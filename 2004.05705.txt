Are Game Engines Software Frameworks? A Three-perspective Study⋆
Cristiano Politowskia,∗, Fabio Petrillob, João Eduardo Montandonc, Marco Tulio Valentec and
Yann-Gaël Guéhéneuca
aConcordia University, Montreal, Quebec, Canada
bUniversité du Québec à Chicoutimi, Chicoutimi, Quebec, Canada
cUniversidade Federal de Minas Gerais, Belo Horizonte, Brazil
A R T I C L E I N F O
Keywords:
Game-engine
Framework
Video-game
Mining
Open-source
Abstract
Game engines help developers create video games and avoid duplication of code and eﬀort, like frame-
works for traditional software systems. In this paper, we explore open-source game engines along three
perspectives: literature, code, and human. First, we explore and summarise the academic literature
on game engines. Second, we compare the characteristics of the 282 most popular engines and the
282 most popular frameworks in GitHub. Finally, we survey 124 engine developers about their expe-
rience with the development of their engines. We report that: (1) Game engines are not well-studied
in software-engineering research with few studies having engines as object of research. (2) Open-
source game engines are slightly larger in terms of size and complexity and less popular and engaging
than traditional frameworks. Their programming languages diﬀer greatly from frameworks. Engine
projects have shorter histories with less releases. (3) Developers perceive game engines as diﬀerent
from traditional frameworks. Generally, they build game engines to (a) better control the environ-
ment and source code, (b) learn about game engines, and (c) develop speciﬁc games. We conclude
that open-source game engines have diﬀerences compared to traditional open-source frameworks al-
though this diﬀerences do not demand special treatments.
1. Introduction
“It’s hard enough to make a game (...). It’s re-
ally hard to make a game where you have to ﬁght
your own tool set all the time.”
— Schreier [1] quoting a game developer on the
diﬃculties faced using their game engine.
For decades, video games have been a joyful hobby for
many people around the world [2], making the game indus-
try multi-billionaire, surpassing the movie and music indus-
tries combined [3]. However, realistic graphics and smooth
gameplays hide constant and non-ending problems with game
development, mostly related to poor software-development
practices and inadequate management [4]. Problems like
these result in a scenario where 80% of the top 50 games
on Steam1 need critical updates [5], also leaving a trail of
burnout developers after long periods of “crunchs”2 [6].
During game development, developers use specialized
software infrastructures to develop their games; chief among
which are game engines. Game engines encompass a myriad
of resources and tools [7–10]. They can be built from scratch
during game development, reused from previous games, ex-
⋆Dataset: https://doi.org/10.5281/zenodo.3606899.
∗Corresponding author
c_polito@encs.concordia.ca (C. Politowski); fabio@petrillo.com
(F. Petrillo); joao.montandon@dcc.ufmg.br (J.E. Montandon);
mtov@dcc.ufmg.br (M.T. Valente); yann-gael.gueheneuc@concordia.ca (Y.
Guéhéneuc)
ORCID(s): 0000-0002-0206-1056 (C. Politowski); 0000-0002-8355-1494
(F. Petrillo); 0000-0002-3371-7353 (J.E. Montandon); 0000-0002-8180-7548
(M.T. Valente); 0000-0002-4361-2563 (Y. Guéhéneuc)
1Steam is a video game digital distribution service platform available
at https://store.steampowered.com/.
2In game development, “crunch time” is the period during which de-
velopers work extra hours to deliver their game in time.
tended from open-source ones, or bought oﬀthe shelves.
They are essential to game development but misunderstood
and misrepresented by the media [11] and developers due to
lacks of clear deﬁnitions, architectural references [12], and
academic studies. They are also the source of problems, es-
pecially between design and technical teams [13, 14].
To address these problems, some researchers suggest the
use of software-engineering techniques [4, 15, 16] while oth-
ers consider game development as a special kind of software
and propose new engineering practices or extensions to clas-
sical ones [17–23]. However, they did not study a large num-
ber of game engines, either proprietary, because only 13% of
all the games on Steam describe their engines [24], or open
source. They also did not survey game engine developers.
Therefore, we set to comparing open-source video-game
engines with traditional open-source software frameworks
can help researchers and developers to understand them bet-
ter. With this article, we want to answer whether game en-
gines share similar characteristics with software frameworks.
By comparing the tools (engines and frameworks) rather than
their instances (video games, traditional software systems),
we provide a distinct view on game development: rather than
studying how developers use games engines, we focus on
how the foundations of their games are built.
We study open-source game engines from three perspec-
tives: literature, code, and human to provide an global view
on the states of the art and practice on game engines. We
explore academic and gray literature on game engines; com-
pare the characteristics of the 282 most popular engines and
the 282 most popular frameworks in GitHub; and, survey
124 engine developers about their experience with the de-
velopment of their engines. Thus, we provide four contri-
butions: (1) a corpus of open-source engines for this and
Politowski et al.: Preprint submitted to Elsevier
Page 1 of 22
arXiv:2004.05705v3  [cs.SE]  19 Sep 2020

Are Game Engines Software Frameworks? A Three-perspective Study
future research work; (2) an analysis and discussion of the
characteristics of engines; (3) a comparison of these char-
acteristics with those of traditional frameworks; and, (4) a
survey of engine developers about their experience with en-
gine development.
We show that, diﬀerent from what researchers and en-
gine developers think, there are qualitative but no quanti-
tative diﬀerences between engines and frameworks. Game
engines are slightly larger in terms of size and complexity
and less popular and engaging than traditional frameworks.
The programming languages of game engines diﬀer greatly
from that of traditional frameworks. game engine projects
have shorter histories with less releases. Developers per-
ceive game engines as diﬀerent from traditional frameworks
and claim that engines need special treatments. Developers
build game engines to better control the environment and
source code, to learn about game engines, and to develop
speciﬁc games. We conclude that open-source game engines
have diﬀerences compared to traditional open-source frame-
works although this diﬀerences, related to community, do
not demand special treatments.
The paper is structured as follows: Section 2 lists the
research questions for all the three perspectives: literature,
code, human. Section 3 shows the results of the literature
perspective. Section 4 described the study design for the
code perspective: metrics, data collection, and analysis. Sec-
tion 6 discusses our results and threats to their validity. Sec-
tion 7 concludes.
In addition, the detailed results are in the Appendix Sec-
tions. Appendix A shows results related to static analysis of
the projects. Appendix B shows the historic analysis of the
projects. Appendix C shows the community analysis of the
projects. Appendix 5 describes our survey of engine devel-
opers for the human perspective.
2. Research Questions
This Section shows the list of research questions and the
metrics used to answer them. An overview of the Perspec-
tives, RQs, and Metrics, is in the Appendix Figure 6. More
details about the metrics are into the Table 1.
2.1. RQ1: Literature Perspective
Although software frameworks are part of the toolset of
most developers nowadays, its concept is often misunder-
stood, specially with libraries3. To better understand the
diﬀerences between frameworks and game engines we ex-
plore the literature perspective using Scopus4, for academic
books and the search engines on internet, for articles, tech-
nical blogs, and discussion forums. In the Section 3 we aim
to answer the following research questions.
• RQ1.1: What is the deﬁnition for software framework?
3We encountered many problems while gathering the dataset as devel-
opers labeled their projects incorrectly; for example, labelling a library a
“framework” or a game an “engine”.
4https://www.scopus.com
• RQ1.2: What is the deﬁnition for game engine?
• RQ1.3: What are the works related to game engines?
2.2. RQ2: Code Perspective
With respect to the design and implementation of game
engines and traditional frameworks, we study their static,
historical, and community characteristics.
RQ2.1: Static Characteristics
To understand the diﬀerences of the frameworks and game
engines projects from a code perspective, we investigate the
static attributes of the projects, like their size, complexity
of the functions, programming languages and licenses used.
In the Section 4.4 (and Appendix A) we aim to answer the
following research questions.
• RQ2.1.1: What is the popularity of the languages in
the projects?
– Metrics: main_language
• RQ2.1.2: What is the popularity of the licenses in the
projects?
– Metrics: license
• RQ2.1.3: What are the project sizes of engines and
frameworks?
– Metrics: main_language_size, total_size, n_files
• RQ2.1.4: What are the function sizes of engines and
frameworks?
– Metrics: n_funcs, nloc_mean, func_per_file_mean
• RQ2.1.5: What are the function complexities of en-
gines and frameworks?
– Metrics: cc_mean
RQ2.2: Historical Characteristics
To explore the historical characteristics of the projects,
we compare the life-cycles of game engines and traditional
frameworks. We analyze the tags released (versions), projects’
lifespan and commits. In the Section 4.5 (and Appendix B)
we aim to answer the following research questions.
• RQ2.2.1: How many versions were released for each
project?
– Metrics: tags_releases_count
• RQ2.2.2: What is the lifetime of the projects?
– Metrics: lifespan
• RQ2.2.3: How frequently do projects receive new con-
tributions?
– Metrics: commits_count, commits_per_time
• RQ2.2.4: Are commits made on game engines more
eﬀort-prone?
– Metrics: lines_added, lines_removed, code_churn
Politowski et al.: Preprint submitted to Elsevier
Page 2 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
RQ2.3: Community Characteristics
To investigate the interactions of the OSS community on
the projects, we analyze the popularity of the projects, the
number of issues reported in these projects, and the truck-
factor measure [25]. In the Section 4.6 (and Appendix C)
we aim to answer the following research questions.
• RQ2.3.1: How many developers contribute in the project?
– Metrics: truck_factor
• RQ2.3.2: How popular are the projects considering
their main languages?
– Metrics: stargazers_count, contributors_count
• RQ2.3.3: How many issues are reported in each project?
– Metrics: issues_count, closed_issues_count,
closed_issues_rate
2.3. RQ3: Human Perspective
The human perspective pertains to the developers’ per-
ception of game engines and of their diﬀerences with tradi-
tional frameworks. We conducted an online survey with de-
velopers of the game engines to understand why they built
such engines and their opinions about the diﬀerences (if any)
between engines and frameworks.
Question 1 contains a predeﬁned set of answers that we
compiled from the literature and from the documentation
and “readme” ﬁles studied during the manual ﬁltering of the
datasets. The respondent could choose one or more answers.
We also provided a free-form text area for developers to pro-
vide a diﬀerent answer and–or explain their answers. With
Question 2, we want to understand whether game engine de-
velopers are also traditional software developers. Finally,
Question 3 collected the developers’ point of views regard-
ing the diﬀerences (or lack thereof) between the develop-
ment of engines and frameworks.
• RQ3.1: What are the reasons developers create open-
source game engines?
– Survey question 1: Why did you create or col-
laborated with a video-game engine project?
∗To help me to create a game
∗To learn how to build an engine
∗To have the full control of the environment
∗Because the existent engines do not provide
the features I need
∗Because I wanted to work with this speciﬁc
programming language
∗Because the licenses of the existent engines
are too expensive
∗Other [please specify]
• RQ3.2: Do game engine developers also have exper-
tise with traditional software?
– Survey question 2: Have you ever written code
for a software unrelated to games, like a Web,
phone, or desktop app? [Yes or No]
• RQ3.3: For game engine developers, is it similar to
developing a traditional framework?
– Survey question 3:How similar do you think writ-
ing a video-game engine is compared to writing
a framework for traditional apps? (Like Django,
Rails, or Vue) – [1 (very diﬀerent) to 5 (very sim-
ilar)]
3. Results from RQ1: Literature Perspective
We study game engines along the literature perspective
by querying both Scopus and the Internet. We report that
only few works on game engines exist: mostly books, few
academic papers. We did not perform a systematic literature
review (SLR) [26] because of the small size of the current
academic literature on the topic, as shown in the following.
RQ1.1: What is the deﬁnition for software
framework?
GitHub uses a set of “topics”5 to classify projects. It de-
ﬁnes the topic “framework” as “a reusable set of libraries
or classes in software. In an eﬀort to help developers fo-
cus their work on higher level tasks, a framework provides a
functional solution for lower level elements of coding. While
a framework might add more code than is necessary, they
also provide a reusable pattern to speed up development.”
Pree [27] deﬁned frameworks as having frozen and hot
spots: code blocks that remain unchanged and others that re-
ceive user code to build the product. Larman [28] observed
that frameworks use the Hollywood Principle, “Don’t call
us, we’ll call you.”: user code is called by the framework.
Taylor [29] sees a framework as a programmatic bridge be-
tween concepts (such as “window” or “image”) and lower-
level implementations. Frameworks can map architectural
styles into implementation and–or provide a foundation for
an architecture.
RQ1.2: What is the deﬁnition for game engine?
ID Software6 introduced the concept of video-game en-
gine in 1993 to refer to the technology “behind the game”
when they announced the game DOOM [7, 30]. In fact, they
invented the game engine around 1991 and revealed the con-
cept around the DOOM press release early 1993 [31].
The invention of this game technology was a discrete
historical event in the early 1990s but it established MS-
DOS 3.3 as a relevant gaming platform, mostly because of
the NES-like horizontal scrolling emulation, allowing devel-
opers to create games similar to the ones on Nintendo con-
sole. It also introduced the separation of game engine from
“assets” accessible to players and thereby revealed a new
paradigm for game design on the PC platform [31], allowing
5https://github.com/topics/framework
6https://www.idsoftware.com
Politowski et al.: Preprint submitted to Elsevier
Page 3 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
players to modify their games and create new experiences.
This concept has since evolved into the “fundamental soft-
ware components of a computer game”, comprising its core
functions, e.g., graphics rendering, audio, physics, AI [30].
John Carmack7, and to a less degree John Romero8, are
credited for the creation and adoption of the term game en-
gine. In the early 90s, they created the ﬁrst game engine to
separate the concerns between the game code and its assets
and to work collaboratively on the game as a team [14, 30].
Also, they “lent” their engines to other game companies to
allow other developers to focus only on game design.
In 2002, Lewis and Jacobson [32] deﬁned game engines
as “collection[s] of modules of simulation code that do not
directly specify the game’s behavior (game logic) or game’s
environment (level data)”. In 2007, Sherrod [10] deﬁned en-
gines as frameworks comprised of diﬀerent tools, utilities,
and interfaces that hide the low-level details of the imple-
mentations of games. Engines are extensible software that
can be used as the foundations for many diﬀerent games
without major changes [7] and are “software frameworks for
game development”. They relieve developers so that they
can focus on other aspects of game development”9. In 2019,
Toftedahl and Engström [24] analysed and divided engines
in four complementary types: (a) Core Game Engine, (b)
Game Engine, (c) General Purpose Game Engine, and (d)
Special Purpose Game Engine.
RQ1.3: What are the works related to game
engines?
There are few academic papers on game engines. Most
recently and most complete, Toftedahl and Engström [24]
analysed the engines of games on the Steam and Itch.io plat-
forms to create a taxonomy of game engines. They high-
lighted the lack of information regarding the engines used in
mainstream games with only 13% of all games reporting in-
formation about their engines. On Steam, they reported Un-
real (25.6%), Unity (13.2%), and Source (4%) as the main en-
gines. On Itch.io, they observed that Unity alone has 47.3%
of adoption among independent developers.
Messaoudi et al. [12] investigated the performance of the
Unity engine in depth and reported issues with CPU and
GPU consumption and modules related to rendering.
Cowan and Kapralos [33] in 2014 and 2016 [34] anal-
ysed the game engines used for the development of serious
games. They identiﬁed few academic sources about tools
used to develop serious games. They showed that “Second
Life”10 is the most mentioned game engine for serious games,
followed by Unity and Unreal. They considered game en-
gines as parts of larger infrastructures, which they call frame-
works and which contain scripting modules, assets, level ed-
itors as well as the engines responsible for sound, graphics,
7John Carmack was the lead programmer and co-founder of id Software
in 1991.
8John Romero was the designer, programmer and also co-founder of id
Software in 1991.
9https://github.com/topics/game-engine
10Second Life is not a game engine per se but a game that can be ex-
tended by adding new “things” through “mod” or “modding”.
physics, and networking. They ranked Unity, Flash, Second
Life, Unreal, and XNA as the most used engines.
Neto and Brega [35] conducted a systematic literature
review of game engines in the context of immersive appli-
cations for multi-projection systems, aiming at proposing a
generic game engine for this purpose.
Wang and Nordmark [36] assumed that game develop-
ment is diﬀerent from traditional software development and
investigated how architecture inﬂuences the creative process.
They reported that the game genre signiﬁcantly inﬂuences
the choice of an engine. They also showed that game-engine
development is driven by the creative team, which request
features to the development team until the game is completed.
They observed that adding scripting capability ease game-
engine development through testing and prototyping.
Anderson et al. [37] raised issues and questions regard-
ing game engines, among which the need for a uniﬁed lan-
guage of game development, the identiﬁcation of software
components within games, the deﬁnition of clear boundaries
between game engines and games, the links between game
genres and game engines, the creation of best practices for
the development of game engines.
Summary for RQ1: Literature Perspective
We could not ﬁnd many academic paper on game
engines or a reliable source for gray literature. We
recommend to extend this work with multivocal lit-
erature review (with academic and grey literature).
4. Results from RQ2: Code Perspective
This section details the method for gathering the data and
the metrics used to answer the set of RQs 2.1, 2.2, and 2.3.
It also introduced the applied statistical techniques. For the
sake of clarity, this section does not provide all the details but
summarises the answers to each set of RQs. The Appendixes
A, B, and C present the detailed results of each set of RQs.
4.1. Method
Figure 1 shows the steps that we followed to mine the
data to answer our questions. In Step 1, on August 8, 2019,
we gathered the top 1,000 projects in GitHub related to the
game-engine and framework topics, separately, storing each
one in a speciﬁc dataset.
In Step 2, we ﬁltered these projects using the following
criteria to remove “noise” and improve the quality of our
dataset, which is a common approach when dealing with
Github repositories [25, 38] to obtain 458 engines and 743
frameworks:
• The project must have more than one contributor;
• The project must have been starred at least twice;
• The last commit must be at least from 2017;
• The project cannot be archived.
Politowski et al.: Preprint submitted to Elsevier
Page 4 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
GitHub
Step 5:
downloading
 the projects
Step 3:
manually
verifying
projects
Step 2:
fitlering
projects
Step 1:
scrapping
projects
Step 6:
calculating the
"truck factor"
Step 7:
calculating the
measurements
by functions
Step 4:
filtering by
languages
(Lizard tool
constraint)
Accepted languages:
C/C++, Java, C#,
JavaScript,
Objective-C, Swift,
Python, Ruby, TTCN-
3, PHP, Scala,
GDScript, Golang,
Lua
Fitler by tag: 
- game-engine, 
- gameengine, 
- game-framework
- framework
Filter by:
- contributors > 1
- stargazers > 1
- archived == "False"
- last_push > "2017"
Criteria:
- Not be a Game/App
- Has documentation
- Not a library/plugin
The number of
developers 
responsible to
efectively 
maintain the project.
The number of
developers 
responsible to
efectively 
maintain the project.
1000
frameworks
(most stared)
1000 engines
(most stared)
473 frameworks
458 engines
348 frameworks
(148 blacklisted)
348 engines
(193 blacklisted)
282 frameworks
282 engines
Engine and
Framework
Database
Figure 1: The process used to gather the data from GitHub projects.
In Step 3, we manually analysed the remaining 458 +
743 = 1, 201 projects to remove those that are neither game
engines nor frameworks according to the deﬁnitions in Sec-
tion 3. We kept 358 game engines and 358 frameworks.
In Step 4, we kept only projects with programming lan-
guage supported by Lizard: C/C++, C#, GDScript, Golang,
Java, JavaScript, Lua, Objective-C, PHP, Python, Ruby, Scala,
Swift, TTCN-3. We had now 282 engines and 282 frame-
works.
In Step 5, we computed the metrics and stored their val-
ues in the datasets, which we describe in details in the fol-
lowing Section 4.2.
In Step 6, we computed the truck-factor of each project,
which is the number of contributors that must quit before a
project is in serious trouble [25, 39].
In Step 7, we used Lizard to gather the average value
of the metrics related to functions. Lastly, we ordered the
projects by popularity: how many “stars” they have.
Figure 2 shows an example containing the Github page
of the engine Godot11. We only consider the main language
of the projects but most projects are composed of multiple
languages. Almost all the code of Godot is written in C++
(93%). Godot is tagged with the “game-engine” topic and,
therefore, was found through our search. Godot is the most
popular engine containing more than 26K votes.
The dataset, scripts and all the material from this study
are in its replication package12.
4.2. Metrics
Deﬁning metrics is challenging. Some authors warn about
problems with simplistic measurements [40] and lack of pre-
cision of tools that make the measurements [41]. However,
imperfect quantiﬁcation is better than none [42].
11https://github.com/godotengine/godot
12https://doi.org/10.5281/zenodo.3606899.
Kaner et al. [40] recommends the use of direct metrics13
but also deﬁnes a framework to described and justify the
metrics. We used a simpliﬁed version of this framework with
six questions: Purpose (What is the purpose of this metric?),
Scope (What is the scope of this metric?), Scale (What is
the natural scale of the attribute we are trying to metric?),
Domain (What is the domain this metric belongs to?), and
Instrument (How the metric will be measured?).
Therefore, to answer the questions RQ2.1: Static Char-
acteristics, RQ2.2: Historical Characteristics, and RQ2.3:
Community Characteristics, we use the set of metrics de-
scribed in Table 1. Also, the following list some details
about some of the metrics.
RQ2.1.1. Metric: main_language – According to Tiobe
index, currently, the most common languages are C, Java,
Python14. Also, GitHub uses Linguistic to determine the
most common language in the project15.
RQ2.1.2. Metric: license – MIT, Apache-2.0, and GPL-
V3 were the most common open source licenses in 201916.
GitHub has a “license picker” allowing the user to choose
from diﬀerent open-source licenses17.
RQ2.1.3. Metrics: main_language_size,
total_size,
n_file – GitHub recommends repositories with less than
1GB, and less than 5GB is strongly recommended. Also
with 100MB maximum ﬁle size limit18.
RQ2.1.4. Metrics: n_func, nloc_mean, func_per_file_mean
–
Lizard19 gives a list of all functions in the project with
13Direct metric is a metric that does not depend upon a measure of any
other attribute.
14https://www.tiobe.com/tiobe-index/
15https://github.com/github/linguist
16https://bit.ly/3f4myu3
17https://bit.ly/32YNOYv
18https://bit.ly/2BDuKns
19https://github.com/terryyin/lizard
Politowski et al.: Preprint submitted to Elsevier
Page 5 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
C
E
A
D
B
Figure 2: Godot engine Github page example. In this case we considered C++ as main language (A) and ﬁltered the projects
with least one commit from 2017 or newer (B) and with more than two contributors (D). Tags, provided by the developers, were
used to search for the engines (C). Finally, we ordered the projects by the stars (E).
NLOC (lines of code without comments) and CCN (cyclo-
matic complexity number). It also gives the list of ﬁles and
the functions’ name (signatures).
RQ2.1.5. Metrics: cc_mean – McCabe’s [43] recommends
keeping the complexity of modules below 10.
RQ2.2.1. Metric tags_releases_count: Within the con-
text of GitHub, a tag is a release of the product.
RQ2.2.2. Metrics commits_count, commits_per_time –
PyDriller is a Python framework to analyze Git reposito-
ries20.
RQ2.2.4. Metrics: lines_added, lines_removed, code_churn
–
Code churn measures the number the amount of code
changes occurred during development of code [44]. We use
the sum of deleted and removed lines.
RQ2.3.1. Metric: truck_factor – According to Avelino
et al. [25], truck-factor is the number of people on the team
that have to be hit by a truck before the project becomes prob-
lematic. Therefore, systems with low truck-factor have prob-
lems with strong dependency of certain developers. Linux
has truck-factor of 57 and Git 12. We used a library deﬁned
by Avelino et al. [25] as instrument.
RQ2.3.2. Metrics: stargazers_count – “vuejs” is the
most stared github opensource software project with more
than 169K21. In 2019, “microsoft/vscode” had the highest
number of contributors with 19.1K22.
4.3. Analysis
We used the statistical-analysis workﬂow-model for em-
pirical software-engineering research [45] to test statistically
the diﬀerences between engines and frameworks. For each
continuous variable, we used descriptive statistics in the form
of tables with mean, median, min, and max values, together
with boxplots. For the boxplots, to better show the distribu-
tions, we removed outliers using the standard coeﬃcient of
20https://github.com/ishepard/pydriller
21https://github.com/vuejs/vue
22https://octoverse.github.com/
1.5 (푄3+1.5×퐼푄푅). We observed outliers for all the mea-
sures, with medians skewed towards the upper quartile (Q3).
To check for normality, we applied the Shapiro test [46] and
checked visually using Q–Q plots. Normality < 0.05 means
the data is not normally distributed. Finally, given the data
distribution, we applied the appropriate statistical tests and
computed their eﬀect sizes.
4.4. Results for RQ2.1: Static Characteristics
Table 2 shows the results of Wilcoxon tests. The p-values
< 0.01 indicate that the distributions are not equal and there
is a signiﬁcant diﬀerence between engines and frameworks,
although this diﬀerence is small. The biggest eﬀects are re-
lated to source code metrics, i.e., nloc_mean and cc_mean.
The implementation of game engines and traditional frame-
works are diﬀerent but without statistical signiﬁcance. En-
gines are bigger and more complex than frameworks. They
use mostly compiled programming languages vs. interpreted
ones for frameworks. They both often use the MIT license.
4.5. Results for RQ2.2: Historical Characteristics
Overall, all metrics have similar median values when
comparing both groups, except for tags_releases_count. In
fact, engines releases way less versions (median is one) than
frameworks (median is 32).
Table 3 shows the results of Wilcoxon tests, showing
large diﬀerences for all historical measures except lines_added,
lines_removed, and code_churn. Versioning does not look
like a well-followed practice in engine development, with
few versions compared to frameworks. Commits are less
frequent and less numerous in engines, which are younger
and have shorter lifetimes when compared to frameworks.
4.6. Results for RQ2.3: Community
Characteristics
Table 4 shows the results of Wilcoxon tests, indicating a
large diﬀerence in all measures related to community. The
truck-factor shows that the majority of the projects have few
contributors. Some uncommon languages, like Go and C#,
are popular compared to others in more prevalent projects,
e.g., C++ and JavaScript.
Politowski et al.: Preprint submitted to Elsevier
Page 6 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
Table 1
Description of the Metrics for the Code Perspective (Rqs 2, 3, and 4). We adapted the framework deﬁned by Kaner et al. [40].
RQs
Purpose
Scope
Metric
Scale
Domain
Instrument
RQ2.1.1 Verify what is the most
common main languages
by the projects
Project
main_language
Nominal
Programming languages
API
GraphQL
(V4)
RQ2.1.2 Verify what is the most
common licenses used by
the projects
Project
license
Nominal
Source code licenses
API
GraphQL
(V4)
RQ2.1.3 Verify the project size
Project
main_language_size
Ratio
Positive
rational
num-
bers (Q)
API GraphQL
(V4)
total_size
Ratio
Positive
rational
num-
bers (Q)
n_ﬁle
Ratio
Natural numbers (N)
RQ2.1.4 Verify the function size
Function
n_func
Ratio
Natural numbers (N)
Lizard
nloc_mean
Ratio
Positive
rational
num-
bers (Q)
func_per_ﬁle_mean
Ratio
Positive
rational
num-
bers (Q)
RQ2.1.5 Verify the complexity of
the function
Function
cc_mean
Ratio
Natural numbers (N)
Lizard
RQ2.2.1 Verify the release strategy
of the project
Project
tags_releases_count
Ratio
Natural numbers (N)
API
GraphQL
(V4)
RQ2.2.2 Verify the lifetime of the
project
Project
lifespan
Ratio
Natural numbers (N)
API
GraphQL
(V4)
RQ2.2.3 Verify the contributions
to the project
Commits
commits_count
Ratio
Natural numbers (N)
Pydriller
commits_per_time
Ratio
Positive
rational
num-
bers (Q)
RQ2.2.4 Very the eﬀort made in
the projects
Commits
lines_added
Ratio
Natural numbers (N)
Pydriller
lines_removed
Ratio
Natural numbers (N)
code_churn
Ratio
Natural numbers (N)
RQ2.3.1 Verify the contribution of
the project
Contributors truck_factor
Ratio
Natural numbers (N)
Library Avelino
et. al.
RQ2.3.2 Verify the popularity of
the project
Project
stargazers_count
Ratio
Natural numbers (N)
API GraphQL
(V4)
contributors_count
Ratio
Natural numbers (N)
RQ2.3.3 Verify the how developers
deal with issues in the
project
Issues
issues_count
Ratio
Natural numbers (N)
API GraphQL
(V4)
closed_issues_count
Ratio
Natural numbers (N)
closed_issues_rate
Ratio
Positive
rational
num-
bers (Q)
Summary for RQ2: Code Perspective
We observed that, although static characteristics of
game engines and frameworks are similar, the com-
munity of these projects diﬀer. Also, historical as-
pects are mixed, as engines have a smaller lifespan
and less releases, yet similar eﬀort on commits con-
tribution and code churn.
5. Results from RQ3: Human Perspective
We now discuss developers’ own perception of game en-
gines and of their diﬀerences with traditional frameworks.
We used an online form to contact developers over a period
of three days. We sent e-mails to 400 developers of the game
engines in our dataset, using the truck-factor of each project:
developers who collaborate(d) most to the projects. We re-
ceived 124 responses, i.e., 31% of the developers. The sur-
vey, answers, and scripts for their analyses are in the repli-
Politowski et al.: Preprint submitted to Elsevier
Page 7 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
Table 2
Statistical Tests, RQ2.1: Static Characteristics
Variable
P-value
Estimate
Eﬀect
main_language_size
<0.01
0.28
0.189 (small)
total_size
<0.01
0.34
0.188 (small)
n_ﬁle
<0.01
45.00
0.155 (small)
n_func
<0.01
769.00
0.211 (small)
nloc_mean
<0.01
2.12
0.297 (small)
func_per_ﬁle_mean
<0.01
3.13
0.208 (small)
cc_mean
<0.01
0.53
0.356 (small)
Table 3
Statistical Tests, RQ2.2: Historical Characteristics
Variable
P-value
Estimate
Eﬀect
tags_releases_count
<0.01
-24.00
-0.613 (large)
lifespan
<0.01
-56.29
-0.32 (large)
commits_count
<0.01
-175.00
-0.198 (large)
commits_per_time
<0.01
-0.30
-0.198 (large)
lines_added
<0.01
134.47
0.219 (small)
lines_removed
<0.01
48.83
0.168 (small)
cchurn_delta
<0.01
153.88
0.224 (small)
cchurn_sum
<0.01
222.48
0.212 (small)
Table 4
Statistical Tests, RQ2.3: Community Characteristics
Variable
P-value
Estimate
Eﬀect
stargazers_count
<0.01
-358.00
-0.511 (large)
contributors_count
<0.01
-9.00
-0.459 (large)
truck_factor
0.01
<0.01
-0.138 (large)
issues_count
-139.00
<0.01
-0.451 (large)
closed_issues_count
-122.00
<0.01
-0.459 (large)
closed_issues_rate
-0.05
<0.01
-0.27 (large)
cation package12.
Question 1: Why did you create or collaborated
with a video-game engine project?
Figure 3 shows the breakdown of the developers’ an-
swers. Having access to the source code, freedom to de-
velop, etc., i.e., control of the environment, is the developers’
major reason for working on a game engine while learning to
build an engine is the second reason; explaining why many
engines have few developers and commits.
The third reason is to build a game, conﬁrming the lack
of clear separation between developers and game designers.
It is indeed common for game developers to act also as game
designers, specially in independent games, e.g., the single
developer of Stardew Valley23.
The next answer is about working with a speciﬁc lan-
guage, also related with learning: when learning a new lan-
guage, developers want to apply or test their knowledge on
some projects, and game engines are interesting candidates.
23https://www.stardewvalley.net/
23%
22%
19%
14%
12%
4%
Because the licenses of the existent
engines are too expensive
Because the existent engines do not
provide the features I need
Because I wanted to work with this
especific programming language
To help me to create a game
To learn how to build an engine
To have the full control of the
environment
0
20
40
60
80
Frequency
Figure 3: Answers to Question 1: Why did you create or col-
laborated with a video-game engine project?
Also related to the environment, the next answer con-
cerns the features oﬀered by existing engines: reusing or cre-
ating a new engine may be necessary for certain, particular
games with speciﬁc requirements. Developers think as game
designers: the game concept(s) may require a new engine.
The engine licenses are the least concern: fees and taxes
from vendors, e.g., Unreal and Unity, are not important to
developers because some licenses are “indie” friendly and
oﬀer low rates for indie games [24].
Finally, 19 developers provided “Other” answers: they
work on game engines because “it is fun” and–or they have
access to some source code, e.g., one developer who reverse-
engineered a proprietary engine wrote:
“The source for the original engine was propri-
etary and so we opened the platform by reverse-
engineering it then re-implementing under GPL3.”
Other answers include performance, platform compati-
bility, new experimental features, and creating a portfolio.
Question 2: Have you ever written code for a
software unrelated to games, like a Web, phone, or
desktop app?
The great majority of developers, 119 of the 124 respon-
dents (96%), have experience with traditional software. The
respondents can be considered general software developers
with expertise in engine development.
Question 3: How similar do you think writing a
video-game engine is compared to writing a
framework for traditional apps? (Like Django,
Rails, or Vue)
Figure 4 shows that engine developers consider engines
diﬀerent from frameworks: 59% of the respondents believe
Politowski et al.: Preprint submitted to Elsevier
Page 8 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
that engines follows a diﬀerent process from frameworks.
Only 20% believe this this process is similar. This is a sur-
prising result as they also have experience in developing tra-
ditional software.
30%
29%
21%
16%
4%
0
10
20
30
Very different
4
3
2
Very similar
Difference Levels
Frequency
Figure 4: Answers to Question 3: How similar do you think
writing a video-game engine is compared to writing a frame-
work for traditional apps? (Like Django, Rails, or Vue)
Summary for RQ3: Human Perspective
The developers’ main reasons to work on an engine
is (a) having better control over the environment and
source code, (b) learning game-engine development,
and (c) helping develop a speciﬁc game. Almost all
the engine developers have experience with tradi-
tional software. They consider these two types of
software as diﬀerent.
6. Discussions
We now discuss the results of our study of engines along
the three perspectives.
6.1. Perils for Engines and Frameworks
Kalliamvakou et al. [47] analysed developers’ usages of
GitHub and reported a set of perils and promises related to
GitHub projects. Table 5 shows the perils applying to the
objects of our study: engines and frameworks. The perils 7,
8 (about pull-requests), and 9 (activity outside GitHub) are
out of scope of our dataset.
In Peril 1, the authors distinguished forks and base repos-
itories. In our search, we observed that most repositories are
base ones. We found few forks that we removed during the
manual ﬁltering. Therefore, this peril is false for both en-
gines and frameworks.
In Peril 2, the authors reported that the median of com-
mits were 6, with 90% of the projects having less than 50
commits. We observed that the engines and frameworks in
our dataset have medians of 616 and 833 commits, respec-
tively, as shown in Table 9.
Peril 3 does not apply to our dataset as the projects have
a median of one commit per week and because we removed
projects with more than two years without commits.
For Peril 4, the authors found that about 10% of the de-
velopers used GitHub for storage. This is partially true for
Table 5
Perils of Github repositories adapted from Kalliamvakou et al.
[47]. Perils 7, 8, and 9 do not pertain to this work.
#
Perils
Eng.
Fram.
1
A
repository
is
not
necessarily
a
project.
False
False
2
Most projects have very few commits.
False
False
3
Most projects are inactive.
False
False
4
A large portion of repositories are not
for software development.
True
False
5
Two thirds of projects (71.6% of repos-
itories) are personal.
True
False
6
Only a fraction of projects use pull re-
quests. And of those that use them,
their use is very skewed.
True
True
our dataset: we found engine repositories that were used
mostly to store assets, documentation, and other ﬁles.
Peril 5 is present in this study, speciﬁcally in game en-
gine projects: although we removed engines with less than 2
contributors, we found many warnings in read-me ﬁles stat-
ing that an engine was only for “personal use”, an “unﬁn-
ished project”, or for “educational purposes” only.
Peril 6 is true for all projects. The number of pull re-
quests for engines is lower than that for frameworks: at least
50% of the engine projects have at least 10 closed pull re-
quests, while frameworks have 100s.
In general, the perils found in any repositories in GitHub
do not apply to our dataset. Engines and frameworks seem
diﬀerent to the projects studied by Kalliamvakou et al. [47].
6.2. Discussion of RQ1: Literature Perspective
In theory, game engines and frameworks have similar ob-
jectives: they are modular platforms for reuse that provide
a standard way to develop a product, lowering the barrier of
entry for developers by abstracting implementation details.
We could classify frameworks in diﬀerent categories, ac-
cording to their domains, e.g., Web apps, mobile apps, AI,
etc. In a same category and across categories, two frame-
works are not the same. They provide their functionalities
in diﬀerent ways. Similarly, game engines also belong to
diﬀerent categories and are diﬀerent from one another. For
example, 3D or 2D and speciﬁc for game genres, like plat-
former, shooter, racing, etc.
Traditional frameworks provide business services while
game engines support entertaining games [16]. The process
of ﬁnding the “fun factor” is exclusive to game development
[19, 21] but do not exempt developers from using traditional
software-engineering practices [4, 48]. Game engines are
tools that help game developers to build games and, there-
fore, are not directly concerned with non-functional require-
ments of games, such as “being fun”.
Figure 5 shows the relationship between game engines,
games, frameworks, and traditional software: a video game
is a product built on top of a engine, like a Web app is built
on top of a Web framework. Engines are a speciﬁc kind of
Politowski et al.: Preprint submitted to Elsevier
Page 9 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
framework used to build games. Everything described is a
software: Scrumpy24 is a Web app written with Vue while
Dota 225 is a game made with Source.
is a
is a
Framework
is a
Software
is a
is a
Web Framework
is a
Game Engine
made by
is a
Web Application
made by
is a
Video Game
Figure 5: Semantic relationship between software, framework,
and product.
6.3. Discussion of RQ2: Code Perspective
6.3.1. RQ2.1: Static Characteristics
Diﬀerences in Programming Languages. There is a dis-
crepancy between the languages used in game engines, which
belong mostly to the C family, and frameworks, developed
mostly with interpreted languages. We explain this diﬀer-
ence as follows: engines must work close to the hardware
and manage memory for performance. Low-level, compiled
languages allow developers to control fully the hardware and
memory. Frameworks use languages providing higher-level
abstractions, allowing developers to focus on features. Frame-
works and engines are tools on which developers build their
products, who choose the most eﬀective language for their
needs.
This observation highlights the needs for performance
in engines, through low-level communication with hardware
and memory. With the rise of WebAssembly26 and the pos-
sibility of running compiled code in Web browsers, this ob-
servation could change in the near future.
We explain the predominance of C++ for engines by a
set of features of this language: abstraction, performance,
memory management, platforms support, existing libraries,
and community. These features together make C++ a good
choice for game developers.
Engines are usually written (or extended) via their main
programming language. However, to ease the design, im-
plement, test workﬂow during production, game developers
often add scripting capabilities to their engines. Therefore,
when writing a game, game developers may not code directly
with low-level languages but use scripts; sometimes with in
a speciﬁc domain-speciﬁc language. For example, Unity, al-
though written in C++, oﬀers scripting capabilities in C#27
for game developers to build their games. Furthermore, the
24https://scrumpy.io
25http://blog.dota2.com
26https://webassembly.org/
27https://docs.unity3d.com/Manual/ScriptingSection.html
developer can, possible, ﬁnish its game just using this high
level language. For any further extension in the game en-
gine they will need to deal with the low level language. On
the other hand, frameworks rarely oﬀer scripting capabili-
ties: their products are often written in the same program-
ming languages.
Similarities in Licenses. The MIT License is the most
used license by both open-source frameworks and open-source
engines because it allows reusing and distributing source and–
or compiled code in open or proprietary products, with or
without changes. Developers can use such these frameworks
and engines to create and distribute their software and games
without restriction. Also, they can extend or change the code
without having to share their intellectual property.
Similarities in Sizes and Complexities. Our results show
small diﬀerences in sizes and complexities between engines
and frameworks, yet not enough to consider engines diﬀerent
from frameworks.
The size of a piece of code is a simplistic proxy to its
quality. Also, regarding the languages and numbers of ﬁles,
we expected that larger values for frameworks, given the
numbers of conﬁguration ﬁles and testing functions. How-
ever, we reported that engines are larger in all cases, al-
though by a small margin.
The complexities of the functions was another surprise
given the large number of small engines: engines are more
complex, although by a small diﬀerence.
6.3.2. RQ2.2: Historical Characteristics
Our results showed that 40% of the engines do not have
tags, which could mean that they are still under development
and no build is available.
However, our dataset contains the most important game
engines on GitHub, thus there should be other reasons for
the lack of engine releases. During our manual analysis,
we found engines with warning messages alerting that they
were incomplete, lacking some essential features. Also, we
observed that about one third of the engines have only two
collaborators. This fact combined with the complexity of
engines could explain the diﬃculty to release a ﬁrst feature-
complete version.
Frameworks are released more often than engines with
more commits performed more regularly. There are thus
meaningful diﬀerences between engines and frameworks, which
could be explained by the higher popularity of the frame-
works (see next section).
6.3.3. RQ2.3: Community Characteristics
Diﬀerences in Truck Factor. The truck-factor is 1 for most
of the engines (83%). Lavallée and Robillard [49] consid-
ered that, in addition to being a threat to a project survival,
a low truck-factor causes also delays, as the knowledge is
concentrated in one developer only. This concentration fur-
ther limits adoption by new developers. We believe that low
truck-factor values are due to the nature of the engines, i.e.,
side/hobby projects. In contrast, popular frameworks do not
Politowski et al.: Preprint submitted to Elsevier
Page 10 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
have such a dependency on single developers.
Diﬀerences in Community Engagement. We assumed that
the numbers of stars for projects in GitHub are a good proxy
for their popularity [50]. Surprisingly, engines written in Go
and frameworks written in C# are most popular, even though
their total numbers are low. JavaScript and C are second and
third, respectively. Java is barely present despite its age and
general popularity.
6.4. Closed-Source vs. Open-Source Game
Engines
The great majority of commercial games are written with
proprietary, closed-source game engines. Recently, an eﬀort
for building a robust and powerful open-source game engine
became popular with the Godot project. The Godot game
engine was thus used by many indie games28, some of them
of high quality29.
Open-source tools for game development had a promis-
ing start with Doom and its engine. However, the game
industry took another route and closed-source engines are
commonplace nowadays. Despite the diﬀerence in popular-
ity between open-source game engines and traditional, open-
source frameworks, we believe that open-source is the right
path to follow. It democratizes and allow a soft learning
curve for beginners. Also, it will allow the creation of more
diverse games.
6.5. Threats to Validity
Our results are subject to threat to their internal, con-
struct, and external validity.
Internal Validity. We related engines and frameworks with
static and historical measures. As previous works, we as-
sumed that these measures represent the characteristics that
they measure as perceived by developers. It is possible that
other measures would be more relevant and representative
for developers’ choices and perceptions. We mitigated this
threat by exploring diﬀerent perspectives: literature, code,
and human. Also, we divided measures along diﬀerent as-
pects (static, historical, and community).
Construct Validity. We assumed that we could compare
fairly projects in diﬀerent programming languages, for dif-
ferent domains, and with diﬀerent purposes, as in various
previous studies. We claim that diﬀerent projects can be
compared by considering these projects from three diﬀerent
perspectives: literature, code, and human.
External Validity. We studied only open-source projects
accessible to other researchers and to provide uniquely iden-
tifying information. We also shared on-line12 all the col-
lected data to mitigate this threat by allowing others to study,
reproduce, and complement our results.
28https://itch.io/games/made-with-godot
29https://youtu.be/UEDEIksGEjQ
Conclusion Validity. We did not perform a systematic lit-
erature review integrating gray literature available on the In-
ternet. We accept this threat and plan a multivocal literature
review in future work. Our study of the literature conﬁrmed
that game engines are little studied in academia.
The higher popularity of the frameworks is a concern:
the numbers of contributors are larger and could lead to un-
fair comparisons. We ordered the dataset by the most popu-
lar frameworks and engines, so we expected such eﬀect. In
the future, we will improve the categorization of our dataset
by separating frameworks and engines based on their do-
mains (Web, security, etc., and 2D and 3D games, etc.).
We mined the dataset using the tags of GitHub with which
developers classify their projects. For game engines, we
used some variations like game engine, game-engine, or ga-
meengine. We may have missed some projects if developers
did not use relevant, recognisable tags. For example, the
game engine Piston30, written in Rust by 67 contributors,
is not part of our dataset because it was tagged as “piston,
rust, modular-game-engine”. However, we claim that such
engines are rare and their absence does not aﬀect our results
based on 282 engines and 282 frameworks.
Regarding our survey, Question 3 is broad and could have
mislead developers. Although the requirements are diﬀer-
ent, developers are still creating the building blocks that will
serve to build a product. We mitigated this threat through
Questions 1 and 2 and the other two perspectives.
Even after ﬁltering out projects with at less than two con-
tributors, most of the open-source engines are, in fact, per-
sonal projects. A few, popular, open-source game engines
are used by the majority of the released games. In general,
commercial games are built using proprietary/closed-source
engines (Unity and Unreal). In future work, we could use
other metrics to ﬁlter the projects than their numbers of con-
tributors and stars; for example, the numbers and stars of the
games released using these engines.
Our conclusions, in particular those stemming from RQ2
and RQ3, depend on the users of the analysed projects: a
project with a larger user base would certainly receive more
bug reports, see more commits and more contributions, etc.
Therefore, comparing the top frameworks, which are cer-
tainly used in dozens of others projects, and the top game
engines, which are mostly “personal” projects, could be un-
fair to game engines. We must accept this threat in the ab-
sence of means to obtain statistics on the user base of GitHub
projects. Future work includes possibly using GitHub In-
sights on a selected set of projects in collaboration with their
developers’ teams.
Finally, we acknowledge that a great part of game-engine
development is closed-source. Therefore, these results might
not generalize to game engines overall but should hold true
to open-source game engines.
30https://github.com/PistonDevelopers/piston
Politowski et al.: Preprint submitted to Elsevier
Page 11 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
7. Conclusion
This paper is a step towards conﬁrming that software-
engineering practices apply to game development given their
commonalities. It investigated open-source game engines,
which form the foundation of video games, and compared
them with traditional open-source frameworks. Frameworks
are used by developers to ease software development and to
focus on their products rather than on implementation de-
tails. Similarly, game engines help developers create video
games and avoid duplication of code and eﬀort.
We studied open-source game engines along three per-
spectives: literature, code, and human. Our literature re-
view showed a lack of academic studies about engines, espe-
cially their characteristics and architectures. Yet, we showed
that, diﬀerent from what researchers and engine developers
think, there are qualitative but no quantitative diﬀerences
between open-source engines and open-source frameworks.
Hence, game engines must be an object of study in software-
engineering research in their own right.
We divided the code perspective into three points of view:
static code (RQ2.1), history of the projects (RQ2.2), and of
their community characteristics (RQ2.3). We studied 282
engines and 282 frameworks from GitHub and contributed
with the ﬁrst corpus of curated open-source engines12. We
reported no signiﬁcant diﬀerence between engines and frame-
works for size and complexity but major diﬀerences in terms
of popularity and community engagement. The program-
ming languages adoption diﬀered greatly also with engines
mostly written in C, C++, and C# and frameworks mostly
in JavaScript, PHP, and Python. We observed that engines
have shorter histories and fewer releases than frameworks.
Finally, our survey results showed that engine develop-
ers have also experience in developing traditional software
and that they believe that game engines are diﬀerent from
frameworks. The developers’ objectives for developing en-
gines are (a) better control the environment and source code,
(b) learn, and (c) develop speciﬁc games.
We conclude that open-source game engines share
similarities with open-source frameworks, mostly
regarding their concepts, code characteristics, and
contribution eﬀort. Yet, while engines projects are
mainly personal, the communities around frame-
work projects are larger, with longer lifespans, more
releases, better truck-factor, and more popularity.
Therefore,
engine developers should adopt the
similar software code-quality toolkit when dealing
with code. Finally, the low truck-factor and smaller
user-base suggests that more care should be given to
the documentation of the open-source engines.
We will also consider contacting a subset of the top projects
and work with their developers’ teams so that they install
GitHub Insights, which would provide further information
on the projects, unavailable at the moment when analysing
GitHub data as “outsiders” to the projects.
Some engines appears suitable for a deeper investiga-
tion of their core architectures. The outliers are good can-
didates to ﬁnd anti-patterns related to engines and frame-
works. While Gregory [7] presented a complex description
of the architecture of an engine, it would be interesting to
see how a real, successful engine architecture is similar to
the one proposed by the author. Also, we did not discuss in
details the most popular, closed-source engines: Unity and
Unreal. We could also study the diﬀerences between engines
and frameworks regarding their workﬂow to reveal new dif-
ferences between both types of software. Finally, further in-
vestigate engines and frameworks communities (developers’
turnover and how teams are geo-dispersed) as well as why
and how these projects choose their languages.
Acknowledgement
The authors thank all the anonymous developers for their
time. The authors were partly supported by the NSERC Dis-
covery Grant and Canada Research Chairs programs.
Politowski et al.: Preprint submitted to Elsevier
Page 12 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
References
[1] Jason Schreier. How bioware’s anthem went wrong. https://kotaku.
com/how-biowares-anthem-went-wrong-1833731964, 2019.
Accessed:
2019-04-03.
[2] Entertainment Software Association - ESA.
Esa’s essential facts
about the computer and video game industry report, 2019. [Online;
accessed 7-February-2019].
[3] Newzoo.
2019
global
games
market
re-
port.
https://newzoo.com/insights/trend-reports/
newzoo-global-games-market-report-2019-light-version/,
2019.
[Online; accessed 1-October-2019].
[4] Fábio Petrillo, Marcelo Pimenta, Francisco Trindade, and Carlos Di-
etrich.
What went wrong? a survey of problems in game devel-
opment. Computers in Entertainment, 7(1):1, February 2009. doi:
10.1145/1486508.1486521.
[5] Dayi Lin, Cor Paul Bezemer, and Ahmed E. Hassan. Studying the ur-
gent updates of popular games on the Steam platform. Empirical Soft-
ware Engineering, 22(4):2095–2126, 2017. ISSN 1573-7616. doi:
10.1007/s10664-016-9480-2.
[6] Henrik Edholm, Mikaela Lidstrom, Jan-Philipp Steghofer, and Hakan
Burden. Crunch Time: The Reasons and Eﬀects of Unpaid Over-
time in the Games Industry.
In 2017 IEEE/ACM 39th Interna-
tional Conference on Software Engineering: Software Engineering
in Practice Track (ICSE-SEIP), pages 43–52. IEEE, May 2017. ISBN
9781538627174. doi: 10.1109/icse-seip.2017.18.
[7] Jason Gregory. Game Engine Architecture, Second Edition. A. K.
Peters, Ltd., Natick, MA, USA, 2nd edition, 2014. ISBN 1466560010,
9781466560017.
[8] A. Thorn.
Game Engine Design and Implementation.
Founda-
tions of game development. Jones & Bartlett Learning, 2011. ISBN
9780763784515.
[9] Jason Hughes. What to look for when evaluating middleware for in-
tegration. In Eric Lengyel, editor, Game Engine Gems 1, pages 3–10.
Jones and Bartlett, 2010.
[10] A. Sherrod.
Ultimate 3D Game Engine Design & Architecture.
Charles River Media game development series. Charles River Media,
2007. ISBN 9781584504733.
[11] Jason
Schreier.
The
controversy
over
bethesda’s
’game
engine’
is
misguided.
https://kotaku.com/
the-controversy-over-bethesdas-game-engine-is-misguided-1830435351,
2018. Accessed: 2019-02-06.
[12] Farouk Messaoudi, Gwendal Simon, and Adlen Ksentini. Dissect-
ing games engines: The case of Unity3D. Annual Workshop on Net-
work and Systems Support for Games, 2016-January:1–6, 2016. ISSN
2156-8146. doi: 10.1109/NetGames.2015.7382990.
[13] J. Schreier. Blood, Sweat, and Pixels: The Triumphant, Turbulent
Stories Behind How Video Games Are Made. HarperCollins, 2017.
ISBN 9780062651242.
[14] D. Kushner. Masters of Doom: How Two Guys Created an Empire and
Transformed Pop Culture. Random House Publishing Group, 2003.
ISBN 9781588362896.
[15] Fabio Petrillo and Marcelo Pimenta. Is agility out there?
In Pro-
ceedings of the 28th ACM International Conference on Design of
Communication - SIGDOC 10, pages 9–15. ACM Press, 2010. doi:
10.1145/1878450.1878453.
[16] Jussi Kasurinen, Maria Palacin-Silva, and Erno Vanhala. What con-
cerns game developers? a study on game development processes, sus-
tainability and metrics. In 2017 IEEE/ACM 8th Workshop on Emerg-
ing Trends in Software Metrics (WETSoM), pages 15–21. IEEE, May
2017. doi: 10.1109/wetsom.2017.3.
[17] Sami Hyrynsalmi, Eriks Klotins, Michael Unterkalmsteiner, Tony
Gorschek, Nirnaya Tripathi, Leandro Bento Pompermaier, and Rafael
Prikladnicki. What is a Minimum Viable (Video) Game? In 17th IFIP
WG 6.11 Conference on e-Business, e-Services, and e-Society, I3E
2018, volume 11195, pages 217–231. Springer-Verlag GmbH, Octo-
ber 2018. ISBN 3030021300. doi: 10.1007/978-3-030-02131-3.
[18] Emerson Murphy-Hill, Thomas Zimmermann, and Nachiappan Na-
gappan.
Cowboys, Ankle Sprains, and Keepers of Quality: How
is Video Game Development Diﬀerent from Software Development?
Proceedings of the 36th International Conference on Software Engi-
neering, pages 1–11, 2014. doi: 10.1145/2568225.2568226.
[19] Chris Lewis and Jim Whitehead. The whats and the whys of games
and software engineering. In Proceeding of the 1st international work-
shop on Games and software engineering - GAS 11, pages 1–4. ACM
Press, 2011. ISBN 9781450305785. doi: 10.1145/1984674.1984676.
[20] Christopher M. Kanode and Hisham M. Haddad. Software engineer-
ing challenges in game development. In 2009 Sixth International Con-
ference on Information Technology: New Generations, pages 260–
265. IEEE, 2009. ISBN 9780769535968. doi: 10.1109/itng.2009.74.
[21] David Callele, Philip Dueck, Krzysztof Wnuk, and Peitsa Hynninen.
Experience requirements in video games: Deﬁnition and testability.
2015 IEEE 23rd International Requirements Engineering Conference,
RE 2015 - Proceedings, pages 324–333, 2015. doi: 10.1109/RE.2015.
7320449.
[22] Rido Ramadan and Bayu Hendradjaya. Development of game testing
method for measuring game quality. In 2014 International Confer-
ence on Data and Software Engineering (ICODSE), pages 1–6. IEEE,
November 2014. ISBN 9781479979967. doi: 10.1109/icodse.2014.
7062694.
[23] Maxim Mozgovoy and Evgeny Pyshkin. A comprehensive approach
to quality assurance in a mobile game project. In Proceedings of the
14th Central and Eastern European Software Engineering Conference
Russia on ZZZ - CEE-SECR 18, pages 1–8. ACM Press, 2018. ISBN
9781450361767. doi: 10.1145/3290621.3290835.
[24] Marcus Toftedahl and Henrik Engström. A Taxonomy of Game En-
gines and the Tools that Drive the Industry. In Proceedings of the
2019 DiGRA International Conference: Game, Play and the Emerg-
ing Ludo-Mix, pages –, 2019.
[25] G. Avelino, L. Passos, A. Hora, and M. T. Valente. A novel approach
for estimating truck factors. In 2016 IEEE 24th International Con-
ference on Program Comprehension (ICPC), pages 1–10, May 2016.
doi: 10.1109/ICPC.2016.7503718.
[26] Barbara A. Kitchenham.
Systematic review in software engineer-
ing: Where we are and where we should be going. In Proceedings
of the 2nd International Workshop on Evidential Assessment of Soft-
ware Technologies, EAST ’12, pages 1–2. Association for Comput-
ing Machinery, 2012. ISBN 9781450315098. doi: 10.1145/2372233.
2372235.
[27] Wolfgang Pree.
Meta patterns—a means for capturing the essen-
tials of reusable object-oriented design. In European Conference on
Object-Oriented Programming, pages 150–162. Springer, 1994.
[28] Craig Larman. Applying UML and patterns: an introduction to ob-
ject oriented analysis and design and interative development. Pearson
Education India, 2012.
[29] Richard N. Taylor. Only the architecture you need. In Volker Gruhn
and Rüdiger Striemer, editors, The Essence of Software Engineering,
pages 77–89. Springer International Publishing, Cham, 2018. ISBN
978-3-319-73897-0. doi: 10.1007/978-3-319-73897-0_5.
[30] Henry Lowood and Raiford Guins.
Debugging Game History:
A Critical Lexicon.
The MIT Press, 2016.
ISBN 0262034190,
9780262034197.
[31] Henry Lowood. Game Engines and Game History. Kinephanos: His-
tory of Games International Conference Proceedings, pages 179–98,
January 2014.
[32] Michael Lewis and Jeﬀrey Jacobson. Introduction. Communications
of the ACM, 45(1):27–31, January 2002. ISSN 0001-0782. doi: 10.
1145/502269.502288.
[33] Brent Cowan and Bill Kapralos. A survey of frameworks and game
engines for serious game development. In 2014 IEEE 14th Interna-
tional Conference on Advanced Learning Technologies, pages 662–
664. IEEE, July 2014. ISBN 9781479940387. doi: 10.1109/icalt.
2014.194.
[34] Brent Cowan and Bill Kapralos. An overview of serious game en-
gines and frameworks. In Anthony Lewis Brooks, Sheryl Brahnam,
Bill Kapralos, and Lakhmi C. Jain, editors, Recent Advances in Tech-
nologies for Inclusive Well-Being, pages 15–38. Springer Interna-
Politowski et al.: Preprint submitted to Elsevier
Page 13 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
tional Publishing, 2017. ISBN 978-3-319-49879-9. doi: 10.1007/
978-3-319-49879-9_2.
[35] Mario Popolin Neto and Jose Remo Ferreira Brega.
A survey of
solutions for game engines in the development of immersive appli-
cations for multi-projection systems as base for a generic solution
design. In 2015 XVII Symposium on Virtual and Augmented Real-
ity, pages 61–70. IEEE, May 2015.
ISBN 9781467372046.
doi:
10.1109/svr.2015.16.
[36] Alf Inge Wang and Njål Nordmark. Software architectures and the
creative processes in game development.
In Konstantinos Chori-
anopoulos, Monica Divitini, Jannicke Baalsrud Hauge, Letizia Jac-
cheri, and Rainer Malaka, editors, Entertainment Computing - ICEC
2015, pages 272–285, Cham, 2015. Springer International Publish-
ing. ISBN 978-3-319-24589-8.
[37] Eike Falk Anderson, Steﬀen Engel, Peter Comninos, and Leigh
McLoughlin.
The case for research in game engine architecture.
In Proceedings of the 2008 Conference on Future Play Research,
Play, Share - Future Play 08, page 228. ACM Press, 2008. ISBN
9781605582184. doi: 10.1145/1496984.1497031.
[38] Antonio Lima, Luca Rossi, and Mirco Musolesi. Coding together at
scale: GitHub as a collaborative social network. Proceedings of the
8th International Conference on Weblogs and Social Media, ICWSM
2014, pages 295–304, 2014.
[39] Laurie Williams and Robert Kessler. Pair programming illuminated.
Addison-Wesley Longman Publishing Co., Inc., 2002.
[40] Cem Kaner, Senior Member, and Walter P. Bond. Software engineer-
ing metrics: What do they measure and how do we know?
In In
METRICS 2004. IEEE CS. Press, 2004.
[41] Rüdiger Lincke, Jonas Lundberg, and Welf Löwe. Comparing soft-
ware metrics tools. In Proceedings of the 2008 International Sympo-
sium on Software Testing and Analysis, ISSTA ’08, pages 131–142.
Association for Computing Machinery, 2008. ISBN 9781605580500.
doi: 10.1145/1390630.1390648.
[42] T. DeMarco.
Controlling Software Projects: Management, Mea-
surement, and Estimates.
Prentice Hall PTR, USA, 1986.
ISBN
0131717111.
[43] T. J. McCabe. A Complexity Measure. IEEE Transaction Software
Engineering, SE-2(4):308–320, December 1976. ISSN 1939-3520.
doi: 10.1109/TSE.1976.233837.
[44] Y. Shin, A. Meneely, L. Williams, and J. A. Osborne. Evaluating
Complexity, Code Churn, and Developer Activity Metrics as Indi-
cators of Software Vulnerabilities. IEEE Transactions on Software
Engineering, 37(6):772–787, 2011.
[45] Francisco Gomes de Oliveira Neto, Richard Torkar, Robert Feldt,
L. Gren, Carlo A. Furia, and Z. Huang. Evolution of statistical analy-
sis in empirical software engineering research: Current state and steps
forward. Journal of Systems and Software, 156:246–267, 2019. ISSN
0164-1212. doi: 10.1016/j.jss.2019.07.002.
[46] Claes Wohlin, Per Runeson, Martin Hst, Magnus C. Ohlsson, Bjrn
Regnell, and Anders Wessln.
Experimentation in Software Engi-
neering. Springer Publishing Company, Incorporated, 2012. ISBN
3642290434.
[47] Eirini Kalliamvakou, Leif Singer, Georgios Gousios, Daniel M. Ger-
man, Kelly Blincoe, and Daniela Damian. The promises and perils
of mining GitHub.
11th Working Conference on Mining Software
Repositories, MSR 2014 - Proceedings, pages 92–101, 2014. doi:
10.1145/2597073.2597074.
[48] Jussi Kasurinen.
Games as software.
In Proceedings of the 17th
International Conference on Computer Systems and Technologies
2016 - CompSysTech 16, pages 33–40. ACM Press, 2016.
ISBN
9781450341820. doi: 10.1145/2983468.2983501.
[49] Mathieu Lavallée and Pierre N. Robillard. Why good developers write
bad code: An observational case study of the impacts of organiza-
tional factors on software quality. In Proceedings of the 37th Inter-
national Conference on Software Engineering - Volume 1, ICSE ’15,
pages 677–687. IEEE Press, 2015. ISBN 978-1-4799-1934-5. URL
http://dl.acm.org/citation.cfm?id=2818754.2818837.
[50] Hudson Borges and Marco Tulio Valente. What’s in a github star? un-
derstanding repository starring practices in a social coding platform.
Journal of Systems and Software, 146:112–129, 2018. ISSN 0164-
1212. doi: 10.1016/j.jss.2018.09.016.
[51] Christopher Vendome, Gabriele Bavota, Massimiliano Di Penta,
Mario Linares-Vásquez, Daniel German, and Denys Poshyvanyk.
License usage and changes: a large-scale study on gitHub, vol-
ume 22.
Springer, 2017.
ISBN 1066401694384.
doi: 10.1007/
s10664-016-9438-4.
Politowski et al.: Preprint submitted to Elsevier
Page 14 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
Metrics
RQ2
Code
RQ1.1
Engine
definition
RQ1.2
Framework
definition
RQ1.3
Related
works
RQ1
Literature
RQ3.1
Reasons
RQ3.2
Experience
RQ3.3
Opinion
RQ3
Human
RQ2.3
Community
RQ2.3.1
Project's 
Dependency
RQ2.3.2
Project's 
Popularity
Truck-Factor
Number of
stars
Number of
contributors
RQ2.3.3
Project's 
Issues
Number of
issues
Number of
closed issues
Closed issues
rate
RQ2.2
Historic
RQ2.2.1
Versions
RQ2.2.2
Lifetime
RQ2.2.3
Contribution
Number of
tags released
Lifespan
Number of
commits
Average
commits per
week
RQ2.2.4
Effort
Lines added
Lines
removed
Code churn
RQ2.1
Static
RQ2.1.1
Popularity
Languages
Project's 
main
language
RQ2.1.2
Popularity
Licenses
Project's 
license
RQ2.1.3
Project
Size
Main
language size
(MB)
Number of
files
RQ2.1.4
Function
Size
Number of
functions
Average
functions per
file
Cyclomatic
Complexity
RQ2.1.5
Function
Complexity
Average
NLOC per
function
Total size
(MB)
Figure 6: The three perspectives of the study, the research questions and metrics.
Appendix
A. Detailed Results for RQ2.1: Static
Characteristics
RQ2.1.1: What is the popularity of the languages
in the projects?
Table 7 shows the popularity of the programming lan-
guages in both framework and game engines, ordered by the
numbers of projects. The most used languages in game en-
gines belong to the C family: C, C++, and C#. Together,
they represent about 64% of the code. For frameworks, Java-
Script, PHP, and Python are the most used languages with
51% of the code. C++ and JavaScript are the most used lan-
guage for games and frameworks.
The distributions of the languages diﬀer for each group.
Game engines are mainly built in C++. For frameworks, the
diﬀerences between the top three languages are smaller. Be-
cause we sorted projects by popularity and most top frame-
works focus on Web development, interpreted languages are
used in the majority of their code.
Figure 7 shows the ranking of the top six most used lan-
guages in engines and frameworks and compare it to other
three global sources of programming languages usage in 2019:
GitHut 2.031 (Third Quarter), which uses the GitHub API
to query the most used languages in the public repositories,
Tiobe index32 (November), which uses a set of metrics to-
gether with results from search engines, and PYPL33 (Pop-
ularitY of Programming Language, December), which is a
ranking created by analysing how often language tutorials
are searched on Google.
C++ is the most popular language for engines but is only
the 10th most popular in frameworks, 5th in GitHut, 4th in
Tiobe, and 6th in PYPL. C is used in engines and is in 2nd
position in Tiobe but not so popular according to the other
sources. JavaScript is embraced by the open-source commu-
nity and received lots of attention in searches but Tiobe puts
it in the 7th place. The popularity of the programming lan-
guages in engines is more aligned to the Tiobe index than to
the other sources. In contrast, popular languages in frame-
works are more aligned to GitHut and PYPL rankings. Game
engines are more aligned with the commercial market and
31https://madnight.github.io/githut/
32https://www.tiobe.com/tiobe-index/
33https://pypl.github.io/PYPL.html
Politowski et al.: Preprint submitted to Elsevier
Page 15 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
Table 6
Descriptive Statistics, RQ2.1: Static Characteristics. Normality <0.01 means the data is not normally distributed.
RQs
Variable
Type
Mean
Std.Dev.
Median
Min
Max
Normality
RQ2.3
main_language_size
engine
5.78
14.95
1.09
0.00
102.10
<0.01
main_language_size
framework
3.82
17.74
0.55
0.00
276.76
<0.01
total_size
engine
7.66
20.31
1.22
0.00
155.32
<0.01
total_size
framework
4.82
26.27
0.60
0.00
423.37
<0.01
n_ﬁle
engine
685.60
1853.12
171.00
1.00
23379.00
<0.01
n_ﬁle
framework
456.93
1053.45
97.50
1.00
8062.00
<0.01
RQ2.4
n_func
engine
10130.74
21627.98
2394.00
1.00
163779.00
<0.01
n_func
framework
5924.17
14469.19
960.50
1.00
145288.00
<0.01
nloc_mean
engine
12.94
15.17
11.07
1.32
247.25
<0.01
nloc_mean
framework
12.71
33.89
8.79
1.00
539.79
<0.01
func_per_ﬁle_mean
engine
20.60
40.32
12.34
1.00
370.14
<0.01
func_per_ﬁle_mean
framework
23.03
82.62
8.57
1.00
1070.13
<0.01
RQ2.5
cc_mean
engine
3.09
2.35
2.77
1.00
36.19
<0.01
cc_mean
framework
2.68
3.75
2.14
1.00
60.22
<0.01
Table 7
Popularity of programming languages among engines and
frameworks.
Engine
Framework
Total
N
%
N
%
N
%
C++
107
37.94%
10
3.55%
117
20.74%
JavaScript
28
9.93%
71
25.18%
99
17.55%
Python
14
4.96%
45
15.96%
59
10.46%
C
41
14.54%
11
3.90%
52
9.22%
PHP
3
1.06%
46
16.31%
49
8.69%
C#
33
11.70%
15
5.32%
48
8.51%
Java
27
9.57%
19
6.74%
46
8.16%
Go
14
4.96%
21
7.45%
35
6.21%
TypeScript
7
2.48%
18
6.38%
25
4.43%
Swift
2
0.71%
13
4.61%
15
2.66%
Scala
1
0.35%
5
1.77%
6
1.06%
Objective-C
1
0.35%
4
1.42%
5
0.89%
Lua
4
1.42%
0
0.00%
4
0.71%
Ruby
0
0.00%
4
1.42%
4
0.71%
less with open-source projects.
RQ2.1.2: What is the popularity of the licenses in
the projects?
Table 8 shows the top 10 most used licenses. Diﬀerently
from the languages, the distribution of licenses is similar be-
tween engines and frameworks. The MIT License is most
used for both types of projects with 46%. “Other” licenses
(not reported by GitHub) are the second most popular with
18%. 9% of the projects do not have an explicit license. The
remaining ones form 27%.
According to GitHut 2.0, the licenses in GitHub project
are ranked as follows: MIT 54%, Apache 16%, GPL 2 13%,
GPL 3 10%, and BSD 3 5%, which is similar to the rankings
in engines and frameworks. Projects with “Other” licenses
Table 8
Most Used Licenses.
Engine
Framework
Total
N
%
N
%
N
%
MIT License
116
41%
142
50%
258
46%
Other
55
20%
48
17%
103
18%
No licence speciﬁed
30
11%
22
8%
52
9%
Apache License 2.0
17
6%
35
12%
52
9%
GNU GPL v3.0
28
10%
10
4%
38
7%
GNU LGPL v3.0
8
3%
5
2%
13
2%
BSD 3
2
1%
7
2%
9
2%
GNU GPL v2.0
7
2%
2
1%
9
2%
zlib License
6
2%
0
0%
6
1%
GNU AGPL v3.0
2
1%
3
1%
5
1%
BSD 2
3
1%
1
0%
4
1%
GNU LGPL v2.1
1
0%
3
1%
4
1%
Mozilla PL 2.0
2
1%
1
0%
3
1%
The Unlicense
2
1%
1
0%
3
1%
Artistic License 2.0
1
0%
0
0%
1
0%
Boost SL 1.0
0
0%
1
0%
1
0%
CC Attribution 4.0
1
0%
0
0%
1
0%
Eclipse PL 1.0
0
0%
1
0%
1
0%
Microsoft PL
1
0%
0
0%
1
0%
are a big part of this data, which, according to Vendome et al.
[51], are prone to migrate towards Apache or GPL licenses.
Finally, the MIT license is popular thanks to its permissive
model, which ﬁts well with most open-source projects.
The licenses might only apply to the engines or frame-
works and not to the games or software. For example, games
created with Godot have their creators as sole copyright own-
ers but must include its license:
“Godot Engine’s license terms and copyright
do not apply to the content you create with it;
you are free to license your games how you see
Politowski et al.: Preprint submitted to Elsevier
Page 16 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
1
2
3
4
5
6
7
8
9
10
Engine Framework Githut
PYPL
Tiobe
Ranking most used programming languages
Language G
G
G
C
C#
C++
(a) Most used languages in Game Engines.
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
1
2
3
4
5
6
7
8
9
10
Engine Framework Githut
PYPL
Tiobe
Ranking most used programming languages
Language G
G
G
JavaScript
PHP
Python
(b) Most used languages in Frameworks.
Figure 7: Ranking of the languages used in engines and frame-
works compared to their global uses.
best ﬁt, and will be their sole copyright owner(s).
Note however that the Godot Engine binary that
you would distribute with your game is a copy of
the ‘Software’ as deﬁned in the license, and you
are therefore required to include the copyright
notice and license statement somewhere in your
documentation.”
– https://godotengine.org/license
RQ2.1.3: What are the project sizes of engines and
frameworks?
We considered main_language_size, total_size, and n_ﬁles.
They show larger values for engines when compared to frame-
works. Considering the medians, engines have around 50%
higher median values regarding size of the main language
(1.09MB), total size of the project (1.22MB), and number of
ﬁles (171 ﬁles). The boxplots in Figure 8 help to identify the
diﬀerences among variables: game engines are larger than
frameworks, on average.
G
G
0
2
4
6
engine
framework
(a) Language size
G
G
0.0
2.5
5.0
7.5
10.0
engine
framework
(b) Total size
G
G
0
300
600
900
engine
framework
(c) Number of ﬁles
Figure 8: Boxplots – RQ2.1.3: What are the project sizes of
engines and frameworks?
(a) main_language_size
(b) total_size
(c) n_files
RQ2.1.4: What are the function sizes of engines
and frameworks?
We considered n_func, nloc_mean, and func_per_ﬁle_mean.
The boxplots in Figure 9 show that engines have larger val-
ues when compared to frameworks. Considering medians,
engines have around 30% more functions per ﬁle and 20%
more functions and lines of code per function.
G
G
0
5000
10000
15000
engine
framework
(a) Functions
G
G
0
5
10
15
20
engine
framework
(b) Code lines
G
G
0
10
20
30
engine
framework
(c) Functions per ﬁle
Figure 9: Boxplots – RQ2.1.4: What are the function sizes of
engines and frameworks?
(a) n_funcs
(b) nloc_mean
(c) func_per_file_mean
Politowski et al.: Preprint submitted to Elsevier
Page 17 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
RQ2.1.5: What are the function complexities of
engines and frameworks?
We considered cc_mean to assess functions complexi-
ties. The median for engines is about 23% greater than the
frameworks, which correspond to a complexity of less than
1. Figure 10 illustrates this diﬀerence. We also identiﬁed 16
projects (10 engines and 6 frameworks) with median com-
plexities greater than 5.
G
G
engine
framework
1
2
3
4
5
Figure 10: Boxplot of the Cyclomatic Complexity (CC).
Factoring out low-level languages, e.g., C++, the com-
plexity of the functions are similar between engines and frame-
works. The number of ﬁles and average functions per ﬁle are
similar. The total number of functions, however, is diﬀerent:
engines have twice as many functions (median values).
Programming languages vary greatly, as the game en-
gines are written mostly in compiled languages, while frame-
works in interpreted ones. Both types of projects prefer the
MIT license, very suitable to open-source projects. Although
game engines are, on average, bigger and more complex than
frameworks, this diﬀerence is small.
Politowski et al.: Preprint submitted to Elsevier
Page 18 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
Table 9
Descriptive Statistics: RQ2.2: Historical Characteristics. Normality <0.01 means the data is not normally distributed.
RQs
Variable
Type
Mean
Std.Dev.
Median
Min
Max
Normality
RQ3.1
tags_releases_count
engine
15.82
52.20
1.00
0.00
657.00
<0.01
tags_releases_count
framework
82.24
216.37
32.00
0.00
2,678.00
<0.01
RQ3.2
lifespan (weeks)
engine
155.70
113.39
135.79
0.00
530.43
<0.01
lifespan (weeks)
framework
215.30
129.79
182.14
5.71
590.71
<0.01
RQ3.3
commits_count
engine
2,029.93
4,553.92
616.00
7.00
37,026.00
<0.01
commits_count
framework
3,463.88
8,581.04
833.50
20.00
87,774.00
<0.01
commits_per_time
engine
3.44
7.71
1.04
0.01
62.68
<0.01
commits_per_time
framework
5.86
14.53
1.41
0.03
148.59
<0.01
RQ3.4
lines_added
engine
2,403.59
9,179.15
424.20
7.00
94,597.77
<0.01
lines_added
framework
776.62
2,750.07
169.46
5.80
26,099.63
<0.01
lines_removed
engine
644.34
1,343.49
175.44
0.00
11,957.13
<0.01
lines_removed
framework
434.67
1,421.13
104.84
2.33
15,450.48
<0.01
code_churn
engine
3,074.94
9,512.87
423.86
7.00
95,426.69
<0.01
code_churn
framework
1,211.28
4,015.20
163.79
10.67
41,550.10
<0.01
B. Detailed Results for RQ2.2: Historical
Characteristics
RQ2.2.1: How many versions were released for
each project?
Around 40% of the engines (112 projects) do not have
any tag. Only 8% of the frameworks (23 projects) are lack-
ing them. Most engines have between 0 and 11 tags while
frameworks have between 9 to 88. Frameworks release new
versions more often. Figure 11 shows the boxplots for the
numbers of tags. The dots represent the outliers as the ma-
jority of the engines have zero or few tags.
G
G
engine
framework
0
25
50
75
100
Figure 11: Boxplot of number of tags – RQ2.2.1: How many
versions were released for each project?
RQ2.2.2: What is the lifetime of the projects?
Figure 12 shows the distributions of engines and frame-
works lifetimes in weeks: both have similar shapes, with
more projects in the last years. Considering median values,
engines and frameworks are 2.6 and 3.5 years-old, respec-
tively. Open-source engines are more recent when compared
to open-source frameworks.
RQ2.2.3: How frequently do projects receive new
contributions?
Figure 13a presents the distribution for commits_count.
The frequency and number of commits is larger for frame-
G
G
engine
framework
0
200
400
Figure 12: Boxplot of lifespan in weeks – RQ2.2.2: What is
the lifetime of the projects?
works in total. Most engines have more than 616 commits,
while frameworks have more than 833, in the median.
Figure 13b depicts the distribution for commits_per_time,
which represents the number of commits (commits_count)
averaged by the projects’ lifetime (lifespan). Interestingly,
engines are more active than frameworks when considering
the number of commits overtime. In fact, 47% of the en-
gines have at least one commit per week, while this activity
is achieved by 40% of frameworks. This behavior—together
with the results presented in RQ2.2—may indicate that en-
gines are less mature than frameworks.
RQ2.2.4: Are commits made on game engines
more eﬀort-prone?
To answer this research question we investigated three
diﬀerent metrics: lines_added, lines_removed, and code_churn.
To keep our comparison at project level, we averaged the val-
ues of these metrics based on the number of commits each
project has. Overall, engines added and removed more lines
than frameworks. In median basis, 424.20 lines were added
by engines, against 169.46 lines for frameworks. When it
comes to lines removed, engines deleted 175.44 of them,
while frameworks removed 104.84; also median values. This
results in a code churn that is 2.6x times higher for engines
when compared to frameworks (423.86 vs 163.79), which
Politowski et al.: Preprint submitted to Elsevier
Page 19 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
G
G
0
2000
4000
6000
engine
framework
(a) Commits
G
G
0
10
20
30
engine
framework
(b) Commits per week
Figure 13: Boxplots – RQ2.2.3: How frequently do projects
receive new contributions?
means that engines are more likely to have major changes
than frameworks.
Politowski et al.: Preprint submitted to Elsevier
Page 20 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
Table 10
Descriptive Statistics, RQ2.3: Community Characteristics. Normality <0.01 means the data is not normally distributed.
RQs
Variable
Type
Mean
Std.Dev.
Median
Min
Max
Normality
RQ4.1
truck_factor
engine
1.32
0.91
1
1
8
<0.01
truck_factor
framework
1.58
1.88
1
1
25
<0.01
RQ4.2
stargazers_count
engine
659.45
2,140.45
44.5
2
23775
<0.01
stargazers_count
framework
4,017.36
11,671.63
556.5
111
145516
<0.01
contributors_count
engine
18.95
52.66
3
2
435
<0.01
contributors_count
framework
57.09
94.34
15
2
403
<0.01
RQ4.3
issues_count
engine
494.19
2,453.87
44
0
30,317
<0.01
issues_count
framework
1,534.70
4,075.97
254
3
36,757
<0.01
closed_issues_count
engine
428.5
2,122.72
34.5
0
24,861
<0.01
closed_issues_count
framework
1,449.18
3,496.88
215.5
0
35,659
<0.01
closed_issues_rate
engine
80%
20%
85%
0%
100%
<0.01
closed_issues_rate
framework
87%
14%
91%
0%
100%
<0.01
C. Detailed Results for RQ2.3: Community
Characteristics
RQ2.3.1: How many developers contribute in the
project?
Table 11 shows the truck-factor values and numbers of
contributors per project. The distribution of the truck-factor
between engines and frameworks are similar with the major-
ity of the projects having a value equal to one (82% for en-
gines and 73% for frameworks). The engine with the highest
truck-factor is PGZero with value of 8. Three frameworks
have truck-factor values higher than 8: Django (9), Rails
(13), and FrameworkBenchmarks (25). As a comparison,
Linux34 has a truck-factor of 57 and Git of 12 [25].
Table 11
Truck-factor values and medians of contributors.
Frameworks
Engines
Truck-factor
N
Contributors
N
Contributors
1
208
11
231
3
2
46
46
35
13
3
10
75.5
7
47
4
11
75
4
50
5
1
355
1
216
6
2
299
1
312
7
–
–
2
294
8
1
69
1
32
9
1
403
–
–
13
1
377
–
–
25
1
374
–
–
The median of contributors follows an direct relation:
the higher the truck-factor, the higher the number of con-
tributors. The exceptions are the engine PGZero (Python)
with 32 contributors and the framework Sofa (C++) with 69
contributors, both with truck-factor 8.
34https://github.com/torvalds/linux
RQ2.3.2: How popular are the projects considering
their main languages?
Figure 14 shows the popularity of the projects consid-
ering the top 10 most used languages (Table 7) ordered by
median numbers of stars. Engines written in Go have the
highest popularity although they are only 14. JavaScript is
the second most popular language followed by the C family.
Although C++ makes up the majority of the engines, it is
only the ﬁfth most popular. C# is the most popular language
for frameworks, but with only 15 projects. JavaScript and C
are second and third, respectively.
10
100
1000
10000
Go
Lua JavaScript
C
C#
C++
PHP TypeScriptPython
Java
stargazers_count
Engines
G
G
G
G
G
G
G
1e+02
1e+03
1e+04
1e+05
C#
C
JavaScript PHP
Python
Go
Swift
Java TypeScript C++
stargazers_count
Frameworks
Figure 14: Popularity of the Top 10 Most Used Languages for
Engines and Frameworks Ordered by Medians.
Politowski et al.: Preprint submitted to Elsevier
Page 21 of 22

Are Game Engines Software Frameworks? A Three-perspective Study
RQ2.3.3: How many issues are reported in each
project?
As observed in Table 10, issues activity on frameworks
are higher when compared to engines. For instance, 50% of
the frameworks have at least 254 issues reported (i.e., me-
dian). This number drops to 44 for engines. The number of
closed issues present a similar diﬀerence: half of the projects
have at least 215 and 34 issues closed for frameworks and
engines, respectively. When it comes to the rate of closed
issues, both kinds of systems present similar results, though.
In median, engines have closed 85% of the issues reported
so far, while frameworks have closed 91% of them.
Politowski et al.: Preprint submitted to Elsevier
Page 22 of 22

