Designing Bayesian Networks for Highly Expert-Involved
Problem Diagnosis Domains
by
Dennis L Ramdass
Submitted to the Department of Electrical Engineering and Computer Science
in Partial Fulfillment of the Requirements for the Degree of
Master of Engineering in Electrical Engineering and Computer Science
at the
MASSACHUSETTS INSTITUTE OF TECHNOLOGY
June 2009
@Massachusetts Institute of Technology 2009. All rights reserved.
The author hereby grants to M.I.T. permission to reproduce and to distribute publicly paper and
electronic copies of this thesis document in whole and in part in any medium now known or
hereafter created.
Author _--.._ 
_.
Department of Electrical Engineering and Computer Science
M=, 
99 
2009
Certified by
Samuel R. Madden
Associate Professor of Computer Science
, hesis Supervisor
Certified by
Accepted by 
..
Swaminat 
hn 
Ramany
.
at 
lect 
, Network Appliance Inc.
X i $ 
,," esis Co-Supervisor
Arthur C. Smith
Professor of Electrical Engineering
Chairman, Department Committee on Graduate Theses
MASSACHUSETTS INSTT-E'
OF TECHNOLOGY
JUL 2 0 2009
LIBRARIES
ARCHIVES

Designing Bayesian Networks for Highly Expert-Involved
Problem Diagnosis Domains
by
Dennis L. Ramdass
Submitted to the
Department of Electrical Engineering and Computer Science
May 22, 2009
In Partial Fulfillment of the Requirements for the Degree of
Master of Engineering in Electrical Engineering and Computer Science
ABSTRACT
Systems for diagnosing problems in highly complicated problem domains have been
traditionally very difficult to design. Such problem diagnosis systems have often been
restricted to the use of primarily rule-based methods for problem diagnosis in cases where
machine learning for probabilistic methods has been made difficult by limited available
training data. The probabilistic diagnostic methods that do not require a substantial
amount of available training data usually require considerable expert involvement in
design. This thesis proposes a model which balances the amount of expert involvement
needed and the complexity of design in cases where training data for machine learning is
limited. This model aims to use a variety of techniques and methods to translate, and
augment, experts' quantitative knowledge of their problem diagnosis domain into
quantitative parameters for a Bayesian network model which can be used to design
effective and efficient problem diagnosis systems.
Thesis Supervisor: Samuel R. Madden
Title: Associate Professor, Department of Electrical Engineering & Computer Science

ACKNOWLEDGEMENTS
Firstly, I would like to thank God for guiding me through my research and through the
preparation of my thesis. I would like to thank my family, and friends, for providing me
with encouragement and support throughout this process.
I would like to thank my advisor Professor Samuel Madden for guiding me through the
research process. I am grateful to Swaminathan Ramany, Steve Klinkner and Suhel Khan of
Network Appliance Inc. for facilitating my research at that company and providing
guidance through the research process.

Contents
1 
Introduction ..................................................... 
6
2 
Related Work and Overview of Bayesian Networks.............. 
... 
............ 10
3 
Overview of Bayesian Network Structure .......................................................... 
...................... 14
4 
Evidence Nodes .......................................................................................................................................... 
16
4.1 
Evidence Nodes as Ranked Nodes ............................................................. 
......................... 16
4.2 
Missing Data from Evidence Nodes .............................................................. 
...................... 17
5 
Derived Nodes ............................................................................................................................................ 
21
5.1 
Derived Node Means ....................................................................................................................... 
21
5.2 
Derived Node Variances ....................................... 
............................................................ 
21
6 
Edges .................................................... 
22
6.1 
Edge W eights ............................................... 
23
6.2 
Edge Relationships ... .......................................... 
24
7 
Implementation ......................................................................................................................................... 28
7.1 
Creation of Nodes ...................................................... 
29
7.2 
Specification of Evidence Node Priors: .................................................................................... 
29
7.3 
Creation of Edges .................................................... 
29
7.4 
Execution of Bayesian Network .............................................. 
29
7.5 
Example of Bayesian Network Creation ............................................. 
............. 
.................... 
30
8 
Results .................................................... 
33
8.1 
Testing Goals ...................................................... 
34
8.2 
Testing Framework ..................................................... 
36
8.2.1 
Case Classes for Comparison Testing ........................................................................ 
38
8.2.2 
Performance Criterion ........................................................................................................... 
38
8.2.3 
Test Cases Used .................................................... 
39
8.3 
Presentation and Analysis of Results .............. 
................................................................... 40
9 
F u tu re W o rk ................................................................................................................................................ 
5 1
1 0 C o n clu sio n s .................................................................................................................................................. 
5 3

List of Figures
Figure 1: Bayesian Network for Classic Rain/Sprinkler/Grass Example.............. 
11
Figure 2: Example of a prior distribution for a ranked evidence node............... 
16
Figure 3: Diagrammatic representation of edge specifications ....................................... 
26
Figure 4: Example of using intermediate nodes for edge function compositing............ 27
Figure 5: "Inefficient Access to LUN" Bayesian Network Structure* .................................... 
32
Figure 6: Error Rates vs. Iteration Test Number for Test Case A.................................... 
43
Figure 7: Error Rates vs. Test Iteration Number for Test Case B ..................................... 
46
Figure 8: Error Rates vs. Iteration Test Number for Test Case C ..................................... 
48
List of Tables
Table 1: Problem Dom ains Tested .............................................................................................................. 
34
Table 2: Variance of Error Rates among Experts for Test Case A ..................................... 
43
Table 3: Variance of Error Rates among Experts for Test Case B ..................................... 
46
Table 4: Variance of Error Rates among Experts for Test Case C.................................... 
48

1 
Introduction
In recent years, there has been increasing use of systematic methods for diagnosing
problems in a large number of domains. Examples of such problem diagnosis domains
include:
* Diagnosis of medical problems (1).
* 
Diagnosis of manufacturing problems (2).
* 
Diagnosis of computer performance problems (3).
Problem diagnosis systems aim to detect specific problems based on the
observation of some subset of potential symptom variables. For example a simple medical
problem diagnosis system can diagnose that a patient is afflicted with the common cold if
some of the following symptoms are observed: patient sneezing, patient having a runny
nose, patient having a mild fever, patient having a scratchy throat, and patient having a
cough.
These systems have been traditionally based on either deterministic methods such
as rule-based systems or probabilistic methods such as Bayesian networks.
Many problem domains are very complicated consisting of complex relationships
between symptoms and problems. Diagnosis systems for these problem domains require
considerable expert involvement in their design and implementation. These problem
domains are hereafter referred to as highly expert-involved problem diagnosis domains.
Traditionally, diagnosis systems for these problem domains have tended to utilize
rule-based systems because of the complexity of the problem diagnosis domains (4).
6

However, rule-based systems do not scale well as the size and complexity of these problem
domains increases. Rule-base systems become difficult to construct, complicated to modify
and messy to analyze. A well-designed probabilistic approach, however, can alleviate some
difficulties in design while achieving accurate results (5).
A probabilistic approach to problem diagnosis has a number of advantages over a
deterministic approach. The primary advantage is the ability to encode uncertainty easily
into probabilistic systems. In cases where there is uncertainty in the observation of system
variables or uncertainty of the effect of system variables on each other, a probabilistic
system can be designed to take note of measures of uncertainty, propagate them through
the system and reflect a measure of these uncertainties in its diagnoses. In complex
problem domains, it is critical that the diagnosis systems note and propagate uncertainty
through the system since the effects of introduced uncertainty is not always
straightforward for experts to deduce.
For example, the CPU usage of a computer system may not be known exactly but
may be believed to be between 70% and 90% with a probability of 0.8. In this case, it is
useful for the system to give a diagnosis but reflect a measure of uncertainty in the
diagnosis brought about by the "inexact" observation of the CPU usage.
Probabilistic systems achieve this by encoding system variables as random
variables. Naturally, the variance of these random variables can be used to represent the
uncertainty in system variables. The final diagnosis given by the system can be generated
by choosing the problems corresponding to the variables with the highest means, and
reporting the uncertainty in the diagnosis as a function of the variances of those variables.

In this thesis, a Bayesian network model is proposed as a probabilistic system for
highly expert-involved problem diagnosis domains. This research was done with the
primary goal of designing a software tool to design Bayesian networks for diagnosis of
storage system problems at a company specializing in storage system solutions. These
Bayesian networks could then be used for diagnosis in a variety of ways. Primarily, these
diagnosis systems could be programmed into customer-side applications to diagnose
problems on customers' storage systems and perhaps suggest recommendations for
problem-solving. If these systems are even moderately successful in problem diagnoses,
the company would be greatly helped. For example, a substantial gain can be made by the
subsequent reduction in calls to technical support if accurate automated problem
diagnoses can be made by a customer-side application.
The specific problem domains at the company were highly complex with most
domains consisting of hundreds of variables. Diagnosis techniques at the company, prior to
the Bayesian networks designed during this thesis, usually involved a high degree of expert
involvement. A primary goal of this thesis was to design problem diagnosis systems that
reduced expert involvement. With this in mind, a Bayesian network model was chosen.
However, limited training data was available for machine learning for these Bayesian
networks. Thus, this research focused on ways to reduce expert involvement for designing
Bayesian networks given this constraint.
This thesis thus proposes a framework for experts to develop Bayesian networks for
their problem diagnosis domains specifically for complicated problem domains with
limited training data available for machine learning. A software prototype was

implemented to design Bayesian networks according to the proposed model. Bayesian
networks, designed using this software prototype, were tested at the company. Testing
shows that these Bayesian networks can be designed, using the software prototype, to
perform well enough to be used successfully in practice.
This thesis proceeds as follows: Section 2 gives a brief introduction to Bayesian
networks and discusses related work in Bayesian network design. Next, Section 3 gives an
overview of the Bayesian network structure of the proposed model. Sections 4 and 5 detail
the particulars of nodes in the Bayesian network model. Section 6 explains edges and edge
parameters. Section 7 describes the implementation details of the software built for
experts to make their Bayesian networks, and steps for creation and execution of these
Bayesian networks. Section 8 describes the setup for testing the model, presents results
and analyses these results. Finally, Section 9 discusses ideas for future work and Section 10
concludes this thesis.

2 
Related Work and Overview of Bayesian Networks
Bayesian networks (6; 7) are a class of probabilistic models used in multivariate
statistical analysis. They are defined as directed acyclic graphs whose structures encode
the conditional independence and causal relationship between variables represented by
network nodes (8).
A Bayesian network for a set of variables X = (X,..., X} consists of:
1. Structure, S: Bayesian networks contain a network structure, S, that encodes
a set of conditional independence assertions about variables in X.
2. Parameters, O: Each variable has a set of local probability distribution
associated with it. Collectively, these components define the joint probability
distribution for X. The nodes in S are in one-to-one correspondence with the
variables X (9). This set of local probability distribution can be
parameterized so a Bayesian network can be represented by a structure S,
and a set of parameters O.
A simple classic example of a Bayesian network is one in which one tries to diagnose
whether or not it is raining based on the observation of grass being wet or not. Suppose
there are 2 events which could cause grass to be wet: the sprinkler being on, and rain. It is
also known that when it is raining, the sprinkler is never on. This situation can be modeled
with the Bayesian network shown in Figure 1. All three variables, abbreviated by G=grass
wet, S= sprinkler on and R=raining, have two possible values T (for true) and F (for false).

SPRINKLER
T 
F
T 
0.4 
0.6
F 
0.01 
0.99
RAIN
T 
F
0.2 
0.8
GRASS WET
SPRINKLER 
RAIN 
T 
F
F 
F 
0.0 
1.0
F 
T 
0.8 
0.2
T 
F 
0.9 
0.1
T 
T 
0.99 
0.01
Figure 1: Bayesian Network for Classic Rain/Sprinkler/Grass Example
Using a Bayesian network model, questions like "What is the probability it is raining,
given that the grass is wet?" can be answered. Using the parameters given in Figure 1, we
can calculate the probability in question as follows:
P(G =T,R =T)
P(R = TIG = T) = P(G=T 
)
P(G=T)
,S (T,F} P(G =T,S,R =T)
ZR,SE{T,F} P(G =T,S,R)
(0.99 x0.01x0.2)+(0.8 x0.99x0.2)
(0.99 x0.01x0.2)+(0.8 x0.99x0.2)+(0.9x0.8x0.4)+(0) = 0.3577
Bayesian networks have been studied closely in recent years to learn causal models
under uncertainty and have been applied successfully to different areas of science and

technology. They have been used in many cases for highly expert-involved problem
domains. These networks have, however, been designed with considerable effort and time
investment by experts knowledgeable in the areas of probabilistic reasoning (10).
Typically, a Bayesian network for a particular system is designed by specifying some
portion of its structure and/or some subset of its parameter space. This specification is
sometimes done by an expert of the system. In several cases system experts cannot easily,
or accurately, specify the full structure and parameter space of the Bayesian network. In
such cases, machine learning is used to complement the expert specification to form the
fully developed Bayesian network.
For the problem domains upon which this thesis was focused, a substantial amount
of training data was not available in many cases. With limited training data, simple, popular
machine learning techniques for parameter estimation such as maximum-likelihood (ML)
estimation would be unsuitable due to overfitting (11; 12). The complexity of the problem
domains made search, and even heuristic search, methods over parameter spaces, for the
given Bayesian networks, computationally difficult. Given these difficulties, the Bayesian
network model proposed requires both structure and parameter specification by experts.
This thesis focused on making this task as easy, quick and successful as possible for
experts.
In (13), Weidl et al. suggest an object-oriented Bayesian network (OOBN) language,
which allows complex domains to be described in terms of inter-related objects. This model

is rich, and can be very useful, but can prove difficult for users not knowledgeable about
probabilistic methods.
Software has been developed to try to make user construction of Bayesian as simple
as possible. An example of such software is AgenaRisk software (14). While this software
may be very useful, it lacks the flexibility and extensibility to be used commercially in many
cases. The underlying methods of this software are described by Fenton et al. in (15).
Fenton et al. focus on the use of ranked Bayesian network nodes to model qualitative
judgments of experts. Fenton et al. use ranked nodes everywhere in the system to model
qualitative expert judgments. This thesis proposes the use of ranked nodes for only a
subset of nodes but uses some of the functions used by Fenton et al. to calculate node
values.
Fenton et al. propose a fixed user-specified variance for every node in the network.
This thesis allows uncertainty to be introduced into the Bayesian network by taking into
account the variance of parent nodes when calculating the variance of a child node. This
thesis proposes a framework which allows the system to operate successfully even in the
cases of missing data i.e. when some variables are not observed. The model proposed by
Fenton et al. in (15) does not include provisions for cases of missing data.

3 
Overview of Bayesian Network Structure
Bayesian networks usually have no well-defined shape since evidence nodes are
usually interspersed across the network. For the cases of problem diagnosis domains, all
observable nodes represent symptoms. These symptoms are analyzed to diagnose which
problems are present and make recommendations if appropriate. This directionality of
causation in this domain lends itself to a natural partitioning of nodes in the Bayesian
network into Event Nodes and Derived Nodes.
Event nodes represent empirical measurements of symptom variables. For example,
event nodes can be made to represent the performance variables of a computer system
such as CPU usage, disk writes per minute or results of a patient's blood test such as blood
platelet count and white blood cell count. Derived nodes represent abstract inferences or
hypotheses that can be made from the event nodes. These encompass all nodes of the
system that cannot be observed directly.
It is useful to consider, and treat, evidence nodes distinctly from derived nodes in
the system. In many cases, experts would like to perform the same analysis of problems
given a different set of variables in different formats. In a practical sense, one can think of
different variable sets available for different groups of users.
For example, at a company the technical support group may have access to a
different, but effectively equivalent, set of symptom variables, as the set of variables
available to a customer-side application. It would be useful for a single Bayesian network to

be used in both cases, with some of the evidence node layer altered, but the nodes and
edges in entire derived node layer remaining the same.
For this reason, the proposed Bayesian network model enforces separation of
evidence nodes from derived nodes, and treats both sets of nodes differently. At the
company at which research was done, the designed Bayesian networks were intended to be
use by several different groups necessitating several different evidence node layers. Thus, a
goal of this thesis was to produce a system that allows experts to easily switching between
sets of evidence nodes.

4 
Evidence Nodes
4.1 
Evidence Nodes as Ranked Nodes
Evidence nodes are nodes whose values are (possibly) observed directly unlike
Derived nodes whose values are derived from calculations. In the proposed design,
evidence nodes are modeled quantitatively as "Ranked Nodes" as described by Fenton et al.
in (15).
Ranked nodes are nodes that take discrete values on an underlying [0, 1] scale. The
discrete values are presented on a qualitative scale with each possible value called a state.
For example, a set of possible node states can be (Very Low, Low, Medium, High, Very High]
as seen in Figure 2.
0.35 2
0.30 .
0.25 -
0.20 -
0.15 -
0.10 -
0.05 -
0.00 -
Very Low 
Low 
Medium 
High 
Very High
Node State
Figure 2: Example of a prior distribution for a ranked evidence node

This quantitative scale allows a mapping of variables from a wide range of scales to
a single intuitive scale. Effectively, this representation enforces an abstraction barrier
between the scale of the external variables of the system and the probability scale of the
internal variables. For example, a number of 5 memory faults per minute, means nothing
intuitively but a specification of "High" memory faults per minute does. In this way, the
individual scales of all evidence variables are abstracted from the system. This makes
interchanging of evidence nodes easy as well as making the derived node layer entirely
independent of the scales of the evidence nodes observed.
Another advantage of ranked evidence nodes is the discretization of node values
into ranked nodes allows a prior distribution on the node values to be specified more
easily. This helps deal with cases of missing data as discussed in the next subsection.
The values of evidence nodes in the system are updated periodically before the
system needs to be executed for a diagnosis. These values can be updating either by the
user or automatically through the collection and parsing of system variables.
4.2 
Missing Data from Evidence Nodes
It is often the case that some the states (values) of some evidence nodes may not be
observed at any given time. In diagnosis of storage system performance problems, one
form of collecting data may be periodic sampling of variables. Variable values are
sometimes fetched over unreliable network protocols (For efficiency reasons, unreliable
protocols are often preferred to reliable protocols). Thus, it is often the case that at any
given sampling time, requests for variable values may be met with a response containing
an invalid variable value or no response at all, within a given timeframe.
17

Another method of collecting performance data is via a "dump" of system variables
when the system encounters a problem. In these cases, the actual problem encountered
may disrupt the system in such a manner that it prevents the acquisition of certain system
variables. In diagnosis of medical problems, all possible symptoms may not be observable
at any given time or results from medical tests may not be available at all times. For
example, diagnosis of a critical medical problem may be necessary with some results of a
blood test pending.
In these cases, all possible evidence variables are not observed at all times. Thus all
possible evidence nodes cannot be assigned values at every desired execution of the
Bayesian network. The evidence nodes that cannot be assigned values at the time of
execution are hereafter referred to as missing nodes. In these cases, it is of obvious benefit
for the Bayesian network to still produce accurate results, in spite of the missing evidence
node data. It is necessary for the evidence nodes with missing values to be assumed to take
some meaningful value.
One way to ensure this is to have a prior distribution specified on the possible states
of every evidence node. A prior distribution corresponds to a valid probability of an
evidence node being in any given state. Figure 2 shows an example of a prior distribution
on an evidence node.
This specification can often be done exclusively through machine learning by
sampling of a large number of values of every evidence node. This requires a considerable
training data for the system. In many cases, like those encountered with the problem
domains in this thesis, available training data was very limited. In some of these cases, an

expert may better be able to give an idea of the prior distribution of the evidence nodes
than sampling from a limited data history.
In such cases, it is useful to generate and update prior distributions "on the fly" i.e.
as the Bayesian network is being used. In this way, expert knowledge is combined with
machine learning, given observed data, to always have useful prior distributions specified
on the evidence nodes of the system.
The basic idea of this method is to use the prior distributions specified by the expert
in the initial stages of the system usage, and slowly progress towards using the prior
distributions generated by sampling. This method is especially important in cases where it
is expected that the sample prior distributions would take a long time to converge to the
true prior distributions i.e. cases where a very large training sample size is needed to
converge to the true node distribution.
For every evidence node, experts are given the option of specifying a prior
distribution. If the expert chooses not to specify a prior distribution, sampling will be used
exclusively to generate prior distributions. If the expert does specify a prior distribution,
this prior distribution is treated then as an "observed" prior distribution with a specific
length of observation history. This length of observation history parameter is posed as a
confidence index specified by the expert corresponding to his confidence in his specified
prior distribution.
The prior distribution is then updated every time a value of the particular evidence
node is observed. The updating algorithm is as follows:

Pr[state](N+1) = Pr[state](N) 8(N)
Pr[observed state](N+1) = Pr[observed state](N) + (1 - Pr[observed state](N))8(N)
H+N
8(N) = H + N 
: fractional step away from specified prior
N: number of empirical observations, H: history length parameter
Pr [state](N): probability of node being in a given state after N empirical observations
By using this method, the updated prior distributions approach the empirical
distributions by taking the smallest possible steps away from the expert-specified prior
distributions towards the empirical distributions.
, V states # observed state

5 
Derived Nodes
Derived nodes are nodes whose values have to be calculated because they cannot be
observed directly. The distribution of a derived node is represented by an underlying
Gaussian normal random variable. The derived node's value must be limited to be between
0 and 1 since the node's value represents a probability. This normal random variable is
truncated at the boundaries [0, 1] and re-normalized, and is thus referred to as a doubly-
truncated normal random variable (DTN).
5.1 
Derived Node Means
The node's mean represents the probability of the event represented by the node
being true. For example, if the derived node "System overheating" has a mean = 0.6, the
probability of the event "System overheating" being true is 60%.
5.2 
Derived Node Variances
The node's variance represents a measure of how confident the system is in the
mean value calculated i.e. it gives the uncertainty of the system in the resulting node mean.
The details of the calculations of a derived node's variance are presented in Section 6.1.

6 
Edges
Edges between connecting nodes are stored implicitly in the derived nodes of the
system. All edges in the system are directed edges with fixed directionality in a strict
parent-child relationship. An edge between a parent node and a child node encodes the
effect that the value of the parent node has on the value of the child node.
In a typical Bayesian network, the probability distribution for every derived node,
conditioned on all its parent nodes, is usually specified by a local probability distribution
(9). In (15), Fenton et al. use discrete nodes everywhere so all local probability
distributions were specified by a Node Probability Table (NPT).
Some Bayesian network systems use machine learning techniques to specify the
parameters local probability distributions. Given the limitation of a small amount of
available training data, this thesis could not employ any of the popular machine parameter
techniques successfully. Exploration of methods not requiring large amounts of training
data proved futile. Search methods, both exhaustive and heuristic, through possible
parameter spaces for the best parameter set, were found to be extremely computationally
difficult due to the complexity of the domains. In the proposed design, local probability
distributions are designed to be generated automatically using minimal expert
specification.
This design's method for automatically generating local probability distributions is
similar to the implementation described by Fenton et al. in (15). A child node's local
probability distribution is calculated using the mean values of its parent nodes' local
probability distributions by specifying weights, and a function chosen from a preset list, on
22

the edges between parent and child nodes. The proposed framework extends the
calculations in (15) to the case of continuous probability distributions.
6.1 
Edge Weights
It is expected that in highly expert-involved problem domains, experts would be
able to roughly specify good weights and be able to easily increase the degree of precision
iteratively.
Each edge is weighted by a weight specified on a discrete [1, 10] scale by an expert
corresponding to the relative magnitude of the effect of the parent node's value on the child
node's value. The expert specifies a confidence value in the weightings of a group of
weighted edges incoming to a derived node. This confidence value allows the expert to
encode uncertainty into the system, for cases where he may not be completely
knowledgeable about the relation between parent nodes and a child node.
This parameter introduces this measure of uncertainty into the system which is
propagated through the system so the expert can look at the final results with a good idea
of the overall uncertainty in the system calculations. This is a major benefit over rule-based
systems which often produce dubious results with no warning signs that the results
generated may be inaccurate.

6.2 
Edge Relationships
An expert usually can specify the qualitative relationship between a group of parent
nodes and a given child node. The challenge in designing a suitable Bayesian network is
translating these qualitative relationships to quantitative relationships. In the proposed
design, the expert can choose from a set of functions which calculate the child node's value
based on the qualitative relationship between the set of parent nodes and the given child
node. Figure 3 shows an example of a node and the specified relationships to its parent
nodes.
The set of functions is as follows:
i. 
WMEAN: The child node's distribution is a DTN with a mean equal to the
weighted mean of all parent nodes' means (15). This function can be used
when a set of parent nodes collectively act as an indicator variable for a child
node. For example, in the case where one has 3 measurements of the same
variable, like the temperature of a patient, the weighted mean function may
be applicable.
WMEAN = 
1 Wi
wi: expert weighting for edge i, N: number of parent nodes
[ti: mean of parent node i
ii. 
WMAX: The child node's distribution is a DTN with a mean equal to the
weighted maximum of all parent nodes' means (15). This is the probabilistic
24

equivalent of an OR rule in a rule-based system. This function can be used
when a set of parent nodes are possible indicator variables for a child node
such that the value of just one of the parent nodes being high is sufficient to
conclude the child node's value is high. For example, suppose that one can
tell if it is raining outside by either seeing someone come walking in while
closing an umbrella or by seeing wet footsteps in the hallway. Observations
of both events do not need to occur for the judgment "it is raining outside" to
be made since just one is sufficient to make such a judgment so the weighted
maximum function may be applicable.
WMAX = max ' 
i
i=1... 
w 
+ (N -
1)_
iii. 
WMIN: The child node's distribution is a DTN with a mean equal to the
weighted maximum of all parent nodes' means (15). This is effectively the
probabilistic equivalent of an AND rule in a rule-based system. This function
can be used when a set of parent nodes are indicator variables for a child
node such that all the values of the parent nodes need to be high to conclude
the child's value is high. An example of this is the case where one needs to see
both the grass outside being wet and the window being wet to conclude with
high probability (child node value high) that it was raining earlier. In this
example, a weighted minimum function may be applicable.
WMIN = 
min 
i + 
j 
j
i=1 ...N 
w_+(N-'1)_

The variances of parent nodes as well as expert confidences in edge weightings are
used to calculate the variance of child nodes in the following manner:
wiKc
Adjusted weights, vi = NLw
Variance, a2 = 
L= viai
N ei= 
vi 2
ai: variance of parent node i
c: Expert confidence in incoming edge weights
K: Scaling factor needed normalize calculated variances to the scale of the variances
introduced by missing data. A good practical estimate was found to be on the order of
the number of edges in the system.
Figure 3: Diagrammatic representation of edge
specifications
Using the means, variances and edge weights shown in Figure 3, the mean and
variance of node D can be calculated as follows:
26

Mean of D 
=
i=1 Wi
Variance of D
wiK
cN Z i= Wi
Variance of D =
7 x 0.78 + 4 x 0.37 + 2 x 0.62 = 0.63
7+4+2
N 
V~i2
N Zi v Vi2
7x10
K = 10,c = 7 * v 
=x 0.2564; v2 = 0.1465; v 3 = 0.07326
3 x 13 x 7
0.2564 x 0.023 + 0.1465 x 0.017 + 0.07326 x 0.051
3 x (0.25642 + 0.14652 + 0.073262)
= 0.05411
Parent nodes may need to be partitioned into different groups based on different
relationships with child nodes. As an implementation detail, this can be done by creating an
intermediate node between each group of parent nodes and the child node then
compositing the functions between the nodes appropriately. Figure 4 shows the relevant
compositing required to satisfy the condition, child node D = WMAX [WMIN {parent A,
parent B), parent C}.
Figure 4: Example of using intermediate nodes for edge function
compositing

7 
Implementation
A software program was designed to act as an interface for users to create Bayesian
networks based on the proposed Bayesian network model. The program was implemented
in C# as a command-line interface (CLI). A graphical-user interface (GUI) would be of much
greater benefit to provide the user a visual representation of the Bayesian network as it is
being designed and executed. For the purposes of this thesis, however, time constraints
dictated only a CLI could be implemented. The software program consisted of about 500
lines of source code.
The program ran on a Windows platform with offline data but it is expected that it
can be easily extended to other platforms and be made to interface with private networks
to acquire real-time data.
A node interface was created in C# which is implemented by an Evidence Node
subclass and a Derived Node subclass. The steps for the user and execution of the Bayesian
network by the user are detailed in the following subsections.

7.1 
Creation of Nodes
Evidence nodes and derived nodes need to be constructed with each node
corresponding to a variable in the problem diagnosis domain. This can be done by a simple
constructor method call to create an instance of the relevant node type. Each node only
initially requires a unique name which acts as the node handle for future references.
7.2 
Specification of Evidence Node Priors:
Priors can be specified on evidence nodes after their construction. Since evidence
nodes are implemented as ranked nodes (discrete), a valid prior distribution can be
specified easily by the user by specifying a probability of the given evidence node being in
each state. The user specifies a confidence index for each prior distribution specified.
7.3 
Creation of Edges
Edges are constructed by adding parent nodes to every child derived node in the
system. These edges are stored implicitly by a hashtable in the child node. Edge weights are
assigned to each edge and an edge function from the set [WMEAN, WMIN, WMAX} is
specified. The expert also specified a confidence index in his edge weights. At this stage, the
Bayesian network is complete i.e. structure and parameters are fully specified.
7.4 
Execution of Bayesian Network
The Bayesian network can be executed at any time by a call to an executeo function.
Before each execution, some or all of the evidence node values are updated to reflect the
most recent empirical observation of their values i.e. a snapshot of the evidence variables
at that time. The updated means and variances of every node in the Bayesian network are

available almost instantaneously since there are only a small number of calculations
required at each execution to update the local probability distributions at each node. After
every execution, the nodes and variances of all nodes in the system are available. A
diagnosis could be produced from the results by looking at the nodes with the highest
means with variances within some maximum allowable variance. This maximum allowable
variance is decided upon based on the value of the scaling factor, K, specified in variance
calculations (See Section 6.2).
7.5 
Example of Bayesian Network Creation
The following is an example of commands using the CLI to create a Bayesian network
whose structure is shown in Figure 5:
# Step 1: Create evidence nodes and derived nodes
lun = new BayesianNetwork ("LUN")
lun.createEvidenceNodes("highest block usage", "2nd highest block usage",
"median block usage", "partial block count", "number of asynchronous reads")
lun.createDerivedNodes("high random block usage", "uniform block usage with 1
hotspot", "uniform block usage with 2 hotspots", "high partial block usage",
"applications using fixed multiple of prescribed block sizes", "applications
using random block size", "badly partitioned LUNs")
# Step 2: Specify priors on desired evidence nodes
lun.evidenceNode ("partial block count") . specifyPrior (VeryLow=O. , Low=O. i,
Medium=0.4, High=0.3, VeryHigh=O.l; confidence=7)
# Step 3: Add edges
lun.derivedNode ("high random block usage") .addEdges(["highest block usage",
weight=7], ["2nd highest block usage", weight=5], function=WMIN, confidence=6)
lun.derivedNode ("uniform block usage with 1 hotspot") .addEdges (["highest
block usage", weight=7], ["median block usage", weight=6], function=WMIN,
confidence=7)

lun.derivedNode ("uniform block usage with 2 hotspots").addEdges (["highest
block usage", weight=6], ["2nd highest block usage", weight=6], ["median block
usage", weight=6], function=WMEAN, confidence=5)
lun.derivedNode("high partial block usage").addEdges(["number of asynchronous
reads", weight=4], ["partial block count", weight=8], function=WMAX,
confidence=6)
lun.derivedNode("applications using fixed multiple of prescribed block
size").addEdges(["uniform block usage with 2 hotspots", weight=8], ["high
partial block usage"], weight=5], function=WMEAN)
lun.derivedNode ("applications using random block sizes").addEdges (["uniform
block usage with 2 hotspots", weight=6], ["high random block usage"],
weight=8], function=WMAX)
lun.derivedNode ("badly partitioned LUNs") .addEdges(["uniform block usage with
1 hotspot", weight = 10], function=WMEAN)
# Step 4: Execute
lun.evidenceNode ("highest block usage"). set(value=Very High)
lun. evidenceNode ("2nd highest block usage").set (value=High)
lun.evidenceNode ("median block usage").set (value=Medium)
lun.evidenceNode ("number of asynchronous reads"). set(value=Very Low)
lun.execute()

partial block
count
applications
using random
block sizes
WMEAN 
WMIN 
WMAX
0 
--
~- 
-
-
-
---
Figure 5: "Inefficient Access to LUN" Bayesian Network Structure*
*Note: This Bayesian network represents a tiny version of the "Inefficient Access to LUN"
Bayesian Network in Table 1 with dummy variables used to conceal confidential information.

8 
Results
Testing of the proposed Bayesian network model was done using a set of 3 problem
diagnosis domains at the company. The set of problem diagnosis domains used were
related to problems with technical performance in customer storage systems (See Table 1).
The exact Bayesian network structure and parameters specified by the experts are
confidential.
An initial investigation was done into the nature of these problem diagnosis
domains and previous diagnosis techniques used at the company. It was found that most of
the diagnosis techniques involved considerable participation from experts due to the
complexity of the problem diagnosis domains. Automated techniques in the form of rule-
based systems were attempted in some cases with limited success.
These problems domains showed the characteristics of a highly expert-involved
problem diagnosis domains discussed in Section 1. The primary goal of testing was to show
that the proposed model could be used by experts to easily and effectively design Bayesian
networks for problem diagnosis in these domains.

Table 1: Problem Domains Tested
Average Number
Problem
Problems Being Diagnosed 
of Nodes and
Domain
Edges
Inefficient 
* Applications using smaller block sizes than 
73 nodes
Access to 
prescribed block sizes 
178 edges
Logical Unit 
* 
Badly partitioned LUNs
Numbers 
* Applications using a fixed multiple of prescribed
(LUNs) 
block sizes rather than prescribed fixed block size.
* Performance benchmarking for LUN access is
incorrectly setup.
* Applications performing extensive sequential I/O
using variable length blocks rather than
prescribed fixed block sizes.
High SAN 
* Excessively deep directory structure. 
42 nodes
Access 
* 
Insufficient cache memory. 
103 edges
Response 
* 
High fragmentation at a file level.
Time for I/O 
* 
High fragmentation in RAID group.
operations 
* 
Large, random workloads.
CPU 
* 
CPU bottleneck due to rogue process. 
25 nodes
Bottleneck 
* 
CPU bottleneck due to bad mounts. 
57 edges
* Platform limitations.
* Backup tasks being performed.
8.1 
Testing Goals
The following testing goals were set for the proposed framework:
34

A. The proposed Bayesian network model would produce satisfactory results
with the right choice of structure and parameters for a given system. This
would show the effectiveness of Bayesian networks designed according to
the proposed model. For the purposes of a customer-side diagnosis
application, a success rate of over 65% would significantly reduce the
amount of time and effort spent by experts responding to technical support
calls.
B. The proposed Bayesian network model would be such that experts can
easily converge on a good set of parameters and appropriate structure for a
given problem diagnosis domain. This would show the effectiveness of
Bayesian networks designed according to the proposed model can be easily
made to approach a satisfactory level effectiveness.
C. The proposed Bayesian network model would be such that in the cases of
missing data, satisfactory results can be still be achieved. This would
empirically validate the model's techniques used for dealing with missing
evidence node data.
D. The proposed Bayesian network model would be such that experts can
easily change the evidence node layer in the Bayesian network and then
quickly converge to a good set of parameters for a given problem diagnosis
domain. This would show that effectiveness of Bayesian networks designed
according to the proposed model with a distinct separation of evidence
nodes from derived nodes.

E. The proposed Bayesian network model would be such that Bayesian
networks with expert specified weights would perform better than Bayesian
networks with machine-learnt weights using a simple machine learning
technique and training on a small sample of data. This would validate the
preference of expert-specified weights to simple machine-learnt weights
given the constraint of limited available training data.
8.2 
Testing Framework
5 performance experts were asked to participate in the creation of Bayesian
networks for each of 3 different problem diagnosis domains. These problem domains were
familiar to the experts but not in their areas of specific expertise. Testing was not done in a
strictly rigorous testing environment but rather was constrained over email
correspondence. This did not allow a fair assessment of the time experts spent on creation
of the Bayesian networks to be assessed precisely. Anecdotally, experts reported that the
creation of the Bayesian network using the given software usually was completed within 1-
2 hours.
Each expert was given short documentation on the concept of Bayesian networks, a
brief overview of the software implemented for the proposed Bayesian network model, a
listing of steps needed for creation and a short example of creation and execution using the
CLI. They were then left to perform the assigned tasks and turned in the Bayesian networks
they created at their leisure.
For testing, the experts were also given pointers to documentation about the
specifics of the problem diagnosis domains. Such documentation was largely informal in
36

the form of wiki pages and email thread discussions. The experts were given a set of
created nodes in all the layers beforehand to control for variability in node names and
number of nodes, as well as to save tedium. All the other steps were left up to the expert to
perform (See Section 8).
The experts were asked to perform the steps detailed in Section 7.1 to 7.4 iteratively
5 times. The experts did not have access to the problems being tested using their Bayesian
networks but they were told the classes of problems being tested (See Section 8.2.1 for
details). On every iteration, experts turned in their updated Bayesian networks. These
Bayesian networks were then tested using the test cases described in the following
sections, and all the error rates from testing for each of the experts' Bayesian networks
were reported to the experts.
As a basis for comparison, a simple machine-learning prototype was used to learn
edge weights for the Bayesian networks being tested. This machine-learning prototype was
built using the Bayes Net MATLAB Toolbox (16) to perform maximum-likelihood estimation
was performed using the Expectation-Maximization algorithm. In this machine-learning
prototype, several simplifying approximations to the edge functions in Section 6.2 were
made and the node values discretized for simplicity of calculation.
After testing was done on expert Bayesian networks, the most common expert-
specified Bayesian network structure for each problem domain was selected. This Bayesian
network structure, with no weights specified, was input into the machine-learning
prototype. 75% of the test cases were designated as training data and the remaining 25%
of the test cases were used to actually test the Bayesian networks with machine-learnt

weights. The partitioning into training and test data was done randomly and the results
shown in Section 8.3 represent an average of 5 different random splits.
8.2.1 Case Classes for Comparison Testing
For each problem diagnosis domain, the Bayesian's network performance was
compared to a history of archived cases which are known to be cases where:
A. A single problem was diagnosed.
B. Multiple problems were diagnosed.
C. No problems were diagnosed.
D. Missing data introduced so much uncertainty that no expert diagnosis could
be made.
These are cases where experts, prior to the Bayesian network tool, diagnosed
problems given a set of recorded system variables. These cases were not diagnosed by the
same experts as those experts used during testing but these cases still effectively act as
ground truth for testing.
8.2.2 Performance Criterion
The performance of the Bayesian networks was assessed by considering the rate of
Type I (false positive) and Type II (false negative) errors relative to ground truth. In this
testing framework, a "positive" result must meet both of the following criteria for the case
of a single known problem:
(1) The Bayesian network node corresponding to the known problem has a
calculated probability significantly higher than the probability of all the

nodes corresponding to other problems. In practice, a good cutoff mean
difference value was found to be x 0.2.
(2) The Bayesian network node corresponding to the known problem has a
calculated variance below a pre-specified maximum allowable variance. In
practice, a good maximum allowable variance can be set at - 0.6. This value is
related to scaling factor K for variance propagation discussed in Section 7.2.
These criteria are naturally extended to the case of multiple known problems. A
"negative" result arises when either of the criteria is not met.
In the case of missing data, there is an additional "indeterminate" result possible.
This result occurs when there is too much variance in the problem diagnosis domain for
the network to give reliable results. This corresponds to a failure of the second criterion.
An "indeterminate" result is needed for the comparison testing case described in Section
8.2.1D.
8.2.3 Test Cases Used
For each of 3 problem diagnosis domains, the following test cases were used:
A. 75 cases with no missing evidence node data:
i. 25 cases with a single known problem.
ii. 25 cases with multiple known problems.
iii. 25 cases with no known problem.
B. The same 75 cases with different evidence node layer i.e. a different set of
evidence variables:
i. 25 cases with a single known problem.
39

ii. 25 cases with multiple known problems.
iii. 25 cases with no known problem.
C. 40 cases with missing evidence node data for a particular evidence node.
i. 
10 cases with a single known problem.
ii. 10 cases with multiple known problems.
iii. 10 cases with no known problem.
iv. 10 cases with too much uncertainty to diagnose a problem.
The results were benchmarked against a "null hypothesis" which corresponded to a
random guess of the expected problems based on the frequency of problems in the test
cases.
8.3 
Presentation and Analysis of Results
Testing generated a significant amount of quantitative and qualitative insights into
the performance of Bayesian networks constructed using the designed software.
Qualitatively, insights about the usability of the software were gained through
anecdotal evidence from experts. Experts were happy with the simplicity of the command-
line interface and the potential for automatic Bayesian network creation using scripting.
However, they suggested that a graphical user interface (GUI) would be extremely useful
for visualizing network structure. Experts found the parameters intuitive and they claimed
they understood the general effects on the Bayesian networks brought about by changing
each parameter. The number of parameters requiring specification seemed very reasonable
to the experts given the large size of the problem domains. Initially, experts expressed
some skepticism about the degree of precision with which they would be able to specify
40

edge weights and how this would affect the system's results. However, they found in testing
that they were able to roughly specify good edge weights based on their qualitative
knowledge and that tuning them on subsequent test iterations was not as difficult as they
imagined.
Quantitatively, testing showed quick convergence to high levels of system
performance by all experts with a reasonably small degree of variability among the experts.
This variability is due in part to variability of network structure but mostly due to small
differences in parameter specification.
Control for structure variability among node names and number of nodes was done
by providing all the experts with the same set of pre-created nodes. During testing, it was
found that the sets of edge locations specified by all 5 experts were almost identical. There
were a few instances of edges being specified between certain nodes by one expert and not
the other 4 experts but these edges were always given very small weights making them
insignificant.
Parameter variability was much more common than structure variability, with a
range of edge weights and confidence indices specified by the user. This was reflected in
some variability of results among experts (See Table 2, Table 3, Table 4). However, each
expert progressively converged to either the same set of parameters or equivalently
effective sets of parameters.
In general, most misdiagnoses came about initially from experts specifying
confidence parameters, such as confidences in edge weights, to be too low resulting in
more false negatives then false positives. In the cases of false positives, experts often
41

overemphasized the effect of one particular parent node on a child node by assigning too
high a weight to that edge initially. Both these cases were often quickly rectified on
subsequent iterations.

Test Case A: General Case
100.0%
90.0%
80.0%
70.0%
60.0%
50.0%
40.0%
30.0%
20.0%
10.0%
0.0%
Test Iteration Number
Figure 6: Error Rates vs. Iteration Test Number for Test Case A
Table 2: Variance of Error Rates among Experts for Test Case A
_- 
---- 
-
.. ...
...
. .... 
.
-* 
False Positive Rate
-- 
False Negative Rate
-*- 
- False Negative Rate for
Multiple Problems Cases
* .**. 
False Negative Rate for
Single Problem Cases
-False 
Positive Rate: Null
Hypothesis
- - False Negative Rate: Null
Hypothesis
-
False Positive Rate:
Simple Machine Learning
--- 
-False 
Negative Rate:
Simple Machine Learning

As seen in Figure 6, experts were able to decrease error rates iteratively in almost
all cases. The third iteration greatly reduced the "False Negative Rate" while the fourth
iteration greatly reduced the "False Positive Rate". This is most likely due to experts
concentrating their efforts in particular iterations to reduce one error type rate at a time.
Experts converged to reasonably small error rates within the 5 iterations of
network specification. The "False Negative Rate" converged to around 14 4% while the
"False Positive Rate" converged to around 6 2%. This meets the goals of a high level of
system effectiveness discussed in Sections 8.1.A and 8.1.B. As expected, these error rates
are much less than those provided by the null hypothesis (random guessing based on
frequency). The error rates from the Bayesian networks with expert-specified weights
compared favorably with those of the Bayesian networks with machine-learnt weights. The
poor performance of the machine-learnt weights ("False Positive Rate"=56%, "False
Negative Rate"=61%) can be attributed to overfitting of weights due to a very small sample
size.
The "False Negative Rate" is consistently higher than the "False Positive Rate" for
Bayesian networks with expert-specified weights. This is most likely due to experts tending
to avoid specifying extreme parameter values and structure specification. It is expected
that these error rates can be made to be closer in value in cases where the cost of each
error type is the same.
The "False Negative Rate for Multiple Problems Cases" actually increases from the
first iteration to the second iteration. The variance in error rates among experts spikes at

this time as seen in Table 2. This suggests that some of the experts may have tried to
decrease the "False Negative Rate for Single Problems Cases" by overfitting parameters.
The "False Negative Rate for Multiple Problems Case" is also consistently higher
than the "False Negative Rate for Single Problem Cases." This reflects the added complexity
of the cases with multiple known problems and the difficulty experts encounter in
reasoning system parameters in such cases. However, the "False Negative Rate for Multiple
Problems Cases" converges to a very satisfactory 8%.
As shown in Table 1, the variance in error rates among experts converged to
relatively small values indicating that the proposed model does lend itself easily to
convergence to a highly effective parameter space.

Test Case B: Different Evidence Node Layer
100.0%
90.0%
80.0%
70.0%
60.0%
50.0%
40.0%
30.0%
20.0%
10.0%
0.0%
Test iteration Number
Figure 7: Error Rates vs. Test Iteration Number for Test Case B
Table 3: Variance of Error Rates among Experts for Test Case B
Test Iteration Number 
1 
2 
3 
4 
5
Variance of False Negative Error Rates 
7.91% 
4.15% 
3.79% 
3.76% 
3.70%
Variance of False Positive Error Rates 
7.57% 
4.07% 
2.31% 
2.25% 
2.22%
m-- 
-
mi
mi 
--
m-- 
-
-m 
mm- 
nmm
-4-- 
False Positive Rate
-a- 
False Negative Rate
-~-- False Negative Rate for
Multiple Problems Case
* .** 
False Negative Rate for
Single Problem Case
False Positive Rate: Null
Hypothesis
-
- False Negative Rate: Null
Hypothesis
-
* False Positive Rate: Simple
Machine Learning
---- 
False Negative Rate:
Simple Machine Learning

The initial error rates in Test Case B for Bayesian networks with expert-specified
weights, as seen in Figure 7, are significantly higher than the corresponding final error
rates in Test Case A. The variance among experts of error rates is also very high initially as
seen in Table 3. This suggests that on the first iteration, some of the experts may have
simply exchanged the evidence node layer with minimal or no changes to the network
parameters. On the second iteration, error rates decrease significantly and are much closer
to the final error rates as in Test Case A. There is a corresponding significant drop in error
variances among experts suggesting that the lack of updated specification of parameters by
some experts in the first iteration has been corrected.
By the third iteration, the error rates have effectively converged to the final error
rates. This shows that exchanging a layer in the Bayesian network requires very little work
for the network to converge to satisfactory results meeting the goal discussed in Section
8.1.D. As expected, these error rates are much less than those provided by the null
hypothesis (random guessing based on frequency). The error rates from the Bayesian
networks with expert-specified weights also compared favorably with those of the
Bayesian networks with machine-learnt weights which are similar to those in Test Case A.
47

Test Case C: Missing Data
100.0% --
, 
-
90.0%
S.. 
... 
......
80.0%
70.0% 
1
60.0%
,*
20.0%
10.0%
S 0.0%
10.0%
0.0% 
i
1 
2 
3
Test Iteration Number
False Positive Rate
-
 - False Positive Rate for
Uncertainty Cases
-- 
-- False Negative Rate
-
'-- 
False Negative Rate for
Single Problem Cases
.... ** False Negative Rate for
Multiple Problems Cases
-
False Positive Rate: Null
Hypothesis
-
- False Negative Rate: Null
Hypothesis
False Positive Rate: Simple
Machine Learning
----
False Negative Rate:
Simple Machine Learning
Figure 8: Error Rates vs. Iteration Test Number for Test Case C
Table 4: Variance of Error Rates among Experts for Test Case C
48

The initial expert error rates are very high for Test Case C as seen in Figure 8. There
is also a very high initial variance of error rates among experts as seen in Table 4. This is
expected since an initial guess at a combination of network parameters and a proper prior
distribution for the missing evidence node is somewhat random and unlikely to be a good
combination. However, experts were able to decrease error rates iteratively in a manner
similar to Test Case A.
The variance of error rates among experts fluctuates somewhat and overall remains
generally high. This suggests that some of the experts may have been experimenting more
liberally with parameters and prior distributions than others. It also suggests that the
parameter of expert confidence in the prior distribution adds a relatively large degree of
variance among experts in the initial executions of the Bayesian network.
The "False Positive Rate" converged to a reasonable rate of about 12  5%. The
"False Negative Rate" converges to a rate of about 31 6%. This rate is relatively high
suggesting that in many cases with missing data, the network may struggle to identify
problems. However, a 31% "False Negative Rate" Bayesian problem diagnosis network is
still useful to experts in many cases. For example, if the Bayesian network were used in a
customer-side application, a 69% success rate is acceptable (> 65% as discussed in Section
8.1.A) since the Bayesian network would cause the number of phone calls to technical
support to decrease significantly. It is also noteworthy that sometimes missing data can be
due to a random event (See Section 4.2). Thus, a user can often simply execute the Bayesian
network shortly after the initial execution to get better results since it is likely less, or no,
data would be missing.

As expected, expert error rates are much less than those provided by the null
hypothesis (random guessing based on frequency). The error rates from the Bayesian
networks with expert-specified weights compared favorably with those of the Bayesian
networks with machine-learnt weights. Bayesian networks with machine-learnt weights
perform very poorly ("False Positive Rate"=71%, "False Negative Rate"=75%). This is
somewhat expected since simple maximum-likelihood estimation on a small training
sample is known to be even more inaccurate for cases where node values are missing.

9 
Future Work
There are several areas of future work that can be done to improve the proposed
framework and software. The immediately obvious improvement to the software is to add
a graphical user interface (GUI) to the software so that experts may be able to visualize the
Bayesian network during design and execution. Time constraints did not allow the
development of such a GUI but it is expected that a useful GUI can be easily designed for
this software.
The software could also be improved by adding capabilities to interface with live
data through the CLI rather than static offline analysis.
An improvement to the underlying Bayesian network model would be the
development of a way to use machine learning to augment expert specifications of edge
weights. As discussed in Section 7 and shown in testing (See Section 8), machine learning of
Bayesian network parameters may not be successful for cases where limited training data
is available. However, successful solutions may exist if our goal is to learn finely specified
edge weights given initial roughly expert-specified edge weights i.e. some sort of machine
weight-tuning algorithm can be developed given a very good initial guess is given by an
expert.
A useful benefit of this improvement would be the allowance of experts to add
possibly superfluous edges between nodes in the system for cases where the expert does
not know with certainty if there are any relations between the connecting nodes. If
machine-tuning of the weights is implemented, the expert need not worry about if edges
are superfluous since machine-learning would dictate the edge weight approach zero as it

trains on a large enough training data set. If a relation does exist between the nodes
however, a non-zero weight would be correctly applied to the relevant edge.
In retrospect, this research could have spent a little more time focusing on
developing a method to do this machine tuning of edge weights. While there is no
guarantee that a computationally-efficient, successful solution would have been found,
simple first-order methods to perform this machine tuning could have been formulated and
tested.
Another improvement may be the use of a more complicated sampling method to
update the expert-specified prior distribution on evidence nodes. In the proposed
framework, naive sampling of every observation is performed but better results may be
had with techniques such as Monte-Carlo methods.

10 
Conclusions
The designed software provides a useful, extensible and effective tool for modelling
Bayesian networks, particularly for problem domains that ordinarily would require a high
degree of expert involvement in diagnosis. The designed software works well for problem
domains with limited training data for machine learning by reducing the amount of expert
involvement greatly. This is achieved by providing a system that requires a reasonably
small amount of expert time easily mapping qualitative knowledge to quantitative
knowledge in its design followed by a short period of fine-tuning to produce high quality
results.
Testing has shown that, in typical use cases, experts can develop a Bayesian network
using the designed software easily and quickly converge to small error rates. Flexibility and
extensibility of the diagnosis systems are critical. The proposed model caters to such
flexibility by separating evidence nodes from derived nodes explicitly and treating them
differently.
With most complex problem diagnosis systems, all possible evidence variables may
not be observable at all times. The designed diagnosis system allows diagnosis to be
performed at any time even when some evidence variables are not observed. This is done
using a small amount of expert knowledge elicitation at design time for the Bayesian
network (not every time at run-time), and machine learning. Testing showed that results in
these cases are of sufficient quality for many applications. For example, this tool could be
used in customer-side applications with an almost 70% success rate for cases of missing
data. This software can be used as a primary diagnosis tool for experts whose results can
53

be used to aid or direct some secondary diagnosis tool in cases of missing data. For
example, this tool can greatly narrow the space of problems that experts can investigate
during expert diagnosis.
This software is limited as a problem diagnosis tool in cases where the structure of a
Bayesian network is very difficult to formulate. Unknown structure is often due to
difficulties of identifying causation in the problem domain. Causal relationships between
variables need to be relatively well known qualitatively in order to design a Bayesian
network using this tool. For example, this model is not expected to perform well when used
to design Bayesian networks that aim to be predictive, such as a Bayesian network for
stock market forecasting or a Bayesian network for predicting future performance
problems, since these problem domains usually do not have well-known causal
relationships between domain variables.
For most problem diagnosis problem domains, experts know, at least qualitatively,
the causal relationships between system variables because of their experience in
diagnosing problems in the given domain. The main challenge in building a system to
diagnose such problems is translating that qualitative knowledge into quantitative
knowledge. The designed software has shown an effective and easy way to build Bayesian
networks for problem diagnosis domains in this manner while still allowing a great deal of
flexibility and extensibility.
54

Bibliography
1. Ha, JungWoo and Eom, JaeHong and Kim, SungChun and Zhang, ByoungTak.
Evolutionary hypernetwork models for aptamer-based cardiovascular disease diagnosis.
GECCO '07: Proceedings of the 2007 GECCO conference companion on Genetic and
evolutionary computation. London, United Kingdom : ACM, 2007, pp. 2709-2716.
2. Birnbaum, Larry and Hopp, Wallace and Iravani, Seyed and Livingston, Kevin and
Shou, Biying and Tirpak, Thomas. Task aware information access for diagnosis of
manufacturing problems. IUI '05: Proceedings of the 10 
Oth international conference on
Intelligent user interfaces. San Diego, California, USA : ACM, 2005, pp. 308-310.
3. Roth, Philip C. and Miller, Barton P. On-line automated performance diagnosis on
thousands of processes. PPoPP '06: Proceedings of the eleventh ACM SIGPLAN symposium on
Principles and practice ofparallel programming. New York, New York, USA : ACM, 2006, pp.
69-80.
4. Xu, Jing. Rule-based automatic software performance diagnosis and improvement. WOSP
'08: Proceedings of the 7th international workshop on Software and performance. Princeton,
NJ, USA: ACM, 2008, pp. 1-12.
5. Probabilistic fault localization in communication systems using belief networks. Steinder,
Malgorzata and Sethi, Adarshpal S. 1063-6692, Piscataway, NJ, USA: IEEE Press, 2004,
IEEE/ACM Trans. Netw., Vol. 12, pp. 809-822.
6. Chickering, David Heckerman and Dan Geiger and David. Learning Bayesian
Networks: The Combination of Knowledge and Statistical Data. Machine Learning. s.l.:
Springer Netherlands, 1995, pp. 197-243.
7. Pearl, Judea. Probabilistic reasoning in intelligent systems: networks of plausible
inference. San Francisco, CA, USA: Morgan Kaufmann Publishers Inc.
8. Asadi, Narges Bani and Meng, Teresa H. and Wong, Wing H. Reconfigurable
computing for learning Bayesian networks. FPGA '08: Proceedings of the 16th international
ACM/SIGDA symposium on Field programmable gate arrays. Monterey, California, USA:
ACM, 2008, pp. 203-211.
9. Heckerman, David. A Tutorial on Learning With Bayesian Networks. Learning in
Graphical Models. Redmond, WA: Microsoft Corporation, 1996.

10. Combining knowledge from different sources in causal probabilistic models. Druzdzel,
Marek i. and Diez, Francisco J. 1533-7928, Cambridge, MA, USA: MIT Press, 2003, J.
Mach. Learn. Res., Vol. 4, pp. 295-316.
11. A Bayesian computer vision system for modeling human interactions. Oliver, N.M. and
Rosario, B. and Pentland, A.P. Redmond, WA: Microsoft Corp., 2000.
12. Learning probabilistic relational models. Schmidt, Douglas C. New York, NY, USA:
Springer-Verlag New York, Inc., 2000.
13. Madsen, Galia Weidl and Anders L. Object Oriented Bayesian Networks for Industrial
Process Operation. In Proc. Workshop on Bayesian modelling, Uncertainty in AI. Providence,
Rhode Island : s.n., 2003, pp. 302-313.
14. AgenaRisk Software. [www.agenarisk.com] s.l. : Agena Ltd., 2007.
15. Using Ranked Nodes to Model Qualitative ]udgments in Bayesian Networks. Fenton,
Norman E. and Neil, Martin and Caballero, Jose Galan. 10, Piscataway, NJ, USA: IEEE
Educational Activities Department, 2007, IEEE Trans. on Knowl. and Data Eng., Vol. 19, pp.
1420-1432.
16. Murphy, Kevin. Bayes Net Toolbox for Matlab.
http://www.cs.ubc.ca/~-murphyk/Software/BNT/bnt.html. [Online]
17. Large-Sample Learning of Bayesian Networks is NP-Hard. Chickering, David Maxwell
and Heckerman, David and Meek, Christopher. 1533-7928, Cambridge, MA, USA: MIT
Press, 2004, J. Mach. Learn. Res., Vol. 5.

