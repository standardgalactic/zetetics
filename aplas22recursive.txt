A Calculus with Recursive Types, Record
Concatenation and Subtyping
Yaoda Zhou1, Bruno C. d. S. Oliveira1, and Andong Fan2
The University of Hong Kong, Hong Kong SAR, China
{ydzhou, bruno}@cs.hku.hk
Zhejiang University, Hangzhou, China
afan2018@zju.edu.cn
Abstract. Calculi with subtyping, a form of record concatenation and
recursive types are useful to model objects with multiple inheritance. Sur-
prisingly, almost no existing calculi supports the three features together,
partly because the combination of subtyping and record concatenation
is already known to be troublesome. Recently, a line of work on disjoint
intersection types with a merge operator has emerged as a new approach
to deal with the interaction between subtyping and record concatenation.
However, the addition of recursive types has not been studied.
In this paper we present a calculus that combines iso-recursive types with
disjoint intersection types and a merge operator. The merge operator
generalizes symmetric record concatenation, and the calculus supports
subtyping as well as recursive types. We build on recent developments on
the theory of iso-recursive subtyping using the so-called nominal unfold-
ing rules to add iso-recursive types to a calculus with disjoint intersection
types and a merge operator. The main challenge lies in the disjointness
deﬁnition with iso-recursive subtyping. We show the type soundness of
the calculus, decidability of subtyping, as well as the soundness and com-
pleteness of our disjointness deﬁnition. All the proofs are mechanized in
the Coq theorem prover.
1
Introduction
Record calculi with a concatenation operator have attracted the attention of re-
searchers due to their ability to give the semantics of object-oriented languages
with multiple inheritance [19,14,15]. The foundational work by Cook and Pals-
berg [19], and Cardelli [14] work on the semantics of the Obliq language are prime
examples of the usefulness of untyped record calculi with record concatenation
to model the semantics of OOP with inheritance.
Unfortunately, typed calculi with record concatenation and subtyping have
proven to be quite challenging to model. An important problem, identiﬁed by
Cardelli and Mitchell [15], is that subtyping can hide static type information that
is needed to correctly model (common forms of) record concatenation. Cardelli
and Mitchell illustrate the problem with a simple example:
let f2 (r:{x:Int}) (s:{y:Bool }) : {x:Int} & {y:Bool} = r,,s
in f2 ({x=3, y=4}) ({y=true , x=false })

2
Zhou et. al.
Here f2 is a function that takes two records (r and s) as arguments, and returns
a new record that concatenates the two records (r ,, s). For the return type
of f2 we use record type concatenation (here denoted as R & S). Because of
subtyping it is possible to invoke f2 with records that have more ﬁelds than the
ﬁelds expected by the static types of the arguments of f2. For instance, while the
static type of the ﬁrst argument of f2 is {x : Int}, the record that is actually
provided at the application ({x = 3, y = 4}) also has an extra ﬁeld y.
The program above is ﬁne from a typing point of view, but what should the
program evaluate to? There are a few common options for the semantics of record
concatenation. Record concatenation can be symmetric, only allowing the con-
catenation of records without conﬂicts; or it can be asymmetric, implementing
an overriding semantics where, in case of conﬂicts, ﬁelds on the left (or the right)
record are given preference. Choosing a naive form of asymmetric concatenation
does not work. For instance, with left-biased concatenation, the example above
would evaluate to {x = 3, y = 4}, which has the wrong type! Therefore, Cardelli
and Mitchell [15] state that:
we should now feel compelled to deﬁne R & S only when R and S are
disjoint: that is when any ﬁeld present in an element of R is absent
from every element of S, and vice versa.
hinting for an approach with symmetric concatenation, based on disjointness.
But a naive symmetric concatenation operation would result in a record {x =
3, y = 4, y = true, x = false} with conﬂicts, which should not be allowed!
Thus, such a naive form of symmetric concatenation does not work either.
Recent work on calculi with disjoint intersection types [33] and a merge op-
erator oﬀers a solution to the Cardelli and Mitchell’s problem for concatenation.
For instance, the λi calculus [33] adopts disjointness and restricts subsumption
to address the challenges of symmetric concatenation/merge. Most importantly,
λi has a type-directed semantics to ensure proper information hiding and the
preservation of the expected modular type invariants. The application of the
f2 function in λi results in {x = 3, y = true}, which has no conﬂicts and is
of the right type. Types are used at runtime to ensure that ﬁelds hidden by
subtyping are dropped from the record. This is enforced, for example, during
beta-reduction, which uses the type of the argument to ﬁlter any hidden ﬁelds/-
values from records/merges. Thus, before substitution, the ﬁrst argument of f2,
for instance, is ﬁrst ﬁltered using the type {x : Int}. The actual record that is
substituted in the body of f2 is {x = 3} (and not {x = 3, y = 4}).
An important limitation of existing calculi with disjoint intersection types is
that they lack recursive types. For typed model of objects, supporting recursive
types is important, since many object encodings require recursive types [10].
Without recursive types binary methods [9] and other types of methods, that
refer to the current object type cannot be easily modelled. For example, it is hard
to support an equality method in an object. In addition, recursive structures,
such as lists or trees, require recursive types as well.
This paper studies subtyping relations combining iso-recursive subtyping
with disjoint intersection types and a merge operator. Our calculus λµ
i , extends

A Calculus with Recursive Types, Record Concatenation and Subtyping
3
λi with recursive types. With λµ
i we can use a standard encoding of objects
using recursive types [10,11,19,18] in λµ
i to model objects with recursive types.
For instance, we can deﬁne an interface for arithmetic expressions Exp using a
recursive type:
Exp := µ Exp. {eval : nat, dbl : Exp, eq : Exp →bool}
In Exp there are 3 methods: an evaluation method that returns the value of eval-
uating the expression; a dbl method that doubles all the natural numbers in (the
AST of) an expression; and an equality method that compares the expression
with another expression. In λi it is only possible to express the type of eval.
However, in λµ
i we can also express dbl and eq. Importantly, in λµ
i the record
type {eval : nat, dbl : Exp, eq : Exp →bool} is syntactic sugar for intersections
of single ﬁeld records [40,22]. In other words, to deﬁne the type Exp we need
both intersection types and recursive types.
To add iso-recursive subtyping to λµ
i , we employ a recent formulation of
iso-recursive subtyping based on the so-called nominal unfolding rules [47]. The
nominal unfolding rules have equivalent expressive power to the iso-recursive
Amber rules [12], but they are easier to work with formally. We prove various
important properties for λµ
i , including transitivity of algorithmic subtyping, de-
cidability as well as the unfolding lemma. A key technical challenge is how to
deﬁne disjointness for iso-recursive types, which turns out to be non-trivial. By
employing the notion of a lower common supertype, we show that it is possible
to obtain a sound and complete formulation of algorithmic disjointness. All the
calculi and lemmas presented in this paper have been mechanically formalized
in the Coq theorem prover [42]. In summary, the contributions of this paper are:
– Iso-recursive subtyping with intersection types: We show the applica-
bility of nominal unfoldings to a subtyping relation that includes intersection
types. The subtyping relation is transitive, decidable and supports the un-
folding lemma.
– The λµ
i calculus, which adds iso-recursive types to an existing calculus
with record types, disjoint intersection types and a merge/concatenation
operator.
– Algorithmic disjointness for iso-recursive types. The algorithmic for-
mulation of disjointness for iso-recursive types is non-trivial. We introduce an
approach based on lower common supertypes, enabling a sound and complete
algorithm for disjointness.
– Mechanical formalization: Finally, we provide a mechanical formalization
and proofs for all the calculi and proofs in the Coq theorem prover [42]. The
proofs are available in the supplementary material of this submission [46].
2
Overview
2.1
Background: Disjoint Intersection Types
λi and other calculi with disjoint intersection types [33,2,6] have been shown
to provide ﬂexible forms of dynamic multiple inheritance [5,45]. Moreover, they

4
Zhou et. al.
enable a highly modular and compositional programming style that addresses
the Expression Problem [43] naturally. For space reasons, here we only illustrate
brieﬂy the ability of such calculi to model ﬁrst-class traits and a very dynamic
form of inheritance [5]:
addId(super:Trait[Person], idNumber:Int):Trait[Student ]=
trait
inherits
super => { def id : Int = idNumber }
In this code, written in the SEDEL language [5], there are two noteworthy points.
Firstly, unlike statically typed mainstream OOP languages, traits (which are
similar to OOP classes) are ﬁrst class. They can be passed as arguments (such
as super), or returned as a result as above. Secondly, the code uses a highly
dynamic form of inheritance. The trait that is inherited (super) is a parameter
of the function. In contrast, in languages like Java, for class A extends B, the
class B must be statically known. We refer the interested reader to the work by
[5,45] for a much more extensive discussion on the applications of calculi with
disjoint intersection types, as well as how to encode source language features,
such as ﬁrst-class traits.
2.2
λµ
i : Adding recursive types to λi
An important limitation of existing calculi with disjoint intersection types is
that they lack recursive types, preventing binary methods [9] and other types of
methods. As we have discussed in Section 1, without recursive types we cannot
write object interfaces such as:
Exp := µ Exp. {eval : nat, dbl : Exp, eq : Exp →bool}
where some method signatures refer to the type being deﬁned. In λµ
i we add
recursive types, therefore it becomes possible to deﬁne the object interface Exp.
Using a standard object encoding based on records and recursive types [18,10],
we can then model objects. To implement Exp we ﬁrst need a few auxiliary
functions (eval′ : Exp →nat, dbl′ : Exp →Exp and eq′ : Exp →Exp →bool) that
unfold the recursive type1. Then we deﬁne two recursive functions lit : nat →Exp
and add : Exp →Exp →Exp:
eval′ e
= (unfold [Exp] e).eval
dbl′ e
= (unfold [Exp] e).dbl
eq′ e1 e2 = (unfold [Exp] e1).eq e2
lit n
= fold [Exp]{eval = n, dbl = lit(n ∗2),
eq = λe′. (eval′ e′ == n) : Exp →bool}
add e1 e2 = fold [Exp]{eval = eval′ e1 + eval′ e2, dbl = add (dbl′ e1) (dbl′ e2),
eq = λe′. (eval′ e′ == eval′ e1 + eval′ e2) : Exp →bool}
In this example the functions lit and add act as encodings of classes or traits. The
function lit is basic: it stores the literal, a double function and equality functions.
1 We assume the presence of recursive functions, and that records are lazy in the
example.

A Calculus with Recursive Types, Record Concatenation and Subtyping
5
In add, operations such as eval′ have to be called for subexpressions. To check if
2 ∗7 = 2 ∗(3 + 4), we can deﬁne e1 : Exp = lit 7 and e2 : Exp = add (lit 3) (lit 4).
Then, we check if eq′ (dbl′ e1) (dbl′ e2) is satisﬁed.
2.3
Disjointness for Recursive Types
The disjointness restriction is an essential feature in calculi with disjoint inter-
section types. Such restriction ensures that certain merges of values, that could
lead to ambiguity, are forbidden. For instance, in the example above merges are
used to encode records. A record {x = 1, y = true} is encoded as the merge of
two single ﬁeld records {x = 1}, , {y = true}. Here the operator , , is the merge
operator [40,22], which can be viewed as a generalization of record concatena-
tion. Ambiguity can arise with the merge operator if the two values in the merge
overlap. For instance, with records, we would like to forbid r = {x = 1, x = 2} (a
record with two ﬁelds with the same name and type), since r.x would be ambigu-
ous. With the merge operator we can merge not only records, but also arbitrary
values. Thus, we need to forbid merges such as 1, , 2 which provides two values
of type Int. The disjointness restriction is employed when type-checking merges
to ensure that the types being merged do not overlap. A standard speciﬁcation
of disjointness [33,29] is:
Deﬁnition 1 (Speciﬁcation of disjointness). Γ ⊢A ∗s B ≡∀C, (Γ ⊢A ≤
C ∧Γ ⊢B ≤C) ⇒⌉C⌈
The intuition is that two types are disjoint when all their supertypes are (iso-
morphic to) ⊤. The notation ⌉· ⌈represents toplike types, which are both su-
pertypes and subtypes of ⊤. In essence ambiguity arises from upcasts on values.
For instance if we cast 1, , 2 under type Int there can be two possible results.
Disjointness prevents merges with values having common supertypes (with the
exception of ⊤). Therefore, when such disjoint merges are upcast we can ensure
that only one value will be extracted for any given (non toplike) type.
One of the challenges in the design of λµ
i is to ﬁnd an algorithmic rule to
check whether two recursive types are disjoint and prove that it is complete
with respect to the speciﬁcation. As part of the completeness proof we must
be able to ﬁnd common supertypes of two types, but this is non-trivial for re-
cursive types due to contravariance. For example, assume that we have two
recursive types µα. ((nat →α) →nat) and µα. ((⊤→α) →nat), then
µα. ((nat →α)&(⊤→α) →nat) is not a valid common supertype because
α is contravariant. In contrast, for covariant recursive types and non-recursive
types, ﬁnding a common supertype is simpler. For instance, for the recursive
types µα. (String →α) and µα. (nat →α), the intersection of the two in-
puts types of the function in the recursive type gives us a common supertype
µα. (String&nat →α).
In Section 4, we will show that the disjoint rules for recursive types are quite
simple: we only need to check if their one-time ﬁnite unfoldings are disjoint or
not. Furthermore, we can address the challenge of ﬁnding supertypes using a

6
Zhou et. al.
lower common supertype deﬁnition, which gives a common supertype even for
contravariant recursive types. This plays a crucial role in the completeness proof
for disjointness.
3
Static Semantics of λµ
i
This section presents the static semantics of λµ
i , covering syntax, subtyping,
disjointness and typing rules. The main novelty over λi is the addition of iso-
recursive types, which requires novel proof techniques to deal with disjointness.
Our subtyping relation supports intersection types and iso-recursive types using
the nominal unfolding rule [47]. Among others, we prove transitivity of sub-
typing, the unfolding lemma and decidability of subtyping. We note that this
subtyping relation is quite general and, while it is used by our speciﬁc applica-
tion in Section 4, it can be easily adapted to many other calculi with recursive
types and intersection types.
3.1
Syntax and Subtyping
Syntax The syntax of our calculus is:
Types
A, B ::= nat | ⊤| ⊥| A1 →A2 | {α : A} | α | µα. A | A1&A2
Expressions
e ::= i | ⊤| x | λx. e : A →B | e1 e2 | ﬁx x : A. e | e : A
| unfold [A] e | fold [A] e | {α = e} | e1, , e2 | e.α
Values
v ::= i | ⊤| λx .e : A →B | fold [A] v | v1, , v2 | {α = v}
Contexts
Γ ::= · | Γ, α | Γ, x : A
Modes
⇔::=
⇐
|
⇒
Meta-variables A, B range over types. Types are mostly standard and consist of:
natural numbers (nat), the top type (⊤), the bottom type (⊥), function types
(A →B), type variables (α), and recursive types (µα. A). The most interesting
feature is the presence of labelled types {α : A}. Labelled types can be viewed as
a simple form of nominal types. They are essentially a pair that contains a name
(or type variable) α and a type. We use labelled types in two diﬀerent ways: 1)
we use them with the nominal unfolding rules for iso-recursive subtyping; and
2) we also use them to model records and records types in combination with
intersection types and the merge operator.
Expressions, which are denoted as e, include: a top value (⊤), lambda ex-
pressions (λx. e : A →B) and ﬁxpoints (ﬁx x : A. e). Note that for lambda
expressions, we annotate both input and output types, since the output types
are necessary in a Type-Directed Operational Semantics (TDOS) during reduc-
tion, which will be described in Section 4.
Values include a canonical top value (⊤), lambda expressions (λx.e : A →B),
merges of values (v1, , v2) and record values ({α = v}). For proving type-safety,
the contexts also store the types of variables used in the program. We employ
bi-directional type checking in the system, thus ⇐/⇒represent the checking
mode and synthesis mode, respectively.

A Calculus with Recursive Types, Record Concatenation and Subtyping
7
⊢Γ
(Well-Formed Environment)
wfe-nil
⊢·
wfe-sub
⊢Γ
fresh α
⊢Γ, α
wfe-typ
⊢Γ
fresh x
Γ ⊢A
⊢Γ, x : A
Γ ⊢A
(Well-Formed Type)
wft-Nat
⊢Γ
Γ ⊢nat
wft-Top
⊢Γ
Γ ⊢⊤
wft-Bot
⊢Γ
Γ ⊢⊥
wft-var
α ∈Γ
Γ ⊢α
wft-arr
Γ ⊢A
Γ ⊢B
Γ ⊢A →B
wft-rcd
Γ ⊢A
Γ ⊢{α : A}
wft-rec
Γ, α ⊢A
Γ ⊢µα. A
wft-and
Γ ⊢A
Γ ⊢B
Γ ⊢A&B
Fig. 1: Well-formedness.
The syntactic sugar for record types and records is also shown below, illus-
trates the standard encoding [22,40] in terms of intersection types, labelled types
and merges.
{α1 : A1, . . . , αn : An} ≡{α1 : A1} & . . . & {αn : An}
{α1 = e1, . . . , αn = en} ≡{α1 = e1} , , . . . , , {αn = en}
Well-Formedness The deﬁnition of well-formed types is mostly standard, as
Figure 1 shows. An environment is well-formed if all the variables are distinct.
Subtyping Figure 2 shows the subtyping relation. Rule S-bot states that any
well-formed type A is a supertype of the ⊥type. Rule S-fvar is a standard rule
for type variables: variable α is a subtype of itself. The rule for function types
(rule S-arrow) and intersection types are standard. Rule S-rcd states that a
labelled type is a subtype of another labelled type if the two types are labelled
with the same name and A ≤B.
Rule S-rec, the nominal unfolding rule, is the most interesting one. In this
rule, the body of the recursive type is unfolded twice. However, for the innermost
unfolding, the type that we substitute is not the recursive type. Instead, we use
a labelled type, where the label is a fresh name that serves as a unique identiﬁer
for the recursive types being compared. The label is associated to the bodies
of both recursive types. In other words, we substitute the recursive variable by
the labelled type in the recursive type body A: [α 7→{β : A}] A. The label is
useful to identify types that arise from recursive unfolding substitutions and to
give distinct identities to recursive types. We should note that Zhou et al. [47]
present the rule in a slightly diﬀerent way, by reusing the recursive type variable
as a label:

8
Zhou et. al.
⌉A⌈
(Toplike Type)
top-base
⌉⊤⌈
top-and
⌉A⌈
⌉B⌈
⌉A&B⌈
top-arrow
⌉B⌈
Γ ⊢A
⌉A →B⌈
top-rec
⌉A⌈
⌉µα. A⌈
top-rcd
⌉A⌈
⌉{α : A}⌈
Γ ⊢A ≤B
(Subtyping)
S-nat
⊢Γ
Γ ⊢nat ≤nat
S-top
⊢Γ
⌉B⌈
Γ ⊢A ≤B
S-bot
⊢Γ
Γ ⊢A
Γ ⊢⊥≤A
S-rcd
Γ ⊢A ≤B
Γ ⊢{α : A} ≤{α : B}
S-arrow
Γ ⊢B1 ≤A1
Γ ⊢A2 ≤B2
Γ ⊢A1 →A2 ≤B1 →B2
S-and
Γ ⊢A ≤B1
Γ ⊢A ≤B2
Γ ⊢A ≤B1&B2
S-fvar
⊢Γ
α ∈Γ
Γ ⊢α ≤α
S-andR
Γ ⊢A1
Γ ⊢A2 ≤B
Γ ⊢A1&A2 ≤B
S-andL
Γ ⊢A2
Γ ⊢A1 ≤B
Γ ⊢A1&A2 ≤B
S-rec
Γ, α ⊢[α 7→{β : A}] A ≤[α 7→{β : B}] B
fresh β
Γ ⊢µα. A ≤µα. B
Fig. 2: Subtyping rules.
S-oldrec
Γ, α ⊢[α 7→{α : A}] A ≤[α 7→{α : B}] B
Γ ⊢µα. A ≤µα. B
The two presentations are equivalent, but the original presentation implicitly
assumes that bound variables and free variables are distinct. Thus, the α that
is bound by the recursive type µα. A and the α used in the label should be
considered distinct (and the α used in the label should be distinct from other
free variables as well). To avoid confusion we make such implicit assumptions
explicit in the rule S-Rec here.
The basic intuition about the nominal unfolding rules is that, in order to
deal with negative occurrences of recursive type variables, such as in µα. α →
nat ≤µα. α →⊤we need to unfold the recursive types at least twice to detect
invalid subtyping statements. For instance, unfolding the previous example twice
leads to ((µα. α →nat) →nat) →nat ≤((µα. α →⊤) →⊤) →⊤, which is
not a valid subtyping statement. Thus, the original subtyping statement should
be rejected. The nominal unfolding rules leverage on this insight, while being
terminating since the recursive types are replaced by non-recursive types that
are in the same subtyping relation as the original types. The nominal unfolding

A Calculus with Recursive Types, Record Concatenation and Subtyping
9
rules have been shown by Zhou et al. [47] to have equivalent expressive power to
the well-known (iso-recursive) Amber rules [12]. However, the nominal unfolding
rules are easier to work with in terms of proofs, which is the reason why we
employ them here. In particular, they enable us to prove transitivity, and to
have a set of algorithmic rules (without transitivity built in). We refer interested
readers to the work by Zhou et al. for the equivalence proofs with respect to the
Amber rules and the theory of the nominal unfolding rules.
A toplike type, whose deﬁnition is shown as rule S-top, is both a supertype
and a subtype of ⊤. In calculi with disjoint intersection types, the deﬁnition
of toplike types plays an important role, since disjointness is deﬁned in terms
of toplike types. Allowing a larger set of toplike types enables more types to
be disjoint. In particular, the motivation for λi to include rule top-arrow in
subtyping is to allow certain function types to be disjoint [6,28,33]. The rule top-
arrow itself is inspired from the well-known BCD-subtyping [4] relation, which
also states that any function type that returns a toplike type is itself toplike.
Rule top-arrow was ﬁrst adopted in calculi with disjoint intersection types
by Bi et al. [6], and we follow that approach as well here. Without such rule
two function types can never be disjoint, disallowing more than one function in
a merge (where all expressions must have disjoint types). Similarly, in λµ
i the
rule top-rec enables merges that can contain more than one expression with a
recursive type.
Subtyping is reﬂexive and transitive:
Theorem 1 (Reﬂexivity). If ⊢Γ and Γ ⊢A then Γ ⊢A ≤A.
Theorem 2 (Transitivity). If Γ ⊢A ≤B and Γ ⊢B ≤C then Γ ⊢A ≤C.
Furthermore, we have also proved the unfolding lemma, which plays an im-
portant role in type preservation. The proof strategy is similar to the approach
used in Zhou et. al [47].
Lemma 1 (Unfolding Lemma).
If Γ ⊢µα. A ≤µα. B then Γ ⊢[α 7→
µα. A] A ≤[α 7→µα. B] B.
3.2
Decidability
Decidability of subtyping is a signiﬁcant property, which is often problematic
in many subtyping relations [27,37]. Fortunately, under our new iso-recursive
subtyping rules with nominal unfoldings, decidability is easy to prove:
Theorem 3 (Decidability of Subtyping). If ⊢Γ, Γ ⊢A and Γ ⊢B, then
Γ ⊢A ≤B is decidable.
Informally, looking at Figure 2 we can identify two potential complications in
deriving an algorithm from the subtyping relation and showing its termination.
The ﬁrst complication comes from the newly added intersection subtyping rules,
which makes the relation not completely syntax directed. In particular, there is

10
Zhou et. al.
overlapping between all three intersection rules. However, this problem is well-
known from the literature of intersection types. A standard solution, proposed
by Davies and Pfenning [21], is to only apply rule S-andL and rule S-andR
for Γ ⊢A1&A2 ≤B when B is ordinary (i.e. not an intersection type). This
removes the overlapping between rule S-and and rules S-andR and S-andL.
For the remaining overlapping between rules S-andR and S-andL backtrack-
ing is needed. The same approach can be adopted in an implementation of our
subtyping relation. The second complication is that the relation is not struc-
turally recursive because of rule S-rec. In rule S-rec the size of the types in
the premise can actually grow. However, the key observation here is that the
number of recursive binders will reach the peak and decreases after some unfold-
ings. We employ the same technique by Zhou et. al [47], to prove decidability
with a nominal unfolding rule.
3.3
Disjointness
One of the core judgments of λµ
i is disjointness. The standard disjointness speci-
ﬁcation [33] states that two types A and B are disjoint if all common supertypes
of A and B are toplike, as Deﬁnition 1 showed. In other words, A and B are dis-
joint if there are no non-toplike supertypes. While this deﬁnition of disjointness
is concise, it is not algorithmic. Thus, a challenge in calculi with disjoint inter-
section types is to ﬁnd an algorithmic set of rules that is sound and complete to
the disjointness speciﬁcation.
Figure 3 shows an algorithmic formulation of disjointness. Most rules are
standard and follow from previous work [33,28,7]. Toplike types are disjoint
with other types (rules dis-topL and
dis-topR). Intersection types need to
check the disjointness of every component (rules dis-andL and dis-andR). Two
labelled types are disjoint if they have distinct labels or the types of the label
are disjoint (rules dis-RcdRcd and dis-RcdRcdEq). Two diﬀerent variables
are always disjoint (rule dis-VarVar). Rule dis-ArrArr states that, for two
function types, we just need to check if their output types are disjoint or not.
The most interesting one is the disjointness of recursive types. Without top-
like types, it could be very simple: any two recursive types are not disjoint be-
cause µα. ⊤is a non toplike common supertype for all recursive types. However,
the introduction of toplike types complicates the interaction between any two
recursive types, as we described in Section 2. Nevertheless, rule dis-RecRec
is surprisingly simple: two recursive types are disjoint if their bodies are dis-
joint. Finally, two types with diﬀerent type constructors (e.g. record types and
recursive types) are disjoint (rule dis-axiom).
Disjointness soundness The soundness lemma showing that our rules satisfy the
speciﬁcation is straightforward:
Lemma 2 (Soundness). If Γ ⊢A ∗B then Γ ⊢A ∗s B.
Proof. By induction on Γ ⊢A ∗B.

A Calculus with Recursive Types, Record Concatenation and Subtyping
11
Γ ⊢A ∗B
(Disjointness)
dis-topL
⌉B⌈
Γ ⊢A ∗B
dis-topR
⌉A⌈
Γ ⊢A ∗B
dis-andL
Γ ⊢A1 ∗B
Γ ⊢A2 ∗B
Γ ⊢A1&A2 ∗B
dis-andR
Γ ⊢A ∗B1
Γ ⊢A ∗B2
Γ ⊢A ∗B1&B2
dis-VarVar
α ̸= β
Γ ⊢α ∗β
dis-ArrArr
Γ ⊢A2 ∗B2
Γ ⊢A1 →A2 ∗B1 →B2
dis-RcdRcd
α ̸= β
Γ ⊢{α : A} ∗{β : B}
dis-RcdRcdEq
Γ ⊢A ∗B
Γ ⊢{α : A} ∗{α : B}
dis-RecRec
Γ, α ⊢A ∗B
Γ ⊢µα. A ∗µα. B
dis-axiom
Γ ⊢A ∗axiom B
Γ ⊢A ∗B
Fig. 3: Disjointness.
3.4
Completeness of Disjointness
The most challenging part of the formalization of λµ
i is to show that algorith-
mic disjointness is complete with respect to the speciﬁcation. The diﬃculty is
brought by rule dis-RecRec. If two recursive types µα. A and µα. B satisfy the
speciﬁcation, then for any type C, Γ ⊢µα. A ≤C ∧Γ ⊢µα. B ≤C implies that
C is toplike. By rule dis-RecRec, we want to prove that any type D satisfying
Γ, α ⊢A ≤D ∧Γ, α ⊢B ≤D implies that D is toplike. Clearly C and D should
be related since in one case C is the supertype of two recursive types, and in the
other case D is the supertype of the bodies of the two recursive types. However,
the relation between C and D is intricate.
Lower common supertype To help to relate C and D, we deﬁne a new function
⊔, which is shown in Figure 4. The function ⊔computes a lower supertype of
type A and B. A simpliﬁcation that we employ in our deﬁnition is that types of
common supertypes in contravariant positions are all ⊥. Strictly speaking this
means that the supertype that we ﬁnd is not the lowest one in the subtyping
lattice. But in our setting this does not matter, because the disjointness of arrow
types (see rule dis-ArrArr) does not account for input types. If the input types
did matter for disjointness then we would likely need a dual deﬁnition for ﬁnding
greater common subtypes, making the deﬁnition more involved. We can prove
some useful properties for ⊔:
Lemma 3 (⊔is supertype). For any A and B, Γ ⊢A ≤A⊔B and Γ ⊢B ≤
A ⊔B.

12
Zhou et. al.
⊤⊔A
=
⊤
α ⊔α
=
α
A ⊔B&C
= A&B ⊔A&C
⊥⊔µα. A
=
µα. (⊥⊔A)
⊥⊔{α : A}
=
{α : ⊥⊔A}
⊥⊔A1 →A2
= ⊥→(⊥⊔A2)
µα. A ⊔µα. B
=
µα. (A ⊔B)
A1 →A2 ⊔B1 →B2 = ⊥→(A2 ⊔B2)
A ⊔⊤
=
⊤
α ⊔β
=
⊤(α ̸= β)
A&B ⊔C
= A&C ⊔B&C
µα. A ⊔⊥
= µα. (A ⊔⊥)
{α : A} ⊔⊥
=
{α : A ⊔⊥}
A1 →A2 ⊔⊥
= ⊥→(A2 ⊔⊥)
{α : A} ⊔{β : B} =
⊤(α ̸= β)
{α : A} ⊔{α : B} =
{α : A ⊔B}
otherwise: ⊥⊔A = A, A ⊔⊥= A, A ⊔A = A, A ⊔B = ⊤,
Fig. 4: Lower common supertype.
Lemma 4. If Γ ⊢A ≤C and Γ ⊢B ≤C and A ⊔B is toplike, then C is
toplike.
Lemma 4 is the most important one: A⊔B is not the least common supertype
of A and B, but if it is toplike then all supertypes of A and B are toplike. With
the previous lemmas we can prove the completeness lemma:
Lemma 5 (Completeness). For types A and B, if Γ ⊢A∗sB then Γ ⊢A∗B.
3.5
Bidirectional Typing
We use bidirectional type checking in λµ
i , following λi [29]. Bi-directional type-
checking is helpful to eliminate a source of ambiguity (and non-determinism)
that arises from an unrestricted subsumption rule in conventional type assign-
ment systems in the presence of a concatenation/merge operator (a point which
was also noted by Cardelli and Mitchell [15]). The typing rules are shown in
Figure 5. There are two standard modes: Γ ⊢e ⇒A synthesises the type A of
expression e under the context Γ, and Γ ⊢e ⇐A checks if expression e has type
A under the context Γ.
Many rules are standard. There are two rules for merge expressions, which
follow from previous work [29]. Rule typing-merge employs a disjointness re-
striction, and only allows two expressions with disjoint types to be merged. The
disjointness restriction prevents ambiguity that could arise merging types with
common (non-toplike) supertypes. For instance, if 1, , 2 would be allowed, then
in an expression like (1, , 2) + 3 we could have two possible results: 4 and 5.
The merge of duplicated values such as 1, , 1 is not harmful, since no ambiguity
arises in this case, and such values can arise from reduction. Thus, there is also
a rule typing-mergev, which allows merging two consistent values regardless
of their types. The consistency relation is:
Deﬁnition 2 (Consistency).
v1 ≈spec v2 ≡∀A, (v1 ,→A v′
1 ∧v2 ,→A v′
2) ⇒
v′
1 = v′
2

A Calculus with Recursive Types, Record Concatenation and Subtyping
13
Γ ⊢e ⇔A
(Typing)
typing-sub
Γ ⊢e ⇒A
Γ ⊢A ≤B
Γ ⊢e ⇐B
typing-top
⊢Γ
Γ ⊢⊤⇒⊤
typing-var
⊢Γ
x : A ∈Γ
Γ ⊢x ⇒A
typing-app
Γ ⊢e1 ⇒A1 →A2
Γ ⊢e2 ⇐A1
Γ ⊢e1 e2 ⇒A2
typing-nat
⊢Γ
Γ ⊢i ⇒nat
typing-anno
Γ ⊢e ⇐A
Γ ⊢e : A ⇒A
typing-proj
Γ ⊢e ⇒{α : A}
Γ ⊢e.α ⇒A
typing-rcd
Γ ⊢e ⇒A
Γ ⊢{α = e} ⇒{α : A}
typing-abs
Γ, x : A1 ⊢e ⇐A2
Γ ⊢λx.e : A1 →A2 ⇒A1 →A2
typing-unfold
Γ ⊢e ⇐µα. A
Γ ⊢unfold [µα. A] e ⇒[α 7→µα. A] A
typing-fix
Γ, x : A ⊢e ⇐A
Γ ⊢ﬁx x : A. e ⇒A
typing-merge
Γ ⊢e1 ⇒A
Γ ⊢e2 ⇒B
Γ ⊢A ∗B
Γ ⊢e1, , e2 ⇒A&B
typing-mergev
· ⊢v1 ⇒A
· ⊢v2 ⇒B
v1 ≈spec v2
Γ ⊢v1, , v2 ⇒A&B
typing-fold
Γ ⊢e ⇐[α 7→µα. A] A
Γ ⊢µα. A
Γ ⊢fold [µα. A] e ⇒µα. A
Fig. 5: Typing.
In this relation, two values are consistent if for any type A casting of those two
values under type A produces the same result. We introduce the casting relation
v1 ,→A v2, which reduces the value v1 to v2 under the type A in Section 4.1. A
key property relating consistency and disjointness is:
Lemma 6 (Consistency of disjoint values).
If ⊢v1 ⇒A and ⊢v2 ⇒B
and ⊢A ∗s B then v1 ≈spec v2.
4
Dynamic Semantics of λµ
i
We now introduce the Type-Directed Operational Semantics (TDOS) for λµ
i .
TDOS, originally proposed by Huang et al. [28,29], is a variant of small-step
operational semantics. In TDOS, type annotations are operationally relevant,
since selecting values from merged values is type-directed. We show that λµ
i is
deterministic and type sound.

14
Zhou et. al.
v1 ,→A v2
(Casting)
tred-nat
i ,→nat i
tred-top
ord A
⌉A⌈
v ,→A A†
tred-mergeL
v1 ,→A v
ord A
v1, , v2 ,→A v
tred-mergeR
v2 ,→A v
ord A
v1, , v2 ,→A v
tred-rec
∼⌉µα. B⌈
· ⊢µα. A ≤µα. B
fold [µα. A] v ,→µα. B fold [µα. B] v
tred-arrow
∼⌉B2⌈
· ⊢B1 ≤A1
· ⊢A2 ≤B2
λx.e : A1 →A2 ,→B1→B2 λx.e : A1 →B2
tred-and
v ,→A v1
v ,→B v2
v ,→A&B v1, , v2
tred-rcd
v1 ,→A v2
∼⌉{α : A}⌈
{α = v1} ,→{α:A} {α = v2}
Fig. 6: Casting.
4.1
A Type-Directed Operational Semantics for λµ
i
The deﬁning feature of a TDOS is a relation called casting (originally called
typed reduction by Huang et al.). Casting plays an important role: based on
the contextual type information, values are further reduced to match the type
structure precisely. In many conventional operational semantics a value is the
ﬁnal result in a program, but with TDOS further reduction can happen if the
type that is required for the value has a mismatch with the shape of the value.
For example, if we have the merge 1, ,′ c′ at type Int then casting will produce 1.
However, the same value at type Int&Char would remain unchanged (1, ,′ c′).
The rules for casting are shown at the Figure 6. All non-intersection types
are ordinary types. Casting v1 ,→A v2 denotes that the value v1 is reduced to v2
under the type A. From the deﬁnitions, we can see that the A is the supertype
of the principal type of v1, and v2 is the value compatible with A. The most
special one is rule tred-top: if the type is toplike, then a value will reduce to
the corresponding top value, where the A† is deﬁned as:
(A →B)† = λx .⊤: A →B
{α : A}† =
{α : A†}
(µα. A)† = fold [µα. A] ⊤
(A&B)† =
A†, , B†
otherwise:A† = ⊤
4.2
Reduction
The deﬁnition of reduction is shown at the Figure 7. Most rules are standard.
Casting is used in rule step-beta for adjusting the argument value to the ex-
pected type for the input of the function. Casting is also used in rule step-annov
for annotations. Rules step-fld and
step-fldt are for unfold expressions.
Finally, there is also a special rule step-fldm for recursive types as well as
intersection types.

A Calculus with Recursive Types, Record Concatenation and Subtyping
15
e1 ⇝e2
(Reduction)
step-beta
v1 ,→A1 v2
(λx.e : A1 →A2) v1 ⇝([x 7→v2] e) : A2
step-appl
e1 ⇝e′
1
e1 e2 ⇝e′
1 e2
step-appr
e2 ⇝e′
2
v1 e2 ⇝v1 e′
2
step-proj
e ⇝e′
e.α ⇝e′.α
step-mergel
e1 ⇝e′
1
e1, , e2 ⇝e′
1, , e2
step-merger
e2 ⇝e′
2
v1, , e2 ⇝v1, , e′
2
step-anno
e ⇝e′
e : A ⇝e′ : A
step-annov
v ,→A v ′
v : A ⇝v ′
step-fix
ﬁx x : A. e ⇝([x 7→ﬁx x : A. e] e) : A
step-fold
e ⇝e′
fold [A] e ⇝fold [A] e′
step-rcd
e ⇝e′
{α = e} ⇝{α = e′}
step-unfold
e ⇝e′
unfold [A] e ⇝unfold [A] e′
step-fld
v1 ,→[α7→µα. A] A v2
∼⌉µα. A⌈
unfold [µα. A] (fold [µα. B] v1) ⇝v2
step-fldm
v1, , v2 ,→µα. A v
∼⌉µα. A⌈
unfold [µα. A] (v1, , v2) ⇝unfold [µα. A] v
step-fldt
v1 ,→[α7→µα. A] A v2
⌉µα. A⌈
unfold [µα. A] v1 ⇝v2
step-projrcd
{α = v}.α ⇝v
Fig. 7: Small-step semantics.
4.3
Determinism
One of the properties of our semantics is determinism: expressions will always
reduce to the same value. Lemma 7 says that if a value can be type-checked, then
it reduces to a same value under the type A. Lemma 8 says that if an expression
can be type-checked, then it reduces to a unique expression.
Lemma 7 (Determinism of ,→). If Γ ⊢v ⇒B and v ,→A v1 and v ,→A v2
then v1 = v2.
Proof. By induction on v ,→A v1.
Lemma 8 (Determinism of ⇝). If Γ ⊢e ⇔A and e ⇝e1 and e ⇝e2 then
e1 = e2.
Proof. By induction on e ⇝e1.
4.4
Type safety
We prove type safety following a similar approach to the previous work [29],
and by showing progress and preservation theorems. The following lemmas and
theorems show that our system is type-safe.

16
Zhou et. al.
Theorem 4 (Preservation). If ⊢e1 ⇔A and e1 ⇝e2 then ⊢e2 ⇐A.
Proof. By induction on ⊢e1 ⇔A.
Lemma 9 (Progress of ,→). If ⊢v1 ⇐A then ∃v2, v1 ,→A v2.
Proof. By induction on A.
Theorem 5 (Progress). If ⊢e1 ⇔A then e1 is a value or ∃e2, e1 ⇝e2.
Proof. By induction on ⊢e1 ⇔A.
5
Discussion and Related Work
Throughout the paper, we have already reviewed some of the closest related
work in detail. In this section, we will discuss other related work.
Disjoint Intersection Types and Record Calculi with Concatenation. Disjoint
intersection types were originally proposed by Oliveira et al. [33]. Such calculi
have intersection types as well as a merge operator [40,22] with a disjointness
restriction to ensure the determinism of the language. Follow-up work [2,6,5]
provides more advanced features, such as disjoint polymorphism and distributive
subtyping and ﬁrst-class traits, built upon the original work. With all these
features together, an alternative paradigm called Compositional Programming
(CP) is proposed [7,45]. CP allows for a very modular programming style where
the Expression Problem [43] can be solved naturally. A limitation of existing
calculi with disjoint intersection types is that they do not support recursive
types, which are important to encode binary methods [9] or, more generally,
recursive object types. The λµ
i calculus addresses this limitation and shows, for
the ﬁrst time, a calculus with disjoint intersection types and recursive types.
The merge operator generalizes concatenation by allowing values of any types
(not just record types) to be merged. As we described in the introduction the
interaction between subtyping and record concatenation is quite tricky. Cardelli
and Mitchell observed the problem [15], but did not provide a solution. Instead,
they decided to use record extension and restriction operators instead of con-
catenation. One solution adopted by some calculi [39,38,34,26] is to distinguish
between records that can be concatenated, and records that have subtyping. The
choice is mutually exclusive: records that can be concatenated cannot have sub-
typing and vice-versa. Such an approach would prevent Cardelli and Mitchell’s
f2 example in the introduction from type-checking. Calculi with disjoint inter-
section types, including λµ
i , oﬀer a diﬀerent solution by adopting a type-directed
semantics, which ensures that ﬁelds hidden by subtyping are also hidden at
runtime. This allows concatenation and subtyping to be used together.
As far as we know, no full formalization of a calculus supports subtyping,
record concatenation and recursive subtyping at the same time. In Cardelli’s F<:ρ
calculus [13] equi-recursive subtyping is assumed to be an extension to record
subtyping and record concatenation but no proofs were provided. Palsberg and
Zhao’s work [34] shows supporting subtyping, record concatenation and recursive
types (but no recursive subtyping) together for type inference is NP-complete.

A Calculus with Recursive Types, Record Concatenation and Subtyping
17
Alternative Models for Typed Objects. There are alternative ways to model ob-
jects without having records and record concatenation. Perhaps the most famous
one are Abadi and Cardelli’s object calculi [1]. In their work, objects are mod-
elled directly. No form of concatenation is provided, but the ﬁelds of objects can
be updated in object calculi. Besides, they also provide declarative type systems
(with a transitivity rule built-in) to support recursive subtyping.
Another alternative approach, which has received a lot of attention recently,
are calculi with dependent object types (DOT) [41], which aims to capture the
essence of Scala. Many variants of DOT include intersection types, a form of
recursive types and subtyping. However, there are no records and record con-
catenation, since objects are directly modelled rather than being encoded via
records. The subtyping rules for intersection types are similar to ours. Moreover,
the rules for recursive types employed in some variants of DOT [41,44,25] are
mostly structural and employ an inductive deﬁnition of subtyping. The key sub-
typing rules in the DOT variant by [41] are shown next:
Γ, z : T z
1 ⊢T z
1 <: T z
2
BindX
Γ ⊢µz. T z
1 <: µz. T z
2
Γ, z : T z
1 ⊢T z
1 <: T2
BindI
Γ ⊢µz. T z
1 <: T2
Γ ⊢x : T x
VarPack
Γ ⊢x : µz. T z
Γ ⊢x : µz. T z
VarUnpack
Γ ⊢x : T x
We adapt the notation employed by [41] for recursive types to our notation. In the
rules, T z denotes that variable z is free in type T. Rule BindX is in essence a one-
step ﬁnite unfolding of the recursive type, leading to an inductive deﬁnition of
subtyping. The second rule for recursive types (rule BindI) is a special case where
a recursive type µz. T z
1 is a subtype of another type T2 if T2 does not contain the
recursive variable z. A diﬀerence between recursive types µz. T z in DOT and the
ones in this paper is that in DOT z is a term variable instead of a type variable. In
DOT, recursive types can be used in combination with path-dependent types [3],
to denote types such as z.L, where z represents a (possibly recursive) term with
a type member L. Because of this design, the typing rules that introduce and
eliminate recursive types [41], are deﬁned on variables. Unlike our formulation
of subtyping, which is algorithmic, DOT’s formulation of subtyping is usually
presented in a declarative form. Undecidability is an important problem with
DOT’s formulation of subtyping [27], and the existing decidable fragments of
DOT lack transitivity [27,31].
Semantic Subtyping with Intersection Types and Equi-Recursive Types. Seman-
tic subtyping [24,16], provides a set-theoretic point of view for type systems.
In that approach, (equi-)recursive types and intersection types are interpreted
as subsets of the model, the subtyping relation is decidable, and some impor-
tant properties, such as transitivity, are derived naturally. Although semantic
subtyping approaches have many advantages, they can be technically more in-
volved, while the metatheory of syntactic formulations is simpler and generally
easier to extend. Damm [20] explored a type system with equi-recursive types

18
Zhou et. al.
and intersection types. His subtyping relation is quite expressive, as it supports
equi-recursive types and distributivity rules for subtyping. However, he does not
follow the conventional syntactic formulations of subtyping, such as the one in
this paper or those employed in DOT. Instead, types are encoded as regular
tree expressions/set constraints. In contrast, our formulation is more conven-
tional and supports iso-recursive types instead. Unlike our work Damm does not
consider extensible records with concatenation.
Other Languages with Recursive Types and Intersection Types. Some languages
employ recursive subtyping as well as intersection types, like Typescript [32]
and Whiley [36]. Typescript has a rich type system but no formal document
provided. [8] has formalized a subset of Typescript and proved that is safe, but
unfortunately, no intersection types are supported. Whiley is an experimental
language that supports recursive types, intersection types and subtyping. How-
ever, no work formalizes all the features together, lacking either recursive types
[35] or intersection types [30].
6
Conclusion
Recursive types, extensible record types and intersection types are important fea-
tures in many OOP languages, since object types can be modelled with recursive
records and multiple inheritance can be modelled via intersection types [17] and
record concatenation. Our λµ
i calculus illustrates that the 3 features can be put
together in a single calculus and therefore can be used to provide simple encod-
ings for objects. There are a few interesting directions for future work. One is
to add polymorphism and bounded quantiﬁcation to λµ
i , which is a signiﬁcant
feature for real world languages. Another one is to investigate distributive sub-
typing for iso-recursive subtyping. With distributivity, we can model a form of
family polymorphism [23].
Acknowledgement
We thank the anonymous reviewers for their helpful comments. This work has
been sponsored by Hong Kong Research Grant Council projects number 17209519,
17209520 and 17209821.
References
1. Abadi, M., Cardelli, L.: A theory of objects. Springer Science & Business Media
(1996)
2. Alpuim, J., Oliveira, B.C.d.S., Shi, Z.: Disjoint polymorphism. In: European Sym-
posium on Programming. pp. 1–28. Springer (2017)
3. Amin, N., Rompf, T., Odersky, M.: Foundations of path-dependent types. In: Pro-
ceedings of the 2014 ACM International Conference on Object Oriented Program-
ming, Systems, Languages, and Applications. OOPSLA ’14, Association for Com-
puting Machinery (2014)

A Calculus with Recursive Types, Record Concatenation and Subtyping
19
4. Barendregt, H., Coppo, M., Dezani-Ciancaglini, M.: A ﬁlter lambda model and
the completeness of type assignment. The journal of symbolic logic 48(4), 931–940
(1983)
5. Bi, X., Oliveira, B.C.d.S.: Typed ﬁrst-class traits. In: 32nd European Conference
on Object-Oriented Programming (ECOOP 2018) (2018)
6. Bi, X., Oliveira, B.C.d.S., Schrijvers, T.: The essence of nested composition.
In: 32nd European Conference on Object-Oriented Programming (ECOOP 2018)
(2018)
7. Bi, X., Xie, N., Oliveira, B.C.d.S., Schrijvers, T.: Distributive disjoint polymor-
phism for compositional programming. In: European Symposium on Programming.
pp. 381–409. Springer, Cham (2019)
8. Bierman, G., Abadi, M., Torgersen, M.: Understanding typescript. In: European
Conference on Object-Oriented Programming. pp. 257–281. Springer (2014)
9. Bruce, K., Cardeli, L., Castagna, G., Group, T.H.O., Leavens, G.T., Pierce, B.:
On binary methods. Theory and Practice of Object Systems 1(3) (1996)
10. Bruce, K.B., Cardelli, L., Pierce, B.C.: Comparing object encodings 155(1/2),
108–133 (Nov 1999), http://www.cis.upenn.edu/~bcpierce/papers/compobj.ps
11. Cardelli, L.: A semantics of multiple inheritance. In: Semantics of Data Types
(1984)
12. Cardelli, L.: Amber. In: LITP Spring School on Theoretical Computer Science. pp.
21–47. Springer (1985)
13. Cardelli, L.: Extensible records in a pure calculus of subtyping. Digital. Systems
Research Center (1992)
14. Cardelli, L.: A language with distributed scope. In: Proceedings of the 22nd
ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages.
p. 286–297. POPL ’95 (1995)
15. Cardelli, L., Mitchell, J.C.: Operations on records. Mathematical Structures in
Computer Science 1(1), 3–48 (1991)
16. Castagna, G., Frisch, A.: A gentle introduction to semantic subtyping. In: Proceed-
ings of the 7th ACM SIGPLAN international conference on Principles and practice
of declarative programming. pp. 198–199 (2005)
17. Compagnoni, A.B., Pierce, B.C.: Higher-order intersection types and multiple in-
heritance. Mathematical Structures in Computer Science (MSCS) 6(5), 469–501
(1996)
18. Cook, W.R., Hill, W., Canning, P.S.: Inheritance is not subtyping. In: Proceedings
of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages. p. 125–135. POPL ’90 (1989)
19. Cook, W.R., Palsberg, J.: A denotational semantics of inheritance and its cor-
rectness. In: Object-Oriented Programming: Systems, Languages and Applications
(OOPSLA) (1989)
20. Damm, F.M.: Subtyping with union types, intersection types and recursive types.
In: International Symposium on Theoretical Aspects of Computer Software. pp.
687–706. Springer (1994)
21. Davies, R., Pfenning, F.: Intersection types and computational eﬀects. In: Inter-
national Conference on Functional Programming (ICFP) (2000)
22. Dunﬁeld, J.: Elaborating intersection and union types. Journal of Functional Pro-
gramming 24(2-3), 133–165 (2014)
23. Ernst, E.: Family polymorphism. In: European Conference on Object-Oriented
Programming (ECOOP) (2001)
24. Frisch, A., Castagna, G., Benzaken, V.: Semantic subtyping. In: Proceedings 17th
Annual IEEE Symposium on Logic in Computer Science. pp. 137–146. IEEE (2002)

20
Zhou et. al.
25. Giarrusso, P.G., Stefanesco, L., Timany, A., Birkedal, L., Krebbers, R.: Scala step-
by-step: Soundness for dot with step-indexed logical relations in iris. Proc. ACM
Program. Lang. 4(ICFP) (Aug 2020)
26. Glew, N.: An eﬃcient class and object encoding. In: Proceedings of the 15th ACM
SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and
Applications. p. 311–324. OOPSLA ’00, Association for Computing Machinery
(2000)
27. Hu, J.Z., Lhot´ak, O.: Undecidability of dsub and its decidable fragments. Proceed-
ings of the ACM on Programming Languages 4(POPL), 1–30 (2019)
28. Huang, X., Oliveira, B.C.d.S.: A Type-Directed Operational Semantics For a
Calculus with a Merge Operator. In: 34th European Conference on Object-
Oriented Programming (ECOOP 2020). vol. 166 (2020). https://doi.org/10.
4230/LIPIcs.ECOOP.2020.26
29. Huang, X., Zhao, J., Oliveira, B.C.d.S.: Taming the merge operator: a type-directed
operational semantics approach. Journal of Functional Programming (2021)
30. Jones, T., Pearce, D.J.: A mechanical soundness proof for subtyping over recursive
types. In: Proceedings of the 18th Workshop on Formal Techniques for Java-like
Programs. pp. 1–6 (2016)
31. Mackay, J., Potanin, A., Aldrich, J., Groves, L.: Decidable subtyping for path
dependent types. Proceedings of the ACM on Programming Languages 4(POPL),
1–27 (2019)
32. Microsoft: Typescript (2021), https://www.typescriptlang.org/
33. Oliveira, B.C.d.S., Shi, Z., Alpuim, J.: Disjoint intersection types. In: Proceedings
of the 21st ACM SIGPLAN International Conference on Functional Programming.
pp. 364–377 (2016)
34. Palsberg, J., Zhao, T.: Type inference for record concatenation and subtyping. Inf.
Comput. 189(1) (Feb 2004)
35. Pearce, D.J.: Rewriting for sound and complete union, intersection and negation
types. ACM SIGPLAN Notices 52(12), 117–130 (2017)
36. Pearce, D.J., Groves, L.: Whiley: a platform for research in software veriﬁcation. In:
International Conference on Software Language Engineering. pp. 238–248. Springer
(2013)
37. Pierce, B.C.: Bounded quantiﬁcation is undecidable. Information and Computation
112(1), 131–165 (1994)
38. Pottier, F.: A 3-part type inference engine. In: European Symposium on Program-
ming. pp. 320–335. Springer (2000)
39. R´emy, D.: A case study of typechecking with constrained types: Typing record con-
catenation (1995), presented at the workshop on Advances in types for computer
science at the Newton Institute, Cambridge, UK
40. Reynolds, J.C.: Preliminary design of the programming language forsythe (1988)
41. Rompf, T., Amin, N.: Type soundness for dependent object types (dot). In: Pro-
ceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented
Programming, Systems, Languages, and Applications. pp. 624–641 (2016)
42. The Coq Development Team: Coq (2019), https://coq.inria.fr
43. Wadler, P.: The expression problem (1998), discussion on the Java Genericity mail-
ing list
44. Wang, F., Rompf, T.: Towards strong normalization for dependent object types
(dot). In: 31st European Conference on Object-Oriented Programming (ECOOP
2017). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik (2017)
45. Zhang, W., Sun, Y., Oliveira, B.C.d.S.: Compositional programming. ACM Trans-
actions on Programming Languages and Systems (TOPLAS) pp. 1–60 (2021)

A Calculus with Recursive Types, Record Concatenation and Subtyping
21
46. Zhou, Y., Oliveira, B.C.d.S., Fan, A.: A Calculus with Recursive Types, Record
Concatenation and Subtyping (Artifact) (Aug 2022). https://doi.org/10.5281/
zenodo.7003284
47. Zhou, Y., Zhao, J., Oliveira, B.C.d.S.: Revisiting iso-recursive subtyping. ACM
Transactions on Programming Languages and Systems (TOPLAS) (2022). https:
//doi.org/10.1145/3549537

