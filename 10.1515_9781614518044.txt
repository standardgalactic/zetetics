Logic, Computation, Hierarchies

Ontos Mathematical Logic
Edited by 
Wolfram Pohlers, Thomas Scanlon,  
Ernest Schimmerling, Ralf Schindler,  
Helmut Schwichtenberg
Volume 4

Logic, 
Computation, 
Hierarchies
Edited by 
Vasco Brattka, Hannes Diener, Dieter Spreen

ISBN 978-1-61451-783-2
e-ISBN 978-1-61451-804-4
ISSN 2198-2341
Library of Congress Cataloging-in-Publication Data
A CIP catalog record for this book has been applied for at the Library of Congress.
Bibliographic information published by the Deutsche Nationalbibliothek
The Deutsche Nationalbibliothek lists this publication in the Deutsche Nationalbibliografie; 
detailed bibliographic data are available on the Internet at http://dnb.dnb.de.
© 2014 Walter de Gruyter Inc., Boston/Berlin
Printing: CPI books GmbH, Leck 
♾ Printed on acid-free paper
Printed in Germany
www.degruyter.com

Victor Selivanov, Würzburg, 2013¹
1 Reproduced with permission of Ernestina Selivanova.


Preface
Computability and hierarchies are the leading themes of Victor Selivanov’s scien-
tiﬁc work. As a student he got interested in mathematical logic mainly because
of being dissatisﬁed with the level of rigour in the mathematical analysis lectures
he followed. Today, he is regarded as a world-expert in hierarchy theory, with his
publications having been highly inﬂuential. This volume is dedicated to Victor on
the occasion of his 60th birthday.
The idea for this Festschrift was born during a workshop in Novosibirsk in
honour of him and the splendid birthday party afterwards. We asked collaborators
and friends of his to contribute to a book that also should reﬂect the width of his
scientiﬁc interests. The result is a collection of 17 refereed articles written by 23
authors.
We would like to thank all that helped to produce this volume of high scien-
tiﬁc standard. These are of course the authors, but also the referees. Their careful
reading of the manuscripts and critical remarks made a crucial contribution. Spe-
cial thanks go to Svetlana Selivanova for answering questions on bibliographical
data.
Cape Town, Christchurch, Munich, Pretoria, Siegen, Winter 2013/14
Vasco Brattka¹
Hannes Diener²
Dieter Spreen³
1 Faculty of Computer Science, Universität der Bundeswehr, Munich, Germany, and Department
of Mathematics and Applied Mathematics, University of Cape Town, South Africa
2 Department of Mathematics, University of Siegen, Germany, and Department of Mathematics
and Statistics, University of Canterbury, Christchurch, New Zealand
3 Department of Mathematics, University of Siegen, Germany, and Department of Decision Sci-
ences, University of South Africa, Pretoria, South Africa


Contents
Preface | VII
Dieter Spreen
The Life and Work of Victor L. Selivanov | 1
Collins Amburo Agyingi, Paulus Haihambo, and Hans-Peter A. Künzi
Tight Extensions of T0-Quasi-Metric Spaces | 9
Klaus Ambos-Spies
On the Strongly Bounded Turing Degrees of Simple Sets | 23
Matthew de Brecht
Levels of Discontinuity, Limit-Computability, and Jump Operators | 79
Jacques Duparc, Olivier Finkel, and Jean-Pierre Ressayre
The Wadge Hierarchy of Petri Nets ω-Languages | 109
Willem L. Fouché
Diophantine Properties of Brownian Motion: Recursive Aspects | 139
Sy-David Friedman
The Completeness of Isomorphism | 157
Peter Hertling, Victor Selivanov
Complexity Issues for Preorders on Finite Labeled Forests | 165
Anton Konovalov
Boolean Algebras of Regular Quasi-aperiodic Languages | 191
Eryk Kopczyński, Damian Niwiński
A Simple Indeterminate Inﬁnite Game | 205
Luca Motto Ros, Philipp Schlicht
Lipschitz and Uniformly Continuous Reducibilities on Ultrametric Polish
Spaces | 213

X
|
Contents
Sergey Odintsov
On the Equivalence of Paraconsistent and Explosive Versions of Nelson
Logic | 259
Svetlana Selivanova
Computing Clebsch-Gordan Matrices with Applications in Elasticity
Theory | 273
Nikolay V. Shilov
An Approach to Design of Automata-Based Axiomatization for Propositional
Program and Temporal Logics (by Example of Linear Temporal Logic) | 297
Dieter Spreen
Partial Numberings and Precompleteness | 325
Dieter Spreen
An Isomorphism Theorem for Partial Numberings | 341
Ludwig Staiger
Two theorems on the Hausdorﬀmeasure of regular ω-languages | 383
Anton V. Zhukov
Some Notes on the Universality of Three-Orders on Finite Labeled
Posets | 393
Index | 411

Dieter Spreen
The Life and Work of Victor L. Selivanov
||
Dieter Spreen: Department of Mathematics, University of Siegen, Germany, and Department of
Decision Sciences, University of South Africa, Pretoria, South Africa
Victor L. Selivanov was born on the 25th of August, 1952, in Oktyabr’sky, a small
industrial city in the Republic of Bashkortostan (Russian Federation), near the
border with Tatarstan. He was the fourth (and youngest) child in his family. His
parents Lev N. Selivanov and Lidya G. Selivanova both worked as mathematics
teachers at a college in Oktyabr’sky.
He graduated with honours from Kazan State University (1974) and became
a postgraduate student of M.M. Arslanov and R.G. Bukharayev in Kazan. In 1979
he was awarded a Ph.D. in Mathematics from Novosibirsk University. The title of
the thesis was “On computable numberings”. Victor defended his habilitation the-
sis “Hierarchical classiﬁcation of arithmetical sets and index sets” at the Institute
of Mathematics of the Siberian Devision of the Russian Academy of Sciences in
Novosibirsk in 1989.
After spending a few years (1978–82) as Assistant Professor, ﬁrst at Ulyanovsk
Polytechnic Institute and then at Kazan Institute of Chemical Technology, he
moved to Novosibirsk State Pedagogical University, where he was Senior Lecturer
(1982–86), Docent (1986–90), Professor (1990–91) and Head of the Chair of In-
formatics and Discrete Mathematics (1991–2009). In 1993 he was appointed Full
Professor. Since 2009 he is Chief Research Fellow at the A.P. Ershov Institute of
Informatics Systems of the Siberian Devision of the Russian Academy of Sciences.
Selivanov’s research started in 1974 when he became a postgraduate student
at Kazan State University. It is devoted to Mathematical Logic, Computer Science,
and Didactics of Mathematics and Informatics. The main focus of his research is
computability, ranging from general computability theory to automata theory. In
the beginning his main contributions were in numbering theory. Later he shifted
to the study of hierarchies, which is still his central interest.
Numbering Theory
In his Ph.D. thesis he (i) proved that any nontrivial semilattice of computable num-
berings is not a lattice; (ii) constructed an example of a discrete, but not eﬀectively
discrete family of total recursive functions having a unique (up to equivalence)

2
|
Dieter Spreen
computable numbering; (iii) constructed an example of a non-discrete family of
computably enumerable sets having a unique (up to equivalence) computable
numbering. The results answers well known questions on computable number-
ings [1; 2; 3; 4; 5]. Result (ii) was later applied in learning theory.
In addition, he proved several facts on degrees of unsolvability, among oth-
ers he classiﬁed the possible versions of tt-reducibilities (a result that was in-
dependently obtained by Bulitko) and completely described the relationship be-
tween the Ershov hierarchy and the high-low hierarchy of degrees of unsolvability
[9; 16; 18; 25]. This was independently discovered by Jockusch and Shore.
Selivanov also developed a relativized version of the theory of precomplete
and complete numberings which led to priority-free proofs of several known re-
sults about the structure of tt-type degrees and about m-degrees of index sets in
such structures [17; 19; 26; 29].
In the beginning of the 1990s, Selivanov obtained general results on positively
numbered Boolean algebras, part of them jointly with Odintsov [21; 24]. The main
results are that this class of Boolean algebras always has a good computable num-
bering (an analog of the numbering of the computably enumerable sets) and that
there is a unique (up to eﬀective isomorphism) universal positive Boolean alge-
bra (an analog of the creative sets). He also characterized many natural and im-
portant index sets of positive Boolean algebras. Later some of these results were
extended by him to the very general context of recursively axiomatizable quasiva-
rieties [29; 34]. This research has diﬀerent applications, e.g. to the classiﬁcation of
many natural index sets in the lattice of computably enumerable sets, in the semi-
lattice of computably enumerable m-degrees and in the Lindenbaum algebra of
propositions [21; 22; 24; 28; 29; 34].
Hierarchies in Computability Theory
As is well known, the Ershov diﬀerence hierarchy is closely related to the so called
m-jump operator. In his habilitation thesis Selivanov deﬁned and investigated sev-
eral generalizations of this operator. It turned out that the generalized operators
are closely related to the theory of complete numberings developed by Mal’cev and
Ershov, and to the study of structures of m-degrees of index sets of the computably
enumerable sets as well as the partial recursive functions. The results led to a sim-
pliﬁcation and generalization of results by Hay about index sets [8; 11; 13; 15].
Selivanov, moreover, deﬁned a reﬁnement of the arithmetic hierarchy called
the ﬁne hierarchy and proved that it contains many known hierarchies and has
some rather strong closure properties with respect to reﬁnements. These results
informally mean that the ﬁne hierarchy is in some sense the ﬁnest possible. Later,

The Life and Work of Victor L. Selivanov
|
3
using set-theoretic operations introduced by Wadge, he gave a set-theoretical de-
scription of the ﬁne hierarchy. This yields the possibility of deﬁning the hierarchy
in very diﬀerent contexts, e.g. in the context of logic and descriptive set theory.
In the latter case, he could show that the ﬁne hierarchy is, in an exact sense, the
ﬁnite version of the Wadge hierarchy of Borel sets [13; 15; 20; 23; 24; 27; 28]. These
results are also part of his habilitation thesis.
He extended the ﬁne hierarchy from the case of sets to the case of k-partitions
[52]. With heavy use of Priestley duality he showed that the methods of alternating
trees and of m-reducibilities developed earlier by Addison, by him, and by others
for concrete examples of ﬁne hierarchies apply to a broad class of ﬁne hierarchies.
Selivanov gave a complete description of analogs of the famous Rice-Shapiro
theorem for all levels of the arithmetic hierarchy (as well as of some of its reﬁne-
ments). Another principal result is a complete description of m-degrees of index
sets of the predicates which are ﬁrst-order deﬁnable in the Lindenbaum algebra
of statements of nontrivial signature. Note that this classiﬁcation needs all levels
of the ﬁne hierarchy, i.e., it could not be achieved without the invention of the ﬁne
hierarchy (see [6; 7; 8; 10; 11; 12; 14; 20; 22; 24]).
Hierarchies in Complexity Theory
In the context of structural complexity theory Selivanov deﬁned and considered
analogs of the hierarchies mentioned above. He was able to extend the well-
known result of Kadin about the non-collapse of the Boolean hierarchy over NP
to a much richer hierarchy, called the plus-hierarchy [27; 31]. Further work in this
direction, essentially developed jointly with Glasser and Reitwiessner [51], led
to the solution of long-standing open problems such as a question by Blass and
Gurevich on the status of the shrinking property (also known as the reduction
property) for levels of the polynomial hierarchy.
Hierarchies in Language Theory
Selivanov also used the ﬁne hierarchy to classify regular ω-languages. It turned
out that the resulting classiﬁcation coincides with the Wagner hierarchy. This re-
sult establishes a close relationship between descriptive set theory and the the-
ory of regular ω-languages. It leads to rather diﬀerent proofs of deep and com-
plicated results of Wagner [30]. This investigation seems to have been the ﬁrst
applications of modern descriptive set theory to the theory of ω-languages, a line
which was also developed by French mathematicians such as Perrin, Carton, Du-

4
|
Dieter Spreen
parc and Finkel. Recently, Selivanov classiﬁed the Wadge degrees of ω-languages
of deterministic Turing machines [35]. In this way he answered a question raised
by Duparc.
In pursuing this research Selivanov developed a complete analog of the Wag-
ner hierarchy for the class of regular star-free ω-languages [42]. He also extended
the Wagner hierarchy from the case of sets to the case of k-partitions which, for
k > 2, leads to a much more complicated but still tractable structure of degrees
[53; 56]. Jointly with Wagner, he comprehensively investigated complexity ques-
tions related to his hierarchy [41].
Further on, he proposed a new, logical approach to the well known problem
of the decidability of the dot-depth hierarchy and of some its reﬁnements. In this
way, he obtained quite diﬀerent and shorter proofs of important results, as well
as new results on analogs of the dot-depth problem. Some of these results were
obtained independently and by other methods by Glasser, Schmitz and Wagner.
Using some previous results on the so called leaf languages, he established a deep
connection of these automata-theoretic hierarchies with the complexity-theoretic
ones mentioned above [32; 33].
In joint work with Wagner [38] the above-mentioned results were applied to
deﬁning and investigating a reducibility on star-free languages which ﬁts perfectly
to the dot-depth hierarchy. Both established a close relationship of this reducibil-
ity with the leaf-language approach to complexity classes. This research was ex-
tended to quasi-periodic languages, which form another important class of regu-
lar languages. [47].
Hierarchies in Descriptive Set Theory
Selivanov picked up an old problem of Scott and developed a rather comprehen-
sive theory of Borel and diﬀerence hierarchies in so called φ-spaces, which are
topological counterparts of algebraic directed-complete partial orderings, and a
theory of Wadge reducibility in such spaces. In a sense this theory parallels the
corresponding classical theory for Polish spaces. The theory has non-trivial appli-
cations to classical ω-ary Boolean operations of Kantorovich and Livenson and is
closely related to the theory of inﬁnitary languages, i.e. languages that may con-
tain both, ﬁnite and inﬁnite words [36; 37; 39; 44]. The extension is very natural
and suggests new interesting ways of extending classical descriptive set theory.
Recently, the descriptive set theory for φ-spaces was extended by de Brecht,
Becher and Grigorieﬀto some broader natural classes of spaces.
The theory was partially extended from the case of sets to the case of k-par-
titions [40; 43; 44; 48]. Jointly with Motto Ros and Schlicht, Selivanov extended

The Life and Work of Victor L. Selivanov
|
5
the classical Wadge theory to the broader class of quasi-Polish spaces [57], and
together with Schröder [58] he introduced and studied hierarchies of topological
spaces that include well known classes of spaces as the quasi-Polish spaces and
the Kleene-Kreisel continuous functionals.
New methods to study ﬁrst order deﬁnability in countable structures were de-
veloped which apply to structures on words and labeled trees [45; 46; 49; 50; 54;
55]. As a consequence comprehensive deﬁnability results for degree structures nat-
urally arising in topology and computable analysis were obtained, in particular,
for initial segments of the Wadge and Weihrauch degrees of k-partitions. This pro-
vides ﬁrst steps in the development of degree theory for topological structures in
parallel to the classical degree theory for discrete structures.
Many of Selivanov’s mathematical ideas have been taken up and developed
further by other mathematicians. His results found their way into monographs
and textbooks in computability and formal language theory, as well as in hand-
books. In addition to his interest in the foundations of mathematics and computer
science Selivanov has developed a strong interest in didactics. Here, his main aim
was to create new and more eﬃcient methods of teaching mathematics and in-
formatics to students of diﬀerent specialties and diﬀerent qualiﬁcations. He pro-
duced methods for teaching basic skills of oﬃce software, and found ways of in-
troducing algorithmics to school children, and conveying fundamentals of visual
programming as well as elements of computer modeling in secondary and high
school.
Selivanov has supervised 9 Ph.D. theses and many master dissertations. He
is the author of about 100 publications as well as several textbooks and didactic
materials of diﬀerent kind in Algebra, Logic, Informatics, and Didactics of Infor-
matics.
His work was honoured by a Humboldt Fellowship, Visiting Professorships
in Siegen and Paris, as well as two Mercator Professorships by the German Re-
search Foundation. He was awarded the honorary title “Merited Worker of the
High School” of the Russian Government in 1999 and the honorary title “Merited
Worker of Science and Technology of the Russian Federation” by the Ministry of
Science and Education of the Russian Federation in 2012.
Thanks to generous funding by the Austrian Science Fund, the German Aca-
demic Exchange Service, the German Research Foundation, the Russian Founda-
tion for Basic Research and, more recently, the European Union Selivanov was
an ever-welcome guest in Aachen, Cambridge, Darmstadt, Heidelberg, Munich,
Siegen, Swansea, Vienna, and Würzburg.

6
|
Dieter Spreen
Bibliography
[1]
On numberings of families of total recursive functions. Algebra and Logic, 15, N 2 (1976),
128–141.
[2]
Two theorems on computable numberings. Algebra and Logic, 15, N 4 (1976), 297–306.
[3]
On computability of some classes of numberings. Prob. Methods and Cybernetics, v.12-13,
Kazan University, Kazan,1976, 157–170 (Russian).
[4]
Numberings of canonically computable families of ﬁnite sets. Sib. Math. J., 18, N 6 (1977),
1373–1381 (Russian, there is an English translation).
[5]
Some remarks on classes of recursively enumerable sets. Sib. Math. J., 19, N 1 (1978),
109–115.
[6]
On index sets of classes of numberings. Prob. Methods and Cybernetics, v.14, Kazan
University, Kazan,1978, 90–103 (Russian).
[7]
On index sets of computable classes of ﬁnite sets. In: Algorithms and Automata, Kazan
University, Kazan,1978, 95–99 (Russian).
[8]
On the structure of degrees of index sets. Algebra and Logic, 18, N 4 (1979), 286–299.
[9]
On a class of reducibilities in recursion theory. Prob. Methods and Cybernetics, v.14,
Kazan University, Kazan, v. 18 (1982), 83–101 (Russian).
[10] On index sets in the Kleene-Mostowski hierarchy. Trans. Inst. Math., Novosibirsk, N 2
(1982), 135–158 (Russian).
[11]
On the structure of degrees of generalized index sets. Algebra and Logic, 21, N 4 (1982),
316–330.
[12] Eﬀective analogs of A-, B-, and Cs-sets with applications to index sets. Prob. Methods
and Cybernetics, v.14, Kazan University, Kazan, v. 19 (1983), 112–128 (Russian).
[13] Hierarchies of hyperarithmetical sets and functions. Algebra and Logic, 22, N 6 (1983),
473—491.
[14] Index sets in the hyperarithmetical hierarchy. Sib. Math. J., N 3 (1984), 474–488.
[15]
On a hierarchy of limiting computations. Sib. Math. J., 25, No 5 (1984), 798–806.
[16] On Ershov hierarchy. Sib. Math. J., 26, N 1 (1985), 105–116.
[17]
Index sets of factor-objects of the Post numbering. Algebra and Logic, 27, N 3 (1988),
215–224.
[18] Ershov hierarchy and Turing jump. Algebra and Logic, 27 N 4 (1988), 292–301.
[18] On algorithmic complexity of algebraic systems. Math. Notes, 44, No 5–6 (1988) p.944–
950.
[19] Applications of precomplete numberings to tt-type degrees and to index sets. Algebra
and Logic, 28, N 1 (1989), 51–56.
[20] Fine hierarchies of arithmetical sets and deﬁnable index sets. Trans. Inst. Math., Novosi-
birsk, 12 (1989), 165–185 (Russian).
[21] Arithmetical hierarchy and ideals of numbered boolean algebras (jointly with S.P.
Odintsov). Sib. Math. J., 30, N 6 (1989), 140–149 (Russian, there is an English transla-
tion).
[22] Index sets of classes of hyperhypersimple sets. Algebra and Logic, 29, N 2 (1990), 155–
168.
[23] A ﬁne hierarchy of formulas. Algebra and Logic, 30, N 5 (1991), 368–378.
[24] Fine hierarchies and deﬁnable index sets. Alg. and Logic, 30, N 6 (1991), 463–475.
[25] Jumps of some classes of sets. Math. Notes, 50, No 6 (1991), p.1299–1300.

The Life and Work of Victor L. Selivanov
|
7
[26] Precomplete numberings and functions without ﬁxed points. Math. Notes, Math. Notes,
51, No 1 (1992), p.95–99.
[27] Fine hierarchies and Boolean terms. The Journal of Symbolic Logic, 60, N 1 (1995), 289–
317.
[28] Fine hierarchy and deﬁnability in the Lindenbaum algebra. In: Logic: from foundations to
applications, Proceedings of the Logic Colloquium-93 in Keele. Oxford, 1996, 425–452.
[29] On recursively enumerable structures. Annals of pure and applied logic, 78 (1996), 243–
258.
[30] Fine hierarchy of regular omega-languages. Theor. Computer Science, 191 (1998), 37–59.
[31] Reﬁning the polynomial hierarchy. Algebra and Logic, 38 (1999), N 4, 248–258.
[32] Relating automata-theoretic hierarchies to complexity-theoretic hierarchies. Theoret.
Informatics Appl., 36 (2002), 29–42.
[33] On decidability of classes of hierarchies of regular aperiodic languages. Algebra and
Logic,41, N 5 (2002), 337–348.
[34] Positive structures. In: Computability and Models, Perspectives East and West, S. Barry
Cooper and Sergei S. Goncharov, eds., Kluwer Academic / Plenum Publishers, New York,
2003, 321–350.
[35] Wadge degrees of ω-languages of deterministic Turing machines. Theoretical Informatics
and Applications, 37 (2003), 67–83.
[36] Diﬀerence hierarchy in φ-spaces. Algebra and Logic, 43, N 4 (2004), 238–248.
[37] Hierarchies in φ-spaces and applications. Math. Logic Quarterly, 51, N 1 (2005), 45–61.
[38] A reducibility for the dot-depth hierarchy (jointly with K.W. Wagner). Theoretical Computer
Science, 345, N 2-3 (2005), 448–472.
[39] Towards a descriptive set theory for domain-like structures. Theoretical Computer Sci-
ence, 365 (2006), 258–282.
[40] The quotient algebra of labeled forests modulo h-equivalence. Algebra and Logic, 46, N 2
(2007), 120–133.
[41] Complexity of topological properties of regular ω-languages (jointly with K.W. Wagner).
Fundamenta Informaticae, 83(1-2): 197–217 (2008).
[42] Fine hierarchy of regular aperiodic ω-languages. International Journal of Foundations of
Computer Science, 19, No 3 (2008) 649–675.
[43] Wadge reducibility and inﬁnite computations. Mathematics in Computer Science, 2
(2008), 5–36 doi: 10.1007/ s11786-008-0042-x
[44] On the diﬀerence hierarchy in countably based T0-spaces. Electronic Notes in Theoretical
Computer Science, V. 221 (2008), 257-269, doi: 10.1016/ j.entcs. 2008.12.022.
[45] Deﬁnability in the h-quasiorder of labeled forests (jointly with O.V. Kudinov and A.V.
Zhukov). Annals of Pure and Applied Logic, 159(3): 318–332 (2009). doi: 10.1016/ j.apal.
2008.09.026.
[46] Undecidability in Some Structures Related to Computation Theory. Journal of Logic and
Computation, 19, No 1 (2009), 177–197; doi: 10.1093/ logcom/exn023
[47] Hierarchies and reducibilities on regular languages related to modulo counting. RAIRO
Theoretical Informatics and Applications, 41 (2009), 95–132. DOI: 10.1051/ ita:2007063
[48] On the Wadge reducibility of k-partitions. Journal of Logic and Algebraic Programming, 79,
No 1, 2010, 92–102. PII: S1567-8326(09)00024-1 DOI: 10.1016/ j.jlap.2009. 02.008
[49] Deﬁnability of closure operations in the h-quasiorder of labeled forests (jointly with Oleg
Kudinov and Anton Zhukov). Algebra and Logic, 49, No 2 (2010), 181–194.

8
|
Dieter Spreen
[50] Deﬁnability in the subword order (jointly with O.V. Kudinov and L.V. Yartseva). Siberian
Mathematical Journal, 51, No 3 (2010), 575–583.
[51]
The Shrinking Property for NP and coNP (jointly with C. Glasser and C. Reitwiessner).
Theoretical Computer Science 412 (2011), 853-864.
[52] Fine hierarchies via Piestley duality. Annals of Pure and Applied Logic, 163 (2012) 1075-
1107, doi:10.1016/j.apal.2011.12.029
[53] Complexity of aperiodicity for topological properties of regular ω-languages (jointly with
K.W. Wagner). Conf. Computability in Europe-2008 Lecture Notes in Computer Science, v.
5028. Berlin: Springer, 2008, 533–543.
[54] A Gandy theorem for abstract structures and applications to ﬁrst-order deﬁnability (jointly
with O.V. Kudinov). Proc. Of CiE-2009 (K. Ambos-Spies, B. Löwe and W. Merkle, eds.),
Lecture Notes in Computer Science, v. 5635. Berlin: Springer, 2009, 290–299.
[55] Undecidability in Weihrauch degrees (jointly with O. Kudinov and A. Zhukov). Proc. of
CiE-2010 (F. Ferreira, B. Löwe, E. Mayordomo and L.M. Gomes, eds.), Lecture Notes in
Computer Science, v. 6158. Berlin: Springer, 2010, 256–265.
[56] A ﬁne nierarchy of ω-regular k-partitions. B. Löwe et.al. (Eds.): CiE 2011, LNCS 6735, pp.
260–269. Springer, Heidelberg (2011).
[57] Wadge-like reducibilities on arbitrary quasi-Polish spaces (jointly with L. Motto Ros and P.
Schlicht). Accepted by Mathematical Structures in Computer Science, arXiv:1204.5338 v1
[mathLO] 24 Apr 2012.
[58] Some hierarchies of QCB0-spaces (jointly with M. Schröder). Mathematical Structures in
Computer Science, to appear.

Collins Amburo Agyingi, Paulus Haihambo, and
Hans-Peter A. Künzi
Tight Extensions of T0-Quasi-Metric Spaces¹
Abstract: Dress introduced and studied the concept of the tight span of a metric
space. It is known that Dress’s theory is equivalent to the theory of the injective
hull of a metric space independently discussed by Isbell some years earlier. In
a paper by Kemajou et al. it was shown that Isbell’s approach can be modiﬁed
to work similarly for T0-quasi-metric spaces and nonexpansive maps. Continuing
that work we show in the present paper that large parts of the theory developed
by Dress do not use the symmetry of the metric and - when appropriately modiﬁed
- hold essentially unchanged for T0-quasi-metric spaces.
Keywords: hyperconvexity; T0-quasi-metric space; injective hull; q-hyperconvex,
tight extension, tight span
Mathematics Subject Classiﬁcation 2010: AMS (2010) Subject Classiﬁcations:
54D35; 54E15; 54E35; 54E55; 54E50
||
Collins Amburo Agyingi, Paulus Haihambo, Hans-Peter A. Künzi: Department of Mathematics
and Applied Mathematics, University of Cape Town, South Africa
1 Introduction
In [7] Isbell showed that every metric space X has an injective hull TX, which is
compact if X is compact. Let us also recall that a metric space is called hypercon-
vex (see e.g. [9, p. 78]) if and only if it is injective in the category of metric spaces
and nonexpansive maps. Dress [4] later gave an independent, but equivalent ap-
proach to Isbell’s theory that is based on the concept of a tight extension.
In analogy to Isbell’s theory Kemajou et al. [8] proved that each T0-quasi-
metric space X has a q-hyperconvex hull QX, which is joincompact if X is join-
compact. They called a T0-quasi-metric space q-hyperconvex if and only if it is in-
jective in the category of T0-quasi-metric spaces and nonexpansive maps. In this
paper we intend to generalize results due to Dress [4] on tight extensions of met-
1 The authors would like to thank the National Research Foundation of South Africa for partial
ﬁnancial support. This research was also supported by a Marie Curie International Research Staﬀ
Exchange Scheme Fellowship within the 7th European Community Framework Programme.

10
|
C. A. Agyingi, P. Haihambo, and H.-P.A. Künzi
ric spaces to the category of T0-quasi-metric spaces and nonexpansive maps. In
particular we show that large parts of the theory of tight extensions do not use the
symmetry of the metric and under appropriate modiﬁcations still hold essentially
unchanged for T0-quasi-metrics. The results of the present paper will be applied
in further investigations of the authors about endpoints in T0-quasi-metric spaces
[2]. Hence it was necessary to develop the discussed theory below carefully in de-
tail, although it sometimes closely follows the classical metric theory.
2 Preliminaries
This section recalls the most important deﬁnitions that we shall use in the follow-
ing.
Deﬁnition 1. Let X be a set and d : X × X →[0, ∞) be a function mapping into
the set [0, ∞) of the nonnegative reals. Then d is a quasi-pseudometric on X if
(a) d(x, x) = 0 whenever x ∈X, and
(b) d(x, z) ≤d(x, y) + d(y, z) whenever x, y, z ∈X.
We shall say that (X, d) is a T0-quasi-metric space provided that d also satisﬁes
the following condition: For each x, y ∈X, d(x, y) = 0 = d(y, x) implies that
x = y.
Let d be a quasi-pseudometric on a set X. Then d−1 : X × X →[0, ∞) deﬁned by
d−1(x, y) = d(y, x) whenever x, y ∈X is also a quasi-pseudometric, called the
conjugate quasi-pseudometric of d. Note that if d is a T0-quasi-metric on X, then
ds = max{d, d−1} = d ∨d−1 is a metric on X.
Let (X, d) be a quasi-pseudometric space. For each x ∈X and ϵ > 0, Bd(x, ϵ) =
{y ∈X : d(x, y) < ϵ} denotes the open ϵ-ball at x. The collection of all “open” balls
yields a base for a topology τ(d). It is called the topology induced by d on X.
A map f : (X, d) →(Y, e) between quasi-pseudometric spaces is called iso-
metric provided that d(x, y) = e(f(x), f(y)) whenever x, y ∈X. Note that each
isometric map with a T0-quasi-metric domain is a one-to-one map.
A map f : (X, d) →(Y, e) between quasi-pseudometric spaces is called non-
expansive provided that e(f(x), f(y)) ≤d(x, y) whenever x, y ∈X.
Given two nonnegative real numbers a and b we shall write a ˙−b for max{a −
b, 0}, which in a more lattice-theoretic terminology we shall also denote by (a −
b) ∨0. Note that u(x, y) = x ˙−y with x, y ∈[0, ∞) deﬁnes the standard T0-quasi-
metric on [0, ∞).

Tight Extensions of T0-Quasi-Metric Spaces
|
11
For further basic concepts used from the theory of asymmetric topology we re-
fer the reader to [5] and [10]. Some recent work about quasi-pseudometric spaces
can be found in [1; 3; 11; 12; 14]. In the preprint [3] de Brecht for instance investi-
gates connections between the theory of T0-quasi-metric spaces and Victor Seliv-
anov’s work in descriptive set theory (see e.g. [15]).
3 q-hyperconvex hulls of T0-quasi-metric spaces
Next we recall some results mainly from [8] belonging to the theory of the q-
hyperconvex hull of a T0-quasi-metric space.
Let (X, d) be a T0-quasi-metric space. We shall say that a function pair f =
(f1, f2) on (X, d) where fi : X →[0, ∞) (i = 1, 2) is ample provided that d(x, y) ≤
f2(x) + f1(y) whenever x, y ∈X.
Let PX denote the set of all ample function pairs on (X, d). (In such situations
we may also write P(X,d) in cases where d is not obvious.) For each f , g ∈PX we
set D(f , g) = supx∈X(f1(x) ˙−g1(x))∨supx∈X(g2(x) ˙−f2(x)). Then D is an extended²
T0-quasi-metric on PX.
We shall call a function pair f minimal on (X, d) (among the ample function
pairs on (X, d)) if it is ample and whenever g is ample on (X, d) and for each x ∈X
we have g1(x) ≤f1(x) and g2(x) ≤f2(x),³ then g = f . It is well known that Zorn’s
Lemma implies that below each ample function pair there is a minimal ample
pair (for a more constructive and global approach, essentially due to Dress [4], see
Proposition 2 below). By QX we shall denote the set of all minimal ample pairs on
(X, d) equipped with the restriction of D to QX ×QX, which we shall also denote by
D. Recall that D is indeed a (real-valued) T0-quasi-metric on QX × QX [8, Remark
6].
Furthermore f ∈PX belongs to QX if and only if f1(x) = sup{d(y, x) ˙−f2(y) :
y ∈X} and f2(x) = sup{d(x, y) ˙−f1(y) : y ∈X} whenever x ∈X (see [11, Remark
2]).
It is known (see [8, Lemma 3]) that f ∈QX implies that f1(x) −f1(y) ≤d(y, x)
and f2(x) −f2(y) ≤d(x, y) whenever x, y ∈X :
2 If we replace in the deﬁnition of a quasi-pseudometric [0, ∞) by [0, ∞] we obtain the deﬁni-
tion of an extended quasi-pseudometric. Of course, the triangle inequality for extended quasi-
pseudometrics is interpreted in the self-explanatory way.
3 For any function pairs f and g satisfying this relation we shall write g ≤f .

12
|
C. A. Agyingi, P. Haihambo, and H.-P.A. Künzi
Indeed (compare [13, remark before Proposition 3.1]) given x ∈X we have that
f2(x) −d(x, x′) = sup{d(x, y) ˙−f1(y) : y ∈X} −d(x, x′) ≤sup{d(x′, y) ˙−f1(y) :
y ∈X} = f2(x′). The inequality for f1 is veriﬁed similarly.
Moreover supx∈X(f1(x) ˙−g1(x)) = supx∈X(g2(x) ˙−f2(x)) whenever f , g ∈QX
(compare [8, Lemma 7]).
For each x ∈X we can deﬁne the minimal function pair
fx(y) = (d(x, y), d(y, x))
(whenever y ∈X) on (X, d). The map j deﬁned by x →fx whenever x ∈X deﬁnes
an isometric embedding of (X, d) into (QX, D) (see [8, Lemma 1]).
We recall that (QX, D) is called the q-hyperconvex hull of (X, d). A T0-quasi-
metric space X is said to be q-hyperconvex if f ∈QX implies that there is an x ∈X
such that f = fx (compare [8, Corollary 4]). For an intrinsic characterization of
q-hyperconvexity see [8, Deﬁnition 2].
We also note that D(f , fx) = f1(x) and D(fx, f) = f2(x) whenever x ∈X and
f ∈QX [8, Lemma 8].
4 T0-quasi-metric tight extensions
In this section we generalize some crucial results about tight extensions of metric
spaces from [4] to our quasi-metric setting.
Proposition 2. (compare [4, Section 1.9]) Let (X, d) be a T0-quasi-metric space.
There exists a retraction map p : PX →QX, i.e., a map that satisﬁes the conditions
(a) D(p(f), p(g)) ≤D(f , g) whenever f , g ∈PX.
(b) p(f) ≤f whenever f ∈PX.
(In particular p(f) = f whenever f ∈QX, since each f in QX is minimal, and
thus p indeed is a retraction.)
Proof. Given a pair f ∈PX, we set f ∗
1 (y) = sup{d(x′, y) ˙−f2(x′) : x′ ∈X} whenever
y ∈X and f ∗
2 (x) = sup{d(x, y′) ˙−f1(y′) : y′ ∈X} whenever x ∈X.
Claim 1: f ∗≤f .
Note that for any x, y′ ∈X, we have d(x, y′) ≤f2(x)+f1(y′) and thus d(x, y′)−
f1(y′) ≤f2(x). Therefore f ∗
2 (x) = sup{d(x, y′) ˙−f1(y′) : y′ ∈X} ≤f2(x). In a
similar manner, we can show that f ∗
1 (y) ≤f1(y) whenever y ∈X. Thus f ∗≤f .
Claim 2: d(x, y) ≤f ∗
2 (x)+f1(y) and d(x, y) ≤f2(x)+f ∗
1 (y) whenever x, y ∈X.
Let x, y ∈X. We see that sup{d(x, y′) ˙−f1(y′) : y′ ∈X} + f1(y) ≥d(x, y) −
f1(y) + f1(y) = d(x, y). Similarly we have d(x, y) ≤f2(x) + sup{d(x′, y) ˙−f2(x′) :

Tight Extensions of T0-Quasi-Metric Spaces
|
13
x′ ∈X}. Therefore we get d(x, y) ≤f ∗
2 (x) + f1(y) and d(x, y) ≤f2(x) + f ∗
1 (y)
whenever x, y ∈X.
Deﬁne q : PX →PX by f →q(f) = ( 1
2(f1 + f ∗
1 ), 1
2(f2 + f ∗
2 )) whenever f ∈PX.
Claim 3: q(f) is indeed ample and q(f) ≤f .
In fact (q(f))2(x)+(q(f))1(y) = 1
2(f1(y)+f ∗
1 (y))+ 1
2(f2(x)+f ∗
2 (x)) = 1
2(f1(y)+
f ∗
2 (x)) + 1
2(f ∗
1 (y) + f2(x)) ≥1
2 d(x, y) + 1
2 d(x, y) = d(x, y) whenever x, y ∈X.
This shows that q(f) is ample. Obviously q(f) ≤f , since f ∗≤f .
Claim 4: We have that D(q(f), q(g)) ≤D(f , g) whenever f , g ∈PX :
Let f , g ∈PX and x ∈X. Then
f ∗
1 (x) = sup{d(y, x) ˙−f2(y) : y ∈X} ≤
sup{d(y, x) ˙−g2(y) + g2(y) ˙−f2(y) : y ∈X} ≤
sup{d(y, x) ˙−g2(y) : y ∈X} + sup{g2(y) ˙−f2(y) : y ∈X} ≤g∗
1(x) + D(f , g).
Therefore
sup
x∈X
((q(f))1(x) ˙−(q(g))1(x)) ≤1
2 sup
x∈X
(f1(x) ˙−g1(x)) + 1
2 sup
x∈X
(f ∗
1 (x) ˙−g∗
1(x))
≤1
2 D(f , g) + 1
2 D(f , g) = D(f , g).
Similarly we can show that supx∈X((q(g))2(x) ˙−(q(f))2(x)) ≤D(f , g) whenever
f , g ∈PX. Thus D(q(f), q(g)) ≤D(f , g) whenever f , g ∈PX.
In the rest of the proof, given f ∈PX, we obtain a minimal ample function
pair below f as the pointwise limit of the sequence (qn(f))n∈N where qn is the nth-
iteration of q :
Fix f ∈PX. Obviously for n ∈N the n-iteration qn of q yields a monotonically
decreasing sequence (qn(f)) that is bounded below by the 0-pair.
Hence the map p(f) := limn→∞qn(f) exists, where we take the pointwise
limit pair with respect to the usual topology τ(us) on [0, ∞).
Note that obviously for each n ∈N, qn(f) belongs to PX and qn satisﬁes the
conditions (a) and (b), too.
Therefore p(f) ∈PX and p also satisﬁes condition (b).
For each n ∈N, f , g ∈PX and x ∈X we have
[(qn(f))1(x) ˙−(qn(g))1(x)] ∨[(qn(g))2(x) ˙−(qn(f))2(x)] ≤D(f , g);
thus D(p(f), p(g)) ≤D(f , g) and p satisﬁes condition (a), too.
We ﬁnally show that p(f) ∈QX whenever f ∈PX.
Let f ∈PX. For all n ∈N we have p(f) ≤qn(f) and hence p(f)∗≥qn(f)∗by
deﬁnition of the ∗-operation.

14
|
C. A. Agyingi, P. Haihambo, and H.-P.A. Künzi
So 0 ≤p(f) −p(f)∗≤qn(f) −qn(f)∗= 2(qn(f) −qn+1(f)) (compare [13,
proof of Proposition 3.1]), since qn+1(f) =
qn(f)+qn(f)∗
2
. In particular this yields
that p(f) = p(f)∗. But then h := p(f) is minimal among the ample function pairs:
Indeed let g ≤h, that is g1 ≤h1 and g2 ≤h2, and let g be an ample function
pair. Then for each x ∈X,
h2(x) = sup
y∈X
(d(x, y) ˙−h1(y)) ≤sup
y∈X
(d(x, y) ˙−g1(y)) ≤g2(x)
by ampleness of g. So g2 = h2. Similarly g1 = h1 and therefore the pair h is
minimal ample.
Remark 1. We next note that Proposition 2 can also be proved by Zorn’s Lemma
(compare [4, Section 1.9]).
Proof. We only sketch the idea of this proof. Let P be the set of all maps p from PX
to PX satisfying the following two conditions (1) p(f) ≤f and (2) D(p(f), p(g)) ≤
D(f , g) whenever f , g ∈PX.
Deﬁne a partial order ⪯on P as follows:
p ⪯q iﬀ[p(f) ≤q(f) and D(p(f), p(g)) ≤D(q(f), q(g))] whenever f , g ∈PX.
Let K be a nonempty chain in (P, ⪯). Deﬁne a map t : PX →PX by
t(f)(x) := ( inf
k∈K(k(f))1(x), inf
k∈K(k(f))2(x))
whenever x ∈X, where the inﬁma are taken pointwise in [0, ∞).
One veriﬁes that t is a lower bound of K in (P, ⪯). By Zorn’s Lemma P has a
minimal element, say m.
Let us now see that m(f) ∈QX whenever f ∈PX. We need the following
lemma that is of independent interest.
Lemma 3. (compare [4, Section 1.3]) Let (X, d) be a T0-quasi-metric space and let
f ∈PX. For each x ∈X set (px(f))1(z) = f1(z) if z ∈X \ {x} and
(px(f))1(x) = sup{d(y, x) ˙−f2(y) : y ∈X}
and (px(f))2(z) = f2(z) if z ∈X \ {x} and
(px(f))2(x) = sup{d(x, y) ˙−f1(y) : y ∈X}.
Then for each x ∈X, px ∈P.
Proof. We leave the details of the proof of the lemma to the reader.
We now ﬁnish the proof of Remark 1. For each x ∈X we obviously have that px ◦
m ∈P and px ◦m ⪯m. Hence by minimality of m, px ◦m = m whenever x ∈X.

Tight Extensions of T0-Quasi-Metric Spaces
|
15
It follows that for each x ∈X, px(m(f)) = m(f) whenever f ∈PX. Thus by the
deﬁnition of the elements of QX we conclude that m(f) ∈QX whenever f ∈PX by
[11, Remark 2].
Remark 2. (The general quasi-metric “segment Iab”.) Let X = [0, 1]. Choose
a, b ∈[0, ∞) such that a + b ̸= 0. Set dab(x, y) = (x −y)a if x > y and
dab(x, y) = (y −x)b if y ≥x. Then ([0, 1], dab) is a T0-quasi-metric space, as it is
readily checked, by considering the various cases for the underlying asymmetric
norm nab on R deﬁned by nab(x) = xa if x > 0 and nab(x) = −xb if x ≤0.
Remark 3. (compare [4, Section 1.10]) Using some p (as in Proposition 2) we can
deﬁne for any f ∈QX a map Ψ : [0, 1] × QX →QX as follows: (t, g) →pt(g) =
p(tf + (1 −t)g) from p0, the identity on QX, to p1, the constant map QX →{f} ⊆
QX. Here we used the fact that tf + (1 −t)g ∈PX.
Note that moreover, for any s, t ∈[0, 1] with t ≤s one has D(ps(g), pt(g)) =
D(p(sf +(1−s)g), p(tf +(1−t)g)) ≤D(sf +(1−s)g, tf +(1−t)g) = supx∈X((s−
t)f1(x) ˙−(s −t)g1(x)) ∨supx∈X((s −t)g2(x) ˙−(s −t)f2(x)) = (s −t)D(f , g).
Furthermore
D(f , g) ≤D(f , ps(g)) + D(ps(g), pt(g))
+
D(pt(g), g) =
D(p1(g), ps(g)) + D(ps(g), pt(g))
+
D(pt(g), p0(g)) =
(1 −s)D(f , g) + D(ps(g), pt(g))
+
tD(f , g).
Therefore
D(ps(g), pt(g)) ≥(s −t)D(f , g)
and thus
D(ps(g), pt(g)) = (s −t)D(f , g)
whenever g ∈QX and 0 ≤t ≤s ≤1.
If 0 ≤s ≤t ≤1 and g ∈QX, then a similar computation yields
D(ps(g), pt(g)) = D−1(pt(g), ps(g)) = (t −s)D−1(f , g) = (t −s)D(g, f).
Set a = D(f , g) and b = D(g, f). Then the map ([0, 1], dab) →(QX, D) deﬁned
by s →ps(g) yields an isometric map connecting g to f .
We next show that if we equip the unit interval [0, 1] of the reals with its stan-
dard topology τ(us) (where, as usual, us also denotes the restriction of the metric
us to [0, 1]) and QX with the topology τ(D), then the map Ψ is continuous, that is,
Ψ : [0, 1] × QX →QX is a homotopy and QX is contractible in the classical sense.
Indeed suppose that the sequence (sn)n∈N converges to s in ([0, 1], τ(us)) and
the sequence (gn)n∈N converges to g in (QX, τ(D)), that is D(g, gn) →0 if n →∞.

16
|
C. A. Agyingi, P. Haihambo, and H.-P.A. Künzi
Then for each n ∈N, by the triangle inequality we have that
D(ps(g), psn(gn)) ≤D(ps(g), psn(g)) + D(psn(g), psn(gn)).
Therefore for each n ∈N we see that
D(ps(g), psn(g)) = (s −sn)D(f , g)
if s ≥sn and
D(ps(g), psn(g)) = (sn −s)D(g, f)
if sn ≥s, according to the calculations completed above.
Moreover for each n ∈N, we get that
D(psn(g), psn(gn)) = (1 −sn)D(g, gn)
by deﬁnition of D.
By our assumptions we conclude that
D(ps(g), psn(g)) →0
and
D(psn(g), psn(gn)) →0
if n →∞. Therefore D(ps(g), psn(gn)) →0 if n →∞, and hence Ψ is indeed
continuous.
Proposition 4. (compare [4, Section 1.11]) Let (Y, d) be a T0-quasi-metric space
and let X be a (nonempty) subspace of (Y, d). Then there exists an isometric em-
bedding τ : QX →QY such that τ(f)|X = f whenever f ∈QX.
Proof. Let x0 ∈X be ﬁxed and choose a retraction p : PY →QY satisfying the
conditions (a) and (b) of Proposition 2. Furthermore let s : QX →PY be deﬁned
as s(f) = f ′ where f ′
1(y) = f1(y) whenever y ∈X, and f ′
1(y) = f1(x0) + d(x0, y)
whenever y ∈Y\X. Similarly f ′
2(y) = f2(y) whenever y ∈X, and f2(y) = d(y, x0)+
f2(x0) whenever y ∈Y \ X.
We prove that f ′ ∈PY by considering four cases:
Suppose x ∈X and y ∈X; then f ′
2(x) + f ′
1(y) = f2(x) + f1(y) ≥d(x, y).
Suppose that x ∈Y \ X and y ∈Y \ X; then f ′
2(x) + f ′
1(y) = d(x, x0) + f2(x0) +
f1(x0) + d(x0, y) ≥d(x, x0) + d(x0, y) ≥d(x, y).
Suppose that x ∈X and y ∈Y \ X; then f ′
2(x) + f1(y) = f2(x) + f1(x0) +
d(x0, y) ≥d(x, x0) + d(x0, y) ≥d(x, y).
Suppose that x ∈Y \ X and y ∈X; then f ′
2(x) + f ′
1(y) = d(x, x0) + f2(x0) +
f1(y) ≥d(x, x0) + d(x0, y) ≥d(x, y). Thus f ′ ∈PY.

Tight Extensions of T0-Quasi-Metric Spaces
|
17
Deﬁne τ = p ◦s : QX →QY. Note that τ(f)|X = p(f ′)|X = f whenever f ∈QX,
since p(f ′) ≤f ′, therefore p(f ′)|X ≤f ′|X = f , and f is minimal on X.
Furthermore for any f , g ∈QX,
D(f , g) = D(τ(f)|X, τ(g)|X)
≤
D(τ(f), τ(g)) =
D(p(f ′), p(g′))
≤
D(f ′, g′) = D(f , g)
where the last equality follows from the deﬁnition of f ′ and g′.
Deﬁnition 5. (compare [8, Remark 7]) Let X be a subspace of a T0-quasi-metric
space (Y, d). Then Y is called a tight extension of X if for any quasi-pseudometric
e on Y that satisﬁes e ≤d and agrees with d on X × X we have that e = d.
In [8, Remark 7] it was shown that for any T0-quasi-metric space (X, d) we have
that the isometric embedding j : X →QX is tight, that is, QX is a tight extension
of j(X).
Remark 4. (see [4, Section 1.12]) For any T0-quasi-metric tight extension Y1 of X,
any T0-quasi-metric extension (Y2, d) of X and any nonexpansive map ψ : Y1 →
Y2 satisfying ψ(x) = x whenever x ∈X, ψ is necessarily an isometric map.
Proof. Otherwise the quasi-pseudometric ρ : Y1 × Y1 →[0, ∞) deﬁned by
(x, y) →ρ(x, y) = d(ψ(x), ψ(y)) would contradict the tightness of the extension
Y1 of X.
Proposition 6. (compare [4, Section 1.13]) Let (Y, d) be a T0-quasi-metric tight
extension of X. Then the restriction map deﬁned by f →f|X whenever f ∈QY is a
bijective isometric map QY →QX.
Proof. Choose a retraction p : PX →QX satisfying the conditions (a) and (b) of
Proposition 2 and let ψ : QY →QX : f →p(f|X) denote the composition of p with
the restriction map. Then ψ is a nonexpansive map and QY and QX are T0-quasi-
metric extensions of X. According to Remark 4 ψ must be an isometric map, since
QY is a tight extension of X, because QY is a tight extension of Y and Y is a tight
extension of X.
By Proposition 4 there is an isometric embedding τ : QX →QY satisfying
τ(f)|X = f for all f ∈QX. Then we have ψ(τ(f)) = p(τ(f)|X) = p(f) = f for
all f ∈QX and thus ψ is necessarily surjective. But a surjective isometric map
on a T0-quasi-metric domain is necessarily bijective. So τ : QX →QY has to be
the map inverse to ψ and thus for any f ∈QY we necessarily have the formula
f|X = τ(ψ(f))|X = ψ(f) ∈QX, that is, the restriction map QY →PX : f →f|X maps

18
|
C. A. Agyingi, P. Haihambo, and H.-P.A. Künzi
QY already onto QX, without having to be composed with the retraction map p.
Hence we see that for any T0-quasi-metric tight extension Y of X the restriction
map QY →QX : f →f|X yields a bijective isometric map between QY and QX.
Proposition 7. (compare [6, Theorem 2]) Let X be a subspace of the T0-quasi-
metric space (Y, d). Then the following three conditions are equivalent:
(a) Y is a tight extension of X.
(b) d(y1, y2) = sup{(d(x1, x2) −d(x1, y1) −d(y2, x2)) ∨0 : x1, x2 ∈X}
whenever y1, y2 ∈Y.
(c) fy|X(x) = (d(y, x), d(x, y)) with x ∈X is minimal on X whenever y ∈Y and
the map Φ : (Y, d) →(QX, D) : y →fy|X is an isometric embedding.
Proof. (a) →(b): Let Y be a T0-quasi-metric tight extension of X. By Proposition
6 the map QY →QX deﬁned by f →f|X deﬁnes a bijective isometric map between
QY and QX. Hence the extension Y of X, as a subspace of QY, fulﬁls condition (b)
of Proposition 7, since the extension QX of X satisﬁes it by [8, Remark 7].
(b) →(c): For any x1, x2 ∈X and y1 ∈Y we have that
d(x1, x2) ≤d(x1, y1) + d(y1, x2).
Therefore for any x1, x2 ∈X and y1, y2 ∈Y we see that
d(x1, x2) −d(x1, y1) −d(y2, x2) ≤d(y1, x2) −d(y2, x2).
Consequently for any y1, y2 ∈Y we have by (b) that
d(y1, y2) = sup{(d(x1, x2) −d(x1, y1) −d(y2, x2)) ∨0 : x1, x2 ∈X} ≤
sup{(d(y1, x2) ˙−d(y2, x2)) : x2 ∈X} ≤d(y1, y2).
Similarly
d(x1, x2) ≤d(x1, y2) + d(y2, x2)
whenever x1, x2 ∈X and y2 ∈Y.
It follows that for each x1, x2 ∈X and y1, y2 ∈Y we have that
d(x1, x2) −d(y2, x2) −d(x1, y1) ≤d(x1, y2) −d(x1, y1).
Thus for any y1, y2 ∈Y we see by (b) that
d(y1, y2) ≤sup{(d(x1, x2) −d(y2, x2) −d(x1, y1)) ∨0 : x1, x2 ∈X} ≤
sup{(d(x1, y2) ˙−d(x1, y1)) : x1 ∈X} ≤d(y1, y2).
Hence we conclude that d(y1, y2) = D(fy1|X, fy2|X) whenever y1, y2 ∈Y.

Tight Extensions of T0-Quasi-Metric Spaces
|
19
As we have just shown, for any y1, y2 ∈Y we have that
d(y1, y2) = sup{(d(x1, y2) ˙−d(x1, y1)) : x1 ∈X}
and
d(y1, y2) = sup{(d(y1, x2) ˙−d(y2, x2)) : x2 ∈X}.
Substituting x2 ∈X for y2 and x1 ∈X for y1, respectively, we obtain the two
equations
(fy1)1(x2) = d(y1, x2) = sup{(d(x1, x2) ˙−d(x1, y1)) : x1 ∈X}
whenever y1 ∈Y and x2 ∈X,
and
(fy2)2(x1) = d(x1, y2) = sup{(d(x1, x2) ˙−d(y2, x2)) : x2 ∈X}
whenever y2 ∈Y and x1 ∈X.
By [11, Remark 2] the restriction fy|X is minimal on X whenever y ∈Y.
(c)→(a): Let q : Y ×Y →[0, ∞) be a quasi-pseudometric on Y such that q ≤d
and q|X×X = d|X×X.
According to (c) and since fy|X is minimal whenever y ∈X we have d(y1, y2) =
D(fy1|X, fy2|X) = supx∈X(d(y1, x) ˙−d(y2, x)) = supx∈X(d(x, y2) ˙−d(x, y1)) when-
ever y1, y2 ∈Y by [8, Lemma 7].
Then substituting
d(x1, y2) = sup{(d(x1, x2) ˙−d(y2, x2)) : x2 ∈X}
into the formula
d(y1, y2) = sup{(d(x1, y2) ˙−d(x1, y1)) : x1 ∈X},
we obtain
d(y1, y2) = sup
x1∈X
sup
x2∈X
{(d(x1, x2) −d(x1, y1) −d(y2, x2)) ∨0}
≤
sup
x1,x2∈X
{(q(x1, x2) −q(x1, y1) −q(y2, x2)) ∨0} ≤q(y1, y2)
whenever y1, y2 ∈Y by our assumption. Consequently q = d.
Therefore condition (a) is satisﬁed.
Remark 5. (compare [4, Section 1.14]) Let (Y, d) be a T0-quasi-metric of X. Elabo-
rating further on Proposition 7 we see that there is only one isometric embedding
ϕ : Y →QX satisfying ϕ(x) = fx whenever x ∈X, since for such an embedding

20
|
C. A. Agyingi, P. Haihambo, and H.-P.A. Künzi
ϕ : Y →QX, y ∈Y and x ∈X, we have (fy)2|X(x) = d(x, y) = D(ϕ(x), ϕ(y)) =
D(fx, ϕ(y)) = (ϕ(y))2(x); therefore (fy)2|X = (ϕ(y))2. In a similar way, one can
show that (fy)1|X = (ϕ(y))1 whenever y ∈Y.
In particular we see that the tight extension Y of X can be understood as a
subspace of the extension QX of X. Hence QX is maximal among the T0-quasi-
metric tight extensions of X.
We ﬁnally discuss an asymmetric version of a result due to Herrlich. To this end,
given a quasi-pseudometric space (X, dX), for each x ∈X and ϵ > 0, by CdX(x, ϵ) =
{y ∈X : dX(x, y) ≤ϵ} we denote the so-called closed ball of radius ϵ at x. (Note
that it is closed with respect to the topology τ(d−1
X ).)
In X we say that the (double) family C = (CdX(xi, ri), Cd−1
X (yi, si))i∈I of such
balls meets potentially provided that there exists a T0-quasi-metric extension
(Y, dY) of (X, dX) such that 
i∈I(CdY (xi, ri) ∩Cd−1
Y (yi, si)) ̸= ∅.
Proposition 8. (compare [6, Proposition]) If C = (CdX(xi, ri), Cd−1
X (xi, si))i∈I is a
(double) family of balls in a T0-quasi-metric space (X, d), then the following condi-
tions are equivalent:
(1) C meets potentially in X.
(2) For any i, j ∈I, CdX(xi, ri) meets with any Cd−1
X (xj, sj) potentially in X.
(3) dX(xi, xj) ≤ri + sj whenever i, j ∈I.
(4) There exists a minimal (ample) function pair t = (t1, t2) on X with t2(xi) ≤
ri and t1(xi) ≤si whenever i ∈I.
Proof. (1) →(2) →(3) are obvious.
(3) →(4) is obvious for I = ∅.
Otherwise deﬁne a function pair f = (f1, f2) on Y = {xi : i ∈I} by setting for
each y ∈Y, f1(y) = inf{si : xi = y} and f2(y) = inf{ri : xi = y}. Choose y0 ∈Y.
Set g1(x) = f1(x) if x ∈Y, and g1(x) = f1(y0) + dX(y0, x) if x ∈X \ Y.
Furthermore set g2(x) = f2(x) if x ∈Y, and g2(x) = dX(x, y0) + f2(y0) if
x ∈X \ Y.
Then g1(xi) ≤si and g2(xi) ≤ri whenever i ∈I. Furthermore dX(x, x′) ≤
g2(x)+ g1(x′) whenever x ∈X and x′ ∈X. Thus g = (g1, g2) is an ample function
pair on X and by Zorn’s Lemma there is a minimal ample pair t = (t1, t2) on X
such that t ≤g.
(4) →(1) : Let t = (t1, t2) be a minimal ample pair on X with t1(xi) ≤si and
t2(xi) ≤ri whenever i ∈I. If t = fx for some x ∈X, then x ∈
i∈I(CdX(xi, ri) ∩
Cd−1
X (xi, si)). Thus the family C meets in X.
Otherwise extend X to a space Y by adding one point y0 to X and by deﬁn-
ing a T0-quasi-metric dY on Y extending dX and satisfying dY(x, y0) = t2(x) and

Tight Extensions of T0-Quasi-Metric Spaces
|
21
dY(y0, x) = t1(x) whenever x ∈X. One readily checks that dY is a T0-quasi-metric
on Y (compare [8, end of proof of Theorem 1]).
Then y0 ∈
i∈I(CdY (xi, ri) ∩Cd−1
Y (xi, si)) and we are done.
The following example answers a question asked by one of the referees.
Remark 6. (see [8, Example 7]) Let X be the set {0, 1} equipped with the discrete
metric. Then QX is isometric to the product set [0, 1]×[0, 1] of two copies of real unit
intervals [0, 1] equipped with the T0-quasi-metric D((α, β), (α′, β′)) = u(α, α′) ∨
u(β, β′) whenever (α, β), (α′, β′) ∈[0, 1] × [0, 1], while TX can be identiﬁed with
the subspace {(α, 1 −α) : α ∈[0, 1]} in this product, that is, TX is isometric to the
unit interval [0, 1] of the reals equipped with the restriction of the metric us.
Observe that, intuitively, QX consists of all the points z determined by the
equations 1 = D(f0, z) + D(z, f1) and 1 = D(f1, z) + D(z, f0).
We recall from [8, Proposition 5] that for any metric space (X, m), there exists
a canonical isometric embedding of TX into QX.
Acknowledgement: We would like to thank an anonymous referee for his useful
comments.
Bibliography
[1]
E. Colebunders, S. De Wachter and B. Lowen, Intrinsic approach spaces on domains,
Topology Appl. 158: 2343–2355, 2011.
[2]
A. Collins Amburo, P. Haihambo and H.-P.A. Künzi, Endpoints in T0-quasi-metric spaces,
in preparation.
[3]
M. de Brecht, Quasi-Polish spaces, Ann. Pure Appl. Logic 164: 356–381, 2013.
[4]
A.W.M. Dress, Trees, tight extensions of metric spaces, and the cohomological dimension
of certain groups: a note on combinatorial properties of metric spaces, Adv. Math. 53:
321–402, 1984.
[5]
P. Fletcher and W.F. Lindgren, Quasi-uniform Spaces, Dekker, New York, 1982.
[6]
H. Herrlich, Hyperconvex hulls of metric spaces, Topology Appl. 44: 181–187, 1992.
[7]
J.R. Isbell, Six theorems about injective metric spaces, Comment. Math. Helv. 39: 65–76,
1964.
[8]
E. Kemajou, H.-P.A. Künzi and O.O. Otafudu, The Isbell-hull of a di-space, Topology Appl.
159: 2463–2475, 2012.
[9]
M.A. Khamsi and W.A. Kirk, An Introduction to Metric Spaces and Fixed Point Theory, John
Wiley, New York, 2001.
[10] H.-P.A. Künzi, An introduction to quasi-uniform spaces, Contemp. Math. 486: 239–304,
2009.
[11]
H.-P.A. Künzi and M. Sanchis, The Katětov construction modiﬁed for a T0-quasi-metric
space, Topology Appl. 159: 711–720, 2012.

22
|
C. A. Agyingi, P. Haihambo, and H.-P.A. Künzi
[12] H.-P.A. Künzi and M. Sanchis, Addendum to “The Katětov construction modiﬁed for a
T0-quasi-metric space”, Math. Struct. in Comp. Science (to appear).
[13] U. Lang, Injective hulls of certain discrete metric spaces and groups, arXiv:1107.5971v2
[math.GR] 28 June 2012.
[14] J. Marín, S. Romaguera and P. Tirado, Weakly contractive multivalued maps and w-
distances on complete quasi-metric spaces, Fixed Point Theory Appl. 2011:2, 9pp, 2011.
[15]
V. Selivanov, On the diﬀerence hierarchy in countably based T0-spaces, Electronic Notes
in Theoretical Computer Science 221: 257–269, 2008.

Klaus Ambos-Spies
On the Strongly Bounded Turing Degrees of
Simple Sets¹
Abstract: We study the r-degrees of simple sets under the strongly bounded Tur-
ing reducibilities r = cl (computable Lipschitz reducibility) and r = ibT (iden-
tity bounded Turing reducibility) which are deﬁned in terms of Turing function-
als where the use function is bounded by the identity function up to an additive
constant and the identity function, respectively. We call a c.e. r-degree a simple if
it contains a simple set and we call a nonsimple otherwise. As we show, the ibT-
degree of a c.e. set A is simple if and only if the cl-degree of A is simple, and there
are nonsimple c.e. r-degrees > 0. Moreover, we analyze the distribution of the sim-
ple and nonsimple r-degrees in the partial ordering of the c.e. r-degrees. Among
the results we obtain are the following. (i) For any c.e. r-degree a > 0, there are sim-
ple r-degrees which are below a, above a and incomparable with a. (ii) For any c.e.
r-degree a > 0, there are nonzero nonsimple c.e. r-degrees which are below a and
incomparable with a; and there is a nonsimple c.e. r-degree above a if and only if
a is not contained in the complete wtt-degree. (iii) There are inﬁnite intervals of
c.e. r-degrees entirely consisting of nonsimple c.e. r-degrees respectively simple r-
degrees. (iv) Any c.e. r-degree is the join of two nonsimple c.e. r-degrees whereas
the class of the nonzero c.e. r-degrees is not generated by the simple r-degrees
under join though any simple r-degree is the join of two lesser simple r-degrees.
Moreover, neither the class of the nonsimple c.e. r-degrees nor the class of the
simple r-degrees generates the class of c.e. r-degrees under meet.
Keywords: Computable Lipschitz reducibility, identity bounded Turing reducibil-
ity, strong reducibilities, computably enumerable degrees, computably enumer-
able sets, simple sets, Post’s Program
Mathematics Subject Classiﬁcation 2010: 03D25, 03D30
||
Klaus Ambos-Spies: Department of Mathematics and Computer Science, University of Heidel-
berg, Germany
1 This research was partially done whilst the author was a visiting fellow at the Isaac Newton
Institute for the Mathematical Sciences in the programme ‘Semantics & Syntax’ in the spring of
2012.

24
|
Klaus Ambos-Spies
1 Introduction
The notion of a simple set is among the most well known concepts in computabil-
ity theory. Simple sets were introduced in 1944 by Post in his seminal paper [15]
where he raised the question of whether there are more than two computably enu-
merable (c.e.) Turing degrees which became known as Post’s Problem. This pa-
per may be viewed as the origin of degree theory and speciﬁcally of the theory
of the c.e. (Turing) degrees which became one of the most productive areas in
computability theory (see e.g. Odifreddi [14] and Soare [16]). Post’s approach to
solve Post’s Problem - now known as Post’s Program - was a structural one. He
tried to ﬁnd a nonvacuous property P of c.e. sets such that any c.e. set with this
property is neither computable nor (Turing) complete. In order to get such a prop-
erty, Post looked at c.e. sets with “thin” (but inﬁnite) complements. In particular,
Post called a c.e. set A simple if its complement is inﬁnite but does not contain
any inﬁnite c.e. set as a subset. He showed that simple sets exist and that they
are not complete under many-one reducibility (in fact under bounded truth-table
reducibility) but that they may be complete under truth-table reducibility. So, in
order to guarantee Turing incompleteness, Post suggested some reﬁnements of
simplicity, namely hyper-simplicity and hyper-hyper-simplicity. As it turned out,
however, neither of these properties guarantees Turing-incompleteness and - in
a strict sense - Post’s Program fails. The solution of Post’s Problem was given by
Friedberg and Muchnik in 1956, by introducing the priority method. Though this
constructive approach proved to be very powerful and most of the results on the
structure of the c.e. degrees are proven by priority arguments, Post’s structural
approach and variations of Post’s Program still attracted researchers in the past.
So, by replacing thinness properties by other structural properties, several solu-
tions to Post’s Problem were given where, probably, the solution found by Harring-
ton and Soare [11] is the most satisfying one. Moreover, Post’s structural approach
proved to be very useful for the study of the c.e. degrees under the strong reducibil-
ities as many-one (m), bounded truth-table (btt) and truth-table (tt) reducibilities
(see e.g. Chapter III in Odifreddi [14]).
One may consider a generalization of Post’s Program in a diﬀerent direction:
instead of replacing thinness properties by more general structural properties one
may look at degrees in general and not only at the complete degree. For this sake,
given a property P of c.e. sets implying noncomputability, let
Pρ(degρ(A)) ⇔there is a set P with property P such that P =ρ A
be the corresponding degree property (for a given reducibility ≤ρ). Then, in or-
der to solve Post’s Problem for ρ-reducibility, i.e., to show that there are at least

On the Strongly Bounded Turing Degrees of Simple Sets
|
25
two nonzero c.e. ρ-degrees, it suﬃces to show that there are noncomputable
c.e. sets A and B such that the ρ-degree of A contains a set with property P (i.e.,
Pρ(degρ(A)) holds) and the ρ-degree of B does not contain a c.e. set with property
P (i.e., Pρ(degρ(B)) fails).
This Generalized Post’s Program is more technical but also more powerful than
Post’s original program. Namely, the simple set property S does not suﬃce to
solve Post’s Problem for tt-reducibility in the sense of Post’s Program (since, as
mentioned before, Post has shown that there are tt-complete simple sets), but
it suﬃces in the sense of Generalized Post’s Program since - by Post - there is
a simple set A (hence Stt(degtt(A)) holds) while - as shown by Jockusch [12] -
there is a noncomputable c.e. set B which is not tt-equivalent to any simple set
(hence Stt(degtt(B)) fails). But, even in the sense of Generalized Post’s Program,
simplicity fails to solve Post’s Problems for Turing reducibility, since Dekker has
shown in 1954 that any nonzero c.e. Turing degree contains a (hyper-)simple set.
The stronger property HHS of hyper-hyper-simplicity, however, solves the origi-
nal Post’s Problem for Turing reducibility in the sense of Generalized Post’s Pro-
gram since Martin has shown that a c.e. Turing degree contains an hh-simple set
if and only if the degree is high. So there are noncomputable c.e. sets A and B
such that HHST(degT(A)) holds while HHST(degT(B)) fails. (For deﬁnitions and
references see Chapter III in Odifreddi [14].)
The above described role played by simple sets in the study of the degrees of
c.e. sets led us to look at the degrees of simple sets under the strongly bounded
Turing reducibilities. These reducibilities - computable Lipschitz reducibility (cl-
reducibility for short) and identity bounded Turing reducibility (ibT-reducibility
for short) are deﬁned in terms of Turing functionals where the use function is
bounded by the identity function up to an additive constant and the identity
function, respectively. They were introduced only fairly recently by Downey,
Hirschfeldt and Laforte [8] and Soare [17], respectively. Computable Lipschitz
reducibility is of particular interest in the theory of algorithmic randomness since
it does not only capture relative computability but also measures the relative de-
gree of randomness in the sense of Kolmogorov complexity. We refer the reader
to the recent monograph of Downey and Hirschfeldt [9] and to Ambos-Spies et al.
[3] for more motivation and details.
The strongly bounded Turing reducibilities have some interesting structural
properties which distinguish them from the other computable reducibilities. So
there are no complete sets under these reducibilities (Downey, Hirschfeldt and
LaForte [8]); in fact, there are so-called r-maximal pairs of c.e. sets, i.e., c.e. sets
A and B such that there is no c.e. set C such that A ≤r C and B ≤r C for r = ibT, cl
(Barmpalias [5] and Fan and Lu [10]; see [3] for more on maximal pairs). (By the

26
|
Klaus Ambos-Spies
former, Post’s Program does not make sense in the context of these reducibilities,
but one may consider Generalized Post’s Program here.)
We start our investigation in the degrees of simple sets under the strongly
bounded Turing reducibilities by showing that a set A is ibT-equivalent to a sim-
ple set if and only if it is cl-equivalent to a simple set, and we show that there
are noncomputable c.e. sets which are not r-equivalent to any simple set (where
r = ibT, cl throughout this paper).
We then analyze the distribution of the classes Sr and Sr of the c.e. r-degrees
containing respectively not containing simple sets in the partial ordering (Rr, ≤)
of the c.e. r-degrees. While the class Sm of the simple many-one degrees is a proper
ideal in the partial ordering (Rm, ≤) of the c.e. m-degrees, it turns out that the class
Sr of the simple r-degrees is quite scattered in the partial ordering (Rr, ≤). For in-
stance, for any nonzero c.e. r-degree a, there are simple and nonzero nonsimple
r-degrees below a, there are simple and nonsimple r-degrees incomparable with
a, and - unless a is the r-degree of a wtt-complete set - there are simple and non-
simple r-degrees above a. For wtt-complete A we show that degr(A) is simple. So,
in contrast to the situation for the m-degrees where the class of the simple degrees
is an ideal, here the simple degrees are not closed downwards and a simple degree
can be found above any c.e. degree. Moreover, we show that there are inﬁnite inter-
vals in (Rr, ≤) consisting only of simple degrees respectively nonsimple degrees
and we discuss the question whether the classes Sr and Sr are closed under join
and meet. Finally, we indicate that - in some sense - there are more nonsimple de-
grees than simple degrees. Namely while the class Sr of the nonsimple r-degrees
generates the class Rr of all c.e. r-degrees under join (but not under meet), the
class Sr of the simple r-degrees generates Rr neither under join nor under meet.
The outline of the paper is as follows. In Sections 2 and 3 we introduce the facts
on the strongly bounded Turing reducibilities and simple sets, respectively, to be
used in the following. Then, after proving the coincidence theorem for simple ibT-
and cl-degrees (Section 4), we present our results on nonsimple r-degrees where
we start with the basic construction of a nonzero nonsimple r-degree (Section 5)
and then extend this construction in order to get the stronger positive results on Sr
(Sections 6 and 7). We then turn to existence results for simple sets. First we show
that there are simple sets above and below any noncomputable c.e. set (Section 8).
By reﬁning these results we obtain more insight in the distribution of the simple r-
degrees among the c.e. r-degrees and can show that any noncomputable c.e. set is
equivalent to a simple set under linearly bounded Turing reducibility (Section 9).
We then show that wtt-complete sets have simple r-degrees (Section 10) and look
at splittings into simple r-degrees (Section 11). Finally, in Section 12, we pose some
open problems. There we also propose a further generalization of Post’s Program
which allows a solution of Post’s Problem for wtt-reducibility in terms of simple

On the Strongly Bounded Turing Degrees of Simple Sets
|
27
sets. Whether the simple sets also give a solution of the original Post’s Problem
for Turing reducibility along these lines is left open.
2 The strongly bounded Turing reducibilities
We start with some basic deﬁnitions and notation on the reducibilities we con-
sider here. For more details see e.g. Ambos-Spies et al. [3] or Ambos-Spies [2].
Let {Φe}e≥0 be a standard enumeration of the Turing functionals obtained by
goedelization of the oracle Turing machines, and let φe be the use function² of
Φe. Then a set A is Turing reducible to a set B, A ≤T B, if A = ΦB
e for some e ≥0.
For any function f, we say that A is f-bounded Turing reducible to B (A ≤f-T B) if
A is Turing reducible to B via a reduction where the use function is bounded by f,
i.e., if there is a number e such that A = ΦB
e and φB
e (x) ≤f(x) for all x ≥0. This
leads to the following reducibility notions.
1. A is identity-bounded-Turing (ibT-) reducible to B (A ≤ibT B) if A is f-bounded
Turing reducible to B for the identity function f(x) = x.
2. A is computable Lipschitz (cl-) reducible to B (A ≤cl B) if there is a number k ≥
0 such that A is f-bounded Turing reducible to B for f(x) = x + k. Moreover,
for k ≥0, A is (i + k)bT-reducible to B (A ≤(i+k)bT B) if A is f-bounded Turing
reducible to B for f(x) = x + k. (So A is ibT-reducible to B iﬀA is (i + 0)bT-
reducible to B, and A is cl-reducible to B iﬀA is (i + k)bT-reducible to B for
some k ≥0.)
3. A is linearly bounded Turing (lbT-) reducible to B (A ≤lbT B) if A is f-bounded
Turing reducible to B for a linearly bounded function f, i.e., for a function f
satisfying f(x) ≤k0x + k1 for some numbers k0, k1 ≥0 and all numbers
x ≥0.
4. A is weak-truth-table (wtt-) reducible or bounded-Turing (bT-) reducible to B
(A ≤wtt B) if A is f-bounded Turing reducible to B for some computable func-
tion f.
2 Warning: Here we work with a slightly nonstandard deﬁnition of the use. While most commonly
the use function gives strict upper bounds on the oracle queries, here we consider nonstrict bounds.
I.e., we let φX
e (x) ↑if ΦX
e (x) is undeﬁned and we let φX
e (x) be the greatest oracle query in the
computation of ΦX
e (x) if ΦX
e (x) is deﬁned (where we let φX
e (x) = 0 if no queries are asked).

28
|
Klaus Ambos-Spies
In the following we refer to ibT and cl as the strongly bounded Turing reducibilities.
Moreover we use the following convention.
Convention. Since we will obtain many results for both of the strongly bounded
reducibilities, ibT-reducibility and cl-reducibility, simultaneously, in order to sim-
plify notation, r-reducibility will stand for both ibT-reducibility and cl-reducibility in
the following. Similarly, if we simultaneously refer to ibT, cl and wtt then we shortly
write r′, and if we refer to ibT, cl, wtt and T then we write r′′. ρ will stand for any
reducibility.
We call a Turing functional Φe an f-bounded Turing functional if φX
e (x) ≤f(x)
for all oracle sets X and inputs x such that ΦX
e (x) is deﬁned. ibT-, cl-, lbT- and wtt-
functionals are deﬁned correspondingly. Note that, for any computable function f,
A ≤f-T B if and only if there is an f-bounded Turing functional Φ such that A ≤T B
via Φ, and similarly for ibT, cl, lbT and wtt. (Namely, if A ≤f-T B via Φe then A is
f-T-reducible to B via the f-bounded Turing functional Ψe where Ψ X
e (x) = ΦX
e (x)
if in the latter computation no oracle query exceeds f(x) and Ψ X
e (x) is undeﬁned
otherwise.) Moreover, there are computable enumerations of the corresponding
functionals (where in case of the wtt-functionals we have to include the Turing
functionals bounded by partial computable functions). In the following we let
{ ˆΦe}e≥0 and { ˜Φe}e≥0 be computable enumerations of the ibT- and cl-functionals,
respectively, and let ˆφe and ˜φe be the corresponding use functions, where the cl-
functionals ˜Φe are chosen so that ˜φX
e (x) ≤x + e if ˜ΦX
e (x) is deﬁned. Finally we let
{φe}e≥0 and {We}e≥0 be standard enumerations of the unary partial computable
functions and c.e. sets, respectively, where We = dom(φe). We use computable
approximations of the functionals and the corresponding use functions which are
denoted by an additional index s giving the stage of the approximation. So, for in-
stance, ΦX
e,s(x) is the result of computing ΦX
e (x) for s steps and φX
e,s(x) is the corre-
sponding use. We assume that whenever ΦX
e,s(x) is deﬁned then e, x, φX
e,s(x) < s.
This convention applies to ibT- and cl-functionals, partial computable functions
and c.e. sets correspondingly.
The ρ-degree of a set A is denoted by degρ(A), and (Rρ, ≤) denotes the partial
ordering of the c.e. ρ-degrees, i.e., the ρ-degrees of c.e. sets. Lower case boldface
letters denote c.e. ρ-degrees. 0 denotes the ρ-degree of the computable sets, and
R+
ρ = Rρ \ {0} denotes the class of the c.e. ρ-degrees of noncomputable sets. For
c.e. ρ-degrees a and b, a ∨b denotes the join (least upper bound) of a and b in
Rρ (if it exists) and a ∧b denotes the meet (greatest lower bound) of a and b in
Rρ (if it exists). In the following all sets and degrees are computably enumerable
(unless explicitely stated otherwise).
Note that, for any sets A and B,
A ≤ibT B ⇒A ≤cl B ⇒A ≤lbT B ⇒A ≤wtt B ⇒A ≤T B
(1)

On the Strongly Bounded Turing Degrees of Simple Sets
|
29
hence
degibT(A) ⊆degcl(A) ⊆deglbT(A) ⊆degwtt(A) ⊆degT(A).
(2)
The structures of the c.e. wtt- and T-degrees have been extensively studied in the
literature (see e.g. Soare [16]) while the strongly bounded Turing degrees have
been studied only more recently (see e.g. the recent monograph by Downey and
Hirschfeldt [9] or the recent papers [2] and [3]). While the partial orderings of
the c.e. wtt- and T-degrees are upper semi-lattices (but no lower semi-lattices)
with least and greatest elements (namely the degrees of the computable sets
and the complete sets, respectively), the partial orderings of the c.e. ibT- and cl-
degrees are neither upper semi-lattices nor lower semi-lattices (Downey and
Hirschfeldt [9]) and do not possess greatest - in fact no maximal - elements
(Downey, Hirschfeldt and LaForte [8], Barmpalias [5]). Also, while the partial
orderings of the c.e. wtt- and T-degrees are dense, the partial orderings of the c.e.
ibT- and cl-degrees are not dense (Barmpalias and Lewis [6], Day [7]).
It seems that the partial ordering of the c.e. lbT-degrees has not been studied
in the literature. One can easily show, however, that it shares the most basic prop-
erties with the partial ordering of the c.e. wtt-degrees: It is a dense and distributive
upper semi-lattice with least and greatest elements but not a lower semi-lattice.
We close with some simple but useful concepts and facts which will be applied
in the following quite frequently. They are taken from [2] and [3].
A (computable) shift f is a strictly increasing (computable) function f : ω →
ω. A shift f is nontrivial if f(x) > x for some (hence for almost all) x, and f is
unbounded if, for any number k, there is a number x such that f(x) −x > k. For a
set A and a computable shift f, the f-shift of A is deﬁned by Af = {f(x) : x ∈A}.
Lemma 1 (Computable-Shift Lemma ([2], [3])). Let f be a computable shift and let
A be a noncomputable c.e. set.
(i)
Af =wtt A.
(ii) Af ≤ibT A. Moreover, if f is unbounded then A ̸≤cl Af (whence Af <ibT A and
Af <cl A).
(iii) If f is unbounded then, for any c.e. set B such that Af ∩B = ∅and A ≤cl Af ∪B,
it holds that A ≤cl B.
Lemma 2 (Splitting Lemma (see e.g. [2], [3])). Let A0, . . . , An (n ≥1) be pairwise
disjoint c.e. sets. Then, for r′′ ∈{ibT, cl, wtt, T},
degr′′(A0 ∪· · · ∪Am) = degr′′(A0) ∨· · · ∨degr′′(Am).
Finally, we will use the following simple fact on c.e. wtt-degrees.

30
|
Klaus Ambos-Spies
Proposition 3. For any c.e. set A and any inﬁnite computable set R there is a c.e.
set ˆA such that A =wtt ˆA and ˆA ⊆R.
Proof. The computable function g enumerating R in increasing order is a com-
putable shift. So, since Ag ⊆R, the claim follows from part (i) of the Computable-
Shift Lemma.
3 Simple sets and simple degrees
Recall that a set A is simple if A is c.e., co-inﬁnite, and A intersects all inﬁnite
c.e. sets (see Post [15]). A set A is immune if A is inﬁnite and does not contain any
inﬁnite c.e. subset. So a set is simple if it is c.e. and its complement is immune.
Moreover, since any inﬁnite c.e. set contains an inﬁnite computable set as a subset,
an inﬁnite set is immune if and only if it does not contain any inﬁnite computable
set.
Deﬁnition 4. A c.e. ρ-degree a is simple if a contains a simple set, and a is non-
simple otherwise.
The classes of the simple and nonsimple c.e. ρ-degrees are denoted by Sρ and Sρ,
respectively. Since, obviously, no computable set is simple, the ρ-degree 0 of the
computable sets is nonsimple, i.e., 0 ∈Sρ. So, in order to avoid trivialities, in
the following we will usually consider the class S
+
ρ
= Sρ \ {0} of the nonzero
nonsimple c.e. ρ-degrees in place of Sρ.
Note that, for the reducibilities introduced in Section 2, there is no completely
simple degree, i.e., no c.e. degree such that all c.e. sets in the degree are simple.
By (2) it suﬃces to show this for ρ = ibT.
Proposition 5. For any c.e. set A there is a c.e. set B such that A =ibT B and B
contains an inﬁnite computable set. In particular, any c.e. ibT-degree contains a
nonsimple c.e. set.
Proof. Fix A. If A is computable, let B = ∅. If A is noncomputable, hence inﬁnite,
then A contains an inﬁnite computable set R. Then, as one can easily check, B =
A \ R has the required properties.
The following are well known facts on simple sets to be used below. For the sake
of completeness we include the short proofs.

On the Strongly Bounded Turing Degrees of Simple Sets
|
31
Proposition 6. Let A be a simple set and let B be an inﬁnite c.e. set. Then A ∩B is
inﬁnite.
Proof. For a contradiction assume that A∩B is ﬁnite. Then B\(A∩B) is an inﬁnite
c.e. set which does not intersect A. So A is not simple.
Lemma 7 (Simple Set Lemma). Let A be a simple set, let B be an inﬁnite c.e. set,
and let k be any number ≥0. There are inﬁnitely many numbers x ≥k such that
x ∈B and the interval [x −k, x + k] is contained in A.
Proof. The proof is by induction on k. For k = 0 the claim is immediate by Propo-
sition 6. So ﬁx k > 0 and, by inductive hypothesis, assume that there are inﬁnitely
many numbers x ∈B such that the interval [x −(k −1), x + (k −1)] is contained
in A. Then, for
B(k,0) = {x −k : x ∈B & [x −(k −1), x + (k −1)] ⊆A},
B(k,0) is an inﬁnite c.e. set. Hence, by Proposition 6, A∩B(k,0) is inﬁnite. By deﬁni-
tion of B(k,0) this implies that there are inﬁnitely many numbers x ∈B such that
the interval [x −k, x + (k −1)] is contained in A. So, for
B(k,1) = {x + k : x ∈B & [x −k, x + (k −1)] ⊆A},
B(k,1) is an inﬁnite c.e. set. Hence, by Proposition 6, A ∩B(k,1) is inﬁnite. But, by
choice of B(k,1), this implies that there are inﬁnitely many numbers x ∈B such
that [x −k, x + k] is contained in A.
4 Coincidence of the simple ibT- and cl-degrees
Before we establish the existence of nonsimple c.e. r-degrees a > 0 for the strongly
bounded Turing reducibilities r = ibT, cl, we ﬁrst show that, for any c.e. set A,
degibT(A) is simple if and only if degcl(A) is simple.
Theorem 8 (Coincidence Theorem). For any c.e. set A, degibT(A) is simple if and
only if degcl(A) is simple.
For the proof of the nontrivial implication we will use the following lemma.
Lemma 9 (Representation Lemma). Let A and B be noncomputable c.e. sets such
that A ≤(i+k)bT B and B ≤(i+k)bT A, and let {As}s≥0 and {Bs}s≥0 be computable
enumerations of A and B, respectively. There are one-to-one computable functions

32
|
Klaus Ambos-Spies
a and b such that, for ˆA = range(a) and ˆB = range(b) and for s ≥0, the following
hold.
ˆA ⊆A & ˆB ⊆B
(3)
ˆA =ibT A & ˆB =ibT B
(4)
a(s) ∈A \ As & b(s) ∈B \ Bs
(5)
|b(s) −a(s)| ≤k
(6)
Lemma 9 is a symmetric version of a similar representation lemma in [2] where it is
shown that any (i+k)bT-reduction between c.e. sets is witnessed by a k-permitting
argument. Since the proofs are quite similar we only sketch the proof and refer to
[2] for more details.
Proof (sketch).. Fix (i + k)bT-functionals Φ and Ψ such that B = ΦA and A = Ψ B.
Deﬁne the length (of agreement) function l by
l(s) = max{x ≤s : ∀y < x (Bs(y) = ΦAs
s (y) & As(y) = Ψ Bs
s (y))}.
Then lims→ω l(s) = ω whence there are inﬁnitely many expansionary stages s, i.e.,
stages s such that l(t) < l(s) for all t < s. Call an expansionary stage s critical if
there is a number x < l(s) such that x ∈A \ As, and say that criticalness of s
is witnessed by a stage t > s if As ↾l(s) ̸= At ↾l(s). Note that criticalness of
any critical stage s is witnessed by some t > s, and, for any witness t, all stages
t′ ≥t are witnesses too. Moreover, by noncomputability of A, there are inﬁnitely
many critical expansionary stages. So, since the set of all pairs (s, t) such that s
is critical and criticalness of s is witnessed by t is computable, we can deﬁne a
computable ascending sequence of expansionary stages s0 < s1 < s2 < . . . such
that sn is critical and sn+1 witnesses criticalness of sn.
Now let
a(n) = µ x (x ∈Asn+1 \ Asn) and b(n) = µ x (x ∈Bsn+1 \ Bsn).
Note that, by choice of the stages sn and sn+1, a(n) exists and a(n) < l(sn) <
l(sn+1). So
Asn(a(n)) = Ψ Bsn
sn (a(n)) = 0 and Asn+1(a(n)) = Ψ
Bsn+1
sn+1 (a(n)) = 1.
Since Ψ is an (i + k)bT-functional it follows that
Bsn ↾a(n) + k + 1 ̸= Bsn+1 ↾a(n) + k + 1.

On the Strongly Bounded Turing Degrees of Simple Sets
|
33
So b(n) exists too and b(n) ≤a(n) + k. Moreover, the dual inequality a(n) ≤
b(n) + k follows for b(n) < l(sn) by a symmetric argument and is for b(n) ≥l(sn)
obvious.
The above observations easily imply that the functions a and b are well de-
ﬁned, computable and one-to-one, and that the conditions (3) - (6) are satisﬁed.
Proof of Theorem 8. By (2) it suﬃces to show that, for any c.e. set A such that
degcl(A) is simple, degibT(A) is simple too. So ﬁx c.e. sets A and B such that
A =cl B and B is simple. It suﬃces to give a simple set C such that A =ibT C.
By A =cl B we may ﬁx k ≥0 such that A ≤(i+k)bT B ≤(i+k)bT A. So, given
any computable enumerations {As}s≥0 and {Bs}s≥0 of A and B, respectively, by
the Representation Lemma we may ﬁx computable one-to-one functions a and b
such that, for ˆA = range(a) and ˆB = range(b), (3) to (6) hold.
Then C is given by the following computable enumeration.
s = 0. C0 = {a(0)}.
s > 0. Cs = Cs−1 ∪{a(s)} ∪{x : a(s) < x & [x −k, x + k] ⊆Bs}.
For a proof of C =ibT A, by (4) it suﬃces to show that C =ibT ˆA. The latter is done
by showing that, for s > 0,
a(s) = µx(x ∈Cs \ Cs−1).
(7)
Note that, by a(s) = µx(x ∈ˆAs \ ˆAs−1) for ˆAs = {a(0), . . . , a(s)}, this implies
that C ≤ibT ˆA and ˆA ≤ibT C by permitting. Now, for a proof of (7), observe that,
by deﬁnition of C, a(s) ∈Cs and no new number < a(s) enters C at stage s. So
it suﬃces to show that, for s > 0, a(s) /∈Cs−1. For a contradiction, pick s > 0
minimal such that a(s) ∈Cs−1 and ﬁx t < s minimal such that a(s) ∈Ct. Then,
by deﬁnition of Ct, a(s) is an element of the third part of Ct, hence [a(s)−k, a(s)+
k] ⊆Bt. It follows with (6) that b(s) ∈Bt. But, by t < s, this contradicts (5).
Finally, for a proof that C is simple, note that, by C =ibT A and by noncom-
putability of A, C is noncomputable hence co-inﬁnite. So, given an inﬁnite c.e. set
V, it suﬃces to show that C ∩V ̸= ∅. In order to do so, note that by the Simple Set
Lemma there are inﬁnitely many numbers x ∈V such that the interval [x−k, x+k]
is contained in the simple set B. So, given any computable enumeration {Vs}s≥0
of V we can eﬀectively enumerate numbers x0 < x1 < x2 < . . . and corresponding
stages s0 < s1 < s2 < . . . such that xn ∈Vsn and [xn −k, xn + k] ⊆Bsn. By non-
computability of ˆA this implies that there are some s and n such that s > sn and
a(s) < xn. So, by deﬁnition of Cs, xn ∈Cs hence C ∩V ̸= ∅.

34
|
Klaus Ambos-Spies
5 A nonzero nonsimple cl-degree
We now show that, for r = ibT, cl, there is a nonsimple c.e. r-degree a > 0. By the
Coincidence Theorem, it suﬃces to show this for r = ibT.
Theorem 10. There is a noncomputable c.e. set A such that degibT(A) is not simple.
Proof. By a ﬁnite-injury argument we enumerate a noncomputable c.e. set A
which is not ibT-equivalent to any simple set. As usual, we let As denote the ﬁnite
part of A enumerated by the end of stage s (A0 = ∅).
In order to make A noncomputable it suﬃces to meet the requirements
ℜ2e : A ̸= φe
(e ≥0)
and, in order to ensure that A is not ibT-equivalent to any simple set, it suﬃces to
meet the requirements
ℜ2e+1 : [A = ˆΦ
We0
e1
& We0 = ˆΦA
e2] ⇒We0 is not simple
for e = ⟨e0, e1, e2⟩≥0.
Before we give the formal construction of the set A, we describe the strategies
for meeting the requirements ℜn. Fix uniformly computable inﬁnite and pairwise
disjoint sets Rn (n ≥0), say Rn = ω[n] = {⟨n, x⟩: x ≥0}, and reserve Rn for the
strategy for meeting requirement ℜn.
The strategy for meeting a noncomputability requirement ℜ2e is standard. We
wait for a stage s > 2e such that there is a number x ∈R2e satisfying φe,s(x) = 0.
Then, for the least such stage s and the least corresponding number x, x is put
into A at stage s + 1 thereby ensuring A(x) ̸= φe(x). Note that if there are no such
stage s and number x then φe(x) ̸= 0 for all x ∈R2e, and no number from R2e is
put into A. So ℜ2e is met in this case too.
The strategy for meeting a nonsimplicity requirement ℜ2e+1 (e = ⟨e0, e1, e2⟩)
is a diagonalization strategy aiming at destroying the premise of the requirement.
The strategy will fail to achieve this goal only if R2e+1 ∩We0 is ﬁnite hence (by
Proposition 6) We0 is not simple. So requirement ℜ2e+1 is met no matter whether
or not the strategy becomes active. The strategy is as follows.
Wait for a stage s > 2e +1 such that for some number x ∈R2e+1 the following
hold.
(S1) x ∈We0,s
(S2) x /∈As
(S3) As(x) = ˆΦ
We0,s
e1,s (x)
(S4) We0,s ↾x = ˆΦAs
e2,s ↾x

On the Strongly Bounded Turing Degrees of Simple Sets
|
35
Then enumerate x into A at stage s + 1 and restrain all lesser numbers from A
thereby guaranteeing that A ↾x = As ↾x.
To show that this action guarantees that the premise of requirement ℜ2e+1
fails, ﬁrst assume that ˆΦ
We0,s
e1,s (x) = ˆΦ
We0
e1 (x). Then, by (S2) and (S3),
A(x) = As+1(x) ̸= As(x) = ˆΦ
We0,s
e1,s (x) = ˆΦ
We0
e1 (x),
hence A ̸= ˆΦ
We0
e1 . On the other hand, if ˆΦ
We0,s
e1,s (x) ̸= ˆΦ
We0
e1 (x) (where, by (S3),
ˆΦ
We0,s
e1,s (x) ↓) then - since ˆΦe1 is an ibT-functional and since, by (S1), x has entered
We0 by stage s already - a number x′ < x has to enter We0 after stage s, while, by
the restraint imposed on A at stage s + 1, no number < x enters A after stage s. It
follows with (S4) that
We0(x′) ̸= We0,s(x′) = ˆΦAs
e2,s(x′) = ˆΦA
e2(x′),
hence We0 ̸= ˆΦA
e2. So in either case the premise of ℜ2e+1 is not correct.
For a proof that the above strategy guarantees that requirement ℜ2e+1 is met,
w.l.o.g. assume that the premise of ℜ2e+1 holds and the strategy for meeting ℜ2e+1
does not become active, hence R2e+1 ∩A = ∅. Then, for any x ∈R2e+1, the condi-
tions (S2), (S3) and (S4) hold for all suﬃciently large stages s. So, for any x ∈R2e+1,
condition (S1) must fail at all suﬃciently large stages s, hence x /∈We0. It follows
that We0 ∩R2e+1 = ∅, hence We0 is not simple. So requirement ℜ2e+1 is met.
Note that the above strategies are ﬁnitary. (More precisely, the ℜ2e-strategy is
positive and acts at most once while the ℜ2e+1-strategy is positive and negative
and acts at most once unless its restraint is injured.) So the strategies can be eas-
ily combined in a standard ﬁnite injury fashion in the actual construction of A as
follows where we attach the restraint function r(n, s) to requirement ℜn denoting
the restraint imposed by ℜn at the end of stage s. Since the noncomputability re-
quirements are purely positive, r(2e, s) = 0 for e, s ≥0; and r(2e + 1, 0) = 0 for
e ≥0.
Stage s + 1. Requirement ℜ2e requires attention at stage s + 1 if s + 1 > 2e,
As ∩R2e = ∅, and there is a number x ∈R2e such that x > max{r(n′) : n′ < 2e}
and φe,s(x) = 0; and, for the least such x (if any), ℜ2e requires attention via
x. Requirement ℜ2e+1 (e = ⟨e0, e1, e2⟩) requires attention at stage s + 1 if
s + 1 > 2e + 1, r(2e + 1, s) = 0 and there is a number x ∈R2e+1 such that
(S1), (S2), (S3), (S4), and
(S5)
x > max{r(n′, s) : n′ < 2e + 1}
hold; and, for the least such x (if any), ℜ2e+1 requires attention via x.

36
|
Klaus Ambos-Spies
Fix n minimal such that ℜn requires attention and say that ℜn becomes active
at stage s + 1. (If no requirement requires attention let r(n, s + 1) = r(n, s) for
all n ≥0 and proceed to stage s + 2.) Let n = 2e + i, i ≤1.
If n = 2e and ℜ2e requires attention via x then enumerate x into A and let
r(n′, s + 1) = r(n′, s) for n′ < 2e and r(n′, s + 1) = 0 for n′ ≥2e.
If n = 2e + 1 and ℜ2e+1 requires attention via x then enumerate x into A
and let r(n′, s + 1) = r(n′, s) for n′ < 2e + 1, r(2e + 1, s + 1) = x + 1, and
r(n′, s + 1) = 0 for n′ > 2e + 1.
To show that the construction is correct, it suﬃces to show that all requirements
ℜn require attention at most ﬁnitely often and are met. The proof is by induction
on n. So ﬁx n and the unique e ≥0 and i ≤1 such that n = 2e + i. By inductive
hypothesis, there is a stage s0 > n such that no requirement ℜn′ with n′ < n re-
quires attention after stage s0. So, in particular, r(n′, s) = r(n′, s0) for n′ < n and
s ≥s0, and we may ﬁx x0 ∈Rn minimal such that r(n′, s) < x0 for n′ < n and
s ≥s0. Moreover, ℜn becomes active whenever it requires attention after stage s0.
Now ﬁrst assume that n = 2e. Then ℜ2e becomes active at most once since
if ℜ2e becomes active at stage t + 1 then a number x ∈R2e is put into A at stage
t + 1 whence the clause As ∩R2e = ∅in the deﬁnition of ℜ2e requiring attention
at stage s + 1 fails for all s > t. So ℜ2e requires attention at most once after stage
s0.
It remains to show that ℜ2e is met. For a contradiction assume that ℜ2e is not
met. Then, obviously, ℜ2e never becomes active, hence A ∩R2e = ∅. Moreover,
since ℜ2e is not met, A(x) = φe(x) = 0 for all x ∈R2e. It follows that, for all
suﬃciently large s, ℜ2e requires attention via x0 at stage s+1. But this contradicts
the fact that ℜ2e requires attention only ﬁnitely often.
Finally assume that n = 2e + 1. If ℜ2e+1 becomes active at a stage s + 1 > s0
then r(2e + 1, t) = r(2e + 1, s + 1) > 0 for all t > s, hence ℜ2e+1 does not require
attention after stage s + 1. So ℜ2e+1 requires attention at most once after stage s0.
It remains to show that ℜ2e+1 is met. Since ℜ2e+1 requires attention only
ﬁnitely often, we may ﬁx x1 ≥x0 minimal such that there is no x ∈R2e+1 ∩A
with x ≥x1. Now, for a contradiction, assume that ℜ2e+1 is not met, i.e., that the
premise of ℜ2e+1 holds and We0 is simple. Note that, by the observations on the
ℜ2e+1-strategy preceding the construction, the premise of ℜ2e+1 fails if there is
a stage s + 1 at which ℜ2e+1 becomes active provided that ℜ2e+1 is not injured
later. So, by assumption and by choice of s0, r(2e + 1, s) = 0 for s ≥s0 and ℜ2e+1
does not require attention after stage s0. But the latter can be refuted as follows.
It suﬃces to show that there is a number x > x0 in R2e+1 and a stage s ≥s0 such
that (S1) - (S4) hold. By simplicity of We0, ﬁx x ∈We0 ∩(R2e+1 ∩{x : x ≥x1}) and

On the Strongly Bounded Turing Degrees of Simple Sets
|
37
s1 ≥s0 such that x ∈We0,s1. Then (S1) and (S2) hold at all stages s ≥s1; and (S3)
and (S4) hold at all suﬃciently large stages s by the assumption that the premise
of ℜ2e+1 is satisﬁed.
By the Coincidence Theorem, Theorem 10 immediately carries over to cl-re-
ducibility.
Corollary 11. There is a noncomputable c.e. set A such that degcl(A) is not simple.
For an extension of Corollary 11, which we will prove in the next section, we have
to use a direct argument for constructing a nonsimple cl-degree and cannot refer
to the Coincidence Theorem. So, in the remainder of this section, we show how the
proof of Theorem 10 can be adjusted in order to obtain a direct proof of Corollary
11.
Direct proof of Corollary 11. In order to make degcl(A) nonsimple we have to re-
place the nonsimplicity requirements ℜ2e+1 in the proof of Theorem 10 by the
stronger requirements
ℜ2e+1 : [A = ˜Φ
We0
e1
& We0 = ˜ΦA
e2] ⇒We0 is not simple
(for e = ⟨e0, e1, e2⟩≥0) where the ibT-functionals are replaced by cl-functionals
(while the noncomputability requirements ℜ2e are unchanged). Here we assume
that the coding function is chosen so that e0, e1, e2 ≤⟨e0, e1, e2⟩. So, by choice
of the enumeration of the cl-functionals, the use of the cl-functionals ˜Φ
We0
e1 (x) and
˜ΦA
e2(x) is bounded by x + e.
The strategy for meeting the thus modiﬁed nonsimplicity requirements for cl-
functionals is somewhat more involved than the previously described strategy for
meeting the original requirements for ibT-functionals.
Fix the computable partition of ω into ﬁnite intervals In = [yn, yn+1) (y0 = 0)
where, for e, m ≥0, the interval I⟨2e,m⟩has length 1 while the interval I⟨2e+1,m⟩
has length 2e + 1, i.e., y⟨2e+1,m⟩+1 = y⟨2e+1,m⟩+ 2e + 1, and let x⟨2e+1,m⟩=
y⟨2e+1,m⟩+ e be the middle element of the interval I⟨2e+1,m⟩. Then the uniformly
computable inﬁnite and pairwise disjoint sets Rn reserved for the requirements
ℜn, n ≥0, are deﬁned by Rn = 
m≥0 I⟨n,m⟩.
The revised strategy for meeting ℜ2e+1 is as follows. Wait for a stage s > 2e+1
such that for some m ≥0 the following hold.
(S′
1)I⟨2e+1,m⟩⊆We0,s
(S′
2)x⟨2e+1,m⟩/∈As
(S′
3)As(x⟨2e+1,m⟩) = ˜Φ
We0,s
e1,s (x⟨2e+1,m⟩)
(S′
4)We0,s ↾y⟨2e+1,m⟩= ˜ΦAs
e2,s ↾y⟨2e+1,m⟩

38
|
Klaus Ambos-Spies
Then, for the least such s and for the least corresponding m, put x⟨2e+1,m⟩into
As+1 and restrain all numbers < x⟨2e+1,m⟩from A.
To show that this action guarantees that the premise of requirement ℜ2e+1
fails, ﬁrst assume that ˜Φ
We0,s
e1,s (x⟨2e+1,m⟩) = ˜Φ
We0
e1 (x⟨2e+1,m⟩). Then, by (S′
2) and
(S′
3),
A(x⟨2e+1,m⟩) ̸= As(x⟨2e+1,m⟩) = ˜Φ
We0,s
e1,s (x⟨2e+1,m⟩) = ˜Φ
We0
e1 (x⟨2e+1,m⟩),
hence A ̸= ˜Φ
We0
e1 . So, for the remainder of the argument, we may assume that
˜Φ
We0,s
e1,s (x⟨2e+1,m⟩) ̸= ˜Φ
We0
e1 (x⟨2e+1,m⟩) where, by (S′
3), ˜Φ
We0,s
e1,s (x⟨2e+1,m⟩) ↓. Then
there must be a number z ∈We0 \ We0,s such that
z ≤˜φ
We0,s
e1,s (x⟨2e+1,m⟩) ≤x⟨2e+1,m⟩+ e < y⟨2e+1,m⟩+1.
In fact, by (S′
1), z < y⟨2e+1,m⟩. So, by (S′
4), We0(z) ̸= We0,s(z) = ˜ΦAs
e2,s(z) ↓. But,
since
˜φAs
e2,s(z) ≤z + e < y⟨2e+1,m⟩+ e = x⟨2e+1,m⟩,
it follows with A ↾x⟨2e+1,m⟩= As ↾x⟨2e+1,m⟩that ˜ΦA
e2(z) = ˜ΦAs
e2,s(z). So We0(z) ̸=
˜ΦA
e2(z), hence We0 ̸= ˜ΦA
e2.
For a proof that the above strategy guarantees that requirement ℜ2e+1 is met,
w.l.o.g. assume that the premise of ℜ2e+1 holds and the strategy for meeting ℜ2e+1
does not become active, hence R2e+1 ∩A = ∅. Then, for any m ≥0, the conditions
(S′
2), (S′
3) and (S′
4) hold for all suﬃciently large stages s. So, for any m ≥0, con-
dition (S′
1) must fail at all suﬃciently large stages s, hence I⟨2e+1,m⟩̸⊆We0, i.e.,
|I⟨2e+1,m⟩∩We0| < 2e + 1. (In the actual construction, due to the ﬁnite injuries
we can only argue that this is true for all suﬃciently large m.) Now ﬁx k maximal
such that |I⟨2e+1,m⟩∩We0| = k for inﬁnitely many m, ﬁx m0 minimal such that
|I⟨2e+1,m⟩∩We0| ≤k for all m > m0, and eﬀectively enumerate numbers mp and
stages sp (p ≥1) such that m0 < m1 < m2 < m3 < . . . and |I⟨2e+1,mp⟩∩We0,sp| = k.
Then, for
zp = µz(z ∈I⟨2e+1,mp⟩\ We0,sp),
zp /∈We0. So We0 does not intersect the inﬁnite computable set {zp : p ≥1} hence
is not simple. So ℜ2e+1 is met.
In the actual construction of A it suﬃces to adjust the deﬁnition of ℜ2e+1 re-
quiring attention and the action in case that ℜ2e+1 becomes active as follows. Now
requirement ℜ2e+1 (e = ⟨e0, e1, e2⟩) requires attention at stage s+1 if s+1 > 2e+1,
r(2e + 1, s) = 0 and there is a number m ≥0 such that (S′
1), (S′
2), (S′
3), (S′
4), and
(S′
5)
x⟨2e+1,m⟩> max{r(n′, s) : n′ < 2e + 1}
hold; and, for the least such m (if any), ℜ2e+1 requires attention via m. If ℜ2e+1
becomes active at stage s + 1 and ℜ2e+1 requires attention via m then x⟨2e+1,m⟩is

On the Strongly Bounded Turing Degrees of Simple Sets
|
39
enumerated into A at stage s+1 and the restraint of ℜ2e+1 is set to r(2e+1, s+1) =
x⟨2e+1,m⟩+ 1.
The correctness of the construction is established as in the proof of Theorem
10 using the above observations on the strategy for the modiﬁed nonsimplicity
requirements.
6 An interval of nonsimple degrees
The proof of the existence of nonzero nonsimple c.e. r-degrees (r = ibT, cl) can be
easily extended to show that there are nontrivial - in fact inﬁnite - intervals of c.e.
r-degrees containing only nonsimple r-degrees.
Theorem 12. There are c.e. sets A and B such that
A ≤ibT B,
(8)
B ̸≤T A,
(9)
and
∀C c.e.[A ≤cl C ≤cl B ⇒C is not simple]
(10)
hold.
Proof. The proof is obtained by some rather straightforward modiﬁcations of the
direct proof of Corollary 11 outlined at the end of the preceding section. So we only
give the basic ideas and leave the details to the reader.
By a ﬁnite-injury argument, we construct c.e. sets A and B with the required
properties, and we let As and Bs denote the ﬁnite parts of A and B, respectively,
enumerated by the end of stage s (A0 = B0 = ∅).
In order to satisfy (9) and (10) it suﬃces to meet the requirements
ℜ2e : B ̸= ΦA
e
(for e ≥0) and
ℜ2e+1 : [A = ˜Φ
We0
e1
& We0 = ˜ΦB
e2] ⇒We0 is not simple
(for e = ⟨e0, e1, e2⟩, e ≥0), respectively.
As in the direct proof of Corollary 11, ﬁx the computable partition of ω into
the ﬁnite intervals In = [yn, yn+1) (y0 = 0) where interval I⟨2e,m⟩has length 1 and
interval I⟨2e+1,m⟩has length 2e + 1, let x⟨2e+1,m⟩= y⟨2e+1,m⟩+ e, and reserve

40
|
Klaus Ambos-Spies
the inﬁnite computable set Rn = 
m≥0 I⟨n,m⟩for requirement ℜn. Moreover, let
Reven = 
e≥0 R2e and Rodd = 
e≥0 R2e+1.
Then (8) is guaranteed by ensuring
A ∩Ieven = ∅& A ∩Iodd = B ∩Iodd.
(11)
The strategy for meeting requirement ℜ2e is the standard Friedberg-Muchnik strat-
egy. We pick the least unused number x from the reserved intervals I⟨2e,m⟩, m ≥0,
which is not restrained by any higher priority requirement and wait for a stage s
such that ΦAs
e,s(x) = 0 (and such that no higher priority requirement wants to act).
Then, at stage s + 1, we put x into B and restrain all numbers ≤φAs
e,s(x) from A.
Note that this strategy is ﬁnitary (i.e., if injured only ﬁnitely often, then ℜ2e acts
only ﬁnitely often and the restraint r(2e, s) imposed by ℜ2e is bounded).
The strategy for meeting requirement ℜ2e+1 is essentially the strategy for
meeting the corresponding requirement in the direct proof of Corollary 11. Since
the role played by A there is now split between A and B, however, clause (S′
4) has
to be replaced here by
(S′′
4)
We0,s ↾x⟨2e+1,m⟩= ˜ΦBs
e2,s ↾x⟨2e+1,m⟩
while clauses (S′
1) - (S′
3) remain unchanged.
So now the positive part is played by A while the negative part is played by B.
Accordingly, if the strategy acts at stage s+1 via m, now x⟨2e+1,m⟩is put into A and
all numbers < x⟨2e+1,m⟩are restrained from B. In order to satisfy (11), however, we
have to treat A and B equally on Iodd. So, actually, we put x⟨2e+1,m⟩into A and B
and we restrain the numbers < x⟨2e+1,m⟩from A and B. Note that this modiﬁcation
does not interfere with the basic strategy, and we can argue as before that the
strategy succeeds.
Theorem 12 immediately implies that, for r = ibT, cl, there are c.e. r-degrees a and
b such that a < b and the interval [a, b] = {c ∈Rr : a ≤c ≤b} contains only
nonsimple r-degrees, i.e., [a, b] ⊆Sr. In fact, by the following observation we may
argue that the interval [a, b] is inﬁnite.
Lemma 13. (a) Let D, E, F be c.e. sets such that D ≤wtt E ≤wtt F and D ≤r F
(r = ibT, cl). There is a c.e. set ˆE such that D ≤ibT ˆE ≤r F and ˆE =wtt E.
(b) Let D and F be c.e. sets such that D <wtt F and D <r F (r = ibT, cl). There is
a c.e. set E such that D <r E <r F and D <wtt E <wtt F.
Proof. (a) By Proposition 5, w.l.o.g. we may assume that there is an inﬁnite com-
putable set R such that D ∩R = ∅. Moreover, by E ≤wtt F there is a computable
shift f such that E ≤f-T F hence Ef ≤ibT F. So, for the computable shift g enumer-
ating R in order, it follows with the Computable-Shift Lemma that (Ef )g =wtt E

On the Strongly Bounded Turing Degrees of Simple Sets
|
41
and (Ef )g ≤ibT F. So, by (Ef )g ⊆R ⊆D and by the Splitting Lemma, the set
ˆE = D ∪(Ef )g has the required properties.
(b) This follows from (a) by density of the partial ordering of the c.e. wtt-
degrees (see Ladner and Sasso [13]).
Corollary 14. Let r = ibT, cl. There are c.e. r-degrees a and b such that a < b, [a, b]
is inﬁnite, and c is nonsimple for all c ∈[a, b].
Proof. Let A and B be c.e. sets as in Theorem 12 and let a = degr(A) and b =
degr(B). Then [a, b] ⊆Sr. So it only remains to show that [a, b] is inﬁnite. Since
A <r B and A <wtt B it suﬃces to show that there are c.e. sets Bn, n ≥0, such
that A <r · · · <r B3 <r B2 <r B1 <r B0 =r B and A <wtt · · · <wtt B3 <wtt B2 <wtt
B1 <wtt B0. But such sets Bn are obtained by induction on n by letting B0 = B and
by letting Bn+1 be the set E given by part (b) of Lemma 13 applied to D = A and
F = Bn.
7 More existence results for nonsimple degrees
We now look at the distribution of the nonsimple c.e. r-degrees among all c.e. r-
degrees. Given a noncomputable c.e. set A, we show that (i) there is a nonzero
nonsimple c.e. r-degree which is below degr(A) and (ii) there is a nonzero non-
simple c.e. r-degree which is incomparable with degr(A). Moreover, if A is not wtt-
complete then (iii) there is a nonsimple c.e. r-degree above degr(A). (In Section
10 we will show that the assumption that A is not wtt-complete is necessary.) Here
(i) and (iii) can be obtained by combining the basic construction of a nonzero non-
simple r-degree in Section 5 with the permitting method and some coding strategy,
respectively, while (ii) can be established by combining these techniques. In the
following, however, we prove a quite powerful technical lemma which does not
only imply the above results but - by applying some results from the literature
- gives us some additional insights into the structure of Sr. So, for instance, we
show that Sr generates the class Rr of the c.e. r-degrees under join, that Sr is not
closed under meet, and that there is a pair of nonsimple r-degrees which is both
minimal and maximal.
Lemma 15. Let A and B be c.e. sets and let R be an inﬁnite computable set such
that
A ∩R = ∅
(12)

42
|
Klaus Ambos-Spies
and
B ̸≤wtt A.
(13)
There is a c.e. set C such that
C ∩R = A,
(14)
C ∩R ≤ibT B,
(15)
C is noncomputable,
(16)
and
degcl(C) is nonsimple.
(17)
Proof. By a ﬁnite injury argument we eﬀectively enumerate a c.e. set C with the
required properties. As usual we let Cs denote the ﬁnite part of C enumerated by
the end of stage s.
Fix computable enumerations {As}s≥0 and {Bs}s≥0 of A and B, respectively,
and let g be the computable one-to-one function which enumerates the com-
putable set R in order. Then, in order to ensure (14), it suﬃces to let
Cs ∩R = As
(18)
for all stages s ≥0. Condition (15) is satisﬁed by permitting. I.e., we guarantee
∀s ≥0 ∀x ∈R (x ∈Cs+1 \ Cs ⇒Bs+1 ↾x + 1 ̸= Bs ↾x + 1).
(19)
In order to satisfy (17), by the Coincidence Theorem it suﬃces to make degibT(C)
nonsimple. So conditions (16) and (17) can be satisﬁed by meeting the require-
ments
ℜ2e : C ̸= φe
for e ≥0 and
ℜ2e+1 : [C = ˆΦ
We0
e1
& We0 = ˆΦC
e2] ⇒We0 is not simple
for e ≥0 where e = ⟨e0, e1, e2⟩.
The strategies for meeting these requirements are variations of the strategies
for meeting the corresponding requirements in the proof of Theorem 10. Since, by
(18), these strategies may use only numbers from R, we reserve the numbers in
Rn = {g(⟨n, x⟩) : x ≥0} ⊂R for meeting requirement ℜn. Moreover, we attach
the restraint function r(n, s) to requirement ℜn denoting the restraint imposed
by ℜn at the end of stage s. Since the noncomputability requirements are purely
positive, r(2e, s) = 0 for all e, s ≥0.

On the Strongly Bounded Turing Degrees of Simple Sets
|
43
Then, for meeting a noncomputability requirement ℜ2e, we combine the non-
computability strategy used in the proof of Theorem 10 with B-permitting. So we
say that requirement ℜ2e requires attention at stage s + 1 if s > 2e,
(i)
R2e ∩Cs = ∅,
and there is a number x ∈R2e such that the following conditions are satisﬁed.
(ii) φe,s(x) = 0
(iii) Bs+1 ↾x + 1 ̸= Bs ↾x + 1
(iv) x > max{r(n′, s) : n′ < 2e}
Moreover, if ℜ2e requires attention at stage s + 1 then we say that ℜ2e requires
attention via x at stage s + 1 if x is the least number in R2e satisfying (ii) - (iv).
The strategy for meeting a nonsimplicity requirement ℜ2e+1 (e = ⟨e0, e1, e2⟩)
is based on the corresponding strategy in the proof of Theorem 10 - which aims
at destroying the premise of the requirement by diagonalization - but it has to be
reﬁned in two directions. First, in order to guarantee (19), the strategy has to be
combined with B-permitting. This requires that the strategy imposes some addi-
tional restraints in order to preserve the conditions needed for a diagonalization
witness x (i.e., in the notation of the proof of Theorem 10, conditions (S2) - (S4))
while waiting for permitting. The second problem which arises is the following. If
ℜ2e+1 becomes active then the restraint imposed in order to preserve the tempo-
rary disagreement created in the premise of the requirement, does not apply to
the part of C in R where, by (18), C has to agree with A. So, in order to make sure
that eventually there will be an attack which is not injured by (18), we pick the
potential diagonalization witnesses x in such a way that we can argue that if we
do inﬁnitely many attacks and all of them are injured by the A-part of C later, then
B ≤wtt A contrary to (13). (So this cannot happen, ℜ2e+1 will be ﬁnitary and ℜ2e+1
will be met.)
Formally, the strategy for meeting requirement ℜ2e+1 is as follows. First in-
ductively specify the potential diagonalization witnesses x2e+1,n: let x2e+1,0 be
the number in R2e+1 which is enumerated into We0 ﬁrst (if any) and, given x2e+1,n,
let x2e+1,n+1 be the ﬁrst number > x2e+1,n in R2e+1 which becomes enumerated
into We0 after enumeration of x2e+1,n (if any). Moreover, if x2e+1,n is deﬁned then
let s2e+1,n be the stage at which x2e+1,n is enumerated into We0. Note that, for
given e, n, s, it is decidable whether s2e+1,n = s, and x2e+1,n can be computed
from s2e+1,n. Moreover, if We0 ∩R2e+1 is inﬁnite then the sequences {x2e+1,n}n≥0
and {s2e+1,n}n≥0 are deﬁned, strictly increasing, and computable.

44
|
Klaus Ambos-Spies
Next deﬁne the length function l(2e + 1, s) by
l(2e + 1, s) = max{m :
s2e+1,m ↓≤s &
Cs ↾x2e+1,m + 1 = ˆΦ
We0,s
e1,s ↾x2e+1,m + 1 &
We0,s ↾x2e+1,m + 1 = ˆΦCs
e2,s ↾x2e+1,m + 1}.
Note that l(2e + 1, s) is computable and
sups→∞l(2e + 1, s) = ω
⇔
lims→∞l(2e + 1, s) = ω
⇔
C = ˆΦ
We0
e1
& We0 = ˆΦC
e2 & ∀m ≥0 (x2e+1,m ↓)
⇔
C = ˆΦ
We0
e1
& We0 = ˆΦC
e2 & We0 ∩R2e+1 inﬁnite
(20)
holds. (Note that the ﬁrst equivalence holds since the functionals used in the def-
inition of l are bounded.) So sups→∞l(2e + 1, s) < ω indicates that requirement
ℜ2e+1 is met since either the hypothesis of the requirement fails or the inﬁnite
computable set R2e+1 is almost completely contained in the complement of We0
(hence We0 is not simple).
Now, requirement ℜ2e+1 requires attention at stage s + 1 if s > 2e + 1 and
(a) there is a number m ≤l(2e + 1, s) such that m ∈Bs+1 \ Bs and x2e+1,m >
max{r(n′, s) : n′ < 2e + 1} or
(b) there is a number m ≤l(2e + 1, s) such that x2e+1,m > r(2e + 1, s).
If ℜ2e+1 requires attention at stage s + 1 and there is a number m as in (a) then
we say that ℜ2e+1 requires attention via (a) and m at stage s + 1 for the least such
number m; and if ℜ2e+1 requires attention at stage s + 1 and (a) does not hold
then we say that ℜ2e+1 requires attention via (b) and m at stage s + 1 for the least
number m as in (b).
Using the above deﬁnitions, the description of stage s + 1 of the construction
of C can be completed as follows (where C0 = A0 and r(n, 0) = 0 for all n ≥0).
Stage s + 1. Fix n minimal such that requirement ℜn requires attention. De-
clare that ℜn receives attention or becomes active at stage s + 1. (If no require-
ment requires attention then let Cs+1 = As+1 ∪Cs and r(n, s + 1) = r(n, s)
for all n ≥0.)
If n = 2e and ℜ2e requires attention via x then let
Cs+1 = As+1 ∪Cs ∪{x} and r(n, s + 1) = 0.

On the Strongly Bounded Turing Degrees of Simple Sets
|
45
If n = 2e +1 then distinguish the following two cases. If ℜ2e+1 requires atten-
tion via (a) and m then let
Cs+1 = As+1 ∪Cs ∪{x2e+1,m}
and
r(n, s + 1) = max(r(n, s), x2e+1,m) + 1.
If ℜ2e+1 requires attention via (b) and m then let
Cs+1 = As+1 ∪Cs and r(n, s + 1) = x2e+1,m.
In any case let r(n′, s + 1) = r(n′, s) for n′ < n and r(n′, s + 1) = 0 for n′ > n.
This completes the construction.
Note that, by eﬀectivity of the construction, C is computably enumerable.
Moreover, the construction obeys (18) and (19). Hence (14) and (15) hold. So it
only remains to show that all requirements ℜn (n ≥0) are met. We prove this
by induction on n where we simultaneously prove that requirement ℜn requires
attention at most ﬁnitely often.
Claim. For any n ≥0, requirement ℜn requires attention at most ﬁnitely often
and is met.
For a proof of the claim, ﬁx n and, by inductive hypothesis, choose a stage
s0 > n such that no requirement ℜn′, n′ < n, requires attention after stage s0,
and let rn = max{r(n′, s0) : n′ < n}. Then, for s ≥s0, r(n′, s) = r(n′, s0) hence
rn = max{r(n′, s) : n′ < n}. Moreover, ℜn receives attention whenever it requires
attention after stage s0.
Now, ﬁrst assume that n = 2e. Note that ℜ2e acts at most once. (Namely, if
ℜ2e acts at stage s + 1 then a number x from R2e is put into C at stage s + 1, hence
clause (i) in the deﬁnition of requiring attention fails for t > s). So it suﬃces to
show that ℜ2e is met. For a contradiction assume that this is not the case. Then
C = φe. Moreover, obviously, ℜ2e is met if it acts at some stage. So ℜ2e never acts,
hence C ∩R2e = ∅and ℜ2e does not require attention after stage s0. It follows
from C ∩R2e = ∅and C = φe that, for any x ∈R2e such that x > r2e, there is a
stage sx > s0 such that clauses (i), (ii) and (iv) in the deﬁnition of ℜ2e requiring
attention hold for all s ≥sx, and the least such stage sx can be computed from x.
So, since ℜ2e does not require attention after stage s0, (iii) fails for s ≥sx. Hence
Bsx ↾x + 1 = B ↾x + 1 for x ∈R2e with x > r2e. So B is computable contrary to
choice of B. This completes the proof for n = 2e.
So, ﬁnally, assume that n = 2e + 1 (e = ⟨e0, e1, e2⟩). We start with some
observations on the restraint r(2e + 1, s) imposed by ℜ2e+1. Note that, by choice

46
|
Klaus Ambos-Spies
of s0, r(2e + 1, s) is nondecreasing in s for s ≥s0, i.e.,
∀s, s′ (s0 ≤s ≤s′ ⇒r(2e + 1, s) ≤r(2e + 1, s′)).
(21)
So sups→∞r(2e + 1, s) = ω if and only if lims→∞r(2e + 1, s) = ω. Moreover,
for s ≥s0, r(2e + 1, s + 1) ̸= r(2e + 1, s) if and only if ℜ2e+1 becomes active
at stage s + 1. So, again by (21), sups→∞r(2e + 1, s) = ω if and only if ℜ2e+1
becomes active inﬁnitely often if and only if ℜ2e+1 requires attention inﬁnitely
often. Finally, by construction, if l(2e + 1, s) is unbounded then ℜ2e+1 requires
attention inﬁnitely often, and if l(2e+1, s) is bounded then r(2e+1, s) is bounded
too. So, summarizing, we obtain the following equivalences.
sups→∞r(2e + 1, s) = ω
⇔
lims→∞r(2e + 1, s) = ω
⇔
sups→∞l(2e + 1, s) = ω
⇔
ℜ2e+1 becomes active inﬁnitely often
⇔
ℜ2e+1 requires attention inﬁnitely often
(22)
Then, by (20) and (22), in order to show that ℜ2e+1 is met and requires attention
only ﬁnitely often it suﬃces to show
sup
s→∞l(2e + 1, s) < ω.
(23)
For a contradiction, assume that (23) fails. Then, by (20) and (22),
lims→∞l(2e + 1, s) = sups→∞l(2e + 1, s) = ω
and
lims→∞r(2e + 1, s) = sups→∞r(2e + 1, s) = ω.
(24)
Now, for m ≥0, let t(m) be the least stage ≥s0 such that
l(2e + 1, t(m)) ≥m,
(25)
r(2e + 1, t(m)) ≥x2e+1,m,
(26)
and
At(m) ↾x2e+1,m + 1 = A ↾x2e+1,m + 1
(27)
hold. Note that t(m) exists by (24) and t(m) is nondecreasing in m. Since B ̸≤wtt A,
it follows that there are inﬁnitely many numbers m such that B(m) ̸= Bt(m)(m).

On the Strongly Bounded Turing Degrees of Simple Sets
|
47
(Namely otherwise B(m) were computable from A ↾f(m) for the computable func-
tion f(m) = x2e+1,m + 1.) So, for the remainder of the proof, we may ﬁx m min-
imal such that x2e+1,m > r2e+1 and B(m) ̸= Bt(m)(m), and ﬁx s ≥t(m) with
m ∈Bs+1 \ Bs.
In order to get the desired contradiction we will show that ℜ2e+1 becomes
active via (a) and m at stage s + 1 and that this action destroys the premise of
ℜ2e+1.
First observe that, by s0 ≤t(m), no requirement ℜn′ with n′ < 2e + 1 enu-
merates any numbers into C after stage t(m) and, by (26) and (21), no requirement
ℜn′ with n′ > 2e + 1 enumerates a number x ≤x2e+1,m into C after stage t(m).
Moreover, by minimality of m and by t(m′) ≤t(m) for m′ < m, ℜ2e+1 does not
enumerate any number x2e+1,m′ with m′ < m into C after stage t(m). So
(C ∩R) ↾x2e+1,m = (Ct(m) ∩R) ↾x2e+1,m.
Since, by (18) and (27),
(C ∩R) ↾x2e+1,m = (Ct(m) ∩R) ↾x2e+1,m
too, it follows that
C ↾x2e+1,m = Ct(m) ↾x2e+1,m
(28)
and
Cs ↾x2e+1,m + 1 = Ct(m) ↾x2e+1,m + 1
(29)
where the latter follows from the fact that, by m ∈Bs+1 \ Bs, x2e+1,m /∈Cs. Next
observe that
We0 ↾x2e+1,m + 1 = We0,t(m) ↾x2e+1,m + 1.
(30)
Since, by (25), x2e+1,m ∈We0,t(m), for a proof of (30) it suﬃces to show that
We0 ↾x2e+1,m = We0,t(m) ↾x2e+1,m.
So, for a contradiction, assume that this is not the case. Since, by (25) and (28),
We0,t(m) ↾x2e+1,m = ˆΦ
Ct(m)
e2,t(m) ↾x2e+1,m = ˆΦC
e2 ↾x2e+1,m,
it follows that We0 ̸= ΦC
e2. But, by (20), this contradicts (24). So (30) holds.
Now, by (25), (29) and (30), l(2e + 1, s) ≥m. So ℜ2e+1 requires and re-
ceives attention via (a) and m at stage s + 1 hence x2e+1,m ∈Cs+1 \ Cs. Since,
by (25), Ct(m)(x2e+1,m) = ˆΦ
We0,t(m)
e1,t(m) (x2e+1,m) and, by (30), ˆΦ
We0,t(m)
e1,t(m) (x2e+1,m) =
ˆΦ
We0
e1 (x2e+1,m), it follows that C(x2e+1,m) ̸= ˆΦ
We0
e1 (x2e+1,m). But, by (20), this
contradicts (24).
This completes the proof of the claim and the proof of Lemma 15.

48
|
Klaus Ambos-Spies
We now turn to applications of Lemma 15. Most of these applications can be ob-
tained from the following theorem.
Theorem 16. Let A and B be c.e. sets such that A ≤r B and B ̸≤wtt A (r = ibT, cl).
There is a c.e. set C such that degcl(C) is nonsimple and A ≤r C ≤r B. In fact, C can
be chosen so that A <r C <r B and A <wtt C <wtt B.
Proof. By Proposition 5 we may assume that there is an inﬁnite computable set
R ⊆A. Then Lemma 15 applied to A, B and R yields a set C with the properties
required in the ﬁrst part of the theorem. For a proof of the second part, by Lemma
13 (b) choose c.e. sets ˆA and ˆB such that A <r′ ˆA <r′ ˆB <r′ B for r′ = r, wtt and
apply the ﬁrst part of the theorem to ˆA and ˆB in place of A and B.
Theorem 17. Let B be any noncomputable c.e. set. There is a noncomputable c.e
set C ≤r B such that degr(C) is nonsimple (r = ibT, cl).
Proof. This is a special case of Theorem 16 where A = ∅.
Theorem 18. Let A be a c.e. set such that A is not wtt-complete. There is a c.e set
C such that A ≤r C and degr(C) is nonsimple (r = ibT, cl).
Proof. By Theorem 16 it suﬃces to show that there is a wtt-complete set B such
that A ≤ibT B. We get such a set B as follows. By Proposition 5 we may assume
that there is an inﬁnite computable set R ⊆A. Then, by Proposition 3, there is a
wtt-complete set C such that C ⊆R hence A ∩C = ∅. So, for B = A ∪C, A ≤ibT B
and B is wtt-complete by the Splitting Lemma.
Corollary 19. There is a Turing complete set C such that degcl(C) is nonsimple.
Proof. Apply Theorem 18 to any Turing complete set A which is not wtt-complete.
Next, by applying Sacks’s Splitting Theorem, we improve Theorem 17 by showing
that any nonzero c.e. r-degree can be split into a pair of nonsimple c.e. r-degrees.
This implies that the class Sr of the nonsimple c.e. r-degrees generates the class
Rr of all c.e. r-degrees under join and that the class Sr is not closed under join.
Theorem 20. Let A be a noncomputable c.e. set. There are c.e. sets A0 and A1 such
that, for r = ibT, cl,
degr(A) = degr(A0) ∨degr(A1),
(31)

On the Strongly Bounded Turing Degrees of Simple Sets
|
49
(32)
and
degr(Ai) is nonsimple (i = 0, 1)
(33)
hold.
Proof. By Sacks’s Splitting Theorem split A into disjoint c.e. sets ˆA0 and ˆA1 such
that ˆA0|T ˆA1. Then, by the Splitting Lemma, degr(A) = degr(ˆA0) ∨degr(ˆA1) and
ˆA0 <r′ A for r′ = r, wtt. By the latter and by Theorem 16, there are c.e. sets Ai such
that degr(Ai) is nonsimple and ˆAi <r′ Ai <r′ A (i = 0, 1). Then, as one can easily
check, the sets A0 and A1 have the required properties.
Corollary 21. Let a be a c.e. r-degree (r = ibT, cl). There are nonsimple c.e. r-
degrees a0 and a1 such that a = a0 ∨a1. So, in particular, the class Sr of the non-
simple c.e. r-degrees generates the class Rr of the c.e. r-degrees under join.
Proof. Since 0 is nonsimple and 0 = 0 ∨0, this is immediate by Theorem 20.
Corollary 22. The class Sr of the nonsimple c.e. r-degrees is not closed under join
(r = ibT, cl).
Proof. By Corollary 21 and the existence of simple sets.
The fact, that for any noncomputable c.e. set there is an r-incomparable c.e. set
with nonsimple r-degree, can be established by applications of Sacks’s Splitting
Theorem too. We need the following lemma.
Lemma 23. Let D be a noncomputable c.e. set. There are c.e. sets A and B such
that D|clA, D|clB, A ≤ibT B and B ̸≤T A.
Proof. We ﬁrst observe that there is a c.e. set B such that D|clB. Namely, by Barm-
palias [5], there are no maximal c.e. cl-degrees. So we may ﬁx a c.e. set ˆD such
that D <cl ˆD, and, by Sacks’s Splitting Theorem, we may split ˆD into disjoint c.e.
sets ˆD0 and ˆD1 (hence degcl(ˆD0) ∨degcl(ˆD1) = degcl(ˆD)) such that D ̸≤T ˆD0 and
D ̸≤T ˆD1. Then, as one can easily check, D|cl ˆD0 or D|cl ˆD1.
Now given B such that D|clB, we obtain the required set A by another appli-
cation of the Splitting Theorem, namely by splitting B into c.e. sets B0 and B1
such that B ̸≤T Bi for i = 0, 1. Then, by the Splitting Lemma, Bi ≤ibT B and
degcl(B0)∨degcl(B1) = degcl(B). By the latter and by D|clB, D|clBi for some i ≤1.
So if we let A = Bi for such an i then A has the required properties.
A0 |wtt A1,

50
|
Klaus Ambos-Spies
Theorem 24. Let D be a noncomputable c.e. set. There is a c.e. set C such that C
and D are r-incomparable and the r-degree of C is nonsimple (r = ibT, cl).
Proof. Fix A and B as in Lemma 23 and apply Theorem 16 to A and B.
We conclude this section by giving two more applications of Theorem 16 based on
results on minimal pairs and branching degrees in the literature. (Recall that, for
any reducibility ≤ρ, a c.e. ρ-degree a is branching if a is the meet of two greater
c.e. ρ-degrees, i.e., if there are a0, a1 > a such that a = a0 ∧a1. And a pair (a0, a1)
of c.e. ρ-degrees is a minimal pair if a0, a1 > 0 and 0 = a0 ∧a1.) We ﬁrst prove the
dual of Corollary 22, namely that the class Sr of the nonsimple c.e. r-degrees is not
closed under meet (r = ibT, cl). (The dual of the stronger Corollary 21, however,
fails as shown in Section 10).
Theorem 25. There are c.e. sets A, B and C such that A is simple, degr(B) and
degr(C) are nonsimple, and degr(A) = degr(B) ∧degr(C) (r = ibT, cl). Hence the
class Sr of the nonsimple c.e. r-degrees is not closed under meet.
Proof. We need the following observation on minimal pairs in [2]: Let
B3 = {∅, {0}, {1}, {2}, {0, 1}, {0, 2}, {1, 2}, {0, 1, 2}}
be the 3-atom Boolean algebra and let A0, A1 and A2 be pairwise disjoint noncom-
putable c.e. sets such that degwtt(Ai) ∧degwtt(Aj) = 0 for all i, j ≤2 with i ̸= j.
Then, for r′ = r, wtt, the map fr′ : B3 →Rr′ given by fr′(α) = degr′(
i∈α Ai) is an
embedding of (B3, ⊆) into (Rr′, ≤) preserving joins and meets. So, in particular,
degr′(A0) = degr′(A0 ∪A1) ∧degr′(A0 ∪A2)
and
A0 <r′ A0 ∪A1, A0 ∪A2.
(34)
Now let ˆA0, ˆA1, ˆA2 be any noncomputable c.e. sets such that
degwtt(ˆAi) ∧degwtt(ˆAj) = 0
for i, j ≤2 with i ̸= j. Since any nonzero c.e. wtt-degree contains a simple set (see
e.g. Corollary 31 below), we may assume that ˆA0 is simple and, by Proposition
5, we may ﬁx a c.e. set A0 =ibT ˆA0 and an inﬁnite computable set R such that
A0 ∩R = ∅. Moreover, we may split R into two inﬁnite computable sets R1 and
R2 and, by Proposition 3 we may ﬁx c.e. sets Ai ⊆Ri such that Ai =wtt ˆAi. Then
degr(A0) is simple, the sets A0, A1, A2 are pairwise disjoint, and their wtt-degrees
are pairwise minimal pairs. Hence, by the above observation from [2], (34) holds.

On the Strongly Bounded Turing Degrees of Simple Sets
|
51
By the second part of (34) and by Theorem 16, there are c.e. sets B and C such that
degr(B) and degr(C) are nonsimple and
A0 <r′ B <r′ A0 ∪A1 and A0 <r′ C <r′ A0 ∪A2.
Since, degr(A0) is simple it follows with the ﬁrst part of (34) that the sets B and C
together with A = A0 have the required properties.
As a ﬁnal application of Theorem 16 we prove the existence of a pair (a, b) of non-
simple c.e. r-degrees such that the pair (a, b) is maximal and minimal (r = ibT, cl).
Recall that a pair (a, b) of c.e. r-degrees is maximal if there is no c.e. r-degree c
such that a ≤c and b ≤c.
Theorem 26. There is a pair (a, b) of nonsimple c.e. r-degrees which is minimal
and maximal (r = ibT, cl).
Note that, for a pair (a, b) of c.e. r-degrees which is minimal and maximal and
for any c.e. r-degree c > 0, it holds that c|a or c|b. So Theorem 26 strengthens
Theorem 24.
Also note that, for any maximal pair (a, b) and for ˆa and ˆb such that ˆa ≥a
and ˆb ≥b, the pair (ˆa, ˆb) is maximal again; and, similarly, for any minimal pair
(a, b) and for ˆa and ˆb such that 0 < ˆa ≤a and 0 < ˆb ≤b, the pair (ˆa, ˆb) is minimal
again. So, Theorem 26 is immediate by Theorem 16 and the following lemma.
Lemma 27. There are noncomputable c.e. sets A0, A1, ˆA0, ˆA1 such that the follow-
ing hold (for i = 0, 1 and r = ibT, cl).
(i) Ai ≤ibT ˆAi
(ii) ˆAi ̸≤wtt Ai
(iii) (degr(A0), degr(A1)) is a maximal pair
(iv) (degr(ˆA0), degr(ˆA1)) is a minimal pair
Proof. The proof requires a number of results on minimal and maximal pairs in
the literature.
We ﬁrst note that it suﬃces to consider the case of r = ibT. This follows from
the observation in [3] that, for a pair of c.e. sets A and B, (degibT(A), degibT(B))
is a maximal pair if and only if (degcl(A), degcl(B)) is a maximal pair, and, sim-
ilarly, the pair (degibT(A), degibT(B)) is minimal if and only if the pair (degcl(A),
degcl(B)) is minimal.
Next we use the existence of pairs of c.e. ibT-degrees which are both minimal
and maximal which has been established in [3] too. So we may ﬁx noncomputable
c.e. sets A0 and A1 such that the pair (degibT(A0), degibT(A1)) is minimal and

52
|
Klaus Ambos-Spies
maximal (hence (iii) holds). Moreover, by Proposition 5, w.l.o.g. we may assume
that, for i = 0, 1, there is an inﬁnite computable set Ri ⊆Ai.
A further result from [3] we use is the fact that minimal pairs in the c.e. ibT-
degrees and in the c.e. wtt-degrees coincide, i.e., that for a pair of c.e. sets A and
B, (degibT(A), degibT(B)) is a minimal pair if and only if (degwtt(A), degwtt(B)) is
a minimal pair. (So, in particular, the pair (degwtt(A0), degwtt(A1)) is minimal.)
This observation allows us to exploit the fact that the join of any minimal pair of
c.e. wtt-degrees is the half of a minimal pair of c.e. wtt-degrees which has been
proven in [1]. So, since
(degwtt(A0), degwtt(A1)) is a minimal pair,
(35)
we may ﬁx c.e. sets B and C such that
(degwtt(A0 ⊕A1), degwtt(B)) is a minimal pair
(36)
and
(degwtt(A0 ⊕A1 ⊕B), degwtt(C)) is a minimal pair.
(37)
Moreover, by Proposition 3, w.l.o.g. we may assume that B ⊆R0 and C ⊆R1.
The ﬁnal ingredient from the literature we use is the fact that the upper semi-
lattice of the c.e. wtt-degrees is distributive (due to Lachlan; see [18]). By (35) - (37)
this implies that
(degwtt(A0 ⊕B), degwtt(A1 ⊕C)) is a minimal pair.
(38)
Now let ˆA0 = A0 ∪B and ˆA1 = A1 ∪C. Since A0 ∩B = ∅and A1 ∩C = ∅, it
follows by the Splitting Lemma that (i) holds and ˆA0 =wtt A0 ⊕B and ˆA1 =wtt
A1 ⊕C. The latter implies (iv) and (ii) as follows. (iv) is immediate by (38) and by
the coincidence of the wtt-minimal pairs with the ibT-minimal pairs. For a proof
of (ii) it suﬃces to note that, by (36) and (37), B ̸≤wtt A0 and C ̸≤wtt A1 whereas
B ≤wtt A0 ⊕B =wtt ˆA0 and C ≤wtt A1 ⊕C =wtt ˆA1.
8 Simple degrees below and above given degrees
After having shown a variety of existence results for nonsimple r-degrees we now
turn to existence results for simple r-degrees (r = ibT, cl).
The existence of simple sets was shown by Post [15]. Using a stage construc-
tion the deﬁnition of a simple set A in the style of Post can be described as follows.
The set A has to be c.e. and coinﬁnite and has to meet the requirements
ℜe : If We is inﬁnite then We ∩A ̸= ∅.

On the Strongly Bounded Turing Degrees of Simple Sets
|
53
for e ≥0. By eﬀectivity of the enumeration {As}s≥0 of A this is ensured by the
following strategy for meeting ℜe:
If there is a stage s ≥e such that We,s ∩As = ∅and there is a number x ∈We,s
such that x ≥2e then put the least such x into As+1.
Note that the condition x ≥2e ensures that |A∩{0, . . . , 2e−1}| ≤e - hence that A
is coinﬁnite. Obviously, in order to guarantee the latter, the condition x ≥2e may
be replaced by x ≥f(e) for any strictly increasing computable function f such
that lim supx→∞f(x) −x = ∞. In the following we refer to this variant of Post’s
construction as Post’s simple set construction with lower bound f(e).
It is well known that Post’s simple set construction can be combined with the
permitting technique. Since permitting yields an ibT-reduction this implies that
for any noncomputable c.e. set B there is a simple set A such that A ≤ibT B. So the
class Sr of the simple r-degrees is downward dense in the partial ordering (R+
r , ≤)
of the nonzero r-degrees (r = ibT, cl).
Theorem 28. Let B be a noncomputable c.e. set. There is a simple set A such that
A ≤ibT B.
Proof (sketch).. Given a computable enumeration {Bs}s≥0 of B, it suﬃces to mod-
ify Post’s simple set construction as follows. The strategy for meeting requirement
ℜe is now combined with permitting:
If there is a stage s ≥e such that We,s ∩As = ∅and there is a number x ∈We,s
such that x ≥2e and Bs+1 ↾x + 1 ̸= Bs ↾x + 1 then put the least such x into
As+1.
Then one can argue that, by noncomputability of B, all requirements are met.
Namely, for a contradiction, assume that ℜe is not met. Then We is inﬁnite and
We ∩A = ∅. So, by the former, there are strictly increasing computable sequences
{xn}n≥0 and {sn}n≥0 such that xn ≥2e and xn ∈We,sn; and, by the latter, xn is
not enumerated into A. Hence, by construction, Bsn ↾xn +1 = B ↾xn +1. But this
implies that B is computable contrary to choice of B.
The dual of Theorem 28 holds too.
Theorem 29. Let B be a c.e. set. There is a simple set A such that B ≤ibT A.

54
|
Klaus Ambos-Spies
Proof. Without loss of generality we may assume that 0 /∈B (by closure of =ibT un-
der ﬁnite variations) and that B is noncomputable (since otherwise we may let A
be any simple set) but not simple (since otherwise we may let A = B). So, in partic-
ular, we may assume that B is inﬁnite and that the complement B of B contains an
inﬁnite computable set R as a subset where 0 ∈R. Let b be a computable one-to-
one function which enumerates B and let r be the computable one-to-one enumer-
ation of R in order of magnitude. Finally let B0 = ∅and Bs = {b(0), . . . , b(s −1)}
for s > 0.
We will enumerate a set A with the required properties in stages where As will
denote the ﬁnite part of A enumerated by the end of stage s (A0 = ∅).
We ensure B ≤ibT A by making A permit B. To be more precise, we use the
odd stages of the construction for coding B into A by putting some new number
ys ≤b(s) into A at stage 2s + 1 thereby ensuring that
∀s ∃ys (ys ≤b(s) & ys ∈A2s+1 \ A2s)
(39)
holds. Obviously this implies B ≤ibT A.
Since, by noncomputability of B, B ≤ibT A ensures that A is noncomputable
(hence coinﬁnite), in order to make A simple, it suﬃces to meet the standard sim-
plicity requirements for e ≥0.
ℜe : If We is inﬁnite then We ∩A ̸= ∅.
For meeting ℜe we use the standard strategy of Post with lower bound r(e) + 1
where action for meeting the simplicity requirements is limited to the even stages.
Choosing the witness for ℜe (if any) to be greater than r(e) /∈B will allow us to
argue that the enumeration of the witnesses for the simplicity requirements will
not interfere with coding B into A according to (39).
The construction of A is as follows.
Stage 2s > 0. For any e < s such that We,s ∩A2s−1 = ∅and there is a number
x > r(e) such that x ∈We,s, put the least such number x into A2s.
Stage 2s + 1. If there is a number y ≤b(s) such that y /∈A2s then let ys be the
greatest such number y and put ys into A2s+1.
Correctness of the construction is established as follows. The proof that the sim-
plicity requirements are met is straightforward. So it only remains to verify equa-
tion (39). By construction, it suﬃces to show that, for all s, the number ys speciﬁed
at stage 2s + 1 of the construction exists, i.e., that
∀s ∃y (y ≤b(s) & y /∈A2s)
(40)

On the Strongly Bounded Turing Degrees of Simple Sets
|
55
holds. Let A0 and A1 be the parts of A enumerated at the even and odd stages,
respectively, and set Ai
s = Ai ∩As for s ≥0. (Note that A is the disjoint union
of the c.e. sets A0 and A1, that A0
0 = A1
0 = A0 = ∅, and that A0
2s = A0
2s+1 and
A1
2s+1 = A1
2s+2.) Then for a proof of (40) it suﬃces to show that
∀s ∀z [|(A0 ∪A1
2s) ↾z + 1| ≤|(R ∪Bs) ↾z + 1|]
(41)
holds.
To show that (41) implies (40) ﬁx s. Then
|A2s ↾b(s) + 1|
≤
|(A0 ∪A1
2s) ↾b(s) + 1|
(since A2s ⊆A0 ∪A1
2s)
≤
|(R ∪Bs) ↾b(s) + 1|
(by (41) applied to z = b(s))
≤
b(s)
where the last inequality follows from the facts that there are b(s) + 1 numbers
≤b(s) and that b(s) /∈R ∪Bs (since R and B are disjoint and since b(s) enters B
only at stage s + 1). So there is a number y ≤b(s) with y /∈A2s.
The proof of (41) is by induction on s.
First note that |A0 ↾r(e) + 1| ≤e since a number x ≤r(e) can enter A0 only
for the sake of a requirement ℜe′ with e′ < e, and any of these e requirements
causes at most one number to be enumerated into A0. Since |R ↾r(e) + 1| = e + 1
it follows that, for any number z,
|A0 ↾z + 1| ≤|R ↾z + 1|
holds. Since A1
0 = B0 = ∅, this immediately implies (41) for s = 0.
For the inductive step assume that (41) holds for s, and ﬁx z in order to show
|(A0 ∪A1
2(s+1)) ↾z + 1| ≤|(R ∪Bs+1) ↾z + 1|].
(42)
W.l.o.g. we may assume that
(A0 ∪A1
2(s+1)) ↾z + 1 ̸= (A0 ∪A1
2s) ↾z + 1
since otherwise the claim is immediate by inductive hypothesis. Since A0 is ﬁxed
and since A1
2(s+1) = A1
2s+1, it follows that at stage 2s + 1 of the construction
the required ys exists, ys ≤z, and A1
2(s+1) = A1
2s+1 = A1
2s ∪{ys} whence (by
A0 ∩A1 = ∅)
|(A0 ∪A1
2(s+1)) ↾z + 1| = |(A0 ∪A1
2s) ↾z + 1| + 1.
(43)
Now, if b(s) ≤z then, by R ∩B = ∅,
|(R ∪Bs+1) ↾z + 1| = |(R ∪Bs) ↾z + 1| + 1

56
|
Klaus Ambos-Spies
and the claim follows by inductive hypothesis. So for the remainder of the argu-
ment we can assume that b(s) > z.
Now, for a contradiction, assume that (42) fails, i.e.,
|(A0 ∪A1
2(s+1)) ↾z + 1| > |(R ∪Bs+1) ↾z + 1|.
Since, by b(s) > z, |(R ∪Bs) ↾z + 1| = |(R ∪Bs+1) ↾z + 1|, it follows, by inductive
hypothesis and by (43), that
|(A0 ∪A1
2s) ↾z + 1| = |(R ∪Bs) ↾z + 1| = |(R ∪Bs+1) ↾z + 1|
(44)
holds. Moreover, by deﬁnition of ys and by ys ≤z < b(s), the interval (z, b(s)] is
contained in A2s ⊆A0 ∪A1
2s. So
|(A0 ∪A1
2s) ↾b(s) + 1| = |(A0 ∪A1
2s) ↾z + 1| + b(s) −z
(45)
while, by inductive hypothesis,
|(A0 ∪A1
2s) ↾b(s) + 1| ≤|(R ∪Bs) ↾b(s) + 1|.
(46)
By replacing the left hand side of (46) according to (45) and (44) it follows that
|(R ∪Bs) ↾z + 1| + b(s) −z ≤|(R ∪Bs) ↾b(s) + 1|
hence
b(s) −z ≤|(R ∪Bs) ∩(z, b(s)]|.
(47)
But, since b(s) /∈R ∪Bs,
|(R ∪Bs) ∩(z, b(s)]| = |(R ∪Bs) ∩(z, b(s))| ≤|(z, b(s))| = (b(s) −z) −1
contrary to (47). So (42) must hold, which completes the proof of (41) and the proof
of the theorem.
9 Simple degrees below and above given degrees:
stronger results and applications
In the preceding section we have shown that, for any given noncomputable c.e.
set B, there is a simple set A such that A ≤r B and a simple set A such that B ≤r A
(r = ibT, cl). On the other hand, by Theorem 10, there are noncomputable c.e.
sets B which are not r-equivalent to any simple set. So the above results cannot
be combined. This makes it natural to ask how close a simple set A ≤r B and a

On the Strongly Bounded Turing Degrees of Simple Sets
|
57
simple set A ≥r B can be to B. In the former case we will show that A can be
chosen to be lbT-equivalent to B, i.e., that there is a simple set A such that B ≤lbT
A ≤r B. So, in particular, all nonzero c.e. lbT-degrees are simple. In the latter case
we can only show that A can be chosen to be wtt-equivalent to B, i.e., that there
is a simple set A such that B ≤r A ≤wtt B. At the end of the section we apply the
latter observation in order to prove the analog of Theorem 26 for simple degrees
thereby showing that, for any nonzero c.e. r-degree a, there is a simple r-degree
which is incomparable with a.
Theorem 30. Let B be a noncomputable c.e. set. There is a simple set A such that
A ≤ibT B and B ≤lbT A.
Proof. Fix a computable 1-1 function b(n) enumerating B and let {Bs}s≥0 be the
computable enumeration of B deﬁned by B0 = ∅and Bs+1 = {b(0), . . . , b(s)}.
We eﬀectively enumerate a c.e. set A with the required properties in stages where
As denotes the ﬁnite part of A enumerated by the end of stage s (As = ∅).
The strategy for meeting the simplicity requirements
ℜe : If We is inﬁnite then We ∩A ̸= ∅.
is Post’s simple set strategy combined with permitting as introduced in the proof
of Theorem 28. Here, however, we use a larger lower bound thereby leaving
enough room for coding B into A in order to ensure B ≤lbT A. As in the proof
of Theorem 29 we handle the simplicity requirements at the even stages and the
coding of B into A at the odd stages of the construction.
Stage 2s > 0. For any e < s such that We,s ∩A2s−1 = ∅and there is a number
x > max{8e, b(s)} such that x ∈We,s, put the least such number x into A2s.
Stage 2s + 1. Put zs into A2s+1 where zs is the least number z such that 4b(s) <
z and z /∈A2s.
In order to show that the construction is correct, let A0 and A1 be the parts of A
enumerated at the even and odd stages respectively. (So A is the disjoint union of
the c.e. sets A0 and A1, and, for Ai
s = Ai ∩As, A0
0 = A1
0 = A0 = ∅, A0
2s = A0
2s+1
and A1
2s+1 = A1
2s+2.)
As in the proof of Theorem 28 we may argue that, by noncomputability of B,
the simplicity requirements ℜe are met. Moreover, by construction,
|A0 ↾8e + 1| ≤e + 1 and |A1 ↾4e + 1| ≤e + 1
(48)
whence A is coinﬁnite. So A is simple.

58
|
Klaus Ambos-Spies
The reduction A ≤ibT B holds by permitting since any number y entering A at
stage 2s or 2s + 1 is greater than b(s). Finally, for a proof of B ≤lbT A, note that,
by (48), |A ↾8y + 1| ≤3y + 2 for all y ≥0, hence [4y + 1, 8y] ̸⊆A for y ≥3. So,
for b(s) ≥3, zs ≤8b(s). Obviously this implies B ≤f-T A for the linearly bounded
function f(n) = 8n.
Theorem 30 immediately implies that any noncomputable c.e. set is lbT-equi-
valent to a simple set.
Corollary 31. Any nonzero c.e. lbT-degree is simple.
In the remainder of this section we prove a weak dual version of Theorem 30 where
lbT is replaced by wtt.
Theorem 32. Let B be a noncomputable c.e. set. There is a simple set A such that
B ≤ibT A and A ≤wtt B.
Proof. As in the proof of Theorem 29 we may assume that 0 /∈B and that B is not
simple. So we may ﬁx an inﬁnite computable set R′ ⊆B such that 0 ∈R′. From
R′ we obtain a very sparse computable subset R of R′ by inductively deﬁning the
function r(s) enumerating R in order as follows: let r(0) = 0 and, given r(s), let
r(s + 1) = (µ y ∈R′)(|R′ ∩(r(s), y)| > r(s) + s + 2).
Note that the deﬁnitions of R and r guarantee that 0 ∈R, R ∩B = ∅and
∀s ≥0 [|B ∩(r(s), r(s + 1))| > r(s) + s + 2].
(49)
Now the desired set A is essentially constructed as in the proof of Theorem 29
based on the sets B and R and the enumeration r of R given above. The only diﬀer-
ence is that now the strategy for making A simple is combined with B-permitting.
So the even stages of the construction are now as follows
Stage 2s > 0. For any e < s such that We,s ∩A2s−1 = ∅and there is a number
x > max(r(e), b(s)) such that x ∈We,s, put the least such number x into A2s.
while the odd stages are unchanged:
Stage 2s + 1. If there is a number y ≤b(s) such that y /∈A2s then let ys be the
greatest such number y and put ys into A2s+1.

On the Strongly Bounded Turing Degrees of Simple Sets
|
59
Then - as in the proof of Theorem 28 - we may argue that A is simple; and - as in
the proof of Theorem 29 - we may argue that B ≤ibT A. In particular, as there, we
can show that (41) holds and that the number ys speciﬁed at stage 2s + 1 exists.
It remains to show that A ≤wtt B. Using the notation introduced in the proof of
Theorem 29, it is immediate that the part A0 of A enumerated at the even stages is
ibT-reducible (hence wtt-reducible) to B by permitting. So it suﬃces to show that
the part A1 of A enumerated at the odd stages is wtt-reducible to B too. Since ys is
the only number which enters A1 at stage 2s +1, this can be established by giving
a nondecreasing computable function f such that
∀∞s ≥0 [b(s) ≤f(ys)].
(50)
Namely, (50) implies that, for almost all numbers s and x,
Bs ↾f(x) + 1 = B ↾f(x) + 1 ⇒A1
s ↾x + 1 = A1 ↾x + 1
whence A1(x) can be computed from B ↾f(x) + 1.
Now the desired function f is deﬁned by
∀x, s ≥0 [x ∈[r(s), r(s + 1)) ⇒f(x) = r(s + 2)].
(51)
Obviously, f is nondecreasing and computable. In order to show that f satisﬁes
(50), ﬁx s such that w.l.o.g. b(s) > r(1). Then, given x ≥1 such that b(s) ∈
(r(x), r(x + 1)) it suﬃces to argue that ys ≥r(x −1). Since, by deﬁnition, ys is
the greatest number y ≤b(s) such that y /∈A2s, it suﬃces to show that the in-
terval [r(x −1), r(x)] is not completely contained in A. This is done as follows. By
|R ↾r(x) + 1| = x + 1 and by (41),
|A ↾r(x) + 1| ≤x + 1 + |B ↾r(x) + 1|
(52)
while, by (49),
|B ∩(r(x −1), r(x))| > r(x −1) + x + 1,
hence
|B ↾r(x) + 1| < r(x) + 1 −(r(x −1) + x + 1) = (r(x) −r(x −1)) −x.
(53)
It follows that
|A ∩[r(x −1), r(x)]|
≤
|A ↾r(x) + 1|
≤
x + 1 + |B ↾r(x) + 1|
(by (52))
<
x + 1 + (r(x) −r(x −1)) −x
(by (53))
=
(r(x) −r(x −1)) + 1
=
|[r(x −1), r(x)]|,
hence [r(x −1), r(x)] ̸⊆A.

60
|
Klaus Ambos-Spies
We conclude this section with an application of Theorem 32. We show that, for any
nonzero c.e. r-degree a there is a simple r-degree which is incomparable with a.
For this sake we prove that the analog of Theorem 26 on nonsimple maximal and
minimal pairs holds for the simple degrees too. We obtain this from Theorem 32
by applying some of the results on the strongly bounded Turing degrees from [3]
used in the proof of Theorem 26 already.
Theorem 33. There is a pair of simple c.e. r-degrees a and b which is minimal and
maximal (r = ibT, cl).
Proof. As observed in the proof of Lemma 27, it suﬃces to prove the theorem for
r = ibT. By [3] ﬁx c.e. sets A and B such that the pair
(degibT(A), degibT(B))
is minimal and maximal, and by Theorem 32, let ˆA and ˆB be simple sets such that
ˆA =wtt A, A ≤ibT ˆA, ˆB =wtt B and B ≤ibT ˆB. Then, by maximality of the pair
(degibT(A), degibT(B)) and by A ≤ibT ˆA and B ≤ibT ˆB, the pair
(degibT(ˆA), degibT(ˆB))
is maximal too. Moreover, since by [3], for any c.e. sets ˜A and ˜B, the pair
(degibT(˜A), degibT(˜B))
is minimal iﬀthe pair (degwtt(˜A), degwtt(˜B)) is minimal, it follows by minimality
of the pair (degibT(A), degibT(B)) and by ˆA =wtt A and ˆB =wtt B, that the pair
(degibT(ˆA), degibT(ˆB)) is minimal too. So a = degibT(ˆA) and b = degibT(ˆB) have
the required properties.
Since, as observed before, for a pair (a, b) of c.e. r-degrees which is minimal and
maximal and for any c.e. r-degree c > 0, c|a or c|b, Theorem 33 implies that any
c.e. r-degree c > 0 is incomparable to some simple r-degree.
Corollary 34. For any c.e. r-degree c > 0 there is a simple c.e. r-degree d such that
c and d are incomparable (r = ibT, cl).
Moreover, since the degree 0 is nonsimple, Theorem 33 immediately implies that
the class of simple r-degrees is not closed under meet.
Corollary 35. The class Sr of the simple c.e. r-degrees is not closed under meet
(r = ibT, cl).

On the Strongly Bounded Turing Degrees of Simple Sets
|
61
10 wtt-Complete sets have simple degree
In Section 8 we have shown that Post’s simple set construction can be combined
with permitting and coding in order to show that, for any given noncomputable
c.e. set B, there is a simple set A such that A ≤ibT B and a simple set A such that
B ≤ibT A, respectively. On the other hand, by the existence of nonzero nonsimple
c.e. ibT-degrees (Theorem 10), in general permitting and coding cannot be com-
bined in order to obtain a simple set A which is ibT-equivalent to B. The problem
which arises in combining these techniques is as follows. If a number x (permitted
by B) is put into A at a stage s in order to meet a simplicity requirement then it may
happen that this number x is enumerated into B at a later stage t. Then, in order
to record this change, a number < x has to be put into A (since x has been enumer-
ated before) but this smaller number may not be permitted by B. (So, in general,
we only obtain the weaker results presented in the preceding section.) This prob-
lem can be avoided, however, if the set B is wtt-complete. Then, by choosing a
suﬃciently large lower bound for the simple set construction, we may argue that
if a number x used for meeting a simplicity requirement is enumerated into B later
then a number x′ < x can be forced into B at a still later stage so that the change
of B at x has not to be recorded by the coding procedure. So any wtt-complete set
is ibT-equivalent to a simple set.
Theorem 36. Let B be wtt-complete. There is a simple set A such that A =ibT B.
Proof. We start with some notation. Let {Ψn}n≥0 and {ψn}n≥0 be computable enu-
merations of the (partial) wtt-functionals together with corresponding partially
computable bounds. (To be more precise, Ψn and ψn are chosen so that, when-
ever Ψ X
n (x) is deﬁned, then ψn(x) is deﬁned and the use of Ψ X
n (x) is bounded by
ψn(x); and, for any wtt-functional Ψ and for any corresponding (w.l.o.g. strictly in-
creasing) computable bound f, there is a number n such that Ψ = Ψn and f = ψn.)
Moreover, let {Ψn,s}s≥0 and {ψn,s}s≥0 be uniformly computable enumerations of
Ψn and ψn as usual. W.l.o.g. we may assume that, if ψn(x) is deﬁned then ψn(y) is
deﬁned for all y < x and ψn(y) < ψn(x) (and similarly for ψn,s). Finally, let b be a 1-1
computable function enumerating B and let B0 = ∅and Bs+1 = {b(0), . . . , b(s)}.
We construct a sequence {An}n≥0 of (uniformly) c.e. sets together with an
auxiliary c.e. set C such that, for n ≥0,
C = Ψ B
n ⇒An =ibT B & An is simple
(54)
holds. Then, by wtt-completeness of B, there is a number n such that C = Ψ B
n , and
the set A = An has the required properties.

62
|
Klaus Ambos-Spies
Call n correct if C = Ψ B
n holds, let Cs and An,s be the ﬁnite parts of C and An,
respectively, enumerated by the end of stage s of the construction below, and let
l(n, s) = µx(Cs(x) ̸= Ψ Bs
n,s(x)).
Then, for correct n, lims→∞l(n, s) = ∞. Moreover, for x < l(n, s) such that x /∈Cs,
we can force that a number y ≤ψn(x) enters B after stage s by putting x into C at
stage s + 1.
Now in order to make sure that, for correct n, the set A = An has the required
properties we ensure that for such n the conditions
x ∈An,s+1 \ An,s ⇒∃t ≥s (b(t) ≤x)
(55)
and
An ↾b(s) + 1 ̸= An,s ↾b(s) + 1
(56)
are satisﬁed - thereby guaranteeing that An ≤ibT B and B ≤ibT An, respectively -
and the requirements
ℜn
e : If We is inﬁnite then An
e ∩We ̸= ∅
are met (for e ≥0) - thereby guaranteeing that An is simple. For meeting the sim-
plicity requirements ℜn
e we use Post’s strategy with lower bounds ψn(⟨n, e⟩) + 1
combined with permitting. The latter guarantees (55). The chosen lower bound al-
lows us to satisfy (56) as follows. If we enumerate y > ψn(⟨n, e⟩) into An in order to
meet ℜn
e at stage s + 1 and y = b(t) for some t ≥s + 1 then we can force a number
< y into B after stage t + 1 by putting ⟨n, e⟩into C at the least stage t′ + 1 ≥t + 1
such that l(n, t′) > ⟨n, e⟩.
The construction of the sets C and An is as follows (where C0 = An,0 = ∅).
Stage s + 1. The stage consists of 3 steps.
Step 1 (Making An simple). For any n, e ≤s such that
(i) We,s ∩An,s = ∅,
(ii) ψn,s(⟨n, e⟩) ↓, and
(iii) there is a number y such that y ∈We,s and
max(b(s), ψn(⟨n, e⟩) < y
hold, put the least such number y into An and declare that y is an n-e-
number.
Step 2 (Partial coding of B into An). For any n, e ≤s such that b(s) /∈An,s
put b(s) into An.

On the Strongly Bounded Turing Degrees of Simple Sets
|
63
Step 3 (Completing the coding of B into An). For any n, e ≤s such that
there is a stage t ≤s such that b(t) ∈An,t, b(t) has been declared to be
an n-e-number at a stage ≤t, ⟨n, e⟩< l(n, s), and ⟨n, e⟩/∈Cs, put ⟨n, e⟩
into C.
In order to show that the construction achieves its goal, ﬁx n such that n is cor-
rect. Since, obviously, (55) is satisﬁed (for all n), it suﬃces to show that the n-
requirements, i.e., the requirements ℜn
e for e ≥0, are met and (56) holds. Note
that, by correctness of n, ψn is total and lims→∞l(n, s) = ∞.
By totality of ψn, as in the proof of Theorem 28 we can argue that ℜn
e is met.
Namely, for a contradiction, assume that ℜn
e is not met. Then We is inﬁnite and
We ∩An = ∅. So there are strictly increasing computable sequences {xn}n≥0 and
{sn}n≥0 such that ψn,s0(⟨n, e⟩) ↓, xn > ψn(⟨n, e⟩), xn ∈We,sn, and Bsn ↾xn + 1 =
B ↾xn + 1. Hence B is computable contrary to choice of B.
Finally, the proof of (56) is indirect too. For a contradiction ﬁx b(s) minimal
such that
An ↾b(s) + 1 = An,s ↾b(s) + 1.
(57)
Then there is a number e and a stage t such that n, e ≤t < s and requirement
ℜn
e enumerates b(s) into An at stage t + 1. So ψn,t(⟨n, e⟩) ↓, ψn(⟨n, e⟩) < b(s),
and b(s) becomes an n-e-number at stage t + 1. Since, by construction, there is
at most one n-e-number (for any given n and e) and since lims→∞l(n, s) = ∞,
it follows that there is a stage s′ ≥s such that l(n, s′) > ⟨n, e⟩and ⟨n, e⟩/∈Cs′
and that, for the least such s′, ⟨n, e⟩is enumerated into C at stage s′ + 1, hence
C(⟨n, e⟩) ̸= Ψ Bs′
n,s′(⟨n, e⟩) ↓. By correctness of n this implies that a number z ≤
ψn(⟨n, e⟩) has to enter B after stage s′. I.e., there is a stage s′′ ≥s′ ≥s such that
b(s′′) ≤ψn(⟨n, e⟩) < b(s). It follows, by minimality of b(s), that An ↾b(s′′) + 1 ̸=
An,s′′ ↾b(s′′) + 1. But, by b(s′′) < b(s) and by s ≤s′′ this contradicts (57).
This completes the proof.
Note that Theorem 36 shows that in Theorem 16 the assumption that A is not wtt-
complete is necessary. Conversely, Corollary 19 implies that in Theorem 36 we can-
not replace wtt-completeness by T-completeness.
As a direct consequence of Theorem 36 we obtain the existence of simple up-
per cones in the c.e. ibT- and cl-degrees, which in turn directly implies that the
class Sr of the nonsimple c.e. r-degrees does not generate the class Rr of all c.e.
r-degrees under meet.
Corollary 37. Let r = ibT, cl. There is a c.e. r-degree a such that
∀b [a ≤b ⇒b simple].
(58)

64
|
Klaus Ambos-Spies
Proof. Since, for r = ibT, cl, r-reducibility is stronger than wtt-reducibility, for
any c.e. sets A and B such that A is wtt-complete and A ≤r B, B is wtt-complete
too. So the claim is immediate by Theorem 36.
Corollary 38. The class Sr of the nonsimple c.e. r-degrees does not generate the
class Rr of all c.e. r-degrees under meet (r = ibT, cl).
Proof. This is immediate by Corollary 37.
Another consequence of Theorem 36 is that there are inﬁnite intervals of c.e. r-
degrees containing only simple degrees.
Corollary 39. Let r = ibT, cl. There are c.e. r-degrees a and b such that a < b,
[a, b] is inﬁnite, and c is simple for all c ∈[a, b].
Proof. Given any wtt-complete set A and any unbounded computable shift f, the
interval [degr(Af ), degr(A)] is contained in the class of r-degrees of wtt-complete
sets, hence, by Theorem 36, contains only simple degrees. So it suﬃces to show
that the interval [degr(Af ), degr(A)] is inﬁnite. Since, by the Computable-Shift
Lemma, Bf <r B for any computable unbounded shift f and any noncomputable
c.e. set B, this follows from the observation that for any unbounded computable
shift f there are unbounded computable shifts g and h such that f(n) = g(h(n))
hence Bf = (Bh)g.
Recall that in Section 6 we proved the analog of Corollary 39 for nonsimple
degrees (Corollary 14). In fact, there we proved that there is a closed interval
[degr(A), degr(B)] of nonsimple r-degrees such that not only A <r B but also
A <T B (hence A <wtt B). The corresponding result for simple intervals fails:
By Theorem 16, for any interval [degr(A), degr(B)] which contains only simple
r-degrees, it holds that A =wtt B.
11 Splitting into simple degrees
By Theorem 20 any nonzero c.e. r-degree can be split into two lesser nonsimple
c.e. r-degrees. So, in particular, the nonsimple c.e. r-degrees generate the c.e. r-
degrees under join whereas - as just observed - the nonsimple c.e. r-degrees do
not generate the c.e. r-degrees under meet. We conclude our investigation of the
simple and nonsimple r-degrees by looking at the corresponding questions for
simple r-degrees.

On the Strongly Bounded Turing Degrees of Simple Sets
|
65
Though - as we show ﬁrst - any simple r-degree can be split into two lesser sim-
ple r-degrees, the simple r-degrees do not generate the nonzero r-degrees under
join. So, in particular, there is a nonzero c.e. r-degree which cannot be split into
two simple c.e. r-degrees. In order to prove this we show a considerably stronger
result namely that there are c.e. r-degrees b < a such that any simple r-degree
below a is already below b. Finally, we show that the simple c.e. r-degrees do not
generate the c.e. r-degrees under meet either.
Theorem 40. Let A be a simple set and let B be a noncomputable c.e. set. There
are simple sets A0 and A1 such that, for r = ibT, cl,
degr(A) = degr(A0) ∨degr(A1)
(59)
and
B ̸≤T Ai (i = 0, 1).
(60)
Note that, for B = A, the theorem implies that A0 and A1 are Turing incomparable,
hence, by (59), Ai <r′′ A for r′′ = ibT, cl, wtt, T and i ≤1.
Proof. The proof is a straightforward combination of the proof of Sacks’s Splitting
Theorem with the basic construction of a simple c.e. r-degree. So we only give
the idea. As in the proof of Theorem 20 we may argue that it suﬃces to consider
r = ibT.
Fix a computable 1-to-1 function a enumerating A, let As+1 = {a(0), . . . a(s)},
and let Ai,s denote the ﬁnite part of Ai enumerated by the end of stage s of the
construction below (i = 0, 1). Then, in order to guarantee (59), it suﬃces to ensure
A = A0 ∪A1
(61)
and, for i ≤1 and s ≥0,
Ai,s+1 \ Ai,s = ∅or µx(x ∈Ai,s+1 \ Ai,s) = a(s).
(62)
In order to ensure that B is not Turing reducible to Ai and to make Ai simple it
suﬃces to meet the requirements
ℜ4e+i : B ̸= ΦAi
e
and
ℜ4e+2+i : If We is inﬁnite then We ∩Ai ̸= ∅.
respectively (e ≥0, i = 0, 1).
The requirements ℜ4e+i are met by Sacks’s preservation strategy (see e.g. [16]).
We only note here that this strategy imposes a restraint r(4e+i, s) on Ai at (the end

66
|
Klaus Ambos-Spies
of) stage s of the construction, and that, assuming that there are at most ﬁnitely
many stages s such that a number ≤r(4e + i, s) is put into Ai at stage s + 1, ℜ4e+i
is met and
r(4e + i) = lim
s→∞r(4e + i, s) < ω
exists. The requirements ℜ4e+2+i are met by a variant of Post’s simple set con-
struction. Stage s + 1 of the construction is as follows (A0,0 = A1,0 = ∅).
Stage s + 1. Requirement ℜ4e+i (i ≤1) requires attention if e ≤s and a(s) ≤
r(4e + i, s) while requirement ℜ4e+2+i (i ≤1) requires attention if e ≤s and
(i) We,s ∩Ai,s = ∅and
(ii) ∃y ≥a(s)(y ∈We,s ∩As+1)
hold. Fix n minimal such that ℜn requires attention (and let n = 4s if no such
n exists). If n = 4e + i (i ≤1) then let
Ai,s+1 = Ai,s & A1−i,s+1 = A1−i,s ∪{a(s)}
and if n = 4e + 2 + i (i ≤1) then let
Ai,s+1 = Ai,s ∪{a(s), y} & A1−i,s+1 = A1−i,s
for the least y as in (ii).
Now, to show that the construction is correct, ﬁrst note that Ai,s ⊆As (i ≤1,
s ≥0) and that (61) and (62) are satisﬁed. Moreover, since any simplicity require-
ment acts at most once, it follows from the above remarks on Sacks’s preservation
strategy that requirement ℜ4e+i requires attention at most ﬁnitely often and is
met. So, in order to show that the simplicity requirement ℜ4e+2+i is met, it suf-
ﬁces to show that, for inﬁnite We, there are inﬁnitely many stages s satisfying (ii).
Since A is simple, We ∩A is inﬁnite. So there are inﬁnite computable sequences
y0 < y1 < . . . and s0 < s1 < . . . such that yn ∈We,sn ∩Asn+1. Since A is non-
computable it follows that, for inﬁnitely many n, there is a stage s ≥sn such that
a(s) ≤yn.
This completes the sketch of the proof.
In order to show that the simple r-degrees do not generate the nonzero r-degrees
under join we show that there are c.e. r-degrees a and b such that 0 < b < a and
such that any simple r-degree below a is already below b.So a cannot be presented
as the ﬁnite join of simple r-degrees.
Theorem 41. There are noncomputable c.e. sets A and B such that, for r = ibT, cl,
B <r A
(63)

On the Strongly Bounded Turing Degrees of Simple Sets
|
67
and
∀S simple (S ≤r A ⇔S ≤r B).
(64)
Proof. By a tree argument we enumerate c.e. sets A and B with the required prop-
erties. As usual we let As and Bs denote the ﬁnite parts of A and B enumerated by
the end of stage s.
It suﬃces to guarantee that
B ≤ibT A
(65)
holds and that the requirements
ℜe : A ̸= ˜ΦB
e
(e ≥0)
and
ˆℜe : If We0 is simple and We0 = ˆΦA
e1 then We0 ≤ibT B.
(e = ⟨e0, e1⟩≥0)
are met. Namely, the requirements ℜe together with (65) imply (63), while the re-
quirements ˆℜe guarantee
∀S simple (S ≤ibT A ⇒S ≤ibT B).
(66)
The latter implies (64) as follows. By (63) it suﬃces to show that (66) holds for ≤cl
in place of ≤ibT too. So ﬁx a simple set S such that S ≤cl A. Then, for some k ≥0,
S ≤(i+k)bT A. So, for S + k = {x + k : x ∈S}, S + k ≤ibT A. Since, for simple S, the
bounded shift S + k is simple again, it follows with (66) that S + k ≤ibT B, hence
S ≤(i+k)bT B.
Condition (65) is met by permitting. I.e., a number y is put into B at a stage
s + 1 only if a smaller number x is put into A at the same stage.
For meeting requirement ℜe we use the Friedberg-Muchnik strategy. I.e., for
some number x we keep x out of A unless there is a stage s such that ˜ΦBs
e,s(x) =
0. In the latter case we put x into A and at the same time restrain all numbers
≤x + e from B thereby preserving the computation ˜ΦBs
e,s(x). In order to make
this action compatible with a higher priority requirement ˆℜe′ (e′ < e), however,
we have to modify this strategy somewhat (where here and in the following we
assume e′ = ⟨e′
0, e′
1⟩). Assume that ˆℜe′ is relevant, i.e., We′
0 is simple and We′
0 =
ˆΦA
e′
1. Then putting x into A permits numbers z ≥x to enter We′
0 which, in order
to meet ˆℜe′, have to be permitted by B too. For numbers z ≥x + e + 1 this is not
a problem, since simultaneously with putting x into A we may put x + e + 1 into
B without injuring the restraint on B needed for the sake of ℜe. For the numbers
z = x, . . . , x + e, however, we cannot guarantee B-permitting without injuring

68
|
Klaus Ambos-Spies
the restraint imposed by ℜe. So we diagonalize via x at stage s + 1 only if these
numbers are in We′
0 already, i.e., if [x, x + e] ⊆We′
0,s. For simple We0 we may
argue that, by the Simple Set Lemma, we will ﬁnd such x and s. For nonsimple
We0, however, such a situation may never occur whence we have to guess whether
a higher priority requirement ˆℜe′ is relevant or not. As usual these guesses are
implemented by the priority tree of the construction.
The priority tree T is the full binary tree, T = {0, 1}<ω. For a node (string) α
of the tree we let |α| denote the length of α and we write α ⊑β (α ⊏β) if α is an
initial segment (proper initial segment) of β. Furthermore, we say that α is to the
left of β, α <L β, if there is a string γ such that γ0 ⊑α and γ1 ⊑β, and we say that
α is less than β (α < β) if α <L β or α ⊏β, and we write α ≤β if α < β or α = β.
Each node α of length e encodes a guess at which of the requirements ˆℜ0,
. . . , ˆℜe−1 are relevant, and to each such node α a strategy ℜα for meeting require-
ment ℜe is attached which is based on this guess. (So the priority ordering of the
requirements is given by ℜ0 > ˆℜ0 > ℜ1 > ˆℜ1 > . . . .)
Potential diagonalization witnesses are assigned to the strategies ℜα (|α| = e)
working on requirement ℜe as follows. Fix a uniformly computable partition of ω
into inﬁnitely many mutually disjoint ﬁnite intervals Iα
n (α ∈T, n ≥0) such that
Iα
n = [xα
n, yα
n] = [xα
n, xα
n + |α| + 1]
has length |α| + 2 and xα
n ≥n. Then the intervals Iα
n, n ≥0, are reserved for
the strategy ℜα where the least element xα
n ∈Iα
n is the diagonalization candidate
(follower) while yα
n is the corresponding B-trace to be put into B if xα
n is enumerated
into A.
Now, for α and e < |α|, the guess α(e) = 0 expresses that requirement ˆRe is rel-
evant, i.e., that its premise holds. In order to approximate this guess in the course
of the construction, the second condition in the premise of ˆRe is approximated
with the help of the length function l(e, s) deﬁned by
l(e, s) = µx(We0,s(x) ̸= ˆΦAs
e1,s(x)).
Then, since ˆΦe1 is a bounded functional,
We0 = ˆΦA
e1 ⇔
lim
s→∞l(e, s) = ∞⇔lim sup
s→∞l(e, s) = ∞.
(67)
So We0 = ˆΦA
e1 if and only if there are inﬁnitely many e-expansionary stages s,
i.e., stages s such that l(e, s) > l(e, t) for all t < s (where we may consider only
stages s and t from some given inﬁnite set). The ﬁrst part of the premise of ˆRe,
namely that We0 is simple, is too complex (namely, Π0
3-complete; see e.g. Soare
[16]), however, in order to be approximated in a similar fashion. So we replace the

On the Strongly Bounded Turing Degrees of Simple Sets
|
69
test on simplicity of We0 by a test on the following inﬁnitary property used in the
construction, namely the property that, for any β ∈T and a corresponding inﬁnite
computable set Dβ (to be speciﬁed below), there are inﬁnitely many n ∈Dβ such
that Iβ
n ⊆We0. This leads to the following deﬁnitions where we say that a number
e′ is α-relevant if e′ < |α| and α(e′) = 0.
For n ≥0, call the node α n-saturated at stage s if s ≥n and, for any node
β with |β| ≤n there are at least n β-intervals Iβ
m = [xβ
m, yβ
m] such that, for any α-
relevant e′, Iβ
m ⊆We′
0,s and l(e′, s) > yβ
m; and call α saturated if for every number
n there is a stage sn such that α is n-saturated at stage sn. Note that α is saturated
if and only if
∀e′ < |α| (α(e′) = 0 ⇒lim
s→∞l(e′, s) = ω)
(68)
and
∀β ∃∞m (Iβ
m ⊆

{e′:e′<|α| & α(e′)=0}
We′
0)
(69)
hold.
Then α-stages are inductively deﬁned as follows. 0 is an α-stage for all strings
α. For s > 0, s is a λ-stage and, if s is an α-stage and |α| < s, then s is an α0-stage
if, for the greatest t < s such that t is an α0-stage, α0 is (t + 1)-saturated at stage s,
and s is an α1-stage otherwise. Let δs be the unique string of length s such that s
is a δs-stage. (So δs codes the guess at the end of stage of the construction about
relevance of the ﬁrst s requirements ˆℜ0, . . . , ˆℜs−1. Also note that s is an α-stage
if and only if α ⊑δs.) Finally, the true path f of the construction is deﬁned by
f = lim infs→∞δs. I.e., f ↾n is the leftmost string α of length n such that α ⊑δs
for inﬁnitely many stages s.
The following True Path Lemma shows that the guesses on the true path are
(suﬃciently) correct. Namely, if a requirement ˆℜe is relevant then we guess so.
And, if we erroneously guess that a requirement ˆℜe is relevant, this will not do any
harm to the construction since the assumptions actually used in the construction
will be true.
True Path Lemma. (a) Let α be a string such that α ⊏f. Then α is saturated.
(b) Assume that e = ⟨e0, e1⟩≥0 is relevant, i.e., We0 is simple and We0 = ˆΦA
e1.
Then f(e) = 0.
Proof. Part (a) is immediate by the deﬁnition of f. For a proof of part (b) let
α = f ↾e. Then we have to show that there are inﬁnitely many α0-stages. In order
to do so, it suﬃces to show that α0 is saturated. Then, by (68) and (69) (for α0 in
place of α) , for any t ≥0 and α′ ⊑α0, α′ is (t+1)-saturated at all suﬃciently large
stages s which, by deﬁnition, implies that there are inﬁnitely many α0-stages.
Now, since α ⊑f, it follows from part (a) that (68) and (69) hold. It suﬃces to
establish these conditions for α0 in place of α. The former is immediate since, by

70
|
Klaus Ambos-Spies
We0 = ˆΦA
e1 and by (67), lims→∞l(e, s) = ω. For a proof of the latter ﬁx β. Then, by
(69) (for α), there is an inﬁnite computable set D such that Iβ
m ⊆We′
0 for all e′ < e
such that e′ is α-relevant or, equivalently, α0-relevant. So it suﬃces to show that
there are inﬁnitely many m ∈D such that Iβ
m ⊆We0. But since We0 is simple this
is immediate by the Simple Set Lemma.
This completes the proof of the True Path Lemma.
We are now ready to give the construction of A and B. Let A0 = B0 = ∅and
initialize all strategies ℜα at stage 0. Moreover, say that a strategy ℜα is satisﬁed
at stage s if ℜα has been active at a stage t ≤s and ℜα has not been initialized at
any stage t′ such that t ≤t′ ≤s.
Stage s + 1 > 0. Strategy ℜα requires attention at stage s + 1 if the following
hold.
(i) α ⊏δs
(ii) ℜα is not satisﬁed at stage s.
(iii) There is a number m ≥0 such that
(iii)a xα
m is greater than the greatest stage t ≤s such that ℜα is initialized
at stage t,
(iii)b xα
m ̸∈As and yα
m ̸∈Bs,
(iii)c
˜ΦBs
e (xα
m) = 0 where e = |α|, and
(iii)d for all α-relevant e′ < |α|, Iα
m ⊆We′
0,s and l(e′, s) > yα
m.
Moreover, if ℜα requires attention then, for the least m satisfying (iii)a - (iii)d,
ℜα requires attention via m.
If some strategy requires attention then ﬁx α minimal such that ℜα requires
attention and ﬁx m such that ℜα requires attention via m. Declare ℜα to be
active, put xα
m into A and yα
m into B, and initialize all strategies ℜβ such that
α < β.
If no requirement requires attention then initialize all strategies ℜβ such that
δs ≤β.
This completes the construction. It remains to show that the construction is cor-
rect. We do this by proving the following claims.
Claim 1. B ≤ibT A (i.e., (65) holds). Proof. Note that if a number y is enumerated
into B at a stage s + 1 then, for some α and m, the ℜα-follower xα
m is enumerated
into A at stage s + 1 and y = yα
m > xα
m. So B ≤ibT A by permitting.
Claim 2. Let e ≥0 and let α = f ↾e. Then ℜα requires attention only ﬁnitely
often and ℜe is met.
Proof. The proof is by induction on e. Fix e and α = f ↾e. Then, by deﬁnition
of f, α < δs for all suﬃciently large stages s. So, by inductive hypothesis, we may
ﬁx a stage s0 such that α < δs for s ≥s0 and such that no strategy ℜα′ with α′ < α

On the Strongly Bounded Turing Degrees of Simple Sets
|
71
requires attention after stage s0. Then ℜα is not initialized after stage s0 and ℜα
becomes active at any stage s + 1 > s0 at which it requires attention.
It follows that ℜα requires attention at most once after stage s0. Namely, if ℜα
requires attention at stage s1 +1 > s0 then ℜα becomes active at stage s1 +1. Since
ℜα is not initialized later, it follows that ℜα is satisﬁed at all stages s ≥s1 + 1. So
condition (ii) in the deﬁnition of requiring attention fails for s ≥s1 + 1, hence ℜα
does not require attention after stage s1 + 1.
It remains to show that requirement ℜe is met.
First observe that if ℜα becomes active at some stage s+1 and is not initialized
later then ℜe is met. Namely then, for some m ≥0, xα
m is enumerated into A at
stage s + 1 where ˜ΦBs
e,s(xα
m) = 0. Moreover, the only number which enters B at
stage s + 1, namely yα
m = xα
m + e + 1, is greater than the use of ˜ΦBs
e,s(xα
m) which is
bounded by xα
m + e. Hence
A(xα
m) = 1 ̸= 0 = ˜ΦBs
e,s(xα
m) = ˜ΦBs+1
e,s+1(xα
m).
(70)
Moreover, ℜα does not act later (since ℜα is not initialized after stage s hence per-
manently satisﬁed) and no strategy ℜβ with β < α acts later (since ℜα is not initial-
ized after stage s + 1). So only strategies ℜβ with α < β may act after stage s + 1.
But theses strategies ℜβ are initialized at stage s + 1 hence (by clause (iii)a in the
deﬁnition of requiring attention and by xβ
m < yβ
m) enumerate only numbers > s + 1
into (A and) B later. So B ↾s + 2 = Bs+1 ↾s + 2. Since, by our convention on use
functions, the use of ˜ΦBs+1
e,s+1(xα
m) = 0 is bounded by s + 1, it follows that
˜ΦB
e (xα
m) = ˜ΦBs+1
e,s+1(xα
m) = 0.
So A(xα
m) ̸= ˜ΦB
e (xα
m) by (70), hence ℜe is met.
Now, for a contradiction, assume that ℜe is not met, i.e., that A = ˜ΦB
e . Fix m0
such that, for m ≥m0,
xα
m > s0 & Iα
m ∩A = Iα
m ∩B = ∅& ˜ΦB
e (xα
m) = 0.
Note that such a number m0 exists by the assumption that A = ˜ΦB
e since ℜα re-
quires attention only ﬁnitely often, hence Iα
m ∩(A ∪B) ̸= ∅for at most ﬁnitely
many m. Since ℜα is not initialized after stage s0, it follows that for m ≥m0, the
conditions (iii)a, (iii)b and (iii)c in the deﬁnition of requiring attention hold at all
suﬃciently large stages s. On the other hand, since α is saturated by the True Path
Lemma, there are inﬁnitely many m such that (iii)d holds for all suﬃciently large
s. So (iii) holds for all suﬃciently large s.
Moreover, by the preceding observation, if ℜα becomes active at some stage
s + 1 then - by the assumption that ℜe is not met - ℜα is initialized later. Since

72
|
Klaus Ambos-Spies
ℜα is not initialized after stage s0, this implies that ℜα is not satisﬁed at any stage
s ≥s0, hence (ii) in the deﬁnition of requiring attention holds for s ≥s0.
So, summarizing, (ii) and (iii) hold for all suﬃciently large s. Since, by α ⊏f,
there are inﬁnitely many α-stages, it follows that ℜα requires attention inﬁnitely
often which gives the desired contradiction.
Claim 3. ˆℜe is met.
Proof. Fix e = ⟨e0, e1⟩. W.l.o.g. we may assume that ˆℜe is relevant, i.e., that
We0 is simple and We0 = ˆΦA
e1. We have to show that We0 is ibT-reducible to B.
Let α = f ↾e. Then, by the True Path Lemma, α0 ⊏f. So, in particular, there
are inﬁnitely many α0-stages. Moreover, by Claim 2, we may ﬁx a stage s0 such
that no strategy ℜβ with β ≤α0 becomes active after stage s0.
Now given x, in order to compute We0 ↾x+1 from B ↾x+1, proceed as follows.
Pick α0-stages s1 and s2 such that s2 > s1 > s0, s1 > x and Bs2 ↾x + 1 = B ↾x + 1.
We claim that We0,s2 ↾x + 1 = We0 ↾x + 1.
For a contradiction assume that a number x′ ≤x enters We0 after stage s2. Fix
the least such x′ and let s′+1 > s2 be the stage at which x′ is enumerated into We0.
Note that at stage s1 + 1 > x all strategies ℜβ with α0 <L β are initialized. So, by
choice of s0 and by s1 < s2, a number x′′ ≤x can enter A at a stage s′′ +1 ≥s2 +1
only if s′′ is an α0-stage and x′′ is the follower of a strategy ℜβ where α0 ⊏β.
Moreover, since s2 > s1 > x and s1 is an α0-stage, it follows that, for any α0-stage
s ≥s2, α0 is (s1 + 1)-saturated at stage s, hence, by α0-relevance of e, l(e, s) >
s1 > x.
Now in order to get the desired contradiction distinguish the following two
cases. First assume that As′+1 ↾x′ + 1 = As2 ↾x′ + 1. Then, by l(e, s2) > x ≥x′,
We0,s′+1(x′) ̸= We0,s2(x′) = ˆΦ
As2
e1,s2(x′) = ˆΦ
As′+1
e1,s′+1(x′)
hence l(e, s′ + 1) ≤x′ ≤x. Since, as observed above, at a stage s + 1 ≥s2 + 1
which is not an α0-stage no number ≤x can enter A and since l(e, s) > x at any
α0-stage s ≥s2, it follows that there is no α0-stage s ≥s′ + 1. A contradiction. So
we may assume that As′+1 ↾x′ + 1 ̸= As2 ↾x′ + 1 and we may ﬁx x′′ ≤x′ ≤x and
s′′ with s2 ≤s′′ ≤s′ such that x′′ enters A at stage s′′+1. Then, as observed above,
s′′ is α0-expansionary, l(e, s′′) > x ≥x′′ and x′′ is a follower xβ
m of some strategy
ℜβ where α0 ⊏β. So, by construction, Iβ
m = [xβ
m, yβ
m] ⊆We0,s′′ and yβ
m enters B at
stage s′′ + 1. By the latter and by choice of s2, yβ
m > x. So xβ
m = x′′ ≤x′ ≤x < yβ
m,
i.e., x′ ∈Iβ
m. It follows that x′ ∈We0,s′′ contrary to the assumption that x′ enters
We0 only at stage s′ + 1 > s′′.
This completes the proof of Claim 3 and the proof of the theorem.
Corollary 42. The class Sr of the simple r-degrees does not generate the class R+
r
of the nonzero c.e. r-degrees under join (r = ibT, cl).

On the Strongly Bounded Turing Degrees of Simple Sets
|
73
Proof. Fix c.e. sets A and B as in Theorem 41 and let a = degr(A) and b = degr(B).
Then b < a and Sr ∩Rr(≤a) ⊆Rr(≤b). So, for any ﬁnite sequence c0, . . . , cn of
simple degrees ≤a such that c0∨· · ·∨cn exists, c0, . . . , cn ≤b hence c0∨· · ·∨cn ≤
b < a. So a cannot be presented as the join of ﬁnitely many simple degrees.
We conclude our investigations of the simple r-degrees by proving the dual of
Corollary 42 for the meet operator.
Theorem 43. The class Sr of the simple r-degrees does not generate the class Rr of
the c.e. r-degrees under meet (r = ibT, cl). I.e., there is a c.e. set A such that, for any
n ≥0 and for any simple sets A0, . . . , An, either degr(A0) ∧· · · ∧degr(An) does
not exist or degr(A0) ∧· · · ∧degr(An) ̸= degr(A).
Note that, by Theorem 33, the degree 0 is the meet of two simple degrees. So, in
fact, Theorem 43 shows that the class Sr of the simple r-degrees does not generate
the class R+
r of the nonzero c.e. r-degrees under meet.
Proof of Theorem 43.. In order to simplify notation we only prove the binary case
n = 1 and leave the straightforward extension to the general case to the reader.
It suﬃces to enumerate a c.e. set A and auxiliary c.e. sets Ve, e ≥0, such that,
for any relevant e = ⟨e0, e1, e2, e3⟩≥0,
Ve ≤ibT We0, We1
(71)
holds and the requirements
ℜ⟨e,n⟩: Ve ̸= ˜ΦA
n
(n ≥0)
are met, where e is relevant if
∀i ≤1 (A = ˜Φ
Wei
e2+i & Wei is simple).
(72)
The strategy for meeting requirement ℜ⟨e,n⟩(for relevant e), which is similar to the
strategy for meeting the corresponding requirements ℜe in the proof of Theorem
41, is as follows. Let e = ⟨e0, e1, e2, e3⟩where we assume that e0, e1, e2, e3 ≤e.
We reserve a computable set of inﬁnitely many pairwise disjoint intervals I =
[x0, . . . , xe+n+1] of length e+n+2 for ℜ⟨e,n⟩. Then we ensure that Ve(x0) ̸= ˜ΦA
n (x0)
for the ﬁrst element of one of these intervals I. For this sake, we follow the stan-
dard Friedberg-Muchnik strategy. I.e., we wait for a stage s such that ˜ΦAs
n,s(x0) = 0
(if there is no such stage then ℜ⟨e,n⟩is trivially met since in this case x0 is not put
into Ve). Then we put x0 into Ve and preserve ˜ΦAs
n,s(x0) = 0 by restraining all num-
bers ≤x0 + n = xn from A. In order to make this compatible with (71), however,
we have to make sure that x0 entering Ve is permitted by Wei, i.e., that there is a

74
|
Klaus Ambos-Spies
number yi ≤x0 which enters Wei after stage s (for i = 0, 1). Now, assuming that e
is relevant, this can be achieved as follows. We put x0 into Ve at stage s + 1 only
if
I ⊆We0,s ∩We1,s
(73)
and if, for i = 0, 1,
As ↾xe+n+1 + 1 = ˜Φ
Wei ,s
e2+i,s ↾xe+n+1 + 1.
(74)
Note that, by relevance of e, there must be an interval I and a stage s with these
properties. Namely, since We0 and We1 are simple, it follows from the Simple Set
Lemma that, for some (in fact, inﬁnitely many) of the reserved intervals I, I ⊆
We0 ∩We1; and, by A = ˜Φ
Wei
e2+i, (74) holds for all I at all suﬃciently large stages
s. Now, if (73) and (74) hold and we put x0 into Ve then we simultaneously put
xn+1 into A. Note that the latter does not interfere with the restraint imposed on
A by the strategy. But, by (74) and (the ﬁrst part of) (72), it forces a number yi ≤
xn+1 + e2+i ≤xn+1 + e = xn+e+1 to enter Wei after stage s. In fact, by (73), this
number yi must be less than x0. Hence Ve ≤ibT Wei by permitting.
The formal construction is as follows.
Let {Im
k }m,k≥0 be a computable partition of ω into ﬁnite intervals where the
interval I⟨e,n⟩
k
= [x⟨e,n⟩
k,0 , . . . , x⟨e,n⟩
k,e+n+1] has length e + n + 2, and reserve the inter-
vals I⟨e,n⟩
k
, k ≥0, for the strategy meeting requirement ℜ⟨e,n⟩. Then stage s + 1 of
the construction is as follows where r(⟨e, n⟩, s) is the restraint imposed by ℜ⟨e,n⟩
at stage s and where A0 = Ve,0 = ∅and r(⟨e, n⟩, 0) = 0.
Stage s + 1 > 0. Requirement ℜ⟨e,n⟩requires attention at stage s+1 if ⟨e, n⟩< s
and r(⟨e, n⟩, s) = 0 and there is a number k ≥0 such that the following hold.
(i) I⟨e,n⟩
k
∩As = I⟨e,n⟩
k
∩Ve,s = ∅
(ii) I⟨e,n⟩
k
⊆We0,s ∩We1,s
(iii) As ↾x⟨e,n⟩
k,e+n+1 + 1 = ˜Φ
Wei ,s
e2+i,s ↾x⟨e,n⟩
k,e+n+1 + 1 for i = 0, 1
(iv) ˜ΦAs
n,s(x⟨e,n⟩
k,0 ) = 0
(v) max{r(m, s) : m < ⟨e, n⟩} < x⟨e,n⟩
k,0
And if ℜ⟨e,n⟩requires attention then say that ℜ⟨e,n⟩requires attention via k for
the least k such that (i)-(v) hold.
Then, for the least ⟨e, n⟩such that ℜ⟨e,n⟩requires attention, ℜ⟨e,n⟩becomes
active and for the unique k such that ℜ⟨e,n⟩requires attention via k, x⟨e,n⟩
k,0
is
put into Ve, x⟨e,n⟩
k,n+1 is put into A, and the restraint of ℜ⟨e,n⟩is set to r(⟨e, n⟩, s+
1) = x⟨e,n⟩
k,n . Moreover, for m < ⟨e, n⟩, r(m, s+1) = r(m, s) while, for m > ⟨e, n⟩,
r(m, s + 1) = 0.

On the Strongly Bounded Turing Degrees of Simple Sets
|
75
Finally, if no requirement requires attention then r(m, s + 1) = r(m, s) for all
m ≥0.
This completes the construction. By a straightforward induction on m, any require-
ment ℜm requires attention at most ﬁnitely often, hence lims→∞r(m, s) < ω exists.
Using these facts it easily follows by the above discussion of the strategy for meet-
ing the requirements that, for relevant e, the e-requirements ℜ⟨e,n⟩, n ≥0, are met
and condition (71) is satisﬁed.
12 Conclusion
We have analysed the degrees of the simple sets under the strongly bounded
Turing reducibilities r = ibT, cl. First we have shown, that a c.e. set A is ibT-
equivalent to a simple set if and only if A is cl-equivalent to a simple set (Coinci-
dence Theorem; Theorem 8) and that there is a noncomputable c.e. set A which is
not ibT-equivalent (hence not cl-equivalent) to any simple set (Theorem 10). We
have also shown that the latter observation does not extend to weaker reducibil-
ities like the linearly bounded Turing reducibility. Namely, any noncomputable
c.e. set A is lbT-equivalent to a simple set (Corollary 31).
Then we had a closer look at the distribution of the simple r-degrees and the
nonsimple c.e. r-degrees among all c.e. r-degrees. It turned out that, both, the
partial ordering of the simple r-degrees, (Sr, ≤), and the complementary class of
the nonsimple c.e. r-degrees, (Sr, ≤), are quite scattered in the partial ordering of
the c.e. r-degrees, (Rr, ≤).
So, for instance, for any c.e. r-degree a > 0 there are degrees b, c, d ∈Sr such
that b is below a (Theorem 28), c is above a (Theorem 29) and d is incomparable
with a (Theorem 34). For the class of the nonsimple c.e. r-degrees the correspond-
ing results hold with one notable exception: for any c.e. r-degree a > 0 there are
degrees b, d ∈Sr such that b ̸= 0 and b is below a (Theorem 17), and d is incom-
parable with a (Theorem 24). Moreover, if a is not the degree of a wtt-complete set,
then there is a degree c ∈Sr such that c is above a (Theorem 18). Here, however,
this additional hypothesis is necessary, since the r-degree of any wtt-complete set
is simple (Theorem 36).
Moreover, neither Sr nor Sr is dense in (Rr, ≤) - to be more precise, there are
inﬁnite intervals in (Rr, ≤) which are entirely contained in Sr (Corollary 39) and
there are inﬁnite intervals in (Rr, ≤) which are entirely contained in Sr (Corollary
14) - and the classes Sr and Sr lack the most basic closure properties. Namely, Sr
is neither closed under join (Corollary 22) nor closed under meet (Theorem 25). In

76
|
Klaus Ambos-Spies
case of the simple degrees we have only shown that Sr is not closed under meet
(Corollary 35), but Kräling recently closed this gap by showing that Sr is not closed
under join too.
Finally, we shed some light on the question how common the simple and non-
simple r-degrees are by answering the question whether these degree classes gen-
erate all c.e. r-degrees under join or meet. In case of the nonsimple degrees, Sr
generates Rr under join (Corollary 21) but not under meet (Corollary 38) while, in
case of the simple degrees, Sr generates R+
r neither under join (Corollary 42) nor
under meet (Theorem 43).
It is an interesting open problem whether the fact that an r-degree contains
a simple set is reﬂected by its ordering properties, i.e., whether the class Sr of the
simple r-degrees is deﬁnable in the partial ordering (Rr, ≤).
Open Problem 44. Is there a ﬁrst order formula φ(x) in the language of partial
orderings such that Sr = {a : (Rr, ≤) ⊨φ(a/x)}?
Finally, we come back to what we started with, Post’s Problem and Post’s Program.
For what reducibilities ρ do simple sets help to solve Post’s Problem, i.e., allow us
to show that there are at least two nonzero c.e ρ-degrees?
As pointed out in the introduction already, Post himself gave a positive answer
for ρ = m and even ρ = btt along the lines of his program: He established the ex-
istence of simple sets and showed that no simple set is btt-complete. Post also
showed, however, that, by his approach, simple sets do not solve Post’s Problem
for tt-reducibility since there are tt-complete simple sets. For tt-reducibility, how-
ever, simple sets provide a solution to Post’s Problem in the sense of Generalized
Post Program (as deﬁned in the introduction), i.e., there are noncomputable c.e.
sets A and B such that the tt-degree of A contains a simple set (i.e., Stt(degtt(A))
holds) while the tt-degree of B does not contain any simple set (i.e., Stt(degtt(B))
fails).
In the same sense, we obtain a solution for Post’s Problem for the strongly
bounded Turing reducibilities ρ = ibT and ρ = cl by Theorem 10 and Corollary 11,
respectively, in this paper. Even by this generalized approach, however, simplicity
does not help to solve Post’s Problem for ρ = lbT, hence for ρ = wtt or ρ = T.
Namely, by Corollary 31, SlbT(a) holds for any nonzero c.e. lbT-degree a (hence
Swtt(a) and ST(a) hold for any nonzero c.e. wtt- respectively T-degree a).
By some of the other results in this paper, however, we can further generalize
Post’s Program in order to get a solution of Post’s Problem for ρ = wtt in terms
of simple sets. Namely, given a reducibility ρ and a stronger reducibility ρ′, we
replace the property that the ρ-degree a contains a simple set, i.e., Sρ(a), by the

On the Strongly Bounded Turing Degrees of Simple Sets
|
77
stronger property that every c.e. ρ′-degree inside a contains a simple sets, i.e.,
Sρ′
ρ (a) ⇔∀c.e. A ∈a [Sρ′(degρ′(A))].
Then, by the existence of nonzero c.e. ibT-degrees which do not contain any sim-
ple set (Theorem 10) it follows that there is a c.e. wtt-degree a > 0 such that SibT
wtt(a)
fails, whereas, by Theorem 36, SibT
wtt(0′
wtt) holds for the wtt-complete degree 0′
wtt.
We do not know, however, whether we can get a solution to the original ver-
sion of Post’s Problem, i.e., to Post’s Problem for Turing reducibility, in terms of
simple sets in this way. A positive answer would be quite remarkable by showing
that Post’s simple set property indeed helps to establish the existence of noncom-
putable Turing-incomplete sets, though the way this property has to be used had
to be much more technical than proposed by Post’s Program. In order to show
that this is indeed possible it suﬃces to give an aﬃrmative answer to the follow-
ing question.
Open Problem 45. Is there a c.e. set A such that SibT
T (degT(A)) holds, i.e., such
that any c.e. set B which is Turing equivalent to A is ibT-equivalent to a simple set?
Note that, by Corollary 19, there is a Turing complete set which has nonsimple
ibT-degree. So in contrast to the case of weak truth-table reducibility, complete
sets do not provide a positive answer to Open Problem 45. In fact, by Theorem 16,
for any set A such that SibT
T (degT(A)) holds (if any), degT(A) must be contiguous,
i.e., degT(A) can contain only one c.e. wtt-degree. (The existence of contiguous
degrees > 0 is shown in [13].)
Bibliography
[1]
K. Ambos-Spies. Cupping and noncapping in the r.e. weak truth-table and Turing degrees.
Arch. Math. Logik Grundlag., 25:109–126, 1985.
[2]
K. Ambos-Spies. On the Strongly Bounded Turing Degrees of the Computably Enumerable
Sets. To appear.
[3]
K. Ambos-Spies, D. Ding, Y. Fan and W. Merkle. Maximal pairs of computably enumerable
sets in the computably Lipschitz degrees. Theory of Computing Systems, 52:2–27, 2013.
[4]
K. Ambos-Spies, C. G. Jockusch, R. A. Shore and R.I. Soare. An algebraic decomposition of
the recursively enumerable degrees and the coincidence of several degree classes with
the promptly simple degrees. Trans. Amer. Math. Soc., 281:109–128, 1984.
[5]
G. Barmpalias. Computably enumerable sets in the Solovay and the strong weak truth
table degrees. In: Computability in Europe, Amsterdam, 2005. Lecture Notes in Comput.
Sci., vol. 3526, pp. 8–17. Springer, Berlin, 2005.
[6]
G. Barmpalias and A.E.M. Lewis. The ibT degrees of computably enumerable sets are not
dense. Ann. Pure Appl. Logic, 141:51–60, 2006.

78
|
Klaus Ambos-Spies
[7]
A.R. Day. The computable Lipschitz degrees of computably enumerable sets are not
dense. Ann. Pure Appl. Logic, 161:1588–1602, 2010.
[8]
R.G. Downey, D.R. Hirschfeldt, G. LaForte. Randomness and reducibility. J. Comput. Sys-
tem Sci., 68:96–114, 2004.
[9]
R.G. Downey and D.R. Hirschfeldt. Algorithmic randomness and complexity. Theory and
Applications of Computability. Springer, New York, 2010.
[10] Y. Fan and H. Lu. Some properties of sw-reducibility. Journal of Nanjing University (Mathe-
matical Biquarterly), 22:244–252, 2005.
[11]
L. Harrington and R.I. Soare. Post’s program and incomplete recursively enumerable sets.
Proc. Nat. Acad. Sci. U.S.A., 88:10242–10246, 1991.
[12] C. G. Jockusch. Three easy constructions of recursively enumerable sets. In: Logic Year
1979– 80, Proc. Seminars and Conf. Math. Logic, Univ. Connecticut, Storrs, CT, 1979/80.
Lecture Notes in Math., vol. 859, pp. 83–91. Springer, Berlin, 1981.
[13] R.E. Ladner and P. Sasso. The weak truth table degrees of recursively enumerable sets.
Ann. Math. Logic, 8:429–448, 1975.
[14] P. Odifreddi. Classical recursion theory. The theory of functions and sets of natural num-
bers. With a foreword by G. E. Sacks. Studies in Logic and the Foundations of Mathemat-
ics, 125. North-Holland Publishing Co., Amsterdam, 1989.
[15]
E. L. Post. Recursively enumerable sets of positive integers and their decision problems.
Bull. Amer. Math. Soc., 50:284–316, 1944.
[16] R.I. Soare. Recursively enumerable sets and degrees. A study of computable functions
and computably generated sets. Perspectives in Mathematical Logic. Springer-Verlag,
Berlin, 1987.
[17]
R.I. Soare. Computability theory and diﬀerential geometry. Bull. Symbolic Logic, 10:457–
486, 2004.
[18] M. Stob. wtt-degrees and T-degrees of r.e. sets. J. Symbolic Logic, 48:921–930, 1983.

Matthew de Brecht
Levels of Discontinuity, Limit-Computability,
and Jump Operators¹
Abstract: We develop a general theory of jump operators, which is intended to pro-
vide an abstraction of the notion of “limit-computability” on represented spaces.
Jump operators also provide a framework with a strong categorical ﬂavor for
investigating degrees of discontinuity of functions and hierarchies of sets on rep-
resented spaces. We will provide a thorough investigation within this framework
of a hierarchy of ∆0
2-measurable functions between arbitrary countably based
T0-spaces, which captures the notion of computing with ordinal mind-change
bounds. Our abstract approach not only raises new questions but also sheds
new light on previous results. For example, we introduce a notion of “higher or-
der” descriptive set theoretical objects, we generalize a recent characterization
of the computability theoretic notion of “lowness” in terms of adjoint functors,
and we show that our framework encompasses ordinal quantiﬁcations of the
non-constructiveness of Hilbert’s ﬁnite basis theorem.
Keywords: Borel complexity, computable analysis, descriptive set theory, category
theory
Mathematics Subject Classiﬁcation 2010: 54H05, 26A21, 03D30, 03F60, 03G30
||
Matthew de Brecht: National Institute of Information and Communications Technology, Center
for Neural Systems and Information Networks, Osaka, Japan
1 Introduction
This paper is concerned with two relatively new developments in the ﬁeld of de-
scriptive set theory.
The ﬁrst development is the extension of the classical descriptive set theory
for metrizable spaces to more general topological spaces and mathematical struc-
tures. Although it is not uncommon, particularly in measure theory, to deﬁne the
1 This paper is dedicated to Victor Selivanov in celebration of his 60th birthday and his valuable
contributions to the descriptive set theory of general topological spaces. The author thanks Arno
Pauly, Luca Motto Ros, Vasco Brattka, and Takayuki Kihara for valuable discussions and comments
on earlier drafts of this paper.

80
|
Matthew de Brecht
Borel algebra for an arbitrary topological space, detailed analysis of the Borel
hierarchy has been mainly restricted to the class of metrizable spaces, or possi-
bly Hausdorﬀspaces on rare occasion. However, relatively recent work by V. Se-
livanov [37; 35; 36; 38; 39], D. Scott [34], A. Tang [45; 46], and the author [11;
12], have demonstrated that a signiﬁcant portion of the descriptive set theory of
metrizable spaces generalizes naturally to countably based T0-spaces. This devel-
opment opens up the possibility of ﬁnding new applications of descriptive set the-
ory to mathematical ﬁelds heavily relying on non-Hausdorﬀtopological spaces,
such as theoretical computer science (e.g., ω-continuous domains) and modern
algebraic geometry (e.g., the Zarisiki topology on the prime spectrum of a count-
able commutative ring). These generalizations can also shed new light on old re-
sults. For example, although the Gandy-Harrington space (a non-metrizable space
that plays an important role in eﬀective descriptive set theory) cannot be topolog-
ically embedded into any Polish space, it can be embedded as a co-analytic set
into a quasi-Polish space [11].
The second development is a shift from a focus on the complexity of subsets
of a space to a focus on the complexity of functions between spaces. Certainly
Baire’s hierarchy of discontinuous functions has a long history, but it is fair to say
that Borel’s hierarchy of sets has played a more prominent role in the develop-
ment of the theory. However, recently there has been growing interest within the
ﬁeld of computable analysis concerning the relationship between hierarchies of
discontinuous functions, Turing degrees, and limit-computability, in particular by
researchers such as V. Brattka, P. Hertling, A. Pauly, M. Ziegler, T. Kihara, and the
author [6; 10; 20; 7; 48; 25; 12]. Furthermore, recent extensions of the Wadge game
by researchers such as A. Andretta, L. Motto Ros, and B. Semmes [2; 29; 27; 28; 40]
have provided new classiﬁcations of discontinuous functions and new methods
to generalize classical results like the Jayne-Rogers theorem [22]. V. Selivanov has
made contributions in this area as well, for example by generalizing the Hausdorﬀ-
Kuratowski theorem for the diﬀerence hierarchy to a hierarchy of ∆0
2-measurable
functions into ﬁnite discrete spaces [38; 39].
These two developments should not be considered independent. For exam-
ple, if we simply add to our framework the two-point non-trivial non-metrizable
space S, known as the Sierpinski space, then we can obtain an elegant bijective
correspondence between the family of Σ0
α-subsets of a space X and the family of
Σ0
α-measurable functions from X to S. This is a natural generalization of the known
bijection between open subsets of a space and continuous functions into the Sier-
pinski space, and is also similar to the role of the subobject classiﬁer in a topos.
Domain theory teaches us that the mathematical object Σ0
α(X), now viewed as a
family of functions into S, will certainly not be metrizable, even if we can hope for
it to be a topological space at all.

Levels of Discontinuity and Jump Operators
|
81
Continuing a little more our analogy with a topos, if we wish to work within a
single category then we are faced with a dilemma if we have only one “sub-object”
classiﬁer S but want a hierarchy of classes of subobjects such as Σ0
1(X) ⊆Σ0
2(X) ⊆
· · · . One natural solution is to abandon the idea of having a single subobject clas-
siﬁer, and instead have a sequence S1, S2, . . . of subobject classiﬁers that respec-
tively classiﬁy the families Σ0
1, Σ0
2, . . .. Such a theory would be very unwieldy if
the subobject classiﬁers were all unrelated, but we might have some hope for the
theory if the subobject classiﬁers S1, S2, . . . are deﬁned as the iterates of a sin-
gle endofunctor F applied to a single subobject classiﬁer S. We now only have to
worry about which functors F to consider, and what the “base” subobject classiﬁer
S should be.
This abstract view is closely related to recent work initiated by A. Pauly on
synthetic descriptive set theory [31; 32]. Ultimately, an axiomatic approach in the
same spirit as topos theory would be most desireable, as it might help expose con-
nections between the descriptive set theory of general topological spaces and the
descriptive complexity of ﬁnite structures [1]. However, it seems a little premature
to attempt that now, and instead we develop these ideas within the category of
represented spaces and continuously realizable functions [4]. In this context, we
introduce (topological) “jump operators”, which modulate the representation of
a space and in eﬀect play the role of the endofunctors F described above.
The concept of a jump operator that we present here has its roots in the work
of M. Ziegler [48] and V. Brattka [6; 10], where numerous connections are made
between levels of discontinuity, limit-computability, and the representation of a
function’s output space. The hierarchy of discontinuity that jump operators char-
acterize turns out to be a subset of the strong Weihrauch degrees [9; 8], but we
believe that the categorical framework that jump operators provide has much to
oﬀer.
This paper is organized into ﬁve major sections. After this Introduction, we
will develop the general theory of (topological) jump operators. The third major
section will investigate a lower portion of the jump operator hierarchy consisting
of ∆0
2-measurable functions. Our main contribution here is to extend some previ-
ous results concerning functions between metrizable spaces to functions between
arbitrary countably based T0-spaces. The results in this section are also important
because they demonstrate that the jump operator framework is powerful enough
to characterize functions as ﬁnely as P. Hertling’s hierarchy of discontinuity lev-
els [21; 20]. The fourth major section presents several examples and applications,
such as connections with the diﬀerence hierarchy, a quantiﬁcation of the non-
constructiveness of Hilbert’s basis theorem in terms of the ordinal ωω (essentially
due to S. Simpson [41] and F. Stephan and Y. Ventson [44]), and show some ap-
plications to the Jayne-Rogers theorem. It is our attempt to ﬁnd a common thread

82
|
Matthew de Brecht
between the results in this section that should be considered new, more so than
the results themselves, so in several cases we omit proofs. We conclude in the ﬁfth
major section.
We will expect that the reader is familiar with classical descriptive set theory
[24] and domain theory [17]. The reader should also consult [37] and [11] for def-
initions and results concerning the descriptive set theory of arbitrary countably
based T0-spaces. Although we will not be concerned much with computability is-
sues, the reader will beneﬁt from an understanding of the Type Two Theory of
Eﬀectivity [47]. In particular, we will make much use of M. Schröder’s extended
deﬁnition of an admissible representation [33], as well as the notion of realizabil-
ity of functions between represented spaces (see [4]).
Our notation will follow that of [11]. The following modiﬁcation of the Borel
hierarchy, due to V. Selivanov, is required in order to provide a meaningful classi-
ﬁcation of the Borel subsets of non-metrizable spaces.
Deﬁnition 1. Let X be a topological space. For each ordinal α (1 ≤α < ω1) we
deﬁne Σ0
α(X) inductively as follows.
1. Σ0
1(X) is the set of all open subsets of X.
2. For α > 1, Σ0
α(X) is the set of all subsets A of X which can be expressed in the
form
A =

i∈ω
Bi \ B′
i,
where for each i, Bi and B′
i are in Σ0
βi(X) for some βi < α.
We deﬁne Π0
α(X) = {X \ A | A ∈Σ0
α(X)} and ∆0
α(X) = Σ0
α(X) ∩Π0
α(X).
The above deﬁnition is equivalent to the classical deﬁnition of the Borel hierarchy
for metrizable spaces, but it diﬀers for more general spaces.
A function f : X →Y is Σ0
α-measurable if and only if f −1(U) ∈Σ0
α(X) for every
open subset U of Y. We will also be interested in ∆0
2-measurability, which requires
the preimage of every open set to be a ∆0
2-set.
Later in the paper we will present some results speciﬁc to quasi-Polish spaces,
which are deﬁned as the countably based spaces that admit a Smyth-complete
quasi-metric. Polish spaces and ω-continuous domains are examples of quasi-
Polish spaces. A space is quasi-Polish if and only if it is homeomorphic to a Π0
2-
subset of P(ω), the power set of ω with the Scott-topology. The reader should con-
sult [11] for additional results on quasi-Polish spaces.

Levels of Discontinuity and Jump Operators
|
83
2 Jump operators
A represented space is a pair ⟨X, ρ⟩where X is a set and ρ: ⊆ωω →X is a surjec-
tive partial function. If ⟨X, ρX⟩and ⟨Y, ρY⟩are represented spaces and f : ⊆X →
Y is a partial function, then a function F : ⊆ωω →ωω realizes f, denoted F ⊢f,
if and only if f ◦ρX = ρY ◦F. If there exists a continuous realizer for f then we say
that f is continuously realizable and write ⊢f. Note that if F ⊢f and G ⊢g, then
G ◦F ⊢g ◦f, assuming the composition g ◦f makes sense.
In some cases, a function f : X →Y between represented spaces may fail to be
continuously realizable, but will become continuously realizable if we strengthen
the information content of the representation of X or weaken the information con-
tent of the representation of Y. The notion of “limit computability” is a common
example of weakening the output representation. The motivation for the follow-
ing deﬁnition is to create an abstract framework to investigate in a uniform man-
ner how modiﬁcations of the information content of a representation eﬀects the
realizability of functions.
Deﬁnition 2. A (topological) jump operator is a partial surjective function j: ⊆
ωω →ωω such that for every partial continuous F : ⊆ωω →ωω, there is partial
continuous F′ : ⊆ωω →ωω such that F ◦j = j ◦F′.
The identity function id: ωω →ωω is a trivial example of a jump operator. Let
f : X →Y be a function between represented spaces. A j-realizer of f is a function
F : ⊆ωω →ωω such that j ◦F ⊢f. We use the notation F ⊢j f to denote that F is
a j-realizer for f. If there exists a continuous j-realizer for f then we will say that f
is j-realizable and write ⊢j f.
The deﬁnition of “jump operator” given above is appropriate for the category
of represented spaces and continuously realizable functions. Given a represented
space ⟨X, ρX⟩and a jump operator j, we can write j(X) to denote the represented
space ⟨X, ρX ◦j⟩. For each function f : X →Y between represented spaces, we
deﬁne j(f) to be the same function as f but now interpretted as being between the
represented spaces j(X) and j(Y). It is now clear that the deﬁnition of a jump oper-
ator is precisely what is needed to guarantee that j(·) is a well-deﬁned endofunctor
on the category of represented spaces.
If working in the category of represented spaces and computably realizable
functions, then the appropriate deﬁnition of a (computability theoretic) jump op-
erator would be to require that for every computable F : ⊆ωω →ωω, there is com-
putable F′ : ⊆ωω →ωω such that F ◦j = j ◦F′. The deﬁnition of j-realizability
would also be modiﬁed in a similar manner. These modiﬁcations are necessary

84
|
Matthew de Brecht
because, for example, the operator L introduced in [7] to characterize low com-
putability is a computability theoretic jump operator but it is not a topological
jump operator.
In this paper, unless explicitly mentioned otherwise we will assume the topo-
logical jump operator deﬁnition given above and shall drop the term “topological”.
However, much of the theory we develop will also apply to the computability the-
oretic jump operators as well.
Examples 3, 4, and 5 below provide typical examples of jump operators. In
the following, ⟨· · · ⟩n∈ω : (ωω)ω →ωω is some ﬁxed (computable) encoding of
countable sequences of elements of ωω as single elements of ωω.
Example 3. Deﬁne jΣ0
2 : ⊆ωω →ωω as:
⟨ξn⟩n∈ω ∈dom(jΣ0
2)
⇔
ξ0, ξ1, . . . converges in ωω
jΣ0
2(⟨ξn⟩n∈ω)
=
lim
n∈ω ξn
Example 4. Deﬁne j∆: ⊆ωω →ωω as:
⟨ξn⟩n∈ω ∈dom(j∆)
⇔
(∃n)(∀m ≥n)[ξm = ξn]
j∆(⟨ξn⟩n∈ω)
=
lim
n∈ω ξn
Example 5. For each countable ordinal α, deﬁne jα : ⊆ωω →ωω as:
⟨⟨βn⟩α ⋄ξn⟩n∈ω ∈dom(jα)
⇔
(∀n)(α > βn ≥βn+1) and
(∀n)(ξn ̸= ξn+1 ⇒βn ̸= βn+1)
jα(⟨⟨βn⟩α ⋄ξn⟩n∈ω)
=
lim
n∈ω ξn
where ⟨·⟩α : α →ω is some ﬁxed encoding of ordinals less than α as natural numbers,
and ⟨β⟩α ⋄ξ is the element of ωω obtained by prepending the encoding of β to the
beginning of ξ.
The jump operators jΣ0
2 and j∆are also computability theoretic jump operators.
If α < ωCK
1
then jα is a computability theoretic jump operator assuming that the
encoding ⟨·⟩α is eﬀective.
Intuitively, jΣ0
2-realizing a function only requires the realizer to output a se-
quence of “guesses” which is guaranteed to converge to the correct answer. Each
guess is an inﬁnite sequence in ωω, and convergence means that each ﬁnite preﬁx
of the guess can be modiﬁed only a ﬁnite number of times. The jump operator jΣ0
2
and its connections with limit computability have been extensively studied in the
ﬁeld of computable analysis, for example by V. Brattka [6; 10] and M. Ziegler [48].

Levels of Discontinuity and Jump Operators
|
85
In the context of Wadge-like games and reducibilities, the jump operator jΣ0
2 essen-
tially captures the notion of an “eraser” game (see [27; 28; 40] and the references
therein). It can also be shown that jΣ0
2 is a Σ0
2-admissible representation of ωω in
the sense of [12]. It follows from these results that if X and Y are countably based
T0-spaces, then f : X →Y is jΣ0
2-realizable if and only if f is Σ0
2-measurable. In gen-
eral, for any ordinal α < ω1, any Σ0
α-admissible representation jΣ0
α of ωω will be
a jump operator which precisely captures the Σ0
α-measurable functions between
countably based spaces. For ﬁnite n > 2 the inductive deﬁnition jΣ0
n+1 = jΣ0
n ◦jΣ0
2
suﬃces.
The jump operator j∆deﬁnes a stricter notion of limit computability. In this
case, the realizer is also allowed to output guesses that converge to the correct an-
swer, but the realizer can only modify his guess a ﬁnite number of times. This
jump operator has been investigated by M. Ziegler [48] in terms of ﬁnite revis-
ing computation, and was shown in [7] by V. Brattka, A. Pauly, and the author
to correspond to closed choice on the natural numbers. In the context of Wadge-
like games, j∆corresponds to the “backtrack” game (see [40]). A. Andretta [2] has
shown that a total function on ωω is j∆-realizable if and only if it is ∆0
2-piecewise
continuous. It follows from the Jayne-Rogers theorem ([22], see also [29; 23; 43;
25]) that a total function on ωω is j∆-realizable if and only if it is ∆0
2-measurable.
However, it should be noted that this relationship between j∆-realizability and ∆0
2-
measurability does not extend to functions between arbitrary spaces, and in fact
we will show in the latter half of this paper that there is no jump operator that
completely captures the notion of ∆0
2-measurability.
The family of jump operators jα for α < ω1 are further restrictions of j∆, where
the realizer must output with each guess an ordinal bound on the number of times
it will change its guess in the future. For example, when 1 ≤n < ω, a jn-realizer
can only make a maximum of n guesses. A jω-realizer must output a bound n < ω
along with its ﬁrst guess, and then can only modify its guess a maximum of n
times thereafter. This concept is closely related to the Ershov hierarchy [15], to the
notion of ordinal mind change complexity in the ﬁeld of inductive inference (see
[16; 26; 13; 14]), and to the Hausdorﬀdiﬀerence hierarchy [24]. We will show later
in this paper that a function between countably based T0-spaces is jα-realizable
if and only if the discontinuity level of the function (in the sense of P. Hertling
[21; 20]) does not exceed α.
2.1 Lattice structure
Jump operators are (quasi-)ordered by j ≤k if and only if j is k-realizable. We will
say j and k are equivalent, written j ≡k, if j ≤k and k ≤j. In the examples given

86
|
Matthew de Brecht
previously, it is clear that jα ≤jβ ≤j∆≤jΣ0
2 when α ≤β < ω1. It is straightfor-
ward to prove that if j ≤k, then ⊢j f implies ⊢k f for every function f between
represented spaces.
In this section we will prove that the topological jump operators form a lattice
which is complete under countable (non-empty) meets and joins. The deﬁnitions
and main points of the proofs in this section are mostly due to A. Pauly [30]. The
author is indebted to A. Pauly for pointing out that the proofs in this section only
apply to topological jump operators and may fail to hold for computability theo-
retic jump operators in general.
In the following, given i ∈ω and ξ ∈ωω, we will write ⟨i⟩⋄ξ to denote the
element of ωω obtained by prepending i to the beginning of ξ.
Deﬁnition 6. Let (ji)i∈ω be a countable sequence of jump operators. Deﬁne
 ji : ⊆ωω →ωω and  ji : ⊆ωω →ωω by
1. ( ji)(⟨i⟩⋄ξ) = ji(ξ), where
dom(

ji) = {⟨i⟩⋄ξ ∈ωω | ξ ∈dom(ji)}.
2. ( ji)(⟨ξn⟩n∈ω) = j0(ξ0), where
dom(

ji) = {⟨ξn⟩n∈ω ∈ωω | ∀i, k: ji(ξi) = jk(ξk)}.
The next two theorems show that the above deﬁnitions are in fact (topological)
jump operators corresponding to the supremum and inﬁmum of (ji)i∈ω.
Theorem 7.  ji is a jump-operator and is the supremum of (ji)i∈ω.
Proof. Assume f : ⊆ωω →ωω is continuous. For i ∈ω there is continuous gi : ⊆
ωω →ωω such that f ◦ji = ji ◦gi. Deﬁne g: ⊆ωω →ωω as g(⟨i⟩⋄ξ) = ⟨i⟩⋄gi(ξ).
Clearly g is continuous and
f((

ji)(⟨i⟩⋄ξ))
=
f(ji(ξ))
=
ji(gi(ξ))
=
(

ji)(⟨i⟩⋄gi(ξ))
=
(

ji)(g(⟨i⟩⋄ξ)),
hence f ◦ ji =  ji ◦g. Therefore  ji is a jump operator.
Next, for i ∈ω deﬁne fi(ξ) = ⟨i⟩⋄ξ. Then fi is continuous and ji = ( ji) ◦fi.
Therefore ji ≤ ji for all i ∈ω.
Finally, assume p: ωω →ωω is such that ji = p ◦qi for some continuous
qi : ωω →ωω (for all i ∈ω). Deﬁne q: ωω →ωω so that q(⟨i⟩⋄ξ) = qi(ξ). Then

Levels of Discontinuity and Jump Operators
|
87
q is continuous and
(

ji)(⟨i⟩⋄ξ)
=
ji(ξ)
=
p(qi(ξ))
=
p(q(⟨i⟩⋄ξ))
hence  ji = p ◦q. Therefore  ji ≤p. It follows that  ji is the supremum of
(ji)i∈ω.
Theorem 8.  ji is a jump-operator and is the inﬁmum of (ji)i∈ω.
Proof. Assume f :
⊆ωω →ωω is continuous. For i ∈ω there is continuous
gi : ⊆ωω →ωω such that f ◦ji = ji ◦gi. Deﬁne g: ⊆ωω →ωω as
g(⟨ξn⟩n∈ω) = ⟨gn(ξn)⟩n∈ω.
Clearly g is continuous and if ⟨ξn⟩n∈ω ∈dom( ji) then for all i, k ∈ω, ji(ξi) =
jk(ξk) hence ji ◦gi(ξi) = f ◦ji(ξi) = f ◦jk(ξk) = jk ◦gk(ξk), and it follows that
⟨gn(ξn)⟩n∈ω ∈dom( ji). So for ⟨ξn⟩n∈ω ∈dom( ji) we have
f((

ji)(⟨ξn⟩n∈ω))
=
f(j0(ξ0))
=
j0(g0(ξ0))
=
(

ji)(⟨gn(ξn)⟩n∈ω),
hence f ◦ ji =  ji ◦g. Therefore  ji is a jump operator.
Next, deﬁne πi(⟨ξn⟩n ∈ω) = ξi, which is clearly continuous. Then
(

ji)(⟨ξn⟩n∈ω)
=
j0(ξ0)
=
ji(ξi)
=
ji(πi(⟨ξn⟩n∈ω)),
hence  ji ≤ji for all i ∈ω.
Assume p: ωω →ωω is such that p = ji ◦qi for some continuous qi : ωω →
ωω (for all i ∈ω). Deﬁne q: ωω →ωω so that q(ξ) = ⟨qn(ξ)⟩n∈ω. Clearly q is
continuous. If ξ ∈dom(q) then p(ξ) = ji(qi(ξ)) for all i ∈ω, so ⟨qn(ξ)⟩n∈ω ∈
dom( ji) and
p(ξ)
=
j0(q0(ξ))
=
(

ji)(⟨qn(ξ)⟩n∈ω)
=
(

ji)(q(ξ)),
hence p ≤ ji. It follows that  ji is the inﬁmum of (ji)i∈ω.
For example, let (jαi)i∈ω be a sequence of jump operators from Example 5. Then it
is straightforward to verify that  jαi = j αi and  jαi = j αi.

88
|
Matthew de Brecht
2.2 The “jump” of a representation
Let J be the lattice of jump operators. It is easy to show that if j and k are jump
operators, then so is j ◦k. Furthermore, if j1 ≤j2, then j1 ◦k ≤j2 ◦k. Thus, every
jump operator k deﬁnes a monotonic function on J, which we call the k-jump, that
maps j to j ◦k. This notion of iterating “jumps” can be found in [48] and [10] for
the case of jΣ0
2.
A jump operator j is extensive if the identity function id: ωω →ωω is j-
realizable. Currently the author is unaware of any topological jump operators
that are not extensive, but the non-extensive computability theoretic jump opera-
tors have a non-trivial structure (for example, the inverse of the Turing jump, or
integral, in [10] and [7] is non-extensive).
A jump operator j is idempotent if j◦j ≡j. The jump operator j∆is idempotent,
but jΣ0
2 is not.
We will say that j-realizability is closed under compositions if for every pair of
j-realizable functions f : X →Y and g: Y →Z we have that g◦f is also j-realizable.
Theorem 9. If j is an extensive jump operator, then j-realizability is closed under
composition if and only if j is idempotent.
Proof. Assume j is extensive and closed under compositions. Clearly, j is j-
realizable, so j ◦j must be j-realizable, hence j ◦j ≤j. On the other hand, since
id ≤j it follows by the monotonicity of the j-jump that j ≤j ◦j. Therefore, j ◦j ≡j.
For the converse, assume j is extensive and idempotent, and assume F ⊢j f
and G ⊢j g and the composition g ◦f is possible. Then j ◦F ⊢f and j ◦G ⊢g, and
composition gives j◦G◦j◦F ⊢g◦f. Since j is a jump operator, there is continuous
G′ such that j ◦j ◦G′ ◦F ⊢g ◦f. Now using the idempotent property of j we obtain
G′ ◦F ⊢j g ◦f.
Recall that a closure operator on a partially ordered set is a function which is
monotonic, extensive, and idempotent. The above theorem can be reworded as
follows.
Corollary 10. If j is an extensive jump operator, then j-realizability is closed under
composition if and only if the j-jump is a closure operator on J.
It is easy to see that if the j-jump is a closure operator on J, then j is the least ﬁxed
point of the j-jump above id. In particular, the j∆-jump of jα is equivalent to j∆for
each α < ω1. It turns out that jΣ0
α is a ﬁxed point of the j∆-jump for each α < ω1
because jΣ0
α ◦j∆is Σ0
α-measurable.

Levels of Discontinuity and Jump Operators
|
89
2.3 Strong Weihrauch Degrees
Inthis section we will compare jump operators with the notion of strong Weihrauch
reducibility (see [9; 8; 30; 7] for more on Weihrauch reducibility). We only consider
the topological version of reducibility for the case of single valued functions.
Deﬁnition 11. Let f : X →Y and g: W →Z be functions between represented
spaces. Deﬁne f ≤sW g if and only if there are continuous functions K, H :
⊆
ωω →ωω satisfying K ◦G ◦H ⊢f whenever G ⊢g.
Theorem 12. Let f : X →Y be a function between represented spaces, and let j be
a jump operator. Then f ≤sW j if and only if f is j-realizable.
Proof. Assume f ≤sW j and let K and H be the relevant continuous functions.
Since ωω is represented by the identity function, it follows that K ◦j ◦H ⊢f. Using
the fact that j is a jump operator, there is continuous K′ : ⊆ωω →ωω such that
j ◦K′ ◦H ⊢f. Therefore, the continuous function K′ ◦H j-realizes f.
For the converse, assume F : ωω →ωω is a continuous j-realizer of f. Then
j ◦F ⊢f by deﬁnition. Again, since ωω is represented by the identity function we
have J ⊢j if and only if J = j. Thus, taking K as the identity function and H = F
demonstrates that f ≤sW j.
The above theorem shows that jump operators form a subset of the strong Weih-
rauch degrees. However, this inclusion is strict, in the sense that there are strong
Weihrauch degrees that do not correspond to any jump operator. For example, a
constant function on ωω is not strong Weihrauch equivalent to any jump operator
because jump operators are surjective.
2.4 Adjoints
This section actually applies more to computability theoretic jump operators than
topological jump operators, but the basic deﬁnitions and immediate results are
the same in both cases. This section mainly consists of generalizations of results
found in [10] and [7].
Let j and k be jump operators and let id: ωω →ωω be the identity function.
We say that j is left adjoint to k or that k is right adjoint to j, and write j ⊣k, if
and only if k ◦j ≤id ≤j ◦k. This is equivalent to stating that the j-jump on J is
left adjoint to the k-jump, and it also implies that the associated endofunctors are
adjoint.

90
|
Matthew de Brecht
Example 13 (see [10] and [7]). Let (Un)n∈ω be a standard enumeration of the com-
putably enumerable open subsets of ωω. Deﬁne J : ωω →ωω by J(ξ)(n) = 1 if
ξ ∈Un and J(ξ)(n) = 0, otherwise. Then J−1, the inverse of J, is a computability
theoretic jump operator and J−1 ⊣jΣ0
2.
Note, however, that J−1 is not a topological jump operator [7].
Proposition 14. If j ⊣k then the (j ◦k)-jump is a closure operator. In particular,
(j ◦k)-realizable functions are closed under composition.
Proof. This is a well known property of adjoints. Since k ◦j ≤id it follows that
j◦k◦j◦k ≤j◦id◦k ≡j◦k. Furthermore, id ≤j◦k implies j◦k ≡id◦j◦k ≤j◦k◦j◦k,
and it follows that (j ◦k) is idempotent. Therefore, the (j ◦k)-jump is a closure
operator.
The low-jump-operator is deﬁned as L = J−1 ◦jΣ0
2. It is shown in [7] that L-
realizability captures the notion of “lowness” from computability theory. It imme-
diately follows from the above proposition that L-realizable functions are closed
under composition.
The general theory of adjoints provides much information about j and k when
it is known that j ⊣k. For example, the j-jump preserves joins on J and the k-jump
preserves meets. Viewed as functors, j preserves colimits and k preserves limits.
This means, in particular, that k(X)×k(Y) will be isomorphic to k(X×Y) for every
pair of represented spaces X and Y.
Although so far we have been investigating the eﬀects of weakening the out-
put representation, it is also interesting to investigate the eﬀects of strengthening
the input representation. Given jump operators j and k, represented spaces ⟨X, ρX⟩
and ⟨Y, ρY⟩, and a function f : X →Y, we will say that a function F : ⊆ωω →ωω
⟨j, k⟩-realizes f if and only if f ◦ρX ◦j = ρY ◦k ◦F. This simply means that F
realizes f reinterpretted as a function between j(X) and k(Y). We will say that a
function is ⟨j, k⟩-realizable if and only if it has a continuous ⟨j, k⟩-realizer. Clearly,
j-realizability as deﬁned earlier corresponds to ⟨id, j⟩-realizability.
The following theorem shows that if j ⊣k, then strengthening the input rep-
resentation by j is equivalent to weakening the output representation by k.
Theorem 15. If j and k are jump operators and j ⊣k, then ⟨j, id⟩-realizability is
equivalent to ⟨id, k⟩-realizability.
Proof. Assume j ⊣k and that f : X →Y is ⟨j, id⟩-realizable. Let Fj be any contin-
uous ⟨j, id⟩-realizer for f. Since k is a jump operator there is a partial continuous
F′
j that ⟨k, k⟩-realizes Fj, hence F′
j is a ⟨j ◦k, k⟩-realizer of f. If we let I be a contin-

Levels of Discontinuity and Jump Operators
|
91
uous function reducing id to j ◦k, then F′
j ◦I is a continuous ⟨id, k⟩-realizer for f.
Therefore, f is ⟨id, k⟩-realizable.
Proving that ⟨id, k⟩-realizability implies ⟨j, id⟩-realizability is done similarly.
Finally, the following proposition shows that it is easy to create new pairs of ad-
joint jump operators from a given pair of adjoint operators. We leave the proof as
an easy exercise.
Proposition 16. If j ⊣k, then k ◦k ◦j ◦j ≤k ◦j ≤id ≤j ◦k ≤j ◦j ◦k ◦k. In
particular, we have j ◦j ⊣k ◦k.
2.5 Additional properties
In our ﬁnal section on the general theory of jump operators, we would like to em-
phasize how they can contribute to the development of a categorical framework
for descriptive set theory. The observations in this section are closely related to
recent work initiated by A. Pauly on synthetic descriptive set theory [31; 32].
Let S = {⊥, ⊤} be the Sierpinski space and let 2 = {0, 1} be the discrete
two point space. It is well known that there is a bijection between the open (resp.,
clopen) subsets of a topological space X and the continuous functions from X to
S (resp., 2). In the same manner, there is an obvious bijection between Σ0
2(X) and
the set of jΣ0
2-realizable functions χ: X →S. Furthermore, ∆0
2(X) is in bijective
correspondence with the set of jΣ0
2-realizable functions χ: X →2.
In general, given an arbitrary jump operator j and a represented space X, we
can deﬁne Σj(X) to be the set of j-realizable functions from X into S, and deﬁne
∆j(X) to be the set of j-realizable functions from X into 2. Thus, each jump operator
j determines a “j-decideable” class ∆j(X) of subsets of X and a “j-semi-decideable”
class Σj(X).²
It is well known that the category of represented spaces and continuously re-
alizable (total) functions is cartesian closed (see [4], for example). Given a repre-
sented space Y and a jump operator j, recall that j(Y) denotes the represented
space obtained by composing the representation with j (this is the image of Y un-
der the endofunctor determined by j). Then for any pair of represented spaces X
and Y, the exponential object j(Y)X is the natural candidate for the represented
space of j-realizable functions from X to Y. In particular, j(S)X corresponds to Σj(X)
and j(2)X corresponds to ∆j(X).
2 Note that ∆j and Σj will completely coincide for some jump operators, such as j∆.

92
|
Matthew de Brecht
We can therefore deﬁne notions such as “Σ0
2-set” on an arbitrary represented
space X, and we can interpret the set of Σ0
2-sets as a new represented space. This
can be done even when it is impossible to interpret X as a topological space in any
natural way.
What kind of a space is Σ0
2(Σ0
2(X))? Note that jΣ0
2(S) is isomorphic to the Sier-
pinski space with the total representation ρ: ωω →S sending ξ ∈ωω to ⊤if
and only if (∃n)(∀m)[ξ(⟨n, m⟩) = 1]. Thus, Σ0
2(X) represents in a sense the fam-
ily of Σ0
2-predicates on X, and Σ0
2(Σ0
2(X)) is the second-order object corresponding
to the family of Σ0
2-predicates on the Σ0
2-predicates on X. This connection between
Σ0
n(X) and Σ0
2-predicates easily extends to n > 2. It is the topic of future research to
determine what kind of general “topological” information can be extracted from
spaces like Σ0
2(Σ0
2(X)).
3 Levels of discontinuity
The next part of this paper will be dedicated to characterizing j∆- and jα-realizabi-
lity (1 ≤α < ω1) for functions between arbitrary countably based T0-spaces.
A characterization of j∆-realizability for functions on ωω has already been
given by A. Andretta [2]. In addition, L. Motto Ros [27] has independently investi-
gated a notion related to jα-realizability on metric spaces. However, the extension
of the theory to arbitrary countably based T0-spaces that we provide here appears
to be new.
In the following sections, we will assume that all represented spaces are
countably based T0-topological spaces with admissible representations. Recall
from [33; 47] that a representation ρ:
⊆ωω →X to a topological space X is
admissible if ρ is continuous and for any continuous f :
⊆ωω →X there is
continuous F : ωω →ωω such that f = ρ ◦F. It is well known that a function
f : X →Y between admissibly represented spaces is continuously realizable if
and only if it is continuous.
3.1 Characterization of j∆-realizability
A total function f : X →Y is ∆0
2-piecewise continuous if and only if there is a family
{Ai}i∈ω of sets in ∆0
2(X) such that X = 
i∈ω Ai and f|Ai : Ai →Y, the restriction
of f to Ai, is continuous for all i ∈ω.
Let ω∞be the one point compactiﬁcation of the natural numbers, with ∞the
point at inﬁnity. Recall that a function ξ : ω∞→X is continuous if and only if the

Levels of Discontinuity and Jump Operators
|
93
sequence (ξ(i))i∈ω converges to ξ(∞) in X. Given a continuous function ξ : ω∞→
X and S ⊆X, we say that ξ is eventually in S if and only if ξ(∞) ∈S and ξ(m) ∈S
for all but ﬁnitely many m ∈ω. We will say that ξ is eventually equal to x for some
x ∈X if ξ is eventually in the singleton set {x}, and in this case we will also say
that ξ is eventually constant.
Assuming, as we do, that X and Y are countably based, a function f : X →Y is
∆0
2-piecewise continuous if and only if there is a ∆0
2-measurable function ι: X →ω
such that for any continuous function ξ : ω∞→X, if ι ◦ξ is eventually constant
then f ◦ξ is continuous. Converting from the previous deﬁnition to this deﬁnition
only requires the equivalence between continuity and sequential continuity for
countably based spaces, and the generalized Σ0
2-reduction principle which allows
us to convert a Σ0
2-covering into a Σ0
2-partitioning. We will call the function ι: X →
ω above a ∆0
2-indexing function for f. For example, the function ι∆: dom(j∆) →ω
that maps each ⟨ξn⟩n∈ω ∈dom(j∆) to the least n ∈ω satisfying (∀m ≥n)[ξm = ξn]
is a ∆0
2-indexing function for j∆.
The next theorem generalizes a result by A. Andretta [2].
Theorem 17. Let f : X →Y be a function between admissibly represented count-
ably based T0-spaces. Then f is j∆-realizable if and only if f is ∆0
2-piecewise contin-
uous.
Proof. Let ρX be the admissible representation for X and ρY the admissible repre-
sentation for Y. We can assume without loss of generality that ρX is an open map
and has Polish ﬁbers (i.e. ρ−1
X (x) is Polish for each x ∈X), and similarly for ρY.
Assume F :
⊆ωω →ωω j∆-realizes f. Then ι′ = ι∆◦F is a ∆0
2-indexing
function for f ◦ρX = ρY ◦j∆◦F. Since ι′ is ∆0
2-measurable, we can write ι′−1(n) =

i∈ω An
i for suitably chosen closed sets An
i . Let {Bi}i∈ω be a countable basis for
ωω, and deﬁne Uk
n,i = ρX(Bk) and Vk
n,i = ρX(Bk \ An
i ). Note that Uk
n,i and Vk
n,i are
open subsets of X by our assumption that ρX is an open map.
We ﬁrst show that each x ∈X is in Uk
n,i \ Vk
n,i for some choice of k, n, i ∈ω.
Since ρ−1
X (x) ⊆
n,i∈ω An
i , the Baire category theorem implies some An
i must have
non-empty interior in ρ−1
X (x). Thus there is some k ∈ω such that Bk ∩ρ−1
X (x) ̸= ∅
and Bk ∩ρ−1
X (x) ⊆An
i ∩ρ−1
X (x). It follows that x ∈Uk
n,i \ Vk
n,i.
Let ⟨·, ·, ·⟩: ω3 →ω be a bijection, and deﬁne ι: X →ω so that ι(x) = ⟨k, n, i⟩,
where ⟨k, n, i⟩is the least number satisfying x ∈Uk
n,i \ Vk
n,i. It is immediate that ι
is ∆0
2-measurable.
Let ξ : ω∞→X be a continuous function such that ι◦ξ is eventually constant.
The admissibility of ρX implies there is continuous ξ′ : ω∞→ωω such that ξ =
ρX ◦ξ′. Assume (ι ◦ξ)(∞) = ⟨k, n, i⟩. Then ξ is eventually in ρX(Bk) \ ρX(Bk \ An
i ),
hence ξ′ is eventually in Bk ∩An
i , and it follows that ι′ ◦ξ′ is eventually equal to

94
|
Matthew de Brecht
n. Since ι′ is a ∆0
2-indexing function for f ◦ρX, it follows that f ◦ξ = f ◦ρX ◦ξ′ is
continuous. Therefore, ι is a ∆0
2-indexing function for f, and we have proven that
f is ∆0
2-piecewise continuous.
For the converse, let ι: X →ω be a ∆0
2-indexing function for f. Then ι′ = ι◦ρX
is a ∆0
2-indexing function for f ◦ρX. We can write ι′−1(n) = 
i∈ω An
i for suitably
chosen closed sets An
i , and we have that f ◦ρX restricted to An
i is continuous. By
the admissibility of ρY, there is continuous Fn
i :
⊆ωω →ωω that realizes the
restriction of f ◦ρX to Ai
n. By relabeling, we can assume that {Ai}i∈ω is a family of
closed sets covering the domain of f ◦ρX, and Fi is a continuous realizer for the
restriction of f ◦ρX to Ai.
The most intuitive way to explain how to “glue” together the continuous real-
izers Fi into a single j∆-realizer F, is to deﬁne an algorithm for a Type Two Turing
Machine that computes F (possibly with access to some oracle). This description
will also help clarify the connections between limit computing with ﬁnite mind
changes and the j∆jump operators. The reader should consult [47] for more on
Type Two Turing Machines, and [48] for an intuitive description of computing with
ﬁnite mind changes.
The realizer F ﬁrst initializes a pointer p := 0, and begins reading in the input
ξ ∈ωω. While reading in the input, F attempts to write to its output tape (an
encoding of) an inﬁnite sequence of copies of the output of Fp(ξ). In parallel, F
will try to determine whether or not ξ really is in Ap. If ξ is not in Ap, then this will
be observed after reading in some ﬁnite preﬁx of ξ because Ap is a closed set. In
such a case, F will increment the pointer p := p + 1, and then resume outputting
copies of the output of Fp(ξ) and testing whether x ∈Ap for the updated value of
the pointer p.
When p is incremented, it is possible that F has already written some ﬁnite
preﬁxes of a ﬁnitenumber of elements of ωω to the output tape. After incrementing
the pointer, F will consider these initial guesses to be invalid, and will complete
the preﬁxes it has already written by extending them with inﬁnitely many zeros.
This guarantees that F will produce a valid encoding of an inﬁnite sequence of
elements of ωω as output.
Since {Ai}i∈ω covers the domain of f ◦ρX, after a ﬁnite number of “mind
changes” the pointer p will reach a value such that ξ ∈Ap, and the pointer will
never be modiﬁed again afterwards. Since Fp realizes the restriction of f ◦ρX to
Ap, we see that the output of F converges after a ﬁnite number of modiﬁcations to
the desired output.

Levels of Discontinuity and Jump Operators
|
95
3.2 Characterization of jα-realizability
In this section we will characterize jα-realizability in terms of a hierarchy of dis-
continuity levels introduced by P. Hertling [21; 20].
Recall that a function f : X →Y is continuous at x ∈X iﬀfor any neighbor-
hood V of f(x) there is an open neighborhood U of x such that f(U) ⊆V. If f is
not continuous at x then f is discontinuous at x.
Deﬁnition 18 (P. Hertling [21; 20]). Let cl(·) be the closure operator on X and let
f : X →Y be a function. For each ordinal α, deﬁne Lα(f) recursively as follows:
1. L0(f) = X
2. Lα+1(f) = cl({x ∈Lα(f) | f|Lα(f) is discontinuous at x})
3. If α is a limit ordinal, then Lα(f) = 
β<α Lβ(f).
The level of f, denoted Lev(f), is deﬁned as Lev(f) = min{α | Lα(f) = ∅} if there
exists α such that Lα(f) = ∅, and Lev(f) = ∞, otherwise.
Note that, assuming that X is countably based, there is some α < ω1 such that
Lα(f) = Lα+1(f). This is because we cannot have a strictly decreasing transﬁnite
sequence of closed sets in X with non-countable order type (see Theorem 6.9 in
[24]). In particular, if Lev(f) ̸= ∞then Lev(f) < ω1 when the domain is countably
based.
The next deﬁnition will provide a convenient characterization of Lev(·) in
terms of “piecewise continuity”.
Deﬁnition 19. For each ordinal α (1 ≤α < ω1), a total function f : X →Y is Dα-
piecewise continuous if and only if there is a family {Uβ}β<α of open subsets of X
such that X = 
β<α Dα(Uβ) and f|Dα(Uβ) : Dα(Uβ) →Y is continuous for all β < α,
where we deﬁne Dα(Uβ) = Uβ \ 
γ<β Uγ.
The following theorem shows that Deﬁnitions 18 and 19 describe equivalent hier-
archies of discontinuity.
Theorem 20. Let X and Y be non-empty countably based T0 spaces, and f : X →Y
a function. Then Lev(f) = α (α ̸= ∞) if and only if f is Dα-piecewise continuous
and f is not Dβ-piecewise continuous for any β < α.
Proof. We divide the proof into two parts. In Part 1, we show that if Lev(f) = α
then f is Dα-piecewise continuous. In Part 2, we show that if f is Dα-piecewise
continuous then Lev(f) ≤α. The theorem clearly follows from these two claims.

96
|
Matthew de Brecht
(Part 1): First assume that Lev(f) = α. Clearly, α ≥1 because L0(f) = X ̸= ∅.
For β < α, deﬁne Uβ = X \ Lβ+1(f). Clearly Uβ is open. Note that

γ<β
Uγ
=

γ<β
X \ Lγ+1(f)
=
X \

γ<β
Lγ+1(f)
=
X \ Lβ(f)
where the last equality holds when β is a limit ordinal by deﬁnition of Lβ(f) and
holds when β is a successor by the fact that {Lγ+1}γ<β is a decreasing sequence
that ends with Lβ. It follows that
Dα(Uβ)
=
Uβ \

γ<β
Uγ
=
X \ Lβ+1(f)
\ X \ Lβ(f)
=
Lβ(f) \ Lβ+1(f).
We ﬁrst show that X = 
β<α Dα(Uβ). For x ∈X, let βx = min{β | x ̸∈Lβ(f)}. Since
Lα(f) = ∅by assumption, we have that βx is deﬁned and βx ≤α. It is also clear
that βx is a successor ordinal, because if βx was a limit ordinal then x ∈Lγ(f) for
all γ < β (by our choice of minimal βx) hence x ∈Lβx(f) (by deﬁnition of Lβx for
limit βx), a contradiction. Therefore, βx = γx +1 for some ordinal γx < α. It follows
that x ∈Dα(Uγx), hence X = 
β<α Dα(Uβ).
It only remains to show that f|Dα(Uβ) is continuous for all β < α. Assume for
a contradiction that f|Dα(Uβ) is discontinuous at some point x. Since Dα(Uβ) is
a subspace of Lβ(f), it must be the case that f|Lβ(f) is also discontinuous at x.
Therefore, x ∈Lβ+1(f), contradicting x ∈Dα(Uβ). Thus, f|Dα(Uβ) is continuous
for all β < α.
(Part 2): Let {Uβ}β<α be open subsets of X such that X = 
β<α Dα(Uβ) and
f|Dα(Uβ) : Dα(Uβ) →Y is continuous for all β < α. We can assume without loss of
generality that 
γ<β Uγ ⊆Uβ for all β < α.
We claim that Lβ+1(f) ⊆X \ Uβ for all β < α. The case β = 0 is easy, so as-
sume that β > 0 and the claim holds for all γ < β. First note that, since f|Dα(Uβ) =
f|Uβ\
γ<β Uγ is continuous by assumption, and since Uβ \ 
γ<β Uγ is an open sub-
space of X \ 
γ<β Uγ, f|X\
γ<β Uγ is continuous at every x ∈Uβ. Now assume that
f|Lβ(f) is discontinuous at x. By induction hypothesis,
Lβ(f) =

γ<β
Lγ+1(f) ⊆

γ<β
X \ Uγ = X \

γ<β
Uγ
so it follows that f|X\
γ<β Uγ is discontinuous at x. Therefore, x ̸∈Uβ. Hence,
{x ∈Lβ(f) | f|Lβ(f) is discontinuous at x} ⊆X \ Uβ

Levels of Discontinuity and Jump Operators
|
97
and it follows that Lβ+1(f) ⊆X \ Uβ because X \ Uβ is closed. This concludes the
proof of the claim.
Since {X\Uβ}β<α is a decreasing sequence of closed sets and 
β<α(X\Uβ) = ∅,
the claim implies that Lα(f) = ∅, hence Lev(f) ≤α.
For each countable ordinal α, we let αop denote the topological space whose
points are the ordinals less than α and whose open sets are generated from the
sets ↓β = {γ | γ ≤β} for each β < α.
Let f : X →Y be a function between countably based spaces, and let α be a
countable ordinal. An α-indexing function for f is a continuous function ι: X →
αop such that for any continuous function ξ : ω∞→X, if ι ◦ξ is eventually con-
stant then f ◦ξ is continuous.
The existence of an α-indexing function is a necessary and suﬃcient condi-
tion for a function to be Dα-piecewise continuous. If f is Dα-piecewise continu-
ous, then the function ι mapping Dα(Uβ) to β is an α-indexing function for f. Con-
versely, if ι is an α-indexing function for f, then deﬁning Uβ = ι−1(↓β) demon-
strates that f is Dβ-piecewise continuous.
The function ια : dom(jα) →αop, deﬁned as mapping ⟨⟨βn⟩α ⋄ξn⟩n∈ω to
min{βn | n ∈ω}, is an α-indexing function for the jump operator jα.
We can now completely characterize jα-realizability for functions between
countably based spaces.
Theorem 21. Let f : X →Y be a function between admissibly represented count-
ably based T0-spaces and let α be a countable ordinal. Then f is jα-realizable if and
only if Lev(f) ≤α if and only if f is Dα-piecewise continuous.
Proof. As before, we assume without loss of generality that the admissible repre-
sentations ρX and ρY are open maps with Polish ﬁbers.
Assume F :
⊆ωω →ωω jα-realizes f. Then ι′ = ια ◦F is an α-indexing
function for f ◦ρX = ρY ◦jα ◦F. Let Uβ = ρX(ι′−1(↓β)) for β < α. Clearly, Uβ is
an open subset of X because ρX is an open map. Finally, deﬁne ι: X →αop so that
x →min{β | x ∈Uβ}. It is easy to see that ι is a well-deﬁned total function. For
each ordinal β < α, ι−1(↓β) = 
γ≤β Uγ, hence ι is continuous.
Let ξ : ω∞→X be a continuous function such that ι ◦ξ is eventually con-
stant. The admissibility of ρX implies there is continuous ξ′ : ω∞→ωω such that
ξ = ρX ◦ξ′. Assume (ι ◦ξ)(∞) = β. Then ξ is eventually in Dα(Uβ), hence ξ′ is
eventually in ι′−1(↓β) \ 
γ<β ι′−1(↓γ). It follows that ι′ ◦ξ′ is eventually equal to
β. Since ι′ is an α-indexing function for f ◦ρX, it follows that f ◦ξ = f ◦ρX ◦ξ′ is
continuous. Therefore, ι is an α-indexing function for f, and we have proven that
f is Dα-piecewise continuous.

98
|
Matthew de Brecht
For the converse, we will use the same method as in the proof of Theorem 17
and deﬁne an oracle Type Two Turing Machine that computes a jα-realizer for f.
Let ι: X →ω be an α-indexing function for f. Then ι′ = ι ◦ρX is an α-indexing
function for f ◦ρX. Let Uβ = ι′−1(↓β) for β < α, and we have that f ◦ρX restricted
to Dα(Uβ) is continuous. By the admissibility of ρY, there is continuous Fβ :
⊆
ωω →ωω that realizes the restriction of f ◦ρX to Dα(Uβ).
Our algorithm is as follows. Begin reading in the input ξ ∈ωω, and search
in parallel for β < α such that ξ ∈Uβ. Such a β can be found after reading in a
ﬁnite preﬁx of ξ because each Uβ is open and the Uβ cover the domain of f ◦ρX.
The algorithm then initializes an ordinal counter ˆβ := β and attempts to write to
the output tape an inﬁnite sequence of copies of the element ⟨ˆβ⟩α ⋄Fˆβ(ξ). While
outputting the copies of ⟨ˆβ⟩α ⋄Fˆβ(ξ) the algorithm continues to search for some
γ < ˆβ such that ξ ∈Uγ. If such a γ is ever found, then the algorithm sets ˆβ := γ
and begins outputting an inﬁnite sequence of copies of ⟨ˆβ⟩α ⋄Fˆβ(ξ) for the new
value of ˆβ. It is easy to see that such an algorithm computes a jα-realizer for f.
4 Examples and applications
In this last section of this paper we provide a few examples and applications of j∆
and jα-realizability.
4.1 The Diﬀerence Hierarchy
Given a jump operator j and a represented space X, recall that ∆j(X) is the set of
j-realizable functions from X into the discrete two point space 2 = {0, 1}. In this
section, we will show that ∆jα(X) (1 ≤α < ω1) correspond to the ambiguous levels
of the diﬀerence hierarchy when X is a countably based space.
Deﬁnition 22. Any ordinal α can be expressed as α = β + n, where β is a limit
ordinal or 0, and n < ω. We say that α is even if n is even, and odd, otherwise. For
any ordinal α, let r(α) = 0 if α is even, and r(α) = 1, otherwise. For any ordinal α,
deﬁne
Dα({Aβ}β<α) =

{Aβ \  
γ<β
Aγ

| β < α, r(β) ̸= r(α)},
where {Aβ}β<α is a sequence of sets such that Aγ ⊆Aβ for all γ < β < α.

Levels of Discontinuity and Jump Operators
|
99
For any topological space X and ordinal α, deﬁne Σ−1
α (X) to be the set of all
sets Dα({Uβ}β<α), where {Uβ}β<α is an increasing sequence of open subsets of X.
The following connection with the diﬀerence hierarchy has already been observed
by both P. Hertling and V. Selivanov, so we omit the proof.
Proposition 23 (see [38]). If X is a countably based T0-space and 1 ≤α < ω1,
then a total function f : X →2 is jα-realizable if and only if both f −1(1) and f −1(0)
are in Σ−1
α (X).
4.2 Cantor-Bendixson Rank
A limit point of a topological space is a point that is not isolated, i.e. a point x such
that for every open U containing x there is y ∈U distinct from x. A space is perfect
if all of its points are limit points.
Deﬁnition 24 (see [24]). For any topological space X, let
X′ = {x ∈X | x is a limit point of X}.
For ordinal α, deﬁne X(α) recursively as follows:
1. X(0) = X,
2. X(α+1) = (X(α))′,
3. If α is a limit ordinal, then X(α) = 
β<α X(β).
If X is countably based, then there is a least countable ordinal α0 such that X(α) =
X(α0) for all α ≥α0. Such α0 is called the Cantor-Bendixson rank of X, and is
denoted |X|CB. We also let X∞= X(|X|CB), which is a perfect subset of X.
Assuming X is countably based, X \ X∞must be countable. This is because for ev-
ery x ∈(X\X′) there must be a (basic) open U containing x and no other elements
of X, so (X \ X′) must be countable.
Let ω⊥= ω ∪{⊥} be such that {n} is open for n ∈ω and the only open set
containing ⊥is ω⊥itself. Given countably based X, deﬁne p: X →ω⊥so that
p(x) = ⊥for x ∈X∞and p restricted to the elements of X \ X∞is injective into ω.
The following is a generalization of a result by Luo and Schulte [26] concern-
ing ordinal mind-change complexity of inductive inference (see also [13; 14]).
Proposition 25. For any countably based space X, p: X →ω⊥is jα-realizable,
where

100
|
Matthew de Brecht
1. α = |X|CB if X∞= ∅or |X|CB is a successor ordinal
2. α = |X|CB + 1 if X∞̸= ∅and |X|CB is a limit ordinal
Proof. If X∞= ∅, then deﬁne Uβ = X \ (X(β))′ for β < |X|CB. Letting α = |X|CB, we
see that Dα(Uβ) = X(β) \ (X(β))′, which is the set of isolated points of X(β), hence
a discrete subspace of X.
If X∞̸= ∅but |X|CB = γ + 1, then set Uβ = X \ (X(β))′ for β < γ and Uγ = X.
Letting α = |X|CB, Dα(Uβ) = X(β) \ (X(β))′ for β < γ and Dα(Uγ) = X∞.
If X∞̸= ∅and |X|CB is a limit ordinal, then set Uβ = X \ (X(β))′ for β < |X|CB
and U|X|CB = X. Letting α = |X|CB + 1, Dα(Uβ) = X(β) \ (X(β))′ for β < |X|CB and
Dα(U|X|CB) = X∞.
In all three of the above cases, it is easy to see that Uβ (β < α) is open, X =

β<α Dα(Uβ), and the corresponding restrictions of p are continuous.
4.3 Hilbert’s basis theorem
Let (R, +, ·) be a commutative ring. A subset I ⊆R is an ideal if and only if (I, +)
is a subgroup of (R, +) and (∀x ∈I)(∀r ∈R)[x · r ∈I]. A ring is Noetherian if and
only if it does not have an inﬁnite strictly ascending chain of ideals.
Given a ring R, we let R[x1, . . . , xn] denote the ring of polynomials with coef-
ﬁcients in R and n indeterminates x1, . . . , xn.
A famous theorem by David Hilbert states that if R is a Noetherian ring then
R[x1, . . . , xn] is also Noetherian. Hilbert’s proof was non-constructive, and was
initially criticized by Paul Gordan with the famous quote “Das ist nicht Mathe-
matik. Das ist Theologie.”
Here we quantify one aspect of the “non-constructiveness” of the basis theo-
rem in terms of the level of discontinuity of converting an enumeration of an ideal
into a Gröbner basis for the ideal. Our approach is much in the same spirit as V.
Brattka’s project to quantify the non-computability of mathematical theorems in
terms of their Weihrauch degrees (see, for example, [9; 8; 7]). Our contribution is
only in the way that we formalize the problem, and our main result is essentially
a reformulation of results on Hilbert’s basis theorem by S. Simpson [41] in the con-
text of reverse mathematics, and by F. Stephan and Y. Ventsov [44] in the context
of inductive inference.
Let Q be the ring of rational numbers, and let In be the set of ideals of the
polynomial ring Q[x1, . . . , xn]. If we encode the elements of Q[x1 . . . , xn] as ele-
ments of ω, then each element of ωω can be interpretted as an inﬁnite sequence
of elements of Q[x1 . . . , xn]. We will interpret In as a represented space with the
representation ρ: ⊆ωω →In that maps each enumeration of an ideal I ∈In to

Levels of Discontinuity and Jump Operators
|
101
I. This representation is admissible with respect to the topology on In generated
by ↑⟨r⟩= {I ∈In | r ∈I}, where r varies over elements of Q[x1 . . . , xn]. Note that
this topology is very far from being Hausdorﬀ.
Let Gn be the set of ﬁnite subsets of Q[x1 . . . , xn]. We will think of Gn as the set
of Gröbner bases for ideals in In (for some predeﬁned monomial order). We think
of each Gröbner basis in Gn as being represented by a ﬁnite terminated string,
hence Gn carries the discrete topology.
Let fn : In →Gn be the function that maps each I ∈In to its unique Gröbner
basis. Intuitively, fn embodies the problem of converting an inﬁnite enumeration
of an ideal of Q[x1 . . . , xn] into a ﬁnite Gröbner basis for the ideal.
The next theorem immediately follows from work by S. Simpson [41] and F.
Stephan and Y. Ventsov [44], so we omit the proof.
Theorem 26. The functions fn : In →Gn are jωn-realizable for each n ∈ω. In fact,
Lev(fn) = ωn.
Hilbert’s basis theorem holds for all n ∈ω, so it is natural to consider the function
∀nfn corresponding to universal quantiﬁcation over ω. The most natural interpre-
tation for such a function is to simply take the disjoint union of all of the fn. Then
∀nfn essentially takes some n ∈ω as initial input, and then operates like fn there-
after. It is easy to see that Lev(∀nfn) = ωω, which is consistent with S. Simpson’s
[41] characterization of Hilbert’s basis theorem.
4.4 ∆0
2-measurable functions and the Jayne-Rogers theorem
Recall that a function f : X →Y is ∆0
2-measurable if and only if f −1(U) ∈∆0
2(X)
for each open U ⊆Y. Note that this is equivalent to requiring that f −1(A) ∈Σ0
2(X)
for each A ∈Σ0
2(Y).
The following is a slight generalization of a theorem by J. E. Jayne and C. A.
Rogers [22]. A much simpler proof of the original theorem was given by L. Motto
Ros and B. Semmes [29; 23]. The original version of the Jayne-Rogers theorem only
applied to functions that had a metrizable domain.
In the following, an analytic space is a topological space that has an admis-
sible representation with analytic domain. For countably based T0-spaces, this
is easily seen to be equivalent to the space being homeomorphic to an analytic
subset of a quasi-Polish space [11].

102
|
Matthew de Brecht
Theorem 27 (Jayne and Rogers). Assume X is an analytic countably based T0-
space and Y is a separable metrizable space. Then a function f : X →Y is ∆0
2-
measurable if and only if it is ∆0
2-piecewise continuous.
Proof. Let ρX be an admissible representation of X with analytic domain. Then
f ◦ρX is a ∆0
2-measurable function from an analytic metrizable space into a metriz-
able space, hence f ◦ρX is ∆0
2-piecewise continuous by the original Jayne-Rogers
theorem [22; 29; 23]. It follows that there is a continuous j∆-realizer F of f ◦ρX.
Clearly, F is a j∆-realizer of f, hence f is ∆0
2-piecewise continuous.
A natural question is how much the constraints on the domain and codomain can
be relaxed. Based on S. Solecki’s work in [42] and its applications to the Jayne-
Roger’s theorem [43] (but see also [23]), we conjecture that it is consistent with
ZFC to allow the domain to be Σ1
2 and possibly any other level of the projective
hierarchy. With respect to the codomain, however, the following example shows
that some separation axiom, such as regularity³, is required.
Example 28. We consider two topologies on the ordinal ω + 1 = {0, 1, 2, . . . , ω}.
The ﬁrst topology, τ1, is the Scott-topology, and is generated by the open sets ↑n =
{β ∈ω + 1 | n ≤β} for n < ω. The second topology, τ2, is deﬁned so that a non-
empty subset U ⊆ω +1 is open if and only if ω ∈U and all but ﬁnitely many n ∈ω
are in U. The topological space (ω +1, τ1) is one of the simplest examples of an inﬁ-
nite ω-continuous domain [17]. The topological space (ω + 1, τ2) is homeomorphic
to the Zariski topology on the prime spectrum of the ring of integers. Both τ1 and
τ2 are quasi-Polish topologies on ω + 1. Furthermore, in both of these spaces the
singleton set {ω} is Π0
2 but not Σ0
2, hence these spaces fail the TD-separation axiom
of Aull and Thron [3] (see also [11; 14] for more on the TD-axiom).
The function f : (ω + 1, τ1) →(ω + 1, τ2), deﬁned to behave as the identity on
ω + 1, is a ∆0
2-measurable function that is not ∆0
2-piecewise continuous. Since (ω +
1, τ1) is quasi-Polish, it follows from [11] that it has a total admissible representation
ρ: ωω →(ω + 1, τ1). As any j∆-realizer of f ◦ρ would be a j∆-realizer of f, we see
that the function f ◦ρ: ωω →(ω + 1, τ2) is an example of a function with Polish
domain which is ∆0
2-measurable but not ∆0
2-piecewise continuous.
Let F be a class of functions between (admissibly represented) topological spaces.
We will say that a jump operator j captures the class F if it holds that f ∈F if
3 Luca Motto Ros has pointed out to the author that the proof in [23] suggests regularity is a
suﬃcient criterion on the codomain for Theorem 27 to hold, even in the absence of separability
and metrizability.

Levels of Discontinuity and Jump Operators
|
103
and only if f is j-realizable. Note that such a j must be in F because j is trivially
j-realizable.
If we let F be the class of ∆0
2-measurable functions with (countably based)
analytic domain and metrizable codomain, then the Jayne-Rogers theorem states
that j∆captures F. However, the example above shows that j∆does not capture the
class of ∆0
2-measurable functions between arbitrary countably based T0-spaces.
One might wonder if some other jump operator might capture this larger class,
but the following result shows that this is not possible.
Proposition 29. There is no jump operator that captures the entire class of ∆0
2-
measurable functions between countably based T0-spaces.
Proof. Assume for a contradiction that j captures the entire class of ∆0
2-measurable
functions between countably based T0-spaces. Let f : (ω + 1, τ1) →(ω+1, τ2) be
the ∆0
2-measurable function from Example 28. We can assume that (ω + 1, τ1) has
a total admissible representation, hence there is a total continuous F : ωω →ωω
that j-realizes f. The Jayne-Rogers theorem now implies that the ∆0
2-measurable
function j ◦F : ωω →ωω has a continuous j∆-realizer F′ : ωω →ωω. However, F′
would then be a continuous j∆-realizer of f, which is a contradiction.
By applying the same argument to the function f ◦ρ from Example 28, it can
be seen that the above proposition holds true even if we further restrict to ∆0
2-
measurable functions with Polish domain.
4.5 A generalization of the Hausdorﬀ-Kuratowski theorem
The Hausdorﬀ-Kuratowski theorem (see [24]) states that the diﬀerence hierarchy
on a Polish space exhausts all of the ∆0
2-sets. The full version of the theorem actu-
ally applies to all levels of the Borel hierarchy. It was observed by V. Selivanov
[36; 39] that the Hausdorﬀ-Kuratowski theorem holds for some important non-
metrizable spaces such as ω-continuous domains. Later it was shown that the full
version of the Hausdorﬀ-Kuratowski theorem holds for all quasi-Polish spaces [11].
In addition to extending the Hausdorﬀ-Kuratowski theorem to a more general
class of spaces, V. Selivanov has also generalized the theorem from being a classi-
ﬁcation of sets to a classiﬁcation of functions [36]. In particular, it was observed
in [36] that each ∆0
2-measurable function f from a Polish space into a ﬁnite dis-
crete space will satisfy Lev(f) = α for some α < ω1. In this section, we will extend
this result to show that any ∆0
2-measurable function f from a quasi-Polish space
to a separable metrizable space will satisfy Lev(f) = α for some α < ω1. Given
the connections between P. Hertling’s levels of discontinuity and the diﬀerence

104
|
Matthew de Brecht
hierarchy, our result is a very broad generalization of the Hausdorﬀ-Kuratowski
theorem restricted to ∆0
2-sets. L. Motto Ros [27] has independently made a similar
observation for ∆0
2-measurable functions on metrizable spaces.
As in the original proof of the Hausdorﬀ-Kuratowski theorem, the Baire cate-
gory theorem plays an important role in our generalized result as well. One version
of the Baire category theorem states that if a Polish space is equal to the union
of a countable family of closed sets, then one of the closed sets must have non-
empty interior. Clearly, the same statement holds for Polish spaces if we replace
“closed” by either “Fσ” or “Σ0
2”. However, since the equivalence between Fσ-sets
and Σ0
2-sets breaks down for non-metrizable spaces, the version of the Baire cat-
egory theorem presented in the following lemma is more appropriate in general.
This generalization of the Baire category theorem has already been investigated
by R. Heckmann [19] and by V. Becher and S. Grigorieﬀ[5].
Lemma 30. Assume X is quasi-Polish and {Ai}i∈ω is a family of sets from Σ0
2(X)
such that X = 
i∈ω Ai. Then there is i ∈ω such that Ai has non-empty interior.
Equivalently, the intersection of a countable family of dense Π0
2-subsets of a quasi-
Polish space is a dense Π0
2-set.
Proof. Let f : ωω →X be an open continuous surjection (see [11]) and let Bi =
f −1(Ai). Each Bi is a Σ0
2-subset of a metrizable space hence equal to a countable
union of closed sets. Since ωω = 
i∈ω Bi, the Baire category theorem for Polish
spaces implies there is i ∈ω such that Bi has non-empty interior. It follows that
Ai has non-empty interior because f is an open map.
Theorem 31. If X is quasi-Polish and Y is a countably based T0-space, then f : X →
Y is j∆-realizable if and only if it is jα-realizable for some α < ω1.
Proof. Assume f : X →Y is j∆-realizable. Let α < ω1 be the least ordinal such
that Lα(f) = Lα+1(f), which exists because X is countably based. Assume for
a contradiction that Lα(f) ̸= ∅. Clearly, f|Lα(f) is j∆-realizable, hence there is a
∆0
2-partitioning {Ai}i∈ω of Lα(f) such that the restriction of f to Ai is continuous
for each i ∈ω. Note that Lα(f) is quasi-Polish because it is a closed subset of the
quasi-Polish space X. Therefore, Lemma 30 applies and there is i ∈ω such that Ai
has non-empty interior relative to Lα(f). But then f|Lα(f) is continuous on a non-
empty open subset of Lα(f), contradicting our assumption that Lα(f) = Lα+1(f).
Thus, Lα(f) is empty and it follows that Lev(f) = α < ω1.
The converse holds for all represented spaces because jα ≤j∆.
Combining the above result with the Jayne-Rogers theorem yields the following
generalization of the Hausdorﬀ-Kuratowski theorem.

Levels of Discontinuity and Jump Operators
|
105
Theorem 32. If X is quasi-Polish and Y is a separable metrizable space, then
f : X →Y is ∆0
2-measurable if and only if it is jα-realizable for some α < ω1.
5 Conclusions
Although much of classical descriptive set theory has been extended to arbitrary
countably based T0-spaces, it is still a major open problem to understand how de-
scriptive set theory should work for non-countably based topological spaces and
more general represented spaces. This is a very strange realm, where even single-
ton sets can have complexity of arbitrarily high rank in the projective hierarchy.
The approach we have taken here with jump operators provides a general
framework, with a nice categorical ﬂavor, for which to extend descriptive set the-
ory to more general mathematical structures. In particular, it raises natural ques-
tions concerning the structure and applications of “higher-order” descriptive set
theoretical objects such as Σ0
2(Σ0
2(X)).
There is also a strong need for a reﬁned analysis of the categorical logic of
the category of represented spaces and realizable functions with closer atten-
tion to the “level” of the represented spaces. For example, the “naive Cauchy”
representation of the real numbers in [4], which is obtained via a kind of dou-
ble negation of the standard Cauchy representation of the reals, happens to be
equivalent to the jΣ0
2-jump of the standard Cauchy representation of reals [48].
S. Hayashi [18] has also investigated connections between limit-computability
and non-constructive principles such as double negation elimination and the
excluded middle restricted to certain subclasses of formulae. It would be very
interesting to see how these concepts are connected.
Bibliography
[1]
J. Addison, Tarski’s theory of deﬁnability: common themes in descriptive set theory, re-
cursive function theory, classical pure logic, and ﬁnite-universe logic, Annals of Pure and
Applied Logic 126 (2004), 77–92.
[2]
A. Andretta, More on Wadge determinacy, Annals of Pure and Applied Logic 144 (2006),
2–32.
[3]
C. E. Aull and W. J. Thron, Separation axioms between T0 and T1, Indag. Math. 24 (1963),
26–37.
[4]
A. Bauer, Realizability as the connection between computable and constructive mathemat-
ics, Second International Conference on Computability and Complexity in Analysis (CCA
2005), 2005.

106
|
Matthew de Brecht
[5]
V. Becher and S. Grigorieﬀ, Borel and Hausdorﬀhierarchies in topological spaces of
Choquet games and their eﬀectiviation, (submitted), 2012.
[6]
V. Brattka, Eﬀective Borel measurability and reducibility of functions, Mathematical Logic
Quarterly 51 (2005), 19–44.
[7]
V. Brattka, M. de Brecht, and A. Pauly, Closed choice and a uniform low basis theorem,
Annals of Pure and Applied Logic 163, no. 8.
[8]
V. Brattka and G. Gherardi, Eﬀective choice and boundedness principles in computable
analysis, The Bulletin of Symbolic Logic 17 (2011), 73–117.
[9]
V. Brattka and G. Gherardi, Weihrauch degrees, omniscience principles and weak com-
putability, The Journal of Symbolic Logic 76 (2011), 143–176.
[10] V. Brattka and M. Makananise, Limit computable functions and subsets, (unpublished
notes).
[11] M. de Brecht, Quasi-Polish spaces, Annals of Pure and Applied Logic 164 (2013), no. 3,
356 – 381.
[12] M. de Brecht and A. Yamamoto, Σ0
α-admissible representations (extended abstract), Sixth
International Conference on Computability and Complexity in Analysis (CCA 2009), 2009.
[13] M. de Brecht and A. Yamamoto, Mind change complexity of inferring unbounded unions of
restricted pattern languages from positive data, Theoretical Computer Science 411 (2010),
no. 7-9, 976 – 985.
[14] M. de Brecht and A. Yamamoto, Topological properties of concept spaces (full version),
Information and Computation 208 (2010), no. 4, 327 – 340.
[15] Y. Ershov, A hierarchy of sets I, II, III, Algebra and Logic 7 (1968), no. 1, 25–43.
[16] R. Freivalds and C. H. Smith, On the role of procrastination for machine learning, Informa-
tion and Computation 107 (1993), 237–271.
[17] G. Gierz, K. H. Hofmann, K. Keimel, J. D. Lawson, M. W. Mislove, and D. S. Scott, Continu-
ous lattices and domains, Cambridge University Press, 2003.
[18] S. Hayashi, Mathematics based on incremental learning - Excluded middle and inductive
inference, Theoretical Computer Science 350 (2006), no. 1, 125–139.
[19] R. Heckmann, Spatiality of countably presentable locales (proved with the Baire category
theorem), (submitted), 2012.
[20] P. Hertling, Topological complexity with continuous operations, Journal of Complexity 12
(1996), 315–338.
[21] P. Hertling, Unstetigkeitsgrade von Funktionen in der eﬀectiven Analysis, Ph.D. thesis,
FernUniversität Hagen, 1996.
[22] J. E. Jayne and C. A. Rogers, First level Borel functions and isomorphisms, J. Math. pures et
appl. 61 (1982), 177 – 205.
[23] M. Kačena, L. Motto Ros, and B. Semmes, Some observations on “A new proof of a theo-
rem of Jayne and Rogers”, Real Analysis Exchange 38 (2012), 121–132.
[24] A. Kechris, Classical descriptive set theory, Springer-Verlag, 1995.
[25] T. Kihara, Decomposing Borel functions using the Shore-Slaman join theorem,
arXiv:1304.0698, 2013.
[26] W. Luo and O. Schulte, Mind change eﬃcient learning, Information and Computation 204
(2006), 989–1011.
[27] L. Motto Ros, General reducibilities for sets of reals, Ph.D. thesis, Polytechnic of Turin,
2007.
[28] L. Motto Ros, Game representations of classes of piecewise deﬁnable functions, Mathe-
matical Logic Quarterly 57 (2011), 95–112.

Levels of Discontinuity and Jump Operators
|
107
[29] L. Motto Ros and B. Semmes, A new proof of a theorem of Jayne and Rogers, Real Analysis
Exchange 35 (2010), 195–203.
[30] A. Pauly, On the (semi)lattices induced by continuous reducibilities, Mathematical Logic
Quarterly 56 (2010), no. 5, 488–502.
[31] A. Pauly, Synthetic descriptive set theory, Logik Seminar, Technical University of Darm-
stadt, September, 2012.
[32] A. Pauly and M. de Brecht, Towards Synthetic Descriptive Set Theory: An instantiation with
represented spaces, arXiv:1307.1850, 2013.
[33] M. Schröder, Extended admissibility, Theoretical Computer Science 284 (2002), 519–538.
[34] D. S. Scott, Data types as lattices, SIAM Journal on Computing 5 (1976), 522–587.
[35] V. Selivanov, Index sets in the hyperarithmetical hierarchy, Siberian Mathematical Journal
25 (1984), 474–488.
[36] V. Selivanov, Diﬀerence hierarchy in ϕ-spaces, Algebra and Logic 43 (2004), 238–248.
[37] V. Selivanov, Towards a descriptive set theory for domain-like structures, Theoretical
Computer Science 365 (2006), 258–282.
[38] V. Selivanov, Hierarchies of ∆0
2-measurable k-partitions, Math. Logic Quarterly 53 (2007),
446–461.
[39] V. Selivanov, On the diﬀerence hierarchy in countably based T0-spaces, Electronic Notes
in Theoretical Computer Science 221 (2008), 257–269.
[40] B. Semmes, A game for the Borel functions, Ph.D. thesis, Universiteit van Amsterdam,
2006.
[41] S. Simpson, Ordinal numbers and the Hilbert basis theorem, Journal of Symbolic Logic 53
(1988), 961–974.
[42] S. Solecki, Covering analytic sets by families of closed sets, The Journal of Symbolic Logic
59 (1994), no. 3, 1022–1031.
[43] S. Solecki, Decomposing Borel sets and functions and the structure of Baire class 1 func-
tions, Journal of the Amer. Math. Soc. 11 (1998), no. 3, 521–550.
[44] F. Stephan and Y. Ventsov, Learning algebraic structures from text, Theoretical Computer
Science 268 (2001), 221–273.
[45] A. Tang, Chain properties in P(ω), Theoretical Computer Science 9 (1979), 153–172.
[46] A. Tang, Wadge reducibility and Hausdorﬀdiﬀerence hierarchy in P(ω), Lecture Notes in
Mathematics 871 (1981), 360–371.
[47] K. Weihrauch, Computable analysis, Springer-Verlag, 2000.
[48] M. Ziegler, Revising type-2 computation and degrees of discontinuity, Electronic Notes in
Theoretical Computer Science 167 (2007), 255–274.


Jacques Duparc, Olivier Finkel, and Jean-Pierre Ressayre
The Wadge Hierarchy of Petri Nets
ω-Languages¹
Abstract: We describe the Wadge hierarchy of the ω-languages recognized by de-
terministic Petri nets. This is an extension of the celebrated Wagner hierarchy
which turned out to be the Wadge hierarchy of the ω-regular languages. Petri nets
are more powerful devices than ﬁnite automata. They may be deﬁned as partially
blind multi-counter automata. We show that the whole hierarchy has height ωω2,
and give a description of the restrictions of this hierarchy to partially blind multi-
counter automata of some ﬁxed positive number of counters.
Keywords: Automata theory, languages of inﬁnite words, Petri nets, partially
blind multicounter automata, Cantor topology, topological complexity, Borel and
Wadge hierarchies, Wadge degrees
Mathematics Subject Classiﬁcation 2010: 68Q05, 68Q45, 68Q15, 91A44, 03D05,
03E15
||
Jacques Duparc: Faculty of Business and Economics, University of Lausanne, Switzerland
Olivier Finkel and Jean-Pierre Ressayre: Institut de Mathématiques de Jussieu - Paris Rive
Gauche, CNRS et Université Paris Diderot, France
1 Introduction
The languages of inﬁnite words, also called ω-languages, accepted by ﬁnite au-
tomata were ﬁrst studied by Büchi to prove the decidability of the monadic sec-
ond order theory of one successor over the integers. Since then, the ω-regular
languages have been thoroughly studied, and many applications to speciﬁcation
and veriﬁcation of non-terminating systems have been found (see for instance
[32; 45; 47] for many results and references). The acceptance of inﬁnite words by
other ﬁnite machines, such as pushdown automata, multicounter automata, Petri
nets, Turing machines, have also been considered, see [4; 10; 22; 45; 46].
The set Σω of inﬁnite words over a ﬁnite alphabet Σ is naturally equipped with
the Cantor topology. Then, the complexity of languages of inﬁnite words accepted
1 Dedicated to Victor Selivanov on the occasion of his sixtieth birthday.

110
|
J. Duparc, O. Finkel, and J.-P. Ressayre
by ﬁnite machines may be studied in terms of topological complexity. This con-
sists in locating these languages at ﬁrst inside the Borel hierarchy or the projective
hierarchy, and then inside the Wadge hierarchy of the Borel subsets. The latter be-
ing a huge reﬁnement of the Borel hierarchy. The standard work here can be found
in [10; 28; 38; 40; 42; 43; 44; 45; 47].
It is well known that every ω-language accepted by a deterministic Büchi
automaton is a Π0
2-set, and that an ω-language accepted by a non-deterministic
Büchi (or Muller) automaton is a ∆0
3-set. The Borelhierarchy of regular ω-languages
is then determined. Moreover Landweber proved that the Borel complexity of any
ω-language accepted by a Muller or Büchi automaton can be computed eﬀectively
(see [27; 32; 45; 47]).
The trace of the Wadge hierarchy on the ω-regular languages is called the Wag-
ner hierarchy. It has been completely described by Klaus Wagner in [50]. Its length
is the ordinal ωω. Wagner gave an automaton-like characterization of this hierar-
chy, based on the notions of chain and superchain, together with an algorithm
to compute the Wadge (Wagner) degree of any given ω-regular language. Later,
Wilke and Yoo proved that the Wadge degree of an ω-regular language may be
computed in polynomial time [51]. This hierarchy was thoroughly studied by Car-
ton and Perrin in [2; 3], and by Victor Selivanov in [34; 35; 39].
There are a large number of classes of ﬁnite machines recognizing ω-langua-
ges. Each of them yields a countable sub-hierarchy of the Wadge hierarchy. Since
the 1980’s, and the seminal work of Klaus Wagner on the ω-regular languages –
although Wagner was unaware at the time of the connections between the Wadge
hierarchy and his own work – the description of these sub-hierarchies has been a
constant objective.
The Wadge hierarchy of deterministic context-free ω-languages, together with
its length: ω(ω2), was determined in [7; 8]. Whether this hierarchy is decidable
or not remains an open problem. The Wadge hierarchy induced by determinis-
tic partially blind 1-counter automata was described in an eﬀective way in [13],
and other partial decidability results were obtained in [14]. Then, it was proved
in [17; 22] that the Wadge hierarchy of context-free ω-languages and the Wadge
hierarchy of eﬀective analytic sets² are equal. Intriguingly, the only Wadge class
for which the membership of a given context-free ω-language can be decided is
the rudimentary {∅} (see [14; 15; 16]). In particular, one cannot decide whether a
non-deterministic pushdown automaton is universal or not. This latter decision
problem is actually Π1
2-complete, hence located at the second level of the projec-
2 The class of eﬀective analytic sets (denoted Σ1
1) is the class of all the ω-languages recognized by
(non-deterministic) Turing machines.

The Wadge Hierarchy of Petri Nets ω-Languages
|
111
tive hierarchy, and therefore it is “highly undecidable" (see [20]). Moreover, the
second author showed in [19] that the topological complexity of a context-free ω-
language may even depend on the models of set theory. In addition, similar re-
sults hold for ω-languages accepted by 2-tape Büchi automata (see for instance
[18; 19]). Finally, the Wadge hierarchy of ω-languages of deterministic Turing ma-
chines was determined by Victor Selivanov in [36; 37].
Among the many devices that recognize ω-languages and are more powerful
than ﬁnite automata, there are the Petri nets. They are used to describe distributed
systems. Petri nets are directed bipartite graphs, in which the nodes represent
transitions and places. Any distribution of tokens over the places deﬁnes a con-
ﬁguration of the net. Petri nets are related to automata for the reason that they
may be regarded as partially blind multicounter automata (see [23]). Petri nets have
been extensively examined, particularly in concurrency theory (see for instance
[11; 33]). The inﬁnite behavior of Petri nets was ﬁrst studied by Valk in [48], and of
the one of deterministic Petri nets, by Carstensen in [1].
In this paper we ﬁrst consider some deterministic partially blind multicounter
automata (corresponding to deterministic Petri nets) and the ω-languages that
they accept once equipped with a Muller acceptance condition. This forms the
class of deterministic Petri net ω-languages denoted L3
ωdt in [1]. We describe the
trace of the Wadge hierarchy on these languages, which extends the celebrated
Wagner hierarchy of ω-regular languages. We show that the whole hierarchy has
height ωω2, and we characterize the various restrictions of this hierarchy to some
ﬁxed number of partially blind counters.
This article is an extended version of a former conference paper that lacked
most of the proofs but which appeared in [9].
2 Basics on ω-languages, automata, and Petri
nets
We assume the reader to be familiar with the theories of formal languages and
ω-regular languages (see for instance [24; 32; 47]). Throughout the paper, we as-
sume Σ to be any ﬁnite set called the alphabet. A ﬁnite word (string) over Σ is any
sequence of the form u = a1 . . . ak, where k ∈N, and ai ∈Σ holds for every
i ≤k. Notice that when k = 0, u becomes the empty word denoted by ε. The
length of the word u is denoted by |u| (here |u| = k). We will write u(i) = ai and
u[i] = u(1) . . . u(i) for i ≤k and u[0] = ε. We will denote by Σ∗the set of all ﬁnite
words over Σ.

112
|
J. Duparc, O. Finkel, and J.-P. Ressayre
An inﬁnite word over Σ is some sequence of the form x = a1a2 . . . an . . .
where each ai (any i > 0) belongs to Σ. These inﬁnite words are called ω-words
for they have length ω (the ﬁrst inﬁnite ordinal). An inﬁnite word x over Σ can
be viewed as a mapping x : N −→Σ, so we will write x = x(1)x(2) . . . and
x[n] = x(1)x(2) . . . x(n) for its preﬁx³ of length n. We will write Σω for the set of all
ω-words over the alphabet Σ. An ω-language over the alphabet Σ is nothing but a
subset of Σω.
As usual, the concatenation of two ﬁnite words u and v is denoted by uv. The
concatenation of a ﬁnite word u and an ω-word x gives the ω-words y = ux deﬁned
by: y(k) = u(k) if k ≤|u| , and y(k) = x(k−|u|) if k > |u|. Given any ﬁnite or inﬁnite
word x, the ﬁnite word u is a preﬁx of x (denoted u ⊑x) if u(i) = x(i) holds for
every nonzero integer i ≤|u|.
For any ω-language V ⊆Σ∗, the ω-power of V is
Vω = {σ = u1 . . . un . . . ∈Σω | ui ∈V, ∀i ≥1}.
Deﬁnition 1. A ﬁnite state machine is a quadruple M = (Q, Σ, δ, q0), where Q is
a ﬁnite set of states, Σ is a ﬁnite input alphabet, q0 ∈Q is the initial state, and δ
is a mapping from Q × Σ into 2Q . It is deterministic if δ : Q × Σ −→Q.
Given an inﬁnite word x, the inﬁnite sequence of states ρ = r0r1r2r3 . . . is
called an (inﬁnite) run of M on x if both r0 = q0 and ri+1 ∈δ(ri, ai) holds for all
i ≥1. By In(ρ), we denote the set of states that appear inﬁnitely often in ρ, namely
In(ρ) = {q ∈Q | ∀m ∃n > m rn = q}.
Equipped with an acceptance condition F, a ﬁnite state machine becomes a
ﬁnite state automaton M = (Q, Σ, δ, q0, F). It is a Büchi automaton (BA) when
F ⊆Q, and a Muller automaton when F ⊆2Q. A Büchi automaton (respectively
a Muller automaton) accepts x if for some inﬁnite run of M on x In(ρ) ∩F ̸= ∅
(respectively In(ρ) ∈F holds).
The ω-language accepted by an automaton is the set of all the inﬁnite words
that it accepts.
A classical result, essentially due to McNaughton [31], is that given any ω-language
L, the following are equivalent:
1. L is accepted by some deterministic Muller automaton,
2. L is accepted by some non-deterministic Muller automaton,
3. L is accepted by some non-deterministic Büchi automaton
3 Note that the enumeration x = x(1)x(2) . . . does not start at 0 so that we recover the empty
word as x[0].

The Wadge Hierarchy of Petri Nets ω-Languages
|
113
4. L is of the form L = 
i≤n UiVω
i , where each Ui, Vi are regular languages.
An ω-language that satisﬁes any of the above conditions is called an ω-regular
language (or a regular ω-language). We denote by REGω the class of all ω-regular
languages. We now move away from ﬁnite automata to consider partially blind
multicounter automata.
A multicounter automaton, at each step, may increment or decrement its
counters by a ﬁxed amount (a counter is a register that contains an integer). Such
a machine is blind if it cannot get any access to the content of its counters dur-
ing the computation – in other words, if every transition that is allowed when
some counter is non-empty, is also available when this counter is empty (and
vice versa). On ﬁnite words, blind multicounter automata need to empty all their
counters in order to accept. This characteristic gives them the power to recognize
the language of all words that contains the same numbers of 0’s and 1’s. A mul-
ticounter automaton is partially blind if, in addition to being blind, it also gets
stuck should one of its counters decrease below zero. Partially blind multicounter
automata are strictly more powerful machines than blind multicounter automata.
For instance they recognize the language of all the ﬁnite words w such that every
preﬁx of w contains no more 0’s than 1’s (see [23] for more details).
In order to get a partially blind multicounter automaton which accepts the
same language as a given Petri net, one can distinguish between the places of a
Petri net by dividing them into the bounded ones (the number of tokens in such
a place at any time is uniformly bounded) and the unbounded ones. Then each
unbounded place may be seen as a partially blind counter, and the tokens in the
bounded places determine the state of the partially blind multicounter automaton.
The transitions of the Petri net may then be seen as the ﬁnite control of the par-
tially blind multicounter automaton and the labels of these transitions are then
the input symbols.
On ω-words, allowing ε-transitions does not increase the expressive power of
deterministic Petri nets (contrary to what happens with non-deterministic Petri
nets, see [1]). For this reason, we restrict ourselves to the sole real time – i.e., ε-
transition free – partially blind multicounter automata. Also, there is no loss of
generality in assuming that every transition either adds or subtracts 1 or 0 to each
counter.
Deﬁnition 2. Let k be any nonzero integer. A (real time) deterministic k-partially
blind-counter machine (k-PBCM) is a 4-tuple
M = (Q, Σ, δ, q0)

114
|
J. Duparc, O. Finkel, and J.-P. Ressayre
where Q is a ﬁnite set of states, Σ is a ﬁnite input alphabet, q0 ∈Q is the initial
state, and the transition relation δ is a partial mapping from Q × Σ × {0, 1}k into
Q × {0, 1, −1}k.
A conﬁguration of a k-PBCM M is denoted by (q, c1, . . . , ck), where q ∈Q is
the control state and for every nonzero i ≤k, ci ∈N stands for the content of its
ith counter. A k-PBCM must satisfy the following conditions:
1. [Next conﬁguration] Given any a ∈Σ, and q, q′ ∈Q we write
a : (q, c1, . . . , ck) →M (q′, c1 + j1, . . . , ck + jk) when δ(q, a, i1, . . . , ik) is
deﬁned where im = 1 if cm > 0 and im = 0 otherwise and δ(q, a, i1, . . . , ik)
= (q′, j1, . . . , jk).
2.
[Blind counter] Whenever δ(q, a, i1, . . . , ik) is deﬁned and im
=
0 for
some m, 1 ≤m ≤k then δ(q, a, i1, . . . , im + 1, . . . , ik) is deﬁned and
δ(q, a, i1, . . . , im, . . . , ik) = δ(q, a, i1, . . . , im + 1, . . . , ik).
3.
[Non-negative counter] If δ(q, a, i1, . . . , ik) is deﬁned and im = 0 for some
m, 1 ≤m ≤k then δ(q, a, i1, . . . , ik) = (q′, j1, . . . , jk) with jm ∈{0, 1}.
Following Sheila Greibach in [23] we notice that blind multicounter machines
know nothing about their counters (this is what 2 suggests). However, partially
blind multicounter machines know something about their counters, namely by
substracting 1 and adding 1 they can determine whether they are nonzero. But
they cannot determine whether some of their counters are zero. As stated by 3, any
transition of a partially blind multicounter machine that would try to decrease
one of its counter below zero is undeﬁned, leading the machine to get stuck.
An ω-sequence of conﬁgurations ρ = (ri, ci
1, . . . ci
k)i∈N is called a complete
run of M on an ω-word x = a0a1a2 . . . an . . . over Σ if
–
(r0, c0
1, . . . c0
k) = (q0, 0, . . . , 0), and for all i ∈N
–
ai : (ri, ci
1, . . . ci
k) →M (ri+1, ci+1
1
, . . . ci+1
k
).
We let In(ρ) denote the set of all control states visited inﬁnitely often during the
complete run ρ.
Deﬁnition 3. A Büchi (resp. Muller) deterministic k-partially blind-counter au-
tomaton is some k-PBCM M′ = (Q, Σ, δ, q0), equipped with an acceptance condi-
tion F:
M = (Q, Σ, δ, q0, F).

The Wadge Hierarchy of Petri Nets ω-Languages
|
115
It is a Büchi (resp. Muller⁴) k-partially blind-counter automaton when F ⊆Q (resp.
F ⊆2Q), and it accepts x if the inﬁnite run of M′ on x meets the condition In(ρ) ∩
F ̸= ∅(respectively In(ρ) ∈F).
We let L(M) denote the ω-language accepted by M. We write BC(k) for the class of
ω-languages accepted by Muller deterministic k-partially blind-counter automata.
3 Borel and Wadge hierarchies
We assume the reader to be familiar with basic notions of topology and ordinals
(in particular the operations of multiplication and exponentiation) that can be
found in [26; 28] and in [41].
For any given ﬁnite alphabet X – with at least two diﬀerent letters – we con-
sider the topological space Xω equipped with the Cantor topology⁵. The open sets
of Xω are those of the form WXω, for some W ⊆X∗. The closed sets are the comple-
ments of the open sets. The class that contains both the open sets and the closed
sets, and is closed under countable union and intersection is the class of Borel sets.
It is nicely set up in a hierarchy by counting how many times these operations are
needed.
This deﬁnes the Borel Hierarchy: Σ0
1 is the class of open sets , and Π0
1 is the
class of closed sets. For any nonzero integer n, Σ0
n+1 is the class of countable
unions of sets inside Π0
n, while Π0
n+1 is the class of countable intersections of sets
inside Σ0
n. More generally, for any nonzero countable ordinal α, Σ0
α is the class of
countable unions of sets in 
γ<α Π0
γ , and Π0
α is the class of countable intersections
of sets in 
γ<α Σ0
γ.
We give without proofs a few basic results about Borel classes. Proofs may be
found in [25; 30].
Proposition 4. (a) Σ0
α ∪Π0
α ⊊Σ0
α+1 ∩Π0
α+1, holds for each countable ordinal
α ≥1.
(b) 
γ<α Σ0
γ = 
γ<α Π0
γ ⊊Σ0
α ∩Π0
α, holds for each countable limit ordinal α.
(c) A set W ⊆Xω belongs to Σ0
α iﬀXω ∖W belongs to Π0
α.
(d) Σ0
α ∖Π0
α ̸= ∅and Π0
α ∖Σ0
α ̸= ∅holds for every countable ordinal α ≥1.
4 The Muller acceptance condition was denoted 3-acceptance in [1; 27], and (inf , =) in [45].
5 The product topology of the discrete topology on X.

116
|
J. Duparc, O. Finkel, and J.-P. Ressayre
The Borel rank of a subset A of Xω is the least ordinal α ≥1 such that A belongs
to Σ0
α ∪Π0
α.
The Borel hierarchy turns into the very reﬁned Wadge Hierarchy with the use
of continuous pre-images.
Deﬁnition 5 (≤w, ≡w, <w). We let X, Y be two ﬁnite alphabets, and A ⊆Xω, B ⊆
Yω, A is said Wadge reducible to B (denoted A ≤W B) if and only if there exists
some continuous function f : Xω −→Yω that satisﬁes
∀x ∈X (x ∈A ⇔f(x) ∈B).
We write A ≡w B when both A ≤w B and B ≤w A hold, and A <w B when both
A ≤w B and B ̸≤w A hold.
We call a set A ⊆Xω self dual if A ≡W A∁is satisﬁed (where A∁stands for the
complement of A, namely A∁= A ∖Xω), and non-self dual otherwise⁶.
It is easy to verify that the relation ≤w is both reﬂexive and transitive, and
that ≡W is an equivalence relation. Now a topological class is a class that is closed
under continuous pre-images. Given any set A, the class of all its continuous pre-
images forms a topological class Γ called a Wadge class, and A is said to be Γ-
complete since it both belongs to Γ and (Wadge) reduces every element in it. It
follows that two sets are complete for the same topological class if and only if
they are Wadge equivalent. We write [A]W for the Wadge class generated by A. So
formally
[A]W = {B ⊆Xω | B ≤w A}.
From Proposition 4, we derive that Σ0
α (resp. Π0
α) is a Wadge class and any set
in Σ0
α ∖Π0
α (resp. Π0
α ∖Σ0
α) is Σ0
α-complete (resp. Π0
α-complete). Both Σ0
n-complete
and Π0
n-complete sets (any 0 < n < ω) are examined in [43].
The notion of Wadge reducibility is intricately related to game theory for con-
tinuous functions may be regarded as strategies for a given player involved in a
two-player game of perfect information and inﬁnite length:
Deﬁnition 6. Given any mapping f : Xω −→Yω, the game G(f) is a two-player
game where players take turn picking letters in X for I and Y for II, player I starting
the game, and player II being allowed in addition to pass her turn, while player I
is not. After ω-many moves, player I and player II have respectively constructed
6 Non-self dual sets are precisely those that do not satisfy A ≤w A∁.

The Wadge Hierarchy of Petri Nets ω-Languages
|
117
I
II
:
:
x0
x2
x3
x4
x5
x1
x2n
x2n+1
x2n+2
x2n+3
x ∈Xω and y ∈Y∗∪Yω. Player II wins the game if y = f(x), otherwise player I
wins.
So, in the game G(f), a strategy for player I is a mapping σ : (Y ∪{s})* −→X,
where s is a new letter not in Y that stands for II’s moves when she passes her
turn⁷. A strategy for player II is a mapping f : X+ −→Y ∪{s}. A strategy is called
winning if it ensures a win whatever the opponent does.
This game was designed to characterize the continuous functions.
Theorem 7 (Wadge). Let f : Xω −→Yω, the following are equivalent:
f is continuous ⇐⇒II has a winning strategy in G(f).
Proof. This is an easy exercise (see [30; 25]).
Deﬁnition 8. For A ⊆Xω and B ⊆Yω, the Wadge game W (A, B) is the same
game as G(f), except for the winning condition: II wins if and only if both y ∈Yω
and (x ∈A ⇐⇒y ∈B) hold.
A winning strategy for II in W (A, B) yields a continuous mapping f : Xω −→Yω
that guaranties A ≤w B, whereas any continuous function f that witnesses the
reduction relation A ≤w B gives rise to some winning strategy for II in G(f) that
is also winning for II in W (A, B).
Theorem 9 (Wadge). For A ⊆Xω and B ⊆Yω,
A ≤w B ⇐⇒II has a winning strategy in W (A, B) .
In 1975, Martin proved Borel determinacy [29; 25] which implies that as long as
both A and B are both Borel, either player I or player II has a winning strategy in
the Wadge game W (A, B).
As an immediate consequence we have the following lemma.
7 "s" stands for “skips".

118
|
J. Duparc, O. Finkel, and J.-P. Ressayre
Lemma 10 (Wadge). For any ﬁnite set X , and A, B ⊆Xω both Borel,
A ̸≤w B and B ̸≤w A =⇒A ≡w B∁.
Proof. By determinacy, from A ̸≤w B, it follows that I has a w.s. in W (A, B) which
gives a w.s. for II in W

B∁, A

which shows that B∁≤w A. By the same argument,
from B ̸≤w A, one derives A ≤w B∁.
Another immediate consequence of determinacy is Wadge’s Lemma.
Lemma 11 (Wadge). For any ﬁnite set X,
there are no three ≤w-incomparable Borel subsets of Xω.
Proof. Assume A, B, C ⊆Xω are all Borel ≤w-incomparable sets. By Lemma 10,
both A ≡w B∁and C ≡w B∁hold, which leads to A ≡w C.
We recall that a set S is well ordered by the binary relation < on S if and only if <
is a linear order on S such that there is no strictly inﬁnite <-decreasing sequence
of elements from S.
Theorem 12 (Martin-Monk). For X any ﬁnite set, there is no sequence (Ai)i∈ω of
Borel subsets of Xω such that the following holds:
A0 >w A1 >w A2 >w . . . An >w An+1 >w . . .
Proof. See [25; 49].
It follows that up to complementation and ≡W, the class of Borel subsets of Xω, is
well-ordered by <w. Therefore, there are a unique ordinal |WH| isomorphic to this
well-ordering and a mapping d0
W from the Borel subsets of Xω onto |WH|, such
that for all Borel subsets A, B:
–
d0
WA < d0
WB ⇔A <w B, and
–
d0
WA = d0
WB ⇔(A ≡w B or A ≡w B∁).
This well-ordering restricted to Borel sets of ﬁnite ranks⁸ has length the ﬁrst ﬁx-
point of the operation α −→ω1α [6; 49], where ω1 denotes the ﬁrst uncountable
ordinal.
8 The Borel sets of ﬁnite ranks are those in

n∈N
Σ0
n =

n∈N
Π0
n.

The Wadge Hierarchy of Petri Nets ω-Languages
|
119
In order to study the Wadge hierarchy of the class BC(k) we proceed as in [6]
and concentrate on the sole non-self dual sets. For this reason we slightly modify
the deﬁnition of the Wadge degree.
Deﬁnition 13. For A ⊆Xω, such that A >w ∅, we set
–
dw(∅) = dw(∅∁) = 1,
–
dw(A) = sup{dw(B) + 1 | B non-self dual and B <W A}.
Every ω-language which is accepted by a deterministic Petri net – more generally
by a deterministic X-automaton in the sense of [10] or by a deterministic Turing
machine – is a boolean combination of Σ0
2-sets. Therefore its Wadge degree – in-
side the whole Wadge hierarchy of Borel sets – is less than ωω
1 . Moreover, every
nonzero ordinal α < ωω
1 admits a unique Cantor normal form of base ω1 [41], i.e.,
it can be written as
α = ωnj
1 .δj + ωnj−1
1
.δj−1 + . . . + ωn1
1 .δ1
where ω > j > 0, ω > nj > nj−1 > . . . > n1 ≥0, and δj, δj−1, . . . , δ1 are nonzero
countable ordinals.
Since Wagner [50], it is well known that such an ordinal is the Wadge degree of
an ω-regular language if and only if the multiplicative coeﬃcients (δj, δj−1, . . . ,
δ1) are all integers. It is also known that such an ordinal is the Wadge degree of
a deterministic context-free ω-language if and only if these multiplicative coeﬃ-
cients are all below ωω [7]. Our purpose will be to add to the picture the following
results:
1. for every nonzero ordinal α whose Cantor normal form of base ω1 is
α = ωnj
1 .δj + ωnj−1
1
.δj−1 + . . . + ωn1
1 .δ1
where the multiplicative coeﬃcients δj, δj−1, . . . , δ1 are (nonzero) ordinals
less than ωk+1, for some integer k ≥1, there exists some ω-language L ∈
BC(k) whose Wadge degree is precisely α.
2. Every non-self dual ω-language in BC(k) has a Wadge degree of the above
form.
In the next section we introduce a few operations over sets of ω-words that will
prove extremely useful.

120
|
J. Duparc, O. Finkel, and J.-P. Ressayre
4 Operations over sets of ω-words
4.1 The sum
Deﬁnition 14. For {X+, X−} a partition in non-empty sets of XB ∖XA with XA ⊆
XB, A ⊆Xω
A, and B ⊆Xω
B , we deﬁne the addition to be.
B + A = A ∪X∗
AX+B ∪X∗
AX−B∁.
A player in charge of B + A in a Wadge game behaves as a player who begins the
play being in charge of A, and at any moment may also decide to start anew but
being in charge this time of either B or B∁. (The ﬁrst letter in XB ∖XA decides
between B or B∁).
Notice that given any ﬁnite alphabets X, Y that contain at least two letters
each, and any B ⊆Xω, there exists B′ ⊆Yω such that B ≡w B′. Moreover, if
B ∈BC(k) holds for some ﬁxed integer k, then B′ may be chosen in BC(k). It
follows that by abuse of notation we may write B + A when what we really mean
is B′ + A where B′ is any set that satisﬁes both B′ ≡w B and B′ ⊆Xω for some
alphabet X that strictly extends with at least two new letters the alphabet from
which A is taken from.
Proposition 15 (Wadge). For non-self dual Borel sets A and B,
dw(B + A) = dw(B) + dw(A).
Notice that this operation is associative: A + (B + C) ≡W (A + B) + C holds for
all non-self dual Borel sets A, B, C. Notice also that (B + A)∁≡w B + A∁is always
satisﬁed. Although BC(k) is not closed under complementation and B + A was
deﬁned with the help of B∁we will however allow the expression B + A ∈BC(k)
for A, B ∈BC(k) as long as there exists some C ∈BC(k) that satisﬁes C ≡w B∁.
4.2 The countable multiplication
In order to deﬁne the countable multiplication of an ω-language, we ﬁrst deﬁne
the supremum of a countable family of ω-languages:
Deﬁnition 16. For any bijection f : N −→I, any family (Ai)i∈I of non-self dual
Borel subsets of Xω, and any ﬁxed letter e ∈X,
sup
i∈I
Ai =

n∈N
(X ∖{e})neAf(n).

The Wadge Hierarchy of Petri Nets ω-Languages
|
121
Proposition 17. For (Ai)i∈I any countable family of non-self dual Borel subsets of
Xω with the following property ∀i ∈I ∃j ∈I Ai <w Aj, we have
1. supi∈I Ai is a non-self dual Borel subset of Xω, and
2. dw(supi∈I Ai) = sup{dw(Ai) | i ∈I}.
Proof. See [6; 7].
By combining the two operations of sum and supremum, we deﬁne the multiplica-
tion by a countable ordinal.
Deﬁnition 18. For A ⊆Xω, and 0 < α < ω1, A • α is inductively deﬁned by:
1. A • 1 = A
2. A • (ν + 1) = (A • ν) + A
3. A • β = supδ∈β A • δ when β is a limit ordinal.
By Propositions 15 and 17, this operation satisﬁes the following:
Proposition 19. Let A ⊆Xω be some non-self dual Borel set, and 0 < α < ω1,
dw(A • α) = dw(A) · α.
For a player in charge of A • α in a Wadge game, everything goes as if (s)he could
switch again and again between being in charge of A or A∁– starting anew every
time (s)he does so – but restrained from doing so inﬁnitely often by having to con-
struct a decreasing sequence of ordinals < α on the side every time (s)he switches.
This operation A −→A • α was denoted A −→Aˆ·α in [8].
4.3 The multiplication by ω1
Deﬁnition 20. For A ⊆Xω, and a, b /∈X two diﬀerent letters, Y = X ∪{a, b},
A • ω1 ⊆(X ∪{a, b})ω is deﬁned⁹ by
A • ω1 = A ∪Y∗aA ∪Y∗bA∁.
Inside a Wadge game, a player in charge of A•ω1 may switch indeﬁnitely between
being in charge of A or its complement, deleting what (s)he has already played
each time (s)he switches.
9 This operation was denoted A+ in [5], A −→Aˆ.∞in [8], and A −→A♮in [7].

122
|
J. Duparc, O. Finkel, and J.-P. Ressayre
Proposition 21. For any non-self dual Borel A ⊆Xω,
1. A • ω1 is non-self dual Borel, and
2. dw(A • ω1) = dw(A) · ω1.
Proof. See [6].
The following property will prove very useful.
Proposition 22. If A ⊆Xω is regular, then A • ω1 is also regular.
Proof. It follows directly from the deﬁnition of A • ω1 and the closure of the class
REGω under ﬁnite union, complementation, and left concatenation by ﬁnitary reg-
ular languages [8].
4.4 Canonical non-self dual sets
The empty set is an ω-language with Wadge degree 1 (dw(∅) = 1). It is non-self
dual, its complement has the same Wadge degree (dw(∅) = dw(Xω) = 1), and
these two are the only ω-languages with degree 1.
On the basis of the emptyset or its complement, the operations deﬁned above
provide non-self dual Borel sets for every Wadge degree < ωω
1 . For convenience,
given any A ⊆Xω we write A • ωn
1 for:
–
A • ω0
1 = A,
–
A • ωn+1
1
= (A • ωn
1) • ω1.
By Proposition 21, dw(A • ωn
1) = dw(A) · ωn
1 holds for every non-self dual Borel
A ⊆Xω. It follows immediately that the ω-language ∅• ωn
1 is a non-self dual Borel
set whose Wadge degree is exactly ωn
1.
Every nonzero ordinal α < ωω
1 admits a unique Cantor normal form of base
ω1 which is an expression of the form:
α = ωnj
1 · δj + ωnj−1
1
· δj−1 + . . . + ωn1
1 · δ1.
where ω > j > 0, ω > nj > nj−1 > . . . > n1 ≥0, and δj, δj−1, . . . , δ1 are nonzero
countable ordinals [41]. Following [6; 7], by mean of the set theoretical sum and
countable multiplication we deﬁne:
Ω(α) = (∅• ωnj
1 ) • δj + (∅• ωnj−1
1
) • δj−1 + . . . + (∅• ωn1
1 ) • δ1.
The result is dw(Ω(α)) = α. It follows from Propositions 15, 19, and 21.

The Wadge Hierarchy of Petri Nets ω-Languages
|
123
5 A hierarchy of BC(k)
From now on, we conﬁne ourselves to the sole ordinals α < ωω
1 whose Cantor
normal forms of base ω1 contain only multiplicative coeﬃcients less than ωk+1.
We construct for every such α some Muller deterministic k-partially blind-counter
automata Mα and M−
α such that both L(Mα) ≡W Ω(α) and L(M−
α ) ≡W Ω(α)∁
hold.
To start with, notice that for every integer n, since ∅• ωn
1 ∈REGω holds, there
exists some deterministic Muller automaton On = (Qn, Xn, δn, q0
n, Fn), where
Fn ⊆2Qn is the collection of designated state sets, such that L(On) = ∅• ωn
1.
Proposition 23. For any ω-regular language A, any integer j ≥1 there exist ω-
languages B, C ∈BC(j) such that
B ≡W (A • ωj) and C ≡W (A • ωj)∁.
Proof. Recall that being in charge of A • ωj in a Wadge game is the same as being
able to swap A and A∁, re-starting each time but also constructing step by step at
each swapping a strictly decreasing sequence < ωj on the side. Now any ordinal
α < ωj has a unique Cantor normal form of base ω:
α = ωj−1 · nj−1 + ωj−2 · nj−2 + . . . + ω1 · n1 + ω0 · n0.
where nj−1, nj−2, . . . , n1, n0 are (possibly null) integers . Then we see that j-many
partially blind counters suﬃce to keep track of the ordinal α: the ﬁrst counter
value is n0, the second counter value is n1, ..., the jth counter value is nj−1.
Let then A be an ω-regular language accepted by a deterministic Muller au-
tomaton, and A, A−be deterministic Muller automata such that L(A)∁= L(A−).
For any nonzero integer j we describe deterministic k-partially blind counter
automata Aωj and A−
ωj such that both L(Aωj) ≡w L(A) • ωj and L(A−
ωj) ≡w
L(A) • ωj∁hold.
We ﬁrst add the following new letters to the alphabet of A (and also A−):
↑0, ↑1, . . . , ↑j−1, ↓0, ↓1, . . . , ↓j−1, a, a−.
We describe Aωj (respectively A−
ωj) by the way it behaves when it reads an ω-word.
The reader may easily verify that the conditions below may be carried away by a
k-partially blind counter automaton.
The machine starts reading “up arrow" letters, i.e., those in {↑0, ↑1, . . . , ↑j−1}
(otherwise it simply rejects). As long as it does so, it increases the content of its
counters – ↑i stands for an increase by 1 of counter i – but if it does so inﬁnitely

124
|
J. Duparc, O. Finkel, and J.-P. Ressayre
often – that is the inﬁnite word x that it reads belongs to {↑0, ↑1, . . . , ↑j−1}ω – the
machine Aωj rejects while A−
ωj accepts.
Then, after the machine has read the whole preﬁx of “up arrow" letters, it
should encounter either the letter a+ or the letter a−(otherwise it rejects). If it
reads a+ (resp. a−) it starts working just like A (resp. A−). This goes on until even-
tually the machine reads a letter inside {↑0, ↑1, . . . , ↑j−1, ↓0, ↓1, . . . , ↓j−1, a, a−.}
If it is the case, then this letter has to be a “down arrow" of the form ↓i followed by
“up arrow" letters (possibly none) of the form ↑p for some p < i, followed by either
a+ or a−(otherwise both Aωj and A−
ωj rejects). When this word is of the form
↓i (↑p)la (resp. ↓i (↑p)la−), it decreases counter i by one and increases counter p
by l, then it works as A (resp. A−).
By playing the underlying Wadge games, the reader may easily verify that
both L(Aωj) ≡w L(A) • ωj and L(A−
ωj) ≡w (L(Aωj))∁hold.
Proposition 24. For any ω-regular language A, any integer k, and any ordinal
ωk ≤α < ωk+1, there exist ω-languages B, C ∈BC(k) such that
B ≡W (A • α) and C ≡W (A • α)∁.
Proof.
1. If 0 < α < ω, then from the very deﬁnition of the sum, it is immediate to see
that if A belongs to REGω, then both A•α and its complement belong to REGω.
2. If ω ≤α < ωk+1, we distinguish between two cases:
(a) If α = ωk, this was examined in Proposition 23.
(b) If ωk < α < ωk+1, then we consider the Cantor normal form of base ω of
α:
α = ωmj · nj + ωmj−1 · nj−1 + . . . + ωm0 · n0.
where k = mj > mj−1 > . . . > m0 holds, and nj, nj−1, . . . , n0 are all
nonzero integers.
By Proposition 23 and case 1, for each mi (0 ≤i ≤j) there are mi-partially
blind counter automata Aωmi and A−
ωmi such that L(Aωmi ) ≡w L(A) • ωmi
and L(A−
ωi) ≡w (L(Aωi))∁hold¹⁰. There is no loss of generality in assum-
ing that
i. for each i ≤j, both Aωmi and A−
ωmi are k-partially blind counter au-
tomata whose transition functions only deal with counters of the
10 The case mi = 0 corresponds to 0-partially blind counter automata Aω0 = A and A−
ω0 its
dual.

The Wadge Hierarchy of Petri Nets ω-Languages
|
125
form cl for 1 ≤l ≤mi leaving untouched the counters of the form cm
for mi < m ≤k.
ii. The alphabets of the diﬀerent machines do not overlap. Which means
that for 0 ≤h < i ≤j, if Σh, Σi denote the respective alphabets of
Aωmh , Aωmi (and equivalently of A−
ωmh , A−
ωmi ), then Σh ∩Σi = ∅
holds.
Moreover we set up Σ to be 
i≤j Σi, and ˇAωmi (resp. ˇA−
ωmi ) to be the ma-
chine that works on Σ – rather than on Σi – just like Aωmi (resp. A−
ωmi )
as long as it reads letters in Σi, and rejects as soon as it reads a letter in
Σ ∖Σi.
We consider two new letters t+, t−for transitions from a machine to an-
other, and we build Aα, A−
α as follows.
i. Aα starts working like ˇAωm0 (resp. A−
α starts like ˇA−
ωm0 ) as long as no
letter t+ nor t−is encountered.
ii. If a letter among {t+, t−} is encountered for the nth time for some
n < n0 + . . . + nj, we let i be the integer that satisﬁes
n0 + . . . + ni−1 < n + 1 ≤n0 + . . . + ni
if n > n0, and i = 0 otherwise. Then right after this letter is read and
until another transition letter (either t+ or t−) is eventually read:
–
if this letter is t+, Aα (resp. A−
α ) works as if it were ˇAωmi , and
–
if this letter is t−, Aα (resp. A−
α ) works as if it were ˇA−
ωmi .
iii. If a letter among {t+, t−} is encountered for the n0 + . . . + nth
j
time,
then Aα (resp. A−α) rejects.
The reader should notice that in case 2(b)ii when a machine hits a t+ or t−
letter, some of its counters may already have a nonzero content. But this
is not a problem since the initial phase of ˇAωmi (and ˇA−
ωmi as well) consists
in ﬁlling up these same counters plus eventually some extra ones. From
there, it is tedious but straightforward to verify that both Aα ≡w A•α and
A−
α ≡w A • α hold.
Theorem 25. Let α < ωω
1 be any ordinal whose Cantor normal form of base ω1 with
multiplicative coeﬃcients less than ωω:
α = ωnj
1 · δj + ωnj−1
1
· δj−1 + . . . + ωn0
1 · δ0
where ω > j ≥0, ω > nj > nj−1 > . . . > n0 ≥0, and ωω > δj, δj−1, . . . , δ0 > 0.

126
|
J. Duparc, O. Finkel, and J.-P. Ressayre
Let k be the least integer such that ∀i ≤j δi < ωk+1. Then there exist ω-
languages B, C ∈BC(k) such that
B ≡w Ω(α) and C ≡w Ω(α)∁.
We recall that Ω(α) is deﬁned by
Ω(α) = (∅• ωnj
1 ) • δj + (∅• ωnj−1
1
) • δj−1 + . . . + (∅• ωn0
1 ) • δ0.
Proof. For every i ≤j the set ∅• ωni
1 is ω-regular, so that for each integer i ≤j we
have machines Ai and Ai−such that L(Ai) ≡w ∅• ωni
1 and L(Ai−) ≡w (∅• ωni
1 )∁
hold for every i ≤j. The case j = 0 was already proved in Proposition 24, so that
we may assume that j > 0 holds.
Now we also consider for each i ≤j the “exact" ki-partially blind-counter
automata Ai
δi and Ai−
δi that were designed in the proof of Proposition 24. (Notice
that ki was deﬁned as the least integer such that δi < ωki+1.) We then form for each
i ≤j, some k-partially blind-counter automata ˆAi
δi and ˆAi−
δi which work exactly
the way Ai
δi and Ai−
δi do on the ﬁrst ki-many counters, leaving untouched the last
k −ki-many ones.
For simplicity – and without loss of generality – we may assume that both
Σh ∩Σi = ∅and Σi = Σ−
i hold for every 0 ≤h < i ≤j, where Σi, Σ−
i stand for the
respective alphabets of ˆAi
δi and ˆAi−
δi .
Then, for each i ≤j we form, some k-partially blind-counter automata ˇAi
δi and
ˇAi−
δi which work on the alphabet Σ = 
i≤j Σi. The machine ˇAi
δi (resp. ˇAi−
δi ) works
as ˆAi
δi (resp. ˆAi−
δi ) on the alphabet Σi, and both machines reject if they eventually
read a letter not in Σi.
At last we use new letters t+, t−for getting from one machine to another, and
we build Aα, A−
α as follows.
1. As long as neither t+ nor t−is encountered, Aα (resp. A−
α ) works as ˇA0
δ0 (resp.
ˇA0−
δ0 ).
2. If a letter among {t+, t−} is encountered for the ith time for some i < j, then
right after this letter is read and until another letter of the form t+ or t−is
eventually read:
–
if this letter is t+, Aα (resp. A−
α ) now behaves as if it were ˇAi
δi, and
–
if this letter is t−, Aα (resp. A−
α ) now behaves as if it were ˇAi−
δi .
3. If a letter among {t+, t−} is encountered for the jth, then both Aα and A−
α
reject right away.

The Wadge Hierarchy of Petri Nets ω-Languages
|
127
The result is L(Aα) ≡w Ω(α) and L(A−
α ) ≡w Ω(α)∁. We leave the tedious but
straightforward details to the reader.
6 Localisation of BC(k)
This section is dedicated to proving that no other Wadge class than the ones de-
scribed in Theorem 25 is generated by some non-self dual ω-language in BC(k).
As a preliminary, we present a technical result about the Wadge hierarchy, a few
others about ordinal combinatorics, and some notations.
For any A ⊆Xω and u ∈X∗, we write u−1A for the set {x ∈Xω | ux ∈A},
and we say that A is initializable if the second player has a w.s. in the Wadge game
W (A, A) even though she is restricted to positions u ∈X∗that satisfy u−1A ≡w A.
Lemma 26. For A ⊆Xω any initializable set, B ⊆Yω, and δ, θ any countable
ordinals,
A • (θ + 1) ≤w B ≤w A • δ =⇒∃u ∈Y∗





u−1B ≡w A • (θ + 1)
or
u−1B ≡w (A • (θ + 1))∁.
Proof. The case θ + 1 = δ is obvious since the empty word works for u. So in the
sequel we assume θ + 1 < δ. The proof goes by induction on δ.
Assume δ is limit.
1.If B ≡w A • δ, then clearly the set
{d0
Wu−1B : u ∈Y∗and u−1B <w B}
is unbounded in d0
W(A • δ) = d0
W(A) · δ. Hence there exists some ordinal
ξ < δ and some v ∈Y∗that both satisfy
A • (θ + 1) ≤w v−1B ≤w (A • ξ) <w A • δ
Then by induction hypothesis one gets some u′ ∈Y∗such that





u′−1v−1B ≡w A • (θ + 1)
or
u′−1v−1B ≡w (A • (θ + 1))∁
Hence u = vu′ works.
2.If B <w A • δ, then d0
W(B) < d0
W(A • δ) = d0
W(A) · δ. Hence, for some ξ < δ
we have
A • (θ + 1) ≤w B ≤w (A • ξ)

128
|
J. Duparc, O. Finkel, and J.-P. Ressayre
which gives the result using the induction hypothesis on ξ.
Assume δ is successor.
–
Assume δ = ζ + 2.
1. Assume (A • (ζ + 1))∁≤w B ≤w A • (ζ + 2).
We consider the following combination of Wadge games with 3 play-
ers : I, II and III:
*
I is in charge of ((A • ζ) + A∁) – which is Wadge equivalent to
(A • (ζ + 1))∁,
*
II is in charge of B, and
*
III is in charge of A • (ζ + 2).
II applies a w.s. that reduces I and III applies a w.s. that reduces II.
This means that if I plays x1, II plays x2 and III plays x3 then II re-
duces I if x1 ∈(A • ζ) + A∁⇐⇒x2 ∈B; and III reduces II if
x3 ∈A • (ζ + 2) ⇐⇒x2 ∈B.
Assume now that player I remaining in the right tail A∁(i.e. without
going into (A • ζ) or (A • ζ)∁) applies a winning strategy in the Wadge
game W(A∁, A) against Player III as long as III stays in the tail part A
of A • (ζ + 1) + A. Necessarily after a ﬁnite number of moves player
III exits the right most A and chooses (A • (ζ + 1))∁– for the other
choice A • (ζ + 1) would be a losing one. We let v be the position of
player II at that point, so that we obtain:
(A • (ζ + 1))∁≤w v−1B ≤w (A • (ζ + 1))∁,
hence
v−1B ≡w (A • (ζ + 1))∁.
If θ + 1 = ζ + 1 we are done. Otherwise we have
(A • (θ + 1))∁≤w v−1B∁≤w A • (ζ + 1)
By induction hypothesis there exists u extending v such that
u−1B∁≡w A • (θ + 1) or u−1B∁≡w (A • (θ + 1))∁
which gives
u−1B ≡w A • (θ + 1) or u−1B ≡w (A • (θ + 1))∁.
2. Assume B ≤w A • (ζ + 1).
Since ζ + 1 < δ holds, the result relies on the induction hypothesis
for
A • (θ + 1) ≤w B ≤w A • (ζ + 1).

The Wadge Hierarchy of Petri Nets ω-Languages
|
129
–
Assume δ = ζ + 1, ζ limit:
If B ≤w A•ζ holds the result follows from the induction hypothesis. Thus
we assume that the following holds:
(A • ζ)∁≤w B ≤w (A • ζ) + A
Now consider the following combination of Wadge games with 3 players
where:
*
I is in charge of (A • θ) + A + A + A∁(this is Wadge equivalent to
(A • (θ + 3))∁),
*
II is in charge of B, and
*
III is in charge of A • ζ + A.
II applies a w.s. that reduces I and III applies a w.s. that reduces II. Player
I applies a winning strategy in the Wadge game W(A∁, A) against Player
III as long as Player III remains in the tail part A of (A•ζ)+A. Necessarily
after a ﬁnite number of moves player III exits the ﬁrst A and chooses (A •
ζ)∁or (A • ζ).
Now notice that since A is non-self dual, the set {w ∈X∗| w−1A ≡w A}
is a tree – it is closed under preﬁxes – that contains an inﬁnite branch.
We let x be such an inﬁnite branch.
*
If x ∈A, then player I chooses to go into (A•θ+A+A)∁if III chooses
(A • ζ)∁and into (A • θ + A + A) if III chooses (A • ζ).
*
If x /∈A, then player I chooses to go into (A • θ + A + A) if III chooses
(A • ζ)∁and into (A • θ + A + A)∁if III chooses (A • ζ).
Then I plays along x, so that III is forced to choose A • γ for some γ < ζ
(by deﬁnition A • ζ = supγ<ζ A • γ). After III makes that choice, II is in a
position v that satisﬁes
A • (θ + 2)∁≤w v−1B ≤w A • γ or
A • (θ + 2) ≤w v−1B ≤w A • γ.
Therefore we obtain
A • (θ + 1) ≤w v−1B ≤w A • γ
which gives the result by induction hypothesis since γ < δ holds.
Lemma 27. We let B ⊆Yω, A ⊆Xω be any initializable set, and δ, θ be any
countable ordinals. We consider any set of the form
C = A • ωn
1 • νn + . . . + A • ωn−1
1
• νn−1 + . . . + A • ω1 • ν1
for any nonzero integer n, and countable coeﬃcients νn, νn−1, . . . , ν1 with at least
one of them being nonzero.

u−1B ≡w C + A • (θ + 1)
or
u−1B ≡w (C + A • (θ + 1))∁.
Proof. The proof is very similar to the one of Lemma 26, so we leave it to the reader.
We recall that for any set of ordinals O, its order type – denoted ot(O) – is the
unique ordinal that is isomorphic to O ordered by membership (which is nothing
but the usual ordering on ordinals).
Deﬁnition 28. The function H : ωω × ωω −→On is deﬁned by
H(α, β) = ωk · (lk + mk) + ωk−1 · (lk−1 + mk−1) + . . . + ω0 · (l0 + m0).
Where (a variation of the) the Cantor normal form of base ω of α (resp. β) is
α = ωk · lk + ωk−1 · lk−1 + . . . + ω0 · l0
β = ωk · mk + ωk−1 · mk−1 + . . . + ω0 · m0
with lk, mk, lk−1, mk−1, . . . , l0, m0 ∈N. (Some of these integers may be null¹¹.)
Lemma 29. Let H : ωω × ωω −→On, 0 < α′, α, β′β < ωω with α′ ≤α, β′ ≤β but
either α′ < α or β′ < β, then
H(α′, β′) < H(α, β).
Proof. This is tedious but straightforward, and left to the reader.
We make use of the mapping H to prove the following combinatorial result.
Lemma 30. Let α, β, γ be nonzero ordinals with α, β < ωω, and f : γ −→{0, 1}.
If both α = ot(f −1[0]) and β = ot(f −1[1]) hold, then γ ≤H(α, β).
Proof. The proof goes by induction on (max{α, β}, min{α, β}) ordered by lexico-
graphic ordering.
11 In particular, lk, lk−1, . . . mk, mk−1, . . . might be null, but since α, β > 0 holds, at least one
of the li’s, and one of the mi’s are diﬀerent from zero.
130
|
J. Duparc, O. Finkel, and J.-P. Ressayre
C+A•(θ+1) ≤w B ≤w C+A•δ =⇒∃u ∈Y∗





130
|
J. Duparc, O. Finkel, and J.-P. Ressayre

The Wadge Hierarchy of Petri Nets ω-Languages
|
131
1. If α = β = 1, then the result is immediate.
2. We assume α ≥β, and we let (α, β) be the <lex-least pair such that there exists
some ordinal γ together with f : γ −→{0, 1} that satisfy
–
α = ot(f −1[0]),
–
β = ot(f −1[1]), and
–
γ > H(α, β).
We consider the order types of the following two sets of ordinals:
(a) α′ = ot({θ < H(α, β) | f(θ) = 0}), and
(b) β′ = ot({θ < H(α, β) | f(θ) = 1}),
together with f ′ the restriction of f to H(α, β). Necessarily either α′ < α or
β′ < β holds. Therefore we have
(max{α′, β′}, min{α′, β′}) <lex (max{α, β}, min{α, β}).
Hence we get the ordinal γ′
= H(α, β), together with the mapping f ′
:
H(α, β) −→{0, 1} such that α′ = ot({θ < γ′ | f ′(θ) = 0}) and β′ = ot({θ <
γ′ | f ′(θ) = 1}). By Lemma 29, we obtain γ′ = H(α, β) > H(α′, β′) which
contradicts the induction hypothesis.
Corollary 31. Let k, n be nonzero integers, γ be any ordinal, 0 ≤α0, . . . , αk < ωn,
and f : γ −→{0, . . . , k}.
If ∀i ≤k αi = ot(f −1[i]) holds, then γ < ωn.
Proof. This is immediate from Lemma 30.
Lemma 32. Let k be some nonzero integer, (Nk, ≲) be a well-ordering such that
(a0, . . . , ak−1) ≲(b0, . . . , bk−1) =⇒







∀i < k
ai ≤bi
or
∃i, j < k ai < bi and aj > bj
holds for every k-tuples (a0, . . . , ak−1), (b0, . . . , bk−1) ∈Nk. Then, the order type
of (Nk, ≲) is at most ωk.
Proof. The proof goes by induction on k ≥1.
1. The initial case k = 1 is immediate since (N1, ≲) is nothing but the usual
ordering on integers.

132
|
J. Duparc, O. Finkel, and J.-P. Ressayre
2. We assume the result holds for k ≥1, and we show that it holds for k + 1.
Claim 33. For any integer n, the order type of the following set (ordered by ≲)
An = {(a0, a1, . . . , ak) ∈Nk+1 | (a0, a1, . . . , ak) < (n, n, . . . , n)}
is strictly below ω(k+1).
Proof. Notice that if (a0, a1, . . . , ak) < (n, n, . . . , n) holds then ai < n must
hold for some i ≤k + 1.
For each i ≤k + 1 and each j < n we consider
A(i,j) = {(a0, a1, . . . , ak) ∈Nk+1 | ai = j},
and α(i,j) = ot(A(i,j)) its order type (ordered by ≲). Notice that for
(a0, . . . , ai−1, j, ai+1, . . . , ak) ≲(b0, . . . , bi−1, j, bi+1, . . . , bk)
=⇒







∀l ∈{0, . . . , i −1, i + 1, . . . , k}
al ≤bl
or
∃l, m ∈{0, . . . , i −1, i + 1, . . . , k} al < bl and am > bm
Therefore by induction hypothesis, α(i,j) < ωk+1 holds for all i ≤k + 1 and
j < n. It follows from Corollary 31 that ot(An) < ωk+1 holds.
On the other hand for every integer n ≥0 it holds that (n, n, . . . , n) <
(n + 1, n + 1, . . . , n + 1). Moreover if n = max{a0, a1, . . . , ak} + 1 then
(a0, a1, . . . , ak) < (n, n, . . . , n). Therefore, the sequence (ot(An))n≥1 is coﬁ-
nal in ot(Nk+1) and thus the order type of (Nk+1, ≲) is at most ωk+1.
Lemma 34. We let k be any nonzero integer, B ∈BC(k), A ⊆Xω be any initializ-
able set, and δ any countable ordinal.
B ≤w A • δ =⇒B ≤w A • α for some α < ωk+1.
Notice that an immediate consequence is that B ≡w A • δ holds only for ordinals
δ < ωk+1.
Proof. First notice that for every B ⊆Xω, and every u ∈X∗, if B ∈BC(k) holds,
then u−1B ∈BC(k) holds too.
Towards a contradiction, we assume that A • α <w B ≤w A • δ holds for all
α < ωk+1. We let B be a k-partially blind counter automaton that recognizes B.

The Wadge Hierarchy of Petri Nets ω-Languages
|
133
By Lemma 26, for each successor ordinal α < ωk+1 there exists some uα ∈X∗
such that u−1
α B ≡w A • α or u−1
α B ≡w (A • α)∁. For each such uα, we form
(qα, cα,0, cα,1, . . . , cα,k−1) where qα denotes the control state that B is in after hav-
ing read uα, and cα,i the height of its counter number i (any i < k).
Now there exists necessarily some control state q such that
the order type of the set S = {α < ωk+1 | α successor and qα = q} is ωk+1.
Now, by Lemma 32 there exist α, α′ ∈S such that α′ < α holds together with
cα,i ≤c′
α,i holds for all i < k. (Without loss of generality, we may even assume
that ω ≤α′ < α holds.) Let us denote B′
α the k-partially blind counter automaton
B that starts in state (qα′, cα′,0, cα′,1, . . . , cα′,k−1), and Bα the one that starts in
state (qα, cα,0, cα,1, . . . , cα,k−1). Notice that since cα,i ≤c′
α,i holds for all i < k,
Bα′ performs exactly the same as Bα except when the latter crashes for it tries
to decrease a counter that is already empty. But it is then not diﬃcult to see that
given the above assumption – that ω ≤α′ < α holds – u−1
α B ≤w u−1
α′ B holds
which leads to either A • α ≤w A • α′ or (A • α)∁≤w A • α′. In both cases, it
contradicts α′ < α.
Notice that the set ∅• ωn
1 is initializable, so we have in particular the following
result.
Lemma 35. For k, n any integers, A any non-self dual ω-language in BC(k), and
any nonzero countable ordinal α,
A or A∁≡w (∅• ωn
1) • α =⇒α < ωk+1.
In a similar way, we can now state the following lemma.
Lemma 36. We let k be any nonzero integer, B ∈BC(k), A ⊆Xω be any initializ-
able set, δ be any countable ordinal, and C be any set of the form
C = A • ωn
1 • νn + . . . + A • ωn−1
1
• νn−1 + . . . + A • ω1 • ν1
for any nonzero integer n, and countable multiplicative coeﬃcients νn, νn−1, . . . , ν1
with at least one of them being nonzero.
B ≤w C + A • δ =⇒B ≤w C + A • α for some α < ωk+1.
Proof. The proof is very similar to the one of Lemma 34, so we leave it to the reader.

134
|
J. Duparc, O. Finkel, and J.-P. Ressayre
Theorem 37. Let k be any nonzero integer, B ⊆Xω be non-self dual. If B ∈BC(k),
then either B or B∁is Wadge equivalent to some
Ω(α) = (∅• ωnj
1 ) • δj + (∅• ωnj−1
1
) • δj−1 + . . . + (∅• ωn0
1 ) • δ0.
where j ∈N, nj > nj−1 > . . . > n0 and ωk+1 > δj, δj−1, . . . , δ0 > 0.
Proof. This is an almost immediate consequence of Lemmas 34 and 36.
This settles the case of the non-self dual ω-languages in BC(k). For the self-dual
ones, it is enough to notice the easy following:
1. Given any A ⊆Xω, if A ∈BC(k) is self dual, then there exists two non-self
dual sets B, C ⊆Xω such that both B and C belong to BC(k), B ≡w C∁, and
A ≡w X0B ∪X1C, where {X0, X1} is any partition of X in two non-empty sets.
2. If A ⊆Xω and B ⊆Xω are non-self dual, satisfy A ≡w B∁, and both belong to
BC(k), then, given any partition of X in two non-empty sets {X0, X1}, X0A ∪
X1B is self-dual, and also belongs to BC(k).
As a consequence, we obtain the following general result if we come back to the
original deﬁnition of the Wadge degree of a set (denoted d◦) – from which we
slightly departed from to deﬁne dW – namely:
Deﬁnition 38. For A ⊆Xω, we set
d◦(A) = sup{d◦(B) + 1 | B <W A}.
(Notice that this deﬁnition implies d◦(∅) = d◦(∅∁) = 0.)
Theorem 39. For any A ⊆Xω, there exists an ω-language B ⊆Xω recognized by
some deterministic Petri net, such that A ≡w B if and only if d◦A is of the form
α = ωn
1 · δn + . . . + ω0
1 · δ0.
for some n ∈N, and ωω > δn, . . . , δ0 ≥0.
From where we immediately obtain the following:
Corollary 40. The height of the Wadge hierarchy of ω-languages recognized by
deterministic Petri nets is (ωω)ω = ωω2.

The Wadge Hierarchy of Petri Nets ω-Languages
|
135
7 Conclusions
We provided a description of the extension of the Wagner hierarchy from automata
to deterministic Petri Nets with Muller acceptance conditions. Of course the re-
sults would be rigorously the same if we replace Muller acceptance conditions
with parity acceptance conditions. But with Büchi acceptance conditions instead,
it becomes even simpler since the ω-languages are no more boolean combinations
of Σ0
2-sets, but Π0
2-sets. So, the whole hierarchy comes down to the following:
Corollary 41. For any A ⊆Xω, there exists an ω-language B ⊆Xω recognized by
some deterministic Petri net with Büchi acceptance conditions, such that A ≡w B
if and only if either
–
d◦A = ω1, and A is Π0
2-complete, or
–
d◦A < ωω.
Deciding the degree of a given ω-language in BC(k), for k ≥2, recognized by
some deterministic Petri net – either with Büchi or Muller acceptance conditions,
remains an open question. Notice that for k = 1 this decision problem has been
shown to be decidable in [13].
Another rather interesting open direction of research is to go from deter-
ministic to non-deterministic Petri nets. It is clear that this step forward brings
new Wadge classes – for instance there exist ω-languages recognized by non-
deterministic Petri nets with Büchi acceptance conditions that are Σ0
3-complete,
hence not ∆0
3, [21] – but the description of this whole hierarchy still requires more
investigations.
Bibliography
[1]
H. Carstensen. Inﬁnite behaviour of deterministic Petri nets. In Proceedings of Mathe-
matical Foundations of Computer Science 1988, volume 324 of Lecture Notes in Computer
Science, pages 210–219. Springer, 1988.
[2]
O. Carton and D. Perrin. Chains and superchains for ω-rational sets, automata and
semigroups. International Journal of Algebra and Computation, 7(7):673–695, 1997.
[3]
O. Carton and D. Perrin. The Wagner hierarchy of ω-rational sets. International Journal of
Algebra and Computation, 9(5):597–620, 1999.
[4]
R. Cohen and A. Gold. ω-computations on Turing machines. Theoretical Computer Science,
6:1–23, 1978.
[5]
J. Duparc. La forme Normale des Boréliens de rang ﬁnis. PhD thesis, Université Paris VII,
1995.

136
|
J. Duparc, O. Finkel, and J.-P. Ressayre
[6]
J. Duparc. Wadge hierarchy and Veblen hierarchy: Part 1: Borel sets of ﬁnite rank. Journal of
Symbolic Logic, 66(1):56–86, 2001.
[7]
J. Duparc. A hierarchy of deterministic context free ω-languages. Theoretical Computer
Science, 290(3):1253–1300, 2003.
[8]
J. Duparc, O. Finkel, and J.-P. Ressayre. Computer science and the ﬁne structure of Borel
sets. Theoretical Computer Science, 257(1–2):85–105, 2001.
[9]
J. Duparc, O. Finkel, and J.-P. Ressayre. The Wadge hierarchy of Petri nets ω-languages. In
Proceedings of the International Symposium on Logical Foundations of Computer Science,
LFCS 2013, volume 7734 of Lecture Notes in Computer Science, pages 179–193. Springer,
2013.
[10] J. Engelfriet and H. J. Hoogeboom. X-automata on ω-words. Theoretical Computer Science,
110(1):1–51, 1993.
[11] J. Esparza. Decidability and complexity of Petri net problems, an introduction. Lectures on
Petri Nets I: Basic Models, pages 374–428, 1998.
[12] H. Fernau and R. Stiebe. Blind counter automata on ω-words. Fund. Inform., 83(1-2):51–64,
2008.
[13] O. Finkel. An eﬀective extension of the Wagner hierarchy to blind counter automata. In
Proceedings of Computer Science Logic, 15th International Workshop, CSL 2001, volume
2142 of Lecture Notes in Computer Science, pages 369–383. Springer, 2001.
[14] O. Finkel. Topological properties of omega context free languages. Theoretical Computer
Science, 262(1–2):669–697, 2001.
[15] O. Finkel. Wadge hierarchy of omega context free languages. Theoretical Computer Science,
269(1–2):283–315, 2001.
[16] O. Finkel. Borel hierarchy and omega context free languages. Theoretical Computer Science,
290(3):1385–1405, 2003.
[17] O. Finkel. Borel ranks and Wadge degrees of context free omega languages. Mathematical
Structures in Computer Science, 16(5):813–840, 2006.
[18] O. Finkel. Wadge degrees of inﬁnitary rational relations. Special Issue on Intensional
Programming and Semantics in honour of Bill Wadge on the occasion of his 60th cycle,
Mathematics in Computer Science, 2(1):85–102, 2008.
[19] O. Finkel. The complexity of inﬁnite computations in models of set theory. Logical Methods
in Computer Science, 5(4:4):1–19, 2009.
[20] O. Finkel. Highly undecidable problems for inﬁnite computations. Theoretical Informatics
and Applications, 43(2):339–364, 2009.
[21] O. Finkel. On the topological complexity of ω-languages of non-deterministic Petri nets.
2012. Preprint.
[22] O. Finkel. Topological complexity of context free ω-languages: A survey. In Language,
Culture, Computation: Studies in Honor of Yaacov Choueka, Lecture Notes in Computer
Science. Springer, 2013. To appear, available from http://fr.arxiv.org/abs/0806.1413.
[23] S. Greibach. Remarks on blind and partially blind one way multicounter machines. Theoret-
ical Computer Science, 7:311–324, 1978.
[24] J. E. Hopcroft, R. Motwani, and J. D. Ullman. Introduction to automata theory, languages,
and computation. Addison-Wesley Publishing Co., Reading, Mass., 2001. Addison-Wesley
Series in Computer Science.
[25] A. S. Kechris. Classical descriptive set theory. Springer-Verlag, New York, 1995.
[26] K. Kuratowski. Topology. Academic Press, New York, 1966.

The Wadge Hierarchy of Petri Nets ω-Languages
|
137
[27] L. Landweber. Decision problems for ω-automata. Mathematical Systems Theory, 3(4):376–
384, 1969.
[28] H. Lescow and W. Thomas. Logical speciﬁcations of inﬁnite computations. In J. W.
de Bakker, W. P. de Roever, and G. Rozenberg, editors, A Decade of Concurrency, volume
803 of Lecture Notes in Computer Science, pages 583–621. Springer, 1994.
[29] D. A. Martin. Borel determinacy. The Annals of Mathematics, 102(2):363–371, 1975.
[30] Y. N. Moschovakis. Descriptive set theory, volume 155. American Mathematical Society,
2009.
[31] R. M. Naughton. Testing and generating inﬁnite sequences by a ﬁnite automaton. Informa-
tion and Control, 9:521–530, 1966.
[32] D. Perrin and J.-E. Pin. Inﬁnite words, automata, semigroups, logic and games, volume 141
of Pure and Applied Mathematics. Elsevier, 2004.
[33] G. Rozenberg. Lectures on concurrency and Petri nets: advances in Petri nets, volume 3098.
Springer Verlag, 2004.
[34] V. Selivanov. Fine hierarchy of regular ω-languages. In Proceedings of the International
Joint Conference on the Theory and Practice of Software Development TAPSOFT-95, in
Aarhus, Denmark, volume 915 of Lecture Notes in Computer Science, pages 277–287.
Springer, 1995.
[35] V. Selivanov. Fine hierarchy of regular ω-languages,. Theoretical Computer Science,
191:37–59, 1998.
[36] V. Selivanov. Wadge degrees of ω-languages of deterministic Turing machines. In
Proceedings of the International Conference STACS 2003, 20th Annual Symposium on
Theoretical Aspects of Computer Science, Berlin, Germany, volume 2607 of Lecture Notes
in Computer Science, pages 97–108. Springer, 2003.
[37] V. Selivanov. Wadge degrees of ω-languages of deterministic Turing machines. RAIRO-
Theoretical Informatics and Applications, 37(1):67–83, 2003.
[38] V. Selivanov. Fine hierarchies and m-reducibilities in theoretical computer science.
Theoretical Computer Science, 405(1-2):116–163, 2008.
[39] V. Selivanov. Fine hierarchy of regular aperiodic omega-languages. International Journal of
Foundations of Computer Science, 19(3):649–675, 2008.
[40] V. Selivanov. Wadge reducibility and inﬁnite computations. Special Issue on Intensional
Programming and Semantics in honour of Bill Wadge on the occasion of his 60th cycle,
Mathematics in Computer Science, 2(1):5–36, 2008.
[41] W. Sierpinski. Cardinal and ordinal numbers. PWN (Warszawa), 1965.
[42] P. Simonnet. Automates et théorie descriptive. PhD thesis, Université Paris VII, 1992.
[43] L. Staiger. Hierarchies of recursive ω-languages. Elektronische Informationsverarbeitung
und Kybernetik, 22(5-6):219–241, 1986.
[44] L. Staiger. Research in the theory of ω-languages. Journal of Information Processing and
Cybernetics, 23(8-9):415–439, 1987. Mathematical aspects of informatics (Mägdesprung,
1986).
[45] L. Staiger. ω-languages. In Handbook of formal languages, Vol. 3, pages 339–387.
Springer, Berlin, 1997.
[46] L. Staiger and K. Wagner. Rekursive Folgenmengen. I. Z. Math. Logik Grundlag. Math.,
24(6):523–538, 1978.
[47] W. Thomas. Automata on inﬁnite objects. In J. van Leeuwen, editor, Handbook of Theoretical
Computer Science, volume B, Formal models and semantics, pages 135–191. Elsevier,
1990.

138
|
J. Duparc, O. Finkel, and J.-P. Ressayre
[48] R. Valk. Inﬁnite behaviour of Petri nets. Theoretical computer science, 25(3):311–341, 1983.
[49] W. Wadge. Reducibility and determinateness in the Baire space. PhD thesis, University of
California, Berkeley, 1983.
[50] K. Wagner. On ω-regular sets. Information and Control, 43(2):123–177, 1979.
[51] T. Wilke and H. Yoo. Computing the Wadge degree, the Lifschitz degree, and the Rabin
index of a regular language of inﬁnite words in polynomial time. In P. Mosses, M. Nielsen,
and M. Schwartzbach, editors, TAPSOFT 95, volume 915 of Lect. Notes in Comp. Sci., pages
288–302. Springer Verlag, Berlin, Heidelberg, New York, 1995.

Willem L. Fouché
Diophantine Properties of Brownian Motion:
Recursive Aspects¹
Abstract: We use recent results on the Fourier analysis of the zero sets of Brow-
nian motion to explore the diophantine properties of an algorithmically random
Brownian motion ( also known as a complex oscillation). We discuss the construc-
tion and deﬁnability of perfect sets which are linearly independent over the ratio-
nals directly from Martin-Löf random reals. Finally we explore the recent work
of Tsirelson on countable dense sets to study the diophantine properties of local
minimisers of Brownian motion.
Keywords: Brownian motion, Fourier dimension, algorithmic randomness, addi-
tive structure in fractals
Mathematics Subject Classiﬁcation 2010: 68Q30, 03D30, 60D99
||
Willem L. Fouché: Department of Decision Sciences, University of South Africa, Pretoria, South
Africa
1 Introduction
A Brownian motion on the unit interval is algorithmically random if it meets all
eﬀective (Martin-Löf) statistical tests, now expressed in terms of the statistical
events associated with Brownian motion on the unit interval. The class of func-
tions corresponds exactly, in the language of Weihrauch [24; 25], Gács [11] and
specialised by Hoyrup and Rojas [13], in the context of algorithmic randomness,
to the Martin-Löf random elements of the computable measure space
R = (C0[0, 1], d, B, W),
where C0[0, 1] is the set of the continuous functions on the unit interval that van-
ish at the origin, d is the metric induced by the uniform norm, B is the countable
set of piecewise linear functions vanishing at the origin with slopes and points
of non-diﬀerentiability all rational numbers and where W is the Wiener measure.
We shall also refer to such a Brownian motion as a complex oscillation. This termi-
1 Dedicated to Victor Selivanov on the occasion of his 60th birthday.

140
|
Willem L. Fouché
nology was suggested to the author by the following Kolmolgorov theoretic inter-
pretation of this notion [1; 2]: One can characterise a Brownian motion which is
generic (in the sense just stated) as an eﬀective and uniform limit of a sequence
(xn) of “ﬁnite random walks”, where, moreover, each xn can be encoded by a ﬁ-
nite binary string sn of length n, such that the (preﬁx-free) Kolmogorov complex-
ity, K(sn), of sn satisﬁes, for some constant d > 0, the inequality K(sn) > n −d
for all values of n. (See Deﬁnition 3, introduced by Asarin and Prokovskiy [2], in
Section 3 below.) We shall study the images of certain ultra-thin sets (perfect sets
of Hausdorﬀdimension zero) under a complex oscillation. We have shown in [6]
that these images are perfect sets whose elements are linearly independent over
the ﬁeld of rational numbers. In this paper we discuss the deﬁnability of these
sets, within the recursion-theoretic hierarchy, by exploiting the recursive isomor-
phism constructed in [5] between the Kolmogorov-Chaitin random reals and the
class of suitably encoded versions of complex oscillations. We shall also utilise
Tsirelson’s theory of countable dense random sets [23] to study the diophantine
properties of the local minimisers of Brownian motion. The local minimizers of a
complex oscillation is studied in [7].
We shall utilise recent results by Mukeru and the author [8] on the rate of
decay of the Fourier transform of the delta function of a continuous version of
Brownian motion to identify some diophantine properties of the zero set of a com-
plex oscillation. For more on the Fourier and consequent Diophantine properties
of the sample paths of Brownian motion the reader is referred to the paper by Łaba
and Pramanik [15]. We shall also show that some of these phenomena can be ex-
pressed within the hyperaritmetical hierarchy and pose the problem as to whether
this is essentially so.
The author is very grateful to the Department of Mathematics at the Corvi-
nus University, Budapest, for hosting my frequent visits to the department and
for teaching and sharing with me so much of the subtleties of measure theory and
stochastic processes.
This research is being partially supported by the National Research Founda-
tion (NRF) of South Africa as well as by a Marie Curie International Research Staﬀ
Exchange Scheme Fellowship (COMPUTAL PIRSES-GA-2011-294962) within the 7th
European Community Framework Programme.

Diophantine Properties of Brownian Motion: Recursive Aspects
|
141
2 Preliminaries from Brownian motion and
geometric measure theory
A random variable X with mean µ and variance σ2 is normal if it has a density
function of the form
1
√
2π σ e−(t−µ)2/2σ2.
If (Ω, F, P) is a probability space and X is a real-valued random variable on Ω, the
measure µ on F given by
F →P(X−1(F)), F ∈F,
is called the distribution of X.
A Brownian motion on the unit interval is a real-valued function (ω, t) →
Xω(t) on Ω× [0, 1], where Ωis the underlying space of some probability space,
such that Xω(0) = 0 a.s. and for t1 < . . . < tn in the unit interval, the random vari-
ables Xω(t1), Xω(t2)−Xω(t1), · · · , Xω(tn)−Xω(tn−1) are statistically independent
and normally distributed with means all 0 and variances t1, t2 −t1, · · · , tn −tn−1,
respectively.
It is a fundamental fact that any Brownian motion has a “continuous ver-
sion”(see, for example [10]). This means the following: Write Σ for the σ-algebra of
Borel sets of C[0, 1] where the latter is topologised by the uniform norm topology.
There is a unique probability measure W on Σ such that for 0 ≤t1 < . . . < tn ≤1
and for a Borel subset B of Rn, we have
P({ω ∈Ω: (Xω(t1), · · · , Xω(tn)) ∈B}) = W(A),
where
A = {x ∈C[0, 1] : (x(t1), · · · , x(tn)) ∈B}).
The measure W is known as the Wiener measure. We shall usually write X(t) in-
stead of Xω(t).
For a compact subset A of Euclidean space Rd and real numbers α, ϵ with
0 ≤α < d and ϵ > 0, consider all coverings of A by balls Bn of diameter ≤ϵ and
the corresponding sums

n
|Bn|α,
where |B| denotes the diameter of B. All the metric notions here are to be under-
stood in terms of the standard ℓ2 norms on Euclidean space. The inﬁmum of the
sums over all coverings of A by balls of diameter ≤ϵ is denoted by Hϵ
α(A). When

142
|
Willem L. Fouché
ϵ decreases to 0, the corresponding Hϵ
α(A) increases to a limit (which may be in-
ﬁnite). The limit is denoted by Hα(A) and is called the Hausdorﬀmeasure of A in
dimension α.
If 0 < α < β ≤d, then, for any covering (Bn) of A,

n
|Bn|β ≤sup
n
|Bn|β−α 
n
|Bn|α,
from which it follows that
Hϵ
β(A) ≤ϵβ−αHϵ
α(A).
Hence if Hα(A) < ∞, then Hβ(A) = 0. Equivalently,
Hβ(A) > 0 =⇒Hα(A) = ∞.
Therefore,
sup{α : Hα(A) = ∞} = inf{β : Hβ(A) = 0}.
This common value is called the Hausdorﬀdimension of A and denoted by dimhA.
If α is such that 0 < Hα(A) < ∞, then α = dimhA. However, if α = dimhA, we
cannot say anything about the value of Hα(A).
It is easy to check that A →Hα(A) deﬁnes an outer measure which is invariant
under translations and rotations, and homogeneous of degree α with respect to
dilations.
If A is a Borel subset of Euclidean space, the set of non-zero Radon measures
with support contained in A is denoted by M+(A). For a given µ ∈M+(A), the
energy integral of µ with respect to the kernel |x|−α is given by
Iα(µ) =

Rd

Rd
dµ(x)dµ(y)
|x −y|α
.
We say that µ has ﬁnite energy with respect to |x|−α when Iα(µ) < ∞. If A carries
positive measures of ﬁnite energy with respect to |x|−α we say that A has positive
capacity with respect to |x|−α and we write
Capα(A) > 0.
If A carries no positive measure of ﬁnite energy with respect to |x|−α, we say that
A has capacity zero with respect to this kernel and we write Capα(A) = 0.
It follows from the Fourier analysis of temperate distributions that
Iα(µ) = C(α, d)

Rd
|ˆµ(ξ))|2|ξ|α dξ
|ξ|d ,
(1)

Diophantine Properties of Brownian Motion: Recursive Aspects
|
143
when 0 < α < d, where C(α, d) is a positive constant and where, moreover,
ˆµ(ξ) =

Rd
eisξ dµ(s),
is the Fourier transform of the measure µ. (For a proof see Chapter 12 of[17].)
We shall make frequent use of the following very fundamental fact.
Proposition 1. For a compact subset A of Rd and 0 < α < β < d,
Hβ(A) > 0 ⇒Capα(A) > 0 ⇒Hα(A) > 0.
Hence
sup{α : Capα(A) > 0} = dimhA,
or, equivalently,
sup{α : Iα(µ) < ∞} = dimhA.
A proof of this proposition can be found in Chapter 8 of [17], for example.
The Fourier dimension of a compact set E is the supremum of positive real
numbers α < 1 such that for some non-zero Borel measure µ supported by E , it is
the case that
|ˆµ(ξ)|2 ≤
1
|ξ|α ,
for |ξ| suﬃciently large. The Fourier dimension of E is denoted by dimf (E). Clearly,
by (1),
dimf (E) ≤dimh(E),
(2)
for all compact sets E. The set is called a Salem set if dimf (E) = dimh(E).
The following question posed by Beurling was addressed and solved in the
aﬃrmative by Salem [21] in 1950.
Given a number α ∈(0, 1), does there exist a compact set E on the line whose
Hausdorﬀdimension is α that carries a Borel measure µ whose Fourier trans-
form
ˆµ(u) =

R
eiuxdµ(x)
is dominated by |u|−α/2 as |u| →∞?
It follows from (1) and (2) that given a compact subset E of [0, 1] with Hausdorﬀ
dimension α ∈(0, 1), the number α/2 is critical for this question to have an aﬃr-
mative answer. Of course, such a set E will be a Salem set.

144
|
Willem L. Fouché
Salem proved this result by constructing for every α in the unit interval, a ran-
dom measure µ (over a convenient probability space) whose support E has Haus-
dorﬀdimension α and which satisﬁes the Beurling-requirement with probability
one.
It was recently shown [9] by the author, in collaboration with George Davie
and Safari Mukeru, that such sets can also be constructed by looking at Cantor
type ternary sets E with computable ratios ξ and then to consider the image of E
under a complex oscillation.
The following theorem illustrates the rich diophantine structure of sets E of
non-zero Fourier dimension. Even though the proof method is well-known in ge-
ometric measure theory, we give a full proof, for we need sharper estimates than
what we could ﬁnd in the literature.
Theorem 2. (Folklore) Suppose E is a compact subset of reals such that, for every
ϵ > 0, there is some µ ∈M+(E) and 0 < α < 1, such that, for some constant C = C(ϵ),
it is the case that
|ˆµ(ξ)|2 ≤C|ξ|−α+ϵ,
as |ξ| →∞. Then, if k is a natural number such that kα > 1, it will follow, upon
writing
Ek = E + · · · + E (k times),
that
R =

n<ω
n(Ek −Ek).
Moreover, if A is any ﬁnite set of real numbers, then Ek will contain an aﬃne (a
translated and rescaled) copy of A.
Proof. Set
ν = µ ∗· · · ∗µ (k times).
(Here ∗denotes the convolution product.) Clearly, by choosing ϵ > 0 such that
k(α −ϵ) > 1 + ϵ, we have , for |ξ| large,
|ˆν(ξ)|2 = |ˆµ(ξ)2|k ≤Ck|ξ|−kα+kϵ ≤Ck|ξ|−1−ϵ.
It follows that the function ˆν is in L2(R). Since ν is a non-zero measure, it follows
from Parseval’s theorem that ν is absolutely continuous with respect to Lebesgue
measure. In particular, supp ν has non-zero Lebesgue measure. Since
supp ν ⊂Ek,

Diophantine Properties of Brownian Motion: Recursive Aspects
|
145
we conclude that Ek has non-zero Lebesgue measure. It follows from Steinhaus’s
theorem [22] that Ek −Ek has zero as an interior point. This concludes the ﬁrst part
of the theorem.
The second part follows from the following beautiful remark [15]: If F is any
set of positive Lebesgue measure, then F will contain an aﬃne copy of any ﬁnite
set A of real numbers. This is, as noted by Łaba and Pramanik [15], a consequence
of Lebesgue’s density theorem.
3 Complex oscillations
The set of non-negative integers is denoted by ω and we write B for the Cantor
space {0, 1}ω. The set of words over the alphabet {0, 1} is denoted by {0, 1}∗. If
a ∈{0, 1}∗, we write |a| for the length of a. If α = α0α1 . . . is in B, we write α(n)
for the word 
j<n αj. We use the usual recursion-theoretic terminology Σ0
r and Π0
r
for the arithmetical subsets of ωk × Bl, k, l ≥0. (See, for example, [12]). We write
λ for the Lebesgue probability measure on B. For a binary word s of length n, say,
we write [s] for the “interval” {α ∈B : α(n) = s}. A sequence (an) of real numbers
converges eﬀectively to 0 as n →∞if for some total recursive f : ω →ω, it is the
case that |an| ≤(m + 1)−1 whenever n ≥f(m).
For any ﬁnite binary word a we denote its (preﬁx-free) Kolmogorov complexity
by K(a). Recall that an inﬁnite binary string α is Kolmogorov-Chaitin complex if
∃d∀n K(α(n)) ≥n −d.
(3)
In the sequel, we shall denote this set by KC and refer to its elements as KC-strings.
The KC-strings are also referred to Martin-Lö or algorithmically random real num-
bers. (See, e.g., [3], [16] or [19] for more background.)
For n ≥1, we write Cn for the class of continuous functions on the unit
interval that vanish at 0 and are linear with slopes ±√n on the intervals [(i −
1)/n, i/n] , i = 1, . . . , n. With every x ∈Cn, one can associate a binary string
a = a1 · · · an by setting ai = 1 or ai = 0 according to whether x increases or de-
creases on the interval [(i −1)/n, i/n]. We call the sequence a the code of x and
denote it by c(x). The following notion was introduced by Asarin and Prokovskiy
in [2].
Deﬁnition 3. A sequence (xn) in C[0, 1] is complex if xn ∈Cn for each n and there
is a constant d > 0 such that K(c(xn)) ≥n −d for all n. A function x ∈C[0, 1] is a
complex oscillation if there is a complex sequence (xn) such that ∥x−xn∥converges
eﬀectively to 0 as n →∞.

146
|
Willem L. Fouché
The class of complex oscillations is denoted by C.
In [5] the author constructed a bijection Φ : KC →C which is eﬀective in the
following sense: If α ∈KC and m < ω, one can eﬀectively construct from the ﬁrst
m bits of α, a function pm, where pm is a ﬁnite linear combination of piecewise
linear functions with rational coeﬃcients, such that, for some absolute positive
constant C, the complex oscillation Φ(α) is approximated by the sequence (pm)
as follows:
supt∈[0,1]|Φ(α)(t) −pm(t)| ≤C log m/
√m
(4)
for all m > Mα, where Mα is a constant that depends on α only. Conversely, if
x ∈C, then one can compute, relative to an inﬁnite binary string which encodes
the values of a complex oscillation x at the rational numbers in the unit interval,
the KC-string α such that Φ(α) = x.
In [5] the author proved that these results have the following implication:
Theorem 4. There is a uniform algorithm that, relative to any KC-string α, with
input a rational number t in the unit interval and a natural number n, will output
the ﬁrst n bits of the the value of the complex oscillation Φ(α) at the value t.
This result plays a crucial rôle in this paper, for it will enable us to show how
the sample path properties of a complex oscillation Φ(α) (and hence of a typical
Brownian motion) can be described within the arithmetical hierarchy relative to
the associated KC-string α. In this way, as was stated in the introduction of this pa-
per, one ﬁnds an explicit unfolding of the incredibly rich geometry that is enfolded
in every KC-string α by merely regarding such an α as an encoding of a complex
oscillation or, equivalently, of an (eﬀectively) generic Brownian motion.
The mapping Φ is also a measure-theoretic isomorphism in the following
(standard) sense: Write λ for the Lebesgue measure on the space {0, 1}ω and
write W for the Wiener measure on C[0, 1]. Then, for any Borel subset A of C[0, 1]
with the uniform norm topology, we have
λ(Φ−1(A)) = W(A).
In other words, W is the pushout of λ under Φ. We shall frequently denote Φ(α)
by xα.
We follow [4] to deﬁne an analogue of a Π0
2 subset of C[0, 1] which is of con-
structive measure 0. If F is a subset of C[0, 1], we denote by F its topological clo-
sure in C[0, 1] with the uniform norm topology. For ϵ > 0, we let Oϵ(F) be the ϵ-ball
{f ∈C[0, 1] : ∃g∈F∥f −g∥< ϵ} of f. (Here ∥.∥denotes the supremum norm.) We
write F0 for the complement of F and F1 for F.

Diophantine Properties of Brownian Motion: Recursive Aspects
|
147
Deﬁnition 5. A sequence F0 = (Fi : i < ω) in Σ is an eﬀective generating sequence
if
1. for F ∈F0, for ϵ > 0 and δ ∈{0, 1}, we have, for G = Oϵ(Fδ) or for G = Fδ,
that W(G) = W(G),
2. there is an eﬀective procedure that yields, for each sequence 0 ≤i1 < . . . <
in < ω and k < ω a binary rational number βk such that
|W(Fi1 ∩. . . ∩Fin) −βk| < 2−k,
3. for n, i < ω, a strictly positive rational number ϵ and for x ∈Cn, both the
relations x ∈Oϵ(Fi) and x ∈Oϵ(F0
i ) are recursive in x, ϵ, i and n, relative to
an eﬀective representation of the rationals.
If F0 = (Fi : i < ω) is an eﬀective generating sequence and F is the Boolean alge-
bra generated by F0, then there is an enumeration (Ti : i < ω) of the elements of F
(with possible repetition) in such a way, for a given i, one can eﬀectively describe
Ti as a ﬁnite union of sets of the form
F = Fδ1
i1 ∩. . . ∩Fδn
in
where 0 ≤i1 < . . . < in and δi ∈{0, 1} for each i ≤n. We call any such sequence
(Ti : i < ω) a recursive enumeration of F. We say in this case that F is eﬀectively
generated by F0 and refer to F as an eﬀectively generated algebra of sets.
Let (Ti : i < ω) be a recursive enumeration of the algebra F which is eﬀectively
generated by the sequence F0 = (Fi : i < ω) in Σ. It is shown in [4] that there is an
eﬀective procedure that yields, for i, k < ω, a binary rational βk such that
|W (Ti) −βk| < 2−k,
in other words, the function i →W(Ti) is computable.
A sequence (An) of sets in F is said to be F-semirecursive if it is of the form
(Tϕ(n)) for some total recursive function ϕ : ω →ω and some eﬀective enumera-
tion (Ti) of F. (Note that the sequence (Ac
n), where Ac
n is the complement of An, is
also an F-semirecursive sequence.) In this case, we call the union ∪nAn a Σ0
1(F)
set. A set is a Π0
1(F)-set if it is the complement of a Σ0
1(F)-set. It is of the form
∩nAn for some F-semirecursive sequence (An). A sequence (Bn) in F is a uniform
sequence of Σ0
1(F)- sets if, for some total recursive function ϕ : ω2 →ω and some
eﬀective enumeration (Ti) of F, each Bn is of the form
Bn =

m
Tϕ(n,m).
In this case, we call the intersection ∩nBn a Π0
2(F)-set. If, moreover, the Wiener-
measure of Bn converges eﬀectively to 0 as n →∞, we say that the set given by
∩nBn is a Π0
2(F)-set of constructive measure 0.

148
|
Willem L. Fouché
The proof of the following theorem appears in [4].
Theorem 6. Let F be an eﬀectively generated algebra of sets. If x is a complex
oscillation, then x is in the complement of every Π0
2(F)-set of constructive measure
0.
This means, that every complex oscillation is, in an obvious sense, F-Martin-Löf
random.
Deﬁnition 7. An eﬀectively generated algebra of sets F is universal if the class C of
complex oscillations is deﬁnable by a single Σ0
2(F)-set, the complement of which
is a set of constructive measure 0. In other words, F is universal iﬀa continuous
function x on the unit interval is a complex oscillation iﬀx is F-Martin-Löf random.
We introduce two classes of eﬀectively generated algebras G and M which are very
useful for reﬂecting properties of one-dimensional Brownian motion into complex
oscillations.
Let G0 be a family of sets in Σ each having a description of the form:
a1X(t1) + · · · + anX(tn) ≤L
(5)
or of the form (5) with ≤replaced by <, where all the aj, tj (0 ≤tj ≤1) are non-zero
rational numbers, L is a recursive real number and X is one-dimensional Brown-
ian motion.
We require that it be possible to ﬁnd an enumeration (Gi : i < ω) of G0 such
that, for given i, if Gi is given by (5), we can eﬀectively compute the sign, the de-
nominators and numerators of the rational numbers aj, tj and, moreover, that the
recursive real L can be computed up to arbitrary accuracy.
It is shown in [5] that G0 = (Gi : i < ω) is an eﬀective generating sequence
in the sense of Deﬁnition 5. The associated eﬀectively generated algebra of sets G
will be referred to as a gaussian algebra.
It is shown in [4] that if G0 is deﬁned by events of the form (5) with n = 1 and
a1 = 1, then the associated G is in fact universal in the sense of Deﬁnition 7.
We shall also make frequent use of the following result from [4] which is an
easy consequence of Theorem 6. It is the analogue, for continuous functions, of
the well-known fact that Martin-Löf random reals are in fact Kurtz-random.
Theorem 8. If B is a Σ0
1(F) set and W(B) = 1, then C, the set of complex oscilla-
tions, is contained in B.

Diophantine Properties of Brownian Motion: Recursive Aspects
|
149
4 Diophantine properties of zero sets of Brownian
motion and complex oscillations
The following result is proven in [8].
Theorem 9. (Fouché and Mukeru). Let X be a continuous version of one-dimen-
sional Brownian motion on the unit interval. Then, almost surely, there exists a
nonzero Radon measure µ with support on ZX, the zero set of X, such that its
Fourier transform ˆµ satisﬁes the inequality
|ˆµ(ξ)|2 ≪ϵ |ξ|−1
2 +ϵ,
(6)
as |ξ| →∞. In particular, the zero-set of Brownian motion is almost surely a Salem
set.
It would be interesting to study the existence of arithmetic propgressions in the
zero sets of X. This question is related to the results obtained in Section 8 of [15]
by Łaba and Pramanik.
By Theorem 2, the preceding theorem has the following consequence:
Theorem 10. For a continuous version X of Brownian motion over the unit interval,
we have, almost surely,
R =
∞

n=1
n(YX −YX),
where
YX = ZX + ZX + ZX,
and ZX is the zero set of X. Moreover, almost surely, for any ﬁnite set A of real num-
bers, the set YX will contain an aﬃne (rescaled and translated) copy of A.
We now investigate the extent to which this result can be reﬂected in every com-
plex oscillation. For a ﬁxed r ∈R deﬁne the subset Ωr of C[0, 1] by:
X ∈Ωr ↔∃n∃z1,...,z6∈ZX
r = n((z1 + z2 + z3) −(z4 + z5 + z6)).
It follows from the preceding that each Ωr has Wiener measure one. For a real r and
a natural number ℓ, let Ir,ℓbe any interval of length ≤1
ℓwith rational endpoints
which contains r.
For a real r, a continuous function X on the unit interval and an natural num-
ber ℓdeﬁne the predicate P(r, ℓ, X) by:
P(r, ℓ, X)
↔
∃n∃t1,...,t6∈[0,1]∩Q

n((t1 + t2 + t3) −(t4 + t5 + t6)) ∈Ir,ℓ

∧

150
|
Willem L. Fouché
∀1≤i≤6 |X(ti)| < 1
ℓ.
Note that for ﬁxed r and ℓthe predicate P(r, ℓ, X) is Σ0
1(G) for some (ﬁxed) gaussian
algebra G.
Our next aim is to show, for nonzero r:
X ∈Ωr →∀ℓP(r, ℓ, X).
This will have the implication that for ﬁxed r, ℓ, the predicate P deﬁnes a Σ0
1(G)–
set of Wiener measure one so that in particular P(r, ℓ, x) will also hold for each
complex oscillation x.
For X ∈Ωr and ℓ≥1 let n be a natural number and z1, . . . , z6 be zeroes of X
such that r = n((z1 + z2 + z3)−(z4 + z5 + z6)). Next choose t1, . . . , t6 ∈[0, 1]∩Q
suﬃciently close to z1, . . . , z6 to ensure that both |n((t1 + t2 + t3) −(t4 + t5 +
t6)) −r| < 1
ℓand |X(ti)| < 1
ℓfor i = 1, . . . , 6 holds. Consequently, we can deduce
P(r, ℓ, X) for all ℓ.
We have proven
Theorem 11. If x is a complex oscillation and r is a real number then
∀ℓ∃n∃t1,...,t6∈[0,1]∩Q

|n((t1 + t2 + t3) −(t4 + t5 + t6)) −r| < 1
ℓ

∧
∀1≤i≤6 |x(ti)| < 1
ℓ.
Denote the predicate in Theorem 11 by P(x, r). It follows that the set deﬁned B by
x ∈B ↔∀rP(x, r)
contains all the complex oscillations. Deﬁne Q(x, r) as P(x, r) but with the ﬁrst
two quantiﬁers interchanged. Then
R =

n<ω
n(Yx −Yx) ↔∀rQ(x, r).
Itis an open problem whether the predicate ∀rQ(x, r) deﬁnes a set that will contain
all complex oscillations.
5 Hamel sets generated by complex oscillations
For the historical background to and a Fourier-analytical perspective on the re-
sults of this section, the reader is referred to Chapter 5 of the book by Rudin [20].

Diophantine Properties of Brownian Motion: Recursive Aspects
|
151
A perfect subset of the unit interval is called a Hamel set, if its elements are
linearly independent over the ﬁeld of rational numbers, or, equivalently, if it is a
perfect subset of some Hamel basis of the reals over the rationals. Our aim is to
show how Hamel sets can be generated by complex oscillations. Our results are
inspired by the arguments on pages 255-257 of Kahane [14].
Set
E =

1
2 +
∞

k=2
ϵk
1
2k2 : ϵk ∈{−1, 1} for all k

.
(7)
In [6], the author proved:
Theorem 12. If x is a complex oscillation then the elements of the image x(E) of
the set E under x will be linearly independent over the ﬁeld of rational numbers.
Our next aim is to show how one can use this theorem together with Theorem 4 to
ﬁnd deﬁnitions of Hamel sets within the arithmetical hierarchy. For ℓ≥2, set
Dℓ=

1
2 +
ℓ

k=2
ϵk
1
2k2 : ϵk ∈{−1, 1} for all k = 2, . . . , ℓ

.
Write D = ∪ℓ≥2Dℓ. Note that the topological closure of D is D ∪E We begin by
proving
Proposition 13. If α ∈KC, then
z ∈xα(E) ↔∀m∃n>m∃t∈Dn|xα(t) −z| < 1
2n .
(8)
Proof: Suppose z = xα(t) where α ∈KC and t ∈E is given by
t = 1
2 +
∞

k=2
ϵk
1
2k2 .
For n ≥1 set
tn = 1
2 +
n

k=2
ϵk
1
2k2 .
It follows from Proposition 1 in [5] that for some constant C > 1 and n suﬃciently
large it is the case
|xα(tn) −z| ≤C|tn −t|
1
2 log
1
|tn −t| .
Since |tn −t| ≤
1
2n2 we conlude that for all n suﬃciently large
|xα(tn) −z| < 1
2n .

152
|
Willem L. Fouché
Conversely, suppose that z, α satisfy the predicate on the right-hand side of (8).
With each m, we associate an n = n(m) > m such that |xα(tn) −z| <
1
2n for some
tn ∈Dn. The sequence (t(m)) has some convergent sequence with a limit τ say.
Clearly τ ∈E, and by the continuity of xα, we can conclude that xα(τ) = z. This
concludes the proof of the Proposition.
Note that
|xα(t) −z| < 1
2n ↔∃k|xα(t)(k) −z(k)| < 1
2n −2
2k ,
the right-hand side being Σ0
1 in α, z, t and n. Consequently
Theorem 14. There is a Π0
2-formula Q(α, z) deﬁned over KC × {0, 1}ω such that
z ∈xα(E) ↔Q(α, z).
Let Ωbe any ∆0
2-element of KC (a Chaitin real). Then Q(λiΩ(i), z) is a Π0
3-predicate
in z that deﬁnes a Hamel set. We have proven
Theorem 15. There is a Π0
3-predicate R(z) over {0, 1}ω and a Hamel set K such
that
R(z) ↔z ∈K .
6 Further developments and an open problem
We write S∞for the symmetric group of a countable set . We place on S∞the
pointwise convergence topology thus giving S∞the subspace topology under its
embedding into the Baire space NN. The group S∞acts naturally (and continu-
ously) on (0, 1)∞
̸= :
σ.(uj : j ≥1) := (uσ−1(j) : j ≥1),
for all (uj) ∈(0, 1)∞
̸= and σ ∈S∞. The orbit space under this action is denoted by
(0, 1)∞
̸= /S∞. The Borel structure on this space is given by the topology induced by
the canonical mapping
π : (0, 1)∞
̸= −→(0, 1)∞
̸= /S∞.
Let Ωbe a standard Borel space. A strongly random countable set in the unit in-
terval is a measurable mapping X : Ω→(0, 1)∞
̸= /S∞that factors through some
(traditional) random sequence Y as shown:

Diophantine Properties of Brownian Motion: Recursive Aspects
|
153
Ω
(0, 1)∞
̸= /S∞
(0, 1)∞
̸=
X
Y
π
One can think of X as a random countable set induced via S∞-equivalence, by a
random sequence Y, both in the unit interval. Denote the Borel space (0, 1)∞
̸= /S∞
by CS(0, 1).
If X is a continuous function on the unit interval, then a local minimizer of X
is a point t such that there is some closed interval I ⊂[0, 1] containing t such that
the function X assumes a minimum value on I at the point t. We denote by MIN(X)
the set of local minimizers of X.
It is well-known that if X is a continuous version of Brownian motion on the
unit interval, then MIN(X) is almost surely a dense and countable set and that all
the local minimizers of X are strict. This means that, for each closed subinterval I
of the closed unit interval, there is a unique ν ∈I where the minimum of X on I is
assumed.
This has the implication that there is a subset Ω0 of C[0, 1] of full Wiener mea-
sure such that one can deﬁne a measurable mapping min : C[0, 1] ⊃Ω0 −→
(0, 1)∞
̸= in such a way that the composition of min with the projection π will deﬁne
a mapping X →MIN(X). In the sequel this strongly random set will be denoted
by MIN. To summarise, we have the following commutative diagram:
C[0, 1] ⊃Ω0
(0, 1)∞
̸= /S∞
(0, 1)∞
̸=
MIN
min
π
Let (mk) be any random enumeration of the local minimizers of a continuous ver-
sion of Brownian motion in the unit interval .
Let q > 2 and for k ≥1 set
sk = (1 + mk).

154
|
Willem L. Fouché
Theorem 16. The sequence (sk) is linearly independent over Q.
Proof: For standard measure spaces (Ω1, P1) and (Ω2, P2), let there be some Pi-
measurable strongly random variable Xi : Ωi →CS(0, 1) such that the induced
probability distributions on CS(0, 1) are the same.
We say in this case that the strongly random sets X1 and X2 are statistically
similar relative to the probabilities P1, P2 and we write X1 ∼X2. This means ex-
actly that
P1(X−1
1 (Σ)) = P2(X−1
2 (Σ)),
for all Borel subsets Σ of CS(0, 1).
Write λ∞for the product measure on (0, 1)∞which is the countable product
of the Lebesgue measure λ on the unit interval and write Λ for the measure on
CS(0, 1) which is the pushout of λ∞under π. In other words, for a Borel subset Σ
of CS(0, 1),
Λ(Σ) = λ∞(π−1Σ).
Write U : (0, 1)∞→CS(0, 1) for the strongly random set as deﬁned by the follow-
ing commutative diagram:
(0, 1)∞
̸=
CS(0, 1) = (0, 1)∞
̸= /S∞
(0, 1)∞
̸=
U
Id
π
In [23] Tsirelson proved the truly remarkable result that
MIN ∼U.
(9)
The theorem with the uniform sequence (uk) replacing the local minimizers (mk)
is known to be true. (See pages 256-260 in Meyer [18].) Hence the theorem follows
from the statistical similarity of MIN and U and the fact that the notion of linear
independence over Q of a sequence of reals is preserved under the action of S∞
on the space of real sequences.
Remark. In statistics U is known as a model of an unordered uniform inﬁnite
sample. Moreover, it follows from the Hewitt-Savage theorem that, for every Borel
subset Σ of CS(0, 1), it is the case that
Λ(Σ) ∈{0, 1}.
(10)

Diophantine Properties of Brownian Motion: Recursive Aspects
|
155
Note that Λ is non-atomic. As has been noted before [23], this shows that the well-
known fact that CS(0, 1) is not a standard Borel space, is a direct consequence of
a frequently used fact in statistics.
Open problem. In [7] the author showed how the local minimizers of a complex
oscillation Φ(α) can be computed from a KC-string α. This opens the possibility
of ﬁnding analogues of Theorem 16 for complex oscillations.
Let us call a continuous function x on the unit interval strongly random if
it belongs to every Σ0
2(G) set of Wiener measure one, for some gaussian algebra
G. The set of strongly random functions is a subclass of the complex oscillations.
By using the constructions in [7], it can be shown that the sk associated with a
strongly random function will be linearly independent over the rationals. Whether
this result can be extended to complex oscillations, is an open problem.
Bibliography
[1]
Asarin, E.A.: Individual random signals: an approach based on complexity, doctoral
dissertation, Moscow State University, 1988
[2]
Asarin, E. A. and Prokovskiy, A. V.: Use of the Kolmogorov complexity in analysing control
system dynamics, Automation Remote Control 47 (1986) 21-28. Translated from: Primee-
nenie kolmogorovskoi slozhnosti k anlizu dinamiki upravlemykh sistem, Automatika i
Telemekhanika (Automation Remote Control) 1 (1986) 25-33.
[3]
Chaitin, G. A.: Algorithmic information theory, Cambridge University Press, 1987.
[4]
Fouché, W. L.: Arithmetical representations of Brownian motion I, J. Symb. Logic 65 (2000),
421-442.
[5]
Fouché, W. L.: The descriptive complexity of Brownian motion, Advances in Mathematics
155, (2000), 317-343
[6]
Fouché, W. L.: Fractals generated by algorithmically random Brownian motion, K. Ambos-
Spies, B. Löwe, and W. Merkle (Eds.): CiE 2009, LNCS 5635 (2009), 208-217.
[7]
Fouché, W. L.: Kolmogorov complexity and the geometry of Brownian motion. Accepted by
Mathematical Structures in Computer Science.
[8]
Fouché, W. L. and Mukeru S.: On the Fourier structure of the zero set of fractional Brown-
ian motion, Statistics and Probability Letters 83 (2013), 459-466.
[9]
Fouché, W. L., Mukeru, S. and Davie, G.: Fourier spectra of measures associated with
algorithmically random Brownian motion. Submitted.
[10] Freedman, D.: Brownian motion and diﬀusion, (second edition) Springer-Verlag, New York,
1983.
[11]
Gács, P.: Uniform test of algorithmic randomness over a general space, Theoretical Com-
puter Science 341 (2005), 91-137.
[12] Hinman, P. G.: Recursion-theoretic hierarchies, Springer-Verlag, New York, 1978.
[13] Hoyrup, M. , Rojas, C.: Computability of probability measures and Martin-Löf randomness
over metric spaces, Information and Computation 207 (2009), 830-847.
[14] Kahane, J. -P.: Some random series of functions (second edition), Cambridge University
Press, 1993.

156
|
Willem L. Fouché
[15]
Łaba I., and Pramanik, M.: Arithmetical progressions in sets of fractional dimension,
Geometric and Functional Analysis, 19 (2009), 429-456.
[16] Martin-Löf, P.: The deﬁnition of random sequences, Information and Control 9 (1966),
602-619.
[17]
Mattila, P.: Geometry of sets and measures in Euclidean spaces, Cambridge University
Press, 1995.
[18] Meyer, Y.: Algebraic numbers and harmonic analysis, North Holland, Amsterdam, 1972.
[19] Nies, A.: Computability and randomness, Oxford Logic Guides 51, Clarendon Press, Ox-
ford, 2008.
[20] Rudin, W.: Fourier Analysis on Groups, Interscience Publishers, New York - London, 1960.
[21] Salem, R.: On singular monotonic functions whose spectrum has a given Hausdorﬀ
dimension, Ark Mat 1 (1950), 353-365.
[22] Steinhaus, H.: Sur les distances des distances des ensemble de mesure positive, Fund
Math 1 (1920), 93-104.
[23] Tsirelson, S.: Brownian local minima, random dense countable sets and random equiva-
lence classes, Electronic Journal of Probability 11 (2006), 162-198.
[24] Weihrauch, K.: Computability on the probability measures on the Borel sets of the unit
interval, Theoretical Computer Science 219 (1999), 421-437.
[25] Weihrauch, K.: Computable Analysis, Springer, Berlin, 2000.

Sy-David Friedman
The Completeness of Isomorphism¹
Abstract: This paper provides a survey of results concerning the complexity of the
isomorphism relation when restricted to classes ranging from the class of com-
putable structures to the class of arbitrary countable structures. The aim is to de-
termine in which cases this relation is Σ1
1-complete.
Keywords: countable structure, computable structure, isomorphism, hierarchy,
completeness.
Mathematics Subject Classiﬁcation 2010: 03C57, 03C75, 03D45, 03D60, 03E15,
03E45
||
Sy-David Friedman: Kurt Gödel Research Center, University of Vienna, Austria
In classical descriptive set theory, analytic equivalence relations (i.e., Σ1
1 equiv-
alence relations with parameters) are compared under the relation of Borel re-
ducibility (for example, see [5]). An important subclass of the Σ1
1 equivalence re-
lations are the isomorphism relations, i.e., the restrictions of the isomorphism re-
lation on countable structures (viewed as an equivalence relation on reals coding
such structures) to the models of a sentence of the inﬁnitary logic Lω1ω. Scott’s
Theorem implies that the equivalence classes of any isomorphism relation are
Borel, and therefore no isomorphism relation can be complete (under Borel re-
ducibility) within the class of Σ1
1 equivalence relations as a whole, some of which
contain non-Borel equivalence classes. (This is clariﬁed below.)
The picture is diﬀerent in the computable setting. It is shown in [2] that iso-
morphism on computable structures (viewed as an equivalence relation on nat-
ural numbers coding such structures), indeed on computable trees, is complete
for Σ1
1 equivalence relations under the natural analogue of Borel-reducibility for
equivalence relations on numbers: E0 is reducible to E1 iﬀfor some computable
f : N →N, E0(m, n) iﬀE1(f(m), f(n)) for all m, n.
In this article we survey the situation for classes of structures between the
class of computable structures and the class of arbitrary countable structures. Our
1 The author would like to congratulate Professor Victor Selivanov on the occasion of his 60th
birthday for his broad and signiﬁcant contributions to the ﬁeld of mathematical logic. He also
wishes to thank the FWF (Austrian Science Fund) for its generous support of this research through
Project P 22430-N13.

158
|
Sy-David Friedman
aim is to determine in which cases isomorphism is complete and in which cases
it is not.
Work has also been done by considering not arbitrary isomorphisms, but iso-
morphisms of a restricted type (such as computable or hyperarithmetic isomor-
phism). For this I refer the reader to [3].
1 Classes of structures
To discuss classes of structures intermediate between the class of computable
structures and the class of arbitrary countable structures we make use of the L-
hierarchy. We ﬁx a computable ﬁrst-order language and consider structures for
that language with universe ω. Assume V = L; thus every structure is deﬁnable
over Lα for some inﬁnite countable ordinal α.
For pairs (α, n) where α is an inﬁnite countable ordinal, 0 < n ∈ω, deﬁne:
X(α, n) = all reals (subsets of ω) which are ∆n deﬁnable over Lα
Also when α is a countable ordinal greater than ω we deﬁne:
X(α, 0) = all reals (subsets of ω) which are elements of Lα
Now ﬁx α, n as above and let E be an equivalence relation on reals which is
Σ1
1 with parameter from X(α, n). We say that E is complete on X(α, n) iﬀwhenever
F is another such equivalence relation there exists a function f from reals to reals
sending X(α, n) into X(α, n) such that for x, y ∈X(α, n):
F(x, y) iﬀE(f(x), f(y)),
where f is Hyp (i.e. ∆1
1) in a parameter from X(α, n).
Note that isomorphism (viewed as an equivalence relation on reals coding
countable structures) is a parameter-free Σ1
1 equivalence relation.
Main Question 1. For which α, n is isomorphism complete on X(α, n)?
2 When isomorphism is complete
The basic positive result from [2] reads as follows.
Theorem 2. ([2]) Isomorphism is complete on X(ω, 1), the set of computable reals.
Roughly speaking, the proof goes as follows. Suppose that E(m, n) is a Σ1
1 equiv-
alence relation on computable reals with a computable parameter; we can trans-

The Completeness of Isomorphism
|
159
late E into a Σ1
1 equivalence relation E′ on natural numbers without parameter.
By Kleene’s Representation Theorem choose a computable sequence (T(m, n) |
m, n ∈ω) of computable trees such that E′(m, n) iﬀT(m, n) is ill-founded. Us-
ing “rank-saturated” trees (see [1]) we can assume that the isomorphism type of
T(m, n) depends only on the rank of T(m, n) (which is ∞if T(m, n) is ill-founded).
The main trick is to ensure that this rank depends only on the E′-equivalence
classes of m, n. Then by deﬁning T∗(m) to be the “join” of the T(m, n), n ∈ω,
we obtain: E′(m0, m1) iﬀT∗(m0) is isomorphic to T∗(m1). For the details see [2].
Now using a Hyp function which takes a computable real to a Turing-index for it,
we obtain the desired Hyp reduction of E to isomorphism on computable struc-
tures.
Now Theorem 2 clearly relativises to a real parameter. Say that isomorphism
is complete on the p-computable reals (where p is a real parameter) iﬀwhenever
E is a Σ1
1 equivalence relation with a p-computable parameter there is a Hyp func-
tion f with p-computable parameter sending p-computable reals to p-computable
structures such that for p-computable x, y: E(x, y) iﬀf(x), f(y) are isomorphic.
Corollary 3. For any parameter p, isomorphism is complete on the set of p-compu-
table reals.
This reduces the Main Question 1 to the cases where n = 0, using the following
ﬁne-structural fact (see [6] or [4]).
Theorem 4. For any α, n, X(α, n) either equals X(α, 0) or equals the set of p-
computable reals for some real p.
The reason for this is the following: If X(α, n) does not equal X(α, 0) then there is
a real which is ∆n over Lα but does not belong to Lα; in fact there is a “canonical”
such real called the “∆n master code” for Lα, which serves as the parameter p in
the conclusion of the theorem.
We can reduce our Main Question 1 even further. For example, consider X(ω+
1, 0), the set of arithmetical reals. There is a Hyp function which takes an arith-
metical real to an arithmetical code for it and this reduces the completeness of
isomorphism on X(ω + 1, 0) to its completeness on X(ω, 1), the content of Theo-
rem 2. More generally, suppose that X(α, 0) is distinct from X(β, 0) for each β < α
(an assumption we can make without loss of generality) and that for some real p
in Lα, α is less than the least p-admissible ordinal ωp
1; then there is a Hyp in p
function which send the reals of X(α, 0) injectively into ω, thereby reducing the
completeness of isomorphism on X(α, 0) to its completness on the p-computable

160
|
Sy-David Friedman
reals, Corollary 3. Thus we have the completeness of isomorphism on X(α, n) in
all cases except when n = 0 and one of the following holds:
1. α is admissible but not the limit of admissibles.
2. α is a limit of admissibles.
We now show that isomorphism is not complete on X(α, 0) in the second of these
cases.
3 When isomorphism is not complete
First we need to clarify why isomorphism on arbitrary countable structures is not
complete for Σ1
1 equivalence relations on arbitrary reals.
Proposition 5. There is a Σ1
1 equivalence relation E on reals with an equivalence
class which is not Borel (i.e., not Hyp with a real parameter).
Proof. Let X be a Σ1
1 set of reals which is not Borel. Deﬁne E by: E(x, y) iﬀx, y ∈X
or x = y. Then X is an equivalence class of E.
Theorem 6. (Scott, see [5]) For any countable structure A, the set of (codes for)
countable structures which are isomorphic to A is Borel.
Proof. Let φ be the Scott sentence of A, i.e., the canonical sentence of Lω1ω whose
countable models are exactly those isomorphic to A. This set of models is Borel,
as the set of countable models of any sentence of Lω1ω is Borel.
Corollary 7. Isomorphism on countable structures is not complete for Σ1
1 equiva-
lence relations (under Borel, i.e. Hyp in a real parameter, reducibility).
Proof. A Borel reduction from a Σ1
1 equivalence relation E to another such equiv-
alence relation F takes non-Borel equivalence classes to non-Borel equivalence
classes.
Now suppose that we replace the set of all reals by some subset X(α, 0) of the reals;
what do we need to know about α for the above argument to still work?
Proposition 8. Suppose that α is a limit of admissibles. Let A be a countable struc-
ture with code in Lα. Then the set of codes for countable structures isomorphic to A
is Hyp with parameter in Lα.

The Completeness of Isomorphism
|
161
Proof. The canonical Scott sentence φ for A belongs to the second admissible set
containing x whenever x is a real coding A. As α is a limit of admissibles, φ is
coded by a real in Lα. It follows that the set of countable structures isomorphic to
A, i.e., the set of countable models of φ, is Hyp with parameter in Lα.
Corollary 9. Isomorphism is not complete on X(α, 0) when α is a limit of admissi-
bles.
Proof. Let X be the set of reals which code linear orders having inﬁnite descending
chains. Then X is Σ1
1 and not Borel. Now X ∩Lα is the set of reals in Lα which code
linear orders which have inﬁnite descending chains in Lα, using the fact that α is
a limit of admissibles. Thus X ∩Lα is Σ1
1 but not ∆1
1 in Lα. And if B is a Hyp set
of reals with parameter in Lα then B ∩Lα is ∆1
1 in Lα, so it follows that X and B
disagree on the reals of Lα. Now as before consider the equivalence relation E(x, y)
iﬀx ∈X or x = y; this equivalence relation is not reducible to isomorphism on
X(α, 0) as its restriction to Lα has an equivalence class which is not ∆1
1 in Lα but
the intersection with Lα of the equivalence classes of isomorphism are each ∆1
1 in
Lα.
Successor admissibles?
We are left with cases of X(α, 0) when α is a successor admissible, i.e. an admissi-
ble ordinal which is not the limit of admissibles. Note the following.
Proposition 10. Suppose that α is a successor admissible. Then either X(α, 0)
equals X(β, 0) where β is a limit of admissibles or the reals of X(α, 0) are exactly
those which are hyperarithmetic in p for some ﬁxed real p.
Proof. If Lα thinks that ℵ1 exists then X(α, 0) equals L(β, 0) where β is the ℵ1 of
Lα. Otherwise we may choose a real p in Lα which codes the supremum of the
admissibles less than α and then the reals of Lα are exactly those which are hyper-
arithmetic in p.
Thus the only remaining cases are relativisations to a real parameter of the follow-
ing.
Open Question 11. Is isomorphism complete on X(ωck
1 , 0), the set of hyperarith-
metic reals?

162
|
Sy-David Friedman
Recall that this asks the following: Suppose that E is a Σ1
1 equivalence relation on
reals. Is there a Hyp function f which takes reals to countable structures such that
for hyperarithmetic x, y, E(x, y) iﬀf(x), f(y) are isomorphic? The proof methods
of Theorem 2 and Corollary 9 do not appear to cover this case.
4 A variant
There is a strengthening of Corollary 9 for the case of X(α, 0) when α is a limit of
limits of admissibles.
Let E1 be the equivalence relation E1(x, y) iﬀfor suﬃciently large n, (x)n =
(y)n, where (x)n is the n-th “column” of x via some computable pairing funcion
⟨·, ·⟩on the natural numbers: (x)n(m) = x(⟨m, n⟩) for all m. Then E1 is a Hyp
equivalence relation.
Theorem 12. Let α be a limit of limits of admissibles. Then E1 is not reducible to
isomorphism on structures with codes in X(α, 0), the set of reals in Lα, via a Hyp
function with parameter from X(α, 0).
Proof. Suppose that there were such a reduction f with parameter p in Lα and
choose a limit of admissibles α0 < α so that p belongs to Lα0.
Let M denote Lα, M0 denote Lα0 and let (zn | n ∈ω) ∈M be generic for the
ω-product of Sacks forcing over M0. Deﬁne xn so that (xn)k is the 0-real for k < n
and is zk otherwise. The xn’s are pairwise E1-equivalent so the f(xn)’s are pairwise
isomorphic. As α0 is a limit of admissibles, they are in fact pairwise isomorphic
in M0[x0]. Choose a permutation π of ω in M which is Cohen-generic over M0[x0].
Let z be π · f(x0), the code for the structure obtained from f(x0) by applying π.
Then the structure coded by z is isomorphic to the structures coded by the f(xn)’s.
Also z is Cohen over each M0[xn]: Write z = π · f(x0) = π · π−1
n f(xn) where πn
is an isomorphism between f(x0) and f(xn) in M0[x0] and note that π · π−1
n
is
Cohen over M0[xn]. Now choose a real y in M0[z] so that f(y) is isomorphic to the
structure coded by z; this is possible as α0 is a limit of z-admissibles. Then y is E1-
equivalent to x0 and therefore some zn is a component of y. But then M0[xn+1][y], a
Cohen-generic extension of M0[xn+1], contains a real which is Sacks-generic over
M0[xn+1], a contradiction.

The Completeness of Isomorphism
|
163
Bibliography
[1]
W. Calvert, J.Knight and J.Millar, Computable trees of Scott rank ωck
1 and computable
approximations, J. Symbolic Logic, 71 (2006), no.1, 283–298.
[2]
E.Fokina, S.Friedman, V.Harizanov, J.Knight, C.McCoy and A.Montalban, Isomorphism
relations on computable structures, Journal of Symbolic Logic, vol.77, no.1, pp. 122–132,
March 2012.
[3]
E.Fokina, S.Friedman and A.Nies, Equivalence Relations that are Σ3 Complete for Com-
putable Reducibility - (extended abstract), Lecture Notes in Computer Science 7456,
pp.26–33, 2012.
[4]
S.Friedman, Negative Solutions to Post’s Problem II, Annals of Mathematics, Vol. 113,
1981, pp. 25-43.
[5]
S.Gao, Invariant descriptive set theory, Pure and Applied Mathematics 293. Taylor and
Francis Group, 2009.
[6]
C.Jockusch and S.Simpson, A degree-theoretic deﬁnition of the ramiﬁed analytical hierar-
chy, Annals of Math. Logic 10 (1975), pp. 1-32.


Peter Hertling, Victor Selivanov
Complexity Issues for Preorders on Finite
Labeled Forests¹
Abstract: We prove that three preorders on the ﬁnite k-labeled forests are polyno-
mial time computable. Together with an earlier result of the ﬁrst author, this im-
plies polynomial-time computability for an important initial segment of the corre-
sponding degrees of discontinuity of k-partitions on the Baire space. Furtermore,
we show that on ω-labeled forests the ﬁrst of these three preorders is polynomial
time computable as well while the other two preorders are NP-complete.
Keywords: Topological complexity, Weihrauch reducibility, labeled forest, poly-
nomial-time computability, NP-completeness.
Mathematics Subject Classiﬁcation 2010: 03D15, 03D30, 06A06
||
Peter Hertling: Institut für Theoretische Informatik, Mathematik und Operations Research
Universität der Bundeswehr München, Germany
Victor Selivanov: A.P. Ershov Institute of Informatics Systems, Siberian Division of the Russian
Academy of Sciences and Novosibirsk State Pedagogical University, Russia
1 Introduction
As is well-known, reducibilities serve as useful tools for understanding the com-
plexity (or non-computability) of decision problems on discrete structures. In com-
putable analysis, many problems of interest turn out to be non-computable, even
discontinuous. Thus, there is a need for tools to measure their non-computability
or discontinuity. Accordingly, also in this context of decision problems on contin-
uous structures people employed some reducibility notions.
Weihrauch [24; 25] (see also the thesis [23] supervised by Weihrauch) intro-
duced a topological reducibility relation ≤2 for functions f between products of
the Cantor space and a discrete space. Independently, Hirsch [11] gave a similar
deﬁnition for functions between arbitrary topological spaces. Weihrauch [24; 25]
also introduced a generalisation of this reducibility relation to sets of functions.
1 The results contained in this paper have been presented at the conference CiE 2011. A short
version [10] of this paper has appeared in the proceedings volume of CiE 2011.
Both authors were supported by DFG-RFBR (Grant 436 RUS 113/1002/01, 09-01-91334).

166
|
Peter Hertling and Victor Selivanov
A computability-theoretic version of this generalisation, transferred via represen-
tations to computational problems on arbitrary represented spaces, is now called
Weihrauch reducibility; see [4].
These notions have turned out to be very useful for understanding the non-
computability and discontinuity of important computation problems in com-
putable analysis [9; 3] and constructive mathematics [25; 4]. The ﬁrst author
has also considered slightly weaker topological reducibility relations ≤0 and ≤1
for functions between arbitrary topological spaces in [7; 8; 9]. The notions are
nontrivial even for the case of discrete spaces Y = k = {0, . . . , k −1} with k
points, 1 < k < ω. We call functions f : X →k k-partitions of X because they
are in a natural bijective correspondence with the partitions (A0, . . . , Ak−1) of X
where Ai = f −1(i)). For k = 2 the relation ≤0 coincides with the classical Wadge
reducibility [12].
In [7] (without proofs) and [8; 9] (with proofs) the ﬁrst author gave a “combina-
torial” characterization of the important initial segment of the degree structures
under these reducibilities of k-partitions of the Baire space B = ωω formed by
the k-partitions of B the components of which are ﬁnite Boolean combinations
of open sets. Namely, he introduced preorders ≤0, ≤1, ≤2 on the set Fk of ﬁnite
k-labeled forests (precise deﬁnitions are given in the next section) such that, for
each i ≤2, the structure of the topological ≤i-degrees of the speciﬁed initial seg-
ment is isomorphic to the quotient-poset of (Fk \ {∅}; ≤i). In fact, he showed that
with any k-partition f in the initial segment just described one can associate a
non-empty ﬁnite k-labeled forest B(f) such that, for any k-partitions f and g on
the Baire space one has f ≤i g if, and only if, B(f) ≤i B(g). Furthermore, the map-
ping f →B(f) to the set of ﬁnite non-empty k-forests is onto. This result provides a
natural naming system for the speciﬁed initial segment of topological ≤i-degrees
of k-partitions of the Baire space. The second author has extended this result for
≤0 to a much larger initial segment of k-partitions [22]. Note that the Baire space
is important because it is commonly used in computable analysis [26] to represent
many other spaces of interest.
The structure (Fk; ≤0) and its extension to the structure (Pk; ≤0) of ﬁnite k-
labeled posets are also important due to their close relationship to the Boolean
hierarchy of k-partitions that extends the classical Boolean (or diﬀerence) hierar-
chy of sets [14; 13; 21] and to some other ﬁelds of discrete mathematics like clones
of functions on k [20; 19].
The mentioned results motivated the study of (Fk; ≤0) and (Pk; ≤0) in a series
of publications. In [15] it was shown that for any k ≥3 the ﬁrst-order theory of
the quotient-poset of (Fk; ≤0) is undecidable. It is even computably isomorphic
to ﬁrst-order arithmetic [16]. In [18] the same was shown for ≤1 and ≤2. In [17]
a complete deﬁnability theory for the quotient-poset of (Fk; ≤0) was developed.

Complexity Issues for Preorders on Finite Labeled Forests
|
167
According to [20], the quotient-poset of (Pk; ≤0) is universal for each k ≥2, i.e., it
contains any countable poset as a substructure.
The naming systems (Fk; ≤i) and (Pk; ≤i) are obviously computable, and the
natural next step in understanding their computational properties is to look at
their complexity. In [19] it is shown that the relation ≤0 on Pk is NP-complete for
each k ≥2. In this paper we answer some natural complexity questions about the
relations ≤0, ≤1, ≤2 on Fk, and also on the set Fω of ﬁnite ω-labeled posets. Note
that in [9] it is shown that the structure of ≤2-degrees of functions f : B →ω such
that all f −1(k) are ﬁnite Boolean combinations of open sets is isomorphic to the
quotient-poset of (Fω; ≤2).
Our main results are summarized in the following three theorems.
Theorem 1. The relation ≤0 is computable in cubic time on Fk, for any k < ω, and
on Fω.
Theorem 2. The relation ≤1 is computable in cubic time on Fk, for any k < ω, and
NP-complete on Fω.
Theorem 3. The relation ≤2 is computable in time O(nk+3) on Fk, for any k < ω,
and NP-complete on Fω.
Furthermore, we show that minimization with respect to ≤0 is polynomial-time
computable.
In Section 2 we recall some relevant deﬁnitions and facts. In Sections 3, 5 and
6 we prove the results for ≤0, ≤1 and ≤2, respectively. In Section 4 we consider the
minimization problem with respect to ≤0. In Section 7 we mention some related
open questions.
The results contained in this paper have been presented at the conference CiE
2011. A short version [10] of this paper has appeared in the proceedings volume of
CiE 2011. The statements concerning NP-completeness in Theorems 2 and 3 have
been proved already in [10]. For completeness sake, we include the proofs here as
well. For the other statements either only proof sketches or no proofs at all have
been given in [10]. Here we give complete proofs of all assertions.
2 Preliminaries
We use some standard notation and terminology on posets which may be found
e.g. in [5]. Throughout this paper, k denotes an arbitrary integer, k ≥2, which
is identiﬁed with the set {0, . . . , k −1}. A poset is a partially ordered set (P, ≤),

168
|
Peter Hertling and Victor Selivanov
that is, a set P with a binary relation ≤on it that is reﬂexive, transitive, and anti-
symmmetric. As usual, by x < y we mean (x ≤y ∧x ̸= y). For an element x ∈P
the upper cone of x is the set ↑x := {y ∈P | x ≤y}, and the lower cone of x is the
set ↓x := {y ∈P | y ≤x}. A chain is a poset (P, ≤) such that additionally x ≤y
or y ≤x, for all x, y ∈P. By a forest we mean a ﬁnite poset in which every upper
cone ↑x (endowed with the order obtained by restricting ≤to ↑x) is a chain. A
tree is a forest that has a largest element, that is, an element x satisfying y ≤x for
all y ∈P. When such an element exists then it is uniquely determined, and it is
called the root of the tree. The cardinality of a forest F is denoted |F|.
A k-labeled forest (or just a k-forest) is a triple (P; ≤, c) consisting of a forest
(P; ≤) and a labeling c : P →k. We call a k-forest (P; ≤, c) repetition-free iﬀc(x) ̸=
c(y) whenever y is an immediate successor of x in P, i.e., whenever x < y and there
does not exist a z ∈P with x < z and z < y. We often simplify the notation of a
k-forest to P. By default, we denote the labeling in a given k-forest by c. We are
mainly interested in the set Fk of ﬁnite k-labeled forests, but also in the set Tk
of ﬁnite k-labeled trees and in the set Ck of ﬁnite k-labeled chains. The ﬁnite k-
labeled chains are identiﬁed with the ﬁnite non-empty words over the alphabet
k. Any such word u is a sequence u(0) · · · u(n −1) of letters where n = |u| is the
length of u. We will view this as a k-labeled chain of length n with u(0) being the
label of the root of the chain.
For any k-forests F, G ∈Fk and i < k, let pi(F) denote a k-tree obtained from
F by adding a new greatest element with the label i. Let F⊔G be the disjoint union
of F, G. Note that any tree is of the form pi(F), and that any proper forest, i.e., a
forest which is neither empty nor a tree, is of the form F ⊔G where F and G are
nonempty forests. The singleton k-tree with label i is identiﬁed with i.
Lemma 4. Let k ≥2, and let (P; ≤P, cP) and (Q; ≤Q, cQ) be k-forests. For a mono-
tone function φ : (P; ≤P, cP) →(Q; ≤Q, cQ) the following two conditions are equiv-
alent.
1. There exists a function f : k →k with cP = f ◦cQ ◦φ.
2. For all x, y ∈P, cP(x) ̸= cP(y) →cQ(φ(x)) ̸= cQ(φ(y)).
The same holds true for ω-forests.
Proof. We prove the assertion for k-forests. The proof of the assertion for ω-forests
is essentially identical.
Let us ﬁx some k ≥2. The direction “1 ⇒2” is clear. For the direction “2 ⇒1”,
let us assume that for all x, y ∈P, cP(x) ̸= cP(y) →cQ(φ(x)) ̸= cQ(φ(y)). We
deﬁne a function f : k →k as follows. If for some i ∈k there is some x ∈P with
i = cQ(φ(x)), then we set f(i) := cP(x). Note that if there are diﬀerent x, y ∈P
with i = cQ(φ(x)) and i = cQ(φ(y)) then by assumption cP(x) = cP(y). For all

Complexity Issues for Preorders on Finite Labeled Forests
|
169
other i ∈k we choose f(i) arbitrarily. The function f is well deﬁned. It satisﬁes
cP = f ◦cQ ◦φ.
Deﬁnition 5.
1. A
0-morphism (resp., 1-morphism, resp., 2-morphism) φ
:
(P; ≤P, cP) →(Q; ≤Q, cQ) between k-forests is a monotone function φ :
(P; ≤P) →(Q; ≤Q) that satisﬁes cP = cQ ◦φ (resp., one and then both of
the conditions in Lemma 4, resp., ∀x, y ∈P((x ≤P y ∧cP(x) ̸= cP(y)) →
cQ(φ(x)) ̸= cQ(φ(y)))).
2. We write P ≤0 Q (resp. P ≤1 Q, P ≤2 Q) to denote that there exists a 0-
morphism (resp. 1-morphism, 2-morphism) φ : P →Q.
Using Lemma 4 it is easy to see that any 0-morphism is a 1-morphism and any
1-morphism is a 2-morphism. Therefore, ≤0 implies ≤1 and ≤1 implies ≤2. The
relations ≤0, ≤1, ≤2 are reﬂexive and transitive on Fk, i.e., they are preorders. In
the same way we deﬁne the preorders ≤0, ≤1, ≤2 on the set Fω of ﬁnite ω-labeled
forests (in which any natural number may be used as a label).
Let ω∗be the set of ﬁnite sequences (strings) of natural numbers. The empty
string is denoted by ∅, the concatenation of strings σ, τ by στ, the length of σ by
|σ|. By ω+ we denote the set of ﬁnite non-empty strings in ω. By σ ⊑τ we denote
that the string σ is an initial segment of the string τ. For any n, 1 < n < ω, let n∗
be the set of ﬁnite strings of elements of {0, . . . , n −1}, n∗⊆ω∗. E.g., 2∗is the set
of ﬁnite strings of 0’s and 1’s. In computer science people often consider the sets
A∗and A+ of ﬁnite (respectively, ﬁnite non-empty) words over a ﬁnite alphabet
A. Mathematically, these sets are of course the same as n∗and n+ respectively,
where n is the cardinality of A.
Since we plan to deal with the complexity of the introduced preorders, we
need to represent them by ﬁnite words over a ﬁnite alphabet. For k-labeled forests
we use the alphabet k∪{(, )}. A k-labeled forest consists of ﬁnitely many k-labeled
trees, and we will represent it as a concatenation of these trees, in an arbitrary or-
der. A k-labeled tree T consists of a root with the label c(T) and a forest F consist-
ing of the trees appended to the root. It will be represented by the string (c(T)F).
Example 6. For example, the 4-labeled forest ({1, 2, 3, 4, 5}; ≤, c), with the partial
order relation ≤given by
a ≤b : ⇐⇒(a, b) ∈{(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (2, 1), (3, 1), (4, 1), (4, 3)}
and with the labeling c deﬁned by c(i) := i mod 4 can be represented by the string
(1(2)(3(0)))(1). We describe this forest: it consists of two trees. The node 1, labeled
with 1, is the root of the ﬁrst tree, the nodes 2, labeled with 2, and 3, labeled with

170
|
Peter Hertling and Victor Selivanov
3, are its children, the node 4, labeled with 0, is the child of node 3, and the node 5,
labeled with 1, forms the second tree, a singleton tree.
Note that any string representing a k-labeled forest with n elements has length
exactly 3n, for any k < ω. In order to represent ω-labeled forests, we proceed in
the same way, but represent the labels in binary form. Thus, we use the alphabet
{(, ), 0, 1}. Since we wish to compare two forests, and the Turing machine expects
the input on one input tape, we will give representations of the two forests to the
Turing machine, separated by some special symbol, e.g., #.
3 The Complexity of ≤0
The following theorem is our ﬁrst main result. It implies Theorem 1.
Theorem 7. For any k < ω, there is a Turing machine which, given two k-labeled
forests F and G, checks in time O(m+n+m2n+mn2) (where m := |F| and n := |G|)
whether F ≤0 G or not. The same is true for ω-labeled forests (where now m and n
are the lengths of representations of F and G, respectively).
Thus, the relation ≤0 is computable in cubic time on Fk, for any k < ω, and on Fω.
Proof. First we consider the case of k-labeled forests, for some k < ω. We will
show the following statement: There is an algorithm (a Turing machine) which,
given two forests F and G with m := |F| and n := |G|, decides in time O(m + n +
m2n+mn2) whether F ≤0 G or not. The Turing machine is based on the following
sequence of statements for two forests F and G, which is similar to an observation
in [21]:
1. If |F| = 0 then F ≤0 G is true.
2. If |F| ≥1 and |G| = 0 then F ≤0 G is false.
3. If F = pi(F0) and G = pi(G0) then F ≤0 G iﬀF0 ≤0 G.
4. If F = pi(F0), G = pj(G0), and i ̸= j then F ≤0 G iﬀF ≤0 G0.
5. If F = pi(F0) and G = G0 ⊔G1 then F ≤0 G iﬀF ≤0 G0 ∨F ≤0 G1.
6. If F = F0 ⊔F1 then F ≤0 G iﬀF0 ≤0 G ∧F1 ≤0 G.
In the following we sketch the Turing machine. Furthermore, for each step we say
in which time it can be executed. Let t(m, n) denote the maximum time needed
by this algorithm, given a forest F with |F| = m and a forest G with |G| = n. When
started with F#G on the input tape, the machine copies F and G to two work tapes.

Complexity Issues for Preorders on Finite Labeled Forests
|
171
This can be done in time O(m + n). Then the recursive algorithm is started. When-
ever it is called with some subforests F′ and G′, these subforests can be remem-
bered on two stacks realized on some work tapes. The machine follows the case
distinction above.
1. First, the machine checks whether the forest F is empty. This can be done in
constant time. If this is the case then the machine says YES and stops. Other-
wise it continues with Step 2.
2. The machine checks whether G is empty. This can be done in constant time.
If this is the case then the machine says NO and stops. Otherwise it continues
with Step 3.
3. The machine checks whether F consists of a single tree. This can be done in
time O(m). If this is not the case then it continues with Step 6. If F consists of
a single tree then the machine checks whether G consists of a single tree as
well. This can be done in time O(n). If this is not the case then it continues
with Step 5. If G consists of a single tree as well then we have F = pi(F0) and
G = pj(G0) for some labels i and j and for some forests F0 and G0. Now the
machine checks whether i = j. This can be done in constant time. If this is not
the case then the machine continues with Step 4. If i = j then the machine
checks by a recursive call whether F0 ≤0 G. This can be done in time
t(m −1, n).
If this is the case then the machine says YES and stops. Otherwise it says NO
and stops.
4. In this case we have F = pi(F0) and G = pj(G0) for some labels i and j with
i ̸= j and for some forests F0 and G0. The machine checks by a recursive call
whether F ≤0 G0. This can be done in time
t(m, n −1).
If this is the case then the machine says YES and stops. Otherwise it says NO
and stops.
5. In this case we have F = pi(F0), and G is neither empty nor a tree. The ma-
chine sets G0 := ﬁrst tree in G, and G1 := the forest consisting of the remain-
ing trees in G. All of this can be done in time O(n). Then it checks by two
recursive calls whether F ≤0 G0 or F ≤0 G1. This can be done in time
O(m + n) + max{t(m, n1) + t(m, n2) | n1 ≥1, n2 ≥1, n1 + n2 = n}.
If this is the case then the machine says YES and stops. Otherwise it says NO
and stops.

172
|
Peter Hertling and Victor Selivanov
6. In this case F is neither empty nor a tree. The machine sets F0 := ﬁrst tree in
F, and F1 := the forest consisting of the remaining trees in F. All of this can
be done in time O(m). Then it checks by two recursive calls whether F0 ≤0 G
and F1 ≤0 G. This can be done in time
O(m + n) + max{t(m1, n) + t(m2, n) | m1 ≥1, m2 ≥1, m1 + m2 = m}.
If this is the case then the machine says YES and stops. Otherwise it says NO
and stops.
The description and the analysis of the algorithm sketched above show that there
exists a constant c > 0 such that for all m, n ≥0
t(0, n) ≤c · (1 + n)
and
t(m, 0) ≤c · (1 + m),
and for all m, n ≥1
t(m, n)
≤
c · (m + n)
+ max{ t(m −1, n),
t(m, n −1),
max{t(m, n1) + t(m, n2) | n1 ≥1, n2 ≥1, n1 + n2 = n},
max{t(m1, n) + t(m2, n) | m1 ≥1, m2 ≥1, m1 + m2 = m}}.
Using these recursive inequalities, we now show by induction that for m, n ≥1
t(m, n) ≤2c · (m2n + mn2).
(1)
This proves the claim t(m, n) ∈O(m + n + m2n + mn2). In order to prove (1) it is
suﬃcient to prove the following four statements for m, n ≥1:
I.
c · (m + n) + t(m −1, n) ≤2c · (m2n + mn2).
II.
c · (m + n) + t(m, n −1) ≤2c · (m2n + mn2).
III. For any n1, n2 with n1 ≥1, n2 ≥1 and n1 + n2 = n
c · (m + n) + t(m, n1) + t(m, n2) ≤2c · (m2n + mn2).
IV. For any m1, m2 with m1 ≥1, m2 ≥1 and m1 + m2 = m
c · (m + n) + t(m1, n) + t(m2, n) ≤2c · (m2n + mn2).

Complexity Issues for Preorders on Finite Labeled Forests
|
173
Now we prove these four statements.
I.
c · (m + n) + t(m −1, n) ≤2c · (m2n + mn2).
In order to prove this, we distinguish two cases:
Case 1: m = 1: Then
c · (m + n) + t(m −1, n)
=
c · (m + n) + t(0, n)
≤
c · (m + n) + c · (1 + n)
=
2c · (m + n)
≤
2c · (m2n + mn2).
Case 2: m > 1: Then
c · (m + n) + t(m −1, n)
≤
c · (m + n) + 2c · ((m −1)2n + (m −1)n2)
=
2c · (m2n + mn2) + c · (m + n −4mn + 2n −2n2)
=
2c · (m2n + mn2) + c · (m(1 −n) + 3n(1 −m) −2n2)
≤
2c · (m2n + mn2).
II.
c · (m + n) + t(m, n −1) ≤2c · (m2n + mn2).
The proof is completely symmetric to the proof of the previous statement.
III. For any n1, n2 with n1 ≥1, n2 ≥1 and n1 + n2 = n
c · (m + n) + t(m, n1) + t(m, n2) ≤2c · (m2n + mn2).
Indeed, for n1, n2 with n1 ≥1, n2 ≥1 and n1 + n2 = n one obtains
c · (m + n) + t(m, n1) + t(m, n2)
≤
c · (m + n) + 2c · (m2n1 + mn2
1) + 2c · (m2n2 + mn2
2)
=
2c · (m2n + mn2) + c · (m + n + 2m(n2
1 + n2
2 −n2))
=
2c · (m2n + mn2) + c · (m + n −4mn1n2)
=
2c · (m2n + mn2)
+c · (m(1 −n1n2) + n1(1 −mn2) + n2(1 −mn1) −mn1n2)
≤
2c · (m2n + mn2).
IV. For any m1, m2 with m1 ≥1, m2 ≥1 and m1 + m2 = m
c · (m + n) + t(m1, n) + t(m2, n) ≤2c · (m2n + mn2).
The proof is completely symmetric to the proof of the previous statement.

174
|
Peter Hertling and Victor Selivanov
In the case of ω-labeled forests, one sets m := the length of the forest F as a string,
i.e., the length of the string representing the ﬁrst forest, and, similarly, n := the
length of the string representing the second forest. Note that if the forest F is empty
then m = 0, and if F is not empty then m ≥3. Similarly with G. The algorithm
works in the same way. The recursive inequalities for the time estimation have to
be modiﬁed slightly. There exists a constant c > 0 such that the following holds.
For 0 ≤m ≤2 and n ≥0 one has
t(m, n) ≤c · (1 + n),
for m ≥0 and 0 ≤n ≤2 one has
t(m, n) ≤c · (1 + m),
and for m, n ≥3 one has
t(m, n)
≤
c · (m + n)
+ max{ max{t(m −i, n) | 3 ≤i ≤m},
max{t(m, n −i) | 3 ≤i ≤n},
max{t(m, n1) + t(m, n2) | n1 ≥3, n2 ≥3, n1 + n2 = n},
max{t(m1, n) + t(m2, n) | m1 ≥3, m2 ≥3, m1 + m2 = m}}.
Using these recursive inequalities, similarly as above one arrives at t(m, n) ∈
O(m + n + m2n + mn2).
4 The Complexity of ≤0-minimization
Theorem 7 may be used to establish polynomial-time computability of some other
natural relations and functions on Fk. We give some examples related to minimal
k-forests. Recall that a minimal k-forest is a ﬁnite k-forest not ≤0-equivalent to a
k-forest of lesser cardinality. As observed in [21], any ﬁnite k-forest is equivalent
to a unique (up to isomorphism) minimal k-forest. The next characterization of
the minimal k-forests from [21] is a kind of inductive deﬁnition (by induction on
the cardinality) of the minimal k-forests.
Proposition 8.
1. The empty k-forest is minimal, and any singleton k-forest is
minimal.
2. A non-singleton k-tree (T; ≤, c) is minimal iﬀthe k-forest (F; ≤F, c|F) obtained
by deleting the root from T is minimal, and if c(root(T)) ̸= c(y) for all immedi-
ate predecessors y of the root in T.

Complexity Issues for Preorders on Finite Labeled Forests
|
175
3. A non-empty, proper (i.e., not ≤0-equivalent to a k-tree) k-forest is minimal iﬀ
all its k-trees are minimal and pairwise incomparable under ≤0.
The ﬁrst item in the next lemma was observed in [21], the other follows from the
previous proposition.
Lemma 9.
1. Any two ≤0-equivalent k-trees have the same root label.
2. If F is a minimal k-forest and x ∈F then the lower cone ↓x (with the induced
partial order and labeling) is minimal.
If F = F0⊔· · ·⊔Fn where the summands are k-trees and i < k, let qi(F) denote the k-
forest G0⊔· · ·⊔Gm where the sequence (G0, . . . , Gm) is obtained from (F0, . . . , Fn)
by deleting all roots labeled by i (note that qi(F) may be empty). Relate to any
k-forest F = F0 ⊔· · · ⊔Fn where the summands are k-trees the k-forest F∗=
Fi0 ⊔· · · ⊔Fim where i0 is the smallest i ≤n with Fi ̸≤0 Fi+1 ⊔· · · ⊔Fn, i1 > i0 is
the smallest number i ≤n (if any) with Fi ̸≤0 Fi+1 ⊔· · · ⊔Fn ⊔Fi0, i2 > i1 is the
smallest number i ≤n (if any) with Fi ̸≤0 Fi+1 ⊔· · · ⊔Fn ⊔Fi0 ⊔Fi1, and so on.
The next lemma follows from the deﬁnitions and from Theorem 7.
Lemma 10.
1. For any F ∈Fk and i < k, |qi(F)| ≤|F| and |F∗| ≤|F|.
2. For any F = F0 ⊔· · · ⊔Fn, Fi0, . . . , Fim are pairwise ≤0-incomparable and
F∗≡0 F.
3. The function F →qi(F) is computable in linear time.
4. The function F →F∗is computable in cubic time.
Proof. The ﬁrst two statements follow directly from the deﬁnitions.
In order to delete a root with label i from a tree in a forest represented as de-
scribed above one has to delete ﬁrst the opening bracket preceding the label of
the root, then the label itself and ﬁnally the closing bracket of the tree. For the
last part, one may use a stack in which one remembers the current depth of brack-
ets when reading the forest from left to right. It is possible to do this deletion in a
single run through the forest. Therefore, it can be performed in linear time.
Finally, the fourth statement can be deduced from Theorem 7 as follows. Given
a forest F = F0 ⊔· · · ⊔Fm where the summands are k-trees with ni := |Fi| (note
that ni ≥1) and n := |F| = n0 + . . . + nm, the time needed for computing F∗
is dominated by the time for ≤0-comparing any tree Fi with any other tree Fj. By
Theorem 7 this time is up to a multiplicative constant bounded from above by

0≤i,j≤m, i̸=j
(n2
i nj + nin2
j ) <

0≤i,j≤m
(n2
i nj + nin2
j ) = 2 ·

0≤i,j≤m
n2
i nj

176
|
Peter Hertling and Victor Selivanov
=
2 ·
m

i=0
n2
i
m

j=0
nj = 2 · n ·
m

i=0
n2
i ≤2n3.
That proves the assertion.
Theorem 11. There is a function min : Fk →Fk computable in time O(n4) such
that, for any F ∈Fk, min(F) is minimal and min(F) ≡0 F.
Proof. The function min is given by the following recursive algorithm:
1. If |F| = 0 or |F| = 1 then set min(F) = F.
2. If F = pi(G) is not a singleton, then set min(F) = pi(qi(min(G))∗).
3. If F = F0 ⊔· · · ⊔Fm where the summands are k-trees and m > 0 then set
min(F) = (min(F0) ⊔· · · ⊔min(Fm))∗.
The correctness of the algorithm follows from the above proposition and lemmas.
Let t(n) be the maximum time needed for computing min(F) for some k-labeled
forest F with n = |F|. We are going to show t(n) ∈O(n4).
The ﬁrst step of the algorithm can be performed in constant time. For the sec-
ond step, note that checking whether F is a tree but not a singleton tree can be
done in linear time. If F = pi(G), then |G| = n −1. One can compute min(G) in
time t(n −1). By Lemma 10, then one can compute qi(min(G)) in time O(n −1).
By Lemma 10, then one can compute qi(min(G))∗in time O((n −1)3). Finally,
one can compute pi(qi(min(G))∗) in time O(n). For the third step, we assume that
F = F0 ⊔· · · ⊔Fm where the summands are k-trees with ni := |Fi| and m > 0. The
third step can be performed in time m
i=0 t(ni) + O(n3). We conclude that there is
a constant c > 0 such that the following holds true:
t(0) ≤c
and
t(1) ≤c,
and for n ≥2
t(n)
≤
c · n + max

t(n −1) + c · (n −1) + c · (n −1)3 + c · n),
c · n3 + max

m

i=0
t(ni)
 m > 0, (∀i) ni ≥1,
m

i=0
ni = n

.
Using these recursive inequalities, by induction one shows that
t(n) ≤2c · n4
for n ≥1. This proves t(n) ∈O(n4).

Complexity Issues for Preorders on Finite Labeled Forests
|
177
5 The Complexity of ≤1
Lemma 12. The relations ≤1 and ≤2 coincide on Cω and also, for each k < ω, on
Ck.
Proof. This follows from the second characterization of ≤1 in Lemma 4 and from
the deﬁnition of ≤2.
Proposition 13. The relations ≤1 and ≤2 on Cω are NP-hard.
Proof. By Lemma 12, it suﬃces to ﬁnd a polynomial time reduction of 3-SAT to ≤2
on Cω (in this proof we assume familiarity of the reader with some common knowl-
edge from complexity theory, see e.g. [1; 2]). We have to relate in polynomial time
to any 3-CNF C = C(x0, . . . , xn) words u, v over the alphabet ω such that C is
satisﬁable iﬀu ≤2 v. In “mnemonic notation”, u will in fact be a word over the al-
phabet {0, 1, T, F}, and v will be a word over the alphabet {0, 1, x0, ¯x0 . . . , xn, ¯xn}.
A straightforward coding turns u, v into words over the alphabet ω.
We may assume that C = D0 ∧· · · ∧Dm where any Dj is a disjunction xaj
pj ∨
xbj
qj ∨xcj
rj of exactly three literals, pj, qj, rj ≤n, 0 ≤aj, bj, cj ≤1, x1 = x and
x0 = ¯x, and no disjunction contains a letter with its negation. For each j ≤m, let
˜Dj denote the word xaj
pjxbj
qj xcj
rj . Deﬁne the words u′ and v′ by
u′
:=
(TF01)n+1(T01)m+1
v′
:=
x0¯x0x001 · · · xn¯xnxn01˜D001 · · · ˜Dm01.
Note that |u′| = 4(n + 1) + 3(m + 1) and |v′| = 5(n + 1) + 5(m + 1). Finally,
let u := (01)Mu′ and v := (01)Mv′ where M = |v′| + 1. Obviously, the function
C →(u, v) is computable in linear time.
We call xi¯xixi01 the i-th variable factor of v (0 ≤i ≤n), and ˜Dj01 the j-th
disjunction factor of v (0 ≤j ≤m). Note that the variable (resp. disjunction) factors
of v are in a natural bijective correspondence with the factors TF01 (resp. T01) of
u. For each i ≤n, let ti (resp. li) be the position in u (resp. in v) of the letter T (resp.
of the ﬁrst entry of xi) in the i-th factor TF01 (resp. of the i-th variable factor). For
each j ≤m, let sj be the position in u of the letter T in the j-th factor T01.
Let C be satisﬁable, i.e., true for some assignment α : {x0, . . . , xn} →{T, F}.
Deﬁne a monotone function φ : |u| →|v| as follows: φ sends the position of
any entry of 0 or 1 in u to the corresponding position of the same letter in v (note
that the numbers of entries of these letters in u and v coincide); for any i ≤n, if
α(xi) = T then φ(ti) = li and φ(ti + 1) = li + 1, otherwise φ(ti) = li + 1 and

178
|
Peter Hertling and Victor Selivanov
φ(ti + 1) = li + 2; for any j ≤m, φ sends sj to the position of the ﬁrst true literal
in the j-th disjunction factor. Then φ is a 2-morphism from u to v.
Conversely, let φ : u →v be a 2-morphism; we have to ﬁnd a satisfying assign-
ment α for C. Since u is repetition-free, φ is injective. Since M > |v′|, φ(0, . . . , 2M−
1) contains some positions for both 0 and 1, hence φ cannot send any position of
T or F to a position of 0 or 1. Since any factor of v without 0, 1 has length 3, the
positions of T, F in the i-th factor TF01 can go only to positions of xi¯xixi in the
corresponding i-variable factor (for each i ≤n), and, for each j ≤m, φ(sj) is a
position of some literal in the j-th disjunctive factor. For any i ≤n, let α(xi) = T
iﬀφ(ti) = li. Then α is a desired satisfying assignment.
Theorem 14. For any k < ω, the relation ≤1 on Fk is computable in cubic time. The
relation ≤1 on Fω is NP-complete.
Proof. Let k < ω. For any G = (Q; ≤, c) ∈Fk and f : k →k, we deﬁne Gf :=
(Q; ≤, f ◦c). From the deﬁnition of ≤1 we observe that F ≤1 G iﬀthere exists a
function f : k →k such that F ≤0 Gf. Let {f1, . . . , fkk} be an enumeration without
repetition of {f | f : k →k}. Since G →(Gf1, . . . , Gfkk ) is computable in linear
time and ≤0 is computable in cubic time, ≤1 on Fk is computable in cubic time.
For Fω, ≤1 is NP-hard by the previous proposition. It remains to show that it is
in NP. The corresponding nondeterministic algorithm is obvious: given ω-labeled
forests F = (P; ≤P, cP) and G = (Q; ≤Q, cQ), guess a function f : cQ(Q) →cP(P)
and a function φ : P →Q and check (in polynomial time) whether φ is a 0-
morphism from (P; ≤P, cP) to (Q; ≤Q, f ◦cQ).
Note that by Theorem 14 the relation ≤1 on Fω is ﬁxed-parameter tractable (com-
pare [6]) if the largest label of the input forests is taken as the parameter.
6 The Complexity of ≤2
Theorem 15. For any k < ω, the relation ≤2 on Fk is computable in time O(nk+3).
The relation ≤2 on Fω is NP-complete.
For the proof of the ﬁrst assertion in Theorem 15 we need the following simple
technical lemma.
Lemma 16. For every k ≥1 and every n ≥2
(n −1)k + 2−(k−1) · nk−1 ≤nk.

Complexity Issues for Preorders on Finite Labeled Forests
|
179
Proof. Fix some (natural numbers) k ≥1 and n ≥2. By the binomial formula
nk −(n −1)k = ((n −1) + 1)k −(n −1)k ≥k · (n −1)k−1 ≥(n −1)k−1.
Due to n ≥2 we have n −1 ≥n/2, hence
nk −(n −1)k ≥2−(k−1)nk−1.
By rearranging we obtain the assertion.
Proof of Theorem 15. First we prove the second assertion. The relation ≤2 on Fω is
NP-hard by Proposition 13. It remains to show that it is in NP. The corresponding
nondeterministic algorithm is obvious: given F, G, guess a function φ : F →G
and check (in polynomial time) whether φ is a 2-morphism.
We come to the proof of the ﬁrst assertion. Let k < ω. Let us denote by f :⊆
k →k an arbitrary function whose domain dom(f) and whose range may be any
subsets of k = {0, . . . , k−1}. For F = (P; ≤P, cP), G = (Q; ≤Q, cQ) ∈Fk, and such
a function f :⊆k →k, let F ≤f
2 G mean that there is a 2-morphism φ : F →G
such that for all x ∈P, if cQ(φ(x)) ∈dom(f) then cP(x) = f(cQ(φ(x))). Note
that F ≤2 G is equivalent to F ≤f∅
2 G where f∅is the partial function from k to k
with dom(f) = ∅. Therefore it suﬃces to show that the relation ≤f
2 is computable
in time O(n3+k−| dom(f)|), for any function f :⊆k →k. Similarly to the proof of
Theorem 7, we show that there exists a natural recursive algorithm based on the
following sequence of statements for k-forests F and G and a function f :⊆k →k.
This sequence of statements is based on the recursive deﬁnition of ≤2 in [7; 8; 9]:
1. If |F| = 0 then F ≤f
2 G is true.
2. If |F| ≥1 and |G| = 0 then F ≤f
2 G is false.
3. If F = pi(F0), G = pj(G0), j ∈dom(f), and i = f(j) then F ≤f
2 G iﬀF0 ≤f
2 G.
4. If F = pi(F0), G = pj(G0), j ∈dom(f), and i ̸= f(j) then F ≤f
2 G iﬀF ≤f
2 G0.
5. If F = pi(F0), G = pj(G0), and j ̸∈dom(f) then F ≤f
2 G iﬀ(F ≤f
2 G0∨F0 ≤g
2 G).
Here g is deﬁned by dom(g) := dom(f)∪{j}, and by g(l) := f(l) for l ∈dom(f),
and g(j) := i.
6. If F = pi(F0) and G = G0 ⊔G1 then F ≤f
2 G iﬀF ≤f
2 G0 ∨F ≤f
2 G1.
7. If F = F0 ⊔F1 then F ≤f
2 G iﬀF0 ≤f
2 G ∧F1 ≤f
2 G.
In the following we sketch the Turing machine. Let tl(m, n) denote the maximum
time needed by this algorithm, given a forest F with |F| = m, a forest G with |G| =
n and a function f :⊆k →k with l = | dom(f)|. When started with F#G#f on
the input tape (where f is given as a list of all pairs (x, f(x)) with x ∈dom(f)), the
machine copies F, G, and f to three work tapes. This can be done in time O(m+n).
Then the recursive algorithm is started. Whenever it is called with some subforests

180
|
Peter Hertling and Victor Selivanov
F′ and G′, these subforests can be remembered on two stacks realized on some
work tapes. The machine follows the case distinction above.
1. First, the machine checks whether the forest F is empty. This can be done in
constant time. If this is the case then the machine says YES and stops. Other-
wise it continues with Step 2.
2. The machine checks whether G is empty. This can be done in constant time.
If this is the case then the machine says NO and stops. Otherwise it continues
with Step 3.
3. The machine checks whether F consists of a single tree. This can be done in
time O(m). If this is not the case then it continues with Step 7. If F consists of
a single tree then the machine checks whether G consists of a single tree as
well. This can be done in time O(n). If this is not the case then it continues
with Step 6. If G consists of a single tree as well then we have F = pi(F0) and
G = pj(G0) for some labels i and j and for some forests F0 and G0. Now the
machine checks whether j ∈dom(f). This can be done in constant time. If
this is not the case then the machine continues with Step 5. If j ∈dom(f) then
the machine checks whether i = f(j). If this is not the case then the machine
continues with Step 4. If i = f(j) then the machine checks by a recursive call
whether F0 ≤f
2 G. This can be done in time
tl(m −1, n).
If this is the case then the machine says YES and stops. Otherwise it says NO
and stops.
4. In this case we have F = pi(F0) and G = pj(G0) for some labels i and j with
j ∈dom(f), and with i ̸= f(j), and for some forests F0 and G0. The machine
checks by a recursive call whether F ≤f
2 G0. This can be done in time
tl(m, n −1).
If this is the case then the machine says YES and stops. Otherwise it says NO
and stops.
5. In this case we have F = pi(F0) and G = pj(G0) for some labels i and j with
j ̸∈dom(f), and for some forests F0 and G0. The machine checks by a recursive
call whether F ≤f
2 G0. This can be done in time
tl(m, n −1).
If this is the case then the machine says YES and stops. Otherwise it deﬁnes
a function g :⊆k →k by dom(g) := dom(f) ∪{j}, and by g(l) := f(l) for
l ∈dom(f), and g(j) := i), and checks by a recursive call whether F0 ≤g
2 G.

Complexity Issues for Preorders on Finite Labeled Forests
|
181
This can be done in time
tl+1(m −1, n).
If this is the case then the machine says YES and stops. Otherwise it says NO
and stops.
6. In this case we have F = pi(F0), and G is neither empty nor a tree. The ma-
chine sets G0 := ﬁrst tree in G, and G1 := the forest consisting of the remain-
ing trees in G. All of this can be done in time O(n). Then it checks by two
recursive calls whether F ≤f
2 G0 and F ≤f
2 G1. This can be done in time
O(m + n) + max{tl(m, n1) + tl(m, n2) | n1 ≥1, n2 ≥1, n1 + n2 = n}.
If this is the case then the machine says YES and stops. Otherwise it says NO
and stops.
7. In this case F is neither empty nor a tree. The machine sets F0 := ﬁrst tree in
F, and F1 := the forest consisting of the remaining trees in F. All of this can
be done in time O(m). Then it checks by two recursive calls whether F0 ≤f
2 G
and F1 ≤f
2 G. This can be done in time
O(m + n) + max{tl(m1, n) + tl(m2, n) | m1 ≥1, m2 ≥1, m1 + m2 = m}.
If this is the case then the machine says YES and stops. Otherwise it says NO
and stops.
We wish to estimate the time needed by this Turing machine.
Note that in comparison with the sequence of statements in the proof of The-
orem 7, there is an additional case, namely No. 5. If f is total, i.e., if | dom(f)| = k,
then this case plays no role, and one arrives at the same bound for the time as for
the relation ≤0. But if f is not total, then this case has to be taken into considera-
tion. Similarly to the proof of Theorem 7, we will show that for any function f :⊆
k →k, the algorithm works in time O(m+n+m2n1+k−| dom(f)|+mn2+k−| dom(f)|),
for any input forests F, G with m := |F|, n := |G|. This is shown ﬁrst for all total
functions f, i.e., with k−| dom(f)| = 0, then for all functions f with k−| dom(f)| =
1, then for all functions with k −| dom(f)| = 2, and so on. The additional term
k −| dom(f)| in the exponent in the time bound is caused by Case no. 5 in the
sequence of statements at the beginning of the proof. In the following we give a
detailed proof.
The description and the analysis of the algorithm sketched above show that
for every l with 0 ≤l ≤k there exists a constant cl > 0 such that for all m, n ≥0
tl(0, n) ≤cl · (1 + n)
and
tl(m, 0) ≤cl · (1 + m),

182
|
Peter Hertling and Victor Selivanov
and for all m, n ≥1 the following is true. In case l = k, i.e., if the function f is
total, the ﬁfth step in the algorithm will never be entered. Therefore we obtain the
same estimate as in the proof of Theorem 7 for ≤0:
tk(m, n)
≤ck · (m + n)
+ max{ tk(m −1, n),
tk(m, n −1),
max{tk(m, n1) + tk(m, n2) | n1 ≥1, n2 ≥1, n1 + n2 = n},
max{tk(m1, n) + tk(m2, n) | m1 ≥1, m2 ≥1, m1 + m2 = m}}.
As in the proof of Theorem 15, these recursive inequalities imply
tk(m, n) ≤2ck · (m2n + mn2)
(2)
for m, n ≥1. For l < k, the ﬁfth step may be entered, and we obtain the following
estimate for m, n ≥1:
tl(m, n)
≤cl · (m + n)
+ max{ tl(m −1, n),
tl(m, n −1),
tl(m, n −1) + tl+1(m −1, n),
max{tl(m, n1) + tl(m, n2) | n1 ≥1, n2 ≥1, n1 + n2 = n},
max{tl(m1, n) + tl(m2, n) | m1 ≥1, m2 ≥1, m1 + m2 = m}}.
Of course, this can be simpliﬁed to
tl(m, n)
≤
cl · (m + n)
+ max{ tl(m −1, n),
tl(m, n −1) + tl+1(m −1, n),
max{tl(m, n1) + tl(m, n2) | n1 ≥1, n2 ≥1, n1 + n2 = n},
max{tl(m1, n) + tl(m2, n) | m1 ≥1, m2 ≥1, m1 + m2 = m}}
for m, n ≥1. We deﬁne
dk := 2 · ck
and by induction for l = k −1, k −2, . . . , 0
dl := max{2 · cl + cl+1, 21+k−l · dl+1}.

Complexity Issues for Preorders on Finite Labeled Forests
|
183
We are now going to show by induction that
tl(m, n) ≤dl · (m2n1+k−l + mn2+k−l)
(3)
for all m, n ≥1 and 0 ≤l ≤k. This implies the assertion:
tl(m, n) ∈O(m + n + m2n1+k−l + mn2+k−l).
We come to the proof of (3). We have already seen above that (3) is true for
l = k; see (2). Now we consider the case l < k. Remember that we know
tl(0, n) ≤cl · (1 + n)
and
tl(m, 0) ≤cl · (1 + m),
and
tl+1(0, n) ≤cl+1 · (1 + n)
and
tl+1(m, 0) ≤cl+1 · (1 + m),
for m, n ≥0. And by induction hypothesis, we can assume that
tl+1(m, n) ≤dl+1 · (m2n1+k−(l+1) + mn2+k−(l+1))
for all m, n ≥1. In order to show (3) it is suﬃcient to prove the following four
assertions for m, n ≥1:
I.
cl · (m + n) + tl(m −1, n) ≤dl · (m2n1+k−l + mn2+k−l).
II.
cl · (m + n) + tl(m, n −1) + tl+1(m −1, n) ≤dl · (m2n1+k−l + mn2+k−l).
III. For n1, n2 with n1 ≥1, n2 ≥1, and n1 + n2 = n:
cl · (m + n) + tl(m, n1) + tl(m, n2) ≤dl · (m2n1+k−l + mn2+k−l).
IV. For m1, m2 with m1 ≥1, m2 ≥1, and m1 + m2 = m:
cl · (m + n) + tl(m1, n) + tl(m2, n) ≤dl · (m2n1+k−l + mn2+k−l).
Note that the left hand side in the estimates in these assertions which is really
diﬀerent from the left hand side in the corresponding assertion in the proof of
Theorem 7 is the left hand side in II. This left hand side causes the additional term
k −l in the exponent of n. In the proof of II. we will use Lemma 16.
Now we prove these four statements.
I.
cl · (m + n) + tl(m −1, n) ≤dl · (m2n1+k−l + mn2+k−l).

184
|
Peter Hertling and Victor Selivanov
In order to prove this we distinguish two cases.
Case 1: m = 1. Then
cl · (m + n) + tl(m −1, n)
=
cl · (m + n) + tl(0, n)
≤
cl · (m + n) + cl · (1 + n)
=
2cl · (m + n)
≤
dl · (m + n)
≤
dl · (m2n1+k−l + mn2+k−l).
Case 2: m > 1. Then
cl · (m + n) + tl(m −1, n)
≤
cl · (m + n) + dl · ((m −1)2n1+k−l + (m −1)n2+k−l)
=
dl · (m2n1+k−l + mn2+k−l)
+ cl · (m + n) + dl · (−2mn1+k−l + n1+k−l −n2+k−l)
≤
dl · (m2n1+k−l + mn2+k−l)
+ dl · (m + n) + dl · (−2mn1+k−l)
=
dl · (m2n1+k−l + mn2+k−l)
+ dl · (m · (1 −n1+k−l) + n · (1 −mnk−l))
≤
dl · (m2n1+k−l + mn2+k−l).
II.
cl · (m + n) + tl(m, n −1) + tl+1(m −1, n) ≤dl · (m2n1+k−l + mn2+k−l).
In order to prove this, we distinguish four cases.
Case 1: m = 1 and n = 1: Then
cl · (m + n) + tl(m, n −1) + tl+1(m −1, n)
=
cl · 2 + tl(1, 0) + tl+1(0, 1)
≤
cl · 2 + cl · 2 + cl+1 · 2
≤
dl · 2
=
dl · (m2n1+k−l + mn2+k−l).
Case 2: m = 1 and n > 1: Then
cl · (m + n) + tl(m, n −1) + tl+1(m −1, n)
=
cl · (1 + n) + tl(1, n −1) + tl+1(0, n)

Complexity Issues for Preorders on Finite Labeled Forests
|
185
≤
cl · (1 + n) + dl · (12 · (n −1)1+k−l + 1 · (n −1)2+k−l)
+ cl+1 · (1 + n)
≤
dl · (1 + n) + dl · n · (n −1)1+k−l
=
dl · 1 + dl · n · (1 + (n −1)1+k−l)
≤
dl · 1 + dl · n · n1+k−l
=
dl · (1 + n2+k−l)
≤
dl · (m2n1+k−l + mn2+k−l).
Case 3: m > 1 and n = 1: Then
cl · (m + n) + tl(m, n −1) + tl+1(m −1, n)
=
cl · (m + 1) + tl(m, 0) + tl+1(m −1, 1)
≤
cl · (m + 1) + cl · (1 + m)
+ dl+1 · ((m −1)2 · 11+k−l−1 + (m −1) · 12+k−l−1)
=
2cl · (1 + m) + dl+1 · m(m −1)
≤
dl · (1 + m) + dl · m(m −1)
≤
dl · (1 + m2)
≤
dl · (m2n1+k−l + mn2+k−l).
Case 4: m > 1 and n > 1: Then
cl · (m + n) + tl(m, n −1) + tl+1(m −1, n)
≤
cl · (m + n)
+dl · (m2 · (n −1)1+k−l + m · (n −1)2+k−l)
+dl+1 · ((m −1)2 · n1+k−l−1 + (m −1) · n2+k−l−1)
=
cl · (m + n)
+dl · (m2 · (n −1)1+k−l + m · (n −1)2+k−l)
+dl+1 · ((m −1)2 · nk−l + (m −1) · n1+k−l)
≤
cl · (m + n)
+dl · (m2 · (n −1)1+k−l + m · (n −1)2+k−l)
+dl+1 · (m2 · nk−l + m · n1+k−l)
≤
cl · (m + n)
+dl · (m2 · (n −1)1+k−l + m · (n −1)2+k−l)
+2−(1+k−l) · dl · (m2 · nk−l + m · n1+k−l)
≤
cl · (m + n)
(here we use Lemma 16)

186
|
Peter Hertling and Victor Selivanov
+dl · 1
2 · m2 ·

(n −1)1+k−l + n1+k−l
+ dl · m · n2+k−l
=
dl · (m2n1+k−l + mn2+k−l)
+cl · (m + n) + dl · 1
2 · m2 ·

(n −1)1+k−l −n1+k−l
≤
dl · (m2n1+k−l + mn2+k−l)
+1
2 · dl · (m + n) + 1
2 · dl · m2 ·

(n −1)1+k−l −n1+k−l
≤
dl · (m2n1+k−l + mn2+k−l)
because due to k > l we have 1 + k −l ≥2, and, furthermore, due to n ≥2 we
obtain
m2 ·

n1+k−l −(n −1)1+k−l
=
m2 · (n −1)1+k−l ·

n
n −1
1+k−l
−1

≥
m2 · (n −1)2 ·

n
n −1
2
−1

=
m2 ·

n2 −(n −1)2
=
m2 · (2n −1)
=
nm2 + nm2 −m2
≥
n + 2m2 −m2
=
n + m2
≥
n + m.
III. For n1, n2 with n1 ≥1, n2 ≥1, and n1 + n2 = n:
cl · (m + n) + tl(m, n1) + tl(m, n2) ≤dl · (m2n1+k−l + mn2+k−l).
Indeed, for n1, n2 with n1 ≥1, n2 ≥1 and n1 + n2 = n one obtains
cl · (m + n) + tl(m, n1) + tl(m, n2)
≤
cl · (m + n)
+dl · (m2n1+k−l
1
+ mn2+k−l
1
)
+dl · (m2n1+k−l
2
+ mn2+k−l
2
)
≤
dl · (m2n1+k−l + mn2+k−l)
+cl · (m + n)
+dl · m2 · (n1+k−l
1
+ n1+k−l
2
−n1+k−l)
+dl · m · (n2+k−l
1
+ n2+k−l
2
−n2+k−l)

Complexity Issues for Preorders on Finite Labeled Forests
|
187
≤
dl · (m2n1+k−l + mn2+k−l)
+1
2 · dl · (m + n1 + n2)
−dl · m2 · (1 + k −l) · n1 · n2
−dl · m · (2 + k −l) · n1 · n2
≤
dl · (m2n1+k−l + mn2+k−l).
where in the third estimate we used for h ≥2, for n1 ≥1, n2 ≥2, and for
n = n1 + n2:
nh −nh
1 −nh
2 ≥h · nh−1
1
· n2 ≥h · n1 · n2.
IV. For m1, m2 with m1 ≥1, m2 ≥1, and m1 + m2 = m:
cl · (m + n) + tl(m1, n) + tl(m2, n) ≤dl · (m2n1+k−l + mn2+k−l).
Indeed, for n1, n2 with n1 ≥1, n2 ≥1 and n1 + n2 = n one obtains
cl · (m + n) + tl(m1, n) + tl(m2, n)
≤
cl · (m + n)
+dl · (m2
1n1+k−l + m1n2+k−l)
+dl · (m2
2n1+k−l + m2n2+k−l)
≤
dl · (m2n1+k−l + mn2+k−l)
+cl · (m + n)
+dl · n1+k−l · (m2
1 + m2
2 −m2)
≤
dl · (m2n1+k−l + mn2+k−l)
+1
2 · dl · (m1 + m2 + n)
−dl · n1+k−l · 2m1m2
≤
dl · (m2n1+k−l + mn2+k−l).
7 Some Open Questions
Some interesting questions related to the topic of this paper remain open. We have
shown that on Fk the preorders ≤0 and ≤1 are computable in cubic time and ≤2 is
computable in time O(nk+3). It would be interesting to determine the exact com-
plexity classes of these preorders. One may also ask for the complexity of some fur-
ther natural functions related to the quotient posets Fi
k of the preorders (Fk; ≤i),

188
|
Peter Hertling and Victor Selivanov
i ≤2. This applies for example to the rank and spectrum functions deﬁned as fol-
lows. The quotient-posets Fi
k are known [8] to be well posets of rank ω, i.e., they
have neither inﬁnite antichains nor inﬁnite descending chains but they have in-
ﬁnite ascending chains. The rank function rki : Fk →ω measures the rank of
the ≤i-equivalence class [F]i in Fi
k. By the spectrum function on Fi
k we mean the
function spi : ω →ω where spi(n) is the number of elements of rank n in Fi
k.
Bibliography
[1]
J. L. Balcázar, J. Díaz, and J. Gabarró. Structural complexity. I. EATCS Monographs on
Theoretical Computer Science, Vol. 11. Springer, Berlin, 1988.
[2]
J. L. Balcázar, J. Díaz, and J. Gabarró. Structural complexity. II. EATCS Monographs on
Theoretical Computer Science, Vol. 22. Springer, Berlin, 1990.
[3]
V. Brattka and G. Gherardi. Eﬀective choice and boundedness principles in computable
analysis. Bulletin of Symbolic Logic, 17(1):73–117, 2011.
[4]
V. Brattka and G. Gherardi. Weihrauch degrees, omniscience principles and weak com-
putability. J. Symb. Log., 76(1):143–176, 2011.
[5]
B. Davey and H. Priestley. Introduction to Lattices and Order. Cambridge University Press,
Cambridge, second edition, 2002.
[6]
R. G. Downey and M. R. Fellows. Parameterized Complexity Theory. Monographs in
Computer Science. Springer, New York, 1999.
[7]
P. Hertling. A topological complexity hierarchy of functions with ﬁnite range. Technical
Report 223, Centre de recerca matematica, Institut d’estudis catalans, Barcelona, October
1993. Workshop on Continuous Algorithms and Complexity.
[8]
P. Hertling. Topologische Komplexitätsgrade von Funktionen mit endlichem Bild. Informatik
Berichte 152, FernUniversität Hagen, Hagen, December 1993.
[9]
P. Hertling. Unstetigkeitsgrade von Funktionen in der eﬀektiven Analysis. PhD thesis,
Fachbereich Informatik, FernUniversität Hagen, 1996.
[10] P. Hertling and V. L. Selivanov. Complexity issues for preorders on ﬁnite labeled forests.
B. Löwe (ed.) et al., Models of Computation in Context. CiE 2011, LNCS 6735, Springer,
Berlin, 112-121, 2011.
[11] M. D. Hirsch. Applications of topology to lower bound estimates in computer science.
Hirsch, M. W. (ed.) et al., From topology to computation: Proceedings of the Smalefest.
Springer, New York, 395-418, 1993.
[12] A. S. Kechris. Classical descriptive set theory. Graduate Texts in Mathematics. 156. Springer,
Berlin, 1995.
[13] S. Kosub. NP-partitions over posets with an application to reducing the set of solutions of
NP problems. Theory Comput. Syst., 38(1):83–113, 2005.
[14] S. Kosub and K. W. Wagner. The Boolean hierarchy of NP-partitions (extended abstract).
Reichel, Horst (ed.) et al., STACS 2000. LNCS 1770, Springer, Berlin, 157-168, 2000.
[15] O. V. Kudinov and V. L. Selivanov. Undecidability in the homomorphic quasiorder of ﬁnite
labeled forests. Beckmann, Arnold (ed.) et al., Logical approaches to computational
barriers. CiE 2006. LNCS 3988, Springer, Berlin, 289-296, 2006.

Complexity Issues for Preorders on Finite Labeled Forests
|
189
[16] O. V. Kudinov and V. L. Selivanov. Undecidability in the homomorphic quasiorder of ﬁnite
labelled forests. J. Log. Comput., 17(6):1135–1151, 2007.
[17] O. V. Kudinov and V. L. Selivanov. A Gandy theorem for abstract structures and applications
to ﬁrst-order deﬁnability. Ambos-Spies, Klaus (ed.) et al., Mathematical theory and
computational practice. CiE 2009. LNCS 5635, Springer, Berlin, 290-299, 2009.
[18] O. V. Kudinov, V. L. Selivanov, and A. V. Zhukov. Undecidability in Weihrauch degrees. Fer-
reira, Fernando (ed.) et al., Programs, proofs, processes. CiE 2010. LNCS 6158, Springer,
Berlin, 256-265, 2010.
[19] L. Kwuida and E. Lehtonen. On the homomorphism order of labeled posets. Order, 2010.
[20] E. Lehtonen. Labeled posets are universal. Eur. J. Comb., 29(2):493–506, 2008.
[21] V. Selivanov. Boolean hierarchies of partitions over a reducible base. Algebra Logika,
43(1):77–109, 2004. Translation in Algebra and Logic 43, No. 1, 44-61.
[22] V. L. Selivanov. Hierarchies of ∆0
2–measurable k–partitions. Mathematical Logic Quarterly,
53(4–5):446–461, 2007.
[23] T. von Stein. Vergleich nicht konstruktiv lösbarer Probleme in der Analysis. Diplomarbeit,
Fakultät für Informatik, FernUniversität Hagen, March 1989.
[24] K. Weihrauch. The degrees of discontinuity of some translators between representations
of the real numbers. Informatik Berichte 129, FernUniversität Hagen, Hagen, July 1992.
[25] K. Weihrauch. The TTE-interpretation of three hierarchies of omniscience principles.
Informatik Berichte 130, FernUniversität Hagen, Hagen, September 1992.
[26] K. Weihrauch. Computable Analysis. Springer, Berlin, 2000.


Anton Konovalov
Boolean Algebras of Regular
Quasi-aperiodic Languages¹
Abstract: We characterize up to isomorphism the Boolean algebras of regular
quasi-aperiodic languages and of regular d-quasi-aperiodic languages, and show
decidability of classes of languages related to these characterizations.
Keywords: Boolean algebra, Frechét ideal, regular quasi-aperiodic language, reg-
ular d-quasi-aperiodic language.
Mathematics Subject Classiﬁcation 2010: 03G05, 03C13, 06E05, 68Q15
||
Anton Konovalov: A.P. Ershov Institute of Informatics Systems, Siberian Division of the Russian
Academy of Sciences and Novosibirsk State University, Russia
1 Introduction
Boolean algebras are of principal importance for several branches of mathematics.
Accordingly, characterization of naturally arising Boolean algebras attracts atten-
tion of many researchers. As examples we mention characterizations of natural
Boolean algebras in logic and computability theory [4; 5; 10; 11; 12].
In formal language theory, people consider many classes of languages which
form Boolean algebra’s but until recently there was no attempt to characterize
those Boolean algebra’s up to isomorphism. To our knowledge, the ﬁrst papers in
this direction are [6; 13]. Such characterizations could be of some interest because
they provide a new kind information on the classes of languages. Due to Stone
duality, this could contribute to understanding of the corresponding Stone spaces
which, for the case of regular languages, are closely related to the important and
intricate proﬁnite topologies [8; 2].
In this note we characterize up to isomorphism the Boolean algebras of regu-
lar quasi-aperiodic languages and of regular d-quasi-aperiodic languages. These
characterizations are similar to the corresponding characterizations of Boolean
algebras of regular languages RΣ and of regular aperiodic languages AΣ in [13],
though some proofs are diﬀerent.
1 Supported by RFBR Grant 13-01-00015a

192
|
Anton Konovalov
If B is a Boolean algebra and α an ordinal, let Fα(B) be the α-th iterated
Frechét ideal of B, B(α) = B/Fα(B) is the α-th Frechét derivative of B and B′ = B(1).
(See [3] for a detailed treatment, some deﬁnitions are recalled in the next section.)
For a ﬁnite alphabet Σ, let QΣ (resp. QΣ,d) denote the Boolean algebra of all
regular quasi-aperiodic (resp. of all regular d-quasi-aperiodic) languages over Σ.
The main result of this paper looks as follows:
Theorem 1.
1. For any alphabet Σ, QΣ is an atomic Boolean algebra with in-
ﬁnitely many atoms, and Q′
Σ is a countable atomless Boolean algebra.
2. For any d > 1 and a unary alphabet Σ, QΣ,d is an atomic Boolean algebra with
inﬁnitely many atoms, and Q′
Σ,d is an Boolean algebra with 2d elements.
3. For any d > 1 and alphabet Σ with at least two symbols, F0(QΣ,d) ⊂F1(QΣ,d) ⊂
· · · ⊂Fω(QΣ,d) = Fω+1(QΣ,d), for each n < ω the Boolean algebra Q(n)
Σ,d is
atomic with inﬁnitely many atoms, and Q(ω)
Σ,d is a countable atomless Boolean
algebra.
From some well-known facts on Boolean algebra’s (see Chapter 1 of [3]) it follows
that items 1 – 3 characterize the corresponding Boolean algebra’s up to isomor-
phism. Moreover, our proofs imply decidability of the classes of regular quasi-
aperiodic languages related to the main theorem.
The main result of this paper and the corresponding result about languages
of ﬁnite words imply the following
Corollary 2. For any d > 1 and alphabet Σ with at least two symbols, QΣ ≃RΣ and
QΣ,d ≃AΣ where ≃denotes the isomorphism relation.
In Sections 2 and 3 we provide the necessary Boolean algebrackground on
Boolean algebra’s and on regular languages, respectively. In Sections 4 and 5
we characterize the Boolean algebra’s QΣ and QΣ,d, respectively.
2 Preliminaries on Boolean Algebras
In this section we very brieﬂy recall some notions and facts on Boolean algebra’s
used in the sequel (more details are contained in [13]). We assume the reader to
be familiar with Boolean algebrasic notions related to Boolean algebra’s like ideal
of a Boolean algebra, quotient-algebra of a Boolean algebra modulo a given ideal,
and canonical homomorphism of a Boolean algebra onto its quotient-algebra (for

Boolean Algebras of Regular Quasi-aperiodic Languages
|
193
detailed treatments of Boolean algebra’s we refer to [3; 14]). Boolean algebra’s are
considered in the signature {∪, ∩,¯, 0, 1}.
Recall that element a of a Boolean algebra A is an atom if a ̸= 0 and x < a
implies x = 0. A Boolean algebra A is atomless if it has no atom, and it is atomic
if below any non-zero element there is an atom. The ideal of a Boolean algebra
A generated by atoms is called Frechét ideal of A. It consists of all ﬁnite unions
(including the empty union which coincides with 0) of atoms and it is denoted
by F(A). The quotient-algebra A/F(A) is called the Frechét derivative of A and is
denoted by A′.
Deﬁne the transﬁnite sequence {Fα(A)} of iterated Frechét ideals of a Boolean
algebra A as follows: F0(A) = {0}, Fβ+1(A) = {x | x/Fβ(A) ∈F(A(β))} where
A(β) = A/Fβ(A), and Fα(A) = 
β<α Fβ(A) for a limit ordinal α. This sequence is
ascending under inclusion, and Fα(A) = Fα+1(A) for some α; the least ordinal α
with this property is called the ordinal type of A and is denoted σ(A). In this paper
we use Frechét ideals only for α ≤ω.
3 Preliminaries on Regular Languages
Here we brieﬂy recall some notation, notions and facts on regular languages used
in the sequel. Let Σ∗denote the set of words over Σ including the empty word ε
and let Σ+ denote the set non-empty of words over Σ. For any n < ω, let Σn be the
set of words over Σ of length n. The length of a word w is denoted by |w|. Let ⊑be
the preﬁx partial order on Σ∗, i.e. u ⊑v iﬀux = v for some x ∈Σ∗.
We freely use some standard deﬁnitions and notation on words, regular
languages and ﬁnite automata like regular expressions or deterministic ﬁnite au-
tomata (DFA) denoted as A = (Q, Σ, f , q0, F) (for a more systematic treatment
see e.g. [15; 9; 17; 18]). The automaton A recognizes the language LA = {u ∈Σ∗|
q0 · u ∈F} where q · u = f(q, u) is the state reached by A when it reads the word
u started from a state q. Let RΣ denote the class of regular languages over Σ (i.e.,
languages recognized by DFA’s or, equivalently, denoted by regular expressions)
For L ∈RΣ, ML denotes the minimal DFA that recognizes L; the minimal DFA is
unique up to isomorphism.
Recall that a language L is called decidable (or Turing-decidable), if there ex-
ists a Turing Machine M such that on input x, M accepts if x ∈L, and M rejects
otherwise (for a more systematic treatment see e.g. [19]).
The following fact is the simplest form of pumping lemma (see e.g. [18] for
more details).

194
|
Anton Konovalov
Proposition 3. For any language L ∈RΣ there is k < ω such that any word w ∈L
with |w| ≥k may be factorized as w = xyz where |xy| ≤k, |y| ≥1 and xynz ∈L
for each n < ω.
For k < ω, a language L ∈RΣ is called k-sparse if the function pL(n) = |Σn ∩L|
is O(nk) (cf. [16; 18]). Let Sk denote the class of regular k-sparse languages over
Σ. Note that S0 ⊂S1 ⊂· · · . Languages from Sω = 
k<ω Sk are called sparse lan-
guages. 0-sparse languages are also known as slender languages. We will need the
following characterizations of k-sparse languages in terms of regular expressions
(cf. [16; 18; 7]).
Proposition 4. For any L ∈RΣ and k < ω, L ∈Sk iﬀL is a ﬁnite union of languages
xy∗
0z0 · · · y∗
kzk where x, yi, zi ∈Σ∗.
There is also a nice characterization of sparse languages in terms of (graphs of)
their minimal automata (cf. [7]). We say that a DFA A has an ω-pattern if there are
u, v1, v2, w ∈Σ∗such that v1, v2 are ⊑-incomparable (i.e., v1(i) ̸= v2(i) for some
i < |v1|, |v2|), q0 · u = q0 · uv1 = q0 · uv2 and q0 · uv1w ∈F.
Proposition 5. For any L ∈RΣ, L ∈Sω iﬀthe minimal DFA of L has no ω-pattern.
For q ∈Q and u ∈Σ∗, let (q, u) denote the path in DFA A along u started at
q, and let Q(q, u) = {q · v | v ⊑u}. We say that a path (q, u) meets a set of
states G ⊆Q if Q(q, u) ∩G ̸= ∅. A path (q, u) is a cycle of A if u is nonempty and
q · u = q. A cycle is simple if it has no repeated vertices other that the starting
and ending vertices. Let CA be the set of all Q(q, u) where (q, u) is a cycle of A.
Deﬁne the preorder ≤on CA as follows: G ≤H if there is a path of A starting in
G and ending in H. Note that if G ≡H then K ≡G for some K ⊇G ∪H, i.e. any
element [G] of the quotient-set CA/ ≡has a greatest set under inclusion; these
greatest sets are called strongly connected components (SCC’s) of A and they may
serve as canonical representatives for the equivalence classes [G]. The next result
is known (cf. [7]) and easy to check.
Proposition 6. For any sparse language L = LA ∈RΣ and any u ∈L, if the path
(q0, u) meets a SCC G of A then [G] = {G} is a singleton, and G = Q(s, v) for some
simple cycle of A.
Lemma 7. Let L ∈RΣ, let the minimal DFA ML has no ω-pattern and let F0 < · · · <
Fk+1 - SCC’s of automata ML such that some ﬁnal state of ML is reachable from
Fk+1. Then there exist x, yi, zi ∈Σ∗and si ∈Fi such that xy∗
0z0 · · · y∗
k+1zk+1 ⊆L,
Fi = Q(si, yi) for each i ≤k + 1, (si, yi) is a simple cycle of ML, q0 · x ∈F0,

Boolean Algebras of Regular Quasi-aperiodic Languages
|
195
q0 · xz0 ∈F1, . . . , q0 · xz0 · · · zk ∈Fk+1, q0 · xz0 · · · zk+1 ∈F, the words zi are
nonempty, and for each i < k + 1 the ﬁrst letters in yi, zi are distinct.
Proof. Choose an accepting path u in ML that meets all SCC’s F0, . . . , Fk+1. Then
existence of the desired objects (except maybe the property that the ﬁrst letters in
yi, zi are distinct) follows from Proposition 6. The last property may be achieved
by “shifting” the cycles (si, yi) if needed.
Proposition 8. For any L ∈RΣ and k < ω, L ∈Sk iﬀthe minimal DFA ML has
no ω-pattern and there is no chain F0 < · · · < Fk+1 of SCC’s of ML such that a ﬁnal
state of ML is reachable from Fk+1.
Proof. Let L ∈Sk, then ML has no ω-pattern by Proposition 5. Suppose, for a con-
tradiction, that a chain as above exists. Consider the language xy∗
0z0 · · · y∗
k+1zk+1,
where the words from the Lemma 7 are used. By lemma 1 and lemma 2 in [16] we
get xy∗
0z0 · · · y∗
k+1zk+1 ̸∈Sk. A contradiction.
For the opposite direction, assume that there is no chain of length k + 1 as
in the formulation. There are only ﬁnitely many of such chains of length ≤k + 1.
By Proposition 6, L is a ﬁnite union of languages of the form xy∗
0z0 · · · y∗
t zt, t ≤k
constructed as in the last paragraph. By Proposition 4 L ∈Sk.
We also recall the following classical fact of automata theory. A DFA A is called
counter-free if q · un = q implies q · u = q, for all q ∈Q, u ∈Σ+ and n > 0, in
other words, if A has no counting pattern. Recall that a counting pattern for A is
a simple cycle (q, un) where u ∈Σ+ and n > 1. A counting pattern (q, un) of a
DFA A is called d-balanced counting pattern (where d ≥1) if u ≡0modd. Note
that in [21] deﬁnitions of counting patterns of d-balanced counting patterns look
slightly diﬀerent but they are clearly equivalent to the deﬁnitions here for the case
of minimal DFA’s.
Proposition 9. [20] For any L ∈RΣ the following conditions are equivalent:
1. There is some d ≥1 such that L can be constructed from singleton languages
{a}, a ∈Σ and the language (Σd)∗by ﬁnite applications of operations of union,
complementation, and concatenation.
2. There is some d ≥1 such that there is n < ω such that xynz ∈L iﬀxyn+1z ∈L
for all x, y, z ∈Σ∗with |y| ≡0 mod d.
Languages satisfying the conditions in the last proposition are called quasi-
aperiodic. By quasi-aperiodicity index of a quasi-aperiodic language L we mean
the least number n satisfying the condition 2 above. The class QΣ of regular quasi-
aperiodic languages over Σ is closed under the Boolean operations.

196
|
Anton Konovalov
Proposition 10. [20; 21] For any L ∈RΣ and d ≥1 the following conditions are
equivalent:
1. L can be constructed from singleton languages {a}, a ∈Σ and the language
(Σd)∗by ﬁnite applications of operations of union, complementation, and con-
catenation.
2. There is n < ω such that xynz ∈L iﬀxyn+1z ∈L for all x, y, z ∈Σ∗with
|y| ≡0 mod d.
3. The minimal DFA of L has no d-balanced counting pattern.
Languages satisfying the conditions in the last proposition are called d-quasi-
aperiodic. Note that the class of 1-quasi-aperiodic languages coincides with the
class of aperiodic laguages. By d-quasi-aperiodicity index of a d-quasi-aperiodic
language L we mean the least number n satisfying the condition 2 above. The class
QΣ,d of regular d-quasi-aperiodic languages over Σ is closed under the Boolean op-
erations and under concatenation.
There are several other important characterizations of the class QΣ and QΣ,d
but in this paper we use only those mentioned above. For a more systematic treat-
ment see e.g. [21; 20].
4 The Boolean Algebra QΣ
First we characterize the Boolean algebra QΣ formed by the class QΣ of regular
quasi-aperiodic languages over Σ. Thus, we prove item 1 of the main theorem from
Introduction.
Proposition 11.
1. For any alphabet Σ, QΣ is an atomic Boolean algebra with in-
ﬁnitely many atoms, and Q′
Σ is a countable atomless Boolean algebra.
2. The class F(QΣ) is decidable.
Proof.
1. Obviously, the atoms of QΣ are exactly the singleton languages, hence
the ﬁrst assertion holds. For the second assertion, it suﬃces to show that for
any inﬁnite language L ∈QΣ there is an inﬁnite regular quasi-aperiodic lan-
guage M ⊆L such that L\M is inﬁnite. By Proposition 3, there are x, y, z ∈Σ∗
such that |y| ≥1 and xy∗z ⊆L. Note that by proposition 9 the language
x(yn)∗z is quasi-aperiodic (with d = |yn|) for any n < ω. Then the language
M = x(yy)∗z has the desired properties.
2. The assertion is well-known because F(QΣ) is the class of ﬁnite languages.

Boolean Algebras of Regular Quasi-aperiodic Languages
|
197
According to Proposition 1.8.3 of [3]), the item 1 of Proposition 11 characterizes the
Boolean algebra QΣ up to isomorphism. This immediately implies
Corollary 12. For any alphabet Σ, QΣ ≃RΣ.
Proof. Since Boolean algebra RΣ has the same properties as in item 1 of Proposi-
tion 11 (see [6; 13]), QΣ ≃RΣ.
5 The Boolean Algebra QΣ,d
First we characterize the Boolean algebra QΣ,d formed by the class QΣ,d of d-quasi-
aperiodic regular languages over a unary alphabet Σ. Thus, we prove item 2 of the
main theorem from Introduction.
We recall that a non-empty word u ∈Σ∗is called primitive if vn = u implies
n = 1 (and hence v = u) for all v ∈Σ+. It is well known [22] that any non-empty
word is uniquely representable as a power of a primitive word. In other words if
un = vm and u, v are primitive then u = v and m = n.
Lemma 13. Let L ∈QΣ,d, A be the minimal DFA of L, (q, y) be a cycle of A, and
y = vk for a primitive word v and k > 0. Then k divides d
n where n is the greatest
common divisor of d and |v|.
Proof. Consider the word w = v
d
n . Since |w| = |v| · d
n and n divides |v|, both d and
|v| divide |w|. Since L ∈QΣ,d, by Proposition 10 (q, wm) is not a counting pattern
of A for each m ≥2, hence |y| divides |w|. Thus, |v| · d
n = |w| = k · |v| · q for some
integer q ≥1. Therefore, k divides d
n .
Lemma 14. Let y = vk ∈Σ+ where v is primitive and k > 0. Then y∗∈QΣ,d iﬀk
divides d
n where n is the greatest common divisor of d and |v|.
Proof. Clearly, the minimal DFA A of y∗has |y| + 1 states q0, . . . , q|y| where q0 is
the initial state which is also the unique accepting state, qi · y(i) = qi+1 for each
i < |y| −1, qi · y(i) = q0 for i = |y| −1, and q|y| is the sink state that attracts
all other transitions of A. Then implication from left to right follows immediately
from the previous lemma.
Conversely, let k divide d
n , i.e. d
n = k · q for some integer q ≥1. By Proposition
10, it suﬃces to show that A has no d-balanced counting pattern, i.e., if (s, wm) is
a cycle of A and d divides |w| then already (s, w) is a cycle of A. By the structure of
A, we may w.l.o.g. assume that s = q0 and q|y| is not in the cycle (q0, wm). Then

198
|
Anton Konovalov
yl = wm for some integer l ≥1. Let w = uj where u is primitive and j ≥1, then
vkl = yl = ujm. Since u and v are primitive, u = v and hence w = vj. Since d and
|v| divide |w| and d|v|
n
is the greatest common divisor of d and |v|, d|v|
n
divides |w|.
Then for some integer p ≥1 we have |w| = d|v|
n
· p = k · q · |v| · p, hence k · |v|
divides |y|. Therefore, q0 · w = q0.
Corollary 15. For any y ∈Σ+, y∗∈QΣ,|y|. Furthermore, Sω ⊆QΣ.
Proof. The ﬁrst assertion follows from the previous lemma (take d = |y|). For the
second assertion, it suﬃces to show (by Proposition 4) that L ∈QΣ for any lan-
guage L of the form xy∗
1z1 . . . y∗
kzk where k ≥1 and y1, . . . yk ∈Σ+. By the ﬁrst as-
sertion, L ∈QΣ,d ⊆QΣ where d is the least common multiple of |y1|, . . . , |yk|.
Proposition 16. For any unary alphabet Σ = {a} and d > 1, QΣ,d is an atomic
Boolean algebra with inﬁnitely many atoms, and Q′
Σ,d is a Boolean algebra with 2d
elements.
Proof. Obviously, the atoms of QΣ,d are exactly the singleton languages, hence the
ﬁrst assertion holds. Let Lj = aj(ad)∗, where j < ω. It is clear that Lj ∈QΣ,d, L′
j ̸= 0
for any j < ω and L′
i ∩L′
j = ⊘for any distinct i, j < d, where L′
i = Li/F1(QΣ,d). For
the second assertion it suﬃces to show that L′
i is atom in Q′
Σ,d for all i < d and for
any inﬁnite L ∈QΣ,d there is j < d such that L′
j ⊆L′.
We have to show that if M is an inﬁnite d-quasi-aperiodic subset of Li then
Li \ M is ﬁnite. We have ai(ad)m ∈M for inﬁnitely many m. By proposition 10,
ai(ad)m ∈M for all m ≥n, where n is the d-quasi-aperiodicity index of M. There-
fore Li \ M is a ﬁnite. It is clear that for any k ≥d there is j < d such that L′
k = L′
j,
hence L′
i is atom in Q′
Σ,d for all i < d.
Consider an arbitrary inﬁnite d-quasi-aperiodic language L. By Proposition 3,
there are x, y, z ∈Σ∗such that |y| ≥1 and xy∗z ⊆L. As Σ = {a}, then xy∗z =
ai(ak)∗for some i, k < ω. By Lemma 14 k divides d and hence ai(ad)∗⊆ai(ak)∗⊆
L. Thus L′ ⊇L′
i for some i < d.
To characterize the Boolean algebra QΣ,d for non-unary alphabets Σ, we need next
lemmas.
Lemma 17. Let y = vk ∈Σ+ where v is primitive and k > 0, and let y∗∈QΣ,d.
Then there is a word w ∈(Σd)+ such that y∗is a ﬁnite union of languages of the
form x · w∗, x ∈Σ∗.

Boolean Algebras of Regular Quasi-aperiodic Languages
|
199
Proof. By Lemma 14, d
n = k · q for some integer q ≥1. By the proof of Lemma 13,
for the word w = v
d
n we have w ∈(Σd)+ and |y| divides |w|. Thus,
y∗= (vk)∗= w∗∪vk · w∗∪· · · ∪vk(q−1) · w∗
is a desired representation.
Lemma 18. For any k < ω and x, zi ∈Σ∗, yi ∈Σ+ with y∗
1, · · · , y∗
k ∈QΣ,d,
xy∗
1z1 · · · y∗
kzk ∈Fk+1(QΣ,d). If, in addition, yi(0) ̸= zi(0) for each i = 1, . . . , k
then xy∗
1z1 · · · y∗
kzk ̸∈Fk(QΣ,d).
Proof. Representing any yi as in the previous lemma and using the fact that con-
catenation is distributive with respect to ∪, we see that w.l.o.g. we may assume
that y1, . . . , yk ∈(Σd)+. To prove the ﬁrst assertion it suﬃces to check the state-
ment by induction on k. For k = 0 this is obvious because L = {x} is an atom of
QΣ,d = Q(0)
Σ,d.
Let k = 1. The case y1 = ε is trivial, so assume y1 to be non-empty. Then L is
inﬁnite and we have to show that if A is an inﬁnite d-quasi-aperiodic subset of L
then L \ A is ﬁnite. We have xym
1 z1 ∈A for inﬁnitely many m. By Proposition 10,
xym
1 z1 ∈A for all m ≥n where n is the d-quasi-aperiodicity index of A. Therefore,
L \ A is ﬁnite.
Let now k ≥2. For any n < ω, set Ln = xyn
1y∗
1z1 · · · yn
ky∗
kzk, then L = L0 ⊃
L1 ⊃L2 ⊃· · · , where L = xy∗
1z1 · · · y∗
kzk. It suﬃces to show that for any d-quasi-
aperiodic language A ⊆L at least one of languages A, L \ A is in Fk(QΣ,d). We
distinguish two cases.
Case 1. Ln ⊆A for some n. Then A = L \ A ⊆L \ Ln ∈Fk(QΣ,d) by the proof
for k = 1. Thus, A ∈Fk+1(QΣ,d).
Case 2. Ln ̸⊆A for all n, i.e. for any n there are m1, m2 ≥n such that
xym1
1 z1ym2
2 z2 ∈A. By Proposition 10, xym1
1 z1ym2
2 z2 ∈A for all m1, m2 ≥m where
m is the d-quasi-aperiodicity index of A. Then Lm ⊆A, hence L \ A ⊆L \ Lm ∈
Fk(QΣ,d), hence L \ A ∈Fk(QΣ,d).
For the second assertion, represent any yi as yi = vki
i where vi are primitive,
and let, as above, wi = v
d
ni
i . Then wi ∈(Σd)+ and xw∗
1z1 · · · w∗
kzk ⊆xy∗
1z1 · · · y∗
kzk,
hence it suﬃces to check that xw∗
1z1 · · · w∗
kzk ̸∈Fk(QΣ,d). The assertion xw∗
1z1 ̸∈
F1(QΣ,d) is clear because the language xw∗
1z1 is inﬁnite while F1(QΣ,d) is the class
of ﬁnite languages.
The language xw∗
1z1w∗
2z2 is a disjoint union of languages Kn = xwn
1z1w∗
2z2,
and, for each n, Kn/F1(QΣ,d) is an atom of Q′
Σ,d by the ﬁrst assertion. Therefore,
xw∗
1z1w∗
2z2 ̸∈F2(QΣ,d). Continuing in this manner, we derive the desired asser-
tions.

200
|
Anton Konovalov
Lemma 19. For any L ∈Fω(QΣ,d), the minimal DFA of L has no ω-pattern.
Proof. By contraposition, assume that the minimal DFA of L has an ω-pattern with
some words x, y1, y2, z. We assume w.l.o.g. that y1(0) ̸= y2(0). We have to show
that L ̸∈Fω(QΣ,d). Since x(y1+y2)∗z ⊆L, it suﬃces to show that xy∗
1z ̸∈Fω(QΣ,d),
xy∗
1y2y∗
1z ̸∈Fω(QΣ,d), xy∗
1y2y∗
1y2y∗
1z ̸∈Fω(QΣ,d) and so on. But this holds by the
previous lemma.
Theorem 20. For any L ∈QΣ,d the following conditions are equivalent:
1. L ∈Fω(QΣ,d).
2. The minimal DFA of L has no d-balanced counting pattern and has no ω-
pattern.
3. L ∈QΣ,d ∩Sω.
4. L is a ﬁnite union of languages xy∗
0z0 · · · y∗
kzk where k < ω, x, yi, zi ∈Σ∗and
y∗
0, · · · , y∗
k ∈QΣ,d.
Proof. 1→2. This follows from the previous lemma and Proposition 10.
2↔3. This follows from Propositions 10 and 5.
2→4. The desired representation of L follows from Lemmas 7 and 14
4→1. This follows from Lemma 18.
Corollary 21. The class of regular d-quasi-aperiodic languages Fω(QΣ,d) is decid-
able.
Next we characterize Fk(QΣ,d) for any k < ω. Note that F0(QΣ,d) = {∅} and
F1(QΣ,d) is the class of ﬁnite regular d-quasi-aperiodic languages over Σ.
Theorem 22. For any k < ω and L ∈RΣ the following conditions are equivalent:
1. L ∈Fk+2(QΣ,d).
2. The minimal DFA of L has no d-balanced counting pattern, has no ω-pattern,
and there is no chain F0 < · · · < Fk+1 of SCC’s of ML such that a ﬁnal state of
ML is reachable from Fk+1.
3. L ∈QΣ,d ∩Sk.
4. L is a ﬁnite union of languages xy∗
0z0 · · · y∗
kzk where
x, yi, zi ∈Σ∗and y∗
0, · · · , y∗
k ∈QΣ,d .
Proof. 1→2. This follows from Proposition 10, Lemma 19 and the proofs of Lemma
19 and Proposition 8.
2↔3. This follows from Propositions 10 and 8.
2→4. The desired representation of L follows from Lemmas 7 and 14.

Boolean Algebras of Regular Quasi-aperiodic Languages
|
201
4→1. This follows from Lemma 18.
Now we are able to prove the item 3 of the main theorem in Introduction.
Theorem 23. For any alphabet Σ with at least two symbols,
F0(QΣ,d) ⊂F1(QΣ,d) ⊂· · · ⊂Fω(QΣ,d) = Fω+1(QΣ,d) ,
for each n < ω the Boolean algebra Q(n)
Σ,d is atomic with inﬁnitely many atoms, and
Q(ω)
Σ,d is a countable atomless Boolean algebra.
Proof. First we check that Fk(QΣ,d) ⊂Fk+1(QΣ,d for each k < ω. For k = 0 the
inclusion is trivial. Let a, b ∈Σ, a ̸= b, and let y = ad and z = bd, then y∗, z∗∈
QΣ,d. By Lemma 18
y∗∈F2(QΣ,d) \ F1(QΣ,d), y∗zy∗∈F3(QΣ,d) \ F2(QΣ,d),
y∗zy∗zy∗∈F4(QΣ,d) \ F3(QΣ,d),
and so on.
By Lemma 18 the elements y∗/F1(QΣ,d), y∗zy∗/F2(QΣ,d), . . . are atoms re-
spectively in the Boolean algebra’s Q(1)
Σ,d, Q(2)
Σ,d, . . ., and the same applies to the
elements zny∗/F1(QΣ,d), zny∗zy∗/F2(QΣ,d), . . . for each n < ω. Since the lan-
guages zny∗(as well as the languages zny∗zy∗and so on) are pairwise disjoint
for distinct n, the Boolean algebra’s Q(1)
Σ,d, Q(2)
Σ,d, . . . have inﬁnitely many atoms (as
well as the Boolean algebra Q(0)
Σ,d = QΣ,d).
Next we check that the Boolean algebra Q(k)
Σ,d is atomic for each k < ω. For
k < 2 this is again obvious, so it remains to show that for any k < ω and L ∈QΣ,d \
Fk+2(QΣ,d) there is a d-quasiaperiodic language A ⊆L such that A/Fk+2(QΣ,d) is
an atom of Q(k+2)
Σ,d
. We distinguish the cases L ̸∈Fω(QΣ,d) and L ∈Fω(QΣ,d).
In the ﬁrst case, the minimal DFA ML of L has an ω-pattern, hence A exists by
Theorem 20 and the proof of Lemma 19. In the second case, by Theorem 20 and
Lemma 7 there are SCC’s F0 < · · · < Fk+1 and the words speciﬁed there. The words
z0, . . . , zk are non-empty and the ﬁrst letters in zi, yi are distinct for each i ≤k.
Since ML has no d-balanced counting pattern, y∗
0, · · · , y∗
k ∈QΣ,d. Then by (the
proof of) Lemma 18 the language A = xy∗
0z0 · · · y∗
kzk has the desired property.
To prove the remaining assertions for the Boolean algebra QΣ,d, it suﬃces to
show that for any L ∈QΣ,d \ Fω(QΣ,d) there is a d-quasiaperiodic language M ⊆L
such that M, L \ M ̸∈Fω(QΣ,d). By Proposition 10 and Theorem 20, the minimal
DFA ML of L has no d-balanced counting pattern but has an ω-pattern formed
by some words x, y1, y2, z such that y1(0) ̸= y2(0). Since ML has no d-balanced
counting pattern, y∗
1, y∗
2 ∈QΣ,d. By the proof of Lemma 19, we can take M =
xy1(y1 + y2)∗z.

202
|
Anton Konovalov
Similar to Corollary 12 we obtain
Corollary 24. For any d > 1 and alphabet Σ with at least two symbols, QΣ,d ≃AΣ.
Acknowledgement: I am grateful to Victor Selivanov for stating the problem of
characterization the Boolean algebra of regular languages and for providing a
copy of his paper [21], and also for many useful discussions of quasi-aperiodic
and d-quasi-aperiodic languages.
Bibliography
[1]
C. Choﬀrut and J. Karhumäki. Combinatorics of Words. A chapter of Handbook of Formal
Languages, Berlin, Springer, 1997.
[2]
M. Gehrke, S. Grigorieﬀand J.-E. Pin. Duality and equational theory of regular languages.
Proc. of ICALP 2008, Lecture Notes in Computer Science, v. 5126, Springer Verlag, (2008),
246–257.
[3]
S.S. Goncharov. Countable Boolean Algebras and Decidability. Plenum, New York, 1996.
[4]
W. Hanf, The boolean algebra of logic. Bull. Amer. Math. Soc., 20, No 4 (1975), 456–502.
[5]
S. Lempp, M. Peretyat’kin and R. Solomon. The Lindenbaum algebra of the theory of the
class of all ﬁnite models. Journal of Mathematical Logic 2, No 2 (2002), 145–225.
[6]
C. Marini, A. Sorbi, G. Simi, M. Sorrentino. A note on algebras of languages. Theoretical
Computer Science , v. 412 (2011), 6531–6536.
[7]
J.-E. Pin. Unpublished manuscript on regular languages.
[8]
N. Pippenger. Regular languages and Stone duality. Theory of Computing Systems, 30, No
2 (1997), 121–134.
[9]
D. Perrin and J.-E. Pin. Inﬁnite Words. v. 141 of Pure and Applied Mathematics, Elsevier,
2004.
[10] V. L. Selivanov. Universal Boolean algebras with applications. Abstracts of Int. Conf. in
Algebra, Novosibirsk, 1991, 127 (in Russian).
[11]
V. L. Selivanov. Hierarchies, Numerations, Index Sets. Handwritten notes, 1992, 290 pp.
[12] V. L. Selivanov. Positive structures. In: Computability and Models, Perspectives East
and West, S. Boolean algebrarry Cooper and Sergei S. Goncharov, eds., Kluwer Aca-
demic/Plenum Publishers, New York, 2003, 321–350.
[13] V. Selivanov and A. Konovalov. Boolean Algebras of Regular Languages. DLT 2011, LNCS
6795, G. Mauri and A. Leporati, eds., Springer, Heidelberg, 2011, 386–396.
[14] R. Sikorski. Boolean Algebras. Springer-Verlag, Berlin, 1964.
[15]
H. Straubing. Finite automata, formal logic and circuit complexity. Birkhäuser, Boston,
1994.
[16] A. Szilard, S. Yu, K. Zhang and J. Shallit. Characterizing Regular Languages with Polyno-
mial Densities. Proc. of MFCS, Lecture Notes in Computer Science, v. 629 (1992), 494–
503.
[17]
W. Thomas. Languages, automata and logic. Handbook of Formal Language theory, v. B
(1996), 133–191.

Boolean Algebras of Regular Quasi-aperiodic Languages
|
203
[18] S. Yu. Regular Languages. A chapter of Handbook of Formal Languages, ed. G. Rozenberg
and A. Salomaa, Springer, 1997.
[19] M. Davis. Computability and Unsolvability. McGraw-Hill Book Company, 1958.
[20] Z. Wu. Quasi-star-free Languages on Inﬁnite Words. Acta Cybernetica, v. 17, No. 1, (2005),
75–93.
[21] V.L. Selivanov. Hierarchies and reducibilities on regular languages related to modulo
counting. RAIRO Theoretical Informatics and Applications, 41 (2009), 95–132.
[22] R. C. Lyndon and M. P. Schützenberger. The Equation aM = bNcP in a Free Group. Mich-
gan Math. J., 9(1962), 289-298.


Eryk Kopczyński, Damian Niwiński
A Simple Indeterminate Inﬁnite Game¹
Abstract: We show a proof of the existence of an indeterminate game with perfect
information, which can be taught to high school students. The winning criterion is
based on an inﬁnite XOR, i.e., a Boolean function over inﬁnite strings of bits, such
that the change of one bit in an argument changes the value. The indeterminacy
follows by strategy stealing technique.
Keywords: Inﬁnite games, perfect information games, determinacy, strategy steal-
ing
Mathematics Subject Classiﬁcation 2010: 03E25, 03E60
||
Eryk Kopczyński and Damian Niwiński: Faculty of Mathematics, Informatics and Mechanics,
University of Warsaw, Poland.
1 Introduction
One of the simplest and yet non-trivial results in foundations of mathematics,
which can be presented to high school pupils, is the Theorem of Zermelo on the de-
terminacy of the game of chess [14]: either Black or White has a winning strategy,
or both players have strategies to achieve a draw.
The proof smoothly generalizes the problem to all ﬁnite games with perfect in-
formation², and reveals an algorithmic aspect of the result. The message however
remains incomplete if we hide from our students that even perfect information
games can be indeterminate if we allow the players to make inﬁnite sequences of
moves.
Inﬁnite games have a long history started with mathematical puzzles consid-
ered by Stefan Banach and Stanisław Mazur in the 1930s; see [10] for concise in-
troduction and [13] for historical overview. Although such games can hardly be
played in real life, they are vital for multiple areas of mathematics—in particular
descriptive set theory [6; 9], and also for computer science; see [4] for a survey.
1 The authors were supported by the Polish Ministry of Science grant nr N N206 567840.
2 In a two player perfect information game both players know the current state of the game, and
the future depends uniquely on their moves, see, e.g., [10].

206
|
Eryk Kopczyński and Damian Niwiński
Indeterminacy of perfect information two player inﬁnite games was observed
in the ﬁrst published work on such games [3]. It means that, even though an actual
choice of players’ strategies always determines the result of the game, a winning
strategy may not exist for any of the players, which makes the result of the game
indeterminate. From a teaching perspective, we can note a remote analogy with
real life games. Indeed, the result of a chess match is “indeterminate” for us
because the players presumably ignore the optimal strategies. But we know
from the Zermelo Theorem that such optimal strategies exist. In contrast, for inﬁ-
nite games, the winning (or optimal) strategies may not exist at all.
The existence of indeterminate games can be proved in many ways, which
however usually introduce some bits of mathematics unknown to high school
pupils. Indeterminate games can be constructed by a diagonal argument using
transﬁnite induction (see, e.g., [5]); their existence can be also inferred from a clas-
sical result in general topology, namely the Bernstein partition of a Polish space
into two parts, none of which contains a perfect set³ (see, e.g., [10]). Another argu-
ment, game-theoretic in ﬂavour, can be used to show indeterminacy of a certain
game based on a Fréchet ultraﬁlter; the authors learned this example from the
unpublished lecture notes⁴ by Jacques Duparc[2]. This argument uses the strat-
egy stealing technique, which is well known for solving ﬁnite games, in particular
Hex. It is based on the following reasoning:
If player B had a winning strategy, it could be used to construct a winning strategy for player
A.
As ﬁnite games are determined, this implies that player A has winning strategy.
In case of inﬁnite games however, the same argument implies indeterminacy, as-
suming that the dependence above holds in both directions (i.e., A →B, and B →
A).
In the present note, we use a similar argument to show the indeterminacy of
a conceptually simpler game based on an inﬁnite XOR function, i.e., a function
f : {0, 1}ω →{0, 1}, such that the change of one bit in an argument changes
the value. (From {0, 1}n to {0, 1}, there are clearly only two such functions:
XOR and ¬ XOR.) A bit of advanced mathematics is only needed to show that
such functions exist. Here the use of the Axiom of Choice is unavoidable, but no
transﬁnite induction is necessary. We took an idea of inﬁnite XOR function from
3 Because the set of plays consistent with any strategy (in particular, a hypothetical winning
strategy) forms a perfect set.
4 A similar proof appears in lecture notes by Alessandro Andreta [1].

A Simple Indeterminate Inﬁnite Game
|
207
Michael Sipser [12], who showed that inﬁnite XOR functions cannot be computed
by countable Boolean circuits. This unpublished work constitutes an interesting
link between set-theoretic topology and complexity theory. Recall that the cele-
brated Furst-Saxe-Sipser Theorem shows that (ﬁnitary) XOR function cannot be
computed by polynomial-size circuits of bounded depth, and according to [12],
the solution to the inﬁnitary problem “proved to be useful to direct the search for
the solution to the ﬁnitary one”.
Bibliographical note
The proof presented in this paper has been invented by the ﬁrst author for a course
held by the second author at the University of Warsaw in 2008–2009. The second
author used this proof in his talk at the congress on Square of Opposition [11]. We
have been aware that the indeterminacy of the inﬁnite XOR games is not surprising
per se, as the winning criteria are non-measurable here.
After having submitted the ﬁrst version of this article, we have learned that
inﬁnite XOR functions are familiar in descriptive set theory under the name of
ﬂip sets (more precisely, XOR functions are characteristic functions of ﬂip sets).
More importantly, also the idea of our proof was known to the descriptive set the-
ory community before. In particular Yurii Khomskii presented an essentially the
same proof (in terms of ﬂip sets) in his Intensive course on Inﬁnite Games at Soﬁa
University [7]; the origins of the idea can be traced back further, but are hard to
ﬁx at this moment [8]. The idea is so natural that could likely be found by more
people independently, although we are not aware of any published source except
for the Internet publications mentioned above.
In any case, we do not claim priority here, but hope the example can be useful,
in particular in teaching computer science students. Indeed, it uses only a tiny
portion of abstract mathematics, and relies on the XOR function well familiar to
programmers. And we would like to present it to the volume dedicated to Victor
Selivanov, as it touches one of his favorite topics — teaching of logic.
2 Inﬁnite XOR game
Let B = {0, 1}. For two words v, w ∈Bm, where m ≤ω, let hd(v, w) = |{i : vi ̸=
wi}| be the Hamming distance between v and w. For v, w ∈Bω, we let v ∼w iﬀ
hd(v, w) < ω.

208
|
Eryk Kopczyński and Damian Niwiński
Deﬁnition 1. An inﬁnite XOR function f : Bω →B is a function with the follow-
ing property: if hd(w1, w2) = 1 then f(w1) ̸= f(w2).
Theorem 2. There exists an inﬁnite XOR function.
Proof. We use the Axiom of Choice. Let S be a set which contains exactly one ele-
ment from each equivalence class of ∼. For w ∈Bω, let r(w) be the element of S
such that w ∼r(w). We deﬁne f(w) = hd(w, r(w)) mod 2. One easily checks that
f is an inﬁnite XOR function.
Remark
In fact, there are 2c inﬁnite XOR functions, where c is the cardinality of the set of
real numbers. For, observe ﬁrst that, for S as above, |S| = c, as each equivalence
class of ∼is countable. Then, for each α : S →{0, 1}, we obtain a diﬀerent inﬁnite
XOR function given by fα(w) = (f(w) + α(r(w))) mod 2.
Deﬁnition 3. Let f be an inﬁnite XOR function. The inﬁnite XOR game Gf is
played as follows. Player 0 picks a word w0 ∈B+. Then, Player 1 picks a word
w1 ∈B+. Player 0 picks a word w2 ∈B+, Player 1 picks a word w3 ∈B+, and so on.
Thus, we obtain a play which is an inﬁnite sequence of words: w0w1, w2, w3, . . .
Player i wins iﬀf(w0w1w2w3 . . .) = i.
Deﬁnition 4. A strategy for player i in Gf is a function
S :

k∈ω
(B+)2k+i →B+.
A play w0, w1, w2, . . . is consistent with S iﬀwk+1 = S(w0, w1, . . . , wk), for each
suitable k (i.e., each move of player i is given by S). S is winning iﬀPlayer i wins
each play consistent with S.
Note that in the above we view (B+)m as a product B+ × B+ × . . . × B+ (m
times) rather than concatenation B+B+ . . . B+ (m times). Such an identiﬁcation
would restrict the set of strategies, but in fact it would not aﬀect our result. Note
that, by deﬁnition, (B+)0 = {∅}.
We use the strategy stealing argument to show that no player has a winning
strategy in the inﬁnite XOR game. Intuitively, whenever our opponent answers our
move v with w, we could have instead changed one bit in v to obtain another word
v′, and play v′w instead of v. This eﬀectively exchanges the roles of the two players,
so if our opponent had a winning strategy, we can use it now for ourselves. The
precise argument follows.

A Simple Indeterminate Inﬁnite Game
|
209
Theorem 5. No player has a winning strategy in an inﬁnite XOR game Gf.
Proof. Let S be a strategy for Player 1 −i. We construct two strategies for Player i,
T and T′, such that one of them will win at least one play against S.
Consider ﬁrst i = 0, and let the ﬁrst move of Player 0 (who starts the game)
be T(∅) = 0. Suppose the answer of Player 1 is S(0) = w1. We let T′(∅) = 1w1.
Now, if S(1w1) = w2 then we let T(0, w1) = w2, and if S(0, w1, w2) = w3, we let
T′(1w1, w2) = w3, and so on. In symbols, we let
T′(1w1, w2, . . . , w2k)
=
S(0, w1, . . . , w2k)
T(0, w1, . . . , w2k+1)
=
S(1w1, w2, . . . , w2k+1).
In the ﬁgure below, the dashed arrows indicate the “stealing”.
Player 0
0
w2
w4
Strategy T
Player 1
w1



w3




w5




Player 0
1w1
w3
w5
Strategy T′
Player 1
w2













w4













Note that in the two plays above Player 1 uses his strategy S, but the resulting
sequences diﬀer exactly in one bit (actually the bit number 0), hence one of the
plays is lost by Player 1.
The argument for i = 1 is similar. Let the starting move of Player 0 be S(∅) =
w0. We let T(w0) = 0. Now suppose S(w0, 0) = w1. We let T′(w0) = 1w1. If
S(w0, 1w1) = w2, we let T(w0, 0, w1) = w2, and so on, as represented on the
ﬁgure below.

210
|
Eryk Kopczyński and Damian Niwiński
Player 0
w0
w1














w3














w5


 













Strategy T
Player 1
0
w2
w4
Player 0
w0
w2




w4




Strategy T′
Player 1
1w1
w3
w5
Analogically as above, Player 0 uses her strategy S, but the resulting sequences
diﬀer exactly in one bit (namely the bit number |w0|), hence this strategy cannot
be winning.
Hence the game Gf is indeed indeterminate.
Acknowledgement: Wethank Jacques Duparc, YuriiKhomskii,andHenrykMicha-
lewski, as well as the anonymous referees, for many insightful comments.
Bibliography
[1]
Andretta, A. Notes on Descriptive Set Theory. June, 2001.
[2]
Duparc, J., Games and Their Application in Computer Science, Unpublished lecture notes,
RWTH Aachen, 2002, http://www-mgi.informatik.rwth-aachen.de/Teaching/Games-
SS02/index.html
[3]
Gale, D., and Stewart, F.M., Inﬁnite games with perfect information., Annals of Mathemat-
ics 28 (1953), 245–266.
[4]
Grädel, E., Positional Determinacy of Inﬁnite Games, In STACS 2004, 4–18.
[5]
Gurevich, Y., The Logic in Computer Science Column., Bulletin of the EATCS 38, June 1989,
93–100.
[6]
Kechris, A.S., Classical descriptive set theory. Springer-Verlag, New York, 1995.
[7]
Khomskii, Y., Intensive course on Inﬁnite Games (lecture notes), Soﬁa University, 12-19
June 2010, http://www.logic.univie.ac.at/~ykhomski/inﬁnitegames2010/index.html
[8]
Khomskii, Y., Private communication, August 2012.
[9]
Moschovakis, Y. N., Descriptive Set Theory, North Holland, 1980.
[10] Mycielski, J., Games with Perfect Information, In R.J. Aumann, S. Hart, editors, Handbook
of Game Theory, volume 1, North-Holland, 1992, 41–70.

A Simple Indeterminate Inﬁnite Game
|
211
[11] Niwiński, D., Symmetry and duality in ﬁxed-point calculus (slides)., Square of Opposition,
Corté, Corsica, June 17–20, 2010. http://www.square-of-opposition.org/start2.html
[12] Sipser, M., On polynomial vs. exponential growth, Unpublished manuscript, Mathematics
Department MIT, 1981.
[13] Telgarsky, R., Topological games: On the 50th anniversary of Banach-Mazur games, Rocky
Mountain Journal of Mathematics 17, 1987, 227–276.
[14] Zermelo, E., Über eine Anwendung der Mengenlehre auf die Theorie des Schachspiels,
Proceedings of the Fifth Congress of Mathematicians, Cambridge 1912, 501–504.


Luca Motto Ros, Philipp Schlicht
Lipschitz and Uniformly Continuous
Reducibilities on Ultrametric Polish Spaces¹
Abstract: We analyze the reducibilities induced by, respectively, uniformly con-
tinuous, Lipschitz, and nonexpansive functions on arbitrary ultrametric Polish
spaces, and determine whether under suitable set-theoretical assumptions the in-
duced degree-structures are well-behaved.
Keywords: Wadge reducibility, continuous reducibility, Lipschitz reducibility, uni-
formly continuous reducibility, ultrametric Polish space, nonexpansive function,
Lipschitz function, uniformly continuous function
Mathematics Subject Classiﬁcation 2010: 03E15, 03E60, 54C10, 54E40
||
Luca Motto Ros: Mathematisches Institut, Albert-Ludwigs-Universität Freiburg, Germany
Philipp Schlicht: Mathematisches Institut, Rheinische Friedrich-Wilhelms-Universität Bonn,
Germany
1 Introduction
Throughout the paper, we work in the usual Zermelo-Frænkel set theory ZF, plus
the Axiom of Dependent Choices over the reals DC(R). Let X be a Polish space,
and let F be a reducibility (on X), that is a collection of functions from X to itself
closed under composition and containing the identity id = idX. Given A, B ⊆X,
we say that A is reducible to B if and only if
A = f −1(B) for some f : X →X,
and that A is F-reducible to B (A ≤F B in symbols) if A is reducible to B via a
function in F. Notice that clearly A ≤F B
⇐⇒
¬A ≤F ¬B (where, to simplify
the notation, we set ¬A = X \ A whenever the underlying space X is clear from
the context). Since F is a reducibility on X, the relation ≤F is a preorder which
can be used to measure the “complexity” of subsets of X: in fact, if F consists of
reasonably simple functions, the assertion “A ≤F B” may be understood as “the
1 The authors would like to congratulate Professor Victor Selivanov on the occasion of his sixtieth
birthday for his wide and important contributions to mathematical logic and, in particular, to the
theory of Wadge-like reducibilities and its connections with theoretical computer science.

214
|
Luca Motto Ros and Philipp Schlicht
set A is not more complicated than the set B” — to test whether a given x ∈X
belongs to A or not, it is enough to pick a witness f ∈F of A ≤F B, and then
check whether f(x) ∈B or not. This suggests that the reducibility F may be used
to form a hierarchy of subsets of X in the following way. Say that A, B ⊆X are
F-equivalent (A ≡F B in symbols) if A ≤F B ≤F A. Since ≡F is the equivalence
relation canonically induced by ≤F, we can consider the F-degree [A]F = {B ⊆
X | A ≡F B} of a given A ⊆X, and then order the collection Deg(F) = {[A]F | A ⊆
X} of such F-degrees using the quotient of ≤F, namely setting [A]F ≤[B]F ⇐⇒
A ≤F B for every A, B ⊆X. The resulting structure Deg(F) = (Deg(F), ≤) is
then called F-hierarchy on X. When considering the restriction DegΓ(F) of such
structure to the F-degrees of sets in a given Γ ⊆P(X), we speak of F-hierarchy
on Γ-subsets of X.
In his Ph.D. thesis [24], Wadge considered the case when X is the Baire space
ωω (i.e. the space of all ω-sequences of natural numbers endowed with the prod-
uct of the discrete topology on ω) and F is either the set W = W(X) of all con-
tinuous functions, or the set L(¯d) of all functions which are nonexpansive with
respect to the usual metric ¯d on ωω (see Section 2 for the deﬁnition). Using game-
theoretical methods, he was able to show that in both cases the F-hierarchy on
Borel subsets of X = ωω is semi-well-ordered, that is:
(1) it is semi-linearly ordered, i.e. either A ≤F B or ¬B ≤F A for all Borel A, B ⊆X;
(2) it is well-founded.
Notice that the Semi-Linear Ordering principle for F (brieﬂy: SLOF) deﬁned in
(1) implies that antichains have size at most 2, and that they are of the form
{[A]F, [¬A]F} for some A ⊆X such that A ≰F ¬A (sets with this last property
are called F-nonselfdual, while the other ones are called F-selfdual: since F-
selfduality is ≡F-invariant, a similar terminology will be applied to the F-degree
of A as well). This in particular means that if we further identify each F-degree
[A]F with its dual [¬A]F we get a linear ordering, which is also well-founded when
(2) holds.
A semi-well-ordered hierarchy is practically optimal as a measure of complex-
ity for (Borel subsets of) X: by well-foundness, we can associate to each A ⊆X
an ordinal rank (the F-rank of A), and antichains are of minimal size.² In fact,
2 Asking for no antichain at all seems unreasonable by the following considerations: let A be
e.g. a proper open subset of a given Polish space X. On the one hand, checking membership in A
cannot be considered strictly simpler or strictly more diﬃcult than checking membership in its
complement: this means that the degrees of A and ¬A cannot be one strictly below the other in the

Lipschitz and Uniformly Continuous Reducibilities
|
215
in [16; 15] it is proposed to classify arbitrary F-hierarchies on corresponding topo-
logical spaces X according to whether they provide a good measure of complexity
for subsets of X. This led to the following deﬁnition.
Deﬁnition 1. Let F be a reducibility on a (topological) space X, and let Γ ⊆P(X).
The F-hierarchy DegΓ(F) on Γ-subsets of X is called:
–
very good if it is semi-well-ordered;
–
good if it is a well-quasi-order, i.e. all its antichains and descending chains
are ﬁnite;
–
bad if it contains inﬁnite antichains;
–
very bad if it contains both inﬁnite antichains and inﬁnite descending chains.
Since the pioneering work of Wadge, many other F-hierarchies on the Baire space
ωω (or, more generally, on zero-dimensional Polish space) have been considered
in the literature [23; 1; 2; 11; 13; 14], including Borel functions, ∆0
α-functions,³ Lips-
chitz functions, uniformly continuous functions, functions of Baire class < α for a
given additively closed countable ordinal α, Σ1
n-measurable functions, and so on.
It turned out that all of them are very good when restricted to Borel sets, or even to
larger collections of subsets of ωω if suitable determinacy principles are assumed.
In contrast, it is shown in [6; 7; 9; 18; 16] that when considering the continuous
reducibility on the real line R or, more generally, on arbitrary Polish spaces with
nonzero dimension, then one usually gets a (very) bad hierarchy (and the same ap-
plies to some other classical kind of reducibilities, depending on the space under
consideration).⁴
Given all these results, one may be tempted to conjecture that all “natural”
F-hierarchies on (Borel subsets of) a zero-dimensional Polish space X need to be
very good. This conjecture is justiﬁed by the fact that every such space is homeo-
morphic to a closed subset (hence to a topological retract) of the Baire space, and
hierarchy. On the other hand, the fact that open sets and closed sets have in general diﬀerent (often
complementary) combinatorial and topological properties, strongly suggests that the degrees of A
and ¬A should be kept distinct. Therefore such degrees must form an antichain of size 2.
3 Given a countable ordinal α ≥1 and a Polish space X, a function f : X →X is called ∆0
α-function
if f −1(A) ∈Σ0
α for every A ∈Σ0
α.
4 Of course, one can further extend the class of topological spaces under consideration, and
analyze e.g. the continuous reducibility on them: for example, [19] considers the case of ω-algebraic
domains (a class of spaces relevant in theoretical computer science), while [16] consider the
broader class of the so-called quasi-Polish spaces. Moreover, it is possible to generalize the notion
of reducibility itself by considering e.g. reducibilities between ﬁnite partitions (see e.g. [22; 6; 19;
20; 21] and the references contained therein).

216
|
Luca Motto Ros and Philipp Schlicht
a well-known transfer argument (see e.g. [16, Proposition 5.4]) shows that this al-
ready implies the following folklore result.
Proposition 2. Let X be a zero-dimensional Polish space, and let F be an arbitrary
reducibility on X which contains W(X), i.e. all continuous functions from X to itself.
Then the F-hierarchy Deg∆1
1(F) on Borel subsets of X is very good.
In fact, [11, Theorem 3.1] (essentially) shows that this result can be further strength-
ened when X itself is a closed subset of ωω: if X is equipped with the restriction ¯dX
of the canonical metric ¯d on ωω, then Deg∆1
1(F) is very good as soon as F contains
the collection L(¯dX) of all ¯dX-nonexpansive functions.
Despite the above mentioned results, in [15, Theorem 5.4, Proposition 5.10,
and Theorem 5.11] it is shown that there are various natural reducibilities on ωω
that actually induce (very) bad hierarchies on its Borel subsets. In particular,
it is shown that ωω can be equipped with a complete ultrametric d′, still com-
patible with its usual product topology, such that the F-hierarchy on Borel (in
fact, even just clopen) subsets of ωω is very bad for F the collection of all the
d′-nonexpansive (alternatively: d′-Lipschitz) functions.
Motivated by these results, in the present paper we continue this investigation
by considering various complete ultrametrics on ωω (compatible with its product
topology) and, more generally, the collection of all ultrametric Polish spaces X =
(X, d), a very natural and interesting class which includes e.g. the space Qp of
p-adic numbers (for every prime p ∈N).⁵ On such spaces, we then consider the
hierarchies of degrees induced by one of the following reducibilities⁶ on X:
–
the collection L(d) of all nonexpansive functions, where f : X →X is called
nonexpansive if d(f(x), f(y)) ≤d(x, y) for all x, y ∈X;
–
the collection Lip(d) of all Lipschitz functions (with arbitrary constants),
where f : X →X is a Lipschitz function with constant L (for a nonnegative real
L) if d(f(x), f(y)) ≤L · d(x, y) for all x, y ∈X;
–
the collection UCont(d) of all uniformly continuous functions, where f : X →
X is uniformly continuous if for every ε ∈R+ there is a δ ∈R+ such that
d(x, y) < δ ⇒d(f(x), f(y)) < ε for all x, y ∈X (here R+ denotes the set of
strictly positive reals).
5 More generally, the completion of any countable valued ﬁeld K with valuation | · |K : K →R
and metric d(x, y) = |x −y|K (for x, y ∈K) is always an ultrametric Polish space.
6 Notice that since the metric topology on X is always zero-dimensional, it does not make much
sense to consider reducibilities F ⊇W(X), because by Proposition 2 they always induce a very
good hierarchy on Borel subsets of X.

Lipschitz and Uniformly Continuous Reducibilities
|
217
The main results of the paper are the following:
(A) The UCont(d)-hierarchy on Borel subsets of X is always very good (Theo-
rem 16). Since by Proposition 10 it is possible to equip the Baire space with a
compatible complete ultrametric d′ such that L(¯d) ̸⊆UCont(d′) (where ¯d is
the usual metric on ωω), this also implies that L(¯d) ⊆F is a suﬃcient but not
necessary condition for the F-hierarchy on Borel subsets of ωω being very
good (for F a reducibility on ωω).
(B) If X is perfect, then the Lip(d)-hierarchy on the Borel subsets of X is either
very good (if X has bounded diameter), or else it is very bad already when
restricted to clopen subsets of X (if the diameter of X is unbounded). A techni-
cal strengthening of the property of having (un)bounded diameter (see Deﬁni-
tion 17) works similarly for arbitrary ultrametric Polish spaces (Theorems 20
and 26, Corollary 29).
(C) If the range of d contains an honest increasing sequence (see Deﬁnition 31),
then the L(d)-hierarchy on clopen subsets of X is very bad (Theorem 32); in
particular, this happens in the special case when X is perfect and has un-
bounded diameter. If instead the range of d is either ﬁnite or a decreasing
ω-sequence converging to 0, then the L(d)-hierarchy on Borel subsets of X is
always very good (Theorem 37).
(D) It follows from the second part of (C) that if X is compact, then both⁷ the Lip(d)-
and the L(d)-hierarchy on Borel subsets of X are very good (Theorem 47).
(E) If we assume the Axiom of Choice AC, then the F-hierarchy on (arbitrary sub-
sets of) an uncountable X is very bad for every reducibility F such that L(d) ⊆
F ⊆Bor(X), where Bor(X) is the collection of all Borel functions from X into
itself (Theorem 56). If we further assume that V = L, then the F-hierarchy on
X is very bad already when restricted to Π1
1, i.e. coanalytic,⁸ subsets of X (The-
orem 63).
In particular, the results in (A)–(D) generalize those from [15, Section 5] and an-
swer most of the questions in [15, Section 6]. Moreover, they allow us to construct
discrete ultrametric Polish spaces X = (X, d) whose Lip(d)- and L(d)-hierarchies
are very bad (Corollaries 25 and 33), a fact which contradicts the conceivable con-
jecture that the Lip(d)- and the L(d)-hierarchy on them need to be (very) good
since all subsets of such spaces are extremely simple (i.e. clopen). Notice also
7 Since on compact metric spaces continuity and uniform continuity coincide, the UCont(d)-
hierarchy on Borel subsets of a compact X is very good already by Proposition 2.
8 Equivalently, to Σ1
1 (i.e. analytic) subsets of X.

218
|
Luca Motto Ros and Philipp Schlicht
that the result mentioned in (E) under the assumption V = L (which is best pos-
sible for most reducibilities F by Proposition 2 and the comment following it) can
be viewed as an extension of the well-know classical result that if Π1
1-determinacy
fails then there are proper Π1
1 sets which are not (Borel-)complete for coanalytic
sets.
We end this introduction with two general remarks concerning the results pre-
sented in this paper:
i) to simplify the presentation, we will consider only F-hierarchies on Borel sub-
sets of a given ultrametric Polish space X (except in Section 6): this is be-
cause in this way we can avoid to assume any axiom beyond our basic the-
ory ZF + DC(R). However, as usual in Wadge theory, all our results can be
extended to larger pointclasses Γ ⊆P(X) by assuming corresponding deter-
minacy axioms (more precisely: the determinacy of subsets of ωω which are
Boolean combinations of sets in Γ). In particular, under the full Axiom of De-
terminacy AD (asserting that all games on ω are determined), all these results
remain true when considering unrestricted F-hierarchies Deg(F) on X;
ii) when showing that a given F-hierarchy on X (possibly restricted to some Γ ⊆
P(X)) is very bad, we will actually show that some very complicated partial
(quasi-)order on P(ω), like the inclusion relation ⊆, or even the more com-
plicated relation ⊆∗of inclusion modulo ﬁnite sets, embeds into such a hier-
archy. This gives much stronger results, as it implies e.g. that the F-hierarchy
under consideration contains antichains of size the continuum and, in the
case of ⊆∗, that (under AC) every partial order of size ℵ1 embeds into the F-
hierarchy on (Γ-subsets of) X (see [17]).
2 Basic facts about ultrametric Polish spaces
Given a metric space X = (X, d), we denote by τd the metric topology (induced
by d), i.e. the topology generated by the basic open balls Bd(x, ε) = {y ∈X |
d(x, y) < ε} (for some x ∈X and ε ∈R+). When considered as a topological
space, the space X is tacitly endowed with such topology, and therefore we will
e.g. say that the metric space X is separable if there is a countable τd-dense subset
of X, and similarly for all other topological notions. The diameter of X is bounded if
there is R ∈R+ such that sup{d(x, y) | x, y ∈X} ≤R, and unbounded otherwise.
A metric d on a space X is called ultrametric if it satisﬁes the following
strengthening of the triangle inequality, for all x, y, z ∈X:
d(x, z) ≤max{d(x, y), d(y, z)}.

Lipschitz and Uniformly Continuous Reducibilities
|
219
Deﬁnition 3. An ultrametric Polish space is a separable metric space X = (X, d)
such that d is a complete ultrametric. The collection of all ultrametric Polish
spaces will be denoted by X .
Every (τd-)closed subspace C of an ultrametric Polish space X = (X, d) will be
tacitly equipped with the metric dC = d ↾C, which is obviously a complete ultra-
metric compatible with the relative topology on C induced by τd. When there is
no danger of confusion, with a little abuse of notation the metric dC will be some-
times denoted by d again.
Notation 4. Given an ultrametric Polish space X = (X, d), we set R(d) = {d(x, y) |
x, y ∈X, x ̸= y}, the set of all nonzero distances realized in X.
A typical example of an ultrametric Polish space is obtained by equipping the
Baire space with the usual metric ¯d deﬁned by
¯d(x, y) =

0
if x = y
2−n
if n is smallest such that x(n) ̸= y(n) :
it is straightforward to check that ¯d is actually an ultrametric generating the prod-
uct topology on ωω, and obviously R(¯d) = {2−n | n ∈ω}. We will keep denoting
this ultrametric by ¯d throughout the paper.
We collect here some easy but useful facts about arbitrary ultrametric (Polish)
spaces X = (X, d):
(1) for every x, y, z ∈X two of the distances d(x, y), d(x, z), d(y, z) are equal, and
they are greater than or equal to the third (the “isosceles triangle” rule);
(2) for every x, y, z ∈X, if d(x, z) ̸= d(y, z) then d(x, y) = max{d(x, z), d(y, z)}.
In particular, if x, y, z, w ∈X are such that d(x, z), d(y, w) < d(x, y) then
d(z, w) = d(x, y);
(3) given a (τd-)dense set Q ⊆X, all distances are realized by elements of Q, that
is: for every x, y ∈X there are q, p ∈Q such that d(x, y) = d(q, p). In partic-
ular, if X is separable then R(d) is countable;⁹
(4) for every x ∈X and r ∈R+ the open ball Bd(x, r) is actually clopen, and
Bd(y, r) = Bd(x, r) for every y ∈Bd(x, r). In particular, the topology τd is
always zero-dimensional, and hence if X is an ultrametric Polish space, then
9 Vice versa, for every countable R ⊆R+ there is an ultrametric Polish space X = (X, d) such
that R(d) = R, for example X = R ∪{0} with d(x, y) = max{x, y} for distinct x, y ∈X.

220
|
Luca Motto Ros and Philipp Schlicht
it is homeomorphic to a closed subset of the Baire space by [10, Theorem 7.8]
(see also Lemma 11);
(5) given x, y ∈X and r, s ∈R+, the (cl)open balls Bd(x, r) and Bd(y, s) are either
disjoint, or else one of them contains the other.
To simplify the terminology, we adapt the deﬁnition of family of reducibilities
introduced in [16, Deﬁnition 5.1] to the restricted context of ultrametric Polish
spaces.
Deﬁnition 5. Let F be a collection of functions between any ultrametric Polish
spaces. For X, Y ∈X , denote by F(X, Y) the collection of all functions from F
with domain X and range included in Y. The collection F is called family of re-
ducibilities (on X ) if:
1. it contains all the identity functions, i.e. idX ∈F(X, X) for every X ∈X ;
2. it is closed under composition, i.e. for every X, Y, Z ∈X , f ∈F(X, Y), and
g ∈F(Y, Z), the function g ◦f belongs to F(X, Z);
Examples of family of reducibilities are the collections of all continuous func-
tions, of all uniformly continuous functions, of all Lipschitz functions, and of
all nonexpansive functions. Notice also that if F is a family of reducibilities then
F(X) = F(X, X) is a reducibility on the space X (for every X ∈X ). The next simple
lemma is a minor variation of [16, Proposition 5.4] and can be proved in a similar
way.
Lemma 6. Let F be a family of reducibilities and X, Y ∈X . Suppose that there
is a surjective f ∈F(X, Y) admitting a right inverse g ∈F(Y, X). Then there is an
embedding from (P(Y), ≤F(Y), ¬) into (P(X), ≤F(X), ¬).
In particular, if F consists of Borel functions and the F(X)-hierarchy on Borel
subsets of X is (very) good, then also the F(Y)-hierarchy on Borel subsets of Y is
(very) good.
Proof. The map P(Y) →P(X): A →f −1(A) is the desired embedding.
3 Uniformly continuous and Lipschitz
reducibilities
In [15, Question 6.2], it is asked whether one can equip the Baire space ωω with
a compatible complete ultrametric d′ so that L(¯d) ̸⊆UCont(d′), and whether it is

Lipschitz and Uniformly Continuous Reducibilities
|
221
possible to strengthen this last condition to: the UCont(d′)-hierarchy on X is (very)
bad. We start by answering positively the ﬁrst part of this question.
Notation 7. Given a function ϕ: ω →R+, we denote by rg(ϕ) the range of ϕ, i.e.
rg(ϕ) = {r ∈R+ | ∃n ∈ω (ϕ(n) = r)}.
Deﬁnition 8. Given a function ϕ: ω →R+ with inf rg(ϕ) > 0, deﬁne the metric
dϕ on ωω by setting for every x, y ∈ωω
dϕ(x, y) = max{ϕ(x(0)), ϕ(y(0))} · ¯d(x, y).
It is not hard to check that each dϕ is a complete ultrametric compatible with the
product topology on ωω (and that inf rg(ϕ) > 0 is necessary for completeness).
Notation 9. Given a natural number i ∈ω and an ordinal α, we denote by i(α) the
constant α-sequence with value i.
Proposition 10. Let ϕ: ω →R+ : n →2n. Then L(¯d) ̸⊆UCont(dϕ).
Proof. Consider the map f : ωω →ωω: n⌢x →3n⌢x. We show that for every
ε, δ ∈R+ there are x, y ∈ωω such that dϕ(x, y) < δ but dϕ(f(x), f(y)) > ε.
Let 0 ̸= k ∈ω be such that 2−k < δ. Then for every n ≥k we get that setting
x = n(2n)⌢0(ω) and y = n(2n)⌢1(ω),
dϕ(x, y) = 2n · 2−2n = 2−n ≤2−k < δ.
However,
dϕ(f(x), f(y)) = 23n · 2−2n = 2n,
hence letting n be large enough we get dϕ(f(x), f(y)) > ε, as desired.
In order to answer the second half of [15, Question 6.2], we abstractly analyze the
behavior of the UCont(d)-hierarchy on an arbitrary ultrametric Polish space X =
(X, d). The following lemma uses standard arguments (see e.g. the proof of [10,
Theorem 7.8]), but we fully reprove it here for the reader’s convenience.
Lemma 11. Let X = (X, d) be an ultrametric Polish space. Then there is a closed set
C ⊆ωω and a bijection f : (C, ¯d) →(X, d) such that f is uniformly continuous and
f −1 is nonexpansive. Moreover, if X has bounded diameter, then f is even Lipschitz,
and if X has diameter ≤1 then we can alternatively require f to be nonexpansive
and f −1 to be Lipschitz with constant 2.
Proof. Let Q be a countable dense subset of X. Deﬁne the sets As ⊆X for s ∈
<ωω recursively on lh(s) as follows: A∅= X. Given As ⊆X, let {Bs,i | i < I}

222
|
Luca Motto Ros and Philipp Schlicht
(for some I ≤ω) be an enumeration without repetitions of the set of open balls
{Bd(x, 2−lh(s)) | x ∈Q ∩As}, and set As⌢i = Bs,i if i < I and As⌢i = ∅otherwise.
Since d is an ultrametric, one can easily check that the family (As)s∈<ωω is a Luzin
scheme with vanishing diameter consisting of clopen sets, and with the further
property that As = 
n∈ω As⌢n for every s ∈<ωω. Therefore the set C = {x ∈ωω |

n∈ω Ax↾n ̸= ∅} is a closed subset of ωω, and the map f : C →X sending x ∈C
to the unique element in 
n∈ω Ax↾n is a bijection. So it remains only to check that
such f has the desired properties.
Given ε > 0, let n ∈ω be smallest such that 2−n ≤ε, and set δ = 2−n. If x, y ∈
C are such that ¯d(x, y) < δ, then x ↾(n+1) = y ↾(n+1), which implies f(x), f(y) ∈
Ax↾(n+1). By deﬁnition of the As, this implies that d(f(x), f(y)) < 2−n ≤ε. This
shows that f is uniformly continuous.
Further assuming that X be of bounded diameter, we get that f is Lipschitz
with constant max{2, k}, where k ∈ω is an arbitrary bound to the diameter of X,
i.e. it is such that d(x, y) ≤k for every x, y ∈X. To see this, ﬁx distinct x, y ∈C. If
x(0) ̸= y(0) then d(f(x), f(y)) ≤k ≤k · ¯d(x, y) by our choice of k ∈ω. Let now
n ̸= 0 be smallest such that x(n) ̸= y(n), so that ¯d(x, y) = 2−n. Since x ↾n = y ↾n
we get that f(x), f(y) ∈Ax↾n, which implies d(f(x), f(y)) < 2−(n−1): therefore
d(f(x), f(y)) < 2 · 2−n = 2 · d(x, y).
Now ﬁx x, y ∈C, and let n ∈ω be such that ¯d(x, y) = 2−n. Since x(n) ̸=
y(n) implies Ax↾(n+1) ∩Ay↾(n+1) = ∅, we get that d(f(x), f(y)) ≥2−n (because
d is an ultrametric), and hence ¯d(x, y) ≤d(f(x), f(y)). This shows that f −1 is
nonexpansive.
Finally, assume that X has diameter ≤1. In the construction above, redeﬁne
the collections {Bs,i | i < I} as enumerations without repetitions of the sets
{Bd(x, 2−(lh(s)+1)) | x ∈Q ∩As} ,
and then use this new sets to deﬁne the As’s and the map f. Arguing as before, one
can easily check that f is now nonexpansive while f −1 is Lipschitz with constant
2, as required.
Remark 12. The special case of Lemma 11 where X has diameter ≤1 already ap-
peared (with the same proof) in [12, Theorem 4.1]. However, such a result cannot be
literally extended to an arbitrary ultrametric Polish space X, and in fact the assump-
tions in Lemma 11 are optimal. To see this, note that if X has unbounded diameter
then we cannot require a map f as in Lemma 11 to be Lipschitz because every Lips-
chitz image of a space with bounded diameter (like any set C ⊆ωω) has necessarily
bounded diameter too. Similarly, a nonexpansive image of a set of diameter ≤R (for
some R ∈R+), has diameter ≤R too.

Lipschitz and Uniformly Continuous Reducibilities
|
223
Deﬁnition 13. Let X be a topological space, F be a collection of functions from X
to itself, and A ⊆X. We call F-retraction of X onto A any surjection f ∈F from
X onto A such that f ↾A = idA; if such a function exists we also say that A is an
F-retract of X.
Recall from [10, Proposition 2.8] that if ∅̸= A ⊆C are closed subsets of the Baire
space, then there is an L(¯dC)-retraction (i.e. a nonexpansive retraction) of C onto A
— a fact that will be repeatedly used throughout the paper. The next corollary gen-
eralizes this result to arbitrary ultrametric Polish spaces, provided that we slightly
weaken the requirement that the retraction be nonexpansive.
Corollary 14. Let X = (X, d) be an ultrametric Polish space. For every nonempty
closed A ⊆X, there is a uniformly continuous retraction r: X ↠A. If moreover A
has bounded diameter, then the retraction r can be taken to be Lipschitz.
Proof. Let C and f be as in Lemma 11, with f uniformly continuous and f −1 non-
expansive. Notice that since f is, in particular, a homeomorphism, the set A′ =
f −1(A) is a nonempty closed subset of C. Let g: C →A′ be a nonexpansive retrac-
tion: then r = f ◦g ◦f −1 : (X, d) ↠(A, d) is the desired uniformly continuous
retraction.
Assume now that A has bounded diameter, and let C, f, and g be as in the
previous paragraph. Arguing as in the proof of Lemma 11, one can easily check
that f ↾A′ : (A′, ¯d) →(X, d) is actually Lipschitz (since A has bounded diameter):
therefore r = (f ↾A′) ◦g ◦f −1 : (X, d) ↠(A, d) is the desired Lipschitz retraction.
Remark 15. It is not possible in general to strengthen Corollary 14 by requiring the
reduction to be nonexpansive, even if we require the entire X to have small diameter.
To see this, let X = {0}∪

1
2 + 2−(n+1) | n ∈ω

, and set d(x, y) = max{x, y} for all
distinct x, y ∈X. Then X = (X, d) is a discrete ultrametric Polish space of diameter
≤1. Consider the clopen set A = X \ {0}, and let f : X ↠A be a retraction. Let
n ∈ω be such that f(0) = 1
2 + 2−(n+1): then setting x = 0 and y = 1
2 + 2−(n+2) we
get that
d(f(x), f(y)) = d(f(x), y) = 1
2 + 2−(n+1) > 1
2 + 2−(n+2) = d(x, y),
so f is expansive.
Theorem 16. The UCont(d)-hierarchy Deg∆1
1(UCont(d)) on the Borel subsets of an
arbitrary ultrametric Polish space X = (X, d) is always very good. If X has bounded

224
|
Luca Motto Ros and Philipp Schlicht
diameter, then the Lip(d)-hierarchy Deg∆1
1(Lip(d)) on the Borel subsets of X is very
good as well.
Proof. Let C ⊆ωω and f : C →X be as in Lemma 11, and let g: (ωω, ¯d) →(C, ¯d)
be a nonexpansive retraction. Then f −1 is a right inverse of g ◦f, and hence the
result follows from Lemma 6 and the fact that both the UCont(¯d)-hierarchy and
the Lip(¯d)-hierarchy are very good by [13].
In particular, this fully answers in the negative the second half of [15, Question
6.2]. Moreover, Theorem 16 provides also a negative answer to [15, Question 6.1]:
letting ϕ be as in Proposition 10, we get that the set UCont(dϕ) of uniformly con-
tinuous functions is a surjective image of ωω,¹⁰ it does not contain L(¯d), but it
induces a very good hierarchy on the Borel subsets (or, further assuming AD, on
the collection of all subsets) of ωω.
Theorem 16 shows that having a bounded diameter is a suﬃcient condition
for having that the Lip(d)-hierarchy on the Borel subsets of an ultrametric Polish
space X = (X, d) is very good. In fact, we are now going to show that a technical
strengthening of this condition is both necessary and suﬃcient for that.
Deﬁnition 17. Let X = (X, d) be an (ultra)metric Polish space. We say that the
diameter of X is nontrivially unbounded if for every k ∈ω and every ε ∈R+ there
are x, y ∈X with d(x, y) > k such that both x and y are not ε-isolated.¹¹
Notice that if X is perfect, then the diameter of X is nontrivially unbounded if and
only if it is unbounded.
Example 18. Let p be a prime natural number, and let Qp be the ultrametric Polish
space of p-adic numbers equipped with the usual p-adic metric dp: then Qp has
unbounded diameter and is perfect (hence its diameter is nontrivially unbounded).
To see the former, given k ∈ω let n ∈ω be such that n ≥2 and k < pn: setting
x = p−1 and y = p−n we easily get dp(x, y) = pn > k. To see that Qp is also
perfect, ﬁx an arbitrary q ∈Q, and given ε ∈R+ let l ∈ω be such that p−l < ε:
then q′ = q −pl is distinct from q and dp(q, q′) = p−l < ε. This shows that q is not
isolated, and since Q is dense in Qp we are done.
10 When working in models of AD (as it is often the case when dealing with Wadge-like hierarchies),
for technical reasons it is often preferable to express “cardinality inequality” using surjections
instead of injections. Therefore the stated property should be intended (in any model of ZF) as: the
cardinality of UCont(dϕ) is not larger than that of the Baire space. Obviously, further assuming
the Axiom of Choice AC this just means that UCont(dϕ) has cardinality ≤2ℵ0.
11 Recall that a point x of a metric space is called ε-isolated (for some ε ∈R+) if Bd(x, ε) = {x}.

Lipschitz and Uniformly Continuous Reducibilities
|
225
Notation 19. We let ⊆∗denote the relation of inclusion modulo ﬁnite sets between
subsets of ω, i.e. for every a, b ⊆ω we set
a ⊆∗b ⇐⇒∃¯k ∈ω ∀k ≥¯k (k ∈a ⇒k ∈b).
Theorem 20. Let X = (X, d) be an ultrametric Polish space, and assume that its di-
ameter is nontrivially unbounded. Then there is a map ψ from P(ω) into the clopen
subsets of X such that for all a, b ⊆ω:
1. if a ⊆∗b then ψ(a) ≤L(d) ψ(b);
2. if ψ(a) ≤Lip(d) ψ(b) then a ⊆∗b.
In particular, (P(ω), ⊆∗) embeds into both Deg∆0
1(Lip(d)) and Deg∆0
1(L(d)).
Proof. Let (qn)n∈ω be an enumeration of a countable dense subset Q of X. We ﬁrst
recursively construct two sequences (rn)n∈ω, (sn)n∈ω of nonnegative reals and two
sequences (xn)n∈ω, (yn)n∈ω of points of X such that for all distinct n, m ∈ω the
following properties hold:
(a) d(xn, xm) = rmax{n,m} and d(xn, yn) = sn;
(b) rn+1 > max{n + 1, r2
n} (in particular, (rn)n∈ω is strictly increasing and un-
bounded in R+);
(c) s0 < 1 and sn+1 <
sn
rn+1 (in particular, (sn)n∈ω is a strictly decreasing se-
quence).
Claim 21. If x ∈X is not ε-isolated then there are at least two distinct qi, qj ∈Q
such that qi, qj ∈Bd(x, ε).
Proof of the Claim. Since x is not ε-isolated, there is y ∈Bd(x, ε) such that x ̸=
y. By density of Q, there are qi, qj ∈Q such that qi ∈Bd(x, d(x, y)) and qj ∈
Bd(y, d(x, y)). Then qi ̸= qj since Bd(x, d(x, y))∩Bd(y, d(x, y)) = ∅, while qi, qj ∈
Bd(x, ε) because Bd(x, d(x, y)), Bd(y, d(x, y)) ⊆Bd(x, ε) by d(x, y) < ε.
Let x ∈X be not 1-isolated (such an x exists because the diameter of X is nontriv-
ially unbounded), and let qi, qj be as in Claim 21 for ε = 1. Then we set x0 = qi,
y0 = qj, r0 = 0, and s0 = d(qi, qj). Now assume that xn, yn, rn, and sn have been
deﬁned. Let x, y ∈X be such that d(x, y) > max{n + 1, r2
n} and x, y are not
sn
rn+1-
isolated. Then at least one of x and y has distance greater than max{n + 1, r2
n}
from xn (and hence also from all the xm for m ≤n): if not, then we would have
d(x, y) ≤max{d(x, xn), d(y, xn)} ≤max{n + 1, r2
n}, contradicting our choice of
x, y. So we may assume without loss of generality that d(x, xn) > max{n + 1, r2
n}
and x is not
sn
rn+1-isolated. Let qi, qj be as in Claim 21 for ε =
sn
rn+1, and set xn+1 =
qi, yn+1 = qj, rn+1 = d(qi, xn), and sn+1 = d(qi, qj). Since d(qi, x) <
sn
rn+1 ≤1 ≤

226
|
Luca Motto Ros and Philipp Schlicht
max{n + 1, r2
n}, we have rn+1 = d(qi, xn) = d(x, xn) > max{n + 1, r2
n}. Moreover,
sn+1 <
sn
rn+1 by the fact that qi, qj ∈Bd(x,
sn
rn+1). Arguing by induction on n ∈ω,
it is then easy to check that the sequences constructed in this way have all the
desired properties.
Given a ⊆ω, let ˆa = {2i | i ∈ω} ∪{2i + 1 | i ∈a}, so that ˆa is always inﬁnite
and for every a, b ⊆ω
a ⊆∗b ⇐⇒ˆa ⊆∗ˆb.
For a ⊆ω, set ψ(a) = 
i∈ˆa Bd(xi, si). Clearly, each ψ(a) is an open subset of X.
To see that it is also closed, observe that Bd(xi, si) ⊆Bd(xi, 1) for every i ∈ω by
our choice of the si’s, and that for distinct i, j ∈ω the clopen balls Bd(xi, 1) and
Bd(xj, 1) are disjoint by our choice of the xi’s and of the ri’s: therefore, since the
open balls in X are automatically closed we get that
X \ ψ(a) =
 
Bd(z, 1) | z /∈

i∈ˆa Bd(xi, 1)

∪

{Bd(xi, 1) \ Bd(xi, si) | i ∈ˆa}
is open.
Let now a, b ⊆ω be such that a ⊆∗b, which in particular implies ˆa ⊆∗ˆb,
and let 0 ̸= ¯k ∈ω be such that ¯k ∈ˆa and k ∈ˆa ⇒k ∈ˆb for every k ≥¯k. Deﬁne
f : (X, d) →(X, d) as follows:
f(x) =













x¯k
if x ∈Bd(xi, si), i < ¯k, i ∈ˆa
y¯k
if x ∈Bd(x0, r¯k) \ {Bd(xi, si) | i < ¯k, i ∈ˆa}
yi
if x ∈Bd(xi, si), i ≥¯k, i /∈ˆa
x
otherwise.
It is straightforward to check that f reduces ψ(a) to ψ(b), so we only need to check
that f is nonexpansive, and this amounts to check that if x, y are distinct points of
X which fall in diﬀerent cases in the deﬁnition of f, then d(f(x), f(y)) ≤d(x, y).
A careful inspection shows that the unique nontrivial cases are the following:
case A: x ∈Bd(x0, r¯k), while y /∈Bd(x0, r¯k) ∪{Bd(xi, si) | i ≥¯k, i /∈ˆa}. Then
d(x, y) ≥r¯k (by case assumption) and d(x, f(x)) = r¯k (because either
f(x) = x¯k or f(x) = y¯k, depending on whether x ∈Bd(xi, si) for some i ∈
ˆa smaller than ¯k or not). Since in the case under consideration f(y) = y,
we get that either d(f(x), f(y)) ≤r¯k, or else d(f(x), f(y)) = d(f(x), y) =
d(x, y) by the isosceles triangle rule: in both cases, d(f(x), f(y)) ≤d(x, y)
as required.
case B: x ∈Bd(x0, r¯k) \ {Bd(xi, si) | i < ¯k, i ∈ˆa}, while y ∈Bd(xi, si) for some
i ≥¯k, i /∈ˆa. Then since d(x, x0) < r¯k and d(x0, y) = ri ≥r¯k, we get

Lipschitz and Uniformly Continuous Reducibilities
|
227
d(x, y) = ri. Since by case assumption f(x) = y¯k and f(y) = yi, either
f(x) = f(y) (in case i = ¯k) or d(f(x), f(y)) = ri, and hence we again get
d(f(x), f(y)) ≤d(x, y), as required.
case C: x ∈Bd(xi, si) for some i ≥¯k, i
/∈ˆa, while also y
/∈Bd(x0, r¯k)∪
{Bd(xi, si) | i ≥¯k, i /∈ˆa}. Then d(x, y) ≥si, d(x, f(x)) = si (because
f(x) = yi), and f(y) = y: this implies that either d(f(x), f(y)) ≤si
or d(f(x), f(y)) = d(f(x), y) = d(x, y), so that in any case d(f(x),
f(y)) ≤d(x, y).
This concludes the proof of part (1).
We now prove part (2) of the theorem. Given a, b ⊆ω, assume that f : (X, d) →
(X, d) is a Lip(d)-reduction of ψ(a) to ψ(b), and let 0 ̸= n ∈ω be such that
d(f(x), f(y)) ≤rn · d(x, y) for every x, y ∈X (such an n exists because (rn)n∈ω is
unbounded in R+ by (b) above). Notice that, necessarily,
f

{Bd(xi, si) | i ∈ˆa}

= f(ψ(a)) ⊆ψ(b) ⊆

j∈ω
Bd(xj, sj).
We now argue as in the proof of [15, Theorem 5.4].
Claim 22. Fix an arbitrary i ∈ˆa. If there are x ∈Bd(xi, si) and j ≥n such that
f(x) ∈Bd(xj, sj), then f(Bd(xi, si)) ⊆Bd(xj, sj).
Proof of the Claim. Suppose not, and let y ∈Bd(xi, si) and j′ ̸= j be such that
f(y) ∈Bd(xj′, sj′). Then
d(f(x), f(y)) = max{rj, rj′} ≥rj ≥rn · 1 > rn · si > rn · d(x, y),
contradicting the choice of n.
Claim 23. For every i ∈ˆa such that i > n, f(Bd(xi, si)) ⊆Bd(xj, sj) for some j ≥i.
Proof. Suppose towards a contradiction that there are x ∈Bd(xi, si) and j < i such
that f(x) ∈Bd(xj, sj), so that, in particular, j ∈ˆb because x ∈ψ(a) and f reduces
ψ(a) to ψ(b). Then since d(x, yi) = si, by our choice of the si’s we get
d(f(x), f(yi)) ≤rn · si ≤ri−1 · si < si−1 ≤sj,
and hence f(yi) ∈Bd(f(x), sj) = Bd(xj, sj) ⊆ψ(b): but this contradicts the fact
that f is a reduction of ψ(a) to ψ(b), because yi /∈ψ(a) while Bd(xj, sj) ⊆ψ(b)
since j ∈ˆb. Thus, given an arbitrary x ∈Bd(xi, si) there is j ≥i > n such that
f(x) ∈Bd(xj, sj): by Claim 22, we then get f(Bd(xi, si)) ⊆Bd(xj, sj), as required.

228
|
Luca Motto Ros and Philipp Schlicht
Let now ¯ı be the smallest element of ˆa. By Claim 22, either f(Bd(x¯ı, s¯ı))
⊆

j<n Bd(xj, sj), or f(Bd(x¯ıs¯ı)) ⊆Bd(xj, sj) for some j ≥n. Therefore, in both
cases there is ¯k > max{n,¯ı} such that f(Bd(x¯ı, s¯ı)) ⊆
j≤¯k Bd(xj, sj): we claim
that k ∈ˆa ⇒k ∈ˆb for every k ≥¯k, which also implies a ⊆∗b.
Fix k ≥¯k such that k ∈ˆa. By Claim 23 and ¯k > n, there is j ≥k such that
f(Bd(xk, sk)) ⊆Bd(xj, sj). Assume towards a contradiction that j > k: then
d(f(x¯ı), f(xk)) = rj > rk · rk > rn · rk = rn · d(x¯ı, xk),
contradicting the choice of n. Therefore f(Bd(xk, sk)) ⊆Bd(xk, sk), which in par-
ticular implies that ψ(b) ∩Bd(xk, sk) ̸= ∅(since xk ∈ψ(a) and f reduces ψ(a) to
ψ(b)): but this means that k ∈ˆb, and hence we are done.
Applying Theorem 20 to the space Qp of p-adic numbers (which is possible by
Example 18) we get the following corollary.
Corollary 24. Let p be a prime natural number, and let dp be the p-adic metric on
the space Qp. Then both the Lip(dp)- and the L(dp)-hierarchies are very bad already
when restricted to clopen subsets of Qp.
The condition on the diameter of X = (X, d) used to prove Theorem 20 is very
weak: this allows us to construct extremely simple (in fact: discrete) ultrametric
Polish spaces X = (X, d) with the property that their Lip(d)- and L(d)-hierarchies
are both very bad, despite the fact that all their subsets are topologically simple
(i.e. clopen).
Corollary 25. There exists a discrete (hence countable) ultrametric Polish space
X0
=
(X0, d0) such that (P(ω), ⊆∗) embeds into both the Lip(d0)- and the
L(d0)-hierarchy on (the clopen subsets of) X0. In particular, Deg(Lip(d0))
=
Deg∆0
1(Lip(d0)) and Deg(L(d0)) = Deg∆0
1(L(d0)) are both very bad.
Proof. Let X0 = {xi
n | n ∈ω, i = 0, 1} and set
d0(xi
n, xj
m) =







0
if n = m and i = j
2−n
if n = m and i ̸= j
max{n, m}
if n ̸= m.
It is easy to check that X0 = (X0, d0) is a discrete ultrametric Polish space. Now ob-
serve that the diameter of X0 is nontrivially unbounded. In fact, given n ∈ω and
ε ∈R+, let k be minimal such that 2−k < ε and l = max{n, k}: then d0(x0
l , x0
l+1) =
l + 1 > n, and the points x1
l and x1
l+1 witness that x0
l and x0
l+1 are not ε-isolated.
Therefore X0 is as desired by Theorem 20.

Lipschitz and Uniformly Continuous Reducibilities
|
229
The next proposition extends Theorem 16 and shows that the condition on X in
Theorem 20 is optimal.
Theorem 26. Let X = (X, d) be an ultrametric Polish space whose diameter is not
nontrivially unbounded. Then the Lip(d)-hierarchy Deg∆1
1(Lip(d)) on Borel subsets
of X is very good.
Proof. Let n ∈ω and ε ∈R+ be such that for every x, y, if d(x, y) > n then at least
one of x and y is ε-isolated.
Let us ﬁrst consider the degenerate case in which all points of X are ε-isolated.
Since constant functions are always (trivially) Lipschitz, we get that the sets X
and ∅are Lip(d)-incomparable, and that they are both (strictly) ≤Lip(d)-below any
other set ∅, X ̸= A ⊆X. Assume now that B ⊆X is another set which is diﬀerent
from both ∅and X: we claim that then A ≡Lip(d) B. To see this, ﬁx ¯x ∈B and
¯y ∈¬B, and for every x ∈X set f(x) = ¯x if x ∈A and f(x) = ¯y if x ∈¬A. Then
f : (X, d) →(X, d) reduces A to B. Moreover, since for all distinct x, y ∈X we have
d(x, y) ≥ε (because both x and y are ε-isolated), we get
d(f(x), f(y)) ≤d(¯x, ¯y) = d(¯x, ¯y)
ε
· ε ≤d(¯x, ¯y)
ε
· d(x, y),
so that f is Lipschitz with constant d(¯x,¯y)
ε
. This shows that A ≤Lip(d) B. Switching
the role of A and B, we get that also B ≤Lip(d) A, and hence we are done. Therefore
we have shown that the Lip(d)-hierarchy on X is constituted by the two Lip(d)-
incomparable degrees [∅]Lip(d) = {∅} and [X]Lip(d) = {X}, plus a unique Lip(d)-
degree above them containing all other subsets of X, and is thus (trivially) very
good.
Assume now that there is a non-ε-isolated point x0 ∈X, and set X′ = Bd(x0,
n + 1). By our choice of n and ε, we get that d(x, y) ≥n + 1 for every x ∈X′ and
y ∈X \ X′, and that each y ∈X \ X′ is ε-isolated (because d(x0, y) > n and x0 is
not ε-isolated). We ﬁrst prove the following useful claim.
Claim 27. Let A, B ⊆X be such that B ̸= ∅, X. If there is a Lipschitz reduction
f : (X′, dX′) →(X′, dX′) of A′ = A ∩X′ to B′ = B ∩X′, then A ≤Lip(d) B.
Proof. Let f be as in the hypothesis of the claim, and let 1 ≤k ∈ω be such that
d(f(x), f(y)) ≤k · d(x, y) for every x, y ∈X′. Fix ¯x ∈B and ¯y ∈¬B, and extend
f to the map ˆf : (X, d) →(X, d) by letting ˆf(x) = ¯x if x ∈A \ X′ and ˆf(x) = ¯y if
x ∈X \ (X′ ∪A). Clearly, ˆf reduces A to B, and we claim that ˆf is Lipschitz with
constant c, where c is
c = max

k, d(¯x, ¯y)
ε
, d(x0, ¯x)
n + 1 , d(x0, ¯y)
n + 1

.

230
|
Luca Motto Ros and Philipp Schlicht
Fix arbitrary x, y ∈X. If x, y ∈X′, then
d(ˆf(x), ˆf(y)) = d(f(x), f(y)) ≤k · d(x, y) ≤c · d(x, y)
by our choice of k ∈ω. If x, y ∈X \ X′, then d(x, y) ≥ε because both x and y
are ε-isolated, and either ˆf(x) = ˆf(y) or d(ˆf(x), ˆf(y)) = d(¯x, ¯y). Therefore in both
cases
d(ˆf(x), ˆf(y)) ≤d(¯x, ¯y)
ε
· ε ≤c · d(x, y).
Let now x ∈X′ and y ∈X\X′, and assume without loss of generality that ˆf(y) = ¯x
(the case ˆf(y) = ¯y is analogous, just systematically replace ¯x with ¯y in the argu-
ment below). Then either ¯x ∈X′, in which case d(ˆf(x), ˆf(y)) < n + 1 ≤d(x, y) ≤
c · d(x, y) (since c ≥k ≥1), or else
d(ˆf(x), ˆf(y)) = d(x0, ¯x) = d(x0, ¯x)
n + 1
· n + 1 ≤c · d(x, y).
The case x ∈X \ X′ and y ∈X′ can be treated similarly, so in all cases we obtained
d(ˆf(x), ˆf(y)) ≤c · d(x, y), as required.
We now want to show that the SLOLip(d) principle holds for Borel subsets of X, so
let us ﬁx arbitrary Borel A, B ⊆X. Assume ﬁrst that B = X. Then either A = X, in
which case the identity map on X witnesses A ≤Lip(d) B, or else ¬A ̸= ∅, in which
case any constant map with value ¯x ∈¬A witnesses B ≤Lip(d) ¬A. The symmetric
case B = ∅can be dealt with in a similar way, so in what follows we can assume
without loss of generality that B ̸= ∅, X. Moreover, switching the role of A and B
in the argument above we may further assume that A ̸= ∅, X. Set A′ = A ∩X′ and
B′ = B ∩X′. Since X′ has bounded diameter, by Theorem 16 there is a Lipschitz
function f : (X′, d) →(X′, d) such that either f −1(B′) = A′ or f −1(X′ \ A′) = B′.
Since ¬A ∩X′ = X′ \ A′, applying Claim 27 we get that either A ≤Lip(d) B or
B ≤Lip(d) ¬A, as desired.
Finally, let us show that the Lip(d)-hierarchy on Borel subsets of X is also well-
founded. Suppose not, and let (An)n∈ω be a sequence of Borel subsets of X such
that An+1 <Lip(d) An for every n ∈ω. Notice that this in particular implies that
An ̸= ∅, X for every n ∈ω. By Claim 27 and our choice of the An’s, for all i < j there
is no Lipschitz f : (X′, dX′) →(X′, dX′) reducing Ai ∩X′ to Aj ∩X′. Using Ramsey’s
theorem, we get that there is an inﬁnite I ⊆ω such that either ∀i, j ∈I (i < j ⇒
Aj ∩X′ ≤Lip(dX′) Ai ∩X′), or else ∀i, j ∈I (i < j ⇒Aj ∩X′ ≰Lip(dX′) Ai ∩X′): in the
former case the sequence (Ai ∩X′)i∈ω would give an inﬁnite (strictly) descending
chain in the Lip(dX′)-hierarchy on X′, while in the latter it would give an inﬁnite
antichain (in the same hierarchy). Since X′ has bounded diameter and all the sets
Ai ∩X′ are clearly Borel in it, both possibilities contradicts Theorem 16, and hence
we are done.

Lipschitz and Uniformly Continuous Reducibilities
|
231
Corollary 28. Let X = (X, d) be an ultrametric Polish space.Then the following are
equivalent:
1. the diameter of X is nontrivially unbounded;
2. (P(ω), ⊆∗) embeds into Deg∆0
1(Lip(d));
3. the Lip(d)-hierarchy on Borel (equivalently, clopen) subsets of X is very bad;
4. the Lip(d)-hierarchy on Borel (equivalently, clopen) subsets of X is not very
good.
Hence Deg∆1
1(Lip(d)) is either very good or very bad.
Proof. By Theorem 20 and Theorem 26.
Corollary 29. Let X = (X, d) be a perfect ultrametric Polish space. Then
1. X has bounded diameter
⇐⇒
the Lip(d)-hierarchy on Borel (equivalently,
clopen) subsets of X is very good;
2. X has unbounded diameter ⇐⇒the Lip(d)-hierarchy on Borel (equivalently,
clopen) subsets of X is very bad, and in fact in this case the partial order
(P(ω), ⊆∗) embeds into Deg∆0
1(Lip(d)).
Let us consider again the ultrametrics dϕ introduced in Deﬁnition 8.
Corollary 30. Let ϕ: ω →R+ have unbounded range and suppose that inf rg(ϕ) >
0. Then (P(ω), ⊆∗) embeds into both the Lip(dϕ)- and L(dϕ)-hierarchy on clopen
subsets of ωω, and therefore both Deg∆0
1(Lip(dϕ)) and Deg∆0
1(L(dϕ)) are very bad.
Conversely, if ϕ has bounded range, then the Lip(dϕ)-hierarchy Deg∆1
1 (Lip(dϕ)) on
Borel subsets of ωω is very good.
Proof. Observe that (ωω, dϕ) is a perfect ultrametric Polish space, and that it has
unbounded diameter if and only if the rg(ϕ) is unbounded in R+; then apply The-
orems 20 and 16.
4 Nonexpansive reducibilities
Deﬁnition 31. Let X = (X, d) be an ultrametric Polish space. We say that R(d)
contains an honest increasing sequence if it contains a strictly increasing sequence
(rn)n∈ω such that for some sequences (xn)n∈ω, (yn)n∈ω of points in X the following
conditions holds:
(i) d(xn, xm) = rmax{n,m} for all distinct n, m ∈ω;
(ii) d(x0, y0) < r0 and d(xn+1, yn+1) < d(xn, yn) for all n ∈ω.

232
|
Luca Motto Ros and Philipp Schlicht
The above condition is somewhat technical, but in case X = (X, d) is a perfect
ultrametric Polish space it is immediate to check that R(d) contains an honest
increasing sequence if and only if one of the following equivalent¹² conditions are
satisﬁed:
1. there is X′ ⊆X such that R(dX′) has order type ω (with respect to the usual
ordering on R);
2. there is a sequence (xn)n∈ω of points in X and a strictly increasing sequence
(rn)n∈ω of distances in R(d) such that d(xn, xm) = rmax{n,m} for all distinct
n, m ∈ω.
Notice also that if the diameter of an ultrametric Polish space X = (X, d) is nontriv-
ially unbounded, then R(d) contains an honest increasing sequence by the ﬁrst
part of the proof of Theorem 20.
Theorem 32. Let X = (X, d) be a ultrametric Polish space such that R(d) contains
an honest increasing sequence. Then there is a map ψ from P(ω) into the clopen
subsets of X such that for all a, b ⊆ω
a ⊆∗b ⇐⇒ψ(a) ≤L(d) ψ(b).
Proof. Argue similarly to Theorem 20, with the following variations:
(a) let the sequences (xn)n∈ω, (yn)n∈ω, and (rn)n∈ω constructed at the beginning
of the proof of Theorem 20 be witnesses of the fact that R(d) contains an hon-
est increasing sequence (forgetting about the extra properties required in The-
orem 20), and set sn = d(xn, yn);¹³
(b) given a ⊆ω, deﬁne ψ(a) as before, i.e. set ψ(a) = 
i∈ˆa Bd(xi, si), where
ˆa = {2i | i ∈ω} ∪{2i + 1 | i ∈a};
(c) to prove the backward direction, use an argument similar to that of Theo-
rem 20, but dropping any reference to the integer n (this simpliﬁcation can
be adopted here because we have to deal only with nonexpansive functions).
More precisely: let f be a nonexpansive reduction of ψ(a) to ψ(b). Then for ev-
ery i ∈ˆa there is a unique j ∈ω such that f(Bd(xi, si)) ⊆Bd(xj, sj) (because
of the choice of the xi, yi’s and the fact that f is nonexpansive). Arguing as in
Claim 23, one immediately sees that we cannot have j < i because in such case
12 To see that these two conditions are indeed equivalent, argue as in the ﬁrst part of the proof of
Theorem 20.
13 Clearly, the points xn and yn can again be chosen in any given countable dense set Q ⊆X.

Lipschitz and Uniformly Continuous Reducibilities
|
233
si ≤sj. Conclude as in the ﬁnal part of the proof of Theorem 20, using the fact
that rk < rj for every j > k.
Corollary 33. There is an ultrametric Polish space X1 = (X1, d1) whose set of
nonzero distances R(d1) is bounded away from 0 (hence it is countable and dis-
crete) such that (P(ω), ⊆∗) embeds into the L(d1)-hierarchy on (clopen subsets of)
X1. Therefore Deg(L(d1)) = Deg∆0
1(L(d1)) is very bad.
Proof. Let X1 = {xi
n | n ∈ω, i = 0, 1} and set
d1(xi
n, xj
m) =







0
if n = m and i = j
1
2 + 2−(n+1)
if n = m and i ̸= j
2 −2−max{n,m}
if n ̸= m.
It is easy to check that X1 = (X1, d1) is an ultrametric Polish space. Moreover
r ≥1
2 for every r ∈R(d1), hence R(d1) is bounded away from 0. Moreover, the
sequences obtained by setting rn = 2 −2−n, xn = x0
n, and yn = x1
n witness that
R(d1) contains an honest increasing sequence. Hence the result follows from The-
orem 32.
Remark 34. Notice that if an ultrametric Polish space X = (X, d) satisﬁes the hy-
pothesis of Corollary 33 (i.e. it is such that R(d) is bounded away from 0), then its
Lip(d)-hierarchy is always (trivially) very good by Theorem 26 and the fact that all
its points are ε-isolated for ε = inf R(d) > 0.
Corollary 35. Given ϕ: ω →R+ such that inf rg(ϕ) > 0, if rg(ϕ) contains an
increasing ω-sequence then (P(ω), ⊆∗) embeds into the L(dϕ)-hierarchy on clopen
subsets of ωω, and therefore Deg∆0
1(L(dϕ)) is very bad.
Proof. Notice that (ωω, dϕ) is always a perfect Polish space, and that R(dϕ) has
an honest increasing sequence if and only if rg(ϕ) contains an increasing ω-
sequence. Then apply Theorem 32.
Proposition 36. Suppose that X = (X, d) is an ultrametric Polish space such that
R(d) is either ﬁnite or a descending (ω-)sequence converging to 0, let I ≤ω be the
cardinality of R(d), and let ρ be the unique order-preserving map from {2−i | i < I}
and R(d). Then there is a closed set C ⊆ωω and a bijection f : C →X such that for
all x, y ∈X
d(x, y) = ρ(¯d(f −1(x), f −1(y))).
(∗)
In particular, the structures (P(X), ≤L(d), ¬) and (P(C), ≤L(¯d), ¬) are isomorphic.

234
|
Luca Motto Ros and Philipp Schlicht
Proof. Let us ﬁrst assume that I = ω, i.e. that R(d) is a descending (ω-)sequence
converging to 0. Inductively deﬁne the family (As)s∈<ωω of subsets of X by induc-
tion on lh(s) as follows. Set A∅= X. Then let {Bs,j | j < J} (for some J ≤ω) be
an enumeration without repetitions of the collection {Bd(x, ρ(2−lh(s))) | x ∈As},
and set As⌢j = Bs,j if j < J and As⌢j = ∅otherwise. It is easy to check that the fam-
ily (As)s∈<ωω is a Luzin scheme with vanishing diameter consisting of clopen sets.
Hence letting C = {x ∈ωω | 
n∈ω Ax↾n ̸= ∅} and f : C →X be deﬁned by letting
f(x) be the unique element of 
n∈ω Ax↾n, we get that C and f are as required.
Assume now that I is ﬁnite, so that, in particular, X is a discrete space. Induc-
tively deﬁne the sets As as above for all s ∈<ωω of length ≤I. Then if lh(s) = I
the set As is either empty or a singleton. Letting C = {s⌢0(ω) | lh(s) = I, As ̸= ∅}
and deﬁning f : C →X by letting f(s⌢0(ω)) be the unique element of As we again
have that C and f are as required.
For the last part, notice that the map P(X) →P(C): A →f −1(A) is the
desired isomorphism. To see this, simply notice that (∗) implies that L(d) = {f ◦
h ◦f −1 | h ∈L(¯dC)}.
Theorem 37. Suppose that X = (X, d) is an ultrametric Polish space such that
R(d) is either ﬁnite or a descending (ω-)sequence converging to 0. Then the L(d)-
hierarchy Deg∆1
1(L(d)) on Borel subsets of X is very good.
Proof. By Proposition 36, it is clearly enough to show that the L(¯dC)-hierarchy on
Borel subsets of C is very good: but this easily follows from the existence of a non-
expansive retraction of (ωω, ¯d) onto (C, ¯dC), Lemma 6, and the fact that the L(¯d)-
hierarchy on the Borel subsets of ωω is very good.
Corollary 38. Let ϕ: ω →R+ and suppose that rg(ϕ) is ﬁnite (so that trivially
inf rg(ϕ) > 0). Then the L(dϕ)-hierarchy Deg∆1
1(L(dϕ)) on Borel subsets of ωω is
very good.
Proof. Simply observe that under our assumptions the set R(dϕ) is always an ω-
sequence converging to 0, and then apply Theorem 37.
Let us now consider the general problem of determining the character of the L(dϕ)-
hierarchy on Borel subsets of ωω for an arbitrary ϕ: ω →R+ with inf rg(ϕ) > 0.
By Corollary 35, if rg(ϕ) contains an increasing ω-sequence, then Deg∆1
1 (L(dϕ))
is very bad, hence we can assume without loss of generality that rg(ϕ) has order

Lipschitz and Uniformly Continuous Reducibilities
|
235
type¹⁴ α∗for some countable ordinal α. Corollary 38 considered the subcase where
α is ﬁnite: the next proposition considers instead the special (but yet signiﬁcant)
subcase where α = ω and ϕ is injective.
Notation 39. Given a set A ⊆ωω and a ﬁnite sequence s ∈<ωω, let s⌢A = {s⌢x |
x ∈A}. When lh(s) = 1, we simplify the notation by setting n⌢A = ⟨n⟩⌢A, and
with a little abuse of notation we set r⌢A = {r⌢x | x ∈A} ⊆{r} × ωω also when
r is not a natural number. Finally, given a family (An)n∈ω of subsets of ωω, we set

n∈ω An = 
n∈ω n⌢An.
Theorem 40. Let ϕ: ω →R+ be such that inf rg(ϕ) > 0, and suppose that ϕ is
injective and that rg(ϕ) has order type ω∗. Then the L(dϕ)-hierarchy Deg∆1
1(L(dϕ))
on the Borel subsets of ωω is very good.
Proof. Using the usual game-theoretic arguments (see e.g. [3]), it is easy to see
that if a Borel A ⊆ωω is L(¯d)-selfdual, then its L(¯d)-degree [A]L(¯d) is followed by
an ω1-chain of L(¯d)-selfdual degrees (L (α)[A]L(¯d))α<ω1, where the L (α)[A]L(¯d) are
recursively deﬁned as follows:
(i)
L (0)[A]L(¯d) = [A]L(¯d);
(ii) L (α+1)[A]L(¯d) = [0⌢C]L(¯d) for some/any C ∈L (α)[A]L(¯d);
(iii) for limit α’s, L (α)[A]L(¯d) = [
n∈ω Cn]L(¯d), where Cn ∈L (αn)[A]L(¯d) for each
n ∈ω, and (αn)n∈ω is some/any increasing sequence coﬁnal in α.
We will use the following known facts about the Baire space (ωω, ¯d).
–
A set A is self-contractible (i.e. reducible to itself via a contraction) if and only
if it is L(¯d)-nonselfdual; in this case the iterates of the contraction are reduc-
tions of A to itself and have a unique common ﬁxed point (see [15, Corollary
4.4]).
–
The L(¯d)-nonselfdual degrees coincide with the W(¯d)-nonselfdual degrees
(see e.g. [23, Theorem 3.1]).
–
Every Lip(¯d)-selfdual degree [A]Lip(¯d) is of the form {[0(n)⌢A′]L(¯d) | n < ω}
for some L(¯d)-selfdual set A′; if instead [A]Lip(¯d) is Lip(¯d)-nonselfdual, then
[A]Lip(¯d) = [A]L(¯d) (see [13]).
–
If A <Lip(¯d) B, then for all ε ∈R+ there is a Lipschitz reduction of A to B with
constant ε (see the end of Section 4 in [15]).
14 Given a linear order L = (L, ≤), we denote by L∗the reverse linear oder induced by L, i.e.
L∗= (L, ≤−1). Since α = {β | β < α} (for every ordinal α), we tacitly identify α with the linear
order α = (α, ≤), so that α∗= (α, ≥).

236
|
Luca Motto Ros and Philipp Schlicht
–
Let W = W(ωω) be the set of all continuous functions from ωω into itself,
which is clearly a reducibility. Then every W-selfdual degree [A]W is of the form

{L (α)([A′]L(d)) | α < ω1}
for some L(¯d)-selfdual set A′ (see e.g. [3]).
Note that (ωω, dϕ) is isometric to the space Y = 
r∈rg(ϕ) r⌢ωω equipped with the
ultrametric (which with a little abuse of notation will be denoted by dϕ again)
dϕ(r⌢x, s⌢y) =







0
if r = s and x = y,
max{r, s}
if r ̸= s,
r · 2−(n+1)
if r = s and n is least such that x(n) ̸= y(n).
Claim 41. Every Borel subset ¯C of Y = (Y, dϕ) is L(dϕ)-equivalent to one of the
following (L(dϕ)-)normal forms ¯A (where in what follows A, An ⊆ωω and < is the
usual order on the reals):
1. ¯A = 
n∈ω r⌢
n An, where the sequence of the An’s is <Lip(¯d)-increasing and the
sequence (rn)n∈ω in rg(ϕ) is strictly <-decreasing.
2. ¯A = 
n∈ω r⌢
n An, where the sequence of the An’s is <L(¯d)-increasing, Am ≡Lip(¯d)
An for all m, n ∈ω, and the sequence (rn)n∈ω in rg(ϕ) is strictly <-decreasing.
3. A is L(¯d)-nonselfdual and
(a) ¯A = r⌢A for some r ∈rg(ϕ), or
(b) ¯A = (r⌢
0 A) ∪(r⌢
1 (¬A)) for some r0, r1 ∈rg(ϕ) with r0 > r1, or
(c) ¯A = 
i∈ω r2i
⌢A ∪
i∈ω r2i+1
⌢(¬A) for some strictly <-decreasing se-
quence (rn)n∈ω in rg(ϕ).
4. A is L(¯d)-selfdual and
(a) ¯A = r⌢A for some r ∈rg(ϕ), or
(b) ¯A = 
n∈ω r⌢
n A for some strictly <-decreasing sequence (rn)n∈ω in rg(ϕ).
Proof of the Claim. Let us sketch how to obtain these normal forms. We will often
use the following easy fact. Let D ⊆rg(ϕ), ρ: D →rg(ϕ) be a non-<-increasing
map, {fr : ωω →ωω | r ∈D} ⊆L(¯d), and f ′ : 
r∈rg(ϕ)\D(r⌢ωω) →Y be a
nonexpansive map (with respect to dϕ): then the map f : Y →Y deﬁned by
f(r⌢x) =

ρ(r)⌢fr(x)
if r ∈D
f ′(r⌢x)
otherwise
is in L(dϕ).
Now let ¯C = 
r∈rg(ϕ)(r⌢Cr) be an arbitrary Borel subset of (Y, dϕ), and
set C = {Cr | r ∈rg(ϕ)}, so that each Cr is a Borel subset of ωω. If C has no

Lipschitz and Uniformly Continuous Reducibilities
|
237
Lip(¯d)-maximal element, choose a strictly <-decreasing sequence (rn)n∈ω in rg(ϕ)
such that (Crn)n∈ω is strictly <Lip(dϕ)-increasing and <Lip(dϕ)-coﬁnal in C. Then ¯A =

n∈ω Crn is in the normal form (1), and moreover it is easy to see that ¯A ≡L(dϕ) ¯C.
Otherwise, if C has a Lip(¯d)-maximal element but no L(¯d)-maximal element, then
we can similarly ﬁnd a set ¯A in the normal form (2) which is L(dϕ)-equivalent to
¯C.
Now suppose that there is an L(¯d)-maximal element B among the sets in C.
Suppose ﬁrst that B is L(¯d)-nonselfdual.
If there is no C ∈C with C ≡L(¯d) ¬B, then we choose some r ∈rg(ϕ) with
Cr ≡L(¯d) B. Using the assumption inf rg(ϕ) > 0 and the fact mentioned at the
beginning of the proof that L(¯d)-nonselfdual sets are self-contractible with arbi-
trarily small Lipschitz constant, it follows that ¯A = r⌢Cr ≡L(dϕ) ¯C, and ¯A is in
the normal form (3a). (For the nontrivial reduction, for each t ∈rg(ϕ) choose a
L(¯d)-reduction ft : ωω →ωω of Ct to Cr, let ε ∈R+ be such that max rg(ϕ) · ε ≤
inf rg(ϕ), and let g: ωω →ωω be a Lipschitz map with constant ε reducing Cr to
itself. Deﬁne f : Y →Y by setting f(t⌢x) = r⌢g(ft(x)) for every t ∈rg(ϕ) and
x ∈ωω: it is easy to check that f ∈L(dϕ) reduces ¯C to ¯A.)
If there is a <-minimal s ∈rg(ϕ) with Cs ≡L(¯d) ¬B, let r be either the <-minimal
element of rg(ϕ) with Cr ≡L(¯d) B, or the <-largest element of rg(ϕ) satisfying both
Cr ≡L(¯d) B and r < s. Then ¯A = r⌢Cr∪s⌢Cs is in the normal form (3b), and arguing
as above one can check that ¯C ≡Ld(ϕ) ¯A using the assumption inf rg(ϕ) > 0 and the
previously mentioned fact about self-contractions. (For the nontrivial reduction,
notice that we can assume without loss of generality that r < s (otherwise we
simply switch the role of Cr and Cs). Let D = {t ∈rg(ϕ) | Ct ≡L(¯d) ¬B}, so that
s = min D. For t ∈rg(ϕ), set ρ(t) = s if t ∈D and ρ(t) = r otherwise. Let ft
be a L(¯d)-reduction of Ct to Cs if t ∈D and of Ct to Cr otherwise. Let ε and g
be as above. Then the map f : Y →Y deﬁned by f(t⌢x) = s⌢ft(x) if t ∈D and
f(t⌢x) = r⌢g(ft(x)) otherwise is an L(dϕ)-reduction of ¯C to ¯A.)
If there are unboundedly many s ∈rg(ϕ) with Cs ≡L(¯d) ¬B and an <-minimal
r ∈rg(ϕ) with Cr ≡L(¯d) B, argue as in the previous paragraph switching the role
of B and r with, respectively, ¬B and s.
In the remaining case there are unboundedly many r ∈rg(ϕ) with Cr ≡L(¯d) B
and unboundedly many s ∈rg(ϕ) with Cs ≡L(¯d) ¬B. In this situation it is easy to
see that ¯C is L(dϕ)-equivalent to a set ¯A in the normal form (3c).
Finally, suppose that C has a L(¯d)-maximal element B and that B is L(¯d)-
selfdual. It follows from the remarks at the beginning of the proof that there is an
L(¯d)-nonselfdual set A with B ∈L (λ+n)[A⊕(¬A)]L(¯d) for some n ∈ω and λ = 0 or
λ a countable limit ordinal. Set D = {r ∈rg(ϕ) | Cr ∈
j∈ω L (λ+j)[A ⊕(¬A)]L(¯d)},
and deﬁne the index of any r ∈D as i(r) = r · 2−(j+1), where j is the unique natu-

238
|
Luca Motto Ros and Philipp Schlicht
ral number such that Cr ∈L (λ+j)[A ⊕(¬A)]L(¯d). Then for any r, s ∈D for which
i(r) ≤i(s) there is an L(dϕ)-map f such that f(s⌢ωω) ⊆r⌢ωω and f reduces s⌢Cs
to r⌢Cr.
Suppose ﬁrst that there is j ≤n such that Crm ∈L (λ+j)[A ⊕(¬A)]L(¯d) for
some strictly <-descending sequence (rm)m∈ω of distances in rg(ϕ), and let k be
the largest of such j’s. If n = k, then ¯A = 
m∈ω r⌢
mCrm is in the normal form (4b)
and ¯A ≡L(dϕ) ¯C. If n > k, let r be <-smallest in rg(ϕ) such that Cr ≡L(¯d) B. If
inf rg(ϕ) < r · 2n−k, then using the fact that Cr is reducible to each of the Crm’s
with some Lipschitz function with constant 2n−k we get that ¯C ≡L(dϕ) ¯C′, where
¯C′ = ¯C \

t≥r t⌢ωω

. Applying recursively this same procedure, after ﬁnitely
many steps we will end up with a set ¯C∗≡L(dϕ) ¯C such that either the Crm are L(¯d)-
maximal in C∗, or else there is an <-smallest r such that Cr is L(¯d)-maximal in C∗,
Cr ∈L (λ+n∗)[A ⊕(¬A)]L(¯d) for some k < n∗≤n, and r · 2n∗−k ≤inf rg(ϕ). In
the former case we again easily get that ¯A = 
m∈ω r⌢
mCrm is in the normal form
(4b) and ¯A ≡L(dϕ) ¯C∗≡L(dϕ) ¯C. In the latter case, we get that ¯A = r⌢Cr is in
normal form (4a) and ¯A ≡L(dϕ) ¯C∗≡L(dϕ) ¯C. (To see that ¯C∗≤L(dϕ) ¯A, which is the
only nontrivial reduction, notice that we may assume without loss of generality
that all the Crm’s equal a ﬁxed set C ̸= ωω, that Cr = 0(n∗−k)⌢C, and that for
t /∈{r} ∪{rm | m ∈ω} either Ct = ∅or Ct = 0(it+1)⌢C for some it < n∗−k. Fix
t ∈rg(ϕ). If t ≥r then let ft : ωω →ωω be a L(¯d)-reduction of Ct to Cr. If t = rm
for some m ∈ω, deﬁne ft by setting ft(x) = 0(n∗−k)⌢x for all x ∈ωω. Finally, if
t < r and t ̸= rm, then let ft be a constant map with value 0(n∗−k)⌢y for some ﬁxed
y /∈C if Ct = ∅, and otherwise set ft(x) = 0(n∗−k−it−1)⌢x for all x ∈ωω. Then the
map f : Y →Y deﬁned by setting f(t⌢x) = r⌢ft(x) for all t ∈rg(ϕ) and x ∈ωω is
a L(dϕ)-reduction of ¯C to ¯A.)
Therefore we may assume without loss of generality that D is ﬁnite. Actually,
applying the standard arguments used above it is not diﬃcult to see that we may
also assume that there are m ∈ω, a strictly <-decreasing sequence r0, . . . , rm ∈
rg(ϕ), and a strictly decreasing sequence n0, . . . , nm ∈ω such that:
–
Crk ∈L (λ+nk)[A ⊕(¬A)]L(¯d) for all k ≤m;
–
i(rk) < i(rk+1) for all k < m;
–
Ct = ∅for all t ≥rm which are not of the form rk for some k ≤m;
–
Ct <Lip(¯d) Crm for all t < rm.
Assume ﬁrst that λ > 0. Then without loss of generality we may assume that Crk =
0(nk)⌢
l∈ω(0(l)⌢C′
l) for all k ≤m, where the C′
l’s are strictly L(¯d)-increasing sub-
sets of ωω such that their L(¯d)-degrees are coﬁnal below L (λ)[A⊕(¬A)]L(¯d). Notice
that in this case i(rk) measures the dϕ-distance between each pair of subsets of Crk
of the form 0(nk)⌢l⌢0(l)⌢C′
l. Assume ﬁrst that there is l ∈ω such that Ct ≤L(¯d) C′
l

Lipschitz and Uniformly Continuous Reducibilities
|
239
for all t < rm. Then it is not hard to see that ¯A = r0⌢Cr0 is in normal form (4a)
and ¯A ≡L(dϕ) ¯C. (An L(dϕ)-reduction f of ¯C to ¯A may be deﬁned on sets of the
form t⌢ωω for t < rm by ﬁxing l′ ≥l such that 2−l′ ≤inf rg(ϕ) and an L(¯d)-
reduction ft of Ct to C′
l′, and then setting f(t⌢x) = r0⌢0(n0)⌢l′⌢0(l′)⌢ft(x); for
t ≥rm, the map f may be deﬁned on t⌢ωω in the obvious way using the property
of the i(rk)’s mentioned above.) Now assume instead that the family {Ct | t < rm}
is L(¯d)-coﬁnal below 
l∈ω C′
l ≡L(¯d)

l∈ω 0(l)⌢C′
l ∈L (λ)[A ⊕(¬A)]L(¯d). Then us-
ing arguments similar to the one already applied, one gets that if i(r0) ≤inf rg(ϕ)
then we can again set ¯A = r0⌢C0, so that ¯A is in normal form (4a), and prove that
¯A ≡L(dϕ) ¯C, while if i(r0) > inf rg(ϕ) then we may choose a strictly decreasing se-
quence (th)h∈ω so that t0 < min{rm, i(r0)} and the Cth’s are ≤L(¯d)-increasing, all
in the same Lip(¯d)-degree, and coﬁnal below 
l∈ω 0(l)⌢C′
l, and then prove that
¯A = 
h∈ω th
⌢Cth is in normal form (2) and L(dϕ)-equivalent to ¯C.
Finally, let λ = 0. In this case we may assume without loss of generality that
Crk = 0(nk)⌢(A ⊕¬A) for all k ≤m, and i(rk) measures the distance between
the copies of A and ¬A in Crk. Let us ﬁrst suppose that there are arbitrarily small
r, s > inf rg(ϕ) with Cr ≡L(dϕ) A and Cs ≡L(dϕ) ¬A. If i(r0) ≤inf rg(ϕ), we let ¯A =
r⌢
0 Cr0; then ¯A is in the normal form (4a) and arguing as above we get ¯A ≡L(dϕ) ¯C.
If i(r0) > inf rg(ϕ), we choose a strictly decreasing sequence (th)h∈ω in rg(ϕ) with
t0 < min{rm, i(r0)}, Ct2p ≡L(¯d) A and Ct2p+1 ≡L(¯d) ¬A, and let ¯A = 
h∈ω th
⌢Cth.
Then ¯A is in the normal form (3c) and, arguing as in the case λ > 0, we get ¯A ≡L(dϕ)
¯C. Next, let us suppose that there are no r, s < i(r0) in rg(ϕ) with Cr ≡L(¯d) A and
Cs ≡L(¯d) ¬A. Let ¯A = r⌢
0 Cr0. Then ¯A is in the normal form (4a), and using the self-
contractibility of A and inf rg(ϕ) > 0 we again obtain ¯A ≡L(dϕ) ¯C. Finally, suppose
that there are r, s < i(r0) in rg(ϕ) with Cr ≡L(¯d) A and Cs ≡L(¯d) ¬A and that there
is an <-minimal r ∈rg(ϕ) with Cr ≡L(¯d) A (the analogous situation in which there
is a minimal r ∈rg(ϕ) with Cr ≡L(¯d) ¬A can be treated similarly). We consider the
<-smallest s ∈rg(ϕ) with Cs ≡L(¯d) ¬A if this exists, and any s ∈rg(ϕ) with s < r
and Cs ≡L(¯d) ¬A otherwise. Then ¯A = r⌢A ∪s⌢(¬A) is in the normal form (3b)
and ¯A ≡L(dϕ) ¯C.
By Claim 41, to show that SLOL(dϕ) holds for Borel subsets of Y it is enough to show
that for every pair of Borel sets ¯A and ¯B in L(dϕ)-normal form, either ¯A ≤L(dϕ) ¯B
or ¯B ≤L(dϕ) ¬¯A: we are now going to sketch the proof of this fact, by considering
all the possible combinations of normal forms.
If ¯A is in case (1) of the normal form, then it is L(dϕ)-selfdual, and hence semi-
linearity is equivalent to showing that ¯A ≤L(dϕ) ¯B or ¯B ≤L(dϕ) ¯A. Let A′ = ⊕n∈ωAn,
so that [A′]L(¯d) = supn∈ω[An]L(¯d). First assume that ¯B is either in normal form (1)
or (2), and let B′ = 
n∈ω Bn. If A′ <L(¯d) B′ (equivalently, A′ <Lip(¯d) B′), then we

240
|
Luca Motto Ros and Philipp Schlicht
get ¯A ≤L(dϕ) ¯B, and similarly switching the role of A and B. If instead A′ ≡L(¯d) B′,
then we get ¯A ≡L(dϕ) ¯B. Assume now that ¯B is either in normal form (3) or (4). Then
using B in place of B′ in the argument above (and noticing that either A′ ≤Lip(¯d) B
or else B ≤L(¯d) An for all suﬃciently large n ∈ω) we get again that ¯A is L(dϕ)-
comparable with ¯B, as required.
Let now ¯A be in normal form (2). If ¯B is in normal form (2) too, arguing as in
the previous case we compare A′ = 
n∈ω An and B′ = 
n∈ω Bn with respect to
L(¯d). Similarly, if ¯B is in case (3), we compare A′ with B with respect to L(¯d), and
then argue as above again. Now let us suppose that ¯B is in case (4). If An <Lip(¯d) B
for all n ∈ω, then ¯A ≤L(dϕ) ¯B. Otherwise B ≤L(¯d) An for some n ∈ω and thus
¯B ≤L(¯d) ¯A.
We now assume that ¯A is in normal form (3). If ¯B is in normal form (3) too,
we can prove ¯A ≤L(dϕ) ¯B or ¯B ≤L(dϕ) ¬¯A by ﬁrst comparing A and B with re-
spect to Lip(¯d)-reducibility (equivalently, L(¯d)-reducibility), using the assumption
inf rg(ϕ) > 0. If ¯A ≡Lip(¯d) ¯B and both ¯A and ¯B are in case (3b), then we simply
compare the minimum of the values r1 appearing in their normal forms. The com-
parison is straightforward in all other cases for ¯A and ¯B in the normal form (3)
with ¯A ≡Lip(¯d) ¯B. If instead ¯B is in case (4), using the assumption inf rg(ϕ) > 0,
we simply need to compare the L(¯d)-degrees of A and B; all possible relationships
between these degrees with respect to ≤L(¯d) can be transferred back to analogous
relationships between ¯A and ¯B with respect to ≤L(dϕ).
Let us ﬁnally suppose that ¯A and ¯B are both in case (4); this is the more del-
icate case. Since ¯A and ¯B are clearly L(dϕ)-selfdual, it is again suﬃcient to show
that they are L(dϕ)-comparable. First assume that ¯A and ¯B are both in case (4a),
where ¯A = r⌢A and ¯B = s⌢B. If A and B are not in the same Lip(¯d)-degree, then it
is easy to compare ¯A and ¯B with respect to ≤L(dϕ), and if A ≤L(¯d) B then ¯A ≤L(dϕ) ¯B.
Hence we can assume that A ≡Lip(¯d) B and B ≤L(¯d) A, so that A ≡L(¯d) 0(n)⌢B for
some n ∈ω. Using the assumption inf rg(ϕ) > 0, it is now easy to check that
¯A ≤L(dϕ) ¯B holds if s · 2n ≤r, while ¯B ≤L(dϕ) ¯A holds if r ≤s · 2n.
Suppose now that ¯A = r⌢A is in case (4a) and ¯B is in case (4b). We have
¯A ≤L(dϕ) ¯B if A ≤L(¯d) B holds, and moreover B <Lip(¯d) A implies that 0(n)⌢B
≤L(¯d) A for all n ∈ω (which in turn implies ¯B ≤L(dϕ) ¯A). Thus we can assume
that A ≡Lip(¯d) B and B ≤L(¯d) A, so that again A ≡L(¯d) 0(n)⌢B for some n ∈ω, and
let s = inf rg(ϕ). Arguing similarly to the previous case, it is easy to check that
¯A ≤L(dϕ) ¯B holds if s · 2n < r, while ¯B ≤L(dϕ) ¯A holds if s · 2n ≥r.
The last case that needs to be considered is when both ¯A and ¯B are in case
(4b). We may assume that A ≤L(¯d) B and hence ¯A ≤L(dϕ) ¯B. This concludes the
proof that SLOL(dϕ) holds for Borel subsets (in normal form) of Y.

Lipschitz and Uniformly Continuous Reducibilities
|
241
It remains to show that the L(dϕ)-hierarchy on Borel subsets of Y is well-
founded, and for this we may again concentrate only on sets in normal form.
Assume towards a contradiction that there is a family (¯A(i))i∈ω of Borel subsets
of Y in normal form such that ¯A(i+1) <L(dϕ) ¯A(i) for all i ∈ω. Since there are only
ﬁnitely many types of normal form, passing to a subsequence if necessary we may
further assume that all the ¯A(i)’s share the same type of normal form. We now
consider the various possibilities.
First assume that the ¯A(i)’s are all in normal form (1), and set (A′)(i) =

n∈ω A(i)
n , where the sets A(i)
n
⊆ωω are those appearing in the normal form of
¯A(i). Notice that all the (A′)(i) are necessarily L(¯d)-selfdual. Then (A′)(i+1) <L(¯d)
(A′)(i), because otherwise (A′)(i) ≤L(¯d) (A′)(i+1), whence one would easily get
¯A(i) ≤L(dϕ) ¯A(i+1), contradicting the choice of the ¯A(i)’s. Therefore the (A′)(i) are
strictly L(¯d)-decreasing, contradicting the fact that the L(¯d)-hierarchy on Borel
subsets of ωω is well-founded.
The case where all the ¯A(i)’s are in normal form (2) can be dealt with in the
same way, and a similar argument works also for the other cases with the follow-
ing minor modiﬁcations:
–
When considering normal forms as in (3a), set (A′)(i) = A(i), where A(i) ⊆ωω
is the set appearing in the normal form of ¯A(i), and pass to a subsequence if
necessary to avoid the situations in which A(i+1) ≡L(¯d) ¬A(i);
–
When considering normal forms as in (3b) or (3c), set (A′)(i) = (0⌢A(i)) ∪
(1⌢(¬A(i))), where A(i), ¬A(i) ⊆ωω are the sets appearing in the normal form
of ¯A(i). In case (3b), we may need to pass to a subsequence ((A′)(il))l∈ω to
guarantee that A(il+1) <L(¯d) A(il).
–
When considering normal forms as in (4), set (A′)(i) = A(i), where A(i) ⊆ωω
is the set appearing in the normal form of ¯A(i). In case (4a) it may be necessary
to ﬁrst pass to a subsequence ((A′)(il))l∈ω to guarantee that the sequence of
the r(il)’s appearing in the canonical form of ¯A(il) is not <-increasing.
This concludes the proof of the well-foundness of ≤L(dϕ) on Borel subsets of Y,
and hence of the entire proposition.
Corollaries 35, 38, and Theorem 40 already cover many interesting cases, and us-
ing the methods developed in the proof of Theorem 40 it seems plausible to conjec-
ture that if the range of ϕ does not contain increasing ω-sequences, then the L(dϕ)-
hierarchy on Borel subsets of ωω is well-founded. However, the general problem
of determining the character of the L(d)-hierarchy on an arbitrary ultrametric Pol-
ish space X = (X, d) remains open:

242
|
Luca Motto Ros and Philipp Schlicht
Question 42. Let X = (X, d) be an ultrametric (perfect) Polish space such that R(d)
does not contain an honest increasing sequence, and assume that R(d) is neither
ﬁnite nor a (ω-)sequence converging to 0. Is the L(d)-hierarchy Deg∆1
1(L(d)) on the
Borel subsets of X (very) good?
Remark 43. In order to answer Question 42, it may be useful to note the following.
It is proved in [4, Theorem 4.1] that every ultrametric Polish space X = (X, d) is
isometric to a closed subspace of the ultrametric Urysohn space UR(d) = {(xn)n∈ω ∈
ω(R(d)∪{0}) | xn ≥xn+1 for all n and limn→∞xn = 0} equipped with the complete
ultrametric
dUR(d)((xn)n∈ω, (yn)n∈ω) =

0
if xn = yn for all n,
max(xn, yn)
if n is least such that x(n) ̸= y(n).
Suppose that X = (X, d) is a perfect ultrametric Polish space and choose a closed
subspace Y of (UR(d), dUR(d)) such that Y = (Y, dUR(d)) is isometric to X. Let S(Y) =
{y ↾n | y ∈Y, n ∈ω}, and set D(s) = {r ∈R+ | ∃x ∈ω(R(d)∪{0}) (s⌢r⌢x ∈Y)}
for each s ∈S(Y). Notice that S(Y) and D(s) are countable since R(d) is countable.
If there is a strictly increasing sequence (rn)n∈ω in D(s) for some s ∈S(Y), then
we obtain an honest increasing sequence in R(d) from the assumption that (X, d) is
perfect. If there is no honest increasing sequence in R(d), it follows that the order
type of each D(s) is α∗
s for some countable ordinal αs.
Finally, we want to show that, even if by Theorem 32 it is possible that the L(d)-
hierarchy Deg∆1
1(L(d)) on Borel subsets of a given ultrametric Polish space X =
(X, d) with bounded diameter is very bad, a natural (modest) strengthening of the
preorder ≤L(d) already yields to a semi-linearly ordered hierarchy.
Deﬁnition 44. Suppose X = (X, d) is an ultrametric Polish space, and let A, B ⊆
X. Let us write A ≤Lip(d,L) B if there is a Lipschitz function f : (X, d) →(X, d) with
constant L ∈R+ such that A = f −1(B). We say that A is almost nonexpansive
reducible to B (A ≤aL(d) B in symbols) if A ≤Lip(d,L) B for every 1 < L ∈R+.
Notice that the relation ≤aL(d) is a preorder (for the transitivity use the fact that
if f , g: X →X are Lipschitz functions with constant L, L′, respectively, then g ◦f
is Lipschitz with constant L · L′). Moreover, ≤aL(d) is strictly between ≤L(d) and
≤Lip(d). Even if literally ≤aL(d) is not of the form ≤F for some reducibility F on
X, with a little abuse of notation and terminology we can nevertheless consider
the aL(d)-hierarchy on (Borel subsets of) X, the Semi-Linear Ordering principle
SLOaL(d), and so on (with the obvious deﬁnitions).

Lipschitz and Uniformly Continuous Reducibilities
|
243
Proposition 45. Let X = (X, d) be an ultrametric Polish space with bounded di-
ameter. Then the aL(d)-hierarchy on the Borel subsets of X is semi-linearly ordered,
and hence not bad.
Proof. Given L > 1, let dL : X × X →R+ be deﬁned by dL(x, y) = min({Ln |
d(x, y) ≤Ln and n ∈Z}) if x, y ∈X are distinct, and by dL(x, y) = 0 if x = y ∈
X. Then dL is a complete ultrametric on X compatible with the metric topology
τd, and since we assumed that X has bounded (d-)diameter we also have that
R(dL) ⊆{Ln | n ∈Z} is either ﬁnite, or a decreasing sequence converging to 0. By
Theorem 37, this means that the L(dL)-hierarchy on Borel subsets of X is very good,
and hence, in particular, semi-linearly ordered. Moreover, id: (X, d) →(X, dL) is
Lipschitz with constant L, while id: (X, dL) →(X, d) is nonexpansive. Hence for
all subsets A, B of X:
–
if A ≤Lip(d,L′) B, then A ≤Lip(dL,L·L′) B;
–
if A ≤Lip(dL,L′) B, then A ≤Lip(d,L·L′) B.
In particular, A ≤L(dL) B implies that A ≤Lip(d,L) B.
We claim SLOaL(d) holds for Borel subsets of X. By the observation above and
SLOLip(dL), for every ﬁxed L > 1 we have that either A ≤Lip(d,L) B or B ≤Lip(d,L) ¬A.
If for every n ∈ω there is 1 < L ≤1 + 2−n such that A ≤Lip(d,L) B, then A ≤aL(d) B.
Similarly, if for every n ∈ω there is 1 < L ≤1 + 2−n such that B ≤Lip(d,L) ¬A,
then B ≤aL(d) ¬A. Since one of the two possibilities necessarily occurs, we get
that either A ≤aL(d) B or B ≤aL(d) ¬A, as required.
5 Compact ultrametric Polish spaces
It is well-known that any continuous function between metric spaces is automati-
cally uniformly continuous as soon as its domain is compact (see e.g. [10, Propo-
sition 4.5]). In particular, this means that it does not make much sense to consider
the UCont(d)-hierarchy on a compact ultrametric Polish space X = (X, d): since it
coincide¹⁵ with the W(X)-hierarchy on X, its restriction to the Borel sets is always
very good by Proposition 2. However, one may wonder about the character of the
Lip(d)- and the L(d)-hierarchy on (Borel subsets of) such an X: the next results
show that they must always be very good as well.
15 In fact in the speciﬁc case of the Cantor space C = (ω2, ¯dC) one can check that, although
Lip(¯dC) ⊊UCont(¯dC), the Lip(¯dC)- and the UCont(¯dC)-hierarchies coincide.

244
|
Luca Motto Ros and Philipp Schlicht
Proposition 46. Let X = (X, d) be a compact ultrametric Polish space. Then either
X (and hence also R(d)) is ﬁnite, or else R(d) is a strictly decreasing (ω-)sequence
converging to 0. In particular, X has bounded diameter.
Proof. It is clearly enough to show that for every ¯r ∈R+, the set R(d)≥¯r = {r ∈
R(d) | r ≥¯r} is ﬁnite. To see this, observe that the family B = {Bd(x, ¯r) | x ∈X} is
a ﬁnite covering of X because X is compact. Assume towards a contradiction that
R(d)≥¯r is inﬁnite, let (rn)n∈ω be an enumeration without repetitions of it, and let
(xn)n∈ω and (yn)n∈ω be such that d(xn, yn) = rn for every n ∈ω. Since B is ﬁnite,
there are distinct n, m ∈ω such that d(xn, xm), d(yn, ym) < ¯r. Since rm ≥¯r, we
get that rn = d(xn, yn) = d(xm, ym) = rm, contradicting the choice of the rn’s.
Theorem 47. Let X = (X, d) be a compact ultrametric Polish space. Then both the
L(d)- and the Lip(d)-hierarchy on Borel subsets of X are very good.
Proof. Use Proposition 46 together with Theorems 37 and 16.
In particular, we cannot change the ultrametric on the Cantor space ω2 to make
its nonexpansive or its Lipschitz hierarchy (very) bad: if d′ is any complete ultra-
metric compatible with the product topology on ω2, then both the Lip(d′)- and the
L(d′)-hierarchy on Borel subsets of ω2 are very good.¹⁶
Remark 48. Albeit Theorem 47 shows that there is no compact ultrametric Polish
space X = (X, d) with a (very) bad Lip(d)- or L(d)-hierarchy, Corollaries 25 and 33
shows that there are Kσ-spaces¹⁷ Xi = (Xi, di), i = 0, 1, such that:
–
both Deg∆0
1(L(d0)) and Deg∆0
1(Lip(d0)) are very bad;
–
Deg∆0
1(L(d1)) is very bad, while Deg∆1
1(Lip(d1)) is very good.
Let us now concentrate on the Cantor space C = ω2, and let us brieﬂy consider an-
other kind of reducibility that was analyzed in [15] for the case of the Baire space,
namely the collection of all contraction mappings.
Notation 49. Let ¯d = ¯dC be the usual metric on the Cantor space. We denote by
c(¯d) the collection of all contractions from C into itself, i.e. of all Lipschitz functions
f : C →C with constant strictly smaller than 1.
16 However, analogously to [15, Section 5] it is still possible to deﬁne compatible complete ul-
trametrics di, i = 0, 1, on C = ω2 so that L(¯dC) ̸⊆Lip(d0) (hence also L(¯dC) ̸⊆L(d0)), while
L(¯dC) ̸⊆L(d1) but Lip(¯dC) = Lip(d1).
17 A topological space is Kσ if it is the union of countably many compact subsets.

Lipschitz and Uniformly Continuous Reducibilities
|
245
Given two sets A, B ⊆C, set
A ≤c(¯d) B ⇐⇒A = B ∨∃f ∈c(¯d) (A = f −1(B)).
In fact, ≤c(¯d) = ≤F, where F is the reducibility on C obtained by adding the identity
id = idC to the set c(¯d).
Using the methods developed in [15, Section 4], it is easy to check that the follow-
ing hold:
Theorem 50. Let A, B be Borel subsets of C.
1. If A ̸≡L(¯d) B, then A ≤c(¯d) B
⇐⇒
A ≤L(¯d) B, while if A ≡L(¯d) B, then
A ≤c(¯d) B ⇐⇒A ≰L(¯d) ¬A.
2. A is selfcontractible (i.e. A = f −1(A) for some f ∈c(¯d)) if and only if A ≰L(¯d)
¬A.
3. If A ≰L(¯d) ¬A, then [A]c(¯d) = [A]L(¯d), while if A ≤L(¯d) ¬A, then [A]c(¯d) = {A}.
4. A <c(¯d) B ⇐⇒A <L(¯d) B.
Therefore, to describe the c(¯d)-hierarchy on Borel subsets of C it is enough to deter-
mine how many sets are contained in each L(¯d)-degree of an L(¯d)-selfdual Borel
subset of C, and to combine this information with the well-known description of
the L(¯d)-hierarchy on Borel subsets of C (see [3]). Let us ﬁrst brieﬂy describe this
last hierarchy. First of all, the hierarchy is semi-well-ordered. At the bottom we
found the L(¯d)-nonselfdual pair constituted by [C]L(¯d) = {C} and [∅]L(¯d) = {∅}.
Immediately after each L(¯d)-nonselfdual pair {[A]L(¯d), [¬A]L(¯d)} there is the L(¯d)-
degree of the L(¯d)-selfdual set A ⊕¬A = (0⌢A) ∪(1⌢(¬A)) = {0⌢x | x ∈
A} ∪{1⌢x | x ∈¬A}. On the other hand, if A is L(¯d)-selfdual, then immediately
after [A]L(¯d) there is the L(¯d)-degree of the selfdual set 0⌢A = {0⌢x | x ∈A}. Fi-
nally, at all limit level there is always an L(¯d)-nonselfdual pair. Therefore we get
the structure represented in Figure 1, where bullets represent L(¯d)-degrees and
each L(¯d)-degree is L(¯d)-reducible to another one if and only if it is (strictly) to the
left of it.
Notice that the ﬁrst ω-chain of consecutive L(¯d)-selfdual degrees contains all
nontrivial clopen sets, while the ﬁrst non-trivial L(¯d)-nonselfdual pair is formed
by all proper open and proper closed subsets of C.
To compute the cardinality of a given [A]L(¯d) (for A ⊆C), recall ﬁrst that if
∅, C ̸= A is clopen, then there is 0 ̸= n ∈ω, called the level of A such that A ≡L(¯d)
N0(n), where for an arbitrary s ∈<ω2 we set Ns = {x ∈C | s ⊂x} — in fact A is
in the n-th L(¯d)-selfdual degree of the ﬁrst ω-chain of consecutive L(¯d)-selfdual
degrees if and only if it is of level n.

246
|
Luca Motto Ros and Philipp Schlicht
•
• • • · · ·



ω
• • • · · ·



ω
• • • · · ·



ω
· · · · · ·
• • • · · ·



ω
· · · · · ·
•
•
•
•
↑
clopen sets
↑
limit levels
Fig. 1: The L(¯d)-hierarchy on Borel subsets of C.
Proposition 51. Let ∅, C ̸= A ⊆C.
1. if A is clopen, then [A]L(¯d) contains exactly 22n −22n−1-many sets, where n is the
level of A;
2. if A is not clopen, then there is an injection j: C →[A]L(¯d).
Proof. For each 0 ̸= n ∈ω, the collection of all clopen sets L(¯d)-reducible to N0(n)
consists of all the sets of the form 
s∈S Ns for S a subset of {s ∈<ω2 | lh(s) = n}:
therefore there are 22n-many such sets. So if A is a clopen set of level n, then
to compute the cardinality of [A]L(¯d) we have to subtract to 22n the number of
sets which are not L(¯
d)-reducible to
d)-equivalent to N0(n), i.e. ∅, C, and all sets L(¯
N0(n−1): since there are 22n−1-many such sets, we get that [A]L(¯d) contains exactly
22n −22n−1-many sets.
For the second part, let us ﬁrst assume that A ≰L(¯d) ¬A. If A is a proper open
set, then the map j: C →[A]L(¯d) : x →C \ {x} is as required. Therefore we can
assume without loss of generality that B ≤L(¯d) A for every proper closed set B. By
Theorem 50(2), there is f ∈c(¯d) such that f −1(A) = A. Let i = 0, 1 be such that
f(C) ⊆N⟨i⟩, and consider the map
j: C →[A]L(¯d) : x →Ax = (A ∩N⟨i⟩) ∪{(1 −i)⌢x}.
Clearly j is an injection, so it remains only to show that A ≡L(¯d) Ax for every x ∈C.
For one direction, f witnesses A ≤L(¯d) Ax. For the other direction, let gx ∈L(¯d)
be a reduction of {(1 −i)⌢x} to A: then (idC ↾N⟨i⟩) ∪(gx ↾N⟨(1−i)⟩) witnesses
Ax ≤L(¯d) A.
Finally, let A be L(¯d)-selfdual. Since by case assumption A is not clopen, there
is an L(¯d)-nonselfdual B ̸= ∅, C and n ∈ω such that A ≡L(¯d) 0(n)⌢(B ⊕¬B). Let
j′ : C →[B]L(¯d) be an injective map: then
j: C →[A]L(¯d) : x →0(n)⌢(j′(x) ⊕¬j′(x))
is clearly as required.
•
•
•

Lipschitz and Uniformly Continuous Reducibilities
|
247
Since by Theorem 50 the c(¯d)-hierarchy on Borel subsets of C is the reﬁnement of
the L(¯d)-hierarchy obtained by splitting each L(¯d)-selfdual degree into the single-
tons of its elements, using Proposition 51 we can represent such hierarchy as in
Figure 2, where the bullets represent the c(¯d)-degrees and the boxes around them
represent the L(¯d)-degrees they come from (notice that by Proposition 51(1) in the
second column there are 12 diﬀerent c(¯d)-degrees, while in the third column we
already ﬁnd 240 distinct c(¯d)-degrees!).
•
•
•
•
•
...
•
•
...
•
•
...
•
•
•
•
...
•
. . .



ω
•
•
...
•
•
•
•
•
•
•
•
...
...
•
•
•
•
•
•
•
•
...
...
•
•
•
•
•
•
•
•
...
. . .



ω
•
•
. . . . . .
Fig. 2: The c(¯d)-hierarchy on Borel subsets of C.
Proposition 51 and Theorem 50 also imply the following corollary.
Corollary 52.
(1) The c(¯d)-hierarchy Deg∆1
1(c(¯d)) on Borel subsets of C is bad but not very bad.
In fact it contains antichains of size the continuum.
(2) The c(¯d)-hierarchy DegΣ0
1∪Π0
1(c(¯d)) on open or closed subsets of C is good but
not very good.
Notice that Corollary 52(2) gives a partial answer to [15, Question 6.3]. However,
such solution is not completely satisfactory, as we needed to restrict our hierarchy
to a very small class of subsets of C — of course it would be more interesting to
ﬁnd a reducibility F (on some Polish space X) inducing a good but not very good
hierarchy on the entire collection of Borel subsets of X (or, under AD, even on
the entire P(X)). This last problem seems to be completely open, but the next
example shows that if the requirement that the preorder inducing the hierarchy

248
|
Luca Motto Ros and Philipp Schlicht
be of the form ≤F (for some reducibility F on X) is dropped, then one can obtain a
“natural” hierarchy on the collection of all Borel subsets of ωω which is good but
not very good .
Example 53. Given a set R ⊆R+ and A, B ⊆ωω such that A ≤Lip(¯d) B, let LA,B =
inf{0 < L ∈R+ | A ≤Lip(¯d,L) B}, where ≤Lip(¯d,L) is as in Deﬁnition 44. Then set
A ≤R B ⇐⇒A ≤Lip(¯d) B ∧LA,B ∈R ∪{0, 1}.
Notice that ≤R is always reﬂexive: in fact, either A ≰Lip(¯d,L) A for all L < 1 (in which
case the identity function witnesses LA,A = 1), or else by considering arbitrarily
large powers of any witness of A ≤Lip(¯d),L A (for some L < 1) we see that LA,A = 0.
In contrast, notice that in general ≤R need not to be transitive. However, when ≤R
actually happens to be a preorder (as in all the relevant cases considered below),
then with a little abuse of terminology we can consider the ≤R-hierarchy on Borel
subsets of ωω (with the obvious deﬁnition).
Using the methods introduced at the end of [15, Section 4], it is easy to see that
if A, B ⊆ωω are Borel sets such that A <Lip(¯d) B, then also A <R B, because in this
case LA,B = 0. Moreover, since by [15, Corollary 4.4] if A ⊆ωω is Lip(¯d)-nonselfdual
(equivalently: L(¯d)-nonselfdual), then A ≤Lip(¯d,L) A for every L > 0, we get that
for such an A, A ≤L(¯d) B ⇒A ≤R B for every B ⊆ωω, and if R ⊆(0, 1] we in
fact have that A ≤L(¯d) B
⇐⇒
A ≤R B. Finally, if A ⊆ωω is L(¯d)-selfdual and
B ∈[A]L(¯d), then A ≡R B because [15, Proposition 4.2] implies that all the witnesses
of A ≤L(¯d) B and B ≤L(¯d) A cannot have Lipschitz constant < 1. Summing up, we
get that if R ⊆(0, 1] (and ≤R is transitive), then the ≤R-hierarchy reﬁnes the L(¯d)-
hierarchy, and may diﬀer from it only within the Lip(¯d)-selfdual degrees.
Let us now concentrate on the canonical examples given by Rn = (0, 2−n] (for
n ∈ω). It is easy to check that if n ≤1, then the ≤R-hierarchy coincides with the
L(¯d)-hierarchy. However, if n > 1 and A is an L(¯d)-selfdual set, then
A ≤Rn B ⇐⇒A ≤L(¯d) B ∧(B ≡L(¯d) A ∨0(n)⌢A ≤L(¯d) B).
(†)
Therefore the restriction of ≤Rn to the Borel subsets of ωω is always transitive
(hence a preorder), and it is also well-founded. Moreover, (†) also implies that the
antichains in ≤R have always size ≤n. Since e.g. {0(i+1)⌢ωω | i < n} is an ≤Rn-
antichain of size precisely n consisting of clopen sets, we get that for all n ≥3 the
≤Rn-hierarchy on Borel subsets of ωω is good but not very good.

Lipschitz and Uniformly Continuous Reducibilities
|
249
6 Wadge-like reducibilities and the Axiom of
Choice
By (the comment following) Proposition 2, the L(¯d)-hierarchy Deg∆1
1(L(¯d)) on the
Borel subsets of ωω is very good, and as already recalled the same is true for larger
classes of subsets of ωω if we further assume corresponding determinacy axioms.
It is therefore natural to ask what happens if, instead of assuming such determi-
nacy principles, we assume the Axiom of Choice AC or other strong choice princi-
ples.
Similar considerations apply to arbitrary Polish spaces as well. It is shown
in [18] that for every non-zero-dimensional Polish space X the W(X)-hierarchy
on Borel subsets of X already contains antichains of size the continuum, and
in fact [9] shows that if e.g. X = R then we can also embed (P(ω), ⊆∗) into
Deg∆1
1(W(X)) (but this last result cannot be extended to arbitrary X: as explained
in [16, Section 5.1], all continuous functions on the Cook continuum X are either
constant or the identity, and therefore all chains of subsets of X with respect to
continuous reducibility have length ≤2). However, [16] shows that for every Pol-
ish space X, the Dα(X)-hierarchy on Borel subsets of X (where Dα(X) denotes the
collection of all ∆0
α-functions from X to itself) is always very good for α ≥ω, and
that the same is true for α ≥3 if X is of dimension ̸= ∞. Also these last results
extend to larger classes of subsets of X under suitable determinacy assumptions,
and therefore it is meaningful to ask what happens if instead we assume AC.
Not surprisingly, it turns out that under choice all the above mentioned hi-
erarchies of degrees (on arbitrary subsets of X) become very bad. Clearly, Borel
determinacy forces us to consider non-Borel subsets of X to get such results: there-
fore in what follows we will concentrate only on uncountable (ultrametric) Polish
spaces.
Notation 54. If X is a set and A ⊆X2, we denote by Ax the “vertical section” deter-
mined by x ∈X, i.e. we set Ax = {y ∈X | (x, y) ∈A}. Moreover, for every cardinal
µ we set [X]µ = {Y ⊆X | |Y| = µ}.
Lemma 55 (AC). Let µ be an inﬁnite cardinal and X be a set of size µ. Moreover,
let C ⊆[X]µ, F be a collection of functions from X to itself, and suppose that |C| =
|F| = µ. Then there is a set A ⊆X2 such that Ax ∩C ≰F Ay for all distinct x, y ∈X
and all C ∈C.

250
|
Luca Motto Ros and Philipp Schlicht
Proof. We ﬁrst recursively construct a sequence ({Ax,α, Bx,α | x ∈X})α<µ such
that Ax,α ∩Bx,α = ∅, Ax,α ⊆Ax,β, Bx,α ⊆Bx,β, and |Ax,α ∪Bx,α| ≤|2 · α| for all
α ≤β < µ and x ∈X.
Fix a surjection h: µ →C × F × X2, and set Ax,0 = Bx,0 = ∅for all x ∈X.
Let now 0 < α < µ, and assume that all sets of the form Ax,β, Bx,β for x ∈X and
β < α have already been deﬁned, so that we can set Ax,<α = 
β<α Ax,β and Bx,<α =

β<α Bx,β. Let (C, f , x, y) ∈C × F × X2 be such that h(α) = (C, f , x, y), and let
C0 = C\(Ax,<α∪Bx,<α). Notice that |C0| = µ because |Ax,<α∪Bx,<α| < µ and |C| = µ.
We distinguish two cases: if |f(C0)| < µ, we choose distinct a, b ∈C0 such that
f(a) = f(b) (this is possible because |C0| = µ > |f(C0)|), and then we set Ax,α =
Ax,<α ∪{a}, Bx,α = Bx,<α ∪{b}, and Az,α = Az,<α, Bz,α = Bz,<α for all z ∈X distinct
from x. If instead |f(C0)| = µ, we pick some a ∈C0 with f(a) /∈Ay,<α∪By,<α (which
exists because |Ay,<α ∪By,<α| < µ, and hence f(C0) \ (Ay,<α ∪By,<α) ̸= ∅), and then
we set Ax,α = Ax,<α ∪{a}, Bx,α = Bx,<α, Ay,α = Ay,<α, By,α = By,<α ∪{f(a)}, and
Az,α = Az,<α, Bz,α = Bz,<α for all z ∈X distinct from x and y. This completes the
recursive step of our construction, and it is easy to check by induction on α < µ
that the sets Ax,α, Bx,α are as required.
Finally, we set Ax = 
α<µ Ax,α, Bx = 
α<µ Bx,α, and A = {(x, y) ∈X2 | y ∈
Ax}, so that, in particular, Ax ∩Bx = ∅for every x ∈X. It is straightforward to
check that the α-th step in the recursive construction above ensures that f is not a
reduction of Ax ∩C to Ay, because either there are a ∈Ax ∩C and b ∈Bx ⊆X \ Ax
such that f(a) = f(b), or else there is a ∈Ax ∩C such that f(a) ∈By ⊆X \Ay.
Theorem 56 (AC). Let X = (X, d) be an uncountable ultrametric Polish space.
Then there is a map ψ: P(ω) →P(X) such that for all a, b ⊆ω
1. if a ⊆b, then ψ(a) ≤L(d) ψ(b);
2. if ψ(a) ≤Bor(X) ψ(b), then a ⊆b.
In particular, (P(ω), ⊆) embeds into the F-hierarchy on X for every reducibility
L(d) ⊆F ⊆Bor(X), hence Deg(F) is very bad.
Proof. We apply the Lemma 55 letting µ = |X| = 2ℵ0, C be the set of all uncount-
able Borel subsets of X, and F = Bor(X) be the collection of all Borel functions
from X to itself. Thus we obtain a sequence of ≤Bor(X)-incomparable sets An ⊆X
(the lemma gives more, but an ω-sequence is suﬃcient here). Notice that each An
is necessarily uncountable and that An ̸= X, as otherwise in both cases we would
easily have An ≤Bor(X) Am for every m ∈ω. Now choose a sequence (Xn)n∈ω
of pairwise disjoint uncountable clopen balls in X, and ﬁx a Borel isomorphism
hn : X →Xn for every n ∈ω. Given a ⊆ω, set ψ(a) = 
n∈a hn(An).
To see that ψ is as required, ﬁrst suppose that a, b ⊆ω are such that a ⊆b,
and for every n ∈b\a pick a point yn ∈Xn\hn(An) (which exists because An ̸= X).

Lipschitz and Uniformly Continuous Reducibilities
|
251
Then we deﬁne f : X →X by setting
f(x) =

yn
if x ∈Xn for some n ∈b \ a,
x
otherwise.
Clearly f reduces ψ(a) to ψ(b), and it is easy to check that since d is an ultramet-
ric and the Xn are (cl)open balls, then f ∈L(d): therefore ψ(a) ≤L(d) ψ(b), as
required.
Now let a, b ⊆ω be such that ψ(a) ≤Bor(X) ψ(b), let f ∈Bor(X) be a witness
of this, and ﬁx an arbitrary n ∈a. Notice that f(ψ(a)) ⊆ψ(b) ⊆
m∈b Xm. Since
An is uncountable, this means that there is m ∈b such that f −1(Xm) ∩Xn is
uncountable. Fix ¯y ∈X \ Am: setting C = h−1
n (f −1(Xm) ∩Xn), we get that C is
an uncountable Borel set, and that the map g: X →X deﬁned by
g(x) =

(h−1
m
◦f ◦hn)(x)
if x ∈C,
¯y
otherwise
witnesses An∩C ≤Bor(X) Am. By our choice of the An’s, this implies n = m, whence
n ∈b. Therefore a ⊆b, as required.
Remark 57. Notice that to get Lemma 55 it is enough to assume that X is a well-
orderable set. Therefore, also in Theorem 56 we can weaken the assumption AC by
just requiring that X (equivalently, any uncountable Polish space) is well-orderable.
Using essentially the same argument, one can also show that a variant of Theo-
rem 56 applies to arbitrary uncountable Polish spaces X (and not only to the ultra-
metric ones).
Theorem 58 (AC). Let X be an uncountable Polish space. Then there is a map
ψ: P(ω) →P(X) such that for every a, b ⊆ω
1. if a ⊆b, then ψ(a) ≤D2(X) ψ(b);
2. if ψ(a) ≤Bor(X) ψ(b), then a ⊆b.
In particular, (P(ω), ⊆) embeds into the F-hierarchy on X for every reducibility
D2(X) ⊆F ⊆Bor(X), hence Deg(F) is very bad.
Proof. In the proof of Theorem 56, let (Xn)n∈ω be a partition of X into uncountable
∆0
2 sets.
Remark 59. In Theorem 58 we cannot replace ≤D2(X) with continuous reducibility
≤W(X): in fact, in the Cook continuum X (which is uncountable), we cannot hope to
embed (P(ω), ⊆) into Deg(W(X)) because there are no inﬁnite chains of subsets of
X (with respect to continuous reducibility).

252
|
Luca Motto Ros and Philipp Schlicht
We now aim to show that if we further assume V = L, then the map ψ of Theo-
rems 56 and 58 can be chosen to range in the collection of Π1
1 (alternatively: Σ1
1)
subsets of the given (ultrametric) Polish space: this in particular implies that the
L(¯d)-hierarchy on Π1
1 (respectively, Σ1
1) subsets of ωω is very bad in L. To prove this,
we will modify the recursion used in the proof of Lemma 55 so that membership
in each of the sets can be computed in the next admissible set.
Notation 60. For x, y ∈ωω, let ωx,y
1
denote the least (x, y)-admissible ordinal γ.¹⁸
To simplify the notation, set also ωx
1 = ωx,x
1 .
Theorem 61 (Spector-Gandy). (see [8, Theorem 5.5]) A set A ⊆ωω is Π1
1 in a pa-
rameter p ∈ωω if and only if there is a Σ1-formula φ(x) such that
x ∈A ⇔Lωx,p
1 [x, p] ⊨φ(x, p)
for all x ∈ωω.
Lemma 62. Let X be a Polish space. Then there is a set G ⊆ωω × X2 such that:
1. A set F ⊆X2 is the graph of a Borel function from X to itself if and only if
F = Gx = {(y, z) ∈X2 | (x, y, z) ∈G} for some x ∈p(G).
2. The projection p(G) on the ﬁrst coordinate is a Π1
1 set.
3. G is both Π1
1 and Σ1
1 on p(G) × X2.
Sketch of proof. Notice that we can concentrate only on ultrametric Polish spaces
X = (X, d), because the result can then be transferred to an arbitrary Polish space
Y by using a Borel isomorphism between X and Y. Therefore from now on we ﬁx an
ultrametric Polish space X = (X, d). Recall that Bor(X) coincides with the collec-
tion of all Baire class α functions (for arbitrary α < ω1), i.e. with the closure under
pointwise limits of the collection of all Lipschitz functions (see [12, Corollary 2.16]
and [10, Theorems 24.3]). Starting with a function f deﬁned on a ﬁxed countable
dense set D ⊆X, we form the (pseudo-)limit ¯f of f by setting ¯f(x) = limn→∞f(xn)
(for an arbitrary sequence (xn)n∈ω in D with limn→∞xn = x) if
oscf (x) = lim
n→∞sup{d(f(y), f(z)) | y, z ∈X ∧d(x, y), d(x, z) < 2−n} = 0,
and ¯f(x) = y0 (for y0 ∈X a ﬁxed value) otherwise. From a countable family of
functions f as above attached to the terminal nodes of a given well-founded tree,
we can then build up a Borel function g by forming (pseudo-)limits (i.e. taking
the pointwise limit where it exists and some ﬁxed value y0 ∈X elsewhere) in the
18 That is, ωx,y
1
is the least γ > ω such that Lγ[x, y] is a model of Kripke-Platek set theory.

Lipschitz and Uniformly Continuous Reducibilities
|
253
obvious way along the tree. The tree is then coded into an element of x ∈ωω,
and for all x’s built in this way we let Gx be the graph of the corresponding Borel
function g. Notice that the set of codes is Π1
1 because of the condition that the trees
used in the coding are well-founded.
Theorem 63. Assume V = L and let X = (X, d) be an uncountable ultrametric Pol-
ish space. Then there is a map ψ from P(ω) into the Π1
1 subsets of X such that for
all a, b ⊆ω
1. if a ⊆b, then ψ(a) ≤L(d) ψ(b);
2. if ψ(a) ≤Bor(X) ψ(b), then a ⊆b.
In particular, (P(ω), ⊆) embeds into the F-hierarchy on the Π1
1 subsets of X for
every reducibility L(d) ⊆F ⊆Bor(X), hence DegΠ1
1(F) is very bad.
Proof. Let Nt = {x ∈ωω | t ⊆x} for t ∈<ωω. We ﬁrst assume that (X, d) =
(ωω, ¯d). The map ψ: P(ω) →P(ωω) is deﬁned by ﬁrst constructing a Π1
1 set
A ⊆P(ω) × ωω,¹⁹ and then letting ψ(a) = Aa = {y ∈ωω | (a, y) ∈A}. To
deﬁne the desired A, we will in turn construct by recursion on α < ω1 a sequence
(An,α, Bn,α)n<ω,α<ω1 such that for all n < ω and α ≤β < ω1
1. An,α, Bn,α ⊆N⟨n⟩,
2. An,α ∩Bn,α = ∅,
3. |An,α|, |Bn,α| < ω1, and
4. An,α ⊆An,β and Bn,α ⊆Bn,β.
Given a ⊆ω, we then let for n < ω and γ < ω1
Aa,α =

n∈a An,α,
Ba,α =

n∈a Bn,α,
An,<γ =

α<γ An,α,
Bn,<γ =

α<γ Bn,α,
Aa,<γ =

α<γ Aa,α,
Ba,<γ =

α<γ Ba,α,
and ﬁnally we set
An =

α<ω1 An,α,
Bn =

α<ω1 Bn,α,
Aa =

n∈a An,
Ba =

n∈a Bn.
19 We freely identify each a ∈P(ω) with its characteristic function in ω2. The notions of Π1
1
subsets of P(ω) and P(ω) × ωω are deﬁned accordingly. Since the identiﬁcation is computable,
the Spector-Gandy Theorem 61 holds for Π1
1 subsets of P(ω) × ωω.

254
|
Luca Motto Ros and Philipp Schlicht
Notice that by (1), (2) and (4), we have that for all a ⊆ω and γ < ω1, Aa,<γ ∩
Ba,<γ = ∅and Aa ∩Ba = ∅. Finally, to simplify the notation we will also write
sγ = (An,α, Bn,α)n<ω,α<γ for γ < ω1.
The construction is based on the following claims.
Claim 64. For every s ∈Lω1 and l < ω, there are uncountably many x ∈N⟨l⟩with
s ∈Lωx
1.
Proof. Let α < ω1 and x ∈N⟨l⟩be such that s ∈Lα and ωx
1 > α. Then ωx,y
1
> α for
all y ∈ωω, so s ∈Lωx⊕y
1
for any y ∈ωω (where x⊕y is deﬁned by (x⊕y)(2i) = x(i)
and (x ⊕y)(2i + 1) = y(i)).
Let An,0 = Bn,0 = ∅. Let now γ > 0, and suppose that the γth element in <L is
of the form (c, a, b, l), where c ∈ωω is a code for a Borel measurable function
f : ωω →ωω as in Lemma 62, a, b ⊆ω, and l ∈a \ b (if this is not the case, we
simply let An,γ = An,<γ and Bn,γ = Bn,<γ for all n ∈ω).
Claim 65. There is x ∈N⟨l⟩such that sγ ∈Lωx
1[x] and x /∈Al,<γ ∪Bl,<γ.
Proof. Let W ⊆ωω denote the set of x ∈ωω with sγ ∈Lωx
1[x]. Since W ∩N⟨l⟩is
uncountable by Claim 64 and Al,<γ ∪Bl,<γ is countable by (3), there is x ∈(W ∩
N⟨l⟩) \ (Al,<γ ∪Bl,<γ), as required.
Let ¯x ∈ωω denote the <L-least element satisfying Claim 65. If f(¯x) ∈Ab,<γ, let
Bl,γ = Bl,<γ∪{¯x}. If f(¯x) ∈Bb,<γ, let Al,γ = Al,<γ∪{¯x}. Finally, if f(¯x) /∈Ab,<γ∪Bb,<γ
and f(¯x)(0) = m, let Al,γ = Al,<γ ∪{¯x}, and if additionally m ∈b, then let Bm,γ =
Bm,<γ∪{f(¯x)}. For all remaining An,γ’s and Bn,γ’s, let An,γ = An,<γ and Bn,γ = Bn,<γ.
Note that if f(¯x) /∈Ab,<γ ∪Bb,<γ and m ∈b, then f(¯x) /∈Am,<γ. This completes the
construction of the An,α’s and Bn,α’s, and hence also of the sets Aa and Ba for
a ⊆ω.
Claim 66. If a ⊆b ⊆ω, then Aa ≤L(¯d) Ab.
Proof. Let f(z) = z for all z ∈N⟨l⟩with l ∈a ∪(ω \ b), while for z ∈N⟨l⟩with
l ∈b \ a, ﬁx z0 /∈Ab and let f(z) = z0. Clearly f ∈L(¯d). The result then follows
from the fact that Aa ∩N⟨l⟩= Al ⊆N⟨l⟩for l ∈a and Aa ∩N⟨l⟩= ∅otherwise (and
similarly for a replaced by b).
Claim 67. If a ̸⊆b, then Aa ̸≤Bor(ωω) Ab.
Proof. Suppose that f : ωω →
ωω is a Borel measurable function with Aa =
f −1(Ab). Fix l ∈a \ b, and let c and γ be such that c codes f as in Lemma 62
and (c, a, b, l) is the γth element in <L. Suppose that in step γ of the construction,
¯x ∈ωω is the <L-least pair in Claim 65. If f(¯x) ∈Ab,<γ, then ¯x ∈Bl ⊆Ba and
f(¯x) ∈Ab. Then ¯x /∈Aa because Aa ∩Ba = ∅, and hence Aa ̸= f −1(Ab). If

Lipschitz and Uniformly Continuous Reducibilities
|
255
f(¯x) ∈Bb,<γ, then ¯x ∈Al ⊆Aa and f(¯x) ∈Bb. Then Aa ̸= f −1(Ab) because
Ab ∩Bb = ∅. Finally, suppose that f(¯x) /∈Ab,<γ ∪Bb,<γ and f(¯x)(0) = m. Then
¯x ∈Al ⊆Aa. If m /∈b, then f(¯x) /∈Ab because Ab ∩N⟨m⟩= ∅. If m ∈b, then
f(¯x) ∈Bm ⊆Bb, so f(¯x) /∈Ab by Ab ∩Bb = ∅. So in both cases Aa ̸= f −1(Ab).
Note that the condition that (c, a, b, l) is of the required form is Π1
1 by Lemma 62.
Since the truth value of Π1
1 statements can be calculated in admissible sets by the
Spector-Gandy Theorem 61, this implies that the recursion is absolute between
(and deﬁnable over) admissible sets.
Let A = {(a, y) | y ∈Aa} ⊆P(ω) × ωω.
Claim 68. A is Π1
1.
Proof. We freely identify each a ⊆ω with its characteristic function, so that A can
be viewed as a subset of ωω × ωω. It is then suﬃcient to show that there is a Σ1
formula φ such that (x, y) ∈A if and only if Lωx,y
1 [x, y] ⊨φ(x, y) for all x, y ∈ωω,
by the Spector-Gandy Theorem 61. Let φl(y) state that there is some γ < ω1 and a
sequence s of length γ constructed according to the recursion such that y is added
to Al at step γ. Let φ(x, y) ⇐⇒∃l ∈x φl(y).
Suppose that (x, y) ∈A. Then y ∈Al ⊆Ax for some l ∈x. Suppose that y is
added to Al at step γ < ω1 in the construction. Then sγ ∈Lωy
1[y] by the deﬁnition
in the successor step. Then Lωx,y
1 [x, y] ⊨φl(y), and hence Lωx,y
1 [x, y] ⊨φ(x, y). Now
suppose that Lωx,y
1 [x, y] ⊨φ(x, y). Then Lωx,y
1 [x, y] ⊨φl(y) for some l ∈x. Since
the recursion is absolute between admissible sets, this implies that y ∈Ax and
hence (x, y) ∈A.
Now suppose that (X, d) is an arbitrary uncountable ultrametric Polish space. Fix
a sequence (Un)n∈ω of disjoint uncountable open balls. For each l ∈ω, ﬁx a Π0
2
proper subset Cl of Ul homeomorphic to ωω, together with a homeomorphism
hl : N⟨l⟩→Cl and a point xl ∈Ul \ Cl. Let h: ωω →X : x →hx(0)(x). Then
h: ωω →
l∈ω Cl is a homeomorphism and 
l∈ω Cl is a Borel subset of X. Finally,
let ψ(a) = h(Aa) for a ⊆ω.
Claim 69. If a ⊆b ⊆ω, then ψ(a) ≤L(d) ψ(b).
Proof. Let f(z) = z for all z ∈Cl with l ∈a ∪(ω \ b) and all z ∈X \ 
l∈ω Ul,
and let f(z) = xl for all z ∈Ul with l ∈b \ a. Then f : X →X is Lipschitz and
ψ(a) = f −1(ψ(b)).
Claim 70. If a ̸⊆b, then ψ(a) ̸≤Bor(X) ψ(b).
Proof. Suppose towards a contradiction that f : X →X is a Borel map reducing
ψ(a) to ψ(b). Since b ̸= ω by a ̸⊆b, there is y0 ∈(
l∈ω Cl) \ ψ(b). Let ¯f : X →X
by letting ¯f(x) = f(x) if f(x) ∈
l∈ω Cl and ¯f(x) = y0 otherwise: then ¯f : X →

256
|
Luca Motto Ros and Philipp Schlicht

l∈ω Cl is Borel and still reduces ψ(a) to ψ(b). Since the map h: ωω →
l∈ω Cl
is a homeomorphism, the function h−1 ◦¯f ◦h: ωω →ωω is a well-deﬁned Borel
function reducing Aa to Ab, contradicting Claim 67.
This completes the proof of Theorem 63.
Similar to Corollary 58, we now obtain:
Theorem 71. Assume V = L and let X be an uncountable Polish space. Then there
is a map ψ from P(ω) into the Π1
1 subsets of X such that for every a, b ⊆ω
1. if a ⊆b, then ψ(a) ≤D2(X) ψ(b);
2. if ψ(a) ≤Bor(X) ψ(b), then a ⊆b.
In particular, (P(ω), ⊆) embeds into the F-hierarchy on the Π1
1 subsets of X for
every reducibility D2(X) ⊆F ⊆Bor(X), hence DegΠ1
1(F) is very bad.
Proof. Deﬁne ψ as at the end of the proof of Theorem 63 (where the case of an
arbitrary ultrametric Polish space is considered). If a ⊆b ⊆ω, we deﬁne f : X →
X as in the proof of Claim 69: then f is clearly D2(X) and ψ(a) = f −1(ψ(b)). The
converse direction can be easily proved as in Claim 70, hence we are done.
The existence of maps ψ: P(ω) →Σ1
1(X) with the properties stated in Theo-
rems 63 and 71 follows immediately by taking complements, i.e. by setting ψ(a) =
X \ ψ(a) for every a ⊆ω (where ψ: P(ω) →Π1
1(X) is as in Theorem 63 or Theo-
rem 71).
Remark 72. By Borel determinacy, the requirement that ψ ranges into Π1
1 (alter-
natively: Σ1
1) subsets of X in Theorems 63 and 71 cannot be further improved, and
therefore such results are optimal.
It is well-known that Π1
1-determinacy implies that e.g. the L(¯d)-hierarchy on Π1
1
subsets of ωω is very good. In fact, Harrington [5] (essentially) showed that the
following are equivalent:
–
every Π1
1 subset of ωω is determined;
–
for all x ∈ωω, x# exists;
–
SLOL(¯d) holds for Π1
1 subsets of ωω.
Since sharps do not exist if V = L, Theorem 63 can then be regarded as a strength-
ening of (one direction) of the above mentioned Harrington’s result: under the
further assumption V = L, not only SLOL(¯d) for Π1
1 subsets of ωω does not hold,
but in fact we can embed a reasonably complicated partial order in DegΠ1
1(L(¯d)).
Notice also that since Deg∆1
1(L(¯d)) needs to be very good by Borel determinacy,

Lipschitz and Uniformly Continuous Reducibilities
|
257
Theorem 63 actually shows that if V = L, then (P(ω), ⊆) embeds into the L(¯d)-
hierarchy on proper Π1
1 subsets of ωω, and Theorem 71 shows that the same par-
tial order embeds also e.g. in the Bor(X)-hierarchy on proper Π1
1 (alternatively:
proper Σ1
1) subsets of any uncountable Polish space X. This conclusion consider-
ably strengthen the well-known fact that if Π1
1-determinacy fails then there are
proper Π1
1 subsets which are not (Borel-)complete for that class.
The next questions essentially asks if it is possible to further strengthen Theo-
rems 56 and 63 by either trying to embed a more complicated quasi-order into the
relevant hierarchies, or by weakening the assumption required for those results
to Π1
1-determinacy.
Question 73. Assume AC.
1. Is there a map ψ: P(ω) →P(ωω) such that a ⊆∗b ⇐⇒ψ(a) ≤Bor(ωω) ψ(b)
for all a, b ⊆ω?
2. Does the non-existence of 0# already imply that the Bor(ωω)-hierarchy on Π1
1
subsets of ωω is ill-founded?
Bibliography
[1]
A. Andretta and D. A. Martin. Borel-Wadge degrees. Fund. Math., 177:175–192, 2003.
[2]
A. Andretta. More on Wadge determinacy. Annals of Pure and Applied Logic, 144:2–32,
2006.
[3]
A. Andretta. The SLO principle and the Wadge hierarchy. Foundations of the formal sciences
V, Stud. Log. (Lond.), 11:1–38, 2007.
[4]
S. Gao and C. Shao. Polish ultrametric Urysohn spaces and their isometry groups. Topology
Appl., 158(3):492–508, 2011.
[5]
Leo Harrington. Analytic determinacy and 0♯. J. Symbolic Logic, 43(4):685–693, 1978.
[6]
P. Hertling. Topologische Komplexitätsgrade von Funktionen mit endlichem Bild.
Informatik-Berichte, 152, 1993.
[7]
P. Hertling. Unstetigkeitsgrade von Funktionen in der eﬀektiven Analysis. 1996. Ph.D.
Thesis, Fachbereich Informatik, FernUniversität Hagen.
[8]
G. Hjorth. Vienna notes on eﬀective descriptive set theory and admissible sets. available at
http://www.math.uni-bonn.de/people/logic/events/young-set-theory-2010/Hjorth.pdf,
2010.
[9]
D. Ikegami, P. Schlicht, and H. Tanaka. Continuous reducibility for the real line. Preprint,
submitted, 2012.
[10] A. S. Kechris. Classical Descriptive Set Theory. Number 156 in Graduate text in Mathematics.
Springer-Verlag, Heidelberg New York, 1995.
[11]
L. Motto Ros. Borel-amenable reducibilities for sets of reals. Journal of Symbolic Logic,
74(1):27–49, 2009.
[12] Luca Motto Ros. A new characterization of Baire class 1 functions. Real Anal. Exchange,
34(1):29–48, 2009.

258
|
Luca Motto Ros and Philipp Schlicht
[13] L. Motto Ros. Baire reductions and good Borel reducibilities. J. Symbolic Logic, 75(1):323–
345, 2010.
[14] L. Motto Ros. Beyond Borel-amenability: scales and superamenable reducibilities. Ann.
Pure Appl. Logic, 161(7):829–836, 2010.
[15]
L. Motto Ros. Bad Wadge-like reducibilities on the Baire space. preprint, submitted, 2012.
[16] L. Motto Ros, P. Schlicht, and V. Selivanov. Wadge-like reducibilities on arbitrary quasi-
Polish spaces. To appear on Mathematical Structures in Computer Science, 2012.
[17]
I. I. Parovičenko. A universal bicompact of weight ℵ. Dokl. Akad. Nauk SSSR, 150:36–39,
1963.
[18] P. Schlicht. Continuous reducibility and dimension. Preprint, submitted, 2012.
[19] V. L. Selivanov. Variations on the Wadge reducibility [Translation of Mat. Tr. 8 (2005), no.
1, 135–175]. Siberian Adv. Math., 15(3):44–80, 2005.
[20] V. L. Selivanov. Hierarchies of ∆0
2-measurable k-partitions. MLQ Math. Log. Q., 53(4-5):446–
461, 2007.
[21] V. L. Selivanov. On the Wadge reducibility of k-partitions. J. Log. Algebr. Program.,
79(1):92–102, 2010.
[22] F. van Engelen, A. W. Miller, and J. Steel. Rigid Borel sets and better quasi-order theory.
In Logic and combinatorics (Arcata, Calif., 1985), volume 65 of Contemp. Math., pages
199–222. Amer. Math. Soc., Providence, RI, 1987.
[23] R. A. Van Wesep. Wadge degrees and descriptive set theory. In Alexander S. Kechris and
Yiannis N. Moschovakis, editors, Cabal Seminar 76-77, number 689 in Lecture Notes in
Mathematics. Springer-Verlag, 1978.
[24] W. W. Wadge. Reducibility and Determinateness on the Baire Space. PhD thesis, University
of California, Berkeley, 1983.

Sergey Odintsov
On the Equivalence of Paraconsistent and
Explosive Versions of Nelson Logic¹
Abstract: We investigate the relations between the paraconsistent version of Nel-
son logic suggested by M. Busaniche and R. Cignoli and the explosive version of
this logic.
Keywords: 03B53, 03B55, 03B60, 03G10
Mathematics Subject Classiﬁcation 2010: Strong negation, Nelson logic, paracon-
sistency, Belnapian constant, twist- structure, lattice of logics
||
Sergey Odintsov S.L. Sobolev Institute of Mathematics, Siberian Division of the Russian
Academy of Sciences, Russia
1 Introduction
In many cases paraconsistent logics are obtained as weaker versions of traditional
logical systems by deleting the Duns Scottus law from the list of axioms. In this
way there arose, e.g., the minimal logic J, a paraconsistent version of the intuition-
istc logic Int, and the paraconsistent Nelson logic N4, a weakening of the explo-
sive Nelson logic N3. Deleting one or another axiom from the axiomatics does not
mean that the resulting logic lose the expressive power as compared to the origi-
nal logic. The most natural example is provided by the classical and intuitionistic
logics. It is known from the Glivenko theorem that the classical logic can be faith-
fully embedded into the intuitionistic one. As a result the classical reasoning can
be modelled in the intuitionistic logic. Additionally, as we can see from the Kripke
semantics for Int, the intuitionistic logic give us the possibility to model the dy-
namics of information states. In a similar way, the paraconsistent logics J and N4
can model explosive reasoning of logics Int and respectively N3 and give us the
possibility to distinguish the contradictions, which is impossible in explosive log-
ics, where all inconsistent theories are trivial and all contradictions are equivalent
(see [16] for details).
1 This paper was written with support from the Russian Foundation for Basic Research, Projects
No. 12-01-00168-a and No. 11-07-00560-a

260
|
Sergey Odintsov
Sometimes the connections between explosive and paraconsistent versions
of one logic are even more close. The aim of the present paper is to show that
one natural version of a paraconsistent Nelson logic is equivalent to the explosive
N3 is a rather strong sense. The concept of constructible falsity was suggested
by D. Nelson [10] to overcome the non-constructive character of the intuitionis-
tic negation. Subsequently, his system of constructive logic with strong negation,
traditionally denoted by N3, was axiomatized by Vorob’ev [26; 27] and studied
algebraically by Helena Rasiowa [18; 19]. M. Fidel and D. Vakarelov [6; 25] inde-
pendently discovered a convenient representation of algebraic N3-models via so
called twist-structures.
The concept of constructible falsity agrees well with that of paraconsistency. If
the falsity of an atomic fact p represented as ∼p, the strong negation of p, is given
explicitly, we may admit that both p and ∼p are true. The paraconsistent Nelson’s
logic N4 is obtained by deleting the “explosive" axiom ∼p →(p →q) from
the axiomatics of N3. From the early 1970s several versions of N4 were studied
independently by R. Routley (later R. Sylvan) in the propositional case in [20], by
López-Escobar in [9] and by Nelson himself in [1], both in the ﬁrst-order case.
Kripke semantics for N3 ( [23; 8]) is readily obtained from the usual Kripke se-
mantics for intuitionistic logic by assigning to each world, instead of a set of propo-
sitional variables, a set of literals, ie. propositional variables or strongly negated
propositional variables. Equivalently, the truth-assignment on propositional vari-
ables and worlds is 3-valued, to reﬂect the three cases of veriﬁed, falsiﬁed or nei-
ther. Changing to 4-valued assignments in Kripke models produces a semantics
for N4: the fourth value now corresponds to “overdetermined" or the situation
that both a literal and its contrary are veriﬁed at a world. This explains the choice
of denotation N3 and N4. Actually (see [17] for details), we can consider a truth-
assignment for the logic N4 as a mapping sending pairs of propositional variables
and worlds into four-element Belnapian matrix with its truth values True, False,
Neither, and Both [2; 3].
Algebraic semantics for N4 in terms of N4-lattices was suggested in [12], and
the twist-structure representation of N4-lattices was studied in [13]. The logic N4⊥
[14] is obtained from N4 by adjoining the intuitionistic falsity constant ⊥. It is a
conservative extension of N4 as well as of the intuitionistic logic, but adding this
constant provides the class of N4⊥-extensions with a regular structure (see [16]).
In twist-structure semantics [6; 25], we have ⊥= (0, 1), where 0 and 1 are zero
and unit elements of the underlying Heyting algebra. In this way ⊥is a natural
analog of the Belnapian constant False, where as ∼⊥= (1, 0) corresponds to
True [2; 3].
Another version of paraconsistent Nelson logic [11] arose in the course of the
study of substructural properties of the strong implication connective, p ⇒q :=

Paraconsistent and Explosive Nelson Logics
|
261
(p →q)∧(∼q →∼p). This implication connective lacks the contraction property.
The formulas p ⇒(p ⇒q) and p ⇒q are not equivalent in N3. In [21; 22], it was
proved syntactically, with the help of the prover OTTER, that the variety of N3-
lattices (providing algebraic semantics for N3) is deﬁnitionally equivalent to the
variety of Nelson FLew-algebras (a subvariety of the variety of residuated lattices),
and so N3 can be treated as an axiomatic extension of FLew, the full Lambeck
calculus with exchange and weakening [7]. M. Busaniche and R. Cignoli [5] have
found more natural (and essentially shorter) semantic proof of this result. Trying
to extend this result to N4 they deﬁned in [4] the logic eN4 with the additional
constant e satisfying the equations e =∼e and e →e = e. The eN4-lattices are
N4-lattices with the interpreted constant e. In twist-structures, the constant e is
always interpreted as (1, 1), and, in this way, it corresponds to the Belnapian con-
stant Both. In [4], M. Busaniche and R. Cignoli deﬁned a variety of NPc-lattices,
a subvariety of the variety of residuated lattices with involution, and proved that
this variety is equivalent to the variety of eN4-lattices. Notice that the syntactical
translations are in this case essentially diﬀerent from that of [21].
In this paper we consider the logic eN4⊥, the language of which contains both
constants ⊥and e. Despite the fact that the logic eN4⊥is paraconsistent, its ex-
pressive power is very close to that of N3. In this paper, we deﬁne the translation
σ, which embed faithfully N3 into eN4⊥, and the translation β providing the em-
bedding of eN4⊥into N3. Moreover, the translations σ and β will deﬁne mutually
inverse isomorphisms of the lattice of N3-extensions and that of eN4⊥-extensions.
This allows to conclude the expressive powers of the paraconsistent logic eN4⊥
and of the explosive N3 are essentially the same.
In the following it will be interesting to consider the result of adding an analog
of the Belapian constant Neither to the logic N4⊥, and at the result of adding the
full set of Belnapian constants to N4. Also, it would be interesting to have a closer
look at the relations between the variety of Nelson FLew-algebras from [21] and
the variety of NPc-lattices from [4].
2 The Nelson logics
We consider the basic propositional language L = {∨, ∧, →, ∼} and two lan-
guages obtained from L by adjoining constant symbols:
L⊥= L ∪{⊥}, L⊥,e = L ∪{⊥, e}.
The symbol ∼stands for the strong negation, while the constant ⊥is the intu-
itionistic falsity constant and it will be used to deﬁne the intuitionistic negation.

262
|
Sergey Odintsov
The set of formulas For(L) (For(L⊥), etc.) is constructed from a ﬁxed set Prop =
{p0, p1, . . .} of propositional variables with the help of connectives of the respec-
tive language in a standard way.
By a logic in the language L (L⊥, etc.) we mean a subset of For(L) (For(L⊥),
etc.) closed under the substitution rule and the rule of modus ponens (MP). A
theory over a logic L is a set T of formulas of the respective language such that
L ⊆T and T is closed under MP. A theory T is called inconsistent wrt ∼(wrt ⊥) if
φ, ∼φ ∈T for some formula φ (if ⊥∈T). A theory T over L is trivial if T contains
all formulas of the respective language, otherwise the theory is called non-trivial.
Recall that a logic is called paraconsistent wrt ∼(wrt ⊥) if there is a nontrivial
inconsistent wrt ∼( wrt ⊥) theory over that logic. But if such theory does not exist,
then the logic is called paraconsistent wrtexplosive wrt ∼(wrt ⊥).
If L is a logic and Γ is a set of formulas of the same language as L, we denote
by L + Γ the least logic containing L ∪Γ. Such logic exists since the intersection of
an arbitrary family of logics is again a logic. If L is a logic in the language L (L⊥,
etc.), we denote by EL the set of all logics in the language L (L⊥, etc.) extending
L. The operations ∩and + turn EL into the lattice.
The paraconsistent Nelson logic N4 can be deﬁned as the least logic in the
language L containing the following list of axioms:
A1. p →(q →p)
A2. (p →(q →r)) →((p →q) →(p →r))
A3. (p ∧q) →p
A4. (p ∧q) →q
A5. (p →q) →((p →r) →(p →(q ∧r)))
A6. p →(p ∨q)
A7. q →(p ∨q)
A8. (p →r) →((q →r) →((p ∨q) →r))
A9. ∼∼p ↔p
A10. ∼(p ∨q) ↔(∼p ∧∼q)
A11. ∼(p ∧q) ↔(∼p ∨∼q)
A12. ∼(p →q) ↔(p ∧∼q)
The explosive Nelson logic N3 can be deﬁned as
N3 = N4 + {∼p →(p →q)}.
The logic N4⊥is the least logic in the language L⊥containing axioms A1–A12 of
N4 and the additional axioms for the constant ⊥:
A13. ⊥→p
and
A14. ∼⊥

Paraconsistent and Explosive Nelson Logics
|
263
These axioms allow to deﬁne the explosive intuitionistic negation in the usual
way: ¬φ := φ →⊥. More exactly, it can be proved that N4⊥is a conservative ex-
tension of the intuitionistic logic deﬁned in the language {∨, ∧, →, ⊥}. The logic
N4⊥is also a conservative extension of N4. Notice that N4⊥is paraconsistent wrt
∼and explosive wrt ⊥.
If we deﬁne the constant ⊥as ∼(p0 →p0), then the axioms A13 and A14
are provable in N3. In this way, the logic N3 can be considered as an extension of
N4⊥. We can prove in N3 the implication ∼p →¬p, but the converse remains
unprovable. Notice that in N4⊥the implication ∼p →¬p is not provable.
The logic eN4⊥is deﬁned in the language L⊥,e as follows:
eN4⊥= N4⊥+ {e, ∼e}.
3 Algebraic semantics for Nelson’s logics
Recall that an implicative lattice A = ⟨A, ∧, ∨, →, 1⟩is a distributive lattice with
the greatest element 1, and the implication operation →satisfying the equivalence
a ∧c ≤b iﬀc ≤a →b,
where ≤is the lattice ordering of A and a, b, c ∈A. A Heyting algebra A =
⟨A, ∧, ∨, →, 0, 1⟩is an implicative lattice with the least element 0.
The set Fd(A) = {a ∨(a →b) | a, b ∈A} is a ﬁlter of dense elements of an
implicative lattice (a Heyting algebra) A. The lattice of ﬁlters on A is denoted by
F(A), and the lattice of ideals is denoted by I(A). In case of a Heyting algebra A
we have: Fd(A) = {a ∈A | ¬¬a = 1} = {a ∨¬a | a ∈A}.
Deﬁnition 1. Let A be an implicative lattice (a Heyting algebra).
1. A full twist-structure over A is an algebra
A▷◁= ⟨A × A, ∨, ∧, →, ∼⟩
(A▷◁= ⟨A × A, ∨, ∧, →, ∼, ⊥, 1⟩)
with twist-operations deﬁned for (a, b), (c, d) ∈A × A in the following way:
(a, b) ∨(c, d) := (a ∨c, b ∧d), (a, b) ∧(c, d) := (a ∧c, b ∨d)
(a, b) →(c, d) := (a →c, a ∧d), ∼(a, b) := (b, a)
(⊥:= (0, 1), 1 := (1, 0)).
2. A twist-structure over A is an arbitrary subalgebra B of the full twist-structure
A▷◁such that π1(B) = A, where πi, i = 1, 2, denotes the projection of the
direct product on the i-th coordinate.

264
|
Sergey Odintsov
3. A class of all twist-structures over the A is denoted by S▷◁(A).
Notice that if B ∈S▷◁(A), then we have π2(B) = A.
A valuation in a twist-structure B is deﬁned in a usual way as a homomor-
phism of the algebra of formulas into B. The relation B ⊨φ means that π1υ(φ) = 1
for every B-valuation υ. We write B ⊨Γ for a set of formulas Γ if B ⊨φ for all φ ∈Γ.
Put LB = {φ ∈For(L⊥) | B ⊨φ}. For a formula φ, the notation ⊨▷◁φ (⊨⊥
▷◁φ)
means that B ⊨φ for each twist-structure B over an implicative lattice (a Heyting
algebra).
Theorem 2. [12; 14] For any φ ∈For(L) (φ ∈For(L⊥)) the following equivalence
is true
φ ∈N4 ⇔⊨▷◁φ
(φ ∈N4⊥⇔⊨⊥
▷◁φ).
Let A be an implicative lattice (a Heyting algebra). Further, let ∇∈F(A), Fd(A) ⊆
∇, ∆∈I(A). We denote by Tw(A, ∇, ∆) the twist-structure over A with the uni-
verse
|Tw(A, ∇, ∆)| = {(a, b) | a, b ∈A, a ∨b ∈∇, a ∧b ∈∆}.
It is easy to see that this set is closed under twist-operations. Moreover (see [13]),
every element B of S▷◁(A) can be represented as B = Tw(A, ∇, ∆), where
∇= {a ∨b | (a, b) ∈B} and ∆= {a ∧b | (a, b) ∈B}.
In particular, A▷◁= Tw(A, A, A). In [14] it was noticed that a twist-structure
B = Tw(A, ∇, ∆) is a model of the logic N3, B ⊨N3, iﬀthe implicative lattice
A contains the least element 0 and ∆= {0}. Thus, the logic N3 is characterized
by the class of twist-structures of the form Tw(A, ∇, {0}).
An algebra A = ⟨A, ∨, ∧, →, ∼⟩(A = ⟨A, ∨, ∧, →, ∼, ⊥, 1⟩) isomorphic to
a twist-structure over an implicative lattice (a Heyting algebra) is called an N4-
lattice (an N4⊥-lattice). We say that φ is true on an N4(⊥)-lattice A, A ⊨φ, if
the identity φ →φ = φ holds on A. This deﬁnition agrees with the deﬁnition
of validity of formulas on twist structures. Namely, if B is a twist-structure, then
B ⊨φ iﬀthe identity φ →φ = φ holds on B. We say that an N4(⊥)-lattice A is a
model of a logic L ∈EN4(⊥) (A ⊨L) if A ⊨φ for all φ ∈L.

Paraconsistent and Explosive Nelson Logics
|
265
In [12; 14], it was proved that the class of all N4(⊥)-lattices forms a variety
N4(⊥), and that the lattice Sub(N4(⊥)) of subvarieties of N4(⊥) is dually² isomor-
phic to the lattice EN4(⊥) of N4(⊥)-extensions. These mutually inverse dual iso-
morphisms are given by the rules:
V(L) = {A | A ∈N4(⊥), A ⊨L}, L ∈EN4(⊥);
L(V) = {φ | A ⊨φ for all A ∈V}, V ∈Sub(N4(⊥)).
It follows from the above remarks on N3-models that for every N4-lattice A the
following equivalence holds:
A ∈V(N3) iﬀA ∼= Tw(B, ∇, {0}) for some B and ∇⊇Fd(B).
(1)
An algebra A = ⟨A, ∨, ∧, →, ∼, e, ⊥, 1⟩is called an an eN4⊥-lattice iﬀthe e-free
reduct A = ⟨A, ∨, ∧, →, ∼, ⊥, 1⟩is an N4⊥-lattice and the following equations
hold: e →e = e and ∼e = e. Since the class of N4⊥-lattices form a variety, the
class of eN4⊥-lattices is a variety too, which we denote as eN4⊥.
Slightly modifying the proofs of [14] we obtain that the mappings
V : Sub(eN4⊥) →EeN4⊥and L : EeN4⊥→Sub(eN4⊥)
deﬁned as above are mutually inverse dual lattice isomorphisms between the
lattice Sub(eN4⊥) of subvarieties of the variety eN4⊥and the lattice of eN4⊥-
extensions.
Let A be an eN4⊥-lattice. Since A is an N4⊥-lattice too, there is a twist-
structure B over a Heyting algebra C such that A ∼= B. Let e be interpreted in B
as (a, b). The equality ∼e = e implies (b, a) = (a, b), ie. a = b. The equality
e →e = e means that (a, b) →(a, b) = (a →a, a ∧b) = (1, a ∧b) = (a, b),
ie. a = 1. Thus, e is interpreted in B as (1, 1), in particular, (1, 1) ∈B. Since
(1, 1) ∈B, we have 1 = 1 ∧1 ∈∆(B), which means that ∆(B) = C. On the other
hand, if B = Tw(C, ∇, C), then (1, 1) ∈B since 1 = 1 ∨1 belongs to every ﬁlter ∇
on C. Thus, interpreting e as (1, 1) turns B into an eN4(⊥)-lattice. We have thus
proved the following statement.
Proposition 3. An algebra A = ⟨A, ∨, ∧, →, ∼, e, ⊥, 1⟩is an eN4⊥-lattice iﬀ
there are a Heyting algebra B and a ﬁlter ∇on B (Fd(B) ⊆∇) such that A ∼=
Tw(B, ∇, B). The constant e corresponds to (1, 1) under this isomorphism.
2 By a dual isomorphism of lattices A and B we mean a mapping h : A →B such that h is an
isomorphism of A and Bop, where Bop is the lattice with the same support as B, but with the
inverse ordering.

266
|
Sergey Odintsov
Let A be an N4⊥-lattice. A non-empty subset ∇⊆A is called a special ﬁlter of
the ﬁrst kind (sﬀk) on A if: 1) a ∈∇and b ∈∇imply a ∧b ∈∇; 2) a ∈∇and
(a →b) →(a →b) = a →b imply b ∈∇. It is obvious that the set of all sﬀk on
A forms a lattice, which we denote F1(A).
Denote by Con(A) the lattice of congruences on A. It was proved in [13; 14]
that the mappings ∇→θ∇, ∇∈F1(A), and θ →∇θ, θ ∈Con(A),where
θ∇= {(a, b) | a, b ∈A, a ↔b, ∼a ↔∼b ∈∇},
∇θ = {a | a ∈A, aθ(a →a)},
establish mutually inverse isomorphisms between lattices F1(A) and Con(A).
Let A ∈S▷◁(B). For F ⊆B, put F▷◁= {(a, b) | (a, b) ∈B, a ∈F}. It was
proved in [14] that F ∈F(B) iﬀF▷◁∈F1(A). Moreover, if F ∈F(B), then for every
∇∈F(B) with Fd(B) ⊆∇and ∆∈I(B), we have the following isomorphism:
Tw(B, ∇, ∆)/F▷◁∼= Tw(B/F, ∇/F, ∆/F).
(2)
All these results can be easily transferred to eN4⊥-lattices.
4 Translations
First we consider an embedding of N3 into eN4⊥.
For a formula φ, we denote by var(φ) the set of all propositional variables
that occur in φ. The translation σ : For(L) →For(L⊥,e) is given by the rule
σ(φ) := (

p∈var(φ)
¬(p∧∼p)) →φ.
For arbitrary L ∈EN3, put
σ(L) = eN4⊥+ {σ(φ) | φ ∈L}.
Recall that a logic L1 is faithfully embedded into L2 via a translation τ if for every
formula φ in the language of L1, we have the equivalence: φ ∈L1 iﬀτ(φ) ∈L2.
Our next goal is to prove that every logic L extending N3 is faithfully embedded
into σ(L) via the translation σ. Prior to proving this we make the following obser-
vation.
Lemma 4. For every formula φ ∈For(L), Heyting algebra A, and ﬁlter ∇on A
such that Fd(A) ⊆∇, the following equivalence holds:
Tw(A, ∇, A) ⊨σ(φ) iﬀTw(A, ∇, {0}) ⊨φ.

Paraconsistent and Explosive Nelson Logics
|
267
Proof. Assume that Tw(A, ∇, A) ⊨σ(φ) and consider a Tw(A, ∇, {0})-valuation
v. Since Tw(A, ∇, {0}) ⊆Tw(A, ∇, A) we can consider v as a Tw(A, ∇, A)-
valuation.
By assumption π1v(σ(φ)) = π1v(
p∈var(φ) ¬(p∧∼p)) →π1v(φ) =
1, whence π1v(
p∈var(φ) ¬(p∧∼p)) ≤π1v(φ). Since v is a Tw(A, ∇, {0})-
valuation, we have π1v(p) ∩π2v(p) = π1v(p∧∼p) = 0 for every p ∈Prop.
Consequently,
π1v(

p∈var(φ)
¬(p∧∼p)) = 1
and π1v(φ) = 1. We have thus proved that Tw(A, ∇, {0}) ⊨φ.
Now we assume that Tw(A, ∇, A) ⊭σ(φ). Let a Tw(A, ∇, A)-valuation v be
such that π1v(σ(φ)) ̸= 1. The latter means that
π1v(

p∈var(φ)
¬(p∧∼p)) ̸≤π1v(φ).
Denote a = π1v(
p∈var(φ) ¬(p∧∼p)) and b = π1v(φ), then a ̸≤b. Let ⟨a⟩
be a ﬁlter on A generated by a, ⟨a⟩= {c | a ≤c}. Then we have b ̸∈⟨a⟩.
Consider the twist-structure Tw(A/⟨a⟩, ∇/⟨a⟩, A/⟨a⟩) and the valuation v′ given
by the rule v′(p) = (π1v(p)/⟨a⟩, π2v(p)/⟨a⟩). An easy induction on the struc-
ture of formulas allows to prove that for any formula φ ∈For(L⊥,e), we have
v′(φ) = (π1v(φ)/⟨a⟩, π2v(φ)/⟨a⟩). In particular, we have π1v′(φ) = b/⟨a⟩. Since
b ̸∈⟨a⟩, b/⟨a⟩̸= 1A/⟨a⟩, whence Tw(A/⟨a⟩, ∇/⟨a⟩, A⟨a⟩) ⊭φ. At the same time,
π1v′(
p∈var(φ) ¬(p∧∼p)) = a/⟨a⟩= 1A/⟨a⟩, which implies for all p ∈var(φ)
that π1v′(p∧∼p) = 0A/⟨a⟩, ie. π1v′(p) ∧π2v′(p) = 0A/⟨a⟩for all p ∈var(φ).
This means that on propositional variables from var(φ), the valuation v′ acts
as a Tw(A/⟨a⟩, ∇/⟨a⟩, {0/⟨a⟩})-valuation. This fact and π1v′(φ) ̸= 1A/⟨a⟩imply
Tw(A/⟨a⟩, ∇/⟨a⟩, {0/⟨a⟩}) ⊭φ, ie. the identity φ →φ = φ does not hold on
Tw(A/⟨a⟩, ∇/⟨a⟩, {0/⟨a⟩}). By (2) the twist-structure Tw(A/⟨a⟩, ∇/⟨a⟩, {0/⟨a⟩})
is isomorphic to Tw(A, ∇, {0})/⟨a⟩▷◁, the quotient algebra of Tw(A, ∇, {0}).
Consequently, φ
→
φ
=
φ is not an identity of Tw(A, ∇, {0}) too. Thus,
Tw(A, ∇, {0}) ⊭φ.
Theorem 5. For every logic L ∈EN3 and formula φ ∈For(L), the following equiv-
alence holds:
φ ∈L ⇐⇒σ(φ) ∈σ(L).
Proof. That φ ∈L implies σ(φ) ∈σ(L) follows from the deﬁnition of the logic
σ(L). Take a formula φ ̸∈L and an algebra A ∈V(L) such that A ⊭φ. Since
L extends N3, we have A ⊨N3. Consequently, A ∼= Tw(B, ∇, {0}) for some
B. By the previous lemma we have Tw(B, ∇, B) ⊨σ(ψ) for all ψ ∈L, whence

268
|
Sergey Odintsov
Tw(B, ∇, B) ∈V(σ(L)). At the same time, Tw(B, ∇, B) ⊭σ(φ) in view of A ⊭φ.
We have thus proved that σ(φ) ̸∈σ(L).
Corollary 6. The logic N3 is faithfully embedded into eN4⊥via σ.
Proof. It remains to notice that σ(N3) = eN4⊥, ie. σ(φ) ∈eN4⊥for all φ ∈
N3. If φ ∈N3, then Tw(A, ∇, {0}) ⊨φ for all A and ∇. By Lemma 3 we obtain
Tw(A, ∇, A) ⊨σ(φ) for all A and ∇. Every eN4⊥-lattice is isomorphic to a twist-
structure of the form Tw(A, ∇, A), consequently, σ(φ) ∈eN4⊥.
Corollary 7. The mapping L →σ(L), L ∈EN3, is an order preserving embedding
of the lattice EN3 into EeN4⊥.
Proof. It follows by deﬁnition that this mapping preserves the inclusion relation.
Let L1, L2 ∈EN3 and φ ∈L1 \ L2. By Theorem 4 we obtain that σ(φ) ∈σ(L1) \
σ(L2). Thus, the mapping L →σ(L) is one-to-one.
In fact, the mapping L →σ(L) establishes an isomorphism between lattices EN3
and EeN4⊥. This fact can be proved in diﬀerent ways. For example, one can deﬁne
β(L) = {φ | σ(φ) ∈L} for L ∈EeN4⊥. We know that N3 ⊆β(L) and one can
prove that β(L) is a logic and that σ(β(L)) = L. Instead of following this way we
deﬁne a translation β : For(L⊥,e) →For(L) and prove that it allows to deﬁne an
embedding of EeN4⊥into EN3, which is inverse to the embedding deﬁned by σ.
Recall that a formula φ is a negation normal form (nnf) if the strong negation
∼occurs in φ only in front of propositional variables. The strong negation axioms
A9–A12 allow to reduce any formula to a negative normal form, ie. to eﬀectively
ﬁnd out for a formula φ ∈For(L⊥,e) a nnf ψ such that φ ↔ψ ∈eN4⊥. We say
in this case that ψ is a negative normal form of φ. Suppose that we ﬁxed some
algorithm reducing a formula φ to its nnf ¯φ.
For φ ∈For(L⊥,e), we write φ = φ(p0, . . . , pn) if var(φ) is a subset of
{p0, . . . , pn}.
First we deﬁne the translation β : For(L⊥,e) →For(L) for formulas that
are nnfs. If φ = φ(p0, . . . , pn) is a nnf, then there is a uniquely deﬁned positive
formula φ′, ie. a formula constructed from propositional variable with the help of
positive connectives ∨, ∧, and →, such that
φ(p0, . . . , pn) = φ′(⊥, ∼⊥, e, ∼e, p0, ∼p0, . . . , pn, ∼pn).
We put
β(φ(p0, . . . , pn)) =
φ′(⊥, ∼⊥, ∼⊥, ∼⊥, p0, p1∨∼p0, . . . , p2n, p2n+1∨∼p2n) .

Paraconsistent and Explosive Nelson Logics
|
269
In this deﬁnition the constant ⊥is treated as an abbreviation for ∼(p0 →p0).
In other words, for nnfs the translation β is deﬁned as follows:
β(⊥) = ⊥, β(∼⊥) =∼⊥, β(e) =∼⊥, β(∼e) =∼⊥,
β(pi) := p2i, β(∼pi) = p2i+1∨∼p2i,
β(φ ⋄ψ) := β(φ) ⋄β(ψ), ⋄∈{∨, ∧, →}.
For a formula φ, which is not a nnf, we put
β(φ) = β(¯φ).
For a logic L ∈EeN4⊥, we deﬁne β(L) = N3 + {β(φ) | φ ∈L}.
Lemma 8. For every formula φ ∈For(L⊥,e), Heyting algebra A, and ﬁlter ∇on A
such that Fd(A) ⊆∇, the following equivalence holds:
Tw(A, ∇, {0}) ⊨β(φ) iﬀTw(A, ∇, A) ⊨φ.
Proof. Since Tw(A, ∇, A) ⊨φ iﬀTw(A, ∇, A) ⊨¯φ, it will be enough to consider
the case of a nnf φ(p0, . . . , pn).
Assume that Tw(A, ∇, {0}) ⊨β(φ) and take arbitrary Tw(A, ∇, A)-valuation
v. Consider a Tw(A, ∇, {0})-valuation v′ such that:
v′(p2i) = (π1v(pi), ¬π1v(pi) ∧π2v(pi)), v′(p2i+1) = (π2v(pi), ¬π2v(pi)),
where i = 0, . . . , n and ¬a denotes a →0. Let us check the correctness of this
deﬁnition. Calculate
π1v′(p2i) ∨π2v′(p2i) = (π1v(pi) ∨¬π1v(pi)) ∧(π1v(pi) ∨π2v(pi)).
We have π1v(pi) ∨¬π1v(pi) ∈Fd(A) ⊆∇and π1v(pi) ∨π2v(pi) ∈∇in view of
v(pi) ∈Tw(A, ∇, A), whence π1v′(p2i) ∨π2v′(p2i) ∈∇. At the same time,
π1v′(p2i) ∧π2v′(p2i) = π1v(pi) ∧¬π1v(pi) ∧π2v(pi) = 0.
Consequently, v′(p2i) ∈Tw(A, ∇, {0}). For v′(p2i+1), we have
π1v′(p2i+1) ∨π2v′(p2i+1) = π2v(pi) ∨¬π2v(pi) ∈Fd(A) ⊆∇,
π1v′(p2i+1) ∧π2v′(p2i+1) = π2v(pi) ∧¬π2v(pi) = 0.
We have thus proved v′(p2i+1) ∈Tw(A, ∇, {0}).
Further, π1v′(β(pi)) = π1v′(p2i) = π1v(pi) and
π1v′(β(∼pi)) = π1v′(p2i+1∨∼p2i) = π2v(pi) ∨(¬π1v(pi) ∧π2v(pi)) =

270
|
Sergey Odintsov
= π2v(pi) = π1v(∼pi).
Using these facts by induction on the structure of formula we can prove that
π1v′(β(φ)) = π1v(φ).
By assumption Tw(A, ∇, {0}) ⊨β(φ), consequently π1v(φ) = π1v′(β(φ)) = 1.
We have thus proved Tw(A, ∇, A) ⊨φ.
Now we assume that Tw(A, ∇, {0}) ⊭β(φ). Let Tw(A, ∇, {0})-valuation v be
such that π1v(β(φ)) ̸= 1. Consider a Tw(A, ∇, A)-valuation v′ such that
v′(pi) = (π1v(p2i), π2v(p2i) ∨π1v(p2i+1)), i = 0, . . . , n.
Check that π1v′(pi) ∨π2v′(pi) ∈∇. Indeed,
π1v(p2i) ∨π2v(p2i) ∨π1v(p2i+1) ≥π1v(p2i) ∨π2v(p2i) ∈∇.
For pi, we have π1v(β(pi)) = π1v(p2i) = π1v′(pi). For ∼pi, we calculate
π1v(β(∼pi)) = π1v(p2i+1∨∼p2i) = π1v(p2i+1) ∨π2v(p2i) =
= π2v′(pi) = π1v′(∼pi).
Again by induction on the structure of formulas we obtain
π1v(β(φ)) = π1v′(φ).
Consequently π1v′(φ) ̸= 1 and Tw(A, ∇, A) ⊭φ.
Theorem 9. For every logic L ∈EeN4⊥and formula φ ∈For(L⊥,e), the following
equivalence holds:
φ ∈L ⇐⇒β(φ) ∈β(L).
Proof. We can prove this statement in essentially the same way as Theorem 4. The
only diﬀerence is that we will use Lemma 7 instead of Lemma 3.
The next two statements are obtained similarly to Corollaries 5 and 6.
Corollary 10. The logic eN4⊥is faithfully embedded into N3 via β.
Corollary 11. The mapping L →β(L), L ∈EeN4⊥, is an order preserving embed-
ding of the lattice EeN4⊥into EN3.
It remains to prove that the lattice embeddings deﬁned by the translations σ and
β are mutually inverse.

Paraconsistent and Explosive Nelson Logics
|
271
Theorem 12. The mappings L →σ(L), L ∈EN3, and L →β(L), L ∈EeN4⊥, are
mutually inverse lattice isomorphisms between EN3 and EeN4⊥.
Proof. Let A be a Heyting algebra and ∇a ﬁlter on A such that Fd(A) ⊆∇. It
follows from Lemma 3 and the deﬁnition of the logic σ(L) that
Tw(A, ∇, {0}) ⊨L ⇐⇒Tw(A, ∇, A) ⊨σ(L)
(3)
for all L ∈EN3.
Similarly, from Lemma 7 and the deﬁnition of the logic β(L) we obtain
Tw(A, ∇, A) ⊨L ⇐⇒Tw(A, ∇, {0}) ⊨β(L)
(4)
for all L ∈EeN4⊥.
It follows from (3) and (4) the logics L and β(σ(L)) have the same models of
the form Tw(A, ∇, {0}). Consequently, L = β(σ(L)) for all L ∈EN3.
In the same way, the logics L and σ(β(L)) have the same models of the form
Tw(A, ∇, A). Consequently, L = σ(β(L)) for all L ∈EeN4⊥.
Consequently, the mappings determined by σ and β are mutually inverse. By
Corollaries 6 and 10 EN3 and EeN4⊥are isomorphic as orders. Consequently, they
are isomorphic as lattices.
Bibliography
[1]
A. Almukdad & D. Nelson. Constructible falsity and inexact predicates. J. Symbolic Logic,
49:231–233, 1984.
[2]
N.D. Belnap. How a computer should think. In:, G.Ryle (ed.) Contemporary Aspects of
Philosophy, Oriel Press, Stocksﬁeld, 30–56, 1976.
[3]
N.D. Belnap. A Useful Four-Valued Logic. In: J.M. Dunn and G. Epstein (eds. ) Modern Uses
of Multiple-Valued Logics, D. Reidel Publishing Company, Dordrecht, 8–37, 1977.
[4]
M. Busaniche, R. Cignoli. Residuated lattices as algebraic semantics for paraconsitent
Nelson’s logic. Journal of Logic and Computation, 19:1019-1029, 2009.
[5]
M. Busaniche, R. Cignoli. Constructive logic with strong negation as a substructural logic.
Journal of Logic and Computation, 20:761–793, 2010.
[6]
M. Fidel. An algebraic study of a propositional system of Nelson. in: A. Arruda,
N. da Costa, R. Chuaqui (eds.) Mathematical Logic. Proceedings of the First Brasilian
Conference, Lectures in Pure and Applied Mathematics, V.39, New York, Marcel Dekker,
99–117, 1978.
[7]
N. Galatos, P. Jipsen, T. Kowalski, and H.Ono. Residuated lattices: an algebraic glimpse at
substructural logics, Elsevier, Amsterdam, 2007.
[8]
Y. Gurevich. Intuitionistic logic with strong negation. Studia Logica, 36:49–59, 1977.
[9]
E.G.K. López-Escobar. Refutability and elementary number theory. Indagationes Mathemat-
icae, 34:362-374, 1972.

272
|
Sergey Odintsov
[10] D. Nelson. Constructible falsity. Journal of Symbolic Logic, 14:16–26, 1949.
[11]
D. Nelson. Negation and separation of concepts in constructive systems. in: A. Heyting
(ed.) Constructivity in Mathematics, 208–225, North-Holland, Amsterdam, 1959. 14:16–26,
1949.
[12] S. Odintsov. Algebraic semantics for paraconsistent Nelson’s Logic. Journal of Logic and
Computation, 13:453–468, 2003.
[13] S. Odintsov. On representation of N4-lattices. Studia Logica, 76:385–405, 2004.
[14] S. Odintsov. The Class of Extensions of Nelson’s paraconsistent logic. Studia Logica,
80:293–322, 2005.
[15]
S. Odintsov. On extensions of Nelson’s logic satisfying Dummett’s axiom. Siberian Mathe-
matical Journal, 48:112–125, 2007.
[16] S. Odintsov. Constructive Negations and Paraconsistency, Dordrecht, Springer, 2008.
[17]
S.P. Odintsov, H. Wansing. Modal logics with Belnapian truth values. Journal of Applied
Non-Classical Logics, 20:279–301, 2010.
[18] H. Rasiowa. N-lattices and constructive logic with strong negation. Fundamenta Mathe-
maticae, 46:61–80, 1958.
[19] H. Rasiowa. An algebraic approach to non-classical logic. PWN, Warsaw and North-Holland,
Amsterdam, 1974.
[20] R. Routley. Semantical analyses of propositional systems of Fitch and Nelson. Studia
Logica, 33(3):283–298, 1974.
[21] M. Spinks, R, Veroﬀ. Constructive logic with strong negation is a substructural logic. I.
Studia Logica, 88:325–348, 2008.
[22] M. Spinks, R, Veroﬀ. Constructive logic with strong negation is a substructural logic. II.
Studia Logica, 89:401–425, 2008.
[23] R. H. Thomason. A semantical study of constructible falsity. Zeitschrift für Mathematische
Logik und Grundlagen der Mathematik, 15:247–257, 1969.
[24] A. Urquhart. Duality for algebras of relevant logics. Studia Logica, 56:263–76, 1994.
[25] D. Vakarelov. Notes on N-lattices and constructive logic with strong negation. Studia
Logica, 34:109–125, 1977.
[26] N. N. Vorob’ev. A constructive propositional calculus with strong negation (in russian).
Doklady Akademii Nauk SSSR, 85:465–468, 1952.
[27] N. N. Vorob’ev. The problem of deducibility in constructive propositional calculus with
strong negation (in russian). Doklady Akademii Nauk SSSR, 85:689–692, 1952.

Svetlana Selivanova
Computing Clebsch-Gordan Matrices with
Applications in Elasticity Theory¹
Abstract: We provide an algorithm of computing Clebsch-Gordan coeﬃcients for
irreducible representations, with integer weights, of the rotation group SO(3) and
demonstrate the convenience of this algorithm for constructing new (to our knowl-
edge) models in anisotropic elasticity theory.
Keywords: group of rotations, irreducible representations, Clebsch-Gordan matri-
ces, elasticity theory.
Mathematics Subject Classiﬁcation 2010: 20C35, 74B20
||
Svetlana Selivanova: S.L. Sobolev Institute of Mathematics, Siberian Division of the Russian
Academy of Sciences, Russia
1 Introduction
The aim of this paper is to provide an algorithm of computing Clebsch-Gordan
coeﬃcients, written in a convenient real-valued matrix form, for irreducible rep-
resentations, with integer weights, of the rotation group SO(3), and to show its
convenience for modelling anisotropic elasticity problems.
The Clebsch-Gordan coeﬃcients, arising from Kronecker products of repre-
sentations (see Section 2 for deﬁnitions), are a classical notion in group represen-
tation theory, and they are widely used in mathematical physics, see e.g. [2; 4; 14;
17; 21; 23; 24]. In [8; 9; 12; 16] it is shown how, written in a matrix form, they al-
low to construct invariant diﬀerential operators (as
∂
∂xi Gi
1[L,L±1], where Gi
1[L,L±1]
are particular examples of Clebsch-Gordan matrices, see deﬁnitions and exam-
ples in the paper) and matrix spherical functions (as products of relevant Clebsch-
Gordan matrices and homogeneous polynomials). It helps to write many (systems
of) ﬁrst-order PDEs invariant under rotations in a convenient form and to ﬁnd ex-
1 This research was partially supported by the Federal Target Grant “Scientiﬁc and educational
personnel of innovative Russia” for 2009-2013, program 1.2.2, contract No. 8217, and by the Russian
Foundation for Basic Research, project No. 12-01-31183.
Dedicated to Victor Selivanov on the occasion of his 60th birthday

274
|
Svetlana Selivanova
plicit solutions of Cauchy problems for them, see e.g. discussions on the examples
of elasticity, acoustics and Maxwell equations in the mentioned references.
The algorithm described in Section 4 relies on formulas derived recently in the
papers [7; 13] (which were written in continuation of the monograph [9]), where
a special basis, w.r.t. which the matrices of the representations are real orthogo-
nal (in contrast to complex unitary matrices in most literature on mathematical
physics), is proposed. The construction of this basis and further technical details
are described in Sections 2, 3. The general idea of the algorithm consists of calcu-
lating highest-/lowest-weight coeﬃcients ﬁrst and then applying lowering/raising
operators and is well-known (see e.g. [2; 4; 24] and modern improvements [1; 5]).
The (probably) new aspect is the special basis of [7; 13] and the spinor technique
we use for our computations. In comparison to other recent papers on the subject,
the presentation is very elementary, and possibility of application to (linear and
nonlinear) elasticity theory is demonstrated (Section 5).
In particular, we use the Clebsch-Gordan matrices to construct quadratic in-
variants and write down an equation of state of an anisotropic elastic media, as a
thermodynamical potential depending on these invariants. By using purely group
representation methods we are able to write down the precise form of the invari-
ants for all crystal systems, without any complicated geometric considerations.
The parameters of the invariant quadratic forms may be interpreted as the param-
eters of the media from the Hook’s law (Lame coeﬃcients in the isotropic case), in
accordance with well-known facts of elasticity theory [19; 15; 22].
This construction can be used to write elasticity equations in an invariant
form which is convenient for modelling complicated physical processes like ex-
ploding welding of metals and for applying numerical methods to the obtained
PDEs (the work in this direction is in progress and will appear in forthcoming pub-
lications). These considerations are a development of the paper [20] and are in line
with the works [6; 10; 11; 18].
2 Preliminaries
Let us ﬁrst recall some basic notions following the book [9]. The rotations of a
three-dimensional Euclidean space R3 constitute the group
SO(3) = {g ∈GL(3) | gTg = I3, det(g) = 1},
where GL(3) is the group of all nondegenerate 3 × 3 matrices, while I3 is the unit
matrix.

Computing Clebsch-Gordan Matrices
|
275
It is said that we have a representation TG of a group G in a k-dimensional
vector space L, if to each element g ∈G there corresponds a linear mapping Tg :
L →L such that
Te = Ik, Tg1·g2 = Tg1 · Tg2,
(2.1)
where e is the identity of the group G.
The representation TG is called irreducible, if in L there are no nontrivial sub-
spaces invariant under all mappings Tg, where g ∈G. The number N (integer or
half of an integer), such that k = 2N + 1, is called the weight of the irreducible
representation. It is well-known that single-valued irreducible representations of
SO(3) can exist only in odd-dimensional spaces (i.e. when N is integer), moreover,
for a ﬁxed number N, the corresponding representation is unique up to equiva-
lence. In this paper we consider only integer weights N.
The elements {g(t) ∈G}t∈R constitute a one-parameter subgroup of the group
G, if
g(t + s) = g(t) · g(s) and g(0) = e.
(2.2)
Let LN be the (2N + 1)-dimensional vector space in which the action of an irre-
ducible representation TG of G = SO(3) is deﬁned, and let us denote the Cartesian
coordinates in R3 as x−1, x0, x1. Then the one-parameter subgroups correspond-
ing to rotations w.r.t. these axes are described by the families of matrices
g1(ω) =


1
0
0
0
cos(ω)
−sin(ω)
0
sin(ω)
cos(ω)

, g−1(ω) =


cos(ω)
0
sin(ω)
0
1
0
−sin(ω)
0
cos(ω)

,
g0(ω) =


cos(ω)
−sin(ω)
0
sin(ω)
cos(ω)
0
0
0
1

,
where ω ∈R.
Denote as Jj, j = −1, 0, 1, the inﬁnitesimal operators of the representations of
these subgroups:
Jj =
d
dω Tgj(ω)|ω=0.
(2.3)
There are diﬀerent possibilities to chose a canonical, w.r.t. the representation TG,
basis in LN. A standard way, see e.g. [4; 9; 24], is to chose vectors on which the
inﬁnitesimal operators act as follows
iJ0 en
N = nen
N, n = −N, . . . , N,
(2.4)
(iJ1 + J−1) en
N =

−

(N −n + 1)(N + n) en−1
N
, n = −N + 1, . . . , N,
0, n = −N
(2.5)

276
|
Svetlana Selivanova
(iJ1 −J−1) en
N =

−

(N −n)(N + n + 1) en+1
N
, n = −N, . . . , N −1,
0, n = N.
(2.6)
Note that en
N are eigenvectors of the operator J0 (they are deﬁned up to a multi-
plicative constant), while formulas (2.5) and (2.6) allow to compute the basis vec-
tors recursively. W. r. t. such basis, which is called a canonical basis of “e” type, TG
is deﬁned by unitary matrices of dimension (2N + 1) × (2N + 1).
In [7] a basis, w.r.t. to which TG is deﬁned by (real) orthogonal matrices, is
introduced, and it is called a canonical basis of “h” type. This basis is related to
the previous one by means of a unitary transformation:









h−n
N
= (−i)N−1
√
2

(−1)nen
N −e−n
N
 ,
h0
N = (−i)Ne0
N,
hn
N = −(−i)N
√
2

(−1)nen
N + e−n
N
 .
(2.7)
The action of the inﬁnitesimal operators on this basis is as follows:
0
J0
−J0
0
 
h−n
N
hn
N

= n
h−n
N
hn
N

, n ≥0;
(2.8)















J−1
J1
−J1
J−1
 
h−n
N
hn
N

=

(N + n)(N −n + 1)
h−n+1
N
hn−1
N

, n ≥2,
J−1
J1
−J1
J−1
 
h−1
N
h1
N

= −

2N(N + 1)
0
h0
N

,
(2.9)















J−1
−J1
J1
J−1
 
h−n
N
hn
N

= −

(N + n + 1)(N −n)
h−n−1
N
hn+1
N

, n ≥1,
J−1
J1
J1
J−1
 
0
h0
N

=

N(N+1)
2
h−1
N
h1
N

,
(2.10)
Recall that a Kronecker product Tg = T1
g × T2
g of the representation T1
g of weight
N1 and T2
g of weight N2 is a representation which acts on a matrix B of dimension
(2N1 + 1) × (2N2 + 1) as
Tg B = T1
g B (T2
g)T.
(2.11)

Computing Clebsch-Gordan Matrices
|
277
The deﬁnition of the Clebsch-Gordan matrices, that we are going to compute,
arises from the following statement [7].
Theorem. If the representations T1
g and T2
g are irreducible, then T1
g × T2
g can
be decomposed into a direct sum of irreducible representations of the following
weights:
N = |N1 −N2|, |N1 −N2| + 1, . . . , N1 + N2.
(2.12)
Such decomposition is realized by means of the Clebsch-Gordan matrices, which
constitute canonical bases of the corresponding spaces of matrices:
Gn
N[N1,N2] of dimension (2N1 + 1) × (2N2 + 1), n = −N, N + 1, . . . , N.
(2.13)
These matrices are real-valued, orthonormal:
tr

(Gn
N[N1,N2])TGm
N[N1,N2]

= δmn (the Kronecker symbol),
(2.14)
possess one or two non-zero diagonals, and satisfy the following symmetry prop-
erty:
Gn
N[N1,N2] = (−1)N+N1+N2(Gn
N[N2,N1])T.
(2.15)
For computations, diﬀerent realizations of the irreducible representations are use-
ful, in particular: in the space of homogeneous polynomials of three real variables;
in the space of homogeneous spinor polynomials of two complex variables; in the
space of matrices. Our computations rely on the last two ones; we describe them
in the next section.
3 Diﬀerent realizations of irreducible
representations of the rotation group
A spinor polynomial is a homogeneous polynomial f(ξ, η) of degree 2N of two com-
plex variables ξ, η. The dimension of this space is equal to 2N + 1.
As it is known, the elements of SO(3) can be parameterized by unitary ma-
trices g ∈SU(2) in such a way that to any irreducible representation of SU(2)
of an integer weight N there corresponds a unique representation of SO(3) in a
space of odd dimension equal to 2N + 1. This parametrization helps to describe
all single-valued irreducible representations of SO(3), since it is sometimes more
convenient to make computations for SU(2). For simplicity of notation we denote
the one-parameter subgroups of SU(2) and the corresponding inﬁnitesimal oper-
ators in the same way gj(w) and Jj, as for SO(3) above.

278
|
Svetlana Selivanova
In the space of spinor polynomials the irreducible representation of SU(2) of
weight N is realized by the following formula [7]: for
g ∈SU(2), g =

α
β
−β
α

(3.1)
we have
Tgf(ξ, η) = f(ξ
′, η
′
) ≡f(αξ −βη, βξ + αη).
(3.2)
The canonical basis of “e” type consists of the polynomials
en
N(ξ, η) = ˜ρ(N, n)ξ N+nηN−n = (−1)N+n

(2N + 1)!
(N + n)!(N −n)! ξ N+nηN−n,
(3.3)
where n = −N, . . . N. According to (2.7), the canonical basis of “h” type is deﬁned
as
h·
N = e·
NUN,
(3.4)
e·
N = h·
NVN,
(3.5)
where
h·
N =

h−N
N , h−N+1
N
, . . . , h0
N, . . . , hN
N

, e·
N =

e−N
N , e−N+1
N
, . . . , e0
N, . . . , eN
N

,
UN = (−i)N−1
√
2


−1
i
. . .
. . .
−1
i
−i
√
2
(−1)n
i(−1)n
. . .
. . .
(−1)N
i(−1)N


,
U∗
NUN = I2N+1 and
VN = U−1
N
= U∗
N = iN−1
√
2


−1
(−1)N
. . .
. . .
−1
(−1)n
i
√
2
−i
−i(−1)n
. . .
. . .
−i
−i(−1)N


.
The product of two irreducible representations of weights N1 and N2 (of dimen-
sions 2N1 + 1 and 2N2 + 1), can be realized in the space of bispinor polynomials
f(ξ1, η1; ξ2, η2), homogeneous of degrees 2N1 and 2N2 on ξ1, η1 and ξ2, η2, re-
spectively:
Tgf(ξ1, η1; ξ2, η2) = f(αξ1 −βη1, βξ1 + αη1; αξ2 −βη2, βξ2 + αη2).
(3.6)

Computing Clebsch-Gordan Matrices
|
279
This representation acting in a (2N1+1)·(2N2+1)-dimensional space is reducible
and it can be decomposed into irreducible ones as in (2.12). The canonical bases
of “e” type look as [9; 8]
µn
N[N1,N2](ξ1, η1; ξ2, η2) =
(3.7)
= ˆρ(N, N1, N2)(ξ1η2 −η1ξ2)N1+N2−N

−ξ2 ∂
∂ξ1
−η2 ∂
∂η1
N−N1+N2
en
N(ξ1, η1),
where n = −N, −N + 1, . . . , N, and N1, N2 are ﬁxed and N is as in (2.12);
ˆρ(N, N1, N2) =

(2N1 + 1)!(2N2 + 1)!(N + N1 −N2)!
2N!(N1 + N2 −N)!(N −N1 + N2)!(N + N1 + N2 + 1)! .
The complete proof of this fact can be found in [9] (Section 13). Since this book is
in Russian, we recall brieﬂy its main steps.
–
First, the inﬁnitesimal operators acting in the space of bispinor polynomials
are calculated (for spinor polynomials it is a straightforward calculation by
deﬁnition, and for the bispinor case the deﬁnition of the Kronecker product
of representations is used). The answer is as follows:
(iJ1 + J−1) = η1 ∂
∂ξ1
+ η2 ∂
∂ξ2 ,
(iJ1 −J−1) = ξ1 ∂
∂η1
+ ξ2 ∂
∂η2 ,
(3.8)
iJ0 = 1
2

ξ1 ∂
∂ξ1
−η1 ∂
∂η1

+ 1
2

ξ2 ∂
∂ξ2
−η2 ∂
∂η2

.
(3.9)
–
It is noticed (by direct computation of the action of the inﬁnitesimal operators)
that the products en1
N1en2
N2 do not constitute a canonical basis in the space of
bispinor polynomials. The form of the polynomials needed is “guessed” by
taking in account the identities
(iJ1 + J−1)(ξ1η2 −ξ2η1)q = 0,
(iJ1 −J−1)(ξ1η2 −ξ2η1)q = 0
(3.10)
and by choosing a proper norming after calculating the scalar square of the
polynomial
(ξqη2 −ξ2η1)aηb
1ηc
2.
(3.11)
–
Finally, a direct substitution of the basis (3.7) into the equalities (2.4)–(2.5)
shows that it satisﬁes the deﬁnition of a canonical basis of “e” type.
Further, according to (2.7), the“h” type bases look as
νn
N[N1,N2](ξ1, η1; ξ2, η2) = ˆρ(N, N1, N2)(ξ1η2 −η1ξ2)N1+N2−N·
(3.12)

280
|
Svetlana Selivanova
·

−ξ2 ∂
∂ξ1
−η2 ∂
∂η1
N−N1+N2
hn
N(ξ1, η1).
These bases are related as
µ·
N[N1,N2] = ν·
N[N1,N2]VN.
(3.13)
The Clebsch-Gordan matrices Cn
N[N1,N2] and Gn
N[N1,N2] are introduced as the coef-
ﬁcients of decomposition of the basis polynomials µn
N[N1,N2] and νn
N[N1,N2] by the
polynomials {en1
N1en2
N2} and {hn1
N1hn2
N2}, respectively:
µn
N[N1,N2] = e·
N1Cn
N[N1,N2](e·
N2)T,
(3.14)
νn
N[N1,N2] = h·
N1Gn
N[N1,N2](h·
N2)T
(3.15)
It is easy to see [7], that the matrices Cn
N[N1,N2], n = −N, . . . , N and Gn
N[N1,N2], n =
−N, . . . , N constitute canonical bases of type “e” and of type “h”, respectively, in
the subspace of (2N1 +1)×(2N2 +1)-dimensional matrices, where an irreducible
representation of dimension N, N = |N1 −N2|, . . . , N1 + N2 is acting.
The following formula [7], which is a corollary of the formulas (3.7), (3.14), will
be useful for computations of the nonzero Clebsch-Gordan coeﬃcients in the next
section. For all n ∈{−N, −N + 1, . . . , N}, n2 ∈{−N2, −N2 + 1, . . . , N2} we have

ρ(N, N1, N2)
 ∂
∂ξ0
∂
∂η −
∂
∂η0
∂
∂ξ
N−N1+N2
en
N(ξ0, η0)

|ξ0=ξ,η0=η ·
·(−1)N2−n2e−n2
N2 (ξ, η) =

n1
cn[n1,n2]
N[N1,N2]en1
N1(ξ, η),
(3.16)
where
ρ(N, N1, N2) =

(2N1 + 1)!(N1 + N2 −N)!(N + N1 −N2)!
(2N)!(2N2 + 1)!(N + N1 + N2 + 1)!(N −N1 + N2)! .
(3.17)
4 Computing the Clebsch-Gordan matrices
We want to compute the nonzero elements of the matrices
G±n
N[N1,N2], n = 0, . . . , N, N = |N1 −N2|, |N1 −N2| + 1, . . . , N1 + N2
(4.1)
for arbitrary integer weights N1, N2. Note that in a similar way we can simply ob-
tain the matrices C±n
N[N1,N2].
The general scheme of computation, which we present in more details below,
is as follows:

Computing Clebsch-Gordan Matrices
|
281
1. Compute the nonzero diagonal of the two matrices C±N
N[N1,N2], by means of
(3.16).
2. Compute the two matrices G±N
N[N1,N2] by means of the transformation formulas
(3.5) and (3.13).
3. Compute other matrices by means of recurrent formulas (2.9), (2.10), which
allow to deﬁne G±(n−1)
N[N1,N2] from G±n
N[N1,N2].
Now let us describe these three stages more precisely.
–
To carry out the ﬁrst stage we use the well-known property of the Clebsch-
Gordan coeﬃcients stating that
cn[n1,n2]
N[N1,N2] = 0 for n1 + n2 ̸= n,
(4.2)
i.e. each matrix Cn
N[N1,N2] possesses only one nonzero diagonal, thus the sum
in the right-hand part of (3.16), for n = N, consists of only one nonzero sum-
mand (when n1 = n −n2).
More precisely, for n = N the elements of the nonzero diagonal, have the
numbers (N −k, k), where k = N −N1, N −N1 + 1, . . . , N2. Rewriting (3.16)
and taking into account (3.17) and (3.3), we obtain
cN[N−k,k]
N[N1,N2] = (−1)N2−kρ(N, N1, N2)
˜ρ(N2, −k)
˜ρ(N1, N −k)

2N + 1·
(4.3)
·[(N +N1 −N2 +1) . . . (2N −1)(2N)]·[(N1 −N +k+1) . . . (N2 +k−1)(N2 +k)].
For n = −N, the elements of the nonzero diagonal have numbers (−N −
k, k), k = −N2, −N2 + 1, . . . , N1 −N, and we obtain
c−N[−N−k,k]
N[N1,N2]
= (−1)N2−kρ(N, N1, N2)
˜ρ(N2, −k)
˜ρ(N1, −N −k)

2N + 1·
(4.4)
·[(N +N1 −N2 +1) . . . (2N −1)(2N)]·[(N1 −N −k+1) . . . (N2 −k−1)(N2 −k)].
The case N = 0 (and N2 = N1) is considered independently:
c0[−k,k]
0[N1,N1] = (−1)N1−k
√2N1 + 1 , k = −N1, −N1 + 1, . . . , N1.
(4.5)
–
Now turn to the second stage. From the formulas (3.13) and (3.14) we have
νN
N[N1,N2] = −(−i)N
√
2
[(−1)NµN
N[N1,N2] + µ−N
N[N1,N2]] =
= −(−i)N
√
2
[(−1)Ne·
N1CN
N[N1,N2](e·
N2)T + e·
N1C−N
N[N1,N2](e·
N2)T] =

282
|
Svetlana Selivanova
= −(−i)N
√
2
h·
N1VN1 [(−1)NCN[N1,N2] + C−N
N[N1,N2]] (VN2)T(h·
N2)T,
hence
GN
N[N1,N2] = −(−i)N
√
2
VN1

(−1)NCN
N[N1,N2] + C−N
N[N1,N2]

(VN2)T.
(4.6)
In a similar way,
G−N
N[N1,N2] = (−i)N−1
√
2
VN1

(−1)NCN
N[N1,N2] −C−N
N[N1,N2]

(VN2)T.
(4.7)
For N = 0 (N2 = N1), we have
G0
0[N1,N1] = VN1C0
0[N1,N1](VN1)T.
(4.8)
Note that the matrices calculated on this stage are real-valued.
–
Finally, in order to compute other matrices G±n
N[N1,N2], n < N, on the third
stage of the algorithm, we need to compute ﬁrst the action of the inﬁnitesimal
operators J±1, see (2.3), (2.9), (2.10).
By deﬁnition,
Jn =
d
dω Tgn(ω)|ω=0, n = −1, 0, 1,
(4.9)
where gn(ω) are one-parameter subgroups of SU(2).
As already mentioned in the previous section, in the space of spinor polyno-
mials, J±1 are given by formulas
J−1 = 1
2

−η ∂
∂ξ + ξ ∂
∂η

, J1 = i
2

η ∂
∂ξ + ξ ∂
∂η

(4.10)
From particular cases of the formula (3.16), written in the basis “h”, it follows
that
(−1)n√
3Jn

N(N + 1)(2N + 1)
hk
N(ξ, η) =

j
gn[j,k]
1[N,N]hj
N(ξ, η),
(4.11)
and hence
JN
±1 = −

N(N + 1)(2N + 1)
3
G±1
1[N,N],
(4.12)
where by JN
±1 we mean the corresponding inﬁnitesimal operators of the rep-
resentations of weight N. This formulas are constructive, since the matrices
G±1
1[N,N] were computed on the ﬁrst stage.
Let us again consider the space of (2N1 + 1) × (2N2 + 1) matrices, which
is isomorphic to the space of bispinor polynomials and denote there the in-
ﬁnitesimal operators as JN1×N2
±1
. Recall that in this space the Clebsch-Gordan
matrices
G±n
N[N1,N2], n = 0, . . . , N, N = |N1 −N2|, |N1 −N2| + 1, . . . , N1 + N2 (4.13)

Computing Clebsch-Gordan Matrices
|
283
constitute a canonical basis of “h” type.
The action of the operator JN1×N2
±1
on the matrix B of dimension (2N1 + 1) ×
(2N2 + 1) is computed as
JN1×N2
±1
B = −1
√
3
{

N1(N1 + 1)(2N1 + 1)G±1
1[N1,N1]B+

N2(N2 + 1)(2N2 + 1)B(G±1
1[N2,N2])T}.
(4.14)
It follows from the deﬁnition of the Kronecker product and the inﬁnitesimal
operator and taking into account the formula (4.12):
(T1
g × T2
g)B = T1
g B(T2
g)T,
(4.15)
JN1×N2
±1
B =
d
dω (T1
g±1(ω) × T1
g±1(ω))|ω=0B = JN1
±1B + BJN2
±1.
(4.16)
Finally, the recurrent formulas (2.9) and (2.10) allow to compute the matrices
G±(n−1)
N[N1,N2] from G±n
N[N1,N2].
More precisely, for N ≥n ≥2 we have
G−(n−1)
N[N1,N2] = −
1

(N + n)(N −n + 1)
{JN1×N2
−1
G−n
N[N1,N2]+
+JN1×N2
1
Gn
N[N1,N2]},
(4.17)
G(n−1)
N[N1,N2] = −
1

(N + n)(N −n + 1)
{−JN1×N2
1
G−n
N[N1,N2]+
+JN1×N2
−1
Gn
N[N1,N2]}.
(4.18)
For n = 1 we have
G0
N[N1,N2] =
1

2N(N + 1)

−JN1×N2
1
G−1
N[N1,N2] + JN1×N2
−1
G1
N[N1,N2]

.
(4.19)
Note also that we can compute the Clebsch-Gordan matrices by this algorithm
without the spinor technique (by using only the matrix approach), computing at
the ﬁrst stage the eigenvectors of the inﬁnitesimal operator J0 acting in the space
of matrices.

284
|
Svetlana Selivanova
5 Applications to elasticity theory
5.1 Statement of the problem
Let T = ||sij|| (where i, j = −1, 0, 1) be a tensor related to the elastic media, e.g.
in [20] we consider the Piola-Kirchhoﬀstress tensor (which is not necessarily sym-
metric) in Lagrangian coordinates ξ−1, ξ0, ξ1, but we also may consider the sym-
metric Cauchy stress tensor in Eulerian coordinates x−1, x0, x1, or some relevant
function of the distorsion matrix C = ||cij|| = || ∂xi
∂ξj ||, whatever is more convenient
for a particular problem. Here we assume for simplicity this tensor be symmetric:
T = T∗, and use, when considering diﬀerent crystal systems, a technique a bit
diﬀerent from the one used in [20].
The internal energy of the considered media can then be written as a function
of det(T) and ﬁve quadratic invariants, which will be constructed below:
H = H(det(T), J0, J1, I0, I1, I2).
(5.1)
For linear elasticity theory, the internal energy is constructed just as the sum of
the quadratic invariants.
The symmetric tensor T can be written as
T =


s11
s12
s13
s21
s22
s23
s31
s32
s33

= pI3 + S.
(5.2)
Here p is the “pressure”, a scalar, i.e. it is transformed by an irreducible represen-
tation of weight 0;
S = S∗, tr(S) = 0 is the “deviator” matrix, consisting of ﬁve independent el-
ements, which form a vector transformed by an irreducible representation of
weight 2;
I3 is the identity matrix.
The matrix S can be rewritten by means of the corresponding Clebsch-Gordan
matrices (which are a canonical basis in the space of symmetric 3×3 matrices with
zero trace) as follows:
S =


s11 −p
s12+s21
2
s13+s31
2
s12+s21
2
s22 −p
s23+s32
2
s13+s31
2
s23+s32
2
s33 −p

=
= s−2G−2
2[1,1] + s−1G−1
2[1,1] + s0G0
2[1,1] + s1G1
2[1,1] + s2G2
2[1,1].
(5.3)

Computing Clebsch-Gordan Matrices
|
285
Let us denote
s =







s−2
s−1
s0
s1
s2







=


















−s13 + s31
√
2
s12 + s21
√
2
√
3
√
2
(s22 −p)
s23 + s32
√
2
s11 −s33
√
2


















.
(5.4)
This vector is transformed by weight 2, and the corresponding Clebsch-Gordan
matrices (calculated by the algorithm from the previous subsection) look as fol-
lows:
G−2
2[1,1] =


0
0
−1
√
2
0
0
0
−1
√
2
0
0

, G−1
2[1,1] =


0
1
√
2
0
1
√
2
0
0
0
0
0

,
G0
2[1,1] =


−1
√
6
0
0
0
2
√
6
0
0
0
−1
√
6

,
G1
2[1,1] =


0
0
0
0
0
1
√
2
0
1
√
2
0

, G2
2[1,1] =


1
√
2
0
0
0
0
0
0
0
−1
√
2

.
Let us calculate the matrix of the irreducible representation of SO(3) acting in R5
as
˜s = As
(5.5)
which transforms the above introduced vector
s = (s−2, s−1, s0, s1, s2)T
(cf. [13; 4; 24] etc. where the matrix entries of irreducible are calculated with diﬀer-
ent methods for the general case). The matrix A can be represented as the product
AθAφAψ of the matrices of representations of the rotations Uθ,Uφ, Uψ around the
coordinate axes (as it is well-known, any element U of SO(3) is a combination of
such rotations).
The transformation
x′ = Ux

286
|
Svetlana Selivanova
of the space of vectors
x = (x−1, x0, x1)T
induces the transformation UTSU of the tensor S, thus in order to calculate the
elements Aij of the desired matrix A we ﬁrst calculate independently each matrix
UTGj
2[1,1]U of the sum
˜S =
2

j=−2
sjUTGj
2[1,1]U =
2

i=−2
˜siGi
2[1,1]
(5.6)
and deduce from (5.6)
˜si = ˜si(sj, φ, ψ, θ) =
2

i=−2
Aijsj.
(5.7)
For the ﬁrst one-parameter subgroup
U = Uθ =


cos(θ)
−sin(θ)
0
sin(θ)
cos(θ)
0
0
0
1


(5.8)
(around the axis x−1) we obtain the following matrix
Aθ =


cos(θ)
0
0
−sin(θ)
0
0
cos(2θ)
1
2
√
3 sin(2θ)
0
−1
2 sin(2θ)
0
−1
2
√
3 sin(2θ)
cos(θ)2 −1
2 sin(θ)2
0
1
2
√
3 sin(θ)2
sin(θ)
0
0
cos(θ)
0
0
1
2 sin(2θ)
1
2
√
3 sin(θ)2
0
1
2 + 1
2 cos(θ)2

.
(5.9)
The two other subgroups are treated in a similar way. The knowledge of the ob-
tained matrices will be helpful when considering diﬀerent crystal systems below.
5.2 Construction of invariants
To write down all of the invariants of the variables {sij} in (5.1), let us ﬁrst ask,
which quadratic forms (and how many) can be constructed from the elements p
and s from (5.4). For this purpose we write all possible Kronecker products of the
weights 0 and 2
0 × 0, 0 × 2, 2 × 0, 2 × 2
and their decompositions into irreducible ones. Note that, due to commutativity
of the Kronecker product, the cases 0×2 and 2×0 are identical. According to (2.12),

Computing Clebsch-Gordan Matrices
|
287
from the decomposition of the product of weights N1 and N2 into irreducible ones
[2|N1 −N2| + 1] + . . . + [2(N1 + N2) + 1] = (2N1 + 1)(2N2 + 1)
(5.10)
parameters w(N)
n
arise, which transform by irreducible representations of the cor-
responding weights N. This fact is illustrated by the following formula [8]:
p(N1) × q(N2) =
N1+N2

N=|N1−N2|

N

n=−N
w(N)
n
Gn
N[N1,N2]

,
(5.11)
where the vectors p and q are transformed by means of irreducible representations
of weights N1 and N2, respectively.
The invariant quadratic forms (transformed by a representation of zero
weight) made from these vectors look as follows (their invariance is an obvious
consequence of orthogonality of the representations under consideration):
I(N) =
N

n=−N
w(N)
n

p(N1)T
Gn
N[N1,N2], q(N2)

,
(5.12)
N = |N1 −N2|, |N1 −N2| + 1, . . . , N1 + N2.
In this way, we can calculate how many parameters (the coeﬃcients of these qua-
dratic forms) characterizing the elastic media there are and write down all possi-
ble invariant quadratic forms in (5.1). During this process we will identify the co-
inciding (due to commutativity) invariants and remove the skew-symmetric ones
(for the odd sum of weights N + N1 + N2). Finally we will obtain, according to
(5.10),
1) 0 × 0 =⇒1 parameter;
2) 0 × 2, 2 × 0 =⇒5 parameters;
3) 2 × 2 =⇒1 + 5 + 9 = 15 parameters (for the weights 0, 2, 4; note that
the cases of weights 1, 3 are not meaningful because of the skew-symmetry of the
corresponding Clebsch-Gordan matrices),
thus 21 parameters characterizing the elastic media, which is in accordance
with the classical elasticity theory.
According to (5.12), the corresponding invariant quadratic forms look as fol-
lows.
1. For N1 = 0; N2 = 0; N = 0 we have
J0 = c1G0
0[0,0]p2 = c1p2.
(5.13)
2. For N1 = 0; N2 = 2; N = 2 the Clebsch-Gordan matrices look again very
simple: G0
2[0,2] = [0 0 1 0 0] , G−1
2[0,2] = [0 1 0 0 0] , G1
2[0,2] = [0 0 0 1 0] , G−2
2[0,2]

288
|
Svetlana Selivanova
= [1 0 0 0 0] , G2
2[0,2] = [0 0 0 0 1] , and the corresponding quadratic form has
ﬁve arbitrary parameters aj, j = −2, −1, . . . , 2:
J1 =
2

j=−2
ajGj
2[0,2]sp =
2

j=−2
ajsjp.
(5.14)
The same expression appears from the case N1 = 2; N2 = 0; N = 2.
3. For the case N1 = 2; N2 = 2, as explained above, we have to consider N =
0, 2, 4.
–
For N = 0 we have
I0 = c2(G0
0[2,2] s, s) = ˜c2(s, s),
(5.15)
where G0[2,2] = cI3 is a diagonal matrix.
–
For N1 = 2; N2 = 2; N = 2 the invariant quadratic form looks like
I1 =
2

j=−2
bj(Gj
2[2,2]s, s),
(5.16)
where
G−2
2[2,2] =


0
0
−
√
2
√
7
0
0
0
0
0
−
√
3
√
2
√
7
0
−
√
2
√
7
0
0
0
0
0
−
√
3
√
2
√
7
0
0
0
0
0
0
0
0


,
G−1
2[2,2] =


0
0
0
−
√
3
√
2
√
7
0
0
0
1
√
2
√
7
0
√
3
√
2
√
7
0
1
√
2
√
7
0
0
0
−
√
3
√
2
√
7
0
0
0
0
0
√
3
√
2
√
7
0
0
0


,
G0
2[2,2] =


−
√
2
√
7
0
0
0
0
0
1
√
2
√
7
0
0
0
0
0
√
2
√
7
0
0
0
0
0
1
√
2
√
7
0
0
0
0
0
−
√
2
√
7


,

Computing Clebsch-Gordan Matrices
|
289
G1
2[2,2] =


0
−
√
3
√
2
√
7
0
0
0
−
√
3
√
2
√
7
0
0
0
0
0
0
0
1
√
2
√
7
0
0
0
1
√
2
√
7
0
−
√
3
√
2
√
7
0
0
0
−
√
3
√
2
√
7
0


,
G2
2[2,2] =


0
0
0
0
0
0
√
3
√
2
√
7
0
0
0
0
0
0
0
−
√
2
√
7
0
0
0
−
√
3
√
2
√
7
0
0
0
−
√
2
√
7
0
0


.
–
Finally, for the case N1 = 2; N2 = 2; N = 4 we obtain
I2 =
4

j=−4
dj(Gj
4[2,2]s, s),
(5.17)
where
G−4
4[2,2] =


0
0
0
0
−
√
2
2
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
−
√
2
2
0
0
0
0


,
G−3
4[2,2] =


0
0
0
−1
2
0
0
0
0
0
−1
2
0
0
0
0
0
−1
2
0
0
0
0
0
−1
2
0
0
0


,
G−2
4[2,2] =


0
0
√
14
√
3
14
0
0
0
0
0
−
√
14
7
0
√
14
√
3
14
0
0
0
0
0
−
√
14
7
0
0
0
0
0
0
0
0


,
G−1
4[2,2] =


0
0
0
√
7
14
0
0
0
√
7
√
3
7
0
−
√
7
14
0
√
7
√
3
7
0
0
0
√
7
14
0
0
0
0
0
−
√
7
14
0
0
0


,

290
|
Svetlana Selivanova
G0
4[2,2] =


√
5
√
2
√
7
70
0
0
0
0
0
−2
√
5
√
2
√
7
35
0
0
0
0
0
3
√
5
√
2
√
7
35
0
0
0
0
0
−2
√
5
√
2
√
7
35
0
0
0
0
0
√
5
√
2
√
7
70


,
G1
4[2,2] =


0
√
7
14
0
0
0
√
7
14
0
0
0
0
0
0
0
√
7
√
3
7
0
0
0
√
7
√
3
7
0
√
7
14
0
0
0
√
7
14
0


,
G2
4[2,2] =


0
0
0
0
0
0
√
14
7
0
0
0
0
0
0
0
√
14
√
3
14
0
0
0
−
√
14
7
0
0
0
√
14
√
3
14
0
0


,
G−3
4[2,2] =


0
1
2
0
0
0
1
2
0
0
0
0
0
0
0
0
0
0
0
0
0
−1
2
0
0
0
−1
2
0


,
G−4
4[2,2] =


√
2
2
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
−
√
2
2


.
As we can see, the 21 parameters characterizing the elastic media have split into
several groups:
–
two scalars c1, c2;
–
two 5-dimensional vectors a = (a−2, a−1, a0, a1, a2) and
b = (b−2, b−1, b0, b1, b2);
–
one 9-dimensional vector d = (d−4, d−3, d−2, d−1, d0, d1, d2, d3, d4).

Computing Clebsch-Gordan Matrices
|
291
5.3 Examples
For the crystal systems, where there are additional symmetries, the number of
independent parameters is less than 21. Using again the representation group ap-
proach, this fact can be established easily for all of the seven crystal systems, also
called syngonies. Below this is shown on the example of the monoclinic and rhom-
bic crystal systems.
Recall that a crystal group ∆consists of several orthogonal transformations:
∆⊂{h : x →τ + Bx | τ ∈R3, B ∈O(3)},
(5.18)
and K is a crystal with the symmetry group ∆, if
K = hK, ∀h ∈∆.
(5.19)
Denote as Γ the group of rotations of the crystal, i.e. the set of matrices constituting
the elements of ∆.
For the triclinic system, when Γ = I, we have the full set of 21 independent
parameters. For the monoclinic system we have Γ =< R2 >, where
R2 =


−1
0
0
0
−1
0
0
0
1

= Uθ
(5.20)
is the rotation around the axis x−1 on θ = π. In this case the transformation matrix
(5.9) looks like
A = Aθ =


−1
0
0
0
0
0
1
0
0
0
0
0
1
0
0
0
0
0
−1
0
0
0
0
0
1


.
(5.21)
Taking in a account the invariance of the quadratic forms introduced above, we
arrive at the following relations: for the invariant J1 from (5.14),
2

j=−2
ajsj = a−2s−2 + a−1s−1 + a0s0 + a1s1 + a2s2 =
= −a−2s−2 + a−1s−1 + a0s0 −a1s1 + a2s2 =
2

j=−2
aj˜sj,
from where it follows that
a−2 = a1 = 0.
(5.22)

292
|
Svetlana Selivanova
The identity for the invariant I1 from (5.16), looking as
2

j=−2
bj < Gj
2[2,2]s, s >=
2

j=−2
bj < Gj
2[2,2]˜s, ˜s >=
2

j=−2
bj < ATGj
2[2,2]As, s >,
gives
b−2 = b1 = 0.
(5.23)
Finally, the identity for the invariant I2 from (5.17) we have
4

j=−4
dj < Gj
4[2,2]s, s >=
4

j=−4
dj < Gj
4[2,2]˜s, ˜s >=
4

j=−4
dj < ATGj
4[2,2]As, s >,
from where
d−4 = d−2 = d1 = d3 = 0.
(5.24)
Consequently, for the monoclinic crystal system there are 21 −2 −2 −4 = 13
independent parameters which characterize the media. The quadratic invariants
look in this case as
J0 = c1p2, J1 =

a−1G−1
2[0,2] + a0G0
2[0,2] + a2G2
2[0,2]

sp,
I0 = c2(s, s), I1 =

b−1G−1
2[2,2] + b0G0
2[2,2] + b2G2
2[2,2]

s, s

,
(5.25)
I2 =

d−3G−3
4[2,2] + d−1G−1
4[2,2] + d0G0
4[2,2] + d2G2
4[2,2] + d4G4
4[2,2]

s, s

.
For the rhombic system < R2, L2 >, where
L2 =


−1
0
0
0
1
0
0
0
−1

= Uφ
(5.26)
for φ = π, we need one more matrix, corresponding to the rotation L2:
A = Aφ =


1
0
0
0
0
0
−1
0
0
0
0
0
1
0
0
0
0
0
−1
0
0
0
0
0
1


.
(5.27)
Besides the zero coeﬃcients obtained for the monoclinic system above, we have
a−1 = b−1 = d−1 = d−3 = 0.
(5.28)

Computing Clebsch-Gordan Matrices
|
293
The invariants look now like
J0 = c1p2, J1 = a0G0
2[0,2] + a2G2
2[0,2]sp,
I0 = c2(s, s), I1 =

b0G0
2[2,2] + b2G2
2[2,2]

s, s

,
(5.29)
I2 =

d0G0
4[2,2] + d2G2
4[2,2] + d4G4
4[2,2]

s, s)

.
For the ﬁve other crystal systems the independent parameters are calculated in
a similar way. By another method, using the contravariance of the Hook’s tensor,
this was done in [20].
For the isotropic case the only quadratic invariants are
J0 = c1p2, I0 = c2(s, s).
Finally, let us consider the example of linear elasticity theory, when the equations
can be written as follows:









ρ ∂ui
∂t −∂σij
∂xj
= 0,
∂εij
∂t −1
2( ∂ui
∂xj
+ ∂uj
∂xi
) = 0,
(5.30)
where i , j = 1 , 2, 3, ui are the velocities, εij = εji is the tensor of deformations
and σij = σji is the tensor of stresses. From the Hook’s law εij = cijklσkl,







ρ ∂ui
∂t −∂σij
∂xi
= 0,
cijkl ∂σkl
∂t
−1
2( ∂ui
∂xj
+ ∂uj
∂xi
) = 0.
(5.31)
It is a symmetric hyperbolic system (in the sense of Friedrichs [3]), which may
written, by means of Clebsch-Gordan matrices, in an invariant form (here v =
(u−1, u0, u1) is the velocity vector, p is pressure, s is the 5-dimensional vector de-
ﬁned in (5.4)):













A1 ∂
∂t v + ∆−s + ∆+p = 0,
ˆA ∂
∂t

p
s

+

∆−v(1)
0
0
∆+v(1)

= 0.
(5.32)
Here
∆−u(L) = c−(L)
1

i=−1
∂
∂xi
Gi
1[L−1,L]u(L),

294
|
Svetlana Selivanova
∆+u(L) = c+(L)
1

i=−1
∂
∂xi
Gi
1[L+1,L]u(L)
are invariant under rotations matrix diﬀerential operators. The ﬁrst of them lowers
the weight of the vector from L to L −1 (an analog of div), the second one makes
the weight bigger, from L to L + 1 (an analog of grad). The matrix ˆA looks as

A0
0
0
A2

+





0
2
j=−2
ajGj
2[0,2]
2
j=−2
ajGj
2[2,0]
2
j=−2
bjGj
2[2,2] +
4
j=−4
djGj
4[2,2]





(5.33)
Here
A0 = ˆc1G0
0[0,0] = ˆc1 =
1
3λ + 2µ , A2 = ˆc2G0
0[2,2] =








1
µ
1
µ
1
µ
1
µ
1
µ








,
where λ and µ are the Lame coeﬃcients In the isotropic case the constants ai, bi
and dj are equal to zero. For the triclinic system all of the 21 constants are present,
while for other crystal systems some of them are equal to zero or are linearly de-
pendent, as described above. In the case of nonlinear elasticity the systems (5.31)
and (5.32) look more complicated: the matrix by
∂
∂t is constructed from second
partial derivatives of the potential H from (5.1), which has to be a convex function,
and several other equations may be needed to add to the system, depending on
the model [20; 6; 10; 12].
Acknowledgement: I thank S.K. Godunov for suggesting me this problematic and
fruitful discussions, V.M. Gordienko for a consultation on his papers, the anony-
mous referee for useful remarks and references.
I am deeply grateful to Victor Selivanov, who was the ﬁrst to show me the
beauty of mathematics, for his permanent support and attention to my work.
Bibliography
[1]
Alex A., Kalus M., Huckleberry, A., von Delft, J. A numerical algorithm for the explicit calcu-
lation of SU(N) and SL(N,C) Clebsch-Gordan coeﬃcients. Journal of Mathematical Physics,
52:2, 023507, 2011.
[2]
Edmonds A. R. Angular Momentum in Quantum Mechanics. Princeton, New Jersey: Prince-
ton University Press, 1957.

Computing Clebsch-Gordan Matrices
|
295
[3]
Friedrichs K.O. Symmetric hyperbolic linear diﬀerential equations. Communica-
tion on Pure and Applied Mathematics, 7, 345–392, 1954.
[4]
Gelfand I. M., Milnos R. A., Shapiro E. Ya. Representations of the rotation group and the
Lorentz group. M., 1958. (Russian)
[5]
Gliske S., Klink W. H., Ton-That T. Algorithms for Computing U(N) Clebsch-Gordan Coeﬃ-
cients. Acta Applicandae Mathematicae 95:1, 51–72, 2007.
[6]
Godunov S.K. The equation of elasticity with dissipation as a nontrivial example of ther-
modynamically consistent hyperbolic equations. J. Hyperbolic Diﬀ. Equat., 1:4, 235–249,
2004.
[7]
Godunov S.K., Gordienko V.M. The Clebsch-Gordan coeﬃcients with respect to various
bases for unitary and orthogonal representations of SU(2) and SO(3). Siberian Mathe-
matical Journal, 45:3, 443–458, 2004.
[8]
Godunov S.K., Gordienko V.M. Complicated structures of Galilean-invariant conservation
laws. Applied Mechanics and Technichal Physics, 43:2, 175–189, 2002.
[9]
Godunov S.K., Mikhailova T.Yu. Representations of the rotation group an spherical func-
tions. Novosibirsk,“Nauchnaya kniga”, 1998. (Russian)
[10] Godunov S. K., Peshkov I. M. Symmetric hyperbolic equations in the nonlinear elasticity
theory. Zh. Vychisl. Mat. Mat. Fiz., 48:6, 1034–1055, 2008.
[11]
Godunov S.K., Romenskii E. I. Elements of Continuum Mechanics and Conservation Laws,
Novosibirsk, Nauchnaya Kniga Publishers, 1998. (Russian)
[12] Godunov S. K., Mikhailova T. Yu., Romenskii E. I. Systems of thermodynamically coordi-
nated laws of conservation invariant under rotations. Siberian Mathematical Journal, 37:4,
690–705, 1996.
[13] Gordienko V.M. Matrix entries of real representations of the groups O(3) and SO(3).
Siberian Mathematical Journal 43:1, 51–63, 2002.
[14] Karasev V.P., Shelepin V.A. Finite diﬀerences, Clebsch-Gordan coeﬃcients, and hypergeo-
metric functions. Theoretical and Mathematical Physics, 17, 991–998, 1973.
[15]
Landau L. D., Lifshitz E. M., Kosevich A. M., Pitaevskii L.P. Elasticity theory. Elsevier, 1986.
[16] Mikhailova T. Yu. Thermodynamically consistent conservation laws with unknowns of
arbitrary weight Siberian Mathematical Journal, 38:3, 528–538, 1997.
[17]
Miller W. Symmetry and separation of variables. Addison-Wesley, Reading, Mas-
sachusetts, 1977.
[18] Peshkov I. M. Numerical simulation of discontinuous solutions in nonlinear elasticity
theory. Journal of applied mechanics and technical physics, 50:5, 858–865, 2009.
[19] Sedov L.I. A Course in Continuum Mechanics: Basic equations and analytical techniques.
Wolters-Noordhoﬀ, 1971.
[20] Selivanova S.V. Invariant recording of elasticity theory equations. Journal of Applied Me-
chanics and Technical Physics 49:5, 809–822, 2008.
[21] Shelepin L.A. Calculus of Clebsch-Gordan coeﬃcients and its physical applications.
Proceedings of the Lebedev Physical Institute 70, 1–114, New York, 1975.
[22] Steigmann D.J. Invariants of the Stretch Tensors and their Application to Finite Elasticity
Theory. Mathematics and Mechanics of Solids 7:4, 393–404, 2002.
[23] Sternberg S. Group theory and physics. Cambridge University press, 1994.
[24] Vilenkin N.Ya. Special functions and representation theory. M., “Nauka”, 1965. (Russian)


Nikolay V. Shilov
An Approach to Design of Automata-Based
Axiomatization for Propositional Program
and Temporal Logics (by Example of Linear
Temporal Logic)¹
Abstract: This paper presents an approach to design of axiomatic system for
propositional program and temporal logics. The approach is presented by exam-
ple of development of a sound and complete axiomatization for Propositional
Linear Temporal Logic (PLTL). This logic is a very popular formalism for speciﬁ-
cation and veriﬁcation of computer programs and systems. The resulting tableau-
like axiomatization for PLTL is based on automata-theoretic decision procedure
coupled with tableau for local model checking of the propositional µ-Calculus.
Keywords: Propositional linear temporal logic, axiomatization, automata on inﬁ-
nite words, propositional mu-Calculus, model checking
Mathematics Subject Classiﬁcation 2010: 03B44, 03D05
||
Nikolay V. Shilov: A.P. Ershov Institute of Informatics Systems, Siberian Division of the Russian
Academy of Sciences, and Novosibirsk State University, Russia
1 Introduction
The primary purpose of a research presented in this paper is study how to convert
automata-theoretic decision procedures for propositional temporal and program
logics into axiomatization of these logics. From puristic viewpoint the purpose is
a controversial from the very beginning because decidability means recursiveness
of the set of valid formulas while axiomatisability means that the set is recursively
enumerable. But axiomatization means also formulation of some axioms and infer-
ence rules that are capable (altogether) to generate all valid statements by purely
syntactic inference machine, while logic decision procedures may be variable in
their nature: they can be model-theoretic, base on reduction to other decidable
results, interpretation in decidable theories, etc. So the problem under study is
1 This research is supported by grant of Russian Foundation for Basic Research (RFBR)13-01-00645.

298
|
Nikolay V. Shilov
similar (from methodological point of view) to a classical problem for formal lan-
guages: we are given a class of automata that are recognizers for formal languages
and need to build a class of grammars that are generators for these formal lan-
guages.
In particular, the paper presents how to convert a decision procedure (that
is based on translation to automata) into axiomatization for Propositional Lin-
ear Temporal Logic (PLTL). This logic is a very popular formalism for speciﬁca-
tion and veriﬁcation of computer programs and systems [20; 6]. Fundamental re-
sults on decidability, model checking, and axiomatization for PLTL have become
a part of the Computer Science classics [11; 24]. Automata-theoretic technique [27]
has proved its utility for propositional modal logics of programs. In particular,
PSPACE-completeness for PLTL has been proved in this technique [26].
Later the automata-theoretic approach has been extended to model checking
[6]. For example, PLTL model checker SPIN [15] employs emptyness algorithm for
product of Büchi automata. Maybe, the most impressive demonstration of utility
and eﬃciency of automata-based model checking is veriﬁcation of key parts of the
multithreaded code of Curiosity Mars rover mission for possible race conditions or
deadlocks [16]:
We analyzed ﬁve critical subsystems of the control software’s in this way. In one case our
ﬁndings led to a complete redesign of the subsystem to prevent the types of problems that
the model checker had uncovered.
The axiomatization issues for PLTL have been studied ﬁrst on base of modal logic
tradition [14]. But tableau and tableau-base decision procedure for PLTL have
been developed with aid of automata-theoretic technique also [28]. A comprehen-
sive study of tableaux for ﬁrst-order temporal logics can be found in [17]. Tableau
for combinations of temporal logics with other modal logics became a research
topic in recent years [19; 10].
At the same time a so called clausal resolution approach for axiomatization of
diﬀerent propositional temporal logic was under development. General outlines
of this method has been presented in [12] for propositional linear temporal logic
with future and past modalities and operators. The method is based on classical
resolution augmented by temporal resolution rule. A special Separated Normal
Form (SNF) has been deﬁned for these purposes. For branching time temporal
logic CTL a clausal resolution system has been developed in [1]. Algorithmical is-
sues of CTL resolution theorem prover have been discussed in [2]. A recent devel-
opment for branching time propositional logic is sound and complete clausal res-
olution system for ECTL+ [4]. For PLTL a sound and complete clausal resolution

Design of Automata-Based Axiomatization
|
299
has been developed in [13] and then improved in [9]. Connection between inﬁnite
automata and SNF has been examined in [3].
In this paper we develop sound and complete experimental tableau-like ax-
iomatization for PLTL. This axiomatization comprises rewriting rules that simplify
formulae (table 1), and a ‘tableau’ (table 5). But basically this axiomatization is au-
tomata decision procedure augmented by model checking deciding automata as a
ﬁnite model. A deduction strategy within the axiomatization consists of a number
of stages. These stages are sketched below along with outlines of the rest of the pa-
per. Basically our axiomatization is ‘retrieved’ from automata-theoretic decision
procedure.
In the section 2 we introduce the rewriting rules that eliminate negations out-
side literals and emulate subformulae of until constructs U by new propositional
symbols. The rules preserve tautologies and lead to a so-called simple formulae.
In the section 3 we study a special class of automata on inﬁnite words. An au-
tomaton in this class accepts an inﬁnite word as soon as it enters any accepting
control state. A (fairness) constraint is a set of input symbols. An inﬁnite word is
bounded by the constraint iﬀall speciﬁed symbols occur ﬁnite number of times
at most. The halting (termination) problem with the constraint consists in check-
ing whether an automaton accepts all inﬁnite words that are bounded by the con-
straint (if it is the case than we say that the automaton totally accept the con-
straint). Lemma 23 proves that the problem is decidable. In principle the problem
can be solved by Büchi automata, but in this paper a closely related but original
methods is presented due to its convenience for developing an axiomatization².
In the section 4 we translate simple formulae of PLTL into automata with fair-
ness constraint. Control states of the automata are ﬁnite sets of formulae. The
main property of this translation is captured in lemma 25: a formula is a tautol-
ogy iﬀthe automaton totally accepts the constraint.
In the section 5 the automata are considered as ﬁnite labeled transition sys-
tems (i.e. Kripke structures) for the propositional µ-Calculus [18], and the halting
problem with constrains is encoded by a particular formula of the µ-Calculus. An
automaton totally accepts a constraint iﬀthe formula holds in some initial state
of the corresponding model (see lemma 34). In simple words: we interpret halting
problem with fairness constraint as the local model checking problem for some
ﬁxed formula of the propositional µ-Calculus.
2 We do believe that automata-theoretic approach to decidability can exploit diﬀerent variants of
automata, not necessary well-known (i.e. Büchi or Rabin) automata [25]. For example, it was the
case [23], when elementary decidability has been established for Propositional Dynamic Logic
with looping and converse.

300
|
Nikolay V. Shilov
In the section 6 we adopt sound and complete tableau designed for local
model checking for the µ-Calculus in ﬁnite model [7] and convert it into a tableau-
like axiomatization of PLTL.
In the last section 7 we summarize, point out some topics for further research
and discuss motivation behind development of the presented approach to axiom-
atization.
2 Propositional Linear Temporal Logic
Let Prp be an inﬁnite set of propositional symbols.
Deﬁnition 1. The syntax of the Propositional Linear Time Logic (PLTL) consists
of formulae that are deﬁned by induction as follows:
–
every propositional symbol is a formula;
–
negation (¬ϕ) is a formula;
–
conjunction (ϕ ∧ψ) and disjunction (ϕ ∨ψ) are formulae;
–
nextime (◦ϕ), always (□ϕ), and eventual (♦ϕ) are formulae;
–
until (ϕUψ) and unless (ϕWψ) are formulae³.
Let Prp(ξ) be the set of all propositional symbols that occur in a formula ξ. Every
substring of a formula that is a formula itself is said to a subformula; let Sub(ξ) be
the set of all subformulae of a formula ξ. We exploit the standard abbreviations
(ϕ →ψ) and (ϕ ↔ψ) for ((¬ϕ) ∨ψ) and for ((ϕ →ψ) ∧(ψ →ϕ)) respectively.
Frequently we omit the most external parenthesis in small formulae and some
parenthesis inside formulae in accordance with the standard rules of operation
precedence: ¬, ◦, □, ♦, ∧, ∨, →, ↔.
Deﬁnition 2. (Bounded) linear structure is a pair of the form (V, B) where
–
the bound B ⊆Prp is a ﬁnite set of propositional symbols,
–
the valuation sequence V is a sequence of sets of propositional symbols
V0, . . . Vi, · · · ⊆B .
3 As follows from the deﬁnition 5 below, unless can be expressed in terms of always and until, i.e.
one can consider it as a derivable construct. But it helps a little bit in representation of formula
transformation into normal form according to thr deﬁnition 6.

Design of Automata-Based Axiomatization
|
301
Deﬁnition 3. If (V, B) and (U, C) are two bounded linear structures such that
B ⊆C and Vi = (Ui ∩B) for every i ≥0, then (U, C) is said to be a (semantics)
extension of (V, B) on (propositional symbols in) C \ B.
Deﬁnition 4. A point is a triple of the form (V, B, i) where i ≥0 is an integer and
(V, B) is a bounded linear structure.
Deﬁnition 5. Semantics of PLTL is deﬁned in terms of the satisfyability relation
|= between points and formulae by induction on formula structure⁴:
–
(V, B, i) |= p iﬀp ∈Vi for p ∈Prp;
–
(V, B, i) |= (¬ϕ) iﬀ(V, B, i) |=/ ϕ;
–
(V, B, i) |= (ϕ ∧ψ) iﬀ(V, B, i) |= ϕ and (V, B, i) |= ψ,
(V, B, i) |= (ϕ ∨ψ) iﬀ(V, B, i) |= ϕ or (V, B, i) |= ψ;
–
(V, B, i) |= (◦ϕ) iﬀ(V, B, i + 1) |= ϕ,
(V, B, i) |= (□ϕ) iﬀ(V, B, j) |= ϕ for every j ≥i,
(V, B, i) |= (♦ϕ) iﬀ(V, B, j) |= ϕ for some j ≥i;
–
(V, B, i) |= (ϕUψ) iﬀ(V, B, k) |= ψ for some k ≥i and
(V, B, j) |= ϕ for every j ∈[i..k[,
(V, B, i) |= (ϕWψ) iﬀ(V, B, i) |= (□ϕ) or (V, B, i) |= (ϕUψ).
A formula is said to be a tautology iﬀit holds in every point. Formulae are said
to be equivalent iﬀthey have equal semantics (i.e. for every point they hold or do
not hold in the point simultaneously). As usual, formulae ϕ and ψ are equivalent
iﬀthe formula (ϕ ↔ψ) is a tautology. A literal is a propositional symbol or its
negation.
Deﬁnition 6. Normal formulae are formulae that do not use abbreviations →and
↔, and that can use the negation in literals only. Simple formulae are normal for-
mulae that do not use W operator and that can use U operator with propositional
symbols only.
Every PLTL formula is equivalent to some normal formula due to standard ‘nor-
malizing’ De-Morgan-like tautologies
¬¬ϕ ↔ϕ
¬ ◦ϕ ↔◦¬ϕ
¬□ϕ ↔♦¬ϕ
¬♦ϕ ↔□¬ϕ
¬(ϕ ∧ψ) ↔¬ϕ ∨¬ψ
¬(ϕ ∨ψ) ↔¬ϕ ∧¬ψ
4 We assume Prp(ϕ) ∪Prp(ϕ) ⊆B.

302
|
Nikolay V. Shilov
¬(ϕUψ) ↔¬ψW(¬ϕ ∧¬ψ)
¬(ϕWψ) ↔¬ψU(¬ϕ ∧¬ψ)
The major disadvantage of this normalization is exponential space complexity
(since it multiplies copies of some subformulae). We overcome this problem by
shifting equivalence to metaequivalence as follows.
Deﬁnition 7. Formulae ϕ and ψ are metaequivalent ( ϕ
<↔ψ) iﬀfor every point
(V, B, i) the following holds:
(V, B, i) |= ϕ
⇕
(U, C, i) |= ψ for every extension (U, C) of (V, B) on C \ B.
The equivalence implies the metaequivalence but not vice versa. The metaequiv-
alence is not a symmetric, but metaequivalent formulae are tautologies or are not
tautologies simultaneously.
A new (or fresh) propositional symbol is a symbol from inﬁnite alphabet Prp
that has not been used yet. Syntax substitution of some object instead of (any/all)
instance(s) of some target in a subject is denoted by subjectobject
target.
Lemma 8. For every formula ξ, every its subformula θ that is out of scope of any
negation in ξ, and every new propositional symbol p the formulae ξ and □(θ →
p) →ξ p
θ are metaequivalent: ξ
<↔□(θ →p) →ξ p
θ .
(Let us remark for justiﬁcation that □(θ →p) implies that p is interpreted as θ at
least; at the same time ξ p
θ is monotonous on p since p replaces positive instances
of θ.)
Combining lemma 8 with another tautology ϕWψ ↔□ϕ ∨(ϕUψ) we can
formulate the following lemma.
Lemma 9. For every formula ξ, all its subformulae ϕ and ψ, and new propositional
symbols p and q the following metaequivalences hold as soon as all substitutions
are out of the range of any negation:
–
ξ
<↔□((ϕ →p) ∧(ψ →q)) →ξ pUq
ϕUψ,
–
ξ
<↔□((ϕ →p) ∧(ψ →q)) →ξ□p∨(pUq)
ϕWψ
.
Combining the normalizing equivalences with lemma 9 we get the following
proposition.
Proposition 10. Every formula is metaequivalent to some simple formula that can
be constructed in polynomial time by the rewriting system presented in table 1.

Design of Automata-Based Axiomatization
|
303
ζ ⇒ζφ
¬¬φ
ζ ⇒ζ◦¬φ
¬◦φ
ζ ⇒ζ↔♦¬φ
¬□φ
ζ ⇒ζ□¬φ
¬♦φ
ζ ⇒ζ¬φ∨¬ψ
¬(φ∧ψ)
ζ ⇒ζ¬φ∧¬ψ
¬(φ∨ψ)
ζ ⇒□((¬φ →p) ∧(¬ψ →q)) →ζ□p∨(pU(p∧q))
¬(φUψ)
ζ ⇒□((¬φ →p) ∧(¬ψ →q)) →ζpU(p∧q)
¬(φWψ)
ζ ⇒□((φ →p) ∧(ψ →q)) →ζpUq
φUψ
ζ ⇒□((φ →p) ∧(ψ →q)) →ζ□p∨(pUq)
φWψ
(where p and q are new propositional symbols)
Table 1: Rewriting rules for simpliﬁcation
3 Stuttering Automata with Fairness Constraint
Speaking informally, a stuttering automaton is just a nondeterministic ﬁnite au-
tomaton with the input alphabet consisting of subsets of some ﬁnite set⁵, that can
stutter (stay for awhile) on cells of the input tape. The ﬁnite set mention above
is the set of all propositional variables that are in use in a formula to be veriﬁed.
Subsets of this set are sets of propositional variables, they serve as input symbols.
One can think about each of these “symbols” as about collection of propositional
variables to be interpreted as valid at current moment of time, while propositional
variables that are not in this “symbol” are to be interpreted as invalid at this mo-
ment. A stuttering automaton reads (stuttering sometimes, i.e. with pauses) the
input tape with a sequence of these “symbol” simulating formula veriﬁcation in
the corresponding model for PLTL.
Deﬁnition 11. A stuttering automaton is a tuple (Sts, Bnd, Ini, Fin, Prg) where
–
Sts is a ﬁnite set of control states, Ini and Fin are subsets of Sts that comprise
initial and ﬁnal states;
5 This choice of the alphabet is motivated by intention to represent bounded linear structures (i.e.
a models for PLTL), not study of automata properties on themselves.

304
|
Nikolay V. Shilov
–
Bnd is a ﬁnite set, called the bound, while the powerset 2Bnd is called the
input alphabet;
–
Prg is the program that consists of transitions of 2 types:
–
reading type (q′, S) →q′′,
–
moving type (q′, S, next) →q′′,
where q′, q′′ ∈Sts, S ⊆Bnd, and next is a special reserved symbol.
The stuttering automata work on countable sequences of input symbols. Every se-
quence of this kind can be thought as input tape consisting of cells (or positions)
that are enumerated and that contain subsets of the bound set per cell. Every stut-
tering automaton has a pointer (ore reading head) that every time points to a cell
of the input tape and can remains in this position or move to the next cell to the
right.
Deﬁnition 12. Let (Sts, Bnd, Ini, Fin, Prg) be a stuttering automaton. A conﬁgu-
ration of the automaton is a triple (W, i, q) that comprises an inﬁnite word W ∈
(2Bnd)ω (input tape), an integer i ≥0 (pointer position), and a control state q ∈Sts.
We say that a conﬁguration (W, i, q) contains the word W. A conﬁguration is said
to be initial iﬀi = 0 and q ∈Ini (i.e. the pointer is on the leftmost cell and the
automaton is in an initial state). A conﬁguration is said to be ﬁnal iﬀq ∈Fin (the
automaton is in a ﬁnal state).
Deﬁnition 13. Let (Sts, Bnd, Ini, Fin, Prg) be a stuttering automaton. The au-
tomaton shifts from one conﬁguration to another in accordance with the program:
it can shift from (W, i, q′) to
–
(W, i, q′′) iﬀ(q′, Wi) →q′′ ∈Prg,
–
(W, (i + 1), q′′) iﬀ(q′, Wi, next) →q′′ ∈Prg,
where Wi ⊆Bnd is the i-th element of the sequence W.
Deﬁnition 14. For a given stuttering automaton A shifting is a binary relation →A
on its conﬁgurations: for every pair of conﬁgurations c′ abd c′′, we write c′ →A c′′
iﬀA can shift from c′ to c′′. We denote by →∗
A the reﬂexive and transitive closure
of the binary relation →A.
Deﬁnition 15. A stuttering automaton A accepts an inﬁnite word W (written in
its input alphabet) iﬀthere are an initial conﬁguration c′ and a ﬁnal conﬁguration
c′′ such that c′ and c′′ both contain the word W and c′ →∗
A c′′. The language of
the automaton L(A) comprises all inﬁnite words that the automaton accepts. The
automaton A is said to be total iﬀL(A) comprises all inﬁnite words (2B)ω.

Design of Automata-Based Axiomatization
|
305
Now we are going to deﬁne a very important notion of fairness constraint.
Deﬁnition 16. Let D be some set, seq ∈Dω be an inﬁnite sequence of elements
in D, and (P : D →Bool) be some property of elements in D. The sequence seq
is said to be fair with respect to the property P iﬀinﬁnitely many elements of the
sequence seq enjoy this property. In contrast, we say that the sequence seq is
bounded by the fairness constrain P iﬀthe property P holds ﬁnitely often at most
in seq (i.e. P does not hold after some point in seq).
We are most interested in some fairness constraint for stuttering automata.
Deﬁnition 17. Let Bnd be a ﬁnite set and S ⊆Bnd. A competence property PS is
the following predicate (S ∩T ̸= ∅) on subsets of Bnd.
The following lemma is straightforward⁶.
Lemma 18. Let Bnd be a ﬁnite set of propositional symbols, S ⊆Bnd, and W ∈
(2Bnd)ω be an inﬁnite word. Then W is bounded by fairness constraint PS iﬀall propo-
sitional symbols in S disappear after some position in W.
Deﬁnition 19. Let (Sts, Bnd, Ini, Fin, Prg) be a stuttering automaton, S ⊆Bnd
and PS be corresponding competence property. We say that the automaton A to-
tally meets the fairness constraint PS iﬀlanguage L(A) includes all inﬁnite words
W ∈(2B)ω that are bounded by the constraint PS.
In conjunction with lemma 18 it immediately implies the following lemma.
Lemma 20. Let (Sts, Bnd, Ini, Fin, Prg) be a stuttering automaton, S ⊆Bnd, and
PS be corresponding competence property. The automaton totally meets the fairness
constraint PS iﬀit accepts every inﬁnite word in (2Bnd)ω that contains ﬁnite (at most)
number of instances of symbols in S.
Deﬁnition 21. The total (halting, termination) problem for stuttering automata
with competence fairness constraint is to check for input stuttering automaton A
and input competence property PS whether the automaton A totally meets the
fairness constraint PS.
6 It explains the title ‘competence property’ for PS: the fairness constraint PS grants full rights
to elements in Bnd \ S while imposes right limitations for elements in S: the former can occur
inﬁnitely often, the later - ﬁnitely often at most.

306
|
Nikolay V. Shilov
There are several opportunities to decide the total problem for stuttering automata
with competence fairness constraint. The most high level but indirect approach
can exploit the formalism of Büchi automata and the decidability of the emptiness
problem for these automata. In contrast, let us present below a variant of a low
level but direct decision procedure.
Deﬁnition 22. Let A = (Sts, Bnd, Ini, Fin, Prg) and PS be particular stuttering
automaton and competence property. Let M be the set of control states that occur
in the right hand side of moving transitions.
–
For every T ⊆Bnd let us deﬁne a binary relation on states
T⇝⊆Sts×(M∪Fin):
q′
T⇝q′′ iﬀq′ ≡q′′ ∈Fin
or
there is some sequence of control states q0, . . . qn (n ≥0)
such that q′ = q0, (q0, T) →q1 ∈Prg, . . . (qn−1, T) →qn ∈
Prg, and (qn, T, next) →q′′ ∈Prg.
–
Let us extend
T⇝on 2Sts × 2M∪Fin as follows: Q′
T⇝Q′′ iﬀfor every q′′ ∈Q′′
there is some q′ ∈Q′ such that q′
T⇝q′′.
Informally speaking, on ﬁnal states the relation
T⇝on states does not evolve
further, and on non-ﬁnal states
T⇝it is the reﬂexive and transitive closure of
T-readings up to the ﬁrst T-move.
Proposition 23. The total problem for stuttering automata with competence fair-
ness constraint is decidable in time exponential in the size of the automaton.
Proof. The decision procedure is given in the table 3 (third column) in terms of
T⇝on 2Sts × 2M∪Fin. Please refer section 7 in the Appendix for correctness of this
procedure.
4 PLTL and Stuttering Automata
Below we present the algorithm of translation of simple formulae of PLTL to stut-
tering automata with fairness constraint. The algorithm inputs a simple formula
ξ and a set of propositional symbols B that includes all symbols that occur in ξ,
and outputs a stuttering automaton A(ξ, B) and two sets of new propositional
symbols F(ξ, B) and G(ξ, B). The description of the algorithm follows.
Let ξ be a simple formula and B ⊇Prp(ξ) be a set of propositional symbols.
Let us enumerate all instances of conjunctions ∧and modalities □within ξ; it

Design of Automata-Based Axiomatization
|
307
(p, S) →accept iﬀp ∈S
P(p) = p? ; accept
(¬p, S) →accept iﬀp /∈S
P(¬p) = ¬p? ; accept
(◦ϕ, S, next) →ϕ
P(◦ϕ) = next ; P(ϕ)
(□aϕ, S, next) →□aϕ iﬀga ∈S
P(□aϕ) = while ga? do next ; P(ϕ)
(□aϕ, S) →ϕ iﬀga /∈S
(♦ϕ, S) →ϕ
P(♦ϕ) = next* ; P(ϕ)
(♦ϕ, S, next) →♦ϕ
(ϕ ∧c ψ, S) →ϕ iﬀfc ∈S
P(ϕ ∧c ψ) = if fc then P(ϕ) else P(ψ)
(ϕ ∧c ψ, S) →ψ iﬀfc /∈S
(ϕ ∨ψ, S) →ϕ
P(ϕ ∨ψ) = P(ϕ) U P(ψ)
(ϕ ∨ψ, S) →ψ
(pUq, S) →q
P(pUq) = (p? ; next)* ; q? ; accept
(pUq, S, next) →pUq iﬀp ∈S
Table 2: Automaton program and its structured flowchart
gives us an opportunity to index conjunctions and always modalities and refer
every particular instance by the assigned index. Let C and A be set of indexes as-
signed to conjunctions and to □modalities by this enumeration. Let us assign a
new propositional symbol fc for every conjunction ∧c (c ∈C) and a new proposi-
tional symbol ga for every modality □a (a ∈A) within ξ. Let F(ξ, B) be {fc : c ∈C}
and G(ξ, B) be {ga : a ∈A}.
The control states Sts of resulting automaton are subformulae of the formula
ξ extended by a special state accept. The initial state is the formula ξ, the ﬁ-
nal state is accept: Ini = {ξ} and Fin = {accept}. The input alphabet bound
Bnd is B ∪F(ξ, B) ∪G(ξ, B), i.e. the input alphabet comprises all sets of proposi-
tional symbols in B and new propositional symbols associated with conjunctions
and □modalities in the formula ξ. The program Prg of the automaton A(ξ, B) is
presented in the table 2 in structured and unstructured forms. In structured for-
malism we exploit ; for sequencing, U for non-deterministic choice, * for non-
deterministic iteration, if −then −else for deterministic choice, while −do î
for deterministic iteration. We also use tests of two kinds: if p is a propositional
symbol then the test p? means the p ∈Wnow and the test ¬p? means the p /∈Wnow,
where Wnow ⊆B ∪F(ξ, B) ∪G(ξ, B) is the currently reading position of the input
word W.
Lemma 24. Let ξ be a simple formula and B ⊇Prp(ξ) be a set of propositional
symbols. Let F = F(ξ, B) and G = G(ξ, B) be two sets of new propositional symbols

308
|
Nikolay V. Shilov
constructed in accordance with the translation algorithm. Then for every subformula
θ of the formula ξ, for every point (V, B, i) the following holds:
(V, B, i) |= θ
iﬀ
the stuttering automaton
(
control states



({accept} ∪Sub(θ)) ,
bound



(B ∪F ∪G) ,
Ini states

{θ} ,
Fin states



{accept} ,
program

P(θ))
starting in position i accepts every extension (V, B ∪F ∪G) of
(V, B) on propositional symbols in F ∪G that is bounded by the
fairness constraint PG.
(In plain words: θ holds in the point (V, B, i) iﬀthe corresponding automaton ac-
cepts every word (Vi ∪Fi ∪Gi), (Vi+1 ∪Fi+1 ∪Gi+1), . . . , where Fi, Fi+1, · · · ⊆F
and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some j ≥i.)
Please refer section 7 in the Appendix for the proof. In turn, the above lemma 24
immediately implies the following proposition.
Proposition 25. Let ξ be a simple formula and B ⊇Prp(ξ) be a set of propositional
symbols. Let F = F(ξ, B) and G = G(ξ, B) be two sets of new propositional symbols
constructed in accordance with the translation algorithm. Then the following holds:
ξ is a tautology
iﬀ
the stuttering automaton
(({accept} ∪Sub(θ)) , (B ∪F ∪G) , {θ} , {accept} , P(θ))
totally accepts the fairness constraint PG.
By the way, propositions 10, 23, and 25 imply a well-known upper bound for de-
cidability of PLTL.
Corollary 26. PLTL is decidable in exponential time.

Design of Automata-Based Axiomatization
|
309
5 Model Checking Interpretation
Let {true, false} be Boolean constants, Var and Act be disjoint ﬁnite alphabets
of propositional and action variables respectively. For avoiding ambiguities, we
assume that these new alphabets Var and Act are disjoint with the alphabet of
propositional symbols Prp that are in use in PLTL.
Deﬁnition 27. The syntax of the propositional µ-Calculus (µC) consists of formu-
lae that are deﬁned by induction as follows:
–
every propositional variable is a formula;
–
negation (¬ϕ) is a formula;
–
conjunction (ϕ ∧ψ) and disjunction (ϕ ∨ψ) are formulae;
–
(⟨a⟩ϕ) and ([a]ϕ) are formulae for every a ∈Act;
–
the least (µx . ϕ) and the greatest (νx . ϕ) ﬁxpoints are formulae for every
x ∈Var without instances in the range of odd amount of negations in ϕ.
As in the PLTL framework, sometimes we omit the most external parenthesis in
small formulae and some parenthesis inside formulae in accordance with the
standard rules of boolean operation precedence. We also use syntax substitution
subjectobject
target and another related metanotation: let subject0
target(object) stay for
the object, and for let subjectn+1
target(object) stay for subject
subjectn
target(object)
target
every
n ≥0.
Semantics of µC is deﬁned in models that are called labeled transition sys-
tems in Computer Science or Kripke structures in modal logic tradition. For avoid-
ing ambiguities with PLTL, we use terminology and notation of modal logic for
reasoning about µC.
Deﬁnition 28. Every model M is a triple (D, R, E) where the universe D ̸= ∅
consists of worlds, the interpretation R : Act →2D×D assigns a binary relation
R(a) ⊆D × D to every action variable a, the evaluation E : Var →2D assigns a
monadic predicate E(x) ⊆D to every propositional variable x.
Models can be inﬁnite, but we are most interested in ﬁnite models only.
Deﬁnition 29. Semantics of µC is a ternary validity relation ||= between worlds,
models, and formulae. This relation is deﬁned by induction on formulae structure.
In ﬁnite models it can be deﬁned as follows:
–
w||=M true and w||=/ Mfalse,
w||=M x iﬀw ∈E(x) for x ∈Var;

310
|
Nikolay V. Shilov
–
w||=M (¬ϕ) iﬀw||=/ Mϕ;
–
w||=M (ϕ ∧ψ) iﬀw||=M ϕ and w||=M ψ,
w||=M (ϕ ∨ψ) iﬀw||=M ϕ or w||=M ψ;
–
w||=M ([a]ϕ) iﬀu||=M ϕ for every u such that (w, u) ∈R(a),
w||=M (⟨a⟩ϕ) iﬀu||=M ϕ for some u such that (w, u) ∈R(a);
–
w||=M νx.ϕ iﬀw||=M ϕn
x(true) for all n ≥0;
w||=M µx.ϕ iﬀw||=M ϕn
x(false) for some n ≥0.
(Informally speaking, νx.ϕ and µx.ϕ are abbreviations for inﬁnite conjunction

n≥0
ϕn
x(true)
and inﬁnite disjunction

n≥0
ϕn
x(false)
respectively.)
Model checking is testing a model against a formula. The global checking
problem consists in calculation of the set M(ξ) of all worlds of the input model
M where the input formula ξ is valid. The local checking problem consists in test-
ing the validity w||=M ξ of the input formula ξ in the input world w in the input
model M. We are most interested model checking of ﬁnite models.
Deﬁnition 30. Let x, y, Nice, and Fin be ﬁxed propositional variables, and
A, B ⊆Act be sets of action variables. Then let
–
GOOD be formula (Nice ∧
b∈B⟨b⟩y),
–
HALT be formula (Fin ∨x ∨
a∈A⟨a⟩x),
–
PROVER be formula (ν y.GOOD)(µ x.HALT)
Nice
.
Since deﬁnition 30 is obscure, let us explane the formulae were provided. Formula
νy.GOOD states that for every inﬁnite sequence acts of actions from B, there is a
path generated by exercising actions in this sequence such that Nice holds at each
state in the path. In PROVER, Nice is µx.HALT, which states that every inﬁnite
path labeled with actions from A eventually reaches a state where Fin holds. So
PROVER states that any inﬁnite sequence of actions from B labels some path in
such a way that if at any point the remaining actions all fall into A, then the path
eventually reaches a state where Fin holds.

Design of Automata-Based Axiomatization
|
311
Stages
Model checking
Decision procedure
Stage 1
H0 : = E(Fin) ; i : = 0 ;
H0 = {Q′ : Q′ ⊆Fin},
do Hi+1 : = Hi∪
Hi+1 = Hi ∪{Q′ :
∪

a∈A
R(a)−(Hi)

for every T ⊆(B \ S)
there is Q′′ ∈Hi
that Q′
T⇝Q′′}
until Hi ̸= Hi+1 ;
for every i ≥0,
H : = Hi ;
H = 
i≥0 Hi;
Stage 2
G0 : = H ; i : = 0 ;
G0 = H,
do Gi+1 : = Gi∩
Gi+1 = {Q′ ∈Gi :
∩
 
b∈B
R(b)−(Gi)

for every T ⊆B
there is Q′′ ∈Gi
that Q′
T⇝Q′′}
until Gi ̸= Gi+1 ;
for every n ≥0,
G : = Gi ;
G = 
i≥0 Gi;
Stage 3
M(PROVER) : = G
A totally meets the constraint PS
iﬀthere exists Target ∈G
that Target ⊆Ini
and Target ̸= ∅.
Table 3: Model checking and decision procedure
Lemma 31.
Let M = (D, R, E) be a ﬁnite model. Then global checking of formula PROVER in
M can be carried out by the algorithm⁷ in the table 3 (second column).
(For justiﬁcation observe that the algorithm is just a straightforward specialization
of semantics of µC for formula PROVER in ﬁnite models.)
We are especially interested in the model checking of PROVER in models that
are generated by stuttering automata with constraint.
Deﬁnition 32. Let A = (Sts, Bnd, Ini, Fin, Prg) and PS be a stuttering automa-
ton and a competence property. Let M(A, PS) be the following ﬁnite model
7 We exploit inverse for binary relations and inverse images: if r is a binary relation on a set D
with a subset S ⊆D, then r−= {(d′, d′′) : (d′′, d′) ∈r} is the inverse of r and r−(S) = {d′ ∈
D : (d′, d′′) ∈r for some d′′ ∈S} is the inverse image of S.

312
|
Nikolay V. Shilov
(D, R, E). The universe D is 2Sts, i.e. comprises all sets of control states. The
alphabet Act of action variables consists of the subsets of the bound Bnd, i.e. co-
incides with the input alphabet of the automaton: Act = 2Bnd. For every T ∈Act
let R(T) be
T⇝. The alphabet of propositional variables Var includes one ‘special’
variable Fin and two auxiliary variables x, y. The most important is evaluation of
the special variable: E(Fin) = 2Fin \ {∅}, i.e. it comprises all non-empty subsets
of the ﬁnal sets.
Deﬁnition 33. Let A = (Sts, Bnd, Ini, Fin, Prg) and PS be a stuttering automa-
ton and a competence property. The model checking interpretation for the total
problem for the automaton A with the fairness constraint PS consists in the ﬁnite
model M(A, PS) and two sets 2Bnd and 2Bnd\S adopted as A ⊆Act and B ⊆Act
in the formula PROVER.
The importance of the model checking interpretation follows from the next propo-
sition 34. The correctness of this proposition is due to the comparison of the sec-
ond and the third columns of the table 3.
Proposition 34.
A stuttering automaton A totally accepts a fairness constraint PS
iﬀ
Q||=M(A,PS) PROVER for some set Q of initial control states of A.
6 Axiomatization via Local Model Checking
There are two papers [7; 5] that have suggested tableau for local model checking
of formulae of the propositional µ-Calculus. The ﬁrst cited paper addresses ﬁnite
state systems, while the second one deals with inﬁnite systems as well as ﬁnite.
We prefer the system from [7] since we are interested in model checking interpre-
tation of the halting problem with fairness constraint, i.e. we are bound by ﬁnite
models M of the single formula PROVER. In the following paragraphs we sketch
the approach, the tableau, and soundness and completeness results from [7].
There are only 2 syntax diﬀerences between variants of the propositional µ-
Calculus, that was discussed in the section 5 and that is in use in [7]. First, the
set of propositional variables in [7] is divided on two disjoint sets: the variables
that can not be bound by ﬁxpoints and the variables that have to be bound by
ﬁxpoints; the former we refer as model constants, the later – as model variables.

Design of Automata-Based Axiomatization
|
313
νy.¬ψ(y)
↓
¬ψ(y)
↓
ψ(y)
↙
↘
νx.¬φ(x)
¬(⟨T⟩y)
for every
T ⊆Bnd
↓
↘
¬φ(x)
⟨T⟩y
↙
↓
↘
↘
¬(
T ⊆Bnd\S(¬⟨T⟩¬x))
Fin
¬x
y
↙
↗
↘

T ⊆Bnd\S(¬⟨T⟩¬x)
↗
x
↙
↗
¬⟨T⟩¬x
for every
T ⊆Bnd \ S
→⟨T⟩¬x
Fig. 1: Subformulae of νPROVER
Next, [7] exploits syntax without ∧, [ ], and µ. Both variants enjoy equal expressive
power due to standard De-Morgan-like tautologies: ϕ ∧ψ ↔¬(¬ϕ ∨¬ψ), [a]ϕ ↔
¬⟨a⟩¬ψ,
µx.ψ ↔¬(νx.(ψ¬x
x )). For avoiding ambiguities, we distinguish these
two variants and refer variant from [7] by acronym νC.
In particular, in the formula PROVER propositional variable Fin is a modal
constant and propositional auxiliary variables x and y are modal variables. νC-
representation of this formula is the following formula νPROVER:
νy.¬

νx.¬

ϕ(x)



Fin ∨¬x ∨¬

T⊆Bnd\S
¬(⟨T⟩¬x) 
∨ 
T⊆Bnd
¬(⟨T⟩y)



ψ(y)

.
The subformula relation (‘strict subterm’ in [7]) ≺is treated in pure syntax man-
ner like in PLTL: a subformula is a substring of the formula that is a formula it-
self. The complete graph of the immediate subformula relation for subformulae
of νPROVER is depicted in the ﬁgure 1.
The tableau from [7] is represented in the table 4. We only turned upside-down
all rules so that the goals are under subgoals (since we prefer proof-search tree to
grow upward). The proof rules operate on sequents of the form (H ⊢M w ∈ξ)
where ξ is a formula of νC, M is a ﬁnite model, w is a world and H is a set of
hypothesis (or assumptions) of the form (u : θ) where u is a world and θ is a closed

314
|
Nikolay V. Shilov
Axiom Schemata
H ⊢M w ∈p iﬀp is a modal constant and w ∈E(p)
H ⊢M w ∈¬p iﬀp is a modal constant and w /∈E(p)
H ⊢M w ∈¬(⟨a⟩ξ) iﬀ{v : (w, v) ∈R(a)} is empty set ∅
H ⊢M w ∈νx.ξ iﬀ(w : νx.ξ) ∈H
Inference Rules
H⊢Mw∈ξ
H⊢Mw∈¬¬ξ
H⊢Mw∈¬ξ , H⊢Mw∈¬θ
H⊢Mw∈¬(ξ∨θ)
H⊢Mw∈ξ
H⊢Mw∈ξ∨θ
H⊢Mw∈θ
H⊢Mw∈ξ∨θ
H⊢Mu∈ξ
H⊢Mw∈⟨a⟩ξ for u ∈{v : (w, v) ∈R(a)}
H⊢Mu1∈¬ξ ,... H⊢Mun∈¬ξ
H⊢Mw∈¬(⟨a⟩ξ)
where {u1, . . . un} = {v : (w, v) ∈R(a)}
H′∪{(w:νx.ξ)}⊢Mw∈ξνx.ξ
x
H⊢Mw∈νx.ξ
H′∪{(w:νx.ξ)}⊢Mw∈¬ξνx.ξ
x
H⊢Mw∈¬(νx.ξ)
where (w : νx.ξ) /∈H and H′ = H \ {(u : θ) : νx.ξ ≺θ}
Table 4: Sound and complete system for local model checking from [7].
ﬁxpoint formula. In formally speaking a sequent {(u1 : θ1), . . . (un : θn)} ⊢M w ∈
ξ means that if u1 ⊢M θ1, ... un ⊢M θn then w ⊢M ξ. [7] has proved the general
soundness and completeness results (theorems 4.18 and 4.19). We would like to
summarize them both in the following corollary.
Corollary 35.
For every formula ξ of νC, for every ﬁnite model M and every world w within this
model the following holds: ∅⊢M w ∈ξ iﬀw||=M ξ.
Our tableau-like deduction system in presented the table 5. This system is bound
for a target simple PLTL formulae η to be proved. In this system
–
W and U range over sets of subformulae of η extended by label accept,

Design of Automata-Based Axiomatization
|
315
–
H and H′ range over collections of assumptions in the form (W : νy.¬ψ(y))
or (U : νx.¬ϕ(x)), where νy.¬ψ(y) and νx.¬ϕ(y) are the only two closed
formulae in ﬁg. 1,
–
T ranges over sets of Prp(η) ∪F(η, Prp(η)) ∪G(η, Prp(η)) (i.e. are sets of
propositional symbols, conjunctions and always-modalities in η),
–
T⇝is the binary relation on sets of subformulae of η extended by label accept,
derived from the table 2,
–
ξ and θ range over νC-formulae in ﬁg. 1 with
Bnd = (Prp(η) ∪F(η, Prp(η)) ∪G(η, Prp(η)) and S = G(η, Prp(η),
–
≺is the subormula relation in ﬁg. 1.
At last we are ready to combine propositions 10, 23, 25, and 34 with corollary 35
and prove our soundness and completeness theorem.
Theorem 36. –
For all formulae ζ and η of PLTL, if ζ can be transformed to η by
rewriting rules in the table 1, then ζ is a tautology iﬀη is a tautology.
–
Every formula ζ of PLTL, can be transformed by rewriting rules in the table 1 to
some simple formula η of PLTL.
–
For every simple formula η of PLTL the following holds: η is a tautology iﬀthe
sequent (∅⊢{η} ∈νPROVER) is provable in the system presented in the table
5.
Remark: Table 5 inherited notation from the table 4 and [7]. In particular, in the
axiom schema
H ⊢W ∈Fin iﬀW = {accept}
Fin is a propositional variable of the formula PROVER, W is a world of the model
where worlds are sets of subformulas (of the PLTL formula to be veriﬁed) extended
by a special symbol accept, H ⊢W ∈Fin is a heritage of table 4 and [7] where
notation w ∈ξ represents that µC formula ξ holds in the world w of a model to be
checked.
7 Conclusion
We have presented in this paper how to develop sound and complete experimen-
tal tableau-like axiomatization for PLTL. This axiomatization has been ‘retrieved’
from automata-theoretic decision procedure with aid of tableau for local model
checking for the propositional µ-Calculus. We do believe that similar approach
should work for other propositional program and temporal logics with automata-

316
|
Nikolay V. Shilov
theoretic decision procedures in general and for the propositional µ-Calculus in
particular. Application of the approach to these logics is a topic for further re-
search.
The research presented in this paper was started in 2003, while author was
a visiting Erskine Fellow at University of Canterbury, Christchurch, New Zealand.
Arthur N. Prior (1914-1967), a founder of tense and temporal logics [21; 8], was Pro-
fessor of Philosophy at this university in 1952-1956. So the title of the paper could
be as follows: “Designing automata-based axiomatization for Propositional Lin-
ear Temporal Logic at home of Arthur Prior”. Preliminary version of this research
has been published as a position paper (without proofs) in the Proceedings of In-
ternational Conference TABLEAUX-2005 [22].
When the ﬁrst version of this paper has been submitted for review, an unan-
imous reviewer expressed a concern about motivation of the research and raised
some very important questions:
When building a complete axiomatization for some logic one may pursue various objects: to
express the basic principles of the logic, to formalize and alleviate deductive reasoning, to
support comparative analysis of logical systems, etc. Therefore, everybody who introduce a
new axiomatization of a well-known logic or a general approach to design complete axiomatic
systems for a whole family of logics must elucidate some issues. What is the use of the
axiomatization built with help of the approach introduced in the paper? What is it good
for? What new knowledge about, say, PLTL one can acquire from the new axiomatic system
introduced in the paper? What is the relationship between an automata-based axiomatization
of PLTL proposed in this paper and other axiomatic systems?
First I would like to thank the reviewer for very explicit formulation and questions.
Next I have to answer the questions. In some sense, sound and complete axioma-
tisation still is an art or a human craft. The paper claims that sometimes this craft
can be converted into a routing, assuming that automata-decision procedure is
available, and the automata property is expressible in terms of model checking
the automata diagram. But a further transformation of the resulting routing ax-
iomatization into human-friendly and human-valuable form, or to highly-eﬃcient
and easy-to-implement deductive procedure requires human contribution. It is a
topic for further research, whether the suggested axiomatization for PLTL can be
converted into any known human-friendly axiomatization or into a new eﬃcient
deductive procedure.
Bibliography
[1]
A. Bolotov and M. Fisher. A Resolution Method for CTL Branching-Time Temporal Logic,
Proceedings of the Fourth International Workshop on Temporal Representation and

Design of Automata-Based Axiomatization
|
317
Reasoning (TIME), IEEE Press, 20–27, 1997.
[2]
A. Bolotov and C. Dixon. Resolution for Branching-Time Temporal Logics: Applying the
Temporal Resolution Rule, Proceedings of the Seventh International Workshop on Tempo-
ral Representation and Reasoning (TIME’00), IEEE Computer Press, 163–172, 2000.
[3]
A. Bolotov, M. Fisher, and C. Dixon. On the Relationship Between Omega-Automata and
Temporal Logic Normal Forms, Journal of Logic and Computation, 12(4):561–581, 2002.
[4]
A. Bolotov and A. Basukoski. Clausal Resolution for Extended Computation Tree Logic
ECTL+, Proceedings of the Eleventh International Symposium on Temporal Representation
and Reasoning (TIME’04), IEEE Computer Press, 140–147, 2004.
[5]
J. Bradﬁeld and C. Stirling. Local model checking for inﬁnite state spaces, Theoretical
Computer Science, 96:157-174, 1992.
[6]
E.M. Clarke, O. Grumberg, and D. Peled. Model Checking, MIT Press, 1999.
[7]
R. Cleaveland. Tableau-based model checking in the propositional mu-calculus, Acta
Informatica, 27:725–747, 1990.
[8]
J. Copeland. Logic and reality : essays on the legacy of Arthur Prior, Clarendon Press and
Oxford University Press, 1996.
[9]
A. Degtyarev, M. Fisher, and B. Konev. A Simpliﬁed Clausal Resolution Procedure for
Propositional Linear-Time Temporal Logic, em Proc. TABLEAUX-02, Lecture Notes in Com-
puter Science, 2381:85–99, 2002.
[10] C. Dixon, C. Nalon, and M. Fisher. Tableaux for Temporal Logics of Knowledge: Syn-
chronous Systems of Perfect Recall or No Learning, em Proceedings of the Tenth In-
ternational Symposium on Temporal Representation and Reasoning and the Fourth
International Conference on Temporal Logic (TIME-ICTL 2003), 62–71, 2003.
[11]
E.A. Emerson. Temporal and Modal Logic, in Handbook of Theoretical Computer Science,
v.B, Elsilver and The MIT Press, 995–1072, 1990.
[12] M. Fisher. A Resolution Method for Temporal Logic, Proceedings of Twelfth International
Joint Conference on Artiﬁcial Intelligence (IJCAI), 99–104, 1991.
[13] M. Fisher, C. Dixon, and M. Peim. Clausal Temporal Resolution, ACM Transactions on
Computational Logic, 2(1):12–56, 2001.
[14] D.M. Gabbay, A. Pnueli, S. Shelah, J. Stavi. On the temporal analysis of fairness, Seventh
ACM Symposium on Principles of Programming Languages (PoPL), 163–173, 1980.
[15]
G.J. Holzmann Landing a Spacecraft on Mars, IEEE Software, 30(2):83–86, 2013.
[16] G.J. Holzmann. The Spin Model Checker — Primer and Reference Manual Addison-Wesley,
Reading Massachusetts, 2004.
[17]
R. Kontchakov, C. Lutz, F. Wolter, and M. Zakharyaschev. Temporal Tableaux Studia
Logica, 76(1):91–134, 2004.
[18] D. Kozen. Results on the Propositional Mu-Calculus. Theoretical Computer Science,
27:333–354, 1983.
[19] C. Lutz, H. Sturm, F. Wolter, and M. Zakharyaschev. Tableaux for Temporal Description
Logic with Constant Domain. Proceedings of the International Joint Conference on Auto-
mated Reasoning (IJCAR-01), Lecture Notes in Artiﬁcal Intelligence, 2083:121–136, 2001.
[20] Z. Manna and A. Pnueli. The temporal logic of Reactive and Concurrent Systems, Springer-
Verlag, 1991.
[21] A.N. Prior. Time and Modality, Oxford, Clarendon Press, 1957.
[22] N.V. Shilov. Tableau-like Axiomatization for Propositional Linear Temporal Logic. Proc. In-
tern. Conf. Automated Reasoning with Analytic Tableaux and Related Methods (TABLEAUX
2005), TABLEAUX 2005 Position Papers and Tutorial Descriptions, Fachberichte INFOR-

318
|
Nikolay V. Shilov
MATIK, Universitat Koblenz-Landau, Institut fur Informatik, technical report n.12/2005,
27–40, 2005.
[23] R.S. Street. Propositional Dynamic Logic of looping and converse is elementary decidable,
Infor. and Control, 54:121-141, 1982.
[24] C. Stirling. Modal and Temporal Logics, in Handbook of Logic in Computer Science, v.2,
Claredon Press, 477–563, 1992.
[25] Thomas W. Automata on inﬁnite objects, in Handbook of theoretical computer science, v.B,
MIT Press Cambridge, 133–191, 1990.
[26] M.Y. Vardi. An automata-theoretic approach to linear temporal logic, Logics for Concur-
rency: Structure versus Automata, Lecture Notes in Computer Science, 1043:238–266,
1996.
[27] M.Y. Vardi and P. Wolper. Automata-theoretic techniques for modal logic of programs. J.
Computer and System Sciences, 32:183–221, 1986.
[28] P. Wolper. The tableau method for temporal logic: An overview, Logique et Analyse,
28:119–136, 1985.
Appendix
Proof details for Proposition 23
First let us construct the set H of all sets of control states Q′ ⊆Sts such that for
every inﬁnite word W ∈(2Bnd)ω, for every i ≥0, if Wj ∩S = ∅for every j ≥i
then (W, i, q′) →∗
A (W, j, q′′) for some q′ ∈Q′, q′′ ∈Fin and j ≥i (i.e. starting
with some state q′ in Q′ the automaton eventually accepts the suﬃx WiWi+1 . . .
of the word W as soon as no symbol from S occurs in the suﬃx). This set H can be
constructed as ∪n≥0Hn where H0 ⊆H1 ⊆. . . Hn ⊆Hn+1 ⊆. . . is non-decreasing
sequence of sets Hn (n ≥0) of all sets of control states Q′ ⊆Sts such that for
every inﬁnite word W ∈(2Bnd)ω, for every i ≥0, if Wj ∩S = ∅for every j ≥i then
(W, i, q′) →∗
A (W, j, q′′) for some q′ ∈Q′, q′′ ∈Fin and j ∈[i..(i+n)] (i.e. starting
with some state q′ in Q′ the automaton accepts the suﬃx WiWi+1 . . . of the word
W after n moves at most as soon as no symbol from S occurs in the suﬃx). It is
easy to see that H0 = {Q′ : Q′ ⊆Fin} and Hn+1 = Hn ∪{Q′ : for every T ⊆
(B \ S) there exists some Q′′ ∈Hn such that Q′
T⇝Q′′} for every n ≥0.
Next let us construct the set G of all sets of control states Q′ ⊆Sts such that
for every inﬁnite word W ∈(2Bnd)ω, for every i ≥0, if W is bounded by the fair-
ness constraint PS then (W, i, q′) →∗
A (W, j, q′′) for some q′ ∈Q′, q′′ ∈Fin and
j ≥i (i.e. starting with some state q′ in Q′ the automaton eventually accepts the
suﬃx WiWi+1 . . . of the word W as soon as the suﬃx is bounded by the fairness
constraint). This set G can be constructed as ∩n≥0Gn where G0 ⊇G1 ⊇. . . Gn ⊇
Gn+1 ⊇. . . is non-increasing sequence of sets Gn (n ≥0) of all sets of control

Design of Automata-Based Axiomatization
|
319
states Q′ ⊆Sts such that for every inﬁnite word W ∈(2B)ω, for every i ≥0, if
Wj ∩S = ∅for every j ≥(i + n) then (W, i, q′) →∗
A (W, k, q′′) for some q′ ∈Q′,
q′′ ∈Fin and k ≥i (i.e. starting with some state q′ in Q′ the automaton accepts
the suﬃx WiWi+1 . . . of the word W as soon as no symbol from S occurs in the
suﬃx after position (i + n)). It is easy to see that G0 = H and Gn+1 = {Q′ ∈Gn :
for every T ⊆B there exists some Q′′ ∈Gn such that Q′
T⇝Q′′} for every n ≥0.
Finally we have: the automaton A totally meets the fairness constraint PS
iﬀthere exists a non-empty subset of the initial states Target ⊆Ini such that
Target ∈G. It ﬁnishes a sketch of the direct decision procedure.
Proof of Lemma 24
Induction of subformulae structure. Here we extensively exploit structured nota-
tion.
–
If θ is a propositional symbol or negation of a propositional symbol then proof
is straightforward. For example, let θ be a propositional symbol p and let
(VB, i) be a point. Then we have:
(VB, i) |= θ
⇔
p ∈VB
i
⇔
p ∈(VB
i ∪Fi ∪Gi) for every Fi ⊆F and Gi ⊆G
⇔
the automaton
({p, accept}, (B ∪F ∪G), {p}, {accept}, {(p, S) →accept : p ∈S})
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i.
–
If θ is pUq then we have:
(VB, i) |= θ
⇔
(VB, k) |= q for some k ≥i and (VB, j) |= p for all j ∈[i..k[
⇔
q ∈VB
k for some k ≥i and p ∈VB
j for all j ∈[i..k[
⇔
the automaton
({q, pUq, accept}, (B ∪F ∪G), { pUq}, {accept},
{(pUq, S) →q : S ⊂B ∪F ∪G}
∪{(pUq, S, next) →pUq : p ∈S} ∪{(q, S) →accept : q ∈S})

320
|
Nikolay V. Shilov
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . (VB
k ∪Fk ∪Gk),
(VB
k+1 ∪Fk+1 ∪Gk+1), . . . , where Fi, Fi+1, . . . , Fk, Fk+1, · · · ⊆F and Gi,
Gi+1, . . . , Gk, Gk+1, · · · ⊆G, but ∅= Gl = Gl+1 = . . . for some l ≥k
⇔
the automaton
({q, pUq, accept}, (B ∪F ∪G), { pUq}, {accept},
{(pUq, S) →q : S ⊂B ∪F ∪G} ∪{(pUq, S, next) →pUq : p ∈S}
∪{(q, S) →accept : q ∈S})
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1∪Fi+1∪Gi+1), . . . where Fi, Fi+1,
· · · ⊆F and Gi, Gi+1, · · · ⊆G, but ∅= Gj = Gj+1 = . . . for some j ≥i.
–
If θ is ◦ϕ then we have:
(VB, i) |= θ
⇔
(VB, i + 1) |= ϕ
⇔
the automaton
({accept} ∪Sub(ϕ), (B ∪F ∪G), {ϕ}, {accept}, P(ϕ))
accepts every word (VB
i+1 ∪Fi+1 ∪Gi+1), (VB
i+2 ∪Fi+2 ∪Gi+2), . . . , where
Fi+1, Fi+2, · · · ⊆F and Gi+1, Gi+2, · · · ⊆G but ∅= Gj = Gj+1 = . . . for
some j ≥i + 1
⇔
the automaton
({accept} ∪Sub(θ), (B ∪F ∪G), {θ}, {accept}, (next ; P(ϕ)))
accepts every word (VB
i ∪Fi∪Gi), (VB
i+1∪Fi+1∪Gi+1), (VB
i+2∪Fi+2∪Gi+2),
. . . , where Fi, Fi+1, Fi+2, · · · ⊆F and Gi, Gi+1, Gi+2, · · · ⊆G but ∅= Gj =
Gj+1 = . . . for some j ≥i + 1
⇔
the automaton
({accept} ∪Sub(θ), (B ∪F ∪G), {θ}, {accept}, P(θ))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i.
–
If θ is □aϕ then we have: (VB, i) |= θ ⇔(VB, j) |= ϕ for every j ≥i
⇔
for every j ≥i the automaton
({accept} ∪Sub(ϕ), (B ∪F ∪G), {ϕ}, {accept}, P(ϕ))
accepts every word (VB
j ∪Fj ∪Gj), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fj,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gk = Gk+1 = . . . for some
k ≥j

Design of Automata-Based Axiomatization
|
321
⇔
for every j ≥i the automaton
({accept}∪Sub(θ), (B∪F∪G), {θ}, {accept}, (while ga?do next ; P(ϕ)))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . (VB
j ∪Fj ∪Gj),
(VB
j+1 ∪Fj+1 ∪Gj+1), . . . , where Fi, Fi+1, . . . , Fj, Fj+1, · · · ⊆F and Gi,
Gi+1, . . . , Gj, Gj+1, · · · ⊆G, ga ∈Gi, ga ∈Gi+1, . . . , ga ∈Gj−1, but
ga /∈Gj and ∅= Gk = Gk+1 = . . . for some k ≥j
⇔
the automaton
({accept} ∪Sub(θ), (B ∪F ∪G), {θ}, {accept}, P(θ))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i.
–
If θ is ♦ϕ then we have:
(VB, i) |= θ ⇔(VB, j) |= ϕ for some j ≥i
⇔
for some j ≥i the automaton
({accept} ∪Sub(ϕ), (B ∪F ∪G), {ϕ}, {accept}, P(ϕ))
accepts every word (VB
j ∪Fj ∪Gj), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fj,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gk = Gk+1 = . . . for some
k ≥j
⇔
for some j ≥i the automaton
({accept} ∪Sub(θ), (B ∪F ∪G), {θ}, {accept}, (next* ; P(ϕ)))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . (VB
j ∪Fj ∪Gj),
(VB
j+1 ∪Fj+1 ∪Gj+1), . . . , where Fi, Fi+1, . . . , Fj, Fj+1, · · · ⊆F and Gi,
Gi+1, . . . , Gj, Gj+1, · · · ⊆G, but ∅= Gk = Gk+1 = . . . for some k ≥j
⇔
the automaton
({accept} ∪Sub(θ), (B ∪F ∪G), {θ}, {accept}, P(θ))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i.
–
If θ is ϕ ∧c ψ then we have:
(VB, i) |= θ ⇔(VB, i) |= ϕ and (VB, i) |= ψ
⇔
the automaton
({accept} ∪Sub(ϕ), (B ∪F ∪G), {ϕ}, {accept}, P(ϕ))

322
|
Nikolay V. Shilov
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i and the automaton
({accept} ∪Sub(ψ), (B ∪F ∪G), {ψ}, {accept}, P(ψ))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i
⇔
the automaton
({accept} ∪Sub(ϕ), (B ∪F ∪G), {ϕ}, {accept}, P(ϕ))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where fc ∈Fi,
Fi, Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i and the automaton
({accept} ∪Sub(ψ), (B ∪F ∪G), {ψ}, {accept}, P(ψ))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where fc /∈Fi,
Fi, Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i
⇔
the automaton
({accept}∪Sub(θ), (B∪F∪G), {θ}, {accept}, (if fcthen P(ϕ)else P(ψ)))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i
⇔
the automaton
({accept} ∪Sub(θ), (B ∪F ∪G), {θ}, {accept}, P(θ))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i.
–
If θ is ϕ ∨ψ then we have:
(VB, i) |= θ ⇔(VB, i) |= ϕ or (VB, i) |= ψ
⇔
the automaton
({accept} ∪Sub(ϕ), (B ∪F ∪G), {ϕ}, {accept}, P(ϕ))

Design of Automata-Based Axiomatization
|
323
accepts every word (VB
i ∪Fi∪Gi), (VB
i+1∪Fi+1∪Gi+1), . . . , where Fi, Fi+1,
· · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some j ≥i
or the automaton ({accept} ∪Sub(ψ), (B ∪F ∪G), {ψ}, {accept}, P(ψ))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i
⇔
the automaton
({accept} ∪Sub(θ), (B ∪F ∪G), {θ}, {accept}, (P(ϕ) U P(psi)))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i
⇔
the automaton
({accept} ∪Sub(θ), (B ∪F ∪G), {θ}, {accept}, P(θ))
accepts every word (VB
i ∪Fi ∪Gi), (VB
i+1 ∪Fi+1 ∪Gi+1), . . . , where Fi,
Fi+1, · · · ⊆F and Gi, Gi+1, · · · ⊆G but ∅= Gj = Gj+1 = . . . for some
j ≥i.

324
|
Nikolay V. Shilov
Axiom Schemata
H ⊢W ∈Fin iﬀW = {accept}
H ⊢W ∈¬(⟨T⟩ξ) iﬀ{U : W
T⇝U} is the emptyset
H ⊢W ∈νz.ξ iﬀ(W : νz.ξ) ∈H
Inference Rules
H⊢W∈ξ
H⊢W∈¬¬ξ
H⊢W∈¬ξ , H⊢W∈¬θ
H⊢W∈¬(ξ∨θ)
H⊢W∈ξ
H⊢W∈ξ∨θ
H⊢W∈θ
H⊢W∈ξ∨θ
H⊢U∈ξ
H⊢W∈⟨T⟩ξ for some U that W
T⇝U
H⊢U1∈¬ξ ,... H⊢Un∈¬ξ
H⊢W∈¬(⟨T⟩ξ)
where {U1, . . . Un} = {U : W
T⇝U}
H′∪{(W:νz.ξ)}⊢W∈ξνz.ξ
z
H⊢W∈νz.ξ
H′∪{(W:νz.ξ)}⊢W∈¬ξνz.ξ
z
H⊢W∈¬(νz.ξ)
where (W : νz.ξ) /∈H and H′ = H \ {(U : θ) : νz.ξ ≺θ}
Table 5: Sound and complete system for simple formulae of PLTL

Dieter Spreen
Partial Numberings and Precompleteness¹
Abstract: Precompleteness is a powerful property of numberings. Most number-
ings commonly used in computability theory such as the Gödel numberings of
the partial computable functions are precomplete. As is well known, exactly the
precomplete numberings have the eﬀective ﬁxed point property. In this paper ex-
tensions of precompleteness to partial numberings are discussed. As is shown,
most of the important properties shared by precomplete numberings carry over to
the partial case.
Keywords: Partial numbering, precompleteness, ﬁxed point property
Mathematics Subject Classiﬁcation 2010: 03D45
||
Dieter Spreen: Department of Mathematics, University of Siegen, Germany, and Department of
Decision Sciences, University of South Africa, Pretoria, South Africa
1 Introduction
A numbering is a map from the natural numbers onto a given set. Numberings are
a central tool in Russian style constructive mathematics allowing the transfer of
computability concepts to abstract structures.
Apart from early investigations, e.g. by Mal’tsev [6; 5], in later studies mostly
only totally deﬁned numberings have been considered in the literature (cf. e.g.
[1; 2]). Totality can always be assumed as long as purely algebraic structures are
discussed. As was shown by the author [10], the situation changes if topological
structures are studied: standard numberings of spaces without ﬁnite points are
only partially deﬁned, by necessity. Their domain of deﬁnition is Π0
2-hard. Here,
a point is called ﬁnite if its neighbourhood ﬁlter has a ﬁnite base.
A numbered set is a set together with a numbering of it. The natural numbers,
e.g., form a numbered set with respect to the identity function as numbering. Mor-
phisms between numbered sets are maps between the sets coming with a realizer,
i.e. a computable function tracking names (indices) of the arguments to names of
1 This research was supported by a Marie Curie International Research StaﬀExchange Scheme
Fellowship within the 7th European Community Framework Programme.

326
|
Dieter Spreen
the corresponding objects under the map. In case of total numberings, realizers
are total functions too.
A numbering is precomplete if every partial computable transformation of in-
dices can be totalized relative to the numbering. A prominent example are the
Gödel numberings of the partial computable functions, sometimes also called ac-
ceptable numberings. Precomplete numberings have important properties. Each
of its ﬁbers uniformly contains an inﬁnite computably enumerable subset. More-
over, a numbering is precomplete, exactly if it has the eﬀective ﬁxed point property.
As part of his work on numbered sets, Ershov [1] studied the category of (totally)
numbered sets. This category has no nontrivial injective objects. If, however, we
relativize the notion of an injective object by restricting universal quantiﬁcation
in its deﬁnition to those subobjects of the natural numbers that are eﬀectively enu-
merable, a class of objects is obtained which turns out to contain exactly the pre-
completely numbered sets. This gives a nice category theoretic characterization
of precompletely numbered sets.
In this paper we want to extend these results to the case of partial number-
ings. Realizers of morphisms need only be deﬁned for names of objects in this
case, not for all natural numbers. As has already been mentioned, in important
special cases the logical complexity of the name set is much higher than that of
computably enumerable sets. So, realizers will also be deﬁned for numbers which
are not names. They might even map such numbers to names of objects in the
range of the morphism. The category of partially numbered sets is known to be
Cartesian closed and equivalent to the category of modest sets which has been
extensively studied in semantics of type systems [4]. Precompleteness can be ex-
tended to partial numberings in several ways. The notions diﬀer e.g. in whether
we demand that all values of a totalizer are names or not. Independently of how
we decide, it may happen for some index that the value of a totalizer is a name
while the value of the partial index function is not, though it exists. Correctly pre-
complete numberings satisfy the additional requirement that values of totalizers
are names, just if the corresponding values of the given partial index functions
are names. If totalizers are required to have only names as values, an analogue
of Ershov’s category theoretic characterization can be derived. The other proper-
ties of precomplete numberings mentioned above carry over to the partial case
for all the extensions of precompleteness we study. Numberings of the respective
kind are characterized by versions of the eﬀective ﬁxed point theorem, and their
ﬁbers uniformly contain inﬁnite eﬀectively enumerable sets. In case of correctly
precomplete numberings we have in addition that also the set of non-names con-
tains such a set.
The paper is organized as follows: Section 2 contains basic deﬁnitions. Then,
in Section 3, various precompleteness notions are introduced and a category-

Partial Numberings and Precompleteness
|
327
theoretic characterization for one of these notions is derived. As we will see in
Section 4, also in the partial case, for all the notions of precompleteness, exactly
the numberings for which the eﬀective ﬁxed point theorem holds are precomplete.
Further properties of precomplete numberings are discussed in Section 5.
2 Basic deﬁnitions
In what follows, let ⟨, ⟩: ω2 →ω be a computable pairing function with corre-
sponding projections π1 and π2 such that πi(⟨a1, a2⟩) = ai. Let P(n) (R(n)) denote
the set of all n-ary partial (total) computable functions. For some Gödel number-
ing φ, we let φi(a)↓mean that the computation of φi(a) stops, φi(a)↓∈C that it
stops with value in C, and φi(a)↓n that it stops within n steps. The complement of
a set A is denoted by A. Moreover, we write F : A ⇀B to mean that F is a partial
function from set A into set B with domain dom(F).
As is well known, a subset C ⊆ω is decidable if there is a function f ∈R(1)
with C = f −1({0}). For i ∈ω such that φi ∈R(1) let Zi = φ−1
i
({0}). In any other
case let Z be undeﬁned. Then Z is a partial indexing of all decidable subsets of ω.
A (partial) numbering ν of a set S is a partial map ν: ω ⇀S (onto). The value
of ν at n ∈dom(ν) is denoted, interchangeably, by νn and ν(n). If s ∈S and
n ∈dom(ν) with νn = s, then n is said to be an index or a name of s. Numberings ν
with dom(ν) = ω, are called total. Let Nump(S) be the set of all partial numberings
of set S.
As was shown in [10], standard numberings of topological spaces like the com-
putable real numbers with the Euclidean topology are only partially deﬁned, by
necessity. In these cases the domain of the numbering is Π0
2-hard.
Deﬁnition 1. For S′ ⊆S, ν′ ∈Nump(S′) and ν, κ ∈Nump(S),
1. ν′ is m-reducible to ν, written ν′ ≤m ν, if there is some reduction function
g ∈P(1) with dom(ν′) ⊆dom(g), g(dom(ν′)) ⊆dom(ν), and ν′
n = νg(n), for
all n ∈dom(ν′).
2. ν is m-equivalent to κ, written ν ≡m κ, if ν ≤m κ and κ ≤m ν.
This deﬁnition is due to Mal’cev [6].
Lemma 2. Let S be nonempty and ν ∈Nump(S) such that dom(ν) is computably
enumerable. Then S has a total numbering m-equivalent to ν.
Proof. Since S is not empty, the same is true for dom(ν). Therefore, there is some
function g ∈R(1) with range(g) = dom(ν). Set g∗(j) = µi : g(i) = j. Then

328
|
Dieter Spreen
g∗∈P(1) with dom(g∗) = range(g). Moreover, for j ∈range(g), g(g∗(j)) = j. Let
¯ν = ν ◦g. Then ¯ν is a total numbering of S. In addition, ¯ν ≤m ν via g and ν ≤m ¯ν
via g∗.
A somewhat stronger result has been shown by Mal’cev under the additional as-
sumption that dom(ν) is inﬁnite [6, Theorem 2.2.1]. In this case g can be chosen
as one-to-one.
A subset X of S is completely enumerable, if there is a computably enumerable
set C ⊆ω such that νi ∈X if and only if i ∈C, for all i ∈dom(ν). Thus, X
is completely enumerable if we can enumerate all indices of elements of X and
perhaps some numbers which are not used as names by numbering ν.
3 Precompleteness
Precompleteness is a powerful property shared by most numberings commonly
used in computability theory: all Gödel numberings, e.g., as well as the number-
ing W of the computably enumerable sets are precomplete. Here, we will discuss
extensions of this notion to partial numberings. We start with a deﬁnition due to
Selivanov [9].
Deﬁnition 3. A numbering ν ∈Nump(S) is precomplete, if for any function p ∈
P(1) there is a function g ∈R(1) with range(g) ⊆dom(ν) such that for all i ∈
p−1(dom(ν)),
νp(i) = νg(i).
Function g is called totalizer of p or said to totalize p.
Mal’tsev deﬁned precomplete numberings as partial numberings with the eﬀec-
tive ﬁxed point property. In [6] they were called “complete”. Later, when introduc-
ing the completeness notion for total numberings that we still use [7], he changed
the notion into “precomplete”. Mal’cev’s ﬁrst deﬁnition was rather strong as he
could show that such numberings are necessarily totally deﬁned [6, p. 182]. Er-
shov [1; 2] considered only total numberings and gave two new characterizations
of precomplete numberings: in categorical terms and in terms of totalizers. The
later one has become the standard deﬁnition of precompleteness in modern text
books (cf. e.g. [12]). Both of Ershov’s characterizations carry over to the partial
case, thus showing the naturalness of the above deﬁnition.
If S is a set and ν ∈Nump(S), (S, ν) is called numbered set. With respect to the
identical numbering idω the set ω of all natural numbers is a numbered set which
we denote by N. In the case of total numberings morphisms between numbered

Partial Numberings and Precompleteness
|
329
sets are such that in particular every total numbering ν: ω →S is a morphism
from N to (S, ν). Therefore, morphisms between partially numbered sets need not
be total maps.
As has already been pointed out, in order to allow computability considera-
tions for abstract objects, such objects are represented by natural numbers via
numberings. So, the computability of a map between spaces of abstract objects
can only mean that we have an algorithm tracking names of arguments into names
of values under the given map.
Deﬁnition 4. Let (S, ν) and (S′, ν′) be numbered sets. A partial map F : S ⇀S′ is
realizable if it has a realizer, i.e. a function f ∈P(1) with dom(f) ⊇ν−1(dom(F))
and f(ν−1(dom(F))) ⊆dom(ν′) such that
F(νi) = ν′
f(i),
for all i ∈ν−1(dom(F)).
Let NUMp be the category of numbered sets with realizable partial maps as mor-
phisms. For objects S = (S, ν) and S′ = (S′, ν′) in NUMp, (S′, F′) is a subobject of
S in NUMp, if F′ : S′ →S is a total one-to-one realizable map.
Deﬁnition 5. Let S = (S, ν) be a numbered set.
1. A numbering ν′ of a subset S′ of S is principal, if for every κ ∈Nump(S′),
κ ≤m ν =⇒κ ≤m ν′.
2. A subobject ((S′′, ν′′), F′′) of S is a c-subobject, if F′′ ◦ν′′ is a principal num-
bering of range(F′′).
Deﬁnitions 5(1) and (2) are due to Mal’cev [7] and Ershov [2], respectively.
Lemma 6. Let S = (S, ν) be a numbered set and S′ a nonempty completely enu-
merable subset of S. Then S′ has a principal numbering.
Proof. The proof is a modiﬁcation of the proof in [1]. Let A ⊆ω witness that S′ is
completely enumerable and let f ∈R(1) enumerate A. Deﬁne ν′ = ν ◦f. If f(n) ∈
dom(ν) then ν′
n ∈S′. Otherwise, ν′
n is undeﬁned. Thus, dom(ν′) = f −1(dom(ν)),
which means that ν′ ∈Nump(S′).
Now, let κ ∈Nump(S′) with κ ≤m ν and let g ∈P(1) be the corresponding
reduction function. Then
g(dom(κ)) ⊆ν−1(S′) ⊆range(f).
(1)

330
|
Dieter Spreen
Set
h(n) =

µm : f(m) = g(n)
if g(n)↓,
undeﬁned
otherwise.
Then h ∈P(1) with dom(h) ⊆dom(g). Moreover, f(h(n)) = g(n), for n ∈
dom(h). Let n ∈dom(κ). Then n ∈dom(g), from which we obtain with (1)
that g(n) ∈range(f). Hence, g(n) = f(h(n)). Since g(dom(κ)) ⊆dom(ν),
it follows that f(h(n)) ∈dom(ν). We thus have that dom(κ) ⊆dom(h) and
h(dom(κ)) ⊆dom(ν′). Moreover, κn = νg(n) = νf(h(n)) = ν′
h(n). Therefore,
κ ≤m ν′.
Deﬁnition 7. A subobject ((S′, ν′), F′) of a numbered set S = (S, ν) is an e-
subobject of S if ((S′, ν′), F′) is a c-subobject of S and F′(S′) is a completely
enumerable subset of S.
Deﬁnition 7 is due to Ershov [2].
As we have seen in the preceding lemma, for each completely enumerable
subset S′ of S a numbering ν′ can be deﬁned so that (S′, ν′) is an e-subobject of S
with respect to the identical embedding.
Theorem 8. Let S = (S, ν) be a numbered set. Then ν is precomplete if, and only if,
for each e-subobject (T, F) of N and every realizable map H : T ⇀S there is a total
realizable map G: ω →S such that
H = G ◦F.
Proof. Let us ﬁrst assume that ν is precomplete. Moreover, let (T, F) with T =
(T, κ) be an e-subobject of N and H : T ⇀S a realizable map. Suppose that F and
H, respectively, are realized by f , h ∈P(1). Then F(T) = f(dom(κ)). By assump-
tion F(T) is computably enumerable. Thus, f −1(F(T)) is computably enumerable
as well. In addition, f −1(F(T)) ⊇dom(κ).
If T is empty, κ and F are empty maps. Let p be the nowhere deﬁned func-
tion in this case. Otherwise, if T is not empty, the sets F(T), dom(κ) and hence
f −1(F(T)) are nonempty as well. Let some enumeration of f −1(F(T)) be ﬁxed and
for n ∈ω, set k(n) to be the ﬁrst m in this enumeration with f(m) = n. Then
k ∈P(1) and f(k(n)) = n, for n ∈F(T)). Now, let p = h ◦k.
In both cases, p ∈P(1). Let g ∈R(1) with range(g) ⊆dom(ν) be a totalizer of
p, i.e., νp(n) = νg(n), for n ∈p−1(dom(ν)). Set G = ν ◦g. Since g is total, we have
that G: ω →S is a total map realized by g.
Suppose that T is not empty and let x ∈T. Then F(x) ∈F(T). Thus, k(F(x)) is
deﬁned. Since F(κk(F(x))) = f(k(F(x))) = F(x) and F is one-to-one, it follows that

Partial Numberings and Precompleteness
|
331
κk(F(x)) = x, whereby we obtain that
H(x) = H(κk(F(x))) = νh(k(F(x))) = νg(F(x)) = G(F(x)).
If T is empty, the last equation holds trivially.
For the converse implication let p, h ∈P(1) with range(h) = dom(p) and set
T = (dom(p), h). Moreover, set F(x) = x, for x ∈dom(p). Then we have for n ∈
dom(h) that F(h(n)) = h(n) = idω(h(n)). Thus, F : dom(p) →ω is a one-to-one
realizable total map and (T, F) is an e-subobject of N. Now, deﬁne H(n) = νp(n),
for n ∈p−1(dom(ν)). Then we have for n ∈h−1(p−1(dom(ν))) that H(h(n)) =
νp(h(n)). Therefore, H : T ⇀S is a realizable partial map. By assumption there is
some total realizable map G: ω →S with H = G ◦F. Let g ∈P(1) realize G. Then
we have that dom(g) ⊇ω and range(g) ⊆dom(ν), which in particular means that
g ∈R(1). Moreover, we have for n ∈p−1(dom(ν)) that
νp(n) = H(n) = G(F(n)) = G(n) = νg(n).
As follows from Deﬁnition 3, for a totalizer g of a function p ∈P(1) we always
have that g(n) ∈dom(ν), though there may be some n ∈dom(p) with p(n) ̸∈
dom(ν). In the case of total numberings this problem will not occur. When dealing
with partial numberings, however, there are situations in which a more symmetric
notion of precompleteness is needed (cf. [11]).
Deﬁnition 9. A numbering ν ∈Nump(S) is
1. faintly precomplete, if for any function p ∈P(1) there is a function g ∈R(1)
such the following two conditions hold, for all i ∈dom(p),
(a) p(i) ∈dom(ν) =⇒g(i) ∈dom(ν),
(b) p(i) ∈dom(ν) =⇒νp(i) = νg(i).
Function g is called faint totalizer of p or said to faintly totalize p.
2. correctly precomplete, if for any function p ∈P(1) there is a function g ∈R(1)
such the following two conditions hold, for all i ∈dom(p),
(a) p(i) ∈dom(ν) ⇐⇒g(i) ∈dom(ν),
(b) p(i) ∈dom(ν) =⇒νp(i) = νg(i).
In this case g is called correct totalizer of p or said to correctly totalize p.
Note that in case of a correctly precomplete numbering ν and a correct totalizer
g of some computable partial function p, for an argument i ̸∈dom(p) the value
g(i) is not determined to be in dom(ν), or not to be in dom(ν), respectively, by the
above deﬁnition.
Obviously, precompleteness in the sense of Deﬁnition 3 and correct precom-
pleteness both imply faint precompleteness. In the case of total numberings all

332
|
Dieter Spreen
three notions coincide. As follows from the next results, however, the ﬁrst two
concepts are incomparable in the case of proper partial numberings.
Lemma 10. If ν ∈Nump(S) is not total, there is some p ∈P(1) such that no g ∈R(1)
both totalizes and correctly totalizes p.
Proof. Since ν is not total, there is some ¯a ∈dom(ν). Set p(¯a) = ¯a and let p be
undeﬁned, otherwise. Moreover, assume that g ∈R(1) totalizes as well as correctly
totalizes p. Then
range(g) ⊆dom(ν)
(2)
and for a ∈dom(p),
p(a) ∈dom(ν) ⇐⇒g(a) ∈dom(ν).
(3)
By the choice of ¯a and p, it follows from (3) that g(¯a) ̸∈dom(ν), in contradiction
to (2).
Let φ be a Gödel numbering of P(1) and ˆφ be the co-restriction of φ to R(1).
Lemma 11. ˆφ is correctly precomplete, but not precomplete.
Proof. We ﬁrst show that ˆφ is correctly precomplete. Let to this end p ∈P(1). Since
Gödel numberings are precomplete [12], there is some g ∈R(1) with φp(i) = φg(i),
for i ∈dom(p). It follows that g correctly totalizes p with respect to ˆφ.
Let us next assume that ˆφ is also precomplete. Deﬁne q ∈P(1) by q(i) = i,
for i ∈ω. Then there is some f ∈R(1) with range(f) ⊆dom(ˆφ) and ˆφq(i) = ˆφf(i),
for i ∈q−1(dom(ˆφ)). Thus, ˆφf(i) = ˆφi, for i ∈dom(ˆφ). It follows that λi.φf(i) is
an enumeration of R(1) with computable universal function. By [12, p. 116, Theo-
rem 13], however, such enumerations do not exist.
Next, let K be the halting set. Set νi = 0, if i ∈K, and let ν be undeﬁned, otherwise.
Then ν ∈Nump({0}).
Lemma 12. ν is precomplete, but not correctly precomplete.
Proof. Let p ∈P(1) and a0 ∈K. Set g(a) = a0, for a ∈ω. Then g ∈R(1) with
range(g) ⊆dom(ν) and νp(a) = νg(a), for a ∈p−1(dom(ν)). Thus, g totalizes p.
In order to see that ν is not correctly precomplete, let a1 ∈K and set q(a) =
a1, for a ∈K. In any other case, let q be undeﬁned. Then q ∈P(1). As is well
known [8, p. 81, Theorem II(a)], K is not m-reducible to its complement, i.e., h(K)
intersects K, for all h ∈R(1). Let ah ∈K with h(ah) ∈K. Then ah ∈dom(q) such
that h(ah) ∈dom(ν), but q(ah) ̸∈dom(ν). It follows that q cannot be correctly
totalized.

Partial Numberings and Precompleteness
|
333
4 The eﬀective ﬁxed point property
As we will see next, also in the partial case and for all precompleteness notions
just introduced, precomplete numberings are exactly those numberings that have
an eﬀective ﬁxed point property. We start with faint precompleteness.
Theorem 13. Let ν ∈Nump(S). Then the following four statements are equivalent:
1. Numbering ν is faintly precomplete.
2. There is some function h ∈R(1) such that the subsequent two requirements
hold, for all i ∈ω,
(a) φi(h(i))↓∈dom(ν) =⇒h(i) ∈dom(ν),
(b) φi(h(i))↓∈dom(ν) =⇒νφi(h(i)) = νh(i).
3. There is some function h ∈R(1) such that the subsequent two requirements
hold, for all i ∈ω with φi ∈R(1),
(a) φi(h(i)) ∈dom(ν) =⇒h(i) ∈dom(ν),
(b) φi(h(i)) ∈dom(ν) =⇒νφi(h(i)) = νh(i).
4. There is some function h ∈R(1) such that the subsequent two requirements
hold, for all i ∈ω with φi ∈R(1) and range(φi) ⊆dom(ν),
(a) h(i) ∈dom(ν),
(b) νφi(h(i)) = νh(i).
Proof. The proof follows the one for total numberings [12]. We ﬁrst show that (1)
implies (2). Let p ∈P(1) be deﬁned by p(n) = φn(n) and g ∈R(1) faintly totalize
p. Moreover, let q ∈R(1) such that φq(i) = φi ◦g and set h = g ◦q. Then h ∈
R(1). In addition, we have for i ∈ω with φi(h(i)) being deﬁned that φi(h(i)) =
φi(g(q(i))) = φq(i)(q(i)) = p(q(i)). By deﬁnition, h(i) = g(q(i)). If φi(h(i)) ∈
dom(ν), it follows that p(q(i)) ∈dom(ν) and hence that g(q(i)) ∈dom(ν), as g
faintly totalizes p. Furthermore, νp(q(i)) = νg(q(i)). Thus, νφi(h(i)) = νh(i).
Obviously, (3) is a special case of (2) and (4) a special case of (3). So, it remains
to show that (4) entails (1). Assume that p ∈P(1) and let q ∈R(1) with φq(n)(m) =
p(n). Set g = h ◦q. Then g ∈R(1). Moreover, we have for i ∈dom(p) with p(i) ∈
dom(ν) that φq(i) ∈R(1) and range(φq(i)) ⊆dom(ν). Hence, h(q(i)) ∈dom(ν) as
well and νφq(i)(h(q(i))) = νh(q(i)), i.e., g(i) ∈dom(ν) and νp(i) = νg(i).
The corresponding result for precomplete numberings is just a consequence of
this proof.
Theorem 14. Let ν ∈Nump(S). Then the following four statements are equivalent:
1. Numbering ν is precomplete.

334
|
Dieter Spreen
2. There is some function h ∈R(1) with range(h) ⊆dom(ν) such that for all i ∈ω
with φi(h(i))↓∈dom(ν),
νφi(h(i)) = νh(i).
3. There is some function h ∈R(1) with range(h) ⊆dom(ν) such that for all i ∈ω
with φi ∈R(1) and φi(h(i)) ∈dom(ν),
νφi(h(i)) = νh(i).
4. There is some function h ∈R(1) with range(h) ⊆dom(ν) such that for all i ∈ω
with φi ∈R(1) and range(φi) ⊆dom(ν),
νφi(h(i)) = νh(i).
In the preceding theorems it may happen that φi(h(i))↓̸∈dom(ν), but h(i) ∈
dom(ν). A similar asymmetry was found in the deﬁnitions of precompleteness and
faint precompleteness. It motivated us to introduce correct precompeteness. As we
will see now, in this case we also have a symmetric version of the eﬀective ﬁxed
point theorem.
Theorem 15. Let ν ∈Nump(S). Then the following three statements are equivalent:
1. Numbering ν is correctly precomplete.
2. There is some function h ∈R(1) such that the subsequent two requirements
hold, for all i ∈ω for which φi(h(i)) is deﬁned,
(a) φi(h(i)) ∈dom(ν) ⇐⇒h(i) ∈dom(ν),
(b) φi(h(i)) ∈dom(ν) =⇒νφi(h(i)) = νh(i).
3. There is some function h ∈R(1) such that the subsequent two requirements
hold, for all i ∈ω with φi ∈R(1),
(a) φi(h(i)) ∈dom(ν) ⇐⇒h(i) ∈dom(ν),
(b) φi(h(i)) ∈dom(ν) =⇒νφi(h(i)) = νh(i).
Proof. Because of Theorem 13 we only have to show that the additional implica-
tions hold. Assume ﬁrst that ν is correctly precomplete and let h be as in the proof
of 13((1)⇒(2)). Suppose that h(i) ∈dom(ν), i.e., g(q(i)) ∈dom(ν). Since g cor-
rectly totalizes p, it follows that p(q(i)) ∈dom(ν), which means that φi(h(i)) ∈
dom(ν) as well.
Next, assume that Statement (3) holds and p ∈P(1). Let g ∈R(1) be the
totalizer constructed in the proof of 13((4)⇒(1)) and suppose that g(i) ∈dom(ν),
for i ∈dom(p). Then h(q(i)) ∈dom(ν) and hence φq(i)(h(q(i))) ∈dom(ν), i.e.,
p(i) ∈dom(ν).

Partial Numberings and Precompleteness
|
335
5 Further properties
The subsequent result shows that each ﬁber of a faintly precomplete numbering
is uniformly undecidable.
Lemma 16. Let S contain at least two elements and ν ∈Nump(S) be faintly pre-
complete. Then there is some function r ∈P(1) such the following properties hold,
for all j ∈dom(Z) and s ∈S,
1. r(j)↓,
2. ∅̸= Zj ⊆ν−1({s}) =⇒r(j) ∈ν−1({s}) \ Zj.
If ν is even correctly precomplete, r has the additional property that for j ∈dom(Z),
3. ∅̸= Zj ⊆dom(ν) =⇒r(j) ∈dom(ν) \ Zj.
Proof. The proof is again a reﬁnement of the one for total numberings [12]. Since
S has at least two elements there are indices a, b ∈dom(ν) with νa ̸= νb. Deﬁne
f , g ∈P(1) as follows:
f(⟨j, n⟩) =













a
if φj(n)↓with φj(n) = 0,
π1(µ⟨d, e⟩: [φj(d)↓e ∧φj(d) = 0])
if φj(n)↓with φj(n) ̸= 0
and for some d ∈ω, φj(d)↓with φj(d) = 0,
undeﬁned
otherwise,
g(⟨j, n⟩) =







b
if φj(n)↓with φj(n) = 0,
a
if φj(n)↓with φj(n) ̸= 0,
undeﬁned
otherwise.
Since ν is faintly precomplete there are functions f ′, g′ ∈R(1) such that for all
i ∈dom(f),
f(i) ∈dom(ν) =⇒f ′(i) ∈dom(ν)
(4)
νf ′(i) = νf(i), if f(i) ∈dom(ν),
(5)
and for all i ∈dom(g),
g(i) ∈dom(ν) =⇒g′(i) ∈dom(ν)
(6)
νg′(i) = νg(i), if g(i) ∈dom(ν).
As ν has the eﬀective ﬁxed point property, there are further on functions h, k ∈
R(1) so that for all j ∈ω,
f ′(⟨j, h(j)⟩) ∈dom(ν) =⇒h(j) ∈dom(ν)
(7)

336
|
Dieter Spreen
νf ′(⟨j,h(j)⟩) = νh(j), if f ′(⟨j, h(j)⟩) ∈dom(ν),
(8)
and
g′(⟨j, k(j)⟩) ∈dom(ν) =⇒k(j) ∈dom(ν)
(9)
νg′(⟨j,k(j)⟩) = νk(j), if g′(⟨j, k(j)⟩) ∈dom(ν).
Now, deﬁne r ∈P(1) by
r(j) =







h(j)
if φj(h(j))↓with φj(h(j)) ̸= 0,
k(j)
if φj(h(j))↓with φj(h(j)) = 0,
undeﬁned
otherwise.
It remains to show that r has the desired properties. Let to this end j ∈dom(Z)
with Zj being nonempty. Then φj is total. Since h and k are total functions as well,
we obtain that r(j) is deﬁned. Moreover, it follows that there is a smallest number
⟨d, e⟩so that φj(d)↓e with φj(d) = 0.
Now assume that s ∈S such that Zj ⊆ν−1({s}). Then d ∈Zj ⊆ν−1({s}) ⊆
dom(ν). Thus, f(⟨j, h(j)⟩)↓∈dom(ν), from which we obtain with (4) and (7) that
f ′(⟨j, h(j)⟩), h(j) ∈dom(ν) as well.
As range(λn.g(⟨j, n⟩)) ⊆dom(ν), it follows with (6) and (9) that g(⟨j, k(j)⟩),
g′(⟨j, k(j)⟩), k(j) ∈dom(ν).
Let us now consider the cases that φj(h(j)) ̸= 0 or φj(h(j)) = 0.
Case φj(h(j)) ̸= 0: In this case we have that r(j) = h(j). In addition, h(j) ̸∈Zj.
Thus, r(j) ∈dom(ν) \ Zj. Because of (5) and (8) it follows further on that
νr(j) = νh(j) = νf ′(⟨j,h(j)⟩) = νf(⟨j,h(j)⟩) = νd = s.
Consequently, r(j) ∈ν−1({s}) \ Zj.
Case φj(h(j)) = 0: Now, h(j) ∈Zj ⊆ν−1({s}) and therefore
s = νh(j) = νf ′(⟨j,h(j)⟩) = νf(⟨j,h(j)⟩) = νa.
Assume that φj(k(j)) = 0. Then k(j) ∈Zj ⊆ν−1({s}). It follows that
νa = s = νk(j) = νg′(⟨j,k(j)⟩) = νg(⟨j,k(j)⟩) = νb,
contradicting our choice of a and b. Hence, φj(k(j)) ̸= 0, which means that r(j) ̸∈
Zj. Moreover, we have that
νr(j) = νk(j) = νg′(⟨j,k(j)⟩) = νg(⟨j,k(j)⟩) = νa.

Partial Numberings and Precompleteness
|
337
This shows that r(j) ∈ν−1({s}) \ Zj in the second case as well.
Next, we assume that ν is even correctly precomplete and deal with the case
that Zj ⊆dom(ν). Note that now also the reverse implications hold in (4), (6), (7)
and (9). Again we consider the two cases:
Case φj(h(j)) ̸= 0: Now, h(j) ̸∈Zj, r(j) = h(j), and f(⟨j, h(j)⟩) = d. Since d ∈Zj ⊆
dom(ν), we obtain with the reverse implications in (4) and (7) that h(j) ∈dom(ν).
Thus, r(j) ∈dom(ν) \ Zj.
Case φj(h(j)) = 0: In this case h(j) ∈Zj ⊆dom(ν). On the other hand, f(⟨j, h(j)⟩) =
a ∈dom(ν), contradicting Properties (4) and (7). Thus, this case will not ap-
pear.
As a consequence we obtain that each ﬁber of a faintly precomplete numbering
uniformly contains an inﬁnite computably enumerable set.
Proposition 17. Let S contain at least two elements and ν ∈Nump(S) be faintly
precomplete. Then there is a one-to-one function g ∈R(2) such that for all m ∈
dom(ν) and n ∈ω,
1. g(m, n) ∈dom(ν),
2. νg(m,n) = νm.
If ν is even correctly precomplete, g has the additional property that for m ∈dom(ν),
3. g(m, n) ∈dom(ν).
Proof. Let q ∈R(2) with
φq(i,a)(n) =

φi(n)
if n ̸= a,
0
otherwise.
Then range(λa.q(i, a)) ⊆dom(Z), for i ∈dom(Z). Moreover, Zq(i,a) = Zi ∪{a} in
this case. Let a0 be a Z-index of the empty set and deﬁne
p(m, 0) = q(a0, m),
p(m, n + 1) = q(p(m, n), r(p(m, n))),
where the function r is as in Lemma 16. Then it follows by an easy induction on n
that for all m, n ∈ω,
p(m, n)↓∈dom(Z),
r(p(m, n)) ∈Zp(m,n+1) \ Zp(m,n),
m ∈dom(ν) =⇒r(p(m, n)) ∈dom(ν),
(10)

338
|
Dieter Spreen
νr(p(m,n)) = νm, if m ∈dom(ν).
In particular, we have that r(p(m, n)) ̸= r(p(m, n′)), for all n, n′ ∈ω with n ̸= n′.
If ν is correctly precomplete, also the reverse implication in (10) holds. Therefore,
the function g′(m, n) = r(p(m, n)) nearly has the desired properties. It remains to
turn it into a one-to-one function. Let to this end ⟨⟨m, n⟩⟩= (m+n)(m+n+1)/2+n
be the well known Cantor pairing function and set
g(0, 0 = g′(0, 0),
g(m, n) = g′(m, µa : g′(m, a) ̸∈{ g(m′, n′) | ⟨⟨m′, n′⟩⟩< ⟨⟨m, n⟩⟩}),
for m, n ∈ω with ⟨⟨m, n⟩⟩> 0. Then g is as desired.
An easy conclusion of the last result is that a numbering is faintly precomplete if
every partial computable function has a uniform inﬁnite family of faint totalizers,
and similarly in the precomplete and correctly precomplete case.
Theorem 18. Let S contain at least two elements and ν ∈Nump(S). Then the fol-
lowing statements hold:
1. Numbering ν is faintly precomplete if, and only if, for every function p ∈P(1)
there is a one-to-one function h ∈R(2) such that for all m ∈p−1(dom(ν)) and
all n ∈ω, h(m, n) ∈dom(ν) with
νp(m) = νh(m,n).
2. Numbering ν is precomplete if, and only if, for every function p ∈P(1) there
is a one-to-one function h ∈R(2) with range(h) ⊆dom(ν) such that for all
m ∈p−1(dom(ν)) and all n ∈ω,
νp(m) = νh(m,n).
3. Numbering ν is correctly precomplete if, and only if, for every function p ∈P(1)
there is a one-to-one function h ∈R(2) such that for all m, n ∈ω,
(a) p(m) ∈dom(ν) ⇐⇒h(m, n) ∈dom(ν),
(b) p(m) ∈dom(ν) =⇒νp(m) = νh(m,n).
Proof. In all three cases the “if” part is obvious. For the converse direction let g ∈
R(2) be as in the preceding proposition. Moreover, for a given function p ∈P(1),
let f ∈R(1) be a (correct, faint) totalizer. Then set h(m, n) = g(f(m), n). As is
easily veriﬁed, h has the desired properties.
Deﬁnition 19. A numbering ν ∈Nump(S) is (faintly, correctly) 1-precomplete if
every function p ∈P(1) has a (faint, correct) one-to-one totalizer.

Partial Numberings and Precompleteness
|
339
Corollary 20. Let S have at least two elements. Then every numbering ν ∈Nump(S)
is (faintly, correctly) precomplete, exactly if it is (faintly, correctly) 1-precomplete.
Proof. Again the “if” direction is obvious. For the other direction let p ∈P(1) and
h ∈R(2) as in Theorem 18. Then the function g with g(m) = h(m, m) is a (faint,
correct) one-to-one totalizer of p.
A further consequence of Theorem 18 is that a numbering is (faintly) precomplete,
exactly if each computable total index transformation with values in dom(ν) has a
uniform inﬁnite family of ﬁxed points; similarly in the correctly precomplete case.
Theorem 21. Let S have at least two elements and ν ∈Nump(S). Then the following
statements hold:
1. Numbering ν is faintly precomplete if, and only if, there is some function h ∈R(2)
which is one-to-one in the second argument such that for all i ∈ω with φi ∈R(1)
and range(φi) ⊆dom(ν), as well as all n ∈ω, h(i, n) ∈dom(ν) and
νφi(h(i,n)) = νh(i,n).
2. Numbering ν is precomplete if, and only if, there is some function h ∈R(2) which
is one-to-one in the second argument such that range(h) ⊆dom(ν) and for all
i ∈ω with φi ∈R(1) and range(φi) ⊆dom(ν), as well as all n ∈ω,
νφi(h(i,n)) = νh(i,n).
3. Numbering ν is correctly precomplete if, and only if, there is some function h ∈
R(2) which is one-to-one in the second argument such that for all i, n ∈ω for
which φi(h(i, n)) is deﬁned,
(a) φi(h(i, n)) ∈dom(ν) ⇐⇒h(i, n) ∈dom(ν),
(b) φi(h(i, n)) ∈dom(ν) =⇒νφi(h(i,n)) = νh(i,n).
The proof proceeds in the same way as for Theorems 13- 15. Most conclusions in
this section extend results in [3] to partial numberings.
Acknowledgement: The author is grateful to V.L. Selivanov for inspiring discus-
sions, and the unknown referees for their careful reading of a ﬁrst version of the
manuscript and useful hints helping to improve the readability of the paper.
Bibliography
[1]
Yu.L. Ershov, Theorie der Numerierungen I, Zeitschrift für mathematische Logik Grundla-
gen der Mathematik 19 (1973) 289–388.

340
|
Dieter Spreen
[2]
Yu.L. Ershov, Theory of numberings, in: E.R. Griﬀor, ed., Handbook of Computability
Theory, Elsevier Science B.V., Amsterdam, 1999, pp. 473–503.
[3]
A. Kanda and A.H. Lachlan, Alternative characterizations of precomplete numberings,
Zeitschrift für mathematische Logik Grundlagen der Mathematik 33 (1987) 97–100.
[4]
G. Longo and E. Moggi, Constructive natural deduction and its “omega-set” interpretation,
Mathematical Structures in Computer Science 1 (2) (1991) 215–253.
[5]
A.I. Mal’tsev, Algorithms and Recursive Functions. Wolters-NoordhoﬀPublishing, Gronin-
gen, 1965.
[6]
A.I. Mal’tsev, Constructive algebras I, in: H.G. Wells, III, ed., The Metamathematics of Al-
gebraic Systems. Collected papers: 1936–1967, North-Holland, Amsterdam, 1971, pp. 148–
214.
[7]
A.I. Mal’tsev, Sets with complete numberings, in: H.G. Wells, III, ed., The Metamathemat-
ics of Algebraic Systems. Collected papers: 1936–1967, North-Holland, Amsterdam, 1971,
pp. 287–312.
[8]
H. Rogers, Jr., Theory of Eﬀective Functions and Eﬀective Computability. McGraw-Hill Book
Company, New York, 1967.
[9]
V.L. Selivanov, private communication.
[10] D. Spreen, On some decision problems in programming, Information and Computation
122 (1995) 120–139; Corrigendum 148 (1999) 241–244.
[11]
D. Spreen, An isomorphism theorem for partial numberings, This Volume, pp. 341–381.
[12] K. Weihrauch, Computability, Springer-Verlag, Berlin, 1987.

Dieter Spreen
An Isomorphism Theorem for Partial
Numberings¹
Abstract: As is well-known, two equivalent total numberings are computably iso-
morphic, if at least one of them is precomplete. Selivanov asked whether a result
of this type is true also for partial numberings. As has been shown by the author,
numberings of this kind appear by necessity in studies of eﬀectively given topo-
logical spaces like the computable real numbers. In the present paper it is demon-
strated for a rather general class of spaces including the computable reals that
any two strongly correct numberings are computably isomorphic. Moreover, two
strongly equivalent partial numberings are computably isomorphic, if they are
both correctly precomplete, or uniformly productive.
Keywords: Partial numbering, computable isomorphism, reducibility, precom-
pleteness, cylinder, Myhill’s theorem, uniform productiveness, eﬀective topologi-
cal space, constructive metric space, computable real numbers
Mathematics Subject Classiﬁcation 2010: 03D45, 03D78, 03F60
||
Dieter Spreen: Department of Mathematics, University of Siegen, Germany, and Department of
Decision Sciences, University of South Africa, Pretoria, South Africa
1 Introduction
As has been shown by the author [19], standard numberings of the computable
real numbers and similar eﬀectively given topological spaces are only partially de-
ﬁned, by necessity. Thus, not every natural number is a name of some computable
object. It was demonstrated that any two such numberings are m-equivalent [21].
Spaces like the partial computable functions, on the other hand, are known to
have totally deﬁned standard, i.e. Gödel numberings such that any two of them
are even computably isomorphic [16].
In this paper it is studied whether such a result is also true for standard num-
berings of the computable reals and similar spaces. The investigation is carried
1 This research was supported by a Marie Curie International Research StaﬀExchange Scheme
Fellowship within the 7th European Community Framework Programme.

342
|
Dieter Spreen
out in the general setting of eﬀective topological spaces introduced in earlier pa-
pers of the author [19; 20; 21; 22; 24].
For total numberings it is well known that m-equivalent numberings are com-
putably isomorphic if at least one of them is precomplete [11; 7; 8; 28]. The proof
proceeds in two steps: First it is shown that any numbering which is m-equivalent
to a precomplete one is already 1-equivalent and then a generalization of Myhill’s
theorem is applied.
If one extends the usual reducibility relation between numberings to partial
numberings in a straightforward way, the reduction function is allowed to map
non-names with respect to one numbering onto names with respect to the other.
A computable isomorphism, however, can only map non-names onto non-names.
So, reduction functions have to operate in a similar way. We speak of strong re-
ducibility in this situation.
Strong reducibility of partial numberings has been studied in [23]. The degree
structure of partial numberings is strongly related to that of total numberings in
this case. If the weaker reducibility notion is applied, both structures exhibit quite
diﬀerent properties [1].
The usual proof of Myhill’s theorem requires the computation of ﬁnite se-
quences of alternating compositions f ◦· · ·◦g◦f(n) of the two reduction functions
f and g involved. In the case of partial numberings reduction functions are partial
functions mapping names of some element to names of the same element and—in
the strong case—non-names to non-names. If, applied to a non-name n, f(n) is in
the domain of g, then g(f(n)) need not be in the domain of f again. Hence, some
of these computations may not terminate.
Since we cannot decide, in general, whether a number is a name, Myhill’s con-
struction will not work in the case of partial numberings. As was shown in [25],
however, a central tool used to transform any reduction to a precomplete number-
ing into a 1-reduction, is available also in the partial case.
A numbering is precomplete if every partial computable index function can be
totalized relative to the numbering. We call it correctly precomplete in case there
is always a totalizer with the property that if the value of the partial index function
is a non-name, the same is true for the corresponding value of the totalizer.
The technical result mentioned before allows in a uniform way ﬁnding a new
element not contained in a given ﬁnite set in each ﬁber of a correctly precomplete
numbering as well as in the set of non-names. It can even be strengthened to the
case that the given forbidden set is decidable.
This stronger result may be used to transform a reduction from a total precom-
plete numbering to any other one into a 1-reduction [11; 7; 8; 28]. To do a similar
construction in the case that the given numbering is correctly precomplete, but
not total, a further strengthening is needed such that the forbidden set is only

An Isomorphism Theorem for Partial Numberings
|
343
required to be computably enumerable. We call a numbering with this property
uniformly productive.
As will be shown, any two strongly m-equivalent numberings are computably
isomorphic, if they are both either correctly precomplete or uniformly productive.
In general correctly precomplete numberings need not be uniformly productive.
This holds, however, for a large class of eﬀective topological spaces including all
constructive metric spaces without isolated elements, if the numberings are also
strongly acceptable. We will also meet here another condition called ﬁlter admis-
sion which is satisﬁed by correctly precomplete numberings.
Acceptable numberings are such that one can enumerate the indices of all
basic open sets containing a given point, uniformly in an index of the point, as
well as eﬀectively pass from Gödel numbers of normed eﬀective enumerations
of a base of the neighbourhood ﬁlter of a point to an index of that point. In the
strongly acceptable case the enumeration procedures in addition satisfy certain
reliability requirements with respect to the set of names. If the functions used to
pass from eﬀective enumerations of convergent ﬁlter bases to indices of their lim-
its also admits ﬁlters, which means that they are also deﬁned for enumerations of
nonconverging ﬁlters, numberings are said to be strongly correct.
For eﬀective spaces in the class mentioned above strongly correct numberings
are uniformly productive. An easy construction shows that such numberings ex-
ist.
As it turns out,any two strongly correct numberings are strongly m-equivalent.
Consequently, if the space under consideration belongs to the above mentioned
class, then all of its strongly correct numberings are pairwise computably isomor-
phic.
The paper is organized as follows: In Section 2 basic deﬁnitions are given.
Then, in Section 3, correct precompleteness of partial numberings is deﬁned and
an isomorphism theorem for such numberings derived. Uniform productiveness
is introduced in Section 4 and a corresponding isomorphism theorem is stated.
In the remaining sections it is studied whether these results can be improved
in the case of eﬀective topological spaces, in particular whether one can get rid of
the correct precompleteness and the uniform productiveness assumption, respec-
tively.
Eﬀective topological spaces and their numberings are introduced in Section 5.
For quite a general class of such spaces the uniform productiveness of strongly
correct numberings is derived. The existence of such numberings is shown in Sec-
tion 6. In Section 7 constructive metric spaces are introduced and it is demon-
strated that the requirements for the general class of spaces deﬁned in Section 5
are met. In particular it follows that any two canonical numberings of the com-

344
|
Dieter Spreen
putably complete ordered ﬁeld of the computable real numbers are computably
isomorphic. Final remarks can be found in Section 8.
2 Basic deﬁnitions
In what follows, let ⟨, ⟩: ω2 →ω be a computable pairing function with corre-
sponding projections π1 and π2 such that πi(⟨a1, a2⟩) = ai. Moreover, let a coding
of ﬁnite sequences of natural numbers be ﬁxed along with computable functions
lth, (·)- and ∗so that for the sequence coded by m, lth(m) is its length and (m)i
with i < lth(m) is its (i+1)-st element. In addition, m∗n is the code of the concate-
nation of the sequences coded by m and n. If a1, . . . , an is a sequence of natural
numbers we denote its code by ⟨a1, . . . , an⟩as well. In particular, ⟨⟩denotes the
code of the empty sequence.
Let P(n) (R(n)) denote the set of all n-ary partial (total) computable functions,
and let Wi be the domain of the ith partial computable function φi with respect to
some Gödel numbering φ. We let φi(a)↓mean that the computation of φi(a) stops,
φi(a)↓∈C that it stops with value in C, and φi(a)↓n that it stops within n steps.
If A ⊆ω is not empty and computably enumerable, As (= {f(0), ..., f(s −1)})
is the ﬁnite subset of A which can be enumerated in s steps with respect to some
ﬁxed total enumeration f of A. The complement of a set A is denoted by A.
As is well known, a subset C ⊆ω is decidable if there is a function f ∈R(1)
with C = f −1({0}). For i ∈ω such that φi ∈R(1), let Zi = φ−1
i
({0}). In any other
case let Z be undeﬁned. Then Z is a partial indexing of all decidable subsets of ω.
Let A1, A2 and B1, B2 be disjoint subsets of ω. Then (A1, A2) ≤m (B1, B2),
read (A1, A2) is many-one reducible to (B1, B2), if there is a function f ∈P(1)
such that for i = 1, 2 and all a ∈A1 ∪A2, if a ∈Ai then f(a)↓∈Bi.
A (partial) numbering ν of a set S is a partial map ν: ω ⇀S (onto) with domain
dom(ν). The value of ν at n ∈dom(ν) is denoted, interchangeably, by νn and ν(n).
If s ∈S and n ∈dom(ν) with νn = s, then n is said to be an index or a name of
s. Numberings ν with dom(ν) = ω, are called total. Let Nump(S) be the set of all
partial numberings of set S.
Given a partial numbering ν of S, a subset X is completely enumerable (with
respect to ν), if there is a computably enumerable set Wn such that νi ∈X if and
only if i ∈Wn, for all i ∈dom(ν). Set Mn = X, for any such n and X, and let
Mn be undeﬁned otherwise. Then M is a numbering of the class of all completely
enumerable subsets of S. X is enumerable, if there is a computably enumerable
set A ⊆dom(ν) such that X = { νi | i ∈A }. Thus, X is enumerable if we can
enumerate a subset of the index set of X which contains at least one index for

An Isomorphism Theorem for Partial Numberings
|
345
every element of X, whereas X is completely enumerable if we can enumerate all
indices of elements of X and perhaps some numbers which are not used as names
by numbering ν.
Deﬁnition 1 ([11]). A partial map F : S ⇀T between sets S and T with numberings
ν and κ, respectively, is realizable, if there is a function f ∈P(1), said to track F,
such that ν−1(dom(F)) ⊆dom(f), f(ν−1(dom(F))) ⊆dom(κ), and F(νi) = κf(i),
for all i ∈ν−1(dom(F)).
Deﬁnition 2 ([11]). Let ν, κ ∈Nump(S).
1. ν ≤m κ, read ν is m-reducible to κ, if there is some reduction function g ∈P(1)
with dom(ν) ⊆dom(g), g(dom(ν)) ⊆dom(κ), and νn = κg(n), for all n ∈
dom(ν).
2. ν ≤1 κ, read ν is 1-reducible to κ, if ν ≤m κ with a one-to-one reduction func-
tion.
3. ν ≡m κ, read ν is m-equivalent to κ, if ν ≤m κ and κ ≤m ν.
4. ν ≡1 κ, read ν is 1-equivalent to κ, if ν ≤1 κ and κ ≤1 ν.
5. ν ≃κ, read ν is computably isomorphic to κ, if there is some one-to-one func-
tion g ∈P(1) with dom(ν) ⊆dom(g), g(dom(ν)) = dom(κ), and νn = κg(n),
for all n ∈dom(ν).
The degree structure of partial numberings induced by this reducibility relation
has been studied in [1].
As follows from Deﬁnition 2(5), the function g ∈P(1) witnessing that two
partial numberings ν and κ are computably isomorphic is such that for all s ∈S
and all n ∈dom(g),
n ∈ν−1({s}) ⇐⇒g(n) ∈κ−1({s}).
Reduction functions as in Deﬁnition 2(1), on the other hand, satisfy only the left-
to-right part of this equivalence, thus allowing non-names with respect to ν to
be mapped onto names with respect to κ. In the isomorphism theorems we are
going to derive in the following sections the computable isomorphism between
two given m-equivalent numberings will be constructed from the corresponding
reduction functions. But, by what has just been said, this will only be possible if
we strengthen our reducibility notion.
Deﬁnition 3. Let ν, κ ∈Nump(S).
1. ν ≤s
m κ, read ν is strongly m-reducible to κ, if there is some strong reduction
function g ∈P(1) with dom(ν) = g−1(dom(κ)) and νn = κg(n), for all n ∈
dom(ν).

346
|
Dieter Spreen
2. ν ≤s
1 κ, read ν is strongly 1-reducible to κ, if ν ≤s
m κ with a one-to-one strong
reduction function.
3. ν ≡s
m κ, read ν is strongly m-equivalent to κ, if ν ≤s
m κ and κ ≤s
m ν. Similarly
for strong 1-equivalence ≡s
1.
Strong reducibility of partial numberings has been investigated in [23]. The follow-
ing technical lemma will be useful later.
Lemma 4. Let ν, κ ∈Nump(S) with κ ≤s
m ν and A ⊆ω be computably enumerable
so that A ⊇dom(ν). Then there is a function s ∈P(1) with range(s) ⊆A that
strongly reduces κ to ν.
Proof. Let g ∈P(1) strongly reduce κ to ν and s be the restriction of g to g−1(A).
Then s ∈P(1) with range(s) ⊆A. Since dom(κ) = g−1(dom(ν)), we have that
dom(κ) ⊆g−1(A) = dom(s). Thus, νs(i) = νg(i) = κi, for i ∈dom(κ). It follows
that dom(κ) ⊆s−1(dom(ν)). Conversely, if i ∈s−1(dom(ν)), then i ∈g−1(A) and
s(i) ∈dom(ν). Hence, g(i)↓∈dom(ν), i.e., i ∈dom(κ).
3 Precompleteness
Precompleteness is a powerful property shared by most numberings commonly
used in computability theory: all Gödel numberings as well as the numbering W
of the computably enumerable sets are precomplete. For total numberings, pre-
completeness is known to be equivalent to having the eﬀective ﬁxed point prop-
erty [11; 7; 8; 28]. Extensions of this notion to partial numberings are discussed in
[25].
Deﬁnition 5. A numbering ν ∈Nump(S) is precomplete, if for any function p ∈
P(1) there is some function g ∈R(1) with range(g) ⊆dom(ν) such that for all
i ∈p−1(dom(ν)),
νp(i) = νg(i).
Function g is called totalizer of p or said to totalize p.
The deﬁnition allows g(i) to be a name of some element of S even if p(i) is not. We
had a similar situation in the case of reducibility where we were forced to consider
stronger reduction functions. For related reasons we need to work with a more
symmetric precompleteness notion.

An Isomorphism Theorem for Partial Numberings
|
347
Deﬁnition 6. A numbering ν ∈Nump(S) is correctly precomplete, if for any func-
tion p ∈P(1) there is some function g ∈R(1) such the following two conditions
hold for all i ∈dom(p):
1. p(i) ∈dom(ν) ⇐⇒g(i) ∈dom(ν),
2. p(i) ∈dom(ν) =⇒νp(i) = νg(i).
In this case g is called correct totalizer of p or said to correctly totalize p.
There is a correspondence between partial numberings of S and total numberings
of the one-point extension of S under which correctly precomplete partial num-
berings correspond to precomplete total numberings.
Let to this end ∗̸∈S and set S∗= S ∪{∗}. Then for ν ∈Nump(S) deﬁne
ν∗
n =

νn
if n ∈dom(ν),
∗
otherwise.
Then ν∗is a total numbering of S∗that is precompete, exactly if ν is correctly pre-
complete.
Each ﬁber of a correctly precomplete numbering as well as the complement
of its domain uniformly contains an inﬁnite computably enumerable set.
Proposition 7. Let S contain at least two elements and ν ∈Nump(S) be correctly
precomplete. Then there is a one-to-one function g ∈R(2) such that for all i, a ∈ω
and s ∈S,
g(i, a) ∈ν−1({s}) ⇐⇒i ∈ν−1({s}).
(1)
The proposition extends a result of Kanda and Lachlan [10] to partial numberings.
A proof is given in [25].
We will use the result to design an algorithm that transforms strong reduc-
tions into strong one-to-one reductions.
Deﬁnition 8 ([14]). For numberings ν, κ ∈Nump(S), a ν-κ-correspondence K is a
nonempty set {(a1, b1), . . . , (an, bn)} ⊆ω2 such that for all indices i, j with i ̸= j
and all s ∈S,
–
ai ̸= aj and bi ̸= bj,
–
ai ∈ν−1({s}) ⇐⇒bi ∈κ−1({s}).
Set ⟨K⟩= ⟨⟨a1, b1⟩, . . . , ⟨an, bn⟩⟩.
Lemma 9. Let S have at least two elements and ν, κ ∈Nump(S) such that κ is
correctly precomplete. Moreover, let ν ≤s
m κ via f ∈P(1). Then there is a function

348
|
Dieter Spreen
hf ∈P(2) such that for all ν-κ-correspondences K = {(a1, b1), . . . , (an, bn)} ⊆ω2
and all a ∈dom(f) \ {a1, . . . , an} the following two properties hold:
1. hf (⟨K⟩, a)↓,
2. K ∪{(a, hf (⟨K⟩, a))} is a ν-κ-correspondence again.
Proof. Let g ∈R(2) be as in Proposition 7, deﬁne p ∈R(2) by
p(c, m) =

m
if m ̸∈{ π2((c)i) | i < lth(c) },
g(m, µn ≤lth(c) : g(m, n) ̸∈{ π2((c)i) | i < lth(c) }) otherwise,
and set hf (c, a) = p(c, f(a)).
Obviously, hf ∈P(2). Now, let K = {(a1, b1), . . . , (an, bn)} ⊆ω2 be a ν-κ-
correspondence and a ∈dom(f) \ {a1, . . . , an}. Then hf (⟨K⟩, a) is deﬁned.
If f(a) ̸∈{b1, . . . , bn}, hf (⟨K⟩, a) = f(a). Hence, (a, hf (⟨K⟩, a)) ̸∈K. In case
that f(a) ∈{b1, . . . , bn}, we have that p(⟨K⟩, f(a)) ̸∈{b1, . . . , bn}. Thus, also in
this case, (a, hf (⟨K⟩, a)) ̸∈K.
Next, let s
∈S. Since f strongly m-reduces ν to κ, it follows that a
∈
ν−1({s}), just if f(a) ∈κ−1({s}). Moreover, by (1), f(a) ∈κ−1({s}) if, and only
if, p(⟨K⟩, f(a)) ∈κ−1({s}). Thus, a ∈ν−1({s}), exactly if hf (⟨K⟩, a) ∈κ−1({s}),
which shows that K ∪{(a, hf (⟨K⟩, a))} is again a ν-κ-correspondence.
Proposition 10. Let S have at least two elements and ν, κ ∈Nump(S) such that κ
is correctly precomplete. Then the following two statements hold:
1. If ν ≤s
m κ then ν ≤s
1 κ.
2. If κ ≤s
m ν with a total reduction function, then κ ≤s
1 ν.
Proof. (1) Let f ∈P(1) witness that ν ≤s
m κ. Then dom(f) is computably enumer-
able and nonempty, as S is not empty. Let j0, j1, . . . be a computable enumeration
of dom(f) without repetitions and deﬁne
t(0) = ⟨⟨j0, hf (⟨⟩, j0)⟩⟩,
t(n + 1) = t(n) ∗⟨⟨jn+1, hf (t(n), jn+1)⟩⟩,
if jn+1 exists. In all other cases let t(n) be undeﬁned. Finally, set
r(a) = µn : π1((t(n))n) = a
and
k(a) = π2((t(r(a)))r(a)).
Then r, k ∈P(1). Moreover, k has domain dom(f) and graph
G = { (a, b) ∈ω2 | (∃n ∈dom(t))⟨a, b⟩= (t(n))n }.

An Isomorphism Theorem for Partial Numberings
|
349
Since G is a ν-κ-correspondence, k is one-to-one and for i ∈ω we obtain that
i ∈dom(ν) ⇐⇒(∃s ∈S)νi = s
⇐⇒(∃s ∈S)k(i)↓∧κk(i) = s
(as dom(ν) ⊆dom(f) = dom(k))
⇐⇒k(i)↓∈dom(κ)
⇐⇒i ∈k−1(dom(κ)).
Thus, dom(ν) = k−1(dom(κ)). Moreover, it follows for i ∈dom(ν) that νi = κk(i).
(2) Assume that κ ≤s
m ν via f ∈R(1). Since f is total, it also witnesses that
κ∗≤m ν∗. We have already seen that κ∗is precomplete. Thus, κ∗≤1 ν∗[11; 7; 8;
28], which implies that κ ≤s
1 ν.
As we have seen, the totality requirement on the reduction function is essential in
Proposition 10(2). Before we start dealing with the general case where this condi-
tion is dropped, let us note that in case of both constructions above the totality of
the reduction functions involved is preserved. Moreover, the usual construction in
the proof of Myhill’s theorem works also for partial numberings, if the functions
witnessing strong 1-equivalence are both total.
Corollary 11. Let S contain at least two elements and ν, κ ∈Nump(S) such that κ
is correctly precomplete. If ν and κ are strongly m-equivalent with total reduction
functions, then they are computably isomorphic.
For a numbering ν ∈Nump(S), the cylindriﬁcation of ν is the numbering c(ν) with
c(ν)⟨i,j⟩= νi, if i ∈dom(ν) and j ∈ω, and c(ν) being undeﬁned, otherwise. Num-
bering ν is said to be a cylinder, if it is computably isomorphic to its cylindriﬁcation
[7].
Theorem 12. Every correctly precomplete numbering is a cylinder.
Proof. Note that ν ≤s
1 c(ν) via λn.⟨n, 0⟩and c(ν) ≤s
m ν via π1. As both reduction
functions are total, it follows with Proposition 10(1) and the corollary that ν ≃
c(ν).
Now, assume that S has at least two elements and ν, κ ∈Nump(S) are correctly
precompete. Moreover, let ν ≡s
m κ. Then by stepwise alternating, similarly as in
the proof of Myhill’s theorem, the procedure given by Lemma 9, we can enumerate
the graph of a computable isomorphism between ν and κ.

350
|
Dieter Spreen
Theorem 13 (First Isomorphism Theorem). Let S have at least two elements and ν,
κ ∈Nump(S) be correctly precomplete. Then, if ν and κ are strongly m-equivalent,
they are computably isomorphic.
Proof. Suppose that ν ≤s
m κ via f ∈P(1) and κ ≤s
m ν via g ∈P(1), and let hf ∈P(2)
and hg ∈P(2) be the function existing by Lemma 9 in this case.
Since S ̸= ∅, and both ν and κ are onto maps, their domains are not empty too,
as is also the case with the domains of functions f , g, hf and hg. Thus, there are
functions r, t ∈R(1) that enumerate dom(f) and dom(g), respectively. We will use
these functions to construct a function k ∈R(1) enumerating a sequence of larger
and larger correspondences from which we will ﬁnally obtain the computable iso-
morphism p ∈P(1) between ν and κ.
If c ∈ω is the code of a correspondence, then we denote the code of its dual,
obtained by exchanging domain and range, by ˆc, i.e., if c is the code of
{(a1, b1), . . . , (an, bn)} ,
then ˆc is the code of {(b1, a1), . . . , (bn, an)}.
Set
k(0) = ⟨⟨r(0), hf (⟨⟩, r(0))⟩⟩,
k(2n + 1) =







k(2n) ∗⟨⟨hg(
k(2n), t(n)), t(n)⟩⟩
if t(n) ̸= π2((k(2n))i), for all i < lth(k(2n)),
k(2n)
otherwise,
k(2n + 2) =







k(2n + 1) ∗⟨⟨r(n + 1), hf (k(2n + 1), r(n + 1))⟩⟩
if r(n) ̸= π1((k(2n + 1))i), for all i < lth(k(2n + 1),
k(2n + 1)
otherwise,
let
q(a) = µn : π1((k(n))lth(k(n))−1) = a,
and deﬁne
p(a) = π2((k(q(a)))lth(k(q(a)))−1).
It remains to show that p is a computable isomorphism between ν and κ.
By construction it is one-to-one: if p(a) = b and p(a′) = b′ with b = b′, then
there is some stage m such that (a, b), (a′, b′) are elements of the correspondence
with code k(m). Hence, a = a′.

An Isomorphism Theorem for Partial Numberings
|
351
Next, let a ∈dom(ν). Then a ∈dom(f). Thus, there is some m ≥0 with
a = r(m). It follows that there is some b ∈ω so that (a, b) is in the correspondence
with code k(2m), which means that a ∈dom(p) and b ∈dom(κ). This shows that
dom(ν) ⊆dom(p) as well as p(dom(ν)) ⊆dom(κ). In addition, we have that
b ∈κ−1({νa}), i.e., νa = κb = κp(a).
If b ∈dom(κ), then b ∈dom(g) and hence b = t(m), for some m ≥0. So,
there is some a ∈ω such that (a, b) is in the correspondence with code k(2m +1).
It follows that a ∈dom(ν) and therefore that b ∈p(dom(ν)).
Note that in the case of total numberings, precompleteness is inherited under m-
equivalence. Therefore, this result extends Eršov’s Isomorphism Theorem for total
numberings [7] to the partial case.
4 Uniform productiveness
We will now consider the case of a statement like Proposition 10(2) without the
totality requirement. If we follow the proofs of Proposition 10(1) and Theorem 13
outlined in the last section, we see that they makes essential use of Proposition 7,
which follows from the fact that for a correctly precomplete numbering, each ﬁber
as well as the complement of its domain are uniformly nondecidable [25]. As will
be shown later, standard numberings of eﬀectively given topological spaces like
the computable real numbers have even the property that their ﬁbers as well as
their domain complements are uniformly non-computably enumerable, i.e., they
are uniformly productive.
Deﬁnition 14. A numbering ν ∈Nump(S) is uniformly productive, if there is some
computably enumerable set A ⊇dom(ν), called localizer, and a function k ∈R(1),
the witness generator, so that φk(i) is total, for all i ∈A, and
1. φk(i)(j) ∈ν−1({νi}) \ Wj, for all i ∈dom(ν) and j ∈ω with Wj ⊆ν−1({νi}),
2. φk(i)(j) ∈dom(ν) \ Wj, for all i ∈A \ dom(ν) and j ∈ω with Wj ⊆dom(ν).
Under some very natural conditions satisﬁed by standard numberings of many
important eﬀectively given topological spaces the new concept turns out to be
weaker than correct precompleteness. But note that this is not true in general: Let
K be the halting set and deﬁne κi = 1, if i ∈K, and κi = 0, otherwise. Then κ is a
precomplete total numbering of {0, 1} [11; 28], which obviously is not uniformly
productive.

352
|
Dieter Spreen
Proposition 15. Let ν, κ ∈Nump(S) such that ν is uniformly productive with local-
izer A. If ν ≤s
m κ and κ ≤s
m ν with reduction functions f , g ∈P(1), respectively, so
that f is total, then κ is uniformly productive as well with localizer g−1(A).
Proof. Let k ∈R(1) be a witness generator for ν. Moreover, let r, h ∈R(1) with
Wr(j) = f −1(Wj)
and
φh(i)(j) = f(φk(g(i))(r(j))).
As we will show next, κ is uniformly productive with localizer g−1(A) and wit-
ness generator h. Obviously, g−1(A) ⊇dom(κ), because A
⊇dom(ν) and
g−1(dom(ν)) = dom(κ), by strong reduction.
Let i ∈dom(κ) and Wj ⊆κ−1({κi}). Then
Wr(j) = f −1(Wj) ⊆f −1(κ−1({κi})) = ν−1({νg(i)}).
Thus, φk(g(i))(r(j)) ∈ν−1({νg(i)}) \ Wr(j) and hence,
φh(i)(j) = f(φk(g(i))(r(j))) ∈κ−1({κi}) \ Wj.
Next, assume that i ∈g−1(A) \ dom(κ) and Wj ⊆dom(κ). Since
f −1(dom(κ)) = dom(ν),
we obtain that Wr(j) ⊆dom(ν). Moreover,
g(i) ∈g(g−1(A) ∩dom(κ)) = g(g−1(A) ∩g−1(dom(ν)))
= g(g−1(A \ dom(ν))) ⊆A \ dom(ν).
Therefore, φk(g(i))(r(j)) ∈dom(ν) \ Wr(j), from which it follows that φh(i)(j) ∈
dom(κ) \ Wj.
Corollary 16. The cylindriﬁcation of a uniformly productive numbering is itself uni-
formly productive.
Proposition 17. Let ν ∈Nump(S) be uniformly productive with localizer A. Then
there is a one-to-one function g ∈P(2) such that for all a ∈ω, i ∈A and s ∈S,
g(i, a)↓with
g(i, a) ∈ν−1({s}) ⇔i ∈ν−1({s}).
Proof. To a large extend the proof follows that of Proposition 7 in [25]. Let q ∈R(2)
with Wq(m,n) = Wm ∪{n} and Wm0 = ∅. Deﬁne
p(i, 0) = q(m0, i),
p(i, a + 1) = q(p(i, a), φk(i)(p(i, a))),

An Isomorphism Theorem for Partial Numberings
|
353
where k is the witness generator for ν. Then it follows by induction on a that for
all i ∈A and a ∈ω,
φk(i)(p(i, a)) ∈Wp(i,a+1) \ Wp(i,a),
i ∈dom(ν) ⇔φk(i)(p(i, a)) ∈domν,
νφk(i)(p(i,a)) = νi, if i ∈dom(ν).
In particular, we have that φk(i)(p(i, a)) ̸= φk(i)(p(i, a′)), for all i ∈A and a ∈ω
with a ̸= a′.
Since ν is uniformly productive, dom(ν) and hence also A are inﬁnite. Thus,
A has a one-to-one enumeration f ∈R(1). Let ⟨⟨m, n⟩⟩= (m + n)(m + n + 1)/2 + n
be the Cantor pairing function again and set
g′(0, 0) = φk(f(0))(p(f(0), 0)),
g′(j, a) = φk(f(j))(p(f(j),
µn : φk(f(j))(p(f(j), n)) ̸∈{ g′(j′, a′) | ⟨⟨j′, a′⟩⟩< ⟨⟨j, a⟩⟩})),
for j, a ∈ω with ⟨⟨j, a⟩⟩> 0. Moreover, let f ∗(i) = µj : f(j) = i. Then f ∗∈P(1)
with dom(f ∗) = A. In addition, f ∗is one to one and for i ∈A, f(f ∗(i)) = i. Deﬁne
g(i, a) = g′(f ∗(i), a). Then g has the desired properties.
As a consequence of Proposition 17 we obtain the following analogue of Lemma 9.
Lemma 18. Let ν, κ ∈Nump(S) such that κ is uniformly productive. Moreover, let
f ∈P(1) strongly reduce ν to κ. Then there is a function hf ∈P(2) such that for
all ν-κ-correspondences K = {(a1, b1), . . . , (an, bn)} ⊆ω2 and all a ∈dom(f) \
{a1, . . . , an} the following two properties hold:
1. hf (⟨K⟩, a)↓,
2. K ∪{(a, hf (⟨K⟩, a))} is a ν-κ-correspondence again.
Proof. Let A be a localizer for κ. By Lemma 4 we can assume that range(f) ⊆A.
This allows us to construct the function hf as in the proof of Lemma 9 by now
using function g according to Proposition 17.
Proposition 19. Let ν, κ ∈Nump(S) such that κ is uniformly productive with local-
izer A. Then the following two statements hold:
1. If ν ≤s
m κ, then ν ≤s
1 κ.
2. If κ ≤s
m ν with a total reduction function, then κ ≤s
1 ν.
Proof. (1) follows as Proposition 10(1).

354
|
Dieter Spreen
(2) Let ν′ be the corestriction of ν to the range of f. Moreover, let g be the restric-
tion of the identity function on ω to range(f). Then f and g, respectively, witness
that κ ≤s
m ν′ and ν′ ≤s
1 ν. Thus, it remains to show that κ ≤s
1 ν′.
Deﬁne ¯f(j) = µi : f(i) = j. Then ¯f ∈P(1) with dom(¯f) = range(f). Obviously,
¯f witnesses that ν′ ≤s
m κ. Thus, κ ≡s
m ν′, which by Proposition 15 means that ν′
is uniformly productive with localizer f(A). With the ﬁrst statement we therefore
obtain that κ ≤s
1 ν′.
As a further consequence of Lemma 18 we obtain the following analogue of Theo-
rem 13. The proof proceeds in the same way.
Theorem 20 (Second Isomorphism Theorem). Let ν, κ ∈Nump(S) be uniformly
productive. Then, if ν and κ are strongly m-equivalent, they are computably isomor-
phic.
In Corollary 16 we have seen that the cylindriﬁcation c(ν) of a uniformly pro-
ductive numbering ν is again uniformly productive. Moreover, ν ≡s
m c(ν). Thus,
ν ≃c(ν).
Theorem 21. Every uniformly productive numbering is a cylinder.
5 Eﬀective topological spaces
In what follows, let T = (T, τ) be a countable topological T0 space with countable
basis B. At ﬁrst sight the requirement that T is countable seems quite restrictive.
We think of T as being the subspace of computable elements of some larger space.
There are several approaches to topology that come with natural computability
notions for points and maps (cf. e.g. [18; 26; 29; 4]). It allows to assign indices to
the computable points in a canonical way so that important properties become
computable. In general the notion of computable point is rather complex, mainly
harder than Σ0
1.
Contrary to this, in most applications the basic open sets have a simple ﬁ-
nite description. By coding the descriptions one obtains a total numbering of the
topological basis. For us basic open sets are predicates. Each point is uniquely de-
termined by the collection of all predicates it satisﬁes, thus the T0 requirement.
Usually, set inclusion between basic open sets is not completely enumerable.
But in the applications we have in mind there is a canonical relation between the
descriptions of the basic open sets (respectively, their code numbers), which in
many cases is stronger than set inclusion. This relation is computably enumerable.

An Isomorphism Theorem for Partial Numberings
|
355
We assume that the topological basis B comes with a total numbering B of its
elements and such a relation between the codes.
Deﬁnition 22. Let ≺B be a transitive binary relation on ω. We say that:
1. ≺B is a strong inclusion, if for all m, n ∈ω, from m ≺B n it follows that Bm ⊆
Bn.
2. B is a strong basis, if ≺B is a strong inclusion and for all z ∈T and m, n ∈ω
with z ∈Bm ∩Bn there is a number a ∈ω such that z ∈Ba, a ≺B m and
a ≺B n.
For what follows we assume that ≺B is a strong inclusion with respect to which B
is a strong basis.
In applications canonical indexings usually have the important property that
all basic open sets Bn are completely enumerable, uniformly in n. Note that this
does not mean that we can eﬀectively enumerate, uniformly in n, all indices of
points in Bn, and only those. The enumeration procedure may list additional num-
bers that are not names of points in T.
Deﬁnition 23. Let T = (T, τ) be a countable topological T0 space with countable
basis B, and let x and B be numberings of T and B, respectively, such that B is
total. We say that x is computable if there is some computably enumerable set
L ⊆ω such that for all i ∈dom(x) and n ∈ω,
⟨i, n⟩∈L ⇔xi ∈Bn.
Since we work with strong inclusion instead of set inclusion, we had to adjust the
notion of a topological basis. In the same way we have to modify that of a ﬁlter
base.
Deﬁnition 24. Let H be a ﬁlter. A nonempty subset F of H is called strong base
of H if the following two conditions hold:
1. For all m, n ∈ω with Bm, Bn ∈F there is some index a ∈ω such that Ba ∈F,
a ≺B m, and a ≺B n.
2. For all m ∈ω with Bm ∈H there is some index a ∈ω such that Ba ∈F and
a ≺B m.
If x is computable, a strong base of basic open sets can eﬀectively be enumerated
for each neighbourhood ﬁlter. As we will see, this can always be done in a normed
way, if the strong inclusion relation is computably enumerable.

356
|
Dieter Spreen
Deﬁnition 25. An enumeration (Bf(a))a∈dom(f) with a partial function f : ω ⇀ω
deﬁned on an initial segment of ω is said to be p-normed if f is decreasing with
respect to ≺B. In case f is total, we say that the enumeration (Bf(a))a∈ω is normed.
Moreover, if f is computable, the enumeration is also called computable and any
Gödel number of f is said to be an index of it.
If (Bf(a))a∈dom(f) is a p-normed enumeration of basic open sets, the set of all Bn
with n ∈range(f) is a base of the ﬁlter
{ O ∈τ | (∃a ∈ω)(∃n ∈range(f))n ≺B a ∧Ba ⊆O }.
In case that f is total, it is even a strong base.
Deﬁnition 26. If for total function f, (Bf(a))a∈ω enumerates a strong base of the
neighbourhood ﬁlter N(y) of some point y ∈T, we say it converges to that point.
Lemma 27. Let T = (T, τ) be a countable topological T0 space with countable
basis B, and numberings x and B, respectively, of T and B such that B is total and
x computable with witnessing set L. Moreover, let ≺B be computably enumerable.
Then there are functions q ∈R(1) and p ∈R(2) such that for all i, n ∈ω with
⟨i, n⟩∈L the following four statements hold:
1. Both, q(i) and p(i, n) are indices of p-normed computable enumerations of ba-
sic open sets. If i ∈dom(x), the enumerations are normed and converge to xi.
2. If φq(i) is total, there is some m ∈range(φq(i)) with m ≺B n.
3. φp(i,n)(0) ≺B n, in case that φp(i,n)(0) is deﬁned.
4. ⟨i, m⟩∈L, for all m ∈range(φq(i)) ∪range(φp(i,n)).
Proof. Let f ∈R(1) such that φf(i) is an enumeration of all indices c with ⟨i, c⟩∈L
which is either nowhere deﬁned or total. Moreover, let v ∈R(3) so that φv(i,n,a)
enumerates all indices m with ⟨i, m⟩∈L, m ≺B n, and m ≺B φf(i)(a). Deﬁne
p ∈R(2) by
φp(i,n)(0) = φv(i,n,0)(0),
φp(i,n)(a + 1) = φv(i,φp(i,n)(a),a+1)(0),
and set q(i) = p(i, φf(i)(0)). Then Statements 2-4 and the ﬁrst part of Statement 1
obviously hold. Now, let i ∈dom(x) and assume that xi ∈Bn. Then φf(i) is a total
function, similarly φv(i,n,a), for all a ∈ω, as B is a strong basis. Consequently,
also φp(i,n) and φq(i) are total maps. Moreover, φp(i,n)(a + 1) ≺B φp(i,n)(a),
φp(i,n)(a) ≺B φf(i)(a), and xi ∈B(φp(i,n)(a)), for all a ∈ω. Thus, { Bm | m ∈
range(φp(i,n)) } is a strong base of N(xi). This proves the rest of Statement 1.

An Isomorphism Theorem for Partial Numberings
|
357
Deﬁnition 28. A function g ∈P(1) admits ﬁlters if g(m) is deﬁned, for all indices
m of p-normed computable enumerations of basic open sets.
We want not only to be able to generate normed computable enumerations of ba-
sic open sets that converge to a given point, but conversely, we need also be in a
position to pass eﬀectively from such enumerations to the point they converge to.
Deﬁnition 29. Let x ∈Nump(T). We say that:
1. x allows eﬀective limit passing if there is a function pt ∈P(1) such that, if m
is an index of a normed computable enumeration of basic open sets which
converges to some point y ∈T, then pt(m)↓∈dom(x) and xpt(m) = y.
2. x is approximating if x allows eﬀective limit passing with corresponding func-
tion pt admitting ﬁlters.
3. x is acceptable if it allows eﬀective limit passing and is computable.
4. x is correct if it is both approximating and computable.
If x, x′ ∈Nump(T) such that x allows eﬀective limit passing and x ≤m x′ via
h ∈P(1), then we have for all indices m of converging normed computable enu-
merations of basic open sets that h(pt(m)) is deﬁned. However, this needs not be
the case for indices of p-normed enumerations in general.
Deﬁnition 30. Let x ∈Nump(T) be approximating. A function h ∈P(1) reduc-
ing x respects approximation if h(pt(m)) is deﬁned, for all indices m of p-normed
computable enumerations of basic open sets.
Whenever x ≤m x′ with approximation respecting reduction function we write
x ≤a
m x′, and x ≤a,s
m
x′, if the reduction function is also strong. In case that
both x ≤a
m x′ and x′ ≤a
m x, x and x′ are called m-a-equivalent, and strongly m-
a-equivalent when x ≤a,s
m
x′ and x′ ≤a,s
m
x. We write in these cases x ≡a
m x′ and
x ≡a,s
m x′, respectively.
If x allows eﬀective limit passing, function pt is only required to behave prop-
erly on indices of normed converging enumerations of basic open sets. If for some
m ∈ω we have that pt(m)↓∈dom(x), we cannot conclude that m is an index of
such an enumeration. Sometimes, Bφm(a)

a should at least enumerate a base of
N(xpt(m)).
Deﬁnition 31. A numbering x ∈Nump(T) is said to strongly allow eﬀective limit
passing, if there is a function pt ∈P(1) witnessing that x allows eﬀective limit
passing and being such that for m ∈ω it follows from pt(m)↓∈dom(x) that the

358
|
Dieter Spreen
collection of all sets Ba with a ∈range(φm) is a base of N(xpt(m)). In case that pt
also admits ﬁlters, x is called strongly approximating.
Similarly, we will strengthen the computability notion for numberings x by requir-
ing that for any point y ∈T, x provides as many names for y as possible.
Deﬁnition 32. Numbering x ∈Nump(T) is strongly computable, if x is com-
putable and the set L witnessing this is such that for all i ∈ω with
{ Bn | ⟨i, n⟩∈L }
being a strong base of the neighbourhood ﬁlter of some point y ∈T, we have that
i ∈dom(x) with xi = y.
Let x be computable and let this be witnessed by L ⊆ω. If pt ∈P(1) witnesses that
x also allows eﬀective limit passing, then we have for any index m of a normed
computable enumeration of basic open sets converging to some point y ∈T
that ⟨pt(m), n⟩∈L, for all n ∈range(φm). In case that x is even strongly com-
putable, also the converse holds, as the set of all Bn with n ∈range(φm) so that
⟨pt(m), n⟩∈L is a strong base of N(y).
We say that pt ∈P(1) and L ⊆ω ﬁt well together if pt(m) is deﬁned with
⟨pt(m), n⟩∈L, for all n ∈range(φm) and all indices m of p-normed computable
enumerations of basic open sets.
Lemma 33. Let x ∈Nump(T) be strongly computable and let this be witnessed by
L ⊆ω. Moreover, let pt ∈P(1) ﬁt well together with L. Then pt witnesses that x is
approximating.
If x is strongly computable and strongly allows eﬀective limit passing as well, we
say that it is strongly acceptable. Similarly, we say that x is strongly correct, if x is
strongly computable and strongly approximating. In case that x is strongly correct
and its witnesses L ⊆ω and pt ∈P(1) ﬁt well together, we call x perfect.
From the next results we obtain that any strongly acceptable numbering is
uniquely determined up to strong m-equivalence and any strongly correct one up
to strong m-a-equivalence.
Lemma 34. Let x, x′ ∈Nump(T). Then the following three statements hold:
1. If x is strongly computable and x′ ≤s
m x, then x′ is strongly computable as well.
2. If x strongly allows eﬀective limit passing and x ≤s
m x′, then also x′ strongly
allows eﬀective limit passing.
3. If x is strongly approximating and x ≤a,s
m
x′, then x′ is strongly approximating
as well.

An Isomorphism Theorem for Partial Numberings
|
359
Proof. (1) Let L ⊆ω and g ∈P(1), respectively, witness that x is computable and
x′ ≤s
m x. Then the set { ⟨i, n⟩| ⟨g(i), n⟩∈L } witnesses the computability of x′. Let
i ∈ω and suppose that { Bn | ⟨g(i), n⟩∈L } is a base of the neighbourhood ﬁlter
of some point y ∈T. Then g(i) ∈dom(x) and xg(i) = y. As g is a strong reduction
function, it follows that i ∈dom(x′) and x′
i = y.
(2) Let pt, g ∈P(1) witness that x allows eﬀective limit passing and x ≤s
m
x′, respectively. Then the function g ◦pt witnesses that also x′ allows eﬀective
limit passing. Now, let m ∈ω such that g(pt(m)) ∈dom(x′). Since g is a strong
reduction function, we have that pt(m) ∈dom(x). Hence, the collection of all Ba
with a ∈range(φm) is a base of N(xpt(m)). But xpt(m) = x′
g(pt(m)).
(3) Now, let pt, g ∈P(1), respectively, witness that x is approximating and
x ≤a,s
m x′. Then g ◦pt also witnesses that x′ is approximating.
If x, x′ ∈Nump(T) with x being approximating and x′ computable, and if x ≤a
m x′
via g ∈P(1), it follows from above that x is computable as well via L = { ⟨i, n⟩|
⟨g(i), n⟩∈L′ }. Then, if L, pt ﬁt well together, the same holds for L′ and g ◦pt.
Lemma 35. Let x, x′ ∈Nump(T) such that x is perfect and x′ strongly approximat-
ing. If x ≤s,a
m x′, then x′ is perfect as well.
Proof. Let L′ ⊆ω and g ∈P(1), respectively, witness that x′ is strongly com-
putable and x ≤s,a
m
x′. As we have just seen, pt′ = g ◦pt witnesses that x′ also
is strongly approximating. Set
L′ = L′ ∪{ ⟨pt′(m), n⟩| pt(m)↓∧g(pt(m))↓∧⟨pt(m), n⟩∈L }.
Obviously, L′ and pt′ ﬁt well together. It remains to show, that L′ too witnesses
that x′ is strongly computable.
To this end, let i ∈dom(x′) and n ∈ω. If x′
i ∈Bn, then ⟨i, n⟩∈L′ and hence
⟨i, n⟩∈L′. Conversely, if ⟨i, n⟩∈L′, then ⟨i, n⟩∈L′ and thus x′
i ∈Bn, or there
is some m ∈ω such that i = g(pt(m)) and ⟨pt(m), n⟩∈L. Since g(pt(m)) ∈
dom(x′), it follows that pt(m) ∈dom(x). Hence, xpt(m) ∈Bn which implies that
x′
g(pt(m)) ∈Bn.
Next assume that { Bn | ⟨i, n⟩∈L′ } is a strong base of the neighbourhood
ﬁlter of some point y ∈T. Let us ﬁrst consider the case that i = g(pt(m)), for
some m ∈ω. Then { Bn | ⟨pt(m), n⟩∈L } is a strong base of N(y). Hence, pt(m) ∈
dom(x) and xpt(m) = y. It follows that g(pt(m)) ∈dom(x′) and x′
g(pt(m)) = y. In
the remaining case we have that { Bn | ⟨i, n⟩∈L′ } is a strong base of N(y), and
hence by strong computability of x′ that i ∈dom(x′) with x′
i = y.
Lemma 36. Let x, x′ ∈Nump(T) so that x is correct and x′ approximating. Then
x ≤a
m x′.

360
|
Dieter Spreen
Proof. Let q ∈R(1) be as in Lemma 27 and pt′ ∈P(1) witness that x′ is approxi-
mating. Then the function pt′ ◦q witnesses that x ≤m x′.
Now, let m be an index of a p-normed computable enumeration of basic open
sets. Then pt(m) is deﬁned, as pt admits ﬁlters. Hence, q(pt(m)) is deﬁned as well
and is an index of a p-normed computable enumeration of basic open sets, from
which it ﬁnally follows that also pt′(q(pt(m))) is deﬁned.
As is well known, each point y of a T0 space is uniquely determined by its neigh-
bourhood ﬁlter N(y) and/or a base of it. A point y is ﬁnite if N(y) has a ﬁnite and
hence a singleton base.
Lemma 37. Let T = (T, τ) be a countable topological T0 space with countable ba-
sis B and total numbering B of B that has no ﬁnite points. Moreover, let ≺B be com-
putably enumerable. Then for any two numberings x, x′ ∈Nump(T), if x is strongly
computable and x′ strongly allows eﬀective limit passing, then x ≤s
m x′.
Proof. Again, let q ∈R(1) be as in Lemma 27 and pt′ ∈P(1) witness that x′
strongly allows eﬀective limit passing. Then the function pt′ ◦q witnesses that
x ≤m x′. In particular this means that pt′(q(i)) ∈dom(x′), for i ∈dom(x). Now,
conversely, assume that pt′(q(i)) ∈dom(x′). Then { Bm | m ∈range(φq(i)) } is
a base of N(x′
pt′(q(i))). As x′
pt′(q(i)) is nonﬁnite, φq(i) must be total. Consequently,
by Lemma 27(2),(4), { Bn | ⟨i, n⟩∈L } is a base of N(x′
pt′(q(i))) as well. It is even a
strong base. Here, L ⊆ω witnesses strong computability of x. Hence, i ∈dom(x)
and xi = x′
pt′(q(i)).
Corollary 38. Let T = (T, τ) be a countable topological T0 space with countable
basis B and no ﬁnite points. Let x and B, respectively, be numberings of T and B such
that B is total and x strongly acceptable. Moreover, let ≺B be computably enumer-
able. Then for any numbering x′ ∈Nump(T) the following three statements hold:
1. x′ is strongly computable if, and only if, x′ ≤s
m x.
2. x′ strongly allows eﬀective limit passing if, and only if, x ≤s
m x′.
3. x′ is strongly acceptable if, and only if, x′ ≡s
m x.
If x is even strongly correct, we have in addition:
4. x′ is strongly approximating if, and only if, x ≤a,s
m x′.
5. x′ is strongly correct if, and only if, x′ ≡a,s
m x.
For strongly acceptable numberings correct precompleteness can conveniently be
characterized.
Lemma 39. Let T = (T, τ) be a countable topological T0 space with countable
basis B and no ﬁnite points. Let x and B, respectively, be numberings of T and B

An Isomorphism Theorem for Partial Numberings
|
361
such that B is total and x strongly acceptable. In addition, let ≺B be computably
enumerable. Then x is correctly precomplete if, and only if, there is a total function
witnessing that x strongly allows eﬀective limit passing.
Proof. Let L ⊆ω and pt ∈P(1), respectively, witness that x is strongly computable
and strongly allows eﬀective limit passing. Moreover, for the “if” part, let g ∈
P(1), q ∈R(1) be as in Lemma 27, and k ∈R(1) with φk(i) = φq(g(i)). Then, for
i ∈dom(g) such that g(i) ∈dom(x), k(i) is an index of a normed computable
enumeration of basic open sets converging to xg(i). Thus, pt(k(i)) ∈dom(x) and
xpt(k(i)) = xg(i). Set f = pt ◦k. Since pt ∈R(1), also f ∈R(1).
Now, conversely, suppose that f(i) ∈dom(x). Consequently, the collection of
all Ba with a ∈range(φq(g(i))) is a base of N(xf(i)). As in the proof of Lemma 37
it follows that { Ba | ⟨g(i), a⟩∈L } is even a strong base of N(xf(i)). Thus, g(i) ∈
dom(x), as x is strongly computable.
For the “only if” part assume that x is correctly precomplete. Then there is a
function pt ∈R(1) with xpt(m) = xpt(m), for m ∈dom(pt) with pt(m) ∈dom(x).
Obviously, pt too witnesses that x allows eﬀective limit passing. To see that it does
so also strongly, let m ∈ω such that pt(m) ∈dom(x). Then pt(m) ∈dom(x) as
well. It follows that the set of all Ba with a ∈range(φm) is a base of N(xpt(m)). But
xpt(m) = xpt(m).
The next two results are now consequences.
Theorem 40 (First Isomorphism Theorem for Eﬀective Spaces). Let T = (T, τ)
be a countable topological T0 space with countable basis B and total numbering B
of B that has no ﬁnite points. In addition, let ≺B be computably enumerable. Then
any two strongly acceptable numberings with total limit passing witnesses are com-
putably isomorphic.
Proof. Apply Theorem 13 and Corollary 38.
Corollary 41. Let T = (T, τ) be a countable topological T0 space with countable
basis B and no ﬁnite points. Let x and B, respectively, be numberings of T and B
such that B is total and x strongly acceptable. Moreover, let ≺B be computably enu-
merable. Then, if x is correctly precomplete, it is strongly correct.
In the remainder of this section we will deal with the question when strongly cor-
rect numberings are uniformly productive. A ﬁrst condition space T has to satisfy
is that it has the eﬀective Urysohn property.

362
|
Dieter Spreen
Deﬁnition 42. Let T = (T, τ) be a countable topological T0 space with countable
basis B and total numbering B of B. T has the eﬀective Urysohn property if there
is a countable family (Am)m∈ω of closed sets such that the following hold:
1. Am is completely enumerable, uniformly in m, i.e., there is a function s ∈R(1)
with Am = Ms(m), for all m ∈ω.
2. Bm ⊆Am, for all m ∈ω.
3. If m ≺B n then Am ⊆Bn, for all m, n ∈ω.
Moreover, we will need to enumerate all indices of nonempty basic open sets. This
can always be achieved if x is computable and the space is computably separable,
which means that it has a dense enumerable subset, called its dense base.
In this case we can also semidecide whether Bn \ Am is not empty and eﬀec-
tively ﬁnd a witness.
Lemma 43. Let T = (T, τ) be a countable topological T0 space with countable
basis B, and let B and x, respectively, be numberings B of B and T so that B is total
and x computable. Moreover, let T be computably separable and have the eﬀective
Urysohn property. Then there is a function r ∈P(2) with the following properties:
1. dom(r) = { (m, n) | Bn \ Am ̸= ∅}.
2. If Bn \ Am is not empty, then r(m, n)↓∈dom(x) and xr(m,n) ∈Bn \ Am.
Proof. Let L ⊆ω witness the computability of x and g ∈R(1) with range(g) ⊆
dom(x) such that (xg(a))a∈ω is an enumeration of the dense subset of T. Moreover,
let s ∈R(1) be as in the preceding deﬁnition. Set
C = { ⟨m, n, a⟩| ⟨g(a), n⟩∈L ∧g(a) ∈Ws(m) }
and with respect to some ﬁxed enumeration of C let ⟨m, n, a⟩be the ﬁrst element
enumerated so that m = m and n = n, for given m, n ∈ω. Then set r(m, n) =
g(a).
As Bn\Am is not empty, just if Bn∩Am contains a dense element of T, function
r has the desired properties.
Theorem 44. Let T = (T, τ) be a countable topological T0 space without ﬁnite
points such that topology τ has a countable basis B. Let x and B be numberings of
T and B, respectively, such that B is total and x is strongly correct. Moreover, let T
be computably separable and have the eﬀective Urysohn property. Finally, let ≺B be
computably enumerable. Then x is uniformly productive.
Proof. The proof proceeds by uniformly reducing the complement of the halting
set K, which is known to be productive, to each ﬁber of x as well as to the comple-
ment of its domain.

An Isomorphism Theorem for Partial Numberings
|
363
Let L ⊆ω and pt ∈P(1) witness the strong correctness of x. Moreover, let
r ∈P(2) be as in the preceding lemma and deﬁne
F = { ⟨i, m, n⟩| ⟨i, m⟩, ⟨i, n⟩∈L ∧m ≺B n ∧r(m, n)↓}.
Clearly, F is computably enumerable. Set F′ = π1(F). Then F′ ⊇dom(x). To see
this, let i ∈dom(x). By the strong base property there are m1, m2, m3 ∈ω with
xi ∈Bmρ, for ρ = 1, 2, 3, such that m1 ≺B m2 ≺B m3. Hence, we have that
Bm1 ⊆Am1 ⊆Bm2 ⊆Am2 ⊆Bm3.
Since xi is not ﬁnite, the indices can be chosen so that Bm2 ̸= Bm3. Therefore,
Am1 ⫋Bm3.
As shown in [19], dom(x) is Π0
2-hard. Since F′ is computably enumerable, it
even follows that F′ ⫌dom(x).
With respect to a ﬁxed enumeration of F, let k(i), for i ∈ω, be the ﬁrst tripel
⟨¯ı, m, n⟩with ¯ı = i. In addition, let p ∈R(2) be as in Lemma 27 and ¯q ∈R(1) with
φ¯q(i)(a) = π3−a(k(i)),
for a = 0, 1,
φ¯q(i)(a + 2) = φp(i,π2(k(i)))(a),
for a ∈ω.
Then we have for all i ∈F′ that φ¯q(i)(a)↓, for a = 0, 1. If i ∈dom(x), { Bm | m ∈
range(φ¯q(i)) } is a strong base of N(xi).
Next, deﬁne functions v ∈P(2), u ∈R(2) and g ∈P(1) as follows:
v(i, 0) = 0,
v(i, 1) = 1,
and for a ≥1,
v(i, a + 1) =







ﬁrst j > v(i, a) enumerated
with r(φ¯q(i)(j), φ¯q(i)(v(i, a)))↓
if such j exists,
undeﬁned
otherwise;
u(i, 0) = 0,
u(i, a + 1) =













u(i, a) + 1
if there is some j ≤a + 1 with j > v(i, u(i, a) + 1)
and r(φ¯q(i)(j), φ¯q(i)(v(i, u(i, a) + 1)))↓a+1,
u(i, a)
otherwise;
g(n) = µc : n ∈Kc.
Then g(n) ≥1, by deﬁnition of Kc. Finally, set
φh(i,n)(a) =

φ¯q(i)(v(i, u(i, a)))
if n ̸∈Ka,
φp(ˆr(i,a),φ¯q(i)(v(i,u(i,g(n)−1))))(a −g(n))
otherwise,

364
|
Dieter Spreen
where
ˆr(i, a) = r(φ¯q(i)(v(i, u(i, g(n) −1))), φ¯q(i)(v(i, u(i, g(n) −1)))).
Let φˆq(i)(a) = φ¯q(i)(v(i, u(i, a))). Then, for i ∈F′, h(i, n) is an index of a
computable enumeration of basic open sets that follows the enumeration with
index ˆq(i) as long as n has not been found in K. If n has been found in K, say in
step ¯a, then the construction is such that
Bφ¯q(i)(v(i,u(i,¯a−1)+1)) ⊆Aφ¯q(i)(v(i,u(i,¯a−1)+1)) ⫋Bφ¯q(i)(v(i,u(i,¯a−1))).
(2)
As shown in Lemma 43, we can therefore eﬀectively ﬁnd a point
z ∈Bφ¯q(i)(v(i,u(i,¯a−1)))
which is not included in Aφ¯q(i)(v(i,u(i,¯a−1)+1)). Since
xi ∈Bφ¯q(i)(v(i,u(i,¯a−1)+1)),
this is suﬃcient for z being diﬀerent from xi. Now, we modify our enumeration
by no longer following the enumeration with index ˆq(i), but an enumeration con-
verging to z.
Since we have to assure that the condition in Line (2) is satisﬁed as long as
n has not been found in K, we always have to look one step ahead. Therefore,
the enumeration with index ˆq(i) need not be normed. We possibly have to pause
till some value n has been found in the enumeration with index ¯q(i) that is not
only better than the present value of φˆq(i), say m, with respect to the given strong
inclusion relation ≺B, but in addition is such that An ⫋Bm.
Deﬁne
C = { ⟨i, n, a, a′⟩| a < a′ ∧φh(i,n)(a′) ≺B φh(i,n)(a) }.
Then C is computably enumerable. Let some enumeration of C be ﬁxed and for
i, n, a ∈ω, ⟨¯ı, ¯n, ¯a, ¯a′⟩be the ﬁrst element enumerated with ¯ı = i, ¯n = n and
¯a = a. Set t(i, n, a) = ¯a′.
Claim 1 (∀i, n, a ∈ω)[i ∈dom(x) ∨(i ∈F′ ∧n ∈K) =⇒t(i, n, a)↓].
Proof of Claim:
Case 1 i ∈F′ ∧n ∈K.
Then g(n) is deﬁned and by construction φ¯q(i)(v(i, u(i, g(n) −1))) as well as
φ¯q(i)v(i, (u(i, g(n) −1) + 1)) are deﬁned with
Aφ¯q(i)(v(i,u(i,g(n)−1)+1)) ⫋Bφ¯q(i)(v(i,u(i,g(n)−1))).

An Isomorphism Theorem for Partial Numberings
|
365
Thus,
p(r(φ¯q(i)(v(i, u(i, g(n) −1) + 1)), φ¯q(i)(v(i, u(i, g(n) −1)))),
φ¯q(i)(v(i, u(i, g(n) −1))))
is an index of a converging normed enumeration of basic open sets. Since for a <
g(n), either φh(i,n)(a + 1) ≺B φh(i,n)(a) or φh(i,n)(a + 1) = φh(i,n)(a), and
φp(r(φ¯q(i)(v(i,u(i,g(n)−1)+1)),φ¯q(i)(v(i,u(i,g(n)−1)))),φ¯q(i)(v(i,u(i,g(n)−1))))(a −g(n))
≺B φ¯q(i)(v(i, u(i, g(n) −1))),
we obtain that t(i, n, a) is deﬁned, for all a ∈ω.
Case 2 i ∈dom(x) ∧n ̸∈K.
Then { B(φp(i,π2(k(i)))(a) | a ∈ω } is inﬁnite, as xi is not ﬁnite. Therefore,
λa.u(i, a) grows unboundedly, which implies that range(φ¯q(i)) and hence also
range(φh(i,n)) are inﬁnite. Thus, in this case as well, t(i, n, a) is deﬁned, for all
a ∈ω.
Let d ∈R(2) with
φd(i,n)(0) = φh(i,n)(0),
φd(i,n)(a + 1) = φh(i,n)(t(i, n, a)).
By what has just been shown, we now obtain:
Claim 2
1. If n ∈K and i ∈dom(x), d(i, n) is an index of a normed enumeration of basic
open sets converging to some point z ∈T which is diﬀerent from xi.
2. If n ∈K and i ∈F′ \ dom(x), d(i, n) is an index of a converging normed
enumeration of basic open sets.
3. If n ̸∈K and i ∈dom(x), d(i, n) is an index of a normed enumeration of basic
open sets converging to xi.
4. If n ̸∈K and i ∈F′ \ dom(x), pt(d(i, n)) is deﬁned with pt(d(i, n)) ̸∈dom(x).
Proof of Claim: (1,2) By construction d(i, n) is an index of a normed enumeration
of basic open sets converging to
xr(φ¯q(i)(v(i,u(i,g(n)−1)+1)),φ¯q(i)(v(i,u(i,g(n)−1))))
∈Bφ¯q(i)(v(i,u(i,g(n)−1))) \ Bφ¯q(i)(v(i,u(i,g(n)−1)+1)).
If i ∈dom(x), we have that xi ∈B(φ¯q(i)(v(i, u(i, g(n) −1) + 1))). Thus,
xr(φ¯q(i)(v(i,u(i,g(n)−1)+1)),φ¯q(i)(v(i,u(i,g(n)−1)))) ̸= xi.

366
|
Dieter Spreen
If i ∈F′ \ dom(x), it remains true that d(i, n) is an index of a converging
normed enumeration of basic open sets.
(3) As follows from the construction of φh(i,n) and φ¯q(i), d(i, n) is an index of
a normed enumeration of basic open set converging to xi in this case.
(4) Now, d(i, n) is an index of a p-normed enumeration of basic open sets.
Hence, pt(d(i, n)) is deﬁned, as x is approximating.
Assume that pt(d(i, n)) ∈dom(x). Since x strongly allows eﬀective limit pass-
ing, we have that
{ Ba | a ∈range(φd(i,n)) }
is a strong ﬁlter base of the neighbourhood ﬁlter of some point y ∈T. Because
n ̸∈K, it follows that
{ Bc | c ∈range(λa.φ¯q(i)(v(i, u(i, a)))) }
and hence
{ Bc | c ∈range(λa.φp(i,π2(k(i)))) }
are strong ﬁlter bases of N(y) as well. Then { Bc | ⟨i, c⟩∈L } too is a strong ﬁlter
base of N(y). By assumption, x is strongly computable. Thus, i ∈dom(x) with
xi = y, a contradiction.
Let ˆd ∈R(1) such that φˆd(i)(n) = d(i, n). Then pt ◦φˆd(i) witnesses that the
following two reducibility statements hold:
1. For i ∈dom(x), (K, K) ≤m (x−1({xi}), dom(x) \ x−1({xi})).
2. For i ∈F′ \ dom(x), (K, K) ≤m (dom(x), dom(x)).
Since K is productive, there is a productive function f ∈R(1) so that for all j ∈ω,
Wj ⊆K =⇒f(j) ∈K \ Wj.
Let v ∈R(1) with φv(i) = pt ◦φˆd(i), and s ∈R(2) so that Ws(i,j) = φ−1
v(i)(Wj).
Moreover, let φ¯k(i) = λj.φv(i)(f(s(i, j))).
Then, in case that i ∈dom(x), we have for j ∈ω with Wj ⊆x−1({xi}) that
Ws(i,j) ⊆K and therefore that f(s(i, j)) ∈K \ Ws(i,j), from which we obtain that
φv(i)(f(s(i, j))) ∈x−1({xi}) \ φv(i)(Ws(i,j)) ⊆x−1({xi}) \ Wj.
Similarly, if follows for i ∈F′ \ dom(x) and Wj ⊆dom(x) that
φ¯k(i)(j) ∈dom(x) \ Wj.

An Isomorphism Theorem for Partial Numberings
|
367
It would be interesting to know whether the requirement on T not to contain ﬁnite
elements can be relaxed. As follows from [19], numbering x cannot be uniformly
productive if the space has a maximal ﬁnite element.
If strong inclusion is computably enumerable and T has no ﬁnite points, any
two strongly correct numberings are strongly equivalent, by Corollary 38. As a Con-
sequence of Theorems 20 and 44 we therefore obtain our second isomorphism
result for eﬀective spaces.
Theorem 45 (Second Isomorphism Theorem for Eﬀective Spaces). Let T = (T, τ)
be a countable topological T0 space without ﬁnite points such that topology τ has a
countable basis B. Let B be a total numbering of B. Moreover, let T be computably
separable and have the eﬀective Urysohn property. Finally, let ≺B be computably
enumerable. Then any two strongly correct numberings of T are computably iso-
morphic.
6 A perfect numbering
In this section we will show that each countable T0 space T = (T, τ) with count-
able basis B, total numbering B of B and strong inclusion relation ≺B with respect
to which B is a strong basis has a perfect numbering x of its points.
For i ∈ω such that { Bn | n ∈Wi } is a strong base of the neighbourhood ﬁlter
of some point y ∈T set xi = y. Otherwise, let x be undeﬁned.
Then xi ∈Bn, exactly if n ∈Wi. Thus, x is computable with L = { ⟨i, n⟩| n ∈
Wi }. As follows from the deﬁnition, it is even strongly computable. Obviously,
any function t ∈P(1) with Wt(m) = range(φm) witnesses that x strongly allows
eﬀective limit passing. Since such index functions can always be chosen as total, it
follows that x is also strongly approximating. Thus, x is strongly correct. Because
L and t ﬁt well together, it is even perfect.
Proposition 46. Let T = (T, τ) be a countable T0 space with countable basis B,
total numbering B of B and strong inclusion relation ≺B with respect to which B
is a strong basis. Then T has a perfect numbering, which, in addition, is correctly
precomplete in case that T has no ﬁnite points and ≺B is computably enumerable.
The second statement is a consequence of Lemma 39.
As follows from Lemma 35, perfectness is inherited among strongly correct
numberings with respect to strong m-a-equivalence. Moreover, by Corollary 38,

368
|
Dieter Spreen
any two strongly correct numberings are strongly m-a-equivalent, if strong inclu-
sion is computably enumerable and T has not ﬁnite points.
Corollary 47. Let T = (T, τ) be a countable T0 space with countable basis B, total
numbering B of B and computably enumerable strong inclusion relation ≺B with
respect to which B is a strong basis. If T has no ﬁnite points, every strongly correct
numbering of T is perfect.
With Theorem 45 we moreover have that every strongly correct numbering of space
T can be obtained from the numbering deﬁned in this section by a computable in-
dex permutation, in case the space is computably separable and has a computably
enumerable strong inclusion relation, the eﬀective Urysohn property as well as no
ﬁnite points.
We will give a further example of an acceptable numbering, which is perfect
in case the space has no ﬁnite points.
Assume that ≺B is computably enumerable. If m is an index of a normed com-
putable enumeration of basic open sets converging to a point y ∈T, set ˆx = y.
Otherwise, let ˆx be undeﬁned. As follows from Lemma 27, there is such index for
every point in T. Thus, ˆx ∈Nump(T). The identity function on ω witnesses that ˆx
strongly allows eﬀective limit passing. It is even strongly approximating. Set
ˆL = { ⟨m, n⟩| (∃a ∈ω)(∀c ≤a)φm(c)↓∧φm(a) ≺B n }.
Then ˆL witnesses that ˆx is computable.
Lemma 48. Let T = (T, τ) be a countable topological T0 space without ﬁnite
points such that topology τ has a countable basis B with total numbering B. In addi-
tion, let ≺B be computably enumerable. Then ˆx is strongly acceptable and correctly
precomplete.
Proof. It remains to show that ˆx is strongly computable. Correct precompleteness
is then a consequence of Lemma 39.
Let m ∈ω such that B(Em) with Em = { n ∈ω | ⟨m, n⟩∈ˆL } is a strong base
of the neighbourhood ﬁlter of some point y ∈T. Since T has no ﬁnite points, the
set
{ a ∈ω | (∃n ∈Em)(∀c ≤a)φm(c)↓∧φm(a) ≺B n }
is unbounded. Hence, B(φm(a))a∈ω is a normed computable enumeration of a
basis of N(y), which means that m ∈dom(ˆx) and ˆxm = y.
Under the above assumptions it now follows by Corollary 47 that ˆx is also perfect.
Moreover, as a consequence of Theorem 40, ˆx is computably isomorphic to num-
bering x deﬁned above.

An Isomorphism Theorem for Partial Numberings
|
369
7 Constructive metric spaces
In this section, ﬁnally, we present an important standard example of eﬀective T0
spaces: constructive metric spaces. We will show that for a large and important
subclass of these spaces the assumptions in Theorem 45 hold.
Deﬁnition 49. Let S = (S, δ) be a countable separable metric space and β be a
total numbering of the dense subset S0. S is said to be constructive, if the sets
{ ⟨i, j, a, n⟩| δ(βi, βj) < a · 2−n }
and
{ ⟨i, j, a, n⟩| δ(βi, βj) > a · 2−n }
are computably enumerable.
Well-known examples of constructive metric spaces include Rn
c, that is the space
of all n-tuples of computable real numbers with the Euclidean or the maximum
norm; Baire space, that is the set R(1) of all total computable functions with the
Baire metric [17]; and the set ω with the discrete metric. By using an eﬀective ver-
sion of Weierstraß’s approximation theorem [15] and Sturm’s theorem [27] it can
be shown that Cc[0, 1], the space of all computable functions from [0, 1] to R with
the supremum norm [15], is a constructive metric space too. A proof of this result
and further examples can be found in Blanck [3].
As is well-known, the collection of sets B⟨i,m⟩= { y ∈S | δ(βi, y) < 2−m } (i,
m ∈ω) is a basis of the canonical Hausdorﬀtopology ∆on S. In such a topology
the ﬁnite points coincide with the isolated ones.
Deﬁne
⟨i, m⟩≺B ⟨j, n⟩⇔δ(βi, βj) + 2−m < 2−n.
Using the triangle inequality it is readily veriﬁed that ≺B is a strong inclusion and
the collection of all Ba is a strong basis. Moreover, ≺B is computably enumerable.
In the theory of separable metric spaces one usually works with point se-
quences instead of ﬁlters.
Deﬁnition 50. A sequence (ya)a∈ω of points of S is a normed Cauchy sequence, if
δ(ym, yn) < 2−m, for all n ≥m.
In case all sequence elements belong to the dense subset S0, such a sequence is
called computable, if there is a function g ∈R(1) with ya = βg(a), for a ∈ω. Any
Gödel number of g is said to be an index of (ya)a∈ω.
Deﬁnition 51. Let x ∈Nump(S). We say that x has a strong limit algorithm, if there
is a function li ∈P(1) such that the following properties hold:

370
|
Dieter Spreen
1. dom(li) ⊇{ m ∈ω | dom(φm) is an initial segment of ω }.
2. If m is an index of a convergent normed Cauchy sequence of elements of S0,
then li(m)↓∈dom(x) with xli(m) = lima β(φm(a)).
3. If m ∈li−1(dom(x)), then xli(m) is either isolated and there is some a ∈
dom(φm) such that β(φm(a)) = xli(m) and δ(β(φm(c)), β(φm(e))) < 2−c, for
all c ≤e ≤a, or xli(m) is not isolated and m is an index of a normed Cauchy
sequence of elements of S0 converging to xli(m).
We say that x has a general limit algorithm if there is a function ˆli ∈P(1) with Prop-
erties 51(1-3) where numbering β has been replaced by numbering x and accord-
ingly Cauchy sequences may have elements in S. In case that only Condition 51(2)
holds, we say that x has a weak general limit algorithm.
Note that Condition 51(1) is quite natural. Given an arbitray m, we do not know
whether it is an index of a normed Cauchy sequence. Also, we cannot test this
in a preprocessing step: we need to verify it while approximating. Assume that δ-
distances between points in S0 are rational, then we could test whether δ(βi, βa) <
2−i in each step a.
The existence of a general limit algorithm is a traditional requirement for con-
structive metric spaces, at least in the weak form that only Condition 51(2) is re-
quired. Moschovakis [13] calls it Property (A) (cf. also [5]). Here, we are only con-
cerned with the existence of a strong limit algorithm as in Deﬁnition 51.
Lemma 52. Let x ∈Nump(S). Then the following two statements hold:
1. If x is strongly approximating, then it has a strong limit algorithm with total
function li.
2. If x has a strong limit algorithm and the space has no isolated points, then x
strongly allows eﬀective limit passing with total witness function pt.
Proof. (1) Let pt ∈P(1) witness that x is strongly approximating and k ∈R(1) with
φk(n)(a) =

⟨φn(a + 1), a⟩
if δ(βφn(c), βφn(a + 1)) < 2−c, for all c ≤a,
undeﬁned
otherwise.
Then dom(φk(n)) is an initial segment of ω. Therefore, pt(k(n)) is deﬁned. Set
li = pt ◦k. Then li ∈R(1). It remains to verify Conditions 51(2), (3).
Let m be an index of a normed Cauchy sequence converging to y ∈S. Then
(B(φk(m)(a)))a∈ω is a computable normed enumeration of basic open sets con-
verging to y as well. Hence, xli(m) = y.
Conversely, if m
∈li−1(dom(x)), then { Ba
| a
∈range(φk(m)) } is a
base of N(xli(m)). If dom(φk(m)) is ﬁnite, say with maximal element ¯a, then
δ(β(φm(c)), β(φm(e))) < 2−c, for all c ≤e ≤¯a + 1. Moreover, we have that xli(m)

An Isomorphism Theorem for Partial Numberings
|
371
is isolated. As {B(φk(m)(¯a))} also is a base of N(xli(m)), it follows that xli(m) ∈
B(φk(m)(¯a)). By construction we have that β(φm(¯a + 1)) ∈B(φk(m)(¯a)) as well.
Because the topology is Hausdorﬀ, we therefore obtain that xli(m) = β(φm(¯a +1)).
If, however, dom(φk(m)) is inﬁnite, xli(m) is not isolated, and by construction
m is an index of a normed Cauchy sequence converging to xli(m).
(2) Let li ∈P(1) witness that x has a strong limit algorithm and f ∈R(1) with
φf(n)(0) = π1(φn(0)),
φf(n)(a + 1) =







π1(φn(a + 1))
if δ(βπ1(φn(a)), βπ1(φn(a+1)))
+2−π2(φn(a+1)) < 2−π2(φn(a)),
undeﬁned
otherwise.
By construction, dom(φf(n)) is an initial segment of ω. Hence, li(f(n)) is deﬁned.
Set pt = li ◦f. Then pt ∈R(1). Consequently, pt admits ﬁlters. As we will see next,
pt also witnesses that x strongly allows eﬀective limit passing. Let to this end m
be an index of a normed enumeration of basic open sets converging to some point
y ∈S. Since φm is decreasing with respect to ≺B, φf(m) is a total function. More-
over, we have for all a ∈ω that π2(φm(a + 1)) > π2(φm(a)), which implies that
π2(φm(a)) ≥a. Thus, (β(φf(m)(a)))a∈ω is a normed Cauchy sequence converging
to y. It follows that xpt(m) = y.
Let now, conversely, m ∈pt−1(dom(x)). Since xli(f(m)) is not isolated, f(m)
is an index of a normed Cauchy sequence converging to xli(f(m)). Hence φf(m) is a
total function. It follows that for all c ∈ω,
δ(β(π1(φm(c))), β(π1(φm(c + 1)))) + 2−π2(φf(m)(c+1)) < 2−π2(φm(c)).
This shows that (B(φm(a)))a∈ω is a normed enumeration of basic open sets
converging to xpt(m), which implies that { Ba | a ∈range(φm) } is a base of
N(xpt(m)).
Because of Lemma 39 the second statement has an important consequence.
Proposition 53. Every numbering of a constructive metric space without isolated
points that has a strong limit algorithm is correctly precomplete.
In studies of constructive metric spaces mostly the normed Cauchy numbering ¯x is
used: if m is an index of a normed Cauchy sequence of points of the dense subset
S0 with limit y ∈S, set ¯xm = y; otherwise, let ¯x be undeﬁned.
Lemma 54. The normed Cauchy numbering of a constructive metric space is
strongly computable and has a strong limit algorithm.

372
|
Dieter Spreen
Proof. The identity on ω witnesses that ¯x has a strong limit algorithm. Set
L = { ⟨m, ⟨a, n⟩⟩|(∀e < n)φm(e)↓∧(∀c ≤e)δ(βφm(c), βφm(e)) < 2−c
∧(∃c ∈ω)⟨φm(c), c⟩≺B ⟨a, n⟩}.
Then L testiﬁes the computability of ¯x. To see that ¯x is even strongly computable,
let i ∈ω such that { B⟨a,n⟩| ⟨i, ⟨a, n⟩⟩∈L } is a strong base of the neighbour-
hood ﬁlter of some point y ∈S. It follows that φi(e) is deﬁned for all e ∈ω
with δ(βφm(c), βφm(e)) < 2−c, for all c ≤e. Moreover, there is a c ∈ω with
β(φi(c)) ∈B⟨a,n⟩, for all B⟨a,n⟩∈N(y). Thus, i ∈dom(¯x) with ¯xi = y.
We will now show that S has the eﬀective Urysohn property. Set
A⟨i,m⟩= { y ∈S | δ(βi, y) ≤2−m }.
Then A⟨i,m⟩is closed. Moreover, for a computable numbering x of S,
xa ∈A⟨i,m⟩⇐⇒(∃⟨j, n⟩)B⟨j,n⟩∩A⟨i,m⟩= ∅∧xa ∈B⟨j,n⟩
⇐⇒(∃⟨j, n⟩)δ(βi, βj) > 2−m + 2−n ∧⟨a, ⟨j, n⟩⟩∈L,
where L ⊆ω witnesses the computability of x. Thus, A⟨i,m⟩is completely enumer-
able, uniformly in ⟨i, m⟩.
Finally, assume that ⟨i, m⟩≺B ⟨j, n⟩and let y ∈A⟨i,m⟩. Then δ(βi, y) ≤2−m
and δ(βi, βj) + 2−m < 2−n. By the triangular inequation it follows that δ(βj, y) <
2−n, i.e., y ∈B⟨j,n⟩.
As a special case of Theorem 40 and/or Theorem 45 we now obtain
Theorem 55 (Isomorphism Theorem for Constructive Metric Spaces).
Let S
=
(S, δ) be a constructive metric space without isolated points. Then all of its strongly
computable numberings that in addition have a strong limit algorithm are pairwise
computably isomorphic.
In the beginning of this section we introduced the notion of both a strong and a
general limit algorithm. There is a close relationship between the two.
Lemma 56. Let S = (S, δ) be a constructive metric space without isolated points.
Then a strongly computable numbering x ∈Nump(S) has a strong limit algorithm
if, and only if, β ≤m x and x has a general limit algorithm.
Proof. Let x have a strong limit algorithm. Because of the preceding Isomorphism
Theorem we can assume without restriction that x is the normed Cauchy number-
ing. For n ∈ω set
φk(n)(a) = n.

An Isomorphism Theorem for Partial Numberings
|
373
Then li ◦k witnesses that β ≤m x. Moreover, let g ∈R(1) with
φg(m)(a) =

φφm(a+2)(a + 2)
if δ(xφm(c), xφm(a)) < 2−c, for all c ≤a,
undeﬁned
otherwise.
If m is an index of a converging normed Cauchy sequence of points in S, then
g(m) is an index of a normed Cauchy sequence of points in S0 with the same
limit. Thus, the analogues of Conditions 51(1, 2) hold. For the third condition let
g(m) ∈dom(x). Then g(m) is an index of a converging normed Cauchy sequence
of points in S0. Therefore, φm is a total function and consequently, by the deﬁni-
tion of φg(m), m is an index of a normed Cauchy sequence of points in S converging
to xg(m). It follows that x has a general limit algorithm.
Conversely, let r ∈R(1) witness that β ≤m x and h ∈R(1) with
φh(m)(a) = r(φm(a)).
Set li = ˆli ◦h. Since h is a total function, li is total as well. Moreover, if m is an
index of a converging normed Cauchy sequence of points in S0, then h(m) is an
index of the same sequence, only that now the index is calculated with respect
to x-indices. Thus, xli(m) = lima β(φm(a)). If li(m) ∈dom(x), then h(m) is an
index of a normed Cauchy sequence of points in S0 converging to xˆli(h(m)). Hence,
m is an index of the same sequence, but calculated with respect to β-indices. This
shows that x has a strong limit algorithm.
In the literature metric partial algebras have been studied (cf. [5], and [2] for a
more general approach). In this case numberings are of interest with respect to
which the operations of the algebra are realizable, in particular the metric and
the limit passing operation. Such algebras contain a dense subalgebra generated
by the ﬁnitary algebra operations and there is a canonical indexing of the dense
elements which is m-reducible to any of these numberings.
Let R denote the set of all real numbers, and let νD be some canonical total
indexing of the dyadic rational numbers, e.g., νD(⟨i, j, a⟩) = (i −j)/2a. Then a
real number z is said to be computable if there is a function f ∈R(1) such that
for all m, n ∈ω with m ≤n, the inequality |νD
f(m) −νD
f(n)| < 2−m holds and
z = limm νD
f(m). Any Gödel number of function f is called an index of z. This deﬁnes
a partial indexing γ of the set Rc of all computable real numbers.
The eﬀectivity of the metric δ now means that there is a function d ∈P(2) such
that dom(x)2 ⊆d−1(dom(γ)) and for i, j ∈dom(x), δ(xi, xj) = γd(i,j). Since the
strict order on the computable reals is completely enumerable [12], any numbering
with respect to which the metric is realizable and to which β is m-reducible, is
computable.

374
|
Dieter Spreen
It was shown in [5] that any two numberings of the algebra with respect to
which the algebra operations, and in particular the metric, are realizable and
which have a weak general limit algorithm are m-equivalent. The above result
shows that numberings satisfying slightly stronger, but still very natural require-
ments are even computably isomorphic.
An important example of a metric partial algebra is the structure
Rc = (Rc, 0, 1, +, −, ∗, 1/·, NormLim, <)
of the computable real numbers with the usual ﬁeld operations, the strict order
relation, and the partial limit operation that maps computable normed Cauchy
sequences to their limits. Moschovakis [12, Theorem 4] showed that any two num-
berings of the computable reals with respect to which the ﬁeld operations are
realizable, the order relation is completely enumerable, and which have a weak
general limit algorithm are m-equivalent (cf. also [9]). Note that by the Theorem
of Moschovakis-Ce˘ıtin-Spreen [13; 6; 21] the eﬀectivity of the ﬁeld operations is
equivalent to their eﬀective continuity.
Since the order relation on the dyadic rationals is decidable and
|νD
i −νD
j | < a · 2−n ⇐⇒νD
i −νD
j < a · 2−n ∧νD
j −νD
i < a · 2−n
(similarly in the other case), Rc is a constructive metric space with respect to the
usual metric.
Now, let x ∈Nump(Rc) such that the arithmetical operations are realizable
and strict order is completely enumerable. As is known, the dyadic rationals are
dense in Rc with respect to the Euclidean topology. By using x-indices of the con-
stants 0, 1 and the computable functions that track the arithmetic operations one
can mimic the buildup of the dyadic rationals and thus construct an m-reduction
f of νD into x [12; 9].
Let h−∈P(2) track subtraction and A ⊆ω witness the complete enumerabil-
ity of the order. Then we have for i ∈dom(x) and a, n ∈ω that
xi ∈B⟨a,n⟩⇐⇒xi −νD
a < 2−n ∧νD
a −xi < 2−n
⇐⇒⟨h−(i, f(a)), f(⟨1, 0, n⟩)⟩, ⟨h−(f(a), i), f(⟨1, 0, n⟩⟩∈A.
Thus x is computable. For two sets C, E ⊆ω let
C · E = { ⟨c, e⟩| (∃a ∈ω)⟨c, a⟩∈C ∧⟨a, e⟩∈E }
and deﬁne
A(1) = A,

An Isomorphism Theorem for Partial Numberings
|
375
A(n+1) =

{ A(m1) · A(m2) | m1, m2 > 0 ∧m1 + m2 = n + 1 },
for n ≥1. Then A∗= { A(n) | n > 0 } is transitiv, which means that from
⟨a, c⟩, ⟨c, e⟩∈A∗it follows that ⟨a, e⟩∈A∗. Moreover, A∗is computably enu-
merable and also testiﬁes that the strict order is completely enumerable.
Now, set
APRX(i, n, a) ⇐⇒h−(i, f(a))↓∧h−(f(a), i)↓∧
⟨h−(i, f(a)), f(⟨1, 0, n⟩)⟩, ⟨h−(f(a), i), f(⟨1, 0, n⟩⟩∈A∗.
Since the dyadic rationals are dense in Rc, it follows for i ∈dom(x) that there is
some a ∈ω with APRX(i, n, a), for all n ∈ω.
Deﬁnition 57. A numbering x ∈Nump(Rc) rendering the arithmetical operations
realizable and strict order completely enumerable, is called
1. faithful , if for all i ∈ω the following holds: in case there is a function g ∈R(1)
such that APRX(i, n, g(n)) and APRX(f(g(n′)), n, g(n)), for all n, n′ ∈ω with
n′ ≥n, and there is an ¯n ∈ω with ⟨g(¯n), ¯n⟩≺B ⟨a, m⟩, for every a, m ∈ω
with APRX(i, m, a), then i ∈dom(x) with xi = limn νD(bn).
2. canonical if it is faithful and has a general limit algorithm.
Lemma 58. Let x ∈Nump(Rc) render the arithmetical operations realizable and
strict order completely enumerable. Moreover, let the computability of x be wit-
nesses by L = { ⟨i, ⟨a, m⟩⟩| APRX(i, m, a) }. Then x is strongly computable, exactly
if it is faithful.
Proof. Let i ∈ω and assume that { B⟨a,m⟩| ⟨i, ⟨a, m⟩⟩∈L } is a strong base of
the neighbourhood ﬁlter of some point y ∈Rc with index, say j ∈ω. We need to
construct a sequence (bn)n∈ω of indices with the required properties. We will do
in such a way that (νD(bn))n∈ω converges to y. The construction proceeds induc-
tively.
As D is dense in Rc, there is some e0 ∈ω such that y ∈B⟨e0,0⟩. Moreover, since
{ B⟨a,m⟩| ⟨i, ⟨a, m⟩⟩∈L } is a strong base of N(y), there exists b0, m0 ∈ω such
that APRX(i, m0, b0), ⟨b0, m0⟩≺B ⟨e0, 0⟩, and y ∈B⟨b0,m0⟩. By the deﬁnition of
≺B for the metric case it follows that 2−m0 < 20. Since A∗is transitive, we obtain
that also APRX(i, 0, b0) and y ∈B⟨b0,0⟩.
Now, suppose we have already constructed bn, mn ∈ω so that ⟨bn, mn⟩≺B
⟨bn′, mn′⟩≺B ⟨bn′, n′⟩, for all n′ < n, APRX(i, n, bn) and y ∈B⟨bn,n⟩. By den-
sity again there is some en+1 ∈ω such that y ∈B⟨en+1,n+1⟩. As above it follows
that there are bn+1, mn+1 ∈ω so that ⟨bn+1, mn+1⟩≺B ⟨bn, mn⟩, ⟨en+1, n + 1⟩,
APRX(i, n + 1, bn+1) and y ∈B⟨bn+1,n+1⟩.

376
|
Dieter Spreen
As ⟨bn′, mn′⟩≺B ⟨bn, n⟩, we have that APRX(f(bn′), n, bn), for all n′ > n.
Since L, APRX and ≺B are computably enumerable, there is some function g ∈
R(1) with bn = g(n). Thus, (νD(bn))n∈ω is a computable normed Cauchy sequence
converging to y.
Let a, m ∈ω with APRX(i, m, a). Then y ∈B⟨a,m⟩. Because |νD(bn)−y|+2−n
converges to 0, there is some ¯n with ⟨b¯n, ¯n⟩≺B ⟨a, m⟩. By faithfulness it now
follows that i ∈dom(x) and xi = limn νD(bn) = y.
For the proof of the converse implication let i ∈ω. Then there is some g ∈
R(1) with APRX(i, n, g(n)) and APRX(f(g(n′)), n, g(n)), for all n, n′ ∈ω so that
n′ ≥n, it follows that (νD(g(n)))n∈ω is a computable normed Cauchy sequence. By
computable completeness it has a limit y ∈Rc (cf. [12], where it is called recursive
completeness). It remains to show that { B⟨a,m⟩| APRX(i, m, a) } is a strong ﬁlter
base of N(y).
Let a, m ∈ω with APRX(i, m, a). Then there is some ¯n ∈ω with ⟨g(¯n), ¯n⟩≺B
⟨a, m⟩. Thus, y ∈B⟨a.m⟩. As a consequence, we obtain for any a, m, a′, m′ ∈ω
with APRX(i, m, a) and APRX(i, m′, a′) that ⟨g(˜n), ˜n⟩≺B ⟨a, m⟩, ⟨a′, m′⟩, for
some ˜n ∈ω. Finally, if y ∈B⟨a,m⟩, for a, m ∈ω, then it follows as above that
there is some ˆn ∈ω so that ⟨g(ˆn), ˆn⟩≺B ⟨a, m⟩.
Because of strong computability we now have that i ∈dom(x) and xi = y =
limn νD
g(n).
As we have already seen, the canonical indexing νD of the dyadic rationals is
m-reducible to every canonical numbering. By Lemma 56 every such numbering
therefore has a strong limit algorithm. Moreover, these numberings are strongly
computable. With Theorem 55 we therefore obtain
Theorem 59 (Isomorphism Theorem for Rc). Any two canonical numberings of
the structure Rc of the computable real numbers are computably isomorphic.
Central notions in the theory of eﬀective topological spaces like acceptability and
strong correctness depend on the topological basis and strong inclusion relation
chosen. In order to establish the correct precompleteness or uniform productivity
of a numbering one often has to choose an appropriate basis and strong inclusion.
As an example we will consider the signed-digit numbering. For simplicity reasons
will restrict our considerations on the subspace given by the interval [−1, +1]c, i.e.
the set of computable real numbers in the interval [−1, +1].
Let
B = { ( a −1
2p
, a + 1
2p
) | p ∈ω ∧−2p < a < 2p }.
Then B also is a base of the Euclidean topology on [−1, +1]c. Moreover, every in-
terval in B can be obtained by a ﬁnite iterated application of the operations L, R, C

An Isomorphism Theorem for Partial Numberings
|
377
to [−1, +1]c, where L, R, C: B →B are deﬁned by
L( a −1
2p
, a + 1
2p
) = (2a −2
2p+1 ,
2a
2p+1 ),
R( a −1
2p
, a + 1
2p
) = ( 2a
2p+1 , 2a + 2
2p+1 ),
C( a −1
2p
, a + 1
2p
) = (2a −1
2p+1 , 2a + 1
2p+1 ).
Thus, each such interval can be coded by a ﬁnite string over {L, R, C}. Set
⌈L⌉= 2,
⌈R⌉= 1
and
⌈C⌉= 0,
and for a ﬁnite string A1 . . . Ar over {L, R, C},
⌈A1 . . . Ar⌉= ⟨⌈A1⌉, . . . , ⌈Ar⌉⟩.
Now, deﬁne
Bn =







Ar ◦· · · ◦A1[−1, +1]c
if n = ⌈A1 . . . Ar⌉with
A1, . . . , Ar ∈{L, R, C},
[−1, +1]
otherwise.
and let m ≺B n, if there is a ﬁnite string A1 . . . Ar with m = ⌈A1 . . . Ar⌉and in
case that also n is the code of such a string, then this string is a proper preﬁx of
A1 . . . Ar, i.e.,
m ≺B n ⇐⇒(∀a < lth(m))(m)a ∈{0, 1, 2} ∧[(∀a < lth(n))(n)a ∈{0, 1, 2}
⇒lth(m) > lth(n) ∧(∀a < lth(n))(m)a = (n)a].
It follows that ≺B is a computably enumerable strong inclusion relation with re-
spect to which B a strong basis ist.
Deﬁnition 60. For m ∈ω such that φm is total with range(φm) ⊆{0, 1, 2}, set
˜xm =
∞

a=0
[[φm(a)]] · 2−(a+1),
where [[0]] = 0, [[1]] = 1 and [[2]] = −1. In all other cases let ˜x be undeﬁned. Num-
bering ˜x is called signed-digit numbering.
Lemma 61. For all m ∈dom(˜x) and a ∈ω,
˜xm ∈B⟨φm(0),...,φm(a)⟩.

378
|
Dieter Spreen
Let ˆx be the numbering constructed in the preceding section. We will show that
˜x ≡s
m ˆx with total reduction functions. As a consequence we even obtain that
˜x ≡a,s
m
ˆx, which implies that ˜x is perfect. Moreover, it has a total strong eﬀective
limit passing function. Hence, it is also correctly precomplete. So, ˜x is computably
isomorphic to ˆx. Moreover, it is computably isomorphic to the corestriction of the
normed Cauchy numbering to the subspace [−1, +1]c.
For the proof that ˜x ≤s
m ˆx let f ∈R(1) with
φf(m)(a) = ⟨φm(0), . . . , φm(a)⟩.
As is readily veriﬁed, if m ∈dom(˜x) then f(m) is an index of a normed computable
enumeration of basic open sets converging to ˜xm, i.e., m ∈f −1(dom(ˆx)). Now,
assume that f(m) ∈dom(ˆx). It follows that f(m) is an index of a normed enu-
meration of basic open sets converging to some y ∈[−1, +1]c. Hence, φf(m) is a
total function with φf(m)(a + 1) ≺B φf(m)(a). By the deﬁnition of f, φm is a total
function too. Moreover, range(φm) ⊆{0, 1, 2}. Because of Lemma 61 we therefore
have that y = ˜xm. Thus, m ∈dom(˜x).
Next, for the proof of ˆx ≤s
m ˜x, deﬁne g ∈R(1) by
φg(m)(a) =

(φm(a + 1))a.
if φm(a + 1) ≺B φm(a),
undeﬁned
otherwise.
Then, if m ∈dom(ˆx), φm is a total function with φm(a + 1) ≺B φm(a), which
implies that lth(φm(a + 1)) is strictly increasing as a tends to inﬁnity. Moreover,
(φm(a + 1))a ∈{0, 1, 2}, for all a < lth(φm(a + 1)). It follows that φg(m) is to-
tal as well with range(φg(m)) ⊆{0, 1, 2}. By deﬁnition of ≺B we have for b ∈ω
and c < lth(φm(b + 1)) that (φm(b + 1))c = (φm(b + 2))c. Thus, φm(a + 1) =
⟨φg(m)(0), . . . , φg(m)(lth(φm(a+1))−1)⟩. As a consequence of Lemma 61 we there-
fore obtain that ˜xg(m) = ˆxm. Hence, m ∈g−1(dom(˜x)).
Conversely, if g(m) ∈dom(˜x), then φg(m) is a total function. Hence, φm is
totally deﬁned and for all a ∈ω, φm(a + 1) ≺B φm(a). As above it follows that
˜xg(m) ∈B(φm(a + 1)), for all a ∈ω, which implies that m is an index of a normed
enumeration of basic open sets converging to ˜xg(m), i.e., m ∈dom(ˆx).
8 Conclusion
In this paper the question was studied when two m-equivalent partial numberings
are computably isomorphic. It turned out that in the partial case the reducibility
notion had to be strengthened in such a way that reduction functions are more reli-
able when operating on non-names. Under this strengthening the classical result

An Isomorphism Theorem for Partial Numberings
|
379
that two equivalent total numberings are computably isomorphic if at least one of
them is precomplete [11; 7; 8], could be extended to the partial case. However, now
both numberings are required to be precomplete, as precompleteness is no longer
inheritable under equivalence. Moreover, the extension of the precompleteness
notion had to be carefully chosen.
The new concept of uniform productivity was introduced and it was shown
that two strongly equivalent numberings are computably isomorphic as well, if
they are both uniformly productive.
In the second part of the paper eﬀective topological T0 spaces and their num-
berings were considered. Acceptable numberings have to make certain topologi-
cal properties computable: for every point a base of its neighbourhood ﬁlter must
uniformly be enumerable and, conversely, the operation to pass from a base of
a converging ﬁlter to its limit needs be computable. By strengthening these con-
ditions the notions of strongly acceptable and strongly correct numberings were
obtained. For spaces without ﬁnite points it was shown that a strongly acceptable
numbering is correctly precomplete exactly if the eﬀective limit passing witness is
a totally deﬁned function, and that strongly acceptable numberings with this ad-
ditional property are strongly correct. In case of spaces that are also computably
separable and have the eﬀective Urysohn property, strongly correct numberings
turned out to be uniformly productive.
As a consequence of the general results derived in the ﬁrst part, two strongly
correct numberings of a space without ﬁnite point, but with computably enumer-
able strong inclusion are computably isomorphic, if they either have total eﬀective
limit passing functions, or the space under consideration is also computably sep-
arable and has the eﬀective Urysohn property.
It was shown that eﬀective spaces always have a strongly correct numbering
which in case that the space has no ﬁnite points is even correctly precomplete. As
turned out, the assumptions that had to be made in this paper are satisﬁed by
important spaces and numberings considered in the literature. The numberings
are therefore not only equivalent, as was known, but computably isomorphic.
In the literature the stability, or eﬀective categoricity, of metric algebras has
been studied, i.e. the question whether any two standard numberings of the car-
rier of such a structure are equivalent (cf. e.g. [12; 9; 2; 5]). Here, a numbering is
a standard numbering, if it renders the operations and relations of the structure
computable.
A prominent example is the structure
(Rc, 0, 1, +, −, ∗, 1/·, NormLim, <)

380
|
Dieter Spreen
of the computable real numbers, where the normed limit operator
NormLim: Rω
c ⇀Rc
is only partially deﬁned: it maps computable normed Cauchy sequences of com-
putable reals to their limits. Moschovakis [12] showed that the structure is eﬀec-
tively categorical. In [5] a generalization of this result to metrical algebras has been
presented. The question has also been studied with respect to other computability
approaches [9; 2].
It follows very easily, both in the case of the computable real number struc-
ture as well as in the more general metric algebra case, that standard numberings
of these topological structures are acceptable. In all special cases considered in
the paper they were even perfect and correctly precomplete. Under a very natural
strengthening of the requirements, in particular those for the function tracking
the normed limit operator, the numberings turn out to be strongly correct. Hence
any two of them are computably isomorphic, improving known results.
Acknowledgement: The main results of this paper answer a question posed by
V. Selivanov in a discussion on previous results of the author, when he was vis-
iting the A.P. Eršov Institute of Informatics Systems of the Russian Academy of
Sciences in Novosibirsk in summer 2011. The author is grateful to V. Selivanov for
inspiring discussions as well as the A.P. Eršov Institute for its hospitality. Thanks
are also due to the unknown referees for their careful reading of a ﬁrst version
of the manuscript. By giving hints to literature and putting new questions they
helped improving and extending the paper.
Bibliography
[1]
S. Badaev and D. Spreen, A note on partial numberings, Mathematical Logic Quarterly 51
(2) (2005) 129–136.
[2]
A. Bauer and J. Blanck, Canonical eﬀective subalgebras of classical algebras as construc-
tive metric completions, Journal of Universal Computer Science 16 (18) (2010) 2496–2522.
[3]
J. Blanck, Domain representability of metric spaces, Annals of Pure and Applied Logic 83
(3) (1997) 225–247.
[4]
J. Blanck, Domain representations of topological spaces, Theoretical Computer Science
247 (1-2) (2000) 229–255.
[5]
J. Blanck, V. Stoltenberg-Hansen, and J.V. Tucker, Stability of representations of eﬀective
partial algebras, Mathematical Logic Quarterly 57 (2) (2011) 217–231.
[6]
G.S. Ce˘ıtin, Algorithmic operators in constructive metric spaces, Trudy Matematiki In-
stituta Steklov 67 (1962) 295–361; English translation: American Mathematical Society
Translations, series 2, 64 (1967) 1–80.

An Isomorphism Theorem for Partial Numberings
|
381
[7]
Yu.L. Eršov, Theorie der Numerierungen I, Zeitschrift für mathematische Logik und Grund-
lagen der Mathematik 19 (19-25) (1973) 289–388.
[8]
Yu.L. Eršov, Theory of numberings, in: E.R. Griﬀor, ed., Handbook of Computability Theory,
Elsevier Science B.V., Amsterdam, 1999, pp. 473–503.
[9]
P. Hertling, A real number structure that is eﬀectively categorical, Mathematical Logic
Quarterly 45 (2) (1999) 147–182.
[10] A. Kanda and A.H. Lachlan, Alternative characterizations of precomplete numberings,
Zeitschrift für mathematische Logik und Grundlagen der Mathematik 33 (2) (1987) 97–
100.
[11]
A.I. Mal’cev, Constructive algebras I, in: H.G. Wells, III, ed., The Metamathematics of Alge-
braic Systems. Collected papers: 1936–1967, North-Holland, Amsterdam, 1971, pp. 148–
214.
[12] Y.N. Moschovakis, Notation systems and recursive ordered ﬁelds, Compositio Mathemat-
ica 17 (1965) 40–71.
[13] Y.N. Moschovakis, Recursive metric spaces, Fundamenta Mathematicae 55 (3) (1964)
215–238.
[14] J. Myhill, Creative sets, Zeitschrift für mathematische Logik und Grundlagen der Mathe-
matik 1 (2) (1955) 97–108.
[15]
M.B. Pour-El and J.I. Richards, Computability in Analysis and Physics, Springer-Verlag,
Berlin, 1989.
[16] H. Rogers, Jr., Gödel numberings of partial recursive functions, The Journal of Symbolic
Logic 23 (3) (1958) 331–341.
[17]
H. Rogers, Jr., Theory of Recursive Functions and Eﬀective Computability, McGraw-Hill,
New York, 1967.
[18] I. Sigstam, Formal spaces and their eﬀective presentations, Archive for Mathematical
Logic 34 (4) (1995) 211–246.
[19] D. Spreen, On some decision problems in programming, Information and Computation
122 (1995) 120–139; Corrigendum 148 (1999) 241–244.
[20] D. Spreen, Eﬀective inseparability in a topological setting, Annals of Pure and Applied
Logic 80 (1996) 257–275.
[21] D. Spreen, On eﬀective topological spaces, The Journal of Symbolic Logic 63 (1) (1998)
185–221; Corrigendum 65 (4) (2000) 1917–1918.
[22] D. Spreen, Can partial indexings be totalized? The Journal of Symbolic Logic 66 (3) (2001)
1157–1185.
[23] D. Spreen, Strong reducibilities for partial numberings, Archive for Mathematical Logic 44
(2005) 209–217.
[24] D. Spreen, Eﬀectivity and eﬀective continuity of multifunctions, The Journal of Symbolic
Logic 75 (2) (2010) 602–640.
[25] D. Spreen, Partial numberings and precompleteness, This Volume, pp. 325–340.
[26] V. Stoltenberg-Hansen and J.V. Tucker, Eﬀective algebras, in: S. Abramsky et al., eds.,
Handbook of Logic in Computer Science, vol. 4, Clarendon Press, Oxford, 1995, 357–526.
[27] C.F. Sturm, Mémoire sur la résolution des équations numeriques, Annales de mathémati-
ques pures et appliquées 6 (1835) 271–318.
[28] K. Weihrauch, Computability, Springer-Verlag, Berlin, 1987.
[29] K. Weihrauch, Computable Analysis, Springer-Verlag, Berlin, 1998.


Ludwig Staiger
Two theorems on the Hausdorﬀmeasure of
regular ω-languages¹
Abstract: This paper presents the proof of two theorems dealing with the calcula-
tion of the Hausdorﬀmeasure of regular ω-languages, that is, subsets of the Cantor
space deﬁnable by ﬁnite automata.
Keywords: Hausdorﬀdimension, Hausdorﬀmeasure, Cantor space
Mathematics Subject Classiﬁcation 2010: 68Q45, 49Q15, 37F35, 11K55
||
Ludwig Staiger: Institut für Informatik, Martin-Luther-Universität, Halle-Wittenberg, Germany
Regular ω-languages are not only famous because they are deﬁnable by ﬁnite
automata but also because they are the ones deﬁnable in Büchi’s [3] restricted
monadic second order arithmetic (cf. the survey [18] or [11]).
Hausdorﬀdimension and Hausdorﬀmeasure for regular ω-languages have
been proved to be computable (cf. [2; 8; 4] or [10; 14]). The computation of the
Hausdorﬀmeasure of a regular ω-language uses several properties which do not
hold for larger classes of ω-languages (cf. [12; 10; 14]). These properties show that
subsets of the Cantor space deﬁnable by ﬁnite automata really deserve the name
“regular”.
Our theorems relate the Hausdorﬀmeasure of a subset of the Cantor space to
the Hausdorﬀmeasure of its closure. The ﬁrst theorem shows that under a certain
restriction the measure of a regular ω-language whose Hausdorﬀmeasure diﬀers
from the measure of its closure is already inﬁnite. Its proof uses the decomposition
theorem of [14] which is based on McNaughton’s theorem [9] and extends in some
sense earlier decompositions of [1; 19; 17].
The second theorem gives a suﬃcient condition under which Gδ-sets, that is,
countable intersections of open sets, of the Cantor space have the same Hausdorﬀ
measure as their closure. Here we rely on a measure-category theorem for subsets
of the Cantor space deﬁnable by ﬁnite automata derived in [15].
1 The results of this paper were presented at the Dagstuhl-Seminar “Topological and Game-
Theoretic Aspects of Inﬁnite Computations”, Schloß Dagstuhl, 29.06. - 04.07.2008 [7]

384
|
Ludwig Staiger
1 Notation
In this section we introduce the notation used throughout the paper. By N =
{0, 1, 2, . . .} we denote the set of natural numbers. Its elements will be usually
denoted by letters i, . . . , n. Let X be an alphabet of cardinality |X| = r ≥2. Then
X∗is the set of ﬁnite words on X, including the empty word e, and Xω is the set
of inﬁnite strings (ω-words) over X. Subsets of X∗will be referred to as languages
and subsets of Xω as ω-languages.
For w ∈X∗and η ∈X∗∪Xω let w·η be their concatenation. This concatenation
product extends in an obvious way to subsets W ⊆X∗and B ⊆X∗∪Xω. For a lan-
guage W let W∗:= 
i∈N Wi, and Wω := {w1 · · · wi · · · : wi ∈W \ {e}} be the set
of inﬁnite strings formed by concatenating non-empty words in W. Furthermore,
|w| is the length of the word w ∈X∗and pref(B) is the set of all ﬁnite preﬁxes
of strings in B ⊆X∗∪Xω. We shall abbreviate w ∈pref({η}) (η ∈X∗∪Xω) by
w ⊑η.
As usual, we consider Xω as a topological space (Cantor space). The closure
(smallest closed set containing F) of a subset F ⊆Xω, C(F), is described as C(F) :=
{ξ : pref({ξ}) ⊆pref(F)}. The open sets in Cantor space are the ω-languages of
the form W · Xω.
We assume the reader to be familiar with the basic facts of the theory of regu-
lar languages and ﬁnite automata. We postpone the deﬁnition of regularity for ω-
languages to Section 3. For more details on ω-languages and regular ω-languages
see the book [11] or the survey papers [13; 18].
2 HausdorﬀDimension and HausdorﬀMeasure
First, we shall describe brieﬂy the basic formulae needed for the deﬁnition of
Hausdorﬀdimension and Hausdorﬀmeasure. For more background and motiva-
tion see Section 1 of [10].
Next we recall the deﬁnition of the Hausdorﬀmeasure and Hausdorﬀdimen-
sion (see [4; 6]) of a subset of Xω. In the setting of languages and ω-languages this
can be read as follows (see [12; 14]). For F ⊆Xω, r = |X| ≥2 and 0 ≤α ≤1 the
equation
Lα(F) := lim
l→∞inf
 
w∈W
r−α·|w| : F ⊆W · Xω ∧∀w(w ∈W →|w| ≥l)

(1)
deﬁnes the α-dimensional metric outer measure on Xω. The measure Lα satisﬁes
the following properties (see [4; 6; 10]).

Two Theorems on Hausdorﬀmeasure
|
385
Proposition 1. Let F ⊆Xω, V ⊆X∗and α ∈[0, 1].
1. If Lα(F) < ∞then Lα+ε(F) = 0 for all ε > 0.
2. If F ⊆ξ : ξ ∈Xω ∧pref(ξ) ⊆V and 
v∈V r−α·|v| < ∞then Lα(F) = 0.
3. It holds the scaling property Lα(w · F) = r−α·|w| · Lα(F).
4. If V is preﬁx-free then Lα(F ∩V · Xω) = 
w∈V Lα(F ∩w · Xω).
Then the Hausdorﬀdimension of F is deﬁned as
dim F := sup{α : α = 0 ∨Lα(F) = ∞} = inf{α : Lα(F) = 0} .
It should be mentioned that dim is countably stable and invariant under scaling,
that is, for Fi ⊆Xω we have
dim 
i∈N Fi = sup{dim Fi : i ∈N}
and
dim w · F0 = dim F0 .
(2)
In particular, every at most countable subset E ⊆Xω has Hausdorﬀdimension
dim E = 0, and the measure L0 is the counting measure, that is, L0(E) = |E| if E
is ﬁnite and L0(E) = ∞, otherwise.
We say that an ω-language F has locally positive α-dimensional measure pro-
vided ∀ww ∈pref(F) →Lα(F ∩w · Xω) > 0. Then the following technical result
is true.
Proposition 2. Let F ⊆Xω have dim F = α, Lα(F) < ∞and locally positive α-
dimensional measure. If F′ ⊆F and Lα(F′) = Lα(F) then pref(F′) = pref(F) and,
consequently, C(F′) = C(F).
Proof. First observe that F′ ⊆F implies Lα(F′∩w·Xω) ≤Lα(F∩w·Xω) for all w ∈
X∗. Then the general identity (see Proposition 1.4) Lα(E) = 
w∈Xn Lα(E ∩w · Xω)
and the hypothesis Lα(F′) = Lα(F) < ∞imply Lα(F′ ∩w · Xω) = Lα(F ∩w · Xω).
Obviously, pref(F′) ⊆pref(F). Let now w ∈pref(F). Then Lα(F ∩w · Xω) > 0
which in view of Lα(F′ ∩w · Xω) = Lα(F ∩w · Xω) implies w ∈pref(F′).
We list some relations of the Hausdorﬀdimension and the measure Lα for ω-
languages (see [12; 10]).
Proposition 3. Let α = dim Wω. Then Lα(Wω) ≤1, and if, moreover, Lα(Wω) > 0
then Wω has locally positive α-dimensional measure.
Proof. The ﬁrst part is Proposition 6.6 of [12]. Let w ∈pref(Wω). Then there is a
v ∈X∗such that wv ∈W∗, and, consequently wv · Wω ⊆Wω ∩w · Xω. Now
Proposition 1.3 yields 0 < Lα(wv · Wω) ≤Lα(Wω ∩w · Xω).

386
|
Ludwig Staiger
3 Decomposition of Regular ω-languages
As usual we call a language W ⊆X∗regular if there is a ﬁnite (deterministic)
automaton A = (X; S; s0; δ), where S is the ﬁnite set of states, s0 ∈S is the initial
state and δ : S × X →S is the transition function², such that W = {w : δ(s0; w) ∈
S′} for some ﬁxed set S′ ⊆S.
An ω-language F ⊆Xω is called regular provided there are a ﬁnite (determin-
istic) automaton A = (X; S; s0; δ) and a table T ⊆{S′ : S′ ⊆S} such that for
ξ ∈Xω it holds ξ ∈F if and only if Inf(A; ξ) ∈T where Inf(A; ξ) is the set of all
states s ∈S through which the automaton A runs inﬁnitely often when reading
the input ξ. Observe that S′ = Inf(A; ξ) holds for a subset S′ ⊆S if and only if
1. there is a word u ∈X∗such that δ(s0; u) ∈S′, and
2. for all s, s′ ∈S′ there are non-empty words w, v ∈X∗such that δ(s; w) = s′
and δ(s′; v) = s.
Thus, to ease our notation, unless stated otherwise in the sequel we will assume
all automata to be initially connected, that is, S = {δ(s0; w) : w ∈X∗} and the
tables T to be contained in {Inf(A; ξ) : ξ ∈Xω}.
The ω-language F = {ξ : Inf(A; ξ) ∈T} is the disjoint union of all sets FS′ =
{ξ : Inf(A; ξ) = S′} where S′ ∈T.
We are going to split F into smaller mutually disjoint parts. Let A = (X; S; s0; δ)
be ﬁxed. We refer to a word v ∈X∗as (s; S′)-loop completing if and only if
1. v is not the empty word,
2. δ(s; v) = s and {δ(s; v′) : v′ ⊑v} = S′, and
3. {δ(s; v′) : v′ ⊑v′′} ⊂S′ for all proper preﬁxes v′′ ⊏v with δ(s; v′′) = s.
and we call a word w ∈X∗(s; S′)-loop entering provided
1. δ(s0; v) = s and
2. if w = w′ · x for some x ∈X then δ(s0; w′) /∈S′.
Denote by V(s;S′) the set of all (s; S′)-loop completing words and by W(s;S′)
the set of all (s; S′)-loop entering words. Both languages are regular and con-
structable from the ﬁnite automaton A = (X; S; s0; δ). Moreover, V(s;S′) is preﬁx-
2 We use the same symbol δ to denote the usual extension of the function δ to S × X∗.

Two Theorems on Hausdorﬀmeasure
|
387
free, whereas W(s;S′) need not be so. Nevertheless, every ξ ∈FS′ has a unique
representation ξ = w · v1 · · · vi · · · where w ∈W(s;S′) and vi ∈V(s;S′). Here the
state s ∈S′ is uniquely determined as the state succeeding the last state ˆs /∈S′ in
the sequence (δ(s0; u))u⊏ξ. Thus we obtain the following (see [15]).
Lemma 4 (Decomposition Lemma). Let A = (X; S; s0; δ) be a ﬁnite automaton,
T ⊆{Inf(A; ξ) : ξ ∈Xω} be a table and let F = {ξ : Inf(A; ξ) ∈T}. Then
F =

S′∈T

s∈S′

w∈W(s;S′)
w · Vω
(s;S′) ,
(3)
and the sets w · Vω
(s;S′) are pairwise disjoint.
As an immediate consequence of the Decomposition Lemma we obtain that every
regular ω-language has the form n
i=1 Wi ·Vω
i where Wi, Vi are regular languages.
The converse is also true, that is, if W ⊆X∗and F, E ⊆Xω are regular then also
Wω, W · E and E ∪F are regular ω-languages. Note, however, that the representa-
tion of Eq. (3) is much ﬁner, since it splits a regular ω-language F = n
i=1 Wi · Vω
i
into mutually disjoint parts w · Vω
i , w ∈Wi, i ∈{1, . . . , n}, where, additionally,
the languages Vi are preﬁx-free.
Next we are going to construct, depending on the automaton A = (X; S; s0; δ),
a subset F′ of the set F in Eq. (3) on which the Hausdorﬀmeasure Lα is con-
centrated. To this end we need some properties of the measure Lα for regular ω-
languages.
Since regular ω-languages are Borel sets in Cantor space (cf. [13; 18]), Lα is not
only an outer measure but a measure on the class of regular ω-languages. Thus
we have the following (cf. [5]).
Proposition 5. If (Fi)i∈N is a family of mutually disjoint regular ω-languages then
Lα

i∈N Fi

= 
i∈N Lα(Fi).
Moreover, the following are shown in [12] and [10].
Proposition 6 ([12, Theorem 4.7]). If F ⊆Xω is a non-empty regular ω-language
and α = dim F then Lα(F) > 0.
Proposition 7 ([12, Theorem 4.6],[10, Theorem 6]). Let V ⊆X∗be regular and
preﬁx-free. Then Lα(Vω) = Lα(C(Vω)).
From Eq. (3), Proposition 5 and Proposition 1.3 we obtain a formula for the Haus-
dorﬀmeasure Lα(F) of F:
Lα(F) =

S′∈T

s∈S′(

w∈W(s;S′)
r−α·|w|) · Lα(Vω
(s;S′)) .
(4)

388
|
Ludwig Staiger
The following lemma shows that several of the sets w · Vω
(s;S′) do not contribute to
the measure Lα(F) of F.
Proposition 8. Let A = (X; S; s0; δ) be a ﬁnite automaton and V(s;S′) ̸= ∅. Then
S′′ ⊂S′ implies Vω
(s;S′′) ⊆C(Vω
(s;S′)).
Moreover, we have Lα(Vω
(s;S′′)) = 0 for α = dim Vω
(s;S′) .
Proof. To prove the ﬁrst assertion it suﬃces to show pref(Vω
(s;S′′)) ⊆pref(Vω
(s;S′)).
Let As := (X; S; s; δ). Then ζ ∈Vω
(s;S′) if and only if Inf(As; ζ) = S′ and
{δ(s; u) : u ⊏ξ} ⊆S′. Consequently, for v ∈V∗
(s;S′′) and ξ ∈Vω
(s;S′) we have
Inf(As; v · ξ) = S′ whence V∗
(s;S′′) · Vω
(s;S′) = Vω
(s;S′) and thus pref(Vω
(s;S′′)) ⊆
pref(Vω
(s;S′)).
As Vω
(s;S′′) and Vω
(s;S′) are disjoint subsets of C(Vω
(s;S′)) the second assertion
follows from the ﬁrst one and Proposition 7.
Proposition 8 shows that for an ω-language F accepted by an automaton A =
(X; S; s0; δ) and a table T ⊆{Inf(A; ξ) : ξ ∈Xω} the measure Lα(F) for α =
dim F is concentrated only on subsets w · Vω
(s,S′) for which S′ is maximal w.r.t. set
inclusion in T.
If α = dim F and we choose among the maximal sets S′ ∈T those for which
Lα(w · Vω
(s;S′)) > 0 we eliminate all sets w · Vω
(s;S′) with Lα(w · Vω
(s;S′)) = 0 in Eq. (3)
and obtain the following.
Theorem 9. Let A = (X; S; s0; δ) be a ﬁnite automaton, T ⊆{Inf(A; ξ) : ξ ∈Xω}
be a table, F = {ξ : Inf(A; ξ) ∈T} and α = dim F.
If S := {S′ : S′ ∈T ∧∃s(s ∈S′ ∧Lα(Vω
(s,S′)) > 0)} the ω-language F′ = {ξ :
Inf(A; ξ) ∈S} satisﬁes F′ ⊆F and Lα(F) = Lα(F′).
Moreover, the ω-language F′ has a decomposition
F′ =

S′∈S

s∈S′

w∈W(s;S′)
w · Vω
(s;S′) ,
(5)
where Lα(w · Vω
(s;S′)) > 0 for all sets w · Vω
(s;S′) .
4 Results
4.1 Sets of locally positive measure
Theorem 10. If F ⊆Xω is a regular ω-language, α := dim F, F has locally positive
α-dimensional measure then Lα(C(F)) = Lα(F).

Two Theorems on Hausdorﬀmeasure
|
389
Proof. It suﬃces to show that Lα(C(F)) > Lα(F) implies Lα(F) = ∞.
From Theorem 9 we know that F contains a regular ω-language F′ = n
i=1 Wi·
Vω
i with Lα(F) = Lα(F′) where the sets Wi, Vi are regular, the Vi are preﬁx-free
with Lα(Vi) > 0, and the sets w·Vω
i , w ∈Wi, i ∈{1, . . . , n}, are mutually disjoint.
Assume ∞≥Lα(C(F)) > Lα(F). Since F has locally positive α-dimensional
measure, by Proposition 2 pref(F′) = pref(F) whence C(F′) = C(F).
If pref(ξ) ⊆pref(Wi·Vω
i ) then there is a w ∈Wi such that pref(ξ)\pref(w) ⊆
w · pref(Vω
i ) or pref(ξ) ⊆pref(Wi). This shows
C(F′) =
n
i=1
Wi · C(Vω
i ) ∪
n
i=1
{ξ : pref(ξ) ⊆pref(Wi)} .
Since Lα(w · C(Vω
i )) = Lα(w · Vω
i ) the assumption Lα(C(F)) > Lα(F) implies that
Lα({ξ : pref(ξ) ⊆pref(Wi)}) > 0 for some i ∈{1, . . . , n} which in view of
Proposition 1.2 yields 
w∈pref(Wi) r−α·|w| = ∞.
Since Wi is regular, there is a k ∈N such that for every v ∈pref(Wi) there
is a w ∈Wi with v ⊑w and |w| −|v| ≤k. Thus 
v∈pref(Wi) r−α·|v| = ∞implies

w∈Wi r−α·|w| = ∞and we obtain Lα(F) ≥Lα(Wi · Vω
i ) = (
w∈Wi r−α·|w|) ·
Lα(Vω
i ) = ∞.
As an immediate consequence we obtain the following.
Corollary 11. If F ⊆Xω is a regular ω-language, α := dim F, F has locally positive
α-dimensional measure and Lα(C(F) \ F) > 0 then Lα(F) = ∞.
In case Lα(F) = ∞the measure of the diﬀerence Lα(C(F) \ F) may be ﬁnite or
inﬁnite.
Example 12. Let X = {0, 1} and F1 := 0∗· 1ω and F2 := 0∗· 1∗· 0ω. Both sets
are countable, thus dim F1 = dim F2 = 0. We have C(F1) = 0ω ∪0∗· 1ω and
C(F2) = 0∗· 1ω ∪0∗· 1∗· 0ω, and, consequently, L0(C(F1) \ F1) = L0(0ω) = 1 and
L0(C(F2) \ F2) = L0(0∗· 1ω) = ∞.
□
In Theorem 10 the hypothesis that F has locally positive α-dimensional measure
is essential. We give an example.
Example 13. Let X = {0, 1} and F := F1 ∪F2 where F1 = (0 · {0, 1})ω is a closed
set and F2 = (1 · {0, 1})∗· (10)ω.
Then Lα(F ∩1 · {0, 1}ω) = 0 for α > 0, since F2 is countable. Moreover, C(F) =
(0·{0, 1})ω∪(1·{0, 1})ω and one easily calculates dim F = dim C(F) = 1
2, L1/2(F) =
1
√
2 > 0 and L1/2(C(F)) = 2 · L1/2(F) =
√
2.
□

390
|
Ludwig Staiger
From Proposition 3 and Theorem 10 we obtain the following relationship for the
Hausdorﬀmeasure of regular ω-power languages.
Corollary 14. Let W ⊆X∗. If Wω is a regular ω-language and α = dim Wω then
Lα(C(Wω)) = Lα(Wω) .
Corollary 14 and, consequently, Theorem 10 are not valid for non-regular ω-
languages. In [16, Section 3.3] examples of preﬁx-free non-regular languages W
fulﬁlling various relationships between Lα(Wω) and Lα(C(Wω)) are given.
4.2 Measure of Gδ-sets
Before we proceed to the presentation of the second theorem we have to introduce
some necessary prerequisites concerning the topology of the Cantor space.
As usual, a countable intersection of open sets is referred to as a Gδ-set. More-
over, we call a set F nowhere dense in E provided C(E \ C(F)) = C(E), that is, if
C(F) does not contain a nonempty subset of the form E ∩w · Xω, and a subset F is
referred to as of ﬁrst Baire category in E if F is a countable union of sets nowhere
dense in E.
Lemma 15 ([15, Theorem 8]). Let E ⊆Xω be a regular ω-language which is closed
in Cantor space, α = dim E and let E have ﬁnite and locally positive α-dimensional
measure.
Then every regular ω-language F ⊆E is of ﬁrst Baire category in E if and only
if Lα(F) = 0
This much preparatory apparatus leads to the following result.
Theorem 16. Let E ⊆Xω be a Gδ-set which is a countable intersection of regular
ω-languages and let C(E) be regular. If α = dim C(E), Lα(C(E)) < ∞, and C(E) has
locally positive α-dimensional measure then Lα(C(E)) = Lα(E).
Proof. Observe that C(E) is a regular ω-language. Since E is a Gδ-set, C(E) \ E
is of ﬁrst Baire category, and, since E is a countable intersection of regular ω-
languages, say E = 
i∈N Fi, the diﬀerence C(E) \ E = 
i∈N(C(E) \ Fi) is a count-
able union of regular ω-languages C(E)\Fi, each of which is of ﬁrst Baire category.
Then according to Lemma 15 Lα(C(E) \ Fi) = 0, and the assertion follows.
Theorem 16 can be applied also to non-regular ω-languages. We give a simple ex-
ample.

Two Theorems on Hausdorﬀmeasure
|
391
Example 17. Let E := Xω \ {w · vω : w, v ∈X∗∧v ̸= e} be the set of all ω-words
which are not ultimately periodic. Then E is the intersection of the following regular
ω-languages open in Cantor space Xω \ {w · vω}, w, v ∈X∗∧v ̸= e, thus a Gδ-set.
We have C(E) = Xω whence dim C(E) = 1 and obtain L1(C(E)) = L1(E) = 1.
□
The condition that E be a Gδ-set is really essential as the following example shows.
Example 18. Let X = {0, 1} and E = {0, 1}∗· 0ω = 
n∈N{0, 1}∗· {0n1, 0}ω which
is an intersection of regular ω-languages {0, 1}∗·{0n1, 0}ω. Moreover, E is an Fσ-set
but no Gδ-set.
Then C(E) = {0, 1}ω and α = dim C(E) = 1, L1(C(E) ∩w · {0, 1}ω) = 1 < ∞
for all w ∈{0, 1}∗but, as E is countable, dim E = 0 and hence L1(E) = 0.
□
Acknowledgement: The author would like to thank the anonymous referees for
helpful comments.
Bibliography
[1]
André Arnold. Rational ω-languages are nonambiguous. Theoret. Comput. Sci., 26(1-2):221–
223, 1983.
[2]
Christoph Bandt. Self-similar sets. III. Constructions with soﬁc systems. Monatsh. Math.,
108(2-3):89–102, 1989.
[3]
J. Richard Büchi. On a decision method in restricted second order arithmetic. In Logic,
Methodology and Philosophy of Science (Proc. 1960 Internat. Congr .), pages 1–11. Stan-
ford Univ. Press, Stanford, Calif., 1962.
[4]
Gerald Edgar. Measure, topology, and fractal geometry. Undergraduate Texts in Mathemat-
ics. Springer, New York, second edition, 2008.
[5]
Kenneth Falconer. The geometry of fractal sets, volume 85 of Cambridge Tracts in Mathe-
matics. Cambridge University Press, Cambridge, 1986.
[6]
Kenneth Falconer. Fractal geometry. John Wiley & Sons Ltd., Chichester, 1990.
[7]
Peter Hertling, Victor Selivanov, Wolfgang Thomas, William W. Wadge, and Klaus Wagner.
Topological and game-theoretic aspects of inﬁnite computations (executive summary). In
Peter Hertling, Victor Selivanov, Wolfgang Thomas, William W. Wadge, and Klaus Wagner,
editors, Topological and Game-Theoretic Aspects of Inﬁnite Computations, Dagstuhl
Seminar Proceedings 08271, Dagstuhl, Germany, 2008.
[8]
R. Daniel Mauldin and Stanley C. Williams. Hausdorﬀdimension in graph directed construc-
tions. Trans. Amer. Math. Soc., 309(2):811–829, 1988.
[9]
Robert McNaughton. Testing and generating inﬁnite sequences by a ﬁnite automaton.
Information and Control, 9:521–530, 1966.
[10] Wolfgang Merzenich and Ludwig Staiger. Fractals, dimension, and formal languages. RAIRO
Inform. Théor. Appl., 28(3-4):361–386, 1994.

392
|
Ludwig Staiger
[11] Dominique Perrin and Jean-Éric Pin. Inﬁnite Words, volume 141 of Pure and Applied
Mathematics. Elsevier, Amsterdam, 2004. ISBN 0-12-532111-2.
[12] Ludwig Staiger. Kolmogorov complexity and Hausdorﬀdimension. Inform. and Comput.,
103(2):159–194, 1993.
[13] Ludwig Staiger. ω-languages. In Grzegorz Rozenberg and Arto Salomaa, editors, Handbook
of Formal Languages, volume 3, pages 339–387. Springer-Verlag, Berlin, 1997. Beyond
words.
[14] Ludwig Staiger. The Hausdorﬀmeasure of regular ω-languages is computable. Bull. Eur.
Assoc. Theor. Comput. Sci. EATCS, (66):178–182, 1998.
[15] Ludwig Staiger. Rich ω-words and monadic second-order arithmetic. In Mogens Nielsen
and Wolfgang Thomas, editors, Computer science logic (Aarhus, 1997), volume 1414 of
Lecture Notes in Computer Science, pages 478–490. Springer-Verlag, Berlin, 1998.
[16] Ludwig Staiger. Inﬁnite iterated function systems in Cantor space and the Hausdorﬀ
measure of ω-power languages. Internat. J. Found. Comput. Sci., 16(4):787–802, 2005.
[17] Ludwig Staiger und Klaus Wagner. Automatentheoretische und automatenfreie Charakter-
isierungen topologischer Klassen regulärer Folgenmengen. Elektron. Informationsverarbeit.
Kybernetik, 10:379–392, 1974.
[18] Wolfgang Thomas. Automata on inﬁnite objects. In Jan van Leeuwen, editor, Handbook
of Theoretical Computer Science, volume B, pages 133–192. North Holland, Amsterdam,
1990.
[19] Klaus Wagner. On ω-regular sets. Inform. and Control, 43(2):123–177, 1979.

Anton V. Zhukov
Some Notes on the Universality of
Three-Orders on Finite Labeled Posets¹
Abstract: We prove that the 1- and 2-order of (the corresponding equivalence
classes of) ﬁnite k-labeled posets (for k ≥2) are universal in the sense that any
countable poset can be embedded into them, i.e., these two orders have a “maxi-
mal complexity” among all countable orders. This observation straightforwardly
extends the corresponding result of E. Lehtonen for the 0-order (also known as the
homomorphic order). We propose a constructive combinatorial procedure that iso-
morphically embeds the quotient structure of the ﬁnite k-labeled posets (forests)
with the 2-order into the corresponding structures with the 0- and 1-order. In par-
ticular, it means that the 2-preorder on ﬁnite k-labeled posets (forests) can be split
(in some natural sense) into 0-preorder and 2-equivalence. As a corollary, we de-
ﬁne the inﬁmum operation in the quotient structures of the ﬁnite k-labeled posets
and forests, and prove that these structures are distributive lattices. Finally, some
notes are given on minimal upper and maximal lower bounds in the 1-order of
k-labeled posets and forests.
Keywords: labeled poset, labeled forest, 0-preorder, 1-preorder, 2-preorder, uni-
versality
Mathematics Subject Classiﬁcation 2010: 05C62, 06A06, 06A07, 06A11
||
Anton V. Zhukov: Novosibirsk State Pedagogical University, Russia
1 Introduction
We use some standard algebraic notation and terminology which can be found,
e.g., in [1]. For any preorder or partial order ≤, x < y means x ≤y ∧y ̸≤x and x|y
(x and y incomparable) means x ̸≤y∧y ̸≤x. For any poset (P, ≤) and any element
x ∈P, the upper ˇx and the lower cone ˆx are deﬁned as follows: ˇx = {y ∈P : x ≤y},
ˆx = {y ∈P : y ≤x}. As usual, a chain is a totally (linearly) ordered set (or subset of
a poset). An antichain is a subset with pairwise incomparable elements. A lattice
is a poset in which every pair of elements has the supremum and the inﬁmum.
1 The work was supported by RFBR grant 13-01-00015a.

394
|
Anton V. Zhukov
One can accept the following general deﬁnition: a forest is a poset in which any
upper cone is a totally ordered set (chain) with the greatest element. In this paper,
we consider only ﬁnite posets and forests.
Throughout this paper, k is meant to be an arbitrary integer, k ≥2, which is
identiﬁed (as an ordinal number) with the set {0, . . . , k −1}.
Deﬁnition 1.
(i) A k-labeled poset (or just a k-poset) is a triple (P; ≤P, cP) con-
sisting of a poset (P; ≤P) and a labeling function (or just labeling) cP : P →k.
(ii) A k-forest is a k-poset (P; ≤P, cP) for which the poset (P, ≤P) is a forest.
We usually simplify the notation of a k-poset (P; ≤P, cP) to P. A k-poset P can be
seen as a node-weighted directed graph, where every x ∈P carries the label cP(x).
The set of all labels of P will be denoted by cP(P). We call a k-poset P repetition-
free iﬀcP(x) ̸= cP(y) whenever x is an immediate predecessor of y in P (i.e. x ≤P
y ∧¬∃z(x <P z <P y)). A k-chain xn < . . . < x1 with labels c(xi) = li is denoted (up
to isomorphism) by l1 · · · n. In particular, a one-element k-poset (called singleton)
with the label l of its element will be denoted just by l. A repetition-free k-chain is
called alternating.
The classes of all ﬁnite k-posets and of all ﬁnite k-forests are denoted by
Pk and Fk, respectively. Instead of k-posets, we can consider their isomorphism
types; in that case Pk and Fk are countable.
Let S be any family (set) of k-posets. The join  S is a disjoint union of (iso-
morphic copies of) elements of S. Note that this operation is deﬁned up to isomor-
phism. More formally, the join  S can be deﬁned as follows:
 S = {(P, x) : P ∈S, x ∈P},
(P, x) ≤⊔S (Q, y) ⇔P = Q ∧x ≤P y,
c⊔S(P, x) = a ⇔cP(x) = a.
Similarly, the join operation can be deﬁned also for indexed families of k-subsets
(with indices instead of k-posets). For any k-posets P and Q, deﬁne the (binary)
join
P ⊔Q =

{P, Q}.
If P, Q are disjoint, i.e. P ∩Q = ∅, then P ⊔Q is isomorphic to the k-poset
(P ∪Q; ≤P∪Q, cP∪Q), where ≤P∪Q=≤P ∪≤Q and cP∪Q = cP ∪cQ (i.e., cP∪Q(x) =
cP(x) for any x ∈P, and cP∪Q(x) = cQ(x) for any x ∈Q).
Deﬁnition 2. Let (P; ≤P, cP), (Q; ≤Q, cQ) be arbitrary k-posets and a function
f : (P, ≤P) →(Q, ≤Q) be monotone, i.e.
∀x, y ∈P(x ≤P y →f(x) ≤Q f(y)).

On the Universality of Three-Orders on Finite Labeled Posets
|
395
(i) f is called a 0-morphism (or just morphism) if f preserves the labeling, i.e.
cP = cQ ◦f.
(ii) f is called a 1-morphism if there exists a mapping g: k →k such that
cP = g ◦cQ ◦f.
(iii) f is called a 2-morphism if f maps any ≤P-comparable elements of P with
unequal labels to elements with unequal labels:
∀x, y ∈P((x ≤P y ∧cP(x) ̸= cP(y)) →cQ(f(x)) ̸= cQ(f(y))).
For i ∈{0, 1, 2}, the fact that f is an i-morphism from P to Q is brieﬂy denoted
by f : P ≤i Q. Note that the item (ii) of the deﬁnition above can be reformulated
as follows: a monotone function f : P →Q is a 1-morphism iﬀany two elements
of P with unequal labels are mapped by f to elements of Q with unequal labels,
i.e. ∀x, y ∈P((cP(x) ̸= cP(y)) →cQ(f(x)) ̸= cQ(f(y))) (e.g., see the paper by
P. Hertling and V. Selivanov in this volume).
Deﬁnition 3. For i ∈{0, 1, 2}, P ≤i Q (P is i-morphic or i-reducible to Q) iﬀthere
exists a morphism f : P ≤i Q.
Two k-posets P and Q are called i-incomparable if P ̸≤i Q and Q ̸≤i P. The rela-
tions (reducibilities) ≤0, ≤1, ≤2 are preorders, and called 0-, 1-, and 2-preorder,
respectively. Evidently, any 0-morphism is a 1-morphism, and, in its turn, any 1-
morphism is a 2-morphism. Hence ≤0 implies ≤1, and ≤1 implies ≤2, but simple
counterexamples show that the inverse implications are false.
The preorders ≤0, ≤1, ≤2 were introduced (on labeled trees) by P. Hertling
within the framework of functional hierarchies [3; 4]. In fact, these relations on
k-posets are particular cases of more general notions of reducibility relations
on functions between topological spaces. The relation ≤2 in a general topologi-
cal setting was ﬁrst considered by K. Weihrauch [4; 11], and, independently, by
M. D. Hirsch [6]. Among these three preorders, the 0-preorder is most well-known.
It was considered and studied in various contexts and applications on various
subclasses of k-posets by the following authors (this list is possibly not com-
plete): P. Hertling, S. Kosub, O. V. Kudinov, L. Kwuida, E. Lehtonen, V. L. Selivanov,
K. Wagner (e.g., see [5; 7] and references therein). In this paper, we are interested
mainly in connections between the relation ≤0 on one hand, and the relations
≤1, ≤2 on the other hand. The general question is, which properties and applica-
tions of ≤0 hold also for ≤1 and ≤2.
There exists a function split: Pk →Fk with the following property [10]:
∀P ∈Pk

split(P) ≤0 P ∧∀F ∈Fk(F ≤0 P →F ≤0 split(P)).

396
|
Anton V. Zhukov
This function was computed in [10] by induction. However, one can extend the
split function on arbitrary posets in which every chain has an upper bound (this
extension is not inductive and requires the Axiom of Choice).
Two k-posets P and Q are i-equivalent, P ≡i Q, iﬀP ≤i Q and Q ≤i P. The
relation ≡i is clearly an equivalence relation called i-equivalence. For any X ∈Pk
or X ∈Fk, let [X]i denote the i-equivalence class of X in Pk or in Fk: [X]i = {Y ∈
Pk | Y ≡i X} or [X]i = {Y ∈Fk | Y ≡i X} (what is meant depends on a context).
The quotient set of Pk (Fk) under ≡i, i ∈{0, 1, 2}, is denoted by Pi
k (respec-
tively, Fi
k). Any element of P2
k (F2
k) is the union of some elements of P1
k (respec-
tively, F1
k). The preorder ≤i induces a partial order on Pi
k which we call i-order
and denote also by ≤i. We will simplify the notation of the poset (Pi
k; ≤i) to just
Pi
k.
The height h(P) of a k-poset P ∈Pk is the maximal length of a chain in P.
In particular, the height of the empty k-poset ∅is 0. The height of an element (i-
equivalence class) x ∈Pi
k is the minimal height of a representative of x: h(x) =
min{h(P) : P ∈x}. For any P ∈Pk with h(P) = n, if P contains an alternating
chain of length n then h([P]i) = n for every i ∈{0, 1, 2}. This remark easily follows
from the fact that an alternating chain cannot be i-reducible to a chain of lesser
length. Hence h([l1 · · · ln]i) = n for any alternating k-chain l1 · · · ln. For any n ∈ω,
let Pi
k(n) denote the subclass of all elements of height n:
Pi
k(n) = {x ∈Pi
k : h(x) = n}.
For any set of labels κ ⊆k, let A(κ) denote the k-poset (κ; ∅, c), where c(x) = x
for any x ∈κ. In other words, A(κ) is a k-antichain with elements which bear
the labels from the set κ (one element per label). Consider the following simplest
examples:
–
Pi
k(0) = {[∅]i} = {{∅}} for i ∈{0, 1, 2};
–
P0
k(1) = {[A(κ)]0 : κ ⊆k, κ ̸= ∅};
–
P1
k(1) = {[A(κ)]1 : κ = {0, . . . , l}, 0 ≤l ≤k −1};
–
P2
k(1) = {[0]2};
–
P2
k(2) = {[01]2}.
Indeed, note that x ∈Pi
k(1) (i ∈{0, 1, 2}) iﬀx contains A(κ) for some κ ⊆k.
Furthermore, for any κ1, κ2, κ ⊆k, A(κ1) ≤0 A(κ2) iﬀκ1 ⊆κ2, A(κ1) ≤1 A(κ2)
iﬀ|κ1| ≤|κ2|, and A(κ) ≡2 0. For the last example, let [P]2 ∈P2
k(2) for some
k-poset P of height 2. Then it can be easily proved that P contains an alternating
chain of length 2, and hence P ≡2 01.

On the Universality of Three-Orders on Finite Labeled Posets
|
397
2 Universality
A countable poset is called universal if every countable poset can be isomorphi-
cally embedded into it. In order to prove that a poset is universal, it is suﬃcient to
embed some known universal poset into the poset under consideration.
Let (G, ≤h) denote the set of all (loopless) directed graphs with the homomor-
phism relation (preorder), and let (Gh, ≤h) be the corresponding quotient struc-
ture (poset). As is well-known, Gh is a universal poset (see [2; 7; 9] and the bibliog-
raphy there). E. Lehtonen proved in [8] the universality of P0
k by embedding some
universal poset into P0
2(4). In [7] E. Lehtonen and L. Kwuida improved this result
by embedding Gh into P0
2(2).
Theorem 4. For any k ≥2, the posets P1
k and P2
k are universal.
Proof. As mentioned earlier, P1
2(1) and P2
2(2) contain only one element each. We
will give an idea of proof that P1
2(2) and P2
2(3) are universal (this evidently implies
the universality of P1
k and P2
k for any k ≥2).
It turns out that the following representation from [7] is valid for the structure
P1
2(2), too. For an arbitrary directed graph G = (V, E), deﬁne a 2-poset P(G) =
((V ∪E) × {0, 1}; ≤, c), where the partial order ≤and the labeling c are exactly
deﬁned by the following rules:
–
c(x, y) = y for all x ∈V ∪E, y ∈{0, 1};
–
(x, 0) < (x, 1) for each x ∈V, and (x, 1) < (x, 0) for each x ∈E;
–
(u, 0) < ((u, v), 0) and ((u, v), 1) < (v, 1) for each (u, v) ∈E.
It was proved in [7] that G ≤h H iﬀP(G) ≤0 P(H) for any G, H ∈G. Assume
that f : P(G) ≤1 P(H) and f : P(G) ̸≤0 P(H). Hence the 1-morphism f maps all ele-
ments with the label 0 to elements with the label 1 and vice versa. Deﬁne g: G →H
as follows: g(u) = v iﬀf(u, 0) = ((w, v), 1) for some w ∈H. It can be easily shown
that g is a graph homomorphism. Thus we proved that G ≤h H iﬀP(G) ≤1 P(H),
and this implies the embeddability of Gh into P1
2(2).
To embed Gh into P2
2, we use the following representation of a graph G =
(V, E) ∈G: Q(G) = ((V ∪E) × {0, 1, 2}; ≤, c), where ≤and c are exactly deﬁned
as follows:
–
c(x, 0) = c(x, 2) = 0 and c(x, 1) = 1 for all x ∈V;
–
c(x, 0) = c(x, 2) = 1 and c(x, 1) = 0 for all x ∈E;
–
(x, 0) < (x, 1) < (x, 2) for all x ∈V ∪E;
–
(u, 0) < ((u, v), 2) and ((u, v), 0) < (v, 2) for each (u, v) ∈E.

398
|
Anton V. Zhukov
0
0
Fig. 1: G = ({u, v}, {(u, v)}) and Q(G).
Figure 1 shows an example of this construction for a directed graph which has two
nodes and an arc between them. In comparison with the previous construction
for P1
2(2), the second component j of a pair (x, j) ∈Q(G) does not stand for the
label c(x, j), it shows the “level” of (x, j) in Q(G): (x, 0) is minimal, and (x, 2) is
maximal.
Note that the structures Fi
k are not universal, because they are so called well quasi-
orders, and have no inﬁnite descending chains (for F0
k, see [10] and bibliography
there for details).
3 Principal k-posets and k-forests
Deﬁnition 5. We call a k-poset P principal (or basic) if for any k-poset X X ≤2 P
implies X ≤0 P. Respectively, a k-forest F is principal (or basic) if for any k-forest
X X ≤2 F implies X ≤0 F.
Note that no restrictions are placed on cardinality of X in this deﬁnition. It is easy
to show that a nonempty principal k-poset or k-tree depends on k and must con-
tain all labels from the set k = {0, . . . , k −1}.
A k-poset (k-forest) B is called principal (or basic) for a k-poset (respectively, k-
forest) A if B is principal and A ≡2 B. Evidently, if a k-poset B is basic for a k-poset
A ∈Pk then [A]2 = [B]2 and B is basic for any C ∈[A]2 ∈P2
k. The same is true
for k-forests. Therefore, if B ∈Pk (B ∈Fk) is principal for some A ∈Pk (A ∈Fk),
we call B principal in the 2-class [B]2 ∈P2
k (respectively, [B]2 ∈F2
k). In that case,
we also call the element [B]0 ∈P0
k ([B]0 ∈F0
k) principal for the element [B]2 ∈P2
k
(respectively, [B]2 ∈F2
k). For any x ∈P2
k there exists at most one principal y ∈P0
k
(since any two principal k-posets for every k-poset are 0-equivalent), and the same
is true for the structure F2
k. The following theorem states that there exists always
exactly one such principal element (0-equivalence class):
Theorem 6. (i) For any ﬁnite k-poset there exists its ﬁnite principal k-poset.
(ii) For any ﬁnite k-forest there exists its ﬁnite principal k-forest.

On the Universality of Three-Orders on Finite Labeled Posets
|
399
Proof. In what follows, we will describe a simple procedure of constructing the
desired ﬁnite principal k-poset (k-forest).
(i) Let A ∈Pk be any ﬁnite k-poset. It is convenient to use some technical
terms in the following proof. We call any pair (x, i) ∈A × k k-element. Deﬁne the
reduction relation ⊴on A × k:
(x1, i1) ⊴(x2, i2) ⇔x1 ≤A x2 ∧(i1 ̸= i2 →cA(x1) ̸= cA(x2)).
In particular, (x1, cA(x1))⊴(x1, cA(x2)) for any x1, x2 ∈P. Note also that (x, i1)⊴
(x, i2) implies i1 = i2. The relation ⊴is reﬂexive and antisymmetric, but nontran-
sitive, i.e. is not a partial order (e.g. if x1 ≤A x2 ≤A x3, cA(x1) = cA(x3) = 0,
and cA(x2) = 1, then (x1, 0) ⊴(x2, 0) and (x2, 0) ⊴(x3, 1), but (x1, 0) ⋬(x3, 1)).
If (x1, i1) ⊴(x2, i2) then we call the k-element (x1, i1) lower for the k-element
(x2, i2), and (x2, i2) is upper for (x1, i1).
A (local) reduct of A is any quadruple of the form (x, i, L, U), where x ∈A,
i ∈k, and L, U ⊆A × k are such sets of k-elements that (x, i) ∈L ∩U and any
k-element from U is upper for any k-element from L:
∀(x1, i1) ∈L ∀(x2, i2) ∈U (x1, i1) ⊴(x2, i2).
In particular, any k-element from L is lower for (x, i), and any k-element from
U is upper for (x, i). We call the k-elements of L lower for the reduct (x, i, L, U),
and the k-elements of U upper for this reduct. Since ⊴is antisymmetric, we have
L ∩U = {(x, i)}. In an intuitive sense which will be clariﬁed later, the reduct
(x, i, L, U) is a “local representation” of some k-poset P ≤2 A, where x represents
some element x ∈P with cP(x) = i, and L, U represent respectively ˆa, ˇa – lower
and upper cones of this element in P.
Consider the set B of all reducts of A. B is clearly ﬁnite. Let
(x1, i1, L1, U1) ≤B (x2, i2, L2, U2) iﬀL1 ⊆L2 and U2 ⊆U1.
The reﬂexivity and the transitivity of the relation ≤B are obvious. Taking into ac-
count that L1 ∩U1 = {(x1, i1)} and L2 ∩U2 = {(x2, i2)}, we obtain the an-
tisymmetry of ≤B. Thus ≤B is a partial order. It should be noted a simple, yet
important property of this relation: (x1, i1, L1, U1) ≤B (x2, i2, L2, U2) implies
(x1, i1) ⊴(x2, i2) (since (x1, i1) ∈L1 ⊆L2). After deﬁning the labeling function
cB(x, i, L, U) = i on B, we have the ﬁnite k-poset (B; ≤B, cB) which, as usual, will
be denoted just by B.
Next we prove that A ≡2 B. For any x ∈A, denote
L(x) = {(y, cA(y)) ∈A × k | y ≤A x}, U(x) = {(y, cA(y)) ∈A × k | x ≤A y}.
It is easy to verify that the mapping x →(x, i, L(x), R(x)) is an isomorphic embed-
ding from A into B. Therefore A ≤0 B and A ≤2 B. Consider now the projection

400
|
Anton V. Zhukov
(x, i, L, U) →x from B to A. The implication (x1, i1, L1, U1) ≤A (x2, i2, L2, U2) →
(x1, i1) ⊴(x2, i2) and the deﬁnition of the reduction relation ⊴yield that this pro-
jection is a 2-morphism. Thus B ≤2 A and A ≡2 B.
Let P be an arbitrary k-poset such that f : P ≤2 A. For any x ∈P, denote
Lf (x) = {(f(y), cP(y)) | y ∈P ∧y ≤P x},
Uf (x) = {(f(y), cP(y)) | y ∈P ∧x ≤P y}.
Let (f(y1), cP(y1)) ∈Lf (x) and (f(y2), cP(y2)) ∈Uf (x). Since y1 ≤P x ≤P y2
and f is a 2-morphism, we have f(y1) ≤A f(y2). Moreover, cP(y1) ̸= cP(y2) im-
plies cA(f(y1)) ̸= cA(f(y2)), and hence (f(y1), cP(y1)) ⊴(f(y2), cP(y2)). There-
fore (f(x), cP(x), Lf (x), Uf (x)) is a reduct for any x ∈P. Consider the mapping
g: P →B deﬁned by
g(x) = (f(x), cP(x), Lf (x), Uf (x)).
If x1 ≤P x2 then Lf (x1) ⊆Lf (x2) and Uf (x2) ⊆Uf (x1), and hence g is monotone.
Since cB(g(x)) = cP(x), g preserves the labeling. Thus g: P ≤0 B.
(ii) For an arbitrary ﬁnite k-forest A ∈Fk, consider its principal ﬁnite k-poset
C which has been constructed (under the name of B) in the previous item. Let
B = split(C). Then B ≤0 C ≤2 A and B ≤2 A. On the other hand, if F is a k-forest
and F ≤2 A then F ≤0 C and F ≤0 B. In particular, F = A implies A ≤0 B and
A ≤2 B. Thus B is really a principal ﬁnite k-forest for A.
Let ppk and pfk denote respectively the operations of constructing the principal k-
poset and k-forest according to Theorem 6. Namely, for A ∈Pk, we set ppk(A) = B,
where B is as constructed from A in the proof of Theorem 2 part (i). Similarly, for
A ∈Fk, we set pfk(A) = B, where B is as constructed from A in the proof of
Theorem 2, part (ii).
4 Embedding
The following lemma reﬂects a general property of principal k-posets and k-forests
which holds for both operations ppk and pfk:
Lemma 7. (i) For any k-posets P, Q ∈Pk, the following ﬁve assertions are equiva-
lent: P ≤2 Q, P ≤2 ppk(Q), ppk(P) ≤2 ppk(Q), P ≤0 ppk(Q), ppk(P) ≤0 ppk(Q).
(ii) For any k-forests F, G ∈Fk, the following ﬁve assertions are equivalent:
F ≤2 G, F ≤2 pfk(G), pfk(F) ≤2 pfk(G), F ≤0 pfk(G), pfk(F) ≤0 pfk(G).

On the Universality of Three-Orders on Finite Labeled Posets
|
401
Proof. We will show only (i), (ii) is checked analogously. Since ppk(P) and ppk(Q)
are principal k-posets for P and Q, respectively, we have by deﬁnition P ≡2 ppk(P)
and Q ≡2 ppk(Q). By the transitivity of the relation ≤2, this implies the equiva-
lence of the ﬁrst three assertions: P ≤2 Q, P ≤2 ppk(Q), and ppk(P) ≤2 ppk(Q).
Deﬁnition 5 yields the implications from P ≤2 ppk(Q) to P ≤0 ppk(Q) and
from ppk(P) ≤2 ppk(Q) to ppk(P) ≤0 ppk(Q). The opposite implications from
P ≤0 ppk(Q) to P ≤2 ppk(Q) and from ppk(P) ≤0 ppk(Q) to ppk(P) ≤2 ppk(Q)
hold since the 2-preorder ≤2 is a coarsening of ≤0.
Corollary 8. (i) The poset P2
k is isomorphically embeddable into the posets P0
k and
P1
k.
(ii) The poset F2
k is isomorphically embeddable into the posets F0
k and F1
k.
Proof. Consider the following induced operations ppi
k and pfi
k for i ∈{0, 1}:
–
ppi
k : P2
k →Pi
k, ppi
k([P]2) = [ppk(P)]i;
–
pfi
k : F2
k →Fi
k, pfi
k([F]2) = [ppk(F)]i.
By Lemma 7, P ≤2 Q holds iﬀppk(P) ≤0 ppk(Q), and F ≤2 G holds iﬀpfk(F) ≤0
pfk(G) (for any P, Q ∈Pk and F, G ∈Fk). Hence one can easily conclude that ppi
k
embeds P2
k into Pi
k, and pfi
k embeds F2
k into Fi
k.
It should be noted that there are other ways of proving P2
k to be embeddable into
P0
k and P1
k. Moreover, these three structures are pairwise embeddable into each
other since they are universal, i.e. any countable poset can be embedded into each
of them (for universality of P0
k see [8], universality of P1
k and P2
k is shown in this
paper). Nonetheless, the algorithm in the proof of Theorem 6 deﬁnes a natural
embedding in the sense that pp0
k(x) ⊆pp1
k(x) ⊆x for any x ∈P2
k, and pf0
k(x) ⊆
pf1
k(x) ⊆x for any x ∈F2
k.
5 P2
k and F2
k as distributive lattices
One of the ﬁrst natural questions about a poset is whether it is a (distributive)
lattice, i.e. whether there exist suprema and inﬁma (for any pair of elements) in
this structure. It is simple and well-known fact that the (induced) join ⊔is the
supremum in the structures P0
k, F0
k. Moreover, these structures are distributive
lattices: it was proved for Fk by V.L. Selivanov [10], and for Pk by E. Lehtonen [8].

402
|
Anton V. Zhukov
The label-matching product P ⊗Q of k-posets P, Q is deﬁned as follows [8]:
P ⊗Q = {(x, y) ∈P × Q | cP(x) = cQ(y)};
(x1, y1) ≤P⊗Q (x2, y2) ⇔x1 ≤P x2 ∧y1 ≤Q y2;
cP⊗Q(x, y) = cP(x) = cQ(y).
The induced label-matching product operation [P]0 ⊗[Q]0 = [P ⊗Q]0 is the inﬁ-
mum of [P]0, [Q]0 in P0
k. Note that the label-matching product of two k-forests is
not necessarily a k-forest. For example, the 3-poset 210 ⊗120 contains the least
element (labeled with 0) and two maximal incomparable elements (labeled with
1 and 2).
The inﬁmum of elements f , g ∈F0
k is deﬁned in [10] as follows:
infF0
k {x, y} =

{h ∈F0
k : h ≤0 f ∧h ≤0 g} =

(ˆx ∩ˆy).
The existence of this join in F0
k follows from the fact that every lower cone in this
structure is ﬁnite (since F0
k is a well quasi-order [10]).
Deﬁne the split (label-matching) product F ⊠G, and its induced version:
F ⊠G = split(F ⊗G), [F]0 ⊠[G]0 = [split(F ⊗G)]0.
The correctness of the deﬁnition of the induced split product follows from the def-
inition of the split function. The following lemma contains a simple constructive
description of the inﬁmum in F0
k as the induced split product:
Lemma 9. For any x, y ∈F0
k, infF0
k {x, y} = x ⊠y.
Proof. It immediately follows from the deﬁnition of the split function and the fact
that ⊗induces the inﬁmum in P0
k.
Theorem 10. For any k ≥2, the structures P2
k and F2
k are distributive lattices.
Proof. It is easy to verify that the induced join [A]2 ⊔[B]2 = [A ⊔B]2 is the supre-
mum of [A]2, [B]2 in P2
k and F2
k.
Next we construct the inﬁmum in the structure P2
k. For arbitrary k-posets P
and Q, deﬁne the 2-product operation ⊙as follows:
P ⊙Q = ppk(P) ⊗ppk(Q).
Since P ⊙Q = ppk(P) ⊗ppk(Q) ≤0 ppk(P) ≤2 P, we have P ⊙Q ≤2 P. In the same
way P ⊙Q ≤2 Q. Let X ∈Pk be any ﬁnite k-poset such that X ≤2 P and X ≤2 Q.
Then, by Lemma 7 (i), X ≤0 ppk(P) and X ≤0 ppk(Q). Hence we obtain X ≤0 P⊙Q

On the Universality of Three-Orders on Finite Labeled Posets
|
403
and X ≤2 P ⊙Q. Thus we have proved that the induced 2-product is the inﬁmum
in P2
k:
infP2
k {[P]2, [Q]2} = [P]2 ⊙[Q]2 = [P ⊙Q]2.
To prove the distributivity, we need the following property of the operation ppk:
ppk(P ⊔Q) ≡0 ppk(P) ⊔ppk(Q).
(1)
Next we verify this 0-equivalence. Since ppk(P) and ppk(Q) are principal for P and
Q, respectively, we have P ≡2 ppk(P) and Q ≡2 ppk(Q), and hence P ⊔Q ≡2
ppk(P)⊔ppk(Q). Now let X be an arbitrary k-poset such that X ≤2 ppk(P)⊔ppk(Q).
Then f : X ≤2 P ⊔Q for some 2-morphism f. We can assume w.l.o.g. that P and
Q are disjoint. Then P ⊔Q is isomorphic to P ∪Q, and we can treat P ⊔Q as
P∪Q. Consider the disjoint k-subposets X1 = f −1(P) and X2 = f −1(Q). Obviously,
X1 ∪X2 = X. By the monotonicity of the 2-morphism f, we have
∀x ∈X1∀y ∈X2 (x ̸≤X y ∧y ̸≤X x).
Therefore, X1 ⊔X2 is isomorphic to X, and hence X1 ⊔X2 ≡0 X. On the other hand,
we have f|X1 : X1 ≤2 P and f|X2 : X2 ≤2 Q. Then, by Lemma 7, X1 ≤0 ppk(P),
X2 ≤0 ppk(Q), and hence X1 ⊔X2 ≤0 ppk(P) ⊔ppk(Q). Since X1 ⊔X2 ≡0 X, this
implies X ≤0 ppk(P) ⊔ppk(Q). Thus the k-poset ppk(P) ⊔ppk(Q) is principal for
P ⊔Q, so we have proved 0-equivalence (1).
From (1) and the distributivity of the lattice P0
k, for any P, Q1, Q2 ∈Pk, we
have
P ⊙(Q1 ⊔Q2) = ppk(P) ⊗ppk(Q1 ⊔Q2) ≡0 ppk(P) ⊗(ppk(Q1) ⊔ppk(Q2)) ≡0
(ppk(P) ⊗ppk(Q1)) ⊔(ppk(P) ⊗ppk(Q2)) = (P ⊙Q1) ⊔(P ⊙Q2).
The 0-equivalence P⊙(Q1 ⊔Q2) ≡0 (P⊙Q1)⊔(P⊙Q2) implies the corresponding
distributive law in the structure P2
k, therefore this structure is a distributive lattice
(it is a well-known fact that one distributive law is suﬃcient for distributivity).
Similarly to the case of the structure P2
k, consider the following split 2-product
operation: for any F, G ∈Fk, let
F ⊡G = pfk(F) ⊠pfk(G).
By analogy with the structure P2
k, one can easily show that the induced split 2-
product is the inﬁmum in F2
k: infF2
k ({P, Q}) = [P]2 ⊡[Q]2 = [P ⊡Q]2. The dis-
tributivity can be proved similarly using the property
pfk(F ⊔G) ≡0 pfk(F) ⊔pfk(G).

404
|
Anton V. Zhukov
6 Some notes on the structures P1
k and F1
k
In this section, we investigate minimal upper and maximal lower bounds in the
structures P1
k and F1
k. Hereby we show that, in contrast to the lattices P0
k, F0
k, P2
k,
and F2
k, the structures P1
k (for k ≥2) and F1
k (for k ≥3) are not lattices. The
structure F1
2 is excluded from consideration since it is a linearly ordered set of
type ω; this assertion easily follows from the fact that every 2-tree is 0-equivalent
to an alternating 2-chain ([10], see also a description of F0
2 therein).
For any k-poset P = (P; ≤P, cP), deﬁne two sets of "repaintings" of P:
rep+
k (P) = {(P; ≤P, c) | idP : (P; ≤P, cP) ≤1 (P; ≤P, c)},
rep−
k (P) = {(P; ≤P, c) | idP : (P; ≤P, c) ≤1 (P; ≤P, cP)}.
The k-posets from rep+
k (P) and rep−
k (P) have the same structure as P, but possibly
another labeling function c; rep+
k (P) (rep−
k (P)) contains all such k-posets to which
P is 1-reducible (which are 1-reducible to P, respectively) by the identity mapping
idP.
Lemma 11. For any A ∈Pk such that P ≤1 A, there exists Q ∈rep+
k (P) such that
Q ≤0 A. For any A ∈Pk such that A ≤1 P, there exists Q ∈rep−
k (P) such that
A ≤0 Q.
Proof. If f : P ≤1 A then take Q = (P; ≤P, cA ◦f). Now assume that f : A ≤1 P,
and, according to Deﬁnition 2 (ii), g: k →k is such mapping that cA = g ◦cP ◦f.
Deﬁne c = g ◦cP and Q = (P; ≤P, c). Then cA = c ◦f and c = g ◦cP ◦idP. By
Deﬁnition 2 (i) and (ii), we have f : A ≤0 Q and idP : Q ≤1 P.
Let mubP1
k (x, y), mlbP1
k (x, y), mubF1
k (x, y), mlbF1
k (x, y) denote the sets of all min-
imal upper bounds and all maximal lower bounds of x, y in the structure P1
k, and
the sets of all minimal upper bounds and all maximal lower bounds of x, y in the
structure F1
k, respectively. Perhaps the simplest general observation of minimal
upper and maximal lower bounds in the structures P1
k and F1
k is the following
one.
Proposition 12. (i) For any P, Q ∈Pk,
mubP1
k ([P]1, [Q]1) ⊆{[A ⊔B]1 ∈P1
k | A ∈rep+
k (P), B ∈rep+
k (P)},
mlbP1
k ([P]1, [Q]1) ⊆{[A ⊗B]1 ∈P1
k | A ∈rep−
k (P), B ∈rep−
k (P)}.
(ii) For any F, G ∈Fk,
mubF1
k ([F]1, [G]1) ⊆{[A ⊔B]1 ∈F1
k | A ∈rep+
k (F), B ∈rep+
k (G)},
mlbF1
k ([F]1, [G]1) ⊆{[A ⊠B]1 ∈F1
k | A ∈rep−
k (F), B ∈rep−
k (G)}.

On the Universality of Three-Orders on Finite Labeled Posets
|
405
Proof. The assertions easily follow from Lemma 11 and the properties of the oper-
ations ⊔, ⊗, and ⊠: the join ⊔induces the supremum in both structures P0
k and F0
k,
and the operations ⊗, ⊠(by Lemma 9) induce the inﬁma in these structures.
When do the inclusions in Proposition 12 become equalities, or what reﬁnements
can be made for this proposition? Next we propose some natural restraints on the
conditions of Proposition 12 which allow to obtain simple examples of unequal
minimal upper bounds.
We call a k-poset P rigid (in the sense of labeling) if any 1-endomorphism
(i.e., 1-morphism from P to itself) is a 0-morphism. A k-poset (P; ≤P, cP) is called
connected if the corresponding poset (P; ≤P) is (weakly) connected as a directed
graph, i.e., there is an undirected path between any pair of elements. For exam-
ple, any alternating k-chain is rigid and connected. An important property of con-
nected k-posets is the join irreducibility: if P is a connected k-poset then
∀A, B ∈Pk(P ≤i A ⊔B →(P ≤i A ∨P ≤i B)), where i ∈{0, 1, 2}.
This property for all three preorders ≤i evidently follows from the monotonicity
of an i-morphism since an image of a connected k-poset must be connected.
As usual, the set of all permutations of the set k (i.e., bijections from k to itself)
will be denoted by Sk. For every α ∈Sk, deﬁne α(P) = (P; ≤P, α ◦cP). It is easy
to show that {α(P) | α ∈Sk} = rep+
k (P) ∩rep−
k (P). Note that P ≡1 α(P) for
any α ∈Sk. However, the k-posets α(P) are 0-incomparable for diﬀerent α in the
following particular case:
Lemma 13. If P ∈Pk is rigid and cP(P) = k then α(P) ≤0 β(P) implies α = β.
Proof. Let f : α(P) ≤0 β(P), then f : P ≤0 (α−1◦β)(P). Hence f : P ≤1 (α−1◦β)(P).
From idP : (α−1 ◦β)(P) ≤1 P, by transitivity of the relation ≤1, we obtain that
idP ◦f = f is a 1-morphism from P to itself. Since P is rigid, f is a 0-morphism from
P to itself. Consider an arbitrary label a ∈k. Since cP(f(P)) = cP(P) = k, there
exists x ∈P such that cP(f(x)) = a. From f : P ≤0 P and f : P ≤0 (α−1 ◦β)(P), we
conclude that a = cP(f(x)) = cP(x) = c(α−1◦β)(P)(f(x)) = (α−1 ◦β)(cP(f(x))) =
(α−1 ◦β)(a). Thus α−1 ◦β = idk, and hence α = β.
Proposition 14. Let P, Q ∈Pk be 1-incomparable rigid connected k-posets such
that cP(P) = cQ(Q) = k. Then
mubP1
k ([P]1, [Q]1) = {[α(P) ⊔Q]1 | α ∈Sk}.
Moreover, the k-posets α(P) ⊔Q are pairwise 1-incomparable for diﬀerent α ∈Sk,
and hence |mubP1
k ([P]1, [Q]1)| = k!. If P, Q ∈Fk then the same assertion holds for
mubF1
k ([P]1, [Q]1).

406
|
Anton V. Zhukov
0
1
1
0
0
1
0
1
0
1
1
1
Fig. 2: 2-posets P and Q with |mubP1
2([P]1, [Q]1)| = 2
Proof. Evidently, cP(P) = cQ(Q) = k implies rep+
k (P) = {α(P) | α ∈Sk} and
rep+
k (Q) = {β(Q) | β ∈Sk}. For any α, β ∈Sk, β−1 ◦α ∈Sk and
α(P) ⊔β(Q) ≡1 β−1(α(P) ⊔β(Q)) = (β−1 ◦α)(P) ⊔idk(Q).
Thus we have
{[A ⊔B]1 ∈P1
k | A ∈rep+
k (P), B ∈rep+
k (P)} = {[α(P) ⊔Q]1 | α ∈Sk},
and, by Proposition 12,
mubP1
k ([P]1, [Q]1) ⊆{[α(P) ⊔Q]1 | α ∈Sk}.
In order to prove the required equality, it is suﬃcient to show that, for any unequal
α, β ∈Sk, α(P) ⊔Q ̸≤1 β(P) ⊔Q. Indeed, for some α, β ∈Sk, let f : α(P) ⊔Q ≤1
β(P) ⊔Q. Then, due to the connectedness and 1-incomparability of P and Q, we
obtain f|α(P) : α(P) ≤1 β(P) and f|Q : Q ≤1 Q. Since Q is rigid, f|Q is a 0-morphism.
Due to cQ(Q) = k, f|Q preserves every label from k, hence so does the whole map-
ping f (f maps elements with unequal labels to elements with unequal labels),
and we have f|α(P) : α(P) ≤0 β(P). By Lemma 13, this implies α = β. The case of
the structure F1
k is treated similarly.
Proposition 14 allows to construct examples of pairs of elements without the
supremum in the structures P1
k and F1
k. For the structure P1
2, take two connected
2-posets P, Q depicted on Figure 2. Any 1-morphism between 2-posets preserves
the labels 0 and 1, or permutes them. Furthermore, any 2-chain 01 is mapped to 01
or, respectively, 10. These facts show that P and Q are rigid and 1-incomparable.
By Proposition 14, this implies that the 1-equivalence classes [P]1 and [Q]1 have
exactly two minimal upper bounds in the structure P1
2. As rigid 1-incomparable
3-forests, we can take 3-chains 0102 and 0120. Then [0102]1 and [0120]1 have ex-
actly 3! = 6 minimal upper bounds in the structure F1
3, namely [0102 ⊔0120]1,
[1012 ⊔0120]1, [2120 ⊔0120]1, [0201 ⊔0120]1,[1210 ⊔0120]1, [2021 ⊔0120]1.
Finally, we propose some general combinatorial reﬁnement of Proposition 12.
Recall that Deﬁnition 2 (ii) requires for a 1-morphism f : P →Q the existence of
a mapping g: k →k such that cP = g ◦cQ ◦f. For technical reasons, instead of

On the Universality of Three-Orders on Finite Labeled Posets
|
407
the total mapping g, we will w.l.o.g. consider the corresponding partial mapping.
A partial transformation of the set k is a partial mapping from k to itself. Denote
the domain and the range of an arbitrary partial transformation α by D(α) and
R(α), respectively. A partial permutation of the set k is a partial transformation of
k which is a bijection between two subsets of k. For example, the identity mapping
idκ is a partial permutation for any κ ⊆k, where D(idκ) = κ and idκ(x) = x for
every x ∈κ. Let ˆTk and ˆSk denote the sets of all partial transformations and all
partial permutations of k, respectively. Thus a monotone function f : P →Q is a
1-morphism iﬀthere exists φ ∈ˆTk with R(φ) = cP(P) and D(φ) ⊆cQ(Q) such
that cP = φ ◦cQ ◦f. This partial transformation φ is an important characteristic
of the 1-morphism f, and is deﬁned uniquely by f.
The composition of partial transformations α, β ∈ˆTk such that D(α) ⊆R(β)
is deﬁned as usual: α◦β is a partial transformation on k with the domain D(α◦β) =
{x ∈D(β) : β(x) ∈D(α)} and with the range R(α ◦β) = R(α) given by the rule
(α ◦β)(x) = α(β(x)) for all x ∈D(α ◦β).
For any α, β ∈ˆTk, we say that α is divided by β (on the right), or β is a (right)
divisor of α, if there exists γ ∈ˆTk such that D(γ) ⊆R(β) and α = γ ◦β. In that
case, γ is called a quotient (of α by β), denoted γ = α/β. The quotient γ (if it
exists) is determined uniquely by α and β since D(γ) = β(D(α)). Any two partial
transformations have at least one common divisor – the identity mapping idk. A
common divisor γ of α, β ∈ˆTk is called a greatest common divisor, if γ is divided
by any common divisor of α, β. Let gcd(α, β) denote the set of all greatest common
divisors of α, β. We call two partial transformations α, β coprime, denoted α ⊥β,
if gcd(α, β) contains only partial permutations. For any k-poset P = (P; ≤P, cP),
deﬁne the set ˆTk(P) ⊆ˆTk, and, for every partial transformation α ∈ˆTk(P), deﬁne
the set rep+
k (P, α) ⊆rep+
k (P):
ˆTk(P) = {α ∈ˆTk | R(α) = cP(P) ∧∀a ∈cP(P)(|α−1(a)| ≤|c−1
P (a)|)},
rep+
k (P, α) = {(P; ≤, c) ∈rep+
k (P) | cP = α ◦c}.
The following results show how Proposition 12 can be reﬁned using properties
of the divisibility of partial transformations. We do not give all details of their
straightforward proofs.
Lemma 15. Let α, β ∈ˆTk be arbitrary partial transformations.
(i) gcd(α, β) ̸= ∅, and D(γ) = D(α) ∪D(β) for any γ ∈gcd(α, β).
(ii) For any γ ∈gcd(α, β), α/γ ⊥β/γ.
Proof. We will show only that gcd(α, β) ̸= ∅. Deﬁne the following binary relations
on the set k:
x ∼α y ⇔(x ∈D(α) ∧y ∈D(α) ∧α(x) = α(y)) ∨(x ̸∈D(α) ∧y ̸∈D(α)),

408
|
Anton V. Zhukov
∼β is deﬁned similarly with β instead of α, and
x ∼y ⇔x ∼α y ∧x ∼β y.
The relations ∼α, ∼β, ∼are equivalence relations. Consider an arbitrary partial
transformation γ such that D(γ) = D(α) ∪D(β), and, for any x, y ∈D(γ), γ(x) =
γ(y) iﬀx ∼y. Next we check that γ ∈gcd(α, β).
Let x ∈R(γ), and x = γ(y) for some y ∈D(γ). Deﬁne γ1 ∈ˆTk as follows: if
y ∈D(α) then deﬁne γ1(x) = α(y), else let γ1(x) be undeﬁned. This deﬁnition
is correct because the value γ1(x) does not depend on the choice of y (all such y
belong to one ∼-equivalence class, and hence to one ∼α-equivalence class). Hence
α/γ = γ1, and γ is a divisor of α. By a parallel argument, γ is also a divisor of β
with some quotient γ2 = β/γ.
Now let δ be another common divisor of α, β with the quotients δ1 = α/δ,
δ2 = β/δ. Deﬁne ε ∈ˆTk as follows. Let D(ε) = D(δ1) ∪D(δ2), and consider an
arbitrary x ∈D(ε). By the deﬁnition of a quotient, D(δ1) ⊆R(δ), D(δ2) ⊆R(δ),
and hence D(ε) ⊆R(δ). Consequently, there exists y ∈D(δ) such that x = δ(y).
Moreover, y ∈D(α) ∪D(β) = D(γ), hence y ∈D(γ), and we set ε(x) = γ(y). Note
that D(ε) ⊆R(δ). Again, it is easy to check the correctness of this deﬁnition of ε,
i.e., the independence of ε(x) from the choice of y. Indeed, let x = δ(y) = δ(y1) ∈
D(ε). Since δ is a divisor of α and β, we have α(y) = α(y1) and β(y) = β(y1).
Therefore, y ∼y1 and hence γ(y) = γ(y1). Thus the deﬁnition of ε is correct.
This deﬁnition, the inclusion D(ε) ⊆R(δ), and the continued equality D(ε ◦δ) =
δ−1(D(δ1) ∪D(δ2)) = D(α) ∪D(β) = D(γ) imply the divisibility γ/δ = ε.
Proposition 16. For any P, Q ∈Pk, every minimal upper bound of the elements
[P]1, [Q]1 in the structure P1
k has the form [A ⊔B]1, where A ∈rep+
k (P, α) and B ∈
rep+
k (Q, β) for some α ∈ˆTk(P) and β ∈ˆTk(Q) such that α ⊥β. If P, Q ∈Fk then
the same assertion holds for the structure F1
k.
Proof. Let f : P ≤1 X and g: Q ≤1 X for [X]1 ∈mubP1
k ([P]1, [Q]1), and let φ, ψ ∈
ˆTk be the corresponding partial transformations for f , g, respectively. Consider
any γ ∈gcd(φ, ψ), and denote α = φ/γ, β = ψ/γ. By the item (ii) of the previous
lemma, α ⊥β. Let A = (P; ≤P, γ ◦f) and B = (Q; ≤Q, γ ◦g). Since P ≤1 A, Q ≤1 B,
and A ⊔B ≤1 X, we have [A ⊔B]1 = [X]1.
Acknowledgement: The author is grateful to his research supervisor, Professor
V. L. Selivanov, for the encouragement and helpful discussions. The author also
thanks an anonymous referee for careful reading and pointing out some misprints
and inaccuracies, as well as for valuable suggestions.

On the Universality of Three-Orders on Finite Labeled Posets
|
409
Bibliography
[1]
B. Davey and H. Priestley. Introduction to Lattices and Order. Cambridge University Press,
Cambridge, 2nd Edition, 2002.
[2]
P. Hell and J. Nešetřil. Graphs and Homomorphisms. Oxford University Press, 2004.
[3]
P. Hertling. Topologische Komplexitätsgrade von Funktionen mit endlichem Bild. Infor-
matik Berichte 152, FernUniversität Hagen, 1993.
[4]
P. Hertling. Unstetigkeitsgrade von Funktionen in der eﬀektiven Analysis. PhD thesis,
Fachbereich Informatik, FernUniversität Hagen, 1996.
[5]
P. Hertling and V. L. Selivanov. Complexity issues for preorders on ﬁnite labeled forests.
B. Löwe (ed.) et al., Models of Computation in Context. CiE 2011, LNCS 6735, Springer,
Berlin, 112–121, 2011.
[6]
M. D. Hirsch. Applications of topology to lower bound estimates in computer science.
Hirsch, M. W. (ed.) et al., From Topology to Computation: Proceedings of the Smalefest.
Springer, New York, 395–418, 1993.
[7]
L. Kwuida and E. Lehtonen. On the homomorphism order of labeled posets. Order,
28(2):251–265, 2011.
[8]
E. Lehtonen. Labeled posets are universal. Eur. J. Comb., 29(2):493–506, 2008.
[9]
A. Pultr and V. Trnková. Combinatorial, Algebraic and Topological Representations of
Groups, Semigroups and Categories. North-Holland, Amsterdam, 1980.
[10] V. Selivanov. Boolean hierarchies of partitions over reducible bases. Algebra and Logic,
43(1):77–109, 2004.
[11]
K. Weihrauch. The TTE-interpretation of three hierarchies of omniscience principles.
Informatik Berichte 130, FernUniversität Hagen, 1992.


Index
0-morphism 405, 406
1-morphism 395, 397, 405–407
2-morphism 395, 400, 403
2-product 402
– split 403
Σ1
1 equivalence relation 157, 158, 160, 162
α-dimensional measure 385, 388–390
ω-pattern 194
ω-regular language 109–111, 113, 119, 123, 124
i-equivalent 396
i-incomparable 395
i-morphic 395
i-order 396
i-reducible 395, 396
acceptance by automaton 299, 304, 308, 318,
319
adjoint 89–91
admit ﬁlters 343, 357, 358, 360, 371
algorithmically random 139, 145
alternating 394, 396, 404, 405
atomic boolean algebra 193
axiomatization 297–300, 315, 316
Baire category theorem 93, 104
basic 398
Borel determinacy 117
Brownian motion 139–141, 146, 148, 149, 153
canonical basis 276, 278, 279, 284
Cantor normal form 119, 122–125, 130
Cantor topology 109, 115
chain 168, 188
Clebsh-Gordan matrix 273, 277, 280, 282, 283,
285, 287
complete 26, 29, 48, 61, 64, 75, 77
completely enumerable 328–330, 344, 345,
354, 355, 362, 372–375
complex oscillation 140, 144–146, 148–151,
155
complexity 165, 167, 169, 177, 187
– Kolmogorov 140, 145
computably isomorphic 345, 349, 350, 354,
361, 367, 368, 372, 374, 376, 378
constructive metric space 343, 369–372, 374
correspondence 347, 348, 350, 353
counter-free DFA 195
counting pattern 195
crystal group 291
d-balanced counting pattern 195
d-quasi-aperiodicity index 196
decidable language 193
deterministic Muller automaton 112, 123
eﬀective ﬁxed point property 328, 333, 335
eﬀective Urysohn property 361, 362, 367, 368,
372, 379
elasticity equations 274
equivalent 327
– strongly 367, 379
fairness constraint 299, 305, 306, 308, 312,
318, 319
family of reducibilities 220
ﬁnite automaton 386, 388
ﬁnite point 360–362, 367–369, 379
ﬁrst Baire category 390
forest 166, 168–172, 174, 175, 178–181
Fourier dimension 143, 144
Frechét ideal 193
game
– indeterminate 205, 206, 210
– inﬁnite 206, 209
– perfect information 205, 206
– Wadge 117, 120, 121, 123, 124, 127–129
game determinacy 205, 206
general limit algorithm 370, 372–375
Hamel set 151
Hausdorﬀdimension 140, 142–144, 383–385
Heyting algebra 260, 263–266, 269, 271
hierarchy
– bad 215

412
|
Index
– Borel 80, 110, 116
– good 247
– very bad 215
– very good 216, 224, 247
– Wadge 110, 111, 119, 127, 134
immune 30
implicative lattice 263, 264
inﬁnite words 109
inﬁnite XOR function 206–208
inﬁnitesimal operator 275–277, 279, 282, 283
initializable 127, 129, 132, 133
injective hull 9
irreducible representation 273, 275, 277, 278,
280, 284, 285, 287
isomorphism relation 157
iterated Frechét ideal 193
join 394, 401, 402, 405
jump operator 81, 83–91, 94, 97, 98, 102, 103,
105
k-labeled chain 168
k-partially blind-counter automata 115, 123,
126
L-hierarchy 158
label-matching product 402
– split 402
labeled forest 393
labeled poset 393, 394
limit-computable 79
Lipschitz function 215, 216, 220, 230, 238, 242,
244, 252
logic
– explosive Nelson 262
– explosive wrt. ∼(wrt ⊥) 262
– linear temporal 298, 316
– paraconsistent Nelson 262
– paraconsistent wrt. ∼(wrt. ⊥) 262
– propositional program 315
low-jump-operator 90
Martin-Löf random 139, 148
minimal ample 11
model checking 298–300, 310–312, 315, 316
multicounter automaton 113
non-self dual Borel set 120–122
nonexpansive 10, 216, 220, 232
nontrivially unbounded 224, 225, 228, 229,
231, 232
normed enumeration 356, 357, 365, 366, 370,
371, 378
nowhere dense 390
NP-complete 167, 178
numbering 325–335, 337–339, 344
– acceptable 343, 368, 379
– approximating 357, 366
– canonical 343, 376
– faithful 375
– perfect 367
– strongly acceptable 343, 358, 360, 361, 379
– strongly approximating 358–360, 367, 368,
370
– strongly computable 358–361, 366–368, 371,
372, 375, 376
– strongly correct 343, 361, 367, 368, 379
partial numbering 326–328, 331, 332, 339,
342–347, 349, 378
partially blind counters 111, 123
Petri net 109, 111, 113, 119, 134, 135
polynomial time 177, 178
Post’s Problem 26, 76
Post’s Program
– Generalized 25
precomplete 328, 330–334, 337, 338
– correctly 331, 332, 334, 335, 337–339
– faintly 331, 333, 335, 337–339
preorder 166, 169, 187
primitive word 197
principal 398–401, 403
propositional µ-calculus 299, 309, 312, 315,
316
q-hyperconvex 9, 11
q-hyperconvex hull 11, 12
quasi-aperiodicity index 195
quasi-Polish space 80, 82, 101, 103, 104
realizable 345
reducibility
– Borel 157
– computable Lipschitz 23, 25

Index
|
413
– identity bounded Turing 23
– linearly bounded Turing 75
– Turing 25, 77
reducible 327, 332
– strongly 346
– strongly bounded Turing 25, 26, 28, 29, 31,
60
– weak-truth-table 27, 77
reduct 399, 400
regular ω-language 383, 384, 387–391
regular d-quasi-aperiodic languages 196
regular quasi-aperiodic languages 195
repetition-free 394
representation
– admissible 82, 85, 92, 93, 97, 101–103, 106
represented space 79, 81–83, 86, 89–92, 98,
100, 104, 105, 107
respect approximation 357
retraction 223, 224, 234
rigid 405, 406
Salem set 143, 149
Scott’s theorem 157
semi-linear ordering principle 214, 242
simple 30, 33, 34, 49, 50, 52–54, 56–58, 60,
61, 65–68, 73
sparse language 194
spinor polynomial 277–279, 282
strategy stealing 208
strong basis 355, 356, 367–369, 377
strong inclusion 355, 364, 367–369, 376, 377,
379
strongly allow eﬀective limit passing 357
strongly random countable set 152–155
stuttering automata 304–306, 311
table 386–388
tight extension 12, 17–19
tight span 9
totalizer 326, 328, 330, 331, 334, 338, 339
tree 168–172, 174–176, 180, 181
twist-structure 260, 261, 263–265, 267, 268
ultrametric Polish space 216–225, 228, 229,
231–234, 241–244, 250, 252, 253, 255,
256
uniformly productive 343, 351–354, 361, 362,
367, 379
universal 397, 398, 401
universal countable poset 393
Wadge class 110, 116, 127, 135
Wadge degree 119, 122, 134
winning strategy 117, 128, 129


