
Preface to Second Edition
The first edition of this book was appreciated by the students for its simplicity. The ~.'lr_~ ""~-'-'
maintains this feature along with inclusion of new tOfics and errors of previous edition
Every topic has been explained in depth without compromising over the lucidity of the tex
d pnlg:J~s.
This approach makes this book suitable for both novices and advanced programmers.
Developl)1ent of logic and familiarity with the syntax and features of the language are the two p- -
of excellent programming skills. The comprehensive contents of the chapters along with the num
example programs helps you to develop your logic in a stepwise manner and makes you feel comfo
with the syntax of the language. Remember that you can't learn swimming by just reading a book
how to swim, you have to jump into water for that, similarly if you want to learn programming, .
is essential for you to make your own programs. So start by understanding the programs given in the
book, work on them, modify them and see the results and try to make similar programs.
Each chapter is complemented by exercises with solutions that act as a review of the chapter. We strongly
recommend that you solve all the exercises before switching over to another topic. Exercises have been
structured in such a way that you can test and implement the knowledge acquired from the chapter,
and this is really important for getting full hold over a topic. We're sure if you understand the concepts,
you'll enjoy doing the exercises.
Our aim of writing this book is to, enable any student emerge as a full-fledged C programmer who can
withstand the challenges of the industry. This is the reason for inclusion of chapters on project building,
library development and code optimization.
'"
We are thankful to our family and friends for their love and support.
If you have any problems or
sugg~stions, please feel free to contact us at-
suresh_k_sri@yahoo.co.in
deepali_lko@yahoo.co.in
Suresh Kumar Srivastava
Deepali Srivastava
"

C in Depth
Preface to First Edition
Hello ! I am Suresh Kumar Srivastava. Firstly I want to tell you how the idea of writing a book on
'C' language came to my mind. When I was in 1st semester of 'B Level', C language was in my course.
I didn't know anything about computers. So at that time learning of 'C' language was very difficult
for me. I faced a lot of problems. After thorough studies o(many standard and authentic books in
'C', it became convenient for me to work in 'C'. Presently I am in a position to say that that I have
in-depth knowledge of 'c' and find myself in a position to help my juniors in making them comfortable
with 'C'. This idea inspired me to write a book which is easilyunderstandable by beginners and contains
all theoretical concepts and their implementation in programming.
v
I was alone in this work. I was the initiator, visualizer and accomplisher for this work.
I am very thankful to my elder brother_ Raju Bhaiya and sister Reena didi for their love and care for
me and my work. I am thankful to g1y friend Sh-'lilesh Raghuvanshi for proof reading of my book.
I am also thankful to Mr. Manish Jain and Mr. Anil Tyagi of BPB Publications for considering my work.
Suresh Kumar Srivastava

vi
Contents
1.
Introduction to C
1.1
Design Methods
1.1.1
Top-Down Design
1.1.2
Bottom-Up Design
1.1.3
Modular Approach
1.2
Programming Languages
1.2.1
Low Level Languages
1.2.1.1
Machine Level Language
1.2.1.2
Assembly Language
1.2.2 High-Level Languages
1.3
Translators
1.4
History Of C
1.5
Characteristics Of C
1.6
Structure Of A C Program
1.7
Environment For C
1.7.1
Unix Environment
1.7.2
MS-DOS Environment
1.7.2.1
Command Line
1.7.2.2
Integrated Development Environment
2.
Elements of C
2.1
C Character Set
2.1.1
Alphabets
2.1.2
Digits
2.1.3
Special characters
2.2
Execution Characters/Escape Sequences
2.3
Trigraph Characters
2.4
Delimiters
2.5
Reserved Words / Keywords
2.6
Identifiers
2.7
Data Types
2.8
Constants
2.8.1
Numeric Constants
2.8.1.1·
Integer constant
2.8.1.2
Real ( floating point) Constants
2.8.2
Character Constants
2.8.3
String Constants
C in Deptl;
1.:6
1
1
2
2
2
2'
2
2
3
3
3
4
4
5
5
5
5
'"
6
7-16
7
7
7
7
8
8
9
9
9
10
10
11
11
12
13
13


4.12
Type Conversion
4.12.1
Implicit Type Conversions
4.12.2
Automatic Conversions
4.12.3
Type Conversion In Assignment
4.12.4
Explicit Type Conversion Or Type Casting
4.13
Precedence And Associativity Of Operators
4.14
Role Of Parentheses In Evaluating Expressions
4.15
Order Of Evaluation Of Operands
Exercise
Programming Exercise
Answers
5.
Control Statements
5.1
Compound Statement' or Block
5.2
if...else
5.2.1
Nesting ofif...else'
5.2.2
else if Ladder
5.3
Loops
5.3.1
while loop
5.3.2
do...while loop
5.3.3
for loop
5.3.4
Nesting Of Loops
5.3.5
Infinite Loops
5.4
break statement
5.5
continue statement
5.6
goto
5.7
switch
5.8
Some Additional Problems
5.9
Pyramids
Exercise
Programming Exercise
Answers
6.
Functions
6.1
Advantages Of Using Functions
6.2
Library Functions
6.3
User-Defined Functions'
6.4
Fu.nction Definition
6.5
Function Call
6.6
Function Declaration
6.7
return statement
6.8
Function Arguments
6.9
Types Of Functions
6.9.1
Functions With No Arguments And No Return Value-
6.9.2
Function With No Arguments But A Return Value
6.9,3
Function With Arguments But No Return Value
-----.
C in Depth
44
44
44
45
46
47
50
53
53
56
56
58-109
58
59
6\
63
65
65
69
71
75
77
78
80
82
84
9Q
99
103
108
109
110-157
110
110
III
112
113
114
116
118
120
120
121
121

~ -
i;..
r
C in Depth
6.9.4
Function With Arguments And Return Value
6.10
More About Function Declaration
6.11
Declaration Of Functions With No Arguments
6.12
If Declaration Is Absent
6.13
Order Of Evaluation Of Function Arguments
6.14
main() Function
6.15
Library Functions
6.16
Old Style Of Function Declaration
6.17
Old Style Of Function Definition
6.18
Local, Global And Static Variables
6.18.1
Local Variables
6.18.2
Global Variables
6.18.3
Static Variables
6.19
Recursion
6.19.1
Tower Of Hanoi
6.19.2
Advantages And Disadvantages Of Recursion
6.19.3
Local Variables In Recursion
6.20
Some Additional Problems
Exercise
Programming Exercise
Answers
7.
Arrays
7.1
One Dimensional Array
7.1. 1
Declaration of 1-D Array
7:1.2
Accessing I-D Array Elements
7.1.3
Processing 1-D Arrays
7.1.4
Initialization of I-D Array
7.1.5
I-D Arrays And Functions
7.1.5.1
Passing Individual Array Elements to a Function
7.1.5.2
Passing whole 1-D Array to a Function.
7.2
Two Dimensional Array
7.2.1
Declaration and Accessing Individual Elements of a 2-D array
7.2.2
Processing 2-D Arrays
7.2.3
Initialization of 2-D Arrays
7.3
Arrays With More Than Two Dimensions
7.3.1
Multidimensional Array And Functions
7.4
Introduction To Strings
7.4.1
Input and output of strings
7.5
Some Additional Problems
Exercise
Programming Exercise
Answers
8.
Pointers
8.1
About Memory
ix
123
124
124
125
125
125
126
126
126
130
130
131
132
132
136
139
139
140
149
155
·156
158-195'
158
158
159
160
«.162
165
165
165
167
167
168
169
173
174
175
175
175
191
193
194
196-252
1%
;

x
8.2
Address Operator
8.3
Pointers Variables
8.3.1
Declaration Of Pointer Variables
8.3.2
Assigning Address To Pointer Variables
8.3.3
Dereferencing Pointer Variables
8.4
Pointer Arithmetic
8.5
Precedence Of Dereferencing Operator And Increment/Decrement Operators
8.6
Pointer Comp.arisons \
,
8.7
Pointer To Pointer
\
8.8
Pointers and One Dimensional Arrays
8.9
Subscripting Pointer Variables
8.10
:Rpinter to an Array
8.11
PbintersAnd Two Dimensional Arrays
8.12
Subscripting Pointer To An Array
8.13
Pointers And Three Dimensional Arrays
8.14
Pointers And Functions
8.15
Returning More Than One Value From A Function
8.16, Function Returning Pointer
8.17
Passing a 1-D Array to a Function
8.18
Passing a 2-D Array to a Function
8.19
Array Of Pointers
. 8.20
void Pointers
8.21
Dynamic Memory Allocation
8.21.1
malloc()
8.21.2
calloc()
8.21.3
realloc()
8.21.4 free()
8.21.5
Dynamic Arrays
8.22
Pointers To Functions
8.22.1
Dedaring A Pointer To A Function
8.22.2
Calling A Function Through Function Pointer
8.22.3
Passing a Function's Address as an Argument to Other Function
8.22.4 Using Arrays Of Function Pointers
Exercise
Answers
9.
Strings
\
9.1
String Constant or String Literal
9.2
String Variables
9.3
String Library Functidns
, 9.3.1
strlen()
9.3.2
strcmp()
9.3.3
st{'cpy()
9.3.4
strcat()
9.4
String Pointers
9.5
Array Of Strings Or Two Dimensional Array Of Characters
1,.,.'
C in Depth
197
197
198
198
199
201
204
206
206
208
211
212
213
216
·217
219
221
222
223'
225
227
229
231
131
233
233
234
235
238
239
240
240
242
244
251
253-287
253
255
257
2517
258
259
,/261
262
264
-

10.3
10.4
10.5
10.6
10.7
10.8
10.9
10.10
10.11
10.12
10.13
3
~
o
o
2
4
1
:7
53
55
57
5,7
58
59
61
.62
~64
C in D?[Jth
9.6
Array Of Pointers To Strings
9.7
sprintf()
9.8
sscanf()
9.9
Some Additional Problems
Exercise
Programming Exercise'
Answers
10. Structure And Union
10.1
Defining a Structure
10.2
Declaring Structure Variables
10.2.1
With Structure Definition
10.2.2
Using Structure Tag
Initialization Of Structure Variables
Accessing Member:s of a Structure
Assignment of Structure Variables
Storage of Structures in Memory
Size of Structure
Array of Structures
Arrays Within Structures
Nested Structures (Structure Within Structure)
Pointers to Structures
Pointers Within Structures
Structures And Functions
10. 13. 1
Passing Structure Members As Arguments
10.13.2
Passing Structure Variable As Argument
10.13.3
Passing Pointers To Structures As Arguments
10.13.4
Returning A Structure Variable From Function
10.13.5
Returning A Pointer To Structure From A Function
10.13.6
Passing Array Of Structures As Argument
10.14
Self Referential Structures
10.15
Linked List
10.15.1
Traversing a Linked List
10.15.2
Searching in a Linked List
10.15.3
Insertion into a Linked List
10.15.4
Insertion in the Beginning
10.15.5
Insertion in Between or at the end
10.15.6
Deletion From A Linked List
10.15.7
Deletion of First Node
10.15.8
Deletion of a Node in Between or at the End
10.15.9
Creation Of List
10.15. 10 Reversing A Linked List
10.16
union
10.17
typedef
Exercise
Programming Exercise
Answers
267
272
273
274
280
284
286
288-333'
288
289
289
289
290
290
292
292
293
293
295
296
298
299
299
299
300
301
<,
302
303
303
309
309
311
311
311
312
312
313
313
314
314
318·
321
326
329
332
332

11.4
11.5
11.6
11.7
11.8
11. Files
11".1
11.2
11.3
334-376
334
335
335
337
337
338
338
339
339
339
340
340
341
341
341
342
342
342
343
343
344
345
345
347
348
349
.. 350
351
362
362
363
364
364
364
365
365
366
366
366
367
367
368
374
375
376
C in Depth
Text And Binary Modes
Concept Of BufTer
Opening a File
11.3.1
Errors in Opening Files
Closing a File
End of File
Structure of a General File Program
Predefined File Pointers
Character I/O
11.8.1
fputc ( )
11.8.2
fgetc()
11.8.3
getc( ) and putc( )
11.9
Integer i/o
11.9.1
putw ( )
11.9.2
getw()
11.10 String I/O
11.10.1
fputs()
11.1 0.2
fgets()
11.11
Formatted I/O
11.11.1
fprintf ( )
11.11.2
fscanf ( )
11.12
Block Read / Write
11.12.1
fwrite()
11.12.2
fread()
11.13
Random Access To File
'11.13.1 . fseek ( )
11.13.2
ftelI()
11.13.3
rewind()
11.14
Other File Functions
11.14.1
feof()
11.14.'2
ferror()
11.14.3
c1earerr()
11.14.4
perror()
11.14.5
rename()
11.14.6
unlink()
11.14.7
remove()
11.14.8
fflush()
11.14.9
tmpfile()
11.14.10 tmpnam( )
11.14.11
freopen()
11.15
Conmland Line Arguments
11.16
Some Additional Problems
Exercise
Programming Exercise
Answers

I
l
l
l
5
5
5
6
6
7
7
8
4
5
6
C in Depth
12. The C Preprocessor
12.1
#define
12.2
Macros with Arguments
12.3
Nesting in Macros
12.4
Problems with Macros
12.5
Macros Vs Functions
12.6
Generic Functions
12.7
#undef
12.8
Stringizing Operator ( # )
12.9
Token Pasting Operator( ## )
12.10
Including Files
12.11
Conditional Compilation
12.11.1
#if And #endif
12.11.2
#else and #elif
12.11.3
de.fined Operator
12.11.4
#ifdef arid #ifndef
12.11.5
Writing Portable Code
12.11.6
Debugging
12.11.7
Commenting A Part Of Code
12.11.8
Other Uses of conditional compilation
12.12
PredefiI).ed· Macro Names
12.13
#line
12.14
#error
12.15
Null Directive
12.16
#pragma
12.17
How to see the code expanded by the Preprocessor
Exercise
Answers
13. Operations on Bits
13.1
Bitwise AND ( & )
13.2
Bitwise OR ( I )
13.3
Bitwise XOR (
1\
)
13.4
One's Complement ( ~ )
13.5
Bitwise Left Shift ( «
) .
13.6
Bitwise Right Shift ( »
)
13.7
Multiplication and Division by 2 using shift operators
13.8
Masking
13.8.1
Masking Using Bitwise AND
13.8.2
Masking Using Bitwise OR
13.8.3
Masking Using Bitwise XOR
13.8.4
Switching off Bits Using Bitwise AND and Complement Operator
13.9
Some additional Problems
13.10
Bit Fields
Exercise
Answers
xiii
377-406
3 8
379
381
382
385
386
387
387
388
389
389
390
390
393
393
395
396
397
397
·398
399
399
400
400
401
401
405
~
407-432
408
408
409
410
411
411
412
413
413
415
415
416
18
~_6
_9

14. Miscellaneous Features In C
14.1
Enumeration
14.2
Storage C1as~es
14.2.1
Automatic
14.2.2
External
14.2.3
Static
14.2.3.1
Local Static Variables
14.2.3.2
Global Static Variables
14.2.4
Register
14.3
Storage Classes in Functions
14.4
Linkage
14.5
Memory During Program Execution
14.6
const
14.7
volatile
14.8
Functions With Variable Number Of Arguments
14.8.1
Passing Variable Number of Arguments To Another Function
14.9
lvahie and rvalue
14.10
Compilation And Execution of C Programs
14.10.1
PreprocessoJ;
14.10.2.
Compiler
14.10.3
Assembler
14.10.4
Linker
.Exercise
Answers
15. Building project and, creation of library
15.1
Requirement Analysis
15.2
Top Level Design
15.3
Detail Design
15.4
Coding
15.4.1
Dtmanip.h
15.4.2
. Datefmt.c
15.4.3
Valid.c
15.4.4
Leap.c
15.4.5
Julian.c
15.4.6
Weekday.c
15.4.7
Cmpdate.c
15.4.8
Diffymd.c
15.4.9
Diffdays.c
15.4.10
Addyear.c
15.4.11
Subyear.c
15.4.12
Addmonth.c
15.4.13
Submonth.c
15.4.14
Adddays.c
15A15
Subdays.c
15:4.16
Main.c
C ill Depth
433-463
433
437
437
439
442
442
443
444
445
445
445
447
449
450
454
456
457
457
457
457
457
458'
463
464-486
464
465
~
465
468
468
469
469
470
470
471
472
472
473
474
474
475
475
476
·477
477

5
5
7
9
o
4
6
7
7 -
7
;7
i7
i8'
;3
16
54
55
55
58
68
69
69
70
70
71
72
72
73
·74
f74
~75
~75
~76
~77
P7
C in Depth
15.5
Building Project in Turbo C
15.6
Testing
15.7
Creation Of Library And Using it in your Program in Turbo C
15.7.1
Deletion of a Module From Library
15.7.2
Getting Modules From Library
15.7.3
Changing Version Of Module In Library
15.8
Building Project On Unix
15.8. ~
Writing Makefile
15.8.2
Building Project With Make
15.9
Creation Of Library And Using In Your Program in Unix
16. Code Optimization in C
16.1,
Optimization is a Technique
16.2
Optimization With Tool
16.3
Optimization With Loop
16.3,1
Loop Unrolling
16.3.2
Avoiding Calculations In Loops
16.4
Fast Mathem~tics
16.4.1
Avoid Unnecessary Integer Division
16.4.2
Multiplication And Division by Power Of 2
16.5
Simplifying Expressions
16.6
,Declare prototypes for Functions
16.7
Better Way Of Calling Function
16.8
Prefer int to char or short
16.9
Use of Register Variables
16.10
Opti~ization With Switch Statement
16.11
Avoid Pointer Dereference
16.12
Prefer Pre Increment/Decrement to Post Increment/Decrement
16.13
Prefer Array to Memory Allocation
16.14
Use Array Style Code Rather Than Pointer
16.15
Expression Order {,Jnderstanding
16.16
Declaration Of Local Function
16.17
Breaking Loop With Parallel Coding
16.18
Trick to use Common Expression
16.19
Declaring Local Variables Based On Size
16.20
Prefer Integer Comparison
16.21
Avoid String Comparison
. C and Assembly Interaction
17.1
Inline Assembly Language
17.2
Linking Of Two Assembly Files
17.2. 1
Memory Models
17.2.2
C And Segments in Library
17.3
Linking Assembly Procedure in C Program
xv
481
48'1
482
482
483
483
483
484
486
486
487-494
487
487
487
487
488
488
488
488
489
489
489
489
490
490
492
492 .
...
492
492
492
493
493
493
494
494
494
495-504
495
498
, 500
500
502
.
--
~--
-----

505-52:
50:
50:
50:
50:
50:
50:
50:
501
501
,SOl
501
501
501
501
501
50'
50'
50'
50'
50'
SO',
'§O'
SO',
50~
50~
501
501
501
SOl
501
501
501
501
SOl
SOl
505
505
505
50S
50S
50S
50S
SIC
SIC
SIC
C in Dept!.
18. Library Functions
18.1
Mathematical Functions
18.1.1abs( )
18.1.2
acos()
18.1.3
asin( )
18.1.4
atan()
18.1.5
atan2()
18.1.6
cabs()
18.1.7
ceil( )
18.1.8
cos()
18:1.9
cosh()
18.1.10
exp()
18.1.11
fabs( J
18.1.12
floor()
18.1.13
fmod()
18.1.14
frexpC)
18,1.15
Idexp()
18.1.16
log()
18.1.17
log10()
18.1.18
modf()
18.1.19
pow()
18.1.20
sin()
18.1.21
sinh()
18.1.22
sqrt()
18.1.23
tan()
18.1.24
tanh()
18.2
Character Type Functions
18.2.1
,isalnum()
18.2.2
isalpha( )
18.2.3
iscntrl( )
18.2.4
,isdigit( )
18.2.5
isgraph( )
18.2.6
islower( )
18.2.7
isprint( )
18.2.8
ispunct( )
18.2.9
isspace( )
18.2.10
isupper()
18.2.11
isxdigit( )
18.2.12
tolower()
18.2.13
toupper()
18.3
String Manipulation Functions
18.3.1
strcat( )
18.3.2
strchr( )
18.3.3
strcmp( )
18.3.4
strcpy()
18.3.5
strcspn()

7th
;21
505
505 .
505
505
505
505
505
506
506
,506
506
506
506
506
506
507
507
507
507
507
507
~07
507
507
507
508
508
508
508
508
508
508 .
508
508
508
509
509
509
509 .
509
509
509
510
510
-10
C in Depth
18.3.6
strlen()
18.3.7strncat( )
18.3.8
strncmp( )
18.3.9
strncpy( )
18.3.10
strpbrk()
18.3.11
strrchr()
18.3.12 . strspn( )
18.3.13
strstr()
18.4
Input/Output Functions
18.4.1
access()
18.4.2
chmod()
18.4.3
clearerr( )
18.4.4
close()
18.4.5
create )
18.4.6
fclose( )
18.4.7
feof()
18.4.8
ferror( )
18.4.9
fflush( )
18.4.10
fgetc()
18.4.11
fgets()
18.4.12
fileno()
18.4.13
fopen()
18.4.14
fprintf()
18.4.15
fplitc()
18.4.16
fputs()
_18.4.17
fread()
18.4.18
fputchar()
18.4.19
fscanf()
18.4.20
fseek()
18.4.21
fstat()
18.4.22
ftell()
18.4.23
isatty()
18.4.24
open()
18.4.25·
read()
18.4.26
remove()
18.4.27
rename()
18.4.28
setbuf()
18.4.29
sopen()
18.4.30
stat()
18.4.31
sprintf()
18.4.32
sscanf()
18.4.33
tell()
18.4.34
tmpfile()
18.4.35
tmpnam()
18.4.36
unlink( )
510
510
511
511
512
512
512
512
513
513
513
514
514
514 .
514
514
514
515
-515
515
515
515
515
516
516
.516
516
" 516
SIp
517
517
517
517
518 -
518
518
518
519
520
. 520
520
520
520
520
521

"
Chapter 1
Introduction to C
oftware is a collection of programs and a program is a collection of instructions given to the computer.
Development of software is a stepwise process. Before developing a software, number of processes
e done. The first step is to understand the user requirements. Problem analysis arises during the
requirement phase of software development. Problem analysis is done for obtaining the user requirements
and to determine the input and output of the program.
'=or solving the problem, an "algorithm" is implemented. Algorithm is a sequence of steps that gives
ethod of solving a problem. This "algoritnm" creates the logic of program. On the basis of this
-algorithm", program code is written. The steps before writing program .code are
as~
User requirements
Problem analysis
t
Input and Output
t
Designing algorithm
/
Program coding
Process of program development'
//
.1
Design Methods
:Jesigning is the first step for obtaining solution of a given problem. The purpose of designing is
~o
represent the solution for the system. It is really difficult to design a large system because the complexity
system cannot be represented easily. So variqus methods have been evolved for designing.
.1.1
Top-Down Design
.c:. 'ery system has several hierarchies of components. The top-level com~onent represents the whole
~ tern. Top-Down design method starts from top-level component to lowest level (bottom) component.
this design method, the system is divided into some major components.

1.2
Programming Languages
Then each major component is divided into lower level components. Similarly other components are
divided till the lowest level component.
Bottom-Up design method is the reverse ofTop-Down approach. It starts from the lowest level component
to the highest-level component. It first designs the basic components and from these basic components
the higher-level components are designed.
C ill Depth
Bottom-Up Design
Modular Approach
1.1.2
1.1.3
It is better to divide a large system into modules. In terms of programming, module is logically a well-
defined part of program. Each module is a separate part of the program. It is easy to modify a program
written with modular approach because changes in one module don't affect other modules of program.
It is also easy to check bugs in the program in module level programming.
Before learning any language, it is important to know about the various types of languages and their
features. It is interesting to know what were the basic requirements of the programmers and wha1
difficulties they faced with the existing languages. The programming languages can be classified into
two types-
1.
Low level languages
.
\
2.
HIgh level languages
The languages in this category are the Machine level language and Assembly language.
1.2.1.1
Machine Level Language
Computers can understand only digital signals, which are in binary digits i.e. 0 and 1. So the instructiom
given to the computer can be only in binary codes. The machine language consists of instructions thai
are in binary 0 or 1. Computers can understand only machine level language.
Writing a program in machine level language is a difficult task because it is not easy for programmen
to write instructions in binary code. A machine level language program is error-prone and its maintenancE
is very difficult. Furthennore ma.chine language programs are not portable. Every computer has its owr
n'1achine instructions, so the programs written for one computer are not valid for other computers.
1.2~.1.2
Assembly Language
The et~ifficulties faced in machine level language were reduced to some extent by using a modified fom
ofmacL'ine level language called assembly language. In assembly language instructions are given in Englist
like words, such as MOV, ADD, SUB etc. So it is easier to write and understand assembly programs,
Since a computer can understand only machine level language, hence assembly language program musl
be translated into machine language. The translator that is used for Itranslating is called "assembler"
Although writing programs in assembly language is a bit easier, but still the programmer has to knoVl
all the low level details related with the hardware of a computer. In assembly language, data is stored
in computer registers and each computer has different set of r~gisters. Hence the assembly languagE
program is also not portable. Since the low level languages are related with the hardware, hence thE
execution of a low-level program is faster.
.
1.2.1
Low Lev"el Languages

th
Introduction to C
3
lfe
1.2.2
High-Level Languages
ent
nts
High-level languages are designed keeping in mind the features of portability i.e. these languages are
machine independent. These are English like languages, so it is easy to write and understand the programs
of high-level language. While programming in a high level languag\e, the programmer is not concerned
with the low level details, and so the whole attention can be paid to the logic of the problem being
solved. For translating a high-level language program into machine language, compiler or interpreter is
used. Every language has its own compiler or interpreter. Some languages in this category are- FORTRAN,
COBOL, BASIC, Pascal etc.
We know that computers can understand only machine level language, which is in binary 1 or O. It
is difficult to write and maintain programs in machine level language. So the need arises for converting
the code of high-level and low-level languages into machine level language and translators are used for
this purpose. These translators are just computer programs, which accept a program written in high
level or low-level, language and produce an equivalent machine language program as output. The three
types of translators used are-
•
Assembler
•
Compiler
•
Interpreter'
Assembler is used for converting the code oflow-levellanguage (assembly language) into machine level
language.
Compilers and interpreters are used to convert the code of high-level language into machine language.
The high level program is known as source program and the corresponding rn~chine language program
is k~own ~~ obje~t prog~am. Although both complle;s and interPr~ters perform the ;ame task but the~e
is a' differerice in their working.
.
A compiler searches all the errors of program and lists them. If the program is error free then it converts
the code of program i~to machine cod~ and then the program can be executed by separate comlnands.
An interpreter checks the errors of program statement by statement. After checking one statement, it
converts that statement into machine erode and then executes that statement. This process continues
until the last statement of program or an erroneous statement occurs.
ell-
~am
am.
heir
That
into
IOns
that
ners
ance
own
ters.
1.3
1.4
Translators
History Of C
form
glish
ams.
must
ller".
mow
tored
~uage
e the'
In earlier days, every language was designed for some specific purpose. For example FORTRAN (Formula
Translator) was used for scientific and mathematical applications, COBOL (Common Business Oriented
Language) was used for business applications. So need of such a language was felt which could withstand
most of the purposes. "Necessity is the mother of invention". From here the first step towards C was
put forward by Dennis Ritchie.
The C lalfguage was developed in 1970's at Bell laboratories by Dennis Ritchie. Initially it was designed
for programming in the operating system called UNIX. After the advent of C, the whole UNIX operating
system was rewritten using it. Now almost tlvc entire UNIX operating system and the tools supplied
with it including the C compiler itself are written in C.
The C language is derived from the B language, which was written by Ken Thompson at AT&T Bell
laboratories. The B language was adopted from a language called BCPL (Basic Combined Programming
Language), which was developed by Martin Richards at Cambridge University.

1.5
Characteristics of C
local
variables
statements
local
variables
statements
C in Depth
Comments can be placed anywhere in a program and are enclosed qetween the delimiters /* at
*/.Comments are generally used for documentation purposes.
I
}
func2(
{
In 1982 a committee was formed by ANSI (American National Standards Institute) to standardize thl
C language. Finally in 1989, the standard for C language was introduced known as ANSI C. Generall~
most of the modern compilers conform to this standard.
Comments
Preprocessor
di'r'fctives
Global
variables \
main(
function\
{
local
variables
\tatements
}
funcl(
{
It is a middle level language. It has the simplicity of a high level language as well as the power of
low level language. This asp;ct of C makes it suitabl~ for writing both application' programs and systen
programs. Hence it is an excellent, efficient and general-purpose language for most of the application
I such as mathematical, scientific, business and system software applications.
C is small language, consisting of only 32 English words known as keywords (if, else, for, break etc.:
The power of C is augmen,ted by the library functions provided with it. Moreover, the langua'ge i
extendible since it allows the users to add their own library functions to the library.
\
C contains control constructs needed to write a structured program hence it is considered a structure
programming language. It includes structures for selection (if.. .else, switch), repetition (while, fo
do...while) and for loop exit\ (break).
.
.
The programs w~itten in C aile portable i.e. programs written for one type of computer or operatin
system can be run\on anothet type of computer or operating system.
1.6
StructJre of a C Program
,
C program is a colle\tion of one or more- functions. Every function is a collection of statements an
performs some specific task. The general structure of C program is-

Introduction to C
5
Preprocessor directives are processed through preprocessor before the C source code passes through
ompiler. The commoniy used preprocessor directives are #include and #define. #include is used for
including header files. #define is used to define symbolic constants and macros.
Every C program has one or more functions. If a program has only one function then it must be mainO..
Execution of every C program starts with maine ).function. It has two parts, declaration of local variables
and statements. The
~ci'pe of the local variable is local to that function only. Statements in the mainO
function are executed one by one. Other functions are the user-defined functions, which also have local
variables and C statements. They can be defined before or after maine ). It may be possible that some
ariables have to be used in many functions, so it is necessary to declare them globally. These variables
are called global variables.
1.7
Environment For C
The steps for the execution of C program are as-
1.
Program creation
2.
Program compilation
3.
Program execution
The C programs are written in :mostly two environments, UNIX and MS-DOS.
1.7.1
Unix Environment
Generally a command line C compiler is provided with the UNIX operating system. This compiler is
named cc or gcc,
(a) Program creation
In unix environment, file can be created with vi editor as-
$ vi filename.c
Here $ is the unix prompt. The file can be saved by pressing ESC and SHIFT+zz.
.
--
)
Program compilation
After creation of C program, it can be compiled as-
$cc filename.c
the program has mathematical function then it is compiled as-
$cc filename.c
-1m
After compilation, the executable code is stored in the file a.out .
)
Program execution
_\fier the compilation of program, it can be executed as-
$ a.out
.....
.7.2
MS-DOS Environment
- MS-DOS environment creation, compilation and execution can be done using command line or IDE
mtegrated Development Environment).
.7.2.1
Command Line
Borland C, the command line compiler is bcc.exe and in Turbo C the command line compiler is tcc.exe.

(a)
Program creation
The program file can be created using any editor and should be saved with .c extension.
(b)
Program compilation
After saving the file, C program Gan be compiled at DOS prompt by writing-
C:\>tcc
filen'ame
(in Turbo C)
C:\>bcc filename
(in Borland C)
(c)
Program execution
After compilation of C program, the executable file filename.exe is created. It is executed at DOS promp
by writing-
C:\>filename
1.7.2.2
Integrated Development Environment
All these steps can be performed in an IDE using menu options or shortcut keys. In Borland C thl
program bc.exe is the IDE and in Turbo C the program tC.exe is the IDE. So we can open the IDI
by typing bc or tc at the command prompt.
(a). Program creation
A new file can be created from menu optign New. The file can be saved by menu option Save. If th,
file is unnamed then it is savell by menu option Save as. An existing file can be opened from the mem
option Open.
(b)
Program. compilation
The file compiled by the menu option Compile. (Alt+F9)
(c)
Program execution
The file can be executed by the menu option Run. (Ctrl+F9). The output appears in the outp,ut windm
that can be seen using the keys Alt+F5.
.
We have' given you just a preliminary knowledge of how to execute your programs. There are seven;
other options that you can explore while working and it is best to check the manual of your compile
to know about these options.
6
C in Depth

pth
Chapter 2
Elements of C
Impt
~ the
IDE
Every language has some basic elements and grammatical rules. Before understanding programming,
- is must to know the basic elements of C language. These basic elements are character set, variables,
tatypes, constants, keywords (reserved words), variable declaration, expressions, statements etc. All
of these are l,lsed to construct a- C program.
.1
C Character Set
:fie c~aracters that are used in C programs are given below-
f the
.1.1
Alphabets
nenu
A, B, C
Z
a, b, c
z
Digits
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
"
Character
Meaning
Character
Meaning
+
plus
sign
-
minus sign(hyphen)
*
asterisk
%
percent
sign
\
Backward slash
/
forward slash
<
less than sign .
=
equal to sign
>
greater than sign
underscore
-
(
left parenthesis
)
right parenthesis
{
left braces
}
right braces
[
left bracket
]
right bracket
,
comma
period
,
single quotes
"
double quotes
:
colon
;
Semicolon
?
Question mark
!
Exclamation sign
&
ampersand
I
vertical bar
@
at the rate
A
caret sign
$
dollar sign
#
hash sign
-
tilde sign
,
back quotation mark
Idow
veral
tpiler
_.1.3
Special
characters

8
C in Depth
2.2
Execution Characters/Escape Sequences
. Characters are printed on the screen through the keyboard but some characters such as newline, tab,
. backspace cannot be printed like other normal characters. C supports the combination of backslash (\)
and some characters from the C character set to print these characters.
These. character combinations are known as escape sequences and are represented by two characters.
The first character is
"\" and second character is from the C character set. Some escape sequences
are given below-
Escape
Meaning
ASCII Value
Purpose
Sequence
\b
backspace
008
Moves the cursor to the previous position of the
current
line
\a
bellealert)
007
Produces a beep sound for alert
\r
carriage return-
013
Moves the cursor to beginning of the current line.·
\n
newline
010
Moves the cursor to the beginning of the next line
\f
form feed
012
Moves the cursor to the initial position of the next
logical page.
\0
.null
000
Null
\v
vertical tab
011
Moves the cursor to next vertical tab position
\t
Horizontal tab
009
Moves the cursor to the next horizontal tab position.
\\
backslash
092
Presents
a
character
with backslash ( \ )
Blank, horizontal tab, vertical tab, newline, carriage return, form feed are known as whitespace in (
language.
2.3
Trigraph
Characters
There is a possibility that the keyboard doesn't print some characters. C supports the facility of "trigrapJ
sequence" to print these characters. These trigraph 'sequences have three characters.. First two an
'??' and third character is any character from C character ·set. Some trigraph sequences are as give]
helow-
Trigraph Sequence
Symbol
??<
{ left
brace
17>
} right
brace
??(
[ left
bracket
??)
] right
bracket
??!
I vertical
bar
??/
\
backslash
??=
#
hash
slgn
??-
~
tilde
??'
/\
caret

Jth
Element of C
9
2.4
Delimiters
'.
( )
[ ]
{ }
#
tab,
(\)
ers.
ices
Delimiters are used for syntactic meaning in C. These are as given below-
colon
used for label
semicolon
end of statement
parentheses
used in expression
square brackets
used for array
curly braces
used for block of statements
hash
preprocessor directive
comma
variable delimiter
the
2.5
Reserved Words / Keywords
extern
if
return
static
umon
while
char
do
case
continue
default
else
enum
for
goto
long
register
signed
sizeof
switch
typedef
void
volatile
double
float
int
short
struct
unsigned
There are certain words that are reserved for doing specific tasks. These words are known as keywords
d they have standard, predefin~d meaning in C. They are always written in lowercase. There are only
_ keywords available in C which are given below-
auto .
break
const
in C
ne.
ine
lext
_.6
Identifiers
sraph
o are
given
the words that we'll use in our C programs will be either keywords or identifiers. Keywords are
_
defined and can't be changed by the user, while identifiers are user defined words and are used to
-' e names to entities like variables, arrays, fUi1ctions, structures etc. Rules for naming identifiers are
~. 'en below-
)
The name should consist of only alphabets (both upper and lower case), digits and underscore
sign( _ ).
_)
First character should be an alphabet or underscore.
)
The name should not be a keyword.
)
Since C is case sensitive, the uppercase and lowercase letters are considered different. For example
code, Code and CODE are three different identifiers.
:)
An identifier name may be arbitrarily long. Some implementations of C recognize only the first
eight characters, though most implementations recognize 31 characters. ANSI standard compilers
recognIze 31 characters.
_ e identifiers are generally given meaningful names. Some examples of valid identifier names-
Value
a
net-pay
rec1
data
MARKS
e examples of invalid identifier names are-

Constant is a vll1ue that cannot be changed during execution of the program. There are
three type1
of constants-
C supports different types of data. Storage representation of these data types is different in memory.
There are four fundamental datatypes in C, which are int, char, float and double..
'char' is used to store any single character, Oint' is used to store integer value, 'float'·is used for storing
single precision floating point number and 'double' is used for storing double precision floating point
number. We can use type qualifiers with these basic types to get some more types.
There are two types of type qualifiers-
1.
Size qualifiers
short, long
2.
Sign qualifiers
signed, unsigned
When the qualifier unsigned is used the number is always positive, and when signed is used number
may be positive or negative. If the sign qualifier is not mentioned, then by default signed qualifier is
assumed. The range of values for signed data types is less thantliat of unsigned type. This is because
in signed type, the leftmost bit is used to represent the sign, while in unsigned type this bit is also used
to represent the value.
The size and range of different data types on a 16-bit machine is given in the following table. The size
and range may vary on machines with different word sizes.
.
Basic data
Data types with
Size(bytes)
Range
types
type qualifiers
char
char or signed char
1
-128 to 127
unsigned char
1
o to 255 .
int
int or signed int
2
-32768 to 32767
unsigned int
2
o to 65535
short int or signed short int
1
-128 to 127
unsigned short int
1
o to 255
-lopg int or signed long int
4
-2147483648 to 214748,3647
unsigned long int
4
o to 4294967295
float
float
4
3.4E-38 to 3.4E+38
double
double
8
1.7E-308 to 1.7E+308
long double
10
3.4E-4932 to 1.1E+4932
C in Depth
First character should be an alphabet or underscore
int
is a keyword
# is a special character
blank space is not permitted
Constants'
5bc
int
rec#
avg no
2.7
Data Types
2.8
10

I
Hexadecimal
th
ry.
ng
int
::/ement of C
I
Decimal
I
Integer
consrant
Octal
I
Numeric
constant
I
I
Real
constant
Constants"
Character
constant
I
String
constant
11
Jer
. IS
JS~
;ed
ize
.8.1
Numeric Constants
_-mneric constants consist of numeric digits, they mayor may not have decimal pointe ", ). These are
- ~ rules for defining numeric constants-
Numeric constant should have at least one digit.
No comma or space is allowed within the numeric constant. "
Numeric constants can either be positive or negative but default sign is always positive.
~ ere are two types of numeric constants-
_.8.1.1
Integer constant
ger constants are whole numbers which have no decimal point ( . ). There are three types of integer
_ stants based on different number systems. The permissible characters that can be used in these
_ c::lstants are-
,47
Decimal constants -
0,1,2,3,4,5,6,7,8,9
Octal "constants -
0,1,2,3,4,5,6,7
Hex decimal constants -
0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,a,b,c,d,e,f
e valid decimal integer constants are-
°
123
3705
23759
e invalid decimal integer constants are-
Invalid
Remark
2.5
illegal
character ( . )
3#5
illegal character ( # )
98 5
No blank.space allowed
0925
First digit can not be zero
8,354
Comma is not allowed'
octal integer .constants; first digit must be 0. For example-
°
05
(base
10)
(base 8)
(base
1.6)
-~~--------'--------------~---~~._---

C in Depth
teger
~r a reai number, while the exponent can be only an integer (positive
the nlimber 1800000 can be written as 1.8e6, here 1.8 is mantissa and 6 is
exam les are as-
,
-
Number
Exponential form
2500000000
~
2.5* 109'
2.5e9
0.0000076
~
7.6*10.6
7.6e-6
-670000
~
-6.7* 105
-6.7E5
077
0324
By default the type of a floating point constant is double. We can explicitly mention lh'"
J
0
constant·
by suffixing it with a for F (for float type), I or L ( for long double). For ex
2.3e5
floating point constant of type double
2.4e-9l
or 2.4e-9L
floating point constant of type long double
3.52f
or 3.52F
floating point constant of type float
I
In hexadecimal integer constants, first two characters should.be Ox or OX. Some examples are as-
Ox
OX23
Ox515
OXA15B
OxFFF .
Oxac
By default the type of an integer constant is int. But if the value of integer constant exceeds the range
of values represented by int type, the type is taken to be unsigned int or long int. We can also explicitly
mention the type of the constant by suffixing it with I or L( for long), u or U (for unsigned), ul or
UL (for unsigned long). For example-
.
6453
Integer constant of type int
45238722UL
or
45238722uI
Integer constant of type unsigned long int
6655U
or
6655u
Integer constant of type unsigned int
2.8.1.2
Real (floating point) Constants
Floating point constants are numeric constants that contain decimal point. Some valid floating point
constants are-
0.5
5.3
4000.0
0.0073
5597.
/
39.0807
'/"
'
.
For expr.essin~ ver~ frge or ~ery small real constants, e~ponential (scientific) form is used. Here .the
number IS wntten Itt the mantissa and exponent form, WhICh are sep~e' or 'E'. The mantissa
can be an in
or negative).
For example
the exponent.
Some more
12

ent of C'
8.2
Character Constants
13
.-
haracter constant is a single character that is enclosed within single quotes. Some valid character
_
stants are-
'9'
'D'
'$'
, ,
'#'
e invalid character constants are-
Invalid·
Remark
'four'
There should be only one character within quotes
"d"
Double quotes are not allowed
"
No character between single quotes
y
Single quotes missing
:=: ery character constant has a uni,que integer value associated with it. This integer is the numeric value
~ the character in the machine's character code. If the machine is using ASCII (American Standard
ooe for Information Interchange), then the character 'G' represents integer value 71 and the character
- represents value 53. Some ASCII values are-
. A - Z
ASCII value ( 65 - 90 )
a - z
ASCII value ( 97 - 122 )
o- 9
ASCII value ( 48 - 57 )
ASCII value ( 59 )
CII values for all characters are given in Aypendix A.
_.8.3·
String Constants
tring constant has zero, one or more than one character. A string constant is enclosed within double
... otes (" "). At the end of string, \0 is 'automatically placed by the compiler.
".
me examples of string constants are-
"Kumar"
"593"
"8"
"A"
_-ote that "A" and 'A' are different, the first one is a string constant which consists of character A
and \0 while the second one is a character constant which represents integer value 65.
2.8.4
Symbolic Constants
If we want to use a constant several times then we can provide it a name. For example if we have
to use the constant·3.14159265 at many places in our program, then we can give it a name PI and
use this name instead' of writing the constant value everywhere. These types of constants are called
.symbolic constants or named constants.
A symbolic constant is a name that substitutes for a sequence of characters. The characters may represent
a numeric constant, a character constant or a string constant.
These constants are generally defined at the beginning of the program as-

#define name value
Here 'name' is the symbolic name for the constant, and is generally written in uppercase letters. 'value'
can be numeric, character or string constant.
Some examples of symbolic constants are as-
#define
MAX
100
#define
PI
3.14159625
#define
CH
'y'
#define
NAME
"Suresh"
In the program, these names will be replaced by the corresponding values. These symbolic constants
improve the readability and modifiability of the program.
2.9
Variables
14
C in Depth
Variable is a name that can be -used to store values. Variables can take different values but one at a
time. These values can b~ changed during execution of the program. A data type is associated with
each variable. The data type ofthe variable decides what values it can take. The rules for naming variables
are same as that for naming identifiers.
2.9.1
Declaration of Variabres
'
.
.
.
In the last declaration only variable total has been initialised.
When a variable is declared it contains undefined value commonly known as garbage value. If we want
we can assign some initial value to the variable during the declaration itself, this is called initialisation
of the variable. For example-
int a = 5;
float x = 8.9, Y = 10.5;
char ch = 'y';
double num = 0.15197e-7;
int 1, m, n, total = 0;
It is must to declare a variable before it is used in the program. Declaration of a variable specifies it&
name and datatype. The type and range of values that a variable can store depends upon its datatypej
The syntax of declaration of a variable is-
-
datatype variablename;
Here datatype may be int, float, char, double etc. Some examples of declaration of variables are-
int.x;
float salary;
char grade;
Here x is a variable of type int, salary is a variable of type float, and grade is a variab~e of type char.
We c~n also declare more than one variable in a single declaration. For example-
)
Illt x, y., z, total;
Here x, y, z, total are all variables of type int.
Initialisation of Variables
2.9.2

-
expression is a combination of operators, constants, variables and function calls. The expression
be arithmetic, logical or relationaL
--:
.
e examples are as-
x+y
- arithmetic operation
a =
b+c
- uses two operators ( =') and ( + )
a > b
- relational expression
'
a . b
- logical expression
func(a, b)
- function call
II study about these operators and expressions in the next chapter.
1
Statements
ent of C
_10
Expressions
15
j
x = y - z;
func( a , b );
ement that 'has only a semicolon is also known as null statement. For example-
.
/* null statement
>/</
_ C program, instruc.tions are written in the form of statements. A statement is an executable part
-
e program and causes the computer to carry out some action. Statements can be categorized as-
Expression statements
Compound statements
Selection statements (if, if. ..else, switch)
Iterative statements (for, while, do, ..while)
Jump statements ( goto, continue, break, return)
Label statements ( case, default, label statement used in goto )
.1
Expression Statement
sion statement consists of an expression followed by a semicolon. For example-
x = 5;
.2
Compound Statement
mpound statement consists of several statements enclosed within a pair of curly braces { }.
"'~:....l.ouund statement is also known as block of statements. Note that there is no semicolon after the
g brace. For example-
::'nt
1=4, b=2, h=3;
::'nt
area, volume;
area=2*(1*b+b~h+h*1);
olume=l*b*h;
.: variable is to be declared inside the block then it can be declared only at the beginning of the
The variables that are declared inside a block can be used only inside that block. All other categories
- ements are discussed in further chapters.

C in Depth
(single line comment)
(multiple line comment)
we can', write a comment inside ano,\comment
2 12
Comments
•
I
/
Comments are:used for increasing readability of the program. They explain the purpose of the program
and are helpful in understanding the program. Comments are written inside
/* and */. There can be
single line or multiple line comments. We can write comments anywhere in a program except inside
a string constant or a character constant.
Some examples of comments are-'
/*Variable b represents basic salary*/
/*This is a C program to calculate
simple interest
*1
Comments can't be nested i.e.
16

Chapter 3
Input-Output In C
are three main functions of any program- it takes data as input, processes
is data and gives
utput. The input operation involves movement of data from an input device (gen rally keyboard)
rnputer m~mory, while in output operation the data moves from computer memor
to the output
(generally screen). C language does not provide any facility for input-output operations. The input
t is performed through a set of library functions that are supplied with every C compiler. These
·ons are formally not a part of the language but they are considered standard for all input-output
ions in C. The set of library functions that performs input-output operations is known as standard
ibrary.
are several header files that provide necessary information in support ofthe various library functions.
~ header files are entered in the program using the #include directive at the beginning of the program.
example if a program uses any function from the standard I/O library, then it should include the
- r file stdio.h as-
.
=include<stdio.h>
ly there are other header files like math.h, string.h, alloc.h that should be included when certa.in
functions are used.
- chapter we'll discuss about the input functions scanf( ) and getchar( ) and the output functions
) and putchar( ). There are several other input-output functions that will be discussed in further
ers.
Ie method for taking the data as input is to give the value to the variables by assignment statement.
ample- .
- t basic = 2000;
ar ch = 'y';
this way we can give only particular data to the variabies.
ond method is to use the input function scanf( ), which takes the input data from the keyboard.
- method we can give any value to the variables at run time. For output, we use the function
):
Conversion Specifications
tions scanf( ) and printf( ) make use of conversion specifications to specify the type and size
Each conversion specification must begin witfi a percent sign ( % ). Some conversion specification
)ven below-
a single character
------ -----

C in Depth
(
\
%d
a decimal integer
%f
a floating point number
%e
a floating point number
%g
a floating point number
%If
long range of tloating point number (for double data
typ~)
%h
a short integer
%0
an octal integer
%x
a hexadecimal integer
%i
a decimal, octal or hexadecimal integer
%s
a string
%u
an unsigned decimal integer
The modifier h can be used before conversion specifications d, i, 0, u, x to specify short integer and
the modifier I can be used before them to specify a long integer. The modifier I can be used before
conversion specifications f, e, g to specify double while modifier L can be used before them to specify
a long double. For example %Id, %hd, %Lf, %hx are valid conversion specifications.
18
3.2
Reading Input Data
Input data can be entered into the memo!)' from a standard input device (keyboard). C provides the
scanf( ) library function for entering input data. This function can take all types of values (numeric,
character, string) as input. The scanf( ) function can be written as-
scanf( "control string" , address I, address2, ....);
This function should have at least two parameters. First parameter is a control string, which contains
eonversion specification characters. It should be within double quotes. The conversion specification
characters may be one or more; it depends on the number of variables we want to input. The othel
parameters are addresses of variables. In the scanf( ) function at least one address should qe present
The address of a variable is found by preceding the variable name by an ampersand (&) sign. Thi!
sign is called the address operator and it gives the starting address of the variable name in memory
A string variable is not preceded by & sign to get .the address.
Some examples of scanf( ) function are as-
#include<stdio.h>
main (
)
{
int
marks;
scanf("%d",&marks) ;
In this example, the control string contains only one conversion specification character %d, which implie
that one integer value should be entered as input. This entered value will be stored in the variable mark~
#include<stdio.h>
main (
)
{
char
ch;

Input-Output in C
scanf("%c",&ch)~
19
ere the control string contains conversion specification
Charac~r %c, which means that a single
aracter should be entered as input. This entered value will be
tored in the variable ch.
.
=':'nclude<s ~
.
-"'in (
float
height;
scanf("%f",&height) ;
-ere the control string contains the conversion specili'-
int number should be entered as input. This entered Vale,
=':'~clude<stdio.h>
=:.=.':'n (
)
char
str[30]
scanf("%s",str) ;
which means that a floating
ired In the variable, height.
:s
- this example control string has conversion specification character %s implying that a string should
taken as input. Note that the variable str is not preceded by ampersand(&) sign. The entered string
-II be stored in the variable str.
ore than one value can also be entered by single scanf( ) function. For example-
=~~clude<stdio.h>,
-;::' n (
int
basic,da;
scanf("%d%d",&basic,&da);
the control string has two conversion specification characters implying that two integer values
uld be entered. These yalues are stored in the variables basic and~da. The data can be ent,ereo with
_- e as the delimiter as-
.
1500 1200
~~=clude<stdio.h>
;:::n (
int
basic;
f loa t
. bra;

Here the control string has three conversi9n specifications characters %d, %f and %c means that on
integer value, one floating point value and one single characterLcan be entered as input. These value
are stored in the variables,basic, hra and grade. The input data can be entered as-
1500 200.50 A
When more than one values are input by scanf( ), these values can be separated by whitespace charactel
like space, tab or newline (default). A specific character can also be placed between two conversio
specification characters as a delimiter.
20
char
grade;
scanf ("%d . %f
%c", &basic, &hra, &grade);
C in Depth
~include<stdio.h>
main(
(
irrt
basic;
float
hra;
scanf("%d:%f",&basic,&hra) ;
Here the delimiter is colon (
). The input data can be entered as-
1500:200.50
The value 1500 is stored in variable basic and 200.50 is stored in hra.
#include<stdio.h>
main(
(
int
basic;
float
hra;
Scanf("%d,%f",&basic,&hra) ;
Here the delimiter is comma ( , ). The input data can be entered as-
1500, 200.40
#include<stdio.h>
main(
int
day,mOn1"h,year;
int
basic;
scanf("%d-%d-%d",&day,&month,&year) ;
scanf (" $ %d", &basic) ;

Input-Output in C
Here if the data is entered as-
21
24-5-1973
$3000
Then 24 is stored in var..~ble day, 5 is stored in variable month and 1973 is stored in variable year and
3000 is stored in variable basic.
If we include any spaces between the C'onversion specifications inside the control string, then they are
just ignored.
-include<stdio.h>
ain(
int
x,y,z;
scanf("%d
%d
%d",&x,&y,&z);
If the data is entered as-
12 34 56
Then 12 is stored in x, 34 is stored in y and 56 is stored in z.
3.3
Writing Output Data
Output data can be written from computer memory to the standard output device (monitor) uSIng printfO
library function. With this function all type of values (numeric, character or string) can be written as
output. The printf( ) function can be written as-
printf("control string", variable 1, variable 2,
);
In this function the control string contains conversion specification characters and text. It should be
enclosed within'double quotes. The name of variables snould not be preceded by an ampersand(&) sign.
I the control string does not contain any conversion specification, then the variable names are not
-pecified. Some example of printf( ) function are as-
=lnclude<stdio.h>
=:ain (
printf ("C
is
excellent\n");
Output:
C is excellent
ere control string has only text and no conversion specification character, hence the o,utput is only
- xt.
=:nclude<stdio.h>
-ain(
int
age;
printf("Enter
your
age
");
scanf("%d",&age) ;

int
ba.sic=2000;
char
ch='$';
char
str[30];
C in Depth
#include<stdio.h>
main (
)
Here control string has conversion specification character %s, implying that a string will be displaye
and. variable name str is a character array, holding the string which will be displayed.
printf("%sH,str) ;
#include<stdio.h>
main (
)
{
printf("%c",ch) ;
#include<stdio.h>
main (
)
(
Here control string has conversion specification character %f, which means that floating point numbe
will be displayed. The variable height has that floating point value which will be displayed as outpu1
In the above example, the control string has conversion specification character %c, means that a singl
character will be displayed and variable ch has that character value.
fl0at
height=5.6;
printf("%fH,height);
In this example control string contains a conversion specification character %d, which implies that ar
integer value will be displayed. The variable basic has that integer value which will be displayed as output
printf("%dH,basic) ;
#include<stdio.h>
main (
)
{
Here also printf does not contain any conversion specification character and.is used to display a message
that tells the user to enter his age.
#include<stdio.h>
main (
)
{
22

Input-Output in C
int
basic=2 000;
printf ("Basic
Salary
%d",basic) ;
23
}
Output:
Basic Salary = 2000
Here the control string contains text with conversion specification character %d. The text will be displayed
as it is, and the value of variable basic will be displayed in place of %d.
-include<stdip.h>
ain (
{
int
b=l500;.
float
h=200.50;·
char
g= 'A' ;
printf~"Basic
%d,
HRA
%f
Grade
%c",b,h,g) ;
}
Output:
Basic = 1500 , HRA = 200.500000 , Grade =' A
Here control string contains text with three conversion specification characters %d, %f and %c. %d
r
.
for integer value, %fis for floating point 'number and %c is for a single character.
-
t.
=include<stdio.h>
ain(
int
num=lO;
printf ("Octal
equivalent
of
decimal
%d
%0" , n urn, n urn) ;
Output:
Octal equivalent of decimal 10 = 12
Ie
rIere the second conversion specification character is %0 hence the octal equivalent of the decimal number
ored in the variable num is displayed.
=include<stdio.h>
:=ain(
int
num=lO;
printf ("Hex
equivalent
of
decimal
%d
%x", num, num) ;
Output:
~d
Hex equivalent of decimal 10 = A
Here the second conversion specification character is % x hence the hexadecimal equivalent of the decimal
umber stored in the variable num is displayed.
chapter 2 we had studied about escape sequences. Here we'll see how we can use them in the printf
-tatement. The-most commonly used escape sequences used are '\n' and '\1'.

3.4
}:formatted Input And Output
%wd
Here 'd' is the conversion specification character for integer value and 'w' is an integer number specifying
Formatted input and output means Jhat data is entered and displayed in a particular format. Through
format specifications, better presentation of result can be obtained. Formats for different specifications
are as-
C in Depth
9 \ 11 \ 1978
She said, "I have to go".
%c\n",b,h,g) ;
%c\n",b,h,g);
will print
will print
Grade = A
%f\nGrade
HRA = 200.500000
Format For Integer Input
\
printf("9 \\ I I \\ 1978");
inlt
b=1500;
float
h=200.50;
char
g='A';
printf ("Basic
%d\tHRA
=' %f\tGrade
printf("She said, \"1 have to go\". ");
int,
b=1500
flo\p.t
h=200. 50
cha~
g='A';
printf("Basic
%d\nHRA
}
Output:
Basic = 1500
'\t' moves the cursor to the next tab stop. Similarly we can use other escape sequences also. For example
'\b' moves the cursor one position back, '\r' moves the cursor to the beginning of the current line
and '\a' alerts the user by a beep sound. '\v' moves the cursor to the next vertical tab position(first
column of the next line), and '\f' move the cursor to the'next page. '\v' and '\f' are effective only
when output is printed through a printer.
If we want to print characters like single quotes ( , ),double quotes ( " ) or the backslash charcter
( \ ), then we have to precede them by a backslash character in the format string.
For example-
3.4.1
#includ~<stdio.h>
main (
!
)1
{
}
Output:
Basic = .1500
HRA
~. 200.500000
Grn~~JA
. '
'\n; moves he cursor to the beginning of next line. Here we have placed a '\n' at the end of control
string also, it ensures that the output of the next program starts at a new line.
'
#include<stdio.h>
main (I
)
{
24

Input-Output in C
25
the ,maximum field width of input data. If the length of input is more than this maximum field width
then the values are not stored correctly. For example-
scanf ("%2d%3d", &a, &b );
(i)
When input data length is less than the given field width, then the input values are unaltered and
stored in given variables.
Input-
6 39
Result-
6 is stored in a and 39 is stored in b.
(ii)
When input data length is equal to the given 'field width, then the input values are unaltered and
stored in
giv~n variables.
Input-
26 394
Result-
26 is stored in a and 394 is stored in b.
(iii)
When input data length is more than the given field width, then the input values are altered and
stored in the variable as -
Input-
269 3845
Result-
26 is stored in a and 9 is stored in b and the rest of input is ignored.
3.4.2
Format For Integer Output
%wd
Here w is the, integer number specifying the minimum field width of the output data. If the length of '
the variable is less than the specified field width, then the variable is right jl~titied with leadin'g blanks.
For example -
printf("a=%3d, b=%4d", a, b );
/
(i)
When the length of variable is less than the width specifier.
Value of variables-
789
Output:
,
The width specifier of first data is 3 while there are only 2 digits in it, so there is one leading blank.
The width specifier of second data is 4 while there is only 1 digit, so there are 3 leading blanks.
(ii)
When the length of the variable is equal to the width specifier
Value of variables-
263 1941

26
Output:
C in Depth
%d\n",a,b,c) ;
\nc
=
%4d\n",a,b,c);
.1
(iii)
When length of variable is more than the width specifier, then also the output is printed correctly.
Value of variables-
2691 19412
Output:
#include<stdio.h>
main (
)
int
a=4000,b=200, c=15;
printf ("a
=
%d
\nb.
=
%d
\nc
printf("%a
=
%4d
\n%b
%4d
}
The output of the first printf would be-
a = 4000 .
b = 200
c = 15
while the output of second printf would be-
a = 4000
b =
200
c =
15
3.4.3
Format For Floating Point Numeric Input
%wf
Here 'w' is the integer number specifying the total width of the input data (including the digits before
and after decimal and the decimal itself). For example-
scanf("%~f %4f ", &x, &y);
(i)
When input data length is less than the given width, values are unaltered and stored in the variables.
Input
5
5.9
Result
5.0 is stored in x and 5.90 is stored iny.
(ii)
When input data length is equal to the given width, then the given values are unaltered and stored
in the given variables.
Input
5.3 5.92

'Put-Output in C
27
Result
5.3 is stored in x and 5.92 is stored in y
Iii)
When input data length is more than the given width then the given values are altered and stored
in the given variables as-
put
5.93 65.87
esult
5.9 is storpc
1 in x and 3.00 is stored in y.
.4.4
Format For Floating Point Numeric Output
w.of
ere w is the integer number specifying the total width of the input data and n is the number of digits
-
be printed after decimal point. By default 6 digits are printed after the decimal. For examp!e-
printf("x = %4.1f, y = %7.2f ", x, y);
=the total length of the variable is less than the specified width 'w', then the value is right justified
.
leading blanks. If the number of digits after decimal is more than 'n' then the digits are rounded
- Iue of variables-
8
5.9
utput:
ue of variables-
25.3
1635.92
tput:
- ue of variables
15.231
ut:
65.875948
__ .5
Format For String Input
ws
-
e w specifies the total number of characters that will be stored in the string.
char str [8] ;
scanf ("%3s", str );

C in Depth
If the input is-
Srivastava
only first three characters of this input will be stored in the string, so the characters in the string will
be-
'S', 'r', 'i', '\0'
The null character('\O') is automatically stored at the end.
3.4.6
O/ow.ns
Format For String Output
Here w is the specified field width. Decimal point and 'n' are optional. If present then 'n' specifies
that only first n characters of the string will be displayed and (w - n) leading blanks are displayed before
string.
(i)
printf("%3s", "sureshkumar" );
(ii)
printt{"% IOs"; "reeta");
(iii)
printf("%.3s", "sureshkumar " );
(iv)
printf("% 8.3s", "sureshkumar ");
(8 - 3 = 5 leading blanks)
3.5
Suppression Character in scanf( )
If we want to skip any input field then we specify * between the % sign and the conversion specification.
The input field is read but its value is not assigned to any address. This character * is called the sup-pression
character. For example-
scanf ("%d %*d %d", &a, &b, &c);
Input:
25 30 35
Here 25 is stored in 'a' , 30 is skipped and 35 is stored in the 'b'. Since no data is available for 'c'
so it has garbage value.
scanf("%d %*c %d %*c %d", &d, &m, &y);
Input:
.
31\/2003
Here 3 will be stored in d, then / will be skipped, 11 will be stored in m, again i will be skipped and
finally 2003' will be stored in y.
#include<stdio.h>
main (
)
int
a,b,c;
printf("'Enter
three
numbers
:");

rput-Outputin C
scanf("%d
%*d
%d",&a,&b,&c);
priiltf("%d
%d
%d",a,b,c);'
tput:
::- ter three numbers : 25 30 35
25 35 25381
variable c has garbage value.
29
.6
Character I/O
..1
getchar ( ) and putchar( )
e macros getcharO ,!nd putchar( ) can be used for character lIO. getchar( ) reads a single character
-
m the standard input. putchar( ) outputs one character at a time to the standard output.
=~_clude<stdio.h>
=:'n (
)
char
Chi
printf ("Enter
a
character
");
ch=getchar() ;
printf ("The
entered
character
is
");
putchar(ch) ;
ut:
- - r a character : B
'" entered character is : B
Exercise
- me stdio.h is included in all programs.
"define
MSSG
"Hello
World\n"
main ( )
{
printf(MSSG) ;
_
main (
{
printf("Indian\b
is
great\n");
printf("New\rDelhi\n") ;
(3) main (
(
int
a=l1;
priutf("a
printf("a.
printf("a
%d\t",a) ;
%o\t",a) ;
%x\n",a) ;

main (
{
main ( \
{
main ( )
{
C in Depth
%u\n",a,b) ;
b=50000;
%d,
b
=
int
a=5·0000;
unsigned
int
printf("a
int
a=98;
char
ch=' c' ;
printf("%c,
%d\n",a,ch);
float
al,bl,a2,b2,a3,b3;
al=2;
bl=6.8;
a2=4.2;
b2=3.57;
a3=9.82;
b3=85.673;
printf("%3.1f,%4.2f\n",al,bl) ;
printf("%5.1f,%6.2f\n",a2,b2) ;
print~("%7.1f,%8.2f\n",a3,b3) ;
float
D=123. 1265;
printf("%f\t",b) ;
printf("%.2f\t",b) ;
printf("%.3f\n",b) ;
int
a=625,b=2394,c=12345;
printf("%5d,
%5d,
%5d\n",a,b,c);
printf("%3d,
%4d,
%5d\n",a,b,c);
char
Chi
printf("Enter
a
character:");
scanf("%c",&ch);
printf("%d\n",ch) ;
main(
{
main(
{
main ( )
{

Input-Output in C
31
, .
(lO)main( )
(
printf("%10s\nU,"India U) ;
printf("%4s\n U,"India U) ;
printf(".2s\n U,"India U) ;
printf("%5.2s\n U,"India U) ;
Answers
/
625,
2394, 12345
625, 2394, 12345
a == -15536, b==50000
/
/
The value 50000 is outside the range of int data type.
)
This program enters a character and prints its ASCII value.
)
123.126503 123.13 123.127
-)
Hello World
India'is great .
Delhi
\b takes the cursor to the previous position of current line, \r takes the cursor to the beginning
of current line, \n takes the cursor to the beginning of next/line.
3) a==lla==13a==b/
)
(I)
( )
b, 99·
2.0,6.80
4.2,
3.57
9.8,
85.67
0)
~Pl! iilndia
India
In
In

Chapter 4
Operators find Expressions
An operator specifies an operation to be performed that yields a value. The variables, constants can
be joined by various operators to form an
e~pression. An operand is a data item on which an operator
acts. Some operators require two operands, while others act upon only one operand. C includes a large
number of operators that fall under several different categories, which are as-
1.
Arithmetic operators
2.
Assignment operators .
3.
Increment and Decrement operators
4.
Relationaloperators.
5.
Logical operators
6.
Conditional operator
7.
Comma operator
8.
sizeof operator
9.
Bitwise operators
10.
Other operators
4.1
Arithmetic Operators
Arithmetic operators are used for numeric calculations. They are of two types -
. 1.
Unary arithmetic operators
2.
Binary arithmetic operators
4.1.1
Unary Arithmetic Operators
Unary operators require only one operand. For example-
+x
-y
Here '-' changes the sign of the operand y.
4.1.2.
Binary Arithmetic Operators
Binary operators require two operands. There are five binary arithmetic operators-

Operators and Expressions
Operator
Purpose
+
addition
-
subtraction
*
multiplication
/
division
%
gives the remainder in integer division
33
% (modulus operator) cannot be applied with floating point operands. There is no exponent operator
in C. However there is a library function pow( ) to carry out exponentiation operation.
_ ote that unary plus and unary minus operators are different from the addition and subtraction operators.
4.2
Integer Arithmetic
When both operands are integers then the arithmetic operation with these operands is called integer
arithmetic and the resulting value is always an integer. Let us take two variables a and b. The value'
of a = 17 and b = 4, the results of the following operations are-
Expression
Result
a+b
21
a-b
13'
a*b
68
alb
4 (decimal part truncates)
a%b
1 (Remainder after integer division)
After division operation the decimal part will be truncated and result is only integer part of quotient.
After modulus operation the result will be remainder part of integer division. The second operand"must
be nonzero for division and modulus operations.
/
/*P4.1
Program
to
understand
the
integer
arithmetic
operation* /
~include<stdio.h>
ain (
)
{
int
a=17,b=4;
p r i n t f ( " Sum
=
%d \ n" , a +b) ;
ptintf("Difference
=
%d\n",a-b);
printf ("Product
=
%d\n", a*b);
printf("Quotient
=
%d\n",a/b);
printf ("Remainder
=
%d\n", a%b) ;
}
/
Output:
Sum = 21
Difference = 13
Product = 68
Quotient = 4
Remainder =

34
C in Depth
4.3
Floating-Point Arithmetic
When both operands are of float type then the arithmetic operation with these operands is called floaring-
point arithmetic: Let us take two variables a and b. The value of a = 12.4 and b = 3.1
the
result~
of the following operations are as-
Expression
Result
--
a+b
15.5
a-b
9.3
a*b
38.44
a I b
4.0
The modulus operator % cannot be used with floating point numbers.
/*P4.2
Program
to
ul)derstand
the
floating
point
arithmetic
oper<:ltion
*
#include<stdio.h>
main
(
)
float
a=12.4,b=3.8;
p r i n t f ( " Sum
=
%. 2 f \ n" , a +b) ;
printf ("Difference
=
%.2f\n", a-b) ;
printf ("Product
=
%. 2f\n" , a *b) ;
printf("a/b.~
%.2f\n",a/b);
}
Output
_Sum = 16.20
Difference = 8.60
Product = 47.12
alb
= 3.26
4.4
Mixed Mode Arithmetic
When one operand is of integer type and the other is of floating type then the arithmetic operation wi1
these operands is known as mixed mode arithmetic and the resulting value is float type.
If a = 12, b = 2.5
Expression
Result
a+b
14.5
a-b
9.5
I
a*b
30.0
a I b
4.8
\
I
i
Sometimes mixed mode arithmetic can help in getting exact results. For exm'nple the result of expressi<
5/2 will be 2, since integer arithmetic is applied. If we want exact result we can make one of the operan
float type. For example 5.0/2 or 5/2.0, both will give result 2.5.

Operators and Expressions
.5
Assignment
Op~rators
35
.-\ value can be stored in a variable with the use of assignment operator. This assignment operator "
=
", is used in assignment expressions and assignment statements.
e operand on the left hand side should be a variable, while the operand on the right hand side can
any variable, constant or expression. The value of righ~ hand operand is assigned to the left hand
perand. Here are some examples of assignment expressions-
x = 8
/*
8 is assigned to x*/
y = 5
/*
5 is assigned to y*/
s = x+y-2
/*
Value of expression x+y-2
is assigned to s*/
y = x
/*
Value of x is assigned to y*/
x = y
/*
Value of y is assigned to x*/
The value that is being assigned is considered as value of the assignment ex·pression. For example
= 8 is an assignment expression whose value is 8.
Ie can have multiple assignment expressions also, for example-
x = y = z = 20
Here all the three variables x, y, t will be assigned value 20, and the value of the whole expression
'ill be 20.
If we put a semicolon after the assignment expression then it becomes an assignment statement.
For example these are assignment statements-
x = 8;
y = 5;
s = x+y-2;
x = y = z = 20;
hen the variable on the left hand side of assignment operator also occurs on right hand side"'then
e can avoid writing the variable twice by using compound assignment operators. For example-
x = x + 5
'1
can also be writt-en as-
x += 5
n
,s
.
Here += is a compound assignment operator.
Similarly we have other compound assignment operators-
x -=5
is equivalent to
x = x - 5
y*=5
is equivalent to
y = y* 5
surTI·/=5
is equivalent to
sum = sum / 5
k%= 5
is equivalent to
k = k % 5
4.6
Increment And Decrement Operators
C has two useful operators increment ( ++ ) and decrement ( - - ). These are unary operators because
they operate on a single operand. The increment iperator ( ++ ) increments the value of the variable
by 1 and decrement operator ( - - ) decrements the value of the variable by 1.

C in Depth
++x
is equivalent to
x = x + 1
- -x
is equivalent to
x = x-I
These operators should be used only with variables; they can't be used with constants or expressions.
For example the expressions ++5 or ++(x+y+z) are invalid.
These operators are of two types-
1.
Prefix increment / decrement - operator is written before the operand (e.g. ++x or - -x )
2.
Postfix increment / decrement - operator is written after the operand
(e.g. x++ or x - - )
4.6..1
Prefix Increment / Decrement
/*P4.3
Program
to
understand
the
use
of
prefix
increment
/
decrement
*
#include<stdio.h>
main( )
{
Here first the value of variable' is incremented / decremented then the new value is used in the operation
Let us take a variable x whose value is 3.
The statement y = ++x; means first incremenf the value of x by 1, then assign the value of x to y
This single statement is -equivalent to these two statements-
x = x+l;
Y = x;
Hence now value of x is 4 and value of y is 4.
The statement y = - -x ; means first decrement the value of x by 1 then assign the value of x to )
This statement is equivalent to these two' statements.
x =
x~l;
Y = x;
Hence now value of x is 3 and value of y is 3.
int
x=8;
printf("x
printf ("x
printf ("x
printf ("x
printf ("x
%d\t",x);
%d\t",++x);
/*prefix
increment*/
%d\ t" ,x) ;.
%d\t", - --x);
/*prefix
decrement*/
%d\n",x);
}
Output:
x = 8
x = 9
x = 9
x = 8
x = 8
In the second printf statement, first the value of x is incremented and then printed; similarly in the fOUl
printf statement first the value of x is decremented and then printed.
4.6.2
Postfix Increment / Decrement
Here first the value of variable is used in the operation and then increment/decrement is perform<
Let us take a variable whose value is 3.
The statement y = x++; means first the value of x is assigned to y and then x is incremented. T
statement is equivalent to these two statements-

Operators and Expressions
37
y = x;
x = x+I;
Hence now value of x is 4 and value of y is 3.
The statement y = x- -; means first the value ofx is assigned to y and then x is decremented.
This statement is equivalent to these two statements-
.
y = x;
x = x-I;
Hence now value of x is 3 and value of y is 4.
*P4.4
Program· to
understand' the
use
of
postfix
i Tlcrement/decrement* /
:include<stdio.h>
ain ( )
{
int
x:8;
printf("x
printf ("x
printf("x
printf("x
printf ("x
%d\n" ,x) ;
%d\t",x++);
/*postfix
increment*/
%d\t",x);
%d\t" ,;.- -);
/*postfix
decrement*/
%d\n" ,x) ;
}
Output:
x = 8
x = 8
x
= 9
x = 9
x = 8
h
:i.
15
the second printf statement, first the value of x is printed and then incremented; similarly in the fourth
rintf statement first the value of x is printed and then decremented.
.7
Relational Operators
elational operators are used to compare values of two expressions depending on their relations. An
expression that contains relational operators is called relational expression. If the relation is true "then
e value of relational expression is 1 and if the relation is false then the value of expression is O. The
lational operators are-
Operator
Meaning
<
less. than
<=
less than or equal to
-
-
. equal to
!=
Not equal to
>
Greater than'
>=
Greater than or equal to
_et us tak.e· two variables a = 9 and b = 5, and form simple relational expressions with them-

C in Depth
Expression
Relation
Value of Expression
a < b
False
0
a <= b
False
0
a= =b
False
0
a != b
True
1
a>b
True
1
a >= b
True
1
a==O
False
0
b!=O
True
1
. a>8
True
1
2> 4
False
0
The relational operators are gene~IY used in if.. .else construct and loops. In our next program we'll
use the if statement tomustrate the use of relational operators. The if control statement evaluates an
expression, and if this exp-res~ is true(non zero) then the next statement is executed, otherwise the
~ext st.atement is ~kipped. .Jhe details ~f if statement are discussed in chapter 5. ·Here we have used
It to gIve you an Idea of how the relatIOnal operators are used.
/*P4.5
Program
to
understand
the
use
of
relational
operators* /
#include<stdio.h>
main(
int
a,b;
printf ("Enter
values
for
a
and
b
") ;
scanf("%d%d",&a,&b) ;
if(a<b)
printf ("%d
is/less
than
%d\n", a, b) ;
if(a<=b)
;/
printf ("%d
is
less
than
or
equal
to
%d\n", a/ b) ;
if (a==b)
printf("%d
is
e/qual
to
%d\n",a,bY;
if(a!=b)
/
printf("%d
lS
not
equal
to
%'d\n",a,b);
if(a>b)
printf("%d
is
greater
than
%d\n",a,b);
if (a>=b)
printf("%d
is
great&f"
than
or
equal
to
%d\n",a,b);
}
Output:
Enter values
fo~ a anfr1>
12
7
12 is not equal to 7
.
12 is greater than 7
12 is greater than or equal to 7
It is important to note that the assignment operator(=) and equality operator(= =) are entirely differe
Assignment operator is used for assigning values while equality operator is used to compare t

Operators and Expressions
39
"xpressions. Beginners generally confuse between the two and use one in the place of another, and this
eads to an error difficult to find out. For example if in the above program we use '='instead of '=
= , then we'll get wrong output.
if(a = b)
printf("%d is equal to %d\ri",a,b);
ere a = b is treated as an assignment expression, so the value of b is assigned to variable a, and the
'Blue of the whole expression becomes 7 which is non-zero, and so the next statement is executed.
.8
Logical Or Boolean Operators
expression that combines two or more expressions is termed as a logical expression. For combining
~ e e expressions we use logical operators. These operators return 0 for false and 1 for true. The operands
y be constants, variables or expressions. C has three logical operators.
Operator
Meaning
&&
AND
I I
OR
!
NOT
ere logical NOT is a unary operator while the other two are binary operators. Before studying these .
erators let us understand the concept of true and false. In C any non-zero value is regarded as true
d zero is regarded as false.
.8.1
AND ( &&) Operator
This operator gives the net result true if both_ the conditions are true, otherwise the result is false.
Boolean Table
Condition!
Condition2
. Result
False
False
False
False
True
False
True
False
False
)'rue
True
True
/
r
<-.
o
Let us take three variables a = 10, b = 5, c = 0
uppose we have a logical expression-
(a = = 10) && (b < a)
Here both the conditions a = = 10 and b < a are true, and hence this whole expression i's true. Since
the logical operators return 1 for true hence the value of this expression is 1.
. Expression
Result
Value of expression
(a= =10) && (b>a)
true && false
false
0
(b>=a) && (b= =3)
false && false
false
0
a && b
true && true
true
1
a && c
true && false
false
0

This operator gives the net result false, ifboth the conditions have the value false, otherwise the result
is true.
In the last two expressions we have taken only variables. Since nonzero values are regarded as true
and zero value is regarded as false, so variables a and b are considered true and variable c is considered
false.
4.8.2
OR ( I I) Operator
Boolean Table
Condition!
Condition2
Result
False
False
False
False
True
True
True
False
True
True
True
True
C in Deptlr
Let us take. three variables a = 10, b = 5, c =.0
Consider the logical expression-
(a >= b) I I (b > 15)
This gives result true because one condition is true.
This is a unary operator and it negates the value of the condition. If the value of the condition is false
then it gives the result true. If the value of the condition is true then it gives the result false.
Boolean Table
Let us take three variables a = 10, b = 5, c = °
Suppose we have this logical expression-
! ( a = = 10 )
The value of the condition
(a= =10) is true. NOT operator negates the value of the condition. Hence
the result is false.
4.8.3
Expression
a I I b
a I I c
(a<9) I I (b>10)
(b!=7) I I c
Not ( ! ) Operator
true I I true
true I I false
falsel I false
true I I false
Condition
False
True
Result
true
true
false
true
Result
True
False
Value of expression
1
1
°
1

Operators and Expressions
Expression
Result
Value of expression
!a
!true
false
0
!c
!false
true
I
!(b>c)
!true
false
0
!(a && c)
!false
true
1
..
.9
Conditional Operator
. 41
onditional operator is a ternary operator ( ? and: ) which requires three expressions as operands. This
written as-
TestExpression ? expression1 : expression2
ly the TestExpression is evaluated.
If TestExpression is true(nonzero), then expression1 is evaluated and it becomes the value of the
overall conditional expression.
If TestExpression is false(zero), then expression2 is evaluated and it becomes the vaJue of overall
conditional expression.
example consider this conditional expression-
a>b?a:b
.:::.ere first the expression a > b is evaluated, if the value is true then the value of variable a becomes
_
value of conditional expression otherwise the value'ofb becomes the value of conditional expression.
- ppose a = 5 and b = 8, and we use the above conditional expression in a statement as-
max = a > b ? a : b;
-
the expression a > b is evaluated, since it is false so the value of b becomes the value of conditional
=xpression and it is assigned to variable max.
-
.
,
our next example we have written a conditional statement by putting a semicolon after the conditional
ression.
a < b ? printf("a is smaller") : printf("b is smaller");
in e the expression a < b is true, so the first printf function is executed.
~P4.6 Program to print the larger of
two numbers using conditional operator
;-
clude<stdi~.h>
--in ( )
int
a., b! max;
printf ("Ente:r;
values
scanf("%d
%d",&a,&b);
max
=
a>b
?
a :"b;
printf("Larger
of
%d
for
a
and
b
");
I*ternary
operator* I
and
%d
is
%d\n", a, b,max);
tput:
Enter values for a and b
12
7
Larger of 12 and 7 is 12

The comma operator ( , ) is used to permit different expressions to appear in situations where only
one expression would be used. The expressions are separated by the comma operator. The separated
expressions are evaluated from left to right and the type and valut of the rightmost expression is the
type and value of the compound expression.
For example consider this expression-
a = 8, b = 7, c = 9, a+b+c
Here we have combined 4 expressions. Initially 8 is assigned to the variable a, then 7 is assigned to
the variable b, 9 is assigned to variable c and after this a+b+c is evaluated which becomes the value
of whole expression. So the value of the above expression is 24. Now consider this statement-
sum = ( a = 8, b = 7, c = 9, a+b+c );
Here the value of the whole expression on right side will be assigned to variable sum i.e. sum will be
assigned value 24. Since precedence of comma operator is lower than that of assignment operator hence
the parentheses are necessary here. The comma operator helps make the code more compact, for example
without the use of comma operator the above task would have been done in 4 statements.
a = 8;
b = 7;
c = 9;
sum = a-hb+c
4.10
Comma Operator
C in Depth
/*P4.7
Program
to
understand
the
use
of
comma
operator
*/
#include<stdio.h>
main:( )
{
int
a , b , C, sum;
sum
(a=8,b=7,c=9,a+b+c);
printf("Sum
%d\n",sum);
}
Output:
Sum =24
/ * . P4 . 8
Program
to
interchange
the
value
of
two
variables
using
comm
operator*/
#include<stdio.h>
main(
int
a=8, b=7, temp;
printf("a
=
%d,
b
%d\n",a,b);
tem,P=a,
.a=b,
b=temp;
printf("a
%d,
b
=
%d\n",a,b);
}
Output:
a=8,b=7
a= 7 , b = 8

Operators and Expressions
• I
•--,
43
-
The comma operator is also used in loops, we'll study about that in the next chapter.
4.11
sizeo/O,perator
i
sizeof is an unary operator. This operator gives the size of its operand in te;ms of bytes. The operarid
can be a variable, constant or any datatype( int, float, char etc ). For example sizeof(int) gives the bytes
occupied by the int datatype i.e.J
f*P4.9
Program
to
understand
the
sizeof
operator* /
#include<stdio.h>
main( )
{
int
var;
printf
. ("Size
of
int
%d" ,sizeof (int) ) ;
printf("Size
of
float
%d",sizeof(float));
p do n t f ( " S i z e
0 f
va r
=
%d" , s i z e 0 f (var) ) ;
printf("Size
of
an
integer
constant
= %d",sizeof(45));
}
Output:
Size of int = 2
Size of float = 4
Size of val' = 2
Size of an integer constant = 2
Generally sizeof operator is used to make portable programs i.e. programs that can be run on different
machines. For examplejf we write our program assuming int to be of 2 bytes, then it won't run correctly
on a machine on which int is of 4 bytes. So to make general code that can run on all machines we
can use sizeof operator.
Bitwise Operators
C has the ability to support the manipulation of data at the bit level. Bitwise operators are used for
operations on individual bits. Bitwise operators operate on integers only. The bitwise operators are as-
Bitwise operator
Meaning
&
bitwise AND
I
bitwise OR
~
one's -complemen!
«
left shift
»
"
right shift
/\
bitwise XOR
These bitwise operators are discussed in detail in chapter 13.
Other operators
There are rriany other operators that ;we'll study in further chapters, The last operator that we'll take
up in this chapter is the type cast ~perator. Before stlldying that we'll discuss about type conversions
in C.
.. .,

C in Depth
I
Explicit type conversion
Type conversion
,in assignments
I
Automatic binary .
conversion
I
Implicit type converslOu
Ir---I----,
Automatic type
conversion
I
Type Conversion
I
Automatic unary
conversion
4.12
C provides the facility of mixing different types of variables and constants in an expression. In these
. types of operations data type of one operand is converted into data type of another operand. This is
known as type conversion. The different types of type conversion are-
Type Conversion
I
Implicit type conversions are done by the compiler while the explicit type conversions are user definec
conversions.
4.12.1
Implicit Type Conversions
These conversions are done by the C compiler according to some predefmed rules of C language. Thl
two types of implicit type conversions are automatic type conversions and type com ersion in assignment~
4.12.2
Automatic Conversions
Automatic unary conversions
All operands of type char and short will be converted to int before any operation. Some comPilers convel
all float operands to double before any operation.
Automatic binary conversions
The rules for automatic binary conversions are as-
(i)
If one operand is long double, then the other will be .converted to long double, and the result wi
be long double,
(ii)
Otherwise if one operand is double, then the other will be converted to double and the result wi
be double,
(iii} Otherwise if one operand is float, the other will be converted to float and the result will be flo::
(iv) Otherwise if one operand is unsigned long int, then other will be converted to. UJisigned long il
and the result will be unsigned long int.
(v). Otherwise if one operand is long int and other is unsigned int
(a)
If long int can represent all the values of an unsigned int, then unsigned int will be convert(
to long int and the result will be long int,
(b)
'Else both the operands will be converted to unsigned long int and the result will be unsign(
long int,
(vi) Otherwise if one operand is long int, then the other will be converted to long int and the res\
will be long int.

Operators and Expressions
ii) Otherwise if one operand is unsigned int, then the other will be converted to unsigned int and the
result will be unsigned int.
mi) Otherwise both operands will be int and the result will be int.
we leave aside unsigned variables, then these rules are rather simple and can be summarized by
- igning a rank to each data type. Whenever there are two operands of different data types the operand
'th a lower rank will be converted to the type of higher rank operand. This is called promotion of
ta type.
I long double I
Highest rank
~
~
d=J
Lowest rank
J
t .,
4.12.3
Type Conversion In Assignment
If the types of the two operands in an assignment expression are different, then the type of the right
hand side operand is converted to the type of left hand operand. Here if the right hand operand is of
lower rank then it will be promoted to the rank of left hand operand, and if it is of higher rank then
it will demoted to the rank of left hand operand.
'"
ome consequences of these prOmotions and demotions are-
1.
Some high order bits may be dropped when long is converted to int, or int is converted to short
int or char.
2.
Fractional part may be truncated during conversion of float type to lnt type.
3.
When double type is converted to float type, digits are rounded off.
4.
When a signed type is changed to unsigned type, the sign may be dropped.
S.
.When an int is converted to float, or float to double there will be no increase in accuracy or precision.
It
/ * P4 .10
Program
to
understand
the
type
conversion
in
assignment· /
#include<stdio.h>
main(
d
lt
char
c1,c2;
int
il,i2;
fl'Qat
f1, f2;
c1='H';
i1=80. 56; /*Demotion: float
converted
to
int,
only
80 .assigned
to
il * /
f1=12.6;

c2=i1;
i2=f1;
1 *Now
c2
12*1
printf("c2
f2=i1;
i2=c1;
I*Now
i2
printf("f2
I*Demotion
I*Demotion·
has
character
%c,
i2
I*Promotion
I*Promotion
contains
ASCII
%.2f,
i2
C ill Depth
int
converted
to
char* 1
float
converted
to
int * 1
wi th
ASCII
value
80, i2
is
assigned
value
%d\n",c2,i2);
int
converted
to
float * 1
char
converted
to' int * 1
value
of
character
'Hi
which
is
72 * 1
%d\n",f2,i2);
}
Output:
c2 = P,
i2 == 12
f2 = 80.00,
i2 =' 72
4.12.4
Explicit Type Conversion Or Type Casting
There may be certain situations where implicit conversions may not solve our purpose. For example-
float z;
int x = 20, y = 3;
z ~ x/y;
The value of z will be 6.0 instead of 6.66.
In these types of cases we can specify our own co~versions known as' type casting or coercion. Thi:
is done with the help of cast operator. The cast operator is a unary operator that is used for convertinl
an expression to a particular data type temporarily. The expression can be any constant or variable
The syntax of cast operator is-
(datatype) expression
Here the datatype along with the parentheses is called the cast operator.,
So if we write the above statement as-
z = (float)x/y;
Now the value of z will come out be 6.66. This happens because the cast operator (float) temporaril
converted the int variable x into float type and so floating point arithmetic took place and fraction
part was not lost.
Note that the cast operator changes the data type of variable x only temporarily for the evaluation
I
. this expression, everywhere else in the program it will be an int variable only.
1 *P4. 11
Program
to
illustrate
the
use
of
cast
operator* 1
#include<stdio.h>
main( )
{
int
x=5,y=2;
float
p,q;
p=x/y;
printf("p
=
%f\n",p);
q=(float)x/y;
printf("q
=
%f\n",q);

Operators and Expressions
Output:
p = 2.000000
q = 2.500000
47
(float)20/3
(float)(20/3)
(double)( x +y -z)
(double)x+y-z
Y
il
Initially the expression x/y.is evaluated, both x and yare integers so according to integer arithmetic
after division, decimal value is truncated and result is integer value 2. This value will be assigned to
p but p is a float variable so according to implicit type conversion in assignment the integer value 2
will be converted to float and then assigned to p. So finally the value of p is 2.0
When cast operator is used, floating point arithmetic is performed hence the value of q is 2.5
Here are some other examples of usage of cast operator-
(int)20.3
constant 20.3 converted
to integer type and fractional part is 10st(Result
20)
constant 20 converted to float type, and then divided by 3
(Result 6.66)
First 20 divided by 3 and then result of whole expression converted to float
type(Result
6.00)
.
Result of expression x+y-z is converted' to double
First x is converted to double and then used in expression
.13
Precedence And Associativity Of Operators
:01" evaluation of expressions having more than one operator, there are certain precedence and associativity
es defined in C. Let us see what these rules are and why are they required.
Consider the following expression-
2 + 3 * 5
ere we have two operators- addition and multiplication operators. If addition is performed before
tiplication then result will be 25 and if multiplication is perfoffi1ed before. addition then the result
-
be 17.
C language, operators are grouped together and each group is given a precedence level. The precec1ence
f all the operators is given in the following table. The upper rows in the table have higher precedence
it decreases as we move down the table. Hence the operators with precedence level 1 have highest
edence and with precedence level 15 have lowest precedence: So whenever an expression contains
re than one operator, the operator with a higher precedence is evaluated first. For example in the
'e expression, multiplication will be performed before addition since multiplication operator has higher
dence than the addition operator.

C in Deptb
Operator
Description
Precedence level
Associativity
( )
Function call
[ ]
Array subscript
1
Left to Right
-7
Arrow operator
Dot operator
+'
Unary plus
-
Unary minus
++
Increment
- -
Decrement
!
Logical NOT
2
Right to Left
-
One's complement
*
Indirection
&
Address
\
(datatype)
Type 'cast
sizeof
Size in bytes
*
Multiplication
/
Division
3
Left to Right
%
Modulus
+
Addition
4
Left to Right
-
Subtraction
«
~eft shift
5
Left to Right
»
Right shift
<
Less than
<=
Less than or equal to
6
Left to Right
\
>
Greater than
,.
>=
Greater.than or equal to
-
-
Equal to
7
Left o Right
!=
Not equal to
&
Bitwise AND
8
Left to Right
/\
Bitwise XOR
9
Left to Right
I
Bitwise OR
10
Left to Right
&&
Logical AND
11
~ft to Right
1 I
Logical OR
12
Le
o Right
? :
Conditional operator
13
Right to Left
=
*= /= %=
+= -=
Assignment operators
14
-
to Left
~
&= /\= 1=
«= »=
Comma operator
15
'"
to Right
,

Operators and Expressions
49
Let us take some expressions and see how they will be evaluated-
(i)
x = a+b < c
Here + operator has higher precedence than < and =, and < has more precedence than =,
so
first a+b will be evaluated, then < operator will be evaluated, and at last the whole value will be
assigned to x. If initial values are a = 2,b = 6, c = 9, then final value of x
will be 1.
(ii)
x *= a + b
Here + operator has higher precedence than *=, so a+b will be evaluated before compound
assignment.
This is interpreted as x = x*(a+b) and not as x = x*a+b.
If initial values are x = 5, a = 2, b = 6, then final value of x will be 13.
(iii)
x = a<=b II b==c
Here order of evaluation of operators will be <=, = =, 11,=. If initial values are a = 2, b = 3, c
= 4, then final value of x will 'be 1.
In the above examples we have considered expressions that contain operators having different precedenc-e
levels. Now consider a situation when two operators with the same precedence occur in an expression.
For example-
-
,
5 + 16 / 2 * 4
Here / and * have higher precedence than + operator, so they will be evaluated before addition. But
I and * have same precedence, so which one of them will be evaluated first still remains a problem.
If/ is evaluated before *, then the result is 37 otherwise the result is 7. Similarly consider this expression-
20 - 7 - 5 - 2 -1
Here we have four subtraction operators, which of course have the same precedence level. If we decide
to evaluate from left to right then answer will be 5, and if we evaluate from right to left the answer
will be 17.
'
To solve these types of problems, an associativity property is assigned to each operator. Associativity
of the operators within same group is same. All the operators either associate from left to right or from
right to left. The associativity of all operators is also given in the precedence table. Now again consrder
the above two expressions-
5 + 16 / 2 *4
ince / and * operators associate from left to right so / will be evaluated before * and the correct result
37.
20 - 7 - 5 - 2 -1
The subtraction operator associates from left to right so the value of this expression is 5,
The assignment operator associates from right to left. Suppose we have a multiple assignment expression
e this-
x=y=z=5
-ere initially the integer value 5 is assigned to variable z and then value of expression z = 5 is assigned
variable y. The value of expression z = 5 is 5, so 5 is assigned to variable y and now the value
f expression y = z = 5 becomes 5. Now value of this expression is assigned to x and the value of
hole expression x = y = z = 5 becomes 5.
-:De conditional operator also associates form fight to left. Consider this expression-
x?y:a?b:c

50
C in Depth
-•....,
Since the conditional operator is right associative so this expression is considered as:
x ? y : (a ? b : c)
If x is non zero then the value of this expression will be equal to y. If x is zero then value of thi~
expression will be equal to the value of expression (a ? b : c) i.e. equal to b if a is non zero and equa
to c if a is zero.
4:14
-Role Of Parentheses- In Evaluating Expressions
.-
~
.
If we want to change the order of precedence of any operation, we can use parentheses. AccordinJ
to the parentheses rule, all the operations that are enclosed within parentheses are performed first.
For example in expression 24/2+4, division will take place before addition according to precedence rul(
but if we enclose 2+4 inside parentheses then addition will .be performed first: So the value of expressio
24/(2+4) is 4.
For evaluation of expression inside parentheses same precedence and associativity rules apply. Fe
example-
.
(22 - 4 ) 1 (2+4*2-1)
Here inside parentheses multiplication will be performed before addition.
There can be nesting of parentheses in expressions i.e. a pair of parentheses can be enclosed with
another pair of parentheses. For example-
.
( 4* (3+2) )/10
In these cases, expressions within innermost parentheses are always evaluated first, and then ne
innermost parentheses and so on, till outermost parentheses. After evaluation of all expressions
witl~
par~ntheses, the remaining expression is evaluated as usual. In the above expression .3+2 is evaluat
first and then 4*5 and then 20/1 O.
Sometimes in complex expressions, parentheses are used just to increase readability. For example comp:
the following two expressions-
x = a!=b && c*d>=m%n
x = (a!=b) && ( (c*d) >=(m%n) )
These two expressions are evaluated in the same way but the operations performed in second one
clearer.
.
Let us take some expressions and evaluate them according the precedence, associativity and parenthf
rules.
a = 8,
b = 4, c = 2, d = 1, e = 5 , f = 20
a+
b~(c+d)*3 % e+f/9

n
lr
• erators and Expressions
a
+b-(c+d)
*
3%
e
SIb2 1'-1 lW
6th
7th
10
a =17,
b = 5, c = 6, d = 3, e = 5
a % 6 - b I 2 + ( c *
d - -5 ) I e
+ f
/ 9
4th
I-
2
/
51
in
xt
in
~d
lre
,es
a % 6 - b
/
2 + (
c * d-5)/e
3rd I I 4th I
Il~
1
f
6th
2nd
1
3
5th
7th
J
5
a = 4, b = 5, C = 6, d = 3, e = 5, f
= 10
a*b-c/d<e+f
a*b-c/d<e+f
~~~
rO
r
1
~
1
5th
o
a = 8, b = 5, c = 8, d = 3, e = 65, f
= 10, g = 2, h = 5, k = 2
a-b+c/d== elf - g+h
%k

52
a-
b+ c/d= e/
f
- g+h %k
I 4th I I 1st I
I ~d I II 3td
I
3
t
5th
J
.
8_th
---JJ
1
a = 8, b = 3,
C = 2, d = 3, e = 2, f
= 11
a - b I I ( a- b * C
) +
d && e - f
% 3
C in Depth
a -
-b
14th I
IIC a-b *c
I LLS!
I
~
) + d && e - f
% --3
I
L3~d I
~-
8th
1
The following program prints the results of above expressions-
/*P4,12
Program
to
evaluate
some
expressions* /-
main ( )
{
int
a,b,c,d,e,f,g,h,k;_
a=8,b=4,c=2,d=1,e=S~f=20;
printf("%d\t-,a+b-(c+d)*3%e+f/9) ;
a=17,b=S,c=6,d=3,e=S;
printf("%d\t-,a%6-b/2+(c*d-S)/e) ;
a=4,b=S,c=6,d=3,e=S,f=lO;
printf("%d\t-,a*b-c/d<e+f) ;
a=8,b=5,c=8,d=3,e=6S,f=10,g=2,h=S,k=2;
printf("%d\t~,a-b+c/d==e/f-g+h%k);
a=8,b=3,c=2,d=3,e=2,f=11;
printf("%d\n-,a-bl I (a-b*c)+d&&e-f%3);
Output:
10
5
o

Operators and Expressions
S3
4.15
Order Of Evaluation Of Operands
C does not specify the order in which the operands of an operator are evaluated. For example consider '
the expression-
y = (++x) + (- -x);
/*Assume value of x is 5*/
Here the two operands of the addition operator are (++x) and (- -x). These two operands have to be
added and then the result has to be assigned to variable y. Before addition, these two operands will
e evaluated. Now if the first operand(++x) is evaluated first then y will be assigned yalue 11, while
if second operand(- -x)
is evaluated first then y will
be assigned the value 9. Since C is silent on
such controversies, the answers may .vary on different compilers so it is better to avoid such -type of
expressions.
There are four exceptional operators where C clearly specifies the order of evaluation of operands. These
operators are logical AND( && ), logical ORe I I ) , conditional (? : ) and comma operator( , ). In
....
.
ail these cases the operand on th~ left side is evaluated first.
In the case of logical AND and logical OR operators, sometimes there is no need to evaluate second
operand. In && operator, if the first operand evaluates to false(zero), then second operand is not evaluated
and in the case of I I operator if the first operand evaluates to true(non zero)
th~n second operand is
not evaluated.
Exercise
Assume stdio.h is included in all programs.
(1) main (
)
{
int
a=-3;
a·= - a - a + ! a ;
printf("%d\n·,a);
(2) main (
{
int
a=2,b=1,c,d;
c=a<b;
'd=(a>b)&&(c<b) ;
printf("c
=
%d,
d
3) main (
{
%d\n·,c,d) ;
int
a=9,b=15,c=16,d=12,e,f;
e=! (a<bllb<c);
f=(a>b)?
a-b:b-a;
printf("e'=
%d,
f
%d\n·,e,f);
main(
{
int
a=5;
a=6 ;

a=a+5*a;
printf ("a
(5) main (
int
a=5,b=5;
printf ("%d,
printf ("%d,
printf ("%d,
printf ("%d,
(6) main(
{
%d\n",a);
%d\t",++a,b--);
%d\t",a,b);
%d\t", ++a,b++);
%d\n" , a, b) ;
Cin Depth
int
x,y,z;
x=8++;
y=++x++;
z= (x+Y) - -;
printf ("x
=
%d,
y
(7) main(
{
%d,
Z
%d\n", x, y) ;
int
a=4,b=8,c=3,d=9,z;
z=a++
+
++b
*
c- -
- -d;
printf ("a
=
%d, b
=
%d, c
%d, d
(8) main ( ).
%d,z
%d\n",a,b,c,d,z);
int
a=14,b,c;
a=a%-5;
b=a/3;
c=a/5%3;
printf ("a
%d,
b
(9) main (
/{
%d,
c
%d\n",a,b,c);
int
a=15,b=13,c=16,x,y;
x=a-3%2+c*2/4%2+b/4;
y=a=b+5-b+9/3;
printf ("x
=
%d,
y
=
%d\n", x, y) ;
(lO)main(
{
int
x,y,z,k=10;
k+=(x=5,y=x+2,z=x+y) ;
printf("x
=
%d,y
=
%d,z
%d,k
%d\n",x,y,z,k);

Operators and Expressions
ll)maiI:J.( )
(
illt
a;
float
b;
b=lS/2;
printf("%f\tn,bl;
b=(floatl1S/2+(lS/2) ;
printf("%f\nn,b) ;
(12) main (
{
int
a=9;
·char
ch='A';
a=a+ch+24;
printf("%d,%c\t%d,%c\nn,ch,ch,a,al;
(13 Imain (
(
55
int
a,b,c,d;
a=b=c=d=4;
a*=b+1;
c+=d*=3;
printf("a
%d,c
(14 Imain (
{
int
a=S,b=10,temp;
temp=a,a=b,b=temp;
printf("a
%d,b
(lSlmain(
{
int
a=10, b=3, max;
a>b?max=a:max=b;
printf ("%d n ,max);
(161#include<stdio.h>
main( I
{
%d\nn,a,
c);
%d\nn ,a, bl ;
int
a=S,b=6;
printf("'d\tn,a=bl;
printf("%d\tn,a==bl;
printf ("%d
%d\nn, afbl ;
/
(17) main (

C ;n Depth
int
a=3,b=4,c=3,d=4,x,y;
x=(a=5)&&(b=7) ;
y= (c=5) II (d=8);
printf("a=%d,b=%d,c=%d,d=%d,x=%d,y=%d\n",a,b,c,d,x,y) ;
x=(a==6)&&(b=9) ;
y= (c==6) II (d=lO);
printf("a=%d,b=%d,c=%d,d=%d,x=%d,y=%d\n",a,b,c,d,x,y) ;
I
(18)main( )
{
int
a=lO;
a=a++*a- -;
printf("%d\n",a) ;
. }
(19) main (
{
int
a=2,b=2,x,y;
x=4*(++a*2+3) ;
y=4*(b++*2+3) ;
printf("a=%d,b=%d,x=%d,y=%d\n",a,b,x,y) ;
1.
2.
3.
4.
5.
6.
7.
Programming Exercise
Enter'the temperature in Celsius and convert that into Fahrenheit.
Accept the radius of the circle and calculate the area and perimeter of the circle.
Write a program to accept the number in decimal and print the number in octal and hexadecimal.
,
Accept any five digit number and print the value of remainder after dividing by 3.
Accept any two numbers, if the first number is greater than second then print the sum of these
two numbers, otherwise print their difference. Write this program using ternary operator.
Write a program'to accept the principal, rate, and number of years and find out the simple interest.
Accepts marks in five subject and calculate the total percentage marks.
Answers
(1)
6
(2)
c = 0, d = 1
(3)
e = 0, f=-6
(4)
36
(5)
6, 5
6, 4
7, 4
7, 5
(6)
Error, Expressions like 8++, ++x++, (x+y)- - are not valid.
(7)
a = 5, b= 9,c = 2, d = 8, Z = 23
(8)
a = 4, b = 1, c = °
(9)
x=17,y=8
(10) x = 5, Y = 7, Z = 12, k = 22
)

Operators and Expressions
57
(ll) 7.000000 14.500000
(12) 65, A
98, b
(13) a = 20, c = 16
Precedence of + operator is more than that of+= . Associativity of compound assignment operators
is from right to left
14) a = 10, b = 5
15) Since the precedence of assignment operator is less than that of conditional operator so the
conditional statement is interpreted as~ ( a>b?max = a : max) = b;,
Now this statement reduces to statement 10 = b, which results in an error. So the solution is to
put parentheses around the third operand as-
a>b? max = a : (max = b);
(16) 6
1
6
6
(17) a = 5, b = 7, c = 5, d = 4, x = 1, y = 1
a = 5, b = 7, c = 5, d = 10, x = 0, y = 1
18) Result of these types of expressions is undefined.
(19) a = 3, b = 3, x = 36, y = 28
)

Chapter 5
Control Statements
In C programs, statements are executed sequentially in the order in which they appear in the program.
But sometimes we may want to use a condition for executing only a part of program. Also many situations
arise where we may want to execute some statements several times. Control statements enable us to
specify the order in which the various instructions in the program are to be executed. This determine.s
the flow of control. Control statements define how the control is transferred to other parts of the program.
C language supports four types of control- statements, which are as-
1.
if...else
2.
goto
3.
switch
j
4.
loop
while
do...while
for
5.1
Compound Statement or Block
A compound statement or a block is a group of statements enclosed within a pair of curly braces {}
The statements inside the block are executed sequentially. The general form is-
{
statementl;
statement2;
For example-
{
1=4;
b=2;
area=l*b;
printf("%d",area) ;
A compound statement is syntactically equivalent to a single statement and can appear anywhere in tl
program where a single statement is allowed.
)

Control Statements
5.2
if...else
59
if(condition)
{
This is a bi-directional conditional control statement. This statement is used to test a condition and take
one of the two possible actions. If the condition is true then a single statement or a block of statements
is executed (one part of the program), otherwise another single statement or a block of statements is
executed (other part of the program). Recall that in C, any nonzero value is regarded as tr!1e while zero
is regarded as false.
Syntax 1:
if(condition)
statementl;
statement;
There can be a single statement or a block of statements after the if part.
True
False
statement;
if(condition)
{
Flow chart ofifcontrol statement
Here if the condition is true(nonzero) then statement! is executed, and if it is false(zero), then the next
st~tement which is immediately after the if control statement is executed.
Syntax 2:
if(condition)
statementl;
else
i
statement2;
}
else
statement;
)

True
Next statement
False
C in Depth
Flow chart ofif. ..else control statement
Here if the condition is true then statement1 is executed and if it is false then statement2 is executed.
After this the control transfers to the next statement which is immediately after the if. ..else control
statement.
/ *P5.1
Program
to
print
a
message
if
negative
number
is
entered* /
#inc1ude<stdio.h>
main ( )
{
int
num;
pJ;'in~f("Enter
a
number
scanf("%d".&num};
if (num<O)
printf ("Number
entered
printf ("Value
of
num
is
15t run:
Enter
a number: -6
Number entered is negative
Value of num is -6
2nd run:·
If
) i
is
negative\n"};
%d\n",
num};
Enter a number : 8
Value of num is 8
/ *P5. 2
Program
to
print
the
larger
and
smaller
of
the
two
numbers * /
#include<stdio.h>
main ( )
{
.'
int
a,b;
printf ("Enter
the
first
number
scanf("%d".&a) ;
" ) i
I

second
number
Control Statements
printf ("Enter
the
scanf ("%d" ,.&b) ;
if (a>'b)
printf("larger
else
printf("larger
number
number.
%d
and
%d
and
\\ ) ;
smaller
smaller
number
number
%d\n",a,b);
%d\n", b, a) ;
61
}
Output:
Enter the first number : 9
Enter the second number : 11
larger number = 11 and smaller number = 9
/ *P5. 3
Program
to
print
whether
the
number
is
even
or
odd
* /
#include<stdio.h>
main ( )
{
int
num;
printf ("Enter
a
number
") ;
scanf("%d",&num) ;
iffnum%2==O)
/*test
for
eVen
*/
printf ("Number
is
even\n");
else
printf ("Number
is
odd\n");-
}
Output:
Enter the number : 15
Number is odd
5.2.1
Nesting of if...else
We can have another if. ..else statement in the if block or the else block. This is called nestin~.of if...else
statements. Here is an example of nesting where we have if...else inside both if block and else block.
if (condition
1)
{
if (condition
2)
statementA1;
else
statementA2;
else
if(condition
3)
. statementB1;
else
statementB2
While nesting if...else statements, sometimes confusion may arise in associating else part with appropriate
if part: Let us take'an example-

C in Depth
if (grade== 'A')
{
if(marks>95)
printf("Excellent") ;
}
else
printf ("Work
hard
for
getting
A
grade");
If we write the above code without braces as-
if(grade=='A')
if(marks>95)
printf.("Excellent") ;
else
printf ("Work
hard
for
getting
A
grade");
Here the else part is matched with the second if, but we wanted to match it with the first if. The compiler
does not associate if and else ·parts according to the indentations, it matches the else part with closest
unmatched if part. So whenever there is doubt regarding matching of if and else parts we can use braces
to enclose each if and else blocks.
/*P5.4
Program
to
find
largest
number
from
three
given
numbers*/
#include<stdio.h>
main( )
{
int
a,b,c,large;
printf ("Enter
three· numbers
") ;
scan~("%d%d%d",&a,&b,&c) ;
if (a>b)
{
if(a>c)
large=a;
else·
large=c;
else
if (b>c)
large=b;
else
large=c;
}
pri.ntf (":"argest
number
is
%d\n", large) ;
}/*End
of
main() */.
The next program finds whether a given year is leap or not. A centennial(divisible by 100) year is Ie
if it is divisible by 400, and a non centennial year is leap if it is divisible by 4.
/*P5.5
Program
to
find
whether
a
year
is
leap
or
not*/
#include<stdio.h>
main(
{
(

Control Statements
,
.
i!1t
year;
printf ("Enter
year
sca'nf ("%d "
I &year) ;
if (year%100==0)
{
" ) ;'
63
if (year%400==0)
printf ("Leap
year\n");
else
printf ("Not
leap\n");
}
else
if (year%4==O)
printf ("Leap
year\n");
else
. printf("Not
leap\n");
_ ote that we can write this program using a single if condition and && and II operators.
':f (year%4==0
&&
year%100! =0
II
year%400==0)
printf ("Leap
year\n");
e
se
printf ("Not
leap\n");
-.2.2
else if Ladder
This is a type of nesting in which there is an if. ..else statement in every else part except the last else
part. This type of nesting is frequently used in programs and is also known as else if ladder.
statementD;
-:;.7 if( condition!)
//....
statementA;
''-
~lse
if(condition2)
........."71.
statementB;
i.··
else
if( condition 3)
..../7
statementC'
."
.,
<'
else
.........
if( condition!)
statementA;
else jf(condition2)
statementB;
else if( condition 3)
statementC;
else
statementD;
This nested structure is generally written in compact form as in second figure. The flow chart for this
.'
~
SlTUcture is-

stat A
False
stat C
False
1
False
C in Depth
I Next Statement I
Flow chart ofelse.. .ifladder
Here each condition is checked, and when a _condition is found to be true, the statements corresponding
to that are executed, and the contliol comes out of the nested structure without checking remaining
conditions. If none of ~~e conditions is true then the last else part is executed.
'
and
per>=70
and
per>=55
and
per>=40
marks
of
the
as-
of
a
student
when
assigning
grade
is
to
find
out
the
grade
given.
The
method
of
grade=A
grade=B
grade=C
grade=D
grade=E
/ * P5. 6
Program
4
subj ects
are
per>:: 85
per<85
per<70
per<55
per<40
Here, per
is
perc,entage.
*/
#include<stdio.h>
main ( )
{
float
ml, m2, ni3, m4, total, per;
char
grade;
printf{"Enter
marks
of
4
subjects
");
scanf(-%f%f%f%f·,&ml,&m2,&m3,&m4) ;
total=ml+m2+m3+m4;
per=total/4;
if (per>=85)
grade= 'A' ;
else
if(per>=70)
grade='B';
else
if (per>=55)
grade= 'C' ;

COntrol Statements
else
if (per>=40)
grade= 'D' ;
else
grade='E';
printf ("Percentage
is
%f\nGrade
is
%c\n", per, grade) ;
- we don't use the else if ladder, the equivalent code for this problem would be-
::.f(per>=85)
grade=' A' ;
~=(per<85&&per>=70)
grade='B' ;
:f(per<70&&per>=S5)
grade=' C' ;
:!(per<55&&per>=40).
grade= 'D' ;
=-=(per<40)
grade=' E' ;
65
if.. .else ladder whenever a condition is found true other conditions are not checked, while in this
e all the conditions will always be checked wasting a lot of time, and moreover the conditions here
_
more lengthy.
-.3
Loops
ps are used when we want to execute a part of the program or a block of statements se"·~ral times.
-
example, suppose we want to print "e is the best" 10 times. One -.way to get the desired output
_ - we write 10 printf statements, which is not preferable. Other way out is - use loop. Using loop
can write one loop statement and only one printf statement, and this approach is definitely better
the first ·one. With the help of loop we can execute a part of the program repeatedly till some
dition is true. There are three loop statements in C-
"
while
do while
for
.3.1
while loop
e while statement can be written as:
::'°le(condition)
statement;
while(condition}
{
statement;
statement;

66
False
True
Flow chart of while loop
C in Dept}
Like if-else statement here also we can have either a single statement or a block of statements, a
here it is known as the body ~f lo'Op. Now let's see how this -loop works.
First the condition is evaluated; if it is true then the statements in the body of loop are executed. Au
the execution, again the condition is checked and if it is found to be true then again the statemel
in the body of loop are executed. This means that these statements are executed continuously till t
condition is true and when it becomes false, the loop terininates and the control comes out of the lo(
Each execution of th~ loop body is known as iteration.
/*
P5.7- Program
to
print
the
numbers
from
1
to
10
using
while. loop
#inc1ude<stdio.h>
main ( )
(
int
i=l;
while(i.::=10)
{
printf("%d\t",i) ;
i=i+1;
/ * Statement
that
changes
the
value
of
condition
* /
}
printf(~'\n") -;
/
Here initially the condition ( i <'0= 10) is true. After each iteration of the loop, value of i increases i
when the value of i equals 11 the condition becomes false and the loop terminates.
}
Output:
1
2
3
4
5
6
7
8
9
10

Control Statements
67
Note that inside the body of the loop there should be a statement that alters the value of the condition,
so that the condition becomes false ultimately at some point.
-
J*P5.8 Program
to
print
numbers
in
reverse
order
with
a
difference
of 2*1
main (
)
{
int
k=10;
while(k>=2)
{
printf("%d\tH,k);
k=k-2;
}
printf("\n H) ;
}
Output:
10
8
6
4
2
I*P5.9
Program to' print
the
sum
of
digits
of
any
number* 1
=include<stdio.h>
ai-n ( )
{
last
digit
* J
number
* J
\\ ) ;
rem=n%10;
1 *
taking
last
digit
of
sum+=rem;
n/=lO;
1*
skipping
int
n, sum=O, rem;
printf ("Enter
the
number
scanf("%d H,
&n);
while(n>O)
{
:r
:s
.e
).
d
1
}
printf ("Sum
of
digits
=
%d\n H, sum) ;
utput:
Enter the number: 1452
Sum of digits = 12
I
ere we are extracting the digits of the number from right to left and then these digits are added one
y one to the variable sum. Note that the variable sum is initialized to 0. This is because we are adding
50me numbers to it, and if not initialized then these numbers will be added to garbage vatue present.
ill it. Let's see how the loop works when the value of n is 1452.
Before loop starts
rem = garbage value,
sum = 0,
n = 1452
After 1st iteration
rem = 1452%10 = 2,
sum = 0+2 = 2,
n = 145
After 2nd iteration
rem = 145%10 = 5,
sum = 2+5 = 7,
n = 14
After 3rd iteration
rem = 14%10 = 4,
sum = 7+4 = 11,
n = 1
After 4th iteration
rem = 1%10 = 1,
sum = U +1 = 12,
n = 0
~-ow since the value of n is equal to zero, hence the condition ( n > 0) becomes false and the loop
ps.

68
Cin D~Pi
I*PS.10
Program
to
find
the
product
of
digits
of
any
number*1
#include<stdio.h>
main ( )
{
in~
n,prod=l,rem;
printf ("Enter
the
number
").;
scanf("%d",&n) ;
while(n>O)
{
rem=n%10;
prod*=rem;
n/=10;
I*taking
last
digit*1
1 *skipping
last
digit
of
number* 1
}
printf("Product
of
digits
=
%d\n",prod);
}
Output:
Enter the number : 234
Product of digits = 24
The logic of extracting digits is similar to thaf in previous program, but here we are multiplying
jigits instead of adding, so here the variable prod is initialized by value 1.
I*PS.11
Program
to
find
the
factorial
of
any
number*1
#include<stdio.h>
main( )
{
" ) i
int
n, num;
long
fact=l;
printf ("Enter
the
number
scanf("%d" ,&n);
num=n;
if(n<O)
printf ("No
factorial
of
negative
number\n");
else
while (n>l)
{
\
fact*=n;
n- - i
%1 d \ n",
n um ,
fa c t) ;
}
printf ("Factorial
of
%d
}
Output:
Enter the number: 4
Factorial of 4 = 24
The factorial of a number n is the product of numbers from 1 to n.
..
n! "'" n * (n-1)* (n-2)
*2*1.
4! = 4*3*2*1 = 24
~! = 8*7*6*5*4*3*2*1 = 40320
i;
i

Control Statements
69
statement;
statement;
.e
We have taken the variable fact of type long instead of type int. This is so because the factorials grow
at a very fast rate, and they may exceed the range of an int (32767). Even the factorial of 8 is more
than this limit.
I *P5. 12
Program
to
.:::onvert
a
binary
number
to
a
decimal
number*"
include<stdio.h>
main( )
{
int
n,nsave,rem,d,j=l,dec=O;
printf("Enter
the
number
in binary");
scanf ("%d", &n) ;
nsave=n;
while (n::-O)
{
rem=n%lO;
I*taking
last
digit*1
d=rem*j;
dec+=d;
j*=2;
n/=lO;
/*skipping
last
digit*/
}
printf("Binary
number
=
%d,
Decimal
number
=
%d\n",nsave,dec);
}
Ouput
Enter the number in binary : 1101
Binary number = 1101, Decimal humber = 13
To convert a binary number to decimal, we extract binary digits from right and add them after multiplying
by powers of 2. This is somewhat similar to the program P5.9, only we have to multiply the digits
by powers of 2 before adding them. This is how the loop works for binary number 1101. ----<
Before loop starts:
rem=garbage,
d= garbage,
dec=O,
j=l,
n=nsave=llOI
After 1st iteration:
rem=1,
d=1*1,
dec=1,
j=2,
n=110
After 2nd iteration:
rem=O,
d=0*2,
dec=1 +0,
j=4,
n=ll
After 3rd iteration:
rem= I,
d=1*4,
dec=1+0+4,
j=8,
n=I
After 4th iteration:
rem=l,
d=1 *8,
dec=1+0+4+8,
j=16,
n=O
Now the value of n becomes zero so the loop terminates. We have taken a variable nsave to save the
value of binary number, because the value of n gets changed after the loop execution.
(The above program will be valid for binary numbers upto 11111 only, for larger numbers take long
int).
5.3.2
do...while loop
The 'do...while' statement is also used for looping. The body of this loop may contain a single statement
or a block of statements. The syntax for writing this loop is:
do
do
statement;
while(condition) ;'
}while(condition) ;

C in Depth
Flow chart of do ... while loop
Here firstly the statements inside loop body are executed and then the condition is evaluated. If th(
condition is true, then again the loop body is executed and this process continues until tne conditiol
becomes false. Note that unlike while loop, here a semicolon is placed after the condition.
In a 'while' I09P, first the condition is evaluated and then the statements are executed whereas in
j
~o while loop, first the statements· are executed and then the condition is evaluated. So if initially thl
condition is false the while loop will not execute at all, whereas the do while loop will always executl
at least once.
/ *:p5. 13
Program
to
print
the
numbers
from
1
to
10
using
#include<stdio.h>
main ()
{
int
i=l;
do
(
printf("%u\t",i) ;
i=i+1;
}while(i<=10) ;
printf("\n") ;
do...whi1e
loop*.
/
Generally while loop is used more frequently than the do while loop but some situations may arise whe
it is better to check the condition at the bottom of loop. For example in the next two programs it •
better to use a do while loop.
}
Outp,Jrt:
1
2
3
4
5
6
7
8
9
10

Control Statements
I*P5.14
Program
to
count
the
digi ts
in
any
number
* /
-include<stdio.h> .
ain ( )
{
int
n, count=O, rem;
printf ("Enter
the
number
") ;
scanf ("%d" ,&n) ;
do
{
n/=10;
count++;
}while(n>O) ;
printf ("Number
of
digits
=
%d\n!', count) ;
71
If we write the same program using a while loop then we won't get correct answer when input number
is O. The count of digits in number 0 is 1, but using while loop the answer will come out to be zero.
1*
P5.15
Program
to
find
the
sum
of
numbers
entered* /
include<stdio.h>
ain(
{
int
num, sum=O.-
do
{
'.
printf ("Enter
a
number·
(0
to
stop)
scanf("%d",&num) ;
sum+=num;
}while (num! =0) ;
printf ("Sum
is
%d\n", sum) ;
\, ) ;
In this program if we use while loop then the condition will be checked at the top, so either we'll have
to give some initial value to the variable num or we'll have to write duplicate printf and scanf( ) statements
before the loop.
The do...while loop is generally used for checking validity of entered data. Suppose we want the user
to enter an employee ID, and the valid IDs are in the range 100 to 500 only. If the user enters an invalid
ID, we want to ignore that ID and again ask him to enter another one, and we want this process to
continue till he enters a valid ID. In this type of situation we can use do ...while loop.
do
printf("Enter
employee
ID
");
scanf("%d",&emp_id) ;
}while (emp_id<100
I I
emp_id>50 n );
This loop will terminate only when the entered number is in the valid range 100 to 500.
5.3.3
for loop
The 'for' statement is very useful while programming in C. It has three expressions and semicolons
are used for separating these expressions.
The 'for' statement can be written as-

C in Depth
for(expressionl;expression2;expression3)
-_..
statement;
for(expressionl;expression2;expression3)
{
statement;
statement;
The loop body can be a single statement or block of statements.
expressionl is an initialization expression, expression2 is a test expression or condition and expression3
.is an update expression. expression1 is executed only once when the loop starts and is used to i.nitialize
the loop .. variables. This expression is generally an assignment expression. expression2 is a condition
and is tested before each iteration of the loop. This condition generally uses relational and logical oj:>er~tors.
expression3 is an update expr~ssion and is executed each time after the body of the loop is executed.
Now let us see how this loop works. Firstly the initialization expression is executed and the loop variables
are initialized, and then the condition is checked, if the condition is true then the body of loop is executed.
After ,executing the loop body, control transfers to expression3(update expression) and it modifies the
loop variables and then again the condition is checked, and if it is true, the body of loop is executed.
This process continues till the condition is true and when the condition becomes false the loop is
terminated and control is transferred to the statement following the loop.
The work done by the for loop can be performed by writing a while loop as-
Initialization expression
False
True
Bodyofloop
Update expression
Next statement
Out of loop
Flow chart of for loop

Control Statements
expression
1;,
while(expre:ssion
2)
{
statement;
expression
3;
73
Although the task of while and for loops is same, the for loop is generally used when the number of
iterations are known in advance and while loop is used where number of iterations are not known,
I*P5.16
Program
to
print
the
numbers
from
1
to
10
using
for
loop*1
#include<stdio.h>
main( )
{
int
i;
for(i=1;i<=10;i++)
printf("%d\tH,i);
printf ("\n H);
}
Output:·
I
2
3
4
·5
6
7
8
9
10
1*P5. 17
Program
to
print· numbers
in
reverse
order
wi th
a
dif ference
of
2*1
main(
{
int'
k;
for(k=10;k>=2;k-=2)
printf("%d\tH,k) ;
printf("\n H);
}
Output:
10
8
6
4
2
@~5. 18
Multiply
two
posi tive
numbers
without
using
*
operator* 1
/ inc1ude<stdio. h>
'lTIain(
)
{
int
a,b,i;
int
resul t=O;
printf("Enter
two
numbers
to
be
multiplied
");
scanf("%d%dH,&a,&b) ;
for(i=l;i<=b;i++)
result=result+a;
printf("%d
*
%d
%d\nH,a,b,result);
I*P5.19
Find
the
sum
of
this
series
upto
n
terms

C in Depth
1+2+4+7+11+16+
* /
#include<stdio.h>
main ( )
{
int
i, n, sum=O, term=l;
printf ("Enter
number
of
terms
") ;
scanf ("%d" ,&n) ;
for(i=l;i<=n;i++)
{
sum+=term;
term=terIh+i;
}
printf ("The
sum
of
series
upto
%d
terms
is
%d\n", n, sum) ;
}
/*P5.20
Program
to
generate
fibonacci
series
1,1,2,3,5,8,13,34,55,89
.
In
this
series
each
number
is
a
sum
of
the
previous
two
numbers*/
#include<stdJo.h>
main( )
{
long
x, y,;i:;
int
i,n;
x=O;
y=l;
pri!1tf ("Enter
the
number
of
terms
") ;
scanf ("%d" ,&n) ;
prip tf("%ld
~,y);
for li=~1U<n;i++)
{
/.~~-.-
z=x+y;
prln't f (:' %ld
x=y;
Y ==~_'4 ;
printf("\n") ;
\\
I Z r~
All the three expressions of the for loop are optional. We can omit anyone or all the three expressions
in the for loop but in any case the two separating semicolons should always be present.
expression! is omitted when the initialization work is done before entering the loop.'
expression2 is a condition and if omitted, it is always assumed to be true and so.this type of loop will
never stop executing. This type of loop is infinite and to avoid it there should be a statement inside
the loop that takes the control out of the loop.
expression3 is an update expression and is omitted when it is present inside the body of the loop..
/*P5.21
Program
to
print
the
sum
of
digits
-of
any
number
using
for
loop
*/
#inc1ude<stdio.h>

Control Statements
75'~
main ( )
{
int
n, sum=O, rem;
printf ("Enter
the
number
") ;
scanf ("%d" , &n) ;
for (
; n>O ;n/=lO)
{
rem=n%lO;
/*taking
last
digit
of
number*/
sum+=rem;
}
printf ("Sum
of
digits
=
9;d\n", sum) ;
We can also have any number of expressions separated by commas. For example, we may want to
initialize more than one variable or take more than one variable as loop variable.
/ *P5. 22
Program
to
print
numbers
using
for
loop* /
#include<stdio.h>
main ( )
{
int
i, j ;
for(i=O,j=lO;i<=j;i++,j--)
printf("i
=
%d
.j
%d\n",i,j);
j = 10
j= 9
j = 8
j =7
j = 6
j = 5
Nesting of Loops
}
Output:
i = 0
i = 1
i = 2
i = '3
i = 4
i = 5
5.3.4
When a loop is written inside the body of another loop, then it is known as nesting of loops. Any type
of loop can be nested inside any other type of loop. For example a for loop may be nested inside another
for loop or inside a while or do while loop. Similarly while and do while loops can be nested.
/*P5.23
Program
to
understand
nesting
in
for
loop*/
#include<stdio.h>
main( )
{
int
i,j;
for(i=1;i<=3;i++)
{
/ *ou.ter
loop* /
printf("i
%d\n",i);
for(j=1;j<=4;j++)
/*inner
loop*/
printf ("j
%d\t", j);
printf("\n");

C in Depth
Output:
i = 1
j=l
j=2
3
j=4
i=2
j=l
j=2
J
3
j=4
i=3
j = 1
j = 2
j = 3
j = 4
Here for each iteration of the outer loop, the inner loop is executed 4 times.
The next program prints armstrong numbers. Armstrong number is a three digit number in which the
sum of cube of all digits is equal to the number, for example 371 is an armstrong number since 371
= 33+73+P=27+343+1
I*P5.24
Program
to
print
armstrony
iHlmbers
from
100
to
999*1
#inc1ude<stdio.h>
main ( )
int
num,n,cube,d,sum;
printf ("Armstrong
numbers
are
: \n") ;
for(num=100;num<=999;num++)
{
/ *outer
100p* /
n=num;
sum=O;
whi1e(n>0)
{
1 * inner
loop* /
d=n%10;
n/=10;
cube=d*d*d; .
sum=sum+cube;
}/*End .of
while
loop*1
if (num==sum)
printf("%d\n",num) ;
} 1*End
of
for
loop* /
Here the outer for loop is used to generate numbers from 100 to 999, and the inner while loop is used
to extract digits and then find the sum of cube of those digits.
I*P5.25
Program
to
find
the
sum
of
digits
of
a
number
until
the
sum
is
reduced
to
1
digit.
For
example:
538769->38->11->2*1
#include<stdio.h>
main( )
{
long
·num;
int
dig, sum;
printf ("Enter
a
number
") ;
scanf("%ld",&num) ;
printf("%ld->",num) ;

ntrot (:jtatements
do
{
for(sum=O;num!=O;num/~lO)
{
dig=num-%lO;
sum+=dig;
}
printf("%d\t",sum);
num=sum;
}while(num/10!=O) ;
printf("\n") ;
utput:
Enter a number: 789988
789988->49
13
4
ere the inner for loop is used tt? find the digits of the number.
77
·.3.5
Infinite Loops
The loops that go on executing infinitely and never terminate are called infinite loops. Sometimes we
'te these loops by mistake while sometimes we deliberately make use of these loops in our programs.
~et us take some examples and see what type of mistakes lead to infinite loops.
A)
for (i=O; i<=5; i- -)
printf("%d",i);
,
This loop will execute till the value of i is less than or equal to 5 i.e. the loop will terminate only
when i becomes greater than 5. The initial value of i is 0 and after each iteration its value is
decreasing, hence it will never become greater than 5. So the loop condition will never become
false and the loop will go on executing infinitely. For the loop to work correctly we should write
i++ instead of i- -.
(B)
There should be a statement inside the loop body that changes the value of loop variable after<-each
iteration. In for loop this work is done by. the update expression but in- while and do while we
may forget to change the loop variable and this can lead to infinite loop.
int
k=l;
do
{
printf ("%d", k) ;
sum=sum+k;
}while(k<5) ;
Here we are not changing the value of k inside the loop body and hence the loop becomes infinite.
(C)
A common mistake made by beginners is to use the assignment operator(=) where equality operator(=
=) should have been used. If this mistake is made in the loop condition then it may cause the
loop to execute infinitely. For example consider this loop:
while(n=2)
{
}
Here we wanted the loop to execute till the value of n is equal to 2. So we should have written

n= =2
but mistakenly we have written n = 2. Now n = 2 is an assignment expression and the
value of this expression is 2, which is a nonzero(true) value and hence the loop condition is always
true.
(D) int
i;
for(i=32000;i<=32767;i++)
printf("%d
",i);
78
C in Depth
Everything seems to be correct with this loop but even then it executes infinitely. This is because
i is an int variable and the range of an int variable is from -32768 to 32767. As the value of i
exceeds 32767 it goes on the negative side and this process goes on, leading to an infinite loop.-
The output\ is-
32000
32001.
32767
-32768
-32767
-1
0 1 2
32767
-32768
..
(E)
float
k=2. 0;
while (k! =3.0)
{
printf("%f\n",' k);
k=k+O.2;
This loop is infinite because the computer represents a floahng point value as an approximation
of the real value. The computer may represent the value 3.0 as 2.999999 or may be as 3.000001.
So our condition (k!=3.0) never becomes false. The solution for this problem is to write the condition
as (k<=3.0).
(F)
int
i=l;
while (i<=5) ;
printf("%d-,i++) ;
This loop will produce no output and will go on executing infinitely. The mistake here is that we
have puta semicolon after the condition. So this loop is treated as:
~
while(i<=5)
This null statement is treated as the bo~y of loop and it keeps on executing.
These were some of the examples where infinite loops occur due to mistakes, but sometimes infinit{
loops are intentionally used in programs. To come out of these loops break or goto statements are used
while(l)
fort
)
do
{
{
}while(l);
These types of loops are generally used in menu driven programs.
5.4
break statement
break statement is used inside ,loops and switch statements. Sometimes it becomes necessary to COlli
out of the loop even before the loop condition becomes false. In such a situation, break statement i
used to terminate the loop. This statement causes an immediate exit from that loop in which thi,

Control Statements
I
I
79
statement appears. It can be written as-
break;
When break statement is encountered, loop is terminated and the control is transferred to the statement
immediately. after the loop. The break statement is generally written along with. a condition. If break
is written inside a nested loop structure then it causes exit from the innermost loop.
Next iteration
of loop
Beginning ofLoop
~
True r-------....,
. ~~--.. break statement
Next statement
Out of loop
Break (control statement)
*P5.26
Program
to
understand
the
use
of
break* /
=include<stdio.h>
=ain(
int
n;
for(n=1;n<=5;n++)
if (n==3)
{
printf ("I
understand
the
use
of
break\n").;
break;
}
printf ("Nilmber
%d\n", n) ;
le
is
is
}
printf ("Out
of
for
loop\n");

C in Depth
Output:
Number = 1
Number = 2
I understand the use of break
Out of for loop
This is a simple program, not of much use but illustrates the use of break statement. Had there been
no break statement, this loop would have executed 5 times. But here as the value of n becomes equal
to 3, break is encountered and loop is terminated.
Now we take a program which checks whether a number is prime or not. A prime number is a number
that is divisible only by 1 and itself. A number n will be prime if remainders of n/2, n/3, n/4
nJ
-Vn are all non-zero, or in other words n is not divisible by any number from 2 to -Vn.
/*PS.27
Program
to
find
whether
a
number
is
prime
or
not*/
#include<stdio.h>
#include<math.h>
main(
{
int
i, num, flag=l;
printf ("Enter
a
number
") ;
scanf("%d",&num) ;
for(i=2;i<7 s qrt(num);i++)
{
•
'-
'0.
...........( .,.....
if
(n\lm%i=±Q )
{ \
printf("%d
is
not
prime\n",num);
f~ag=q;'
break(
}
I
.'
}
~,
if (flag==yY
printf ("%d
is
pr·ime\n", num) ;
...
sqrt( ) isi a library function that returns the square root of a number, we have to include header fi
math.h when we use this function. The range of for loop is from 2 to -Vn, if the number is divisib
by any number from this range means the number is not prime and there is no need to check divisibili
by other numbers, hence the control is transferred out of loop by break statement. Control can cor
out of loop in two situations, after the full execution of loop when loop condition becomes false,
due to break statement. If control comes out after full execution of loop, then the value of flag Vi
be 1 and number will be prime.
.
5.5
continue statement
The continue statement is used when we want to go to the next iteration of the loop after skippi
some statements of the loop.. This contirtue statement can be written simply as-
continue;
It is generally used with a condition. When continue statement is encountered all the remaining stateme

Control Statements
81
(statements after continue) in the current iteration are not executed and the loop continues with the
next iteration.
The difference between break and continue is that when break is. encountered the loop terminates and
the control is transferred to the next statement following the loop, but when a continue statement is
encountered the loop is not terminated and the control is transferred to the beginning of the loop.
In while and do-while loops, after continue statement the control. is transferred to the test condition
and then the loop continues, whereas in for loop after continue statement the control is transferred to
update expression and then the condition is tested.
Begirming of loop
Next iteration
of loop
.,,;;>"----+1 continue statement
continue (control statement)
j
/*P5.28
Program
to
understand
the
use
of· continue
statement*/
4include<stdio.h>
main ( )
{
int
n;
for(n=1;n<=5;n++)
{
if(n==3)
{
printf ("I
understand
the
use
of
continue\n");
continue;
}
printf ("Number
=
%d\n", n) ;
}
printf ("Out
of
for
loop\n");

82
Output
Number = 1
NumbEi" = 2
I understand the use of c'ontinue
Number = 4
Number = 5
,
Out of for loop
C in Depth
/*P5.29
Program
to
find
the
sum
and
avera\:j'='
of
10
positive
integers*/
#include<stdio.h>
main ( )
{
int
i=l, n, sum=O;
float
avg;
printf ("Enter
10
positive
numbers
whi1e(i<=10)
{
\n") ;
printf ("E;nter
number
scanf( "%d",
&n);
if <n<O)
{
%d
\\ Ii) i
, printf ("Enter
only
positive
numbers\n");
continue;
sum+=n;
i++;
\.
}
aVg=sum/10.0;
printf ("Sum
=
%d
Avg
=
%f\n", sum, avg) ;
In this program ifany negative number is enter~d then a message is displayed and the control is transferred
to the beginning of loop.
5.6
goto
This is an unconditional control statement that transfers the flow of control to another part of the
program.
The goto statement can be used as-
goto
label;
label:
statement;
Here label is any valid C identifier and it is followed by a .colon.
Whenever the statement goto label; is encountered, the control is transferred to the statement that i:

}
Output:
Enter the number : 14
Number is even
The label can be placed anywhere. If the label is after the goto then the control is transferred forward
and it is known as forward jump or forward goto, and if the label is before the got6 then the control
is transferred backwards and it is known as backward. jump or backward goto. In forward goto, the
statements between goto and label will not be executed and in backward goto statements between goto
and label will be executed repeatedly. More than one goto can be associated with the same label but
we cannot have same label at more than one place.
The control can be transferred only within a function using goto statement.(Concept of functions will
be introduced in further chapters)
There should always be a statement after any label. If label is at the end of program, and no statements
are to be written after it, we can write the null statement (single semicolon) after the label because
a program can't end with a label.
The use of 'goto' should be avoided, as it is difficult to understand where the control is being transferred.
Sometimes it leads to "spaghetti" code, which is not understandable and is very difficult to debug and
maintain. We can always perform all our jobs without using' goto, and the use of goto is not favoured
in structured programming.
Although the use of goto is not preferred but there is a situation where goto can actually make the
code simpler 'and more readable. This situation arises when we have to exit from deeply nested loops.
To exit from a single loop we can use the break statement, but in nested loops break will take the control
only out of the innermost loop.
/*P5.30
Program
to
print
whether
the
number
is
even
or
odd*/
#include<stdio.h>
main()
{
83
/
(I
)
;
number
the
&n) ;
int
n;
printf ("Enter
scanf ("
%d",
if (n%2:=:=O)
goto
even;
else
goto
odd;
even
printf ("Number
is
even");
goto
end;
odd
printf ("Number
is
odd");
gotoend;
end:
printf("\n") ;
immediately after the label.
Control Statements

C in Depth
fore
)
{
while(
)
{
fore
)
{
if(
)
}
}
l,
goto stop;-J
stop:•
......................
As mentioned earlier, we can always write any code without using goto, so·here also we have anotheJ
way of exiting out of the deeply nested loop.
flag=O;
fore
)
{
while(
)
{
fore
)
{
if(
)
{
flag=l;
break;
/*out of innermost for loop*/
}
}
if( flag= =1)
break;
..
/*out of while loop*/
If(flag= =1) ~
break; ~
/* out of outer for loop*/
We can see that in the case of nested loops, the code using goto is more readable and if it is not USI
then many tests have to be performed.
5.7
switch
This is a multi-directional conditional control statement. Sometimes there is a need in program to ma:
choice among number of alternatives. For making this choice, we use the switch statement. This c
be written as-

Control Statements
85
switch(expression)
{
case
constantl:
statement
case
constant2:
statement
case
constantN:
statement
default
statement
Here switch,
cas~ and default are keywords. The "expression" following the switch keyword can be
any C expression that yields an integer value. It can be value of any integer or character variable, or
a function call returning an integer, or an arithmetic, logical, relational, bitwise expression yielding an
integer. It can be any integer or character constant also. Since characters are converted to their ASCII
values, so we can also use characters in this expr~ssion. Data types long int and short int are also a owe .
-=
-
.
~.
.•
r-es
rr06-~
The constants following the case keywords should be of integer or character type. They can be either
constants or constant expressions. These constants must be different from one another.
We can't use floating point or string constants. Multiple constants in a single case are not allowed; each
case should be followed by only one constant.
Each case'can be followed by any number of statements. It is also possible that a case has no statement
under it. If a case is followed by multiple statements, then it is not necessary to enclose them within
pair of curly braces, but it is n0t an error if we do so. The statements under case can be any valid
C statements like if else, while, for or even another switch statement. Writing a switch statement inside
another is called nesting of switches. Now we'll see some valid and invalid ways of writing switch
expressions and case constants.
int a, b, c;
char d, e;
float f;
j
Valid
switc~(a)
switch(a>b)
switch(d +e-3)
Invalid
switch(f)
switch(a+4.5)
Valid
switch(a>b && b>c)
switch(func(a, b))'
case 4:
case 'a':
case 2+4:
case '.a'>'b': .
Invalid
case 2, 4, 5: .
case a+2:
case a>b:
case a:
case 2.3:
case "second":
case 2 : 4 : 5 :
Now let us see how the switch statement works. Firstly the switch expression is evaluated, then the
1

86
C in Depth
-.
value of this expression is compared one by one with every case constant. If the value of expression
matches with any case constant, then all statements under that particular case are executed. If none
of the case constant matches with the value of the expression then the block of statements under default
is executed. 'default'. is optional, if it is not present and no case matches then no action takes place.
These cases and default can occur in any order.
/*P5.31
Program
to
understand
the
switch
control
statement*/
#include<stdio.h>
main (.)
{
int
choice;
printf ("Enter
your
choice
") ;
scanf("%d",~choice);
switch(choice)
{
case
1:
frintf("First\n") ;
case
2:
printf("Second\n");
case
3:
printf("Third\n");
default:
printf ("Wrong
choice\n");
}
Output:
Enter your choice : 2
Second
Third
Wrong choice
Here value of choice matches with second case so all the statements after case 2 are executed sequentially
The statements of case 3 and default are also executed in addition to the statements of case 2.
Thi~
is known as falling through cases.
Suppose we don't want the control to fall through the statements of all the cases under the matchinl
case, then we can use break statement. If a break statement is encountered inside a switch, then al
the statements following.break are not executed and the control jumps out of the switch. Let's rewrite
the above program using break.
I*P5.32
Program
to
understand
the
switch
with
break
sta·tement*/
#include<stdio.h>
main ( )
{
int
choice;
printf ("Enter
your
choice
") ;
scanf("%d",&choice);
switch(choice)
{
case
1:

Control Statements
printf("First\n"); l
break;
j¥break
case
2:
printf("Second\n") ;
break;
case
3:
printf("Third\n");
break;
default:
printf("Wrong
choice\n
U );
}
}/*End
of
main() */
statement
in
87
Output:
Enter your choice
2 :
Second:
It is -not necessary that if break is present inside switch, then it should be present after all case statements.
Some c,ases may have break while others may not have. So the use of break inside switch is optional,
it mayor may not be used depending on the requirement and logic of the program. The use of continue
.statement is not valid inside switch.
True

The break statement is not logically needed after the last case(or default if it is at the last) but it is
a good programming practice to do so because in future we may need to add new cases at the last.
88
C in Depth
1* P5 .33
Program
to
perform
arithmetic
calculat ions
on
integers * 1
#include<stdio.h>
main ( )
{
char
op;
int
a,b;
printf ("Enter
number
operator
and
another
number
") ;
sca·nf ("%d%c%d", &a, &op, &b) ;
switch(op)
{
case
'+':
printf (".Result
break;
%d\n", a+b) ;
case
'-':
printf ("Result
=
%d\n", a-b);
break;
case
'*'.
printf("Result
%d\n",a*b);
break;
case
'I':
printf(~Result
%d\n",a/b);
break;
case
'%':
printfl"Result
%d\n",a%b);
break;
default:
printf I "Enter
valid
operator\n");
}/*End
of
switch*1
}/*End
of
mainl )*1
Output:
Enter number operator and another number : 2+5
Result = 7
In this program, the valid operator for multiplication is only '*', ifwe want to make 'x', 'X' also valid
operators for multiplication, then we can modify above switch statement like this.
switch(op)
{
case
'-':
result
break;
case
'x':
case
'X':
case
'*'.
result
a-b;
a*b;

Control Statements
break;
case
'/':
89
}/*End
of
switch*/
Here we have added two cases which have no statements. In both these cases, statements of case '*'
will be executed since there is no break after case 'x' and case 'X'.
/*P5.34
Program
to
find
whether
the
alphabet
is
a
vowel
or
consonant*/
#include<stdio.h>
main(
{
char
ch;
printf ("Enter
an
alphabet
") ;
scanf("%c
U
,
&ch);
switch(ch)
{
case
'a' :
case
'e' :
case
\ i
I :
case
'0' :
case
'u' .,
printf ("Alphabet
is
a
vowel \n
U
)
;
break;
default:
printf ("Alphabet
is
a
consonant\n
U );
In this program, if someone enters a vowel in uppercase then it will be regarded as a consonant. One
solution to this problem is to add 5 more cases for uppercase vowels. But we can solve this problem
in another way without adding any cases. We have studied earlier that switch expression can be a function
call returning an int or char. So change the switch expression to tolower(ch) and now our problem
will be solved. tolower() is a library function which converts uppercase to lowercase, header file ctype.h
has to be included to use this function.
Switch statement is very important in menu driven programs. Here we'll make a menu driven(dummy)
program which is identical to a database application. Although this program performs nothing useful
ut it shows us the structure of menu driven programs.
I*P5.35
A
menu
driven
program
using
infinite
loop
and
switch*/
include<stdio.h>
ain( )
{
int
choice;
while (l)
{
printf("l.Create
database\n
U );
print1 (" 2 . Insert
new
record\n
U );
printf ("3 ',Modify
a
record\n
U );
printf("4.Delete
a
record\n
U );

C in Depth
printf("5.Display
all
records\n");
printf("6.Exit\n") ;
printf ("Enter
your
choice
") ;
scanf("%d",&choice);
switch(choice)
{
case
1:
printf ("Database
created ..... \n\n") ;
break;
case
2:
printf ("Record
inserted..... \n\n") ;
break;
case
3:
printf ("Record
modified ..... \n\n") ;
break;
case
4:
printf ("Record
deleted ..... \n\n") ;
break;
case
5:
printf ("Records
displayed ..... \n\n") ;
break;
case
6:
exi t (1) ;
default:
printf ("Wrong
choice\n");
}/*End
of
switch~/
} / *End
of
while* /
} / *Rnd
of
main ( ) * /
Here we have taken switch inside an infinite loop. The function exit( ) is used to tenninate the prograrr
Each ~ime this loop executes, all options will be displayed and we'll be asked to enter Qur choice
Appropriate action will be taken depending on our choice. If we enter choice 6, then we'll come ou
ofthe program. In real programs we'll write full code inside the cases instead of simple printf statementf
5.8
Some Additional Problems
Problem 1
Write a program to find whether a date entered is valid or not. Assume that dates between years 1851
and 2050 are valid.
/ *P5 .36
Program
to
check
whether
a
date
is
valid
or
not. * /
#include<stdio.h>
main( )
{
int . d,m,y;·
int
flag=l, isleap=O;
printf ("Enter
date
(dd/mm/yyyy)
") ;
scanf("%d/%d/%d",&d,&ID,&y) ;
if (y%4==0
&&
y%100! =0
II
y%400==O)
·isleap=l;
if (y<=1850
II
y>=2050)

Control Statements
flag=O;
else
if (m<l
II
m>12)
flag=O;
else
if (d<l)
flag=O;
else
if (m==2)
/*check
for
number
of
-:Jays
in
February* /
{
if (d>28)
flag=O;
if(d==29&&isleap)
flag=l;
91
else
if(m==4
II
m==6
II
m==9
II
m==ll)/*Check
days
in
april,
june,
sept,
nov* /
if (d>30)
flag=O;
}
else if (d>31)
flag=O;
if (flag== 0)
printf ("Not
a
valid
date\n");
else
printf ("Valid
Date
\n");
}/*End
of
main()
*/
Problem 2
Write a program to find difference of two dates in years, months and days. Assume that the dates are
entered in valid range and that the first date falls before second date.
/*P5.37
Program
to
get
difference
of
two
dates
in
years,
months,
days*/
#include<stdio.h>
main(
{
int
dl, d2, d, ml, m2, m, yl, y2, y;
printf ("Enter
first
date
(dd/mm/yyyy)
");
scanf("%d/%d/%d",&dl,&ml,&yl) ;
printf ("Enter
second
date
(dd/mm/yyyy)
") ;
scanf("%d/%d/%d",&d2,&m2,&y2) ;
if(d2<dl)
{
if (m2==3)
{
if(y2%4==O
&&
y2%lOO!=O
II
y2%400==O)
/*check
for
leap*/
d2=d2+29;
else
d2=d2+28;
}
else
if (m2==5 II m2==71Im2==lO Ilm2==12)
d2=d2+30;

C in Depth
else
d2=d2+3l;
m2=m2-1;
}
if (m2<ml)
{
y2=y2-1;
m2=m2+12;
}
y=y2-yl;
m=m2-ml;
d=d2-dl;
printf ("Difference
of
the
two
dates
is
") ;
printf("%d
years
%d
months
%d
days\n",y,m,d);
}/*Endof
main()*/
Here we are subtracting first date from second date, so we can get the difference in years, months
and days by writing:
y = y2 - y1;
m = m2 - m1;
d = d2 - d1;
We have assumed that the second date falls after first date, so y2 will always be greater or equal to
yl and y will always come out positive.
It is possible that m2 is less than m1, in this case m will come out negative, and if d2 is less than
d1 then d will come out to be negative. So before calculating y, m and d we should make sure that
m2 is greater than or equal to m1 and d2 is greater than or equal to d1.
If d2 is less than d1, then we borrow a month from m2 and add the days of that month to d2. Now
since all the months have different number of days, the days added to d2 will depend on the month
borrowed. We'll always borrow a month that is before m2. For example if m2 = 5(May), then we'll
borrow month April from m2, so we'll add 30 to d2.
d2 = d2+30;
m2 = m2-1;
'"
If m2
= 3(March), then we'll borrow month February from m2, so we'll add 28 or 29 (if it is leap
year) to d2.
d2 = d2+28;
m2 = m2-1;
In the program we've done this through nested if else statements.
If m2 is less than m1, then we borrow 1 year{12 months) from y2 and add it to m:L.
n12=m2+12;
y2=y2-1;
Now m2 will ,become greater than m1.
Problem 3
Write a program to multiply two numbers by Russian peasant method. Russian peasant method multiplies
any two positive numbers using multiplication by 2, division by 2 and addition. Here the first number
is divided by 2(integer division), and the second is multiplied by 2 rep~atedly until the first number reduces
to 1. Suppose we hav~ to multiply 19 by 25, we write the result of division and multiplication by 2,
in the two columns like this:

Control Statements
93
19
9
4
2
1
25
50
100
200
400
475
Add
Add
Add
_ ow to get the product we'll add those values of the right hand column, for which the corresponding
left column values are odd. So 25, 50, 400 will be added to get 475, which is the product of 19 and
5, Now we will see how this method can be implemented in program.
I*P5.38
Program
to
multiply
two
numbers
by
russian
peasant
method* 1
:include<stdio.h>
:nain ( )
{
int
a,b,x,y,s:O;
printf ("Enter
two
numbers
to
be
multiplied
") ;
scanf("%d%dH,&X,&y) ;
a:x;
b=y;
while(a>:l)
{
if(a%2!:O)
s:s+b;
a/:2;
b*:2;
}
print'f ("%d
*
%d
Problem 4
I*Loop
till
first
number
reduces
to
1*1
1*1f
first
number
is
odd*1
1 *Add
second
number
to
s * 1
I*Divide
first
number
by
2*1
I*Multiply
Second
number
by
two*1
%d\n H,X,y, s);
Write a currency program, that tells you how many number of 100, 50, 20, 10, 5, 2 and 1 Rs notes
will be needed for a given amount of money. For example if the total amount is Rs 545 then five 100
Rs notes, two 20 Rs note and one 5 Rs note will be needed. This sort of program can be used in ATM
machines,
I*P5.39
Program
to
find
out
the
number
of
notes
required
for
a
given
amount
0 f
money * 1
#include<stdio.h>
main(
int
n, choice, notes;
printf ("Enter
the
total
scanf("%dH,&n) ;
printf ("Enter
the
value
scanf("%dH,&choice);
switch
(choice)
amount
in
Rs
") ;
of
note
from
which
u
want
to
begin
\\ ) i
default:
printf ("Enter
only
valid
values H);

C in Depth
break;
case
100:
notes=n/100;
printf("Number
of
100
Rs
notes
%d\n",notes);
n=n%100;
case
50:
notes=n/50;
printf("Number
of
50
Rs
notes
%d\n",notes);
n=n%50;
case
20:
notes=n/20,
printf("Numbel.
of
20
Rsnotes
%d\n",notes);
n=n%20;
case
10:
notes=n/10;
printf ("Number
of
10
Rs
notes
%d\n" ,notes) ;
n=n%10;
case
5:
notes=n/5;
printf ("Number
of
5
Rs
notes
%d\n" ,notes) ;
n=n%5;
case
2:
notes=n/2;
printf ("Number
of
2
Rs
notes
%d\n", notes) ;
n=n%2;
case
1:
notes=n/1;
printf("Number
of
1
Rs
notes
%d\n",notes);
}
printf("\n") ;
Output:
Enter the total amount in Rs : 748
Enter the value of note from which u want to begin : 50
Number of 50 Rs notes =
14
Number of 20 Rs notes
= 2
Number of 10 Rs notes = 0
Number of 5 Rs notes
=
1
Number of 2 Rs notes = 1
Number of 1 Rs notes
=
1
The logic of the program is simple, break statements are not used. The default statement is in the beginning
and there is a break after the default.
Problem 5 .
Write a program that finds out the day of week from a given date.
The formula for
calcula~ing the day is-

Control Statements
day = (y +j + f - h
+ fh) % 7;
j = julian day of the date
y = year of given date(in 4 digits)
f = (nt part of (y-l)/4 '
h = int part of (y-l)/lOO
fh = int part of (y-l )/400
The value of varia~le day tells us the day of week.
Value of variable day
Narne 'of day of week
0
Saturday
-
1
Sunday
2
Monday
3
Tuesday
4
Wednesday
5
Thursday
6
Friday
95
In the above formula, julian day ofa date represents the day of year on which the date falls. Julian
day of 1st Jan is 1, of 2nd Feb is 33, of 31 s1 Dec is 365(366 if leap year).
Now let's decide the structure of our program. Once we get the value of variable day, we can use
switch to print the n~me of day of the week from the value of day.
To ca,lculate the value of day we'll have to find out the value of julian day. Let's assume that the day,
month and year of entered date are stored in variables d, m and y respectively. We take another variable
j for the value of julian day.
Initially the value of j is taken equal to d, and then days of previous months are added to j to get the-
value of julian day. We can use switch statement for this and take m as the switch variable.~
j =d;
switch(m)
{
case
2:
case
3 :
case
4 :
case
5 :
case
6:
case
7:
case
8 :
case
9:
case
10:
case
11:
case
12:
j+=31;
break;
j+=31+28;
break;
j+=31+28+31;
break; .
j+=31+28+31+30;
break;
j+=31+28+31+30+31;
break;
j+=31+28+31+30+31+30;
break;
j+=31+28+31+30+31+30+31;
break;
j+=31+28+31+30+31+30+31+31;
break;
j+=31+28+31+30+31+30+31+31+30;
break;
j+=31+28+31+30+31+30+31+31+30+31;
break;
j+=31+28+31+30+31+30+31+31+30+31+30;
break;
}
Suppose the date is 2nd May 2002, then d= 2, m = 5, so the control will go .in case 5, and julian
day will be 2+31+28+31+30 = 122
The above logic applied in switch statement was simple but as we can see the whole switch statement

is confusing to read and understand. If we omit the break statements, take the cases in descending
order, and take the switch variable as m-1 then we can accomplish our job by writing a very concise
switch statement.
96
j =d;
switch(m
-
1 )
{
case
11:
j+=30;
case
10:
j+=31;
case
9:
j+=30;
case
8 :
j+=31;
case . 7:
j+=31;
cas.e
6 :
j+=30;
case
5 :
j+=31;
case
4 :
j+=30;
case
3 :
j+=31;
case
2 :
j +=2_8;
case
1:
j +=31;
}
C in Dept?
./
Here if d = 2, m= 5 theri control will go in case 4(5-1), and since there is no break, all statements
of cases 4, 3, 2, 1 will be executed. Hence j = 2+30+31+28+31 = 122. This shows that we can use
the flexibility of switch statement according to the need and logic of the program.
We have found out the julian day, but what if the year is leap. In that case we'll have to add 1 to the
julian day, if the month is other than January or February. This is how we'll do it.
"
if (y%4==0&&y%100 ! =0 II y%400==0)
/ *check
for
leap
year* I
if(m!=1&&m!=2)
j=j+1;
Recall that a non centennial year is leap if it is divisible by 4, and a centennial year (divisible by 100)
is leap if it is divisible by 400.
~
/ *P5. 40
Program
to
find
day
of
week
from
a
given
date* /
#include<stdio.h>
main (.
{
int
d,m,y,j,f,h,fh,day;
.printf("Enter
date
(dd/mm/yyyy)
scanf("%d/%d/%d",&d,&m,&y);
j=d;
swi tch (m
-
1)
{
case
11:
j+=30;
case
10:
j+=31;
case
9 :
j+=30;
case
8 :
j+=31;
case
7 :
j+=31;
case. 6·
j +=3 0;
case
5 :
j+=31;
case
4 :
j+=30;
case
3 :
j+=31;
\\ );
.'

Control Statements
case
2:
case
1:
j+=28;
j+=3l;
97
}
if (y%4==0&&y%100! =0 II y%400==O)
if(m!=1&&ml';'2)
j=j+l;
f=(y-l)/4;
- h= (y-l) /100;
fh=(y-l)/400;
day=(y+j+f-h+fh)%7;
switch(day)
{
.:::::ae
0:
case
1:
case
2:
case
3:
case
4:
case
5:
case
6:
prin~f ("Saturday\n");
break;
printf ("Sunday\n");
break;
printf ("Monday\n");
break;
printf ("Tuesday\n");
break;
printf ("Wednesday\n");
break;
printf ("Thursday\n");
break;
printf ("Friday\n");
break;
}
}/*End
of
main( )*/
Problem 6
Write a program to print triad numbers. Any three numbers will be triad numbers if they satisfy the·
ollowing conditions-
1.
Each number is a three digit number.
All the digits in the three numbers (total 9
di.~its) should be different.
3.
Second number should be twice the first number and third number should be thrice the first number.
For example-
219
438
657
267
534
801
I*P5.41
Program
to
print
triad
numbers * /
=include<stdio.h>
ain(
{
int
m,n,p,num;
int
i,k,dl,d2,d3;
for(num=100;num<=999/3;num++)/*Loop
A*/
{
for (i=num; i<= 3 *num; i+=num) / * loop
B
* /
{
k=i;
dl=k%lO;
k/=lO;
d2=k%10;
k/=lO;
d3=k%10;
k/=lO;
if (dl==d2
II
d2==d3
II
d3==dl)
goto
nextnum;
} / *Endof
loop
B* /

98
C in Depti
for(m=num;m>O;m/=lO) /*Loop
c*/
{
dl=m%lO;
for(n=num*2;n>O;n/=lO) /*Loop
D*/
{
d2=n%lO;
for(p=num*3;p>O;p/=lO)
/*Loop
E*/
{
d3=p%lO;
if (dl';'=d211 d2==d311 dl==d3)
goto
nextnum;
} / *End
of
Loop
E* /
} / *End
of
Loop
D* /
}/*End
of
loop
C*/
p r i n t f ( "% d
%d
%d \ t"
I n um I n um* 2 , n um* 3 ) ;
nextnum:
} / *End
of
loop
A* /
}/*End
of
main( )*/
Loop A is used to generate numbers. Since triad numbers are three digit numbers, bence this loop sta
from lQO. The upper limit of this loop is 333 (999/3) because for numbers more than 333, 3*num v
not be a three digit number.
Loop B is inside loop A, and it executes three times, for i = num, i = 2*num and i = 3*num. It fil
out whether the three digits in a number(i) are different or not. In this loop dl" d2, d3 are digits
a single number, and if any two digits are found to be sar-.f': then we again go to the update express
of loop A and check for next number.
Loops C, D, E are nested loops which find out whether there are any common digits in the tb
numbers(num, 2*num, 3*num). Here dl, d2, d3 are digits of num, 2*num, 3*num respectively. If:
two digits are same then we go to the update expression of loop A to check for next number.
Note that in loops C, D and E, the dig\ts of different numbers are compared, and in loop B digit1
a. single number are compared.
Problem 7
Write a program to find out the Least Common Multiple, and Highest Common Factor of two numb
/*P5.42
Program
to
find
the
LCM
and
HCF
of
two
numbers*/
#include<stdio.h>
main ( )
{
int
x/y'/a/b;
printf ("Enter
two
numbers
scanf ("%d
%d"
I &x , &y) ;
a=x;b=y;
while(a!=b)
{
if (a<b)
a=a+x;
else
b=b+y;
" ) i
.

Control Statements
}
printf("LCM
of' %d
and
%d
is
%d\n",x,Y,a);
a=x;
b=y;
while(a!=b)
{
if(a>b)
a=a-b;
else
b=b-a;
}
printf ("HCF
of
%d
and
%d
is. %d\n", x, y, a) ;
}
Output
Enter two numbers : 60 135
LCM of 60 and 135 is 540
RCF of 60 and 135 is 15
5.9
Pyramids
*
1
1
1
2
1
**
22
1 2
2 3
34
01
* * *
333
123
4 5 6
456
101
****
4444
123 4
7 8 9 10
5678
0101
*****
5 5 5 5 5 12345
11 12 13 14 15
6789 10
10 101
(a)
(b)
(c)
(d)
(e)
(f)
The program for pyramid (a) is-
=tain( )
{
int ·i,j,n;
printf ("Enter
n
") ;
scanf("%d",&n) ;
for(i=l;i<=n;i++)
for(j=l;j<=i;j++)
printf("*
");
printf("\n");
I*for
next
line
of
pyramid*/
5
54
543
5432
5.4 3 2 1
(g)
5
44
333
2222
1 1 111
(h)
99
Here the outer for, loop is for number of lines and the inner loop is for number of stars in each line.
We can see that the number of stars is equal to the line number, hence the inner loop will execute once
for first line, twice for second line, thrice for third line and so on;
.
,-
, .
In the above program if we print the value of i, then we'll get the pyramid (b), and on printing the
value of j we'll get the pyramid(c).
'
For the pyramid (d) we'll take a variable p = 1, and write the printf statement as-
printf("%3d",p++);

For pyramid (e) we'll print the value of i+j, for pyramid (f) we'll print 1 if (i+j) is even and print 0
if (i+j) is odd.
For pyramid (g) we have to print (n+ I-j) and for pyramid (h) we have to print (n+ I-i). These two
pyramids can also be written by reversing the loops and then printing the values of i and f For example
code for pyramid (g) can be written as-
100
C in Depth
for(i=n;i>=l;i- -)
('
for(j=n;,j>=i;j- -)
. printf ("%3d", j) ;
printf("\n") ;
* * * * *
55555
* * * *
4444
* * *
333
* *
22
*
1
(i)
(j)
The code fo~ pyramid (i) is-
for(i=n;b'=l;i- -)
{
for(j=l;j<=i;j++)
printf("*
");
printf("\n") ;
12345
1234
123
12
1
(k)
54321
5432
543
54
5
(1)
1 1 111
2222
333
22
1
(m)
*
**
***
**** .
*****
(n)
*
* *
* * *
* * * *
*****
(0)
We can see that line 1 has 5 stars, line 2 has 4 stars and so on. The outer loop is for number of line
and will execute n times, but here we have taken it as a decreasing loop. So for first iteration of oute
. loop, inner loop will execute n times, for second iteration of outer loop inner loop will execufe n-l time
and so on.
For pyramids (j), (k), (1), (m) we'll print values of i, j, (n+ I-j), (n+I-i) respectively. The pyramids (
and (m) can also be printed by reversing both the loops and then printing i and j.
For pyramid (n), we have to print spaces before printing stars.' The code for it is-
for(i=l;i<=n;i++)
/*loop
for
number
of
lines*/
{
for(j=l;j<=n-i;j++)
printf("
");
for!j=l;j<=i;j++)
printf("*");
printf("\n") ;
/*loop
for
printing
spaces* /
. /*loop
for
printing
stars* /
/*for
next
line
of
pyramid*/'
}
The code for pyramid (0) is same as this one, only a space is given after star in the printf stateme

----~
Control Statements
101
*
*
1
1
5
'*********
I
***
***
123
232
545
; *******
1* ****
I
*****
*****
12345
34543·
54345
I
*******
\ *** .. ***
1234567
4567654
5432345
***
*********
*********
123456789
567898765· 543212345
*
(P)
(q)
(r)
(s)
(t)
(u)
.-__ Third part .
First part ---+I
*****i '------'
Second part
The code for pyramid (p) is-
for
(i=l; i<=ni i++)
{
/
}
for(j=lij<=n-iij++)
printf("
");
for(j=lij<=iij++)
printf("*")i
for(j=l;j<i;j++)
printf("*");
printf("\n") i
/*loop
for
number
of
lines
in
pyramid*/
/*loop
for
spaces
(first
part)*/
/*loop
for
second
part*/
/*loop
for
third
part*/
/*for
next
line
of· pyramid* /
Here first part and second part are written same as in pyramid (n) and third part is written same as
in pyramid (a).
,
The code for pyramid (q) will be the same, only the range of first for loop for spaces will be from
1 to 2*(n+I-i) and there will be a space after star in the printf statements.
----..
The loops for pyramids (r), (s) and (t) will be same as that ofpyramid (p), but here we'll take a variable
p and print its value.
For pyramid (r) we'll initialize the value of p with 1 each time before second inner for loop; and then
print the value of p++ in the last two for loops.
.
For pyramid (s) we'll initialize the value of p with i before second inner for loop, and then print the
value of p++ in second for loop. After this the value of p is decreased by I and then the value of
- -p is printed in the third for loop.
For pyramid (t) we'll initialize the value of p with n before second inner for loop, and then print the
value of p- - in second loop and p++ in third loop. The vallie of p has to be increased by 2 before
third for loop.
The code for pyramid (t) is-
for (i=l; i<=n;~i++)
/ *loop
for
number
of
lines
in
pyramid* /
{
for(j=l;j<=n-i;j++
/* loop
for
spaces
(first
part) */

--"",
printf("
");
p=n;
for(j=l;j<=i;j++
printf ("%d" ,p- -);
p=p+2;
for (j =1 ;. j.< i ; j + + )
printf("%d",p++) ;
printf("\n");
I*loop
for
second
part
*1
I*loop
for
third
part
*1
1 *
for
next
line
of
pyramid
* 1
C in Dr;pth
}
The code for inverted pyramid (u) is-
for(i=l;i<=n;i++)
{
for(j=l;j<=i;j++)
printf("
");
for ( j =1; j < = (n - i) ; j ++ )
printf("*");
.
for(j=l;j«n-i) ;j++)
printf("*");
printf("\n") ;
*
1
1
5
***
123
232
545
*****
12345
34543
54345
*******
1234567
4567654
5432345
******"'**
123456789
567898765
543212345
*******
1234567
4567654
5432345
*****
12345
34543
54345
***
123
232
545
*
1
1
5
(v)
(w)
(x)
(y)
'"
The diamond (v) can be obtained by joining pyramids (p) and (u) so the code is also same as that of
(p) and (u), Note that if n = 5 then the upper pyramid has 5 lines while inverted pyramid has only
4 lines in this diamond. So the loop for the inverted pyramid here will range from 1 to n-L instead of
1 to n. The code for diamond (v) is-
for(i=l;i<=n;i++)
{
for(j=l;j<=n-i;j++)
printf("
");
for(j=l;j<=i;j++)
printf("*");
for(j=l;j<i;j++)
print·f("*");
printf("\n") ;
}
for(i=l;i<=n-l;i++)
{
for(j=l;j<=i;j++)
printf("
");

Control Statements
for(j=l;j<=n-i;j++)
printf("*");
for(j=l;j<n-i;j++)
printf("*");.
printf("\n") ;
103
The structure of loops for diamonds (w), (x) and (y) will be same as that of (v), and the logic is similar
to that of pyramids (r), (s) and (t) respectively. Apply the same logic (of variable p) in the second outer
for loop also.
The code for diamond (y) is-
for(i~l;i<=n;i++)
{
for(j=l;j<=n-i;j++)
printf("
");
p=n;
for(j=l;j<=i;j++)
print f ( "%d" ,p- -) ;
p=p+2;
for(j=l;j<i;j++)
printf("%d",p++) ;
printf("\n") ;
}
for(i=l;i<=n-l;i++)
{
for(j=l;j<=i;j++)
printf("
");
p=n;
for(j=l;j<=n-i;j++)
printf ("%d" ,p- -);
p=p+2 ;
for(j=l;j<n-i;j++)
printf("%d",p++);
printf("\n") ;
In the diamond (x) initialize p with i in first for loop but with n-i in the second for loop.
Exercise
Assume stdio.h is included in all programs;
(1) main()
{
int
a=9;
if(a=5)
printf ("It
is
important
to
be
nice\n");
else
printf ("It
is
nice
to
be
important\n");
(2) main(

-/"
104
int
a=20, b=3;
if(a<lO)
a=a-5;
b=b+5;
printf("%d
%d\n",a,b);
I
(3) main (
I {
':
int 'a=9,b=O,c=O;
if ( ! a < 1°&& !b I Ic)
printf ("Difficulties
make
us
better\n");
else
printf ("Difficulties
make
us
bitter\n");
(4.) main (
int
i=l, j =9; .
. if(i>=5&&j<5);
i=j+2;
printf("%d\n",i);
(5) main(
int
a=O,b=O;
if ( ! a)
{
b=!a;
if (b)
a=!b;
}
printf("%d,
%d
\n",a,b);
(6) main(
{
int
a=5;
begin:
if (a)
{
C in Depth
....
It
printf ("%d
a- -;
goto
begin;
(7) main (
{
1/
I a) ;

Control Statements
int
a=5;
begin:
if(a)
printf("%d\tn,a);
a- -;
goto
begin;
(8) main(
{
int
a=2,x=lO;
if(a==2)
if (x==8)
printf("a
is
equal
to
2
and
x
is
equal
to
8
n );
else·
printf("a
is
not
equal
to
2
n );
(9) main(
{
int
a=6,b=4;
while (a+b)
{
105
printf( "a
a=a/2;
b%=3;
(lO)main(
{
int
i=lO;
do
{
%d,
b
-%d\nn ,a, b) ;
printf(~i=%d\nn,i);
i=i-3;
}while(i) ;
(11 )main (
{
int
i,j=lO;
for(;i=j;j-=2)
printf("%d. ",j);
(12)main(
{
int
i,j,x=O;
for(i=O;i<5;i++)
for(j=i;j>O;j- -)

x=i+j+l;
printf("x
%d\n",x);
-'",
}.
(13) main (
{
C in Depth
int
i, index=O;
for(i=O;i<lO;i++)
C'
,
'int
i=O;
while(i++<5)
inde'x++ ;
},
printf ("index
=
%d\n", index);
(14)main(
{
int
i;
for(i=1;i<10;i++)
if(i==3)
continue;
printf("%d
",i);
(15)main(
{
int
i=l;
while(i<lO)
[
if(i==3)
continue;
printf("%d
",i);
i++;
(l6)main(
{
int
i, sum;
for(i=O;i<lO;i+=3)
sum
+=i*i;
printf("%d",sum) ;
(17)main(
..
{
int
c=50;
fort
;c;

Control Statements
c- -;
printf ("c
(18)main( )
{
%d\n",c);
107
char
ch= 'A' ;
switch(ch)
{
case
'A':
case'B':
ch++;
continue;
case
'C':
case
'D':
ch++;
(19)main(
{
int
var=2, x=l, y=2;
switch(var)
{
case
x:
x++;
case" y:
y++;
(20)main(
{
char
ch=' A' ;
while(ch<='D')
{
switch(ch)
{
case
'A':
case'B':
ch++;
continue;
case
'C'":
ch++;
printf("%c",ch) ;
(21)main(
{
int
n,sum=O;
for(
{
case
'D':

C in Depth
-/"",
scanf("%d",
&n);
sum+=p;
if(sum>lOO)
break;
(22)main(
(
int
i ,. suml=O, sum2=O;
for(i=1;i<5;i++)
suml+=i;
i=l;
while(i<=i)
{
i++;
sum2+=i;
printf ("%d
%d\n",i,suml,sum2) ;
1.
..oJ
2,
3.
4.
5.
6.
7.
8.
9.
10.
11.
Programming Exercise
Write a program to print prime numbers from 1 to 99. (Hint: 'See P5.27, instead of entering a
number, take a for loop that generates numbers from 1 to 99)
~
Write a program to enter a humber and find the reverse of that number.
Input a number and a digit and find whether the digit is present in the number or not, if present
then count the number of times it occurs in the number.
Write a program to acceptlj-ny number n and print the sum of square of all numbers from 1 to
n.
~
Write a program to accept any number n and print the cube of all numbers from 1 to n which
are divisible by 3.
Write a program to accept any six digit number and print the sum of all even digits of that number
and multiplication of all odd digits.
Write a program to findout the value ofx raised to the power y, where x and yare positive integers.
Write a program to accept any number up to six digits and print that in words.
For example- 1265 = one two six five
Wri,te a program to enter a number and test whether it is a fibonacci number or not.
Write a program to print all the pythagorean triplets less than 50. Any three numbers x, y, z are
called pythagorean triplets if x < .Y < z and X2+y2 = Z2
Find the sum of these series up to n terms where x is an integer entered by the user.
I + 2 + 4 + 7 + II + 16 +
1+ 11 + III + 1111 +.....
x + x2 +x3 +x4+
..
X + x2 _x3 + x4+
.
I/x - l/x 2 +1/x3 -l/x4

Control Statements
Answers
109
(1)
It is important to be nice
The variable a is assigned the value 5, and so the if condition becomes true.
(2)
20
8
(3)
Difficulties make us better'
(4)
11
There is a semicolon after the if part, and it is considered as null statement.
(5)
0, 1
(6)
5
4
3
2
1
(7)
This program runs infinitely, because the goto statement is not inside the if structure.
(8)
a is not equal to 2.
Here the else part is paired with the second if, if we want to pair it with the first if then we should
enclose the second if inside parentheses.
(9)
a = 6, b = 4
a = 3, b = 1
a = 1, b = 1
a = 0, b = 1
a = 0, b = 1
a = 0, b = 1
The value ofb never becomes zero, and so the condition never becomes false resulting in an infinite
loop.
(10) 10
7
4
1
-2
-5
-8
.
The value of i never becomes zero, resulting in an infinite loop.
11) 10
8
6
4
2
The loop terminates when the value of assignment expression ( i = j ) becomes zero.
12)x.= 6
13) index = 50 .
14) 1 2 4 5 6 '7 8 9
5) This program prints 1 2 and [hen goes into an infinite loop.
6) The variable sum is not initialized to zero, if it is initialized to zero then the result will be 126.
7) c =0
8) Error, continue can't be used ii1side switch.
9) Error, only constant expressions can be used in switch.
_0) DE
Here the continue' statement is inside the while loop.
-1) The loop will enter numbers, and will terminate when the sum of these numbers exceeds 100.
2) 5
. 10

..
Chapter 6
functions
A function is..a self-contained subprogram that is meant to do some specific, well-defined task. A (
program consists of one or more functions. If a program has only one fupction then it must be th
maine ) function.
6.1
Advantages Of Using_Fun.ctions
1.
Generally a difficult problem is divided into sub problems and then solved. This divide and conque
technique is implemented in C through functions. A program can be divided irito functions, eac
of which performs some specific task. So the use of C functions modularizes and divides the wor
of a program.
2.
When some specific code is to be used more than once and at different places in the progran
the use of functions avoids repetition of that code.
3.
The program becomes easily understandable, modifiable and easy to debl!g and test. It beconif
simple to write the program and understand what work is done by each part of the program
4.
Functions c'an be stored in a library and reusability can be achieved.
.
C programs have two types' of functions-
1.
Library functions
...
2.
User-defined functions
6.2
Library Functions
C has the facility to provide library functions for performing some operations. These functions are prese
in the C library and they are predefined. For example sqrt( ) is a mathematical lib~ary function whil
is used for finding out the square root of any number. The functions scanf( ) and printf( ) are inp
output library functions. Similarly we have functions like strlen( ), strcmp( ) for string manipulatior
To use a library function we have to include corresponding header file using the preprocessor directi
#include. For example to use input output functions like printf( ), scanf( ) we have to include stdio,
for mathematical library functions we have to include math.h, for string library string .h should'
included. The following program illustrates the use of library function sqrt( ).
/ *P6. 1
Program
to
#include<stdio.h>
#include<math.h>
main( }
{
double
n, s;
printf ("Enter
find' the
square
root
of. any
nunber. * /
a
number
") ;

Functions
scanf (''%If'', &n) ;
s=sgrt (n) ;
printf ("The
square
root
of
%. 2lf
is
%.2lf\n"
'n,
s
);
111
}
Output:
Enter a number : J6
The square root of 16.00 is : 4.00
In this program we have used three library functions - printf( ), scanf( ) and sqrt( }. We'll learn more
about library functions later in this chapter.
'-
6.3
User..Defined Functions
Users can create their own functions for performing any specific task of the program. These types
of functions are called user-defined functions. To create and use these functions, we should know about
these three things- ~
1.
Function definition .
2.
Function declaration
3.
Function call
Before discussing these three points we have written two simple programs that will be used for reference.
The first program draws a line and the second one adds two numbers.
/ *P6. 2
Program
to
draw
a
line* /
#include<stdio.h>
void
drawline (void) ;
/*Function
Declaration* /
main( )
{
draw1ine( ).;-
/*Function
Call*/
}
void
drawline (void)
/ *Function
Definition* /
\
{
int
i;
for(i=1;i<=80;i++)
-
prin t f (" _ " ) ;
/*P6.3
Program
to . find
the
sum
of
two
numbers* /
#include<stdio.h>
int
sum(int
x, inty);
/*Function
declaration*/
main ( ) .
~,.
{
and
b
int
a,b, s;
printf ("Enter
values
for
a
scanf ("%d
%d", &a, &b) ;
s=sum (a,
b);
printf ("Sum
of
%d
and
%d
is
/I
)
;
/*Function
call*/
%d \ n" ,a, b, s) ;
\
}
int
sum (int
x, int
y)
int
s;
/*Function
definition*/
- ----
/

-/"'"
112
S=X+Y;
re'turn
s;
6.4
Function Definition
, C in Dept
The function definition consists ·ofthe whole description and codt(of a function. It tells what the functiol
is doing and what are its inputs and outputs. A function definition consists of two parts - a functiOl
header and a funp!ion body. The general syntax of a function definition is-
func_name (
typel
argl, type2
arg2,
)
'.
local
variables
declarations;
statement;
return(expression) ;
\
The first line in the\function definition is known as the function header and after this the
b..Q.d~ of thl
function is written ~nclo~ed in curly braces'
J
.
.
,
The return_type denotes the type of the value that will be returned by the function. The return_typl
is optional and if omi,tted, ~~l!rped__to .bejQcby_default~A function can return. e~ther one value 0
no valqe. If a function doe~ not return any value then void should be wfitten in place of retul'}UyPe
func_name specifies t~e nathe of the function and it can be any valid C identifier. After function name
the argument declarati<i>Ds are given in parentheses, which mention the type and name of the arguments
These are known ~s formal argumen,!Land used to accept values. A function can take any number 0
arguments or even no argument at all. If there are no arguments then either the parentheses can bl
left empty or void can be written inside the parentheses.
The body of function is a compouqd statement (or a block), which consists qf declarations of variables
and C statements followed 'by an optional return statement. The variables declared inside. the fu~ctiOl
are known as local variables, since they are local to' that function only, i.e. they have existence onl;
in the function in which they are declared, they can not be used anywhere else in the program. Then
can be any number of valid C statements inside a function body. The return statement is optional. I
may be absent if the function does not return any valu~.
The function definition can be placed anywhere in the program. But generally all definitions are place<
after the maine ) function. Note that a function definition cannot be placed inside another functiOl
definition. Functiqn definitions can also be placed in different files., .
. "
In P6.2 the function definition is-
void
drawline (void)
{
int
i;
for(i=1;i<80;i++)
printf ("-") ;
}
Here the function is not returning any value so void is written at the place of return_type, and sincl
•
it does not accept any arguments so void is written inside parentheses. The int variable iis decfare<
inside the function body' SC' it is a local variable and can be used insid~ this function only.

113
1n P6.3 the function definition is-
int
sum (int
x, int
y)
int
s;
s=x+y;
return
s;
This. function returns a value of type int ,because int is written at the place of return_type. This function
takes two formal arguments x and y, both of type int. The variable s is declared inside the function
so it is ~ local variable. The formal arguments x and yare also used as local variables inside this function.
6.5
r•••ti•• Call
The function definition describes what a function can do, blJt to actually use it in the program the function
should be called somewhere. A function is ,called by ~iirlply writi~g its ~~n~~ followed by the argument
list inside the parentheses. .
. .
func_nam~(argl,arg2, arg3 ...)
These arguments arg I, arg2, ,...are called actual arguments..
Here func_name is known as the called function while the function in which this fl,lnction call is placed.
. known as the calling'function: For'example in' the program P6.3, maine ) is the calling function, sum()
. the called function and a, b are actual' arguments.' The function call is written on the right hand side
oJ the assignment operator as-
.
"
.
s = sum(a, b);
Even if there are no actual arguments, the function call should have the empty parentheses, For example
in program P6.2, the function call is written as- ..
.
drawline( );
When a function is called, the control passes to the called function, which is ex<;cuted and after th1s ,
the control is transferred to the statement following the function call in the calling function. The following
gure shows'the transfer of control when two functions funcl( ) and' func2( ) are called from mainO. '
maine )
{
}
statementl;
funcl( );
statement2; 4--+------1
statement3;
func2( 9, 3J
statement4;
statementS;
funcl( )
{
}
func2( int a, int b)
{
Transfer of control when function is called

114
C in Depth
If the function returns a value, then this function call can be used like an operand in any expression
/'"
anywhere in the program. The type and value of this operand will be the type and value of the return
value of the function. For example-
s = sum(a"b);
,
/*Assigning the return value of sum( ) to variable s*/
q = rriax(x, y)*IO;
/*return value of max{ ) is multiplied by 10 and assigned to variable b*/
if ( isprime(x.)' =' =1')
/*return value of isprime( ) is used in if condition*/
printf("Number is prime');
printf(",%d\n", sum(a+b) );
/*Return value of sum( ) is printed*/
If the function is declared as void then it cannot be used in this way in any eJSPression. For example
it would be meaningless and invalid to write an expression like this-
/
s = drawline( );
. •
1:J;7 I
~
A function call can be used as a statement, if a semicolon is placed after it. In this case if the function
.returns any value, it is just discarded. For example- "'--
/'
.
.
draw(x, y);
display( a, b, c);
printprimes( );
A function
c~ll, cannot occur on the left hand of an assignment statement.
func(x, y) ~ a; /* Invalid */
The code 'of a function is executed only when it is called by some other function. If the function .
defined and not called even once then it's code will never be executed. A function can be called mo
'.
than once, so the code is, executed each time it is called. The execution of a function finishes eith
when the closing braces of the function body are reached or if return statement is encountered:
6.6
Function Declaration
I'
The calling function needs information about the called function. If definition of the called function
placed before the calling function, then declaration is not needed. For example if in progra~ P6.3, '"
write the definition of sum( ) beforemain( ), then declaration is not needed.
/*P6.4
Program
to
#include<stdio.h>
(-iDt' sum! int
x, int
~~..
int
.S;'
s ==J:c+.y.i .
:r:eturn' s;
}
main ( )
{
.
,
find r the
. y)>.
!
sum
of (two· numbers*/
/*Function
definition* /
/
It
int
a,b,s;
pr'intf ("Enter
values
for
a
a1'J.d
t!
") ;
scanf("%d
%d",&a,&b);
I
"
'~
s==s~m (a ,,p) i
/ *Function
call * /
'printf("Sum
of
%d
and
%d
is'%d\n",a,b,s);

Functions
115
Here the definition of sum( ) is written before maine ), so maine ) knows everything about the function
sumO. But generally th~ function maine ) is placed at.the top and all other functions are placed aft~r'
i~. In'this case, function declaration is n·eeded. The function declaration is 'also known -as the function'
prQtbtyp~,.an~ it inf?rms the ~ompiler about the following three things-
1.
Name of the'function,:
2.
Number and .type of,argumetit~ received by the functi9n.
3.
Type of value returned by the function,.
Function declaration tells the compiler that a function with these features will be defined and used later
in the program. The general syntax of afunction declaratioJ'l is-
.
,
return_type
func_name(typel argl, type2 arg2, .. ,.....)j
This looks just like the header of function definition, except that the1;e is a semicolon at the end, The
names of the arguments while' declarihg a functio~ are option~l.· These' are only used for descriptive'
purposes. So we can w~ite the declaration in this way also- ,
.
'.
return_type
func_name(typel,
type2, ........);
,
,
.
In program P6.2 the declaration is written as-
void drawline(void); .
In program P6.3 tbe declaration is written as-
int sUn:J.(int x,. into y);
Now we'll write two more example programs that use functions.
/ *P5. 5
Program
that
finds
whether
a
number
is
even
or
odd* /
#include<stdio.h>
void
f indC
int
n);
main()
.
{
(I- ) 1 co -
. -
er~b)~
1
/I
) i
larger
of
two
numbers* /
odd\n", n) ;
even \n" ,n) ;
is
int
n)
int
a, b;.
printf ("Enter
two
numbers
scanf("%d%d",&a,&b);
r
if (~%2==O)
printf ("%d
else
printf ("%d
is
/*P6.6
Program
that
finds. the
#include<stdio.h>
int
ma'x (intx, int
y).;
main( )...
~.,
,'.
{
}
void
find (
{
int
num;-·
printf ("Enter
a
number
".) ;
scanf("%d",&num)
~
find(num);
.

116
printf ("Maximum
of
%d
and
%d
is
%d\n",a,b,max(a,bl f;
C in Depth
}
-max ( in t<
x, int
y)
(
c
if (x>y:)
return
x;
else
return
y;
!-
\
6.7
.return statement
The return statement is used in a function to return a value to the calling function. It may also be used
for immediate exit from the called function to the calling function without rei~ming a value. ,~
This statement can appear anywhere inside the body of the function. There are two ways in. whicb
it can be used-
.
return;
t
return ( expression );
Here return is a keyword. -The first form of return statement is used to terminate the function witho
retuming any value. In this case only return keyword is written. The following program uses this form
of return statement.
/*P6.7
Program
to
understand
the
use
of
return
statement*/
#include<stdio.h>
void
funct (int
age, float
ht);
main.( )
{
Oint
age;,
float _ ht;
printf ("Enter
age
and
height:
) ;
scanf("%d
%f",
&age,
&ht);
funct(age,ht) ;
}
void
funct (int
age, float
ht)
{
if (age>25)
{
printf("Age
should
be
less
than
25\n");
return;
}
if (ht<5)·
{
printf ("Height
should
be
more
than
5\n");
return;
}
printf("Se)ected\n");
The second form of return statement is used to terminate a function and return a value to the callinl
function. The programs P6.3 and P6.6 use this second form of return statement. The value
retu,rne~

Functions
117
by the return statement may be any constant~ variable, expression or even any other function call(which
returns a value). For example in program P6.3 we can directly write return (x+y) instead of-taking
a variable and returning,it. Similarly in program P6.6 we can directly wrife return ( x>y ? x :y)
Some other examples of valid return statements are-
return 1;
return ~;
return ( x+y'!'z );
return ( 3 * sum(a, b) );
It is optional to enclose the returning value in parenthese,s:
We can use multiple return statements in a function but as soon as first return statement is encountered
the function terminates and all the statements following it are not execut~d.'
, "
The next function compares two dates( dllmllyl
and d2/m2/y2) and returns 1 if first date is smaller,
returns -1 if second date is smaller , returns 0 ,if both dates are same. In tlii~' function we have used '
7 return'statements.
int
cmpdate(
int
d1"
int Im1,
int
y1,
int
d2,
int
m2,
int
y2)
if (}i'1<y2),
'return
1;,
,if (y1>y2)
return
-,1;
if (ml<m2)
return
1;
if (m1>m2)
return
-1;
if (dl<d2)
return
l;
if(d1>d2)
return
-1;
return
0;
}
The next program uses a function
tha~ finds o\t the factorial of a number,
/*P6.8
Program
to
find
out
the
f'actorial
of
a
number*/
\
#include<stdio.h>
'
long
int
factorial (int
n)\;
main")
,'~
{
int
num;
printf (;\Enter
a
number
").;
scanf("%d",&num) ;
if (num<O)
printf ("No
factorial
of
negative
number\n,");
else
printf ("F,actorial
of
%d
is
!!?l:d\n", num, factorial (num) ) ;
}
long
int
factorial (int
n)

/ *P6. 9
Program
to
understand
formal
and
actual
arguments * /
#include<stdio.h>
A function can r:eturn only one value. If we want to return more than one value then we have to use
another technique discussed in further chapters,· It is incorrect to try to return more than one value
using comma.
return 1, 2, 3;
Here this expression is using comma operator and hence only the rightmost value will be returned,
If no value is to be returned ftom the function then it should be declared as void, All functions, which
are not of void type, return a value. If the function is not of void type and no value is returned through
return statement, then a garbage value is returned automatically.
If the value returned is not of the type specified in the function definition then it is converted to that
type if the conversion is legaL
6.8
Function Arguments
The calling function sends some values to the called function for communication; these values are called
arguments or parameters,
Actual arguments: The arguments which are mentioned in the function cali are known as actual
arguments, since these are the values which are actually sent to the called function. Actual.arguments
can be written in the form of variables, constants or expressions or any function call that returns a
val~e, For example-
"
fun(x,)
func.(a*b, c*d+k)
.func( 22, 43 )
func( 1, 2, sum(a, b) )
Formal arguments: The name of the arguments, ~hich are mentioned in the function definition are
called formal or dummy arguments since they are used just to hold the values that are sent by the calling
function.
These, formal arguments are simply like other local variables of the· function which are created when
the function call srarts and are destroyed when the function ends. However there are Jwo differeqces,
First is that fornml arguments are declared inside parentheses while other local variables are de~lared
at the beginning of the function block. The second difference is'that fopnal arguments are autonlatically
initialized with the values of the achial arguments passed, while other local variables are assigned values
through the statements written inside the function body.
The order, number and type of actual arguments in the function call should match with the order, number
and type of formal arguments in the function definition,
118
int
i;
long
int
fact:=.l;
if (n====O),
return
1;
for(i=n;i>l;i- -)
fact*==i;
return
fact;
C in Depth

Functions
main( )
{
int
m=6.n=3;
prinif(~~d\t":multiply(~,n)J;
print f ( "%d \ t" ,'mnlt lply"(is: ,'1;1),' i";"
printf("%d\t".multiply(m+n.m-n));
printf("%d\n".multiply(6.srim(m,n))) ;
}
mul tiply (int
x. int
y)
{
int
~;
p:::x*y;
return
p;
}
sum (int
x ,
int.
y)
{
return
X+Y;
119
}
Output:
18
60
27
54
In this program, funclion nlultiply( ) is called 4 times. The variables x and y ilre the formal arguments
of multiply( ). First time when the function is called: actual arguments are var"iable"s m and n, so "the
formal arguments x and y are initialized with the vafues of m and nand p=18 is returned. Second time
function is .called with actual argm'hents 15 and 4, so this time x and yare initialized with values 15
and 4 respectively, hence p=6~ is returned. Similarly third time x and y are initialized with values m+~=9
amd m-n=3 respectively, hence p=27 is returned. In the fourth call the first argument is a constant
value (6), while the second argument is a function call. So this time, x is initialized by 6 and y is initialized
by the value returned by the function sum( ) i.e. 9. Hence this time p=54 is returned.
The names of formal and actual arguments maybe same or different, because they are written in separate
functions.
/ *P6" 10
Program
to
understand
formal
and
actual
arguments * /
#include<stdio.h> .
main ( )
.
{
int
a=6.b=3;
fu~c (a, b);
-
func (15. 4) ;
func(a+b.a-b) ;
}
func (int
a. int
b)
printf ("a
%0,
b
%d\n".a.l::!);
}
Output:
a := 6
a = 15
a=9
Q=
~
b = 4
b = 3

120
C in Depth
'"
In the above program we can see that the values of a and b inside maine ) are 6 and 3, while a imd
b inside func( ) are initialized with values of actual arguments sent on, each call. Any changes made
to the formal arguments inside the function do not affect the actual arguments.
6.9
Types Of Functions
The functions can be classified into four categories on the basis of the arguments and return value.
1. .
Functions with no arguments and no return value.
2.
Functions with no arguments and a return value.
3.
Functions with arguments and no return value.
4.
Functions with arguments and a return value.
6.9.1
/
Functions With No Arguments And No Return Value
I' I
Functions that have no arguments and no return value are written as-
void
f,unc (voiC!) ;
main( ) .'
{
func ( ) ;
}
void
func (void).
{
statement;
In the above example, the function func( ) is called by main ( 2and the function definition is written
after the maine ) function. As the function' func( ) has no arguments, maine ) can not send any data
to func( ) and since it hqs no return statement, hence function can not return any value t; maine )j
There is no communication between the callipg and the called function, Since there is no return value
these types of functions cannot be ,used as operands in expressions, The function drawline( ) in P6.•
is an example of these types of functions, Let us see one more example program-
/*P6.11
Program
that
uses
a
function
with
no
arguments
and' noretur:J
values*/
#include<stdio.h~
void
dispmenu ~void) ;
malll'( )
.
{
int
choice;.
dispmenu'( ) ;
printf ("Enter
your
choice
:"};
s~anf("%d",&choice);
}
void
dispmenu (void
{
printf (" 1. Create
database\n");
printf("2.Insert
new
record\n");
printf("3.Modifya
record\n");

Functions
printf("4.Delete
a
record\n")i
printf("5.Display
all
records\n") i
printf("6.Exit\n") i
6.9.2'
Function With No Arguments But A Return Value
These types of functions do not receive any arguments but they can return a value.
int
func (void) i,
. main( l "
.
{
,
intr i
r=func ( );"
'l
}
int
func (yoi,d)
return
(expression) i
}
The next program uses a function of this type', .
121
/*P6.12
Program
that
returns
the - sum
of
squares
of
all
odd
numbers
from
1
to
25*/
#include<stdio.p>
in,t . func (void) i
main ( )
{
printf ("%d\n".' func ( ) ) i
}
. int
func;: (void).
{
'int
num, s=o i
for(num=linum<=25inum++)
{
if (num%2 !=O)·
s+=num*num.;
return
s i
'
}
Output:
2925
6.9.3
Function With Arguments But No Return Valu,e
These types of functions have arguments, hence thecalling function can send data to the called function
but the called function does not return any value, These functions can be writtel1.as-

122
void
fur~c (int, int) ;
main ( )
func(a,b) ;
}
void
func,( int
c, int
d)
{
C in Depth
statements
Here a and b are actual arguments which are used for sending the value, c and d are the formal arguments,
which accept values'from the actual arguments.
' '
,
}
else
printf ("No
triangle
possible
with
these
sides\n");
.
float
a,b,c;
printf ("Enter' the
sides
of
triangle
") ;
scanf("%f~f%f",&a,&b,~c) ;
if (a<b+c'&&
b<c+a
&!ic
c<a+b)
{
, ~ .
type (a, b, c),;,
area(a,b,c) ;
/*P6.13
Program
#include<stdio.h>
#include<math.h>
void
type (fl,oat
void,,~ area-( float
main'( )"
{
to
find
the
type
~,float
b, float
c);
a,ftoat
b,float
c);
and
area
of
a
triangle.*/
}
void
type(float
a, float
b, float
c)
c)
is
equilateral \n") ;
c==a)
is
i:sosceles\n");
b,float
a,float
area(float
if«a*a)+(b*1;»==(c*c) II (b*b)+(c*c)==(a*a) II (c*c)+{a*a)=={b*b))
printf ("The
triangle
is
right
angled
triangle\n");
if(a==b
&&
b==c)
printf ("The
triangle
else
if {a==b
II
b;==c
II
printf {"The
triangle
else
printf ("The
triangle
is
scalene\n");,
i
}
void
float
s;
a,rE!a;
s'= (a+b+~) !2 i
area=sqrt(s*(s-a)*{s-b,*{s-c)) ;
printf ("The
area 'of 'triangle
=
%f\n", area) ;

Functions
123
6.9.4
Function With Arguments And Return Value
These types of functions have arguments, so the calling function can send data to the called function,
, it can also return any value to the calling function using return statement. This function can be written
as-
int
func (int, int) ;
main ( )
{
,
int
r;
r=func (a, b) ;
func(c,d) ;
)
int
func (int
a, int
b
return
(expression)';
Here return statement returns the value of the expression to the calling function. The functions sumO,
multiply( ), max( ) that we had written earlier' are examples of these types of functions. Let us take
one m'ore example program-
/*P6.14
Program
to
find
the
sum
of
digits
of
any
number*/
#include<stdio.h>
int
sum (int
n);
,
'
main (J
{
int
num;
pr'intf ("Enter
the
number
") ;
scanf("%d~,&nu~) ;
printf ("Sum
of
digits
of
%d
is
%d\n", num, sum(n,um) );
}
int
sum (int
n)
c:::::
int
i, sum=O, rem;
whiletn>O)"
'
{'
.
rem=n%10;
sum+=rem;
n/=10;
return
.( sum) ;
/*rem
takes
the
value
of
last
digit*/
/ *skips
the
last, digi t
of
number* /
}
While describing the different type of functions, we have assumed arguments and return values of type
int for simplicity. These values can be of arty data type.

124
6.10
More About Function Declaration
C in Dep
The main thing about the placing of function declaration is that it should be before the function c
Generally all the function declarations are written before the maine ) function. This way the functf
declaration is accessible to all functions. It is also possible that we declare the function only inside .those
functions that call it Note that if function definition occurs before the function call, then declaratio
is not needed.
If a function returns a value of type int or char then it is not necessary to declare the function, because
by default every function returns an int value. The compiler assumes that any function, for which return
type is not specified in the definition, will return an int value. But if the function returns a value other
than int such as float, double, pointer, array, structure etc then it is necessary to declare it before the
function call.
Declaration of a function has two main uses. Firstly, it tells the compiler about the return type of the
function. Secondly, it specifies the type and number of arguments of the function. So it can be used
to check any mismatch between the number and type of arguments in the function definition and function
call. We had seen that it is optional to declare the functions of type int or char, but it is a good practice
to declare all func'tions since we can check the number and type of arguments in function call. So in
this way we can prevent bugs, which could occur due to wrong number and type of arguments in
the function call.
6.11
Declaration Of Functions, With No Arguments
• I
If a function has no arguments, then either the parentheses can be left empty or void can be written
inside the parentheses. But it is better to write void because when parentheses are empty, the compiler
assumes that there is no information about the arguments. There can be no arguments or any number
of arguments, So the compiler won't be able to check any mismatch in the type and number of arguments
in function call.
Similarly void c~n be specified as return type if a function does not return any value. This will avoid
accidental use of function in any expression. For example-
..
/ *P6. 15
Program to
understand declaration
of
functions
with
no
arguments* /
#include<stdio.h>
void
func;l ( ) ;
vciid
func2 (void) ;
main ()
{
funcl (1.3, 'a',) ;
func2 (1.3, 'a',> ;
}
void 'funcl,( )
{
/*will
not
generate
any
error*/
/ *will
generate
error* /
printf("\nFunctionl\n");
}
void
func2 (void
)
{
print~("\nFunction2\n") ;
}
Here we see that funcl ( ) can be called with wrong number and type of arguments and it will not show

Functions
125
any compilation error, so it can be a bug hard to find. It is not possible to call the function func20
.h i .
Wit
lany argument.
6.12
If Declaration Is AbsentvO'
If act~al arguments are more than the formal argument& tI1en the extra a~mal arguments are just ignored.
If actual arguments are less than the/ormal arguments,' then the extra formal arguments receive garbage
value.
func (int
a, int
b, int . c)
{
func(l, 2, 3, 4, 5);
/*Actual arguments more than formal*/
Here the last two arguments are just ignored. a = 1, b = 2, c = 3
func(l, 2 );
/*Actual arguments less than formal*/
Here the third argument receives garbage value. a = 1, b = 2,c = garbage value
If there is a type mismatch between a corresponding actual and formal argument, then compiler tries'
to convert th~ type of actual argument to the type of the formal argument if the conversion is legal.
otherwise a garbage value is passed.to the formal argument.
Execution of every C program always begins with the function maine ). Each function is called directly
or indirectly in maine ) and after all functions have done their operations, control returns back to mainO.
There can be only one maine ) function in.aprogram.
The maine ) function is a user defined function but the name, number and type of arguments are predefined
in the language. The operating system calls. the main function and maine ) returns a value of integer
type to the operating system. If the value returned is zero, it implies that the function has terminated
successfully and any nonzero return value indicates an error. If no return value is specified in maine
) then any garbage value will be returned automatically. Calling the function exit( ) with an integer value
When a function is .called .with more than one argument,t~en the the order of evaluation of arguments
is unspecified. This order of evaluation is not important in function calls like multiply( m, n)
or
multiply(m+n;' m-n). But if we have a function ~an .like this: .
'. .
.
int m = 3, k;
k = multiply( m, m++);
Now here if the first argument is evaluated first then value of k will be 91 an9 if the second argurrtent
is evaluated first, the value of k will be 12. But since the order of evaluation of arguments is unspecified
in C and depends on compiler, hence the result may be different on different compilers. Similarly if
we write-
int i = 10;
printf("%d _%d
%d':~. - -i, i++, i); .
Here also the result is unpredictable. So it is better to avoid these types of argument expressions that
can produce different results on different compilers.
6.13
6.14
Order Of Evaluation Of Function Arguments
maine ) Function

is equivalent to returning that value from maine ). The function maine ) can also take arguments, which.
will' be discussed in. further chapters.
The definition, declaration and call of maine ) function-
-
•
.
-
_ .
I
•
Function Declaration - By the C compiler
Function Definition - By the programmer'
Function Call -
~y the operating system
126
C in Depth
6.15
Library Functions.
local
variables
declarations;
Old Style Of Function Definition
Old Style Of Function Declaration
6.17
6.16
The old style of writing function definition is slightly different from the one we have studied. Altho _
this style is no longer used but the compilers still support it.
The old style declaration of functions does not inform the. compiler about the type and number 0
arguments. The syntax of old style declaration is-
return_type func_name( );
The parentheses are always empty even if the function receives arguments. This conventioQ is support
in new compilers also so that the old programs can be compiled using the new compilers, But
convention is not used now since the new convention is better and provides more information to
compiler.
The library funct.ions are formally not a part of the C language, but they are supplied with every C
compiler. The source code of the library functions is not given to the user. These functions are
precomp'iled and the user gets only the object code. This object code is linked, to the object code of
your program by the linker. Different categories of library functions are grouped together in separate
iibraiy files: When we call a library function in our program, the linker selects the code of that function
from the library file and adds it to the program.
The definition, declaration and call of library functions-
Function Defini~io~ - Predefined, precompiled and present in the library.'
Function Declaration. - In header files ( files with a .h extension)
Function Call - By the programmer
To use a library function in our program we should know-
(i)
Name of the function and its purpose
(ii)
Type and number of arguments it accepts
(iii) Type of the value it returns
(iv) Name ,of the header file to be included.
We can deflne any function of our own with the same name as that of any function in the C library.
If we do so then the function that we have defined will take precedence over the library function with
the same name. The standard library functions are discussed in chapter 18.
"
return_type
func_name(argument
list)
argument
declarations
{

Functions
statements;
returnlexpression);
127
The coinpilersbased on K&R C support t1).is syntax while the new compilers based on ANSI C support
bothJhe ways of writing function headers. Let us see "'in example of function definition written in old·
style-
..
.
float
func1Ia,b,z)
inta, b;
float
z;
{
float
s;
s=la+b)/z;
return
z;
Here are few more programs on functions.
1*P6. 16
Program
to
find
the
reverse
of
a
number
and
check
whether
it
is
a
palindrome
or
not.
Palindrome
is
a
number
that
remains
same
when
reversed. ~I
#include<stq.io. h>
j
int
reverse (int
n);
mai~1 )"
.
{
iI!:t
num;,
printf I "Enter
a
number
.") ;
scanf("%d",&num) ;
printf ("Reverse
of
,%d
is
.%d\n", nu;n, rever.se Inurn) ) .;
iflnum==reverse(num) )
pri~u.t.f l "..l\Tl.U:O.D.er
j s
oR
;...:.~..J. i ..'ODro_wJ;I }_T'J 1/" ,.
else
printf I "Number
is
not
a
palindrome\n");
}
reverse,1 int . nj
{
iIl;t
rem, rev=O;.
while In>O)'
{
rem=n%;l.O;
re.v=rev *10 +re:m;
n/=10;
return
rev;
}
Output:
Enter the number: g113
Now the number is : 3113
Number is a palindrome
I*P6.17
Program
to
find
whether
the
number
is
prime
or
not.*1

128
C in Depth
#i~clude<stdio.h>
#include<math.h>
int
isprime (int
n);
main ( )
{
int
num;
printf ("Enter
a
number
") ;"
scanf("%d",
&num);
if(isprime(num))
printf ("Number
is
prime\n");
else
printf ("Number
is
not
prime\n");
}
int
isprime (int
n)
int
i,flag=1;
tor (i=2; i<=sqrt (n) ;'i++)
{
if(n%l==O)
{
flag=O;
breCjlk;
return
(flag);
/*P6.18
Program
to
p:r;int
all
prime
numbers
less
than
500*/
#include<stdio.h>
#include<math.h>
int
isprime (int
n);
main ( )
{
int
i;
for(i=1;i<=500;i++)
if (isprime (i))
printf("%d
",i);
}
int
isprime (int
n)
I
/*P6.19
Program
to
print
twin
primes
less ,than
500
odd
numbers
are
both
prime
(e.g.
17,
19)
then. they
primes.*/
#include<stdio.h>
#include<math.h>
int
isprime (int
n);
main ( )
If
two
consecutive
are
known
as
twi

_":unctions
129
int
i=3,j;
while(i<500)
{
*P6.20
Program
.to
convert
a
decimal
number
to
binary
number* /
-include<stdio.h>
:
ng
int binary (long
in.t
num);
:::ain ( )
:...:It
isprirne (
int
n)
j =i;
i=i+2;
if(isprime(j)
&&
isprime(i»
printf ("%5d
%5d\n", j, i) ;
" ) i
~ld\n",num,binary(num) );
decimal
number
%ld
Binary
=
long
int
num;
printf("Enter
the
scanf("%ld",&num) ;
printf ("Decimal
:ong
binary (long
int
num)
long
rem, a=l, bin=O;
while(num>O)
{
rem=num%2;
bin=bin+rem*a;
num/=2;
a*=lO;
".
)
return
bin;
e logic used in this program is discussed below-
_ ppose decimal number is 29
Quotient
Remainder
29/2
14
1
MSB
14/2
7
0
7/2
3
1
3/2
1
1
1/2
0
1
LSB
1*0 ~ 1*10+ 1*100 + 0*1000 + 1*10000
= 10111

By this method we can get binary equivalents of decimal numbers upto 1023 only, since for numben
more than 1023(Binary - 1111111111), the binary equivalents will exceed the range of long int. In the
-next chapter we'll see a better method to print binary numbers.
130
C in Depth
I *P6. 21
Program
to
raise
a
floating
point
number
to
an
integer
powei
eg
an
where
a
is
floating
point
and
n
is· integer
value* I
*include<stdio.h>
main ( )
{
float
a;
int
n;
'float
power (float
a, int
n);
printf (\\Enter
base
") ;
scanf ("%f" ,\&a) ;
printf ("Enter
exponent
\\) ;
scanf (\\%d" ,&n); -
printf(\\%f
raised
to
poweI-%d
is
%f\n",a,n,power(a,n»;
}
float
power (float
a, int
n)
{
int
i;
float
p=l;
if(n==O)
return
1;
else
for(i=l;i<=abs(n) ;i++)
p=p*a;
if (n>O)
return
p;
else
return
lip;
}
6.18
Local, Global And Static Variables
6.18.1
Local Variables
The variables that are _defined within the body of a functioQ or a block, are local to that functic
block only and are called local variables. For example-
func ( )
{
int_ a, b;
Here a and b are local variables which are defined within the body of the function func( ). Local var
can be used only in those functions or blocks, in which they are declared. The same variable
may be used in different functions. For example-

=- llctions
int
a=2,l;>=4;
- nc2 ( )
int
a=15,b=20;
131
ere values of a = 2, b = 4 are local to the function funcl( ) and a = !5, b = 20 are local to the
ction func2( ).
....18.2
Global Variables
_ e variables that are defined outside any function are called global variables: All functions in the prog~am
access and niodify global variables. It is useful to declare a variable global if it is to be used by'.
y functions in the program. Global variables are automatically initialized to 0 at the time of de~laration.
*P6.22
Program
to
understand
the
use
of
global
variables* I
=·nclude<s~dio.h>
aid
funcl (void) ;
-aid
func2 (void) ;
:.nt
a"b=6;
~in( )
printf("'Inside
r,nain()
tuncl();
func2 ( ) ;
-oid. funcl (void
a
%d,
b
%d\n",a,b)
printf ("Inside
funcl ( )
-
id
func2 (void)
a
=
%d,
b
%d\n", a, b);
int
a=8;
print f (" Inside
func2 ( )
a
=
%d,
b
=
%d\n",a,b);
tput:
Inside maine ):
a = 0; b = 6
Inside funcl( ) : a = 0, b = 6
Inside func2( ):
a = 8, b = 6
ere a and b are declared outside all functions henet; they are global variables. The variable a will be
'tialized to 0 automatically since it is a global variable. Now we can use these variables in any function.
func2( ), there is local variable with the same name as global variable. Whenever there is a conflict
tween a local and global variable, the local variable gets the precedence. So inside func2( ) the value

132
of local variable gets printed.
c
1 6.18.3
Static Variables'
C in Depth
Static variables are decla~ed by writing keyword static in front of the declaratiop.
static type var_name;.
A static variable is initialized only once and the value of a static variable is retaine~ between fu:~ctiOl
calls. If a static variable is not initiali~ed then it is automatically initialized to O~
/ *P6. 23
Program
to
understand
the
use
of
static
variables* /
#includecstdio.h>
void
fun.c.(void);
mainJ>
{
func (J ;
func ( ) ;
func ( ) r
b::10;.
'%d
b
=
%~\n" ,a,b);
b = 10
b = 11
b = 12
Recursion
int
a=lO;
static
int
printf ("a
a++;
b~+;
6.19
}
Output:
a = 10
a = 10
a = 10
}.
v~idfunc.(void)
{
Recursion is a powerful technique of writing a complicated algorithm in an easy way. Accordin
this technique a problem is defined in terms of itself. The problem is solved by dividing it into s
proqlems, whic~ are similar in nature to the original problem. These smaller problems a~e solved
their solutions are applied to get the final solution of our original problem.
To implement recursion technique in programming, a function should be capable of calling its~lf
this facility is available in C. The funG-tion thaLcallsjtself~'inside.£unction
body}..again~and a ain is
!l.s a recursiie_fune.1i.on. Inrecu~n the calling function and the called function are same. For ex
main ()
. .
>,
{
Rete 'b' is a static variable. First time when the function is called 'b' is initialized to 10. Inside
function, value of 'b' becomes 11. This value is retained and when next time the function is call'
value of 'b' is 11 and the initialization is neglected. Similarly when third time function is called,
of 'b' is 12. Note that the variable 'a', which is not static is initialized on each call and its val
not retained.

Functions
rec ( ) ;
}
rec( )
,
,
{
rec (
);
----I.~ recursive
call
133
6! = 6 * 5!
5! = 5*4!
Here rec( ) is called inside the body of f~nction rec( ). There should be a terminating condition to stop
recursion, otherwise rec( ) will keep on calling itself infinitely and will never return.
if (... )
/*terrninating
condition*/
rec ( ) ;
Before writ~ng a recursive function for aproblem we should consider these point-s-
1.
We should be able to define the solution of the problem in terms ofa similar type ofsmaller problem.
, At each step we get closer to' the final' solution of our original problem.
2.
There should be a terminating condition to stop recursion.
Now we will take some problems and write recursive functions for solving them.
(i)
Factor~al'
(ii)
Power
(iii)
Fibonacci numbers,
(iv) Tower of hanoi
We know that' the factorial of a positive integer n can be found out by multiplying all integers from
1 to n.
n!
= I * 2 '" 3 *
* (n-l) * n
This is the iterative definition of factorial and in the previous chapter we had written a program to compute
factorial using loop. Now we'll try to find out the recursive definition of factorial.
We know that
6! = 6*5*4*3*2*1
We can write it as-
Similarly we can write
So in general we can write
n! = n * (n-l)!
Now problem of finding out factorial of (n-l) is similar to that of finding out factorial ~fn, but itis
definitely smaller in size. So we have defined the solution of factorial problem in terms of itself. We
know that the factorial of 0 is 1. This can act as the terminating condition. So the recursive definition
of factorial can be written as-

134
n!
= {:
•
(n-l) !
n=O
n>O
C in Depth
Now we'll write a program, which finds out the factorial using a recursive function.
"
winding phase
/*P6.24
Program
to
find
the
factorial
of
a
number
by
recursive
method* /
#include<stdio.h>
long
fact (int
n);
main ( )
{
int
num;
printf ("Enter
a
number
") ;
scanf("%d",&num);
printf ("Factorial
of
%d
is
%ld\n", num, fact (num) ) ;
}
long
fact (int
n)
{
if
(n==O)
return(l) ;
else
return(n*fact(n-l»
;
This function returns I if the argument n is 01 otherwise it returns n*fact(n-l). To return n*fact(n-.
1), the value of fact(n-l) has to be calculat~d for which fact( ) has to be called again but this time
with an argument of n-l.
This process of calling fact( ) continues till it is called with an argument
of 0,
Suppos,ewe want to find out the factorial of 5.
Initially main( ) calls factorial(5)
Since 5>0, factorial(5) calls factorial(4)
Since 4>0, factorial(4) calls factorial(3)
Since 3>0, factorial(3) calls factorial(2)
. Since 2>0, factorial(2) calls factorial(1)
Since 1>0, factorial(J) calls factorial(O)
When'factorial( ) is called with n=O then the condition inside if statement becomes true, so now the
recursion stops and control returns to factorial(l)
Now every called function will return the value to the previous function. These values are returned in
the reverse order of function calls.

Functions
135
Recursive functions work in two ph,ases. First one is the winding phase and the next one is unwinding
phase. In winding phase the function keeps on calling itself. The winding phase stops when the terminating
condition arrives in a call, now the unwinding phase starts and the called functions return values in
reverse order.
In the above case the function factorial( ) is called 6 times, but there is only one copy of that function
in memory. Each function call is different from another because the argument supplied is different each
time.
ow we'll write a recursive function for finding out the an.
The iterative definition for finding an is
an = a * a * a *
n times
The recursive definition can be written as-
{
1
n=O
n>O
j*P6.25
Program
to
raise
a
floating
point
number· to
a
positive
integer
sing
recursion* /
winclude<stdio.h>
::loat
power (float
a, int
n);
:nain ( )
{
float
a, p;
int
n;
print~ ("Enter
a
and
n
") ;
scanf("%f%d",&a,&n) ;
p=power(a,n) ;
printf("%f
raised. to
power
%d
is
%f\n",a,n,p);
::loat
power (float
a, int
n)
if(n==O)
return(l) ;
else
return(a*power(a,n-i)) ;
PS.20, we had written a program to print the fibonacci series. Now we'll write a recursive definition
:or finding fibonacci numbers.
Jib(n) ~{
1
fib(n-l) + fib(n-2)
n=O or n=l
n>l
•
*P6.26
Program
to
generate
fibonacci·
series
using
recursion* /
·nclude<stdio.h>

136
main ( )
{
int
nterms,
i;
printf ("Enter
number
of
terms
") ;
scanf ("%d",
&nterms);
for(i=O;i<nterms;i++)
printf("%d
",fib)i»;
.
-"
printf("\n") ;
C in Depth
int
fib(int
n)
/*recursive
function
that
returns
nth
term
of
fibonacci
series* /
6.19.1
Tower Of Hanoi
if (n==O Iln==l)
return(l);
else
return(fib(n~1)+fib(n-2» ;
The problem of Tower of Hanoi is to move disks from one pillar to another using a temporary p-
Suppose we have a source pillar S which has finite number of disks, and these disks are placed
it in a decreasing order i.e. largest disk is at the bottom and the smallest disk is at the top. Now
I
want to place all these disks on destination pillar 0 in the same order. We can use a temporary p
T to place the disks temporarily whenever required.. The conditions for this game are-
1.
We can move only one disk from one pillar to another at a time.
2.
Larger disk cannot be placed on smaller disk.
Suppose the number of disks on pillar S is n. First we'll solve the problem for n=l, n=2, n=
then we'll develop a general procedure for the solution.
Here S is the source, 0 is the destination pillar'and T is the temporary pillar.
}
The difference frolJ1 previous two functions (factorial and power) is that here the function fib( ) i
called two times inside the function body. The following figure shows the recursive calls of functio
fib( ) when it is called with argument 5.

Functions
137
For n=l
S
T
D
ill
. S
T
D
ill
S-7D
S-7 D means move the disk from pillar S to pillar D.
For n=2
S
T.
D
S
T
D
S
T
D
S
T
D
ill ill ill ill
Initial position
S-7T
S-7D
T-7D
(i)
Move disk 1 from pillar S to T
(ii)
Move disk 2 from pillar S to D
(iii)
Move disk 1 from pillar T to D
For n=3
( S-7T )
( S-7 D )
( T-7D )
ill ill ill ill
Initial position
S
T
D
ill
S-7D
S-7T
D-7T
STD
STD
STD
ill ill ill
S-7D
T~
T-7S
S-7D
(i)
Move disk 1 from pillar S to D
(S-7 D)
(ii)
Move disk 2 from pillar S to T
(S-7 T)
(iii)
Move disk 1 from pillar D to T
(D-7 T)
(iv)
Move disk 3 from pillar S to D
(S-7 D)
(v)
Move disk 1 from pillar T to S
(T-7 S)
(vi)
Move disk 2 from pillar T to D
(T-7 D)
(vii) Move disk 1 from pillar S to D
(S-7 D)
These were the solutions for n=l, n=2, n=3. From these solutions we can observe that first we move
n-l disks from source pillar (S) to temporary pillar (T) and then move the largest disk to destination
pillareD). So the general solution for n disks can be written as-
1.
Move upper n-I disks from S to T.
2.
Move nth disk from S to D.
3.
Move n-I disks from T to D.
To move n-I disks from S to T, we can use D as the temporary pillar, and to move n-I disks from
•

138
T to D, we can use S as the temporary pillar.
Move disk from source to dest
n=l
tofh( n, source, temp, dest) =
tofh(n-l, source, dest, temp)
Move nth disk
from source to dest
n>1
tofh(n-l, temp, source, dest)
C in Depth
/*P6.27
Program
to
solve
Tower
of
#include<stdio.h>
main(
Hanoi
problem
using
recursion* /
char
source='S' ,temp='T',dest='D';
int
ndisk;
printf("Enter
the
number
of
disks
");
scanf("%dU,&ndisk) ;
printf ("Sequence
is
: \n
U
)
;
tofh(ndisk,source,temp,dest) ;
}
tofh (int
ndisk, char
source, char
temp. char
dest)
{
if (ndisk>O)
{
tofh(ndisk-l, source,dest, temp) ;
printf ("Move
Disk
%d
%c->%c\n U,ndisk,source,dest);
tofh(ndisk-l,temp,source,dest) ;
}
}/*End
of
tofh()*/

Functions
139
...:.--_-.-~.- tofb(1 , S, T, D)-S_7 D
________ tofb(2, S, ~T)-
S_7T
------- tofb(l, D, S, T)-D_7T
/
tofb(3, S, ~)
.
S_7D
.
tofb(1, T, D, S)-T_7S
tofb(2, T, S, D)
T_7 D
~ tofh(1, S, T, D)-S_7D
tofb(4, S, D, T)
S_7T
\
tofb(l, D, S, T)-D_7T
_______ tofb(2, D, 1:...-S)-
D_7S
------ tofb(1, T, D, S)-T_7S
tofb(3, D, S T)
D_7T
~
-
tofh(1, S, T, D)-S_7D
tofb(2, S, ~
. S_7T
.
.
tofb(l, D, S, T)-D_7T
tofb(5, S, T~ D)-·-----------------------S_7D'
_----tofb(l, T, D, S)-T_7S
________
.
tofb(2, T, ~
T_7 D
tofb(l, S, T, D)-S_7 D
/
tofb(3, T, D, S),-----------------T_7S
~
tofb(1, D, S, T)--D_7T
tofb(2, D, T, S)~---------D_7S
to£11(1, T, D, S)-T_7 S
tofh(4, T, S, D)
T_7 D .
\
-
tofb(1, S, T, D)-S_7D
____ tofb(2, S, ~
.
S_7T
.
~
to£11(1, D, S, T)--D_7T
tofb(3, S, T, D)
S_7 D
---=----
.
to£11(1, T, D, S)-""-T_7 S
------
tofb(2, T, S, D)
T_7 D
.
~ tofb(1, S, T, D)-S_7D
6.19.2
AdvantagesAnd Disadvantages Of Recursion
The use of recursion makes the code more compact and elegant. It simplifies the logic and hence makes
the program easier to understand. But the code written using recursion is less efficient since recursion
.is a slow process because of many function calls involved in it.
Most problems with recursive solutions also have an equivalent non recursive(generally iterative) solutions.
A non recursive solution increases performance while a recursive solution is simpler.
6.19.3
Local Variables In Recursion
We know. each function has some local variables that exist only inside that function. When a function
is called recursively, then for each call a new set of local variables is created(except static), their name
is same bu't they are stored at different places and contain different values. These values are remembered
by the compiler till the end of function call, so that these values are available in the unwinding phase.

140
C in Depth.
6.20
Some Additional Problems
Problem 1
" ) ;
\\) ;
/.int
num, base, resul t;
char
choice;
printf("Enter
'b'
for
binary
and
'0'
for
octal
scanf("%c",&choice) ;
printf ("Enter
the
number
scanf(~%d",&num);
if (choice==' b' )
base=2;
else
base=8;
result=func(num,base) ;
printf ("Decimal
number
is
%d\n", result) ;
Write a program to convert a binary or octal number to a decimal number depending on user's choice.
./ *P6 .28
Program to
convert
a
binary or octal
number
to
a
dec imal
number* /
#include<stdfo.h>
.
main ( )
{
}
func(int
n,int
base)
{
int
rem,d,j=l,dec=O;
while(n>O)
{
rem=n%lO;
/;;
taking
last
digit
* /
d.=rem*j;
d~c+=d;
j*=base;
n/=lO;
/ *
skipping
last
digit
* /
return
dec;
}
Problem 2
Write a program to implement these formulae of permutations and combinations.
The formula for number of permutations of n objects taken r at a time-
p(n, r) = n! / (n-r)!
The formula for number of combinations of n objects taken r at a time is-
c(n, r) = n! / r! * (n-r)!
This can also be written as-
·c(n, r) = p(n, r) / r!
/*P6.29
Program
to
find
out
permutations
and
combinations* /
#include<stdio.h>
long
factor.ial (int) ;

Functions
long
perm(int, inti i
long
comb (int, int) i
main( )
{
int
n,r;
printf'( "Enter
n
") ;
scanf ("%d" ,&n) ;.
printf ("Enter
r
") ;
scanf ("%d" ,&r) ;
printf ("Total
combinations
are
printf ("Total
permutations
are
}
long
comb (int
n, int
r)
{
long
c;
c=perm(n,r)/factorial(r) ;
. return
c;
}
long
perm(int
n, int
r)
{
long
p;
p=fac~orial(n)/factorial(n-r);
return
p;
}
long
factorial (int
k)
{
long
factc=l;
while (
k>O
{
fa'ct *=k;
k- -;
return
fact;
Problem 3
rite a program to print Pascal's triangle,
1
2
1
3
3
1
464
5
10
10
5
1
6
15
20 15 6
%ld\n",comb(n,r»
;
%ld\n",perm(n,r»
;
141
*P6. 30
Program
to
print
Pascal's
triangle* I
-~nclude<stdio.h>
_ ng
factorial (int} ;
:
ng
comb(int, int);
I.'
.-.l_.......
_

142
main(
{
int
i,j,k;
printf ("Enter
number
of
rows
scanf ("%d", &k) ;
for(i=O;i<k;i++)
{
for(j=O;j<=i;j++)
printf("%~ld",comb(i,j)");
printf("\n") ;
}
long
comb(int
n,int
r)
{
for
Pascal's
triangle
C in Depth
") ;
long
c;
c=factorial(n)/(factorial(r)*factorial(n-r))
return
c;
}
long
factorial (int
k)
{
long
fact=l;
while(k>O)
{
fact*=k;
k- -;
return "fact;
}
Problem 4
Write a program to convert a decimal number to a roman number. The roman numbers con:espond"
to decimal numbers are as-
1- ,i,
9 -
IX
100 - c
4 - iv
10 - X
500 - d
5 - v
50 - I
1000 - m
Some examples are-
14
xiv
123
cxxiii
1009
mix
48
xxxxviii
772
dcClxxii
2856
mmdccclvi
/*P6.31
Program
to
convert
a
decimal
number
to
roman
number*/
#include<stdio.h>
int
roman(int, int, char);
main ( )
{
int
num;
printf ("Enter
a
number
") ;
scanf{"%d",&num) ;
1f(num>=lOOO)
num=roman(num,1000, 'm');

Functions
if(num>=500)
num=roman(num, 500, 'd');
if(num>=lOO)
num=roman(num,lOO, 'c');
if(num>=50)
num=roman(num, 50, '1');
if (num>=lO)·
num=roman(num, 10, 'x');
if(num>=5)
num=roman(num,5, 'v');
if(num>=l)
roman (num, 1, 'i');
printf (" \n") ;
}
int
roman(int
n,int
k,charc)
if(n==9)
{
printf("ix") ;
return
0;
}
if(n==4)
{
printf("iv") ;
return
0;
}
while(n>=k)
{
printf("%c" .c);
n=n-k;
return
n;
}
Problem 5
Write a program that prints the reverse of a positive integer using recursion.
f*P6.32
Program
to
print
the
reverse
of
a
positive
integer* f
#include<stdio.h>
void
reverse (long
int
n);
main ( )
{
long
int
num;
printf ("Enter
number
") ;
scanf("%ld",&num) ;
reverse (num) ;
printf("\n") ;
}
void
reverse (long
int
n)
{
int
rem;
143

144
if(n==O)
return;
else
rem=n%lO;
printfl"%d",rem);
n/=lO;
reverse (n) ;
}
Problem 6
C in Depth
Write a program that reads a number and prints whether the given number is divisible by 11 or nol
by using the algorithm which states that a number is divisible by 11 if and only if the difference oj
the sums of digits at odd positions and even positions is either zero or divisible by 11,
/ *
P6. 33
Program
that
tests
whether
a
number
is
divisible
by lIar
not
*/
#include<stdio.h>
void· test (long
int
x);
main ( )
{
long
int
num;'
printf("Enter
the
numher
to
be
tested
");
scanf("%ld",&num);
test (num) ;
}
void
test (long
int
n)
{
int
sl:::0, s2=0, k;
while(n>O)
{
sl+=n%10;
n/=10;
s2+=n%10;
n/=10;
}
k=sl>s2? (sl-s2) : (52-s1) ;
if(k>10)
te5t(k};
else
if(k==O)
printf ("The
number
is
divisible
by
11 \n") ;
else
printf("The
number
is
not
divisibl~ by
11\n");
}
.~
Problem 7
Write a program that uses a recursive function to convert a decimal number to (i) Binary (ii) 0
(iii) Hexadecimal depending on user's choice.

/* P6.34 Program to convert a decimal number to Binary,
Octal or Hexadecimal
*/
#include<stdio.h>
void
convert(int,
int);
main ( )
{
int
num, base;
int . choice;
while(l)
{
printf("l.Binary\n") ;
printf("2.0ctal\n") ;
printf("3.Hexadecimal\n") ;
printf("4.Exii\n") ;
printf ("Enter
your
choice
") ;
scanf ("%d",
&choice)";
switch(choice)
{
145
loop* / "
while
of
choice\n") ;
/ *Takes
to
start
case
1:
base=2;
break;
case
2:
base=8;
break;
case
3:
base=16;
break;
case
4:'
exi t (1) ;
default:
printf ("Wrong
continue;
Functions
}
printf ("Enter
the
number
in
decimal:
");
scanf("%d",&num) ;
convert(num,base) ;
printf (" \n") ;
}
void
convert
(int
num, int
base)
int
rem;
rem=num%base;
num/=base;
if
(num>O)
convert (num,base) ;
if(rem<lO)
printf("%d",rem) ;
else
printf("%c",rem-lO+'A') ;

Write a program to find out the prime factors of a number using both iterative and recursive methods.
Prime factors of 56 are 2; 2, 2, 7, prime factors of 98 are 2, 7, 7, prime factors of 121 are 11, 11.
146
Problem 8
/ *P6. 35
Program
to
print
the
prime
factors * /
#include<stdio.h>
void
pfact (int
num);
void
rpfact( int
n);
main ( )
{
int
num;
printf ("Enter
a
number
") ;
scanf("%d",&num);
pfact(num) ;printf("\n");
rpfact(num) ;printf("\n");
}
void
pfact (int
num)
{
int
i;
for(i=2;num!=1;i++)
I
{
while(num%i==O)
{
printf ("%d
", i) ;
num=num/i;
}
void
rpfact (int
num)
static
int
i=2;
if (num==l)
return;
else
while(num%i==O)
{
printf("%d
",i);
num=num/ i;
i++;
rpfact (num) ;
}
Problem 9
i
I
C in Depth
Write a program to find out the sum of this series, both by iterative and recursive methods.

%If\n'',series(x,n) ):
%If\n'',rseries(x,n)) :
Functions
147
/*P6.36
Program
to
find
out
the
sum
of
series*/
#include<stdio.h>
long
intfact (int
num):
double
power (float
x, int· n):
doub.le
series (float
x, int
n):
double
rseries (float
x, int
n):
main ( )
{
\\) i
terms
\\) ;
float
x:
int
n:
printf ("Enter
x
scanf("%f",&x) :
printf ("Enter
number
of
scanf ("%d", &n) :
printf("Itera~ive
printf("Recursive
}
long
int
fact (int
num)
(
int
i:
long
int
f=l:
for(i=l:i<=num:i++)
f=f*i:
return
f:
}
double
power (float
x, int
n)
(
int
i:
float
p=l:
for(i~l:i<=n:i++)
p=p*x:
return
p:
}
double
series (float. x, int
n)
(
int
i,j,sign=l:
float
term, sum:
for(i=l:i<=n:i++)
".
sign=(i%2=~O)?-1:1:
j=2*i-l:
term=sign*power(x,j)/fact(j);
sum+=term:
return
sum;
}
do,uble
rseries{ float
x, int
n)
int
sign=l:
float
term, sum'
;i.f(n==O)
+

148
sum=O:
else
{
sign=(n%2==O)?-1:L:
term=sign*power(x,2*n-l)/fact(2*n-l) :
sum=term+rseries(x,n-l):
return. sum:
C in Depth
The ith term of the series is
x( 2" i-I)/ (2*i~1)! . In iterative function, we'll take a loop from i=l to
i=n and add all the terms. To calculate the numerator ahd denominator of a term we'll use the functions
power( ) and fact( ). Since the terms.have alternate positive and negative signs, so we'll take a variable
sign, initialize it with 1 and multiply it with -Ion each iteration of the loop.
Problem 10
Write a program to find out the Least Common Multiple and Highest Common factor of two numbers
recursively. The iterative method is given in Program P5.42.
/*P6.37
Program
to
find
out
the
LCM
and
RCF
of
two
numbers· recursively*/
#include<stdio.h>
int
m, n:
main( )
{
int
x,y:
printf ("Enter
two
numbers
") :
sc·anf ("%d
%d·" , &x, &y) :
printf ("RCF
of
%d
and
%d
is
%d\n", x, y, hcf (x, y) ) :
m=x;n=y:
printf ("LCM
of
%d
and
%d
is
%d\n", x, y, lcm (x, y) ) :
}
int
hcf(int· a, int
b)
if(a==b)
retur·n (b) :
else
if (a<b)
hcf(a,b-a)
·else
hcf(a-b,b) :
}
int
lcm(int
a, int ,b)
if (a==b)
return (b) :
else
if(a<b)
lcm(a+m,b):
else
lcm(a,b+n.):

Functions
Assume stdio.h is included in all programs.
(l) void
func (void) ;
·main( )
{
printf("Lucknow\n H);
goto
ab;
)
void
func (voidl
{
ab:
pr~ntf("Bar~illy\nH);
(2) main (
{
int
i=9;
if(i==9)
{
int
i=25;
}
printf("i=%dH,i);
3) void
func(int
a,int
b);
main( )
{
int.
Xi
x=func(2,3) ;
}
void
func(int
a,ipt
b)
{
int
s;
s=a+b;
retu.rn;
4) main(
{
int
x=5;
x=func ( ) ;
printf("%d\n",x);
)
int
func (int
a)
a=a*2;
-) main (
{
Exercise
149
~I

150
static
int
x=5;
if(x>O)
{
printf ("%d
x- -;
main ( ) ;
(6) main (
{
II
I x) i
C in Depth
int
s;
s=func(2,3);
printf("%d\n",s);
}
int
func(int
a,il1t
b,int
c)
c=4;
return
(a+b+c);
(7) main(
int
s;
s=func(2,3,6);
printf("%d\n",s);
int
func (int a, int
b)
return
(a+b);
(8) func(int
x,int
y);
main ( )
{
int
p=func(5,6};
printf ("%d", p) ;
}
func(int
x,int
y)
int.
x=2;
return
x*y;
(9) main(
{
int
varl=12, var2=35;
printf("%d",max(varl,var2»;
int
max (int
x, int
y)

Functions
151
x>y?return
x: return
y;
(10) main (
{
int
n=5;
printf("%d\n",func(n»
;
}
func (int
n)
{
return(n+sqr(n-2)+cube(n-3»;
sqr (int· x)
{
return (x*x) ;
cube(int
x)
{
return
(x*x*x);
(11) main ( )
{
int
func(int
a,int
b);
return
(a+b);
}
int
c;
c=func(3,5) ;
printf ("%d", c) ;
(12)main(
{
int
x=5;
fun'c1 (x) ;
}
func1(int
a)
{
printf("Value
of
a
if(a>O)
func2(--a);
}
func2(int
b)
{
printf ("Value
of
b
if (b>O)
func1 (- -b);
(13)void
disp(int,
int);
main( )
{
int
x=15;
float
y=290.5;
disp (x, y) ;
%d\n" ,a) ;
%d\n",b);

void
disp (int 'a, int
b)
{
printf ("%d
%d\n", a, b) ;
}
(14)void func(void
).;
main ( )
{
int
i=S;
for(i=i+1;i<8;i++)
func ( ) ;
}
void
func (void)
int
j;
for{j=1;j<3;j++)
printf(~%d\t",++j);
(lS)main(
{
int
i=10, k;
for
k=mult(i)
U (- -i<S)
break;
r
printf{"k=%d\n",k);
}
mult(int
j)
{
j *=j.;
return(j) ;
(16) main (
{
int
i=2,j=3;
printf("%d\n",func(i,j) );
}
func(int
a,int
b)
a=a-S;
b++;
return ( ! a+- -b) ;
(17)main(
{
int
X;
C in Depth

Functions
x=func(2,3,4) ;
printf("%d\nH,x) ;
}
func(int
a,int
b,int
c)
{
return(a,b,c) ;
(18)void
func (int
a, int
b);
rna'in ( )
{
int
i=5,j=lO;
func(i/2,j%3) ;
}
void
func(int
a,intb)
a=a/2;
b- -;
printf("%d\tH,a+b) ;
(19)int
a=5;
void
func (void
);
main ( )
{
func ( ) ;
printf ("%d\n H, a) ;
}
void
func (void)
{
int
a=2;
printf ("%d\t H, a);
}
(20,)rnq.in(
{
int
a=2,b=5;
a=func(a+b,a-b) ;
printf("%d\nH,a) ;
}
func (int
x, int
y)
{
return
X+Y,
x-y;
( 2 1 ) rna i n ( )
{
int
i=O, k=3;
i+=func (k) ;
i+=func (k) ;
i+=func (k) ;
printf("%d\nH,i);
153

."
154
C in Depth
fune (int
k)
(
static
int
m=2;
m=m+k;
return
m;
(22)main(
{
int
n=8;
printf("%d\nU,fune(n)) ;
}
fune (int
n)
{
if(n==O)
return
0;
else
return(n+fune(n-l));
(23)main(
{
int
a=2,b=6;
_
printf("%d\tU,funel(a,b));
printf("%d\n U,fune2(a;b));
}
funel (inta, int
b)
{
int
i,s=O;
for(i=a;i<=b;i++)
s=s+i*i;
}
return
s;
}
fune2 (int
a, int
b)
{
int
s;
if (a<b)
s=a*a+func2(a+l,b) ;
else
s=a*a;
:24)main(
{
int
a=7, b=8;.
printf("%d\nU,fune(a,b)) ;
}
fune(int
x,int
y)
{

Functions
if (x==O)
return
y;
else
func (- -x, ++Y)
(25)main(
{
int
x=55, y=l 7;
printf("%d\n",func(x,y»;
}
func (int
x, int
y)
{
int
q=O;
if (x<y)
return
0;
else
return
func(x-y,y)+l;
(26)main(
{
funcl (6);
printf("\n") ;
func2 (6);
}
funcl (int
x)
{
printf("%d
",x);
if (x>2)
funcl(- -x);
}
func2 (int
x)
{
if (x>2)
func2 (- -x) ;
printf("%d. ",x);
155
Programming .Exercise
1.
Write a function cubesum( ) that accepts an integer and returns the sum of the ~ubes .of individual
digits of that number. Use this program to print Armstrong numbers in a given rarge. (See program
P5.24)
2.
Write a function that inputs a number and returns the product of digits of that number until the
product is reduced to one digit ( like P5.25). The number of times digits need to be multiplied
to reach one digit is called the persistence of the number. Write another function pers( )to input
a number and return its persistence.
For example:
86 ~
48 ~ 32 ~6
(persistence 3)
341 ~ 12 ~ 2
( persistence 2)

156
C in Depth
3.
Write a functi9n sumdiv( ) that finds the sum of divisors of a number. (Divisors of a number are
those numbers by which the number is divisible). For example divisors of 36 are 1, 2, 3, 4, 6,
9, 18. A number is called perfect if the sum of divisors of that number is equal to the number.
For example 28 is a perfect number, since 1+2+4+7+14 =28. Write a program to print all the perfect
numbers in· a given range.
4.
Write a program to find the sum of this series upto n terms.
1 + 1 / 2 + 1 / 4 + 1 / 9 + 1 / 16 +
.
5.
Write a program to find out the roots of quadratic equation
ax2 + bx + c = O.
6.
Write a function that accepts a character in lower case and returns its upper case equivalent.
7.
Write a program mult() that accepts two integers and returns their product. Don't use the * operator.
Similarly make two more functions quo( ) and rem( ) that accept two integers and return the quotient
and remainder respectively, without the use of / and % operators.
8.
Write a recursive function to find the sum of digits of a number.
.,
sumd(n) = {O
(n%10) + sun1d(n/l0)
n=O
n>O
9.
Write a recursive function to find the combinations of n objects taken l' at a time
l' = 0 or n = l'
rcomb(n, 1')=
rcomb(n-l, 1') + rcomb(n-l, 1'-1) )
otherwise
10.
Write a program to print number in words using recursion. For example if we have a number
31246, then the program should print
"
Three one Two four Six
Answers
(1)
(2)
(3)
(4)
We can't use goto between functions, so this program will show an error stating that ab is an
undefined label.
i=9
The function is declared as void so it doesn't return any value, and so the functi0!1 call can't be
used.in any expression.
If no value is returned through return 'statement; ana the function IS not declared of type void
then garbage, value is returned, so the variable x will have garbage value.
54321
Here the definition of maine ) is written recursively.
(6)
9·
Since function declaration is absent, so garbage value is passed in variable c, inside the function
variable c is assigned the value 4. If the function is declared. as-
int func( int, int , int);
then we'll get an error stating that there are too few parameters in call to func( ).

Functions
157
(7)
5
If the function is declared as-
int func(int, int);
then we'll get an error stating that there is an extra parameter in call to func( ).
(8)
Error: Multiple declaration for x in func( ).
(9)
Error:
Expression syntax
The operands of conditional operator should be expressions, but return x and return yare not
expressions.
(10) 22
We can have a function call in return statement of another call.
(11) We'll get errors because a function definition can't be written inside definition of another function.
(12) Value of a = 5
Value of b = 4
Value of a = 3
Value of b = 2
Value of a = 1
Value of b = 0
This is an example of indirect recursion.
(13) 15
290
(14) 2
2
(15) k = 25
(16) 3
(17) 4
Here expression a, b, c is considered as an expression with comma operator, so the value of
expression is rightmost value, hence value of c gets returned.
'"
(18) 1
(19) 2
5
In func( ), the local variable will be accessed, because whenever there is a conflict between the
local and global variables, the local variable gets the priority.
(20) 10
(21) 24
(22) 36
func( ) finds the sum of series 1+2+3.... +n
(23) 90
90
Both functions funcI ( ) and func2( ) return the sum of squares of numbers from a to b, funcI (
) uses iterative method while func2( ) uses recursive method.
(24) 15
func( ) is a recursive function for adding two integers.
(25) 3
. func() is a recursive function to find out the quotient.
(26) 6 5 4 3 2
223 4 5

Chapter 7
Arrays
The variables that we have used till now are capable of storing only one value at a time.
Consi~er a
situation when we want to store and display the age of 100 employees. For this we have to do the
following-
1.·
Declare 100 different variables to store the age of employees.
2.
Assign a value to each variable.
3.
Display the value of each variable.
Although we can perform our task by the above three steps but just imagine how difficult it would
be to handle so many variables in the program and the 'program would become very lengthy. The concept
oflarrays is useful in these· types of situations where we can group· similar type of data items.
An array is a collection of similar type of data items and each data item is called an element of the
array. The data type of the elements may be any valid data type like char, int or float. The elements
of array share the same variable name but each element has a different index number known as subscript.
For the above problem we can take an array variable age[ 100] of type into The size of this array variable
is 100 so it is capable of storing 100 integer values. The individual elements of this array are- .
"
age[O], age[l], age[2], age[3], age[4],
age[98], age[99]
In C. the subscripts start from zero, so age[O] is the first element, age[ 1] is the second element of arra)
and so on.
Arrays can be single dimensional or multidimensional. The number of subscripts detennines the dimensiOl
of array. A one-dimensional array has one subscript, two dimensional array has two subscripts and
on. The one-dimensional arrays are known as vectors and two-dimensional arrays are known as matrice:
fn this chapter first we will study about single dimensional arrays andthen move on to multi dimensiom
. "'.
arrays.
7.1
. 7.1.1
Qne Dimensional Array
Declaration of I-D Array
Like other simple variables, arrays should also be declared before they are used in the program.
The syntax for declaration of an array is-
data_type
array~name[size];
Here array_name denotes the name of the array and it can be any valid C identifier, data_type is
data type of the elements of array. The size of the array specifies the number of elements that
be stored in the array. ·lmay be a positive integer constant or constant integer expression.

Arrays
159
Here are some examples of array declarations-·
int age[100]; .
float sal[15];
char grade[20];
Here age is an integer type array, which can store 100 elements of iriteger type. The array sal is a floating
type array of size 15, can hold float values and third one is a character type array of size 20, can hold
characters. The individual elements of the above arrays are-
age[O], ageI1], age[2],
age[99]
sal[O], sal[I], sal[2]!
sal[14]
.grade[O], grade[I], grade[2],
grade[19]
When the array is declared, the compiler allocates space in.memory sufficient to hold all the elements
of the array, so the compiler should know the size of array at the compile time. Hence we can't use'
variables for specifying the size of array in the declaration. The symbolic constants can be' used to
specify the size of array. For example-
,
-
#defineSIZE
10
rnain( )
{
int
size=15;
float
sal [SIZE] ;
int
rna r k s [ s i z e] ;
/*Valid*/
/ *Not
valid*/
} .
The use of symbolic constant to specify the size of array makes it convenient to modify the program
if the size of array is to be changed later, because the size has to be changed only at one place i.e.
in the #define directive.
7.1.2
Accessing I-D Array Elements
Theelements of an array can be accessed by specifying the array name followed by subscript in brackets.
In C, the array subscripts start from O. Hence if there is an array of size 5 then the valid subscripts
will be from 0 to 4. The last valid subscript is one less than the size of the array. This last valid subscript
is sometimes know as the upper bound of the array and 0 is known as the lower bound of the array.
Let us take an array-
int arr[5];
/*Size of array arr is 5, can hold five integer elements*/
The elements of this array are-
arr[O],
arr[l], arr[2], arr[3],
arr[4]
3ere 0 is the lower bound and 4 is the upper bound of the array.
e subscript can be any expression that yields an integer value. It can be any integer constant, integer
-ariable, integer expression or return value(int) from a function call. For example, if i and j are integer
riables then these are some valid subscripted array elements-
arr[3]
arr[i]
arr[i+j]

arr[2*j]
arr[i++]
A subscripted array element is treated as any other variable in the program. We can store values in
them, print their values or perform any operation that is valid for any simple variable of the same data
type. For example if arr[5] and sal[10] are two arrays then these are valid statements-
C in Depth
into
sal[2]*/
of
sal[2]*/
and increment
the value ofi*
arra
1*/
/*Input
value
/*Print
value
value of
sal[2]
int
arr[5];
fioat
sal (10).:
inti;
sc'anf("%d",.&arr[l]);
/*input
value
into
arr[l]*/
printf("%f",sal[3]);
/*print
value .of
sal[3]*/
arr[\4]=25;
/*assign
a
value
to
arr[4]
*/
arr[4]++;
/*Increnient
the
value
of
arr[4]
by
sal[5]+=200;
/*Add
200
to
sal[5]*/
sum=arr[0]+arr[l]+arr[2]+arr[3]+arr[4] ;/*Add
all
the
values
of
arr[5]*/
i=2;
scanf("%f",&sal[i]) ;
printf("%f",sal[i]) ;
printf ("%f", sal [i++]); /*Print
160
Processing 1-D Arrays
7.1.3
For processing arrays we generally use a for loop and the loop variable is used at the place of subscri
The initial value of loop variable is taken 0 since array subscripts start from zero. The loop variab
is increased by 1 each time so that we can accesS and process the next element in the array. The to
number of passes in the loop will be equal to the number of elements in the array and in each p
we will process one element.
Suppose arr[10] is an array of int type-
(i)
Reading values in arr[10]
fore i = 0; i < 10; i++)
scanf("%d", &arr[i]);
(ii)
Displaying values of arr[ 10]
fore i = 0; i < 10; i++)
printf(%d ", arr[i]);
(iii)
Adding all the elements of arr[ 10]
sum = 0;
fore i = 0; i < 10; i++)
sum+=arr[i];
In C there is no check on bounds of the "array. For example if we have an array arr[5] , the
vali~
subscripts are only 0, 1, 2, 3, 4
and if someone tries to access elements beyond these subscrip
like arr[5] , arr[10] or arr[-I], the compiler will not show any error message but this may lead to rm
time errors, which can be very difficult to debug. So it is the responsibility of programmer to provi
array bounds checking wherever needed.

Arrays
/ * P7 . 1
Program
to
input
values
into
an
array
and
display
th,em* /
#include<stdio.h>
main( )
{
int
arr[5J,i;
ior(i=0;i<5;i++)
161
printf ("Enter
the
value
for
arr[ %d]
scanf("%d".&arr[i)) ;
" , i) ;
}
printf ("The
array
elements
are
for(i=0;i<5;i++)
printf("%d\t",arr[i]);
printf ("\n");
}
Output:
Enter the value for arr[O]
U
Enter the value for arr[ 1]
45
Enter the value for arr[2]
59
Enter the value for arr[3]
98
Enter the value for arr[4]
21
_ The array elements are :
12
45
59
98
21
\n" ) ;
/ *P7 .2
Program
to
add
the
elements
of
an
array* /
#include<stdio.h>
main ( )
{
int
arr[10],i,sum=0;
for(i=0;i<10;i++)
{
printf ("Enter
the
value
for
arr [%d]
scanf("%d~,&arr[i]);
sum+=arr[i];
printf ("Sum
=
%d\n". sum) ;
/*P7.3
Program
to
count
the
even
and
odd
numbers
in
a
array*/
#include<stdio.h>
#define
SIZE
10
main( )
{
int
arr [SIZE] • i. even=O_, odd=O;
for(i=O;i<SIZE;i++)
{
printf ("Enter
the
value
for
arr lId]
scanf("%d".&arr[i]) ;
if(arr[i]%2==0)
fJ Ii) .

162
even++;
else
odd++;
print£: ("Even
numbers
%d, Odd
numbers
=%d\n", even, odd
);
C ill Depth
7.1.4
Initialization of I-D Array
After declaration, the elements of a local array have garbage value while the elements of global and
static arrays are automatically initialized to zero. We can explicitly initialize arrays at the time ofdeclaration.
The syntax for initialization of an array is-
data_type array_name[size]={valuel, value2
valueN };
Here array_name is the name of the array variable, size is the size of the array and valueI, value2,
............valueN are the constant values known as initializers, which are assigned to the array elements
one after another. These values are'separated by commas and there is a semicolon after the ending
braces. For example-
int marks[5] = {50, 85, 70, 65, 95};
The values of the array elements" after this initialization are-
marks[O] : 50,
marks[I]: 85,
marks[2]: 70,
marks[3]: 65,
marks[4]: 95
While initializing I-D an'ays, iUs optional to specify the size of the array. If the size is omitted during
initialization then the compiler assumes the size of array equal to the number of initializers. For example-
. int marks[] = { 99, 78, 50,45, 67, 89};
float sal[] = { 25.5, 38.5, 24.7};
Here the size of array marks is assumed to be 6 and that of sal is assu-med to be 3.
Ifduring initialization the number of initializers is less than the size of array then, all the remaining elements
of array are assigned value zero. For example-
'"
int marks[5] = { 99, 78};
\
Here the size of array is 5 while there are only 2 initializers. After this initialization the value of the
elements are as-
\
.
marks[O] : 99,
marks[l]: 78,
marks[2]: 0,
marks[3]: 0,
marks[4]: 0
So if we initialize an array like this-
int arr[IOO] = {O};
then all the elements of arr will be initialized to zero.
If the number of initializers is more than the size given in brackets then compiler will show an erro
For examp!e-
int arr[5] = '{I, 2, 3,4,5,6,7, 8};
/*Error*i
We can't copy all the elements of an array to another array by simply assigning it to the other area:.
For example if we have two arrays a[5] and b[5] then
int a[5] = {I, 2, 3, 4, 5};
int b[5];
b = a;
/*Not valid*/

Arrays
163
We'll have to copy all the elements of array one by one, using a for loop.
for( i = 0; i < 5; i++)
b[i] = a[i];
hi the following program we'll find out the maximum and minimum number in an integer array.
/ *P7 .4
Program
to
find
the
maximum
and
minimum
number
in
an
array* /
#include<stdio.h>
main ( )
{
int
i, j , arr[ 10] = { 2 , 5, 4, 1, 8, 9, 11 , 6, 3 , 7} ;
int
min, max;
min=max=arr[O] ;
for(i=l;i<lO;i++)
{
'%d\n" ,min, max) ;
\\
Maxi~um
\
if(arr[i]<min)
min=arr[i] ;
if(arr[i]>max)
max=arr[i] ;
}
~rintf("Minimum
%d,
}
Output:
Minimum = 1, Maximum = 11
We have taken the value of first element as the initial value of min and max. Inside the for loop, we'll
start comparing from second element onwards so this time we have started the loop from 1 instead
of O.
The following program will reverse the elements of an array.
/ *P7 . 5
Program
to
reverse
"the
elements
of
an
array* /
#include<stdio.h>
main ( )
{
int
i,j,temp,arr[lO)={1,2,3,4,5,6,7,8,9,lO}:
.for(i=O,j=9;i<j;i++,j- -)
{
temp=arr[i);
arr [i) =arr [j ) ;.
arr[j]=temp;
}
printf ("After
reversing
the
array
is
) :
for(i=O;i<10;i++)
printf("%d
",arr[i]);
printf("\n") ;
}
Output:
After reversing the array is
10
9
8
7
6
5
4
3
2
1
In the for loop we have used comma operator and taken two variable i and j. The variable i is initialized
l
......._

./.
164
C in Depth
with the lower bound and j is initialized with upper bound. After each pass of the loop, i is incremented
while j is decremented. Inside the loop, a[i] is exchanged with a(j]' So a[O] will be exchanged with
a[9], a[l] with a[8], a[2] with a[7] and so on.'
'
The next program prints the binary equivalent of a decimal number. The process of obtaining a binary
number form decimal number 29 is given below:
29/2
14/2
7/2
3/2
1/2
Quotient
14
7
3
1
o
Remainder
1
a[O]
o
a[l]
1
a[2]
1
a[3]
1
a[4]
MSB
LSB
't
I
We will store the remainders in an array, and then at last the array is printed in reverse order to get
the binary number.
/ *P7 . 6
Program
to
convert
a
decimal
number
to
binary
number
* /
#include<stdio.h>
main( )
{
\
printf ("Binary
number
is
") ;
for(j=i-1;j>=0;j- -)/*print
the
array
backwards*/
printf("%d",arr[j));
printf("\n") ;
}
Output:
Enter a decimal number
: 29
Binary number is : 11101
The next program searches for a particular item in the array.
~
'/*P7.7
Program
to
search
for
an
item
in
the
array*/
#
inc1ude<stdio. h>
#define
SIZE
10
main (
)
{
\
" ) ;
/ * s tore
the
remainder
in
array* /
arr [i) =num%2; ,
num/=2;
i++;
, . int
num, rem, arr [ 15) , i, j ;
printf ("Enter
a
decimal
number
scanf("%d",&num) ;
i=O;
while(num>O)
{
int
i,arr[SIZE)={23,12,56,98,76,14,65,11,19,45};
int
item;
printf ("Enter
the
i tern
to
be
searched
") ;

Arrays
scanfl"%d",&item)~
for(i=O;i<SIZE;i++)
{
if(item==arr[i))
{
printf ("%d
found
at
position
%d\n", item, i+1);
break;
165
}
if (i==SIZE)
printf("Item
%d
not
found
in
array\n" ,
item) ;
}
The item to be searched is compared with each element of the array, if the element is found, for loop
is terminated through break statement. The control can come out of the loop in two cases, first if the
item is found and loop is terminated through break and second if item is not found and the loop is
fully executed. In the second case the value of i would be equal to SIZE. Here we are searching the
item sequentially so this search is known as linear or sequential search.
I.
7.1.5
I-D Arrays And Functions
7.1.5.1
Passing Individual Array Elements to a Function
We know that an array element is treated as any other simple variable in the program. So we can pass
individual array elements as arguments to a function like other simple variables.
/*P7.8
Program
to
pass
array
elements
to
a
function* /
#include<stdio.h>
mainl)
{
int
arr[lOJ,i;
printf I "Enter
the
array
elements
") ;
for(i=O;i<10;i++)
{
'scanfl"%d",&ar~[i) );
checklarr[i)) ;
}
check (int
num)
{
if (num%2==O)
printf("%d
else
printf("%d
is
even\n",num);
is
odd\n", num) ;
7.1.5.2
Passing whole I-D Array to a Function
We can pass whole array as an actual argument to a function. The corresponding formal argument should
be declared as an array variable of the same data type.
mainl )

166
C in Depth
int
arr[10]
func(arr);/*In
function call,array name is specified without brackets*/
}
func(int
va1[10])
{
It is optional to specify the size of the array in the formal argument, for example we may write the
function definition as-
func (int
val [
])
{
/*P7.9
Program to understand the effect of passing
~n array to a function*/
#include<stdiO.h>
main ( )
{
We have studied that changes made in formal arguments do not affect the actual arguments, but this
is not the case while passing an array to a function. The mechanism of passing an array, to a function
is quite different from that ofpassing .a simple variable. We have studied earlier that in the case of simple
variables, the called function creates a copy of the variable and works on it, so any changes, made in
the function do not affect the original variable.
When an array is passed as an actual argument, the
called fu~ction actually gets access to the original array and works on it, so any changes made inside
the function affect the original array. Here is a program in which an array is pass~d to a function.
. int
i, arr [6] ={1, 2, 3,4, 5, 6} ;
func (arr).;
printf ("Contents
of
array
are
now
for(i=O;i<6;i++)
printf("%d
",arr[i»;
printf("\n") ;
}
func(int
vale])
{
int
sum=O,i;
for(i=O;i<6;i++)
{
val[i]=val[i]*val[i] ;
sum+=val[i];
\\ ) ;
}
printf("The
sum
of
squares
=
%d\n",sum);
}
Output:
The sum of squares = 91
The contents of array are now : 1 4 9 16 25 36

Arrays
167
Here we can see that the changes made to the array inside the called function are reflected in the calling
function. The name of the formal argument is different but it refers to the original array.
Since it is not necessary to specify the size of array in the function definition, so we can write general
functions that can work on arrays of same type but different sizes. For example in the next program,
the function add( ) is capable of adding the elements of any size of an integer array.
/ *P7 . 10
Program
that
uses
a
general
function
that
works
on
arrays
of
different
sizes* /
#include<stdio.h>
main ( )
{
int
a[5]={2,4,6,8,10};
int
b [8] = {1, 3,5,7,9,11,13,15} ;
int
c [10] = {l, 2,3,4,5,6,7,8,9,10} ;
printf ("Sum
of
elements
of
array
a
printf ("Sum
of
elements
of
array
b
printf ("Sum
of
elements
of
array
c
}
add(i.nt
arr[],int
n)
{
int
i, sum=O;
for(i=O;i<n;i++)
sum+=arr[i];
return
sum;
}
Output:
Sum of elements of array a : 30
Sum of elements of array b : 64
Sum of elements of array c : 55
%d\n",add(a,5»;
%d\n",add(b,8»
;
%d\n",~dd(c,10»
;
7.2
Two Dimensional Array
7.2.1
Declaration and Accessing Individual Elements of a 2-D array
The syntax of declaration of a 2-D array is similar to that of I-D arrays, but here we have two subscripts)
data_type
array_name[rowsize][columnsize]; ,
Here· rowsize specifies the number of rows and }lolumnsize represents the number of columns in the
array. The' total number of elements in the array are, rowsize * columnsize.For example-
int arr[4][5];
Here arr is a 2-D array with 4 rows and 5 columns. The individual elements of this array can be accessed
by applying two subscripts, where the first subscript denotes the row number and the second subscript
denotes the column number. The starting element ofthis array is arr[O][O] and the last element is arr[3][4].
The total number of elements in this array is 4*5 = 20.
'

168
C in Depth
ColO
Call
Col2
Col3
Col4
Row 0
arr[O] [0]
arr[O][I]
arr[O][2]
arr[O][3]
arr[OH4]
Row I
arr[I][O]
. arr[l][l]
arr[I][2]
. arr[I][3]
arr[l][4]
Row 2
arr[2][0]
arr[2][I]
arr[2][2]
arr[2][3]
arr[2][4]
Row 3
arr[3][0]
arr[3][I]
arr[3][2]
arr[3][3]
arr[3][4]
7.2.2
Processing 2-D Arrays
for(j=O;j<5;j++)
printf("%d
",arr[i][jj);
printf("\n") ;
for(i=O;i<4;i++)
For processing 2-D arrays, we use two nested for loops. The outer for loop corresponds to the row
and the inner for· loop. corresponds to the column.
int arr[4][5];
(i)
Reading values in arr
for( i = 0;
i < 4; i++ )
for( j = 0; j< 5; j++ ).
'"
scanf("%d" &arr[i][jD;
(ii)
Displaying values of arr
for( i = 0;
i < 4; i++ )
for( j = 0; j< 5; j++ )
printf( "%d
", arr[i]UD;
_This will print all the elements in the same line. If we want to print the elements of different rows
on different lines then we can write like this-
.Here the printf("\n") statement causes the next row to begin from a new line.
/ *P7. 11
Program
to
input
and
display
a
matrix* /
#define
ROW
3
#def ine
COL
4
tinclude<stdio.h>
main ( )
{
int
mat [ROW] [COL], i, j;
printf ("Enter
the
elements
of
matrix (%dx%d)
rOW-Wlse
; \n" ,ROW, COL) ;
for(i=O;i<ROW;i++)
for(j=O;j<COL;j++)
scanf ("%d", &mat[i] [j]);
printf ("The
matrix
that
you
have
entered
is
; \n") ;
for(i=O;i<ROW;i++)
(
for(j=O;j<COL;j++)

Arrays
169
printf("%5d",rnat[i] [j]);
printf("\n") ;
}
printf("\n") ;
Output:
Enter the elements of matrix(3x4) row-wise -
2 3 4 7
8 5 I 9
1 825
The matrix that you have entered is -
2
3
4
7
8
5
1
9
I
825
7.2.3
Initialization of 2-D Arrays
2-D arrays can be initialized in a way similar to that of I-D arrays. For example-
int mat[4][3] = { 11, 12, 13, 14, 15, 16, p, 18, 19, 20, 21, 22};
These values are assigned to the elements row-wise, so the values of elements after this initialization
are-
mat[O][O]
11
mat[I][O]
14
mat[2][0]
17
mat[3][0] : 20
mat[O][I] : 12
mat[I][IJ.: 15
mat[2][1] : 18
mat[3][1] : 21
mat[0][2]
13
mat[I][2]
16
mat[2][2]
19
mat[3][2] : 22
o
* /
1
* /
2
* /
3
* /
/*
Row
/*
Row
/*
Row
/*
Row
.While initializing we can group the elements row-wise using inner braces. For example-
in t
rna t [ 4] [3] ={{11 , 12 , 13 } , {14, 15 , 16 } , {I 7 , 18 , 19 } , {2 0 , 21 , 22 } } ;
int
rna t [ 4] [3] = {
{11,12,13},
{l4,15,16},
{l7,18,19},
{20,21,22}
} ;
Here the values in the first inner braces will be the values of Row 0, values in the second inner braces
will be values of Row 1 and so on.
Now consider this array initialization-
int
rna t [ 4] [3] ={
{11 },
{12,13},
{l4,15,16},
{17}
/ *Row
0* /
/ *Row
1 * /
/ *Row
2 * /
/*Row
3* /
} ;

170
C in Depth
The remaining elements in each row will be assigned values 0, so the values of elements will be-
{l,10},
{2,20,200J,
{3 },
{4, 40, 400}
. In 2-D arrays it is optional to specify the first dimension but the second dimension should always be
present. For example-
int
rna t [) (3) = {
: \n", ROW ,.COL) ;
mat[O][2]
0
mat[1 ][2]:
0
mat[2][2]:
16
mat[3][2]:
0
mat[O][I]
0
mat[l][l] : .13
mat[2][ 1]
15
mat[3][1]
0
printf ("Enter
matrix
mat2 (%dx%d) row-wise
for(i=O;i<ROW;i++)
for(j=O;j<COL;j++)
scanf ("%d", &mat2 [i) [j]);
mat[O][O]:
11
mat[1][0]
12
mat[2][0]
14
mat[3][0]
17
} ;
Here first dimension is taken 4 since there are 4 rows in initialization list.
A 2-D array is also known as a matrix. The next program adds two matrices;- the order of both the
matrices should be same.
.
i~t
i, j, matl [ROW) [COL) ,mat2 [ROW) [COL) ,mat3 [ROW] [COL) ;
printf ("Enter
matrix
matl (%dx%d) row-wise .: \n" ,ROW, COL) ;
for(i=O;i<ROW;i++)
for(j=O;j<COL;j++)
scanf ("%d", &matl [i) [j)
;
/*P7.12
Program
for
addition
of
two
matrices.*/
#define
ROW
3
#define
COL
4
#include<stdio.h>
main (
)
/*Addition*/
for(i=O;i<ROW;i++)
for(j=O;j<COL;j++)
rna t 3 [i) [j ) =ma t 1 [ i) [j ) +ma t 2 [i) [j ) ;
printf ("The
resultant
matrix
mat3
is
: \n");
for(i=O;i<ROW;i++)
{
for(j=~;j<COL;j++)
printf ("%5d" ,mat3 [i) [j);
printf("\n")';

Arrays
Output:
Enter elements of first matrix mat1(3x4) row-wise -
1 284
5 6 7 8
3 2 1 4
Enter elements of second matrix mat2(3x4) row-wise -
2 5 4 2
1 526
9 4 7 2
The resultant matrix mat3 is -
3
7
12
6
6
11
9
14
12
6
8
6
171
Now we'll write a program to multiply two matrices. Multiplication of matrices requires that the number
of columns in first matrix should be equal to the number of rows in second matrix. Each row of first
matrix is multiplied with the column of second matrix then added to get the element of resultant matrix.
If we multiply two matrices of order mxn and nxp then the multiplied matrix will be of order mxp.
For example-
.
[
4 :]
[2
6
~
A2• 2 =
B
-
.
3
2>3
-3
2
. _ [
4*2 + 5*(-3)
4*6 + 5*2
4*3 + 5*'J
[~7
34
32J
C2• 3 -
3*2 + 2*(-3)
3*6 + 2*2
3*3 + 2*4
22
17
/*P7.l3
Program
for
multiplication
of
two
matrices*/
#include<stdio.h>
#def ine
ROWl
3
#define
COLl
4
#define
ROW2
COLl
#define
COL2
2
main(
)
int
matl[ROWlj [COL1J,mat2[ROW2j [COL2j,mat3[ROWlj [COL2j;
int
i,j,k;
printf ("Enter
matrix
matl(%dx%d) row-wise
: \n", ROW1, COL1) ;.
for(i=Oji<ROWlji++)
fbr(j=O;j<COL1;j++)
scan f ( " %d" , &matl [ i j [j j ) ;
printf ("Enter
matrix
mat2 (%dx%d) row-wise
: \n" ,ROW2, COL2} ;

}
Output:
Enter matrix mat1(3x4)row-wise -
2 1 4 3
527 1
3 1 4 2
Enter matrix mat2(4x2)row-wise -
1 2
3 4
2 5
62
The Resultant matrix mat3 is -
31
34
31
55
26
34
The next program finds out the. transpose of a matrix. Transpose matrix is defined as the matrix that
is obtained by interchanging the rows and columns of a matrix. If a matrix is of mxn order then its
transpose matrix will be of order nxm.
/*P7.14
Program
to
find
the
tranpose
of
I!)atrix.*/
#include<stdio.h>
#define
ROW· 3
#define
COL
4
main ( )
{
172
for{i=O;i<ROW2;i++)
for{j=O;j<COL2;j++)
scan f ( "%d" , &ma t 2 [ i) [j ) ) ;
I *Mul tiplication
* I
for{i=O;i<ROW1;i++)
for{j~O~j<COL2;j++)
{
rna t 3 [ i) [j) = 0 ;
for{k=O;k<COL1;k++)
rna t 3 [ i) [j) + =rnatl [ i) [k) *rna t 2 [k) [j ) ;
printf ("The
Resultant
matrix
mat3
is
: \n") ;
for.{i=O;i<ROW1;i++)
{
~or{j=O;j<COL2;j++)
printf ("%5d" ,mat3 [i) [j));
printf{"\n");
int
matl [ROW) [COL] ,mat2 [COL] [ROW], i, j;
printf ("Enter
matrix. matl (%dx%d)
row-wise
\n" ,ROW, COL) ;
C in Depth

Arrays
for(i=O;i<ROW;i++)
for(j=O;j<COL;j++)
scan f ( "%d" , &ma t 1 [ i] [j ] ) ;
for(i=O;i<COL;i++)
for(j=O;j<ROW;j++)
ma t 2 [i] [j ] =mat 1 [j ] [i] ;
printf ("Tranpose
of
matrix
is; \n") ;
for(i=O;i<COL;i++)
{
for(j=O;j<ROW;j++)
printf ("%5d" ,mat2 [i] [j] ) ;
printf ("\n");
}
Output:
Enter matrix mat1(3x4) row-wise-
3 2 1 5
6 5 8 2
934 1
173
Tranpose of matrix is-
369
253
184
521
7.3
Arrays With More Than Two Dimensions
~
We'll just give a brief overview of three-d arrays. We can think of a three-d array as an array of 2-
D arrays. For example if we have an array-
int arr[2][4][3] ;
We can think of this as an array which consists of two 2-D arrays and each of th9se 2-D array has
4 rows and 3 columns.
[0][0]
[0][1]
[0][2)
[0][0]
[0][1]
[0][2]
[0]
[1][0]
[1][1]
[1 ][2]
[1]
[1 ][0]
[1][1]
[1][2]
[2][0]
[2][1]
[2][2]
[2][0]
[2][1]
[2][2]
[3][0]
[3][1]
[3][2]
[3][0]
[3][1]
[3][2]
The individual elements are-
arr[O][O][O], arr[O][O][1], arr[O][O][2], arr[O][1][0]
arr[O][3]2]
arr[I][O][O], arr[I][O][I], arr[I][0][2], arr[l)[I][O]
arr[I][3]2]
Total number of elements in the above array are-

The value of elements after this initialization are as-
arr[O][O][O] :
I
arr[O][O][I] :' 2
arr[0][0][2] :
3
arr[O][l ][0] :
4
arr[O][I][I] :
5
arr[0][1][2] :
0
arr[0][2][0] :
6
arr[0][2][1] :
7
arr[0][2][2] :
8
, arr[0][3][0] :
9
arr[0][3][1] :
0
arr[0][3][2] :
0
arr[l][O][O] :
10
arr[I][O][ll:
11
arr[I][0][2] :
0
arrD][ 1][0] :
12
arr[I][I][I] :
13
arr[1][1][2] :
14
arr[I][2][0] :
15
arr[ 1][2][1] :
16
arr[I][2][2] :
0
arr[ 1][3][0] :
17
arr[ 1][3][1] :
18
arr[ 1][3][2] :
19
174
=2*4*3
= 24
This array can be initialized as-
int
arr[2][4] [3]={
},
{
{1,2,3},
{4, S} ,
{6,7,8},
{9 }
{l0,11},
{l2,13,14},
{lS,16}
{17,18,19}
/*Matrix
0,
Row
0*/
/*Matrix
0,
Row
1*/
/*Matrix
0,
Row
2*/
/*Matrix °,
Row
3*/
/*Matrix
1,
Row
0*/
/*Matrix
1,
Row
1*/
/*Matrix
1,
Row
2*/
/*Matrix
1,
Row
3*/
C in Depth
Remember that the rule of initialization of multidimensional arrays is that the last subscript varies most
frequently and the first subscript varies least rapidly.
7.3.1
Multidimensional Array And Functions
Multidimensional arrays can also be passed to functions like I-D arrays. When passing multidimensional
arrays the first(leftmost) dimension may be omitted but all other dimensions have to be specified in
the function definition. For example it would be invalid to write a function like this-
func(int
a[
Lint
b[
][
Lint
c[
][
][
]) '/*Inva1id*/
{
In arrays band c we can't omit all the dimensions. The correct form
is~
func(int
a[
],int
b[
][4],int
c[
'][3JlS])
{
/*valid*/

We'll discuss strings in detail in a separate chapter, here is just a brief introduction to strings. In C,
strings are treated as arrays of type char and are terminated by a null character('\O'). This null character
~ .
has ASCII value zero~-
These are the two forms of initialization of a string variable-
char str[IO] = {'I', 'n', 'd', 'i', 'a', '\0' };
char str[IO] = "India";
/*Here the null character is automatically placed at the end*/
Arrays
7.4
7.4.1
Introduction To Strings
Input and output of strings
175
J *P7. 15
Program
for
input
and output
of
strings using
scanf ()
and printf (
) *J
#include<stdio.h>
main( )
{
char
str[10]="Anpara"";
printf("String
is
%s\n",str);
printf ("Enter
new
value
for
string
) ;
scan f ( "% s" , s t r) ;
printf ("String
is
%s\n", str);
}
Output:
String is : Anpara
Enter new value for string : Bareilly
String is : Bareilly
The next program uses the functions gets( ) and puts( ) for the input and output of strings.
"'.
J*P7.16
Program for
input
and output
of strings using gets ()
and puts ( ) * J
#include<stdio.h>
main( )
{
char
str[10];
printf ("Enter
string
") ;
gets(str);
printf ("String
is
") ;
puts (str);
}
Output:
Enter string: New Delhi
String is : New Delhi
7.5
Some Additional Problems
Problem 1
Write a program using arrays, that reads a decimal numher and converts it to (1) Binary (2) Octal or
(3) Hexadecimal depending on user's choice.

Write a program for searching an element in an array through binary search.
The prerequisite for binary search is that the array should be' sorted.' Firstly we compare th
be searched with the middle element of the array. If the item is same as the middle elemen
search is successful otherwise the array is divided into two portions, first portion contains all
/ *P7. 17
Program
to
convert
a
decimal
number
to
Binary,
octal
or
hexadecimal*/
#include<stdio.h>
·main()
{
C in pepth
}
func(int
num,int
b)
{
}
for(j=:i-l;j>=O;j- -)
printf{ "%c", arr[j]);
rem=num%b;
num/=b;
if(rem>9&&rem<16)
arr[i++]=rem-1Q+'A' ;
else
\0
arr[i++]=rem+'O' ;
int
i=O, j ,rem;
char
arr[20];
while(num>O)
{
int
num, opt;
printf ("Enter
a
decimal
number
") ;
scanf("%d",&num) ;
printf ("1.
:Binary\n
2.
Octal \n
3.
Hexadecimal \n" ).;
printf ("Enter
your
option
") ;
scanf("%d",&opt);
switch(opt)
{
case
1:
printf ("Binary
equivalent
is
");'
func(num,2);
break;
,
case
2:
printf("Octal
equivalent
is
");
func (num, 8) ;
break;
case
3:
printf ("Hexadecimal
equivalent
is
") ;
func (num, 16);
break;
printf("\n");
Problem 2
176

Arrays
177
to the left of the middle element and the other one consists of all the elements on the right side of the
element. Since the array is sorted, all the elements in the left portion will be smaller than the middle
element and the elements in the right portion will be greater than the middle element. Now if the item
to be searched is less than the middle element then we search it in the left portion of the array and
if it is greater than the middle element then search will be in the right portion of the array.
Now we will take one portion only for search and compare the item with middle element of that portion.
. This process will continue until we fi~d the required item or middle element has no left or right portion
to search.
To implement this procedure we will take 3 variables viz. low, up and mid that will keep track of the
status of lower limit, upper limit and middle value of that portion of the array, in which we will search
the element. The value of the mid will lie calculated as-
mid =
( low+up) / 2
If item> arr[mid],
search will resume in right portion
low = rpid+1 ,
up will remain same
If item < arr[mid] , search will resume in left portion
up = mid-I,
low will remain same
If
item = = arr[mid] , search is
succe~sful
item found at mid position
If
low> up , search is unsuccessful
item not found in array
Let us take a sorted array of10 elements. Suppose the element that we are searching is 49. The portion
of array in which the element is searched is shown with a bold boundary in the figure.
o
2
3
4
5
6
7
8
9
low =0, up = 9
mid=4
49>25
L.....--.JL...---.Ji----1i.-----I_.....I._--L_........._
........._
........._-J low = mid+1=5
low = 5, up = 9
mid = 7
low = 5, up = 6
mid = 5
low=6, up = 6
mid = 6
49<57
up = mid-l=6 .
49>30
low = mid+1=6
49 ==49
Found
/
Now let us take a case where the search fails. Suppose we are searching the element 16 that is not
present in the array.

178
C in Depth
o
2
3
4
5
6
7
8
9
low = 0, Up ':" 9
mid=4
16<25
up=mid-l=3
low = 0, up = 3
mid = I
16>15
low=mid+1=2
low = 2, up= 3
mid=2
16<18
up=mid-l=1
Now low = 2 and up = 1, the value of low has exceeded the value of up so the search is unsuccessful.
/*P7.l8
Program
to
search
an
element
through
binary
search*/
#include
<stdio. h>
#define
SIZE
10
main(
)
int
arr[SIZE);
int
low,up,mid,i,item;
printf ("Enter
elements
of
the
array(in
sorted
order)
for(i=O;i<SIZE;i++)
scanf("%d",&arr[i);
printf ("Enter
the
item
to
be
searched
") ;
scanf("%d",&item) ;
low=O;
up=SIZE-l;
while(low<=up&&itern!=arr[mid)
{
\n") ;
'--,
mid=(low+up)/2;
if(item>arr[mid) )
low=mid+l;
/*Search
in
right
portion
*/
if (i tern
<arr [mid) )
up=mid-l;
/*Search
in
leftportion
*/
if(item==arr[mid)
printf ("%d
found
at
position
%d\n", item,mid+l);
if(low>up)
printf ("%d
not
found
in
array\n",
item);
Write a program to sort the elements of a I-D array, in ascending order through selection sort.
Sorting is a procedure in which the given elements are ·arranged in ascending or descending order. Fo
example if the elements of an array are-
S, 11, 15, 8, 7, 54, 63, 44
After sorting these clements in ascending order the elements would be- .
5, 7, 8, n, 15,44; 54, 63
/.
Problem 3

C in Depth
Arrays
16<25
=mid-1=3
16>15,
ow=rrrid+1=2
16<18
up--mid-1=1
h is unsuccessful.
:::-ch*/
\n") ;
There are several methods for sorting an array, we'li discuss onI)
insertion). These are discussed in Problems 3, 4 and 6 respectivel
As the name suggests, selection sort technique selects an element a
have a list of elements in unsorted order and you want to sort it, tl
and keep in the new list, after that second smallest element and so (
Let us take an array arr[O], arr[I]
arr[N-l] of elemen
Pass 1:
Compare arr[O] with other elements from arr[l,].
arr[N-l] one
I
exchange arr[O] with the element being compared.
Result: arr[O] is sorted.
Pass 2:
Compare arr[ 1] with other elements from arr[2]
arr[N-1] one b
exchange arr[ 1] with the element "being compared..
Result: arr[O], ariD] are sorted.
Pass 3:
Compare arr[2] with other elements from arr[3]
arr[N-l],
wh
arr[2] with the element being compared.
Result: arr[O], arr[l], arr[2] are sorted.
Pass
N-l:
Compare arr[N-2] with arr[N-l],
if arr[N-2] is bigger then exchar
Result : arr[O] ..................... arr[N-1] are sorted.
Let us take a list of elements in unsorted order and sort them by a
Elements of the array are-
40
20
50
.60
30
10
Pass 1:
40
20
50
60
30
10
arr[O] > arr[l],
20
40
50
60
30
10
arr[O] < arr[2]
20
40
50
60
30
10
arr[O] < arr[3]
20
40
50
60
30
10
arr[O] < arr[4]
~ selection sort.
I
20
40
50
60
30
10
arr[O] > arr[5],
escending order. For
I
20
10
40
50
60
30
Pass 2:
10
40
50
60
30
20
arr[l] < arr[2]
10
40
50
60
30
20
arr[l] < arr[3]

\
Passl
Pass 2
vass 3
Pass 4
Pass 5
i=O
i=2
i=3
i=4
j=1
j=5
j=3
j=4
j=5
j=4
j=5
j=5
0 ,,40
,20
10
10
10
10
10
..10
1 ),zJl
40
20
20
20
20
20
20
2
50
50
·sQ.
50
(flO
30
30
30
3
60
60
60
60
60
60
50
40
4
30
30
40
40
50
,:;0.
60
60
5
10
JO
30
30
.~O
40
40
50
Ex
Ex
Ex
Ex
Ex Ex
·Ex
int
arr [SIZE) ;
in t
i , j , temp;
printf ("Enter
elements
of
the
array
: \n") ;
for(i=O;i<SIZE;i++)
scanf("%d",&arr[i));
for(i=O;i<SIZE-l;i++)
for(j=i+lfj<SIZE;j++)
/*P7.l9
Program
of
sorting
using
selection
sort* /
#include
<stdio. h>
#define
SIZE
10
main( )
{
180
C in Depth
10
40
50
60
30
20
arr[ 1] > arr[4], Exchange
10
30
50
60
40
20
arr{l] > arr[5], Exchange
10
20
50
60
40
30
Pass 3:
10
20
50
60
40
30
arr[2] < arr[3]
10
20
50
60
40
30
arr[2] > arr[4], Exchange
10
20
40
60
50
30
arr[2] > arr[5], Exchange
10
20
30
60
50
40
Pass 4:
10
20
30
60
50
40
arr[3] > arr[4], Exchange
10
20
30
50
60
40
arr[3] > arr[5], Exchange
10
20
30
40
60
50
Pass 5:
10
20 .
30
40
60
50
arr[4] > arr[5], Exchange
10
20
30
40.
50
60
Sorted array is:
10
20
30
40
50
60
The exchanges taking place in the passes are shown in the figure below-

Arrays
if(arr[i]>arr[j])
{
temp=arr[i] ;
arr [i] =arr [j ] ;
arr[j]=temp;
181
} .
printf ("Sorted
array
is
for(i=O;i<SIZE;i++)
printf("%d
",arr[i]);
printf (" \n");
}
Problem 4
\n") ;
Write a program to sort the eleme?ts of a I-D array, in ascending order through bubble sort
If N elements are given, then the procedure for sorting them through bubble sort is as-
The elements of array are arr[O],arr[I]
,
arr[N-l]
Pass 1:
Compare Olh and 151. element, If Olh >151 then exchange them
Compare 151 and 2nd element, If 151 > 2nd then exchange them,
Compare 2nd and 3'd element, If 2nd > 3'd then exchange them,
Compare N-21h with N-llh , If N-21h > N_ph
then exchange them
Pass 2:
Compare Olh and 151 element, If Olh > 151 then exchange them
Compare 151 and 2nd element, If 151 > 2nd then exchange them,
Compare 2nd and 3'd element, If 2nd > 3'd then exchange th.em,
Compare N-3 1h and N-21h element, If N-31h > N-21h then exchange them
Pass N-l:
-
Compare Olh and 151 element,
If
Olh >151 then exchange them
Let us take a list of elements in unsorted order and sort them by applying bubble sort. .
Elements of the array are-
40
Pass 1:
40
20
20
40
20
50
50
50
60
30
30
30
10
10
10
arr[O] > arr[I], Exchange
arr[ 1] < arr[2-]

182
40
'50
40
50
40
50
40
50
30
30
10
C in Depth
arr[O] < arr[ 1]
arr[l] > arr[2], Exchange
arr[O] < arr[l]
arr[l] > arr[2], Exchange
arr[2] > ,arr[3], Exchange
arr[O] > arr[l], Exchange
arr[O] < arr[ 1]
arr[l] < arr[2]
arr[2] > arr[3], Exchange
arr[3] > arr[4], Exchange
arr[2] < arr[3]
arr[3] > arr[4], Exchange
arr[4] > arr[5], Exchange
60
60
60
60
60
60
60
60
60
60
60
60
60
60
10
10
10
60
50
50
50
50
50
50
50
50
50
10
10
10
10
50
30
30
60
10
40
40
40
40
40
30
30
30
50
10
10
10.
10
40
60
60
30
30
30
30
10
10
30
30
30
40
10
50
50
50
30
30
40
40
30
30
40
40
40
40
40
20
20
20
20
Pass 2:
20
20
20
20
20
Pass 3:
20
20
20
20
Pass 4:
20
20
20
PasS 5:
20
10
10'
20
r
Sorted array is-
10
20
30
40
50
60
i=4
j=O
~O
;,10
30
40
50
60
Ex
Pass 4
Pass 5
i=2
j=O
,20
",4,0,
30
10
50
60
Pass 3
Pass 2
j=2
20
40
,SO
6.0
30
10
Passl
i=O
j=O
o 40
1
,~O,
2 50
3 60
4 30.
5 10
Ex
/ *P7 .20
Program
of
sorting
using
bubble
sort * /
#include
<stdio. h>
#define
SIZE
10
main( )

Arrays
int
arr[SIZE];
int
i,j,temp;
printf ("Enter' elements
of
the
array
: \n") ;
for(i=O;i<SIZE;i++)
scanf("%d",&arr[i]);
for(i=O;i<SIZE-l;i++)
{
for(j=O;j<SIZE-l-i;j++)
{
if(arr[j]>arr[j+l])
{
temp=arr[j] ;
arr[j]=arr[j+l];
arr[j+l]=temp;
}
printf ("Sorted
array
is
: \n") ;
for(i=O;i<SIZE;i++)
printf("%d
",arr[i]);
printf("\n") ;
Problem 5
183
Write a program to insert an element in a sorted l-D array at proper place, so that the array remains
sorted after insertion also.
Suppose we have an array of size 10 and there are nine elem<;:nts in it which are in ascending order,
one rightmost space is empty for the new element to be inserted.
'---2----1-_4 ----L-._6---L_9--L.._1_2--11_1_5_1
16
°
123
456
I 19 1_2_°-L-I_
7
8
9
•
To insert an item, we'll compare it with the elements of array from the right side and keep on shifting
them to the right. As soon as we get an element less than the item we'll stop this process and insert
the item. Suppose we have to insert the number 13 in the array-
After insertion the array becomes-

for(i=O;i<SIZE;i++)
printf("%d
",arr[i]);
printf("\n") ;
int
arr [SIZE] ;
int
i, item;
printf ("Enter
elements
of
the
array (in
sorted
order)
for (i=O; i<SIZE-1; i++)
/ *rightmost
space
in
array
should
scanf("%d",&arr[i]);
printf ("Enter
the
item
to
be
inserted
") ;
scanf("%d",&item) ;
for(i=SIZE-2;item<arr[i]&&i>=0;i- -)
a'rr[i+l]=arr[i];
I*Shift
elements
to
the
right*/
/*Insert
item
at
the
proper
place*/
\n" ) ;
be
empty* I
C in Depth
i tern
in
a
sorted
array
at
the
proper
place
to
the
right * I
insert
an
elements
arr[i+1]=item;
/*P7.21
Program
to
by
shifting
other
#include<stdio.h>
#define
SIZE
10
main ( )
{
184
The condition i>=O in the loop is there because if the item is to be inserted at Oth place, then value of
i will become -1, but·a[-1] is not a valid element.
Problem 6
Write a program to sort the elements of a I-D array, in ascending order through insertion sort.
To sort an array through insertion sorting we'll use the insertion procedure described in the previous
program. Here we will place each element of array at proper place in the previously sorted element
...
list.
Let us take there are N elements in the array arr. Then process of inserting each element il1 proper
place is as-
Pass 1:
arr[l] is inserted before or after arr[O].
So arr[O] and arr[ 1] are sorted.
Pass 2:
.arr[2] is inserted before arr[O], in between arr[O] and arr[l] or after arr[l].
So arr[O], arr[ 1] and arr[2] are sorted.
Pass 3:
arr[3] is inserted into its proper place in array arr[O], arr[l], arr[2]
So arr[O], arr[l], arr[2], arr[3] are sorted.

Arrays
185
Pass N-l:
arr[N-l] is inserted into its proper place in array
arr[O], arr[l],
arr[N-2]
So arr[O], arr[I]
arr[N-l] are sorted.
Let us take a list. of elements in unsorted order and sort them by applying insertion sort.
90
30
10
40
50
20
100
70
80
60
k=l,
Insert item = arr[l] = 30
in
90
k=2,
Insert item = arr[2] = lOin
30
90
k=3,
Insert item = arr[3] = 40
in
10
30
90
k=4,
Ins~rtitem=arr[4]=50
in
10
30
40
90
k=5,
Insert item = arr[5] = 20
in
10
·30
40
50
90
k=6,
Insert item = arr[6] = 100
in
10
20
30
40
50
90
k=7,
Insert item = arr[7] = 70
in
10
20
30
40
50
90
100
k=8,
Insert item = arr[8] = 80
in
10
20
30
40
50
70
90
100
k=9,
Insert item = arr[9] = 60
in
10
20
30
40
50
70
80
90
100
/ *P7. 22
Program
to
sort
numbers
using
insertion
sort * /
#include
<stdio. h>
#define
SIZE
10
main()
int arr[SIZE);
int
i, k, item;
printf ("Enter
elements
of
the
array
: \n") ;
for(i=O;i<SIZE;i++)
scanf("%d",&arr[i));
for(k=l;k<SIZE;k++)
{
item=arr[k);
/*item
is
to
be
inserted
at
proper
place*/
for(i=k-l;item<arr[i)&&i>=O;i- -)
arr[i+1)=arr[i) ;
arr[i+l)=item;
}
printf ("Sorted
array
is
: \n") ;
for(i=O;i<SIZE;i++)
printf("%d
",arr[i));
printf (" \n") ;
Problem 7
Write a program for merging two sorted arrays into a third sorted array
If there are two sorted arrays, then process of combining these sorted .arraysinto another in sorted
order is called merging. Let us take two arrays arr1 and arr2 in sorted order, we'll combine them into
a third sorted array arr3.
'
arr1-
5
8
9
28
34

C in Depth
42
k=6
1,4 .(5 I, 81, 912:212:5 ~8 GOJ,
40
33
. 30
25
22
4
arr2-
i=O~
i=O~
i=l~
i=2~
i=3~
We'll take one element from each array, compare them and then take the smaller one in third array.
This process will continue until the elements of one array are finished. Then take the remaining elements
of unfinished array in third array. The whole process for merging is shown below. arr3 is the merged
array, i, j, k are variables used for subscripts of arrI, arr2, arr3 respectively.
Initially i = 0, j = 0, k = °
186
Now take 40, 42 in arr3 because arri has no more elements to compare.
So finally the array arr3 is-
arr3-
/*P7.23
Program
for
merging
two
sorted arrays
into
a
third
sorted
array* /
#include<stdio.h>
#define
SIZEl
5
#define
SIZE2
7
#define
SIZE3SIZE1+SIZE2
main ( )
{
int
arrl[SIZE1),arr2[SIZE2),arr3[SIZE3)i
int
i,j,ki

Arrays
printf ("Enter
elements
of
the
array
arrl
(in
sorted
order)
for(~=O;i<SIZE1;i++)
scanf("%d H ,&arrl[iJ);
1
\n
H
)
;
printf ("Enter
elements
of
the
array
arr2
(in
sorted
order)
: \n
H
)
;
for(i=O;i<SIZE2;i++)
scanf("%d~,&arr2[iJ);
i=O,j=O,k=O;
while«i<SIZE1)&&(j<SIZE2))
{
if(arrl[lJ<arr2[jJ)
arr3[k++J=arrl[i++J;
else
arr3[k++J=arr2[j++J;
}
while(i<SIZE1)
/*Put . remaining
elements
of
arrl
into
arr3*/
arr3[k++J=arrl[i++J;
while(j<SIZE2)
/*Put· remaining
elements
of
arr2
into
arr3*/
arr3[~++J=arr2[j++J;
printf ("Merged
array
arr3
is
for(i=O;i<SIZE3;i++)
printf("%d
",arr3[iJ);
printf("\n
H
)
;
}/*Enct_.of
main() */
Problem 8
\n
H
)
;
Write a program to print the Pascal triangle using a 2-D array. In program P6.30, we had printed this
triangle using functions.
.
We'll calculate and store all the elements of Pascal triangle in a 2-D array. Form the figure we can
observe that-
(i)
All the elements of Column °are 1.
(ii)
All the elements for which Rowand Column are same, are 1.
(iii)
Any other element can be obtained by adding two elements of previous row as-
a[i][j] = a[i-1][j-1]+a[i-1][j];
where i and j represent row and column number.
/*P7.24
Program
to
print
the
Pascal
triangle*/
#include<stdio.h>

•
188
c
#define
MAX
15
main ( )
{
inta [MAX] [MAX] ;
int
i,j,n;
printf ("Enter
n
:");
scanf ("%d" ,&n) ;
for(i=O;i<=n;i++)
for(j=O;j<=i;j++)
if(j ==0 II i==j)
ali] [j]='l;
else
ali] [j]=a[i-1] [j-1]+a[i-1] [j];
}
for(i=O;i<n;i++)
for(j=O;j<=i;j++)
printf("%5d",
a[i][j]);
printf("\n") ;
Problem 9
C in Depth
Write a program to print the magic matrix.
(i)
Magic matrix is a square matrix of order n x n, i.e. number of rows is equal to number of columns.
(ii)
A magic matrix exists only for odd values of n.
(iii)
The numbers in matrix will be I, 2, 3, 4
n2 and each number can occur in the matrix only
once.
(iv) The sums of elements of every row, column, and diagonal are equal. This sum is always equal
to n(n2+1)/2.
The magic matrices for n = 3, n = 5, n = 7 are shown below-
2
9
4'
7
5
3
6
1
8
n=3
Sum = 15
9
2
25
18
11
3
21
19 12 10
22 20
13
6
4
16 14
7
5
23
15
8
1
24 17
n=5
Sum = 65
20
11
2
49 40 31 22
12
3
43 41
32 23 21
4
44 42
~3 24
15
13
45 36 34 25
16 14
5
37 35 26 17
8
6
46
29 27 18
9
7
47 38
28 19 10
1
48 39 30
n=7
Sum=175
The procedure for creating a magic matrix is as-

Arrays
189
Start filling numbers from the centre column of bottom row, so initially place the number 1 in the centre
column of bottom row. Keep on placing the numbers by moving one TOW down and one column left
(down-left) till you reach one of the following situations-
(i)
If you reach at the bottom left of the matrix, or a square that is already filled then mo~e one row
up in the same column. This situation will arise when previously placed number was divisible by
n.
(ii)
If you have to move left of the leftmost column, then go to the rightmost column.
(iii)
If you have to move down the bottom row, then go to the topmost row.
/ *P7 . 25' Program
to
print
the
magic
matrix* /
#include<stdio.h>
#def ineMAX
2 O·
main( )
{
int
a [MAX] [MAX] . i. j • n, num;
printf("Enter
value
of
n(odd
value)
");
scanf ("%d" ,&n) ;
i=n-l;
/*Bottom
row*!
j=(n-l)!2;
!*Centre
column*!
for(num=l;num<=n*n;num++)
a [ i] [j ] =n urn;
i++;
!*move
j - -;
! *move
if (num%n==O)
{
i-=2;
j++;
}
if (i==n)
i=O;
if (j==-l)
j =n-l;
}! *End
or
for*!
for(i=O;i<n;i++)
down*!
left*!
/*one . above
the
previous
row*!
! *back
to
the
previous
column*!
/ *go
to
topmost
row* I
! *go
to
rightmost
column* /
for (j =0; j <n; j + + )
printf("%4d",a[i] [j]);
printf("\n") ;
Problem 10
Write a program to print Spiral Matrix.
A spiral matrix is n x n square matrix formed by placing the numbers 1, 2, 3,4
n2 in spiral form
starting form the leftmost column and topmost row. Spiral matrices can exist for both even and odd
values of n. The spiral matrices for n = 3, n = 4, n = 7 are shown below-

/*P7.26
Program
to
print
the
spiral
matrix*/
#include<stdio.h>
#define
MAX
20
main ( )
{
int
n,i=O,j=O,l,u,num=l,arr[MAX] [MAX]={O};
printf ("Enter
value \ of
n
") ;
scanf("%d",&n) ;
l=O;u=n-l;
for (num=l;num<=n*n;num++)
arr [ i] [j ] =num;
if(i==l&&j<u)
j++;
else
if(j==u&&i<u)
i++;
else
if (i==u&&j>l)
j - -;
else
if (j ==l&&i>l)
i"- -;
C in Depth
n=7
1
2
3
4
5
6
7
24 25 26 27 28 29
8
23 40 41 42 43 30
9
22 39 48 49 44 31 10
21 38 47 46 45 32
11
20 37 36 35 34 33 12
19 18 17 16 15 14 13
n=4
/*If
square
already
filled*/
1 2
3
4
12 13 14
5
11 16 15
6
10
9
8
7
n=3
1
2
3
8
9
4
7
6
5
u- -;
i++;
j++;
1++;
if(arr[i] [j] !=O)
{
190
}
} / *End
of
for* /
for(i=O;i<n;i++)
{
for(j=O;j<n;j++)
printf("%4d",arr[i] [j]);
printf("\n");
L_

Arrays
Exercise
Assume that stdio.h is included in all the programs.
(1) main( )
(
int
i,size=5,arr[size];
for(i=O;i<size;i++)
scanf("%d",&arr[i]) ;
for(i=O;i<size;i++)
printf("%d
",arr[i]);
(2) main(
(
int
arr[4]={2,4,8,16},i=4,j;
while(i)
{
j=arr[i]+i;
i- -;
}
printf ("j=%d\n", j);
(3) main (
int
i=O,sum=O,arr[6]={4,2,6,O,5,lO};
while(arr[i] )
{
sum=sum+arr[i] ;
i++;
191
}
printf("sum
(4) main(
{
%d\n" , sum) ;
int
i, arr [8] = {l, 2,3,4,5,6,7.8} ;
for (i=7; i>=O.; i- -)
printf ("%d\t". - -arr [- -i]);
(5) main (
{
int
arr[5]={5,lO,15,20,25};
func (arr) ;
}
func (int
arr [
])
(
int
i=S, sum=O;
while(i>2)
sum=sum+arr [- -i] ;

in t
x [ 10] , y [3] [4] , z [2] [3] [5] ;
printf("%u
\t
%u
\t
%u\n",sizeof(x),sizeof(y),sizeof(z»;
C in Depth
%d\n", arrl [0], arrl [4]);
%d\n", arr2 [0], arr2 [4]);
%d\n" ,a, b) ;
arrl[4]
arr2[4]
%d,
%d,
%d\n,
"sum);
int
a=4,b=6;
int
arrl[5]={l,2,3,4,5};
int
arr2[5]={6,7,8,9,10};
swapvar(a,b) ;
swaparr(~rrl,arr2) ;
printf ("a
=
%d-,
b
printf ("arrl [0]
printf("arr2[0]
(7) maine
printf("sum
(6) main (
{
192
•
}
swapvar(int
a,int
b)
{
int
temp;
temp=a,a=b,b=temp;
}
swaparr (int
arrl [5] ,int
arr2 [5] )
{
int
i,temp;
for(i=0;i<5;i++)
{
temp=arrl [i] , arrl [i] =arr2 [i],
arr2 [i] =temp;
(8) maine
{
int
i,j,arr[3] [4]={{l,2,3,4}, {5,6,7,8}, {9,10,1l,12}};
for(i=0;i<4;i++)
I
{
for(j=O;j<3;j++)
pr in t f ( "% 3 d" , arr [j ] [i] ) ;
printf ("\n");
(9) #include<math.h>
maine )
{
int
i,j,arr[200];
for(i=2;i<200;i++)
arr[i]=l;
for(i=2;i<=sqrt(200) ;i++)
for(j=i*2;j<200;j+=i)

Arrays
arr[j]=O;
for(i=2;i<200;i++)
if(arr[i]==l)
printf("%d\t",i);
(10)main(
. {
int
a[10] ={2, -3, 4, -5, 6, 7,1,9, -10, -ll};
int
i,j,x,k=O;
for(i=0;i<10;i++)
{
x=a[k] ;
if (x<O)
{
for(j=k;j<10;j++)
a[j]=a[j+1];
a[9]=x;
else
k++;
}
for(i=0;i<10;i++J
printf("%d
",a[i]);
printf ("\n");
1~
Programming Exercise
1.
Write a program to accept n numbers and display the sum of the highest and lowest numbers.
2.
Write a program to accept n numbers in array and display the addition of all even numbers and
.multiplication of all odd numbers.
. "-
3.
Write a program to sort numbers of a one-d array in descending order using
(i) selection sort (ii) bubble sort (iii) insertion sort
4.
Write a function to reverse only first n elements of an array.
5.
Write a _program to modify the elements of an array such that the last element becomes the first
element of the array and all other elements are shifted to right.
123456789
-7
9 1 2 3 4 5 678
We can say that we have rotated the array to the right by one element. Now modify tile'above
program so that we can rotate the array by any number of elements. For example when we rotate
the array by 3 elements the result would be-
l 2 3 4 5 6 7 8 9
-7
78 9 1 2 3 4 5 6
6.
Write a program to find out the determinant of a matrix.
7.
Write a program to count the occurrences of a number in a matrix.
8.
Write a program to store all the elements of a 2-D array in a 1-D array row-wise.
9.
Write a program to find out whether a matrix is symmetric or not. A matrix is symmetric if transpose
of the matrix is equal to the matrix.

17.
Write a program to sort the elements of a matrix (i) row-wise (ii) column-wise
10.
Write a program to check that the elements of an array are distinct.
11.
Write a program to check that the elements of a matrix are distinct.
12.
Write a program to find out the sum of elements of principal and secondary diagonals of a squill
matrix.
13.
Write a program to enter a square matrix of odd size and then check whether it is a magic matri
or not. Any matrix is a magic matrix if all the elements in it are distinct and the sum of elemerr
in each row, column and diagonal are equal.
14.
Write a program to print the elements of a matrix spirally. For example if the matrix is-
258
1 37
629
The output should be-
2 5 8 7.9 2 6 1 3 .
Answers
(1)
Error, the size of an aray should be a constant expression.
(2)
j = 5
(3)
sum
= 12
(4)
6
4
2
0
(5)
sum = 60
(6)
20
24
60
(7)
a = 4, b = 6
arrl[O] = 6, arrl[4] = 10
'\ € in DeptJ
132 1
3 624
575 7
8 898
(ii)
582 1
3 6 9 4--.
172 8
8 3 5 7
Matrix
125 8
3 469
127 8
3 578
(i)
582 1
3 694
172 8
8 3 5 7
Matrix
15.
Write a program to reverse the rows of a matrix.
1
2
3
4
13 14
15 16
5
6
7
8
--.
9
10
11
12
9
10
11
12
5
6
7
8
13 14
15 16
1
2
3
4
16.
Write a program to reverse the columns of a matrix
1
2
. 3
4
4
3
2
1
5
6
7
8
8
7
6
5
9
10
11
12
--.
12
11
10
9
13 14
15 16
16
15 14 13
194

Arrays
~
r95
arr2[0]
= 1, arr2[4] = 5
Any changes made to the array inside the function are visible in the calling function.
(8)
1
5
9
2 6
10
3
7
11
4
8
12
Here the rows are printed vertically and thc columns are printed horizontally.
(9)
Prints all the prime numbers less than 200. This method of finding out prime numbers is known
as Sieve of Eratosthenes.
.
(10) 246 7 1 9 -3 -5 -10 -11
This program suppre3ses the negative numbers at the end of the array.

Chapter 8
Pointers·
C is a very powerful language and the real power of C lies in pointers. The concept of pointers is interesting
as well as challenging. It is very simple to use pointers provided the basics are understood thoroughly.
So it is necessary to visualize every aspect of pointers instead of just having a superficial knowledge
about their syntax and usage. The use of pointers makes the code more efficient and compact. Some
of the uses of pointers are-
-
(i)
Accessing array
element~.
(ii)
Returning more than one value from a function.
(iii)
Accessing dynamically allocated memory.
(iv)
I~plementing data structures like linked lists, trees, and graphs.
8.1
About Memory
...
Before studying pointers it is important to understand how memory is organized in a computer. The
memory in a computer is made up of bytes arranged in a sequential manner. Each byte has an index
number, which is called the address of that byte. The address of these bytes start from zero and- the
address oflast byte is one less than the size of memory. Suppose we have 64 MB of RAM, then mem:'ory
will consist of 64 * 220 = 67108864 bytes. The address of these bytes will be fr.om 0 to 67108863.
.
..
1 "".
0,
1 2
3 4
5
67108863
We have studied that it is necessary to declare a variable before using it, since compiler has to reserve
space for it. The data type of the variable als9 has to be mentioried so that the compiler knows how
much space needs to be reserved. Now let us see what happens when we declare a variable. Suppose
we declare a variable age of type int- .
int
ag~;.
The compiler reserves 2 consecutive bytes from memory for this variable and associates the name age
~ith
i~. The address of first
byt~ from the two allocated bytes is known as the address
o~ variable
age.

Pointers
197
Suppose compiler has reserved bytes numbered 2588 and 2599 for the storage of variable age, then
the address of variable age will be 2583. Let us assign some value to this variable-
,
. '
. '
1-
age = 20;
,
Now this value wj11 be stored in these 2 bytes (of course in binary form). The number of bytes allocated
will depend on the data type of variable. For' example 4 byte.§ would:_have beeJLaJJo_c<lt~d foCa'flo&.
variable and the Cl.ddress_of first byte would be called the add~ess of the variable. Now we wilhee
how to find out the addres's of a variable.
.
,
8.2
Address Operator
C provides an address operator
'~', which returns.the address ,of a variable when placed before it.
.
I
•
•
'
..
_
,
This operator can be read as "the address of ", so &age means address of age, similarly &sal means"
address of sal. The following program print~ the address of variables using address operator.
/*P8.1
Program
to
print
address
of
variables
using
address
operator*/
#include<stdio.h>
main( )
{
int
age=30;
float
sal=1500. 50;
printf ("Value
of
age
printf ("Value
of' sal
%d,
Address
of
age,=
%u\n",age,&age);
%f,
Address
of
sal,=
%u\n",sal,&sal);
}
Output:
Value of age = 30, Address of age = 65524
Value of sal = 1500.500000, Address of sal = 65520
Here we have used %u control sequence to print the address, but this does not mean that addresses.
are unsigned integers: We have used.it since there is no specific control sequence to display address~.
Addresses are just whole numbers. These addresses may be.different each time you nm your program,
it depends on which part of memory is allocated by operating system for this program.
The address operator cannot be used with a, constant or an expression.
&j;
/*Valid, used with a variable*/
&arr[ 1];
/*Valid, used with an array element */
&289;
/*Invalid, used with a constant*/
&(j+k);
/*Invalid, used with an expression*/
This address operator is not new. for
us,~ we have already used it in scanf( ) function. The address
of variable
~s provided to scanf( ), so that it kno,:"s where to write the input value. So now you can
understand why '&.' was, placed be~ore the variable names in scanf( )"
8.3
Pointers Variables:
Finally after this brief introduction, it is time to introduce pointers.A p-ointer is a_variable that store~ .
memory addr.ess. Like all other variables it also has a name, has to be declared and oGcupies sQme
spacei~emory. It is called pointer beca~seit points to a particular location in ~emory by storing
the address of that location.

Like other variables, pointer variables should also be declared before being used.. The general syntax
of declaration is-
data_type *pnamei
Here pname is the name of pointer vari<\ble, which should be a valid C identifier. The aster~sk '*' preceding
this name informs the compiler that the variable is declared as a pointer. Here data type is known as
the base type of pointer. Let us take some pointer declarations-.'
-
int *iptr;
float *fptr;
char *cptr, chI, ch2;
Here iptr is a pointer th,at should point to variables of type int, similarly fptf and cptr should point to
variables of float and char type respectively. Here type of variable iptr is 'pointer to inC or (int *), or
we can say that base type o( jptr is iQJ. We can also combine the declaration of simple variables. and
pointer variables as we have done in the third declaration statement where chI and ch2 are declared
as variables of type char.
Pointers are also variables so compiler will reserve space for them and they will also have some address.
All pointers irrespective o'f their base type will occupy sa~e sp~ce in memory since all of them cont~in
addresses o~ly. Generally 2 bytes ar~ used to store an address (may vary in different computers), so
the compiler allocates 2 bytes for a pointer variable.
Now the question arises that when all the pointers contain addresses only and each oile occupies 2
bytes, then why we have to mention the data type in the declaration statement. We will come to know
about this when we study.about indirection operator and pointer arithmetic.
8.3.2
,Assigning Address To Pointer Variables
/
C in Depth
Declaration Of Pointer Variables
8.3.1
198
•
When we declare a pointer variable it contains garbage value i.e, it may be pointing anywhere in the
memory. So we shOl;lld l\lways assign an address before using it in the program. The use of an unassigned
pointer may give unpredictable results and even cause the prograill to crash. Pointers may be assigned
the addres~ of a variable' using assignment statement. For example-
.
int~ptr, age = 30;
,
~r \.'"", /!
._.'''Or<!Jc.._
float *f1ptr, sal = 1500.50;
/.....,...
'))1\
,/ )
-
-
\......)
.
{ C (1 '-.\-0
iptr = &age;
.
fa
'-"-,)
------
l
J ,j
.•
[ptr = &~al;,
!('1-
::
J '2 .) It
..
('
Now iptr contains the address of variable flge i.e. it point,S to variable age, similarly fptr points to variable
sal. Since iptr is declared as a pointer ~f type, int, we'sholild assign address of only integer variables
to it. If we assign .address of some other data type then compiler won't show any error ,but the output
will be incorrect.

Pointers
5000
500J
( ~5~ \ 55~";
r 5524 ~I------'.I·'.<0'30 .
I
iptr~age
~50Q
4501
~
5521
5522
5523,
L ?5201L I
-C_...;,.15_0_0_.5_0
1
fPtr
sal
We can also initialize the pointer at the time of declaration. But in this case the variable should be declared
before the pointer. For example-
int age = 30, *iptr = &age;
float sal = 1500.50, *fptr = &sal;
It is also possible to assign the value of o~~iableto t~e
othe~, provided their base type is
same. For example if we have an integer pointer pI then we can' assign the value of iptr to it as-
.
e---
I
r
.
,
pI = iptr;
Now both pointer variables iptr and pI contain the address of variable age and point to the same variable
.~
.
-
.
,
.
.
.
~-
We can assign constant zero to a pointer of any type. A symbolic constant NULL is defined in stdio.h,
which denotes the value z~ro. The as'signment ofNULL to a pointer' guar~nteds that it does not point
to any valid Iuerriory location. This can be done as-
ptr = NULL;
8.3.3
Dereferencing Pointer Variables
Till now we have done a lot of programming and in all our programs we have used the name of a
vanab'le foraccessingji. We can also access a variable indirectly using pointeJ.s. For this w~
\~ill use
the indirection operatQr( * ). By placing the indirection operator before a pointer variable, we can access
tile-'.'.aria]Jle whose address IS stored in the p~inter. Let us take an eXaI~ple-
.
int a = 87
float b",= 4.5;
int
pI = &a;
float *p2 = &b;
In our program, if we place'*? before pI then we can access t1).e variab!e whose address is stored
in p1. Since pI contains the address of variable a, we can access the variable a by writing *p1. Similarly
we can access variable
~ by writing *p2.. So we can use *p.l and *p2 in place of variable names a

/ *PB .2
Program
to
dereference
pointer
variables * /
#include<stdio.h>
main( )
{
a = 9;
a++;
x = b + 10;_
print("%d %f', a, b );
scanf("%d%f ", &a, &b );
C in Depth
%u\n",pl);
%u\n",p2),
of
a
of
b
is equivalent to
is equivalent to
is equivalent to
is equivalent to
is equivalent to
Address
Address
int
a=B
float
b=4.5,
int
*pl=&a,
float
'!'p2=&p,
printf ("Value
of
pl
=
printf ("VeHue
of
p2
=
printf ("Adc:rress
of
pl
%u \n" ,&pl) ;
printf ("Address
of
p2
%u \n", &P2) ,
p r i n t f ( "Val u e
0 f
a
-,
%d
%d
%d
\ n" , a, *p 1 , * (&a) ) ;
printf ("Value
of
b
%f
%f
%f
\n", b, *p2, * (&b.) ) ;
_*p 1_= 9;
(*pl)++;
x = *p2 + 10
printf("%d %f', *pl, *p2 );
scanf("%d%f', pI, p2 );
,
-'
and b anywhere in our program. Let us see some examples-
200
The indirection operator can be read as 'value at the address'. For example *pl can be read as 'value
,at the address pI'. This indirection operator (*) is different from the asterisk that was used while declaring
the pointer variable.
Now we will see what is meant by the term *(&age), where age is a variable. Since &age is an address,
so dereferencing it with *. operator will gi'{e.the variable at that address and the variable at that address
is age. Hence *(&age) is same as writing age.
}
Output:
Value of pI = Address of a = 65524 "-
Value of p2 = Address of b = 65520
Address of pI
= 65518.
Address of p2 = 65516
Value of a = 87 87 87
Value of b = 4.500000 4.500000 4.500000
We have already seen that while declaring a pointer variable, we have to mention the data type. The
reason is that when we use the indirection operator, the number of bytes retrieved will be different for
different data types. The value of the pointer only tells the address of starting byte. For example suppose'
we have a pointer ptr which contains the address 2000 and when we write. *ptr. the compiler k~ows
that it has to access the information starting at address 2000. "So the compiler will look at the base
type of the pointer and will retrieve the information depending on that base type. ,For example i~ base
type is int then 2 bytes information will be retrieved and if base type is float, 4 bytes information will
be retrieved and so on. The following figures illustrate this fact. The shaded portion shows the num1;ler
of bytes retrieved.
.
-

4500
4501
4502
4503
4504
4505
--------
----1~~~~
__
Pointers -
char *pI;
int *p2;
"
float *p3;
1200
1201
2622
2633
2644
2655
2666
2667
I 2662
II----.~~,----
pI
1992
1993
6050
6051
6052
6053
6054
6055
16050
II----.~~--
p2
2560
2561
I
4500
p3
201
)
double *p4;
p4-
The size of pointer variable is same fo~ all type of pointers but the memory that will be accessed v.:hile
dereferencing is different.
/*P8.3
Program
to
print
the
size. of
pointe~ variable
and
size
of
value
dereferenced
by
that
pointer* /
#include<stdio.h>
main (
)
(
char
a= 'x' , *pl-=&a;
int
b=12, *p2=&b;
float
c=12.4,*p3=&c;
double
d=18.3,*p4=&d;
printfl"sizeoflpl)
%d
printf("sizeof(p2)
%d
printfl"sizeoflp3)
%d
printf ("sizeof Ip4)
%d
}
Output:
sizeof(p 1') = 2 , sizeof(*p1) = 1
~'--:::",,:;::,.-'
~
~-
sizeof(p2) = 2 , sizeof(*.£7) = ~
sizeof(p3) = 2 , sizeof(*.Q...3) =-1..
sizeof(p4) = '2 , sizeof(*p4) =!-
8.4
Pointer Arithmetic
sizeof(*pl)=
sizeof(*p2)
sizeof l*p3)
sizeofl*p4)
%d\nU,sizeof(pl),sizeof(*pl));
%d\n U,sizeof(p2) ,sizeof(*p2));
%d\n U,sizeof(p3),sizeof(*p3) );
%d\nU,sizeof(p4),sizeof(*p4));
All types of arithmetic operations are not possible with pointers. The only valid operations that can be
performed are as-
•
(I)
Addit~on of an integer to a pointer and increment operation. _
(2)
Subtraction of an integer from a pointer and decrement operation
\(3)
Subtraction of a pOInter from another pointer of same type.)
Pointer arithmetic is somewhat different from ordinary arithmetic. Here all arithmetic is performed relative

202
C in DJth
to the size of base type of pointer. For example if we have an integer pointer pi which contains address
1000 then on incrementing we get 1002 instead of 100I. This' is because the size of int data type is
2. Similarly on decrementing pi, we wi!! get 998 instead of 999. The expression ( pi+3 ) will represent
the address 1006. Let us see some p9'1nter arithmetic for int, float and char pointers.
int ~ = 5, *p) = &a'
r
float b = 2.2, *e.t = &b;
char c = 'x', *pc= &c;
Suppose the address of variables a, ? and care !.QQ9, 49.QV, ~ respectively, so initially values of
pI, p2, p3 will be 1000, 4000 and 5000.
-..
r:""t"t;
or
++pi;
pi =.!.Q9Q + J:. = 1002 (Since iut is of 2 bytes)
pi = pi-3; ./
pi =1002 - 3*2 = 996
.
~
pi = pi+5; .
pi =996 + 5*2 = 1006
pi--;
or
--pi;
pi =1006 - 2 = 1004
pf = 4000 + 4 = 4004 (Since float is of 4 bytes)
pf = 4004 - 3*4 = 3992
pf = 3992 + 5*4 = 4012
pf = 4012 - 4 = 4008
pc = 5000 + 1= 5001 (Since char is of 1 byte)
pc = 5001 - 3 = 4998
pc = 4998 + 5 = 5003
pc = 5003 - 1 = 5002
The complier scales all this arithmetic automatically since it knows the base type of pointer. The arithmetic
in the case of char pointer seems to be like ordinary arithmetic because the size of a char is
1,., byte.
The addresses of variables a, band c are not affected by these operations, only the pointer moves ahead
or backwards.
Suppose pi is an integer pointer that contains address 1000 initially.
p~++;
or .
++pf;
pf = pf-3;
•
pf = pf+~;
pf-, -;
or
- -pf;
pc++;
or
++pc;
pc = pc-3;
pc = pc+5;
pc- -;
or
- -pc;
pI
1 00
1001
1002 1003
1004
1005
1006
1007
,CD...::.·....:·.·::1:.··:::.·:.::····~·
(a)
pi++;
After incrementing, pointer pi points to address 1002 and if derefrenced(*pi), then it will return
the information stored at bytes 1002 and 1003.
.
5000
5001
1000
1001
1002
1003
1004
1005
1006
1007
pI
....................,
'--_....r.-_-'-_---'-__'--_-'-_--'
(b) pi = pi+2:
Now pi contains address 1006, and if dereferenced it will return information stored at bytes 1006
and 1007.

Pointers
pI
1000
1001
1002
1003
1004
1005
1006
1007
,
"
"'o=II]
\
.1
I..
..l
.
203
)
(c)
pi = pi-3;
Now pi contains addre'ss 1000, and if dereferenced it will return information stored at bytes 1000
and 1001.
pI
5000
5001
1000
1001
1002
1003
1004
1005
1006
1007
o=r:..::::..:...:.:.j:.::..::..:....:.o=II]
(d)
printf("%d", *(pi+2) );
Here the pointer will not move to address 1004 since we have not assigned any new value to it.
The Integer stored at bytes 1004 and 1005 will be printed.
pi
5000
5001
1000
1001
1002
1003
1004
1005
1006
1007
o=r::::.::::::.::J:::..:.:::....::C2LJCD
\
It is important to note that when we move a pointer somewhere else in memory by incrementing/
decrementing or adding/subtracting integers then it not necessary that the pointer still points to a variable
of same data type or a valid memory location. The task of allocating memory locations to variables
is done by the compiler. We don't know where and in what order it has stored them. We should take
care that we move the pointers in such a way that they always point to valid memory locations. In
case of arrays, elements are stored in consecutive order. So this arithmetic is generally applied in arrays.
/ *P8 .4
Program
to
show
pointer
arithmetic * /
#include<stdio.h>
main(
Address
of
a
Address
of
b
Address
of
c
int
a=5, *pi=&a; ,
char
b='x',*pc=&b;
float
c=5. 5, *pf=&c;
printf ("Value
of
pi
printf("Value
of
pc,
printf ("Value
Of
pf
pi++;
pc++;
pf++;
printf (",Now
valu.e
of
pi
print.f ("Now
value
of
pc
printf ("Now
value
of
pf
}
Output:
Value of pi = Address of a = 1000
%u\n" ,pi);
%u\n",pc)\;
%u\n" ,POI;
%u\n",pi);
%u\n",pc);
%u\n",pf);
..".

204
Value of pc =Addtess of b = 400£---
Value of pf = Address of c = 8000
Now value of pi = 1002.....--,
Now value of pc = 4001 ~
No,,:, value of pf = 8004 ~
C in)Depth
/ *P8. 5
Program
to
understand
the
postfix/prefix
increment/decrement· in
a
pointer
variable
of
base
type
int
* /
#include<stdio.h>
main(
,int
a=5;
int
*p;
p=&a;
printf ("Value
of
p
=
printf ("Value
of
P. =
printf ("Value
of
p
printf ("Value
of
p
printf ("Value
of
p
printf ("Value
of
p
Address
of
a
%u\n",++p);
~
%u\n",p++);
~
%u\n",--p);
%u\n" -p-'-').
%u\n":p);"'
'
"..
%u\n",p);
Output:
Value of p = Address of a = 1000
Value of p = 1002
Value of p = 1002
Value of p = 1002
Value of p = 1002
Value of p = 1000
"
In first printf the address of a = 1000 is printed. In second printf, first the pointer is incremented then
its value is printed. Since base type of pointer is int, hence it is incremented by 2. Similarly other printf
statements are executed.
Subtraction of a pointer from another pointer of same base type returns an integer, which denotes the
number of elements between two pointers. If we haye two int pointers ptrl and ptr2, containing addresses
3000 and 3010 respectively then ptr2 - ptrl will give 5. (since size of int is 2). This operation is generally
performed when both pointer variables point to the elements of same array.
The arithmetic operations that can never be performed on pointers are-
I.
Addition, multiplication, division of two pointers.
2.
Multiplication between pointer and any number.
3.
Division of a pointer by any number.
4.
Addition of float or double values to pointers.
8.5
Precedence Of Dereferencing Operator And /Increment/
Decrement Operators
~~~enc.Ll~vel.of* .QP~~and increment/decrement operators, is same and their associativity
is from right to left. There can be confusion while combining these oPFators in pointer expressions,

Pointers
so we should use them carefully.
Suppose ptr is an integer pointer and x in an integer variable. Now we'll see how the pointer expressions
"
-
-----
given below are interpreted.
x =; *ptr++;
x ~ ":-J::-ptr;
x .~ .++*ptr;
x = (*ptr)++;
(i)
x ='*ptr++;
The expression *ptr++ is equivalent to *(ptr;+::!:), since these operators associate from right to left.
Hence the increment operator will be applied to ptr, and not to *ptr. The increment bperator is
postfix, so first the value of ptr will be used in the expression allcLthen it will be incremented.
H'ence firstly the integer pointed toby ptr will be dereferer{ced and ~sSlgneci to x and then ptr'
~i1l be incrementtrd. This is salmi as-
.
x = *ptr;
ptr = ptr+1;
.
,
(ii)
x = *++ptr;
The expression *++ptr is equivalent to *(++ptr). Here also the increment operator is applied to
- '
-----
ptr. The increment operator is prefix, so first rtr will be incremented and then its new value will
be <Y.m:? /fi> M>e eJp/C'JJjOh!JJC2?ce »..r31))' lb.e Y1J)))e DJptr js jncremented.... then value at the new
address is dereferenced and assigned to x. 'This is same as-
ptr = ptr+1;
x = *ptr;
(iii)
x = ++*ptd _
'The' e~p;~ssion ++*ptr is equivalent to ++(~). Here the increment operator is applied over *ptr_
and not ptr. So here the value of pointer' wdl not change but the value pointed to by the pofnfer
.vm. ",hanrg'_ ;.f'_. *rp-r. w.ilL incrp.mpnL SjnGf'~ th~ increment oQerator is l1refix hence first the value
of *ptr will increment and then this value will be assigned to x. This is same as-
*ptr = *ptr+1;
x = *ptr;
(iv)
~=:' (~pt!l++\
.Here aiso the increment operator is applied over *ptr and since it is postfix increment hence first
the value of *ptr 'will be assigned to x and then it will be
incr~mented. This is same as-
x = *ptr;
*ptr = *ptr+1;
-
.
Let us take an example and understand how these expressions are interpreted. Suppose value at address
2000 is 25, value at address 2002 is 38, ptr is an integer pointer that contains address 2000 hence "
of *ptr is 25. Now we'll see what will be the results in the above four cases, if this is the iniria con
in all cases~
p~
2000 2002
,......
r

206
(i)
x = *ptr++;
Value of x = 25, Address contained in ptr = 2002, *ptr = 38
(ii)
x = *++ptr,;
Value ofx = 38, Address contained in ptr = 2002, *ptr = 38
(iii)
x = ++*ptr,?
Value of x= 26, Address contained in ptr = 2000, *ptr = 26
:tf--
(iv) x = (*ptr)++; 'J..J-
.
Value of?C = 25, Address contained in ptr = 2000, *ptr = 26
C in Depth
p~
.....
lliTI[]
2000 2002
V~ll(~a38 I
2000 2002
p~
2000 2002
p~
2000 2002
From the above four forms of pointer expressions, first one is generally used since it is used to access
the elements in an array. In the above statements we have taken increment operator, the same rules
stand for decrement operator also.
8.6
Pointer Comparisons
,.
The relational operators = =, != , < , <=, >, >= can be used with pointers. The -operators = = and
-
...-.
!= are used to compare two pointers for finding whether they contain same address or not. They will
be equal only if both are NULL or they contain address of same variable. The use of these oRerators
is valid between pointers or same type or between NULL pointer and any other pointer, or. b~etween
void po.inter and any other pointer. The relational operators <, >; >=, <= are valid between pointers
of same type. These operations make sense only when both the pointers point to elements of the same
'array.
"
8.7
Pointer To Pointer
We know that pointer is a variable that can contain memory address. This pointer variable takes some
space in memory and hence it also has an address. We can store the address of a pointer variable in
some other variable, which is known as a pointer to pointer variable. Similarly we can have a pointer
to pointer to pointer variable and this concept can be extendeo to any limit, but in practice/0nly pointer
to pointer IS used. Pointer to pointer is generally used while passing pointer variabl~s to functions.
The syntax of declaring a pointer to pointer is as-
/'
I
--
data_type **pptr;
Here variable pptr is a pointer to pointer and it can point to a pointer pointing to a ~ariable of type
data_type. The. double asterisk used in the declaration inforins the compiler that a pointer to poinfer
is being declared. Now let us take an example-
int a = 5;·
int *pa = &a;'
int **ppa = &pa;
~
Here type of variable a is int, type of variable pa is (int*) or pointer to int, and type of variable ppa
is (int **) or pointer to pointer .to int.
'(J

Pointers
4000
3000
3000 , If----..I
2090
.pp~
p~
20J),0 ,
f-------I*_,_5------J
a
207
(;S 52.4
,
,
Here pa is a pointer variable, which contains the address of the variable a and ppa is a pointer to pointer
variable, which contains'the address of the pointer variable pa;
,
I
We know that *pa gives value of a, similarly *ppa will give the value of pa. Now let us see what value
will be given by **ppa.
. ,
**p a "1',
'
-7 *(*p~'l))
~
~ :sfri~e *ppa givesp~)..
-7 ~
(Since *pa gives a)
,
'.
\
'
,
Hence we can see that **ppa will give the value of'k So to access the value indirectly pointed to by
a pointer to pointer, we can use double indirection operator. The table given below will make this concept
clear.
Value ofa
a
*pa
**ppa
5
Address ofa
&a
pa
*ppa
2000
Value ofpa
&a
pa
*ppa
2000
Address ofpa
&pa
ppa
3000
Value ofppa
&pa
ppa
3000
Address ofppa
&ppa'
4000
/ *P8. 6
Program
to
understand
pointer
to
pointer* /
#include<stdio.h>
main( )
{
int
a=5;
int
*pa;
-
.
int
**rfE!;;
pa=&a;1
",
~
ppa=&pa; ,
print'f ("Address
of
a
=
%u\n", &a); ~
•
""";-!'
--:-
printfC"Value
of
p'a
=
Addre'ss
of
a
%u\n",pa);G5S2~
printf ("Value., ot
*'pa'
=
Value
of
~
= - %d\n", <pal ;'
~
printf ("Address
of" p~' =
%u \n" ,&pa) ;
printf ("Value
of
ppa
=
Address
of
pa
=
%v.\n" ,ppa);
printf ("Value
of
*ppa
=' Value
of
pa'=
%u\n", *pI?a)';
printf("Value
of
*.*'ppa
Value
of
a
=
%d\n",**ppa);
printf("Address'of
ppa
=
%u\n",&ppa);
}
Output:
Address of a = 65524
Value of pa = Address of a = 65524
Value of~pa = Value of a = ~

208
C in Depth
Address of pa = 65522
Value of ppa = Address of pa = 65522
Value of *ppa = Value of pa = 65524
Value of **ppa = Value of a = 5
Address of ppa = 65520
8.8
Pointers and One Dimensional Arrays
j*P8.7
Program
to
print
the
value
and
addres,s
of
the
elements
of
an
We can get the address of an element of array by applying & operator in front' of subscripted variable
name. Hence &arr[O] gives address O(Oth element, &arr[l] gives the address of first element and so
on. Since array subscripts start from 0, so we'll refer to the first element of array as Oth element and
so on.
The following program shows that the elements of an array are stored in consecutive memory locations.
25
2008
arr[4]
20
2006
arr[3].·
2004
arr[2]
15
arr[l]
10
2002
arr[O]
_ ';'arr[O]
~ I
5
2000
Here 5000 is the address of first element, and since each element (type int) takes 2 bytes so address
of next-element is 5002, and so on. The address of first element of the array is also known as the
_ba~aQdress of the array. So we have seen that the e1eI!lents o{irray are-;tored secluentlally in memory
.one after another.
.
In C language, pointers and arrays are closely related. We can access the array elements using pointer
expressions. Actually the compiler also acces~es l:h~' array elements by converting subscript notation
to pointer notation. Following are the main poInts for understanding the relationship of poinfers with
. arrays.
1.
Elements of an array are stored in consecutive memory locations.
2.
The name of an array is a constant pointer that points to the first element of the array, i.e. it stores
the address of the first element, also known as the base address of array.
'"
3.
According to pointer arithmetic, when a pointer variable is incremented, it points to the next location
of its base type.
.
.
For example-
int arr[5]
=
{ 5 , 10 ,15 , 20, 25 }
Here arr[5] is an array that has 5 elt:1Jlents each of type int.
The elements of an array are stored in contiguous memory locatIOns. Suppose we have an array arr[5]
of type int.
-
'
int <lJfr[5]'~ U,2,~J;:-4,-.:5}.; ._:
('f~ttJ'tcY~
This is stored in memory as-
\--.t'.
.
(5000

Pointers
array
* /
#include<stdio.h>
main ( )
{
int
arr[5J={5,lO,15,20,25};
int
i;
for(i=O;i<5;i++)
printf ("Value
of
arr [%dJ
printf("Address
of
arr[%dJ
%d \ t" , i, arr [ i J ) ;
%u\n"', i,'&arr[ij');
209
}
Output:
Value of arr[O] = 5
Value of arr[l] = 10
Value of arr[2] = 15
Value of arr[3] = 20
Value of arr[4] = 25
Address of arr[O] = 2000
Address of arr[ I] = 2002
Address of arr[2] = 2004
Address of arr[3 j
~ 2006
Address of arr[4] = 2008
The name of the array 'arr' denotes the address of Olh element of array which is 2000. The address
,_
--1·
-'
.
of Olh element can also be given by &arr[O], so arr and &arr[O] represent the same address. The name
of an array is a constant pointer, and according to. pointer arithmetic when an integer is added to a
pointer then we get the address of next element of same base type. Hence (arr+ . will denote the address
of the next element arr[l]. Similarly (arr+2) denotes the address of arr[2] and so on. In other words
we can say that the pointer expreSSiOn (arr
points to 1'1 element of array, (arr+2) points to 2nd element
of array and soon.
~
~
Points to Oth elemeIlt
~
&arr[O]
~
2000
~--,.
arr+1
~
Points to 151 elemem
~
&arr[l]
~
.2002,.....--
arr+2
----7
Points to 2nd element
-~
&arr[2]
~
2004
arr+3
~
Points to 3'd element
~
&arr[3]
~
2006
arr+4
~
Points to 41h element
~
&arr[4]
~
2008..,.-
In general we can write-
The pointer expression Om+i) denotes the same address as &arr[i].
Now if we dereference arr, then we get the Olh element of array, i.e. expression'*arr or *(arr+O) represents
Olh element of array. Similarly on derferencing' (arr+I) we get the 151 element' and so on.
*arr
~
Value of Olh element
~
arr[O]
~
5
*(arr+l)
~
Value of 1'1 element
~
arr[l]
~
10
*(arr+2)
~
Value of 2nd element
~
arr[2]
~
15
*(arr+3)
~
Value of 3'd element
~
arr[3]
~
20
*(arr+4)
~
Value of 41h element
~
arr[4]
4
25
In general we can
write~
*(arr+i)
~
arr[i]
So in subscript notation the address of an array element is &arr[i] and its value is arr[i], while in pointer

210
C in Depth
=
%d\t",i,*.(arr+i));
%u\n", f-;a:r;+i);
..,...
notation the address is (arr+i). and the element is *(arr+i).
/*P8. 8
Program
to 'print
the
value. and
address
of
elements
of
an
array
using
pointer
notation* /
#include<stdio.h>
main ( )
{
int
arr[5]={5,lO,15,20,25};
int
i
for(i=O;i<5;i++)
{
printf ("Value
of
arr lid]
printf("Address
of ,arr[%d]
}
The output of this program is similar to that of P8.7.
Accessing array elements by pointer notation is faster than accessing them by subscript notation, because
the compiler ultimately changes the ~ubscript notation to poin'ter notation and then accesses the array
elements.
Array subscripting is commutative, i.e. arr[i] is same as i[arr].
We had seen earlier that-
~r[i] is equivalent to *(arr + i L'
-
Now r;(~tr+i) is ~ame as *(0":arr)', so we can write. the above statement as-
a~[i] is equivalent to *( i + arr )
Now *(i+arr) can be written as i[arr] in subscript notation, so
'"'--
"0-.<
arr[i] is equivalent to i [arr]
/ *
P~. 9
Program
to
subscript
notation
#include<stdio.h>
main( )
{
print
*/
the. value
of
array
elements
using
pointer
...
and
int
arr[5]={5,lO,15,20,25};
int
i=O.;
for( i=O; i<5; i++)
{
printf ("Value
of
~ [!~] =" , i) ;,
printf("%d\t",arrri~);
,L. .printf ("%d\t", * L~~r+i»);
_printf ("%d\t", * (i+aFr));
--printf ("%d\n", i.[arrJ ) ;
printf ("Address
of
arr lid]
" 0-
%u\n",i,&arr[i]) ;
.
-.
}
Output:
Value of arr[O] = 5/
5
Address of arr[OJ
= 2000
5
5
-0
z

Pointers
211
Value of arr[l] = 10
10
10
10
Address of arr[ 1] = 2002
,
,
Value of arr[2] = 15
15
15
15
Address of arr[2] = 2004
Value of arr[3] = 20
20
20
20
Address of arr[3] = 2006
Value of arr[4] = 25
25
25
25
Address of arr[4] = 2008
8.9
Subscripting Pointer Variables
Suppose we take a pointer variable ptr, and initialize it with the address of the Olh element of the array.
int * tr"l
ptr = arr; I*We could also write ptr = &arr[O] */
,.
~
ptr
arr[O]
arr[l]
arr[2]
arr[3]
arr[4]
Q00.0"t----..j
5
10 I
15
20 I 25
00
'
2000
2002
2004
2006
2008
lllegal*!
illegal*1
illegal*1
ariable, all these operations are valid for- it..
/*
ow ptr points to variable' n~m*/
1* ptr points to next location .*/
I*ptr points to previous location*/,
But since ptr '-
ptr =
~n~
ptr++;
ptr = ptr-
On applying po'
arithmetic and dereferencing we can see that the expression (ptr+i) denotes the
address of ith el
0
array and the expression *(ptr+i) denotes the value of ilh element of array.
According to
e OOlIri'.''a!fmc.e of pointer and subscript notations, *(ptr+i) can be written as ptr[i]. So
if we have a po'
pointing to.-the Oth element of arraYI "then 'we can access the elements of
array by sub
poin
variable. This equivalence of pointer and subscript notations is us~d
in dynamic
e' g arrays to functions.'
"
J Now let us see
e between the name of an array and a pointer variable. The name
of ari array .
in: er
en e it will always point to the Olh element of the array. It is not
a iariable, hen
igo some other address to, it neither can we move it by incrementing
or decremen .
arr =
OWJLCJ.l~
arr++'
arr = arr-
/*P8.l0
Progr
to
print
the
value
and
address
of
array. elements
by
subscripti g
a
_ ointer
variable* /
#include<s
~ .=>
main( )
{
int
arr[-.='5,10,15,20,25};
int
i, *p;
-~

212
p=arr;
for(i=O;i<5;i++)
{
C in Depth
printf("Address
of
arr[%d)=
%u%u
%u
%u\n",i,&arr[i],ax-r+i,p+i,
-_...- .....
-~
&p [i] );
p-i"i";;'tf("Value
of
arr[%d]=
%d
%d
%d
%d \n",i,arr[iJ,*(arr+i),*(p+i),
p [i] ) ;
}
----:-',
}
. J p-t : .
.
I
Output:
Address of arr[O]= 2000 2000 2000 2000 .
.Value of arr[O] = 5 5 5 5
Address of arr[ 1}= 2002
~002 2002 2002
Vallie of arr[l] = 10 10 10 10
Address of arrI2]= 2004 2004 2004 2004
Value of arr[2] = 15 15 1515
Aqdress of arr[3]= 2006 2006 2006 2006
Value of arr[3] = 20 20 20 20
Address of arr[4]~ 2008 2008- 2008 2008
Value of arr[4] = 25 25 25 25
8.10
Pointer to an Array
'
....-
I
111_ the previous section, we had a pointer that pointed to the th element of array. We can also declare
a pointer that can point to the whole array inst:ad of only one\element of array. This p.ointer is useful
when talking about multidimensional arrays. Now we'll see
,ow to declare a pointer to an array.
~nt (*P!I')[1l!J;
.
Here ptr is pointer that can point to an array of 10 integers.
ote that it is necessary to enclose the
pointer name inside parentheses. Here the type of ptr is 'pointer to an array of 10 integers'. -
Note that the pointer that points to the Oth element of array and the pointer that points to the whole
array are totally different. The following program shows this'::
/*P8.11
Program.to
and
pointer
to
an
#include<stdio.h>
main ( )
{
understand
di f ference
array
of
itegers * /
between
pointer
to
.t,
"
an
integer
%u\n" ,p,ptr);
Oth
element
of
arr* /
the
whole
array
arr'* /
%u\n" ,p,ptr);
f&- __
int
*p;
/ *Can
point
to
an
intege,r* /
int
(*ptr) [5];
/ *Can
point
to
an
array
of
5
~
_"..
•
I
int
arr5];
p=arr-;T
/*Points .to
-..
,.
I
ptr=arr;
/*Points
to
print-to ("p
=
%u,
ptr
=
p++;
ptr++;
printf ("p
=
%u,
ptr
integers*/
.,
'

Pointers
213
Output:
p = 3000
°tr = ~ _
p = 3004, ptr = 3010,
crinter that points to Olh element of arrayal.!, while ptr is a pointer that points to the whole
--==--~-e
type of p is 'lni;'"while base type' of prr-iS'an array of 5 integers'o
e K'now"tniC
;hP-;:;;:;;;;:t?T a.-,:tlu:neltic is perfO"rmed relative to the base size, so if we write ptr++, then the pointer ptr
forward by 10 byteso The following figure shows the pointers p and ptr, in this chapter
darker arrow to denote pointer to an array.
On dereferencing a pointer expression we get a value pointed to by that pointer expression. Pointer to
an array points oto ~n array, so on dereferencing it we should get the array, and the name of array denotes'
the base add~ess. So whenever a pointer to an array is dereferenced, we get the base address of the'
array to/whlch it pointso
.
0
/*P8.12
PrograOm
to
dereference
a
pointer
to
an
array* /
#include<stdio.h>
main ( )
{
int
arr [5J = {3, 5,6,7,9} ;
int
*p=~ar..r;
int
(*ptr) [5j=arr;
printf("p
=
%u,
ptr
=
%u\n",p,ptr);
.
fJlilO----
printf("*p
=
%d,
*pcr
=
o%u\n",*p,*ptr);
printf("sizeof(p)
=
%u,
sizeof(*p)
=
%u\n",sizeof(p),sizeof(*p));,
printf(":;;izeof(ptr)
=
%u,
sizeof(*ptr)
=0 %u\n",sizeof(ptr),
sizeof (*ptd ) ;
}
Output:
p = 3000, ptr = 3000
*p = 3, *ptr = ~..-
sizeof(p) = 2, sizeof(*p) = 2
sizeof(ptr) = 2, sizeof(*ptr) = 10
"
8.11
Pointers And Two Dimensional Arrays
In a two dimensional array we can access each element by using two subscripts, where first subscript
represents row number and second subscript represents the column number. The elements of 2-D array
can be accessed with the help of pointer notation also. Suppose arr is a 2-D °array, then we can access
any element arr[i][j] of this array using the pointer expression *( *(arr+i) + j ). Now we'll see how

214
C in Depth
. this expression can be derived. Let us take a two dimension array arr[3][4]-
int arr[3][4] = { {10, 11, 12, 13}, {20, 21, 22, 23}, {30, 31, 32, 33} };
Column 0
Column 1
Column 2
Column 3
Row 0
Row 1
Row 2 .
10
11
12
13
20
21
22
23
30
31
32
33
~.
We have been talking about 2-0 arrays in terms of rows and columns, but since memory in computer
is organized linearly it isn6t possible to store the 2-0 array in rows and columns. The concept ofrows
and columns is only theoretical, ac1ually a 2-0 array is stored in row major order i.e. rows are placed
next to each other. The following figure ~hows how the' ab~ve .2-0 array will be stored in memory.
-==::K
......_"__--..
A
A __·
__
(
V
V
\
arr[O][0]
arr[~][O]
arr[2][0]
'1 10'. Q.C] 12 L~30 '0 32 Q!]
5000
5002
5004
5006 5008
5010
5012
5014
5016
5018
5020
5022
Points to OIl 1-D array - . ,50Q.O..
Points to 1sl 1,-D array -
5008
Points to 2
nd I-D array -
5016
3m)'?)
,,1\1);" .,,') q 36"0
.:-'
1
~.
,,~.
arr
I
10
11
12
13
--=<.
5'~
~
rr+l)
.,'
\
\ .
20
21
22 .
23
- -
.../'
rr+2)
30
~
~
31
32
33
",.
.
(a
(a
Points to 0
1
1 element of arr -
Points to 1Sl el~ment of arr' -,
Points to 2
nd element of ad -
arr
arr+1 -
arr+2 -
Each row can be considered as a 1-0 array, so a two-dimensional array can be considered as'a collection
of one-dimensional arrays that are placed one after another, In other words we can say that a 2-0 array
is an array of arrays. So here arr is an array of 3 elements where each element is a 1-0 arr.ay of 4
integers.
We know that the name of an array is a constant pointer that points to the Olh element of array. I~ the
case of 2-0 arrays, Olh element is a 1-0 array, so the name of a 2-0 array represents a pointer to a
1-0 array. For example in the above case, arr is a pointer to Olh 1-0 array and contains address 5000.
Since arr is a 'pointer to an array of 4 integers', so according to pointer arithmetic, the expression
(arr+1) will represent the address 5008 and expression (arr+2) will represent address 5016.
So we can say that arr points to the Olh 1-0 array, (arr+1) points to the 1'1 1-0 array and (arr+2) points
to the 2nd 1-0 array.
-

pointers
215
In general we can write-
,
arr+i
Points to ilh element of arr ~ Points to ph I-D array
Since (arr+i)-points to ilh element ofarr, so on derefemcing it we'll get ilh element of arr which is of
cour~ I-D array. Hence the expression *(arr+i) gives us ~he base address of ilh I-D' array,
We have proved earlier that the pointer expression *(arr+i) is equivalent to the subscript expression arr[i],
So *(arr+i) which is same as arr[i] gives the base address of i!h I-D array.
*(~)_- arr[O].- Base address ofO~,I-D array - P.oints to Olh element of 011: I-D array -
~OOO
,
*(aFf+l) -"arr[I]- Base address of pi I-D array - Points to Olh element onSI I-D array - 5008 ,
*(arr+2) - arr[2] - Base address of 2nd I-D array - Points to Olh element of 2Jld I-D array --5016
In general we can write- .
*(arr+i), - arr[i] - Base address of ith l-D array - Points to _Olh element of ilh I-D array
Note that both the expressions (arr+i) and *(arr+i) are pointers, but their base type is different The
base type of (arr+i) is 'an array of 4 ints' while the base type of *(arr+i) or
~r[i] is 'int'.·
.
.
'.
-,
,..
.
.
To access any individilal element of our 2-D array, ,we should be able to access any, jlh element of the
ilh I-D array. Since the base type of *(arr+i) is -'int' and it contains the address of Olh 'element of ilh
-
,
'
I-D array, so we can get the addresses of subsequent elements in the ilh I-D array by adding integer
values to *(arr+i). For example *(arr+i)+1 will represent the address of}<l element of ilh I-D array and
*(arr+i)+2 will represent the address of 2nd element of ilh I-D array. Similarly *(arr+i)+j will represent
the address of jlh element of ilh I-D array. On dereferencing this expression we can get the jth element
of the ith I-p array.
arr
*arr
(arr+i)
*(arr+i)
, *Jarr+Q~
*( *(arr+i)+j )
Points to Olh I-D array
.
..\
Points to Olh element of Olh I-D array
P~ints to ilh I-D array
Points to Olh element of ith I-D array
Points to jlh element of ilh I-D array
-.-.-
-
'"
..
Represents the value of jlh element of ilh I-D array
*arr
*(*(arr+2)+3)
..... 10
11
12
13
.....
... 20
21
22
23
.....
..... 30
31
32
33~
.....
-
arr
(arr+l)
(arr+2)
t
*(arr+2)
t
*(arr+2)+3

} ;
int
arr [3] (4) = {
Since ptr is a pointer to an array of
integers. so according
0 pointer arithmetic, ptr+i will point
C in Dep
23 23
33 33
1313
~
10
.11
12
13
20
21
22
23
30
31
32
33
Subscripting Pointer To An Array
ptf
5000''\
I 5QQO I
int
i,j;,
for(i=9;i<3;i++)
}
Output:
Address of Oth, I-D array = 65000 65,000
10 10
11 11
'12 12
Address of lth I-D array = 65008 65008
20 20
21 21
22 22
Address of 2th I-D array = 65016 65016
30 30
31 31
32 32
{lO, 11, 12, l3},
{20,21,22,23},
{30,31,32,33}
\
printf(';Address
of
%dt,h ar,ray
=
%u
%1J.\n",i J arr[iJ,*(arr+i»;
for ( j =0'; j < 4 ; j + + )
..~
,
~
J"''"'. ,.....}
'0 .'
printf("%d
%d
",arr[i] [jJ,*(*(arr+i)+j»;
pr i n t f ( " \ n" );
Cnder the heading 'Subsripting Pointer Variables', we had seen how to subscript a pointer variable tl
:tains the base address of a I-D array. Now we'll see how to subscript a pointer to an array tl
ontains the base address of a 2-D array.
.
uppose arr is a 2-D array with 3 rows and 4 columns and ptr is a pointer to an array of 4 intege
and ptr contains the base address of array arr.
i?t arr[3][4],= { {10, 11, 12, 13}, {20, 21, 22, 23}, {30, 31, 32, 33} };
int (*ptr)[4];
ptr = arr; ,
-!
_:-
~-,
/ *
P8. 13
Program
to
print
the
values
and
address
of
elements
of
a'
D
array
* /
#include<stdio.h>
:nain ( )
{
8.12
216

pth
'11- ' ).
Pointers
217
2-
.
~.
ith row, On dereferncing (ptr+i), we get base address of ith row, To access the address of jth element
of ith row we can add j to the pointer expression *(ptr+i). So the pointer expression *(ptr+i)+j
giv~s'
the address of j!h element of ith row. So the pointer expression *( *(ptr+i)+j) gives the value pf the jth
element of ith row.
.
We have studied that the pointer expression *(*(ptr+i)+j ) is equivalent to subscript expression ptr[i][j]._
Soif we have a pointer variable containing the base address of 2-D array, then we can access the elements
of array by double subscripting that pointer variable.
.
.
/*P8.14
Program to print
elements
of
a
2-D array by subscripting
a
pointer
to
an
array. variable* /
#include<stdio.h>
main( )
{
int
i,arr[3] [4]={{10,1l,12,13}, {20,21,22,23}, {30,3l,32,33}};
int
( * p tF) [4] ;
ptr=arr;
printf("%u
%u
%\~\nn,Ptr,ptr+1,ptr+2);
printt'( ,,%'u
%u
%u \nn, *ptr, * (ptr+1) ,*'(ptr+2) ) ;
printf("%d
%d
%d\nn,**ptr,*{*(ptr+1)+2),*(*(ptr+2)+3));
printf("%d
%d
%d\nn ,ptr[O] [0] ,ptr[l] [2] ,ptr[2] [3]);
}
OutPJIt:
5000 5008 5016
5006 5008 5016
]0 22 33
10 22 33
In a three dimensional array we can access each element by using three subscripts. Let us take a 3-
D array-
_int
arr[2] [3] [2]={
,Ie thai
ly thai
ltegers
8.13
Pointers And Three Dimensional Arrays
point tl
{5,10},
{6,1l},
{7,12},
},
{
{20,30},
{21,31},
{22,32},
} ;
We can consider a three diinensional array to be an array of 2eD arrays i.e. each element of a 3-D
array is considered to be a 2-D array. The 3-D array arr can be. considered a~ an array consisting of
two elements where each elenlent is a 2-D array. The name of the array arr is a pbinter to the Oth elemen
of the ·array, so arr points to the Oth 2-D array.
'

*(arr+i)+j
*(*(arr+i)+j)
*(*(arr+i)+j)+k
*(*(*(arr+i)+j)+k)
ow let us see how we can access any element of a 3d array using pointer notation.
arr
Points to Olh 2-D array'
arr+i
Points to ilh 2-D array
*(arr+i)
Gives base address of ilh 2-D array,
so points to Olh element of ilh 2-D array,
each element of 2-D array is a I-D array,
so it points to Olh I-D array of ith 2-D array
Points to jlh I-D array of ilh 2-D array
Gives base address of jlh I-D array of ilh 2-D array,
so. it points to Olh element of jlh I-D array of ilh 2-D array
Points to klh/element of jlh I-D array of ith 2-D array
Gives the value of klh element of jlh I-D array of ilh 2-D array
So we can see that the pointer expression *(*(*(arr+i)+j)+k) is equivalent to the subscript expression
arr[iJrj][k).
Earlier we have seen that the expression *(arr+i) is equivalent to arr[i] and the expression *(*(arr+i)+j)
is equivalent to arr[iJrj]. So we can say that arr[i] represents the base address of ilh 2-D array and arr[i][j]
represents the represents the base address of the jlh I-D array of ilh 2-D array.
/*P8.1S
Program to print the elements of
3-D array using pointer notation*/
#include<stdio.h>
main( )
{
int
arr[2][3][2]={
{S,lO},
{6, ll},
{7,12},
},
{
{20,30},
{21,31},
{22,32},
} ;
int
i,j,k;
for(i=O;i<2;i++)
for(j=O;j<3;j++)
{
for(k=O;k<2;k++)
printf("
%d\t";*(*(*(arr+i)+j)+k));
printf (".. \n") ;
}
Output:
5
10
6
11
\
/

Pointers
219
7
12
20
30
21
31
22
32
The following figure shows how the 3-D array used in the above program is stored in memory.
1st 2-D array
oth 1-Darray of
1st 2-D array
oth 2-D array
•
t
oth 1-D array of
oth
2~D array . 1st 1 D
f
-
array 0
oth 2-D array
oth element of
'-----.toth 1-D array of
oth 2-D array
oth element of
oth I-D array of
1st 2-D array
8.14
Pointers And Functions
/*P8.16
Program
to
explain
call
byvalue* /
#include<stdio.h>
main ( )
{
int
a=5,b=8;

220
C in Depth
printf ("Before
calling
the
function,
a
and bare
%d, %d\n", a, b) ;
value(a,b) ;
printf ("After
calling
the
function,
a
and bare
%d, %d\n", a, b) ;
}
value(int
{
x, int
y:)
,
-
X; +~;
Y.++ ;,
printf("In
function
changes
are
%d,%d\n",x,y);
}
Output:
Before calling the function, a and bare 5, 8
In functiqn changes are 6 , ?
After calling the function, a and' bare 5, 8
Here a and b are variables declared·in the function maine ) while. x and yare declared in the function
value( ).These variables re~ide at different address~s in-memory. Whenever the function value( ) is called,
two variables are created named x and y and are initialized with the values of variables a and b. Tliis
type of parameter passing is called call by value since we are only supplying the values of actual arguments
to the calling function. Any operation performed on variables x ~nd y in the function value( ), will not
affect variables a and b.
Before calling the function value( ) , the value ofa = 5 and b = 8. The values of a and b are copied
into x and y. Sine:: the memory locations of x, y and a, b are different, so when the values of x and
yare incremented, there will be no effect on the values of a and b. Therefore after calling the function,
a and b are same as before calling the function and have the value 5 and 8.
Before execution of function
After incrementing x and y
maine )
value( )
maine )
value( )
a OJ
x OJ
a OJ
x [TI
2000
2012
2000
2012
[]J
[I]
[I]
IT]
b
2002
Y
2014
b
2002
Y
2014
Although C does not use call by reference, but we can, simulate it by passing addresses of variables
as arguments to the function. To accept the addresses inside the function, we'll need pointer variables.
Here is a progr:lm that simulates call by reference by passing addresses of variables a and b.
/ *
PR. 17
program
to
explain
call
by
reference* /
#include<stdio.h>
main( )
{
int
a=5;
int
b=8;
printf ("Before
calling
the
function,
Ct
and 'b
are
%d, %d\n" ,a, b) ;
ref(&a,&b) ;

Pointers
printf("After
calling
the
function,
a
and bare
%d,%d\E",a,b);
}
ref (int
*p, int
*q)
{
(*p)++;
(*q) ++;
printf ("In
function
changes
are
%0, %d\n", -p, *q) ;
221
}
Output:
Before calling the function, a and bare 5, 8
In function changes are 6 , 9
After calling the function, a and bare 6, 9
, Here we are passing addresses ofvariables a and b in the function cal!. So the receiving fonnal arguments
in the function declaration should be declared of pointer type. Whenever function ref( ) is called, two
pointer to int variables, named p ~nd q are created and they are initialized with the addresses of a and,
b. Now if we dereference 'pointers p and q, we will be able to access variables a and b from function
ref( ).
The maine ) accesses the memory locations occupied by variables a and b by writing their names, while
ref( ) accesses the same memory locations indirectly by writing *p, *q.
Before execution of function
After incrementing *p and *q
ref!
maine )
ref( )
, [JJ
OJ
p 2000
a.
p
a
2000
2000
2012
OJ
2002
IT]
002
b
2002
2014
b
2002
~
q
q
2014
Before calling the function ref( ), the value of a = 5 and b = 8. The value of actual arguments are
copied into pointer variables p and q, and here the actual arguments are addresses of variables a and
b. Since p contains address of variable a, so we can access variable a inside ref() by writing *p, similarly
'variable b can be accessed by
wr~ting *q.
Now (*p)++ means value at address 2000 (which is 5 ) is incremented. Similarly (*q)++ means value
at address 2002 (which is 8) is incremented. Now the value of *p = 6 and *q = 9. When we come
back to maine ), we see that the values of variable a and b have changed. This is because the function
ref( ) knew the addresses, of a and b, so it was able to access them indirectly.
So in this way we could simulate call by reference by passing addresses of arguments. This method
is mainly useful when the called function' has to return more than one values to the function.
8.15
Returning More Than One Value From A Function
We have studied that we ,can return only one value from a function through return statement. This
limitation can be overcome by using call by reference. Let us take a simple example to understand this
concept. Suppose we want a function to return the sum, difference and product of two numbers passed

222
C in Depth
to it. If we use return statement then we will have to make three different functions with one return
statement in each. The following program shows how we can return all these values from a single
function.
/*P8.18
Program to
show
how to
return
more
than
one value
from
a
function
using
call
by
reference* /
#include<stdio.h>
main( )
{
int. a,b,sum,diff,prod;
a=6 ;
b=4;
func(a,b,&sum,&diff,&prod) ;
printf ("Sum
=
%d,
Difference
=
%d,
Product
}
func (int
x, int
y, int
*ps, lIlt.
*pd, int
*pp)
{
*ps=X+y;
*pd=x-y;
*pp=x*y;
%d\n",sum,diff,prod) ;
}
Output:
Sum = 10, Difference = 2 , Product = 24 .
In func( ) variables a and b are passed by value while variables sum, diff, prod are passsed by reference.
The function funcO knows the addresses of variables sum, diff and prod, so it accesses these variables
indirectly using pointers and changes their values.
8.16
Function Returning Pointer
We can have a function that returns a pointer. The syntax of declaration of such type of functien is-
type *func(typel, type 2, ... );
For example-
float *fun(int : char );
/* This function returns a pointer to float. */
int
*f~nc(int , int );
/* This function returns a pointer to int. */
.While returning a pointer, make sure that the memory address returned by the pointer will exist even
after the termination of function. For example a function of this form is invalid-
main( )
{
int. *ptr;
ptr=func ( ) ;
·int
* func (
int
x=5;
int
*p=&x;
~---

Pointers
return
Pi
. 223
Here we are returning a pointer which points to a local variable. We know that a local variable exists
only inside the function. Suppose the variable x is stored at address 2500, so the value of p will be
2500 and this value will be returned by the function func( ). As soon as func( ) terminates, the local
variables x will cease to exist.
The address returned by func( ) is assigned to pointer variable ptr inside main( ), so now ptr will contain
address 2500. When we dereference ptr, we are trying to access the value of a variable that no longer
exists. So never return a pointer that points to a local variable. Now we'll take a program that uses
a function returning pointer.
/.*P8.19
Program
to
show
the
use
of
a
function
that
returns
pointer* /
#include<stdio.h>
int
*fun(int
*p,int
n)i
main( )
int
arr[10] ={l, 2, 3,4,5,6,7,8,9, 10} ,n, *ptri
n=5 i
ptr=fun(arr,n) i
printf ("Value
of
arr
%u,
Value
of ptr
=
%u,
value
of
*ptr
=
%d\n",
arr, ptr, *ptr) i
int
* fun (int
*p, int
n)
p=p+ni
return
Pi
}
Output: -
Value of arr = 65104, Value of ptr = 65114, Value of *ptr = 6
8.17
Passing a 1-D Array to a Function
In the previous chapter we had studied that when an array is passed to a function, the changes made
inside the function affect the original array. This is because the function gets access to the original
array. Here is a simple program that verifies this fact.
I*P8.20
Program to
show that
changes
to
the array made
inside the
function
af feet
the
original
array* I
#inc1ude<stdio.h>
main( )
{
int
i,arr[5]={3,6,2,7,1}j
func(arr)
j
printf("Inside
main()
")j
for(i=Oii<5ii++)
printf("%d
",arr[i])j
~intf("\n") .
~
,

C in Depth
func (int
a [
])
{
int
i;
printf("Inside
fune(
");
for(i=O;i<5;i++)
a[i]=a[i]+2;
printf("%d",a[i]) ;
printf("\n") ;
}
Output:
Inside func( ) : 5 8 4 9 3
Inside maine ) : 5 8 4 9 3
Now after studying about pointers we are in a position to understand what actually happens when an
array is passed to a function. There are three ways of declaring the formal parameter, which has to
receive the array. We can declare it as an unsized or sized array or we can declare it as a pointer.
fune(int
a[J)
{
}
fune (int
a [5] ) ;
{
}
fune(int
*a);
{
In all the three cases the compiler reserves space only for a pointer variable inside the function. In the
function call, the array name. is passed without any
sub~cript or address operator. Since array name
represents the address of first element of array, hence this address is assigned to the pointer variable
in the ftinction. So inside the function we have a pointer that contains the base address of the array.
In the above program, the argument a is declared as a pointer variable whose base type is int, and it
is initialized with the base address of array arr. We have studied that ifwe have a pointer variable containing
,
the base address of an array, then we can access any array element either by pointer notation or subscript
notation. So inside the function, we can access any ith element of arr by writing *(a+i) or a[i]. Since
we are directly accessing the original array hence all the changes made to the array in the called function
are reflected in the calling function.'

Pointers
func( )
maine )
225
a
arr[O] arr[l] arr[2] arr[3] arr[4]
1 2010 ,
.. I
3 I 6 I 2 I 7 I 1 I
2010
2012
2014
2016
2018
2068
2069
The following program will illustrate the point that we have discussed.
/*P8.21
Program
to
verify
the
fact
that
when
an
array
is
passed
to· a
function,
the· receiving
argument
is
declared
as
a
pointer
* /
#include<stdio.h>
main( )
{
float
f_arr[5]={1.4,2.5,3.7,4.1,5.9}i
int
i_arr[5]={1,2,3,4,5}i
char
c_arr[5]={ 'a', 'b', 'c', 'd', 'e'}i
printf("Inside
main(
")i
printf("Size
of
arr
%u\t",sizeof(f_arr))i
printf("Size
of
arr
%u\t",sizeof(i_arr))i
printf("Size
of
arr
%u\n",sizeof(c_arr))i
func(f_arr,i_arr,c_arr) i
}
func(f16at
f[
J,int
*i,char
c[5])
{
printf("Inside
func()
")i
printf("Size
of
f
%d\t",sizeof(f));
printf("Size
of
i
%d\t",sizeof(i))i
printf ("Size
of
c
%d\n", sizeof (c));
)
Output:
Inside maine ) : Size of Carr = 20
Size of i arr = 10
Size of carr = 5
II}side func( ) : Size of f = 2
Size of i = 2
Size of c = 2
Inside the function func( ), f, i, c are declared as pointers, and this is evident by the fact that the
size of each one of them is 2 bytes.
8.18
Passing a 2-D Array to a Function
We have studied in the previous chapter that whenever a multidimensional array is passed to a function,
then it is optional to specify the leftmost dimension but all other dimensions must be specified. So if
we have a 2-D array with 3 row and 4 columns, then the definition of a function that accepts it can
be written in these two ways-
func(int
a[3] [4])
{

226
C in Depth
}
func(int
a[] [4])
{
}
Any changes made to the array in the function will be reflected in the calling function.
Whenever a 2-D array is passed to a function, the function actually receives a pointer to a I-D array,
where the size of I-D array is equal to the number of columns. For example in the above case the
function receives a pointe~ to an array of 4 integers. So we may write the function definition in this
form also-
func(int
(*a) [4])
{
Here a is declared as a pointer to an array of 4 integers, and it is initialized with the base address of
the original 2-D array. Now inside the function we can use either pointer notation-or subscript notation
to access the elements. The following program will make these points clear.
/*P8.22
Program
to
pass
a
2-D
array
to
a
function*/
#include<stdio.h>
main( )
{
int
i,j,arr[3J [4]={
printf("Inside
main(
func(arr);
printf ("Contents
of
for(i=O;i<3;i++)
{
{ll,12,13,14},
{l5,16,17,18},
{l9,20,2l,22},
} ;
sizeof(arr)
%u\n",sizeof(arr»;
array
after
calling
func ()
are
: \n") ;
for(j=O;j<4;j++)
printf("%d
",arr[i] [j]);
printf("\n");
}
func(int
(*a) [4J)
{
int
i,j;
printf (" Inside
func (
printf("Inside
func(
for(i=O;i<3;i++)
for(j=O;j<4;j++)
ali] [j]=a[i] [j]+2;
sizeof(a)
sizeof(*a)
%u\n", sizeof ta)} ;
%u\n",sizebf(*a»
;
}
Output:
Inside main()
sizeof(arr) = 24
.
!

Pointers
Inside func( ) : sizeof(a) = 2
Inside func( ) : sizeof(*a) = 8
Contents of array after calling func( ) are -
13 14 15 16
17 18 19 20
21 22 23 24
func( )
maine )
227
a
5000
~
....
10
11
12
13
JI""
5008
20
21
22
23
5016
30
31'
32
33
8.19,
Array Of Pointers
We can declare an array that contains pointers as its elements. Every element of this array is a pointer
variable that can hold address of any variable of appropriate type. The syntax of declaring an array
of pointers is similar to that of declaring arrays except that an asterisk is placed before the array name.
datatype *arrayname[size];
For example to declare an array of size 10 that contains integer pointers we can write-
int *arrp[10];
I"*P8.23
Program
for
understanding
the
concept
of
array
of
pointers*/
#include<stdio.h>
main ( )
{
int
*pa[3];
int
i,a=5,b=lO,c=15;
pa[O]=&a;
pa[l]=&b;
pa[2]=&c;
for(i=O;i<3;i++)
{
printf ("pa [%dl
printf("*pa[%dl
%u \ t" , i, pa [ i 1) ;
=
%d\n",i,*pa[i]);
}
Output:
pa[O] = 2012
pa[l] = 2560
pa[2] = 3020
*pa[O] = 5
*pa[l] = 10
*pa[2] = 15

228
a
5
2012
b
10
c
15
3020
C in Depth
Here pa is declared as an array of pointers. Every element of this array is a pointer to an integer. pa[i]
gives the value of the ith element of 'pa' which is an address of any int variable and *pa[i] gives the
value of that int variable.
The array of pointers can also contain addresses of elements of another array.
/*P8.24
Program
for
understanding
array
of
pointers* /
#include<sidio.h>
main( )
{
int
i,arr[4]={5,lO,15,20};
int
*pa[4];
for(i=O;i<4;i++)
pari]
=
&arr[i];
for(i=O;i<4;i++)
{
printf ("pa [%d]
printf (" *pa [%d]
=
%u \ t" , i, pa [ i] ) ;
=
%d\n",i,*pa[i]);
}
Output:
pa[O] = 1000
pa[l] = 1002
pa[2] = 1004
pa[3] = 1006
*pa[O] = 5
*pa[l] = 10
*pa[2] = 15
*pa[3] = 20
Here 'pa' is declared as array of pointers. Each element of this array contains the address of each element
of array 'arr'.
arr[O]
arr[l]
arr[2]
arr[3]
5 I
10
I
15
I
20
IT r lJ r
pa[O]
pa[l]
pa[2]
pa[3]
I 1000
1002
1004
1006
2500
2502
2504
2506
lM;.

Pointers
229
Now we'll take a 2-D array arr with 3 rows and 4 columns. An array of pointers of size 3 is declared
and each pointer in this array is assigned the address of Oth element of each row of the 2-D array, i.e.
ith element of pa is a pointer to Oth element of ith row of a 2-D array. This can be done as-
int
arr[3] [4]={{10;11,12,13}, {20,21,22,23}, {30,31,32,33}};
int
*pa[3];
.
for(i=O;i<3;i++)
pa [i] =arr [i] ;
5000
parOl
pa[l]
pa[2]
5000
~
10
11
12
13
5008
~
20
21
22
23
5016
-
~
30
31
32
33
Now let us see how we can access the elements of the 2-D array' arr using the array of pointers
p~.
parOl is a pointer to the Oth element of Oth I-D array of the arrayarr, similarly pari] will be a pointer
to Oth element of ith I-D array of arr.
Since base type of pointer pari] is int, so if we want the address of jth element of ith I-D array then·
we can add j to the expression pari]. Hence the expression pa[i]+j will give the address of fh element
of i1h I-D array. So the expression *( pa[i]+j ) will give the value of the jth element of ith I-D array.
We know that pari] is equivalent to *(pa+i). So the above expression can be written as *(*(pa+i) +j),
and we know that this expression is equivalent to pa[i][j]. So finally we can access the jth element of
ith I-D array by writing pa[i][j].
/"P8.25
program
for ·understanding
array
of
pointers*/
#include<stdio.h>
main( )
{
. int
i, j , arr [3] [4] = { { 10, 11, 12, 13}, {2 0,21,22, 23 }, {3 0, 31,32,33 } } ;
int
*pa[3];
for(i=O;i<3;i++)
pa [i] =arr [i] ;,
for(i=O;i<3;i++)
{
for(j=O;j<4;j++)
printf("%d
",pa[i] [j]);
. printf("\n");
}
Output:
10 11 1213
20 21 22 23
30 31 32 33
8.20
void Pointers
We have studied that a pointer should be assigned an address of the same type as mentioned in pointer

230
C in Depth
/*Incorrect */
/*Correct*/
/*Correct '"/
/*Correct */
declaration. For example if we have a pointer to int, then it would be incorrect to assign the address
of a float variable to it. But an exc.eption to this rule is a pointer to void. A pointer to void is a generic
pointer that can point .t<{ any data type. The syntax of declaration of a void pointer is-
void *vpt; .,'
Here void is a keyword and vpt is declared as a pointer of void type. For example-
int i = 2, *ip = &i;
float f= 2.3, *fp = &f;
double d;
void *vp;
ip = fp;
vp = Ip;
vp = fp;
vp = &d;
We can assign address of any data typ.e to a void pointer and a void pointer can be" assigned to a pointer
of any data type.
A void pointer can't be dereferenced simply by u,S;ing indirection operator. Before dereferencing, it should'
be type cast to appropriate pointer data type. For example if vp is a void pointer and it holds the address
of an integer variable then we can't derefe~~tice i~ just by writing *vp. We'll have to write *(int *)vp,
.where leftmost asterisk is the indirection, operator and (int *) is used for typecasting. Similarly pointer
arithmetic can't be performed on void pointers without typecasting.
/ *P8. 26
Program
to
understand
the
dereferencing
of
a
void
pointer* /
#include<stdio.h>
main(
{
int
a=3;
float
b=3.4,*fp=&b;
void
*vp;
vp=&a;
printf("Value
of
a
=
%d\n",*(int
*)vp);
* (in t
* ) vp=1 2 ;
printf("Value
of
a
=
%d\n",*(int
*)vp);
vp=fp;
printf("Value
of
b
%f\n",*(float
*)vp);
}
Output:
Value of a = 3
Value of a = 12
Value of b = 3.400000
/ *P8. 27
Program
to
understand. pointer
arithmetic
in
void
pointers
* /
#include<stdio.h>
main ( )
{
int
i;

Pointers
231
float
a[4J={l.2,2.5,3.6,4.6};
void
*vp;
vp=a;
for(i=O;i<4;i++)
{
p r i n t f ( "% . 1 f \ t " , * (f loa t
*) vp) ;
(float
*)vp~(float
*)vp+l
/*Can't
write
vp=vp+l*/
}
printf("\n") ;
}
Output:
1.2
2.5
3.6
4.6
void pointers are generally used to pass pointers to functions which have to perform same operations
on different data types.
8.21
Dynamic Memory Allocation
The hlemory allocation lthat we have done till now was static memory allocation. The memory that could
be used by the program was fixed i.e. we could not increase or decrease the size of memory during
the execution of program. In many applications it is not possible to predict how much memory would
be needed by the program at run time. For' ex~mple if we qeclare an array of integers-
int emp_no[200];,
In an array, it is must to specify the size of array while declaring, so the size of this array will be
fixed during runtime. Now two types of problems may occur. The first case is that the number of
values to be stored is less than the size of array -and hence there is wastage of memory. For example
if we have to store only 50 values in the above array, then space for 150 values( 300 bytes) is wasted.
!n second case ou:;;r:'ogram fails if \~/e want to store more values than the size of array, for example
If there IS need ~ store 205 values Il1 the above array.
'
/ .
~
. To overcome these problems we should be able to allocate memory at run time. The process of allocating
,memory at the time of execution is called dynamic memory allocation. The allocation and release of
this memory space can be done with the help of some built-in-functions whose prototypes are found
in alloc.h and stdlib.ll' header files. These functions take memory from a memory area called heap and
release this memory 'whenever not required, so that it can be used again for some other purpose.
Pointers play an impol tant role in dynamic memory allocation because we can access the dynamically
allocated memory only' through pointers.
8.21.1
malloc()
Declaration: void *ma11 'oc(size_t size);
This function is used to a Hocate memory dynamically. The argument size specifies the number of bytes.
to be allocated. The type
size_t is defined in stdlib.h as uns,igned int. On success: malloc( ) returns
a pointer to the first byte ( )f allocated memory. The returned pointer is of type void, which can be type
cast to appropriate type
o~ f pointer. It is generally used as-
ptr = (datatype *) m3 Hoc ( specified size );
re ptr is a pointer of typ 'e datatype, and specified size is the size in bytes required to be reserved
mory. The expression « l11Jtatype *) is used to typecast the pointer returned by malloc( ). For example-
\

232
in~ *ptr;
ptr = ( int * ) malloc (l0);
2500 2501
2502 2503 2504 2505 2506 2507 2508 2509
C in Depth
/l
#j
me
This allocates 10 contiguous bytes of memory space and the address of first byte is stored in the pointer
variable ptr. This space can hold 5 integers. The allocated memory contains garbage value. We can use
sizeof operator to make the program portable and more readable.
ptr =
( int * ) malloc ( 5 * sizeof ( int ) );
This allocates the memory space to hold five integer values.
If there is not sufficient memory available in heap then malloc( ) returns NULL. So we should always
check the value returned by malloc( ).
ptr = (float *) malloc(lO*sizeof(float) );
if ( ptr = = NULL )
printf("Sufficient memory not available");
Unlike memory allocated for variables and arrays, -dynamically allocated memory has no name associated
I
with it. So it can be accessed only through pointers. We have a pointer which points to the first byte
of the allocated memory and we can access the subsequent bytes using pointer arithmetic.
/*P8.28
Program
to
understand
dynamic
ailocation
of
memory* /
#include~stdio.h>
#include<alloc.h>
main( )
{
int
*p,n,i;
printf ("Enter
the
number
of
integers
to
be
entered
") ;
scanf· ("%d" ,&n) ;
p= (int
*) malloc (n* si zeof (int) ) ;
if (p==NULL)
{ .
printf ("Memory
net
available\n");
exi t (1) ;
for(i=O;i<n;i++)
printf ("Enter
an
integer
") ;
scanf("%d",p+i);
}
for(i=O;i<n;i++)
printf("%d\t",*(p+i)) :
The function malloc( ) returns a void pointer and we have studied that a void pointer can be assigned
to any type of pointer without typecasting. But we have used typecasting because it is a good practice
to do so and moreover it also ensures compatibility with C++.

Pointers
233
8.21.2
calloc()
Declaration: void *calloc(size_t n, size_t size);
The calloc( ) function is used to allocate multiple blocks of memory. It is somewhat sImilar to malloc(
) function except for two differences. The first one is that it takes two arguments. The first argument
specifies the number of blocks and the second one specifies the size of each block. For example-
ptr =
( int * ) calloc ( 5 , sizeof(int) );
This allocates 5 blocks of memory, each block contains 2 bytes and the starting address is stored in
the pointer variable ptr, which is of type int. An equivalent malloc( ) call would be-
ptr =
( int * ) malloc ( 5 * sizeof(int) );
Here we have to do the calculation ourselves by multiplying, but calloc( ) function does the calculation
for us.
The other difference between calloc( ) and malloc( ) is that the memory allocated by mallos,(J.con.!a~
garbage value while the memory allocated_l~'y.calloc( ) is iJliti.a~ed to zero. But this initialization by calloc(
) IS not very reliable, so it is better to explicitly initialize the elen1ents whenever there is need to do
so.
Like malloc( ), calloc( ) also returns NULL if there is not sufficient memory availaple in the heap.
8.21.3
realloc()
Declaration: void *realloc( void *ptr, size_t newsize)
We may want to increase or decrease the memory .allocated by malloc( ) or calloc( ). The function
realloc( ) is used to change the size of the memory block. It alters the size of the memory block without
losing the old data. This is known as reallocation of memory.
This function takes two arguments, first is a pointer to the block of memory that was previously allocated
by malloc( ) or calloc( ) and second one is the new size for that block. For example-
ptr = (int -*) malloc ( size );
""
This statement allocates the memory of the specified size and thy starting address of this memory block
is stored in the pointer variable ptr. If we :want to change the size of this memory block, then we can
use realloc( ) as-
ptr = (int \~) realloc ( ptr , newsize );
This statement allocates the memory space of newsize bytes, and the starting address of this memory
block is stored in the pointer variable ptr. The newsize may be smaller or larger than the old size. If
the newsize is larger, then the old data is not lost and the newly allocated bytes are uninitialized. The
starting address contained in ptr may change if there is not sufficient memory at the old address to
store all the bytes consecutively. This function moves the contents of old block into the new block
and the data of the old block is not lost. On failure, realloc( ) returns NULL.
/ *P8. 29
program
to
understand the
use
of
realloc ()
function* /
#include<stdio.h>
#include<alloc.h>
main ( )
{
i,nt
i, *ptr;
ptr=(int
*)malloc(5*sizeof(int));

234
if (ptr==NULL)
{
C in Depth
printf ("Memory
not
available\n");
exit-(l) ;
}
printf ("Enter
5
integers
") ;
for(i=O;i<5;i++)
scanf("%d
",ptr+i);
ptr= (int
*) realloc (ptr, 9 *sizeof (int) );
/ *Allocate
memory
for
4
more
integers*/
if (ptr==NULL)
{
printf ("Memory
not
available\n");
exi t (1) ;
..
f
I
}
printf ("Enter
4
more
integers
for(i=5;i<9;i++)
scanf("%d",ptr+i);
for(i=O;i<9;i++)
printf ("%d
", * (ptr+i));
8.21.4
free()
" ) ;
Declaration: void free(void *p)
The dynamically allocated memory is not automatically released; it will exist till the end of program.
If we have finished working with the memory allocated dynamically, it is our responsibility to release
that memory so that it can be reused. The function free( ) is used to release the memory space allocated
dynamically. The memory released by free( ) is made available to the heap again and can be used for
some other purpose. For example-
free ( ptr );
Here ptr is a pointer variable that contains the base address of a memory block created by malloc( )
or calloc( ). Once a memory location is freed it should not be used. We should-not try to free any
memory location that· was not allocated by malloc( ), calloc( ) or realloc( ).
When the program tenninates all the memory is released automatically by the operating system but it
is a good practice to free whatever has been allocated dynamically. We won't get any errors if we don't
free the dynamically allocated memory, but this would lead to memory leak i.e. memory is slowly leaking
away and can be reused only after the termination of program. For example consider this function-
func ( )
{
int
*ptr;
ptr=(int*)malloc(lO*sizeof(int)} ;
Here we have allocated memory for 10 integers through malloe( ), so each time this function is called,
space for 10 integers would be reserved. We know that the local variables vanish when the function
terminates, and since ptr is a local pointer variable so it will be deallocated automatically at the tennination
of function. But the space allocated dynamically is not deallocated automatically, so that space remains

Pointers
235
there and can't be used, leading to memory leaks. We should free the memory space by putting a call
to free( ) at the end ?f the function.
Since the memory space allocated dynamically is not released after the tern1ination of function, so it
is valid to return a pointer to dynamically allocated memory. For example-
int
*func()
int
*ptr;
ptr=(int*)ma~loc(10*sizeof(int));
return
ptr;
Here we have allocated memory through malloc( ) in func( ), and returned a pointer to this memory.
Now the calling function receives the starting address of this memory, so it can use this memory. Note
that now the call to function free( ) should be placed in the calling function when it has finished working
with this memory. Here fuiJ.c( ) is declared as a function returning pointer. Recall that it is not valid
to return address of a local varillble since it vanishes after the termination of function.
8.21.5
Dynamic Arrays
The memory allocated by malloc( ), calloc( ) and realloc( ) is always made up of contiguous bytes.
Moreover in C there is an equivalence between pointer notation and subscript notation i.e. we can apply
subscripts to a pointer variable. So we can access the dynamically allocated memory through subscript
notation also. We can utilize these features to 'create dynamic arrays whose size can vary during run
time.
Now we'll rewrite the program P8.28 using subscript notation.
/*P8.30
Program
to· access
dynamically
allocated
#include<stdio.h>
#include<alloc.h>
main ( )
{
memory
as
a
Id
array* /
int
*p,n,i;
printf ("Enter
the
number
of
integers
to
be
entered
") ;
scanf ("%d" ,&n) ;
p=(int
*)malloc(n*sizeof(int));
if
(
p
= =
NULL).
printf ("Memory
not
available\n");
exit (1);
}
for(i=O;i<n;i++)
printf ("Enter
an
integer
") ;
scanf("%d",&p[i]) ;
}
for(i=O;i<n;.i++)
•
printf("%d\t",p[i));
In this way we can simulate a I-D array for which size'is entered at execution time.

236
C in Depth
Now we'll see how to create a dynamically allocated 2-D array. In the next program we have used
. a pointer to an array to dynamically allocate a 2-D array. Here the number of columns is fixed while
the number of rows can be entered at run time.
/*P8.31
Program
to
dynamically
allocate
a
2-D
array
using
pointer
to
an
array*/
#include<stdio.h>
#include<alloc.h>
main ( )
{
int
i,j,rowsi
int
(*a)"[4]i
printf("Enter
number
of
rows
") i
scanf ("%d",
&rows) i
a=(int
(*) [4] )malloc(rows*4*sizeof(int)) i
for(i=Oii<rowsii++J
for(j=Oij<4ij+t)
{
printf("Enter
a[%d] [%d]
scanf ("%d", &a [i] [j]) i
j
printf ("The
matrix
is
: \n") i
for(i=Oii<rowsii++)
{
for(j=Oij<4ij++)
printf ("%5d", a [i] [j]) i
printf ("\n") i
}
free(a)i
",i,j)i
Suppose the number of rows entered is 3. The following figure shows how the dynamically.allocated
memory is accessed using pointer to an array. Since there are 3 r0wS and 4 columns so we'll allocate
24 bytes through malloc( ), and the address returned by malloc( ) is assigned to a. The return value
of malloc( ) is cast appropriately.
a
~2000[±±±J
5000
2008
2016
Now we'll" allocate a 2-D array using array of pointers. Here the number of rows is fixed while the
number of columns can be entered at run time.
/*P8.32 Program to dynamically allocate
a
2-D array using array of pointers*/

Pointers
-include<stdio.h>
-include<alloc.h>
ain ( )
(
237
int
*a[3J,i,j,colsi
printf("Enter
number
of
columns
");
scanf (" %d", &cols) i
/*Initialize
each
pointer
in
array
by
address
of
dynamically
allocated
memory*/
for(i=Oii<3;i++)
a[i]=(int
*)malloc(cols*sizeof(int)) i
for(i=Oji<3;i++)
for(j=Oij<colsij++)
(
printf ("Enter
value
for
a [%d] [%d]
scanf ("%d", &a [i] [j]);
}
printf ("The
matrix
is
: \n") i
for(i=Oii<3;i++)
{
for(j=Oij<colsij++)
printf ("%5d",
a [i] [j]) i
printf("\n") i
}
for(i=Oii<3ii++)
free(a[i])i
",i,j);
Suppose the number of columns entered is 4. This figure shows how to dynamically allocate a 2-D
array using array of pointers. In this case the rows may not ~e allocated consecutively.
1800
5000
5002
5004
1800 a[O]
2200 a[1]
2570
2570 a[2]1---"~OIJJ
If we want to enter both the number of rows and number of columns at run time, then we can dynamically
allocate the array of pointers also.
/*P8.33
Program
to
dynamically
allocate
a
2-D
array* /
#include<stdio.h>
tinclude<alloc.h>
main (
)
{

238
C in Depth
int
**a, i, j, rows, CQIs;
printf ("Enter
number
of
rows
and
columns
");
scanf("%d%dn,&rows,&cols) ;
/*Allocate
a
one
dimensional
array
of
int
pointers* /
a=(int
**)malloc(rows*sizeof(int*));
/*Allocate
a
one
dimensional
array
of
integers
for
each
row
pointer* /
for(i=O;i<rows;i++)
a[i]=(int
*lmalloc(cols*sizeof(int));
for(i=O;i<rows;i++)
for(j=O;j<cols;j++)
(
printf("Enter
a[%d] rid]
scanf("%dn,&a[i] [j]);
)
printf ("The
matrix
is
: \nn);
for(i=O;i<rows;i++)
for(j=O;j<cols;j++)
printf ("%Sd n , a [i] [j]);
printf("\nn) ;
for(i~O;i<rows;i++)
free(a[i));
free(a) ;
",i,j);
Suppose the number of rows entered is 3 and the number of columns entered is 4, then the figure for
~
above program would be like this-
a
5000
5002
5004
1800
2200
Here the rows are not contiguous, but we can access each .element with subscnpts. The size of any
row can be easily increased or decreased by realloc( ).
8.22
Pointers To Functions
The code of a function resides in memory hence every function has an address like all other variables

ers
239
e program. We can get the address ofa function by just writing the function's name without
theses.
r? .34
Program
to
ilfustrate
that
every
function
has
an
address·· and
how
=::::;
access
that
address*/
=~clude<stdio.h>
( )
'nt
funcI ( );
printf ("Address
of
function
main()
is
printf ("Address
.of
function
funcI ()
is
funcI();
/*Function
call
*/
cI ( )
printf("India
is
great\n");
tput:
Address of function maine ) is : 657
Address of function func 1( ). is : 691
India is great
.22.1
Declaring A Pointer To A Function
%u
\n", main} ;
%Ul \n", funcI) ;
'e have seen that functions have addresses, so we can have pointers that can contairi these addresses
hence point to them. The syntax for declaration of a pointer to a function is as-
return type (*ptr_name )(type1, type2,
);
.?or example-
float (*fp)( int );
char (*func_p)(float, char);
-ere fp is a pointer that can point to any function that returns a float value and accepts an int value
argl\ment. Similarly funcy is a pointer that can point to functions returning char and accepting float
d char as arguments.
-e can see that this declaration is somewhat similar to the declaration of a function, except that the
inter name is preceded by a * and is enclosed in parentheses. Use of * is obvious since we did this
mile declaring pointers to variables also, but why is the pointer name enclosed in parentheses. Let us
-emove the parentheses and see.
float *fp(int );
ow would you declare a function returning a pointer to float and taking an int value? Well exactly
.
the same manner as above. So in this declaration fp is declared to bela function rather than a pointer
d this happened because parentheses have higher precedence than * operator. This is the reason for
enclosing the pointer name inside
par~ntheses.
_ ow we have learnt how to declare a pointer to a function, the next step is to assign a function's address
·0 it.
float (*fp)(int , int );
float func( int , int );
/*Declaring a function pointer */
/*Declaring a function*/

240
C in Depth
fp = func;
I*Assign address of function func( ) to pointer fp*1
After th'e above assignment fp contains the address of function func( ). J;)eclaring a function is necessary
before using its address anywhere in the program because without d~claration the compiler will not
know about this function and will generate an error.
8.22.2
Calling A Function Through Function Pointer
Now let us see how to invoke a function using a function pointer.
r = func( a, b);
I*Calling function in usual way*1
r = (*fp)(a; b);
I*Calling function via function pointer *1
The effect and result of calling a function by its name or by a function pointer is exactly the same.
/ *P8 .35
Program
to
invoke
a
function
using function
pointer* /
#include<stdio.h>
main( )
{
float
float
(*fp) (int, float);
add(int,float) ,result;
fp=add;
/*Assi~n address
of
function
add()
to
pointer
fp*/
/ *Invoking
a
function
directly
using
function's
name* /.
result=add(5,6.6) ;
printf("%f\n~,result);
/ *Invokirig
a
function
indirectly
by
dereferencing
function
pointer* /
result=(*fp) (5,6.6);
printf("%f\n",result) ;
}
float. add(int
a, float
b)
{
return (a+b) ;
}
Output:
11.600000
11.600000
8.22.3
Passing a Function's Address as an Argument to Other Function
We can send the function's address as an argument to other function in the same way as we send other
arguments. To receive the function's address as an argument, a formal parameter of the appropriate
type should be declared. We can then invoke the function sent as an argument by dereferencing the
formal pointer variable. The following program will make this point clear.
/ *
P8. 36
Program
to
send
a
function's
address
as
an
argument
to
other
function
* /
#include<stdio.h>
main ( )
{

Pointers
void
func(char,void(*fp) (float));
void
funl(float);
printf ("Function
main ()
called\n");
func ( , a' , funl) ;
241
}
-aid
func(char
b,void
(*fp) (float)
/*Address
of
funl
stored
in
fp*/
printf ("Function
func ( )
(·*fp\ Is< _5);
/*Calling
'oid
funl(floC''::.
f)
printf ("Function
funl (
.I
called\n") ;
funl
indirectly
called· \n") ;
using
pointer*/
Output:
Function maine ) called
Function func( ) called
Function fun I( ) called
Here func( ) is a function which accepts two arguments, a char and a function pointer. This function
pointer can point to any function that accepts a float and returns nothing.
fun 1( ) is a function that accepts a float and returns nothing hence we can send its address as second
gument to the function func( ). The function maine ) calls function func( ) while the function func(
) calls function funIC ) indirectly using function pointer. Now we'll write the same program and this
time we'll send a pointer that contains the address of function fun I( ).
1*
P8.37. Program
to
pass
a
pointE;!r
containing
function's
address
as
an
argument*/
~include<stdio.h>
ain ( )
void
func(char,void
(*fp)(float);
void
funl (float) ;
void
(*p) (float);
p=funl;
printf ("Function
main (
called\n") ;
func('a',p);
}
-"oid
func(char
b,void
(*fp) (float»
{
/ *Value
of
p
stored
in
fp* /
printf ("Function
func ( )
(*fp) (8.5);
/*Calling
}
void
funl(float
f)
.
{
caJ,led\n") ;
funl
indirectly
using
pointer*/
printf ("Function
funl ()
called\n");
}
Output:
Function maine ) called

242
C in Depth
Function func( ) called
Function fun 1( ) called
8.22.4
Using Arrays Of Function Pointers
-All this stuff may look a bit c.onfusing and you may think why call a function using function pointeJ
when it can l-e easily called using its name. Well in many applications we don't know in advance whicl
function will be called. In that case we can take the addresses of different functions in an amy anc
.then call the appropriate function depending on some index number.
LeCus take a program and understand this concept. In this program we'll add, subtract, multiply OJ
divide two numbers depending on user's choice. For this of course we'll make four different functions
The addresses of these functions will be stored in an array of function pointers.
float add(float, int);
/*Dec1aration of functions */
float sub(float, int);
float mul(float,int);
float div(float, int);
float (*fp[4] )( float, int );
/*Declare an array of function pointers*/
fp[O] = add;
/*Assigning address to elements of the array of function pointer*/
fp[l]
= sub;
fp[2] = mul;
fp[3] = div;
Instead of the above assignment statements, we could have initialized the array
as~
float (*fp[] )(float , int ) ={'add, sub, mul, div };
Now we can see
that~
(*fp)[O]( a, b);
(*fp)[l]( a; b);
(*fp)[2]( a, b);
(*fp)[3]( a, b);
is equivalent to add(a, b);
is equivalent to sub(a, b);
is equivalent to mul(a, b);
is equivalent to div(a, b);
In the following program, the function select( ) is used to display menu options and to input user's
choice. Depending on the choice of user, corresponding function is
cal~ed.
/*P8.38
Program
to
understand
the
use
of
array
of
function
pointers*/
#include<stdio.h>
int
select (void) ;
float
add(float,int);
float
sub(float, int);
float
mul(float,int);
float
div(float,int);
main ( )
{
int
i,b;
float
a,r;

:r
h
d
,r
;.
_":>ointers
float
(*fp[
])(float,
int)={add,sub,mul,div};
while(l)
{
i=select (
);
if(i==5)
exit(l);
printf-( "Enter
a
float
and
a
integer
scanf ("%f
%d", &a, &b) ;
r= ( * fp [i -1] ) (a, b) ;
printf("Result
is
%f\n",r);
;
t
select (void)
int
choice;
printf("l.Add\n") ;
prirttf("2.Subtract\n") ;
printf("3.Multiply\n") ;
printf("4.Divide\n") ;
printf("5.Exit\n") ;
printf("Enter
your
choice
");
scanf("%d",&choice) ;
return
choice;
=::'oat
add (float
a, int
b)
return
a+b;
="loa't.
SuO\IJ.oat
a,lnt
D)
return
a-b;
=_oat
mul (float
a, int
b)
return
a*b;
oat
div(float a,int
b)
return
alb;
) ;
243
This ~rogra~ could be ,ritten using a ,switch b.ut wri,ting it using function pointers increase~ efficiency.
Funchon pomters are generally used m compilers, mterpreters and database programs.
Here is a review of the pointer declarations used in this chapter-
int *p;
/*Pointer to int */
int **p;
/*Pointer to pointer to int */
int *p[20];
/* Array of 20 int pointers*/
int (*p)[20];
/* Pointer to an array of 20 integers */
int *f(void);
!*Function that returns an int pointer*!

244
int (*fp)(void);
int (*fp[4] )(void);
int *(*fp)(void);
float *(*fp)(int, float);
float *(*fp[4] )(int, float);
C in Depth
/*Pointer to a function, function returns int */
/*An array of 4 pointers to functions, each function
return~
int:"1
/*Pointer to a function, function returns an int pointer */
/*Pointer to a function, function takes two arguments of in
and float type and returns a float pointer*1
/*An array of 4 pointers to functions, each function takes tW(
arguments of int and float type and returns a float pointer*
Exercise
\.
Assume stdio.h is included in all programs.
(l) main ( )
{
int
a=5, *ptr;
ptr=&a;
printf("Input
a
number
");
scanf("%d",ptr);
/*Suppose
the
input
number
is
16*/
printf ("%d
%d\n", a, *ptr) ;
(2) main (
{
int
*ptr;
printf ("Enter
a
number
:");
scanf("%d",ptr) ;
printf("%d\n",*ptr) ;
(3) main (
{
int
arr[5J,i;
for(i=0;i<5;i++)
printf("%u
".arr+i);
/*Suppose base address of arr is
5000*
printf("\nEnter
5
numbers\n");
for(i=0;i<5;i++)
scanf("%d",arr+i);
for(i=0;i<5;i++)
printf("%d
",*(arr+i));
(4) main(
{
int
i,arr[5]~{25,3L,.< ,40.45},*p;
p=&arr;
for(i=0;i<5;i++)
printf("%d\t%d\t".*(p+i) ,p[i]);
(5) main(

'h
tlS
nt
10
*/
'j
3 0 inters
int
i,arr[5]={25,30,35,40,45},*p;
p=&arr [4] ;
for(i=O;i<5;i++)
printf ("%d\t%d\t", * (p-i) ,p [-i]);
~ain(
_
int
i,arr[5]={25;30,35,40,55},*p;
for(i=O;i<5;i~+)
{
printf("%d
",*arr);
arr++;
(7) main (
{
int
i,arr[5]={25,30,35,40,45},*p=arr;
for(i=O;i<5;i++)
{
(*p)++;
printf("%d
",*p);
p++;
(8) main(
{
int
i,arr[5]={25,40,55,70,85},*p=arr;
for(i=O;i<5;i++)
printf("%d
",*P++);
printf("\n");
for(i=O;i<5;i++)
printf("%d
",*--p);
printf (" \n") ;
(9) main(
{
int
i,arr[5]={25,40,55,70,85},*p=arr;
for(i=O;i<8;i++)
printf("%d
",++*p);
printf("\n");
for(i=O;{~7;i++}
printf("%d
"
(*p)++);
printf("\n");
245

246
(10 )main ( )
{
. /
int
arr[10J={25,30,35,40,55,60,65,70,85,90},*p;
for(p=&arr[OJ ;p<arr+10;p++)
printf("%d
",*p);
(ll)main(
{
intar r [ 10 J = { 2 5 , 3 0 , 3 5 , 40 , 5 5 , 6 0 .~ 5 , 7 0 , 8 5 ,9 0 } .. *p ;
for (p=arr+2; p<arr+8; p=p+2) -
~
printf("%d
",*p);
J
(12)main(
{
int
i,arr[10J7{25,30,35,40,55,60,65,?O,85,90};
int
*p=arr+9;
for(i=O;i<lO;i++)
printf("%d
",*p--);
(13)main() .
{
int
arr[10J={25,30,35,40,55,60,65,70,85,90},*p;
for(p=arr+9;p>=arr;p- -)
printf ("%d
", *p
);
(14)main(
{
C in Depth
-
int
arr[4J={lO,20,30,40};/*Assume
base
address
of
arr
is
5000*
int
x=100,*ptr=arr;
printf("%u%d
%d\n",ptr,*ptr,x);
x=*ptr++;
printf("%u%d
%d\n",ptr,*ptr,x);
x=*++ptr;
printf ("%u %d
%d\n", ptr, *ptr, x) ;
x=++*ptr;
printf ("%u%d
%d\n" ,ptr, *ptr,x);
x=(*ptr)++;
printf("%u%d
%d\n",ptr,*ptr,x);
(15) main (
{
int
x,
arr[8J={ll,
22,
33,
44,
55,
66,
77,
88};
x
=
(arr+2)[3J;
printf ("%d\n",
x);

Pointers
_6)main( )
{
int
arr[8J={11,22,33,44,55,66,77,88};
int
*p, *q;
q=arr/2;
p=q*2;
printf ("
%d
%d", *p, *q) ;
17)main(
{
int
arr [6 J = {l, 2,3,4,5,6} ;
int
*p=arr;
printf ("Size
of
p
=' %u,
Size
of arr
18)main(
{
247
%u\n",sizeof(p) ,sizeof(arr);
float' a=5,*p,**pp;
p=&a;
/*Assume
address
of
a
is
5000*/"
pp=&p;
/*Assume
address
of
p
is
5520*/
printf ("a
%f,
p=
%u,
pp
%u\n",a,p,pp) ;
a=a+l;
p=p+l;
pp=pp+l;
printf ("a
%f,
p=
%u,
pp
%u\n",a,p,.pp);
(l9)int
a=5.,b=10;
main( )
{
int . x:", 2 0 ,*ptr=&x;
printf("%d
",*ptr);
changel(ptr) ;
printf("%d
",*ptr);
change2 (&ptr) ;
printf("%d\n",*ptr) ;
}
changel (int
*p)
{
p=&a;
}
change2(int
**pp)
{
*pp=&b;
(20)main(
{
int
a=2,b=6;

248
func(a,&b) ;
printf ("a
%d,
b
%d\n", a, b) ;
C in Depth
}
func (int
x, int
*y)
int
temp;
temp=x;
x=*y;
*y=temp;
(21) int
*ptr;
main ( )
{
func ( ) ;
printf("%d\n",*ptr);
}
func ( )
{
int
num=10;
ptr=&num;
(22) main (
{
int
a=5,b=8;
func (a, b) ;
printf ("a
%d
}
func (int
x,
int
y)
b
%d\n" , a, b) ;
int
temp;
temp=*(&x) ,*(&x)=*(&y) ,*(&y)=temp;
(23)main(
{
int
arr[ 5] = {I, 2,3,4,5};
int
*p=&arr;
printf("p
%u,\t",p);
func1(
pI;
printf("p
%u,\t",p);
func2 (&p);
printf("p
%u\n",p);
}
void
func1 (int
*ptr)
{
ptr++;
}
void
func2 (int
* *pptr
/*Assume
base
address
of
arr is
2000*/

Pointers
(*pptr)++;
(24)main(
{
int
arr[lO];
func(arr) ;
}
func(int
arlO])
{
intb[lO] ;
int
x"=5,y=4;
a=&x;
b=&y;
(25)main(
{
int
arr[3] [4];
/*Assume
base
address
of
arr
is
5000*/
printf("%u\t",arr) ;
printf("%u\t",arr[O]) ;
printf("%u\n" ,'&arr[O] [0]);
printf("%d\t",sizeof(arr)
;
printf("%d\t",sizeof(arr[~]»
;
printf ("%d\n", sizeof (arr[O] [0]»;
(26)main(
{
intarr[3] [4] [5];
/*Assume
base
address
of
arr
is
printf(:%u\t",arr) ;
printf("%u\t",arr[O]) ;
printf("%u\t",arr[O] [0]);
printf("%u\n",&arr[O] [0] [0]);
printf("%d\t",sizeoflarr»
;
printf("%d\t",sizeoflarr[O]»
;
printf ("%d\t", sizeof larr[O] [0]»;
printf("%d\n",sizeof(arr[O] [0] [0]»;
249
2000*/
(27) main (
{
int
arr[lO]
func(.arr+3);
}
func(int
a[
])
{
{1,2,3,4,5,6,7,8,9,10};
,int
i;
for(i=O;a[i] !=8;i++)
Drintfl"%d
",ali]);

250
(28) main ( Y
{
int
i, j ;
int
arr[lO]={3,2,4,1,5,9,8,lO,7,6};
for(i=O;i<lQ;i++)
for(j=O;j<lO-i-l;j++)
if(*(arr+j»*(arr+j+I))
swap(arr+j,arr+j+I);
for(i=O;i<lO;i++)
printf("%d\t-,arr[i]);
printf("\n") ;
}
swap(int
*b,int
*c)
{
int
temp;
temp=*b, *b=*c,*c=temp;
(29)main(
T
C in Depth
int
int
int
i,arr[3] [4]
*pa [ 3 ] ;
(*p)[4];
{{lO,1l,12,13}, {20,2I,22,23}, {30,3I,32,33}}:
p=arr;
for(i=O;i<3;i++)
pari]
arr[i];
printf("%d
%d
%d\n",pa[O][O],pa[O][l],pa[2][3]);
printf("%d
%0.
%d\n",p[O][O],P[O][l],P[2][3]);
(30) int
* funcI (void) ;
int
*func2 (void) ;
main ( )
{
}
int
int
*ptrI, *ptr2;
ptrI=funcI ( ) ;
ptr2=func2 ( ) ;
printf("%d
%d\n",*ptrI,*ptr2);
. ,
* funcI (void)
int
a=8,
*p=&a;
return
p;
int
* func2 (void)
*)malloc(sizeof(int)) ;
int
*p;
p=(int
*p=9;
return
p;
,

Pointers
(31)main( )
{
251
in t
i ,
a r r [ 3] [4]
{ {l 0 , 11 ,1 2 , 1 3 }, .{ 2 0 , 2 1 , 2 2 , 2 3 }, {3 0 , 3 1 , 3 2 , 3 3 } } ;
int
. *p=arr;
for(i=O;i<12;i++)
printf("%d
",p[i]);
printf ("\n
U );
Answers
(1)
16 16
(2)
ptr is not initialized, it contains garbage value and may be pointing anywhere in memory, ptr should
be initialized before being used.
(3)
5000 5002 5004 5006 500-8
Enter 5 numbers : 1 2 3 4 5
1 2 3 4 5
The first for loop prints the addresses of the array elements, second for loop inputs the numbers
in the array and the third for loop prints the array elements.
(4)
25
25
30
30
35
35
-
40
40
45
45
(5)
45
45
40.
40
35
35
. 30
30
25
25
(6)
Error, since arr is a constant pointer and it can't be changed.
(7)
2631'364146
By (*p)++ we are incrementing the value pointed to by p, and by p++ we are incrementing the
pointer.
(8)
25 40 55 70 85
85 70 55 40 25
(9)
2627282930313233
33 34 35 36 37 38 39
(10) 25 30 35 40 55 60 65 70 85 90
(11) 35 55 65
(12) 90 85 70 65 60 55 40 35 30 25
(13) 90 85 70 65 60 55 40 35 30 25
(14) 5000 10 100
5002 20 10
5004 30 30
5004 31 31
5004 32 31
(J 5) 66
(arr+2)[3] will be interpreted as *(arr+2+3) or as *(arr+5), which is same as arr[5].
(16) Error, since multiplication and division operations are not valid with pointers.
(17) Size of p = 2, Size of arr = 12
•
i
i

252
C in Depth
(18) a = 5.000000, p= 5000, pp = 5520
a = 6.000000, p= 5004, pp = 5522
(19) 20 20 10
Since we need' to change the value of ptr we have to send its address, and in the function we
have to receive address of a pointer so we need a pointer to pointer, hence 'the function change2(
) will be able to change. the value of ptr and changel( ) can't change the value of ptr .
(20) a = 2, b=2
Since the address of b is passed so its value changes, while the value of a does not change because
its value is passed.
(21) In this program we are assigning the address of a local variable num. When the function func(
) terminates, the variable num expires and the memory used by it may be used for some other
, purpose. This program may give 10 as the "Output, but the memory may be overwritten anytime.
(22) a = 5 b = 8
We are passing the values of variables a and b, so their values will not change. Writing *(&x)
is' same as writing x.
(23) p = 2000, P = 2000,
P = 2002
The reasoning is same as in question 19.
(24) Error, a = &x is OK since ais declared as a pointer variable, but b = &y not Ok because b is
name of an array, hence a constant pointer.
(25) 5000
5000
5000
24
8
2
(26) 2000
2000
2000
2000
120
40
10
2
(27) 4 '5 6 7
The address of arr[3] is passed to the function. Inside the function, a is declared as a pointer
variable and it gets initialized with the address of arr[3].
(28) 1 2 3 4 5 6 7 8 9 10
The numbers are sorted through bubble sort
(29) 10 1133
10 11 33
pa is an array of 3 pointers, each of base type int, while p is a pointer to an array of 4 integers.
(30) -20 9
It is wrong to return the address of a local variable, but the address of dynamically allocated memOf)'
can be returned.
(31) 10 11 12 13 20 21 22 23 30 31 32 33

Chapter 9
Strings'
~ ere is no separate data type for strings in C. They are treated as arrays of type char. A character
y is a st~~~if~ null5hara~ter(.:iQ' ). This null char~cter is-ari"escip~' sequence with'
_ CII value O. Strings are generaIJy used to store and manipulate data in text form like words or sentences.
.1
String Constant or String Literal
.
_ string constant is a sequence of characters enclosed in double quotes. It is sometimes called a literal.
e double quotes are not a part of the st~ing. Some examples 'of string constants are-
..
'V'
"Taj MahaI"
"2345"
"Subhash Chandra Bose was a great leader"
,,,, (Null string, contains only '\0')
"My age is %d and height is %f\n"
(Control string used in printf)
. nenever a string constant is written anywhere in a program, it is stored somewhere in metQory as
-
array of characters terminated by a nuU character(''\O'rThe string constant itself becomes a p~inter
_____-.
i
.•
.
'
the first character.in: the array. For example the. string "Taj MahaI" will be stored in memory as- .
1000
1001
1002
1003
10041005 1006
1007
1008
1009
a
J ·'_---1.-1_M--L.I_a--lL..-h
a
1 ---1....-\_0_
ch character occupies one byte and compiler automatically inserts the null character at the end. The
string constant "Taj MahaI" is actually a pointer to the character 'T'. So whenever a string constant
. used in the program it is replaced by a pointer pointing to the string.
we have a pointer ~ariable of t;pe char .*.~ the~r w~ 'c~n ~ssig~ the address of this string constant
.
~.r
'
10 It as-
-
\,
.
char *p-= "Taj maha!";
imilarly whim we write-
printf("Subhash Chandra Bose\n'.');
then actually a pointer to characteJ(char *.) is passed to the printf( ) functio,n.
If identical string constants are used in a program, they will be stored separately at different memory
\

2~,
C iii Depth
I
.
~.J
•
-
-
a r cUll
,.. ............... ::::::.r~t-p14
... .1
#include<stdio.h>
main ( )
{
printf(~%u\n",Rgood");
printf(R%u\n", Rgood"f;
if ("bad"
Rbad")
printf(RSame\n");
else
printf ("Not
same\n");.
";~Clont-'rn.-l
:;jLL.L.u'::::l
c:rnreu
}
Output
174
183
Not same
From the above output we can see that the twa strings "good" are identical but they are stored at different
places. When we compare two identical strings using equality operator then we are actually comparing
the addresses and'not the strings. (Later we'll study a library function strcmp() used to compare strings).
Can you guess what will the expression "software"[4] represent? According to the equivalence of pointer
and subscript notations, this expressi,on 'is equivalent to *("software"+4). We know fhat'''software''
represents the address of first character i.e. 's'. On adding 4 to this address we get the address of
character 'w', and on dereferncing it we gef the character 'w':" -'
.
~-
,
In some compilers we can change the string constant by storing its address in a pointer, but it is not
a good practice to'do so and 'the bel1aviour of such a program is undefined. So we should never attempt
to alter the string constants.
We have studied that a string constant gives the address of first character in it, but there is. an exception
to this rule; when the string constant is \lsed as an initializer for a character array then it does not represent
",
any address and it is not stored anywhere in memory. For example-
,
char arr[5] = "Deep";
Here the string constant "Deep" is not stored in memory and hence does not represent any address.
Note that the 'b' and "b" are different. 'b' is a character'constant which represents the ASCII value
,of character 'b' while "b" is a string constant which consists of character'b' and null character '\0'.
Inside a string constant, the backslash is considered as an escape character; so if there is a need to
include backslash, character within a string constant then it should be preceded by another backslash.
Ifwe want to include double qoutes inside string constant, then it should also be preceded by a backslash.
For example consider these two printf statements-
printf("good\\bad");.
printf("I love \"C\" programming");
.
,
.
The output of these 2 statements would be-

C" programming
of a string is not limited to a line only, it can be continued by adding a backslas;l at the
e line.
"
/
~ , g constants are placed adjacent to each other then the compiler concatenates them llnd places
_ e null character at the end of the; conactenated string. For example these two stri~g c-onstarits
concatenated by the compiler as-
ed ""Fort" ~ "Red Fort"
i
String Variables
.......,,·_...~e a string variable we need to declare a character array with sufficient size to hold all the characters
string'inCluding null character.
- ar str[ ] = {'N'
'e'
'w'
, , 'Y'
'0' 'r' 'k'
'\o'}·
,
,
,
,
,
,
"
,
also initialize it as-
ar str[ ] = "New York";
'tialization is same as the previous one and in this case the compiler automaticallY inserts the
acter at the end. Note that here the string constant does not represent an address. The array
be stored in memory as-
----,,-N:-::-,--1--::-:-:o-el~w~1~I
str[O]
str[l]
str[2]
str[3]
1000
1001
1002
1003
1004
1005
1006
1007
Y
I~o~Ir~1~kI
str[4]
str[5]
str[6]
str[7]
1008
\0 I
str[8]
we have not specified the size of the array, but if we specify it then we should take care that
__" should be .large enough to hold all the characters including the null character,
:?9,2
Program
to
print
characters
of
a
string
and
address
of
-'-3racter.
* /
=~clude<stdio.h>
( )
each
<0
char
str[
]="India"i
int
ii,
for(i~Oistr[i]!='\O' ii++)
{
,
printf ("Character
=
%c\ t" , str [i] ) i
printf("Address
= %u\n",&str[i])i
tput
Character = I
Character = n
Character = d
Character = i
Address = 1000
Address = 1001
Address = 1002
Address = 1003
-------.

char
str [ .j ="India";
char
*p;
p=str;
while(*pl='\'O')
{
/*P9.3
Program
to
print
the
address
and
characters
(")i'
the
string
usin_
pointer*/
#include<stdio.h>
main( )
/
.
{
256
Character = a
Address = 1004
arr[O]
arr[1]
---:--:71-:--1 n
I d
1000
1001
1002
1003
1004
C in Depth
printf ("Character
=
%c\ t" , *:p) ;
printf("Address=%u\n",p) ;
p++;
\
The output of this progluHl is same as that of previous program.
Here 'p' is pointer variable which holds the base address of array str[ ]. Incrementing this pointer b.
1 gives the address of next element of character array str[ ], so on incrementing and dereferencin
this pointer we can print all the elements of the string. This procedure is similar to that applied in oth
arrays, except that here the loop terininates when the character '\0' is encountered which signifies the
end of string.
There is a shortcut way for entering and printing strings, using %s specification in the control strin
,
. .
.
of printf( ) and scanf( ).
.
"
/ *P9 . 4
Program
to
input
and
output
a
string
variable
using
scanf (
) *
#include<stdio.h>
main( )
{
char
name [20] ;
printf("Enter
name
:")r
scanf("%s",name) ;
printf("
%s
",name);
printf ("
%s\n", "Srivastava");
lst run:
Enter a name: Dc:epali
Deepali Srivasta'J'
2nd run:
Enter a name: Suresh Kumar
/
•

Dth
Iring
.257
Lng
: by
:ing
ther
the
ring
Suresh
Srivastava
-:he printf( ) takes the base a~dress of string and continues to display the characters until it encounters
- e character '\0'.
'ben we enter the string using %s, the null character is automatically stored at the end of array. We
ven't used
& sigl} in the scanf( ) since the name of the array is itself address of the array. In the
d run when we entered a string with space we could not get the required result. This is becaus'e
scanf( ) stops reading as soon as it encounters a wh{tesp<l;.ce. So for entering string's ~;ith whitespaces
e can use th'e function gets( ). It stops reading only when it encounters a newline and replaces' this
ewline by the null character. We have another functio'n puts( ) which can'output' a string and replaces'
e nuli'character by a newline.
.
' ,
. . .
*P9.5
Program
t,-·
understand
the
use
of
gets()
and
puts( )*/
:~nclude<stdio h>
=ain( )
char
name[20];
printf("Enter
name,
");
gets (name) ;
prihtf ("E'ntered
name
is.
") ;
puts (name) ;
tput:
Enter name: Suresh Kumar
Entered name is : Suresh Kumar
.3
String Liarary F••cti••s
ere are several library functions used to manipulate strings. The prototypes for these functions are
header file string.h. 'We'll discuss some Qf them below-
.
'
,,'
) * I
3.1
strlen( )
-:his function returns the length of the string i.e. the number of characters' in the string excluding the
:.mninating null character. It accepts a single argument, which is pointe~ t,o the first character of the'
5:ring. For example strlen("suresh") returns the value 6. Similarly if s1 is an array that contains the
e "deepuli" then strlen(s1) returns the value 7 .
xp9.6
Program
to
understand
the
work
of
strlen ()
function* /,
=~nclude<stdio.h>
=~nclude<string.h~
=.ain ( )
char
str[20];
int
length;
printf ("Enter
the
string: \n") ;
scanf ("%s", str) ;
,
length=strlen(str) ;
printf ("Length
of' the
string
is
. %d\~", leng,·th) ;
\
\,

258
}
Output:
Enter the string : CinDepth
Length of the string is : 8
Creation Of This Function
Array version~ .
int
~strlen(char
str [
])
int
i=O;
while (st'r[i] !='\O')
i++;
return
i;
Pointer version-
int
pstrlen (char
*str)
{
.
cha"r
*start=str;
while(~§~~!=;\O')
str++;
return
(str-start);
We can also write the while condition as-
while(*str)
because the ASCII value of '\0' is 0 which is considered false in C.
.~
C in Depth
9.3.2
strcmp( )
This function is used for comparison of two strings. If the two strings mat~h,
strcnip(~) ret1.!rns
value 0, otherwise it returns a non-zero value This function compares the strings character by charact
The comparison stops when either the end of string is reached or the corresponding characters in t
two strings are not same. The non-zero value returned on mismatch is the difference of the ASCII vah
of the non-matching characters of the two strings-
strcmp( s1, s2.) returns a value-
< 0 when s1 < s2
= 6 when si '= = . s2
> 0 when sl > s2
Generally we don't use the exact non-zero value returned in case of mismatch. We only need to 1m
its sign to compare the alphabetical positions of the two strings. We can use this function to sort
strings alphabetically.
"
/*P9.]
Program
to
understand
the
work
of
strcmp()
function*/
#include<stdio.h>
#include<string.h>
main ( )
{

pth
259
char
strl [10], str2 [10];
printf ("Enter
the
first
string
") ;
scanf("%s",strl);
printf ("Enter
the
second
string
:");
scanf("%s",str2);
':'f«strcrnp(strl:str2) )==0)
printf ("Stririgs
c:.~e' sarne\n");
else
printf ("Strings
are
not
sarne\n");
nt:
Enter the first string : Bangalore
Enter the second string : Mangalore
Strings are not same
Creation of this function
y version-
-=-=
astrcrnp (char
strl [
], char
str2 [
])
int
i=Oj
while (strl [i] ! =' \ 0' &&str2 [i] ! =' \ 0' &&strl [i] == str2 [i] )
i++;
if(strl[i]==str2[i])
return' 0;
else
return(strl[i]-str2[i]) ;
IS a
:ter.
the
ues
ter version-
-=-:::
pstrcrnp(char
*strl,char
*str2)
while(*strl!='\0'&&*str2!='\0'&&*strl==*str2)
,{
strl++;
str2++;
}
if(*strl==*str2)
return
0;
else
return(*strl-*str2);
lOW
the
.3.3
strcpy( )
~ . function is used for copying one string to another string. strcpy( strl, str2 ) copies str2 to strl.
ere str2 is the source string and strl is destination string. If str2 = "sutesh" then this function copies
resh" into strl. This function takes pointers to two strings as arguments and returns the pointer
first string.
"
./

260
C in Depth
/ *
P9. 8
Program
to
understand
the
work
of
st:::-cpy ()
function* /
#include<stdio.h>
#include<string.h>
maine )
{
char
strl [10], str2 [10];
printf ("Enter
the
first
string
."
);
.scanf("%s",str1);
\t\t
Second
string
\t\t
Second
string
printf ("Enter
tne
second
scanf("%s",str2) ;
strcpy(str1,str2);
printf ("First
string
; %s
strcpy(str1,"Delhi");
strcpy(str2,"Calcutta");
printf ("First
string
: %s
string
. "
) ;
%s\n",str1,str2);
%s\n",str1,str2) ;
}
Output:
Enter the first string : Bombay
Enter the second string : Mumbai .
,/
First string : Mumbai~econd string : Mumbai
First string : Delhi
Second string : Calcutta
The programmer should take care that the first string has enough space to hold the second string.
The function calls like strcpy("New", strl) or strcpy("New", "York") are invalid because "New" is a
string constant which is stored in read only memory and so we can't overwrite it.
strcpy("New", strl);
/*Invalid*/
strcpy("New", "York");
/*Invalid*/
Creation of this Function
Array version-
char
·*'astrcpy (char
strl [
], char
str2 [
])
r
i
,l-
·i=O;
\<T':_le(str2[i] !='\O')
str1 [i] =str2 [i] ;
i++;
}
str1[i]='\0' ;
return
str,l;
/ *Copy
character
by
character*.j
Pointer version-
char
*pstrcpy(char
*str1,char
*str2)
while(*str2!='\0')
{
*str1=*str2;

7th
261
strl++;
str2++;
-t:rl='\O' ;
=eturl'l. strl;
write the above function cone ':>ely as-
*pstrcpy(char· *strl,char
*strl)
- -' i 1 e ( * s t r 2 ++
* s t r 1 + + ) ;
return
s.trl;
"strcat( )
ction is used for concatenation of two strings. If first string is "King" and second string is
then after using this function the first string becomes "Kingsize".
srrcat(strl, str2);
/*concatenates str2 at the end of strl */
null character from the first string is removeq, and the second, string is added at the end of first
The second string remains unaffected.
function ,takes pointer to two strings as arguments and returns a pointer to the first(concatenated)
s a
-=-=.9
Program
to
understand
=~=:ude<stdio.h>
=-== ude<string.h>
--- ( )
the
work
of
strcat ( )
function.*/
har
strl[20],str2[20];
printf ("Enter
the
first
string
") ;
scanf("%s",strl);
,
printf ("Enter
the
second
string
") ;
scanf("%s",str2) ;
strcatlstrl,str2); .
printt'( "First
string
%s
\ tSecond
string
%s\n", strl, str2) ;
strcat(strl, "_one") j
printf ("Now
first
string
is
%s
\n", strl) ;
ut:
r the first string : data
the second string : base
t string : database
Second string : base
_- w first string is
: database_one
reation of this function
_"
ay version-
=b.ar
*astrcat(char
strl[
),char
str2[
])
int
i=O,j=O;

/ *Check
for
the
end
of
first
string* /
262
C in Deptf.
while(strl[i] !='\O')
i++;
while(str2[j]!='\0')
/*Add
second
string
at
the
end
of
first*/
{
strl[i]=str2[j] ;
i++;
j ++;
}
str1[i]='\0' ;
return' str1;
Pointer version-
char
*pstrcat(char
*str1,char
*str2)
whi1e(*str1!='\O')
str1++;
while(*str2!='\O')
{
*str1=*str2;
str1++;
str2++;
*str1='\0' ;
return
str1;
}
The function strcat( ) returns a pointer to the first string, hence it can be nested. The following progra
illustrates this-
/ *P9. 10
Program
to
understand
the
work
of
strcat ( )
#inc1ude<stdio.h>
#include<string.h>
main( )
(
char
str1 [20] ="Subhash
";
char
str2 [10] = "Chandra
";
strcat(strcat(str1,str2) ,"Bose");
printf("str1
%s\n",str1);
function.*/
}
Output:
strl - Subhash
Chandra
Bose
Other string related functions are explained in' the chapter on library functions.
9.4
String Pointers
We can take a char pointer and initialize it with a string constant. For example-
char *ptr = "Chennai";
Here ptris a char pointer which points to the first character of the string constant "Chennai" i.e.
contains ,The base address of this string constant.

!epth
uing
263
scanf("%s",
:;~r);
. ow we'll compare the strings defined as arrays and strings defined as pointers.
char str[] = "Mumbai";
.
.
char *ptr ,= "Chennai"; _ '
ese two fo~ms may look similar but there are some differences in them. The initialization itself has
erent meaning in both forms. In the array form, initialization is a short form for-
char str[] = {'M', 'u', 'In', 'b', 'a', 'i', '\O'}; .
ile in pointer form, address of string constant is assigned to the pointer variable.
. ow let us see how they are represented in memory.
1000
100I
1002
1003
1004
1005
1006
I M I u I m
I· b
I a I
1 I \0 I
str[O]
str[l]
str[2]
str[3]
str[4]
str[5]
str[6]
.:.
ere str is an array of characters and 7 bytes are reserved for it. Since str is the name of an array
"nee it is a constant pointer which will always point to the first element of array. The elements of
~y are initialized with the characters of the string. Note that we had mentioned before that when'
~ram
_ tring constant appears as array initializer, then it does not return an
addre~s. '
,
the second cast:, the string constant "Chennai" is stored somewhere in memory with 8 consecutive
es reserved fOf it. The string constant returns the address of the first character of the string that
"- assigned to the pointer variable ptr. So in this case total 10 bytes are reserved, 2 bytes for the pointer
.
table and 8 bytes for the string.
'
e main difference is that str is a constant pointer and will always contain address 1000 while ptr
-- a pointer variable and may contain any other address. So string assignments are valid for pointers
'bile they are invalid for strings defined as arrays.
str = "Bombay";
/*Invalid*/·
ptr = "Delhi";
/*Valid*/
e can assign string of any length to ptr. That string constant will be stored somewhere and its address
rill be assigned to ptr.
e can assign a different string to str by scanf ( ), strcpy or by assigning characters.
ptr
strcpy(str, "Bombay");. "
'"

264
or
C in Depth
",
str[O] = 'B';
str[l] = '0';
str[~J = om'; str[1) = 'b'; str[4j = 'a'; str[tT = 'y'; str[tJ = '\0';
This will write the new string at the address 1000, but take care that string size does not exceed the
size of array.
.
We have studied earlier that string constants are stored in read only area by some compilers and so
they can't be change.d. So these operations are invalid-
char *ptr = "Bareilly";
ptr[O] = 'D';
/*Invalid*/
scanf("%d", ptr);
..
/*Invalid*/
strcpy(ptr, "Bareilly");
-/*Invalid*/
We can't use scanf( ) with uninitialized pointer since it CJntain garbage value-
char *ptr;
scanf("%d", ptr);
/*Invalid*/
For this first we should allocate memQry through malloc( ), and let this pointer point to that region
of memory.
ptr = (char *)malloc(20);
scanf("%s", ptr);
/*Valid*/
/*P9.11*/
#include<stdio.h>
maine )
{
char
*str;
str~(char
*)malloc(lO);
printf ("Enter
a
string
") ;
scanf("%s",str) ;
printf ("String
is
%s\n", str);
}
Output:
Enter a string : Oxford
String is : Oxford
9.5
Array Of Strings Or Two Dimensional Array Of Characters
Strings are character arrays so array of strings means array of character type arrays i.e. a two dimensiona
array of characters.
Suppose we declare and initialize a two-dimensional array of characters as-
char
arr [ 5] [10]
{
"white",
"red"
I
"green
ll
I

'.,
o
'ng
"yellow" ,
"blue"
} ;
initialization is equivalent to
=-ar
arr(5] (10]
{
{'w', 'h', 'i',t, 'e', '\O'},
{'r','e/,'d/,'\D'},
{'gi, 'r', 'e'
I 'e'
I 'ni, '\O'},
{'y', 'e' 1'1' 1'1', '0', 'Wi I'\O'},
{ \ b-"'
I
\ 1
I
,
\ U
I
,
\ e'
I
I
\ 0
I
}
} ;
265
represents Olh string , points to Olb character of Olh string
represents 151 string,
points to Olh character of 151
string
represents ilh string,
points to Olh character of ilh string
represents jlh character in ilh string
n
ere first subscript of array denotes number of strings in the array and second subscript denotes the
imum length that each string can have. The space reserved for this two-d array is 50 bytes.
ere the name of 2-D array is arr and it gives the base address of the array i.e. it gives the address
first string.
arr[O]
arr[ 1]
arr[i]
arr[i][j]
-
we see that if we want to access individual characters in the string then we use two subscripts
d if we want to access the strings we use a single subscript.
2000
2010
2020
2030·
2040
w
h
1
t
e
\0
r
e
d
\0
g
r
e
e
n
\0
y
e
1
1
0
w
\0
b
1
u
e
\0
2009
2019
2029
2039
2049
's is the internal storage representation of array of strings. 2000 is the base address of the first string.
imilarly, 2010 is the base address of the second string. Here 10 bytes are reserved in memory for
h string. We can see that first string takes only 6 bytes, so 4 bytes are wasted. Similarly 2nd string
es only 4 bytes and 6 bytes are wasted. The total number of bytes occupied by the array is 50 while
- e strings use only 28 bytes so 22 bytes of memory is wasted. Now we'll see through a program
w to print these strings.
*P9.12
Program
to
print
the
strings
of
the
two-dimensional 'character
J
array* /
:include<stdio.h>
:define
N
5
:
efine
LEN
10
:::ain( )
char
arr(N] (LEN]={
\\white ll
,

266
. "red",
"green ll
I
"yellow" ,
"blue"
int
i;
for(i=O;i<N;i++)
{
C in Depth
printf
printf
}
Output:
String = white
String = red
String = green
String = yellow
String = blue
("String
=
%s\t",arr[i)
);
("Address
of
string
=
%u \n",
arr [
i));
Address of string = 2000
Address of string = 20I0
Address of string = 2020
Address of string...= 2030 .
Address of string = 2040
."
In the above program we have initialized the 2-D array with strings: Suppose we don't initialize it at
the time of declaration and try to assign strings to it afterwards like this-
arr[O] = "white";
/*Invalid*/
arr[ 1] = "red";
/*Invalid*/
This will give an error 'lvalue required'. Similarly we cannot write
air[O] = arr[ 1];
/*Invalid*/
If we want to assign values to strings we'll have to use strcpy( ) or scanf( ) function.
strcpy( arr[O], "white");
/*Valid*/
<.
scanf'( %s", arr[O]);
/*Valid*/
strcpy(arr[O], arr[l]);
/*Valid*/
Now we'll take a program to sort the stri~gs alphabetically using the selection sort technique.
I*P9.13
Program
to
#inc1ude<stdio.h>
#define
N
5
#define
LEN
10
main ()
(
sort
the
array
of
strings *I
'"
char
arr[N) [LEN)={
"white",
"red"
I
"green ll
,
"yellow" ,
"blue"
} ;
char
temp[10);
int
i,j;

pth
g
printf ("Before
sorting
: \n") ;
for(i=O;i<N;i++)
printf
("%s
arr[i]);
printf("\n");
for(i=O;i<N;i++)
for(j=i+l;j<N;j++)
if (strcmp(ar::-[i] ,arr[j]»O)
{
strcpy(temp,arr[i]);
strcpi(arrti] ,arr[j]);
strcpy(ar.rU]" temp)
}
printf (~'After . sorting
: \n") ;
for(i=O;i<N;i++)
printf
("%s
",arr[i]);
ut:
~efore
sorting
267
white
red
green
yellow
blue
: at
-
er sorting :
blue
greeQ
red_
white
yellow
e internal representation of strings after sorting is-
2000
2010
2020
2030
2040
b
I
u
e
\0
g
r
e
e
n
\0
r
e
d \0
w
h
1
t e
\0
y
e
I
I
0
w
\0
2009
2019
2029
2039
2049
Internal representation after sorting
ere the sorting is not considered very efficient since each time the whole string is being copied.
.6
Array Of Pointers To Strings
, e have already studied about array of pointers. Array of pointers to strings is an array ofchar pointers
which each pointer points to the first character of a 'String i.e. each element of this array contains
e base address of a string. Let us take an example and see how this array can be declared and initialized.
char
*arrp [
] = {
"white"
I
"red
Jl
,
"green"
I
"yellow" ,
"blue"
}
ere arrp is an array ofpQinters to strings. We have not specified the size ot a:<dY, so the size is determined

268
C in Depth
by the number of initializers. The initializers are string constants. arrp[O] contains the base address 0
string "white", similarly arrp[l] contains the base address of string "red".
Now let us see how these strings are stored in memory-
IOn
100~
2000
arrp[O]
100 ..
arrp[l]
+06 .
arrp[2]
B,O..·..
arrp[3] , 116 ..
....+23- ·
arrp[4]
L-._
.....
String : white
String: red
String: green
String : yellow
String : blue
Address of string : 100
Address of string : 106
Address of string : 110
Address of string : 116
Address of string : 123
Address of string is stored at : 2000
Address of string is stored' at : 2002
Address of string is stored at : 2004
Address of string is stored at : 2006
Address of string is stored at : 2008
'.",
Here all strings occupy 28 bytes and 10 bytes are occupied by the array of pointers. So the ..total byte:
occupied are 38 bytes. In two-dimensional array, total bytes occupied were 50 bytes for these sam
strings. So we can see here saving of 12 bytes.
In the figure we see that strings are stored in consecutive memory locations. Well it is not necessaI')
they may not be stored consecutively and pointers may point to strings located anywhere. Now let u
take a program and see how to print these strings.
/*P9.14
Program
to
print
the
address
and
string
using
array
of
pointer
to. strings* /
#include<stdio.h>
main( )
{
int
i;
char
*arrp [
] = {
"white",
"red"
I
"green"
I
"yellow" ,
"blue"
} ;

)epth
g
269
:sso
for(i=O;i<5;i++)
{
printf
("String
prin~f
-("Addre~s
printf ("Address
%s \ t " , a r rp [ i ]
);
of
string
%u\t" ,arrp[i]
);
of
string
is
stored
at
%u \n", arrp+i
) ;
tput:
String: white
String: red
String: green
String: yellow
String: blue
Address of string : 100
Address of string : 106
Address of string : 110
Address of string : 116
Address of string : 123
Address of string is stored at : 2000
Address of string is stored at : 2002
Address of string is stored at : 2004
Address of string is stored at : 2006
Address of string is stored at : 2008
ead of initializing we could have assigned strings after declaration as-
arrp[O] = "white";
/*Valid*/
arrp[ 1] = "red";
/*Valid*/
ember this type of assignment was invalid when we used 2-D array. Here it is valid because arrp[O]
- a pointer variable and it can be assigned address of any string.
_-ow let us compare array of strings and array ofpointers to strings. Earlier we had studied the differences
tween strings declared as .pointers and strings declared as arrays. 'Here also we have same differences
t are illustrated by this program.
arr[O]="January";
arrp[O]="January";
/*Invalid*/
/*Valid*/
strings
and
between
array
of
show
the
differences
to
strings* /
arr[5] [lO];
*arrp"[5];
char
char
,; P9 . 15
Program
to
array
of
pointers
:"nc1ude<stdio.h>
ain ( )
>ytes
;ame
sary,
~t us
:ers
strcpy(arr[l] , "February");
strcpy!arrp[l] ,"February");
/*Valid*/
/*Invalid,
arrp[l]
not
initialized*/
scan f ( "% s" , a r r [ 2] Y;
scanf("%s",arrp[2]
);
/*Valid*/
/*Invalid,
arrp[2]
not
initialized*/.
arrp[3]=(char
*)mal1oc(10);
strcpy(arrp[3] ,"March");
/*Valid*/
arrp[4]=(char
*)malloc(lO);
scanf("%s",arrp[4]
);
/*Valid*/
}
We have seen that we can't input strings direct'ly in an array of pointers using scanf( ). We have to

270
C in Depth
first allocate memory through malloc( ). Here is a program in which we first enter the string and then
allocate memory required for that string. This allocated memory is pointed by an element of array of
pointers.
/*P9.16*/
#include<stdio.h>
#include<string.h>
main ( )
{
char
*arrp[lOJ,str[20J;
int
i;
for(i=O;i<lO;i++)
{
printf ("Enter
string
%d
", i+l) ;
gets(str);
/ *
Now
allocate
memory
sufficient
to
hold
the
string* /
arrp[iJ=(char
*)malloc(strlen(str)+l);
strcpy(arrp[iJ ,str);
}
for(i=O;i<lO;i++)
printf("%s\t", *(arrp+i));
printf("\n") ;
for(i=O;i<lO;i~+)
free(arrp[i]) ;
If we want to enter the number of strings at run time, then we can allocate the array of pointers
dynamically as we had done in previous chapter program P8.33.
Array of pointers is also useful in grouping together logically related data items. For example we can
take the names of months in an array and then access them by appropriate subscript.
/*P9.17
Program
to
input
a
date
and
print
,the
month*/
#include<stdio.h>
main ( )
{
int
d,m,y;
char
*months [] = { "January",
"February",
"June"
I
\\July",
"August",
"Nove~ber", "December"};
printf ("Enter
date
(dd/mm/yy)
") ;
scanf("%d/%d/%d",&d,&m.&y) ;
printf("Month
%s\n",months[m-l]);
"March",
\\April",
"MayJl,
"September",
"October",
}
Output:
Enter date: 2/5/2002
Month: May
We cO,uld do this by switch statement also but using array of pointers makes the stuff concise.
The next program sorts the strings represented by array of pointers using selection sort techniqUl

,th
271
len
of
____
Program
to
-=.=::'_de<stdio.h>
-
-::~e
N
5
- -
)
sort
strings
represented
by
array
of
pointers*/
_=-ar
*arrp[N]={
"white", "red", "green", "yellow", "blue"
}i
-
i, j i
_~ ar
*tempi
::-:::-intf ("Before
sorting
\n") ;
:: r(i=Oii<N;i++)
_ :::-' nt f ( "% s \ t" , arrp [i] ) ;
:;;=intf("\n");
-
r(i=O;i<N;i++)
-
r(j=i+lij<Nij++)
if(strcmp(arrp[i] ,arrp[jl»O)
{
temp=arrp[i] ;
arrp [i] =arrp [j L
arrp[j]=tempi
}
_rintf ("After
sorting
: \n") i
::or(i=Oii<Nii++)
_rintf("%s\t",arrp[i]) ;
_rintf("\n");
ers
ut:
white
yellow
;an
sorting -
hite
red
sorting -
blue
green
green
red
yellow
blue
2002
arrp[O]
+23- .
arrp[l]
11(}.,..-+-+--+-....,
arrp[2]
+06 ·
arrp[3] ·..·+00 +
..· ----If----J
....+16 :+--+--'
arrp[4] L------J
---~.~
ue.

272
C in De
Here sorting is efficient since only pointers are being exchanged.
9.7
sprintf( )
to
strings
usi
/ *P9 . 19
Program
to' convert
sprintf ()
function* /
#include<stdio.h>
main ( )
{
Declaration:
int sprintf (char *str, const char *controlstring [, argument!, argument2, ,.........] );
This function is same as printf ( ) fu~ction except that instead of sending the formatted output to
screen, it stores the formatted 'output'in a\tring. So with the '~elp of this function we can conv
variables of any data type to string.' A null cnaracter is.appendecYiit the end automatically. This functi
returns the number of characters output to the string excluding thenull character. It is theresponsibil
of the programmer to take the size of string "farge, enough to ~tore all the argumentS1so that....no overfl
occurs.
In the following program we convert integer and float values to strings using sprintf.
integer
and
float
va/lues
char
str1[10j;
char
str2 [10];
int
x=1348;
float
y=234',56;
sprintf(str1,"%d H ,x) ;
sprintf(str2,"1.2~·,y) ;
printf("str1
%s,str2
=
%s\n
H ,str1,str2);
}
Output:
strl
1348, str2 = 234.56
"'1
/ *P9. 20
Program
to
understand
the
use
of
sprintf ()
function* /
#include<stdio.h>
main ( )
{
char
str[30];
char
name[10]="Suresh
H
;
int
m1=89,m2=78,m3=80;
float
per=(m1+m2+m3)/3.0;
char
gr= 'A' ;
sprintf(str,"Result
%s
%d
%d
%d
If
%c\n
H ,name,m1,m2,m3,per,g
printf ("The
string
is
: \n H
)
;
puts(str) ;
}
Output:
The string is-
Result - Suresh 89 78 !SO 82.333336 A

)ep
sscanf( )
273
-= .21
Program
to
convert
strings
to
integer
aJld
float
values* /
=-==_ude<stdio.h>
--- ( )
t sscanf (const char *str, const char *controlstring [, address1, address2,
D;
ction is same as the scanf ( ) function except that data is read from a string rather than the
d input. We can read the formatted text from a string and convert it into variables of different
es. In the following program, we have two strings that are converted to integer and float values
to tI:
~ sscanf( ).
)nve-
nctic
,ibm
erflo
ha r
s t r 1 [ 1 0 ] = " 13 4 8 " ;
har
str2 [10·] ="234.56";
int
x; (
:: oat
y;
sscanf(strl,"%d",&x);
sscanf (s tr2 , "% f" , &y) ;
_ rintf ("Valu'e 'of
x
=
%d,
Value
of
y
ut:
Value of x = 1348, Value of y = 234.56
%.2f\n" ,x,y);
gr)
.::- .22
Program
to
understand
the
use
of
sscanf ()
function* /
~~ ude<stdio.h>
( )
struct{
char
name [10] ;
int
age;
float
sal;
}emp;
char
str[30]="Anita
238000.0";
sscanf(str,"%s%d%f"$emp.name,&emp.age,&emp.sal) ;
printf ("liame
%s \n" , emp. name) ;
printf("Age
%d\n",emp.age);
printf("Salary
%.2f\n",emp.sal);
tput:
Name
: Anita
Age
: 23
Salary
: 8000.00
nf( ) can be used for validating input data. We know how to' put simple validity ched.s on data
h as whether it is in specified range or not, but what if the user starts entering a string where an
eger is required. This type of error is difficult to detect and correct. Here we can use sscanf( ) to
eck whether a valid integer: value is entered or not. For this we take the input in a string instead
an integer variable and then check each character of that string , and if any character in the string

274
C in Depth
-',
, ':,
is other than a digit , '+' or
'~', then we can print the message that input is not a valid integer. If
all the characters input in the string are valid then we can convert that string to an integer variable with
the help of sscanf( ) and then use that integer variable in our program.
9.9
Some Additional Problems
Problem 1
Write a program to test whether a word is palindrome or not. A palindrome is a word that remains the
same when reversed. For example - radar, madam
/*P9.23
Program
to
test
whether
a
word
is
palindrome
or
not*/
#include<stdio.h>
#include<string.h>
main( )
{
char
str[lO];
int
i=O,j,flag;
printf ("Enter
the
word
") ;
scanf("%s",str) ;
,j=strlen(str)-l;
while (i<=j )
{
if(str[i]==str[j])
flag=l;
else
flag=O;
break;
i++;
j - -;
}
if (flag==l)
printf ("Word
is
palindrome\n"
);
else
printf ("Word
is
not
palindrome\n"
);
}
Problem 2
\yrite a program to convert a lowercase string into uppercase.
/*P9.24*/
.
#include<stdio.h>
main( )
{
char
str[lO];
int
i=O;
printf ("Enter
a
string
in
lowercase
") ;
scanf ("%s", str) ;
while(str[i] !='\O')

'Pth
r. If
Nith
275
str[i]=str[i]-32;
i++;
, the
_ rintf ("The
uppercase
string
is
~."",,"U.lem 3
%s\n",str);
a program to enter any string and print it in reverse order.
:;.25
Program
to
enter
any
string
and
print
it
in
reverse
order. * /
-=-: de<stdio.h>
-
)
ar
str[20];
_
t
len;
_rintf ("Enter
any
scanf("%s",str) ;
en=strlen(str)-l;
. hile(len>=O)
t
string
") ;
printf("%c",str[len]);
len- -;
em 4
a program to accept any line and count the number of words in it. ,
=-J.26*/
~_:ude<stdio.h>
- ( )
char
line[lOO];
int
count=O, i=O;
printf ("Enter
the
line
of
text
") ;
gets (line) ;
while(line[i] !='\O')
{
if(line[i]==32)
count++;
i++;
}
if(line[i]=='\O')
count++;
printf ("The
number
of
words
in
line
=
%d\n",
count);
a program to input two strings consisting of maximum 80 characters. Examine both the strings

276
C in De)
".
~
•
'i
and remove all the common characters from both of these strings. Display the resultant string.
/*P9.27*/
#include<stdio.h>
main( )
{
char
strl [80], str2 [80], str3 [8'0], str4 [80];
int
i,j,k,fiag;
printf ("Enter
the
first
string
") ;
scanf ("%s", strl) ;
printf ("Enter
the
second
string
") ;
scanf ("%s", str2) ;
k=O;
for(i=O;i<strlen(strl);i++)
{
flag=O;
,
for(j=0;j<str1en(str2);j++)
{
if(str1[i]==str2[j])
{
flag=l;
break;
}
if (flag! =1)
{
str3 [k] =strl [i] ;
k++;
}
str3[k]='\0';
k=O;
for(i=0;i<str1~n(str2);i++)
{
f1ag=0;
for(j=O;j<strlen(strl);j++)
{
if(str2[i]==strl[j])
{
flag=l;
break;
}
if(flag!=l)
{
str4 [k] =str2 [i] ;
k++;
}
str4[k]='\0' ;

pth
g
printf ("The
printf ("The
first
string
is
second
string
is
%s\n",str3);
%s\n", str4);
277
\
- e a program to read in a string and output the frequency, of each character, in that string.
P9.28
*/
__clude<stdio.h>
="n ( )
char
str[lO],ch;
int
i,j,n,count;
printf ("Enter
a
string
") ;
scanf("%s",str) ;
n=strlen(str) ;
for(i=O;i<n;i++)
{
ch=str[i] ;
if (ch ! ='
'-)
{
count=O;
for(j=O;j<n;j++)
{
if (ch==str [j])
{
count++;
str[j]='
';
}
printf ("%c
occurs
%d
times\n", ch, count·) ;
e a program to enter a 4 digit number and display it in words.
_9.29*/
=~clude<stdio.h>
( )
int
n,num,d=O,dig[4];
char
*ones [
] = {"",
"One",
"Two",
"Seven",
"Eight",
"Three",
"Four",
"Nine",
\\Ten ll
};
"Five"
I
\\Six ll
I
char
*el [
] = {
"Ten",
"Eleven",
"Twelve",
"Thirteen",
"Fourteen",
"Fifteen",
"Six.teen",
"Seventeen",
"Eighteen",
"Nineteen"
};

278
char
*tens [
] = {
"Seventy" ,
printf ("Enter
a
4
digit
scanf("%d",&num) ;
n=num;
do
dig[d]=n%lO;
n/=lQ;
d++;
}while(n>O);
"Twentyil
I
\\Thirt'1
11
t
"Eighty",
"Ninety"
number
");
\'Fortylt
I
} ;
"Fifty",
C in-De
"Sixt:
if(d==4)
printf ("%s
Thousand", O,:les [dJ.g [3] J);
if(d>=3&&dig[2) !=O)
printf("
%s
Hundred
",ones dig[2Jl);
if(d>=2)
{
if
(dig[l]==O)
printf("%s\~",ones[dig[OJJ);
else
if(dig[l]==l)
printf("%s\n",el[dig[O] j);
else·
printf("%s
%s\n",tens[digll]J,ones[dig[OJ));-
}
if (d==1
& &
n urn ! =0 )
printf ("%s\n", ones [dig [OJ j);
if (num==O)
Printf("Zero\n")
,.
\
Probiem 8
Write a function that converts a string to an integer(string contains integer in decimal number syst
/*P9.30*/
#include<stdio.h>
#include<string.h>
main( )
{
char -str[20];
printf ('~Enter
a
number
") ;
scanf("%s",str) ;
printf("%d\n",str_to_i(str));
}
int
str_to_i (char
str [j )
int
i,num=O;
if (str[ 0 1== '- ' )
- i=l;
else
i=O;

Dep
Kty
;tern
g
while(i<strlen(str) )
num=nurn*10+(str[i++]-48);
:.r(str[O]=='-')
return
-num;
else
return
num;
blem 9
~e functions to convert integer and float values to string.
?..-.3l*1
~-=clude<stdio.h>
~-~c ude<string.h>
-
i_to..:...str(int
num,char
str[],int
base);
_':'d
r_to_str (float
num, char
str [] ) ;
=..: ()
char
str1 [10], str2 [10], str3 [10], str4[lO], str5 [10J;
intx=45 ;
float
y=58.5;
i_to_str(x,str1,16) ;puts(strlJ;
i_to_str(x,str2,10) ;puts(str2);
i_to_str(x,str3,8) ;puts(str3);
i_to_str(x,str4,2) ;puts(str4);
f_to_str(y,str5) ;puts(str5);
::':'d
i_to_str (int
num, char
str [] ,int
b)
int
i=o, temp, rem, j ;
while(num>O)
{
rem=num%b;
num/=b;
if(rem>9
&&
rem<16)
s t r [ i ++ ] =
rem- 1 0 + ' A' ;
else
str[i++]=rem+'O';
}
str[i]='\O' ;
for (i=O, j =strlen (str) -1; i<j; i++, j - -)
1*Reverse
the
string* 1
{
temp=str[i];
str[i]=str[j] ;
str[j]=j:emp;
':'d
f_to_str (float
num, char
str [] )
int
i,k;
_ 9

Exercise
printf("%cH,name[i)) ;
i++;
(4) #inc1ude<string.h>
main( )
{
string
H) ;
is
%s\n H, str) ;
a
f·,
char
*str;
printf("Enter
gets(str) ;
printf("String
C in Dept!
float
i=num;
i_to_str(i,str,lO) ;
str[strlen(str)+l]='\O';
. str[strlen(str») ='.';
f=num-i;
k=f*lOOOO;
/*we'll
get
the
float
value
upto
4
decimal
paces*/
i_to_str(k,
str+str1en(str) ,10);
char
*strl="Good H, *str2=HMorning H;
strcat(strl,str2) ;
printf("%s\nH,strl);
int
i=O;
char
name [l 0] = { 'M' , '0' , 'h' , ' i ' , 'n' , 'i' , ' \ 0' } ;
whi1e(name[i)
{
Assume that stdio.h is included in all programs.
(1) main( )
{
(3) #inc1ude<string.h>
. main( )
{
Output:
2D
45
55
101101
58.5000
(2) main (
280

·th
char
str [10] = "How" ;
strcat (str., '?') ;
printf("%s\n",str);
in ( )
char
str[
]="vijaynagar";
str=str+5;
printf("%s\n",str);
}
ain(
char
str[
]="Vijaynagar";
func(str+5) ;
}
::unc(char
*str)
{
printf("%s\n",str) ;
ain(
{
c har
s t r[
] = {7 0 , 97 , 1 0 5 , 11 6 , 1 04 , 0 } ;
printf("%s\n",str);
_
main (
{
char
str [
] ="painstaking" ;
char
*p=str+5;
printf("%c\t",*p) ;
printf("%s\n",p) ;
}
main( )
{
printf("%c\t", "Determination"[2]) ;
printf("%c\t",*("Determination"+2)) ;
printf("%s\t", "Determination"+2) ;
printf("Determination"+2) ;
printf ("\t");
printf("Determination"+str1en("Deepali")) ;
printf("\t");
printf("Determination"+sizeof("Deepa1i")) ;
printf("\n") ;
•
)main (
{
char
str [
] ="Lucknow" ;
281

282
C in Dep;
char
*p=str;
p++;
p=p+2;
p[3]='t' ;
printf("%s
(ll)#include<string.h~
main( )
{
%s\n", str,p);
char
char
*p[]={"Orange", "Yellow", "Sky" "Blue" , "Black"};
arr[lOJ;
printf("%s
%s
%s\n",p[l],p[2],p[3]);
strcpy(arr, "Luck". "now");
printf("%s\n",arr);
(12)#include<string.h>
main ( )
(
char
strl[IS]="Good
";
char
str2 [
] ~"Evening";
strcpy(strl+strlen(str~),str2);
printfl"%s\n",strl) ;
(13) main (
(
char
name [15] ="Vikramadi tya;' ;
int
i=O;
while(name[i])
{
p r i n t f ( " %c
", name [ i) ) ;
i=i+3;
}
(14) main (
(
char
str(10] (20);
int
i;
for(i=O;i<lO;i++)
scanf("%s",str[i]);
for(i=0;i<10;i++)
printf("%s",str[i]);
(lS)main(
(
char
*str[lO);
int
i;
for(i=O;i<lO;i++)

)ept;'
scanf("%s",str[i]) ;
for(i=O;i<lO;i++)
printf("%s",str[i]);
}
- -include<string.h>
har
*combiI].e(
char
*arrl,
char
*arr2);
ain ( )
char
*str=combine ("Suresh" , "Kumar") ;
puts(str) ;
- ar
*combine(char
*arrl,char
*arr2)
char
str[80];
int
x,y, i, j;
x=strlen(arrl) ;
y=strlen(arr2) ;
strcpy(str,arrl) ;
for(i=x,j=O;j<x+y;i++,j++)
str[i]=arr2[j];
str[i]='\O' ;
return\str) ;
- :=ain( )
char
*str="Deepali
Srivastava";
int
i=O;
while(str[++i]);
printf (%d\n", i) ;
::ain ( )
int
dl,ml,yl;
char
date[11]="24/051l973";
date[2]=date[5]='\O' ;
sscanf(date,"%d",&dl) ;
sscanf(date+3,"%d",&ml) ;
sscanf(date+6,"%d",&yl) ;
date[2J'=date[5]='/' ;
printf("dl=%d,ml=%d,yl=%d\n",dl,ml,yl) ;
printf("dat~
%s\n"~date);
;;
ain ( )
{
char
*str="doubtful";
func(str);
283

284
C in Dep
func (char
*p)
{
if ( *p ! =' f ' )
{
printf("%c",*p) ;
func(++p);
(20)main(
{
ch-ar
*ptr;
ptr="My
name
is
%s
and
age
is
%d\n";
printf(ptr,"Ranju",30);
(21)void
funcl(char
arr[
]);
void
func2 (char
a [
]);
main ( )
{
int
i;
char
arr [5] ;
puts(arr);
funcl (arr) ;
puts(arr);
func2(arr);
puts (arr) ;
}
void
funcl (char
x [] )
{
x="Jack";
puts (x) ;
}
void
func2 (char
{
x [ ] )
x [0] = 'J' ,x [1] = \ i ' ,x [2] = \ I ',x [3] = \ I ' ',x [4] = \ \0 ' ;
puts (x) ;
} ,
(22) main (
{
char
*ptr;
ptr= "Every
saint
has
a
past,
\
'
Every
sinner
has
a
future. \n";
printf("Giving
""is
""Iiving.""\n");
printf (ptr) ;
Programming Exercise
1.
Write a function for performing case insensitive string comparison.

~pth
285
o
s
y
z
w
x
u
v
Manish - Lucknow
Divya -Kanpur
Kriti-Renusagar
Write a program to accept a line of text and display the number of consonants and spaces in that
line of text.
Write a function that searches for a character in the string and returns the number of occurrences
of that character in the string. It should take two arguments, first a string and then a character.
Write a function which replaces all the occurrences of a character from a string with another
character. It should take three arguments, a string and two characters.
Write a function which deletes all the occurrences of a character from a string. It should
take
two arguments, a string and a character.
Write a program to accept a line of text and a word. Display the number of occurrences of that
word in the text.
Write a function to remove all the leading and trailing blanks from a string.
Write a program to input text and replace all the occurrences of word "Calcutta" by "Kolkata"
in that text.
Write a program to accept a line of text and print that text after removing all sI?aces and delimiters.
Write a program to accept any 10 names and display those names after sorting them alphabetically
in descending order.
Write a program to encode text and to decode the encoded text.
(i)
Perform the encoding so that every character is replaced by its next character. For example
replace a by b, b by c and so on. Replace z by a.
Plain texf:
program
Encoded text : qsphsbn
Decoded text : program
(ii)
Perform the encoding according to these replacements
abcdefghij
kllrtnop
q
r
s
mnkghdt
abwvup
rqc
z
J
Xl eyf
Plain text: program
Encoded text :cjqtjmp
Decoded text :program
Input a string and change it so that the characters are placed in alphabetical order. For example
the string "motivate" should be changed to "aeimotv"
Write a program to abbreviate input text. For example if the input is "World Health Organization",
then the output should be WHO.
Write a function to extract a substring from a string. Assume that the substring stallS at the ith
character and is n characters long.
Write a program to input a number from 0 to 6 and print the corresponding day using array of
pointers. For example if 0 is entered then print Sunday, if 1 is entered print Monday.
Consider this list of names of persons and cities
Reeta·.
Kanpur
Alok - Rampur
Reena
-
Rampur
Suresh - Lucknow
Deepali -
Lucknow
Saumya - Rampur
Write a program such that if a name of a person is entered then the city is displayed and if a city
is entered then names. of all people living in that city are displayed.
Hint: store the names of cities and
persons in separate array of pointers to strings..

286
C ill Dept
17.
Write a program to input 5 lines of text and then store them as separate strings using array (
pointers to strings.
Answers
(1)
Mohini
(2)
Pointer str contains a garbage value, it ~hould be initialized before reading any string throug
gets( ).
(3)
The memory to which strl points is not writable, since string constant "Good" is stored in rea
only memory by some compilers. We should use a character array str[15].
(4)
'?' represents a character, and strcat concatenates only strings, so we should write "?".
. (5)
Error: since name of array is constant pointer and can't be altered.
(6)
nagar
(7)
Faith
Here the integer values are assumed to be ~SCII equivalents of characters and these charactet
get stored in the array:
.
(8)
t
taking
(9) Itt
termination
\
termination
nation
ation
. I
(10) Lucknot
knot
(11) Yellow
SkyBlue
Black
Lucknow
(12) Good Evening
(13)Vrat
(14) The first loop will input 10 strings and the next for loop. will display them.
(15) The pointers in the array of pointers are not initialized; so it is not valid to input strings.
(16) str is a local array declared inside combine( ) and hence it exists only inside this function, so :
is wrong to return its address to any other function. Sometimes this program may give desire,
output but the memory occupied by array str can be overwritten anytime. If we want this prograr
to work properly then" we can declare the array str in main( ), and send it tocobmine( ).
(17) 18
(18) d1 = 24, m1 = 5, y1 =
11' 3
date
=
24/05/1973
(19) doubt
(20) My name is Ranju and age is 30
(21) --
Jack
Jill
Jill
The two dotted lines represent garbage value. If an array is passed as an argument, then inside
the function we have a pointer to array and of course this is a local pointer variable. It
funcl( ), x is declared as pointer to char and initialized with the address of array arr. Inside thi:
function, the address of string constant "Jack" is assigned to pointer x.
So now x has lost thl
address of array arr and it has nothing to do with this array.

of
0 after call to func1( ), the array arr still contains garbage value. Now func2( ) is called and
array arr is sent to it. Here also x is declared as pointer to char and initialized with the address
of arr, but inside this function we have not changed the address of x.
Giving is living.
- very saint has a past, Every sinner has a future.
Igh
Adjacent string constants are concatenated. Any string constant can be continued on next line by
utting a '\'.
ead
:ers
) it
red
'am
ide
In
this
the

Chapter 10
Stractare find Onion
Array is a collection of same type of elements but in many real life applications we may need to grc
different types of logically related data. For ~mple if we want to create a record of a person t
contains name, age and height of that person, then we can't use array because all the three data eleme
are of different types.
iecordt-
~
1
name
age
height
(string)
(int)
(int)
To store these related fields of different data types we can use a structure, which is capable of stor
heterogeneous data. Oata of different types can be grouped together under a single name using structul
The data elements of a structure are referred to as members.
10.1
Defining a Structure
Definition of a structure creates a template or format that describes the characteristics of its memh
All the variables that would be declared of this structure type, will take the form of this template..
general syntax of a structure definition is-
stru.ct
tagname {
data type
memberl;
datatype
member2;
datatype
memberN;
} ;
Here struct is a keyword, which tells the compiler that a structure is being defined. memberl, memh
...............memberN are known as members of the structure andare declared inside curlybral
There should be a semicolon at the end of the curly braces. These members can be of any data t
like int, char, float, array, pointers or another structure type. tagname is the name of the structure
it is used further in the program to declare variables of this structure type.
Definition of a structure provides one more data type in addition to the built in data types. We can dec
variables of this new data type that will have the format of the defined structure. It is importan

student{
char
name [20] ;
int
rollno;
f loat
marks;
289
} ;
dent is the structure tag and there are three members of this structure viz name, rollno and
Structure template can be defined globally or locally i.e. it can be placed before all functions
Iogram or it can be locally present in a function. If the template is global then it can be used
functions while if it is local then only the function containing it can use
it.·~"
" .. - - - ."
Declaring Structure Variables
definition of a structure template does not reserve any space in memory for the members;
reserved only when actual variables of this structure type are declared. Although the syntax
laration of members inside the template is identical to the syntax we use in declaring variables
members are not variables, they don't have any existence until they are attached with a structure
:=::!b'le. The member names inside a structure should be different from one another but these names
similar to any other variable name declared outside the structure. The member names of two
=~TI't structures may also be same.
take an example of defining a structure template.
2':zz:rue and Union
roup
that
lents
)ring
ures
'ng a structure we have only created a.format, the actual use of structures will be when we
variables based on this format. We can declare structure variables in two ways-
. ith structure definition
-sing the structure tag
1 With Structure Definition
bers
The
_ t
student{
char
name [20] ;
int
rollno;
f loa t
marks;
}stul,stu2,stu3;
srul, stu2 and stu3are variables oftype struct student. When we declare a variable while defining
cture template, the tagname is optional. So we can also declare them as-
~ an
aces
type
berl.
chari
name [20 1 ;
int
rollno;
float
marks;
}stul,stu2,stu3;
declare variables in this way, then we'll not be able to declare other variables of this structure
ywhere else in the program nor can we send these structure variables to functions. Ifa need
to declare a variable of thi,stype in the program then we'll have to write the whole template again.
ihough the tagname is optional it is always better to specify a tagname for the structure.
.2
Using Structure Tag
:clare
also declare structure variables using structure tag. This can be written
as~'
.nt t
_ct:
student {

290
C in' Dept
char
name [20] ;
int
rollno;
float
marks;
} ;
struct
student
stul, stu2;
struct
student
stu3;
Here stu1, stu2 and stu3 are structure variables that are declared using the structure tag student.
Declaring a structure variable reserves space in memory. Each structure variable declared to be of ty
struct student has three members viz. name, rollno and marks. The compiler will reserve space:
each variable sufficient to hold all the members. For example each variable of type struct student \1
occupy 26 (20+2+4) bytes.
10.3
Initialization Of Structure Variables
The syntax of initializing structure variables is similar to that of arrays. All the values are given in cu
braces and the number, order' and type Qf these values should be same as in the structure tempI
definition. The initializing values can only be constant expressions.
struct
stu?ent {
char
name [2'0] ;
int
rollno;
float
marks;
}stul={"Mary H,25,98};
struct
student
stu2={ "John H, 24, 67. 5};
Here value of members of stu1 will be "Mary" for name, 25 for rollno, 98 for marks. The value:
members of stu2 will be "John"
f~r name, 24 for rollno, 67.5 for marks.
We cannot initialize members while defining the structure.
struct
student
{
char
name [20] ;
int
rollno;
floa. t
marks=99;
/ * Inval id* /
}stu;
This is invalid because there is no variable called marks, and no memory is allocated for struf
definition.
If the number ofinitializers is less than the number ofmembers then the remaining members are initial
with zero. For example if we have this initialization-
struct student stu I = {"Mary"};
Here the members rollno and marks of stul will be initialized to zero. This is equivalent to the initializa
struct student stul = {"Mary", 0, O};
f
Some old compilers permit initialization ofonly global and static structures, but there is no such restri
in ANSI standard compilers.
I
Accessing Members of a Structure
10.4
For accessing any member of a structure variable, we use the dot ( . ) operator which is also
as the period or membership operator. The format for accessing a structure member is-
structvariable.member

~ptlr
re and Union
291
_ on the left side of the dot there should be a variable of structure type and on right hand side there
d be the name ofa member of that structure. For example consider the following structure-
:.__ct
st:udent {
aame of stuI is given by - stu l.name
rollno of stuI is given by - stu l.rollno
arks of stul is given by - stul.marks
ame of stu2 is given by - stu2.name
rollno of stu2 is given by - stu2.rollno
arks of stu2 is given by -_stu2.marks
It.
type
~D
w
url.
lla -
t
student
char
name [20] ;
int
rollno;
float
marks;
} ;
stul,stu2;
use stul.name , stu1.marks, stu2.marks etc like any other ordinary variables in the program.
_ can be read, displayed, processed, assigned values or can be send to functions as arguments.
't use student.name or student.rollno because student is not a structure variable, it is a structure
:=: . 1
Program
to
display
the
values
of
structure
members * /
-=.:::'ude<stdio. h>
-=.:::'ude<string.h>
___;::t
student{
s
char
name [20] ;
int
rollno;
float
marks;
} ;
-"-(
)
name,
rollno
and
marks
for
stu3
:
");
%f",stu3.name,&stu3.rollno,&stu3.~~rks)
;
\
%s
%d
%.2f\n",stul.name,stul.roJUno,stul.marks);
%s
%d
%. 2f\n", stu2. name, stu2. rOlino, stu2 .marks) ;
. %s
%d
%. 2f\n", stu3 .name, stu3. rollno, stu3 .marks);
tur
1Z
lOll-
:ti
o
struct
student
stul= {"Mary" ,-2:5,68) ;
struct
student
stu2, stu3;
strcpy(stu2.name, "John");
stu2.rollno=26;
stu2.marks=98;
printf ("Enter
scanf("%s
%d
printf("stul
printf("stu2
printf("stu3
ut:
;er name, rollno and marks for stu3
Tom 27 79.5
stul : Mary 25 68.00
stu2
John 26 98.00'
stu3 : Tom 27 79.50
,ach
,;essed
the dot

292
C in De)
In this program we have declared three variables oftype struct student. The first variable stu1 has hi
initialized, the members of second variable stu2 are given values using separate statements and the val
for third variable stu3 are input by the user. Note that since stu2.name is an array so we can't ass
a string to it using assignment operator, hence we have used the strcpy( ) function.
The dot operator is one of the highest precedence operators, its associativity is from left to right. Hel
it will take precedence over all other unary, relational, logical, arithmetic and assignment operators.
in an expression like ++stu.marks, first stu.marks will be accessed and then its value will be increa
by 1.
1Q.5
Assignment of Strlicture Variables
We can assign values of a structure variable to another structure variable, if both variables are defil
of the same structure type. For example-
/ *P10. 2
Program
to
assign
a
structure
variables
to
another
structu
variable*/
struct
student {
char
name [20] ;
int .rollno;
float
marks;
} ;
main ( )
{
struct
student
struct
student
stu2=stul;
printf("stul
printf("stu2
stul={"Oliver",12,98};
stu2;
%s
%d
%. 2f\n", stul.name, stul. rollno, stul.marks) ;
%s
%d
%. 2f\n", stu2 .name, stu2. rollno, stu2 .marks) ;
}
Output:
stu1 : Oliver 12 98.00
stu2 : Oliver 12 98.00
Unary, relational, arithmetic, bitwise operators are not allowed with structure variables. We can use thl
variables with the members provided the member is not a structure itself.
10.6
Storage of Structures in Memory
The members of structures are stored in consecutive memory locations.
/*P10.3
Program to
show that members of structure are stored in consecuti
memory
locations * /
#include<stdio.h>
main ( )
{
. struct
student {
char
name [5] ;
int
rollno;
float
marks;
}stu;

lept
and Union
293
be
~=':'ntf ("Address
of
name
=
%u \n" , stu. name) ;
alu
:;.=':'ntf("Address
of
rollno
=
%u\n",&stu.rollno);
ssi
-=':'ntf("Address
of
marks = %u\n" ,&stu.marks);
need to find out the size of structure in some situations like reading or writing to files. To
... the size of a structure by sizeof operator, we can either use the structure variable name or
._ ame with the struct keyword. For example-
1:of( struct student )'
eof( stu1 )
_IZeof( stu2 )
- stul and stu2 are variables of type struct student, then all the three expressions will give the
:esult.
- structures may be different on different machines. This is because of certain memory alignment
'ons on some computers. For example some machines store integers only at even addresses and
only at addresses which are multiple of4. This is called aligning of data. Consider this structure-
ess of stu.name = 65514
es of stu.rollno = 65519
_- dress of stu.marks = 65521
ut may be different on different machines, and the number of bytes occupied may also vary
~~;e of the reasons explained in next section, but the main point to be noted, here is that structure
==-=,ers are stored in consecutive memory locations.
.
Size of Structure
fin
.ure
:as
[en
~
s.
_ ar
ch;
-
t
num;
hese
iVl;
--;
ere suppose var.ch is stored at an even address, then' the next byte will be left unused since
't be stored at an odd address. So instead of occupying 3 bytes this structure variable will occupy
with a hole of unused byte in between. Due to these reasons, size of whole structure may not
to the sum of sizes of its members. So it is always better to find the size of structure variable
g sizeof operator rather than using the sum of sizes of its members.
, Array of Structures
ow that array is a collection of dements of same datatype. We can declare array of structures
each element of array is of structure type. Array of structures can be declared as-
struct student stu[10];
stu is an array of lO elements, each of which is a structure of type struct student, means each
ent of stu has 3 members, which are name, rollno and marks. These structures can be accessed
_ gh subscript notation. To access the individual members of these structures we'll use the dot
tor as usual.

294
stu[O].name
stu[1].name .
stu[2].name
stu[9].name
stu[O].rollno
stu[1].rollno
stu[2].rollno
stu[9].rollno
stu[O].marks
stu[1].marks
stu[2].marks
stu[9].marks
C in}Jej
-"1
All the structures of an array are stored in consecutive memory locations.
/ *P10. 4
Program
to
understand
array
of
structures * /
#inc1ude<stdio.h>
struct
student {
char
name [20] i
int
ro11noi
f loat
marks;
} ;
main ( )
{
int
i;
struct
student
stuarr [10] ;
for(i=0;i<10ii++)
{
printf ("Enter
name,
ro1lno
and
marks
") i
scanf("%s%d%f",stuarr[i] .name,&stuarr[i] .rollno,
&~tuarr[i] .marks);
}
for(i=Oii<10;i++)
printf("%s
%d
%f
\n",stuarr[i] .name,stuarr[i] .rollno,
stuarr[i] .marks);
}
In some compilers the above program may not work correctly and will give the message 'iloating p
formats not linked" at run time. This problem occurs because the floating point formats (for sea
and other related functions) are not always linked, to reduce the size of executable file. The solu
to this problem will be given in the manual of your compiler. Fot example, Borland C suggests
inclusion of these two lines to solve this problem.
extern unsigned _floatconvert;
#pragma extref _floatconvert
Another way to avoid the above problem is to insert a definition of a function like this-
. void. link( )
{ float x, *ptr = &x; }
The array of structures may be initialized using the same syntax as in arrays. For example-
. struct
student
stuarr [3] = {
{"Mary",12,98.5},
{"John",11,97},
{"Tom",12,89.5}
} i
\
The inner pairs of braces are optional if all the initializers. are present in the list.

eptt
-
re and Union
Arrays Within Structures
295
Din:
nil
tiofi
the
have an array as a member of structure. In structure student, we have taken the member name
array of characters. Now we'll declare another array inside the structure student.
-=
t
student {
char
name [20] ;
int
rollno;;
int
submarks [4] ;
} ;
::rray subrnarks denotes the marks of students in 4 subjects.
is a variable of type struct student then-
,
.submarks[O] - Denotes the marks of the student in fir~t'subject
.submarks[l] - Denotes the marks in second subject.
"~'"
.name[O] - Denotes the first character of the name member.
.name[4] - Denotes the fifth character of the name member.
[10] is an array of type struct student then-
arr[O].submarks[O] - Denotes the marks of first student in first subject
arr[4].submarks[3] -Denotes the marks- of fifth student in fourth subject.
smarr[O].name[O] - Denotes the first character of name member of first student
rr[5].name[7] - Denotes the eighth character of name member of sixth student
-=:':.5
Program
to
understand
arrays
wi thin
structures * I
--:. de<stdio.h>
student {
char
name [20] ;
int
rollno;
int
submarks [4] ;
} ;
-
i
I j
j
;:;:::ruct
student
stuarr [3] ;
= r(i=Oji<3;i++)
printf ("Enter
data
for
student
%d\n", i+l);
printf ("Enter
name
") ;
scanf("%s",stuarr[i] .name);
printf ("Enter
roll
number
") ;
scanf (" %d",
&stuarr [i] . rollno) ;
for(j=O;j<4;j++)
{
printf ("Enter
marks
for
subj ect
%d
scanf("%d",&stuarr[i] .submarks[j]);
" , j + 1) ;

296
for{i=O;i<3;i++)
{
printf ("Data
of
student
%d\n", i+l) ;
printf ("Name
%s,
Roll
number
%d\nMarks
stuarr[i] .rollno);
for{j=O;j<4;j++)
printf{"%d" ",stuarr[i] .submarks[j]);
printf ("\n");
10.10 Nested Structures (Structure Within Structure)
C in Dep
",stuarr[i] .nam
The members of a structure can be of any data type including another structure type i.e. we can inclt
a structure within another structure. A structure variable can be a member of another structure. TI
is called nesting of structures.
struct
tagl {
memberl;
member2;
struct
tag2 {
memberl;
member2;
member
m;
)varl;
member
n;
}var2;
For accessing memberl of inner structure we'll write-
var2.varl.memberl
Here is an example of nested structures-
struct
student {
char
name [20] ;
int
rollno;
struct
date{
int
day;
int
month;
int
year;
} birthdate;
f loa t
marks;
}stul,stu2;
Here we have defined a structure date inside the structure student. This structure date has three memb
day, month, year and birthdate is a variable of type struct date. We can access the members of im
structure as-
stu1.birthdate.day
-7
stul.birthdate.month
-7
stu1.birthdate.year
-7
day of birthdate of stul
month of birthdate of stul
year of birthdate of stul

th
lure and Union
stu2.birthdate.day
day of birthdate of stu2
297
we have defined the template of structure date inside the structure student, we could have defined
! ,
ide and declared its variables inside the structure student using the tag. But remember if we define
inner structure outside, then this definition should always be before the definition of outer structure.
in this case the date structure should be defined before the student structure.
=uct
date{
int
day;
int
month;
int
year;
_-::::.-uct
} ;
student{
Ie
is
char
name [20] ;
int
rollno;
f loa t
marks;
struct
date
birthdate;
}stul,stu2;
advantage of defining date structure outside is that we can declare variables of date. type anywhere
also. Suppose we define a structure teacher, then we can declare variables of date structure inside
=-. ct
teacher {
char
name [20] ;
int
age;
float
salary;
struct· date
birthdate, joindate;
}tl,t2;
nested ,structures may also be initialized at the time of declaration. For example-
struct teacher t1= { "Sam", 34, 9000, {8, 12, 1970}, { 1, 7, 1995 } } ;
. g of a structure within itself is not valid. For example the following structure definition is invalid-
=-_ ct
person{
char
name[20];
int
age;
float
height;
struct
person
father;
1* Invalid* I
}emp;
-
nesting of structures can be extended -to any level. The following example shows nesting at level
i.e. first structure is nested inside a second structure and second structure is nested inside a third
ture.
ct
time
int
hr;
s
int
min;
:r
int
sec;
:::=-.--uct
date
int
day;
int
month;

/*Date
of
birth*/
298
C in De)
int
year;
struct
time
t;
} ;
struct
student
. char
name[20];
struct
date
dob;
}stul,stu2;
To access hour of date of birth of student stu! we can write-
stu1.dob.t.hr
10.11
Pointers to Structures
We have studied that pointer is a variable which holds the starting address of another variable of ,
data type like int, float or char. Similarly we can have pointer to structure, which can point to the start
address of a structure variable. These pointers are called structure pointers and can be declared
struct
student {
-
char
name [ 20] ;
int
rollno;
int
marks;
} ;
struct
student
stu, *ptr;
Here ptr is a pointer variable that can point to a variable oftype struct student. We'll use the & opera
to access the starting address of a st ·&ture variable, so ptr can point to stu by writing-
ptr = &stu;
There are two ways of accessing th\ members of structure through the structure pointer.
As .we know ptr is a po.inte~ to a struct~, so by dereferencing it we can get the contents of ~truct
vanable. Hence *ptr wIll give the contents of stu. So to access members of a structure vanable
we can write-
.
...
(*ptr).name
(*ptr).rollno
(*ptr).marks
Here parentheses are necessary because dot operator has higher precedence than the * operator. T
syntax is confusing so C has provided another facility of accessing structure members through point(
We can use the arrow operator (-» which is formed by hyphen symbol and greater than symbol.
we can access the members as-
ptr->name
ptr->rollno
ptr->marks
The arrow operator has same precedence as that of dot operator and it also associates from left
right.
/ *P10. 6
Program
to
understand
pointers
to
structures * /
#include<stdio.h>
struct
student {
char
name [20] ;

~th
re and Union
299
int
rollno;
int
marks;
} ;
-
:J. (
)
struct
student
struct
student
printf ("Name
printf ("Rollno
printf ("Marks
stu={"Mary",25,68};
*ptr=&stu;
%s\t",ptr->name);
%d\t",ptr->rollno);
%d\n",ptr->marks) ;
my
lllg
as-
_ an also have pointers that point to individual members ofa structure variable. For example-
int *p = &stu.rollno;
float *ptr = &stu.marks;
expression &stu.rollno is equivalent to &(stu.rollno) because the precedence of dot operator is more
that of address operator.
--------~
.12 Pointers Within Structures
-_ _ inter can also be used as a member of structure. For example we can define a structure like this-
===uct
student {
.13
Structures And Functions
stu.ptrmem or stuptr->ptrmem
access the value pointed to by stu.ptrmem, we'll write
*stu.ptrmem or *stuptr->ptrmem
e the priority of dot and arrow operators is more than that of dereference operator, hence the expression
p~em is equivalent to *(stu.ptrmem), and the expression *stuptr->ptrmem is equivalent to *(stuptr-
Jtrmem).
char
name[20);
tor
int
*ptrmem;
} ;
___ ct
student
stu, *stuptr=&stu;
- ~ ptrmem is pointer to int and is a member of the structure student.
access the va-lue of ptrmem, we'll write
lfe
;tll
b.is
TS.
So
ctures may be passed as arguments to function in different ways. We can pass individual members,
Ie structure variable or structure pointers to the function. Similarly a function can return either a
cture member or whole structure variable or a pointer to structure.
to
.13.1 Passing Structure Members As Arguments
-~ can pass individual structure members as arguments to functions like any other ordinary variable.
r?lO.7
Program to understand
how structure members are sent
to
a
function
_ clude<stdio.h>
-
c1ude<string.h'

300
C in DeJ.
struct
student
char
name [20] ;
int
rollno;
int
marks;
} ;
display (char
name [
1, int
rollno, int
marks);
main ( )
{
struct
student
stu1= {"John" , 12,87};
struct
student
stu2;
strcpy(stu2.name, "Mary");
stu2.rollno=18;
stu2.marks=90;
display(stul.name,stul.rollno,stul.marks);
display(stu2.name,stu2.rollno,stu2.marks);
}
display(char
name [
Lint
rollno,int
marks)
{ /
printf( "Name
printf("RollfJ.o
printf ("Marks
%s \ t" , name) ;
%d\t", rollno) ;
%d\n" ,marks);
}
Output:
Name - John Rollno - 12 Marks - 87
I
.
Name - Mary Rollno - 18 Marks - 90.
L
.
Here we have passed members of the variables stul and stu2 to the function display( ). The narr
of t~e formal arguments can be similar to the names of the members. W~ can pass the arguments usi
call ~y reference also so that the changes made in the called function ~'ll
~e reflected ~n the calli
functIon. In that case we'll have to send the addresses of the members.
IS also possIble to reh
~
a single member from a function.
10.13.2 Passing Structure Variable As Argument
Passing individual members to function becomes cumbersome when there are many members and t
relationship between the members is also lost. We can pass the whole structure as an argument.
/*P10.8 Program to understand how a structure variable is sent to a
functi,
*/
#include<stdio.h>
struct
student {
char
name [20] ;
int
rollno;
int
marks;
} ;
display (struct
student);
main ( )
{
struct
student
structstudent
stul={"John",12,87};
stu2={"Mary",18,90};

h
~::.:::tlrue and Union
_. splay (stu1) i
-'splay(stu2) i
-_ ay(struct
student
stu)
301
_ rintf ("Name
-
_ rintf ("Rollno
_rint f ("Marks
%s\t",stu.name)i
%d\t",stu.rollno) ;
%d\n",stu.marks)i
ut:
_ arne - John Rollno - 12 Marks - 87
_ arne - Mary Rollno - 18 Marks - 90
it is necessary to define the structure template globally because it is used by both functions to
variables.
name of a structure variable is not a pointer unlike arrays, so when we send a structure variable
argument to a function, a copy of the whole structure is made inside the called function and
e work is done on that copy. Any changes made inside the called function are not visible in the
g function since we are only working on a copy ofthe structure variable, not on the actual structure
- Ie.
3.3 Passing Pointers To Structures,As Arguments
size of a structure is very large, then it is not efficient to pass the whole stJ'cture to the function
a copy of it has to be made inside the called function. In this case it is ~~tter to send address
- e structure, which will improve the execution speed.
\--- _.
:::an access the members of the structure variable inside the calling function us~rrow operator.
- - case any changes made to the structure variable inside the called function, will be visible in the
g function since we are actually working on the original structure variable.
"
::::'0.9
Pro.gram
to
understand
how
a
pointer
to
structure
variable
is
=-=
to
a
function* /
~_ ude<stdio.h>
ct
student {
char
name [20] ;
int
rollno;
int
marks;
} i
-_lay(struct
student
*);
-_:narks (struct
student
*);
-
()
struct
student
stu1= {"John", 12,87};
struct
student
stu2= { "Mary" , 18,90} ;
inc_marks (&stu1) ;
-nc_marks(&stu2) ;
display(&stu1) ;
display(&stu2) ;

Structure variables can be returned from functions as any other variable. The returned value cal
assigned to a structure of the apprOpriate type.
/*P10 .10
Program
to
understand
how
a
structure
variable
is
returned
f
a
function* /
#include<stdio.h>
struct
student {
C in DE
%s\t",stuptr->name) ;
%d\t",stuptr->rollno);
%d\n",stuptr->marks} ;
printf ("Name
printf ("Rollno
printf ("Marks
(stuptr->marks)++;
struct
student
change (struct
student
stu)
c.har
~ame [20] ;
int
ro11no;
int
marks;
struct
student
stu1= {"John" , 12,87};
struct
student
stu2= {"Mary", 18,90};
stu1=change(stu1} ;
stu2=change(stu2} ;
display(stul} ;
dispYay (stu2) ;
inc_marks (struct
student
*stuptr)
{
} ;
void
display (struct
student);
struct
student
change (struct
studertt
stu);
main( }
{
}
Output
Name - John Rollno - 12 Marks - 88
Name - Mary Rollno - 18 Marks - 91
10.13.4 Returning A Structure Variable From Function
}
display (
struct
student
*stuptr)
{
302
stu.marks=stu.marks+5;
stu.rollno=stu.rollno-10;
return
stu;
void
display (struct. student. stu)
printf ("Name
printf ("Rollno
printf ("Marks
%s\t",stti.name) ;
%d\t",stu.rollno) ;
%d\n",stu.marks} ;

'Jt
ure and Union
303
ut:
Name - John Rollno - 2 Marks - 92
~ame - Mary Rollno - 8 Marks - 95
13.5 Returning A Pointer To Structure From A Function
ers to structures can also be returned from functions. In the following program, the function
) returns a pointer to structure.
~
:=:0.11
Program· to
understand
how
a
pointer
to
structure
is
returned
a
function* /
-=_lude<stdio.h>
-= 1ude<string.h>
-:.::. t
student {
char
name [20] ;
int
rollno;
int
marks;
} ;
__
display (struct
student
*);
__:::t
student
*func ( ) ;
-=( )
-truct
student
*stuptr;
5t:uptr=func ( ) ;
~'splay(stuptr) ;
_-t
student
* func (
",t:ruct
student
*ptr;
_ r= (struct
student
*)
malloc (sizeof (struct
student));
st:rcpy(ptr->name, "Joseph") ;
_ r->rollno=l5;
_ r->marks=98;
=-eturn
ptr;
::: display (struct
student
*stuptr)
=-~intf("Name
-
:;;=-intf ("Rollno
:;;=-intf ("Marks
%s\t",stuptr->name) ;
%d\t".stuptr->rollno);
%d\n",stuptr->marks) ;
t
eph
15
98
.6 Passing Array Of Structures As Argument
_ pass an array to a function, similarly we can pass the arraYI of structure to function,· where
=ement of array is of structure type. This can be written as-'
_= .12
Program
to
understand
how
an
array
<of
structures
is
sent
to
_-=ction
* /
:'_de<stdio.h>

304
C in D.
struct
student {
char
name [20) ;
int
rollno;
int
marks;
} ;
void
display (struct
student);
void
dec_marks (struct
student· stuarr [ );
main( )
{
int
i;
struct
student
stuarr [3) = {
{"Mary",12,98},
{"John",ll,97},
{"Tom",13,89}
dec_marks (stuarr) ;
for (i=O; i<3; i+-+)
-
display(stuarr[i);
}
void
dec_marks (struct
student
stuarr [
)
int
i;
for(i=O;i<3;i++)
. stuarr[i) .marks=stuarr[i) .marks-l0;
}
void
displ,ay (struct
student
stu)
{
printf ("Name
%s\ t",
stu. name) ;
printf("RQllno
-
%d\t",
stu.rollno);
printf ("Marks
%d\n",
stu.marks);
}
Output:
Name - Mary Rollno - 12 Marks - 88
Name - John Rollno - 11 Marks - 87
Name - Tom Rollno -,13 Marks - 79
All the changes made in the array of structures inside the called function will be visible in the c:
function.
The following program calculates the total marks and grade of students, and then sorts the nam
students on the basis of marks and prints out the sorted records.
/ *PIO .13
Program
to
find
out
and
print
the
grade
of
students* /~-­
#include<stdio.h>
#define
N
5
struct
student
char
name[20);
int
rollno;
int
marks [6) ;'
int
total;

ep
[lim:
:8
re and Union
char
grade;
__ display(struct
student
arr);
-
calculate (struct
student
arr [
]);
sort (
struct
student
arr [
]);
- ()
struct
student
stu [N), temp;
~nt
i, j ;
:or(i=O;i<N;i++)
{
printf ("Enter
name
") ;
scanf ("%s", stu [i] . name) ;
printf ("Enter
rollno
") ;
scanf (" %d" ,&stu [i] . rollno) ;
stu[i] .total=O;
printf ("Enter
marks
in
6
subjects
for(j=O;j<6;j++)
scanf ("%d", &stu [i] .marks [j]);
}
alculate (stu) ;
sort(stu);
:or(i=O;i<N;i++)
display(stu[i]) ;
.-
calculate(struct
student
stull)
':nt
i,j;
for(i=O;i<N;i++)
(
for(j=O;j<6;j++)
stu[i).total+=stu[i] .marks[j];
if(stu[i] .total>500)
stu[i] .grade='A';
. else
if (stu[i] .total>400)
stu[i] .grade='B';
else
if (stu [i] . total>250)
stu[i] .grade='C';
else
stu[i] .grade='D';
}
sort(struct
student
stull>
int
i,j;
struct
student-
temp;
for(i=O;i<N-l;i++)
for(j=i+ljj<N;j++)
if(stu[i] .total<stu[j] .total)
{
temp=stu[i] ;
" ) ;
305
'

306
C in Dep
stu [i) =stu [j];
stu[j]=temp;
}
void
display (struct
student
~+- •• \
}
In the following program the records are sorted on different keys depending on the choice of the u
struct
employee
emp [N] ;
int
i,choice;
for(i=O;i<N;i++}
{
%d\t",stu.rollno) ;
%s\n",stu.namef;
%d\t",stu.total};
-%c\n\n",stu.grade} ;
int
i;
, printf ("Rollno
printf ("Name
printf ("Total
printf ("Grade
void
sort_name (struct
employee
emp t] ) ;
void
sort_d6b (struct
employee
emp [] ) ;
void
sort_doj (struct
employee
emp [] ) ;
void
sort_salary (struct
employee
emp [] ) ;
void
display (struct
employee
emp [] ) ;
int
datecmp(struct
date
datel,
struct
date
date2
};
main (
)
{
char
name [20] ;
struct
date
dob;
str~ct
date
doj;
int
salary;
} ;
printf ("Enter
name
:");
scanf("%s",
emp[i].name};
.
printf ("Enter
date
of
birth (dd/mm/yy)
"} ;
scarif("%d/%d/%d",&emp[iJ .dob.day,&emp[i] .dob.month,
&emp[i] .dob.year};
printf("Enter
date
of
joining(dd/mm/yy}
"};!
scanf("%d/%d/%d",&emp[i] .doj.day,
&emp[i] ."doj.mohth,
&emp[iJ .doj.year};
printf ("Enter
salary
") ;
scanf("%d",&emp[iJ .salary};
int . day;
int
month;
int
year;
}
;
I
struct
employee {
/ *P10 .14
Program
to
sort
the
records
on
different
keys* /
#include<stdio.h>
#·define
N
5
struct
date {

th
re and Union
printf("\n");
}
·....hile (1)
(
printf("l.Sort
by
name\n");
printf("2.Sort
by
date
of
birth\n");
printf ("3. Sort
by
date
of
joining\n");
printf ("4. Sort
by
salary\n");
printf("5.Exit\n") ;
printf("6.Enter
your
choice
:");
scanf ("%d",
&choice);
switch(choice)
{
case
1:
sort_name (emp) ;
break;
case
2:
sort_dob (emp) ;
break;
case
3:
sort_doj (emp) ;
break;
case
4:
sort_salary(emp);
break;
case
5:
exit(l) ;
default:
printf ("Wrong
choice\n");
printf ("\n");
display(emp) ;
307
display(struct
employee
emp [] )
-
t
i;
_rintf("NAME\t\tDOB\t\tDOJ\t\tSALARY\n") ;
::or(i=O;i<N;i++)
p r i n t f ( " %s \ t \ t" , emp [ i) . name) ;
printf("%d/%d/%d\t\t",emp[i] .dob.day,emp[i] .dob.month,
p [ i) . dob . year) ;
printf("%d/%d/%d\t\t",emp[i] .doj.day,emp[i] .doj.month,
~[i] .doj .year);
printf("%d\n",emp[i] .salary);
:rintf("\n") ;
_::.
sort_name(struct
employee
emp[])

308
{
C in Dep
struct
employee
temp;
int
i,j;
for(i=O;i<N-1;i++)
for(j=i+1;j<N;j++)
if(strcmp(emp[i] .name,emp[j] .name»O)
{
temp=emp[i];
emp[i]=emp[j] ;
emp[j]=temp;
}
void
sort_dob (struct
employee
emp [] )
struct
employee
temp;
int
i,j;
for(i=O;i<N-1;i+~)
for(j=i+1;j<N;j++)
if (datecmp(emp[i] .dob,emp[j] .dob»O)
{
temp=emp[i] ;
emp[i]=emp[j];
emp[j]=temp;
}
void
sort_doj (struct
employee
emp [] )
struct
employee
temp;
int
i,j;
for(i=Oii<N-1;i++)
for(j=i+1;j<N;j++)
if(datecmp(emp[i] .doj,emp[j] .doj»O)
{
temp=emp[i] ;
emp[i]=emp[j];
emp[j]=temp;
}
void
sort_salary (struct
employee
emp [] )
struct
employee
temp;
int
i,j;
for(i=O;i<N-1;i++)
for(j=i+1;j<N;j++)
if(emp[i] .salary<emp[j] . salary)
{
temp=emp[i];
emp[i]=emp[j];
emp[j]=temp;
}
/ *Returns
1
if
date1
<
date2,
returns
-1
if
date1
>
date2,
retu!

.i-.~,,-,",.uc:; and Union
:!qUal*/
= datecmp (struct
date
date1,
struct
date
date2)
::(date1.year<date2.year)
return
1;
~_(date1.year>date2.year)
return
-1;
~f(date1.month<date2.month)
return
1;
If(date1.month>date2.month)
return
-1;
If(date1.day<date2.day)
return
1;
~:(date1.day>date2.day)
return
-1;
::eturn
0;
4 Self Referential Structures
309
ture that contains pointers to structures of its own type is known as self referential structure.
:=xample-
_ct
tag{
datatype
member1 ;
datatype
member2;
struct
tag
*ptr1;
struct
tag
*ptr2;
1
d }; 2
\
.. h'
. bl
f
'"
_ ptr
an
ptr
are structure pomters t at can pomt to structure vana
es 0
type struct tag, so
tag is a self referential structure. These types of structures are helpful in implementing data
es like linked lists and trees. We'll discuss the data structure linked list in this chapter.
S Linked List
- a collection of elements. There are two ways of maintaining a list in computer memory. The
ay is to take an array for storing the
element~ of the list, but arrays have some disadvantages.
'on and deletion of an element from an array requires more processing. If the number of elements
list is less than the size of array then memory will be wasted and if the number of elements
~s the size of array then also we'll have problems.
.
: second way of implementing a list in memory is by using a self referential structure. These types
5ts are known as linked lists. A linked list is made up of nodes where each node has two parts,
part contains the infonnation and second part contains the address of the next node. The address
of the last node of linked list will be NULL. The general fonn of a node of linked list is-
_ct
node
datatype
member1;
datatype
member2;

310
} ;
C in Depi
struct
node
*link;
/*
Pointer
to
next
node
of
the
list'
info
link
Address part of the node, which contains
the address ofthe next node
Information part of the node
NULL
The "nodes of a linked list-are not stored contiguously in memory. In array list we could perform
the operations using the array name. In the case of linked list, we'll perform all the
opeFation~ w
the help of a pointer that points to the fIrst node the linked list. This pointer is generally named sl
and it is the only source through which we can access our linked list. The list will be considered em
if the pointer start contains NULL value.
Now we'll take a linked list that contail1s an integer value ih the information part. The structure
the nodes of this list will be defined as-
struct
node {
int
info;
struct
node
*link;
} ;
The pointer variable start will be declared as-
struct node *start;
Here is a linked list that has 4 nodes-
start
2000
.1 15
1000
~120
1600 ~25
1400
We can clearly see that the address of each node is stored in the link part of the previous node,
the address of first node is stored in the pointer variable start. The link part of the last node cont
NULL.
We'll discuss the following operations on this list.
(i)
Traversal of list
(ii)
Searching an element

)e
and Union
rtion of an element
letion of an element
:eation of list
ersal of list
311
':.1 Traversing a Linked List
of a list means accessing each node exactly once. For this we'll take a structure pointer ptr.
ptr is assigned the
v~lue of start.
7:-1" = start;
. ptr points to the first node of linked list. We can access the info part of first node by writing
o.
e'll shift the pointer ptr forward so that it points to the next element. This can be easily done
-gning the address of the next element to ptr as-
7
= ptr->link;
-
has address of the next element. Similarly we can traverse each element of linked list through
ignment until ptr has NULL value, which is link part value of last element. So the linked list
traversed as-
_=(ptr!=NULL)
:;::::-intf ("%d
", ptr->info) ;
:;:::r=ptr->link;
-.2 Searching in a Linked List
. J
ching an element, we traverse the linked list and while traversing we compare the info wart
element with the given element. It can be written as-
/
__ ~(ptr!=NULL)
~=(ptr->info==data)
/*Search
successful*/
=_se
ptr=ptr->link;
/*Go
to
next
element* /
ta is the element, which we want to search.
-.3 Insertion into a Linked List
on in a linked list may be possible in two ways-
ertion in the beginning
ertion in between or at the end.
- rt a node, initially we'll dynamically allocate space for that node using malloc( ). Suppose tmp
inter that points to this dynamically allocated node. In the info part of the node we'll put the
,}ue.
p = (struct node *)malloc( sizeof(struct node) );
p->info = data;

312
C in De.
The link part of the node contains garbage value, we'll assign address to it separately in the two ca
~
tmp
3000
10.15.4 Insertion in the Beginning'
After insertion the new node will become the first riode, and the node which is currently the first n
will come at second place. So we just have to adjust the links of thl;l. nodes.
Assign the value of start to the link part of inserted node as-
tmp->link = start;
Now inserted node points to the next node, which was beginning node of the linked list.
Now inserted node is the first node of the linked list. So start should be reassigned as-
start = tmp
Now start will point to the inserted node, which is first node of the linked list.
The following figure shows this process, dotted lines represent the link before insertion.
start
3000
,
...........................................
10.15.5 Insertion in Between of at the end
First we traverse the linked list for obtaining the node after which we want to insert the element.
obtain pointer q which points to the element after which we have to insert new node. For inser
the element after the node, we give the lin1.}. part of that node to the link part of inserted node and
address of the inserted node is placed into the link part of "the previous node.
tmp->link = q->link;
q->link = tmp;
Here q is pointing to the previous node. After statement 1, link of inserted node will point to the 1
node and after statement 2 link of previous node will point to the inserted node.
If the node is to be inserted at the end then also the above two statements would work. In that,
pointer q will point to the last node, hence q->link will be NULL. So after statement 1, link of inse

pth
re and Union
will have NULL hence it wilf become the last node.
15.6 Deletion From A Linked List
313
-
deleting a node from the linked list, first we traverse the linked list and compare with each element.
finding the element there may be two cases for deletion-
Deletion of first node
Deletion of a node in between or at the el}d.
deletion of nodes also requires adjustment of links. These link manipulations will delete the node
the linked list, but it will still occupy memory. Since the memory for each node was dynamically
ated by us, so it is our responsibility to release that memory after deletion of the node. To release
memory we'll use the function free( ), and for that we'll need a pointer to the node that has to
deleted. :We'll take a pointer trnp that will point to the node to be deleted and after deletion of the
'e we'll call free as-
free(trnp);
.15.7 Deletion of First Node
start
1
10°1°1
!
l ~
.
r---I ~2000
1000
~.
trnp
.1600~
1600
1400
;e
:d
-
ce the node to oe deleted is the first node hence tmp will be assigned the address of first node.
trnp = start;
now trnp points to the first node, which has to be deleted.

Creation of list is very simple if you have understood the above operations. It is similar to insert
of an element at the end of the list. Initially we'll allocate memory for a node as-
tmp = malloc(sizeof(struct node»;
tmp->info = data;
tmp->link = NULL;
If the list is empty and we are inserting the first element, then we'll have to initialize the pointer s
as-
Since start points to the first node of linked list, so start->link will point to the second node of lin!<
list. After deletion of first node, the second node would become the first one, so start should be assign
the address of the second node as-
start = start->link;
Now we should free the element to be deleted, which is pointed to by tmp.
free( tmp );
10.15.8 Deletion of a Node in Between" or
~t the End
C in DeI-
1000
start
We'll traverse the list and obtain a pointer which points to the node that is just before the node to
deleted. Suppose this pointer is q, so the node to bedeleted will be pointed by q->link, hence we 'i
assign this value to tmp as-
tmp = q->link;
So now tmp will point to the node to be deleted.
Now we'll assign the link part of the node to be deleted to the link part of the previous node. T
can be done, as-
<.
q->link = tmp->link;
Now link of previous node will point to node that is just after the node to be deleted.
Finally we'll free the deleted node as":
free(tmp);
If node to be deleted is last node of linked list then second statement can be written as-
q->link = NULL;
10.15.9 Creation Of List
314

pt
re and Union
315
k
n
if ( start = = NULL) /*If list is empty */
start ~ tmp;
that we'll keep on inserting new nodes at the end of the list.
we are in a position to write a program that creates a linked list and performs 'operations on it.
operation has been implemented inside a separate function, The pointer start is taken as global
t all functions can access it and it makes our program simple, If we declare start inside mainO
e'll,have to pass it to all other fUij.ctions and use a pointer to pointer inside those functions,
be
'ill
:::'0,15
Program
of
single
linked
list*/
-=.::lude
<stdio, h>
-::lude
<malloc.h>
-:.:ct
node
int
info;
struct
node
*link;
.s=art;
( )
int
choice,n,m,position,i;
while (1)
{
printf (" 1. Create
List \n") ;
printf("2.Add
at
begining\n");
printf ("3 .Add
after
\n");
printf("4.Delete\n");
printf("5.Display\n");
printf.("6.Search\n") ;
printf("7.Quit\n") ;
printf ("Enter
your
choice
") ;
scanf("%d",&choice);
switch(choice)
{
case
1:
start=NULL;
printf ("How
many
nodes
you
want
") ;
scanf ( "%d" , &n) ;
for(i=O;i<n;i++)
{
printf ("Enter
the
element
scanf("%d",&m) ;
create_list (m) ;
\\) ;
rt
}
break;
case
2:
printf ("Enter
the
elem~nt
scanf ("%d" ,&m) ;
addatbeg (m) ; .
break;
case
3:
\\) i

316
C in Del
printf ("EntGr
the
elemen.t
") ;
scanf ("%d" ,&m) ;
printf ("Enter
the
position
after
which
this
element
inserted
");
scanf("%d",&position);
addafter(m,position);
break;
case
4:
if (start==NULL)
{
printf ("List
is
empty\n");
continue;
}
printf ("Enter
the
element
scanf ("%d" ,&m) ;
del (m) ;
break;
cas·e
5:
display ( ) ;
break;
case
6:
printf ("Enter
the
element
scanf ("%d", &m) ;
search (m) ;
break;
case
7:
exi t
( ) ;
default:
printf ("Wrong
choice\n");
}/*End
of
switch*/
}/*End
of
while*/
}/*End
of
main() */
create_list(int
data)
{
struct
node
*q, *tmp;
tmp=malloc(sizeof(struct
node));
tmp->info=data;
tmp->link=NULL;
if (start==NULL)/ * If
list
is
empty* /
start=tmp;
else
/*Element
inserted
at
the
end*/
q=start;
while(q->link!=NULL)
qj=q->link;
q->link=tmp;
}
}/*J2nd
of
create_list ( )*/.
for deletion~
to
be
searched
" ) ;

lep
re and Union
- tbeg(int
data)
struct
node
*tmp,
-mp=malloc(sizeof(structnode»,
mp->info=data,
mp->link=start,
start
tmp,
~3nd
of
addatbeg ( ) * 1
-- fter(int
da.ta,
int
pos)
struct
node
*tmp,
*q,
int
i,
q=start;
=or(i=O,i<pos-l,i++)
{
q=q->link,
if (q==NULL)
{
printf ("There
are
less
than
%d
elements",
pos),
return,
}
} 1*End
of
for* 1
tmp=malloc(sizeof(struct
noae)),
tmp->link=q->link,
tmp->info=data,
q->link=tmp,
~
cr nd
of
addaft_er() * I
-.
-=:(int
data)
struct
node
*tmp, *q,
if(start->info==data)
{
tmp=start,
start=start->link,
I*First
element
deleted*1
.free (tmp) ,
return,
}
. q=start,
while(q->link->link!=NULL)
{
if(q->link->info==data)/*Element
deleted
in
between*1
{
tmp=q->link,
q->link=tmp->link,
free(tmp);
return,
}
q=q~>link,
}/*End
of
while
*1
,
317

..
318
if (q->link->info==data)
/*Last
element
deleted* /
{
tmp=q->link;
free(tmp) ;
q->link=NULL;
return;
}
printf ("Element
%d
not
found\n", data) ;
}/*End
of
del( )*/
C in Del
display ( )
{
struct
node
*q;
if(start==NULL)
{
printf ("List
is
empty\n");
return;
q=start;
printf ("List
is
: \n") ;
while(q!=NULL)
{
printf ("%d
", q->info) ;
q=q->link;
}
printf (" \n") ;
}/ *End
of
display (
* /
search (int
data)
{
struct
node
*ptr=start;
int
pos=l;
while(ptr!=NULL)
{
if (ptr->info==data)
{
printf("Item
%d
found
at
position
%d\n",data,pos);
return;
}
ptr=ptr->link;
pos++;
}
if (ptr==NULL)
printf ("Item
%d
not
found
in
list\n", data);
}/*End
of
search( )*/
10.15.10·
Reversing A Linked List
Let us take a linked list-

._-~ and Union
319
'Pt
start
~25
1400
'~120
1600
115
1000
want to reverse this linked list. Reverse of this linked list will satisfy the following conditions-
-
t node will b~come the last node of linked list.
t node will become the first node of linked list and now start will point to it.
of 2nd node will point to 151 node, link of 3'd node will point to second node and' so Oll'.
of last node will point to the previous node of last node in linked list.'
~.•.
ersed linked list will be as-
.
start
.
....._ ......&.1..on Of reverse( )
take three pointers pI, p2 and p3. Initially pI, p2 and p3 will point to first, second and third
.:- linked list.
_
= start;
-
= pI -> link;
_
= p2 -> link;
start
reverse list first node will become the last node, so link part of first node should be NULL.
__->link = NULL;

.,
320
C in j
The link of second node should point to first node hence
p2->link = pI;
Now we will traverse the linked list with p3 pointer and shift pointers pI and p2 forward. We •
pI to the link part of p2, so that link of each node will now point to its previous node.
p2->link=pl;
while(p3!=NULL)
{
pl=p2;
p2=p3;
p3=p3->link;
p2->link=pl;
}
When this loop will terminate p3 will be NULL, p2 will point to last node, and li~
now point to its previous node. Now start should point to the last node of the linked list, which.
node of reversed linked list.
start = p2;
start
114001---------------------.
p3==NULL
If the list contains only one element then there will be a problem in initializing p3, hence we
this condition in the beginning-
if ( start->link =
= NULL )
return;
Here is the function reverse that reverses a linked list.
reverse ( )
{
struct
node
*pl, *p2, *p3;
if (start->link==NULL)
/ *if
only
one
element
in
the
list * /
return;
pl=start;
p2=pl->link;
p3=p2->link;
pl->link=NULL;
p2->link=pl;

321
pl==p2;
p2==p3;
p3==p3->link;
p2->link==p1;
re and· Union
. hile (p3 ! ==NULL)
{
}
start==p2;
=d
of
reverse (
* I
.16
union
} ;
structure variables, the union variables can be declared along with the definition or separately. For
le-
a
is a derived data type like structure and it can also contain members of different data types. The
used for definition of a union, declaration of union variables and for accessing members is similar
Ie
used in structures, but here keyword union is used instead of struct. The main difference between
and structure is in the way memory is allocated for the members. In a structure each member
own memory location, whereas members of union share the same memory location. When a .
Ie of type union is declared, compiler allocates sufficient memory to hold the largest member in
~on. Since all members share the same memory location hence we can use only one member at
e. Thus union is used for saving memory. The concept of union is useful when it is not necessary
e all members of the union at a time.
.
.
syntax of definition of a union is-
--
n
union_name{
dataype
member1;
data type
member2;
n
union_name {
datatype
member1;
data type
member2;
}variable_name;
-- can also be declared as-
union union_name variable_name;
- can access' the union members using the same syntax used for structures. If we have a union variable
the members can be accessed using dot(.) operator, and if we have a pointer to union then the
bers can be accessed using the arrow (-» operator.
?lO .16
Program
for· accessing
union
members* I
-- clude<stdio.h>
--':'n ( )
union
resul t (
int
marks;
char
grade;
float. per;

322
C in Depth
}res;
res.marks=90;
printf("Marks
%d\n",res.marks);
res. grade= 'A' ;
printf("Grade
%c\n",res.grade);
res.per=85.5;
printf("Percentage
%f\n",res.per);
} ;
union
utag{
compare the memory allocated for
a
union and structu
""
/*
P10.17
Program to
variable*/
#include<stdio.h>
struct
stag{
union
utaguvar;
struct
stag
svar;
printf ("Size
of
svar
%u\n", sizeof (svar) ) ;
printf ("Address
of
svar
%u \ t" ,&svar) ;
printf ("Address
of
members
%u
%u
%u \n" ,&svat. c, &svar. i, &svar.
printf ("Size
of
uvar
=
%u \n", sizeof (uvar) ) ;
main(
{
char
c;
int
i;
float
f;
}
Output:
Marks: 90
Grade: A
Percentage: 85.500000
Before the first printf, the value 90 is assigned to the union member marks, so other members grad
and per contain garbage value. After first printf, "the value 'A' is assigned to the union member gradl
So now the other two members marks and per contain garbage value. Only one member of union ca
hold yalue at a time, don't try to use all the members simultaneously. So a union variable of type resu
can be treated as either an int variable or char .variable or a float variable. It is the responsibility I
the programmer to keep track of member that currently holds the value.
Union variables can also be initialized, but there is a limitation. We know that due to sharing of memOI
all the members can't hold values simultaneously. So during initialization also only one member can
given an initial value, and this privilege is given to the first member. Hence only the first member
a union can be given an initial value. The type of the initializer should match with the type of the fi:
member. For example, we can initialize the above union variable as-
union result res ={78};
Now we'll take a program and compare the memory allocated for a union and structure variable
char
c;
int
i;
float
f;

pth
re and Union
323
'ade
ade
car.
sui:
( 0:
_rintf("Address
of
uvar
%u\t",&uvar);
printf ("Address
of
members
%u
%u
%u \n" ,&uvar. c, &uvar. i, &uvar. f) ;
nt :
ize of svar = 7
Address of svar : 65514 Address of members: 65514 65515 65517
ize of uvar = 4
Address of uvar,: 65522 Address of members: 65522 65522 65522
65514
65515
65516
65517
65518
65519
65520
I
I~I
I----'--~I
I
I
--..
~..
~ ---f-----+~
65522
65523
65524
65525
orr
lbf
r 0:
fir
o...
) ;
.-C--.
.--i--.~
.~---~ f-------.~
addresses of member~ of a union are same while the addresses of members of a structure are
-.;.rent. The difference in the sizes ofvariables svar and uvar also indicates that union is very economical
e use of memory. Note that the sizes of both union and structure variables may be affected by
~ . g as discussed previously.
cture may be a member of union or a union may be a member of structure. For example-
-"on
result
int
marks;
char
grade;
.::::=uct
res
char
name [15] ;
int
age;
union
result
performance;
data;
data is the structure variable of type struct res. It has three members, an agay of characters name,
integer age and a union member performance. Union will take only one value at a time, either an
- ger value marks or a character value grade. This can also be written as-
=::ruct
res
char
name [15] ;
intage;
union
resul t

324
C in Dept.
int
marks;
char
grade;
}
performance;
}data;
If we want to use the member grade then we can write-
data.performance.grade
Similarly to use the mem~er marks we can write-
-~
data.performance.marks
I
Some other features of union are-
(1)
Arrays of unions can be declared.
(2)
Functions can take union variable as arguments and can return union variables.
(3)
Pointers to unions can be declared.
(4)
Unions can be nested:
(5)
Unions can be self referential like structures.
Besides saving memory space, unions can be helpful in other situations also. We can use unions
declare an array that can hold values -of different data type. The program below shows this-
/*P10 .18
Program that
uses
an - array
of
union
to
hold
values
of
differel
data
types * /
#include<stdio.h>
union
num{
int
i;
long
int
1;
float
f;
double
d;
} ;
main(
union
num
arr [10J; /*Size
of
this
array
will
be
10*sizeof (double)
arr[0].i=12;
arr[11.l=400000;
arr[2J .f=11.12;
arr[3] .d=23 .34;
printf ("%d\t", arr[OJ . i);
'printf("%ld\t" ,arr[lJ .1);
pr int f ( "% f \ t" , arr [2] . f) ;
printf("%f\n" ,arr[3] .d);
}
Output:
12
400000
11.120000
23.340000
Unions are also helpful in low level programming. We may manipulate the individual bytes in a d
type using union. For example we can find whethera given machine's byte order is little-endian or b
endian. First we'll see what is a machine's byte order and then we'll write a program to deterrn
the same.
The byte order of a machine specifies the order in which a multibyte data item is stored in mem(

7th "'=-::'JTie and Union
325
ary representation of integer· 5193 in 2 bytes is-
big-endian
little-endian
:- Howing figure shows how this integer is stored in different byte orders.
010100
01001001
~~
S Byte
L S Byte
There are two common byte orders.
Most significant byte is stored at the lowest address
Least significant byte is stored at the lowest address.
-
ily of processors use little-endian byte order, Motorola family of processors use big-endian
_ er.
to
2000
2001
0100 1001
0001 0100
LSB
MSB
.2000
2001
0001 0100
0100 1001
MSB
LSB
at
e-endian, the least significant byte is stored at the lower address(2000), while the most significant
- stored at the higher address(200 I). In big-endian the MSB is stored at the lower address(2000),
_ the LSB is stored at the higher address(2001).
- Howing program determines the byte order of a machine-
-:
.19
Program
to·· determine
the
byte
order
of
a·
machine* /
-.::::':'ude<stdio.h>
'/
_nion{
int
x;
char
c [2J;
}var;
ar.x=l;
':'f(var.c[OJ==l)
printf("Little
endian\n");
else
printf ("Big
Endian\n");
ake our program portable we can take the size of character array to be. equal to the size of int
- e machine by specifying sizeof operator.
e above example we had examined individual bytes of int data type, we may take any other data
also. For example in. the next example we can examine the individual bytes of a variable of type
_ t stu-
_= ct
student {
char
name [30J;
int
age;

326
union{
} ;
int
class;
C in De
struct
student
stu;
char
c [sizeof (student)] ;
}var;
Now we can access the information stored in var.stu bytewise, this may be helpful in writing the struc
variable var to any file byte by byte.
10.17 typedef
The type definition facility allows us to define a new name for an existing data type. The general SYJI
is-
typedef data_type new_name;
Here typedef is a keywo~d,
data~type is any existing data type that rna
be a standard data typ
a user defined type, new_name is an identifier, which is a new name for thi
data type. Note
tha~
are not creating any new data type but we are only creating a new name for the existing data t]
For example we can define a new name for int type by writing-
typedef int marks;
Now marks is a synonym for int and VIe can use marks instead of int anywhere in the progra
example-
~arks sub I, sub2;
Here subI, sub2 are actually int variables and are similar to any variable declared using int keyw
The above declaration is equivalent to-
.
int sub1, sub2;
Some more examples are-
typdef usigned long int ulint;
typedef float real;
Here ulint is another name for type unsigned long int, and real is another name for float. The typ
declaration can be written wherever other declarations are allowed. We can give more than one n
to a single data type using only one typedef statement. For example-
typedef int age, marks, units;
In the above typedef statement, we have defined three names for the data type int.
Since typedef is syntactically considered as a storage class, so we can't include a storage class in typ
statement. For example statements of these types are invalid-
typedef static char schar;
typedef-extem int marks;
Now we'll see how typdef can be used to define new names for pointers, arrays, functions and struct
1.
Pointers
typedef float *fptr;
After this statement, fptr is a synonym for float * or pointer to float. Now consider this declara

cture and Union
327
fptr p, q, *r;
-
e p and q are declared as pointer to float, while r is declared as a pointer to pointer to float.
Array
typedef int intarr[10];
- er this statement intarr is another name for integer arrays of size 10. Now consider this declaration
ement-
intarr a, b, c[15]; ( Equivalent to ~ inta[10], b[10], c[15][10]; )
-ere a, b are declared as 1-D arrays of size 10, and c is declared as 2-D array of size 15x10.
Functions
typedef float funct(float, int);
-
e funct is any function that takes two values, one float and one int and returns a floa~-:--~
-
iW consider this declaration statement-
_
-
/
funct add, sub, mul, div;
add, sub, mul, div are declared as functions that take a float and int value and return a float value.
- e above statement is equivalent to the following /declaration
sta~ements-
float add(float, int);
/
float sub(float, int);
float mul(float, int);
float ,div(float, int);
-.
Structures
_rrnilarly we can also use typedef for defining a new name for structures. Suppose we have this structure
'tion-
-=-=ruct
studentrec {
char
name[20];
int
marks;
} ;
_- w whenever we want to use this structure we have to write struct /studentrec. We can give a short
d meaningful name to this structure by typedef.
I
typedef struct studentrec Student;
_-ow we can declare variable like this-
Student stu1, stu2; (Equivalent to ~ struct studentrec stu1, stu2;)
e can also combine typedef and structure definition. The syntax. is as-
=:''Pedef
struct
tagname {
!
datatype
memberl;
}newname;
~e tagname can be same as the newname. We can omit the tagname ifthe structure is not selfrefrential.
/
=::pedef
struct

...
328
C in Depth
char
narne(20];
int
age;
}person;
person
student,teacher,ernp;
Here person is a new name for thi~ structure and we have defined three structure vari~bles, which hav!
the format of the above definition.
In our linked list
structure~ definition, we can write-
typedef
struct
node
{
int
i tern;
struct
node
*lihk;
}node;
Now we can use node instead of struct node anywhere in our program-
node *start, *ptr;
Here new name is same as that of tagname. Here we can't omit the tagname since we have to definl
a pointer to the same structure inside the structure.
Advantages of using typedH
1.
It makes our programs more readable and understandable since we can document our progran
by giving meaningful and descriptive names for existing types.
2.
In structures it is important since we can give a single name to the structure, we need not wrin
struct keyword repeatedly.
3.
It makes our programs more portable. When program is run on a different machine on whicl
standard data types are represented by' different number of bytes, only typedef statement has tl
be changed.
The typedef declarations may seem similar to #define directives, but they are different. The basic differenc
is that the typedef declarations are interpreted by the compiler while #define directives are, processe
by the preprocessor. In #define directive we can define an expansion for any text while in typedef w
can only define new names for data types only. The following program shows the difference betwee
#define directive and typdef declaration.
;*P10. 20Prograrn to understand the difference between #define and typedef*
#include<stdio.h>
#define
fp
float
*
rnain( )
{
fp
pl, p2 , p3 ;
typedef
float
* fptr;
fptr
ptrl, ptr2, ptr3;
printf ("%u
%u
%u\n", sizeof (pl), sizeof (p2), sizeof (p3));
printf ("%u
%u
%u\n", sizeof (ptrl) ,sizeof (ptr2) ,sizeof (ptr3) ) ;
Output:
244
222

'h
jZ:..:z::ue and Union
329
me output we can see that pI is declared as a pointer to float while p2 and p3 are declared as
ariables. Actually the preprocessor expanded the declaration as-
- oat *pl, p2, p3;
. g #define we could not successfully define a new name for pointer to float type.
°ablesptrl, ptr2, ptr3 are all declared as pointers to float, so typedef successfully defined a
mune for the type pointer to float.
Exercise
e that stdio.h is included in all programs.
in ( I
struct
A{
int
marks;
char
grade;
.}Al;
struct
A
Bl;
Al.marks=80;
AI. grade= 'A' ;
printf ("Marks
printf ("Grade
Bl
= AI;
printf ("Marks
printf ("Grade
ain ( I
struct
rec {
%d \ t" ,AI. marks
I i
%c\t" ,Al.grade
I;
%d\ t", Bl.marks
I;
%c\n",Bl.grade
I;
char
*name;
int
age;
}*ptr;
char
namel [10] ="Somalika";
ptr->name=namel;
ptr->age=93;
printf("%s\t",ptr->name);
printf("%d\n",ptr->age) ;
}
struct
student
ain ( )
{
char
name[20];
int
age;
};
struct
student
stul= {"Ani ta" , 1 O}, stu2= {"Ani ta" , 12} ;
if(stul==stu2)
printf("Same\n");
else
printf'( "Not
same\n");
:nain(

no
Ci
struct
tag{
int
i;
char
c;
} ;
struct
tag
var= {2, 's' } ;
. rune (var) ;
}
func (struct
tag
v)
{
printr("%d
%c\n",v.i,v.c);
(5) main (
struct
tag {
int
i;
char
c;
} ;
struct
tag
var={2,'s'};
func(var) ;
}
func (struct {int
i;
char
c;}
v
{
printr("%d
%c\n",v.i,v.c);
(6) struct
tag{
int
void
func (struct
main ( )
{
i;
char.
tag) ;
c; } ;
struct
tag
var={12,'c'};
func(var) ;
printf("%d\n",var.i);
}
void
rune (struct
tag
var)
var. i++;
(7) struct
tag{
int
void
func (struct
main ( )
{
i;
char
tag
* ) ;
c; } ;
struct
tag
var={12,'c'};
rune (&var) ;
printf("%d\n",var.i) ;
}
void
func (struct
tag
*ptr)
ptr->i++;

%s\n", rec .name);
I
........,::""nlre and Union
include<string.h>
ain ( )
union
tag{
char
name [ 15] ; .
int
age;
}rec;
strcpy(rec.name, "So~alika");
rec.age=23;
printf ("Name
struct{
char
a[20];
int
b;
union{
double
c;
struct{
char
d[15];
float
e;
} x;
}y;
} z;
main(
printf ("%u
%u
%u\n", sizeof (z .y.x), sizeof (z .y), sizeof (z»;
-
)main(
{
typedef
short
int
unsigned
s_int
var
printf("%u",var);
-
)typedef
struct
tag{
int
i;
char
c;
}tag;
main ( )
{
struct
tag
vl={l,'a'};
tag
v2={2;'b'};
printf("%d
%c
%d
%c\n",vl.i,vl.c,v2.i,v2.c);
331
:2)typedef
typedef
main( )
{
struct
struct
{
{
char
name[20];
int
data;
node
int
age;
}stu;
*link;}node;
·stu
*p=malloc(sizeof(stu»;
node· *ptr=malloc(sizeof(node»;
p->age·=3 0;
ptr;->data=3;

332
C in D
print f (" %d
%d \n" , p->age, ptr->data) ;
Programming Exercise
1.
Write a program to accept name, age and address of five persons and display the name of e
person.
2.
Write a program to accept name and arrival time of five trains and display the name with Rail
time format.
(Note: For example 2PM is written as 14.00 )
3.
Write a program to accept 10 records with the structure-
struct {
char
*name;
int
*age;
float
salary;
}
Display the records before sorting and after sorting. Sorting is based on the primary key ru
and secondary keyage.
4.
Write a program to
~ccept five records of employee. The structure is-
struct{
.
char
name [25] ;
int
age;
int
basic;
}
Calculate the total slary of the employees as-
Total salary = Basic + DA + HRA
DA = 10% of basic
HRA = 5% of basic
Display the name, age and total salary of the employees in descending order on the basis of
.salary..
5.
Write a program to concatenate one linked list at the end of another.
6.
Write a program to remove first node of the list and insert it at the end.
7.
Write a program to count the number of occurrences of an element in the list.
8.
Find the largest and smallest element of a linked list, print total of all elements and find ou
average.
·9.
Write a program that maintains records of students using linked list. The structure of nod
list would be-
struct
node {
char
name [20] ;
int
rollno;
int
marks;
struct
node
*link;
}
Now search a particular record based on roll number.
Answers
(1)
Marks = 80
Grade = A
Marks = 80
Grade = A

re and Union
333
omalika
93
Error, illegal structure operation. Since relational operators can't be used with structures. If we
want to compare them then we'll have to make a function that compare all the members one by
one.
Error: undefined symbol i, and undefined symbol c. ;The structure definition is written inside mainO,
so it can't be accessed by function func( ). It should be written before main( ) so that it is accessible
o all functions.
2
s
12
13
Garbage value will be printed, because currently the member age has been assigned a value.
19 19 41
Size of innermost structure is 19(15+4). The union contains two members of sizes 15 and 19,
so the size of union is 19. The size of outermost structure is 41(20+2+19).
This program will give errors, since it not valid to combine type specifiers(unsigned, long) with
typedef names.
) 1 a 2 b
The first typedef declaration is correct but the second one is not correct. Since in the second
declaration the structure is self referential so we can't omit the structure tag.
<--

Chapter 11
Files
There are two ways of storing <hta in files, binary format and text format. In text format, data is ston
as lines of characters with each line terminated by a newline character('\n'). In binary format, data
stored on the disk in the same way as it is represented in the computer memory. Unix system dOl
not make any distinction between text file and binary files.
Text files are in human readable form and they can be created and read using any text editor, whi
binary files are not in human readable form and they can be created and read only by specific progran
written for them. The binary data stored in the file can't be read using a text editor.
The integer 1679 will take only 2 bytes in a binary file while it will occupy 4 bytes in a text file becau:
in-binary file it is stored as an integer. while in text file it is stored as a sequence of 4 characters i.
'I', '6', '7', '9'.
The hexadecimal value of 1679 is Ox068F, so in binary format it is represented by the two bytes Ox(
and Ox8F. In a text file, this number 1679 is represented by the bytes Ox31, Ox36, Ox37, Ox39(ASC
values).
Text And Binary Modes
11.1
The input and output operations that we have performed so far were done through screen and keyboaJ
only. After termination of program, all the entered data is lost because primary memory is volatile..
the data has to be used later, ihen it becomes necessary to keep it in permanent storage device. C suppor
the concept of files through which data can be stored on the disk or secondary storage device. n
stored data can be read whenever req~ired. A file is a collection of related data placed on the dis]
The file handling in C can be broadly categorized in two types-
•
. High level(standard files or stream oriented files)
•
Lowlevel(system oriented files)
High level file handling is managed by library functions while low leyel file handling is managed by syste
calls. The high level file handling is commonly used since it is easier to manage and hides most of tl
details from the programmer. In this chapter we'll discuss about high level file handling only.
The header file stdio.h should be included in the program to make use of the I/O functions. We hm
already perfQrmed I/O with screen and keyboard using functions like scanf( ), printf( ), gets( ), puts(
getchar( ) and putchar( ). The advantage of using stream oriented file I/O is that the I/O in files
somewhat similar to the screen, keyboard I/O. For example we have functions like fscanf('), fprintf(
fgets( ), fputs( ) which are equivalent to the functions that we have studied earlier.

Binary
Text
0000
0011
0110
0001
1000
0011
1111
0110
0011
0111
0011
1001
335
text files and binary files keep record of the length of the file, and identify the end of file when
length is reached. In text files, there is one more way to detect the end of file. The character with
value 26 is considered to be the end of file character in text files. All input functions stop reading
a text file when this character is encountered and return an end of file signal to the program.
-
s ~ot insert this character in the file, it can be entered through the keyboard by Ctr!+Z( or Ctr!
::> on some systems). In binary files no such character represents the end of file.
- xt files newline is stored as a combination of carriage return '\r'( ASCII 13 ) and linefeed '\n'(ASCII
while in binary files newline is stored only as '\n'(ASCII 10).
inary format, the data is stored in the same way as it is represented in memory so no conversions
to take place while transferring of data between memory and file. I!1 text format some conversions"
~ to take place while transferring data between memory and file. For example while writing to a
file "newline('\n') has to be converted to a combination of i\r' and '\n' and while reading from a
file this combination ('\n' and '\r') is converted back to '\n'.
input and output "operations in binary files take less time as compared to that of text files because
. ary files no conversions have to take place. However the data written using binary format is not
. portable since the size of data types and byte order may be different on different machines. In
format, these problems do not arise so it is. considered more portable.
.2
Concept Of Buffer
r is an area in memory where the data is temporarily stored before being written to the file. When
_ open a file, a buffer is automatically associated with its file pointer. Whatever data we send to the
. not immediately written to the file. First it is sent to the buffer and when the buffer is full then
=ontents are written to the file. When the file is closed, all the contents of buffer are automatically
en to the file even if the buffer is not full. This is called flushing the buffer, we can also explicjtly
-
the buffer by a function fflush( ) described later.
oncept of buffer is used to increase efficiency. Had there been no buffer we would have to access
isk each time for writing even single byte of data. This would have taken lot of time because each
the disk is accessed, the read/write head has to be repositioned. When buffering is done, the data
_oUected in the buffer and data "equal to the size of buffer is written to the file at a time, so the
er of times disk is accessed decreases, which improves the efficiency.
steps for file operations in C programming are as follows-
Open a file
Read the file or write data in the file
Close the file
functions fopen( ) and fclose( ) are used for opening and closing the files respectively.
.3 ~" Opening a File
e must be opened before any I/O operations can be performed on that file. The process of establishing
ection between the program and file is called opening the file.
cture named FILE is defined in the file stdio.h that contains all information about the file like
e, status, buffer size, current position, end of file status etc. All these details are hidden from the

336
programmer and the operating system takes care of all these things.
typedef
struct {
C in Dept
}FILE;
A file pointer is a pointer to a structure of type FILE. Whenever a file is opened, a structure of tYJ
FILE is associated with it, and a file pointer that points to this structure identifies this file. The. functi~
fopen( ) is used to open a file.
Declaration:
FILE .*fopen( const char *filename, const char *mode);
fopen( ) function takes two strings as arguments, the first one is the name of the file to be open
and the second one is the mode that decides which operations( read, write, append etc) are to
performed on the file. On success, fopen( ) returns a pointer of type FILE and on error it returns NUl!
The return value of fopen( ) is assigned to a FILE pointer declared previously. For example-
FILE *fpl, *fp2;
. ,
fp 1 = fopen ( "myfile.txt", "w" );
fp2 = fopen ( "yourfile:dat", "r" );
The name of a file is limitecrto FILENAME_MAX characters. After opening the file with fopen( ),
name of file is not used in the program for any operation on it. Whenever we have to perform a
operation on the file, we'll use the file pointer returned by fopen( ) function. So the name of file
sometimes known as external name, while the file pointer associated with it is· known as its inten
name. The second argument represents the mode in which the file is to be opened. The possible vall
of mode are-
l."w" ( write)
If the file doesn't exist then this mode creates a new file for writing, and if the file alreaciy exi~ts tJ
the previous data is erased and the new data entered is written to the file.
2.
"a"( append)
If the file doesn't exist then this mode creates a new file, and if the file already exists then the ]]
data entered is appended at the end of existing data. In this mode, the data existing in the file is
erased as in "w" mode.
3.
"r" ( read)
This mode is used for opening an existing file for reading purpose only. The file to be opened Il!
exist and the previous data of file is not erased.
i
4.
"w+" (-write+read )
This' mode is same as "w" mode but in this mode we can also read and modify the data. If the
doesn't exist then a new file is created and if the file exists then previous data is erased.
5.
"r+" ( read+write )
This mode is same as "r" mode but in this mode we can also write and modify existing data. The
to be opened must exist and the previous data of file is not erased. Since we can add new data
-- modify existing data so this mode is also called update mode.

337
+" ( append+read )
:ilOde is same as the "a" mode but in this mode we can also read the data stored in the file. If
e doesn't exist, a new file is created and if the file already exists then new data is appended at
of existing data. We cannot modify existing data in this mode.
'
a file in binary mode we can append 'b' to the mode, and to open the file in text mode 't'
_ appe'nded to the mode. But since text mode is the default mode, 't' is generally omitted while
g files in text mode. For example-
~"
Binary file opened in write mode
ab+"
or "a+b"
Binary file opened in append mode
+"
or "r+t" "
Text file opened in update mode
,It
Text file opened in write mode
.1
Errors in Opening Files
error occurs in opening the file, then fopen( ) returns NULL. So we can check for any errors
_
'ng by checking the return v"alue of fopen( ).
~
*fp;
=:: pen("text.dat","w");
=~==NULL)
_rintf("Error
in
opening
file");
exit (1) ;
in opening a file may occur due to various reasons, for example-
If we try to open a file in read or update mode, and the file doesn't exist or we do not have read
ermission on that file.
If we try to create a file but there is no space on the disk or we don't have write permission.
If we try to create a file that already exists and we don't have permission to delete that file.
Operating system limits the number of files that can be opened at a time and we are trying to
open more files than that number.
_ -an give full pathname to open a file. Suppose we want to open a file in DOS whose path is
oksdir\names.dat", then we'll "have to write as-
fp
= fopen(IE:\\booksdir\\names.dat", "r");
_ we have used double backslash because single backslash inside string is considered as an escape
ter, '\b' and '\n' will be regarded as escape sequences if we use single backslash. In Unix, a single
d slash can be used.
r give the mode in single quotes, since it is a string not a character constant.
fp = fopen("file.dat", 'w'); /*Error*/
Closing a File
file that was opened using fopen( ) function must be closed when no more operations are to be
ormed on it. After closing the file, connection between file and program is broken.
aration: int fclose(FILE *fptr);
losing the file, all the buffers associated with it are flushed i.e. all the data that is in the buffer

338
C in D,
is written to the file. The buffers allocated by the system for the file are freed after the file is clc
so that. these buffers can be available for other files. Some systems have a limitation on the mu
of file~ that can be opened at a time, so we should close the files that are not currently in use so
we can open other files.
Although all the files are closed automatically when the program terminates normally, but somet
it may be necessary to close the file by fclose( ) e.g. when we have to reopen the file in some (
mode or when we exceed the number of opened files permitted by the system. Moreover it is a
practice to close files explicitly by fclose( ) when no more operations are to be performed on the
because it becomes clear to the reader of the program that the file has no use now.
fclose( ) returns EOF on error and 0 on success( EOF is a constant defined in stdio.h and its \
is -1). An error in fclose( ) may occur when there is not sufficient space on the disk or wher
disk has been taken out of the 'drive.
If more than one files are opened, then we can close all the files by calling fclose( ) for each
fclose(fptrl) ;
fclose(fptr2) ;
We can also close multiple files by calling a single function fcloseall( ). It closes all the opened.
Declaration: int fcloseall(void);
On error, fcloseapc ) returns EOF and on success it returns the number of files closed. We can
it as-
,
\
n=fcloseall ( ) ;
if (n==EOF)
printf ("could
not
close
all
open
files\n");
else
printf ( "%d
files
success fully. closed\n" ,n) ;
11.5
End of File
...
The file reading functions need to know the end of file so that they can stop reading. When the
of file is reached, the operating system sends an end-of-file signal to the program. When the pro,
receives this signal, the file re'ading functions return EOF, which is a constant defined in the file Stl
and its value is -1. EOF is an integer value, so make sure that the return value of the function is assi
to an integer variable. Note that the value EOF is not present at the end of the file, it is returm
the file reading functions when end of file is reached.
11.6
main(
Structure of a General File Program
FILE
*fp;
fp=fopen("filename", "mode");
fclose
(
fp
);
}/*End
of
main
*/

339
Predefined File Pointers
::redefined constant file pointers are opened automatically when the program is executed.
File pointer
Device
stdin
Standard input device( Keyboard))
stdout
Standard output device( Screen)
stderr
Standard error output device (Screen)
tions used for file I/O are
cter I/O
- fgetc( ), fputc( ), getc( ), putc( )
_ - g I/O
- fgets( ), fputs( )
ger I/O
- getw( ), putw( )
-
atted I/O
- fscanf( ), fprintf( )
ord I/O
- fread( ), fwrite( )
- -cuss all these functions one by one in detail.
Character I/O
fputc ( )
lliE::.:z::r:!tion: int fputc( int c, FILE *fptr);
ction writes a character to the specified file at the current file position and then increments
position pointer. 'On success it returns an integer.representing the character written, and on error
EOF.·
understand
the
use
of
fputc ()
function* /
=-=::"E
*fptr;
--=~
ch;.
_~«fptr=fopen("myfile.txt",Ow") )==NULL)
printf ("File
does
not
exist\n");
exi t. ( ) ;
",::'se
printf ("Enter
text
: \n" ) ;
/*Press Ctrl+z in DOS and Ctrl+d in Unix to stop reading characters*/
while ( (ch=getchar ( ) ) ! =EOF)
fputc (ch, fptr);
::=:'ose (fptr) ;
!!l

C in De
The woods are lovely, dark and deep
But I have miles to go before I sleep.
/'Z
After the execution of this program, this text along with the /\Z character will be written to the
myfile.txt.
11.8.2
fgetc()
Declaration: int fgetc( FILE *fptr );
This function reads a single character from a given file and increments the file pointer position.
success it returns the character after converting it to an int without sign extension. On end of file
error it returns EOF. In the next program we'll read the file myfile.txt that we have created in the prevo
program.
/ *Pll. 2 . Program
to
understand
the
use
of
fgetc ( ) * /
#include<stdio.h>
main ( )
{
FILE
*p;
char
ch;
if( (p=fopen("myfile.txt", "r") )==NULL)
printf("This
file
doesn't
exist\n");
else
while«ch=fgetc(p»
!=EOF)
printf ("%c", ch);
}
fclose (p) ;
}
Output
The woods are lovely, dark and deep
But I have miles to go before I sleep.
The while loop that we have written in the program is equivalent to this
code~
ch=fgetc (p) ;
while(ch!=EOF)
{
printf("%c",chl;
fgetc(p) ;
}
The value returned by fputc( ) and fgetc( ) is not of type char but is of type int. This is because
functions return an integer value EOF(-l) on end of file or error. The variable ch that is used
t~
the character read from the file, is also declared to be of int type for this reason only.
11.8.3
getc() and putc( )
The operations of getc( ) and putc( ) are exactly similar to that of fgetc( ) and fputc( ), the only difl
is that the former two are defined as macros while the latter two are functions.

341
Integer I/O
.1
putw ( )
ation: int putw(int value, FILE *fptr)
function writes an integer value to the file pointed to by fptr. It returns the integer written to the
on success, and EOF on error.
::=:1.3
Program
to
understand
the
use
of
putw ()
function* /
-=clude<stdio.h>
-
()
FILE
*fptr;
int
value;
fptr=fopen("num.dat", "wb");
for(value=1;value<=30;value++)
putw(value~fptrl;
fclose (fptr) ;
.~ program will write integers from 1 to 30 into the file "num.dat".
.9.2
getw()
laration: int getw( FILE *fptr );
's function returns the integer value from the file associated with fptr. It returns the next integer
-
ill the input file on success, and EOF on error or end of file.
Pll.4
Program
to
understand
the
use
of
getw()
function*/
=:nclude<stdio.h>
-"'in( )
FILE
*fptr;
int
value;
fptr=£open("num.dat", "rb");
while( (value=getw(fptr)) !=EOF)
printf("%d\t",value);
fclose(fptrl;
This program will read and print integers from the file "num.dat" which was created earlier.
getw( ) is used with text files then it will stop reading if integer 26 is present in the file because
in text files end of file is· denoted by ASCII 26 which is also a valid integer value. So getw( ) should
not be used with text files.
The value of EOF is -1 which is a valid integer value, so this program will work correctly if -1 is not
present in file, if -1 exists in the file then getw( ) will stop reading and all the values beyond -1 will
be left unread. So we should use feof( ) to check end of file and ferror() to check error. These functions
are discussed later in this chapter.

- es
341
.9
Integer I/O
1.9.1
putw ( )
eclaration: int putw(int value, FILE *fptr)
-' function writes an integer value to the file pointed to by fptr. It returns the integer written to the
- e on success, and EOF on error.
XPll.3
Program. to
understand
the
use
of
putw()
function* /
::nclude<stdio.h>
-
in ( )
FILE
* fptr;
int
value;
fptr=fopen("num.dat", "wb");
for(value=1;value<=30;value++)
putw(value~fptr);
fclose(fptr) ;
program will write integers from 1 to 30 into the file "num.dat".
1.9.2
getw()
eclaration: int getw( FILE *fptr );
's function returns the integer value from the file associated with fptr. It returns the next integer
m the input file on success, and EOF on error or end of file.
xpll .4
Program
to
unders tand
the
use
of
getw ()
funct ion* /
-~nclude<stdio.h>
-
in( )
FILE
*fptr;
int
value;
fptr=£open("num.dat", "rb");
while ( (value=getw (fptr) ) ! =EOF)
printf("%d\t",value);
fclose (fptr) ;
's program will read and print integers from the file "num.dat" which was created earlier.
..: getw( ) is used with text files then it will stop reading if integer 26 is present in the file because
text files end of file is denoted by ASCII 26 which is also a valid integer value. So getw( ) should
t be used with text files.
- e val~e of EOF is -1 which is a valid integer value, so this program will work correctly if -1 is not
ent in file, if -1 exists in the file then getw( ) will stop reading and all the values beyond -1 will
_ left unread. So we should use feof( ) to check end of file and ferror() to check error. These functions
discussed later in this chapter.
s

342
11.10
String I/O
11.10.1 fputs()
C in Dept"
Declaration: int fputs(const char *str, FILE *fptr);
This function writes the null terminated string pointed to by str to a file. The null character that mark
the end of string is not written to the file. On success it returns the last character written and on erro
it returns EOF.
I *Pli. 5
Program
to
understand
the
use
of
fputs ( ) * I
#include<stdio.h>
main ( )
{
FILE
*fptr;
char
str[80j;
fptr=fopen("test.txt", "w");
printf ( "Enter
the
text \n" ) ;
printf ("To
stop
entering,
press
Ctrl+d
in
Unix
and
Ctrl+z
in
Dos\n")
while (gets (str) ! =NULL)
fputs(str,fptr);
fclose(fptr) ;
Suppose we enter this text after running the program~
Yesterday is history
Tomorrow is mystery
Today is a gift
That's why it is called Present
/''Z
When the first line of text is entered and Enter key is pressed, the function gets( ) converts the newlil
character to the null character and the array str contains "Yesterday is history"( 20 characters +1 m
character). Now str is written to the file testtxt using fputs( ). The mill character is not written
the file, so only 20 characters are written.
In previous chapters we had studied about the function puts( ) that prints the string on the scree
The difference between these two functions is that puts( ) translates null character to a newline, b
fputs( ) does not. fputs( ) will write a newline character to the file only if it is contained in the strin
So after the first line of text newline character is not entered in the file. Immediately after the first lu
of text, the second one is written. In the next program we'll see how to read this file using fgets(
11.10.2 fgets( )
Declaration: char *fgets(char *str, int n, FILE *fptr);
This function is used to read characters from a file and these characters are stored in the string pointl
to by str. It reads at most n-1 characters from the file where n is the second argument. fptr is a fi
pointer which points to the file from which characters are read. This function returns the string point
to by str on success, and on error or end of file it returns NULL.
This function reads characters from the file until either a newline or an end of file is encountered
till n-1 characters have been read. It ~ppends a null character ( '\0' ) after the last character read
terminate the string. The following program reads characters from the file testtxt that we had creat

343
_=-_6
Program
to
understand
the
use
of
fgets()*/
=-_de<stdio.h>
.:. _::'E
*fptr;
=.::ar
str[80];
:_-r=fopen("test.txt". "r");
:...ile (fgets (str. 80. fptr) ! =NULL)
puts(str);
::::lose(fptr) ;
"":L:::rt"
y is historyTomorrow is mysteryToday is a giftThat's· why it is called P
-
we call the fgets( ) function with second argument as 20, then the output would be-
y is histor
orow is Myster
_ is a giftTha
it is calle
ent
fgets( ) was called with se.cond argument as 80, then it read 79 characters from the file and
em in array str and appended a null character. Now str was passed to puts( ), so the string
_ displayed on the screen. The function puts( ) converts the null character of string to a newline,
displaying the string a newline is displayed. In the second iteration of the loop, the function
encounters end of file after reading 6 characters only so it stops reading, stores these characters
appends a null character and displays str on the screen using puts( ). When fgetsO was cailed
-econd argument as 20 , then it read 19 characters from the file.
reads characters from the standard input while fgets( ) reads from a file. The difference between
and gets( ) is that fgets( ) does not replace the newline character read by the null character,
ets( ) does. If fgets( ) reads a newline, then both newline and null character will be present
final string.
) it may be possible that input is more than the size of array, since C does not check for array .
-~ so an overflow may occur but in fgets( ) we can limit the size ofinput with the help of second
nt.
Forniatted I/O
- 'e studied about functions which can output and input characters, integers or strings from files.
-~xt two functions that we are going to study now, can input and output a combination of all of
- - a formatted way. Formatting in files is generally used when there is a need to display data on
or print data in some format.
.1 fprintf ( )
fprintf ( FILE *fptr, const char *format [, argument, ... ] );

344
r in De
This function is same as the printf ( ) function but it writes formatted data into the file instead of
standard output(screen). This function has same parameters as in printf( ) but it has one additi
parameter which is a pointer of FILE type, that points to the file to which the output is to be w .
It returns the number of characters· output to the file on success, and EOF on error.
/ *Pll. 7
Program
to
understand
the
use
of
fprintf ( ) * /
#include<stdio.h>
main( )
{
FILE
*fp;
cha:z;: .name[lO];
int
age;
fp=fopen (" rec. dat", "w") ;
printf (I' Enter
your
name
and
age
) ;
scanf("%s%d",name,&age) ;
fprintf(fp,"My
name
is
%s
and .aile
is
%d",name,age);
fclose (fp) ;
/*Pl1.8
Program
to
understand
the
use
of
fprintf() */
#include<stdio.h>
struct
student
char
name [ 20] ;
float
marks;
}stu;
main( )
{
FILE
*fp;
int
i,n;
fp=fopen("students.dat", "w");
~rintf ("Enter
number
of
records
");
scanf ("%d"; &n);
for(i=l;i<=n;i++)
{
printf ( "Enter
name
and .marks
" ) ;
scanf("%s%f",stu.name,&stu.m~rks);
fprintf (fp, "%s
%f", stu.name, stu.marks);
11.11.2 fscanf ( )
Declaration: fscanf ( FILE *fptr, const char *format [, address, ... ] );
This function is similar to the scanf ( ) function but it reads data from file instead of standard i
so it has one more parameter which is a pointer of FILE type and it points to the file from which
will be read. It returns the number of arguments that were assigned some values on success, and
at the end of file.
In the next program we'll read the file students.dat that we have created using fprintf( ) in Pl1.8.
that the forrhat string used in fscanf( ) should be same as the format string used in fprintf( ) .
writing to the file.

345
?11.9
Program
to
understand
the
use
of
fscanf (
* /
~clude<stdio.h>
-
ct
student
char
name [20] ;
float
marks;
~=
i
-=::l( )
FILE
*fopen(),*fp;
fp=fopen(~students.dat","r");
printf ("NAME\tMARKS\n");
while(fscanf(fp, "%s%f",stu.name,&stu.marks) !=EOF)
printf("%s\t%f\n",stu.narne,stu.marks) ;
fclose (fp) ;
~ had mentioned earlier that the file pointers stdout and stdin are automatically opened. If we use
e file pointers (n the functions fprintf( ) and fscanf( ), then these function calls become equivalent
rintf( ) and scanf( ).
e replace the file pointer fp by stdout then-
fprintf( stdout, "My age is %s" , age); is equivalent to printf("My age is %d", age);
we replace the file pointer fp by stdin then-
fscanf(stdin, "%s%d''', name, &age); is equivalent to scanf("%s%d", name, &age);
.12
Block Read / Write
useful to store blocks of data into file rather than individual elements. Each block has some fixed
it may be a structure or an array. It is easy to read the entire block from file or write tlTe entire
k to the file. There are two useful functions for this purpose- fread( ) and fwrite( ). Although we
read or write any type of data varying from a single character to arrays and structures through
e functions, these are mainly used to read and write structures and arrays.
using these functions, the file is generally opened in binary mode( e.g. "wb", "rb" ).
.12.1 fwrite( )
's function is used for writing an entire block to a given file.
laration: size_t fwrite( const void *ptr, size_t size, size_t n, FILE *fptr );
e t is defined in stdio.h as-
typedef unsigned int size_t ;
is a pointer which points to the block of memory that contains the information to be written to
file, size denotes the length of each item in bytes, n is the number of items to be written to the
e, and fptr is a FILE pointer which points to the file to which the data is written.
"" successful, fwrite( ) will write n items or total ( n * size) bytes to the file and will return n. On
or or end of file it will return a number less than n.
-0 write a single float value contained in variable fval to the file

346
C in Depth
fwrite( &fval, sizeof(float), 1, fp);
To write an array of integers arr[ 10] to the file.
fwrite( arr, sizeof(arr), 1, fp);
To write only first 5 elements from the above array to the file
fwrite( arr, sizeof(int), 5, fp);
Note that here in third argument we'll sen.d size of integer, because here the items that we are writing
are integers not array.
To write a structure variable w~ich is defined as
struct record {
\
char nam~[20];
int roll;
float_marks;
}student;
fwrite(&student,sizeof(student),l,fp);
This will write a single structure variable to the file.
To write an array of structures
Suppose stu_arr[200] is an array of structure defined above-
fwrite( stu_arr, sizeof(stu_arr), 1, fp);
Here it will write all the 200 elements of array stu_arr to the' file.
To write only a part of an array of structure
Suppose in the above array stu[200] we have entered records of only 100 students then it is no use
writing whole array to the file(garbage value will be written).We can write 100 records as-
fwrite(stu_arr, sizeof(struct record), 100, fp);
We have used-sizeof operator instead of sending the size directly, so that our program becomes portable
because the size of data types may vary on different computers. Moreover if new elements are adde<i
to our structure, we need not recalculate and change the size in our program.
/*Pll.10
Program
to
understand
the
use
of
fwrite( )*/
#include<stdio.h>
struct
record
char
name [ 20] ;
_int
roll;
float
marks;
}student;
main ( )
{
int
i,n;
FILE
*fp;
fp=fopen (" stu. dat", "wb")_;
if (fp==NULL)

-iJes
printf("Error
in
opening
file\n");
exit(l) ;
}
printf ( "Enter
number
of
records
" ) ;
scanf ("%d",
&n);
for (i=O; i<n; i+,+)
{
printf ( "Enter
name
" ) ;
scanf("%s".student.name) ;
printf ("Enter
roll
no
") ;
scanf("%d".&student.roll);
printf ("Enter
marks
") ;
scanf("%f".&student.marks);
fwrite(&student.sizeof(stude~t),l.fp);
}
fclose(fp) ;
1.12.2 fread()
's function is used to read an entire block from a given file.
_ laration: size_t fread(void *ptr, size_t size, size_t n, FILE *fptr);
ptr is a pointer which points to the block of memory which receives the data read from the file
is the length of each item in bytes, n is the number of items to be read from the file and fptr is
- e pointer which points to the file from which data is read.
success it reads n items from the file and returns n, if error or end of file occurs then it returns
alue less than n. We can use feof( ) and ferror( ) to check these conditions.
read a single float value from the file and store it in variable fval.
fread( &fval, sizeof(float), I, fp);
read array of integers from file and store them in array arr[10].
fread( an, sizeof(arr), I, fp);
read 5 integers from file and store them in first five elements of array arr[10]
fread( arr, sizeof(int), 5, fp);
read a structure variable that is defined as-
ct record{
char name[20];
int roll;
float marks;
}student;
(&student,sizeof(student),1 ,fp);
will read a single structure variable from the file and store it in variable stud,nt.

~48
To read an array of structures
Suppose stu_arr[200] is an array of structure defined above.
fread( stu_arr, sizeof(stu_arr), 1, fp);
Here it will read an array of structu'r~s from file and store it in stu_~;r.
To read 100 records from file and 'store them in first 100 structures nf stu_arr[200].
fread( stu_arr, sizeof(struct record), 100, fp);
The following program reads the file stu.dat created in PI1.IO.
/ *Pll.ll
Program
to
unaerstand
the
use
of
fread ( ) * /
#include<st4io.h>
struct
record
char
name [ 2 0] ;
int
roll;
float
marks;
}student;
main( )
{
FILE
*fp;
fp=fopen("stu.dat", Orb");
if (fp==NULL)
{
printf("Error
in
opening
file\n");
exi t (1) ;
}
printf("\nNAME\tROLLNO\tMARKS\n");
while(fread(&student,sizeof(student) ,l,fp)==l)
{
printf("%s\t",student.name) ;
printf("%d\t",student.roli) ;
printf("%f\n",student.marks) ;
}
fclose(fp) ;
C in Depth
I
The fread( ) function returns the number of records successfully read, so it will return 1 till there
records in the file and will return a number less than 1 when there will be no records in the file.
we have used this condition in our while loop to stop reading when end of file is reached.
11'.13
Random Access To File
We can access the data stored in the file in two ways, sequentially or randomly. So far we have
only sequential access in our programs. For example if we want to access the forty-fourth record th
first fortycthree records should be read sequentially to reach the forty-f~urth record. In random acc
- data can be accessed and processed randomly i.e. in this case the forty-fourth record can be acce
directly. There is no need to read each record sequentially, if we want to access a particular rec
Random access takes less time than the sequential access.
C supports these functions for random access file processing-
-fseek( )

349 ~I
-n()
wind( )
_ tudying these functions it is necessary to understand the concept of file position pointer. File
-=..."...... pointer points to a particular byte in the file and all read and write operations on the file take
this byte. This pointer automatically moves forward when a read or write operation takes place.
s the data randomly, we'll have to take control of this position pointer.
.1 fseek ( )
_
ction is used for setting the file position pointer at the specified byte:
_-.. ..tion: int fseek( FILE *fp,. long displacement, int origin );
is a file pointer, displacement is a long integer which can be positive or negative and it denotes-
ber of bytes which are skipped backward ( if negative,) or forward ( if positive ) from the
en specified in the third argument. This argument is declared as long integer so that it is possible
e in largefil"es.
- . d argument named origin is the position relative to which the displacement takes place. It can
ne of these three values.
Constant
Value
Position
SEEK SET
0
Beginning of file
SEEK CURRENT
1
Current position
SEEK END
2
End of file
~ three constants are defined in stdio.h so we can either use these names or their values.
examples of usage of fseek( ) function are-
fseek ( p, lOt, 0 );
Origin is 0, w1?-ich means that displacement will be relative to beginning of file so position pointer
- skipped 10 bytes forward from the beginning of the file. Since the second argument is a long
integer, so L is attached with it.
fseek ( p, 5L , 1 );
Position pointer is skipped 5 bytes forward from the current position.
fseek ( p, 8L , SEEK_SET );
Position pointer is skipped 8 bytes forward from the beginning of file.
fseek ( p , -5L , 1);
Position pointer is skipped 5 bytes backward from the current position.
fseek (p, OL , 2 );
Origin is 2 which represents end of fi.le and displacement is 0 which means that 0 bytes are skipped
from end of file. So after this statement position pointer will point to the end of file.
fseek( p, -6L, SEEK_END );
Position pointer is skipped 6 bytes backward from the end of file.
fseek ( p, OL , 0 );
This means 0 bytes are skipped from the beginning of file. After this statement position pointer
points to the beginning of file.

On success fseek( ) returns the value 0, and on failure it returns a non-zero value. Consider the
stu.dat that we had created earlier in program P11.10. In the next program we'll be able to read a partie
number of record randomly from the file with the help of fseek( ) function.
350
C in De
/ *Pll.12
Program
to
understand
the
use
of
fseek () * /
#include<stdio.h>
struct
record
char
name [20] ;
int roll;
float
marks;
)student;
main( )
{
int
n;
FILE
*fp;
fp=fopen (" stu. dat", "rb") ;
if (fp==NULL)
{
printf("Error
in
opening
file\n");
exi t (1) ;
}
printf ( "Enter 'the
record
number
to
be
read
" ) ;
scanf ("%d", &n);
fseek(fp, (n-l)*sizeof(student),O);
/*skip
n-l
records*/
fread(&student,sizeof(student),l;fp);
/*Read
the
nth
record*/
printf("%s\t",student.name) ;
'printf("%d\t",student.roll);
printf("%f\n",student.ma~ks);
fclose(fp) ;
Suppose we want to read the 5th record from the file, i.e. n=5. We'll skip first 4 records and p
our position pointer at the beginning of the 5th record, so now fread( ) will read the 5th recor
general if we want to read the nth record we'll skip n-l records with fseek( ) and place the posi
pointer at the beginning of the nth record.
11.13.2 ftell( )
Declaration: long ftell( FILE *fptr);
This function returns the current position of the file position pointer. The vah:e is counted from
beginning of the file.
.
/*
Pll.13
Program
to
understand
the
use 'offtell()*/
#include<stdio.h>
struct
record
char
name [20] ;
int
roll;
float
marks;
}student;

?ILE
* fp;
~p=fopenl"stu.dat","rb");
:'flfp==NULL)
{
printfl"Error
in
opening
file\n");
exi til) ; .
}
printf I" position
pointer
in
the
beginning
->
%ld\n", ftell I fp) ) ;
whilelfreadl&student,sizeoflstudent) ,l,fp)==l)
printf I "Posi-tion
pointer
->
%ld\n", ftell Ifp));
printfl"%s\t",student.name);
printfl"%d\t",student.roll) f
printfl"%f\n",student.marks) ;
}
printf I "Si.ze
of
file
in
bytes
is
%ld\n", ftell Ifp));
fcloselfp) ;
351
or ftell( ) returns -1 L and sets errno to a positive value.
3.3 rewind( )
ration: rewind(FILE *fptr);
function is used to move the file position pointer to the beginning of the file. Here fptr is a pointer .
\
.
.
E type. The function rewind( ) is useful when we open a file for update.
g rewind(fptr) is equivalent to fseek(fptr, OL, 0):
?11.14
Program. to
understand
the
use
of
rewind I ) * /
~_ ude<stdio.h>
-..., (
?ILE
*fp;
!p=fopenl"stu.dat", "rb+");
printf I "Error
in
opening
file\n");
exitll) ;
printf I "position
pointer
->%ld\n", ftell Ifp));
fseeklfp,O,2) ;
printf I "position
pointer
;->%ld\n", ftell Ifp));
rewind I fp) ;
printf ("Position
pointer
-'->%ld\n", ftell Ifp));
::closelfp) ;
we'll write some programs to perform various operations on the file' stu.dat.
'=:1.15
Program
to
append
records
to
a
file* /

. ,
352
#include<stdio.h>
main ( )
{
struct
record
char
name [201 ;
int
roll;
float
marks;
}student;
FILE
*fp;
intchoice=l;
fp=fopen("stu.dat",
"ab");/*opened
in
append
mode
*/
if (fp==NULL)
{
printf ("Error
in
opening
file\n");
exi t (1) ;
}
while(choice==l)
{
C in Del
printf ( "Enter
name':
" ) ;
scanf("%s",student.name) ;
printf ( "Enter
roll
no
") ;
scanf("%d",&student.r91l ) ;
printf ("Enter
marks
") ;
scanf("%f",&student.marks) ;
fwrite(&student,sizeof(studeht) ,l,fp);
printf("Want
to
enter
more?(l
for
yes/O
for
np)
");
scanf ( "%d",
&choice);
}
fclose (fp) ;
/ *Pll. 16
Program
to
read
records
from
a
file
and calculate
grade
of
ec
student
and
display
it
grade
A
B
C
if
if
if
marks
marks
marks
. >=
80
>=
60
<
60
and
<
80
*/
#include<stdio.h>
main( )
{
struct
record
char
name [201 ;
int
roll;
float
marks;
}student;
FILE
*fp;
char
grade;
fp=fopen("stu.dat";
"rb");/*opened
in
read
mode*/

353
=.=(fp==NULL)
printf("Error
in
opening
file\n");
exit(1);
;::rintf("\nNAME\t\tMARKS\t\tGRADE\n\ri") ;
• ile(fread(&stud~nt,sizeof(student) ,l,fp)==1)
printf("~s\t\t",student.name);
printf("%2.2f\t\t",student.marks);
if(student.marks>=80)
printf (, "A\n") ;
else
if (student. marks>=60)
printf ("B\n");
else
printf ("C\n") ;
__ ose (fp) ;
_:.17
Program
to
modify
records
in
a
file*/
:. de<stdio. h>
)
.::=ruct
record
char' name [ 20] ;
int
roll;
float
marks;
- udent;
E
*fp;
==-ar
name [ 20] ; .
:-:lg
~lize=sizeof(student);
-=signed
flag=O;
'::'_=fopen( "stu.dat", "rb+");
:.':: (fp==NULL)
printf("Error
in
opening
file\n");
exit (l) ;
-==·ntf("Enter·name
of
student
whose
record
is
to
be
modified
");
5=anf("%s",name) ;
~le(fread(&student,sizeof(student) ,1,fp)==1)
if(strcmp(student.name,name)==O)
{
printf ("Enter
new
data
-->\n~"J;
printf ( "Enter
name
") ;
scanf("%s",student.name) ;
printf("Enter
roll
no
");
scanf("%d",&student.~oll);

354
printf ( "Enter
marks
") ;
scanf("%f",&student.marks);
fseek(fp,-size,l);
\
fwrite(&student,sizeof(student) ,l,fp);
flag=l;
break;
}
if (flag==O)
printf ("Name
not
found
in
file\n");
else
printf (" Record
Modified
\n" ) ;
fclose(fp);
C in Depth
}
For modifying records we have opened the file stu.dat in update(rb+) mode. We'll read all the records
one by one with the help of fread( ), and as soon as the name of the student matches with the name
we've entered for mbdificat(on, we'll enter new data for the student, and write that data to the file
Before fwrite( ) we have used fseek( ) to skip one record backwards because while reading we've reacheo
the end of the record which is to be modified, i.e. position pointer is at the beginning of next record
so ifwe write new data without using fseek( ) then it will be written over the next record. After modifyin!
the data we'll stop reading and come out of the while loop with the help of break statement.
/ *Pll.18
Program
to
delete
a· record
from
'the
file* /
#include<stdio.h>
main ( )
{
struct
record
{
char
name [20] ;
int
roll;
float
marks;
}student;
FILE
*fp,
*fptmp;
char
name [20] ;
unsigned
flag=O;
fp=fopen("stu.dat", "rb");
if (fp==NULL)
{
printf ("Error
in
opening
file\n");
exit(l) ;
printf ("Enter' the
naIl)e
to
be
deleted
");
scanf("%s",name) ;
fptmp=fopen("tempfile.dat", "wb");
while(fread(&student,sizeof(student),l,fp)==l)
{
if (strcmp(name,student.name) !=O)
fwrite(&student,sizeof(student) i1"fptmp);
else
flag=l;

355
fclose(fp);
fclose(fptmp) ;
remove("stu.dat") ;
rename("tempfile.dat", "stu.dat");
if (flag==O)
printf ("Name
not
found
in
file\n");
else
printf ( "Record
deleted
\n" ) ;
deleting a record from stu.dat we'll make a temporary file tempfile.dat and copy all the records
mat file, except the record to be deleted, and then we'll delete the original stu.dat file and rename'
file.dat to stu.dat file. The macro remove( ) is used for deleting a file and function rename( ),' is
to rename a file.
Pll.19 Program to display the records in sorted order,
sorting is performed
ascending
order
w. r. t.
name* /
=£nclude<stdio.h>
in( )
struct
record
char
name[20];
int
roll;
float' marks;
}student,temp,stu[50] ;
FILE
*fp;
int
i,j,k=O;
fp=fop.en("stu.dat"("rb");/*opened
in
read
mode*/
if (fp==NULL)
{
printf("Error
in
opening
file\n");
exi t (1) ;
},
while(fread(&student,sizeof(student),l,fp)==l)
stu[k++]=student;
/ *Bubble
sort * /
for(i=O;i<k;i++)
for(j=O;j<k-l-i;j++)
{
if (strcmp (stu [j] . name, stu [j +1] . name) >0)
{
temrstu [j ] ;
stu[j]=stu[j+l] ;
stu[j+1J?emp;
}
printf("\nNAME\t\tROLLNO\t\tMARKS\n\n") ;
\

356
for(i=O;i<k;i++)
{
print f ( "%s \ t \ t " , stu [i) . name) ;
printf("%d\t\t",stu[i).ro11);
printf ("%f\n", stufi) .marks);
C in Depth
>'
}
fc10se (fp) ; .
. ~ere we have read all the records fro~the file into an array and then we have sorted that array b:
bubble sort. After sorting we have displayed the sorted array on the screen. Note that the records it:
the file stu.dat are in.their original unsorted form. If we want the records in the file to become sorted,
then we should rewind the file and then write the sorted array to the file with the help of fwrite(
like this-
rewind(fp);
fwrite( stu,
sizeof(stude~t), k, fp);
In this case file stu.dat should be opened in update mode. We may also~write the sorted records t
another file. Now we'll see how to sort on more than one key. Suppose name is primary key and marks
is taken as secondary key, and sorting is to be done in ascending order w.r.t. name and in qescending
order w.r.t. marks.
for(i=O;i<k;i++)
{
for(j=O;j<k-l-i;j++)
{
if(strcmp(stu[j) .name,stu[j+l) .name»O)
{
temp=stu[j) ;
stu[j)=stu[j+l) ;
stu[j+l)=temp;
\
}
91se
if(strcmp(stu[j) .name,stu[j+l) .name)==O)
i f (stu [ j ). rna r k s <stu [ j ] . marks)
{
temp=stu[j);
stu[j]=stu[j+l) ;
stu[j+l)=temp;
}
} / *End
of
inner
for
loop* /
} / *End
of
outer. for
loop* /
Now we'll write a program to merge two files that are sorted on the same key, such that the merg
file is also sorted on the same key. The logic is somewhat similar to the merging of arrays that \l,
had done in chapter 7.
Create two files named sec.tionA.dat .and sectionB.dat using program PIl.I O. The records in these rn
files should be in descending order w.r.t marks. So either you can enter the records in sorted ord
or you may sort the fi!eafter entering the records. The program given next merges these two so
files into a third sorted file. The merged file is named merged.dat and it contains all the records
-
sectionAdai ?nd sectionB.dat in descending order w.r.t marks. Thi.s file can be read using progr

_-ues
C>11.11.
*Pll.20
Program
to
merge
two
files* /
include<stdio.h>
- ruct
record
char
name [20] :
int
roll:
float
marks:
}stul,stu2:
in ( )
FILE
*fpl, *fp2, *fp3:
int
i,j:
if((fpl=fopen("sectionA.dat", "rb"»==NULL)
{
printf ("Error
in
opening
file\n"):
exi t (l) :
}
if((fp2=fopen("sectionB.dat", Orb") )==NULL)
{
printf ("Error
in
opening
file\n"):
exit(l) :
}
if ( (fp3=fopen ( "merged. dat" , "wb") ) ==NULL)
(
printf("Error
in
opening
file\n"):
exi t (1) :
}
i=fread(&stul,sizeof(stul),l,fpl):
j=fread(&stu2,sizeof(stu2),1,fp2):
while((i==l)&&(j==l»
(
if(stul.marks>stu2.marks)
{
fwrite(&stul,sizeof(stul) ,1,fp3):
i=fread(&stul,sizeof(stul),l,fpl):
}
else
fwrite(&stu2,sizeof(stu2) ,1,fp3):
j=fread(&stu2,sizeof(stu2) ,1,fp2):
357
}
while(i==l)
/*Write
remaining records of
sectionA.dat into
mer~At'l.oat*/
(
fwrite(
&stul,sizeof(stul) ,1,fp3):
i=fread(&stul,sizeof(stul) ,l,fpl):
}
while(j==l)/*Write
remaining
records
of
sectionB.dat
into
merged.dat*/
{
f wr i t e (&stu1 , s i ze 0 f (stu1) , 1,-f p 3 ) :

358
j=fread(&stu2.~izeof(stu2).1.fp2)
;
}
fc1ose(fpl) ;
fclose(fp2) ;
fclose(fp3) ;
C in Depth
The next program is a menu driven program in which we manage a database of books. All the operations
that we have studied till now have been combined in this single program.
I*P11. 21
Write
a
program
to
manage
a
database
of
books* I
#include<stdlo.h>
#include<string.h>
void
insert(FILE
*fp);
void
del(FILE
*fp);
void
modify(FILE
*fp);
void
booksold(FILE
*(p);
int
search(FILE
*fp •. char
*name);
void
display(FILE
*fp);
void
list (
FILE
*fp);
struct
{
main(
{
char
name [50] ;
int
ncopies;
float
cost;
}book;
)
int
.choice;
FILE
*fp;
fp=fopen ("books. dat". "rb+") ;
if (fp==NULL)
{
./ fp=fopen ("books. dat". "wb+") ;
if (fp==NULL)
{
puts ("Error
in
opening
f{le\n");
exit(l) ;
}
while(l)
{
printf( 1.Insert
a
new
record\n");
printf(
2.Delete
a
record\n");
printf ( 3. Display
record
of
a
book\n");
printf ( 4.Modify
an
existing
record\n");
printf( 5.List
all
records\n");
printf (
6
Book
sold\n");
prin'tf (
7 .Exit\n");
print f ( Enter
your
choice
" ) ;
sCanf("%d",&choice) ;
switch(choice)

Files~
359
case
1:
insert (fp) ;
break;
case
2:
del( fp) ;
break;
case
3:
disp1ay(fp) ;
break;
case
4:
modify ( fp) ;
break;
case
5:
list (fp) ;
break;
case
_6-y
bookso1d(fp) ;
break;
case
7:
fclose(fp) ;
exit (1) ;
default
printf ("Wrong
choice\n");
}/*End
of
switch
*1
} 1 *End
of
while* 1
}/*End
of
main( )*1
void
insert(FILE
*fp)
fseek(fp,O,2) ;
printf ("Enter
book
name
") ;
scanf("%s",book.name);
print f ( "Enter
number
of
copies
" ) ;
scanf ( "%d" ,&·book. ncopies) ;
printf ("Enter
cost
of
book
");
scanf("%f",&book.cost) ;
fwrite(&book,sizeof(book) ,l,fp);
}/*End
of
insert( )*1
void
del (FILE
*fp)
FILE
* fptmp;
char
name [2 0] ;
printf (" Enter' the
name
of
book
to
be
deleted
from
database
" ) ;
scanf("%s",name) ;
if(search(fp,name)==O)
return;
fptmp=fopen( "tempfile.dat", "wb");
rewind ( fp) ;
while (fread (&book, sizeof-(book) ,1, fp) ==1)

360
if (strcmp(name,book.name) !=O)
fwrite(&book,sizeof(book) ,l,fptmp);
}
fclose(fp) ;
fclose(fptmp) ;
remove("books.dat") ;
rename("tempfile.dat", "books.dat");
print f ( "\nRecord
deleted
\n\n") ;
fp=fopen ("books. dat",
"rb+");
}/*End ofdel( )*/
void
modify(FILE
*fp)
{
char
name [50 ];
long
size=sizeof (book) ;
printf("Enter
the
name
of· the
book
to
be
modified
");
scanf("%s",name) ;
if(search(fp;name)==l)
{
printf ("Enter
new
data-->\n\n");
printf("Enter
book
name
");
scanf("%s",book.name); .
printf ( "Enter
number
of
copies
") ;
s~anf("%d",&book.ncopies);
printf ( "Enter
cost
of
book
") ;
scanf("%f",&book.cost);
fseek(fp,-size,l) ;
fwrite(&book,sizeof(book) ,l,fp);
printf ( "\nRecord
successfully
modified\n \n" ) ;
}
}/*End
of
modify() */
void
booksold (FILE
*fp)
{
C in Depth
·.
"
char
name [50 ];
long
size=sizeof (book) ;
printf (" Enter
the
name
of
the
book
to
be
sold
scanf("%s",name);
if(search(fp,name)==l)
{
if(book.ncopies>O)
{
II
)
;
book.ncopies--;
fseek(fp,-size,l).;
fwrite(&book,sizeof(book) ,l,fp);
printf ( "One
book
sold\n");
printf ("Now
number
of
copies
%d \n" , book. ncopies) ;
}
else
printf ("Book
is
out
of
stock\n\n");

-~
361
}
*End
of
booksold ( ) * /
id
display(FILE
*fp)
char
name[50);
printf("Enter
the
name
of
the
book
");
scanf("%s",name) ;
search(fp,name) ;
printf("\nName\t%s\n",book.name) ;
~rintf("Copies\t%d\n",book.ncopies) ;
printf("Co~t\t%f\n\n",book.cost) ;
·/*End
of
display() */.
-
t
search(FILE
*fp,char
*name)
unsigned
flag=O;
rewind (fp) ;
while(fread(&book,sizeof(book) ,l,fp)==l)
(
if(strcmp(name,book.name)==O)
(
flag=l;
break;
if (flag==O)
printf("\nName
not
found
in
file\n\n");
return
flag;
/*End
of
search( )*/
oid
list(FILE
*fp)
{
rewind ( fp) ;
printf("\nNAME\tCOPIES\t\tCOST\n\n");
while(fread(&book,sizeof(book) ,l,fp)==l)
(
printf("%s\t",book.name) ;
printf ("%d\t\t" ,book.ncopies);
printf("%f\n",book.cost) ;
}
printf (" \n") ;
} / *End
0 f
"1 i s t ( ) */
We haveopened the file books.dat inupdate(rb+) mode. If the file doesn't exist then fopen() will return
~LL, so we'll create the file by opening in "wb+" mode. So first time when we'll run this program,
file will be opened in "wb+" mode. The operations permitted in "wb+" mode and "rb+" mode are same
but the problem with "rb+" mode is that it can't create a file and with "wb+" mode is that it erases
the contents of the file each time file is opened.

'"
362
C in Depth
The function insert( ) is simple, we place the position pointer at the end of file by fseek( ) and then
insert a new record there.
The function search( ) searches for a record in the file, and if .the record does not exist then it displays
a message and returns O. If the record exists then the position pointer is placed at the end of the record,
which was searched and the function returns 1. Before starting our search we have called rewind( )
function so that searc~ starts from the beginning of the file. This function search( ) 'is used in dele
), modify, booksold( ) and display( ) functions.
The dele ) function first calls search( ), and if the record doesn't exist we return from the function.
Otherwise the record is deleted using a temporary file as we have seen earlier. At the end of dele )
function the file books:dat is opened in "rb+" mode because this file was closed by this function, and
it is the respoI\sibility of this function to open the file in "rb+" before returning to main menu and
performing any other operation.
The function modify( ) is simple. The function booksold( ) searches for the book to be sold and it
reduces the number of copies by 1. If the number of copies is 0 then it displays the message that book
is out »fSfock. For reducing number of copies we have written book.ncopies--. We could write this
because book is a global variable and after calling search( ) it contains the record of the book to be
sold.
The function display( ) searches for a particular record and displays its details on the screen while the
function list( ) displays the details of the a.1l the books on the screen.
11.14
Other File Functions
11.14.1 fcof( )
So far we have used the return value ofthe function to detect the end of file while reading. For example
fgetc( ), getc( ), getw( ), fprintf( ) return EOF and fgets( ) returns NULL on end of file. But these
functions return the same value both on end of file and on error. So if a function stops reading we
can't make out whether the end of file was reached or an error was encountered. We can check ~eparatel
for these two conditions with the help of ferror( ) and feof( )..
Declaration: int feof( FILE *fptr );
The macro feof( ) is used to check the end of file condition. It returns a nonzero value· if end of file
has been reached otherwise it returns zero.
. In the program Pll.ll we could have used feof( ) function to read the file.
fread(&student,sizeof(student) ,l,fp);
while( lfeof(fp))
(
printf("%s\t",student.name) ;
printf("%d\t",student.roll);
printf("%f\n",student.marks);
fread(&student,sizeof(student) ,l,fp);
Let us see what would happen if we write the above code like this-
while(lfeof(fp) )
{
fread(&studen~,sizeof(student) ,l,fp);
printf("%s\t",sttident.name) ;

- es
printfl"%d\t",studeat.roll) ;
printfl"%f\n",student.marks);
363
this case, the last record of the program may be processed twice, since iIi C end of file is indicated
y after an input function has made an attempt to read at the end of file.
1.14.2 ferror( )
Declaration: int ferror(FILE *fptr);
The macro ferror( ) is used for detecting any error occurred during read or write operations on a file.
returns a nonzero value if an error occurs i.e. if the error indicator for that file is set, otherwise
returns zero.
I*Pll.22
Program
to
understand
the
use
of
ferror I ) * /
-include<stdio.h>
ain I )
{
FILE
* fptr;
int
Chi
fptr=fopenl "test", "w");
ch=getc I fptr) ;
if Iferrorlfptr»
{
printfl"Error
in
read
operation\n");
exi tIl) ;
}
else
printf I" %c", chI ;
fcloselfptr);
}
Output:
Error in read operation
Here the file is opened in write mode and an attempt is made to read from the file, this gives an error
which is detected by ferror( ).
Generally the return value of the input function is checked to stop reading from the file. Almost all input
functions return same value on end of file and on error, so to distinguish between these two cases,
the functions feof( ) and ferror( ) are used.
/ *Pll. 23
Program
to
understa,nd
the
use
of
feof
I)
and
ferror ( ) * /
#include<stdio.h>
main I )
{
FILE
* fptr-;
int
Chi
i~1 (fptr=fopenl"myfile.c", Or") )==NULL)
{
pnIl,tfl"File
doe,sn't
exist\n");
exit(I);' -
"
}
else

364
while((ch=getc(fptr)) !=EOF)
printf("%c",ch) ;
}
if (feof (fptr) )
printf ("End
of
file\n");
if(ferror(fptr))
printf("Error\n") ;
fclose (fptr) ;
11.14.3 clearerr( )
Declaration: void clearerr(FILE *fptr);
This function is used to set the end of file and error indicators to O.
/*Pll.24
Function
to
understand
the
use
of
clearerr( )*/
#include<stdio.h>
main ( )
{
FILE
* fptr;
int
Chi
fptr=fopen(" test", "w") ;
ch=getc ( fptr) ;
if(ferror(fptr))
{
printf("Error
in
read
operation\n");
clearerr(fptr) ;
}
.
fclose(fptr) ;
11.14.4 perror( )
C in Depth
Declaration: void perror(const char *str);
This function is used to display a message supplied by the user along with the error message generated
by the system. It prints the argument str, then a colon, then the message related to the current value
of ermo, and then a newline. ermo is a global variable which is set to a particular value whenever an
error occurs. The use of this furiction can be understood by reading the next program Pll.25.
11.14.5 rename( )
,
Declaration: int rename(const char *oldname, const char *newname);
This function lis used to rename a file. We can give full path also in the argument, but the drives shouid
be the same although directories may differ. On success it returns 0 and on error it returns -1 and
errno is set to one of these values-
ENOENT .
No such file or directory
EACCES
Permission denied
ENOTSAM
Not same device

365
?11.25
Program
to
understand
the
use
of
rename ( )*/
-bclude
<stdio .h>
=:'0 ( )
char
old_name [80] , new_name [80] ;
printf ("Enter-
the
name
?f
file
to
be
renamed
II) ;
gets (old_name) ;
printf("Enter
a
new
name
for
the
file
");
gets (new_name) ;
if (rename (old_name, new_name) ==0)
printf ( II File
%s
renamed
to
%$ \n ", old_name,
new_name);'
else
perror ( II File
not
rena¥!ed");
ase we give a filename whIch does not exist then value of ermo will be set to ENOENT and the
age displayed by perror will be-
- e not renamed: No such file or directory
.14.6 unlink( )
laration: int unliIlk(const char *filename); .
_. function is used for deleting a file from the directory. We can give full pathname also as the argument.
file should be closed before deleting. On success it returns 0 and on error it returns -I and erma
- set to one of these values-
ENOENT
Path or file name not found
EACCES
Permission denied
"PII.26 'Program
to
understand
the
use
of!'
unlink ( ) * /
-:nclude<stdio.h>
in ( )
FILE
* fptr;
char
name [15] ;
printf("Enter
the
file
name:");
scanf("%s",name) ;
fptr=fopen(name," r ") ;
fclose.( fptr) ;
if(unlink(name)==O)
printf (IIFile
%s
else
perror ( II File'
not
1.14.7 remove( )
is
deleted\n",name);
deleted
" ) ;
eCiaration: int remove(const char *filename);
:-emave is a macro that deletes ,a file from the directory. It is similar t6 the function unlink( ).

366
C in Depth
11.14.8 fflush( )
Declaration: int fflush(FILE *fptr);
This function writes any buffered unwritten output to the file associated with fptr. The file IS not closed
after call to ffiush( ). On success it returns 0 and on error it returns E9F. If we call this function
with stderr, then all the unwritten buffered error messages will. be written.
fflush (stderr);
To flush all output streams we can write-
ffiush(NULL);
Although ffiush( ) is defined for output streams only, but in some compilers ffiush( ) can be used with
stdin to discard unread characters on standard input. For example consider this situation-
printf("Enter an integer: ");
scanf("%d", &i);
printf("Enter a character : ");
scanf("%c", &ch);
After entering the integer, we press Enter key so that tbe first scanf( ) terminates. The integer value
is read by the scanf( ) but the newline character(ASCII 10) is still in the input buffer. So the next
scanf( ) reads this newline character in the variable ch, and terminates even before user enters any
character. Similar type of problem may occur-when we use gets( ) after scanf( ), since gets( ) terminates
when it finds a newline character. To avoid such problems we can use fflush(stdin) to discard an
unread characters. For example-
printf("Enter an integer: ");
scanf("%d", &i);
printf("Enter a character: ");
fflush(stdin);
scanf("%c", &ch);
Nute that
fnu~h(~tdin) i;> not portable, it =ight not work on every compiler.
11.14.9 tmpfile( )
Declaration: FILE *tmpfile(void);
tmpfile( ) creates a temporary binary file and opens it in "wb+" mode. On success it returns a pointer
of type FILE that points to the temporary file and on error it returns NULL. The file created By tmpfile(
) is temporary because it is automatically deleted when closed or when
th~ program terminates.
14.11.10 tmpnam( )
Declaration: char *tmpnam(char str[L_tmpnam]);
This function is used to generate a unique name for a file. The argurrient str can be NULL or an arra
of minimum L_tmpnam characters. If str is NULL then tmpnam( ) stores the temporary file name in
a internal static array and returns a pointer to that array. If str is not NULL, then tmpnam( ) stores
the temporary file name in str and returns str. The number o(different file names that can be gener~ted
by tmpnam( ) during the execution of program is specified by TMP_MAX, w1).ich is defined in stdio.h
file. Note that tmpnam( ) only creates a file name, it does not create the file. A file withthe nam:e generated
by tmpnam( ) can be opened using fopen( ), and it should be closed using fclose( ).

367
1.11 freopen( )
ration: FILE *freopen(const char *filename, const char *mode, FILE *fptr);
function is used to associate a new file with a file pointer. The file associated with'fptr is closed
.' fclose( ), after that the filename that is specified in the first argument is opened in the specified
as by fopen( ), and this fptr is now associated with this file. On success freopen( ) returns fptr,
- on error it returns NULL.
.
function is generally used to change the files associated with file pointers stdin, stdout and stderr.
example the file pointer stderr is associated with the screen, if we want to store the error messages
file instead of displaying them on the screen, then we can use freopen( ) as-
freopen(i'errorfile", "a", stderr);
. 5
Command Line Arguments
function maine ) can accept two parameters. The definition of maine ) when it accepts parameters
e written as-
(int
argc, char
*argv C ])
first parameter is of type int and the second one is an array of pointers to strings. These parameters
_ onventionally named argc(argument counter) and argv(argument vector), and are used to access
arguments supplied at the command prompt. Let us see how this is done.
program is compiled and executable file is created. In DOS, name of the executable file is saine
e name of the program and it has a .exe extension. In UNIX, the executable file is named as a.out.
_ can give. any other name to the executable me in UNIX using -0 option as-
cc -0 myprog myprog.c
_ ' the program is executed at the command prompt, and arguments are supplied to it. The first
ent is always the name of executable file. The parameters argc and argv can be used to access
omrnand line arguments. The parameter argc represents the number of arguments on command
. All the arguments supplied at the command line are stored internally as strings and their addresses
stored in the array of pointers named argv.
_11.27
Program
to
understand
command
line
arguments * /
-=clude<stdio.h>
-~ n (int
argc, c.har
*argv [
])
int
i;
printf("argc=%d\n",argc) ;
for(i=O;i<argc;i++)
printf("argv[%d]=%s\n",i;argv[i]);
_ pose the name of the program is myprog.c and it is executed on the command prompt as-
myprog you r 2 good
variable argc will have value 5, since total five arguments are supplied at the command prompt.
first argument is the name of the progral"!1, so argv[O] points to the base address of string "myprog"

368
C in DeptJ
(it might contain the whole path of the file). Similarly argv[l] points to the base address of string "you'
argv[2] points the base address of string "r", argv[3] points to the base address of string "2", argv[t
points to the base address of string "good".
The output will be :
argc = 5
argv[O] = myprog
argv[ 1] = you
arg:v[2] = r
argv[3]
;= 2
argv[4] = good
Note that each argument is stored as a string, so argv[3] does not represent the integer 2 but it i!
pointer to string "2". If we want to use it as an integer in the program then we we'll have to cony
it to an integer using function atoi( ).
.
!
11.16
Some ~dditional Problems
Problem 1
Write a program that copies a file to another file. The names of two files should be sent as comm:
line arguments.
.
/*Pll.28
Program
to
copy
a
file
to
another* /
#include<stdio.h>
main (int
argc, char
*argv [
])
FILE
* source, *dest, * fopen ( ) ;
int
c;
if(argc!=3)
{
printf ("Wrong
number
of
arguments\n");
exi t (1) ;
}
if( (source=fopen(argv[l], "r"»==NULL)
{
printf(U
Can't
open
source
file\n");
exit(l) ;
}
if( (dest=fopen(argv[2], "w") )==NULL)
{
printf ("
Can't
open
destination
file\n");
exi t ( 1) ;
}
while((ch=fgetc(source»
!=EOF)
fputc(dest,c) ;
fclose(source) ;
fclose(dest) ;
In this program, first we've checked the number of command line arguments using argc, it is a
practice to do so.

369
roblem 2
-rite a program to remove all comment lines from a syntax error free C source program.·
*Pll.29*"/
=~nclude<stdio.h>
=ain( )
FILE
*fpl,*fp2;
char
name [50] ;
int
cl,c2,found='n';
printf ("Enter
the
file
name
");
scanf("%s",name) ;
if( (fpl=fopen(name, "r") )==NULL)
{
printf ("Error
in
opening
file\n");
exi t ( ) ;
ep2=fopen("c:\\new.c", "w");
cl=fgetc(fpl);
c2=fgetc(fpl) ;
while(c2!=EOF)
{
if(cl=='/'&&c2=='*')
found=' y' ;
if(found=='n' )
fputc(cl,fp2) ;
if (cl==' *' &&c2==' /')
{
found= 'n' ;
c2=fgetc(fpl) ;
cl=c2;
c2=fgetc(fpl) ;
}
fclose(fpl) ;
fclose(fp2) ;
.Toblem 3
rite a program to count the number of words in a text file. Assume that a word ends with a space,
<ab, newline, comma, fullstop, semicolon, colon, hyphen.
*Pll.30
Program
to
count
the
number
of
words*/
-include<stdio.h>
=include<stdlib.h>
:::.ain ( )
char
line[81];

370
int
i, count=O;
FILE
* fptr;
if( (fptr=fopen("test.txt", "r"II==NULLI
{
printf ("File
doesn ' t
exist\n" I;
exit(l) ;
}
while.( (fgets (line, 81, fptrl I ! =NULLI
{
for (i=O; line [i] ! =
I
\ 0 '; i++ I
if(is_end(line[i]1 I
count++;
}
printf ("Number
of
words
in
the
file
fclose(fptrl;
}
is_end (int
chI
{
%d\n",countl;
C in Depth
switch(chl
{
case
'\n' :
case
'\t ' :
case
I ;
I :
case
, -
I :
return
l',
return
0;
case
I.
case
I.
case
, .
case
I.
I
•
",
This is a simple program that counts the words in a text file, by counting the characters that terminate
a word. This program may give incorrect output in some cases, let us consider those cases and modify
the program accordingly.
If the file contains two or more adjacent terminating characters, then the output will be wreng. For
example there are two or more adjacent spaces or a full stop followed by a space or a newline. In
this case we can modify the if condition as-
if ( is_end(1ine[i]) && !is_end(1ine[i-l]) )
If there are two or more adjacent newline characters(blank lines) in the file then in spite of the modified
if condition the output will be wrong. This is because fgets( ) stops reading when it encounters a newline
character. So we can place this condition in the beginning of while loop.
if ( line[O] =
= '\n' )
continue;
Problem 4
Write a program to count the number of occurrences of a given word in a text file. No line of text
file contains, more than 80 characters(including newline character). Suppose the name of file is testtxt
and the word to be counted is "that" and the file contains the
follG~'ing data.
This is the house that Jack built, that is the house that John built.
This is better than that.
His name is John.
She is not sure whether that is his book.

-jJes
371
• e output should reproduce the lines containing the wor.d along with the number of occurrences of
_- en word, and at the end it should give the frequency of the given word in the file as-
Number of times the given word occurs in the file is 5.
XPl1.31*/
=~ncl~de<stdio.h>
=inclu~<stdlib.h>
=~nclude~~ring.h>
-
t
display--( char
line [
], char
wordtext [
]};
in( }
char
line[81];
int
total
0;
FILE
*fptr;
if((fptr=fopen("test.txt", "r"} }==NULL}
{
printf ("File
doesn't
exist\n");
exit(l};
}
whi 1 e ( ( f ge t s ( 1 ine , 8 1 , f p t r) } ! =NULL }
total=total+display(line, "that"};
printf ("Number
of
times
the
given
word
occurs
in file
is
%d\n", totai);
fclose (fptr) ;
display(char
line [
], char
wordtext [
]}
int
i,j,k,len;
char
str[80];
int
count=O;
len=strlen(wordtext} ;
for(i=O;line[i] !='\O';i++}
(
k=O;
if(is_end(line[i-l]}&&is_end(line[i+len]})
(
for(k=O,j=i;k<len;j++,k++)
str [k] =line [j] ;
str[k]='\O';
if(strcmp(str,wordtext)==O)
count++;
}
if(count>O)
(
printf("%s",line) ;
printf("count=%d\n",count} ;
return
count;
_.:i_end (int
ch

C in Dep,
372
switch (ch)
{
case
'\n ':
case
'\t':
case
case
';':
case
'-':
return
1;
return
0;
':
case
, '.
, .
case
I
•
'
t
case
, .
}
Output:
This is the hou~e that Jack built, that is the house that John buHt.
count = 3
This is better than that.
count =1
She is not sure whether that is his book.
count = 1
Number of times the given word occurs in the file is 5.
The logic used inside the function display( ) is simple. We find the length of the given word by strh
.function. Suppose the length is 4, then we'll extract the 4 letter word~ in the string str one by c
and this string str is compared with the given word using strcmp( ).
This program would not count the word if it appears in the beginning of the line. For example if tt
is a line in the file like this-
.
that is his book.
Here the word "that" will not be counted. The reason for this is that in our logic we have assw
that before the word, there is a word-ending character( eg space, newline, comma
et~).
But this is the first character of the array, so this condition fails and the word is not counted. To
the correct output we can modify the if condition as-
.
if ( ( is_end( line[i-1]) II i = = 0 ) && is_end( line[i+len] ) )
If you want to count those occurrences of the word also, when it is embedded inside another
then remove the above if condition totally. For example if the word to be searched is "rot", the!
occurrence in the words like parrot, rotten, carrot, rotate, rotary will be counted.
The search perfonned by our program is case sensitive, since the comparison performed by strCl
is case sensitivl;l. If we want to perform case insensitive search then we'll have to make a fune
of our own that performs case insensitive search of two strings.
strcmp_in(char
*strl,char
*str2)
{
int
i;
for(i=O;strl[iJ l='\O';i++)
if (toupper (strl [i) ) l =toupper (str2 [i) ) )
\ return
1;
return
0;
This function compares two strings of equal lengths and returns 1 if they are not same, othe

373
_e declaration for the function toupper is in the header file ctype.h.
oblem 5
.. e a program to read a text file WRONG.DAT and copy to another file RIGHT.DAT after making
ections in the text as follows:
Replace the first character of the word to uppercase, if the previous word was terminated by a
fullstop or newline.
Replace the word 'a' with the word 'an' if the next word starts with a vowel.
( Alphabets a, e, i, 0, u or A, E, I, 0, U known as vowels)
Pll. 32 * /
=~nclude<stdio.h>
~nclude<ctype.h>
"'·n( )
char
wrong[81l ,right[120l i
int
ch, i, j;
FILE
*fptr1, *fptr2;
if( (fptr1=fopen("wrong.dat", Dr") )==NULLI
{
printf("File
doesn't
exist\n");
exi t (1 I ;
}
if( (fptr2=fopen("right,dat", Ow") )==NULLI
{
printf("File
doesn't
exist\n"l;
exit (11;
} .
while( (fgets (wrong, 81, fptr1») !=NULL)
{
i=O;j=O;
while (wrong til ! =' \0')
{ .
if(islower(wrong[il 1&&(i==Ollwrong[i-ll=='.' I I
right[j++l=toupper(wrong[i++l I i
else
if (wrong[il;;:;='
'&&wrong[i-1l=='a'
&&is_vowel(wrong[i+llll
{
right[j++l='n'i
right[j++l=wrong[i++l;
}
else
right[j++l=wrong[i++l;
}
r i ght [j 1=' \ 0 ' ;
fputs (right,
fptr2 I ;
~s-:vowel (int
chI
switch(ch)

374
C in Deptl
case
'a':
case
'A':
case
' e':
case
' E':
case
'i':
case
'I':
cas
, 0':
case
'0':
Assume stdio.h is included in all programs.
(1) main()
{
case
'u':
-.return
return
0;
case
1;
'U' :
Exercise
FILE
*fptr;
unsigned
char
ch;
fptr=fopen ( "myf ile. dat" , "w" ) ;
while ( (ch=fgetc(fptr»
!=EOF)
putchar (ch) ;
fclose(fptr);
(2) main(
{
FILE
*fp;
int
ch;
fp=fopen ("myfile. dat", "w") ;
fprintf (fp, "If
equal
love
there
cannot
be .. ");
fputc (26, fp);
fprintf(fp," .. l e t
the
more
loving
one
be
me\n");
fclose (fp) ;
fp=fopen (" myfile. dat", "r") ;
while( (ch=fgetc(fp»
!=EOF)
putchar(ch) ;
(3) main (
{
FILE
*fptrl,*fptr2;
char
fname[20];
printf ("Enter
the
path
of
first
file
");
scanf ("%s",
fname);
fptr1=fopen(fname, "r");
if (fptrl==NULL)
{
printf("Error
in
opening
first
file\n");
fptr2=fopen (" c: \mydir\names. dat",
"r");
if (fptr2==NULL)
{
printf("Error
in
opening
second
file\n");
fclose'( fptrl);
fclose (fptr2) ;
exi t (l) ;
exi t (1) ;

/
Files
Suppose the path of first file is entered as-
c:\mydir\myfile.dat
(4) main( )
{
FILE
*fptr;
int
ch;
fptr=fo'pen( "na~es .dat", 'w');
while ( (ch= fgetc (fptr) )! =EOF)
putchar (ch) ;
fclose.( fptr) ;
5} main·(
{
char
name [50] ;
int
empid;
fprintf(stdout,"Enter
your
name
");
fgets(name,50,stdin) ;
fprintf (stdout, "Enter
your
empid
") ;
fscanf (
stdin," %d" ,&empid
);
fprintf (stdout, "Your
empid
is
%d",
empid);
fputc( '\n' ,stdout);
fprintf (stdout, "Your
name
is
");
fputs(name,stdout) ;
(6) main (
{
"FILE
* fptr;
char
str[80];
fptr=fopen("test.txt", "r n );
while (fgets (str, 80, fptr) ! =EOF)
puts(str);
(7) main(int
argc,char
*argv[
])
{
int
i,
sum=O;
for(i=l;i c argc;i++)
sum=sum+argv[i];
printf("%d\n",sum) ;
}
Suppose"the name of executable file is add and on the command line it is invoked as-
add 2 4 6 8
375
Programming Exercise
1.
Write a program to copy a file to another file such that blank lines are not written to the new
file..
2.
Write a program to convert all the lower case characters of a file to upper case.

C in Depth
Write a program to display the total number of alphabets and numeric characters in file.
Write a program to remove all comments from the file. Assume that a comment starts with double
slash ( II ) and continues till the end of the line.
Write a program that concatenates any number of files and writes the ~utput in a destination file.
The names of files should be passed through command line arguments.
Write a program to insert line numbers and page numbers in a file.
Consider this structure-
struct {
char name;
int age;
int sal;
}
Write a program to store 10 records of this structure in the file and s'ort them on the basis 01
name and age, where name· is the primary key and age is secondary key.
8.
Modify the program PI1.21, so that the records to be deleted are marked as deleted, and mak~
a function to physically delete the marked records from the file.
Answers·
(1)
This program will display the contents of the file and when the end of file is reached the progran
goes into an infinite loop, since data type of ch is unsigned char while the value of EOF is -:
which is signed.
(2)
If equal love there cannot be..
Since we are reading in text mode, so 26 is regarded as the end of file character and any te~
beyond it is not ·read.
(3)
Error in opening second file
The first file opens successfully while the second file does not. Inside string constants, th~ backslas
is considered as an escape character, so while opening second file we should use double backslas
in the path name. The name of first file is not a string constant, so there is no need to enter doubl
backslashes in it.
(4)
The value of mode should be enclosed in double quotes since it is a string.
(5)
When fprintf(), fputs( ), fputc( ) are called with stdout, they are equivalent to printf( ), put
. )and putchar( ) respectively.When fscanf( ), fgets( ), fgetc( ) are called with stdin, they are equivale
to scanf( ), gets( ) and getchar( ) respectively.
(6)
fgets() does not return NULL on end of file or on error, not EOF. The contents of the who
file will be displayed and then fgets( ) will return NULL at the end of file, but the loop conditil
checks for EOF, so the last line will be displayed infinitely.
(7)
Command line arguments are stored as strings, so we have to use atoi( ) function to convert th~
to integers. The correct statement would be-
sum = sum + atoi(argv[l]);

Chapter 12
The CPreprocessor
C has a spe<;:ial feature of preprocessor which makes it different from other high level languages that
on't have this type of facility. Some advantages of using preprocessor are-
(i)
Readability of the program js increased.
(ii)
Program modification becomes easy.
(ill) Makes the program portable and efficient.
e know that the code that we write is translated into object code by the compiler. But before being
ompiled, the code is passed through the C preprocessor. The preprocessor scans the whole source
ode and modifies it, which is then given to the compiler.
Source code·
The lines starting with the symbol # are known as preprocessor directives. When the preprocessor finds
a line starting with the symbol #, it considers it as a command for itself and works accordingly. All
the directives are executed by the preprocessor, and the compiler does not receive any line starting with
symbol. .Some features of preprocessor directives are-
(i)
Each preprocessor directive starts with a # symbol.
(ii)
There can be only one directive on a line.
(iii) There is no semicolon at the end of a directive.
(v)
To continue a directive on next line, we should place a backslash at the end of the line.
(vi) The preprocessor directives can be placed anywhere in a program (inside or outside functions)
but they are usually written at the beginning of a program.
'
(vi) A directive is active from the point of its appearance till the end of the program.
'"
The main functions performed by the preprocessor directives are·
1.
Simple Macro Substitution
2.
Macros with arguments
3.
Conditional Compilation

378
4.
Including 'files
5.
Error generation, pragmas and predefined macro names.
The preprocessor directives that perform these functions are as given below-
#define
#else
#error
#if
#elif
#line
#ifdef
.#endif
#pragma
#ifndef /'
#und6f
C in l)epth
There are three operators that are used with these directives-
Defined operator
defined( )
Stringizing operator
#
Token pasting operator
##
Apart from the facilities provided through directives, another important task that preprocessor performs
is that it replaces each comment by a single space.
12.1
#define
'11lII.
We have already used this directive to define symbolic constants. The general syntax is-
#pefme
macro name
macro_expansion
liere mflcro_name is any valid C identifier, and it is generally taken in capital letters to distinguish'
from other variables. The macro_expansion can be any text. A space is necessary between the macro
name and macro expansion. The C preprocessor replaces all the occurrences of macro_name wi
the macro_expansion. For example-
#deflne TRUE 1
#define FALSE°
#define PI 3.14159265
#define MAX 100
(
#define RETIRE AGE 58
C preprocessor searches for macro_name in the C source code and replaces it with the macro_expansioJ
For example wherever the macro name TRUE appears in the code, it is replaced by 1. These typl
of constants are known as symbolic constants. These constants increase the readability of the prognu
for example it is better to use the name PI 'instead of the value itself. Moreover if after some time'~
may decide to change the value of a constant, then the change has to be made only at one place. F
example if we decide to increase the RETIRE_AGE from 58 to 60, then we have to change the #defi
. directive only. If we had not defined this constant then we would have to replace each occurrence
58 by 60. We have already utilized this feature to define the size of an array.
We can also define any string constant in the place of macro_expansion.
/*P12.1
Program
to
show
that
macro
expansion
can
be
a
string
constant
#include<stdio.h>
#defineMSSG
"I
understand
the
use
of
#define\n"
main( )
{
printf (MSSG) ;

_ e C Preprocessor
3 9
tput:
I understand the use of #define
_ e C preprocessor searches for the macro name MSSG and substitutes the message "I understan
e use of #define\n" in the printf ( ).
-e can have macro expansions of any sort. Here are some more examples-
#define AND &&
#define OR I I
#define BEGIN maine ){
#define END }
#define INFINITE while( 1 )
~define NEW_LINE printf("\n");
#define ERROR printf("An error has occurred\n");
ere is a semicolon in the last two directives. This semicolon is just a part of the macro_expansion.
_'ow whenever we write NEW_LINE or ERROR in the program, they will be replaced by printf calls
. d the terminating semicolon.
member that the C preprocessor will simply replace the macro_name with the macro_expansion and
e macro_expansion can be any text. So it is our responsibility to see that after replacement the re.sulting
e is valid in C. For example if we define. a macro MAX like this-
#define MAX 5;
_-ow consider this declaration statement-
int arr[MAX];
~is
wil~ be translated by the preprocessor as-
int arr[5;];
d this is not valid in C.
the macro_name appears inside a character constant, string constant or a comment then it is no·
:-eplaced and is left as it is. For example-
#define SUN 2
#define WINDOWS 3
\
printf("Rays of SUN are coming through the WINDOWS");
Here the replacement will not take place inside the string.
is also possible to define a macro without any macro expansion. for example-
#define TEST
-:his is used in compilation directives where the preprocessor only needs to know whether the
been defined or not.
2.2
Macros with Arguments
~e #define directive can also be used to define macros with arguments. The general syntax is-
#define macro_name(arg1, arg2, ......) macro_expansion

380
C in Depth
Here argl, arg2 .... are the fonnal
ar~uments. The macro_name is replaced with the macro_expansion
and the formal arguments are replaced by the corresponding actual arguments supplied in the macro
call. So the macro_expansion will be different for different actual arguments. For example suppose we
define these two macros-
#define SUM(x, y) ( (x) + (y) )
#define PROD(x, y) ( (x) * (y) )
Now suppose we have these two statements in our program-
s = SUM(5, 6);
p = PROD(m, n);
After passing through the preprocessor these statements would be expanded as-
s =
( (5) + (6) );
p =
( (m) * (n) );
Since this js just replacement of text, hence the arguments can be of any data type. For example we
may use the macro SUM to find out the sum of long or float types also.
The following' statement-
s = SUM( 2.3, 4.8 );
would be expanded as-
s =
( (2.3) + (4.8) );
/*P12.2
Program
to' understand
macros
with
arguments*/
#include<stdio.h>
#define
SUM (x, y)
«x) + (y) )
#define
PROD (x, y)
«x) * (y))
main( )
{
int
l,m,i,j,a=5,b=3i
float
p, qi'
1 =SUM (a , b) i
m=PROD (a, b) i
i=SUM(4,6) i
j=PROD(4,6)i
p=SUM(2.2,3.4)i
q=PROD(2.2,3.4)i
printf("l=%d,m=%d,i=%d,j=%d,p=%.lf,q=%.lf\n",l,m,i,j,p,q) i
}
Output:
I = 8, m = 15, i = 10; j = 24, P = 5.6, q = 7.5
Let us see some more examples of macros with arguments-
#define SQUARE(x) ( (x)*(x) )
#define MAX( x, y ) ( (x) > (y) ? (x) : (y) )
#define MIN( x, y ) ( (x) < (y) ? (x) : (y) J
#define ISLOVvER(c) ( c >= 97 && c <= 122 )
#define ISUPPER(c) ( c >= 65 && c <= 90 )

The C Preprocessor
#define TOUPPER(c) ( (c) + 'A' - 'a' )
#define ISLEAP(y) ( (y%400 = = 0) II ( y%100!=0 && y%4 = = 0) )
#define BLANK_LINES(n) { int i; fore i = 0; i < n; i++ ) printf("\n"); }
#define CIRCLE_AREA(rad) ( 3.14 * (rad) *(rad) )
381
_ ote that there should be no space between the macro_name and left parenthesis, otherwise the macro
expansion is consid~red to start from the left parenthesis. For example if we write a macro like this-
#define
SQUARE (x) ( (x)*(x) )
_ ow any call like SQUARE(5) would be expanded as-
(x) ( (x)*(x) )(5)
Here SQUARE is considered as a macro without arguments and the text (x) ( (x)*(x) ) is regarded
macro expansion. SO SQUARE is replaced by the macro expansion and (5) is written as it is.
12.3
Nesting in Macros
One macro name can also be used for defining another macro name i.e. the macro expansion can also
ontain the name of another macro. For example-
#define
PI 3. 14
#define
PISQUARE PI*PI
_ ow if we have an expression-
k = PISQUARE;
~irst time the preprocessor will expand it as-
k = PI * PI;
_-ow agaiQ the preprocessor rescans this expanded expression, and if any macros are found then it
replaces them. This process of rescanning continues till no macros are left in the expression. So finally
e expanded expression would be-
~
k = 3.14 *3.14;
Here is another example of nesting of macros-
#define ISLOWER(c) (c >= 97 && c <= 122)
#define TOUPPER(c) ISLOWER(c ) ? «c) + 'A' - 'a') : c
ere the macro TOUPPER uses the macro ISLOWER in its expansion. If the character is lowercase
en only it will be changed to uppercase otherwise it will remain unchanged.
The following program illustrates the use of nested macros-
"P12.3
:Program
to
understand
nesting
in "macros* /
=include<stdio.h>
=define
ISLOWER(c)
(c>=97&&c<=122)
-define
ISUPPER(c)
(c>=65&&c<=90)
=define
ISALPHA(c)
ISLOWER(c)
II
ISUPPER(c)
-define
ISNUM (c)
(<:;>=48&&c<=57)
-def ine
ISALPHANUM (c)
ISALPHA (c)
I I
ISNUM (c)
=ain( )

382
C in Depth
char
ch;
printf ("Enter
a
character
\n") ;
scanf("%c",
&ch);
if
(ISALPHANUM(ch»
printf (" %c
is
an
alphanumeric
character\n", chI ;
else
printf ("%c
is
not
an
alphanumeric
character\n", chI ;
}
If the macro name appears inside its own expansion, then it is not expanded. So don't try to write
recursive macros like this one-
#define FACTORIAL(k) k = = 0 ? 1 : k * FACTORIAL(k-l) /*Incorrect*/
12.4
Problems with Macros
You must be-wondering why so many parentheses are used in the macro expansion. Since the preprocessor
simply replaces the formal argument with the actual argument, we may not get the desired result in
some cases. Let us see what sort of problems can occur while using macros and how they can be
avoided.
In the following program we have defined a macro PROD without any parentheses in the macro expansiOI
/*P12.4*/
#include<stdio.h>
#definePROD(x,y)
x*y
main ( )
{
printf("%d\t",PROD(2,4»;
printf("%d\n",PROD(3+4,5+1»
;
)
Output:
8
24
Here the first printf( ) gives the correct result 8, but the second printf( ) prints 24 while we we
expecting the result to be a product of 7 and 6 i.e. 42. Let us see how the preprocessor expand
these macros.
PROD(2, 4)
is expanded as
2*4
PROD(3+4 , 5+1 )
is expanded as
3+4*5+1
The precedence of multiplication operator is more than addition operator so the, calculation went 1
this, 3+20+I =24 and hence we got the wrong result. This problem can be solved by enclosing el
formal argument inside parentheses. So now we rew/rite our program like this-
/*P12.5*/
- ,
#include<stdio.h>
#define
PROD (x, y)
(x) * (y)
main ( )
{
printf("%d\t",PRuu(~,4»;
printf("%d\t",PROD(3+4,5+1) );
printf("%d\n".60/PROD(2,3»
;

(; ?reprocessor
ut:
842
90
the first two printf( ) give us the desired result. In the third printf we had tried to divide 60 by
product of 2 and 3 and the expected result was 10 but we got 90, so still there is a problem in
_ macro. Again let us see how preprocessor has done the. expansions.
PROD(2, 4)
is expanded as
(2)*(4)
PROD(3+4 , 5+1 )
is expanded as
(3+4)*(5+1)
60/PROD(2, 3 )
is expanded as
60 / (2)*(3)
we can see that in the last case, first 60 is divided by 2 and then the result is multiplied by 3
use / and * operators associate from left to right. So the result was not the expected one. To solve
-- sort of problem we should enclose whole macro expansion inside parentheses. So the correct way
: defining macro is-
#define PROD(x, y) ( (x)*(y) )
_
iW 60/PROD(2, 3) would .be expanded as 60 / ( (2)*(3) ) and hence 60 is divided by, the product
:
and 3, and we can get the desired result.
if your macro is accepting arguments and you want it to work properly then it is better to put
ntheses around the entire macro expansion and also around each argument.
_- w consider this program and we will find another sort of problem.
?12.6*/
:~ clude<stdio.h>
-c.efine
SQUARE (x)
((x) * (x) )
-=in( )
int
k:5, s,
s=SQUARE(k++) ;
printf("s"=
%d,
k
%d \ n" , s , k) ;
tput:
s = 25, k = 7
-ere the statement
s = SQUARE(k++); is expanded as s =
( (k++) * (k++) );
-ere value of k is incremented twice while we intended to assign the square of k to variable s, and
increase the value of k only once. Moreover the result of expressions like (k++) *(k++) is undefined
C. So in this case it is better if we use a function instead of macro.
-Pl2.7*/
:~nclude<stdio.h>
::..::J.t
square (int
x)
return
x*x;
--in ( )
int
k=5,s;

384
s==square(k++) ;
printf ("s
.==
%d,
k
%d\n",s,k);
C in Depth
}
Output:
s = 25, k = 6
Now we will see a different type of problem. Consider this program, in which. we have written a mac1"l
to swap the value of 2 variables of any datatype..
.
I*P12.8*/
#iriclude<stdio;h>
#define
SWAP(dtype,x,y)
dtype
t;
t
x,
x
y,
y
t;
main(
)
int
a==2,b==5;
SWAP(int,a,b)
printf(~a==%d,b==%d\n",a,b);
}
Output:
a = 5, b=2
There is no problem in this program. It worked according to our expectations and swapped the valm
of a and b. The macro was expanded in this way-
SWAP(int, a, b) is expanded to { int t; t = a, a = b, b = t; }
After macro expansion, the maine ) function would look like this-
main( )
{
int
a==2,b==5;
{
int
t;
. t==a,
a==b,
b=::t;
}
printf ("a
==
%d,
. b
==
%d\n", a, b) ;
Here t is a variable that is local to the block of code in which it is defined.
Now consider the next program, it is similar to the above program except that the names of the variablt
to be swapped are sand 1.
/*P12.9*/
#include<stdio.h>
#define
SWAP(dtype,x,y)
dtype
t;
t==x,
x==y,
y==t;
main(
)
{
int
s==2,
t==5;
SWAP(int,s,t)
printf ("S
==
%d,
t
%d\n",s,t);
}
Output:
s = 2, t = 5
The values of variables sand t were not swapped. After macro expansion, the main function wou
look like this-
,
.

_ e C Preprocessor
385
in( )
int
s;"2, t=5;
{
int
t;
t=s,
s=t,
t=t;
printf("s
=
%d,
t
=
%d\n",s,t);
-
now you know why things went wrong. When the macro was expanded, there was a conflict between
-~ variable t declared inside the block, and the variable t declared outside the block in main( ). To avoid
h type of problems, we can use some naming convention for local variables declared in macros.
-
example we may decide to
wr~te them-in capita-Is.
- ~e is another problem that can cause the program to give unexpected results.
?12.10*/
:- clude<stdio.h>
:~<=:fine
MACRO (x)
if (x==O)
printf ("Out
for
a
Duck\n")
- ':n ( )
int
runs=12;
if(runs<100)
MACRO (runs) ;
else
printf ("Score'd
a
century\n");
ut:
Scored a century
~ runs were only 12, so the output is wrong. Let's see what happened after the code was expanded.
expanded code is-
if(runs<100)
if (runs==O)
printf ("Out
for
a
duck");
else
printf ("Scored
a
century\n");
e e pan ""as matched with the if part of the macro. To avoid this problem either we can enclose
hole macro inside parentheses or we may use a conditional operator.
=define MACRO(x) { if ( x = = 0 ) printf("Out for a Duck\n") }
=define MACRO(x) x = = 0 ? printf("Out for a duck\n") : printf("\n")
Macros Vs Functions
e seen that macros with arguments can perform tasks similar to functions. In' this topic we'll
e the advantages and disadvantages of functions and macros.
o is expanded into inline code so the text of macro is inserted into the code for each macro
ence macros make the code lengthy and the compilation time increases. On the other, hand the
a function is written only at one place, regardless of the number of times it is called so the
functions makes the code smaller.
'ons, the passing of arguments and returning a value takes some time and hence the tAel;ution
•rogram becomes slow while in the case of macros this time is saved and they mak~ the program

386
C in Dep
faster.
So functions are slow but take less memory while macros are fast but occupy more memory due
duplicity of code. If the macro is small it is good but if it is large and is called many times ther
is better to change it into a function since it may increase the size of the program considerably. I
sometimes macros can prove very useful and also improve the execution
spe~d. For example in
file stdio.h, getchar( ) and putchar( ) are defined as macros. If they were defined as functions tJ
there would be a function call for processing each character, which would increase the run timl
Preprocessor just replac,es or substitutes the text without any sort of checking. So macros can be u
with arguments of different types as we have seen earlier in the case of macro SUM in program PI:
Functions perform type checking so separate functions have to be written for each data type.
remember that lack of type checking facility in macros makes them more error prone.
So whether to use a macro or a function depends on the memory available, your requirement and
nature of the task to be performed.
\
12.6
Generic Functions
Now we'll explore an interesting and powerful feature of preprocessor. We can define macros that
; be used to generate functions for different data types. These types of macros are called generic functi
These macros generally take the function name and data type as arguments and the macro call is rep};
by a function definition. All this may sound a bit confusing, don't worry the following program
clear- all your confusions.
/*P12.11
Program
to
understand
generic
functions
* /
#inc1ude<stdio.h>
#define
MAX(FNAME,DTYPE)
\
DTYPE
FNAME (DTYPE
X,
DTYPE
Y)
\
{
\
return
X>Y
?
X:Y;
}
MAX(max_int,int)
MAX (max_float, float)
MAX (max_double, double)
main ( )
{
int
p;
float
q;
double
r;
p=max_int(3,9) ;
q=max_f1oat(7.4,5.7) ;
r=max_double(12.34,13.54) ;
printf("p
=
%d,q
=
%.2f,r
\
%.2lf
\n",p,q,r);
}
Output:
p = 9, q = 7.40, r = 13.54
i
The three macro calls written just before main( ) are expanded as-

C Preprocessor
~X(max_int, int)
~(max_float, float)
int max_int (int X, int Y)
{
return X>Y? X : Y;
}
float max_float (float X, float Y)
{
return X>Y? X : Y;
}
387
MAX(max_double, double)
~. double max_double (double X, double Y)
{
return X>Y? X : Y;
}
e can see that the three macro calls written before maine ) are expanded into function definitions.
- is way. we can generate function definitions for different data types.
#undef
definition of a macro will exist from the #define directive tiII the end of the program. If we want
define this macro we can use the #undef directive.
tax:
.tundef macro name
this directive if the macro_name is encountered in the program then it will not be replaced by
macro_exapnsion. In other words now the scope of the macro is limited to the code between #define
#Undef directives. This is used when we want the macro definition to be valid for only a part of
program. This directive is generally useful with other conditional compjJation directives.
_.8
Stringizi.ng Operator ( # )
the definition of macro, a formal argument occurs inside a string in the macro expansion then
.
neit replaced by the actual argument. For example if we have a macro-
#define SHOW(var) printf("var = %d", var)
"n a call SHOW(x); will be expanded as printf("var = %d", x);
the formal argument var outside the string was replaced by the actual argument x, but inside the
- g this replacement did not take place.
-_ solve this sort of problem we can lise the stringizing operator. This operator is used within the definition
=macro. It causes the argument it precedes to be turned into a string or in other words it stringizes
cro argument. So if in the macro expansion, we have a formal argument preceded by #, then both
- operator and argument are replaced by the actual argument surrounded within double quotes. We
write the above macro using stringizing operator as-
#define SHOW(var) printf(#var "=%d", var)
---~ --
-

388
C in DeptA
Now a call
SHOW(x);
will be expanded as printf("x" "=%d", x);
We know that adjacent strings are concatenated so after string concatenation this becomes-
printf("x = %d", x);
We can make the above macro more general so that' it can display variable 'of any type.
/*P12.12
Program
to
understand
the
use
of
stringizing
operator* /
#include<stdio.h>
#define
SHOW(var,format)
printf(#var
"
=
%"
#format
"\n",var);
main ( )
{
int
x=9;float
y=2.5;char
:;::='$';
SHOW (x, d) ;
SHOW(y,O.2f) ;
SHOW(z,c) ;
SHOW(x*y,O.2f) ;
}
Output:
x = 9
y = 2.50
z = $
x*y = 22.50
The macros in the above program were expanded as-
SHOW(x, d); .
~ printf("x" " = 0/0" "d" "\n", x);
SHOW(y, 0.2f);
~ printf("y" " = 0/0" "0.2f" "\n", y);
. SHOW(z, c);
~ printf("z" " = 0/0" "c" "\n", z);
SHOW(x*y, 0.20; ~ printf("x*y" " = 0/0" "0.2f" "\n", x*y);
After string concatenation the .above statements look like this-
printf("x = O/Od\n", x);
printf("y = %0.2f \n", y);
printf("z = %c\n", z);
printf("x*y = %O.2f \n", x*y);
12.9
Token Pasting Operator( ## )
Token pasting operator ## is used in a macro definition to concatenate two tokens into a single to
As the name implies, this operator pastes the two token into one.
/*P12.13
Program
to
understand
the
use
of
token
pasting
operator*1
#include<stdio.h>.
#define
PASTE (a,
b)
a##b
#define
MARKS (subject)
marks_##subject
main ( )
{
int
k2=14,k3=25;

C Preprocessor
int
marks
chern
89,
rnarks_rnaths
=
98;
printf("%d
%d
",PASTE(k,2),PASTE(k,3));
print f (" %d
%d\n", MARKS (chern) ,MARKS (rnaths) ) ;
tput:
14 25 89 98
e token pasting operator converts the above statements into-
printf( "~d %d", k2, k3 );
printf("%d %d", marks_chern, marks_maths );
_.10
Including Files
389
:- e preprocessor directive #include is used to include a file into the source code. We have already used
. directive to include header files in our programs. The filename should be within angle brackets or
-
ble quotes. The syntax is-
#include "filename"
#inc1ude<filename>
~o preprocessor replaces the #include directive by the contents of the specified file. After including
file, the entire contents of file can be used in the program. If the filename is in double quotes, first
. searched in the current directory (where the source file is present), if not found there then it is
ched in the standard include directory. If the filename is within angle brackets, then the file is searched
dle standard include directory only. The specification of standard include directory is implementation
- ed.
-
erally angled brackets are used to include standard header files while double quotes are used to include
er files'related to a particular program. We can also specify the whole path instead of the path
e. For example-
#include "C:\mydir\myfile.h"
-e that here the path is not a string constant so there is no need to double the backslashes.
lude directive should not be used to include the contents of other '.c' files. It is generally used
. elude header files only. Header files are given '.h' extension to distinguish them from other C files,
- ough this is not necessary. Header files generally contain macro definitions, declarations ofenum,
ture, union, typdef, external functions and global variables. The function definitions or global variable
- ·tions should not be put in the header files.
de files can be nested i.e. an included file can contain another #include directive.
_.11
Conditional Compilation
may be situations when we want to compile some parts of the code based on some condition.
_ know that before compilation the source code passes through the preprocessor. So we can direct
preprocessor to supply only some parts of the code to the compiler for compilation.
itional compilation means compilation of a part of code based on some condition.
e conditions are checked during the preprocessing phase. The directives used in conditional
ilation are-
#ifdef
#ifndef
#if
#else
#elif
#endif

390
C in Depth
Every #if directive should end with a #endif directive. The working of these directives is somewha
similar to that of if...else construct.
12.11.1 #if And #endif
An expression which is followed by the #if is evaluated, if result is non-zero then the statements hetweeJ
#if and #endif are compiled, otherwise they are skipped. This is written as-
#if
constant-expression
statements
#endif
The constant-expression should be an integral expression and it should not contain enum constanl
sizeof operator, cast operator or any keyword or variables. It can contain arithmetic,'logical, relation
operators. If any undefined identifier appears in the expression, it is treated as having the value zeJ
/*P12.14
Program
to
understand
the
use
of
#if
directive*/
#include<stdio.h>
#defineFLAG
8
main( )
{
int
a=20,b=4;.
#if
FLAG
>=
3
printf ("Value
of
FLAG
is
greater
than
or
equal
to
3 \n") ;
a=a+b;
b=a*b;
printf ("Values
of
variables
a
and
bhave
beenchanged\n");
#endif
print f ("a
=
%d ,b
%d \ n" , a , b) ;
printf ("Program
completed\n");
"
}
Output:
Value of FLAG is greater than or equal to 3
Values of variables a and b have been changed
a = 24, b = 96
Program completed
In this program FLAG is defined with the value 8. First the constant expression FLAG >= 3 is ev
since it is true(non zero), hence all the statements between #if and #endif are compiled. SUpp(i
value of FLAG is changed to 2, now,the constant expression FLAG /= 3 would evaluate to false
hence the st~tements between #if and #endif will not be compiled. In this case the output of the
would be-
a = 20, b = 4
Program completed
12.11.2 #else and #elif
"Il,.
#else is used with the #if preprocessor directive. It is analogous to if..,else control structure.
is as-

The C Preprocessor
391
~if
constant-expression
statements
:else
statements
:endif
the constant expression evaluates to non-zero then the statements between #if and #else are compiled
otherwise the statements between #else ~nd #endif are compiled.
/*P12.l5
Program
to
understand
the
use
of
#else
directive* /
:include<stdio.h>
-define
FLAG
2
ain ( )
int
a:20,b:4;
#if
FLAG>:3
printf ("Value
a:a+b;
b=a*b;
#else
printf ("Value
a=a-b;
b=a/b;
#endif
printf ("a
%d,
printf("Program
of
FLAG
is
greater
than
or
equal
of
FLAG
is
less
than
3 \n") ;
b
=
%d\n",a,b);
completed\n") ;
to
3 \n") ;
Output:
Value. of FLAG is greater than or equal to 3
a = 24, b = 96
Program completed
<,
Here the value of FLAG is 8, so the constant expression FLAG >= 3 is evaluated to true and hence
:he statements between #if and #else are compiled. If the value of FLAG is changed.to 2, then the
-onstant expression FLAG >=,3 would evaluate to zero, so now the statements between #else and #endif
'11 be compiled and the output of the program would be-
Value of FLAG is less than 3
a = 16, b = 4
Program completed
_-esting of #if and #else is a.lso possible and this can be done using #elif. This is analogous to the else.. .if
dder that we had studied in control statements. Every #elif has one constant expression, first the
expression is evaluated if the value is true then that part ofcode is compiled and all other #elif expressions
e skipped, otherwise the next #elif expression is evaluated.
ntax:
#if
constant-expressionl
#elif
constant-expression2

j1
392
C in Dept!.
#elif
constant-expression3
#else
#endif
The above code can be written using #if and #else directives as-
#if
constant-expressionl
#else
#if
constant-expression2
#else
#if
constant-expression3
#else
#endif
#endif
#endif
Here for each #if there should be a #endif, while when using #elif there is only one #endif. Let us tak
a program that uses #elif directive-
/*P12.l6
Program
to
understand
the
use .of
#elif
directive*/
#include<stdio.h>
#define
FLAG
1
main ( )
{
int
a=20,b=4;
#if
FLAG==O
printf ("Value
of
FLAG
is
is
zero\n");
a++;
b++;
#elif
FLAG==l
printf ("Value
of
FLAG
is
one\n");
a- -;
b-:- -;
#elif
FLAG==2
printf ("Value
of
FLAG
is
two
\n");
a=a-3;
b=b-3;
#else
printf ("Value
of
FLAG
is
greater
than
two
or
less
than
zero\n")
a=a+b;
b=a-b;
#endif
printf ("a
=
%d,
b
=
%d\n", a, b) ;
printf ("Program
completed\n");
}
Output:
Value of FLAG is one

C Preprocessor
393
a = 19, b = 3
Program completed
the expression FLAG = = 1 is true, hence the statements corresponding to this #elif are compiled.
_.11.3 defined Operator
• tax: defined(macro_name )
. operator is used only with #if and #elif directives. It evaluates to 1 if the macro_name has been
• firied using #define, otherwise it evaluates to zero. For example:
#if defined(FLAG)
me macro FLAG has been defined using #define, then the value of expression defined(FLAG) would
1, otherwise its value would be o.
_.11.4 #ifdef and #ifndef
-:'e directives #ifdef and #ifndef provide an alternative short form for combining #if with defined operator.
#if defined(macro_name ) is equivalent to #ifdef macro_name
#if !defined(macro_name ) is equivalent to #ifndef macro_name
-yntax of #ifdef-
#ifdef
macro name
#endif
- the macro_name has been defined with the #define directive, then the statements between #ifdef and
dif will be compiled. If the macro_name has not been defined or was undefined using #undef then
ese statements are not compiled.
mtax of-#ifndef-
#ifndef
macro_name
#endif
...: the macro_name has not been defined using #define or was undefined using #undef, then the statements
tween #ifndef and #endif are compiled. If the macro_name has been defined, then these statements
not compiled.
_et ·us take a program- ..
*P12.17
Program
to
understand
the
use
of
#ifdef
9.irecti\ve* /
=includecstdio.h>
= efine
FLAG
::.ain ( )
int
a=20,b=4;
#ifdef
FLAG
printf ("FLAG
is
defined\n"
);
a++;
b++;
#endif
printf ("a
=
%d,
printf("Program
b=
%d\n",a,b);
completed\n") ;

394
C in Depth
b=
%d\n",a,b);
completed\n") ;
·Ilijr.
Output:
FLAG is defined
a = 21, b = 5
Program completed
The macro FLAG has been defined, so the statements between #ifdef and #endif are compiled. If we
delete the definition of macro FLAG from the program, then these statements won't be compiled and
the output of the program would be-
a = 20, b = 4
Program completed
/*P12.18
Program
to
understand
the
use
of
#undef
and
#ifdef
directives*
#include<stdio.h>
#define FLAG
main ( )
{
int
a=20,b=4;
#ifdef
FLAG
printf ("FLAG
is
defined\n");
a++;
b++;
#endif
#undef
FLAG
#ifdef
FLAG
printf("Prepocessor\n H );
a++;
b++;
#endif
printf("a
%d,
printf("Program
}
Output:
FLAG is defined
a = 21, b = 5
Program completed
Here we have undefined the macro FLAG in the middle of program. So the macro FLAG is deflIJ
only for the part of the program that is before the #undef directive, and it is undefined for the r
of the program.
"
/ *P12 .19
Program
to
understand
the
use
of
#ifndef
directive* /
#include<stdio.h>
main( )
{
int
a=20,b=4;
#ifndef
MAX
printf ("MAX
is
not
"defined\n");
a- -;
b- -;
#endif

C Preprocessor
printf("a
=
%d,
printf("Prograrn
b
=
%d\n",a,b);
cornpleted\n") ;
395
tput:
MAX is not defined
a = 19, b = 3
Program completed
ere the macro MAX has not been defined, so the statements between #ifndef and #endif are compiled.
-:he existence of defined operator is important in some cases. For example we can't use the short
.1mlls(#ifdef and #ifndef) here-
i)
When we need to check the existence of more than one macros, for example-
#if defined(ABC) && defined(PQR) && !defined(XYZ)
ii ) When the existence of macro is to be checked in #elif
#if
defined (ABC)
#elif
defined (
PQR)
#elif
defined(XYZ)
#endif
There are lot of situations where conditional compilation can prove useful e.g. writing portable code,
debugging, l;ommenting. We'll discuss all these cases one by one.
12.11.5 Writing Portable Code
Suppose. we want to write a program that can be run on different systems. In this case some lines
of the code would be system dependent. These !ines can be written using conditional compilation
directives. Suppose we have made different header fil~s corresponding to 'different machines. We can
write code to include the appropriate header file while working on a specific machine.
"
#if
MACHINE
==
ABC
#define
hfile
abc.h
#elif
MACHINE
==
PQR
#define
hfile
pqr. h
#elif
MACHINE
=
=
XYZ
#define
hfile
xyz.h
#else
#define
hfile
newfile.h
#endif .
#include"hfile"
Now when we want to work on machine ABC, we can define the macro MACHINE as-
#define MACHINE ABC
So the file abc.h will be included.
If we want to work on machine XYZ, we can define MACHINE as-
#define MACHINE XYZ
Now the file xyz.h will be included.

396
C in Depth
Similarly if we have some code in the program that is different for different machines, we can use
the above structure.
12.11.6 Debugging
The compiler can detect syntax errors but it is unable to detect run time errors, which result in incorrect
output. To trace these types of errors in the program the debugging has to be done by the programmer.
Ina large program where many functions and variables are involved this can be a difficult task. For
this debugging purpose we can insert some printf statements inside' the code that tell us about the
internlediate results. After the debugging is complete we don't need these statements and we can delete
them. But suppose after few days we again need to debug the program, then we'll have to insert all
those statements once again. We have another better alternative if we use preprocessor directives. Using
these directives we can make these debugging statements active or inactive depending on our needs.
The following program shows this-
#include<stdio.h>
#define
DEBUG
main( )
{
int
x;
# if de f
DEBUG
printf( "Starting
main() \n");
#endif
func ( ) ;
# ifde f
DEBUG
.printf("Now
value
of
x
#endif
func ( )
#ifdef
DEBUG
printf ("Inside
func ( ) \n") ;
#endif
%d
and
y
=
%d
\ n" , x, y) ;
II,.
}
When the debugging is complete we can just undefine or delete the macro DEBUG. This will make the
#ifdef condition false and all the debugging statements will not be compiled. So in this way we can
switch between the debugging and normal mode by defining or deleting the macro DEBUG withou
having to delete all the debugging statements.
Including #ifdef and #endif for every debugging statement makes things look more lengthy and confusing.
To make it more concise we can define another macro SHOW. The macro SHOW is defined in such
a way that if macro DEBUG is defined, then SHOW will be replaced by a printf statement, and if DEBUG
is not defined then SHOW won't be replaced by anything.
#include<stdio.h>
#define
DEBUG

C Preprocessor
-:.::def
DEBUG
#define
SHOW (message)
=e se
#def ine
SHOW (mes sage)
=:ndif
-in ( )
printf
message
397
int
x,
y
SHOW ( ("Starting
main ( ) \n") ) ;
fUl1.C ( ) ;
SHOW ( ("Now
value
of
x
c ( )
SHOW(("Inside
func( )\fl"»i
%d
and
y
%d
\n",x,y»;
-
e the argument message sent to the macro SHOW consists of the control string and all arguments
'ch we want to send to printf( ), and these are to be enclosed in parentheses. This is why we have
two pairs of parentheses while calling SHOW.
_.11.7 Commenting A Part Of Code
_
pose while testing or for some other reason, we want to comment some part of our source code
contains many comments. This can't be d()ne using our usual technique (/* .... */) since comments
't be nested in C. So here we can use our conditional compilation directives to comment out parts
our source code.
=~clude<stdio.h>
=:iefine
COMMENT·
'n( )
#ifndef
COMMENT
statement .
statement ..
#endif
/ *
,..comment
* /
/*
...comment
*/
Code
to
be
commented
. the macro COMMENTis defined, then the code will be commented (not compiled).and if this macro
not defined then it will treated as usual code and will be compiled.
_.11.8 Other Uses of conditional compilation
you open any header file, you will see that whole contents of the file are enclosed inside #ifndef

398
.. #endif directives. For example if we open stdio.h file
#ifndef
STDIO H
#define.
STOIO_H
....contents of stdio.h file .....
#endif
.C in Depth
. This sort of coding ensures that the contents of this file will be included only once. The first time when
the file stdio.h is included, the preprocessor finds that macro _STDIO_H is not defined, and hence
it defines this macro and includes the contents of the file. After this whenever stdio.h is included in
our program, the preprocessor finds that the macro _STOIO_H is defined and hence it skips all the
statements between #ifndef and #endif.
We can use a similar strategy to avoid multiple definitions in our program. For example the definitioii
of constant NULL may be needed by many files such as stdio.h, sdtlib.h, string.h, alloc.h etc. This
constant can be defined in ail these files but if we include more than one files which have definition
of NULL, then our program will have multiple definitions of NULL. So definition of NULL is put in
a separate file _null.h l:ind this file is included in all other files.
These files don't include the _null.h file directly, but enclose the include directive inside #ifndef and
#endif like this-
#ifndefNULL
#include< null.h'
#endif
Now this file will be included only when NULL has not been defined.
12.12' Predefined Macro Names
There are certain predefined macro names which can't be undefined or redefined by #undef or #define
. DATE
TIME
-
-
FILE
LINE
STDC
-
-
String constant that represents the date of compilation in the format "mm dd yyyy
String constant that represents the time of compilation in the format "hh:mm:ss
String constant that represents the name of the file being compiled.
Decimal constant that represents the line number being compiled.
Decimal constant, which is 1 if compiled with ANSI standard
/ *P12. 20
Program
to
display
the
values
of
predefined· constants * /
#include<stdio.h>
main(
{
printf ("%s\n", __DATE__ ' ;
printf (" %s \n"
I __TIME__ l ;
printf("%s\n", __FILE__J;
printf("%d\n". __LINE__l;
}
Output:
Sep 24 2003
10:24:42

C Preprocessor
C:\P20.C
8
399
macros _FILE_ and _LINE_ can be used to write error messages in the program, that can
the line number and file name where the error occurred.
_.13
#line
- directive is used for debugging purposes.
tax:
#line dec_const string..:..const
.dec_const is any decimal constant and string_const is any string constant. This directive assigns
_const and string_const to the macros _LINE_ and _FILE_ respectively. If the
strin~_const
ot specified then the macro _FILE_ rem<l:ins unchanged.
T
P12. 21
Program
to
understar"d
the
use
of
#line,
name
of
this
file
is
-- g. c
* I
--=clude<stdio.h>
-i.n ( )
printf("C
in
depth\n");
printf ("%d. %s\n", __LINE__ , __ FILE~_) ;
#line
25
"myprog.c"
printf("%d
%s\n",_..:..LINE__ , __FILE__ );
ut:
C in depth
'6 C:\prog.c
25 myprog.c
.14
#error
- preprocessor directive is used for debugging purpose. #error directive stops compilation and displays
31a1 error message attached with it.
x:
#error message
example:
'_=ndef
MACRO.
'~ror
MACRO
is
not
defined
=-.dif
_=def
TINY
'='-ror
This
program
will
not
run
in
the
tiny
model.
=-.dif
_=
defined (_Windows)
&&
! def ined (_BUILDRTLDLL)

400
C in Depth
#error
Timer
not
available
for
Windows
#endif
Suppose a program has been written using ANSI C standard, then this line.can be inserted at the beginnin
of the code.
#ifndef
STDC
#error This program should be run using ANSI C
#endif
Suppose there are two files and both ofthem can't be included at a time, then we can use #error directi,-
to stop inclusion of both files at a time. For example suppose the files stdarg.hand varargs.h can
be included ata time, then we can insert #error directive inside the files like this-
I*Structure
of
file
stdarg.h*1
#ifndef
STDARG_H
#define
__STDARG_H
#ifdef
_VARARGS_H
#error
Can' t
include
both
stdarg. hand
varargs. h
#endif
..... contents
of
file
.
#endif
I*Structure
of
file
varargs.h*1
#ifndef
__VARARGS_H
#define
__VARARGS_H
#ifdef
STDARG~H
#error Can' t
include
both
stdarg. hand
varargs. h
#endif
..... contents
of
file
.
#endif
12.15 Null Directive
A preprocessor directive consisting only of the symbol # is known as the null directive and it h
effect.
12.16 #pragma
#pragma startup
It allows the programmer to specify the function that should be called upon program startup i.e.
This is an implementation defined directive that allows various instructions to be given to the co
Syntax:
#pragn1a name
Here name is the name of the pragma we want. The pragmas may be different for different com
You should check your compiler's manual for the pragmas available and their details. Any unreco~
pragma directive is just ignored, without showing any error or warning. Some #pragma statements av
in Turbo Care as-
.
\
"""

C Preprocessor
401
. ( ) is called. For example-
#pragma startup func 1
~e function func I( ) will be called before the main( ) function.
ragma exit
ows the programmer to specify the function that should be called upon program exit i.e. before
program terminates.
gma exit func2
_e function func2( ) will be called just before the program terminates.
ragma inline
ells the compiler that inline assembly code is contained in the program.
ragma warn
~ can turn warning messages on or off using this pragma.
.7
How to see the code expanded 'by the Preprocessor
ughout the chapter we have discussed all the concepts by explaining how the preprocessor expands
code. Now we'll tell you how to view the code after the preprocessing phase. The procedure
vary on different systems, we'll discuss it. for Turbo C and UNIX.
Turbo C, we have a utility(executable file) named cpp( C preprocessor). This utility creates a file
- contains the expanded source code. The name of this file is same as that· of source code file and
a ".i " extension. For example suppose t4e source code is present in file d:\myfile.c, then the
ded code would be present in myfile.i. We can create the expanded file at the command prompt
C:\TC>cpp d:\myfile.c
e source code contains #include directive, then we'll have to specify the path of include file~ F"or
pIe if c:\tc\include is path C!f included files then we have to write as-
C:\TC>cpp -Ic:\tc\inclu"de d:\myfile.c
-~ file myfile.i will be created i.n the directory where cpp is present. We can view this file using a
editor or by type cOl1}mand. To know more about the syntax of usage of cpp just type cpp at
command prompt.
IX, we can view the expanded code by using the option -E. With this option the output of the
_ rocessor is displayed on the terminal. If we use option -P, then the output of the preprocessor
ored in a file with the same name as source file but with a ".i " extension. We can use -I to inform
preprocessor about .the path of included files.
Exercise
-
ume stdio.h is included in all programs.
#def ine
MAX
5;
main ( )
{-
printf{"%d",MAX) ;

·Ilir.
402
C in Depth
(2) #define
MSSG
printf("If
you
lapse,
don't
collapse\n
U );
main ( )
{
,MSSG
(3) #define
PROD
(x,y)
«xl * (y»
main ( )
{
int
a=3,b=4;
printf ("Product
of
a
andb
=
%d", PROD (a,b) ) ;
(4) #define
A
50
#define
B
A+100
main ( )
{
int
i,j;
i=B/20;
j=500-B;
printf("i
=
%d,
j
=
%d\n",i,jl;
(5) #define
NEW_LINE
printf("\n");
#define
BLANK_LINES(n)
{int
i;
for(i=O;i<n;i++). printf("\n");}
main ( )
{
printf ("When
you
have
a
chance");
NEW_LINE
print f (" to
embrace
an
opportun~ty") ;
BLANK_LINES (3)
printf("Give
it
a
big
hug");
NEW_LINE
(6 ) #define
INFINITE
while (1)
#define
CHECK(a)
if(a==O). break
main ( )
{
int
x=5;
INFINITE
{
printf ("%d
\\,x- -) i
CHECK (x) i
(7) #define
ABS (x)
«x) <0
?- (x) : (x) )
main ( )
{
int
array[4]={l,-2,3,-4};

C Preprocessor
int
*p=array+3 ;
while (p>=array)
{
printf ("%·d . ", ABS (*p) ) ;
p- -;
.
}
#define
main ( )
{
printf ("If
the
lift
to
success
is
broken,
").
printf (".Try
the
stairs. ") .
oJ) #define
CUBE (x)
lx*x*x)
main ( )
{
printf("%d\n",CUBE(1+2»;
::'0) #define
CUBE (x)
«x) * (x) * (x) )
main ( )
{
int
i=l;
while (i<=8)
printf("%d\t",CUBE{i++»;
_l)#define
SWAP(dtype,x,y)
{dtype
t;
t=x+y,
x=t-x,
y=i-y;}
main ( )
{
int
a=l, b=2, x=3, y=4, s=25, t=26 i
SWAP(int,a,b)
SWAP(int,x,y)
SWAP(int,s,t)
printf("a=%d,b=%d,x=%d,y=%d,s=%d,t=%d\n",a,b,x,y,s,t) ;
:2)#define
INC(dtype,x,i)
x=x+i
main ( )
{
int
arr[5]={20,34,56,12,96},*ptr=arr;
INC(int,arr[2] ,3);
INC(int*,ptr,2);
printf("*ptr
=
%d\n",*ptr);
:3) #def ine
INT
int
main ( )
{
403

404
INT
a=2, *p=&a;
p ri n t f ( " %d
%d \ n" , a, *p) ;
(14) #define
Y
10
main ( )
{
#if
X
I I
Y
&&
Z
printf ("Sea
in
Depth\n");
#else
printf("See
in
depth\n");
#endif
(15)main(
{
int
x=3,y=4,z;
z=x+y;
#include<string.h>
printf("%d\n",z) ;
(l6)#define
DIF-F(FNAME,
DTYPE,
RTYPE)
\
RTYPE
FNAME(DTYPE
X,DTYPE
Y){
return
X-Y;}
DIFF(diff_int,int,int)
DIFF(diff_iptr,int*,int)
DIFF(diff_float,f1oat,float) ;
DIFF(diff~fptr,float*,int);
main( )
{
C in Depth
int
iarr[5)={l,,,2,3,4,5},a,p,q;
~_
float
farr[7)={1.2,2.3,3.4,4.5,5.6,6.7,7.8},b;
a=diff_int(iarr[4) ,iarr[l);
b=diff_float(farr[6J ,farr[2);
p=diff_iptr(&iarr[4) ,&iarr[l);
q=diff_fptr(&farr[4) ,&farr[1);
printf("a
=
%d,
b
=
%.1f,
p
=
%d,
q
%d\n",a,b,p,q);
(17)#define
MAX
3
main( )
{
printf ("Value
of
MAX
is
%d\n" ,MAX);
#undef
MAX
#ifdef
MAX
printf ("Have
a
good
day");
#endif
..
(18) #define
PRINT1 (message)
#define
PRINT2 (message)
printf(message) ;
printf("message");

"
Preprocessor
-define
PRINT3 (message)
printf (#message);
ain ( )
, 405
PRINT1 ("If
we
rest,
PRINT2("If
we
rest,
PRINT3("If
we
rest,
we
rust. \n")
we
rust.\n")
we
rust. \n")
define
:nain ( )
{
show(value)
printf
#value
"
=
%d\n",
value) ;
int
a=10,b=5,e=4;
show(a/b*e);
::)#define
MACRO (a)
if(a<=5)
printf(#a"
main( )
{
int
x=6,y=15;
if (x<=y)
MACRO (x) ;
else
MACRO (y) ;
::)main (
{
#line
100 . "system.e"
printf ("%d
%s\n", __LINE__ , __FILE__ ) ;
Answers
%d\n", a) ;
-.
This program will show errors since there is a semicolon after 5, and due to this after expansion
the printf statement looks like this- printf(" %d ", 5;);
If you lapse, don't collapse
There is a space between the macro name PROD and left parenthesis, so after macro expansion
the printf statement looks like this:
printf("Product of a and b = %d", (x,
~) ( (x)*(y) )(a, b) );
Therefore the program gives error that x and yare undefined symbols.
i = 55, j = 550
The values are calculated as : i = A+100/20; U= 500-A+I00;
When Y0U have a chance
to embrace an opportunity
Give it a big hug
54321
432 1

406
C in Depth
(8)
This program will give error, since the name of the macro is not a valid C identifier.
(9)
7
The macro call CUBE(1+2) is expanded as - (1+2*1+2*1+2)
(10) 6 120 504
The macro CUBE(i++) is expanded as ( (x++) *(x++)*(x++) ), and the values of such expressIOns
are undefined. So although we have got the output but these values may differ.
(11) a = 2, b = 1, x = 4, y = 3, S = 7, t = 26
The first two macro calls swapped the values, but the third one gave unexpected results.
The third macro call was expanded as-
{ int t; t = s+t, s = t-s, t = t-t; }
These calculations were performed using the variable t that is declared inside this block.
So the value of variable t that was defined outside the block remaips unchanged(26). The variab ~
t declared inside the block contains garbage value, so the variable s gets this garbage value.
(12) *ptr = 59
(13) 2 2
(14) See in depth
(15) This program will give many errors, all of them stating that declaration is not allowed here.
We know that after expansion, the #include directive is replaced by the contents of the file.
this case also the preprocessor inserts all the contents of file string.h after the statement z =
+y; The file string.h contains many declarations, and we know that in C, declarations are allo
only at the beginning of a block before any executable statement. So we get all these errors. T
program will compile correctly if we put the #include directive before all executable statem
(16) a = 3, b = 4.4, p = 3, q = 3
(17) Value of MAX is 3
(18) If we rest, we rust.
message"If we rest, we rust.\n"
(19) a/b*c = 8
(20) In this program we'll get the error of misplaced else. Since x <= y is true, so MACRO(x)
be expanded as-
if(x<=y)
if (x<=5)
printf ("x
%d\n" ,x) ; ;
else
if (y<=5)
printf ("y
%d\n" ,y) ; ;
The double semicolons cause the problem. A single semicolon is considered as a null state
so there are two statements in the if part, but they are not inside parentheses. So to compile
program correctly, we'll have to remove one semicolon from the macro expansion or fron:
macro call, or we may enclose the macro call inside parentheses.
(21) 100 system.c

Chapter 13
Operations on Bits
_ know that inside the computer; data is represented in binary digits called bits (0 and 1). Till now
ere able to access and manipulate bytes only. But some applications, such as system programming
. e manipulation of individu~l bits within a byte. In most high-level languages this facility is not
-- able, but C has tr.e special feature to manipulate indiviaual bits of a byte. This feature is implemented
gh bitwise operators that support bitwise operations. These bitwise operators are-
Operator
Meaning
&
bitwise AND
I
bitwise OR
1\
bitwise exclusive OR (XOR)
~
One's complement
«
bitwise left shift
»
bitwise right shift
all the operators are binary, except the complement operator, which is unary. These bitwise operators
on data of integral types only i.e. char, int, short, long including both signed and unsigned types.
~en these operators are applied to signed types, the result may be implementation dependent, because
erent implementations represent the signed data in different ways.
e operators operate on each bit of the operand, so while using these operators we'll consider the
representation (bit pattern) of the operand. While writing the bit pattern, the numbering of bits
from 0 and they are numbered from right to left. For example if we have an integer variable
= Ox3C60, the binary pattern of this integer is 0011 1100 0110 0000. The numbering of bits is-
15 14 13 12 1110
9
8
7
6
5
4
3
2
1·0
the rightmost(Olh) .bit is the least significant bit, while the leftmost(15Ih) bit is the most significant
A bit is on if it has value 1, while it is off if it has value O.
'n use a function bit-pattern( ) in our programs, that will take an integer as input and print the 16
binary pattern of that integer. The definition of this function is given in program P13.13. In our

408
C in Depth
examples, we'll represent the integers in hexadecimal, because it is easier to convert hexadecimal to
binary and vice versa.
All bitwise operators except the complement operator can be combined with the assignment operator
to form the compound assignment operators-
&=
1=
«=
»=
/\=
"
,
,
13.1
Bitwise AND ( & )
..
It is a binary operator and requires two operands. These operands are compared bitwise i.e. all the
corresponding bits in both operands are compared. The resulting bit is 1, only when the bits in both
operands are 1, otherwise it is O.
Boolean Table
Bit of operand!
Bit of operand2
Resulting Bit
0
0
0
0
1
0
1
0
0
1
1
1
Let us take a = Ox293B and b = OxlA2F are two integer variables. The binary representations of these
variables and the result after performing bitwise AND operation is shown below-
a
0010 1001 0011 1011
(Ox293B)
b'
0001 1010 0010 1111
(OxlA2F)
a&b
0000 1000 0010 1011
(Ox082B)
/*P13.1*/
#include<stdio.h>
main( )
{
int
a,b;
.
printf ("Enter
values
for
a
and
b
") ;.
scanf("%d%d",&a;&b);
printf ("a
= %d\t\t", a);
bit_pattern(a);
printf ("b. =
%d \ t \ t" ,b);
bit_pattern (b) ;
printf("a&b
=
%d\t\t" ,a&b);
bit_pattern(a&b);
If you want to enter and display the values of a and b in hexadecimal, then use %x. The definitio
of function bit_pattem( ) is given in program P13.13.
13.2
Bitwise OR ( I )
The corresponding bits of both operands are compared and the resulting bit is 0, only when the bits
in both operands are O,otherwise it is 1.

erations on Bits
Boolean Table
Bit of operand 1
Bit of operand 2
Resulting Bit
0
0
0
0
1
1
1
0
1
1
I
1
The result of bitwise OR operation performed between variables a and b is shown below-
a
0010 1001 0011 1011
(Ox293B)
b
0001 1010 0010 1111
(Ox1A2F)
a I b
0011 1011 0011 1111
(Ox3B3F)
*P13.2*/
-include<stdio.h>
::rain ( )
int
a,b;
printf ("Enter
values
for
a
and
b
") ;
scanf("%d%d",&a,&b) ;
printf{"a
=
%d\t\t",a);
bit_p"attern(a);
printf("b
=
%d\t\t",b);
bit_pattern(b);
printf("alb
=
%d\t\t",alb);
bit_pattern(a!b);
13.3
Bitwise XOR (
A
)
409
The corresponding bits of both operands are compared and the resulting bit is 1, if bits of both operands
ave different value, otherwise it is O.
~.
Boolean Table
Bit of operand 1
Bit of operand 2
Resulting Bit
0
0
0
0
1
1
1
0
1
1
1
0
The result of bitwise XOR operation performed between variable a and b is shown below-
,
a
0010 1001 0011 1011
(Ox293B)
b
0001 1010 0010 1111
(Ox1A2F)
a /\ b
0011 0011 0001 0100
(Ox3314)
/*P13.3*/
4include<stdio.h>
main( )

bit_pattern(a) ,
bit_pattern(b) ,
bit_pattern(aAb) ,
410
int
a,b,
printf ("Enter
values
for
a
and
b
scanf("%d%d",
&a,
&b);
printf("a
=
%d\t\t",
a),
printf("b
=
%d\t\t",
b),
printf("aAb
=
%d\t\t",
aAb),
") ;
. C in Dep
When the bitwise operators &, I , 1\ operate on two operands of different sizes, then the size of small
operand is increased to match the size of larger operand. For example if there are two operands
sizes 16 and 32 bits, then the 16-bit operand will be converted to 32 bits. The extra bits are add
to the left of the smaller operand. If the smaller operand is unsigned then all these extra bits are fill
with zeros, and if it is signed then these bits are filled with the sign bit.
13.4
One's Complement ( ,.., )
One's complement operator -is a unary operator and requires only one operand. It negates the value c
the bit. If the bit of the operand is 1 then the resulting bit is 0 and if the bit of the operand is 0 the
the resulting bit is 1.
Boolean Table
Bit of operand
Resulting Bit
0
1
1
0
a
~a
b
~b
0010 1001 0011 1011
1101 0110 11000100
0001 1010 0010 1111
1110 0101 1101 0000
(Ox293B)
( OxD6C4)
(Ox1A2F)
(OxE5DO)
/*P13.4*/
#include<stdio.h>
main(
{
int
a;
p:cintf("En'ter
value
for
a
");
scan f ( "%d" , &a) ;
printf("a
= %d\t",a),
bit_pattern(a) ,
printf("-a
= %d\t",-a);
bit_pattern(-a),
When the complement operator is applied to an operand twice, then result is the original operand i
~(~a) is equal to a. This feature of complement operator can be used for' encrypting and decryp
data. To encrypt the data, we can apply complement operator to it, and to decrypt the data i.e. to
back the original data we can apply the complement operator to the encrypted data. For exampl
Original data
0000 1111 0101 0011
Encrypted data :
1111 0000 1010 1100 ( By applying ~ to original data)

rations on Bits
rypted data :
0000 1111 0101 0011 ( By applying ~ to encrypted data)
3.5
Bitwise Left Shift ( «
)
411
cis operator is used for shifting the bits left. It requires two operands. The left operand is the operand
ose bits are shifted and the right operand indicates the number of bits to be shifted. On shifting the
•
left, an equal number of bit positions on the right are vacated. These positions are filled in with
its. Let us take an integer variable a = Ox1346. The binary representation of x is-
0001 0011 0100 0110
- w we'll find out a «
4
Initial Bit pattern
Bit pattern after left shifting
10001 0011 0100 0110~·
0001
'----.r'
Lost Bits
I 0011 0100 0110 0000 I
'--y---J
Bits filled
shifting all bits to the left by 4, the leftmost 4 bits are lost while the rightmost 4 bit positions become
_ pty which are filled with 0 bits.
~P13.5*/
-~nclude<stdio.h>
-=in ( )
int
a;
printf ("Enter
value
for
a
:
");
scanf ("%d", &a) ;
printf("a
%d\t",a);
bit pattern(a);
a=a«i;
printf("a
%d\t",a);
bit pattern(a);
3.6
Bitwise Right Shift ( »
)
's operator is similar to the left shift operator, exceptthat it shifts the bits to the right side. On shifting
p bits right, an equal number of bit positions on the left are vacated. These positions are filled in with
its in unsigned integers. We'll again take a variable a = Ox1346, and this time we'll find out a »
Initial Bit pattern
Bit pattern after right shifting
I 0000 0001 0011 01001
0110
'--y---J
'--y---J
Bits filled
Lost Bits
Right shift in an unsigned integer
right shift if the first operand is a signed integer, then the result is compiler dependent. Some compilers
ow logical shift while others may follow arithmetic shift.

h
412
C in Depth
Logical shift - The vacated bits. are always filled with zeros.
Arithmetic shift - The vacated bits are filled with the value of the leftmost bit in the initial bit pattern.
If the leftmost bit is 1, then the vacated positions are filled with 1, and if the leftmost bit is 0, then
the vacated positions are filled with 0.
The following two examples show arithmetic shift in signed integers. In first case the leftmost bit is
1 so the vacated bits are filled with 1, and in the second case the leftmost bit is 0, so the vacated bits
are filled with 0.
--.j 1000 10100011 1011
--.j 0100 10100011 1011 I
11111 1000 101000111
1011
I0000 0100 1010 0011
1011
•
_Arithmetic right shift in signed integers
Actually the leftmost bit represents the sign bit. If the number is negative, then it is set to 1. So
.~
other words we can say that, in arithmetic shift the vacated bits are filled with the sign bit.
We know that expressions like x/2 or x*5 do not change the value of x , similarly x«4 or x»3 wiL
not change the value of x. If we write x = x«4 , then only the value of x will be changed.
While using left shift and right shift operators, the result is undefined if the right operand is negati -
or it is more than the number of bits used to represent the left operand.
/*P13.6*/
#include<stdio.h>
main ( )
{
int
a;
printf ("Enter
value
for
a
") ;
scanf ("%x" ,&a) i
printf("a
%x\t",a);
bit_pattern(a);
a=a»2;
printf ("a
%x\t", a);
bit_pattern(a);
13.7
Multiplication and Division by 2 using shift operators
The effect of shifting one bit right is equivalent to integer division by 2, and the effect of shifting -
bit left, is equivalent to multiplication by 2. So we can use shift operators to multiply and 4ivide inte."
by power of 2. For example to multiply an integer by 22,
we~ll shift it left by 2 bits, tdmultiply
23 we'll shift it left by 3 bits. Similarly to divide an integer by 22, we'll shift it right by 2 bits, to di .
by 23 we'll shift it right by 3 bits.
In the case of right shift, if the compiler follows logical shift the~ the effect of division by· 2 is
seen in signed integers.

erations on Bits
413
I
Statement
Bit Pattern of a
Decimal value of a
i)
a = 45;
0000 0000 0010 1101
45
Dj
a = a «
1;
0000 0000 0101 1010
90
( = 45*2 1 )
Iii)
a = a «
2;
0000 0001 0110 1000
360
( = 90*22)
iv)
a = a «
5;
0010 1101 0000 0000
11520
( =360* 2S )
y)
a = a «
3;
0110 1000 0000 0000
26624
( !=11520*23 )
'i)
a = a »
1;
0011 0100 0000 0000
13312
( =26624 1.2 1 )
ill)
a = a»
6,
0000 0000 1101·0000
208
(=13312/2 6
)
iii)
,a = a »
4;
0000 0000 0000 1101
13
( =208 1 24 )
IX)
a = a »
1;
0000 0000 0000 0110
6
( =13 1 21 )
- the statement (v), the effect of multiplication by 23 is not seen, this is because a bit with a value
: 1 has been dropped from the left. So in the case of left shift, if a bit with value of 1 is shifted
d lost, then the effect of multiplication by powers of 2 is not seen.
statement (ix), value of a is 13 and it is shifted right by 1 bit, the result is 6 which shows that the
ainder. is discarded.
3.8
Masking
king is an operation in which we can selectively mask or filter the bits of a variable, such that some
are changed according to our needs while the others remain unchanged. Through masking, we can
=anipulate bits in a bit pattern and perform operations such as testing a bit, inverting a bit, switching
or off a bit. Masking is performed with the help of bitwise operators. The bit pattern to be masked
- taken as the first operand and the second operand is called mask. The mask is selected according
our needs.
further discussion, we will take an arbitrary bit pattern of 16 bits and show different types of masking
it.
b lS b l4 b l3 b l2 bilblOb9bg b7 b6 bsb4b3b2b , bo
Here b ls.b 14
b l.bo are bits and they may be 0 or 1.
3.8.1
Masking Using Bitwise AND
b1Sb l4 b l3 biZ
bll b lO
b9 bg
b7
b
bs
b4 b3 bz
b l
bo
(Original Value)
6
0
0
0
0
1
1
1
1
0
0
0
0
1
1
1
1
(Mask)
0
0
0
0
bll b lo
b
bg
0
0
0
0
b3
bz
bl
bo
(New Value)
9
~ere we can see that whenever there is a 0 in the mask, new bit value becomes 0 while the new bit
ue remains unchanged when there is a 1 in the mask.
,-e can switch off any bit by using & operator. For example if we want to switch off the last 4 bits
a bit pattern, we can 'choose the mask such that last four bits are O.
a = a & OxFFFO

414
C in Depth
(Original Value)
(~ask)
(New value)
blSb l4 b l3 b l2 bll b lo
b9
bs
b7
b6
bs
. b4
b3
b2
bl
bo
(Original Value)
1
1
1
1
1
1
1
1
1
1
0
0
0
0
(Mask)
blsb l4 bl) b l2 b ll b lO
b9
bs
b7
b6
bs
b4
0
0
0
0
(New Value)
Later in this chapter, we'll see a better method to switch off bits using bitwise AND and complement
operator, .
Bitwise AND operator is generally used to test whether a particular bit is on or off. Suppose we want
to test the Slit bit, we will select the mask with only 5th bit on-
blSb l4 b l3 bl2 b ll b lO
b9
bs
b7
b6
bs
b4
b3
b2
bl
bo
0000000000100000
o 0
0
0
0
0
0
0
0
O.
bs
0
0
0
0
0
If 5th bit in the original bit pattern is 0, then the new value will be zero, and if 5th bit in original bit
pattern is 1, then the new value will be non zero
mask
=
Ox20;
if ((a&mask) ==0)
printf("5th
bit
is
off");
else
printf("5th
bit
is
on");
-
So by choosing an appropriate mask and using bitwise AND operator, we can test whether a bit is on
or off. We can retrieve bit value by using if.. .else, conditional operator or shift operator. Let us see
different methods for retrieving 5th bit-
mask = Ox20;
1.
. if ((a&mask) ==0)
bit=O;
else
bit=l;
2.
bit= (a&mask)?l: 0;
3.
bit=(a&mask»>5;
/*P13.7
A
program
to
test
5th_bit*/
#include<stdio.h>
main( )
{
int'
a,bit,mask=Ox20;
printf ("Enter
an
integer
") ;
scanf ("%d", &a) ;
printf("a'
=
%d\t",a);
bit_pattern(a);
if ((a&mask) ==0)
bit=O;
else
bit=l;
printf("5th
bit
is
%d\n",bit);

Operations. on Bits'
415
13.8.2
Masking Using Bitwise OR
b lSb l4 b l3 biz
bl] blo
b9
bg
b7
b6
bs
b4 bJ
bz
bl
bo
(Original Value)
0
0
0
0
1
1
1
0
0
0
0
1
1
1
1
(Mask)
bls b l4 b l3 b l2
1
1
1
b7
b6
bs
b4
1
1
1
1
(New Value)
ere we can see that whenever there is a 1 in the mask, new bit value becomes 1 while the new bit
~ue remains unchanged when there is a 0 in the mask.
e can use bitwise OR operator to switch on a particular bit. The mask is chosen in such a way that
e bits to be switched on should be 1 and rest of the bits should be o.
~uppose we want to switch on the 5th bit
b]S b]4 b 13 biz bl! blo
b9
bg
. b7
b6
bs
b4 b3 bz
bl
bo
(Original Value)
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
(Mask)
bls b l4 b 13 biz
bll blo
b9
bg
b7
b6
1
b4
bJ
bz
bl
bo
(New Value)
mask = Ox20;
a = a I mask;
*P13.8
A
program
to
switch
on
the
5 th
bit*/
;:nclude<stdio.h>
in ( )
int
a,bit,mask;Ox20;
printf ("Enter
an
integer
scanf ("%d" ,&a) ;
printf (."a
=
%d\t" ,a);
a=almask;
printf ("After
switching
printf("a
=
%d\t",a);
\\ ) ;
bit_pattern(a) ;
on
5th
bit,
the
bit_pattern(a) ;
value
of
a
is
: \n") ;
.8.3
Masking Using Bitwise XOR
b lSb l4 b l3 biz
bl] blo
b9
bg
b7
b6
bs
b4 b3 bz
bl
bo
(Original Value)
0
(j
0
0
1
1
1
1
0
0
0
0
1
1
1
1
(Mask)
b lSb l4 b l3 biz hll b lO
b9
bg
b7
b6
bs
b4 b3 b2
bl
bo
(New Value)
-
e we can see that whenever there is 1 in the mask the corresponding bit value is inverted while
new bit value remains unch~nged when there is a 0 in the mask.
have seen earlier that the complement operator(-:--) complements all the bits in a number. But if we
t to complement some particular bits in a number, then we can, use bitwise XOR operator.
- e mask should be chosen in such a way that the bits to be complemented should be I;; rest of the
should be o.
suppose we want to invert the value of 5th bit.

( 5th bit changes to 0, and all other bits unchanged)
( 5th bit changes to 1, and all other bits unchanged)
(
5t~ bit changes to 0, and all other bits unchanged)
416
C in Depth
, b lSb l4 b l3 b l2
bll b lO
b9
bg
b7
b6
bs b4
b3
b2
b,
bo
(Original Value)
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
(Mask)
b lSb l4 b 13 b l2 bll b lO
b9
bg
b7
b6
bs b4
b3
b2
b,
bo
(New Value)
mask = Ox20;
a = a
1\ mask
So we can use this operator to toggle bits between values 0 and 1. For example if we have an integ
~llriable a, and we want to toggle its 5th bit.
.
S~~pose initially 5Ul bit in variable a is 1
i~ask = Ox20;
a = a
1\ mask
,
a = a
1\ mask
a = a
1\ mask
Fromthe above operations we can also see that when an operand is XORed with a value twice, re
is same as the original operand. This feature can be used for encryption..
For example. if initial value of a variable var = OxF13A
var = var
1\ Ox1F; (Encryption)
var = var I\Ox1F; (Decryption)
After first statement the value ofvar becomes OxF125, while after second statement we get back ori
value of var (OxF13A).
/*P13.9
A
program
to
toggle' 5th
bit
using
bitwise
XOR
opertor*/
#include<stdio.h>
main( )
{
int
a,bit,mask=Ox20;
printf ("Enter
an
integer
") ;
scanf ("%d", &a) ;
printf("a
=
%d\t",a);
O'bit_pattern(a);
a
=
a "mask;
printf("a
=
%d\t",a);
bit_pattern(a);
a
=
a"mask;
printf("a
=
%d\t",a);
bit:-pattern(a);
When a value is XORed with itself the result is zero, this is ~bvious since all corresponding bits
be same. For example value of expressions like varl\var will be zero. This feature of XOR op
can be utilized to compare two values for equality.
13.8.4
Switching off Bits Using Bitwise AND and Complement Operator
.
°
I
.
We have seen that bits can be switched off using bitwise AND operator. Let us see what sort of po
problem arises when we use bitwise AND operator.
Suppose we want to switch off the 5th bit of an integer variable a, we can take the mask as-
1111 1111 1101 1111 (OxFFDF)

erations on Bits
417
a = a & OxFFDF;
_-ow suppose we use this code on a computer that uses 32 bits to store an integer, then OxFFDF would
_ represented as-
0000000000000000 1111 1111 1101 1111
_- w this mask will switch off the 16 leftmost bits also, which is not intended. So on a computer using
=_ bits for an integer, the appropriate mask to switch off the 5th bit should be-
Illl Illl 1111 1111 1111 1111 1101 lll1 ( OxFFFFFFDF)
a = a & OxFFFFFFDF;
- would be better if we could write the same line of code for both type of computers. We can do
's by combining the complement operator with the AND operator as-
a = a &
~Ox20
a computer using 16 bits for an integer, this is interpreted as-
a ~ a & 11111111 1101 llU
_ d on a computer using 32 bits for an integer, this is interpreted as-
a = a & 1111 1111 1111 1111 1111 1111 1101 1111
"P13.l0
A
program
to
switch
off
the
5 th
bit*/
=:nclude<stdio.h>
-
in ()
iht
a,bit,mask=Ox20;
printf ("Enter
an
integer
scanf ("%d" ,&a) i
printf("a
=
%d\t",a)i
a=a&-:maski
printf ("After
switching
printf("a
=
%d\t",a);
) ;
bit_pattern(a) ;
off
the
5 th
bit,
bit_pattern(a) ;
the
value
of
a
is
: \n" ) ;
_'ow let us summarize the different manipulations on 5th bit in an integer variable a-
mask = 'Ox20;
.
Test 5th bit in variable a :
a· & mask
Switch or 5th bit in variable a:
.a = a I mask;
Switch off 5th bit in variable a:
a = a &
~ mask;
Invert 5th bit in variable a :
a = a /\ mask;
!milarly we can manipulate any bit by these operations, we just have to choose the mask appropriately.
::-or manipulating 6th bit:
mask = Ox40
(0000 0000 01 00 0000)
::-or manipulating 9th bit :
mask = Ox200
(0000 0010 0000 0000)
::-or manipulating 3rd and 6th bits :
mask = Ox48
(0000 0000 0100 1000)
-e can calculate the mask by left shifting integer 1 by position of bit.
mask = 1 «
bitposition;
For manipulating 4th bit: mask = 1«4 ( ooqo 0000 0001 0000 )
For manipulating 6th bit : mask = 1«6 ( 0000 0000 0100 0000 )

418
/*P13.ll
Program
to
test
any
bit
in
an
integer*/
#include<stdio.h>
main( )
{
int
a,bit,mask,bitposition;
print f( "Enter
ian
integer
) ;
scanf("%d",&a) ;
printf ("Enter
the
bit
position
) ;
scanf("%d",&bitposition);
mask=l«bitposition;
printf("a
=
%d\t",a);
bit_pattern(a-);
if ((a&mask) ==0)
bit=O;
else
, bit=l;
printf("The
bit
at -position
%d
is
%d\n",bitposition,bit);
C in Depth
If we want to manipulate all ,bits one by one, them we can use a loop, for example this program will
switch on all the bits in the ~nteger variable' a. '
/*P13.l2
Program
to
switch
on all
the
bits
in
an
integer, variable*/
#include<stdid.h>
main( )
{
int
a, mask, i;,
printf ("Enter
the
scanf ("%d" ,&a) ;
printf("%d\t",
a);
for(i=0;i<=15;i++)
(
value
of
a
");
bit_pattern(a);
mask=l«i;
a=alma,sk;
/*switch
on
the
ith
bit*/
}
printf("%d\t",a) ;
bit_pattern(a);
There is one other way also to calculate the appropriate mask for a particular bit position. We can
an array of masks as-
unsigned int arr_mask[] = { Ox1, Ox2, Ox4, Ox8, Ox10, Ox20, Ox40, Ox80, Ox100, Ox200, Ox400, Ox8
Ox1000, Ox2000, Ox4000, Ox4000};
Now the mask for manipulating any bit can be calculated as-'
mask = arr_mask[bitposition);
For example to switch on the 4th bit we can write,
x = x I arr_mask[4);
13.9
Some additional Problems
Problem 1
Write a program to print bitpatt~rn of a 16 bit integer.

Operations on Bits
419
_~ow we are in a position to write the definition of the function bit-pattern( ), that we have been using
- I now. Printing the binary pattern of an integer requires testing of each bit in the integer. The bit
umbering is from right to left, but we'll have to print the bits from left to right so firstly 15th bit will
printed, then 14th and so on till Oth bit. So we will start testing bits from the 15th bit onwards. To
-est 15th bit, mask should be 1«15. Similarly to test 14th bit, mask should be 1«14 and so on.
*P13.13
Printing
the
binary.
pattern
of
a
16' bit
integer*/
include<stdio.h>
ain ( )
int
a;
printf ("Enter
an
integer
") ;
scanf ("%d" ,&a) ;
bit_pattern(a) ;
;,it_pattern(int
a)
{
int
i,mask;
for (i=15; i>=O; i- -.)
{
mask=1«i;
if ( (a&mask) == 0)
printf ("0");
else
printf("1");
printf ("\n");
In pt iteration mask is
In 2nd iteration mask is
In 3rd iteration mask is
In: last iteration mask is
1000 0000 0000 0000
0100 0000 0000 0000
0010 0000 0000 0000
0000 0000 0000 0001
15th bit is tested and printed
14th bit is tested and printed
...
13th bit is tested and printed
oth bit is tested and printed
To make this program portable, we can modify the for loop as-
for( i = sizeof(int)-1 ; i>=O; i- -)
Problem 2
Write a program to find whether the number is even or odd, using bitwise operators.
A number will be odd if its least significant bit(rightmost) is 1 and it will be even if its least significant
bit is O. This means we just have to test whether the least significant bit is 1 or O. We know that the
bitwise AND operator is suitable for testing bits. Now we have to choose an appropriate mask. Since
we have to check the rightmost bit, so we will take a mask in which the rightmost bit is 1 and all
other bits are O.
/*P13.14
Program
to
find
whether
a
number
is
even
or
odd*/
#include<stdio.h>

420
main(
int
num;
int
mask=Oxl;
printf ("Enter
a
number
") ;
scanf("%dH,&num) ;
If( (num&mask) ==0)
printf ("Number
is
even\n H);
else
printf ("Number
is
odd\n H);
Problem 3
C in Depth
Write a program that inputs a binary pattern less than or equal to 16 bits and converts it to an intege
/ *P13 .15
Program
to
convert
a
binary
pattern
to
an
integer* /
#include<stdio.h>
main ( )
{
char
bit;·
int
i,num=O;
printf("Enter
any
bit
pattern
less
than
or
equal
to
16
bits ·:\n
H
]
for(i=0;i<=15;i++)
{
bi t=getchar ( ) ';
if(bit=='O')
num=num«l;
else
if(bit=='l')
num=(num«l) +1;
else
break;
}
printf("Hexadecimal
%x\nH,num);
printf("Decimal
%d\nH,num);
Problem 4
Write a program to swap the first 8 bits with the last 8 bits in a given unsigned 16 bit integer.
For example if initially the bit pattern is
- 1000 1111 00110001
After swapping it should become
- 0011 0001 1000 1111
This can be achieved as-
x
1000 1111 0011 0001
x«8
0011 0001 0000 0000
x»8
0000 0000 1000 1111
x«8 I x»8
0011 0001 1000 1111
If the integer is unsigned then this method will work properly but if the integer is a signed neg,
number, then according to arithmetic shift after right shifting, the leftmost 8 bits will be filled with

ations on Bits
421
d we will not get our desired result. To avoid this problem we can force the leftmost 8 bits-to
zero after the right shift. So now this will be as:
'.
x = (x«8) I ((x»8) & OxOOFF)
_13.16
Program
to
swap
first
8
bits
with
the
last
8
bits
in
a
16-
__=
integer* /
-=clude<stdio.h>
-::n ( )
int
num, i;
printf ("Enter
number
in. hexadecimal
") ;
scanf ("%x" , &num) ;
printf ("Before
swapping,
num
%x\n" , num) ;
bit_pattern(num);
num=(num«8) I ((num»8)&OxOOFF)
printf ("After
swapping,
num
=
%x\n", num) ;
bit_pattern(num);
\
e a program to swap the values of 2 variables using bitwise XOR.
_13.17
Swapping
the
values
without
using
a
temporary
variable
through
__=wise
XOR*/
- clude<stdio.h>
- ':n ( )
int
x,y;
printf·( "Enter
values
for
x
and
y
scanf("%d%d",&x,&y) ;
printf {"x
=
%d,
y
%d\n" , x, y) ;
x=x"y;
y=x"y;
x=x"y;.
printf ("x
%d,
y
%d\n" , x, y) ;
oblem 6
\\) i
- e a program to print the bit pattern of 2's complement of a number
_ know that the 2's complement can be found out by adding 1 to the one's complement. Another
to obtain the 2's complement is that, scan the bit pattern from right to left, and invert all the b,its
the first appearance of a bit with value 1. For example-
Bit pattern
0000 0001 0110 0000
2's complement
1111 1110 1010 0000
_13.18
Program
to
print
the
two's
complement
of
a
number.
k /
:- clude<stdio.h>
<n( )

422
int
num, i, mask;
pi-intf ("Enter
a
number
") ;
scanf("%dH,&num) ;
printf("Two'S
complement
is
%d\nH,-num+l);
for(i=O;i<=15;i++)
{
I*Fir;td
a
bit
with
value
1*1
C in Dep
mask=l«i;
num=num"mask;
I*Invert
the
bit*1
}
printt ("Two's
complement
is
Problem 7
%d\n H, num) ;
Write a function that rotates'bits to right by n positions.
Initial bit pattern
0000 0000 0000 1101
After rotating right by 4 bits
1101 0000 0000 0000
Similarly write a function that rotates bits to left by n positions.
. Initial bit pattern
1001 0000 1001 0011
After rotating left by 3 bits
.1000 0100 1001 1100
1*P13 .19 * 1
#include<stdio.h>
main(
{
int
n urn, n, i , bit;
printf ("Enter
number
in
hexadecimal
") ;
scanf("%xH,&num) ;
bit_pattern(num) ;
printf ("Enter
number
of
Positions· to
be
rotated
") ;
scanf("%dH,&n) ;
n=n%16;
num=rotate_right(num,
n);
printf ("Number
after
right
rotation
is
%x\n H, num) ;
bit_pattern(num) ;
num=rotate_left(num,n) ;
printf ("Number· after
left
rotation
is
%x\n H,num) ;
bit_pattern(num) ;
)
rotate_right (int
num, int
n)
{
int
i,lsbit;

1*
Test
LSB
*1
ations on Bits
for(i=l;i<=n;i++~
{
lsbit=num&1?1:0;
num=num»l;
if (lsbit==O)
num=num&-(1«15);
I*Switch
off
MSB*I
else
num=numl (1«15);
I*Switch
on
MSB*I
return
num;
__:::ate_left (int
num, int
n)
int
i,msbit;
for(i=l;i<=n;i++)
msbit=num&(l«15)?1:0;
I*Test
MSB*1
num=num«l;
if (msbi t== 0)
num=num&-l;
I*Switch
off
LSB*I
else
num=num!l;
I*Switch
on
LSB*I
return
num;
oblem 8
423
-te a function mult(num, n, err) that uses the shift operators »
and «
to compute the value of
* 2"). Assume that both num and n are unsigned positive integers and are 32 bits in
size~ The
• parameter is set by the function to zero if calculation is successful and 1 if an overflow occurs..
-
overflow occurs when the resultant value doesn't fit in the 32 bit unsigned integer. Do not use add,
tract, multiply or divide to compare the result.
?13 . 20 * 1
:- clude<stdio.h>
-in ( )
unsigned
int
num, n, err=O;
printf ("Enter
the
number
and
power
of
2
") ;
scanf ("%u%u" ,&num, &n) ;
mult(num,n,err) ;
_t (int
num, int
n, int
err)
unsigned
int
resu1 t=num;
.while(n>O)
{
num=num«l;
I*Multiply
by
2*1
n- - i
if (num<result)
-----------------------~--_.-

424
err=l;
break;
result=num;
}
if (err==l)
printf ("Overflow\n"
);
else·
printf("Result
=
%u\n",result);
C in Depth
Now we know very well how to manipulate individual bits within a byte. This bit manipulation is usefi
in maintaining boolean flags. For example we can use a charaCter variable to hold 8 flags or an integ
variable to hold 16 flags. Each bit can be used to represent a flag. This will definitely save memo
when many flags are to be used in a program and als6 it is easy to maintain s,ingle variable for seve
flags. We can test, switch on or off, toggle any individual flag by bitwise operators. Different m
is taken for manipulating each flag. To increase readability, generally each mask corresponding to·a fl
is given a name using #define. Let us take an example and understand how this is done. We'll decl
a variable of unsigned integer type, and then we'll use the individual bits to represent different flag
associated with the attributes of a file. The variable is declared as-
unsigned int flags;
Now we'll use 10 bits of this variable to represent 10 different
fl~s.
i
Terminal
Incoming
EOF
line
Write
Outgoing
Binary
Error
Mallocd
Read
To increase readability, we'll give a name to each mask corresponding to these bits.
#define
F RDWR Ox0003
#define
FREAD OxOOOI
#define
F WRIT Ox0002
#define
F BUF Ox0004
#define
F LBUF Ox0008
#define
F ERR OxOO10
#define
F EOF Ox0020
#define
F BIN Ox0040
#defihe
F IN Ox0080
#define
F OUT OxOl00
#define
F TERM Ox0200
/* Read/write flag
/* Read only file
/* Write only file
/* Malloc'ed Buffer data
/* line-buffered file
/* Error indicator
/* EOF indicator
/* Binary file indicator
/* Data is incoming
/* Data is outgoing
/* File is a terminal
Oth and }5t bit */
Oth bit */
}'I bit */
2nd bit */
3rd bit*/
4th bit*/
5th bit*/
6th bit*/
7th bit*/
8th bit*/
9th bit */

rations on Bits
- w we can perform masking operations to manipulate the different flags like this-
_0
switch
on
error
flag* I
=:ags=flagsl_F_ERR;
o
switch
off
write
flag* I
=:ags=flags&-_F_WRIT;
"':'0
toggle
incoming
flag*/
=:ags=flagsA_F_IN;
_0
test
EOF
flag* I
_=(flags&_F_EOF)==O)
printf("EOF
flag
is
not
set
");
printf ("EOF
flag
is
set
");
425
we'll take another example in which a variable named permissions will contain information about
~ different access permissions given to different
~lass of users. There are three types of users viz.
er, group, others, and there are four types of permissions that can be· given to these users viz.
write, append, execute.,
Others
Group
Owner
r.----'A'---......"
r.----'A'---....."
r.----'A-----."
15
14
13
12
11
10
9
8
7
6
5
4
3
2
o
E
A
W
R
E
A
W
R
E
A
W
R
= masks corresponding to these bits can be named as:
#define R OWNER OxOOOl
/* Oth bit */
#define W OWNER Ox0002
/* 1't bit */
#define A OWNER Ox0004
/* 2nd bit */
#define E_OWNER Ox0008
/* 3rd bit*/
#define R GROUP OxOOlO
/* 4th bit*/
#define W GROUP Ox0020
/* 5th bit*/
#define A GROUP Ox0040
/* 6th bit*/
#define E GROUP IN Ox0080
/* 7th bit*/
#define R OTHERS Ox0100
/* 8th bit*/
#define W OTHERS Ox0200
/* 9th bit */
#define A OTHERS Ox0400
/* 10th bit*/
#define E OTHERS Ox0800
/* 1ph bit */
unsigned int permission;
permission = Ox 19F;

426
C in Depth
If the size of a bit field is n, then the range of values that the bit field can take is fr0111 0 .
13.10 Bit Fields
unsigned
a:2;
unsigned
b:5;
unsigned
c:l;
uns{gned
d: 3;
/*Invalid*/
Bit field
Size in bits
Range of values
a
2
o to 22-1( 0 to 3)
b
5
o to 25-1 (0 to 31)
c
1
o to 2'-1 ( 0 and 1)
d
3
o to 23-1 (0 to 7)
scanf("%d", &var.a);
} ;
Here the structure has four bit fields a, b, c and d. The sizes of a, b, c and dare 2, 5, 1 and:
respectively; The bit fields can be accessed .like other members of the structure using the dot ope
Whenever they appear inside expressions, they are treated like integers(of smaller range). The
some vaiid expressions using bit fields.
struct
tag
var;
var.a=2;
printfl"%dn,var.bl;
x=var.a+var.b;
"
iflvar.c==11
printf I "Flag
is
on\nn I;
It would be invalid to assign any value to a bitfield outside its range, for example-
var.b = 54;
/*Invalid*/
We can't apply sizeof and address operators to bit fields. So we can't use scanf to input
in a bit field.
We have seen how to access and manipulate individual bits or group of bits using bitwise operat(
Bit fields provide an alternative method of accessing bits. A bit field is a collection of adjacent bi~
is defined inside a structure but is different from other members because its size is specified in tel
of bits. The data type of. a bit field can be int, signed int or unsigned int.
Let us take an example that shows the syntax of defining bit fields.
struct
tag
{
After this statement owners will get all pennissions, group will get read and execute pennission, an
others will get only read permission.
To grant execute permission to others we can write-
pennission = permission IE_OTHERS;
/*Switch on 11th bit*/
To take away read permission from group we can write-
pennission = pennission & ~R_GROUP;
/*Switch off 4th bit*/

erations on Bits
427
'" may input the value into a temporary variable and then assign it to the bit field.
scanf("%d", &temp);
var.a = temp;
•we have pointer to structure then arrow operator(-» can be used to access the bit fields. Code using
e1ds is easier to understand than the equivalent masking operations, but bitfields are considered non-
ble as most of the issues related with them are implementation dependent.
-e had mentioned that the data type of bit nelds can be int, signed int or unsigned int. A plain int field
y be treated as signed by some compilers while as unsigned by others. So for portability, it is better
clearly specify signed or unsigned in the declaration of bit fields. If a bitfield is defined as signed,
en it should be at least 2 bits long because one bit is used for sign.
e direction of allocation of bit fields within an integer is also implementation dependent. Some C
pilers allocate the bit fields from right to left, while others may allocate them from left to right.
• the bit fields are assigned from right to lert, then the first field occupies the least significant bit. If
e bit fields are assigned from left to right, then the first field occupies the most significant bit.
15-14
13
12
11
10
9
8
7
6
5
4
3
2
0
Four bit fields assigned from right to left
15
14
13
12
11
10
9
8
7
6
5
4
32
0
I Four bit fields assigned from left to right
_ e other implementation dependent issue about bit fields is that whether they can croSs integer boun<!aries
_ not. For example consider this structure-
struct
tag{
unsigned
a: 5;
unsigned
b: 2;
unsigned
c: 12;
} ;
_ e first two fields occupy only 7 bits in a 16 bit integer, ~o 9 bits can still be used for another bit
-eld. But the bits needed for next bit field is more than 9. Some implementations may start the next
-eld(c) from a new it:lteger, while others may just place the next field in 12 adjacent bits i.e. 9 unused
- m the previous integer and 3 bits from the next integer.
15 14
13
12
I I 10
9
8
7
6
5
4
3
2
1
0
15
14
13 12
II
10
9
8 7
6
5
4
3
2
1
0
Bit fields cross integer boundary

428
C in Depth
15
14
13
12 II
10
9
8
7
6
5
4
3
2
1
0
15
14
13
12
11 10
9
8 7
6
5
4
3
2
1
0
Bit fields do not cross integer boundary
We can define unnamed bitfields for controlling the alignment of bitfields within an integer. The s'
of unnamed bitfield provides padding within the integer.
struct
tag{
unsigned
unsigned
unsigned
unsigned
a: 5;
b: 2;
: 9;
/ *
c:
12;
padding
within
first
integer' * /
} ;
Here the unnamed bitfield !ills out the 9 unused' bits of first integer, so the bitfieldc starts with
second integer. Since these 9 bits don't have any name, so they can't be accessed from theprogran
We can also take the size ofthe unnamed bitfield zero, so we have no need to provide the padditJ
and next bitfield will start with second integer.
struct
tag{
} ;
unsigned
a
unsigned
b
unsigned
unsigned
c
5 ;
2- ;
0;
12;
/*this
field
starts
from
next
integer'
Now we'll take the example of file permissions that we had seen earlier using bitwise operators.
struct
permission
{
unsigned
r_owner: 1;
unsigned
w_owner:'l;
unsigned
a_owner: 1;
unsigned
e_owner: 1;
unsigned
r_group:1;
unsigned
w_group: 1;
unsigned
a_group: 1;
unsigned
e_group: 1;
unsigned
r_others: 1;
unsigned
w_others: 1;
unsigned
a_others: 1;
unsigned
e_others: 1;
} ;
struct permissions perm = {I, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, O} ;
After this statement owners will get all permissions, group will get read and' execute permission,
others will get only read permission.
Now we can write statements to grant and take permissions like this-
perm.e_others = 1;
/*grant execute permission to others*/'

erations on Bits
perm.r_group = 0;
\
/*take away read permission from group*/
Exercise
429
me stdio.h is included in all programs.
:) main ( )
{
int
x=5,y=4;
if(xllY)
printf ("x&y
:) main (
{
%d,
x&&y
'%d\n" ,x&y,x&&y);
int
x=5,y=13,z;
z=x"y;
printf(~z=%d\n",z);
:) main (
{
int
x;
x=(OxFF»8)«8;
printf("%x\n",x) ;
-=) main (
{
int
k;
k= ( (3 < < 4 ) " (9 6 >>1) ) ;
printf("%d\n",k) ;
::) main (
{
int
k=OxC9FB;
k&=- (1«5);
printfl"%x\t",k);
kl=(1«2) ;
printf("%x\t",k) ;
k"=(1«14) ;
printf("%x\n",k) ;
int
x=Ox1F;
x«2.;
printf("%x
",x);
x»2;
printf("%x\n",x);
/*1100
1001
1111
1011 * /

430
(7) main (
{
C in Depth
unsigned
int
arr_mask[
l={
Ox1,Ox2,Ox4,Ox8,Ox10,Ox20,Ox40,
Ox80,Ox100,Ox200,Ox400,Ox800,
Ox1000,Ox2000,Ox4000,Ox4000}~
int
i /num=Ox3 8F;
for (i=l; i>=O; i- -)
num&arr_mask[il
?
printf("-l."·) :printf("O");
printf ("\n");
}
(8) main(
{
int
num=OxAO 1D, pos'=3, bi t;
int
mask=l«gos;
bit= (num&mask) »pos;
p~intf("%d",bit);
(9) main(
int
i,bit,num=Ox238E;
unsigned
int
mask;
for (i=15; i>=O; i- -)
{
mask=l«i;
bit=(num&mask»>i;
printf("%d",bit) ;
(lO)main(
{
int
num=Ox1F, p-os=3, bi t;
bit=(num»pos)&l;
printf("%d\n",bit) ;
(11 )main (
{
int
i, num=OxAODF
for(i=15;i>=O;i- -)
printf ("%d" , (num»i) &1) ;_
(12)main(
{
int
i,num=Ox1A3B;
unsigned
int
mask;

Operations 011 Bits
rnask=1«15;
for(i=15;i>=O;i- -)
{
(nurn&rnask)
?
printf("l") :printf("O");
rnask=rnask»l;
Answers
431
(1)
x&y = 1, x&&y = 1
(2)
z = 8
(3)
0
(4)
0
3«4 evaluates to 48, 96»1 also evaluates to 48, and 481\48 evaluates to O.
(5)
c9db
c9df
89df
1«5 is
0000000000100000
-(1«5) is
1111111111011111
1«2 is
0000000000000100
1«14 is
0100000000000000
(6) If If
There will be no change, if the statement is written as x = x«2; , then the value of x will change.
(7)
0000001110001111
Prints the binary pattern of an integer, we have taken the masks in an array.
(8)
1
Extracts the bit at position pos
Bit pattern of num is
10100000 0001 1101
Bit pattern of lis
0000 0000 0000 0001
Bit pattern of mask = 1«3 is
0000 0000 0000 1000
Bit pattern of num & mask is
0000 0000 0000 1000
Bit pattern of (num&mask»>3
0000 0000 0000 0001
In this way we can extract a bit at position pos.
(9)
0010001110001110
Prints the binary pattern of an integer, the logic of extracting a bit is same as used in previous
question..
(10) 1
Extracts the bit at position pos
Bit pattern of num
0000 0000 0001 1111
Bit pattern of num»3
0000 0000 0000 0011
(Now the bit that was at position 3 has come to the ~ightmost position)
Bit pattern of 1
0000 0000 0000 0001
Bit pattern of (num»3)&10000 0000 0000 0001
/
(11) 1010 000011011111
i
Prints the binary pattern of an integer, the logic of extracting a bit is same as used in previous
question.

432
C in Depi
(12) 0001101000111011
Prints the binary pattern of an integer
Initially the mask is 1«15
1000 0000 0000 0000
mask = mask»l
0100 0000 0000 0000
mask = mask» 1
0010 0000 0000 0000
So we can see that in each iteration the mask changes, and hence we can extract all the bil
~ ..

Chapter 14
Miscellaneous. Features In C
Enumeration
::s speak more than numbers and this is the reason for the inclusion of enumerated data types in
etimes the replacement of integer constants like I, 2 3 by some meaningful and descriptive names,
ces the readability of the code and makes it self documenting. For example suppose we are making
'" related program, then it would be better if we could use names like Jan, Feb, Mar, Apr instead
e numbers 1, 2, 3, 4.
umeration type is a' user defined data type, which can take values only from a user defined list
ed integer constants called enumerators. The syntax of defining an enumeration data type is same
t of structure or union. The general format of definition is- .
enum
tag{
memberl;
member2;
} ;
enum is a keyword, tag is an identifier that specifies the name of the new enumeration' type being
- ed, and memberl, member2 are identifiers which represent integer constants and are called
rator constants or enumerators. The list of these enumerators is called enumerator list. Note that
structure and union, here the members inside the braces are not variables, they are named integer
I..-~.nts.
the definition, we can declare variables 'of this new data type as-
enum tag varl, var2, var3;
arl, var2, var3 are variables of type enum tag. These variables- can take values only from the
rator list.
Tariables can also be declared with the definition as-
enum
tag
{
memberl;
member2 ;
}varl,
var2,
var3;
me tag is optional. Let us take an example-
;mum month{ Jan, Feb, Mar, Apr, May, lun };

434
Here anew data type month is defined and the enumerator list contains six enumerators.
Internally the compiler treats these enumerators as integer constants. These are automatically assi~
integer vaJues beginning from 0, 1,2... etc till the last member of the enumeration. In the above exa
these enumerators will take following values-
Jan
°
.Feb
1
Mar
2
Apr
3
May
4
Jun
5
These are the default values assigned to the· enumerators. It is also possible to explicitly assign
value to enumerators but in this case, the successive unassigned enumerators will take values one gr
than the value of the previous enumerator. For example-
enum month{ Jan, Feb = 4, Mar, Apr, May = 11, Jun };
Now the enumerators will take following values-
. Jan
°
Feb
4
Mar
5
Apr
6
May
11
Jun
12
We can assign any signed integer value to enumerators, provided the value is within the range 0=
It is also possible to assign same value to more than one enumerator.
enum month{ Jan, January = 0, Feb = 1, February = 1, Mar = 2, March = 2};
"
The enumerated variables can be processed like other integer variables. We can assign values to -
from the enumerator list or they can be compared to other variables and values of the same type.
example-
enum month{ Jan, Feb, Mar, Apr, May, Jun }ml, m2;
ml= Mar;
m2 = May;
Nowml has integer valu~ 2 and m2 will take the value 4.
Any variable of type enum month can take values only from the 6 enumerators specified in th"
For example this is invalid-
ml = Dec;
/*Invalid*/
Some other examples of enum data type definitions are-
enutn suit{ Spades, Hearts, Clubs, Diamonds};
enum position { Ace = I, King, Queen, Jack, Ten, Nine, Eight, Seven, Six, Five, Three, -=-
enum month{ Jan, Feb, Mar, Apr" May, Jun, Jul, Aug, Sep, Oct, Nov, Dec};
enum day{ Sunday, Monday, Tuesday, Wednesd~y, Thursday, Friday, Saturday};
enum color{ white, black, red, green, blue, yellow, pink, brown};

laneous Features in C
enum boolean{ true , false};
enum switch{ off, on};
enum subject{ Hindi, English, Maths, Physics, Chemistry, Biology, History };
enum base { Binary = 2, Octal = 8, Decimal = lO, Hexadecimal = 16};
are some examples of code using these enum definitions-
enum
color
walls,
floor;
if (walls==pin~)
floor=blue;
else
floor=white;
enum
day
today;
today=Monday;
if (today==Sunday)
printf("Holiday\n");
else
if (today==Saturday)
printf ("Half
working' day\n");
else
printf ("Full
working
Day\n");
enum
subj ect
s;
irit
passmarks;'
switch(s)
{
case
hindi:
case
english:
passmarks=25;
break;
case
maths:
passma'rks=40;
break;
case
physics:
case
chemisty:
passmarks=35.;
break;
default:
passmarks=33;
435
Suppose we need a function that returns number of days in a month. It can be written as- _
enum
month
m;
in)::
days;
if (
m==Apr
I I
m==Jun
I I
m==Sep
I I
m==Nov
days=30;
if ( m==Jan
Ilm==Mar II
m==May II
m==Jul II
m==Aug II
m==Oct I I m==Dec)
days=31;
if(
m==Feb
d,ays=28

436
C in De
/ *
P14.l
Program
to
print
the
value
of
enum
variables* /
#include<std~o.h>
mainC
)
{
enum
month{Jan,Feb,Mar,Apr,May,Jun}ml,m2i
ml=Mar;
printf("ml
=
%d
\n",ml);
printf ("Enter
value
for. m2
") ;
scanf ("%d" ,&m2) ;
printf('~m2
%d
\n",m2);
}
·Output :
ml
= 2
Enter the value for m2 : 5
m2 = 5
It is not possible to perform .input and output in terms of enumerator names. The input and outp
only in the form of their integer values. You may be tempted to use %s to output and input enum
variables but this is invalid since enumerators are not strings.
printf("%s", ml); /*Invalid*/
Since enumerators are identifiers so their·name should be different from other identifiers in the
scope. The following code is wrong because the identifier chemistry has been used at two diffi
places.
enum group I { physics, chemistry, maths};
. enum group2{ zoology, botany, chemistry}; /*Invalid*/
float maths; /* Invalid*/
We can use typedef in the definition of enum, for example:-
typedef enum{false, true} boolean;
Now we can define variables like this-
boolean flag = true;
We have seen earlier that we can define constants using #define also, for exampk-
#define Sun 0
#define Mon 1
#define Tue 2
#define Wed 3
Now we'll compare the constants defined by #define preprocessor directive and enum.
(i)
By defining an enum, we define a new type whose variables can be declared but using
. we can only give name to some constant values.
(ii)
enurn is a part of C language(32 keywords) but #define is not.
(iii)
All #define directives are global, while enum obeys the scope rules.
(iv) In #define we have to explicitly assign the values to all constants, while in enum the val
assigned by the compiler automatically.
We can always write our programs by using integer variables instead of enumerated variables,
of enum in complicated programs. makes the program more understandable.

iscellaneous Features in C
437
14.2
Storage. Classes
addition to data type, each variable has 'one more attribute known as storage class. The proper use
of storage classes makes our program efficient and fast. In larger multifile programs the know:ledge
of storage classes is indispensable. We can specify a storage class wh·le declaring a variab.le. The gcit~ral
.
\
~tax 1S-
.
storage_class datatype variable_name;
There are four types of storage classes-
Automatic
External
Static
-,.
Register
The keywords auto, static, register, extern are used for these storage classes. So we may write
eclaration statements like this-
auto int x, y;
static float d;
register int z;
en the storage class specifier is not. present in the declaration, compiler assumes a default storage
lass based on the place of declaration.
storage class decides about these four aspects of a variable-'
)
Lifetime - Time between the creation and destruction of a variable.
)
Scope - Locations where the variable is available for use.
)
Initial value - Default value taken by an uninitialized variable.
)
Place of storage - Place in memory where the storage is allocated for the variable.
_~ow we'll discuss all these storage classes one by one in detail.
4.2.1
Automatic
the variables declared inside a. block/function without arty storage class specifier are called automatic
·ables. We may also use the keyword auto to declare automati'c variables, although this is generally
t done. The following two declaration statements are equivalent and both declare a and b to be automatic
'abies of type into
=:mc ( )
int
a,b;
- nc (
\auto
int
a,b;
e uninitialized automatic variables initially contain garbage value. The scope of these variables is inside
function or block in which they are declared and they can't be used in an~ other function/block.

438
C in- Depth
They are named automatic since storage for them is reserved automatically each time when the control
enters the function/block and are released automatically when the function/block terminates. For example-
/ *P14. 2
Program
to
understand
automatic
variables * /
#include<stdio.h>
main( )
{
func ( ) ;
func ( ) ;
func ( ) ;
}
func ( )
{
int, x=2,y=5;
printf("x=%d,y=%d",x,y) ;
x++;
y++;
}
Output:
x = 2, y = 5
x = 2, Y = 5
x = 2, y = 5
Here when the function func( ) is called first time, the variables x and yare created and initialized
and when the control returns to main( ), these variables are destroyed. When the function func( ) is
c.alled for the second time, again these variables are created and initialized, and are destroyed after
execution of the function. So automatic variables come into existence each time the function is executed
and are' destroyed when the function terminates.
Since automatic variables are known inside a function or block only, so we can have variables of same
name in different functions or blocks without any conflict. For example in the following program the
variable x is used in different blocks (here blocks consist of function body) without any conflict.
/ *P14. 3
Program
to
understand
automatic
variables* /
#include<stdio.h>
main ( )
{
int
x=5;
printf ("x
tunc ( ) ;
}
tunc ( )
{
int
x=15;
printf ("x
%d\t" ,x);
%d\n",x);
}
Output:
x = 5
x = 15
Here the variable x declared inside main( ) IS different from the variable x declared inside the functiOl
func( ).

439
cellaneous Features in C
the next program, there are different blocks inside maine ), and the variable x declared in different
ks is different.
P14.4
Program
to
understand
automatic
variables * I
:~clude<stdio.h>
:in ( )
int
x=3;
printf("%d\t",x) ;
{
int. x=10;
printf("%d\t",x);
int
x=26;
printf("%d\t" ,x);
}
printf("%d\n",x);
3
10
26
External
tput:
3
e variables that have to be used by many functions and different files can be declared as external
.abIes. The initial value of an uninitialized external variable is zero.
fore studying external variables, let us first understand the difference between their definition and
-
laration. The declaration of an external variable declares the type and name of the variable, while
definition reserves storage for the variable as well as behaves as a declaration. The keyword extern
- specified in declaration but not in definition. For example the definition of an external variable salary
. 1 be written as-
"
float salary;
declaration will be written as-·
extern float salary;
e following points will clarify the concept of definition and declaration of an external variable.
finition of an external variable-
)
Definition creates the variable, so memory is allocated at the time of definition.
)
There can be only one definition.
)
The variable can be initialized with the definition and initializer should be con$tant.
)
The keyword extern is not specified in the definition. Some compilersmay allow the use of extern
but it is better to omit this. keyword in the definition.
)
The definition can be written only outside functions.
:Jeclaration of an external variable-
)
The declaration does not create the variable, it only refers to a variable that has already been created
somewhere, so memory is not allocated at the time of declaration.

440
C in Depth
. (b)
There can be many declarations.
(c)
The variable cannot be initialized at the time of declaration.
(d)
The keyword extern is always specified in the declaration.
(e)
The declaration can be placed inside functions also.
Consider this program:
#include<stdio.h>
int
x=8;
main ( )
{
}
funcl ( )
{
}
func2 ( )
{
In this program the variable x will be available to all the functions, since an external variable is actiy
from the point of its definition till the end of a program. Now if we change the place of defmition 0-
variable x like this-
#include<stdio.h>
main( )
{
)
funcl( )
{
int
x=8;
func2 ( )
{
Now x is defined after maine ) and funcl( ), so it can't be used by these functions, it is available 0
•
to function func2( ). Suppose we want to use this variable in function maine ) then we can place
declaration in this function like this-
#include<stdio.h>
main( )
ext:ern
int
x;
)
funcl( )
{

Miscellane.ous Features in C
int
X=8i
func2(
{
441
Now x will be available to functions func2( ) and maine ).
Till now we had written our program in a single file. When the progra~ is large it is written in different
files and these files are compiled separately and linked together afterwards to form an executable program.
Now we'll consider a multifile program which is written in three files viz. first.c, second.c and third.c.
fust.e
seeond.e
third.e
int x = 8;
func2( )
func4( )
maine )
{
{
{
.............
.............
}
}
}
func3( )
func5( )
funcl( )
{
{
{
.............
.........
.............
}
}
}
Here in the file first.c, an external variable x is defined and initialized. This variable can be used both
in maine ) and funcl ( ) but it is not accessible to other files. Suppose file second.c wants to access
this variable then we can put the declaration in this file as-
fust.e
seeond.e .
third.c
..
int x = 8;
extern int x;
func4( )
maine )
. func2( )
{
{
{
.............
.............
}
}
}
func5( )
funclO
func3( )
{
{
{
............
..............
.............
}
}
}
'ow this variable can be accessed and modified in files first.c and second.c and any changes made
to it will be visible in both files. If this variable is needed by only one function in the file second.c,
then the extern declaration can be put inside that function.
So the declaration of an external variable using extern keyword is used to extend the scope of that
variable.

442
C in Depth
./
Suppose our program consists of many files and in file first.c, we have defined many variables that
may be heeded by other files also. We can put an extern declaration for each variable in every file that
needs it. Another better and practical approach is to collect all extern declarations in a header file and
include that header file in the files, which require access to those variables.
14.2.3
Static
There are two types. of static variables-
. (l)
Local static variables
(2)
Global static variables
14.2.3.1 Local Static Variables
The scope of a local static variable is same as that of an automatic variable i.e. it can be used only
inside the function or block in which it is defined. The lifetime of a static variable is more than that
.of an automatic variable. A static variable is created at the compilation time and it remains alive till the
.end of a program. It is not created and destroyed each time the control enters a functionlblock. Hence
a static variable is created only once and its value is retained between function calls. If it has been
initialized, then the initialization value is placed in it only once at the time of creation. It is not initialized
each time the function is called.
A static variable can be initialized only by constants or constant expressions. Unlike automatic variables,
we can't use the values of previously initialized variables to initialize static variables. If a static variable
is not explicitly initialized then by default it takes initial value zero.
int x = 8;
int y = x;
/*Valid*/
static int z = x;
/*Invalid, initializer should be constant*/
Let us take a program to understand the use of local static variables. This program is similar to P14.2
but here x and yare declared as static variables.
/ *P14. 5
Program
to
understand
the
use
of
local
static
variable&* /
#include<stdio.h>
main( )
{
func ( ) ;
func ( ) ;
func ( ) ;
}
func ( )
{
static
int
x=2, y=5;
printf("x=%d,y=%d\n",x,y) ;
x++;
y++;
}
Output:
x· = 2, Y = 5
x = 3, y = 6
x = 4, Y = 7
Note that the effect of initialization is seen only in the first call. In subsequent calls initialization is no

Miscellaneous Features in C
443
performed and variables x and y contain values left by the previous function call. The next program
also illustrates the use of local static variables.
.
.
/ *P14. 6
.Program
to
understand
the
use
of
local
sta·tic
variable
* /
#include<stdio.h>
main( )
{
int
n,i;
printf {"Enter
a
number
:");
scanf ("%d" ,&n) ;
for(i=l;i<=lO;i++)
func(n);
printf("\n") ;
}
func (int
n)
{
static
int
step;
/*
Automatically
initialized
to
0
* /
step=step+n;
printf("%d\t",step);
}
Output:
Enter the number : 4
4
8
12
16
20
24
28
32
36
40
The next program uses a recursive function to find out the sum of digits of a number. The variable
sum taken inside function sumd( ) should be taken as static.
I
/*P14.7
Program
to
find
out
the
sum
of
digits
of
a
number
#include<stdio.h>
int . sumd (int
num);
main( )
{
int
num;
printf ("Enter
a
number
") ;
scanf("%d",&num) ;
printf ("Sum
of
digits
of
%d
is
%d\n", num, sumd (num) ) ;
int
sumd (int
num)
static
int
sum=O;
if (num>O)
{
sum=sum+{num%lO) ;
sumd(num/lO) ;
return
sum;
recursively*/
)
14.2.3.2 Global Static Variables
If a local variable is declared as static then it remains alive throughout the program. In the case of

~----------
444
C in Depth
global variables~ the static specifier is not used to extendthe lifetime since global variables have already
a lifetime equal to the life of program. Here the static specifier is used for information hiding. If an
external variable is defined as static, then it can't be used by other files of the program. So w'e can.
make an external variable private to a file by making it static.
first.c
second.c
third.c
int x = 8;
extern int x;
func4( )
static irit y =10;
func2( )
{
maine )
{
.............
{
.............
}
}"
func5( )
}
func3( )
{
funclO
{
.............
{
.............
}
.............
}
}
Here the variable y is defined as a static external variable, so it can be used only in the file first.c. We
can't use it in other files by putting extern declaration for it.
14.2.4
Register
Register storage class can be applied only to local variables. The scope, lifetime and initial value ofregister
variables are same as that of automatic variables. The only difference between the two is in the place
where they are stored. Automatic variables are stored in memory while register variables are stored in
CPU registers. Registers are small storage units present in the processor. The variables stored in registers
can be accessed much faster than the variables stored in memory. So the variables that are frequentl
used can be assigned'register storage class for faster processing. For example the variables used as
loop counters may be declared· as register variables since they are frequently used.
/ *P14. 8
Program
to
understand
the
use
of
register
variable*!
#include<stdio.h>
main(
{,
register· int
i;
for(i=O;i<20000;i++)
printf("%d\n".i);
Register variables don't have memory addresses so we can't apply address operator(&) to them. Then
are limited number of registers in the processor hence we can declare only few variables as registeJ
If many variables are declared as register and the CPU registers are not available then compiler wi!
treat them as automatic variables.·
\
The CPU registers are generally of 16 bits, so we can specify register storage class only for int, cha
or pointer types. If a variable other than these types is declared as register variable then compiler treat
it as an automatic variable.
The register storage class specifier can be applied to formal arguments of a function while the otht
three storage class specifiers can't be used in this way.

iscellaneous Features in C
4.3
Storage Classes in Functions
445
-:be storage class specifiers extern and static can be used with function definitions. The definition
f a function without any storage specifier is equivalent to its definition with the keyword extern i.e.
default the definition of a function is considered external. If a function is external then it can be
ed by all the files of the program and if it is static then it can be used only in the file where it is
- fined.
~ an external function is to be used in another file, then that file should contain function declaration
d it is a good practice to specify extern in that declaration.
first.c
main( )
{
}
float func1(int)
{
}
second.c
extern float func1(int );
func2( )
{
}
static int func3(int )
{
}
third.c
void func4( )
{
}
void func5( )
{
}
-ere the function func1( ) is defined in file first.c. Its declaration is put in file second.c, so it can be
ed in this file also. The function func3( ) in file second.c is defined as static so it can't be used
. any other.file. Generally declarations of all functions are collected in a header file and that header
e is included in other ·files.
4.4
Lirikage
_ ere are three types of linkages in C-
_)
External linkage
)
Internal linkage
)
No linkage
c.al variables have no linkage, so their scope is only within the block where they are declared. Global
'ables ·and functions have external iinkage, so they can be used in any file of the program. Static
_obal variables and static functions have internal linkage, so their scope is only in the file where they
declared.
4.5
Memory During Program Execution
- e register variables are stored in CPU registers and rest of the variables are stored in memory. Now
us see how memory is organized when a C program is run.
de Area: This area is used to store executable code of the program. The size of this area does not
ge during run time.
ta Area: This area stores static and global variables. His further subdivided into two areas viz. initialized
area and uninitialized data area. The initialized data area stores all the initialized static and global

446
-
C in Dep
variables while the uninitialized data area stores all the uninitialized static and global variables. The reasa.:
for division of this area is that all unintialized variables can be collectively assigned value zero. The sil::
of data area is also fixed and does not change during run time.
.-------------,
.
Code
Code ofthe program
1------------1
.
Initialized Data
Initialized static variables
Initialized global variables
I-----------i
.
Uninitialized Data
Uninitialized static variables
Uninitialized global variables
Dynamically allocated memory
Initialized and uninitialized
,automatic variables
1------------1
.
Heap
I
I------+------i
.
..
•
1------4-"'"-----j
.
Stack
'---------~--'
..
Memory during execution of the program
Heap: This area is used for dynamically allocated memory. It is the responsibility of the program::
to allocate memory from the heap. The size ofthis area is dynamic i.e. it may change during run t!;
Stack: Automatic variables are stored in this area. The size of this area keeps on changing during
time.
The following table summarizes all the features of storage classes-
""
l,(eyword
Place of
Lifetime
Scope
Initial
Place of
Linkage
InitiaIt
,
declaration
I
Value
storage
auto
Inside
Function
Function
Garbage
Memory
None
Consta;
(or none)
Function
/Block
/Block
(stack)
VariabI;:
/Block
-
register
Inside
Function
Function
Garbage
Registers
None
Consta:
Function
/Block
/Block
Variab~
/Block
static
Inside
Program
Function
Zero
Memory
None
ConSl
(local)
Function
/ Block
(data are:;!)
/Block
(none)
Outside
Program
Definition to
Zero
Memory
External
COllSl
function
end offile
(data area)
(Definition of
(can be shared
external
in other files
I

Miscellaneous Features in C
447
variable)
using extern
declaration)
extern
Outside' or
Program
Declaration to
-
Memory
External
Can't be
inside fimction
cnd of file
(data area)
initialized
(Declaration
/ Function
of external
variable)
static
Outside
Program
Definition to
Zero
Memory
Internal
Constant
(global)
function
end of file
(data area)
(can't be
"
shared in
other files
using extern
declaration)
14.6
const
If any variable is declared with const qualifier, thenthe value of that variable can't be changed by the
program. The const qualifier can occur in the declaration before or after the data type. For example-
const int x = 9;
int const x = 9;
Both these declarations are equivalent and declare x as a const variable. Any attempt to change the value
of this variable in the program will result in an error. For example these statements are invalid-
x = 10;
/*Invalid*/
x = func( );
/*Invalid*/
x++;
/*Invalid*/
"
The canst qualifier informs the compiler that the variable can be stored in read only memory. A const
variable can be given a value only through initialization or by som~ hardware devices. Note that the
value of a const variable can't be modified by the program, but any external event outside the program
an change its value.
If an array, structure or union is declared as const then each member in it becomes constant. For
example-
const int arr[5] = { 10, 11, 12, 13, 14 };
---
const struct { char x; int y; float z; }var ={ 'A', 12, 29.5 };
arr[2] = 22;
/*Invalid*/
var.x = 'B';
/*Invalid*/
-=-tle const variables are not true compile time constants inC. So we can't use const variables where
~onstant expressions are required e.g. in array dimensions or case labels.
-or example the following code is invalid in C.
const int size=10;
int arr[size];
l
~
~_~_~

448
C in Depth
The const qualifier can be useful while passing array arguments to functions. We know that when an
array is pissed as an argument, the function gets access to the original array and can modify it. If
we don't want the function to make any changes in the array then we can declare the array as con
in the formal parameter list..
func (
canst
char· arr []
{
}
Now we'll see how to use canst in pointer declarations. We can declare three types of pointers using
the qualifier const:
(i)
Pointer to canst data
(ii)
cQnst pointer
(iii)
const pointer to canst data
Consider these declarations-
const int a = 2, b = 6;
canst int *p I = &a;
/* or int canst *pI = &a; */
Here pI is declared as a pointer to constinteger. We can change the pointer pI but we can't chan
the variable pointed to by pl.
*p1 = 9;
/*Invalid*/
pI = &b;
/*Valid since pI is not a constant itself*/
Now consider these declarations-
int a = 2, b = 6;
int' *const p2 = &a;
Here p2 is declared as a canst pointer. We can't change the pointer variable p2, but we can chane _
. the variable po(nted to byp2.·
<,
*p2 = 9;
/*Vali"d*/
p2 = &b;
/*Invalid since p2 is a constant*/
Now consider these declarations-
const int a=2, b=6;
const int const *p3=&a;
Here p3 is declared as a const pointer to const integer. We can neither change the pointer variable
':
nor the variable pointed to by it.
*p3 = 9;
/*Invalid*/
p3 = &b;
/*Invalid*/
So the three different types of declarations of pointers using const are-
int const *ptr;
or
canst int *ptr;
/* pointer to const integer */
int *const ptr;
/* const pointer to an integer */
const int *const ptr;
/* const pointer to a const integer */
The following example will further clarify this concept.
char
strl []
"weal thy" ;

Miscellaneous Features in C
char
str2[]="strong";
const
char
*pc=strl;
char
*const
cp=strl;
const
char*const
cpc=strl;
/ *pointer
to
const * /
/ *const
pointer* /
/ *const
p'ointerto
const * /
449
pc=str2;
cp=str2
cpc=str2;
*pc='h';
*cp='h';
*cpc='h';
/*Valid*/
/*Invalid*/
/*Invalid*/
/*Invalid*/
/*Valid*/
I*Invalid*/
If we want to assigp the address of a canst variable to a non const pointer~len we'll have to use
ast operator. For example-
const int a = 10;
int *ptr;
ptr = (int *)&a;
_ ow if we try to change the value of variable a indirectly through ptr then the result is undefined and
ere can be a run time error.
*ptr = 12;
/* undefined*/
14.7
volatile
l
Ihenever a variable is encountered in the program, compiler reads the value of that variable from the
memory. But sometimes for optimization purposes the compiler stores the value of the currently used
"ariable in any unused register. Now when that variable is encountered next time in the program and
me compiler sees that the program has not changed value of the variable, it reads the value from the
register instead of the memory. This process saves time since accessing a register is faster than accessing
memory.
"
This sort of automatic optimization by the compiler may sometimes lead to incorrect results. This generally
happens when the value of a variable can be modified by some external process outside the program.
These types of situations arise when we have memory mapped I/O, variables shared among multiple
rocesses or variables that can be modified by interrupt routines.
For example suppose we have a variable time that "represents current system time and its value is controlled
. y the system clock. Now consider this loop-
while( time != T )
/* Do nothing till value of variable time equals T*/
The optimizing phase of the compiler may observe that the value of variable time is not changing inside
me loop, so it may decide to access its value once from the memory and then cache this value in a
egister. Now for each iteration of the loop, compiler reads this cached value from the register and.
hence the loop will never terminate, but this is not what we wanted. It is our responsibility to inform
the compiler that the value of a particular variable may change through some external process also.
To solve these types of problems we can use volatile qualifier. If a variable is declared with the qualifier
volatile, then we are instructing the compiler to turn off the optimization process for that variable i.e.
we are forcing the compiler to read the value of that variable from memory only, each time it is

450
C in Depth
encountered in the program. The optimization phase of compiler will never try to cache the value: 0
a volatile variable in a register.
The value of a volatile variable can be changed from inside the program. If we don't want this to happen
we can use the qualifier const along with the qualifier volatile. For example-
const volatile int x;
If an array, structure or union is declared as volatile then each member becomes volatile.
14.8
Functions With Variable Number Of Arguments
In the functions that we had created till now, the number and data type of arguments was fixed
the time of function definition. In some situations we may need functions that can accept variable numb
of arguments of different types. The library functions printf( ) and scanf( ) are example of these t
-
of functions. We have already used these functions many times with different number and type
arguments. We can also creat~ our own functions that can accept variable number of arguments. Th
-
types of functions are also known as variadic functions.
The header file stdarg.h provides the facilities needed to define functions with variable number
arguments. This file defines a new type called va_list and three macros va_start, va_arg, va_end
can operate on variables of this new type.
Type
va_list - Used to declare argument pointer variables.
Macros
Initializes the argument pointer variable.
Retrieves the current argument and increments the argument pointer.
Assigns NULL to argument pointer.
(
.
A function that accepts variable number of arguments should be defined with ellipsis(...) at the
of argument list. The ellipsis should occur only at the end of argument list and there should be at 1
one fixed argument. For example-
func (
char
*str,
in!:
num,
...
)
{
Here func( ) takes two fixed arguments viz. str, num and after that it can accept any numbe
arguments. For example all these calls of func( ) are valid-
func("Chennai", 40, 67.89, 'p', "Madras", 23, 67 );
func("Lucknow", 35, 66 );
func("Bareilly", 30, 'x', 20, 39, 12.5);
In all these calls first two arguments are always a string and an integer, rest of the arguments Cl
of any type. Now inside the function definition we can ~ccess the fixed arguments using their
but the remaining arguments don't have a name so they are accessediusing the macros defined in stc
file. This is why fixed arguments are known as named arguments and variable number of argu
are known as unnamed arguments. Now we'll see how we q.n access these unnamed arguments
the function body.

_fiscellaneous Features in C
451
Initially we'll declare a variable of type va_list.
. va_list ap;
This variable is conventionally named ap. Here ap is known as argument pointer and will. be used to
point to the unnamed arguments. The macro va_start initializes ap and makes it point to the first unnamed
gument passed to the function. This macro takes two arguments, first one is the argument pointer
ap and second one is the name of the last fixed argument passed to the function (i.e. argument which
is just before the ellipsis). For example in the above function func( ), va_start will be called as-
va_start( ap, num);
_ ow we can access individual variable arguments sequentially by using va_argo This macro takes ap
Ed the data type of the current argument.
arg = va_arg( ap, datatype);
It returns the value of the current argument and increments the pointer ap so that it points to the next
argument. After calling va_start, the first call of va_arg returns first unnamed argument, second call
returns second unnamed argument and so on. If datatype of the cunent unnamed argument in the function
all does not match with the datatype in va_arg then the behaviour is undefined.
The macro va_end should be called before exiting from the function. This macro sets the argument
pointer to NULL.
va_end(ap);
The unnamed arguments can't be used after calling va_end. If we want to use those arguments then
once again we'll have to initialize ap with va_start.
The whole procedure is summarized in these steps-
(i)
Include the header file stdarg.h
(ii)
.The fU1!ction header should contain ellipsis to denote the variable argument list.
(iii)
Declare a variable of type va_list.
(iv)
Initialize this argument pointer using va_start, so that it points 'to the first unnamed argum~nt.
(v)
Use va_arg to retrieve the value of arguments.
vi)
Call the macro va_end when you have finished working with these arguments,
There is no facility to count how many arguments were passed in the function call and what was the
lype of each argument. It is programmer's responsibility to pass this information to the function through
fixed arguments. For example we may decide to take the first fixed argument as an integer that represents
the total number of unnamed arguments. Generally a fonnat string is passed as a fixed argument, which
ontains infonnation about the type ofeach argument. For example printf( ) uses the format string that
ontains conversion specifications which denote the data type of each unnamed argument.·
. ow we'll take an example program and apply all these concepts. In this program we will make a function
um( ) which returns the sum of integers passed to it.
/*P14.9
program
to
find
out
the
sum
of
integers
* /
-include<stdio.h>
=include<stdarg.h>
':'nt
sum(int
; .. );
ain( )
{
printf ("Total
%d\n", sum(2, 99, 68));

452
printf ("Tot,~l
printf ("Total
%d\n",sum(3,11,79,32)) ;
%d\n",sum(5,23,34,45,56,78)) ;
.
C in.Depth
}
int
sum (int
num,
... )
{.
int
i;
va...:.list . ap;
int
arg,
total=O;
va_start (ap,num) ;
for(i=O;i<num;i++)
arg=va_arg(ap,int) ;
printf("%d
",arg);
total+=arg;
}
va_end (ap) ;
return. total;
}
Output:
99 68 Total = 167
11 79 32 Total = 122
23 34 45 5678 Total = 236
Here we have called the function sum with different number of arguments. We have taken only 0
fixed argument num that represents the number of unnamed arguments passed to the function. It
used in the loop to step through the unnamed arguments. Inside the function, firstly a variable of va_
type 'is declared. Then va_start is called and num is passed to it since it is the last fixed argume
After-that each variable argument is obtained by calling va_arg repeatedly inside a loop.
In the above program we have taken variable number of arguments but all of them were of the san
type. Now we'll take another program in which the unnamed arguments are of different types. 11
working of this function is somewhat similar to that of printf( ) function. In this function we'll s
only one fixed argument and that will be a format string. Inside the function we'll scan this fom
string to know the data type of the unnamed argument. The text in the format string is printed throul
putchar( ). We have printed character values and string values using putchar( ) and fputs( ) respective
The integer and float values are first converted to strings and then printed using fPuts( ).We have us
i_to_str( ) function that converts an integer to a string and Cto_str( ) function that converts a fl
to a string. The definitions of these functions are given in chapter string ( program P9.31 ). This pri
) function is a bit smarter than printf( ), since it can print the binary equivalent of an integer ali
/*P14.10
Program
that
uses
a
function
similar
to
printf( )*/
#include<s~darg.h>
#include<stdio.h>
void
i_to_str (int
num, char' str [] ,int
b);
void
f_to_str (float
num, char
str [] ) ;
void
print(char
*format,
);
main( )
int
a=125;
float
b=
563.66;

iscellaneous Features in C
char
c=' Q' ;
char
*name="Ranju";
print ("Value
of
a
in
binary
-
%b\n",a) ;
print ("Value
of
a
in
octal
%o\n", a) ;
print ("Value
of
a
in
decimal
=
%d\n", a) ;
print ("Value
of
a
in
hexadecimal
%x\n", a) ;
print ("Value
of
P
=
%f\n" ,b) ;
print ("Value
of
c
%c\n",c);
print ("Value
of
name
%s'\n", name) ;
}
void
print (char
* format,
... )
(
char
*p,*str;
int
k;
float
1;
va_list
ap;
va_start(ap,format);
for(p=format;*p!='\O' ;p++)
(
\
if((*p)=='%')
(
p++;
swi tch (*p)
<"
case
'b':
k=va_arg(ap,int) ;
i_to_str(k,str,2) ;
fputs(str,stdout) ;
break;
case
'd':
k=va_arg(ap,int) ;
i_to_str(k,str,lO) ;
fputs(str,stdout) ;
break;
case
'0':
k=va_arg(ap,int) ;
i_to_str(k,str,8) ;
fputs(str,stdout) ;
break;
case
'x':
k=va_arg~ap,int);
i_to_str(k,str,
6);
fputs(str,stdout)
break;
case
'c':
k=va_arg(ap,int) ;
putchar(k) ;
break;
case's' :
str=va_arg (ap, char
*);
453

;;p
454
C in Depth
fputs(str,stdout) ;
break;
case
"f':
l=va_arg(ap,double) ;
f_to_str(l,str);
fputs(str,stdout) ;
break;
case
%':
putchar('%');
break;
}
else
putchar(*p) ;
Here we have used int in va:",arg to extra-::t a char value and double to extract a float value. This
because in the case of variable number of arguments the default argument promotions are applied i.
arguments of type char and short int are promoted to int and arguments of type float are convert
to double. So use int for extracting a char, short int or int and use double,to extract a float or doub
We have taken the function print to be of void type, if you want you can return the number of charact
output as in printf( ).
The functions i_to_str( ) and Cto_str( ) can't handle negative numbers, so before calling these functio
we'll have to write an additional condition for negative numbers like this-
k = -k; putchar('-'); }
Passing Variable Number of Argume"nts To Another Function
if ( k<O)
{
14.8.1
Suppose we write a function funcl( ) thattakes variable number of arguments and we want to p
all these unnamed arguments to another function func2( ). For this the function func2( ) should
declared such that it can accept a variable of va_list type.
funcl (int
num,
... )
{
va_list
ap;
va_start (ap,num) ;
func2 (num, ap) ;
}
func2 (int
num,va_list
ap)
{
So here inside func2( ) there is no need to declare a variable of va_list type and call to macro va_
is also not needed. The variable ap can be used in the macro va_arg to retrieve the arguments.
in func2( ) we can use the unnamed arguments only once, it is not possible to call va_start again

~iscellaneous Features in C
·455
retraverse the variable argument list. Now we'll take a simple example and see how this .can be done.
In the program P14.9 we had made a function sum( ) that displays the integers and returns their total.
_ ow we'll make a separate function display( ) for displaying the numbers and will send the initialized
argument pointer to this function.
/*P14.11
Program
in
which
the
variable
length
list
is
passed
to
another
function*/
-inc1ude<stdio.h>
=inc1ude<stdarg.h>
. n t
sum ( int
. . . ) ;
oid
display (int, va_list) ;
:nain ( )
{
printf ("Total=
printf("Total
printf ("Total=
%d\n",sum(2,99,68»;
=%d\n",sum(3,11,79,32»
;
%d\n",sum(5,23,34,45,56:'78»
;
l
}
':'nt
sum (int
num,
.. , )
int
i;
va_list
ap;
int
arg, total=O;
va~start(ap,num);
display(num,ap) ;
for(i=O;i<num;i++)
arg=va_arg(ap,int);
tota1+=arg;
}
va_end (ap) ;
return
total;'
}
void
display (int
num, va_list
ap)
{
int
i,arg;
for(i=O;i<num;i++)
arg=va_arg(ap,int) ;
printf("%d
",arg);
The library function vprintf is one such function that accepts a variable of type va_list. It is just like
printffunction except that it takes a variable ofva_list type instead ofvariable argument list. The prototypes
of printf and vprintf are-
int printf ( const char *format [, argument, ...] );
int vprintf ( const cl1ar *format, va_list arglist);
imilarly vfprintf and vsprintf are analogous to fprintf and sprintf, except for this single difference.
int fprintf (FILE *stream, const char *format [, argument, ...J);

456
int vfprjntf(FILE *stream, const char *format, va_list arglist);
int sprintf (char *buffer, const char *format [, argument, ...]);
int vsprintf(char *buffer, const char *format, va_list arglist);
C in Depth
Now we'll write a debugging function error( ) that will display the error message along with file name
function name and line number where the error occurred. This function won't be much useful if it
takes only a fixed number of arguments of specific types because at different times the error message
~ould have to display values of different variables. So we'll define it as a variadic function. The first
four arguments are fixed in which the first three represent filename, function name and line number
respectively. The fourth argument is a format string which represents the error message and is similar
to the fomlat string of printf( ) function. After this we can have variable number of arguments which
will be written along with the error message, according to the conversion specifications(%d, %s etc}
present in the format string. The definition of error( ) function can be written as-
error(char
*file,char
*fname,int
line,char
*format,
... )
va_list
ap;
va_start(~p,format);
printf("ERROR
");
printf("File
%s
printf ("Function
-
%s
printf("Line
%d\n",
vprintf(format,ap) ;
printf ("\n");
Here we have used vprintf to print the error message along with the variable number of arguments_
Now suppose this function is invoked in function myfunc( ) of file myfile.c, at line 44 like this-
myfunc (
)
{
error (__FILE__ , "myfunc" , __LINE__ , "Value
of
a
must
be
less
than
%d
and
greater
than
%d\n",lOO,5);
}
The output will be this-
ERROR: File - c:\dir\myfile.c , Function - myfunc , Line - 44
Value of a must be less than 100 and greater than 5
If we want to send the output to the stream stderr, then we can use fprintf and vfprintf instead of
printf and vprintf in the definition of error function.
.
14.9
Ivalue and rvalue
Sometimes we get compiler errors that use the terms lvalue and rvalue. An expression that can occur
on t~e left hand side of a~signment operator is known as lvalue and an expression that can occur only
on nght 'hand Side of assignment operator is known as rvalue.
Some examples of rvalues are-
5

J1iscellaneous Features in C
457
x+y*z
monday
&x
arr
(here monday is an enum constant)
(here x is an integer variable)
(here arr is the name of an array)
The value of these expressions can be used in the program, but they can't be modified, we can't write
them on the left side of assignment operator. We will get error'lvalue required' if we try to write
statements like this-
5 = x;
x+y*z = 12;
&x = p;
arr= ptr;
orne examples of lvalues are-
var
(var is an integer variable)
ptr
(ptr is a p·ointer)
*ptr
(ptr is a pointer variable)
emp
(emp is a structure variable)
emp->salary
(here emp is a structure variable and salary is its member)
arr[2]
(arr is a l-d array)
All these expressions can occur both on the left side and right side of assignment operator i.e. we can
use their values in the program and their value can be modified,
.
14.10
Compilation And Execution of C Programs
There are different phases through which our program passes before being transformed into an executable
form. The following figure shows these phases-
14.10.1 Preprocessor
The source code is the code that we write using any text editor and the source code file is given an
extension '.c'. This source code is firstly passed through the preprocessor: The preprocessor expands
this code and passes it. to the compiler. We have discussed the role of preprocessor in chapter 12.
14.10.2 Compiler
The expanded code is passed to the compiler. The compiler converts this code into the machine's assembly
language code.
14.10.3 Assembler
This assembly language is converted to object code by the system's assembler. The name of object
file is same as that of source file. In DOS the object file has extension '.obj' and in UNIX the extension
is '.0'.
14.10.4 Linker
Generally all programs written in C, use library functions. Library functions are precompiled and their
object code is stored in library files with' .lib'(or '.a') extension. The linker combines this object code
of the library functions with the object code of our program. Our program may also contain references
-------------------'---~-------'j

458
Compiler
I
assembly code
..
Assembler
I
Other object -
ObjeC~ code
Libraries
files CLter~
executable code
C in Depth
to functions that are defined in other files. The linker links the object code of these files also to our
program. So the job of the linker is to combine the object code of our program with the object code
of other files and object code of library functions. The output of the linker is an executable file. In
DOS the executable file has same name as that of source code file and has extension '.exe', and in
UNIX the executable file is named as a.out or the name of output with -0 option.
Exercise
Assume stdio.h is included in all programs.
(1) enum
month{jan, feb,rnar,apr,may};
main( )
{
enum
month
m;
m=++feb;
printf ("%d\n",
m);
(2) enum
day{ sun=l, mon, tue, wed} ;
main( )
{
enum
day
d1;
printf("%d\t",mon) ;
d1=mon+2;
printf("%d\n",d1) ;
(3) struct
tag{

Miscellaneous Features in C
459
auto
int
x;
static
int
y;
} ;
main ( )
{
struct
tag
s;
s.x=4;
s.y=5;
(4) int
var=6;
main( )
{
int
var=18;
printf("%d",var) ;
(5) main (
int
i, sum=O;
for(i=O;i>5;i++)
{
int
i=lO;
sum=sum+i++;
}
printf (" sum
=
%d", sum) ;
(6)
main~ )
int
i, sum=O;
for(i=O;i>5;i++)
{
static
int
i=lO;
sum=sum+i++;
}
printf (" sum
=
%d", sum) ;
(7) int
x=89;
main( )
{
funcl (x) ;
printf("%d\t",x) ;
func2 ( ) ;
printf("%d\n",x) ;
}
funcl (int
x)
{
x++;
func2 ( )
{
x++;

---------
460
(8) int
x=2;
static
int
y=5;
main ( )
{
C in Depth
int
x=3;
func ( ) ;
func ( ) ;
print f (" Inside
main ( )
}
func ( )
{
static
int
X;
x=x+2;
printf("Inside
func()
(9 ) main(
funcl(
) ;
func2(
) ;
}
funcl(
{
extern
int
x·,
X++;
printf("%d\t",x);
}
int. x=89;
func2 ( )
{
x++;
pri~tf("%d\n",x);
(lO)main(
{
const
int
*ptr=func ( ) ;
*ptr
7;
printf("*Ptr=%d",*Ptr);
}
func ( )
{
x=%d,y=%d\n",x,y);
x=%d,y=%d\n",x,y) ;
int
*p=malloc(l*sizeof(int»;
return
p;
(ll)main(
{
char
char
char
strl [
] = "hockey" ;
str2 [
. ] = "Cricket" ;
const
*p=strl;

j,fiscellaneous Features in C
*p=\j' ;
p=str2;
(12 )main (
{
461
char
char
char
str1[
str2[
*const
] ="hockey";
] ="Cricket";
p=str1;
*p=' j' ;
p=str2;
(13 )main (
{
int
a[
]={l,2,3,4};
int
b[
]={5,6,7,8};
int
c[
]={9,10,1l,12};
func(a,b,c) ;
}
func(int 'a[
J,const
int
b[
J,int
c[
])
{
a=c ;'
a[O]++;
b=c;
b[O]++;
(14) main.(
{
const
int
i=23;
const
int
j =thrice (i) ;
printf("j=%d\n",j) ;
}
thrice(int
if
{
return
3*i;
(15)main(
{
int
i=3;
const
int
j =i;
const
int
k=func ( ) ;
int
*ptr=&k;
const
int
m=*ptr;
printf("%d\t%d\t%d\t%d\n",
i,
j,
k,
m);
}
func ( )
{
return
4;

462
(16)int
*func();
main( )
{
int
i,
size;
const
int
*arr=func (&size) ;
for(i=O;i<size;i++)
printf ("Enter
a [%d)
scanf("%d",
&arr[i]);
}
for(i=O;i<size;i++)
printf("%d\t",
arr[i);
}
int
*tunc(int
*psize)
int
*p;
printf ("Enter
size
") ;
scanf ("%d",
psize
);
p=malloc(*psize*sizeof(int»;
return
p;
(17)#include<stdarg.h>
void
func(int
n, ... );
main (
)
{
int
count=4;
func(count,2,3,4,5) ;
}
void
func (int
n, ... )
va_list
ap;
int
a,i;
for(i=O;i<n;i++)
{
a=va_arg(ap,int);
printf("%d
",a);
(18)#include<stdarg.h>
main ( )
int
a=2, b=3, c=4, d=5;
func (4,2, 3, 8, 5) ;
J.' ) •
, ,
C in Depth
}
func(int
a,
{
, int
b)
va_list
*ap;
va_start (ap,
a);
for(i=O;i<b;i++)

Miscellaneous Features.in C
printf("%dU,va_arg(ap,int)) ;
va end:
(19)rnain(
{
int
x=6;
'++X++ ;
printf("%d\nU,x) ;
Answers
(1)
Error: lvalue required
(2)
2
4
(3)
Error: storage specifiers can't be used inside definition of structure templates
(4)
18
Whenever there is a conflict between a local and global variable of the same name the local variable
gets the priority.
(5) . sum = 0
(6)
sum = 0
(7)
89
90
(8)
Inside func( ) : x = 2, y = 5
Inside func( ) : x = 4, y = 5
Inside maine ) : x = 3, y = 5
(9)
90
91
(10) Error: can't modify a const object
(11) Error: can't modify a const object
Here p=str2 is valid, but *p='j' is invalid.
"
(12) Error: can't modify a const object
Here p=str2 is invalid,' but *p='j' is valid
(13) Error: can't modify a const object
Both the statements b=c; and b[O]++; are invalid.'
(14) 69
(15) 3
3
4
4
(16) Enter size : 3
Enter a[O] : 5
. Enter a[l] : 6
Enter a[2] : 7
5
6
7
r-
(17) Since ap was not initialized by va_start, so it may be pointing! anywhere in memory and so we'll
get garbage values.
(18) Ellipsis should always be at the end of argument list, and another mistake is that an asterisk in
used while declaring argument pointer
(19) Error: lvalue required

Chapter 15
Building project and creation of library
We have studied about C lap.guage, now we'll come to the real life problems and see how we can solve
them step by step. Here we will use our C program to develop one real life project with whole software
life cycle of project. This will give' you an idea of developing a full project in C. We will develop.this
project in Turbo C as well as in Unix. Also we will see how to develop a library and use the functions
of this library in different programs.
.
The project that we are going to make is related with date. Date related operations are of great importance
in many applications. Most of the application projects require date related manipulations. So our aim
is to develop a project in C, which will perform all date related manipulations. Now we will go step
by step in different phases of software development life cycle for developing this project. These phases
are as-
1.
Requirement analysis
2.
Top level design
3.
Detail design
4.
COGing
5.
Testing
First step is requirement analysis. Here we think about requirement of our project by analyzing different
manipulation of dates. We know very well what are the operations that are needed with date, as well
as different attributes of date. So after analyzing we came up with a document that gives all the
requirement of the project. This is called as SRS(Software Requirement Specification).
1.
Given date is valid or invalid.
2.
Day of week from' a given date.
3.
Comparing two dates.
I
4.
Diffrrence of two dates in days.
5.
Difference of two dates in years, months and days.
6.
Add years to a given date.
7.
Subtract years from a given date.
8.
. Add months to a given date.
9.
Subtract months from a given date.
10.
Add days to a given date.
11.
Subtract days from a given date.
15.1
Requirement Analysis

_ Iding project and creation of library
465
-.2
Top Level Design
w we will go to the second step that is top-level design. Here we will divide the whole project in
erent modules. So whenever any change is needed, it will affect only one particular module and
- others. Now we will write different modules in different files. All the modules will be implemented
different files as-
Datefmt.c
This file will contain modules to convert a date from string form to integer variables and vice versa.
Valid.c
This file will contain module to check whether a given date is valid or not.
Leap .c
This file will contain module to check whether a given year is leap or not.
Julian.c
This file will contain module for getting julian number and also converting julian number to months
and days from a given date.
Weekday.c
This file will contain module for getting day of week for a given date.
Cmpdate.c
This file will contain module for comparing two dates.
Diffymd.c
This file will contain module to find out difference in years, months and days for two dates.
Diffdays.c
This file will contain module to find out difference in days for two dates.
Addyear.c
This file will contain module for adding years to a given date.
Subyear.c
This file will contain module for subtracting years from a given date.
Addmonth.c
This file will contain module for adding months to i given date.
Submonth.c
This file will contain module for subtracting months from a given date.
Adddays.c
This file will contain module for adding days to a given date.
-.
Subdays.c
This file will contain module for subtracting days from a given date.
5.3
Detail Design
w we will go to the next step that is detail design. Here we analyze all modules one by one for detail
ign. We analyze what functions will be required, what would be the input and return value 'of that
ction in each module and come up .with one document for detail design, which contains the information
function prototype for each modlule. Let us see the function required in each module-
te that date will be always in dd/mm/yyyy format.
t

466
C in Dep-
1. Datefmt.c
void splitDate(char *date, int *y, int *m, int *d )
Input:
date
string in dd/mm/yyyy format
y
integer pointer, will get value of year.
m
integer pointer, will get value of month.
d
integer pointer, will get value of day
Return value - None
void formDate(char *date, int y, int m, int d)
Input :
date
pointer to character for getting date in string form
y
Integer that represents the year of given date
m
Integer that represents the month of given date
d
Integer that represents the day of given date
Return value - None
2. Valid.c
Return Value:
y
lilt julian(int d, int m, int y)
Input:
d
m
Not a leap year
Leap year
Date is not valid
Date is valid
day from given date
month from given date
year from given date
integer value containing julian number.
year
o
1
4. Julian.c
3. Leap.c
int isLeap(int year)
Input:·
Return Value:
int isValid(char *date)
Input:
date
Return Value
0
I
void revJulian(int j, int y, int *d, int *m)
Input:
J
contains julian no. for given year from given date
y
year from given date
d
integer value, will get day from julian number
m
integer value, will get mpnth from julian number
Return Value:
None

• "!ding project and creation of library
467
_. Weekday.c
id weekDay(char *date, char *dayWeek)
lit:
date
Given date in dd/mm/yyyy format
dayWeek
pointer to character for getting day of week
etum value:
. None
Subyear.c
subYear(char *date, int dyear, char *newDate)
date
Given date
dyear
Number of years to be subtracted
Cmpdate.c
cmpDate( char *datel, char *date2)
ut:
datel
First date in dd/mm/yyyy format
date2
Second date in dd/mm/yyyy format
date1 > date2
date1 =
= date2
date1 < date2
~l
o
I
_ ddyear.c
\
addYear(char *date, int iyear, char *newDate}
date
Given date
iyear
Number of years to be added
newDate
Character pointer, will get new date after addition
Value:
None
Diffdays.c
diffDays( char *datel, char *date2)
t:
dateI
First date in dd/mmfyyyy format
date2
Second date in dd/mm/yyyy foriuat
Value:
integer value that contains difference of two dates in days
-d diffYMD(char *datel, char *date2, int *y, int *m, int *d)
ut:
date1
First date in dd/mm/yyyy format
date2
Second date in dd/mrn/yyyy format
y
integer pointer, will get years
m
integer pointer, will get months
d
integer pointer, will get days
None

468
Return Value:
newDate
None
Character pointer, will get new date after subtraction
C in Dep
n. Addmon th.c
void addMonth(char *date, int imonth, char *newDate)
Input:
date
Given date
imonth
Number of months to be added
newDate
Character pointer, will get new date after addition
Return Value:
None
12. Submonth.c
void subMonth (char *date, int dmonth, char *newDate)
Input:
date
Given date
dmonth
Number of months to be subtracted
newDate
Character pointer, will get new date after subtraction
Return Value:
None
13. Adddays.c
void addDays(char *date, int days, char *newDate)
Input:
date
Given date
days
Number of days to be added
newDate
Character pointer, will get new date after addition
Return Value:
None
14. Subdays.c
void subDays(char *date, int days, char *newDate)
Input:
date
Given date
days
Number of days to be subtracted
newDate .
Character pointer, will get new date after subtraction
Return Value:
None
15.4
Coding
Now we will go to the next step that is coding. Here we write logic for each function given inm
and finally write the code in C language. The coding for all functions is given below.
.1e maintain one header file that contains all function prototypes and will be included in the file wl1
that function is used.
15.4.1
Dtmanip.h
void formDate(char *date, int y: int m, int d);
void splitDate(char *date,int *y,int *m, int *d);
int isValid(char *date);
int isLeap(int y);

Building project and creation of library
void addDays(char *date,int days,char *newDate);
void addMonth(char *date,int imonth,char *newDate);
void addYear(char *date,int iyear,char *newDate);
int cmpDate(char *date1,char *date2);
int diffDays(char *date1,char *date2);
void diffYMD(char *date1,char *date2,int *y,int *m,int *d);
void subDays(char *date,int days,char *newDate);
void subMonth(char *date,int dmonth,char *newDate);
.void subYear(char *date,int dyear,char *newDate);
.void weekDay(char *date,char *dayWeek);
void revJulian(int j,int y,int *d,int *m);
int julian(int d,int m,int y);
15.4.2
Datefmt.c
469
/*To
split
and
form
void
splitDate(char
{
the
date* /
*date, int
*y, int
*m,int
*d)
L
date[2]=date[5]='\0';
*d=atoi (date) ;
*m=atoi(date+3) ;
*y=atoi(date+6);
date[2]=date[5]='/' ;
}/*End
of
splitDate( )*/
void
formDate (char
*date, int
y, int
m, int
d)
{
char
arr [ 9] [3] = { "01" , "02 " , "03 " , "04 II
, "05 " , "06 II
, "07 " , "08 II
, "09 " } ;
if (d<lO)
strcpy(date,arr[d-l]);
else
sprintf(date,"%d",d);
if(m<lO)
strcpy(date+3,arr[m-l]) ;
else
sprintf(date+3, "%d",m);
sprintf(date+6, "%d",y);
date[2]=date[5]='/' ;
} / *End
of
formDate ( ) * /
The function splitDate( ) is used to get the values of day, month, year in different integer variables.
We have used the library function atoi( ) that converts a string to an integer. The first argument to
splitDate( ) is a string that contains the date in the format dd/mm/yyyy.
The function formDate( ) is used to form a date in format dd/mm/yyyy, from the values of day, month,
year. Here we have used the library function sprintf( ) to convert an integer to string.
15.4.3
Valid.c
/ *To
find
whether
a
date
entered
is
valid
or
not. * /

470
int
isValid(char
*date)
int
d,m,y;
if(date[2] !='/'
II
daterS] !='/'
II
strlen(date) !=10)
return
0;
s~litDate(date,&y,&m,&d);
C in Depth
if(
d==O
II
m==O
retlfrn' 0;
if (
d<l
I I
d>31
return
0;
II'y==O)
II
m<l
II
m>12)
if. (m==2)
{
/ *check
for
number
of
days
in
February* /
if (d==29
&&
isLec>.p (y) )
return
1;
if (
d>28)
return
0;
}
.
if(
m==4
II
m==6
II
m==9 II m==l1)/*Checkfor days in april,
june, sept,
nov* /
if(d>30)
return
0;
This function returns 1 if the date is valid, otherwise it returns zero. In this function, initially we chec -
the Jonnat of the date. If the date is not in the format dd/mm/yyyy, then it is invalid. After this we
call function splitDate( ) to get the values of variables y, m, d. Inside splitDateO we have used atoi
) which returns 0 if it can't successfully convert string to an integer. For example suppose the use
enters the date as : 09/ii/1988, here the value of variable m will be zero since atoiO would not wo •
successfully. So if any of the variables y, m, d has value zero, then the date is invalid. Rest of the
function is simple.
return
}/*End
of
1 ;
isValid()*/
15.4.4
Leap.c
int
isLeap (int
year)
if (year%4==0
&&
year%100! =0
II
year%400==0)
return
1;
else
return
0;
}/*End
of
isLeap()*/
15.4.5
Julian.c
/ *Function
to
calculate
julian
days
* /

uilding project and creation of library
471
::.::It
julian(int
d, int
m, int
y)
int
j=d;
switch(m-l)
{
case
11:
j+=30;
case
10:
j+=31;
case
9 :
j+=30;
case
8:
j+=31;
case
7 :
j+=31;
case
6 :
j+=30;
case
5 :
j+=31;
case
4 :
j+=30;
case
3 :
j+=31;
case'
2 :
j+=28;
case
1:
j+=31;
}
if(isLeap(y)
&&
m!=l
&&
m!=2)
j=j+l;
return
j;
I*End
of
julian()*/
"Function
to
get
id
revJulian (int
the
j,
value
int
y,
of
day
and
month
int
*d,
int
*m)
from
julian
days
*/
int
i;
int
month[13]={0,31,28,31,30,31,30,3i,31,30,31,30,31};
if (isLeap (y) )
month[2]=29;
for(i=1;i<=12;i++)
{
if (j <=month [i] )
break;
j=j-month[i];
*d=j;
*m=i;
*End
of
revJulian()*/
e logic of finding out the julian day is given in Problem 5(program P5.40) of Chapter 5
e function revJulian( ) finds out the value of day and month when the value of julian day and year
known. The array month stores the number of days in each month.
5.4.6
Wcekday.c
"To
find
day
of
week
from
a
given
date --* /
:~nclude<string.h>
id
weekDay (char
*date, char
*dayWeek)
int
d,m,y,j,f,h,fh,day;
splitDate(date,&y,&m,&d);

.._---------
472
j=julian(d,m,y) ;
f=(y-l)/4:
h=(y-l)1100;
fh=(y-l)/400;
day=(y+j+f-h+fh)%7;
switch(day)
{
C in Dep
case
0:
case
1 :
case
2 :
case
3 :
case
4 :
case
5:
case
6 :
strcpy(dayWeek,"Saturday");
break;
strcpy (dayWeek, "Sunday");
break;
strcpy(dayWeek,"Monday"):
break:
strcpy(dayWeek,"Tuesday"):
break;
strcpy (dayWeek, "Wednesday");
break:
strcpy(dayWe~k,"Thursday"): break;
strcpy (dayWeek, "Friday");
break;
}
}/*End
of
weekDay ( )>:.1
The logic of this function is similar to that given in P5.40.
15.4.7
Cmpdate.c
int
dl, ml, yl, d2, m2, y2;
splitDate(datel,&yl,&ml,&dl) ;
splitDate(date2,&y2,&m2,&d2) ;
/ *To
compare
two
int
cmpDate (char
°if(yl<y2 )
return
1·,
if (yl>y2 )
return
-1 ;
if(ml<m2)
return
1·,
if (ml>m2)
return
-I:
if (dl<d2)
return
1·,
dates*/
*datel,char
*date2)
if (dl>d2)
return
-1:
return
0;
}/*End
of
cmpDate()*/
This function returns 1 if date1 falls before date2,
returns -1 if date2 falls before date1
returns 0 if both dates are same.
15.4.8
Diffymd.c
/*To
void
get
difference
of
two
dates
in
years,
months
and
diffYMD(char "*datel,
char
*date2, int
*y, int
*m, int
days*/
*d)

b
Building project and creation of library
int
dl, ml, yl, d2, m2, y2;
splitDate(datel,&yl,&ml,&dl) ;
splitDate(date2,&y2,&m2,&d2) ;
if(d2<dl)
{
if (m2==3)
{
if(isLeap(y2)
d2=d2+29;
else
d2=d2+28;
else
if (m2==5
II
m2==7
II
m2==lO
II
m2==12)
d2=d2+30;
else
d2=d2.+31;
m2=m2-1;
}
if (m2<ml)
{
y2=y2-1;
m2=m2+'12 ;
}
*y=y2-yl;
*m=m2-ml;
*d=d2-dl;
}/*End
of
diffYMD() */
The logic of this function is similar to that given in program P5.37.
15.4.9
Diffdays.c
/*To
get
difference
of
two
dates
in
days*/
int
diffDays (char
*datel, char
*date2)
int
dl,ml,yl,d2,m2,y2,jl,j2;
int
y,d;i,days;
d=O;
splitDate(datel,&yl,&~l,&dl);
splitDate(date2,&y2,&m2,&d2) ;
jl=julian(dl,ml,yl);
j2=julian(d2,m2,y2);
if (yl==y2)
return
(j2-jl);
for(i=yl+l;i<=y2-1;i++)
{
if(isLeap(i»)
d=d+366;
else
d=d+365;
}
if
(isLeap (yl) )
473

So total difference in days = 240 +1461 + 276 = 1977
If both the dates are in the same year the~ we can find out the difference simply by subtracting the
julian days.
Suppose we want to find out the difference in dates 5 May 1970 and 3 Oct 1975. The difference in
days will be sum of three components D 1, d, D2.
D1 = 365 ..:.- julian day of 5 May 1970 = 365
~ 125 = 240
D2 = julian day of 3 Oct 1975 = 276
d = Total days in years from 1971 to 1974 = 365 + 366+ 365 +365 = 1461
} / *End
of
subYear () * /
C in Depth
3 Oct 1975
d
Dl
5 May 1970-<:----~r-(--------f
D2
days=(366-jl)+d+j2;
else
days=(365-jl)+d+j2;
15.4.11 Subyear.c
/ *To
subtract
years
from
a
date* /
void
subYear(char
*date,int
dyear,char
*newDate)
{
/ *To
add
years
to
a
date* /
void
addYear(char
*date,int
iyear,char
*newDate)
{
if(d==29
&&
m==2
&&
!isLeap(y))
d=28;
formDate(newDate,y,m,d) ;
15.4.10 Addyear.c
int
d,m,y;
splitDate(date,&y,&m,&d);
y=y+iyear;
if (d==29
&&
m==2
&&
! isLeap (y) )
d=28;
formDate(newDate,y,m,d);
} / *End
of
addYear () * /
splitDate(date,&y,&m,&d) ;
y=y-dyear;
int
d,m,y;
return
days;
}/*End
of
diifDays( )*/
474

Building project and creation of library
j
15.4.12 Addmonth.c
/ *
To
add
months
to' a
date* /
void
addMonth (char
*date, int
imonth, char
*newDate)
int
d,m,y,quot,rem;
splitDate(date,
&y,
&m,&d);
quot=i!llonth/12;
rem=imonth%12;
y=y+quot;
m=m+rem;
if(m>12)
(
y=y+l;
m=m-l,2 ;
}
if (m==2
&&
d>=29)
{
if ( ! isLeap (y) )
d=28;
if (isLeap (y) )
d=29;
}
if: (m==4
II
m==6
II
m==9
I I
m==ll)
&&
d==31)
d=30;
formDate(newDate,y,·m,d);
} / *End
of
addMonth () * /
15.4.13 Submonth.c
/ *To
subtract
months
from
a
date* /
void
sUbMonth (char
*date, int
dmonth, char
*newDate)
{
int
d, m, y, quot, rem;
splitDate(date,&y,&m,&d) ;
quot=dmonth/12;
w.\.
rem=dmonth%12;
\-
y=y-quot;
m=m-rem;
if (m<=O)
{
y=y-l;
m=m+12;
}
if (m==2
&&
d>=29)
{
if ( ! isLeap (y»
d=28;
if (isLeap (y) )
d=29;
}
if «m==4
I I
m==6
II
m=;:;9
I I
m==ll)
&&
d==31)
475

476
d=30;
formDate(newDate,y,m,d) ;
} / "'End
of
subMonth () * /
I
15.4.14 Adddays.c
/*To
add
days
to
a
date*/
void
addDays (char
*date, int
days, char
*newDate)
{
int
dl, ml, yil, d2, m2, y2;
int
jl,x,j2,k;
splitDate(date,&yl,&ml,&dl) ;
jl=julian(dl,ml,yl) ;
x=isLeaphrl)
?
366-jl
365-jl;
if (days1::x)
{
j2=jl+days;
y2=yl;
}
else
days=days-x;
y2=yl+l;
k=isLeap(y2)
?
366:
365;
while(
days>=k)
{
C in Depth
Suppose we want to add days to the date 5 May 1970. Initially we'll find out the julian day(jl) of this
date which comes out to be 125. Now we'll try to find out the year and julian day(j2) of the new date,
and after that we'll use function revJulian( ) to find out the exact day and month of the new date.
First of all we'll find out the remaining days of the year 1970 by subtracting jl from 365..
This
valu~ comes out 240 and is stored in variable x. Now if the days to be added are less than or
equal to x, then year of the new date will remain same and the julian day of the new date can be found
out by writing j2 = jl + days; For example if we have to~dd 200 days to 5 May 1970, then value
of j2 will be 125 + 200 = 325, so after calling revJulian( ) and formDate( ) we get the new date as
21/11/1970.
Suppose we have to add 1900 days to 5 May 1970. First we'll subtract x=240 from 1900

477
/lilding project and creation of library
*To
subtract
days
from
a
date* /
~oid subDays(char
*date,int
days,char
*newDate)
ames out 1660), after this we'll reach the next year i.e. 1971. So now we have to add 1660 days
:0 1 Jan 1971. Now keep on subtracting the days of years from 1660 till you get a value less than
65(or 366 in case of leap year).
1660 - 365 = 1295 , we've reached 1 Jan 1972
1294 - 366 = 929, we've reached 1 Jan 1973 (subtracted 366 since 1972 is leap)
929 - 365 = 564, we've reached 1 Jan 1974
.
564 - 365 = 199, we've reached 1 Jan 1975 (199 < 365)
_-ow the year y2 is 1975 and the julian day j2 is 199, so on calling revJulian( ) and fonnDate( ) we'L
set the exact date which comes out to be 18/07/1975
5.4.15 Subdays.c
int
d1, m1, y1, d2, m2, y2;
int
j1,j2,x,k;
splitDate(date,&y1,&m1,&d1) ;
j1=julian(d1,m1,y1) ;
if(days<j1)
{
j2=j1-days;
y2=y1;
}
else
days=days-j 1;
/ *Now
subtract
days
from
1st
Jan
y1 * /
y2=y1-1;
k=isLeap(y2)?366:365;
while(days>=k)
{
if (isLeap (y2) )
days=days-366';
else
days=days-365;
y2- -;
k=isLeap(y2)?366:365;
}
j2=isLeap(y2)?366-days:365-days;
}
revJulian(j2,y2,&d2~&m2);
formDate(newDate,y2,m2,d2) ;
• / *End
of
subDays () * /
-:be logic of this function is somewhat similar to that of addDays( ).
5.4.16 Main.c
=include<stdio.h>
-include
"dtmanip. h"
ain ( )
l

478
C in Depth
int
choice;
char
date[ll] ,date1[ll] ,date2[ll];
char
dayWeek[10] ,newDate[ll];
int
iyear, imonth, dyear, dmonth, days;
int
y,m,d;
whi1e(1)
.{
switch(choice)
{
printf ("1.
Date
validation\n");
printf ("2.
Compare
..9.ates\n");
printf ("3.
Differenc~~-of
Dates
in
days\n");
. printf (" 4.
Dif ference
of
Dates
in
years, months, days \n") ;
printf ("5.
Day
of
week\n");
printf("6.
Add
years\n");
printf("7;. Ac1d
months\n");
printn"8.
Add
days\n");
printf("9.
Subtract
years\n");
printf ("10.
Subtract
months\n");
printf("ll.
Subtract
days\n");
printf("12.
Exit\n");
printf ("Enter
your
choice
") ;
scanf("%d",&choice);
case
1:
printf ("Enter
date
(dd/mm/yyyy)
") ;
scanf("%s",date) ;
if(isValid(date) )
printf ("Valid
date\n");
else
printf ("Not
a
Valid
Date\n");
break;
case
2:
printf ("Enter
first
date
(dd/mm/yyyy)
") ;
. scanf("%s",date1);
printf ("Enter
second
date
(dd/mm/yyyy)
") ;
scanf("%s",date2);
if(!isValid(date1)
II
!isValid(date2»
{
printf ("Enter
only
valid
da,tes\n");
break;
1)
\n",date1,date2) ;
-1)
\
\n",date1,date2);
%s
are
same. \n" ,dat
date<.:,
)
Date ,~\
%s
dat~2 \ )
Date
\ %s
\
date1,
%s
<
date1,
%5
>
}
if(cmpDate(date1,date2)==0)
printf ("Date
%s
and
Date
date2) ;
else
if (cmpDate(
printf ("Date
else
if (cmpDate (
printf ("Date

~uilding project and creatIOn oJ Iwrary
break;
case
3:
printf ("Enter
first
date
(dd/mm/yyyy)
") ;
scanf("%s",datel) ;
printf ("Enter
second
date
(dd/mm/yyyy)
") ;
scanf("%s",date2) ;
if(!isValid(datel)
II
!isValid(date2»
{
printf ("Enter
only
valid
dates\n");
break;
}
if(cmpDate(datel,date2)==l)
days=diffDays(datel,date2) ;
else
days=diffDays(date2;datel) ;
printf ("Difference
in
days
%d\n", days) ;
break;
case
4:
printf (".Enter
first
date
(dd/mm/yyyy)
") ;
scanf("%s",datel) ;
printf ("Enter
second
date
(dd/mm/yyyy)
") ;
scanf("%s",date2) ;
if ( ! isVa 1 i d (datel)
I I
! isVa 1 i d (da t e 2 ) )
{
printf ("Enter
only
valid
dates\n");
break;
}
if{cmpDate(datel,date2)==l)
diffYMD(datel,date2,&y,&m,&d) ;
else
diffYMD(date2,datel,&y,&m,&d) ;
printf ("Difference
of
the
two
dates
is
") ;
printf("%d
years
%d
months
%d
days\n",y,
m,
d);
break;
case
5:
printf ("Enter
date
(dd/mm/yyyy)
") ;
scanf("%s",date) ;
weekDay(date,dayWeek) ;
printf("Day
of
week
is
%s\n",dayWeek);
break;
case
6:
printf ("Enter
date
(dd/mm/yyyy)
") ;
scanf("%s",date) ;
if(!isValid(date»
{
printf ("Enter
a
valid
date\n");
break;
}
printf ("Enter
the
number
of
years
to
be
added
") ;
scanf("%d",&iyear) ;
addYear(date,iyear,newDate) ;

48~
C in lJept
printf ("Now
the
new
date
'is
%s\n", newDate) ;
break;
case
7:
printf ("Enter
date
(dd/mm/yyyy)
") ;
scanf(Y%s",date);
if(!isValid(date) )
{
printf ("Enter
a
valid
date\n");
break;
}
printf ("Enter
the
number
of
months
to
be
added
") ;
scanf("%d",&imont~) ;
addMonth(date,imonth,newDate) ;
printf("Now
the
new
date
is
%s\n",newDate);
break;
case
8:
printf ("Enter
date
(dd/mm/yyyy)
") ;
scanf ("%s", date) ;
if(!isValid(date»
{
printf ("Enter
a
valid
date\n");
break;
}'
printf ("Enter
the
number
of
days
to
be
added
") ;
scanf("%d",&days);
addDays(date,days,newDate);
printf ("Now
the
new
date
is
%s\n", newDate) ;
b'reak;
case
9:
printf("Enter
date
(dd/mm/yyyy)
");
scanf("%s",date) ;
if(!isValid(date»
{
printf ("Enter
a
valid
date\n");
break;
printf ("Enter
the
number
of
ye'ars ,to
be
subtracted
scanf("%d",&dyear);
i
subYear(date,dyear,newDate) ;
printf("Now
the
new
date
is
%s\n",newDate);
break;
case
10:
printf ("Enter
date
(dd/mm/yyyy)
") ;
scanf("%s",date) ;
if(!isValid(date»
{
printf ("Enter
a
valid
date\n");
break;
}
printf ("Enter
the
number
of
months
to
be
subtracted
scanf("%d",&dmonth);

valid
date\n");
\
Building project and creation of library
subMonth(date,dmonth,newDate);
printf ("Now
the
new
date
is
%s\n", newDate) ;
break;
case
11:
printf ("Enter
date
(dd/mm/yyyy)
") ;
scanf("%s",date) ;
{f( !isVa1id(date»
{
printf ("Enter
a
break;
481
}
printf ("Enter
the
number
of
days
to
be
subtracted
") ;
scanf("%d",&days);
subDays(date,days,newDate) ;
printf ("Now
the
new
date
is
%s\n", newDate) ;
break;
case
12:
exit (1) ;
default:
printf ("Wrong
choice\n");
}/*End
of
switch*/
}/*End
of
while*/
}/*End
of
main()*/
15.5
Building Project in Turbo C
I.
First go to Project -> Open Project
Create a project file DT.prj
2.
Now a "window will open that will display all files in the project. Right now we don't have any
file added in project.
"
3.
Now go to menu option Project -> Add Items and ,add a file in the project. The added file will
come in project window.
Similarly add all files one by one !n the project. Now you can see all the files in project window.
Now you can open any file by double clicking on that item in project window. Any file can be
deleted from the project by selecting it and pressing Delete or from the menu option delete item.
6.
Now go to Compile -> Build All, it will compile all the files and build the project. All the errors
will come in window for each file. If there is no error then it will show success,
Now go to Run -> Run and program will run.
Now close all windows including project item window.
Now go to Project -> Close Project for closing the project.
15.6
Testing
_ow we go for next and last step that is testing. Here we write different test cases for all modules
and see whether the modules give correct results for each case. We perform testing for each individual
odule which is called module te"sting, as well as we do integration testing which tests that after
tegration also all modules are working fine or not or we find out which module is giving problem
er integration.
our project we will test functionality after integration because here module testing and integration
.
"

482
C in Depth
testing is more or less same. So we will check functionality with different test cases if any errors are
coming then we will modify that particular part of coding and do the testing again.
15.7
C
,
Creation Of Library And Using it in your Program in Turbo
Suppose we want to add a module in library. First we will produce .obj file by compilation then we
will add the function of .obj file to library with the help of tlib utility. The whole process will be as-
1.
Produce the .obj file by compiling file as-
d:\> tcc -c xyz.c (ENTER)
Now xyz.obj will be created.
We can also make the .obj file by Alt + F9:
2.'
Now we will add all the functions of xyz.obj in new library as-
d:\> tlib ABC.lib+xyz.obj (ENTER)
Now new library ABC.lib will be created which will contain all the functions of XYZ.obj.
3.
Create one header file named ABC.h which will contain prototype of all the functions available in
library ABC.lib.
4.
Now you can call any function of library ABC.lib by including header file ABC.h.
5.
Suppose we want to add some more modules. First we will get the .obj file of all modules then
they will be added as-
d:\> tlib ABC.lib+XYZ1.obj+XYZ2.obj+XYZ3.obj (ENTER)
Now we will create library dtmanip.lib for our Date project and will call the functions in one sample
file.
1.
First we will produce .obj files for all modules as-
d:\> tcc -c- Datefmt.c Valid.c Leap.c Julian.c Weekday.c Cmpdate.c Diffymd.c Diffdays.
Addyear.c Subyear.c Addmonth.c Submonth.c Adddays.c Subdays.c
This will produce .obj files for all modules.
~
2.
Now we will create one new library dtmanip.lib for date manipulation by adding these modul
d:\>tlib dtmanip.lib+Datefmt.obj+Valid.obj+Leap.obj+Weekday.obj+Cmpdate.obj+
Diffdays.obj+Diffymd.obj+Addyear.obj+Addmonth.obj+Adddays.obj+Subyear.obj+
Submonth.obj+Subdays.obj+ Julian.obj
Now new library dtmanip.lib will be created, which will contain all the functions of above ~odul
3.
We will create one header file dtmanip.h, which is already given before.
4.
Now we will create one sample file like main.c of Date project and call the functions availab :
in dtmanip.lib.
5.
Create new project testlib and add dtmanip.h, main.c and dtmanip.lib in this project.
I
6.
Now we can build and run this project.
So now we have date manipulation library that can be used anywhere else also whenever date rela
manipulation is required.
15.7.1
Deletion of a Module From Library
We can delete any module from library as-
d:\> tlib dtmanip-Diffdays

Building project and creation of library
483
This will delete the module of Diffdays from dtmanip library.
15.7.2
Getting Modules From Library
We can get module from library as-
d:\> tlib dtmanip*Valid
Now we will get the Valid module, from dtmanip.lib. This can be added in different library as-
d:\> tlib newdt.lib+Valid.obj
This will add Valid module which we got from dtmanip.lib, into newdt.1ib.
15.7.3
Changing Version Of l\1odule In Library
This can be done by deleting and then adding a particular module from library as-
d:\> tlib dtmanip-Adddays
This will delete the module Adddays from dtmanip.lib library.
d:\> tlib dtmanip+Adddays.obj
This will add the new version of module Adddays in dtmanip.lib library.
We can do the same thing in one step also as-
d:\> tlib dtmanip-+Adddays
This will delete the Adddays module froni dtmanip.lib and add the new version ofAdddays in dtmamp.lib.
15.8
Building Project On Unix
We require makefile concept for building project on unix platform. Unix provides a utility make to build
project. This utility takes care of dependencies.
We know very well how to compile files with unix cc compiler and get the object and executable file.
Suppose we want to compile a single file main.c. Then it looks very easy-
cc -0 Date main.c
It will compile main.c and give the executable Date.
Suppose we have more than one file then we can compile them as-
ee -0 Date main.c Datefmt.e Valid.c Leap.e Weekday.e Cmpdate.e Diffdays.e Diffymd.e Addyear.c
AJdmonth.c Adddays.e Subyear.e Submonth.c Subdays.c Julian.c
Now it will compile all the files and give the executable Date as output.
Suppose we are compiling all these files first time then it looks fine. But suppose we are changing source
code of some file and again compiling then it will be a time taking process. We can provide .0 compil.ed
object file of them, which are not changed. Suppose only main.c is changed and rest of them are same
then we can use .0 object file of rest of them as-
cc -0 Date main.c Datefmt.o Valid.o Leap.o Weekday.o Cmpdate.o Diffdays.o Di~ymd.o Addyear.o
Addmonth.o Adddays.o Subyear.o Submonth.o Subdays.o Julian.o
We can create only object file with -c option as-
ce -c file.c
So now we know that we have no need to compile all the files again if their source is nelt changed.
We can use their object file itself./But this is always very difficult to remember that which file is c.hanged

'4
484
C in Depth
and which one need not to recompile again. Even compiling these files again and again on command
line is also a big problem.
The solution is make utility. This utility takes care. of all these problems and it even provides some more
facility to manage project in a better way.
15.8.1
Writing Makefile
make utility uses makefile for building project. This makefile contains commands that tell make utility
how to build your project with given source files. This makefile contains the dependency rules and
construction rules.
left side : right side
cc right side ( compilation by using options for linking library )
Here in first line, left side is the target and right side is the source files on which target is dependent
Second line is for the construction. If any source file is changed then make will go for construction
rule otherwise it will not do anything. We have to understand what exactly make utility does with
makefile.
1.
It reads makefile and comes to know which object file and library is needed for target and the
it checks what source files are needed for each object.
2.
It checks time and date for each object file against dependent source, if any source is of later
date than its object file, then it will apply construction rule for that particular object.
3.
Now it will check time and date oftarget against dependent object file if any object file is of later
date than it's target then it will apply construction rule for target.
Now we will see how will be our makefile for Date project then we will see what is the meaning o~
each line of our makefile.
Makefile 1:
#--------------------
#
Date project Makefile
#
#
TARGET=Dt
OBJS=Datefmt.o Valid.o Leap.o Julian.o Cmpdate.o Adddays.o Addmonth.o Addyear.o \
Subdays.o Submonth.o Subyear.o Diffymd.o Diffdays.o Weekday.o Main.o
$(TARGET):$(OBJS)
cc -0 $(TARGET) $(OBJS)
Datefmt.o:Datefmt.c
cc -c Datefmt.c·
Valid.o:Valid.c
cc -c Valid.c
Leap.o:Leap.c
cc -c Leap.c

-,uilding project and creation of library
485
Date project Makefile
S=Dtaefmt.o Valid.o Leap.o Julian.o Cmpdate.o Adddays.o Addmonth.o Addyear.o \
Subdays.o Submonth.o Subyear.o Diffymd.o Diffdays.o Weekday.o Main.o
(TARGET)
:\RGET):$(OBJS)
lian.o:Julian.c
cc -c Julian.c
mpdate.o:Cmpdate.c
cc -c Cmpdate.c
ddays.o:Adddays.c
cc -c Adddays.c
-_ dmonth.o:Addmonth.c
cc -c Addmonth.c
- dyear.o:Addyear.c
cc -c Addyear.c
bdays.o:Subdays.c
cc -c Subdays.c
-
month.o:Submonth.c
cc -c Submonth.c
_::byear.o:Subyear.c
cc -c Suby·ear.c
dfymd.o:Diffymd.c
cc -c Diffymd.c
- days.o:Diffdays.c
cc -c Diffdays.c
rekday.o:Weekday.c
cc -c Weekday.c
- .o:Main.c
cc -c Main.c
e can write the makefile as also.

486
C in Depth
cc $(OBJS) -0 $@
15.8.2
Building Project With Make
We can simply execute make as-
$make (ENTER)
It will search for file makefile in current directory and will build the project. But suppose we have man:
makefiles for different projects, then we can use some naming convention to name makefile for projects
Like we can name our project makefile as project_makefile. Here our project is Date so we can nam~
our makefile as Date makefile.
.
We can execute this as-
Creation Of Library And Using In Your Program in Unix
First we will compile all the files for creating .0 for source files.
$cc -c Datefmt.c Valid.c Leap.c Julian.c Cmpdate.c Adddays.c Addmonth.c Addyear.c \
Subdays.c Submonth.c Subyear.c Diffymd.c Diffdays.c Weekday.c Main.c
This will produce .0 file for all source .c files.
Now we will assign all .0 files to one variable.
$OBJS= Dtaefmt.o Valid.o Leap.o Julian.o Cmpdate.o Adddays.o Addmonth.o Addyear.o \
Subdays.o Submonth.o Subyear.o Diffymd.o Diffdays.o Weekday.o Main.o
Library dt will be created with archiver ar as-
ar mv Libdt.a $OBJS
Now we will write file Main.c and call the functions of dt library in it.
Now Main.c will be compiled as-
cc -0 Dt Main.c -L. -ldt
3.
2.
4.
5.
15.9
Now we will see process for creation of library and how to call function of this library in another
1.
$make -f Date_makefile (ENTER)
I would like to recommend you to see the unix man page of make. This can be very useful for bu' -
work, which also takes a slice of project time. Generally one person in team is devoted for handl" _
build work of project.

Chapter 16
Codv Optimization in C
16.1
Optimization is a Technique
When we think about optimization, it looks like we are talking only about making our code shorter.
But its not true, sometimes shorter code takes more execution time compared to large code. So here
comes performance, and it depends on whether you want shorter code that is good for maintenance
but less in performance, or larger code that is bad for maintenance but good in performance. Now we
will come to resource optimization. Generally resources are shared between different processes. Suppose
your program takes more resources, then definitely it will affect performance of other processes that
need same resources. So we have a need to write and optimize our program keeping in mind resources
e.g. processor's time. You will be surprised to know that most of the time, increasing of hardware
like processors comes only because of our bad programming like unnecessary variables, bad searching
and sorting algorithms. This is because we think only about running our program properly, and consider
about resources only after getting some problem. Companies are spending more than $50 million on
resources, adding more than 12 processors in single server, only because they don't consider other
things in programs and are helpless to find this individual problem. So our work is not only to write
program but also to develop the habit of writing optimized programs considering the overall Vlew of
system. That's why optimization is a technique because it considers many other things in program not
only codes. You will see more things later in each topic.
16.2
Optimization With Toor
The first tool with our code is compiler. We can do lot ofoptimization with our compiler itself. It provides
lot of options. So firstly we should understand our compiler better. Compiler manual can help you in
understanding different options. We should know what our compiler can do for us and what it cannot
do. So we do whatever it does not do for us and we will not do whatever it does for us. We have
some different tools, which can help us to write our code in a better way. Like we can use tool purify
to know where memory leak is coming in our code. Also we can use purecov to know how much
coverage is done. by our code, so that we can write code that has better coverage.
16.3
Optimization With Loop
16.3.1
Loop Unrolling
We can unroll small loops. Let us take an example-
int
a=5;
for(i=O;i<4;i++)
{

488
value[iJ=a;
a=a+5;
C in Depth
}
This can be simply written like this-
int value[ ] = { 5, 10, 15,20 };
at initialization time. Alternatively it can be written in between program like this-
value[0]=5;
value[1]=10;
value[2]=15;
value[3]=20;
This is obviously better than previous one but most of the times compiler does this automatically, but
we can expect little bit advantage and even it will be better to make a habit of writing optimized code.
You can get this advantage in matrix program.
.
.
16.3.2
Avoiding Calculations In Loops
We should avoid any calculation, which is more or less constant in value within the loop. The same
thing is true for avoiding calculation or anything, w~ich can be removed from inner loop.
for(i=O;i<10;i++)
value[iJ=b*(20-b/3*c%2)*i/2;
We can avoid this calculation and it can be written as-
a=b*(20-b/3*c%2)/2
for(i=O;i<10;i++)
{
value[i]=a*i;
Always try to minimize things in inner loop because this can improve efficiency.
16.4
16.4.1
Fast Mathematics
•
Avoid Unnecessary Integer Division
We know that division operation is slow so we shOl,I1d try to minimize the division operations. Let us
take an example-
int a, Q, c, d;
d = albic;
This division operation can be eliminate.d as-
d=a/(b*c);
Multiplication operation is more effective than division operation. So we should try to convert division
operation to multiplication.
.
16.4.2
Multiplication And Division by Power Of 2
We know that base of computer understanding is binary( 0 or 1) i.e. base of 2. So we always need
to do multiplication and division operations for numbers which are power of 2. One way is to do simple

Code Optimization in C
489
division or multiplication with the number, which is power of 2 as-
a = a * 8 ( 8 is 23 )
a = a / 8 ( 8 is 23
)
The second way to perform the same operation is by using left shift «
for multiplication operation
and right shift »
for division operation. This can be done as-
a = a «
3 (or a = a * 23 )
a = a »
3 (or a = a / 23 )
So,
a «
b is equivalent to a * 2b and
a »
b is equivalent to a / 2b
These bit operations will be much faster than multiplication and division operations. For simple operations,
the compiler may automatically optimize the code but in case of complex expressions it is always advised
o use· bit operations, which is more effective optimization.
Suppose we want to multiply by 6 then it can be written as-
a = a «
1+ a «
2;
Compiler can not optimize this code so we should always make habit of writing optimized code without
minking that it can be optimized by compiler or not.
16.5
Simplifying Expressions
ometimes we can reduce some operations by simplifying expressions. Let us see a simple example-
x * y + Y *4
This can be simplified as-
(x+4)*y
This will reduce one multiplication operation.
16.6
Declare prototypes for Functions
e should always declare prototype for functions. This will tell the compiler about functions and it
:an be helpful for compiler to optimize the code.
6.7
Better Way Of Calling Function
e know that calling a function means a stack will be setup with parameters of functions, so we should
ays try to reduce the parameter of functions, which can improve the stack mechanism. It will be
_ tter to use pointer instead of passing structure or big array, which can be overhead for stack and
decrease the efficiency of program.
.
6.8
Prefer int to char or short
'e should always prefer int to char because C performs all operations of char with integer. In all
erations like passing char to a function or any arithmetic operation, first char will be converted into
teger and after completion of operation it will again be converted into char. For a single char this
y not affect efficiency but suppose same operation is performed 100 times in a loop then it can
rease the efficiency of program.

490
16.9
Use of Register Variables
C in Depth
. Register variables are' stored in CPU registers. If you are declaring a variable as register then it w'
be accessed from register instead of memory which will always be faster. We know that registers ar
limited so we should declare only those variables as register, which are heavily used. If we have nest
loops, then we should take the inner loop variables as register, because they will be used more tim
than outside loop variables.
16.10 Optimization With Switch Statement
Compilers translate switch statements in different ways. Ifcase labels are small contiguous integer valu
then it creates jump table. This is very fast and doesn't depend on number of case labels also. If c
labels are longer and not contiguous then it creates comparison tree i.e. if.. .else statements. So in
case we should keep the most frequent label first and least frequent label should be at last. Let us tee
an example-
.
switch(
no_of_day
{
case
31:
break;
case
30:
break;
case
28:
case
29:
break;
default:
printf ("Incorrect
value\n");
break;
}/*End
of
switch*/
...
Sometimes we see lot of repeated code written in all cases except one or two statements. Let us
an example-
switch(expression)
{
case
a:
break;
case
b:
bre.ak;
case
c:
common. statements;
different
statements;
common
statements;
break;
case
d:
common
statements;

Code Optimization in C
different
statements;
common
statements;
break;
case
e:
common
statements;
different
statements;
common
statements;
break;
case
f:
common
statements;
different
statements;
common
statements;
break;
default:
break;
491
Here we can take all cases together and can write common statements only once and different statements
in related cases using another switch. Here we will take case c, d, e, f together and write common
statements, then we can use another switch and write different statements in case c, d, e, f. Then after
this switch we can again write common statements. This problem is repeated by lot of programmers
because they don't use this trick.
.
switch(expression)
{
case. a:
break;
case
b:
break;
case
c:
case
d:
case
e:
case
f:
common
statements;
switch(expression);
{
case
c:
different
statements;
break;
case
d:
different
statements;
break;
case
e:
different
statements;
break;
case
f:
different
statements;
break;
1
_

...----------
492
}/*End
of
switch*/
common
statements;
·break;
default:
break;
}/*End
o·f
switch*/
Hopefully this will help lot of new programmers.
16.11
Avoid Pointer Dereference
C in Depth
We should always avoid. pointer dereferencing in loop or while passing it as parameter. It creates lot
of trouble in memory. Suppose it is used in loop then it will affect the efficiency. So better assign it
to some temporary variable and then use that temporary variable in loop.
16.12 Prefer Pre Increment/Decrement to Post Increment/Decrement
We should prefer pre increment/decrement to post increment/decrement wherever both of them have
been used for same work. In pre increment, it first increments the value and just copies to the variable
location but in post increment it first copies the value to temporary variable, increments it and then
copies the value to variable location. For a one time operation may be it will not affect but suppose
this operation is in 1000 time loop then it will sure effect the efficiency. So it will always be better
to use pre increment/decrement to get efficiency.
16.13 Prefer Array to Memory Allocation
Wherever possible we should use array instead of pointer with memory allocation. Accessing with array
index is always fast compared to dynamic storage. Basically it depends on the requirement also. But
if we are sure that we are not going to use storage more than particular size then we can prefer arra
for that particular size. Memory allocation and deallocation has some burden and in some circumstances
it can be avoided with array. You can take example of creating stack or queue, which will be better
with array instead of implementing with linked list when we know the size of stack and queQe will
not be more than particular size.
16.14 Use Array Style Code Rather Than Pointer
Pointer is special facility in C that distinguishes it from other languages. Effective use of pointer makes
C language more efficient. But it also creates problem for compiler to optimize code. Pointer can read
and write at any part of memory and it becomes difficult for compiler to optimize code which uses
pointer. In some places we can 'use pointer as array. Like we can use ptr[O], ptr[ 1]
which will
make compiler's job easier for optimization.
16.15 Expression Order Understanding
In C we use lot of expressions in control statements and we also join more than one expressions b
I I or && operator. Let us take an example of I I operator-
A II
B
Here first A will be evaluated, if it's true then there is no need of evaluation of expression B and condition
will become true. But if A is false then it will check for B, now if B is true then whole condition will
become true otherwise it will be false. Suppose probability of expression A becoming true. is very less
and B becoming true is high then most of the time after evaluating expression A it will go for evaluation
of B. So most of the time we are evaluating A unnecessarily. In this case, it 'would be better to put

Code Optimization in C
493
the expression B first in condition, which has higher probability of becoming true.
B I I
A
( preferred )
Nbw it will first check B and if it's true then condition will be true and it will skip most of the time
evaluation of A and will increase the performance. Now let us check one example of && operator-
C &&
D
Here first expression C will be evaluated and if its false then no need of evaluation of expression D
andcondition will become false. IfC is true then it will check for D, ifD is also true then whole condition
will become true otherwise it will become false. Here we will check which expression has more probability
of becoming false: that expression should be placed first expression in condition.
Now suppose probability of becoming true or false is equal in all expressions which are joined with
I I or && operator then the expression which can be evaluated faster than others should be first in
condition.
16.16 Declaration Of Local Function
We should always declare all the- functions used in a program and if the function is used in that file
only then it should always be declared .as static, that means scope of that function will be limited to
that file only. If it is not declared as static then it will be interpreted as extern and compiler will take
unnecessary burden for external linkage of this function because it will think that this can be used outside
file also.
16.17 Breaking Loop With Parallel Coding
We can write parallel coding by writing instructions in pipeline. We can write one instruction of loop
into parts, which can help to reduce the number of cycles and definitely increase the efficiency. Let
us take an example-
total=O;
for(i=l;i<=lOO;++i)
total
+=
i;
Here we are simply evaluating the total uf numbers from 1 to 100. The same thing can be done as:
totall=O;
total"2=O;
tota13=O;
tota14=O;
total=O;
" for(i=1;i<=lOO;i=i+4)
{
totall=totall+i;
tota12=tota12+i+li"
tota13=tota13+i+2i
tota14=tota14+i+3i
}
total
=
total 1
+
tota12
+
tota13
+
tota14i
It doesn't seem very attractive optimization but it can improve efficiency where big calculation is required
like in mathematics or graphics.
16.18 Trick to use Common Expression
We can extract common expression, which is used at many places in the program. Let us take an example-

494
C in Depth
x = a*lO/b;
y = c*SIb;
We can write the same as-
temp = Sib;
x = a*2*temp;
y = c*temp;
Here we are avoiding evaluation of an expression by using temp variable and multiplication. Here the
expression is very small, but suppose it is a big one and used at lot of places tl1en it will be better
choice. These things are to be done manually by properly reviewing the code, because compiler will
not be able to do optimization for these types of tricks.
16.19 Declaring Local Variables Based On Size
The local variables should be declared based on their sizes. We should prefer to declare larger to smaller
datatype size variables. Compiler allocates variables in the same sequence in which they are declared.
Declaring larger to smaller datatype variables will help the compiler in alignment and padding. Let us
take an example-
int a;
float b;
long c;
double d, e[2];
This should be declared as-
double e[2];
double d;
long c;
float b;
int a;
,':
16.20 Prefer Integer Comparison
We should always prefer integer comparison in conditions because it is faster as compared to any 0
data type.
16.21
Avoid String Comparison
We should try to avoid strings 'comparisons as much as possible. String comparison is very slo
it compares each character. Generally we use strcmp( ) function fO,r comparing two strings. But
is very slow and can be very inefficient if we have lot of data in strings for comparing. We kno
can't avoid comparing strings, but we can use some trick for the comparison:
1.
Compare the index of '\0' of first string with the same index of second string.
2.
Firstly compare first character of both strings; if they are same then only compare the full su_'-=-_
These two points can be very important in avoiding most of the string comparison.

Chapter 17
C and fis~embly Interaction
C has wonderful feature to interact with assembly. This makes it more useful. It's good that we can
interact with other language but the question arises why is it needed. We know very well that assembly
is a low level language and it can interact directly with hardware. It does manipulation in registers so
it is always fast compared to other languages. There are so many things that can be done with assembly
language only. We can use these features with C very easily. We ca~ write inline assembly routine in
our C code, as well as our C module can also interact with assembly module.
17.1
Inline Assembly l,anguage
We can write assembly statement in C language by using asm keyboard before each assembly-statement
ill our program.
Ex-
asm mov AX , 5
Let us take a C program to print a character by using assembly statement.
:<lain ( )
{
asm
mav
d1, 65
asm
mav
ah,2
asm
int
21
h
Here we are using INT 21 with assembly. Let us see its description-
INT 21 H Service 2 - Character Output on
Input:
. DL= ASCII character
AH=2
For writing same thing in MASM we have to use keyword _asm and <ill the assembly statements will
e in block starting with' { , and ending with'}'.
ain ( )
asm
mav
d1,65
m'av
ah,.2
int
21
h
}

496
C in Depth
Now we can compile and run this program like other C programs. Now you will think how it will happen.
Actually your C compiler parses'assembly code from your program, creates one assembly file and then
assembles it with the assembler (TASM or MASM), when it creates object file then this object file will
be linked to your C executable.
Now the question arises this can be done very easily in C language program, then why inline assembly
is needed. Remember interaction through hardware can be done best through assembly language only.
There are so many things, which cannot be done with C, that can be done only through assembly language
and there is no alternative C function available.
Suppose we want to get the scan code of any pressed key of keyboard. Every key has scan code including
combination of special keys- (Ctrl, Alt, Shift) and normal key. There is no C function available for getting
scan code of pressed key. But we can use INT 16 with assembly for getting scan code. Let us see
how INT 16 works.
INT 16H, service 0 - Read k~y from keyboard
Input:
AH=O
Output:
\
AH=Scan code
AL=ASCII code
main( )
{
asm
mav
ah,O
asm
int
16
H
After these two asm statements, scan code will be available in AH register which we can use in another
part of program. So now you got a brilliant idea, start writing the program for keyboard interaction.
Now we want to take the data in C statement and use it in asm statements. Suppose we want to print
a string then we will need to use 9th routine of INT 21. See the description below-
-
INT 21 H SeFice 9 - String Print
Input:
AH=9
DS:DX points to a string that ends in '$'
Service 9 of INT 21 is used to print the string which ends with '$'. Let us take an example program.
main( )
{
char
*ptr="C
with
Assembly
$" ;
asm
mav
dX,ptr
asm
mav
ah,9
asm
int
21
h
Here INT 21 Service 9 will print-
C with Assembly
Now we want to write assembly statements in\ user defined function. This can be written as-
main( )
{
func ( ) ;

C and Assembly Interactio,:
497
func ( )
{
asrn
rnov
dl,65
asrn
rnov
ah,2
asrn
int
21
h
Here we have written asm statements for printing character 'A' in function func( ). Suppose we want
to take this character in C statements then it can be as-
char
ch= 'A' ;
main( )
{
func ( ) ;
}
func ( )
{
asrn
rnov
dl, ch
asrn
rnov
ah, 2
asrn
int
21h
Here we have written a function which is not passing any value and does not return any value.
Suppose we want to write a function which passes some value and we want to use these pararmeter
values in asm statement and want to return the value from function, then we will have to do it in some
different way.
In C, when we pass parameters it goes to the stack. It pushes the value of pararmeter instead of address,
and for returning we use assembly instruction RET. It pushes the pararmeter in reverse order.
Let us take a program where we don't pass any parameter-
main( )
{
func () ;
}
func ( )
{
asrn
rnov
d1, 65
asrn
rnov
ah,2
asrn
int
21h
Here we are not passing any parameter, so the func( ) will be set up in stack as-
I
I
~
~2 bytes
~4 bytes·
Small, Compact
Medium, Large, Huge
Here in large, medium and huge return address is of 4 bytes because these memory models can have
more than 1 code segment.

498
Suppose we are passingpararmeters in our function. Let us take an example-
main(.)
{
display( 'x', 'y');
}
display (char
x, char
y)
{
asm
.
121
(Y) 2 bytes
121
(Y) 2 bytes
120
(X) 2 bytes
120
(X) 2 bytes
Return
2 bytes
Return
4 bytes
\1/
Small, Compact
Medium, Large, Huge
C in Depth
We know C pushes the parameters in reverse order(compiler dependent), so first y will be pushed an'
then x will be pushed in stack.( undefined)
Now the question is how to get these parameters from stack t9 use in asm statement. SP is the sta
pointer which points to the current word in stack. We can use Base pointer BP to store the positior:
of SP, so that with the help of BP we can get the parameter value from stack and then it can be us
in our asm statement.
Now we will see how we can write two assembly files with one file having a procedure that will
called in another file. Similar things we will do with other C and assembly files where we will call assemb •
procedure in C program as well as C functions in assembly program. But first we will learn how
link two assembly programs. Let us take a simple program that prints a single string-
CODE SEG SEGMENT
ASSUME CS:CODE &EG, DS:CODE SEG, ES:CODE SEG, SS:CODE SEG
-
\
-
-
-
ORG 100H
START: JMP DISPLAY
STR DB "Suresh Srivastava.$"
DISPLAY PROC NEAR
MOV DX, OFFSET STR
MOV AH, 9
INT 2lH
INT 20H
17.2
Linking Of Two Assembly Files

C and Assembly Interaction
DISPLAY ENDP
END START
499
h
Here our program has procedure to print the string. Let us take another program that calls procedure,
which is used to display the string.
CODE SEG SEGMENT
ASSUME CS:CODE_SEG, DS:CODE_SEG, ES:CODE_SEG, SS:CODE_SEG
ORG lOOH
START: DISPLAY PROC NEAR
CALL SUB DISPLAY
INT 20H
DISPLAY ENDP
SUB_DISPLAY PROC NEAR
JMP GO
ALL_OK D~ "Suresh Srivastava. $"
GO: MOY DX, OFFSET ALL_OK
MOY AH, 9
TNT 21H
RET
SUB DISPLAY ENDP
CODE SEG ENDS
END START
ow think about modular programming. Suppose we w·ant to write all the procedures in different files
and those procedures will be called in the main module. So we will have to link all the files. Let us
take an example program that has two files, one file has procedure which is called in another file.
MAIN.ASM
CODE SEG SEGMENT
ASSUME CS:CODE_SEG, DS:CODE_SEG, ES:CODE_SEG, SS:CODE_SEG
ORG lOOR
START:
DISPLAY PROC NEAR
CALL SUB DISPLAY
INT 20R
DISPLAY ENDP
CODE SEG ENDS
END START

500
EXPROC.ASM
CODE SEG SEGMENT
ASSUME CS:CODE_SEG, DS:CODE_SEG, ES:CODE_SEG, SS:CODE_SEG
SUB DISPLAY PROC NEAR
JMP GO
ALL DK DB "Suresh Srivastava. $"
GO: MOV DX, OFFSET ALL_OK
MOV AH, 9'
INT 21H
RET
SUB DISPLAY ENDP
CODE SEG ENDS
END
C in Depth
We can see here both the files are in code segment. END START and ORG statements are only in
MAIN.ASM. Because it can have only one entry and we want both files one after another in memory.
17.2.1
Memory Models
We have different memory models - tiny, small, medium, compact, huge which set the limit of code
and data area. So we select the memory model depending on our program requirements. Different models
and their limit for code, data and array are as given below-
Code Segment
Data Segment
Array
Tiny
All in same segment
Small
"
< 64 K
< 64 K
< 64 K
Medium
> 64 K
< 64 K
< 64 K
Compact
< 64 K
> 64 K
< 64 K
Large
> 64 K
> 64 K
< 64 K
Huge
> 64 K
> 64 K
> 64 K
17.2.2
C And Segments in Library
We can link .assembly pr~gram with C program only when both of them have same segment narn
C standard hbrary uses dIfferent segment names based on their memory models. To overcome
-
problem, we ha~e simplified segment directive which is supported by turbo C as well as Microsoft C
We have followmg keywords for declaration.
.CODE
code
.DATA
Initialized data
.DATA?
Uninitilized data
.FARDATA
Initialized non-Dgroup data(Compact/Large/Huge)

C and Assembly Interaction
.FARDATA?
Uninitialized non-Dgroup data(compact/Large/Huge)
501
Here we have no need to write like CODE_SEG, when we will use the memory model then correct
segment name will be placed. Let us see a program-
MAIN.ASM
.MODEL SMALL
.CODE
ORG
~OOH
START:
DISPLAY PROC NEAR
CALL SUB DISPLAY
TNT 20H
DISPLAY ENDP
END START
EXPROC.ASM
.MODEL SMALL
.CODE
SUB DISPLAY PROC NEAR
JMP GO
ALL_OK DB "Suresh Srivastava.$"
GO: MOY DX, OFFSET ALL_OK
MOY AH, 9
TNT 21H
RET
SUB DISPLAY ENDP
END
Here model is declared as SMALL, so the segment names will be automatically placed based on memory
model. Here code segment is automatically ended with the end of file. If data 'segment is available then
code segment will end when the data segment starts. We can see that we don't have to worry for
maintaining different segment names, with simplified directive, segment names will be placed based on
memory model. For using segment address, we will have to use w'ith @ prefix eg @code, @data.
~ow we have to link both the files, so procedure will be declared as EXTRN in MATN.ASM and it
will be declared PUBLIC when its definition is available. See the program below -for linking.
YIAIN.ASM
EXTRN SUB DISPLAYNEAR
.MODEL SMALL
L
_

502
.CODE
ORG lOOH
START:
DISPLAY PROC NEAR
CALL SUB DISPLAY
INT 20H
DISPLAY ENDP
END START
EXPROC.ASM
PUBLIC SUB DISPLAY
.MODEL SMALL
.CODE
SUB DISPLAY PROC NEAR
JMP GO
ALL_OK DB "Suresh Srivastava.$"
GO: MOV DX, OFFSET ALL_OK
MOVAH,9
INT 21H
RET
SUB_DISPLAY ENDp·
END
C in Depth
Here we can see that SUB_DISPLAY is declared as PUBLIC in file EXPROC.ASM, so that it can be
called in another file. It is declared as EXTRN in MAIN.ASM, so it can be called in file MAIN.AS
d:\>TASM MAIN.ASM
d:\>TASM EXPROC.ASM
d:\>TLINK MAIN+EXPROC
d:\>EXE2BIN MAIN MAIN.COM
d:\>MAIN
Suresh Srivastava
17.3
Linking Assembly Procedure in C Program.
Now we will see how we can call one assembly procedure in C program. We will write main progran:
in C, which will call assembly procedure from asm program for getting the scan code of any key or
keyboard..
Main.c
extern
int
getscancode (
);
main ( )
{

C and Assembly Interaction
503
printf ("Scan
code
of
pressed
key
=
%x\n", getscancode ( ) ) ;
}
getscancode( ) function will be defined in asm program, so here it will be declared as extern to call
this asm procedure in Cprogram. But this procedure name will be with ( _ ) underscore because. for
,linking procedure in C this will be needed. Let us assume the memory model is small then our stack
will be as-
BP+2
BP
~.
~
Since we are not passing any parameter, so only return value of function will be available in stack frame.
See the asm procedure. below-
GET.ASM
.MODEL SMALL
.CODE
PUBLIC _getscancode
_getscancode PROC
PUSH BP
MOV BP, SP
MOV AH, 0
INT 16H
POPBP
RET
_getscancode ENDP
END
Here this procedure will get the scan code of pressed key and it will return this value. Here procedure
name is in small letters because C is case sensitive and it will search for label in small letters. But assembler
makes all public variables in capital letters, so we should use -mx option of asseinbler, so the same
case of public variable will be used. Now we can link the assembly procedure. with C program as-
d:\>tasm -mx GET.ASM
d:\>tcc Main.c GET.obj
We have seen how to call assembly procedure in C program, but there was no parameter in function.
Now we will see how to pass parameter in C function and how it can be used in assembly procedure.
Suppose we are calling one function ADDNUM in C program as-
MAIN.C
extern
int
ADDNUM (int, int) ;
main ( )
{
int
total, a=5, b=lO;
total=ADDNUM(a,b);

504
printf("Toatl=%d\n",total);
Now we will see how it will be in memory.
5
BP+6
10
BP+4
.Return
BP+2
OldBP
BP
5
BP+8
10
BP+6
Return
OldBP
BP
C in Depth
Small, Compact
Medium, Large, Huge
/
Suppose we are taking small men:lOry model then we can see position of a is BP+6 and that of b is
BP+4 in stack. Now/we can use this in assembly procedure. The assembly procedure for this will be
as-
ADD.ASM
.MODEL SMALL
.CODE
PUBLIC
ADDNUM
ADDNUM PROC '
PUSH BP
MOV BP, SP
MOV AX, [BP+4]
MOV BX, [BP+6]
ADD AX, BX
POP BP
RET
ADDNUMENDP
END
Now we can link assembly procedure with C program as-
d:\>tasm -mx ADDNUM.ASM
d:\> tcc MAIN.c ADDNUM.obj
/

b
Chapter 18
Library functions
18.1
Mathematical Functions
The header file math.h contains declarations for several exponential, logarithmic, trigonometric, hyperbolic,
and other mathematical functions. In all trigonometric functions, angles are taken in radians.
18.1.1
abs()
Declaration: int abs(int x);
It returns the absolute value of the argument. If the argument is positive then it returns the positive
value, if the argument is negative then it negates the value and returns the positive value.
18.1.2
acos()
Declaration: double acos(double x);
This function returns the arc cosine of x i.e. cos·lx. The argument should be in the range -1 to
1 and the return value lies in the range 0 to 7t.
.
18.1.3
asin()
Declaration: double asin(double x);
This function returns the arc sine of x i.e. sin-Ix. The argument should be in the range -1 to 1
and the return value lies in the range -7t12 to 7t/2.
18.1.4
atan()
Declaration: double atan(double x);
This function returns the arc tangent of x i.e. tan-Ix. The argument should be in the range-l to
1 and the return value lies in the range -7t12 to 7t/2.
18.1.5
atan2()
Declaration: double atan2(double y, double x);
This function is used for computing the arc tangent of y/x i.e. tan-I(y/x). The return value lies
in the range -7t to 7t.
18.1.6
cabs()
Declaration: double cabs(struct complex x);
This function returns the absolute value of complex number.

-----------
506
C in Depth
18.1.7
ceil()
Declaration: double ceil(double x);
This function finds the smallest integer not less than x and returns it as a double. For example-
x = 2.4
return value 3.0
x =-2.4
return value -2.0
18.1.8 . COS( )
Declaration: double cos(double x);
This function returns the trigonometric cosine of x. The value of the argument must be in radians
imd return value lies between -1 and 1.
18.1.9
cosh()
Declaration: double cosh(double x);
This function returns the hyperbolic cosine of x.
18.1.10 exp( )
Declaration: double exp(double x);
This function returns the value of e.
18.1.11 fabs()
Declaration: double fabs(double x);
This function is same as abs( ) function but it computes the absolute value of floating point number.
18.1.12 floor( )
Declaration: double f1oor(double x);
.
.
This function finds the largest integer not greater than x and returns it as a double. For example-
x = 2.4
return value 2.0
x = -2.4
return value -3.0
18.1.13 fmod( )
Declaration: double fmod(double x, double y);
It returns the floating remainder of x/yo The sign of the result is the same as that of x. If the
value of y is zero, the result is implementation defined.
x = 7.0, Y = 4.0
return value 3.0
x = 4.6, y = 2.2
return value 0.2
18.1.14 frexp( )
Declaration: double frexp( double arg, int *exptr );
This function splits the first argument into mantissa and exponent such that
arg = mantissa* 2exponent
It returns the value of mantissa whose range is [0.5, 1 ), and the value of exponent is stored'
the variable pointed to by exptr i.e. *exptr gives the value of exponent. If the value of arg is

Library Functions
then the function returns 0 and the value stored in *exptr is also O.
18.1.15 ldexp( )
Declaration: double ldexp( double arg, int exp);
This function is used for obtaining the value of the expression arg * 2exp•
. 18.1.16 loge )
Declaration: double log(double arg);
This function returns the natural logarithm(base e) of argument.
18.1.17 logl0( )
Declaration: double 10glO(double arg);
This function returns the base 10 logarithm of argument.
18.1.18 modf( )
507.
Declaration: double modf(double arg , double *ptr);
This function splits the first argument arg into integer and fractional part. Both parts have the same
sign as argo The fractional part is returned by the function, and the integer part is stored in the
variable pointed to byptr .
18.1.19 pow( )
Declaration: double pow(double x, double y);
This function returns the value of xY,
18.1.20 sine )
1:,' .
Declaration: double sin(double arg);
This function returns the trigonometric sine of the argument, where the argument is in r~ians.
18.1.21sinh( )
Declaration: double sinh(double x);
This function returns the hyperbolic sine of X.
18.1.22 sqrt( )
Declaration: double sqrt(double x);
This function returns the square root of x..
18.1.23 tan( )
Declaration: double tan(double x);
This function returns the trigonometric tangent of X.
18.1.24 tanh( )
DeClaration: double tanh(double x);
This function returns the hyperbolic tangent of X.

508
18.2
Character Type Functions
C in Depth
Header File: ctype.h
18.2.1
isalnum()
Declaration: int isalnum(int arg);
This macro returns a nonzero value if argument is alphanumeric(a...z, A...Z, 0...9), otherwise it"
returns zero.
18.2.2
isalpha()
Declaration: int isaJpha(int arg);
This macro returns a nonzero value if argument is alphabetic(a...z, A...Z ), otherwise it returns
zero.
18.2.3
iscntrl()
Declaration: int iscntrl(int arg);-
The iscntrl( ) returns a non zero value if the argument is a control character, otherwise it returns
zero.
18.2.4
isdigit()
Declaration: int isdigit(int arg);
This macro returns a non zero value if the argument is a digit (0... 9), otherwise it returns zero.
18.2.5
isgraph()
Declaration: int isgraph(int arg);
This macro returns a non zero value if the argument is a graphic character (any printing character
except a space), otherwise it returns zero.
'18.2.6
islower()
Declaration: int _islower(int ,arg);
This macro returns a non zero value if the argument is a lowercase character (a...z), otherwise
it returns zero.
,18.2.7
isprint()
Declaration: int isprint(int arg);
This macroreturns a non zero value if the argument is printable character (including space), otherwise
it returns zero.
18.2.8 ispunct()
Declaration: int ispunct(int arg); ,
This macro returns a nonzero value if the argument is punctuation character, otherwise it returns
zero.
18.2.9
isspace()
Declaration: int isspace(int arg);
This macro returns a nonzero value if the argument is white space character (space, horizont

Library Functions
tab, vertical tab, form feed, new line, carriage return), otherwise it, returns zero.
18.2.10 isupper( )
509
Declaration: int isupper(int arg);
This macro is used to check whether a given character is uppercase character (A....Z) or not.
It returns nonzero if the argument is uppercase character, otherwise it returns zero.
18.2~11 isxdigit( )
Declaration: int isxdigit(int arg); .
This macro is used to check whether a given character is hexadecimal digit(A....F, a....f, 0....9)
or not. It returns nonzero if the argument is hexadecimal digit, otherwise it returns zero.
18.2.12 tolower( }
Declaration: int tolower(int arg);
This macro is used to
con~ert an uppercase character(A .... Z) into equivalent lowercase
character(a....z). It returns lowercase character if the argument is an uppercase character, otherwise
it returns unchanged value.
18.2.13 toupper( )
Declaration: int toupper(int arg);
The macro toupper( ) is used to convert a "lowercase character(a....z) into equivalent uppercase
character(A....Z). It returns uppercase character if the argument is a lowercase character, otherwise
it returns unchanged value.
18.3
.String Manipulation Functions
Header file: string.h
18.3.1
strcat()
Declaration: char *strcat(char *str1, const char *str2);
This function is used to concatenate two strings. The null character from strl is removed and
str2 is concatenated at the end of strl. A pointer to the concatenated strings is returned by the
function.
18.3.2
strchr()
Declaration: char *strchr(const char *str, int ch);
This function returns the pointer to the first occurrence of the character cli in the string str. If
the character is not present in the string then it returns NULL.
#include<stdio.h>
#include<string.h>
main ( )
{
char
*p;
p=strchr("Multinational!', 'n');
printf("%s\nU,p) ;
l
_

510
Output:
national
·18.3.3
strcmp()
Declaration: char *strcmp(const char *strl, const char *str2);
This function is used to compare two strings lexicographically.
strcmp( strl, str2 ) returns a value-
< 0
when strl < str2
= 0
when strl = = str2
> 0
when strl > str2
18.3.4
strcpy()
C in Depth
Declaration: char *strcpy(cha_r *strl, char *str2);
This function copies string str2 to strl, including the null character, and returns a pointer to the
first string.
183.5· strcspn()
Declaration: size_t strcspn(const char *strl, const char *str2)
This function returns the index of the first character of strl, which is matched with any .character
of str2. For example-
strcspn("abcmnop", "lmn");
strcspn("abcmnop", "In");
-strcspn("1234ABCD", "COT");
18.3.6
strlen()
will return 3
will return 4
will return 6
Declaration: size_t strlen(const char *str);
It returns the number. of characters in the string, exduding the null character.
18.3.7
strncat()
Declaration: char *strncat(char *strl, const char *str2, size_t length);
.This function is same as strcat( ) but it concatenates only a portion of a string to another string.
The null character from strl is removed and length characters of str2 are appended at the end
of strl, and at last a null character )s added at the end of strl. This function returns strl.
#include<stdio.h>
/
#include<string.h>
main ( )
{
char
strl[lSJ="ABC";
strncat(strl, "DEFGHIJ",4);
printf ("%s\n" , strl) ;
Output:
ABCDEFG
--'------ ...:

LibrarrFunctions
18.3.8
strncmp()
511
Declaration: int *strncmp(const char *arrl, const char *arr2, size_t length);
Header file: string.h
This function is similar to strcmp( ) but it compares the characters of the strings upto specified
length.
strncmp( strl, str2, len ) returns a value-
< 0
when strt < str2
= 0
when strl= = str2
> o
when strl > str2
#include<stdio.h>
#include<string.h>
main ( ) .
{
int
l,m,n,p;
1=strncmp("Deepali","Deepanjali",4);
m=s~rncmp("Deepali","Deepanjali",6);
n=strncmp("Suresh","Sur~iya"i3);
p=strncmp("Suresh","Suraiya",5) ;
printf("%d\t%d\t%d\t%d\n",l,m,n,p);
Output:
o
18.3.9
-2
0
strncpy( )
4
Declaration: int *strncpy(char *strl, const char *str2, size_t length);
It is same as strcpy( ) but it copies the characters of the string to the specified length. Here str2
should be a null terminated string and strl should be an array.
If str2 has more than length characters, then strl might not be null terminated.
If str2 has less than length characters, then null characters will be added to strl at the end, till
the specified length of characters have been copied.
#include<stdio.h>
#include<string.h>
main ( )
{
char
str1 (10) ;
strncpy(str1,"Departmental",6) ;
str1(6)='\0' ;
printf("%s\n",str1);
Output:
Depart

--------
512
C in Depth
18.3.10 strpbrk( )
Declaration: char *strpbrk(const char *strl, const char *str2);
This function returns the pointer to first character of string strl, which matches with any character
.of str2. It returns NULL if there are no common characters in the two strings.
#include<stdio.h>
'
#include<stririg.h>
main ( )
{
char
*pl, *p2, *p3 'j
pl=strpbrk("abcmnop","lmn")j
p2=strpbrk("abcmnop". "In")
j
p3=strp~rk("1234ABCD","COT")
j
printf("%s\t%s~t%s\n",pl.p2.p3)j
Output:
mnop
nop
CD
18.3.11 strrchr( )
Declaration: char *strrchr(const char *str, int ch);
This function returns a pointer to the last occurrence of the character ch in the string point
to by str, otherwise it returns NULL.
#include<stdio.h>
#include<string.h>
main ( )
{
char
*p;
p=strrchr("Multinational", 'n');
print f ( "%s\ n" •p)
j
Output:
nal
18.3.12 strspn( )
Declaration: size_t strspn(const char *strl, const char *str2);
This function returns the index ofthe first character of strl, which does not match with any char
from str2. For example-
.
(
strspn("cindepth", "datastructure")
will return 1
strspn("abcdefghijk", "completedatabase")
will return 5
strspn("1234ABCD", "AB12")
will return 2
18.3.13 strstr( )
Declaration: char*strstr(const char *arrl, const char *arr2);
, .
This function is used to locate the first occurrence of a s'ubstring in another string. The se

Library Functions
513
argument is a pointer to the substring and the first argument is a pointer to the string in which
the substring is to be searched. This function returns a pointer to _the beginning of the first
occurrence of the substring in another string. If the substring is not present then it returns NULL.
#include<stdio.h>
#include<string.h>
maLl ( )
char
*ptr;
ptr=strstr("placementsection","cement") ;
printf("%s",ptr);
Output:
cement section
18A
18.4.1
Input/Output Functions
access( )
Declaration: int access( constchar *fname, int mode );
Head(!r file: io.h
This function is used to see the existence.of file. It also checks the type of file. The possible
values oJ mode are as given below-
mode
value
0
existence of file
1
executable file
2
write access
4
read access
6
read/write access
18.4.2chmod( )
Declaration:- int chmod( const char *fname, int mode );
Header file: io.h
This function is used for changing the access mode of the file to the value of the mode. These
modes are as given below-
mode'
meaning
S lREAD
read access
S WRITE
write access
S_IREAD I S_IWRITE
read and write access

514
C in Depth
18.4.3
clearerr()
Declaration: void clearerr( FILE *stream );
Header file: stdio.h
This function is used to set the end of file and error indicators to O.
18.4.4
close()
Declaration: int close( int fd );
Header file: io.h
This function is called with a file descriptor which is created with a successful call to open( )
or create ). It closes the file and flushes the write buffer. It returns zero on success otherwise
it returns -1.
18.4.5
creat()
Declaration: int create const char *fname, int pmode );
Header file: io.h
This function creates a new file for writing. The file descriptor returns a positive value on,suc~ess
otherwise it returns -1. The permission mode determines the file access setting. The values 0
pmode are as:
permission mode
meaning
S IREAD
read only
S IWRITE
write only
18.4.6
fclose()
Declaration: int fclose( FILE *fptr );
Header file: stdio.h
This function is used to close a file that was opened by fopen( ). It returns EOF on error an
o on success.
18.4.7
feof()
Declaration: int feof( FILE *fptr );
Header file: stdio.h
The macro feof( ) is used to check the end of file condition. It returns a nonzero value if e
of file has been reached otherwise it returns zero.
18.4.8
ferror()
Declaration: int ferror( FILE *fptr );
Header file: stdio.h
The macro ferror( ) is used for detecting any error occurred during read or write operations
a file. It returns a nonzero value if an error occurs i.e. if the error indicator for that file is
otherwise it returns zero.

Library Functions
51S
18.4.9
fflush()
Declaration: int fflush( FILE *fptr );
Header file: stdio.h
This function writes any buffered unwritten output to the file associated with fptr. On success
it returns 0 and on error it returns EOF.
18.4.10
fgetc()
Declaration: int fgetc( FILE *fptr );
Header file: stdio.h
This function· reads a single character from a given file and increments the file pointer position.
On success it returns the character after converting it to an int without sign extension. On end
of file or error it returns EOF.
.
18.4.11 fgets( )
Declaration: char fgets( char *str, int n, FILE *fptr );
Header file: stdio.h
This function is used to read characters from a file and these characters are stored in·the string
pointed to by str. It reads at most
n~1 characters from the file where n is the second argument.
fptr is a file pointer which points to the file from which characters are read. This function returns
the string pointed to by str on success, and on error or end of file it returns NULL.
18.4.12 fileno( )
Declaration: int fileno( FILE *stream );
Header file: stdio.h
The function fileno( ) is used for returning the file descriptor of the specified file pointer.
18.4.13 fopen( )
Declaration: FILE *fopen( const char *fname, corist char *mode );
Header file: stdio.h
The function fopen( ) is used to open a file. It takes two strings as arguments, the first one is
the name of the file to be opened and the second one is the mode that decides which operations(
read, write, append etc) are to be performed on the file. On success, fopen( ) returns a pointer
of type FILE and on error it returns NULL.
18.4.14 fprintf( )
Declaration: fprintf ( FILE *fptr, constchar *format [, argument, ... ] );
Header file: stdio.h
This function is same as the printf( ) function but it writes formatted data into the file instead
of the standard output. This function has same parameters as in printf( ) but it has one additional
parameter which is a pointer of FILE type, that points to the file to which the output is to be
written. It returns the number of characters output to the file on success, and EOF on e!ror.

516
C in Depth
18.4.15 fputc( )
Declaration: int fputc( int ch, FILE *fptr );
Header file : stdio.h
This function writes a character to the specified file at the current file position and then increments
the file position pointer. On success it returns an integer representing the character written, and
on error it returns EOP.
18.4.16 fputs( )
Declaration: int fputs( const char *str, FILE*fptr );
Header file: stdio.h
This function writes the null terminated string pointed to by str to a file. The null character that
marks the end of string is I}ot written to the file. On success it returns the last character written
and on error it returns EOF.
18.4.17 fread( )
Declar~tion: size_t fread( void *ptr, size_t size, size_t n, FILE *fptr );
Header file: stdio.h
This function is used to read an entire block from ,a given file. Here ptr is a pointer which points
to the block of memory which receives the data read from the file, size is the length of each item
in bytes, n is the number of items to be read from the file and fptr is a file pointer which points
to the file from which data is read. On. success it reads n items from the file and returns n, if
error.or end of file occurs then it returns -a -value -less than n.
18.4.18. fputchar( )
Declaration: int fputchar( int arg ).;
Header file: stdio.h
This function is used for writing' a character to standard output.
1~.4.19 fscanf( )
Declaration: fscanf ( FILE *fptr, const char *format [, address, ... ] );
Header file: stdio.h
This function is similar to the scanf ( ) function but it reads data from file instead of standard
input, so it has 'one more parameter which is a pointer of FILE type and it points to the file from
which data will be read. It returns the number of arguments that were assigned some values on
success, and EOF at the end of file.
18.4.20
fseek()
Declaration: int fseek( FILE *fp , long disp, int position);
Header file: stdio.h
This function is used for setting the file position pointer at the specified byte. Here fp is a file
pointer, displacement is a long integer which can be positive or negative and it denotes the number
of bytes which are skipped backward ( if negative) or forward ( if positive) from the positio
specified in the third argument. The third argument can take one of these three values.

Library Functions
Constant
Value
Position
SEEK SET
0
Beginning of file
SEEK_CURRENT
1
Current position
SEEK END
2
End of file
18.4.21 fstat( ).
517
Declaration: int fstat( int fd, struct stat *finfo );
Header file: sys/stat.h
This function is used for filling thtl file infonnation in structure finfo. The structure of finfo is
same as stat which is defined in sys/stat.b,
18.4.22 ftell( )
Declaration: int fputs( FILE *stream );
Header file: stdio.h
This function returns the current position of the file position pointer. The value is counted from
the beginning of the file.
18.4.23 isatty( )
Declaration: int isatty( int handle);
Header file: io.h
This function is used for checking whether the handle is associated with character device or not.
The character device may be a tenninal, console, printer or serial port. It returns nonzero on success,
otherwise it returns zero.
18.4.24 open( )
Declaration: int open( const char *fname, int access, unsigned mode );
Header file: io.h
This function is used for opening a file. The access is the base mode with modifier. modifier is
taken by applying OR operator with base mode.
Base mode
Meaning
O_WRONLY
write only
o RDONLY
read only
o RDWR
read / write
Modifiers
Meaning
o APPEND
For appending
o BINARY
binary file
o CREAT
creates the file, if the file
doesn't exist and sets the
attribute with mode

518
o EXCL
o NDELAY
o TEXT
O_TRUNC
when it is used with 0_CREAT
it doesn't create file, if the
file already exists.
Unix compatible
text file
Truncates to
~ength 0 if file doesn't exist
C in Depth
.~
The parameter mode is used with only 0_CREAT modifier.
Mode
Meaning
S_IREAD
Read
S IWRITE
Write
S_READ / S_IWRITE
Read / Write
18.4.25 read( )
Declaration: int read( int fd, void *arr, unsigned num );
Header file: io.h
This function is used for reading the
files~ Here fd is the file descriptor, num is the number of
bytes read from the file and arr points to the array which has the number of bytes. read from
file. The file pointer position is incremented by the number of bytes read from file. If end of file
occurs then number of bytes read will be smaller than num.
18.4.26 remove( )
Declaration: int remove( const char *fname );
Header file: stdio.h
This function is used for deleting the file. It returns 0 on success and -1 on error.
18.4.27 rename( )
Declaration: int rename( const char *old, const char *new )
Header file: stdio.h
This function is used to rename a file. We can give full path also in the argument, but the drives
should be the same although directories may differ. On success it returns 0 and on error it returns
-1.
.'
18.4.28 setbuf( )
Declaration: void setbuf( FILE *fptr, char *buffer );
Header file: stdio.h
The function setbuf( ) specifies the buffer that will be used by a file. The size of the buffer should
be BUFSIZ bytes, which is defined irt stdio.h. If setbuf( ) is called with null, then the I/O will
be unbuffered.

Library Functions
18.4.29 sopen( )
519
Declaration: int sopen( const char *fname, int access, int shmode, int mode)
Header file: io.h
.The macro sopen( ) is used for opening a file in shared mode. This is used in network environment.
The access is the base mode with modifier. Modifier is taken by applying OR operator with base
mode.
Base mode
Meaning
o WRONLY
write only
o RDONLY
read only
o RDWR
read / write
Modifiers
Meaning
o APPENn
For appending
o BINARY
binary file
O_C~AT
creates the file, if the file
doesn't exist and sets the
attributes with' mode
O_EXCL
when it is used with 0 CREAT
-
it doesn't create file, if the
file already exists.
o NDELAY
o TEXT
text file
O_TRUNC
shmode is the share mode with the file. These are-
.
shmode
Meaning
SH COMPACT
Compatibility mode
SH DENYRD
Not allowed for read
SH DENYWR
Not allowed for write
SH DENYRW
Not allowed for read ! write
SH_DENYNO
Allowed for read / write
SH_DENYNONE
Allowed for read / write
'....
The parameter mode is used with only 0_CREAT modifier: The modes arr-

520
18.4.30 stat( )
Base mode
Meaning
S IREAD
Read
S_IWRITE
Write
S READ / S IWRITE
Read / Write
-
-
C in Depth
Declaration: int state char *fname, struct stat *finfo );
Header me: sys\stat.h
This function is used for filling the file information in structure finfo. The structure of finfo is
same as stat which is defined in sys\stat.h.
18.4.31 sprintf( )
Declaration: int sprintf (char *str,const char *controlstring [, argl, arg2,
] );
Header file: stdio.h
This function is same as printf ( ) function except that instead of sending the formatted output·
to the screen, it stores the formatted output in a string. This funct,ion returns the number of
characters output to the string excluding the null character and on failure it returns EOF.
18.4.32 sscanf( )
Declaration: int sscanf (const char *str, const char *controlstring [, addressl, address2,......] );
Header file: stdio.h
This function is same as the scanf ( ) function except that data is read from a string rather than
the
stan~ard input. We can read the formatted text from a string and convert it into variables of
different data types.-
18.4.33 tell( )
Declaration: long tell( int fd )
Header file: io.h
This is same as ftell( ). It is used for getting the current file pointer position.
18.4.34 tmpfile( )
Declaration: FILE *tmpfile( void)
Header file: stdio.h
tmpfile( ) creates a temporary binary file and opens it in update mode(wb+). On success it returns
a pointer of type FILE that points to the temporary file and on error it returns NULL. The file
created by tmpfile( ) is temporary because it is automatically deleted when closed or when the
program terminates.
18.4.35 tmpnam()
char *tmpnam( char *arr )
Header file: stdio.h
This function is used for generating a unique file name. The number of different file naines that

Library Functions
521
can be generated by tmpnam() during the execution of program is specified by TMP_MAX, which
is defined in stdio.h file. This file name is stored in the array, which is pointed to by an.
18.4.36 unlink( )
Declaration: int unlink( const char *fname )
Header file: stdio.h
This function is used tor deleting a file from the directory. We can give full pathname also as the
argument. The file should be closed before deleting. On success it returns 0 and on error it returns
-1 and errno is set to one of these values:
ENOENT
EACCES
Path or file name not found
Permission denied
<-.

·
Appendix A
-
fiSCIl Characters
ASCII value
Character
ASCII value
Character
ASCII value
Character
000
NUL
049
1
098
b
001
SOH
050
2
099
c
002
STX
051
3
100
d
-
003
ETX
052
4
101
e
004
EOT
053
5
102
f
005
ENQ
054
6
103
g
006
ACK
055
7
104
h
007
BEL
056
8
105
i
008
BS
057
9
106
j
009
HT
058
107
k
010
LF
059
,
108
1
011
VT
060
<
109
m
012
FF
061
=
110
n
013
CR
062
>
111
0
014
SO
063
?
112
P
015
SI
064
@
113
q'"
016
DLE
065
A
114
r
'017
DC1
066
B
115
- s
018
DC2
067
C
116
t
019
DC3
068
D
117
u
020
DC4
069
E
118
v
021
NAK
070
F
119
w
022
SYN
071
G
120
x
023
ETB
072
H
121
y
024
CAN
073
I
122
z
025
EM
074
J
123
{
026
SUB
075
K
124
I
\
027
ESC
076
L·
125
}
028
FS
077
M
126
~
029
GS
078
N
127
DEL
030
RS
079
0
031
US
080
P
032
blank
081
Q
",,033
.!
082
I
R
"
~
-,
j

lue
I
Character
b
c
d
e
f
g
h
1
J
k
I
m
n
0
p
q
r
s
t
u
v
w
x
y
z
{
I
}
~
DEL
ASCII Characters
ASCII value
Character
ASCII value
Charact
034
"
083
S
035
#
084
T
036
$
085
U
037
%
086
V
038
&
087
W
039
,
088
X
040
(
089
y
041
)
090
Z
042
*
091
[
043
+
092
\
044
,
093
]
045
-
094
1\
04.6
095
-
047
/
-
096
,
048
0
097
a
* Characters
from 1 - 32 and character 127 are control cha
".,

Precedence and Associativity c
Appendix B
Onerator
( )
[ ]
-7
+
++
*&
(datatype)
sizeof
*
%
+
«
»
<
<=
>
>=
!=
&
/\
&&
I I
?
:
Descrintion
Function call
Array subscript
Arrow operator
Dot operator
Unary plus
Unary minus,
Increment
Decrement
Logical NOT
One's complement
Indirection
Address
Type cast
Size in bytes
Multiplication
Division
Modulus
Addition
Subtraction
Left shift
Right shift
Less than
Less than or equal to
Greater than
Greater than or eoual to
Equal to
Not equal to
Bitwise AND
Bitwise XOR
Bitwise OR
Logical AND
Logical OR
Conditional operator
Precedenci
2
3
4
5
6
7
8
9
10
11
12
13

D
.' Precedence and Associativity of Operators
-
*=
/=
%=
+= -=&
Assignment operators
14
Right to Left
=
1\ =
1=«= »=
,
Comma operator
15
Left to Right

Appendix C
Conversion Specifications
%c
- a single character
%d
- a decimal integer
%f
- a floating point number
%e
- a floating point number
%g
- a floating point number
%If
- long range of floating po\nt number( for double data type)
%h
- a. short integer
%0
- an octal integer
%x
- ahexadecimal integer
%i
- a decimal, octal or hexadecimal integer
%s
- a string
%u
- an unsigned decimal integer
The modifier h can be used before conversion specifications d, i, 0, u, x to specify short.integer and
the modifier 1 can be used before them to specify a long integer.
The modifier 1 can be used before conversion specifications f,e,g to specify double while modifier L
can be used before them to specify a long double.

..

528
C in Depth
9
OA39
0A28
8000
0
OB30
OB2~
8100
-
OC2D
OC5F
OCIF
8200
=
OD3D
OD2E
8300
I
lAlB
lAOO
[
lASB
lAm
]
lB5D
IB7D
lBlD
lBOO
,
273B
273A
2700
,
2827
2822 .
,
2960
297E
I
\
2B5C
·2B7C
2BlC
2600
(same as Alt L)
,
332C
333C
342E
. 343E
/
352F
353F
Fl
3BOO
5400
5EOO
6800
F2
3COO
5500
5FOO
6900
F3
3DOO
5600
6000
6AOO
F4
3EOO
5700
6100
6BOO
F5
3FOO
5800
6200
6COO
F6
4000
5900
6300
6DOO
F7
4100
5AOO
6400
6EOO
F8
4200
5BOO
6500
6FOO
F9
4300
5COO
6600
7000
FlO
4400
5DOO
6700
7100
Fll
8500
8700
8900
8BOO
F12-
8600
8800
8AOO
8COO
BackSpace
OE08
OE08
OE7F
OEOO
Del
5300
532E
9300
A300
~
Down Arrow
5000
.
5032
9100
AOOO
End
4FOO
4F3l
7500
9FOO
Enter
lCOD
lCOD
lCOA
A600
Esc
OllB
OllB
OllB
0100
Home
4700
4737
7700
9700
Ins
5200
5230
9200
A200
.Keypad 5
4C35
8FOO
Keypad *
372A
9600
3700
Keypad -
4A2D
4A2D
8EOO
4AOO
Keypad +
4E2B
4E2B
4EOO
Keypad /
352F
352F
9500
A400
LeftArrow
4BOO
4B34
7300'
9BOO
PgDn
5100
5133
7600
A100
PgUp
4900
,
4939
8400
9900
PrtSc
7200
RightArrow
4DOO
4D36
74do
9DOO
SpaceBar
3920
3920
3920·
3920
Tab
OF09
OFOO
9400
A500
Up AlTOW
4800
4838
8DOO
9800
-
,

!,40
#defme, 378
#else and #elif, 390
#error, 399.
#if And #endif, 390
#ifdef and #ifndef, 393
#line,399
#pragma, 400
#Undef,387
& ,408
&&,39
1\,409
1. 408
11,40
-,410
«,411
»,411
A
abs( ), 505
access( ), 519
acos( ),505
actual arguments, 118
address operator, 197
AND (&&) Operator, 39
argc,367
argv[],367
arithmetic operators, 32
binary arithmetic operators, 32
unary arithmetic operators, 32
arrays, 158
arrays and functions, 165, 174
more than two dimensions, 173
one dimensional array, 158
two dimensional array, 167
asin( ), 505
assembly and C interaction, 495
inline assembly language, 495
linking of two assembly Files, 498
Index
linking assembly procedure in C Program, 5
assignment operators, 35
associativity of operators, 47.
atan(),505
atan2( ), 505
automatic type conversion, 44
automatic, 437
B
binary search, 176
bit fields, 426
bitwise operators, 407
bitwise AND ( & ), 408
bitwise left shift ( «
), 411
bitwise OR ( I), 408
bitwise right shift ( »
), 411
bitwise XOR ( 1\ ), 409
one's complement (-),410
break statement, 78
bubble sort, 181
buffer, 335
c
C character set, 7
cabs(),505
calloc(),233
ceil( ),506
character I/O, 339
character type functions, 508
characteristics of C, 4
chmod( ), 513
clearerr(), 364, 514
close( ), 514
code optimization, 487
comma operator, 42
command line arguments, 367
comments, 16
compilation of C programs, 457
compound statement or block, 58

lI
I,f·
I
r
530
conditional compilation, 389
conditional operator, 41
const, 447
constants, 10
.character constants, 13
numeric constants, 11
. string constants, 13
symbolic constants, 13
continue statement, 80
control statements, 58
conversion specifications, 17
cos( ),506
cosh( ), 506
creat( ), 514
n
data types, 10
delimiters, 9
design methods, 1
bottom-up design, 2
modular approach, 2
top-down design, 1
do...while loop, 69
dynamic memory allocation, 231
E
enumeration, 433
environment for C, 5
MS-DOS Environment, 5
Unix Environment, 5
escape sequences, 8
evaluation of operands, 53
execution characters, 8
exp(),506
expressions, 15
external,439
F
fabs(),506
fclose( ), 514
feof(),362,514
ferror( ), 363,514
fflush( ), 366,515
fgetc( ), 340,515
fgets( ), 342;515
fileno( ), 515
files, 334
C in Depth
block read I write, 345
character 110, 339
closing a file, 337
end of file, 338
formatted 110, 343
integer 110, 341
opening a file, 335
other file functions, 362
predefined file pointers, 339
random access to file, 348
string 110, 342
structure of a general file program, 338
text and binary modes, 334
floating-point arithmetic, 34
floor( ), 506
fmod(),506
fopen(),515
for loop, 71
formatted input and output, 24
floating point numeric input, 26
floating point numeric output, 27
format for integer input, 24
format for integer output, 25
format for string input, 27
format for string output, 28
fprintf(),343,515
fputc (), 339,516
fputchar( ), 516
fputs( ), 342,516
fread(),347,516
free(),234
freopen( ), 367
frexp( ), 506
fscanf(),344,516
fseek (), 349,516
fstat( ), 517
ftell(),350,517
functions,ll0
advantages, 110·
library functions, 110
user-defined functions, 111
d.efmition, 112
call, 113
declaration, 114,124, 126
arguments, 118, 125
types, 120
variable number of arguments, 450
fwrite( ), 345

•
Index
G
getc( ) and putc( ), 340
getchar( ), 29
getw(),341
global Variables, 131
goto, 82
H
high level languages, 3
history of C, 3
I
identifiers, 9
if. ..else, 59
Nesting ofif...else, 61
else if Ladder, 63
including files, 389
increment and decrement operators, 35
postfix increment / decrement, 36
.prefix increment / decrement, 36
input/output functions, 513
insertion sort, 184
integer arithmetic, 33
isalnum( ), 508
isalpha( ), 508
isatty( ), 517
iscntrl( ), 508
isdigit( ), 508
isgraph( ), 508
islower( ), 508
isprint( ), 508
ispunct( ), 508
isspace( ), 508
isupper( ); 509
isxdigit( ), 509
K
keywords, 9
L
ldexp( ), 507
library creation, 484
creation of library in turbo C, 482
creation of library in Unix, 486
library functions, 110, 126
linkage, 445
linked list, 309
creation oflist, 314
deletion from a linked list, 313
deletion of a node in between, 314
deletion of first node, 313
insertion in between or at the
end,~ 312
insertion in the beginning, 312
insertion into a linked list, 311
reversing a linked list, 318
searching in a linked list, 311
traversing a linked list, 311
local variables, 130
log(),507
logl0( ), 507
logical or boolean operators, 39
AND ( &&) operator, 39
OR ( II ) operator, 40
NOT ( ! ) operator, 40
loops, 65
while loop, 65
do...while loop, 69
for loop, 71
Nesting Of Loops, 75
Infinite Loops, 77
Ivalue, 456
M
macros, 379
generic functions, 386
macros vs functions, 385
nesting in macros, 381
predefined macro names, 398
problems with macros, 382
magic matrix, 188
inain( ) function, 125
maHoc( ), 231
masking, 413
masking using bitwise AND, 413
masking using bitwise OR, 415
masking using bitwise XOR, 415
switching off bits using Bitwise AND
1 an
Complement Operator, 416 '
memory during program execution, 445
memory models, 500
.
memory, 196
merging of arrays, 185
mixed mode arithmetic, 34
modf(),507
53

532
N
NOT ( ! ) Operator, 40
null directive, 400
numeric constant, 11
o
one dimensional array, 158
open( ), 517
OR ( II) Operator, 40
p
pascal triangle, 187
perror( ), 364
pointers, 196
array of pointers, 227
function returning pointer, 222.
pointer arithmetic, 201
pointer comparisons, 206
pointer to an array, 212
pointer to pointer, 206
pointers and functions, 219
pointers and one dimensional arrays, 208
pointers and three dimensional arrays, 217
pointers and two dimensional arrays, 213
pointers to functions, 238
I
poiilters varili'bles, 197
subscripting pointer to an array, 216
subscripting pointer variables, 211
pow(),507
precedence of operators, 47
preprocessor, 377
prograpuning languages, 2
high-level languages, 3
low level languages, 2
project Jmilding, 464
building project in'turbo C, 481
'building project on unix, 483
coding, 468
detail design, 465
requirement analysis, 464
testing, 481
top level design, ~65
putchar( ), 29
putw ( ), 341
R
read( ), 518
C in Depth
realloc( ), 233
recursion, 132
tower of hanoi, 136
advantages and disadvantages of recursion, 139
local variables in recursion, 139
register, 444
relational operators, 37
remove(),365,518
rename( ), 364,518
---reserved words, 9
retutn statement, 116
rewind( ), 351
rvalue, 456
s
selection sort, 180
self refe!ential structures, 309
setbuf( ), 518
. sin(), 507
sinh( ),507
sizeo~operator, 43 .
spiral tpatrix, 189
sprint£{ ), 272,520
sqrt(),507
sscanf( ), 273,520
, state ), 520
statements, 15
static Variables, 132,442
storage classes in functions, 445
storage classes, 437
strcat( ), 261,509
strchr( ), 509
strcmp( ), 258,510
strcpy( ), 259,510
strcspn( ), 510
string manipulation functions, 509
stringizing operator ( # ), 387
strings, 175, 253
array of pointers to strings, 267
array of strings or two dimensional array of
characters, 264
string constant or string literal, 253
string library functions, 257
string pointers, 262
string variables, 255
strien( ), 257,510
strncat( ), 510 .
strncmp( ), 511
strncpy( ), 511

index
strpbrk(),512
strrchr( ), 512
strspn( ), 512
strstr(),512
structure, 288
accessing, members of a structure, 291
array of structures, 293
arrays within structures, .295
assignment of structure variables, 292
declaring structure variables, 289
defining a structure, 288
initialization of structure variables. 290
nested structures, 296
pointers to structures, 298
pointers within structures, 299'
size of structure, 293
storage of structures in memory, 292
structures and functions, 299
suppression character in scanf( ), 28
switch, 84.
T
tan(),507
tanh(),507
tell( ), 520
tffipfile( ), 366,522
/
tm¥nam( ), 366,520
tOKen pasting operator( ## ), 388
tolower( ), 509
toupper( ), 509
translators, 3
trigraph characters, 8
two dimensional array, 167
type conversion, 44
implicit type conversions, 44
automatic conversions, 44
type conversion in assignment, 45
explicit type conversion, 46
typedef, 326
u
union, 321
unlink( ), 365,521
user-defined functions, 111
v
va_arg,450
va_end, 450
va_list, 450
va_start, 450
variable number of arguments, ~50
variables, 14
declaration of variables, 14
initialisation of variables, 14
vfprintf( ), 455
void pointers, 229
volatile, 449
vprintf( ), 455
vsprintf( ), 455
w
while loop, 6,5
,
I

The book explains each topic in depth without compromising over the lucidity_ofthe text and
programs. This approach makes this book suitable for both novices arid advanced
programmers. The well -_strnctHred programs are easily understandable by the beginners and
---
.
useful for the experienced programmers. The book contains about 300 programs, 210
exercises and 80 programming exercises with solutions of exercises and hints to solve
programming exercises. Five new chapters ~ave been included in this edition ofthe book. The
chapter on project development and library creation can help students in implementingJileir
knowledge andbecome aperfect C programmer.
~
ABOIFf THE AUTHOR
Suresh ~umar Srivastava has beeg working in software industry for last 7'years. He has done
B level [rem DOE~ACC Society. He has worked on development of device driver"debugger
.
/
and syskm software area.tIe likes to work on system side as well as some creative work for
,I
.
.
develQ13ment of software tools. He has authored a book on Data· Structures titled" Data
Stnfctures through C in Depth". He is planning to write some more books on different topics,
which can be useful for students to work in system software development.
'
Deep'C'Ji Srivastava has done MSc. In Mathematics and Advanced PGDCA from MJP
Rohilkhand University. Her areas ofinterest are C and Data Structures. She also likes to lea~
and'work on systems' software. She has authored a book OIl Data structures titled "D;ta
Structures thtough C in Bepth". ~b-e Is-plaJllling to work on some other topics and use her
creativity in system software development.
www.bpbonline.com
~-
---
ISBN 81-8333-048-7
1"", HOm
IRs. 360/-1
/---------

