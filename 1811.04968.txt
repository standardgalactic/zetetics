PennyLane: Automatic differentiation of hybrid quantum-
classical computations
Ville Bergholm,1 Josh Izaac,1 Maria Schuld,1 Christian Gogolin,1 Shahnawaz Ahmed,2 Vishnu Ajith,3 M. Sohaib Alam,4, 5
Guillermo Alonso-Linaje,1 B. AkashNarayanan, Ali Asadi,1 Juan Miguel Arrazola,1 Utkarsh Azad,1 Sam Banning,1 Carsten
Blank,6 Thomas R Bromley,1 Benjamin A. Cordier,7 Jack Ceroni,1 Alain Delgado,1 Olivia Di Matteo,1, 8 Amintor Dusko,1
Tanya Garg,9 Diego Guala,1 Anthony Hayes,1 Ryan Hill,10 Aroosa Ijaz,1 Theodor Isacsson,1 David Ittah,1 Soran Jahangiri,1
Prateek Jain,11 Edward Jiang,1 Ankit Khandelwal,12 Korbinian Kottmann,13 Robert A. Lang,14 Christina Lee,1 Thomas
Loke,15 Angus Lowe,1 Keri McKiernan,16 Johannes Jakob Meyer,17 J. A. Montañez-Barrera,18 Romain Moyard,1 Zeyue Niu,1
Lee James O’Riordan,1 Steven Oud,19 Ashish Panigrahi,20 Chae-Yeun Park,1 Daniel Polatajko,21 Nicolás Quesada,1 Chase
Roberts,1 Nahum Sá,22 Isidor Schoch,23 Borun Shi,24 Shuli Shu,1 Sukin Sim,25 Arshpreet Singh,26 Ingrid Strandberg,27
Jay Soni,1 Antal Száva,1 Slimane Thabet,28, 29 Rodrigo A. Vargas-Hernández,14, 30 Trevor Vincent,1 Nicola Vitucci, Maurice
Weber,31 David Wierichs,32 Roeland Wiersema,30, 33 Moritz Willmann, Vincent Wong,34 Shaoming Zhang,35, 36 and Nathan
Killoran1
1Xanadu, 777 Bay Street, Toronto, Canada
2Wallenberg Centre for Quantum Technology, Department of Microtechnology and Nanoscience, Chalmers University of Technology, 412 96 Gothenburg,
Sweden
3Indian Institute of Information Technology, Kottayam
4Quantum Artiﬁcial Intelligence Laboratory (QuAIL), NASA Ames Research Center, Moffett Field, CA, 94035, USA
5USRA Research Institute for Advanced Computer Science (RIACS), Mountain View, CA, 94043, USA
6data cybernetics, Martin-Kolmsperger-Str 26, 86899 Landsberg, Germany
7Department of Medical Informatics and Clinical Epidemiology, Oregon Health and Science University, Portland, OR 97202, USA
8Dept. of Electrical and Computer Engineering, The University of British Columbia, Vancouver, BC, V6T 1Z4, Canada
9Department of Physics, Indian Institute of Technology Roorkee, Roorkee, Uttarakhand, India
10qBraid, 5235 South Harper Court, Chicago, IL 60615
11Factal Analytics, Level 2 Chimes Building Plot 61, Sector - 44, Gurgaon 122003, Haryana, India
12Centre for High Energy Physics, Indian Institute of Science, Bengaluru, Karnataka, India 560012
13ICFO - Institut de Ciencies Fotoniques, The Barcelona Institute of Science and Technology, Av. Carl Friedrich Gauss 3, 08860 Castelldefels (Barcelona),
Spain
14Chemical Physics Theory Group, Department of Chemistry, University of Toronto, Canada
15DUG Technology, 76 Kings Park Rd, West Perth WA 6005 Australia
16Rigetti Computing, 2919 Seventh Street, Berkeley, CA 94710
17Dahlem Center for Complex Quantum Systems, Freie Universität Berlin, 14195 Berlin, Germany
18Institute for Advanced Simulation, Jülich Supercomputing Centre, Forschungszentrum Jülich, 52425 Jülich, Germany
19University of Amsterdam
20School of Physical Sciences, National Institute of Science Education and Research, HBNI, Jatni, 752 050 Odisha, India
21Cervest
22Centro Brasileiro de Pesquisas Físicas, Rua Dr. Xavier Sigaud 150, 22290-180 Rio de Janeiro, Brazil
23ETH Zurich, Quantum Engineering, Department of Information Technology and Electrical Engineering (D-ITET), 8092 Zurich, Switzerland.
24Neo4j UK Ltd.
25Zapata Computing, Inc.
26ITC Infotech Bangalore
27Department of Microtechnology and Nanoscience MC2, Chalmers University of Technology, SE-412 96 G öteborg, Sweden
28Pasqal, 7 rue Léonard de Vinci, 91300 Massy, France
29LIP6, CNRS, Sorbonne Université, 4 place Jussieu, 75005 Paris, France
30Vector Institute, MaRS Centre, Toronto, Ontario, M5G 1M1, Canada
31ETH Zürich, Department of Computer Science, 8092 Zïrich, Switzerland.
32Institute for Theoretical Physics, University of Cologne, Germany
33Department of Physics and Astronomy, University of Waterloo, Ontario, N2L 3G1, Canada
34TRIUMF, Vancouver, BC, Canada V6T 2A3
35Technical University of Munich, Department of Informatics, Boltzmannstraße 3, 85748 Garching, Germany
36BMW Group, Munich, Germany
PennyLane is a Python 3 software framework for differentiable programming of quantum computers. The library provides a
uniﬁed architecture for near-term quantum computing devices, supporting both qubit and continuous-variable paradigms.
PennyLane’s core feature is the ability to compute gradients of variational quantum circuits in a way that is compatible with
classical techniques such as backpropagation. PennyLane thus extends the automatic differentiation algorithms common in
optimization and machine learning to include quantum and hybrid computations. A plugin system makes the framework
compatible with any gate-based quantum simulator or hardware. We provide plugins for hardware providers including
the Xanadu Cloud, Amazon Braket, and IBM Quantum, allowing PennyLane optimizations to be run on publicly accessible
arXiv:1811.04968v4  [quant-ph]  29 Jul 2022

2
quantum devices. On the classical front, PennyLane interfaces with accelerated machine learning libraries such as Ten-
sorFlow, PyTorch, JAX, and Autograd. PennyLane can be used for the optimization of variational quantum eigensolvers,
quantum approximate optimization, quantum machine learning models, and many other applications.
Introduction
Recent progress in the development and commercializa-
tion of quantum technologies has had a profound impact
on the landscape of quantum algorithms.
Near-term
quantum devices require routines that are of shallow
depth and robust against errors. The design paradigm of
hybrid algorithms which integrate quantum and classical
processing has therefore become increasingly important.
Possibly the most well-known class of hybrid algorithms is
that of variational circuits, which are parameter-dependent
quantum circuits that can be optimized by a classical
computer with regards to a given objective.
Hybrid optimization with variational circuits opens up
a number of new research avenues for near-term quan-
tum computing with applications in quantum chemistry [1],
quantum optimization [2], factoring [3], state diagonaliza-
tion [4], and quantum machine learning [5–18]. In a re-
versal from the usual practices in quantum computing re-
search, a lot of research for these mostly heuristic algo-
rithms necessarily focuses on numerical experiments rather
than rigorous mathematical analysis. Luckily, there are var-
ious publicly accessible platforms to simulate quantum al-
gorithms [19–26] or even run them on real quantum de-
vices through a cloud service [27–29]. Prior to PennyLane’s
launch in 2018, while some frameworks were designed with
variational circuits in mind [25, 30, 31], this was not the
norm, and there was at this stage no uniﬁed tool for the hy-
brid optimization of quantum circuits across quantum plat-
forms, allowing integration with machine learning tooling
while treating all quantum devices on the same footing1.
PennyLane is an open-source Python 3 framework that fa-
cilitates the optimization of quantum and hybrid quantum-
classical algorithms through differentiable quantum pro-
gramming.
It extends several seminal machine learning
libraries — including Autograd [34], TensorFlow [35], Py-
Torch [36], and JAX [37] — to handle modules of quantum
information processing. This can be used to optimize vari-
ational quantum circuits in applications such as quantum
approximate optimization [2] or variational quantum eigen-
solvers [1]. The framework can also handle more complex
machine learning tasks such as training a hybrid quantum-
classical machine learning model in a supervised fashion,
or training a generative adverserial network, both when
discriminator and generator are quantum models [14] and
1 Since PennyLane was released, other differentiable hybrid optimization
frameworks have followed suit, including TensorFlow Quantum [32]
and Yao.jl [33].
when one is quantum and the other is classical [38]. Fi-
nally, PennyLane introduces the concept of differentiable
quantum transforms — the ability to map between circuits
and their intermediate classical processing steps in a dif-
ferentiable manner, as used in many quantum subroutines
[39]. This enables a fully differentiable quantum program-
ming paradigm, where the model (the sequence of quan-
tum transforms) can be optimized alongside the quantum
circuits.
FIG. 1: Basic example of a PennyLane program consisting of
a quantum node followed by a classical node. The output of
the classical node is the objective for optimization.
PennyLane can in principle be used with any gate-based
quantum computing platform as a backend, including both
qubit and continuous-variable architectures, and has a sim-
ple Python-based user interface. Fig. 1 shows an example
that illustrates the core idea of the framework. The user de-
ﬁnes a quantum circuit in the quantum function circuit
connected to a device dev, as well as a “classical function”
that calls circuit and computes a cost. The functions can
be depicted as nodes in a directed acyclic computational
graph that represents the ﬂow of information in the com-
putation. Each node may involve a number of input and
output variables represented by the incoming and outgo-
ing edges, respectively. A GradientDescentOptimizer
is created that improves the initial candidate for these vari-
ables by one step, with the goal of decreasing the cost. Pen-
nyLane is able to automatically determine the gradients of
all nodes — even if the computation is performed on quan-
tum hardware — and can therefore compute the gradient
of the ﬁnal cost node with respect to any input variable.
PennyLane is an open-source software project. Anyone
who contributes signiﬁcantly to the library (new features,
new plugins, etc.) will be acknowledged as a co-author of
this whitepaper. The source code for PennyLane is avail-

3
(a)
x
A(θ)
f (x;θ)
(b)
x
U(θ)
ˆB
f (x;θ)
R
FIG. 2: While a classical node consists of a numerical
computation A, a quantum node executes a variational
circuit U on a quantum device and returns an estimate of the
expectation value of an observable ˆB, estimated by averaging
R measurements.
able online on GitHub2, while comprehensive documenta-
tion and tutorials are available on PennyLane.ai3.
In the following, we will introduce the concept of hybrid
optimization and discuss how gradients of quantum nodes
are computed. We then present PennyLane’s user interface
through examples of optimization and supervised learning,
and describe how to write new plugins that connect Penny-
Lane to other quantum hardware and simulators.
Hybrid optimization
The goal of optimization in PennyLane is to ﬁnd the min-
ima of a cost function that quantiﬁes the quality of a so-
lution for a certain task. In hybrid quantum-classical opti-
mization, the output of the cost function is a result of both
classical and quantum processing, or a hybrid computation.
We call the processing submodules classical and quantum
nodes. Both classical and quantum nodes can depend on
tunable parameters θ that we call variables, which are ad-
justed during optimization to minimize the cost. The nodes
can receive inputs x from other nodes or directly from the
global input to the hybrid computation, and they produce
outputs f (x;θ).
The computation can therefore be de-
picted as a Directed Acyclic Graph (DAG) that graphically
represents the steps involved in computing the cost, which
is produced by the ﬁnal node in the DAG. By traversing the
DAG, information about gradients can be accumulated via
the rules of automatic differentiation [40, 41]. This is used
to compute the gradient of the cost function with respect to
all variables in order to minimize the cost with a gradient-
descent-type algorithm.
Quantum nodes
While classical nodes (see Fig. 2(a)) can contain any nu-
merical computations4, quantum nodes have a more re-
stricted layout.
A quantum node (in PennyLane repre-
sented by the QNode class) is an encapsulation of a function
2 https://github.com/PennyLaneAI/pennylane/
3 https://pennylane.ai
4 Of course, in order to differentiate the classical nodes the computations
have to be based on differentiable functions.
f (x;θ) : Rm →Rn that is executed by means of quantum
information processing on a quantum device. The device can
either refer to quantum hardware or a classical simulator.
Variational circuits
The quantum device executes a parametrized quantum
circuit called a variational circuit [42] that consists of three
basic operations:
1. Prepare an initial state (here assumed to be the
ground or vacuum state |0〉).
2. Apply a sequence of unitary gates U (or more gen-
erally, quantum operations or channels) to |0〉. Each
gate is either a ﬁxed operation, or it can depend on
some of the inputs x or the variables θ. This prepares
the ﬁnal state U(x,θ)|0〉.
3. Measure m mutually commuting scalar observables ˆBi
in the ﬁnal state.
Step 2 describes the way inputs x are encoded into the
variational circuit, namely by associating them with gate
parameters that are not used as trainable variables5. Step 3
describes the way quantum information is transformed back
to the classical output of a quantum node as the expectated
values of the measured observables:
fi(x;θ) = 〈ˆBi〉= 〈0| U(x;θ)† ˆBiU(x;θ)|0〉.
(1)
The observables ˆBi typically consist of a local observable
for each wire (i.e., qubit or qumode) in the circuit, or just
a subset of the wires. For example, ˆBi could be the Pauli-Z
operator for one or more qubits.
Estimating the expectation values
The expectation values 〈ˆBi〉are estimated by averaging
the measurement results obtained over R runs of the circuit.
This estimator, denoted f ∗
i , is unbiased, 〈f ∗
i 〉= fi(x;θ), and
it has variance
Var(f ∗
i ) = Var(ˆBi)
R
=
〈ˆB2
i 〉−〈ˆBi〉2
R
,
(2)
which depends on the variance of the operator ˆBi, as well
as the number of measurements (‘shots’) R. Note that set-
ting R = 1 estimates the expectation value from a single
measurement sample. Simulator devices can also choose
to compute the exact expectation value numerically (in
PennyLane this is the default behavior, represented by set-
ting shots=None). The reﬁned graphical representation
of quantum nodes is shown in Fig. 2(b). We will drop the
index R in the following.
5 This input embedding can also be interpreted as a feature map that maps
x to the Hilbert space of the quantum system [9].

4
FIG. 3: Different types of architectures for variational
circuits: (I) layered gate architecture, (II) alternating
operator architecture [2], and (III) an example of a tensor
network architecture [44].
(a) Variational quantum eigensolver
U(θ1)
σx
U(θ2)
σy
(a1 f1 + a2 f2)2
〈H〉2
f1
f2
(b) Variational quantum classiﬁer
x
P
U(θW)
σz
f + θb
y
f
(c) Quantum generative adversarial network (QGAN)
D(θD) ◦R
σz
D(θD) ◦G(θG)
σz
PR
PG
fG −fR
−fG
CostD
CostG
fR
fG
fG
FIG. 4: DAGs of hybrid optimization examples. These
models and more are available as worked examples in the
PennyLane docs [45].
Circuit architectures
The heart of a variational circuit is the architecture, or
the ﬁxed gate sequence that is the skeleton of the algorithm.
Three common types of architectures are sketched in Fig. 3.
The strength of an architecture varies depending on the de-
sired use-case, and it is not always clear what makes a good
ansatz. Investigations of the expressive power of different
approaches are also ongoing [43]. One goal of PennyLane
is to facilitate such studies across various architectures and
hardware platforms.
Examples of hybrid optimization tasks
Fig. 4 shows three examples of hybrid optimization tasks
depicted as a DAG. Each of these models is available as
a worked example in the PennyLane documentation [45].
Fig. 4(a) illustrates a variational quantum eigensolver, in
which expectation values of two Pauli operators are com-
bined with weights a1, a2 to return the squared global en-
ergy expectation 〈H〉2. Fig. 4(b) shows a variational quan-
tum classiﬁer predicting a label y given a data input x for
a supervised learning task. The input is preprocessed by a
routine P and fed into a variational circuit with variables
θW. A classical node adds a bias variable θb to the Pauli-Z
expectation of a designated qubit. In Fig. 4(c) one can see
a quantum generative adverserial network (QGAN) exam-
ple. It consists of two variational circuits. One represents
the “real data” circuit R together with a discriminator circuit
D, and the other has a “fake” generator circuit G replacing
R. The result is postprocessed by PR,G and used to con-
struct the cost function of the discriminator as well as the
generator. The goal of a GAN is to train the discriminator
and generator in an adversarial fashion until the generator
produces data that is indistinguishable from the true distri-
bution.
Computing gradients
PennyLane focuses on optimization via gradient-based
algorithms, such as gradient descent and its variations. To
minimize the cost via gradient descent, in every step the
individual variables µ ∈Θ are updated according to the
following rule:
1: procedure GRADIENT DESCENT STEP
2:
for µ ∈Θ do
3:
µ(t+1) = µ(t) −η(t)∂µC(Θ)
The learning rate η(t) can be adapted in each step, de-
pending either on the step number, or on the gradient itself.
Backpropagating through the graph
A step of gradient descent requires us to compute the gra-
dient ∇ΘC(Θ) of the cost with respect to all variables Θ.
The gradient consists of partial derivatives ∂µC(Θ) with re-
spect to the individual variables µ ∈Θ. In modern machine
learning libraries like TensorFlow [35], PyTorch [36], Auto-
grad [34], or JAX [37], this computation is performed using
automatic differentiation techniques such as the backprop-
agation algorithm. PennyLane extends these capabilities to
computations involving quantum nodes, allowing computa-
tional models in these four machine learning libraries (in-
cluding those with GPU- and TPU-accelerated components)
to seamlessly include quantum nodes. This makes Penny-
Lane completely compatible with standard automatic differ-
entiation techniques commonly used in machine learning.
While the backpropagation method — a classical algo-
rithm — can resolve the gradient of quantum nodes exe-
cuted on backpropagation-compatible simulators (such as
PennyLane’s built-in default.qubit simulator), this ap-

5
Path p=1
C(Θ)
Path p=2
C(Θ)
FIG. 5: Example illustration of the two paths that lead from
the cost function back to a quantum node.
proach suffers from several drawbacks.
Firstly, it does
not scale with simulations requiring increasing number
of qubits, due to the signiﬁcant memory requirements of
backpropagation (namely, that the quantum state must be
cached at every step in the simulation). Secondly, it does
not support quantum hardware.
To rectify this issue, while preserving the ability to back-
propagate through the overall hybrid quantum-classical
computation, note that the backpropagation algorithm does
not need to resolve the quantum information inside quan-
tum nodes — it is sufﬁcient for us to (separately) compute
the vector Jacobian product of quantum nodes with respect
to their (classical) inputs and variables. The key insight is to
use the same quantum device (hardware or simulator) that
implements a quantum node to also compute (simulator ef-
ﬁcient or hardware compatible) gradients or Jacobians of
that quantum node.
Assume that only the node n∗depends on the subset of
variables θ ⊆Θ, and that µ is in θ. Let C◦n(p)
1 ◦···◦n∗be the
path through the DAG of (quantum or classical) nodes that
emerges from following the cost in the opposite direction of
the directed edges until we reach node n∗. Since there may
be Np ≥1 of those paths (see Fig. 5), we use a superscript
p to denote the path index. All branches that do not lead
back to θ are independent of µ and can be thought of as
constants. The chain rule prescribes that the derivative with
respect to the variable µ ∈θ is given by6
∂µC(Θ) =
Np
X
p=1
∂C
∂n(p)
1
∂n(p)
1
∂n(p)
2
··· ∂n∗
∂µ .
In conclusion, we need to be able to compute two types of
6 While ∂µC(Θ) is a partial derivative and one entry of the gradient vector
∇C(Θ), intermediate DAG nodes may map multiple inputs to multiple
outputs. In this case, we deal with 2-dimensional Jacobian matrices
rather than gradients.
gradients for each node: the derivative
∂n(p)
i
∂n(p)
i−1
with respect
to the input from a previous node, as well as the derivative
with respect to a node variable ∂n
∂µ.
Derivatives of quantum nodes
PennyLane provides multiple methods for computing
derivatives of quantum nodes with respect to a variable
or input7: hardware-compatible circuit transforms, back-
propagation (if supported by the underlying simulator),
or device-provided.
By default, PennyLane uses various
heuristics to determine the ‘best’ gradient method — that
is, the most accurate and efﬁcient gradient method of those
supported by the circuit and the device):
1. If the device provides its own gradient method, this
is the default choice.
For example, this allows for
simulators that support the classical efﬁcient ’adjoint’
method of differentiation [46].
2. If the device is computing expectation values exactly
(shots=None) and supports backpropagation, this is
the next choice.
3. Most quantum nodes permit analytic derivatives on
hardware via parameter-shift rules [47, 48]. If exe-
cuting on hardware devices, or with simulators where
shots!=None, a parameter-shift gradient transform
is the next best choice.
4. Finally, if the circuit does not permit analytic hard-
ware gradients, numerical methods such as the
method of ﬁnite differences is applied.
Analytic derivatives
Recent advances in the quantum machine learning liter-
ature [8, 10, 11, 49] have suggested ways to estimate an-
alytic derivatives by computing linear combinations of dif-
ferent quantum circuits. These rules are summarized and
extended for arbitrary single-frequency operators in a com-
panion paper [47], and extended to operators of arbitrary
frequencies in [48].
This result provides the theoretical
foundation for derivative computations in PennyLane. In
a nutshell, PennyLane makes multiple circuit evaluations,
taking place at shifted parameters, in order to compute an-
alytic derivatives. This recipe works for single-parameter
qubit gates of the form eiGx, where the Hermitian gener-
ator G has an equidistant frequency spectrum (which in-
cludes e.g., all common qubit parametrized gates), as well
as continuous-variable circuits with Gaussian operations8.
7 When we speak of derivatives here, we actually refer to estimates of
derivatives that result from estimates of expectation values. Numerically
computed derivatives in turn are approximations of the true derivatives,
even if the quantum nodes were giving exact expectations (e.g., by using
a classical simulator device).
8 For cases that do not fall into the above two categories, various ex-
tensions are available.
These include shift rules for gates with non-

6
If f (x;θ) = f (µ) is the output of the quantum node, we
have
∂µ f (µ) =
r
X
i=1
ci f (µ + si),
(3)
where r is the number of unique differences in the eigenvalue
spectrum of gate i, si the corresponding parameter-shift val-
ues, and ci the coefﬁcients. Note that ci and si are typically
not ﬁxed; there is a degree of freedom that allows the shift
values to be chosen as needed, and the corresponding co-
efﬁcients to be computed. Having said that, PennyLane by
default chooses shift values that are equidistant with respect
to the gates period, in order to minimize variance.
While this equation bears some structural resemblance
to numerical formulas (discussed next), there are two key
differences.
First, the values ci and si are not inﬁnitesi-
mal, but ﬁnite; second, Eq. (3) gives the exact derivatives.
Thus, while analytic derivative evaluations are constrained
by device noise and statistical imprecision in the averaging
of measurements, they are not subject to numerical issues.
To analytically compute derivatives of qubit gates or gates
in a Gaussian circuit, PennyLane automatically computes
or looks up the appropriate derivative recipe for an opera-
tion, evaluates the original circuit multiple times (shifting
the argument of the relevant gate by {si}), and takes the
linear combination with coefﬁcients {ci}.
Numerical derivatives
Numerical derivative methods require only ‘black-box’
evaluations of the model. We estimate the partial deriva-
tive of a node by evaluating its output, f (x;θ) = f (µ), at
several values which are close to the current value µ ∈θ (µ
can be either a variable or an input here). The approxima-
tion of the derivative is given by
∂µ f (µ) ≈f (µ + ∆µ) −f (µ)
∆µ
(4)
for the forward ﬁnite-differences method, and by
∂µ f (µ) ≈
f (µ + 1
2∆µ) −f (µ −1
2∆µ)
∆µ
(5)
for the centered ﬁnite-differences method. Of course, there is
a tradeoff in choice of the difference ∆µ for noisy hardware.
Backpropagation and device derivatives
In addition to the analytic and numeric derivative imple-
mentations described above — which are supported by all
simulator and hardware devices — PennyLane also supports
equidistant generator frequencies [48], stochastic parameter-shift rules
for multi-parameter gates [50], and a Hadamard test-based approach
that requires an auxiliary qubit [47]. These extensions are not currently
implemented in PennyLane.
FIG. 6: Variational circuit of the qubit rotation example.
native backpropagation, as well as directly querying the de-
vice for the derivative, if known. For example, a simulator
written using a classical automatic differentiation library,
such as TensorFlow, PyTorch, or JAX, can make use of back-
propagation algorithms to calculate derivatives. Compared
to the analytic method on simulators, this may lead to sig-
niﬁcant time savings, as the information required to com-
pute the derivative is stored and reused from the forward
circuit evaluation — simply adding constant overhead. Fur-
thermore, the device derivative may also be used when in-
terfacing with hardware devices that provide their own cus-
tom gradient formulations.
Higher-order derivatives
In addition to computing ﬁrst-order derivatives of quan-
tum nodes on hardware and simulators, PennyLane also
natively supports arbitrary-order derivatives of quantum
nodes.
In the case of gradient transforms that produce
multiple circuits to evaluate under-the-hood (such as the
parameter-shift rules and method of ﬁnite-differences), the
linear combinations are simply iterated by successively ap-
plying the chain and product rules until the required or-
der is reached. To minimize redundant device evaluations,
terms in the iterated rules are simpliﬁed and combined by
taking into account the periods of the gates.
User API
A thorough introduction and review of PennyLane’s API
can be found in the online documentation. The documen-
tation also provides several examples for optimization and
machine learning of quantum and hybrid models in both
continuous-variable and qubit architectures, as well as tu-
torials that walk through the features step-by-step.
Optimization
To see how PennyLane allows the easy construction and
optimization of variational circuits, let us consider the
simple task of optimizing the rotation of a single qubit —
the PennyLane version of ‘Hello world!’.
The task at hand is to optimize the variational circuit of
Fig. 6 with two rotation gates in order to ﬂip a single qubit
from state |0〉to state |1〉. After the rotations, the qubit is
in state |ψ〉= R y(φ2)Rx(φ1)|0〉and we measure the expec-
tation value
f (φ1,φ2) = 〈ψ|σz|ψ〉= cos(φ1)cos(φ2)

7
of the Pauli-Z operator. Depending on the variables φ1 and
φ2, the output expectation lies between 1 (if |ψ〉= |0〉)
and −1 (if |ψ〉= |1〉).
PennyLane code for this example — using the default au-
tograd interface for classical processing — is shown below
in Codeblock 1. It is a self-contained example that deﬁnes a
quantum node, binds it to a computational device, and op-
timizes the output of the quantum node to reach a desired
target.
import pennylane as qml
from pennylane import numpy as np
# Create device
dev = qml.device('default.qubit', wires=1)
# Quantum node
@qml.qnode(dev)
def circuit1(weights):
qml.RX(weights[0], wires=0)
qml.RY(weights[1], wires=0)
return qml.expval(qml.PauliZ(0))
# Create optimizer
opt = qml.GradientDescentOptimizer(0.25)
# Set initial weights
weights = np.array([0.1, 0.2], requires_grad=True)
# Optimize circuit output
for i in range(30):
weights, cost = opt.step_and_cost(circuit1,
weights)
,→
print(f"Step {i}: cost: {cost}")
Codeblock 1: Optimizing two rotation angles to ﬂip a qubit.
We now discuss each element in the above example. Af-
ter the initial import statements, we declare the device
dev on which we run the quantum node, before deﬁn-
ing the quantum node itself.
PennyLane uses the name
wires to refer to quantum subsystems (qubits or qumodes)
since they are represented by horizontal wires in a circuit
diagram.
The decorator @qml.qnode(dev) is a short-
cut that transforms the function circuit1 into a quan-
tum node of the same name. If PennyLane is used with
another supported machine learning library, such as Py-
Torch or TensorFlow, the QNode interface should be speci-
ﬁed when using the decorator, via the interface keyword
argument (interface=‘torch’ and interface=‘tf’
respectively). This allows the QNode to accept objects na-
tive to that interface, such as Torch or TensorFlow tensors.
Note that we could alternatively create the QNode by
hand, without the use of the decorator:
def circuit1():
...
circuit1 = qml.QNode(circuit1, dev)
Codeblock 2: Creating a quantum node without the
decorator.
Finally, the free variables of this computation are auto-
matically optimized through repeated calls to the step or
step_and_cost method of the provided optimizer.
In order for a quantum node to work properly within Pen-
nyLane, the function declaring the quantum circuit must
adhere to a few rules. It must contain quantum operations
to be applied on the device (such operations may depend
on classical inputs passed to the quantum function), and
must return measurement statistics (including expectation
values, variances, and probabilities), of one or more observ-
ables on separate wires. In the latter case, the measurement
statistics should be returned together as a tuple.
dev2 = qml.device('default.qubit', wires=2)
@qml.qnode(dev2)
def circuit2(x):
qml.RX(x[0], wires=0)
qml.CNOT(wires=[0,1])
qml.RY(x[1], wires=1)
return qml.expval(qml.PauliZ(0)),
qml.var(qml.PauliZ(1))
,→
Codeblock 3: A quantum node that returns two
expectations.
As long as at least one measurement value is re-
turned,
not every wire needs to be measured.
In
addition to expectation values,
PennyLane also sup-
ports
returning
variances
(qml.var()),
probabilities
(qml.probs()),
and
samples
(qml.sample()),
al-
though the latter is not differentiable.
Simulator de-
vices may also support returning states (qml.state(),
qml.density_matrix()),
which support differentia-
tion on backpropagation-capable devices.
Tensor prod-
ucts of observables may also be speciﬁed using the @
notation, for example qml.expval(qml.PauliZ(0) @
qml.PauliY(2)). Finally, Hamiltonians representing lin-
ear combinations of operators can be speciﬁed via the no-
tation:
qml.expval(qml.PauliZ(0) @ qml.PauliY(2) + 0.5 *
qml.PauliZ(1))
,→
Codeblock 4: Specifying an expectation value of a
Hamiltonian.
Multiple quantum nodes can be bound to the same de-
vice, and the same circuit can be run on different devices.
In the latter case, the QNode will need to be created manu-
ally. These use-cases are shown in Codeblock 5.9
sim = qml.device("qiskit.aer", wires=1)
hardware = qml.device("qiskit.ibm", backend="ibmqx5"
wires=1)
,→
9 This particular example leverages the Qiskit [51] plugin for PennyLane
[52]. This code will not run without the plugin being installed and with-
out hardware access credentials being provided.

8
# Define quantum circuits
def circuitA(x):
qml.RX(x[0], wires=0)
qml.RY(x[1], wires=0)
return qml.expval(qml.PauliZ(0))
def circuitB(x):
qml.RY(x[0], wires=0)
qml.RX(x[1], wires=0)
return qml.expval(qml.PauliZ(0))
# QNode running Circuit A on simulator
A_s = qml.QNode(circuitA, sim)
# QNode running Circuit A on hardware
A_hw = qml.QNode(circuitA, hardware)
# QNode running Circuit B on hardware
B_hw = qml.QNode(circuitB, hardware)
Codeblock 5: Constructing multiple quantum nodes from
various circuits and devices.
If we have multiple quantum nodes, we can combine the
outputs with a classical node to compute a ﬁnal cost func-
tion:
# Classical node
def cost(x):
return (A_s(x)-A_hw(x))**2
opt = qml.GradientDescentOptimizer()
x = np.array([0.1, 0.2], requires_grad=True)
for i in range(10):
x = opt.step(cost, x)
Codeblock 6: A classical node combining two quantum
nodes.
This cost compares a simulator and a hardware, and ﬁnds
values of the variables for which the two produce the
same result.
This simple example hints that automatic
optimization tools could be used to correct for systematic
errors on quantum hardware.
In summary, quantum and classical nodes can be com-
bined in many different ways to build a larger hybrid com-
putation, which can then be optimized automatically in Pen-
nyLane.
Supervised learning
PennyLane has been designed with quantum and hybrid
quantum-classical machine learning applications in mind.
To demonstrate how this works, we consider a basic imple-
mentation of a variational classiﬁer. A variational classiﬁer
is a model where part of the computation of a class predic-
tion is executed by a variational circuit. The circuit takes an
input x as well as some trainable variables and computes a
prediction y.
def loss(labels, predictions):
# Compute loss
...
def regularizer(weights, bias):
# Compute regularization penalty
...
def statepreparation(x):
# Encode x into the quantum state
...
def layer(W):
# Layer of the model
...
def circuit3(x, weights):
# Encode input x into quantum state
statepreparation(x)
# Execute layers
for W in weights:
layer(W)
return ... # Return expectation(s)
def model(x, weights, bias):
weights = weights[0]
bias = weights[1]
return circuit3(x, weights) + bias
def cost(weights, bias, X, Y):
# Compute prediction for each input
preds = [model(x, weights, bias) for x in X]
# Compute the cost
loss = loss(Y, preds)
regul = regularizer(weights, bias)
return loss + 0.01 * regul
Codeblock 7: Code stub for creating a variational quantum
classiﬁer.
In Codeblock 7, the machine learning model is deﬁned in
the model function. It retrieves two types of variables, a
scalar bias and a list of layer weights. It then computes
the output of the variational circuit and adds the bias.
The variational circuit, in turn, ﬁrst refers to a routine
that encodes the input into a quantum state, and then
applies layers of a certain gate sequence, after which an
expectation is returned.
We can train the classiﬁer to generalize the input-output
relation of a training dataset.
# Training inputs
X = np.array(..., requires_grad=False)
# Training targets
Y = np.array(..., requires_grad=False)
# Create optimizer
opt = qml.AdamOptimizer(0.005, beta1=0.9, beta2=0.9)
# Initialize weights
n_layers = ...
n_gates = ...
weights = np.random.randn(n_layers, n_gates,
requires_grad=True)
,→
bias = np.array(0., requires_grad=True)
# Train the model
for i in range(50):

9
weights, bias, _, _ = opt.step(cost, weights,
bias, X, Y)
,→
Codeblock 8: Code stub for optimizing the variational
classiﬁer.
The variables are initialized as a tuple containing the bias
and the weight matrix. In the optimization loop, we feed a
Python lambda function into the optimizer. Since the opti-
mizer expects a function with a single input argument, this
is a way to feed both X and Y into the cost.
PennyLane can straightforwardly incorporate various
standard machine learning practices.
Examples include:
optimizing minibatches of data with stochastic gradient
descent, adding more terms to the cost, saving variables to
a ﬁle, and continuing optimization with a warm start. For
full worked-out examples, see the PennyLane documenta-
tion [45].
Behind the scenes
The core feature of PennyLane that enables such seamless
optimization integration is the ability to easily extract gra-
dients of hybrid quantum-classical cost functions, regard-
less of underlying quantum devices. The approach for com-
puting hybrid gradients depends on the autodifferentiation
library of choice; below, we demonstrate this capability us-
ing the default Autograd integration, but the same can be
done using PyTorch, TensorFlow, or JAX — simply use the
canonical method of computing gradients in the chosen au-
todifferentiation library. In the default Autograd interface,
qml.grad and qml.jacobian compute gradients of clas-
sical or quantum nodes. Let us switch to “interactive mode”
and look at circuit1 and circuit2 from above.
>>> from pennylane import numpy as np
>>> x = np.array([0.4, 0.1], requires_grad=True)
>>> g1 = qml.grad(circuit1)
>>> print(g1(x))
[-0.38747287, -0.09195267]
>>> j2 = qml.jacobian(circuit2)
>>> print(j2(x))
[[-0.38941834 -0.
]
[ 0.71020641
0.16854179]]
Codeblock 9: Computing gradients of hybrid functions.
As expected, the gradient of a QNode with 2 inputs and
1 output is a 1-dimensional array, while the Jacobian of
a QNode with 2 inputs and 2 outputs is a 2 × 2 array.
The Optimizer class uses gradients and Jacobians com-
puted this way to update variables. PennyLane currently
has several built-in optimizers which work with the de-
fault Autograd interface. This includes standard optimiza-
tion techniques from classical machine learning (standard
gradient descent, gradient descent with momentum, gra-
dient descent with Nesterov momentum, Adagrad, Adam,
RMSprop), as well as a suite of ’quantum aware’ optimiz-
ers, which take into account the quantum geometry and
hardware to increase convergence while minimizing re-
quired quantum resources (quantum natural gradient de-
scent [53], coordinate minimization [48, 54], shot adpative
optimization [55], and Riemannian gradient-ﬂow [56]). If
using PyTorch, TensorFlow, or JAX, the optimizers provided
by those libraries can be used.
Algorithms and features
PennyLane also provides a higher-level interface for eas-
ily and automatically creating and processing QNodes. This
includes a library of circuit ansätze or ‘templates’ from
across the quantum machine learning literature, libraries
of transforms to manipulate circuits and QNodes, and the
ability to easily create cost functions for common quantum
variational algorithms.
Templates
The pennylane.templates module provides a grow-
ing library of pre-coded templates of common variational
circuit architectures that can be used to build, evaluate, and
train more complex models. In the literature, such architec-
tures are commonly known as an ansatz. PennyLane con-
ceptually distinguishes two types of templates, layer archi-
tectures and input embeddings. Most templates are com-
plemented by functions that provide an array of random
initial parameters.
import pennylane as qml
from pennylane import numpy as np
dev = qml.device('default.qubit', wires=2)
@qml.qnode(dev)
def circuit(weights, x):
qml.AngleEmbedding(x, [0,1])
qml.StronglyEntanglingLayers(weights, [0,1])
return qml.expval(qml.PauliZ(0))
shape =
qml.StronglyEntanglingLayers.shape(n_layers=3,
n_wires=2)
,→
,→
weights = np.random.random(shape,
requires_grad=True)
,→
print(circuit(weights, x=[1., 2.]))
Codeblock 10: The embedding template AngleEmbedding
is used to embed data within the QNode, and the layer
template StronglyEntanglingLayers used as the variational
ansatz with a uniform parameter initialization strategy.
Templates provided include AmplitudeEmbedding,
QAOAEmbedding, CVNeuralNetLayers, among others.
In addition, custom templates can be easily created; sim-
ply create a quantum function that applies quantum gates:
def bell_state_preparation(wires):
qml.Hadamard(wires=wires[0])
qml.CNOT(wires=wires)

10
Codeblock 11: Deﬁning a custom template.
The custom template can then be used within any valid QN-
ode.
Transforms
While the ability to deﬁne, process, execute, and train
quantum nodes enables the design of rich variational mod-
els, the power of differentiable quantum programming with
PennyLane is fully unlocked by ‘transforms’; a library of
functions that manipulate, transform, and extract informa-
tion from quantum functions.
There are two main forms of transforms available in Pen-
nyLane:
1. Classical transforms:
These transforms extract
information
from
quantum
functions
without
execting the underlying device.
Examples in-
clude qml.draw()
(for
drawing
quantum
cir-
cuits), qml.specs() (resource information), and
qml.matrix() (extract the matrix representation
of the circuit unitary).
2. Quantum transforms: These transforms extract in-
formation from quantum nodes by generating one or
more quantum circuits, and post-processing the re-
sults with classical processing.
Thus, in contrast to the ‘classical’ transform, the quantum
transform requires additional quantum device evaluations
in order to compute the requested quantity. Aside from this
conceptual difference, both forms of transforms share the
same three important qualities:
• They take as input a function, and transform it to a
new function that takes the same arguments, but re-
turns a different quantity.
• If the output of the transformed function is one or
more ﬂoating point values that depends smoothly
on the input to the original function (as with
qml.matrix), then the transformed function is typi-
cally differentiable with respect to the function argu-
ments.
• If the transform itself permits ﬂoating point parame-
ters, then the transformed function is typically differ-
entiable with respect to the transform arguments.
More formally, we can deﬁne a differentiable quantum
transform as follows:
Deﬁnition 1 Let f (θi) be a quantum function with input pa-
rameters {θi}. A transform T with inputs {φi} is a differen-
tiable quantum transform if
T (f ) →{gk},
(6)
where each gk is also a differentiable quantum function with
respect to the same inputs {θi}, and ∂T
∂φi is deﬁned for all {φi}.
Such
transforms
are
common-place
in
PennyLane,
with
examples
being
the
parameter-shift
rules,
and
qml.batch_inputs() which transforms a circuit to
permit batched input embedding. Another example is the
transform that returns the Fubini-Study metric tensor of a
quantum node:
dev = qml.device("default.qubit", wires=3)
@qml.qnode(dev)
def circuit(weights):
qml.RX(weights[0], wires=0)
qml.RY(weights[1], wires=0)
qml.CNOT(wires=[0, 1])
qml.RZ(weights[2], wires=1)
qml.RZ(weights[3], wires=0)
return qml.expval(qml.PauliY(1))
weights = np.array([0.1, 0.2, 0.4, 0.5],
requires_grad=True)
,→
# apply the transform
mt_fn = qml.metric_tensor(circuit)
# compute the metric tensor
mt_fn(weights)
# calculate the gradient of the norm
def norm(x):
return np.linalg.norm(mt_fn(x))
qml.grad(norm)(weights)
Codeblock 12: Differentiating a transformed QNode.
Circuit compilation is another example of a quantum
transform, and is in fact a special case, as compilation trans-
forms always map a quantum function to a single output
quantum function. As such, they can be arbitrarily com-
posed and ‘stacked’. PennyLane provides a variety of com-
pilation transforms:
@qml.qnode(dev)
@qml.transforms.commute_controlled(direction="left")
@qml.transforms.merge_rotations(atol=1e-6)
@qml.transforms.cancel_inverses
def circuit(x, y, z):
qml.RX(x, wires=0)
qml.RY(y, wires=0)
qml.CNOT(wires=[0, 1])
qml.RZ(x, wires=1)
qml.RZ(-z, wires=0)
return qml.expval(qml.PauliY(1))
Codeblock 13: Applying compilation transforms.
In addition, the qml.compile() transform makes it
easy to build custom compilation pipelines from these in-
dividual transform building blocks.
Finally, PennyLane provides tools for creating custom
transforms.
These work by manipulating the low-level
datastructure representing a sequence of operations and
measurements to be executed on the quantum device
— the quantum tape.
Two decorators are available:
qml.qfunc_transform, for deﬁning transforms that map
a quantum function to a single quantum function, and

11
qml.batch_transform, for deﬁning transforms that map
a quantum function to multiple quantum functions.
@qml.batch_transform
def my_transform(tape, *transform_params):
...
return new_tapes, processing_fn
Codeblock 14: Batch transforms take an input tape
representing a quantum circuit, and return a list of tapes to
execute on the device, as well as a classical post-processing
function to apply to the execution results.
Just-in-time compilation
In addition to providing quantum transforms, PennyLane
also continues to work with many of the composable func-
tional transforms available via autodifferentiation frame-
works. One example includes just-in-time (JIT) compila-
tion, the ability to dynamically compile components of the
computation to machine code, enabling both performance
improvements, and the ability to execute on resources such
as GPUs and TPUs. JAX and TensorFlow both provide JIT
transformations — jax.jit and tf.function respec-
tively — that transform wrapped functions to enable JIT
compatibility. These transformations work seamlessly with
cost functions that include quantum nodes, regardless of
where the quantum node is executed.
Noteably, this al-
lows models to be constructed that take advantage of JIT
compilation to speed up classical pre- and post-processing,
while retaining the ability to execute quantum components
on quantum hardware.
import pennylane as qml
import jax
from jax import numpy as jnp
s3_bucket = ("my-bucket", "my-prefix")
dev = qml.device(
"braket.aws.qubit", 40,
"arn:aws:braket:::device/qpu/rigetti/Aspen-11",
s3_bucket
)
@qml.qnode(dev, interface="jax")
def circuit(x):
qml.RX(x[0], wires=0)
qml.RY(x[1], wires=1)
qml.CNOT(wires=[0, 1])
return qml.expval(qml.PauliZ(0))
@jax.jit
def cost(x):
return jnp.abs(1 - circuit(jnp.sin(x)))
x = jnp.array([-0.5, 0.6])
cost(x)
Codeblock 15: A hybrid classical-quantum cost function is
just-in-time compiled using JAX. The contained QNode is
executed on quantum hardware using the Amazon Braket
plugin.
In addition, there is support for differentiation trans-
forms, including jax.grad, jax.jacobian, jax.vjp,
torch.autograd.functional,
and
TensorFlow’s
tape.jacobian and tape.gradient.
Quantum chemistry
The variational quantum eigensolver (VQE) algorithm is
frequently applied to quantum chemistry problems [1]. In
VQE, a quantum computer is ﬁrst used to prepare the trial
wave function of a molecule, and the expectation value of
its electronic Hamiltonian is measured.
A classical opti-
mizer then adjusts the quantum circuit parameters to ﬁnd
the lowest eigenvalue of the Hamiltonian.
The starting point of VQE is an electronic Hamiltonian ex-
pressed in the Pauli basis — however, determining the Pauli-
basis representation from the molecular structure is highly
non-trivial, requiring use of both self-consistent ﬁeld meth-
ods as well as mapping of Fermionic states and operators to
qubits. PennyLane provides a quantum chemistry package
that, with a single line of code, can be used to generate the
electronic Hamiltonian of a molecule. It employs an in-built
fully-differentiable Hartree-Fock solver [57], in addition to
supporting external quantum chemistry packages such as
OpenFermion [58], PySCF [59], and Psi4 [60, 61].
To build the Hamiltonian, it is necessary to specify the
atomic symbols and the geometry of the molecule.
Ad-
ditional optional information includes the charge of the
molecule, the spin-multiplicity of the Hartree-Fock state,
and the atomic basis set.
The following example code
generates the qubit Hamiltonian for the neutral hydrogen
molecule using the sto-3g basis set for atomic orbitals:
import pennylane as qml
from pennylane import numpy as np
symbols = ['H', 'H']
geometry = np.array([0.0, 0.0, 0.0, 0.0, 0.0,
1.3888])
,→
H, qubits = qml.qchem.molecular_hamiltonian(
symbols,
geometry,
charge=0,
mult=1,
basis='sto-3g'
)
Codeblock 16: Generating the electronic Hamiltonian of the
Hydrogen molecule.
Once the Hamiltonian has been generated, a circuit is
constructed and standard PennyLane techniques are used
to optimize the circuit parameters:
dev = qml.device("default.qubit", wires=qubits)
opt = qml.GradientDescentOptimizer(stepsize=0.4)
hf = qml.qchem.hf_state(electrons=2, orbitals=4)
@qml.qnode(dev)
def circuit(parameters):
qml.BasisState(hf, wires=range(qubits))

12
qml.DoubleExcitation(parameters[0], wires=[0, 1,
2, 3])
,→
return qml.expval(H)
params = np.zeros(1, requires_grad=True)
prev_energy = 0.0
for n in range(50):
params, energy = opt.step_and_cost(circuit,
params)
,→
print(energy, params)
if np.abs(energy - prev_energy) < 1e-6:
break
prev_energy = energy
Codeblock 17: Constructing a VQE optimization workﬂow.
Built-in simulator devices
While PennyLane is designed to easily integrate with ex-
ternal quantum devices (see Writing a plugin device for
more details), it also includes a suite of built-in simulators,
to allow for immediate exploration of differentiable quan-
tum programming without needing to install additional de-
pendencies. This allows for a rapid-iteration style of devel-
opment; explore the capabilities of the quantum algorithm
under development, before scaling it up to run on quantum
hardware.
Currently, PennyLane provides ﬁve simulator devices:
• default.qubit: A Python-based qubit statevector
simulator, with backends written using NumPy, Ten-
sorFlow, PyTorch, and JAX. As a result, this simula-
tor supports end-to-end backpropagation, and mod-
els containing this device can be deployed for execu-
tion on GPUs and TPUs. Due to the memory overhead
of backpropagation, this device works best for 0-20
qubits.
• default.mixed: A Python-based qubit mixed-state
simulator, written in NumPy.
Allows for quantum
nodes that contain quantum channels.
• default.gaussian: A Python-based continuous-
variable simulator, written using NumPy, and de-
signed to support photonic-based quantum nodes.
This device supports continuous-variable quantum
circuits with Gaussian gates and measurements.
• lightning.qubit: A high-performance qubit stat-
evector simulator, written in C++. This device sup-
ports the adjoint method of quantum differentiation
[46], enabling extremely efﬁcient optimization for
quantum nodes with 20 or more qubits.
• lightning.gpu:
A high-performance qubit stat-
evector simulator, written using NVIDIA’s cuQuantum
SDK [62] for GPU accelerated circuit simulation. As
with lightning.qubit, adjoint differentiation is
supported.
lightning.qubit and lightning.gpu
As default.qubit provides an easy way to explore the
use of PennyLane, often more involved workﬂows require
a high-performance backend; lightning.qubit was de-
veloped with this in mind. The core functionality is written
using modern C++ language features (11, 14, and 17), and
allows for an extensible implementation of quantum gate
kernels.
While most users may be running on x86-64 sys-
tems, lightning.qubit also provides pre-built support
for ARM and PowerPC platforms allowing us to target
all architectures for our users, from laptops to cloud
and HPC systems.
As we provide pre-built wheels for
lightning.qubit, this will be automatically be installed
alongside PennyLane, without any need for user compila-
tion.
lightning.qubit is both designed for optimal per-
formance on the individual kernel level, as well as high
throughput jobs that are common to PennyLane: namely,
differentiable workﬂows of quantum circuits. Our imple-
mentation of the adjoint differentiation method directly
parallelizes over user-requested observables, and offers
signﬁcant run-time improvements for workloads with many
observable evaluations. As a result, lightning.qubit us-
ing adjoint differentiation signiﬁcantly reduces the time-to-
solution over other simulators and gradient methods.
As an extension to lightning.qubit, we also provide
lightning.gpu, where gate calls are ofﬂoaded to the
NVIDIA cuQuantum SDK. By taking advantage of the ad-
ditional performance provided by GPUs, lightning.gpu
can evaluate gradients of much larger and deeper quantum
circuits that would otherwise have been intractible on CPU
resources alone.
Writing a plugin device
PennyLane was designed with extensibility in mind, pro-
viding an API for both hardware devices and software simu-
lators to easily connect and allow PennyLane access to their
frameworks. This enables the automatic differentiation and
optimization features of PennyLane to be used on an exter-
nal framework with minimal effort. As a result, PennyLane
is inherently hardware agnostic — the user is able to con-
struct hybrid computational graphs containing QNodes exe-
cuted on an arbitrary number of different devices, and even
reuse quantum circuits across different devices. As of ver-
sion 0.24, PennyLane has plugins available for the Xanadu
Cloud and Strawberry Fields [25, 27, 63], Amazon Braket
[28], Rigetti [64, 65], IBM Quantum and Qiskit [51, 52],
Google Cirq [66], ProjectQ [22, 67], Microsoft QDK [68],
Qulacs [69, 70], AQT [71], Honeywell [72], and IonQ [73].
In PennyLane, there is a subtle distinction between the
terms ‘plugin’ and ‘device’:
• A plugin is an external Python package that provides
additional quantum devices to PennyLane.

13
• Each plugin may provide one (or more) devices, that
are accessible directly by PennyLane, as well as any
additional private functions or classes.
Once installed, these devices can be loaded directly from
PennyLane without any additional steps required by the
user. Depending on the scope of the plugin, a plugin can
also provide custom quantum operations, observables, and
functions that extend PennyLane — for example by convert-
ing from the target framework’s quantum circuit represen-
tation directly to a QNode supporting autodifferentiation10.
In the remainder of this section, we brieﬂy describe the plu-
gin API of PennyLane, and how it can be used to provide
new quantum devices.
Devices
When performing a hybrid computation using Penny-
Lane, one of the ﬁrst steps is to specify the quantum devices
which will be used by quantum nodes. As seen above, this
is done as follows:
import pennylane as qml
dev1 = qml.device(short_name, wires=2)
Codeblock 18: Loading a PennyLane-compatible device.
where short_name is a string which uniquely identiﬁes the
device provided. In general, the short name has the follow-
ing form: pluginname.devicename.
Creating a new device
The ﬁrst step in making a PennyLane plugin is creating
the device class. This is as simple as importing the abstract
base class Device from PennyLane, and subclassing it 11:
from pennylane import Device
class MyDevice(Device):
"""MyDevice docstring"""
name = 'My custom device'
short_name = 'example.mydevice'
pennylane_requires = '0.1.0'
version = '0.0.1'
author = 'Ada Lovelace'
Codeblock 19: Creating a custom PennyLane-compatible
device.
Here, we have begun deﬁning some important class at-
tributes (‘identiﬁers’) that allow PennyLane to recognize the
device. These include:
10 One example being the PennyLane-Qiskit plugin, which provides con-
version functions qml.from_qasm() and qml.from_qiskit() — al-
lowing QNodes to be created from QASM and Qiskit quantum programs
respectively.
11 See
the
developers
guide
in
the
PennyLane
documentation,
https://pennylane.readthedocs.io/en/stable/development/plugins.html,
for an up-to-date guide on creating a new plugin
• Device.name: a string containing the ofﬁcial name
of the device
• Device.short_name: the string used to identify
and load the device by users of PennyLane
• Device.pennylane_requires: the version num-
ber(s) of PennyLane that this device is compatible
with; if the user attempts to load the device on a dif-
ferent version of PennyLane, a DeviceError will be
raised
• Device.version: the version number of the device
• Device.author: the author of the device
Deﬁning all these attributes is mandatory.
Supporting operations and expectations
Plugins must inform PennyLane about the operations and
expectations that the device supports, as well as poten-
tially further capabilities, by providing the following class
attributes/properties:
• Device.operations: a set of the supported Pen-
nyLane operations as strings, e.g., operations =
{"CNOT", "PauliX"}.
This is used to decide
whether an operation is supported by your device
in the default implementation of the public method
Device.supported().
• Device.observables: a set of the supported Pen-
nyLane observables as strings, e.g., observables =
{"PauliX", "Hadamard", "Hermitian"}. This
is used to decide whether an observable is supported
by your device in the default implementation of the
public method Device.supported().
• Device._capabilities: a dictionary containing
information about the capabilities of the device. For
example, the key 'model', which has value ei-
ther 'qubit' or 'CV', indicates to PennyLane the
computing model supported by the device.
This
class dictionary may also be used to return addi-
tional information to the user — this is accessible
from the PennyLane frontend via the public method
Device.capabilities.
A subclass of the Device class, QubitDevice, is pro-
vided for easy integration with simulators and hardware de-
vices that utilize the qubit model. QubitDevice provides
automatic support for all supported observables, including
tensor observables. For a better idea of how these required
device properties work, refer to the two reference devices.
Applying operations and measuring statistics
Once all the class attributes are deﬁned, it is necessary to
deﬁne some required class methods, to allow PennyLane to
apply operations to your device. In the following examples,
we focus on the QubitDevice subclass. When PennyLane

14
evaluates a QNode, it calls the Device.execute method,
which performs the following process:
self.check_validity(circuit.operations,
circuit.observables)
,→
# apply all circuit operations
self.apply(circuit.operations,
rotations=circuit.diagonalizing_gates)
,→
# generate computational basis samples
if (not self.analytic) or circuit.is_sampled:
self._samples = self.generate_samples()
# compute the required statistics
results = self.statistics(circuit.observables)
return self._asarray(results)
Codeblock 20: The PennyLane Device.execute method,
called whenever a quantum node is evaluated.
In most cases, there are a minimum of two methods that
need to be deﬁned:
• Device.apply: Accepts a list of PennyLane Oper-
ations to be applied.
The corresponding quantum
operations are applied to the device, the circuit ro-
tated into the measurement basis, and, if relevant, the
quantum circuit compiled and executed.
• Device.probability:
Returns the (marginal)
probability of each computational basis state from the
last run of the device.
In addition, if the device generates/returns its own compu-
tational basis samples for measured modes after execution,
the following method must also be deﬁned:
• Device.generate_samples:
Generate
com-
putational
basis
samples
for
all
wires.
If
Device.generate_samples
is
not
deﬁned,
PennyLane will automatically generate samples using
the output of the device probability.
Once the required methods are deﬁned, the inherited meth-
ods Device.expval, Device.var, and Device.sample
can be passed an observable (or tensor product of observ-
ables), returning the corresponding measurement statistic.
Installation and testing
PennyLane uses a setuptools entry_points ap-
proach to plugin integration. In order to make a plugin
accessible to PennyLane, the following keyword argument
to the setup function must be provided in the plugin’s
setup.py ﬁle:
devices_list = [
'myplugin.mydev1 = MyMod.MySubMod:MyDev1',
'myplugin.mydev2 = MyMod.MySubMod:MyDev2'
,→
,→
]
setup(entry_points={'pennylane.plugins':
devices_list})
,→
Codeblock 21: Creating the PennyLane device entry points.
Here, devices_list is a list of devices to be regis-
tered, myplugin.mydev1 is the short name of the de-
vice, and MyMod.MySubMod is the path to the Device class,
MyDev1. To ensure the device is working as expected, it
can be installed in developer mode using pip install
-e pluginpath, where pluginpath is the location of the
plugin. It will then be accessible via PennyLane.
All plugins should come with unit tests, to ensure that
devices work as expected. In general, as all supported op-
erations have their gradient formula deﬁned and tested by
PennyLane, testing that the device calculates the correct
gradients is not required — it is sufﬁcient to test that it
applies and measures quantum operations and observables
correctly.
To help, PennyLane provides a device integra-
tion test utility, to ensure that a speciﬁed device returns
expected values for various circuits and measurements.
This device testing utility comes pre-installed with Penny-
Lane, and is available via the command pl-device-test.
For example, running the device test against the built-in
default.qubit simulator:
pl-device-test --device default.qubit --shots 10000
--skip-ops
,→
Codeblock 22: Running the PennyLane device integration
test suite against default.qubit with 10000 shots, and
skipping the tests of any unsupported operations.
Supporting new operations
PennyLane also provides the ability to add custom op-
erations or observables to be executed on the plugin de-
vice, that may not be currently supported by PennyLane.
For qubit architectures this is done by subclassing the
Operation and Observable classes, deﬁning the num-
ber of parameters the operation takes, and the number
of wires the operation acts on.
In addition, if the fre-
quencies of the operation are known, the corresponding
parameter_frequencies should be provided, to open
up analytic differentiation support in PennyLane.
For example, to deﬁne the U2 gate, which depends on
parameters φ and λ, we create the following class:
class U2(Operation):
"""U2 gate."""
num_params = 2
num_wires = 1
parameter_frequencies = [(1,), (1,)]
def __init__(self, phi, lam, wires, **kwargs):
super().__init__(phi, delta, wires=wires,
**kwargs)
,→
@staticmethod
def compute_decomposition(phi, lam, wires):
decomp_ops = [
Rot(lam, np.pi / 2, -lam, wires=wires),
PhaseShift(phi + lam, wires=wires)
]
return decomp_ops

15
Codeblock 23: Creating a custom qubit operation.
where the following quantities must be declared:
• Operation.num_params: the number of parame-
ters the operation takes
• Operation.num_wires: the number of wires the
operation acts on
In addition, the following optional operator representa-
tions can be deﬁned, which enables additional functionality
within PennyLane:
• Operation.compute_matrix:
static
method
which returns the matrix representation in the
computational basis.
• Operation.compute_sparse_matrix:
static
method which returns the sparse matrix representa-
tion in the computational basis.
• Operation.compute_decomposition:
static
method which returns a list of operators representing
the tensor product decomposition.
• Operation.compute_diagonalizing_gates:
static method which returns a list of PennyLane
operations that diagonalize the observable in the
computational basis.
• Operation.compute_eigvals:
static
method
which returns the eigenvalues.
• Operation.compute_kraus_matrices:
static
method which returns the a list of Kraus matrices
representing a channel.
• generator: An instance method that returns an op-
erator representing the Hermitian generator of a sin-
gle parameter operation.
• Operation.parameter_frequencies:
property
or attribute that deﬁnes the frequency spectrum of an
operator with respect to an expectation value. If pro-
vided, this is used to compute generalized shift rules
for the operator, enabling anlaytic quantum gradients
on hardware.
• Operation.grad_recipe: the gradient recipe for
operation. This is a list with one tuple per operation
parameter. For parameter k, the tuple is of the form
(ck, mk,sk), resulting in a gradient recipe of
d
dφk
O =
X
k
ckO(mkφk + sk).
• Operation.label: determines how the operation
appears in a circuit diagram.
The user can then import this operation directly from
your plugin, and use it when deﬁning a QNode:
import pennylane as qml
from MyModule.MySubModule import Ising
@qnode(dev1)
def my_qfunc(phi):
qml.Hadamard(wires=0)
Ising(phi, wires=[0, 1])
return qml.expval(qml.PauliZ(1))
Codeblock 24: Using a plugin-provided custom operation.
In this case, as the plugin is providing a custom operation
not supported by PennyLane, it is recommended that the
plugin unit tests do provide tests to ensure that PennyLane
returns the correct gradient for the custom operations.
Custom observables
Custom observables can be added in an identical manner
to operations above, but with three small changes:
• The Observable class should instead be subclassed.
• The static method Observable.compute_eigvals
should be deﬁned, returning a one-dimensional array
of eigenvalues of the observable.
• The static method Observable.compute_diagonalizing_ga
should be deﬁned. This is used to support devices
that can only perform measurements in the compu-
tational basis.
Custom CV operations and expectations
For custom continuous-variable operations or expecta-
tions, the CVOperation or CVObservable classes must
be subclassed instead. In addition, for CV operations with
known analytic gradient formulas (such as Gaussian op-
erations), the static class method CV._heisenberg_rep
must be deﬁned:
class Custom(CVOperation):
"""Custom gate"""
n_params = 2
n_wires = 1
grad_method = 'A'
grad_recipe = None
@staticmethod
def _heisenberg_rep(params):
return function(params)
Codeblock 25: Creating a custom continuous-variable
operation.
For operations, the _heisenberg_rep method should
return the Heisenberg representation of the operation, i.e.,
the matrix of the linear transformation carried out by
the operation for the given parameter values12.
This is
12 Speciﬁcally, if the operation carries out a unitary transformation U, this
method should return the matrix for the adjoint action U†(·)U.

16
used internally for calculating the gradient using the an-
alytic method (grad_method = 'A'). For observables,
this method should return a real vector (ﬁrst-order ob-
servables) or symmetric matrix (second-order observables)
of coefﬁcients which represent the expansion of the ob-
servable in the basis of monomials of the quadrature op-
erators.
For single-mode operations we use the basis
r = (I, ˆx, ˆp), and for multi-mode operations the basis
r = (I, ˆx0, ˆp0, ˆx1, ˆp1,...), where ˆxk and ˆpk are the quadra-
ture operators of qumode k.
Note that, for every gate,
even if the analytic gradient formula is not known or if
_heisenberg_rep is not provided, PennyLane continues
to support the ﬁnite difference method of gradient compu-
tation.
Conclusion
We have introduced PennyLane, a Python package that
extends automatic differentiation to quantum and hybrid
classical-quantum information processing. This is accom-
plished by introducing a new quantum node abstraction
which interfaces cleanly with existing DAG-based auto-
matic differentiation methods like the backpropagation al-
gorithm. The ability to compute gradients of variational
quantum circuits – and to integrate these seamlessly as part
of larger hybrid computations – opens up a wealth of poten-
tial applications, in particular for optimization and machine
learning tasks.
We envision PennyLane as a powerful tool for many re-
search directions in quantum computing and quantum ma-
chine learning, similar to how libraries like TensorFlow, Py-
Torch, or JAX have become indispensible for research in
deep learning. With small quantum processors becoming
publicly available, and with the emergence of variational
quantum circuits as a new algorithmic paradigm, the quan-
tum computing community has begun to embrace heuristic
algorithms more and more. This spirit is already common
in the classical machine learning community and has – to-
gether with dedicated software enabling rapid exploration
of computational models – allowed that ﬁeld to develop at
a remarkable pace. With PennyLane, tools are now freely
available to investigate model structures, training strate-
gies, and optimization landscapes within hybrid and quan-
tum machine learning, to explore existing and new varia-
tional circuit architectures, and to design completely new
algorithms by circuit learning.
[1] Alberto Peruzzo, Jarrod McClean, Peter Shadbolt, Man-Hong
Yung, Xiao-Qi Zhou, Peter J Love, Alán Aspuru-Guzik, and
Jeremy L O’Brien, “A variational eigenvalue solver on a pho-
tonic quantum processor,” Nature Communications 5, 4213
(2014).
[2] Edward Farhi, Jeffrey Goldstone,
and Sam Gutmann,
“A quantum approximate optimization algorithm,” arXiv
preprint (2014), arxiv:1411.4028.
[3] Eric R Anschuetz, Jonathan P Olson, Alán Aspuru-Guzik,
and Yudong Cao, “Variational quantum factoring,” arXiv
preprint (2018), arxiv:1808.08927.
[4] Ryan LaRose, Arkin Tikku, Étude O’Neel-Judy, Lukasz Cincio,
and Patrick J Coles, “Variational quantum state diagonaliza-
tion,” arXiv preprint (2018), arxiv:1810.10506.
[5] Jonathan Romero, Jonathan P Olson,
and Alan Aspuru-
Guzik, “Quantum autoencoders for efﬁcient compression of
quantum data,” Quantum Science and Technology 2, 045001
(2017).
[6] Peter D Johnson, Jonathan Romero, Jonathan Olson, Yudong
Cao,
and Alán Aspuru-Guzik, “QVECTOR: an algorithm
for device-tailored quantum error correction,” arXiv preprint
(2017), arxiv:1711.02249.
[7] Guillaume Verdon, Michael Broughton,
and Jacob Bi-
amonte,
“A
quantum
algorithm
to
train
neural
net-
works using low-depth circuits,” arXiv preprint
(2017),
arxiv:1712.05304.
[8] Edward Farhi and Hartmut Neven, “Classiﬁcation with
quantum neural networks on near term processors,” arXiv
preprint (2018), arxiv:1802.06002.
[9] Maria Schuld and Nathan Killoran, “Quantum machine
learning in feature Hilbert spaces,” arXiv preprint (2018),
arxiv:1803.07128.
[10] Kosuke Mitarai, Makoto Negoro, Masahiro Kitagawa, and
Keisuke Fujii, “Quantum circuit learning,” Phys. Rev. A 98,
032309 (2018), arxiv:1803.00745.
[11] Maria Schuld, Alex Bocharov, Krysta Svore,
and Nathan
Wiebe, “Circuit-centric quantum classiﬁers,” arXiv preprint
(2018), arxiv:1804.00633.
[12] Edward Grant, Marcello Benedetti, Shuxiang Cao, Andrew
Hallam, Joshua Lockhart, Vid Stojevic, Andrew G Green, and
Simone Severini, “Hierarchical quantum classiﬁers,” arXiv
preprint (2018), arxiv:1804.03680.
[13] Jin-Guo Liu and Lei Wang, “Differentiable learning of
quantum circuit Born machine,” arXiv preprint
(2018),
arxiv:1804.04168.
[14] Pierre-Luc Dallaire-Demers and Nathan Killoran, “Quantum
generative adversarial networks,” Physical Review A 98,
012324 (2018).
[15] Vojtech Havlicek, Antonio D Córcoles, Kristan Temme,
Aram W Harrow, Jerry M Chow, and Jay M Gambetta, “Su-
pervised learning with quantum enhanced feature spaces,”
arXiv preprint (2018), arxiv:1804.11326.
[16] Hongxiang Chen, Leonard Wossnig, Simone Severini, Hart-
mut Neven,
and Masoud Mohseni, “Universal discrimi-
native quantum neural networks,” arXiv preprint
(2018),
arxiv:1805.08654.
[17] Nathan Killoran, Thomas R Bromley, Juan Miguel Arra-
zola, Maria Schuld, Nicolás Quesada,
and Seth Lloyd,
“Continuous-variable
quantum
neural
networks,”
arXiv
preprint (2018), arxiv:1806.06871.
[18] Gregory R Steinbrecher, Jonathan P Olson, Dirk Englund,
and Jacques Carolan, “Quantum optical neural networks,”
arXiv preprint (2018), arxiv:1808.10047.
[19] Dave Wecker and Krysta M. Svore, “LIQUi|>: A software de-

17
sign architecture and domain-speciﬁc language for quantum
computing,” arXiv preprint (2014), arxiv:1402.4467.
[20] Mikhail Smelyanskiy,
Nicolas PD Sawaya,
and Alán
Aspuru-Guzik, “qHiPSTER: the quantum high performance
software testing environment,” arXiv preprint
(2016),
arxiv:1601.07195.
[21] IBM Corporation, “Qiskit,” (2016).
[22] Damian S Steiger, Thomas Häner, and Matthias Troyer, “Pro-
jectQ: an open source software framework for quantum com-
puting,” Quantum 2, 49 (2018).
[23] Rigetti Computing, “Forest SDK,” (2017).
[24] Microsoft
Corporation,
“Quantum
Development
Kit,”
(2017).
[25] Nathan
Killoran,
Josh
Izaac,
Nicolás
Quesada,
Ville
Bergholm, Matthew Amy, and Christian Weedbrook, “Straw-
berry Fields: A software platform for photonic quantum com-
puting,” arXiv preprint (2018), arxiv:1804.03159.
[26] Google Inc., “Cirq,” (2018).
[27] J.M. Arrazola, V. Bergholm, K. Brádler, T.R. Bromley, M.J.
Collins, I. Dhand, A. Fumagalli, T. Gerrits, A. Goussev, L.G.
Helt, J. Hundal, T. Isacsson, R.B. Israel, J. Izaac, S. Jahangiri,
R. Janik, N. Killoran, S.P. Kumar, J. Lavoie, A.E. Lita, D.H.
Mahler, M. Menotti, B. Morrison, S.W. Nam, L. Neuhaus, H.Y.
Qi, N. Quesada, A. Repingon, K.K. Sabapathy, M. Schuld,
D. Su, J. Swinarton, A. Száva, K. Tan, P. Tan, V.D. Vaidya,
Z. Vernon, Z. Zabaneh, and Y. Zhang, “Quantum circuits with
many photons on a programmable nanophotonic chip,” Na-
ture 591, 54–60 (2021).
[28] Amazon Web Services, “Amazon Braket,” (2020).
[29] IBM Corporation, “IBM Quantum Experience,” (2016).
[30] Xanadu Inc., “Quantum machine learning toolbox,” (2018).
[31] Sukin Sim, Yudong Cao, Jonathan Romero, Peter D Johnson,
and Alan Aspuru-Guzik, “A framework for algorithm deploy-
ment on cloud-based quantum computers,” arXiv preprint
(2018), arxiv:1810.10576.
[32] Michael Broughton, Guillaume Verdon, Trevor McCourt, An-
tonio J Martinez, Jae Hyeon Yoo, Sergei V Isakov, Philip
Massey, Ramin Halavati, Murphy Yuezhen Niu, Alexan-
der Zlokapa, et al., “Tensorﬂow quantum:
A software
framework for quantum machine learning,” arXiv preprint
arXiv:2003.02989 (2020).
[33] Xiu-Zhe Luo, Jin-Guo Liu, Pan Zhang, and Lei Wang, “Yao. jl:
Extensible, efﬁcient framework for quantum algorithm de-
sign,” Quantum 4, 341 (2020).
[34] Dougal Maclaurin, David Duvenaud,
and Ryan P Adams,
“Autograd: Effortless gradients in numpy,” in ICML 2015 Au-
toML Workshop (2015).
[35] Martín Abadi, Paul Barham, Jianmin Chen, Zhifeng Chen,
Andy Davis, Jeffrey Dean, Matthieu Devin, Sanjay Ghe-
mawat, Geoffrey Irving, Michael Isard, Manjunath Kudlur,
Josh Levenberg, Rajat Monga, Sherry Moore, Derek G. Mur-
ray, Benoit Steiner, Paul Tucker, Vijay Vasudevan, Pete War-
den, Martin Wicke, Yuan Yu, and Xiaoqiang Zheng, “Tensor-
Flow: a system for large-scale machine learning.” in OSDI,
Vol. 16 (USENIX Association, Berkeley, CA, USA, 2016) pp.
265–283.
[36] Adam Paszke,
Sam Gross,
Soumith Chintala,
Gregory
Chanan, Edward Yang, Zachary DeVito, Zeming Lin, Alban
Desmaison, Luca Antiga, and Adam Lerer, “Automatic dif-
ferentiation in PyTorch,” (2017).
[37] James Bradbury, Roy Frostig, Peter Hawkins, Matthew James
Johnson, Chris Leary, Dougal Maclaurin, George Necula,
Adam Paszke, Jake VanderPlas, Skye Wanderman-Milne,
and Qiao Zhang, “JAX: composable transformations of
Python+NumPy programs,” (2018).
[38] Seth Lloyd and Christian Weedbrook, “Quantum generative
adversarial learning,” Physical Review Letters 121, 040502
(2018).
[39] Olivia Di Matteo,
Josh Izaac,
Tom Bromley,
Anthony
Hayes, Christina Lee, Maria Schuld, Antal Száva, Chase
Roberts,
and Nathan Killoran, “Quantum computing
with differentiable quantum transforms,” arXiv preprint
arXiv:2202.13414 (2022).
[40] Dougal Maclaurin, Modeling, inference and optimization with
composable differentiable procedures, Ph.D. thesis, Harvard
University, Graduate School of Arts & Sciences (2016).
[41] Atılım Güne¸s Baydin, Barak A Pearlmutter, Alexey Andreye-
vich Radul, and Jeffrey Mark Siskind, “Automatic differen-
tiation in machine learning: a survey.” Journal of Machine
Learning Research 18, 1–153 (2018).
[42] Jarrod R McClean,
Jonathan Romero,
Ryan Babbush,
and Alán Aspuru-Guzik, “The theory of variational hybrid
quantum-classical algorithms,” New Journal of Physics 18,
023023 (2016).
[43] Yuxuan Du, Min-Hsiu Hsieh, Tongliang Liu, and Dacheng
Tao, “The expressive power of parameterized quantum cir-
cuits,” arXiv preprint (2018), arxiv:1810.11922.
[44] William Huggins, Piyush Patel, K Birgitta Whaley,
and
E
Miles
Stoudenmire,
“Towards
quantum
machine
learning with tensor networks,” arXiv preprint
(2018),
arxiv:1803.11537.
[45] Xanadu Inc., “PennyLane,” (2018).
[46] Tyson Jones and Julien Gacon, “Efﬁcient calculation of gra-
dients in classical simulations of variational quantum algo-
rithms,” arXiv preprint arXiv:2009.02823 (2020).
[47] Maria Schuld, Ville Bergholm, Christian Gogolin, Josh Izaac,
and Nathan Killoran, “Evaluating analytic gradients on quan-
tum hardware,” Physical Review A 99, 032331 (2019).
[48] David Wierichs, Josh Izaac, Cody Wang, and Cedric Yen-Yu
Lin, “General parameter-shift rules for quantum gradients,”
Quantum 6, 677 (2022).
[49] Gian Giacomo Guerreschi and Mikhail Smelyanskiy, “Prac-
tical optimization for hybrid quantum-classical algorithms,”
arXiv preprint (2017), arxiv:1701.01450.
[50] Leonardo Banchi and Gavin E Crooks, “Measuring analytic
gradients of general quantum evolution with the stochastic
parameter shift rule,” Quantum 5, 386 (2021).
[51] David C McKay, Thomas Alexander, Luciano Bello, Michael J
Biercuk, Lev Bishop, Jiayin Chen, Jerry M Chow, Antonio D
Córcoles, Daniel Egger, Stefan Filipp, et al., “Qiskit backend
speciﬁcations for openqasm and openpulse experiments,”
arXiv preprint arXiv:1809.03452 (2018).
[52] Xanadu Inc., “PennyLane Qiskit plugin,” (2019).
[53] James Stokes, Josh Izaac, Nathan Killoran,
and Giuseppe
Carleo,
“Quantum
natural
gradient,”
arXiv
preprint
arXiv:1909.02108 (2019).
[54] Mateusz
Ostaszewski,
Edward
Grant,
and
Marcello
Benedetti, “Structure optimization for parameterized quan-
tum circuits,” Quantum 5, 391 (2021).
[55] Andrew Arrasmith, Lukasz Cincio, Rolando D Somma,
and Patrick J Coles, “Operator sampling for shot-frugal
optimization in variational algorithms,” arXiv preprint
arXiv:2004.06252 (2020).
[56] Roeland Wiersema and Nathan Killoran, “Optimizing quan-
tum circuits with riemannian gradient-ﬂow,” arXiv preprint
arXiv:2202.06976 (2022).
[57] Juan Miguel Arrazola, Soran Jahangiri, Alain Delgado, Jack
Ceroni, Josh Izaac, Antal Száva, Utkarsh Azad, Robert A.

18
Lang,
Zeyue Niu,
Olivia Di Matteo,
Romain Moyard,
Jay Soni, Maria Schuld, Rodrigo A. Vargas-Hernández,
Teresa Tamayo-Mendoza, Cedric Yen-Yu Lin, Alán Aspuru-
Guzik,
and Nathan Killoran, “Differentiable quantum
computational chemistry with pennylane,” arXiv preprint
arXiv:2111.09967 (2021).
[58] Jarrod R McClean, Kevin J Sung, Ian D Kivlichan, Yudong
Cao, Chengyu Dai, E Schuyler Fried, Craig Gidney, Bren-
dan Gimby, Pranav Gokhale, Thomas Häner, et al., “Open-
fermion: the electronic structure package for quantum com-
puters,” arXiv:1710.07629 (2017).
[59] Qiming Sun, Timothy C Berkelbach, Nick S Blunt, George H
Booth, Sheng Guo, Zhendong Li, Junzi Liu, James D Mc-
Clain, Elvira R Sayfutyarova, Sandeep Sharma, et al., “Pyscf:
the python-based simulations of chemistry framework,” Wi-
ley Interdisciplinary Reviews: Computational Molecular Sci-
ence 8, e1340 (2018).
[60] Justin M Turney, Andrew C Simmonett, Robert M Parrish, Ed-
ward G Hohenstein, Francesco A Evangelista, Justin T Fer-
mann, Benjamin J Mintz, Lori A Burns, Jeremiah J Wilke,
Micah L Abrams, et al., “Psi4: an open-source ab initio elec-
tronic structure program,” Wiley Interdisciplinary Reviews:
Computational Molecular Science 2, 556–565 (2012).
[61] Robert M Parrish, Lori A Burns, Daniel GA Smith, Andrew C
Simmonett, A Eugene DePrince III, Edward G Hohenstein,
Ugur Bozkaya, Alexander Yu Sokolov, Roberto Di Remigio,
Ryan M Richard, et al., “Psi4 1.1:
An open-source elec-
tronic structure program emphasizing automation, advanced
libraries, and interoperability,” Journal of Chemical Theory
and Computation 13, 3185–3197 (2017).
[62] NVIDIA cuQuantum team, “Nvidia/cuquantum: cuquantum
v22.03.0,” (2022).
[63] Xanadu Inc., “PennyLane Strawberry Fields plugin,” (2018).
[64] Robert S Smith, Michael J Curtis,
and William J Zeng,
“A practical quantum instruction set architecture,” arXiv
preprint arXiv:1608.03355 (2016).
[65] “PennyLane Forest plugin,” (2019).
[66] Xanadu Inc., “PennyLane Cirq plugin,” (2019).
[67] Xanadu Inc., “PennyLane ProjectQ plugin,” (2018).
[68] Xanadu Inc., “PennyLane Q# plugin,” (2019).
[69] QunaSys, “Qulacs,” (2019).
[70] Xanadu Inc., “PennyLane Qulacs plugin,” (2019).
[71] Xanadu Inc., “PennyLane AQT plugin,” (2019).
[72] Xanadu Inc., “PennyLane Honeywell plugin,” (2019).
[73] Xanadu Inc., “PennyLane IonQ plugin,” (2019).

