2
Classical coordination mechanisms
in the chemical model
Jean-Pierre Banˆatre
INRIA/IRISA, Universit´e de Rennes 1
Pascal Fradet
INRIA Rhˆone-Alpes
Yann Radenac
INRIA/IRISA, Universit´e de Rennes 1
In memory of Gilles Kahn
The essence of this paper stems from discussions that the ﬁrst
author (Jean-Pierre Banˆatre) had with Gilles on topics related with
programming in general and chemical programming in particular. Gilles
liked the ideas behind the Gamma model [6] and the closely related
Berry and Boudol’s CHAM [7] as the basic principles are so simple and
elegant. The last opportunity Jean-Pierre had to speak about these
ideas to Gilles, was when he presented the LNCS volume devoted to the
Unconventional Programming Paradigms workshop [1]. The 10 minutes
appointment (at that time, he was CEO of INRIA) lasted a long time.
Gilles was ﬁne and in good humour, as often, and he was clearly happy
to talk about a subject he loved. He spoke a lot about λ-calculus, the
reduction principle, the β-reduction. . . a really great souvenir!
Abstract
Originally, the chemical model of computation has been proposed as
a simple and elegant parallel programming paradigm. Data is seen
as “molecules” and computation as “chemical reactions”: if some
molecules satisfy a predeﬁned reaction condition, they are replaced by
the “product” of the reaction. When no reaction is possible, a normal
form is reached and the program terminates. In this paper, we describe
classical coordination mechanisms and parallel programming models in
the chemical setting. All these examples put forward the simplicity and
expressivity of the chemical paradigm. We pay a particular attention
From Semantics to Computer Science Essays in Honour of Gilles Kahn,
eds Yves
Bertot, G´erard Huet, Jean-Jacques L´evy and Gordon Plotkin. Published by Cambridge
University Press.
c
⃝Cambridge University Press 2009.
29
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

30
J.-P. Banˆatre, P. Fradet and Y. Radenac
to the chemical description of the simple and successful parallel
computation model known as Kahn Process Networks.
2.1 Introduction
The Gamma formalism was proposed 20 years ago to capture the
intuition of computation as the global evolution of a collection of atomic
values interacting freely [6]. Gamma can be introduced intuitively
through the chemical reaction metaphor. The unique data structure in
Gamma is the multiset which can be seen as a chemical solution. A
simple program is made of a reaction condition and an action. Execution
proceeds by replacing elements satisfying the reaction condition by the
elements speciﬁed by the action. The result of a Gamma program is
obtained when a stable or inert state is reached, that is to say, when no
more reactions can take place.
For example, the computation of the maximum element of a non-
empty multiset of comparable elements can be described by the reaction
rule
replace x, y by x if x ≥y
meaning that any couple of elements x and y of the multiset such that
x is greater or equal to y is replaced by x. This process goes on till a
stable state is reached, that is to say, when only the maximum element
remains. Note that, in this deﬁnition, nothing is said about the order of
evaluation of the comparisons. If several disjoint pairs of elements satisfy
the condition, reactions can be performed in parallel.
Gamma can be formalized as a multiset AC-rewriting language. The
Gamma formalism, and its derivative works as summarized in [2], is
based on ﬁnite multisets of basic values. However, this basic concept
can be extended by allowing elements of multisets to be reactions
themselves (higher-order multisets), to have an inﬁnite multiplicity
(inﬁnite multisets) and even to have a negative multiplicity (hybrid
multisets). In [4], we have investigated these unconventional multiset
structures (higher-order, inﬁnite and hybrid multisets) and shown
how they can be interpreted in a chemical programming framework.
In particular, we have introduced the γ-calculus, a minimal higher-
order calculus that summarizes the fundamental concepts of chemical
programming. From this basic language, we have derived HOCL (the
Higher Order Chemical Language), a programming language built by
extending the γ-calculus with constants, operators, types and expressive
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
31
patterns. The reﬂexive CHAM [10] is another approach to higher-order
multiset programming.
The objective of this paper is to show how many well-known parallel
mechanisms from basic mutual exclusion to Kahn Process Networks can
be expressed in the same uniﬁed framework: the chemical model. This
work illustrates one more time the expressivity of chemical languages.
It also paves the way to formal comparisons of classical coordination
structures and models.
2.2 The higher-order chemical language
The HOCL language [4] is a higher-order extension of Gamma based on
the γ-calculus [3]. Here, we present brieﬂy and informally the features
of HOCL used in this article. The interested reader will ﬁnd a more
complete and formal presentation in [4].
In HOCL, programs, solutions, data and reaction rules are all
molecules. A program is a solution of atoms
⟨A1, . . . , An⟩
that is, a multiset of constants, reaction rules and (sub-)solutions.
The associativity and commutativity of the operator “,” formalize the
Brownian motion within a chemical solution. These laws can always
be used to reorganize molecules in solutions. Atoms are either basic
constants (integers, booleans, etc. ), pairs (A1:A2), sub-solutions (⟨M⟩)
or reaction rules. A reaction rule is written
one P by M if C
where P is a pattern which selects some atoms, C is the reaction
condition and M the result of the reaction. If P matches atoms which
satisfy C, they are replaced by M. For example,
⟨(one x::Int by x + 1 if x div 2), 4, 9, 15⟩−→γ ⟨5, 9, 15⟩.
The pattern x::Int matches any integer, the condition imposes the integer
to be even and the action replaces it by the next odd integer. In the rest
of this article, we omit types in patterns when there is no ambiguity.
Such reaction rules are said to be one-shot since they are consumed
when they react. In Gamma, rewrite rules were outside the multiset and
remained as long as they could be applied. In HOCL, such recursive
rules are called n-shot and, like in Gamma, these are written as
replace P by M if C.
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

32
J.-P. Banˆatre, P. Fradet and Y. Radenac
The execution of a chemical program consists in performing reactions
(non-deterministically and possibly in parallel) until the solution
becomes inert i.e. no reaction can take place anymore. For example, the
following HOCL program computes the prime numbers lower than 10
using a version of the Eratosthenes’ sieve:
⟨(replace x, y by x if x div y), 2, 3, 4, 5, 6, 7, 8, 9, 10⟩.
The reaction removes any element y which can be divided by another
one x. Initially several reactions are possible. For example, the pair
(2, 10) can be replaced by 2, the pair (3, 9) by 3 or (4, 8) by 4, etc.
The solution becomes inert when the rule cannot react with any pair of
integers in the solution; that is to say, when the solution contains only
prime numbers. Even if there are many possible executions, the result
of the computation in our example is always ⟨(replace x, y by x if x div
y), 2, 3, 5, 7⟩.
A molecule inside a solution cannot react with a molecule outside
the solution (the construct ⟨.⟩can be seen as a membrane). Reaction
rules can access the content of a sub-solution only if it is inert. This
important restriction allows the evaluation order to be controlled in
an otherwise highly non-deterministic and parallel model. All reactions
should be performed in a sub-solution before its content may be accessed
or extracted. So, the pattern ⟨P⟩matches only inert solutions whose
content matches the pattern P.
Rules can be named (or tagged) using the syntax
name = replace P by M if C.
Names are used to match and extract speciﬁc rules using the same syntax
(name = x). We often use the let operator to name rules and assume
that
let name = M in N
def
=
N[(name = M)/name]
that is, the occurrences of name in N are replaced by name = M.
We also often make use of the pattern ω which can match any molecule
or nothing. This pattern is very convenient to extract elements from a
solution.
Using all these features, the Eratosthenes’ sieve can be rewritten
in order to remove the n-shot reaction rule sieve at the end of the
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
33
computation:
let sieve = replace x, y by x if x div y in
let clean = one⟨sieve = x, ω⟩by ω in
⟨clean, ⟨sieve, 2, 3, 4, 5, 6, 7, 8, 9, 10⟩⟩
The reduction proceeds as follows:
⟨clean = . . . , ⟨sieve = . . . , 2, 3, 4, 5, 6, 7, 8, 9, 10⟩⟩
∗
−→
⟨clean = . . . , ⟨sieve = . . . , 2, 3, 5, 7⟩⟩
−→
⟨2, 3, 5, 7⟩
The reaction rule clean cannot be applied until the sub-solution is inert.
The rule sieve reacts until all primes are computed. Then, the one-shot
rule clean extracts the prime numbers and suppresses the reaction rule
sieve.
2.3 The basic coordination structures of HOCL
HOCL is a programming language that, as explained below, provides
some primitive coordination structures: namely, parallel execution,
mutual exclusion, the atomic capture and the serialization and paralleli-
zation of computations.
2.3.1 Parallel execution
When two reactions involve distinct tuples of elements, both reactions
can occur at the same time.
For example, when computing the sum of a multiset of integers:
⟨42, 6, 14, 5, 2, 8, 5, 42, 89, add = replace x, y by x + y⟩
several reactions involving the rule add may occur at the same time
provided that the couples of integers involved are distinct. Parallel
execution relies on a fundamental property of HOCL : mutual exclusion.
2.3.2 Mutual exclusion
The mutual exclusion property states that a molecule cannot take part
to several reactions at the same time. For example, several reactions can
occur at the same time in the previous solution (e.g. (42,89) at the same
time as (5,5), etc.). Without mutual exclusion, the same integer could
occur in several reactions at the same time. In this case, our previous
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

34
J.-P. Banˆatre, P. Fradet and Y. Radenac
program would not represent the sum of a multiset since, for example,
89 would be allowed to react with 2 and 6 and be replaced by 91 and 95.
2.3.3 Atomic capture
Another fundamental property of HOCL is the atomic capture. A
reaction rule takes all its arguments atomically. Either all the required
arguments are present or no reaction occurs. If all the required arguments
are present, none of them may take part in another reaction at the same
time.
Atomic capture is useful to express non-blocking programs. For
example, the famous dining philosophers problem can be expressed in
HOCL as follows. Initially the multiset contains N forks (i.e. N pairs
Fork:1, . . . , Fork:N) and the two following n-shot reaction rules eat and
think:
eat = replace Fork:f1, Fork:f2
by Phi:f1
if f2 = f1 + 1 mod N
think = replace Phi:f
by Fork:f, Fork:(f + 1 mod N)
if true
The eat rule looks for two adjacent forks Fork:f1 and Fork:f2 with
f2 = f1 + 1 mod N and “produces” the eating philosopher Phi:f1.
This reaction relies on the atomic capture property: the two forks are
taken simultaneously (atomicity) and this prevents deadlocks. The
think rule “transforms” an eating philosopher into two available forks.
This rule models the fact that any eating philosopher can be stopped
non-deterministically at anytime.
2.3.4 Serialization
A key motivation of chemical models in general, and HOCL in particular,
is to be able to express programs without any artiﬁcial sequentiality (i.e.
sequentiality that is not imposed by the logic of the algorithm). However,
even within this highly unconstrained and parallel setting, sequencing
of actions can be expressed. Sequencing relies on the fact that a rule
needing to access a sub-solution has to wait for its inertia. The reaction
rule will react after (in sequence) all the reactions inside the sub-solution
have completed.
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
35
The HOCL program that computes all the primes lower than a given
integer N can be expressed by a sequence of actions that ﬁrst computes
the integers from 1 to N and then applies the rule sieve:
⟨⟨iota, N⟩, thensieve⟩
where
thensieve = one⟨iota = r, x, ω⟩by sieve, ω
iota = replace x by x, x −1 if x > 1
sieve = replace x, y by x if x div y
The rule iota generates the integers from N to 1 using the notation x to
denote a distinguished (e.g. tagged) integer. The one-shot rule thensieve
waits for the inertia of the sub-solution. When it is inert, the generated
integers are extracted and put next to the rule sieve (iota and the tagged
integer 1 are removed). The wait for the inertia has serialized the iota
and sieve operations.
Most of the existing chemical languages share these basic features.
They all have conditional reactions with atomic capture of elements. On
the other hand, they usually do not address fairness issues.
2.4 Classical coordination in HOCL
In this section, we consider well known coordination mechanisms and
express them in HOCL. Most of them are communication patterns
between sequential processes. We ﬁrst show how to model such sequential
processes as chemical solutions. Then, we propose a chemical version
of communications using rendezvous, shared variables, Linda primitives
and Petri nets.
2.4.1 Sequential processes in HOCL
In order to represent sequential and deterministic processes in the
chemical model, we encode them at a fairly low level. For instance,
the program counter and addresses of instructions will be represented
explicitly. It should be clear that syntactic sugar could be used to express
sequential processes (and many subsequent communication schemes)
more concisely. However, for simplicity and uniformity reasons, we will
stick to pure and basic HOCL programs.
A process is a solution made of:
• a local store storing variables represented by pairs of the form
name:value;
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

36
J.-P. Banˆatre, P. Fradet and Y. Radenac
• a code represented by a sequence of instructions encoded by pairs
of the form address:instruction where address is an integer and
instruction is a reaction rule to modify local variables;
• a program counter PC:address recording the next instruction to be
executed.
A process is an inert solution that contains both the program to execute
and its local store. A reaction rule, named run, executes the current
instruction (i.e. the instruction pointed to by PC) of processes.
For example, the process P = {TEMP : = X; X : = Y; Y : =
TEMP; } that swaps the content of two variables X and Y is represented
by the sequence of instructions:
code ≡



1:⟨assign(TEMP, X)⟩,
2:⟨assign(X, Y)⟩,
3:⟨assign(Y, TEMP)⟩
where assign(A, B) is the rule
assign(A, B) ≡one A:a, B:b
by A:b, B:b
which performs the assignment A : = B.
Assuming an initial store where the local variables X, Y and TEMP
have the values 10, 23 and 0, respectively, the process P in its initial
state is represented by the solution
⟨P:⟨PC:1, X:10, Y:23, TEMP:0, code⟩, run⟩
with
run = replace p:⟨PC:a, a:⟨c⟩, ω⟩
by p:⟨PC:(a + 1), a:⟨c⟩, c, ω⟩
The run rule extracts the instruction pointed to by PC from the list of
instructions and increments the program counter. The rule representing
the instruction (i.e. c) reacts and modiﬁes the local store. When the
solution representing the process is inert again, the run rule can be
applied again. In our example, it is easy to convince oneself that the
solution will be rewritten into the ﬁnal inert solution
⟨P:⟨PC:4, X:23, Y:10, TEMP:10, code⟩, run⟩
Since there is no instruction at address 4, the run rule cannot react
anymore. Other instructions are easily deﬁned, for example:
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
37
• the neg rule
neg(A) ≡one A:a
by A:(not a)
corresponds to the statement A : = not A.
• the add rule
add(A, B, C) ≡one A:a, B:b, C:c
by A:(b + c), B:b, C:c
corresponds to the statement A : = B + C.
• the jmp instruction
jmp(b) ≡one PC:a
by PC:b
sets PC to a new address.
• the ncondJmp instruction
ncondJmp(B, b) ≡one PC:a, B:k
by B:k, PC:(if k then a else b)
sets PC to a new address or leaves it unchanged depending on the
value of the boolean variable B.
The run rule can be placed into a solution with several processes like:
⟨run, P1:⟨. . .⟩, . . . , Pn:⟨. . .⟩⟩
In the absence of the coordination rule, run will rewrite all processes
step by step potentially in parallel or non-deterministically. We now
describe coordination (communication, synchronization) instructions
between two (or more) processes. Contrary to standard imperative
instructions which are of the form a:⟨i⟩(i.e. within a solution), coordi-
nation instructions will be of the form a:i:x:y (i.e. in tuples). They
cannot be executed by the run rule. The coordination mechanism relies
on speciﬁc reaction rules taking as parameters all actors (processes,
shared variables, queues, etc.) involved in the interaction.
2.4.2 Rendezvous in HOCL
We consider concurrently executing processes communicating by atomic,
instantaneous actions called “rendezvous” (or sometimes, “synchronous
message passing”). If two processes are to communicate, and one reaches
the point at which it is ready to communicate ﬁrst, then it stalls until
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

38
J.-P. Banˆatre, P. Fradet and Y. Radenac
the other process is ready as well. The exchange (communication) is
atomic in that it is initiated and completed in a single uninterruptable
step. Examples of rendezvous models include Hoare’s communicating
sequential processes (CSP) [11] and Milner’s calculus of communicating
systems (CCS) [13].
Rendezvous models are particularly well suited to applications where
resource sharing is a key element, such as client–server database
models and multitasking or multiplexing of hardware resources. A key
feature of rendezvous-based models is their ability to cleanly model
non-determinate interactions.
In HOCL, the rendezvous is represented as an atomic capture of two
processes in a particular state. The sender should be ready to send
something and the receiver should be ready to receive. The rule runRdV,
below, implements a rendezvous communication in one atomic step:
runRdV = replace p1:⟨PC:a, a:send:p2:x, x:k, ω1⟩,
p2:⟨PC:b, b:recv:p1:y, y:l, ω2⟩
by p1:⟨PC:(a + 1), a:send:p2:x, x:k, ω1⟩,
p2:⟨PC:(b + 1), b:recv:p1:y, y:k, ω2⟩
The communication between two processes p1 and p2 takes place when
the active instruction of p1 is of the form send:p2:x (“send the value of
variable x to p2”) and the active instruction of p2 is of the form recv:p1:y
(“place the value received from p1 in variable y”). The value of x is
placed into y and both program counters are incremented.
Typically, a collection of sequential processes communicating by
rendezvous will be represented by a solution of the form:
⟨run, runRdV, P1:⟨. . .⟩, . . . , Pn:⟨. . .⟩⟩
The reaction run will execute (in parallel and non-deterministically)
processes unwilling to communicate. At the same time, runRdV will
execute (potentially several) pairs of processes waiting for a rendezvous.
2.4.3 Shared variables
Local variables are inside the solution representing the associated
process. Shared variables are represented by data in the top-level
solution containing the processes. For example, the shared variable X
whose value is 3 is represented as:
⟨. . . , Pi:⟨. . .⟩, . . . , X:3⟩
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
39
A shared variable is manipulated using two instructions:
• a:Wshare:X:Y which writes the value of the local variable Y in the
shared variable X;
• a:Rshare:X:Y which reads the value of the shared variable Y and
stores it in the local variable X.
The associated reaction rules are
runWshare = replace p:⟨PC:a, a:Wshare:x:y, y:k, ω⟩,
x:l
by p:⟨PC:(a + 1), a:Wshare:x:y, y:k, ω⟩,
x:k
runRshare = replace p:⟨PC:a, a:Rshare:x:y, x:k, ω⟩,
y:l
by p:⟨PC:(a + 1), a:Wshare:x:y, x:l, ω⟩,
y:l
To let processes communicate using shared variables A and B, the system
is represented by a solution of the form:
⟨run, runWshare, runRshare, P1:⟨. . .⟩, . . . , Pn:⟨. . .⟩, A:0, B:841⟩
Again, the atomic capture of reaction rules is key to ensure the
atomicity of the operations on shared variables. If several processes
want to write the same shared variable concurrently, an ordering will
be non-deterministically chosen.
2.4.4 Linda primitives in HOCL
The Linda model of communication [8] has mainly two operations, out
and in, that modify a unique data structure called a tuple space. The
operation out(X1: · · · :Xn) stores a tuple l1: · · · :ln (where li is the value
of the variable Xi) in the tuple space. The operation in(X1: · · · :Xn)
removes a tuple that matches the given tuple pattern. The tuple pattern
contains variable names or constants. A corresponding tuple must be
the same size and the constants must concur. Then, the ith variable Xi
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

40
J.-P. Banˆatre, P. Fradet and Y. Radenac
is assigned to the ith value. In HOCL these are implemented by the two
following reaction rules:
runLindaOut = replace p:⟨PC:a, a:out:r, ωP ⟩
by p:⟨PC:a, a:out:r, ωP ⟩,
r
runLindaIn = replace p:⟨PC:a, a:in:r, ωP ⟩
by p:⟨PC:a, a:in:r, ωP ⟩,
r
In both rules, the variable r stands for a one-shot rule that is extracted
to be executed. In a out-rule, r has the following form:
one p:⟨PC:a, a:out:r, X1:l1, . . . , Xn:ln, ωp⟩,
TS:⟨ω⟩
by p:⟨PC:(a + 1), a:out:r, X1:l1, . . . , Xn:ln, ωp⟩,
TS:⟨l1: . . . :ln, ω⟩
Conversely, in a in-rule, r has the following form:
one p:⟨PC:a, a:in:r, X1:l′
1, . . . , Xn:l′
n, ωp⟩,
TS:⟨l1: . . . :ln, ω⟩
by p:⟨PC:(a + 1), a:in:r, X1:l1, . . . , Xn:ln, ωp⟩,
TS:⟨ω⟩
The in and out operations are implemented in a two-step fashion. In the
ﬁrst step, the corresponding rule is extracted. The instruction name in
or out is converted to in or out to prevent a second shot, and the PC is
not incremented. In the second step, the extracted one-shot rule looks
for all the data it needs inside the process p (read or write variables)
and inside the tuple space TS (matched tuple). It increments the PC
and resets the instruction name to in or out.
The extracted one-shot rule corresponding to a in-rule is blocked until
a tuple matching l1: . . . :ln is found in the considered tuple space, and
so the corresponding process is blocked too. The pattern l1: . . . :ln may
contain variables and constants (e.g. 1:x).
Consider the server process of the Server–Clients example from [8]. A
server treats a stream of requests encoded as a triple (“request”, index,
data) in the tuple space. Starting from index 1, the server extracts such
a triple from the tuple space, assigns data to its local variable req, treats
the request and produces the result as a triple (“response”, index, data)
in the tuple space. The index is then incremented to treat the next
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
41
server()
{
int index = 1;
...
while (1) {
in("request", index, ? req);
...
out("response", index++, response);
}
}
Fig. 2.1. Server in C-Linda.
⟨run, runLindaIn, runLindaOut, TS:⟨⟩,
Server:⟨index:1,
PC:0,
req:0,
0:in:request,
. . .
n:out:response,
(n + 1):jmp(0)
⟩,
. . .
⟩
with
request = one Server:⟨PC:a, a:in:r, index:i, req:j, ωp⟩,
TS:⟨(“request”:i:X), ω⟩
by Server:⟨PC:(a + 1), a:in:r, index:i, req:X, ωp⟩,
TS:⟨ω⟩
response = one Server:⟨PC:a, a:out:r, index:i, req:j, ωp⟩,
TS:⟨ω⟩
by Server:⟨PC:(a + 1), a:out:r, index:(i + 1), req:X, ωp⟩,
TS:⟨(“response”:i:X), ω⟩
Fig. 2.2. Encoding of the C-Linda server into HOCL.
request. The C-Linda code implementing the server is shown in
Figure 2.1.
Figure 2.2 shows the encoding of this program into HOCL. The
sequential code of the process is similar. The in and out operations are
encoded using the two one-shot rules request and response. The rule
request
extracts a tuple of the form (“request”:i:X), where i is
the current index and assigns the data X to the local variable req. The
rule response stores a tuple of the form (“response”:i:X) where X is
the value of the local variable req and increments the current index i.
In both cases, the program counter is incremented and the in and out
instructions are reset to an executable form.
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

42
J.-P. Banˆatre, P. Fradet and Y. Radenac
2.4.5 Petri nets in HOCL
A Petri net [14] consists in places and transitions. A place may contain
any number of tokens. A transition takes some tokens from its input
places and produces tokens in its output places.
The notions of places and transitions are very close to the chemical
notions of solutions and reaction rules. We represent a place as a solution
of tokens ⟨Tok, Tok, . . .⟩and transitions as reaction rules rewriting
atomically input and output places. Places and transitions are named
Pi and tj, respectively. For example, a transition t1 taking two tokens
from P1 and producing one token into P2 is represented by the rule
t1 = replace P1:⟨Tok, Tok, ω1⟩, P2:⟨ω2⟩
by P1:⟨ω1⟩, P2:⟨Tok, ω2⟩
The main issue is that two transitions consuming tokens in the same
place (that has enough tokens) cannot be ﬁred simultaneously since a
sub-solution can only take part in one reaction at a time.
An alternative encoding, that allows two transitions with common
input places to be ﬁred concurrently is to represent a token in place Pi
as the constant Pi. All tokens are placed in the top-level solution and
the previous transition t1 would be expressed as:
t1 = replace P1, P1 by P2
The drawback of this encoding is to prevent the expression of inhibitor
arcs. An inhibitor arc from place P to t enables the transition t to ﬁre
only if no tokens are in the place P. Testing the absence of elements with
the second encoding is a global operation which cannot be expressed
as a single atomic rule. With the ﬁrst encoding, inhibitor arcs can be
encoded easily by testing whether a sub-solution is empty. For example:
t2 = replace P1:⟨Tok, ω1⟩, P2:⟨⟩, P3:⟨ω3⟩
by P1:⟨ω1⟩, P2:⟨⟩, P3:⟨Tok, ω3⟩
The Petri net shown in Figure 2.3 (taken from [14]) represents a readers–
writers synchronization, where the k tokens in place P1 represent k
processes which may read and write in a shared memory represented by
place P3. Up to k process may be reading concurrently, but when one
process is writing, no other process can be reading or writing.
The encoding of that Petri net in HOCL is the solution given in
Figure 2.4. Tokens are represented by constants, and the four transitions
are represented by four n-shot rules. For instance, the rule t2 takes and
removes one token P1 and k tokens P3, and generates one token P4.
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
43
Fig. 2.3. Petri net of a readers–writers synchronization.
let t1 = replace P1, P3 by P2 in
let t2 = replace P1, P3, . . . , P3



k
by P4 in
let t3 = replace P2 by P1, P3 in
let t4 = replace P4 by P1, P3, . . . , P3



k
in
⟨t1, t2, t3, t4, P1, P3, . . . , P3



k
⟩
Fig. 2.4. Encoding of the Petri net in HOCL.
2.5 Kahn Process Networks in a chemical setting
The Kahn Process Network (KPN) model of computation [12] assumes
a network of concurrent autonomous and deterministic processes
that communicate over unbounded FIFO channels. Communication is
asynchronous and point to point; it is based on a blocking read primitive
and a non-blocking send primitive. Each process in the network is
speciﬁed as a sequential program that executes concurrently with other
processes. A KPN is deterministic, meaning that the result of the
computation is independent of its schedule.
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

44
J.-P. Banˆatre, P. Fradet and Y. Radenac
2.5.1 A simple example
Gilles Kahn gave in [12] an example made out of the three following
sequential processes:
Process f(integer in U,V; integer out W) ;
Begin integer I ; logical B ;
B := true ;
Repeat Begin
I := if B then wait(U) else wait(V) ;
print (I) ;
send I on W ;
B := not B ;
End ;
End ;
Process g(integer in U ; integer out V, W ) ;
Begin integer I ; logical B ;
B := true ;
Repeat Begin
I := wait(U) ;
if B then send I on V else send I on W ;
B := not B ;
End ;
End ;
Process h(integer in U ; integer out V; integer INIT ) ;
Begin integer I ;
Repeat Begin
I := wait(U) ;
send I on V ;
End ;
End ;
A process writes the value of a local variable X on a channel C using
the command send X on C. It reads the channel C and stores the value
in the local variable X using the command X := wait(C).
The network is built using one instance of each process f and g and
two instances of process h (with its third parameter set to 0 and 1) and
connecting them using the FIFO channels X, Y, Z, T1 and T2. Using par
for the parallel composition, the network is speciﬁed as
f(Y,Z,X) par g(X,T1,T2) par h(T1,Y,0) par h(T2,Z,1) ;
A graphical representation of the complete network is given by Figure 2.5
where nodes represent processes and arcs communication channels
between processes.
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
45
Fig. 2.5. Graphical representation of the KPN example.
2.5.2 Chemical queues
In KPNs, communication between processes uses queues to implement
asynchronous communication. In HOCL, a queue can be represented by
a solution of pairs rank:value. That solution includes also two counters
CW (resp. CR) storing the rank to write (resp. to read) a value. Using the
operation send, a producer adds a value at the rank CW and increments
the counter CW. Using the operation wait, a consumer takes the value
at rank CR and increments the counter CR. The counters CW and CR
are always present in the solution representing the queue. Initially, the
queue is empty and both counters are equal.
The send X on C operation is represented in HOCL by the instruction
a:send:C:X and X := wait(C) by a:wait:C:X. The corresponding rules
are:
runSend = replace p:⟨PC:a, a:send:q:u, u:k, ω⟩,
q:⟨CW:cw, ωQ⟩
by p:⟨PC:(a + 1), a:send:q:u, u:k, ω⟩,
q:⟨CW:(cw + 1), cw:k, ωQ⟩
runWait = replace p:⟨PC:a, a:wait:q:u, u:k, ω⟩,
q:⟨CR:cr, cr:l, ωQ⟩
by p:⟨PC:(a + 1), a:wait:q:u, u:l, ω⟩,
q:⟨CR:(cr + 1), ωQ⟩
The instructions send and wait can be seen as a rendezvous between
a process p and a queue q. That implementation supports unbounded
queues but does not allow a producer and a consumer to access the same
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

46
J.-P. Banˆatre, P. Fradet and Y. Radenac
queue at the same time. We present other possible encoding at the end
of the section.
2.5.3 Chemical KPNs
Typically, a KPN is represented by several sequential processes and
queues in the main solution. The solution contains also the three
reaction rules run, runSend and runWait which can be performed at
the same time (as long as they do not involve the same queues or
processes). Chemical reactions make the network evolve according a
unspeciﬁed, non-deterministic and parallel schedule. The only synchro-
nization constraints are enforced by queues. Of course, even if there is
much potential interleaving, the functional semantics of chemical KPNs
is deterministic.
The example of Section 2.5.1 can be written in HOCL using the
previous encoding for sequential commands (see Section 2.4.1) and
queues as follows:
processF(u, v, w) ≡
⟨PC:0,
I:0, B:true,
0:⟨ncondJmp(B, 3)⟩,
1:wait:u:I,
2:⟨jmp(4)⟩,
3:wait:v:I,
4:⟨print, I⟩,
5:send:w:I,
6:⟨neg(B)⟩,
7:⟨jmp(0)⟩⟩
processG(u, v, w) ≡
⟨PC:0,
I:0, B:true,
0:wait:u:I,
1:⟨ncondJmp(B, 4)⟩,
2:send:v:I,
3:⟨jmp(5)⟩,
4:send:w:I,
5:⟨neg(B)⟩,
6:⟨jmp(0)⟩⟩
processH(u, v, init) ≡
⟨PC:0,
I:0,
0:send:v:init,
1:wait:u:I,
2:send:v:I,
3:⟨jmp(1)⟩⟩
The processes have local variables (I and B, or just I) and their
program counter set to 0. The network of Figure 2.5 is represented by
the following solution:
⟨processF(Y, Z, X), processG(X, T1, T2),
processH(T1, Y, 0), processH(T2, Z, 1),
Y:⟨CW:0, CR:0⟩, Z:⟨CW:0, CR:0⟩, X:⟨CW:0, CR:0⟩,
T1:⟨CW:0, CR:0⟩, T2:⟨CW:0, CR:0⟩,
run, runWait, runSend⟩
The solution is made of four instances of processes, ﬁve queues (initially
empty), and the reaction rules implementing sequential execution (run)
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
47
and communication (runWait, runSend). Our implementation remains
close to the original example, the key diﬀerence being that sequential
execution and communications are made explicit by reaction rules.
2.5.4 Other implementations of queues
We conclude our study of KPNs by presenting some other possible
implementations of queues in the same chemical framework.
Bounded queues A bounded queue is a solution q:n:⟨. . .⟩tagged
by its name q and maximum size n. If a queue is bounded, the
corresponding counters are incremented modulo its maximum size n.
The rule runSendB is now a blocking primitive since it may only react
when the queue is not full:
runSendB = replace p:⟨PC:a, a:send:q:u, u:k, ω⟩,
q:n:⟨CW:cw, CR:cr, ωQ⟩
by p:⟨PC:(a + 1), a:send:q:u, u:k, ω⟩,
q:n:⟨CW:(cw + 1) mod n, CR:cr, cw:k, ωQ⟩
if (cw + 1) mod n ̸= cr
runWaitB = replace p:⟨PC:a, a:wait:q:u, u:k, ω⟩,
q:n:⟨CR:cr, cr:l, ωQ⟩
by p:⟨PC:(a + 1), a:wait:q:u, u:l, ω⟩,
q:n:⟨CR:(cr + 1) mod n, ωQ⟩
The queue is full when the next free rank (CW + 1) is equal modulo n
to CR. In this case, the send operation blocks.
Non-exclusive queues When a queue is represented by a sub-solution,
it cannot react simultaneously with several processes, especially between
one producer and one consumer. In this case, using independent atoms
to represent a queue solves this problem and the representations of all
queues are mixed together. The two counters of a queue are tagged by
the name of the queue (CW:q:cw, CR:q:cr ). The values are also tagged
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

48
J.-P. Banˆatre, P. Fradet and Y. Radenac
and are represented as triples q:r:v (name of queue, rank, value). The
reaction rules implementing writing and reading become:
runSendNEx = replace p:⟨PC:a, a:send:q:u, u:k, ω⟩,
CW:q:cw
by p:⟨PC:(a + 1), a:send:q:u, u:k, ω⟩,
CW:q:(cw + 1), q:cw:k
runWaitNEx = replace p:⟨PC:a, a:wait:q:u, u:k, ω⟩,
CR:q:cr, q:cr:l
by p:⟨PC:(a + 1), a:wait:q:u, u:l, ω⟩,
CR:q:(cr + 1)
These operations are no longer rendezvous with the queue but instead
with the counter CW for runSendNEx and the counter CR and an
individual value for runWaitNEx. The same queue can be written and
read at the same time as long as it has at least one value.
2.6 Conclusion
Originally, the Gamma formalism was invented as a basic paradigm
for parallel programming [6]. It was proposed to capture the intuition
of a computation as the global evolution of a collection of atomic
values evolving freely. Gamma appears as a very high level language
which allows programmers to describe programs in a very abstract way,
with minimal constraints and no artiﬁcial sequentiality. In fact, from
experience, it is often much harder to write a sequential program in
Gamma than a parallel one. Later, it became clear that a necessary
extension to this simple formalism was to allow elements of a multiset
to be Gamma programs themselves, thus introducing higher order. This
led to the HOCL language used in this paper.
The idea behind the present paper was to show how traditional
coordination mechanisms can be readily described in a chemical setting.
Basically, the chemical paradigm (as introduced in HOCL) oﬀers four
basic properties: mutual exclusion, atomic capture, parallelization
and serialization. We have exploited these properties in order to give
a chemical expression of well known coordination schemes. After
presenting how to encode sequential processes as chemical solutions,
we have expressed the CSP rendezvous, shared variables, Linda’s
primitives, Petri nets and Kahn Process Networks in HOCL. All these
examples put forward the simplicity and expressivity of the chemical
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

Coordination in the chemical model
49
paradigm. A natural research direction would be to complete and use
these descriptions in the same chemical framework to compare and
classify the diﬀerent coordination schemes.
The chemical paradigm has been used in several other areas. For
example, an operating system kernel [15] has been speciﬁed in Gamma
and proved correct in a framework inspired by the Unity logic [9]. The
system is represented as a collection of quadruples (Pi, Si, Mi, Ci) where
Si, Mi, and Ci represent, respectively, the state, the mailbox and the
channel associated with process Pi. The Pi’s are functions called by the
system itself. The system includes rules such as
replace(Pi, Si, Mi, Ci) by(P ′
i, S′
i, M ′
i, C′
i) if Ready(Pi, Si)
An important aspect of this work is the derivation of a ﬁle system
(written in Gamma) by successive reﬁnements from a temporal logic
speciﬁcation.
More recently, we have used HOCL to specify autonomic systems [5].
Such self-organizing systems behave autonomously in order to maintain
a predetermined quality of service which may be violated in certain
circumstances. Very often, such violations may be dealt with by applying
local corrections. These corrections are easily expressed as independent
HOCL reaction rules. Comparisons with models related to HOCL and
the underlying γ-calculus may be found in [4]. We do not come back on
these comparisons here.
As a ﬁnal comment, let us point out that, unlike Gamma, HOCL allows
reaction rules (programs) to be elements of multisets, to be composed by
taking (resp. returning) reactions as parameters (resp. result) and to be
recursive (as expressed by the replace rule). In that sense, it complies
with the principle stated in the conclusion of Gilles’s paper [12]:
“A good concept is one that is closed under arbitrary composition and under
recursion.”
Acknowledgements
Thanks are due to the anonymous reviewers for their comments and
suggestions.
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

50
J.-P. Banˆatre, P. Fradet and Y. Radenac
Bibliography
[1]
J.-P. Banˆatre, P. Fradet, J.-L. Giavitto and O. Michel (eds). Unconven-
tional Programming Paradigms (UPP’04), volume 3566 of Lecture Notes in
Computer Science, Revised Selected and Invited Papers of the International
Workshop, 2005. Springer-Verlag.
[2]
J.-P. Banˆatre, P. Fradet and D. Le M´etayer. Gamma and the chemical
reaction model: Fifteen years after. In Multiset Processing, volume 2235 of
Lecture Notes in Computer Science, pp. 17–44. Springer-Verlag, 2001.
[3]
J.-P. Banˆatre, P. Fradet and Y. Radenac. Principles of chemical
programming. In S. Abdennadher and C. Ringeissen (eds), Proceedings of
the 5th International Workshop on Rule-Based Programming (RULE 2004),
volume 124 of ENTCS, pp. 133–147. Elsevier, June 2005.
[4]
J.-P. Banˆatre, P. Fradet and Y. Radenac. Generalised multisets for
chemical programming. Mathematical Structures in Computer Science,
16(4):557–580, 2006.
[5]
J.-P. Banˆatre, P. Fradet and Y. Radenac. Programming self-organizing
systems with the higher-order chemical language. International Journal of
Unconventional Computing, 2007.
[6]
J.-P. Banˆatre and D. Le M´etayer. Programming by multiset transfor-
mation. Communications of the ACM (CACM), 36(1):98–111, 1993.
[7]
G. Berry and G. Boudol. The chemical abstract machine. Theoretical
Computer Science, 96:217–248, 1992.
[8]
N. Carriero and D. Gelernter. Linda in Context. Communications of the
ACM, 32(4):444–458, 1989.
[9]
K. Mani Chandy and J. Misra. Parallel Program Design : A Foundation.
Addison-Wesley, 1988.
[10]
C. Fournet and G. Gonthier. The reﬂexive CHAM and the join-calculus.
In Proceedings of the 23rd ACM Symposium on Principles of Programming
Languages, pp. 372–385. ACM Press, 1996.
[11]
C. A. R. Hoare. Communicating sequential processes. Communications
of the ACM, 21(8):666–677, 1978.
[12]
G. Kahn. The semantics of a simple language for parallel programming.
Information Processing, 74:471–475, 1974.
[13]
R. Milner. A Calculus of Communicating Systems, volume 92 of Lecture
Notes in Computer Science. Springer-Verlag, 1980.
[14]
T. Murata. Petri nets: Properties, analysis and applications. Proceedings
of the IEEE, 77(4):541–580, 1989.
[15]
H. R. Barradas. Une approche `a la d´erivation formelle de syst`emes en
Gamma. PhD thesis, Universit´e de Rennes 1, France, 1993.
https://doi.org/10.1017/CBO9780511770524.003 Published online by Cambridge University Press

