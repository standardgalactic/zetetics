 
ONTOLOGY-BASED CUSTOMIZABLE 3D MODELING FOR SIMULATION 
 
 
 
 
 
 
 
 
 
 
 
 
 
By 
 
MINHO PARK 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
A DISSERTATION PRESENTED TO THE GRADUATE SCHOOL 
OF THE UNIVERSITY OF FLORIDA IN PARTIAL FULFILLMENT 
OF THE REQUIREMENTS FOR THE DEGREE OF 
DOCTOR OF PHILOSOPHY 
 
UNIVERSITY OF FLORIDA 
 
2005 

 
 
 
Copyright 2005 
 
by 
 
Minho Park 
 
 
 
 
 
 

 
 
 
To my parents, my lovely wife Suwon, and our daughter Emily 
 
 
 

 
ACKNOWLEDGMENTS 
I would like to express my deepest gratitude to my advisor, Dr. Paul A. Fishwick, 
who gave me inspiration and guidance throughout my Ph.D. studies at the University of 
Florida. I would also like to give my sincere appreciation to my Ph.D. committee 
members, Dr. Joachim Hammer, Dr. Beverly Sanders, Dr. Sherman Bai, and Dr. 
Abdelsalam A. Helal, for their precious time and advice for my research. 
I appreciate all the colleagues in our research group for sharing valuable ideas. 
Special thanks go to Jinho Lee and Hyunju Shim for their help and companionship. 
Also, I am grateful to the National Science Foundation and the Air Force Research 
Laboratory for their financial support for my studies in the United States. 
I owe great love to my parents, who prayed for and encouraged me throughout my 
studies, and my wife, Suwon, and my daughter, Emily (Soyeon), who shared all the 
wonderful and difficult moments with me here in Gainesville. They are the reason for my 
existence. 
 
 
iv 

 
TABLE OF CONTENTS 
 
 
page 
ACKNOWLEDGMENTS ................................................................................................. iv 
LIST OF TABLES........................................................................................................... viii 
LIST OF FIGURES ........................................................................................................... ix 
ABSTRACT...................................................................................................................... xii 
CHAPTER 
1 INTRODUCTION ............................................................................................................1 
1.1 Motivations and Challenges ...................................................................................1 
1.2 Contributions to Knowledge...................................................................................3 
1.2.1 Provide an Integrated Modeling and Simulation Environment....................3 
1.2.2 Ontology Management and Model Database Construction..........................4 
1.2.3 Present an Interaction Model Concept .........................................................6 
1.2.4 Improvements in the Visual Model Construction ........................................7 
1.3 Organization of the Dissertation.............................................................................9 
2 BACKGROUND ............................................................................................................10 
2.1 Dynamic Models...................................................................................................10 
2.2 RUBE: An XML-based 2D and 3D Modeling Framework for Simulation..........12 
2.3 Ontology ...............................................................................................................18 
3 INTEGRATIVE MULTIMODELING...........................................................................22 
3.1 Approach...............................................................................................................22 
3.1.1 Aircraft Class..............................................................................................24 
3.1.2 Sensors Class..............................................................................................26 
3.1.3 Process and Display Classes.......................................................................27 
3.1.4 Geometry Model, Dynamic Model, and Information Model Classes ........28 
3.1.5 Interaction Model Class..............................................................................28 
3.1.6 Summary.....................................................................................................29 
3.2 Methodology.........................................................................................................30 
4 IMPLEMENTATION.....................................................................................................32 
v 

4.1 Overview...............................................................................................................32 
4.2 Ontology: A Framework for Encoding Modeling Knowledge.............................33 
4.2.1 Classes ........................................................................................................36 
4.2.2 Properties....................................................................................................37 
4.3 Blender Interface ..................................................................................................39 
4.3.1 Model Architecture.....................................................................................40 
4.3.2 Model Explorer...........................................................................................43 
4.3.3 Ontology Explorer......................................................................................46 
4.3.4 Export .........................................................................................................51 
4.3.5 Simulation...................................................................................................52 
4.2.6 Blender Game Logic...................................................................................54 
5 CASE STUDY................................................................................................................55 
5.1 A Military Application .........................................................................................55 
5.1.1 Modeling for Geometry and Dynamic Models ..........................................56 
5.1.2 Modeling for Interaction Model .................................................................57 
5.1.3 Code Generation.........................................................................................60 
5.1.4 Integrative Multimodeling with Simulation ...............................................63 
5.2 A Light Bulb Application.....................................................................................65 
5.2.1 Ontology.....................................................................................................66 
5.2.2 Modeling for Geometry and Dynamic Models ..........................................68 
5.2.3 Modeling for Interaction Model .................................................................69 
5.2.4 Code Generation.........................................................................................71 
5.2.5 Integrative Multimodeling with Simulation ...............................................72 
6 CONCLUSION...............................................................................................................75 
6.1 Summary of Results..............................................................................................75 
6.2 Future Research ....................................................................................................77 
6.2.1 Ontological Domain Extension ..................................................................77 
6.2.2 Model Type Extension ...............................................................................80 
6.2.3 Interface Construction ................................................................................81 
6.2.4 Visual Programming Support.....................................................................81 
APPENDIX 
A BLENDER INTERFACE SOURCE .............................................................................82 
A.1 Graphical User Interface......................................................................................82 
A.2 MXL Creation......................................................................................................85 
A.3 OWL Management ..............................................................................................91 
A.4 Snap to Grid.........................................................................................................98 
B LIGHT BULB EXAMPLE SOURCES .......................................................................107 
B.1 DXL ...................................................................................................................107 
B.2 Simulation Code in Python ................................................................................110 
vi 

C OWL AND XSLT SOURCES.....................................................................................134 
C.1 Example 1: Battle Scene ....................................................................................134 
C.2 Example 2: Light Bulb.......................................................................................137 
C.3 Combined OWL: FSM and Scene Ontologies...................................................140 
C.4 Parser in XLST...................................................................................................146 
LIST OF REFERENCES.................................................................................................149 
BIOGRAPHICAL SKETCH ...........................................................................................155 
 
 
vii 

 
LIST OF TABLES 
Table  
page
 
2-1. Mapping Rules............................................................................................................20 
4-1. Properties....................................................................................................................38 
 
 
 
viii 

 
LIST OF FIGURES 
Figure  
page
 
2-1. Declarative Model ......................................................................................................11 
2-2. Functional Model........................................................................................................11 
2-3. RUBE Framework......................................................................................................13 
2-4. An FSM Describing a Four-Stroke Gasoline Engine [25] .........................................14 
2-5. MXL Representation (FBM) for the Example ...........................................................15 
2-6. MXL Representation (FSM) for the Four-Stroke Gasoline Engine ...........................16 
2-7. DXL Representation for the Four-Stroke Gasoline Engine........................................17 
2-8. Simulation Output from the 2D Engine Model ..........................................................18 
2-9. Simulation Results......................................................................................................18 
2-10. A Primitive FSM Ontology ......................................................................................19 
2-11. OWL Representation for the FSM............................................................................20 
3-1. Scene Ontology...........................................................................................................24 
4-1. The Overall Structure for the Integrative Multimodeling Environment.....................33 
4-2. Scene Ontology...........................................................................................................34 
4-3. OWL Representation..................................................................................................35 
4-4. Class Definitions in Protégé .......................................................................................37 
4-5. Property Definitions in Protégé..................................................................................38 
4-6. Blender Environment..................................................................................................40 
4-7. Model Architecture.....................................................................................................41 
4-8. FSM with Tank-Pipe Metaphor..................................................................................42 
ix 

4-9. FSM with Primitives...................................................................................................42 
4-10. A Snapshot of Model Explorer.................................................................................44 
4-11. Point a Source and a Target Objects.........................................................................45 
4-12. Select a Connection Object.......................................................................................45 
4-13. Connection................................................................................................................45 
4-14. Select a Connection Object.......................................................................................46 
4-15. Connection................................................................................................................46 
4-16. A Snapshot of Ontology Explorer ............................................................................47 
4-17. Pop-Up Menu ...........................................................................................................48 
4-18. Instance Creation......................................................................................................49 
4-19. hasDynamic Property Creation.................................................................................49 
4-20. hasGeometry Property Creation ...............................................................................49 
4-21. File Name and Location Specification .....................................................................50 
4-22. New Instance ............................................................................................................50 
4-23. Import Process..........................................................................................................51 
4-24. GUI for Export..........................................................................................................52 
4-25. MXL and Function Definitions for the Example......................................................52 
4-26. GUI for Simulation...................................................................................................53 
4-27. Blender Game Logic.................................................................................................54 
5-1. 2D Dynamic FBM Representation of the Combat Scene...........................................56 
5-2. 2D Dynamic Model (FBM) Representation of Interaction Model.............................58 
5-3. Interaction Model for the F15 (Geometry Object) .....................................................59 
5-4. Interaction Model for the F15 (Dynamic Object).......................................................59 
5-5. MXL for the Example.................................................................................................61 
5-6. DXL for the Example .................................................................................................62 
x 

5-7. Initial Scene (Geometry Model).................................................................................63 
5-8. Scene Prior to Interaction ...........................................................................................64 
5-9. Model Morphing.........................................................................................................64 
5-10. Dynamic Model........................................................................................................64 
5-11. Light Bulb.................................................................................................................65 
5-12. FSM Representation for the Light Bulb Example....................................................66 
5-13. Multimodel Representation for the Light Bulb Example.........................................66 
5-14. Light Bulb Ontology.................................................................................................67 
5-15. 2D Dynamic Model (FBM) Representation of Interaction Model...........................69 
5-16. Interaction Model for State 3....................................................................................70 
5-17. MXL for the Example...............................................................................................71 
5-18. MXL for FSM...........................................................................................................72 
5-19. Scene Prior to Interaction (Geometry Model)..........................................................73 
5-20. Model Morphing.......................................................................................................73 
5-21. Dynamic Model........................................................................................................73 
5-22. Two Model Types (Geometry and Dynamic Models)..............................................74 
6-1. Extended OWL Representation..................................................................................78 
 
 
xi 

 
Abstract of Dissertation Presented to the Graduate School 
of the University of Florida in Partial Fulfillment of the 
Requirements for the Degree of Doctor of Philosophy 
ONTOLOGY-BASED CUSTOMIZABLE 3D MODELING FOR SIMULATION 
By 
Minho Park 
May, 2005 
Chair:  Paul A. Fishwick 
Major Department:  Computer and Information Science and Engineering 
Modeling techniques tend to be found in isolated communities: geometry models in 
computer-aided design (CAD) and computer graphics, dynamic models in computer 
simulation, and information models in information technology. When models are 
included within the same digital environment, the ways of connecting them together 
seamlessly and visually are not well known even though elements from each model have 
many commonalities. We attempt to address this deficiency by studying specific ways in 
which models can be interconnected within the same 3D space. For example, consider 
this scenario: a region with several key military vehicles and targets: planes (both fighter 
as well as command and control center), surface-to-air missile (SAM) sites, and drones. 
A variety of models define the geometry, information, and dynamics of these objects. 
Ideally, we can explore and execute these models within the 3D scene by formalizing 
domain knowledge and providing a well-defined methodology.
We present a modeling and simulation methodology called integrative 
multimodeling. The purpose of integrative multimodeing is to provide a human-computer 
xii 

interaction environment that allows components of different model types to be linked to 
one another—most notably dynamic models used in simulation to geometry models for 
the phenomena being modeled. In the context of integrative multimodeling, the following 
general issues naturally arise: 1) “How can we connect different model components?”; 2) 
“How can we visualize different model types in 3D space?”; and 3) “How can we 
simulate a dynamic model within the integrative multimodeling environment?”  
For the first issue, we have defined a formalized scene domain to bridge semantic 
gaps between the different models and facilitate mapping processes between the 
components of the different models by conceptualizing all objects existing in the scene 
domain using semantic languages and tools. 
For the second issue, we have developed a Python-based interface to provide 
visualization environments. Using the interface, users can visualize and create their own 
model types as well as construct a model component database. 
For the third issue, we have employed the RUBE framework, which was developed 
by the Graphics, Modeling and Arts (GMA) Laboratory at the University of Florida. 
RUBE is an extensible markup language (XML)-based Modeling and Simulation 
framework and application, which permits users to specify and simulate a dynamic 
model, with an ability to customize a model presentation using 2D or 3D visualizations. 
In addition, human-computer interactions are needed to achieve integrative 
multimodeling between multiple models. To facilitate the integrative multimodeling, the 
interactions should be formalized and executable in the environment. Therefore, the 
concept of interaction model for integrative multimodeling is created and represented as a 
function block model (FBM) for formalizing human-computer interactions.  
xiii 

This work to date has resulted in an environment permitting users to explore 
dynamic model structure through interactions with geometric scene structure.  
 
 
 
xiv 

CHAPTER 1 
INTRODUCTION 
1.1 Motivations and Challenges 
A model is a simplified representation of the real entity created in order to increase 
our understanding of that entity. Modeling is the process of making the model. Various 
modeling techniques and methodologies have been introduced and applied to real-world 
applications in isolated communities, such as computer graphics and CAD, computer 
simulation, and information technology.  In computer graphics and CAD, researchers 
focus on geometric modeling methods [1, 2], and on system behavioral modeling 
approaches [3-6] in computer simulation and information modeling approaches [7, 8] in 
information technology.  
Even though researchers in diverse areas have their own distinct modeling 
environments and concepts, they commonly describe a real world based on different 
perspectives under different environments (interfaces) with different storage systems. 
Through the modeling process, the real world could be expressed in diverse model types, 
such as a geometry model, a dynamic model, or an information model. Ideally, we can 
explore and execute these models within a unified 3D scene that integrates diverse 
models. 
Our research was started by posing five general questions:  
1. 
Is there any way we can include different model types within the same 
environment? 
2. 
How can we connect them together seamlessly, visually, and effectively? 
1 

2 
3. 
How can we overcome semantic heterogeneity between the models? 
4. 
How can we manage modeling knowledge?  
5. 
How can we control the model presentations under the environment?  
We found that the ability to create customized 3D models, effective ontology 
construction, and human computer interaction (HCI) techniques [9-11] help to blend and 
stitch together different model types. 
We present a new modeling and simulation methodology called integrative 
multimodeling [12-14]. The purpose of integrative multimodeling is to provide a human 
computer interaction environment that allows components of different model types to be 
linked to one another.  
To support integrative multimodeling, the open source 3D Blender software is 
employed as a comprehensive modeling and simulation tool [15-17]. An ontology web 
language (OWL) [18], which is a language for processing web information, is used to 
bridge semantic gaps between the different models, facilitate mapping processes between 
the components of the different models, construct a model component database, and 
manage modeling knowledge.  
In addition, we introduce an interaction model for human computer interactions. 
The interaction model can be implemented and executed within a Blender environment or 
a virtual reality modeling language (VRML) environment.  
To construct and simulate dynamic models, we use the RUBE framework, which is 
an XML-based modeling and simulation tool [19-22] developed by our research group. In 
RUBE, two XML languages, multimodel exchange language (MXL) [23] and dynamic 
exchange language (DXL) [24], were designed to capture the semantic content for the 
dynamic models.  
 

3 
1.2 Contributions to Knowledge 
1.2.1 Provide an Integrated Modeling and Simulation Environment 
In the area of modeling and simulation, Dynamic and Static models can be defined 
as one of the model classifications [25-27]. A dynamic model, which is compared with a 
static model, represents a system as model variables in the system evolve over time. We 
can represent the dynamic behaviors as one of the model types, such as functional block 
model (FBM), finite state model (FSM), equation model, system dynamics model, or 
queuing model. On the other hand, a variety of geometric model types are classified in a 
graphics and CAD community. For example, boundary representations, constructive solid 
geometry (CSG), and wireframe models are used to represent geometric models [28-30].  
Ideally, we can blend and stitch together different model types so that users or 
modelers can explore and execute these models within a unified 3D scene. We started to 
investigate ways in which we can integrate geometry and dynamic models within the 
same scene environment. As a result, an integrated modeling and simulation environment 
for geometry and dynamic models has been developed for supporting the viewing and 
interaction associated with multiple models under a Blender 3D environment and 
simulating a dynamic model as well as animating a geometry model in the same digital 
environment. To build up the integrated environment, Blender Interface, Blender Game 
Engine, and RUBE framework are employed. 
As a related work, LabVIEW [31] is a fully featured graphic-based application 
development tool produced by National Instruments. It has been used for visualizing data 
flow as well as analyzing and controlling data by providing Vision Development and 
Real-Time modules. However, LabVIEW can only support 2D-based graphical 
environment and does not provide a module for handling ontologies. 
 

4 
1.2.2 Ontology Management and Model Database Construction 
An ontology represents a formal conceptualization of a domain. Ontology 
languages, such as resource description framework (RDF) [32, 33] and OWL, and tools, 
such as Protégé [34, 35] and semantic web ontology overview and perusal (SWOOP) 
[36], have been developed for representing knowledge and information about a certain 
specific domain.  
We developed the ontology management tool, Ontology Explorer, for manipulating 
an ontology by allowing users to create class instances for constructing a model 
component database and to generate classes or subclasses within the OWL–based 
ontology for managing the OWL ontology without leaving the environment. In addition, 
Ontology Explorer provides an alternate modeling process for geometry and dynamic 
models by reusing geometry and dynamic model objects. The brief reviews for ontology 
and ontology-related work are necessary to understand Ontology Explorer. 
The Semantic Web [37] technologies, such as ontology languages involving RDF, 
resource description framework-schema (RDF-S) [38], and OWL, are employed in a 
variety of communities to share or exchange the information, as well as to deal with 
semantic gaps between different domains. In the information systems community, 
including the database systems community, ontologies are used to achieve semantic 
interoperability in heterogeneous information systems by overcoming structural 
heterogeneity and semantic heterogeneity between the information systems [39-42]. In a 
simulation and modeling community, Miller, Sheth, and Fishwick propose the Discrete-
event Modeling Ontology (DeMO) [43, 44] to facilitate modeling and simulation. To 
represent core concepts in the discrete-event modeling domain, they define four main 
abstract classes in the ontology: DeModel, ModelConcepts, ModelComponents and 
 

5 
ModelMechanisms. The DeModel class defines general model types such as Petri-Net and 
Markov. Corresponding model elements are described in ModelComponents using “has-
a” relationships. In ModelConcepts, they define fundamental concepts used in 
constructing dynamic models such as State, Event, and Tokens. Diverse modeling 
techniques, such as Event-based and Transition-based, are conceptualized in 
ModelMechanisms. The DeMO is general domain-based ontology for discrete-event 
modeling, while our scene ontology is application-based and instance-based for 
integrative multimodeling, which will be shown in the next section. Liang and Paredis 
[45] define a port ontology to capture both syntactic and semantic information for 
allowing modelers to reason about the system configuration and corresponding 
simulation models. 
As OWL-based ontology editor tools, Protégé and SWOOP are used for 
development of OWL ontologies. Protégé editor is a powerful tool which allows users to 
construct a domain ontology and create instances of OWL classes. And many plug-ins 
such as ezOWL [46] and OntoViz [47] support the Protégé editor. On the other hand, 
SWOOP is a web-based development tool for ontologies. It is a simple and handy tool 
compared to Protégé editor. However, it does not support the functionality for instance 
creation.  
We create OWL-based ontologies to define application domains and modeling 
knowledge, to bridge semantic gaps between the different models, and to facilitate 
mapping processes between the components of the different models. And Ontology 
Explorer has been developed for supporting a modeling and simulation process within the 
Blender environment and providing functionality of ontology editor. 
 

6 
The distinct points, compared to any other related work in a simulation and 
modeling community, are that 1) the OWL-based ontologies are used for building a 
model component repository (i.e., Model Database) for geometry and dynamic models to 
increase reusability of model components, and 2) Ontology Explorer has an ontology 
editor functionality. 
1.2.3 Present an Interaction Model Concept  
Human-computer interactions are needed to achieve the integrative multimodeling 
environment. To facilitate the integrative multimodeling, the interactions should be 
formalized and executable in the Blender environment. Therefore, the concept of 
interaction model is created and represented as a function block model (FBM) for 
formalizing human-computer interactions. And Blender logic graphs are utilized for 
modeling the interaction model and executing the model.  
HCI techniques play an important role in integrative Multimodeling to connect and 
visualize different model types together seamlessly within the same digital environment. 
Many techniques are being used for supporting user interactions in 3D space. If we 
consider a desktop-based interaction environment, the keyboard and mouse are the 
primary interaction devices. Therefore, interaction methods should be sensor-based or 
scripting-based. Using the interaction devices and interaction methods, modelers or users 
visualize or navigate their 3D worlds. Diverse interaction methods are found in the 
literature, such as toolbar-based, Windows-based, button-based, or scripting-based user 
interactions. For example, Campbell and his colleagues [48] have developed a virtual 
geographical information system (GIS) using GeoVRML and Java 3D software 
development packages. They employ a menu bar and toolbars for ease of use because 
most users immediately understand how to use the menu bar and toolbars. Cubaud and 
 

7 
Topol [49] present a VRML-based user interface for a virtual library, which applies 2D 
Windows-based interface concepts to a 3D world. They allow users to move, minimize, 
maximize, or close Windows by dragging and dropping them or by pushing a button, 
which is usually provided in a traditional Windows system environment. Lin and Loftin 
[50] provide a functional virtual reality (VR) application for geoscience visualization. 
They employ virtual button and bounding box concepts to interact with geoscience data. 
If interaction is needed, all the control buttons on the frame can be visible; otherwise they 
are set to be invisible so that the frame simply acts as the reference outside the bounding 
box. Hendricks, Marsden, and Blake [51] present a VR authoring system. The system 
provides three main modules, graphics, scripting, and events modules, for supporting 
interactions. If we consider all interaction methods previously described, the possible 
interaction ways within a desktop-based environment are “Virtual Button,” “Windows,” 
and “scripting-based interaction” approaches. In the “Virtual Button” and “Windows” 
cases, we can implement the concepts using “touch sensor” or “IndexedFaceSet.” If we 
employ an additional technology, such as Hypertext Preprocessor in VRML, “scripting-
based interaction” could be a possible method.  
The open source Blender package provides powerful sensor-based interaction 
methods. In Chapter 5, we will introduce and explain the sensor-based interaction 
approaches using two examples.  
1.2.4 Improvements in the Visual Model Construction 
RUBE, which is developed by the Modeling and Simulation Research Group 
within the Graphics, Modeling and Arts (GMA) Laboratory at the University of Florida, 
provides a web-based Modeling and Simulation environment that enables modelers to 
define, create, and execute a customized or personalized dynamic model, such as a finite 
 

8 
state machine (FSM), a functional block model (FBM), or a multimodel containing 
multiple dynamic models (i.e., FBM and FSM). However, the primary disadvantage of 
RUBE is that it is a little cumbersome to build models. It does not have library concepts 
for model components and functions. Whenever users want to build their models in the 
RUBE environment, they have to create model objects and the corresponding functions in 
every modeling process even though objects and functions are frequently used in 
modeling process. Another problem is the issue of topological connectivity, which must 
be manually specified in modeling process. A solution is to induce the topology from the 
geometry using an intelligent algorithm. 
As a solution for the first problem in RUBE, we develop Model Explorer and 
provide library systems for dynamic model objects, MXL, and functions for users to 
facilitate dynamic modeling process. Model Explorer allows users to search or import 
proper Blender objects from the object library. If users need their own customized or 
personalized objects, they are able to generate certain objects and store them into the 
object library using Export in Blender Interface. 
A “snap to grid” algorithm will be introduced in Chapter 5 as a solution for the 
second problem. The algorithm makes scaling, rotation, and transformation matrices for 
the connection objects such as arrows and/or pipes using vector operations. When given 
non-connection-related objects in a 3D scene, users do not need to relocate, resize, and 
re-rotate any connection objects. This indicates that the algorithm can place the 
connection objects exactly between the source and target blocks according to user 
requests. 
 

9 
1.3 Organization of the Dissertation 
Our approach and methodology for integrative multimodeling is explained and 
discussed in Chapter 3. Background knowledge, such as the concept of dynamic model, 
RUBE (XML-based Modeling and Simulation Framework), and ontology, is addressed 
and discussed in Chapter 2. The integrative mutimodeling environment is presented in 
Chapter 4. In Chapter 5, we demonstrate how the methodology is applied to real-world 
applications using two examples. We conclude the dissertation by discussing future 
research in Chapter 6. 
 

CHAPTER 2 
BACKGROUND 
2.1 Dynamic Models 
Before we discuss our modeling approach and methodology, let us overview a 
unifying formalism that serves to represent a wide variety of system models. A 
deterministic system <T, U, Y, Q, Ω, δ, λ> within classical systems theory is defined as 
follows [25]: 
• 
T is the time set. For continuous systems, T = R (reals), and for discrete time 
systems, T = Z (integers). 
• 
U is the input set containing the possible values of the input to the system. 
• 
Y is the output set. 
• 
Q is the state set. 
• 
Ω is the set of admissible (or acceptable) input functions. This contains a set of 
input functions to use during system operation. Often, due to physical limitations, 
Ω is a subset of the set of all possible input functions (T→ U). 
• 
δ is the transition function. It is defined as δ: Q x Ω → Q. 
• 
λ is the output function, λ : Q → Y. 
A pair consisting of a time and a state (t, s), where s ∈ Q, is called an event. Events 
are points in event space just as states are points in state space. Event space is defined as 
T x Q. State and Event are critical aspects of any system and by focusing on one or the 
other, we form two different sorts of models: declarative models that focus on the 
concept of state, and functional models that focus on the concept of event. In declarative 
modeling, as shown in Figure 2-1, in 2D diagram, we build models that focus on state 
10 

11 
representations and state-to-state transitions. In functional modeling as shown in Figure 
2-2, we focus on the system as a coupled network of functions each of which takes inputs 
and produces outputs. 
 
Figure 2-1. Declarative Model 
                      
 
Figure 2-2. Functional Model 
The declarative modeling approach suggests that we look at the world through a 
sequence of changes in state and it is very good for modeling problem domains where the 
problem decomposes into discrete temporal phases. Finite State Automata (FSA) permit 
us to model systems with a minimum of components. An FSA is a system with states and 
transitions. A state, depicted as a circle, represents the current condition of a system for 
 

12 
some length of time, and transitions, depicted as arrows, enable the system to move from 
one state to another during the simulation. The basic definition of system <T, U, Y, Q, Ω, 
δ, λ> provides the semantics for declarative models as described above for the 
deterministic system. 
Functional models map very easily into the OO paradigm since a function is 
represented as a method located within an object, and it is often used to model continuous 
systems and discrete event systems composed of coupled functional blocks. 
These functional models are also useful when the problem is given in terms of 
distinct physical objects which are connected in a directed order or the problem involves 
a material flow throughout the system. Function-based models contain a transfer function 
which relates input to output. The functions, along with inputs and outputs, are often 
depicted in a “block” form, especially when a block is the iconic representation of 
physical device being modeled. 
We discuss mapping rules between the formal definition of system and ontological 
domain knowledge in Section 2.3 by showing how each element in the description could 
be connected to domain knowledge.  
2.2 RUBE: An XML-based 2D and 3D Modeling Framework for Simulation  
We have developed a dynamic modeling and simulation framework called RUBE 
for the past four years [52, 53]. The purpose of RUBE is to facilitate dynamic multimodel 
construction and reuse within a 2D environment [54] or a 3D immersive environment 
[55].  
A simplified overall structure of the XML-based RUBE framework is shown in 
Figure 2-3. RUBE is an XML-based framework and application, which permits the users 
to specify and simulate a dynamic model, with an ability to customize a model 
 

13 
presentation using 2D or 3D visualization. In Figure 2-3, the RUBE framework is defined 
using two stages: model representation and model creation. 
For model representation, a dynamic model, which is generated by a 2D or a 3D 
interface, is composed of two sorts of files: a scene file, which contains 2D or 3D 
geometry objects, and a model file, which is represented by MXL. RUBE uses Sodipodi 
[56] and Blender [57] for each representation of the 2D or the 3D model scenes and 
behaviors. The scene files don’t have any information about model behavior or dynamics 
except regarding the appearance of the model. The scene files can be either 2D or 3D 
XML documents: SVG (Scalar Vector Graphics) [58] or X3D (eXtensible 3D) [59] 
respectively. The MXL file describes the behavior of the model to represent the model 
file that describes a heterogeneous multimodel in an abstract level such as FBM 
(Functional Block Model) and FSM (Finite State Machine).  
 
Simulation code 
… 
SimPackJ/S 
… 
Simulation file 
 
MXL file 
MXLtoDXL 
translator using 
XSLT 
DXLtoJavascript 
translator using 
DOM 
 
DXL file 
 
MXL file 
 
Simulation file 
 
Scene file 
2D & 3D 
Merge engine 
 
2D & 3D 
RUBE dynamic 
modeling file 
 
2D interface 
(Sodipodi) 
 
3D interface 
(Blender) 
 
 
 
 
 
 
Figure 2-3. RUBE Framework 
For model creation, a 2D or a 3D merge engine, which uses XSLT (eXtensible 
Stylesheet Language Transformation) [60], merges two XML documents: a scene file and 
a model file. For model simulation, the MXLtoDXL translator translates a model file 
written in MXL into a low-level modeling language called DXL, which can be described 
with homogeneous simple block diagrams. The DXL is translated into an executable 
 

14 
programming code for the model simulation using the DXLtoJavascript translator. The 
programming code can be executed using SimpackJ/S [61, 62], which provides the 
underlying code foundation libraries, classes, and objects.  
For example, a four-stroke gasoline engine has four phases, which cycle until the 
engine is turned off. The four phases are Compression, Ignition, Expansion, and 
Exhaustion. In this gasoline engine, injected fuel vapor is compressed by the piston of the 
cylinder (Compression) and then the fuel is ignited (Ignition). As a result of the ignition, 
the piston of the cylinder moves back (Expansion). The resulting fumes exit through the 
exhaust manifold (Exhaustion).  
0 
1 
Engine FSM
0 
0 
1 
1 
1 
1 
2 
Compres
sion 
Exhausti
on 
Off
Ignition 
Expan
sion
0 
 
 
 
 
 
 
 
Figure 2-4. An FSM Describing a Four-Stroke Gasoline Engine [25] 
The behavior of the engine can be described as the FSM in Figure 2-4. While an 
input value of 0 will let the engine stay at the current state, the value 1 causes the engine 
to move to the next state. An input value of 2 in the Ignition state indicates that the 
ignition is turned off (Off state).  
The engine system can also be modeled with a pipeline of 3 functions to create an 
FBM. To execute the engine, input to and output from the engine must be specified from 
the outside world. The engine can be embedded inside of the FBM block with one input 
 

15 
and one output block associated with it. The input block feeds the input value to the 
engine. The engine block represents an engine model that behaves as described in Figure 
2-4. The current state of the engine is passed to the next block, namely the output block.  
 From the model representation (2D or 3D), we can generate an MXL file for the 
example. Figures 2-5 and 2-6 show the MXL representations for the example.  
 
<?xml version="1.0" encoding="utf-8"?> 
<MXL> 
     <fbm id="MXL"> 
 
<block id="F1"> 
 
 
<output id="F1_outports_integer1" datatype="Integer" index="0"/> 
 
 
<script lang="JavaScript" src="input.js" func="gen"/> 
 
</block> 
 
<block id="F2"> 
 
 
<input id="F2_inports_integer1" datatype="Integer" index="0"/> 
 
 
<output id="F2_outports_string1" datatype="String" index="0"/> 
 
 
<fsm id="FSM_F2" src="FSM_F2.xml"/> 
 
</block> 
 
<block id="F3"> 
 
 
<input id="F3_inports_string1" datatype="String" index="0"/> 
 
 
<script lang="JavaScript" src="input.js" func="disp"/> 
 
</block> 
 
<trace from="F1_outports_integer1" to="F2_inports_integer1"/> 
 
<trace from="F2_outports_string1" to="F3_inports_string1"/> 
     </fbm> 
      
     <simulation start_time="0" end_time="10" delta_time="0.1" cycle_time="0.1" /> 
</MXL>    
 
 
 
 
 
 
 
 
        Figure 2-5. MXL Representation (FBM) for the Example 
        In Figure 2-5, the MXL contains fbm and simulation as sub-elements. fbm 
represents model type (i.e., Functional Block Model) and has two elements, block and 
trace. Each block element has an attribute, id, to specify the names of blocks. In addition, 
the element has port information, input and/or output, as well as its functionality, script. 
Each input and output element contain id, datatype, and index, which define the name of 
input/output, data type of input/output, and the number of input/output, respectively. And 
script element has lang, src, and func to specify program language, the name of script 
file, and function to be executed, respectively. If a block contains another model type (i.e. 
multimodel), the model type and its MXL can be specified in the block (i.e., Block F2 in 
 

16 
Figure 2-5). trace has from and to attributes denoting connectivity between blocks. 
simulation has specific information for executing a certain dynamic model such as start 
time, end time, and delta time. Figure 6 depicts internal dynamic model type which block 
F2 contains. In this case, the MXL represents Finite State Machine. Therefore the MXL 
has state and transition as sub-elements. Likewise each state and transition has its id, 
script information, and topological connectivity.  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
<?xml version="1.0" encoding="utf-8"?> 
<MXL> 
    <fsm id="FSM_F2"> 
 
<input id="F2_inports_integer1" datatype="Integer" index="0"/> 
 
<output id="F2_outports_string1" datatype="String" index="0"/> 
 
 
 
<state id="off" start="true"> 
 
       <script lang="JavaScript" src="input.js" func="off"/> 
 
</state> 
 
<state id="compression"> 
 
 
<script lang="JavaScript" src="input.js" func="compression"/> 
 
</state> 
 
<state id="ignition"> 
 
 
<script lang="JavaScript" src="input.js" func="ignition"/> 
 
</state> 
 
<state id="expansion"> 
 
 
<script lang="JavaScript" src="input.js" func="expansion"/> 
 
</state> 
 
<state id="exhaustion"> 
 
 
<script lang="JavaScript" src="input.js" func="exhaustion"/> 
 
</state> 
 
<transition from="off" to="compression"> 
 
 
<script lang="JavaScript" src="input.js" func="off2Compression"/> 
 
</transition> 
 
<transition from="compression" to="ignition"> 
 
 
<script lang="JavaScript" src="input.js" func="compression2Ignition"/> 
 
</transition> 
 
<transition from="ignition" to="off"> 
 
 
<script lang="JavaScript" src="input.js" func="ignition2Off"/> 
 
</transition> 
 
<transition from="ignition" to="expansion"> 
 
 
<script lang="JavaScript" src="input.js" func="ignition2Expansion"/> 
 
</transition> 
 
<transition from="expansion" to="exhaustion"> 
 
 
<script lang="JavaScript" src="input.js" func="expansion2Exhaustion"/> 
 
</transition> 
 
<transition from="exhaustion" to="compression> 
 
 
<script lang="JavaScript" src="input.js" func="exhaustion2Compression"/> 
 
</transition> 
    </fsm> 
</MXL> 
        Figure 2-6. MXL Representation (FSM) for the Four-Stroke Gasoline Engine 
 

17 
Using MXL2DXLTranslator, the MXL file can be translated into DXL, which is a 
homogeneous assembly level block diagram modeling language consisting of 
Connectors, Blocks, and Ports. Figure 2-7 shows the generated DXL from the MXL as 
shown in Figures 2-5 and 2-6. Ultimately we can generate a JavaScript-based simulation 
code for the example through DXL2JavaScript translator.  
 
<?xml version="1.0" encoding="UTF-8"?> 
<DXL> 
 <block id="F1" type="SYNC" > 
  <port id="F1.F1_outports_integer1" type="OUTPUT" target="F2.F2_inports_integer1" data_type="Integer"></port> 
  <definition id="input.js" func="gen" lang="JavaScript"></definition> 
 </block> 
 <block id="F2" type="SYNC" > 
  <port id="F2.F2_inports_integer1" type="INPUT" source="F1.F1_outports_integer1" target="FSM_F2_INPUT.IP1"  
   data_type="Integer"></port> 
  <port id="F2.F2_outports_string1" type="OUTPUT" target="F3.F3_inports_string1" data_type="String"></port> 
  <DXL id="FSM_F2"> 
     <block id="FSM_F2_INPUT" type="SYNC" internal="YES"> 
       <port id="FSM_F2_INPUT.IP1" type="INPUT" source="F2.F2_inports_integer1" data_type="Integer"></port> 
       <port id="FSM_F2_INPUT.IP2" type="INPUT" source="FSM_F2_OUT.OP1" data_type="String”></port> 
     </block> 
     <block id="FSM_F2_OUT" type="ASYNC" internal="YES"> 
       <port id="FSM_F2_OUT.OP1" type="OUTPUT" target="FSM_F2_INPUT.IP2" data_type="String"></port> 
     </block> 
  </DXL> 
 </block> 
 <block id="F3" type="SYNC" > 
  <port id="F3.F3_inports_string1" type="INPUT" source="F2.F2_outports_string1" data_type="String"></port> 
  <definition id="input.js" func="disp" lang="JavaScript"></definition> 
 </block> 
 <connect id="F1_outports_integer1ToF2_inports_integer1"> 
  <port id="F1_outports_integer1ToF2_inports_integer1.OP1" type="INPUT"  
                            source="F1.F1_outports_integer1"></port> 
  <port id="F1_outports_integer1ToF2_inports_integer1.IP1" type="OUTPUT"  
                           source="F2.F2_inports_integer1"></port> 
 </connect> 
 <connect id="F2_outports_string1ToF3_inports_string1"> 
  <port id="F2_outports_string1ToF3_inports_string1.OP1" type="INPUT" source="F2.F2_outports_string1"></port> 
  <port id="F2_outports_string1ToF3_inports_string1.IP1" type="OUTPUT" source="F3.F3_inports_string1"></port> 
 </connect> 
 <simulation start_time="0" end_time="10" delta_time="0.1" cycle_time="0.1"/> 
</DXL> 
Figure 2-7. DXL Representation for the Four-Stroke Gasoline Engine 
Figures 2-8 and 2-9 show the simulation results of 2D and 3D scenes. 
 

18 
 
 Figure 2-8. Simulation Output from the 2D Engine Model 
 
 
 
 
 
 
 
                                                          A                                                                     B 
 Figure 2-9. Simulation Results. A) Final VRML Scene Generated by the 3D-Based 
RUBE Framework, B)   Simulation Output from the 3D Engine Model 
2.3 Ontology 
An ontology [63, 64] describes meaning of terms and their interrelationships used 
in a particular domain. Ontologies consist of three general elements: classes, properties, 
and the relationships between classes and properties. An ontology is expressed in XML 
or ontology languages, such as RDF, RDF-S, and OWL, so that the information 
contained in documents can be processed by applications. OWL has more power to 
express meaning and semantics than RDF, which is a general-purpose language for 
representing information on the Web, and RDF-S, which describes how to use RDF to 
 

19 
describe RDF vocabularies, since OWL is built on RDF and extends a vocabulary of 
RDF-S. 
Figure 2-10 illustrates a simple ontology which represents the domain of Finite 
State Machines (FSM). An FSM contains a set of states, inputs and outputs, as well as a 
start state, state and output transition functions. A transition connects two states together 
in a directional fashion. The icons in circles represent concepts or classes, whereas the 
squares represent instances. 
                              
 
Figure 2-10. A Primitive FSM Ontology  
Also we can represent FSM as a formal definition [65]. The formal definition of 
FSM is a 5-tuple (Q, ∑, δ, q0, F), where 
• Q is a finite set called the states, 
• ∑ is a finite set called the alphabet, 
• δ: Q * ∑  → Q is the transition function, 
• q0 ∈ Q is the start state, and  
• F ⊆ Q is the set of final states. 
The formal definition precisely describes what we mean by a finite state machine. 
From the FSM ontology example and the formal definition of FSM, we create a set of 
 

20 
rules that define both the formal grammar and data types for FSM using OWL as shown 
in Table 2-1. 
Table 2-1. Mapping Rules 
FSM Definition 
OWL Definition 
Remarks 
A set of states 
State class 
 
A set of alphabet 
InputSet class 
{0,1} 
Transition function 
TransitionFunction 
class 
Three object properties: 
1. hasInput 
2. hasSource 
3. hasTarget 
Start state 
StartState class 
Subclass of State class 
Final state 
FinalState class 
Subclass of State class 
 
Figure 2-11 depicts a visual OWL representation for the FSM (instances are not 
shown). We define all FSM components as classes and then connect the components 
using “has” relationships. Finally, we add some restrictions and properties to each class 
according to the formal definition of FSM so that we can generate a valid FSM. 
 
Figure 2-11. OWL Representation for the FSM 
 

21 
We can also represent the ontology using XML schema. The schema provides a 
formal structure for an individual XML document. In the schema, we can define elements 
of FSM and simple relationships between the elements as well as attributes and data 
types. Based on the schema, we can create instance-based model representation for a 
certain FSM. Consider the following scenario: 
• Two state instances, states s1 and s2 
• Four transition instances, t1, t2, t3, and t4 
• Two possible input values, 0 and 1  
• Reflexive transitions for input value 0  
• Change transitions for input value 1 (s1↔ s2) 
Based on the scenario, we can specify a document for the FSM and check the 
model validation for the FSM using a set of rules (i.e., MXL schema [66, 67]). The 
following shows the instance-based ontology in MXL for the scenario: 
<?xml version=''1.0'' encoding=''utf-8''?> 
<mxl> 
   <fsm id=''fsm''> 
      <state id=''s1'' start=''true''> 
      <state id=''s2''> 
      <transition from=``s1'' to=''s1'' input=0 />   /* t1/ 
      <transition from=``s1'' to=''s2'' input=1 />  /* t2/ 
      <transition from=``s2'' to=''s1'' input=1 />  /* t3/ 
      <transition from=``s2'' to=''s2'' input=0 />  /* t4/ 
</mxl> 
 
 
 
 
 
 

CHAPTER 3 
INTEGRATIVE MULTIMODELING 
The purpose of integrative multimodeling is to provide a human computer 
interaction (HCI) environment that allows modelers or users to alternate and juxtapose 
the representations of the heterogeneous model types by connecting model components 
between different model types. In the context of integrative multimodeling, the following 
general issues naturally arise: 
• 
How can we connect different model components? 
• 
How can we formalize the model component mapping and user interactions?  
• 
How can we visualize different model types in 3D space? 
• 
How can we compose a dynamic model and an interaction model? 
• 
How can we verify a dynamic model in terms of syntax and semantics? 
• 
How can we execute a dynamic model and an interaction model? 
We will explain and justify our approach to deal with the first four issues listed 
above by providing our scene domain ontology in Chapter 3.1. The last two issues will be 
covered in Chapter 3.2. 
3.1 Approach 
A real-world system can be embodied as a certain model type within a 2D or 3D 
visualization environment. It can be described by different perspectives depending on the 
modelers’ viewpoint since the real-world system has the geometry, dynamics, or 
information. Ideally we can integrate the different angles of vision within one interface so 
22 

23 
that we can explore a variety of heterogeneous representations through human computer 
interactions and investigate dynamics of the certain scene within the same environment.  
We need to define a formalized scene domain in which multiple model 
representations can exist together and a certain model type can be transformed into other 
model types via user interactions, by conceptualizing all objects, that the scene domain 
contains, and specifying properties (i.e., geometry, dynamics, and information) of objects 
and relationships between objects.  
In our scene domain, we conceptualize a real-world system to be modeled, as well 
as user interactions. All objects’ concepts in the domain are defined as classes or 
subclasses. Specific relationships between objects are represented as a graph structure. 
Three data type properties, hasGeometry, hasDynamic, and hasInformation, are defined 
for providing additional information to each class. hasGeometry refers to each geometric 
structure of a certain target system being modeled, and hasDynamic indicates a dynamic 
behavior of the geometric structure. hasInformation specifies information, such as the 
manufacturers, sizes, and colors of each specific part of the target system. 
Consider the following scenario with three objects representing a battle scene: joint 
surveillance target attack radar system (JSTARS), F15 fighter aircraft, and unmanned 
aerial vehicle (UAV). The UAV is in charge of gathering battlefield information and 
conveying the information to JSTARS. Then JSTARS delivers attack messages to the 
F15. Finally, the F15 attacks some areas. Based on our scene modeling knowledge 
regarding the scenario and user interactions, we can construct the ontology for the 
battlefield scene, as shown in Figure 3-1.  The rectangles indicate concepts, which are 
represented by classes or subclasses, whereas the circles represent instances. The 
 

24 
instances can be used for visualizing the battle scene as geometry, dynamic, or 
information model types through user interactions in 3D space because every class has 
properties associated with model types.  
 
Figure 3-1. Scene Ontology 
In Figure 3-1, the scene “contains” aircraft, such as JSTARS, F15, and UAV, and 
sensors, such as touch or keyboard sensors, which can derive user interactions. Therefore, 
we define two classes as subdomains of the scene: Aircraft and Sensors. In addition, we 
define Geometry Model, Dynamic Model, Information Model, Process, Display, and 
Interaction Model classes. Classes and subclasses defined in Figure 3-1 are further 
discussed in the following subsections, as well as class relationships and restrictions. 
3.1.1 Aircraft Class 
JSTARS, F15 and UAV are classified as subclasses of the Aircraft class to 
compose a battle scene. The Aircraft class is connected to the scene using a “contains” 
Scene 
Aircraft 
Sensors 
UAV 
JSTARS 
F15 
• Has Geometry
• Has Dynamic
• Has Information
Information Model 
Geometry Model 
Dynamic Model 
Process 
Control 
Effect 
UAV 
Effect
F15
Control 
JSTARS
Interaction 
Model 
Geometry 
Model 
Dynamic 
Model 
Sensors
contains
contains
handles
Displayed in 3D
Subclass Of
Information 
Model 
Activates/Deactivates Geometry/Dynamic/Information Models 
Interaction Model 
Subclass Of
Takes Has Geometry/Dynamic/Information from each instance
Represented in MXL
• Has Geometry
• Has Dynamic
• Has Information
 

25 
relationship. We define three data type properties, which are hasGeometry, hasDynamic 
and hasInformation, within the Aircraft class since all instances of the Aircraft class can 
have geometry and dynamics as well as certain information. All subclasses can inherit the 
properties from the upper class. In the domain of Aircraft, hasGeometry refers to each 
geometric structure being modeled in 3D space. By gathering all hasGeometry properties 
of instances of the domain, an overall battle scene can be modeled as a geometry model 
(i.e., Geometry Model class). Therefore, the battle scene can be visualized in a 3D 
environment. On the other hand, hasDynamic indicates each dynamics of UAV, JSTARS, 
or F15. We employ multimodeling exchange langauge (MXL) to capture the semantic 
content for each dynamics. The semantic content includes: 
• 
A 3D object for explicitly representing a geometric element of a dynamic model in 
3D space. 
• 
A function describing dynamic behavior, encoded by computer programming 
languages, such as Python or JavaScript.  
• 
Input and/or output information associated with the function. 
In the ontology, each hasDynamic refers to an MXL representation of UAV, 
JSTARS, or F15. Each MXL is separately stored as a file with an “mxl” file extension. 
That means every hasDynamic property in the ontology indicates the corresponding 
MXL file. By collecting all hasDynamic properties (i.e., MXL files), an entire dynamic 
model for the battle scene can therefore be implemented in MXL and visualized in 3D 
space based on a 3D dynamic model object found in each MXL file. Ultimately, the 
dynamic model can be simulated based on given functions through the RUBE 
framework. For example, a possible functional block model (FBM) representation in 
MXL for the UAV is as follows: 
<block id = “Rectangle”> 
 

26 
   <output id = “output_1” datatype = “Boolean”/> 
   <script lang= “Python” source = “Boolean_gen.py” function = “Generator” /> 
</block> 
As seen in the MXL above, the following interpretation is possible: 
• 
This block can be visualized as a rectangle in 3D space.  
• 
The function “Generator,” which is defined in “Boolean_gen.py,” is used for 
generating boolean data. 
• 
The “Generator” function is encoded in Python and has a return value which is a 
boolean. 
An overall MXL representation for the example is shown in Chapter 5. 
hasInformation indicates specific information of each component by appending 
subproperties to the hasInformation property. By collecting hasInformation properties, 
we can visualize the content of information like the Camtree [68] in 3D space as well. 
3.1.2 Sensors Class 
The Sensors class is included in the scene domain and connected to the scene using 
a “contains” relationship. Also, instances of the class are utilized for constructing an 
interaction model because user interactions are initiated by pressing certain sensors, such 
as touch sensors in VRML or keyboard sensors in Blender. The class is further divided 
into two subclasses, Mouse-based and Keyboard-based classes, since the mouse and 
keyboard are the primary interaction devices in a desktop-based interaction environment. 
Three data properties are also defined in the Sensors class. In the domain of the Sensors, 
each hasGeometry indicates a certain geometric structure representing a sensor such as a 
button in 3D, and each hasDynamic refers to a dynamic behavior which is described in 
MXL. hasInformation could contain a specific information for a certain sensor by 
 

27 
creating subproperties. A possible representation in MXL for a touch sensor used in 
VRML is as follows: 
    <block id = “Touch_Sensor”> 
         <output id = “output_1” datatype = “Boolean”/> 
        <script lang= “JavaScript” source = “Boolean_gen.js” function =    
        “Generator”/> 
    </block> 
The distinct point is that any sensor is described as a block which is one of the 
elements of functional block model (FBM) since we consider an interaction model as a 
kind of functional block model. The details are further discussed when we introduce 
Interaction Model class.  
3.1.3 Process and Display Classes 
Process and Display classes are used for establishing an interaction model like the 
Sensors class. The Process class has Control and Effect subclasses. Because our goal is to 
create multiple visual modes for a certain target system through an interaction model, we 
need control processes, which can manage current scene style, find positions of current 
model components, and then assign the positions to the components of different model 
type, and visual effects, which can show a visual conversion process from one model type 
to the other model type. The Display class is used to show outputs of an interaction 
model. The output of the interaction model is one of the model types such as geometry, 
dynamic, or information models. In our scene domain, therefore, the Display class is 
directly connected to Geometry Model, Dynamic Model, and Information Model classes 
using “has a” relationships. Each model class can be composed of data type property (i.e., 
 

28 
hasGeometry, hasDynamic, or hasInformation) of instances of main model components 
in the scene.  
3.1.4 Geometry Model, Dynamic Model, and Information Model Classes 
The Geometry Model and Information Model classes are used for visualizing 
corresponding model types by taking hasGeometry and hasInformation properties of each 
model component, and the Dynamic Model class is used for representing dynamic 
behaviors as well as 3D geometric structures of the dynamic model. In the case of 
Dynamic Model class, therefore, the class should be logically further specified. That 
means the Dynamic Model class has two branch classes: one is for standing for dynamic 
behaviors in MXL and the other is for explicitly representing geometric objects of the 
dynamic model. The former class is implemented by collecting MXL files (i.e., 
hasDynamic properties) of the main model components, whereas the latter is composed 
of the 3D geometric objects found in corresponding MXL files. Hence, the Dynamic 
Model class is connected to the two different classes using a “has MXL” and a “has 
Representation” relationships.  
3.1.5 Interaction Model Class 
Integrative Multimodeling is achieved based on a user interaction environment that 
allows modelers to change model presentations among different model types. The user 
interaction need to be formalized and executable in the scene domain. Therefore, the 
Interaction Model class is inserted into the domain. As we mentioned, an instance of the 
Interaction Model class can be created by taking instances of Sensors, Process, and 
Display classes because user interactions are initiated by pressing certain sensors, such as 
touch sensors in VRML or keyboard sensors in Blender. The interactions are then 
 

29 
supervised or managed through a control process, and then the proper model type is 
displayed in 3D space through a certain effect process such as morphing.  
An interaction model can be represented as a dynamic model. We consider the 
interaction model as a kind of functional block model (FBM) since Sensors are FBM 
blocks with no inputs (they drive or generate the data), Control and Effect processes are 
FBM blocks with inputs and outputs, and Display is an FBM block with no outputs. The 
interaction model can therefore be described as an FBM syntax in MXL and provide an 
HCI environment that enables user interactions. 
3.1.6 Summary 
From the scene ontology, we conclude or observe the following facts: 
• 
The scene domain includes a real-world system, as well as user interactions. Within 
the scene domain, multiple model types, which are geometry, dynamic, and 
information models, for the real-world system can be coexisted and be 
interchangeable through user interactions. 
• 
3D model components for geometry and dynamic models could be reusable by 
maintaining the instances of class or subclass.  
• 
The scope of domain can be extended by creating new class and/or subclasses or by 
adopting the existing ontology.  
• 
The interaction model is “sensor-based” and can be implemented as functional 
block model (FBM) for user interactions. 
• 
Our dynamic models for the battle scene and user interactions are taken out of the 
hasDynamic properties and "wrapped up" into models that are connected directly to 
the root classes. This approach suggests that other models, such as geometry and 
information models, are formed in similar ways, thus simplifying the structure of 
the ontology. 
When we implement an integrative multimodeling environment, which is discussed 
in Chapter 4, we do not consider information models to simplify user interactions, the 
structure of the ontology, and model executions. We focus mainly on representing 
 

30 
dynamic models used in simulation and geometry models for the phenomena being 
modeled. 
3.2 Methodology 
We propose a 3D ontology-based customizable modeling and simulation 
methodology for integrative multimodeling. Based on dynamic and geometry model 
levels, the following steps show the general methodology for integrative multimodeling: 
Step 1: Choose a target system to be modeled: The target system could be anything 
in the real world.  
Step 2: Create a geometry model for the target system: In this step, modelers 
embody the real-world system in 3D space by directly constructing the system or by 
reusing the system object if the target system is maintained in the ontology.  
Step 3: Select a dynamic model type for the target system: Modelers specify the 
dynamic behavioral type, such as finite state machine (FSM) or functional block model 
(FBM). 
Step 4: Choose a metaphor and/or an aesthetic style for the dynamic model and 
then specify functions and MXLs: Modelers develop their own customizable dynamic 
model presentation or select predefined dynamic model components from libraries, which 
is discussed in Chapter 4. If modelers do not use the libraries, they have to specify 
functions for their dynamic models using Python as well as MXLs. In addition, modelers 
can append their customized model components to the libraries as well as corresponding 
functions and MXLs. 
Step 5: (optional) Store the geometry and/or dynamic model representations for 
future reuse: In this step, modelers can construct a model component database for 
geometry and/or dynamic models by generating instances of related classes. 
 

31 
Step 6: Create a simulation code for the dynamic model: Through the RUBE 
framework, modelers can generate a simulation code for the dynamic model of a certain 
scene. The code is then inserted into a “Logic Brick” inside the Blender Game Engine to 
simulate the dynamic model. However, if the dynamic model in MXL for the scene is not 
well defined, error messages will be displayed and the process will be terminated when 
generating a DXL since we have a schema for MXL to check model verification. 
Step 7: Define interaction methods and then implement an interaction model: In 
VRML, the interaction model is really the routing graph and a kind of dynamic model. 
Therefore, modelers have to build the interaction model like the scene dynamic model. 
Finally, the JavaScript code for user interactions could be generated through the RUBE 
framework. However, we focus on a Blender environment since VRML files require an 
additional authoring capability. In Blender, the interaction model can be built within the 
Blender Game Engine without explicitly making the model. In the Blender Game Engine, 
there are Sensors (i.e., keyboard and mouse sensors), Controllers, and Actuators. These 
are used to create "Logic Brick" graphs, which drive the interaction. Using the “Logic 
Brick” graphs, we can implement and execute the interaction model. The details are 
discussed in Chapter 5. 
Step 8: Create an integrative multimodeling environment: Based on step 7, we 
achieve a human computer interaction (HCI) environment that allows modelers to 
alternate and juxtapose the representations of the heterogeneous model types, such as a 
dynamic model being simulated and a geometry model being animated. 
In Chapter 5, we demonstrate how this methodology can be applied to real-world 
examples to support our idea and approach. 
 

CHAPTER 4 
IMPLEMENTATION 
In this Chapter, we first discuss the overall structure of the integrative 
multimodeling environment. After presenting an overview of the integrative 
multimodeling environment, we focus on the scene ontology implementation as well as 
the modeling and simulation environment within the integrative multimodeling. The 
scene ontology is constructed based on the scene domain ontology which is discussed in 
Chapter 3. The modeling and simulation environment is developed based on Python-
based interfaces (i.e., Blender Interface) and the RUBE framework. 
4.1 Overview 
Blender as a 3D authoring tool and RUBE framework are used for supporting 
integrative multimodeling, and the Python scripting language [69, 70] is employed for 
implementing an interface. The interface, Blender Interface, contains four functionalities, 
Model Explorer, Ontology Explorer, Exporter, and Simulation, which can allow users to 
build their customized or personalized dynamic models such as FBM, FSM, and queuing 
model and simulate their dynamic models with a Python code generated by the RUBE 
framework in Blender. In addition, Blender Game Engine is employed to implement and 
execute an interaction model and to animate a geometry model, as well as to simulate a 
dynamic model. A repository for model components (i.e., library system) is provided for 
modelers or users to give flexibility in dynamic model representations. Also, the OWL-
based scene ontology is supported for increasing reusability of geometry model 
32 

33 
components. Figure 4-1 shows the overall structure of the integrative multimodeling 
environment.  
Import dynamic or geometry objects 
 
Figure 4-1. The Overall Structure for the Integrative Multimodeling Environment 
4.2 Ontology: A Framework for Encoding Modeling Knowledge 
An ontology is necessary to define the scene domain and formalize and justify 
connections between geometry and dynamic model components for integrative 
multimodeling. The Protégé ontology editor is employed to create a scene ontology. And 
ezOWL is used to visualize the ontology. Figures 4-2 and 4-3 show the graphical 
representation and OWL representation of the ontology for the battle scene, which will be 
used as an example for discussing the Integrative Modeling and simulation process in 
Chapter 5. In Figure 4-2, two data type properties for each class, hasGeometry and 
hasDynamic, can be found as well as relationships between classes. We can interpret this 
as all objects can have geometry and dynamic model components and be interchangeable 
Blender 3D scene 
Model Explorer 
Export 
Ontology Explorer 
Simulation 
Repository for  
Dynamic Model 
Components  
Ontology 
Class 
Instance 
rube Framework 
1) Blender to MXL 
2) MXL to DXL 
3) DXL to Python code
Python Code 
Blender Game Engine 
Logic Bricks for Animation 
Logic Bricks for Simulation 
Logic Bricks for Interaction 
Model and Modeling 
Animate a geometry model 
Simulate a dynamic model 
Integrative Multimodeling 
Place 
Utilize 
Access 
Create 
Access
Store
Import dynamic model objects 
Export 
model 
objects 
 
Create
 

34 
between the components in the scene domain based on relationships and restrictions. In 
addition, Geometry Model, Dynamic Model, and Interaction Model classes are defined in 
Figure 4-2.  
 
Figure 4-2. Scene Ontology 
 
 

35 
           
 
 
 
 
 
 
 
 
 
 
 
 
 
<rdf:RDF 
xmlns="http://a.com/ontology#" 
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" 
xmlns:owl="http://www.w3.org/2002/07/owl#" 
xml:base="http://a.com/ontology"> 
<owl:Ontology rdf:about=""/> 
<owl:Class rdf:ID="Geometry_for_UAV_Dynamic_Model"/> 
<owl:Class rdf:ID="MXL_for_UAV_Dynamic_Model"/> 
<owl:Class rdf:ID="Scene"/> 
<owl:Class rdf:ID="JSTARS"> 
   <rdfs:subClassOf> 
       <owl:Class rdf:ID="Aircraft"/> 
   </rdfs:subClassOf> 
</owl:Class> 
…… 
<owl:ObjectProperty rdf:ID="TakesDynamicProperty"> 
    <rdfs:domain rdf:resource="#MXL_for_UAV_Dynamic_Model"/> 
    <rdfs:range> 
       <owl:Class> 
           <owl:unionOf rdf:parseType="Collection"> 
                 <owl:Class rdf:about="#UAV"/> 
                 <owl:Class rdf:about="#JSTARS"/> 
                 <owl:Class rdf:about="#F15"/> 
           </owl:unionOf> 
       </owl:Class> 
    </rdfs:range> 
</owl:ObjectProperty> 
<owl:ObjectProperty rdf:ID="hasDynamicModel"> 
    <rdfs:range rdf:resource="#Geometry_for_UAV_Dynamic_Model"/> 
    <rdfs:domain rdf:resource="#Display"/> 
</owl:ObjectProperty> 
<owl:ObjectProperty rdf:ID="hasMXL"> 
    <rdfs:range rdf:resource="#MXL_for_UAV_Dynamic_Model"/> 
    <rdfs:domain rdf:resource="#Dynamic_Model"/> 
</owl:ObjectProperty> 
…….. 
Figure 4-3. OWL Representation 
The Geometry Model class can be built by taking hasGeometry property of each 
model component. Also, it will be used as an output of an interaction model. Similarly 
Interaction Model class can be constructed by taking hasDynamic properties of Sensor, 
Process, and Display classes. The Dynamic Model class is linked to 
MXL_for_UAV_Activity class and Geometry_for_UAV_Activity class using hasMXL and 
hasRepresentation relationships. The MXL_for_UAV_Activity is created from 
hasDynamic properties of the main model components, and the 
Geometry_for_UAV_Activity indicates 3D geometric structures to explicitly represent the 
dynamic model. A simulation code, such as Python, can be generated from the 
 

36 
MXL_for_UAV_Activity class through the RUBE framework, which is discussed in 
Chapter 5. Using Geometry_for_UAV_Activity class, we can visualize the dynamic model 
in 3D space, and it will be used as an output of an interaction model. Besides, any 
instances, which will be created in the modeling process, can be inserted into the 
ontology for constructing a model component database.  
Following subsections discuss classes and properties, which are created in our 
scene domain, in detail.  
4.2.1 Classes 
Our scene domain is formalized and justified by conceptualizing all objects (i.e., 
things) which are existed in the domain. First, we create Scene class, which is used as a 
super class in the domain. Because our goal is to create a kind of battle scene composing 
of three aircraft, such as one F15, one UAV, and one JSTARS, Aircraft class is created, 
and F15, UAV, and JSTARS classes are also defined as subclasses of the Aircraft class. 
Because all user interactions are driven by sensors associated with fundamental 
interaction devices, such as the keyboard and mouse, in a desktop-based environment, the 
domain includes Sensors class, as well as Keyboard-based and Mouse-based classes as 
subclasses of the Sensors class. Display and Process classes are included for establishing 
an interaction model. Display class is employed for showing a result of the interaction 
model, a geometry model or a dynamic model. Therefore, the Display Class has 
relationships with Geometry Model and Dynamic Model classes. The Process class is 
needed for controlling model types displayed in 3D space and showing visual conversion 
processes between different model types. Hence, we define Control and Effect classes as 
subclasses of the Process class. The Geometry Model class refers to 3D components of a 
target system being modeled, while The Dynamic Model class indicates 3D model 
 

37 
components of a dynamic model needed for visualizing the dynamic model (i.e., 
Geometry_for_UAV_Dynamic_Model class), as well as dynamic behaviors of the 
dynamic model in MXL (i.e., MXL_for_UAV_Dynamic_Model class). Finally Interaction 
Model class is included in the domain to provide a user interaction environment that 
allows users or modelers to change model representations. Figure 4-4 shows the classes 
defined in the domain. 
 
Figure 4-4. Class Definitions in Protégé 
4.2.2 Properties 
Data type properties and object properties are defined to connect classes and to give 
restrictions on certain classes. Figure 4-5 shows data type properties and object properties 
defined in the scene domain. In Table 4-1, the properties, which are data type properties 
and object properties defined in the scene domain, are described in detail. 
 
 
 

38 
Table 4-1. Properties 
Property 
Domain  
Range 
Contains 
Scene 
Aircraft, Sensor 
hasDynamic 
Aircraft, Sensor 
XML Schema Datatype (String) 
hasDynamicModel 
Display 
Geometry_for_UAV_Dynamic- 
_Model 
hasGeometry 
Aircraft, Sensor 
XML Schema Datatype (String) 
hasGeometryModel 
Display 
Geometry_Model 
hasMXL 
Dynamic_Model 
MXL_for_UAV_Dynamic_Mo- 
del 
hasRepresentation 
Dynamic_Model 
Geometry_for_UAV_Dynamic- 
_Model 
hasRepresentationForDyn-
amicModel 
Geometry_for_UAV_-
DynamicModel 
Aircraft 
isDynamicModel 
MXL_for_UAV_Dyn-
amic_Model 
Aircraft 
isGeometryModel 
Geometry_Model 
Aircraft 
isInteractionModel 
InteractionModel 
Scene 
TakesDisplay 
InteractionModel 
Display 
TakesDynamicProperty 
MXL_for_UAV_Dyn-
amic _Model 
UAV, JSTARS, F15 
TakesGeometryOfDynam-
icModel 
Geometry_for_UAV_-
Dynamic_Model 
UAV, JSTARS, F15 
TakesGeometryProperty 
Geometry_Model 
UAV, JSTARS, F15 
TakesProcess 
InteractionModel 
Process 
TakesSensors 
InteractionModel 
Sensor 
 
 
Figure 4-5. Property Definitions in Protégé 
 

39 
4.3 Blender Interface 
 
To achieve integrative multimodeling in 3D space, we need the following 
environments: 
6. 
A customizable dynamic modeling environment that allows modelers to define their 
own custom metaphors and store them into certain locations or to import proper 
representations for their dynamic models from libraries of prefabricated geometric 
model components.  
7. 
A knowledge management environment that enables modelers to extend the scope 
of a scene domain and/or to create any instances of certain classes or subclasses by 
providing an ontology editing functionality such as Protégé. 
8. 
A human interaction modeling environment that provides modelers to formalize 
and execute human interactions so that they can change the representations of the 
heterogeneous model types.  
9. 
A simulation/interaction environment that allows modelers to simulate their 
dynamic models and to enable human computer interactions. 
  
We developed a Python-based interface, Blender Interface, which can support these 
types of environments. Blender Interface consists of four components, Model Explorer, 
Ontology Explorer, Exporter, and Simulation. Figure 4-6 depicts the overall integrative 
multimodeling environment in the Blender software. The environment consists of Blender 
3D Window (Scene Editor), Blender Interface, and Blender Logic Brick. Geometry and 
dynamic models for a certain system are composed in the Scene Editor, while specifying 
the dynamic model types and styles for the system and generating Python simulation 
code for the dynamic model in the Blender Interface. The Python code is inserted into 
Blender Logic Brick to simulate the dynamic model. In addition, the interaction model is 
implemented and executed in the Blender Logic Brick for providing a human computer 
interaction environment. In the following subsections, the model architecture used in the 
 

40 
RUBE library system and each component in Blender Interface, as well as Blender Game 
Logic are explained in detail. 
 
 
Figure 4-6. Blender Environment 
4.3.1 Model Architecture 
To use Blender Interface, RUBE must be installed. The RUBE has four folders: 
primitive, predefined theme, user-defined theme, and rube_utility folders. The primitive 
and predefined theme folders are given for users to provide libraries containing dynamic 
model objects and the corresponding MXL files and functions. Figure 4-7 shows the 
model architecture in the library system. As the names imply, the primitive folder has 
primitive blender objects, such as cube and sphere, with the corresponding MXL file and 
function for each model type, such as FSM or FBM. The predefined theme folder 
contains prefabricated customized and personalized blender objects, as well as MXL files 
and functions. If modelers want their own model representations, they can create an 
object and store it into a proper model-type folder under the user-defined theme using the 
 

41 
Exporter component provided by Blender Interface. The reason for providing the model 
component repository (i.e., primitive, predefined theme, and user-defined folders) is that 
we give modelers flexibility in model representation. Figure 4-8, for example, shows a 
rendered image of the finite state machine representation for a certain system using a tank 
and pipe metaphor in the predefined theme’s FSM folders. Figure 4-9 shows the different 
presentation for the same system with primitive objects, spheres and arrows, in the 
primitive’s FSM folders. After installing RUBE, the modelers load 
“Blender_Interface.py” from the rube_utility folder and then execute it to utilize Blender 
Interface which is shown in Figure 4-6.  
 
 
Figure 4-7. Model Architecture 
 

42 
   
Figure 4-8. FSM with Tank-Pipe Metaphor 
   
Figure 4-9. FSM with Primitives 
On the left side of Figure 4-7 we find that each model type is further divided into 
its model elements; each element is classified into detailed areas. Likewise, each area is 
further specified. For example, the functional block model (FBM) folder has two 
subfolders, Function and Trace, which are elements of FBM. The Function folder has 
three specific areas, Arithmetic, General, and Sensor. In Arithmetic, the Add_2_1 
arithmetic function is found, which has two subfolders according to data types, Integer 
and Float. The right side of Figure 4-7 shows the three files associated with the Add_2_1 
arithmetic function for float data. The Python file (i.e., Add_2_1.py) contains the 
following simple program code (the number “2” in the file name represents the number of 
input, while the number “1” represents the number of output); 
 

43 
def Add_2_1 ( parameter_1,  parameter_2): 
      sum = parameter_1 + parameter_2 
      return sum 
Also, we need 3D objects to explicitly represent geometric elements of dynamic 
models in 3D space. The Add_2_1.obj contains the 3D object associated with the 
function Add_2_1. In this case, the file contains a cube since we want to visualize the 
block element as a primitive type. The MXL file (i.e., Add_2_1.mxl) contains the 
following expression to represent semantics of the Add_2_1: 
<block id = “Add_2_1.obj”> 
   <input id = “Add_2_1_float_in_1” datatype = “Float”/> 
   <input id = “Add_2_1_float_in_2” datatype = “Float”/> 
   <output id = “Add_2_1_float_out_1” datatype = “Float”/> 
   <script lang = “Python” src = “Add_2_1.py” func= “Add_2_1”/> 
</block> 
The id of the block points to the primitive 3D object, while the func of the script 
indicates the function “Add_2_1” defined in “Add_2_1.py.” Also, two float input and a 
float output ports are included. Each low folder in the model architecture contains three 
files, as in Figure 4-7, to represent its functionality, geometry, and semantics in a set of 
pairs.  
4.3.2 Model Explorer 
Model Explorer reflects the model architecture, as shown in Figure 4-10, and is 
used for the dynamic modeling process. It provides flexibility in model presentation and 
efficiency in model creation to modelers. The concept of Windows Explorer is utilized for 
building Model Explorer since most modelers are well acquainted with Windows 
 

44 
Explorer. Using Model Explorer, modelers are able to search model objects, which they 
want to import, within the RUBE folders. They then generate proper model objects in the 
specific positions of Blender 3D Editor specified by the modelers. Also, modelers select 
and import connection objects, such as pipes or arrows, to represent connectivity between 
main model components.  
 
Figure 4-10. A Snapshot of Model Explorer 
We developed a “snap to grid” algorithm to deal with connectivity in 3D space, that 
is, the algorithm makes scaling, rotation, and transformation matrices for the connection 
objects using vector operations. Therefore, when given non-connection-related objects in 
a 3D scene, the modelers do not need to relocate, resize, and re-rotate any connection 
objects. This indicates that the algorithm can place the connection objects exactly 
between the source and target model components according to the modelers’ requests. 
The “snap to grid” algorithm provides two approaches, “By a user specification” and “By 
an algorithm.” 
 

45 
• 
 By a user specification  
o Point two blocks/states sequentially with mouse. The first object 
represents a source, and the second one indicates a target. 
       
 A    
 B 
  Figure 4-11. Point a Source and a Target Objects. A) Point a Source and B) 
Point a Target 
o Select a connector element (i.e., a pipe or an arrow) from the Model 
Explorer, and then press the button. 
                                
 
                                            Figure 4-12. Select a Connection Object 
o The selected connector is located exactly between two model components. 
                                                
 
 
                                                         Figure 4-13. Connection 
• 
By an algorithm  
 

46 
o Locate a mouse pointer between two objects. 
o Select a connector element (i.e., a pipe or an arrow) from the Model 
Explorer, and then press the button. 
                              
 
                                           Figure 4-14. Select a Connection Object 
o The selected connector is located exactly between two model components. 
                                              
 
                                                      Figure 4-15. Connection 
4.3.3 Ontology Explorer 
Ontology Explorer is developed for the following three reasons: 
• 
Provide an alternate modeling method for dynamic or geometry models 
• 
Manage an OWL file by allowing users to make their own classes or subclasses 
• 
Construct a model component database for reusability by allowing users to create 
instances of OWL classes or subclasses 
Like Model Explorer, the concept of Ontology Explorer is similar to that of 
Windows Explorer. Ontology Explorer reflects the OWL file which is shown in Figure 4-
3. To create Ontology Explorer, XML technologies, such as 4Suite [71] and extensible 
 

47 
stylesheet language transformations (XSLT), are utilized since the OWL file is one of 
XML-related languages. We may consider Ontology Explorer as another form of 
ontology visualizations, that is, in the case of ezOWL it visualizes an ontology as a 
diagrammatic representation, while Ontology Explorer represents the ontology as an 
instance-based hierarchical structure. The ontology visualization process is as follows:  
1. 
Parse the OWL file using XSLT. 
 
2. 
Classify the file into three parts, Class, Subclass, and Instance. 
 
3. 
Store each section into List data structure. 
 
4. 
Using Python, displaying the OWL file as a hierarchical structure.  
 
 
Figure 4-16. A Snapshot of Ontology Explorer 
Figure 4-16 shows the snapshot of Ontology Explorer. In Figure 4-16, the numbers 
next to class or subclass names indicate the number of instances associated with the 
classes or subclasses. If a modeler clicks a “+” button next to a class or subclass name, 
geometry and dynamic model components’ location information is displayed, as shown in 
 

48 
Figure 4-16, for modelers to provide an alternative modeling method by importing a 
stored geometry and/or dynamic objects. If pressing a button associated with hasDynamic 
or hasGeometry, the corresponding object will appear in the Blender 3D Editor. In 
addition, Ontology Explorer also provides an ontology editing capability like Protégé.  
Modelers can create their own classes or subclasses or generate instances of OWL 
classes or subclasses for maintaining or extending the scope of a scene domain in 
Ontology Explorer. The buttons (i.e., editing button) framed in white bold lines in Figure 
4-16 are provided for an ontology editing functionality. An option menu, including Class, 
Subclass, and Instance, will appear when pressing the button. By choosing one of the 
options and then providing necessary data, such as ID and location, modelers can manage 
their scene domain without leaving the environment. Alternatively, they can handle the 
domain with other ontology editing tools, such as Protégé or SWOOP.   
For example, a modeler wants to create an instance of the JSTARS class in the 
scene domain. The modelers have to consider the following steps: 
Step 1: Press the editing button of the JSTARS class then pop-up menu will appear, and 
then select the Instance option in the menu. 
 
       Figure 4-17. Pop-Up Menu 
Step 2: Enter an ID of the instance, such as “Jstars_1,” then press the “OK” button. 
 
 

49 
       Figure 4-18. Instance Creation 
Step 3: Choose a proper dynamic object in the Scene Editor to create the hasDynamic 
property of the instance then press the Select a dynamic object button in the Blender 
Interface. In this example, the middle cube is selected since it is the dynamic model 
component of the JSTARS. 
 
       Figure 4-19. hasDynamic Property Creation 
Step 4: Select a geometry object in the Scene Editor to create the hasGeometry property 
of the instance then press the Select a geometry object button in the Blender Interface.  
 
       Figure 4-20. hasGeometry Property Creation 
Step 5: Specify a location and a file name (i.e., “obj” is a file extension) of the geometry 
object for the future reuse then press the “OK” button. The selected geometry object is 
imported through an import algorithm and stored at the specified location with the file 
name. In this example, we specify the location as “c:\geo\” and the file name as “js.obj.” 
 

50 
 
Figure 4-21. File Name and Location Specification 
Step 6: A newly created instance appears in the Ontology Explorer. In this case, 
“Jstars_1” is created through the steps above with hasDynamic and hasGeometry data 
type properties. By pressing a hasGeometry button and a hasDynamic button, we can 
activate the instance in geometry and/or dynamic modeling processes since the two 
properties indicate corresponding object file locations. 
 
Figure 4-22. New Instance 
Once we create any instances (i.e., a model component database) within the 
Ontology Explorer, we can take advantage of the instances in modeling processes. Figure 
4-23 shows an example of how the instance is used in a modeling process. A modeler can 
export a geometry object and/or a dynamic object by pressing proper buttons shown in 
the Ontology Explorer. When the hasGeometry button is pressed in Figure 4-23, the 
geometry structure of the JSTARS appears in the Scene Editor. 
 

51 
 
Figure 4-23. Import Process 
4.3.4 Export 
Export [72] is included in Blender Interface to allow modelers to build their own 
customized or personalized dynamic objects. Figure 4-24 shows a graphical user interface 
for Export. For example, if a modeler wants to build a primitive FBM block with three 
inputs and one output which represents an arithmetic integer ADD function, the modeler 
has to create an object representing a functional block as shown in Figure 4-24 in the 
Blender 3D Editor. The modeler then specifies a location for storing the object and 
presses the export button in the Export. In addition, the modeler creates MXL, which 
describes dynamic behavior for the dynamic component, and a Python code for the 
integer ADD function. The modeler then stores these files in the location where the 3D 
dynamic object is already stored. Modelers could produce their own MXLs and functions 
for their customized and personalized model components without having knowledge of 
MXL and Python syntax since we provide default MXLs and functions in the library 
system. The defaults could give modelers guidelines on generating their own files. 
Figures 4-24 and 4-25 depict the FBM block object, MXL, and Python code for the 
example. 
 
 

52 
 
Figure 4-24. GUI for Export 
 
Figure 4-25. MXL and Function Definitions for the Example 
 
4.3.5 Simulation 
From given dynamic model components in Blender 3D Editor, we can generate a 
simulation code for a target system through the RUBE framework. The simulation code is 
Python scripting language. The process for generating a simulation code includes three 
steps, as shown in Figure 4-26:  
Step 1: BlenderToMXL 
def ADD_3_1(parameter1, parameter2, parameter3): 
    sum = parameter1 + parameter2 + parameter3 
    return sum 
<block id = "ADD_3_1"> 
    <input id = "Add_3_1_Int_in_1" datatype="Integer" index="0"/> 
    <input id = "Add_3_1_Int_in_2" datatype="Integer" index="1"/> 
    <input id = "Add_3_1_Int_in_3" datatype="Integer" index="2"/> 
    <output id = "Add_3_1_Int_out_1" datatype="Integer" index="0"/> 
    <script lang="Python" src="Python_src.py" func="Add_3_1"/> 
</block> 
 

53 
 First, an MXL file for a given scene dynamic model is created by gathering all 
segm
he MXL file is converted to a low-level XML language called 
dynam
for simulation is generated from DXL using DOM. 
ate a given 
dynam
ect 
ented MXL files from the libraries, since the library system contains Blender 
objects, as well as the corresponding MXLs and functions in a set of pairs. 
Step 2: MXLToDXL 
 Using XSLT, t
ics exchange language (DXL). 
Step 3: DXLToPython 
The Python code 
Figure 4-26 shows a graphical user interface for Simulation. To simul
ic model, Blender Game Logic is employed, which is discussed in the following 
section. Blender Game Logic consists of three components: Sensors, Controllers, and 
Actuators. The generated Python code is placed within the Controllers of a dummy obj
so that the Actuators of the dummy object can distribute current simulation values to 
Sensors of the main dynamic blocks which compose a dynamic model. 
 
Figure 4-26. GUI for Simulation 
 

54 
4.2.6 Blender Game Logic 
Blender software provides not only a 3D authoring environment, but also a 
simulation environment called Blender Game Logic. Using Blender Game Logic, 
modelers interact with a 3D world in real time by controlling scene objects which can 
interact with other scene objects existing in the 3D world. Sensors, Controllers, and 
Actuators, as shown in Figure 4-27, are key components composed of Blender Game 
Logic. We think of the Sensors as the senses of a life form, the Controllers as the brain, 
and the Actuators as the muscles. On the other hand, we can consider Blender Game 
Logic as dynamic models. Sensors are FBM blocks with no inputs (they drive or generate 
the data), Controllers are FBM blocks with inputs and outputs, and Actuators are FBM 
blocks with no outputs. Hence, the concepts of the Blender Game Logic could be applied 
to implement an interaction model for user interactions. We utilize Blender Game Logic 
not only for simulating a dynamic model, but for constructing an interaction model and 
executing the model.  
 
 
Figure 4-27. Blender Game Logic 
 
 

CHAPTER 5 
CASE STUDY 
In this Chapter, we demonstrate how an integrative multimodeling can be achieved 
for a certain application domain through our methodology, as proposed in Chapter 3. 
Two examples, battle scene and light bulb, are introduced to support our idea and 
approach. In the first example, battle scene, we employ a simple functional block model 
(FBM) to represent dynamics of the model components, while two different model types 
(i.e., multimodel), functional block model (FBM) and finite state machine (FSM), are 
used for representing dynamics of the light bulb using a chemistry metaphor.  
5.1 A Military Application  
In this particular example, three geometry objects represent one unmanned aerial 
vehicle (UAV), one F15, and one joint surveillance target attack radar system (JSTARS), 
respectively. The objects are flying around and communicating with each other. To avoid 
simulation complexity, we simplify a simulation scenario, which means UAV passes 
target information to JSTARS, and then JSTARS commands F15 to attack the target. We 
can represent the scenario as a functional block model (FBM). Figure 5-1 shows the 2D 
diagram representation for FBM which can be modeled as a 3D dynamic model using 
Blender Interface. The UAV block randomly generates a boolean value (0/1) and sends it 
to the JSTARS block. If the JSTARS block receives “True,” it conveys the value to the 
F15 block. The F15 block counts the “True” value as the number of received attack 
messages. 
55 

56 
 
Figure 5-1. 2D Dynamic FBM Representation of the Combat Scene 
5.1.1 Modeling for Geometry and Dynamic Models 
To create geometry objects in the Blender 3D Editor, there are three possible 
approaches: 
10. 
Directly build geometry objects in the Blender 3D Editor. 
11. 
Append geometry objects using Blender menus. 
12. 
Reuse geometry objects by importing class instances from the ontology using 
Ontology Explorer.    
For the example, the objects are created by the first method since the ontology has 
no any instance initially. To avoid model complexity, geometry objects are placed in the 
first layer of the Blender 3D scene since Blender provides multiple 3D layers to help 
modelers create complicated 3D scenes. The dynamic model for the example can be 
generated in the second layer using Model Explorer or Ontology Explorer. For the 
example, Model Explorer is used to create dynamic objects since the library system 
provides essential primitive objects and corresponding MXLs and functions. If modelers 
want customized or personalized objects, they can create and store their own objects and 
then import the objects using Export and Model Explorer. In this example, the 
“primitive” folder is selected because we want to represent a dynamic model as a 
primitive type such as a cube. Then the “FBM” folder is selected as a model type. 
Because FBM consists of two model elements, such as Function and Trace, we have to 
choose one of the model element folders and then select any proper function or trace 
types. To represent the first block in Figure 5-1, the boolean random generator is selected 
UAV 
JSTARS
F15 
0/1 
1 
 

57 
as Function. If we press the button representing the object file, we can see the 
corresponding object in the Blender 3D Editor. To represent the first arrow between the 
first and second blocks in Figure 5-1, we choose the Trace folder and select “Arrow,” 
then we press the object button. As with the first block, the arrow object appears in the 
scene and is placed exactly between the first and second block since we support the 
algorithm for topological connectivity called “snap to grid.” All blocks and traces in the 
2D diagram can be generated with the same manner as previously explained. If we create 
new customized dynamic model components to represent the scene, we can store the 
components for future reuse by creating instances of respective classes in Ontology 
Explorer. 
5.1.2 Modeling for Interaction Model  
To achieve integrative multimodeling within the Blender environment, an 
interaction model for user interactions is necessary since the interaction model allows 
modelers to manipulate heterogeneous model types in 3D space. The interaction model is 
simply a dynamic model for modelers who are driving the system. We implement an 
interaction model as a dynamic model in Blender Game Logic. Figure 5-2 shows a 2D 
diagrammatic representation of an interaction model for the example.  
 

58 
 
Figure 5-2. 2D Dynamic Model (FBM) Representation of Interaction Model 
Position Tracking 
for  
Geometry Objects 
Position
Activate 
If we construe the interaction model (IM) verbally based on Figure 5-2, the 
following interpretation is possible:   
• 
Two sensors are needed for driving user interactions; one (i.e., Sensor_1) is for 
changing a geometry model to a dynamic model. The other (i.e., Sensor_2) is for 
changing a dynamic model to a geometry model 
• 
Scene Controller manages sensor inputs. For example, if a current scene is a 
geometry model and Sensor_1 is activated, then Scene Controller ignores the input 
of Sensor_1. Otherwise (i.e., if a current scene is a geometry model and Sensor_2 is 
activated), Scene Controller enables Activate Geometry Objects. 
• 
Position Tracking for Geometry/Dynamic Objects captures the current positions of 
geometry/dynamic objects so that the corresponding dynamic/geometry objects can 
be replaced in the same positions. 
• 
Activate Geometry/Dynamic Objects retrieves geometry/dynamic model 
components associated with dynamic/geometry model components. 
• 
Position Setting for Geometry/Dynamic Objects assigns new locations, which are 
the positions of dynamic/geometry model components caught by Position Tracking 
Dynamic/Geometry Objects, to proper geometry/dynamic model components. 
• 
Display geometry/dynamic model components through Morphing Process (i.e., 
fade-in and fade-out effects). 
Based on the 2D diagrammatic representation, we embody the interaction model, as 
shown in Figures 5-3 and 5-4, within the Blender Game Logic. In the Blender Game 
Sensor_1 
Setting for 
Dynamic 
Dynamic 
Objects 
Objects 
Sensor_2 
Scene 
Controller 
Position Tracking 
for  
Dynamic Objects 
Morphing 
Process 
Display
Geometry 
or 
Dynamic 
Models 
Position
Activate
Setting for 
Geometr  
y
Objects 
Geometry 
Objects 
 

59 
Logic, there are Sensors, Controllers, and Actuators. These are used to create "Logic 
Brick" graphs which drive the interaction. The Game Engine can cover most interaction 
behaviors since it has well-defined built-in Sensors and Actuators. If a user, however, 
wants more complicated interactions, the user can handle the interactions by Python 
scripting language. After creating a Python file, the user puts it in one of the Controllers 
and connects the Controller with any proper Actuator.  
 
Figure 5-3. Interaction Model for the F15 (Geometry Object) 
 
 
Figure 5-4. Interaction Model for the F15 (Dynamic Object) 
 

60 
To implement the interaction model of the example in Blender Game Logic, the 
following Sensors, Controllers, and Actuators are needed: 
1. Two keyboard sensors (per each geometry and dynamic object) for driving user 
interactions.  
• “G” key: If a user presses the “G” key, a current dynamic model 
component is ultimately changed into a corresponding geometry model 
component 
• “D” key: If a user presses the “D” key, a current geometry model 
component is ultimately changed into a corresponding dynamic model 
component 
2. Two “AND” controllers for triggering a morphing effect such as fade-in or fade-
out  
3. Three Python-coded controllers for capturing a position of the current 
dynamic/geometry model object or for assigning a new position to the 
corresponding geometry/dynamic model object 
4. Three Message Actuators for sending current position values (i.e., x, y, and z 
values) to corresponding geometry/dynamic objects’ Message Sensors. 
5. Three Message Sensors for receiving current geometry/dynamic object positions 
from Message Actuators and activating the corresponding controllers to set the 
positions of dynamic/geometry objects 
6. Two InterPOlation (IPO) actuators for changing transparencies of dynamic and 
geometry objects for the morphing effect applied for geometry and dynamic 
model components 
Figures 5-3 and 5-4 show the example of the interaction logic applied to the F15 
(i.e., geometry and dynamic objects for the F15). In addition, one Always sensor, one 
Expression controller, and one Motion actuator are employed to animate the geometry 
model. In the same manner, we can apply the interaction logic to other model 
components, such as the UAV and JSTARS.  
5.1.3 Code Generation 
The three steps, BlenderToMXL, MXLToDXL, and DXLToPythonCode, are needed 
to generate a Python-based simulation code from given dynamic model components. First 
 

61 
we have to create an overall MXL representation for a certain dynamic model by 
collecting all individual MXL files, which are associated with dynamic model objects, 
from libraries. The overall MXL representation for the example is shown in Figure 5-5. 
Each block contains certain functional information for the dynamic model, while each 
trace represents topological connectivity for the dynamic model. The Block for JSTARS, 
for example, has its ID, input and output ports, and function with ID. In the case of a 
trace, it shows topological connectivity using “from” and “to” attributes. The connection 
information is automatically generated through the algorithm, “snap to grid.” In addition, 
simulation information is also shown in Figure 5-5. Default values are currently 
predefined for the simulation attributes. If a user wants to change the values, the user can 
modify the values in the Blender Interface source code.  
 
 
 
 
 
 
 
 
 
Figure 5-5. MXL for the Example 
<?xml version="1.0" encoding="UTF-8" ?> 
<MXL> 
   <fbm id="MXL"> 
       <block id = "UAV"> 
           <output id = "UAV_Boolean_out_1" datatype="Boolean" index="0"/> 
           <script lang="Python" src="UAV.py" func="Generation_Boolean"/> 
       </block> 
       <block id = "JSTARS"> 
           <input  id = "JSTARS_Boolean_in_1" datatype="Boolean" index="0"/> 
           <output id = "JSTARS_Boolean_out_1" datatype="Boolean" index="0"/> 
           <script lang="Python" src="JSTARS.py" func="Evaluation_Boolean"/> 
       </block> 
       <block id = "F15"> 
           <input id = "F15_Boolean_in_1" datatype="Boolean" index="0"/> 
           <script lang="Python" src="F15.py" func="Accumulation_Boolean"/> 
       </block>     
       <trace from="UAV_Boolean_out_1" to="JSTARS_Boolean_in_1"/> 
       <trace from="JSTARS_Boolean_out_1" to="F15_Boolean_in_1"/> 
   </fbm> 
   <simulation strat_time="0" end_time="100" delta_time="0.1" cycle_time="0.1"/> 
</MXL>  
 
After MXL is generated, DXL, which is a lower level modeling language, can be 
created from MXL using MXLToDXLTranslator. The DXL represents a homogeneous 
 

62 
dynamic model consisting of block, port, and connect. The DXL for the example is 
shown in Figure 5-6.  
After that, we can produce a Python simulation code through DXLToPythonCode. 
A 3D dummy object is needed to insert the generated Python code into the Controller of 
the dummy object for simulating the example. After placing the code in the Controller, 
the Actuator of the dummy object can distribute current simulation values to each Sensor 
of the dynamic blocks for simulation. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 5-6. DXL for the Example 
<?xml version="1.0" encoding="UTF-8"?> 
<DXL> 
   <block id="UAV" type="SYNC" > 
       <port id="UAV.UAV_Boolean_out_1" type="OUTPUT"    
                 target="JSTARS.JSTARS_Boolean_in_1" data_type="Boolean"/> 
       <definition id="Python_src.py" func="Generation_Boolean" lang="Python"/> 
   </block> 
   <block id="JSTARS" type="SYNC" > 
       <port id="JSTARS.JSTARS_Boolean_in_1" type="INPUT"      
                 source="UAV.UAV_Boolean_out_1" data_type="Boolean"/> 
       <port id="JSTARS.JSTARS_Boolean_out_1" type="OUTPUT"  
                 target="F15.F15_Boolean_in_1" data_type="Boolean"/> 
       <definition id="Python_src.py" func="Evaluation_Boolean" lang="Python"/> 
   </block> 
   <block id="F15" type="SYNC" > 
       <port id="F15.F15_Boolean_in_1" type="INPUT"  
                 source="JSTARS.JSTARS_Boolean_out_1" data_type="Boolean"/> 
       <definition id="Python_src.py" func="Accumulation_Boolean" lang="Python"/> 
   </block>     
   <connect id="UAV_Boolean_out_1ToJSTARS_Boolean_in_1"> 
       <port id="UAV_Boolean_out_1ToJSTARS_Boolean_in_1.OP1" type="INPUT"  
                 source="UAV.UAV_Boolean_out_1"/> 
       <port id="UAV_Boolean_out_1ToJSTARS_Boolean_in_1.IP1" type="OUTPUT"  
                 source="JSTARS.JSTARS_Boolean_in_1"/> 
   </connect> 
   <connect id="JSTARS_Boolean_out_1ToF15_Boolean_in_1"> 
       <port id="JSTARS_Boolean_out_1ToF15_Boolean_in_1.OP1" type="INPUT"  
                 source="JSTARS.JSTARS_Boolean_out_1"/> 
       <port id="JSTARS_Boolean_out_1ToF15_Boolean_in_1.IP1" type="OUTPUT"  
                 source="F15.F15_Boolean_in_1"/> 
   </connect> 
   <simulation strat_time="0" end_time="100" delta_time="0.1" cycle_time="0.1"/> 
</DXL> 
 
 
Figure 5-6. DXL for the Example 
 

63 
5.1.4 Integrative Multimodeling with Simulation 
Figures 5-7 through 5-10 represent a conversion process with simulation from a 
geometry model to a dynamic model applied to one F15, one JSTARS, and one UAV. 
The four figures are described in detail: 
• 
Figure 5-7: This is the start of the scenario with the three objects. 
• 
Figure 5-8: Modelers decide to investigate the dynamics of the scenario at a certain 
point. 
• 
Figure 5-9: Geometry objects are transformed into their respective dynamic model 
components through fade-in and fade-out effects when modelers press the “D” key 
on the keyboard 
• 
Figure 5-10: The dynamic model appears to show how the objects interact. 
In addition, modelers change the model types from the dynamic model to the 
geometry model by pressing the “G” key in Figure 5-10. The number in the figures 
implies the result of the F15, that is, the number of received attack messages from 
JSTARS.  
 
Figure 5-7. Initial Scene (Geometry Model) 
 

64 
 
Figure 5-8. Scene Prior to Interaction 
 
 
 
Figure 5-9. Model Morphing 
 
Figure 5-10. Dynamic Model 
 

65 
5.2 A Light Bulb Application  
We implement the light bulb example using multiple model types, such as FBM 
and FSM. We define three blocks representing FBM. The first block generates random 
numbers, 0 or 1, which are fed into the second block as input values. The second block 
takes input values from the first block and output a certain value which is fed into the 
third block. Finally the third block displays its input values which are the results of the 
second block. We employ FSM to represent dynamics of the light bulb. The light bulb 
consists of a light socket, a switch, and a bulb as shown in Figure 5-11. We will map each 
component of the light bulb to each state of the FSM which will be discussed in the later 
section. Three states and six transitions are defined to structure the FSM for the example. 
A 2D diagram of the FSM is depicted in Figure 5-12. The FSM is inserted into the second 
block of the FBM. Figure 15-13 shows the overall (i.e., multimodel) 2D diagram 
representation for the light bulb example. 
                             
 
Figure 5-11. Light Bulb 
 
 

66 
                              
 
Figure 5-12. FSM Representation for the Light Bulb Example 
 
Figure 5-13. Multimodel Representation for the Light Bulb Example 
 
S1
 
 
Random  
Display 
In the following subsections, we will introduce the ontology that defines our 
application domain, light bulb. Modeling processes (i.e., a geometry modeling, a dynamic 
modeling, and an interaction modeling) for the example will be then discussed. Finally 
we will explain the process for generating a simulation code for the example.  
5.2.1 Ontology  
Figure 5-14 shows the ontology for the domain of the light bulb application. Most 
parts of the ontology are almost identical with the previous application domain, battle 
scene, in terms of concepts and approaches for modeling. Therefore, we focus mainly on 
explaining the light bulb domain in this section. We create Light Bulb, Light Socket, Light 
Switch, and Bulb classes since a light bulb is usually composed of three components, a 
Number  
Generator 
(Current  
State) 
S2
1
S3
1
 

67 
light socket, a light switch, and a bulb. We connect Light Bulb class with Scene class 
using a “contains” relationship, and the Light Bulb class is connected to its 
subcomponents’ classes, Light Socket, Light Switch, and Bulb classes, using an 
“isComposedOf” relationship. We can visualize a geometry structure of the light bulb by 
taking geometry properties of each subcomponent and construct a dynamic model by 
taking dynamic properties of each subcomponent.  
 
Figure 5-14. Light Bulb Ontology 
 

68 
5.2.2 Modeling for Geometry and Dynamic Models 
The light bulb, representing the geometry model, is created in the first layer of the 
Blender 3D scene. For the aesthetic aspect, we replace the light bulb with a lamp. Then 
we create geometric objects to represent a dynamic model for the example. Two model 
types, FBM and FSM, are utilized to create the dynamic model. In this example, we use a 
chemistry metaphor. Therefore, we import three chemistry holder objects and two 
chemistry pipe objects from Model Explorer to indicate three functional blocks and two 
traces. The first object has a function with one output port for generating integer random 
numbers, 0 or 1. The second object has a null function with one input and one output 
ports since the FSM is replaced with its functionality. The last object has a display 
function with one input port. To construct the FSM for the light bulb example, three 
states and six transitions are defined:   
• 
State 1: off unplugged 
• 
State 2: off plugged 
• 
State 3: on plugged 
• 
Transition 1: from State 1 to State 2 
• 
Transition 2: from State 2 to State 3 
• 
Transition 3: from State 3 to State 2 
• 
Transitions 4, 5, and 6: reflexive transitions for input value 0 
Then we map each state to each model component. The mapping rules are as 
follows: 
• 
A light socket is mapped to State 1 
• 
A light switch is mapped to State 2 
• 
A bulb is mapped to State 3 
 

69 
Chemistry glasses and pipes are employed to represent states and transitions, 
respectively. Based on the mapping rules and metaphor concepts, we import three 
chemistry glass objects and three chemistry pipe objects using Model Explorer.  
5.2.3 Modeling for Interaction Model  
Figure 5-15 depicts a 2D diagrammatic representation of an interaction model for 
the light bulb example. Most parts of the interaction model are identical with the previous 
example. In this example, however, Sensor_3 is added to the interaction model for 
allowing users/modelers to explore geometry model and dynamic model (i.e., FSM) 
simultaneously.  
 
Figure 5-15. 2D Dynamic Model (FBM) Representation of Interaction Model 
Activate 
 
Dynamic 
Sensor_1 
Models 
Scene 
Morphing 
Controller 
Process 
To implement the interaction model of the example in Blender Game Logic, the 
following Sensors, Controllers, and Actuators are needed: 
• 
Three keyboard sensors (per each geometry and dynamic object) for driving user 
interactions.  
o “G” key: If a user presses the “G” key, a current dynamic model 
component is ultimately changed into a corresponding geometry model 
component 
 
Activate
Sensor_2 
Display
Geometry 
Geometry 
or 
Model
Dynamic 
Models 
 
Activate
FSM  
Model
Sensor_3 
 

70 
o “D” key: If a user presses the “D” key, a current geometry model 
component is ultimately changed into a corresponding dynamic model 
component 
o “F” key: If a user presses the “F” key, the dynamic model (FSM) for the 
light bulb appears  
• 
Three “AND” controllers for triggering a morphing effect such as fade-in or fade-
out and activating the FSM representation for the light bulb  
• 
One Python-coded controller for a color change effect to represent data flows 
• 
One Message Sensor for receiving newly created state information 
• 
Two InterPOlation (IPO) actuators for changing transparencies of dynamic and 
geometry objects for the morphing effect applied for geometry and dynamic model 
components 
• 
Two Visibility actuators for changing colors  
Figure 5-16 shows the example of the interaction logic applied to one of chemistry 
glass representing one of states. In the same manner, we can apply the interaction logic to 
other model components.  
 
Figure 5-16. Interaction Model for State 3 
 

71 
5.2.4 Code Generation 
The overall MXL representation for the example is shown in Figures 5-17 and 5-
18. Because we represent the example as multimodel concepts, two MXL files are 
created.  
 
Figure 5-17. MXL for the Example 
<?xml version="1.0" encoding="utf-8"?> 
<MXL> 
   <fbm id ="fbm"> 
 
<block id="Generator"> 
  
       <output id="FBM_Generator0_output" datatype="Integer" index="0"/> 
 
  
<script lang="Python" src="Generator.py" func="Generator"/> 
 
</block> 
 
 
 
<block id="Display"> 
 
 
<input id="FBM_Display0_input" datatype="String" index="0"/> 
 
 
<script lang="Python" src="Display.py" func="Display"/> 
 
</block> 
 
 
 
<block id="Generic"> 
 
 
<input id="FBM_Generic0_input" datatype="Integer" index="0"/> 
 
 
<output id="FBM_Generic0_output" datatype="String" index="0"/> 
 
                <fsm id="fsm_1" src = "fsm_1.mxl"/> 
 
</block> 
 
 
 
<trace from = "FBM_Generator0_output" to = "FBM_Generic0_input"/> 
 
<trace from = "FBM_Generic0_output" to = "FBM_Display0_input"/> 
   </fbm> 
   <simulation start_time = "0" end_time = "10" delta_time = "1" cycle_time = "0.1"/> 
</MXL> 
In Figure 5-17, “Generic” block contains an MXL file for FSM. The MXL file, as 
shown in Figure 5-18, has three states and six transitions to represent semantics of the 
light bulb.  
Three states and six transitions are generated based on given state objects (i.e., 
chemistry glasses and pipes) in the scene editor. In the case of transitions, they show 
topological connectivity using “from” and “to” attributes. The connection information is 
automatically generated through the algorithm, “snap to grid.”  
Using MXLToDXLTranslator, we create a DXL file from the MXL. The DXL for 
the example is shown in Appendix B. Then we can produce a Python simulation code 
 

72 
through DXLToPythonCode. The simulation code is inserted into the Controller of one of 
dummy objects such as a camera or a lamp.  
 
 
Figure 5-18. MXL for FSM 
<?xml version="1.0" encoding="utf-8"?> 
<MXL> 
 
<input id="FBM_Generic0_SUB_input" datatype="Integer" index="0"/> 
 
<output id="FBM_Generic0_SUB_output" datatype="String" index="0"/> 
 
<fsm id ="fsm_1"> 
 
 
<state id="SUB5_S1" start="true"> 
 
 
    <script lang="Python" src="S1.py" func="S1"/> 
 
 
</state> 
 
 
<state id="SUB6_S2"> 
 
 
    <script lang="Python" src="S2.py" func="S2"/> 
 
 
</state> 
 
 
<state id="SUB7_S3"> 
 
 
    <script lang="Python" src="S3.py" func="S3"/> 
 
 
</state> 
 
 
<transition from = "SUB5_S1" to = "SUB5_S1"> 
 
 
    <script lang = "Python" src = "FSM_T1_Tran.py" func = "FSM_T1_Tran"/> 
 
 
</transition> 
 
 
<transition from = "SUB6_S2" to = "SUB6_S2"> 
 
 
    <script lang = "Python" src = "FSM_T1_Tran.py" func = "FSM_T1_Tran"/> 
 
 
</transition> 
 
 
<transition from = "SUB7_S3" to = "SUB7_S3"> 
 
 
    <script lang = "Python" src = "FSM_T1_Tran.py" func = "FSM_T1_Tran"/> 
 
 
</transition> 
 
 
<transition from = "SUB5_S1" to = "SUB6_S2"> 
 
 
    <script lang = "Python" src = "FSM_T2_Tran.py" func = "FSM_T2_Tran"/> 
 
 
</transition> 
 
 
<transition from = "SUB6_S2" to = "SUB7_S3"> 
 
 
    <script lang = "Python" src = "FSM_T3_Tran.py" func = "FSM_T3_Tran"/> 
 
 
</transition> 
 
 
<transition from = "SUB7_S3" to = "SUB6_S2"> 
 
 
    <script lang = "Python" src = "FSM_T4_Tran.py" func = "FSM_T4_Tran"/> 
 
 
</transition> 
 
</fsm> 
</MXL> 
5.2.5 Integrative Multimodeling with Simulation 
Figures 5-19 through 5-21 represent a conversion process with simulation from a 
geometry model to a dynamic model. In Figure 5-21, the integer number in the first block 
represents a generated random number, 0 or 1, and the string in the third block shows a 
current status of the FSM. Figure 5-22 depicts the situation of which two different model 
types are displayed simultaneously.  
 

73 
 
Figure 5-19. Scene Prior to Interaction (Geometry Model) 
 
Figure 5-20. Model Morphing 
 
Figure 5-21. Dynamic Model 
 

74 
 
Figure 5-22. Two Model Types (Geometry and Dynamic Models) 
 
 

CHAPTER 6 
CONCLUSION 
6.1 Summary of Results  
In this dissertation, our approach and methodology for integrative multimodeling 
have been presented. We have explained and discussed the integrative multimodeling 
environment and graphical user interfaces for the environment. Using the examples of the 
battle scene and the light bulb, we have demonstrated how the integrative multimodeling 
concepts are applied to real-world systems and how semantic web technology is adapted 
in the area of modeling and simulation.  
We have learned that effective ontology construction and human-computer 
interaction techniques are essential factors to support integrative multimodeling. In our 
research, ontology concepts are employed for defining our scene domain and formalizing 
the mapping concepts of different model components, as well as building a model 
component database. User interactions play an especially important role in integrative 
multimodeling to manipulate a scene. Therefore we have also presented the concept of 
interaction model and implemented the interaction model. One of the distinct points in 
integrative multimodeling is that the Blender Game Engine concepts are applied for 
building and executing the interaction model. Also the interaction model can be 
implemented and executed in a VRML environment since the interaction model is a kind 
of routing graph [73]. In addition, Model Explorer and Ontology Explorer have been 
presented as tools for facilitating the modeling process and managing the ontology. Also, 
the concepts of the “snap to gird” and the RUBE library system have been introduced. 
75 

76 
The contributions of this paper in the field of modeling and simulation can be 
summarized as follows: 
We provided an integrated modeling and simulation environment: The 
integrated modeling and simulation environment for geometry and dynamic models have 
been developed for supporting the viewing and interaction associated with multiple 
models under a Blender 3D environment and simulating a dynamic model as well as 
animating a geometry model in the same digital environment. 
We introduced ontology management and model database construction 
methods: Ontology Explorer in Blender Interface is developed for manipulating the 
ontology by allowing users to create class instances for constructing a model component 
database and to generate classes or subclasses within the OWL–based ontology for 
managing the OWL ontology without leaving the environment. Also, Ontology Explorer 
provides an alternate modeling process for geometry and dynamic models by reusing 
geometry and dynamic model objects as well as an ontology editing functionality. 
We presented an interaction model concept and modeling process for the 
interaction model: The concept of interaction model for integrative multimodeling is 
created and represented as a function block model (FBM) for formalizing human-
computer interactions. “Logic Brick” graphs are utilized for modeling the interaction 
model and executing the model. 
We provided an improved dynamic modeling environment: The library system 
and the “snap to grid” algorithm are provided for modelers to give flexibility and 
efficiency in model representation, as well as to facilitate a dynamic modeling process. 
 

77 
6.2 Future Research 
For future work, four areas of research related to an ontology-based modeling and 
simulation approach and Blender Interface on which we plan to focus our effort include 
Ontological Domain Extension, Model Type Extension, Interface Construction, and 
Visual Programming Support.  
6.2.1 Ontological Domain Extension 
Currently we adopt two different approaches for the use of ontologies within the 
integrative multimodeling environment. We have MXL and DXL schemas for specifying 
model types, model definitions, and model structures. Each schema defines the language 
as an ontology. Therefore we can check validation and verification for a certain model 
through the schemas. On the other hand, OWL representation is employed to describe a 
certain application domain as well as modeling knowledge regarding geometry, dynamic, 
and interaction models.  
Ideally we can represent model structure knowledge and modeling knowledge 
along with application domain knowledge in OWL. Consider the following two 
ontologies in OWL: 1) the FSM ontology, as shown in Chapter 2, which conceptualizes 
elements of FSM as well as relationships between elements and defines how an FSM is 
structured; and 2) the light bulb ontology, as shown in Chapter 5, which conceptualizes 
the domain of the light bulb as well as modeling knowledge. If we combine two different 
domain ontologies, the following issue naturally arises: How do we connect the different 
ontologies?  
We link Dynamic Model class in the light bulb ontology to FSM class in the FSM 
ontology using a sub-class relationship since FSM is one of the dynamic model types. 
Then each model component in the light bulb ontology, such as a light socket, a light 
 

78 
switch, or a bulb, is connected to one of the states specified in the FSM ontology. For 
example, according to our mapping rules which were discussed in Chapter 2, the light 
socket is connected to Start State. Likewise, using “is-a” relationships, the light switch 
and the bulb are connected to Final State since the FSM could reach one of the states 
(i.e., On/Off) in the end. Figure 6-1 shows the extended OWL representation which 
combines model information with modeling knowledge and application domain 
information for the light bulb example. 
 
Figure 6-1. Extended OWL Representation 
 
 

79 
Based on Figure 6-1, the following interpretation is possible:  
• 
The light bulb consists of a light socket, a light switch, and a bulb 
• 
The light bulb can be represented by an FSM model type  
• 
The FSM has three states and multiple transitions (“snap to grid” algorithm could 
catch the transition information from the given 3D transition objects) 
• 
The light socket represents State 1 (i.e., start state) 
• 
The light switch represents State 2  
• 
The bulb represents State 3 
If we append inference rules in the form of Semantic Web Rule Language (SWRL) 
logic [74] to the extended ontology as well as employ reasoning tools, such as Jess [75] 
and Racer [76], we could achieve an inference-based or rule-based modeling 
environment. In other words, using the reasoning tools we can interoperate between 
SWRL rules and OWL, not only semantically and syntactically, but also inferentially to 
get all the inferences.  
For example, if we use the Protégé as an ontology editor and a reasoning tool, we 
can implement the extended OWL, as shown in Figure 6-1, and may extract the following 
inferred first-order logics through Racer classification based on the extended OWL (all 
inferences are not shown): 
• 
Light_Bulb := Light_Socket ∪Light_Switch ∪Bulb 
• 
Light_Socket/Light_Switch/Bulb := (hasGeometry = 1 ∪hasDynamic = 1 
∪is_a_state_1/2/3 = 1) 
• 
FSM := State ∪ TransitionFunction 
• 
State :=  (StartAndFianlState = 1) ∩ (StartState = 1∪NormalState ≥ 1∪FianlState 
≥ 1) ∩ (StartState = 1∪FianlState ≥ 1)  
• 
TransitionFunction := ( hasTarget = 1 ∪ hasSource = 1 ∪hasInput = {0,1}) 
 

80 
In addition, if we append SWRL rules representing some dependencies between the 
properties, such as hasTarget (?x1, ?x2) ∩ hasSource (?x1, ?x3) Î isConnectedTo (?x2, 
?x3) and hasTarget (?x1, ?x2) ∩ hasSource (?x1, ?x3) ∩ hasTarget (?x4, ?x3) ∩ 
hasSource (?x4, ?x2) Î isBidirectional(?x1, ?x4), we can extract additional inferences 
through the Jess Rule Engine. Ultimately we can obtain an inferred dynamic model 
structure as well as a geometry model structure for the light bulb example. However, the 
following open issue naturally arises: How can we connect the knowledge-based and 
rule-based modeling approach with the RUBE framework under the Protégé 
environment?  
A possible answer for the issue is that we need to develop our own Protégé API. At 
a glance, it might make sense and be reasonable. However, the approach will bring us 
another issue, that is, how can we visualize and simulate models after obtaining model 
structures from the knowledge base? It needs other APIs for visualization and simulation. 
We imagine the solution for the second issue will need more complicated mechanisms.  
To provide a reasonable solution for the issue, we need an in-depth study and 
discussion about the knowledge-based approach as well as more experience in the SWRL 
logic and reasoning engines. 
6.2.2 Model Type Extension 
Currently, we support only two main MXL model types FSM and FBM. We also 
plan on supporting the following types: EQN (difference and differential equations), QM 
(queuing models), PETRI (petri nets), MARKOV (markov models), and SD (system 
dynamics models). 
 

81 
6.2.3 Interface Construction 
Our current work with Blender is preliminary, and the Model and Ontology 
Explorers need to be fleshed out to make them more robust. 
6.2.4 Visual Programming Support  
Another member of our research group will develop a visual programming model 
capability, using a factory metaphor. This will serve as a comprehensive usability test for 
our research product.  
 
 

APPENDIX A 
BLENDER INTERFACE SOURCE 
A.1 Graphical User Interface 
# ================= 
# GUI 
# ================= 
def gui():  
    global temp_toggle1,temp_toggle2,MXL_List, MXL_Menu 
    global type 
    global exporttype 
    global operation  
    global gFilename 
    global gAlert 
    global ExportOptions 
    global ExportType 
  
    glClearColor(0.3,0.4,0.2,0.0)                                                      
    glClear(GL_COLOR_BUFFER_BIT) 
    glColor3f(1.0,1.0,1.0) 
    Button("Exit", 5000, 10, 10, 80, 20)  
    Button("Model Explorer", 5001, 100, 10, 110, 20) 
    Button("Ontology Explorer", 5002, 220, 10, 120, 20)     
    Button("Object Exporter", 5003, 350, 10, 110, 20) 
    Button("Simulation", 5004, 470, 10, 100, 20) 
     
    if  EXPORTER: 
        if (gAlert==0): 
           gFilename=String ("Filename: 
",EVENT_PATHCHANGE,32,250,320,32,gFilename.val,255,"Full pathname and filename") 
           Button ("Export",EVENT_EXPORT,32,200,100,32) 
           glRasterPos2d(32, 165) 
           Button ("Done",EVENT_QUIT,142,50,100,32) 
 
        elif (gAlert==1): 
           glRasterPos2i (32,250) 
           Text (gFilename.val+ " already exists. Save anyway?") 
           Button ("Save",EVENT_EXPORT_CHK,150,200,50,32) 
           Button ("Cancel",EVENT_EXPORT_CANCEL,250,200,50,32) 
           gAlert = 0 
        elif (gAlert==2): 
           glRasterPos2i (32,250) 
           Text (gFilename.val+ " cannot be found. Check directory and filename.") 
           Button ("Continue",EVENT_IMPORT_CONT,32,190,70,32)  
82 

83 
           gAlert = 0 
        elif gAlert == 3: 
           glRasterPos2i (32,250) 
           Text ("No objects selected to export. You must select one or more objects.") 
           Button ("Continue",EVENT_EXPORT_ERR,192,200,70,32) 
           gAlert = 0 
        elif gAlert == 5: 
           glRasterPos2i (32,250) 
           Text ("Invalid directory path.") 
           Button ("Continue",EVENT_EXPORT_ERR,192,200,70,32) 
           gAlert = 0 
        else: 
           glRasterPos2i (32,250) 
           Text (str(operation)+ " of " +str(gFilename.val)+ " done.") 
           Button ("Continue",EVENT_DONE,192,200,70,32) 
     
    if  MODEL_EXPLORER: 
        event_no = 1 
        x_position = 30 
        y_position = 600 
        pre_pos = 0                             
        for folder in list_a: 
            pos=len(re.findall(r'\\', folder[0])) 
            pos = pos - 1 
            y_position = y_position - 20 
            if  pos != 0: 
                if  pos > pre_pos: 
                    x_position = x_position + (10*(pos - pre_pos))     
                elif pos < pre_pos: 
                    x_position = x_position - (10*(pre_pos - pos))     
                else: 
                    pass     
            if  folder[2] == 'close':  
                Button ('+', event_no, x_position, y_position, 10, 10, 'Click it to show subfolders')  
            elif folder[2] == 'open':  
                Button ('*', event_no, x_position, y_position, 10, 10, 'Click it to hide subfolders')                
            else: #an import case 
                s_len=(len(folder[2]) + 2) * 10 
                temp_evt = event_no + 500 
                Button (folder[2], temp_evt, x_position, y_position, s_len, 15, 'Import the object') 
            glRasterPos2i (x_position + 15,y_position)   
            idx = string.rfind(folder[0], os.sep) 
            text= folder[0][idx+1:]                                                      
            Text (text)       
 
            event_no = event_no + 1 
            pre_pos = pos 
             
    if  ONTOLOGY_EXPLORER: 
        pup_evnet_no=0 
        pup_event=[] 
 

84 
        event_no = 1001 
        x_position = 30 
        y_position = 600 
        pre_pos = 0 
        for folder in onto_a: 
            pos=len(re.findall(r'\\', folder[0])) 
            pos = pos - 1 
            y_position = y_position - 20 
            if  pos != 0: 
                if  pos > pre_pos: 
                    x_position = x_position + (10*(pos - pre_pos))     
                elif pos < pre_pos: 
                    x_position = x_position - (10*(pre_pos - pos))     
                else: 
                    pass     
            if  folder[2] == 'close':  
                Button ('+', event_no, x_position, y_position, 10, 10, 'Click it to show subfolders') 
            elif folder[2] == 'open':  
                Button ('*', event_no, x_position, y_position, 10, 10, 'Click it to hide subfolders')                
            else: #an import case 
                s_len=(len(folder[2])) * 8 
                x1=len(folder[3]) 
                x_temp = x_position + 120 
                temp_evt = event_no + 500 
                Button (folder[2], temp_evt, x_temp, y_position, s_len, 15, 'Import the object') 
                 
            if  folder[2] == 'open' or folder[2] == 'close':                           
                glColor3f(1.0,1.0,1.0) 
            else:     
                glColor3f(0.5,1.0,1.0) 
            glRasterPos2i (x_position + 15,y_position)   
            idx = string.rfind(folder[0], os.sep) 
            text= folder[0][idx+1:] 
            k=0 
            for each in instance_list.keys(): 
                re_str = text+"#" 
                str_find = string.find(each, re_str) 
                if  str_find != -1: 
                    k=k+1                                                      
            if  k == 0:         
                Text (text)       
            else: 
                text = text + ' ('+str(k)+')' 
                Text (text)           
            scene_find = string.find(folder[0], 'Scene') 
            end_x = 0 
            try: 
                if  folder[3] != '': 
                    end_x = 1 
            except: 
                pass   
 

85 
             
            t_len = GetStringWidth(text) 
            if  end_x == 0:           
                pup_event_no = event_no + 1000 # evt > 2000 
                t_position = x_position + t_len + 50 
                glColor3f(1.0,1.0,1.0)                                                   
     
        glRectf(t_position - 2,y_position - 2, t_position + 12.5,y_position + 12) 
                Button ('!', pup_event_no, t_position, y_position, 10, 10, 'Creating...') 
                if  MXL_inst_activate == 1 and folder[0] == toggle_target: 
MXL_Menu = Menu(MXL_List,  10002, t_position + 20, y_position, 80, 20, 
MXL_Menu.val) 
                    Button ('S', 10003, t_position+120, y_position, 20, 15, 'Selecting...') 
                    Button ('D', 10004, t_position+160, y_position, 20, 15, 'Deleting...') 
                    Button ('E', 10005, t_position+200, y_position, 20, 15, 'Done...') 
                if  toggle_activate == 1 and folder[0] == toggle_target: 
                    temp_toggle1 = Toggle('Select a dynamic object', 10000, t_position + 20, y_position,  
                    150, 20, 0) 
                if  toggle_activate == 2 and folder[0] == toggle_target: 
                    temp_toggle1 = Toggle('Select a dynamic object', 10000, t_position + 20, y_position,  
                    150, 20, 0) 
                    temp_toggle2 = Toggle('Select a geometry object', 10001, t_position + 190,  
                    y_position, 150, 20, 0) 
                pup_event.append([pup_event_no, folder[0]])           
             
            event_no = event_no + 1 
            pre_pos = pos 
 
A.2 MXL Creation 
#======================================================== 
def Multimodel_Check(): 
#======================================================== 
    for obj in Model_Object_List: 
        Linked_List[obj]=[]  
        for t_obj in Model_Object_List: 
            if  obj == t_obj: 
                pass 
            else: 
                return_value=BoundBox_Compare(obj, t_obj) 
                if  return_value == "Yes": 
                    Linked_List[obj].append([t_obj, '']) 
                    print "Linked_List:", Linked_List,Linked_List[obj][0][0],Linked_List[obj][0][1] 
 
    Arrange_Ordering() 
    arranged_model_layers_list=Arrange_Model_Layers() 
     
    file1 = open ('c:\\rube\\rube_utility\\MXL_files\\rubeMXL.xml', "w") 
    file1.write('<?xml version="1.0" encoding="utf-8"?>\n') 
    file1.write('<MXL>\n')  
    type=arranged_model_layers_list["1"][0][0:2] 
    if  type == "FB": 
 

86 
        file1.write('<fbm id ="fbm">\n')  
    elif type == "FS": 
        file1.write('<fsm id ="fsm">\n')  
    else: 
        file1.write('<gp id ="gp">\n') 
          
    for layer in arranged_model_layers_list: 
        if  layer == "1": 
            i=len(arranged_model_layers_list[layer]) 
            k=0 
            while (i): 
                Construct_MXL(arranged_model_layers_list[layer][k], file1, 
"",arranged_model_layers_list ) 
                #print "End MXL tag for ", arranged_model_layers_list[layer][k] 
                k=k+1 
                i=i-1 
            Connection_Info(arranged_model_layers_list["1"],file1,1) 
 
    if  type == "FB": 
        file1.write('</fbm>\n')  
    elif type == "FS": 
        file1.write('</fsm>\n')  
    else: 
        file1.write('</gp>\n') 
 
    file1.write('<simulation start_time = "0" end_time = "100" delta_time = "0.1" cycle_time = 
"0.1"/>\n')          
    file1.write('</MXL>')  
    file1.close()          
     
    ### mxl -> dxl 
    file_found = 0 
    os.chdir('c:\\rube\\rube_utility\\MXL_files') 
    sys_env_2=os.environ['Path'] 
    dir_list_2=string.split(sys_env_2, pathsep)                         
    for t_dir_2 in dir_list_2: 
        if t_dir_2 == ".": pass 
        else: 
            try: 
                if  exists(join(t_dir_2, "javac.exe")): 
                    find_1 = os.path.abspath(join(t_dir_2, "java.exe")) 
                    find_2 = os.path.abspath(join(t_dir_2, "javac.exe")) 
                    file_found = 1 
                    break 
            except: pass                
     
    if  file_found == 1:     
        return_value=os.spawnv(0, find_1, ('java.exe', 'org.apache.xalan.xslt.Process', '-in', 
'rubeMXL.xml', '-xsl', 'MXL2DXL2DP.xsl')) 
         
    if  return_value != 0:  
 

87 
        print "ERROR!!" 
    else: 
        return_value=os.spawnv(0, find_2, ('javac.exe', 'DXLP.java')) 
        if  return_value != 0: 
            print "ERROR_5!!" 
        else:     
            return_value=os.spawnv(0, find_1, ('java.exe', 'DXL', 'rubeDXL.dxl'))      
            if  return_value != 0:  
                print "ERROR_6!!" 
            else: 
                print "Done" 
#======================================================== 
def Connection_Info(x_list,file1, layer): #for the 1st layer 
#========================================================   
 
    for obj1 in x_list: 
        for obj2 in FBM_Connectivity_List: 
            idx=string.find(FBM_Connectivity_List[obj2][0][0], obj1) 
            if  idx != -1: 
                file1.write('<trace from = "%s" to = "%s"/>\n' 
%(FBM_Connectivity_List[obj2][0][0],FBM_Connectivity_List[obj2][1][0]))          
        for obj2 in FSM_Connectivity_List: 
            idx=string.find(FSM_Connectivity_List[obj2][0][0], obj1) 
            if  idx != -1: 
                if  layer == 1: 
                    file1.write('<transition from = "%s" to = "%s">\n' 
%(FSM_Connectivity_List[obj2][0][0],FSM_Connectivity_List[obj2][1][0]))                 
                    file1.write('    <script lang = "Python" src = "%s" func = "%s"/>\n' %(obj2+'.py', 
obj2))                                 
                    file1.write('</transition>\n')  
                    make_transition_function(obj2)                              
                else: 
                    file1.write('<transition from = "%s" to = "%s">\n' 
%(replace_id[FSM_Connectivity_List[obj2][0][0]][0],replace_id[FSM_Connectivity_List[obj2][
1][0]][0]))                 
                    file1.write('    <script lang = "Python" src = "%s" func = "%s"/>\n' %(obj2+'.py', 
obj2))                                 
                    file1.write('</transition>\n')  
                    make_transition_function(obj2)                              
                 
#=================================     
def make_transition_function(obj):     
#================================= 
    t_f = 'c:\\rube\\rube_utility\\MXL_files\\'+obj+'.py' 
    trans_file = open (t_f, "w") 
    trans_file.write('def %s(input, output):\n' %(obj)) 
    trans_file.write('    if  input[0] == %s:\n' %(FSM_Connector[obj][0]))  
    trans_file.write('        output[0] = 1\n') 
    trans_file.write('    else:\n') 
    trans_file.write('        output[0] = 0\n')  
     
 

88 
     
#======================================================== 
def Construct_MXL(x, file1, file_new,arranged_model_layers_list): 
#========================================================   
    global sub_file_name 
       
    inside_obj = "No" 
     
    for obj in Linked_List: 
        if  obj == x: 
            i=len(Linked_List[obj]) 
            k=0 
            if  i > 0:  
                tp=Linked_List[obj][0][0][0:2] 
                Write_MXL(x,file1,2,tp) 
                new_file1 = 'c:\\rube\\rube_utility\\MXL_files\\'+ new_file 
                file2 = open (new_file1, "w") 
                sub_file_name = file2 
                file2.write('<?xml version="1.0" encoding="utf-8"?>\n') 
                file2.write('<MXL>\n') 
                j=len(new_line) 
                l=0 
                while (j): 
                    file2.write(new_line[l]) 
                    file2.write("\n")  
                    j=j-1 
                    l=l+1 
                if  tp == "FB": 
                    n_s="fbm_" + str(MXL_File_Num) 
                    file2.write('<fbm id ="%s">\n' %(n_s))  
                elif tp == "FS": 
                    n_s="fsm_" + str(MXL_File_Num) 
                    file2.write('<fsm id ="%s">\n' %(n_s))  
                else: 
                    n_s="gp_" + str(MXL_File_Num) 
                    file2.write('<gp id ="%s">\n' %(n_s)) 
                     
                while (i): 
                    inside_obj="Yes" 
                    Construct_MXL(Linked_List[obj][k][0], file1, "Yes",arranged_model_layers_list) 
                    i=i-1 
                    k=k+1 
             
            if  k > 0: 
                Connection_Info(arranged_model_layers_list["2"],file2, 2) 
                if  tp == "FB": 
                    file2.write('</fbm>\n')  
                elif tp == "FS": 
                    file2.write('</fsm>\n')  
                else: 
                    file2.write('</gp>\n') 
 

89 
 
                file2.write('</MXL>')  
                file2.close()          
                  
    if  inside_obj == "No": 
        if  file_new == "Yes": 
            Write_MXL(x,sub_file_name,3,"") 
        else: 
            Write_MXL(x,file1,1,"") 
         
#======================================================== 
def Write_MXL(x,file1,opt,type): 
#========================================================             
   global MXL_File_Num, new_line, new_file 
    
   new_line = [] 
   new_file = "" 
   i=len(Obj_Directory) 
   k=0 
   while (i): 
       if  Obj_Directory[k][1] == x: 
           os.chdir(Obj_Directory[k][0])                                                                        
           dir_list=os.listdir(os.getcwd())  
           for file_name in dir_list: 
               MXL_file = string.find(file_name, '.mxl') 
               MXL_bak_file = string.find(file_name, '.mxl.') 
               if  MXL_file != -1 and MXL_bak_file == -1: #find the mxl file 
                   src_file = open (Obj_Directory[k][0]+'\\'+ file_name, "r") 
                   contents = src_file.readlines()  
                   for line in contents: 
                        
                       idx1=string.find(line, "input ") 
                       idx2=string.find(line, "output ") 
                       idx0=string.find(line, "script ") 
                       if  idx1 == -1 and idx2 == -1:     
                           print line 
                           if  opt == 2 and idx0 != -1: 
                               if  type == "FB": 
                                   MXL_File_Num = MXL_File_Num + 1  
                                   t1 = "fbm_" + str(MXL_File_Num) 
                                   t2 = "fbm_" + str(MXL_File_Num) + ".mxl" 
                                   file1.write('    <fbm id="%s" src = "%s"/>\n' %(t1, t2)) 
                                   new_file = t2 
                               elif type == "FS": 
                                   MXL_File_Num = MXL_File_Num + 1 
                                   t1 = "fsm_" + str(MXL_File_Num) 
                                   t2 = "fsm_" + str(MXL_File_Num) + ".mxl" 
                                   file1.write('    <fsm id="%s" src = "%s"/>\n' %(t1, t2)) 
                                   new_file = t2 
                               else: 
                                   MXL_File_Num = MXL_File_Num + 1 
 

90 
                                   t1 = "gp_" + str(MXL_File_Num) 
                                   t2 = "gp_" + str(MXL_File_Num) + ".mxl" 
                                   file1.write('    <gp id="%s" src = "%s"/>\n' %(t1, t2)) 
                                   new_file = t2 
                           elif opt == 3 and idx0 == -1: 
                               idx3=string.find(line, "id") 
                               if  idx3 != -1: 
                                   idx4=string.find(line[idx3:], "'") 
                                   idx5=string.find(line[idx3:], '"') 
 
 
 
 
   replace_id[Obj_Directory[k][1]]=[] 
                                   if  idx4 != -1: 
                                       idx6=string.find(line[idx3+idx4:], "'") 
                                       file1.write(line[0:idx3+idx4+1]) 
                                       file1.write('SUB'+str(k)+'_'+line[idx3+idx4+1:idx6]) 
                                       file1.write("\n") 
                                       idx8=string.find(line[idx3+idx5+1:], '"')  
replace_id[Obj_Directory[k][1]].append('SUB'+str(k)+'_'+line[idx3+idx4 
+1:idx3+idx4+idx8+1]) 
                                      
                                   if  idx5 != -1: 
                                       idx7=string.find(line[idx3+idx5:], "'") 
                                       file1.write(line[0:idx3+idx5+1]) 
                                       file1.write('SUB'+str(k)+'_'+line[idx3+idx5+1:idx7]) 
                                       file1.write("\n")  
                                       idx9=string.find(line[idx3+idx5+1:], '"') 
replace_id[Obj_Directory[k][1]].append('SUB'+str(k)+'_'+line[idx3+idx5 
+1:idx3+idx5+idx9+1]) 
                               else: 
                                   file1.write(line)                        
                           else: 
                               file1.write(line)                        
 
                       if  idx1 != -1: 
                           idx3=string.find(line, "id") 
                           if  idx3 != -1: 
                               idx4=string.find(line[idx3:], "'") 
                               idx5=string.find(line[idx3:], '"') 
                               if  idx4 != -1: 
                                   idx6=string.find(line[idx3+idx4:], "'") 
                                   file1.write(line[0:idx3+idx4+1]) 
                                   file1.write(x+'_'+line[idx3+idx4+1:idx6-1]) 
                                   file1.write("\n")  
                                   if  opt == 2: 
                                       need_more = x+'_SUB_'+line[idx3+idx4+1:idx6-1] 
                                       new_line.append(line[0:idx3+idx4+1] + need_more)  
                               if  idx5 != -1: 
                                   idx7=string.find(line[idx3+idx5:], '"')     
                                   file1.write(line[0:idx3+idx5+1]) 
                                   file1.write(x+'_'+line[idx3+idx5+1:idx7-1]) 
                                   file1.write("\n")  
                                   if  opt == 2: 
 

91 
                                       need_more = x+'_SUB_'+line[idx3+idx5+1:idx7-1] 
                                       new_line.append(line[0:idx3+idx5+1] + need_more)  
                                    
                       if  idx2 != -1: 
                           idx3=string.find(line, "id") 
                           if  idx3 != -1: 
                               idx4=string.find(line[idx3:], "'") 
                               idx5=string.find(line[idx3:], '"') 
                               if  idx4 != -1: 
                                   idx6=string.find(line[idx3+idx4:], "'") 
                                   file1.write(line[0:idx3+idx4+1]) 
                                   file1.write(x+'_'+line[idx3+idx4+1:idx6-1]) 
                                   file1.write("\n")  
                                   if  opt == 2: 
                                       need_more = x+'_SUB_'+line[idx3+idx4+1:idx6-1] 
                                       new_line.append(line[0:idx3+idx4+1] + need_more)  
                                    
                               if  idx5 != -1: 
                                   idx7=string.find(line[idx3+idx5:], '"')     
                                   file1.write(line[0:idx3+idx5+1]) 
                                   file1.write(x+'_'+line[idx3+idx5+1:idx7-1]) 
                                   file1.write("\n")  
                                   if  opt == 2: 
                                       need_more = x+'_SUB_'+line[idx3+idx5+1:idx7-1] 
                                       new_line.append(line[0:idx3+idx5+1] + need_more)  
 
                   file1.write('\n')      
                   src_file.close() 
       i=i-1 
       k=k+1 
 
A.3 OWL Management 
# ================================================= 
# Parsing an ontology to make a directory form 
# ================================================= 
def Ontology_Parsing(): 
     
    os.chdir('c:\\research\\test_sources\\owl_xslt_example') 
    xslt = open('parse.xslt').read()  
    xml = open('scene.owl').read()  
  
    processor = Processor.Processor()  
    transform = InputSource.DefaultFactory.fromString(xslt)  
    processor.appendStylesheet(transform)  
  
    source = InputSource.DefaultFactory.fromString(xml)  
    result = processor.run(source) 
    file = open('temp',"w") 
    file.write(result) 
 

92 
    file.close()  
    print result  
    FILE=open ('temp',"r") 
    lines = FILE.readlines() 
    lineNO=1 
    start_AllValue="No" 
    for line in lines: 
        if  lineNO == 1: 
            ontology_list = line.split() 
        if  start_AllValue == "Yes": 
            AllValue_List.append(line.split())     
        if  line.split() == ['*']: 
            start_AllValue = "Yes" 
        if  lineNO > 2 and line.split() != [] and line.split() != ['#'] and start_AllValue == "No": 
            inst_list.append(line.split()) 
         
        lineNO = lineNO + 1 
    
    for each in inst_list: 
        instance_list[each[0]+"#"+each[1]]=[] 
 
    for each in inst_list: 
        instance_list[each[0]+"#"+each[1]].append([each[2],each[3]]) 
 
    for item in ontology_list: 
        rename[item]=[] 
 
    for item in ontology_list: 
        idx = string.rfind(item, os.sep) 
        if  idx == -1: 
            txt = 'path:\\Ontology\\' + item 
            rename[item].append(txt) 
         
    for item in ontology_list: 
        cnt=len(re.findall(r'\\', item)) 
        if  cnt == 2: 
            name1, name2 = os.split(item) 
            i=len(name1) 
            try: 
                txt = rename[name1[0:i-2]][0] +'\\'+ name2 
                rename[item].append(txt) 
            except: 
                for each in rename.keys(): 
                    t1, t2 = os.split(each) 
                    if  t2 == name1[0:i-2]: 
                        txt = rename[each][0] +'\\'+ name2 
                        rename[item].append(txt)    
 
    for each in rename.keys(): 
        ontology.append([rename[each][0]]) 
    ontology.append(['path:\\Ontology']) 
 

93 
 
#======================================================== 
def Create_MXL_Instance(): 
#======================================================== 
    global ontology, rename, instance_list, inst_list, AllValue_List, MXL_Element 
  
    file1 = open ('scene.owl', "r") 
    contents = file1.readlines() 
    file2 = open ('temp_scene.owl', "w") 
    for line in contents: 
        idx=string.find(line, '</rdf:RDF>') 
        if  idx != -1: 
            file2.write('  <%s rdf:ID="%s">\n' %(MXL_Tag,instance_id ))  
            i=len(MXL_Element) 
            k=0 
            while (i): 
                file2.write('    <hasDynamic rdf:resource="#%s"/>\n' %(MXL_Element[k])) 
                k=k+1 
                i=i-1 
            file2.write('    <hasMXLLocation 
rdf:datatype="http://www.w3.org/2001/XMLSchema#string"\n') 
            file2.write('    >%s</hasMXLLocation>\n' %(MXL_Location))     
            file2.write('  </%s>\n' %(MXL_Tag)) 
            file2.write(line)  
        else: 
            file2.write(line)  
    file1.close() 
    file2.close() 
    os.remove('scene.owl') 
    shutil.copyfile('temp_scene.owl','scene.owl') 
    ontology=[] 
    rename={} 
    instance_list={} 
    inst_list=[] 
    AllValue_List=[] 
    MXL_Element=[] 
    Ontology_Parsing() 
         
#======================================================== 
def Create_Class(x,y): 
#======================================================== 
    global ontology, rename, instance_list, inst_list, AllValue_List 
    t_list=[[],[],[],[]] 
    found="No" 
    passed="No" 
    i=0 
    try: 
        if  len(x)> 0 and len(y) > 0: 
            for each in ontology: 
                idx = string.rfind(each[0], y) 
                if  idx != -1: 
 

94 
                    found = "Yes" 
                 
            if  found == "No": 
                Blender.Draw.PupMenu('Can not find the AllValueFrom in the ontology. Please create 
the corresponding SubClass first....%t') 
            else: 
                file1 = open ('scene.owl', "r") 
                contents = file1.readlines() 
                file2 = open ('temp_scene.owl', "w") 
                for line in contents: 
                    if  i == 0: 
                        t_list[0] = line 
                    elif i == 1: 
                        t_list[1] = line 
                    elif i == 2: 
                        t_list[2] = line 
                    elif i == 3: 
                        t_list[3] = line 
                    else: 
                        t_list[0] = t_list[1] 
                        t_list[1] = t_list[2] 
                        t_list[2] = t_list[3] 
                        t_list[3] = line 
 
                    i=i+1               
                    idx=string.find(line, '<owl:DatatypeProperty rdf:ID="hasMXLLocation">') 
                    if  idx != -1: 
                        file2.write('  <owl:Class rdf:ID="%s">\n' %(x))  
                        file2.write('    <rdfs:subClassOf>\n') 
                        file2.write('      <owl:Restriction>\n')  
                        file2.write('        <owl:onProperty rdf:resource="#hasDynamic"/>\n') 
                        file2.write('        <owl:allValuesFrom rdf:resource="#%s"/>\n' %(y)) 
                        file2.write('      </owl:Restriction>\n')   
                        file2.write('    </rdfs:subClassOf>\n') 
                        file2.write('  </owl:Class>\n\n') 
                        file2.write(line) 
                        passed="Yes" 
                    else: 
                        if  passed == "Yes": 
                            idx=string.find(line, '<owl:unionOf rdf:parseType="Collection">')   
                            if  idx != -1: 
                                idx1=string.find(t_list[0], '<owl:DatatypeProperty rdf:ID="hasDynamic">')   
                                idx2=string.find(t_list[0], '<owl:DatatypeProperty 
rdf:ID="hasMXLLocation">')   
                                if  idx1 != -1 or idx2 != -1: 
                                    file2.write(line) 
                                    file2.write('          <owl:Class rdf:about="#%s"/>\n' %(x)) 
                                else: 
                                    file2.write(line) 
                            else: 
                                file2.write(line) 
 

95 
                        else:     
                            file2.write(line)  
                             
                file1.close() 
                file2.close() 
                os.remove('scene.owl') 
                shutil.copyfile('temp_scene.owl','scene.owl') 
                ontology=[] 
                rename={} 
                instance_list={} 
                inst_list=[] 
                AllValue_List=[] 
                Ontology_Parsing() 
        else: 
            print "Create_Class ERROR_1!!!: ", x,y  
    except:        
        print "Create_Class ERROR_2!!!: ", x,y  
         
     
     
#======================================================== 
def Create_SubClass(x,y,z): 
#======================================================== 
    global ontology, rename, instance_list, inst_list, AllValue_List 
    t_list=[[],[],[],[],[]] 
    passed="No" 
 
    i=0 
    try: 
        if  len(x) > 0: 
            file1 = open ('scene.owl', "r") 
            contents = file1.readlines() 
            file2 = open ('temp_scene.owl', "w") 
            for line in contents: 
 
                if  i == 0: 
                    t_list[0] = line 
                elif i == 1: 
                    t_list[1] = line 
                elif i == 2: 
                    t_list[2] = line 
                elif i == 3: 
                    t_list[3] = line 
                elif i == 4: 
                    t_list[4] = line 
                else: 
                    t_list[0] = t_list[1] 
                    t_list[1] = t_list[2] 
                    t_list[2] = t_list[3] 
                    t_list[3] = t_list[4] 
                    t_list[4] = line 
 

96 
 
                i=i+1 
                if  y == 1: 
                    idx=string.find(line, '<owl:Class rdf:ID="Scene"/>') 
                else: 
                    temp = '<owl:Class rdf:ID="'+z+'">' 
                    idx1=string.find(t_list[0], temp)   
                    idx=string.find(line, '</owl:Class>') 
                     
                if  idx != -1: 
                    file2.write(line) 
                    if  y == 1: 
                        file2.write('  <owl:Class rdf:ID="%s">\n' %(x))  
                        file2.write('    <rdfs:subClassOf>\n') 
                        file2.write('      <owl:Class rdf:about="#Scene"/>\n') 
                        file2.write('    </rdfs:subClassOf>\n') 
                        file2.write('  </owl:Class>\n') 
                        passed = "Yes" 
                    if  y == 0 and idx1 != -1: 
                        file2.write('  <owl:Class rdf:ID="%s">\n' %(x))  
                        file2.write('    <rdfs:subClassOf>\n') 
                        file2.write('      <owl:Class rdf:about="#%s"/>\n' %(z)) 
                        file2.write('    </rdfs:subClassOf>\n') 
                        file2.write('  </owl:Class>\n')     
                else: 
                    if  passed == "Yes": 
                        idx=string.find(line, '<owl:unionOf rdf:parseType="Collection">')   
                        if  idx != -1: 
                            idx1=string.find(t_list[1], '<owl:DatatypeProperty rdf:ID="hasDynamic">')   
                            idx2=string.find(t_list[1], '<owl:DatatypeProperty rdf:ID="hasGeometry">')   
                            if  idx1 != -1 or idx2 != -1: 
                                file2.write(line) 
                                file2.write('          <owl:Class rdf:about="#%s"/>\n' %(x)) 
                            else: 
                                file2.write(line) 
                        else: 
                            file2.write(line) 
                    else:     
                        file2.write(line)  
 
                             
            file1.close() 
            file2.close() 
            os.remove('scene.owl') 
            shutil.copyfile('temp_scene.owl','scene.owl') 
            ontology=[] 
            rename={} 
            instance_list={} 
            inst_list=[] 
            AllValue_List=[] 
            Ontology_Parsing() 
 

97 
        else: 
            print "Create_SubClass ERROR_3!: ", x,y  
    except: 
        print "Create_SubClass ERROR_4!: ", x,y  
     
#======================================================== 
def Create_Instance(a,b,c,d): 
#======================================================== 
    global ontology, rename, instance_list, inst_list, AllValue_List 
    found="No" 
    print "X and Y:", a,b,c,d 
    for each in ontology: 
        idx = string.rfind(each[0], d) 
        if  idx != -1: 
            found = "Yes" 
                 
    if  found == "No": 
        Blender.Draw.PupMenu('Can not find the corresponding SubClass/Class in the 
ontology....%t') 
    else: 
        os.chdir('c:\\research\\test_sources\\owl_xslt_example') 
        file1 = open ('scene.owl', "r") 
        contents = file1.readlines() 
        file2 = open ('temp_scene.owl', "w") 
        for line in contents: 
            idx=string.find(line, '</rdf:RDF>') 
            if  idx != -1: 
                file2.write('  <%s rdf:ID="%s">\n' %(d,a))  
                file2.write('    <hasGeometry 
rdf:datatype="http://www.w3.org/2001/XMLSchema#string"\n') 
                file2.write('    >%s</hasGeometry>\n' %(c)) 
                file2.write('    <hasDynamic 
rdf:datatype="http://www.w3.org/2001/XMLSchema#string"\n') 
                file2.write('    >%s</hasDynamic>\n' %(b))         
                file2.write('  </%s>\n' %(d)) 
                file2.write(line)  
            else: 
                file2.write(line)  
        file1.close() 
        file2.close() 
        os.remove('scene.owl') 
        shutil.copyfile('temp_scene.owl','scene.owl') 
        ontology=[] 
        rename={} 
        instance_list={} 
        inst_list=[] 
        AllValue_List=[] 
        Ontology_Parsing() 
 
 

98 
A.4 Snap to Grid 
 #======================================================== 
def Check_FBM_Connectivity(item): 
#======================================================== 
    print '===== front=====' 
 
    Recalculate_Vertex_Position(Temp_FBM_Trace_Front_Vertex) 
    print '===== rear=====' 
    Recalculate_Vertex_Position(Temp_FBM_Trace_Rear_Vertex) 
    print '===== input=====' 
    Recalculate_Vertex_Position(Temp_FBM_Input_Vertex) 
    print '===== output=====' 
    Recalculate_Vertex_Position(Temp_FBM_Output_Vertex) 
    FBM_Connectivity_List[item] = [[],[]] 
     
    # calculate distance between trace_front_vertex and input_vertex 
    Calc_Distance(Temp_FBM_Trace_Rear_Vertex, Temp_FBM_Output_Vertex, 
FBM_Connectivity_List, 'from', item) 
    Calc_Distance(Temp_FBM_Trace_Front_Vertex, Temp_FBM_Input_Vertex, 
FBM_Connectivity_List, 'to', item) 
     
#======================================================== 
def Check_FSM_Connectivity(item): 
#======================================================== 
    print '===== front=====' 
    Recalculate_Vertex_Position(FSM_Transition_Front_Vertex) 
    print '===== rear=====' 
    Recalculate_Vertex_Position(FSM_Transition_Rear_Vertex) 
    print '===== FSM object=====' 
    Find_FSM_Object_Position() 
     
    FSM_Connectivity_List[item] = [[],[]] 
             
    # calculate distance between trace_front_vertex and input_vertex 
    Calc_Distance(FSM_Transition_Front_Vertex, FSM_Object_List, FSM_Connectivity_List, 
'from', item) 
     
    Calc_Distance(FSM_Transition_Rear_Vertex, FSM_Object_List, FSM_Connectivity_List, 'to', 
item) 
     
#======================================================== 
def Calc_Distance(list_a, list_b, list_c, where, item): 
#======================================================== 
    global min_value    
    global target_obj 
    global pre_obj, v_f_x, v_f_y, v_f_z, t_x2, t_y2, t_z2 
     
    min_value   = CONST_MIN_VALUE 
    target_obj  = "" 
    self_idx = string.find(item, 'self') 
 

99 
    model_type_idx = string.find(item, 'FBM') 
    if  self_idx != -1:  
        Non_self = False 
    else: 
        Non_self = True 
 
    Angle_List = {} 
    min_angle = 99999 
    min_angle_obj = ""         
    x1 = list_a[item][0][0] 
    y1 = list_a[item][0][1] 
    z1 = list_a[item][0][2] 
    if  where == 'to': 
        v_t1_x, v_t1_y, v_t1_z = (d_x, d_y, d_z) 
 
    for obj in list_b: 
        t_obj = '' 
        if  model_type_idx != -1:  
            idx = string.rfind(obj, '_') 
            t_obj= obj[0:idx]  
        print "sssss:", obj 
        x2 = list_b[obj][0][0] 
        y2 = list_b[obj][0][1] 
        z2 = list_b[obj][0][2] 
 
        if  where == 'to': 
            v_t2_x, v_t2_y, v_t2_z = (x2, y2, z2) 
            b_angle = Mathutils.AngleBetweenVecs(Vector([v_t1_x - v_f_x, v_t1_y - v_f_y, v_t1_z - 
v_f_z]), Vector([v_t2_x - v_f_x, v_t2_y - v_f_y, v_t2_z - v_f_z])) 
            Angle_List[obj] = b_angle 
            if  int(b_angle) < min_angle and Non_self == True: 
                if  (pre_obj != obj and model_type_idx == -1) or (pre_obj != t_obj and model_type_idx 
!= -1): 
                    min_angle = int(b_angle) 
                    min_angle_obj = obj 
        x = x2 - x1 
        y = y2 - y1 
        z = z2 - z1 
        xp = x * x 
        yp = y * y 
        zp = z * z 
        dist = math.sqrt (xp + yp + zp) 
        print "before:", dist, min_value, pre_obj, where 
        if  dist < min_value and where == 'from': 
            min_value = dist 
            target_obj = obj 
            t_x2, t_y2, t_z2 = (x2, y2, z2) 
             
        if  dist < min_value and where == 'to' and pre_obj != obj and Non_self == True and 
model_type_idx == -1: 
            min_value = dist 
 

100 
            target_obj = obj 
             
         if  dist < min_value and where == 'to' and pre_obj != t_obj and Non_self == True and   
model_type_idx != -1: #fbm 
            min_value = dist 
            target_obj = obj 
             
        if  dist < min_value and where == 'to' and Non_self == False: 
            min_value = dist 
            target_obj = obj 
    if  where == 'from': 
        list_c[item][0].append(target_obj) 
        if  model_type_idx != -1:  
            idx = string.rfind(target_obj, '_') 
            pre_obj= target_obj[0:idx]  
        else: 
            pre_obj = target_obj 
        v_f_x, v_f_y, v_f_z =(t_x2, t_y2, t_z2) 
        list_a[item][0][3] = 'Done' 
        t_x2, t_y2, t_z2 = (0,0,0) 
    else:  
        if  min_angle_obj == target_obj: 
            list_c[item][1].append(target_obj) 
            list_a[item][0][3] = 'Done' 
        else: 
            t_angle=Angle_List[target_obj] 
            diff_angle = abs(t_angle - min_angle) 
            if  diff_angle < 5: 
                list_c[item][1].append(target_obj) 
                list_a[item][0][3] = 'Done' 
            else: 
                list_c[item][1].append(min_angle_obj) 
                list_a[item][0][3] = 'Done' 
        pre_obj  = ""            
             
             
#======================================================== 
def Recalculate_Vertex_Position(temp_list): 
#======================================================== 
        
    for tobj in temp_list: 
            try: 
                t1_obj = Blender.Object.Get(tobj)    
            except: 
                t1_obj = Blender.Object.Get(temp_list[tobj][0][3]) 
            loc_t1 = t1_obj.getLocation() 
bx,by,bz = (float(temp_list[tobj][0][0]), float(temp_list[tobj][0][1]), 
float(temp_list[tobj][0][2])) 
            ax,ay,az = (t1_obj.RotX, t1_obj.RotY, t1_obj.RotZ) 
            cx,cy,cz = (t1_obj.SizeX,t1_obj.SizeY,t1_obj.SizeZ) 
        
 

101 
            # rot X  
            x1=bx 
            y1=by*math.cos(ax)-bz*math.sin(ax) 
            z1=by*math.sin(ax)+bz*math.cos(ax) 
 
            # rot Y 
            x2=x1*math.cos(ay)+z1*math.sin(ay) 
            y2=y1 
            z2=z1*math.cos(ay)-x1*math.sin(ay) 
 
            # rot Z 
            x3=x2*math.cos(az)-y2*math.sin(az) 
            y3=x2*math.sin(az)+y2*math.cos(az) 
            z3=z2 
         
            x = cx*x3 
            y = cy*y3 
            z = cz*z3                      
             
            x = loc_t1[0] + x 
            y = loc_t1[1] + y 
            z = loc_t1[2] + z 
         
            temp_list[tobj] = [] 
            temp_list[tobj].append([x, y, z, '']) 
 
#======================================================== 
def ImportFunction (importName, type, Current_Dir, input_value): 
#========================================================        
      global gFilename  
      global gAlert 
      global d_x, d_y, d_z 
       
      t_input_list = [] 
      t_output_list = [] 
      bridge_YES = 0 
      Connect_Type = "" 
       
      os.chdir(Current_Dir)                                                                        
      rube_dir_list=os.listdir(os.getcwd())  
      for file_name in rube_dir_list: 
          TXT_file = string.find(file_name, '.txt') 
          TXT_bak_file = string.find(file_name, '.txt.') 
          if  TXT_file != -1 and TXT_bak_file == -1: #find the txt file 
              file_path = Current_Dir + '\\'+ file_name 
              FILE=open (file_path,"r") 
              lines = FILE.readlines() 
              linenumber = 1 
              input_port_num = 0 
              output_port_num = 0 
               
 

102 
              for line in lines: 
                  words = line.split() 
                  input_port = string.find(words[0], 'input') 
                  output_port = string.find(words[0], 'output') 
                  trace_info = string.find(words[0], 'trace') 
                  tran_info = string.find(words[0], 'transition') 
                  if  input_port != -1: 
                      input_port_num = input_port_num + 1 
                      t_input_list.append([words[0],words[1],words[2],words[3]]) 
                  if  output_port != -1: 
                      output_port_num = output_port_num + 1 
                      t_output_list.append([words[0],words[1],words[2],words[3]]) 
                  if  trace_info != -1 or tran_info != -1: 
                      rear_info = string.find(words[1], 'rear') 
                      if  rear_info != -1: 
                          r_x = float(words[2]) 
                          r_y = float(words[3]) 
                          r_z = float(words[4]) 
                      else: 
                          f_x = float(words[2]) 
                          f_y = float(words[3]) 
                          f_z = float(words[4]) 
                       
              FILE.close() 
                
      try: 
         FILE=open (importName,"r") 
          
         directory, Name = os.split(importName) 
          
         words = Name.split(".") 
         Name = words[0] 
         AllObjList.append(Name) 
         x=len(AllObjList) 
 
 j = 0 
         while(x): 
             x = x - 1 
             if  AllObjList[x] == Name: 
                 j = j+1 
                  
         dir_list=string.split(Current_Dir, '\\') 
         if  dir_list[3] == 'FBM': 
             Name = 'FBM_'+ Name + str(j-1) 
             if  dir_list[4] == 'Trace': 
                 FBM_Trace_Front_Vertex[Name] = [] 
                 FBM_Trace_Rear_Vertex[Name] = [] 
                 FBM_Trace_Front_Vertex[Name].append([f_x, f_y, f_z, '']) 
                 FBM_Trace_Rear_Vertex[Name].append([r_x, r_y, r_z, '']) 
                 bridge_YES = 1 
             else: 
                 Model_Object_List.append(Name) 
 

103 
                  
                 x=0 
                 while(input_port_num): 
                       T_Name = Name + '_' + t_input_list[x][0] 
FBM_Input_Vertex[T_Name] = []  
FBM_Input_Vertex[T_Name].append([float(t_input_list[x][1]),float(t_input_list[x]
[2]),float(t_input_list[x][3]), Name])     
                     input_port_num = input_port_num - 1  
                     x = x+1 
                 x=0 
                 while(output_port_num): 
                     T_Name = Name + '_' + t_output_list[x][0] 
                     FBM_Output_Vertex[T_Name] = [] 
                     
FBM_Output_Vertex[T_Name].append([float(t_output_list[x][1]),float(t_output_list[
x][2]),float(t_output_list[x][3]), Name])     
                     output_port_num = output_port_num - 1      
                     x = x+1 
                      
         elif dir_list[3] == 'FSM': 
             Connect_Type = Name 
             Name = 'FSM_'+ Name + str(j-1) 
             if  dir_list[4] == 'Transition': 
                 Name = Name + '_Trans' 
                 FSM_Transition_Front_Vertex[Name] = [] 
                 FSM_Transition_Rear_Vertex[Name] = [] 
                 FSM_Transition_Front_Vertex[Name].append([f_x, f_y, f_z, '']) 
                 FSM_Transition_Rear_Vertex[Name].append([r_x, r_y, r_z, '']) 
                 FSM_Connector[Name]=[] 
                 FSM_Connector[Name].append(input_value) 
                 bridge_YES = 2 
             else: 
                 Model_Object_List.append(Name) 
                      
         elif dir_list[3] == 'QM': 
             Name = 'QM_'+ Name + str(j-1)         
         else: 
             Name = 'Imported_'+ Name + str(j-1)   
          
         Obj_Directory.append([directory, Name]) 
                
         Selected_Obj = Blender.Object.GetSelected() 
         ObjImport(FILE, Name, importName)  
         FILE.close() 
         gAlert = 4 
         i=Blender.Window.GetCursorPos()  
          
         ob = Blender.Object.Get("Mesh") 
         d_x = 0 
         d_y = 0 
         d_z = 0 
 

104 
         ob.LocX = i[0] 
         ob.LocY = i[1] 
         ob.LocZ = i[2] 
         d_x, d_y, d_z = (i[0], i[1], i[2]) 
          
         obj_folders[Name]= importName   
          
          
         if  bridge_YES == 1: #FBM 
             Create_Temp_Lists() 
             Check_FBM_Connectivity(Name) 
             if  len(Selected_Obj) == 2: 
                 p=0 
                 for item in Selected_Obj: 
                     if  p == 0:  
                         to_obj = check_port(FBM_Input_Vertex, item.name) 
                         p = p + 1 
                     else:     
                         from_obj = check_port(FBM_Output_Vertex, item.name) 
                 FBM_Connectivity_List[Name] = [[],[]] 
                 FBM_Connectivity_List[Name][0].append(from_obj) 
                 FBM_Connectivity_List[Name][1].append(to_obj)  
                 from_x_val = Temp_FBM_Output_Vertex[from_obj][0][0] #x position 
                 from_y_val = Temp_FBM_Output_Vertex[from_obj][0][1] #y position 
                 from_z_val = Temp_FBM_Output_Vertex[from_obj][0][2] #z position 
                 to_x_val = Temp_FBM_Input_Vertex[to_obj][0][0] #x position 
                 to_y_val = Temp_FBM_Input_Vertex[to_obj][0][1] #y position 
                 to_z_val = Temp_FBM_Input_Vertex[to_obj][0][2] #z position                                  
             else: 
                 from_x_val = 
Temp_FBM_Output_Vertex[FBM_Connectivity_List[Name][0][0]][0][0] #x position 
 from_y_val = 
Temp_FBM_Output_Vertex[FBM_Connectivity_List[Name][0][0]][0][1] #y position 
                 from_z_val = 
Temp_FBM_Output_Vertex[FBM_Connectivity_List[Name][0][0]][0][2] #z position 
 to_x_val = Temp_FBM_Input_Vertex[FBM_Connectivity_List[Name][1][0]][0][0]  
                 to_y_val = Temp_FBM_Input_Vertex[FBM_Connectivity_List[Name][1][0]][0][1]                 
to_z_val = Temp_FBM_Input_Vertex[FBM_Connectivity_List[Name][1][0]][0][2]  
              
             #scaling matrix 
             t_x_val=Temp_FBM_Trace_Front_Vertex[Name][0][0] 
             t_y_val=Temp_FBM_Trace_Front_Vertex[Name][0][1] 
             t_z_val=Temp_FBM_Trace_Front_Vertex[Name][0][2] 
             f_x_val=Temp_FBM_Trace_Rear_Vertex[Name][0][0] 
             f_y_val=Temp_FBM_Trace_Rear_Vertex[Name][0][1] 
             f_z_val=Temp_FBM_Trace_Rear_Vertex[Name][0][2] 
     
             xx=math.sqrt((t_x_val - f_x_val)*(t_x_val - f_x_val)+(t_y_val - f_y_val)*(t_y_val - 
f_y_val)+(t_z_val - f_z_val)*(t_z_val - f_z_val)) 
             yy=math.sqrt((to_x_val - from_x_val)*(to_x_val - from_x_val)+(to_y_val - 
from_y_val)*(to_y_val - from_y_val)+(to_z_val - from_z_val)*(to_z_val - from_z_val)) 
 

105 
             zz=(yy-2)/xx 
             s_mat = Mathutils.Matrix([1,0,0,0],[0,1,0,0],[0,0,zz,0],[0,0,0,1])  
             r=Vector([(float(from_x_val) - float(to_x_val)),(float(from_y_val) - float(to_y_val)), 
(float(from_z_val) - float(to_z_val))]) 
             x=vnorm(r)    
             Gvec = makeRotMtx_fromVec(x) 
 
             Gvec[0].append(0) 
             Gvec[1].append(0) 
             Gvec[2].append(0) 
             r_mat = Mathutils.Matrix(Gvec[0],Gvec[1],Gvec[2],[0,0,0,1]) 
             sr_mat=mulmat(s_mat, r_mat, 4)  
t_mat = Mathutils.Matrix([1,0,0,0],[0,1,0,0],[0,0,1,0],[(to_x_val + 
from_x_val)/2,(to_y_val + from_y_val)/2,(to_z_val + from_z_val)/2,1])  
             z_matrix=mulmat(sr_mat, t_mat, 4) 
             matrix = Mathutils.Matrix(z_matrix[0],z_matrix[1],z_matrix[2],z_matrix[3])  
             print matrix 
             ob.setMatrix(matrix) 
         elif bridge_YES == 2: #FSM 
             Check_FSM_Connectivity(Name)  
             if  len(Selected_Obj) == 2: 
                 p=0 
                 for item in Selected_Obj: 
                     if  p == 0:  
                         to_obj = item.name 
                         p = p + 1 
                     else:     
                         from_obj = item.name 
                 FSM_Connectivity_List[Name] = [[],[]] 
                 FSM_Connectivity_List[Name][0].append(from_obj) 
                 FSM_Connectivity_List[Name][1].append(to_obj)  
                 from_x_val = FSM_Object_List[from_obj][0][0] #x position 
                 from_y_val = FSM_Object_List[from_obj][0][1] #y position 
                 from_z_val = FSM_Object_List[from_obj][0][2] #z position 
                 to_x_val = FSM_Object_List[to_obj][0][0] #x position 
                 to_y_val = FSM_Object_List[to_obj][0][1] #y position 
                 to_z_val = FSM_Object_List[to_obj][0][2] #z position                                  
             else: 
                 from_x_val = FSM_Object_List[FSM_Connectivity_List[Name][0][0]][0][0]                 
from_y_val = FSM_Object_List[FSM_Connectivity_List[Name][0][0]][0][1]                 
from_z_val = FSM_Object_List[FSM_Connectivity_List[Name][0][0]][0][2]  
                 to_x_val = FSM_Object_List[FSM_Connectivity_List[Name][1][0]][0][0] #x position 
                 to_y_val = FSM_Object_List[FSM_Connectivity_List[Name][1][0]][0][1] #y position 
                 to_z_val = FSM_Object_List[FSM_Connectivity_List[Name][1][0]][0][2] #z position 
                   
              
             #scaling matrix 
             t_x_val=FSM_Transition_Front_Vertex[Name][0][0] 
             t_y_val=FSM_Transition_Front_Vertex[Name][0][1] 
             t_z_val=FSM_Transition_Front_Vertex[Name][0][2] 
             f_x_val=FSM_Transition_Rear_Vertex[Name][0][0] 
 

106 
             f_y_val=FSM_Transition_Rear_Vertex[Name][0][1] 
             f_z_val=FSM_Transition_Rear_Vertex[Name][0][2] 
             xx=math.sqrt((t_x_val - f_x_val)*(t_x_val - f_x_val)+(t_y_val - f_y_val)*(t_y_val - 
f_y_val)+(t_z_val - f_z_val)*(t_z_val - f_z_val)) 
yy=math.sqrt((to_x_val - from_x_val)*(to_x_val - from_x_val)+(to_y_val - 
from_y_val)*(to_y_val - from_y_val)+(to_z_val - from_z_val)*(to_z_val - from_z_val)) 
             if  Connect_Type != "pipe": 
                 zz=(yy-5)/xx 
             else: 
                 zz=yy/xx 
             s_mat = Mathutils.Matrix([1,0,0,0],[0,1,0,0],[0,0,zz,0],[0,0,0,1])  
              
 r=Vector([(float(from_x_val) - float(to_x_val)),(float(from_y_val) - float(to_y_val)), 
(float(from_z_val) - float(to_z_val))]) 
             x=vnorm(r)    
             Gvec = makeRotMtx_fromVec(x) 
 
             Gvec[0].append(0) 
             Gvec[1].append(0) 
             Gvec[2].append(0) 
             r_mat = Mathutils.Matrix(Gvec[0],Gvec[1],Gvec[2],[0,0,0,1]) 
             sr_mat=mulmat(s_mat, r_mat, 4)  
t_mat = Mathutils.Matrix([1,0,0,0],[0,1,0,0],[0,0,1,0],[(to_x_val + 
from_x_val)/2,(to_y_val + from_y_val)/2,(to_z_val + from_z_val)/2,1])  
             z_matrix=mulmat(sr_mat, t_mat, 4) 
             matrix = Mathutils.Matrix(z_matrix[0],z_matrix[1],z_matrix[2],z_matrix[3])  
             ob.setMatrix(matrix) 
         Draw() 
 
      except IOError: 
         gAlert=2 
         Draw () 
 
 
 
 
 

APPENDIX B 
LIGHT BULB EXAMPLE SOURCES 
B.1 DXL 
<?xml version="1.0" encoding="UTF-8"?> 
<DXL> 
 
<block id="Generator" type="SYNC" > 
<port id="Generator.FBM_Generator0_output" type="OUTPUT"   
         target="Generic.FBM_Generic0_input" data_type="Integer"></port> 
    
<definition id="Generator.py" func="Generator" lang="Python"></definition> 
</block> 
 
 
<block id="Display" type="SYNC" > 
 
<port id="Display.FBM_Display0_input" type="INPUT"  
                          source="Generic.FBM_Generic0_output" data_type="String"></port> 
 
<definition id="Display.py" func="Display" lang="Python"></definition> 
</block> 
 
 
<block id="Generic" type="SYNC" > 
 
<port id="Generic.FBM_Generic0_input" type="INPUT"  
                      source="Generator.FBM_Generator0_output" target="fsm_1_INPUT.IP1"                  
                     data_type="Integer"></port> 
 
<port id="Generic.FBM_Generic0_output" type="OUTPUT"  
                      target="Display.FBM_Display0_input" data_type="String"></port> 
 
<DXL id="fsm_1"> 
 
 
<block id="fsm_1_INPUT" type="SYNC" internal="YES"> 
 
 
 
<port id="fsm_1_INPUT.IP1" type="INPUT"  
                                                source="Generic.FBM_Generic0_input"  
                                                data_type="Integer"></port> 
 
 
 
<port id="fsm_1_INPUT.IP2" type="INPUT"  
                                                source="fsm_1_OUT.OP4" data_type="String" initial =  
                                                "fsm_1_SUB5_S1"></port> 
 
 
 
<port id="fsm_1_INPUT.OP1" type="OUTPUT"  
                                                 target="fsm_1_SUB5_S1Tofsm_1_SUB5_S1.IP1"  
                                                 data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_INPUT.OP1" type="OUTPUT"  
                                                 target="fsm_1_SUB5_S1Tofsm_1_SUB6_S2.IP1"  
                                                 data_type="Boolean"></port> 
 
 
 
 
<port id="fsm_1_INPUT.OP2" type="OUTPUT"  
                                                 target="fsm_1_SUB6_S2Tofsm_1_SUB6_S2.IP1"  
                                                 data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_INPUT.OP2" type="OUTPUT"  
                                                 target="fsm_1_SUB6_S2Tofsm_1_SUB7_S3.IP1"  
107 

108 
                                                 data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_INPUT.OP3" type="OUTPUT"  
                                                 target="fsm_1_SUB7_S3Tofsm_1_SUB7_S3.IP1"  
                                                 data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_INPUT.OP3" type="OUTPUT"  
                                                 target="fsm_1_SUB7_S3Tofsm_1_SUB6_S2.IP1"  
                                                 data_type="Boolean"></port> 
 
 
</block> 
 
 
<block id="fsm_1_OUT" type="ASYNC" internal="YES"> 
 
 
 
<port id="fsm_1_OUT.IP1" type="INPUT"  
                                                 source="fsm_1_SUB5_S1Tofsm_1_SUB5_S1.OP1"  
                                                 data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_OUT.IP2" type="INPUT"  
                                                 source="fsm_1_SUB6_S2Tofsm_1_SUB6_S2.OP1"  
                                                 data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_OUT.IP3" type="INPUT"  
                                                 source="fsm_1_SUB7_S3Tofsm_1_SUB7_S3.OP1"  
                                                 data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_OUT.IP2" type="INPUT"  
                                                 source="fsm_1_SUB5_S1Tofsm_1_SUB6_S2.OP1"  
                                                 data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_OUT.IP3" type="INPUT"  
                                                 source="fsm_1_SUB6_S2Tofsm_1_SUB7_S3.OP1"  
                                                 data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_OUT.IP2" type="INPUT"  
                                                  source="fsm_1_SUB7_S3Tofsm_1_SUB6_S2.OP1"  
                                                  data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_OUT.OP1" type="OUTPUT"  
                                                 target="fsm_1_SUB5_S1.IP1" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_OUT.OP2" type="OUTPUT"       
                                                 target="fsm_1_SUB6_S2.IP1" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_OUT.OP3" type="OUTPUT"  
                                                 target="fsm_1_SUB7_S3.IP1" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_OUT.OP4" type="OUTPUT"  
                                                 target="fsm_1_INPUT.IP2" data_type="String"></port> 
 
 
</block> 
 
 
<block id="fsm_1_SUB5_S1" type="SYNC"> 
 
 
 
<port id="fsm_1_SUB5_S1.IP1" type="INPUT"  
                                                 source="fsm_1_OUT.OP1" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_SUB5_S1.OP1" type="OUTPUT"  
                                                 target="Generic.FBM_Generic0_output" data_type="String"  
                                                 ></port> 
 
 
 
<definition id="S1.py" func="S1" lang="Python"></definition> 
 
 
</block> 
 
 
<block id="fsm_1_SUB6_S2" type="SYNC"> 
 
 
 
<port id="fsm_1_SUB6_S2.IP1" type="INPUT" 
                                                 source="fsm_1_OUT.OP2" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_SUB6_S2.OP1" type="OUTPUT"  
                                                 target="Generic.FBM_Generic0_output" data_type="String"  
                                                 ></port> 
 
 
 
<definition id="S2.py" func="S2" lang="Python"></definition> 
 

109 
 
 
</block> 
 
 
<block id="fsm_1_SUB7_S3" type="SYNC"> 
 
 
 
<port id="fsm_1_SUB7_S3.IP1" type="INPUT" 
                                                 source="fsm_1_OUT.OP3" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_SUB7_S3.OP1" type="OUTPUT"  
                                                 target="Generic.FBM_Generic0_output" data_type="String"  
                                                 ></port> 
 
 
 
<definition id="S3.py" func="S3" lang="Python"></definition> 
 
 
</block> 
 
 
<block id="fsm_1_SUB5_S1Tofsm_1_SUB5_S1" type="SYNC" > 
 
 
 
<port id="fsm_1_SUB5_S1Tofsm_1_SUB5_S1.IP1" type="INPUT"  
                                                 source="fsm_1_INPUT.OP1" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_SUB5_S1Tofsm_1_SUB5_S1.OP1" type="OUTPUT"  
                                                 target="fsm_1_OUT.IP1" data_type="Boolean"></port> 
 
 
 
<definition id="FSM_T1_Tran.py" func="FSM_T1_Tran"  
                                                          lang="Python"></definition> 
 
 
</block> 
 
 
<block id="fsm_1_SUB6_S2Tofsm_1_SUB6_S2" type="SYNC" > 
        
 
 
<port id="fsm_1_SUB6_S2Tofsm_1_SUB6_S2.IP1" type="INPUT"  
                                                 source="fsm_1_INPUT.OP2" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_SUB6_S2Tofsm_1_SUB6_S2.OP1" type="OUTPUT"  
                                                 target="fsm_1_OUT.IP2" data_type="Boolean"></port> 
 
 
 
<definition id="FSM_T1_Tran.py" func="FSM_T1_Tran"  
                                                          lang="Python"></definition> 
 
 
</block> 
 
 
<block id="fsm_1_SUB7_S3Tofsm_1_SUB7_S3" type="SYNC" > 
 
 
 
<port id="fsm_1_SUB7_S3Tofsm_1_SUB7_S3.IP1" type="INPUT"  
                                                 source="fsm_1_INPUT.OP3" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_SUB7_S3Tofsm_1_SUB7_S3.OP1" type="OUTPUT"  
                                                 target="fsm_1_OUT.IP3" data_type="Boolean"></port> 
 
 
 
<definition id="FSM_T1_Tran.py" func="FSM_T1_Tran"  
                                                          lang="Python"></definition> 
 
 
</block> 
 
 
<block id="fsm_1_SUB5_S1Tofsm_1_SUB6_S2" type="SYNC" > 
 
 
 
<port id="fsm_1_SUB5_S1Tofsm_1_SUB6_S2.IP1" type="INPUT"  
                                                 source="fsm_1_INPUT.OP1" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_SUB5_S1Tofsm_1_SUB6_S2.OP1" type="OUTPUT"  
                                                 target="fsm_1_OUT.IP2" data_type="Boolean"></port> 
 
 
 
<definition id="FSM_T2_Tran.py" func="FSM_T2_Tran"  
                                                          lang="Python"></definition> 
 
 
</block> 
 
 
 
<block id="fsm_1_SUB6_S2Tofsm_1_SUB7_S3" type="SYNC" > 
 
 
 
<port id="fsm_1_SUB6_S2Tofsm_1_SUB7_S3.IP1" type="INPUT"  
                                                 source="fsm_1_INPUT.OP2" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_SUB6_S2Tofsm_1_SUB7_S3.OP1" type="OUTPUT"  
                                                 target="fsm_1_OUT.IP3" data_type="Boolean"></port> 
 
 
 
<definition id="FSM_T3_Tran.py" func="FSM_T3_Tran"  
                                                          lang="Python"></definition> 
 
 
</block> 
 
 
<block id="fsm_1_SUB7_S3Tofsm_1_SUB6_S2" type="SYNC" > 
 
 
 
<port id="fsm_1_SUB7_S3Tofsm_1_SUB6_S2.IP1" type="INPUT"  
 

110 
                                                 source="fsm_1_INPUT.OP3" data_type="Boolean"></port> 
 
 
 
<port id="fsm_1_SUB7_S3Tofsm_1_SUB6_S2.OP1" type="OUTPUT"  
                                                 target="fsm_1_OUT.IP2" data_type="Boolean"></port> 
 
 
 
<definition id="FSM_T4_Tran.py" func="FSM_T4_Tran"  
                                                         lang="Python"></definition> 
 
 
</block> 
 
</DXL> 
 
</block> 
 
 
<connect id="FBM_Generator0_outputToFBM_Generic0_input"> 
 
<port id="FBM_Generator0_outputToFBM_Generic0_input.OP1" type="INPUT"  
                      source="Generator.FBM_Generator0_output"></port> 
 
<port id="FBM_Generator0_outputToFBM_Generic0_input.IP1" type="OUTPUT"  
                       source="Generic.FBM_Generic0_input"></port> 
</connect> 
 
 
<connect id="FBM_Generic0_outputToFBM_Display0_input"> 
 
<port id="FBM_Generic0_outputToFBM_Display0_input.OP1" type="INPUT"  
                       source="Generic.FBM_Generic0_output"></port> 
 
<port id="FBM_Generic0_outputToFBM_Display0_input.IP1" type="OUTPUT"  
                       source="Display.FBM_Display0_input"></port> 
</connect> 
 
 
 
<simulation start_time="0" end_time="10" delta_time="1" cycle_time="0.1"/> 
 
</DXL> 
 
B.2 Simulation Code in Python 
import Sim 
import math 
import Gen 
import Blender 
import time 
import sys, struct, string 
import os 
from Blender import NMesh, Scene, Object, Draw, Image, Material, Texture, sys 
from Blender.BGL import * 
from Blender.Draw import * 
from Blender import Draw 
from Blender.Window import * 
from Blender.Image import * 
from Blender.Material import * 
from Blender.Texture import * 
from Blender.sys import * 
from types import * 
from os import path 
 
NUM_BLOCKS = 14 
 

111 
NUM_TYPES  = 6 
MAX_INPUTS = 5 
MAX_OUTPUTS = 5 
MAX_PARAMS = 5 
SINGLE = 1 
TAIL = 2 
GEN = 0 
TRUE = 1 
FALSE = 0 
status_check = 0 
last_time = delta_time = 0.0 
num_blocks = block_num = 0 
end_time = 0.0 
current_state = None 
current_in = 0 
cur_in = 0 
end = 0 
event_value = None 
layer = 0 
delay = [] 
in1 = [] 
out = [] 
param = [] 
block_type = [] 
input_num = [] 
output_num = [] 
value = [] 
block_token = [] 
in_var = [] 
port_check = [] 
 
def clrstatus(): 
 
global status_check 
 
status_check = 0 
 
# Global Object Variables 
Generic_object = None 
fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object = None 
fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object = None 
fsm_1_OUT_object = None 
fsm_1_SUB7_S3_object = None 
fsm_1_SUB6_S2_object = None 
fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object = None 
fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object = None 
fsm_1_SUB5_S1_object = None 
Display_object = None 
fsm_1_INPUT_object = None 
fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object = None 
Generator_object = None 
fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object = None 
 
 

112 
class Generic_class: 
 
global Generator_object 
 
global Display_object 
 
global Generic_object 
 
global fsm_1_INPUT_object 
 
global fsm_1_OUT_object 
 
global fsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object 
 
global status_check, last_time, delta_time, num_blocks, block_num 
 
global delay, in1, out, param, block_type, input_num, output_num 
 
global value, port_check, block_token, current_state, current_in 
 
global cur_in, end, in_var, event_value, layer, end_time, dt 
 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
self.front_method = self.Generic_front 
 
 
self.tail_method = self.Generic_tail 
 
 
def Generic_front(self): 
 
 
if(self.port_check_count==self.NUM_INPUT_PORTS): 
 
 
 
if(self.in_ports_check[0] == TRUE): 
 
 
 
 
fsm_1_INPUT_object.input[0] =self.input[0] 
 
 
 
 
fsm_1_INPUT_object.in_ports_check[0] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[3], delay[3], block_token) 
 
 
def Generic_tail(self): 
 
 
if(self.out_ports_check[0] == TRUE): 
 

113 
 
 
 
Display_object.input[0] =self.output[0] 
 
 
 
Display_object.in_ports_check[0] = TRUE 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
Sim.schedule(block_type[1], delay[1], block_token) 
 
 
 
out_Generic = self.output[0] 
 
 
 
clear_port(self); 
 
class fsm_1_SUB5_S1Tofsm_1_SUB5_S1_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.FSM_T1_Tran_Controller 
 
 
self.user_function = FSM_T1_Tran 
 
 
def FSM_T1_Tran_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
# =====>   Beginning of User Code   <===== 
 
def FSM_T1_Tran(input, output): 
    if  input[0] == 0: 
        output[0] = 1 
    else: 
     
output[0] = 0 
 
# =====>   Ending of User Code   <===== 
 
 

114 
class fsm_1_SUB7_S3Tofsm_1_SUB7_S3_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.FSM_T1_Tran_Controller 
 
 
self.user_function = FSM_T1_Tran 
 
 
def FSM_T1_Tran_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
class fsm_1_OUT_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 3 
 
 
self.NUM_OUTPUT_PORTS = 4 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 

115 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[1] = None 
 
 
self.in_ports_check[1] = FALSE 
 
 
self.input[2] = None 
 
 
self.in_ports_check[2] = FALSE 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[2] = None 
 
 
self.output[0] = None 
 
 
self.output[1] = None 
 
 
self.output[3] = None 
 
 
 
self.function_Controller = self.fsm_1_OUT_func_Controller 
 
 
self.user_function = fsm_1_OUT_func 
 
 
def fsm_1_OUT_func_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[2] != None): 
 
 
 
self.out_ports_check[2] = TRUE 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
 
 
if(self.output[1] != None): 
 
 
 
self.out_ports_check[1] = TRUE 
 
 
 
if(self.output[3] != None): 
 
 
 
self.out_ports_check[3] = TRUE 
 
# =====>   Beginning of User Code   <===== 
 
 
 
def fsm_1_OUT_func(input,output): 
 
 
 
 
 
if input[0] == 1: 
 
 
output[0] = 1 
 
 
output[3] ='fsm_1_SUB5_S1' 
 
 
 
 
 
if input[1] == 1: 
 
 
output[1] = 1 
 
 
output[3] ='fsm_1_SUB6_S2' 
 
 
 
 
 
if input[2] == 1: 
 
 
output[2] = 1 
 
 
output[3] ='fsm_1_SUB7_S3' 
 
 
 
 
# =====>   Ending of User Code   <===== 
 
 

116 
class fsm_1_SUB7_S3_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.S3_Controller 
 
 
self.user_function = S3 
 
 
def S3_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
# =====>   Beginning of User Code   <===== 
 
def S3(input,output): 
 
output[0] = 'S3' 
# =====>   Ending of User Code   <===== 
 
class fsm_1_SUB6_S2_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 

117 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.S2_Controller 
 
 
self.user_function = S2 
 
 
def S2_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
# =====>   Beginning of User Code   <===== 
 
def S2(input,output): 
 
output[0] = 'S2' 
# =====>   Ending of User Code   <===== 
 
class fsm_1_SUB7_S3Tofsm_1_SUB6_S2_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 

118 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.FSM_T4_Tran_Controller 
 
 
self.user_function = FSM_T4_Tran 
 
 
def FSM_T4_Tran_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
# =====>   Beginning of User Code   <===== 
 
def FSM_T4_Tran(input, output): 
    if  input[0] == 1: 
        output[0] = 1 
    else: 
        output[0] = 0 
 
# =====>   Ending of User Code   <===== 
 
class fsm_1_SUB5_S1Tofsm_1_SUB6_S2_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.FSM_T2_Tran_Controller 
 
 
self.user_function = FSM_T2_Tran 
 
 
def FSM_T2_Tran_Controller(self): 
 
 

119 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
# =====>   Beginning of User Code   <===== 
 
def FSM_T2_Tran(input, output): 
    if  input[0] == 1: 
        output[0] = 1 
    else: 
        output[0] = 0 
 
# =====>   Ending of User Code   <===== 
 
class fsm_1_SUB5_S1_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.S1_Controller 
 
 
self.user_function = S1 
 
 
def S1_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
# =====>   Beginning of User Code   <===== 
 
 

120 
def S1(input,output): 
 
output[0] = 'S1' 
# =====>   Ending of User Code   <===== 
 
class Display_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 0 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
 
self.function_Controller = self.Display_Controller 
 
 
self.user_function = Display 
 
 
def Display_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
# =====>   Beginning of User Code   <===== 
 
def Display(input, output): 
 
print input[0] 
 
sleep(1000) 
# =====>   Ending of User Code   <===== 
 
class fsm_1_INPUT_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 2 
 
 
self.NUM_OUTPUT_PORTS = 3 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 

121 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[1] = 'fsm_1_SUB5_S1' 
 
 
self.in_ports_check[1] = TRUE 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[0] = None 
 
 
self.output[1] = None 
 
 
self.output[2] = None 
 
 
 
self.function_Controller = self.fsm_1_INPUT_func_Controller 
 
 
self.user_function = fsm_1_INPUT_func 
 
 
def fsm_1_INPUT_func_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
 
 
if(self.output[1] != None): 
 
 
 
self.out_ports_check[1] = TRUE 
 
 
 
if(self.output[2] != None): 
 
 
 
self.out_ports_check[2] = TRUE 
 
# =====>   Beginning of User Code   <===== 
 
 
 
def fsm_1_INPUT_func(input,output): 
 
 
 
 
 
if input[1] == 'fsm_1_SUB5_S1': 
 
 
output[0] = input[0] 
 
 
 
 
 
 
if input[1] == 'fsm_1_SUB6_S2': 
 
 
output[1] = input[0] 
 
 
 
 
 
 
if input[1] == 'fsm_1_SUB7_S3': 
 
 
output[2] = input[0] 
 
 
 
 
 
# =====>   Ending of User Code   <===== 
 
class fsm_1_SUB6_S2Tofsm_1_SUB6_S2_class: 
 
def __init__(self): 
 

122 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.FSM_T1_Tran_Controller 
 
 
self.user_function = FSM_T1_Tran 
 
 
 
def FSM_T1_Tran_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
class Generator_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 0 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 

123 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.Generator_Controller 
 
 
self.user_function = Generator 
 
 
 
def Generator_Controller(self): 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
# =====>   Beginning of User Code   <===== 
 
import random 
 
def Generator(input,output): 
 
output[0] = random.randint( 0 , 1 ) 
 
 
# =====>   Ending of User Code   <===== 
 
class fsm_1_SUB6_S2Tofsm_1_SUB7_S3_class: 
 
def __init__(self): 
 
 
self.NUM_INPUT_PORTS = 1 
 
 
self.NUM_OUTPUT_PORTS = 1 
 
 
 
 
self.input = [] 
 
 
self.in_ports_check = [] 
 
 
self.output = [] 
 
 
self.out_ports_check = [] 
 
 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.input.append(None) 
 
 
for i in xrange(self.NUM_INPUT_PORTS): 
 
 
 
self.in_ports_check.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.output.append(None) 
 
 
for i in xrange(self.NUM_OUTPUT_PORTS): 
 
 
 
self.out_ports_check.append(None) 
 
 
self.port_check_count = 0 
 
 
 
self.input[0] = None 
 

124 
 
 
self.in_ports_check[0] = FALSE 
 
 
self.output[0] = None 
 
 
 
self.function_Controller = self.FSM_T3_Tran_Controller 
 
 
self.user_function = FSM_T3_Tran 
 
 
 
def FSM_T3_Tran_Controller(self): 
 
 
 
self.user_function(self.input, self.output) 
 
 
 
if(self.output[0] != None): 
 
 
 
self.out_ports_check[0] = TRUE 
 
 
# =====>   Beginning of User Code   <===== 
 
def FSM_T3_Tran(input, output): 
    if  input[0] == 1: 
        output[0] = 1 
    else: 
        output[0] = 0 
 
# =====>   Ending of User Code   <===== 
 
def init_blocks(): 
 
global Generator_object 
 
global Display_object 
 
global Generic_object 
 
global fsm_1_INPUT_object 
 
global fsm_1_OUT_object 
 
global fsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object 
 
global status_check, last_time, delta_time, num_blocks, block_num 
 
global delay, in1, out, param, block_type, input_num, output_num 
 
global value, port_check, block_token, current_state, current_in 
 
global cur_in, end, in_var, event_value, layer, end_time, dt 
 
 
for i in xrange(0, NUM_BLOCKS): 
 
 
delay.append(0.0) 
 
 
in1.append([]) 
 
 
out.append([]) 
 
 
param.append([]) 
 
 
block_type.append(None) 
 

125 
 
 
input_num.append(None) 
 
 
output_num.append(None) 
 
 
value.append(None) 
 
 
port_check.append(None) 
 
 
for k in xrange(NUM_BLOCKS): 
 
 
for i in xrange(MAX_INPUTS): 
 
 
 
in1[k].append(None) 
 
 
for i in xrange(MAX_OUTPUTS): 
 
 
 
out[k].append(None) 
 
 
for i in xrange(MAX_PARAMS): 
 
 
 
param[k].append(None) 
 
 
block_token = Sim.TOKEN() 
 
for i in xrange(100): 
 
 
in_var.append(None) 
 
 
Generic_object = Generic_class() 
 
fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object =  
              fsm_1_SUB5_S1Tofsm_1_SUB5_S1_class() 
 
fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object =  
             fsm_1_SUB7_S3Tofsm_1_SUB7_S3_class() 
 
fsm_1_OUT_object = fsm_1_OUT_class() 
 
fsm_1_SUB7_S3_object = fsm_1_SUB7_S3_class() 
 
fsm_1_SUB6_S2_object = fsm_1_SUB6_S2_class() 
 
fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object =  
             fsm_1_SUB7_S3Tofsm_1_SUB6_S2_class() 
 
fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object =  
             fsm_1_SUB5_S1Tofsm_1_SUB6_S2_class() 
 
fsm_1_SUB5_S1_object = fsm_1_SUB5_S1_class() 
 
Display_object = Display_class() 
 
fsm_1_INPUT_object = fsm_1_INPUT_class() 
 
fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object =  
             fsm_1_SUB6_S2Tofsm_1_SUB6_S2_class() 
 
Generator_object = Generator_class() 
 
fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object =  
             fsm_1_SUB6_S2Tofsm_1_SUB7_S3_class() 
 
def checking_port(tmp_obj): 
 
tmp_obj.port_check_count = 0 
 
for i in xrange(tmp_obj.NUM_INPUT_PORTS): 
 
 
if(tmp_obj.in_ports_check[i] == TRUE): 
 
 
 
tmp_obj.port_check_count+=1 
 
 
def clear_port(tmp_obj): 
 
for i in xrange(tmp_obj.NUM_INPUT_PORTS): 
 
 
tmp_obj.in_ports_check[i] = FALSE 
 
 
tmp_obj.input[i] = None 
 
 
tmp_obj.port_check_count = 0 
 

126 
 
 
for i in xrange(tmp_obj.NUM_OUTPUT_PORTS): 
 
 
tmp_obj.out_ports_check[i] = FALSE 
 
 
tmp_obj.output[i] = None 
 
def main(): 
 
global Generator_object 
 
global Display_object 
 
global Generic_object 
 
global fsm_1_INPUT_object 
 
global fsm_1_OUT_object 
 
global fsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object 
 
global status_check, last_time, delta_time, num_blocks, block_num 
 
global delay, in1, out, param, block_type, input_num, output_num 
 
global value, port_check, block_token, current_state, current_in 
 
global cur_in, end, in_var, event_value, layer, end_time, dt 
 
block_name = [] 
 
block_name.append("Generator") 
 
block_name.append("Display") 
 
block_name.append("Generic") 
 
block_name.append("fsm_1_INPUT") 
 
block_name.append("fsm_1_OUT") 
 
block_name.append("fsm_1_SUB5_S1") 
 
block_name.append("fsm_1_SUB6_S2") 
 
block_name.append("fsm_1_SUB7_S3") 
 
block_name.append("fsm_1_SUB5_S1Tofsm_1_SUB5_S1") 
 
block_name.append("fsm_1_SUB6_S2Tofsm_1_SUB6_S2") 
 
block_name.append("fsm_1_SUB7_S3Tofsm_1_SUB7_S3") 
 
block_name.append("fsm_1_SUB5_S1Tofsm_1_SUB6_S2") 
 
block_name.append("fsm_1_SUB6_S2Tofsm_1_SUB7_S3") 
 
block_name.append("fsm_1_SUB7_S3Tofsm_1_SUB6_S2") 
 
 
Sim.init(0.0, Sim.LINKED) 
 
init_blocks() 
 
read_network() 
 
clrstatus() 
 
 
for i in xrange(num_blocks): 
 
 
value[i] = 0.0 
 
 
if (param[i][0] == TRUE): 
 
 
 
block_token.attr[0] =  i 
 
 
 
Sim.schedule(block_type[i], 0.0, block_token) 
 
last_time = 0.0 
 

127 
 
while(Sim.time() < end_time and Sim.event_list.size > 0): 
 
 
event = 0 
 
 
event = Sim.next_event(block_token, 0.0, Sim.ASYNC) 
 
 
if (Sim.time() != last_time): 
 
 
 
last_time = Sim.time() 
 
 
update_block(event, block_token) 
 
def update_block(event, block_token): 
 
global Generator_object 
 
global Display_object 
 
global Generic_object 
 
global fsm_1_INPUT_object 
 
global fsm_1_OUT_object 
 
global fsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object 
 
global status_check, last_time, delta_time, num_blocks, block_num 
 
global delay, in1, out, param, block_type, input_num, output_num 
 
global value, port_check, current_state, current_in 
 
global cur_in, end, in_var, event_value, layer, end_time, dt 
 
 
block_num =  block_token.attr[0] 
 
 
if(event == 0): 
 
 
checking_port(Generator_object) 
 
 
if(Generator_object.port_check_count==Generator_object.NUM_INPUT_PORTS): 
 
 
 
Generator_object.function_Controller() 
 
 
 
if(Generator_object.out_ports_check[0] == TRUE): 
 
 
 
 
Generic_object.input[0] =Generator_object.output[0] 
 
 
 
 
Generic_object.in_ports_check[0] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[2], delay[2], block_token) 
 
 
 
 
out_Generator = Generator_object.output[0] 
 
 
 
clear_port(Generator_object) 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
Sim.schedule(block_type[0], dt, block_token) 
 
 
 
elif(event == 1): 
 
 
checking_port(Display_object) 
 
 
if(Display_object.port_check_count==Display_object.NUM_INPUT_PORTS): 
 
 
 
Display_object.function_Controller() 
 
 
 
clear_port(Display_object) 
 
 

128 
 
 
elif(event == 2): 
 
 
checking_port(Generic_object) 
 
 
if(block_token.attr[0]==SINGLE): 
 
 
 
Generic_object.front_method() 
 
 
if(block_token.attr[0]==TAIL): 
 
 
 
Generic_object.tail_method() 
 
elif(event == 3): 
 
 
checking_port(fsm_1_INPUT_object) 
 
 
if(fsm_1_INPUT_object.port_check_count==fsm_1_INPUT_object.NUM_INPUT_POR 
                 TS): 
 
 
 
fsm_1_INPUT_object.function_Controller() 
 
 
 
if(fsm_1_INPUT_object.out_ports_check[0] == TRUE): 
 
 
 
 
fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object.input[0]  
                                                     =fsm_1_INPUT_object.output[0] 
 
 
 
 
fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object.in_ports_check[0]  
                                                     = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[8], delay[8], block_token) 
 
 
 
 
fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object.input[0]  
                                                     =fsm_1_INPUT_object.output[0] 
 
 
 
 
fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object.in_ports_check[0]  
                                                     = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[11], delay[11], block_token) 
 
 
 
if(fsm_1_INPUT_object.out_ports_check[1] == TRUE): 
 
 
 
 
fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object.input[0]  
                                                     =fsm_1_INPUT_object.output[1] 
 
 
 
 
fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object.in_ports_check[0]  
                                                     = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[9], delay[9], block_token) 
 
 
 
 
fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object.input[0]  
                                                     =fsm_1_INPUT_object.output[1] 
 
 
 
 
fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object.in_ports_check[0]  
                                                     = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[12], delay[12], block_token) 
 
 
 
if(fsm_1_INPUT_object.out_ports_check[2] == TRUE): 
 
 
 
 
fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object.input[0]  
                                                     =fsm_1_INPUT_object.output[2] 
 
 
 
 
fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object.in_ports_check[0]  
                                                     = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[10], delay[10], block_token) 
 
 
 
 
fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object.input[0]  
                                                     =fsm_1_INPUT_object.output[2] 
 
 
 
 
fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object.in_ports_check[0]  
                                                     = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 

129 
 
 
 
 
Sim.schedule(block_type[13], delay[13], block_token) 
 
 
 
clear_port(fsm_1_INPUT_object) 
 
 
 
elif(event == 4): 
 
 
checking_port(fsm_1_OUT_object) 
 
 
if(fsm_1_OUT_object.port_check_count> 0): 
 
 
 
fsm_1_OUT_object.function_Controller() 
 
 
 
if(fsm_1_OUT_object.out_ports_check[2] == TRUE): 
 
 
 
 
fsm_1_SUB7_S3_object.input[0]  
                                                     =fsm_1_OUT_object.output[2] 
 
 
 
 
fsm_1_SUB7_S3_object.in_ports_check[0] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[7], delay[7], block_token) 
 
 
 
if(fsm_1_OUT_object.out_ports_check[0] == TRUE): 
 
 
 
 
fsm_1_SUB5_S1_object.input[0]  
                                                     =fsm_1_OUT_object.output[0] 
 
 
 
 
fsm_1_SUB5_S1_object.in_ports_check[0] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[5], delay[5], block_token) 
 
 
 
if(fsm_1_OUT_object.out_ports_check[1] == TRUE): 
 
 
 
 
fsm_1_SUB6_S2_object.input[0]  
                                                     =fsm_1_OUT_object.output[1] 
 
 
 
 
fsm_1_SUB6_S2_object.in_ports_check[0] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[6], delay[6], block_token) 
 
 
 
if(fsm_1_OUT_object.out_ports_check[3] == TRUE): 
 
 
 
 
fsm_1_INPUT_object.input[1] =fsm_1_OUT_object.output[3] 
 
 
 
 
fsm_1_INPUT_object.in_ports_check[1] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[3], delay[3], block_token) 
 
 
 
clear_port(fsm_1_OUT_object) 
 
 
 
elif(event == 5): 
 
 
checking_port(fsm_1_SUB5_S1_object) 
 
 
if(fsm_1_SUB5_S1_object.port_check_count==fsm_1_SUB5_S1_object.NUM_INPUT_ 
                 PORTS): 
 
 
 
fsm_1_SUB5_S1_object.function_Controller() 
 
 
 
if(fsm_1_SUB5_S1_object.out_ports_check[0] == TRUE): 
 
 
 
 
Generic_object.output[0] =fsm_1_SUB5_S1_object.output[0] 
 
 
 
 
Generic_object.out_ports_check[0] = TRUE 
 
 
 
 
block_token.attr[0] = TAIL 
 
 
 
 
Sim.schedule(block_type[2], delay[2], block_token) 
 
 
 
 
out_Generic_fsm_1_SUB5_S1 =  
                                                    fsm_1_SUB5_S1_object.output[0] 
 
 
 
clear_port(fsm_1_SUB5_S1_object) 
 
 
 
elif(event == 6): 
 

130 
 
 
checking_port(fsm_1_SUB6_S2_object) 
 
 
if(fsm_1_SUB6_S2_object.port_check_count==fsm_1_SUB6_S2_object.NUM_INPUT_ 
                 PORTS): 
 
 
 
fsm_1_SUB6_S2_object.function_Controller() 
 
 
 
if(fsm_1_SUB6_S2_object.out_ports_check[0] == TRUE): 
 
 
 
 
Generic_object.output[0] =fsm_1_SUB6_S2_object.output[0] 
 
 
 
 
Generic_object.out_ports_check[0] = TRUE 
 
 
 
 
block_token.attr[0] = TAIL 
 
 
 
 
Sim.schedule(block_type[2], delay[2], block_token) 
 
 
 
 
out_Generic_fsm_1_SUB6_S2 =  
                                                     fsm_1_SUB6_S2_object.output[0] 
 
 
 
clear_port(fsm_1_SUB6_S2_object) 
 
 
 
elif(event == 7): 
 
 
checking_port(fsm_1_SUB7_S3_object) 
 
 
if(fsm_1_SUB7_S3_object.port_check_count==fsm_1_SUB7_S3_object.NUM_INPUT_ 
                 PORTS): 
 
 
 
fsm_1_SUB7_S3_object.function_Controller() 
 
 
 
if(fsm_1_SUB7_S3_object.out_ports_check[0] == TRUE): 
 
 
 
 
Generic_object.output[0] =fsm_1_SUB7_S3_object.output[0] 
 
 
 
 
Generic_object.out_ports_check[0] = TRUE 
 
 
 
 
block_token.attr[0] = TAIL 
 
 
 
 
Sim.schedule(block_type[2], delay[2], block_token) 
 
 
 
 
out_Generic_fsm_1_SUB7_S3 =  
                                                     fsm_1_SUB7_S3_object.output[0] 
 
 
 
clear_port(fsm_1_SUB7_S3_object) 
 
 
 
elif(event == 8): 
 
 
checking_port(fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object) 
 
 
if(fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object.port_check_count==fsm_1_SUB5_S1Tof 
                 sm_1_SUB5_S1_object.NUM_INPUT_PORTS): 
 
 
 
fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object.function_Controller() 
 
 
 
if(fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object.out_ports_check[0] ==  
                                           TRUE): 
 
 
 
 
fsm_1_OUT_object.input[0]  
                                                     =fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object.output[0] 
 
 
 
 
fsm_1_OUT_object.in_ports_check[0] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[4], delay[4], block_token) 
 
 
 
 
out_Generic_fsm_1_SUB5_S1Tofsm_1_SUB5_S1 =  
                                                     fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object.output[0] 
 
 
 
clear_port(fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object) 
 
 
elif(event == 9): 
 
 
checking_port(fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object) 
 

131 
 
 
if(fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object.port_check_count==fsm_1_SUB6_S2Tof 
                 sm_1_SUB6_S2_object.NUM_INPUT_PORTS): 
 
 
 
fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object.function_Controller() 
 
 
 
if(fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object.out_ports_check[0] ==  
                                           TRUE): 
 
 
 
 
fsm_1_OUT_object.input[1]  
                                                     =fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object.output[0] 
 
 
 
 
fsm_1_OUT_object.in_ports_check[1] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[4], delay[4], block_token) 
 
 
 
 
out_Generic_fsm_1_SUB6_S2Tofsm_1_SUB6_S2 =  
                                                     fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object.output[0] 
 
 
 
clear_port(fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object) 
 
 
elif(event == 10): 
 
 
checking_port(fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object) 
 
 
if(fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object.port_check_count==fsm_1_SUB7_S3Tof 
                 sm_1_SUB7_S3_object.NUM_INPUT_PORTS): 
 
 
 
fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object.function_Controller() 
 
 
 
if(fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object.out_ports_check[0] == 
                                           TRUE): 
 
 
 
 
fsm_1_OUT_object.input[2]  
                                                     =fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object.output[0] 
 
 
 
 
fsm_1_OUT_object.in_ports_check[2] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[4], delay[4], block_token) 
 
 
 
 
out_Generic_fsm_1_SUB7_S3Tofsm_1_SUB7_S3 = 
                                                     fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object.output[0] 
 
 
 
clear_port(fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object) 
 
 
elif(event == 11): 
 
 
checking_port(fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object) 
 
 
if(fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object.port_check_count==fsm_1_SUB5_S1Tof 
                 sm_1_SUB6_S2_object.NUM_INPUT_PORTS): 
 
 
 
fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object.function_Controller() 
 
 
 
if(fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object.out_ports_check[0] ==  
                                           TRUE): 
 
 
 
 
fsm_1_OUT_object.input[1]  
                                                     =fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object.output[0] 
 
 
 
 
fsm_1_OUT_object.in_ports_check[1] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[4], delay[4], block_token) 
 
 
 
 
out_Generic_fsm_1_SUB5_S1Tofsm_1_SUB6_S2 =  
                                                     fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object.output[0] 
 
 
 
clear_port(fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object) 
 
 
elif(event == 12): 
 
 
checking_port(fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object) 
 

132 
 
 
if(fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object.port_check_count==fsm_1_SUB6_S2Tof 
                 sm_1_SUB7_S3_object.NUM_INPUT_PORTS): 
 
 
 
fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object.function_Controller() 
 
 
 
if(fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object.out_ports_check[0] ==  
                                           TRUE): 
 
 
 
 
fsm_1_OUT_object.input[2]  
                                                     =fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object.output[0] 
 
 
 
 
fsm_1_OUT_object.in_ports_check[2] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[4], delay[4], block_token) 
 
 
 
 
out_Generic_fsm_1_SUB6_S2Tofsm_1_SUB7_S3 = 
                                                     fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object.output[0] 
 
 
 
clear_port(fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object) 
 
 
elif(event == 13): 
 
 
checking_port(fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object) 
 
 
if(fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object.port_check_count==fsm_1_SUB7_S3Tof 
                 sm_1_SUB6_S2_object.NUM_INPUT_PORTS): 
 
 
 
fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object.function_Controller() 
 
 
 
if(fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object.out_ports_check[0] == 
                                           TRUE): 
 
 
 
 
fsm_1_OUT_object.input[1]  
                                                     =fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object.output[0] 
 
 
 
 
fsm_1_OUT_object.in_ports_check[1] = TRUE 
 
 
 
 
block_token.attr[0] = SINGLE 
 
 
 
 
Sim.schedule(block_type[4], delay[4], block_token) 
 
 
 
 
out_Generic_fsm_1_SUB7_S3Tofsm_1_SUB6_S2 =  
                                                     fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object.output[0] 
 
 
 
clear_port(fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object) 
 
def read_network(): 
 
global Generator_object 
 
global Display_object 
 
global Generic_object 
 
global fsm_1_INPUT_object 
 
global fsm_1_OUT_object 
 
global fsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB5_S1_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB5_S1Tofsm_1_SUB6_S2_object 
 
global fsm_1_SUB6_S2Tofsm_1_SUB7_S3_object 
 
global fsm_1_SUB7_S3Tofsm_1_SUB6_S2_object 
 
global status_check, last_time, delta_time, num_blocks, block_num 
 
global delay, in1, out, param, block_type, input_num, output_num 
 
global value, port_check, block_token, current_state, current_in 
 
global cur_in, end, in_var, event_value, layer, end_time, dt 
 

133 
 
 
num_blocks = 14 
 
end_time = 10.0 
 
dt = 1.0 
 
cycle_time = 0.1 
 
block_type[0] = 0 
 
block_type[1] = 1 
 
block_type[2] = 2 
 
block_type[3] = 3 
 
block_type[4] = 4 
 
block_type[5] = 5 
 
block_type[6] = 6 
 
block_type[7] = 7 
 
block_type[8] = 8 
 
block_type[9] = 9 
 
block_type[10] = 10 
 
block_type[11] = 11 
 
block_type[12] = 12 
 
block_type[13] = 13 
 
delay[0] = 0 
 
delay[1] = 0 
 
delay[2] = 0 
 
delay[3] = 0 
 
delay[4] = 0 
 
delay[5] = 0 
 
delay[6] = 0 
 
delay[7] = 0 
 
delay[8] = 0 
 
delay[9] = 0 
 
delay[10] = 0 
 
delay[11] = 0 
 
delay[12] = 0 
 
delay[13] = 0 
 
param[0][0] = TRUE 
 
param[1][0] = FALSE 
 
param[2][0] = FALSE 
 
param[3][0] = FALSE 
 
param[4][0] = FALSE 
 
param[5][0] = FALSE 
 
param[6][0] = FALSE 
 
param[7][0] = FALSE 
 
param[8][0] = FALSE 
 
param[9][0] = FALSE 
 
param[10][0] = FALSE 
 
param[11][0] = FALSE 
 
param[12][0] = FALSE 
 
param[13][0] = FALSE 
main()
 

APPENDIX C 
OWL AND XSLT SOURCES 
C.1 Example 1: Battle Scene 
<rdf:RDF 
    xmlns="http://a.com/ontology#" 
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" 
    xmlns:owl="http://www.w3.org/2002/07/owl#" 
  xml:base="http://a.com/ontology"> 
  <owl:Ontology rdf:about=""/> 
  <owl:Class rdf:ID="Geometry_for_UAV_Dynamic_Model"/> 
  <owl:Class rdf:ID="MXL_for_UAV_Dynamic_Model"/> 
  <owl:Class rdf:ID="Scene"/> 
  <owl:Class rdf:ID="JSTARS"> 
    <rdfs:subClassOf> 
      <owl:Class rdf:ID="Aircraft"/> 
    </rdfs:subClassOf> 
  </owl:Class> 
  <owl:Class rdf:ID="Mouse_based"> 
    <rdfs:subClassOf> 
      <owl:Class rdf:ID="Sensor"/> 
    </rdfs:subClassOf> 
  </owl:Class> 
  <owl:Class rdf:ID="InteractionModel"/> 
  <owl:Class rdf:ID="Effect"> 
    <rdfs:subClassOf> 
      <owl:Class rdf:ID="Process"/> 
    </rdfs:subClassOf> 
  </owl:Class> 
  <owl:Class rdf:ID="Control"> 
    <rdfs:subClassOf rdf:resource="#Process"/> 
  </owl:Class> 
  <owl:Class rdf:ID="Display"/> 
  <owl:Class rdf:ID="UAV"> 
    <rdfs:subClassOf rdf:resource="#Aircraft"/> 
  </owl:Class> 
  <owl:Class rdf:ID="Dynamic_Model"/> 
  <owl:Class rdf:ID="Keyboard_based"> 
    <rdfs:subClassOf rdf:resource="#Sensor"/> 
  </owl:Class> 
  <owl:Class rdf:ID="F15"> 
    <rdfs:subClassOf rdf:resource="#Aircraft"/> 
  </owl:Class> 
134 

135 
  <owl:Class rdf:ID="Geometry_Model"/> 
  <owl:ObjectProperty rdf:ID="hasRepresentationForDynamicModel"> 
    <rdfs:range rdf:resource="#Aircraft"/> 
    <rdfs:domain rdf:resource="#Geometry_for_UAV_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesDynamicProperty"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#UAV"/> 
          <owl:Class rdf:about="#JSTARS"/> 
          <owl:Class rdf:about="#F15"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#MXL_for_UAV_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasDynamicModel"> 
    <rdfs:range rdf:resource="#Geometry_for_UAV_Dynamic_Model"/> 
    <rdfs:domain rdf:resource="#Display"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasMXL"> 
    <rdfs:range rdf:resource="#MXL_for_UAV_Dynamic_Model"/> 
    <rdfs:domain rdf:resource="#Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isGeometryModel"> 
    <rdfs:range rdf:resource="#Aircraft"/> 
    <rdfs:domain rdf:resource="#Geometry_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasRepresentation"> 
    <rdfs:domain rdf:resource="#Dynamic_Model"/> 
    <rdfs:range rdf:resource="#Geometry_for_UAV_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesGeometryProperty"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#F15"/> 
          <owl:Class rdf:about="#JSTARS"/> 
          <owl:Class rdf:about="#UAV"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#Geometry_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesProcess"> 
    <rdfs:range rdf:resource="#Process"/> 
    <rdfs:domain rdf:resource="#InteractionModel"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isDynamicModel"> 
    <rdfs:range rdf:resource="#Aircraft"/> 
 

136 
    <rdfs:domain rdf:resource="#MXL_for_UAV_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="contains"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Aircraft"/> 
          <owl:Class rdf:about="#Sensor"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#Scene"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesSensors"> 
    <rdfs:domain rdf:resource="#InteractionModel"/> 
    <rdfs:range rdf:resource="#Sensor"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isInteractionModel"> 
    <rdfs:range rdf:resource="#Scene"/> 
    <rdfs:domain rdf:resource="#InteractionModel"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesGeometryOfDynamicModel"> 
    <rdfs:domain rdf:resource="#Geometry_for_UAV_Dynamic_Model"/> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#UAV"/> 
          <owl:Class rdf:about="#JSTARS"/> 
          <owl:Class rdf:about="#F15"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasGeometryModel"> 
    <rdfs:range rdf:resource="#Geometry_Model"/> 
    <rdfs:domain rdf:resource="#Display"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesDisplay"> 
    <rdfs:range rdf:resource="#Display"/> 
    <rdfs:domain rdf:resource="#InteractionModel"/> 
  </owl:ObjectProperty> 
  <owl:DatatypeProperty rdf:ID="hasDynamic"> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Sensor"/> 
          <owl:Class rdf:about="#Aircraft"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/> 
 

137 
  </owl:DatatypeProperty> 
  <owl:DatatypeProperty rdf:ID="hasGeometry"> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Sensor"/> 
          <owl:Class rdf:about="#Aircraft"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/> 
  </owl:DatatypeProperty> 
</rdf:RDF> 
 
C.2 Example 2: Light Bulb 
<rdf:RDF 
    xmlns="http://a.com/ontology#" 
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" 
    xmlns:owl="http://www.w3.org/2002/07/owl#" 
  xml:base="http://a.com/ontology"> 
  <owl:Ontology rdf:about=""/> 
  <owl:Class rdf:ID="Light_Switch"/> 
  <owl:Class rdf:ID="Scene"/> 
  <owl:Class rdf:ID="Geometry_for_Light_Bulb_Dynamic_Model"/> 
  <owl:Class rdf:ID="Light_Bulb"/> 
  <owl:Class rdf:ID="Light_Socket"/> 
  <owl:Class rdf:ID="MXL_for_Light_Bulb_Dynamic_Model"/> 
  <owl:Class rdf:ID="Mouse_based"> 
    <rdfs:subClassOf> 
      <owl:Class rdf:ID="Sensor"/> 
    </rdfs:subClassOf> 
  </owl:Class> 
  <owl:Class rdf:ID="InteractionModel"/> 
  <owl:Class rdf:ID="Effect"> 
    <rdfs:subClassOf> 
      <owl:Class rdf:ID="Process"/> 
    </rdfs:subClassOf> 
  </owl:Class> 
  <owl:Class rdf:ID="Control"> 
    <rdfs:subClassOf rdf:resource="#Process"/> 
  </owl:Class> 
  <owl:Class rdf:ID="Display"/> 
  <owl:Class rdf:ID="Dynamic_Model"/> 
  <owl:Class rdf:ID="Keyboard_based"> 
    <rdfs:subClassOf rdf:resource="#Sensor"/> 
  </owl:Class> 
  <owl:Class rdf:ID="Geometry_Model"/> 
  <owl:Class rdf:ID="Bulb"/> 
  <owl:ObjectProperty rdf:ID="hasRepresentationForDynamicModel"> 
 

138 
    <rdfs:range rdf:resource="#Light_Bulb"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesDynamicProperty"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#MXL_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasDynamicModel"> 
    <rdfs:domain rdf:resource="#Display"/> 
    <rdfs:range rdf:resource="#Geometry_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasMXL"> 
    <rdfs:range rdf:resource="#MXL_for_Light_Bulb_Dynamic_Model"/> 
    <rdfs:domain rdf:resource="#Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isGeometryModel"> 
    <rdfs:domain rdf:resource="#Geometry_Model"/> 
    <rdfs:range rdf:resource="#Light_Bulb"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasRepresentation"> 
    <rdfs:domain rdf:resource="#Dynamic_Model"/> 
    <rdfs:range rdf:resource="#Geometry_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesGeometryProperty"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#Geometry_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesProcess"> 
    <rdfs:range rdf:resource="#Process"/> 
    <rdfs:domain rdf:resource="#InteractionModel"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isDynamicModel"> 
    <rdfs:range rdf:resource="#Light_Bulb"/> 
    <rdfs:domain rdf:resource="#MXL_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesSensors"> 
 

139 
    <rdfs:domain rdf:resource="#InteractionModel"/> 
    <rdfs:range rdf:resource="#Sensor"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="contains"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Sensor"/> 
          <owl:Class rdf:about="#Light_Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#Scene"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isInteractionModel"> 
    <rdfs:range rdf:resource="#Scene"/> 
    <rdfs:domain rdf:resource="#InteractionModel"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isComposedOf"> 
    <rdfs:domain rdf:resource="#Light_Bulb"/> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesGeometryOfDynamicModel"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#Geometry_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasGeometryModel"> 
    <rdfs:range rdf:resource="#Geometry_Model"/> 
    <rdfs:domain rdf:resource="#Display"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesDisplay"> 
    <rdfs:range rdf:resource="#Display"/> 
    <rdfs:domain rdf:resource="#InteractionModel"/> 
  </owl:ObjectProperty> 
  <owl:DatatypeProperty rdf:ID="hasDynamic"> 
 

140 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Sensor"/> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
          <owl:Class rdf:about="#Light_Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/> 
  </owl:DatatypeProperty> 
  <owl:DatatypeProperty rdf:ID="hasGeometry"> 
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Sensor"/> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
          <owl:Class rdf:about="#Light_Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
  </owl:DatatypeProperty> 
</rdf:RDF> 
 
C.3 Combined OWL: FSM and Scene Ontologies 
<rdf:RDF 
    xmlns="http://a.com/ontology#" 
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" 
    xmlns:owl="http://www.w3.org/2002/07/owl#" 
  xml:base="http://a.com/ontology"> 
  <owl:Ontology rdf:about=""/> 
  <owl:Class rdf:ID="InputSet"> 
    <rdfs:subClassOf> 
      <owl:Class> 
        <owl:oneOf rdf:parseType="Collection"> 
          <InputSet rdf:ID="In_Zero"> 
            <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string" 
            >Input value : 0</rdfs:comment> 
          </InputSet> 
          <InputSet rdf:ID="In_One"> 
            <rdfs:comment rdf:datatype="http://www.w3.org/2001/XMLSchema#string" 
            >Input value : 1</rdfs:comment> 
          </InputSet> 
        </owl:oneOf> 
 

141 
      </owl:Class> 
    </rdfs:subClassOf> 
  </owl:Class> 
  <owl:Class rdf:ID="StartAndFinalState"> 
    <owl:disjointWith> 
      <owl:Class rdf:about="#NormalState"/> 
    </owl:disjointWith> 
    <owl:disjointWith> 
      <owl:Class rdf:about="#StartState"/> 
    </owl:disjointWith> 
    <owl:disjointWith> 
      <owl:Class rdf:about="#FinalState"/> 
    </owl:disjointWith> 
    <rdfs:subClassOf> 
      <owl:Class rdf:ID="State"/> 
    </rdfs:subClassOf> 
  </owl:Class> 
  <owl:Class rdf:ID="FinalState"> 
    <owl:disjointWith> 
      <owl:Class rdf:about="#StartState"/> 
    </owl:disjointWith> 
    <owl:disjointWith rdf:resource="#StartAndFinalState"/> 
    <owl:disjointWith> 
      <owl:Class rdf:about="#NormalState"/> 
    </owl:disjointWith> 
    <rdfs:subClassOf rdf:resource="#State"/> 
  </owl:Class> 
  <owl:Class rdf:ID="Light_Switch"/> 
  <owl:Class rdf:ID="TransitionFunction"/> 
  <owl:Class rdf:ID="Scene"/> 
  <owl:Class rdf:ID="Geometry_for_Light_Bulb_Dynamic_Model"/> 
  <owl:Class rdf:ID="Light_Bulb"/> 
  <owl:Class rdf:ID="NormalState"> 
    <rdfs:subClassOf rdf:resource="#State"/> 
    <owl:disjointWith rdf:resource="#StartAndFinalState"/> 
    <owl:disjointWith rdf:resource="#FinalState"/> 
    <owl:disjointWith> 
      <owl:Class rdf:about="#StartState"/> 
    </owl:disjointWith> 
  </owl:Class> 
  <owl:Class rdf:ID="FSM"> 
    <rdfs:subClassOf> 
      <owl:Restriction> 
        <owl:onProperty> 
          <owl:ObjectProperty rdf:about="#hasTransitionFunction"/> 
        </owl:onProperty> 
        <owl:allValuesFrom rdf:resource="#TransitionFunction"/> 
      </owl:Restriction> 
    </rdfs:subClassOf> 
    <rdfs:subClassOf> 
      <owl:Class rdf:ID="Dynamic_Model"/> 
 

142 
    </rdfs:subClassOf> 
    <rdfs:subClassOf> 
      <owl:Restriction> 
        <owl:allValuesFrom> 
          <owl:Class rdf:about="#StartState"/> 
        </owl:allValuesFrom> 
        <owl:onProperty> 
          <owl:ObjectProperty rdf:about="#hasStartState"/> 
        </owl:onProperty> 
      </owl:Restriction> 
    </rdfs:subClassOf> 
    <rdfs:subClassOf> 
      <owl:Restriction> 
        <owl:allValuesFrom rdf:resource="#StartAndFinalState"/> 
        <owl:onProperty> 
          <owl:ObjectProperty rdf:about="#hasStartAndFinalState"/> 
        </owl:onProperty> 
      </owl:Restriction> 
    </rdfs:subClassOf> 
    <rdfs:subClassOf> 
      <owl:Restriction> 
        <owl:allValuesFrom rdf:resource="#FinalState"/> 
        <owl:onProperty> 
          <owl:ObjectProperty rdf:about="#hasFinalState"/> 
        </owl:onProperty> 
      </owl:Restriction> 
    </rdfs:subClassOf> 
    <rdfs:subClassOf> 
      <owl:Restriction> 
        <owl:onProperty> 
          <owl:ObjectProperty rdf:about="#hasNormalState"/> 
        </owl:onProperty> 
        <owl:allValuesFrom rdf:resource="#NormalState"/> 
      </owl:Restriction> 
    </rdfs:subClassOf> 
  </owl:Class> 
  <owl:Class rdf:ID="Light_Socket"/> 
  <owl:Class rdf:ID="StartState"> 
    <rdfs:subClassOf rdf:resource="#State"/> 
    <owl:disjointWith rdf:resource="#FinalState"/> 
    <owl:disjointWith rdf:resource="#StartAndFinalState"/> 
    <owl:disjointWith rdf:resource="#NormalState"/> 
  </owl:Class> 
  <owl:Class rdf:ID="MXL_for_Light_Bulb_Dynamic_Model"/> 
  <owl:Class rdf:ID="Bulb"/> 
  <owl:ObjectProperty rdf:ID="TakesDynamicProperty"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
 

143 
          <owl:Class rdf:about="#Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#MXL_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasTransitionFunction"> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#FSM"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
    <rdfs:range rdf:resource="#TransitionFunction"/> 
    <rdf:type rdf:resource="http://www.w3.org/2002/07/owl#InverseFunctionalProperty"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasStartState"> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#FSM"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
    <rdfs:range rdf:resource="#StartState"/> 
    <rdf:type rdf:resource="http://www.w3.org/2002/07/owl#FunctionalProperty"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesGeometryProperty"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="is_a_state_2"> 
    <rdfs:domain rdf:resource="#Light_Switch"/> 
    <rdfs:range rdf:resource="#FinalState"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasNormalState"> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#FSM"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
 

144 
    <rdfs:range rdf:resource="#NormalState"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isComposedOf"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#Light_Bulb"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesGeometryOfDynamicModel"> 
    <rdfs:range> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:range> 
    <rdfs:domain rdf:resource="#Geometry_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasRepresentationForDynamicModel"> 
    <rdfs:range rdf:resource="#Light_Bulb"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasStates"> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#FSM"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
    <rdfs:range rdf:resource="#State"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isGeometryModel"> 
    <rdfs:range rdf:resource="#Light_Bulb"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesProcess"/> 
  <owl:ObjectProperty rdf:ID="contains"> 
    <rdfs:domain rdf:resource="#Scene"/> 
    <rdfs:range rdf:resource="#Light_Bulb"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesSensors"/> 
  <owl:ObjectProperty rdf:ID="isInteractionModel"> 
    <rdfs:range rdf:resource="#Scene"/> 
  </owl:ObjectProperty> 
 

145 
  <owl:ObjectProperty rdf:ID="hasGeometryModel"/> 
  <owl:ObjectProperty rdf:ID="hasFinalState"> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#FSM"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
    <rdfs:range rdf:resource="#FinalState"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasMXL"> 
    <rdfs:range rdf:resource="#MXL_for_Light_Bulb_Dynamic_Model"/> 
    <rdfs:domain rdf:resource="#Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasRepresentation"> 
    <rdfs:domain rdf:resource="#Dynamic_Model"/> 
    <rdfs:range rdf:resource="#Geometry_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="isDynamicModel"> 
    <rdfs:range rdf:resource="#Light_Bulb"/> 
    <rdfs:domain rdf:resource="#MXL_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasStartAndFinalState"> 
    <rdfs:range rdf:resource="#StartAndFinalState"/> 
    <rdf:type rdf:resource="http://www.w3.org/2002/07/owl#FunctionalProperty"/> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#FSM"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="is_a_state_3"> 
    <rdfs:domain rdf:resource="#Bulb"/> 
    <rdfs:range rdf:resource="#FinalState"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="is_a_state_1"> 
    <rdfs:range rdf:resource="#StartState"/> 
    <rdfs:domain rdf:resource="#Light_Socket"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasDynamicModel"> 
    <rdfs:range rdf:resource="#Geometry_for_Light_Bulb_Dynamic_Model"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasInput"> 
    <rdfs:range rdf:resource="#InputSet"/> 
    <rdfs:domain rdf:resource="#TransitionFunction"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="hasSource"> 
    <rdfs:domain rdf:resource="#TransitionFunction"/> 
 

146 
    <rdf:type rdf:resource="http://www.w3.org/2002/07/owl#FunctionalProperty"/> 
    <rdfs:range rdf:resource="#State"/> 
  </owl:ObjectProperty> 
  <owl:ObjectProperty rdf:ID="TakesDisplay"/> 
  <owl:DatatypeProperty rdf:ID="hasGeometry"> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
          <owl:Class rdf:about="#Light_Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/> 
  </owl:DatatypeProperty> 
  <owl:FunctionalProperty rdf:ID="hasDynamic"> 
    <rdfs:domain> 
      <owl:Class> 
        <owl:unionOf rdf:parseType="Collection"> 
          <owl:Class rdf:about="#Light_Socket"/> 
          <owl:Class rdf:about="#Light_Switch"/> 
          <owl:Class rdf:about="#Bulb"/> 
          <owl:Class rdf:about="#Light_Bulb"/> 
        </owl:unionOf> 
      </owl:Class> 
    </rdfs:domain> 
    <rdf:type rdf:resource="http://www.w3.org/2002/07/owl#DatatypeProperty"/> 
    <rdf:type rdf:resource="http://www.w3.org/2002/07/owl#ObjectProperty"/> 
    <rdfs:range rdf:resource="http://www.w3.org/2001/XMLSchema#string"/> 
  </owl:FunctionalProperty> 
  <owl:FunctionalProperty rdf:ID="hasTarget"> 
    <rdf:type rdf:resource="http://www.w3.org/2002/07/owl#ObjectProperty"/> 
    <rdfs:domain rdf:resource="#TransitionFunction"/> 
    <rdfs:range rdf:resource="#State"/> 
  </owl:FunctionalProperty> 
</rdf:RDF> 
 
C.4 Parser in XLST 
<?xml version="1.0" encoding="ISO-8859-1"?>  
<xsl:stylesheet  
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0" 
 xmlns:owl="http://www.w3.org/2002/07/owl#"  
 xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  
 xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" > 
<xsl:output omit-xml-declaration ="yes" encoding="UTF-8" indent="yes"/>  
  
<xsl:template match="/">  
      <xsl:for-each select="//owl:Class">  
 

147 
         <xsl:variable name="l_1" select="string-length(@rdf:ID)"/> 
         <xsl:variable name="l_2" select="string-length(child::*/child::owl:Class/@rdf:about)"/> 
         <xsl:variable name="id_1" select="@rdf:ID"/> 
         <xsl:variable name="id_2" select="child::*/child::owl:Class/@rdf:about"/> 
          
        <xsl:choose> 
          <xsl:when test="$l_1 != 0 and $l_2 != 0"> 
            <xsl:value-of select="concat(substring($id_2,2),'\\',$id_1)"/> 
          </xsl:when> 
          <xsl:when test="$l_1 != 0 and $l_2 = 0"> 
             <xsl:value-of select="$id_1"/> 
          </xsl:when>    
 
  <xsl:otherwise> 
 
  </xsl:otherwise> 
        </xsl:choose> 
        <xsl:text> </xsl:text> 
      </xsl:for-each>  
      <xsl:for-each select="//rdfs:subClassOf">  
         <xsl:variable name="id" select="@rdf:resource"/> 
        <xsl:choose> 
          <xsl:when test="$id != ''"> 
            <xsl:variable name="x1" select="parent::owl:Class/@rdf:ID"/> 
            <xsl:if test="$x1 != ''"> 
 
      <xsl:value-of select="concat(substring($id,2),'\\',$x1)"/> 
 
    </xsl:if> 
          </xsl:when> 
 
  <xsl:otherwise></xsl:otherwise> 
        </xsl:choose> 
        <xsl:text> </xsl:text> 
      </xsl:for-each>  
 
      <xsl:for-each select="//owl:Class">  
        <xsl:variable name="id" select="@rdf:ID"/> 
        <xsl:variable name="len" select="string-length($id)"/> 
        <!--<xsl:if test="$len != 0"><xsl:value-of select="$id"/><xsl:text> </xsl:text></xsl:if>  --> 
        <xsl:for-each select="//*[name()= $id]"> 
            <xsl:variable name="inst_id" select="@rdf:ID"/> 
          <!--name:<xsl:value-of select="name()"/>--> 
             <xsl:for-each select="child::*"> 
                <xsl:if test="$len != 0"><xsl:value-of select="$id"/><xsl:text> </xsl:text><xsl:value-of  
                 select="$inst_id"/><xsl:text> </xsl:text></xsl:if> 
                <xsl:variable name="tag" select="."/>  
                <xsl:variable name="res" select="@rdf:resource"/> 
                <xsl:variable name="l" select="string-length(.)"/> 
                <xsl:value-of select="name()"/> 
                <xsl:text> </xsl:text> 
                <xsl:if test="$l != 0"> 
                  <xsl:value-of select="$tag"/> 
                  <xsl:text> </xsl:text> 
                </xsl:if>   
                <xsl:if test="$l = 0"> 
 

148 
                  <xsl:value-of select="$res"/> 
                  <xsl:text> </xsl:text> 
                </xsl:if>  
#                  
             </xsl:for-each>  
        </xsl:for-each>  
 
      </xsl:for-each>      
* 
      <xsl:for-each select="//owl:allValuesFrom/ancestor-or-self::*"> 
         <xsl:variable name="id" select="@rdf:ID"/> 
         <xsl:variable name="id1" select="@rdf:resource"/> 
         <xsl:value-of select="$id"/> 
          
         <xsl:if test="$id1 != ''"> 
             <xsl:value-of select="$id1"/> 
             <xsl:text> </xsl:text> 
         </xsl:if>  
      </xsl:for-each>       
</xsl:template>  
</xsl:stylesheet>  
 
 

 
LIST OF REFERENCES 
1. 
WILSON, T., TALBERT, J., and COX, J. 1993, “Modeling primitives: an object 
oriented formulation of boundary value problems in a solid geometric modeling 
context,” In Proceedings on the Second ACM Symposium on Solid Modeling and 
Applications, ACM Press, New York, 441-448. 
2. 
PAOLUZZI, A., BERNARDINO, F., CATTANI, C., and FERRUCCI, V. 1993, 
“Dimension-independent modeling with simplicial complexes,” ACM Transactions 
on Graphics (TOG), Volume 12, Issue 1 (January), 56-102. 
3. 
HOPKINS, J. and FISHWICK, P. A. 2001, “Synthetic human agents for modeling 
and simulation,” In Proceedings of the IEEE in special issue Agent-Based 
Modeling and Simulation: Exploiting the Metaphor, Volume 89, Number 2 
(February), 131-147. 
4. 
UHRMACHER, A. 2001, “Dynamic structures in modeling and simulation: a 
reflective approach,” ACM Transactions on Modeling and Computer Simulation 
(TOMACS), Volume 11, Issue 2 (April), 206-232. 
5. 
BOBEANU, C., KERCKHOFFS, E., and LANDEGHEM, H. 2004, “Modeling of 
discrete event systems: a holistic and incremental approach using petri nets,” ACM 
Transactions on Modeling and Computer Simulation (TOMACS), Volume 14, 
Issue 4 (October), 389-423. 
6. 
PAGE, E. H., BUSS, A., FISHWICK P. A., HEARLY, K. J., NANCE, R. E., and 
PAUL, R. J. 2000, “Web-based simulation: revolution or evolution?,” ACM 
Transactions on Modeling and Computer Simulation, Volume 10, Number 1 
(January), 3-17. 
7. 
GRIFFIOEN, J., MEHROTRA, R., and YAVATKAR, R. 1993, “An object-
oriented model for image information representation,” In Proceedings of the second 
International Conference on Information and Knowledge Management, ACM 
Press, New York, 393-402. 
8. 
JEONG, K. and ALLAN, D. 2004, “Integrated system design, analysis and 
database-driven simulation model generation,” In Proceedings of the 37th Annual 
Symposium on Simulation, IEEE Computer Society, Washington, 80-88. 
9. 
SHNEIDERMAN, B. and PLAISANT, C. 2004. Designing the user interface: 
strategies for effective human-computer interaction. Addison-Wesley, New York, 
NY. 
149 

150 
10. 
DIK, A., FINLAY, K., ABOWD, G., and BEALE, R. 1998. Human-computer 
interaction. Prentice Hall Europe, Essex, England. 
11. 
BURDEA, G. and COIFFET, P. 1994. Virtual reality technology. Wiley-
Interscience, New York, NY. 
12. 
FISHWICK, P. A. 2004, “Toward an integrative multimodeling interface: a human-
computer interface approach to interrelating model structures,” Accepted for SCS 
Transactions on Simulation, Special Issue in Grand Challenges in Computer 
Simulation. 
13. 
PARK, M. and FISHWICK, P. A. 2004, “A methodology for integrative 
multimodeling: connecting dynamic and geometry models,” In Proceedings of 
Enabling Technology for Simulation Science within SPIE '04 AeroSense 
Conference, Volume 5423, 9-17.  
14. 
PARK, M. and FISHWICK, P. A. 2004, “An integrated environment blending 
dynamic and geometry models," In Proceedings of the 2004 AI, Simulation and 
Planning In High Autonomy Systems, Lecture Notes in Computer Science, Volume 
3397, 574-584. 
15. 
ROOSENDAAL, T. and SELLERI, S. 2004. Blender 2.3 guide. Blender 
Foundation, Amsterdam, the Netherlands.  
16. 
ROOSENDAAL, T. and WARTMANN C. 2002. The official blender gamekit: 
interactive 3d for artists. Blender Foundation, Amsterdam, the Netherlands.  
17. 
WARTMANN, C. 2001. The blender book. Linux Journal Press, Seattle, WA. 
18. 
McGUNIESS, D. L. and HARMELEN, F. 2003, “OWL web ontology language 
overview,” February 1, 2005. http://www.w3.org/TR/owl-features. 
19. 
KIM, T., LEE, J., and FISHWICK, P. A. 2002, “A two-stage modeling and 
simulation process for web-based modeling and simulation,” ACM Transactions on 
Modeling and Computer Simulation, Volume 12, Issue 3 (July), 230-248. 
20. 
KIM, T. and FISHWICK, P. A. 2002, “A 3d XML-based customized framework 
for dynamic models,” In Proceedings f the Seventh International Conference on 3D 
Web Technology, ACM Press, New York, 103-109.                 
21. 
FISHWICK, P. A., LEE, J., PARK, M., and SHIM, H. 2003, " RUBE: a 
customized 2d and 3d modeling framework for simulation," In Proceedings of the 
2003 Winter Simulation Conference, Winter Simulation Conference, 755-762. 
22. 
FISHWICK, P. A. 2002, “rube: an XML-based architecture for 3d process model 
fusion,” In Proceedings of Enabling Technology for Simulation Science within 
SPIE '02 AeroSense Conference, Volume 4716, 330-335. 
 

151 
23. 
KIM, T. AND FISHWICK, P. A. 2002, “An XML-based visualization and 
simulation framework for dynamic models,” In Proceedings of Enabling 
Technology for Simulation Science within SPIE '02 AeroSense Conference, 
Volume 4716, 336–347. 
24. 
LEE, J. and FISHWICK, P. A. 2002, “A dynamics exchange language layer for 
rube,” In Proceedings of Enabling Technologies for Simulation Science within 
SPIE '02 AeroSense Conference, Volume 4716, 359-366. 
25. 
FISHWICK, P. A. 1995. Simulation model design and execution: building digital 
worlds. Prentice-Hall, Englewood Cliffs, NJ. 
26. 
LAW, A. and KELTON, W. 1991. Simulation modeling & analysis. McGraw-Hill, 
New York, NY.  
27. 
HOOVER, S. and PERRY, R. 1989. Simulation: a problem-solving approach. 
Addison-Wesley, New York, NY. 
28. 
ANGEL, E. 2003. Interactive computer graphics: a top-down approach with 
OpenGL. Addison-Wesley, New York, NY. 
29. 
CHASEN, S. 1978. Geometric principles and procedures for computer graphic 
applications. Prentice-Hall, Englewood Cliffs, NJ. 
30. 
BAKER, H. 2004. Computer graphics with OpenGL. Prentice-Hall, Upper Saddle 
River, NJ. 
31. 
LabVIEW. February 1, 2005. http://www.ni.com/labview/ 
32. 
Resource Description Framework (RDF). February 1, 2005. 
http://www.w3.org/RDF/ 
33. 
Resource Description Framework (RDF): Concepts and Abstract Syntax. February 
1, 2005. http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/ 
34. 
NOY, N.F., SINTEK, M., DECKER, S., CRUBEZY, M., FERGERSON, R.W., 
and MUSEN, M.A. 2001, “Creating semantic web contents with Protege-2000,” 
IEEE Intelligent Systems, Volume 16, Number 2, 60-71. 
35. 
The Protégé Ontology Editor and Knowledge Acquisition System. February 1, 
2005. http://protege.stanford.edu/ 
36. 
SWOOP. February 1, 2005. http://www.mindswap.org/2004/SWOOP/ 
37. 
BERNERS-LEE, T., HENDLER, J., and LASSILA, O. 2001. The semantic web, 
Scientific American, May, 34-43. 
 

152 
38. 
RDF Vocabulary Description Language 1.0: RDF Schema. February 1, 2005.    
http://www.w3.org/TR/rdf- schema/ 
39. 
BOUQUET, P., DONA, A., SERAFINI, L., and ZANOBINI, S. 2002, 
“Contextualized local ontologies specification via CTXML,” In Proceedings of the 
AAAI Workshop on Meaning Negotiation, AAAI Press, Menlo Park, 64-71.  
40. 
KASHYAP, V. and SHETH, A. 1996, “Semantic and schematic similarities 
between database objects: a context-based approach,” The VLDB Journal: The 
International Journal on Very Large Data Bases, Volume 5, Issue 4 (December), 
276-304. 
41. 
MAEDCHE, A., MOTIK, B., SILVA, N., and VOLZ, R. 2002, “MAFRA - a 
mapping framework for distributed ontologies,” In Proceedings of the 13th 
International Conference on Knowledge Engineering and Knowledge Management, 
Lecture Notes in Computer Science, Volume 2473, 235-250. 
42. 
WACHE, H., VOEGELE, T., VISSER, U., STUCKENSCHMIDT, H., 
SCHUSTER, G., NEUMANN, H., and HUEBNER, S. 2001, “Ontology-based 
integration of information: a survey of existing approaches,” In Proceedings of the 
IJCAI-01 Workshop on Ontologies and Information Sharing, Volume 47, 108-118. 
43. 
MILLER, J., BARAMIDZE, G., FISHWICK, P. A., and SHETH, A. 2004, 
“Investigating ontologies for simulation modeling,” In Proceedings of the 37th 
Annual Simulation Symposium, IEEE Computer Society, Washington, 55-63. 
44. 
FISHWICK, P. A. and MILLER, J. 2004, “Ontologies for modeling and 
simulation: issues and approaches,” In Proceedings of the 2004 Winter Simulation 
Conference, Winter Simulation Conference, 251-256. 
45. 
LIANG, V. and PAREDIS, C. 2003, “A port ontology for automated model 
composition,” In Proceedings of the 2003 Winter Simulation Conference, Winter 
Simulation Conference, 613-622. 
46. 
ezOWL. February 1, 2005. http://iweb.etri.re.kr/ezowl/index.html 
47. 
OntoViz. February 1, 2005. 
http://protege.stanford.edu/plugins/ontoviz/ontoviz.html 
48. 
CAMPBELL, B., COLLINS, P., HADAWAY, H., HEDLEY, N., and 
STOERMER, M. 2002, “Web3d in ocean science learning environments: virtual 
big beef creek,” In Proceedings of the seventh International Conference on 3D Web 
Technology, ACM Press, New York, 85-91. 
49. 
CUBAUD, P. and TOPOL, A. 2001, “A VRML-based user interface for an online 
digitalized antiquarian collection,” In Proceedings of the Sixth International 
Conference on 3D Web Technology, ACM Press, New York, 51-59. 
 

153 
50. 
LIN, C. and LOFTIN, R. 1998, “Application of virtual reality in the interpretation 
of geoscience data,” In Proceedings of the ACM Symposium on Virtual Reality 
Software and Technology, ACM Press, New York, 187-194. 
51. 
HENDRICKS, Z., MARSDEN, G., and BLAKE, E. 2003, “A meta-authoring tool 
for specifying interactions in virtual reality environments,” In Proceedings of the 
2nd International Conference on Computer Graphics, Virtual Reality, Visualization 
and Interaction in Africa, ACM Press, New York, 171-180. 
52. 
FISHWICK, P. A. 2002, “Using XML for simulation modeling,” In Proceedings of 
the 2003 Winter Simulation Conference, Winter Simulation Conference, 616-622. 
53. 
LIM, N. 2004, “RUBE-QM: a 3d simulation and modeling approach for queuing 
systems,” M.S. Thesis, University of Florida. 
54. 
SHIM, H. 2003, “An XML-based diagrammatic dynamic modeling and simulation 
system,” M.S. Thesis, University of Florida. 
55. 
PARK, M. and FISHWICK, P. A. 2003, "Enabling dynamic model customization," 
In Proceedings of Enabling Technology for Simulation Science within SPIE '03 
AeroSense Conference, Volume 5091, 404-414. 
56. 
SODIPODI. February 1, 2005. http://sodipodi.sourceforge.net/ 
57. 
BLENDER. February 1, 2005. http://www.blender3d.org/ 
58. 
EISENBERG, D. 2002. SVG essentials. O’Reilly, Sebastopol, CA. 
59. 
X3D, February 1, 2005 .http://www.web3d.org/x3d/ 
60. 
KAY, M. 2000. XSLT programmer's reference, Wrox Press, Birmingham, UK. 
61. 
FISHWICK, P. A. 1992, “SimPack: getting started with simulation programming in 
C and C++,” In Proceedings of the 1992 Winter Simulation Conference, ACM 
Press, New York, 154-162. 
62. 
PARK, M. and FISHWICK, P. A. 2002, “SimPackJ/S: a web-oriented toolkit for 
discrete event simulation,” In Proceedings of Enabling Technology for Simulation 
Science within SPIE '02 AeroSense Conference, Volume 4716, 348–358. 
63. 
RUSSELL, S. and NORVIG, P. 2003. Artificial intelligence: a modern approach. 
Prentice-Hall, Upper Saddle River, NJ. 
64. 
GRUBER, T.R. 1995, “Toward principles for the design of ontologies used for 
knowledge sharing,” International Journal of Human-Computer Studies, Volume 
43, 907-928. 
65. 
SIPSER, M. 1996. Introduction to the theory of computation. PWS, Boston, MA. 
 

154 
66. 
KIM, T. 2002, “A 3d XML-based modeling and simulation framework for dynamic 
models,” Ph.D. Dissertation, University of Florida. 
67. 
DAMKJER, K. L. 2003, “Architecting RUBE worlds: a methodology for creating 
virtual analog devices as metaphorical representations of formal systems,” M.S. 
Thesis, University of Florida. 
68. 
ROBERTSON, G. G., CARD, S. K., and MACKINLAY, J. D. 1991, “Cone trees: 
animated 3d visualization of hierarchical information,” In Proceedings of CHI’91 
Conference of Human Factor in Computing Systems, ACM Press, New York, 184-
194. 
69. 
PYTHON, February 1, 2005. http://www.python.org/ 
70. 
BROWN, M. C. 2001. Python: the complete reference. Osborne/McGraw-Hill, 
Berkeley, CA. 
71. 
4Suite, February 1, 2005. http://4suite.org/index.xhtml/ 
72. 
Blender Exporter, February 1, 2005. http://jmsoler.free.fr/util/blenderfile/py/ 
73. 
CAREY, R. and BELL, G. 1997. The annotated VRML 2.0 reference manual. 
Addison-Wesley, Reading, MA. 
74. 
HORROCKS, I., PATEL-SCHNEIDER, P. F., BOLEY, H., TABET, S., GROSOF, 
B., and DEAN, M. 2004, “SWRL: a semantic web rule language combining OWL 
and RuleML,” February 1, 2005. http://www.daml.org/2004/04/swrl/ 
75. 
Jess, February 1, 2005. http://herzberg.ca.sandia.gov/jess/ 
76. 
Racer, February 1, 2005. http://www.sts.tu-harburg.de/~r.f.moeller/racer/ 
 
 
 

 
BIOGRAPHICAL SKETCH 
Minho Park received his Bachelor of Science degree in computer engineering from 
Hong-Ik University, Seoul, Korea, in March 1994. After his graduation, he worked as a 
software engineer at Korea Securities Computer Corporation in Korea, from 1994 to 
1998 and as an assistant manager at Good-Morning Securities Company in Korea, from 
1999 to 2000. In 2002, he received his Master of Science degree in computer and 
information science and engineering at the University of Florida and started to pursue his 
PhD degree since then. His major research areas are web-based modeling for computer 
simulation, 3D visualization, semantic web, and aesthetic computing. 
 
 
155 

