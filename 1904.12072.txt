MIT-CTP/5114
Flow-based generative models for Markov chain Monte Carlo in lattice ﬁeld theory
M. S. Albergo,1, 2, 3 G. Kanwar,4 and P. E. Shanahan4, 1
1Perimeter Institute for Theoretical Physics, Waterloo, Ontario N2L 2Y5, Canada
2Cavendish Laboratories, University of Cambridge, Cambridge CB3 0HE, U.K.
3University of Waterloo, Waterloo, Ontario N2L 3G1, Canada
4Center for Theoretical Physics, Massachusetts Institute of Technology, Cambridge, MA 02139, U.S.A.
A Markov chain update scheme using a machine-learned ﬂow-based generative model is proposed
for Monte Carlo sampling in lattice ﬁeld theories. The generative model may be optimized (trained)
to produce samples from a distribution approximating the desired Boltzmann distribution deter-
mined by the lattice action of the theory being studied. Training the model systematically improves
autocorrelation times in the Markov chain, even in regions of parameter space where standard
Markov chain Monte Carlo algorithms exhibit critical slowing down in producing decorrelated up-
dates. Moreover, the model may be trained without existing samples from the desired distribution.
The algorithm is compared with HMC and local Metropolis sampling for φ4 theory in two dimen-
sions.
I.
INTRODUCTION
A key problem in lattice ﬁeld theory and statisti-
cal mechanics is the evaluation of integrals over ﬁeld
conﬁgurations, referred to as path integrals. Typically,
such integrals are evaluated via a Markov chain Monte
Carlo (MCMC) approach: ﬁeld conﬁgurations are sam-
pled from the desired probability distribution, dictated
by the action of the theory, using a Markov chain. A
signiﬁcant practical concern is the existence of correla-
tions between conﬁgurations in the chain. Critical slow-
ing down [1] refers to the divergence of the associated au-
tocorrelation time as a critical point in parameter space
is approached.
This behavior drastically increases the
computational cost of simulations in these parameter re-
gions [2, 3].
For some models, algorithms have been
found which signiﬁcantly reduce or eliminate this slow-
ing down [4–11], enabling eﬃcient simulation. For ﬁeld
theories, a number of methods have been proposed to
circumvent critical slowing down by variations of Hy-
brid Monte Carlo (HMC) techniques [12–15], multi-scale
updating procedures [16–18], open boundary conditions
or non-orientable manifolds [19–21], metadynamics [22],
and machine learning tools [23, 24]. In important classes
of theories, however, critical slowing down remains lim-
iting; for example, in lattice formulations of Quantum
Chromodynamics (QCD, the piece of the Standard Model
describing the strong nuclear force) it is a major barrier
to simulations at the ﬁne lattice spacings required for
precise control of the continuum limit.
Here, a new ﬂow-based MCMC approach is proposed
and is applied to lattice ﬁeld generation. The resulting
Markov chain has autocorrelation properties that are sys-
tematically improvable by an optimization (training) step
before sampling. In this method, samples z are drawn
from a simple distribution and then transformed by a
change-of-variables (or “ﬂow”) φ = f −1(z), resulting in
samples φ with a new eﬀective distribution ˜pf. The map-
ping f −1 is chosen to be eﬃcient to compute, making it
easy to draw samples φ, and is optimized within a vari-
ational family to produce a distribution ˜pf close to the
desired one. To guarantee asymptotic exactness of sam-
pling, a Markov chain is constructed using Metropolis-
Hastings steps with ˜pf taken as a proposal distribution.
Since proposed samples are independent of the previous
samples in the chain, the autocorrelation time and accep-
tance rate are coupled; the autocorrelation time drops to
zero as the acceptance rate approaches 1. This is true
even in regions of parameter space where standard algo-
rithms exhibit critical slowing down. Under mild condi-
tions (detailed in Section II), this approach is guaranteed
to generate samples from the desired probability distri-
bution in the limit of a large number of updates.
This method has several features that make it attrac-
tive for the evaluation of path integrals in lattice ﬁeld
theories:
1. The autocorrelation time of the Markov chain can
be systematically decreased by training the model;
2. Each step of the Markov chain requires only the
model evaluation and an action computation;
3. Each update proposal is independent of the previ-
ous sample, thus proposals can be generated in par-
allel and eﬃciently composed into a Markov chain;
4. The model is trained using samples produced by the
model itself, without the need for existing samples
from the desired probability distribution.
Several other machine learning approaches have been
applied to MCMC, for statistical mechanics systems, syn-
thetic distributions, and simple lattice quantum ﬁeld
theories.
Self-learning Monte Carlo (SLMC) methods
have been applied fairly successfully to one- to three-
dimensional Ising and fermionic systems. These meth-
ods construct, by a variety of techniques, an eﬀective
Hamiltonian for a theory that can be more easily sam-
pled than the original Hamiltonian [25–29]. The eﬀective
Hamiltonian is learned using supervised learning tech-
niques based on training data drawn from a combination
of existing MCMC simulations, randomly-mutated sam-
ples, and the accelerated Markov chain itself (hence the
arXiv:1904.12072v3  [hep-lat]  9 Sep 2019

2
term “self-learning”).
Flow-based methods have been
used for Monte Carlo sampling in the two-dimensional
Ising model [30], many-body systems [31], and synthetic
distributions [32, 33], and generative adversarial methods
have been applied to two-dimensional scalar ﬁeld the-
ory [34, 35].
In contrast to these approaches, the method proposed
here focuses on directly generating samples from a close
approximation to the true distribution in such a way that
the exact likelihood of each produced sample is known.
The direct generation allows self-learning as in SLMC,
and the known likelihood allows use of a Metropolis-
Hastings acceptance step to ensure exactness.
The proposed ﬂow-based MCMC algorithm is detailed
in Section II. A numerical study of its eﬀectiveness in
the context of two-dimensional φ4 theory is presented in
Section III. Finally, Section IV outlines the further devel-
opment and scaling of the approach that will be required
for applications to theories deﬁned in a larger number
of spacetime dimensions and to more complicated ﬁeld
theories such as QCD.
II.
A FLOW-BASED MARKOV CHAIN MONTE
CARLO ALGORITHM
In lattice ﬁeld theory, a Markov chain Monte Carlo
(MCMC) process is an eﬃcient way to generate ﬁeld
conﬁgurations φ ∈RD distributed according to a target
probability distribution
p(φ) = e−S(φ)/Z,
with
Z =
Z
D
Y
j=1
dφj e−S(φ),
(1)
where j indexes the D components of φ, S(φ) is the action
that deﬁnes the theory and Z is the partition function.
Here, φ is deﬁned to be a vector of D real components
representing the combined internal (α) and spacetime (x)
degrees of freedom of the ﬁeld φ(x, α) evaluated on a ﬁ-
nite, discrete spacetime lattice (generalizations to gauge
ﬁelds are discussed in Section IV). A MCMC process gen-
erates a chain φ(0) →φ(1) →. . . φ(N) by steps through
conﬁguration space starting with an arbitrary conﬁgura-
tion φ(0). The steps are stochastic and are determined
by the probabilities T(φ, φ′) associated with each pos-
sible transition φ →φ′.
These probabilities must be
non-negative and normalized:
T(φ, φ′) ≥0
and
Z
D
Y
j=1
dφ′
j T(φ, φ′) = 1.
(2)
They must also satisfy the conditions of ergodicity and
balance to ensure that samples in the chain are drawn
from a distribution that converges to p(φ) after thermal-
ization. For the chain to be ergodic, it must be possible
to transition from a starting conﬁguration φ to any other
conﬁguration φ′ in a ﬁnite number of steps, i.e.,
∃n such that T n(φ, φ′) > 0 for all φ, φ′,
(3)
and the chain must not have a period, for which it is
suﬃcient that a single state has non-zero self-transition
probability, i.e.,
∃φ such that T(φ, φ) > 0.
(4)
Balance is the condition that p(φ) is a stationary distri-
bution of the transition:
Z
D
Y
j=1
dφj p(φ)T(φ, φ′) = p(φ′).
(5)
Any procedure which satisﬁes these conditions will, in
the limit of a suﬃciently long Markov chain, produce
ﬁeld conﬁgurations {φ(i)} distributed according to p(φ).
A.
Metropolis-Hastings with generative models
Given a model that allows sampling from a known
probability distribution ˜p(φ), a Markov chain for a de-
sired probability distribution p(φ) can be constructed via
the independence Metropolis sampler, a specialization of
the Metropolis-Hastings method [36]. For each step i of
the chain, an update proposal φ′ is generated by sam-
pling from ˜p(φ), independent of the previous conﬁgura-
tion. This proposal is accepted with probability
A(φ(i−1), φ′) = min

1, ˜p(φ(i−1))
p(φ(i−1))
p(φ′)
˜p(φ′)

.
(6)
If the proposal is accepted, φ(i) = φ′, otherwise φ(i) =
φ(i−1). This procedure deﬁnes the transition probabili-
ties of the Markov chain.
The general Metropolis-Hastings algorithm has been
proven to satisfy balance [37] for any proposal scheme.
For the independence Metropolis sampler, under the fur-
ther condition that every state φ has non-zero proposal
density and non-zero desired density,
˜p(φ) > 0, p(φ) > 0 for all φ,
(7)
the Markov chain is also ergodic and thus guaranteed to
converge to the desired distribution [36].
This Markov chain can be intuitively considered a
method to correct an approximate distribution ˜p(φ) to
the desired distribution p(φ). The accept/reject statis-
tics of the Metropolis-Hastings algorithm serve as a diag-
nostic for closeness of the approximate and desired distri-
butions; if the distributions are equal, proposals are ac-
cepted with probability 1 and the Markov chain process
is equivalent to a direct sampling of the desired distribu-
tion. This is made precise in Section II C.
B.
Sampling using normalizing ﬂows
Here, a normalizing ﬂow model is used to deﬁne a
proposal distribution ˜p(φ) for a generative Metropolis-
Hastings algorithm. Normalizing ﬂows [38] are a machine

3
z
ϕ
 
(z)
f −1
…
…
g−1
i
g−1
i+1
g−1
n
g−1
1
r(z)
(ϕ)
p̃ f
(a) Normalizing ﬂow between prior and output distributions
z
za
=
ϕa
zb
split
ti
e−si
−
⊙
ϕb
couple
combine
(z)
g−1
i
(b) Inverse coupling layer
FIG. 1:
In (a), a normalizing ﬂow is shown transforming samples z from a prior distribution r(z) to samples φ distributed
according to ˜pf(φ). The mapping f −1(z) is constructed by composing inverse coupling layers g−1
i
as deﬁned in Eq. (10) in
terms of neural networks si and ti and shown diagrammatically in (b). By optimizing the neural networks within each coupling
layer, ˜pf(φ) can be made to approximate a distribution of interest, p(φ).
learning approach to the task of sampling from compli-
cated, intractable distributions. They do so by learning
a map from an input distribution that is easy to sample
to an output distribution that approximates the desired
distribution. Normalizing ﬂow models produce both sam-
ples and their associated probability densities, allowing
the acceptance probability in Eq. (6) to be calculated.
A normalizing ﬂow enacts the transformation between
distributions by a change-of-variables1: a smooth, bijec-
tive function, f −1 : RD →RD maps samples z from a
prior distribution r(z) to φ = f −1(z).
This mapping
deﬁnes an output distribution ˜pf(φ), by the change-of-
variables formula
˜pf(φ) = r(f(φ))
det ∂f(φ)
∂φ
 .
(8)
Typically,
the
prior
distribution
is
a
simple
and
analytically-understood distribution (e.g., a normal dis-
tribution). While the desired distribution p(φ) is often
complicated and diﬃcult to sample from directly, opti-
mizing the function f allows one to generate samples
from ˜pf(φ) ≈p(φ).
The function f is chosen to have
a tractable Jacobian such that the probability density
˜pf(φ) can be computed exactly according to Eq. (8).
To encode a map from a simple distribution r(z) to a
complicated distribution ˜pf(φ), the map f must be highly
expressive while also being invertible and having a com-
putable Jacobian. Here, the real non-volume-preserving
(real NVP) ﬂow [39] machine learning approach is used:
f is constructed by the composition of aﬃne coupling
layers that scale and oﬀset half of the components of the
input at a time; the choice of which components of the
1 The convention of using f−1 for the change-of-variables stems
from typical applications of normalizing ﬂows.
data are transformed is part of the layer deﬁnition. Split-
ting the D-dimensional vector φ into (D/2)-dimensional
pieces φa and φb according to this choice, a single cou-
pling layer gi transforms φ to z = gi(φ) via
gi(φ) :=
(
za = φa
zb = φb ⊙esi(φa) + ti(φa),
(9)
where si and ti are neural networks mapping from RD/2
to RD/2 and ⊙denotes element-wise multiplication. Im-
portantly, each layer gi is invertible without inverting the
neural networks si or ti:
g−1
i
(z) :=
(
φa = za
φb = (zb −ti(za)) ⊙e−si(za).
(10)
The Jacobian matrix is lower-triangular and its determi-
nant can be easily computed. For coupling layer gi:
det ∂gi(φ)
∂φ
 =
D/2
Y
j=1
e[si(φa)]j,
(11)
where j indexes the D/2 components of the output of si.
Stacking many coupling layers g1, . . . , gn which alternate
which half of the data is transformed, the function f is
deﬁned as
f(φ) = g1(g2(. . . gn(φ) . . . )).
(12)
Using the chain rule, the determinant of the Jacobian
of f is a product of the contributions from each gi. By
increasing the number of coupling layers and the com-
plexity of the networks si and ti, f can systematically
be made more expressive and general. Figure 1 depicts
how composing many coupling layers incrementally mod-
iﬁes a prior distribution which is easy to sample into a

4
more complex output distribution that approximates a
distribution of interest.
For a ﬁxed initial distribution r(z), the neural net-
works within each aﬃne coupling layer of f can be trained
to bring ˜pf(φ) close to the desired distribution p(φ).
This training is undertaken by minimizing a loss func-
tion. Here, the loss function used is a shifted Kullback-
Leibler (KL) divergence2 between the target distribution
of the form p(φ) = e−S(φ)/Z and the proposal distribu-
tion ˜pf(φ):
L(˜pf) := DKL(˜pf||p) −log Z
=
Z Y
j
dφj ˜pf(φ) (log ˜pf(φ) −log p(φ) −log Z)
=
Z Y
j
dφj ˜pf(φ) (log ˜pf(φ) + S(φ)) .
(13)
This loss function has been successfully applied in re-
lated generative approaches to statistical lattice mod-
els [30, 41].
The formal shift by log Z in Eq. (13)
eliminates the need to compute the true partition func-
tion, and does not aﬀect the gradients or location of the
minima.
By non-negativity of the KL divergence, the
lower bound on the loss is −log Z, and this minimum is
achieved exactly when ˜pf = p. In practice, the loss is
stochastically estimated by drawing batches of M sam-
ples from the model

φ(i) ∼˜pf
	
and computing the sam-
ple mean:
\
L (˜pf) = 1
M
M
X
i=1

log ˜pf(φ(i)) + S(φ(i))

.
(14)
The loss minimization can then be undertaken using
stochastic optimization techniques such as stochastic gra-
dient descent or momentum-based methods including
Adam and Nesterov [42, 43].
By construction, the ﬂow model allows sampling from
˜pf eﬃciently. The training process can thus be performed
by drawing samples from the model itself, rather than
using existing samples from the desired distribution as
training data. This self-training is a key feature of the
proposed approach to Monte Carlo sampling for ﬁeld the-
ories, where samples from the desired distribution are
often computationally expensive to obtain.
If samples
do exist, they can be used to ‘pre-train’ the network,
although in the numerical studies undertaken here this
was not found to be markedly more eﬃcient in network
optimization than using only self-training.
Given a trained model with distribution ˜pf(φ) ≈p(φ),
samples from ˜pf can be used as proposals to advance a
Markov chain using the generative Metropolis-Hastings
2 This training paradigm is a speciﬁc instance of Probability Den-
sity Distillation [30, 40].
algorithm described above. This forms the basis for the
ﬂow-based MCMC algorithm proposed here:
1. A ﬂow-based generative model (here, a real NVP
model) is trained using the shifted KL loss given in
Eq. (13) to have output distribution ˜pf(φ) ≈p(φ);
2. N proposals

φ′(i) ∼˜pf
	
are produced by sampling
from the ﬂow-based model (this can be done in par-
allel) and the associated action S(φ′) is computed
for each proposal;
3. Starting from an arbitrary initial conﬁguration,
each proposed sample is successively accepted or
rejected using the Metropolis-Hastings algorithm
given in Eq. (6) to build a Markov chain of length
N.
When the prior distribution r(z) is strictly positive, the
invertibility and continuity of f guarantees that the gen-
erated distribution ˜pf(φ) is also strictly positive. For all
models with ﬁnite action, and thus p(φ) > 0, the re-
sulting Markov chain is then ergodic by the arguments
detailed in Section II A.
C.
Autocorrelation time for generative
Metropolis-Hastings
For any Markov chain constructed via a generative
Metropolis-Hastings algorithm (with independent update
proposals), an observable-independent estimator for au-
tocorrelation time can be deﬁned from the accept/reject
statistics of the chain.
This serves both as a measure
of the similarity between the proposal and desired dis-
tributions and enables proper error estimation for lattice
observables [44].
Precisely, the autocorrelation at Markov chain separa-
tion τ, for all observables, is given by the probability of
τ rejections in a row,
pτrej ≡
* τY
i=1
1rej(i)
+
= ρ(τ)/ρ(0),
(15)
where 1rej(i) is an indicator variable taking value 1 when
the proposed step from i −1 to i was rejected in the
Metropolis-Hastings algorithm, and 0 otherwise. In prac-
tice, for a near-equilibrium, ﬁnite Markov chain with
length N, a ﬁnite-sample estimator provides a good ap-
proximation to ρ(τ)/ρ(0):
\
ρ(τ)/ρ(0)acc =
1
N −τ
N−τ
X
j=1
τY
i=1
1rej(i + j).
(16)
This measure of autocorrelation is consistent with the
usual deﬁnition; it is shown in Appendix A that the stan-
dard estimator for the autocorrelation of any given ob-
servable O,
\
ρ(τ)/ρ(0)O =
1
N−τ
PN−τ−1
i=0
(Oi −¯O)(Oi+τ −¯O)
1
N
PN−1
i=0
 Oi −¯O
2
, (17)

5
also converges to pτrej in the limit N →∞.
The qualitative relation between acceptance rate and
autocorrelations gives a convenient measure of the auto-
correlation characteristics of a Markov chain. Precisely,
the autocorrelation at distance τ can be bounded in terms
of the average acceptance rate a = 1 −E [prej]:
ρ(τ)/ρ(0) = E
φ∼p

pτ
rej(φ)

≥

E
φ∼p [prej(φ)]
τ
= (1 −a)τ.
(18)
Increasing the acceptance rate of an independence
Metropolis sampler is thus a necessary condition to re-
duce autocorrelations. Additionally, a = 1 exactly when
the proposal and desired distributions are equal. In this
case, prej(φ) = 0 for each φ, and there are no autocor-
relations. While bringing a close to 1 does not provide
an upper bound on autocorrelation, stochastically im-
proving a loss function that measures distance between
distributions is expected to reduce autocorrelations on
average. In practice, autocorrelations should be evalu-
ated as a test metric alongside the training loss to con-
ﬁrm improvement over the course of training the model.
The correspondence between loss minimization, accep-
tance rate, and autocorrelations is studied in the context
of φ4 theory in Section III, where a clear correlation be-
tween a and ρ(τ)/ρ(0) is observed.
D.
Critical slowing down
When a distribution is sampled using a Markov chain
with large autocorrelation time, many updates are re-
quired to produce decorrelated samples. Critical slowing
down (CSD) is deﬁned as the divergence of the autocorre-
lation time of Markov chain sampling as a critical point in
parameter space is approached [1]. A numerically-stable
deﬁnition of the characteristic autocorrelation time of a
Markov chain is the integrated autocorrelation time:
τ int
O = 1
2 +
lim
τmax→∞
τmax
X
τ=1
ρO(τ)
ρO(0).
(19)
As a critical point is approached, analysis of standard
local-update algorithms for lattice models suggests τ int
O
is typically well-described by a power law in the lattice
spacing, or for ﬁxed physical volume, a power law in the
lattice sites per dimension, L. A dynamical critical expo-
nent zO is thus deﬁned by a ﬁt to τ int
O = αOLzO along a
line of constant physics. An update algorithm for which
the critical exponent is zero is unaﬀected by CSD.
In any generative Metropolis-Hastings simulation, the
autocorrelation time is completely ﬁxed by the expected
accept/reject statistics, which in turn result from the
structure of the proposal and desired distributions. For
models trained with a target value of the integrated au-
tocorrelation time used as a stopping criterion, CSD as-
sociated with the Markov chain sampling is thus trivially
removed at the expense of up-front training costs. The
E1
E2
E3
E4
E5
L
6
8
10
12
14
m2
−4
−4
−4
−4
−4
λ
6.975
6.008
5.550
5.276
5.113
mpL
3.96(3)
3.97(5)
4.00(4)
3.96(5)
4.03(6)
TABLE I: Parameters {m2, λ} of φ4 theory on L × L lattices
used for numerical study of the ﬂow-based MCMC algorithm
proposed here. The coupling constants λ have been chosen to
approximately maintain constant mpL as L is varied.
diﬃculty of CSD is in essence shifted to the training of
the model, i.e., to the optimization of the proposal distri-
bution. The cost and scaling of this optimization task for
φ4 theory, as studied here, and the prospects of scaling
this approach to more complicated theories, are discussed
in Sec. III D.
III.
APPLICATION OF FLOW-BASED MCMC
TO φ4 THEORY
The theory with a massive scalar ﬁeld φ(x) and a quar-
tic self-interaction is one of the simplest interacting ﬁeld
theories that can be constructed. It is thus a convenient
testing ground for new algorithms for lattice ﬁeld theory,
such as the ﬂow-based MCMC approach proposed here.
In a d-dimensional Euclidean spacetime, a discretized
formulation of φ4 theory can be deﬁned on a lattice with
sites xµ = anµ, where a denotes the lattice spacing,
µ ∈{1, . . . , d} labels spacetime dimension, and nµ ∈Zd.
Here, a ﬁnite lattice volume V = (aL)d is considered,
with periodic boundary conditions in all dimensions. The
lattice action (in units where a = 1) can be expressed as
S(φ) =
X
x
 X
y
φ(x)□(x, y)φ(y) + m2φ(x)2 + λφ(x)4
!
,
(20)
where the parameters m2 and λ are the bare mass
squared and bare coupling, respectively, and the lattice
d’Alembert operator is deﬁned by
X
y
□(x, y)φ(y) =
X
µ
(2φ(x) −φ(x −ˆµ) −φ(x + ˆµ)) .
(21)
By taking expectation values over the distribution p(φ) =
e−S(φ)/Z, observables in the theory can be estimated.
The observables studied here are the connected two-
point Green’s function
Gc(x) = 1
V
X
y
 ⟨φ(y)φ(y + x)⟩−⟨φ(y)⟩⟨φ(y + x)⟩

(22)
and its momentum-space representation
˜Gc(⃗p, t) =
1
Ld−1
X
⃗x
ei⃗p·⃗xGc(⃗x, t),
(23)

6
62 ML
1
10
100
1000
104
Count
102 ML
1
10
100
1000
104
142 ML
0
20
40
60
80
1
10
100
1000
104
Run length
(a) Flow-based MCMC trained to 50% mean
acceptance.
62 ML
62 HMC
1
10
100
1000
104
Count
102 ML
102 HMC
1
10
100
1000
104
142 ML
142 HMC
0
20
40
60
80
1
10
100
1000
104
Run length
(b) Flow-based MCMC trained to 70% mean
acceptance and HMC tuned to 70% mean
acceptance.
FIG. 2: Histograms of length of consecutive runs of Metropolis rejections in machine-learned (ML) models at both 50% and
70% mean acceptance. Also shown is the same statistic for Markov chains generated via HMC, where mean acceptance was
tuned to 70%. The frequency of long runs of rejections is consistently reduced for models trained to reach higher average
acceptance. The ML and HMC ensembles at 70% acceptance display very similar distributions of rejection streaks.
where xµ = (⃗x, t), as well as the corresponding pole mass
mp = −∂t log
D
˜Gc(0, t)
E
,
(24)
and the two-point susceptibility
χ2 =
X
x
Gc(x).
(25)
In the limit λ →∞, with m2/λ < 0 ﬁxed, scalar φ4
theory reduces to an Ising model. Another observable of
interest is therefore the average Ising energy density [45],
deﬁned by
E = 1
d
X
1≤µ≤d
Gc(ˆµ),
(26)
where the sum runs over single-site displacements in all
dimensions.
The action of φ4 theory is invariant under the discrete
symmetry φ(x) →−φ(x).
Depending on the value of
the parameters m2 and λ, this symmetry can be spon-
taneously broken.
The theory thus has two phases: a
symmetric phase and a broken-symmetry phase.
A.
Model deﬁnition and training
For
this
proof-of-principle
study,
the
ﬂow-based
MCMC algorithm detailed in Section II was applied to
φ4 theory in two dimensions with L = {6, 8, 10, 12, 14}
lattice sites in each dimension. The parameters m2 and
λ were chosen to ﬁx mpL ≈4 for each lattice size; their
numerical values are given in Table I. For simplicity in
this initial work, all parameters were chosen to lie in the
symmetric phase.
In principle, the ﬂow-based MCMC
algorithm can be applied with identical methods to the
broken-symmetry phase of the theory, but it remains to
be shown that models can be trained for such choices of
parameters.
For each set of parameters, real NVP models were de-
ﬁned using 8–12 aﬃne coupling layers (see Sec. II B). The
coupling layers were deﬁned to update half of the lattice
sites in a checkerboard pattern; successive layers alter-
nately updated the odd and even sites. The neural net-
works si and ti used in coupling layer gi (see Eq. (9))
were constructed from two to six fully-connected layers,
each deﬁned as multiplication by a rectangular matrix
followed by pointwise application of a nonlinear function
(here, a leaky rectiﬁed linear unit [46]).
Intermediate
vectors (hidden units) had sizes ranging between 100–
1024. The prior distribution r(z) was chosen to be an
uncorrelated Gaussian distribution
r(z) ∝
Y
i
e−z2
i /2.
(27)
The models were trained to minimize the shifted KL loss
between the output distribution ˜pf(φ) and the desired
distribution p(φ) = e−S(φ)/Z using gradient-based up-
dates with the Adam optimizer [42], a speciﬁc variety
of gradient descent with momentum. A mean absolute
error loss, deﬁned in Appendix B, was optimized before
training in the case of the 142 model where it was found
to accelerate convergence to the KL loss minimum.

7
○
○
○
○
○
○
○
○
○
○
○
○
○
○
□
□
□
□
□
□
□
□
□
□
□
□
□
□
◇
◇
◇
◇
◇
◇
◇
◇
◇
◇
◇
◇
◇
◇
○HMC
□Local
◇ML
0
1
2
3
4
5
6
7
8
9 10 11 12 13
0.02
0.03
0.04
0.05
0.06
FIG. 3: Zero-momentum Green’s functions evaluated for pa-
rameter set E5. Results computed using 106 conﬁgurations
from the HMC, local Metropolis, and machine-learned (ML)
ensembles are consistent within statistical errors. Error bars
indicate 68% conﬁdence intervals estimated using bootstrap
resampling with bins of size 100.
○
○
○
○
○
○
○
○
○
○
○
○
□
□
□
□
□
□
□
□
□
□
□
□
◇
◇
◇
◇
◇
◇
◇
◇
◇
◇
◇
◇
○HMC
□Local
◇ML
1
2
3
4
5
6
7
8
9
10 11 12
0.275
0.280
0.285
0.290
0.295
0.300
0.305
FIG. 4: Eﬀective pole masses evaluated for parameter set E5,
deﬁned by the arccosh estimator given in the main text. Re-
sults computed using 106 conﬁgurations from the HMC, local
Metropolis, and machine-learned (ML) ensembles are consis-
tent within statistical errors. Error bars indicate 68% con-
ﬁdence intervals estimated using bootstrap resampling with
bins of size 100.
An exhaustive study of the optimal choice of prior dis-
tribution r(z), model depth, architecture and initializa-
tion of the neural networks, and of the mode of cou-
pling of the aﬃne layers, is beyond the scope of this
proof-of-principle study. The parameters used here, how-
ever, proved to deﬁne suﬃciently expressive models such
that the Metropolis-Hastings algorithm applied to out-
put from the trained models easily achieved acceptance
rates of well over 50%. With further investment in hyper-
parameter optimization, higher rates of acceptance could
be achieved. In any Markov chain using the Metropolis-
Hastings algorithm, there is a tradeoﬀbetween compu-
tational cost and correlations resulting from low accep-
tance rates. The optimal acceptance rate minimizes the
cost per decorrelated sample from the chain. Here, the
cost of training, and not just model evaluation, must be
considered, and the optimal level of training in future
applications will depend on many factors, such as the
desired ensemble size.
For each set of parameters studied, instances of the
model were trained to reach both 50% and 70% aver-
age Metropolis acceptance. Figure 2 shows histograms of
the number of updates between accepted conﬁgurations
for models at both levels of training. Models trained to
reach the higher acceptance rate are seen to have shorter
runs of consecutive rejections. Because autocorrelation
is related to rejections by ρ(τ)/ρ(0) = pτrej for indepen-
dence Metropolis sampling, a reduced frequency of re-
jection runs with length longer than τ directly implies a
reduction in ρ(τ)/ρ(0). Implications for critical slowing
down of the generation of decorrelated conﬁgurations are
discussed in Section III C.
For comparison, ensembles of 106 lattice conﬁgura-
tions were generated using the machine-learned models
in ﬂow-based MCMC as well as standard local Metropo-
lis [47] and Hybrid Monte Carlo (HMC) [48] algorithms
at matched parameters. The local Metropolis algorithm
employed a ﬁxed order of sequential updates to each site,
with proposed updates to φ(x) sampled uniformly from
the interval [φ(x) −δ, φ(x) + δ] followed by a Metropolis-
Hastings accept/reject step; for all parameters consid-
ered, the width δ was tuned to achieve a 70% accep-
tance rate. The HMC method was implemented using
a leapfrog integrator with a ﬁxed division of trajectory
length τ into 10 steps; the trajectory length τ was also
tuned to achieve a 70% acceptance rate. In both the local
Metropolis and HMC methods, samples were saved after
every 10th update.
B.
Tests: physical observables and error scaling
Since the ﬂow-based MCMC algorithm satisﬁes ergod-
icity and balance, it is guaranteed to produce samples
from the desired probability distribution in the limit of
an inﬁnite chain. To test the performance of the algo-
rithm for a ﬁnite number of samples, each of the physical
observables deﬁned above was computed on ensembles
of conﬁgurations at the parameters of Table I, generated
both using standard HMC and local Metropolis methods,
as well as with the trained ﬂow-based MCMC algorithm.
Figures 3–5 compare the observables computed on en-
sembles generated using all three methods.
To estimate the pole mass mp, an eﬀective mass is
deﬁned based on the zero-momentum Green’s functions
at various time separations:
meﬀ
p (t) = arccosh
 ˜Gc(0, t −1) + ˜Gc(0, t + 1)
2 ˜Gc(0, t)
!
.
(28)
For all observables, the values computed using the ﬂow-

8
○
○
○
○
○
□
□
□
□
□
◇
◇
◇
◇
◇
○
HMC
□
Local
◇
ML
62
82
102
122
142
1
2
3
4
5
6
○
○
○
○
○
□
□
□
□
□
◇
◇
◇
◇
◇
○
HMC
□
Local
◇
ML
62
82
102
122
142
0.05
0.06
0.07
0.08
0.09
0.10
0.11
FIG. 5: Susceptibility (χ2) and Ising energy (E) estimated
on all ensembles. Results computed using 106 conﬁgurations
from the HMC, local Metropolis, and machine-learned (ML)
ensembles are consistent within statistical errors. Errors in-
dicate 68% conﬁdence intervals estimated using bootstrap re-
sampling with bins of size 100.
○
○
○
○
○○
○○
○
○
□
□
□
□
□
□□□
□
□
◇
◇
◇
◇
◇
◇◇◇
◇
◇
○
HMC
□
Local
◇
ML
1000
2000
5000
10 000
0.02
0.03
0.04
0.05
0.06
○
○
○
○
○
○
○
○
○
○
□
□
□
□
□□
□
□
□□
◇
◇
◇
◇
◇
◇
◇
◇◇◇
○
HMC
□
Local
◇
ML
1000
2000
5000
10 000
1.0×10-4
1.5×10-4
2.0×10-4
2.5×10-4
FIG. 6: Statistical error varying with number of samples N
in two candidate observables, χ2 and E, for the HMC, local
Metropolis, and machine-learned (ML) ensembles. The red
dashed line shows a 1/
√
N curve normalized by the average
error estimate of the three approaches at N = 1000. Central
values were estimated as 68% conﬁdence intervals on each
observable by bootstrap resampling ensemble subsets of size
N. Error bars indicate 68% conﬁdence intervals estimated
using an external bootstrap resampling step.
based MCMC ensembles are consistent within statistical
uncertainties with those computed using the standard
methods. Moreover, Figure 6 shows that the statistical
uncertainties of the observables scale as 1/
√
N with the
number of samples N, as expected for decorrelated sam-
ples.
C.
Critical slowing down
For φ4 theory, a number of algorithms have been de-
veloped that mitigate CSD to various extents, such as
worm algorithms [45], multigrid methods [49], Fourier-
accelerated Langevin updates [50] and cluster updates
via embedded Ising dynamics [51].
The path towards
generalizing those algorithms to more complicated theo-
ries such as QCD, however, is not clear. Algorithms such
as HMC and local Metropolis, which are also used for
studies of QCD and pure gauge theory, exhibit CSD for
φ4 (as well as more complicated theories) as the contin-
uum limit is approached.
The parameter sets chosen for the study of φ4 theory
in this work (Table I) correspond to a critical line with
constant mpL as L →∞. For the ﬂow-based MCMC
approach proposed here, as well as for ensembles gener-
ated using the HMC and local Metropolis algorithms, the
autocorrelation times of the set of physical observables
discussed previously were ﬁt to leading-order power laws
in L to determine the dynamical critical exponents zO
for that observable. Figure 7 shows the autocorrelation
times for each observable for each approach to ensemble
generation. The absolute values of τint are not directly
comparable between methods because the cost per up-
date diﬀers. The scaling with lattice size, on the other
hand, indicates the sensitivity of each method to critical
slowing down. For both HMC and local Metropolis, the
critical behavior and consequently the performance of the
algorithm was found to depend on the observable. In each
case, the critical exponent was 0.3 ≲zO ≲2.0. In com-
parison, for the ﬂow-based MCMC ensembles at a ﬁxed
acceptance, the critical exponent was found to be consis-
tent with zero, with the autocorrelation time observable-
independent and in agreement with the acceptance-based
estimator deﬁned in Section II C.
Since the the mean acceptance rate was used as the
stopping criterion for training these models, it was not
guaranteed a priori that the measured integrated auto-
correlation time would be constant across the diﬀerent

9
○
○
○
○
○
□
□
□
□
□
◇
◇
◇
◇
◇
○
□
◇
6
8
10
12
14
0.5
1
2
5
(a) HMC ensembles
○
○
○
○
○
□
□
□
□
□
◇
◇
◇
◇
◇
○
□
◇
6
8
10
12
14
0.5
1
2
5
(b) Local Metropolis ensembles
○
○
○
○
○
□
□
□
□
□
◇
◇
◇
◇
◇
△
△
△
△
△
○
○
○
○
○
□
□
□
□
□
◇
◇
◇
◇
◇
△
△
△
△
△
○
□
◇
△
6
8
10
12
14
0.5
1
2
5
50% ML models
70% ML models
(c) Flow-based MCMC ensembles
FIG. 7:
Scaling of integrated autocorrelation time with respect to lattice size for HMC, local Metropolis, and ﬂow-based
MCMC. In (c) the upper sets of points in blue correspond to models trained to a mean acceptance rate of 50%, while the lower
sets of points in green correspond to models trained to a mean acceptance rate of 70%. Dashed red lines display power law
ﬁts to L = {10, 12, 14} with labels Lz specifying the scaling. The HMC and local Metropolis methods demonstrate power-law
growth of τint, while τint for the ﬂow-based MCMC is consistent with a constant in L and decreases as mean acceptance rate
increases. Dot-dashed blue and green lines for the ﬂow-based ensembles display lower bounds in terms of mean acceptance rate
based on Eq. (18). Error bars indicate 68% conﬁdence intervals estimated by bootstrap resampling and error propagation.
models used. The results in Figure 7, however, suggest
that beyond the simple lower bound from Eq. (18) there
is a strong correlation between the mean acceptance rate
and integrated autocorrelation time for models trained
using a shifted KL loss. This is further conﬁrmed by the
similarity of the rejection run histograms across lattice
sizes for ﬂow-based MCMC, as shown in Figure 2.
D.
Training costs
While CSD in the sampling step for the ﬂow-based
MCMC is eliminated, training the generative model in-
troduces an additional up-front cost, as discussed in Sec-
tion II D. Since this cost is amortized over the ensemble,
this approach will naturally be computationally advan-
tageous in the limit of generating a large number of sam-
ples. For a ﬁnite target ensemble size, the potential ac-
celeration oﬀered depends crucially on the training time.
In this work, all models were trained using one to two
GPU-weeks, with the larger lattices incurring the most
computational cost. For the simple fully-connected archi-
tecture used in this work, the scaling of both the sampling
and training time is controlled by dense matrix-vector
multiplications which require O(V 2) ﬂoating point op-
erations each. The number of epochs used to train the
largest lattice was also roughly 10× that of the smallest
lattice. This asymptotic scaling is a result of the simple
model architecture used in this proof-of-principle study.
For related methods applied to image generation, using
convolutional neural networks and a multi-scale archi-
tecture reduced training and sampling costs signiﬁcantly
and improved scaling to O(V ) [39]. There are physical
grounds to expect these tools to apply equally well to
the present application. Convolutional networks use only
local information to update values in each layer, exploit-
ing locality in the system, and use identical weights for
each point on the lattice, manifestly preserving trans-
lational invariance.
A multi-scale architecture learns
coarse-grained distributions and ﬁne-graining procedures
in separate layers; this is an eﬀective division of tasks
for renormalizable quantum ﬁeld theories, where simple
coarse-grained descriptions are expected to arise. Gen-
erative models, and in particular ﬂow-based models, are
also rapidly evolving towards more eﬃcient representa-
tion capacity. Complex coupling layers have been imple-
mented [39, 52], as have generalized convolutions [53, 54]
and transformations with continuous dynamics that are
not dependent on restricted coupling layers [55]. These
developments allow models to better capture a distribu-
tion within a given number of training steps.
For complex applications, it is also critical that larger
models with many coupling layers can be trained with-
out exceeding memory bounds. The algorithm proposed
here can be trained with constant memory cost as the
number of layers is increased [56], alleviating the stor-
age limitations that can arise in gradient-based optimiza-
tion. Memory costs can be further reduced by distribut-
ing samples within each training batch across many ma-
chines.
Finally, typical applications seek to produce ensembles
at many diﬀerent choices of parameters, and often require
parameter tuning. Training costs can therefore by amor-
tized further; models trained with respect to an action
at a given set of parameter values can either be used to
initialize training or as a prior distribution for models

10
targeting that action at nearby parameter values.
IV.
SUMMARY
This work deﬁnes a ﬂow-based MCMC algorithm to
sample lattice ﬁeld conﬁgurations from a desired proba-
bility distribution:
1. A real NVP ﬂow model is trained to produce ap-
proximately the desired distribution;
2. Samples are proposed from the trained model;
3. Starting from an arbitrary conﬁguration, each pro-
posal is accepted or rejected to advance a Markov
chain using the Metropolis-Hastings algorithm.
The approach is shown to deﬁne an ergodic and bal-
anced Markov chain, thus guaranteeing convergence to
the desired probability distribution in the limit of a
long Markov chain. In essence, the ﬂow-based MCMC
algorithm combines the expressiveness of normalizing
ﬂows based on neural networks with the theoretical
guarantees of Markov chains to create a trainable and
asymptotically-correct sampler.
Since these ﬂows are
applicable for arbitrary conﬁgurations with continuous,
real-valued degrees of freedom, one can generically apply
this method to any of a broad class of lattice theories.
Here, the algorithm is implemented in practice for φ4 the-
ory, and is demonstrated to produce ensembles of conﬁg-
urations that are indistinguishable from those generated
using standard local Metropolis and HMC algorithms,
based on studies of a number of physical observables.
A key feature of the approach is that models trained to
a ﬁxed acceptance rate do not experience critical slowing
down in the sampling stage. In particular, the autocorre-
lation time for all observables is dictated entirely by the
accuracy with which the ﬂow model has been trained;
perfect training corresponds to decorrelated samples and
100% acceptance in the Metropolis-Hastings step of the
MCMC process. Nevertheless, the eﬃciency with which
the training step of this approach can be scaled to larger
model sizes, and to more complicated theories such as
QCD, remains to be studied.
Recent advances in the
training and scaling of ﬂow models provide reasons for
optimism on this front. Further, incorporating symme-
tries generally improves data eﬃciency of training, and
implementing spacetime and gauge symmetries [57] may
be a natural next step to practically train these ﬂow mod-
els for lattice gauge theories like QCD.
In moving towards lattice gauge theories such as QCD,
several theoretical developments are also required. The
real NVP model chosen to parameterize the normaliz-
ing ﬂows here is described in terms of vectors of vari-
ables φ ∈RD. Gauge conﬁgurations, however, live in a
compact manifold arising from the Lie group structure.
Extending this method will require a normalizing ﬂow
model that can act on this manifold while remaining suf-
ﬁciently expressive. The choice of prior likewise will need
to be extended to a distribution over the manifold of lat-
tice gauge conﬁgurations which can be easily sampled.
A uniform distribution, for example, may be a candidate
for a prior, but this choice must be tested in the context
of a speciﬁc ﬂow model.
If the ﬂow-based MCMC algorithm proposed here can
be implemented for a complex theory such as QCD, the
advantages would be signiﬁcant; arbitrarily large ensem-
bles of ﬁeld conﬁgurations could be generated at minimal
cost. The independence of the proposal step from any
previous conﬁguration allows parallel generation of pro-
posals, and the continually-improving support in hard-
ware and software for neural network execution sug-
gests future practical gains for this style of ensemble-
generation.
Given eﬃcient sample generation from a
trained model, ensembles would not need to be stored
long-term.
Moreover, a model trained for one action
could either be re-trained or used as a prior for another
ﬂow model targeting an action with nearby parameter
values. This would allow eﬃcient tuning of parameters
and generation of additional ensembles interpolating be-
tween and extrapolating from existing models.
Acknowledgements
We thank J.-W. Chen, K. Cranmer, W. Detmold,
R. Melko, D. Murphy, A. Pochinsky, and B. Trippe for
helpful discussions. This work is supported in part by
the U.S. Department of Energy, Oﬃce of Science, Of-
ﬁce of Nuclear Physics under grant Contract Number de-
sc0011090. This research used resources of the Argonne
Leadership Computing Facility, which is a DOE Oﬃce
of Science User Facility supported under Contract DE-
AC02-06CH11357, under the ALCF Aurora Early Sci-
ence Program. Some work was undertaken at the Kavli
Institute for Theoretical Physics, supported by the Na-
tional Science Foundation under Grant No. NSF PHY-
1748958. PES is supported by the National Science Foun-
dation under CAREER Award 1841699, GK is supported
by the U.S. Department of Energy under the SciDAC4
award de-sc0018121, and PES and MSA are supported
in part by NSERC and the Perimeter Institute for The-
oretical Physics. Research at the Perimeter Institute is
supported by the Government of Canada through the
Department of Innovation, Science and Economic Devel-
opment and by the Province of Ontario through the Min-
istry of Research and Innovation.
Appendix A: Acceptance rate estimator for
autocorrelation
Here it is shown that the standard estimator for the
autocorrelation of an observable O converges in the limit
of inﬁnite path length to pτrej, as claimed in Section II C.

11
The standard estimator is deﬁned by:
lim
N→∞E
h
\
ρ(τ)/ρ(0)O
i
(A1)
= lim
N→∞E
"
1
N−τ
PN−τ−1
i=0
(Oi −¯O)(Oi+τ −¯O)
1
N
PN−1
i=0
 Oi −¯O
2
#
(A2)
= lim
N→∞E
"
(Oi −¯O)(Oi+τ −¯O)
1
N
PN−1
i=0
 Oi −¯O
2
#
,
(A3)
where the ﬁnal equality is true assuming the Markov
chain is initialized with a sample from the stationary
distribution p(φ) (i.e., it is assumed that enough prior
iterations were discarded that the chain is thermalized).
The expectation value can then be split by cases and,
conditioning on the ﬁxed accept/reject pattern, the ex-
pectation values can be computed by identifying the dis-
tributions of observables Oi and Oi+τ:
lim
N→∞E
h
\
ρ(τ)/ρ(0)O
i
= lim
N→∞pτrejE
"
(Oi −¯O)(Oi+τ −¯O)
1
N
PN−1
i=0
 Oi −¯O
2
all proposals i + 1, . . . , i + τ rejected
#
+
(A4)
(1 −pτrej)E
"
(Oi −¯O)(Oi+τ −¯O)
1
N
PN−1
i=0
 Oi −¯O
2
some proposal i + 1, . . . , i + τ accepted
#
(A5)
= pτrej lim
N→∞E
φ∼p
"
(O[φ] −¯O)2
1
N
P
j /∈[i,i+τ](Oj −¯O)2 + O(τ/N)
#
+
(A6)
(1 −pτrej) lim
N→∞E
φ∼p E
φ′∼˜p
"
(O[φ] −¯O)(O[φ′] −¯O)
1
N
P
j /∈[i,i+τ](Oj −¯O)2 + O(τ/N)
#
(A7)
= pτrej
ρ(0)
ρ(0) + (1 −pτrej)
E
φ∼p

O[φ] −¯O

E
φ′∼˜p

O[φ′] −¯O

ρ(0)
= pτrej.
(A8)
The limit N →∞is used to drop biases arising from
conditioning on behavior within the region [i, i + τ].
Appendix B: Mean absolute error loss
The mean absolute error (MAE) loss optimized before
training some models is deﬁned by:
LMAE(˜pf) :=
Z Y
j
dφj ˜pf(φ) |log ˜pf(φ) −log p(φ)| .
(B1)
It is bounded below by the KL divergence DKL(˜pf||p)
and has global minima exactly where the KL loss does,
when ˜pf = p.
In
practice,
the
loss
is
stochastically
estimated
by drawing batches of M samples from the model

φ(i) ∼˜pf
	
and computing the sample mean:
\
LMAE(˜pf) = 1
M
M
X
i=1
log ˜pf(φ(i)) −log p(φ(i))

= 1
M
M
X
i=1
log ˜pf(φ(i)) + S(φ(i)) + log Z
 .
(B2)
To employ this loss, the partition function must either
be estimated ahead of time, or initialized as a trainable
parameter. In this study, a multistage method [58] was
used to estimate and ﬁx the partition function value used
while optimizing LMAE.
This loss is appealing due to the point-by-point poten-
tial driving the distribution towards the correct one. Any
errors in computing log Z, however, result in a minimum
at which the model distribution ˜pf(φ) does not necessar-
ily agree with the desired distribution p(φ). This loss was
therefore only used prior to training with the shifted KL
loss.

12
[1] U. Wolﬀ, Nucl. Phys. Proc. Suppl. 17, 93 (1990).
[2] L. Del Debbio, G. M. Manca, and E. Vicari, Phys. Lett.
B594, 315 (2004), hep-lat/0403001.
[3] H. B. Meyer, H. Simma, R. Sommer, M. Della Morte,
O. Witzel, and U. Wolﬀ, Comput. Phys. Commun. 176,
91 (2007), hep-lat/0606004.
[4] D. Kandel, E. Domany, D. Ron, A. Brandt, and E. Loh,
Phys. Rev. Lett. 60, 1591 (1988).
[5] C. Bonati and M. D’Elia, Phys. Rev. E98, 013308 (2018),
1709.10034.
[6] M. Hasenbusch and S. Schaefer, Phys. Rev. D 98,
054502 (2018), URL https://link.aps.org/doi/10.
1103/PhysRevD.98.054502.
[7] R. H. Swendsen and J.-S. Wang, Phys. Rev. Lett. 58,
86 (1987), URL https://link.aps.org/doi/10.1103/
PhysRevLett.58.86.
[8] U. Wolﬀ, Phys. Rev. Lett. 62, 361 (1989), URL https:
//link.aps.org/doi/10.1103/PhysRevLett.62.361.
[9] N. Prokof’ev and B. Svistunov, Phys. Rev. Lett. 87,
160601 (2001), URL https://link.aps.org/doi/10.
1103/PhysRevLett.87.160601.
[10] N. Kawashima and K. Harada, Journal of the Physical
Society of Japan 73, 1379 (2004), cond-mat/0312675.
[11] W. Bietenholz, A. Pochinsky, and U. J. Wiese, Phys.
Rev. Lett. 75, 4524 (1995), URL https://link.aps.
org/doi/10.1103/PhysRevLett.75.4524.
[12] A. Ramos, PoS LATTICE2012, 193 (2012), 1212.3800.
[13] A. S. Gambhir and K. Orginos, PoS LATTICE2014,
043 (2015), 1506.06118.
[14] G. Cossu, P. Boyle, N. Christ, C. Jung, A. Jttner,
and F. Sanﬁlippo, EPJ Web Conf. 175, 02008 (2018),
1710.07036.
[15] X.-Y. Jin and J. C. Osborn, in Proceedings of Science
(2019), 1904.10039.
[16] M. G. Endres, R. C. Brower, W. Detmold, K. Orginos,
and A. V. Pochinsky, Phys. Rev. D92, 114516 (2015),
1510.04675.
[17] W. Detmold and M. G. Endres, Phys. Rev. D94, 114502
(2016), 1605.09650.
[18] W. Detmold and M. G. Endres, Phys. Rev. D97, 074507
(2018), 1801.06132.
[19] M. Luscher and S. Schaefer, Comput. Phys. Commun.
184, 519 (2013), 1206.2809.
[20] S. Mages, B. C. Toth, S. Borsanyi, Z. Fodor, S. D.
Katz, and K. K. Szabo, Phys. Rev. D95, 094512 (2017),
1512.06804.
[21] Y. Burnier, A. Florio, O. Kaczmarek, and L. Mazur, EPJ
Web Conf. 175, 07004 (2018), 1710.06472.
[22] A. Laio, G. Martinelli, and F. Sanﬁlippo, JHEP 07, 089
(2016), 1508.07270.
[23] A. Tanaka and A. Tomiya (2017), 1712.03893.
[24] P. E. Shanahan, D. Trewartha, and W. Detmold, Phys.
Rev. D97, 094506 (2018), 1801.05784.
[25] L. Huang and L. Wang, Physical Review B 95, 1 (2017),
ISSN 24699969.
[26] J. Liu, Y. Qi, Z. Y. Meng, and L. Fu, Physical Review B
95 (2017), ISSN 24699969.
[27] J. Liu, H. Shen, Y. Qi, Z. Y. Meng, and L. Fu, arXiv
e-prints arXiv:1611.09364 (2016), 1611.09364.
[28] Y. Nagai, H. Shen, Y. Qi, J. Liu, and L. Fu, Physical
Review B 96, 1 (2017), ISSN 24699969.
[29] H. Shen, J. Liu, and L. Fu, Physical Review B 97 (2018),
ISSN 24699969.
[30] S. H. Li and L. Wang, Physical Review Letters 121, 1
(2018), ISSN 10797114.
[31] F. No´e and H. Wu, arXiv e-prints arXiv:1812.01729
(2018), 1812.01729.
[32] J. Song, S. Zhao, and S. Ermon, in Proceedings in Neu-
ral Information Processing Systems 2017 (2017), NIPS,
ISBN 0008-5472 (Print)\r0008-5472 (Linking),
ISSN
13000527, URL http://arxiv.org/abs/1706.07561.
[33] D. Levy, M. D. Hoﬀman, and J. Sohl-Dickstein, arXiv
e-prints arXiv:1711.09268 (2017), 1711.09268.
[34] J. M. Urban and J. M. Pawlowski (2018), 1811.03533.
[35] K. Zhou, G. Endrdi, L.-G. Pang, and H. Stcker, Phys.
Rev. D100, 011501 (2019), 1810.12879.
[36] L. Tierney, Ann. Statist. 22, 1701 (1994), URL https:
//doi.org/10.1214/aos/1176325750.
[37] W. K. Hastings,
Biometrika 57,
97 (1970),
ISSN
00063444,
URL
http://www.jstor.org/stable/
2334940.
[38] D.
J.
Rezende
and
S.
Mohamed,
arXiv
preprint
arXiv:1505.05770 (2015).
[39] L. Dinh, J. Sohl-Dickstein, and S. Bengio (2016), URL
http://arxiv.org/abs/1605.08803.
[40] A. v. d. Oord, Y. Li, I. Babuschkin, K. Simonyan,
O. Vinyals, K. Kavukcuoglu, G. v. d. Driessche, E. Lock-
hart, L. C. Cobo, F. Stimberg, et al. (2017), URL http:
//arxiv.org/abs/1711.10433.
[41] L. Zhang, W. E, and L. Wang, CoRR abs/1809.10188
(2018), 1809.10188, URL http://arxiv.org/abs/1809.
10188.
[42] D. P. Kingma and J. L. Ba, in International Conference
on Learning Representations (ICLR) (2015).
[43] Y. E. Nesterov, Dokl. Akad. Nauk SSSR 269, 543 (1983),
URL https://ci.nii.ac.jp/naid/10029946121/en/.
[44] U.
Wolﬀ
(ALPHA),
Comput.
Phys.
Commun.
156,
143 (2004),
[Erratum:
Comput. Phys. Com-
mun.176,383(2007)], hep-lat/0306017.
[45] I. Vierhaus, Ph.D. thesis, Humboldt University of Berlin
(2010).
[46] V. Nair and G. E. Hinton, in ICML (2010).
[47] U. Wolﬀ, Numerical Simulation in Quantum Field The-
ory (Springer Berlin Heidelberg, Berlin, Heidelberg,
1996),
pp. 245–257,
ISBN 978-3-642-85238-1,
URL
https://doi.org/10.1007/978-3-642-85238-1_14.
[48] S. Duane, A. Kennedy, B. J. Pendleton, and D. Roweth,
Physics
Letters
B
195,
216
(1987),
ISSN
0370-
2693, URL http://www.sciencedirect.com/science/
article/pii/037026938791197X.
[49] J.
Goodman
and
A.
D.
Sokal,
Phys.
Rev.
D
40, 2035 (1989), URL https://link.aps.org/doi/10.
1103/PhysRevD.40.2035.
[50] G.
G.
Batrouni
and
B.
Svetitsky,
Phys.
Rev.
B
36, 5647 (1987), URL https://link.aps.org/doi/10.
1103/PhysRevB.36.5647.
[51] R.
C.
Brower
and
P.
Tamayo,
Phys.
Rev.
Lett.
62, 1087 (1989), URL https://link.aps.org/doi/10.
1103/PhysRevLett.62.1087.
[52] L. Dinh, D. Krueger, and Y. Bengio, 1, 1 (2014), ISSN
1410.8516, URL http://arxiv.org/abs/1410.8516.
[53] D. P. Kingma and P. Dhariwal,
in Neural Infor-

13
mation Processing Systems
(2018),
pp. 1–15,
ISBN
0769501850, ISSN 10059040, URL http://arxiv.org/
abs/1807.03039.
[54] E. Hoogeboom, R. V. D. Berg, and M. Welling (2019),
URL http://arxiv.org/abs/1901.11137.
[55] W.
Grathwohl,
R.
T.
Q.
Chen,
J.
Bettencourt,
I. Sutskever, and D. Duvenaud, in ICLR (2019), pp. 1–
13, ISBN 9783901882760, ISSN 16879139, URL http:
//arxiv.org/abs/1810.01367.
[56] X. Li and W. Grathwohl, pp. 1–7 (2018), URL http:
//bayesiandeeplearning.org/2018/papers/37.pdf.
[57] T. S. Cohen, M. Weiler, B. Kicanaoglu, and M. Welling,
arXiv e-prints arXiv:1902.04615 (2019), 1902.04615.
[58] J.
P.
Valleau
and
D.
N.
Card,
The
Jour-
nal
of
Chemical
Physics
57,
5457
(1972),
https://doi.org/10.1063/1.1678245,
URL
https:
//doi.org/10.1063/1.1678245.

