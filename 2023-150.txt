More Efficient Zero-Knowledge Protocols over Z2k
via Galois Rings
Fuchun Lin, Chaoping Xing, and Yizhou Yao
Shanghai Jiao Tong University
{linfuchun,xingcp,yaoyizhou0620}@sjtu.edu.cn
Abstract. A recent line of works on zero-knowledge (ZK) protocols with
a vector oblivious linear function evaluation (VOLE)-based offline phase
provides a new paradigm for scalable ZK protocols featuring fast proving,
in particular a prover memory footprint almost the same as computing
the circuit in the clear. Very recently, Baum et al. (Crypto’23) proposed
the VOLE-in-the-head technique, allowing such protocols to become
publicly verifiable. Many practically efficient protocols for proving circuit
satisfiability over any field are implemented, while protocols over rings Z2k
are significantly lagging behind, with only a proof-of-concept pioneering
work called Appenzeller to Brie (CCS’21) and a first proposal called
MozZ2karella (Crypto’22). The ring Z232 or Z264, though highly important
(it captures computation in real-life programming and the computer
architectures such as CPU words), presents non-trivial difficulties because,
for example, unlike Galois fields F2k, the fraction of units in rings Z2k is
1/2. In this work, we first construct ZK protocols over a high degree Galois
ring extension of Z2k (fraction of units close to 1) and then convert to
Z2k efficiently using amortization techniques. Our results greatly change
the landscape of ZK protocols over Z2k.
(1) We propose a competing ZK protocol that has many advantages over
the state-of-the-art MozZ2karella: our efficiency is independent of the
security parameter (so increasing superiority as the security parameter
grows); even for concrete 40, 80 bits soundness on 32, 64-bit CPUs, we all
offer savings (up to 3× at best).
(2) Inspired by the recently proposed interactive message authentication
code technique (CCS’22), we construct a constant round VOLE-based
ZK protocol over Z2k with sublinear (in the circuit size) communication
complexity, which was previously achieved only over fields.
(3) We adapt the VOLE-in-the-head technique, and apply it to our first ZK
protocol, yielding the first publicly verifiable non-interactive ZK (NIZK)
over Z2k with linear communication complexity. Also, we show that the
pseudorandom correlation generator (PCG) approach (incompatible with
VOLE-in-the-head) can be adapted to efficiently implement VOLE over
Galois rings, with analysis of the hardness of underlying assumptions.
1
Introduction
A proof system (of knowledge) for circuit satisfiability allows a prover to convince
a verifier that he holds a witness w for a given circuit C such that C(w) = 1.

The proof is zero-knowledge (ZK) if no information about w beyond the fact
that C(w) = 1 is revealed to the verifier. Typically, the circuit C can either be a
Boolean circuit that consists of AND gates and XOR gates, or an arithmetic circuit
that consists of Add gates and Mult gates over some ring R.
Over decades of studies, numerous ZK proof systems have been developed,
which have different properties and also diverse in efficiency metrics (round
complexity, communication complexity, prover/verifier computation complexity,
prover/verifier memory, etc.).
We briefly review ZK proof systems that admit practically efficient ZK proto-
cols for circuit satisfiability, with special emphasis on scalability to large circuits.
The MPC-in-the-head (MPCitH) paradigm [42], offers a publicly verifiable solu-
tion to non-interactive ZK (NIZK), where the prover emulates in his head the
evaluation of the circuit with imaginary parties via a multi-party computation
(MPC) protocol and proves to the verifier that the circuit is honestly evalu-
ated. The bottleneck of MPCitH is either big proof size [42,36,22,44], or small
proof size but large prover time and memory [2]. The garbled circuit [57] ZK
(GCZK) [43,33,58,41] paradigm admits ZK protocols with small prover time and
memory, but large proof size, where the verifier plays the role of garbler (who
garbles the circuit). The interactive oracle proof (IOP)-based ZK proofs admit
zero-knowledge succinct non-interactive arguments of knowledge (zk-SNARK) pro-
tocols [39,18,8,34,9,24,51]. Most zk-SNARKs achieve short proof size and small
verification time simultaneously (assuming a setup). However, many of them re-
quire the prover has sufficient computation power (namely, large prover time and
memory). We remark that very recently, there is a line of works [11,13,55,49,12,38]
focusing on zk-SNARKs with linear prover time 1, as proving time becomes a
bottleneck for large circuits. To our best knowledge, succinctness for both proof
size and verification time can only be achieved when R is a finite field of size
Ω(|C|) [13,55,38], and succinct proof size can be achieved for any field [49,12].
These constructions are still not scalable, due to the large memory requirement.
VOLE-based ZK. The focus of this work is on a new paradigm of active research
usually described as vector oblivious linear function evaluation (VOLE)-based
ZK. The (random) VOLE is a primitive allows the sender to obtain two (random)
vectors M, x and the receiver to obtain a (random) scalar ∆and a (random)
vector K such that K = M + x · ∆over some ring R. In general, VOLE-based
ZK protocols have main advantages of scalable prover memory, linear prover
time, and linear proof size. In a high level, by viewing a ZK proof as a special
case of secure two-party computation (2-PC), where only the prover (sender)
has inputs, each value on the wire is authenticated by a linearly homomorphic
message authentication code (MAC), and the prover proves to the verifier that the
authenticated values satisfy the circuit topology. In more detail, VOLE-based ZK
protocols have two phases, an offline phase that generates random VOLE-based
MACs, and an online phase that securely evaluates the circuit.
1 We say a ZK protocol has linear prover time, if the number of ring operations required
for the prover is linear in the circuit size.
2

Boyle et al. [14,16] initiated the study of VOLE-based ZK, by introducing
a new cryptographic primitive, the pseudorandom correlation generator (PCG).
Generally, PCG is an extension of pseudorandom generator (PRG) from generat-
ing a batch of randomness locally to a batch of correlated randomness between
some parties. PCG offers a lightweight candidate for generating random VOLE
correlations in the offline phase. The authors of [15] presented a two-round mali-
ciously secure construction of PCG for VOLE, and showed that when combining
with a non-interactive online phase, a designated verifier NIZK for circuit satisfi-
ability over arbitrary field can be obtained. The subsequent work Wolverine [53]
constructed an efficient constant round online phase over any field (communicates
4 field elements per multiplication gate), and an efficient interactive PCG con-
struction for VOLE. The work [30] introduced line point zero knowledge (LPZK),
which essentially admits a more efficient online phase over a sufficiently large
field (communicates 1 finite field element per multiplication gate). Concurrent
to Wolverine and LPZK, Mac’n’Cheese [7] proposed two different online phase
protocols that have sublinear communication complexity when used for disjunc-
tion. Follow up works to the above include QuickSilver [56] and then improved
LPZK [29], AntMan [54]. QuickSilver combined the idea of LPZK and Wolverine
to achieve one field element per multiplication gate for arbitrary field (also,
QuickSilver proposed an online phase for proving low degree polynomials with
sublinear communication). Improved LPZK [29] reduced the communication from
1 field element per multiplication gate to 1/2. AntMan [54] proposed an online
phase over arbitrary field with sublinear (in the circuit size) communication, by
employing a novel authentication technique. We refer to a recent survey [6] for the
technical details. Very recently, Baum et al. [5] proposed the VOLE-in-the-head
technique, which compiles a public coin VOLE-based ZK protocol into a publicly
verifiable NIZK, by using a SoftSpokenOT [50] style VOLE construction instead
of a PCG-style VOLE construction. On the other hand, VOLE-in-the-head can
be viewed as an optimization of MPCitH.
ZK over integer rings. As the models of computation in real-life program-
ming and the computer architectures (such as CPU words) are formulated as
operations over the ring Z232 or Z264, ZK protocols over Z2k are more efficient
when implemented. However, the fact that half of the ring Z2k are zero divisors
presents non-trivial technical difficulties. To our best knowledge, there are only
three existing works that constructed ZK protocols over Z2k.
Ganesh et. al [35] proposed Rinocchio by adapting Pinocchio [47], a SNARK
for field arithmetic, to work for ring arithmetic, while other SNARKs seems very
hard to adapt. They introduced the quadratic ring program (QRP) problem and
achieved a designated verifier zk-SNARK with succinct proof size (not succinct
verification) for proving QRP over a general ring R that contains sufficiently
large exceptional sets. When used for Z2k, Rinocchio suffers from a significant
efficiency loss, as exceptional sets of Z2k are small. Following the blueprint of
VOLE-based ZK protocols over finite fields, and also inspired by the idea of
SPDZ2k [25], Baum et.al. proposed two online constructions in Appenzeller to
Brie [3], and later a more efficient online protocol with a PCG construction for
3

VOLE over Z2k in MozZ2karella [4] 2. The main drawback of these constructions,
is that the efficiency has an inherent undesirable dependency on the security
parameter.
Given the width and depth of the theoretical study on ZK protocols over
finite fields, the current state of protocols over rings Z2k leaves too much to be
desired.
1.1
Our Contributions
We introduce more powerful tools (namely, the reverse multiplication friendly
embedding (RMFE) techniques [20,21,26,31]) from the MPC literature into the
literature of VOLE-based ZK. We focus on optimizing the efficiency of VOLE-
based ZK over Z2k, and obtain the following results.
(1) Targeting the state-of-the-art ZK protocol over Z2k, MozZ2karella, we
propose a competing online phase protocol Πm,n,t
ZK
, which is also public coin.
Our protocol has the main advantage that the efficiency is independent on the
security parameter (see Theorem 2). Thus, in all high security region applications,
our protocol has overwhelming advantage over MozZ2karella. We then compare
concrete performance between the two statistical security parameter choices
κ = 40 and κ = 80 over Z232 and Z264 in Table 1, assuming the circuit whose
satisfiability to be proved is a single instruction multiple data (SIMD) circuit.
Table 1: Concrete (online phase) comparison against MozZ2karella. “Comm.”
denotes the communication complexity (counted in bits) per multiplication gate,
and ‘R’ denotes the ring on which the protocol is running. For κ = 40, we use
(16, 45)-RMFEs, while for κ = 80, we use (27, 85)-RMFEs.3
k
κ
MozZ2karella
This work (Πm,n,t
ZK
)
Comm.
R
Comm.
R
32
4
179
Z2130
93
GR(232, 45)
80
302
Z2212
104
GR(232, 85)
64
40
211
Z2162
183
GR(264, 45)
80
334
Z2244
205
GR(264, 85)
(2) Targeting the ZK protocol over fields with sublinear communication
complexity, AntMan, we construct the first VOLE-based ZK protocol Πm,n,t
slZK over
Z2k with the same asymptotic efficiency. We remark that it seems impossible to
achieve similar efficiency by the MozZ2karella approach. For concrete efficiency,
similar to AntMan, we also require a large circuit size (estimated at least 220)
to allow the computational cost of setting up the new authentication coding
2 Appenzeller to Brie adapted the online phases of Wolverine [53] and Mac’n’Cheese
[7], respectively. MozZ2karella adapted the online phase of QuickSilver [56].
3 We select RMFEs over binary field according to [20], and lift to Galois rings via the
approach in [26].
4

scheme to be averaged out. For 40-bit statistical security, we estimate that Πm,n,t
slZK
outperforms Πm,n,t
ZK
when computing a SIMD circuit over Z232 for more than
16 × 12 copies of data 4.
(3) To complement our VOLE-based ZK protocols, we present several efficient
constructions for VOLE over Galois rings. We first present a construction via the
SoftSpokenOT [50] idea, which has fascinating small communication complexity.
And in particular, instantiating the VOLE functionality of our protocol Πm,n,t
ZK
with this construction, allows us to apply the VOLE-in-the-head [5] technique,
then we obtain the first publicly verifiable NIZK over Z2k with linear (in the
circuit size, independent of the security parameter) communication complexity.
To achieve better concrete efficiency (especially smaller computation com-
plexity), we present two constructions following the PCG paradigm. The first
primal-LPN based construction is constant-round, and has generally best perfor-
mance (among the three). The second dual-LPN based construction is two-round,
at the cost of slightly larger computation complexity. In the end, we analyse the
security of LPN over Galois rings. We remark that PCG-style VOLE construc-
tions are incompatible with the VOLE-in-the-head technique, and therefore, one
may do some trade-offs in real-life applications.
1.2
Technical Overview
We sketch how we construct VOLE-based ZK protocols over Z2k. In a high
level, the first step is to adapt existing ZK protocols over Galois field to Galois
ring GR(2k, d). The adaption is straightforward, where we only need to “replace”
the field with GR(2k, d). We remark that VOLE-based ZK protocols over any
field [53,56,54] actually work on a sufficiently large field for security guarantee.
For the Galois ring analogue protocols, the degree d of GR(2k, d) is required to be
sufficiently large accordingly (this is essentially due to Lemma 1).
The second step is to modify the above ZK protocols over GR(2k, d) to efficiently
“simulate” ZK protocols over Z2k. As GR(2k, d) is a ring extension of Z2k, we can
simply view circuits over Z2k as circuits over GR(2k, d), and naively applying ZK
protocols over GR(2k, d). However, working on GR(2k, d) instead of Z2k already
incurs d times overhead (d needs to be linear in the security parameter), and for
malicious security, the prover needs to additionally prove that the witness w are
over Z2k. Our idea for the efficient “simulation” is to use RMFEs.
An RMFE over Z2k consists of two Z2k-linear maps, ϕ : Zm
2k →GR(2k, d),
and ψ : GR(2k, d) →Zm
2k, such that ψ(ϕ(x) · ϕ(y)) = x ∗y, for any x, y ∈Zm
2k,
where m is some positive integer. Intuitively, ϕ “packs” m multiplications over
Z2k to one multiplication over GR(2k, d), and ψ “unpacks” the product over
GR(2k, d). Since ϕ, ψ are Z2k-linear maps, m evaluations of a circuit C over Z2k
can be simultaneously emulated by GR(2k, d) operations, through applying ϕ, ψ
iteratively. Existing works [20,21,1,31] that applied RMFEs in MPC, have paid
4 This estimation uses an estimation of the additively homomorphic encryption (AHE)
ciphertext size c < 8920 bits.
5

great efforts to guarantee that ϕ, ψ are applied honestly (to achieve malicious
security).
Observing that in the ZK for proving circuit satisfiability setting, the prover
(of the ZK protocol over GR(2k, d)) can compute all values on the wires of the
circuit C over Z2k on his own, ϕ, ψ only need to be invoked for one time (after all
values of the circuit C over Z2k are computed). Thus, for malicious security, the
prover needs to additionally prove to the verifier that he follows RMFE encoding
honestly. Our main innovation of this paper is a novel mechanism that solves the
above issue efficiently.
Our re-embedding technique. Let τ = ϕ ◦ψ and [x] denote that x ∈GR(2k, d)
is authenticated by a linearly homomorphic MAC. In the ZK setting, the problem
can be reduced to prove that for a given [x], x belongs to the image of ϕ, denoted
by x ∈Im(ϕ). Recall that the offline phase produces MACs for random values.
Given [µ], µ
$←GR(2k, d), [x] is obtained by the prover sending d := x −µ to
the verifier ([x] := [µ] + d by additive homomorphism). According to RMFE
properties presented in Section 2, we observe that
x = µ + d =⇒τ(x) = τ(µ + d) = τ(µ) + τ(d),
and
x = τ(x) ⇐⇒µ + d = τ(µ) + τ(d) ⇐⇒d −τ(d) = τ(µ) −µ.
Note that for any x ∈GR(2k, d), τ(x) ∈Im(ϕ) by definition, and assuming
ϕ(1) = 1, we have x ∈Im(ϕ) ⇐⇒x = τ(x) (Lemma 3). From above observations,
we let τ(µ) −µ be revealed to the verifier (in the offline phase), and in the online
phase, the verifier can check d −τ(d) = τ(µ) −µ upon receiving d. If the check
passes, [τ(x)] can be computed by [τ(µ)] + τ(d) = [µ] + d. In some sense, [x]
is “re-embedded” into [τ(x)]. Thus, we name it by re-embedding technique. We
formulate the ideal functionality required for the offline phase as the re-embedding
VOLE (embVOLE), and provide an efficient construction from sacrifice. We
remark that our re-embedding technique also plays a crucial role in checking
multiplications when constructing our first ZK protocol Πm,n,t
ZK
.
ZK with a sublinear online phase. For our second sublinear ZK protocol
Πm,n,t
slZK , we compile with an online phase adapted from AntMan [54]. Consider
an SIMD circuit with m = m1 × m2 copies of data over Z2k. We first use
RMFEs to map m1 copies of data over Z2k into one copy of data over GR(2k, d).
Then we apply the information-theoretic polynomial authentication code (IT-
PAC) amortisation technique proposed in AntMan that operates on a batch of
m2 elements in GR(2k, d). We remark that the use of RMFEs in fact incurs a
constant (d/m1 > 1) communication overhead, while the sublinear communication
complexity is due to IT-PACs. Therefore, in practice we select (m1, d)-RMFEs
with
d
m1 as small as possible (m2 as large as possible) under the premise of
GR(2k, d) being sufficiently large to satisfy the security requirement. In a high
level, an IT-PAC authenticates a polynomial, which is determined by m2 elements
in GR(2k, d) via Lagrange interpolation (namely, an IT-PAC authenticates m2
elements simultaneously). We note here that IT-PACs are incompatible with the
6

MozZ2karella [4] approach, since the maximum size of exceptional sets of Z2k+s is
only 2, on which MozZ2karella is working. Tricks of reducing computing a generic
circuit to computing an SIMD circuit are proposed in [54] that we postpone to
the end of Section 3. We quickly point out some possible disadvantages (without
dwelling on them) of the IT-PAC. The interactive generation of IT-PAC increases
the computation complexity considerably and moreover it is not public coin.
Instantiations of VOLE over GR(2k, d). The online phases of our ZK protocols
require a single VOLE correlation of sufficiently large length. To speed-up the
offline phase, we present three constructions for VOLE over GR(2k, d). Comparing
to the primal-LPN based construction for VOLE over Z2k [4] (i.e. the offline phase
of MozZ2karella), our constructions have advantages in the following aspects.
(1) The algebraic structure of Galois rings makes it natural to seamlessly gen-
eralize different VOLE protocols over Galois fields to VOLE protocols over Galois
rings with all their different features well-preserved. We include generalizations
of the three most representative constructions of VOLE, a SoftSpokenOT-style
one, a primal-LPN based one, and a dual-LPN based one. We remark that there
might exist a SoftSpokenOT-style construction for VOLE over Z2k, while it is
unclear how to construct a dual-LPN based variant with similar performance.
(2) The underlying LPN assumptions over GR(2k, d) (of the latter two con-
structions) are more secure than that of MozZ2karella. We show a reduction
relating to LPN over the field F2d, by generalizing the approach of [46]. A similar
reduction severely affects the security of an earlier version of MozZ2karella as
reported in [46] and, to evade this attack, each non-zero entry of the LPN error
vector should be invertible in Z2k. Moreover, as indicated in MozZ2karella, they
have to carefully select LPN parameters to mitigate the effect of a leakage that
the adversary can learn c noise entries with probability 1/2c.
2
Preliminaries
Notations. In this paper, bold letters (e.g. a, b) are used to denote vectors.
Besides, we use xi to denote the ith-component of the vector x. We use [a, b]
(or [a, b + 1) sometimes) to denote the set of integers in the range from a to
b, if a = 1, it is simplified by [b], which is not to be confused with the MAC
notation. We also use x[a : b] to denote the set {xi | i ∈[a, b]}. We use x
$←R
to denote that x is uniformly sampled from a ring R and denote the uniform
distribution over R by UR. For a map ϕ : R1 →R2, we naturally extend it to
be defined over vector space Rn
1 and matrix space Rm×n
1
. Let Im(ϕ) denote the
set {ϕ(x) | x ∈R1} and Ker(ϕ) denote the set {x ∈R1 | ϕ(x) = 0}.
Galois Rings. Let p be a prime, and k, d ≥1 be integers. Let f(X) ∈Zpk[X]
be a monic polynomial of degree d such that f(X) := f(X) mod p is irreducible
over Fp. Denote the Galois ring over Zpk of degree d by GR(pk, d), which is a
ring extension Zpk[X]/(f(X)) of Zpk. The readers may refer to [52] for a friendly
exposition.
We emphasize that Galois rings have a special algebraic structure that, every
element a of GR(pk, d) can be uniquely written as a0 + a1 · p + . . . + ak−1 · pk−1,
7

where ai ∈Fpd, i ∈[0, k). Moreover, zero divisors of GR(pk, d) are of the form
a1 · p + . . . + ak−1 · pk−1, for all ai ∈Fpd, i ∈[k −1]. Therefore, 1/pd fraction
of elements are zero divisors in GR(pk, d), or equivalently, (1 −1/pd) fraction
of elements are invertible. For polynomials over Galois rings, there is an upper
bound on the number of roots.
Lemma 1 ([31]). A nonzero degree-r polynomial over GR(pk, d) has at most
rp(k−1)d roots.
Lemma 1 immediately implies that for any nonzero degree-r polynomial f(x)
over GR(pk, d), we have that Pr
h
f(α) = 0
 α
$←GR(pk, d)
i
≤rp−d.
Reverse Multiplicative Friendly Embedding. Reverse Multiplicative Friendly
Embedding (RMFE) was first introduced by Cascudo et al. [20], which allows
packing multiple multiplications over a field Fq to one multiplication over an
extension field Fqd. It was further showed by Cramer et al. [26] that RMFEs over
finite fields can be lifted to Galois rings. We first recall the definition of RMFE,
and then present some of its important properties.
Definition 1 (RMFE [26]).
Let p be a prime, k, r, m, d ≥1 be integers. A
pair (ϕ, ψ) is called an (m, d)-RMFE over GR(pk, r) if ϕ : GR(pk, r)m →GR(pk, rd)
and ψ : GR(pk, rd) →GR(pk, r)m are two GR(pk, r)-linear maps such that
x ∗y = ψ
 ϕ(x) · ϕ(y)

(1)
for all x, y ∈GR(pk, r)m. Here ∗denotes component-wise product of vectors.
From Definition 1, if (ϕ, ψ) is an RMFE, then ϕ is injective while ψ is surjective.
Therefore, it is necessary for m less than or equal to d. The following lemma
shows the existence of RMFE with a constant ratio m
d .
Lemma 2 (Existence of RMFE [20,26]). There exists a family of (m, d)-
RMFEs over Galois ring GR(pk, r) with d = O(m).
Given an (m, d)-RMFE (ϕ, ψ), we can always assume that ϕ(1) = 1. First, we
show ϕ(1) is invertible in GR(pk, rd) by contradiction. Assume ϕ(1) is a zero divisor
and hence pk−1 · ϕ(1) = 0. Due to the linearity of ϕ, we also have pk−1 · ϕ(1) =
ϕ(pk−1 · 1). This implies that pk−1 · 1 is another preimage of 0, which makes a
contradiction since ϕ is injective. Then, define ϕ′ : GR(pk, r)m →GR(pk, rd) as
ϕ′(a) := ϕ(a) · ϕ(1)−1 and ψ′ : GR(pk, rd) →GR(pk, r)m as ψ′(b) := ψ(b · ϕ(1)). It
is straightforward to verify that (ϕ′, ψ′) is an (m, d)-RMFE with ϕ′(1) = 1. From
now on, we assume ϕ(1) = 1 without explicitly mentioning it.
Lemma 3. Let (ϕ, ψ) be an (m, d)-RMFE over Galois ring GR(pk, r), then
GR(pk, rd) = Im(ϕ) ⊕Ker(ψ).
Proof. As ϕ is injective and ψ is surjective, ψ induces a bijection from the set
Im(ϕ) to GR(pk, r)m since ψ(ϕ(x)) = ψ(ϕ(x) · ϕ(1)) = x ∗1 = x. Together with
the fact that ψ : GR(pk, rd) →GR(pk, r)m is a GR(pk, r)-linear map, we have
GR(pk, rd) = Im(ϕ) ⊕Ker(ψ).
⊓⊔
8

We also define the “re-embed” map τ = ϕ ◦ψ : GR(pk, r) →GR(pk, r). Looking
ahead, Lemma 3 is critical for our ZK protocols.
In this manuscript, we mainly consider RMFEs with r = 1 and p = 2, i.e.,
a family of (m, d)-RMFEs over Z2k. As showed in [20], such families of RMFEs
exist with limm→∞d
m = 4.92.
VOLE and MAC. (Random) vector oblivious linear function evaluation (VOLE)
is a functionality that allows two parties PS, PR to obtain random correlated
values. In more detail, the sender PS obtains two vectors M, x, while the receiver
PR obtains a scalar ∆and a vector K such that K = M + x · ∆. We formalize
the ideal functionality of VOLE over Galois ring GR(2k, d) in Fig. 1.
The above VOLE correlation can be viewed as Message Authentication Codes
(MACs) that authenticate x, denoted by [x]. We then call M the MAC tags, K
the local keys and ∆the global key. It is easy to see that such MAC is linearly
homomorphic. Given authenticated values [x1], . . . , [xl] and public coefficients
c, c1, . . . , cl ∈GR(pk, d), the two parties can locally compute [y] = c+P
i∈[l] ci·[xi]
by setting y = c+P
i∈[l] ci ·xi, My = P
i∈[l] Mxi, and Ky = ∆·c+P
i∈[l] ci ·Kxi.
In particular, we have [y] = [x] + (y −x). Then given [x] for a random x, the two
parties can obtain [y] by having PS send y −x to PR.
Functionality F GR(2k,d)
VOLE
Init: Upon receiving (Init) from both parties, sample ∆
$←GR(2k, d) if PR is
honest, and receive ∆∈GR(2k, d) from the adversary A otherwise. Store ∆and
send it to PR. All further (Init) commands will be ignored.
Extend: Upon receiving (Extend, n) from both parties, proceed as follows:
1. If PR is honest, sample K
$←GR(2k, d)n. Otherwise receive K from A.
2. If PS is honest, sample x
$←GR(2k, d)n and compute M := K−∆·x ∈GR(2k, d)n.
Otherwise, receive x ∈GR(2k, d)n and M ∈GR(2k, d)n from A and then
recompute K := M + ∆· x.
3. Send (x, M) to PS and K to PR.
Fig. 1: Ideal functionality for VOLE over GR(2k, d).
Security Model and Functionalities. We prove the security of our protocols
in the universal composability (UC) framework [19]. In particular, we consider
active adversary and static corruption. We refer to Appendix A for a friendly
exposition. The goal of this work is to design secure zero-knowledge protocols
realizing functionality Fm
ZK, which allows a prover to prove knowledge of m
witnesses satisfying the same circuit C. Details of Fm
ZK are in Fig. 2. In particular,
we say an interactive ZK protocol is public coin, if each message (from the verifier)
sent to the prover is a random string.
9

Functionality F m
ZK
Upon receiving (prove, C, w(1), . . . , w(m)) from a prover P and (verify, C) from a
verifier V, where the same circuit C is input by both parties, send (true) to V if
C(w(j)) = 1 for all j ∈[m] and (false) otherwise.
Fig. 2: Functionality for zero-knowledge proofs for circuit satisfiability.
We also require some fundamental functionalities for our VOLE constructions,
e.g., the equality test functionality (FEQ, Figure 12), which allows two parties
P and V to check their inputs are equivalent with P’s input revealed to V, the
oblivious transfer functionality (FOT, Figure 13), which receives a bit from PS
and two strings from PR, and then sends one of the strings to PS according to
the choice bit 5.
3
Zero-Knowledge Protocols over Z2k
Inspired by the methodology of [31], where the authors constructed efficient
dishonest majority MPC over Z2k by first giving an MPC over GR(2k, d) and
then converting it to work over Z2k, we introduce RMFEs into the context of
VOLE-based ZK protocols, and develop novel, highly efficient techniques.
To obtain efficient zero-knowledge protocols over Z2k, we first introduce a
new functionality FGR(2k,d)
embVOLE and present a construction that UC-realizes it in the
(FGR(2k,d)
VOLE , FEQ)-hybrid model. Next we show how to construct ZK protocols over
Z2k basing on our FGR(2k,d)
embVOLE functionality. In Section 3.2, we present a public
coin ZK protocol over Z2k and in Section 3.3, we construct a ZK protocol over
Z2k with communication complexity sublinear in the circuit size.
3.1
Re-embedding VOLE over GR(2k, d)
Jumping ahead, to construct ZK protocols over Z2k, our first step is to construct
ZK protocols over GR(2k, d). Following the blueprint of ZK protocols over the
Galois fields, e.g., [53,30,56], this step is quite straightforward. The key observation
is that the soundness error of these protocols is related to the fraction of units of
the underlying ring. For example, the ZK protocol over Fq in QuickSilver [56] has
soundness error O(1/q). By Lemma 1, realizing a Galois ring GR(2k, d) analogue
ZK of QuickSilver induces soundness error O
 1/2d
, which can be set negligible
in the security parameter κ by choosing a sufficiently large parameter d.
The main obstacle lies in the second step, where we need to do the conversion.
A naive conversion is to run the above ZK protocol over GR(2k, d) by treating
each element in Z2k as an element in GR(2k, d). However, this already incurs
5 We remark that roles are reversed, compared to the standard OT definition.
10

O(κ) overhead for a negligible soundness error, needless to say that, the prover
is additionally required to prove that his inputs (i.e. the witness) are over Z2k.
In fact, the above naive conversion uses the naive embedding Z2k ,→GR(2k, d),
which can be viewed as an inefficient RMFE over Z2k in some sense. Therefore,
we instead use efficient (m, d)-RMFEs over Z2k to accomplish the conversion,
where the ratio d/m is asymptotically constant.
Let ϕ : Zm
2k →GR(2k, d) and ψ : GR(2k, d) →Zm
2k be an (m, d)-RMFE pair
over Z2k. There are two issues that we have to overcome, when we use RMFEs.
The first thing is that the prover is additionally required to prove that his inputs
(i.e. the witness) are over Im(ϕ) (as opposed to Z2k in the naive embedding case).
The second thing is to guarantee the honest circuit evaluation, since (ϕ, ψ) only
preserves one time multiplication by definition, unlike the naive embedding which
has infinite multiplication capacity.
Functionality F GR(2k,d)
embVOLE
F GR(2k,d)
embVOLE extends the existing VOLE functionality F GR(2k,d)
VOLE
(Figure 1). Init and
Extend are identical to those in F GR(2k,d)
VOLE
, respectively. Let (ϕ, ψ) be an (m, d)-
RMFE pair over Z2k, and τ := ϕ ◦ψ.
Extend-pair: Upon receiving (Extend-pair, n) from both parties, proceed as
follows:
1. If PS is honest, sample x, M
$←GR(2k, d)n; otherwise, receive x, M ∈GR(2k, d)n
from A. Compute η := τ(x) −x ∈Ker(ψ)n and send η to PR.
2. If PR is honest, compute K := M + ∆· x ∈GR(2k, d)n; otherwise, receive
K ∈GR(2k, d)n from A and recompute M := K −∆· x.
3. Send (x, M) to PS and (K, η) to PR.
Fig. 3: Ideal functionality for re-embedding VOLE over GR(2k, d).
To solve the above issues, we propose a novel, highly efficient technique, the
re-embedding VOLE. We show how re-embedding VOLE solves the first issue, and
defer the solution to the second issue to Section 3.2. Our key observation is that
GR(2k, d) is the direct sum of Im(ϕ) and Ker(ψ) (Lemma 3), and the inputs over
Z2k one-to-one correspond to a vector over Im(ϕ) (we use ϕ to map m witnesses
to a vector over GR(2k, d)). Thus, we can allow the projection of x on Ker(ψ)
(i.e., x −τ(x), where τ := ϕ ◦ψ : GR(2k, d) →GR(2k, d) is a Z2k-linear map as
well) to be revealed to the verifier V. Recall that VOLE can be viewed as linearly
homomorphic MACs, this enables the two parties to obtain the re-embedding
pair MACs of x, namely, ([x], [τ(x)]).
We define the re-embedding VOLE functionality FGR(2k,d)
embVOLE in Figure 3, which
essentially allows the two parties to obtain random ([µ], [τ(µ)]) through revealing
11

τ(µ) −µ to the receiver. Now we show that building upon FGR(2k,d)
embVOLE, the two
parties can obtain [x], where x is destined to be over Im(ϕ). Given ([µ], [τ(µ)])
(by FGR(2k,d)
embVOLE), where µ
$←GR(2k, d)n, the prover sends δ = x −µ to the verifier,
the verifier can check
δ −τ(δ) = τ(µ) −µ,
(2)
which is equivalent to check
(x −µ) −τ(x −µ) = τ(µ) −µ ⇐⇒x −τ(x) = 0 ⇐⇒x ∈Im(ϕ)n.
Therefore, if the above equation (2) holds, [x] computed by [µ] + δ are MACs
for elements in Im(ϕ), as desired.
Protocol ΠGR(2k,d)
embVOLE
Init: Both parties send Init to F GR(2k,d)
VOLE
, which returns ∆∈GR(2k, d) to PR.
Extend-pair: To generate n authenticated re-embedding pairs, both parties
proceed as follows:
1. Construct:
(a) Both parties send (Extend, n + s) to F GR(2k,d)
VOLE
. PS receives M, x ∈
GR(2k, d)n+s, and PR receives K ∈GR(2k, d)n+s, such that K = M + x · ∆
holds. Thus, the parties now obtain [xi], i ∈[n + s].
(b) PS computes η := τ(x) −x, then sends η ∈Ker(ψ)n+s to PR. If η /∈
Ker(ψ)n+s, PR aborts.
(c) PS sets M′ := M, and PR sets K′ := K+∆·η. Note that K′ = M′+τ(x)·∆
holds, so the parties now obtain [τ(xi)], i ∈[n + s].
2. Sacrifice:
(a) PR samples χ(1), ..., χ(s)
$←Zn
2k, and sends them to PS.
(b) For i ∈[s], PS computes ai = xn+i + P
j∈[n] χ(i)
j
· xj and bi = τ(xn+i) +
P
j∈[n] χ(i)
j
· τ(xj). PS sends a, b to PR. PS computes ˆ
Mi := Mn+i +
P
j∈[n] χ(i)
j
· Mj, for i ∈[s].
(c) PR checks bi−ai = ηn+i+P
j∈[n] χ(i)
j ·ηj, for i ∈[s] and b ∈Im(ϕ)s. If the
check fails, PR aborts. PR computes ˆ
M′
i := Kn+i +P
j∈[n] χ(i)
j ·Kj −ai ·∆,
for i ∈[s].
(d) PS sends ˆ
M to PR. PR checks whether ˆ
M = ˆ
M′, and aborts if the check
fails.
3. Output: Output ([xi], [τ(xi)]) for i ∈[n].
Fig. 4: Protocol for authenticating re-embedding pairs over GR(2k, d) in the
FGR(2k,d)
VOLE -hybrid model.
To construct a secure re-embedding VOLE protocol, We let the two parties
generate n + s re-embedding pair MACs and sacrifice the extra s re-embedding
12

pair MACs. The sacrifice is done by taking s random Z2k-linear combinations of
n remaining re-embedding pair MACs to obtain s equations, with each masked
with an extra re-embedding pair MAC. If there is at least one of the remaining n
re-embedding pair MACs that is not honestly generated, the correctness check
will fail, except with probability at most 2−s + 2−d, which can be negligible in
the security parameter κ by setting s, d large enough (e.g. s = d = κ + 1). We
give the protocol ΠGR(2k,d)
embVOLE in Figure 4, and we have the following theorem
with proof deferred to Appendix C.1. To obtain n re-embedding pair MACs, our
construction consumes a VOLE correlation of length (n + s), and communicates
(n + 3s) Galois ring elements and ns coefficients over Z2k, or equivalently, on
average (1 + 3s/n + s/d) Galois ring elements. As n is sufficiently large for most
ZK applications, the overhead for constructing re-embedding pairs is close to a
small constant.
Theorem 1. ΠGR(2k,d)
embVOLE UC-realizes FGR(2k,d)
embVOLE in the FGR(2k,d)
VOLE
-hybrid model. In
particular, no PPT environment Z can distinguish the real world execution from
the ideal world simulation except with advantage at most 2−s + 2−d.
3.2
Public coin Zero-Knowledge Protocol over Z2k
Equipped with our re-embedding VOLE technique and inspired by QuickSil-
ver [56], we construct a highly efficient public coin ZK protocol over Z2k.
Suppose the prover P and the verifier V have agreed on an SIMD circuit
C over Z2k with n inputs and t multiplication gates, and P has m witnesses.
By calling FGR(2k,d)
embVOLE, they can obtain n + t re-embedding pair MACs for µ
$←
GR(2k, d)n and ν
$←GR(2k, d)t, and a MAC [π], where π
$←GR(2k, d). P then
computes ω := ϕ(w(1), ..., w(m)), and sends δ := ω −µ to V. They can obtain
[τ(ω)] := [τ(µ)] + τ(δ). Recall that if ω ∈Im(ϕ)n, we have that τ(ω) = ω and
δ −τ(δ) = τ(µ) −µ should hold. Next, the two parties are going to evaluate the
circuit in a topological order. For Add gates, the MAC of the output wire can be
computed locally.
However, for Mul gates, we face a problem as mentioned in Section 3.1, that
RMFEs can only preserve one multiplication. One good news is that in the
ZK setting, the prover P can compute all values in the circuit on his own (as
he holds the witness of the circuit). Therefore, the output MAC of a Mul gate
can be obtained by consuming one random MAC. The bad thing is that all
authenticated values in the circuit should be in Im(ϕ), but the multiplication
equality no longer holds! More specifically, for the i-th multiplication gate in C with
inputs ωα, ωβ ∈Im(ϕ) and output ωγ ∈Im(ϕ), we have ψ(ωα) ∗ψ(ωβ) = ψ(ωγ),
which is not equivalent to ωα · ωβ = ωγ. The former equation is not easy to
verify since values are evaluated over GR(2k, d) rather than Z2k. We show that
this issue can be bypassed by our re-embedding VOLE. Given ([νi], [τ(νi)]) (by
FGR(2k,d)
embVOLE), P sends di to V, which is supposed to equal ωα · ωβ −νi if P is
honest, then they can obtain [ωγ] := [τ(ωα·ωβ)] = [τ(νi)]+τ(di). We remark that
ωγ = τ(ωα · ωβ) ⇐⇒ψ(ωγ) = ψ(ωα) ∗ψ(ωβ), as we always assume ϕ(1) = 1. To
13

verify that each di is computed honestly, the two parties additionally compute
[ˆωγ] := [ωα · ωβ] = [νi] + di. One can observe that
Bi : = Kωα · Kωβ −Kˆωγ · ∆
= (Mωα + ∆· ωα) · (Mωβ + ∆· ωα) −(Mˆωγ + (ωα · ωβ) · ∆) · ∆
= (Mωα · Mωβ) + (ωα · Mωβ + ωβ · Mωα −Mˆωγ) · ∆
holds if di is correct. Therefore, it can be used to detect malicious behaviors by
letting P send A0,i := Mωα · Mωβ, A1,i := ωα · Mωβ + ωβ · Mωα −Mˆωγ to V.
In a high level, we check multiplications for ˆωγ, and automatically re-embed ˆωγ
to ωγ = τ(ˆωγ) via re-embedding VOLE. Moreover, we can use a random linear
combination technique to check all t equations simultaneously. Briefly, V sends
uniformly random coefficients {χi ∈GR(2k, d)}i∈[t] to P, and P returns to V the
linear combination of {A0,i, A1,i}i∈[t] masked with Mπ, π, respectively. In fact,
as GR(2k, d) contains a subfield F2d, χ can be sampled from Ft
2d (intuitively, the
entropy of χ is still sufficient).
Finally, for the output wire ωh, if both parties follow the protocol honestly,
the equation Kωh = Mωh + ϕ(1) · ∆should hold. Thus, we let P open [ωh] by
sending Mωh to V. We have the following theorem, with security proof deferred
to Appendix C.2.
Theorem 2. Protocol Πm,n,t
ZK
communicates (kd + d)/m bits per multiplication
gate, and UC-realizes Fm
ZK in the FGR(2k,d)
embVOLE-hybrid model with soundness error
2−(d−2) and information-theoretic security.
Our protocol Πm,n,t
ZK
transfers one GR(2k, d) element and one random coefficient
over F2d per multiplication gate, yielding amortized communication complexity
of (kd + d)/m-bit, which is independent of the statistical security parameter κ
as d/m is constant. Note that both in Πm,n,t
ZK
, ΠGR(2k,d)
embVOLE, the verifier (receiver)
only sends random strings to the prover (sender). Thus, we obtain a public coin
ZK protocol over Z2k in the VOLE-hybrid model, which allows us to construct a
publicly verifiable NIZK over Z2k in Section 4.1.
3.3
Sublinear Zero-Knowledge Protocol over Z2k
Achieving succinctness is always a fascinating challenge of constructing ZK
protocols. For proving circuit satisfiability over finite fields, there are plenty of
practical candidates (e.g. zk-SNARKs [9,24,51]). However, it is extremely hard
to adapt such ZK protocols to work efficiently over integer rings in general.
In this section, we focus on succinct proof size (i.e., sublinear communication
complexity). Note that our protocol Πm,n,t
ZK
has linear communication complexity.
We are initially inspired by AntMan [54], which constructed interactive ZK for
any field with sublinear communication complexity via developing a new, powerful
technique, the Polynomial Authentication Code (PAC).
We sketch how we construct sublinear ZK over Z2k. Our starting point is
the sublinear ZK protocol of AntMan [54]. Similar to Section 3.2, we follow the
14

Protocol Πm,n,t
ZK
The prover P and the verifier V have agreed on a circuit C over Z2k with n
inputs and t multiplication gates, and P holds m witnesses w(i) ∈Zn
2k such that
C(w(i)) = 1, i ∈[m].
Offline phase
1. P and V send (Init) to F GR(2k,d)
embVOLE, and V receives ∆∈GR(2k, d).
2. P and V send (Extend-pair, n + t) to F GR(2k,d)
embVOLE, which returns authenticated
pairs ([µi], [τ(µi)])i∈[n], ([νj], [τ(νj)])j∈[t], where all µi, νj are sampled uni-
formly at random in GR(2k, d). Note that V also learns τ(µ) −µ and τ(ν) −ν
from F GR(2k,d)
embVOLE.
3. P and V send (Extend, 1) to F GR(2k,d)
embVOLE, which returns authenticated value [π],
where π is sampled uniformly at random in GR(2k, d).
Online phase
1. For input W = (w(1), w(2), ..., w(m)) ∈Zn×m
2k
, P computes ω := ϕ(W), and
sends δi := ωi −µi, i ∈[n] to V. V checks whether δ −τ(δ) = τ(µ) −µ
holds. If the check fails, aborts. Both parties can locally compute [τ(ωi)] :=
[τ(µi)] + τ(δi).
2. For each gate (α, β, γ, T) ∈C, in a topological order:
– If T=Add, then P and V locally compute [ωγ] := [ωα] + [ωβ].
– If T=Mul and this is the i-th multiplication gate, then P sends di :=
ωα · ωβ −νi to V, and both parties locally compute [ωγ] := [τ(νi)] + τ(di),
and [ˆωγ] := [νi] + di.
3. For the i-th multiplication gate, the parties hold ([ωα], [ωβ], [ˆωγ]) with Kωj =
Mωj + ωj · ∆for j ∈{α, β}, and Kˆωγ = Mˆωγ + ˆωγ · ∆.
– P computes A0,i := Mωα · Mωβ ∈GR(2k, d) and A1,i := ωα · Mωβ + ωβ ·
Mωα −Mˆωγ ∈GR(2k, d).
– V computes Bi := Kωα · Kωβ −Kˆωγ · ∆∈GR(2k, d).
4. P and V do the following check.
(a) P sets A∗
0 := Mπ, A∗
1 := π, and V sets B∗:= Kπ so that B∗= A∗
0 +A∗
1 ·∆.
(b) V draws a uniformly random χ from Ft
2d and sends it to P.
(c) P computes X := P
i∈[t] χi · A0,i + A∗
0 ∈GR(2k, d) and Y := P
i∈[t] χi ·
A1,i + A∗
1 ∈GR(2k, d), and sends (X, Y ) to V.
(d) V computes Z := P
i∈[t] χi · Bi + B∗∈GR(2k, d), and checks whether
Z = X + Y · ∆holds. If the check fails, V outputs false and aborts.
5. For the single output wire ωh, both parties hold [ωh].
– P sends Mωh to V.
– V checks whether Kωh = Mωh + ϕ(1) · ∆. If the check fails, V outputs
false. Otherwise, V outputs true.
Fig. 5: Zero-knowledge protocol for circuit satisfiability over Z2k in the FGR(2k,d)
embVOLE-
hybrid model.
15

methodology that first constructing a sublinear ZK protocol over GR(2k, d), and
then converting it to a ZK protocol over Z2k via RMFEs. The first step involves
adapting PAC to work over Galois rings, and for the conversion step, we crucially
rely on our re-embedding technique as well.
The PAC is essentially an information-theoretic polynomial commitment,
which allows to authenticate a polynomial. In more detail, PAC is a generalization
of VOLE-based MAC, where the sender PS holds a MAC tag M ∈GR(2k, d), and
a polynomial f(·) ∈GR(2k, d)[X], while the receiver PR holds a polynomial key
Λ ∈GR(2k, d), a global key ∆∈GR(2k, d), and a local key K ∈GR(2k, d) such that
K = M + f(Λ) · ∆. We remark that the PAC for f(·), denoted by [[f(·)]], can be
viewed as a MAC for f(Λ). On the other hand, a PAC also authenticates a batch
of values, simultaneously. This relies on the fact that a batch of (say, m2) values
over GR(2k, d) uniquely determine a polynomial f(·) ∈GR(2k, d)[X] (of degree
less than m2) via Lagrange interpolation, as long as the evaluation points are
picked appropriately (i.e., in some exceptional set of GR(2k, d)). Intuitively, PAC
significantly reduces the communication complexity in the sense that turning m2
MACs into one MAC [f(Λ)].
In a high level, our protocol starts with the prover P (as PAC sender) and
the verifier V (as PAC receiver) obtaining PACs for the SIMD witnesses, then
they evaluate the circuit using these PACs, and finally P opens the output PAC
to V. Thus, to guarantee malicious security, V should be convinced that the
PACs for inputs are corresponding to the witnesses, and the circuit evaluation is
done correctly. We next briefly summarize how the protocol works, with special
emphasis on how the RMFE and PAC amortisation techniques collaborate.
Suppose that P and V have agreed on a SIMD circuit C over Z2k with n inputs
and t multiplication gates, and P holds m = m1m2 witnesses. Let (ϕ, ψ) be an
(m1, d)-RMFE pair over Z2k and T = {0, 1, ζ, ..., ζ2d−2}, where ζ ∈GR(2k, d) is of
order 2d −1. Now P uses ϕ to map m1m2 witnesses over Z2k to m2 vectors over
GR(2k, d), and the two parties first authenticate these values via VOLE based
MACs. Similar to that in our protocol Πm,n,t
ZK
, we use re-embedding pair MACs
to guarantee that the authenticated values are in the image of ϕ. Next, the two
parties generate the corresponding PACs. We follow the interactive approach
of AntMan [54] that generates a batch of PACs over Galois fields, using an
additively homomorphic encryption (AHE) scheme. For the Galois ring case,
we can instead use the AHE scheme of MHz2k [23]. The sub-protocol ΠPAC
for generating PAC is presented in Figure 19 due to limited space. Then, the
two parties can locally evaluate Add gates in the circuit. For the j-th Mul gate
with input polynomials ua(·), ub(·), P and V generates two PACs [[ˆvj(·)]] and
[[vj(·)]], where ˆvj := ua(·) · ub(·) with degree 2m2 −2 and vj(·) with degree m2 −1
is “τ-consistent” to ˆvj(·), i.e. vj(αi) = τ(ˆvj(αi)), for some fixed points αi ∈T,
i ∈[m2]. After the circuit evaluation is completed, P and V do a series of checks.
(1) The first check is for the τ-consistency. We remark that the τ-consistency
of our protocol Πm,n,t
ZK
is guaranteed for free due to the use of re-embedding VOLE.
However, now the τ-consistency is defined between two polynomials (rather than
two elements). Therefore, we need to find another method. Fortunately, it can
16

be observed that the BatchCheck procedure of AntMan [54], which is originally
used to check vj(αi) = ˆvj(αi) in a batch, can be directly adapted to check
τ-consistency. For a better illustration, we briefly explain how our BatchCheck
procedure works.
Recall that τ = ϕ ◦ψ is a Z2k-linear map. Thus, V can check by P opening
random Z2k-linear combinations of the two sets of polynomials. To avoid potential
information leakage from linear combinations, we mask the opened polynomials
with a pair of random polynomials that satisfy the degree constraint and τ-
consistency. Besides, V should be convinced that the opened polynomials are
consistent to their PACs. It can be observed that the polynomial key Λ can be
revealed to P, after all polynomials needed to be authenticated are authenticated.
Then the PACs are turned into MACs for the polynomial evaluations on Λ
naturally, and V can check this by P opening the MACs.
Procedure BatchCheck
Let T be the set {0, 1, ζ, ..., ζ2d−2}, where ζ ∈GR(2k, d) is of order 2d −1. Let
d1, d2, m, l be parameters. Let {α1, ..., αm} and {β1, ..., βm} be two public subsets
of T. Let H : {0, 1}κ →Zl
2k be a random oracle.
Inputs: P and V have the following inputs: two sets of PACs {[[f1(·)]], ..., [[fl(·)]]}
and {[[g1(·)]], ..., [[gl(·)]]}, where fi(·) is a degree ≤d1 polynomial and gi(·) is a
degree ≤d2 polynomial over GR(2k, d) for i ∈[l].
Consistency Check: P and V check fj(αi) = τ(gj(βi)) for all i ∈[m], j ∈[l].
1. Linear combination phase: Before the polynomial key Λ is opened, P and
V do as follows:
(a) P picks two random polynomial r(·) and s(·) over GR(2k, d) with degree
d1, d2, respectively, such that r(αi) = τ(s(βi)), for i ∈[m]. Then, P and
V run the Pre-Gen procedure of ΠPAC with input 2, to pre-generate two
PACs [[r(·)]] and [[s(·)]].
(b) V samples a seed ←{0, 1}κ and sends it to P. Then, two parties computes
(χ1, ..., χl) := H(seed) ∈Zl
2k.
(c) P and V locally compute [[f(·)]] := P
j∈[l] χj · [[fj(·)]] + [[r(·)]] and [[g(·)]] :=
P
j∈[l] χj · [[gj(·)]] + [[s(·)]]. Then, P sends the polynomial pair (f(·), g(·))
to V, who checks that f(·), g(·) have the degree d1 and d2 respectively and
f(αi) = τ(g(βi)) holds for all i ∈[m]. If the check fails, V aborts.
2. Check phase: P and V locally compute [µ] := [f(Λ)] −f(Λ) and [ν] :=
[g(Λ)] −g(Λ). Then, P sends Mµ, Mν to V (i.e., P opens [µ] and [ν] to V),
and V checks Mµ = Kµ and Mν = Kν. If the check fails, V aborts.
Fig. 6: Procedure for checking the τ-consistency of polynomial evaluations for
two sets of PACs.
17

(2) The next check is for multiplication. Since PACs collapse to MACs auto-
matically after the polynomial key is revealed to P, we can use the multiplication
check procedure of Πm,n,t
ZK
, where P can only pass the check with probability at
most 3/2d, if using some incorrect polynomials ˆvj(·), j ∈[t].
(3) The final check is for inputs and outputs. After Λ is opened to P, the two
parties can obtain MACs [uj(Λ)] from the PACs [[uj(·)]], j ∈[n]. Note that they
have already obtained MACs for inputs (which are restricted in the Im(ϕ) by
re-embedding VOLE). Let ξi(·), i ∈[m2] be the Lagrange polynomials defined
by the evaluation point set {α1, ..., αm2} ⊂T. As uj(·), j ∈[n] can be computed
by Lagrange interpolation, the formula still holds in a MAC representation by
taking ξi(Λ) as the coefficients, which enables V to check input PACs [[uj(·)]] are
consistent with corresponding input MACs. Checking outputs can be done by
opening the PAC associated with the output wire, which should collapse to [1]
with an honest execution of the protocol.
The protocol is given in Figure 7,8, which takes the BatchCheck procedure in
Figure 6 and ΠPAC in Figure 19 as sub-protocols. We have the following theorem
that guarantees security with a sketched proof in Appendix C.3.
Theorem 3. Protocol Πm,n,t
slZK
UC-realizes functionality Fm
ZK that proves circuit
satisfiability over Z2k in the FGR(2k,d)
embVOLE-hybrid model and the random oracle model
with soundness error at most 2m2+3
2d
+ negl(κ).
Our protocol Πm,n,t
slZK communicates 2 AHE ciphertexts per multiplication gate.
The main costs for checking multiplications consist of two parts: transferring
random coefficients χ in Step 5.e in Figure 8, and transferring 2 polynomials
over GR(2k, d) of respective degree m2 −1, 2m2 −1 in the Linear combination
phase of the BatchCheck procedure. Assume the ciphertext size is c, these yield
2ct+td+3m2kd bits in total, which is sublinear in the circuit size mt. By dividing
mt, the amortized complexity per multiplication gate is ( 2c+d
m
+ 3kd
m1t)-bit. We
remark that the overall communication complexity of Πm,n,t
slZK
is linear in the
witness size, as the two parties need to obtain MACs for all witnesses at first.
Besides, Πm,n,t
slZK
is not public coin, due to the interactive generation of PACs.
Reduction from Evaluating Arbitrary Circuit to SIMD Circuit. There
are two methods in the literature to transform a problem on a given circuit
into one on a related SIMD circuit. The first one is to arrange a generic circuit
into an SIMD circuit (cf. [27,21]) by dividing gates into layers of addition and
multiplication gates, which introduces an overhead that depends on the topology
of the given circuit (for a large class of well formed circuits, this overhead is quite
small). The second method [54] is specific to proving circuit satisfiability. Since
the prover P holds the witness, he can calculate all values on the wires in the
circuit and authenticate them in batch as evaluating some SIMD circuit. But in
the generic circuit, the outputs of some gates may be the inputs of other gates,
thus each value on wires now needs to be authenticated twice, one as the output
of some gate, and the other as the input of some other gate. Therefore, V need to
check not only the correctness of gate evaluations, but also the consistency of every
18

Protocol Πm,n,t
slZK -Part I
The prover P and the verifier V have agreed on the following public inputs.
– A circuit C over Z2k with n inputs and t multiplication gates;
– An (m1, d)-RMFE pair (ϕ, ψ) over Z2k, and an element ζ ∈GR(2k, d) with
order 2d −1;
– A set T = {0, 1, ζ, ..., ζ2d−2} and distinct elements α1, ..., αm2 ∈T;
– Polynomials ξi(X) = Q
j∈[m2],j̸=i(X −αj)/(αi−αj) ∈GR(2k, d)[X] with degree
(m2 −1) for i ∈[m2], which are known as the Lagrange basis polynomials.
In addition, P holds m = m1 · m2 witnesses w(i) ∈Zn
2k such that C(w(i)) = 1, for
all i ∈[m].
Offline phase
1. P and V send (Init) to F GR(2k,d)
embVOLE, and V receives ∆∈GR(2k, d).
2. P and V run the Poly-Key procedure of ΠPAC with input 2m2 −2, and V
receives a uniform polynomial key Λ ∈GR(2k, d).
3. P and V send (Extend-pair, nm2) to F GR(2k,d)
embVOLE, which returns authenticated
pairs {([µ(i)
j ], [τ(µ(i)
j )])}i∈[m2],j∈[n], where all µ(i)
j
are sampled uniformly at
random in GR(2k, d). Note that V also learns τ(µ(i)) −µ(i) from F GR(2k,d)
embVOLE.
4. P and V send (Extend, n + 2t) to F GR(2k,d)
embVOLE, which returns authenticated
values {[νi]}i∈[n] and {[πj]}j∈[2t], where all νi, πj are sampled uniformly at
random in GR(2k, d).
Online phase
1. For input W (i) := (w((i−1)·m1+1), w((i−1)·m1+2), ..., w((i−1)·m1+m1)) ∈Zn×m1
2k
,
P computes ω(i) := ϕ(W (i)) ∈GR(2k, d)n, and sends δ(i) := ω(i) −µ(i),
i ∈[m2] to V. V checks whether δ(i) −τ(δ(i)) = τ(µ(i)) −µ(i) holds for
all i ∈[m2]. If the check fails, aborts. Both parties can locally compute
[τ(ω(i)
j )] := [τ(µ(i)
j )] + τ(δ(i)
j ), for i ∈[m2], j ∈[n].
2. For j ∈[n], for the j-th group of m2 inputs gates with input vector
(ω(1)
j , ..., ω(m2)
j
), P defines a degree ≤(m2 −1) polynomial uj(·) such that
uj(αi) = ω(i)
j
for i ∈[m2].
3. P and V run the Pre-Gen procedure of ΠPAC with input [ν], to pre-generate
PACs [[u1(·)]], ..., [[un(·)]].
4. For each gate (a, b, c, T) ∈C, in a topological order:
– If T=Add, then P and V locally compute [[uc(·)]] := [[ua(·)]] + [[ub(·)]].
– If T=Mul and this is the j-th multiplication gate, where j ∈[t], then P
computes a degree ≤(2m2 −2) polynomial evj(·) = euc(·) := ua(·) · ub(·) ∈
GR(2k, d)[X] and a degree ≤(m2 −1) polynomial vj = uc such that
vj(αi) = uc(αi) = τ(euc(αi)) for all i ∈[m2]. Then, P and V run the
Pre-Gen procedure of ΠPAC with input [π2j], [π2j+1], to pre-generate two
PACs [[uc(·)]] and [[euc(·)]].
Fig. 7: Zero-knowledge protocol for SIMD circuit satisfiability over Z2k with
sublinear communication in the FGR(2k,d)
embVOLE-hybrid model-Part I.
19

Protocol Πm,n,t
slZK -Part II
5. P and V perform the following multiplication check.
(a) P and V execute the linear-combination phase of the BatchCheck procedure
with parameters (m2 −1), (2m2 −2), m2, t and a common evaluation subset
{α1, ..., αm2} ⊂T on inputs {[[v1(·)]], ..., [[vt(·)]]} and {[[ev1(·)]], ..., [[evt(·)]]}
to check that vj(αi) = τ(evj(αi)) holds for all i ∈[m2], j ∈[t].
(b) P and V run the Gen procedure of ΠPAC to open Λ to P, and then V
can compute the local keys on all PACs. For the j-th multiplication gate
(a, b, c, Mul) ∈C, P and V now hold [ua(Λ)], [ub(Λ)], [euc(Λ)]. P computes
A0,j := Mua(Λ) · Mub(Λ) ∈GR(2k, d) and A1,j := ua(Λ) · Mub(Λ) + ua(Λ) ·
Mua(Λ) −Meuc(Λ) ∈GR(2k, d). V computes Bj := Kua(Λ) · Kub(Λ) −∆·
Keuc(Λ) ∈GR(2k, d).
(c) P and V execute the check phase of the BatchCheck procedure to complete
the above check. If the check fails, V aborts.
(d) P sets A∗
0 := Mπ, A∗
1 := π, and V sets B∗:= Kπ so that B∗= A∗
0 +∆·A∗
1.
(e) V draws a uniformly random χ from Ft
2d and sends it to P.
(f) P computes X := P
j∈[t] χj · A0,j + A∗
0 ∈GR(2k, d) and Y := P
j∈[t] χj ·
A1,j + A∗
1 ∈GR(2k, d), and sends (X, Y ) to V.
(g) V computes Z := P
j∈[t] χj · Bj + B∗∈GR(2k, d), and checks whether
Z = X + ∆· Y holds. If the check fails, V outputs false and aborts.
6. P and V do the following input output check. P convinces V that [[uj(·)]] is
consistent to ([ω(1)
j
], ..., [ω(m2)
j
]) for j ∈[n], and the values on all output gates
are 1.
(i) For each j ∈[n], P and V locally compute an MAC [zj] := P
i∈[m2] ξi(Λ) ·
[ω(i)
j ] −[uj(Λ)]. Then, P opens [zj], V continues if and only if zj = 0 holds
for all j ∈[n]. Otherwise, V aborts.
(ii) Let [u(·)] be the PAC associated with the output wire of C. P sends Mu(Λ)
to V.
(iii) V checks whether Ku(Λ) = Mu(Λ) + ϕ(1) · ∆. If the check fails, V outputs
false. Otherwise, V outputs true.
Fig. 8: Zero-knowledge protocol for SIMD circuit satisfiability over Z2k with
sublinear communication in the FGR(2k,d)
embVOLE-hybrid model – Part II.
20

two authenticated values on a wire, which would increase the communication
complexity considerably, depending on the topology of the given circuit.
We remark that the second method is compatible with our PAC-based con-
struction, still yielding a sublinear communication online phase, where we can do
the additional check by slightly modifying the BatchCheck procedure to allow
checks on some specific Z2k-components (rather than to check τ-consistency, i.e.
all Z2k-components). It is also possible to combine the above two methods, where
one can first arrange a generic circuit into an SIMD circuit (m1 copies), viewed
as a generic circuit over GR(2k, d), and then apply the second method. Users are
advised to pick the most efficient strategy according to the circuit topology.
4
VOLE over Galois Rings
In this section, we show efficient constructions for VOLE over Galois rings.
The first construction adapts the idea of SoftSpokenOT [50], and allows us to
construct publicly verifiable ZK protocols. Following the PCG paradigm, we
construct concretely more efficient VOLE protocols with security under LPN
over Galois rings. We present an interactive construction (better computation
complexity) based on primal LPN in Section 4.2, and a two-round construction
(small communication complexity) based on dual LPN in Appendix E. We discuss
security of LPN over Galois rings in the end of this section.
4.1
VOLE from (N −1)-out-of-N OT
SoftSpokenOT [50] showed an efficient construction for VOLE over Galois fields,
which is based on (N −1)-out-of-N OT. Intuitively, an (N −1)-out-of-N func-
tionality (formulated as FN
OT−¯1 in Figure 14), takes as inputs N strings (of
the same length) from the sender and one position ∆∈[N] from the receiver,
then delivers these strings to the receiver except for the ∆-th one. As showed
in [50], FOT−¯1 can be efficiently instantiated with log N OTs. We adapt the
SoftSpokenOT idea to construct VOLE protocols over Galois rings. W.l.o.g.,
assume N = 2kd. Let s1, ..., sN ∈GR(2k, d)l be random strings held by PS, and
∆∈[N] be a random index selected by PR. The VOLE construction is induced
by the following observation:
X
y∈GR(2k,d)\{∆}
sy ·(∆−y) =
X
y∈GR(2k,d)
sy ·(∆−y) =
X
y∈GR(2k,d)
sy ·∆−
X
y∈GR(2k,d)
sy ·y.
Through an invocation to FN
OT−¯1, PR receives sy, for y ∈GR(2k, d)\{∆}6. Then,
PR locally computes K := P
y∈GR(2k,d)\{∆} sy · (∆−y). By PS locally computing
M := −P
y∈GR(2k,d) sy · y and x := P
y∈GR(2k,d) sy, we have that K = M + ∆· x
(i.e., PS and PR obtain a VOLE correlation over GR(2k, d)). The main drawback
6 We naturally view y ∈GR(2k, d) as an integer in [N], and ∆∈[N] as an element in
GR(2k, d), since N = 2kd.
21

for implementation is that the computational costs (both for PS and PR) are
high, since the above construction involves N heavy multiplication operations
over GR(2k, d) per party. To reduce the computation complexity, we utilize the
algebraic structure of Galois rings that GR(2k, d) contains F2d as a “subfield”, and
restrict ∆to be sampled from F2d. More specifically, let N = 2d, and we have:
K =
X
y∈F2d\{∆}
sy·(∆−y) =
X
y∈F2d
sy·(∆−y) =
X
y∈F2d
sy·∆−
X
y∈F2d
sy·y = x·∆+M.
We present the resulting VOLE protocol in Figure 9, and we have the following
theorem with proof deferred to Appendix D.1.
Theorem 4. Protocol ΠGR(2k,d)
sfVOLE UC realizes FGR(2k,d)
sfVOLE (Figure 15) in the FN
OT−¯1-
hybrid model.
Protocol ΠGR(2k,d)
sfVOLE
Parameterized by a Galois ring GR(2k, d), and a length parameter l. Let N = 2d.
Init: Both parties send (Init, GR(2k, d)l) to F N
OT−¯1. PR receives ∆∈[N].
Extend: Both parties send (Get) to F N
OT−¯1, and act as follows:
1. Upon receiving {sy}y∈F2d \{∆} from F N
OT−¯1, the receiver PR locally computes
K = P
y∈F2d \{∆} sy · (∆−y).
2. Upon receiving {sy}y∈[n] from F N
OT−¯1, PS computes M := −P
y∈F2d sy · y and
x := P
y∈F2d sy.
3. Output K = M + ∆· x, where K, M, x ∈GR(2k, d)l.
Fig. 9: Protocol for VOLE over GR(2k, d) in the FN
OT−¯1-hybrid model.
We remark that ΠGR(2k,d)
sfVOLE in fact realizes a variant of FGR(2k,d)
VOLE , where PR
obtains random ∆in F2d instead of GR(2k, d). We argue that our ZK protocols
remain secure, if the underlying VOLE functionality is instantiated with ΠGR(2k,d)
sfVOLE .
Intuitively, the entropy of ∆(distributed uniformly at random in F2d rather than
GR(2k, d)) is still sufficient for guaranteeing a negligible soundness error, as we
originally require d to be linear in the security parameter. We refer to a more
detailed discussion in Appendix D.1. As shown in [50], the (N −1)-out-of-N
OT can be efficiently realized by O(log N) parallel invocations of OT and PRGs,
yielding small communication complexity (independent of the length parameter
l). In addition, similar to that in [50,5], it is plausible that the efficiency can be
further improved by using linear codes over GR(2k, d) (e.g. Reed-Solomon codes
defined over GR(2k, d) [26]), which is beyond the scope of this paper and omitted.
22

Baum et al. [5] proposed the VOLE-in-the-head technique, where they con-
structed an compiler that transforms any public coin, interactive ZK protocol
based on (N −1)-out-of-N OT to a publicly verifiable NIZK protocol. As shown
in Section 3.2, our protocol Πm,n,t
ZK
admits a public coin ZK in the VOLE-hybrid
model. Therefore, we can apply their compiler to obtain the first publicly verifiable
NIZK protocol over Z2k, following the road map:
FN
OT−¯1 ⇒ΠGR(2k,d)
sfVOLE ⇒ΠGR(2k,d)
embVOLE ⇒Πm,n,t
ZK
compiler
=⇒
publicly verifiable NIZK
4.2
VOLE based on primal LPN
We also construct efficient VOLE protocols based on variants of LPN, following
the established PCG-style VOLE paradigm (similar to OT extension) 7. Basically,
the paradigm involves two main steps. The first step is to construct a single
point variant of VOLE (spVOLE for short), and the second step is to use LPN to
locally convert multiple spVOLE instances (of the same length) into one (much
longer) VOLE correlation. To begin with, we focus on constructing spVOLE over
GR(2k, d), where u (held by the sender) in the VOLE correlation v = w + u · ∆
has only one non-zero entry 8 (see the ideal functionality FGR(2k,d)
spVOLE in Figure 17).
Single-point VOLE. We adapt the spVOLE construction in Wolverine [53]
from Galois fields to Galois rings. We briefly review the main ingredient, the
puncturable pseudorandom function [14] (PPRF) based on GGM tree [37]. In-
formally, a PPRF allows to distribute n pseudorandom values among the two
parties, where the receiver obtains all of them from a key, while the sender can
compute them all except for one value on his choice from a punctured key. The
GGM tree algorithms (presented in Figure 18) admit a semi-honestly secure
protocol in the OT-hybrid model that achieves the above procedure.
In more detail, suppose the two parties PS and PR have already obtained
random Galois ring elements {vj}j∈[0,n)\{α} and {vj}j∈[0,n) from PPRF, respec-
tively, where α ∈[0, n) is randomly picked by PS. Then PS can define two vectors
w, u ∈GR(2k, d)n such that wj = vj, uj = 0, for j ̸= α (we do not care about
wα, uα for now). It can be directly observed that v = w + u · ∆holds for any ∆,
if ignoring the entry indexed by α. To obtain the desired single-point VOLE cor-
relation, we can consume a length one VOLE correlation γ = δ +β ·∆(intuitively,
“inject” the correlation to the target entry). By PR sending g := γ −P
j∈[0,n) vj
to PS, PS can compute wα := δ −(g + P
i̸=α wi). And we can verify that
vα = wα + β · ∆holds. Thus, setting uα := β, the two parties obtain the desired
single-point VOLE correlation v = w + u · ∆.
The above spVOLE construction is only semi-honestly secure. In the malicious
setting, the adversary may either cheat in the PPRF procedure or send an incorrect
g. As shown in Wolverine [53], to achieve malicious security, we only need to
7 Note that instantiating the VOLE functionality of Πm,n,t
ZK
with PCG-style construc-
tions leads to a designated verifier NIZK, since the verifier is no longer public coin.
8 We remark that we further require the non-zero entry to be a unit of the Galois ring,
due to a modulo attack for LPN over Galois rings (Theorem 6).
23

guarantee the spVOLE correlation holds in each entry 9. To this end, we can apply
a random-linear combination check. Let χi ∈GR(2k, d), i ∈[0, n) be uniformly
random elements picked by PS. We have that
X
i∈[0,n)
χi · vi =
X
i∈[0,n)
χi · wi + χα · β · ∆.
(3)
However, we cannot directly use Equation 3 for consistency check, since χα · β · ∆
can not be locally computed by any party and the linear combination would leak
some information. These can be solved by masking with a VOLE correlation
where y = z + χα · β · ∆. Namely, the two parties check the following equation
X
i∈[0,n)
χi · vi −y =
X
i∈[0,n)
χi · wi −z.
(4)
We give the single-point VOLE protocol in Figure 10, and we have the
following theorem (with proof deferred to Section D.2).
Theorem 5. If G and G′ are PRGs, then ΠGR(2k,d)
spVOLE UC-realizes FGR(2k,d)
spVOLE func-
tionality in the (FGR(2k,d)
VOLE , FOT, FEQ)-hybrid model. In particular, no PPT envi-
ronment Z can distinguish the real world execution from the ideal world simulation
except with advantage at most 1/2d + negl(κ).
From spVOLE to VOLE. The extension procedure relies on an observation
from LPN. Assume A ∈GR(2k, d)m×n is a generating matrix and D is a noise
distribution over GR(2k, d)n, for which the primal LPN assumption holds (we
refer to Section B for LPN preliminaries). Suppose PS and PR have obtained a
VOLE correlation of length (m + n), written as v = w + u · ∆and b = c + e · ∆,
where u ∈GR(2k, d)m and e ←D. We have that
K = (v · A + b) = (w · A + c) + (u · A + e) · ∆= M + x · ∆,
where (M, x), K can be locally computed by PS and PR, respectively. Moreover,
by the primal LPN assumption, x = u·A+e is computationally indistinguishable
from a uniformly random vector over GR(2k, d). In the literature, D is usually
instantiated with the so-called regular noise distribution, where the error vector
of weight t can be divided into t blocks with each block having only one non-zero
entry. Therefore, we can obtain the VOLE correlation b = c + e · ∆from t
repetitions of single-point VOLE. Recall that we require a VOLE correlation (of
length two) to produce one single-point VOLE. Thus, the above construction
essentially extends a VOLE correlation of length m+2t into length n. In addition,
as showed in [53], a kind of “bootstrapping” technique can be used to further
reduce the communication complexity, where a part of the outputs can be reserved
as the base VOLE correlation for the next extension.
9 We remark that this is a major challenge in constructing spVOLE over Z2k, and
MozZ2karella [4] overcame it by using two check mechanisms in a sophisticated way.
24

Protocol ΠGR(2k,d)
spVOLE
Init: Both parties send Init to F GR(2k,d)
VOLE
, which returns ∆to PR.
SP-Extend: On input n = 2h, the two parties do as follows:
1. Construct:
(a) Both parties send (Extend, 1) to F GR(2k,d)
VOLE
. PS receives a, c ∈GR(2k, d) and
PR receives b ∈GR(2k, d) such that b = c + a · ∆holds.
(b) PS samples α
$←[0, n), and draws a uniformly random β in the set of
units of GR(2k, d). PS sets a vector u ∈GR(2k, d)n with uα = β and ui = 0
for all i ̸= α.
(c) PS sets δ := c and sends a′ := β −a ∈GR(2k, d) to PR. PR computes
γ := b + a′ · ∆∈GR(2k, d). Note that γ = δ −β · ∆, so the two parties now
obtain [β].
(d) PR computes s ←GGM.KeyGen(1κ), and runs GGM.Gen(1n, s) to obtain
({vj}j∈[0,n), {(Ki
0, Ki
1)}i∈[h]). Let α = P
i∈[h] 2h−iαi, where αi ∈{0, 1},
and let ¯αi denote the complement of αi. For i ∈[h], PS sends ¯αi to
FOT while PR sends (Ki
0, Ki
1) to FOT, then PS receives Ki
¯αi. PS runs
GGM.Eval(α, {Ki
¯αi}i∈[h]) and gets {vj}j̸=α.
(e) PR sends g := γ −P
j∈[0,n) vj ∈GR(2k, d) to PS. PS defines a vector
w ∈GR(2k, d)n such that wi := vi for i ̸= α and wα := δ −(g + P
i̸=α wi).
Note that v = w + u · ∆.
2. Check:
(a) Both parties send (Extend, 1) to F GR(2k,d)
VOLE
. PS receives x, z ∈GR(2k, d) and
PR receives y∗∈GR(2k, d) where y∗= z + x · ∆.
(b) PS samples χi
$←GR(2k, d) for i ∈[0, n), and computes x∗:= χα · β −x ∈
GR(2k, d). PS sends ({χi}i∈[0,n), x∗) to PR. PR computes y := y∗+∆·x∗∈
GR(2k, d). Now, we have y = z + χα · β · ∆.
(c) PS computes VPS := P
i∈[0,n) χi · wi −z, and sends VPS to FEQ as P.
PR computes VPR := P
i∈[0,n) χi · vi −y, and send VPR to FEQ as V. PR
receives VPS. PS and PR abort if the equality test fails.
3. Output: PS outputs (w, u), and PR outputs v.
Fig. 10:
Protocol
for
single-point
VOLE
over
GR(2k, d)
in
the
(FGR(2k,d)
VOLE , FOT, FEQ)-hybrid model.
25

LPN security. We remark that similar to [53,4], our ΠGR(2k,d)
spVOLE essentially allows
a corrupted PR to guess a subset of [0, n) that contains the index of the non-zero,
invertible entry of u, and a corrupted PS to guess ∆(we formulate such attacks
in FGR(2k,d)
spVOLE). The former leakage would affect the LPN assumption. Namely, it
allows the LPN adversary to guess a subset for each block of the noise vector,
which would leak 1-bit information in general: the adversary learns whether his
guesses are all right.
Definition 2 (Primal LPN with static leakage). We first define the corre-
sponding LPN security game GLPN as follows:
1. Let A ←G(m, n) ∈GR(2k, d)m×n be a primal LPN matrix, x ←GR(2k, d)m be
the secret, and e = (e(1), ..., e(t)) ∈GR(2k, d)n be the error vector, where each
e(i), i ∈[t] has only one entry invertible in GR(2k, d) and zeros everywhere
else.
2. A sends I1, ..., It ⊂[n/t]. If for all i ∈[t], Ii includes the noisy position of
e(i), send success to A. Otherwise, abort.
3. Pick b ←{0, 1}. If b = 0, send y := x · A + e to A, otherwise, send
y
$←GR(2k, d)n to A.
4. A outputs a bit b′. The game outputs 1 if b′ = b, and outputs 0 otherwise.
We say that the decisional (RG, G, R) −LPN(m, n, t) with static leakage is (T, ϵ)-
hard, if for every probabilistic distinguisher B running in time T, B wins the
game GLPN with advantage at most ϵ, i.e.
|Pr[GLPN = 1] −1/2| ≤ϵ.
We give the VOLE extension protocol in Figure 11, and we have the following
theorem with proof deferred to Appendix D.2.
Theorem 6. If the decisional (RG, G, GR(2k, d))-LPN(m, n, t) with static leakage
assumption holds, then ΠGR(2k,d)
VOLE
UC-realizes FGR(2k,d)
qVOLE (see Figure 16) 10 in the
FGR(2k,d)
spVOLE-hybrid model.
We adapt existing reduction results for LPN over Z2k [46] to Galois rings,
obtaining the following theorems with proofs in Appendix B.2.
Theorem 7. If decisional (D, G, GR(2k, d)) −LPN(m, n, w1) is (T, ϵ)-hard, then
decisional (D, G, F2d) −LPN(m, n, w2) is (T −poly(m, n), O(hϵ))-hard, where
(D, w1, w2, h) ∈{(HW, t, 2d(k−1)(2d−1)
2dk−1
t,
√
t), (Ber, λ, λ, 1)}.
Theorem 8. If decisional (Ber, F2d) −LPN(m, n,
λ(2d−1)
(1−λ)2dk+λ2d ) is (T, ϵ)-hard,
then decisional (Ber, GR(2k, d)) −LPN(m, n, λ) is (T −poly(m, n), kϵ)-hard.
10 F GR(2k,d)
qVOLE extends F GR(2k,d)
VOLE
, which additionally captures the leakage of ∆.
26

We remark that Theorem 7 introduces an attack for LPN over GR(2k, d),
where one can reduce an LPN instance’s noise weight by approximately 1/2d
fraction via modulo 2. We see this attack is much less efficient than that for
LPN over Z2k, since it may be tolerable if d is set sufficiently large. Alternatively,
similar to [4,46], we can additionally require that each non-zero entry of the error
vector e is invertible to avoid this reduction attack. We also review main attacks
that may work on LPN over Galois rings in Appendix B.3, following the analysis
of [32,14,15,4,46].
Protocol ΠGR(2k,d)
VOLE
Let A ∈GR(2k, d)m×n be a generating matrix used for LPN(m, n, t) over GR(2k, d).
We always assume that n is a multiple of t.
Init:
– Both parties send Init to F GR(2k,d)
spVOLE, which returns ∆∈GR(2k, d) to PR.
– Both parties send (Extend, m) to F GR(2k,d)
spVOLE. PS receives w, u ∈GR(2k, d)m, and
PR receives v ∈GR(2k, d)m, such that v = w + u · ∆holds.
Extend:
1. For i ∈[t], both parties send (SP-Extend, n/t) to F GR(2k,d)
spVOLE. PS receives c(i), e(i)
and PR receives b(i), where b(i) = c(i) + e(i) · ∆over GR(2k, d)n/t, and e(i) ∈
GR(2k, d)n/t has one entry invertible in GR(2k, d) and zeros everywhere else.
2. Let e := (e(1), ..., e(t)), c := (c(1), ..., c(t)), and b := (b(1), ..., b(t)) ∈GR(2k, d)n.
PS locally computes x := u · A + e, and M := w · A + c ∈GR(2k, d)n. PR
locally computes K := v · A + b ∈GR(2k, d)n.
3. PS updates u, w by setting u := x[1 : m] ∈GR(2k, d)m and w := M[1 : m] ∈
GR(2k, d)m, and outputs (x[m + 1 : n], M[m + 1 : n]). PS updates v by setting
v := K[1 : m] ∈GR(2k, d)m and outputs K[m + 1 : n].
Fig. 11: Protocol for VOLE over GR(2k, d) in the FGR(2k,d)
spVOLE-hybrid model.
References
1. Abspoel, M., Cramer, R., Escudero, D., Damgård, I., Xing, C.: Improved single-
round secure multiplication using regenerating codes. In: ASIACRYPT 2021. LNCS,
vol. 13091, pp. 222–244. Springer (2021)
2. Ames, S., Hazay, C., Ishai, Y., Venkitasubramaniam, M.: Ligero: Lightweight
sublinear arguments without a trusted setup. In: CCS 2017. pp. 2087–2104. ACM
(2017)
27

3. Baum, C., Braun, L., Munch-Hansen, A., Razet, B., Scholl, P.: Appenzeller to brie:
Efficient zero-knowledge proofs for mixed-mode arithmetic and z2k. In: CCS 2021.
pp. 192–211. ACM (2021)
4. Baum, C., Braun, L., Munch-Hansen, A., Scholl, P.: MozZ2karella: Efficient vector-
ole and zero-knowledge proofs over Z2k. In: CRYPTO 2022. LNCS, vol. 13510, pp.
329–358. Springer (2022)
5. Baum, C., Braun, L., de Saint Guilhem, C.D., Klooß, M., Orsini, E., Roy, L.,
Scholl, P.: Publicly verifiable zero-knowledge and post-quantum signatures from
vole-in-the-head. In: CRYPTO 2023. LNCS, vol. 14085, pp. 581–615. Springer
(2022)
6. Baum, C., Dittmer, S., Scholl, P., Wang, X.: Sok: Vector OLE-based zero-knowledge
protocols. IACR Cryptol. ePrint Arch. p. 857 (2023), https://eprint.iacr.org/
2023/857
7. Baum, C., Malozemoff, A.J., Rosen, M.B., Scholl, P.: Mac’n’cheese: Zero-knowledge
proofs for boolean and arithmetic circuits with nested disjunctions. In: CRYPTO
2021. LNCS, vol. 12828, pp. 92–122. Springer (2021)
8. Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and
post-quantum secure computational integrity. IACR Cryptol. ePrint Arch. p. 46
(2018), http://eprint.iacr.org/2018/046
9. Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.:
Aurora: Transparent succinct arguments for R1CS. In: EUROCRYPT 2019. LNCS,
vol. 11476, pp. 103–128. Springer (2019)
10. Blum, A., Furst, M.L., Kearns, M.J., Lipton, R.J.: Cryptographic primitives based
on hard learning problems. In: CRYPTO 1993. LNCS, vol. 773, pp. 278–291.
Springer (1993)
11. Bootle, J., Cerulli, A., Ghadafi, E., Groth, J., Hajiabadi, M., Jakobsen, S.K.: Linear-
time zero-knowledge proofs for arithmetic circuit satisfiability. In: ASIACRYPT
2017. LNCS, vol. 10626, pp. 336–365. Springer (2017)
12. Bootle, J., Chiesa, A., Guan, Z., Liu, S.: Linear-time probabilistic proofs with
sublinear verification for algebraic automata over every field. IACR Cryptol. ePrint
Arch. p. 1056 (2022), https://eprint.iacr.org/2022/1056
13. Bootle, J., Chiesa, A., Liu, S.: Zero-knowledge iops with linear-time prover and
polylogarithmic-time verifier. In: EUROCRYPT 2022. LNCS, vol. 13276, pp. 275–
304. Springer (2022)
14. Boyle, E., Couteau, G., Gilboa, N., Ishai, Y.: Compressing vector OLE. In: CCS
2018. pp. 896–912. ACM (2018)
15. Boyle, E., Couteau, G., Gilboa, N., Ishai, Y., Kohl, L., Rindal, P., Scholl, P.: Efficient
two-round OT extension and silent non-interactive secure computation. In: CCS
2019. pp. 291–308. ACM (2019)
16. Boyle, E., Couteau, G., Gilboa, N., Ishai, Y., Kohl, L., Scholl, P.: Efficient pseudo-
random correlation generators: Silent OT extension and more. In: CRYPTO 2019.
LNCS, vol. 11694, pp. 489–518. Springer (2019)
17. Briaud, P., Øygarden, M.: A new algebraic approach to the regular syndrome
decoding problem and implications for PCG constructions. In: EUROCRYPT 2023.
LNCS, vol. 14008, pp. 391–422. Springer (2023)
18. Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs:
Short proofs for confidential transactions and more. In: SP 2018. pp. 315–334. IEEE
Computer Society (2018)
19. Canetti, R.: Universally composable security: A new paradigm for cryptographic
protocols. In: FOCS 2001. pp. 136–145. IEEE Computer Society (2001)
28

20. Cascudo, I., Cramer, R., Xing, C., Yuan, C.: Amortized complexity of information-
theoretically secure MPC revisited. In: CRYPTO 2018. LNCS, vol. 10993, pp.
395–426. Springer (2018)
21. Cascudo, I., Gundersen, J.S.: A secret-sharing based MPC protocol for boolean
circuits with good amortized complexity. In: TCC 2020. LNCS, vol. 12551, pp.
652–682. Springer (2020)
22. Chase, M., Derler, D., Goldfeder, S., Orlandi, C., Ramacher, S., Rechberger, C.,
Slamanig, D., Zaverucha, G.: Post-quantum zero-knowledge and signatures from
symmetric-key primitives. In: CCS 2017. pp. 1825–1842. ACM (2017)
23. Cheon, J.H., Kim, D., Lee, K.: Mhz2k: MPC from HE over Z2k with new packing,
simpler reshare, and better ZKP. In: CRYPTO 2021. LNCS, vol. 12826, pp. 426–456.
Springer (2021)
24. Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, P., Ward, N.P.: Marlin: Pre-
processing zksnarks with universal and updatable SRS. In: EUROCRYPT 2020.
LNCS, vol. 12105, pp. 738–768. Springer (2020)
25. Cramer, R., Damgård, I., Escudero, D., Scholl, P., Xing, C.: SPDZ2k: Efficient
MPC mod 2k for dishonest majority. In: CRYPTO 2018. LNCS, vol. 10992, pp.
769–798. Springer (2018)
26. Cramer, R., Rambaud, M., Xing, C.: Asymptotically-good arithmetic secret sharing
over Z/pℓZ with strong multiplication and its applications to efficient MPC. In:
CRYPTO 2021. LNCS, vol. 12827, pp. 656–686. Springer (2021)
27. Damgård, I., Zakarias, S.: Constant-overhead secure computation of boolean circuits
using preprocessing. In: TCC 2013. LNCS, vol. 7785, pp. 621–641. Springer (2013)
28. Debris-Alazard, T., Tillich, J.: Statistical decoding. In: ISIT 2017. pp. 1798–1802.
IEEE (2017)
29. Dittmer, S., Ishai, Y., Lu, S., Ostrovsky, R.: Improving line-point zero knowledge:
Two multiplications for the price of one. In: CCS 2022. pp. 829–841. ACM (2022)
30. Dittmer, S., Ishai, Y., Ostrovsky, R.: Line-point zero knowledge and its applications.
In: ITC 2021. LIPIcs, vol. 199, pp. 5:1–5:24. Schloss Dagstuhl - Leibniz-Zentrum
für Informatik (2021)
31. Escudero, D., Xing, C., Yuan, C.: More efficient dishonest majority secure compu-
tation over Z2k via galois rings. In: CRYPTO 2022. LNCS, vol. 13507, pp. 383–412.
Springer (2022)
32. Esser, A., Kübler, R., May, A.: LPN decoded. In: CRYPTO 2017. LNCS, vol. 10402,
pp. 486–514. Springer (2017)
33. Frederiksen, T.K., Nielsen, J.B., Orlandi, C.: Privacy-free garbled circuits with
applications to efficient zero-knowledge. In: EUROCRYPT 2015. LNCS, vol. 9057,
pp. 191–219. Springer (2015)
34. Gabizon, A., Williamson, Z.J., Ciobotaru, O.: PLONK: permutations over lagrange-
bases for oecumenical noninteractive arguments of knowledge. IACR Cryptol. ePrint
Arch. p. 953 (2019), https://eprint.iacr.org/2019/953
35. Ganesh, C., Nitulescu, A., Soria-Vazquez, E.: Rinocchio: Snarks for ring arithmetic.
IACR Cryptol. ePrint Arch. p. 322 (2021)
36. Giacomelli, I., Madsen, J., Orlandi, C.: Zkboo: Faster zero-knowledge for boolean
circuits. In: USENIX Security 2016. pp. 1069–1083. USENIX Association (2016)
37. Goldreich, O., Goldwasser, S., Micali, S.: How to construct random functions. J.
ACM 33(4), 792–807 (1986)
38. Golovnev, A., Lee, J., Setty, S.T.V., Thaler, J., Wahby, R.S.: Brakedown: Linear-
time and field-agnostic snarks for R1CS. In: CRYPTO 2023. LNCS, vol. 14082, pp.
193–226. Springer (2023)
29

39. Groth, J.: On the size of pairing-based non-interactive arguments. In: EUROCRYPT
2016. LNCS, vol. 9666, pp. 305–326. Springer (2016)
40. Guo, X., Yang, K., Wang, X., Zhang, W., Xie, X., Zhang, J., Liu, Z.: Half-tree:
Halving the cost of tree expansion in COT and DPF. In: EUROCRYPT 2023.
LNCS, vol. 14004, pp. 330–362. Springer (2023)
41. Heath, D., Kolesnikov, V.: Stacked garbling for disjunctive zero-knowledge proofs.
In: EUROCRYPT 2020. LNCS, vol. 12107, pp. 569–598. Springer (2020)
42. Ishai, Y., Kushilevitz, E., Ostrovsky, R., Sahai, A.: Zero-knowledge from secure
multiparty computation. In: STOC 2007. pp. 21–30. ACM (2007)
43. Jawurek, M., Kerschbaum, F., Orlandi, C.: Zero-knowledge using garbled circuits:
how to prove non-algebraic statements efficiently. In: CCS 2013. pp. 955–966. ACM
(2013)
44. Katz, J., Kolesnikov, V., Wang, X.: Improved non-interactive zero knowledge with
applications to post-quantum signatures. In: CCS 2018. pp. 525–537. ACM (2018)
45. Lin, F., Xing, C., Yao, Y., Yuan, C.: Amortized NISC over Z2k from RMFE. IACR
Cryptol. ePrint Arch. p. 1363 (2023), https://eprint.iacr.org/2023/1363
46. Liu, H., Wang, X., Yang, K., Yu, Y.: The hardness of LPN over any integer
ring and field for PCG applications. IACR Cryptol. ePrint Arch. p. 712 (2022),
https://eprint.iacr.org/2022/712
47. Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: nearly practical verifiable
computation. Commun. ACM 59(2), 103–112 (2016)
48. Peters, C.: Information-set decoding for linear codes over Fq. In: PQCrypto 2010.
LNCS, vol. 6061, pp. 81–94. Springer (2010)
49. Ron-Zewi, N., Rothblum, R.D.: Proving as fast as computing: succinct arguments
with constant prover overhead. In: STOC 2022. pp. 1353–1363. ACM (2022)
50. Roy, L.: Softspokenot: Quieter OT extension from small-field silent VOLE in the
minicrypt model. In: CRYPTO 2022. LNCS, vol. 13507, pp. 657–687. Springer
(2022)
51. Setty, S.T.V.: Spartan: Efficient and general-purpose zksnarks without trusted
setup. In: CRYPTO 2020. LNCS, vol. 12172, pp. 704–737. Springer (2020)
52. Wan, Z.X.: Lectures on finite fields and Galois rings. World Scientific Publishing
Company (2003)
53. Weng, C., Yang, K., Katz, J., Wang, X.: Wolverine: Fast, scalable, and
communication-efficient zero-knowledge proofs for boolean and arithmetic circuits.
In: IEEE Symposium on Security and Privacy 2021. pp. 1074–1091. IEEE (2021)
54. Weng, C., Yang, K., Yang, Z., Xie, X., Wang, X.: Antman: Interactive zero-
knowledge proofs with sublinear communication. In: CCS 2022. pp. 2901–2914.
ACM (2022)
55. Xie, T., Zhang, Y., Song, D.: Orion: Zero knowledge proof with linear prover time.
In: CRYPTO 2022. LNCS, vol. 13510, pp. 299–328. Springer (2022)
56. Yang, K., Sarkar, P., Weng, C., Wang, X.: Quicksilver: Efficient and affordable
zero-knowledge proofs for circuits and polynomials over any field. In: CCS 2021.
pp. 2986–3001. ACM (2021)
57. Yao, A.C.: How to generate and exchange secrets (extended abstract). In: FOCS
1986. pp. 162–167. IEEE Computer Society (1986)
58. Zahur, S., Rosulek, M., Evans, D.: Two halves make a whole - reducing data transfer
in garbled circuits using half gates. In: EUROCRYPT 2015. LNCS, vol. 9057, pp.
220–250. Springer (2015)
30

Supplementary Material
A
More Preliminaries & Functionalities
Security Model. In UC framework [19], security is defined via the comparison
of an ideal world and a real world. In the real world, the parties interact with
each other following the protocol. In the ideal world, the parties interact with an
ideal functionality F that is designed to ideally realize the protocol rather than
each other. There exists an environment Z, who lives both in the real world
and the ideal world, provides inputs to the parties and can read the outputs.
The corrupted party A, controlled by the environment Z, interacts with honest
parties in the real world. We consider active adversary and static corruption,
namely the adversary A’s behavior is arbitrary and not necessarily according to
the protocol specification and corruption occurs before the protocol execution.
Further, the environment Z is allowed to interact with the adversary A at any
point throughout the protocol execution. The UC-security is guaranteed, if there
is a simulator S plugged to the ideal world that interacts with the adversary A
such that the environment Z can not distinguish S and the honest parties from
the adversary A’s view along with all parties’ inputs and outputs. More formally,
We say a protocol Π UC-realizes a functionality F with security parameter κ,
if there is a probabilistic polynomial-time (PPT) simulator S such that no PPT
environment Z can distinguish the ideal world and the real world with advantage
1/poly(κ).
Commitment Scheme. A commitment scheme is a two party protocol consisting
of two algorithms, Commit and Open. In the commit phase of the protocol, the
sender PS invokes Commit to commit some value m, obtaining (com, unv) ←
Commit(m) as the result. Then he sends com to the receiver PR. Later on in the
unveil phase, PS is required to send m along with the unveil information unv to
PR such that PR can check whether Open(com, unv, m) = 1. Informally, there are
two security properties that a commitment scheme should satisfy; 1.Hiding: PR
can not learn anything about m from com in the commit phase, and 2.Binding:
PS can not provide a m′ ̸= m and a unv′ such that Open(com, unv′, m′) = 1 in
the unveil phase.
Additively Homomorphic Encryption. We describe the Additively Homo-
morphic Encryption (AHE) scheme in the private-key setting, which consists of
three algorithms, KeyGen, Enc, Dec. The KeyGen algorithm outputs a secret key
sk, which is determined by its random tape. The Enc algorithm takes the secret
key sk and message m as inputs, and outputs a ciphertext ⟨m⟩, while the Dec
algorithm decrypts the ciphertext via sk, denoted by m := Dec(⟨m⟩, sk). The
additive property indicates that the decryption of a linear combination of cipher-
texts equals to the corresponding linear combination of plaintexts. We suppose
the AHE scheme works on a Galois ring, and satisfies the chosen plaintext attack
(CPA) security. For security of our protocol ΠPAC (Figure 19), we additionally
require the AHE scheme to satisfy circuit privacy and degree restriction, similar
to that in [54]. Such AHE schemes exist as shown in [23].
31

Functionality FEQ
On input VP from P and VV from V:
1. Send VP and (VP
?= VV) to V.
2. If V is honest and VP = VV, or V is corrupted and sends continue, then send
(VP
?= VV) to P.
3. If V is honest and VP ̸= VV, or V is corrupted and sends abort, then send
abort to P.
Fig. 12: Ideal functionality for equality tests.
Functionality FOT
On input b ∈{0, 1} from PS and m0, m1 from PR: Send mb to PS.
Fig. 13: Ideal functionality for oblivious transfer.
Functionality FOT−¯1
Parameterized by a ring R, and an integer N.
Init: Upon receiving (Init) from both parties:
1. If PS is honest, sample s1, ..., sN
$←R; otherwise receive s1, ..., sN ∈R from A.
2. If PR is honest, sample ∆
$←[N], and send ∆to PR. Otherwise receive ∆∈[n]
and {ˆsi ∈R}i∈[N]\∆from the adversary A, then reset si = ˆsi, for i ∈[N]\∆.
Get: Upon receiving (Get) from both parties:
Send {si}i∈[N] to PS and {si}i∈[N]\{∆} to PR.
Fig. 14: Ideal functionality for (N −1)-out-of-N oblivious transfer.
32

Functionality F GR(2k,d)
sfVOLE
Init: Upon receiving (Init) from both parties, sample ∆
$←F2d if PR is honest,
and receive ∆∈F2d from the adversary A otherwise. Store ∆and send it to PR.
All further (Init) commands will be ignored.
Extend: Upon receiving (Extend, l) from both parties, proceed as follows:
1. If PR is honest, sample K
$←GR(2k, d)l. Otherwise receive K from A.
2. If PS is honest, sample x
$←GR(2k, d)l and compute M := K −∆· x ∈
GR(2k, d)l. Otherwise, receive x ∈GR(2k, d)l and M ∈GR(2k, d)l from A and
then recompute K := M + ∆· x.
3. Send (x, M) to PS and K to PR.
Fig. 15: Ideal functionality of VOLE over GR(2k, d).
Functionality F GR(2k,d)
qVOLE
F GR(2k,d)
qVOLE extends the existing VOLE functionality F GR(2k,d)
VOLE
(Figure 1). Init and
Extend are identical to those in F GR(2k,d)
VOLE
, respectively.
Global-key Query: If PS is corrupted, receive (Guess, ∆′) from A with ∆′ ∈
GR(2k, d). If ∆′ = ∆, send success to PS and ignore any subsequent global-key
queries. Otherwise, send abort to both parties and abort.
Fig. 16: Ideal functionality for VOLE over GR(2k, d) with global key query.
33

Functionality F GR(2k,d)
spVOLE
F GR(2k,d)
spVOLE extends the existing VOLE functionality F GR(2k,d)
VOLE
(Figure 1). Init and
Extend are identical to those in F GR(2k,d)
VOLE
, respectively.
SP-Extend: Upon receiving (SP-Extend, n) from both parties, proceed as follows:
1. If PR is honest, sample v
$←GR(2k, d)n. Otherwise receive v from A.
2. If PS is honest, sample uniform u from GR(2k, d)n with exactly one entry
invertible and zeros everywhere else, and compute w := v −∆· u ∈GR(2k, d)n.
Otherwise, receive u ∈GR(2k, d)n (with at most one nonzero entry) and
w ∈GR(2k, d)n from A, then recompute v := w + ∆· u.
3. If PR is corrupted, receive a set I ⊆[0, n) from A. Let α ∈[0, n) be the
index of the nonzero entry of u. If α ∈I, send success to PR and continue.
Otherwise, send abort to both parties and abort.
4. Send (u, w) to PS and v to PR.
Global-key Query: If PS is corrupted, receive (Guess, ∆′, s) from A with ∆′ ∈
GR(2k, d) and s ∈[k]. If ∆′ = ∆mod 2s, send success to PS and ignore any
subsequent global-key queries. Otherwise, send abort to both parties and abort.
Fig. 17: Ideal functionality for single-point VOLE over GR(2k, d).
B
LPN over Galois Rings
B.1
Learning Parity with Noise
The Learning Parity with Noise (LPN) assumption [10] has been studied for
decades, and it was adapted to be defined over a finite field Fq [14] or an integer
ring Zn [4], recently. We give the definition for (primal) LPN over arbitrary rings
below.
Definition 3 (LPN). Let D(R) = {Dt,n(R)} be the family of distributions over
the ring R where for any integers t ≤n, Im(Dt,n(R)) ⊂Rn. Let G be a proba-
bilistic code generation algorithm such that G(m, n, R) outputs a generator matrix
A ∈Rm×n. Let parameters m, n, t be implicit functions of security parameter
κ. We say that the decisional (D, G, R)-LPN(m, n, t) problem is (T, ϵ)-hard if for
every probabilistic distinguisher B running in time T, we have that
|Pr[B(A, x · A + e) = 1] −Pr[B(A, u) = 1]| ≤ϵ,
where A ←G(m, n, R), x
$←Rm, u
$←Rn, and e ←Dt,n(R).
Informally, the decisional LPN(m, n, t) assumption states that b := x · A + e
is pseudorandom, where A, x, e are defined as above and A is public. There exists
another family of LPN assumptions, i.e. the dual LPN.
34

Algorithm GGM
Let G : {0, 1}κ →{0, 1}2κ, and G′ : {0, 1}κ →GR(2k, d)2 × {0, 1}κ be two pseudo-
random generators (PRGs). For α ∈[0, 2h), we write α = P
i∈[h] 2h−iαi, where
αi ∈{0, 1} and we denote the complement of αi by ¯αi. The GGM algorithms
GGM.KeyGen, GGM.Gen, GGM.Eval are defined as follows:
– GGM.KeyGen: on input 1κ, output s
$←{0, 1}κ.
– GGM.Gen: on input n and s ∈{0, 1}κ, where n = 2h,
(a) Set S0,0 := s.
(b) For i ∈[h −1] and j ∈{0, 1, ..., 2i−1 −1}, compute (S2j,i, S2j+1,i) :=
G(Sj,i−1), where S2j,i (S2j+1,i resp.) is the left (right resp.) child of Sj,i−1.
(c) For j ∈[0, 2h−1), compute (v2j,h, v2j+1,h, Γj) := G′(Sj,h−1).
(d) For i ∈[h−1], set K0,i := L
j∈[0,2i−1) S2j,i and K1,i := L
j∈[0,2i−1) S2j+1,i,
i.e. XOR of left (right) nodes in layer i, respectively.
(e) Set K0,h := P
j∈[0,2h−1) S2j,h and K1,h := P
j∈[0,2h−1) S2j+1,h, i.e. sum of
left (right) leaves, respectively.
(f) Output ({vj}j∈[0,n), {(K0,i, K1,i)}i∈[h]), {Γj}j∈[0,2h−1).
– GGM.Eval: On input α, {Ki}i∈[h], where α ∈[0, n),
(a) Set S1
¯α1 := K1, and x := 0.
(b) For i ∈[h −2],
i. Update x by 2x + αi.
ii. For j ∈[0, 2i)\{x}, compute (S2j,i+1, S2j+1,i+1) := G(Sj,i).
iii. Compute S2x+¯αi+1,i+1 := Ki+1 ⊕L
j∈[0,2i)\{x} S2j+¯αi+1,i+1.
(c) Update x by 2x + αh−1.
i. For j ∈[0, 2h−1)\{x}, compute (v2j, v2j+1, Γj) := G′(Sj,h−1).
ii. Compute v2x+¯αh := Kh −P
j∈[0,2h−1)\{x} v2j+¯αh.
(d) Output ({vj}j∈[0,n)\{α}).
– GGM.Eval′: On input α, {Ki}i∈[h] and K1,h+1, where α ∈[0, n),
(a) Set S1
¯α1 := K1, and x := 0.
(b) For i ∈[h −1],
i. Update x by 2x + αi.
ii. For j ∈[0, 2i)\{x}, compute (S2j,i+1, S2j+1,i+1) := G(Sj,i).
iii. Compute S2x+¯αi+1,i+1 := Ki+1 ⊕L
j∈[0,2i)\{x} S2j+¯αi+1,i+1.
(c)
i. For j ∈[0, 2h)\{α}, compute (v2j, v2j+1, Γj) := G′(Sj,h−1).
ii. Compute Γα := K1,h+1 ⊕L
j∈[0,2h)\{α} Γj.
(d) Output ({(v2j, v2j+1)}j∈[0,n)\{α}, {Γj}j∈[0,n)).
Fig. 18: Algorithms for GGM tree based PPRF.
35

Definition 4 (Dual LPN). Let D(R) = {Dt,n(R)} be the family of distribu-
tions over the ring R where for any integers t ≤n, Im(Dt,n(R)) ⊂Rn. Let G⊥
be a probabilistic dual code generation algorithm such that G⊥(m, n, R) outputs a
parity check matrix H ∈Rn×(n−m). Let parameters m, n, t be implicit functions
of security parameter κ. We say that the decisional dual (D, G, R)-LPN(m, n, t)
problem is (T, ϵ)-hard if for every probabilistic distinguisher B running in time
T, we have that
|Pr[B(H, e · H) = 1] −Pr[B(H, u) = 1]| ≤ϵ,
where H ←G⊥(m, n, R), u
$←Rm, and e ←Dt,n(R).
We mainly consider three kinds of noise distributions in this paper:
Bernoulli. Let Ber(R) = {Berλ,n(R)}λ,n be the family of Bernoulli distributions.
e ←Berλ,n(R) indicates that each entry of e is a uniformly random element in R
with probability λ and zero with probability 1 −λ. Thus the expected Hamming
weight of e is λN(|R| −1)/|R|. We remark that this definition is equivalent to
sampling a uniformly non-zero element in R with probability λN(|R| −1)/|R|
for each entry.
Fixed Hamming weight. Let HW(R) = {HWt,n(R)}t,n be the family of distribu-
tions of uniformly random vectors with fixed Hamming weight. Let H denote
the set {e ∈Rn | wt(e) = t}. Thus we have e ←HWt,n(R) ⇐⇒e ←UH.
Regular Hamming weight. Let RG(R) = {RGt,n(R)}t,n be the family of
distributions of uniformly random regular weight vectors. W.o.l.g. we assume
t|n and let e = (e(1), ..., e(t)), where e(i) ∈Rn/t, i ∈[t]. Let G denote the set
{e ∈Rn | wt(e(i)) = 1, i ∈[t]}. Thus we have e ←RGt,n(R) ⇐⇒e ←UG, and
RG(R) can be viewed as a special case of HW(R).
B.2
Reductions for LPN over GR(2k, d)
Theorem 9 (Theorem 7, restated). If decisional (D, G, GR(2k, d))−LPN(m, n, w1)
is (T, ϵ)-hard, then decisional (D, G, F2d)−LPN(m, n, w2) is (T−poly(m, n), O(hϵ))-
hard, where (D, w1, w2, h) ∈{(HW, t, 2d(k−1)(2d−1)
2dk−1
t,
√
t), (Ber, λ, λ, 1)}.
Proof. Let (A, b := x·A+e) be an LPN instance over GR(2k, d). As GR(2k, d)/(2) ∼=
F2d, we observe that (A(0) := A mod 2, b(0) := b mod 2) constitute exactly the
LPN samples over F2d for noise e(0) := e mod 2. Since e ←HWt,n(GR(2k, d)),
the noise vector e(0) follows a Bernoulli-like distribution over F2d. Further, it
can be observed that e(0) has expected weight t′ = 2d(k−1)(2d−1)
2dk−1
· t. One can nat-
urally generalize Lemma 2 in [46] and obtain that the noise vector e(0) follows
the uniform fixed-weight distribution HWt′,n(F2d) with probability Ω
 1/
√
t

. On
the other hand, (A(0), u(0)) are uniformly random as well. Therefore, one can
use a (HW, G, F2d) −LPN(m, n, t′) distinguisher to distinguish (A(0), b(0)) from
uniform samples. The proof for the second statement is similar, except that for
e ←Berλ,n(GR(2k, d)), one can immediately gets that e(0) ∼Berλ,n(F2d).
⊓⊔
36

Theorem 10 (Theorem 8, restated). If decisional (Ber, F2d)−LPN(m, n,
λ(2d−1)
(1−λ)2dk+λ2d )
is (T, ϵ)-hard, then decisional (Ber, GR(2k, d))−LPN(m, n, λ) is (T−poly(m, n), kϵ)-
hard.
Proof. Let (A, b := x·A+e) be an LPN instance over GR(2k, d). As GR(2k, d)/(2) ∼=
F2d, for any a ∈GR(2k, d), it can be uniquely written as the form
a = a(0) + a(1) · 2 + ... + a(k−1) · 2k−1,
where a(i) ∈F2d, i ∈[0, k). Thus, we can define a decomposition function
Decom such that (a(0), a(1), ..., a(k−1)) := Decom(a) ∈Fk
2d. We use Decom to
decompose the matrix and vectors, and we obtain (A(0), A(1), ..., A(k−1)) :=
Decom(A), (x(0), x(1), ..., x(k−1)) := Decom(x), (e(0), e(1), ..., e(k−1)) := Decom(e),
(b(0), b(1), ..., b(k−1)) := Decom(b). Therefore, we have b(0) = x(0) · A(0) + e(0),
and for i ∈[0, k), we have that
b(i) = (x(i) · A(0) + e(i)) + fi(A, x(0), ..., x(i−1), e(0), ..., e(i−1))
mod 2,
where fi is the sum of all other terms involving the individual x(j) and e(j) with
j ≤i −1. Define the hybrid distributions H0, ..., Hk as follows:
H0 = (A, u(0), ..., u(i−1), u(i), ..., u(k−1))
Hi = (A, b(0), ..., b(i−1), u(i), ..., u(k−1))
Hk = (A, b(0), ..., b(i−1), b(i), ..., b(k−1))
where u(i)
$←Fn
2d for i = 0, 1, ..., k −1. Since x is sampled uniformly at
random, its decomposition x(i) are independent and uniformly random as well.
To distinguish the adjacent hybrids Hi and Hi+1, it suffices to distinguish u(i)
and b(i) with the knowledge of (b(0), ..., b(i−1)). The fi term can be neglected
if the effective noise rate of e(i) conditioned on e(0), ..., e(i−1) is sufficient to
make b(i) pseudorandom. Consider a single noise sample (e(0)
j , e(1)
j , ..., e(k−1)
j
) ←
Decom(Berλ,n(GR(2k, d))), where e(i)
j
is the j-th entry of e(i). If there exists a non-
zero component in (e(0)
j , e(1)
j , ..., e(i−1)
j
), e(i)
j
must be uniformly random, which
makes b(i)
j
uniformly random. Thus, we have that
Pr
h
e(i)
j
̸= 0
 (e(0)
j , e(1)
j , ..., e(i−1)
j
) = 0
i
= λ(2d −1)(2−d(i+1))
1 −λ + λ2−di
is the noise rate needed to keep the computational indistinguishability between Hi
and Hi+1, which reaches its minimum when i = k −1.
⊓⊔
B.3
Attacks on LPN over Galois Rings
We are not aware of any advantages for attacks over Galois rings compared to
Galois fields. Therefore, we review the main attacks that may work on LPN over
Galois rings, following the analysis of previous works [32,14,15,4,46,17].
37

Pooled Gaussian Elimination This attack takes time
 n
t

 n−m
t
 · m2.8, which
was estimated as (
n
n−t)m · m2.8 in [14]. By the following inequality,
 n
t

 n−m
t
 = n!(n −m −t)!
(n −m)!(n −t)! =
t−1
Y
i=0
(n −i)/
t−1
Y
i=0
(n −m −i) > (
n
n −m)t,
we obtain a more accurate estimation for LPN with low noise, i.e. (
n
n−m)t · m2.8.
We give the comparison in Table 2. Therefore, we use this formula to estimate
the complexity of Pooled Gaussian Elimination attack.
Table 2: Comparison of two estimations.
LPN parameters
Complexity(bit)
m
n
t
Gauss
Estimation[14]
Estimation(ours)
108112
358620
215
158.15
140.36
158.11
148912
649590
295
158.96
145.71
158.93
Statistical Decoding (SD) The authors of [14] simplified the complexity of
the SD attack [28] by log(m + 1) + t · log
n
n−m−1. A recent work [46] pointed out
that to succeed with constant advantage, SD attack requires at most
log(m + 1) + 2 ·

log
 n
t

−log
 n−m−1
t

+ log
2|Fq|
|Fq| −1

bits arithmetic operations over Fq. According to the proof of Theorem 10 of [46],
we observe that only the term log
2|Fq|
|Fq|−1 relates to the algebraic structure of the
ring (essentially, the fraction of units of the ring). Therefore, we can naturally
adapt their results to Galois rings, and we obtain that the bit security of the
LPN instance with respect to SD attack is computed as
log(m + 1) + 2 ·

log
 n
t

−log
 n−m−1
t

+ log
2pd
pd −1

≈log(m + 1) + 2t · (log
n
n −m −1) + 2.
Information Set Decoding (ISD) The authors of [46] analysed known ISD
variants for different field size and show that the generalized SD-ISD attack [48] is
equivalent to the pooled Gaussian attack for large fields. Since LPN over GR(2k, d)
can be reduced to LPN over F2d and d is set linear in the statistical security
parameter κ in our constructions, the generalized SD-ISD attack is equivalent to
the pooled Gaussian attack on LPN instantiations for our VOLE constructions.
Algebraic Geometry Attack [17] To our best knowledge, this is the only
attack on LPN that is able to exploit the regular noise distribution. The algebraic
38

geometry attack performs better than Pooled Gaussian Elimination, SD, ISD
attacks, on solving regular LPN problems with a small code rate (i.e., m/n). As
most PCG applications suggest the dimension parameter m to be relatively large,
the algebraic geometry attack has few advantages in these settings.
From above discussions, we can use the pooled Gaussian attack to estimate
the LPN security of our constructions.
C
Deferred Proofs of Zero-Knowledge Protocols
C.1
Security of re-embedding VOLE
Theorem 11 (Theorem 1, restated). ΠGR(2k,d)
embVOLE UC-realizes FGR(2k,d)
embVOLE in
the FGR(2k,d)
VOLE
-hybrid model. In particular, no PPT environment Z can distinguish
the real world execution from the ideal world simulation except with advantage at
most 2−s + 2−d.
Proof. We divide our proof into two parts. First, we consider PS is corrupted
and construct a PPT simulator SS, then we consider PR is corrupted and build
a PPT simulator SR as well. Both Simulators interact with the corrupted party
in the ideal world and can read the corrupted party’s inputs to the functionality
FGR(2k,d)
VOLE .
Corrupted PS: Whenever the Extend-pair procedure is going to run, SS acts
as follows:
1. SS reads M, x ∈GR(2k, d)n+s that A sends to FGR(2k,d)
VOLE .
2. Upon receiving η ∈GR(2k, d)n+s from A, if η /∈Ker(ψ)n+s, SS aborts. SS
sets M′ := M.
3. SS samples χ(1), ..., χ(s)
$←Zn
2k, and sends them to A.
4. Upon receiving a, b ∈GR(2k, d)s from A. If bi −ai ̸= ηn+i + P
j∈[n] χ(i)
j
· ηj,
for some i ∈[s], or b /∈Im(ϕ)s, SS aborts.
5. SS receives ˆMi, i ∈[s] from A. SS computes ˆM′
i := Mn+i + P
j∈[n] χ(i)
j · Mj,
for i ∈[s]. If both η = (τ(x)−x) and ˆM = ˆM′ hold, SS sends (x[1 : n], M[1 :
n]) to FGR(2k,d)
embVOLE. Otherwise, SS aborts.
It can be observed that when SS aborts in step 2 or step 4 of the simulation,
the honest PR aborts in corresponding step of the protocol as well. Besides,
χ(1), ..., χ(s) are sampled in the same way of the ideal simulation and real exe-
cution. Therefore, it remains to consider the check of step 5. Basically, A can
cheat by sending η ∈Ker(ψ)n+s, but η ̸= τ(x) −x. Let η = τ(x) −x + ε, where
ε ∈Ker(ψ)n+s. We have that
η = τ(x) −(x −ε) = τ(x −ε) −(x −ε).
Therefore, A can set
a∗
i := (xn+i −εn+i) +
X
j∈[n]
χ(i)
j
· (xj −εj),
39

and
b∗
i := τ(xn+i −εn+i) +
X
j∈[n]
χ(i)
j
· τ(xj −εj) = τ(xn+i) +
X
j∈[n]
χ(i)
j
· τ(xj) = bi,
for i ∈[s]. These a∗
i , b∗
i would pass the check of honest PR. Now in real protocol,
we have that
ˆM′
i = Kn+i +
X
j∈[n]
χ(i)
j
· Kj −∆· a∗
i
= (Mn+i + ∆xn+i) +
X
j∈[n]
χ(i)
j (Mj + ∆xj) −∆(xn+i −εn+i +
X
j∈[n]
χ(i)
j (xj −εj))
= Mn+i +
X
j∈[n]
χ(i)
j
· Mj + ∆· (εn+i +
X
j∈[n]
χ(i)
j
· εj)
= ˆMi + ∆· (εn+i +
X
j∈[n]
χ(i)
j
· εj).
Thus, the check ˆM = ˆM′ passes if and only if
∆· (εn+i +
X
j∈[n]
χ(i)
j
· εj) = 0,
for all i ∈[s]. If εn+i +P
i∈[n] χ(i)
j ·εj ̸= 0, from lemma 1, the above equality holds
with probability at most 2−d. Since χ(i)
j
∈Z2k, for j ∈[n], εn+i+P
j∈[n] χ(i)
j ·εj = 0
holds with probability at most 1/2. Combining together, ˆM = ˆM′ holds with
probability at most 2−s+2−d in real execution if η ̸= τ(x)−x, while in simulation,
this will leads to abort. Note that if η is correct, the outputs of honest PR are
computed in the same way in two worlds. Therefore, environment Z can distinguish
the ideal simulation and real execution with advantage at most 2−s + 2−d.
Corrupted PR: SR reads ∆∈GR(2k, d) that A sends to FGR(2k,d)
VOLE
in the Init
procedure. SR then sends ∆to FGR(2k,d)
embVOLE. Every time the Extend-pair procedure
is executed, SR does as follows:
1. SR records K ∈GR(2k, d)n+s sent by A. Upon receiving η ∈Ker(ψ)n from
FGR(2k,d)
embVOLE, SR samples η′
$←Ker(ψ)s and sends ˆη := (η, η′) ∈Ker(ψ)n+s
to A.
2. SR sets K′ := K + ∆· ˆη. Upon receiving χ(i) ∈Zn
2k, i ∈[s] from A, SR
samples b
$←Im(ϕ)s, and computes ai := bi −ηn+i −P
j∈[n] χ(i)
j
· ηj, for
i ∈[s]. Then, SR sends a, b to A.
3. SR computes ˆMi := Kn+i + P
j∈[n] χ(i)
j
· Kj −∆· ai, for i ∈[s]. SR sends
ˆM to A.
4. SR sends K[1 : n] to FGR(2k,d)
embVOLE.
40

The indistinguishability between ideal simulation and real execution for corrupted
PR is simple. We first consider the view of A. In real protocol, A receives
η ∈Ker(ψ)n+s. Since x is distributed uniformly at random in GR(2k, d)n+s, η
is distributed uniformly at random in Ker(ψ)n+s. While in simulation, ˆη are
uniformly sampled from Ker(ψ)n+s as well. As for (a, b = τ(a)) in real protocol,
a is masked with x[n + 1 : n + s], which makes b have the uniform distribution on
Im(ϕ)s. Thus, (a, b) generated by SR have the same distribution as that in the
real protocol. The final message that A receives from SR is ˆM. It can be easily
verified that
ˆM′
i = Kn+i +
X
j∈[n]
χ(i)
j
· Kj −∆· ai = Mn+i +
X
j∈[n]
χ(i)
j
· Mj = ˆMi,
Thus ˆM has the same distribution in both worlds. Finally, we turn to the output
of the honest PS. In real protocol, xi is conditioned on that τ(xi) −xi = ηi, for
all i ∈[n], while they have the same properties in ideal simulation. Therefore, no
PPT environment Z can distinguish the ideal simulation and the real execution.
This completes the proof.
⊓⊔
C.2
Security of Πm,n,t
ZK
Theorem 12 (Theorem 2, restated). Protocol Πm,n,t
ZK
UC-realizes Fm
ZK in the
FGR(2k,d)
embVOLE-hybrid model with soundness error 2−(d−2) and information-theoretic
security.
Proof. We divide our proof into two parts. First, we consider P is corrupted, then
we consider V is corrupted. In each case, we build a PPT simulator S to interact
with the corrupted party in the ideal world, which can read the corrupted party’s
inputs to functionalities FGR(2k,d)
embVOLE.
Corrupted P: S interacts with A as follows:
1. S samples ∆
$←GR(2k, d) and records (µ, Mµ, M′
µ), (ν, Mν, M′
ν) and (π, Mπ)
that A sends to FGR(2k,d)
embVOLE. Thus, S can immediately obtain the MACs
([µi], [τ(µi)])i∈[n], ([νi], [τ(νi)])i∈[t], [π].
2. Upon receiving δ from A, S checks δ −τ(δ) = τ(µ) −µ. If the check fails,
aborts. S can locally compute [τ(ωi)] := [τ(µi)] + τ(δi), for i ∈[n].
3. S runs the rest of the protocol as an honest verifier, using the MACs gen-
erated in previous steps. If the honest verifier outputs true, S computes
(w(1), w(2), ..., w(m)) := ψ(τ(ω)) and then sends them and the circuit C to
Fm
ZK. Otherwise, S sends w := ⊥and C to Fm
ZK and aborts.
From the simulation, we can see that S behaves like an honest verifier towards A,
therefore, the environment Z can not distinguish the ideal simulation and real
execution from the adversary A’s view. Note that Z has access to the output of
the honest party, the situation remains to be considered is that honest verifier V
accepts the proof while A does not hold m witnesses. Below we show the probability
41

that V accepts a proof of wrong statements (i.e. the soundness error) is upper
bounded by 1/2d−2.
First we claim that A has to prepare a ω ∈Im(ϕ)n, which can be one to
one corresponded to m instances of Zn
2k. The proof is direct since the check
δ −τ(δ) = τ(µ) −µ guarantees that
ω = δ + µ = τ(δ) + τ(µ) = τ(δ + µ) = τ(ω).
Next we prove that all the values on the wires in the circuit are correct. It can be
immediately obtained that the values associated with input wires and the output
wires of Add gates are computed correctly, since ϕ, ψ, τ are Z2k-linear. Thus,
we need to consider the correctness of values on the output wires of Mul gates,
which is guaranteed by the correctness of di, for all i ∈[t] in our protocol Πm,n,k
ZK
.
Consider that some of components of d are incorrect, e.g. there is an error in the
i-th Mul gate. Let di := ωα · ωβ −νi + ei, where ei ∈GR(2k, d). Thus we have that
Kˆωγ : = Kνi + ∆· di = Kνi + ∆· (ωα · ωβ −νi + ei)
= Mνi + ∆· νi + ∆· (ωα · ωβ −νi + ei)
= Mˆωγ + ∆· (ωα · ωβ) + ∆· ei,
and
Bi : = Kωα · Kωβ −∆· Kˆωγ
= (Mωα + ∆· ωα) · (Mωβ + ∆· ωα) −∆· (Mˆωγ + ∆· (ωα · ωβ) + ∆· ei)
= (Mωα · Mωβ) + ∆· (ωα · Mωβ + ωβ · Mωα −Mˆωγ) −∆2 · ei
= A0,i + ∆· A1,i −∆2 · ei,
which leads to
Z : =
X
i∈[t]
χi · Bi + B∗
= X + ∆· Y −∆2 · (
X
i∈[t]
χi · ei).
Assume A sends X′ = X + eX and Y ′ = Y + eY to honest verifier, where
eX, eY ∈GR(2k, d). V accepts if and only if
Z = X′ + ∆· Y ′ ⇐⇒0 = eX + ∆· eY + ∆2 · (
X
i∈[t]
χi · ei).
χi is sampled by honest verifier after ei is determined, and eX, eY can be picked
by A after knowing χ. If P
i∈[t] χi · ei ̸= 0, from lemma 1, we obtain that the
above equation holds with probability at most 2−(d−1). Otherwise, A can pass the
check with probability 1 (just sets eX = eY = 0). Since the coefficients χi ∈F2d
are sampled uniformly at random, it suffices to consider there exists a j ∈[t] such
that ej ̸= 0, and ei = 0 for i ̸= j. As Pr[χj = 0] = 1/2d, we obtain that it occurs
with probability at most 2−d.
42

Finally, we show that if C(w(i)) = 0, for some i ∈[m], and all the values on
the wires in the circuit are correct, the probability that A successfully provides a
M′
ωh := Mωh + eωh such that Kωh = M′
ωh + ∆· ϕ(1) is upper bounded by 2−d.
Let r := (C(w(1)), ..., C(w(m))) ∈{0, 1}m. After executing the protocol, We have
Kωh = Mωh + ∆· ϕ(r).
Thus, honest verifier accepts if and only if
Kωh = M′
ωh + ∆· ϕ(1) ⇐⇒0 = eωh + ∆· ϕ(1 −r),
which holds for a random ∆∈GR(2k, d) with probability at most 1/2−d from
lemma 1.
Thus, the overall soundness error is bounded by 2−d+2−(d−1)+2−d = 2−(d−2).
Namely, a PPT Z can distinguish between the real world and the ideal world with
advantage at most 2−(d−2).
Corrupted V: If S receives false from Fm
ZK, then it just aborts. Otherwise, S
interacts with A as follows:
1. In the offline phase: S records ∆∈GR(2k, d) that A sends to FGR(2k,d)
embVOLE in the
Init procedure, also, S records (Kµ, K′
µ), (Kν, K′
ν) and Kπ that A sends to
FGR(2k,d)
embVOLE. Besides, S samples τ(µ)−µ
$←Ker(ψ)n and τ(ν)−ν
$←Ker(ψ)t,
and sends them to A.
2. S samples τ(δ)
$←Im(ϕ)n and sets δ := τ(δ) + τ(µ) −µ. S sends δ to
A. S computes Kτ(ωi) := K′
µi + ∆· τ(δi), for i ∈[n]. Besides, S samples
ω
$←Im(ϕ)n.
3. For each gate (α, β, γ, T) ∈C, in a topological order:
– If T=Add, S computes Kωγ := Kωα + Kωβ as the honest V would do,
and sets ωγ := ωα + ωβ.
– If T=Mul, and this is the i-th multiplication gate, then S sends di :=
ωα ·ωβ −νi to A. S computes Kωγ := K′
νi +∆·τ(di), Kˆωγ := Kνi +∆·di
and Bi := Kωα · Kωβ −∆· Kˆωγ as the honest verifier would do, and sets
ωγ := τ(ωα · ωβ).
4. S receives χ ∈Zt
2k from A.
5. S computes Z := P
i∈[t] χi · Bi + B∗∈GR(2k, d), where B∗:= Kπ. Then S
samples Y
$←GR(2k, d) and sets X := Z −∆· Y . S sends (X, Y ) to A.
6. For the single output wire ωh, S already holds Kωh. S computes Mωh :=
Kωh −∆· ϕ(1), and sends Mωh to A.
Since GR(2k, d) = Im(ϕ)⊕Ker(ψ), the distribution of δ conditioned on δ −τ(δ) =
τ(µ) −µ is equivalent to that of δ := τ(δ) + τ(µ) −µ where τ(δ) are sampled
uniformly at random in Im(ϕ)n. Further, δ is sufficient to perfectly hide the
circuit inputs ω := ϕ(W) in Im(ϕ)n. Similarly, di perfectly hides the output
value of i-th Mul gate in Im(ϕ). Moreover, X, Y provided by honest prover are
uniformly random thanks to the masks A∗
0, A∗
1, respectively, under the condition
that Z = X +∆·Y holds. Therefore, Z’s view in real execution is indistinguishable
to that in simulation. This completes the proof.
⊓⊔
43

C.3
Our ZK protocol with sublinear communication
Protocol ΠPAC
Let AHE = (KeyGen, Enc, Dec) be an additively homomorphic encryption scheme
over GR(2k, d) with CPA security, degree-restriction and circuit privacy. Let
(Commit, Open) be a commitment scheme. Let G be a PRG, and m be the maximum
degree of the polynomials to be authenticated.
Init: P and V send (Init) to F GR(2k,d)
embVOLE, and V receives ∆∈GR(2k, d).
Poly-Key: On input m:
1. V samples seed
$←{0, 1}κ, and computes (com1, unv1) ←Commit(seed). Then
V sends com1 to P.
2. V samples Λ
$←GR(2k, d) and obtain ciphertexts ⟨Λi⟩:= Enc(sk, Λi; ri) for all
i ∈[m], where (r0, r1, ..., rm) ←G(seed) and sk ←KeyGen(r0). Then V sends
⟨Λ1⟩, ..., ⟨Λm⟩to P.
Pre-Gen: On input [u]:
1. For the input MACs [u], suppose P holds u, w ∈GR(2k, d)n and V holds
w ∈GR(2k, d)n such that w := v −∆· u.
2. For each j ∈[n], on input the j-th polynomial fj(X) = P
i∈[0,m] fj,i · Xi ∈
GR(2k, d)[X], P computes a ciphertext ⟨bj⟩:= P
i∈[m] fj,i · ⟨Λi⟩+ fj,0 −uj.
3. P computes (com2, unv2) ←Commit(⟨b1⟩, ..., ⟨bn⟩), and sends com2 to V.
Gen:
1. V sends (unv1, seed) and Λ to P. P checks Open(com1, unv1, seed) = 1. If the
check fails, P aborts. Then, P computes (r0, r1, ..., rm) ←G(seed) and obtains
sk ←KeyGen(r0). P checks that ⟨Λi⟩= Enc(sk, Λi; ri) for all i ∈[m], and
aborts if the check fails. For each j ∈[n], P sets Mj := wj.
2. P sends (unv2, ⟨b1⟩, ..., ⟨bn⟩) to V. V checks Open(com2, unv2, ⟨b1⟩, ..., ⟨bn⟩) =
1. If the check fails, V aborts. Then, for j ∈[n], V computes bj := Dec(sk, ⟨bj⟩),
and sets Kj := vj + ∆· bj. Thus, P and V obtain a PAC [fj(·)], for each
j ∈[n].
Fig. 19: Protocol for generating PACs over GR(2k, d).
Theorem 13 (Theorem 3, restated). Protocol Πm,n,t
slZK
UC-realizes function-
ality Fm
ZK that proves circuit satisfiability over Z2k in the FGR(2k,d)
embVOLE-hybrid model
and the random oracle model with soundness error at most 2m2+3
2d
+ negl(κ).
Proof. Since the proof has the similar structure to that in AntMan [54], hence we
only explain the difference here. The readers may refer to [54] for more details.
44

Note that for the BatchCheck procedure, we let V check that f(αi) = τ(g(βi)),
for i ∈[t], which in fact is an equality constraint over Z2k. Apparently, this
modification would not raise any more considerations of the proof. Another main
difference is that we use an ideal functionality FGR(2k,d)
embVOLE which delivers MACs
of random re-embedding pairs (µ, τ(µ)) over Galois rings. Recall that we let
FGR(2k,d)
embVOLE additionally send µ −τ(µ) to V, as explained before in the proof
of Theorem 2, this leakage would not influence the privacy of witnesses over
Z2k and it guarantees S can extract SIMD witnesses correctly if the sender is
corrupted. Specifically, we instantiate the DVZK procedure in [54] by the LPZK-
based approach, namely the multiplication check procedure in protocol Πm,n,t
ZK
.
According to Lemma 1 and the upper bound in the Galois field case, the soundness
error in the Galois ring case is upper bounded by 2m2+3
2d
+ negl(κ). This concludes
the proof.
⊓⊔
D
Deferred Proofs of VOLE Protocols
D.1
Security of VOLE based on (N −1)-out-of-N OT
We claim that sampling ∆from F2d is sufficient for security of our ZK protocols.
Consider a simple game G0 where the challenger samples a random ∆0 ∈F2d
and asks the adversary to output a, b ∈GR(2k, d) such that α · ∆0 + β = 0, and a
similar game G1 except that the challenger randomly samples ∆from GR(2k, d).
For an adversary A that wins G1 with advantage a1, we have A wins G0 with
advantage at least a1. On the other hand, for an adversary A that wins G0 with
advantage a0, there exists an adversary B (involved in G1) who invokes A and
outputs α′ := α + 2k−1, β′ := β, where α, β are A’s outputs. It can be observed
that B wins G1 (i.e., α′ · ∆+ β = 0) as long as α · ∆0 + β = 0, since ∆can be
uniquely written as ∆= ∆0 + ∆1 · 2 + ... + ∆k−1 · 2k−1, where ∆i ∈F2d, for
i ∈[0, k). Therefore, B wins G1 with advantage a0. Combining together, G0 and
G1 are equivalent. Note that in our protocol, e.g. Πm,n,t
ZK
, the malicious sender is
allowed to guess ∆∈GR(2k, d), who is essentially participating in G1.
We remark that the above discussion also indicates why we can sample random
coefficients from F2d rather than GR(2k, d) for the random linear combination
check.
Theorem 14 (Theorem 4, restated). Protocol ΠGR(2k,d)
sfVOLE UC realizes FGR(2k,d)
sfVOLE
(Figure 15) in the FN
OT−¯1-hybrid model.
Proof. If the sender PS is corrupted. The simulator SS records {sy}y∈[N] sent
by A. Then SS computes M := −P
y∈F2d sy · y and x := P
y∈F2d sy. Finally, SS
sends M, x ∈GR(2k, d)l to the ideal functionality FGR(2k,d)
sfVOLE . The indistinguishabil-
ity between two worlds is straightforward.
If the receiver PR is corrupted. The simulator SR records ∆∈[N] and
{sy}y∈[N]\∆sent by A in the Init phase, and forwards ∆to the ideal func-
tionality FGR(2k,d)
sfVOLE . Then SR computes K = P
y∈F2d\{∆} sy · (∆−y) and sends
45

K ∈GR(2k, d)l to FGR(2k,d)
sfVOLE . The indistinguishability between two worlds is straight-
forward as well. This concludes the proof.
⊓⊔
D.2
Security of VOLE based on primal LPN
Theorem 15 (Theorem 5, restated). If G and G′ are PRGs, then ΠGR(2k,d)
spVOLE
UC-realizes FGR(2k,d)
spVOLE functionality in the (FGR(2k,d)
VOLE , FOT, FEQ)-hybrid model. In
particular, no PPT environment Z can distinguish the real world execution from
the ideal world simulation except with advantage at most 1/2d + negl(κ).
Proof. We divide our proof into two parts. First, we consider PS is corrupted
and construct a PPT simulator SS, then we consider PR is corrupted and build
a PPT simulator SR as well. Both Simulators interact with the corrupted party
in the ideal world and can read the corrupted party’s inputs to functionalities
FGR(2k,d)
VOLE , FOT, FEQ.
Corrupted PS: Each time the SP-Extend procedure is going to run, SS acts as
follows:
1. SS reads the values (a, c) that A sends to FGR(2k,d)
VOLE . Upon receiving a′ ∈
GR(2k, d) from A, SS sets β := a′ + a ∈GR(2k, d) and δ := c.
2. For i ∈[1, h), SS samples Ki
$←{0, 1}κ, and SS samples Kh
$←GR(2k, d).
Then SS reads the choices ¯αi ∈{0, 1}, i ∈[h] that A sends to FOT, and
sends Ki
¯αi := Ki to A. SS computes α := P
i∈[h] 2h−i · αi and defines a
vector u ∈GR(2k, d)n such that uα = β and ui = 0 for i ̸= α. Next, SS runs
GGM.Eval(α, {Ki
¯αi}i∈[h]) and obtains {vj}j̸=α.
3. SS samples g
$←GR(2k, d) and sends it to A. Then SS defines a vector
w ∈GR(2k, d)n such that wα = δ −(g + P
i̸=α vi) and wi = vi for i ̸= α.
4. SS reads the values (x, z) that A sends to FGR(2k,d)
VOLE .
5. Upon receiving {χi}i∈[0,n) and x∗∈GR(2k, d) from A, SS sets x′ := x∗+ x ∈
GR(2k, d).
6. SS reads the values VPS that A sends to FEQ. Then SS computes V ′
PS :=
P
i∈[0,n) χi · wi −z and does as follows:
(a) If x′ = χα · β, then SS checks whether VPS = V ′
PS. If so, SS sends true
to A, and sends u, w to FGR(2k,d)
spVOLE. Otherwise, SS sends abort to A and
aborts.
(b) If x′ ̸= χα · β, since every q ∈GR(2k, d) can be represented as q =
P
i∈[0,k) qi · 2i, qi ∈F2d. Let idq denote the least index such that qidq ̸= 0
(define id0 := k). It can be observed that q is invertible in GR(2k, d) if and
only if idq = 0. Let ε := V ′
PS −VPS and η := x′ −χα · β, we have that
– If idε < idη, SS sends abort to A and aborts.
– If idε ≥idη, SS computes ∆′ :=
ε
2idη · (
η
2idη )−1 mod 2k−idη, and
sends a global-key query (Guess, ∆′, k −idη) to FGR(2k,d)
spVOLE. If FGR(2k,d)
spVOLE
returns success, SS sends true to A, and sends u, w to FGR(2k,d)
spVOLE.
Otherwise, SS sends abort to A and aborts.
46

The Init procedure can be called only once, and it can be perfectly sim-
ulated by forwarding Init from A to FGR(2k,d)
spVOLE. Thus, we focus on analysing
indistinguishability between the SP-Extend procedures.
SS can record a, c that A sends to FGR(2k,d)
VOLE . From the construction of GGM
tree, it can be observed that K1
0, K1
1 are pseudorandom. Further, we have that
K2
0, K2
1 are pseudorandom as well conditioned on K1
0 or K1
1. By induction, we
obtain that Ki
¯αi is pseudorandom conditioned on {Kj
¯αj}j<i, for i ∈[h]. Therefore,
we claim that {Ki
¯αi}i∈[h] are pseudorandom, which indicates that Ki, i ∈[h]
provided by SS are computationally indistinguishable to those in real execution.
In real protocol, γ is uniformly random in A’s view, since ∆is uniformly random
and β is a unit. Therefore, g sampled uniformly at random by SS is of the same
distribution to that masked with γ in A’s view. Now it remains to consider the
check step.
The second call (Extend, 1) enables SS to record x, z. In real protocol, honest
verifier PR computes
VPR : =
X
i∈[0,n)
χi · vi −y
=
X
i∈[0,n)
χi · wi +
X
i∈[0,n)
χi · (vi −wi) −y
=
X
i∈[0,n)
χi · wi + χα · (vα −wα) −(y∗+ ∆· x∗)
=
X
i∈[0,n)
χi · wi −(y∗−∆· x) −∆· (x∗+ x −χα · β)
= V ′
PS −∆· (x′ −χα · β).
If A behaves honestly, then x′ = χα · β will hold and FEQ will return true. Note
that SS can extract α from A’s inputs to FOT, thus SS can check x′ = χα · β.
If the equation holds, FEQ can be emulated by sending true (abort) to A when
VPS = V ′
PS (VPS ̸= V ′
PS), which is the same as in the real protocol.
Otherwise, x∗sent by A must be incorrect. Let η := x′ −χα · β and ε :=
V ′
PS −VPS. Therefore, A passes the equality test if and only if
VPS + ∆· η = V ′
PS ⇐⇒∆· η = ε,
where ∆, η, ϵ ∈GR(2k, d). Although SS does not hold ∆, he can query the global
key to FGR(2k,d)
spVOLE. Since the above equation is over GR(2k, d), there may be no
solutions for ∆, or more than one solutions for ∆. Thus the Global-key Query
is extended to allow queries of “lower bit” of ∆. It is not hard to see that the
simulation matches the real execution in this case.
Thus, we conclude that Z can not computationally distinguish the ideal simu-
lation and the real execution from joint view of A and the output of PR.
Corrupted PR: In the Init procedure, SR reads the global key ∆∈GR(2k, d)
that A sends to FGR(2k,d)
VOLE . Then whenever the SP-Extend procedure is going to
run, SR acts as follows:
47

1. SR reads b ∈GR(2k, d) that A sends to FGR(2k,d)
VOLE . SR samples a′
$←GR(2k, d)
and sends a′ to A. Then, SR draws a uniformly random β in the set of units
of GR(2k, d). Next, SR computes γ := b + ∆· a′ and δ := γ −∆· β.
2. SR reads the values (Ki
0, Ki
1)i∈[h] that A sends to FOT. Upon receiving
g ∈GR(2k, d) from A, for each α ∈[0, n), SR defines a vector w(α) such that
{w(α)
j
}j̸=α := GGM.Eval(α, {Ki
¯αi}i∈[h]) and w(α)
α
:= δ −(g + P
i̸=α w(α)
i
).
3. SR reads the value y∗that A sends to FGR(2k,d)
VOLE . SR samples χi
$←GR(2k, d)
for i ∈[0, n) and x∗
$←GR(2k, d). SR sends ({χi}i∈[0,n), x∗) to A. Then, SR
computes y := y∗+ ∆· x∗.
4. SR reads VPR that A sends to FEQ. Then SR constructs a set I ⊆[0, n) as
follows:
(a) For α ∈[0, n), compute V α
PS := P
i∈[0,n) χi · w(α)
i
+ ∆· χα · β −y.
(b) Append α satisfying V α
PS = VPR to set I, i.e. I := {α ∈[0, n) | V α
PS =
VPR}.
SR sends I to FGR(2k,d)
spVOLE. If it returns abort, SR samples ˆα
$←[0, n)\I, sends
(false, V ˆα
PS) to A (emulating FEQ), and then aborts. Otherwise, SR sends
(true, VPR) to A.
5. SR picks an arbitrary α ∈I and defines v such that vi := w(α)
i
, for i ̸= α
and vα := γ −g −P
i̸=α vi. SR sends v to FGR(2k,d)
spVOLE.
The Init procedure can be called only once, and SR learns ∆that A sends
to FGR(2k,d)
VOLE . Now we consider the simulation for the SP-Extend procedure.
In real execution, a is uniformly random in A’s view, which perfectly masks
a′ in GR(2k, d). Thus, a′ provided by SR has the same distribution as that in the
real execution. SR learns {(Ki
0, Ki
1)}i∈[h] that A sends to FOT, therefore, SR can
evaluate n punctured GGM trees with one value of the α-th leaf missed, for each
α ∈[0, n). SR learns y∗that A sends to FGR(2k,d)
VOLE . The indistinguishability of
χ ∈GR(2k, d)n is obvious and the next message that A receives from PS or SR is
x∗. Similarly, x∗is perfectly masked with x since x is uniformly random in A’s
view. Therefore, we obtain the indistinguishability of x∗between two worlds. What
remains to consider is the simulation for equality test. The set I constructed by
SR corresponds to the selective failure attack on the α∗of honest PS. This attack
can be formalized as follows: (1) A generates a GGM tree correctly and obtains
({vj}j∈[0,n), {(Ki
0, Ki
1)}i∈[h]), (2) A guesses a set I ⊆[0, n), (3) Let U denote the
union of the sets {Ki
¯αi}i∈[h], for α ∈I. A keeps the values of U unchanged and
randomizes the remaining values in {Ki
0, Ki
1}i∈[h]. (4) A runs the rest program as
an honest PR. It can be observed that if α∗∈I, then the equality check will pass,
i.e. V α∗
PS = VPR. This observation guarantees that the set I reconstructed by SR
is identical to that generated by A. Therefore, FGR(2k,d)
spVOLE aborts if and only if the
equality check fails in the real execution. Note that if |I| > 1, SR does not know
the actual α∗. However, SR is required to send v(α∗) to FGR(2k,d)
spVOLE, otherwise, Z
48

may distinguish two worlds from joint view of A and output of PS. We claim that
Pr
h
v(α) ̸= v(α′)  V α
PS = V α′
PS
i
≤1
2d .
We have that
V α
PS = V α′
PS ⇐⇒
X
i∈[0,n)
χi · w(α)
i
+ ∆· χα · β −y =
X
i∈[0,n)
χi · w(α′)
i
+ ∆· χα′ · β −y ⇐⇒
X
i∈[0,n),i̸=α,α′
χi·(w(α)
i
−w(α′)
i
)+χα(∆·β+w(α)
α −w(α′)
α
)+χα′(w(α)
α′ −∆·β−w(α′)
α′ ) = 0
Note that ∆, β, w(α), w(α′) are determined before χ sampled. Therefore, from
lemma 1, we have that
w(α)
i
= w(α′)
i
, for i ∈[0, n)\{α, α′},
and
∆· β = w(α′)
α
−w(α)
α
= w(α)
α′ −w(α′)
α′
hold except with probability 2−d. Thus we immediately obtain that v(α) = v(α′)
holds except with probability 2−d under the condition that V α
PS = V α′
PS. Thus, from
above discussion, we conclude that Z can distinguish the ideal simulation and
real execution with advantage at most 2−d. This completes the whole proof.
⊓⊔
Theorem 16 (Theorem 6, restated). If the decisional (RG, G, GR(2k, d))-
LPN(m, n, t) with static leakage assumption holds, then ΠGR(2k,d)
VOLE
UC-realizes
FGR(2k,d)
qVOLE in the FGR(2k,d)
spVOLE-hybrid model.
Proof. We divide our proof into two parts. First, we consider PS is corrupted and
construct a PPT simulator SS, then we consider PR is corrupted and build a PPT
simulator SR as well. Both Simulators interact with the corrupted party in the
ideal world and can read the corrupted party’s inputs to functionalities FGR(2k,d)
spVOLE.
Corrupted PS: SS reads the vectors u, w ∈GR(2k, d)m that A sends to FGR(2k,d)
spVOLE
in the Init procedure. Then whenever Extend procedure is going to run, SS acts
as follows:
1. For i ∈[t], SS reads e(i) ∈GR(2k, d)m (with at most one invertible entry and
zeros everywhere else) and c(i) ∈GR(2k, d)m that A sends to FGR(2k,d)
spVOLE. Let
e := (e(1), ..., e(t)) ∈GR(2k, d)n and c := (c(1), ..., c(t)) ∈GR(2k, d)n.
2. SS computes x := u · A + e ∈GR(2k, d)n and M := w · A + c ∈GR(2k, d)n.
Then SS updates u := x[1 : m] and z := M[1 : m]. Next, SS sends x[m + 1, n]
and M[m + 1, n] to FGR(2k,d)
spVOLE.
49

3. Whenever A sends a global-key query (Guess, ∆′, s′) to FGR(2k,d)
spVOLE, SS sends
(Guess, ∆′) to FGR(2k,d)
VOLE
and forwards the answer from FGR(2k,d)
VOLE
to A. If the
answer is abort, SS aborts.
The indistinguishability between simulation and execution is obvious, since
the outputs of both parties in two worlds are computed in the same way.
Corrupted PR: SR first receives ∆∈GR(2k, d) from A and reads v ∈GR(2k, d)m
that A sends to FGR(2k,d)
spVOLE in the Init procedure. SR sends ∆to FGR(2k,d)
VOLE . Then
whenever Extend procedure is going to run, SR acts as follows:
1. For i ∈[t], SR reads the vector b(i) ∈GR(2k, d)m that A sends to FGR(2k,d)
spVOLE.
Let b := (b(1), ..., b(t)) ∈GR(2k, d)n.
2. SR samples a random e := (e(1), ..., e(t)) ∈GR(2k, d)n, where each e(i) has
one invertible entry and zeros everywhere else. Let {α1, ..., αt} be the invertible
entry in {e1, ..., et}, respectively. For i ∈[t], SR reads the set Ii ⊆[0, m) that
A sends to FGR(2k,d)
spVOLE. If αi ∈Ii, then SR continues and sends success to A.
Otherwise, SR sends abort to A and aborts.
3. SR computes K := v · A + b ∈GR(2k, d)n, and updates v := K[1 : m]. SR
sends K[m + 1 : n] to FGR(2k,d)
VOLE .
It is not hard to see that e sampled by SR has the same distribution to that
provided by FGR(2k,d)
spVOLE, therefore, the probability that FGR(2k,d)
spVOLE returns success
or abort is identical in real execution and ideal simulation. For the executions
of the Extend procedure, the view of A is simulated perfectly. However, the
distribution of the output x[m + 1 : n] of the honest PS is different to that in
ideal simulation. Thus, environment Z can not distinguish between two worlds if
the the decisional (RG, G, GR(2k, d))-LPN(m, n, t) with static leakage assumption
holds. This completes the proof.
⊓⊔
E
VOLE based on dual LPN
Here we focus on reducing the round complexity of the VOLE extension protocol.
Our (primal LPN-based) construction described in Section 4.2 can not be made
two-round, since the two parties need to obtain an additional VOLE correlation
for the check. Following the approach of [15], we construct a two-round VOLE
extension protocol that relies on the ideal functionality for generalized VOLE
over Galois rings (see FGR(2k,d)
gVOLE in Figure 20). Informally in the generalized VOLE,
the two parties obtain two VOLE correlations with the same length for different
global keys, e.g. K = M + y · ∆and a = c + y · δ. The functionality FGR(2k,d)
gVOLE
can be naturally realized by OTs. To achieve malicious security, as shown in [45]
we can apply a Galois ring analogue of the eVOLE technique [30].
We provide a multi-point VOLE construction in Figure 22, which can be
viewed as a concatenation of multiple single-point VOLEs intuitively. The ideal
functionality for multi-point VOLE is presented in Figure 21.
50

Suppose the two parties want to obtain a t-point VOLE correlation, and
w.l.o.g. we assume the length n has the form t · 2h. We still use the GGM tree
construction to let the two parties obtain PPRF outputs. But, this time we
let PR calculate one more layer for each GGM tree, and view {Γi}i∈[0,2h) as
the right leaves of the last layer. For the j-th GGM tree, j ∈[t], we let PS
always learn {Γ (j)
i
}i∈[0,2h). Thus, PS can check the consistency of each GGM tree
independently, by hashing the right leaves. We remark that there is a recent work
[40] showing how to reduce the cost of generating GGM trees by half. However,
their constructions are only semi-honestly secure and it remains unclear how to
construct multi-point VOLE protocols with malicious security basing on their
techniques.
We slightly modify the GGM.Eval algorithm and obtain GGM.Eval′ in Figure
18. To ensure all the right leaves fix a unique tree, we require that G′ has the
right half injective property 11.
Functionality F GR(2k,d)
gVOLE
Init: Upon receiving (Init) from both parties, sample ∆, δ
$←GR(2k, d) if receiver
PR is honest, and receive ∆, δ ∈GR(2k, d) from the adversary A otherwise. Store
∆, δ and send them to PR. All further (Init) commands will be ignored.
Extend: Upon receiving (Extend, t) from both parties, proceed as follows:
1. If PR is honest, sample K, a
$←GR(2k, d)t. Otherwise, receive K, a from A.
2. If PS is honest, sample y
$←GR(2k, d)t with each component invertible, and
compute M := K −∆· y and c := a −δ · y. Otherwise, receive M, c, y from
A, and then recompute K := M + ∆· y and a := c + δ · y.
3. Send (M, c, y) to PS and send (K, a) to PR.
Fig. 20: Ideal functionality for generalized VOLE over GR(2k, d).
Definition 5. We say a function f = (f0, f1) : {0, 1}κ →GR(2k, d)2×{0, 1}κ has
the right half injective property, if and only if f1 : {0, 1}κ →{0, 1}κ is injective.
Then, from the j-th GGM tree, the two parties can obtain two single-point
VOLE correlations of length 2h, V(j)
0
= W(j)
0
+e(j) ·∆and V(j)
1
= W(j)
1
+e(j) ·δ.
To guarantee the VOLE correlation on the position α(j), we use a random linear
combination check that sacrifices half of the PPRF outputs, i.e. W(j)
1 , V(j)
1 . We
remark that these two checks allow the corrupted receiver to query for the noisy
11 As noted in [15], the right-half injectivity requirement can be relaxed to right-half
collision resistance, if G′ is sampled uniformly at random from a family of hash
functions that are collision-resistant in their right-half output.
51

Functionality F GR(2k,d)
mpVOLE
Init: Upon receiving (Init) from both parties, sample ∆
$←GR(2k, d) if receiver
PR is honest, and receive ∆∈GR(2k, d) from the adversary A otherwise. Store ∆
and send it to PR. All further (Init) commands will be ignored.
MP-Extend: Upon receiving (MP-Extend, n = t · 2h) from both parties, proceed
as follows:
1. If PR is honest, sample v
$←GR(2k, d)n. Otherwise, receive v from A.
2. If PS is honest, sample α1, ..., αt
$←[0, 2h), and y1, ..., yt
$←GR(2k, d)∗, and
define e(j) ∈GR(2k, d)2h such that e(j)
αj = yj and e(j)
i
= 0, i ̸= αj, for j ∈[t],
then computes w := v −∆· (e(1), ..., e(t)). Otherwise, receive e(j) with at most
one invertible entry and zeros everywhere else, for j ∈[t], and w from A, then
recompute v := w + ∆· (e(1), ..., e(t)).
3. If PR is corrupted, receive a series of sets Ij ⊆[0, 2h) from A. If αj ∈Ij for
all j ∈[t], send success to A and continue. Otherwise, send abort to both
parties and abort. Construct a set J := {j ∈[t] | |Ij| = 1}.
4. If PR is corrupted, receive a series of elements ˆαj, where ˆαj ∈Ij and j ∈[t]\J.
If ˆαj = αj for all ˆαj received from A, send success to A and continue.
Otherwise, send abort to both parties and abort.
5. Send w, (e(1), ..., e(t)) to PS and v to PR.
Fig. 21: Ideal functionality for multi-point VOLE over GR(2k, d).
52

Protocol ΠGR(2k,d)
mpVOLE
Init: Both parties send Init to F GR(2k,d)
gVOLE , which returns ∆, δ to PR.
MP-Extend: On input n = t · 2h, the parties do as follows:
Construct:
(a) Both parties send (Extend, t) to F GR(2k,d)
gVOLE , which returns (M, c, y) to PS and
(K, a) to PR such that K = M + y · ∆and a = c + y · δ, where each entry of
y is invertible.
(b) For
j
∈
[t],
both
parties
do
as
follows.
The
receiver
PR
com-
putes s(j)
←
GGM.KeyGen(1κ), and runs GGM.Gen(2h+1, s(j)) to obtain
({(v(j)
2i , v(j)
2i+1, Γ (j)
i
)}i∈[0,2h), {(K(j)
0,i , K(j)
1,i )}i∈[h+1]).
Recompute
K(j)
1,h+1
:=
L
i∈[0,2h) Γ (j)
i
. Let α(j)
=
P
i∈[h] 2h−iα(j)
i , where α(j)
i
$←
{0, 1}, and
let ¯α(j)
i
denote the complement of α(j)
i . For i ∈[h], PS sends ¯α(j)
i
to
FOT while PR sends (K(j)
0,i , K(j)
1,i ) to FOT, then PS receives K(j)
¯α(j)
i
,i. PR
sends K(j)
1,h+1 to PS. PS runs GGM.Eval′(α(j), {K(j)
¯α(j)
i
,i}i∈[h], K(j)
1,h+1) and gets
({(v(j)
2i , v(j)
2i+1)}i̸=α(j), {Γ (j)
i
}i∈[0,2h)). Additionally, PR sends g(j)
0
:= Kj −
P
i∈[0,2h) v(j)
2i and g(j)
1
:= aj −P
i∈[0,2h) v(j)
2i+1 ∈GR(2k, d) to PS.
(c) PS defines vectors W(j)
0 , W(j)
1
∈GR(2k, d)2h such that W(j)
0,i = v(j)
2i , W(j)
1,i =
v(j)
2i+1 for i ̸= α(j) and W(j)
0,α(j) := Mj −(g(j)
0
+ P
i̸=αj W(j)
0,i), W(j)
1,α(j) :=
cj −(g(j)
1
+ P
i̸=α(j) W(j)
1,i). PR defines vectors V(j)
0
:= (v(j)
0 , v(j)
2 , ..., v(j)
2h+1−2)
and V(j)
1
:= (v(j)
1 , v(j)
3 , ..., v(j)
2h+1−1). Note that V(j)
0
= W(j)
0
+ e(j) · ∆and
V(j)
1
= W(j)
1
+ e(j) · δ, where e(j) ∈GR(2k, d)2h has only one entry invertible
in GR(2k, d) and zeros everywhere else, i.e. ej
αj = yj ∈GR(2k, d)∗and ej
i = 0
for i ̸= αj.
(d) PR computes Γ (j) := Hash(Γ (j)
0
, ..., Γ (j)
2h−1) and sends it to PS. PS computes
ˆΓ (j) := Hash(Γ (j)
0
, ..., Γ (j)
2h−1) and checks Γ (j) = ˆΓ (j), for all j ∈[t]. If the check
fails, PS aborts.
(e) PS samples random χ, χ0, ..., χ2h−1 ∈F2d and sends them to PR. For j ∈[t],
PR computes Vj := P
i∈[0,2h) χi(v(j)
2i + χ · v(j)
2i+1). PR computes X := ∆+ χ · δ.
PR sends {Vj}j∈[t] and X to PS.
(f) PS computes Wj := P
i∈[0,2h) χi(W(j)
0,i + χ · W(j)
1,i). PS checks that Vj −Wj =
X · χα(j) · yj holds for all j ∈[t]. If the check fails, PS aborts.
Output: PS outputs (W(1)
0 , ..., W(t)
0 ) ∈GR(2k, d)n, (e(1), ..., e(t)) ∈GR(2k, d)n. PR
outputs (V(1)
0 , ..., V(t)
0 ) ∈GR(2k, d)n.
Fig. 22: Protocol for multi-point VOLE over GR(2k, d) in the (FGR(2k,d)
gVOLE , FOT)-
hybrid model.
53

positions twice, while the corrupted sender learns nothing about ∆. We have the
following theorem.
Theorem 17. If G and G′ are PRGs with G′ having the right half injective
property, and Hash : {0, 1}2hκ →{0, 1}κ is a collision resistant hash function,
ΠGR(2k,d)
mpVOLE realizes the functionality FGR(2k,d)
mpVOLE in the (FGR(2k,d)
gVOLE , FOT)-hybrid model
with malicious security.
Proof. Malicious Sender. The simulator SS acts as follows.
1. SS records the inputs M, c, y ∈GR(2k, d)t sent to FGR(2k,d)
gVOLE by A.
2. For j ∈[t] and i ∈[h], SS records the input ¯α(j)
i
sent to FOT by A, then
SS can recover the values α(j), j ∈[t]. For j ∈[t], SS computes s(j) ←
GGM.KeyGen(1κ), and gets ({(v(j)
2i , v(j)
2i+1, Γ (j)
i
)}i∈[0,2h), {(K(j)
0,i , K(j)
1,i )}i∈[h+1]) ←
GGM.Gen(2h+1, s(j)). SS resets K(j)
1,h+1 := L
i∈[0,2h) Γ (j)
i
. SS emulates FOT by
sending K(j)
¯α(j)
i
,i to A. SS sends g(j)
0 , g(j)
1
$←GR(2k, d) and K(j)
1,h+1 to A.
3. For j ∈[t], SS computes Γ (j) := Hash(Γ (j)
0 , ..., Γ (j)
2h−1) and sends it to A.
4. Upon receiving χ, χ0, ..., χ2h−1 ∈GR(2k, d) from A, for j ∈[t], SS computes
W(j)
0,α(j) := Mj −g(j)
0
−P
i̸=α(j) v(j)
2i and W(j)
1,α(j) := cj −g(j)
1
−P
i̸=α(j) v(j)
2i+1.
Next, SS computes Wj := P
i̸=α(j) χi(v(j)
2i + χ · v(j)
2i+1) + χα(j)(W(j)
0,α(j) + χ ·
W(j)
1,α(j)). Finally, SS samples X
$←GR(2k, d), and sends X, {Vj := Wj + X ·
χα(j) · yj}j∈[t] to A.
5. SS sets W(j)
0,i := v(j)
2i , for j ∈[t], i ∈[0, 2h), i ̸= α(j). SS sets e(j) ∈
GR(2k, d)2h such that e(j)
α(j) := yj, and e(j)
i
= 0 for i ̸= α(j). SS sends
(W(1)
0 , ..., W(t)
0 ), (e(1), ..., e(t)) to FGR(2k,d)
mpVOLE.
The messages produced by SS are generated in the same way to that in the real
execution except for {g(j)
0 , g(j)
1 }j∈[t] and V, X. It is not hard to see that these
messages (except V , since V is dependent on X) are uniformly random in A’s
view in the real execution. Besides, SS can correctly extract (e(1), ..., e(t)) and
compute (W(1)
0 , ..., W(t)
0 ), which guarantees the indistinguishability of the outputs.
Thus, the real execution and the ideal simulation are indistinguishable.
Malicious Receiver. The simulator SR acts as follows.
1. SR records the input ∆, δ that A sends to FGR(2k,d)
gVOLE in the Init phase. Later
in the Extend phase, SR records the input K, a ∈GR(2k, d)t sent to FGR(2k,d)
gVOLE
by A.
2. For j ∈[t], i ∈[0, 2h), SR records the input (K(j)
0,i , K(j)
1,i ) sent to FOT by A.
SR sets α(l) = l, for l ∈[0, 2h). Upon receiving {K(j)
1,h+1, Γ (j)}j∈[t], SR runs
GGM.Eval′(α(l), {K(j)
¯α(l)
i
,i}i∈[h], K(j)
1,h+1) and gets ({(v(j,l)
2i
, v(j,l)
2i+1)}i̸=α(l), {Γ (j,l)
i
}i∈[0,2h)),
for l ∈[0, 2h). SR computes Γ (j)
l
:= Hash(Γ (j,l)
0
, ..., Γ (j,l)
2h−1).
54

3. For j ∈[t], SR builds a series of sets I(j) := {l ∈[0, 2h) | Γ (j)
l
= Γ (j)} ⊆
[0, 2h). If there exists a j ∈[t] such that I(j) = ∅, SR aborts. SR sends
{I(j)}j∈[t] to FGR(2k,d)
mpVOLE. If it aborts, then SR aborts.
4. SR builds a set J := {j ∈[t] | |I(j)| = 1}. If there exists some l ̸= l′ ∈I(j),
j ∈[t]\J and i ̸= l, l′ such that v(j,l)
2i
̸= v(j,l′)
2i
, SR aborts. Thus, for j ∈[t]\J,
SR can obtain consistent {(v(j)
2i , v(j)
2i+1)}i∈[0,2h). Besides, for j ∈J, suppose
I(j) = {α(j)}, then SR can set v(j)
2α(j) = v(j)
2α(j)+1 = 0 to obtain V(j)
0 , V(j)
1 .
5. Upon receiving {g(j)
0 , g(j)
1 }j∈[t] from A, SR samples random χ, χ0, ..., χ2h−1
$←
F2d and sends them to A. For j ∈[t], SR computes β(j)
0
:= g(j)
0
−(Kj −
P
i∈[0,2h) v(j)
2i ) and β(j)
1
:= g(j)
1
−(aj −P
i∈[0,2h) v(j)
2i+1). If there exists a
j ∈[t] such that β(j)
1
̸= 0, but β(j)
0
+ χ · β(j)
1
= 0, SR aborts. SR computes
ˆVj := P
i∈[0,2h) χi(v(j)
2i + χ · v(j)
2i+1).
6. Upon receiving {Vj}j∈[t] and X from A, for j ∈[t] with β(j)
1
̸= 0, SR tries
to find ˆα(j) ∈I(j) such that ˆVj −Vj = χˆα(j)(β(j)
0
+ χ · β(j)
1 ). If such an ˆα(j)
does not exist or is not unique, SR aborts.
7. For j ∈[t]\J with β(j)
1
̸= 0, SR resets I(j) := {ˆα(j)}, and sends I(j) to
FGR(2k,d)
mpVOLE. If it aborts, then SR aborts.
8. SR sends (V(1)
0 , ..., V(t)
0 ) to FGR(2k,d)
mpVOLE.
We show the probability that honest sender aborts in a real execution is
negligibly close to aborting in the ideal simulation. If PS aborts in the real
execution due to some j ∈[t] such that ˆΓ (j) ̸= Γ (j), this will lead to that
α(j) /∈I(j) in the ideal simulation, which means that SR will abort as well.
Next, we claim the probability that SR aborts in the step 4 of the simulation
is negligible. We prove it by contradiction. If such l ̸= l′ ∈I(j), j ∈[t]\J
exist, from the construction of GGM tree, there exists ρ, ρ′ ∈{0, 1}κ such that
(v(j,l)
2i
, v(j,l)
2i+1, Γ (j,l)
i
) = G′(ρ) and (v(j,l′)
2i
, v(j,l′)
2i+1, Γ (j,l′)
i
) = G′(ρ′). Thus, we have
that ρ ̸= ρ′. By the right-half injectivity of G′, we have Γ (j,l)
i
̸= Γ (j,l′)
i
, which leads
to Γ (j)
l
̸= Γ (j)
l′
overwhelmingly. However, Γ (j)
l
= Γ (j)
l′
= Γ (j) since l, l′ ∈I(j).
This completes the proof of the above claim.
If A behaves honestly in the j-th iteration, we have β(j)
0
= β(j)
1
= 0. Since χ is
picked uniformly at random in F2d by SR, the probability that β(j)
0
+ χ · β(j)
1
= 0
with β(j)
1
̸= 0 is equal to 1/2d form Lemma 1. By a union bound, SR aborts in
the step 5 of the simulation with probability at most t/2d.
If A sends (ˆg(j)
0
:= g(j)
0
+β(j)
0 , ˆg(j)
1
:= g(j)
1
+β(j)
1 ) instead of correct (g(j)
0 , g(j)
1 ),
there will be a bias χα(j)(β(j)
0
+χ·β(j)
1 ) for Wj computed by honest PS. Therefore,
it can be observed that if A successfully guesses the α(j) chosen by honest PS, A
can pass the check of PS by sending Vj := ˆVj −χα(j)(β(j)
0
+ χ · β(j)
1 ). On the other
hand, if SR can not find a solution ˆα(j), the honest PS will abort, no matter what
α(j) he picks. As the coefficients χ0, ..., χ2h−1 are sampled uniformly at random
by SR, they are pair-wise distinct except with probability at most 1/2d−h.
55

Therefore, from above discussions, the probability that SR aborts while honest
PS does not abort is bounded by (t/2d + 1/2d−h + negl(κ)). This concludes the
whole proof.
⊓⊔
PS and PR can naturally obtain pseudorandom VOLE correlations with the
help of a multi-point VOLE, just multiplying the functionality outputs by a
parity check matrix H for which a dual variant of the LPN assumption holds.
Here we can use the dual variant to further reduce the communication complexity,
which is formally defined as follows.
Definition 6 (Dual LPN with static leakage). We first describe the corre-
sponding dual LPN security game GDual as follows.
1. Let H ←G⊥(m, n) ∈GR(2k, d)n×(n−m) be a dual LPN matrix, and e =
(e(1), ..., e(t)) ∈GR(2k, d)n be the error vector, where each e(i) has only one
entry invertible in GR(2k, d) and zeros everywhere else.
2. A sends I1, ..., It ⊂[n/t]. If for all i ∈[t], Ii includes the noisy position of e(i),
send success to A. Otherwise, abort. Construct a set J := {j ∈[t] | |Ij| = 1}.
3. A sends ˆαi, where ˆαi ∈Ii and i ∈[t]\J. If for all i ∈[t]\J, ˆαi is the exact
noisy position of e(i), send success to A. Otherwise, abort.
4. Pick b ←{0, 1}. If b = 0, send y := e · H to A, otherwise, send y
$←
GR(2k, d)(n−m) to A.
5. A outputs a bit b′. The game outputs 1 if b′ = b, and outputs 0 otherwise.
We say that the decisional dual (RG, G, R) −LPN(m, n, t) with static leakage is
(T, ϵ)-hard, if for every probabilistic distinguisher B running in time T, B wins
the game GDual with advantage at most ϵ, i.e.
|Pr[GDual = 1] −1/2| ≤ϵ.
By Fiat-Shamir transform, we immediately obtain a two-round multi-point
VOLE protocol, which yields a round optimal VOLE extension protocol. We
remark that when the length of required VOLE correlation is small, or namely
the “bootstrapping” in the primal LPN-based construction is not activated, the
two-round variant has lower communication complexity, as dual-LPN allows for
polynomial stretch.
56

