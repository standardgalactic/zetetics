Vector Commitments With Proofs of Smallness:
Short Range Proofs and More
Benoˆıt Libert
Zama, France
Abstract. Vector commitment schemes are compressing commitments
to vectors that make it possible to succinctly open a commitment for
individual vector positions without revealing anything about other po-
sitions. We describe vector commitments enabling constant-size proofs
that the committed vector is small (i.e., binary, ternary, or of small
norm). As a special case, we obtain range proofs featuring the short-
est proof length in the literature with only 3 group elements per proof.
As another application, we obtain short pairing-based NIZK arguments
for lattice-related statements. In particular, we obtain short proofs (com-
prised of 3 group elements) showing the validity of ring LWE ciphertexts
and public keys. Our constructions are proven simulation-extractable in
the algebraic group model and the random oracle model.
Keywords. Vector commitments, range proofs, ring LWE ciphertexts.
1
Introduction
Vector commitments (VCs) [81,26] allow a user to commit to a vector m ∈Dn
over some domain D by generating a short commitment. Later, the commit-
ter can succinctly open individual entries of m. Here, “succinctly” means that
the partial opening information (called “proof”) should have constant size, no
matter how large the committed vector is. As in standard commitments, a vec-
tor commitment scheme should satisfy two security properties: (i) The binding
property, which ensures that no efficient adversary can open a commitment to
two different values at the same position i ∈[n]; (ii) The hiding property, which
guarantees that revealing a subset of components does not reveal any informa-
tion about messages at remaining positions.
Vector commitments found a number of applications in the context of zero-
knowledge databases [81], verifiable data streaming [77], authenticated dictionar-
ies [96], de-centralized storage [24], succinct arguments [9,78], cryptocurrencies
[95] and blockchain transactions [9,61].
In this paper, we consider the problem of extending vector commitments
with optimally short proofs that the committed vector m has small entries. A
straightforward solution is to generically use a general-purpose succinct non-
interactive argument (SNARK) for all NP languages [88]. While the SNARKs of
[65,54,67] would give constant-size proofs, they would require to represent the
statement as an arithmetic circuit. Then, the latter would have to compute the

opening algorithm (including exponentiations in a group) of the commitment
scheme, which would result in a complex circuit. In turn, this would require a
large structured common reference string (CRS) and make the proof generation
very expensive since, in pairing-based SNARKs with very short proofs [54,67,50],
the CRS size grows linearly with the number of multiplication gates in the arith-
metic circuit. Inevitably, the computational cost of the prover grows (at least)
linearly with the circuit size as well. In this paper, we aim at proving smallness
more efficiently than by generically using a SNARK for all NP statements.
1.1
Our Contributions
We revisit the vector commitment scheme of Libert and Yung [81] and propose a
technique allowing to argue the smallness of committed vectors without chang-
ing the scheme. Using a very small number of group elements (typically 2 or
3), we can prove that a committed vector is binary, ternary or that it has small
infinity norm. By slightly increasing the proof length, we can also prove that a
committed vector has small Euclidean norm or a small Hamming weight.
As a key building block, we describe a technique of generating a short proof
that a committed m has binary entries using only two group elements. This ar-
gument of binarity is proven knowledge-sound in the combined algebraic group
model (AGM) [48] and random oracle model. In addition, the scheme retains
the useful properties of the original vector commitment [81]. In particular, its
CRS size remains linear in the dimension n of committed vectors and it remains
possible to succinctly open the commitment for individual vector positions. As
in [80], it is also possible to prove that a committed (binary) m ∈Zp satisfies
a linear equation ⟨m, t⟩= x for a public t ∈Zn
p and a public x ∈Zp. Finally,
it retains the aggregation properties [80,61] that make it possible to generate a
constant-size proof for a sub-vector opening.
As a first application of our arguments of binarity, we obtain a new construc-
tion of range proof featuring extremely short proofs. Regardless of the range
magnitude, each proof consists of only 3 group elements, which matches the
proof size of Groth’s SNARK [67] and improves upon the shortest known range
proof due to Boneh et al. [12]. The construction extends to simultaneously prove
possibly distinct ranges for the individual entries of a vector x = (x1, . . . , xm)
without affecting the proof size. As a special case, it implies very short proofs
that a committed x ∈Zn has small infinity norm.
As a second main application, we provide short pairing-based non-interactive
zero-knowledge (NIZK) arguments for many natural statements appearing in
lattice-based cryptography. Specifically, we can argue knowledge of small-norm
elements s1, . . . , sn of a cyclotomic ring R = Z[X]/(Xd + 1) that satisfy a linear
relation PM
i=1 ai · si = t, for public vectors of ring elements a1, . . . , aM, t ∈RN
q ,
where Rq = R/(qR). Using only 3 group elements, we can prove the validity
of a ring LWE (RLWE) ciphertext [85], an RLWE public key, or even FHE ci-
phertexts [17,32]. We can also prove that a committed vector is a solution to
an instance of the subset sum problem, which is useful for all the applications
considered in [45]. For the specific task of proving the validity of a ciphertext in
2

the Lyubashevsky-Peikert-Regev cryptosystem [85], we provide efficiency com-
parisons with Groth’s SNARK [67], which is the state-of-the art construction
featuring the same proof size. We estimate that the size of the common ref-
erence string is reduced by a factor 2. While slower on the verifier’s side, our
scheme decreases the number of exponentiations at the prover by a factor 4. The
reason is that, on the prover and verifier sides, the number of exponentiations
only depends on the length of the witness and not on the size of the arithmetic
circuit describing the relation. Our construction thus provides a more balanced
tradeoff than SNARKs between the complexities of the prover and the verifier.
As such, it can be useful in cloud or blockchain applications where it is desirable
to minimize the overhead of the client even at the cost of increasing the workload
of the server. For example, in FHE-based private smart contracts [37,93] (which
explicitly require ZK proofs of input awareness), a resource-constrained client
has to prove the validity of its input FHE ciphertexts before sending them to a
computationally powerful server performing homomorphic operations.
Our NIZK arguments of range membership and ciphertext validity can be
proven simulation-extractable in the algebraic group model [48] and the random
oracle model (recall that all such succinct arguments have to rely on an ideal-
ized model [57]). Simulation-extractability guarantees knowledge-soundness even
when the adversary can observe proofs generated by honest parties. It thus pro-
vides non-malleability [42] guarantees against a malicious prover attempting to
create a proof of its own by mauling honestly generated proofs. As pointed out
in, e.g., [53,51], it is an important security property in all applications where
succinct arguments are easily observable in the wild. For example, if a malleable
range proof is used to demonstrate the validity of confidential transactions (as
in the use case of [19]), it may fail to ensure transaction independence.
Luckily, we can prove simulation-extractability without increasing the proof
length while even the random-oracle-optimized variants [16,4] of Groth’s SNARK
have longer proofs. For the optimal proof length, existing SNARKs either pro-
vide a relaxed flavor of simulation-extractability [3] or they are significantly more
demanding [68] than [67] in terms of CRS size and proving time.
1.2
Technical Overview
In asymmetric pairings e : G× ˆG →GT , the scheme of [81] uses a CRS containing
group elements (g, {gi = g(αi)}i∈[2n]\{n+1}) and (ˆg, {ˆgi = ˆg(αi)}n
i=1). The sender
commits to m = (m1, . . . , mn) ∈Zn
p by choosing γ
R←Zp and computing
C = gγ ·
n
Y
j=1
gmj
j
= gγ+Pn
j=1 mi·αj .
To open a position i ∈[n] of m, the committer reveals a proof
πi = gγ
n+1−i ·
n
Y
j=1,j̸=i
gmj
n+1−i+j =

C/gmi·αiαn+1−i
3

which is verified by checking that e(C, ˆgn+1−i) = e(πi, ˆg) · e(g1, ˆgn)mi.
To aggregate multiple proofs, PointProofs [61] uses the observation [80] that
the commitment of [81] allows proving that a committed m ∈Zn
p satisfies an
inner product relation ⟨m, t⟩= x for public t = (t1, . . . , tn) ∈Zn
p and x ∈Zp.
By raising the verification equation to the power ti ∈Zp and taking the product
over all i ∈[n], we obtain
e
 C,
n
Y
i=1
ˆgti
n+1−i

= e
 n
Y
i=1
πti
i , ˆg

· e(g1, ˆgn)
Pn
i=1 mi·ti .
(1)
PointProofs [61] aggregates proofs {πi}i∈S for a sub-vector S ⊆[n] by deriving
aggregation coefficients {ti}i∈S from a random oracle and defining the aggregated
proof as the product πS = Q
i∈S πti
i . Verification then proceeds by testing the
equality e(C, ˆgn+1−i)
P
i∈S ti = e(πS, ˆg) · e(g1, ˆgn)
P
i∈S mi·ti. In the following, we
further exploit the aggregation properties of PointProofs.
Proving Binarity. Let a commitment ˆC = ˆgγ · Qn
i=1 ˆgxi
i
to x ∈{0, 1}n.1
Using its proof aggregation properties, we prove that, for each i ∈[n], we have
xi ·(xi −1) = 0. To this end, we use a similar batching technique to BulletProofs
[19] and show that Pn
i=1 yi · xi · (xi −1) = 0, where y = (y1, . . . , yn) ∈Zn
p is a
vector of random aggregation coefficients obtained by hashing y = H( ˆC) using
a random oracle H : {0, 1}∗→Zn
p. As long as y ∈Zn
p is chosen uniformly after
{xi}n
i=1, the probability to have Pn
i=1 yi · xi · (xi −1) = 0 is only 1/p if there
exists i ∈[n] such that xi ̸∈{0, 1}.
In order to prove the statement using a constant number of group elements,
we first choose γy
R←Zp and generate an auxiliary commitment
Cy = gγy ·
n
Y
j=1
gyj·xj
n+1−j,
(2)
to the Hadamard product y ◦x = (y1 · x1, . . . , yn · xn) (in the reversed order).
Then, we proceed in two steps.
In a first step, our prover has to demonstrate that it really computed Cy as
a commitment to (yn · xn, . . . , y1 · x1). Since the commitment (2) satisfies
e(Cy, ˆgi) = e
 gγy
i
·
n
Y
j=1,j̸=i
gyj·xj
n+1−j+i, ˆg

· e(g1, ˆgn)yi·xi
∀i ∈[n]
(3)
and the initial commitment ˆC = ˆgγ · Qn
j=1 ˆgxj
j
satisfies
e(gn+1−i, ˆC) = e
 gγ
n+1−i ·
n
Y
j=1,j̸=i
gxj
n+1−i+j, ˆg

· e(g1, ˆgn)xi
∀i ∈[n],
(4)
1 For our applications, we will assume that the commitment is in ˆG rather than G in
order for the proof of knowledge-soundness to work out.
4

we can choose random exponents t = (t1, . . . , tn)
R←Zn
p and use them to raise
(4) to the power ti · yi and (3) to the power ti, respectively. If we then take the
products over all indices i ∈[n] and divide them, we find that
πeq =
Qn
i=1

gγ
n+1−i · Q
j∈[n]\{i} gxj
n+1−i+j
ti·yi
Qn
i=1

gγy
i
· Q
j∈[n]\{i} gyj·xj
n+1−j+i
ti
.
satisfies
e(Qn
i=1 gti·yi
n+1−i, ˆC)
e(Cy, Qn
i=1 ˆgti
i )
= e(πeq, ˆg),
(5)
The reason why πeq is a convincing proof that the prover computed Cy as
a commitment to (yn · xn, . . . , y1 · x1) is the following. Suppose that Cy is a
commitment Cy = gγy · Qn
j=1 gzn+1−j
n+1−j to some (z1, . . . , zn). Then, (3) becomes
e(Cy, ˆgi) = e
 πz,i, ˆg

· e(g1, ˆgn)zn+1−i
∀i ∈[n],
(6)
where πz,i = Qn
j=1,j̸=i gzn+1−j
n+1−j+i is the proof that a prover can compute to open
the (n + 1 −i)-th position of Cy. Now, if we raise (6) to the power ti and divide
it from (4) raised to the power ti · yi, we obtain
e(Qn
i=1 gti·yi
n+1−i, ˆC)
e(Cy, Qn
i=1 ˆgti
i )
= e

n
Y
i=1
 πyi
x,i/πz,i
ti , ˆg

· e(g1, ˆgn)
Pn
i=1 ti·(yi·xi−zn+1−i),
where πx,i = Q
j∈[n]\{i} gxj
n+1−i+j is the computable proof that allows opening the
i-th position of ˆC in (4). If t is chosen uniformly after (z1, . . . , zn), (y1, . . . , yn)
and (x1, . . . , xn), then the probability to have Pn
i=1 ti · (yi · xi −zn+1−i) = 0
is 1/p if there exists i ∈[n] such that zn+1−i ̸= yi · xi. In the construction, we
derive t = (t1, . . . , tn) = H(y, ˆC, Cy) ∈Zn
p from a random oracle to make sure
that t is computed after y, (x1, . . . , xn) and (z1, . . . , zn).
The proof πeq of the first step implies that Cy ·Qn
j=1 g−yj
n+1−j is a commitment
to the vector (yn · (xn −1), . . . , y1 · (x1 −1)), where (x1, . . . , xn) is the vector
committed in ˆC. In a second step, we prove that (yn · (xn −1), . . . , y1 · (x1 −1))
is orthogonal to (xn, . . . , x1): i.e., Pn
i=1 yi · xi · (xi −1) = 0. From (1), it can be
shown that such a proof is computable as
πy = (Cy ·
n
Y
j=1
g−yj
n+1−j)γ ·
n
Y
i=1

gγy
i
·
Y
j∈[n]\{i}
gyj·(xj−1)
n+1−j+i
xi
and satisfies
e
 Cy·
n
Y
j=1
g−yj
n+1−j, ˆC

= e(πy, ˆg)·e(g1, ˆgn)
Pn
i=1 yi·xi·(xi−1) = e(πy, ˆg)
(7)
5

In order to minimize the proof size, we will exploit the linearity of verifica-
tion equations (5) and (7) to aggregate πeq and πy into a single group element
π = πδeq
eq · πδy
y
using random aggregation coefficients (δeq, δy) ∈Z2
p.
Eventually, the proof π = (Cy, π) ∈G2 that ˆC commits to a binary vector
consists of the commitment Cy to (yn · xn, . . . , y1 · x1) and π ∈G.
Proving Range Membership. To obtain a constant-size range proof, we use
the fact that the commitment scheme of [81] is also an inner product functional
commitment. The prover has a Pedersen commitment [90] ˆV = ˆgr · ˆgx
1 in the
group ˆG. In order to prove the statement x ∈[0, 2ℓ−1], the prover considers
the bit representation (x1, . . . , xℓ) ∈{0, 1}ℓof x and computes a commitment
ˆC = ˆgγ · Qℓ
j=1 gxj
j , for a random γ ∈Zp. Using the aggregation properties of
the commitment, it will prove that the committed x = (x1, . . . , xℓ| 0n−ℓ) ∈Zn
p
satisfies: (i) Pℓ
i=1 xi · 2i−1 = x; (ii) xi ∈{0, 1} for each i ∈[n].
In order to prove (i), the prover can adapt (1) and generate a short proof
Qn
i=1 π2i−1
i
∈G such that
e
 ℓ
Y
i=1
g2i−1
n+1−i, ˆC

= e
 ℓ
Y
i=1
π2i−1
i
, ˆg

· e(g1, ˆgn)
Pℓ
i=1 xi·2i−1
(8)
and show that the exponent above e(g1, ˆgn) in (8) is equal to the committed x
in ˆV = ˆgr · ˆgx
1. Since ˆV satisfies e(gn, ˆV ) = e(g1, ˆgn)x · e(gr
n, ˆg), the prover can
actually compute πx = Qℓ
i=1 π2i−1
i
/gr
n such that
e
  Qℓ
i=1 g2i−1
n+1−i, ˆC

e(gn, ˆV )
= e
 πx, ˆg

.
(9)
Proving (ii) is addressed as explained earlier. Note that we do not need to prove
that the n −ℓlast positions of x are zeroes since the inner product in the right-
hand-side member of (8) only involves the first ℓpositions of x.
In order to minimize the proof size, we will exploit the linearity of verification
equations (9), (5) and (7) to aggregate πx, πeq and πy into a single group element.
In order to ensure knowledge soundness in the algebraic group model, we also
need to aggregate a proof element πv showing that ˆV is a commitment to a vector
of the form (x, 0, . . . , 0). The entire proof π = ( ˆC, Cy, π) ∈ˆG × G2 eventually
consists of the commitment ˆC to the bits of x, the auxiliary commitment Cy to
(yn · xn, . . . , y1 · x1) and the aggregated proof π ∈G.
Batching Range Proofs. The above technique extends to prove multiple
range membership statements at once about the entries of a committed vector.
For a commitment ˆV = ˆgr · Qm
k=1 ˆgxk
k , the prover will convince the verifier that
xk ∈[0, 2ℓ−1] for each k ∈[m] using only 3 group elements (we assume for now
that the same range is proven for each xk but distinct ranges can be handled).
To this end, we can use the same aggregation technique as BulletProofs
[19, Section 4.3] and compute ˆC as a commitment to a vector of dimension
6

n = ¯ℓ· m (where ¯ℓis an upper bound for ℓ) obtained by appending the binary
expansions of all {xk}m
k=1. Then, we can use a single group element to prove
that, for each k ∈[m], the k-th sub-vector xk = (xk,1, . . . , xk,ℓ, 0, . . . , 0) hidden
by the commitment ˆC is a binary vector satisfying xk = Pℓ
i=1 xk,i · 2i−1.
Proving Relations in Lattices. Here, we build on an approach considered
by del Pino, Lyubashevsky and Seiler [41] to prove lattice-related statements
assuming the hardness of computing discrete logarithms. The difference that
we replace the BulletProofs component [19] by our more compact proof that a
committed vector is binary. We also exploit the fact that the underlying vector
commitment [81] allows proving inner-product relations as in (1).
Let the polynomial rings R = Z[X]/(Φ), for some cyclotomic polynomial Φ of
degree d, and Rq = R/(qR). As in [41], we aim at proving the existence of small-
norm ring elements s = (s1, . . . , sM) ∈RM such that PM
i=1 ai·si = t mod (q, Φ),
for public t ∈RN
q and a1, . . . , aM ∈RN
q . To this end, we proceed as in [41] and
re-write the relation as the following equality over Z[X]/(Φ)
M
X
i=1
ai · si = t + r · q mod (Φ) ,
(10)
where r ∈RN is a vector of polynomials of degree ≤d −1 and the compo-
nents of {ai}M
i=1 and t are interpreted as polynomials with integer coefficients
in {−⌊q/2⌋, . . . , ⌊q/2⌋}. If ∥si∥∞≤Bi for each i ∈[M], r contains polynomials
with coefficients of magnitude ∥r∥∞≤dM · maxi∈[M](Bi)/2.
If we denote by ϕ : R →Zd the coefficient embedding that maps si =
Pd
j=1 si,j · Xj−1 to its coefficient vector ϕ(si) = (si,1, . . . , si,d) ∈Zd, we can
re-write (10) as a matrix-vector product over Z
[A1 | . . . | AM |
−q · INd ] · [ϕ(s1) | . . . | ϕ(sM) | ϕ(r)]⊤
|
{z
}
≜x
= ϕ(t)
(11)
for structured matrices A1, . . . , AM ∈ZNd×d
q
interpreted as integer matrices
over {−⌊q/2⌋, . . . , ⌊q/2⌋}. In order to prove (11), the prover can commit to the
vector x ∈ZMd+Nd using a vector commitment. Then, it can generate short
proof that ∥ϕ(si)∥∞≤Bi for each i ∈[M] and ∥ϕ(r)∥∞≤dM ·maxi∈[M](Bi)/2.
Finally, it can prove that (11) holds over Zp, where p is the order of pairing-
friendly groups. If p > 2Mqd maxi(Bi), this ensures that (11) also holds over the
integers. In order to optimize the proof size, we commit to the binary decompo-
sition of (ϕ(s1), . . . , ϕ(sM), ϕ(r)) and prove a relation that implies (11).
In order to minimize the number of exponentiations, we apply the Schwartz-
Zippel lemma in a different way than [41]: Instead of proving (10) by considering
evaluations of degree-2d polynomials,2 we compress (11) by left-multiplying both
2 More precisely, [41] proceeds by proving a relation PM
i=1 ai ·si −r1 ·q−r2 ·Φ = t over
Z[X], where r1 and r2 contain polynomials of degree 2(d−1) and d−2, respectively.
7

members with a random vector θ ∈ZNd
p , which allows processing all the rows
of (11) using a short proof for a single inner product relation.
Just like [41], our protocol does not preserve soundness against quantum ad-
versaries. However, both protocols still provide viable solutions in applications
that only need to guarantee soundness at the moment of the protocol execution
(i.e., today and assuming that the adversary is not quantum). In particular,
they do not affect the post-quantum security of the encryption scheme as their
zero-knowledge property does not rely on any assumption.
Achieving Simulation-Extractability. In our security proofs, one of the
main difficulties is to properly simulate proofs for adversarially-chosen state-
ments while remaining able to extract a witness (or break some assumption)
from a proof generated by the adversary. As noticed in, e.g. [51], the simulator
cannot use the trapdoor α ∈Zp of the CRS since it would be incompatible with
a reduction from a q-type assumption in the AGM.
To address this problem, we build a trapdoor-less simulator [51] that can
simulate proofs for adversarially-chosen statements by programming the random
oracles and without using α. To do this, we exploit the fact that our range proofs
and our proof of valid RLWE encryption are obtained by aggregating various
sub-proofs satisfying verifications of the form (5), (7) or (8). In each simulated
proof π = ( ˆC, Cy, π), we compute ˆC and Cy as commitments to vectors which
are programmed (as functions of previously chosen aggregation coefficients) in
such a way that the unique corresponding valid proof π is computable without
knowing the missing element g(αn+1) of the CRS. At the same time, we can argue
that the adversary cannot fake a proof using the simulator’s strategy. We show
that, with overwhelming probability, it can only come up with a proof π whose
representation depends on g(αn+1) if knowledge extraction fails.
1.3
Related Work
Vector commitments with logarithmic-size proofs are known since the Merkle-
tree-based construction [87]. In the last decade, a number of number-theoretic
candidates have emerged and offered useful advantages such as additive ho-
momorphism, very short proofs [81], stateless updatability [26], or sub-vector
openings [78,9,95]. The first candidate with constant-size proofs was put forth
by Libert and Yung [81] under a q-type assumption. Constructions based on
the standard Diffie-Hellman assumption (in pairing-friendly groups) and the
RSA assumption appeared in the work of Catalano and Fiore [26]. Lattice-based
schemes were suggested by Peikert et al. [91]. While more versatile than their
hash-based counterparts, algebraic VCs also seem to require more fancy math-
ematical tools. Indeed, Catalano et al. [27] recently proved negative results on
the possibility of discrete-log-based vector commitments without pairings.
Polynomial and Functional Commitments. Polynomial commitments [74]
allow one to commit to a polynomial and subsequently prove evaluations of this
polynomial on specific inputs via a short proof (i.e., of length sub-linear in the
8

degree of the committed polynomial). Succinct polynomial commitments were
used in a number of SNARKs realizations (see, e.g., [86,50,20,11]). As shown in,
e.g. [23, Section 3.1], polynomial commitments imply vector commitments.
Functional commitments (FC) for inner products [71,80] generalize both vec-
tor commitments and polynomial commitments by allowing the sender to com-
mit to a vector m and succinctly prove linear functions of the committed vector.
The first flavor of inner product functional commitment was considered in the
interactive setting [71] while non-interactive solutions with constant-size proofs
are enabled by SNARKs. Libert, Ramanna and Yung [80] generalized the vec-
tor commitment of [81] into a non-interactive inner product FC in the standard
model while preserving its short proof size. Constructions with short public pa-
rameters in hidden-order groups were put forth in [33,2]. Lai and Malavolta [78]
proposed the notion of linear map commitments that allows a prover to reveal
a linear map evaluation, instead of just an inner product. At the expense of
losing the homomorphic property, Lipmaa and Pavlyk [83] provided an FC can-
didate for sparse polynomials. Boneh et al. [13] considered the dual notion of
function-hiding FC schemes (where the committer commits to a function instead
of a message) for arithmetic circuits, which generalizes vector commitments and
other flavors of commitments.
Among lattice-based realizations, Gorbunov et al. [62] implicitly showed non-
succinct functional commitments for bounded-depth circuits. Peikert et al. [91]
proposed a succinct realization while relying on an online trusted authority to
generate proofs. Albrecht et al. described [1] a construction for constant-degree
polynomials over the integers as a building block for lattice-based SNARKs. Suc-
cinct FC candidates for circuits recently appeared in the work of Wee and Wu
[97]. Independently, de Casto and Peikert [40] proposed a lattice-based function-
hiding FC for circuits, but without fully succinct evaluation proofs.
Vector commitments with succinct proofs of smallness can be seen as a spe-
cial case of functional commitments for Boolean predicates, where the smallness
bound is hard-wired in the circuit. However, functional commitments for general
circuits [40,97] seem ill-suited to our purposes since we aim at computationally
efficient schemes with very short proofs. Indeed, the function-hiding FC scheme
proposed by de Castro and Peikert [40] does not provide succinct openings (i.e.,
the opening size grows with the input length). While succinct, the construction of
Wee and Wu [97] would not compete with ours in terms of proof length and CRS
size (which is quadratic in the dimension of committed vectors in [97]). More-
over, in our application to NIZK arguments, the scheme of [97] would require the
use of ad hoc knowledge assumptions in lattices for lack of a well-defined lattice
analogue of the algebraic group model. Balb´as et al. [5] suggested an alterna-
tive realization of FC for arithmetic circuits. However, its proof length grows
at least linearly with the depth of the arithmetic circuit, which would translate
into much longer proofs than ours.
In an earlier work, Catalano, Fiore and Tucker [28] proposed additively ho-
momorphic FCs for constant-degree polynomials and monotone span programs.
While their construction for polynomials and the Lipmaa-Pavlyk construction
9

[83] are both amenable to proving smallness statements, they would be less
efficient than our constructions, as discussed in Supplementary Material A.
Moreover, their more complex CRS structure would make it harder to prove
knowledge-soundness in our setting, where the evaluation-binding property con-
sidered in [83,28] would not suffice.
Aggregation and Sub-vector Openings. On several occasions, we rely on
sub-vector openings and proof aggregation in the vector commitment of [81].
The notion of sub-vector openings was independently introduced and realized
by Lai and Malavolta [78] and by Boneh, B¨unz and Fisch [9]. It allows a sender
to generate a short proof πS that opens a sub-vector mS of m, for a subset
S ⊆[n]. Sub-vector openings are implied by the proof aggregation property con-
sidered in [9,96,95,24,61,94], which allows anyone (and not only the committer)
to aggregate n individual proofs {πi}i∈S for a committed sub-vector mS into a
constant-size proof πS. Boneh, B¨unz and Fisch [9] and Tomescu et al. [95] re-
alized same-commitment aggregation in hidden-order groups and under q-type
assumptions in pairing-friendly groups, respectively. Campanelli et al. [24] in-
troduced incrementally aggregatable vector commitments, which allow different
sub-vector openings to be merged into a shorter opening for the union of their
sub-vectors. Moreover, aggregated proofs support further aggregation.
By leveraging the linearity properties of the vector commitment from [81],
Gorbunov et al. [61] obtained a VC scheme enabling cross-commitment aggrega-
tion, which is useful in blockchain applications. The same-commitment variant
of their aggregation method is obtained by introducing a random oracle in the
inner product functional commitment of [80]. Our technique of proving that a
committed vector is a reversed Hadamard product of another committed vector
x and a public vector y is inspired by the randomized aggregation technique
of PointProofs [61]. The difference is that, while [61] uses proof aggregation to
succinctly prove sub-vector openings, we use it to prove linear relations between
related positions in distinct committed vectors.
Using aggregation techniques, Campanelli et al. [25] described a compiler
building linear map commitments from inner product functional commitments.
By instantiating vector commitments from polynomial commitments, Boneh
et al. [10,11] obtained an alternative VC system supporting cross-commitment
aggregation. Hyperproofs et al. [94] is yet another VC scheme allowing cross-
commitment aggregation with the additional feature that all proofs can be up-
dated in sub-linear time when the vector changes.
Other Proofs of Binarity. Prior works on pairing-based commitments
[59,58] considered the problem of constructing constant-size proofs that a com-
mitted string is binary. However, these techniques apply to variants of Groth-
Sahai commitments [69] that are not succinct vector commitments: i.e., either
the commitment or partial openings (or both) do not have constant size. The
first candidate [59] was designed for perfectly-binding commitments, where the
commitment is longer than the committed message. The case of perfectly hiding
(compressing) commitments was considered in [58, Section 4.2] but the under-
10

lying commitments do not natively support constant-size partial openings. As
briefly alluded to in [58, Section 4.2.1], it is actually possible to build a succinct
vector commitment to bitstrings on top of the perfectly hiding commitments
from [58, Chapter 4]. However, the resulting construction has several limita-
tions: (i) The CRS has quadratic size in the dimension of committed vectors
(like the Diffie-Hellman-based vector commitment of [26]); (ii) It does not seem
to support constant-size proofs that the committed m ∈Zn
p satisfies inner prod-
uct relations ⟨m, t⟩= x for public t ∈Zn
p and x ∈Zp; (iii) Proofs are somewhat
long and contain more than 20 group elements (according to Table 4.1 in [58]).
Das et al. [39] recently proposed another constant-size argument showing
that a committed vector is binary. While their construction can be modified to
build an alternative range proof to ours, it would result in longer proofs.
Range Proofs. Range proofs were introduced by Brickell et al. [18] and inves-
tigated in a large body of work [30,22,15,82,66,29,36,60] since then.
A standard approach [18,22,66,60,19] consists in breaking integers into bits
and committing to these bits using homomorphic commitments. When it comes
to proving membership of a range [0, 2ℓ−1], the resulting proofs generally contain
O(ℓ) group elements (and thus O(λ · ℓ) bits, where λ is the security parameter)
although somewhat shorter proofs [22,66,60] are achievable using pairings. Using
a clever recursive folding technique, Bulletproofs [19] decreased the communi-
cation complexity to O(log ℓ) group elements (i.e., O(λ · log ℓ) bits) in general
discrete-logarithm-hard groups without a bilinear map.
Another approach [15,82,63,36] relies on integer commitments in hidden-
order groups, by decomposing positive integers as a sum of squares. The sum-
of-squares method was transposed [35,34] to groups of (sufficiently large) public
prime order. It was also adapted to class groups and lattices. For some parame-
ters in the standard discrete logarithm setting, the constructions of [35,34] were
shown to compare favorably with BulletProofs.
For some applications where the proof size is the primary concern (e.g., con-
fidential transactions in the blockchain [19]), it may be desirable to have even
shorter proofs than [19,35,34], even at the expense of losing the transparent setup
property. Using polynomial commitments, Boneh et al. [12] suggested another
range proof inspired by SNARK arithmetization techniques [50]. Their construc-
tion can be realized from a variety of polynomial commitments [74,20,79]. In in-
stantiations from pairing-based polynomial commitments [74,80], it provides the
smallest communication cost to date, with proofs as short as 3 group elements
and 3 scalars. In our range proof construction, we further decrease the proof
length to that of the shortest known SNARKs [67]. A detailed comparison with
[12] is given in Section 4.4.
Discrete-Log-Based Proofs for Lattice Relations. The use of special-
ized pairing-based arguments to prove lattice relations was considered to prove
the correct evaluation of FHE ciphertexts [47]. However, the modulus of the lev-
eled FHE scheme had to match the group order of the pairing. This limitation
does not appear in the del Pino et al. approach [41] nor in our construction. We
11

note that the motivation of [47] was different since, in their setting, the prover
was the server while the verifier was a computationally constrained client. Here,
we consider use cases like [93] where the prover is the client (generating the proof
on its browser using a single thread) and the verifier runs on a computationally
powerful machine that can afford the use of multiple threads.
In applications to private FHE-based private smart contracts [93], the pro-
tocol of [41] was actually preferred to SNARKs in order to obtain faster prover.
Our system can offer a similarly fast prover with the benefit of shorter proofs.
1.4
Organization
We first present our argument of binarity in Section 3. Our constant-size range
proof is described in Section 4. Its batched multi-range extension is detailed in
Supplementary Material D. Due to space limitation, our NIZK argument for ring
LWE ciphertexts is deferred to Supplementary Material G.
2
Background and Definitions
2.1
Hardness Assumptions
Let groups (G, ˆG, GT ) of prime order p with a bilinear map e : G × ˆG →GT .
We rely on the hardness of computing a discrete logarithm α ∈Zp given
{gαi}i∈[2n] and {ˆgαi}i∈[n]. This assumption is similar to the n-discrete loga-
rithm assumption considered in, e.g. [48], except that powers αi are given in the
exponents in both groups G and ˆG.
Definition 1 ([48]). Let (G, ˆG, GT ) be asymmetric bilinear groups of prime
order p. For integers m, n, the (m, n)-Discrete Logarithm ((m, n)-DLOG)
problem is, given (g, gα, g(α2), . . . , g(αm), ˆg, ˆgα, . . . , ˆg(αn)), where α
R←Zp, g
R←G,
ˆg
R←ˆG, to compute α ∈Zp.
2.2
Non-interactive Arguments
Let {Rλ}λ a family of NP relations. A NIZK argument for {Rλ}λ consists of
algorithms Π = (CRS-Gen, Prove, Verify) with the following specifications. On
input of a security parameter λ ∈N and, optionally, language-dependent pa-
rameters lpp, algorithm CRS-Gen generates a common reference string pp and a
simulation trapdoor τ. We allow pp to parameterize the proven relation (when it
specifies the public parameters of a commitment scheme), which then becomes
Rpp ∈{Rλ}λ. Algorithm Prove takes as input the common reference string pp,
a statement x and a witness w and outputs a proof π when (x, w) ∈Rpp. Verify
takes in pp, a statement x and a proof π and returns 0 or 1. Correctness requires
that, for any R ∈{Rλ}λ and any (x, w) ∈Rpp, honestly generated proofs are
always (or at least with overwhelming probability) accepted by the verifier.
12

NIZK arguments should satisfy two security properties. The zero-knowledge
property requires that proofs leak no information about the witness. Knowledge-
soundness property requires that there exists an extractor that can compute a
witness whenever the adversary generates a valid proof. The extractor has access
to the adversary’s internal state, including its random coins. Let the universal
relation R∗for {Rλ}λ that inputs (Rpp, x, w) and outputs 1 iff Rpp ∈{Rλ}λ
and (x, w) ∈Rpp. We say that Π = (CRS-Gen, Prove, Verify) is a NIZK argument
for R∗if it satisfies the properties defined as follows.
Completeness: For any λ ∈N, any (not necessarily efficient) adversary A,
there is a negligible function negl : N →N such that
Pr

Verifypp(x, π) = 1 ∧(x, w) ∈Rpp | (pp, τ) ←CRS-Gen(1λ, lpp),
(x, w) ←A(pp) , π ←Provepp(x, w)

= 1 −negl(λ).
Knowledge-soundness: For any PPT adversary A, there is a PPT extractor
EA that has access to A’s internal state and random coins ρ such that
Pr

Verifypp(x, π) = 1 ∧(x, w) ̸∈Rpp | (pp, τ) ←CRS-Gen(1λ, lpp),
(x, π) ←A(pp; ρ), w ←EA(pp, (x, π), ρ)

= negl(λ).
(Statistical) Zero-knowledge: There is a PPT simulator Sim such that, for
any λ ∈N and any (not necessarily efficient) adversary A and any b ∈{0, 1},
Pr

b ←AOb(pp) | (pp, τ) ←CRS-Gen(1λ, lpp)

= 1/2 + negl(λ).
where O1 is an oracle that inputs (x, w) and returns π ←Provepp(x, w) if
(x, w) ∈Rpp and ⊥otherwise; O0 is oracle that inputs (x, w) and returns
π ←Sim(pp, τ, x) if (x, w) ∈Rpp and ⊥otherwise.
For many applications, it is desirable to strengthen knowledge-soundness by
considering an adversary that can observe simulated proofs (for possibly false
statements) and exploit some malleability of these proofs to generate a fake proof
of its own. The notion of simulation-extractability prevent such attacks.
Simulation-Extractability: For any PPT adversary A, there is a PPT ex-
tractor EA that has access to A’s internal state/randomness ρ such that
Pr

Verifypp(x, π) = 1 ∧(x, w) ̸∈Rpp ∧(x, π) ̸∈Q | (pp, τ) ←CRS-Gen(1λ, lpp),
(x, π) ←ASimProve(pp; ρ), w ←EA(pp, (x, π), ρ, Q)

= negl(λ),
where SimProve(pp, τ, ·) is an oracle that returns a simulated proof π ←
Sim(pp, τ, x) for a given statement x and Q = {(xi, πi)}i denotes the set of
queried statements and the simulated proofs returned by SimProve.
In the following sections, we extend the syntax with an algorithm Com that
inputs a vector x ∈Dn over a domain D and outputs a commitment C. This
commitment will be incorporated in the specific relation Rpp defined by CRS-Gen.
13

2.3
Algebraic Group Model
The algebraic group model (AGM) [48] is an idealized model, where all algo-
rithms are assumed to be algebraic. Algebraic algorithms [14,89] generalize the
notion of a generic algorithm [92] in that, whenever they compute a group el-
ement, they do it using generic operations, by taking linear combinations of
available group elements so far. Hence, whenever they output a group element
X ∈G, they also output a representation {αi}N
i=1 of X = QN
i=1 gαi
i
as a function
of previously observed group elements (g1, . . . , gN) ∈GN in the same group.
In contrast with generic algorithms, algebraic algorithms can exploit the
structure of the group and obtain more information than they would in the
generic group model. Although its relation with the generic group model is un-
clear [75], the AGM provides a powerful framework to analyze the security of
efficient protocols via reductions. In particular, it has been widely used in the
context of SNARKs [48,86,50,11,53,51].
3
Short Proofs That a Committed Vector is Binary
Our construction for binary strings is defined for the relation
Rpp =
(
(x, w) =
  ˆV = ˆgγ ·
n
Y
i=1
ˆgxi
1 ∈ˆG,
 γ, (x1, . . . , xn)

∈Zp × {0, 1}n
)
where pp denotes the CRS containing the commitment key (ˆg, {ˆgi}n
i=1) and the
description of groups (G, ˆG, GT ). Since the commitment is perfectly-hiding, the
proven relation is trivially satisfied because, for any group element ˆV , there exists
a string x ∈{0, 1}n and a corresponding γ ∈Zp such that ˆV = ˆgγ · Qn
i=1 ˆgxi
i .
However, we can prove that the scheme is an argument of knowledge.
CRS-Gen(1λ, 1n): On input of a security parameter λ and the maximal dimen-
sion n ∈poly(λ) of committed vectors, do the following:
1. Choose asymmetric bilinear groups (G, ˆG, GT ) of prime order p > 2l(λ),
for some function l : N →N, and g
R←G, ˆg
R←ˆG.
2. Pick α
R←Zp. Compute g1, . . . , gn, gn+2, . . . , g2n ∈G and ˆg1, . . . , ˆgn ∈ˆG,
where gi = g(αi) for each i ∈[2n]\{n+1} and ˆgi = ˆg(αi) for each i ∈[n].
3. Choose hash functions H, Ht : {0, 1}∗→Zn
p and Hagg : {0, 1}∗→Z2
p.
The public parameters are
pp =

(G, ˆG, GT ), g, ˆg, {gi}i∈[2n]\{n+1}, {ˆgi}i∈[n], H = {H, Ht, Hagg}

.
Compp(x): To commit to a vector x = (x1, . . . , xn) ∈Zn
p, choose a random
γ
R←Zp and compute ˆC = ˆgγ · Qn
j=1 ˆgxj
j . Return ˆC ∈ˆG and the opening
information aux = γ ∈Zp.
14

Provepp
  ˆC, (x, aux)

: given a commitment ˆC and witnesses
 x; aux

consisting
of a vector x = (x1, . . . , xn) ∈Zn
p and randomness aux = γ ∈Zp, return ⊥
if (x1, . . . , xn) ̸∈{0, 1}n. Otherwise, do the following:
1. Compute y = (y1, . . . , yn) = H( ˆC) ∈Zn
p. Choose γy
R←Zp and compute
Cy = gγy ·
n
Y
j=1
gyj·xj
n+1−j
Then, compute t = (t1, . . . , tn) = Ht(y, ˆC, Cy) ∈Zn
p.
2. Generate a proof
πeq =
Qn
i=1

gγ
n+1−i · Q
j∈[n]\{i} gxj
n+1−i+j
ti·yi
Qn
i=1

gγy
i
· Q
j∈[n]\{i} gyj·xj
n+1−j+i
ti
(12)
which satisfies
e(Qn
i=1 gti·yi
n+1−i, ˆC)
e(Cy, Qn
i=1 ˆgti
i )
= e(πeq, ˆg) ,
(13)
and argues that Cy commits to (yn · xn, . . . , y1 · x1) ∈Zn
p.
3. Compute a proof
πy = gγ·γy ·
n
Y
j=1
gγ·yj·(xj−1)
n+1−j
·
n
Y
i=1
 gγy
i
·
Y
j∈[n]\{i}
gyj·(xj−1)
n+1−j+i
xi
(14)
showing that Pn
i=1 yi · xi · (xi −1) = 0 and satisfying
e
 Cy ·
n
Y
j=1
g−yj
n+1−j, ˆC

= e(πy, ˆg)
(15)
4. Compute (δeq, δy) = Hagg( ˆC, Cy) ∈Z2
p and then π = πδeq
eq · πδy
y .
Output the final proof π :=
 Cy, π

∈G2.
Verifypp
  ˆC, π

: Given ˆC ∈ˆG and a purported proof π =
 Cy, π

∈G2,
1. Compute y = H( ˆC) ∈Zn
p, (δeq, δy) = Hagg( ˆC, Cy) ∈Z2
p and t =
Ht(y, ˆC, Cy) ∈Zn
p.
2. Return 1 if the following equations is satisfied and 0 otherwise:
e
 Cδy
y · Qn
i=1 g(δeq·ti−δy)·yi
n+1−i
, ˆC

e
 Cy, Qn
i=1 ˆgδeq·ti
i

= e(π, ˆg).
(16)
Correctness follows from the observation that equation (16) is obtained by
aggregating (13)-(15), for which a detailed proof of correctness can be found in
Supplementary Material C.1.
15

In the algebraic group model, the construction can be proven zero-knowledge
and knowledge-sound (the zero-knowledge simulator actually needs an algebraic
representation of the adversarially-chosen commitment ˆC but this requirement
can be removed by swapping the groups where ˆC and Cy live). The proof of
knowledge-soundness can be inferred from the proof of Theorem 2 (in Section
4), of which it is a sub-case. In the upcoming sections, we will combine the system
with other components in such a way that the combined arguments satisfy the
stronger notion of simulation-extractability.
In Supplementary Material B, we provide a detailed comparison with the
construction of Das et al. [39] and show that our scheme yields more compact
range proofs. In Supplementary Material F, we also explain how to prove the
exact Hamming weight (or an upper bound thereof) of committed binary/ternary
vectors using 4 group elements.
4
A Range Proof With Very Short Proofs
Using the non-interactive argument for binary vectors from Section 3, we can
build range arguments made of a constant number of group elements.
In the description below, we assume ranges [0, B] such that B + 1 is a power
of 2 but the approach easily extends to general ranges. The standard approach to
this problem is to consider the integer ℓ∈N such that 2ℓ−1 ≤B < 2ℓand gener-
ate two range proofs showing that x ∈[0, 2ℓ−1] and x+(2ℓ−1−B) ∈[0, 2ℓ−1],
where the second part is proven by leveraging the additive homomorphic prop-
erty of the commitment. Instead of generating two independent range proofs, we
can double the size of the CRS (by setting n = 2¯ℓ, where ¯ℓ≥ℓis the maximal
bitlength of the range) and avoid increasing the proof size. In Supplementary
Material D.4, we provide more details on the treatment of general ranges.
4.1
Description
We assume that the initial Pedersen commitment ˆV = ˆgr · ˆgx
1 to the witness
x ∈[0, 2ℓ−1] lives in the second source group ˆG of the pairing.3
The range membership relation is formally defined as
Rpp =
n
(x, w) =
 ( ˆV = ˆgr · ˆgx
1, ℓ) ∈ˆG × N, (r, x) ∈Zp × [0, 2ℓ−1]
o
where the CRS pp specifies the commitment key (ˆg, g1) and the groups (G, ˆG, GT ).
CRS-Gen(1λ, 1n): On input of a security parameter λ and the maximal bitlength
n ∈poly(λ) of ranges, do the following:
3 Committing x to a different, pairing-free, group G would not strengthen security
since an adversary that would be able to compute α from pp would still break
knowledge-soundness. The construction of [12] similarly assumes that the integer x
is committed as a polynomial f[X] such that f(1) = x.
16

1. Choose asymmetric bilinear groups (G, ˆG, GT ) of prime order p > 2l(λ),
for some polynomial function l : N →N, and g
R←G, ˆg
R←ˆG.
2. Pick a random α
R←Zp and compute g1, . . . , gn, gn+2, . . . , g2n ∈G as
well as ˆg1, . . . , ˆgn ∈ˆG, where gi = g(αi) for each i ∈[2n] \ {n + 1} and
ˆgi = ˆg(αi) for each i ∈[n].
3. Choose hash functions H, Ht : {0, 1}∗→Zn
p, Hs : {0, 1}∗→Zp and
Hagg : {0, 1}∗→Z4
p that will be modeled as random oracles.
The public parameters are defined to be
pp =

(G, ˆG, GT ), g, ˆg, {gi}i∈[2n]\{n+1}, {ˆgi}i∈[n], H = {H, Hs, Ht, Hagg}

Compp(x): To commit to an integer x ∈Z, choose a random r
R←Zp and
compute a Pedersen commitment ˆV = ˆgr · ˆgx
1 ∈ˆG. Return com = ˆV ∈ˆG
and the opening information aux = r ∈Zp.
Provepp
 com, (x, aux)

: given com = ˆV and witnesses
 x; aux

consisting of an
integer x ∈[0, 2ℓ−1] with binary expansion (x1, . . . , xℓ) ∈{0, 1}ℓ, where
ℓ≤n, and aux = r ∈Zp such that ˆV = ˆgr · ˆgx
1, do the following:
1. Set (xℓ+1, . . . , xn) = 0n−ℓ. Choose γ
R←Zp and compute
ˆC = ˆgγ ·
ℓ
Y
j=1
ˆgxj
j
together with a proof πx ∈G that ˆC commits to (x1, . . . , xn) ∈Zn
p such
that Pℓ
i=1 xi · 2i−1 = x. This proof πx satisfies
e(Qℓ
i=1 g2i−1
n+1−i, ˆC)
e(gn, ˆV )
= e(πx, ˆg)
(17)
and is obtained as
πx = g−r
n
·
ℓ
Y
i=1

gγ
n+1−i ·
Y
j∈[ℓ]\{i}
gxj
n+1−i+j
2i−1
.
2. Compute y = (y1, . . . , yn) = H( ˆV , ˆC) ∈Zn
p. Pick γy
R←Zp and compute
Cy = gγy ·
ℓ
Y
j=1
gyj·xj
n+1−j
Then, compute t = (t1, . . . , tn) = Ht(y, ˆV , ˆC, Cy) ∈Zn
p.
3. Prove that Cy commits to (y1·x1, . . . , yn·xn) ∈Zn
p by computing a short
πeq ∈G (as specified in (12)) satisfying
e(Qn
i=1 gti·yi
n+1−i, ˆC)
e(Cy, Qn
i=1 ˆgti
i )
= e(πeq, ˆg).
(18)
17

4. Prove that Pn
i=1 yi · xi · (xi −1) = 0 by computing πy ∈G via (14),
which satisfies
e
 Cy ·
n
Y
j=1
g−yj
n+1−j, ˆC

= e(πy, ˆg)
(19)
5. Generate an aggregated proof that ˆV = ˆgr · ˆgx
1 is a commitment to a
vector that contains 0 in its last n −1 coordinates. Namely, compute
πv = Qn
i=2

gr
n+1−i · gx
n+2−i
si
∈G such that
e
 n
Y
i=2
gsi
n+1−i, ˆV

= e(πv, ˆg).
(20)
where si = Hs(i, [2, n], ˆV , ˆC, Cy) ∈Zp for each i ∈[2, n].
6. Compute (δx, δeq, δy, δv) = Hagg( ˆV , ˆC, Cy) ∈Z4
p and an aggregated proof
π = πδx
x · πδy
y · πδeq
eq · πδv
v .
Output the final range argument which consists of
π :=
  ˆC, Cy, π

.
(21)
Verifypp
 com, π

: Given com = ˆV ∈ˆG and a purported proof π =
  ˆC, Cy, π

,
1. Compute y = H( ˆV , ˆC) ∈Zn
p, (δx, δeq, δy, δv) = Hagg( ˆV , ˆC, Cy) ∈Z4
p,
t = Ht(y, ˆV , ˆC, Cy) ∈Zn
p. Set s1 = 0 and si = Hs(i, [2, n], ˆV , ˆC, Cy) for
all indices i ∈[2, n].
2. Return 1 if and only if
e
 Cδy
y · Qn
i=1 gδx,i·2i−1+(δeq·ti−δy)·yi
n+1−i
, ˆC

e
 gδx
n · Qn
i=2 g−δv·si
n+1−i, ˆV

· e
 Cy, Qn
i=1 ˆgδeq·ti
i
 = e(π, ˆg),
(22)
where δx,i = δx if i ∈[ℓ] and δx,i = 0 if i ∈[ℓ+ 1, n].
Correctness. The verification equation (22) is obtained by raising equalities
(17), (18), (19) and (20) to the powers δx, δeq, δy, and δv, respectively, and
multiplying the results together. In Supplementary Material C.1, we provide
detailed proofs of correctness for individual verification equations (17)-(20).
Efficiency. The cost of the prover is dominated by 3n exponentiations in G
and two exponentiations in ˆG. Indeed, computing ˆC at step 1 only requires one
exponentiation and a subset product (which is cheaper than an exponentiation)
in ˆG. Step 2 requires n + 1 exponentiations in G. Instead of individually com-
puting the proof elements (πx, πeq, πy, πv), the prover can directly compute the
entire product π at step 6 using only 2n exponentiations since the aggregation
18

coefficients (δx, δeq, δy, δv), y and t only depend on the commitments ( ˆV , ˆC, Cy).
This allows the prover to obtain the coefficients allowing to compute π from
{gi}i̸=n+1 via 3 polynomial products (which are implicitly computed in the ex-
ponent by the pairings in the left-hand-side member of (22)) by interpreting
each commitment as a polynomial evaluated in α in the exponent. Overall, the
prover’s overhead amounts to 3n exponentiations in G, 2 exponentiations in ˆG,
and O(n log n) multiplications over Zp. The verifier’s work is dominated by 2n+1
exponentiations in G, n exponentiations in ˆG and 4 pairings.
In terms of proof length, π only requires one element of ˆG, and 2 element
of G, which matches the optimal size of simulation-extractable pairing-based
SNARKs [68]. Using the KSS18 family of pairing-friendly curves suggested by
Kachisa et al. [73], each element of G (resp. ˆG) can have a 348-bit (resp. 1044-
bit) representation at the 128-bit security level according to [44]. Assuming that
elements of ˆG are three times as large as those of G, the overall proof length
does not exceed the equivalent of 5 elements of G, which amounts to 1740 bits.
In Section 4.4, we give a detailed comparison among existing constant-size
range proofs. As shown in Table 1, our scheme provides the shortest proof length
and the smallest computational cost at the prover.
4.2
Security in the AGM & ROM
We first prove the zero-knowledge property in the random oracle model.
Theorem 1. The construction provides statistical zero-knowledge in the ROM.
(The proof is given in Supplementary Material C.2.)
The simulator in the proof of Theorem 1 proceeds by programming the ran-
dom oracles and also uses the trapdoor of the CRS. On the other hand, it works
for any given ˆV ∈ˆG without knowing an algebraic representation of ˆV . If we
restrict ˆV to be chosen by an algebraic adversary, it is possible to build an
algebraic simulator that does not rely on random oracles.
In the proof of simulation-extractability, we need to build a trapdoor-less
simulator, which does not use the trapdoor α of the common reference string.
Theorem 2. Under the (2n, n)-DLOG assumption, the scheme is simulation-
extractable in the algebraic group model and in the random oracle model.
Proof. In the AGM+ROM model, we show that, unless the (2n, n)-DLOG as-
sumption is false, there exists an extractor that can extract a witness from
any adversarially-generated proof π =
  ˆC, Cy, π

and statement ( ˆV , [0, 2ℓ−1]).
Specifically, we give an algorithm B that can either extract a witness (x, r) with
x ∈[0, 2ℓ−1] or solve an (2n, n)-DLOG instance by computing α ∈Zp from
{(g, g1, . . . , g2n), (ˆg1, . . . , ˆgn)}, where gi = g(αi) and ˆgi = ˆg(αi) for all i.
The given problem instance {(g, g1, . . . , , g2n), (ˆg1, . . . , ˆgn)} is used to define
the CRS pp. Note that gn+1 = g(αn+1) is not included in pp and will never be
used by B. Our reduction/extractor B then interacts with A as follows.
19

Queries: At each random oracle query, B returns a random element in the ap-
propriate range. When A queries a hash value Hagg( ˆV , ˆC, Cy), B makes the cor-
responding queries y = H( ˆV , ˆC), t = Ht(y, ˆV , ˆC, Cy), {si = Hs(i, ˆV , [2, n])}n
i=2
for itself before returning a tuple (δx, δeq, δy, δv). At the first query involving a
group element, A provides a representation of this group element as a linear
combination of all the group elements that it observed so far in the same group.
At any time, A can choose a commitment com = ˆV and ask for a sim-
ulated proof that ˆV is a commitment to some integer in [0, 2ℓ−1] for some
ℓ≤n of its choice. Since A is algebraic, it provides a representation of ˆV w.r.t.
{ˆgi}i∈[0,n] and the commitments ˆC contained in earlier simulated proofs. How-
ever, the simulator used by B is itself algebraic and always simulates proofs by
computing ˆC as a linear combination of {ˆgi}i∈[0,n] for coefficients of its choice.
Hence, for any ˆV chosen by A, B can always compute a representation {vi}n
i=0
such that ˆV = ˆgv0 · Qn
i=1 ˆgvi
i . We assume w.l.o.g. that either v1 ̸∈[0, 2ℓ−1]
or (v2, . . . , vn) ̸= 0 since, otherwise, B can generate a real proof using (v1, v0).
Then, B simulates a proof as follows without using gn+1:
1. Choose random vectors δ = (δx, δeq, δy, δv)
R←Z4
p, y = (y1, . . . , yn)
R←Zn
p,
t = (t1, . . . , tn)
R←Zn
p.
2. Let fn+1 = Pn
i=2 vi · si for random s2, . . . , sn
R←Zp. Define zn = y1 and
a1 = v1 −δv · fn+1
δx
∀i ∈[2, n] : ai = 0
Note that a1 ̸∈{0, 1} w.h.p. if v1 ̸∈[0, 2ℓ−1] or (v2, . . . , vn) ̸= 0. Then,
compute an arbitrary vector (z1, . . . , zn−1) ∈Zn−1
p
satisfying the equality
Pn
i=2 ti · zn+1−i = t1 · (a1 · y1 −y1).
3. Choose random a0, z0
R←Zp and compute simulated commitments
ˆC = ˆga0 ·
n
Y
i=1
ˆgai
i
= ˆga0 · ˆga1,
Cy = gz0 ·
n
Y
i=1
gzi
i .
4. If one of the random oracle values Hagg( ˆV , ˆC, Cy), H( ˆV , ˆC), Ht(y, ˆV , ˆC, Cy)
or {Hs(i, [2, n], ˆV , ˆC, Cy)}n
i=2 was already defined, then abort and report fail-
ure. Otherwise, set y = H( ˆV , ˆC), t = Ht(y, ˆV , ˆC, Cy), δ = Hagg( ˆV , ˆC, Cy)
and si = Hs(i, [2, n], ˆV , ˆC, Cy) for each i ∈[2, n].
5. Define the polynomials
Qx[X] =

n
X
i=0
ai · Xi
·

ℓ
X
i=1
2i−1 · Xn+1−i
−

n
X
i=0
vi · Xi+n
=
n+ℓ
X
i=0
qi · Xi,
Qy[X] =

n
X
i=0
zi · Xi −
n
X
i=1
yi · Xn+1−i
·

n
X
i=0
ai · Xi
=
2n
X
i=0
σi · Xi
20

Qeq[X] =

n
X
i=0
ai · Xi
·

n
X
i=1
ti · yi · Xn+1−i
−

n
X
i=0
zi · Xi
·

n
X
i=1
ti · Xi
=
2n
X
j=0
ej · Xj,
Qv[X] =

n
X
i=0
vi · Xi
·

n
X
i=2
si · Xn+1−i
=
2n
X
j=0
fj · Xj.
Their degree-(n + 1) coefficients are fn+1 = Pn
i=2 vi · si and
qn+1 = −v1 +
ℓ
X
i=1
ai · 2i−1 = −v1 + a1 = −δv · fn+1
δx
,
σn+1 =
n
X
i=1
ai · (zn+1−i −yi) = a1 · (zn −y1) = 0
en+1 =
n
X
i=1
ti · (ai · yi −zn+1−i) = t1 · (a1 · y1 −y1) −
n
X
i=2
ti · zn+1−i = 0
due to the definition of a = (a1, . . . , an) and z = (z1, . . . , zn). Note that
δx · qn+1 + δeq · en+1 + δy · σn+1 + δv · fn+1 = 0
(23)
6. Define the polynomial
Qagg[X] = δx · Qx[X] + δeq · Qeq[X] + δy · Qy[X] + δv · Qv[X] =
2n
X
i=0
ηi · Xi
for which ηn+1 = 0 by construction. Compute π = Q2n
i=1,i̸=n+1 gηi
i
using
(g, {gi}i∈[2n]\{n+1}) and return the simulated proof π = ( ˆC, Cy, π).
Note that the simulated π satisfies the verification equation
e
 Cδy
y · Qℓ
i=1 gδx·2i−1+(δeq·ti−δy)·yi
n+1−i
· Qn
i=ℓ+1 g(δeq·ti−δy)·yi
n+1−i
, ˆC

e
 gδx
n · Qn
i=2 g−δv·si
n+1−i, ˆV

· e
 Cy, Qn
i=1 ˆgδeq·ti
i

= e(π, ˆg).
(24)
and π has the same distribution as a proof generated by the zero-knowledge
simulator in the proof of Theorem 1. Indeed, π is uniquely determined by the
commitments ( ˆC, ˆV , Cy) and the Zp-elements y, t, {si}n
i=2, and δ in (24). Also,
while the committed vectors a, z ∈Zn
p are programmed in a special way, they
are perfectly hidden by the randomness a0 and z0 in ˆC and Cy.
Consequently, the simulation is perfect, unless a collision occurs when ran-
dom oracles are programmed in one of the simulation queries. If QS (reps. QH)
denotes the number of queries made by A to the simulator (resp. to random
oracles), this happens with probability at most (QS + QH) · QH/p.
21

Output: When A halts, it outputs a statement ( ˆV , [0, 2ℓ−1]), for some ℓ∈[1, n],
together with a verifying proof π =
  ˆC, Cy, π

.
Any malicious algebraic prover that comes up with a commitment com = ˆV
and a proof π =
  ˆC, Cy, π

also gives a representation of each group element
w.r.t. the group elements that have been observed so far.4 In particular, A must
provide a representation of Cy w.r.t to (g, {gi}i∈[2n]\{n+1}) and the group ele-
ments {C(i)
y , π(i)}i∈[QS] contained in simulated proofs {π(i)}i∈[QS]. Likewise, A
must provide a representation of ˆC w.r.t (ˆg, {ˆgi}i∈[n]) and the commitments
{ ˆC(i)}i∈[QS] contained in {π(i)}i∈[QS]. However, for each i ∈[QS], B knows
a representation of ˆC(i) w.r.t. (ˆg, {ˆgi}i∈[n]) and a representation of Cy w.r.t.
(g, {gi}n
i=1). It also knows a representation of each π(i) w.r.t (g, {gi}i∈[2n]\{n+1}).
From A’s output and the random coins of the simulation, B can compute scalars
{(θi, zi) ∈Z2
p}i∈[0,2n]\{n+1}, {(ai, vi) ∈Z2
p}i∈[0,n] such that
ˆC =
n
Y
i=0
ˆgai
i ,
Cy =
2n
Y
i=0,i̸=n+1
gzi
i ,
ˆV =
n
Y
i=0
ˆgvi
i ,
π =
2n
Y
i=0,i̸=n+1
gθi
i ,
where we define g0 = g and ˆg0 = ˆg for convenience.
If the representation (v0, v1, . . . , vn) ∈Z2
p of ˆV is such that v1 ∈[0, 2ℓ−1]
and vi = 0 for all i ∈[2, n], then B is done as it can simply output (v1, v0) ∈Z2
p
as a valid opening of the Pedersen commitment ˆV to an integer v1 in the proper
range. We now assume that either v1 ̸∈[0, 2ℓ−1] or (v2, . . . , vn) ̸= 0n−1.
Solving (2n, n)-DLOG: By hypothesis, A’s statement (com = ˆV , [0, 2ℓ−1]) and
proof π =
  ˆC, Cy, π

satisfy (24), where y = H( ˆV , ˆC), t = Ht(y, ˆV , ˆC, Cy), s0 =
0, si = Hs(i, [2, n], ˆV , ˆC, Cy) for i ∈[2, n], and (δx, δeq, δy, δv) = Hagg( ˆV , ˆC, Cy).
We first note that a non-trivial valid π cannot recycle ( ˆV , ˆC, Cy) obtained
from the simulation oracle (namely, we must have ( ˆV , ˆC, Cy) ̸= ( ˆV (i), ˆC(i), Cy)
for all i ∈[QS]) since the left-hand-side member of (24) is uniquely determined
by ( ˆV (i), ˆC(i), C(i)
y ) and it in turn determines a unique valid π(i). Consequently,
the hash values Hagg( ˆV , ˆC, Cy), Ht(y, ˆV , ˆC, Cy) and {Hs(i, [2, n], ˆV , ˆC, Cy)}n
i=2
were not programmed by the simulator in a simulation query.
We also note that the left-hand-side member of (24) is obtained by rais-
ing those of (17)-(20) to the powers (δx, δeq, δy, δv) and multiplying the results
together. Hence, it can be written e(g, ˆg)Pagg(α), where Pagg[X] is the polynomial
Pagg[X] = δx · Px[X] + δy · Py[X] + δeq · Peq[X] + δv · Pv[X]
4 These representations are supplied by A at the first query involving the correspond-
ing group elements.
22

obtained as a linear combination of the polynomials
Px[X] =

n
X
i=0
ai · Xi
·

ℓ
X
i=1
2i−1 · Xn+1−i
−
 n
X
i=0
vi · Xn+i
=
n+ℓ
X
i=0
ωi · Xi,
Py[X] =

z0 +
n
X
i=1
 zn+1−i −yi

· Xn+1−i +
2n
X
i=n+2
zi · Xi
·

n
X
i=0
ai · Xi
=
3n
X
i=0
γi · Xi
Peq[X] =

n
X
i=0
ai · Xi
·

n
X
i=1
ti · yi · Xn+1−i
−

2n
X
i=0,i̸=n+1
zi · Xi
·

n
X
i=1
ti · Xi
=
3n
X
j=0
βj · Xj,
Pv[X] =

n
X
i=0
vi · Xi
·

n
X
i=2
si · Xn+1−i
=
2n
X
j=0
µj · Xj
for which the left-hand-side members of (17)-(20) can be written e(g, ˆg)Px(α),
e(g, ˆg)Peq(α), e(g, ˆg)Py(α), and e(g, ˆg)Pv(α), respectively.
Letting Pagg[X] = P3n
i=0 νi · Xi, the coefficient of its degree-(n + 1) term is
νn+1 = δx · (
ℓ
X
i=1
ai · 2i−1 −v1)
|
{z
}
≜ωn+1
+ δy ·
n
X
i=1
 zn+1−i −yi

· ai
|
{z
}
≜γn+1
+ δeq ·
n
X
i=1
ti · (ai · yi −zn+1−i)
|
{z
}
≜βn+1
+ δv ·
n
X
i=2
vi · si
|
{z
}
≜µn+1
,
where (ωn+1, γn+1, βn+1, µn+1) are the coefficients of the degree-(n+1) terms of
(Px[X], Py[X], Peq[X], Pv[X]), respectively. We argue that, if v1 ̸∈[0, 2ℓ−1] or
(v2, . . . , vn) ̸= 0n−1, we cannot have νn+1 = 0, except with negligible probability.
This follows from the following two arguments:
- The probability that ρ ≜(ωn+1, γn+1, βn+1, µn+1) = 0 is negligible if v1 ̸∈
[0, 2ℓ−1] or (v2, . . . , vn) ̸= 0n−1. Indeed, when (v2, . . . , vn) ̸= 0n−1, we
have µn+1 = 0, with probability 1/p over the random choice of {si}n
i=2 since
{si = Hs(i, [2, n], ˆV , ˆC, Cy)}n
i=2 are derived uniformly after the choice of
{vi}n
i=2. Likewise, when zn+1−i ̸= ai · yi for some i ∈[n], we have βn+1 = 0
with probability 1/p since t = Ht(y, ˆV , ˆC, Cy) is derived after the choice of
y, {ai}n
i=0 and {zi}i∈[0,2n]\{n+1}. Then, if zn+1−i = ai · yi for all i ∈[n], we
have γn+1 = Pn
i=1 yi ·(ai −1)·ai, which cancels with probability 1/p if there
exists i ∈[n] such that ai ̸∈{0, 1}. To see this, we distinguish two cases:
23

a. If y = H( ˆV , ˆC) was programmed in a simulation query, we only have
γn+1 = 0 with probability 1/p since B chose (a1, . . . , an) so as to have
γn+1 = Pn
i=1 yi·ai·(ai−1) = y1·a1·(a1−1) with y1 ∈R Zp and a1 ̸∈{0, 1}.
This covers the case of A attempting to recycle ( ˆV , ˆC) = ( ˆV (i), ˆC(i)) from
a simulated π(i) = ( ˆC(i), C(i)
y , π(i)), with a modified Cy ̸= C(i)
y .
b. If H( ˆV , ˆC) was not programmed by the simulator, then y = H( ˆV , ˆC)
was defined after B obtained the representation {ai}n
i=0 of ˆC. Over the
choice of y, we have Pn
i=1 yi · (ai −1) · ai = 0 with probability 1/p.
If none of the above events occurs and ωn+1 = 0, we have v1 = Pℓ
i=1 ai ·2i−1
and ai ∈{0, 1} for all i ∈[ℓ], which contradicts the hypothesis v1 ̸∈[0, 2ℓ−1].
- If ρ ̸= 0, then νn+1 ̸= 0 with probability 1 −1/p since δ = Hagg( ˆV , ˆC, Cy)
is derived after the choice of {(ai, vi)}n
i=0, and {zi}i∈[0,2n]\{n+1}, which de-
termine ρ. So, a random δ ∈Z4
p satisfies ⟨δ, ρ⟩= 0 with probability 1/p.
If νn+1 ̸= 0, B can compute α ∈Zp by observing that the aggregated verifi-
cation equation (24) implies
π = gνn+1
n+1 ·
Y
i∈[0,3n]\{n+1}
gνi
i ,
(25)
where g2n+1 = g(α2n+1),. . . , g3n = g(α3n) are not available. However, B knows
{νi}3n
i=0. Since νn+1 ̸= 0, we are guaranteed that the representation (25) of π
differs from its representation π = Q2n
i=0,i̸=n+1 gθi
i
revealed by A as part of its
output. This means that α ∈Zp can be found among the roots of the non-zero
R[X] =
X
i∈[0,2n]\{n+1}
(νi −θi) · Xi + νn+1 · Xn+1 +
3n
X
i=2n+1
νi,
⊓⊔
4.3
Batched Range Proofs and Proving the Smallness of Vectors
As detailed in Supplementary Material D, the construction extends to prove mul-
tiple ranges at once for a committed vector ˆV = ˆgr·Qm
k=1 ˆgxk
k of integers. Namely,
ˆC commits to concatenation of the binary decompositions of all {xk}m
k=1. Then,
a single group element allows proving that, for each k ∈[m], the k-th sub-
vector xk = (xk,1, . . . , xk,ℓ, 0, . . . , 0) hidden by ˆC is a binary vector satisfying
xk = Pℓ
i=1 xk,i · 2i−1. For the k-th slot, the prover computes πk ∈G such that
e
 ℓ
Y
i=1
g2i−1
n+1−((k−1)¯ℓ+i), ˆC

= e(g1, ˆgn)xk · e(πk, ˆg)
(26)
Since ˆV is itself a vector commitment, the prover can compute πv,k such that
e
 gk, ˆV

= e(g1, ˆgn)xk · e(πv,k, ˆg)
(27)
24

Then, by dividing (27) from (26), raising the result to a random power ξk ∈Zp
and taking the product over all indices k ∈[m], we find that the prover is able
to compute a short π = Qm
k=1(πk/πv,k)ξk such that
e
  Qm
k=1
  Qℓ
i=1 g2i−1
n+1−((k−1)¯ℓ+i)
ξk, ˆC

e
  Qm
k=1 gξk
k , ˆV

= e(π, ˆg),
(28)
which argues that xk = Pℓ
i=1 xk,i · 2i−1 for all k ∈[m]. Indeed, otherwise, we
have Pm
k=1 ξk · (xk −Pℓ
i=1 xk,i · 2i−1) = 0 with negligible probability 1/p as long
as (ξ1, . . . , ξm) are chosen uniformly after the commitments ˆV and ˆC.
The remaining proof elements are computed exactly as in the single-slot
setting, so that the final proof π still lives in ˆG×G2. This immediately provides
a short proof that a committed vector has small infinity norm. By introducing a
few more group elements in the proof, we can also prove small Euclidean norms,
as explained in Supplementary Material E.
4.4
Comparisons
Our construction assumes that the witness x is committed using a Pedersen
commitment in the pairing-friendly group specified by the CRS of the range
proof. The range proof of [12] similarly requires x to be committed as a constant
polynomial using the CRS of a polynomial commitment scheme.
The BFGW range proofs [12] were the shortest ones so far and they also
feature constant verification time (whereas our verifier computes O(n) expo-
nentiations, where n is the maximal bitlength of the range, as in BulletProofs).
When instantiated with KZG commitments [74] and the cross-commitment eval-
uation techniques of [11, Section 4.1], BFGW proofs consist of 2 commitments
to polynomials (each of which takes an element of G), 3 elements of Zp repre-
senting evaluations of committed polynomials, and a batched evaluation proof
comprised of a group element and at least one scalar.5 If their construction is in-
stantiated with the polynomial commitment of [80, Section 4.1]6 and the batched
evaluation protocol of [11, Section 4.1], the communication cost decreases to 2
elements of G (which commit to polynomials), 3 scalars (for polynomial evalua-
tions) and a single element of G for the batched evaluation proof. In the latter
case, the range proof of [12] only requires 3 elements of G and 3 elements of
Zp. On the downside, combining [12,80] induces 2n exponentiations in ˆG at the
verifier (instead of O(1) using KZG commitments) and increases the prover’s
overhead to 7n exponentiations in G.
5 In randomized versions of the KZG commitment (described in [74, Section 3.3], [11,
Appendix B.2] and [99]), each evaluation proof consists of an element of G and at
least one scalar or an additional element of G.
6 In order to prove the knowledge soundness of the range proof of [12] when the poly-
nomial commitment of [80] is used, it is necessary to rely on the latter’s knowledge
soundness in the AGM (as defined in [11, Appendix C.1.3]) but we believe this
property holds under the (2n, n)-DLOG assumption.
25

Not only does our construction ensure simulation-extractability in the AGM,
it also features the smallest number of exponentiations at the prover (which is
reduced by at least 40%) while matching the shortest proof length of SNARKs.
In terms of space, our construction also improves upon BulletProofs [19],
which requires the prover to send 2⌈log ℓ⌉+ 4 group elements and 5 elements of
Zp. If we compare with SNARKs, we obtain the same proof size as optimally
short candidates [67,68] with the advantage that our CRS size is much shorter:
It only depends on the maximal bitlength n of a range rather than the size of a
circuit representation of the statement. Also, our prover only needs to compute
O(n) exponentiations instead of a number of exponentiations growing with the
size of an arithmetic circuit that computes a commitment opening (which would
be very large as the circuit would have to compute modular exponentiations).
In Table 1, we compare our constant-size range proofs with existing pairing-
based solutions featuring similarly short proofs. Several instantiations of [10] are
considered for different polynomial commitment schemes that are known to pro-
vide constant-size evaluation proofs. Among schemes that do not generically rely
on SNARKs, we only consider those where the CRS size is at most logarithmic
in the maximal range magnitude N = 2n (i.e., linear in n). For example, Table 1
does not include range proofs based on lookup arguments [49,98] as they would
require a CRS of size O(N) = O(2n). For a range [0, 230], this would translate
into a CRS of about 30 Gb instead of 6 Kb in our construction.
Table 1. Efficiency comparisons between constant-size range proofs
Schemes
Proof size
CRS size
Prover cost
Verifier cost
BFGW [12]
3 × |G|
(4n + 2) × |G|
5n expG
3P + 4 expˆG
+ KZG [74, Section 3.3]
4 × |Zp|
4 × |ˆG|
1 expG
BFGW
4 × |G|
(2n + 1) × |G|
5n expG
3P + 4 expˆG
+ Zhang et al. [99]
3 × |Zp|
3 × |ˆG|
1 expG
BFGW
3 × |G|
4n × |G|
7n expG
3P + 2n expˆG
+ LRY [80]
3 × |Zp|
2n × |ˆG|
2 expG
Groth16 [67]
1 × |ˆG|
3|C| × |G|
4|C| expG
3P + O(1) expG
2 × |G|
|C| × |ˆG|
|C| expˆG
New construction
1 × |ˆG|
2n × |G|
3n expG
4P + 2n expG
(Section 4)
2 × |G|
n × |ˆG|
1 expˆG
n expˆG
n multˆG
expG and expˆG denote exponentiations in G and ˆG while multˆG denotes a multiplication in ˆG;
n denotes the bitlength of the range; P stands for a pairing computation; |C| is the size of the
arithmetic circuit verifying a commitment opening.
References
1. M. Albrecht, V. Cini, R.-F. Lai, G. Malavolta, and S.-A. Thyagarajan. Lattice-
based SNARKs: Publicly verifiable, preprocessing, and recursively composable. In
Crypto, 2022.
26

2. A. Arun, C. Ganesh, S. Lokam, T. Mopuri, and S. Sridhar. A transparent constant-
sized polynomial commitment scheme. In PKC, 2023.
3. K. Baghery, M. Kohlweiss, J. Siim, and M. Volkhov. Another look at extraction and
randomization of Groth’s zk-SNARK. Cryptology ePrint Archive Report 2020/811.
4. K. Baghery, Z. Pindado, and C. R`afols. Simulation extractable versions of Groth’s
zk-SNARK revisited. In CANS, 2020.
5. D. Balbas, D. Catalano, D. Fiore, and R.-F. Lai. Chainable functional commit-
ments: From quadratic polynomials to unbounded-depth circuits. In TCC, 2023.
6. R. Barbulescu and S. Duquesne. Updating key size estimations for pairings. J. of
Cryptology, 4(32), 2019.
7. P. Barreto, B. Lynn, and M. Scott. Constructing elliptic curves with prescribed
embedding degrees. In SCN, 2002.
8. E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. Ward. Aurora:
Transparent succinct arguments for R1CS. In Eurocrypt, 2019.
9. D. Boneh, B. B¨unz, and B. Fisch.
Batching techniques for accumulators with
applications to IOPs and stateless blockchains. In Crypto, 2019.
10. D. Boneh, J. Drake, B. Fisch, and A. Gabizon.
Efficient polynomial commit-
mentschemes for multiple points and polynomials. Cryptology ePrint Archive Re-
port 2020/81, 2020.
11. D. Boneh, J. Drake, B. Fisch, and A. Gabizon. Halo infinite: Recursive zk-SNARKs
from any additive polynomial commitment scheme. In Crypto, 2021.
12. D. Boneh, B. Fisch, A. Gabizon, and Z. Williamson. A simple range proof from
polynomial commitments. https://hackmd.io/@dabo/B1U4kx8XI, 2020.
13. D. Boneh, W. Nguyen, and A. Ozdemir. Efficient functional commitments: How
to commit to a private function. Cryptology ePrint Archive Report 2021/1342.
14. D. Boneh and V. Venkatesan. Breaking RSA may not be equivalent to factoring.
In Eurocrypt, 1998.
15. F. Boudot. Efficient proofs that a committed number lies in an interval. In Euro-
crypt, 2000.
16. S. Bowe and A. Gabizon. Making Groth’s zk-SNARK simulation extractable in
the random oracle model. Cryptology ePrint Archive Report 2018/187.
17. Z. Brakerski, C. Gentry, and V. Vaikuntanathan. (Leveled) Fully Homomorphic
Encryption without Bootstrapping. In ITCS, 2012.
18. E. Brickell, D. Chaum, I. Damg˚ard, and J. van de Graaf. Gradual and verifiable
release of a secret. In Crypto. 1988.
19. B. B¨unz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. Bulletproofs:
Short proofs for confidential transactions and more. In IEEE S&P, 2018.
20. B. B¨unz, B. Fisch, and A. Szepieniec. Transparent SNARKs from DARK compilers.
In Eurocrypt, 2020.
21. B. B¨unz, M. Maller, P. Mishra, N. Tyagi, and P. Vesely. Proofs for inner pairing
products and applications. In Asiacrypt, 2021.
22. J. Camenisch, R. Chaabouni, and A. shelat. Efficient protocols for set membership
and range proofs. In Asiacrypt, 2008.
23. J. Camenisch, M. Dubovitskaya, K. Haralambiev, and M. Kohlweiss. Composable
and modular anonymous credentials: Definitions and practical constructions. In
Asiacrypt, 2015.
24. M. Campanelli, D. Fiore, N. Greco, D. Kolonelos, and L. Nizzardo.
Incremen-
tally aggregatable vector commitments and applications to verifiable decentralized
storage. In Asiacrypt, 2020.
25. M. Campanelli, A. Nitulsecu, C. R`afols, A. Zacharakis, and A. Zapico. Linear-map
vector commitments and their practical applications. In Asiacrypt, 2022.
27

26. D. Catalano and D. Fiore. Vector commitments and their applications. In PKC,
2013.
27. D. Catalano, D. Fiore, R. Gennaro, and E. Giunta. On the impossibility of algebraic
vector commitments in pairing-free groups. In TCC, 2022.
28. D. Catalano, D. Fiore, and I. Tucker. Additive-homomorphic functional commit-
ments and applications to homomorphic signatures. In Asiacrypt, 2022.
29. R. Chaabouni, H. Lipmaa, and B. Zhang.
A non-interactive range proof with
constant communication. In Financial Cryptography, 2012.
30. A. Chan, Y. Frankel, and Y. Tsiounis. Easy come – easy go divisible cash. In
Eurocrypt, 1998.
31. J.-H. Cheon. Security analysis of the Strong Diffie-Hellman problem. In Eurocrypt,
2006.
32. I. Chillotti, N. Gama, M. Georgieva, and M. Izabach`ene. TFHE: Fast fully homo-
morphic encryption over the torus. Journal of Cryptology, 33(1), 2020.
33. H. Chu, D. Fiore, D. Kolonelos, and D. Schr¨oder. Inner product functional com-
mitments with constant-size public parameters and openings. In SCN, 2022.
34. G. Couteau, D. Goudarzi, M. Klooß, and M. Reichle. Sharp: Short Relaxed Range
Proofs. In ACM-CCS, 2022.
35. G. Couteau, M. Klooß, H. Lin, and M. Reichle. Efficient range proofs with trans-
parent setup from bounded integer commitments. In Eurocrypt, 2021.
36. G. Couteau, T. Peters, and D. Pointcheval. Removing the strong RSA assumption
from arguments over the integers. In Eurocrypt, 2017.
37. W. Dai. PESCA: a privacy-enhancing smart-contract architecture. Manuscript.
38. I. Damg˚ard, J. Luo, S. Oechsner, P. Scholl, and M. Simkin.
Compact zero-
knowledge proofs of small Hamming weight. In PKC, 2018.
39. S. Das, P. Camacho, Z. Xiang, J. Nieto, B. B¨unz, and L. Ren. Threshold signatures
from inner product argument: Succinct, weighted, and multi-threshold. In ACM-
CCS, 2023.
40. L. de Castro and C. Peikert. Functional commitments for all functions, with trans-
parent setup. In Eurocrypt, 2023.
41. R. del Pino, V. Lyubashevsky, and G. Seiler. Short discrete log proofs for FHE
and Ring-LWE ciphertexts. In PKC, 2019.
42. D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. In STOC, 1991.
43. Y. El Housni. The arithmetic of pairing-based proof systems. PhD Thesis, Nov.
2022.
44. Y. El Housni and A. Guillevic. Optimized and secure pairing-friendly elliptic curves
suitable for one layer proof composition. In CANS, 2020.
45. T. Feneuil, J. Maire, M. Rivain, and D. Vergnaud. Zero-knowledge protocols for
the subset sum problem from MPC-in-the-head with rejection. In Asiacrypt, 2022.
46. A.-L. Ferrara, M. Green, S. Hohenberger, and M.-O. Pedersen. Practical short
signature batch verification. In CT-RSA, 2009.
47. D. Fiore, A. Nitulescu, and D. Pointcheval. Boosting verifiable computation on
encrypted data. In PKC, 2020.
48. G. Fuchsbauer, E. Kiltz, and J. Loss. The algebraic group model and its applica-
tions. In Crypto, 2018.
49. A. Gabizon and Z. Williamson.
Plookup: A simplified polynomial protocol for
lookup tables. Cryptology ePrint Archive Report 2020/315.
50. G. Gabizon, Z. Williamson, and O. Ciobotaru.
PLONK: Permutations over
Lagrange-bases for oecumenical noninteractive arguments of knowledge.
Cryp-
tology ePrint Archive, Report 2019/953,2019.
28

51. C. Ganesh, H. Khoshakhlagh, M. Kohlweiss, A. Nitulescu, and M. Zajac. What
makes Fiat-Shamir zkSNARKs (Updatable SRS) simulation extractable? In SCN,
2022.
52. C. Ganesh, A. Nitulescu, and E. Soria-Vazquez.
Rinocchio: SNARKs for ring
arithmetic. Cryptology ePrint Archive Report 2021/322.
53. C. Ganesh, C. Orlandi, M. Pancholi, A. Takahashi, and D. Tschudi. Fiat–Shamir
Bulletproofs are Non-Malleable (in the Algebraic Group Model). In Eurocrypt,
2022.
54. R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and
succinct NIZKs without PCPs. In Eurocrypt, 2013.
55. C. Gentry, C. Peikert, and V. Vaikuntanathan. Trapdoors for hard lattices and
new cryptographic constructions. In STOC, 2008.
56. C. Gentry, A. Sahai, and B. Waters. Homomorphic encryption from learning with
errors: Conceptually-simpler, asymptotically-faster, attribute-based.
In Crypto,
2013.
57. C. Gentry and D. Wichs. Separating succinct non-interactive arguments from all
falsifiable assumptions. In STOC, 2011.
58. A. Gonz´alez. Efficient non-interactive zero-knowledge proofs. PhD thesis Univer-
sidad De Chile, Santiago, Mar. 2017.
59. A. Gonz´alez, A. Hevia, and C. R`afols. QA-NIZK arguments in asymmetric groups:
New tools and new constructions. In Asiacrypt, 2015.
60. A. Gonzalez and C. R`afols. New techniques for non-interactive shuffle and range
arguments. In ACNS, 2017.
61. S. Gorbunov, L. Reyzin, H. Wee, and Z. Zhang. PointProofs: Aggregating Proofs
for Multiple Vector Commitments. In ACM-CCS, 2020.
62. S. Gorbunov, V. Vaikuntanathan, and D. Wichs. Leveled fully homomorphic sig-
natures from standard lattices. In STOC, 2015.
63. J. Groth. Non-interactive zero-knowledge arguments for voting. In ACNS, 2005.
64. J. Groth. Simulation-sound NIZK proofs for a practical language and constant size
group signatures. In Asiacrypt, 2006.
65. J. Groth. Short pairing-based non-interactive zero-knowledge arguments. In Asi-
acrypt, 2010.
66. J. Groth. Efficient zero-knowledge arguments from two-tiered homomorphic com-
mitments. In Asiacrypt, 2011.
67. J. Groth. On the size of pairing-based non-interactive arguments. In Eurocrypt,
2016.
68. J. Groth and M. Maller. Snarky signatures: Minimal signatures of knowledge from
simulation-extractable SNARKs. In Crypto, 2017.
69. J. Groth and A. Sahai. Efficient non-interactive proof systems for bilinear groups.
In Eurocrypt, 2008.
70. A. Guillevic and S. Singh. On the alpha value of polynomials in thetower number
field sieve algorithm. Cryptology ePrint Archive Report 2019/885, 2019.
71. Y. Ishai, E. Kushilevitz, and R. Ostrovsky.
Efficient arguments without short
PCPs. In CCC, 2007.
72. M. Joye. TFHE public key encryption revisited. Cryptology ePrint Archive Report
2023/603, Apr. 2023.
73. E. Kachisa, E. Schaefer, and M. Scott. Constructing Brezing-Weng pairing-friendly
elliptic curves using elements in the cyclotomic field. In Pairing, 2008.
74. A. Kate, G. Zaverucha, and I. Goldberg. Constant-size commitments to polyno-
mialsand applications. In Asiacrypt, 2010.
29

75. J. Katz, C. Zhang, and H.-S. Zhou. An analysis of the algebraic group model. In
Asiacrypt, 2022.
76. A. Kosba, C. Papamanthou, and E. Shi. xJsnark: A Framework for Efficient Veri-
fiable Computation. In IEEE S&P, 2018.
77. J. Krupp, D. Schr¨oder, M. Simkin, D. Fiore, G. Ateniese, and S. Nuernberger.
Nearly optimal verifiable data streaming. In PKC, 2016.
78. R.-W. Lai and G. Malavolta. Subvector commitments with application to succinct
arguments. In Crypto, 2019.
79. J. Lee. Dory: Efficient, Transparent arguments for Generalised Inner Products and
Polynomial Commitments. In TCC, 2021.
80. B. Libert, S. Ramanna, and M. Yung.
Functional commitment schemes: From
polynomial commitments to pairing-based accumulators from simple assumptions.
In ICALP, 2016.
81. B. Libert and M. Yung. Concise mercurial vector commitments and independent
zero-knowledge sets with short proofs. In TCC, 2010.
82. H. Lipmaa. On Diophantine complexity and statistical zero-knowledge arguments.
In Asiacrypt, 2003.
83. H. Lipmaa and K. Pavlyk. Succinct functional commitment for a large class of
arithmetic circuits. In Asiacrypt, 2020.
84. V. Lyubashevsky. Lattice signatures without trapdoors. In Eurocrypt, 2012.
85. V. Lyubashevsky, C. Peikert, and O. Regev. On ideal lattices and learning with
errors over rings. In Eurocrypt, 2010.
86. M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn.
Sonic: Zero-knowledge
SNARKs from linear-size universal and updateable structured reference strings. In
ACM-CCS, 2019.
87. R. Merkle. A certified digital signature. In Crypto, 1989.
88. S. Micali. Computationally sound proofs. SIAM J. of Computing, 30(4), 2000.
89. P. Paillier and D. Vergnaud. Discrete-log-based signatures may not be equivalent
to discrete log. In Asiacrypt, 2005.
90. T. Pedersen.
Non-interactive and information-theoretic secure verifiable secret
sharing. In Crypto, 1991.
91. C. Peikert, Z. Z. Pepin, and C. Sharp. Vector and functional commitments from
lattices. In TCC, 2021.
92. V. Shoup. Lower bounds for discrete logarithms and related problems. In Euro-
crypt, 1997.
93. R. Solomon, R. Weber, and G. Almashaqbeh.
smartFHE: Privacy-Preserving
Smart Contracts from Fully Homomorphic Encryption. In EuroS&P, 2023.
94. S. Srinivasan, A. Chepurnoy, C. Papamanthou, A. Tomescu, and Y. Zhang. Hyper-
proofs: Aggregating and maintaining proofs in vector commitments. In USENIX
Security, 2022.
95. A. Tomescu, I. Abraham, V. Buterin, J. Drake, D. Feist, and D. Khovratovich.
Aggregatable subvector commitments for stateless cryptocurrencies. In SCN, 2020.
96. A. Tomescu, Y. Xia, and Z. Newman.
Authenticated dictionaries with cross-
incremental proof (dis)aggregation. Cryptology ePrint Archive Report 2020/1239.
97. H. Wee and D. Wu.
Succinct vector, polynomial, and functional commitments
from lattices. In Eurocrypt, 2023.
98. A. Zapico, V. Buterin, D. Khovratovich, M. Maller, A. Nitulescu, and M. Simkin.
Caulk: Lookup arguments in sublinear time. In ACM-CCS, 2022.
99. Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. A zero-
knowledge version of vSQL. Cryptology ePrint Archive Report 2017/1146.
30

Supplementary Material
A
On Proving Smallness via Functional Commitments
for Constant-Degree Polynomials
Catalano, Fiore and Tucker [28] recently built additively homomorphic FCs for
constant-degree multivariate polynomials and monotone span programs. The for-
mer could be used to build short proofs of binarity by showing that the degree-2
polynomial f(x1, . . . , xn) = Pn
i=1 yi · xi · (xi −1) evaluates to 0 for random co-
efficients {yi}n
i=1. Nevertheless, their construction for degree-d polynomials has
a CRS size O(nd). If we were to use it as is to prove that a committed vector is
binary, we would end up with a quadratic-size CRS (instead of linear in our con-
struction) and longer commitments containing two group elements. Moreover,
the shape of the CRS would make it harder to prove knowledge-soundness in the
algebraic group model (note that their notion of evaluation-binding7 would not
suffice for our purposes). The reason is that their CRS contains elements of the
form (gαj, gβ·αj)j∈[n2], for some secret β, α ∈Zp, while some components of hon-
estly generated commitments are of the form g
Pn
j=1 xj·(αj) and only depend on
{gαj}j∈[n]. Hence, it is not clear how the AGM would enable knowledge extrac-
tion from an adversarially-generated commitment/proof since the commitment
can depend on all generators contained in the CRS, including {gβ·αj}j∈[n2].
To avoid these difficulties and decrease the CRS size to O(n) group elements,
it is tempting to exploit the sparsity of the polynomial P
i yi ·xi ·(xi −1). Then,
in the closest adaptation of the technique from [28, Section 4] that we can think
of, either the commitment or the opening is longer than ours by at least one
group element: The prover would include a commitment ¯C ∈G to the product
x ◦x = (x2
1, . . . , x2
n) in the opening before proving that x ◦x −x satisfies an
inner product relation ⟨x◦x−x, y⟩= 0 and that ¯C is consistent with the initial
commitment ˆC = ˆgγ · Qn
j=1 gxj
j
to x, which is part of the statement. To do this,
the prover would have to include at least one additional group element (typi-
cally, an auxiliary commitment C to a reversed version of y ◦x in G if the initial
commitment ˆC lives in ˆG) either in the commitment or in the opening. Then, it
would have to prove that C, and ¯C and ˆC are consistent with one another by
computing a pairing e(C, ˆC) and a pairing of ¯C with some public encoding of y.
Hence, the auxiliary commitment C would have to be part of either the initial
commitment or the opening, thus increasing the global communication overhead
(besides the main commitment ˆC) to 3 group elements (C, ¯C, π) if π is an aggre-
gated proof showing the consistency of all commitments. In our applications to
range proofs and short proofs for ring LWE ciphertexts, this would increase the
proof length by at least one group element. Our approach avoids this overhead
7 In short, evaluation-binding means that no PPT adversary can prove distinct eval-
uations for a given function of the committed vector.
31

since, instead of including a commitment to (x2
1, . . . , x2
n) in the proof, we include
a commitment to the reversed Hadamard product (yn ·xn, . . . , y1 ·x1) so that we
only need two group elements to argue that P
i yi · xi · (xi −1) = 0. This allows
us to reach the smallest proof length of SNARKs [67] in our proofs of smallness
and valid ring LWE encryption.
We also note that the technique of [28, Section 4.1] could be used to prove
that a committed vector has infinity norm ≤B by showing that the polyno-
mial Py(x1, . . . , xn) = P
i=1 yi · Q
j∈[−B,B](xi −j) evaluates to 0 for a random
y ∈Zn
p. However, the commitment size would grow with B (since it grows with
the degree of the polynomial) while the proof length would grow with log B. In
contrast, both sizes are constant in our construction of Section D.1.
In an earlier work [83], Lipmaa and Pavlyk used the arithmetization of
SNARKs [54] to construct succinct FC for sparse polynomials, where the num-
ber monomials is small w.r.t. the number n of variables. Their construction
could be used as well to prove that a committed vector (x1, . . . , xn) satisfies
Pn
i=1 yi · xi · (xi −1) = 0, for a random y ∈Zp derived from a random oracle.
While their openings only consist of one group element, their scheme is more
complex and using it in our setting would be significantly less efficient than our
construction from Section 3 in other metrics. First, their commitments are larger
and contain element of both sources groups G and ˆG (concretely, 2 elements of
G and one element of ˆG). In our applications of sections 4, D and G, this would
lengthen the proofs by at least one element of G. Also, their CRS is more complex
and contains 2ν + µ elements of G and ν elements of ˆG, where ν is the number
of multiplication gates in the arithmetic circuit that computes the polynomial
(which would be ν = 2n in our setting) and µ is the number of wires (here,
we would have µ ≥2n). Their prover is more expensive as well and computes
more than ν + µ + µα + 2µβ exponentiations in G, where µα and µα denote the
lengths of private and public inputs (in our setting, this would amount to at
least 7n exponentiations in G). Moreover, their verification algorithm computes
a product of 5 pairings (instead of 3 in Section 3) and µβ = n exponentiations
in both source groups.
Finally, the complex structure of their CRS would make it harder to prove
knowledge-soundness in our context as it contains multiple monomials αiyj in
the exponent (with j > 1), while “valid” commitments have components that
only depend on monomials αiy, which have degree one in y. In the AGM, this
would complicate the task of the knowledge extractor since maliciously gener-
ated commitments come with a representation that possibly depends on all group
elements contained in the CRS.
B
Das et al.’s Binarity Argument
Das et al. [39, Section 4.2] recently described a constant-size argument showing
that a committed vector is binary. Their construction builds on KZG commit-
ments and inherits their constant verification time. We consider the problem of
building an alternative constant-size range proof using their binarity argument.
32

In [39, Section 4.2], a commitment to a vector x = (x1, . . . , xn) ∈{0, 1}n
is obtained by committing to a polynomial b[X] such that b(ωi) = xi for each
i ∈[n], where ω is a primitive n-th root of unity. In asymmetric pairings, the
CRS contains (g, ˆg, {g(αi), ˆg(αi)}n
i=1) and a commitment is of the form ˆC = ˆgb(α).
In order to show that b(ωi) ∈{0, 1} for each i ∈[n], the prover shows that the
product b[X] · (1 −b[X]) vanishes everywhere on the domain H = {ω, . . . , ωn},
which is equivalent to showing that it is divisible by the vanishing polynomial
ZH = Qn
i=1(X −ωi).
To prove the statement, the prover has to reveal π = (C = gb(α), πb) ∈G2
such that e(C, ˆg/ ˆC) = e(πb, ˆgZH(α)). As described in [39], the construction has
the same proof size as our argument system of Section 3. However, it is not
zero-knowledge since the underlying KZG commitment is deterministic.
A standard trick (used in, e.g., [50]) to achieve zero-knowledge is to add a ran-
dom multiple of the vanishing polynomial to the committed b[X] as it does not
change its evaluations on H. One can compute the initial commitment to b[X]
(which has degree n−1 since b(ωi) = xi for each i ∈[n]) as ˆC = ˆgb(α)+r·ZH(α) for
a random r
R←Zp.8 In order to generate a proof that xi ∈{0, 1} for each i ∈[n],
the prover can compute C = gb(α)+s·ZH(α) for a random s
R←Zp and πb such that
e(C, ˆg/ ˆC) = e(πb, ˆgZH(α)) since (b[X]+s·ZH[X])·(1−b[X]+r·ZH[X]) is divisible
by ZH[X]. However, the prover has to additionally prove that ˆC and C commit
to the same b[X]. This can be done by introducing an additional proof compo-
nent πeq = gr−s that satisfies e(C, ˆg)/e(g, ˆC) = e(πeq, ˆgZH(α)) and shows that
C and ˆC are deterministic KZG commitments to polynomials b[X] + r · ZH[X]
and b[X] + s · ZH[X] that differ by a multiple of ZH[X]. If the commitment
of the statement is ˆC and the simulator knows an algebraic representation of
ˆC, it can simulate a proof using α as a trapdoor.9 In this version, each proof
requires 3 elements of G. This can be reduced to 2 elements of G by computing
an aggregated proof π0 = πb · πδ
eq satisfying
e(C1+δ, ˆg)
e(C · gδ, ˆC)
= e(π0, ˆgZH(α))
(29)
where δ is obtained by hashing C and ˆC.
In order to obtain a range proof, the argument of binarity should be combined
with an inner product argument showing that Pn
i=1 xi · 2i−1 is equal to the
committed integer x. In [39], Das et al. use the observation from [8] that, if a[X]
and b[X] are polynomials such that a(ωi) = ai and b(ωi) = bi for each i ∈[n],
8 In the proof of knowledge-soundness, the AGM-enabled knowledge extractor can
recover b[X] from the algebraic representation of ˆC by performing an Euclidean
division (of which b[X] can be interpreted as the remainder since it has degree n −1
while the divisor ZH[X] has degree n).
9 If the commitment of the statement is C ∈G and the second commitment ˆC is part
of the proof, the simulator can even simulate a proof for a given C without knowing
an algebraic representation of it.
33

then we have
a[X] · b[X] = q[X] · ZH[X] + X · r[X] + ⟨a, b⟩· n−1
for unique polynomials q[X], r[X] of degree n −2. Therefore, if a(ωi) = 2i−1 for
each i ∈[n], the prover can compute proof elements πq = gq(α), πr = gr(α) such
that
e(C, ˆga(α)) = e(πq, ˆgZH(α)) · e(πr, ˆgα) · e(g1/n, ˆg)x
(30)
While e(g1/n, ˆg)x cannot be revealed (as it would not be zero-knowledge), the
prover can compute its initial commitment to the integer x ∈[0, 2n −1] as
V = gx+t·ZH(α), for a random t
R←Zp, which satisfies
e(V, ˆg1/n) = e(g, ˆg)x/n · e(gt/n, ˆgZH(α)).
If we divide the latter equation out of (30), we obtain
e(C, ˆga(α))
e(V, ˆg1/n) = e
 πq/gt/n
| {z }
≜π′q
, ˆgZH(α)
· e(πr, ˆgα)
(31)
If we now aggregate the verification equations (31) and (29), it is then possible
to obtain a compressed proof π = πb · πδ
eq · π′
q
δ2
satisfying
e(C, ˆg1+δ+δ2·a(α))
e(V δ2, ˆg1/n) · e(C · gδ, ˆC)
= e
 π, ˆgZH(α)
· e(πr, ˆgδ2·α)
where δ = H(V, C, ˆC) ∈Zp. The final proof that V = gx+t·ZH(α) commits to an
integer x ∈[0, 2n −1] should contain at least the group elements ( ˆC, C, π, πr)
(which is already longer than our proofs) and cost at least 5 pairings to verify.
Moreover, in order to ensure knowledge-soundness in the AGM, the prover
should also convince the verifier that V was really computed as a commitment
of the form gx+t·ZH(α) (i.e., it commits to a constant polynomial x). Since the
commitment V is randomized by adding a random multiple of ZH(α) in the
exponent, it is not clear how this can be done using the degree check techniques
of [86]. One option is to use a Schnorr-like Σ-protocol proving knowledge of the
underlying (x, t), which introduces two scalars in the proof.
34

C
Deferred Material for the Range Proof of Section 4
C.1
Proof of Correctness
The first verification equation (17) is satisfied because
e(
n
Y
i=1
g2i−1
n+1−i, ˆC) =
n
Y
i=1
e(gn+1−i, ˆC)2i−1
=
n
Y
i=1
e
 gn+1−i, ˆgγ ·
n
Y
j=1
ˆgxj
j
2i−1
=
n
Y
i=1
e
 gγ ·
n
Y
j=1
gxj
j , ˆgn+1−i
2i−1
,
=
n
Y
i=1
e
 gγ
n+1−i ·
n
Y
j=1
gxj
n+1+j−i, ˆg
2i−1
= e(g1, ˆgn)
Pn
i=1 xi·2i−1 · e

n
Y
i=1
 gγ
n+1−i ·
Y
j∈[n]\{i}
gxj
n+1−i+j
2i−1
, ˆg

and e(gn, ˆV ) = e(g1, ˆgn)x · e(gr
n, ˆg), so that dividing out the two equations yields
e(Qn
i=1 g2i−1
n+1−i, ˆC)

e(gn, ˆV ) = e(πx, ˆg) when x = Pn
i=1 xi · 2i−1.
Similarly, the second verification equation (18) follows by dividing the fol-
lowing two equalities:
e(
n
Y
i=1
gti·yi
n+1−i, ˆC) =
n
Y
i=1
e(gn+1−i, ˆC)ti·yi
=
n
Y
i=1

e(g1, ˆgn)xi · e
 g, ˆgγ
n+1−i ·
Y
j∈[n]\{i}
ˆgxj
n+1+j−i
ti·yi
=
n
Y
i=1

e(g1, ˆgn)xi · e
 gγ
n+1−i ·
Y
j∈[n]\{i}
gxj
n+1+j−i, ˆg
ti·yi
= e(g1, ˆgn)
Pn
i=1 yi·ti·xi
·e

n
Y
i=1

gγ
n+1−i ·
Y
j∈[n]\{i}
gxj
n+1−i+j
ti·yi
, ˆg

and
e
 Cy,
n
Y
i=1
ˆgti
i

=
n
Y
i=1
e(Cy, ˆgi)ti =
n
Y
i=1
e
 gγy ·
n
Y
j=1
gyj·xj
n+1−j, ˆgi
ti
=
n
Y
i=1
e
 gγy
i
·
n
Y
j=1
gyj·xj
n+1−j+i, ˆg
ti
= e(g1, ˆgn)
Pn
i=1 yi·ti·xi · e

n
Y
i=1
 gγy
i
·
Y
j∈[n]\{i}
gyj·xj
n+1−j+i
ti, ˆg

.
35

As for equation (19), we have
e(Cy ·
n
Y
j=1
g−yj
n+1−j, ˆC) = e

gγy ·
n
Y
j=1
gyj·(xj−1)
n+1−j
, ˆgγ ·
n
Y
i=1
ˆgxi
i

= e(Cy ·
n
Y
j=1
g−yj
n+1−j, ˆg)γ ·
n
Y
i=1
e
 gγy
i
·
n
Y
j=1
gyj·(xj−1)
n+1−j+i
xi, ˆg

= e(g1, ˆgn)
Pn
i=1 yi·xi·(xi−1) · e
 gγ·γy ·
n
Y
j=1
gγ·yj·(xj−1)
n+1−j
, ˆg

·
n
Y
i=1
e
 gγy
i
·
Y
j∈[n]\{i}
gyj·(xj−1)
n+1−j+i
xi, ˆg

= e

gγ·γy ·
n
Y
j=1
gγ·yj·(xj−1)
n+1−j
·
n
Y
i=1
 gγy
i
·
Y
j∈[n]\{i}
gyj·(xj−1)
n+1−j+i
xi, ˆg

where the last equality holds because xi(xi −1) = 0 for each i ∈[n].
Equation (20) is satisfied by πv = Qn
i=2
 gr
n+1−i · gx
n+2−i
si ∈G since
e
 n
Y
i=2
gsi
n+1−i, ˆV

=
n
Y
i=2
e
 gn+1−i, ˆgr · ˆgx
1
si
=
n
Y
i=2
e
 gr · gx
1, ˆgn+1−i
si =
n
Y
i=2
e
 gr
n+1−i · gx
n+2−i, ˆg
si = e(πv, ˆg).
C.2
Proof of Theorem 1
Proof. We describe a simulator that perfectly simulates proofs using a trapdoor
tk = α ∈Zp and by programming the random oracles. Given a commitment ˆV ∈
ˆG, the simulator computes Cy = gθy ∈G for a randomly chosen θy
R←Zp. Next,
it obtains si = Hs(i, [2, n], ˆV , ˆC, Cy) for each index i ∈[2, n]. It then uniformly
chooses y = (y1, . . . , yn)
R←Zn
p, t = (t1, . . . , tn)
R←Zn
p, δ = (δx, δeq, δy, δv)
R←Z4
p,
sets s0 = 0, and computes
λ =
δx · (αn) −Pn
i=2 δv · si · (αn+1−i)
θy · δy + Pn
i=1(δx,i · 2i−1 + (δeq · ti −δy) · yi + δ0 · ui) · (αn+1−i),
where δx,i = δx if i ∈[ℓ] and δx,i = 0 for all i ∈[ℓ+ 1, n].
Note that the denominator is uniformly distributed over Zp and non-zero
with probability 1 −1/p. Then, it chooses γ
R←Zp and computes a commitment
ˆC = ˆV λ · ˆgγ. It aborts if y = H( ˆV , ˆC), or Hagg( ˆV , ˆC, Cy) or Ht(y, ˆV , ˆC, Cy) was
already defined. If the simulator does not fail, it computes
π =

Cδy
y ·
n
Y
i=1
gδx,i·2i−1+(δeq·ti−δy)yi
n+1−i
γ
·

n
Y
i=1
ˆgδeq·ti
i
−θy
.
(32)
36

Then, it programs the random oracles to have Hagg( ˆV , ˆC, Cy) = (δx, δeq, δy, δv),
y = H( ˆV , ˆC), t = Ht(y, ˆV , ˆC, Cy) for each i ∈[n]. This provides a valid proof
π = ( ˆC, Cy, π), where ˆC and Cy are uniformly distributed over G and ˆG, re-
spectively. Moreover, π satisfies the verification equation (22) since we have
gδx
n ·
n
Y
i=2
g−δv·si
n+1−i =

Cδy
y ·
n
Y
i=1
gδx,i·2i−1+(δeqti−δy)yi
n+1−i
λ
,
which implies
e
 Cδy
y · Qn
i=1 gδx,i·2i−1+(δeq·ti−δy)·yi
n+1−i
, ˆC

e
 gδx
n · Qn
i=2 g−δv·si
n+1−i, ˆV

· e
 Cy, Qn
i=1 ˆgδeq·ti
i

= e
 Cδy
y · Qn
i=1 gδx,i·2i−1+(δeq·ti−δy)·yi
n+1−i
, ˆV λ · ˆgγ
e
 gδx
n · Qn
i=2 g−δv·si
n+1−i, ˆV

· e
 Cy, Qn
i=1 ˆgδeq·ti
i

= e
 Cδy
y · Qn
i=1 gδx,i·2i−1+(δeq·ti−δy)·yi
n+1−i
, ˆV λ
e
 gδx
n · Qn
i=2 g−δv·si
n+1−i, ˆV

· e
  Cδy
y · Qn
i=1 gδx,i·2i−1+(δeq·ti−δy)yi
n+1−i
γ, ˆg

e
   Qn
i=1 ˆgδeq·ti
i
θy, ˆg

= e(π, ˆg)
⊓⊔
D
Short Proofs that a Committed Vector is Small
We now show that the range proof of Section 4 can be batched in order to si-
multaneously prove possibly distinct ranges for the different slots of a multi-base
Pedersen commitment. In particular, we can prove that a vector commitment
commits to a vector of small infinity norm.
As explained in Supplementary Material E, the construction can be used to
prove that a committed vector has small Euclidean norm.
D.1
Description
Given a commitment ˆV = ˆgr · Qm
k=1 ˆgxk
k , the prover will convince the verifier
that xk ∈[0, 2ℓk −1] for each k ∈[m] using only 3 group elements. The relation
is now defined as
Rpp =
n
(x, w) =
  ˆV = ˆgr ·
m
Y
k=1
ˆgxk
k , (ℓ1, . . . , ℓm)

∈ˆG × Nm,
(r, x1, . . . , xm) ∈Zp ×
m
Y
k=1
[0, 2ℓk −1]
o
and the construction proceeds as follows.
37

CRS-Gen(1λ, 1m, {1nk}m
k=1): On input of a security parameter λ, a number of
slots m ∈poly(λ), and the maximal bitlength nk ∈poly(λ) of ranges for each
slot k ∈[m], set n = Pm
k=1 nk and do the following:
1. Choose asymmetric bilinear groups (G, ˆG, GT ) of prime order p > 2ℓp,
where ℓp = max(l(λ), n1, . . . , nm) for some polynomial l : N →N, and
generators g
R←G, ˆg
R←ˆG.
2. Pick a random α
R←Zp and compute g1, . . . , gn, gn+2, . . . , g2n ∈G as
well as ˆg1, . . . , ˆgn ∈ˆG, where gi = g(αi) for each i ∈[2n] \ {n + 1} and
ˆgi = ˆg(αi) for each i ∈[n].
3. Choose hash functions H, Ht : {0, 1}∗→Zn
p, Hs : {0, 1}∗→Zp, Hagg :
{0, 1}∗→Z4
p and Hξ : {0, 1}∗→Zm
p modeled as random oracles.
The public parameters are defined to be
pp =

(G, ˆG, GT ), n, g, ˆg, {gi}i∈[2n]\{n+1}, {ˆgi}i∈[n], H

where H = {H, Hs, Ht, Hagg, Hξ} are hash functions.
Compp(x) To commit to a vector of integers x = (x1, . . . , xm) ∈Zm, choose a
random r
R←Zp and compute ˆV = ˆgr · Qm
k=1 ˆgxk
k
∈ˆG. Return the commit-
ment com = ˆV ∈ˆG and the opening information aux = r ∈Zp.
Provepp
 (com, {1ℓk}m
k=1), (x, aux)

: given a commitment com = ˆV and witnesses
 x; aux

consisting of an integer vector x = (x1, . . . , xm) ∈Zm such that
xk ∈[0, 2ℓk −1] for each k ∈[m], where ℓk ≤nk, and aux = r ∈Zp is the
randomness such that ˆV = ˆgr · Qm
k=1 ˆgxk
k , do the following:
1. For each k ∈[m−1], set jk = n1+· · ·+nk−1 with j1 = 0. For each k ∈[m],
let the binary expansion (xk,1, . . . , xk,ℓk) ∈{0, 1}ℓk of xk. Set xk,i = 0
for each i ∈[ℓk + 1, nk] and define ¯xk = (xk,1, . . . , xk,nk) ∈{0, 1}nk.
2. Choose γ
R←Zp and compute
ˆC = ˆgγ ·
m
Y
k=1
ℓk
Y
j=1
ˆgxk,j
jk+j.
Compute y = (y1, . . . , yn) = H( ˆV , ˆC) ∈Zn
p. Then, choose γy
R←Zp and
compute
Cy = gγy ·
m
Y
k=1
ℓk
Y
j=1
g
yjk+j·xk,j
n+1−(jk+j)
3. Compute ξ = (ξ1, . . . , ξm) = Hξ( ˆV , ˆC, Cy) and generate a proof πx that
ˆC commits to (¯x1 | . . . | ¯xm) ∈Zn
p such that Pℓk
i=1 xk,i · 2i−1 = xk for
each k ∈[m]. This proof πx ∈G satisfies
e
  Qm
k=1
  Qℓk
i=1 g2i−1
n+1−(jk+i)
ξk, ˆC

e
  Qm
k=1 gξk
n+1−k, ˆV

= e(πx, ˆg)
(33)
and is obtained as per formula (40) in Supplementary Material D.2.
38

4. Compute t = (t1, . . . , tn) = Ht(y, ˆV , ˆC, Cy) ∈Zn
p. Generate a proof πeq
(as per formula (43) in Supplementary Material D.2) satisfying
e
  Qm
k=1
Qnk
i=1 g
tjk+i·yjk+i
n+1−(jk+i), ˆC

e
 Cy, Qm
k=1
Qnk
i=1 ˆg
tjk+i
jk+i

= e(πeq, ˆg),
(34)
which shows that Cy is consistent with y and ˆC.
5. Prove that Pm
k=1
Pnk
i=1 yjk+i · xk,i · (xk,i −1) = 0 by computing πy ∈G
(as specified by (44) in Supplementary Material D.2) satisfying
e
 Cy ·
m
Y
k=1
nk
Y
i=1
g
−yjk+i
n+1−(jk+i), ˆC

= e(πy, ˆg).
(35)
6. Generate an aggregated proof that ˆV = ˆgr·Qm
k=1 ˆgxk
k
is a commitment to
a vector that contains 0 in its last n −m coordinates. Namely, compute
πv = Qn
i=m+1
 gr
n+1−i · Qm
k=1 gxk
n+2−i+k
si ∈G such that
e
 n
Y
i=m+1
gsi
n+1−i, ˆV

= e(πv, ˆg).
(36)
where si = Hs(i, [m + 1, n], ˆV , ˆC, Cy) ∈Zp for each i ∈[m + 1, n].
7. Compute (δx, δeq, δy, δv) = Hagg( ˆV , ˆC, Cy) ∈Z4
p and compute an aggre-
gated proof
π = πδx
x · πδy
y · πδeq
eq · πδv
v .
Output the final range argument which consists of
π :=
  ˆC, Cy, π

.
(37)
Verifypp
 com, π

: Given a commitment com = ˆV ∈ˆG and a candidate proof π,
parse the latter as in (37).
1. Compute (δx, δeq, δy, δv) = Hagg( ˆV , ˆC, Cy) ∈Z4
p, y = H( ˆV , ˆC) ∈Zn
p,
ξ = (ξ1, . . . , ξm) = Hξ( ˆV , ˆC, Cy) ∈Zm
p , t = Ht(y, ˆV , ˆC, Cy) ∈Zn
p, and
si = Hs(i, [m + 1, n], ˆV , ˆC, C) for all indices i ∈[m + 1, n]. Define the
vector (s1, . . . , sn) = (0m, sm+1, . . . , sn).
2. For each k ∈[m], define δx,k,i = δx if i ∈[ℓk] and δx,k,i = 0 if i ∈
[ℓk + 1, nk]. Return 1 if
e

Cδy
y
m
Y
k=1
nk
Y
i=1
g
ξk·δx,k,i·2i−1+(δeq·tjk+i−δy)·yjk+i
n+1−(jk+i)
, ˆC

· e
 m
Y
k=1
gξk
n+1−k
n
Y
i=m+1
g−δv·si
n+1−i, ˆV
−1
· e

Cy,
m
Y
k=1
nk
Y
i=1
ˆg
δeq·tjk+i
jk+i
−1
= e(π, ˆg)
(38)
and 0 otherwise.
39

The correctness of the scheme can be proven in the same way as in the base
scheme of Section 4 and details are given in Supplementary Material D.2.
Efficiency. The proof size remains the same as in Section 4. If m denotes the
number of simultaneously performed range proofs, the computational cost of the
prover is now dominated by 3n exponentiations in G and m + 1 exponentiations
in ˆG since each subset product Qnk
j=1 ˆgxk,j
jk+j is cheaper to compute than an expo-
nentiation in ˆG (recall that nk < log p).
The verifier’s workload amounts to 2n + 1 exponentiations in G, n exponen-
tiations in ˆG and 4 pairings.
D.2
Correctness of Aggregated Range Proofs
The verification equation (38) is obtained by raising equalities (33), (34), (35)
and (36) to the powers δx, δeq, δy and δv, and multiplying them together. We now
consider the generation of proofs for individual verification equations (33)-(36).
The prover can compute πx ∈G satisfying equation (33) because, for each
k ∈[m], we have
e
 ℓk
Y
i=1
g2i−1
n+1−(jk+i) , ˆC

=
ℓk
Y
i=1
e
 gn+1−(jk+i), ˆC
2i−1
=
ℓk
Y
i=1
e

gn+1−(jk+i), ˆgγ ·
m
Y
κ=1
ℓκ
Y
j=1
ˆgxκ,j
jκ+j
2i−1
=
ℓk
Y
i=1
e

gγ ·
m
Y
κ=1
ℓκ
Y
j=1
gxjκ+j
jκ+j , ˆgn+1−(jk+i)
2i−1
,
=
ℓk
Y
i=1
e

gγ
n+1−(jk+i) ·
m
Y
κ=1
ℓk
Y
j=1
gxκ,j
n+1+(jκ+j)−(jk+i), ˆg
2i−1
= e(g1, ˆgn)
Pℓk
i=1 xk,i·2i−1
·e
 ℓk
Y
i=1
 gγ
n+1−(jk+i) ·
m
Y
κ=1
Y
j∈[ℓκ]
(κ,j)̸=(k,i)
gxκ,j
n+1−(jk+i)+(jκ+j)
2i−1
, ˆg

and thus
m
Y
k=1
e
  ℓk
Y
i=1
g2i−1
n+1−(jk+i), ˆC
ξk = e(g1, ˆgn)
Pm
k=1 ξk·(Pℓk
i=1 xk,i·2i−1)
·e
 m
Y
k=1
 ℓk
Y
i=1
 gγ
n+1−(jk+i)·
m
Y
κ=1
Y
j∈[ℓκ]
(κ,j)̸=(k,i)
gxκ,j
n+1−(jk+i)+(jκ+j)
2i−1ξk, ˆg

.
(39)
40

We also have
e(
m
Y
k=1
gξk
n+1−k, ˆV ) = e(g1, ˆgn)ξk·xk · e
 m
Y
k=1
 gr
n+1−k ·
m
Y
i=1,i̸=k
gxi
n+1+i−k
ξk, ˆg

,
so that dividing the latter from (39) yields (33) when xk = Pn
i=1 xk,i · 2i−1 for
each k ∈[m] and
πx =
Qm
k=1
 Qℓk
i=1
 gγ
n+1−(jk+i) · Qm
κ=1
Q
j∈[ℓκ],(κ,j)̸=(k,i) gxκ,j
n+1−(jk+i)+(jκ+j)
2i−1ξk
Qm
k=1
 gr
n+1−k · Qm
i=1,i̸=k gxi
n+1+i−k
ξk
.
(40)
The prover can also compute πeq satisfying the second verification equation
(34) by observing that, for each k ∈[m], we have
e
  nk
Y
i=1
g
tjk+i·yjk+i
n+1−(jk+i), ˆC

=
nk
Y
i=1
e(gn+1−(jk+i), ˆC)tjk+i·yjk+i
(41)
=
nk
Y
i=1
e
 gn+1−(jk+i), ˆgγ
m
Y
κ=1
nκ
Y
j=1
ˆgxκ,j
jκ+j
tjk+i·yjk+i
=
nk
Y
i=1

e(g1, ˆgn)xk,i · e
 g, ˆgγ
n+1−(jk+i) ·
m
Y
κ=1
Y
j∈[nκ]
(κ,j)̸=(k,i)
ˆgxκ,j
n+1+(jκ+j)−(jk+i)
tjk+i·yjk+i
=
nk
Y
i=1

e(g1, ˆgn)xk,i · e
 gγ
n+1−(jk+i) ·
m
Y
κ=1
Y
j∈[nκ]
(κ,j)̸=(k,i)
gxκ,j
n+1+(jκ+j)−(jk+i), ˆg
tjk+i·yjk+i
= e(g1, ˆgn)
Pℓk
i=1 yjk+i·tjk+i·xk,i
· e
 nk
Y
i=1

gγ
n+1−(jk+i) ·
m
Y
κ=1
Y
j∈[nκ]
(κ,j)̸=(k,i)
gxκ,j
n+1+(jκ+j)−(jk+i)
tjk+i·yjk+i
, ˆg

.
41

We also have
e
 Cy,
m
Y
k=1
nk
Y
i=1
ˆg
tjk+i
jk+i

=
m
Y
k=1
nk
Y
i=1
e(Cy, ˆgjk+i)tjk+i
(42)
=
m
Y
k=1
nk
Y
i=1
e
 gγy ·
m
Y
κ=1
nκ
Y
j=1
gyjκ+j·xκ,j
n+1−(jκ+j), ˆgjk+i
tjk+i
=
m
Y
k=1
nk
Y
i=1
e
 gγy
jk+i ·
m
Y
κ=1
nκ
Y
j=1
gyjκ+j·xκ,j
n+1−(jκ+j)+(jk+i), ˆg
tjk+i
= e(g1, ˆgn)
Pm
k=1
Pℓk
i=1 yjk+i·tjk+i·xk,i
· e
 m
Y
k=1
nk
Y
i=1
 gγy
jk+i ·
m
Y
κ=1
Y
j∈[nκ]
(κ,j)̸=(k,i)
gyjκ+j·xκ,j
n+1−(jκ+j)+(jk+i)
tjk+i, ˆg

.
By taking the product of (41) for all k ∈[m] and dividing (42) out of the result,
we obtain (34) when πeq is computed as
πeq =
Qm
k=1
Qnk
i=1

gγ
n+1−(jk+i) · Qm
κ=1
Q
j∈[nκ],(κ,j)̸=(k,i) gxκ,j
n+1+(jκ+j)−(jk+i)
tjk+i·yjk+i
Qm
k=1
Qnk
i=1
 gγy
jk+i · Qm
κ=1
Q
j∈[nκ],(κ,j)̸=(k,i) gyjκ+j·xκ,j
n+1−(jκ+j)+(jk+i)
tjk+i
(43)
As for equation (35), the prover can compute
πy = gγ·γy ·
m
Y
k=1
nk
Y
i=1
g
γ·yjk+i·(xk,i−1)
n+1−(jk+i)
·
m
Y
κ=1
nκ
Y
j=1
 gγy
jκ+j ·
m
Y
k=1
Y
i∈[nk]
(k,i)̸=(κ,j)
g
yjk+i·(xk,i−1)
n+1−(jk+i)+(jκ+j)
xκ,j,
(44)
42

which satisfies (35) because we have
e(Cy ·
m
Y
k=1
nk
Y
i=1
g
−yjk+i
n+1−(jk+i), ˆC) = e

gγy ·
m
Y
k=1
nk
Y
i=1
g
yjk+i·(xk,i−1)
n+1−(jk+i)
, ˆgγ ·
m
Y
κ=1
nκ
Y
j=1
ˆgxκ,j
jκ+j

= e(gγy ·
m
Y
k=1
nk
Y
i=1
g
yjk+i·(xk,i−1)
n+1−(jk+i)
, ˆg)γ
·
m
Y
κ=1
nκ
Y
j=1
e
 gγy
jκ+j ·
m
Y
k=1
nk
Y
i=1
g
yjk+i·(xk,i−1)
n+1−(jk+i)+(jκ+j)
xκ,j, ˆg

= e(g1, ˆgn)
Pm
k=1
Pnk
i=1 yjk+i·xk,i·(xk,i−1) · e(gγ·γy ·
m
Y
k=1
nk
Y
i=1
g
γ·yjk+i·(xk,i−1)
n+1−(jk+i)
, ˆg)
·
m
Y
κ=1
nκ
Y
j=1
e
 gγy
jκ+j ·
m
Y
k=1
Y
i∈[nk]
(k,i)̸=(κ,j)
g
yjk+i·(xk,i−1)
n+1−(jk+i)+(jκ+j)
xκ,j, ˆg

= e

gγ·γy ·
m
Y
k=1
nk
Y
i=1
g
γ·yjk+i·(xk,i−1)
n+1−(jk+i)
·
m
Y
κ=1
nκ
Y
j=1
 gγy
jκ+j ·
m
Y
k=1
Y
i∈[nk]
(k,i)̸=(κ,j)
g
yjk+i·(xk,i−1)
n+1−(jk+i)+(jκ+j)
xκ,j, ˆg

,
where the last equality holds since xk,i · (xk,i −1) = 0 for all indices k ∈[m] and
i ∈[nk].
Equation (36) is satisfied by πv = Qn
i=m+1
 gr
n+1−i · Qm
k=1 gxk
n+2−i+k
si since
e
 n
Y
i=m+1
gsi
n+1−i, ˆV

=
n
Y
i=m+1
e

gn+1−i, ˆgr ·
m
Y
k=1
ˆgxk
k
si
=
n
Y
i=m+1
e

gr ·
m
Y
k=1
gxk
k , ˆgn+1−i
si
=
n
Y
i=m+1
e

gr
n+1−i ·
m
Y
k=1
gxk
n+1−i+k, ˆg
si
= e(πv, ˆg).
D.3
Security
Theorem 3. The construction provides zero-knowledge in the ROM.
Proof. The proof is identical to that of Theorem 1 and omitted.
⊓⊔
Theorem 4. Under the (2n, n)-DLOG assumption, the scheme is simulation-
extractable in the algebraic group model and in the random oracle model.
Proof. The proof is similar to that of Theorem 2 and we only detail the changes
in the interaction between the reduction/extractor B and the adversary A.
43

Queries: At any time, A can choose a commitment com = ˆV and ask for a sim-
ulated proof that ˆV commits to an integer vector (x1, . . . , xm) ∈Zm such that
xk ∈[0, 2ℓk −1] for some integers {ℓk}k∈[m] of its choice such that ℓk ≤nk. Since
A is algebraic, it must provide a representation of ˆV with respect to the genera-
tors {ˆgi}i∈[0,n] and the commitments ˆC contained in previous simulated proofs.
Since the simulator B is itself algebraic, for any ˆV chosen by A, B can always find
a representation {vi}n
i=0 such that ˆV = ˆgv0 ·Qn
i=1 ˆgvi
i . We assume w.l.o.g. that ei-
ther: (i) There exists k ∈[m] such that vk ̸∈[0, 2ℓk−1]; or (ii) (vm+1, . . . , vn) ̸= 0.
Otherwise, B can faithfully generate a proof using (v0, v1, . . . , vm) as witnesses.
Then, B proceeds as follows to simulate a proof without using gn+1:
1. Choose random vectors ξ = (ξ1, . . . , ξm)
R←Zm
p , δ = (δx, δeq, δy, δv)
R←Z4
p,
y = (y1, . . . , yn)
R←Zn
p, t = (t1, . . . , tn)
R←Zn
p.
2. Let fn+1 = Pn
i=m+1 vi · si, for randomly chosen si
R←Zp for all indices
i ∈[m + 1, n]. Let an arbitrary k ∈[m] such that
ajk+1 ≜vk + 1
ξk
·

−δv · fn+1
δx
+
X
κ∈[m]\{k}
ξκvκ

̸∈{0, 1}
Such a k ∈[m] must exist w.h.p. since we assumed that (vm+1, . . . , vn) ̸= 0
or there exists k ∈[m] such that vk ̸∈[0, 2ℓk −1]. Then, set
ai = 0
∀i ∈[n] \ {jk + 1}
zn−jk = yjk+1
Then, find arbitrary scalars {zj}j∈[n]\{n−jk} such that
nk
X
i=2
tjk+i · zn+1−(jk+i) +
m
X
κ=1
κ̸=k
nκ
X
i=1
tjκ+i · zn+1−(jκ+i)
= tjk+1 · (ajk+1 · yjk+1 −yjk+1).
3. Choose random a0, z0
R←Zp and compute simulated commitments
ˆC = ˆga0 ·
n
Y
i=1
ˆgai
i
= ˆga0 · ˆg
ajk+1
jk+1 ,
Cy = gz0 ·
n
Y
i=1
gzi
i .
4. If one of the hashes Hξ( ˆV , ˆC, Cy), Hagg( ˆV , ˆC, Cy), H( ˆV , ˆC), Ht(y, ˆV , ˆC, Cy)
or {si = Hs(i, [m + 1, n], ˆV , ˆC, Cy)}n
i=m+1 was already defined, abort. Oth-
erwise, set δ = Hagg( ˆV , ˆC, Cy),
ξ = Hξ( ˆV , ˆC, Cy),
y = H( ˆV , ˆC),
t = Ht(y, ˆV , ˆC, Cy),
and si = Hs(i, [m + 1, n], ˆV , ˆC, Cy) for each i ∈[m + 1, n].
44

5. Define the polynomials
Qx[X] =

n
X
i=0
ai · Xi
·
 m
X
k=1
ℓk
X
i=1
2i−1 · ξk · Xn+1−(jk+i)
−

n
X
i=0
vi · Xi
·
 m
X
k=1
ξk · Xn+1−k
=
2n
X
i=0
qi · Xi,
Qy[X] =

n
X
i=0
zi · Xi −
m
X
κ=1
nκ
X
i=1
yjκ+i · Xn+1−(jκ+i)
·

n
X
i=0
ai · Xi
=

z0 +
m
X
κ=1
nκ
X
i=1
 zn+1−(jκ+i) −yjκ+i

· Xn+1−(jκ+i)
·

n
X
i=0
ai · Xi
=
2n
X
i=0
σi · Xi
Qeq[X] =

n
X
i=0
ai · Xi
·
 m
X
κ=1
nκ
X
i=1
tjκ+i · yjκ+i · Xn+1−(jκ+i)
−

z0 +
m
X
κ=1
nκ
X
i=1
zn+1−(jκ+i) · Xn+1−(jκ+i)
·
 m
X
κ=1
nκ
X
i=1
tjκ+i · Xjκ+i
=
2n
X
j=0
ej · Xj,
Qv[X] =

n
X
i=0
vi · Xi
·

n
X
i=m+1
si · Xn+1−i
=
2n
X
j=0
fj · Xj.
Their degree-(n + 1) coefficients are fn+1 = Pn
i=m+1 vi · si and
qn+1 =
m
X
κ=1
ξκ ·
 
−vκ +
ℓκ
X
i=1
ajκ+i · 2i−1
!
= ξk · ajk+1 −
X
κ∈[m]
ξκ · vκ = −δv · fn+1
δx
,
σn+1 =
m
X
κ=1
nκ
X
i=1
ajκ+i · (zn+1−(jκ+i) −yjκ+i) = ajk+1 · (zn−jk −yjk+1) = 0
en+1 =
m
X
κ=1
nκ
X
i=1
tjκ+i · (ajκ+i · yjκ+i −zn+1−(jκ+i))
= tjk+1 · (ajk+1 · yjk+1 −yjk+1) −
nk
X
i=2
tjk+i · zn+1−(jk+i)
−
m
X
κ=1
κ̸=k
nκ
X
i=1
tjκ+i · zn+1−(jκ+i) = 0
45

due to the definition of committed a = (a1, . . . , an) and z = (z1, . . . , zn).
Observe that
δx · qn+1 + δeq · en+1 + δy · σn+1 + δv · fn+1 = 0
(45)
6. Define the polynomial
Qagg[X] = δx · Qx[X] + δeq · Qeq[X] + δy · Qy[X] + δv · Qv[X] =
2n
X
i=0
ηi · Xi
for which ηn+1 = 0 by construction. Compute
π =
2n
Y
i=1,i̸=n+1
gηi
i
(46)
using (g, {gi}i∈[2n]\{n+1}) and return the simulated proof π = ( ˆC, Cy, π).
We remark that the simulated π from (46) satisfies the verification equation
(38) by construction. Moreover, the proof π has the same distribution as a proof
generated by the zero-knowledge simulator. Indeed, π is uniquely determined by
the commitments ( ˆC, ˆV , Cy) and the aggregation coefficients ξ, y, t, {si}n
i=m+1
and δ in (38). Also, the committed vectors a, z ∈Zn
p are perfectly hidden by
the randomness a0 and z0 in ˆC and Cy, respectively.
Therefore the simulation is perfect, unless a collision occurs when random
oracles are programmed in the simulation queries. If QS (reps. QH) is the number
of queries made by A to the simulator (resp. to random oracles), this happens
with probability ≤(QS + QH) · QH/p.
Output: When A terminates, it outputs a statement ( ˆV , {1ℓk}m
k=1), for some
integers ℓ1 ∈[n1], . . . , ℓm ∈[nm], together with a valid proof π =
  ˆC, Cy, π

.
Since we are in the AGM, A must provide a representation of Cy w.r.t to
(g, {gi}i∈[2n]\{n+1}) and the group elements {C(i)
y , π(i)}i∈[QS] contained in re-
sponses {π(i)}i∈[QS] to simulation queries. Likewise, it must provide a represen-
tation of ˆC w.r.t (ˆg, {ˆgi}i∈[n]) and the commitments { ˆC(i)}i∈[QS] contained in
simulated proofs {π(i)}i∈[QS]. Also, for each i ∈[QS], B knows a representa-
tion of ˆC(i) w.r.t. (ˆg, {ˆgi}i∈[n]) and a representation of Cy w.r.t. (g, {gi}n
i=1).
It also knows a representation of each simulated π(i) w.r.t (g, {gi}i∈[2n]\{n+1}).
From A’s output and the randomness of the simulation, B can infer scalars
{(θi, zi) ∈Z2
p}i∈[0,2n]\{n+1}, {(ai, vi) ∈Z2
p}i∈[0,n] such that
ˆC =
n
Y
i=0
ˆgai
i ,
Cy =
2n
Y
i=0,i̸=n+1
gzi
i ,
ˆV =
n
Y
i=0
ˆgvi
i ,
π =
2n
Y
i=0,i̸=n+1
gθi
i ,
where we define g0 = g and ˆg0 = ˆg for convenience.
If the representation (v0, v1, . . . , vn) ∈Z2
p of ˆV is such that vk ∈[0, 2ℓk −1]
46

for all k ∈[m] and vi = 0 for all i ∈[m + 1, n], then B can simply output
(v0, v1, . . . , vm) ∈Zm+1
p
as a valid witness. We henceforth assume that either
(vm+1, . . . , vn) ̸= 0n−m or there exists k ∈[m] such that vk ̸∈[0, 2ℓk −1].
Solving (2n, n)-DLOG: We first note that a non-trivial valid proof π cannot
recycle ( ˆV , ˆC, Cy) from an output of the simulation oracle (namely, we must
have ( ˆV , ˆC, Cy) ̸= ( ˆV (i), ˆC(i), Cy) for all i ∈[QS]) since the left-hand-side mem-
ber of (38) is uniquely determined by (ˆV (i), ˆC(i), C(i)
y ) and it in turn deter-
mines a unique valid π(i) ∈G. As a consequence, Hagg( ˆV , ˆC, Cy), Hξ( ˆV , ˆC, Cy),
Ht(y, ˆV , ˆC, Cy) and {Hs(i, [m + 1, n], ˆV , ˆC, Cy)}n
i=m+1 are not part of the ran-
dom oracle values that have been programmed by the simulator.
Since the left-hand-side member of (38) is obtained by raising the right-
hand-side members of (33)-(36) to the powers (δx, δeq, δy, δv) and multiplying
the results, it can be written e(g, ˆg)Pagg(α), where Pagg[X] is the polynomial
Pagg[X] = δx · Px[X] + δy · Py[X] + δeq · Peq[X] + δv · Pv[X]
obtained as a linear combination of the polynomials
Px[X] =

n
X
i=0
ai · Xi
·
 m
X
k=1
ℓk
X
i=1
2i−1 · ξk · Xn+1−(jk+i)
−

n
X
i=0
vi · Xi
·
 m
X
k=1
ξk · Xn+1−k
=
2n
X
i=1
ωi · Xi,
Py[X] =

2n
X
i=0,i̸=n+1
zi · Xi −
m
X
κ=1
nκ
X
i=1
yjκ+i · Xn+1−(jκ+i)
·

n
X
i=0
ai · Xi
=

z0 +
m
X
κ=1
nκ
X
i=1
 zn+1−(jκ+i) −yjκ+i

· Xn+1−(jκ+i) +
2n
X
i=n+2
zi · Xi
·

n
X
i=0
ai · Xi
=
3n
X
i=0
γi · Xi
Peq[X] =

n
X
i=0
ai · Xi
·
 m
X
κ=1
nκ
X
i=1
tjκ+i · yjκ+i · Xn+1−(jκ+i)
−

2n
X
i=0,i̸=n+1
zi · Xi
·
 m
X
κ=1
nκ
X
i=1
tjκ+i · Xjκ+i
=
3n
X
j=0
βj · Xj,
Pv[X] =

n
X
i=0
vi · Xi
·

n
X
i=m+1
si · Xn+1−i
=
2n
X
j=0
µj · Xj
for which the left-hand-side members of (33)-(36) can be written e(g, ˆg)Px(α),
e(g, ˆg)Peq(α), e(g, ˆg)Py(α) and e(g, ˆg)Pv(α), respectively.
47

If we write Pagg[X] = P3n
i=0 νi · Xi, the coefficient νn+1 of its degree-(n + 1)
term can be written
νn+1 = δx·
m
X
κ=1
ξκ ·
 ℓκ
X
i=1
ajκ+i · 2i−1 −vκ
!
|
{z
}
≜ωn+1
+ δy·
m
X
κ=1
nκ
X
i=1
 zn+1−(jκ+i) −yjκ+i

· ajκ+i
|
{z
}
≜γn+1
+ δeq ·
m
X
κ=1
nκ
X
i=1
tjκ+i · (ajκ+i · yjκ+i −zn+1−(jκ+i))
|
{z
}
≜βn+1
+ δv ·
n
X
i=m+1
vi · si
|
{z
}
≜µn+1
,
where (ωn+1, γn+1, βn+1, µn+1) are the coefficients of the degree-(n + 1) terms
of (Px[X], Py[X], Peq[X], Pv[X]).
We now argue that, if there exists k ∈[m] such that vk ̸∈[0, 2ℓk −1] or
if (vm+1, . . . , vn) ̸= 0n−m, then we can only have νn+1 = 0 with negligible
probability. This follows from the following arguments:
- The probability to have ρ ≜(ωn+1, γn+1, βn+1, µn+1, ζn+1) = 0 is negligi-
ble. Indeed, when (vm+1, . . . , vn) ̸= 0n−m, we have µn+1 = 0, with proba-
bility 1/p over the choice of {si = Hs(i, [m + 1, n], ˆV , ˆC, Cy)}n
i=m+1. When
zn+1−(jκ+i) ̸= ajκ+i · yjκ+i for some κ ∈[m] and i ∈[nκ], we have βn+1 = 0
with probability 1/p since t = Ht(y, ˆV , ˆC, Cy) is derived after the choice of
y, {ai}n
i=0 and {zi}i∈[0,2n]\{n+1}. Then, if zn+1−(jκ+i) = ajκ+i · yjκ+i for all
κ ∈[m], i ∈[nκ], we have γn+1 = Pm
κ=1
Pnκ
i=1 yjκ+i·(ajκ+i−1)·ajκ+i, which
cancels with probability 1/p if there exists κ ∈[m] and i ∈[ℓκ] such that
ajκ+i ̸∈{0, 1}. This can be seen by distinguishing two cases:
a. If y = H( ˆV , ˆC) was programmed when answering a simulation query,
we can only have γn+1 = 0 with probability 1/p since the simulator
programmed (a1, . . . , an) to have
γn+1 = ajk+1 · (zn−jk −yjk+1) = yjk+1 · ajk+1 · (ajk+1 −1)
for some index jk ∈[n] such that ajk+1 ̸∈{0, 1} and yjk+1 ∈R Zp.
This captures the case of A attempting to re-use ( ˆV , ˆC) = ( ˆV (i), ˆC(i))
contained in an output π(i) = ( ˆC(i), C(i)
y , π(i)) of the simulator, with a
different Cy ̸= C(i)
y .
b. If H( ˆV , ˆC) was not programmed by the simulator, then y = H( ˆV , ˆC)
was defined after B obtained the algebraic representation {ai}n
i=0 of ˆC.
Over the choice of y, we have Pm
κ=1
Pnκ
i=1 yjκ+i · (ajκ+i −1) · ajκ+i = 0
with probability 1/p.
If there exists k ∈[m] such that vk ̸= Pℓk
i=1 ajk+i · 2i−1, the probability to
have ωn+1 = 0 is only 1/p since ξ = Hξ( ˆV , ˆC, Cy) are chosen uniformly
after {vk}m
k=1 and {ai}n
i=0. If none of the above events occurs, then we have
48

vk = Pℓk
i=1 ajk+i · 2i−1 for each k ∈[m] and ajk+i ∈{0, 1} for each i ∈[ℓk].
This contradicts the hypothesis that vk ̸∈[0, 2ℓk −1] for some k ∈[m].
- If ρ ̸= 0, then we have νn+1 ̸= 0 with probability 1−1/p since the aggregation
coefficients δ ≜(δx, δeq, δy, δv) = Hagg( ˆV , ˆC, Cy) are derived after the choice
of {(ai, vi)}n
i=0, and {zi}i∈[0,2n]\{n+1}, which determine the coordinates of
ρ. Hence, a random independent δ ∈Z5
p can only satisfy ⟨δ, ρ⟩= 0 with
probability 1/p.
If νn+1 ̸= 0, then B can compute α ∈Zp by factoring a non-zero polynomial
as in the proof of Theorem 2.
⊓⊔
D.4
Range Proofs for Non-Power-of-Two Ranges
In order to prove membership of a range [0, B] where B + 1 is not a power of
2, a common approach to to use an additively homomorphic commitment and
consider the integer ℓ∈N such that 2ℓ−1 < B < 2ℓ. Then, we generate two
range proofs showing that x ∈[0, 2ℓ−1] and x + (2ℓ−1 −B) ∈[0, 2ℓ−1].
To do this without increasing the proof size, we can commit to vectors of
dimension n = 2¯ℓ(where ¯ℓis an upper bound on ℓ) containing a concate-
nation (x | x′) of the binary decompositions x = (x1, . . . , xℓ, 0, . . . , 0) and
x′ = (x′
1, . . . , x′
ℓ, 0, . . . , 0) of x and x + (2ℓ−1 −B), respectively. Then, the
prover can compute πx, π′
x ∈G
e(Q¯ℓ
i=1 g2i−1
n+1−i, ˆC)
e(gn, ˆV )
= e(πx, ˆg)
e(Qn
i=¯ℓ+1 g2i−¯ℓ−1
n+1−i, ˆC)
e(gn, ˆV · ˆg2ℓ−1−B)
= e(π′
x, ˆg),
where ˆV = ˆgr·ˆgx
1. In the above equalities, πx and π′
x show that x = P¯ℓ
i=1 xi·2i−1
and x + (2ℓ−1 −B) = P¯ℓ
i=1 x′
i · 2i−1. The rest of the proof follows the basic
construction of Section 4. The two proofs πx and π′
x can be aggregated (using
additional randomization components derived from a random oracle) with other
proof components to obtain a proof of the same form as in Section 4.
E
Proving Small Euclidean Norms
In this section, we extend the construction of Section D to prove that a com-
mitment ˆV = ˆgr · Qm
k=1 ˆgxk
k
is a commitment to some x = (x1, . . . , xm) ∈Zm
such that ∥x∥≤B. In order to preserve the zero-knowledge property, we need
to choose the group order p so that
p
p/m > B for any proven norm bound B.
When the CRS is generated, we thus assume a maximal value ¯B for the norm
bounds to be proven and choose p so that B∞≜
p
p/m > ¯B. For simplicity, we
assume that B2 + 1 is a power of two but this restriction can be lifted using the
observations in Section D.4. In the setup phase, we also need parameters allowing
commitments to vectors of dimension n = max(m·(1+⌈log B∞⌉), ⌈log( ¯B2 +1)⌉)
in order to use the scheme of Section D.1.
49

The prover has a commitment ˆV = ˆgˆr · Qm
k=1 ˆgxk
k
∈ˆG to an integer vec-
tor x = (x1, . . . , xm) ∈Zm and wishes to convince the verifier that ∥x∥≤B
without revealing anything else. To this end, it chooses r
R←Zp and computes
V = gr · Qm
k=1 gxk
n+1−k, which commits to ¯x = (0n−m | (xm, . . . , x1)) in the first
source group G. Then, the prover generates a proof showing that V ∈G commits
to the same vector as ˆV , but in the reversed order. This is done by computing
θ = (θ1, . . . , θm) = Hθ( ˆV , V ) ∈Zm
p using a random oracle Hθ and computing a
proof
πθ =
Qm
j=1

gˆr
n+1−j · Q
k∈[m]\{j} gxk
n+1+k−j
θj
Qm
j=1

gr
j · Q
k∈[m]\{j} gxk
n+1−k+j
θj
,
satisfying
e
  Qm
j=1 gθj
n+1−j , ˆV

e
 V, Qm
j=1 ˆgθj
j

= e(πθ, ˆg).
(47)
By itself, (47) only argues that the first m entries of x ∈Zn
p coincide with the
last n −m entries of ¯x in the reversed order. To ensure knowledge soundness,
we also need to prove that the last n −m positions of x are zeroes, but this will
be addressed at a later step.
Next, assuming that ˆV and V were indeed computed by the prover as com-
mitments to ((x1, . . . , xm) | 0n−m) and ((∗, . . . , ∗) | (xm, . . . , x1)), respectively,
we observe that the pairing e(V, ˆV ) computes a product of polynomials in the
exponent, where the coefficient of αn+1 is ∥x∥2 = ⟨x, x⟩. This allows the prover
the compute πB = Qm
k=1(grv
k · Qm
κ=1,κ̸=k gxκ
n+1−κ+k)xk such that
e(V, ˆV ) = e(g1, ˆgn)⟨x,x⟩· e(πB, ˆg).
(48)
However, πB is not disclosed. Instead, the prover computes the ℓB-bit represen-
tation of ∥x∥2 = Pm
k=1 x2
k (where ℓB = log(B2 + 1)) and commits to the vector
w = (w1, . . . , wℓB, 0, . . . , 0) ∈{0, 1}n by choosing γ
R←Zp, computing
ˆCw = ˆgγ ·
ℓB
Y
j=1
ˆgwj
j
(49)
and proving that the committed w is a binary vector. This is done by generating
a proof πw = (Cy,w, πw) ∈G2 as in Section 3. Now, we observe that the prover
can compute π′
B = QℓB
i=1
 gγ
n+1−i · QℓB
j=1,j̸=i gwj
n+1−i+j
2i−1
such that
e
  ℓB
Y
i=1
g2i−1
n+1−i, ˆCw

= e(g1, ˆgn)⟨x,x⟩· e(π′
B, ˆg).
(50)
By dividing (50) from (48), we see that the prover is able to compute a short
¯πB = πB/π′
B ∈G such that
e(V, ˆV )
e
  QℓB
i=1 g2i−1
n+1−i, ˆCw
 = e(¯πB, ˆg).
(51)
50

Together with the proof πθ satisfying (47) and πw, ¯πB shows that ˆV commits to
a vector ((x1, . . . , xm) | 0n−m) ∈Zn
p (we still assume that its last n−m positions
are proven to be 0) such that Pm
k=1 x2
k mod p is at most 2ℓB −1.
However, we also need to prove that Pm
k=1 x2
k mod p is actually Pm
k=1 x2
k
over Z, in which case we have ∥x∥≤B. To this end, the prover uses the
construction of Section D.1 to prove that ∥x∥∞≤
p
p/m, which ensures that
Pm
k=1 x2
k does not wrap around modulo p. We note that this additional proof
component does not affect the zero-knowledge property because the proven
statement ∥x∥≤B already implies ∥x∥∞≤
p
p/m (recall that we assumed
B ≤
p
p/m and we always have ∥x∥∞≤∥x∥). The prover thus generates
a proof π∞= ( ˆC, Cy, π∞) ∈ˆG × G2 that ∥x∥∞≤B∞by proving that
0 ≤xk +
p
p/m < 2
p
p/m for each k ∈[m] using the construction of Sec-
tion D, which also demonstrates that ˆV commits to a vector containing zeroes
in its last n −m entries.
The entire proof π =
 V, π∞, ˆCw, πw, πθ, ¯πB

is eventually comprised of
π∞= ( ˆC, Cy, π∞) ∈ˆG × G2, the commitment ˆCw and its proof of binarity
πw = (Cy,w, πw) ∈G2, the commitment V and the proof πθ satisfying (47), and
the proof ¯πB satisfying (51).
From a security standpoint, the knowledge-soundness property follows from
that of underlying proof components. Simulation-extractability is also preserved
as long as these components are bound together in a non-malleable way. To
do this, one option is to use a short one-time signature (such as the one from
[64, Section 5.4]) whose verification key is included in all random oracle inputs.
However, more efficient solutions are possible by suitably combining the various
sub-proofs together and including previously computed commitments in each
random oracle input.
In terms of efficiency, it is also possible to exploit the linearity of verification
equations and compress (π∞, πθ, πw, ¯πB) ∈G4 into a single group element π =
πδ∞
∞· πδθ
θ · πδw
w · ¯πδB
B
using aggregation coefficients (δ∞, δθ, δw, δB) derived from
a random oracle. This shrinks the proof to 2 elements of ˆG and 4 elements of G
while verification boils down to a product of 8 pairings.
F
Proving Small Hamming Weights
In this section, we show that our argument of Section 3 can be extended to prove
that committed vectors have small Hamming weights.
Compact proofs of small Hamming weights were previously considered by
Damg˚ard et al. [38] in the context of perfectly binding commitments. To our
knowledge, no efficient solution to this problem has been reported in the case
of perfectly hiding commitments if we aim at constant-size proofs. The only
solution we are aware of is to rely on SNARKs for general NP relations via an
expensive Karp reduction.
51

F.1
Proving Exact Hamming Weights for Binary Vectors
For a commitment ˆC = ˆgγ · Qn
j=1 ˆgxj
j
to a binary x ∈{0, 1}n, we can also
prove that x has a fixed Hamming weight. This is useful in the context of FHE,
where secret keys are sometimes chosen with a special structure for efficiency
reasons. To prove that a committed x is a binary vector of Hamming weight k,
we can prove that: (i) x is binary; (ii) Its inner product with the all-one vector
(1, 1, . . . , 1) is exactly k. Our technique from Section 3 allows handling (i). In
order to prove (ii), the prover can generate a short πk ∈G such that
e(
n
Y
i=1
gn+1−i, ˆC) = e(g1, ˆgn)k · e(πk, ˆg),
(52)
which is possible as in (1). Again, we can aggregate πk with other proof compo-
nents to obtain a proof comprised of one element of ˆG and two elements of G.
If we combine the above idea with the range proof construction, it is also
possible to prove that the Hamming weight HW(x) of the committed x is such
that HW(x) ≤B, for some bound B, without revealing the exact weight. In Ap-
pendix F.3, we provide a more efficient way to prove the inequality HW(x) ≤B
for arbitrary (i.e., not necessarily binary) vectors.
F.2
Proving Exact Hamming Weights for Ternary Vectors
If we want to prove the exact Hamming weight a committed x ∈{−1, 0, 1}ℓ,
we can first generate a commitment to ¯x = x ◦x, which is the Hadamard
product of x with itself. We can then prove that: (i) ¯x is indeed the product
x ◦x = (x2
1, . . . , x2
n); (ii) ¯x is binary and has Hamming weight B.
In order to prove (i), we need to compute Csq = gγsq · Qn
j=1 g
x2
j
j
as an aux-
iliary commitment to ¯x = x ◦x, for a random γsq
R←Zp, and prove that Csq
commits to x ◦x. This can be done by adapting the technique of Section 3. The
prover generates yet another commitment Cy = gγy · Qn
i=1 gyi·xi
n+1−i and proves
that it commits to (yn · xn, . . . , y1 · x1) by proceeding exactly as in Section 3.
Specifically, by computing (y1, . . . , yn) = H( ˆC, Csq) and adapting (7), the prover
can generate a short πy ∈G such that
e
 Cy, ˆC

= e(πy, ˆg) · e(g1, ˆgn)
Pn
i=1 yi·x2
i
(53)
Since the prover can also compute a short π′
y ∈G such that Csq satisfies
e
 Csq,
n
Y
i=1
gyi
n+1−i

= e(π′
y, ˆg) · e(g1, ˆgn)
Pn
i=1 yi·x2
i ,
(54)
it can compute πsq = πy/π′
y ∈G such that
e
 Cy, ˆC

e
 Csq, Qn
i=1 gyi
n+1−i
 = e(πsq, ˆg),
(55)
52

which follows by dividing (54) from (53). From ˆC ∈ˆG, Cy ∈G, Csq ∈G, πsq
and πeq (which shows that Cy commits to (yn · xn, . . . , y1 · x1)), the verifier is
convinced that Csq is a commitment to x ◦x.
F.3
Proving Bounded Hamming Weights for Arbitrary Vectors
We now consider the problem of proving small Hamming weights for an arbitrary
vector x = (x1, . . . , xn) ∈Zn
q committed as ˆC = ˆgγ ·Qn
j=1 ˆgxj
j . Using the additive
homomorphic property of the commitment scheme, this also allows proving that
two committed vectors are close in terms of Hamming distance.
In order to prove that x has at most B non-zero positions, we first generate
a commitment Cw to a random vector w = (w1, . . . , wn) ∈{0, 1}n of Hamming
weight HW(w) = B for which wi = 1 for all i ∈[n] such that xi ̸= 0. We can
then prove that: (i) w is binary and has Hamming weight B; (ii) For each i ∈[n],
wi = 1 whenever xi ̸= 0, which implies HW(x) ≤HW(w).
We can prove (i) as explained in Section F.1. In order to prove (ii), we will
prove that Pn
i=1 yi · (1 −wi) · xi = 0 for a random vector y = (y1, . . . , yn), which
ensures that ∀i ∈[n] : (xi ̸= 0) ⇒(wi = 1) with probability 1 −1/p. Indeed, if
there exists i ∈[n] such that xi ̸= 0 and wi = 0, we have Pn
i=1 yi·(1−wi)·xi = 0
with probability 1/p since y is computed after w and x.
In more details, the prover computes a commitment ˆCw = ˆgγw · Qn
j=1 ˆgwi
j
to
w ∈{0, 1}n, for some random γw
R←Zp, and proves that ˆCw is a commitment to
a binary vector using a short proof πw = (Cy,w, πw) ∈G2. Then, the prover gen-
erates another commitment Cy = gγy · Qn
i=1 gyi·wi
n+1−i and proves that it commits
to (yn · wn, . . . , y1 · w1), where (y1, . . . , yn) = H( ˆC, ˆCw), by proceeding exactly
as in Section 3. Next, the prover can generate a short πy ∈G such that
e
 n
Y
i=1
gyi
n+1−i · C−1
y , ˆC

= e(πy, ˆg) · e(g1, ˆgn)
Pn
i=1 yi·(1−wi)·xi = e(πy, ˆg),
(56)
which is possible since Qn
i=1 gyi
n+1−i ·C−1
y
= gγy ·Qn
i=1 gyi·(1−wi)
n+1−i
, so that the sum
Pn
i=1 yi · (1 −wi) · xi is the coefficient of αn+1 when we see the left-hand-side
member of (56) as a product of polynomials in the exponent.
The final proof then consists of ˆCw ∈ˆG, Cy,w, Cy ∈G, and a short π ∈G
obtained by aggregating the various proof components (including πw, πy, the
proof πB that ˆCw satisfies (52), and the proof that Cy is correctly formed).
G
Shorter Proofs for Ring LWE Ciphertexts
In this section, we show that the techniques of previous sections can be used
to obtain very short proofs for natural statements that arise in lattice-based
cryptography. For example, they can be used for all the applications described in
[45]. It includes proving the validity of an LPR ciphertext [85], a BGV ciphertext
53

[17], a ring GSW ciphertext [56], a TFHE ciphertext [32], or a ring LWE public
key. They can also be used to prove that a committed vector contains a GPV
signature [55].
We adapt the approach of del Pino et al. [41] with the difference that we
replace the BulletProofs range proof by our more compact proofs of smallness.
We also exploit the fact that the underlying vector commitment [81] allows
proving inner-product relations as in [80].
Let the polynomial rings R = Z[X]/(Xd + 1) and Rq = R/(qR), where
d is a power of two. As in [41], we aim at proving the existence of a witness
s = (s1, . . . , sM) ∈RM comprised of small-norm ring elements such that
M
X
i=1
ai · si = c mod (q, Xd + 1)
(57)
for public c, a1, . . . , aM ∈RN
q . The relation is defined as the set of pairs
(x, w) =

(c, a1, . . . , aM

∈(RN
q )M+1, (s1, . . . , sM) ∈RM
satisfying (57). To prove this relation, we proceed as in [41] and re-write (57) as
the following equality over Z[X]/(Xd + 1)
M
X
i=1
ai · si = c + r · q mod (Xd + 1),
(58)
where r = (r1, . . . , rN)⊤∈RN is a vector of polynomials of degree ≤d −1 and
the components of {ai}M
i=1 and c are interpreted as polynomials with coefficients
in {−⌊q/2⌋, . . . , ⌊q/2⌋}. If ∥si∥∞≤Bi for each i ∈[M], r contains polynomials
with coefficients of magnitude smaller than ∥r∥∞≤Br ≜dM · maxi∈[M](Bi)/2.
Let us parse ai = (ai,1, . . . , ai,N)⊤∈RN
q . Let the coefficient embedding ϕ :
R →Zd that maps si to its coefficient vector ϕ(si) ∈Zd. Let rot(ai,j) ∈Zd×d the
anti-circulant matrix such that ϕ
 ai,j · si mod (Xd + 1)

= rot(ai,j) · ϕ(si) ∈Zd.
If we re-write (58) as a matrix-vector product over Z, we obtain the relation
[A1 | . . . | AM] ·

ϕ(s1) | . . . | ϕ(sM)
⊤=
M
X
i=1
Ai · ϕ(si) = ϕ(c) + ϕ(r) · q
where Ai = [rot(ai,1)⊤| . . . | rot(ai,N)⊤]⊤∈ZNd×d
q
for all i ∈[M], ϕ(c) ∈ZNd
q
,
and ϕ(r) ∈ZNd. Equivalently, this can be written
[A1 | . . . | AM |
−q · INd ] ·

ϕ(s1) | . . . | ϕ(sM) | ϕ(r)
⊤
|
{z
}
≜¯
w
= ϕ(c)
(59)
In order to prove (59), a natural idea is to have the prover commit to the vector
¯w ∈ZMd+Nd using a vector commitment over ˆG. Then, using the batched range
proof of Section D.1, it can generate short range proof that ∥ϕ(si)∥∞≤Bi
54

for each i ∈[M] and ∥ϕ(r)∥∞≤dM · maxi∈[M](Bi)/2. Using the approach of
[41], it can then prove that (59) holds over Zp,10 where p is the order of ˆG. If
p > 2Mqd maxi(Bi), this ensures that (59) also holds over the integers. Instead
of using the batched range proof of Section D.1, we can make the proof shorter
(and spare one commitment in ˆG) by directly committing to the bits of ¯w.
For any integer z ∈Z, we define gz = (1, 2, 4, . . . , 2z−2, −2z−1)⊤∈Z1×z and
Gz = Id ⊗g⊤
z ∈Zd×dz. We also define G−1
z (v) as the decomposition function
that inputs an integer vector v ∈[−2z−1, 2z−1−1]d and outputs a decomposition
G−1
z (v) ∈{0, 1}d·z such that Gz ·G−1
z (v) = v. Then, for each i ∈[M], we define
˜Ai ≜

G⊤
1+log Bi · rot(ai,1)⊤| . . . | G⊤
1+log Bi · rot(ai,N)⊤⊤∈ZNd×d(1+log Bi)
q
and we prove that
 ˜A1
. . .
˜AM |
−q ·
 IN ⊗G1+log Br
 
|
{z
}
≜˜A
·


s1
...
sM
r1
...
rN


| {z }
≜˜
w
= ϕ(c),
(60)
where we set si = G−1
1+log Bi(ϕ(si)) ∈{0, 1}d·(1+log Bi) for each i ∈[M], and
ri = G−1
1+log Br(ϕ(ri)) ∈{0, 1}d·(1+log Br) for each i ∈[N].
The prover will thus commit to the bit-decomposition ˜w ∈{0, 1}D of the
witness, where D = d · (PN
i=1(1 + log Bi) + N(1 + log Br)). In order to prove
that relation (60) holds modulo p (and thus also over Z since both members
have infinity norm smaller than p/2), the prover will use a random θ ∈ZNd
p
(derived from a random oracle) and prove that the committed ˜w ∈{0, 1}D
satisfies θ⊤· ˜A · ˜w = θ⊤· ϕ(c) mod p. If ˜A · ˜w ̸= ϕ(c) mod p, then we have
θ⊤·( ˜A· ˜w−ϕ(c)) = 0 mod p with probability 1/p. Proving θ⊤· ˜A· ˜w = θ⊤·ϕ(c)
is doable using one element of G as explained in the introduction.11
G.1
Description
In the description below, the CRS does not depend on a specific public key, but
we allow it to depend on upper bounds on the RLWE dimension d, the modulus
q of (57) and the infinity norms {Bi}M
i=1. The reason is that they impact the
10 Here, x mod p is defined as the value y ∈(−p/2, p/2) such that y ≡x (mod p)
11 We actually prove (60) using the linear map commitment of Lai and Malavolta
[78, Appendix D.2]. While their scheme is only proven weakly function-binding (as
defined in [78]) in the random oracle model, it can be proven strongly function-
binding in the AGM+ROM and it still allows us to prove simulation-extractability
in the AGM+ROM.
55

dimension n of committed vectors and/or the order of the pairing-friendly group.
Therefore the CRS-Gen algorithm inputs an upper bound ¯d for the dimension,
an upper bound ¯q for the modulus and maximal values ¯Bi for the infinity norm
bounds Bi to be proven. The prover is allowed to choose a different dimension
d ≤¯d, a different noise bound Bi ≤¯Bi, and a different modulus q ≤¯q in each
proof. For simplicity, we assume that each norm bound Bi is a power of two.
CRS-Gen(1λ, 1 ¯d, 1¯q, 1 ¯
M, 1 ¯
N, {1 ¯
Bi} ¯
N
i=1): Given a security parameter λ, a maxi-
mal dimension ¯d ∈poly(λ), integers ¯N, ¯
M ∈poly(λ), ¯q ∈poly(λ), ¯Bi ∈
poly(λ), set Br ≜¯d ¯
M · maxi∈[M]( ¯Bi)/2 and do the following.
1. Generate asymmetric pairing-friendly groups (G, ˆG, GT ) of prime order
p > max(2l(λ), 2 ¯
M ¯q ¯d maxi( ¯Bi)), for some polynomial l : N →N. Let
n > ¯d · (P ¯
N
i=1(1 + log ¯Bi) + ¯N(1 + log Br)).
2. Pick a random α
R←Zp and compute g1, . . . , gn, gn+2, . . . , g2n ∈G as
well as ˆg1, . . . , ˆgn ∈ˆG, where gi = g(αi) for each i ∈[2n] \ {n + 1} and
ˆgi = ˆg(αi) for each i ∈[n].
3. Choose hash functions H, Ht : {0, 1}∗→Zn
p, Hagg : {0, 1}∗→Z3
p and
Hlmap : {0, 1}∗→Z ¯
N ¯d+1
p
that will be modeled as random oracles.
Output the CRS
pp =

(G, ˆG, GT ), g, ˆg, {gi}i∈[2n]\{n+1}, {ˆgi}i∈[n], H = {H, Ht, Hagg, Hlmap}

.
Provepp
 x, w

: Given a statement x = (q, d, M, N, {Bi}N
i=1, {ai}M
i=1, c) consist-
ing of dimensions d ≤¯d, M ≤¯
M, N ≤¯N, a modulus q ≤¯q, vectors of ring
elements {ai ∈RN
q }M
i=1, c ∈RN
q , and norm bounds Bi ≤¯Bi, as well as a
witness w = (s1, . . . , sM) ∈RM such that (57) holds with ∥si∥∞≤Bi for
each i ∈[M], do the following.
1. Compute polynomials (r1, . . . , rN) ∈RN such that ∥ri∥∞≤Br for each
i ∈[N] and satisfying (58). Encode (s1, . . . , sM) and (r1, . . . , rN) as
˜w =

s⊤
1 | . . . | s⊤
M | r⊤
1
| . . . | r⊤
N
⊤∈{0, 1}D,
using bit decompositions si = G−1
1+log B(ϕ(si)) ∈{0, 1}d(1+log Bi) for each
i ∈[M] and ri = G−1
log d(ϕ(ri)) ∈{0, 1}d·(1+log Br) for each i ∈[N], where
D = d · (PN
i=1(1 + log Bi) + N(1 + log Br)).
2. Commit to w ≜( ˜w | 0n−D) = (w1, . . . , wD, 0, . . . , 0) ∈{0, 1}n and prove
that w is binary. Namely,
a. Choose γ
R←Zp and compute ˆC = ˆgγ · QD
j=1 ˆgwj
j .
56

b. Compute y = (y1, . . . , yn) = H
 x, ˆC

∈Zn
p. Next, choose γy
R←Zp
and compute
Cy = gγy ·
D
Y
j=1
gyj·wj
n+1−j
Then, compute t = (t1, . . . , tn) = Ht(y, x, ˆC, Cy) ∈Zn
p.
c. Using (12), compute πeq ∈G such that
e(Qn
i=1 gti·yi
n+1−i, ˆC)
e(Cy, Qn
i=1 ˆgti
i )
= e(πeq, ˆg).
(61)
which shows that Cy commits to the (reversed) product y ◦w ∈Zn
p.
d. Compute πy = Cγ
y · Qn
i=1

gγy
i
· Q
j∈[n]\{i} gyj·(wj−1)
n+1−j+i
wi
such that
e
 Cy ·
n
Y
j=1
g−yj
n+1−j, ˆC

= e(πy, ˆg)
(62)
which shows that Pn
i=1 yi · wi · (wi −1) = 0.
3. Compute ¯θ = Hlmap
 x, ˆC, Cy

∈Z ¯
N ¯d+1
p
and define ˜A ∈ZNd×D and
ϕ(c) ∈ZNd as in (60). Let θ ∈ZNd+1
p
the first Nd + 1 entries of ¯θ.
4. Parse θ as θ =
 θ⊤
0 | δθ
⊤, with θ0 ∈ZNd
p . Let tθ = θ⊤
0 · ϕ(c) mod p and
a⊤
θ = θ⊤
0 · ˜A mod p. Generate a proof πθ ∈G satisfying
e
 D
Y
k=1
gaθ[k]
n+1−k, ˆC
!
· e(g1, ˆgn)−tθ = e(πθ, ˆg)
(63)
by computing πθ = QD
k=1(gγ
n+1−k · Q
j∈[D]\[k] gwj
n+1−k+j)aθ[k].
5. Compute (δeq, δy, δθ) = Hagg(x, ˆC, Cy) ∈Z3
p and an aggregated proof
π = πδy
y · πδeq
eq · πδθ
θ .
Output the final proof π =
  ˆC, Cy, π

.
Verifypp
 x, π

: Given a statement x = (q, d, M, N, {Bi}N
i=1, {ai}M
i=1, c) and a
candidate π, return 0 if π does not parse properly. Otherwise,
1. Compute (δeq, δy, δθ) = Hagg(x, ˆC, Cy) ∈Z3
p, y = H(x, ˆC) ∈Zn
p, t =
Ht(y, x, ˆC, Cy) ∈Zn
p.
2. Compute ¯θ = Hlmap
 x, ˆC, Cy

∈Z ¯
N ¯d+1
p
and let θ =
 θ⊤
0 | δθ
⊤∈ZNd+1
p
the first Nd + 1 coordinates of ¯θ. Compute tθ = θ⊤
0 · ϕ(c) ∈Zp and
˜a⊤
θ = θ⊤
0 · ˜A ∈ZD
p . Define a⊤
θ = (˜a⊤
θ | 0n−D) ∈Zn
p.
57

3. Return 1 if the following equality holds and 0 otherwise:
e(π, ˆg) = e

Cδy
y ·
n
Y
i=1
g(δeq·ti−δy)·yi+δθ·aθ[i]
n+1−i
, ˆC

· e

Cy,
n
Y
i=1
ˆgδeq·ti
i
−1
· e(g1, ˆgn)−tθ·δθ.
(64)
Correctness. Equation (64) is obtained by aggregating (61), (62), and (63)
using randomness (δeq, δy, δθ). The correctness of (61)-(62) can be shown as in
Section 4 while (63) is a special case of the verification equation of the inner
product functional commitment of [80] (recalled in the introduction, cf. (1)).
Efficiency. We note that a 256-bit p is more than enough to satisfy the con-
straint p > 2M · qd maxi(Bi) since d is typically 1024 or 2048, q ≈264, and M is
a small constant (concrete numbers are given in Supplementary Material G.3).
The CRS is comprised of 2n elements of G and n elements of ˆG. As in
PointProofs [61], the verifier does not need {gi}2n
i=n+2, which are only used by
the prover. The proof only consists of one element of ˆG and two elements of
G. Compared to the most efficient simulation-extractable variant [4] of Groth’s
SNARK [67], our proofs are shorter by one element of ˆG. This matches the op-
timal proof size of the simulation-extractable SNARK of Groth and Maller [68],
which is significantly more expensive than [67] in terms of prover time and CRS
size (see, e.g., [4] for detailed comparisons among them).
In terms of computation, π = πδy
y ·πδeq
eq ·πδθ
θ can be computed using 2n expo-
nentiations. At first, computing the corresponding exponents seems to require
O(n2) multiplications over Zp, which can be quite expensive for a very large
n. Fortunately, these exponents can be obtained via two products of degree-n
polynomials,12 using only O(n · log n) Zp-multiplications for a suitable prime p.
At step 4, the prover computes a product a⊤
θ = θ⊤
0 · ˜A mod p, which takes time
O(Nd · D) in general. When it comes to proving many natural statements in
structured lattices, the matrix ˜A has a special structure allowing to compute
θ⊤
0 · ˜A using only O(d · log d) multiplications in Zp, as explained in Supplemen-
tary Material G.4. The prover’s cost is thus dominated by 3n exponentiations in
G and a product of D = d · (PN
i=1(1 + log Bi) + N(1 + log Br)) elements in ˆG.
The verifier computes 3 pairings and n exponentiations in each source group.
The scheme is not fully succinct since the number of exponentiations at the
verifier grows with the length of the witness. On the prover side, however, it
enables significant savings compared to R1CS-based SNARKs as the number of
exponentiations only grows with the size of the witness, rather than the size of
the arithmetic circuit that computes the encryption function. Indeed, the num-
ber of ring operations in the encryption algorithm does not affect the number of
12 These polynomial products are implicitly computed in the exponent by the pairings
in the right-hand-side member of (64). One of these two products is much faster to
compute as it involves a polynomial of which almost all coefficients are binary.
58

exponentiations in the argument system.
In Supplementary Material G.3, we provide concrete proof/CRS sizes to-
gether with an estimation of the prover’s complexity when it comes to proving
the validity of a ciphertext in the LPR cryptosystem [85]. For such a statement,
we provide a detailed comparison with SNARKs [67] providing similarly short
proofs. Our construction is shown advantageous in applications (e.g., [93]) that
seek to decrease the prover’s computational effort, even at the cost of increasing
the verifier’s. We also provide a comparison with [41].
In Supplementary Material G.6, we describe a variant where the verifier com-
putes a constant number of exponentiations and the task computing the expen-
sive multi-exponentiations is shifted from the verifier to the prover.
G.2
Security
We first describe a simple zero-knowledge simulator.
Theorem 5. The above non-interactive argument is perfectly zero-knowledge.
Proof. To simulate a proof for a statement x = (q, d, M, N, {Bi}N
i=1, {ai}M
i=1, c),
we can use the trapdoor α ∈Zp of the CRS as follows. First, the simulator
samples γ, r, γy
R←Zp and computes ˆC = ˆgγ and Cy = gγy as commitments to
the all-zeroes vector. Next, it computes the polynomial
P[X] = γ · γy · δy + γ ·
n
X
i=1

(δeq · ti −δy) · yi + δθ · aθ[i]

· Xn+1−i
−γy · δeq ·
n
X
i=1
ti · Xi −tθ · δθ · Xn+1
for which the right-hand-side member of (64) can be written e(g, ˆg)P (α). Using
the secret exponent α ∈Zp, the simulator can then simulate a proof by com-
puting π = gP (α). It is easy to see that the resulting tuple π = ( ˆC, Cy, π) is
distributed as a real proof since the commitments ˆC and Cy are uniformly dis-
tributed in their group and π ∈G is uniquely determined by ( ˆC, Cy) and the
aggregation coefficients.
⊓⊔
We note that the zero-knowledge simulator of Theorem 5 is not trapdoor-
less [51] as it relies on the trapdoor of the CRS to simulate proofs. On the other
hand, it works in the standard model, without relying on random oracles. In the
proof of Theorem 6, we describe a trapdoor-less simulator that does not use the
trapdoor of the CRS, but rather proceeds by programming the random oracles.
Theorem 6. If the (2n, n)-DLOG assumption holds, the above non-interactive
argument provides simulation-extractability in the algebraic group model and in
the random oracle model.
59

Proof. In the AGM+ROM model, we show that, under the (2n, n)-DLOG as-
sumption, there is an extractor that can extract a witness from any adversarially-
generated proof π and statement x = (q, d, M, N, {Bi}N
i=1, {ai}M
i=1, c). Con-
cretely, we show an algorithm B that either extracts a witness or solves an (2n, n)-
DLOG instance by computing α ∈Zp from {(g, g1, . . . , g2n), (ˆg1, . . . , ˆgn)}, where
gi = g(αi) and ˆgi = ˆg(αi) for all i.
The problem instance {(g, g1, . . . , , g2n), (ˆg1, . . . , ˆgn)} is used to define pp.
Note that gn+1 = g(αn+1) is not included in pp although it is part of B’s input.
Our reduction/extractor B interacts with A as follows.
Queries: At any time, A can provide x = (q, d, M, N, {Bi}N
i=1, {ai}M
i=1, c) and
ask for a simulated proof that c ∈RN
q is a valid ciphertext for the public key
(a1, . . . , aM). To generate such a proof, the reduction B defines the public-key-
dependent matrix ˜A ∈ZNd×D and the ciphertext-dependent vector ϕ(c) ∈ZNd
as in (60). It chooses θ0
R←ZNd
p
and δθ
R←Zp and computes ˜a⊤
θ = θ⊤
0 · ˜A mod p
and tθ = θ⊤
0 · ϕ(c) mod p. We note that the first component ˜aθ[1] ∈Zp of
˜aθ ∈ZD
p is non-zero with overwhelming probability (as we may assume that
the first column ˜A[1] of ˜A ∈ZNd×D is non-zero). If θ⊤
0 · ˜A[1] = θ⊤
0 · ϕ(c), B
can generate a real proof using the witness ˜w = (1, 0, . . . , 0). We thus assume
θ⊤
0 · ˜A[1] ̸= θ⊤
0 ·ϕ(c), so that B can compute a non-binary w = (w1 | 0n−1) ∈Zn
p
satisfying the equation
a⊤
θ · w = tθ mod p,
where a⊤
θ = (˜a⊤
θ | 0n−D). It commits to w by computing ˆC = ˆgγ · ˆgw1
1
for a
random γ
R←Zp. Next, B simulates other proof elements as follows.
1. Choose random vectors δ = (δeq, δy, δθ)
R←Z3
p, y = (y1, . . . , yn)
R←Zn
p,
t = (t1, . . . , tn)
R←Zn
p.
2. Set zn = y1 and find an arbitrary (z1, . . . , zn−1) ∈Zn−1
p
such that
n
X
i=2
ti · zn+1−i = t1 · y1 · (w1 −1).
3. Choose a random z0
R←Zp and compute a simulated commitment
Cy = gz0 ·
n
Y
i=1
gzi
i .
4. If one of the random oracle values Hagg(x, ˆC, Cy), H(x, ˆC), Hlmap
 x, ˆC, Cy

or Ht(y, x, ˆC, Cy) was already defined, then abort and report failure. Oth-
erwise, set y = H(x, ˆC), t = Ht(y, x, ˆC, Cy), δ = Hagg(x, ˆC, Cy) and
¯θ = Hlmap
 x, ˆC, Cy

∈Z ¯
N ¯d+1
p
for a random vector ¯θ ∈Z ¯
N ¯d+1
p
whose first
Nd + 1 components are (θ0 | δθ).
60

5. Define the polynomials
Qy[X] =

n
X
i=0
zi · Xi −
n
X
i=1
yi · Xn+1−i
·

γ + w1 · X

=

z0 +
n
X
i=1
 zn+1−i −yi

· Xn+1−i
·

γ + w1 · X

=
n+1
X
i=0
σi · Xi
Qeq[X] =

γ + w1 · X

·

n
X
i=1
ti · yi · Xn+1−i
−

n
X
i=0
zi · Xi
·

n
X
i=1
ti · Xi
=
2n
X
j=0
ej · Xj,
Qθ[X] =
 D
X
k=1
aθ[k] · Xn+1−k
·

γ + w1 · X

−tθ · Xn+1 =
n+1
X
i=0
ζi · Xi
Their degree-(n + 1) coefficients are
σn+1 = w1 · (zn −y1) = 0
en+1 = w1t1y1 −
n
X
i=1
ti · zn+1−i = t1 · y1 · (w1 −1) −
n
X
i=2
ti · zn+1−i = 0
ζn+1 = aθ[1] · w1 −tθ = 0
due to the definition of committed w = (w1, . . . , wn) and z = (z1, . . . , zn).
6. Define the polynomial
Qagg[X] = δeq · Qeq[X] + δy · Qy[X] + δθ · Qθ[X] =
2n
X
i=0
ηi · Xi
for which ηn+1 = 0 by construction. Compute
π =
2n
Y
i=1,i̸=n+1
gηi
i
(65)
using (g, {gi}i∈[2n]\{n+1}) and return the simulated proof π = ( ˆC, Cy, π).
The proof π has the same distribution as an output of the simulator in the
proof of Theorem 5. Indeed, π is uniquely determined by x, ( ˆC, Cy) and the
Zp-elements y, t, and δ in the right-hand-side member (64). Moreover, while the
committed w, z ∈Zn
p are programmed in a special way, they are completely
independent of A’s view due to the randomness γ and z0 in ( ˆC, Cy).
Consequently, the simulation is perfect, unless one of the random oracles has
to be programmed on an input where it was previously defined. If QS (reps. QH)
is the number of queries made by A to the simulator (resp. to random oracles),
this happens with probability ≤(QS + QH) · QH/p.
61

Output: When A halts, it outputs x = (q, d, M, N, {Bi}N
i=1, {ai}M
i=1, c) and a
valid proof π =
  ˆC, Cy, π

. Let ˜A ∈ZNd×D the matrix obtained by encoding
{ai ∈RN
q }M
i=1 in (60).
Since we are in the AGM, A must provide representations of ˆC w.r.t to the
set of all ˆG-elements that it could observe during the game. It also has to provide
representations of Cy and π w.r.t to all G-elements that it was allowed to see.
Since the simulator used by B is algebraic, it also knows a representation of each
simulated C(i)
y
and π(i) w.r.t (g, {gi}i∈[2n]\{n+1}). It also knows a representation
of each simulated ˆC(i) w.r.t (ˆg, {ˆgi}i∈[n]). From A’s output and the randomness
of the simulation, B can therefore compute scalars {(ψi, zi) ∈Z2
p}i∈[0,2n]\{n+1}
and {wi ∈Zp}i∈[0,n] such that
ˆC =
n
Y
i=0
ˆgwi
i ,
Cy =
2n
Y
i=0,i̸=n+1
gzi
i ,
π =
2n
Y
i=0,i̸=n+1
gψi
i ,
where g0 = g and ˆg0 = ˆg.
If the representation w = (w0, w1, . . . , wn) ∈Zn
p of the commitment ˆC satis-
fies the conditions
(i) wk ∈{0, 1} for all k ∈[1, D];
(ii) ˜A · ˜w = ϕ(c) mod p, where ˜w = (w1, . . . , wD) ∈ZD
p ;
then B can use the bits (w0, w1, . . . , wD) ∈{0, 1}D to reconstruct witnesses
s1, . . . , sM ∈Z[X]/(Xd + 1) such that ∥si∥∞≤Bi for all i ∈[M] and (57)
holds, meaning that {si}M
i=1 are valid outputs for the knowledge extractor. We
now assume that at least one of the conditions (i)-(ii) does not hold.
Solving (2n, n)-DLOG: We remark that a non-trivial valid proof π cannot re-
cycle (x, ˆC, Cy) from a a simulated proof: That is, for all i ∈[QS], we must
have (x, ˆC, Cy) ̸= (x(i), ˆC(i), C(i)
y ) since the right-hand-side member of (64)
is uniquely determined by (x(i), ˆC(i), C(i)
y ) and it in turn determines a unique
valid proof element π(i) ∈G in the left-hand-side member. This implies that
(δy, δeq, δθ) = Hagg(x, ˆC, Cy) is not one of the hashes programmed by the simu-
lator and neither are t = Ht(y, x, ˆC, Cy), and ¯θ = Hlmap
 x, ˆC, Cy

.
Let the vector a⊤
θ = (˜a⊤
θ | 0n−D) ∈Zn
p defined in the Verify algorithm. From
the algebraic representations of A’s commitments and proof π, B can compute
Pθ[X] =
 D
X
k=1
aθ[k] · Xn+1−k
·

n
X
i=0
wi · Xi
−tθ · Xn+1 =
n+D
X
i=0
ωi · Xi
62

as well as the polynomials
Py[X] =

2n
X
i=0,i̸=n+1
zi · Xi −
n
X
i=1
yi · Xn+1−i
·

n
X
i=0
wi · Xi
=

z0 +
n
X
i=1
 zn+1−i −yi

· Xn+1−i +
2n
X
i=n+2
zi · Xi
·

n
X
i=0
wi · Xi
=
3n
X
i=0
γi · Xi
Peq[X] =

n
X
i=0
wi · Xi
·

n
X
i=1
ti · yi · Xn+1−i
−

2n
X
i=0,i̸=n+1
zi · Xi
·

n
X
i=1
ti · Xi
=
3n
X
j=0
βj · Xj,
for which the left-hand-side members of (61)-(63) can be written e(g, ˆg)Peq(α),
e(g, ˆg)Py(α), and e(g, ˆg)Pθ(α), respectively.
The right-hand-side member of (64) can be written e(g, ˆg)Pagg(α), where
Pagg[X] is the polynomial
Pagg[X] = δy · Py[X] + δeq · Peq[X] + δθ · Pθ[X] =
3n
X
i=0
νi · Xi
In Pagg[X], the coefficient νn+1 of the degree-(n + 1) term can be written
νn+1 = δy ·
n
X
i=1
 zn+1−i −yi

· wi
|
{z
}
≜γn+1
+ δeq ·
n
X
i=1
ti · (wi · yi −zn+1−i)
|
{z
}
≜βn+1
δθ ·
 D
X
k=1
a[k] · wk −tθ

|
{z
}
≜ωn+1
,
where ρ ≜(γn+1, βn+1, ωn+1) is the vector containing the coefficients of the
degree-(n + 1) terms of (Py[X], Peq[X], Pθ[X]).
We now argue that, if one of the conditions (i)-(ii) does not hold, the proba-
bility to have νn+1 = 0 is negligible. This follows from the following observations:
- The probability to have ρ = 0 is negligible. First, if zn+1−i ̸= wi ·yi for some
i ∈[n], we have βn+1 = 0 with probability 1/p since t = Ht(y, x, ˆC, Cy)
is derived after the choice of y, {wi}n
i=0 and {zi}i∈[0,2n]\{n+1}. Now, if we
assume that zn+1−i = wi · yi for all i ∈[n], then we have
γn+1 =
n
X
i=1
yi · (wi −1) · wi,
63

which vanishes with probability 1/p if there exists i ∈[n] such that wi ̸∈
{0, 1}. This can be seen by distinguishing two cases:
a. If y = H(x, ˆC) was programmed when answering a simulation query,
we can only have γn+1 = 0 with probability 1/p since the simulator
programmed (w1, . . . , wn) so has to have
γn+1 =
n
X
i=1
yi · wi · (wi −1) = y1 · w1 · (w1 −1)
where w1 ̸∈{0, 1} and y1 ∈R Zp. This captures the case of an adversary
attempting to re-use the components (x, ˆC) = (x(i), ˆC(i)) of a simulated
proof π(i) = ( ˆC(i), C(i)
y , π(i)) with a modified Cy ̸= C(i)
y .
b. If H(x, ˆC) was not programmed by the simulator, then y = H(x, ˆC)
was defined after B obtained the scalars {wi}n
i=0 underlying ˆC. We then
have the equality Pn
i=1 yi · (wi −1) · wi = 0 with probability 1/p over
the random choice of {yi}n
i=1.
If none of the previous events occurs, we have wi ∈{0, 1} for all i ∈[D].
Then, we are left with bounding the probability that ωn+1 = 0 when condi-
tion (ii) does not hold. In this case, we have θ⊤
0 · ( ˜A · ˜w −ϕ(c)) = 0 mod p
with probability 1/p since ¯θ = Hlmap
 x, ˆC, Cy

is defined after ˜A and ϕ(c).
- If ρ ̸= 0, then we have νn+1 ̸= 0 with overwhelming probability 1 −1/p
since the aggregation coefficients δ ≜(δeq, δy, δθ) = Hagg(x, ˆC, Cy) and
(θ0 | δθ) = Hlmap
 x, ˆC, Cy

are chosen uniformly after the choice of {wi}n
i=0,
{zi}i∈[0,2n]\{n+1} and x, which determine ρ. Therefore, the probability to
have ⟨δ, ρ⟩= 0 mod p is 1/p.
If νn+1 ̸= 0, B can compute α ∈Zp using the algebraic representation of π
as in the proof of Theorem 2.
⊓⊔
G.3
Efficiency Comparisons for Proving the Validity of Ring LWE
Ciphertexts
We consider a special case of the statement in (57) which corresponds to a proof
of validity of an LPR ciphertext [85]. For this specific concrete statement, we
compare our approach with a generic use of SNARKs for arithmetic circuits.
Let a statement consisting of a public key (a, b) ∈R2
q and an LPR ciphertext
(c1, c2) = (a·r+e1, b·r+e2+∆·m) ∈R2
q, where ∆= ⌊q/2⌋and m ∈R/(2R) is the
plaintext.13 We consider a prover willing to convince a verifier that there exist
13 We consider a parameter setting where the secret r is chosen so that ∥r∥∞= 1 an
the noise is sampled from a Gaussian with larger standard deviation.
64

m ∈R/(2R), r ∈R/(2R), and noise terms e1, e2 ∈R of norm ∥e1∥∞, ∥e2∥∞≤B
such that
 a
1
b
∆
1

·


r
m
e1
e2

=
c1
c2

mod q
(66)
Following [41], we will prove the above statement by showing the existence of
small polynomials r, m ∈R/(2R), e1, e2 ∈R, and r1, r2 ∈R such that
 a(X)
1
−q
b(X)
∆
1
−q

·


r(X)
m(X)
e1(X)
e2(X)
r1(X)
r2(X)


=
c1(X)
c2(X)

mod (Xd + 1)
with ∥e1∥∞, ∥e2∥∞≤B, and ∥r1∥∞, ∥r2∥∞≤(d + 1)/2. Over Z, this can be
written

rot(a)
Id
−q · Id
rot(b)
∆· Id
Id
−q · Id

|
{z
}
≜¯A
·


ϕ(r)
ϕ(m)
ϕ(e1)
ϕ(e2)
ϕ(r1)
ϕ(r2)


|
{z
}
≜¯
w
=
ϕ(c1)
ϕ(c2)

| {z }
≜ϕ(c)
,
(67)
where ¯A is interpreted as a 2d×6d matrix with coefficients in {−⌊q/2⌋, . . . , ⌊q/2⌋}.
The prover commits to the bits of ¯w and proves that
 rot(a)
G1+log B
−q · Glog d
rot(b)
∆· Id
G1+log B
−q · Glog d

|
{z
}
≜˜A ∈Z2d×D
·


ϕ(r)
ϕ(m)
e1
e2
r1
r2


|
{z
}
≜˜
w
=
ϕ(c1)
ϕ(c2)

| {z }
≜ϕ(c)
,
(68)
where e1 = G−1
1+log B(ϕ(e1)), e2 = G−1
1+log B(ϕ(e2)), r1 = G−1
log d(ϕ(r1)) and r2 =
G−1
log d(ϕ(r2)). We note that there is no need to decompose m, r ∈R/(2R) since
they are natively binary. The prover will thus commit to the decomposition of
the witness ˜w ∈{0, 1}D, where D = 2d(2 + log B + log d).
It is also interesting to consider proofs of validity in an encryption scheme
proposed by Joye [72], which was designed to be used as a component of the
65

TFHE [32] homomorphic encryption scheme. The scheme of [72] can be seen
as a variant of the LPR cryptosystem where the second ciphertext component
computes an inner product over Zq instead of a multiplication over Rq. For a
plaintext m ∈Zp and a noise e2 ∈Z, ciphertexts are of the form
(c1, c2) =
 a · r + e1, ⟨ϕ(¯b), ϕ(r)⟩+ e2 + ∆· m

∈Rq × Zq
where ∆= ⌊q/t⌋(for a plaintext modulus t) and ϕ(¯b) = (bn−1, . . . , b0) ∈Zn
q
contains the coefficients of the polynomial b(x) = b0+b1X+· · ·+bn−1Xn−1 ∈Rq
in reversed order. Note that c2 ∈Zq can be seen as the extraction of the last slot
from the second component b · r + ∆· m + noise of an LPR ciphertext since the
degree-(n −1) coefficient of the polynomial product b · r ∈Rq is ⟨ϕ(¯b), ϕ(r)⟩. In
this case, relation (67) simplifies as
 rot(a)
Id
−q · Id
ϕ(¯b)
∆
1
−q

|
{z
}
≜¯A
·


ϕ(r)
m
ϕ(e1)
e2
ϕ(r1)
r2


|
{z
}
≜¯
w
=
ϕ(c1)
c2

| {z }
≜ϕ(c)
.
(69)
while (68) becomes

rot(a)
G1+log B
−q · Glog d
ϕ(¯b)
∆· glog t
g1+log B
−q · glog d

|
{z
}
≜˜A ∈Z(d+1)×D
·


ϕ(r)
m
e1
e2
r1
r2


| {z }
≜˜
w
=
ϕ(c1)
c2

| {z }
≜ϕ(c)
,
(70)
with e2 = g−1
1+log B(e2) ∈{0, 1}1+log B and r2 = g−1
log d(r2) ∈{0, 1}log d. The
prover then commits to the decomposition of the witness ˜w ∈{0, 1}D, where
D = d + log t + (d + 1)(1 + log B + log d), where t is the plaintext modulus.
G.4
Efficiency Estimations
Application to the LPR cryptosystem.
In an instantiation of LPR for
λ = 128, a common choice of parameters is d = 1024, q ≈264, with binary uni-
form r ∈R/(2R) while e1, e2 are sampled from a discrete Gaussian distribution
with standard deviation αq ≈239. In this case, a given noise vector ei ∼DZd,αq
66

has infinity norm ∥ei∥∞≤B = αq
√
λ < 243 with overwhelming probability
by [84, Lemma 4.4]. The computational complexity and the CRS size are then
determined by n = D = 112640.
In order to obtain the coefficients allowing to compute π from the generators
{gi}i∈[2n]\{n+1}, the prover has to evaluate two products of degree-n polynomi-
als,14 which can be done using O(n·log n) multiplications. The prover also has to
compute the product a⊤
θ = θ⊤
0 · ˜A mod p. In (68), each block of ˜A has a special
structure allowing to compute the matrix-vector product using O(d · log d) mul-
tiplications over Zp. Indeed, computing θ⊤
0 ·[rot(a)⊤| rot(b)⊤]⊤takes O(d·log d)
multiplications while computing θ⊤
0 · (I2 ⊗Gz) can be done using 2dz additions
over Zp since Gz is of the form Id ⊗(1, 2, 4, . . . , 2z−2, −2z−1).
Eventually, the prover’s cost is dominated by 337920 exponentiations in G
and D + 1 multiplications, which are used to compute ˆC. If we assume that
exponentiations in ˆG are three times as expensive as in G, the overall workload
of the prover is roughly equivalent to 339150 exponentiations in G.
Given the relatively large value of n ≈217, we need to increase the group
order p by about 20 bits in order to obtain a sufficient security margin against
Cheon’s algorithm [31]. If we use a 275-bit group order, elements of G (resp.
ˆG) can have a 374-bit (resp. 1122-bit) representation using KSS18 curves. With
these parameters, the CRS size amounts to 25712 KB and proofs fit in 1870 bits.
Application to Joye’s scheme. We now consider an instantiation of the
scheme in [72] for parameters of interest where d = 1024, q ≈264 and when
the noise has magnitude B ≤242. We assume that the plaintext modulus t
has 8 bits due to compatibility constraints with the bootstrapping of TFHE. In
order to encrypt 256-bit messages, we consider a packed version of the scheme
allowing to encrypt k = 32 slots of 8-bit messages each and where all slots
{c2,i = ⟨ϕ(¯bi), ϕ(r)⟩+ e2,i + ∆· mi}k
i=1 share the same secret r ∈R/(2R) but
use independent noise terms e2,i such that ∥e2,i∥∞≤B.15 To prove a packed
version of relation (70), the prover commits to a vector ˜w of dimension
n > D = (d + k log t) + (d + k)(1 + log B + log d) = 57248.
Using KSS18 or BLS24 curves, this requires a CRS of 13068 KB or 14340 KB,
respectively. The prover computes at most 171744 exponentiations in G (143000
on average if the noise is sampled from a uniform distribution over [−B, B])
besides 57248 multiplications in ˆG.
The prover also computes 2 multiplications of polynomials with degree 57248
over a 275-bit field Zp and a matrix-vector product over Zp (which can be fast
since the matrix is structured). For a prime p such that p −1 is divisible by the
smallest power of 2 above n, all Zp-operations can be optimized using the FFT.
14 The first product is cheaper since one of the factors is of the form γ + PD
i=1 wi · Xi
for binary wi ∈{0, 1}
15 In this case, the matrix ˜A in (70) is modified to have d + k rows, where the last k
rows encode public keys components {ϕ(¯bi)}k
i=1 in the lower block.
67

Verification requires 57248 exponentiations in each source group of the pair-
ing.16 Assuming multiple threads at the verifier, we can speed up its computation
by splitting exponentiations in smaller batches to be processed in parallel. Also,
we can reduce the cost of ˆG-exponentiations by observing that the exponents
t = (t1, . . . , tn) do not need to be uniformly distributed over Zp since they are
only used to perform a batch verification in the proof of Theorem 6 (i.e., to
guarantee that βn+1 ̸= 0 w.h.p. in the expression of νn+1). By [46, Theorem
3.2], we can choose each ti uniformly in a 128-bit interval (instead of a 275-bit
one) and change the verification equation (64) into
e(π, ˆg) = e

Cδy
y ·
n
Y
i=1
g(δeq·ti−δy)·yi+δθ·aθ[i]
n+1−i
, ˆC

· e

Cδeq
y
,
n
Y
i=1
ˆgti
i
−1
· e(g1, ˆgn)−tθ·δθ,
which makes it faster to compute QD
i=1 ˆgti
i for 128-bit exponents {ti}i.
We note that, in both schemes [85,72], the NIZK argument of ciphertext
validity does not impose any constraint on the modulus q of the encryption
scheme (so that any NTT-friendly ring can be used). We only need to choose a
sufficiently large group order p to make sure that no implicit modular reduction
occurs when we want to prove relations (67) and (69) over the integers.
Possible choices of elliptic curve. In order to optimize the prover’s cost,
one may prefer using pairing-friendly curves enabling faster exponentiations in
the first source group G. One option is to choose G as a subgroup of a curve
E(Fr), for which the base prime field Fr is as small as possible. In this case, the
BLS24 curves [7] are good candidates as they offer the fastest exponentiations
in G (but slower exponentiations in ˆG). In order to obtain a sufficient security
margin against Cheon’s attack, we can choose p = |G| > 2275, in which case r
has 1.25·275 = 342 bits. By keeping r small, we also have a short representation
for group elements in G while elements of ˆG are typically 4 times as long as
those of G (when they live in the twisted curve E′(Fr4)). This yields a proof size
of 2052 bits and a CRS size of 14340 KB.
One disadvantage of BLS24 curves is their slower arithmetic in ˆG. In order
to obtain a more balanced tradeoff between the costs of multi-exponentiations in
G and ˆG, one may prefer using BLS12 curves. Using BLS12-379 curves, a multi-
exponentiation in ˆG with 57248 elements is computable in less than a second
according to the timings given in [43, Figure 4.2] for a 256-bit group order. In
order to obtain 128 bits of security and taking Cheon’s attack, one may use the
16 We note that, in applications to private smart contracts [93], this is acceptable since
transaction validators can proceed in parallel, regardless of the number of validators.
Moreover, a transaction is often considered valid when 2N/3 out of N validators have
verified the proof.
68

BLS12-446 curve from [70],17 which yields a group order p ≈2299 (such that 216
divides p −1) whereas elements of G (resp. ˆG) fit within 446 (resp. 892) bits.
G.5
Comparisons
For the above choice of parameters in the LPR cryptosystem, we commit to
vectors of dimension n = 112640, which translates into a prover computing
337920 exponentiations in G and 8196 exponentiations in ˆG. In general, expo-
nentiations in ˆG are at least 3 times as expensive as in G using KSS18 curves
(see, e.g., [6, Table 12]). In our setting, the prover computes the equivalent of
≈339150 exponentiations in G. In the example given in [41, Section 5.3] for
a smaller modulus q, del Pino et al. need about 724986 exponentiations at the
prover (and 200667 at the verifier). In general, their construction [41, Section
5.2] incurs up to 10n + 6 log n exponentiations at the prover (and 2n + 4 log n
exponentiations at the verifier) in order to generate a proof for a vector of di-
mension n. Here, we only need 3n exponentiations in G (and n multiplications
in ˆG) at the prover and the equivalent of 4n G-exponentiations at the verifier.
Although we need a slightly larger group order than theirs (i.e., 275 bits vs 256),
we expect our prover to be faster and our verification algorithm to be slower.
On the other hand, we lose the transparent setup property of BulletProofs and
we need to rely on the algebraic group model.
If we want to prove the same statement using Groth’s SNARK [67] in order
to obtain a similar proof size, we have to express the statement in the language
of Quadratic Arithmetic Programs (QAPs) [54] and obtain a CRS size growing
with the number of arithmetic constraints. Then, we run into two issues that
increase the size of the arithmetic circuit. First, proving the smallness of noise
terms e1 = (e1,1, . . . , e1,d)⊤, e2 = (e2,1, . . . , e2,d)⊤∈Z[X]/(Xd + 1) requires to
break their components into bits. Then, for each pair (b, j) ∈{0, 1} × [d], prov-
ing that {eb,j,τ}1+log B
τ=1
are all bits requires d · (1 + log B) constraints of the form
eb,j,τ · (eb,j,τ −1) = 0 mod p, each of which contributes to the number of multi-
plication gates. In our example, this would amount to 2d · (1 + log B) = 90112
arithmetic constraints. We also need 2d constraints to prove that r and m are
binary. Then, we need O(d·log d) additional constraints to compute the products
a·r and b·r over Zp[X]/(Xd+1) and map e1, e2 to the FFT domain. We note that
the prover can pre-compute (FFT(a), FFT(b)) and (FFT(c1), FFT(c2)) instead
of leaving it to the circuit,18 but the circuit still needs O(d · log d) multiplication
gates to compute FFT(r), FFT(e1) and FFT(e2).
The second issue is that constant-size SNARKs like [67,54] are designed to
handle arithmetic circuits over a large prime field Fp (where p > 2275 is the
order of the pairing-friendly group), whereas we need to prove a statement over
a ring Rq where q ≈264. As observed in [52], using finite field arithmetic to
emulate arithmetic over rings induces some overhead. For example, additions in
Rq may no longer be for free since adding two log q-bit integers over Fp may
17 See also https://neuromancer.sk/std/bls/BLS12-446.
18 This allows computing FFT(a · r) and FFT(b · r) using 2d multiplications.
69

result in a (1 + log q)-bit sum to be reduced in Rq. In [76], short-integer arith-
metic is emulated over Fp by reducing intermediate computation values modulo
q on carefully chosen occasions. In order to prove that a modular reduction
x mod q is performed correctly (when q is not a power of 2), the prover is re-
quired to provide wires x ÷ q and x mod q, allowing the circuit to check that
x = q · (x ÷ q) + (x mod q) and (x mod q) < q. In turn, the latter comparison
requires access to the bits of x mod q, which introduces log q arithmetic con-
straints. Using a greedy approach that only performs one reduction modulo q
per component of (c1, c2) = (a · r + e1, b · r + e2 + ∆· m), the remainder checking
technique of [76] would require 2d · log q = 131072 constraints, thus leading to
an arithmetic circuit with more than 250000 multiplication gates. To improve
this, we can instead interpret the components of (c1, c2) ∈R2
q as remainders of
the long division and prove the smallness of its quotients, which is also what our
construction is doing. Since each quotient has magnitude ≈d/2, this decreases
the number of constraints from 2d · log q to 2d · log d when it comes to proving
correct reductions modulo q. Overall, we estimate that the entire process would
still cost nm = 2d(1 + log B) + 4d + 5d · log d = 145408 arithmetic constraints to
prove the global statement.
While the number nm = 145408 of multiplication gates might seem only
slightly larger than our vector dimension n = 112640, it has a significant im-
pact. In the SNARK, the prover has to compute nm = 145408 exponentiations in
ˆG (with possibly large exponents over Zp) besides 3nm + (nw −ℓs) ≈806913 G-
exponentiations, where nw ≈374785 is the number of wires19 and ℓs = 4d = 4096
is the number of field elements describing the statement. In comparison, we only
need 337920 exponentiations in G and only 410 exponentiations in ˆG. If we
count each exponentiation over ˆG as 3 exponentiations in G, the SNARK of [67]
computes about 1243137 equivalent G-exponentiations. On the other hand, our
verification algorithm is more demanding and computes n exponentiations in
both groups ˆG and G when the SNARK only needs ℓs exponentiations in G.
As far as the CRS size goes, the SNARK approach would cost nm ≈145408
elements of ˆG and 2nm +(nw −ℓs) ≈661505 elements of G. Using KSS18 curves
with a 275-bit group order, it would take about 50116 KB. On the other hand,
the verifier only needs to store a small part of the CRS in Groth’s SNARK.
G.6
A Variant with O(1) Exponentiations at the Verifier
If we increase the number of exponentiations on the prover side, we can have a
verification algorithm that only computes a constant number of exponentiations
and O(n · log n) field operations in Zp. This can be done by exploiting the fact
that the CRS has a similar structure to that of KZG polynomial commitments
[74] and leveraging the constant verification time of KZG. If we consider the
19 The number of wires is nw = nm +nin +nout, where nin = 4d+2d+2d(log B +1)+
2d log d is the number of input wires and nout = 1+2d+2d(log B+1)+2d log d is the
number of output wires (where we count one output wire per bit-proving constraint).
70

scheme from Section G.1 where the verification equation is
e(π, ˆg) = e

Cδy
y ·
n
Y
i=1
g(δeq·ti−δy)·yi+δθ·aθ[i]
n+1−i
|
{z
}
≜Ch
, ˆC

· e

Cδeq
y
,
n
Y
i=1
ˆgti
i
| {z }
≜ˆ
Ct
−1
· e(g1, ˆgn)−tθ·δθ,
(71)
the idea is to have the prover compute all multi-exponentiations and convince
the verifier that they were correctly computed as KZG commitments (similar
ideas were used in [21]). The prover runs as in Section G.1 but it also computes
ˆCt = Qn
i=1 ˆgti
i and another helper commitment Ch = Qn
i=1 g(δeq·ti−δy)·yi+δθ·aθ[i]
n+1−i
.
Then, (Ch, ˆCt) are included in the proof so that the verifier can test the equality
(71) while performing only 2 exponentiations in G, one exponentiation in ˆG, and
one exponentiation in GT .
Note that (Ch, ˆCt) can be seen as deterministic KZG commitments to the
polynomials
Ph[X] =
n
X
i=1
 (δeq · ti −δy) · yi + δθ · aθ[i]

· Xn+1−i
Pt[X] =
n
X
i=1
ti · Xi,
(72)
which are computable by the verifier. To provide evidence that (Ch, ˆCt) were
really computed as KZG commitments to the above polynomials, the prover can
evaluate them on a random input z obtained by hashing (Ch, ˆCt) together with
all other commitments and proof components. Since both polynomials are eval-
uated on a common input, we can generate a single aggregated evaluation proof
πKZG ∈G for the polynomial Ph[X]+ω·Pt[X], for a random scalar ω ∈Zp. Given
the challenge point z = Hz(x, ˆC, Cy, π, Ch, ˆCt, y, t, δ) ∈Zp, the prover can derive
a randomizer ω = Hω(x, ˆC, Cy, π, Ch, ˆCt, y, t, δ, z, Ph(z), Pt(z))) and provide an
aggregated evaluation proof consisting of a single group element πKZG ∈G sat-
isfying
e(Ch · g−ph, ˆg) · e(g, ˆCt · ˆg−pt)ω = e(πKZG, ˆg1 · ˆg−z),
(73)
where (ph, pz) = (Ph(z), Pt(z)). Since X −z divides the linear combination
(Ph[X] + ω · Pt[X]) −(Ph(z) + ω · Pt(z)), the prover can compute πKZG from
(g1, . . . , gn) using n exponentiations in G.
The proof now consists of π = ( ˆC, Cy, π, Ch, ˆCt, πKZG), which is twice as large
as the original proof. The verifier checks both pairing product equations (71) and
(73). The polynomial evaluations (ph, pz) = (Ph(z), Pt(z)) are not included in
the proof since they can be re-computed by the verifier from (Ph[X], Pt[X]).
71

The security analysis proceeds identically to the proof of Theorem 6, except
that it additionally considers the case of adversarially-generated proof containing
malformed (Ch, ˆCt). Let the real polynomials (Ph[X], Pt[X]) defined in (72).
From the algebraic representation of commitments (Ch, ˆCt), the reduction can
compute polynomials Qh[X] and Qt[X] such that Ch = gQh(α) and ˆCt = ˆgQt(α).
If either Ch or ˆCt is malformed, we have (Qh[X], Qt[X]) ̸= (Ph[X], Pt[X]). This
implies Qh[X] + ω · Qt[X] ̸= Ph[X] + ω · Pt[X] with overwhelming probability
since (Ch, ˆCt, y, t, δ) are included in the inputs of Hz and completely determine
(Ph[X], Pt[X]) in (72) and (Qh[X], Qt[X]) (via the algebraic representation of
Ch and ˆCt). The KZG verification equation (73) then implies
(Qh(α) −ph) + ω · (Qt(α) −pt) = π(α) · (α −z)
where π[X] is defined by the algebraic representation of πKZG = gπ(α). Then, the
polynomial identity
(Qh[X] −ph) + ω · (Qt[X] −pt) = π[X] · (X −z)
(74)
must hold unless the reduction can compute α ∈Zp by factoring a non-zero
polynomial. Since (ph, pt) = (Ph(z), Pt(z)), (74) implies
(Qh(z) −Ph(z)) + ω · (Qt(z) −Pt(z)) = 0
However, since we assumed Qh[X]+ω·Qt[X] ̸= Ph[X]+ω·Pt[X] at this point, this
is only possible with probability 1/p because z = Hz(x, ˆC, Cy, π, Ch, ˆCt, y, t, δ)
is defined after (Qh[X], Qt[X], Ph[X], Pt[X]). This shows that, if an algebraic
cheating prover sends a malformed (Ch, ˆCt) ̸= (gPh(α), ˆgPt(α)), it can only pro-
vide an accepting πKZG (i.e., satisfying (73)) with negligible probability under
the (2n, n)-DLOG assumption.
The total cost for the prover now amounts to 5n exponentiations in G
(namely, n for each group element (Cy, Ch, πKZG) and another 2n to compute
π) and n exponentiations in ˆG. The proof size has now increased by a factor
2. While the prover complexity becomes roughly similar to that of a Groth16
prover for the same statement, the CRS size remains significantly smaller than in
R1CS-based SNARKs. In particular, the verifier only needs to store a constant
number of CRS components as in [67].
72

