Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
Contents lists available at ScienceDirect
Journal of Logical and Algebraic Methods in 
Programming
www.elsevier.com/locate/jlamp
Exploring nominal cellular automata ✩
Tommaso Bolognesi ∗, Vincenzo Ciancia ∗
Istituto di Scienza e Tecnologie dell’Informazione “A. Faedo”, Consiglio Nazionale delle Ricerche, Pisa, Italy
a r t i c l e 
i n f o
a b s t r a c t
Article history:
Received 15 December 2016
Received in revised form 7 June 2017
Accepted 8 August 2017
Available online 1 September 2017
Keywords:
Cellular automata
Nominal sets
The emerging ﬁeld of Nominal Computation Theory is concerned with the theory of 
Nominal Sets and its applications to Computer Science. We investigate here the impact of 
nominal sets on the deﬁnition of Cellular Automata and on their computational capabilities, 
with a special focus on the emergent behavioural properties of this new model and their 
signiﬁcance in the context of computation-oriented interpretations of physical phenomena. 
An investigation of the relations between Nominal Cellular Automata and Wolfram’s 
Elementary Cellular Automata is carried out, together with an analysis of interesting 
particles, exhibiting “nominal” behaviour, in a particular kind of rules, reminiscent of the 
class of totalistic Cellular Automata, that we call “bagged”.
© 2017 Elsevier Inc. All rights reserved.
1. Introduction
In the ﬁeld of logical and algebraic methods in Computer Science, a particular class of permutation algebras called 
nominal sets has gained quite some momentum in the last decades, for their appealing role as a constructive computational 
model, that albeit very similar to classical set theory, provides explicit support for names, that are attached to elements, and 
can be freshly allocated while respecting the classical axioms of alpha-convertibility.
Nominal sets are a modern recollection of the permutation model that Fraenkel and Mostowski had used to prove in-
dependence of the Axiom of Choice from the other axioms of set theory, and was re-introduced in Computer Science as 
the grounds for modelling abstract syntax in the presence of binding [14,23]. The theory of nominal sets has given rise in 
the last decades to a novel computing paradigm, based on the notion of pure name, with proven capacity to embrace and 
enhance the full spectrum of Theoretical Computer Science, including syntax and semantics [14,21], automata theory [1], 
regular expressions [18,15], and several other foundational topics, including the most famous theoretical device, namely 
Turing machines [2].
Cellular automata [17] (CAs) are a model of computation originally introduced in the 1940’s by Stanislaw Ulam and 
John von Neumann for modelling biological self-reproduction. In a cellular automaton (CA), cells are arranged in regular, 
ﬁnite-dimensional grids, and assume values from a ﬁnite alphabet (also called colours, or states). Cell updates occur simul-
taneously at discrete time instants (principle of synchrony), the new value of each cell depending of the values of the cells 
in its neighbourhood (principle of locality).
ECAs (for Elementary Cellular Automata) [25] are the simplest form of CA: cells are arranged in a 1D, inﬁnite, or ﬁnite and 
circular, array, they assume binary values, and cell neighbourhoods have diameter 3, meaning that the evolution of each cell 
is determined by its immediate left and right neighbours. In other words, the value ci(t + 1) of cell ci at time t + 1 depends 
✩Research partially supported by ISTI-CNR. The research of the second author was partially supported by the EU FP7 Project QUANTICOL, Grant agreement 
n. 600708.
* Corresponding authors.
E-mail addresses: t.bolognesi@isti.cnr.it (T. Bolognesi), vincenzoml@gmail.com (V. Ciancia).
http://dx.doi.org/10.1016/j.jlamp.2017.08.001
2352-2208/© 2017 Elsevier Inc. All rights reserved.

24
T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
on the value at time t of ci itself and of its immediate left and right neighbours, and is expressed by f (ci−1(t), ci(t), ci+1(t)), 
where f is a boolean function used for all cells (principle of uniformity). There exist 28 = 256 boolean functions of three 
variables, thus there exist 256 distinct ECAs. According to Wolfram’s numbering scheme, if f (1, 1, 1) = b1, f (1, 1, 0) =
b2, ..., f (0, 0, 0) = b8, then the ECA based on function f is numbered by the decimal representation of bit tuple (b1, ..., b8).
Being based on principles of locality and uniformity, CAs have been used for modelling a wide array of natural phe-
nomena, from crystal formation to ﬂuid dynamics, from reaction-diffusion in chemistry to pattern formation in biologic 
substrata. The contrast between the extreme simplicity of their deﬁnition and the richness of their emergent behaviours, as 
widely explored in [24,25], has induced some scientists to attribute to CAs, or similar simple models, a fundamental role 
for explaining the complexity of the physical universe as a whole. The idea that the complexity observed in nature be the 
manifestation of the emergent properties of a computation taking place at the tiniest spacetime scales is sometimes referred 
to as the computational universe conjecture.
The quest for simple theoretical models of digital spacetime is still open. Classical cellular automata provide a founda-
tional example. However, CAs already assume a universal meaning of colours in cells. In this work, instead, we consider 
a model which is solely based on equality, where the meaning of colours is only deﬁned at the local level. In order to 
achieve this, we resort to the machinery of nominal sets. The main purposes of this work are (i) to come up with a revised 
deﬁnition of cellular automata based on nominal computing concepts, and (ii) to present a preliminary exploration and 
discussion of the potential advantages that Nominal Cellular Automata might offer over classical CAs when dealing with 
the computational universe conjecture and, more generally and abstractly, with the emergence of complexity from simple 
premises.
In Section 2 we provide the general deﬁnition of Nominal Cellular Automaton (NCA), which merges naturally the classical 
deﬁnition of CA with the basic assumptions of nominal computing, we deﬁne a “bagged” variant of Nominal CA, closely 
related to the “totalistic”, classical CA, and we classify the spaces of NCAs and bagged NCAs, determining class sizes.
In Section 3 we examine the simplest form of NCA, that we call ENCA (“E” for “elementary”).
In Section 4 we start studying the relations between ENCA and Wolfram’s Elementary CA (ECA), identifying the subset of 
the ECAs that can be directly simulated by ENCAs.
In Section 5 we introduce a simple technique for simulating any ECA – including Turing-complete ECA 110 – by NCAs, 
thus obtaining a ﬁrst instance of a Turing-complete NCA.
In Section 6 we present some of the emergent patterns that can be observed in the spatio-temporal diagrams of NCAs, 
compare them with the classical CA scenario, and speculate on the potential beneﬁts that the new model might offer with 
respect to the computational universe conjecture.
In Section 7 we extend our analysis of emergent properties to the case of bagged NCA, and discover a number of particles 
that exhibit linear trajectories. Among them, we illustrate existence of particles that have an “internal” and an “external” 
(boundary) colour, can move the internal colour to the outside upon collision, and can bind the internal colour to a freshly 
generated name at a speciﬁc point in space-time. We ﬁnd such particles particularly interesting in light of the emergence of 
complex computational capabilities that can take into account causal dependencies, identity of entities, and communication 
capabilities. A formal correspondence between some totalistic and some bagged CA is also proved, analogies and differences 
of particles that emerge in the two cases are discussed, and possible advantages of the new types of nominal particles in 
terms of physical spacetime modelling are suggested.
This paper is an updated version of [5]. Besides catering for a more detailed presentation of NCA, previous work is 
extended by introducing the notion of bagged NCA, studying the corresponding class sizes, and starting to explore their 
behaviour (see Section 2.2 and Section 7). Such notion proved fundamental for discovering truly “nominal” emergent be-
haviour, or more speciﬁcally, name binding at particle creation time (Section 7.2.1).
2. Nominal Cellular Automata (NCA): deﬁnitions and classes
While in classical cellular automata the values assumed by cells range in a ﬁnite alphabet of symbols, or states (often 
called colours), in a Nominal Cellular Automaton (NCA) cell values are drawn from a countably inﬁnite alphabet: they range 
in an inﬁnite set of symbols, or names, that we denote N and conveniently represent by the natural numbers. A name 
denotes nothing but itself, and the only operations on names are: (i) compare names for equality, (ii) make a copy of a 
name, (iii) create a fresh name.
Similar to classical CA, the transition rule of a NCA establishes the next value of cell ci based on the current values of 
the cell and of those in its neighbourhood or, more precisely, on the equality pattern exhibited by these names. In this paper 
we restrict to one-dimensional CAs, in which the cells are arranged in a one-dimensional ﬁnite or inﬁnite array. We shall 
use the term context of cell ci to denote the tuple consisting of ci and some of its left and right neighbours, and the term 
diameter to precisely deﬁne the number of cells in the context (including ci). For example, the diameter-3 context of ci is 
(ci−1, ci, ci+1).
The new value to be assigned to a cell by the transition rule can be either one of the names found in the context at a 
given position, or a new name. The idea is that the rule is not allowed to access the names generated up to the current 
computation step: it can only access those immediately found in the context to which it applies, or create a new, fresh one.
It is worth remarking that NCAs are in fact cellular automata deﬁned in a different kind of set theory – namely, that of 
nominal sets. Let us brieﬂy recall the needed deﬁnitions (the interested reader may refer to [14,23] for more details). First, 

T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
25
ﬁx a countable set N of atoms or names (as we did above) and consider the set P of ﬁnite-kernel permutations of N. More 
precisely, a function π : N →N belongs to P if and only if it is bijective and the set {n ∈N | π(n) ̸= n} (the kernel of π) is 
ﬁnite.
Deﬁnition 1. A nominal set is a pair (X, −) where X is a set, and for all π ∈P, π : X →X is an injective function, obeying 
to the laws 
id = id, and 
π1 ◦π2 = 
π1 ◦
π2, with an additional ﬁnite support restriction, spelled out as follows. Say that set 
S supports x ∈X whenever for any ﬁnite-kernel permutation π such that, for all a ∈S, π(a) = a, we have π(x) = x. Then x
has ﬁnite support whenever there exists a minimal such set S, which is called the support of x. In a nominal set, all elements 
must have ﬁnite support.
A nominal set is usually thought of as a set X, in which each element x has an attached ﬁnite set of names supp(x), 
uniquely determined by the permutation action −. For example, the set of names itself is a nominal set under the trivial 
permutation action ˆπ = π, and the support of each name n is {n}. Finite tuples of names of arity k (such as the contexts 
of nominal cellular automata) form the nominal set (Nk, −) with point-wise permutation action; each tuple is supported 
by the names that appear in it. Formally, a nominal set is also known as a group action for the group of ﬁnite-kernel 
permutations of N, with the additional restriction to ﬁnite support.
We shall now deﬁne the class of “well-behaved” equivariant functions. When no ambiguity is raised, we shall just write 
π(x) instead of π(x), and X instead of (X, −).
Deﬁnition 2. An equivariant function from nominal set X to nominal set Y is a function f : X →Y such that for all π ∈P
and x ∈X we have f (π(x)) = π( f (x)).
An equivariant function, by deﬁnition, does not depend on the precise identity of names in the support of an element, 
since it is only deﬁned up-to the action of a permutation. The dynamics of NCA obeys to this principle, that is, it is an 
equivariant function.
Nominal reasoning (that is, the theory of nominal logic, see [23]) provides a way to constructively deﬁne a function 
generating names that are fresh. More precisely, one can deﬁne an equivariant function f by clauses such as f (A, x) = b, 
where A is a ﬁnite set of names, playing the role of a “freshness assumption”, recording names that have already been used, 
and either b ∈A ∪supp(x), or b is fresh for A and x. In the latter case, any fresh name could be chosen in place of b. The 
theory of nominal sets guarantees that 1) the speciﬁc fresh name chosen for b is irrelevant, that is, the deﬁned equivariant 
function is the same, and 2) a constructive procedure for choosing a fresh element exists – such as the representation 
provided by named sets (see [21,16,13,9]) that we instantiate “under the hoods” when we speak of equality patterns.
The speciﬁcation of an equivariant transition rule f of an NCA takes as input a ﬁnite context (that is, tuple of names) 
and can either return one of its elements, or a fresh one. In light of the aforementioned deﬁnition principle, no freshness 
assumption A is used in the deﬁnition of a rule, that is, A = ∅. However, set A becomes relevant when deﬁning the dynamics
g of an NCA starting from the transition rule f . The dynamics is the function mapping each possible state (or conﬁguration, 
e.g. a ﬁnite sequence, or a two-dimensional structure), into the next one. Informally speaking, g maps each conﬁguration C
into C′, by applying f to the context Ki of each cell ci, ensuring that fresh names generated by f at each context are also 
fresh with respect to the names generated when applying f to any other context K j, with j ̸= i. In order to formalise this, 
we chose an ordering of cells (such as the left-to-right order imposed by rows). The deﬁned function g is not dependent on 
the chosen order.
Deﬁnition 3. Let C = (ci∈[1,n]) be a ﬁnite NCA conﬁguration, where a total ordering has been chosen for the n cells that 
constitute it. For each i, let Ki ∈K be the context corresponding to cell i, drawn from the set of all possible contexts K
(the set of tuples of names of the given context arity). Consider an equivariant transition rule f : K →N, mapping each 
context into a name. Let A range over ﬁnite sets of names, and K range over K. Deﬁne f ′(A, K) = b, where b is fresh 
for A ∪supp(K) if f (K) is fresh for supp(K), b = f (K) otherwise. For A a ﬁnite set of names, deﬁne g(A, C) = C′, where 
C′ = (c′
i∈[1,n]) is inductively deﬁned as c′
1 = f ′(A, K1), and c′
i+1 = f ′(A ∪
j∈[1,i]{c′
j}, Ki+1).
The freshness assumption A in the deﬁnition of g(A, C) is needed in the deﬁnition of the global dynamics of an NCA, 
starting from an initial conﬁguration C and a rule f , and yielding the sequence Cm∈N of conﬁgurations obtained by repeated 
application of g as follows.
Deﬁnition 4. Fix an initial conﬁguration C of length n. Deﬁne by induction the sequence of pairs (Am, Cm), with m ranging 
over natural numbers, each Am a ﬁnite set of names, and each Cm = (cm
i∈[1,n]) a conﬁguration of length n, as A0 = ∅, C0 = C, 
and Cm+1 = g(Am, Cm), Am+1 = Am ∪
i∈[1,n]{cm
i }.
The global dynamics keeps tracks of all the names that have been generated up to a certain conﬁguration. Special care 
would be needed to deal with the case of inﬁnitely many cells (e.g. inﬁnite rows) in each state, which is certainly of 
theoretical interest, but could require application of more reﬁned logical theories, such as [11,12].

26
T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
Remark 1. It is worth emphasising that although the mathematical formalisation of NCA using nominal sets requires a name 
to be fresh with respect to the whole history of computation, there may be several ways to implement the machinery of 
NCAs without resorting to global knowledge about the whole considered computational universe. A centralised implementa-
tion, hosting a global fresh name generator, is not required. A distributed implementation of NCA is certainly possible. As a 
start, note that in the physical world, unique identity of certain particles and entities is a natural phenomenon (do we need 
a centralised authority to recognise a newborn baby?); but also in Computer Science, unique identiﬁers may be created 
hierarchically, based on previously, locally known identiﬁers (think of the internet Domain Name System), or probablistically, 
using random numbers drawn from very large domains.1
It is very important to note that, although our formalisation assumes a context Ki of a speciﬁed size, for each cell, such 
context is not in principle well-deﬁned for the boundary cells of ﬁnite structures. This is also the case in classical CAs. Two 
common choices are either to assume that there is an “external” boundary of cells with a ﬁxed value that is never updated, 
or that the neighbours of boundary cells are “wrapped” by using arithmetics modulo the dimensions of states. We resort to 
the latter in our examples.
2.1. Class sizes
Let us count the number of possible transition rules, thus NCA instances, for context diameter d. Determining the size 
of automata class C is an important preliminary step for its analysis by simulation: the concrete possibility of carrying 
out an exhaustive exploration of C, or the representativeness of a randomly sampled subset of it, crucially depend on the 
size of C, which may well range from a handful to billions or trillions of elements. Furthermore, the relevance of ﬁnding a 
Turing-universal element in C is generally considered higher when C is smaller, as the quantity of information carried by 
contexts and transformed by rules is smaller.
The transition rule is deﬁned by cases, using one component for each different context. Thus we ﬁrst need to determine 
the number of distinct contexts, or, more precisely, distinct equality patterns for context diameter d – a number that we 
denote X(d). The equality pattern of context c = (c1, ..., cd) is the information that indicates which element of the context is 
equal to which other element, with elements identiﬁed by their position in c. Formally, we could deﬁne it as the equivalence 
class of the d-tuples b = (b1, ..., bd) over N such that bi = b j if and only if ci = c j, with i, j ∈{1, 2, ..., d}. In the literature 
on nominal sets, this notion is referred to as permutation orbit (see, for example, Section 5.1 in [23]). For example, the 
equality pattern for context (38, 4, 4, 7, 11, 7) is a countably inﬁnite set of 6-tuples including, among others, (2, 4, 4, 1, 
0, 1), (0, 1, 1, 2, 3, 2), and of course (38, 4, 4, 7, 11, 7) itself. Then, we can easily establish that X(d) is the same as the 
number of partitions of a set of d different objects, which we can represent by the ﬁrst d integers: {1, 2, ..., d}. The reason is 
that we can establish an obvious one-to-one correspondence between the equality pattern and the partition. For example, 
the equality pattern for context (38, 4, 4, 7, 11, 7) corresponds to partition {{1}, {2, 3}, {4, 6}, {5}}: the latter neatly indicates 
that the ﬁrst and ﬁfth element of the context are different from each other and from all other elements, while the elements 
at positions 2 and 3 are equal, but different from all other elements in the context; the same holds for the elements at 
positions 4 and 6. It is also clear that the partition identiﬁes all and only the tuples of the equality pattern.
The number of partitions of a set of d different elements – thus our X(d) – is known as Bell number, or exponential 
number, and is denoted Bell(d). The ﬁrst Bell numbers, starting with d = 1, are 1, 2, 5, 15, 52, 203, 877, 4140, 21147, 
115975, 678570. One way to generate these numbers2 is to use the recurrence:
Bell(n) =
n−1

k=0
Bell(k)
n −1
k

.
For each context involving cell ci and its neighbours the transition prescribes a reaction, i.e. it deﬁnes the name to be 
assigned to ci next, which can be one of the names found in the context or a fresh name. Note that we use the term 
“context” for denoting both an actual tuple of names and the class of tuples that share the same equality pattern; strictly, the 
nominal viewpoint only understands the latter.
Let Cd = {Cd
1, Cd
2, ..., Cd
Bell(d)} be the set of contexts of length d and let α(Cd
i ) be the number of distinct names featured 
by context Cd
i . The number of possible reactions to context Cd
i is α(Cd
i ) + 1, where α(Cd
i ) counts the options for copying 
and re-using a name found in the context and +1 reﬂects the creation of a new name. We can then express the number of 
distinct instances of diameter-d NCAs as follows:
SpaceSize(d) =
Bell(d)

i=1
(α(Cd
i ) + 1).
(1)
We have implemented a simple context enumeration scheme and algorithmically computed SpaceSize(d) for various values 
of d. These are shown in Table 1, left column.
1 See e.g. the Internet Engineering Task Force Universally Unique Identiﬁer (UUID) Request For Comments: https :/ /tools .ietf .org /html /rfc4122.
2 Further information at http :/ /mathworld .wolfram .com /BellNumber.html and https :/ /oeis .org /A000110.

T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
27
Table 1
Sizes of NCA and bagged NCA spaces for various values of context 
diameter d.
d
NCA SpaceSize
Bagged NCA SpaceSize
2
6
2
3
216
6
4
89,579,520
12
5
≈1030
144
6
≈10127
576
7
≈10584
82,944
8
≈102899
2,985,984
Table 2
Class sizes of CAs and totalistic CAs with 2 and 3 colours, and various context diameters d.
d
2-colour CA
2-colour totalistic CA
3-colour CA
3-colour totalistic CA
2
16
8
19,683
243
3
256
16
≈1013
2187
4
65,536
32
≈1039
19,683
5
≈1010
64
≈10116
177,147
6
≈1019
128
≈10348
1,594,323
7
≈1039
256
≈101043
14,348,907
8
≈1077
512
≈103130
129,140,163
In Table 2, columns 1 and 3, we show, for comparison, the class sizes of ordinary 2- and 3-colour CAs with various 
context diameters (an n-colour CA is one in which cells assume values from an alphabet of n symbols).
2.2. Bagged NCA
We introduce now a variant of NCAs that bears some similarity with totalistic CAs. Totalistic cellular automata are a 
variant of CAs with weaker context-discrimination power: as usual, cells are assigned integer values in the range [0, h], 
where, typically, h = 1, but the order of the cells in the context is irrelevant, and contexts whose cell values add up to the 
same total are considered equivalent. Totalistic CAs are clearly a proper subset of ordinary CAs with the same diameter. The 
reason for being interested in them is that their space sizes are dramatically reduced, as shown in Table 2, columns 2 and 
4. The number of diameter-d, k-colour totalistic CAs is
kd(k−1)+1
since there are d(k −1) + 1 possible cell totals (i.e. distinguishable d-cell contexts, or situations), and for each of them the 
rule selects one among k possible values. Note that this calculation is valid both for 1D and for 2D CAs. For example, the 
number of distinct k-colour totalistic 2D CAs, when adopting the 5-element Von Neumann neighbourhood formed by cell 
c and the 4 cells sharing one edge with it, is k5(k−1)+1; this becomes k9(k−1)+1 when a 9-element context is considered, 
formed by c and all the 8 surrounding cells that share with c an edge or just a vertex.
Remark 2. So-called outer-totalistic CAs are also deﬁned in [25]; these are placed between totalistic and ordinary CAs. The 
transition rule for this CA variant consists, as usual, of one component for each “situation”, but the latter is now a pair 
formed by the total of the outer part of cell c’s context, and the precise value of c itself. As a consequence, there are 
more outer-totalistic than totalistic CAs: for a given context size d (including the current cell) and number of colours k, 
the number of outer-totalistic rules is kk((d−1)(k−1)+1). The most famous 2-colour, 2D outer-totalistic CA with a 9-element 
context consisting of a 3 × 3 cell matrix is Conway’s Game of Life, member of a family of 218 = 262, 144 different rules.
Similar to totalistic CAs, in our bagged, nominal CAs the order of the cells in the context is irrelevant; the context is 
not seen as a tuple but as a bag of names (whence the name), and the situation is characterised solely by the arities of 
this bag (forming another bag!). For example, the 5-context (a, a, b, c, c) corresponds to the bag {(a, 2), (b, 1), (c, 2)}, whose 
arities are 2, 1, 2; these, in turn, could be represented as bag {(2, 2), (1, 1)}, but we shall more concisely represent the 
latter bag by the string “1.2.2”, in which the ﬁrst bag’s arities are listed in ascending order (it is possible to do so since 
the speciﬁc identity of names is not used in NCA). We shall call this string context bag arity spectrum, abbreviated CBAS. The 
transition rule for a bagged NCA shall deﬁne a reaction – the assignment of a value to a cell – for each situation, represented 
by a CBAS. Intuitively, the CBAS represents the variety of elements (names) in a context, and their proportions, without 
being concerned with their identities, and, under the nominal viewpoint, appears as an appropriate abstraction of the above 
introduced notion of equality pattern.
For determining the space sizes of bagged NCAs we must ﬁrst ﬁnd the number of distinct CBAS’s for contexts of size d
which is, trivially, the number of partitions of integer d – of different ways to express d as a sum of unordered terms – 

28
T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
Table 3
Possible reactions for each context of diameter 3. Letter n denotes a fresh name. The product of the 
numbers in the third column yields the ENCA space size 216.
i
Context ci
Possible reactions
α(ci) + 1
1
(a,a,a)
a | n
2
2
(a,a,b)
a | b | n
3
3
(a,b,a)
a | b | n
3
4
(a,b,b)
a | b | n
3
5
(a,b,c)
a | b | c | n
4
known as partition number (see https :/ /oeis .org /A000041), that we denote Part(d). For d = 0, 1, ..., 15 its values are: (1, 1, 2, 
3, 5, 7, 11, 15, 22, 30, 42, 56, 77, 101, 135, 176).3
Let now Sd = {Sd
1, Sd
2, ..., Sd
Part(d)} be the set of distinct CBAS for contexts of length d and let γ (Sd
i ) be the number of 
distinct names that can be unambiguously identiﬁed in the context whose CBAS is Sd
i . Note that, unlike the NCA case, we 
cannot access the elements of the context by their position. The only way to identify a name from the context is to refer to 
its arity, whenever this is unique. For example, the already considered context tuple (a, a, b, c, c) corresponds to the CBAS 
“1.2.2”, thus we cannot unambiguously identify names a or c, since they share the same arity, while we can identify b, since 
its arity in the context is unique. In conclusion: γ (1.2.2) = 1.
The number of possible reactions, given a context with CBAS Sd
i , is γ (Sd
i ) + 1, where +1 reﬂects the creation of a new 
name, as in the non-bagged case. Then, the number of distinct, diameter-d bagged NCA is:
BaggedSpaceSize(d) =
Part(d)

i=1
(γ (Sd
i ) + 1).
(2)
Similar to the NCA case, we have implemented a simple CBAS enumeration scheme and algorithmically computed 
BaggedSpaceSize(d) for various values of d. These are shown in the rightmost column of Table 1, where they can be compared 
with the corresponding space sizes for the non-bagged case.
Remark 3. Just as a totalistic CA can be directly represented as a non-totalistic CA (by individually assigning to each contexts 
of the latter that shares the same total T a new cell value identical to that established for T by the former), we can directly 
express a bagged NCA rule as a normal NCA, as follows. Let c be one of the CBAS’s considered in the bagged rule. The 
reaction associated to c will be either a name, denoted ⟨x⟩, identiﬁed purely by its unique arity x in the CBAS, or a new 
name. In general there will be many equality patterns that correspond to c. It is easy to see that for each of these equality 
patterns we can express the same reaction adopted by the bagged NCA. In particular, if the reaction of the bagged NCA is 
⟨x⟩we can select within the equality pattern, just by its position in it, the unique name whose arity is x (there may indeed 
be an offer of multiple equivalent positions).
3. Elementary NCA (ENCA)
In analogy with ECA (Wolfram’s Elementary Cellular Automata), we deﬁne ENCA (Elementary Nominal Cellular Automata) 
as the subclass of NCA with context diameter 3.
The number of different diameter-3 contexts is small: Bell(3) = 5. Thus, we list all of them in Table 3, and identify for 
each context C the possible reactions and their number, which is α(C) + 1. An ENCA behaviour is deﬁned by indicating 
the reaction for each possible context. It follows that the ENCA space size is the product of the numbers in the rightmost 
column of the table, namely 216: the ENCAs are even less than the ECAs (256).
We can conveniently use a mixed basis (or mixed radix) numeral system for associating a number to each ENCA, using 
bases β(i) = α(ci) + 1, i = 1, ..., 5, i.e. (2, 3, 3, 3, 4). For example, the mixed basis notation:
0223130334
identiﬁes number 3 + 0(4) + 1(3 ∗4) + 2(3 ∗3 ∗4) + 0(3 ∗3 ∗3 ∗4) = 87, where the addends are obtained by scanning the 
above expression from right to left, and by using the product of the elements of the growing suﬃxes of tuple (2, 3, 3, 3, 
4). The smallest number expressible with this notation is 0203030304 = 0, while the largest number is 1223232334 = 215, 
establishing the range [0, 215] of indices for the 216 ENCAs.
For example, the transition rule of ENCA 87 is directly determined by the above mixed basis notation for number 87. 
The digits (0, 2, 1, 0, 3) are associated to the contexts listed from top to bottom in Table 3: the ﬁrst digit, 0, indicates that, 
if the ﬁrst context (a, a, a) is detected, then the ﬁrst reaction – a – is taken, and name a is assigned to the central cell (we 
number the alternative items at each entry of column possible reactions from left to right, starting from 0). The second digit, 
3 These numbers can be directly obtained by Mathematica function PartitionsP[d]. See also https :/ /oeis .org /A000041.

T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
29
Fig. 1. The ﬁve types of ENCA behaviour starting from uniform initial conditions – same name in all cells. The labels identify the ENCA rule numbers that 
correspond to each behaviour.
2, indicates that, if the second context (a, a, b) is detected, then the third possible reaction – n – is taken, and a fresh name 
is assigned to the central cell; and so on.
We shall consider circular arrays of length n, where cells cn and c1 are regarded as neighbours (as explained in Section 2). 
A technique widely exploited in [25] for a preliminary assessment of the computational capabilities of CAs consists in 
visually inspecting their diagrams when the computations start from uniform or random initial conditions. In these diagrams 
we shall represent different names by different grey levels.
The simplest uniform initial condition consists of an array of equal names. Fig. 1 shows the only ﬁve types of behaviour 
that are obtained in this case, and indicates the subset of ENCA corresponding to each of them. In the second, third and 
fourth case, n new names are introduced at the ﬁrst step, where n is the number of cells in the circular array (in Fig. 1 we 
set n = 12), and then shifted to the right (rules 108 to 212, by 4), not shifted (rules 109 to 213, by 4), or shifted to the left 
(rules 110 to 214, by 4). Only in the ﬁfth case new names keep being created at each step, indeﬁnitely.
A richer variety of behaviours is obtained by using two runs of equal names in the initial condition, that is, a tuple of 0’s 
followed by a tuple of 1’s. Fig. 2 shows the 93 types of behaviours obtained, each labelled by the number of the smallest 
rule that realises it.
With an initial cell array in which all names are different, only four distinct behaviours are observed. Essentially, these 
are already covered in Fig. 1, where the second row in each of the four rightmost diagrams is a tuple of distinct names (this 
fact is less visible in the rightmost diagram, due to the presence of a high number of different names/grey levels).
The most interesting cases are those in which the initial condition contains fewer distinct names than its size, with some 
duplicates. We postpone the illustration of some of these cases to the closing section of the paper.
4. Direct simulation of ECAs by ENCAs
What are the relations between ENCAs and ECAs? We start answering this question by identifying a subset of ECAs that 
can be directly simulated by ENCAs. By directly we mean that no pre-processing of the initial ECA conﬁguration is required 
for the ENCA to faithfully reproduce the ECA computation, bit by bit, row by row.
Let us consider the conditions an ECA rule must satisfy for an ENCA to be able to directly simulate it. Similar to ENCA 
rule numbers, an ECA rule number, expressed in binary form (thus in ﬁxed basis), identiﬁes the reactions associated to each 
of the 8 possible contexts-bit triples. Consider, for example, ECA 142. The bit octet (b1, b2, ..., b8) representing 142 is (1, 0, 
0, 0, 1, 1, 1, 0): these bits represent the value ci(t + 1) that is assigned to cell ci at time t + 1 whenever the values at time t
of the immediate left neighbour, the cell ci itself, and the immediate right neighbour match, respectively, the eight contexts 
((1, 1, 1), (1, 1, 0), (1, 0, 1), (1, 0, 0), (0, 1, 1), (0, 1, 0), (0, 0, 1), (0, 0, 0)). For an ENCA, contexts (b1, b2, b3) and (b′
1, b′
2, b′
3), 
where the prime symbol denotes bit ﬂipping, are indistinguishable, thus the reaction is the same, and will be to copy one 
of the distinct names found at a ﬁxed position in the triplet. This implies that the simulated ECA must react with ﬂipped 
bits to ﬂipped bit triples. Furthermore an ENCA can only copy names found in the inspected context, hence the reaction 
to (1, 1, 1) can only be 1, and the reaction to (0, 0, 0) must be 0 (as also implied by the previous observation). It follows 
that an ECA rule can be directly simulated by an ENCA only if its binary octet is of form (1, b2, b3, b4, b′
4, b′
3, b′
2, 0). Note 
that the octet above for ECA rule 142 satisﬁes these conditions. Three independent bits are suﬃcient to identify octets of 
this form. In conclusion, there are 8 ECAs that can be directly simulated by ENCAs, namely 142, 150, 170, 178, 204, 212, 
232, 240, since these are the only numbers in the range [0, 255] whose binary representation satisﬁes the above symmetry 
conditions.
For identifying the ENCAs that simulate ECA x, with x ranging in the above set of 8 elements, we must consider the bi-
nary representation (b1, b2, ..., b8) of x and use the bit tuple (b8, b7, b6, b5), where b8 is necessarily 0. The bits (b8, b7, b6, b5)
correspond to choices to be made by the ENCA rules within the set of possible reactions of Table 3. For example, for ECA 142 
we have (b8, b7, b6, b5) = (0, 1, 1, 1). This means that an ENCA that directly simulates this ECA must implement the follow-
ing reactions to the ﬁrst four contexts listed in Table 3: (a, a, a) →a, (a, a, b) →b, (a, b, a) →b, (a, b, b) →b. The reaction to 

30
T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
Fig. 2. The 93 types of ENCA behaviour starting from two adjacent runs of thirteen 0’s and thirteen 1’s. The labels identify the smallest ENCA rule that 
corresponds to each behaviour.
context (a, b, c) can be expressed as a base-4 digit z that selects in a|b|c|n, and is irrelevant since this context never occurs 
in ECA computations: this explains why 4 distinct ENCAs simulate the same ECA. The codes of the latter are obtained by 
interpreting the ﬁve digits (b8, b7, b6, b5, z) in the mixed basis notation introduced earlier for numbering ENCAs. In Fig. 3
we show the eight ECAs that can be directly simulated, and the corresponding ENCAs. The computations start with random 
bit conﬁgurations.
5. Simulation of ECAs by NCAs
By appropriately encoding the initial conﬁgurations, we can simulate any of the 256 ECAs by using NCAs of suﬃciently 
large context diameter.
Proposition 1 Every ECA can be simulated by a diameter-12 NCA.
Proof
Let fx : {0, 1}3 →{0, 1} be the boolean function that yields the next value of a cell based on the current value of 
its context c, for ECA x, and let F X : N12 →N (N are the non-negative integers) be the (equivariant) function that 

T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
31
Fig. 3. The eight ECAs that can be directly simulated by ENCAs; the latter are identiﬁed, case by case, by the numbers below the diagrams.
Table 4
Possible reactions of NCA X for each context (class) of diameter 
12. Letters p, q, r denote fresh names different from one another 
and from 0 and 1. Symbols b1, b2, b3 denote bits.
Context C
Reaction F X(C)
(b1, 0, 1, p,b2, 0, 1,q,b3, 0, 1,r)
fx(C1, C5, C9)
(0, 1, p,b1, 0, 1,q,b2, 0, 1,r,b3)
C1
(1, p,b1, 0, 1,q,b2, 0, 1,r,b3, 0)
C1
(p,b1, 0, 1,q,b2, 0, 1,r,b3, 0, 1)
New
Otherwise
New
yields the next value of a cell based on the equality pattern of the current context C, for the NCA X designed to 
simulate x.
The encoding of the initial conﬁguration cinit of x consists in inserting the three names (0, 1, p), with p fresh, 
after each bit bi, so that:
cinit = (b1,b2,b3,b4 ...) →
Cinit = (b1, 0, 1, p,b2, 0, 1,q,b3, 0, 1,r,b4, 0, 1, s ...).
It follows that p, q, r, s are different from one another, and from both 0 and 1.
Table 4 provides the deﬁnition of F X(C), thus of NCA X.
The ﬁrst four table rows correspond to four key classes of contexts, that differ by the position taken by the 
’trident’ of mutually distinct names, say p, q, r, within the context, with q and r appearing at respective distances 
4 and 8 at the r.h.s. of p.
It should be clear that the position of the trident in the context – thus the identiﬁcation of the context class, 
and of the corresponding reaction F X(C) – can be unambiguously detected under the nominal viewpoint: viewing 
the context as a bag, there are exactly three symbols that occur exactly once in C, namely those forming the 
trident; all other symbols (0’s and 1’s) occur at least three times each.
Let us now comment the rows of Table 4 in detail.
First row
p, q, r are found at context positions C4, C8, C12. Then we know that C1, C5, C9 are the original ECA bits 
and set F X(C) = fx(C1, C5, C9). Note that, under the nominal viewpoint, we can still access the ’absolute 
values’ of the C1, C5, C9, arguments of fx, via the comparison of C1 with C2 or C3 (known to be 0 and 1), 
and similarly for C5 and C9. Then, the actual bit produced by fx(C1, C5, C9) can be copied from C2 or C3.
Second row
p, q, r are found at C3, C7, C11. Then we know that C1, C5, C9 are 0’s and we copy one of them, 
setting F X(C) = C1.
Third row
p, q, r are found at C2, C6, C10. Then we know that C1, C5, C9 are 1’s and we copy one of them, setting 
F X(C) = C1.
Fourth row
p, q, r are found at C1, C5, C9. Then we set F X(C) = new, where n is a fresh name.
Fifth row. For any equality pattern of C that does not match any of the patterns above, function F X(C) can be 
given an arbitrary value, and we choose a fresh name.
Function F X mimics function fx in one case (ﬁrst row), and guarantees to produce, respectively, 0’s, 1’s and new 
names in the other three cases (rows 2, 3, 4).
It is obvious that all the length-12 contexts found in the initial encoding match only the patterns listed in the 
ﬁrst four table rows, and it is trivial to see that F X is designed to satisfy this same constraint in all subsequent 
rows of the nominal CA computation (so that the deﬁnitional clause for F X in the last row of Table 4 will never 

32
T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
Table 5
Possible reactions of NCA Z for each context (class) of diameter 9. 
Letters p, q, r denote fresh names different from one another and 
from 0 and 1. Symbols b1, b2, b3 denote bits.
Context C
Reaction F Z (C)
(b1, 0, p,b2, 0,q,b3, 0,r)
f110(C1, C4, C7)
(0, p,b1, 0,q,b2, 0,r,b3)
C1
(p,b1, 0,q,b2, 0,r,b3, 0)
New
Otherwise
New
be applied), and that the names in the columns corresponding to the bits b1, b2, ... in the initial encoding Cinit
replicate the computation of ECA x. ♦
We implemented the above rule in Mathematica, and veriﬁed that the computation of the context-12 NCA, once decoded 
by retaining only the names at columns 1, 5 and 9, reproduces the computation of the chosen ECA x.
5.1. Turing-universality: simulating ECA 110
ECA 110 is Turing-universal [10], thus any device able to simulate this elementary CA inherits its universality. Propo-
sition 1 then implies that the class of diameter-12 NCAs include at least one universal nominal CA. This result is slightly 
improved by the following proposition.
Proposition 2 There exists a Turing-universal, diameter-9 NCA.
Proof
The proof consists in providing a context-9 NCA – call it Z – that simulates ECA 110, by deﬁning its associated 
equivariant function F Z . Similar to the proof of Proposition 1, we start by deﬁning an encoding Cinit for the generic 
initial conﬁguration cinit of ECA 110. The encoding now consists in inserting only two names (0, p), where p is a 
new name, after each bit bi of cinit:
cinit = (b1,b2,b3 ...) →Cinit = (b1, 0, p,b2, 0,q,b3, 0,r ...).
F Z is built in analogy with the diameter-12 case (see the proof of Proposition 1), except that now only three
cases are distinguished, relative to the position of the mutually distinct names p, q, r in the context C of length 9, 
since the ‘trident’ of these names now overlaps with itself after only three shifts to the right.
Table 5 lists in the ﬁrst three rows the three key context classes and the corresponding F Z values. The ﬁrst row 
deserves special attention. Here the deﬁnition of F Z makes use of function f110(C1, C4, C7). Again the access to the 
‘absolute values’ of the arguments of f110 is legitimate, because the equality pattern of context C provides infor-
mation about the comparisons between the names in C1, C4, C7 and the neighbouring 0’s that we have introduced 
ad-hoc in the encoding. However, once F Z has recognised the bits in C1, C4, C7, it must also produce a new symbol, 
possibly copying a 0 or a 1 from the context. In our present encoding, no 1’s are inserted that can be copied from 
predeﬁned positions, but this could only be a problem when b1, b2, b3 in context C = (b1, 0, p, b2, 0, q, b3, 0, r)
are themselves all 0’s, since in all other cases a ‘1’ is offered by at least one of the three bits. It turns out that 
function f110 is such that f110(0, 0, 0) = 0 (corresponding to the rightmost 0 of the binary expansion 01101110 of 
decimal 110). Thus name 1 is not required in this case, while the desired 0 is found, say, at context position C2.
Rows 2 and 3 in Table 5 describe the clauses of the deﬁnition of F Z(C) that deal with the writing, in the next 
row of the NCA computation, of the ad-hoc name 0, and of a new name, so that the general pattern of these rows, 
and of the contexts of length 9 found in them, is preserved. Row 4 of the table completes the deﬁnition of F Z (C)
by covering ’don’t care’ patterns that will never occur, when starting from a properly encoded Cinit. ♦
In Fig. 4 we show an example ECA 110 computation and the corresponding NCA. The new names used for the encoding 
described above are represented in the lower diagram of Fig. 4 by different grey levels, whereas yellow and red indicate the 
constant values used to encode the two possible states of the ECA.
6. Emergent behaviours in ENCA
How does the adoption of the nominal viewpoint impact on the emergent properties exhibited by cellular automata?
One of the most spectacular emergent features of CAs is that of digital particles (we shall drop the attribute “digital” in the 
sequel). First observed by Zuse in [26], particles became popular with the “gliders” and various forms of “spaceships” arising 
in Conway’s Game of Life, a two-dimensional CA, and were subsequently discovered also by Wolfram in ECAs. In the case 
of ECAs, a particle is a periodic structure that cuts across the spacetime CA diagram; in these diagrams, space and time are 
associated, respectively, to the horizontal and the vertical dimension. When started from a random array of bits, a handful 
of different particles invariably emerge in ECA 110 [25], that draw linear trajectories against a periodic background, moving 

T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
33
Fig. 4. An example ECA 110 computation and the corresponding computation in the simulating NCA. (For interpretation of the references to colour in this 
ﬁgure, the reader is referred to the web version of this article.)
Fig. 5. Classical and nominal particles in ENCA 8.
slower than “the speed of light” – one horizontal cell per vertical step – and engage in various interactions. These particles 
play a crucial role for proving the Turing completeness of ECA 110 [10].
The unbounded name creation feature, implied by the adoption of the nominal viewpoint, allows us to extend the 
deﬁnition of digital particle. Periodic structures of bounded width that move across spacetime while involving a ﬁnite set of 
names (e.g. the ECA 110 particles, formed by names 0 and 1) can still be observed, but now we can also conceive spacetime 
substructures in which periodicity holds only in the nominal sense, i.e. only at the level of the equality pattern. It is clear 
that this implies the appearance of a potentially inﬁnite series of new names in the trajectory, breaking classical periodicity. 
Note that a classical particle with periodic trajectory shape is periodic also in the nominal sense: the equality pattern is 
periodic too, that is, it is unaffected by a name permutation: the crucial difference between classical and nominal particle 
is that the latter may involve an inﬁnite set of names.
As an example, consider ENCA 8. This automaton turns out to be the ﬁrst member of the family to trigger unbounded 
name creation, when started from a uniform random distribution of bits. Fig. 5 illustrates its behaviour, showing both actual 
names (at the right) and their grey level representation (at the left). In this case, particularly simple diagonal particles of 
both types discussed above are easily detected. For example, the diagonal formed by instances of name 1, starting at matrix 
cell (1, 1) is a classical particle, while the line immediately below, starting at matrix cell (2, 1) with names 2, 6, 10, 15, 19..., 
represents a properly nominal particle, that we may represent as a sequence n1, n2, ..., nk, ... , involving mutually distinct 
names. Incidentally, note that the numeric pattern is not regular: although an arithmetic progression of the numbers along 

34
T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
Fig. 6. ENCAs 145, 157, 169, from the same initial random bit tuple.
the trajectory would not be strictly relevant, as it would depend on the speciﬁc choice of fresh name generation among the 
inﬁnitely many possibilities, it would be helpful for the automatic detection of these structures. As an alternative example, 
ENCA 28 produces particles of both types that do not move in space, but only in time; in this case, the names in the 
nominal particles do follow an arithmetic progression.
Started from random bits, ENCA 11 is the ﬁrst automaton to exhibit “maximum creativity”: it quickly settles into a 
steady state in which new names are generated for each cell at each step, thus yielding a dynamics that appears analogous 
to the total uniformity observed in the simplest ECAs. The analogy between a background of mutually distinct names, in 
the nominal CA setting, and a background of equal names – e.g. all 0’s – in the classical CA setting proves useful also when 
dealing with linear particles, as discussed in the next section. In the case of total uniformity – both in the classical and in 
the nominal sense – any orderly arrangement of cells that cuts across the spacetime diagram at some angle could in principle
be regarded as a particle. However, the importance of emergent particles is related to their ability to carry information, to 
interact with one another and, ultimately, to perform computation. This is not the case with particles that run in parallel, 
or with those one may pretend to detect in the extreme case of a totally uniform ﬁeld.
We did ﬁnd interesting cases of nominal, interacting particles, but not in the family of ENCAs. Before leaving the dis-
cussion on this small family of automata, let us quickly mention the remarkable subset formed by codes 145, 157, 169. 
Computations of these automata, starting from the same tuple of random bits, are shown in Fig. 6. The peculiarity of these 
ENCAs is that they exhibit unbounded name creation while allowing names to survive for considerably long times.
7. Emergent behaviours in bagged NCA
Let us now explore the emergent properties of nominal CAs beyond ENCAs. In light of the above mentioned fact (see 
Remark 3) that a bagged NCA can be implemented as a non-bagged NCA, it is clear that searching the space of the former 
cannot reveal anything new w.r.t. exploring the space of the latter automata. The reason for restricting to the bagged case is 
that the spaces to explore are dramatically reduced (see Table 1), therefore, due to their manageable sizes, we could indeed 
carry out exhaustive analyses of bagged NCA spaces and detect a remarkable feature – the emergence of interacting particles 
– that we would have possibly missed if we attempted to address the astronomically huge spaces of non-bagged NCAs. In 
the rest of the paper we focus on the emergence of interacting particles in 1D bagged NCA with context diameters 3, 4 and 
5. Context diameter 4, although having a small number of possible rules (just 12!), already exhibits emergent behaviour that 
is peculiar of nominal computation, related to the identity of names, and “binding” of fresh names along the trajectory of 
particles (Section 7.2.1). Such phenomena are completely new in the spectrum of emergent behaviours of Cellular Automata, 
and illustrate well the potentiality of the nominal variant. Investigating diameter-5 bagged NCAs sheds further light on the 
comparison between bagged NCAs and totalistic CAs.
7.1. Diameter-3 bagged NCA
There are 6 elements in this class. Table 6 shows the three CBAS’s S3
i (i = 1, 2, 3) from contexts of diameter 3, the 
associated possible reactions and their count.
No interacting particles are found in this class. Incidentally, it is a trivial exercise to verify that Rule 0, with transition 
table {3 →⟨3⟩, 1.2 →⟨2⟩, 1.1.1 →n}, behaves exactly like ECA 150 whenever the initial array is binary (in which case the 
third rule component, corresponding to the bottom row in Table 6, is never used, and no new name is ever created).

T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
35
Table 6
Possible reactions for the CBAS’s from contexts of diameter 3. No-
tation ⟨x⟩denotes the name whose (unique) arity in the context is 
x. Letter n denotes a fresh name. The product of the numbers in 
the third column yields the bagged NCA space size 6.
i
S3
i
Possible reactions
γ (S3
i ) + 1
1
3
⟨3⟩|n
2
2
1.2
⟨1⟩|⟨2⟩|n
3
3
1.1.1
n
1
Fig. 7. The twelve bagged NCA with context diameter 4, from initial condition formed by a tuple of 0’s followed by a tuple of 1’s. Different names are 
assigned different grey levels, except for the special assignments: 0 →Blue, 1 →Red, and, limited to Rule 0: 177 →Yellow, 178 →Orange, 199 →Pink, 
200 →Purple. (For interpretation of the references to colour in this ﬁgure legend, the reader is referred to the web version of this article.)
Fig. 8. The twelve bagged NCA with context diameter 4, from initial condition formed by a 1 in a ﬁeld of 0’s. Different names are assigned different grey 
levels, except for the special assignments: 0 →Blue, 1 →Red. (For interpretation of the references to colour in this ﬁgure legend, the reader is referred to 
the web version of this article.)
7.2. Diameter-4 bagged NCA
Although this class consists of only 12 elements, we do ﬁnd interacting particles in it, as illustrated in Figs. 7 and 8.
From the elementary initial condition consisting of a tuple of 0’s followed by a tuple of 1’s (recall that we are using the 
circular boundary assumption) the 12 automata perform as illustrated in Fig. 7, where different grey levels correspond to 
different names, and some of the latter have been highlighted by using other colours. Furthermore, from the elementary 

36
T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
Table 7
Initial conditions generating particles R, L and S
under the context-3 bagged NCA Rule 0.
Particle
Init
R
n∗,a,b,a,a,n∗
L
n∗,c,c,d,c,n∗
S
n∗,e,n,e,n,e,n∗
Fig. 9. Particle R and L interactions for bagged NCA with context diameter 4, Rule 0. Different names are assigned different grey levels or different colours. 
(For interpretation of the references to colour in this ﬁgure, the reader is referred to the web version of this article.)
Fig. 10. Interactions of particle R (those for L are symmetric) with particle S for bagged NCA with context diameter 4, Rule 0. (For interpretation of the 
references to colour in this ﬁgure, the reader is referred to the web version of this article.)
initial condition consisting of a 1 in the middle of a ﬁeld of 0’s the 12 automata perform as illustrated in Fig. 8. Note that in 
plotting the diagrams of Figs. 7 and 8, and of subsequent analogous ﬁgures referring to diameter-4 automata, we employed 
a typical “normalisation” step, shifting by 1 cell every second row of the array, in order to eliminate the drift induced by 
the even number of cells in the context (which makes it impossible to pick a central one).
With respect to particles, the interesting rules have codes 0 and 4. In our numbering scheme, they correspond to the 
following transition tables, which differ only in one component:
Rule 0:
{4 →⟨4⟩, 1.3 →⟨1⟩, 2.2 →n, 1.1.2 →⟨2⟩, 1.1.1.1 →n}
Rule 4:
{4 →⟨4⟩, 1.3 →n, 2.2 →n, 1.1.2 →⟨2⟩, 1.1.1.1 →n}
The inspection of Figs. 7 and 8 reveals the existence of stationary particles, and of ones moving to the left and to the 
right.
7.2.1. Particles in Rule 0
It turns out that, when using the appropriate initial conditions, Rule 0 alone can produce both moving particles, called 
R (moving to the right) and L (moving to the left), and a stationary particle, called S.
The patterns creating R, L and S for Rule 0 are shown in Table 7, where symbol n denotes an ever fresh new name, n∗
denotes a sequence of mutually distinct new names, and a, b, c, d, e denote names different from any n, with a ̸= b and 
c ̸= d.
Particles R and L are illustrated in Fig. 9. They are symmetric and have period 1: they reproduce the initial blocks 
(a, b, a, a) or (c, c, d, c) at each row, with a shift to the right or to the left at every second step (taking into account the 
aforementioned normalisation). We shall refer to the three cells with name a (resp. c) as the external part of the R (resp. L) 
particle, and to the single cell b (resp. d) as the internal part. It turns out that when R and L collide, they annihilate each 
other regardless of whether the two external or internal names are equal or different, and regardless of the initial distance 
between them. This fact is illustrated in Fig. 9.

T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
37
Stationary particle S
is illustrated in Fig. 10. It has period 2, formed by the patterns (n∗, e, n, e, n, e, n∗) and 
(n∗, e, e, e, e, n∗). We remark that, unlike for R and L, the only constant name along the trajectory of S is e: the other 
“internal” cells exhibit ever changing names, as revealed by their grey levels in the diagram.
The interactions of particle R with particle S are illustrated in Fig. 10; those involving particles L and S are not shown, 
since they are exactly symmetric versions of these. Similar to the previous case, the outcome of these collision is indepen-
dent of the initial distance between the two particles but, unlike the previous case, it does depend on whether or not the 
external or internal part of the moving particle has the same colour as S. When the exterior of R has the same colour as S
(Fig. 10 – left), the moving particle reverses its direction, while the internal colour moves to the external part; furthermore, 
S itself turns into another L particle. The interaction between particles R and S in Rule 0 is the ﬁrst example that we 
encountered in NCA where name binding is an emergent behaviour, exhibiting the “nominal” capabilities of NCA. Particle 
R carries two names. Such names are just abstract mathematical entities. However, it is worth noting that in the tradition 
of nominal sets and nominal process calculi (e.g. the π-calculus [19]), names may have a context-dependent interpretation 
(see e.g., [8] for a mild introduction to the subject), such as the identity of a previous event in space-time, or of data items, 
or of communication channels, that is, unique labels for meaningful pieces of information. In NCAs, such meaning is not estab-
lished a priori, but would depend on the speciﬁc interpretation that one gives to the observed phenomena. Let us call the 
two names, carried by particle R, i (internal) and e (external). The computational role of particle R is that of a test, that 
checks whether information e is the same as a previously known one (the colour of R itself). If this is the case, not only e
is swapped with i, thus permitting i to be further tested, but in addition, name binding is observed. The leftmost freshly 
generated L particle carries, as its internal colour, a fresh name, which is unique, and witnesses the point in space-time 
where the interaction happened. Similarly, for the internal and external colours of the rightmost fresh L particle.
Remark 4. From the computational point of view, and in particular in the literature on process calculi, such kind of dynamic 
generation of identities is used for modelling causality (cf. [20,7]), or communication over dynamic networks [21], therefore, 
it is very relevant that particles carrying and manipulating fresh names exist in NCAs. Such particles (possibly in more 
complex forms than those we described above) provide basic building blocks enabling emergence of the same kinds of be-
haviours observed in process calculi (causality, communication, etc.), which is a novel development with respect to classical 
CAs. In order to make such intuition more precise, one could either ﬁnd an interesting combination of a rule and an initial 
condition having a behaviour that can be conﬁdently interpreted as, e.g., communication, or manually deﬁne a simulation 
of (a variant of) an existing process calculus, equipped with a mathematical correctness proof. The π-calculus [19] could be 
a good candidate for the latter, but one would be forced to use a variant that takes the spatial distribution of agents into 
account, as information travels at ﬁnite speed in cellular automata (and in the real world), whereas the π-calculus abstracts 
away from information speed concerns. We leave these developments for future research. As a starting point, we remark 
that no future particle may ever contain the same name that was freshly generated along the dynamics of an NCA, unless it 
is causally dependent from the interaction that generated it.
When it is the interior of R to share the colour with S (Fig. 10 – centre), the two particles jointly create a slightly 
displaced instance of S of that colour. Finally, when three distinct colours are involved, the outcome is an S particle adopting 
the external colour of R (Fig. 10 – right).
These two interactions also have a computational explanation. Particle S is again used as a test, to check this time 
whether the internal name of particle R is the same as a known one. No name binding happens in this case. Indeed, more 
complex combinations of binding and testing might be observed with larger context sizes; Rule 0 is seen as a witness of 
these capabilities, to be further explored in future work.
7.2.2. Particles in Rule 4
Starting from the same patterns used for Rule 0, Rule 4 can produce both stationary particle S and variants of the 
moving particles, that we call R∗and L∗. The latter differ from R and L in that the initial internal name is not preserved: 
it keeps changing along the trajectory (somewhat like in S). This halves the cases to be considered for collisions between 
the moving particles, that reduce to two cases: equal or different external names. As shown in Fig. 11, in the ﬁrst case the 
particles merge into a single S particle of the same colour, while in the second case they annihilate each other.
Fig. 12 shows the interactions of R∗and L∗with S. In all four cases the outcome is mutual annihilation.
Linear particles with similar shape to those just illustrated for NCAs (but indeed not exhibiting name binding) can be also 
be found in classical, totalistic CAs. In some cases we can indeed go as far as establishing a tight correspondence between 
a bagged NCA and a totalistic CA of the same context length. The following proposition states that the computations of the 
binary, totalistic CA with context length 4 and code 20, denoted totCA4
20, and those of the bagged NCA with equal context 
length and code 4, denoted bagNCA4
4, are essentially equivalent.
Proposition 3 Let f : {0, 1} →N be a pseudo-function from the set {0, 1} to the set of names, such that f (1) = 0 and 
f (0) = new, where new denotes a fresh natural number n > 0, that is, one that was never returned by previous ap-
plications of the function. The term pseudo-function refers to the fact that f has a memory: it picks elements from 
set N other than those it has already picked (using nominal sets, see Section 2, Deﬁnitions 3–4 on how to for-
malise such notion). Extend the applicability of f to bit strings: f (b1, ...bn) = ( f (b1) ... f (bn)), where bi ∈{0, 1}. 

38
T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
Fig. 11. Particle R∗and L∗interactions for bagged NCA with context diameter 4, Rule 4. Different names are assigned different grey levels or different 
colours. (For interpretation of the references to colour in this ﬁgure, the reader is referred to the web version of this article.)
Fig. 12. Particle R∗and L∗interactions with particle S for bagged NCA with context diameter 4, Rule 4. (For interpretation of the colours in this ﬁgure, the 
reader is referred to the web version of this article.)
Fig. 13. Computation of automaton totCA4
20 from a random binary string init, and the computation of automaton bagNCA4
4 from f (init). In the diagram at 
the right hand side, name 0 is represented in red, while all other names are represented by grey levels. (For interpretation of the references to colour in 
this ﬁgure legend, the reader is referred to the web version of this article.)
Let ﬁnally totCA4
20(bits) and bagNCA4
4(nats) denote the next row computed by automata totCA4
20 and bagNCA4
4 when 
started, respectively, from bit string bits and from the string nats of naturals. Then, for any bit string bits:
f (totCA4
20(bits)) ∼= bagNCA4
4( f (bits))
(3)
where symbol ∼= denotes that the two strings are equal in the nominal sense, that is, they share the same equality 
pattern.
Proof
Given that we are handling automata with context length 4, it is suﬃcient to show that the commutation ex-
pressed by equation (3) applies relative to bit quadruples. This is shown in Table 8 which is built using the rule 
components of the two automata, and function f . For automaton totCA4
20 the situation →reaction rule components 
are TOT →bit pairs, where TOT is the total of the bits in the context. They are:
totCA4
20: {4 →1, 3 →0, 2 →1, 1 →0, 0 →0}
(The ordered tuple of reactions above, (1, 0, 1, 0, 0), is the binary representation of the rule number – 20.) For 
automaton bagNCA4
4 the situation →reaction rule components, where the situation is represented by a CBAS, have 
been listed earlier in the present section.
The proof of equation (3) reduces to checking that columns 4 and 7 of the table are equal. ♦
Fig. 13 illustrates, on the left, a computation of automaton totCA4
20, starting from a random string of bits (init), and, on the 
right, the computation of automaton bagNCA4
4, starting from f (init). The two computations proceed in lockstep. Essentially, 

T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
39
Table 8
Situations and reactions for automata totCA4
20 and bagNCA4
4. Columns 4 and 7 are equal, indicating 
that the two automata proceed in lockstep.
Context
totCA4
20
bagNCA4
4
Situation
Reaction
f (reaction)
f (context)
Situation
Reaction
(1, 1, 1, 1)
4
1
0
(0, 0, 0, 0)
(4)
⟨4⟩= 0
(1, 1, 1, 0)
3
0
n
(0, 0, 0,n)
(1.3)
n
(1, 1, 0, 1)
3
0
n
(0, 0,n, 0)
(1.3)
n
(1, 1, 0, 0)
2
1
0
(0, 0,n,n′)
(1.1.2)
⟨2⟩= 0
(1, 0, 1, 1)
3
0
n
(0,n, 0, 0)
(1.3)
n
(1, 0, 1, 0)
2
1
0
(0,n, 0,n′)
(1.1.2)
⟨2⟩= 0
(1, 0, 0, 1)
2
1
0
(0,n,n′, 0)
(1.1.2)
⟨2⟩= 0
(1, 0, 0, 0)
1
0
n
(0,n,n′,n′′)
(1.1.1.1)
n
(0, 1, 1, 1)
3
0
n
(n, 0, 0, 0)
(1.3)
n
(0, 1, 1, 0)
2
1
0
(n, 0, 0,n′)
(1.1.2)
⟨2⟩= 0
(0, 1, 0, 1)
2
1
0
(n, 0,n′, 0)
(1.1.2)
⟨2⟩= 0
(0, 1, 0, 0)
1
0
n
(n, 0,n′,n′′)
(1.1.1.1)
n
(0, 0, 1, 1)
2
1
0
(n,n′, 0, 0)
(1.1.2)
⟨2⟩= 0
(0, 0, 1, 0)
1
0
n
(n,n′, 0,n′′)
(1.1.1.1)
n
(0, 0, 0, 1)
1
0
n
(n,n′,n′′, 0)
(1.1.1.1)
n
(0, 0, 0, 0)
0
0
n
(n,n′,n′′,n∗)
(1.1.1.1)
n
Table 9
Direct correspondences between totalistic binary CAs and multiple bagged NCAs, 
for context length 5. Due to the presence of rule components that are never used 
in the bagged NCA, when running on strings from a binary alphabet (“don’t care” 
conditions), there are 8 distinct bagged NCAs for each totalistic CA.
Context-5 totalistic binary CA
Directly equivalent context-5 NCA
38
0–7
42
8–15
52
24–31
56
32–39
in the computation of the totalistic CA, particles are patterns of 1’s (black) that move on a background of 0’s (white), while 
in the computation of the bagged NCA they are patterns of 0’s (in red) on a background of ever new names (grey levels).
It should be clear that while automaton bagNCA4
4 can reproduce all particle interaction scenarios exhibited by totCA4
20, 
the opposite is not true: the interactions between particles of different colours in the former (see Figs. 11 and 12) cannot 
of course be reproduced by the latter. For the same reasons, we cannot expect to be able to directly reproduce by binary, 
context-4 totalistic CAs the more sophisticated, multi-colour particle interaction patterns of context-4, bagged NCA Rule 0 
shown in Figs. 9 and 10.
Some remarks on the relevance of the above ﬁndings are presented in Section 8. The digital particles emerging in 
Nominal CA’s, as illustrated in Fig. 10, represent, in our opinion, a signiﬁcant departure from, and improvement of the 
information transmission capabilities of ordinary CA’s. While Turing completeness is achieved in both models, and forms 
of information transmission are possible in ordinary CA’s as well, the ability to encapsulate a speciﬁc name in a particle 
and transmit it across spacetime is a novel facility of NCA’s that may simplify the task of programming these automata for 
carrying out predeﬁned tasks. Further experimental work is necessary for assessing these potential advantages.
7.3. Diameter-5 bagged NCA
Further types of linear particle emerge in context-5 bagged NCA. Following the developments of the previous section, 
we shall introduce them as we discuss the relations between binary, context-5 totalistic CA (a class of 64 elements, see 
Table 2), and context-5 bagged NCA (a class of 144 elements, see Table 1).
A ﬁrst relationship between the two classes is found by requiring that the totalistic CA and the bagged NCA perform 
exactly the same computation when started from the same binary input string. It is easy to verify formally that 4 out of 
the 64 totalistic CA can be directly simulated by bagged NCAs. The proof requires considering the rule components (tran-
sition tables) of automata from the two classes, along the lines of the proof of Proposition 3, and is omitted. The exact 
correspondences among rule numbers are provided in Table 9.
Moving particles are found only in one of the cases considered in the table. Fig. 14 shows the computation of the 
binary, totalistic, context-5 CA automaton 52, denoted totCA5
52, from a random binary initial string, and the computation of 
context-5 bagged NCAs 24 to 31, from the same input.
Clearly visible at the right hand side of the diagrams is a complex particle with period 9, that shifts to the right by one 
cell at each period. Recall that the symmetry of totalistic CAs as well as bagged NCAs implies that each moving particle has 
a specular counterpart. We shall ﬁnd a genuinely nominal version of this particle in the sequel.

40
T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
Fig. 14. Computation of automaton totCA5
52 from a random binary string, and the computation of context-5 bagged NCAs 24 to 31, from the same input.
Fig. 15. Computation of automaton totCA5
20 from a random binary string init, and the computation of automaton bagNCA5
102 from f (init). In the diagram at 
the right hand side, name 0 is represented in red, while all other names are represented by grey levels. (For interpretation of the references to colour in 
this ﬁgure legend, the reader is referred to the web version of this article.)
Let us now consider a reﬁned relation between totalistic CAs and bagged NCAs that involves a conversion of the binary 
string before running the latter automaton, as done in Section 7.2.2. By adopting exactly the same pseudo-function f used 
therein, for the analogous relation among context-4 automata (Proposition 3), we can establish the following result:
Proposition 4 Let f : {0, 1} →N be the pseudo-function from the set {0, 1} to the set of naturals, such that f (1) = 0 and 
f (0) = new, where new denotes a fresh natural number n > 0 (the same function was used in Section 7.2.2, 
Proposition 3; we also use here the same notational conventions of that proposition). For any bit string bits:
f (totC A5
20(bits)) ∼= bagNCA5
102( f (bits))
(4)
where symbol ∼= denotes that the two strings are equal in the nominal sense, that is, they share the same equality 
pattern.
Proof
Omitted. (Analogous to the proof of Proposition 3.)
Fig. 15 illustrates, on the left, a computation of automaton totCA5
20, starting from a random string of bits (init), and, on the 
right, the computation of automaton bagNCA5
102, starting from f (init). The two computations proceed in lockstep. Again, in 
the computation of the totalistic CA, particles are patterns of 1’s (black) that move on a background of 0’s (white), while in 
the computation of the bagged NCA they are patterns of 0’s (in red) on a background of ever new names (grey levels).
The diagrams of Fig. 15 contain three periodic localised structures. Two of these particles are stationary, and one of these 
is particularly complex. The other particle is the announced genuinely nominal version of the particle already observed in 
Fig. 14.
8. Conclusions
In this paper, we explored the attractive topic of NCA particles. Several questions need to be addressed rigorously. The 
lesson from classical CAs suggests that, beside particles, other interesting emergent properties could be observed in ENCA 
and NCA computations, most notably fractals and pseudo-randomness. These features may also require re-deﬁnition, under 
the nominal perspective.
So far, the most remarkable property of NCA is the existence of particles that can capture a name on-the-ﬂy and carry it 
indeﬁnitely across spacetime, making it available for subsequent interactions. This feature is illustrated in Fig. 10. Consider 
the lower half of the leftmost diagram in that ﬁgure, where two parallel particles coloured in red and in three different 
shades of grey move to the left. The three distinct names corresponding to the three grey levels have been created at the 
location where the collision originating the particles has occurred. These names, jointly with the name represented by red 
cells in the diagram, travel across spacetime unaffected by the background of ever different names, until further interactions 
occur.
What type of computation can we carry out by this mechanism, and by the other features illustrated in Fig. 10? From 
an abstract point of view, one could look at “nominal Turing-completeness”. An NCA-based simulation of so-called Turing 

T. Bolognesi, V. Ciancia / Journal of Logical and Algebraic Methods in Programming 93 (2017) 23–41
41
machines with atoms [2] could be a possible future development in this direction. To clarify the expressive power of the 
model, future work could aim at mimicking the computational features of process calculi such as the π-calculus in NCAs, 
namely parallel composition of agents, communication via named channels, and fresh channel generation and transmission. 
Finally, as we already mentioned, causal dependencies are another interpretation of nominal phenomena. The presence of 
binding in particles makes causality observable, internally to the model, therefore permitting e.g. an entity to discriminate 
events based on the order in which they happened. This is indeed related to the big topic of causality in models of digital 
space-time, in which NCAs may ﬁnd useful applications in future work. Such developments may be highly non-trivial, and 
in this work we just paved the way for them to happen.4
In spite of the rich variety of nature-like phenomena that CAs exhibit, it is generally believed that such models have 
a stronger value as a metaphor for the computational universe, than as an actual, realistic candidate for a fundamental 
physical Theory of Everything. Then, a natural question would be how to transpose the powerful concepts of Nominal Set 
Theory and Nominal Computation to other, more attractive and realistic models of spacetime – notably graph-oriented 
models such as (algorithmic) causal sets [4,3]. A bridge between such models and NCAs may be provided by variants of 
nominal sets where the space of names is structured, e.g. by relations (therefore, graphs) or partial orders (see e.g. [1,6,22]). 
The importance that the permutation group plays both in nominal sets and in some approaches to the dynamics of causal 
sets appears to us as most encouraging for this extended investigation.
References
[1] Mikołaj Boja ´nczyk, Bartek Klin, Slawomir Lasota, Automata with group actions, in: LICS, IEEE Computer Society, 2011, pp. 355–364.
[2] Mikołaj Boja ´nczyk, Bartek Klin, Slawomir Lasota, Szymon Toru ´nczyk, Turing machines with atoms, in: LICS, IEEE Computer Society, 2013, pp. 183–192.
[3] Tommaso Bolognesi, Causal Sets from simple models of computation, Int. J. Unconv. Comput. 6 (6) (2010) 489–524, See also, arXiv:1004.3128 [.org/abs].
[4] Tommaso Bolognesi, Algorithmic causal sets for a computational spacetime, in: H. Zenil (Ed.), A Computable Universe, World Scientiﬁc, 2013.
[5] Tommaso Bolognesi, Vincenzo Ciancia, Nominal cellular automata, in: Proceedings 9th Interaction and Concurrency Experience, ICE, 2016, Heraklion, 
Greece, 8–9 June 2016, in: EPTCS, vol. 223, 2016, pp. 24–35.
[6] Filippo Bonchi, Maria Grazia Buscemi, Vincenzo Ciancia, Fabio Gadducci, A presheaf environment for the explicit fusion calculus, J. Autom. Reason. 
49 (2) (2012) 161–183, http://dx.doi.org/10.1007/s10817-011-9224-3.
[7] Roberto Bruni, Ugo Montanari, Matteo Sammartino, A coalgebraic semantics for causality in Petri nets, J. Log. Algebraic Methods Program. 84 (6) (2015) 
853–883, http://dx.doi.org/10.1016/j.jlamp.2015.07.003.
[8] Vincenzo Ciancia, From Urelements to Computation, Springer International Publishing, 2016, pp. 141–155.
[9] Vincenzo Ciancia, Ugo Montanari, Symmetries, local names and dynamic (de)-allocation of names, Inf. Comput. 208 (12) (2010) 1349–1367, 
http://dx.doi.org/10.1016/j.ic.2009.10.007.
[10] Matthew Cook, Universality in elementary cellular automata, Complex Syst. 15 (1) (2004) 1–40.
[11] Gilles Dowek, Murdoch James Gabbay, Permissive-nominal logic, in: International ACM SIGPLAN Conference on Principles and Practice of Declarative 
Programming, ACM, 2010, pp. 165–176.
[12] Gilles Dowek, Murdoch James Gabbay, Dominic P. Mulligan, Permissive nominal terms and their uniﬁcation: an inﬁnite, co-inﬁnite approach to nominal 
techniques, Log. J. IGPL 18 (6) (2010) 769–822, http://dx.doi.org/10.1093/jigpal/jzq006.
[13] Marcelo Fiore, Sam Staton, Comparing operational models of name-passing process calculi, Inf. Comput. 204 (4) (2006) 524–560, http://dx.
doi.org/10.1016/j.ic.2005.08.004.
[14] Murdoch Gabbay, Andrew M. Pitts, A new approach to abstract syntax involving binders, in: LICS, IEEE Computer Society, 1999, pp. 214–224.
[15] Murdoch James Gabbay, Vincenzo Ciancia, Freshness and name-restriction in sets of traces with names, in: FOSSACS, in: Lect. Notes Comput. Sci., 
vol. 6604, Springer, 2011, pp. 365–380.
[16] Fabio Gadducci, Marino Miculan, Ugo Montanari, About permutation algebras, (pre)sheaves and named sets, High.-Order Symb. Comput. 19 (2) (2006) 
283–304, http://dx.doi.org/10.1007/s10990-006-8749-3.
[17] Andrew Ilachinski, Cellular Automata – A Discrete Universe, World Scientiﬁc, 2001.
[18] Dexter Kozen, Konstantinos Mamouras, Daniela Petrisan, Alexandra Silva, Nominal Kleene coalgebra, in: ICALP, in: Lect. Notes Comput. Sci., vol. 9135, 
Springer, 2015, pp. 286–298.
[19] Robin Milner, Joachim Parrow, David Walker, A calculus of mobile processes, I, Inf. Comput. 100 (1) (1992) 1–40, http://dx.doi.org/10.1016/
0890-5401(92)90008-4, http://www.sciencedirect.com/science/article/pii/0890540192900084.
[20] Ugo Montanari, Marco Pistore, History dependent veriﬁcation for partial order systems, in: Partial Order Methods in Veriﬁcation, in: DIMACS Ser. 
Discret. Math. Theor. Comput. Sci., vol. 29, DIMACS/AMS, 1996, pp. 259–272.
[21] Ugo Montanari, Marco Pistore, pi-Calculus, structured coalgebras, and minimal HD-automata, in: MFCS, in: Lect. Notes Comput. Sci., vol. 1893, Springer, 
2000, pp. 569–578.
[22] Ugo Montanari, Matteo Sammartino, A network-conscious π-calculus and its coalgebraic semantics, Theor. Comput. Sci. 546 (2014) 188–224, http://dx.
doi.org/10.1016/j.tcs.2014.03.009.
[23] Andrew M. Pitts, Nominal Sets: Names and Symmetry in Computer Science, Cambridge University Press, New York, NY, USA, 2013.
[24] Stephen Wolfram, Cellular automata as models of complexity, Nature 311 (4) (1984) 419–424, http://dx.doi.org/10.1038/311419a0.
[25] Stephen Wolfram, A New Kind of Science, Wolfram Media, Inc., 2002.
[26] K. Zuse, Calculating Space, Technical Report, Proj, MAC, MIT, Cambridge, Mass. Technical Translation AZT-70-164-GEMIT. Original title: “Rechnender 
Raum”. 1970.
4 See also the experimental open-source NCA simulator available at https :/ /github .com /vincenzoml /neca.

