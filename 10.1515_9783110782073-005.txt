5 Computability
What is computability theory?
Computability theory arose from the concept of an algorithm. Computability theory, also
called recursion theory, is now a branch of mathematical logic that originated in the
1930s, before there were computers, with the study of computable functions and Turing
degrees. The field has grown to include the study of generalized computability and defin-
ability. For the computer scientist, computability theory shows that there is a theoretical
limit to what computer programs can actually do.
Let â„•= {0, 1, 2, 3, 4, . . . } be the set of natural numbers and let f be a function of the
form f : â„•â†’â„•. What does it mean to say that f is computable? One could say that f is
computable if there is an algorithm such that for each n âˆˆâ„•, the algorithm with input
n will produce the output f (n). This of course would require one to define the meaning
of an algorithm.
Questions
1.
Consider the function f : â„•â†’â„•defined by f (n) = n + 123,572. Is f computable?
2.
Consider the function f : â„•â†’â„•defined by f (n) = 7n. Is f computable?
3.
Consider the function f : â„•â†’â„•defined by f (n) = r, where r is the remainder
obtained after dividing n by 5. Is f computable?
4.
Suppose that the functions f : â„•â†’â„•and g: â„•â†’â„•are computable. Define the
function h: â„•â†’â„•by h(n) = f (n) + g(n). Is h computable?
5.
Are all functions of the form f : â„•â†’â„•computable?
6.
How many computable functions are there?
7.
Suppose that the function f : â„•â†’â„•is computable and suppose that a function
g: â„•â†’â„•satisfies g(n) < f (n) for all n âˆˆâ„•. Is g computable?
Is it possible to give a mathematically precise definition of a computable function? Yes!
Alan Turing was one of the first mathematicians to give such a definition.
5.1 The informal concept
Computability theory is the branch of mathematical logic that studies and identifies
problems that are computationally solvable using different models of computation.
A central question of computer science is to address the limits of computing devices by
understanding the problems that computers can solve. In this section we shall discuss
the basic concepts that appear in the theory of computation.
https://doi.org/10.1515/9783110782073-005

5.1 The informal concept
à±ª
149
5.1.1 Decidable sets
A function f : â„•k â†’â„•is computable if there is an effective (algorithmic) procedure that
can evaluate f , that is, given any input n1, . . . , nk of k natural numbers, the algorithm
will evaluate f (n1, . . . , nk).
In this section, we will use pseudocode to describe our algorithms and procedures.
As you may know, pseudocode is a compact and informal high-level description of an
algorithm. Programmers use pseudocode to develop their algorithms.
The first computability concept that we discuss is the concept of a decidable set.
A set is decidable if there is an effective procedure which will determine whether or not
any legitimate candidate is a member of the set. An effective procedure is an algorithm
that can be carried out by following the specific steps of an algorithm.
Definition 5.1.1. Given any set S of natural numbers, we will say that S is decidable if
there is an effective procedure such that whenever one applies the procedure to any
natural number n, the procedure will eventually end and respond â€œyesâ€ if n âˆˆS and
â€œnoâ€ if n âˆ‰S.
Definition 5.1.1 applies only to subsets of â„•, the set of natural numbers. This defini-
tion can be generalized to other sets as well.
Example 5.1.2. Let S = {n âˆˆâ„•: n is a prime number}. Show that S is decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
If n = à°·or n = à°¸, then let A=No.
If n > à°¸, then perform the following:
Let A=Yes.
For j = à°¹to n âˆ’à°¸;
If j | n, then let A=No.
End of For Loop
Return A
End of Procedure
The above algorithm is summarized as follows: Given a natural number n, if n â‰¤1,
then return No and halt. If n > 1, then search the numbers 2, 3, 4, . . . , n âˆ’1 for a number
j such that j | n (j evenly divides n). If you find one, then return No and halt. If you do
not find such a number, then return Yes and halt. We note that j | n if and only if n = jk
for some k âˆˆâ„•.
In every step of an effective procedure, one must be able to use an algorithm to
decide if a condition is true. Can the truth of the condition â€œj | nâ€ be checked by an
algorithm? One can effectively decide whether or not j | n holds by carrying out the
algorithm called long division. If the remainder is 0, then j | n. Otherwise, j âˆ¤n.

150
à±ª
5 Computability
Example 5.1.3. Let S = {n âˆˆâ„•: n = 7q + 3 for some natural number q}. Show that S is
decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
Perform long division by dividing n by à°¾.
If the remainder is 3, then return Yes.
If the remainder is not 3, then return No.
End of Procedure
In other words, given a number n, divide n by 7. If the remainder is 3, then return
Yes and halt. If the remainder is not 3, then return No and halt.
Example 5.1.4. Suppose that S âŠ†â„•is decidable. Show that â„•\ S is decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
Perform the procedure for deciding whether or not n âˆˆS.
If n âˆˆS, then return No.
If n âˆ‰S, then return Yes.
End of Procedure
That is, given n, using the decision procedure for S, check to see if n belongs to S or
not. If n âˆˆS, then return No and halt. If n âˆ‰S, then return Yes and halt.
Example 5.1.5. Let A âŠ†â„•and B âŠ†â„•be decidable. Show that A \ B is decidable.
Solution. Let n be a natural number. The procedure can be described as follows:
Begin Procedure
Perform the procedure for deciding whether or not n âˆˆA.
Perform the procedure for deciding whether or not n âˆˆB.
If n âˆˆA and n âˆ‰B, then return Yes.
If n âˆ‰A or n âˆˆB, then return No.
End of Procedure
Given n, using the decision procedure for A, check to see if n is a member of A or
not. Using the decision procedure for B, check to see if n belongs to B or not. If n âˆˆA and
n âˆ‰B, then return Yes and halt. If n âˆ‰A or n âˆˆB, then return No and halt.
Example 5.1.6. Let A âŠ†â„•be a finite set. Show that A is decidable.

5.1 The informal concept
à±ª
151
Solution. Let A = {k1, k2, . . . , kâ„“} and n âˆˆâ„•. The procedure is described as follows:
Begin Procedure
Let R=No.
If n = kà°¸, then let R=Yes.
If n = kà°¹, then let R=Yes.
...
If n = kâ„“, then let R=Yes.
Return R.
End of Procedure
That is, given n, check to see if n is in the finite list k1, k2, . . . , kâ„“or not. If n is not in
the list, then return No and halt. If n is in the list, then return Yes and halt.
The notion of an effective procedure is somewhat vague and we have not yet given
a precise mathematical definition. We will shortly be giving just such a definition. There
are at least two different but equivalent ways to define an effective procedure: Turing
machines and register machines. There is also a more mathematical way of defining
computable functions which involves the definition of partial recursive functions.
Are all subsets of â„•decidable? One can show that there are only countably many
effective procedures. Since ğ’«(â„•) (power set of â„•) is uncountable, it follows that the
majority of sets of natural numbers are not decidable.
5.1.2 Computable functions
Definition 5.1.7. Let k â‰¥1 be a natural number. A k-place total function has the form
f : â„•k â†’â„•and its domain is the entire set â„•k. A k-place partial function is a function
whose domain is a subset of â„•k and whose values are in â„•. A total function will also be
viewed as a partial function. The empty function is the partial function that is undefined
for every input. When we say that f : â„•k â†’â„•is a partial function, we mean that the
domain of f is a subset of â„•k.
Example 5.1.8. Define the 2-place total function f : â„•2 â†’â„•and the 2-place partial func-
tion g: â„•2 â†’â„•by
f (m, n) = {m âˆ’n,
if m â‰¥n,
0,
if m < n,
g(m, n) = {m âˆ’n,
if m â‰¥n,
â†‘,
if m < n,
where â†‘means that g(m, n) is undefined. So g(5, 2) is defined and (5, 2) is in the domain
of g; but g(2, 5) is undefined and thus, (2, 5) is not in the domain of g.

152
à±ª
5 Computability
We write âƒ—x âˆˆâ„•k to indicate that âƒ—x is a k-tuple of the form x1, . . . , xk or âŸ¨x1, . . . , xkâŸ©,
depending on the context.
Definition 5.1.9. Let f be a k-place partial function. The function f is effectively com-
putable if there exists an effective procedure that satisfies the following:
1.
Given a k-tuple âƒ—x in the domain of f , the procedure eventually halts and returns the
correct value for f ( âƒ—x).
2.
Given a k-tuple âƒ—x not in the domain of f , the procedure will not halt and thereby
will not return a value.
For example, the partial function for subtraction
g(m, n) = {m âˆ’n,
if m â‰¥n,
â†‘,
if m < n
is effectively computable because there is a procedure for subtracting natural numbers,
which we learned in elementary school. The procedure can be described as follows:
Begin Procedure
If m â‰¥n
compute r = m âˆ’n, return r and halt.
Else
Infinite Loop.
End of Procedure
An infinite loop is a procedure that does not terminate, that is, it runs forever. The
empty function is effectively computable by the following procedure:
Begin Procedure
Infinite Loop.
End of Procedure
The concept of a decidable set can now be described in terms of functions. Let
S âŠ†â„•k. We say that S is decidable if its characteristic function (which is total)
CS( âƒ—x) = {1,
if âƒ—x âˆˆS,
0,
if âƒ—x âˆ‰S
is effectively computable. Thus, S is decidable if its characteristic function CS is a com-
putable total function.

5.1 The informal concept
à±ª
153
Remark 5.1.10. If S âŠ†â„•k is decidable, we can use the computable total function CS to
construct another effectively computable partial function, namely, we can use the fact
that CS( âƒ—x) = 1 if âƒ—x is in S and CS( âƒ—x) = 0 if âƒ—x is not in S, for any âƒ—x âˆˆâ„•k.
Definition 5.1.11. A set S âŠ†â„•k is semi-decidable if its semi-characteristic function
cS( âƒ—x) = {1,
if âƒ—x âˆˆS,
â†‘,
if âƒ—x âˆ‰S
is an effectively computable partial function.
Remark 5.1.12. Thus, a set S is semi-decidable if there is an effective procedure so that
for any input âƒ—x âˆˆâ„•k the procedure will halt and return â€œyesâ€ if and only if âƒ—x âˆˆS. Thus,
if âƒ—x âˆ‰S, then the procedure will not halt (that is, cS( âƒ—x) is undefined).
Any decidable set is also semi-decidable; for example, suppose that S is a decidable
subset of â„•k. Then the following procedure shows that S is semi-decidable.
Begin Procedure
Run CS( âƒ—x)
If output = à°¸
return à°¸and halt.
Else
Infinite Loop.
End of Procedure
A universal 2-place partial function
Now, let us just consider those effective procedures that have only one natural num-
ber as input and return at most one natural number as output. Suppose that we have
adopted a fixed method of encoding each of these procedures P by a single natural num-
ber w. Suppose, further, that each such code w can be effectively decoded in such a way
to retrieve the program P (this can be done). Then the following 2-place â€œuniversal func-
tionâ€
Î¦(w, x) = the result of applying the procedure coded by w to the input x
is an effectively computable partial function. It is to be understood that Î¦(w, x) is unde-
fined (that is, does not halt) when the procedure coded by w fails to halt and return an
output.
Remark 5.1.13. We present an effective procedure that can be used to show that Î¦ is
effectively computable. The procedure has inputs w and x.

154
à±ª
5 Computability
Begin Procedure
Decode w into a procedure P.
If P is not a valid procedure, then infinite loop.
Execute procedure P with input x; set r = return value.
If r = empty
Infinite Loop.
Else
Return r and halt.
End of Procedure
The function Î¦ is not total for at least two reasons: Some natural numbers w will
not decode and produce a procedure. If w does decode into a valid procedure, then this
procedure may not yield an output. We shall write Î¦(w, x)â†“to mean that the procedure
in Remark 5.1.13 halts with inputs w and x and returns an output value. Thus, Î¦(w, x)â†“
means that the procedure coded by w with input x halts and returns an output value.
The notation Î¦(w, x)â†‘means that the procedure fails to halt.
Using the universal function Î¦ we can enumerate all of the 1-place effectively com-
putable partial functions. First, note that for any 1-place effectively computable partial
function f there is a natural number e that encodes the procedure for f . Thus,
f (x) = Î¦(e, x)
for all x âˆˆâ„•.
For this reason, we shall use the notation âŸ¦eâŸ§to denote the corresponding function f .
Hence, âŸ¦eâŸ§(x) = f (x) = Î¦(e, x) for all x âˆˆâ„•.
Thus, for any natural number e, we will now let âŸ¦eâŸ§be the partial computable func-
tion defined by âŸ¦eâŸ§(x) = Î¦(e, x). Of course, some natural numbers e may not code a
procedure and then âŸ¦eâŸ§may be the empty function. In any case, we can conclude that
every 1-place effectively computable partial function appears in the list
âŸ¦0âŸ§, âŸ¦1âŸ§, âŸ¦2âŸ§, âŸ¦3âŸ§, âŸ¦4âŸ§, . . . .
(5.1)
Since an effectively computable function can be computed by more than one procedure,
a computable function may have more than one representation in the list (5.1).
In computability theory, the halting problem can be stated as follows: Given a com-
puter program, decide whether the program will eventually halt when it is executed
with a given input or the program will run forever.
Definition 5.1.14 (Turing). Define the halting relation H on â„•by
âŸ¨w, xâŸ©âˆˆH
iff
âŸ¦wâŸ§(x)â†“,
where âŸ¦wâŸ§(x)â†“means that the procedure coded by w with input x halts and has an output
value.

5.1 The informal concept
à±ª
155
Of course, âŸ¦wâŸ§(x)â†“is equivalent to Î¦(w, x)â†“. Is the relation H decidable? Is there a
procedure that will determine whether or not a program coded by w with input x halts?
Alan Turing proved in 1936 that no such procedure exists.
Theorem 5.1.15 (Turing). The halting relation H is not decidable.
Proof. Suppose, to the contrary, that H is decidable. Thus, the characteristic function CH
defined by
CH(w, x) = {1,
if âŸ¨w, xâŸ©âˆˆH,
0,
if âŸ¨w, xâŸ©âˆ‰H
(5.2)
is effectively computable. Define the partial function f : â„•â†’â„•by
f (n) = {1,
if CH(n, n) = 0,
â†‘,
if CH(n, n) = 1.
(5.3)
It follows that f is an effectively computable partial function (see Remark 5.1.10). Thus,
there is a procedure P that evaluates f . So, if CH(n, n) = 1, then the procedure P with in-
put n, which attempts to evaluate f (n), will not halt. Since f is an effectively computable
partial function, there is a natural number e such that âŸ¦eâŸ§= f . There are two cases to
consider: Either CH(e, e) = 0 or CH(e, e) = 1.
Case 1. Suppose CH(e, e) = 0. Thus, f (e) = 1 and so âŸ¦eâŸ§(e) = 1. Hence, âŸ¨e, eâŸ©âˆˆH because
the procedure coded by e with input e halts. Therefore, (5.2) implies that CH(e, e) = 1,
which is a contradiction.
Case 2. Suppose CH(e, e) = 1. Thus, by (5.3), f (e) is undefined because the procedure that
attempts to evaluate f (e) does not halt. Since âŸ¦eâŸ§= f , we conclude that âŸ¦eâŸ§(e) does not
halt. Hence, CH(e, e) = 0, which is a contradiction.
Turingâ€™s proof presents an example of a diagonal argument, which was introduced
by Georg Cantor in 1873 to prove that the set of real numbers is uncountable.
Even though the halting relation is not decidable, it is semi-decidable as âŸ¨w, xâŸ©âˆˆH
if and only if Î¦(w, x)â†“. Thus, the semi-characteristic function cH satisfies
cH(w, x) = {1,
if âŸ¨w, xâŸ©âˆˆH,
â†‘,
if âŸ¨w, xâŸ©âˆ‰H
and is an effectively computable partial function. The following psuedocode offers an
effective procedure for evaluating cH(w, x) (see Remark 5.1.12 and Definition 5.1.9):

156
à±ª
5 Computability
Begin Procedure
Execute procedure Î¦(w, x).
Return à°¸and halt.
End of Procedure
Definition 5.1.16. Define the subset K on â„•by
K = {x âˆˆâ„•: Î¦(x, x)â†“} = {x âˆˆâ„•: âŸ¦xâŸ§(x)â†“}.
The set K is semi-decidable as the following procedure indicates:
Begin Procedure
Execute procedure Î¦(x, x).
Return à°¸and halt.
End of Procedure
Theorem 5.1.17 (Kleene). Let S be a subset of â„•k. Then S is decidable if and only if both S
and its complement S = â„•k \ S are semi-decidable.
Proof. Let S âŠ†â„•k.
(â‡’). Assume that S is decidable. Then, as we have seen before, S is semi-decidable be-
cause the following effective procedure applies:
Begin Procedure
Run CS( âƒ—x)
If output = à°¸
return à°¸and halt.
Else
Infinite Loop.
End of Procedure
By replacing â€œoutput = 1â€ in the above procedure with â€œoutput = 0,â€ we obtain an
effective procedure that shows that S is semi-decidable.
(â‡). Assume that S and S are semi-decidable. Thus, the partial functions cS and cS are
effectively computable. We shall prove that S is decidable, using a â€œsystem timerâ€ as
follows: Run the cS( âƒ—x)-procedure for one minute and then freeze it. Now, in another
part of executable memory, run the cS( âƒ—x)-procedure for one minute and then freeze it.
Now continue the cS( âƒ—x)-procedure for one minute and then freeze it, and then continue
the cS( âƒ—x)-procedure for one minute and then freeze it. Keep alternating this â€œsharing of

5.1 The informal concept
à±ª
157
system timeâ€ until one of the procedures halts and yields an output of 1. If cS( âƒ—x) = 1, then
return 1. If cS( âƒ—x) = 1, then return 0.
Theorem 5.1.18. Let k be a natural number.
1.
A k-place relation is semi-decidable if and only if the relation is the domain of some
effectively computable partial function.
2.
A partial function f is effectively computable if and only if {âŸ¨âƒ—x, yâŸ©: f ( âƒ—x) = y} is a
semi-decidable relation.
Proof. Let S âŠ†â„•k.
1.
We prove that a k-place relation is semi-decidable if and only if the relation is the
domain of some effectively computable partial function.
(â‡’). Suppose that S âŠ†â„•k is semi-decidable. Thus, by definition, the function cS is
an effectively computable function. Since
cS( âƒ—x) = {1,
if âƒ—x âˆˆS,
â†‘,
if âƒ—x âˆ‰S,
we see that S is the domain of some effectively computable partial function.
(â‡). Suppose that S âŠ†â„•k is the domain of some effectively computable partial
function, say f . We note that the following procedure evaluates cS:
Begin Procedure
Run f( âƒ—x).
Return à°¸and halt.
End of Procedure
Since the procedure f ( âƒ—x) halts if and only if âƒ—x âˆˆS, we conclude that cS is an effec-
tively computable function.
2.
We shall prove that a partial function f is effectively computable if and only if the
set G = {âŸ¨âƒ—x, yâŸ©: f ( âƒ—x) = y} is a semi-decidable relation.
(â‡’). Let f be effectively computable. Consider the following procedure with inputs
âƒ—x and y:
Begin Procedure
Run f( âƒ—x).
If output = y
Return à°¸and halt.
Else
Infinite Loop
End of Procedure

158
à±ª
5 Computability
Thus, the above effective procedure evaluates cG. Therefore, G is semi-decidable.
(â‡). Let G = {âŸ¨âƒ—x, yâŸ©: f ( âƒ—x) = y} be a semi-decidable relation and let cG be the semi-
characteristic function of G, which is a computable partial function. Given âƒ—x, execute
the following procedure:
Begin Procedure
Let n = à°·.
(L)
For j = à°·to n;
Run cG( âƒ—x, j) for n + à°¸minutes.
If cG( âƒ—x, j) has halted and cG( âƒ—x, j) = à°¸, then return j and go to (E).
End for Loop
Let n = n + à°¸and go to (L).
(E)
Halt (End of Procedure)
If f ( âƒ—x)â†“, then this procedure will eventually halt and return the value f ( âƒ—x). If f ( âƒ—x)â†‘,
then this procedure will not halt. Therefore, f is effectively computable.
Let us explain what the above procedure does. We know that G is semi-decidable.
Thus, there is a procedure P such that when given an input âŸ¨âƒ—x, yâŸ©, the procedure
will halt and return â€œyesâ€ if and only if âŸ¨âƒ—x, yâŸ©âˆˆG. We now try to compute f ( âƒ—x), if
it is defined. The plan is to use the procedure P to check âŸ¨âƒ—x, 0âŸ©, âŸ¨âƒ—x, 1âŸ©, âŸ¨âƒ—x, 2âŸ©, . . . for
membership in G. To do this, we must budget our time by using a method called
â€œdovetailing.â€ We execute the following steps:
(1) Spend 1 minute testing whether âŸ¨âƒ—x, 0âŸ©is in G.
(2) Spend 2 minutes each on âŸ¨âƒ—x, 0âŸ©and âŸ¨âƒ—x, 1âŸ©testing for membership in G.
(3) Spend 3 minutes each on âŸ¨âƒ—x, 0âŸ©, âŸ¨âƒ—x, 1âŸ©, âŸ¨âƒ—x, 2âŸ©testing for membership in G.
...
...
If at a step we find an âŸ¨âƒ—x, kâŸ©âˆˆG, then we return the value k and halt. If f ( âƒ—x)â†“, then
this process will eventually halt and return the correct value for f ( âƒ—x). On the other
hand, if f ( âƒ—x)â†‘, then this process will not halt, that is, the process will run forever.
Therefore, the partial function f is effectively computable.
Exercises 5.1.
1. Let A âŠ†â„•and B âŠ†â„•be decidable. Show that A âˆ©B is decidable, that is, let n âˆˆâ„•
and identify an effective procedure that decides whether or not n âˆˆA âˆ©B.
2. Let A and B be decidable subsets of â„•. Show that A âˆªB is decidable.
3. Let A and B be semi-decidable subsets of â„•. Show that A âˆ©B is semi-decidable.
4. Let A and B be semi-decidable subsets of â„•. Show that A âˆªB is semi-decidable.
5. Let R âŠ†â„•2 be a decidable relation. Show that the set {x : âŸ¨x, iâŸ©âˆˆâ„}, domain of R,
is semi-decidable. (Review the proof of Theorem 5.1.18(2).)
6. Suppose that f : â„•â†’â„•is a computable partial function. Show that the domain of
f , {x âˆˆâ„•: f (x)â†“}, is semi-decidable.

5.2 Formalizationsâ€”an overview
à±ª
159
7. Let f : â„•â†’â„•be a total computable function. Show that the range {f (x) : x âˆˆâ„•} is
semi-decidable.
5.2 Formalizationsâ€”an overview
In the preceding section, we used the term â€œeffectively computableâ€ to refer to an in-
tuitive notion of an effective (algorithmic) procedure. In this section we present an
overview of three different (but equivalent) methods that allow one to replace the no-
tion of effectively computable with one that is mathematically precise. One of these
methods will be developed in more detail in Sections 5.3 and 5.4. It is important to
emphasize that these three approaches are equivalent (see Theorems 5.2.20 and 5.2.11).
5.2.1 Turing machines
A Turing machine is a device that manipulates symbols on a tape according to a set of
instructions. Despite its simplicity, a Turing machine can be adapted to simulate the logic
of any computer algorithm. The Turing machine is not intended as a practical method for
implementing algorithms, but rather as a hypothetical device representing a computing
machine. Turing machines help computer scientists understand the limits of mechanical
computation.
A Turing machine has a potentially infinite tape, marked into squares and a tape
head which has an arrow pointing at the square on the tape that is currently being ad-
dressed. Each square can hold a symbol or a blank space. The symbols must be taken
from a given alphabet Î£. Initially, the tape contains only the input string (word) and is
blank everywhere else (see Figure 5.1).
Figure 5.1: A tape with an input string from the alphabet Î£ = {a, t, 3}.
A Turing machine instruction commands the machine to perform the simple steps
indicated below:
(a) read the tape square under the tape head,
(b) write a symbol on the tape in that square,
(c) move the tape head to the left or right, and
(d) proceed to a new instruction.
Steps (b) through (d) all depend upon what symbol appears on the tape square being
scanned before the instruction is executed. The machine can be in any one of finitely

160
à±ª
5 Computability
many â€œstatesâ€ q1, q2, . . . , qr. A machine instruction has the form âŸ¨state, read, write, move,
next-stateâŸ©. A program for a Turing machine consists of a finite set of Turing machine
instructions.
Words and alphabets
Consider the set consisting of the English alphabet {a, b, c, d, . . . , x, y, z}. A finite string
or word over this alphabet is a string of letters; for example, aaactu and zadw are two
strings (words) of letters over the English alphabet.
We will now consider more general alphabets. Let Î£ be a finite set of symbols. Then
Î£âˆ—is the set of all words over the alphabet Î£ (including the empty word Î»). For example,
let Î£ = {1, b, c}. Then
Î£âˆ—= {Î», 1, a, b, 1a, a1, bbb, abcabc, . . . }.
We shall denote the â€œemptyâ€ word with the symbol Î», and this symbol is not allowed to
occur in any alphabet.
Turing machine instructions
An instruction has the form âŸ¨qi, Sj, Sk, D, qmâŸ©, where qi is the current state, Sj and Sk are
symbols in Î£ (the given alphabet), D is either R or L (right or left), and qm is the next
state. If the machine is in state qi, then the instruction âŸ¨qi, Sj, Sk, D, qmâŸ©tells the machine
to look at the square currently under the tape head (the arrow) and do the following (in
order):
1.
If the square contains symbol Sj, then replace it with the symbol Sk.
2.
If D = R, then move the tape head to the next square on the right; if D = L, then
move the tape head to the next square on the left.
3.
Go into state qm.
4.
Let S be the current symbol in the square under the tape head.
5.
Now execute the instruction that has state qm and symbol S as its first two compo-
nents. If there is no such instruction, then halt!
We will not allow the symbol B to be used in any alphabet. The capital letter B will
be used to represent a â€œblankâ€ symbol (that is, an empty square). Thus, an instruction
âŸ¨qi, Sj, B, D, qmâŸ©means to â€œeraseâ€ symbol Sj and the instruction âŸ¨qi, B, Sk, D, qmâŸ©means
that if the square is blank, then write the given symbol Sk into this square. A Turing
machine cannot have two different instructions that have the same first two components.
Suppose that we are working in the two-letter alphabet Î£ = {a, b} and we want to
write a Turing machine that takes a word in this alphabet as input and will append the
letter a to each such word (on the right). For example, if the tape has the initial input
abb, then after running the machine the tape should have the output abba. Figure 5.2
illustrates another example. Such a Turing machine is given in Example 5.2.1 below.

5.2 Formalizationsâ€”an overview
à±ª
161
Figure 5.2: The Turing input and output.
Example 5.2.1. Let Î£ = {a, b} be a two-letter alphabet. We will present a Turing ma-
chine M which consists of six instructions with just three states q1, q2, q3, where q1 is
designated as being the initial state. The state q3 will be the halt state, that is, the ma-
chine will stop operating. When we start this machine in state q1 it will scan the first
letter and then will eventually append the letter a to the word on the right. We show in
Figure 5.3 how this machine executes the program on the input word ab. The box above
the tape head identifies the â€œcurrentâ€ state of the machine. We have
âŸ¨q1, a, a, R, q1âŸ©
âŸ¨q1, b, b, R, q1âŸ©
âŸ¨q1, B, a, L, q2âŸ©
âŸ¨q2, a, a, L, q2âŸ©
âŸ¨q2, b, b, L, q2âŸ©
âŸ¨q2, B, B, R, q3âŸ©.
(M)
Example 5.2.2. Let Î£ = {a, b} be a two-letter alphabet. Let f : Î£âˆ—â†’Î£âˆ—be the 1-place
function defined by f (w) = wa, where w âˆˆÎ£âˆ—is any word in the alphabet Î£. The machine
M in Example 5.2.1 computes the total function f . So we can say that the function f is
Turing computable. Note that f (Î») = a, where Î» is the empty word.
Now suppose that Î£ is a finite alphabet (the blank B does not count as a member
of Î£). Let Î£âˆ—be the set of all words over this alphabet (that is, Î£âˆ—is the set of all finite
strings, including the empty string, consisting of members of Î£).
Definition 5.2.3. Suppose that f is a k-place partial function from (Î£âˆ—)k into Î£âˆ—. We will
say that f is Turing computable if there exists a Turing machine M that, when started
in its initial state scanning the first symbol of a k-tuple
âƒ—w of words (written on the tape,
with a blank square between words, and with the rest of the tape blank), behaves as
follows:
1.
If f ( âƒ—w)â†“(i. e., âƒ—w is in the domain of f ), then M eventually halts and returns the value
f ( âƒ—w), which is the word on the tape whose first letter is under the tape head and
whose last letter is followed by a blank square.
2.
If f ( âƒ—w)â†‘(i. e.,
âƒ—w is not in the domain of f ), then M never halts.

162
à±ª
5 Computability
Figure 5.3: The machine runs with input ab and halts with output aba.
Turing developed these ideas prior to the introduction of modern digital computers.
After World War II, Turing played an active role in the development of early comput-
ers and in the emerging field of artificial intelligence. During the war, he also worked
on deciphering the German battlefield code Enigma, which was militarily important
work that remained classified until after Turingâ€™s death. Turingâ€™s remarkable contribu-
tions to the war effort have been celebrated in recent years. However, before his death,
Turing was persecuted by the English judicial system on account of his sexual orienta-
tion.
Turing computability of functions on â„•k
The definition of Turing computability can be adapted to k-place functions on â„•. One
way to do this is to use the single-letter alphabet Î£ = {1} and represent the natural num-
bers 0, 1, 2, 3, 4, . . . as follows: 1, 11, 111, 1111, 11111, . . . . Thus, the 3-tuple âŸ¨3, 0, 5âŸ©would be
represented on a Turing tape as

5.2 Formalizationsâ€”an overview
à±ª
163
1 1 1 1
1
1 1 1 1 1 1 .
It turns out that every computable function (like the ones in Section 5.1.2) on the nat-
ural numbers is Turing computable. For example, the function f (m, n) = mn is Turing
computable. Thus, there is a Turing machine such that when given the input âŸ¨m, nâŸ©, the
machine will halt with the output mn. For example, if this machine were given the input
âŸ¨3, 4âŸ©represented on the tape as
1 1 1 1
1 1 1 1 1 ,
then the machine would halt with the output
1 1 1 1 1 1 1 1 1 1 1 1 1 ,
which represents 12.
5.2.2 Register machines
In theoretical computer science a register machine is an abstract machine that is used in
a manner similar to that of a Turing machine. Furthermore, every Turing computable
function on the natural numbers can be computed by a register machine and vice
versa.
A register machine is a conceptual computing device with a finite number of regis-
ters, numbered 0, 1, 2, . . . , K. Each register is capable of storing a natural number of any
magnitudeâ€”there is no limit to the size of this number. The operation of the machine
is determined by a program. A program is a finite sequence of instructions, drawn from
the following list:
â€“
I r (where 0 â‰¤r â‰¤K). â€œIncrement r.â€ This instruction results in an increase of the
contents of register r by 1. The machine then proceeds to the next instruction in the
program (if any).
â€“
D r (where 0 â‰¤r â‰¤K). â€œDecrement r.â€ The effect of this instruction depends on
the number in register r. If that number is nonzero, it is decreased by 1 and the
machine proceeds not to the next instruction, but to the following one. However, if
the number in register r is zero, then the machine proceeds to the next instruction.
In other words, the machine attempts to decrement register r and if it is successful,
then it skips one instruction.
â€“
J q (where q is an integerâ€”positive, negative, or zero). â€œJump q.â€ All registers remain
unchanged. The machine takes as its next instruction the q-th instruction following
this one (if q â‰¥0) or the |q|-th instruction preceding this one (if q < 0). The machine
halts if there is no such instruction in the program. Thus, the instruction J 0 results
in an infinite loop, by repeating this one instruction over and over again.

164
à±ª
5 Computability
This programming language has only these three types of instructions. (Strictly speak-
ing, in these instructions, r and q are numerals, not numbers, that is, an instruction
should be a sequence of symbols. If we use base-10 numerals, then the alphabet is
I, D, J, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, âˆ’. An instruction is a correctly formed word over this alpha-
bet.) A register program will halt when the machine cannot find the â€œnextâ€ instruction.
Example 5.2.4 (CLEAR 7). Consider the following program, called â€œCLEAR 7,â€ which will
replace the contents of register 7 with the number 0. The comments (on the right) are
added to explain the individual steps in the program.
D
7
Try to decrement register 7.
J
2
Halt when zero.
J
âˆ’à°¹
Go back and repeat.
The program has three instructions and halts by seeking a fourth instruction. In
addition, we can replace 7 with any register number and obtain a program that will
clear that particular register, for example, the following program CLEAR 3 will clear
register 3.
D
3
J
2
J
âˆ’à°¹
Example 5.2.5 (MOVE r to s). Let r and s be different register numbers. Consider the fol-
lowing program, called â€œMOVE r to s,â€ which will move the number in register r into
register s. This program â€œcallsâ€ on the CLEAR program.
CLEAR
s
Ensure that register s is set to zero.
D
r
Decrement register r.
J
3
Halt when zero.
I
s
Increment register s.
J
âˆ’à°º
Go back and repeat.
The above program leaves a zero in register r and contains seven instructions. The
program halts by seeking an eighth instruction.
Example 5.2.6 (ADD 1 to 2 and 3). Consider the following program, called â€œADD 1 to 2
and 3,â€ which will add the number in register 1 to the numbers in register 2 and regis-
ter 3.

5.2 Formalizationsâ€”an overview
à±ª
165
D
1
Decrement register 1.
J
4
Halt when zero.
I
2
Increment register 2.
I
3
Increment register 3.
J
âˆ’à°»
Go back and repeat.
This program leaves a zero in register 1. Moreover, the program has five instructions
and halts by seeking a sixth instruction. It is clear how to adapt this program to add any
register to one or more registers.
Example 5.2.7 (COPY from r to s (using t)). Consider the following program, called â€œCOPY
from r to s (using t),â€ which copies the number in register r to register s (leaving register
r unchanged). The program â€œcallsâ€ on the programs CLEAR, MOVE, and ADD.
CLEAR
s
Set register s to zero.
MOVE
r to t
ADD
t to r and s
When this program terminates, register r contains the same value as it did when
the program began. The program contains 15 instructions and halts by seeking a 16th
instruction.
Example 5.2.8. Let R0, R1, R2, R3 denote registers 0, 1, 2, and 3. Suppose that x and y
are in registers 1 and 2. The following program will put the sum x + y in register 0. The
comments on the right depict the register contents at each step of the program.
Rà°·
Rà°¸
Rà°¹
Rà°º
CLEAR
0
à°·
x
y
MOVE
1 to 3
à°·
0
y
x
ADD
3 to 1 and 0
x
x
y
0
MOVE
2 to 3
x
x
0
y
ADD
3 to 2 and 0
x + y
x
y
0
At the end of this program, registers 1 and 2 contain the same value as they did
when the program began. The program has 27 instructions and halts by seeking a 28th
instruction.
Definition 5.2.9. Suppose that f : â„•n
â†’
â„•is an n-place partial function. Then f
is register-machine computable if there exists a register program P that, whenever
âƒ—x = âŸ¨x1, x2, . . . , xnâŸ©and x1 is in register 1, x2 is in register 2, . . . , xn is in register n, and 0
is in the other registers, behaves as follows:

166
à±ª
5 Computability
1.
If f ( âƒ—x)â†“(i. e., âƒ—x is in the domain of f ), then P eventually halts and returns the value
f ( âƒ—x) in register 0. Furthermore, the program halts by seeking a (p + 1)st instruction
when the program P contains p instructions.
2.
If f ( âƒ—x)â†‘(i. e., âƒ—x is not in the domain of f ), then P never halts.
Example 5.2.10. Let f : â„•2 â†’â„•be defined by f (x, y) = x + y. Example 5.2.8 shows that f
is register-machine computable.
Theorem 5.2.11. Let f : â„•2 â†’â„•be a partial function. Then f is Turing computable if and
only if f is register-machine computable.
5.2.3 Primitive recursiveness and partial search
For a third formalization of the computability concept, we will define a certain class of
partial functions on â„•to be the smallest class that contains a few simple functions and is
also closed under certain constructions that generate more complicated functions. This
particular formalization requires no particular type of computing device.
For the initial functions, we take the following very simple total functions:
â€“
For each k â‰¥0, the zero function ÌŠf : â„•k â†’â„•defined by the equation
ÌŠf (x1, . . . , xk) = 0
is an initial function. The constant 0 is viewed as a 0-place initial function.
â€“
The successor function S: â„•â†’â„•defined by the equation
S(x) = x + 1
is an initial function.
â€“
For all natural numbers 1 â‰¤i â‰¤k, the projection function Ik
i : â„•k â†’â„•defined by
the equation
Ik
i (x1, . . . , xk) = xi
is an initial function. The function Ik
i just selects the i-th component as its value.
We next identify two ways to generate new functions from the initial functions and those
that have already been constructed. Recall that when f : â„•â†’â„•and g: â„•â†’â„•, we can
construct the composite function (f âˆ˜g): â„•â†’â„•defined by
(f âˆ˜g)(n) = f (g(n))
for all n âˆˆâ„•. We will generalize this operation in our next definition.

5.2 Formalizationsâ€”an overview
à±ª
167
Definition 5.2.12. Let n â‰¥1 and k â‰¥1. Suppose that f : â„•n â†’â„•and gi: â„•k â†’â„•for each
i = 1, 2, . . . , n. Then we can define the function h: â„•k â†’â„•by composition as follows:
h( âƒ—x) = f (g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x)).
In Definition 5.2.12, if f and g1, g2, . . . , gn are partial functions, then h( âƒ—x) is defined if
and only if g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x) and f (g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x)) are all defined.
Example 5.2.13. Let n = 3, let k = 2, let f : â„•3 â†’â„•be defined by f (a, b, c) = ab + c, and
let g1(x, y) = 2x, g2(x, y) = 2y, and g3(x, y) = x + y. Then
h(x, y) = f (g1(x, y), g2(x, y), g3(x, y)) = f (2x, 2y, x + y)
= (2x)(2y) + (x + y) = 4xy + x + y.
Another method that we will use to generate functions is called primitive recursion.
Recall (Section 1.1.4) that if we have a function g: â„•â†’â„•and an element a âˆˆâ„•, then
we can define a function h: â„•â†’â„•by the following recursion:
1.
h(0) = a,
2.
h(n + 1) = g(h(n)), for all n âˆˆâ„•.
We will now generalize this definition.
Definition 5.2.14. Let k â‰¥1 and suppose that f : â„•k â†’â„•and g: â„•k+2 â†’â„•. Then we
can define a function h: â„•k+1 â†’â„•by the following primitive recursion:
(1) h( âƒ—x, 0) = f ( âƒ—x),
(2) h( âƒ—x, n + 1) = g(h( âƒ—x, n), âƒ—x, n), for all n âˆˆâ„•.
In Definition 5.2.14, if f and g are partial functions, then h( âƒ—x, n + 1) is defined if
and only if h( âƒ—x, n) and g(h( âƒ—x, n), âƒ—x, n) are both defined. Furthermore, the function h is
uniquely defined by the above conditions (1) and (2). In fact, Theorem 1.1.27 implies that
the function h exists and is unique.
Example 5.2.15. Let k = 2. Let f : â„•2 â†’â„•be defined by f (a, b) = (a+1)b and g: â„•4 â†’â„•
be defined by g(w, x, y, z) = wx + yz. Then we can define a function h: â„•3 â†’â„•by the
following primitive recursion:
(1) h(x, y, 0) = f (x, y) = (x + 1)y,
(2) h(x, y, n + 1) = g(h(x, y, n), x, y, n), for all n âˆˆâ„•.
Since we have the value h(x, y, 0), we can evaluate h(x, y, 1) as follows:
h(x, y, 1) = g(h(x, y, 0), x, y, 0) = g((x + 1)y, x, y, 0) = (x + 1)yx + y â‹…0 = (x2 + x)y.
Now that we have the value h(x, y, 1), we can evaluate h(x, y, 2) as follows:

168
à±ª
5 Computability
h(x, y, 2) = g(h(x, y, 1), x, y, 1) = g((x2 + x)y, x, y, 1) = (x3 + x2)y + y â‹…1 = (x3 + x2 + 1)y.
Continuing in this manner we can evaluate h(x, y, n) for any natural number n.
Now that we have the initial functions and two methods of producing functions, we
can define the smallest set that contains the initial functions and all the functions that
can be generated from the initial functions using composition and primitive recursion.
Definition 5.2.16. A function f : â„•k â†’â„•is said to be primitive recursive if f can be con-
structed starting with the zero, successor, and projection functions using composition
and primitive recursion.
Thus, if the functions f : â„•n â†’â„•and gi: â„•k â†’â„•for each i = 1, 2, . . . , n are primitive
recursive, then function h: â„•k â†’â„•defined by the composition
h( âƒ—x) = f (g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x))
is also primitive recursive. Furthermore, if f : â„•k â†’â„•and g: â„•k+2 â†’â„•are primitive
recursive, the function h: â„•k+1 â†’â„•that satisfies
(1) h( âƒ—x, 0) = f ( âƒ—x),
(2) h( âƒ—x, n + 1) = g(h( âƒ—x, n), âƒ—x, n), for all n âˆˆâ„•,
is also primitive recursive.
Again, the collection of all primitive recursive functions is the smallest set that
contains the initial functions and is closed under composition and primitive recursion.
Thus, the collection of primitive recursive functions is the smallest set ğ’that contains
the zero, successor, and projection functions and whenever a function f is constructed
from functions in ğ’using composition or primitive recursion, f is also in ğ’.
Example 5.2.17. Show that the function h: â„•3 â†’â„•that satisfies
(1) h(x, y, 0) = y,
(2) h(x, y, n + 1) = h(x, y, n) + 2, for all n âˆˆâ„•,
is primitive recursive.
Solution. According to Definition 5.2.14, we need to find primitive recursive functions
f and g that satisfy:
(a) h(x, y, 0) = f (x, y), where f is a 2-place function,
(b) h(x, y, n + 1) = g(h(x, y, n), x, y, n), for all n âˆˆâ„•, where g is a 4-place function.
The function h has two parts of its definition, namely (1) and (2). We will find the func-
tions f and g by using the following tree to show how h is built up from certain primitive
recursive functions. The left branch below focuses on part (1) of the definition of h and
the right branch addresses part (2) of this definition.

5.2 Formalizationsâ€”an overview
à±ª
169
h
h(x, y, 0) = y
= I2
2(x, y)
= f (x, y)
w = h(x, y, n)
h(x, y, n + 1) = w + 2
= (w + 1) + 1
= S(w) + 1
= S(S(w))
= S(S(I4
1 (w, x, y, n)))
= g(w, x, y, n)
The function f defined by f (x, y) = I2
2(x, y) is an initial function, so f is primitive recur-
sive. The function g defined by g(w, x, y, n) = S(S(I4
1 (w, x, y, n))) is primitive recursive
because g is the result of composing initial functions. Thus, h is a primitive recursive
function.
We note that every primitive recursive function is a total function. This is because
the initial functions are all total, the composition of total functions is total, and a function
obtained by primitive recursion from total functions is also total.
We will show in Section 5.3 that many of the common functions on â„•are primitive
recursive. For example, we shall show that the operations of addition and multiplication
on the natural numbers are primitive recursive.
It seems clear that every primitive recursive function should be regarded as be-
ing effectively computable. The initial functions are computable and the composition of
computable functions produces a computable function. Whenever h is obtained by prim-
itive recursion from computable functions f and g, then it is easy to see how one can ef-
fectively find h( âƒ—x, 99), by first finding h( âƒ—x, 0) and then working oneâ€™s way up as in Exam-
ple 5.2.15. Therefore, h is computable. However, in order to generate all of the effectively
computable functions on the natural numbers, we need to have one more operation.
Before we formally identify this new operation, we begin with a motivating discussion.
Let us take a function g(x, y). Let x âˆˆâ„•and suppose there is at least one value of y
which makes g(x, y) = 0 and we want to find the least value of y for which g(x, y) = 0.
There is an effective method for doing this. We know that y is a natural number. We
first set y = 0 and then compute g(x, y); if we get 0 we stop, because we have found
the least y such that g(x, y) = 0; but if not, we try the next natural number 1. We try
y = 0, 1, 2, 3 . . . until we reach the first value such that g(x, y) = 0. Then we define h(x) =
y and thereby get a new function. When we know that there is such a value, then this
method will terminate in a finite amount of time with the correct answer. Moreover, if
h(x) is a function that computes the least y such that g(x, y) = 0, then h is computable.
We will say that h is produced from g by minimization.
However, we do not always know that there is a y where g(x, y) = 0. Hence the
project of testing y = 0, 1, 2, 3, . . . may never terminate. If we run the test anyway, which

170
à±ª
5 Computability
is called unbounded minimization, we will get h to be a partial function. For this reason,
we will refer to unbounded minimization as partial search because such searches may
not be successful and thus can produce a partial function.
Since we will be working with partial functions, we will use the notation h( âƒ—x)â†“to
indicate that the function h is defined at âƒ—x, and we will write h( âƒ—x)â†‘when h is undefined
at âƒ—x. Moreover, when we say that h: â„•k â†’â„•is a partial function, we mean that the
domain of h may be a proper subset of â„•k. We now introduce the Î¼-operator, which
searches for the least natural number that yields a functional value of 0.
Definition 5.2.18. Let g be a (k+1)-place function on â„•. We say that the k-place function
h is obtained (constructed) from g by partial search if h satisfies
h( âƒ—x) = Î¼y(g( âƒ—x, y) = 0),
that is, for each âƒ—x âˆˆâ„•k, we have h( âƒ—x)â†“and h( âƒ—x) = y if and only if y satisfies the following
two conditions:
1.
g( âƒ—x, y)â†“and g( âƒ—x, y) = 0,
2.
g( âƒ—x, s)â†“and g( âƒ—x, s) > 0 for all s < y.
When the function g in Definition 5.2.18 is effectively computable, then so is h be-
cause we can evaluate h( âƒ—x) by investigating the values g( âƒ—x, 0), g( âƒ—x, 1), . . . , g( âƒ—x, i) (in this
order) until we find the first solution y to the equation g( âƒ—x, y) = 0. If there is no such y,
then the search will never end.
Using the initial functions and the operations of composition, primitive recursion,
and partial search, we can now define a class of functions that includes the primitive
recursive functions.
Definition 5.2.19. A function is partial recursive if it can be generated by starting with
the initial functions and using the operations of composition, primitive recursion, and
partial search.
The collection of partial recursive functions is the smallest set that contains the ini-
tial functions and is closed under composition, primitive recursion, and partial search.
Such functions can be partial functions, because the operation of partial search can pro-
duce partial functions. However, the expression â€œpartial recursiveâ€ is an inseparable
phrase, that is, it should be thought of as â€œpartial-recursive.â€
In Section 5.2.1, we said that a partial function f : â„•k â†’â„•is Turing computable
when there is a Turing machine that will evaluate f . Thus, the definition of a Turing
computable function is very different from the definition of a partial recursive function.
Is there a connection between these two dissimilar ways of defining functions? Alan
Turing was the first to prove the following striking result.
Theorem 5.2.20 (Turing). Let f : â„•k â†’â„•be a partial function. Then f is partial recursive
if and only if f is Turing computable.

5.2 Formalizationsâ€”an overview
à±ª
171
There are mathematically formal definitions of a function being Turing computable,
register-machine computable, and partial recursive. All three of these computational
processes are equivalent, that is, all three approaches define the same class of functions.
However, we have not given a formal definition of a function being computable. This is
because the notion of being computable is intuitive and consequently cannot be given a
precise formal definition. A thesis identified by Alonzo Church and Alan Turing relates
the informal idea of being computable to the formal ideas presented in this section. It is
an observation that has been verified by very strong evidence.
Church-Turing Thesis. Let f be a partial function on the natural numbers. Then the fol-
lowing are equivalent:
â€“
f is computable;
â€“
f is Turing computable;
â€“
f is register-machine computable;
â€“
f is partial recursive.
Exercises 5.2.
1. Let Î£ = {a, b} be a two-letter alphabet. Let f : Î£âˆ—â†’Î£âˆ—be the 1-place Turing com-
putable function defined by the Turing machine (TM), where q1 is the initial state.
Evaluate f (aabb), f (aba), and f (bbaa). We have
âŸ¨q1, a, b, R, q2âŸ©
âŸ¨q1, b, a, R, q2âŸ©
âŸ¨q1, B, a, R, q2âŸ©
âŸ¨q2, a, b, L, q3âŸ©
âŸ¨q2, b, a, R, q2âŸ©
âŸ¨q2, B, a, L, q3âŸ©.
(TM)
2. Let Î£ = {a, b} be a two-letter alphabet. Let f : Î£âˆ—â†’Î£âˆ—be the 1-place function defined
by f (w) = wbb for all w âˆˆÎ£âˆ—. Show that the function f is Turing computable. Then
verify that your machine, when given the input ab, will produce abbb as its output.
3. Let Î£ = {a, b} be a two-letter alphabet. Let f : Î£âˆ—â†’Î£âˆ—be the 1-place function that
will switch the first letter of every nonempty word in Î£âˆ—to the â€œotherâ€ letter. For
example, f (aabb) = babb and f (bbb) = abb. Show that f is Turing computable. Then
verify that your machine, when given the input aab, will produce bab as its output.
4. Let Î£ = {a, b} be a two-letter alphabet. Let f : Î£âˆ—â†’Î£âˆ—be the 1-place function that
will take any nonempty word in Î£âˆ—and change every occurrence of the letter a in
the word to the letter b and will not change any occurrence of letter b in the word.
For example, f (aaba) = bbbb and f (baa) = bbb. Show that f is Turing computable.
Then verify that your machine, when given the input aab, will produce bbb as its
output.
5. Give a register-machine program that computes f (x, y) = max{x âˆ’y, 0}.
6. Give a register-machine program that computes f (x, y) = x â‹…y.

172
à±ª
5 Computability
7. Give a register-machine program that computes f (x, y) = max{x, y}.
8. Let h: â„•4 â†’â„•, f : â„•â†’â„•, g: â„•â†’â„•be primitive recursive functions. Using
Definitions 5.2.12 and 5.2.16, show that the function k(x, y, z) = h(f (x), z, g(y), 2) is
primitive recursive.
9. Show that function p defined by (a) and (b) below is a primitive recursive function:
(a) p(m, 0) = m,
(b) p(m, n + 1) = p(m, n) + 1.
Prove that p(m, n) = m + n by induction on n.
10. Show that function h defined by (a) and (b) below is a primitive recursive function:
(a) h(m, 0) = 0,
(b) h(m, n + 1) = h(m, n) + m.
Prove that h(m, n) = mn by induction on n.
Exercise Notes: For Exercise 5, x is in register 1 and y is in register 2. Now move
register 1 into register 0. Keep decrementing registers 2 and 0 until register 2 contains 0.
For Exercise 6, x is in register 1 and y is in register 2. Register 0 initially contains the value
0. Copy register 1 into register 3. Each time you can decrement register 2, add register 3
to register 0 and then copy register 1 into register 3. For Exercise 7, x is in register 1
and y is in register 2. Copy registers 1 and 2 into registers 3 and 4, respectively. Start
decrementing registers 1 and 2. The first such register who gets to 0 had the smallest
initial value.
5.3 Recursive functions
In the previous section, we discovered that the concept of a computable function on the
natural numbers has several equivalent definitions (there are more). In this section, we
will focus our attention on the class of functions that are recursive. Recursive functions
include the primitive recursive functions and are closed under a search operation sim-
ilar to that of partial search (see Definition 5.2.18).
Recalling Definition 5.2.16, a function f from â„•k to â„•is primitive recursive if it can
be constructed starting with the zero, successor, and projection functions using com-
position and primitive recursion. Primitive recursion and composition are the key op-
erations that are used to build the primitive recursive functions. Primitive recursive
functions are the computable functions that form an important building block on the
way to capture all of the computable functions. Most of the functions normally studied
in number theory are primitive recursive; for example, addition, division, factorial, ex-
ponentiation, and the n-th prime are all primitive recursive functions. Let us revisit the
initial functions that were introduced in Section 5.2.3 and the operations of composition
and primitive recursion.

5.3 Recursive functions
à±ª
173
Definition 5.3.1. The initial functions are defined as follows:
â€“
For each k â‰¥0, the zero function ÌŠf : â„•k â†’â„•is defined by ÌŠf (x1, . . . , xk) = 0. The
constant 0 is viewed as a 0-place zero function.
â€“
The successor function S: â„•â†’â„•is defined by S(x) = x + 1.
â€“
For all 1 â‰¤i â‰¤k, the projection function Ik
i : â„•k â†’â„•is defined by the equation
Ik
i (x1, . . . , xk) = xi.
Definition 5.3.2. Let n â‰¥1 and k â‰¥1. Suppose that f : â„•n â†’â„•and gi: â„•k â†’â„•for each
i = 1, 2, . . . , n. We can then form the composite function h: â„•k â†’â„•, which is defined by
h( âƒ—x) = f (g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x)).
The composition
h( âƒ—x) = f (g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x))
can be illustrated as a tree with a vertex having (n + 1) branches:
h
f
g1
g2
â‹…â‹…â‹…
gn
Here, f must be an n-place function and g1, . . . , gn must all have the same number of
places as the function h.
The projection functions can be used to avoid the apparent rigidity in terms of the
arity of the functions used in composition. By using compositions with various projec-
tion functions, it is possible to pass a subset of the arguments of one function to another
function. For example, if g and h are 2-place functions, then the function
f (a, b, c) = g(h(c, a), h(a, b))
can be obtained by a composition of projection functions, namely,
f (a, b, c) = g(h(I3
3(a, b, c), I3
1 (a, b, c)), h(I3
1 (a, b, c), I3
2(a, b, c))).
Definition 5.3.3. Let k â‰¥1 and suppose that f : â„•k â†’â„•and g: â„•k+2 â†’â„•. Then we can
define a function h: â„•k+1 â†’â„•by the following primitive recursion:
(1) h( âƒ—x, 0) = f ( âƒ—x),
(2) h( âƒ—x, n + 1) = g(h( âƒ—x, n), âƒ—x, n), for all n âˆˆâ„•.
We note that Theorem 1.1.27 implies that the function h in Definition 5.3.3 exists and
is unique. The construction of this function h from the functions f and g is illustrated
by the following tree, where the left branch illustrates the â€œbase stepâ€ (1) and the right
branch illustrates the â€œinductive stepâ€ (2).

174
à±ª
5 Computability
h
h( âƒ—x, 0) = f ( âƒ—x)
w = h( âƒ—x, n)
h( âƒ—x, n + 1) = g(w, âƒ—x, n)
Note that g must have two more places than f and one more place than h. For example, if
h is a 2-place function, then g must be a 3-place function and f must be a 1-place function.
Definition 5.3.4. A function f from â„•k to â„•is primitive recursive if it can be constructed
starting with the zero, successor, and/or projection functions using composition and/or
primitive recursion.
Recall that the operation of partial search may not be successful. Consequently, this
operation can produce a partial function. The set of recursive functions is obtained by
requiring an additional closure condition which is a modification of the partial search
operation. This modification, when applicable, will always produce a total function.
Definition 5.3.5. Let g: â„•k+1 â†’â„•be a total function. Suppose that for all
âƒ—x âˆˆâ„•k,
there is a y âˆˆâ„•such that g( âƒ—x, y) = 0. We say that the k-place function h is obtained
(constructed) from g by total search if h satisfies
h( âƒ—x) = Î¼y(g( âƒ—x, y) = 0),
that is,
h( âƒ—x) = the least y such that g( âƒ—x, y) = 0.
Definition 5.3.6. A function f from â„•k to â„•is recursive if it can be constructed start-
ing with the zero, successor, and/or projection functions using composition, primitive
recursion, and/or total search.
We observe that every recursive function is a total function. Moreover, every prim-
itive recursive function is a recursive function, and every recursive function is a partial
recursive function. We note that there are recursive functions that are not primitive re-
cursive, and there are partial recursive functions that are not recursive. In Chapter 6,
we will show that there is a close relationship between deductions in number theory
and recursive functions.
The set of recursive functions can be defined by recursion (see Section 1.1.5). Let B
be the set that consists of the zero, successor, and projection functions. Let â„±be the set of
operations that correspond to composition, primitive recursion, and total search. Then,
as in Theorem 1.1.24, we can inductively define the sets of functions:
(1) C0 = B,
(2) Cn+1 = Cn âˆªâ„±[Cn], for all n âˆˆâ„•.

5.3 Recursive functions
à±ª
175
Then C = â‹ƒnâˆˆâ„•Cn is the set of all the recursive functions. Moreover, if a set contains
the zero, successor, and projection functions and is closed under composition, primitive
recursion, and total search, then the set contains all of the recursive functions.
We will now begin to show that many of the functions on the natural numbers that
we use in mathematics are (primitive) recursive. Each function that we construct can
be used to construct additional (primitive) recursive functions.
Proposition 5.3.7. The addition function h(x, y) = x + y is primitive recursive.
Proof. Observe that:
â€“
x + 0 = x,
â€“
x + (n + 1) = (x + n) + 1, for all n âˆˆâ„•.
Thus, letting h(x, y) = x + y, we have:
â€“
h(x, 0) = x,
â€“
h(x, n + 1) = h(x, n) + 1, for all n âˆˆâ„•.
We will now show that h is primitive recursive. We must find primitive recursive func-
tions f and g that satisfy Definition 5.3.3:
(1) h(x, 0) = f (x), where f is a 1-place function,
(2) h(x, n + 1) = g(h(x, n), x, n), for all n âˆˆâ„•, where g is a 3-place function.
The function h has two parts of its definition, namely items (1) and (2). We will find the
two functions f and g by using the following tree to show how h is built up from certain
primitive recursive functions. The left branch focuses on part (1) of the definition of h
and the right branch addresses part (2) of this definition.
h
h(x, 0) = x
= I1
1(x)
w = h(x, n)
h(x, n + 1) = w + 1
= S(w)
= S(I3
1 (w, x, n))
The desired function f is f (x) = I1
1(x), which is an initial function and therefore prim-
itive recursive. The desired function g is g(w, x, n) = S(I3
1 (w, x, n)), which is primitive
recursive because it is the result of composing initial functions. Hence, h is a primitive
recursive function.
The symbol â€œó³¨ƒâ†’â€ is read as â€œmaps to.â€ This symbol gives us an easier way to identify
a function. The notation âŸ¨x, yâŸ©ó³¨ƒâ†’x + y indicates that the function is a 2-place function
with input âŸ¨x, yâŸ©and output x + y.

176
à±ª
5 Computability
Proposition 5.3.8. Let k âˆˆâ„•. The constant function âƒ—x ó³¨ƒâ†’k is primitive recursive.
Let k âˆˆâ„•. The constant function âƒ—x ó³¨ƒâ†’k is primitive recursive because it is the
result of composing initial functions. For example, suppose k = 3 and let h(x, y, z, w) = 3.
Observe that
h(x, y, z, w) = 3 = S(S(S(0))) = S3(0) = S3( ÌŠf (x, y, z, w)),
where ÌŠf is the 4-place zero function. Since h is the composition of initial functions, it is
primitive recursive. For k â‰¥1 we shall let kf denote the constant function kf ( âƒ—x) = k, for
all âƒ—x âˆˆâ„•k. The constant i = Si(0) shall be viewed as a 0-place constant function.
Proposition 5.3.9. The multiplication function âŸ¨x, yâŸ©ó³¨ƒâ†’x Ã— y is primitive recursive.
Proof. We note that:
(1) x Ã— 0 = 0,
(2) x Ã— (n + 1) = (x Ã— n) + x, for all n âˆˆâ„•.
We will find the functions f and g by using the following tree to show how h is built up
from certain primitive recursive functions. The following left branch focuses on part (1)
of the definition of h and the right branch addresses part (2) of this definition.
h
h(x, 0) = 0
= ÌŠf (x)
w = h(x, n)
h(x, n + 1) = w + x
= I3
1 (w, x, n) + I3
2(w, x, n)
The desired function f is f (x) = ÌŠf (x), the zero function which is primitive recursive. The
desired function g is g(w, x, n) = I3
1 (w, x, n) + I3
2(w, x, n), which is primitive recursive
because addition is primitive recursive. Therefore, h is primitive recursive.
Since the function h(x, y) = x Ã— y is primitive recursive, we see that
h(I2
1 (x, y), I2
1 (x, y)) = x Ã— x = x2,
h(3f (x, y), I2
1 (x, y)) = 3 Ã— x = 3x
are primitive recursive. Propositions 5.3.7, 5.3.8, and 5.3.9 imply that any polynomial
function with coefficients from â„•is primitive recursive. Thus, p(z, y, z) = 3xy8 + z2 is
primitive recursive.
Remark 5.3.10. Given any (primitive) recursive function f , we can define another func-
tion by replacing any of the variables in f with constants or by interchanging and/or

5.3 Recursive functions
à±ª
177
repeating the variables of f . The new function will then be (primitive) recursive. This
follows by composing f with the appropriate projection and constant functions.
Proposition 5.3.11. The exponentiation function âŸ¨x, yâŸ©ó³¨ƒâ†’xy is primitive recursive.
Proof. Since
â€“
x0 = 1,
â€“
xn+1 = xn Ã— x for all n âˆˆâ„•,
one can now show, in a manner similar to that in the proof of Proposition 5.3.9, that
exponentiation is primitive recursive.
The exponentiation function âŸ¨x, yâŸ©ó³¨ƒâ†’yx is also primitive recursive. This is estab-
lished by composing certain projection functions with the primitive recursive function
in Proposition 5.3.11; namely, let h(x, y) = xy. Define the function g by
g(x, y) = h(I2
2(x, y), I2
1 (x, y)) = h(y, x) = yx.
Since g is constructed by composing primitive recursive functions, it follows that g is
primitive recursive. Since h(3, 4)
Ì¸= g(3, 4), xy and yx are different functions.
Proposition 5.3.12. The factorial function x ó³¨ƒâ†’x! is primitive recursive.
Proof. We have:
â€“
0! = 1,
â€“
(n + 1)! = n! Ã— (n + 1), for all n âˆˆâ„•.
Thus, letting h(x) = x!, we see that:
â€“
h(0) = 1,
â€“
h(n + 1) = h(n) Ã— (n + 1), for all n âˆˆâ„•.
The following tree shows that h is primitive recursive.
h
h(0) = 1
w = h(n)
h(n + 1) = w Ã— (n + 1)
= w Ã— S(n)
= I2
1 (w, n) Ã— S(I2
2(w, n))
Here, 1 is a 0-place primitive recursive function and g(w, n) = I2
1 (w, n) Ã— S(I2
2(w, n)) is a
2-place primitive recursive function.

178
à±ª
5 Computability
Proposition 5.3.13. The predecessor function pred(x) = x âˆ’1 (where pred(0) = 0) is
primitive recursive.
Proof. We have:
â€“
pred(0) = 0,
â€“
pred(n + 1) = n, for all n âˆˆâ„•.
Thus, letting h(x) = pred(x), we see that:
â€“
h(0) = 0,
â€“
h(n + 1) = n, for all n âˆˆâ„•.
The following tree shows that h is primitive recursive.
h
h(0) = 0
w = h(n)
h(n + 1) = n
= I2
2(w, n)
Here, 0 is a 0-place primitive recursive function and g(w, n) = I2
2(w, n) is a 2-place prim-
itive recursive function.
Proposition 5.3.14. The proper subtraction function x
âˆ˜âˆ’y is primitive recursive, where
x âˆ˜âˆ’y is defined by x âˆ˜âˆ’y = max{x âˆ’y, 0}.
Proof. To see this, observe that:
â€“
x âˆ˜âˆ’0 = x,
â€“
x âˆ˜âˆ’(n + 1) = pred(x âˆ˜âˆ’n), for all n âˆˆâ„•.
Thus, letting h(x, y) = x âˆ˜âˆ’y, we see that:
â€“
h(x, 0) = x,
â€“
h(x, n + 1) = pred(h(x, n)), for all n âˆˆâ„•.
The following tree shows that h is primitive recursive.
h
h(x, 0) = x
= I1
1(x)
w = h(x, n)
h(x, n + 1) = pred(w)
= pred(I3
1 (w, x, n))

5.3 Recursive functions
à±ª
179
Here, I1
1 is a 1-place projection function and g(w, x, n) = pred(I3
1 (w, x, n)) is a 3-place
primitive recursive function.
We are now ready to show that bounded sums and products are recursive. First,
we review summation and product notation. Let f : â„•â†’â„•and n âˆˆâ„•. The summation
notation âˆ‘t<n f (t) and the product notation âˆt<n f (t) are defined as follows:
âˆ‘
t<n
f (t) = f (0) + f (1) + f (2) + â‹…â‹…â‹…+ f (n âˆ’1),
âˆ
t<n
f (t) = f (0) Ã— f (1) Ã— f (2) Ã— â‹…â‹…â‹…Ã— f (n âˆ’1),
where âˆ‘t<0 f (t) = 0 and âˆt<0 f (t) = 1. Observe that
âˆ‘
t<(n+1)
f (t) = (âˆ‘
t<n
f (t)) + f (n)
and
âˆ
t<(n+1)
f (t) = (âˆ
t<n
f (t)) Ã— f (n).
Proposition 5.3.15. Suppose that f : â„•k+1 â†’â„•is (primitive) recursive. Then the summa-
tion function s and the product function p defined by
s( âƒ—x, y) = âˆ‘
t<y
f ( âƒ—x, t)
and
p( âƒ—x, y) = âˆ
t<y
f ( âƒ—x, t)
are (primitive) recursive.
Proof. Since addition and multiplication are primitive recursive, the functions s and p
are defined, respectively, by primitive recursion as follows:
(1) s( âƒ—x, 0) = 0,
(2) s( âƒ—x, n + 1) = s( âƒ—x, n) + f ( âƒ—x, n), for all n âˆˆâ„•;
(1) p( âƒ—x, 0) = 1
(2) p( âƒ—x, n + 1) = p( âƒ—x, n) Ã— f ( âƒ—x, n), for all n âˆˆâ„•.
Proposition 5.3.16. Define the function z by
z(x) = {1,
if x = 0,
0,
if x > 0.
Then z is primitive recursive.
Proof. We have z(x) = 1 âˆ˜âˆ’x, and 1 âˆ˜âˆ’x is primitive recursive (see Remark 5.3.10). To see
why z(x) = 1 âˆ˜âˆ’x, observe that:
â€“
z(x) = 1 if and only if x = 0 if and only if 1 âˆ˜âˆ’x = 1,
â€“
z(x) = 0 if and only if x > 0 if and only if 1 âˆ˜âˆ’x = 0.
Another way to show that z is primitive recursive is to observe that:

180
à±ª
5 Computability
(1) z(0) = 1,
(2) z(n + 1) = 0, for all n âˆˆâ„•.
Thus, one can define z by primitive recursion as illustrated in the following tree.
z
z(0) = 1
w = z(n)
z(n + 1) = 0
= ÌŠf (w, n)
Here, 1 is a 0-place constant function and ÌŠf (w, n) is the 2-place zero function.
Proposition 5.3.17. Define the function h by
h(x, y) = {1,
if x â‰¤y,
0,
if x > y.
(5.4)
Then h is primitive recursive.
Proof. Clearly the function z(x âˆ˜âˆ’y) is the composition of primitive recursive functions.
To see that h(x, y) = z(x âˆ˜âˆ’y) satisfies (5.4), note that:
â€“
h(x, y) = 1 if and only if x â‰¤y if and only if x âˆ˜âˆ’y = 0 if and only if z(x âˆ˜âˆ’y) = 1,
â€“
h(x, y) = 0 if and only if x > y if and only if x âˆ˜âˆ’y > 0 if and only if z(x âˆ˜âˆ’y) = 0.
Thus, the function defined by (5.4) is primitive recursive.
We have been building recursive functions. We can thus build a recursive relation
by using its characteristic function.
Definition 5.3.18. Let k â‰¥1. We say that a k-place relation R on â„•is (primitive) recur-
sive if its characteristic function is (primitive) recursive.
In other words, a k-place relation R on â„•is (primitive) recursive if the function
CR(x1, x2, . . . , xk) = {1,
if âŸ¨x1, x2, . . . , xkâŸ©âˆˆR,
0,
if âŸ¨x1, x2, . . . , xkâŸ©âˆ‰R
is (primitive) recursive. Thus, Proposition 5.3.17 shows that the 2-place relation
{âŸ¨x, yâŸ©: x â‰¤y}
is primitive recursive. Proposition 5.3.16 shows that the set {0} is primitive recursive.

5.3 Recursive functions
à±ª
181
Given an n-place (primitive) recursive relation R and n k-place (primitive) recursive
functions g1, g2, . . . , gn, we can define the k-place relation Q by
Q = { âƒ—x : âŸ¨g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x)âŸ©âˆˆR}.
Since the characteristic function for Q is equal to the composition
CQ( âƒ—x) = CR(g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x)),
it follows that the relation Q is also (primitive) recursive. This observation shall be re-
ferred to as the substitution rule.
For any n-place relation R on â„•, we shall write R( âƒ—x) to mean âƒ—x âˆˆR. Thus, the substi-
tution rule states that if R is (primitive) recursive and g1, g2, . . . , gn are k-place (primitive)
recursive functions, then a relation Q that satisfies
Q( âƒ—x)
if and only if
R(g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x))
(5.5)
is also (primitive) recursive.
Proposition 5.3.19. Show that the relation {âŸ¨x, yâŸ©: x â‰¥y} is primitive recursive.
Proof. Let Q = {âŸ¨x, yâŸ©: x â‰¥y}. We know by Proposition 5.3.17 that â‰¤is primitive recur-
sive. Recall that x â‰¥y if and only if y â‰¤x. Since
Q(x, y)
if and only if
I2
2(x, y) â‰¤I2
1 (x, y),
the substitution rule implies that the relation Q is primitive recursive.
Example 5.3.20. Show that the relation {âŸ¨x, yâŸ©: x â‰¤y + 1} is primitive recursive.
Solution. Let Q be the relation {âŸ¨x, yâŸ©: x â‰¤y + 1}. We know that â‰¤is primitive recursive
by Proposition 5.3.17. Since the successor function S(y) = y+1 is primitive recursive and
Q(x, y)
iff
x â‰¤S(y)
iff
I2
1 (x, y) â‰¤S(I2
2(x, y)),
the substitution rule implies that the relation {âŸ¨x, yâŸ©: x â‰¤y + 1} is primitive recursive.
From two k-place relations R and Q on â„•, we define the following three new rela-
tions:
â€“
R = { âƒ—x âˆˆâ„•k : not R( âƒ—x)},
â€“
R âˆ©Q = { âƒ—x âˆˆâ„•k : R( âƒ—x) and Q( âƒ—x)},
â€“
R âˆªQ = { âƒ—x âˆˆâ„•k : R( âƒ—x) or Q( âƒ—x)}.

182
à±ª
5 Computability
The relation R is called the complement of R and satisfies R( âƒ—x) if and only if âƒ—x âˆ‰R. The
relation R âˆ©Q is the intersection of R and Q, and the relation R âˆªQ is the union of the
relations R and Q.
Theorem 5.3.21. Suppose that R and Q are k-place (primitive) recursive relations. Then
the following relations are also (primitive) recursive:
1.
R = { âƒ—x âˆˆâ„•k : not R( âƒ—x)},
2.
R âˆ©Q = { âƒ—x âˆˆâ„•k : R( âƒ—x) and Q( âƒ—x)},
3.
R âˆªQ = { âƒ—x âˆˆâ„•k : R( âƒ—x) or Q( âƒ—x)}.
Proof. Let CR and CQ be the respective characteristic functions of the relations R and Q.
Assuming that CR and CQ are (primitive) recursive, we shall show that the relations R,
R âˆ©Q, and R âˆªQ are also (primitive) recursive.
1.
First we show that CR( âƒ—x) = z(CR( âƒ—x)). Observe that
CR( âƒ—x) = 1
iff
CR( âƒ—x) = 0
iff
z(CR( âƒ—x)) = 1.
Furthermore,
CR( âƒ—x) = 0
iff
CR( âƒ—x) = 1
iff
z(CR( âƒ—x)) = 0.
Thus, CR( âƒ—x) = z(CR( âƒ—x)), which is a composition of (primitive) recursive functions.
Hence, R is a (primitive) recursive relation.
2.
One can easily check that CRâˆ©Q( âƒ—x) = CR( âƒ—x) Ã— CQ( âƒ—x), which is a composition of (prim-
itive) recursive functions. Hence, R âˆ©Q is a (primitive) recursive relation.
3.
First we show that CRâˆªQ( âƒ—x) = 1 âˆ˜âˆ’z(CR( âƒ—x) + CQ( âƒ—x)). Note that
CRâˆªQ( âƒ—x) = 1
iff
CR( âƒ—x) + CQ( âƒ—x) â‰¥1
iff
z(CR( âƒ—x) + CQ( âƒ—x)) = 0
iff
1 âˆ˜âˆ’z(CR( âƒ—x) + CQ( âƒ—x)) = 1.
Moreover,
CRâˆªQ( âƒ—x) = 0
iff
CR( âƒ—x) + CQ( âƒ—x) = 0
iff
z(CR( âƒ—x) + CQ( âƒ—x)) = 1
iff
1 âˆ˜âˆ’z(CR( âƒ—x) + CQ( âƒ—x)) = 0.
Thus, CRâˆªQ( âƒ—x) = 1 âˆ˜âˆ’z(CR( âƒ—x)+CQ( âƒ—x)), a composition of (primitive) recursive functions.
Therefore, R âˆªQ is a (primitive) recursive relation.

5.3 Recursive functions
à±ª
183
By a pertinent application of the projection functions, Theorem 5.3.21 implies that
the conjunction and disjunction of any two (primitive) recursive relations are also
(primitive) recursive. For example, if R(x, y) and S(y, z) are recursive, then the rela-
tion P(x, y, z) defined by â€œR(x, y) and S(y, z)â€ is also recursive.
From Theorem 5.3.21(2)(3), using a proof by induction, one can now show that any
finite intersection or union of recursive sets is also recursive.
Corollary 5.3.22. Let n âˆˆâ„•and suppose that R1, R2, . . . , Rn are k-place (primitive) recur-
sive relations. Then
â‹‚
1â‰¤iâ‰¤n
Ri
and
â‹ƒ
1â‰¤iâ‰¤n
Ri
are (primitive) recursive.
We now apply Theorem 5.3.21 to show that the relations <, >, and = are primitive
recursive.
Proposition 5.3.23. The following relations are primitive recursive:
1.
{âŸ¨x, yâŸ©: x < y},
2.
{âŸ¨x, yâŸ©: x > y},
3.
{âŸ¨x, yâŸ©: x = y}.
Proof. We show that the relations are primitive recursive as follows:
1.
Theorem 5.3.21(1) implies that {âŸ¨x, yâŸ©: x < y} is primitive recursive, since < is the
complement of the relation â‰¥, which is primitive recursive by Proposition 5.3.19.
2.
Theorem 5.3.21(1) implies that {âŸ¨x, yâŸ©: x > y} is primitive recursive, as > is the
complement of the relation â‰¤, which is primitive recursive by Proposition 5.3.17.
3.
Clearly, E = {âŸ¨x, yâŸ©: x = y} is the intersection of â‰¤and â‰¥. Propositions 5.3.17
and 5.3.19 and Theorem 5.3.21(2) imply that E is primitive recursive.
We can now prove that any finite set of natural numbers is primitive recursive.
Proposition 5.3.24. Let A = {n1, n2, . . . , nk} be a finite set of natural numbers. Then A is
primitive recursive.
Proof. Let ni âˆˆA, where 1 â‰¤i â‰¤k. We first show that the singleton {ni} is primitive
recursive. Let nif be the constant function defined by nif (x) = ni, for all x âˆˆâ„•. The
function nif is primitive recursive by Proposition 5.3.8. Clearly, x âˆˆ{ni} if and only if
x = ni. It follows from the substitution rule that {ni} is primitive recursive. To formally
establish this, let I1
1 be the 1-place projection function. By Proposition 5.3.23, the relation
x = y is primitive recursive. As
x âˆˆ{ni}
iff
I1
1(x) = nif (x),

184
à±ª
5 Computability
the substitution rule (see (5.5)) implies that {ni} is primitive recursive. Hence, since A =
â‹ƒ1â‰¤iâ‰¤k{ni}, Corollary 5.3.22(2) implies that A is primitive recursive.
We now show that the graph of a recursive function is itself recursive. The converse
also holds (see Exercise 14).
Proposition 5.3.25. Let f : â„•n â†’â„•be a (primitive) recursive function. Then the relation
G = {âŸ¨âƒ—x, yâŸ©: f ( âƒ—x) = y}, the graph of f , is (primitive) recursive.
Proof. Since the relation = is primitive recursive and
G( âƒ—x, y)
if and only if
f ( âƒ—x) = y,
it follows from the substitution rule that G is a (primitive) recursive relation. More
specifically, since âƒ—x denotes the n-tuple x1, x2, . . . , xn, we see that In+1
i
( âƒ—x, y) = xi for each
1 â‰¤i â‰¤n and In+1
n+1( âƒ—x, y) = y. For every âƒ—x âˆˆâ„•n and y âˆˆâ„•, define
g1( âƒ—x, y) = f (In+1
1
( âƒ—x, y), . . . , In+1
n
( âƒ—x, y))
and
g2( âƒ—x, y) = In+1
n+1( âƒ—x, y).
Then g1 and g2 are (primitive) recursive, where g1( âƒ—x, y) = f ( âƒ—x) and g2( âƒ—x, y) = y. Thus,
G( âƒ—x, y)
if and only if
g1( âƒ—x, y) = g2( âƒ—x, y).
As the relation = is primitive recursive, the substitution rule (see (5.5)) implies that the
relation G is (primitive) recursive.
The next theorem gives a condition for which one can define a (primitive) recursive
function by cases.
Theorem 5.3.26. Let Q be a k-place (primitive) recursive relation. If f and g are k-place
(primitive) recursive functions, then the k-place function h defined by
h( âƒ—x) = {f ( âƒ—x),
if Q( âƒ—x),
g( âƒ—x),
if not Q( âƒ—x)
is also (primitive) recursive.
Proof. Note that
h( âƒ—x) = (f ( âƒ—x) Ã— CQ( âƒ—x)) + (g( âƒ—x) Ã— CQ( âƒ—x)),
which is (primitive) recursive by Propositions 5.3.9 and 5.3.7 and Theorem 5.3.21.
Theorem 5.3.26 can be extended to more than just two exclusive cases. For example,
suppose that f1, f2, f3, f4 are k-place (primitive) recursive functions and suppose that R
and Q are k-place (primitive) recursive relations. Then Theorem 5.3.21 implies that the
function h: â„•k â†’â„•defined by

5.3 Recursive functions
à±ª
185
h( âƒ—x) =
{
{
{
{
{
{
{
{
{
{
{
f1( âƒ—x),
if Q( âƒ—x) and R( âƒ—x),
f2( âƒ—x),
if Q( âƒ—x) and not R( âƒ—x),
f3( âƒ—x),
if R( âƒ—x) and not Q( âƒ—x),
f4( âƒ—x),
if not Q( âƒ—x) and not R( âƒ—x)
is also (primitive) recursive. In the above definition of h, no two of the four cases occur
at the same time, that is, the cases are exclusive. Furthermore, for each âƒ—x exactly one of
these cases holds.
As another example, let f1, f2, f3, f4 be k-place (primitive) recursive functions and
let Q1, Q2, Q3 be k-place (primitive) recursive relations. Suppose that the relations are
exclusive, that is, for any âƒ—x, no two of the relations Q1( âƒ—x), Q2( âƒ—x), and Q3( âƒ—x) hold at the
same time. Then the function h: â„•k â†’â„•defined by
h( âƒ—x) =
{
{
{
{
{
{
{
{
{
{
{
f1( âƒ—x),
if Q1( âƒ—x),
f2( âƒ—x),
if Q2( âƒ—x),
f3( âƒ—x),
if Q3( âƒ—x),
f4( âƒ—x),
if none of the above hold
is (primitive) recursive.
Bounded number quantifiers are very useful when one wants to put some restric-
tion on the numbers being quantified. To say that all natural numbers x < 9 satisfy the
property P(x), we shall write (âˆ€x < 9)P(x). Similarly, to say that some natural num-
ber x < 4 satisfies P(x), we can write (âˆƒx < 4)P(x).
Definition 5.3.27 (Bounded number quantifiers). When a is a specific number, we write
(âˆ€x < a)P(x) to mean that for every natural number x < a, P(x) is true. We also write
(âˆƒx < a)P(x) to assert that for some natural number x < a, P(x) is true.
In our proof of the next theorem we will be using the 1-place function pos defined by
pos(x) = {1,
if x > 0,
0,
if x = 0.
(5.6)
In Exercise 3, one is asked to prove that pos is primitive recursive.
Theorem 5.3.28. If Q is a (k + 1)-place (primitive) recursive relation, then the two follow-
ing (k + 1)-place relations are also (primitive) recursive:
1.
R = {âŸ¨âƒ—x, yâŸ©: (âˆ€t < y)Q( âƒ—x, t)},
2.
P = {âŸ¨âƒ—x, yâŸ©: (âˆƒt < y)Q( âƒ—x, t)}.
Proof. Let Q be a (k + 1)-place (primitive) recursive relation. Thus, the characteristic
function CQ is (primitive) recursive. The characteristic function of the relation R is
CR( âƒ—x, y) = âˆ
t<y
CQ( âƒ—x, t),

186
à±ª
5 Computability
which is (primitive) recursive by Proposition 5.3.15. Furthermore, the characteristic
function of the relation P is
CP( âƒ—x, y) = pos(âˆ‘
t<y
CQ( âƒ—x, t)),
which is also (primitive) recursive by Exercise 3 and Proposition 5.3.15.
Theorem 5.3.28 implies that whenever Q is a (k + 1)-place (primitive) recursive re-
lation and we define a (k + 1)-place relation R by
R( âƒ—x, y)
if and only if
(âˆ€t < y)Q( âƒ—x, t),
then R is (primitive) recursive. Similarly, if we define a (k + 1)-place relation P by
P( âƒ—x, y)
if and only if
(âˆƒt < y)Q( âƒ—x, t),
we can conclude that P is (primitive) recursive.
Example 5.3.29. Show that the 2-place relation R = {âŸ¨x, yâŸ©: (âˆƒq < y + 1)(x Ã— q = y)} is
primitive recursive.
Solution. Observe that the 3-place relation Q defined by
Q(x, q, y)
if and only if
x Ã— q = y
is primitive recursive by Proposition 5.3.25. Define the 3-place relation P by
P(x, y, z)
if and only if
(âˆƒq < z)(x Ã— q = y).
Theorem 5.3.28(2) implies that P is primitive recursive. Now let g1(x, y) = I2
1 (x, y),
g2(x, y) = I2
2(x, y), and g3(x, y) = S(I2
2(x, y)). Clearly, g1, g2, and g3 are primitive recursive
functions. By the substitution rule (see page 181) the relation
P(g1(x, y), g2(x, y), g3(x, y))
is primitive recursive. Observe that
P(g1(x, y), g2(x, y), g3(x, y))
iff
P(x, y, y + 1)
iff
(âˆƒq < y + 1)(x Ã— q = y)
iff
R(x, y).
Therefore, the relation R is primitive recursive.
Proposition 5.3.30. The divisibility relation x | y is primitive recursive.

5.3 Recursive functions
à±ª
187
Proof. Since x | y if and only if x Ã— q = y for some q, we must show that the relation
{âŸ¨x, yâŸ©: x Ã— q = y for some q}
is primitive recursive. To verify this, observe that
x | y
iff
âˆƒq(x Ã— q = y)
iff
(âˆƒq â‰¤y)(x Ã— q = y)
iff
(âˆƒq < y + 1)(x Ã— q = y).
Example 5.3.29 now implies that the divisibility relation x | y is primitive recursive.
Remark 5.3.31. It now follows that if we define a relation using bounded quantifiers,
constants, (primitive) recursive relations, (primitive) recursive functions, and the three
logical connectives â€œandâ€, â€œorâ€, and â€œnotâ€, then the relation is (primitive) recursive.
Proposition 5.3.32. The set {2, 3, 5, 7, . . . } of prime numbers is primitive recursive.
Proof. We show that the 1-place relation {x âˆˆâ„•: x is a prime} is primitive recursive.
Observe that
x is a prime
iff
1 < x and (âˆ€a < x)(âˆ€b < x)(a Ã— b
Ì¸= x),
where the relations < and Ì¸= are primitive recursive, and the function Ã— is also primitive
recursive. Therefore, the set of primes forms a primitive recursive set.
5.3.1 Bounded search
The total search operator (see Definition 5.3.5), also called the Î¼-operator, provides a
method for defining a function whose value is the least number that satisfies a particular
condition. We will now define a search operation that will only perform a search when
there is an upper bound on the number of the searches allowed, that is, the search will
terminate after looking at finitely many cases.
Definition 5.3.33. Let R be a (k + 1)-place relation on â„•. For each âƒ—x âˆˆâ„•k, define the
number (Î¼t < y)R( âƒ—x, t) by
(Î¼t < y)R( âƒ—x, t) = {the least t that satisfies t < y and R( âƒ—x, t),
y,
if no such t exists.
Thus, for any (k + 1)-place relation R on â„•, we can define the following total (k + 1)-
place function f : â„•k+1 â†’â„•by
f ( âƒ—x, y) = (Î¼t < y)R( âƒ—x, t).

188
à±ª
5 Computability
The function f is said to be defined by bounded minimization or bounded search. Observe
that f ( âƒ—x, y) = y if and only if there is no t < y that satisfies R( âƒ—x, t).
For example, consider the 2-place relation â€œt is a prime and t > x.â€ So we can define
the 2-place function f : â„•2 â†’â„•by
f (x, y) = (Î¼t < y)[t is a prime and t > x].
To illustrate how to evaluate this function, we obtain
f (4, 9) = (Î¼t < 9)[t is a prime and t > 4] = 5,
f (4, 20) = (Î¼t < 20)[t is a prime and t > 4] = 5,
f (9, 4) = (Î¼t < 4)[t is a prime and t > 9] = 4,
f (9, 0) = (Î¼t < 0)[t is a prime and t > 9] = 0.
Theorem 5.3.34. If R is a (primitive) recursive relation, then the function
f ( âƒ—x, y) = (Î¼t < y)R( âƒ—x, t)
is (primitive) recursive.
Proof. We will show that f can be defined by primitive recursion. Observe that:
(1) f ( âƒ—x, 0) = 0,
(2) f ( âƒ—x, n + 1) =
{
{
{
{
{
{
{
f ( âƒ—x, n),
if f ( âƒ—x, n) < n,
n,
if f ( âƒ—x, n) = n and R( âƒ—x, n),
n + 1,
if f ( âƒ—x, n) = n and not R( âƒ—x, n),
for all n âˆˆâ„•.
Thus, we get the following tree, where g is (primitive) recursive (see Proposition 5.3.23,
Remark 5.3.31, and Theorem 5.3.26).
f
f ( âƒ—x, 0) = 0
= ÌŠf ( âƒ—x)
w = f ( âƒ—x, n)
f ( âƒ—x, n + 1) =
{
{
{
{
{
{
{
w,
if w < n,
n,
if w = n & R( âƒ—x, n),
n + 1,
if w = n & Â¬R( âƒ—x, n)
= g(w, âƒ—x, n)
Euclid proved that there are infinitely many prime numbers. So the function
h: â„•â†’â„•defined in our next theorem is a total function.

5.3 Recursive functions
à±ª
189
Theorem 5.3.35. Let h: â„•â†’â„•be defined by
h(x) = the smallest prime number that is strictly larger than x.
(5.7)
Then h is primitive recursive.
Proof. First we prove that for every natural number x there is a prime number p such
that x < p â‰¤x! + 1. Note that every prime number q â‰¤x evenly divides x!. We know that
every natural number greater than 1 is divisible by a prime. Since x! + 1 > 1, the natural
number x! + 1 is divisible by a prime p. Because p evenly divides x! + 1, it follows that p
does not evenly divide x!. Therefore, x < p â‰¤x! + 1. It now follows that
h(x) = (Î¼t < (x! + 2))[t is a prime and t > x].
(5.8)
The predicate
t is a prime and t > x
is primitive recursive by Propositions 5.3.32 and 5.3.23 and Theorem 5.3.21(2). Also, the
function x ó³¨ƒâ†’x! is primitive recursive by Proposition 5.3.12. So f : â„•â†’â„•defined by
f (x) = x! + 2 is primitive recursive. Theorem 5.3.34 implies that the function
âŸ¨x, yâŸ©ó³¨ƒâ†’(Î¼t < y)[t is a prime and t > x]
is primitive recursive. Therefore, by composition, the function h satisfying (5.8) is also
primitive recursive.
For each x âˆˆâ„•, let px be the (x + 1)-st prime number. Thus,
p0 = 2,
p1 = 3,
p2 = 5,
p3 = 7,
p4 = 11, . . . , p25 = 101, . . . .
One can easily prove, by induction, that px > x + 1 for all x âˆˆâ„•.
Proposition 5.3.36. The function x ó³¨ƒâ†’px is primitive recursive.
Proof. Let g be defined by g(x) = px. Now let h be the primitive recursive function in
Theorem 5.3.35. Then g can be defined by primitive recursion as follows:
(1) g(0) = 2,
(2) g(n + 1) = h(g(n)), for all n âˆˆâ„•.
Thus, the function g is primitive recursive.
An important feature of the natural numbers is that one can code a finite sequence
of natural numbers by a single natural number. The fundamental theorem of arithmetic
(see Theorem 1.1.29 on page 11) states that every natural number x has a unique prime

190
à±ª
5 Computability
factorization. This theorem allows us to encode any finite tuple of natural numbers by
a single natural number using the following bracket notation:
[ ] = 1,
[x, y] = 2x+13y+1,
[x, y, z] = 2x+13y+15z+1,
...
[x0, x1, . . . , xk] = 2x0+13x1+15x2+1 â‹…â‹…â‹…pxk+1
k
,
(5.9)
where [ ] encodes the â€œemptyâ€ tuple and pk denotes the (k + 1)-st prime. For example,
[2, 1] = 72 and [2, 1, 0] = 360. Let S be the set of all finite sequences (tuples) of natural
numbers. Then the function h: S â†’â„•defined by h(âŸ¨x0, x1, . . . , xkâŸ©) = [x0, x1, . . . , xk] is
one-to-one; however, h is not onto since 10 = 2 Ã— 5 is not a value of this function.
Theorem 5.3.37. Let k be a natural number. The function h: â„•k+1 â†’â„•defined by
h(x0, x1, . . . , xk) = [x0, x1, . . . , xk]
(5.10)
is primitive recursive.
Proof. Let k âˆˆâ„•. As h(x0, x1, . . . , xk) = 2x0+13x1+15x2+1 â‹…â‹…â‹…pxk+1
k
, it follows from Proposi-
tion 5.3.15 that h is primitive recursive because exponentiation is primitive recursive
(see Propositions 5.3.11).
Let s be a natural number which codes a sequence, that is, s = [a0, a1, a2, . . . , ak]
for some finite (k + 1)-tuple of natural numbers a0, a1, a2, . . . , ak. We will next show that
there is a primitive recursive â€œdecodingâ€ function âŸ¨s, iâŸ©ó³¨ƒâ†’(s)i such that (s)i = ai for
each i â‰¤k. For example, since [2, 1] = 72, we have (72)0 = 2 and (72)1 = 1.
Proposition 5.3.38. A primitive recursive decoding function âŸ¨s, iâŸ©ó³¨ƒâ†’(s)i exists.
Proof. For a prime number q, the largest exponent e such that qe | s is also the least
natural number k such that qk+1 âˆ¤s, that is, e = Î¼k(qk+1 âˆ¤s). Since q â‰¥2 and qe | s,
we have e < qe â‰¤s. Hence, e = (Î¼k < s)(qk+1 âˆ¤s). Thus, the exponent of q in the prime
factorization of s is equal to
(Î¼k < s)(qk+1 âˆ¤s).
When q = pi, the (i + 1)-st prime, define
(s)âˆ—
i = (Î¼k < s)(pk+1
i
âˆ¤s),

5.3 Recursive functions
à±ª
191
which is the largest exponent of pi in the prime factorization of s. For our decoding
function we need one less than the exponent of the prime pi in the prime factorization
of s. Thus, we have
(s)i = (s)âˆ—
i
âˆ˜âˆ’1 = (Î¼k < s)(pk+1
i
âˆ¤s) âˆ˜âˆ’1,
which is primitive recursive since the far right hand side of the above equations involves
the composition of primitive recursive functions (see Theorems 5.3.34 and 5.3.21(1) and
Propositions 5.3.36 and 5.3.14).
Note that (s)i is defined for all s, i âˆˆâ„•, even when s does not code a sequence.
Definition 5.3.39. A natural number s is called a sequence number if s = [ ] or s =
[a0, a1, a2, . . . , ak] for some (k + 1)-tuple of natural numbers a0, a1, a2, . . . , ak.
For example, 1 and 108 are sequence numbers because 1 = [ ] and [1, 2] = 2233 = 108,
but 10 is not a sequence number.
Proposition 5.3.40. The set of sequence numbers is primitive recursive.
Proof. See Exercise 11.
One can prove (by induction) that n + 1 < pn for all natural numbers n. Let x âˆˆâ„•
and let k be the smallest such that pk âˆ¤x. So x â‰¥1. If k = 0, then k < x. If k > 0, then
pkâˆ’1 | x. Thus, pkâˆ’1 â‰¤x and hence, k = (k âˆ’1) + 1 < pkâˆ’1 â‰¤x, that is, k < x. Therefore, if
k is the smallest such that pk âˆ¤x, then k < x. This justifies the upper bound of x on the
Î¼-operator in the following proposition.
Proposition 5.3.41. The function lh(x) = (Î¼k < x)(pk âˆ¤x) is primitive recursive.
Proof. This holds because lh(x) = (Î¼k < x)(pk âˆ¤x) and the right hand side of this
equation is primitive recursive.
The function lh(x) is called the length function and gives the length of a sequence
coded by x; for example, since 360 = 23 Ã— 32 Ã— 5 = [2, 1, 0] and p3 = 7 is the least prime
that does not divide 360, we have lh(360) = 3. In general, if x = [a0, a1, a2, . . . , ak], then
lh(x) = k + 1. In addition, (x)lh(x) âˆ˜âˆ’1 = ak is the last component of the sequence. We note
that lh(0) = 0 by Definition 5.3.33.
Let x = [a0, a1, a2, . . . , ak] be a sequence number and let y â‰¤k + 1. Consider the
function âŸ¨x, yâŸ©ó³¨ƒâ†’x â†¾y defined by
x â†¾y = [a0, a1, a2, . . . , ayâˆ’1].
We say that x â†¾y is the restriction of x to y and gives us the code for the sequence
consisting of the first y components of the sequence coded by x.
Proposition 5.3.42. The function âŸ¨x, yâŸ©ó³¨ƒâ†’x â†¾y is primitive recursive.

192
à±ª
5 Computability
Proof. This holds because
x â†¾y = âˆ
t<y
p(x)âˆ—
t
t
(5.11)
and the right hand side of (5.11) is a composition of primitive recursive functions.
For example, if x = [a0, a1, . . . , ak] and y â‰¤k + 1, then
x â†¾y = [a0, a1, . . . , ayâˆ’1] = pa0+1
0
pa1+1
1
â‹…â‹…â‹…p
ayâˆ’1+1
yâˆ’1
= p(x)âˆ—
0
0
p(x)âˆ—
1
1
â‹…â‹…â‹…p
(x)âˆ—
yâˆ’1
yâˆ’1
= âˆ
t<y
p(x)âˆ—
t
t
.
Furthermore, if k = lh(x) âˆ˜âˆ’1, then x â†¾k = [a0, a1, a2, . . . , akâˆ’1] results in the deletion of
the last component in the sequence coded by x.
Let x = [a0, a1, a2, . . . , ak] and y = [b0, b1, b2, . . . , bâ„“] be two sequence numbers. Con-
sider the function âŸ¨x, yâŸ©ó³¨ƒâ†’x âˆ—y defined by
x âˆ—y = [a0, a1, a2, . . . , ak, b0, b1, b2, . . . , bâ„“].
We say that x âˆ—y is the concatenation of x to y.
Proposition 5.3.43. The concatenation function âŸ¨x, yâŸ©ó³¨ƒâ†’x âˆ—y is primitive recursive.
Proof. We must show that there is a 2-place primitive recursive function such that if x
and y are sequence numbers, then âŸ¨x, yâŸ©ó³¨ƒâ†’x âˆ—y. This is done by defining
x âˆ—y = x Ã— âˆ
t<lh(y)
p(y)âˆ—
t
t+lh(x),
which is a composition of primitive recursive functions.
Since [2, 1] = 23 Ã— 32 = 72,
72 âˆ—72 = [2, 1] âˆ—[2, 1] = [2, 1, 2, 1] = 72 Ã— 53 Ã— 72 = 441, 000.
Moreover, if x is a sequence number and i âˆˆâ„•, then x âˆ—[i] is the sequence number of
the sequence obtained by adjoining i at the end of the sequence coded by x. We note that
x âˆ—y is defined for all x and y in â„•, even if x and y are not sequence numbers.
We can define the operation of concatenation of more than two sequence numbers.
Suppose that x0, x1, . . . xkâˆ’1 are sequence numbers. Then we can concatenate all of the
sequences coded by x0, x1, . . . xkâˆ’1, denoted byâˆ—t<k xt, as follows:
âˆ—
t<k
xt = x0 âˆ—x1 âˆ—â‹…â‹…â‹…âˆ—xkâˆ’1,
where on the right hand side of the above equation the operation âˆ—is associative.

5.3 Recursive functions
à±ª
193
Proposition 5.3.44. Let f be a (primitive) recursive (k + 1)-place function. Then the func-
tion âŸ¨âƒ—x, yâŸ©ó³¨ƒâ†’âˆ—t<y f ( âƒ—x, t) is (primitive) recursive.
Proof. Note that the function âŸ¨âƒ—x, yâŸ©ó³¨ƒâ†’âˆ—t<y f ( âƒ—x, t) can be defined by primitive recursion
as follows:
(1) âˆ—t<0 f ( âƒ—x, t) = 1,
(2) âˆ—t<(n+1) f ( âƒ—x, t) = (âˆ—t<n f ( âƒ—x, t)) âˆ—f (x, n), for all n âˆˆâ„•.
Therefore, the function âŸ¨âƒ—x, yâŸ©ó³¨ƒâ†’âˆ—t<y f ( âƒ—x, t) is (primitive) recursive.
For any (k + 1)-place function f , we define a new (k + 1)-place function f by
f ( âƒ—x, y) = [f ( âƒ—x, 0), f ( âƒ—x, 1), . . . , f ( âƒ—x, y âˆ’1)] = âˆ
t<y
pf ( âƒ—x,t)+1
t
.
So the function f encodes the first y values f ( âƒ—x, 0), f ( âƒ—x, 1), . . . , f ( âƒ—x, y âˆ’1) of f as a single
natural number. For example, f ( âƒ—x, 0) = [ ] = 1 and f ( âƒ—x, 2) = [f ( âƒ—x, 0), f ( âƒ—x, 1)]. Clearly,
f ( âƒ—x, y) is always a sequence number of length y.
Proposition 5.3.45. Let f be a (primitive) recursive (k +1)-place function. Then the (k +1)-
place function f is (primitive) recursive.
Proof. Since f ( âƒ—x, y) = âˆt<y pf ( âƒ—x,t)+1
t
, we see that the right hand side of this equation is a
composition of (primitive) recursive functions.
Given any (k +2)-place function g, there exists a unique (k +1)-place function h that
satisfies the equation
h( âƒ—x, y) = g(h( âƒ—x, y), âƒ—x, y),
where we must first know the value of
h( âƒ—x, y) = [h( âƒ—x, 0), h( âƒ—x, 1), . . . , h( âƒ—x, y âˆ’1)]
before we can evaluate h( âƒ—x, y). For example,
h( âƒ—x, 0) = g([ ], âƒ—x, 0),
h( âƒ—x, 1) = g([h( âƒ—x, 0)], âƒ—x, 1),
h( âƒ—x, 2) = g([h( âƒ—x, 0), h( âƒ—x, 1)], âƒ—x, 2),
(ó³µ³)
...
h( âƒ—x, n) = g([h( âƒ—x, 0), h( âƒ—x, 1), . . . , h( âƒ—x, n âˆ’1)], âƒ—x, n),
h( âƒ—x, n + 1) = g([h( âƒ—x, 0), h( âƒ—x, 1), . . . , h( âƒ—x, n âˆ’1), h( âƒ—x, n)], âƒ—x, n + 1).

194
à±ª
5 Computability
The definition of a function by primitive recursion allows one to define the value
of a function h( âƒ—x, n + 1) in terms of its preceding value h( âƒ—x, n) (see Definition 5.2.14).
The above (ó³µ³) clearly illustrates how to define the value of a function in terms of all
its preceding values, namely, by coding the sequence of preceding values as a sequence
number. In computability theory, a course-of-values recursion is a technique for defining
number-theoretic functions by recursion.
Proposition 5.3.46 (Course of values recursion). Let g be a (primitive) recursive (k + 2)-
place function. Then the (k + 1)-place function h that satisfies
h( âƒ—x, n) = g(h( âƒ—x, n), âƒ—x, n), for all âƒ—x and n,
is (primitive) recursive.
Proof. To prove that h is (primitive) recursive, we first show (paradoxically) that h is
(primitive) recursive. Note that h satisfies the primitive recursion:
(1) h( âƒ—x, 0) = 1,
(2) h( âƒ—x, n + 1) = h( âƒ—x, n) âˆ—[g(h( âƒ—x, n)), âƒ—x, n)], for all n âˆˆâ„•.
Thus, h is (primitive) recursive. Since (h( âƒ—x, n+1))n = h( âƒ—x, n), we conclude that h is (prim-
itive) recursive. From (2), we also conclude that
(h( âƒ—x, n + 1))n = (h( âƒ—x, n) âˆ—[g(h( âƒ—x, n)), âƒ—x, n)])n.
Thus, h( âƒ—x, n) = g(h( âƒ—x, y), âƒ—x, n).
We end this section by showing how the total search operation can be used to con-
struct a recursive function.
Proposition 5.3.47. Let R âŠ†â„•k+1 be a recursive relation such that for all âƒ—x âˆˆâ„•k there is
a p âˆˆâ„•such that R( âƒ—x, p). Then the function f : â„•k â†’â„•defined by
f ( âƒ—x) = the least p âˆˆâ„•such that R( âƒ—x, p)
(5.12)
is recursive and R( âƒ—x, f ( âƒ—x)) for all âƒ—x âˆˆâ„•k.
Proof. Since for all âƒ—x âˆˆâ„•k there exists a p âˆˆâ„•such that R( âƒ—x, p), the function f : â„•k â†’â„•
defined by (5.12) satisfies f ( âƒ—x) = Î¼p(1
âˆ˜âˆ’CR( âƒ—x, p) = 0). Therefore, f is recursive and
R( âƒ—x, f ( âƒ—x)) for all âƒ—x âˆˆâ„•k.
Exercises 5.3.
1. Show that the function f : â„•â†’â„•defined by f (x) = x2 is primitive recursive.
2. Show that the function f : â„•â†’â„•defined by
f (n) = {1,
if n is even,
0,
if n is odd

5.4 Recursively enumerable sets and relations
à±ª
195
is primitive recursive.
*3. Show that the function pos defined by (5.6) is primitive recursive.
4. Let f : â„•â†’â„•and the 2-place relation Q be (primitive) recursive. Show, as in Ex-
ample 5.3.29, that R = {âŸ¨x, yâŸ©: (âˆƒq < f (y))Q(x, q)} is (primitive) recursive.
5. Show that the set {i2 : i âˆˆâ„•} is primitive recursive.
6. Show that the set {2i : i âˆˆâ„•} is primitive recursive.
7. Using definition by cases, show that the following functions f : â„•2 â†’â„•are primi-
tive recursive:
(a) f (x, y) = |x âˆ’y|,
(b) f (x, y) = max{x, y},
(c) f (x, y) = min{x, y}.
8. Find a nontotal 2-place function g such that the function h defined by
h(x) = Î¼y(g(x, y) = 0),
that is,
h(x) = the least y such that g(x, y) = 0,
is a total function.
9. For each i âˆˆâ„•, by Proposition 5.3.38, the function t ó³¨ƒâ†’(t)i is primitive recursive.
Evaluate (24)0, (24)1, (45)0, (45)1, (45)2, (23)0, and (23)1.
10. Define m: â„•k+1 â†’â„•by m( âƒ—x, n) = max{f ( âƒ—x, i) : 0 â‰¤i â‰¤n}, where f : â„•k+1 â†’â„•is
(primitive) recursive. Show that m is (primitive) recursive.
*11. Prove Proposition 5.3.40.
12. For each n âˆˆâ„•, let An be a recursive subset of â„•. Show that â‹‚n
i=0 Ai and â‹ƒn
i=0 Ai are
recursive, for all n âˆˆâ„•.
13. Let g: â„•â†’â„•be (primitive) recursive. Let g(0)(i) = i and whenever p â‰¥1, let
g(p) = g âˆ˜g âˆ˜â‹…â‹…â‹…âˆ˜g
âŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸâŸ
p-times
.
Define f : â„•2 â†’â„•by f (i, n) = g(n)(i). Show that f is (primitive) recursive.
*14. Let f : â„•k â†’â„•be a total function. Show that if the graph of f is recursive, then f is
recursive.
5.4 Recursively enumerable sets and relations
Some sets of natural numbers are recursive and some are almost recursive. Recall that
a recursive nonempty set A âŠ†â„•is one whose characteristic function CA is recursive.
Using CA, one can effectively enumerate the elements of A. Let k0 âˆˆA and define the
function f : â„•â†’â„•by

196
à±ª
5 Computability
f (n) = {n,
if CA(n) = 1,
k0,
if CA(n) = 0.
Clearly, f is a recursive function and the range of f is equal to A. Thus, we can list all the
values of f as follows: f (0), f (1), f (2), . . . . This listing also effectively enumerates all of the
elements of A. Theorem 5.3.21 implies that â„•\ A is recursive. Thus, in a similar manner,
we can effectively enumerate the elements of â„•\ A (if nonempty). This motivates our
next definition.
Definition 5.4.1. A set A âŠ†â„•is recursively enumerable if and only if A = âŒ€or there is a
recursive function f : â„•â†’â„•such that A is the range of f .
The function f in Definition 5.4.1 is not required to be one-to-one. However, Exer-
cise 7 shows that every infinite recursively enumerable subset of â„•is the range of a
one-to-one recursive function.
A recursively enumerable set of natural numbers can be viewed as being â€œalmost
recursive.â€ A recursively enumerable set is also said to be semi-recursive. There is an
alternative interpretation of a set being recursively enumerable.
Proposition 5.4.2. A set A âŠ†â„•is recursively enumerable if and only if there is a 2-place
recursive relation R such that A = {n âˆˆâ„•: âˆƒpR(n, p)}.
Proof. Let A âŠ†â„•.
(â‡’). Assume that A is recursively enumerable. Let f : â„•â†’â„•be a recursive function
such that A equals the range of f . Consider the relation
R = {âŸ¨n, pâŸ©: n = f (p)}.
Since the relation = is primitive recursive, the substitution rule (see (5.5) on page 181)
implies that the relation R is recursive. Clearly, A = {n âˆˆâ„•: âˆƒpR(n, p)}.
(â‡). Assume that A = {n âˆˆâ„•: âˆƒpR(n, p)} for some recursive relation R. If A = âŒ€, then
we are done. So let k âˆˆA. By Proposition 5.3.38, the â€œdecodingâ€ operation (s)i is defined
for all s, i âˆˆâ„•. Let f : â„•â†’â„•be defined by
f (n) = {(n)0,
if R((n)0, (n)1),
k,
if not R((n)0, (n)1).
Then f is recursive (see Proposition 5.3.38) and the range of f is A.
Proposition 5.4.2 allows us to broaden the definition of recursively enumerable.
Definition 5.4.3. A relation P âŠ†â„•k is recursively enumerable if and only if there is a
(k + 1)-place recursive relation R such that

5.4 Recursively enumerable sets and relations
à±ª
197
P( âƒ—x)
iff
âˆƒpR( âƒ—x, p)
for all âƒ—x âˆˆâ„•k.
Our goal now is to establish a surprising result: Every total partial recursive func-
tion is, in fact, a recursive function (see Theorem 5.4.12).
Theorem 5.4.4 (Selection theorem). Let S âŠ†â„•k+1 be recursively enumerable and suppose
that for all âƒ—x âˆˆâ„•k there exists an i âˆˆâ„•such that S( âƒ—x, i). Then there is a recursive function
f : â„•k â†’â„•such that S( âƒ—x, f ( âƒ—x)) for all âƒ—x âˆˆâ„•k.
Proof. Given that S is recursively enumerable, there is a recursive relation R such that
S( âƒ—x, i)
iff
âˆƒjR( âƒ—x, i, j).
Suppose that for all âƒ—x âˆˆâ„•k there exists an i âˆˆâ„•such that S( âƒ—x, i). Thus, for all âƒ—x âˆˆâ„•k
there are i, j âˆˆâ„•such that R( âƒ—x, i, j). Define h: â„•k â†’â„•by
h( âƒ—x) = the least p âˆˆâ„•such that R( âƒ—x, (p)0, (p)1).
Note that h( âƒ—x) = Î¼p(1
âˆ˜âˆ’CR( âƒ—x, (p)0, (p)1) = 0) and this is obtained from the recursive
function g( âƒ—x, p) = 1 âˆ˜âˆ’CR( âƒ—x, (p)0, (p)1) by a total search (Definition 5.3.5). So h is recursive.
Define f : â„•k â†’â„•by f ( âƒ—x) = (h( âƒ—x))0. Thus, f is recursive and S( âƒ—x, f ( âƒ—x)) for all âƒ—x âˆˆâ„•k.
We now show that the set of recursively enumerable relations is closed under re-
cursive substitutions, conjunction, and disjunction.
Lemma 5.4.5. Suppose that P is an n-place recursively enumerable relation and that
g1, g2, . . . , gn are k-place recursive functions. Then the k-place relation Q defined by
Q( âƒ—x)
iff
P(g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x))
is recursively enumerable.
Proof. Given that P is recursively enumerable, there is an (n+1)-place recursive relation
R such that P(x1, . . . , xn) iff âˆƒiR(x1, . . . , xn, i). Thus, for all âƒ—x âˆˆâ„•k, we have
Q( âƒ—x)
iff
P(g1( âƒ—x), . . . , gn( âƒ—x))
iff
âˆƒiR(g1( âƒ—x), . . . , gn( âƒ—x), i).
By the substitution rule, the relation R(g1( âƒ—x), . . . , gn( âƒ—x), i) is recursive. Therefore, Q is
recursively enumerable.
Lemma 5.4.6. Let R âŠ†â„•k and Q âŠ†â„•k.
1.
If R is a recursive relation, then R is recursively enumerable.
2.
If R and Q are recursively enumerable relations, then the following relations are also
recursively enumerable:

198
à±ª
5 Computability
(a) R âˆ©Q = { âƒ—x âˆˆâ„•k : R( âƒ—x) and Q( âƒ—x)},
(b) R âˆªQ = { âƒ—x âˆˆâ„•k : R( âƒ—x) or Q( âƒ—x)}.
Proof. Suppose that R âŠ†â„•k and Q âŠ†â„•k.
1.
Let R be a recursive relation. The relation S âŠ†â„•k+1 defined by S( âƒ—x, p) iff R( âƒ—x) is
recursive, as S is the result of a composition of R with the projection functions
Ik+1
i
(x1, . . . , xk, p) = xi, where 1 â‰¤i â‰¤k. Clearly, R( âƒ—x) iff âˆƒpS( âƒ—x, p). So R is recursively
enumerable.
2.
Assume that R and Q are recursively enumerable. Therefore, there are recursive
relations S âŠ†â„•k+1 and U âŠ†â„•k+1 such that
(R( âƒ—x)
iff
âˆƒpS( âƒ—x, p))
and
(Q( âƒ—x)
iff
âˆƒpU( âƒ—x, p)).
Thus,
(R( âƒ—x) and S( âƒ—x))
iff
âˆƒp(S( âƒ—x, (p)0) and U( âƒ—x, (p)1)),
(R( âƒ—x) or S( âƒ—x))
iff
âˆƒp(S( âƒ—x, p) or U( âƒ—x, p)).
Therefore, Theorem 5.3.21 and the substitution rule imply that the conjunction
â€œR( âƒ—x) and S( âƒ—x)â€ and disjunction â€œR( âƒ—x) or S( âƒ—x)â€ are recursively enumerable.
By a suitable use of the projection functions, part 2 of Lemma 5.4.6 implies that
the conjunction and disjunction of any two recursively enumerable relations are re-
cursively enumerable. For example, if R(x, y) and S(y, z) are recursively enumerable,
then the relation P(x, y, z) defined by â€œR(x, y) and S(y, z)â€ is recursively enumerable.
Moreover, by applying a proof by induction, part 2 of Lemma 5.4.6 implies that the con-
junction or disjunction of any finite number of recursively enumerable relations is also
recursively enumerable.
Corollary 5.4.7. Let n âˆˆâ„•and suppose that R1, R2, . . . , Rn are k-place recursively enu-
merable relations. Then
1.
â‹€n
i=1 Ri( âƒ—x) = R1( âƒ—x) âˆ§R2( âƒ—x) âˆ§â‹…â‹…â‹…âˆ§Rn( âƒ—x) is recursively enumerable,
2.
â‹n
i=1 Ri( âƒ—x) = R1( âƒ—x) âˆ¨R2( âƒ—x) âˆ¨â‹…â‹…â‹…âˆ¨Rn( âƒ—x) is recursively enumerable.
We will now show that the set of recursively enumerable relations is closed under
the bounded number quantifiers and the existential quantifier.
Lemma 5.4.8. Let Q âŠ†â„•k+1 be recursively enumerable and let n âˆˆâ„•. Then:
1.
The relation (âˆ€i < n)Q( âƒ—x, i) is recursively enumerable.
2.
The relation (âˆƒi < n)Q( âƒ—x, i) is recursively enumerable.
3.
The relation âˆƒiQ( âƒ—x, i) is recursively enumerable.
Proof. Let Q âŠ†â„•k+1 be recursively enumerable. Thus, there is a recursive relation R
such that

5.4 Recursively enumerable sets and relations
à±ª
199
Q( âƒ—x, i)
iff
âˆƒjR( âƒ—x, i, j).
The desired conclusion follows from the following equivalences:
(âˆ€i < n)Q( âƒ—x, i)
iff
(âˆ€i < n)âˆƒjR( âƒ—x, i, j)
iff
âˆƒj(âˆ€i < n)R( âƒ—x, i, (j)i),
(5.13)
(âˆƒi < n)Q( âƒ—x, i)
iff
(âˆƒi < n)âˆƒjR( âƒ—x, i, j)
iff
âˆƒj(âˆƒi < n)R( âƒ—x, i, j),
(5.14)
âˆƒiQ( âƒ—x, i)
iff
âˆƒiâˆƒjR( âƒ—x, i, j)
iff
âˆƒkR( âƒ—x, (k)0, (k)1).
(5.15)
To confirm (5.13), given that for each i < n there is a ji âˆˆâ„•such that R( âƒ—x, i, ji), let j be the
sequence number j = [j0, j1, . . . , jnâˆ’1]. Then (âˆ€i < n)R( âƒ—x, i, (j)i). Thus, âˆƒj(âˆ€i < n)R( âƒ—x, i, (j)i).
The converse holds similarly. Theorem 5.3.28 implies that the right hand sides of (5.13)
and (5.14) are recursively enumerable, and the substitution rule implies that the right
hand side of (5.15) is recursively enumerable.
The set of partial recursive functions can be defined by induction (see Section 1.1.5).
Let B be the set consisting only of the zero, successor, and projection functions. Let â„±
be the set of functional operations that correspond to composition, primitive recursion,
and partial search. Then, as in Theorem 1.1.24, we inductively define the following sets
of functions:
(1) C0 = B,
(2) Cn+1 = Cn âˆªâ„±[Cn], for all n âˆˆâ„•.
Then C = â‹ƒnâˆˆâ„•Cn is the set of all the partial recursive functions. Moreover, whenever
a set contains the zero, successor, and projection functions and it is closed under com-
position, primitive recursion, and partial search, then the set contains all of the partial
recursive functions (see Exercise 5(b) on page 15). We will apply this observation in the
proof of our next theorem. First we give a definition.
Definition 5.4.9. Let h be a k-place partial recursive function. Then the graph of h is the
(k + 1)-place relation
Gh = {( âƒ—x, y) : h( âƒ—x) = y}.
The next theorem shows that there exists a close connection between partial recur-
sive functions and recursively enumerable relations.
Theorem 5.4.10. For every partial recursive function h, the graph of h is recursively enu-
merable.
Proof. Let S be the set of all partial recursive functions whose graph is recursively enu-
merable. We shall prove by induction that S contains all partial recursive functions.
Base step: We must show that every initial function is in S. To do this, let h be an
initial function. Since h is a recursive function, Gh is recursive by Proposition 5.3.25.
Lemma 5.4.6(1) now implies that the relation Gh is recursively enumerable.

200
à±ª
5 Computability
Inductive step: We must show that S is closed under (1) composition, (2) primitive re-
cursion, and (3) partial search. Let f , g, g1, g2, . . . , gn be partial recursive functions and
assume that all of these functions are in S, that is, assume the induction hypothesis
Gf , Gg, Gg1, . . . , Ggn are recursively enumerable.
(IH)
We now establish closure under the above identified operations (1), (2), and (3).
(1) Assume that f : â„•n â†’â„•and gi: â„•k â†’â„•for each i = 1, 2, . . . , n. We must show that
function h: â„•k â†’â„•defined by the composition
h( âƒ—x) = f (g1( âƒ—x), g2( âƒ—x), . . . , gn( âƒ—x))
is also in S. Since
h( âƒ—x) = y
iff
âˆƒv1 â‹…â‹…â‹…âˆƒvn(
n
â‹€
i=1
gi( âƒ—x) = vi and f (v1, v2, . . . , vn) = y),
(IH), Corollary 5.4.7, and Exercise 11 imply that Gh is recursively enumerable.
(2) Assume that f : â„•k â†’â„•and g: â„•k+2 â†’â„•. We must show that the function
h: â„•k+1 â†’â„•defined by the primitive recursion
(a) h( âƒ—x, 0) = f ( âƒ—x),
(b) h( âƒ—x, n + 1) = g(h( âƒ—x, n), âƒ—x, n), for all n âˆˆâ„•,
is also in S. Because
h( âƒ—x, n) = y
iff
âˆƒp(f ( âƒ—x) = (p)0 and (âˆ€i < n)(g((p)i, âƒ—x, i) = (p)i+1) and (p)n = y),
Lemmas 5.4.5, 5.4.6, and 5.4.8(1)(2) and (IH) imply that Gh is recursively enumerable.
(3) Assume that g is a (k + 1)-place function. We must show that the k-place function h
defined by the partial search
h( âƒ—x) = Î¼y(g( âƒ—x, y) = 0)
is in S. Since
h( âƒ—x) = y
iff
g( âƒ—x, y) = 0 and (âˆ€i < y)âˆƒv(g( âƒ—x, s) = v and v > 0),
Lemmas 5.4.6 and 5.4.8(1)(2) and (IH) imply that Gh is recursively enumerable.
Theorem 5.4.10 and a modification of the proof of Theorem 5.4.4 (see Exercise 5) now
imply the following equivalence.
Theorem 5.4.11. Let h: â„•k â†’â„•be a partial function. Then h is partial recursive if and
only if Gh is recursively enumerable.
Theorems 5.4.10 and 5.4.4 also imply that every total partial recursive function is
recursive.

5.4 Recursively enumerable sets and relations
à±ª
201
Theorem 5.4.12. Let h: â„•k â†’â„•be a total partial recursive function. Then h is a recursive
function.
Proof. Let h be a total partial recursive function. Theorem 5.4.10 implies the relation
Gh( âƒ—x, y)
iff
h(x) = y
(5.16)
is recursively enumerable. Since h is total, we know that for all âƒ—x âˆˆâ„•k, there is a y
such that Gh( âƒ—x, y). The selection theorem (Theorem 5.4.4) implies that there is a recursive
function f : â„•k â†’â„•such that Gh( âƒ—x, f ( âƒ—x)) for all âƒ—x âˆˆâ„•k. Therefore, by (5.16), we conclude
that h( âƒ—x) = f ( âƒ—x) for all âƒ—x âˆˆâ„•k, that is, h is a recursive function.
5.4.1 Decidability revisited
In Section 5.1.1 we presented a definition of a decidable (semi-decidable) set. However,
this definition was given in terms of the intuitive concept of an â€œeffective procedure.â€
Because of Theorems 5.2.11 and 5.2.20 and the Churchâ€“Turing thesis, we can now give a
mathematically precise definition of a set being decidable (semi-decidable).
Definition 5.4.13. Let S âŠ†â„•k. Then S is decidable if its characteristic function
CS( âƒ—x) = {1,
if âƒ—x âˆˆS,
0,
if âƒ—x âˆ‰S
is partial recursive. Moreover, S is semi-decidable if its semi-characteristic function
cS( âƒ—x) = {1,
if âƒ—x âˆˆS
â†‘,
if âƒ—x âˆ‰S
is partial recursive.
In light of Theorem 5.4.12, the above definition of a set being decidable can be made
stronger. Our next result confirms this by showing that a relation is decidable if and only
if its characteristic function is recursive.
Theorem 5.4.14. Let S âŠ†â„•k. Then S is decidable if and only if S is recursive.
Proof. Assume that S is decidable. Thus, the characteristic function CS is total and par-
tial recursive. Theorem 5.4.12 implies that CS is recursive, so S is recursive. Conversely,
suppose that S is recursive. Then CS is recursive and hence, it is partial recursive. There-
fore, S is decidable.
Theorem 5.4.15. Let S âŠ†â„•k. Then S is semi-decidable if and only if S is recursively enu-
merable.
Proof. Assume that S is semi-decidable. So cS is partial recursive. By Theorem 5.4.10, the
graph GcS( âƒ—x, y) of cS is recursively enumerable. Since

202
à±ª
5 Computability
âƒ—x âˆˆS
iff
âˆƒyGcS( âƒ—x, y),
Lemma 5.4.8(3) implies that S is recursively enumerable.
For the converse, suppose that S is recursively enumerable. Definition 5.4.3 implies
that there is a recursive (k + 1)-place relation R such that
S( âƒ—x)
iff
âˆƒpR( âƒ—x, p).
Since R is recursive, the characteristic function CR is recursive. Let h be the partial re-
cursive function
h( âƒ—x) = Î¼p(1 âˆ˜âˆ’CR( âƒ—x, p) = 0),
where h is the result of applying partial search (see Definition 5.2.18) to the recursive
function g( âƒ—x, p) = 1 âˆ˜âˆ’CR( âƒ—x, p). Then CR( âƒ—x, h( âƒ—x)) is the semi-characteristic function of S.
Therefore, S is semi-decidable.
We now show that a relation is recursive if and only if the relation and its comple-
ment are recursively enumerable.
Theorem 5.4.16. Let P âŠ†â„•k. Then P is recursive if and only if P and â„•k \P are recursively
enumerable.
Proof. Let P âŠ†â„•k. Then P and â„•k \ P are recursive. Lemma 5.4.6(1) implies that both
of these sets are recursively enumerable. Now assume that P and â„•k \ P are recursively
enumerable. Thus, there are recursive (k + 1)-relations R and S such that
âƒ—x âˆˆP
iff
âˆƒiR( âƒ—x, i),
(5.17)
âƒ—x âˆ‰P
iff
âˆƒiS( âƒ—x, i),
(5.18)
for all âƒ—x âˆˆâ„•k. Hence, for all âƒ—x âˆˆâ„•k, there exists an i such that R( âƒ—x, i) or S( âƒ—x, i). By
Lemma 5.4.6(2b), the relation â€œR( âƒ—x, i) or S( âƒ—x, i)â€ is recursive. So, by total search, the func-
tion h: â„•k â†’â„•defined by
h( âƒ—x) = Î¼i(R( âƒ—x, i)
or
S( âƒ—x, i))
is recursive. Since âƒ—x âˆˆP iff R( âƒ—x, h( âƒ—x)), it follows that P is recursive.
In Section 5.1.1 we presented an intuitive argument that was designed only to con-
firm Theorem 5.1.17. Theorems 5.4.14, 5.4.15, and 5.4.16 now provide a mathematically
rigorous proof of Theorem 5.1.17, which is restated below.
Theorem 5.4.17 (Kleene). Let S âŠ†â„•k. Then S is decidable if and only if S and its comple-
ment â„•k \ S are semi-decidable.

5.4 Recursively enumerable sets and relations
à±ª
203
Exercises 5.4.
1. Let f : â„•â†’â„•be recursive. Show that the semi-characteristic function of the range
of f , {f (x) : x âˆˆâ„•}, is partial recursive.
2. Let f : â„•â†’â„•be a recursive bijection. Show that f âˆ’1 is recursive.
3. Let A âŠ†â„•be the nonempty range of a partial recursive function. Show that A is
recursively enumerable.
4. Let A âŠ†â„•be recursively enumerable. Show that A is the domain of a partial re-
cursive function.
*5. Let h: â„•k â†’â„•be a partial function. Show that if Gh is recursively enumerable,
then h is partial recursive.
*6. Let f : â„•â†’â„•be a recursive function. Show that if f is strictly increasing, then its
range {f (x) : x âˆˆâ„•} is recursive.
*7. Let f : â„•â†’â„•be recursive, where ran(f ) = {f (x) : x âˆˆâ„•} is infinite.
(a) For all n âˆˆâ„•, show that there is an i > n such that (âˆ€j â‰¤n)(f (j)
Ì¸= f (i)).
(b) For all n âˆˆâ„•, let i be the least such that i > n and (âˆ€j â‰¤n)(f (j)
Ì¸= f (i)). Show
that (âˆ€j < i)(f (j)
Ì¸= f (i)).
(c) Define g: â„•â†’â„•by
g(n) = the least i âˆˆâ„•such that i > n and (âˆ€j < i)(f (j)
Ì¸= f (i)).
Show that g is recursive. Clearly, n < g(n) for all n âˆˆâ„•.
(d) Define h: â„•â†’â„•by h(0) = 0 and h(n + 1) = g(h(n)). Thus, h is recursive.
Show that h(n) < h(n + 1) for all n âˆˆâ„•. Hence, h is one-to-one and strictly
increasing.
(e) Show that f (h(n))
Ì¸= f (j) for all j < h(n), for each n âˆˆâ„•.
(f) Show that v: â„•â†’â„•defined by v(n) = f (h(n)) is one-to-one.
(g) Let y âˆˆran(f ) and let i âˆˆâ„•be the least such that f (i) = y. Therefore, (âˆ€j <
i)(f (j)
Ì¸= f (i)). Show that i = h(n) for some n. Now conclude that ran(v) =
ran(f ).
8. Let A âŠ†â„•be an infinite recursive set. Show that A is the range of a strictly increas-
ing recursive function.
9. Let A âŠ†â„•be an infinite recursively enumerable set. Show that there is an infinite
recursive set B such that B âŠ†A.
10. Prove Corollary 5.4.7.
*11. Let Q âŠ†â„•k+n be recursively enumerable. Prove that the relation
âˆƒi1âˆƒi2 . . . âˆƒinR( âƒ—x, i1, i2, . . . , in),
where âƒ—x âˆˆâ„•k, is recursively enumerable.
Exercise Notes: For Exercise 7(c), see Proposition 5.3.47. For Exercise 7(f), if not, then
by (d) there exists an n such that h(n) < i < h(n + 1). Exercise 7 shows that every infi-

204
à±ª
5 Computability
nite recursively enumerable subset of â„•is the range of a one-to-one recursive function.
For Exercise 9, by Definition 5.4.1 there is a recursive function f : â„•â†’â„•such that A
is the range of f . Use f to construct a strictly increasing recursive function h such that
the range of h is a subset of A; Exercise 6 (above) implies that the range of h is recur-
sive.

