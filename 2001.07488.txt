arXiv:2001.07488v1  [cs.PL]  21 Jan 2020
Profunctor optics, a categorical update
Bryce Clarke1, Derek Elkins2, Jeremy Gibbons3, Fosco Loregian4,
Bartosz Milewski5, Emily Pillmore2, and Mario Rom´an4,3
1Macquarie University, bryce.clarke1@hdr.mq.edu.au
2Independent researcher, derek.a.elkins@gmail.com, emilypi@cohomolo.gy
3University of Oxford, jeremy.gibbons@cs.ox.ac.uk
4Tallinn University of Technology foscoloregian@gmail.com,mroman@ttu.ee
5Programming Cafe, bartosz@relisoft.com
January 22, 2020
Abstract
Profunctor optics are bidirectional data accessors that capture data
transformation patterns such as accessing subﬁelds or iterating over con-
tainers. They are modular, meaning that we can construct accessors for
complex structures by combining simpler ones. Profunctor optics have
been studied only using Sets as the enriching category and in the non-
mixed case.
However, functional programming languages are arguably
better described by enriched categories and we have found that some
structures in the literature are actually mixed optics. Our work gener-
alizes a classic result by Pastro and Street on Tambara theory and uses
it to describe mixed V-enriched profunctor optics and to endow them
with V-category structure. We provide some original families of optics
and derivations, including an elementary one for traversals that solves an
open problem posed by Milewski. Finally, we discuss a Haskell implemen-
tation.
Keywords: lens, profunctor, Tambara module, coend calculus.
1

Contents
1
Introduction
3
1.1
Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.2
Synopsis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.3
Setting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
2
Optics
5
3
Examples of optics
6
3.1
Lenses and prisms
. . . . . . . . . . . . . . . . . . . . . . . . . .
6
3.1.1
Lenses . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
3.1.2
Lenses in a symmetric monoidal category . . . . . . . . .
8
3.1.3
Monadic lenses . . . . . . . . . . . . . . . . . . . . . . . .
8
3.1.4
Lenses with algebraic context . . . . . . . . . . . . . . . .
9
3.1.5
Lenses in a closed category
. . . . . . . . . . . . . . . . .
11
3.1.6
Prisms . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
3.2
Traversals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
3.2.1
Aﬃne traversals
. . . . . . . . . . . . . . . . . . . . . . .
15
3.2.2
Kaleidoscopes . . . . . . . . . . . . . . . . . . . . . . . . .
16
3.3
Grates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
3.3.1
Grates . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
3.3.2
Glasses
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
3.4
Getters, reviews and folds . . . . . . . . . . . . . . . . . . . . . .
19
3.5
Setters and adapters . . . . . . . . . . . . . . . . . . . . . . . . .
20
3.6
Optics for (co)free
. . . . . . . . . . . . . . . . . . . . . . . . . .
21
4
Tambara theory
22
4.1
Generalized Tambara modules . . . . . . . . . . . . . . . . . . . .
23
4.2
Pastro-Street’s “double” comonad
. . . . . . . . . . . . . . . . .
24
4.3
Pastro-Street’s “double” promonad . . . . . . . . . . . . . . . . .
30
4.4
Profunctor representation theorem . . . . . . . . . . . . . . . . .
33
5
Conclusions
33
5.1
Van Laarhoven encoding . . . . . . . . . . . . . . . . . . . . . . .
34
5.2
Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
5.3
Further work . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
6
Acknowledgements
36
7
Appendix: Haskell implementation
39
7.1
Concepts of enriched category theory . . . . . . . . . . . . . . . .
39
7.2
Mixed profunctor optics . . . . . . . . . . . . . . . . . . . . . . .
40
7.3
Combinators
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
41
7.4
Table of optics
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
2

1
Introduction
In functional programming, optics are a compositional representation of many
common patterns in bidirectional data accessing. They are provided by libraries
such as Kmett’s lens [Kme18], O’Connor’s mezzolens [O’C15b], or purescript
profunctor lenses by Freeman et al. [FMH+19]. Optics, and more concretely
lenses, were originally used in functional programming as a compositional so-
lution to the problem of accessing ﬁelds of nested data structures [FGM+05].
As the understanding of these data accessors grew, diﬀerent families of optics
were introduced for a variety of diﬀerent types (e.g. prisms for tagged unions or
traversals for containers), each one of them capturing a particular data access-
ing pattern. These families are intercomposable and together form a powerful
language for modular data access.
Perhaps surprisingly, optics can be composed using ordinary function com-
position; an example can be seen in Figure 1. This is thanks to an alternative
encoding called profunctor representation. In this encoding, each optic is written
as single function that is polymorphic over profunctors with a certain algebraic
structure. For instance, lenses can be written as functions polymorphic over
cartesian profunctors whereas prisms can be written as functions polymorphic
over cocartesian profunctors [PGW17, §3]. Milewski [Mil17] has identiﬁed these
structures (cartesian, cocartesian, . . . ) as Tambara modules [Tam06] and has
used a result by Pastro and Street [PS08] to propose a uniﬁed deﬁnition of optic.
That deﬁnition has been later extended by Boisseau and Gibbons [BG18] and
Riley [Ril18], using slightly diﬀerent techniques and proposing laws for optics.
However, the original result by Pastro and Street cannot be used directly to
unify all the optics that appear in practice. Our work generalizes their result,
going beyond the previous deﬁnitions of optic and covering mixed [Ril18, §6.1]
and enriched optics.
let home = "221b Baker St, London, UK"
address :: Prism Address String
street
:: Lens
String
Address
>>> home?. address.street
Just "221b Baker St"
>>> home & address.street.˜ "4 Marylebone Rd"
"4 Marylebone Rd, London, UK"
Figure 1: The composition of a prism (address) and a lens (street)
is used to parse a string and then access and modify one of its
subﬁelds.
The generalized profunctor representation theorem captures optics already
present in the literature and makes it possible to upgrade them to more sophis-
ticated deﬁnitions. For instance, many generalizations of lenses in functional
3

programming are shown to be particular cases of a more reﬁned deﬁnition that
uses mixed optics (Deﬁnition 3.1). We also show derivations for some new op-
tics that were not present in the literature.
Finally, Milewski [Mil17] posed
the problem of ﬁtting the three basic optics (lenses, prisms and traversals) into
an elementary pattern; lenses and prisms had been covered in his work, but
traversals were missing. We present a new description of traversals in terms of
power series functors whose derivation is more direct than the ones based on
traversables as studied by Jaskelioﬀand Rypacek [JR12].
1.1
Contributions
• We extend the double construction from Pastro and Street’s “Doubles for
monoidal categories” to cover mixed optics. In the same way that they char-
acterize copresheaves of these doubles as Tambara modules, we characterize
copresheaves of mixed optics as suitably generalized Tambara modules [PS08,
Proposition 6.1].
• A study of enriched and mixed optics [Ril18, §6.1], endowing them with V-cat-
egory structure.
• An extension of the result that justiﬁes the profunctor representation of optics
used in functional programming to the case of enriched and mixed optics.
• A new family of optics, which we dub algebraic lenses (Deﬁnition 3.9), that
uniﬁes new examples with some optics already present in the literature, such
as Boisseau’s achromatic lens [Boi17, §5.2].
• A new derivation showing that monadic lenses [ACG+16] are mixed optics
(Proposition 3.7). Similarly, a new derivation showing that Myers’ lenses in a
symmetric monoidal category [Spi19, §2.2] are mixed optics (Proposition 3.5).
• A uniﬁed deﬁnition of lenses, that can be specialized to all of these previous
examples.
• A new derivation of the optic known as traversal (Deﬁnition 3.21) in terms of
a monoidal structure originally described by Kelly [Kel05, §8] for the study
of non-symmetric operads (Proposition 3.23). Following this, a new family of
optics that arises when we generalize this monoidal structure.
1.2
Synopsis
We introduce the deﬁnition of mixed optic in Section 2. Section 3 describes ex-
amples from the practice of functional programming and how they are captured
by the deﬁnition. Section 4 describes how the theory of Tambara modules can
be applied to obtain a profunctor representation for optics.
4

1.3
Setting
We shall work with categories enriched over a B´enabou cosmos (V, ⊗, I); that is,
a (small)-complete and cocomplete symmetric monoidal closed category. In par-
ticular, V is enriched over itself and we write the internal hom-object between
A, B ∈Obj(V) as V(A, B) or just [A, B] when it does not cause ambiguity. Our
intention is to keep a close eye on the applications in functional programming:
the enriching category V should be thought of as the category whose objects
model the types of an idealized programming language and whose morphisms
model the programs. Because of this, V will be cartesian in many of the exam-
ples. We can, however, remain agnostic as to which speciﬁc V we are addressing.
For calculations, we make signiﬁcant use of coend calculus as described, for
instance, by Loregian [Lor19]. The proofs in this paper can be carried without
assuming choice or excluded middle, but there is an important set-theoretical
issue: in some of the examples, we compute coends over non-small categories.
We implicitly ﬁx a suitable Grothendieck universe and our categories are to
be considered small with respect to that universe. As Riley [Ril18, §2] notes,
this will not be a problem in general: even if some coends are indexed by large
categories and we cannot argue their existence using the cocompleteness of Sets,
we will still ﬁnd them represented by objects in the category.
2
Optics
The structure that is common to all optics is that they divide a bigger data
structure of type S ∈C into some focus of type A ∈C and some context or
residual M ∈M around it. We cannot access the context but we can still use
its shape to update the original data structure, replacing the current focus by
a new one. The deﬁnition will capture this fact imposing a quotient relation on
the possible contexts; this quotient is expressed by the dinaturality condition of
a coend. The category of contexts M will be monoidal, allowing us to compose
optics with contexts M and N into an optic with context M ⊗N. Finally,
we leave open the possibility of the new focus being of a diﬀerent type B ∈D,
possibly in a diﬀerent category, which yields a new data structure of type T ∈D.
Let (M, ⊗, I, a, λ, ρ) be a monoidal V-category as deﬁned by Day [Day70].
Let it act on two arbitrary V-categories C and D with strong monoidal V-func-
tors ( L ): M →[C, C] and ( R ): M →[D, D]. We write
φA : A ∼= I
L A,
φM,N,A : M
L N
L A ∼= M ⊗N
L A,
ϕB : B ∼= I
R B,
ϕM,N,B : M
R N
R B ∼= M ⊗N
R B,
for the structure isomorphisms of the strong monoidal actions
L and
R .
Deﬁnition 2.1 (after [Ril18, §6.1], see also [Mil17, BG18]). Let S, A ∈C and
T, B ∈D. An optic from (S, T ) with the focus on (A, B) is an element of the
following object described as a coend
Optic L , R ((A, B), (S, T )) :=
Z M
C(S, M
L A) ⊗D(M
R B, T ).
5

The two strong monoidal actions
L and
R represent the two diﬀerent ways
in which the context interacts with the focus: one when the data structure
is decomposed and another one, possibly diﬀerent, when it is reconstructed.
Varying these two actions we will cover many examples from the literature and
propose some new ones, as the following table summarizes.
Name
Description
Ref.
Adapter (Opticid,id)
C(S, A) ⊗D(B, T )
3.41
Lens (Optic×,•)
C(S, A) × D(S • B, T )
3.1
Monoidal lens (Optic⊗,U×)
CCom(S, A) × C(US ⊗B, T )
3.4
Algebraic lens (OpticU ×,U•)
C(S, A) × D(ΨS • B, T )
3.9
Monadic lens (Optic×,⋊)
W(S, A) × W(S × B, ΨT )
3.6
Linear lens (Optic⊗,•)
C(S, {B, T } • A)
3.15
Prism (Optic•,+)
C(S, T • A) × D(B, T )
3.17
Coalg. prism (OpticU •,U+)
C(S, ΘT • A) × D(B, T )
3.20
Grate (Optic{},•)
D({S, A} • B, T )
3.30
Glass (Optic×[],×[])
C(S × [[S, A], B], T )
3.32
Aﬃne traversal (Optic+⊗,+⊗)
C(S, T + A ⊗{B, T })
3.25
Traversal (OpticPw,Pw)
V(S,
R n An ⊗[Bn, T ])
3.21
Kaleidoscope (OpticApp,App)
R
n V([An, B], [Sn, T ])
3.27
Setter (Opticev,ev)
V([A, B], [S, T ])
3.38
Fold (OpticFoldable,∗)
V(S, LA)
3.35
The purpose of an abstract uniﬁed deﬁnition is twofold: ﬁrstly, it provides a
framework to classify existing optics and explore new ones, as we do in Section 3;
and secondly, it enables a uniﬁed profunctor representation, which we present
in Section 4.
3
Examples of optics
3.1
Lenses and prisms
In functional programming, lenses can be seen as accessors for a particular
subﬁeld of a data structure. Lenses are given by two functions: the view function
that accesses the subﬁeld; and the update function that overwrites its contents.
view :: s -> a
update :: s -> b -> t
The deﬁnition of lens has its origin in Oles’ thesis [Ole82], but this basic deﬁni-
tion has been generalized in many diﬀerent directions. Monadic lenses [ACG+16]
try to unify many of the already proposed ways of combining lenses and monadic
eﬀects. Myers’ lenses in a symmetric monoidal category [Spi19, §2.2] are a dif-
ferent notion that provides an analogue of the view and update functions in
arbitrary symmetric monoidal categories. Riley also describes a notion of linear
lenses with their laws in an arbitrary monoidal closed category [Ril18, §4.8].
6

Boisseau [Boi17, §5.2] introduced the achromatic lens responding to the fact
that sometimes lenses come endowed with a create function along the usual
view and update.
However, these generalizations are not mutually compatible in general. They
use the cartesian or monoidal structure to get the view function in diﬀerent
ways. Many of them include a monad at some point in the type signature,
and then deﬁne a particular variant of lens composition that takes that monad
into account. Some of them, such as monoidal lenses or lenses in a symmetric
monoidal category were not presented as optics, and a profunctor representation
for them was not considered.
We present two derivations of lenses as mixed optics that capture all of
the variants mentioned before and endow all of them with a uniﬁed profunctor
representation (Theorem 4.13). The ﬁrst derivation is based on the cartesian
structure. It generalizes the original one by Milewski [Mil17] and allows us to
show that Myers’ lenses (Deﬁnition 3.4) and monadic lenses (Deﬁnition 3.6) are
also particular cases of mixed optic. The derivation can be then reﬁned to also
cover achromatic lenses and describe some new variants of optic with poten-
tial applications in functional programming that were missing in the literature.
The second derivation uses the closed structure instead, and slightly generalizes
Riley’s linear lenses [Ril18, §4.8].
3.1.1
Lenses
The key ingredient for most variants of lenses is a cartesian monoidal structure.
Throughout this section, we take a cartesian closed category (W, ×, 1) as our
base for enrichment. A monoidal W-category (C, ×, 1) is cartesian if there exist
W-natural isomorphisms C(Z, X × Y ) ∼= C(Z, X) × C(Z, Y ) and C(X, 1) ∼= 1.
Deﬁnition 3.1. Let C be a cartesian W-category with a monoidal W-action
(•): C × D →D to an arbitrary W-category D. A lens is an element of
Lens((A, B), (S, T )) := C(S, A) × D(S • B, T ).
Proposition 3.2. Lenses are mixed optics (as in Deﬁnition 2.1) for the actions
of the cartesian product (×): C × C →C and (•): C × D →D.
That is,
Lens ∼= Optic(×,•).
Proof. The product (×): C2 →C is right adjoint to the diagonal functor.
Z C∈C
C(S, C × A) × D(C • B, T )
∼=
(Product)
Z C∈C
C(S, C) × C(S, A) × D(C • B, T )
∼=
(coYoneda)
C(S, A) × D(S • B, T ).
7

Remark 3.3. The previous deﬁnition can be specialized to the pair C(S, A) ×
C(S × B, T ) if we take C = D and we let (•) be the cartesian product.
3.1.2
Lenses in a symmetric monoidal category
Deﬁnition 3.4 (Spi19, §2.2). Let C be a symmetric monoidal category, with
CCom its category of cocommutative comonoids and U : CCom →C the
forgetful functor. Let S, A ∈CCom and B, T ∈C. A monoidal lens is an
element of
mLens⊗((A, B), (S, T )) := CCom(S, A) × C(US ⊗B, T ).
Proposition 3.5. Monoidal lenses are a particular case of Deﬁnition 3.1.
Proof. The category of cocommutative comonoids CCom over a category C
can be given a cartesian structure in such a way that the forgetful functor
U : CCom →C is strict monoidal (see [Fox76], where a stronger result is
shown). The symmetric structure is needed to endow the monoidal product
of two comonoids with a canonical comonoid structure.
We take the action
(•) in Deﬁnition 3.1 to be given by S • A := US ⊗A. That is, mLens⊗∼=
Optic(⊗,U⊗).
3.1.3
Monadic lenses
Monadic lenses [ACG+16] were proposed for combining lenses with monadic
eﬀects. Their update function can be partial or non-deterministic, and they can
account for side eﬀects.
box :: (Show b) => MonadicLens Log a b (Box a) (Box b)
return (Box 42)
>>= mupdate box "hello"
>>= mupdate box "world"
>>> [box]: contents changed to "hello".
>>> [box]: contents changed to "world".
>>> Box{"world"}
Figure 2: A polymorphic family of type-changing monadic lenses
for a logging monad (Log) is used to track each time a data holder
(Box) is accessed.
Deﬁnition 3.6 (ACG+16, §2.3). Let Ψ: W →W be a W-monad. A monadic
lens for Ψ is an element of
MndLensΨ((A, B), (S, T )) := W(S, A) × W(S × B, ΨT ).
Proposition 3.7. Monadic lenses are a particular case of Deﬁnition 3.1.
8

Proof. First, note that every W-endofunctor is strong. Thus, the W-monad Ψ
comes with a W-natural family θX,Y : X × Ψ(Y ) →Ψ(X × Y ). This induces a
W-action (⋊): W × Kl(Ψ) →Kl(Ψ) deﬁned as the composite
W(A, ΨB) × W(X, Y )
W(X × A, Y × ΨB)
W(X × A, Ψ(Y × B)).
(×)
θ
We can note that KlΨ(S ⋊B, T ) := W(S × B, ΨT ). Monadic lenses can be
rewritten as lenses (as in Deﬁnition 3.1) where the action (•) is given by (⋊): C×
Kl(Ψ) →Kl(Ψ). That is, MndLensΨ ∼= Optic(×,⋊).
Remark 3.8. This technique is similar to the one used by Riley to describe a
non-mixed variant called eﬀectful lenses [Ril18, §4.9].
3.1.4
Lenses with algebraic context
We can further generalize Deﬁnition 3.1 if we allow the context over which we
take the coend to be an algebra for a ﬁxed monad. The motivation is that lenses
with a context like this appear to have direct applications in programming; for
instance, Boisseau’s achromatic lens [Boi17, §5.2] is a particular case of this
deﬁnition.
These algebraic lenses should not be confused with the previous
monadic lenses in Deﬁnition 3.6.
Deﬁnition 3.9. Let Ψ: C →C be a W-monad in a cartesian W-category C.
Let (•): C × D →D be a monoidal W-action to an arbitrary W-category D.
An algebraic lens is an element of
LensΨ((A, B), (S, T )) := C(S, A) × D(ΨS • B, T ).
Proposition 3.10. Algebraic lenses are mixed optics (as in Deﬁnition 2.1) for
the actions of the product by the carrier of an algebra (U×): EMΨ ×C →C
and (U•): EMΨ ×D →D. That is, LensΨ ∼= Optic(U×,U •).
Proof. Products in C induce products in the W-category of algebras EMΨ which
are preserved by the forgetful functor U : EMΨ →C. Thus, the W-category
of algebras is cartesian, making the forgetful functor monoidal. The functor
(U×): EMΨ ×C →C, deﬁned by CU×A := UC × A, is a strong monoidal
action.
Z C∈EMΨ
C(S, UC × A) × D(UC • B, T )
∼=
(Product)
Z C∈EMΨ
C(S, UC) × C(S, A) × D(UC • B, T )
∼=
(Free-forgetful adjunction)
9

Z C∈EMΨ
EMΨ(ΨS, C) × C(S, A) × D(UC • B, T )
∼=
(coYoneda)
C(S, A) × D(ΨS • B, T ).
Remark 3.11. Algebraic lenses are a new optic. Let D = C and let (•) be the
cartesian product. An algebraic lens is given by the usual view function that
accesses the subﬁeld, and a variant of the update function that takes an element
inside a monad.
view :: s -> a
algUpdate :: m s -> b -> t
Remark 3.12. In particular, the case where Ψ is the list monad L: V →V
deﬁnes a new optic, which we dub a classifying lens. We propose to use them
as lenses that can also be trained to classify a new focus into a complete data
structure, as in Figure 3.
let iris =
[ Iris Setosa 4.9 3.0 1.4, 0.2
, Iris Setosa 4.7 3.2 1.3 0.2
, ...
, Iris Virginica 5.9 3.0 5.1 1.8 ]
measure :: AlgLens [] Measurements Flower
iris!!4 ˆ. measure
>>> (5.0, 3.6, 1.4, 0.2)
iris & measure .? Measurements (4.8, 3.2, 3.5, 2.1)
>>> Iris Versicolor (4.8, 3.1, 1.5, 0.1)
Figure 3: A classifying lens (measure) is used both for accessing
a the measurements of a point in the iris dataset and to classify
new measurements into a species (Versicolor).
They are given by two functions, the usual view function that accesses the
focus, and a classify function that takes a list of examples together with some
piece of data and produces a new example.
view :: s -> a
classify :: [s] -> b -> t
Remark 3.13. The case in which Ψ is the maybe monad M: V →V was studied
by Boisseau [Boi17, §5.2] and is known as the achromatic lens. It is motivated
by the fact that, sometimes in practice, lenses come naturally equipped with a
create function [FGM+05, §3] along the usual view and update.
10

view :: s -> a
update :: s -> b -> t
create :: b -> t
For this implementation, we note that
C(S, A) × C(MS × B, T ) ∼= C(S, A) × C(S × B, T ) × C(B, T ).
Remark 3.14. What Riley [Ril18, §4.10] calls achromatic lens,
C(S, {B, T } + 1) × C(S, A) × C(B, T ),
is actually the optic for the action ⊙: C →[C, C] deﬁned by M ⊙A := (M +
1) × A. Perhaps confusingly, this is not equivalent to Boisseau’s achromatic
lens, which is the optic for the action (×): M-Alg →[C, C] of the product by
pointed objects. In order to amend this clash of terminology, we call this second
optic the apochromatic lens. It can be implemented by a view and create
functions, together this time with a maybeUpdate that is allowed to fail.
view :: s -> a
maybeUpdate :: s -> Maybe (b -> t)
create :: b -> t
3.1.5
Lenses in a closed category
Linear lenses (as described by Riley [Ril18, §4.8]) are a diﬀerent generalization
of lenses that relies on a closed monoidal structure. Its advantage is that we do
not need to require our enriching category to be cartesian anymore.
Deﬁnition 3.15 (Ril18, §4.8). Let (D, ⊗, {}) be a right closed V-category with
a monoidal V-action (•): D ⊗C →C to an arbitrary V-category C. A linear
lens is an element of
Lens{}((A, B), (S, T )) := C(S, {B, T } • A).
Proposition 3.16. Linear lenses are mixed optics (as in Deﬁnition 2.1) for
the actions of the monoidal product (⊗): D × D →D and (•): D × C →C.
That is, Lens{} ∼= Optic⊗,•
Proof. The monoidal product has a right adjoint given by the exponential.
Z D∈D
C(S, D • A) ⊗D(D ⊗B, T )
∼=
(Closedness)
Z D∈D
C(S, D • A) ⊗D(D, {B, T })
∼=
(coYoneda)
C(S, {B, T } • A).
11

3.1.6
Prisms
In functional programming, prisms pattern match on data structures, allowing
for failure. They are given by a match function that tries to access the matched
structure and a build function that constructs an abstract type from one of its
alternatives.
match :: s -> Either t a
build :: b -> t
Prisms happen to be lenses in the opposite category. However, they can also be
described as optics in the original category for a diﬀerent pair of actions. We
will provide a derivation of prisms that is dual to our derivation of lenses for a
cartesian structure. This derivation spcializes to the pair C(S, T +A)×C(B, T ).
Deﬁnition 3.17. Let D be a cocartesian W-category with a monoidal W-action
(•): D × C →C to an arbitrary category C. A prism is an element of
Prism((A, B), (S, T )) := C(S, T • A) × D(B, T ).
In other words, a prism from (S, T ) to (A, B) is a lens from (T, S) to (B, A) in
the opposite categories Dop and Cop. However, they can also be seen as optics
from (A, B) to (S, T ).
Proposition 3.18. Prisms are mixed optics (as in Deﬁnition 2.1) for the ac-
tions of the coproduct (+): D × D →D and (•): C × D →D.
That is,
Prism ∼= Optic(•,+).
Proof. The coproduct (+): C2 →C is left adjoint to the diagonal functor.
Z D∈D
C(S, D • A) × D(D + B, T )
∼=
(Coproduct)
Z D∈D
C(S, D • A) × D(D, T ) × D(B, T )
∼=
(coYoneda)
C(S, T • A) × D(B, T ).
Remark 3.19 (Prisms in a symmetric monoidal category). Let C be a symmet-
ric monoidal (plain) category. Its category of commutative monoids, CMon,
can be given a cocartesian structure in such a way that the forgetful functor
U : CMon →C is strict monoidal. A monoidal prism is an element of
mPrism((A, B), (S, T )) := C(S, UT ⊗A) × CMon(B, T ).
Remark 3.20 (Prisms with coalgebraic context). Let Θ be a W-comonad in a
cocartesian W-category D. Let (•): D × C →C be a monoidal action to an
arbitrary W-category C. Coproducts in D induce coproducts in the category of
12

coalgebras EMΘ which are preserved by the forgetful W-functor U : EMΘ →D.
A coalgebraic prism is an element of
PrismΘ((A, B), (S, T )) := C(S, ΘT • A) × D(B, T ).
The coalgebraic variant for a comonad (c) is given by a cMatch function, that
captures the failure into a comonad, and the usual build function.
cMatch :: s -> Either (c t) a
build :: b -> t
3.2
Traversals
In functional programming, traversals extract the elements of a container into
an ordered list, allowing us to iterate over the elements without altering the
container (Figure 4).
let mail =
[ "43 Adlington Rd, Wilmslow, United Kingdom"
, "26 Westcott Rd, Princeton, USA"
, "St James's Square, London, United Kingdom"
]
each
:: Traversal String
[String]
address :: Prism
Address String
city
:: Lens
String
Address
>>> mail & each.address.city %˜ uppercase
[ "43 Adlington Rd, WILMSLOW, United Kingdom"
, "26 Westcott Rd, PRINCETON, USA"
, "St James's Square, LONDON, United Kingdom"
]
Figure 4:
The composition of a traversal (each) with a prism
(address) and a lens (city) is used to parse a collection of strings
and modify one of their subﬁelds.
Traversals are constructed from a single extract function that both outputs
the elements and takes a new list to update them.
extract :: s -> ([a], [b] -> t)
Usually, we ask the length of the input to the function of type [b] -> t to be
the same as the length of [a]. This restriction can be also encoded into the
type when dependent types are available.
Deﬁnition 3.21. A traversal is an element of
Traversal((A, B), (S, T )) := V
 
S,
Z n∈N
An ⊗[Bn, T ]
!
.
13

Remark 3.22. Let (N, +) be the free strict monoidal category on one object.
Ends and coends indexed by N coincide with products and coproducts, respec-
tively. Here A(−) : N →C is the unique monoidal V-functor sending the gener-
ator of N to A ∈C. Each functor C : N →V induces a power series
PwC(A) =
Z n∈N
An ⊗Cn.
This deﬁnes an action Pw: [N, C] →[C, C] sending the indexed family to its
power series (see Remark 3.24). We propose a derivation of the traversal as the
optic for power series.
Proposition 3.23. Traversals are optics (as in Deﬁnition 2.1) for power series.
That is, Traversal ∼= OpticPw,Pw.
Proof. The derivation generalizes that of linear lenses (Deﬁnition 3.15).
Z C∈[N,V]
V
 
S,
Z n∈N
Cn ⊗An
!
⊗V
 Z n∈N
Cn ⊗Bn, T
!
∼=
(Continuity)
Z C∈[N,V]
V
 
S,
Z n∈N
Cn ⊗An
!
⊗
Z
n∈N
V (Cn ⊗Bn, T )
∼=
(Currying)
Z C∈[N,V]
V
 
S,
Z n∈N
Cn ⊗An
!
⊗
Z
n∈N
V (Cn, [Bn, T ])
∼=
(Natural transformation as an end)
Z C∈[N,V]
V
 
S,
Z n∈N
Cn ⊗An
!
⊗[N, V]

C(−), [B(−), T ]

∼=
(coYoneda)
V
 
S,
Z n∈N
An ⊗[Bn, T ]
!
.
The derivation from the general deﬁnition of optic to the concrete descrip-
tion of lenses and prisms in functional programming was ﬁrst described by
Milewski [Mil17], but ﬁnding a derivation of traversals like the one presented
here, ﬁtting the same elementary pattern as lenses or prisms, was left as an
open problem. It should be noted, however, that derivations of the traversal as
the optic for a certain kind of functor called Traversables (which should not
be confused with traversals themselves) have been previously described by Bois-
seau and Gibbons [BG18] and Riley [Ril18]. For a derivation using Yoneda, Ri-
ley [Ril18] recalls a parameterised adjunction that has an equational proof in the
work of Jaskelioﬀand O’Connor [JO15]. These two derivations do not contra-
dict each other: two diﬀerent classes of functors can generate the same optic, for
14

instance, if the adjunction describing both of them gives rise to the same monad.
This seems to be the case here: traversables are coalgebras for a comonad and
power series are the cofree coalgebras for the same comonad [Rom19, §4.2].
In the Sets-based case, the relation between traversable functors, applicative
functors [MP08] and these power series functors has been studied by Jaskelioﬀ
and Rypacek [JO15].
Remark 3.24. The V-functor Pw: [N, V] →[V, V] is actually a strong monoidal
action thanks to the fact that two power series functors compose into a power
series functor.
Z m∈N  Z n∈N
An ⊗Cn
!m
⊗Dm
∼=
(Product distributes over colimits)
Z m Z n1,...,nm
An1 ⊗· · · ⊗Anm ⊗Cn1 ⊗· · · ⊗Cnm ⊗Dm
∼=
(Rearranging terms)
Z k∈N
Ak ⊗
 
X
n1+···+nm=k
Cn1 ⊗· · · ⊗Cnm ⊗Dm
!
.
We are then considering an implicit non-symmetric monoidal structure where
the monoidal product (•): [N, V] ⊗[N, V] →[N, V] of Cn and Dn can be written
as
Z m Z n1,...,nm
N(n1 + · · · + nm, k) ⊗Cn1 ⊗· · · ⊗Cnm ⊗Dm.
This is precisely the structure described by Kelly [Kel05, §8] for the study of
non-symmetric operads. A similar monoidal structure is described there when
we substitute N by (P, +), the V-category of permutations deﬁned as the free
strict symmetric monoidal category on one object. The same derivation can be
repeated with this new structure to obtain an optic similar to the traversal and
given by
V
 
S,
Z n∈P
An ⊗[Bn, T ]
!
.
3.2.1
Aﬃne traversals
Aﬃne traversals strictly generalize prisms and linear lenses in the non-mixed
case allowing a lens-like accessing pattern to fail; they are used to give a concrete
representation of the composition between a lens and a prism. An aﬃne traversal
is implemented by a single access function.
access :: s -> Either t (a , b -> t)
Deﬁnition 3.25. Let W be cartesian closed and let C be a symmetric monoidal
closed W-category that is also cocartesian. An aﬃne traversal is an element
of
Aﬃne⊗((A, B), (S, T )) := C(S, T + A ⊗{B, T }).
15

Proposition 3.26. Aﬃne traversals are optics (as in Deﬁnition 3.1) for the
action (+⊗): C2 →[C, C] that sends C, D ∈C to the functor C + D ⊗(−).
That is, Aﬃne⊗∼= Optic(+⊗),(+⊗).
Proof. The action uses that monoidal product distributes over the coproduct.
Z C,D
C(S, C + D ⊗A) × C(C + D ⊗B, T )
∼=
(Coproduct)
Z C,D
C(S, C + D ⊗A) × C(C, T ) × C(D ⊗B, T )
∼=
(coYoneda, Exponential)
Z D
C(S, T + D ⊗A) × C(D, {B, T })
∼=
(coYoneda)
C(S, T + A ⊗{B, T }).
3.2.2
Kaleidoscopes
Applicative functors are commonly considered in functional programming as
they provide a convenient generalization to monads with better properties for
composition. It is a natural then to ask what is the optic associated to applica-
tive functors. Applicative functors in [V, V] are monoids with respect to Day
convolution (∗): [V, V] × [V, V] →[V, V], deﬁned as the following coend
(F ∗G)(A) =
Z X,Y ∈V
V(X ⊗Y, A) ⊗FX ⊗GY.
Applicative functors form a V-category of monoids App. Alternatively, they
are lax monoidal V-functors for the cartesian structure. It is a basic result in
category theory [ML78, §VII, Theorem 2] that, as the category [V, V] has denu-
merable colimits and Day convolution distributes over them, the free applicative
functor can be computed as I + F + F ∗2 + F ∗3 + . . ..
Deﬁnition 3.27. A kaleidoscope is an element of
Kaleidoscope((A, B), (S, T )) :=
Y
n∈N
V ([An, B], [Sn, T ]) .
Proposition 3.28. Kaleidoscopes are optics for the action of applicative func-
tors.
Proof. Let U : App →[V, V] be the forgetful functor from the category of ap-
plicatives.
Z F ∈App
V(S, UFA) ⊗V(UFB, T )
16

∼=
(Yoneda)
Z F ∈App
V

S,
Z
C∈V
[[A, C], UFC]

⊗V(UFB, T )
∼=
(Continuity)
Z F ∈App Z
C
V (S, [[A, C], UFC]) ⊗V(UFB, T )
∼=
(Exponential)
Z F ∈App Z
C
V ([A, C] ⊗S, UFC)

⊗V(UFB, T )
∼=
(Natural transformations as ends)
Z F ∈App
Nat ([A, −] ⊗S, UF) ⊗V(UFB, T )
∼=
(Free applicative)
Z F ∈App
App
 X
n∈N
[An, −] ⊗S, F
!
⊗V(UFB, T )
∼=
(coYoneda)
V
 X
n∈N
Sn ⊗[An, B], T
!
∼=
(Continuity and exponential)
Y
n∈N
V ([An, B], [Sn, T ]) .
Remark 3.29. The free applicative we construct here is known in Haskell pro-
gramming as the FunList applicative. In the same way that traversables are
written in terms of lists, we can approximate Kaleidoscopes as a single func-
tion aggregate that takes a folding for the foci and outputs a folding for the
complete data structure. Kaleidoscopes are a new optic, and we propose to use
them as accessors for pointwise foldable data structures.
aggregate :: ([a] -> b) -> ([s] -> t)
Kaleidoscopes pose a problem on the side of applications: they cannot be
composed with lenses to produce new kaleidoscopes.
This is caused by the
fact that the constraint deﬁning them (Applicative) is not a superclass of the
constraint deﬁning lenses: a functor given by a product is not applicative, in
general. However, a functor given by a product by a monoid is applicative.
This means that applicatives can be composed with lenses whose residual is a
monoid (Deﬁnition 3.9).
17

measure :: AlgebraicLens [] Measurements Flower
aggregate :: Kaleidoscope Float Measurements
iris & measure.aggregate >- mean
>>> Iris Versicolor; Sepal (5.843, 3.054); Petal (3.758, 1.198)
Figure 5:
Following the previous Example 3, a kaleidoscope
(aggregate) is composed with an algebraic lens to create a new
point on the dataset by aggregating measurements with some func-
tion (mean, maximum) and then classifying it.
3.3
Grates
3.3.1
Grates
Grates create a new structure provided a way of creating a new focus from a
view function. They are given by a single grate function with the form of a
nested continuation.
grate :: ((s -> a) -> b) -> t
Deﬁnition 3.30. Let C be a symmetric monoidal closed V-category.
Let
(•): C × D →D be an arbitrary action. A grate is an element of
Grate ((A, B), (S, T )) := D({S, A} • B, T ).
Proposition 3.31. Grates are mixed optics for the action of the exponential
and (•): C × D →D. That is, Grate ∼= Optic{},•.
Proof. The exponential is right adjoint to the monoidal product.
Z C∈C
C(S, {C, A}) ⊗D(C • B, T )
∼=
(Exponential)
Z C∈C
C(S ⊗C, A) ⊗D(C • B, T )
∼=
(Exponential)
Z C∈C
C(C, {S, A}) ⊗D(C • B, T )
∼=
(coYoneda)
D({S, A} • B, T )
The description of a grate and its profunctor representation in terms of
“closed” profunctors was ﬁrst reported by Deikun and O’Connor [O’C15a]; it
can be seen as a consequence of the profunctor representation theorem (Theo-
rem 4.13).
18

3.3.2
Glasses
Glasses are a new optic that strictly generalizes grates and lenses for the carte-
sian case. In functional programming, glasses can be implemented by a single
function glass that takes a way of transforming views into new foci and uses
it to update the data structure. We propose to use them as a the concrete
representation of the composition of lenses and grates.
glass :: ((s -> a) -> b) -> (s -> t)
Deﬁnition 3.32. Let W be a cartesian B´enabou cosmos and let C be a carte-
sian closed W-category. A glass is an element of
Glass ((A, B), (S, T )) := C(S × [[S, A], B], T ).
Proposition 3.33. Glasses are optics for the action (×[]): Cop × C →[C, C]
that sends C, D ∈C to the W-functor D × [C, −].
Proof.
Z C,D
C(S, C × [D, A]) × C([D, B] × C, T )
∼=
(Product)
Z C,D
C(S, C) × C(S, [D, A]) × C([D, B] × C, T )
∼=
(coYoneda)
Z D
C(S, [D, A]) × C([D, B] × S, T )
∼=
(Exponential)
Z D
C(D, [S, A]) × C([D, B] × S, T )
∼=
(coYoneda)
C([[S, A], B] × S, T ).
3.4
Getters, reviews and folds
Some constructions, such as plain morphisms, are regarded as corner cases of
optics in the lens library. We will describe these constructions (getters, reviews
and folds [Kme18]) as mixed optics. All of them set one of the two base cate-
gories to be the terminal category and, contrary to most optics, they act only
unidirectionally. In some sense, they are degenerate cases of the deﬁnition of
mixed optic.
Deﬁnition 3.34. Let C be an arbitrary V-category. Getters are degenerate
optics for the trivial action on the covariant side.
Reviews are degenerate
optics for the trivial action on the contravariant side.
Getter((A, ∗), (S, ∗)) = C(S, A).
19

Review((∗, B), (∗, T )) = C(B, T ).
In other words, we ﬁx the case where M = 1 and D = 1 or C = 1, respectively.
The category of foldable functors is the slice category on the list functor
L: V →V, also known as the free monoid functor. Using the fact that L is a
monad, the slice category can be made monoidal in such a way that the forgetful
[V, V]/L →[V, V] becomes strong monoidal.
Deﬁnition 3.35. Folds are degenerate optics for the action of foldable functors.
Fold((A, ∗), (S, ∗)) =
Z F ∈Foldable
V(S, FA).
Folds admit a concrete description that we can reach by eliminating the
coend. From the deﬁnition of coend as colimits, a coend from a diagram category
with a terminal object is determined by the value at the terminal object.
Z F ∈Foldable
V(S, FA) ∼= V(S, LA).
Remark 3.36. The same technique can be used to prove that the optic for the
slice category over a monad G : V →V has a concrete form given by C(S, GA).
Remark 3.37. We obtain the usual implementations of getters as s -> a, of
reviews as b -> t and of folds as s -> [a]. Their profunctor representation
degenerates into a covariant or contravariant functor representation, which can
be seen as a more direct application of the Yoneda lemma.
3.5
Setters and adapters
Deﬁnition 3.38. A setter [Kme18] is an element of
Setter((A, B), (S, T )) := V([A, B], [S, T ]).
Proposition 3.39. Setters are optics for the evaluation of any endofunctor
ev: [V, V] →[V, V]. That is, Setter ∼= Opticev,ev.
Proof. The concrete derivation described by Riley [Ril18, §4.5.2] and his re-
quirement for strength can be transferred directly to the enriched case.
Z F ∈[V,V]
V(S, FA) ⊗V(FB, T )
∼=
(Yoneda)
Z F ∈[V,V] Z
C∈V
[V(A, C), V(S, FC)]

⊗V(FB, T )
∼=
(Exponential)
Z F ∈[V,V] Z
C∈V
V(S ⊗[A, C], FC)

⊗V(FB, T )
20

∼=
(Natural transformation as an end)
Z F ∈[V,V]
[V, V](S ⊗[A, −], F) ⊗V(FB, T )
∼=
(coYoneda)
V(S ⊗[A, B], T ).
Remark 3.40. In functional programming, we implicitly restrict to the case
where V is a cartesian category, and we curry this description to obtain the
usual representation of setters as a single over function.
over :: (a -> b) -> s -> t
Deﬁnition 3.41. Let C and D be any two V-categories; adapters [Kme18] are
morphisms in Cop ⊗D. They are optics for the action of the identity functor;
Adapter ∼= Opticid,id.
Adapter((A, B), (S, T )) := C(S, A) ⊗D(B, T ).
3.6
Optics for (co)free
A common pattern that appears across many optic derivations is that of com-
puting the optic associated to a class of functors using an adjunction to allow
for an application of the Yoneda lemma. This observation can be generalized
to a class of concrete optics.
Consider some V-endofunctor H : V →V. Any objects S, T, A, B ∈V can
be regarded as functors from the unit V-category. The following isomorphisms
are the consequence of the fact that left and right global Kan extensions are left
and right adjoints to precomposition, respectively.
V(S, HA) ∼= [V, V](LanAS, H),
V(HB, T ) ∼= [V, V](H, RanBT ).
These extensions exist in V and they are given by the formulas
LanAS ∼= [A, −] ⊗S,
RanBT ∼= [[−, B], T ].
Proposition 3.42 (Rom19, §3.4.7). Let the monoidal V-action U : M →[V, V]
have a left adjoint L: [V, V] →M, or, dually, let it have a right adjoint
R: [V, V] →M. In both of these cases the optic determined by that monoi-
dal action has a concrete form, given by
V(UL([A, −] ⊗S)(B), T )
or
V(S, UR[[−, B], T ](A)),
respectively.
Proof. We prove the ﬁrst case. The second one is dual.
Z M∈M
V(S, UMA) ⊗V(UMB, T )
21

∼=
(Kan extension)
Z M∈M
Nat (LanAS, UM) ⊗V(UMB, T )
∼=
(Adjunction)
Z M∈M
M (LLanAS, M) ⊗V(UMB, T )
∼=
(coYoneda)
V (ULLanAS(B), T ) .
4
Tambara theory
A fundamental feature of optics is that they can be represented as a single poly-
morphic function. Optics that admit this representation are called profunctor
optics, and that polymorphic function is their profunctor representation. The
beneﬁt of the profunctor representation is that it makes particularly easy to
compose two optics, even if they are from diﬀerent families: when optics are
represented by polymorphic functions, composition of optics becomes ordinary
function composition, as it happened with Figure 1.
Profunctor optics can be seen as functions polymorphic over profunctors
endowed with some extra algebraic structure. This extra structure depends on
the family of the optic they represent. For instance, lenses are represented by
functions polymorphic over cartesian profunctors, while prisms are represented
by functions polymorphic over cocartesian profunctors [PGW17, §3]. Milewski
notes that the algebraic structures accompanying these profunctors are precisely
Tambara modules [Mil17], a particular kind of profunctor that had been used to
characterize the monoidal centre of convolution monoidal categories [Tam06].
Furthermore, it was shown that, because of this, categories of lenses or prisms
can be obtained as particular cases of the “Doubles for monoidal categories”
deﬁned by Pastro and Street [PS08, §6].
The double of an arbitrary monoidal V-category (A, ⊗, I), is a promonoidal
V-category DA whose hom-objects are deﬁned as
DA((A, B), (S, T )) :=
Z C∈A
C(S, C ⊗A) ⊗C(C ⊗B, T ).
In the particular case where A is cartesian or cocartesian, the V-category DA is
precisely the category of lenses or prisms over A, respectively. Moreover, one of
the main results of Pastro and Street [PS08, Proposition 6.1] declares that the
V-category of copresheaves over these V-categories, [DC, V], is equivalent to the
V-category of Tambara modules on C. In the case of lenses and prisms, these
Tambara modules are precisely cartesian and cocartesian profunctors, and this
justiﬁes their profunctor representation.
Surprisingly, the results of Pastro and Street can be applied to the theory of
optics after the observations of Milewski [Mil17]. However, they are not general
22

enough. Milewski [Mil17] already proposed a uniﬁed description of optics, later
extended by Boisseau [BG18] and Riley [Ril18], that required a generalization
of the original result by Pastro and Street from monoidal products to arbitrary
monoidal actions.
If we want to capture V-enriched mixed optics, we need
to go even further and generalize Pastro and Street’s deﬁnition of Tambara
module [PS08, §3] in two directions. The monoidal category A in their deﬁnition
needs to be substituted by a pair of arbitrary categories C and D, and the
monoidal product (⊗): A →[A, A] is substituted by a pair of arbitrary monoidal
actions ( L ): M ⊗C →C and ( R ): M ⊗D →D, from a common monoidal
category M.
This section can be seen both as a partial exposition of one of the main results
from Pastro and Street’s “Doubles for monoidal categories” [PS08, Proposition
6.1] and a generalization of their deﬁnitions and propositions to the setting that
is most useful for applications in functional programming.
4.1
Generalized Tambara modules
Originally, Tambara modules [Tam06] were conceived as a structure on top of
certain profunctors that made them interplay nicely with some monoidal action
in both its covariant and contravariant components.
In functional programming, Tambara modules represent the diﬀerent ways
in which we can use an optic.
If P has Tambara module structure for the
monoidal actions deﬁning an optic, we can use that optic to lift the Tambara
module applied to the foci, P(A, B), to the Tambara module applied to the full
structures, P(S, T ). For instance, the profunctor (−) × B →(−) can be used
to lift the projection A × B →B into the update function S × B →T . In other
words, that profunctor is a Tambara module compatible with all the families of
optics that admit an update function, such as lenses. In programming libraries,
this can be used to deﬁne a polymorphic update combinator that works across
diﬀerent optic families.
Formally, we want to prove that Tambara modules for the actions
L and
R
are copresheaves over the category Optic L , R . This will also justify the profunc-
tor representation of optics in terms of Tambara modules (Theorem 4.13).
Deﬁnition 4.1. Let (M, ⊗, I) be a monoidal V-category with two monoidal
actions ( L ): M ⊗C →C and ( R ): M ⊗D →D. A generalized Tambara
module consists of a V-profunctor P : Cop ⊗D →V endowed with a family of
morphisms
αM,A,B : P(A, B) →P(M
L A, M
R B)
V-natural in A ∈C and B ∈D and V-dinatural M ∈M, which additionally
satisﬁes the two equations
αI,A,B ◦P(φA, ϕ−1
B ) = id,
αM⊗N,A,B ◦P(φM,N,A, ϕ−1
M,N,B) = αM,N L A,N R B ◦αN,A,B,
23

for every M, N ∈M, every A ∈C and every B ∈D. That is, a family of
morphisms making the following two diagrams commute.
P(A, B)
P(M ⊗N
L A, M ⊗N
R B)
P(N
L A, N
R B)
P(M
L N
L A, M
R N
R B)
P(A, B)
P(I
L A, I
R B)
P(A, B)
αM⊗N,A,B
αN,A,B
P (φM,N,A,ϕM,N,B)
αM,N LA,N RB
id
αI,A,B
P (φI,A,ϕ−1
I,B)
When V = Sets, we can deﬁne a morphism of Tambara modules as a natural
transformation ηA,B : P(A, B) →Q(A, B) satisfying
ηM L A,M R B ◦αM,A,B = α′
M,A,B ◦ηA,B.
For an arbitrary V, Tambara modules are the objects of a V-category Tamb
whose hom-object from (P, α) to (Q, α′) is computed as the intersection of the
equalizers of
Z
A,B
V(P(A, B), Q(A, B))
πA,B
−−−−−−−−−−−−−−−−−−→V(P(A, B), Q(A, B))
V(id,α′
A,B)
−−−−−−−−−−−−−−−−−−→V(P(A, B), Q(M
L A, M
R B))
and
Z
A,B
V(P(A, B), Q(A, B))
πM LA,M RB
−−−−−−−−−−−→V(P(M
L A, M
R B), Q(M
L A, M
R B))
V(αA,B,id)
−−−−−−−−−−−→V(P(A, B), Q(M
L A, M
R B))
for each A ∈C, B ∈D and M ∈M [PS08, §3.2].
Remark 4.2. Pastro and Street [PS08] follow the convention of omitting the
unitors and the associators of the monoidal category when deﬁning Tambara
modules. These appear in Deﬁnition 4.1 replaced by the structure isomorphisms
of the two monoidal actions.
4.2
Pastro-Street’s “double” comonad
In order to prove their main result, Pastro and Street characterized Tambara
modules as coalgebras for a particular comonad [PS08, §5]. That comonad has a
24

left adjoint that must therefore be a monad, and then Tambara modules can be
equivalently described as algebras for that monad. Following their same tech-
nique, we will describe the V-category of generalized Tambara modules Tamb
as an Eilenberg-Moore category ﬁrst for a comonad and then for its left ad-
joint monad. This will be the main lemma (Lemma 4.6) towards the profunctor
representation theorem (Theorem 4.13).
Deﬁnition 4.3. We start by constructing the underlying V-functor of the
comonad Θ: Prof(C, D) →Prof(C, D). Consider ﬁrst the V-functor
T : Mop ⊗M ⊗Cop ⊗D ⊗Prof(C, D) →V,
given by the composition of the actions ( L ) and ( R ) with the evaluation V-func-
tor Cop ⊗D ⊗Prof(C, D) →V. On objects, this is given by
T (M, N, A, B, P) := P(M
L A, N
R B).
By the universal property of the end, this induces a V-functor Cop ⊗D ⊗
Prof(C, D) →V given by
T (A, B, P) =
Z
M∈M
P(M
L A, M
R B),
which can be curried into the V-functor
ΘP(A, B) :=
Z
M∈M
P(M
L A, M
R B).
Proposition 4.4. The V-functor Θ can be endowed with a comonad structure.
Its counit is the V-natural family of morphisms εP,A,B : ΘP(A, B) →P(A, B)
obtained by projecting on the monoidal unit and applying the unitors,
ΘP(A, B)
P(I
L A, I
R B)
P(A, B).
πI
P (φA,ϕ−1
B )
Its comultiplication is given by δP,A,B : ΘP(A, B) →ΘΘP(A, B), the V-natural
family of transformations obtained as the unique morphisms factorizing
ΘP(A, B)
P(M
L N
L A, M
R N
R B)
P(φM,N,A,ϕ−1
M,N,B)◦πM⊗N
through the projection
ΘΘP(A, B)
P(M
L N
L A, M
R N
R B)
πM◦πN
for every M, N ∈M.
Remark 4.5. Before the proof, let us recall the axioms for a strong monoidal
V-action ⊘: M ⊗C →C of a monoidal V-category (M, ⊗, I) with coherence
isomorphisms (a, λ, ρ) to an arbitrary category C. Let
φA : A ∼= I ⊘A,
φM,N,A: M ⊘N ⊘A ∼= M ⊗N ⊘A,
25

be the structure V-natural isomorphisms of the strong monoidal action. Note
that the following are precisely the axioms for a strong monoidal functor M →
[C, C] written as M ⊗C →C; they are simpliﬁed by the fact that [C, C] is
strict.
I ⊘M ⊘A
M ⊘A
M ⊘I ⊘A
I ⊗M ⊘A
M ⊘A
M ⊗I ⊘A
φI,M,A
φM⊘A
M⊘φA
id
φM,I,A
λM⊘A
ρM⊘A
M ⊘N ⊘K ⊘A
M ⊘N ⊘K ⊘A
M ⊗N ⊘K ⊘A
M ⊘N ⊗K ⊘A
(M ⊗N) ⊗K ⊘A
M ⊗(N ⊗K) ⊘A
id
φM,N,K⊘A
M⊘φN,K,A
φM⊗N,K,A
φM,N⊗K,A
aM,N,K⊘A
Proof. In order to keep the diagrams in this proof small, we introduce the no-
tation P[M](A, B) := P(M
L A, M
R B). We will show that this construction
satisﬁes the comonad axioms.
We ﬁrst prove left counitality, ΘεP ◦δP = idΘP , which follows from the
commutativity of the following diagram.
ΘP(A, B)
ΘΘP(A, B)
ΘP(A, B)
ΘP[M](A, B)
P[M](A, B)
P[I ⊗M](A, B)
P[M][I](A, B)
P[M](A, B)
δP
πI⊗M
(Θε)P
πM
πM
πI
εP [M]
id
P (φI,M,A,ϕ−1
I,M,B)
P (φM LA,ϕ−1
M RB)
The left pentagon of this diagram commutes because of the deﬁnition of δ. The
upper right square commutes because of functoriality of ends and naturality of
πM. The lower right square commutes because of the deﬁnition of ε. By the
axioms of the monoidal actions (Remark 4.5), the lower side of the square can
be rewritten as
P(φI,M,A, ϕ−1
I,M,B) ◦P(φM L A, ϕ−1
M R B) = P(λ−1
M ⊘A, λM ⊘B).
Now, by the wedge condition of the end, one of the sides of the previous diagram
26

is just the projection πM.
ΘP(A, B)
P[I ⊗M](A, B)
P[M](A, B)
P(I ⊗M
L A, M
L B)
πI⊗M
πM
P (id,λM ⊘B)
P (λM⊘A,id)
Finally, by the universal property of the end, that implies that ΘεP ◦δP must
coincide with the identity.
Let us now prove right counitality, εΘP ◦δP = idΘP , which follows from the
commutativity of the following diagram.
ΘP(A, B)
ΘΘP(A, B)
ΘP(A, B)
ΘP[I](A, B)
ΘP(A, B)
P[M ⊗I](A, B)
P[I][M](A, B)
P[M](A, B)
δP
πI⊗M
εΘP
πI
id
πM
ΘP (φI,ϕ−1
I
)
πM
P (φM,I,A,ϕ−1
M,I,B)
P (φA,ϕ−1
B )
Again, the deﬁnition of δ makes the left pentagon commute. The upper right
square commutes now because of the deﬁnition of ε, whereas the lower right
square commutes because of functoriality of ends and naturality of π. By the
axioms of the monoidal actions (Remark 4.5), the lower side of the square can
be rewritten as
P(φA, ϕ−1
B ) ◦P(φM,I,A, ϕ−1
M,I,B) = P(ρ−1
M ⊘A, ρM ⊘B).
Now, by the wedge condition of the end, one of the sides of the previous diagram
is just the projection πM.
ΘP(A, B)
P[I ⊗M](A, B)
P[M](A, B)
P(I ⊗M
L A, M
L B)
πI⊗M
πM
P (id,λM ⊘B)
P (λM⊘A,id)
Finally, by the universal property of the end, εΘP ◦δP must coincide with the
identity.
Coassociativity, ΘδP ◦δP = δΘP ◦δP , follows from commutativity of the
diagram in Figure 6. We need to show that the upper diamond commutes; by
27

the universal property of the ends, this amounts to showing that it commutes
when followed by πM ◦πN ◦πK. The lower pentagon is made of isomorphisms,
and it commutes by the axioms of the monoidal actions (Remark 4.5). The two
upper degenerated pentagons commute by deﬁnition of δ. The two trapezoids
commute by functoriality of ends and naturality of the projections.
Finally, the two outermost morphisms of the diagram correspond to two
projections from ΘP(A, B), namely π(M⊗N)⊗K and πM⊗(N⊗K).
The wedge
condition for the associator aM,N,K makes the external diagram commute.
ΘP(A, B)
ΘΘP(A, B)
ΘΘP(A, B)
ΘΘΘP(A, B)
ΘΘP[K](A, B)
ΘP[K](A, B)
ΘP[N ⊗K](A, B)
ΘP[K][N](A, B)
P[K][N][M](A, B)
P[K][M ⊗N](A, B)
P[N ⊗K][M](A, B)
P[(M ⊗N) ⊗K](A, B)
P[M ⊗(N ⊗K)](A, B)
δP
δP
ΘδP
πK
πN⊗K
δΘP
πK
πN
δP [K]
πM⊗N
πM
ΘP (φN,K,A,ϕ−1
N,K,B)
πM
P (φM,N,K LA,ϕ−1
M,N,K RB)
P (φM⊗N,K,A,ϕ−1
M⊗N,K,B)
P (φN,K,A,ϕ−1
N,K,B)
P (φM,N⊗K,A,ϕ−1
M,N⊗K,B)
P (a−1
M,N,K,aM,N,K)
Figure 6: Diagram for the coassociativity axiom.
Lemma 4.6. Tambara modules are precisely coalgebras for this comonad. There
exists an isomorphism of V-categories Tamb ∼= EM(Θ) from the category of
Tambara modules to the Eilenberg-Moore category of Θ.
Proof. Note that the object of V-natural transformations from P to ΘP is pre-
cisely
Prof(C, D)(P, ΘP)
28

∼=
(Deﬁnition)
Z
A,B
V

P(A, B),
Z
M∈M
P(M
L A, M
R B)

∼=
(Continuity)
Z
A,B,M
V (P(A, B), P(M
L A, M
R B))
whose elements can be seen as a family of morphisms that is natural in both
M ∈M and (A, B) ∈Cop ⊗D. The two conditions in the deﬁnition of Tambara
module can be rewritten as the axioms of the coalgebra.
Proposition 4.7. The Θ comonad has a left V-adjoint Φ, which must therefore
be a monad. On objects, it is given by the following formula.
ΦQ(X, Y ) =
Z M,U,V
Q(U, V ) ⊗C(X, M
L U) ⊗D(M
R V, Y ).
That is, there exists a V-natural isomorphism Nat(ΦQ, P) ∼= Nat(Q, ΘP).
Proof. We can explicitly construct the V-natural isomorphism using coend cal-
culus.
Z
A,B
V

Q(A, B),
Z
M
P(M
L A, M
R B)

∼=
(Continuity)
Z
M,A,B
V(Q(A, B), P(M
L A, M
R B))
∼=
(Yoneda, in the category Cop ⊗D)
Z
M,A,B
V

Q(A, B),
Z
X,Y
V

C(X, M
L A) ⊗D(M
R B, Y ), P(X, Y )

∼=
(Continuity)
Z
M,A,B,X,Y
V

Q(A, B), V

C(X, M
L A) ⊗D(M
R B, Y ), P(X, Y )

∼=
(Currying)
Z
M,A,B,X,Y
V(Q(A, B) ⊗C(X, M
L A) ⊗D(M
R B, Y ), P(X, Y ))
∼=
(Continuity)
Z
X,Y
V
 Z M,A,B
Q(A, B) ⊗C(X, M
L A) ⊗D(M
R B, Y ), P(X, Y )
!
.
Alternatively, the adjunction can be deduced from the deﬁnition of the
comonad Θ and the characterization of global Kan extensions as adjoints to
precomposition.
29

4.3
Pastro-Street’s “double” promonad
The second part of this proof occurs in the bicategory of V-profunctors. In this
category, there exists a formal analogue of the Kleisli construction that, when
applied to the Pastro-Street monad Φ, yields a category whose morphisms are
the optics from Deﬁnition 2.1.
This is the crucial step of the proof, as the
universal property of that Kleisli construction will imply that copresheaves over
the category of optics there deﬁned are Tambara modules (Lemma 4.10). After
that, the last step will be a relatively straightforward application of the Yoneda
lemma (Lemma 4.12).
Let Prof be the bicategory of V-profunctors that has as 0-cells the V-cate-
gories C, D, E, . . .; as 1-cells P : C ↛D the V-profunctors given as P : Cop ⊗
D →V; and as 2-cells the natural transformations between them. The com-
position of two V-profunctors P : Cop ⊗D →V and Q: Dop ⊗E →V is the
V-profunctor Q ⋄P : Cop ⊗E →V deﬁned on objects by the coend1
(Q ⋄P)(C, E) =
Z D∈D
P(C, D) ⊗Q(D, E).
There is, however, an equivalent way of deﬁning profunctor composition if we
interpret each V-profunctor Cop ⊗D →V as a V-functor Cop →[D, V] to
the category of copresheaves. In this case, the composition of two profunctors
P : Cop →[D, V] and Q: Dop →[E, V] is the V-functor (Q ⋄P): Cop →[E, V]
deﬁned by taking a left Kan extension (Q ⋄P) := LanyQ ◦P along the Yoneda
embedding y: Dop →[D, V]. The unit profunctor for composition is precisely
the Yoneda embedding.
Dop
[E, V]
Cop
[D, V]
Q
y
P
LanyQ◦P
In the same way that we can construct a Kleisli category over a monad, we will
perform a Kleisli construction over the monoids of the bicategory Prof, which
we call promonads. Promonads over the base category V that are also Tam-
bara modules for the product appear frequently in the literature on functional
programming languages under the name of arrows [Hug00].
Deﬁnition 4.8. A promonad is given by a V-category A, an endoprofunctor
T : Aop ⊗A →V, and two V-natural families ηX,Y : C(X, Y ) →T (X, Y ) and
µX,Y : (T ⋄T )(X, Y ) →T (X, Y ) satisfying the following unitality and associa-
1Though, in general, the composition of two profunctors can fail to exist for size reasons
or when V lacks certain colimits, we only ever need these composites in a formal sense. This
perspective can be formalized with the notion of virtual equipment [CS09].
30

tivity axioms.
T
T ⋄T
T
T ⋄T ⋄T
T ⋄T
T
T ⋄T
T
η⋄id
id
µ
id⋄η
id
id⋄µ
µ⋄id
µ
µ
A module for the promonad is a V-profunctor P : Xop ⊗A →V, together
with a V-natural transformation ρ: T ⋄P →P making the following diagrams
commute.
P
T ⋄P
T ⋄T ⋄P
T ⋄P
P
T ⋄P
P
η⋄id
id
ρ
µ⋄id
id⋄ρ
ρ
ρ
An algebra is a module structure on a V-copresheaf P : A →V, interpreted as
a profunctor Iop ⊗A →V from the unit V-category.
Lemma 4.9. The bicategory Prof admits the Kleisli construction [PS08, §6].
The Kleisli V-category Kl(T ) for a promonad (T, µ, η) over A is constructed as
having the same objects as A and letting the hom-object between X, Y ∈A be
precisely T (X, Y ) ∈V.
Proof. The multiplication of the promonad is a V-natural transformation whose
components can be taken as the deﬁnition for the composition of the V-category
Kl(T ).
V
 Z Z∈C
T (X, Z) ⊗T (Z, Y ), T (X, Y )
!
∼=
(Continuity)
Z
Z∈C
V (T (X, Z) ⊗T (Z, Y ), T (X, Y ))
Let us show now that this V-category satisﬁes the universal property of
the Kleisli construction. Let P : Xop ⊗A →V be a V-profunctor. A module
structure ρ: T ⋄P →P corresponds to a way of lifting the profunctor P to the
Kleisli category in its second argument.
Z
X∈X,Z∈A
V
 Z Y ∈A
P(X, Y ) ⊗T (Y, Z), P(X, Z)
!
∼=
(Continuity)
Z
X,Y,Z
V(P(X, Y ) ⊗T (Y, Z), P(X, Z))
∼=
(Exponential)
Z
X,Y,Z
V(T (Y, Z), [P(X, Y ), P(X, Z)]).
Functoriality of this family follows from the algebra axioms.
31

Lemma 4.10. The category of algebras for a promonad is equivalent to the
copresheaf category over its Kleisli object.
Proof. Let X be any category and Φ: Y →Y a promonad. By the univer-
sal property of the Kleisli construction (see Lemma 4.9), Prof(X, Kl(Φ)) is
equivalent to the category of modules on X for the promonad. In particular,
V-profunctors from the unit V-category to the Kleisli object form precisely the
category EM(Φ) of algebras for the promonad; thus
[Kl(Φ), V] ∼= [Iop ⊗Kl(Φ), V] ∼= Prof(I, Kl(Φ)) ∼= EM(Φ).
Proposition 4.11. Let T : [A, V] →[A, V] be a cocontinuous monad.
The
profunctor ˇT : Aop →[A, V] deﬁned by ˇT := T ◦y can be given a promonad
structure. Moreover, algebras for T are precisely algebras for the promonad ˇT.
Proof. First, the fact that T is cocontinuous means that it preserves left Kan
extensions and thus,
Lany ˇT ∼= Lany(T ◦y) ∼= T ◦Lany(y) ∼= T.
This means that the composition of the profunctor ˇT with itself is
ˇT ⋄ˇT ∼= Lany ˇT ◦T ◦y ∼= T ◦T ◦y.
The unit and multiplication of the promonad are then obtained by whiskering
the unit and multiplication of the monad with the Yoneda embedding; that is,
(η ∗y): y →T ◦y and (µ ∗y): T ◦y →T ◦T ◦y. The diagrams for associativity
and unitality for the promonad are the whiskering by the Yoneda embedding of
the same diagrams for the monad. In fact, the same reasoning yields that, for
any P : Dop →[A, V],
ˇT ⋄P ∼= (T ◦y) ⋄P ∼= Lany(T ◦y) ◦P ∼= T ◦P.
As a consequence of this for the case P : I →[Aop, V], any T -algebra can be
seen as a ˇT-algebra and vice versa. The axioms for the promonad structure on
ˇT coincide with the axioms for the corresponding monad on T .
In particular, the Pastro-Street monad Φ is a left adjoint.
That implies
that it is cocontinuous and, because of Proposition 4.11, it induces a promonad
ˇΦ = Φ◦y, having Tambara modules as algebras. We can compute by the Yoneda
lemma that
ˇΦ(A, B, S, T ) =
Z M
C(S, M
L A) ⊗D(M
R B, T ).
Note that this coincides with Deﬁnition 2.1. We now deﬁne Optic to be the
Kleisli V-category for the promonad ˇΦ.
32

4.4
Profunctor representation theorem
Let us zoom out to the big picture again. It has been observed that optics can be
composed using their profunctor representation; that is, profunctor optics can
be endowed with a natural categorical structure. On the other hand, we have
generalized the double construction by Pastro and Street [PS08] to abstractly
obtain the category Optic. The last missing piece that makes both coincide
is the profunctor representation theorem, which will justify the profunctor rep-
resentation of optics and their composition in profunctor form being the usual
function composition.
The profunctor representation theorem for the case V = Sets and non-
mixed optics has been discussed by Boisseau and Gibbons [BG18, Theorem 4.2].
Although our statement is more general and the proof technique is diﬀerent, the
main idea is the same. In both cases, the key insight is the following lemma,
already described by Milewski [Mil17].
Lemma 4.12 (“Double Yoneda” from Milewski [Mil17]). For any V-category
A, the hom-object between X and Y is V-naturally isomorphic to the object of
V-natural transformations between the functors that evaluate copresheaves in X
and Y ; that is,
A(X, Y ) ∼= [[A, V], V](−(X), −(Y )).
The isomorphism is given by the canonical maps A(X, Y ) →V(FX, FY ) for
each F ∈[A, V]. Its inverse is given by computing its value on the identity on
the A(X, −) component.
Proof. In the functor V-category [A, V], we can apply the Yoneda embedding
to two representable functors A(Y, −) and A(X, −) to get
Nat(A(Y, −), A(X, −)) ∼=
Z
F
V

[A(X, −), F], [A(Y, −), F]

.
Here reducing by Yoneda lemma on both the left hand side and the two argu-
ments of the right hand side, we get the desired result.
Theorem 4.13 (Profunctor representation theorem).
Z
P ∈Tamb
V(P(A, B), P(S, T )) ∼= Optic((A, B), (S, T )).
Proof. We apply Double Yoneda (Lemma 4.12) to the V-category Optic and
then use that copresheaves over it are precisely Tambara modules (Proposi-
tion 4.10).
5
Conclusions
We have extended a result by Pastro and Street to a setting that is useful for
optics in functional programming. Using it, we have reﬁned some of the optics
33

already present in the literature to mixed optics, providing derivations for each
one of them. We have also described new optics.
Regarding functional programming, the work suggests an architecture for a
library of optics that would beneﬁt from these results. Instead of implementing
each optic separately, the general deﬁnition can be instantiated in all the par-
ticular cases. We can then just consider speciﬁc functions for constructing the
more common families of optics. Tambara modules can be used to implement
each one of the combinators of the library, ensuring that they work for as many
optics as possible. The interested reader can ﬁnd the implementation in the
Appendix 7.
Many of the other applications of optics may beneﬁt from the ﬂexibility
of enriched and mixed optics.
They may be used to capture some lens-like
constructions and provide a general theory of how they should be studied; the
speciﬁcs remain as future work.
5.1
Van Laarhoven encoding
This text has focused on the profunctor representation of optics.
A similar
representation that also provides the beneﬁt of straightforward composition is
the the van Laarhoven encoding [vL09]. It is arguably less ﬂexible than the
profunctor representation, being based on representable profunctors, but it is
more common in practice. For instance, traversals admit a diﬀerent encoding
in terms of profunctors represented by an applicative functor.
Z
F ∈App
V(A, FB) ⊗V(S, FT )
∼=
(Yoneda)
Z
F ∈App
[V, V](A ⊗[B, −], F) ⊗V(S, FT )
∼=
(Free applicative)
Z
F ∈App
App
 X
n∈N
An ⊗[Bn, −], F
!
⊗V(S, FT )
∼=
(coYoneda)
V
 
S,
X
n∈N
An ⊗[Bn, T ]
!
.
Exactly the same technique yields lenses and grates [O’C15a], using arbitrary
representable or corepresentable profunctors, respectively.
5.2
Related work
• The case of mixed optics was ﬁrst mentioned by Riley [Ril18, §6.1], but his
work targeted a more restricted case.
Speciﬁcally, the deﬁnitions of optic
34

given by Riley [Ril18, Deﬁnition 2.0.1] and Boisseau [BG18, §4.5] deal only
with the particular case in which V = Sets, C and D are the same category,
and the two actions coincide. The deﬁnition we use (Deﬁnition 2.1) and the
proofs we present are then strictly more general than these other ones [Ril18,
Proposition 2.0.3], as they address arbitrary monoidal actions instead of mo-
noidal products, and enriched mixed optics instead of assuming C = D.
• Pastro and Street [PS08] ﬁrst described the construction of V-categories of the
form DA in their study of Tambara theory. These results can be reused for
optics thanks to the observations of Milewski [Mil17]. We carry his approach
to a more general case.
• The profunctor representation theorem and its implications for functional
programming are discussed by Boisseau and Gibbons [BG18]. We present a
diﬀerent approach to a more general version of this theorem.
• We describe a general derivation for optics assuming a suitable adjunction
(Section 3.6). Riley describes a diﬀerent but closely related class of optics
and their laws [Ril18, §4.4]; ours makes stronger assumptions but may be
easier to apply in programming contexts.
• A central aspect of Riley’s work is the extension of the concept of lawful lens
to arbitrary lawful optics [Ril18, §3]. Lawfulness is a diﬀerent topic that we
have decided not to address here.
• Finally, Riley uses the results of Jaskelioﬀand O’Connor to propose a de-
scription of the traversal in terms of traversable functors [Ril18, §4.6]; our
derivation simpliﬁes this approach, which was in principle not suitable for the
enriched case.
5.3
Further work
• A categorical account of how optics of diﬀerent kinds compose into optics is
left for further work. Speciﬁcally, it should be able to explain the “lattice
of optics” described by Pickering, Gibbons and Wu [PGW17] and later by
Boisseau and Gibbons [BG18]. Some preliminary results have been discussed
by Rom´an [Rom19], but the proposal to model the lattice is still too ad-hoc
to be satisfactory.
• The relation between power series functors and traversables is implicit across
the literature on polynomial functors and containers. It can be shown that
traversable structures over an endofunctor T correspond to certain parame-
terised coalgebras using the free applicative construction [JR12]. We believe
that it is possible to reﬁne this result relating the laws of traversables to the
derivation in our Proposition 3.23. This could also make our derivation for
traversals more practical for functional programming.
35

It can be noted that lenses are the optic for products, functors that dis-
tribute over strong functors. Traversals are the optic for traversables, func-
tors that distribute over applicative functors. Both have a van Laarhoven
representation in terms of strong and applicative functors respectively.
A
construction like this needs a certain Kan extension to be given a coalgebra
structure [Rom19, Lemma 4.1.3], but it does not necessarily work for any
optic.
• Optics have numerous applications in the literature, including game the-
ory [GHWZ18], machine learning [FJ19] or model-driven development [Ste10].
Beyond functional programming, enriched optics open new paths for explo-
ration on applications of optics. Both mixed optics and enriched optics allow
us to more precisely adjust the existing deﬁnitions to match the desired ap-
plications.
• We have not addressed the topic of lawfulness. A ﬁrst reasonable notion of
lawfulness for the case of mixed optics for two actions ( L ): M ⊗C →C and
( R ): N ⊗D →D is to use a cospan C →E ←D of actions to push the
two parts of the optic into the same category and then consider lawfulness in
E. This can be applied to monadic lenses, for instance, when the monad is
copointed.
6
Acknowledgements
This work was started in the last author’s MSc thesis [Rom19]; development
continued at the Applied Category School 2019 at Oxford, and we thank the
organizers of the School for that opportunity. We also thank Pawel Sobocinski
for comments on the structure of the paper.
Fosco Loregian and Mario Rom´an were supported by the European Union
through the ESF funded Estonian IT Academy research measure (project 2014-
2020.4.05.19-0001). Bryce Clarke is supported by the Australian Government
Research Training Program Scholarship.
References
[ACG+16] Faris Abou-Saleh, James Cheney, Jeremy Gibbons, James McKinna,
and Perdita Stevens.
Reﬂections on monadic lenses.
In A List
of Successes That Can Change the World - Essays Dedicated to
Philip Wadler on the Occasion of His 60th Birthday, pages 1–31,
Heidelberg, 2016. Springer. 4, 6, 8
[BG18] Guillaume Boisseau and Jeremy Gibbons. What you needa know
about Yoneda: Profunctor optics and the Yoneda Lemma (func-
tional pearl). PACMPL, 2(ICFP):84:1–84:27, 2018. 3, 5, 14, 23, 33,
35
36

[Boi17] Guillaume Boisseau. Understanding profunctor optics: a represen-
tation theorem. Master’s thesis, University of Oxford, 2017. 4, 7,
9, 10
[CS09] G. S. H. Cruttwell and Michael A. Shulman. A uniﬁed framework
for generalized multicategories, 2009. 30
[Day70] Brian Day. On closed categories of functors. In Reports of the Mid-
west Category Seminar IV, pages 1–38, Heidelberg, 1970. Springer.
5, 40
[FGM+05] J. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore, Ben-
jamin C. Pierce, and Alan Schmitt. Combinators for bi-directional
tree transformations: a linguistic approach to the view update prob-
lem. In Proceedings of the 32nd ACM SIGPLAN-SIGACT Sympo-
sium on Principles of Programming Languages, POPL 2005, Long
Beach, California, USA, January 12-14, 2005, pages 233–246, 2005.
3, 10
[FJ19] Brendan Fong and Michael Johnson. Lenses and learners. CoRR,
abs/1903.03671, 2019. 36
[FMH+19] Phil Freeman, Brian Marick, Lukas Heidemann, et al. purescript
profunctor lenses. Github https://github.com/purescript-contr
ib/purescript-profunctor-lenses, 2015–2019. 3
[Fox76] Thomas Fox. Coalgebras and cartesian categories. Communications
in Algebra, 4(7):665–667, 1976. 8
[GHWZ18] Neil Ghani, Jules Hedges, Viktor Winschel, and Philipp Zahn.
Compositional game theory.
In Proceedings of the 33rd Annual
ACM/IEEE Symposium on Logic in Computer Science, LICS 2018,
Oxford, UK, July 09-12, 2018, pages 472–481, 2018. 36
[Hug00] John Hughes. Generalising monads to arrows. Sci. Comput. Pro-
gram., 37(1-3):67–111, 2000. 30
[JO15] Mauro Jaskelioﬀand Russell O’Connor. A representation theorem
for second-order functionals. J. Funct. Program., 25, 2015. 14, 15
[JR12] Mauro Jaskelioﬀand Ondrej Rypacek. An investigation of the laws
of traversals. In Proceedings Fourth Workshop on Mathematically
Structured Functional Programming, MSFP@ETAPS 2012, Tallinn,
Estonia, 25 March 2012., pages 40–49, 2012. 4, 35
[Kel05] G. M. Kelly. Basic concepts of enriched category theory. Reprints in
Theory and Applications of Categories, 1(10):137, 2005. Reprint of
the 1982 original. Cambridge Univ. Press, Cambridge; MR0651714.
4, 15, 39
37

[Kme18] Edward Kmett. lens library, version 4.16. Hackage https://hacka
ge.haskell.org/package/lens-4.16, 2012–2018. 3, 19, 20, 21, 41,
42
[Lor19] Fosco Loregian. Coend calculus. arXiv preprint arXiv:1501.02503,
2019. 5
[Mil17] Bartosz Milewski. Profunctor optics: the categorical view. https:
//bartoszmilewski.com/2017/07/07/profunctor-optics-the-cat
egorical-view/, 2017. 3, 4, 5, 7, 14, 22, 23, 33, 35
[ML78] Saunders Mac Lane. Categories for the Working Mathematician.
Graduate Texts in Mathematics. Springer New York, 1978. 16
[MP08] Conor McBride and Ross Paterson. Applicative programming with
eﬀects. Journal of Functional Programming, 18(1):1–13, 2008. 15
[O’C15a] Russell O’Connor. Grate: A new kind of optic. https://r6resear
ch.livejournal.com/28050.html, 2015. 18, 34
[O’C15b] Russell O’Connor. mezzolens: Pure Profunctor Functional Lenses.
Hackage https://hackage.haskell.org/package/mezzolens, 2015.
3
[Ole82] Frank Joseph Oles. A Category-theoretic Approach to the Seman-
tics of Programming Languages. PhD thesis, Syracuse University,
Syracuse, NY, USA, 1982. AAI8301650. 6
[PGW17] Matthew Pickering, Jeremy Gibbons, and Nicolas Wu. Profunctor
optics: Modular data accessors. Programming Journal, 1(2):7, 2017.
3, 22, 35
[PS08] Craig Pastro and Ross Street.
Doubles for monoidal categories.
Theory and applications of categories, 21(4):61–75, 2008. 3, 4, 22,
23, 24, 31, 33, 35
[Ril18] Mitchell
Riley.
Categories
of
optics.
arXiv
preprint
arXiv:1809.00738, 2018. 3, 4, 5, 6, 7, 9, 11, 14, 20, 23, 34, 35
[Rom19] Mario Rom´an. Profunctor optics and traversals. Master’s thesis,
University of Oxford, 2019. 15, 21, 35, 36
[Spi19] David I. Spivak. Generalized lens categories via functors Cop →Cat.
arXiv preprint arXiv:1908.02202, 2019. 4, 6, 8
[Ste10] Perdita Stevens. Bidirectional model transformations in QVT: se-
mantic issues and open questions. Software and Systems Modeling,
9(1):7–20, 2010. 36
[Tam06] Daisuke Tambara.
Distributors on a tensor category.
Hokkaido
mathematical journal, 35(2):379–425, 2006. 3, 22, 23
38

[vL09] Twan van Laarhoven. CPS based functional references. https://ww
w.twanvl.nl/blog/haskell/cps-functional-references, 2009. 34
7
Appendix: Haskell implementation
Let V be a cartesian closed category whose objects model the types of our
programming language and whose points 1 →X represent programs of type X.
The following pretends to be an informal translation of the concepts on enriched
category theory to a Haskell implementation where a single abstract deﬁnition
of optic is used for a range of diﬀerent examples. It can be compiled with GHC
version 8.6.5. The source code of this text includes an implementation of optics
and all the examples we have discussed (Figures 1, 2, 3 and 4, 5).
7.1
Concepts of enriched category theory
Deﬁnition 7.1 (Kel05, §1.2). A V-category C consists of a set Obj(C) of
objects, a hom-object C(A, B) ∈V for each pair of objects A, B ∈Obj(C), a
composition law C(A, B)×C(B, C) →C(A, C) for each triple of objects, and an
identity element 1 →C(A, A) for each object; subject to the usual associativity
and unit axioms.
class Category objc c where
unit :: (objc x) => c x x
comp :: (objc x) => c y z -> c x y -> c x z
Deﬁnition 7.2 (Kel05, §1.2). A V-functor F : C →D consists of a function
Obj(C) →Obj(D) together with a map C(A, B) →D(FA, FB) for each pair
of objects; subject to the usual compatibility with composition and units. V-bi-
functors and V-profunctors can be deﬁned analogously,
class ( Category objc c, Category objd d
, forall x . objc x => objd (f x)
) => VFunctor objc c objd d f where
map :: (objc x, objc y) => c x y -> d (f x) (f y)
class ( Category objc c, Category objd d, Category obje e
, forall x y . (objc x , objd y) => obje (f x y) )
=> Bifunctor objc c objd d obje e f where
bimap :: ( objc x1, objc x2, objd y1, objd y2 )
=> c x1 x2 -> d y1 y2 -> e (f x1 y1) (f x2 y2)
class ( Category objc c, Category objd d )
=> Profunctor objc c objd d p where
dimap :: (objc x1, objc x2, objd y1, objd y2)
=> c x2 x1 -> d y1 y2 -> p x1 y1 -> p x2 y2
39

Deﬁnition 7.3 (Day70). A monoidal V-category is a V-category M together
with a V-functor (⊗): M ⊗M →M, an object I ∈M, and V-natural isomor-
phisms α: (A ⊗B) ⊗C ∼= A ⊗(B ⊗C), ρ: A ⊗I ∼= A, and λ: I ⊗A ∼= A,
satisfying the usual coherence axioms for a monoidal category.
class ( Category obja a
, Bifunctor obja a obja a obja a o
, obja i )
=> MonoidalCategory obja a o i where
alpha
:: (obja x, obja y, obja z)
=> a (x `o` (y `o` z)) ((x `o` y) `o` z)
alphainv
:: (obja x, obja y, obja z)
=> a ((x `o` y) `o` z) (x `o` (y `o` z))
lambda
:: (obja x) => a (x `o` i) x
lambdainv :: (obja x) => a x (x `o` i)
rho
:: (obja x) => a (i `o` x) x
rhoinv
:: (obja x) => a x (i `o` x)
Deﬁnition 7.4. A strong monoidal V-action F : M ⊗C →C from a monoidal
V-category M to an arbitrary category C is a V-functor together with two
V-natural isomorphisms F(I, X) ∼= X and F(M, F(N, X)) ∼= F((M ⊗N), X)
satisfying associativity and unitality conditions.
class ( MonoidalCategory objm m o i
, Bifunctor objm m objc c objc c f
, Category objc c )
=> MonoidalAction objm m o i objc c f where
unitor :: (objc x) => c (f i x) x
unitorinv :: (objc x) => c x (f i x)
multiplicator :: (objc x, objm p, objm q)
=> c (f p (f q x)) (f (p `o` q) x)
multiplicatorinv :: (objc x, objm p, objm q)
=> c (f (p `o` q) x) (f p (f q x))
Deﬁnition 2.1 has now a direct interpretation. Note how the coend is modelled
with an existential type arising from a GADT.
data Optic objc c objd d objm m o i f g a b s t where
Optic :: ( MonoidalAction objm m o i objc c f
, MonoidalAction objm m o i objd d g
, objc a, objc s , objd b, objd t , objm x )
=> c s (f x a) -> d (g x b) t
-> Optic objc c objd d objm m o i f g a b s t
7.2
Mixed profunctor optics
We can implement Tambara modules (Deﬁnition 4.1) and profunctor optics
using the profunctor representation theorem (Theorem 4.13).
40

class ( MonoidalAction objm m o i objc c f
, MonoidalAction objm m o i objd d g
, Profunctor objc c objd d p )
=> Tambara objc c objd d objm m o i f g p where
tambara :: (objc x, objd y, objm w)
=> p x y -> p (f w x) (g w y)
type ProfOptic objc c objd d objm m o i f g a b s t = forall p .
( Tambara objc c objd d objm m o i f g p
, MonoidalAction objm m o i objc c f
, MonoidalAction objm m o i objd d g
, objc a , objd b , objc s , objd t
) => p a b -> p s t
The isomorphism between existential and profunctor optics can be explicitly
constructed from Lemma 4.12.
ex2prof :: forall objc c objd d objm m o i f g a b s t .
Optic
objc c objd d objm m o i f g a b s t
-> ProfOptic objc c objd d objm m o i f g a b s t
ex2prof (Optic l r) =
dimap @objc @c @objd @d l r .
tambara @objc @c @objd @d @objm @m @o @i
prof2ex :: forall objc c objd d objm m o i f g a b s t .
( MonoidalAction objm m o i objc c f
, MonoidalAction objm m o i objd d g
, objc a , objc s
, objd b , objd t )
=> ProfOptic objc c objd d objm m o i f g a b s t
-> Optic
objc c objd d objm m o i f g a b s t
prof2ex p = p (Optic
(unitorinv @objm @m @o @i @objc @c @f)
(unitor @objm @m @o @i @objd @d @g))
7.3
Combinators
After constructing optics, an implementation should provide ways of using them.
Many optics libraries, such as Kmett’s lens [Kme18], provide a vast range of
combinators. Each of these combinators works on some group of optics that
share a common feature. For instance, we could consider all the optics that
implement a view function, and create a single combinator that lets us view the
focus inside a family of optics.
This may seem, at ﬁrst glance, diﬃcult to model. We do not know, a priori,
which of our optics will admit a given combinator.
However, the fact that
Tambara modules are copresheaves over optics suggests that we can use them
41

to model ways of accessing optics; and in fact, we have found them to be very
satisfactory to describe combinators in their full generality.
Remark 7.5. As an example, for any ﬁxed A and B, consider the profunctor
PA,B(S, T ) := (S →A). It can be seen as modelling the view combinator that
some optics provide.
newtype Viewing a b s t = Viewing { getView :: s -> a }
instance Profunctor Any (->) Any (->) (Viewing a b) where
dimap l _ (Viewing f) = Viewing (f . l)
If we want to apply this combinator to a particular optic, we need it to be a
Tambara module for the actions describing the optic. For instance, we can show
that it is a Tambara module for the cartesian product, taking C = D = M; this
means it can be used with lenses in the cartesian case. In other words, lenses
can be used to view the focus.
instance Tambara Any (->) Any (->) Any (->) (,) ()
(,) (,) (Viewing a b) where
tambara (Viewing f) = Viewing (f . snd)
Optic combinators are usually provided as inﬁx functions that interplay nicely
with the composition operator. Speciﬁcally, they have “ﬁxity and semantics
such that subsequent ﬁeld accesses can be performed with Prelude..” [Kme18].
infixl 8 ˆ.
(ˆ.) :: s -> (Viewing a b a b -> Viewing a b s t) -> a
(ˆ.) s l = getView (l $ Viewing id) s
7.4
Table of optics
We can consider all of these optics in the case where some cartesian closed W is
both the enriching category and the base for the optic. This case is of particular
interest in functional programming.
Name
Description
Ref.
Adapter
(s -> a) , (b -> t)
3.41
Lens
(s -> a) , (s -> b -> t)
3.1
Algebraic lens
(s -> a) , (m s -> b -> t)
3.9
Prism
(s -> Either a t) , (b -> t)
3.17
Coalgebraic prism
(s -> Either a (c t)) , (b -> t)
3.9
Grate
((s -> a) -> b) -> t
3.30
Glass
((s -> a) -> b) -> s -> t
3.32
Aﬃne Traversal
s -> Either t (a , b -> t)
3.25
Traversal
s -> (Vec n a, Vec n b -> t)
3.21
Kaleidoscope
(Vec n a -> b) -> (Vec n s -> t)
3.27
Setter
(a -> b) , (s -> t)
3.38
Fold
s -> [a]
3.35
42

