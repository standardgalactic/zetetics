arXiv:2011.02537v1  [math.NA]  4 Nov 2020
LOCAL COARSENING ALGORITHMS ON
ADAPTIVELY REFINED MESHES IN 2D AND
THEIR EFFICIENT IMPLEMENTATION IN MATLAB
STEFAN A. FUNKEN AND ANJA SCHMIDT
Ulm University, Institute for Numerical Mathematics
Abstract. Adaptive meshing includes local reﬁnement as well as coarsening of meshes.
Typically,
coarsening algorithms are based on an explicit reﬁnement history.
In this work, we deal with local
coarsening algorithms that build on the reﬁnement strategies for triangular and quadrilateral meshes
implemented in the ameshref package (Funken and Schmidt 2018, 2019). The ameshref package is a
Matlab-toolbox for research and teaching purposes which oﬀers the user a certain ﬂexibility in the
Refine step of an adaptive ﬁnite element method but can also be used in other contexts like computer
graphics. This toolbox is now be extended by the coarsening option. In ameshref, no explicit information
about the reﬁnement process is stored, but is instead implicit in the data structure. In this work, we
present coarsening algorithms that use easy-to-verify criteria to coarsen adaptively generated meshes
by exploiting the data structure. Thereby, the desired properties are guaranteed and computational
eﬃciency is maintained. A Matlab implementation and some numerical examples are discussed in this
work and are included in full in the toolbox ameshcoars (Funken and Schmidt 2020).
1. Introduction and Outline
Adaptive meshing is an important component in various research areas. It is widely used in the
context of solving partial diﬀerential equations where solutions have local singularities [31]. In station-
ary problems this usually involves reﬁning meshes locally. In time-dependent problems, singularities,
interfaces or forces may change in time. To capture a moving singularity in the adaptive mesh, degrees
of freedom need to be released that were generated in earlier time steps. To this end, it is common
to deploy coarsening algorithms to maintain the adaptive eﬃciency [7, 33]. In addition, coarsening
routines can also be used to generate a sequence of coarse and ﬁne meshes in the context of multigrid
techniques [27, 32]. In computer graphics, adaptive meshing algorithms come into play in, e.g., the
subdivision surface method [2, 16, 30] that is in turn, e.g., used in character animation [17].
In [21], strategies are presented and an eﬃcient implementation is made available in the ameshref-
package [19]. This toolbox was designed for teaching and research purposes. It is easy to understand,
simple to use, adaptable and reliable. Compared to other existing work, it brings more ﬂexibility to
the Refine step of an adaptive method.
Local mesh coarsening is the counterpart of local reﬁnement and involves the deletion of nodes.
Remeshing the grid after the deletion of nodes while preserving the mesh quality is not an obvious
task. To this end, there exist diﬀerent approaches to coarsening, e.g., edge collapsing [6, 32, 16] or
making use of the reﬁnement history [7, 12, 26, 33].
Coarsening based on the reﬁnement history typically uses an explicit history tree to invert the reﬁne-
ment [26, 33]. This requires reﬁnement history updates in each step that needs to be stored additionally.
Various works have shown that it is not necessary to save the reﬁnement history explicitly to coarsen
elements to their corresponding parent element. Instead, relevant information is implicitly contained
in the data structure and can be extracted within linear complexity. For example, Chen and Zhang
proposed a concept on how to identify admissible-to-coarsening nodes without explicitly storing the his-
tory for the newest vertex bisection [12]. Based on the determination of these admissible-to-coarsening
nodes, elements can be coarsened to their parent element. Similar attempts were successful for bisec-
tions in any dimensions [7], for the red-green-blue reﬁnement strategy in two dimensions in [22] and for
quadrilateral meshes using a red reﬁnement in [24]. To the best of our knowledge, this has not been
E-mail address: stefan.funken@uni-ulm.de, anja.schmidt@uni-ulm.de.
2010 Mathematics Subject Classiﬁcation. 65M50.
Key words and phrases. Coarsening, Meshes, Grids, Reﬁnement, Adaptive Finite Element Method.
1

2
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
T-R
T-RG
T-RGB
T-NVB
Q-R
Q-RG
Q-RB
Figure 1. Overview of reﬁnement strategies from the ameshref-toolbox [19, 21, 20]
considered for coarsening.
done for other reﬁnement strategies in two dimensions. For this reason, we bridge the gap and present
easy-to-verify criteria to adaptively coarsen meshes generated by the reﬁnement strategies implemented
in the ameshref-package [20]. We show that all relevant information is contained in the data structures
built within this package and thus a coarsening implementation within linear complexity is possible.
We provide a new Matlab toolbox called ameshcoars that implements coarsening eﬃciently by use
of vectorization and built-in functions. The toolbox ameshcoars is created in such a way that it can
be fully used in interplay with the ameshref package. These packages are designed for teaching and
research and add more ﬂexibility to the Refine/Coarsen step of an adaptive method.
In particular, we present adaptive coarsening strategies for meshes generated by the following re-
ﬁnement procedures: For triangular meshes, we consider the newest vertex bisection (T-NVB) ﬁrst
mentioned in [34], the red-green-blue (T-RGB) reﬁnement method using reference edges presented in
[11], the red-green (T-RG) reﬁnement strategy proposed in [4], and a red (T-R) reﬁnement strategy that
naturally emerges when hanging nodes are allowed. For quadrilateral meshes, a red (Q-R) reﬁnement
strategy is considered that is a reﬁnement by quadrisection [35]. This procedure allows hanging nodes in
the mesh. To eliminate these hanging nodes, additional patterns are needed. To this end, [5] proposes
a Closure step via the red-green (Q-RG) method. A diﬀerent approach to eliminate hanging nodes in
the mesh was inspired by [25] and is referred to as red-blue (Q-RB) reﬁnement method. An overview
of these reﬁnement strategies is shown in Figure 1. In each case a mesh is depicted that is reﬁned in
the right bottom corner. The patterns next to the meshes are used to eliminate hanging nodes. Note
that, for T-NVB and T-RGB, reference edges play a crucial role in the reﬁnement method but they are
omitted in this illustration.
Our coarsening algorithms follow the framework presented in Algorithm 1 for T-NVB, T-RGB, T-R
and Q-R. For T-RG, Q-RG and Q-RB, Algorithm 2 is used that calls Algorithm 1.
Algorithm 1 Coarsen framework for T-NVB, T-RGB, T-R and Q-R
1: Input: An adaptively generated triangulation T by T-NVB, T-RGB,T-R or Q-R where Tmark is the
set of marked elements for coarsening.
2: Output: A coarsened mesh ˆT .
3: procedure CoarsenR/Rgb/Nvb(T , Tmark)
4:
A ←Admissible(T )
⊲Find admissible set A of elements or nodes for coarsening.
5:
A ←Mark(A, Tmark)
⊲Update A according to the set of marked elements or nodes Tmark.
6:
A ←Closure(T , A)
⊲Update A according to neighboring information.
7:
ˆT ←Update Mesh(T , A)
⊲Coarsen mesh T according to the set A.
8:
return ˆT
9: end procedure

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
3
Algorithm 2 Coarsen framework for T-RG, Q-RG and Q-RB
1: Input: An adaptively generated triangulation T by T-RG, Q-RG or Q-RB where Tmark is the set of
marked elements for coarsening.
2: Output: A coarsened mesh ˆT .
3: procedure CoarsenRg/Rb(T , Tmark)
4:
(T R, T R
mark) ←Recoarsen(T , Tmark)
⊲Recoarsen green and blue patterns to receive T R.
5:
T R ←CoarsenR(T R, T R
mark)
⊲Operate coarsening on T R according to T R
mark (Alg. 1).
6:
ˆT ←Regularize(T R)
⊲Regularize T R by adding green and blue patterns.
7:
return ˆT
8: end procedure
The rest of this paper is structured as follows. First, we introduce some notation in Section 2. In
Section 3, we also present the reﬁnement strategies considered in this paper and outline their properties.
We describe the data structures we use to deﬁne a triangulation and explain how the reﬁned elements
are stored within these data structures. Then, in Section 4, we discuss our coarsening algorithms,
namely Algorithm 1 and Algorithm 2, focusing on the individual steps Admissible, Mark, Closure
and Update Mesh and their diﬀerences depending on the reﬁnement method. We also show that
the presented algorithms achieve the desired results. In Section 5 we convert these ideas into code.
Thereby we focus on the eﬃcient implementation in Matlab. Most of this eﬃciency is due to the
easy-to-verify criteria - but in addition we use vectorization and built-in functions to support us in
eﬃciency. Furthermore, an overview of the ameshcoars toolbox is given. The work concludes with
some numerical experiments in Section 6. To gain an insight into the abstract level, we recommend
reading sections 2 to 4. To use the tool it is also useful to read Section 5.2 as it gives an overview of
the included functions and their use in context.
2. Notation and Preliminaries
We consider a polygonal domain Ωin R2. An element T ⊂R2 has quadrangular or triangular shape
and by convention the edges are included in T. A triangulation T is a ﬁnite set of elements T with
positive area |T| > 0, the union of all elements in T covers the closure Ωand for two elements T, K ∈T
with T ̸= K holds ˚
T ∩˚
K = ∅where ˚
T is the element T without edges. In the following we use the
terms mesh and grid synonymously to triangulation.
We denote the set of edges of a triangulation T with E and the set of nodes/vertices with N.
Accordingly, E(T) := {e ∈E | e is edge of T} is the set of edges of an element T ∈T and the set of
nodes N(T) := {v ∈N | v is vertex of T}, respectively.
We call v ∈N a hanging node if for some element T ∈T holds v ∈∂T \ N(T). A 1-irregular
triangulation is a triangulation with at most one hanging node per edge. A conforming or regular
triangulation T of Ωis a triangulation without hanging nodes, i.e., if additionally for all T, K ∈T with
T ̸= K holds that T ∩K is the empty set, a common node or a common edge.
A family of triangulations {Th} into triangles with h = max
T∈T hT > 0 is called shape regular if there
exists a constant c ≥1 such that
hT
ρT
≤c
for all T ∈Th and all h > 0,
where hT denotes the diameter of T ∈Th and ρT is the diameter of the largest ball inscribed in T [14].
This condition is equivalent to the condition, that the minimal angle of all triangles T ∈Th is bounded
away from zero.
A family of triangulations {Th} into quadrilaterals with h = max
T∈T hT > 0 is called shape regular if
• there exists a constant c1 ≥1 such that
hT
hT
≤c1
for all T ∈Th and all h > 0,
where hT and hT denote the longest and shortest edge of the quadrilateral T respectively and
• there exists a constant c2 > 0 such that
| cos ϕ | ≤c2 < 1
for all inner angles ϕ of T

4
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
none
green
blueℓ
bluer
bisec(3)
red
Figure 2. Reﬁnement patterns for newest vertex bisection and red-green-blue reﬁne-
ment. Both methods diﬀer only by the last pattern. T-NVB uses a bisec(3)-operation
where T-RGB uses a red reﬁnement.
The other patterns are used in both methods.
Reference edges are highlighted by hatched lines. The vertex opposite to the reference
edge is considered the newest vertex. It becomes clear that T-NVB always splits the
angle at the newest vertex. T-RGB is an adaption to T-NVB with the diﬀerence that if
all three edges are bisected, a red pattern is used.
holds [15]. The latter property ensures that a quadrilateral does not degenerate into a triangle. Other
weaker or equivalent formulations can be found in [9, 10] for triangular meshes and in [1, 13, 28, 29]
for quadrilateral meshes. The shape regularity of a family of triangulations is a key property in the
analysis of ﬁnite element methods [3, 8, 35].
Let {Ti}i=1,...,n be a sequence of triangulations where Ti+1 results from reﬁning Ti with a certain
strategy. This sequence is called a nested triangulation if T1 ⊂T2 ⊂T3 ⊂· · · ⊂Tn holds for all n ∈N.
3. Mesh Refinement Strategies
In this work, we are concerned with coarsening strategies of triangulations that were generated
through diﬀerent reﬁnement strategies.
Our goal is to ﬁnd adaptive coarsening routines for these
reﬁnement strategies without explicitly knowing the reﬁnement history. To this end, we make use of
implicit information in the data structure and are thus able to ﬁnd a way back in the reﬁnement history.
In the course of adaptive reﬁnement, we ensure certain properties that we also want to maintain during
coarsening. We will look at the properties in more detail when discussing the reﬁnement process.
All of the ideas used within this work rely on the reﬁnement strategies as well as on the data structures
used in the implementation of these reﬁnement strategies. For this reason, we address this topic in
detail in this section.
Let us ﬁrst begin with the diﬀerent reﬁnement strategies. In Figure 1, an overview of the imple-
mented reﬁnement strategies in the ameshref-package is given that are considered for coarsening in
this work. We can cluster these methods into three diﬀerent categories: nested, regular reﬁnements;
nested, irregular reﬁnements; and non-nested, regular reﬁnements. This categorization is helpful for
coarsening as similar approaches can be used within each category. Let us present each of this category
in more detail.
3.1. Nested and Regular Reﬁnement. In this category, we have the newest vertex bisection T-NVB
[34] and the red-green-blue T-RGB reﬁnement as presented in [11]. The reﬁnement patterns are shown
in Figure 2. As the name newest vertex bisection suggests, the angle at the newest vertex is bisected.
In our presentation, we do not highlight the newest vertex but the edge lying opposite to the newest
vertex. In the further course of this work, we call this edge a reference edge.
Halving the angle at the newest vertex corresponds to the bisection of the reference edge. This means
that if an edge of an element is marked at least the reference edge of this element needs to be marked,
too. T-RGB diﬀers from T-NVB only in one pattern – when all edges are bisected. Instead of using a
bisec(3)-operation a red reﬁnement pattern is used. The possible reﬁnement patterns for T-NVB and
T-RGB are shown in Figure 2. The reference edges ensure that in a reﬁnement process the successors
of a triangle fall into at most four similarity classes, the minimal angle is thus bounded by a constant
not depending on the mesh size. Thus, the shape regularity is ensured for all families {Th} obtained
by adaptive reﬁnement via T-NVB or T-RGB.

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
5
none
red
none
red
Figure 3. A triangle and quadrilateral with its red reﬁnement.
To the best of our knowledge, no triangulations into quadrilaterals are known that fall into this
category.
3.2. Nested and Irregular Reﬁnement. In this category, we have the red (R) reﬁnement strategy
for triangular and quadrilateral meshes.
Deﬁnition (Red Reﬁnement). A triangle T is split into four subtriangles by joining the edges’ midpoints
with each other. A quadrilateral T is subdivided into four subquadrilaterals by connecting the midpoints
of opposite edges with each other. We call this operation for triangles or quadrilaterals, respectively, a
red reﬁnement, see Figure 3.
If a red reﬁnement is used adaptively, hanging nodes arise naturally. If hanging nodes are to be
avoided, but only red reﬁnements are allowed, the result is automatically an evenly reﬁned mesh. For
adaptive procedures, hanging nodes can thus not be avoided by red-reﬁning only. The red reﬁnement
is a nested reﬁnement which is irregular. There are several reasons why the number of hanging nodes
per edge should be limited to one.
One reason lies in the implementation of adaptive mesh reﬁnement. Simpler data structures can be
used to track hanging nodes as there can either be one hanging node per edge or none. Further, in
the context of adaptive ﬁnite element methods, the associated ﬁnite element space is spanned by basis
functions whose support does not exceed a small number of elements. This has favorable consequences
in the assembly of matrices as it keeps the computational cost low and ensures that the matrix is sparse.
In summary, this rule is a sort of ”regularization” of the mesh, without eliminating all hanging
nodes. A more thorough analysis of the 1-irregularity can be found in [5]. For this reason, we follow
the 1-Irregular Rule ”Reﬁne any unreﬁned element that has more than one hanging node on an edge.”
established in [5].
The shape regularity for families of triangulations into triangles obtained via the red reﬁnement
is readily apparent. A red reﬁnement of a triangle creates four similar subtriangles. The angle for
successors does thus not change during reﬁnement. For quadrilaterals, this is not directly apparent.
Zhao et al. proved the shape regularity for meshes obtained by enneasection instead of red reﬁnement
[36]. I.e., a quadrilateral is not split into four subquadrilaterals but into nine by trisecting each edge
and connecting opposite lying nodes with each other. The ideas of the proofs for the shape regularity
of convex quadrilateral meshes obtained by enneasection carry over for the red reﬁnement. For a family
of convex quadrilateral triangulations {Th} the shape regularity is thus satisﬁed.
Further, for quadrilaterals, we would like to follow the 3-Neighbor Rule from [5] that says ”Reﬁne
any element with three neighbors that have been red reﬁned.” For triangles, a 2-Neighbor Rule can be
used accordingly. An implementation with and without the 2-Neighbor Rule are given in the ameshref-
package. The standard version (TrefineR.m) is without this rule.
3.3. Non-Nested and Regular Reﬁnement. In this category, we have the red-green (RG) reﬁnement
for triangular and quadrilateral elements and the red-blue (RB) reﬁnement for quadrilateral elements. In
the previous section, we already discussed red reﬁnement. Now, we want to regularize the triangulation
by allowing further reﬁnement to eliminate the hanging nodes.
Deﬁnition (Green Reﬁnement). A triangle T is green-reﬁned if it is divided into two subtriangles by
bisecting one edge of the triangle and connecting this midpoint to the vertex opposite to this edge. A
quadrilateral T is green-reﬁned, if it is subdivided into
• three triangles by connecting the midpoint of one edge with the vertices of the opposite edge;
• four triangles by connecting the midpoints of two adjacent edges and the common vertex of the
other two edges with each other; or
• two quadrilaterals by connecting the midpoints of two opposite edges.

6
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
Figure 4. Green reﬁnements of a triangle and quadrilateral.
Figure 5. Regularization of an irregular mesh of quadrilaterals by creating green pat-
terns. The red nodes represent the hanging nodes of the irregular mesh. The green
patterns are arranged accordingly to obtain a regular triangulation.
Figure 6. Blue reﬁnement of a quadrilateral.
Figure 4 illustrates the diﬀerent green patterns for triangles and quadrilaterals. In the red-green
reﬁnement, the green patterns are now applied like a jigsaw puzzle to eliminate all the hanging nodes
that are created by red reﬁnement, cf. Figure 5, in compliance with the 1-Irregular Rule and d-Neighbor
Rule with d = 2 for triangles and d = 3 for quadrilaterals. The red-green reﬁnement procedure thus
reads:
(1) recoarsen green patterns,
(2) red-reﬁne irregular mesh in accordance with the 1-Irregular and d-Neighbor Rule, and
(3) regularize mesh with green patterns.
This procedure can be repeated until the triangulation fulﬁls the desired properties.
These reﬁnement strategies do not create a nested sequence of triangulations during the reﬁnement
process. The shape regularity for a family of triangulations {Th} obtained by the red-green reﬁnement
is ensured. Red-reﬁnements preserve the shape regularity and, as green patterns are removed before
further reﬁnement, the angles can not become too small. The red-green reﬁnement of quadrilaterals
leads to a mixed triangulation with triangles and quadrilaterals.
The red-blue reﬁnement strategy
generates an adaptive mesh with quadrilaterals only. In contrast, new nodes need to be added by a
blue pattern; green pattern can be used without additional nodes.
Deﬁnition (Blue Reﬁnement). A quadrilateral T is blue-reﬁned if it is split into three quadrilaterals
by joining the midpoint of T with the two midpoints of adjacent edges and with the node that is opposite
to the node that is shared by those adjacent edges, cf. Figure 6.
The red-blue reﬁnement is similar to the red-green reﬁnement. However, as we only have one blue
reﬁnement pattern, we cannot ﬁt this blue pattern to eliminate all hanging nodes. By closing one
hanging node another might be introduced. Or, for two opposite lying hanging nodes, the only ﬁtting
pattern is the red one. Thus, an additional Closure step might be needed to close the mesh properly.
Further remarks are to be made for red-blue reﬁnement, to ensure that the mesh reﬁnement strategy
deﬁnes a unique way of reﬁning the elements. A thorough discussion of this topic is presented in [20, 21]
and is omitted here, as for the coarsening step this is not essential. The family of triangulations {Th}
does satisfy shape regularity. Blue patterns are not reﬁned further and thus the shape regularity of the
red-reﬁnements is essential.

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
7
3.4. Data Structure and Storage of Reﬁned Elements. For our coarsening routines, we present
the key ideas used to go back in the reﬁnement history and coarsen adaptively marked elements. A
reﬁnement creates so-called child elements. In coarsening, we want to coarsen these child elements back
to their parent elements. We will use this terminology throughout this work. The ideas used for T-NVB
and T-RGB are not as obvious and some eﬀort has to be made to determine an easy-to-verify criterion
for admissible nodes. An algorithmic perspective on coarsening for T-NVB is made in [12] and this idea
is implemented in accordance with our reﬁnement procedure in [18]. The same has been done in [22]
for T-RGB. Both implementations are included in the ameshcoars-package but their discussion is only
marginally addressed in this work, as it is presented thoroughly in the mentioned works. For the other
listed reﬁnement strategies the ideas to coarsen elements is quite clear. The core of the work here lies
in the eﬃcient implementation with the lack of an explicit reﬁnement history. For this purpose, we
concentrate on the data structures of these triangulations and the storage of reﬁned elements within
this data structure.
3.4.1. Data Structure. A triangulation T consists of a ﬁnite number of elements T, i.e.,we can denote
a triangulation as a set of elements T = {T1, . . . , Tm}. The elements Tℓfor ℓ= 1, . . . m are further
described for quadrilateral elements by Tℓ= conv(vi, vj, vk, vl) with vertices vi, vj, vk, vl that are located
within a deﬁned coordinate system. In case of triangular elements, we have Tℓ= conv(vi, vj, vk) with
vertices vi, vj, vk, respectively. The set of all vertices also called the set of nodes N = {v1, . . . , vn},
is stored in an n × 2 array coordinates where the ℓ-th node vℓ= (xℓ, yℓ) ∈R2 with its x- and
y-coordinates is represented by
coordinates(ℓ,:)=[xℓ
yℓ].
The triangulation T = {T1, . . . , Tm} is stored in an m × 4 array for quadrilaterals and in an m × 3
array for triangles. If there is no ambiguity, we denote this array by elements. If triangular und
quadrilateral elements are present at the same time, we make the distincton elements3 for triangular
and elements4 for quadrilateral elements. The ℓ-th element Tℓ= conv(vi, vj, vk, vl) is then stored in
elements4(ℓ,:)=[i
j
k
l]
with ordering of the vertices in a mathematical positive sense and for Tℓ= conv(vi, vj, vk) in
elements3(ℓ,:)= [i
j
k],
respectively. Additional boundary information can be added, where the ℓ-th edge Eℓ= conv(vi, vj)
corresponds to
boundary(ℓ,:)= [i
j].
Irregular edges are edges on which a hanging node lies. These edges are stored in a separate array
irregular for which holds
irregular(ℓ,:)= [i
j
k]
is the ℓ-th edge Eℓ= conv(vi, vj) with hanging node vk. Another way to interpret an irregular edge is
to see it as a virtual element. This means that the three nodes form a triangle V = conv(vi, vj, vk) with
area |V | = 0 and are therefore called virtual. We call an element K ∈T a direct neighbor of T ∈T if
T and K have a common edge. We call an element K ∈T an indirect neighbor of T ∈T if they are
connected by a virtual element, i.e. T ∩K is either an edge of T or an edge of K, but not both at the
same time.
The data structures presented so far are minimal in the sense that they describe the mesh fully but
without any further calculations they do not provide information about the neighborhood. However,
this information will be of great importance in the following. Therefore, auxiliary functions are used to
generate neighborhood information that can be easily extracted later. The creation of the additional
data structures is an eﬀort that is performed once each time, but which ensures an eﬃcient extraction
of information during the implementation.
With these auxiliary functions we number the edges, save in egde2nodes which nodes belong to
an edge and then deﬁne the elements in a mathematically positive sense by these edge numbers in
element3edges for triangles and in element4edges for quadrilaterals. This information is suﬃcient
for reﬁnement. For coarsening we need additional information, namely which elements are adjacent to
an edge, stored in edge2elements.
The creation of these additional data structures ensures an overall eﬃcient implementation of the
coarsening routines.

8
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
3.4.2. Storage of Reﬁned Elements. Besides the data structures, another important feature is the stor-
age of reﬁned elements.
We do not store the reﬁnement history of an adaptively generated mesh.
However, in order to coarsen meshes, some information must be implicit in the way reﬁned elements
are stored. Therefore we will go into this in more detail.
Depending on the reﬁnement strategy, the way reﬁned elements are stored plays a role. What they
all have in common is that new coordinates are appended to the end of coordinates. The smaller
the index, the older a node is. New elements are not stored at the end of the array elements. Red
reﬁnements are inserted at the position where the parent element was deﬁned – all other elements are
shifted by the number of additionally inserted elements. We emphasize that this type of storage for
red, red-green or red-blue strategies is not exploited for our coarsening algorithms. What we do use is
that for quadrilaterals, the ﬁrst node in an element is always the oldest, i.e., it has the minimum index.
For triangles, this is not taken into account during storage, but for coarsening, the same sorting is
used. Red-green and red-blue triangulations are stored in blocks, e.g., all red elements are stored in one
block, and all green respectively blue elements are stored in a subsequent block. To distinguish a red
block from a blue or green one, the number of blue or green elements is tracked in a global variable nB
or nG. As the elements’ order in green and blue blocks is not changed during reﬁnement or coarsening,
elements with the same parent element are always stored consecutively, making coarsening easy. Thus,
only suitable criteria need to be found to coarsen red patterns. In summary, we only use the following
storage properties for coarsening:
• New coordinates are appended at the end, so the smaller the index, the older the node.
• Elements are deﬁned in a mathematically positive sense; for quadrilaterals we want to have the
nodes with minimum index at the beginning (otherwise an additional sorting is required as for
for triangles).
• Blue and green elements are stored in a block after all red elements.
For T-NVB or T-RGB the situation is diﬀerent. There, it is of great importance not to lose the
successive way of storing elements that have the same parent element over diﬀerent reﬁnement levels.
For more information, see [22].
4. Mesh Coarsening Strategies
In this section, we present the main ideas used to identify the set of admissible-to-coarsen elements.
As presented in Section 3, the reﬁning process of red-green reﬁnements is implemented in a three-step-
procedure, i.e., we remove green patterns, reﬁne the 1-irregular grid, and close the grid again with
green patterns to ensure the regularity of the grid. We want to use the same three-step-procedure
for red-green and red-blue coarsening, replacing the reﬁnement operation on the 1-irregular grid by a
coarsening operation, cf. Algorithm 2.
We examine coarsening of 1-irregular grids ﬁrst.
Un-/Closure of the mesh with green and blue
patterns is a straight-forward task and is shortly presented afterwards.
4.1. Red Reﬁnements. In adaptive coarsening, diﬀerent aspects come into play. The task is to ﬁnd
an admissible set of elements that can be coarsened without losing desired properties of the mesh.
As a basis for the coarsening of elements, we determine quartets of elements that all have the same
parent element. This ensures that only elements that belonged together in a previous reﬁnement step
are merged. In particular, this guarantees that the shape regularity of a mesh is maintained when it is
coarsened. These quartets are collected in the set of Admissible elements for coarsening.
To make the procedure adaptive, there is an option to Mark certain elements for coarsening. Not
all marked elements can be coarsened, but only those that appear in a quartet. This means that the
marking function can reduce the number of admissible quartets determined in the previous step but it
cannot enlarge it.
With the so updated admissible set of quartets, properties like the 1-irregularity of a mesh or the d-
Neighbor Rule are not taken into account. These are considered in a Closure step. There, the number
of admissible quartets is again reduced to maintain the 1-irregularity of the grid and the d-Neighbor
Rule.
The remaining admissible quartets can then be coarsened back to their parent element while main-
taining all desired mesh properties. This is done in the step Update Mesh where elements, nodes and
irregularity data are updated for the admissible quartets and the rest remain as before.

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
9
T0
T2
T0,1
T1,1
T1,2
T1,3
T1,4
T2,1
T2,2
T2,3
T2,4
T2,5
T2,6
T2,7
T2,8
T3,1
T3,4
T3,3
T3,2
T1
T3
Figure 7. Initial triangulation T0, adaptively red-reﬁned triangulations T1, T2, T3, and
the corresponding tree structure. We only merge elements on the same level that have
the same parent element. If all edges starting from the parent element lead to leaves,
i.e., there are no further successors on a lower level, then the elements are coarsened
back to their parent element. Otherwise, the lower level needs to be coarsened ﬁrst.
Here, T2,1, . . . , T2,4 can be coarsened to T1,1 but T2,5, . . . , T2,8 can not be coarsened to
T1,3. For this to work, T3,1, . . . , T3,4 is ﬁrst coarsened back to T2,7. Then, the successors
of T1,3 do not have any outgoing edges to elements on a smaller level anymore and can
therefore be coarsened.
In summary, the coarsening strategy is carried out using a four-step-procedure that reads
Admissible −Mark −Closure−Update Mesh,
cf. Algorithm 1. As this algorithm describes, a set of admissible elements A is determined, which is
updated several times before the information is used to update the mesh. In the following, we present
each step in detail for 1-irregular meshes. In the presentation, we keep in mind that the coarsening
operation on the 1-irregular grid is also used in a red-green and red-blue context, see Algorithm 2. For
this reason, characteristics have to be determined that apply equally for those reﬁnement methods.
4.1.1. Admissible. A red reﬁnement of an element creates four new subelements. A coarsening of
such a reﬁnement, on the contrary, is intended to merge these four subelements to regain their parent
element. So the task of the step Admissible is to determine quartets of elements that can be combined
to form a larger element. These quartets can not be selected arbitrarily but their determination follows
a certain structure. This structure is not explicitly given in our data structure, but we illustrate the
idea in Figure 7. The reﬁnement of a single element can be displayed in a tree structure. If this element
is red-reﬁned, then four new elements of a ﬁner level are created. The reﬁnement level corresponds
to the level of the tree. If adaptive reﬁnement is applied, it is possible that only some elements are
reﬁned and others are not. Accordingly, the mesh consists of elements of diﬀerent levels of reﬁnement.
Elements of diﬀerent levels can not be joined together. To this end, we need to group four elements on
the same level that have the same ancestor in the tree - an admissible quartet of elements. The tree
structure in Figure 7 is displayed for quadrilateral meshes but applies analogously for the triangular
case.
Keeping in mind that this tree structure is not explicitly given in our data structure, information
about the parent element and the level of elements is a priori unknown. In a tree structure this can
be easily read.
In our case, it is necessary to determine an easy-to-verify criterion that checks for
admissible quartets. This forms the basis for our coarsening procedures.
To distinguish such an admissible quartet of elements from other quartets, we ﬁrst take a look at the
reﬁnement of an element. For quadrilateral meshes, a red reﬁnement creates ﬁve new nodes. One of
these nodes is the middle node and the other four nodes are the midpoints of the element’s four edges.
They are connected to the middle node by an edge. In the following, we want to speak of a ﬁve-point
stencil when we talk about the ﬁve newly created nodes and their connections via edges. The four
vertices of the parent element stem from an older generation than the ﬁve new nodes, see Figure 8.

10
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
Figure 8. Left: A red reﬁnement of a quadrilateral and its parent element. A ﬁve-point
stencil (in red) is introduced in a red reﬁnement. Right: Red-reﬁned triangular element
and its parent element. A middle element (in red) is introduced in a red reﬁnement.
For both holds that the nodes in red stem from a newer generation than the nodes in
black.
One idea to determine an admissible quartet of elements is to ﬁnd out whether or not a middle node
belongs to the latest generation in each element adjacent to that node. Usually, out of the ﬁve-point
stencil, the middle node is the node that is lastly added from these ﬁve points.
This indicates to
determine the newest nodes per element. However, to apply this method in the context of red-blue
meshes, a determination via the newest nodes no longer works because with earlier blue reﬁnements
the middle node is created before some other nodes of the ﬁve-point stencil and is therefore considered
older.
In contrast, the oldest nodes in the element can be determined robustly. The oldest nodes always
originate from the respective parent element and therefore serve as optimal orientation features. We
are now exploiting this as follows: The elements are numbered in mathematically positive order. If we
now know which node is the oldest, we can conclude that the second following node within the element
must be the corresponding middle node of a red reﬁnement. If this middle node is determined to be
the middle node for all four adjacent elements, then these four elements form an admissible quartet of
elements. Algorithm 3 describes the just indicated procedure in more detail. A supportive illustration
is given in Figure 9.
Algorithm 3 Admissible (Quadrilateral)
1: Input:
Quadrilateral mesh T
obtained by red-reﬁnement.
T
= {T1, . . . , Tm} with Ti =
conv(vi1, vi2, vi3, vi4) for all i ∈{1, . . . , m}.
The vertices vij are cyclically permuted such that
vi1 is an older vertex than vij for j ∈{2, 3, 4}.
2: Output: Admissible set A of quartets Q for coarsening.
3: procedure Admissible(T )
4:
A := ∅
5:
for all i ∈{1, . . . , m} do
6:
ﬁnd index set I ⊂{1, . . . , m} such that vi3 = vj3 for all j ∈I
7:
if #I = 4 and vi3 ̸∈N0 then
8:
Q ←{T ∈T | vi3 ∈T}
9:
A ←A ∪{Q}
10:
end if
11:
end for
12:
return A
13: end procedure
For triangular meshes, a red reﬁnement creates three new nodes. The newly created nodes are the
midpoints of the element’s three edges that are connected with each other to form a new triangle. In
the following, we want to speak of a middle element when we talk about the three newly created nodes
and their connections via edges. As for quadrilateral meshes, the three vertices of the parent element
stem from an older generation than the three new nodes.
Again, we want to ﬁnd admissible quartets of elements. Unlike in the quadrilateral case, we can not
work with a middle node. However, we can determine the middle elements. A middle element and its
three direct neighbors thus form an admissible quartet of elements. So the ﬁrst task is to ﬁnd middle
elements. A middle element consists only of nodes of a newer generation. To determine these, we make
use of the oldest nodes.
The determination of the admissible quartets of elements in the case of triangular meshes is described
in Algorithm 4. An illustration of the algorithm is shown in Figure 10. We will now brieﬂy introduce
the main ideas that lead to this procedure. The algorithm takes advantage of the property that a

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
11
3
3
3
3
1
1
1
1
2
2
2
2
4
4
4
4
3
3
1
3
3
3
3
3
1
1
1
1
1
2
2
2
4
4
1
4
Figure 9. Element numbering of red reﬁnements.
The storage position within an
element is indicated by the numbers. The oldest node of an element is stored at position
one. As elements are numbered counterclockwise, the node at the third position is a
candidate for a middle node. To determine if it is a middle node of an admissible quartet,
this node must be shared by four elements having this node on position three in common.
Left: The middle node (in white) is shared by all elements on position three, i.e., the
four elements form an admissible quartet. Right: The same middle node (in white) is
now blocked because of the reﬁned upper right corner. Here, the position three is not
shared by all elements, so we are not on the last level. The elements adjacent to this
middle node are thus not an admissible quartet.
Algorithm 4 Admissible (Triangular)
1: Input:
Triangular mesh T
obtained by red-reﬁnement.
T
=
{T1, . . . , Tm} with Ti
=
conv(vi1, vi2, vi3) for all i ∈{1, . . . , m}.
The vertices vij are cyclically permuted such that vi1
is an older vertex than vij for j ∈{2, 3}.
2: Output: Admissible set A of quartets Q for coarsening.
3: procedure Admissible(T )
4:
for all edges e ∈E(T ) do
5:
ﬁnd set Ie = {i ∈{1, . . . , m} | e is edge of Ti}
6:
vold,e = old
i∈Ie vi1
⊲old returns the oldest node.
7:
end for
8:
O = {T ∈T | vold,e1 = vold,e2 = vold,e3, where e1, e2, e3 are edges of T}
9:
M = T \ O
⊲Middle elements.
10:
A := ∅
11:
for all T ∈M do
12:
if T has 3 direct neighbors then
⊲Quartet having the same parent element.
13:
Q =

T
	
∪
n
ˆT ∈T | ˆT is direct neighbor of T
o
14:
A ←A ∪{Q}
15:
end if
16:
end for
17:
return A
18: end procedure
middle element consists only of newer nodes and thus diﬀers from the other elements - since these
always contain a node from an older generation. The procedure therefore provides for the oldest node
to be determined for each element. If the element Ti = conv(vi1, vi2, vi3) is given, we assume that vi1
is the oldest node of this element. If not, we will cyclically permute the vertices of the element until
vi1 is the oldest node of this element. The next step is to compare the oldest node of an element with
the oldest nodes of the direct neighbor element. We assign the oldest nodes of this comparison to the
edge shared by these two elements. We ﬁnd that the three elements of a red reﬁnement that are not
the middle element are assigned the same oldest node on each edge. So if this is not the case, it is
considered the middle element.
Finally, in order to obtain the admissible quartets of elements, we examine whether a middle element
thus determined has three direct neighbours. If this is the case, an admissible quartet is given by this
middle element and its three direct neighbours.
4.1.2. Mark. In the step Admissible, we determined all admissible quartets that can be considered
for elimination. With the step Mark, adaptivity is incorporated into a coarsening step. This includes

12
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
∗
∗
1
2
3
4
5
6
7
8
9
1
1
5
2
3
6
4
1
1
1
1
1
2
2
2
3
4
3
3
3
3
4
4
10
12
11
6
10
3
8
3
8
8
8
6
6
6
5
Figure 10. Determination of middle elements via an easy-to-verify criterion. Left: The
numbers written in black are the indices of the nodes. The nodes 1–4 are part of the
initial triangulation, 5–11 were added via reﬁnement. To each element we assign the
index of the oldest node per element (in red). Here, the oldest node is represented by
the smallest index. Middle: We now compare the indices of the oldest nodes per element
with the neighboring element and assign the older value (the smaller index) to the edge
that is shared by these two elements. Boundary edges do not have a direct neighbor –
no comparison is needed. Right: We consider an element a middle element if it does not
have the same oldest node assigned on all three edges (in red). The asterisks indicate
that this middle element and its direct neighbors is considered an admissible quartet,
whereas a middle element without an asterisk does not have three direct neighbors and
is thus not in the set of admissible quartets.
that the determined set A is reduced by a marking operation.
We consider the following marking
operation: If an element of an admissible quartet is marked for coarsening, all elements of this quartet
are considered for coarsening. If no element of an admissible quartet is marked, this quartet is not
coarsened. This means that A is updated and the number of quartets for coarsening is reduced. This
step is identical for both triangular and quadrilateral meshes, and is described in Algorithm 5.
Algorithm 5 Mark
1: Input: Admissible set A of quartets and a set of marked elements Tmark.
2: Output: Admissible and marked set A of quartets Q for coarsening.
3: procedure Mark(A, Tmark)
4:
¯
A := ∅
5:
for all T ∈Tmark do
⊲Consider all elements in a quartet for coarsening or none.
6:
if ∃Q ∈A such that T ∈Q then
7:
¯
A ←¯
A ∪{Q}
8:
end if
9:
end for
10:
A ←¯
A
11:
return A
12: end procedure
Note that the convention of at least one marked element per quartet is not restrictive. By a small
modiﬁcation, we can also require that all elements of an admissible quartet need to be marked to be
considered for coarsening.
This marking operation can lead to k-irregular triangulations with k > 1, k ∈N and non-compliance
with the 3-Neighbor Rule. To this end, an additional step Closure is needed.
4.1.3. Closure. After a Closure step, two properties shall be satisﬁed: the 1-irregularity and the
d-Neighbor Rule with d = 2 for triangular and d = 3 for quadrilateral meshes. To this end, we again
want to ﬁnd easy-to-verify criteria to ensure both rules for triangular and quadrilateral meshes.
The 1-irregularity of a mesh means that there can be at most one hanging node per edge. Without
taking neighbor information into account, coarsening can lead to meshes with more than one hanging
node per edge, cf. Figure 11. To prevent this, coarsening back to the parent element is blocked if one of

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
13
∗
∗∗
∗
∗
∗∗
∗
∗
∗∗
∗
Figure 11. Left: Admissible quartets for coarsening are marked by asterisks. Right:
Coarsening of all marked elements does not result in a 1-irregular mesh, i.e., coarsening
may introduce more than one hanging node per edge. To prevent this case, we have
the convention to block a quartet as soon as one of its elements has an irregular edge.
Here, quartets marked in red are blocked for coarsening and only the black ones are
coarsened. This ensures the 1-irregularity of the grid. It is not always necessary to
block elements marked in red, as can be seen on the right of the mesh. Here, coarsening
this quartet would introduce no more than one hanging node per edge. However, during
the reﬁnement process, elements of diﬀerent levels were also created in diﬀerent steps.
Thus, the two shown cases are therefore not distinguished and are handled in the same
way.
∗
∗∗
∗
∗
∗∗
∗
∗
∗∗
∗
∗
∗∗
∗
∗
∗∗
∗
∗
∗∗
∗
2
2
2
2
2
2
2
2
2
2
2
1
2
2
2
2
2
1
2
2
2
2
2
1
∗
∗∗
∗
∗
∗∗
∗
∗
∗∗
∗
∗
∗∗
∗
∗
∗∗
∗
∗
∗∗
∗
2
2
2
2
2
2
2
2
2
1
2
2
2
2
1
2
2
2
2
2
2
2
1
Figure 12. Two exemplary meshes with the assigned weights wv for all 5-point stencil
nodes v contained in A (black dots). As a 5-node stencil, we consider the 5 newest nodes
of an admissible quartet of elements for coarsening. Hanging nodes, boundary nodes
and nodes shared by two stencils of an admissible quartet of elements receive a weight
of two.
Middle nodes receive a weight of zero which is omitted in the presentation.
Every other node of a stencil gets the weight one. If the sum of weights per stencil is
greater than 5 coarsening is performed (black asterisks), if it is less than or equal to 5
the quartet of elements containing this stencil is blocked for coarsening (red asterisks).
This criterion applied in a loop ensures that the 3-Neighbor Rule is maintained.
the neighboring elements has a higher reﬁnement level, i.e., one of the elements in an admissible quartet
has an irregular edge. By blocking, we mean that we reduce the set of admissible quartets A by those
quartets that have at least one irregular edge. Note, that this blocking is not always necessary. For
example, if there is another admissible quartet for coarsening at a higher level of reﬁnement that causes
this irregular edge of an element and this quartet is coarsened back to the parent element, blocking is
not necessary. However, to distinguish between those two cases, which are both speciﬁed in Figure 11,
one would not only need the immediate neighbor information but the entire neighborhood. Since the
reﬁnement also produced patterns of diﬀerent levels in the subsequent reﬁnement steps, a coarsening
without this distinction does not slow down the coarsening process relative to the reﬁnement.
The last desired property is to comply with the 3-Neighbor Rule which states that any element with
three or more neighbors that have been reﬁned must also be reﬁned. This rule shall be eﬀective in a
reverse way for coarsening, i.e., an admissible quartet is not coarsened to the parent element if this
operation would result in the parent element having at most one direct neighbor. Only the most recently
added nodes are decisive for whether coarsening is allowed or not. That means we look at the ﬁve-point
stencils of the admissible quartets contained in A. By a clever assignment of values for the nodes in the
stencils, it is easy to determine if a stencil can be removed without violating the 3-Neighbor Rule. If it
cannot be removed, the set of admissible quartets A is reduced by the quartet that contains this stencil.
To pass this new information to its neighborhood, the process is repeated until no further changes to A
occur. The Closure step for quadrilateral meshes is described in Algorithm 6. In particular, the value
assignment for the nodes in the stencil is speciﬁed. An illustration of the criterion for the 3-Neighbor
Rule in Algorithm 6 is given in Figure 12.

14
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
Algorithm 6 Closure (Quadrilateral)
1: Input: Quadrilateral mesh T obtained by red-reﬁnement and admissible set A of quartets Q for
coarsening.
2: Output: Updated admissible set A of quartets Q for coarsening.
3: procedure Closure(T , A)
4:
for all Q ∈A do
⊲Ensure 1-irregularity.
5:
if for any T ∈Q holds that T has an irregular edge then
6:
A ←A \ {Q}
7:
end if
8:
end for
9:
while ﬁrst run or A changes do
⊲Ensure 3-Neighbor Rule.
10:
ˆ
A := A
11:
for all Q ∈A do
12:
Nst ←{v ∈N | v is node of the 5-point stencil in Q}
⊲See Figure 8.
13:
for all v ∈Nst do
14:
if v is a middle node then
15:
wv ←0
16:
else if v is a hanging node, a boundary node or v is shared by two stencils of admissible
quartets Q contained in A then
17:
wv ←2
18:
else
19:
wv ←1
20:
end if
21:
end for
22:
if
P
v∈Nst
wv ≤5 then
23:
ˆ
A ←ˆ
A \ {Q}
24:
end if
25:
end for
26:
A ←ˆ
A
27:
end while
28:
return A
29: end procedure
For triangular meshes, the situation is analogous. Here, an admissible quartet of elements is also
eliminated from the set of admissible quartets A as soon as one of the elements in an admissible quartet
has an irregular edge. Note, that an admissible quartet consists of one middle element and its three
neighboring elements. The middle element cannot have an irregular edge if it is in an admissible quartet.
Thus, only the other three elements sharing their edges with neighboring elements may be aﬀected.
This ensures the 1-irregularity.
For triangular irregular meshes, the 2-Neighbor Rule is not used. However, in case of a red-green
reﬁnement a 2-Neighbor Rule is needed.
In this case, the same ideas can be used with small modiﬁcations. Here, the nodes of the middle
elements of admissible quartets are considered. The assignment of weights wv for all middle element
nodes v is performed analogously to the quadrilateral case, except that there are no middle nodes. As
a further change, the sum must be less or equal than four instead of ﬁve. Algorithm 7 explains the step
Closure for triangular meshes in more detail.
With all these easy-to-verify criteria, we have now narrowed down the admissible quartets for coars-
ening to include adaptivity and adherence of rules. These quartets are then ﬁnally updated in the next
step.
4.1.4. Update Mesh. The step Update Mesh is the last step performed within the coarsening al-
gorithm. The elements to be coarsened are speciﬁed in quartets in A and only need to be joined to
their parent element, see Figure 8. To ensure that the vertices are arranged counterclockwise within
the parent element, the elements in an admissible quartet must be sorted accordingly. After sorting,
the quartet can be coarsened to their parent element. All other elements are not changed. Coarsening

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
15
Algorithm 7 Closure (Triangular)
1: Input: Triangular mesh T obtained by red-reﬁnement and admissible set A of quartets Q for
coarsening.
2: Output: Updated admissible set A of quartets Q for coarsening.
3: procedure Closure(T , A)
4:
for all Q ∈A do
⊲Ensure 1-irregularity.
5:
if for any T ∈Q holds that T has an irregular edge then
6:
A ←A \ {Q}
7:
end if
8:
end for
9:
if 2-Neighbor Rule is in use then
⊲Optional: Ensure 2-Neighbor Rule.
10:
while ﬁrst run or A changes do
11:
ˆ
A := A
12:
for all Q ∈A do
13:
NM ←{v ∈N(T) | T is middle element in Q}
14:
for all v ∈NM do
15:
if v is a hanging node, a boundary node or is shared by two middle elements of
admissible quartets Q contained in A then
16:
wv ←2
17:
else
18:
wv ←1
19:
end if
20:
end for
21:
if
P
v∈NM
wv ≤4 then
22:
ˆ
A ←ˆ
A \ {Q}
23:
end if
24:
end for
25:
A ←ˆ
A
26:
end while
27:
end if
28:
return A
29: end procedure
may create new irregular edges and remove old ones. Therefore the step Update Mesh also includes
the update of the irregularity data. Algorithm 8 outlines this last step.
Algorithm 8 Update Mesh
1: Input: Mesh T obtained by red-reﬁnement and admissible set A of quartets Q for coarsening.
2: Output: Coarsened mesh ˆT .
3: procedure Update Mesh(T , A)
4:
for all Q ∈A do
5:
Coarsen T ∈Q to their parent element according to Figure 8.
6:
end for
7:
Update irregularity data.
8:
return ˆT
9: end procedure
We have now seen the basic concept of the coarsening algorithm and its single components for red
meshes. In the further course of the work, the data structures and the exact implementation of the
presented points will be dealt with much more concretely. We move their discussion to Section 5. For
now, we focus on some important results for CoarsenR from the algorithmic framework in Algorithm 1.
4.1.5. Properties of CoarsenR. We would now like to discuss important properties of the meshes
that the CoarsenR algorithm outputs. It is irrelevant whether we are talking about triangular or
quadrilateral meshes: the results apply equally to both shapes. We want to note that Algorithm 1 in

16
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
the speciﬁc case of QcoarsenR calls Algorithm 3,5,6 and 8 and TcoarsenR calls Algorithm 4,5,7
and 8.
We have constructed the algorithms in such a way that it retains all the properties that were obtained
during the reﬁnement. By construction, it holds
Theorem 1 (Output CoarsenR). Let T be a 1-irregular triangulation obtained by red reﬁnement
of an initial triangulation T0 and Tmark ⊂T . Then CoarsenR(T , Tmark) from Algorithm 1 gener-
ates a 1-irregular and shape regular triangulation. Further, the d-Neighbor Rule holds with d = 3 for
quadrilaterals and, if the 2-Neighbor Rule is in use for triangular meshes, with d=2 for triangles.
We also want our algorithm to be able to recover the initial triangulation. In our case this can be
done without any further conditions to the triangulation.
Theorem 2 (Coarsening). Let T be an arbitrary red reﬁnement of an initial triangulation T0. Let
(T (i))i=0,1,... be a sequence of triangulations obtained by Algorithm 1, i.e.,
T (0) := T
and
T (i+1) = CoarsenR(T (i), T (i)).
Then after a ﬁnite number of steps M ∈N0, we obtain
T (M) = T0.
For this to be true, the input set A in Update Mesh has to be non-empty for an arbitrary red
triangulation T ̸= T0. This way, Update Mesh always coarsens elements to their parent element and
after a ﬁnite number of coarsening steps, the initial mesh is regained. That coarsening cannot extend
beyond the initial mesh is given in the functions Admissible. For quadrilaterals, the condition vi3 ̸∈N0
in Algorithm 3 ensures that only middle nodes are considered that were not already included in the
initial grid. In the case of triangles, the function old in Algorithm 4 is responsible for not coarsening
further. If the function old is applied to an initial grid, all nodes are of the same age. This means that
no middle elements are detected that belong to the initial mesh, and therefore no further coarsening
beyond the initial mesh is performed. We thus prove
Lemma 1 (Non-emptyness of A). Let T be an arbitrary 1-irregular triangulation consisting of red pat-
terns and T ̸= T0 applies. Then, the input set A of Update Mesh is non-empty when CoarsenR(T , T )
is called.
Proof. The set of admissible quartets A is ﬁrst generated in Admissible. During the procedure, this
initial set A is only reduced but not enlarged.
For this purpose, we ﬁrst prove that the function
Admissible outputs a non-empty set A.
Due to the hierarchical structure of the mesh, there are always quartets of elements that have the
same parent element. These elements correspond to the last level in a tree, cf. Figure 7. The only
exception is the roots in the tree, but this case is excluded with the condition T ̸= T0. Thus, the
output A of Admissible is non-empty. All elements of the triangulation are marked and therefore the
step Mark does not change the set A. It remains to show that after the step Closure there are still
quartets in A.
To ensure the 1-irregularity, quartets of elements are blocked, if they have an irregular edge. If an
element in the quartet has an irregular edge, this means that there are elements at a ﬁner level. If the
quartet is at the ﬁnest level, it cannot be blocked by irregular edges. So there are always quartets that
are not blocked because they are at the ﬁnest level. Thus, the set A remains non-empty.
In addition, the d-Neighbor Rule blocks a quartet from being coarsened if neighboring elements on
the same level are blocked. This blocking does not result from adaptive marking, because all elements
are marked for coarsening. If such a blocking is done, there must therefore be elements on a ﬁner level.
Otherwise, if this quartet is at the ﬁnest level, it cannot be blocked. We conclude A ̸= ∅.
□
Remark 1. The hierarchical structure of the mesh even indicates that the number of coarsening steps
is given by the level of reﬁnement, see also numerical experiments in Section 6.
4.2. Red-Green and Red-Blue Reﬁnements. We now discuss Algorithm 2 for red-green and red-
blue meshes. This algorithm calls the presented Algorithm 1. To this end, we only focus on the other
two steps Recoarsen and Regularize.

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
17
4.2.1. Recoarsen. The Recoarsen operation can be easily explained using Figure 5. There, a mesh
is depicted with diﬀerent green patterns. By recoarsen we mean to delete the green patterns to obtain
a 1-irregular mesh with only red patterns.
To coarsen a regular mesh obtained by red-green or red-blue reﬁnement back to an irregular mesh
consisting of red patterns, it is necessary to determine the green and blue patterns. In our data structure
we have stored red, green and blue patterns in blocks. This means that ﬁrst all red elements are stored
and then either a block of green or blue elements. To distinguish these blocks from each other, the
number of green or blue elements is tracked in a global variable. This information helps to distinguish
all relevant green or blue patterns to be deleted from the red ones. The next step is to determine the
relationship between the elements. In the case of red-green for triangular meshes, there is only one
green pattern that can exist in three diﬀerent orientations, cf. left pattern in Figure 4. A green pattern
consists of two elements that are stored consecutively. To deﬁne their parent element, their common
newest node is deleted and the remaining nodes are stored counterclockwise.
For quadrilateral meshes, the red-green strategy has three diﬀerent green patterns that can be ori-
ented in each direction, cf. second left to right in Figure 4. One of the three patterns (right) consists of
quadrilaterals and is thus stored in a block after all red quadrilaterals. The number of green quadrilat-
erals is tracked in a global variable. As in the triangular case, two consecutive elements have the same
parent element. The deﬁnition of the parent element is easily made by deletion of the newest nodes
and storage of the old ones in a mathematical positive sense. In addition, triangular patterns are used
to regularize the mesh. These are stored in an additional variable and are thus already classiﬁed as
green patterns. There are two types of green patterns consisting of triangles. The diﬀerent types of
green patterns are also stored in blocks. In this case, the number of elements belonging to a type is
not stored and must be determined via characteristics. This is done using the node numbering within
a green pattern. The number determined in this way tells us how many green patterns of which type
exist. We also know how many elements per type have the same parent element. These are stored one
after the other. With this information and the determination of the newest nodes, the parent element
can be redeﬁned.
For red-blue meshes, the number of blue patterns is tracked and can therefore be eliminated analo-
gously.
The Recoarsen step involves not only coarsening green and blue patterns to their corresponding
parent elements, but also deﬁning irregular edges resulting from this process and updating the marked
elements Tmark. In the case of green patterns, deleting the newest node within a green pattern results
in an irregular edge with this newest node as a hanging node. In the case of blue patterns, a hanging
node is usually also introduced. However, there are cases where they do not become a hanging node.
For example, if a blue pattern shares its newest node with another blue pattern, this newest node is
completely eliminated from the mesh and does not become a hanging node. Further, the markings of
green or blue elements in Tmark are eliminated and the updated set T R
mark is output.
Overall, we have received a 1-irregular mesh T R out of the red-green or red-blue mesh T with an
updated set of marked elements T R
mark that can now be processed via Algorithm 1.
4.2.2. Regularize. The output of Algorithm 1 is a coarse 1-irregular mesh to which the d-Neighbor
Rule applies with d = 3 for quadrilaterals and d = 2 for triangles. This ensures, that the speciﬁed
green patterns have the shapes required to regularize the mesh. In other words, the patterns match
the hanging nodes. Regularization is the elimination of hanging nodes by adding more elements to the
mesh. This is the reverse operation of Recoarsen. So we make sure to store the elements in blocks
and track the number of green and blue patterns accordingly. This helps to coarsen the mesh again
in a subsequent coarsening step to Recoarsen. For the red-blue strategy a further note has to be
made. Often, closing one hanging node by a blue pattern introduces another hanging node. This means
that the blue patterns do not readily match the hanging nodes. To this end, the step Regularize
for red-blue includes a further closure step that makes sure to remove all hanging nodes, compare the
red-blue reﬁnement strategy in [21].
4.2.3. Properties of CoarsenRg and CoarsenRb. For red-green and red-blue strategies, the shape
regularity is fulﬁlled. Again, only elements that previously belonged together are merged. In addition,
coarsening cannot result in hanging nodes, since Recoarsen creates a 1-irregular grid in compliance
with the d-Neighbor Rule that can then be coarsened by CoarsenR. From Theorem 1 it is known
that CoarsenR outputs a 1-irregular mesh in accordance with the d-Neighbor Rule. This ensures that

18
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
no other green patterns then the predeﬁned are needed. In Regularize, all hanging nodes can be
eliminated by adding these matching green patterns. For red-blue strategies, Regularize guarantees
the regularity of the mesh by a further closure step, which is not speciﬁed here. In total, the following
applies:
Theorem 3 (Output CoarsenRg/CoarsenRb). Let T be a conforming triangulation obtained by
red-green or red-blue reﬁnement of an initial triangulation T0 and Tmark ⊂T . Then CoarsenRg/
CoarsenRb(T , Tmark) from Algorithm 2 generates a conforming and shape regular triangulation.
With the same arguments, Theorem 2 applies for a triangulation T obtained by red-green or red-blue
reﬁnement and successive applications of CoarsenRG and CoarsenRB as described in Algorithm 2.
This is apparent as we operate on the 1-irregular grid and the green respectively blue reﬁnement is only
an un-/closing operation.
4.3. Newest Vertex Bisection and Red-Green-Blue Reﬁnements. Other works already discuss
coarsening algorithms for the newest vertex bisection [12, 18] and the red-green-blue reﬁnement [22].
At this point we only give a brief insight into the ideas. We would like to draw particular attention
to the diﬃculties encountered in these reﬁnement strategies in terms of coarsening. Let us remember
that we want to use the same algorithmic framework as for red reﬁnements, namely Algorithm 1. A
red reﬁnement quarters an element. A green reﬁnement or a bisection halves an element. This means
that we can imagine the reﬁnement again analogously with a tree – here even a binary tree. So we
have to ﬁnd a criterion with which we can go back in the binary tree. This was shown in the work of
Chen and Zhang [12]. Now we have seen in Figure 2 that the red-green-blue reﬁnement diﬀers only by
the last pattern. This is where a red reﬁnement is applied instead of bisec(3). This makes it possible
to have a diﬀerent tree structure. Some elements are halved and others are quartered. This presents
certain challenges, which are described in detail in the work of Funken and Schmidt [22]. We introduce
the ideas of the individual functions brieﬂy, but refer to [12, 22] for a detailed description.
4.3.1. Admissible. In contrast to the red reﬁnement, we do not determine quartets of elements for
coarsening. Instead, we ﬁnd admissible-to-coarsening nodes via the determination of the cardinality of
adjacent elements to the newest nodes. The newest node of an element can be eliminated if there are
two or four adjacent elements to this node. Otherwise, the elimination is blocked and can be resolved
in a preceding step.
A similar determination of admissible-to-coarsening nodes can be made in the red-green-blue reﬁne-
ment. Here, the red pattern plays a diﬀerent role. To this end, we treat the middle element of a red
pattern diﬀerently and count the adjacent elements to a newest node excluding these middle elements.
The same criterion as for T-NVB can then be used to classify the newest nodes, i.e., for the quantity two
or four adjacent elements excluding middle elements, the node can be eliminated. We refer to [12, 22]
for a more thorough presentation.
4.3.2. Mark. The marking operation marks all nodes of a marked element.
4.3.3. Closure. The newest vertex bisection does not need a Closure step as the admissible-to-
coarsen nodes are already selected so that no further processing steps are necessary.
The red pattern in the red-green-blue reﬁnement however plays a special role and thus an additional
Closure step is needed to ensure the shape regularity. This includes to take care of the assigned
reference edges. The idea here is to go back as if the mesh was reﬁned by the newest vertex bisection.
This still guarantees the shape regularity but also ensures that coarsening is not blocked, see [22].
4.3.4. Update Mesh. After determining the relevant nodes, the adjacent elements to these nodes are
returned to their parent element by coarsening green or red patterns. The return of the green pattern
is analogous to the return of a bisection. Blue patterns are eliminated via a two-step coarsening of
green patterns but are not considered separately. Red patterns are returned to their parent element or
a green or blue intermediate pattern, see [22].
We want to note that Theorem 3 holds analogously for T-NVB and T-RGB. A similar result as in
Theorem 2 can also be obtained, with restrictions to the assignment of reference edges in the initial
triangulation T0. A more thorough discussion of these results can be found in [12, 22].

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
19
5. Implementation and Overview of Toolbox
In this section, we want to focus on how we can implement the ideas in Matlab. In particular,
we have seen that coarsening red reﬁned meshes plays a central role in our work. Coarsening green
and blue patterns is an easy task that we will not go into further in this section. The implementation
of T-NVB has already been discussed in detail in [18] and of T-RGB in [22]. We therefore omit their
presentation here and focus exclusively on the implementation of red coarsening in Matlab according
to Algorithm 1.
5.1. MATLAB Implementation: Coarsening of Red Reﬁnements. An implementation of the
coarsening is based on the presented criteria and the utilization of data structures.
We will ﬁrst
discuss the implementation of coarsening of adaptively reﬁned quadrilateral meshes using the red re-
ﬁnement. Since the implementation for triangles diﬀers only slightly, we present the diﬀerences in the
step Admissible and otherwise refer to the codes provided in [23]. The reader will see that the ideas
can be translated one-to-one with minor adjustments.
5.1.1. QcoarsenR. To get a better overview of the individual blocks, we will structure this section
analogous to the individual steps Admissible, Mark, Closure and Update Mesh and an additional
preparation step.
Admissible. In this part, we determine admissible quartets of elements as described in Algorithm 3.
• Lines 1–5: The function is usually called by
[coordinates,elements4,irregular,boundary] ...
= QcoarsenR(N0,coordinates,elements4,irregular,boundary,marked).
The variables coordinates, elements4, irregular and boundary are clear from the deﬁni-
tion in Section 3.4. Note, that the input elements4 is already sorted as required in Algorithm 3,
i.e., the smallest index is at position one. N0 is the number of nodes in the initial triangulation
T0. Boundary data is an optional argument. marked determines the elements for coarsening
and is considered to be the last entry of varargin (Line 5). The number of nodes nC and
element nE is determined.
• Lines 6–13: Here, admissible middle nodes are determined.
Due to the sorting within an
element, the possible middle nodes are the ones at position three. To this end, we sort the
elements such that all elements with the same third node are listed after each other. If there
are four in a row, they are considered admissible middle nodes, see Figure 9.
• Lines 14–18: Based on the admissible middle nodes, we determine the four elements adjacent
to this node. To this end, we deﬁne a variable with the indices of the coordinates and change
the sign for admissible middle nodes. Applied to the elements, we can determine for which
elements such a negative index is present. Then, node2elem represents the admissible quartets
of elements.
Listing 1. The step Admissible in QcoarsenR.m
1
function [coordinates,elements,irregular,varargout] = ...
2
QcoarsenR(N0,coordinates,elements,irregular,varargin)
3
nC = size(coordinates,1);
4
nE = size(elements,1);
5
marked = varargin{end};
6
%*** get admissible middle nodes
7
temp = sortrows(elements,3);
8
adm = temp(temp(1:end−3,3) == temp(4:end,3),3);
9
adm = adm(adm>N0); % do not delete nodes of initial triangulation
10
if isempty(adm)
11
varargout = varargin;
12
return
13
end
14
%*** determine elements belonging to admissible middle nodes
15
i2fi = 1:nC; i2fi(adm) = −i2fi(adm);
16
idx = −min(i2fi(elements),[],2); kdx = find(idx > 0);
17
temp = sortrows([idx(kdx),kdx]);
18
node2elem = reshape(temp(:,2),4,[])';

20
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
Mark. In this part, we reduce the admissible quartets of elements as described in Algorithm 5.
• Lines 19–23: We mark elements for coarsening. If at least one element in a quartet is marked,
it is considered admissible. The condition in Line 21 can be changed to ==4 if it is preferable
to require that all elements of an quartet shall be marked that this quartet is considered for
coarsening.
Listing 2. The step Mark in QcoarsenR.m
19
%*** consider only marked elements
20
marked elements = zeros(1,nE); marked elements(marked) = 1;
21
idx = sum(marked elements(node2elem),2)>1; % set >1 for coarsen if at least one ...
22
% element is marked; set == 4 for coarsen if all elements are marked
23
node2elem = node2elem(idx,:);
Preparation Step. Until now, it was not necessary to use neighboring properties other than those already
stored in the data structures. However, in order to implement the Closure and the Update Mesh
step, further geometric information is required, which is now generated. In addition, the existing data
is being prepared for further use.
• Lines 24–32: The elements in a quartet are not sorted in node2elem. To ensure storing the
coordinates of the parent element in counterclockwise order, we need to ensure that they are
stored counterclockwise.
To this end, a sorting is made until the four elements are sorted
counterclockwise.
• Lines 33–35: With the help of the auxiliary function provideGeometricData, we generate an
edge numbering.
• Lines 36–39: For the 1-irregularity, it is of importance if any of the elements in an admissible
quartet has an irregular edge. To this end, in adm2edges the outer edges of an admissible
quartet is stored.
• 40–41: We mark an edge if it has a hanging node.
Listing 3. Some preparation for subsequent steps in QcoarsenR.m
24
%*** adjust order
25
i1 = [3,4,4]; i2 = [2,2,3];
26
for k = 1:3
27
idx = find(elements(node2elem(:,i1(k)),4) == ...
28
elements(node2elem(:,i2(k)−1),2));
29
tmp = node2elem(idx,i2(k));
30
node2elem(idx,i2(k)) = node2elem(idx,i1(k));
31
node2elem(idx,i1(k)) = tmp;
32
end
33
%*** obtain geometric information on edges
34
[edge2nodes,irregular2edges,element2edges,boundary2edges{1:nargin−5}] ...
35
= provideGeometricData(irregular,elements,varargin{1:end−1});
36
adm2edges = [element2edges(node2elem(:,1),[4,1]), ...
37
element2edges(node2elem(:,2),[4,1]), ...
38
element2edges(node2elem(:,3),[4,1]), ...
39
element2edges(node2elem(:,4),[4,1])];
40
markedEdges = zeros(size(edge2nodes,1),1);
41
markedEdges(irregular2edges(:,1)) = 1;
Closure. In this part, we reduce the admissible quartets of elements as described in Algorithm 6.
• Lines 43: We ﬁrst determine boundary edges since this information is not always directly avail-
able. boundary is an optional argument. The key here is that irregular and inner edges occur
twice, i.e., single occuring edges must lie on the boundary. This is important for implementing
the assignment of node values speciﬁed in the criterion for the 3-Neighbor Rule.
• Lines 45–49: If any of the elements in an admissible quartet has an irregular edge it is eliminated
from the set of admissible middle nodes adm and admissible quartets node2elem, see Figure 11.
• Lines 47–59: The values for the nodes in the ﬁve-point stencil are assigned. Nodes from bound-
ary or irregular edges are counted twice. In Lines 53–54, it is determined whether this node is
shared by two stencils of admissible quartets or not. The value assignment is accordingly. See

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
21
Figure 12 for reference. Line 57 determines whether a quartet needs to be eliminated due to
the 3-Neighbor Rule. The whole process is repeated until no further changes occur.
Listing 4. The step Closure in QcoarsenR.m
42
%*** follow 3−Neighbor Rule
43
boundinfo = edge2nodes(accumarray([element2edges(:); irregular2edges(:)],...
44
1,[length(edge2nodes) 1])==1,:);
45
idx = find(sum(reshape(markedEdges(adm2edges),[],8),2)); % follow 1−irregularity
46
foo = 1;
47
while ∼isempty(idx)
| |
foo
48
adm(idx)=[];
49
node2elem(idx,:)=[];
50
%*** mark nodes to be eliminated
51
markedNodes = zeros(nC,1);
52
markedNodes(adm) = 1;
53
markedNodes = markedNodes + accumarray(elements(node2elem,2),...
54
ones(size(elements(node2elem,2))),[nC 1]);
55
markedNodes(boundinfo(:,2)) = 2*markedNodes(boundinfo(:,2)); % boundary edges
56
markedNodes(irregular(:,3)) = 2*markedNodes(irregular(:,3)); % irregular edges
57
idx = find(sum(reshape(markedNodes(elements(node2elem,4)),[],4),2)<6);
58
foo = 0;
59
end
Update Mesh. In this part, we update the mesh as described in Algorithm 8.
• Lines 60–62: Elements that are not in any of the admissible quartets are not changed. The
parent elements of the quartets are appended to the array elements. The parent element is
deﬁned by the four oldest nodes in the quartet. These are in the ﬁrst position in the respective
child elements. The previous sorting guarantees that the nodes are mathematically positively
deﬁned within this element.
• Lines 63–77: Irregularity data is updated, too. To this end, we store all irregular edges and
additionally all edges that we eliminated. If any edges appear twice, they are deleted (Lines
70–71). If any of the remaining edges is a boundary edge, they are also deleted (Lines 72-77).
What remains are the updated irregular edges.
• Lines 78–84: Due to the element updates, some nodes are no longer in the mesh. For this
purpose the corresponding nodes are deleted in coordinates. The indexing to the coordinates
in the arrays elements and irregular is updated accordingly.
• 85–99: If additionally boundary data is provided, these edges are also updated.
• Lines 100–106: Finally, we ensure that all elements are sorted such that the minimal index is
at position one.
Listing 5. The step Update Mesh in QcoarsenR.m
60
%*** create new elements
61
idx = setdiff(1:nE,unique(node2elem));
62
newelements = [elements(idx,:);reshape(elements(node2elem(:),1),[],4)];
63
%*** update constrains, allow redundancies
64
irregular = [irregular; ...
65
[elements(node2elem(:,1),1),elements(node2elem(:,2),1),elements(node2elem(:,1),2)];...
66
[elements(node2elem(:,2),1),elements(node2elem(:,3),1),elements(node2elem(:,2),2)];...
67
[elements(node2elem(:,3),1),elements(node2elem(:,4),1),elements(node2elem(:,3),2)];...
68
[elements(node2elem(:,4),1),elements(node2elem(:,1),1),elements(node2elem(:,4),2)]];
69
irregular = sortrows(irregular,3);
70
idx = find(irregular(1:end−1,3) == irregular(2:end,3));
71
irregular([idx(:);idx(:)+1],:) = [];
72
node2bound = zeros(nC,1);
73
node2bound(unique(boundinfo(:)),:) = 1;
74
idx = (markedNodes & node2bound);
75
node2constr = zeros(nC,1);
76
node2constr(irregular(:,3),1) = 1:size(irregular,1);
77
irregular(node2constr(idx),:) = [];
78
%*** update coordinates and element numbering
79
i2fi = zeros(nC,1);

22
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
80
i2fi(newelements) = 1;
81
coordinates = coordinates(find(i2fi),:);
82
i2fi = cumsum(i2fi);
83
elements = reshape(i2fi(newelements),[],4);
84
irregular = reshape(i2fi(irregular),[],3);
85
%*** correct boundaries
86
for j = 1:nargout−3
87
boundary = varargin{j};
88
if ∼isempty(boundary)
89
node2boundary = zeros(nC,2);
90
node2boundary(boundary(:,1),1) = 1:size(boundary,1);
91
node2boundary(boundary(:,2),2) = 1:size(boundary,1);
92
idx = ( markedNodes & node2boundary(:,2) );
93
boundary(node2boundary(idx,2),2) = boundary(node2boundary(idx,1),2);
94
boundary(node2boundary(idx,1),2) = 0;
95
varargout{j} = i2fi(boundary(find(boundary(:,2)),:));
96
else
97
varargout{j} = [];
98
end
99
end
100
%*** sort such that oldest node is first
101
[∼,jdx] = min(elements,[],2);
102
map = [1,2,3,4; 2,3,4,1; 3,4,1,2; 4,1,2,3];
103
for k=1:4
104
idx = jdx == k;
105
elements(idx,:) = elements(idx,map(k,:));
106
end
107
end
5.1.2. TcoarsenR. For triangular meshes, the most ideas can be adopted.
What distinguishes the
triangular case from the quadrilateral is mainly the step Admissible. All other steps are done with
minor changes and are thus not addressed separately. To get to the Admissible step, some preparations
are necessary which we discuss ﬁrst.
Preparation Step. In this part, we prepare the input arrays for our algorithm and generate further
geometric information on the mesh.
• Lines 1–5: This is analogous to the quadrilateral case.
• Lines 6–12: In contrast to our quadrilateral mesh, the triangular mesh is not stored in a way
that the minimal index is stored at position one. To this end a preliminary sorting is performed.
• Lines 13–18: With the auxiliary functions provideGeometricData and createEdge2Elements
we generate edge information and their correspondence to elements.
Listing 6. Preparation step in TcoarsenR.m
1
function [coordinates,elements,irregular,varargout] = ...
2
TcoarsenR(N0,coordinates,elements,irregular,varargin)
3
nC = size(coordinates,1);
4
nE = size(elements,1);
5
marked = varargin{end};
6
%*** sort such that oldest node is first
7
[∼,jdx] = min(elements,[],2);
8
map = [1,2,3;2,3,1;3,1,2];
9
for k=1:3
10
idx = jdx == k;
11
elements(idx,:) = elements(idx,map(k,:));
12
end
13
%*** obtain geometric information
14
[edge2nodes,element3edges,∼] = provideGeometricData([elements;...
15
irregular],zeros(0,4),varargin{1:end−1});
16
irregular2edges = element3edges(nE+1:end,:);
17
element3edges = element3edges(1:nE,:);
18
edge2element = createEdge2Elements(element3edges);

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
23
Admissible. In this part, we determine admissible quartets of elements as described in Algorithm 4,
cf. Figure 10.
• Line 20: The oldest node in an element is the node with the minimal index.
Due to the
pre-sorting this node is stored at position one in elements.
• Lines 21–22: We assign, as described in Algorithm 4 Line 6, the value vold,e to each edge
e ∈E(T ).
• Lines 23–24: We check the criterion that all values assigned to the edges of an element must be
equal. If this is not the case, we consider it to be a middle element.
• Lines 25–26: We exclude the middle elements that contain a node from the initial triangulation
T0 ensuring that coarsening does not occur beyond the initial triangulation.
• Lines 27–28: For each edge of the middle elements the adjacent elements are determined and
stored in elem2coarse
• Lines 29–30: If any of the adjacent elements is 0, i.e., there does not exist a direct neighbor,
this middle element is not considered for an admissible quartet.
• Lines 31–33: So far, elem2coarse has six entries, with the middle element listed three times.
However, we would like each element to occur only once and we would like to have a quartet in
the end. For this purpose we determine the entries that are not equal to the middle element.
These are then stored in an updated elem2coarse with the middle elements midElements.
This completes the determination of the admissible quartets of elements.
• Lines 34–38: As in the quadrilateral case, we want to have the elements in such an order that
we store the coordinates of the parent element counterclockwise. For this purpose, the outer
three elements are stored counterclockwise and the middle element at the end.
Listing 7. The step Admissible in TcoarsenR.m
19
%*** determine elements to coarsen
20
minNode = elements(:,1);
21
value2edges = minNode.*ones(nE,3);
22
minEdgeVal = accumarray(element3edges(:),value2edges(:),[size(edge2nodes,1) 1],@min);
23
midElements = find(∼((minEdgeVal(element3edges(:,1))==minEdgeVal(element3edges(:,2)...
24
)) .* (minEdgeVal(element3edges(:,2)) == minEdgeVal(element3edges(:,3)))));
25
idx = sum(elements(midElements,:)>N0,2)<3; % do not delete nodes of initial triang.
26
midElements(idx) = [];
27
midEdges = element3edges(midElements,:);
28
elem2coarse = reshape(edge2element(midEdges(:),:),[],6);
29
idx = any(elem2coarse == 0,2);
30
elem2coarse(idx,:)= []; midElements(idx) = [];
31
elem2coarse tmp = elem2coarse';
32
idx = (reshape(midElements',1,[]) .* ones(6,size(midElements,1)));
33
elem2coarse = [reshape(elem2coarse tmp(elem2coarse tmp
∼=
idx),3,[])', midElements];
34
%*** adjust order of elements
35
idx = find(elements(elem2coarse(:,1),2) == elements(elem2coarse(:,3),3));
36
tmp = elem2coarse(idx,3);
37
elem2coarse(idx,3) = elem2coarse(idx,2);
38
elem2coarse(idx,2) = tmp;
The steps Mark, Closure and Update Mesh are equivalent to the ones presented for quadrilat-
erals with some minor changes. The full code is provided in [23].
5.2. Overview of Functions Provided by ameshcoars-Package. Our ameshcoars toolbox consists
of several modules and is available on [23].
We list the functions and state the function call for
each function.
For the diﬀerent input parameters, we use the abbreviations C(coordinates), E3
(elements3), E4(elements4), I(irregular), and b(boundary).
Boundary data is an optional
argument that can be left out. N0 is the number of coordinates in the initial mesh T0, i.e., the initial
mesh before any reﬁnement. With this information, we make sure to not coarsen further than to the
initial triangulation.
In this toolbox, we stick to the naming from the ameshref-package. For the coarsening routines,
we simply replace the reﬁne by a coarsen. The rest of the naming remains the same. As our toolbox
is based on ameshref there is the folder refinement/ that includes all the reﬁnement and auxiliary

24
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
functions used in the reﬁnement. What is interesting for us are the functions in the folder coarsening/
and their call.
5.2.1. Local Mesh Coarsening. The functions for adaptive mesh coarsening are called by
• [C,E3,B] = TcoarsenNVB(N0,C,E3,B,marked)
• [C,E3,B] = TcoarsenRGB(N0,C,E3,B,marked)
• [C,E3,B] = TcoarsenRG(N0,C,E3,B,marked)
• [C,E3,I,B] = TcoarsenR(N0,C,E3,I,B,marked)
• [C,E4,I,B] = QcoarsenR(N0,C,E4,I,B,marked)
• [C,E4,B] = QcoarsenRB(N0,C,E4,B,marked)
• [C,E3,E4,B] = QcoarsenRG(N0,C,E3,E4,B,marked)
We want to remark that the functions TcoarsenRG, QcoarsenRB and QcoarsenRG are called in a
three-step-procedure calling the functions TcoarsenR 2neighbor, which is a function operating on
a 1-irregular triangular grid as TcoarsenR with the addition to stick to the 2-Neighbor Rule, and
QcoarsenR. Additional pre- and post-processing is done in
• coarse greenelements and regularize Tgreen for TcoarsenRG,
• coarse blueelements and regularize Qblue for QcoarsenRB and
• coarse Qgreenelements and regularizeedges tri for QcoarsenRG.
Additional auxiliary functions are needed to provide more information on the geometric data, see an
explanation in Section 3.4. These include the functions
• [edge2nodes,element3edges,element4edges,boundary2edges] =
provideGeometricData(E3,E4,B) and
• edge2elements = createEdge2Elements(element2edges).
For the latter there is also an extended version createEdge2Elements adv, which additionally provides
the information about the numbering of the edges within this element. Thus, createEdge2Elements
outputs the elements that share an edge, and createEdge2Elements adv additionally outputs the
information about which edge within the element it is.
5.2.2. A Minimal Example. Listing 8 shows an exemplary code of how to embed the coarsening routine
into a framework. We start with deﬁning an initial mesh T0 (Lines 1–5). The number of coordinates
in the initial mesh is stored in N0. A reﬁned mesh ˜T is created via TrefineR (Lines 8–16). For a given
triangulation T and a given discrete point set P, the function point2element determines the elements
of T that include p for some p ∈P. Thus, for the deﬁned discrete point set in Lines 17–23, elements
in ˜T are marked according to point2element. We coarsen the mesh via the function call TcoarsenR
(Line 27–28) until no further change is made (Line 29). Lines 34–36 plot the locally coarsened mesh.
Listing 8. A minimal example
1
%% Define initial mesh
2
coordinates = [0,0;1,0;1,1;0,1;2,0;2,1];
3
elements = [3,1,2;1,3,4;2,6,3;6,2,5];
4
irregular = zeros(0,3);
5
boundary = [1,2;2,5;5,6;6,3;3,4;4,1];
6
N0 = size(coordinates,1);
7
c old = 0;
8
%% Refine uniformly
9
while 1
10
marked = 1:size(elements,1);
11
[coordinates,elements,irregular,boundary] ...
12
= TrefineR(coordinates,elements,irregular,boundary,marked);
13
if isempty(marked) | |
(size(coordinates,1)>1e3)
14
break
15
end
16
end
17
% define discrete points (here a disc)
18
phi = −pi:pi/50:pi;
19
r = 0.2:1/50:0.4;
20
[r,phi] = meshgrid(r,phi);
21
s = r.*cos(phi);
22
t = r.*sin(phi);

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
25
23
points = [s(:)+1,t(:)+0.5];
24
%% Coarsen at discrete points
25
while 1
26
mark3 = point2element(coordinates,elements,points);
27
[coordinates,elements,irregular,boundary] = ...
28
TcoarsenR(N0,coordinates,elements,irregular,boundary,mark3);
29
if size(coordinates,1) == c old
30
break
31
end
32
c old = size(coordinates,1);
33
end
34
% plot results
35
clf, patch('Faces',elements,'Vertices',coordinates,'Facecolor','none')
36
axis equal, axis off
This minimal example can be called in an adapted way for all implemented coarsening routines. This
includes the deﬁnition of the mesh and the calls of the reﬁnement and coarsening strategy. Especially,
for red-green or red-blue strategies it is important to ﬁrst clear all variables, as in these functions
global variables nG or nB are deﬁned. If they are not cleared before a new script is started, the global
variable may already have a predeﬁned value and an error may be displayed when the script is executed.
5.2.3. Examples and Demo Files. Numerical examples and demo ﬁles based on the interplay of reﬁne-
ment and coarsening are provided in subdirectories of the ameshcoars–toolbox:
• example1/: reﬁnement along a moving circle,
• example2/: adaptive ﬁnite element implementation following [18] for a quasi-stationary partial
diﬀerential equation,
• example3/: triangulation of a GIF,
• example4/: local coarsening of a uniformly reﬁned triangulation.
6. Numerical Experiments
To demonstrate the eﬃciency of the developed Matlab code, we provide some numerical experiments
performed on an Apple MacBook Air with a 1.6 GHz Intel Core i5, a RAM of 8 GB 1600MHz DDR3
on Mac OS High Sierra, version 10.13.6. Throughout, Matlab version 9.2.0 (R2017a) is used.
For the ﬁrst experiment, we consider a reﬁnement along a circle, which is implemented as a part
in example1/, and coarsen this reﬁnement by marking all elements for coarsening until the initial
triangulation is restored.
We measure with Matlab’s tic/toc 20 times the computational time
needed to coarsen the reﬁned circle until the initial triangulation is restored, and take the average
of the measured times.
The results are shown in Figure 13.
There the number of nodes and the
computational time in seconds show a nearly linear behavior. We would like to emphasize that the
time displayed for a number of nodes is the computational time required to perform a coarsening step
with all elements marked. To determine the total computational time required to coarsen a mesh with
a given number of nodes back to the initial triangulation, the times must be cumulated. One can see
that the computational times for a coarsening step scale linearly with the number of nodes in that
mesh.
What is noticeable in Figure 13 is that T-RGB and T-NVB have many more data points than the
other strategies.
To this end, we have studied the interaction between reﬁnement and coarsening.
Speciﬁcally, we wanted to know how many reﬁnement steps are required to preserve the adaptive mesh,
and on the contrary, how many coarsening steps are required to restore the original mesh with all
elements marked for coarsening. We have already indicated that in the case of the red, red-green and
red-blue strategies the number of coarsening steps is identical to the number of reﬁnement steps. This
is due to the hierarchical structure of the meshes. In a coarsening step, less coarsening is generally
possible than was reﬁned in the last reﬁnement step. This is because in coarsening 1-irregularity and
the d-Neighbor Rule are ensured by blocking the coarsening. With the reﬁnement, on the other hand,
this is achieved by further reﬁnements. In general, the number of coarsening steps is not less than
the number of reﬁnement steps needed to restore the initial mesh. To see this, Figure 14 shows the
reﬁnement and coarsening steps as a function of the number of elements. The reﬁnement curve shows
the number of elements achieved in each reﬁnement step. For a better comparison, we have reversed
the coarsening steps and the corresponding number of elements. Normally for coarsening we would
start with a mesh with a large number of elements and decrease with each step. Here we have simply

26
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
101
102
103
104
105
10−5
10−4
10−3
10−2
10−1
100
101
1
1
number of nodes
computational time [s]
TcoarsenNVB
QcoarsenR
TcoarsenRGB
QcoarsenRB
TcoarsenRG
QcoarsenRG
TcoarsenR
Figure 13. Computational times in seconds vs. number of nodes.
We observe a
nearly linear behavior between the number of nodes and the computational time. The
newest vertex bisection implemented in [18] is a bit more performant because no further
Closure step is necessary.
reversed the data points beginning with the smallest to the highest number of elements to get a better
comparison of reﬁnement and coarsening.
T-RGB and T-NVB require more coarsening steps than reﬁnement steps. This can easily be explained
by the fact that a blue, bisec(3) and possibly a red reﬁnement is coarsened in a two-step process
that reverses green reﬁnements. In the reﬁnement process, these patterns were introduced within one
reﬁnement step. This leads to the diﬀerence in the number of reﬁnement and coarsening steps. A more
detailed discussion is given in [22].
In the toolbox, some examples are implemented that present our coarsening algorithm in diﬀerent
contexts. In this work, we restrict ourselves to present local coarsening implemented in example4/
because the presentation of moving circles, singularities or a triangulation of an image sequence is not
suitable for a presentation in a paper. The interested reader should call up the sample implementations
to convince himself of the functionality of the toolbox. In example4/ a mesh is ﬁrst reﬁned uniformly
and with a local marking strategy elements are coarsened only in a speciﬁc region, see Figure 15.

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
27
5
10
15
20
25
100
102
104
106
reﬁnement/coarsening steps
number of elements
TcoarsenNVB
coarsening
reﬁnement
5
10
15
20
25
100
102
104
106
reﬁnement/coarsening steps
number of elements
TcoarsenRGB
coarsening
reﬁnement
5
10
15
100
102
104
106
reﬁnement/coarsening steps
number of elements
TcoarsenRG
coarsening
reﬁnement
5
10
15
100
102
104
106
reﬁnement/coarsening steps
number of elements
TcoarsenR
coarsening
reﬁnement
5
10
15
100
102
104
106
reﬁnement/coarsening steps
number of elements
QcoarsenR
coarsening
reﬁnement
5
10
15
100
102
104
106
reﬁnement/coarsening steps
number of elements
QcoarsenRB
coarsening
reﬁnement
5
10
15
100
102
104
106
reﬁnement/coarsening steps
number of elements
QcoarsenRG
coarsening
reﬁnement
Figure 14. Reﬁnement/Coarsening steps vs. number of elements. In coarsening, the
data points start from a high number of elements and decrease with the number of
coarsening steps, whereas in reﬁnement, the opposite is true. For a better comparison
between reﬁnement and coarsening steps, a reversed data set for coarsening is plotted.
We see that T-NVB and T-RGB use more coarsening steps than the reﬁnement. It is
typical for these strategies that twice as many coarsening steps are needed as reﬁne-
ment steps. The hierarchical structure of red meshes ensures an identical number of
reﬁnement/coarsening steps. The coarsening is nevertheless more restrained in the in-
termediate steps than in the reﬁnement. This is not surprising, as coarsening can be
blocked in the Closure step, whereas further reﬁnements are made in the reﬁnement
step to guarantee 1-irregularity and the d-Neighbor Rule. Un-/Closure of the meshes
with green or blue patterns does not change this behavior.

28
LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
TcoarsenNVB
TcoarsenRGB
TcoarsenRG
TcoarsenR
QcoarsenR
QcoarsenRB
QcoarsenRG
Figure 15. Local Coarsening. A uniformly reﬁned mesh is coarsened locally in the
shape of a circle. The resulting meshes are shown for each mesh coarsening strategy.
References
[1] Acosta, G., and Monz´on, G. The minimal angle condition for quadrilateral ﬁnite elements of arbitrary degree. J.
Comput. Appl. Math. 317 (2017), 218–234.
[2] Andersson, L.-E., and Stewart, N. Introduction to the Mathematics of Subdivision Surfaces. SIAM, 01 2010.
[3] Babuˇska, I., and Aziz, A. K. On the angle condition in the ﬁnite element method. SIAM J. Numer. Anal. 13, 2
(1976), 214–226.
[4] Bank, R. E., and Sherman, A. H. An adaptive, multi-level method for elliptic boundary value problems. Comput.
26, 2 (1981), 91–105.
[5] Bank, R. E., Sherman, A. H., and Weiser, A. Some reﬁnement algorithms and data structures for regular local
mesh reﬁnement. In Scientiﬁc Comput. (1983), vol. 1, by R. Stepleman et al. IMACS. North-Holland, pp. 3–17.
[6] Bank, R. E., and Xu, J. An algorithm for coarsening unstructured meshes. Numer. Math. 73, 1 (1996), 1–36.
[7] Bartels, S., and Schreier, P. Local coarsening of triangulations created by bisections. Univ. Freiburg, SFB 611,
2010.
[8] Braess, D. Finite Elements: Theory, Fast Solvers, and Applications in Solid Mechanics, 3 ed. Cambridge University
Press, 2007.
[9] Brandts, J., Hannukainen, A., Korotov, S., and Kˇrˆıˇzek, M. On angle conditions in the ﬁnite element method.
SeMA Journal 56, 1 (2011), 81–95.
[10] Brandts, J., Korotov, S., and Kˇr´ıˇzek, M. On the equivalence of regularity criteria for triangular and tetrahedral
ﬁnite element partitions. Comput. Math. Appl. 55, 10 (2008), 2227–2233.

LOCAL COARSENING ALGORITHMS ON ADAPTIVELY REFINED MESHES IN 2D
29
[11] Carstensen, C. An adaptive mesh-reﬁning algorithm allowing for an H1-stable L2-projection onto Courant ﬁnite
element spaces. Constr. Approx. 20, 4 (2004), 549–564.
[12] Chen, L., and Zhang, C. A coarsening algorithm on adaptive grids by newest vertex bisection and its applications.
J. Comput. Math. (2010), 767–789.
[13] Chou, S.-H., and He, S. On the regularity and uniformness conditions on quadrilateral grids. Comput. Methods
Appl. Math. 191, 45 (2002), 5149–5158.
[14] Ciarlet, P. G. The ﬁnite element method for elliptic problems. SIAM, 2002.
[15] Ciarlet, P. G., and Raviart, P.-A. Interpolation theory over curved elements, with applications to ﬁnite element
methods. Comput. Methods Appl. Mech. Eng. 1, 2 (1972), 217–249.
[16] Daniels, J., Silva, C. T., and Cohen, E. Localized quadrilateral coarsening. In Comput. Graph. Forum (2009),
vol. 28, Wiley Online Library, pp. 1437–1444.
[17] DeRose, T., Kass, M., and Truong, T. Subdivision surfaces in character animation. In Proceedings of the 25th
annual conference on Computer graphics and interactive techniques (1998), pp. 85–94.
[18] Funken, S. A., Praetorius, D., and Wissgott, P. Eﬃcient implementation of adaptive P1-FEM in Matlab.
Comput. Methods Appl. Math. 11, 4 (2011), 460–490.
[19] Funken, S. A., and Schmidt, A. ameshref – Eﬃcient Implementation of Adaptive Mesh Reﬁnement in 2D. Software
download at https://github.com/aschmidtuulm/ameshref, 2018.
[20] Funken, S. A., and Schmidt, A. Ameshref: A matlab-toolbox for adaptive mesh reﬁnement in two dimensions. In
Lect. Notes Comput. Sci. Eng. Springer International Publishing, 2019, pp. 269–279.
[21] Funken, S. A., and Schmidt, A. Adaptive Mesh Reﬁnement in 2D – An Eﬃcient Implementation in Matlab.
Comput. Methods Appl. Math. 20, 3 (2020), 459–479.
[22] Funken, S. A., and Schmidt, A. A coarsening algorithm on adaptive red-green-blue reﬁned meshes. Numerical
Algorithms (2020).
[23] Funken, S. A., and Schmidt, A. ameshcoars – Eﬃcient Implementation of Adaptive Mesh Coarsening in 2D.
Software download at https://github.com/aschmidtuulm/ameshcoars, 2020.
[24] Huang, F., Xie, X., and Zhang, C. An adaptive hybrid stress transition quadrilateral ﬁnite element method for
linear elasticity. J. Comput. Math. 34, 4 (2016), 339–364.
[25] Kobbelt, L. Interpolatory subdivision on open quadrilateral nets with arbitrary topology. In Comput. Graph. Forum
(1996), vol. 15, Wiley Online Library, pp. 409–420.
[26] Kossaczk`y, I. A recursive approach to local mesh reﬁnement in two and three dimensions. J. Comput. Appl. Math.
55, 3 (1994), 275–288.
[27] Mavriplis, D., and Jameson, A. Multigrid solution of the Euler equations on unstructured and adaptive meshes.
Multigrid Methods: Theory, Applications, and Supercomputing, SF McCormick, ed 110 (1988), 413–429.
[28] Ming, P., and Shi, Z. Quadrilateral mesh. Chinese Ann. Math. 23, 02 (2002), 235–252.
[29] Ming, P., and Shi, Z.-C. Quadrilateral mesh revisited. Comput. Method Appl. M. 191, 49-50 (2002), 5671–5682.
[30] M¨uller, H., and Jaeschke, R. Adaptive subdivision curves and surfaces. IEEE, 1998.
[31] Nochetto, R. H., Siebert, K. G., and Veeser, A. Theory of adaptive ﬁnite element methods: an introduction.
In Multiscale, nonlinear and adaptive approximation. Springer, 2009, pp. 409–542.
[32] Ollivier-Gooch, C. Coarsening unstructured meshes by edge contraction. Int. J. Numer. Methods Eng. 57 (05
2003), 391–414.
[33] Schmidt, A., and Siebert, K. G. Design of Adaptive Finite Element Software - The Finite Element Toolbox
ALBERTA, vol. 42 of Lect. Notes Comput. Sci. Eng. Springer, 2005.
[34] Sewell, E. Automatic Generation of Triangulations for Piecewise Polynomial Approximation. Purdue University,
1972.
[35] Verf¨urth, R. A review of a posteriori error estimation and adaptive mesh-reﬁnement techniques. John Wiley &
Sons Inc, 1996.
[36] Zhao, X., Mao, S., and Shi, Z. Adaptive ﬁnite element methods on quadrilateral meshes without hanging nodes.
SIAM J. on Sci. Comput. 32, 4 (2010), 2099–2120.

