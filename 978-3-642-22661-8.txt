
Igor Chikalov
Average Time Complexity of Decision Trees

Intelligent Systems Reference Library, Volume 21
Editors-in-Chief
Prof. Janusz Kacprzyk
Systems Research Institute
Polish Academy of Sciences
ul. Newelska 6
01-447 Warsaw
Poland
E-mail: kacprzyk@ibspan.waw.pl
Prof. Lakhmi C. Jain
University of South Australia
Adelaide
Mawson Lakes Campus
South Australia 5095
Australia
E-mail: Lakhmi.jain@unisa.edu.au
Further volumes of this series can be found
on our homepage: springer.com
Vol. 5. George A. Anastassiou
Intelligent Mathematics: Computational
Analysis, 2010
ISBN 978-3-642-17097-3
Vol. 6. Ludmila Dymowa
Soft Computing in Economics and Finance,
2011
ISBN 978-3-642-17718-7
Vol. 7. Gerasimos G. Rigatos
Modelling and Control for Intelligent
Industrial Systems, 2011
ISBN 978-3-642-17874-0
Vol. 8. Edward H.Y. Lim, James N.K. Liu,
and
Raymond S.T. Lee
Knowledge Seeker – Ontology Modelling for
Information
Search and Management, 2011
ISBN 978-3-642-17915-0
Vol. 9. Menahem Friedman and Abraham
Kandel
Calculus Light, 2011
ISBN 978-3-642-17847-4
Vol. 10. Andreas Tolk and Lakhmi C. Jain
Intelligence-Based Systems Engineering, 2011
ISBN 978-3-642-17930-3
Vol. 11. Samuli Niiranen and Andre Ribeiro
(Eds.)
Information Processing and Biological
Systems, 2011
ISBN 978-3-642-19620-1
Vol. 12. Florin Gorunescu
Data Mining, 2011
ISBN 978-3-642-19720-8
Vol. 13. Witold Pedrycz and Shyi-Ming Chen
(Eds.)
Granular Computing and Intelligent Systems,
2011
ISBN 978-3-642-19819-9
Vol. 14. George A. Anastassiou and Oktay
Duman
Towards Intelligent Modeling: Statistical
Approximation Theory, 2011
ISBN 978-3-642-19825-0
Vol. 15. Antonino Freno and Edmondo
Trentin
Hybrid Random Fields, 2011
ISBN 978-3-642-20307-7
Vol. 16. Alexiei Dingli
Knowledge Annotation: Making Implicit
Knowledge Explicit, 2011
ISBN 978-3-642-20322-0
Vol. 17. Crina Grosan and Ajith Abraham
Intelligent Systems, 2011
ISBN 978-3-642-21003-7
Vol. 18. Achim Zielesny
From Curve Fitting to Machine Learning,
2011
ISBN 978-3-642-21279-6
Vol. 19. George A. Anastassiou
Intelligent Systems: Approximation by
Artiﬁcial Neural Networks, 2011
ISBN 978-3-642-21430-1
Vol. 20. Lech Polkowski
Approximate Reasoning by Parts, 2011
ISBN 978-3-642-22278-8
Vol. 21. Igor Chikalov
Average Time Complexity of Decision Trees,
2011
ISBN 978-3-642-22660-1

Igor Chikalov
Average Time Complexity
of Decision Trees
123

Dr. Igor Chikalov
Mathematical and Computer Sciences
and Engineering Division
4700 King Abdullah University of Science
and Technology
Thuwal 23955-6900
Kingdom of Saudi Arabia
E-mail: igor.chikalov@kaust.edu.sa
ISBN 978-3-642-22660-1
e-ISBN 978-3-642-22661-8
DOI 10.1007/978-3-642-22661-8
Intelligent Systems Reference Library
ISSN 1868-4394
Library of Congress Control Number: 2011932437
c⃝2011 Springer-Verlag Berlin Heidelberg
This work is subject to copyright. All rights are reserved, whether the whole or
part of the material is concerned, speciﬁcally the rights of translation, reprinting,
reuse of illustrations, recitation, broadcasting, reproduction on microﬁlm or in
any other way, and storage in data banks. Duplication of this publication or
parts thereof is permitted only under the provisions of the German Copyright
Law of September 9, 1965, in its current version, and permission for use must
always be obtained from Springer. Violations are liable to prosecution under the
German Copyright Law.
The use of general descriptive names, registered names, trademarks, etc. in this
publication does not imply, even in the absence of a speciﬁc statement, that such
names are exempt from the relevant protective laws and regulations and therefore
free for general use.
Typeset & Cover Design: Scientiﬁc Publishing Services Pvt. Ltd., Chennai, India.
Printed on acid-free paper
9 8 7 6 5 4 3 2 1
springer.com

To my wife Julia and our daughter
Svetlana, for always believing in me and
loving me, no matter what.

Foreword
It is our great pleasure to welcome a new book “Average Time Complexity of
Decision Trees” by Igor Chikalov. This book is devoted to the study of average
time complexity (average depth and weighted average depth) of decision trees
over ﬁnite and inﬁnite sets of attributes. It contains exact and approximate
algorithms for decision tree optimization, and bounds on minimum average
time complexity of decision trees. The average time complexity measures can
be used in searching for the minimum description length of induced data
models. Hence, there exist relationships of the presented results with the
minimum description length principle (MDL).
The considered applications include the study of average depth of decision
trees for Boolean functions from closed classes, the comparison of results of
the performance of greedy heuristics for average depth minimization with
optimal decision trees constructed by dynamic programming algorithm, and
optimization of decision trees for the corner point recognition problem from
computer vision.
The book can be interesting for researchers working on time complexity
of algorithms and specialists in machine learning.
The author, Igor Chikalov, received his PhD degree in 2002 from Nizhny
Novgorod State University, Russia. During nine years he was working for
Intel Corp. as a senior software engineer/research scientist in machine learn-
ing applications to the control and diagnostic problems of semiconductor
manufacturing. Since 2009 he is a senior research scientist in King Abdul-
lah University of Science and Technology, Saudi Arabia. His current research
interests include supervised machine learning and extensions of dynamic pro-
gramming to the optimization of decision trees and decision rules.
The author deserves the highest appreciation for his outstanding work.
Mikhail Moshkov
May 2011
Andrzej Skowron

Preface
The monograph is devoted to theoretical and experimental study of decision
trees with a focus on minimizing the average time complexity. The study re-
sulted in upper and lower bounds on the minimum average time complexity
of decision trees for identiﬁcation problems. Previously known bounds from
information theory are extended to the case of identiﬁcation problem with
an arbitrary set of attributes. Some examples of identiﬁcation problems are
presented giving an evidence that the obtained bounds are close to unimprov-
able. In addition to universal bounds, we study eﬀectiveness of representing
several types of discrete functions in a form of decision trees. In particular,
for each closed class of Boolean functions we obtained upper bounds on the
average depth of decision trees implementing functions from this class.
The monograph also studies the problem of algorithm design for optimal
decision tree construction. An algorithm based on dynamic programming
is proposed that describes a set of optimal trees and allows for subsequent
optimization on other criteria. Experimental results show applicability of the
algorithm to real-life applications that are represented by decision tables
containing dozens of attributes and several thousands of objects.
Beside individual identiﬁcation problems, inﬁnite classes of problems are
considered. It describes necessary conditions on such classes in order to have
polynomial complexity algorithms for optimal decision tree construction.
The presented results can be of interest for researchers in test theory,
rough set theory and machine learning. Some results may be considered for
including in graduate courses on discrete mathematics and computer science.
The monograph can be used as a reference to prior results in the area.
Some results were obtained in collaboration with Dr. Mikhail Moshkov
and published in joint papers [51, 52, 53, 54, 56]. I am heartily thankful to
Dr. Moshkov for help in preparing this book.

X
Preface
I would like to acknowledge and extend my gratitude to Victor Eruhimov
for fruitful discussions about applications of decision trees and Dr. Andrzej
Skowron for constructive criticism and suggestions for improvement of the
book.
Thuwal, Saudi Arabia,
April 2011
Igor Chikalov

Contents
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
Basic Notions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.1.1
Information Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.1.2
Problems Over Information Systems . . . . . . . . . . . . . . . .
4
1.1.3
Decision Trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.1.4
Decision Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.1.5
Complexity Measures of Decision Trees. . . . . . . . . . . . . .
6
1.2
Overview of Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1.2.1
Bounds on Average Weighted Depth . . . . . . . . . . . . . . . .
7
1.2.2
Representing Boolean Functions by Decision Trees . . . .
9
1.2.3
Algorithms for Decision Tree Construction . . . . . . . . . . .
11
1.2.4
Restricted Information Systems . . . . . . . . . . . . . . . . . . . .
12
2
Bounds on Average Time Complexity of Decision Trees . .
15
2.1
Known Bounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
2.2
Bounds on Average Weighted Depth . . . . . . . . . . . . . . . . . . . . . .
16
2.3
Upper Bound on Average Depth. . . . . . . . . . . . . . . . . . . . . . . . . .
18
2.3.1
Process of Building Decision Trees YU,Ψ
. . . . . . . . . . . .
19
2.3.2
Proofs of Theorems 2.3 and 2.4 . . . . . . . . . . . . . . . . . . . .
20
2.4
On Possibility of Problem Decomposition . . . . . . . . . . . . . . . . . .
26
2.4.1
Proper Problem Decomposition . . . . . . . . . . . . . . . . . . . .
26
2.4.2
Theorem of Decomposition . . . . . . . . . . . . . . . . . . . . . . . .
27
2.4.3
Example of Decomposable Problem . . . . . . . . . . . . . . . . .
37
3
Representing Boolean Functions by Decision Trees . . . . . . .
41
3.1
On Average Depth of Decision Trees Implementing Boolean
Functions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
3.1.1
Auxiliary Notions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42

XII
Contents
3.1.2
Bounds on Function HB(n) . . . . . . . . . . . . . . . . . . . . . . . .
43
3.1.3
Proofs of Propositions 3.1-3.13 . . . . . . . . . . . . . . . . . . . . .
45
3.2
On Branching Programs with Minimum Average Depth . . . . .
58
4
Algorithms for Decision Tree Construction . . . . . . . . . . . . . . .
61
4.1
Algorithm A for Decision Tree Construction . . . . . . . . . . . . . . .
62
4.1.1
Representation of Set of Irredundant Decision Trees . .
63
4.1.2
Procedure of Optimization. . . . . . . . . . . . . . . . . . . . . . . . .
66
4.2
Greedy Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
69
4.3
Modeling Monotonic Boolean Functions by Decision Trees . . .
72
4.4
Constructing Optimal Decision Trees for Corner Point
Detection. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
74
4.4.1
Corner Point Detection Problem . . . . . . . . . . . . . . . . . . .
74
4.4.2
Experimental Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
5
Problems over Information Systems . . . . . . . . . . . . . . . . . . . . . .
79
5.1
On Bounds on Average Depth of Decision Trees Depending
Only on Entropy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
79
5.2
Polynomiality Criterion for Algorithm A . . . . . . . . . . . . . . . . . .
83
A
Closed Classes of Boolean Functions . . . . . . . . . . . . . . . . . . . . . .
87
A.1 Some Deﬁnitions and Notation . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
A.2 Description of All Closed Classes of Boolean Functions . . . . . .
89
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101

Chapter 1
Introduction
Decision trees appeared in 50-60s of the last century in theoretical computer
science [14, 64, 80] and applications [24, 37]. Similar objects are also con-
sidered by natural and social sciences, for example, taxonomy keys [30] or
questionnaires [63]. Decision trees naturally represent identiﬁcation and test-
ing algorithms that specify the next test to perform based on the results of
the previous tests. A number of particular formulations were generalized by
Garey [27] as identiﬁcation problem that is a problem of distinguishing ob-
jects described by a common set of attributes. More general formulation is
provided by decision table framework [34, 65] where objects can have incom-
plete set of attributes and non-unique class labels. In that case, acquiring
class label is enough to solve the problem: identifying a particular object is
not required. In this context, decision trees found many applications in test
theory [39, 45, 46, 81], fault diagnosis [14, 60, 72], rough set theory [61, 62],
discrete optimization, non-procedural programming languages [34], analysis
of algorithm complexity [38], computer vision [74], computational geometry
[69].
Decision tree is also a way of representing data in a structured hierarchical
manner. It describes a recursive partitioning of a set of objects into groups
according to the attribute values. Such representation reveals various patterns
in data like object similarity and common characteristics of several objects. If
objects are divided into classes, decision tree gives an idea of which attributes
are important for assigning an object to a certain class. In machine learning
problems, decision trees show ability to generalization that is capturing strong
dependencies only and ignoring the weak ones which are resulted from a ﬁnite
sample size and do not reﬂect properties of the data source [8, 71]. Compact
decision trees are easily interpreted by human experts that makes it favorable
over other models. The state-of-the-art statistical modeling techniques like
tree ensembles [7, 26] use decision trees for its insensitivity to outliers and
I. Chikalov: Average Time Complexity of Decision Trees, ISRL 21, pp. 1–14.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

2
1
Introduction
uniform way of dealing with numeric and categorical (discrete unordered)
attributes.
In most cases, multiple decision trees are available for the same problem.
Not all of them are equally favorable. Depending on the application, a tree
is required to have minimal storage complexity or guaranteed time complex-
ity in all cases, or minimal expected number of tests. This leads to diﬀerent
strategies for building of decision trees. Bounds on the minimum tree com-
plexity and algorithms for optimal tree constriction are studied in test theory
[21, 49, 46, 47, 81], rough set theory [57, 58, 79], search theory [1], machine
learning [33, 71]. It was discovered, that for almost all criteria, the problem
of building an optimal decision tree is NP-hard, and for many cases there are
results preserving a polynomial time approximation. The problem of design
of eﬀective algorithms for building decision trees is still open. Though, recent
advances proved that greedy algorithms [12, 32] build trees that are close to
optimal for some cases.
In this monograph, several known results on the average time complexity of
decision trees are generalized and a number of new problems are considered.
The main goal is to obtain bounds on the minimum average time complexity
of decision trees and design eﬀective algorithms for building decision trees for
some classes of information systems. Methods of combinatorics, probability
theory and complexity theory are used in the proofs as well as concepts from
various branches of discrete mathematics and computer science.
The monograph consists of ﬁve chapters. Chapter 2.4.3 considers bounds
on the minimum average weighted depth of decision trees. Upper and lower
bounds on the average time complexity of decision trees were known previ-
ously for a problem with a complete set of attributes. These bounds depending
only on the entropy of probability distribution follow from results of coding
theory [41, 77] and are widely applied in search theory (see, e.g. [1]). Chap-
ter 2.4.3 generalizes these bounds to the case of the average weighed depth
of decision trees for an arbitrary identiﬁcation problem. In the ﬁrst section,
an upper bound on the average weighted depth of decision trees and more
precise bound on the average depth are proved. These bounds depend on the
entropy and a parameter M(z), which is introduced by Moshkov in [46]. An
analogous parameter of the exact learning problem is called extended teach-
ing dimension [4, 33]. In general case, calculating M(z) is computationally
intractable, but for several classes of problems, either exact value or tight
bounds on M(z) can be obtained by theoretical analysis.
The second section describes conditions on the problem structure and the
probability distribution for objects that enable problem decomposition. Un-
der these conditions an optimal decision tree for the initial problem can be
synthesized from optimal decision trees for simpler problems. This technique

1
Introduction
3
is used to build a class of problems for which the minimum average depth of
decision tree is close to its upper bound given in the ﬁrst section.
Chapter 3.2 is devoted to several applications that can eﬀectively use de-
cision trees. It consists of two sections. The ﬁrst section studies the average
depth of decision trees implementing Boolean functions. A Shannon type
function is considered that describes growth of the average depth of decision
trees with growth of the number of arguments in the functions being imple-
mented. For each closed class of Boolean functions [68, 36], a lower and an
upper bound is obtained on a Shannon type function characterizing this class.
The obtained results are compared to the analogous results for the depth of
decision trees described in [48]. The notion of decision table partition used in
the proofs is similar to the notion of system of nonoverlapping coverings of
Boolean cube used in spectral methods of digital logic [6], but the type of cov-
ering is estimated from the parent closed class of the function rather than its
spectral properties. It allows to improve lower bounds on the average depth
of decision trees for some functions (e.g., the voting function and the logical
sum). The second section shows that each branching program with the mini-
mum average weighted depth is a read-once branching program. Due to this
fact, known exponential lower bounds on the number of nodes in read-once
branching programs for several combinatorial problems [59, 66, 83, 84, 85]
are applicable to branching programs with the minimum average weighted
depth.
Chapter 4.4.2 is devoted to algorithms for decision tree construction. The
ﬁrst section describes an algorithm A that builds a set of decision trees with
the minimum average weighted depth for a problem given in a form of de-
cision table. The idea of the algorithm is based on dynamic programming
[27, 42, 60, 76]. The second section describes experimental results of using A
for implementing Boolean functions by decision trees. The third section is de-
voted to greedy algorithms. It describes a general scheme of greedy algorithm,
deﬁnes several data impurity functions, and describes results of a comparative
study of performance of several greedy algorithms applied to data sets from
UCI Machine Learning Repository [25]. The fourth section describes results
of applying A to a practical problem of computer vision—fast detection of
corner points [75].
Chapter 5.2 considers a class of information systems called restricted in-
formation systems. It consists of two sections. The ﬁrst section proves that
for restricted information systems (and only for such systems), there exist
upper bounds on the average depth of decision trees that depend only on
the entropy of object probability distribution. The second section gives nec-
essary and suﬃcient conditions that make the time complexity of the above
considered algorithm A limited from above by a polynomial on the number of

4
1
Introduction
rows in a table. These conditions contain the requirement for the information
system to be restricted. In [1], the average depth of decision tree is studied
for some problems (e.g., the problem of ﬁnding a leak in a pipeline). The
obtained results generalize bounds from [1] to an arbitrary restricted infor-
mation system and give polynomial algorithms for building optimal decision
trees.
The monograph contains mainly theoretical results that can be used for
design of eﬀective algorithms for building decision trees and for analysis of
complexity of representing various objects by decision trees. These results
can be of interest for researchers in test theory, rough set theory and logical
analysis of data. The monograph can be used as a part of a course for graduate
students and Ph. D. studies.
1.1
Basic Notions
Denote ω = {0, 1, 2, . . .}, and for k ∈ω \ {0, 1}, denote Ek = {0, . . . , k −1}.
1.1.1
Information Systems
Let A be a nonempty set, F a set of functions deﬁned on A and taking
values from Ek, so that for any f ∈F, the condition f ̸≡const holds. The
functions from F are called attributes, and the pair U = (A, F) is called
k-valued information system (or simply information system) .
A weight function for the information system U is a function of the form
Ψ : F →{1, 2, . . .} that assigns a weight Ψ(f) to each attribute f ∈F.
1.1.2
Problems Over Information Systems
A problem over the information system U is deﬁned by a tuple z = (ν, f1, . . . ,
fn), where ν : En
k →{0, 1, . . ., kn −1} and f1, . . . , fn ∈F. The problem
z consists in ﬁnding the value z(a) = ν(f1(a), . . . , fn(a)) for an arbitrary
element a ∈A.
Two elements a and b from A are equivalent for the problem z if fi(a) =
fi(b) for i = 1, . . . , n. This equivalence relation deﬁnes a partition of A
into nonempty equivalence classes Q1, . . . , Qs. Let us denote by Tz the set
{ ¯d1, . . . , ¯ds} ⊆En
k where ¯di = (f1(a), . . . , fn(a)) and a ∈Qi, i = 1, . . . , s.
A problem z is called diagnostic if for any two tuples ¯di, ¯dj ∈Tz, ¯di ̸= ¯dj, the
condition ν( ¯di) ̸= ν( ¯dj) holds.

1.1
Basic Notions
5
Probability distribution for the problem z is a mapping P : Tz →ω \ {0}.
For ¯d ∈Tz, the value P( ¯d)/ 
¯δ∈Tz P(¯δ) can be interpreted as a probability
of the event (f1(a), . . . , fn(a)) = ¯d for an arbitrary element a from A.
1.1.3
Decision Trees
A decision tree for the problem z = (ν, f1, . . . , fn) is a ﬁnite oriented tree
with root in which:
• each nonterminal node is assigned with an attribute from the set {f1, . . . ,
fn} (i.e. decision trees use only the attributes listed in the description of
the problem z);
• each nonterminal node has exactly k outgoing edges which are labeled with
the numbers 0, . . . , k −1 respectively;
• each terminal node is assigned with a number from ω.
Let us describe the algorithm represented by a decision tree. Let the input
be an element a ∈A. First, the root is assigned to be the current node.
Let us describe one step of the algorithm. If the current node is terminal,
the algorithm returns as result the number assigned to the current node and
ﬁnishes. Otherwise, let fc be the attribute assigned to the current node. For
δ = 0, . . . , k −1, let eδ be the edge that leaves the current node and is labeled
with δ. The value fc(a) is calculated, and the node that the edge efc(a) enters
becomes the current node. Then the algorithm proceeds to the next step.
1.1.4
Decision Tables
Let U be a k-valued information system, Ψ a weight function for U, z =
(ν, f1, . . . , fn) a problem over U, and P a probability distribution for z. Let
Tz = { ¯d1, . . . , ¯ds}. The set Tz can be represented as a rectangular table ﬁlled
with numbers from Ek. Rows of the table correspond to the equivalence classes,
columns to the attributes, and each number is the value of the corresponding
attribute for all elements of the corresponding equivalence class. Let us assign
the i-th column with the weight of the attribute fi for i = 1, . . . , n, and assign
the row ¯dj with the numbers ν( ¯dj) and P( ¯dj) for j = 1, . . . , s. We will de-
note the resulted table T ∗
z and call it decision table for the problem z. Further
several algorithms will be considered that take as input a tabular representa-
tion of the problem z.
A two-player game can be associated with the table T ∗
z . The ﬁrst player
thinks of a row ¯d from T ∗
z . The goal of the second player is to ascertain the
number ν( ¯d) assigned to the row ¯d in T ∗
z . The second player is allowed to

6
1
Introduction
ask questions of the following form: he can choose a column and ask which
number is on the intersection of the column and the row that the ﬁrst player
has in mind. A strategy of the second player can be represented in a form of
a decision tree.
Denote Ωz = {(fi, δ) : fi ∈{f1, . . . , fn}, δ ∈Ek}, and denote Ω∗
z the
set of all ﬁnite words in the alphabet Ωz including the empty word λ. Let
us extend the mapping Ψ to the set Ω∗
z. Let α be an arbitrary word from
Ω∗
z. If α = λ, then Ψ(α) = 0. For α = (fi1, δ1) . . . (fit, δt), t > 0, assume
Ψ(α) = Ψ(fi1) + . . . + Ψ(fit).
Let α ∈Ω∗
z. Deﬁne a separable subtable Tzα of the table Tz in the following
way. If α = λ, then Tzα = Tz. Let α ̸= λ and α = (fi1, δ1) . . . (fim, δm). Then
Tzα is the subtable of the table Tz that contains only the rows which have
the numbers δ1, . . . , δm in the columns i1, . . . , im respectively. We will say
that a table is terminal if it contains no rows or ν(x) ≡const on the set of
rows. Denote S(z) the set of all nonterminal separable subtables of the table
Tz.
For an arbitrary table T from S(z), we denote by D(T ) the number of
rows in T and denote N(T, P) = 
¯d∈T P( ¯d).
Let Γ be a decision tree for the problem z. Set to the correspondence
to each path ξ = v1, r1, . . . , vt, rt, vt+1 in Γ a word π(ξ) ∈Ω∗
z. Let t ≥1,
for j = 1, . . . , t, the node vj be assigned with an attribute fij, and the
edge rj, leaving vj and entering vj+1 be assigned with a number δj. Then
π(ξ) = (fi1, δ1), . . . , (fit, δt). We assume π(ξ) = λ for a path ξ consisting of
a single node .
A path from the root to a terminal node is called complete. Denote
Ξ(Γ) the set of complete paths in decision tree Γ. One can see that

ξ∈Ξ(Γ) Tzπ(ξ) = Tz, and for any two diﬀerent complete paths ξ1, ξ2, the
relation Tzπ(ξ1) ∩Tzπ(ξ2) = ∅holds.
We will state that a decision tree Γ solves the problem z if for an arbitrary
row ¯d ∈Tz, the terminal node of the complete path ξ such that ¯d ∈Tzπ(ξ) is
assigned with the number ν( ¯d). In other words, for an arbitrary element a ∈
A, the terminal node of the path on which computations for a are performed
is labeled with the number z(a).
1.1.5
Complexity Measures of Decision Trees
Let U = (A, F) be an information system, Ψ a weight function for U and
z a problem over U. Let Γ be a decision tree for z that solves the problem
z. For an arbitrary row ¯d ∈Tz, denote ξ ¯d the complete path in Γ on which
computations for the n-tuple of attribute values ¯d are performed.

1.2
Overview of Results
7
As the main complexity measure the average weighted depth of the decision
tree Γ relative to the probability distribution P (or, brieﬂy, P-average weighted
depth of Γ) will be used. It is deﬁned in the following way:
hΨ(Γ, P, z) =
1
N(Tz, P)

¯d∈Tz
Ψ(π(ξ
¯d))P( ¯d) .
In addition to the average weighted depth, the weighted depth will be used
as a complexity measure of decision trees. Weighted depth of decision tree Γ
is deﬁned as follows:
gΨ(Γ, z) = max
¯d∈Tz
Ψ(π(ξ
¯d)) .
If Ψ ≡1, then the considered complexity measures are called average depth
and depth, and denoted h(Γ, P, z) and g(Γ, z). Further we will omit the symbol
z in the notations h(Γ, P, z) and g(Γ, z) if it is clear which problem is meant.
Denote hΨ(z, P) and h(z, P) respectively the minimum P-average weighted
depth and the minimum P-average depth of the decision tree for the prob-
lem z that solves z. For a weight function Ψ, a problem z and a probability
distribution P, a decision tree that solves z and has the minimum P-average
depth is called optimal for z and P, and a tree that solves z and has the
minimum P-average weighted depth is called optimal for Ψ, z and P.
1.2
Overview of Results
This section brieﬂy describes main theoretical results of the monograph.
1.2.1
Bounds on Average Weighted Depth
Let U be an information system and Ψ a weight function for U. First,
we deﬁne a parameter MΨ(z) for a problem z = (ν, f1, . . . , fn) over U. If
z(x) ≡const on the set A, then MΨ(z) = 0. Otherwise, for an arbitrary tuple
¯δ = (δ1, . . . , δn) ∈En
k , denote MΨ(z, ¯δ) the minimum natural number m such
that there exist numbers i1, . . . , ir ∈{1, . . . , n} possessing the following con-
ditions: Ψ(fi1) + . . . + Ψ(fir) ≤m and either the set of solutions on A of the
system of equations {fi1(x) = δi1, . . . , fir(x) = δir} is empty or z(x) ≡const
on this set. Then
MΨ(z) = max
¯δ∈En
k
MΨ(z, ¯δ) .
If Ψ ≡1, then the parameter MΨ(z) is denoted by M(z).
As a parameter of probability distribution P we will use the entropy of
probability distribution

8
1
Introduction
H(P) = log2 N(Tz, P) −
1
N(Tz, P)

¯d∈Tz
P( ¯d) log2 P( ¯d) .
If a diagnostic problem contains all possible attributes, then a known noise-
less coding theorem is applicable saying that the minimum average depth of
decision tree is between H(P) and H(P) + 1. The following theorem gener-
alizes the lower bound to the case of the average weighted depth of decision
tree for an arbitrary diagnostic problem.
Theorem. (Theorem 2.2 from Sect. 2.2) Let U be a k-valued information
system, Ψ a weight function for U, z a diagnostic problem over U, and P a
probability distribution for z. Then
hΨ(z, P) ≥H(P)
log2 k .
The following theorem gives an upper bound on the minimum average
weighted depth of decision tree for an arbitrary problem.
Theorem. (Theorem 2.3 from Sect. 2.2) Let U be an information system, Ψ
a weight function for U, z a problem over U, and P a probability distribution
for z. Then
hΨ(z, P) ≤MΨ(z)(H(P) + 1) .
Since the average depth of decision tree is a particular case of the average
weighted depth, the above considered bounds hold for the average depth as
well. However, the upper bound on the average depth can be improved.
Theorem. (Theorem 2.4 from Sect. 2.3) Let z be a problem over an infor-
mation system U, and P a probability distribution for z. Then
h(z, P) ≤
⎧
⎪
⎪
⎨
⎪
⎪
⎩
M(z) ,
if M(z) ≤1 ,
M(z) + 2H(P) ,
if 2 ≤M(z) ≤3 ,
M(z) +
M(z)
log2 M(z)H(P) ,
if M(z) ≥4 .
In Sect. 2.4, a possibility of reduction is considered for a problem over 2-valued
information system. An algorithm is described that constructs a decision
tree for the initial problem from decision trees for subproblems that form so-
called proper decomposition of the original problem. The section also contains
suﬃcient conditions for the synthesized decision tree to be optimal relative
to the average depth.

1.2
Overview of Results
9
The decomposition technique allows ﬁnding decision trees with the mini-
mum average depth for some classes of problems. In Sect. 2.4.3, it is used to
prove that the upper bound on the average depth of decision tree given by
Theorem 2.4 is close to unimprovable.
Theorem. For an arbitrary natural numbers m ≥2, n ≥3 there exists an
information system U n
m, a problem zn
m over U n
m with mn classes of equivalence
and a probability distribution P n
m ≡1 such that
h(z, P) ≥(M(z) −2)H(P)
2 log2 M(z)
.
This theorem immediately follows from Theorem 2.6 given in Sect. 2.4.3.
1.2.2
Representing Boolean Functions by Decision
Trees
In Chap. 3.2, eﬃciency of representation of Boolean functions by deci-
sion trees is studied. A Boolean function f(x1, . . . , xn) can be represented
as a problem z = (f, x1, . . . , xn) over the information system Un =
(En
2 , {x1, . . . , xn}). The problem z has two equivalence classes Q0 and Q1
containing the sets of binary tuples on which f takes the values 0 and 1
respectively. A decision tree solving the problem z is called a decision tree
implementing f. Denote by g(f) and h(f) respectively the minimum depth of
a decision tree implementing f and the minimum average depth of a decision
tree implementing f relative to the probability distribution P ≡1.
Denote by dim f the number of arguments of the function f. Let B be a
set of Boolean functions. Consider the functions
GB(n) = max{g(f) : f ∈B, dim f ≤n}
and
HB(n) = max{h(f) : f ∈B, dim f ≤n}
that characterize the growth in the worst case of the minimum depth and
the minimum average depth of decision trees implementing Boolean functions
from B with growth of the number of function arguments. Note that HB(n) ≤
GB(n) for any n.
Section 3.1.2 contains several statements that give an upper and a lower
bounds of HB(n) for each closed class of Boolean functions B. The nota-
tion of closed classes of Boolean functions is in accordance with [36]; the
classes and the class inclusion diagram are described in Appendix A. It is

10
1
Introduction
shown that the function HB(n) is either limited from above by a constant or
grows linearly. The work [48] gives exact values of GB(n) for each closed class
of Boolean functions. The following two theorems characterize the relation
between HB(n) and GB(n).
Theorem. (Theorem 3.2 from Sect. 3.1) Let B be a closed class of Boolean
functions, and n a natural number. Let at least one of the following conditions
hold:
a) n = 1;
b) B ∈{O1, . . . , O9, L1, . . . , L5, C1, C2, C3};
c) B ∈{C4, D1, D3} and n is odd;
d) B ∈{D1, D2, D3} and n = 2.
Then HB(n) = GB(n). If none of the conditions a), b), c), d) hold, then
HB(n) < GB(n).
Theorem. (Theorem 3.3 from Sect. 3.1) Let B be a closed class of Boolean
functions. Then
a) limn→∞HB(n)/GB(n) = 0 if B ∈{S1, S3, S5, S6, P1, P3, P5, P6};
b) HB(n)/GB(n) = 1 if B ∈{O1, . . . , O9, L1, . . . , L5, C1, C2, C3};
c) limn→∞HB(n)/GB(n) = 1 if B ∈{C4, M1, . . . , M4, D1, D2, D3};
d) limn→∞HB(n)/GB(n) = 1/2 if B ∈{F ∞
1 , . . . , F ∞
8 };
e) 1/2 −ε(n) < HB(n)/GB(n) < 1 where ε(n) = O(1/√n) if B ∈
{F μ
1 , . . . , F μ
8 } and μ ≥2.
If the number of nodes is estimated in addition to the average weighted depth,
it is reasonable to combine isomorphic subtrees in decision tree. The resulted
object is called branching program. A branching program is called read-once
if in any path from the root to a terminal node, each attribute encounters at
most once. The following theorem shows that the requirement to a branching
program to be read-once is rather strong as any branching program with the
minimum average weighted depth is a read-once branching program.
Theorem. (Theorem 3.4 from Sect. 3.2) Let U be a 2-valued information
system, Ψ a weight function for U, z a problem over U, and P a probability
distribution for z. Let G be a branching program for z that solves z and is
optimal for Ψ, z and P. Then G is a read-once branching program.
In [66], it is shown that a read-once branching program implementing the
function Mult : {0, 1}2n →{0, 1} (the middle bit of the multiplication of two
n-bit integers) contains at least 2Ω(√n) nodes. In [83, 84, 85], the function
n/2 −Clique−Only : {0, 1}n2 →{0, 1} is considered that receives adjacency
matrix of a graph with n nodes and takes the value 1 if and only if the graph

1.2
Overview of Results
11
contains a n/2-clique and does not contain any other edges. It is shown that a
read-once branching program implementing the function n/2−Clique−Only
contains at least 2Ω(n) nodes, while there is a branching program with O(n3)
nodes implementing n/2 −Clique −Only such that any attribute appears
at most twice in each path. In [59], it is shown that a branching program
implementing the characteristic functions of Bose-Chaudhuri codes contains
at least exp(Ω(√n/2)) nodes.
Theorem 3.4 shows that the branching programs that are optimal relative
to the average weighted depth have the same or greater number of nodes than
the read-once branching programs with the minimum number of nodes.
1.2.3
Algorithms for Decision Tree Construction
Let U = (A, F) be an information system and z = (ν, f1, . . . , fn) a problem
over U. Let T be a separable subtable of Tz. For i ∈{1, . . ., n}, denote
E(T, i) the set of numbers contained in i-th column of the table T , and
denote E(T ) = {i : i ∈{1, . . . , n}, |E(T, i)| ≥2}.
Among decision trees for the problem z that solve z we distinguish ir-
redundant decision trees. Consider an arbitrary node w of the tree Γ and
denote path(Γ, w) the path from the root to w. Let T = Tzπ(path(Γ, w)) be
a terminal subtable and ν(x) ≡r on the set of rows of the table T for some
r ∈ω. Then w is a terminal node labeled with r. Let T be a nonterminal
subtable. Then w is labeled with an attribute fi where i ∈E(T ). Finally,
each node w such that Tzπ(path(Γ, w)) = ∅is labeled with the number 0.
The following proposition shows that among irredundant decision trees,
at least one has the minimum average depth.
Proposition. (Proposition 4.1 from Sect. 4.1)
Let U be an information
system, Ψ a weight function for U, z a problem over U, and P a probabil-
ity distribution for z. Then there exists an irredundant decision tree that is
optimal for Ψ, z and P.
Denote by T ree(Tz) the set of irredundant decision trees for the problem z. In
Sect. 4.1, an algorithm A is described that constructs the set of optimal irre-
dundant decision trees for the problem z. At the ﬁrst stage of the algorithm,
a graph Δ(z) of separable subtables of the table Tz is constructed. The graph
in some sense describes all irredundant decision trees for the problem z. Then
the algorithm reduces the graph Δ(z) resulting the graph ΔΨ,P (z). The fol-
lowing theorem is a direct consequence of Proposition 4.2 and Theorem 4.1.
It characterizes the set of trees described by the graph ΔΨ,P (z).
Theorem. Let U be an information system, Ψ a weight function, z a problem
over U, and P a probability distribution for z. Then the algorithm A given

12
1
Introduction
the extended table T ∗
z builds a graph ΔΨ,P (z) that describes the set of all
irredundant decision trees that are optimal relative to the average weighted
depth.
For an arbitrary polynomial Q, a probability distribution P is called Q-
restricted if for an arbitrary row ¯d ∈Tz, the length of the binary notation of
the number P( ¯d) does not exceed Q(n) where n is the number of columns in
the table. One more theorem formulated in Sect. 4.1 characterizes the time
complexity of the algorithm A.
Theorem. (Theorem 4.2 from Sect. 4.1) Let Q(x) be some polynomial. Then
for an arbitrary problem z = (ν, f1, . . . , fn) and an arbitrary Q-restricted
probability distribution P for the problem z, the working time of the algorithm
A is proportional to the number of rows D(Tz) if the table T ∗
z is terminal. If
the table T ∗
z is nonterminal, the working time of the algorithm A is bounded
from below by the maximum of the values n, the number of nonterminal sep-
arable subtables |S(z)|, D(Tz) and the maximum length of attribute weight in
binary notation, and is bounded from above by a polynomial on these values.
1.2.4
Restricted Information Systems
Chapter 5.2 among all other information systems distinguishes so-called re-
stricted information systems. The property of being restricted implies a com-
mon upper bound on the minimum average weighted depth of decision tree
that depends only on the entropy of probability distribution and holds for all
problems over the information system. Another property of restricted infor-
mation systems is that under reasonable assumptions about weight function
and probability distribution, the working time of the algorithm A is limited
from above by a polynomial on the number of attributes in the problem
description.
For an arbitrary natural number t, a system of equations of the form
{f1(x) = δ1, . . . , ft(x) = δt} where f1, . . . , ft ∈F and δ1, . . . , δt ∈Ek, is
called a system of equations over
U. An information system U is called r-
restricted (restricted) if each compatible system of equations over U has an
equivalent subsystem that contains at most r equations.
For a system of equations {f1(x) = δ1, . . . , ft(x) = δt} over the information
system U, the value t
i=1 Ψ(fi) is called the weight of the system of equations.
An information system U is called r-restricted (restricted) relative to Ψ
if each compatible system of equations over U has an equivalent subsystem
whose weight does not exceed r.

1.2
Overview of Results
13
Example. (Example 5.1 from Sect. 5.1) Let A = Rn, and F be a nonempty
set of mappings from Rn to R. Consider an inﬁnite family of functions [F] =
{sign(f + α) + 1 : f ∈F, α ∈R} (note that the expression (sign(x) + 1)
takes the value 0 for a negative x, 1 for x = 0, and 2 for a positive x). If
|F| = k < ∞, then the information system U = (A, [F]) is 2k-restricted (or
2k-restricted relative to the weight function Ψ ≡1).
The following theorem for an arbitrary problem over a restricted information
system and an arbitrary probability distribution, gives an upper bound on
the minimum average weighted depth of decision tree that depends only on
the entropy of probability distribution.
Theorem. (Theorem 5.1 from Sect. 5.1) Let U be an information system, Ψ
a weight function for U, and U be r-restricted relative to Ψ where r is some
natural number. Then hΨ(z, P) ≤2r(H(P) + 1) for an arbitrary problem z
over U and an arbitrary probability distribution P for z.
The following theorem shows that the conditions of Theorem 5.1 are neces-
sary and suﬃcient for existence of a linear upper bound depending only on
the entropy and considering non-linear bounds does not extend the class of
information systems that have upper bounds depending only on the entropy.
Theorem. (Theorem 5.2 from Sect. 5.1) Let U be an information system
that is not restricted relative to the weight function Ψ for U. Then for an
arbitrary ε > 0, there is no function Φ that is limited within the interval [0, ε]
and possesses the condition hΨ(z, P) ≤Φ(H(P)) for any problem z over U
and any probability distribution P for z.
Denote Z(U) the set of problems over the information system U. For an
arbitrary problem z, denote by dim z the number of attributes listed in the
description of z.
Consider the functions
SU(n) = max{|S(z)| : z ∈Z(U), dim z ≤n}
and
DU(n) = max{D(Tz) : z ∈Z(U), dim z ≤n}
that characterize the dependence of the maximum number of separable subta-
bles and the maximum number of rows on the number of columns in decision
tables over U.
Let Ψ be restricted from above by some constant, and Q(x) be some poly-
nomial. Theorem 4.2 implies that for an arbitrary problem z over U and an
arbitrary Q-restricted probability distribution for the problem z, the time
complexity of the algorithm A is restricted from above by a polynomial on

14
1
Introduction
the number of attributes in the problem description if the functions SU(n)
and DU(n) are restricted from above by a polynomial on n. Also, one can see
that the time complexity of the algorithm A has an exponential lower bound
if the function SU(n) grows exponentially.
Theorem. (Theorem 5.3 from Sect. 5.2) Let U = (A, F) be a k-valued in-
formation system. Then the following statements hold:
a) if U is r-restricted, then SU(n) ≤(nk)r + 1 and DU(n) ≤(nk)r + 1 for
any natural number n;
b) if U is not restricted, then SU(n) ≥2n −1 for any natural number n.

Chapter 2
Bounds on Average Time Complexity of
Decision Trees
In this chapter, bounds on the average depth and the average weighted depth
of decision trees are considered. Similar problems are studied in search theory
[1], coding theory [77], design and analysis of algorithms (e.g., sorting) [38].
For any diagnostic problem, the minimum average depth of decision tree is
bounded from below by the entropy of probability distribution (with a mul-
tiplier 1/log2 k for a problem over a k-valued information system). Among
diagnostic problems, the problems with a complete set of attributes have the
lowest minimum average depth of decision trees (e.g, the problem of building
optimal preﬁx code [1] and a blood test study in assumption that exactly
one patient is ill [23]). For such problems, the minimum average depth of
decision tree exceeds the lower bound by at most one. The minimum aver-
age depth reaches the maximum on the problems in which each attribute
is “indispensable” [44] (e.g., a diagnostic problem with n attributes and kn
pairwise diﬀerent rows in the decision table and the problem of implementing
the modulo 2 summation function). These problems have the minimum av-
erage depth of decision tree equal to the number of attributes in the problem
description.
We also consider a possibility of problem decomposition. Some problems
have a hierarchy of attributes: “basic” attributes perform a rough classiﬁca-
tion, and “extended” ones can be applied to reﬁne the solution. In this case,
the leaf composition [44] can be applied: a tree for rough classiﬁcation is built
using basic attributes only, and then each leaf is replaced with a tree that
does ﬁne classiﬁcation using extended attributes only. We are interested in
ﬁnding the conditions that make the tree resulted from such composition to
have the minimum average time complexity. In this case, applying problem
decomposition leads to both comprehensive and eﬀective solution.
The chapter consists of four sections. The ﬁrst section gives a known bound
for a diagnostic problem with a complete set of attributes. The second section
I. Chikalov: Average Time Complexity of Decision Trees, ISRL 21, pp. 15–39.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

16
2
Bounds on Average Time Complexity of Decision Trees
generalizes the known lower bound and gives an upper bound for the average
weighted depth, which depends on the parameter M(z) and the entropy of
probability distribution. The third section gives more precise upper bound
for the minimum average depth of decision tree. The fourth section describes
suﬃcient conditions for problem decomposition which allow synthesizing an
optimal tree for the initial problem from optimal trees for subproblems. An
example of decomposable problem is considered that has the minimum aver-
age depth of decision tree close to the upper bound given in Sect. 2.3. The
results of this chapter were previously published in [16, 18, 51, 52, 53, 54].
2.1
Known Bounds
A problem z = (ν, f1, . . . , fn) with s equivalence classes Q1, . . . , Qs over a
k-valued information system U = (A, F) contains a complete set of attributes
if for an arbitrary partition {1, . . . , s} = 
j∈Ek Ij (where Ii ∩Ij = ∅if i ̸= j),
there exists an attribute ft ∈{f1, . . . , fn} such that
	
i∈Ij
Qi = {a ∈A : ft(a) = j}
for each j ∈Ek.
The following theorem gives a bound on the average depth of decision
tree for a diagnostic problem that contains a complete set of attributes. The
bound follows from coding theory results and is well known in search theory
(see, for example, [1]).
Theorem 2.1. Let z be a diagnostic problem with a complete set of attributes
over a k-valued information system U, and P a probability distribution for
z. Then
H(P)
log2 k ≤h(z, P) ≤H(P)
log2 k + 1 .
2.2
Bounds on Average Weighted Depth
The following theorem generalizes the lower bound to the case of the average
weighted depth of decision tree for an arbitrary diagnostic problem.
Theorem 2.2. Let U be a k-valued information system, Ψ a weight function
for U, z a diagnostic problem over U, and P a probability distribution for z.
Then
hΨ(z, P) ≥H(P)
log2 k .

2.2
Bounds on Average Weighted Depth
17
Proof. Let U = (A, F), z = (ν, f1, . . . , fn), and the problem z contains s
equivalence classes Q1, . . . , Qs. Let (I1
0, . . . , I1
k−1), . . . , (Ir
0, . . . , Ir
k−1) be all
possible partitions of the set {1, . . ., s} possessing the following conditions:
∪k−1
j=0It
j = {1, . . . , s}, and for any numbers i, j ∈Ek, i ̸= j, for t = 1, . . . , r,
the relation It
i ∩It
j = ∅holds. Deﬁne an attribute gt : A →Ek, t = 1, . . . , r,
as follows. If a ∈Qi and i ∈It
j, then gt(a) = j. Consider the problem
z′ = (ν′, f1, . . . , fn, g1, . . . , gr) over the information system U ′ = (A, F ∪
{g1, . . . , gr}) where ν′ : En+r
k
→ω, and ν′(δ1, . . . , δn, δn+1, . . . , δn+r) =
ν(δ1, . . . , δn) for each (δ1, . . . , δn+r) ∈En+r
k
. According to the deﬁnition of
the attributes g1, . . . , gr, we have that the problem z′ contains a complete set
of attributes, and z′ has the same equivalence classes as the problem z. Evi-
dently, z′(a) = z(a) for any element a ∈A. Then z′ is a diagnostic problem
and Theorem 2.1 implies
h(z′, P) ≥H(P)
log2 k .
(2.1)
Let Γ be a decision tree for the problem z that solves z. One can see that Γ
is a decision tree for the problem z′ that solves z′. Then
h(z, P) ≥h(z′, P) .
(2.2)
Since Ψ(f) ≥1 for an arbitrary attribute f ∈F, the relation hΨ(z, P) ≥
h(z, P) holds. The last inequality, (2.1) and (2.2) imply the bound given by
the theorem statement.
⊓⊔
The following theorem gives an upper bound on the minimum average
weighted depth of decision tree for an arbitrary problem.
Theorem 2.3. Let U be an information system, Ψ a weight function for U,
z a problem over U, and P a probability distribution for z. Then
hΨ(z, P) ≤MΨ(z)H(P) + MΨ(z) .
The following proposition shows that the additive constant MΨ(z) in the
right part of the inequality is inherent.
Proposition 2.1. For an arbitrary m ∈ω \ {0}, there exists a 2-valued in-
formation system U, a weight function Ψ for U, a problem z over U and a
sequence of probability distributions P1, P2, . . . for z, such that MΨ(z) = m,
limi→∞H(Pi) = 0, and limi→∞hΨ(z, Pi) = m.

18
2
Bounds on Average Time Complexity of Decision Trees
Proof. Let m ∈ω \ {0}. Deﬁne a 2-valued information system U as follows:
U = (A, F) where A = {0, 1, . . ., m}, F = {f1, . . . , fm} and
fi(a) =

1 ,
if i = a ,
0 ,
if i ̸= a ,
for any fi ∈F and a ∈A. Assume that Ψ(fi) = 1 for i = 1, . . . , m. Let
z = (ν, f1, . . . , fm) be a diagnostic problem. One can see that z has (m + 1)
equivalence classes Q0 = {0}, Q1 = {1}, . . ., Qm = {m}, the table Tz contains
(m+1) rows and it is not a terminal table. Consider a probability distribution
Pi for z, deﬁned as follows:
Pi(¯δ) =

i ,
if ¯δ = (0, 0, . . . , 0) ,
1 ,
if ¯δ ∈Tz \ {(0, 0, . . . , 0)} .
One can see that limi→∞H(Pi) = 0. Let ¯δ ∈Em
2 . It is easy to show, that
MΨ(z, ¯δ) = 1 for ¯δ ̸= (0, . . . , 0), and MΨ(z, ¯δ) = m for ¯δ = (0, . . . , 0). Conse-
quently, MΨ(z) = m.
Let i ∈ω \ {0}, Γ be a decision tree for the problem z that solves z,
and has hΨ(Γ, Pi) = hΨ(z, Pi). Consider a complete path ξ in Γ such that
(0, . . . , 0) ∈Tzπ(ξ). One can see that the length of the path ξ is at least
m. Consequently, hΨ(Γ, Pi) ≥mi/(i + m), and hΨ(z, Pi) ≥mi/(i + m).
Theorem 2.3 implies hΨ(z, Pi) ≤MΨ(z)(H(Pi) + 1) = m(H(Pi) + 1). Using
these relations, we have that limi→∞hΨ(z, Pi) = m.
⊓⊔
2.3
Upper Bound on Average Depth
Since the average depth of decision tree is a particular case of the average
weighted depth, the above considered upper and lower bounds hold for the
average depth as well. However, the upper bound on the average depth can
be improved.
Theorem 2.4. Let z be a problem over an information system U, and P a
probability distribution for z. Then
h(z, P) ≤
⎧
⎪
⎪
⎨
⎪
⎪
⎩
M(z) ,
if M(z) ≤1 ,
M(z) + 2H(P) ,
if 2 ≤M(z) ≤3 ,
M(z) +
M(z)
log2 M(z)H(P) ,
if M(z) ≥4 .
Theorem 2.6 in Sect. 2.4.3 characterizes quality of the obtained bound.

2.3
Upper Bound on Average Depth
19
2.3.1
Process of Building Decision Trees YU,Ψ
Let U = (A, F) be a k-valued information system, Ψ a weight function for
U, z = (ν, f1, . . . , fn) a problem over U, and P a probability distribution for
z. In this section, a process YU,Ψ is considered that takes as input z and P,
and builds a decision tree YU,Ψ(z, P) that solves the problem z. The bounds
given by Theorem 2.3 and Theorem 2.4 are resulted from analysis of decision
trees built by this process.
The set F can be uncountable and the function Ψ can be incomputable,
so in general case, the process YU,Ψ is a way of deﬁning the decision tree
YU,Ψ(z, P) rather than an algorithm.
The process YU,Ψ includes a subprocess XΨ that builds a decision tree
XΨ(z, P, T ) by given z, P and an arbitrary nonterminal subtable T of the
table Tz.
Deﬁne a mapping numz : Ω∗
z →ω. For j = 1, 2, . . ., denote by rj the
j-th prime number. Let β ∈Ω∗
z. If β = λ, then numz(β) = 1. Let β ̸= λ
and β = (fi1, δ1) . . . (fit, δt). Then numz(β) = ri1
1 × . . . × rit
t . The number
numz(β) will be called z-number of the word β.
For an arbitrary word α ∈Ω∗
z, denote h(α) the length of the word α and
denote χ(α) the set of letters from the alphabet Ωz that are contained in α.
Description of the subprocess XΨ
Let the subprocess XΨ be applied to the triplet z, P, T , where T is a
nonterminal subtable of the table Tz.
Step 1. For each i ∈{1, . . ., n}, assume σi to be the minimum number σ
from Ek for which
N(T (fi, σ), P) = max{N(T (fi, δ), P) : δ ∈Ek} .
Denote ¯σ = (σ1, . . . , σn). Let β be the word with the minimum z-number
among all words in Ω∗
z possessing the following conditions: χ(β) ⊆{(f1, σ1),
. . . , (fn, σn)}, the subtable T β is terminal, and Ψ(β) = MΨ(z, ¯σ). Note that
β ̸= λ, because the subtable T is nonterminal. Let β = (fi1, σi1) . . . (fim, σim).
Denote I1 = {fi1, . . . , fim}. Build a tree that consists of a single node. Assign
the word λ to this node. Denote G1 the obtained tree. Proceed to the step 2.
Let t ≥1 steps have been already done and a tree Gt and a set It have
been built.
Step (t + 1). Find in the tree Gt the only node w that is assigned with a
word from Ω∗
z. Denote α the word assigned to w.
If It = ∅, then assign to w the number 0 instead of the word α. Denote
the resulted tree XΨ(z, P, T ). The subprocess XΨ is completed.

20
2
Bounds on Average Time Complexity of Decision Trees
Let It ̸= ∅. Let j be the minimum number form the set {1, . . . , n} possess-
ing the following conditions: fj ∈It and
max{N(T α(fj, σ), P) : σ ∈Ek \ {σj}}
≥max{N(T α(fi, σ), P) : σ ∈Ek \ {σi}}
for any fi ∈It. Assign the attribute fj to the node w instead of the word α.
For each σ ∈Ek, add to the tree Gt a node wσ and the edge that leaves the
node w and enters wσ. Assign the number σ to that edge. Label the node wσ
with the word α(fj, σj) if σ = σj, or with the number 0 otherwise. Denote by
Gt+1 the resulted tree. Assume It+1 = It \ {fj}. Proceed to the step (t + 2).
Description of the process YU,Ψ
Let the process YU,Ψ be applied to the pair (z, P).
Step 1. Assume T = Tz. Build a decision tree that consists of a single node
v.
Let T be a terminal table. Then assign the number ν(¯δ) to the node v
where ¯δ is an arbitrary row from T . Denote YU,Ψ(z, P) the resulted decision
tree. The process YU,Ψ is completed.
Let T be a nonterminal table. Assign the word λ to the node v and proceed
to the next step.
Let t ≥1 steps have been already done. Denote G the tree built at the
step t.
Step (t + 1). If no node in G is assigned with a word from Ω∗
z, then denote
YU,Ψ(z, P) the tree G. The process YU,Ψ is completed. Otherwise, choose in
G a terminal node v, which is assigned with a word from Ω∗
z. Denote α the
word assigned to v.
Let T α be a terminal subtable. If T α = ∅, then assign to v the number 0
instead of the word α. If T α ̸= ∅, then assign to v the number ν(¯δ) instead
of α where ¯δ is an arbitrary row from T α. Proceed to the step (t + 2).
Let T α be a nonterminal subtable. Apply the subprocess XΨ to build the
decision tree XΨ(z, P, T α). For each complete path ξ in XΨ(z, P, T α), replace
the number 0 assigned to its terminal node, with the word απ(ξ). Denote Γ
the tree resulted from this replacement. Replace in G the node v with the
tree Γ. Proceed to the step (t + 2).
2.3.2
Proofs of Theorems 2.3 and 2.4
This section contains proofs of the upper bounds on the minimum average
time complexity of decision trees given in Sect. 2.2 and Sect. 2.3.

2.3
Upper Bound on Average Depth
21
Lemma 2.1. Let U = (A, F) be a k-valued information system, Ψ a weight
function for U, z = (ν, f1, . . . , fn) a problem over U, P a probability distribu-
tion for z, and T a nonterminal subtable of the table Tz. Then the following
conditions hold for each complete path ξ in the decision tree XΨ(z, P, T ):
a) Ψ(π(ξ)) ≤MΨ(z);
b) if T π(ξ) is a nonterminal subtable, then
N(T π(ξ), P) ≤N(T, P)/ max{2, h(π(ξ))} .
Proof. For each i ∈{1, . . . , n}, denote σi the minimum number from Ek such
that
N(T (fi, σi), P) = max{N(T (fi, σ), P) : σ ∈Ek} .
Denote ¯σ = (σ1, . . . , σn). Denote β a word from Ω∗
z with the minimum z-
number possessing the following conditions: χ(β) ⊆{(f1, σ1), . . . , (fn, σn)},
T β is a terminal table, and Ψ(β) = MΨ(z, ¯σ). Obviously, all letters in the
word β are pairwise diﬀerent. Using this property of the word β and the
description of the subprocess XΨ, one can show that there exists a complete
path ξ0 in the tree XΨ(z, P, T ) such that χ(π(ξ0)) = χ(β), and the words
π(ξ0) and β are of equal length. Then T π(ξ0) is a terminal subtable, and
Ψ(π(ξ0)) = Ψ(β). Taking into account the choice of the word β, we have
Ψ(π(ξ0)) = MΨ(z, ¯σ) .
(2.3)
Let π(ξ0) = (fj1, σj1) . . . (fjm, σjm). Denote α0 = λ, and for i = 1, . . . , m,
denote αi = (fj1, σj1) . . . (fji, σji). For i = 1, . . . , m, denote δji the minimum
number from Ek \ {σji} such that
N(T αi−1(fji, δji), P) = max{N(T αi−1(fji, σ), P) : σ ∈Ek \ {σji}} .
Let ξ be an arbitrary complete path in the decision tree XΨ(z, P, T ). Let
ξ = ξ0. By applying (2.3), we obtain Ψ(π(ξ0)) = MΨ(z, ¯σ) ≤MΨ(z). Let ξ ̸=
ξ0. One can see that there exist numbers r ∈{1, . . . , m} and δ ∈Ek such that
π(ξ) = αr−1(fjr, δ). Therefore, Ψ(π(ξ)) ≤Ψ(π(ξ0)) and Ψ(π(ξ)) ≤MΨ(z).
Part (a) of the lemma is proved.
Let ξ be an arbitrary complete path in the decision tree XΨ(z, P, T ), for
which T π(ξ) is a nonterminal subtable. The fact that the subtable T π(ξ0)
is terminal implies ξ ̸= ξ0. It is easy to see that there exist numbers r ∈
{1, . . . , m} and δ ∈Ek such that δ ̸= σjr and π(ξ) = αr−1(fjr, δ).
Let us show that N(T π(ξ), P) ≤N(T, P)/2. Evidently,
N(T π(ξ), P) ≤N(T (fjr, δ), P) .

22
2
Bounds on Average Time Complexity of Decision Trees
Taking into account the choice of the word σjr, we obtain that N(T (fjr, δ),
P) ≤N(T (fjr, σjr), P). Since δ ̸= σjr, the relation
N(T (fjr, δ), P) + N(T (fjr, σjr), P) ≤N(T, P)
holds. Consequently, N(T π(ξ), P) ≤N(T, P)/2.
Obviously, h(π(ξ)) = r. Let r ≥2. Let us show that N(T π(ξ), P) ≤
N(T, P)/r. Since δji+1 ̸= σji+1, the inequalities
N(T αi+1, P) + N(T αi(fji+1, δji+1), P) ≤N(T αi, P)
hold for i = 0, . . . , r −2. Summing these inequalities by i from 0 to r −2, we
obtain
N(T αr−1, P) +
r−2

i=0
N(T αi(fji+1, δji+1), P) ≤N(T, P) .
(2.4)
Let us show that for any i ∈{0, . . . , r −2},
N(T π(ξ), P) ≤N(T αi(fji+1, δji+1), P) .
(2.5)
The inequality
N(T αi(fjr, δ), P) ≤N(T αi(fji+1, δji+1), P)
follows from the choice of the attribute fji+1 (see description of the subprocess
XΨ) and the deﬁnition of the number δji+1. The inequality
N(T π(ξ), P) ≤N(T αi(fjr, δ), P)
is obvious. These two inequalities imply (2.5). The inequality N(T π(ξ), P) ≤
N(T αr−1, P) is obvious. This inequality, (2.4) and (2.5) imply rN(T π(ξ), P)
≤N(T, P). Since r ≥2, the relation N(T π(ξ), P) ≤N(T, P)/r holds. Part
(b) of the lemma is proved.
⊓⊔
Using the description of the process YU,Ψ and subprocess XΨ, and Lemma
2.1, it is not hard to prove the following proposition.
Proposition 2.2. Let U be an information system, and Ψ a weight function
for U. Then for any problem z over U and any probability distribution P
for z, the process YU,Ψ ends in a ﬁnite number of steps. The resulted tree
YU,Ψ(z, P) is a decision tree for the problem z that solves z.

2.3
Upper Bound on Average Depth
23
Proof of Theorem 2.3. If Tz is a terminal table, then the equality hΨ(YU,Ψ(z,
P)) = 0 follows from the description of the process YU,Ψ. This equality and
Proposition 2.2 imply hΨ(z, P) ≤0.
Let Tz be a nonterminal table. Consider an arbitrary row ¯d ∈Tz and ﬁnd
the complete path ξ ¯d in the decision tree YU,Ψ(z, P) such that ¯d ∈Tzπ(ξ ¯d).
From the description of the process YU,Ψ and the assumption that Tz is a
nonterminal table it follows that π(ξ ¯d) = π(ξ ¯d
1) . . . π(ξ ¯d
m) for some m ∈ω\{0}
where ξ ¯d
1 is a complete path in the decision tree XΨ(z, P, T ), and (if m ≥2)
ξ ¯d
i is a complete path in the decision tree XΨ(z, P, T π(ξ ¯d
1) . . . π(ξ ¯d
i−1)), i =
2, . . . , m.
By the assumption, the table Tz is nonterminal. If m ≥2, then the descrip-
tion of the process YU,Ψ implies T π(ξ ¯d
1) . . . π(ξ ¯d
i−1) is a nonterminal table for
i = 2, . . . , m. Applying part (a) of Lemma 2.1, we obtain Ψ(π(ξ ¯d
i )) ≤MΨ(z)
for i = 1, . . . , m. Consequently,
Ψ(π(ξ
¯d)) =
m

i=1
Ψ(π(ξ
¯d
i )) ≤mMΨ(z) .
(2.6)
Let us show that m ≤−log2 P( ¯d)+log2 N(Tz, P)+1. Evidently, the inequal-
ity holds for m = 1. Let m ≥2. Part (b) of Lemma 2.1 implies
N(Tzπ(ξ
¯d
1) . . . π(ξ
¯d
m−1), P) ≤N(Tz, P)
2m−1
.
One can see that ¯d ∈Tzπ(ξ ¯d
1) . . . π(ξ ¯d
m−1). Taking into account this condition,
we obtain
N(Tzπ(ξ
¯d
1) . . . π(ξ
¯d
m−1), P) ≥P( ¯d) .
Consequently, 2m−1 ≤N(Tz, P)/P( ¯d) and m ≤−log2 P( ¯d)+log2 N(Tz, P)+
1. The obtained inequality and (2.6) result in
Ψ(π(ξ
¯d)) ≤MΨ(z)(−log2 P( ¯d) + log2 N(Tz, P) + 1) .
From the deﬁnition of the weighted average depth it follows that
hΨ(YU,Ψ(z, P), P) =
1
N(Tz, P)

¯d∈Tz
Ψ(π(ξ
¯d))P( ¯d)
≤
1
N(Tz, P)MΨ(z)

¯d∈Tz
(log2 N(Tz, P) −log2 P( ¯d) + 1)P( ¯d)
= MΨ(z)(H(P) + 1) .
This inequality and Proposition 2.2 imply hΨ(z, P) ≤MΨ(z)(H(P) + 1).
⊓⊔

24
2
Bounds on Average Time Complexity of Decision Trees
Proof of Theorem 2.4. Let z = (ν, f1, . . . fn). If M(z) = 0, one can see that
the table Tz is terminal and h(z, P) = 0.
Let M(z) = 1. Assume that for i = 1, . . . , n, there exists a number δi ∈
Ek such that ν(x) ̸≡const on the set of rows of the subtable Tz(fi, δi).
Denote ¯δ = (δ1, . . . , δn). One can see that M(z, ¯δ) ≥2, but, according to the
deﬁnition, M(z, ¯δ) ≤M(z) = 1. This contradiction shows that there exists
an attribute fi ∈{f1, . . . , fn} such that for any δ ∈Ek, either Tz(fi, δ) is
empty or ν(x) ≡const on the set of rows of this table. It is easy to show
that there exists a decision tree Γ for the problem z that solves z for which
h(Γ, P) = 1. Consequently, h(z, P) ≤1.
Let M(z) ≥2. This inequality requires Tz to be a nonterminal table.
Consider an arbitrary row ¯d ∈Tz and ﬁnd a complete path ξ ¯d in the decision
tree YU,h(z, P) such that ¯d ∈Tzπ(ξ ¯d). From the description of the process
YU,h and from the fact that Tz is a nonterminal subtable it follows that
π(ξ ¯d) = π(ξ ¯d
1) . . . π(ξ ¯d
m) for some m ∈ω \ {0} where ξ ¯d
1 is a complete path in
the decision tree Xh(z, P, Tz), and (if m ≥2) ξ ¯d
i is a complete path in the
decision tree Xh(z, P, T π(ξt
1) . . . π(ξt
i−1)), i = 2, . . . , m. Denote r ¯d
i = h(π(ξ ¯d
i ))
for i = 1, . . . , m. Let us estimate the value h(π(ξ ¯d)) = m
i=1 r ¯d
i . We will prove
that
h(π(ξ
¯d)) ≤
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
−2 log2 P( ¯d) + 2 log2 N(Tz, P)
+M(z) ,
if 2 ≤M(z) ≤3 ,
M(z)
log2 M(z)(−log2 P( ¯d)
+ log2 N(Tz, P)) + M(z) ,
if M(z) ≥4 .
(2.7)
Let m = 1. Part (a) of Lemma 2.1 implies that r ¯d
1 ≤M(z). Therefore, the
inequality (2.7) holds for m = 1. Let m ≥2. Denote y ¯d
i = max{2, r ¯d
i } for i =
1, . . . , m. By the assumption, Tz is a nonterminal table. From the description
of the process YU,h it follows that Tzπ(ξ ¯d
1) . . . π(ξ ¯d
i ) is a nonterminal subtable
for i = 1, . . . , m −1. Lemma 2.1 and inequality m ≥2 imply
N(Tzπ(ξ
¯d
1) . . . π(ξ
¯d
m−1), P) ≤N(Tz, P)
m−1
i=1 y ¯d
i
.
Since ¯d ∈Tzπ(ξ ¯d
1) . . . π(ξ ¯d
m−1), we obtain N(T π(ξ ¯d
1) . . . π(ξ ¯d
m−1), P) ≥P( ¯d).
Consequently,
m−1

i=1
y
¯d
i ≤N(Tz, P)
P( ¯d)
.

2.3
Upper Bound on Average Depth
25
Taking the binary logarithm of both sides results in
m−1

i=1
log2 y
¯d
i ≤−log2 P( ¯d) + log2 N(Tz, P) .
This inequality implies
m

i=1
r
¯d
i = r
¯d
m +
m−1

i=1
(log2 y
¯d
i (r
¯d
i / log2 y
¯d
i ))
≤r
¯d
m + (
m−1

i=1
log2 y
¯d
i )(max{r
¯d
i / log2 y
¯d
i : i ∈{1, . . ., m −1}})
≤r
¯d
m −(log2 P(d) −log2 N(Tz, P))
×(max{r
¯d
i / log2 y
¯d
i : i ∈{1, . . . , m −1}}) .
(2.8)
Consider the function q(x) = x/ log2(max{2, x}), x ∈ω \ {0}. One can see
that q(0) = 0, q(1) = 1, q(2) = 2, q(3) < 2, q(4) = 2, and the function q(x)
is monotonically increasing for x ≥3. Therefore, for any n ∈ω \ {0}, the
following condition holds:
max{q(i) : i ∈{0, . . ., n}} =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
1 ,
if n = 1 ,
2 ,
if 2 ≤n ≤3 ,
n
log2 n ,
if n ≥4 .
(2.9)
From part (a) of Lemma 2.1 it follows that the inequality
r
¯d
i ≤M(z)
(2.10)
holds for i = 1, . . . , m. From (2.9), (2.10) and the inequality M(z) ≥2 we
have
max{r
¯d
i / log2 y
¯d
i : i ∈{1, . . ., m −1}}
≤max{q(i) : i ∈{0, . . . , M(z)}} =

2 ,
if 2 ≤M(z) ≤3 ,
M(z)
log2 M(z) ,
if M(z) ≥4 .

26
2
Bounds on Average Time Complexity of Decision Trees
These inequalities and inequalities (2.8) and (2.10) imply (2.7). Then
h(YU,h(z, P), P) =

¯d∈Tz
h(π(ξ
¯d))P( ¯d)
≤

M(z) + 2H(P) ,
if 2 ≤M(z) ≤3 ,
M(z) +
M(z)
log2 M(z)H(P) ,
if M(z) ≥4 .
Proposition 2.2 results in correctness of the theorem for M(z) ≥2.
⊓⊔
2.4
On Possibility of Problem Decomposition
In this section, a possibility of reduction is considered for a problem over
2-valued information system. Under certain conditions an optimal (relative
to the average depth) decision tree can be constructed as a composition of
optimal decision trees for simpler problems that form so-called proper de-
composition of the original problem.
2.4.1
Proper Problem Decomposition
Let U = (A, F) be a 2-valued information system, z0 = (ν0, f 0
1 , . . . , f 0
n0) a
diagnostic problem over U with m classes of equivalence A1, . . . , Am. Let
Tz0 = { ¯d0
1, . . . , ¯d0
m} where ¯d0
i = (f 0
1 (ai), . . . , f 0
n0(ai)), ai ∈Ai, i = 1, . . . , m.
For i = 1, . . . , m, let zi = (νi, f i
1, . . . , f i
ni) be a problem over the informa-
tion system (Ai, F) with si classes of equivalence, and the table Tzi contains
si rows ¯di
1, . . . , ¯di
si. For i = 1, . . . , m, let Pi be an arbitrary probability dis-
tribution for the problem zi, and P0 = (N(Tz1, P1), . . . , N(Tzm, Pm)) be a
probability distribution for the problem z0.
For i = 0, . . . , m and j = 1, . . . , si, denote ¯σi
j = (¯αi,j
0 ¯αi,j
1 . . . ¯αi,j
m ) where
¯αi,j
k
∈Enk
2 , k = 0, . . . , m, and
¯αi,j
k
=
⎧
⎪
⎪
⎨
⎪
⎪
⎩
¯d0
i ,
if k = 0 ,
¯di
j ,
if k = i ,
(0, . . . , 0) ,
if k ∈{1, . . .m} \ {i} .
Deﬁne a function ν : En0+...+nm
2
→ω as follows:
ν(¯δ) =

νi( ¯di
j) ,
if ¯δ = ¯σi
j for some i ∈{1, . . ., m}and j ∈{1, . . ., si} ,
0 ,
otherwise .

2.4
On Possibility of Problem Decomposition
27
Consider a problem z = (ν, f 0
1 , . . . , f 0
n0, ˜f 1
1 , . . . , ˜f 1
n1, . . . , ˜f m
1 , . . . , ˜f m
nm) over U,
where
˜f i
j(a) =

f i
j(a) ,
if a ∈Ai ,
0 ,
if a /∈Ai ,
for j = 1, . . . , ni, i = 1, . . . , m and a ∈A. One can see that the ta-
ble Tz contains the rows ¯σ1
1, . . . , ¯σ1
s1, . . . , ¯σm
1 , . . . , ¯σm
sm and does not con-
tain any other rows. Deﬁne a probability distribution P for the problem
z as follows: P(¯σi
j) = Pi( ¯di
j) for j = 1, . . . , si and i = 1, . . . , m. The set
((z0, P0), (z1, P1), . . . , (zm, Pm)) is called a proper decomposition of the pair
(z, P) if:
i) for j = 1, . . . , ni and i = 1, . . . , m, the inequality
N(Tzi(f i
j, 1), Pi) ≤minl∈1,...,m N(Tzl, Pl)
2
holds;
ii) for any i, j ∈{1, . . ., m}, i ̸= j and c ∈ω such that
qi =

¯d∈Tzi,νi( ¯d)=c
Pi( ¯d)/N(Tzi, Pi) > 0
and
qj =

¯d∈Tzj ,νj( ¯d)=c
Pj( ¯d)/N(Tzj, Pj) > 0 ,
the inequalities min(qi, qj) < 1/2 and max(qi, qj) < 1 hold.
Let ((z0, P0), (z1, P1), . . . , (zm, Pm)) be a proper decomposition of the pair
(z, P), and Γi be a decision tree for the problem zi that solves zi, i = 0, . . . , m.
For i = 1, . . . , m, apply the following transformation to the tree Γi. For each
nonterminal node w, replace the attribute f i
j that is assigned to w with the
corresponding attribute ˜f i
j. Denote the resulted tree by ˜Γi.
For i = 1, . . . , m, let us ﬁnd a complete path ξi in Γ0 such that ¯d0
i ∈
Tz0π(ξi) and replace the terminal node of the path ξi with the tree ˜Γi. Denote
the resulted tree by Φ(Γ0, Γ1, . . . , Γm).
2.4.2
Theorem of Decomposition
Theorem 2.5. Let z be a problem over a 2-valued information system U, P
a probability distribution for z, and ((z0, P0), (z1, P1), . . . , (zm, Pm)) a proper
decomposition of the pair (z, P). Let Γi be a decision tree for zi that solves zi

28
2
Bounds on Average Time Complexity of Decision Trees
and is optimal for zi and Pi, i = 0, . . . , m. Then the tree Φ(Γ0, Γ1, . . . , Γm)
is a decision tree for the problem z that solves z and is optimal for z and P.
We preface proof of the theorem by a series of lemmas. Let us deﬁne some
auxiliary notions.
Let Γ be a decision tree for the problem z. Denote V (Γ) and E(Γ) the
set of nodes and the set of edges of Γ respectively. For an arbitrary node
v ∈V (Γ), denote by path(Γ, v) the path from the root of Γ to the node
v. For an arbitrary nonterminal node v ∈V (Γ) and an arbitrary number
δ ∈{0, 1}, denote by e(Γ, v, δ) the edge that leaves v and is labeled with δ.
Let v be a nonterminal node in the tree Γ and f the attribute assigned to v.
The node v is called essential if the table Tzπ(path(Γ, v))(f, δ) is nonempty
for δ = 0, 1. The decision tree is called reduced if all its nonterminal nodes
are essential.
Let z be a problem over information system, P a probability distribution
for z, and ((z0, P0), (z1, P1), . . . , (zm, Pm)) a proper decomposition for the
pair (z, P). An attribute from the description of the problem z is called basic
if it is contained in the description of z0, or extended otherwise.
Let Γ be a reduced decision tree for the problem z, and ξ = v1, e1,
. . . , vt, et, vt+1 a complete path in Γ where v1, . . . , vt+1 ∈V (Γ) and e1, . . . ,
et ∈E(Γ), t ≥1. Let for some k ∈{1, . . . , t + 1}, the node vi be assigned
with a basic attribute if and only if i < k. Then the path ξ is called ordered
by basic attributes.
Let the path ξ be not ordered by basic attributes. For i = 1, . . . , t, denote
fi the attribute assigned to the node vi. Then there exist natural j and
k, j < k ≤t such that fj, . . . , fk−1 are extended attributes, fk is a basic
attribute, and (if j > 1) f1, . . . , fj−1 are basic attributes. Denote
N0(ξ) = N(Tzπ(path(Γ, vk))(fk, 0), P)
and
N1(ξ) = N(Tzπ(path(Γ, vk))(fk, 1), P) .
Since vk is assigned with a basic attribute and Γ is a reduced tree, we have
that for i = j, . . . , k −1, the edge ei is assigned with the number 0. For
i = j, . . . , k −1, denote wi the node that the edge e(Γ, vi, 1) enters, and
denote σi the number such that Tzπ(path(Γ, wi)) = Tzπ(path(Γ, wi))(fk, σi).
The path ξ is called reducible if k ≥j +3 and the set {σj, . . . , σk−1} contains
both 0 and 1.
Deﬁne a path reduction operation. Let the operation be applied to the
path ξ.

2.4
On Possibility of Problem Decomposition
29
Step 1. For δ = 0, 1, denote Γ(δ) the subtree that the edge e(Γ, vk, δ)
enters, and denote e(δ) = e(Γ, vk, δ). If vj is not the root of Γ, then reroute
the edge ej−1 so that it enters the node vk. Proceed to the step 2.
Let i steps have already been done for some 1 ≤i ≤k −j.
Step (i + 1). Reroute the edge e(σj+i−1) so that it enters the node vj+i−1.
Denote e(σj+i−1) = e(Γ, vj+i−1, 0). Proceed to the step (i + 2).
Step (k −j + 2). For δ = 0, 1, reroute the edge e(δ) so that it enters the
subtree Γ(δ). The transformation is completed.
Lemma 2.2. Let z be a problem over an information system, P a probability
distribution for z and D a proper decomposition for the pair (z, P). Let Γ
be a reduced decision tree for z that solves z, ξ a complete path in Γ that is
not ordered by basic attributes, and ˜Γ the tree resulted from applying the path
reduction operation to ξ. Then
a) ˜Γ is a decision tree for z that solves z;
b) h( ˜Γ, P) ≤h(Γ, P);
c) h( ˜Γ, P) ≤h(Γ, P) −(N0(ξ) + N1(ξ))/N(Tz, P) if ξ is a reducible path.
Proof. One can see from the description of the path reduction operation
that ˜Γ is a decision tree for the problem z. Let us show that ˜Γ solves z.
Let ξ = v1, e1, . . . , vt, et, vt+1 where v1, . . . , vt+1 ∈V (Γ), e1, . . . , et ∈E(Γ),
t ≥1, and for i = 1, . . . , t, the node vi is assigned with an attribute fi.
Then there exist natural j and k, j < k ≤t, such that fj, . . . , fk−1 are
extended attributes, fk is a basic attribute, and (if j > 1) f1, . . . , fj−1 are
basic attributes. Let ¯d ∈Tz be an arbitrary row, and φ a complete path
in Γ such that ¯d ∈Tzπ(φ). Denote ˜φ the complete path in ˜Γ that ends
in the same terminal node as φ. Let us show that ¯d ∈Tzπ(˜φ). If vj ̸∈φ,
then ˜φ = φ. If vk ∈φ, then the path ˜φ is obtained from φ by deleting
several pairs consisting of a node and one of its outgoing edges. Therefore
Tzπ(˜φ) ⊇Tzπ(φ). Let vi ∈φ and vi+1 ̸∈φ for some i ∈{j, . . . , k −1}.
Since vi+1 /∈φ, the edge that leaves the node vi and is contained in the
path φ, is labeled with 1. The fact that fi is an extended attribute implies
that the set of solutions of the equation fi(x) = 1 is contained in one of the
equivalence classes of the problem z0. Then there exists a number δ ∈{0, 1}
such that Tzπ(φ) = Tzπ(φ)(fk, δ). From the description of the path reduction
operation it follows that the path ˜φ is obtained from φ by deleting several
pairs consisting of a node and one of its outgoing edges and by adding the pair
(vk, e(Γ, vk, δ)). Therefore, Tzπ(˜φ) ⊇Tzπ(φ)(fk, δ), and, taking into account
the last relation, Tzπ(˜φ) ⊇Tzπ(φ). In general case, Tzπ(˜φ) ⊇Tzπ(φ) and
¯d ∈Tzπ(˜φ). Then the fact that Γ solves the problem z implies that ˜Γ also
solves z.

30
2
Bounds on Average Time Complexity of Decision Trees
Let us prove part (b) and (c) of the lemma. Since Γ is a reduced decision
tree, vk is an essential node. Then for δ = 0, 1, the table Tz0π(path(Γ, vj))
contains at least one row in which the attribute fk takes the value δ. Denote
this row ¯d0
iδ and denote Pδ = N(Tziδ , Piδ). For i = j, . . . , k −1, denote wi
the node which the edge e(Γ, vi, 1) enters, denote σi the number from the set
{0, 1} such that Tzπ(path(Γ, wi)) = Tzπ(path(Γ, wi))(fk, σi), and denote
Ni = N(Tzπ(path(Γ, vi)(fi, 1)), P) .
Then for δ = 0, 1, the following relation holds:
k−1

i=j,σi=δ
Ni + Nδ(ξ) ≥Pδ .
(2.11)
Consider several cases.
1) Let σj = . . . = σk−1. One can see that ξ is not a reducible path. Then
h( ˜Γ, P) = h(Γ, P) +
1
N(Tz, P)
⎛
⎝
k−1

i=j
Ni −(k −j)N1−σj(ξ)
⎞
⎠.
(2.12)
The relation (i) from the deﬁnition of the proper problem decomposition
implies Ni ≤P1−σj for i = j, . . . , k −1. Summing these inequalities, we
obtain
k−1

i=j
Ni ≤(k −j)P1−σj .
(2.13)
From (2.11) it follows that
N1−σj(ξ) ≥P1−σj .
(2.14)
The relations (2.12), (2.13), (2.14) imply (b).
2) Let k = j +2 and σj ̸= σj+1. One can see that ξ is not a reducible path.
Then
h( ˜Γ, P) = h(Γ, P) + Nj −Nσj+1(ξ)
N(Tz, P)
.
(2.15)
The relation (i) implies
Nj + Nj+1 ≤Pσj+1 .
(2.16)
From (2.11) it follows that
Nj+1 + Nσj+1(ξ) ≥Pσj+1 .
(2.17)

2.4
On Possibility of Problem Decomposition
31
The relations (2.15), (2.16), (2.17) imply (b).
3) Let k ≥j + 3, σj ̸= σj+1 and σj = σj+2. One can see that ξ is a
reducible path. Then
h( ˜Γ, P) ≤h(Γ, P) +
1
N(Tz, P)
×
⎛
⎝Nj −Nσj(ξ) −2Nσj+1(ξ) −
k−1

i=j+2,σi=σj+1
Ni
⎞
⎠.
(2.18)
The relation (i) implies
Nj + Nj+1 ≤Pσj+1 .
(2.19)
From (2.11) it follows that
Nj+1 +
k−1

i=j+2,σi=σj+1
Ni + Nσj+1(ξ) ≥Pσj+1 .
(2.20)
The relations (2.18), (2.19), (2.20) imply (c).
4) Let k ≥j + 3, σj ̸= σj+1 and σj ̸= σj+2. One can see that ξ is a
reducible path. Then
h( ˜Γ, P) ≤h(Γ, P) +
1
N(Tz, P)
×
⎛
⎝Nj −2Nσj(ξ) −Nσj+1(ξ) −
k−1

i=j+2,σi=σj
Ni
⎞
⎠.
(2.21)
The relation (i) implies that
Nj ≤1
2Pσj .
(2.22)
From (2.11) it follows that
Nj +
k−1

i=j+2,σi=σj
Ni + Nσj(ξ) ≥Pσj .
(2.23)
The relations (2.21), (2.22), (2.23) imply (c).
5) Let k ≥j + 3, σj = σj+1 = . . . = σm, and σm ̸= σm+1 for some
m ∈{j + 1, . . . , k −2}. One can see that ξ is a reducible path. Then

32
2
Bounds on Average Time Complexity of Decision Trees
h( ˜Γ, P) ≤h(Γ, P) +
m
i=j Ni
N(Tz, P) −(m −j)
N(Tz, P)
×
⎛
⎝
k−1

i=m+1,σi=σm+1
Ni −(m −j + 1)N1−σj(ξ) −Nσj(ξ)
⎞
⎠.
(2.24)
The relation (i) implies Ni ≤P1−σj/2 for i = j, . . . , m. Summing these
inequalities, we obtain
m

i=j
Ni ≤m −j + 1
2
P1−σj .
(2.25)
From (2.11) it follows that
k−1

i=m+1,σi=σm+1
Ni + N1−σj(ξ) ≥P1−σj .
(2.26)
The relations (2.24), (2.25), (2.26) imply (c).
One can see that the cases 1-5 cover all possible combinations of j, k,σj,. . . ,
σk−1. Statement (b) of the lemma holds for each case and statement (c) holds
for the cases in which ξ is a reducible path, so the lemma is proved.
⊓⊔
Lemma 2.3. Let U be a 2-valued information system, Ψ a weight function
for U, z a problem over U and P a probability distribution for z. Let Γ be a
decision tree for the problem z, that solves z and is optimal for Ψ, z and P.
Then Γ is a reduced decision tree.
Proof. Let U = (A, F). Suppose that Γ is not a reduced decision tree. Let v
be an inessential node in Γ such that the path φ from the root to the node v
does not contain any other inessential nodes. One can see that Tzπ(φ) ̸= ∅.
Denote by f the attribute assigned to v. Then there exists a number σ ∈{0, 1}
such that Tzπ(φ) = Tzπ(φ)(f, σ). For δ = 0, 1, denote Γδ the subtree whose
root the edge e(Γ, v, δ) enters. If v is not the root of Γ, then denote r the
edge that enters v and transform Γ so that the edge r enters the root of the
subtree Γσ. Delete from Γ the node v, the edges e(Γ, v, 0), e(Γ, v, 1) and the
subtree Γ1−σ. Denote ˜Γ the resulted tree. One can see that ˜Γ is a decision
tree for z. Let us prove that ˜Γ solves the problem z.
For an arbitrary row ¯d ∈Tz, denote ξ ¯d the complete path in Γ such that
¯d ∈Tzπ(ξ ¯d). Since Tzπ(φ) = Tzπ(φ)(f, σ), the terminal node of the path ξ ¯d
is not contained in Γ1−σ and was not removed by the transformation. De-
note ˜ξ ¯d the complete path in ˜Γ that ends in the same terminal node as ξ ¯d.

2.4
On Possibility of Problem Decomposition
33
If v ̸∈ξ ¯d, then the paths ξ ¯d and ˜ξ ¯d coincide, so Tzπ(ξ ¯d) = Tzπ(˜ξ ¯d) and
Ψ(ξ ¯d) = Ψ(˜ξ ¯d). If v ∈ξ ¯d, then the path ˜ξ ¯d is resulted from ξ ¯d by re-
moving the node v and the edge eσ. Then Ψ(ξ ¯d) = Ψ(˜ξ ¯d) −Ψ(f). Since
Tzπ(φ) = Tzπ(φ)(f, σ), the relation Tzπ(ξ ¯d) = Tzπ(˜ξ ¯d) holds. Then the fact
that Γ solves z, implies that ˜Γ solves z. The relation Tzπ(φ) ̸= ∅implies
v ∈ξ¯δ for some ¯δ ∈Tz. Then hΨ( ˜Γ, P) ≤hΨ(Γ, P)−Ψ(f)P(¯δ)/N(Tz, P) and
hΨ( ˜Γ, P) < hΨ(Γ, P). The latter equality contradicts optimality of the tree Γ
and the resulted contradiction proves the lemma.
⊓⊔
Lemma 2.4. Let z be a problem over an information system, P a probability
distribution for z, and D a proper decomposition of the pair (z, P). Then
there exists a decision tree for the problem z that solves z and is optimal for
z and P, in which each path is ordered by basic attributes.
Proof. Let Γ be a decision tree for z that solves z and is optimal for z and P.
Denote W(Γ) the set of nodes in Γ such that any node w ∈W(Γ) is assigned
with a basic attribute and at least one node in the path path(Γ, w) is assigned
with an extended attribute. Obviously, if W(Γ) = ∅, then all paths in Γ are
ordered by basic attributes.
Let W(Γ) ̸= ∅. Consider an arbitrary complete path ξ in Γ that is not
ordered by basic attributes. Let w be the ﬁrst node in ξ that is contained in
W(Γ). According to Lemma 2.3, Γ is a reduced decision tree. Let us apply
to ξ the path reduction operation and denote the resulted tree ˜Γ. Lemma 2.2
implies that ˜Γ is a decision tree for z that solves z and is optimal for z and
P. One can see that W( ˜Γ) ⊆W(Γ)\{w}. Let us apply the above-mentioned
transformation to ˜Γ and repeat this procedure until W( ˜Γ) = ∅. Thus the
desired decision tree is obtained in a ﬁnite number of steps.
⊓⊔
Let z be a problem over an information system, P a probability distribution
for z and ((z0, P0), (z1, P1), . . . , (zm, Pm)) a proper decomposition for the pair
(z, P). We will say that the tree Γ is completely ordered if for each row
¯d ∈Tz0, there exists a node v ¯d in Γ such that Tz0(path(Γ, v ¯d)) = { ¯d}, and all
nodes in the path path(Γ, v ¯d) are assigned with basic attributes with possible
exception of v ¯d.
Lemma 2.5. Let z be a problem over information system, P a probability
distribution for z, and D a proper decomposition for the pair (z, P). Then
there exists a decision tree for the problem z that solves z, is optimal for z
and P, and is completely ordered.
Proof. Let D = ((z0, P0), (z1, P1), . . . , (zm, Pm)), and zi = (νi, f i
1, . . . , f i
ni) for
i = 0, . . . , m. Let A1, . . . , Am be the equivalence classes of the problem z0,
Tz0 = {¯δ1, . . . , ¯δm}, and ¯δi = (f 0
1 (ai), . . . , f 0
n0(ai)), ai ∈Ai for i = 1, . . . , m.

34
2
Bounds on Average Time Complexity of Decision Trees
According to Lemma 2.4, there exists a decision tree Γ for the problem z
that solves z and is optimal for z and P, in which each complete path is
ordered by basic attributes. We will say that rows ¯δi, ¯δj ∈Tz0, i ̸= j are
separated in Γ with basic attributes if there is a node v ∈Γ that is assigned
with a basic attribute f 0
k, and for some number δ ∈{0, 1}, the relations
¯δi ∈Tz0π(path(Γ, v))(f 0
k , δ) and ¯δj ∈Tz0π(path(Γ, v))(f 0
k, 1−δ) hold. Denote
R(Γ) the number of unordered pairs of rows in the table Tz0, which are not
separated in Γ with basic attributes. Obviously, if R(Γ) = 0, then Γ is a
completely ordered decision tree.
Let R(Γ) ̸= 0. Let ¯δi = (δi
1, . . . , δi
n0) and ¯δj = (δj
1, . . . , δj
n0) be rows of Tz0,
which are not separated in Γ with basic attributes. Choose a number r ∈
{1, . . . , n0} such that δi
r ̸= δj
r. Consider a row ¯d = (d0
1, . . . , d0
n0, . . . , dm
1 , . . . ,
dm
nm) ∈Tz for which (d0
1, . . . , d0
n0) = ¯δi. Find a complete path φ in the
tree Γ such that ¯d ∈Tzπ(φ). The inequality (ii) implies that there exists a
row ¯c = (c0
1, . . . , c0
n0, . . . , cm
1 , . . . , cm
nm) ∈Tz such that (c0
1, . . . , c0
n0) = ¯δi or
(c0
1, . . . , c0
n0) = ¯δj, but ¯c /∈Tzπ(φ). Then at least one node in the path φ is
assigned with an extended attribute. Denote v1 the ﬁrst node of the path
φ that is assigned with an extended attribute, and denote G the subtree of
Γ whose root is v1. Denote ξ a complete path in G such that each edge is
assigned with the number 0. Let ξ = v1, e1, . . . , vt, et, vt+1 where v1, . . . , vt ∈
V (Γ) and e1, . . . , et ∈E(Γ). Consider two cases.
1) Let Tzπ(path(Γ, vt+1)) = Tzπ(path(Γ, vt+1))(f 0
r , σ) for some σ ∈{0, 1}.
Denote k the minimum number, for which the relation Tzπ(path(Γ, vk)) =
Tzπ(path(Γ, vk))(f 0
r , σ) holds. Denote ¯ek−1 = e(Γ, vk−1, 1), and denote w
the node, which the edge ¯ek−1 enters. Assign the attribute f 0
r to the node
vk−1, the number σ to the edge ek−1 and the number (1 −σ) to the edge
¯ek−1. Denote ˜Γ the resulted decision tree. In order to show that ˜Γ solves
z, it is suﬃcient to prove correctness of the equality Tzπ(path(Γ, w)) =
Tzπ(path(Γ, w))(f 0
r , 1−σ). Since the node v1 is assigned with an extended at-
tribute and the path ξ is ordered by basic attributes, the node vk−1 is assigned
with an extended attribute. Then Tzπ(path(Γ, w)) = Tzπ(path(Γ, w))(f 0
r , σ1)
for some σ1 ∈{0, 1}. By the choice of the number k, the relation
Tzπ(path(Γ, vk−1)) ̸= Tzπ(path(Γ, vk−1))(f 0
r , σ)
holds. Therefore,
Tzπ(path(Γ, w)) = Tzπ(path(Γ, w))(f 0
r , 1 −σ) ,
and ˜Γ solves the problem z. Obviously, h( ˜Γ, P) = h(Γ, P) and the tree ˜Γ is
optimal for z and P. Denote ˜ξ the complete path in the tree ˜Γ that ends in
the node vt+1. Let us apply to ˜ξ the path reduction operation and denote the

2.4
On Possibility of Problem Decomposition
35
resulted tree ˆΓ. From Lemma 2.2 it follows that ˆΓ is a decision tree for the
problem z that solves z and is optimal for z and P. One can see that each
complete path in ˆΓ is ordered by basic attributes, and R( ˆΓ) ≤R(Γ) −1.
2) Let Tzπ(path(Γ, vt+1)) ̸= Tzπ(path(Γ, vt+1))(f 0
r , σ) for σ = 0, 1. Then
the inequalities (i) and (ii) from the deﬁnition of the proper problem de-
composition imply that t ≥3, and for some k1, k2 ∈{1, . . ., t}, the node
vk1 is assigned with an attribute from the set { ˜f i
1, . . . , ˜f i
ni}, and the node
vk2 is assigned with an attribute from the set { ˜f j
1, . . . , ˜f j
nj}. Denote α the
number assigned to the node vt+1. Assign the attribute f 0
r to the node
vt+1, add two edges leaving this node and label them with the numbers
0 and 1 respectively. Add to the tree Γ two nodes w0 and w1, assign
the number α to these nodes and transform the tree Γ so that the edge
e(Γ, vt+1, σ) enters the node wσ for σ = 0, 1. Denote the resulted tree ˜Γ.
One can see that ˜Γ is a decision tree for the problem z that solves z and
h( ˜Γ, P) = h(Γ, P) + N(Tzπ(ξ), P)/N(Tz, P). Denote ˜ξ the complete path in
the tree ˜Γ that ends in w0. One can see that N0(˜ξ) + N1(˜ξ) = N(Tzπ(ξ), P).
Apply the path reduction operation to the path ˜ξ and denote the resulted
tree ˆΓ. From Lemma 2.2 it follows that ˆΓ is a decision tree for the problem
z that solves z, and h( ˆΓ, P) ≤h( ˜Γ, P) −(N0(˜ξ) + N1(˜ξ))/N(Tz, P). Then
h( ˆΓ, P) ≤h(Γ, P) and the decision tree ˆΓ is optimal for z and P. One can
see that each complete path in the tree ˆΓ is ordered by basic attributes and
R( ˆΓ) ≤R(Γ) −1.
Let us apply the above-mentioned transformation to ˆΓ and repeat this
procedure until R(Γ) = 0. Thus we obtain the desired decision tree in a
ﬁnite number of steps.
⊓⊔
Proof of Theorem 2.5. Let us show that the decision tree Φ = Φ(Γ0, Γ1, . . . ,
Γm) solves the problem z. Denote by A1, . . . , Am the equivalence classes of the
problem z0. Let Tz0 = { ¯d1, . . . , ¯dm} where ¯di = (f 0
1 (ai), . . . , f 0
n0(ai)), ai ∈Ai,
i = 1, . . . , m. Consider an arbitrary row ¯δ = (δ0
1, . . . , δ0
n0, . . . , δm
1 , . . . , δm
nm) ∈
Tz. Let (δ0
1, . . . , δ0
n0) = ¯di for some i ∈{1, . . . , m}. Denote ξ¯δ the complete
path in the decision tree Φ such that ¯δ ∈Tzπ(ξ¯δ). From the deﬁnition of the
tree Φ it follows that the terminal node of the path ξ¯δ belongs to the subtree
˜Γi. Since the decision tree Γi solves the problem zi, the terminal node of the
path ξi is assigned with the number νi(δi
1, . . . , δi
ni). From the deﬁnition of
proper decomposition we have ν(¯δ) = νi(δi
1, . . . , δi
ni). Therefore, Φ solves the
problem z.
Let us show that Φ is optimal for z and P. From Lemma 2.5 it follows
that there exists a decision tree G for the problem z that solves z, is opti-
mal for z and P, and is completely ordered. For i = 1, . . . , m, denote vi the

36
2
Bounds on Average Time Complexity of Decision Trees
node of the tree G such that Tz0π(path(G, vi)) = { ¯di} and all nodes in the
path path(G, vi), are assigned with basic attributes with possible exception
of the node vi. For i = 1, . . . , m, delete from the tree G the subtree whose
root is vi, but leave vi itself. Assign to vi the number ν0( ¯di). Denote the
resulted tree G0. According to Lemma 2.3, G is a reduced decision tree. It
implies that all nonterminal nodes of the tree G0 are encountered in the
paths path(G0, v1), . . . , path(G0, vm). Then all nonterminal nodes in G0 are
assigned with basic attributes and G0 is a decision tree for z0. One can see
that G0 solves z0. Then,
h(G0, P0) ≥h(z0, P0) .
(2.27)
Let zi = (νi, f i
1, . . . , f i
ni) for i = 0, . . . , m, and z = (ν, f 0
1 , . . . , f 0
n0, ˜f 1
1 , . . . ,
˜f 1
n1, . . . , ˜f m
1 , . . . , ˜f m
nm).
For an arbitrary i ∈{1, . . . , m}, consider the subtree ˜Gi of the tree G whose
root is the node vi. By deﬁnition, ˜f j
k ≡0 in the set Ai for any j ∈{1, . . . , m}\
{i}, k ∈{1, . . . , nj}. Then the fact that G is a reduced decision tree implies
that all nonterminal nodes of the tree ˜Gi are assigned with attributes from
the set { ˜f i
1, . . . , ˜f i
ni}. For each nonterminal node w in ˜Gi, let us replace the
attribute ˜f i
j assigned to w with the corresponding attribute f i
j. Denote Gi
the resulted tree. One can see that Gi is a decision tree for zi that solves zi.
Then
h(Gi, Pi) ≥h(zi, Pi) .
(2.28)
Let us compare the average depth of the trees G and Φ. One can see that
h(Φ, P) = h(Γ0, P0) +
1
N(Tz, P)
m

i=1
N(Tzi, Pi)h(Γi, Pi)
and
h(G, P) = h(G0, P0) +
1
N(Tz, P)
m

i=1
N(Tzi, Pi)h(Gi, Pi) .
Since Γ0, Γ1, . . . , Γm are optimal decision trees, the inequalities (2.27) and
(2.28) result in h(Φ, P) ≤h(G, P). Therefore, Φ is an optimal decision tree
for z and P.
⊓⊔

2.4
On Possibility of Problem Decomposition
37
2.4.3
Example of Decomposable Problem
Theorem 2.5 allows for ﬁnding decision trees with the minimum average depth
for some classes of problems. This section shows that the upper bound on the
average depth of decision tree given by Theorem 2.4 is close to unimprovable.
Theorem 2.6. For arbitrary natural numbers m ≥2, n, there exists a 2-
valued information system U n
m, a problem zn
m over U n
m with mn equivalence
classes and a probability distribution P n
m ≡1 such that H(P) = n log2 m,
M(z) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
m −1 ,
if n = 1 ,
m ,
if n = 2 ,
m + 1 ,
if n ≥3 ,
and h(z, P) = (m + 2)(m −1)
2m
n .
We preface the proof of the theorem by several auxiliary deﬁnitions. Let
m ≥2, n be arbitrary natural numbers. Deﬁne a system of circles Bn
m in
a plane. By deﬁnition, B1
m is m non-intersecting circles such that no one is
enclosed to another. Let the system Bi−1
m
have been already deﬁned. Then the
system Bi
m consists of m non-intersecting circles, such that no one is enclosed
to another, and there is a system of the kind Bi−1
m
inside each circle. A circle
in Bn
m is called zero order circle if it does not contain any circles from Bn
m. Let
for some i < n, circles of orders from zero to (i−1) have been already deﬁned.
A circle from Bn
m is called i-th order circle if the order of all enclosed circles
is at most (i −1) and is equal to (i −1) for at least one circle. One can see
that Bn
m contains s = mn zero order circles. Denote these circles C1, . . . , Cs.
For i = 1, . . . , s, denote ai a point inside Ci, and denote A = {a1, . . . , as}. Set
into correspondence to each circle C from Bn
m a function f : A →{0, 1}. The
function f takes the value 1 on an element ai if the point ai is located inside
the circle C, and 0 otherwise. Denote F = {f1, . . . , ft} the set of functions
that correspond to all circles from Bn
m. Then U n
m = (A, F).
Let zn
m = (ν, f1, . . . , ft) be a diagnostic problem over U n
m. The following
lemma gives the value of the parameter M(z) for the problem zn
m.
Lemma 2.6. Let m ≥2, n be arbitrary natural numbers. Then
M(zn
m) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
m −1 ,
if n = 1 ,
m ,
if n = 2 ,
m + 1 ,
if n ≥3 .

38
2
Bounds on Average Time Complexity of Decision Trees
Proof. Consider the case n ≥3. Let us calculate M(z, ¯δ) for an arbitrary
tuple ¯δ ∈{0, 1}t. Let ¯δ = (0, . . . , 0). The system of equations {f1(x) =
0, . . . , fm(x) = 0} does not have a solution on the set A if f1, . . . , fm are
pairwise diﬀerent attributes corresponding to (n −1)-th order circles. There-
fore, M(zn
m, ¯δ) ≤m. Let ¯δ ̸= (0, . . . , 0). Denote C0 a circle of the small-
est order such that its corresponding attribute takes the value 1 on ¯δ. De-
note n0 the order of the circle C0 and fi0 its corresponding attribute. If
n0 = 0, then the equation fi0(x) = 1 has a single solution on the set A, and
M(zn
m, ¯δ) = 1. Let n0 ≥1. Denote fi1, . . . , fim the attributes corresponding
to the (n0 −1)-th order circles that are enclosed into C0. By the choice of
C0, the attributes fi1, . . . , fim take the value 0 on ¯δ. The system of equations
{fi0(x) = 1, fi1(x) = 0, . . . , fim(x) = 0} does not have a solution on the set
A, so M(zn
m, ¯δ) ≤m + 1. Therefore,
M(zn
m) ≤m + 1 .
(2.29)
Let C2 be an arbitrary second order circle. Consider a tuple ¯δ = (δ1, . . . , δt)
in which the values of the attributes corresponding to C2 and all circles that
contains C2 are set to 1, and all other elements are set to 0. Let us show
that M(zn
m, ¯δ) ≥m + 1. Denote fi0 the attribute corresponding to C2, and
fi1, . . . , fim the attributes corresponding to the ﬁrst order circles enclosed
into C2. Let S = {fj1(x) = δj1, . . . , fjk(x) = δjk} be an arbitrary system of
equations that either does not have a solution on the A or zn
m(x) ≡const
on the set of solutions. Let l ∈{1, . . . , k}. Replace the equation fjl(x) = δjl
with the equation fir(x) = 0 if the circle corresponding to the attribute fjl
is either enclosed into the circle corresponding to fir or coincides with it
for some r ∈{1, . . . , m}. Otherwise, replace the equation fjl(x) = δjl with
the equation fi0(x) = 1. Let us make such replacement for l = 1, . . . , s,
and denote the resulted system S1. One can see that the system S1 contains
at most k equations, the set of solutions of S1 on A is a subset of the set
of solutions of S on A, and S1 is a subsystem of the system S2 = {fi0(x) =
1, fi1(x) = 0, . . . , fim(x) = 0}. Assume that S1 ̸= S2. One can see that in this
case zn
m(x) ̸≡const on the set of solutions of S1 on A. But this is impossible.
Therefore, k ≥m+1. Then any system of equations that either do not have a
solution on A or have a set of solutions coinciding with some equivalence class
contains at least (m + 1) equations, and M(zn
m, ¯δ) ≥m + 1. This inequality
and (2.29) imply M(zn
m) = m + 1. The cases n = 1 and n = 2 are considered
similarly.
⊓⊔
Proof of Theorem 2.6. We apply induction on n. Let n = 1. Deﬁne a decision
tree Γ for the problem z1
m. The decision tree Γ contains (m −1) nontermi-
nal nodes v1, . . . , vm−1, which are assigned with pairwise diﬀerent attributes

2.4
On Possibility of Problem Decomposition
39
f1, . . . , fm−1, and m terminal nodes vm, w1, . . . , wm−1. For i = 1, . . . , m −1,
two edges leave the node vi that are labeled with the numbers 0 and 1
respectively. The edge labeled with 0 enters the node vi+1 and the edge
labeled with 1 enters the node wi. For i = 1, . . . , m −1, the node wi is as-
signed with the number z1
m(ai) where ai is an element of the set A such that
fi(ai) = 1. The node vm is assigned with the number z1
m(a0) where a0 is an
element of the set A such that fi(a0) = 0 for i = 1, . . . , m −1. The decision
tree Γ does not contain any other nodes and edges. One can see that Γ solves
the problem z1
m and is optimal for z1
m and P 1
m. Let us calculate the average
depth of Γ:
h(Γ, P 1
m) = 1
m(
m−1

i=1
i + (m −1)) = (m + 2)(m −1)
2m
.
Then, h(z1
m, P 1
m) = (m + 2)(m −1)/(2m).
Let n be a natural number greater than 1 such that the theorem holds
for all natural numbers less than n. Denote C1, . . . , Cm the (n −1)-th or-
der circles contained in the system Bn
m, and f1, . . . , fm their correspond-
ing attributes. Consider a decomposition ((z0, P0), (z1, P1), . . . , (zm, Pm)) of
the pair (zn
m, P n
m). The diagnostic problem z0 contains only the attributes
f1, . . . , fm. For i = 1, . . . , m, the problem zi contains all attributes cor-
responding to the circles enclosed in Ci, and zi(x) is the mapping zn
m :
A →ω restricted to the set {a ∈A : fi(a) = 1}. Let for i = 0, . . . , m,
Pi be a uniform probability distribution for the problem zi. One can see
that ((z0, P0), (z1, P1), . . . , (zm, Pm)) is a proper decomposition of the pair
(zn
m, P n
m), h(z0, P0) = h(z1
m, P 1
m) and h(zi, Pi) = h(zn−1
m
, P n−1
m
) for i =
1, . . . , m. Using induction hypothesis, we obtain h(z0, P0) = (m + 2)(m −1)
/(2m) and h(zi, Pi) = [(m + 2)(m −1)/(2m)](n −1) for i = 1, . . . , m. Let Γi
be a decision tree for the problem zi that solves zi and is optimal for zi and
Pi, i = 0, . . . , m. Let Φ = Φ(Γ0, Γ1, . . . , Γm). From the deﬁnition of the tree
Φ it follows that
h(Φ, P n
m) = h(Γ0, P0) +
m

i=1
h(Γi, Pi)
m
= (m + 2)(m −1)
2m
n .
Using Theorem 2.5, we obtain h(zn
m, P n
m) = [(m + 2)(m −1)/(2m)]n.
⊓⊔

Chapter 3
Representing Boolean Functions by
Decision Trees
A Boolean or discrete function can be represented by a decision tree. A com-
pact form of decision tree named binary decision diagram or branching pro-
gram is widely known in logic design [2, 40]. This representation is equivalent
to other forms, and in some cases it is more compact than values table or even
the formula [44]. Representing a function in the form of decision tree allows
applying graph algorithms for various transformations [10]. Decision trees
and branching programs are used for eﬀective hardware [15] and software
[5] implementation of functions. For the implementation to be eﬀective, the
function representation should have minimal time and space complexity. The
average depth of decision tree characterizes the expected computing time,
and the number of nodes in branching program characterizes the number of
functional elements required for implementation. Often these two criteria are
incompatible, i.e. there is no solution that is optimal on both time and space
complexity.
The chapter considers several problems of representing functions in the
form of decision trees. It consists of two sections. The ﬁrst section studies the
average time complexity of representing Boolean functions by decision trees.
The complexity of a class of functions can be characterized by a Shannon type
function H(n) that shows the dependence of the minimum average depth of
decision tree in the worst case on the number of function arguments. For each
closed class of Boolean functions B, a lower and an upper bound on HB(n)
are given. Analogous results for the depth of decision trees are described in
[48]. The second section considers branching programs with the minimum
average weighted depth. It is proven that such programs are read-once, i.e.
each attribute is checked at most once along each path. This fact implies
high lower bounds on the number of nodes in branching programs with the
minimum average weighted depth for several known functions.
Results of this chapter were previously published in [19].
I. Chikalov: Average Time Complexity of Decision Trees, ISRL 21, pp. 41–60.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

42
3
Representing Boolean Functions by Decision Trees
3.1
On Average Depth of Decision Trees Implementing
Boolean Functions
This section contains some auxiliary notions followed by propositions that
give bounds on the function H(n) for all closed classes of Boolean functions.
The notation of closed classes of Boolean functions is in accordance with [36];
the classes and the class inclusion diagram are described in Appendix A.
3.1.1
Auxiliary Notions
A function of the form f : En
2 →E2 is called Boolean function. The constants
0 and 1 also are Boolean functions.
Let f(x1, . . . , xn) be a Boolean function. A variable xi of the function f
will be called essential if there exist two n-tuples ¯δ and ¯σ from En
2 which diﬀer
only in the i-th digit and for which f(¯δ) ̸= f(¯σ). Variables of the function f
which are not essential will be called inessential.
Let us set into correspondence to a Boolean function f(x1, . . . , xn) a prob-
lem z = (f, x1, . . . , xn) over the information system Un = (En
2 , {x1, . . . , xn}).
The problem z has two equivalence classes Q0 and Q1 containing the sets of
binary tuples on which f takes the value 0 and 1 respectively. A decision tree
solving the problem z is called a decision tree implementing f. Denote g(f)
and h(f) respectively the minimum depth of a decision tree implementing f
and the minimum average depth of a decision tree implementing f relative
to the probability distribution P ≡1.
Denote dim f the number of arguments of the function f. Let B be a set
of Boolean functions. Consider the functions
GB(n) = max{g(f) : f ∈B, dim f ≤n}
and
HB(n) = max{h(f) : f ∈B, dim f ≤n}
that characterize the growth in the worst case of the minimum depth and
the minimum average depth of decision trees implementing Boolean functions
from B with growth of the number of function arguments. Note that HB(n) ≤
GB(n) for any n.

3.1
On Average Depth of Decision Trees Implementing Boolean Functions
43
3.1.2
Bounds on Function HB(n)
In this section, a number of propositions are formulated that for each closed
class of Boolean functions B give the upper and the lower bound on HB(n)
followed by two theorems that compare the values GB(n) and HB(n).
Proposition 3.1. For B ∈{O2, O3, O7}, the relation HB(n) = 0 holds.
Proposition 3.2. For B ∈{O1, O4, O5, O6, O8, O9}, the relation HB(n) = 1
holds.
Proposition 3.3. For B ∈{S1, S3, S5, S6, P1, P3, P5, P6}, the relation
HB(n) =

2 −
1
2n−1 ,
if n ≥2 ,
1 ,
if n = 1 .
holds.
Proposition 3.4. For B ∈{L1, L2, L3, C1, C2, C3}, the relation HB(n) = n
holds.
Proposition 3.5. For B ∈{L4, L5}, the relation
HB(n) =

n ,
if n = 2k + 1 , k ≥0 ,
n −1 ,
if n = 2k, k ≥1
holds.
Proposition 3.6. For B = C4, the relation
HB(n) =

n ,
if n = 2k + 1, k ≥0 ,
n −
1
2n−1 ,
if n = 2k, k ≥1
holds.
Proposition 3.7. For B ∈{D1, D3}, the following relations hold:
a) HB(n) = n, if n = 2k + 1, k ≥0;
b) n −1.7/√n ≤HB(n) ≤n −1/2n−1, if n = 2k, k ≥1.
Proposition 3.8. For B ∈{M1, M2, M3, M4}, the relation
n + 1 −
√
n + 1 ≤HB(n) ≤n −⌊n/2⌋2−⌊n/2⌋
holds.

44
3
Representing Boolean Functions by Decision Trees
Proposition 3.9. For B = D2, the relation
n + 1/2 −
√
n + 1 ≤HB(n) ≤n −⌊n/2⌋2−⌊n/2⌋
holds.
Proposition 3.10. For B ∈{F ∞
1 , F ∞
4 , F ∞
5 , F ∞
8 }, the relation HB(n) = (n+
1)/2 holds.
Proposition 3.11. For B ∈{F ∞
2 , F ∞
3 , F ∞
6 , F ∞
7 }, the relation
1 + (n −√n)/2 ≤HB(n) ≤(n + 1)/2, n ≥1
holds.
Proposition 3.12. For B ∈{F μ
1 , F μ
4 , F μ
5 , F μ
8 }, μ ≥2, the relation
(n + 1)/2 ≤HB(n) ≤n −⌊n/2⌋2−⌊n/2⌋
holds.
Proposition 3.13. For any B ∈{F μ
2 , F μ
3 , F μ
6 , F μ
7 }, μ ≥2, the relation
1 + (n −√n)/2 ≤HB(n) ≤n −⌊n/2⌋2−⌊n/2⌋
holds.
The following theorem is proved by Moshkov.
Theorem 3.1 ([48]). Let B be a closed class of Boolean functions and n be
a natural number. Then
a) if B ∈{O2, O3, O7}, then GB(n) = 0;
b) if B ∈{O1, O4, O5, O6, O8, O9}, then GB(n) = 1;
c) if B ∈{L4, L5}, then GB(n) =

n ,
if n is odd ,
n −1 ,
if n is even ;
d) if B ∈{D1, D2, D3}, then GB(n) =

n ,
if n ≥3 ,
1 ,
if n ≤2 ;
e) if the class B does not coincide with any classes mentioned in (a) – (d),
then GB(n) = n.
The following two theorems immediately follow from the previous theorem
and Propositions 3.1-3.13. These theorems characterize the relation between
HB(n) and GB(n) for each closed class of Boolean functions.

3.1
On Average Depth of Decision Trees Implementing Boolean Functions
45
Theorem 3.2. Let B be a closed class of Boolean functions, and n a natural
number. Let at least one of the following conditions hold:
a) n = 1;
b) B ∈{O1, . . . , O9, L1, . . . , L5, C1, C2, C3};
c) B ∈{C4, D1, D3} and n is odd;
d) B ∈{D1, D2, D3} and n = 2.
Then HB(n) = GB(n). If none of the conditions (a), (b), (c), (d) hold, then
HB(n) < GB(n).
Theorem 3.3. Let B be a closed class of Boolean functions. Then
a) limn→∞HB(n)/GB(n) = 0 if B ∈{S1, S3, S5, S6, P1, P3, P5, P6};
b) HB(n)/GB(n) = 1 if B ∈{O1, . . . , O9, L1, . . . , L5, C1, C2, C3};
c) limn→∞HB(n)/GB(n) = 1 if B ∈{C4, M1, . . . , M4, D1, D2, D3};
d) limn→∞HB(n)/GB(n) = 1/2 if B ∈{F ∞
1 , . . . , F ∞
8 };
e)
1
2 −ε(n) < HB(n)
GB(n) < 1
where ε(n) = O(1/√n) if B ∈{F μ
1 , . . . , F μ
8 } and μ ≥2.
3.1.3
Proofs of Propositions 3.1-3.13
We preface proof of the propositions by a series of lemmas. Since in this
section the uniform probability distribution is assumed, it is omitted in no-
tations, so the average depth of a tree Γ is denoted by h(Γ).
For an arbitrary path ξ in a decision tree Γ, denote its length by lΓ (ξ).
Denote the logical negation operation by ¬ and the modulo 2 summation by
⊕. A Boolean function f(x1, . . . , xn) is called symmetrical if for each tuple
¯δ ∈En
2 and each permutation p of n elements, the relation f(¯δ) = f(p(¯δ))
holds.
Lemma 3.1. Let f0(x1, . . . , xn) and f1(x1, . . . , xn) be arbitrary Boolean
functions for some natural number n. Let Γ0 and Γ1 be decision trees im-
plementing f0 and f1 respectively. Let Γ be a decision tree of the following
form:
a) the root of Γ is assigned with the attribute xn+1;
b) for δ = 0, 1, an edge eδ leaves the root of Γ and enters the root of Γδ,
which is labeled with the number δ;
c) Γ does not contain any other nodes and edges.

46
3
Representing Boolean Functions by Decision Trees
Then the following statements are true:
a) the decision tree Γ implements the function ¬xn+1 ∧f0 ∨xn+1 ∧f1;
b) h(Γ) = 1 + (h(Γ0) + h(Γ1))/2.
Proof. Consider an arbitrary tuple ¯δ = (δ1, . . . , δn+1) and ﬁnd in the tree Γ
the path ξ(¯δ) on which computations for ¯δ are performed. Since the root of
Γ is assigned with the attribute xn+1, the terminal node of the path ξ(¯δ) is
located in the tree Γδn+1. Denote ¯δ∗= (δ1, . . . , δn) and denote ξδn+1(¯δ∗) the
part of ξ(¯δ) from the root of the tree Γδn+1 to the terminal node. One can
see that in the tree Γδn+1, computations for the tuple ¯δ∗are performed along
the path ξδn+1(¯δ∗). Since the tree Γδn+1 implements the function fδn+1, the
terminal node of the path ξ(¯δ) is assigned with the number fδn+1(δ1, . . . , δn) =
¬δn+1∧f0(δ1, . . . , δn)∨δn+1∧f1(δ1, . . . , δn). Therefore, the tree Γ implements
the function¬xn+1 ∧f0 ∨xn+1 ∧f1.
Obviously, the length of the path ξ(¯δ) is greater by 1 than the length of
the path ξδn+1(¯δ∗). Then
h(Γ) =
1
2n+1

δ∈En+1
2
lΓ (ξ(δ))
= 1
2
⎛
⎝1
2n

¯δ∗∈En
2
(lΓ (ξ0(¯δ∗)) + 1) + 1
2n

¯δ∗∈En
2
(lΓ (ξ1(¯δ∗)) + 1)
⎞
⎠
= 1
2(h(Γ0) + 1 + h(Γ1) + 1) = 1 + h(Γ0) + h(Γ1)
2
.
⊓⊔
The following lemma gives a combinatorial identity, which will be used fur-
ther. Denote g(n, t) = n
i=t Ct
i /2i.
Lemma 3.2. For arbitrary natural numbers n, t ≤n, the equality g(n, t) =
2 −1/2n t
i=0 Ci
n+1 holds.
Proof. Apply the following transformations:
g(n, t) =
n

i=t
1
2i Ct
i =
n+1

i=t
1
2i Ct
i −
1
2n+1 Ct
n+1 =
n

i=t−1
1
2i+1 Ct
i+1
−
1
2n+1 Ct
n+1 = 1
2

n

i=t−1
1
2i Ct
i +
n

i=t−1
1
2i Ct−1
i
−1
2n Ct
n+1

= 1
2

g(n, t) + g(n, t −1) −1
2n Ct
n+1

.

3.1
On Average Depth of Decision Trees Implementing Boolean Functions
47
Then we have
g(n, t) = g(n, t −1) −1
2n Ct
n+1 .
(3.1)
Let us modify g(n, 1) as follows:
g(n, 1) =
n

i=1
i
2i = 1
2 + 2
4 + . . . + n −1
2n−1 + n
2n = 1
2 + 2
4 + . . .
+n −1
2n−1 +
n
2n−1 −n
2n = 1 + 1
2 + 1
4 + . . . +
1
2n−1 −n
2n
= 1 −
1
2n
1 −1
2
−n
2n = 22n −1
2n
−n
2n = 2 −1
2n −n + 1
2n
.
Then g(n, 1) can be expressed in the following form:
g(n, 1) = 2 −1
2n

C0
n+1 + C1
n+1

.
(3.2)
The equalities (3.1) and (3.2) imply g(n, t) = 2−1/2n t
i=0 Ci
n+1.
⊓⊔
Lemma 3.3. The function
f(n) = (n + 1) −
√
2(n + 1)
√3n + 5 −(n + 3
2 −
√
n + 2)
takes positive values for any natural number n ≥3.
Proof. Convert all terms to the common denominator:
f(n) =
√
n + 2 −1
2 −
√
2(n + 1)
√3n + 5
= 2√n + 2√3n + 5 −√3n + 5 −2
√
2(n + 1)
2√3n + 5
=
φ(n)
2√3n + 5 .
The denominator is always positive, so f(n) has the same sign as φ(n). Apply
the following transformations:
φ(n) = (4n + 7) −(
√
3n + 5 −
√
n + 2)2 −
√
3n + 5 −2
√
2(n + 1)
> (4n + 7) −(
√
3n + 6 −
√
n + 2)2 −
√
3n + 5 −2
√
2(n + 1)
= (4n + 7) −(
√
3 −1)2(n + 2) −
√
3n + 5 −2
√
2(n + 1)
= 2(
√
3 −
√
2)n + 4
√
3 −2
√
2 −1 −
√
3n + 5 > 0.6n + 3 −
√
3n + 5
= ψ(n) .
The facts that ψ(n) is monotonically increasing and ψ(3) > 0 prove the
lemma.
⊓⊔

48
3
Representing Boolean Functions by Decision Trees
For an arbitrary natural number k, the Boolean function that takes value 1 if
and only if at least k its arguments are set to 1 is called a threshold function
with the threshold k. Denote by T hrn,k the threshold function of n variables
with the threshold k.
Lemma 3.4. For an arbitrary natural number n, the relation h(T hrn,⌈n/2⌉) ≥
n + 1 −√n + 1 holds, and for an arbitrary odd n ≥3, the relation
h(T hrn,(n+1)/2) ≥n + 3
2 −
√
n + 2
holds.
Proof. Denote m = ⌈n/2⌉. Let Γ be an optimal decision tree implementing
the function T hrn,m. Let us transform Γ as follows. We will process nonter-
minal nodes layer by layer starting from the root. Let v be the current node,
rv the distance from the root to v, and Γv the tree whose root is v. If v is
assigned with the attribute xrv+1, then skip this node and proceed to the
next node. Let v is assigned with an attribute xs that diﬀers from xrv+1.
Lemma 2.3 implies that Γ is a reduced tree. Then for each path in Γ, the
attributes assigned to the nonterminal nodes of this path are pairwise diﬀer-
ent. Therefore, no node in Γv except the root is assigned with the attribute
xs. Assign the attribute xrv+1 to the node v, assign the attribute xs to all
nonterminal nodes in Γv which were assigned with the attribute xrv+1, and
proceed to the next node.
One can see that Γv is a decision tree implementing the function T hrn,m(δ1,
. . . , δrv, xrv+1, . . . , xn) for some δ1, . . . , δrv ∈{0, 1}. Since this function is
symmetrical, the transformation keeps the function implemented by Γv and
does not change the average depth of the tree.
Denote ˆΓ the resulted tree. From the description of the transformation it
follows that ˆΓ is an optimal decision tree implementing the function T hrn,m,
and for i = 1, . . . , n, all nodes in the i-th layer are assigned with the attribute
xi. According to Lemma 2.3, ˆΓ is a reduced decision tree. One can see that for
a tuple ¯δ = (δ1, . . . , δn) ∈En
2 , the length of the path on which computations
for ¯δ are performed is equal to i if and only if one of the following conditions
hold:
• δi = 1, and exactly (m −1) elements of the tuple (δ1, . . . , δi−1) are equal
to one;
• δi = 0, and exactly (n −m) elements of the tuple (δ1, . . . , δi−1) are equal
to zero.
In other words, the length of the path is the minimum of the position of the
m-th one and the position of the (n −m + 1)-th zero in the tuple ¯δ.

3.1
On Average Depth of Decision Trees Implementing Boolean Functions
49
For i = 1, . . . , n, there are 2n−i(Cm−1
i−1
+ Cn−m
i−1 ) tuples corresponding to
the paths in ˆΓ of the length i. Then the average depth of the decision tree ˆΓ
is equal to
h( ˆΓ) = 2−n
n

i=1
i2n−i(Cm−1
i−1 + Cn−m
i−1 ) .
Applying simple transformations and using the previously introduced nota-
tion g(n, t), we obtain h( ˆΓ) = h(T hrn,m) = mg(n, m) + (n −m + 1)g(n, n −
m + 1). Applying Lemma 3.2, we obtain
h(T hrn,m) = 2(n + 1) −1
2n

m
m

i=0
Ci
n+1 + (n −m + 1)
n−m+1

i=0
Ci
n+1

.
If n is odd, then m = (n + 1)/2. Taking into account that (n + 1)/2 =
n −(n + 1)/2 + 1, and
(n+1)/2

i=0
Ci
n+1 = 2n + 1
2C(n+1)/2
n+1
as the number of binary tuples of the length (n + 1) containing at most
(n + 1)/2 ones, we have
h(T hrn,m) = (n + 1)

1 −
1
2n+1 C(n+1)/2
n+1

.
Using a known bound from [29] (see Chap. 8, Exercise 8.5.2)
Cn
2n ≤
4n
√3n + 1 ,
(3.3)
we obtain that h(T hrn,m) ≥(n + 1)(1 −
√
2/√3n + 5) ≥(n + 1) −√n + 1.
Applying Lemma 3.3, we obtain the bound h(T hrn,m) ≥n + 3/2 −√n + 2
for any odd n ≥3.
Let n be even. Then m = n/2. Taking into account that n/2
i=0 Ci
n+1 = 2n
and n/2+1
i=0
Ci
n+1 = 2n + Cn/2+1
n+1
, we have
h(T hrn,m) = (n + 1) −1
2n
n
2 + 1

Cn/2+1
n+1
= (n + 1)

1 −1
2n Cn/2
n

.
The inequality (3.3) implies h(T hrn,m) ≥(n + 1)(1 −
√
2/√3n + 2) ≥(n +
1) −√n + 1.
⊓⊔
Let z = (ν, f1, . . . , fn) be a problem over a 2-valued information system. A set
of terminal separable subtables {I1, . . . , Ik} of the table Tz is called compatible

50
3
Representing Boolean Functions by Decision Trees
if for some natural number l ≤n, there exist numbers a1, . . . , al ∈{1, . . . , n},
and for i = 1, . . . , k, there exist tuples ¯δi = (δi
1, . . . , δi
l) ∈El
2, ¯δi ̸= ¯δj for
i ̸= j, such that Ii = Tz(fa1, δi
1) . . . (fal, δi
l). We will say that the terminal
separable subtables I1, . . . , Ik form a partition of the table Tz if k
i=1 Ii = Tz,
and Ii ∩Ij = ∅for i ̸= j.
Lemma 3.5. Let z = (ν, f1, . . . , fn) be a problem over 2-valued information
system such that Tz = En
2 , and P be a probability distribution for the problem
z. Then the following statements are valid:
a) for an arbitrary compatible set of terminal separable subtables {I1, . . . ,
Ik} of the table Tz, the inequality
h(z, P) ≤n −
1
N(Tz, P)
k

i=1
log2 D(Ii)N(Ii, P)
(3.4)
holds;
b) there exists a partition of the table Tz for which the relation (3.4) holds
as equality.
Proof. Let us prove part (a) of the lemma. Let ν(x) ≡const = νi on the set
of rows of the table Ii for i = 1, . . . , k. Without loss of generality, assume
that Ii = Tz(f1, δi
1) . . . (fl, δi
l) for some δi
1, . . . , δi
l ∈E2, i = 1, . . . , k. Let us
build a decision tree Γ for the problem z in the following way.
Step 0. Build a complete binary tree of the length (l + 1). For i = 1, . . . , l,
assign the attribute fi to each node in the i-th layer and proceed to the ﬁrst
step.
Let t ≥0 steps have been already performed.
Step (t + 1). If each terminal node in the tree Γ has been already labeled
with a number, the algorithm ﬁnishes. Otherwise, choose in Γ an unlabeled
terminal node v. Denote by ξ the path from the root to the node v. If Tzπ(ξ) =
Ii for some i ∈{1, . . . , k}, then label the node v with the number νi and
proceed to the next step. Otherwise, replace the node v with a complete
binary tree Γv of the depth (n −l + 1), and for i = 1, . . . , n −l, assign the
attribute fl+i to all nonterminal nodes in the i-th layer of the tree Γv. Then
assign to each terminal node w of the tree Γv the natural number aw deﬁned
as follows. Denote by φ the path from the root of the tree Γ to the node w.
Since each of the attributes f1, . . . , fn is assigned to a node in the path φ
and Tz = En
2 , the subtable Tzπ(φ) consists of a single row. Denote that row
¯δ and assume aw = ν(¯δ). Proceed to the step (t + 2).
One can see that the algorithm ﬁnishes after the (2l+1)-th step and the
resulted decision tree solves the problem z. For an arbitrary tuple ¯δ ∈Tz,
denote by ξ(¯δ) the complete path on which computations for ¯δ are performed.

3.1
On Average Depth of Decision Trees Implementing Boolean Functions
51
From the description of tree building procedure, the length of ξ(¯δ) is equal
to l if ¯δ ∈Ii for some i ∈{1, . . . , k}, and is equal to n otherwise. Denote
I = I1 ∪. . . ∪Ik. Then the expression for the average depth of the decision
tree Γ has the following form:
h(Γ, P) =
1
N(Tz, P)
⎛
⎝n

¯δ∈Tz\I
P(¯δ) + l

¯δ∈I
P(¯δ)
⎞
⎠
= n −
1
N(Tz, P)
k

i=1
(n −l)N(Ii, P) .
(3.5)
Since Tz = En
2 , each subtable Ii contains exactly 2n−l rows, and log2 D(Ii)
= n −l. Taking into account the obvious inequality h(z, P) ≤h(Γ, P), the
inequality (3.5) can be easily transformed into (3.4).
Let us prove part (b) of the lemma. Let Γ be an optimal decision tree for
the problem z. Denote by W(Γ) the set of nonterminal nodes in the decision
tree Γ. For an arbitrary terminal node w ∈W(Γ), denote by path(w) the
path from the root to the node w. Since the tree Γ solves z, Tzπ(path(w)) is
a terminal subtable, Tzπ(path(w1)) ∩Tzπ(path(w2)) = ∅for any two diﬀer-
ent nodes w1 and w2, and 
w∈W(Γ) Tz(π(path(w))) = Tz. For an arbitrary
terminal node w ∈W(Γ), denote Iw = Tzπ(path(w)) and choose the set
{Iw : w ∈W(Γ)} as the desired partition. From Lemma 2.3 it follows that
Γ is a reduced tree. Then for an arbitrary terminal node w ∈W(Γ), the
nonterminal nodes of the path path(w) are assigned with pairwise diﬀerent
attributes. From the condition Tz = En
2 it follows that the number of rows in
the subtable Iw is equal to 2n−lΓ (path(w)). Therefore, the length of the path
on which computations for all rows of the table Iw are performed is equal to
(n −log2 D(Iw)). Finally, we transform the expression for the average depth
of the decision tree Γ:
h(Γ, P) =
1
N(Tz, P)

¯δ∈Tz
lΓ (ξ(¯δ))P(¯δ)
=
1
N(Tz, P)

w∈W(Γ)
lΓ (path(w))N(Iw, P)
=
1
N(Tz, P)

w∈W(Γ)
(n −log2 D(Iw))N(Iw, P)
= n −
1
N(Tz, P)

w∈W(Γ)
log2 D(Iw)N(Iw, P) .
⊓⊔

52
3
Representing Boolean Functions by Decision Trees
Lemma 3.6. For an arbitrary natural number n, the minimum average depth
of decision trees implementing Boolean functions x1 ⊕. . .⊕xn and x1 ⊕. . .⊕
xn ⊕1 is equal to n.
Proof. Let z = (f, x1, . . . , xn) be a problem corresponding to the function
f(x1, . . . , xn) = x1 ⊕. . . ⊕xn. Let us show that Tz does not have terminal
separable subtables that contain more than one row. Assume the contrary.
Let there exist a word α ∈Ωz such that Tzα is a terminal separable subtable
containing at least two rows ¯δ = (δ1, . . . , δn) and ¯σ = (σ1, . . . , σn), ¯δ ̸= ¯σ.
Let δi ̸= σi for some i ∈{1, . . ., n}. Then the word α does not contain the
letters (xi, 0) and (xi, 1). Since Tz = En
2 , the subtable Tzα also contains the
row ¯δ∗= (δ1, . . . , δi −1, ¬δi, δi+1, . . . , δn). Since f(¯δ) ̸= f(¯δ∗), we obtain a
contradiction with the assumption that Tzα is a terminal subtable. Therefore,
all terminal separable subtables of Tz consist of a single row. From part (b)
of Lemma 3.5 it follows that h(f) = n. The lemma is proved analogously for
the function x1 ⊕. . .⊕xn ⊕1.
⊓⊔
Lemma 3.7. Let f(x1, ..., xn) be an arbitrary non-constant Boolean function.
Denote by ˆf one of the functions f(x1, ..., xn) ∧xn+1, f(x1, ..., xn) ∧¬xn+1,
f(x1, ..., xn)∨xn+1, f(x1, ..., xn)∨¬xn+1. Then the relation h( ˆf) = 1+h(f)/2
holds.
Proof. Let us prove the lemma by induction on the number of essential vari-
ables of the function f. Obviously, each function that have a single essential
variable can be represented (up to inessential variables) in the form f(x) = x
or f(x) = ¬x, and the lemma is valid for these functions.
Let the lemma be valid for all functions with at most (t −1) essential
variables for some t > 1. Let f be a function with t essential variables.
Denote ˆf = f(x1, ..., xn) ∧xn+1.
Let us build a decision tree ˆΓ in the following way. The root of ˆΓ is assigned
with the attribute xn+1. Two edges leave the root labeled with the numbers
0 and 1. The edge labeled with 0 enters a terminal node which is labeled with
the number 0. The edge labeled with 1 enters the root of an optimal decision
tree implementing the function f. The decision tree ˆΓ does not contain any
other nodes and edges. It is easy to see that ˆΓ implements the function ˆf.
According to Lemma 3.1,
h( ˆΓ) = 1 + h(f)
2
.
(3.6)
To prove the lemma it is suﬃcient to show that ˆΓ is an optimal decision
tree. Assume the contrary. In this case, there exists an optimal decision tree

3.1
On Average Depth of Decision Trees Implementing Boolean Functions
53
Γ whose root is assigned with an attribute other than xn+1. Assume without
loss of generality that it is the attribute x1. For δ = 0, 1, denote eδ the edge
that leaves the root of Γ and is labeled with the number δ, and denote Γδ the
decision tree whose root the edge eδ enters. One can see that the decision tree
Γδ implements the function f(δ, x2, . . . , xn) ∧xn+1. Since f has t essential
variables, at least one of the functions f(0, x2, . . . , xn), f(1, x2, . . . , xn) is a
non-constant function. Let both functions possess this condition. Then the
induction base implies that for δ = 0, 1, the relation
h(f(δ, x2, . . . , xn) ∧xn+1) = 1 + h(f(δ, x2, . . . , xn))
2
(3.7)
holds. From Lemma 3.1 it follows that
h(Γ) = 1 + 1
2

1 + h(f(0, x2, . . . , xn))
2
+ 1 + h(f(1, x2, . . . , xn))
2

.
Then
h(Γ) = 2 + h(f(0, x2, . . . , xn)) + h(f(1, x2, . . . , xn))
4
.
(3.8)
Let us build a decision tree G as follows. The root of G is assigned with the
attribute x1. Two edges leave the root labeled with the numbers 0 and 1. For
δ = 0, 1, the edge labeled with the number δ enters the root of an optimal
decision tree for the function f(δ, x2, . . . , xn). The tree G does not contain
any other nodes and edges. One can see that G implements the function f.
According to Lemma 3.1,
h(G) = 1 + h(f(0, x2, . . . , xn)) + h(f(1, x2, . . . , xn))
2
.
(3.9)
Taking into account the inequality h(f) ≤h(G) and substituting (3.9)
into (3.8), we obtain that h(Γ) ≥3/2 + h(f)/2. Comparing the last re-
lation to (3.6), we have h(Γ) > h( ˆΓ) that contradicts the assumption
that Γ is an optimal decision tree. Therefore, only one of the functions
f(0, x2, . . . , xn), f(1, x2, . . . , xn) is non-constant. Suppose for the deﬁnite-
ness that f(1, x2, . . . , xn) ≡const. Then f can be represented in the form f =
x1∨f(0, x2, . . . , xn) or f = ¬x1∧f(0, x2, . . . , xn). The induction base implies
that h(f) = 1 + h(f(0, x2, . . . , xn))/2. The function f(0, x2, . . . , xn) ∧xn+1
is non-constant, and for δ = 0, the relation (3.7) holds. Then the relation
h(f(0, x2, . . . , xn) ∧xn+1) = h(f) holds and implies
h( ˆf) = h(Γ) = 1 + h(f)
2
+ h(f(1, x2, . . . , xn) ∧xn+1)
2
.

54
3
Representing Boolean Functions by Decision Trees
Comparing this relation with (3.6), we have h( ˆf) ≤h( ˆΓ) that contradicts
the assumption that the tree ˆΓ is not optimal. Consequently, the tree ˆΓ is
optimal and h(f) = 1 + h(f)/2. The induction step is proved analogously for
other types of the function ˆf listed in the lemma.
⊓⊔
For arbitrary numbers x, σ ∈E2, denote
xσ =

x ,
if σ = 0 ,
¬x ,
if σ = 1 .
Proof of Proposition 3.1. For an arbitrary natural number n and a number
σ ∈E2, set into correspondence to the function f(x1, . . . , xn) ≡σ a decision
tree Γ0(σ) that consists of a single terminal node labeled with σ. One can see
that the tree Γ0(σ) implements f and h(Γ0(σ)) = 0. Then HB(n) = 0.
⊓⊔
Proof of Proposition 3.2. For an arbitrary natural number n, a natural num-
ber i ≤n, and a number σ ∈E2 set into correspondence to the function
f(x1, . . . , xn) = xσ
i a decision tree Γ1(i, σ). The decision tree Γ1(i, σ) con-
sists of one nonterminal node v labeled with the attribute xi and two termi-
nal nodes w0 and w1 labeled with the numbers 0σ and 1σ respectively. For
δ = 0, 1, there is an edge leaving v and entering wδ, and this edge is labeled
with the number δ. The tree Γ1(i, σ) does not contain other nodes and edges.
One can see that the tree Γ1(i, σ) implements f and h(Γ1(i, σ)) = 1.
On the other hand, a decision tree that implements a non-constant Boolean
function must have at least two terminal nodes and, consequently, at least
one nonterminal node. Therefore, Γ1(i, σ) is an optimal decision tree and
HB(n) = 1.
⊓⊔
Proof of Proposition 3.3. Any function of n arguments from the set S1 ∪S3 ∪
S5 ∪S6 ∪P1 ∪P3 ∪P5 ∪P6 up to argument names can be represented in the
form f0(x1, . . . , xn) = 0, f1(x1, . . . , xn) = 1, f 1
t (x1, . . . , xn) = x1 ∨. . . ∨xt or
f 2
t (x1, . . . , xn) = x1∧. . .∧xt where t ≤n. Let us prove by induction on t that
the relation h(f 1
t ) = h(f 2
t ) = 2 −1/2t−1 holds for t = 1, . . . , n. If t = 1, then
f 1
t ≡f 2
t ≡x1 and h(f 1
t ) = h(f 2
t ) = 1. Let the relation be valid for each i less
than t. From Lemma 3.7 it follows that h(f 1
t ) = 1 + h(f 1
t−1)/2 and h(f 2
t ) =
1 + h(f 2
t−1)/2. According to the inductive hypothesis, h(f 1
t−1) = h(f 2
t−1) =
2−1/2t−2. Then h(f 1
t ) = h(f 2
t ) = 1+(2−1/2t−2)/2 = 2−1/2t−1. One can see
that maxt∈{1,...,n} h(f 1
t ) = maxt∈{1,...,n} h(f 2
t ) = 2 −21−n and the maximum
is reached on the functions f 1
n and f 2
n. Then validity of the proposition follows
from the fact that for n ≥1, each of the classes S1, S3, S5, S6, P1, P3, P5, P6
contains at least one of the functions f 1
n and f 2
n.
⊓⊔

3.1
On Average Depth of Decision Trees Implementing Boolean Functions
55
Proof of Proposition 3.4. Each of the closed classes listed in the proposition
contains at least one of the functions x1 ⊕. . .⊕xn and x1 ⊕. . .⊕xn ⊕1. Using
Lemma 3.6, we obtain that HB(n) ≥n. On the other hand, obviously, any
Boolean function of n arguments can be implemented by a decision tree of
the average depth at most n. Consequently, HB(n) = n.
⊓⊔
Proof of Proposition 3.5. For n = 2k + 1, both classes contain the function
x1 ⊕. . . ⊕xn and validity of the proposition is proved analogously to Propo-
sition 3.4. For n = 2k, none of the classes contain a function with n essential
variables and both classes contain the function x1 ⊕. . . ⊕xn−1. Therefore,
HB(n) = n −1.
⊓⊔
Proof of Proposition 3.6. For n = 2k+1, the class contains the function x1 ⊕
. . . ⊕xn, and validity of the proposition is proved analogously to Proposition
3.4. Let n = 2k, and f be the function such that h(f) = HB(n). Let z =
(f, x1, . . . , xn) be a problem corresponding to the function f. Consider a
sequence of rows ¯δ0, . . . , ¯δn ∈Tz where ¯δ0 = (0, . . . , 0, 0), ¯δ1 = (0, . . . , 0, 1),
¯δ2 = (0, . . . , 1, 1), . . ., ¯δn = (1, . . . , 1, 1). Note that f(¯δ0) = 0 and f(¯δn) = 1
because f ∈C4. Since n = 2k, the relation f(¯δi) = f(¯δi+1) holds for some
i ∈{0, . . ., n −1}. Thus the table Tz has a terminal separable subtable
Tz(x0, 0)(x1, 0) . . . (xi−1, 0)(xi+1, 1) . . . (xn, 1) containing exactly two rows:
¯δi and ¯δi+1. From part (a) of Lemma 3.5 it follows that h(f) ≤n −21−n.
Then HB(n) ≤n −21−n.
Consider the function f(x1, ..., xn) = x1 ∧. . . ∧xn ∨(x1 ⊕. . . ⊕xn). Let z
be the problem corresponding to the function f. One can see that the table
Tz has n terminal separable subtables I1, . . . , In, Ii = Tz(x1, 1) . . . (xi−1,
1)(xi+1, 1) . . . (xn, 1), containing two rows and does not have other terminal
separable subtables containing more than one row. The subtables I1, . . . , In
have the common row (1, . . . , 1). Thus any partition of the table Tz can
contain only one of the subtables I1, . . . , In. From part (b) of Lemma 3.5 it
follows that h(f) = n−21−n. Then HB(n) = n−21−n.
⊓⊔
Proof of Proposition 3.7.
For n = 2k + 1, both classes contain one of the
functions x1 ⊕. . . ⊕xn, x1 ⊕. . . ⊕xn ⊕1 and validity of the proposition
is proved analogously to Proposition 3.4. Let n = 2k. Since D1 ⊆C4 and
D3 ⊆C4, validity of the upper bound follows from Proposition 3.6.
Consider a function f(x1, . . . , xn) deﬁned as follows: on a tuple ¯δ =
(δ1, . . . , δn) it takes the value (δ1 ⊕. . . ⊕δn) if the number of zeros in ¯δ
is greater than the number of ones, the value (δ1 ⊕. . .⊕δn ⊕1) if the number
of zeros in ¯δ is less than the number of ones, and the value δ1 if the number of
zeros is equal to the number of ones. Let us show that any terminal separable
subtable I of the table Tz contains at most one row in which the number

56
3
Representing Boolean Functions by Decision Trees
of zeros diﬀers from the number of ones. Assume the contrary, i.e. the table
I contains at least two such rows. Let the number of zeros in the ﬁrst row
exceed the number of ones. If the second row possesses the same condition,
then the subtable I contains two rows ¯δ1 and ¯δ2 in which the number of ze-
ros is greater than the number of ones and which diﬀer exactly in one digit.
If the number of ones in the second row exceeds the number of zeros, then
the subtable I contains two rows ¯δ1 and ¯δ2 with (n/2 −1) and (n/2 + 1)
ones respectively. According to the deﬁnition of the function, f(¯δ1) ̸= f(¯δ2)
for both cases that contradicts the assumption that I is a terminal subtable.
The case when the ﬁrst row contains more zeros than ones is considered anal-
ogously. Therefore, each terminal separable subtable of the table Tz contains
at most one row in which the number of zeros diﬀers from the number of ones.
It implies that any terminal separable subtable of Tz contains at most two
rows and each two-row subtable contains a row with n/2 zeros and n/2 ones.
Obviously, the table Tz contains Cn/2
n
such rows. Then any partition of the
table Tz contains at most Cn/2
n
subtables with two rows and does not contain
subtables with a greater number of rows. According to part (b) of Lemma
3.5, the relation h(f) ≥n −1/2n−1Cn/2
n
holds. Using the bound (3.3), we
obtain
HB(n) ≥h(f) ≥n −2
√
2
√
3
1
√n ≥n −1.7
√n .
⊓⊔
Proof of Proposition 3.8.
It is not hard to show that each class contains
the function T hrn,⌈n/2⌉. Validity of the lower bound of the lemma imme-
diately follows from Lemma 3.4. Let us prove validity of the upper bound.
Let f(x1, . . . , xn) be a function for which the equality h(f) = HB(n) holds.
Denote z = (f, x1, . . . , xn) the problem corresponding to the function f.
Consider the value of the function f(¯δ) on the tuple ¯δ = (δ1, . . . , δn) where
δ1 = δ2 = . . . = δm = 1, δm+1 = δm+2 = . . . = δn = 0, m = ⌊n/2⌋.
If f(¯δ) = 1, then f takes the value 1 on all tuples in which the ﬁrst m
digits are set to 1. Then the table Tz has a terminal separable subtable
Tz(x1, 1)(x2, 1) . . . (xm, 1), containing 2n−m = 2⌊(n+1)/2⌋rows. From part (a)
of Lemma 3.5 it follows that
h(f) ≤n −⌊(n + 1)/2⌋2−⌊(n+1)/2⌋.
(3.10)
If f(¯δ) = 0, then the function f takes the value 0 on all tuples in which the
last (n −m) digits are set to 0. Thus the table Tz has a terminal separable
subtable Tz(xm+1, 0)(xm+2, 0) . . . (xn, 0) containing 2m = 2⌊n/2⌋rows. From
part (a) of Lemma 3.5 it follows that

3.1
On Average Depth of Decision Trees Implementing Boolean Functions
57
h(f) ≤n −⌊n/2⌋2−⌊n/2⌋.
(3.11)
By taking the weakest bound of (3.10) and (3.11), we obtain HB(n) = h(f) ≤
n −⌊n/2⌋2−⌊n/2⌋.
⊓⊔
Proof of Proposition 3.9. It is easy to show that the class D2 contains the
function T hrn,(n+1)/2 for an arbitrary odd n, and the function T hrn−1,n/2
for an arbitrary even n. Then validity of the lower bound for an arbitrary
n ≥3 follows from Lemma 3.4. Validity of the lower bound for n = 1, 2
can be proved by a direct check. The upper bound follows from the relation
D2 ⊂M1 and Proposition 3.8.
⊓⊔
Proof of Proposition 3.10.
One can see that each function of n argu-
ments from the set F ∞
1
∪F ∞
4
∪F ∞
5
∪F ∞
8
can be represented in the form
f 0
n(x1, . . . , xn) = xi ∨φ0
n−1(x1, . . . , xi−1, xi+1, . . . , xn) or f 1
n(x1, . . . , xn) =
xi ∧φ1
n−1(x1, . . . , xi−1, xi+1, . . . , xn). If φδ
n−1 is a constant function for δ = 0
or δ = 1, then h(f δ
n) ≤1. Let the function φδ
n−1 be non-constant. According
to Lemma 3.7, h(f δ
n) = 1 + h(φδ
n−1)/2. Since the function φδ
n−1 has at most
(n −1) essential variables, h(φδ
n−1) ≤n −1 and h(f δ
n) ≤1 + (n −1)/2. This
relation holds for all functions and, consequently, HB(n) ≤(n + 1)/2.
For σ = 0, 1, consider the functions f 0,σ
n (x1, . . . , xn) = x1 ∨(x2 ⊕. . . ⊕
xn ⊕σ) and f 1,σ
n (x1, . . . , xn) = x1 ∧(x2 ⊕. . . ⊕xn ⊕σ). One can see that
for an arbitrary natural n, each of the classes F ∞
1 , F ∞
4 , F ∞
5 , F ∞
8
contains at
least one of these functions. According to Lemma 3.7, h(f 0,σ
n ) = h(f 1,σ
n ) =
1 +h(x2 ⊕. . . ⊕xn ⊕σ)/2 = (n+1)/2. Then HB(n)=(n+1)/2.
⊓⊔
Proof of Proposition 3.11. One can see that each class contains one of the
functions
f1 = T hrn−1,⌈(n−1)/2⌉(x1, . . . , xn−1) ∧xn ,
f2 = T hrn−1,⌈(n−1)/2⌉(x1, . . . , xn−1) ∨xn
for every n > 1. According to Lemma 3.4, h(T hrn−1,⌈(n−1)/2⌉) ≥n −√n.
According to Lemma 3.7, h(f1) = h(f2) ≥1 + (n −√n)/2. Validity of the
lower bound for n = 1 can be proved by a direct check. Validity of the
upper bound follows from the relations F ∞
2
⊆F ∞
1 , F ∞
3
⊆F ∞
4 , F ∞
6
⊆F ∞
5
F ∞
7
⊆F ∞
8
and Proposition 3.10.
⊓⊔
Proof of Proposition 3.12.
Validity of the lower bound follows from the
relations F μ
1 ⊇F ∞
1 , F μ
4 ⊇F ∞
4 , F μ
5 ⊇F ∞
5 , F μ
8 ⊇F ∞
8 , μ ≥2 and Proposition
3.10.

58
3
Representing Boolean Functions by Decision Trees
Let B = F 2
4 , f(x1, . . . , xn) be a function such that h(f) = HB(n). Let
z = (f, x1, . . . , xn) be the problem corresponding to f. Since F 2
4 ⊆C2, the
relation f(1, . . . , 1) = 1 holds. The lower bound implies that f diﬀers from
the constant 1. Then there exists a number k, 1 ≤k ≤n such that f takes
the value 1 on all tuples containing less than k zeros, and there exists a tuple
containing exactly k zeros on which the function takes the value 0. Then
the table Tz has a terminal separable subtable Tz(x1, 1)(x2, 1) . . . (xn−k+1, 1)
that contains 2k−1 rows. According to part (a) of Lemma 3.5, the inequality
h(f) ≤n −k −1
2k−1
(3.12)
holds. Without loss of generality, assume that the function takes the value 0
on the tuple ¯δ = (δ1, . . . , δn) in which δ1 = δ2 = . . . = δk = 0 and δk+1 =
δk+2 = . . . = δn = 1. Then in each tuple ¯δ = (δ1, . . . , δn) such that f(¯δ) = 0,
at least one of the ﬁrst k digits δ1, . . . , δk is set to zero. Therefore, the table Tz
has a terminal separable subtable Tz(x1, 1)(x2, 1) . . . (xk, 1) containing 2n−k
rows. According to part (a) of Lemma 3.5, the inequality
h(f) ≤n −n −k
2n−k
(3.13)
holds.
The weakest of the bounds (3.12) and (3.13) reaches the maximum on
k = ⌊(n+1)/2⌋. Consequently, HB(n) ≤n−⌊n/2⌋2−⌊n/2⌋. The upper bound
for B = F 2
8 is proved analogously. The upper bound for the remaining classes
follows from the relations F μ
1 ⊆F 2
4 , F μ
4 ⊆F 2
4 , F μ
5 ⊆F 2
8 , F μ
8 ⊆F 2
8 that are
valid for any natural μ ≥2.
⊓⊔
Proof of Proposition 3.13.
Validity of the lower bound follows from the
relations F μ
2 ⊇F ∞
2 , F μ
3 ⊇F ∞
3 , F μ
6 ⊇F ∞
6 , F μ
7 ⊇F ∞
7 , μ ≥2 and Proposition
3.11.
Validity of the upper bound follows from the relations F μ
2 ⊆F μ
1 , F μ
3 ⊆F μ
4 ,
F μ
6 ⊆F μ
5 F μ
7 ⊆F μ
8 , μ ≥2 and Proposition 3.12.
⊓⊔
3.2
On Branching Programs with Minimum Average
Depth
This section considers a possibility of joint optimization of time and space
complexity. For this purpose, a decision tree is represented in a compact form
named branching program. According to Theorem 3.4, the requirement to a
branching program to have the minimum average weighted depth is rather
strong, since all branching programs with the minimum average weighted

3.2
On Branching Programs with Minimum Average Depth
59
depth are read-once. This fact reveals a contradiction between time and space
complexity requirements, because many problems have high lower bounds on
the number of nodes in a read-once branching program. The section con-
cludes with description of several problems, for which the number of nodes
in a branching program with the minimum average weighted depth grows
exponentially with the number of attributes.
Let U = (A, F) be a 2-valued information system, and Ψ a weight function
for U. A branching program for the problem z = (ν, f1, . . . , fn) over U is a
ﬁnite oriented acyclic graph in which:
a) at least one edge enters each node except one called the root of the branch-
ing program;
b) each terminal node (a node that does not have outgoing edges) is labeled
with a number from ω.
c) two edges leave each nonterminal node, labeled with the numbers 0 and
1 respectively;
d) each nonterminal node is assigned with an attribute from the set {f1, . . . ,
fn}.
A path from the root to a terminal node is called complete. A branching
program is called read-once if in each complete path, all nonterminal nodes
are assigned with pairwise diﬀerent attributes.
Let G be a branching program for the problem z. For an arbitrary com-
plete path ξ in G, let us deﬁne the subtable Tzπ(ξ) of the table Tz and the
path weight Ψ(ξ) in the same way as it is deﬁned for decision trees. For
an arbitrary row ¯d ∈Tz, denote by ξ ¯d the complete path in G such that
¯d ∈Tzπ(ξ ¯d). We will say that a branching program G solves the problem z
if for each row ¯d ∈Tz, the terminal node of the path ξ ¯d is labeled with the
number ν( ¯d). Let P be a probability distribution for the problem z. The value
hΨ(G, P, z) = 
¯d∈Tz Ψ(ξ ¯d)P( ¯d)/N(Tz, P) is called P-average weighted depth
of the branching program G. A branching program G for the problem z that
solves z and has the minimum P-average weighted depth is called optimal
for Ψ, z and P.
Theorem 3.4. Let U be a 2-valued information system, Ψ a weight function
for U, z a problem over U, and P a probability distribution for z. Let G be a
branching program for z that solves z and is optimal for Ψ, z and P. Then
G is a read-once branching program.
Proof. For an arbitrary node v, we will call v-subprogram of the branching
program G the set of nodes and edges from G to which an oriented path from
v exists. Let v be a node such that for each node w of v-subprogram, each
path from the root of G to w contains v. Let v have k > 1 incoming edges

60
3
Representing Boolean Functions by Decision Trees
r1, . . . , rk. For i = 2, . . . , k, let us add to the program G a subprogram Gi
that coincide to v-subprogram and transform G so that the edge ri enters the
root of the subprogram Gi. Let us repeat this transformation until at most
one edge enters each node in G. Denote the resulted graph Γ. One can see
that Γ is a decision tree for the problem z that solves z and is optimal for
Ψ, z and P.
Assume G is not a read-once branching program. Then there is a complete
path ξ in Γ containing two nonterminal nodes v1 and v2 which are assigned
with the same attribute f. Let v1 precede v2 in the path ξ. Denote e the edge
that leaves v1 and is contained in the path ξ, and σ the number assigned to
e. Denote ξ2 the path from the root of Γ to the node v2. One can see that
either Tzπ(ξ2) = ∅or Tzπ(ξ2)(f, δ) = Tzπ(ξ2) for some δ ̸= σ. Then the node
v2 is not essential and the tree Γ is not reduced. According to Lemma 2.3,
the tree Γ is not optimal for Ψ, z and P. Then the branching program G is
not optimal for Ψ, z and P which contradicts the premise of the theorem and
thus concludes the proof.
⊓⊔
Let us conclude with some examples of problems for which the minimum num-
ber of nodes in the branching program with the minimum average weighted
depth grows exponentially with the number of attributes. For an arbitrary
Boolean function f(x1, . . . , xn), we will say that a branching program imple-
ments f if it solves the problem z = (f, x1, . . . , xn).
In [66], it is shown that a read-once branching program implementing the
function Mult : {0, 1}2n →{0, 1} (the middle bit in the product of two
n-bit integers) contains at least 2Ω(√n) nodes. In [83, 84, 85], a function
n/2 −Clique −Only : {0, 1}n2 →{0, 1} is considered that takes as input an
incidence matrix for a graph with n nodes. The function takes the value 1 if
and only if the graph contains a n/2-clique and does not contain other edges.
It is shown that a read-once branching program implementing the function
n/2−Clique−Only contains at least 2Ω(n) nodes. Note that there is a branch-
ing program implementing n/2−Clique−Only such that it has O(n3) nodes,
and any attribute appears at most twice in each complete path. In [59], it
is shown that a read-once branching program implementing the characteris-
tic function of Bose-Chaudhuri codes contains at least exp(Ω(√n/2)) nodes.
Theorem 3.4 shows that the branching programs that are optimal relative to
the average weighted depth have the same or greater number of nodes than
the read-once branching programs with the minimum number of nodes.

Chapter 4
Algorithms for Decision Tree
Construction
The study of algorithms for decision tree construction was initiated in 1960s.
The ﬁrst algorithms are based on the separation heuristic [13, 31] that at
each step tries dividing the set of objects as evenly as possible. Later Garey
and Graham [28] showed that such algorithm may construct decision trees
whose average depth is arbitrarily far from the minimum. Hyaﬁl and Rivest in
[35] proved NP-hardness of DT problem that is constructing a tree with the
minimum average depth for a diagnostic problem over 2-valued information
system and uniform probability distribution. Cox et al. in [22] showed that
for a two-class problem over information system, even ﬁnding the root node
attribute for an optimal tree is an NP-hard problem.
Several exact algorithms of decision tree construction are known but, as
could be expected, none of them have polynomial time complexity in gen-
eral case. The algorithms based on dynamic programming [27, 60, 76] build
decision tree bottom-up by synthesizing a tree for a table from trees for its
separable subtables. The algorithms based on branch-and-bound technique
perform depth-ﬁrst search in the space of possible tree preﬁxes [9, 73]. The
second method is more complex from the computational point of view, but it
can serve as a base for approximation algorithms that use heuristics to guide
search. A combination of the two approaches is described in [42]. There are
also algorithms that use logic methods to analyze the function being imple-
mented like ﬁnding function implicants [11] or T-terms [82]. A comprehensive
survey of the algorithms can be found in [44].
Most of approximate algorithms for decision tree construction are greedy.
These algorithms construct trees in a top-down fashion by minimizing some
data impurity function at each step. Activity of a variable [43], entropy
[70, 78] and Gini index [8] are widely used as data impurity functions. For
some problems, a detailed analysis of existence of algorithms with a guar-
anteed approximation ratio has been performed. Adler and Heeringa [32]
I. Chikalov: Average Time Complexity of Decision Trees, ISRL 21, pp. 61–78.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

62
4
Algorithms for Decision Tree Construction
proved absence of polynomial-time approximation scheme for DT problem
unless P = NP and described an algorithm that has (ln n + 1) approxima-
tion ratio. Chakaravarthy et al. [12] generalized the results to k-DT that is
construction of a decision tree with the minimum average depth for a diag-
nostic problem over k-valued information system and an arbitrary probability
distribution. They proved NP-hardness of Ω(log n) approximation and de-
scribed an algorithm that has O(log k log n) approximation ratio. A similar
problem, building a tree with the minimum average depth for a binary classi-
ﬁcation problem over a 2-valued information system and uniform probability
distribution, is surprisingly harder. In [32], an approximation-preserving re-
duction of the problem to ConDT is done that is building the minimum size
tree for a binary classiﬁcation problem over 2-valued information system. For
the latter problem, Alekhnovich et al. [3] proved absence of polynomial time
c ln n-approximation for any constant c unless NP ⊆DT IME[2mϵ] for some
ϵ < 1.
The chapter is devoted to theoretical and experimental study of several
exact and approximate algorithms for decision tree construction. It consists
of four sections. The ﬁrst section describes an algorithm A based on dynamic
programming. The idea is close to [42], but it was devised by the author
independently in collaboration with Dr. Moshkov. The algorithm takes as
input a decision table and ﬁnds the set of all so-called irredundant decision
trees that have the minimum average weighted depth. The second section ex-
perimentally estimates the approximation ratio of several greedy algorithms
on data sets from UCI Machine Learning Repository [25]. The third section
describes using A for calculating exact values of the Shannon type function
H(n) for the class of monotone Boolean functions for small n. The fourth
section contains experimental results of applying A for building an optimal
tree for corner point detection [74], a technique used in computer vision to
track objects.
Some results of this chapter have been published in [20, 21, 55].
4.1
Algorithm A for Decision Tree Construction
In this section, an algorithm is considered that builds an optimal decision
tree with the minimum average weighted depth for a problem represented in
the form of decision table. The idea of the algorithm is based on dynamic
programming [27, 42, 60, 76].

4.1
Algorithm A for Decision Tree Construction
63
4.1.1
Representation of Set of Irredundant Decision
Trees
Let U = (A, F) be an information system, and z = (ν, f1, . . . , fn) a problem
over U. Let T be a separable subtable of Tz. For i ∈{1, . . . , n}, denote E(T, i)
the set of numbers contained in the i-th column of the table T , and denote
E(T ) = {i : i ∈{1, . . ., n}, |E(T, i)| ≥2}.
Among decision trees for the problem z that solve z we distinguish irre-
dundant decision trees. Consider an arbitrary node w of the tree Γ and its
corresponding separable subtable T = Tzπ(path(Γ, w)). Let T be a terminal
subtable, and ν(x) ≡r on the set of rows of the table T for some r ∈ω. Then
w is a terminal node labeled with r. Let T be a nonterminal subtable. Then
w is labeled with an attribute fi where i ∈E(T ). Finally, each node w such
that Tzπ(path(Γ, w)) = ∅is labeled with the number 0.
The following proposition shows that among irredundant decision trees,
at least one has the minimum average weighted depth.
Proposition 4.1. Let U be an information system, Ψ a weight function for
U, z a problem over U, and P a probability distribution for z. Then there
exists an irredundant decision tree that is optimal for Ψ, z and P.
Proof. Let Γ be a decision tree for the problem z that solves z, and Γ be
optimal for Ψ, z and P. Let us consider an algorithm that transforms Γ into
an irredundant decision tree. The algorithm sequentially processes all nodes
of the tree Γ. Let w be the current node. Denote T = Tzπ(path(w)). The
algorithm tries to apply the following rules to each node.
• If T = ∅, then replace the subtree whose root is w with a single node
labeled with 0;
• If T is a terminal subtable and ν(x) ≡r on the set of rows of the table
T , then replace the subtree whose root is w with a single node labeled
with r;
• Let T be a nonterminal subtable and w be labeled with an attribute fi,
i /∈E(T ). Then E(T, i) = {δ} for some δ ∈Ek. Denote by Γδ the decision
tree whose root the edge leaving w and labeled with δ enters. Then replace
the subtree whose root is w with Γδ.
Since each node is considered at most once, the algorithm ends in a ﬁnite
number of steps. Denote the resulted decision tree by ˆΓ. One can see that ˆΓ is

64
4
Algorithms for Decision Tree Construction
an irredundant decision tree for T . Obviously, the applied transformation does
not increase the complexity and thus ˆΓ remains optimal.
⊓⊔
Let T be a separable subtable of Tz. Let us deﬁne a problem zT corre-
sponding to the table T . Let Tz = { ¯d1, . . . , ¯ds} and Q1, . . . , Qs ∈A be
equivalence classes such that (f1(qi), . . . , fn(qi)) = ¯di for any qi ∈Qi. Let
T = { ¯di1, . . . , ¯dit}. Then zT is the problem with the same description as z
over the information system (Qi1 ∪. . . ∪Qit, F). Note that zTz is the initial
problem.
Denote by T ree∗(T ) the set of irredundant decision trees for the problem
zT . Assume technically that for T = ∅, the set T ree∗(T ) contains a single
tree that is a node labeled with the number 0. Consider an algorithm B
for construction of the graph Δ(z), which represents in some sense the set
T ree∗(Tz). Nodes of this graph are some separable subtables of the table Tz.
During each step, the algorithm processes exactly one node and marks this
node with the symbol *. The algorithm starts with the graph which consists
of one node Tz, and ﬁnishes when all nodes of the graph are processed.
Let the algorithm have performed p steps. Describe the step (p+1). If in the
considered graph all nodes have already been processed, then the algorithm
ﬁnishes, and the considered graph is Δ(z). Let the graph have an unprocessed
node (table) T . If T is a terminal subtable and ν(x) ≡r on the set of rows of
the table T , then label the considered node with the number r, mark it with
the symbol * and pass to the step (p + 2).
Let T be a nonterminal subtable. For each i ∈E(T ), draw from the node
T a bundle of edges. Let E(T, i) = {δ1, . . . , δt}. Then draw t edges from T ,
and label these edges with the pairs (fi, δ1), . . . , (fi, δt) respectively. These
edges enter the nodes T (fi, δ1), . . . , T(fi, δt). If some of these nodes are not
in the graph, then add these nodes to the graph. The algorithm marks the
node T with the symbol * and proceeds to the step (p + 2).
r
Fig. 4.1 Trivial
decision tree
Γ1
Γt
fi
0
0
δ1
δt γ1
γk−t
. . .
. . .
Fig. 4.2 Aggregated decision tree

4.1
Algorithm A for Decision Tree Construction
65
Now for each node of the graph Δ(z), we describe the set of decision trees
corresponding to it. It is clear that Δ(z) is a directed acyclic graph. A graph
node is called terminal if it does not have outgoing edges. We will “move”
from terminal nodes which are labeled with numbers to the node Tz. Let T
be a node which is labeled with the number r. Then the only trivial decision
tree depicted on Fig. 4.1 corresponds to the considered node. Let T be a
node (table), such that ν(x) ̸≡const on the set of rows of T . Let i ∈E(T ),
E(T, i) = {δ1, . . . , δt}, and Ek \ E(T, i) = {γ1, . . . , γk−t}. Let Γ1, . . . , Γt be
decision trees from the sets corresponding to the nodes T (fi, δ1), . . . , T(fi, δt).
Then the decision tree depicted on Fig. 4.2 belongs to the set of decision
trees, which corresponds to the node T . All such decision trees belong to the
considered set. This set does not contain any other decision trees.
For any node T , denote by T ree(T ) the set of decision trees corresponding
to T described by the graph Δ(z). The following proposition shows that Δ(z)
represents all irredundant decision trees for the problem z.
Proposition 4.2. Let U be an information system, and z a problem over U.
Let T be a node in the graph Δ(z). Then T ree(T ) = T ree∗(T ).
Proof. Prove the proposition by induction on the nodes of the graph Δ(z). For
each terminal node T , there is only one irredundant decision tree depicted on
Fig. 4.1 and the set T ree(T ) contains only this tree. Let T be a nonterminal
node and the proposition hold for all its descendants. Consider an arbitrary
decision tree Γ ∈T ree(T ). Obviously, Γ contains more than one node. Let
the root of Γ be labeled with an attribute fi. For each δ ∈Ek, denote by Γδ
the decision tree connected to the root of Γ with the edge labeled with the
number δ. From the deﬁnition of the set T ree(T ) it follows that i is contained
in the set E(T ); for each δ ∈E(T, i), the decision tree Γδ belongs to the set
T ree(T (fi, δ)); and for each δ /∈E(T, i), the decision tree Γδ is a single node
labeled with the number 0. According to the induction base, the tree Γδ is
an irredundant decision tree for the problem zT (fi,δ). Then the tree Γ is an
irredundant decision tree for the table zT , so T ree(T ) ⊆T ree∗(T ).
Now consider an arbitrary irredundant decision tree ˆΓ for the problem
zT . According to the deﬁnition of irredundant tree, the root of ˆΓ is labeled
with an attribute fi, i ∈E(T ), and the subtrees whose roots are nodes in the
second ﬂoor are irredundant decision trees for the corresponding descendants
of the node T . Then according to the deﬁnition of the set T ree(T ), the tree
ˆΓ belongs to T ree(T ), and T ree(T ) = T ree∗(T ).
⊓⊔
The following proposition gives upper and lower bounds on the time com-
plexity of the algorithm B (further we assume that k is ﬁxed and do not study
dependence of the algorithm time complexity on k).

66
4
Algorithms for Decision Tree Construction
Proposition 4.3. For an arbitrary problem z = (ν, f1, . . . , fn) represented
in the form of decision table T ∗
z , the working time of the algorithm B is
proportional to the number of rows D(Tz) if Tz is a terminal table. If Tz is a
nonterminal table, the working time of the algorithm B is bounded from below
by the maximum of the values n, |S(z)|, D(Tz) and is bounded from above by
a polynomial on these values.
Proof. At start, the algorithm B reads D(Tz) values of ν(x) function to check
if Tz is a terminal table. If the table Tz is terminal, the algorithm builds
the graph Δ(z) that consist of a single node and ﬁnishes, so the statement
obviously hold.
Let T ∗
z be a nonterminal table. From the deﬁnition of a problem over
information system it follows that |E(Tz)| = n, so the algorithm builds n
bundles of edges leaving the root. One can see that the algorithm B performs
at least |S(z)| steps, so the lower bound holds.
The number of steps of the algorithm B is limited from above by the
number of nonterminal subtables and their immediate descendants in the
graph Δ(z) that is at most |S(z)|nk. For a table T , construction of the sets
E(T ) and E(T, i) takes a linear time on the length of the table representation,
i.e. nD(T ). It is easy to implement a procedure which given a subtable T
checks if the corresponding node presents in the graph, and has a polynomial
time complexity on |S(z)| and D(T ). While processing a nonterminal table
T , the algorithm needs to build a set of subtables of the form T (fi, σ) that
can be done in a polynomial time on n and D(T ).
Then the total working time of the algorithm is bounded from above by a
polynomial on |S(z)|, n and D(T ).
⊓⊔
4.1.2
Procedure of Optimization
Let us describe a procedure which transforms the graph Δ(z) into its proper
subgraph ΔΨ,P (z). It begins from the terminal nodes and moves to the node
Tz. The procedure assigns a number to each node and possibly removes some
bundles of edges which start in the considered node. First, the number 0 is
assigned to each terminal node. Consider a node T which is not terminal and
a bundle of edges which starts in this node. Let the edges be labeled with
pairs (fi, δ1), . . . , (fi, δt), and they enter the nodes T (fi, δ1), . . . , T(fi, δt) to
which numbers p1, . . . , pt have been already assigned. Then assign the number
Ψ(fi)N(T, P) + t
j=1 pj to the considered bundle.
Let p be the minimum of the numbers assigned to the bundles starting in
T . The procedure assigns p to the node T and removes the bundles starting
in T which are assigned with numbers greater than p. After all nodes are
processed, the procedure removes from the graph all nodes such that there

4.1
Algorithm A for Decision Tree Construction
67
is no directed path from the node Tz to the considered node. Denote the
resulted graph by ΔΨ,P (z).
As each nonterminal node keeps at least one bundle of the outgoing edges,
all terminal nodes of ΔΨ,P (z) are terminal nodes of the graph Δ(z). As it
was described earlier, we can set to correspondence a set of decision trees
T reeΨ,P(T ) to each node T of ΔΨ,P (z). One can see that all these deci-
sion trees belong to the set T ree(T ). Denote by T ree⋆
Ψ,P(T ) the subset of
T ree(T ) containing all decision trees that are optimal relative to the av-
erage weighted depth, i.e. T ree⋆
Ψ,P(T ) = { ˆΓ ∈T ree(T ) : hΨ( ˆΓ, zT , P) =
minΓ∈T ree(T ) hΨ(Γ, zT , P)}. The following theorem shows that the optimiza-
tion procedure removes all and only non-optimal decision trees.
Theorem 4.1. Let U be an information system, Ψ a weight function, z a
problem over U, and P a probability distribution for z. Let T be an arbitrary
node in the graph Δ(z). Then T reeΨ,P(T ) = T ree⋆
Ψ,P(T ).
We preface proof of the theorem by the following lemma.
Lemma 4.1. Let U be an information system, Ψ a weight function, z a prob-
lem over U, and P a probability distribution for z. Let T be an arbitrary node
in the graph Δ(z), and p the number assigned to T by the optimization pro-
cedure. Then for each decision tree Γ from the set T reeΨ,P(T ), the equality
p = N(T, P)hΨ(Γ, zT , P) holds.
Proof. Prove the lemma by induction on the nodes of Δ(z). For each terminal
node T , only one irredundant decision tree Γ exists depicted on Fig. 4.1 and
the statement of the lemma obviously holds for T . Let now T be a nonterminal
node and the statement of lemma holds for all descendants of T . Consider
an arbitrary decision tree Γ ∈T reeΨ,P(T ). Let the root of Γ be labeled with
an attribute fi. Let E(T, i) = {a1, . . . , at}. For j = 1, . . . , t, denote by Γj the
decision tree connected to the root of Γ with the edge labeled with aj. Let for
j = 1, . . . , t, the node T (fi, aj) be labeled with a number pj. For j = 1, . . . , t,
denote zj = zT (fi,aj).
The induction base implies that the equality pj = N(T (fi, aj), P)hΨ(Γj,
zj, P) holds for j = 1, . . . , t. According to the deﬁnition of the optimization
procedure, p = Ψ(fi)N(T, P) + t
j=1 pj. Since Γ is an irredundant decision
tree, for any δ /∈E(T, i), the edge that leaves the root of Γ and is labeled
with δ, enters a terminal node.
From the deﬁnition of the average weighted depth we have
hΨ(Γ, zT , P) = Ψ(fi) +
1
N(T, P)
t

j=1
N(T (fi, aj))hΨ(Γt, zj, P) .
(4.1)

68
4
Algorithms for Decision Tree Construction
From the last three equalities we have p = N(T, P)hΨ(Γ, zT , P). Since Γ is
an arbitrary tree from T reeΨ,P(T ), all the trees in T reeΨ,P(T ) have the same
complexity equal to p.
⊓⊔
Proof of Theorem 4.1.
The theorem will be proved by induction on the
nodes of the graph Δ(z). Let T be a terminal node. Then the set T ree(T )
contains only the tree depicted on Fig. 4.1 and this tree is not removed by
the optimization procedure. Then the statement of the theorem holds for the
node T .
Let now T be a nonterminal node in Δ(z), and the statement of the the-
orem hold for any descendant of T in the graph Δ(z). Let the optimization
procedure assigned a number p to the node T . Lemma 4.1 implies that all
decision trees in T reeΨ,P(T ) have the same complexity p. Consider an arbi-
trary decision tree Γ from the set T ree⋆
Ψ,P(T ). From the deﬁnition of the set
T ree⋆
Ψ,P(T ) we have
N(T, P)hΨ(Γ, zT , P) ≤p .
(4.2)
Let us show that N(T, P)hΨ(Γ, zT , P) = p. Let the root of Γ be assigned
with an attribute fi. Since Γ is an irredundant decision tree, i ∈E(T ).
Let E(T, i) = {a1, . . . , at}. For j = 1, . . . , t, denote by Γj the subtree
that is connected to the root with the edge labeled with aj. One can see
that Γj is contained in the set T ree(T (fi, aj)). Let pj be the number as-
signed to the node T (fi, aj) during optimization. For j = 1, . . . , t, denote
zj = zT (fi,aj). Since the theorem holds for the node T (fi, aj), we have
N(T (fi, aj), P)hΨ(Γj, zj, P) ≥pj. From the description of the optimization
process it follows that Ψ(fi)N(T, P)+t
j=1 pj ≥p. Since Γ is an irredundant
decision tree, for any δ /∈E(T, i), the edge that leaves the root of Γ and is
labeled with δ, enters a terminal node.
From the two last equalities and (4.1) we have N(T, P)hΨ(Γ, zT , P) ≥p,
and, recalling (4.2), N(T, P)hΨ(Γ, zT , P) = p. Then
T reeΨ,P(T ) ⊆T ree⋆
Ψ,P(T ) .
(4.3)
Due to (4.1), optimality of the tree Γ implies optimality of each tree Γj,
so Γj ∈T ree⋆
Ψ,P(T (fi, aj)) for j = 1, . . . , t. Then, according to the induction
base, Γj belongs to the set T reeΨ,P(T (fi, aj)) for j = 1, . . . , t. Consider the
bundle of edges in the graph Δ(z) that leave the node T and are labeled with
the pairs (fi, a1), . . . , (fi, at). Since N(T, P)hΨ(Γ, zT , P) = p, these edges
were not removed by the optimization procedure. Then, according to the
deﬁnition of the set T reeΨ,P(T ), the tree Γ belongs to this set. As Γ was
chosen arbitrarily, we have T ree⋆
Ψ,P(T ) ⊆T reeΨ,P(T ), and due to (4.3),
T ree⋆
Ψ,P(T ) = T reeΨ,P(T ).
⊓⊔

4.2
Greedy Algorithms
69
Consider an algorithm A that given a table T ∗
z ﬁrst builds a graph Δ(z),
then transforms it resulting graph ΔΨ,P (z) and ﬁnally extracts one of trees
described by the graph ΔΨ,P (z). For an arbitrary polynomial Q, a probability
distribution P is called Q-restricted if for an arbitrary row ¯d ∈Tz, the length
of the binary notation of the number P( ¯d) does not exceed Q(n) where n is
the number of columns in the table. The following theorem characterizes the
time complexity of the algorithm A.
Theorem 4.2. Let Q(x) be some polynomial. Then for an arbitrary problem
z = (ν, f1, . . . , fn) and an arbitrary Q-restricted probability distribution P
for the problem z, the working time of the algorithm A is proportional to
the number of rows D(Tz) if the table T ∗
z is terminal. If the table T ∗
z is
nonterminal, the working time of the algorithm A is bounded from below by
the maximum of the values n, the number of nonterminal separable subtables
|S(z)|, D(Tz) and the maximum length of attribute weight in binary notation,
and is bounded from above by a polynomial on these values.
Proof. If the table T ∗
z is terminal, the working time of the algorithm B is
proportional to D(Tz) according to Proposition 4.3. Since the graph Δ(z)
contains a single node, the remaining steps of the algorithm A are completed
in a constant time, so the statement of the theorem holds.
Let T ∗
z be a nonterminal table. While calculating the number to assign to
the node Tz in the graph Δ(z), the optimization procedure necessarily reads
the weights of all attributes. This fact and Proposition 4.3 prove the lower
bound on the working time of the algorithm A.
Let us prove the upper bound. From Proposition 4.3 it follows that the
working time of the algorithm B is limited from above by a polynomial on
D(Tz), n and |S(z)|. The optimization procedure performs exactly (|S(z)|+1)
steps. The time of computing pi is limited from above by a polynomial on
the maximum length of the attribute weight notation (denote it by l), Q(n)
and D(T ). The time of computing p given pi is proportional to the number of
bundles that is at most n. Given the graph ΔΨ,P (z), an optimal tree can be
obtained by the time proportional to the number of nodes in the graph, which
is limited from above by a polynomial on n and |S(z)|. Then the theorem
statement is a consequence of the facts that both the number of steps and
the complexity of each step are bounded from above by a polynomial on n,
|S(z)|, D(Tz) and l.
⊓⊔
4.2
Greedy Algorithms
A greedy algorithm builds a decision tree in a top-down fashion, minimiz-
ing some impurity criteria at each step. There are several impurity criteria

70
4
Algorithms for Decision Tree Construction
based on information-theoretical [71, 78], statistical [8] and combinatorial
[43] approaches. In this section, several impurity criteria are deﬁned followed
by a general description of greedy algorithm and experimental results that
compare the average depth of decision trees built by diﬀerent algorithms.
Let U = (A, F) be an information system, Ψ a weight function for U,
z = (ν, f1, . . . , fn) a problem over an U, and P a probability distribution for
z.
Let T be a separable subtable of Tz. Let the function ν(x) take l dif-
ferent values ν1, . . . , νl on the rows of T . For i = 1, ..., l, denote Ni =

¯d∈T,ν( ¯d)=νi P( ¯d). We consider four uncertainty measures:
• entropy: ent(T ) = −l
i=1 (Ni/N(T, P) log2(Ni/N(T, P))) (we assume
0 log2 0 = 0);
• Gini index: gini(T ) = 1 −l
i=1 (Ni/N(T, P))2 ;
• misclassiﬁcation error: me(T ) = 1 −maxi=1,...,lNi/N(T, P);
• weighted number of unordered pairs of rows labeled with diﬀerent deci-
sions: rt(T ) =

N(T, P)2 −l
i=1 N 2
i

/2 (note that rt(T ) = N(T, P)2
× gini(T )/2);
Let i ∈E(T ) and E(T, i) = {a1, . . . , at}. The attribute fi divides the ta-
ble T into the subtables T1 = T (fi, a1), . . . , Tt = T (fi, at). We now de-
ﬁne an impurity function I which assigns impurity I(T, fi) to this parti-
tion. Let us ﬁx an uncertainty measure U from the set {ent, gini, me, rt}
and the type of impurity function: sum or weighted-sum. Then for the type
sum, I(T, fi) = t
j=1 U(Tj), and for the type weighted-sum, I(T, fi) =
t
j=1 U(Tj)N(Tj)/N(T ). As a result, we have eight diﬀerent impurity func-
tions.
Consider an algorithm G that given representation of a problem z and a
probability distribution P in the form of decision table T ∗
z builds a decision
tree G(z, P).
Step 1. Assume T = Tz. Build a decision tree that contains a single node v.
Let T be a terminal table. Then assign the number ν(¯δ) to the node v where
¯δ is an arbitrary row from T . Denote G(z, P) the resulted decision tree. The
process G is completed.
Let T be a nonterminal table. Assign the word λ to the node v and proceed
to the next step.
Let t ≥1 steps have been already done. Denote Γ the tree built at the
step t.
Step (t+1). If none of the nodes in Γ is assigned with a word from Ω∗
z, then
denote G(z, P) the tree Γ. The process Γ is completed. Otherwise, choose in
Γ a node w which is assigned with a word α from Ω∗
z.

4.2
Greedy Algorithms
71
Let T α be a terminal subtable. If T α = ∅, then instead of α assign to
w the number 0. If T α ̸= ∅, then instead of α assign to w the number ν(¯δ)
where ¯δ is an arbitrary row from T α. Proceed to the step (t + 2).
Let T α be a nonterminal subtable. Then for each fi ∈E(T α), compute
the value I(T α, fi) and assign to the node w the attribute fi0 where i0 is the
minimum i ∈{1, . . ., n} for which I(T, fi) has the minimum value. For each
δ ∈E(T α, fi0), add to the tree Γ the node w(δ), mark this node with the
word α(fi0, δ), draw the edge from w to w(δ), and mark this edge with δ.
Proceed to the step (t + 2).
Diﬀerent impurity functions result in diﬀerent greedy algorithms. The fol-
lowing experiment compares the average depth of decision trees built by these
algorithms with the minimum average depth calculated by the algorithm A.
Table 4.1 Average depth of decision trees built by diﬀerent algorithms
Data
Min. avg.
sum
weighted sum
set
depth
ent
gini
rt
me
ent
gini
rt
me
adult-stretch
1.50
1.50 1.50 3.50 1.50 1.50 1.50 3.50 1.50
agaricus-lepiota
1.52
2.35 2.35 1.54 1.52 1.52 1.52 1.52 1.98
balance-scale
3.55
3.55 3.55 3.61 3.55 3.55 3.55 3.61 3.55
breast-cancer
3.24
6.36 6.36 4.06 3.30 3.49 3.70 3.30 3.35
cars
2.95
3.06 3.06 3.72 3.76 2.95 2.96 4.00 4.39
ﬂags
2.72
9.31 9.73 3.21 2.81 3.16 3.16 2.82 2.80
hayes-roth-data
2.62
2.64 2.64 2.64 2.62 2.64 2.64 2.62 2.62
house-votes-84
3.54
5.88 6.99 5.29 3.77 3.68 3.80 3.77 3.63
lenses
1.80
1.80 1.80 3.00 3.00 3.00 1.80 3.00 3.00
lymphography
2.67
7.09 7.09 3.37 2.83 3.12 3.12 2.79 2.78
monks-1-test
2.50
4.50 4.50 2.50 2.50 2.50 2.50 2.50 2.50
monks-1-train
2.53
4.34 4.34 2.53 2.77 3.19 3.22 2.53 2.53
monks-2-test
5.30
5.33 5.33 5.37 5.54 5.40 5.40 5.54 5.54
monks-2-train
4.11
4.70 4.70 4.54 4.20 4.34 4.34 4.26 4.28
monks-3-test
1.83
4.11 2.78 2.78 1.83 1.83 2.08 1.83 1.83
monks-3-train
2.51
3.76 3.03 2.71 2.53 2.54 2.54 2.53 2.53
nursery
3.45
4.05 4.21 3.76 3.76 3.48 3.46 3.85 4.18
poker-hand-train
4.09
6.54 6.54 4.66 4.12 4.12 4.12 4.12 4.13
shuttle-landing
2.33
3.93 3.93 2.93 2.33 2.40 2.40 2.33 2.33
soybean-small
1.34
1.34 1.34 1.34 1.34 1.34 1.34 1.34 1.89
spect-test
2.95
5.93 5.55 4.93 3.48 3.04 3.34 3.47 3.44
teeth
2.78
4.39 4.52 2.78 2.83 2.83 2.78 2.83 2.83
tic-tac-toe
4.35
4.88 4.68 4.82 4.94 4.60 4.58 5.03 5.11
zoo-data
2.29
3.86 3.86 2.44 2.37 2.37 2.37 2.37 2.41
ARD
0.564 0.539 0.222 0.070 0.066 0.052 0.126 0.121

72
4
Algorithms for Decision Tree Construction
The data sets were taken from UCI Machine Learning Repository [25].
Each data set is represented as a table containing several input columns and
an output (decision) column. Some data sets contain index columns that
take unique value for each row. Such columns were removed. Some tables
contain rows with identical values in all columns, possibly, except the decision
column. In this case, each group of identical rows was replaced with a single
row with common values in all input columns and the most common value in
the decision column. Some tables contains missing values. Each missing value
was replaced with the most common value in the corresponding column.
The resulted table was interpreted as a decision table T ∗
z where in-
put columns represent attribute values and the output column represents
values of the function ν(x). We assume uniform probability distribution
P(x) ≡1. As an integral performance measure we consider the average rel-
ative deviation(ARD). For an approximate algorithm X, a set of problems
Z = {z1, . . . , zt}, and a set of probability distributions P = {P1, . . . , Pt},
ARD(X, Z, P) = 1
t
t

i=1
hX(zi, Pi) −h(zi, Pi)
h(zi, Pi)
,
where hX(zi, Pi) is the P-average depth of the decision tree for zi built by
X. We assume that none of the tables Tzi are terminal, so h(zi, Pi) > 0 for
i = 1, . . . , t.
Table 4.1 shows results of experiments with 24 data sets. Each row contains
data set name, the minimum average depth of decision tree calculated by the
algorithm A, and the average depth of decision trees built by each of the
eight greedy algorithms. The last row shows the average relative diﬀerence
for the greedy algorithms. One can see that a combination of weighted sum
with Gini index (the criterion used by CART [8]) and entropy (the criterion
used by ID3 [70]) results in the least ARD values.
4.3
Modeling Monotonic Boolean Functions by
Decision Trees
The property of the algorithm A to build optimal decision trees can be
used to ﬁnd exact values of the Shannon-type function HB(n) described
in Chap. 3.2 for small n. In this section, an experiment is described that
calculates HB(n) for monotone functions depending on up to six variables.
The number of monotone functions of n arguments (also known as Dedekind
number M(n)) is a rapidly growing sequence. The second column of Table 4.2
contains number M(n) for n = 1, . . . , 6. Using algorithm A, we built optimal

4.3
Modeling Monotonic Boolean Functions by Decision Trees
73
Fig. 4.3 Spectrum of h(f) values for n = 5
decision trees for all functions and thus calculated the value of HB(n) that
is given in the third column. The fourth and ﬁfth column contain the lower
and the upper bound on HB(n) which are given by Proposition 3.8.
Table 4.2 HB(n) and its bounds for the class of monotone functions
n
M(n)
HB(n) Lower Upper
bound bound
1
3
1
0.59
1
2
6
1.5
1.27
1.5
3
20
2.5
2
2.5
4
168
3.125
2.76
3.5
5
7561
4.125
3.55
4.5
6 7828354 4.8125
4.35
5.63
The experiments revealed that the minimum average depth reaches its
maximum on threshold functions described in Sect. 3.1.3. For odd n, the
only function having h(f) = HB(n) is T hrn,(n+1)/2. For even n, there are
two such functions: T hrn,n/2 and T hrn,n/2+1. Note that all these functions
are α-functions, so the obtained value of HB(n) is the same for the classes
M1, M2, M3, M4. The function T hrn,(n+1)/2 is a self-dual function for odd
n, so the obtained values of HB(n), n = 1, 3, 5, are applicable to the class
D2. The experiment also allows to ﬁnd the histogram of distribution of the

74
4
Algorithms for Decision Tree Construction
Fig. 4.4 Spectrum of h(f) values for n = 6
minimum average depth among functions in M1 of n variables. Fig. 4.3 and
4.4 show histogram of h(f) for monotone functions of ﬁve and six variables.
4.4
Constructing Optimal Decision Trees for Corner
Point Detection
In this section, we consider a problem that originated in computer vision:
constructing an optimal testing strategy for corner point detection by FAST
algorithm [74, 75]. The problem can be formulated as a problem of building a
decision tree with the minimum average depth. We experimentally compare
performance of the algorithm A and several greedy algorithms that diﬀer in
the attribute selection criterion.
4.4.1
Corner Point Detection Problem
One of the important problems considered in computer vision is object track-
ing that is given a video stream, locating an object and determining its
position in each frame. There are several approaches to object tracking. One
of the accepted approaches is detecting feature points and acquiring the ob-
ject position by these points. Rosten and Drummond devised FAST algorithm
[74, 75] that tracks an object by position of its corners and proposed a simple

4.4
Constructing Optimal Decision Trees for Corner Point Detection
75
Fig. 4.5 [74] FAST Feature detection in an image patch. The highlighted squares
are the pixels used in the feature detection. The pixel at C is the center of a detected
corner: the dashed line passes through 12 contiguous pixels that are brighter than C
by more than the threshold γ.
algorithm for corner point detection. The algorithm iterates through all im-
age pixels and detects corner points by comparing the intensity of the current
pixel and surrounding pixels. In order to determine if an image pixel a is a
corner point, a circle of 16 pixels (a Bresenham circle of radius 3) surround-
ing a is examined: the intensity of each pixel of the circle is compared with
the intensity of a. The pixel a is assumed to be a corner point if at least 12
contiguous pixels on the circle are all either brighter or darker than a by a
given threshold γ (Fig. 4.5).
The surrounding pixels can be tested in an arbitrary order, and the re-
quired number of tests depends on the data and the chosen order of testing.
A good testing strategy can reduce the expected number of checks and thus
reduce the running time of the algorithm. One can see that in order to claim
the current pixel as a corner point, at least 12 checks needs to be done, but
some candidate pixels can be rejected after only four checks. For example,
checking the circle points 1, 5, 9 and 13 allows to reject candidates that do
not have at least three out of four pixels either darker or lighter than the
central pixel.
For an arbitrary pixel a and for i = 1, . . . , 16, denote by φi(a) the intensity
of the i-th pixel in the circle surrounding a (the pixel ordering is shown on
Fig. 4.3) and denote by φc(a) the intensity of the pixel a. The pixel a can
be represented as an object that is characterized by the attributes f1, . . . , f16
where

76
4
Algorithms for Decision Tree Construction
fi(a) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
0 ,
if φi(a) −φc(a) < −γ ,
1 ,
if |φi(a) −φc(a)| ≤γ ,
2 ,
if φi(a) −φc(a) > γ .
The problem of corner point detection can be formulated as a problem
z = (ν, f1, . . . , f16) over a 3-valued information system U = (A, F). The set
A contains examples of image patches collected from the training data set that
is a set of images or a video fragment that is similar to one the algorithm will
work with. The set F consists of the attributes f1, . . . , f16, and the function
ν takes the value 1 if given combination of attribute values correspond to
a corner point, and 0 otherwise. Using the training data set, one can also
estimate a probability distribution P as cardinality of the equivalence classes
obtained by partitioning of A with the attributes from F. Then a valid testing
strategy can be represented by a decision tree for z that solves z, and an
optimal strategy corresponds to a tree with the minimum P-average depth.
4.4.2
Experimental Results
Following the method proposed by the authors of FAST algorithm, we es-
timated the probability distribution from the training data. For each pixel
a (except a 2-pixel outer boundary of each image), we calculated the tuple
(f1(a), . . . , f16(a)) of attribute values. Then we formed a decision table T ∗
z
that contains as rows all tuples of attribute values encountered in the train-
ing data. Each row is assigned with the estimated probability that is the
number of occurrences of the corresponding tuple. We did not include to the
decision table the rows that do not appear in the training data. These tuples
of attribute values may encounter on other images and may be misclassiﬁed,
but we suppose they are less probable, so the number of misclassiﬁcations
will be small and can be compensated by the sensor fusion technique on a
subsequent stage of the object tracking algorithm.
We performed an experiment that compares the average depth of decision
trees built by the greedy algorithms with the minimum value. For training,
we took three groups of images considered in [75] named box, junk and maze
and tried ﬁve values of the threshold γ: 30, 40, 50, 70 and 100. For each set of
images and each threshold value, a decision table T ∗
z was constructed. Then
for each decision table, decision trees were build by the algorithm A and by
three greedy algorithms that use a combination of weighted-sum impurity
function with gini, ent and me uncertainty measures respectively.

4.4
Constructing Optimal Decision Trees for Corner Point Detection
77
Table 4.3 Characteristics of decision tables
Data set Threshold # of # of corner
# of
# of
Time,
rows
points
nodes
edges
s
maze
100
1343
8
88577
363418
1
maze
70
5303
476
1699986 9223694
59
maze
50
15198
2135
5030983 24660203 339
maze
40
27295
4165
8167123 37285264 830
maze
30
50750
9310
14278124 60596561 2404
junk
100
146
0
0
0
0
junk
70
980
8
40045
157697
1
junk
50
3509
101
742765
4055185
20
junk
40
8323
282
1926830 9946555
85
junk
30
18243
847
4379006 22110004 350
box
100
680
15
58186
308882
1
box
70
3225
113
918734
4876964
23
box
50
10972
546
4059543 20901371 215
box
40
20080
1487
7075517 33320358 574
box
30
38381
4258
12404116 53458575 1660
Table 4.4 Average depth of decision trees
Data set Threshold Min. avg.
Uncertainty measure
γ
depth
ent
gini
me
maze
100
1.27327 1.38421 1.4073 1.28518
maze
70
2.97021 3.31982 3.43315 3.32529
maze
50
3.07119 3.25339 3.49671 3.38137
maze
40
3.13391 3.28679 3.55746 3.45605
maze
30
3.27496
3.4028 3.73163 3.53888
junk
70
1.17653 1.22653 1.22653 1.22653
junk
50
2.58393 2.73041 2.77344 2.76917
junk
40
2.77556 3.01826 2.97345 2.98738
junk
30
2.84794 3.04665 3.08738 3.17831
box
100
1.26912 2.19706 2.28824 1.28235
box
70
2.68217 2.83969 3.05891 2.8093
box
50
3.05851 3.24426 3.34962 3.35992
box
40
3.14631 3.43322 3.60652 3.60931
box
30
3.27373 3.47195 3.62302 3.72645
ARD
0.10738 0.14914 0.07744

78
4
Algorithms for Decision Tree Construction
For each decision table, Table 4.3 cites the total number of rows and the
number of corner points detected in the training data. Additionally, the table
shows the number of nodes and the number of edges in the graph Δ(z), and
the running time of the algorithm A. The results give an evidence that A is
capable of processing a table containing up to 50, 000 rows and producing a
graph with more than 14, 000, 000 nodes. Table 4.4 gives the average depth
of decision trees built by the exact algorithm and by the greedy algorithms.
One can see that an optimal strategy requires less than four points to test on
average. For each uncertainty measure U, the last row contains the average
relative deviation of the greedy algorithm that uses U in the impurity criteria.
One can see that the greedy algorithms construct decision trees with the
average depth 7−15% greater than the minimum. The greedy algorithm that
uses uncertainty measure me has the minimum ARD. However, for smaller
values of γ, there is larger variety of data (more rows in the decision table)
and the greedy algorithm that uses ent performs better (this is, in fact, ID3
algorithm [70] applied for this problem in [75]).

Chapter 5
Problems over Information Systems
The problems of estimation of the minimum average time complexity of de-
cision trees and design of eﬃcient algorithms are complex in general case.
The upper bounds described in Chap. 2.4.3 can not be applied directly due
to large computational complexity of the parameter M(z). Under reasonable
assumptions about the relation of P and NP, there are no polynomial time
algorithms with good approximation ratio [12, 32]. One of the possible solu-
tions is to consider particular classes of problems and improve the existing
results using characteristics of the considered classes.
We use the notion of information system to describe a class of problems.
The set of objects and the set of attributes are allowed to be inﬁnite (but
countable). Among all information systems, we distinguish the restricted in-
formation systems in which any system of equations of the type “attribute”
= “value” has an equivalent subsystem whose weight is below a predeﬁned
threshold.
The ﬁrst section describes the notion of restricted information system and
gives bounds on the average weighted depth of decision trees depending only
on the entropy. In the second section, we prove that for a restricted informa-
tion system, under reasonable assumptions about weight function and prob-
ability distribution, the time complexity of the algorithm A is limited from
above by a polynomial on the number of attributes in the problem descrip-
tion. Some results of this chapter were published in [17].
5.1
On Bounds on Average Depth of Decision Trees
Depending Only on Entropy
Let U = (A, F) be an information system and Ψ be a weight function for
U. Theorem 2.3 gives a bound on the minimum average weighted depth of
I. Chikalov: Average Time Complexity of Decision Trees, ISRL 21, pp. 79–84.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

80
5
Problems over Information Systems
decision tree for an arbitrary problem z over U. However, eﬃciency of this
bound is limited due to large computational complexity of the parameter
MΨ(z). Let us consider a necessary and suﬃcient condition for existence of a
function Φ such that hΨ(z, P) ≤Φ(H(P)) for any problem z over U and any
probability distribution P for z.
For an arbitrary natural number t, a system of equations of the form
{f1(x) = δ1, . . . , ft(x) = δt} ,
(5.1)
where f1, . . . , ft ∈F and δ1, . . . , δt ∈Ek is called a system of equations over
U. A system of equations over U is called irreducible, if it does not have any
proper equivalent subsystems. An information system U is called r-restricted
(restricted) if each compatible system of equations over U has an equivalent
subsystem that contains at most r equations.
For the system of equations (5.1), the value t
i=1 Ψ(fi) is called the weight
of the system. An information system U is called r-restricted (restricted)
relative to Ψ if each compatible system of equations over U has an equivalent
subsystem whose weight does not exceed r.
Example 5.1. Let A = Rn, and F be a nonempty set of mappings from Rn to
R. Consider an inﬁnite family of functions [F] = {sign(f +α)+1 : f ∈F, α ∈
R} (note that the expression (sign(x) + 1) takes the value 0 for a negative x,
1 for x = 0, and 2 for a positive x). If |F| = k < ∞, then the information
system U = (A, [F]) is 2k-restricted (or 2k-restricted relative to the weight
function Ψ ≡1).
The following theorem for an arbitrary problem over a restricted information
system and an arbitrary probability distribution, gives an upper bound on
the minimum average weighted depth of decision tree that depends only on
the entropy of probability distribution.
Theorem 5.1. Let U be an information system, Ψ a weight function for U
and U be r-restricted relative to Ψ where r is some natural number. Then
hΨ(z, P) ≤2r(H(P) + 1) for an arbitrary problem z over U and an arbitrary
probability distribution P for z.
Proof. Let U be a k-valued information system, U = (A, F) and z =
(ν, f1, . . . , fn). If z ≡const on A, then obviously MΨ(z) ≤r. Let z ̸≡const on
A. Let us consider an arbitrary tuple ¯δ = (δ1, . . . , δn) from En
k and show that
MΨ(z, ¯δ) ≤2r. From the deﬁnition of the parameter MΨ(z, ¯δ) it follows that
there exists an irreducible system of equations S = {fi1(x) = δi1, . . . , fit(x) =
δit} over z such that t > 0 and the weight of the system is MΨ(z, ¯δ). De-
note by A(S) the set of solutions of this system on A. If A(S) ̸= ∅, then the

5.1
On Bounds on Average Depth of Decision Trees Depending Only on Entropy81
weight of S does not exceed r. Let A(S) = ∅. Denote S1 = S \ {fi1(x) = δi1}.
The equality A(S) = ∅and the fact that S is irreducible imply that S1 is a
compatible irreducible system. Therefore, the weight of the system S1 does
not exceed r and the weight of the system S does not exceed r + Ψ(fi1).
According to the deﬁnition of system of equations, fi1(x) ̸≡const on A. Con-
sequently, there exists a number δ ∈Ek for which the set of solutions of the
equation fi1(a) = δ is a nonempty proper subset of A. Then the system of
equations {fi1(x) = δ} is irreducible and compatible, and its weight (that is
equal to Ψ(fi1)) does not exceed r. Therefore, the weight of the system of
equations S does not exceed 2r and the value of the parameter MΨ(z) (as
the maximum of MΨ(z, ¯δ), ¯δ ∈En
k ) does not exceed 2r. Theorem 2.3 implies
that hΨ(z, P) ≤2r(H(P)+1).
⊓⊔
The following theorem shows that the conditions of Theorem 5.1 are neces-
sary and suﬃcient for existence of a linear upper bound depending only on
the entropy and considering non-linear bounds does not extend the class of
information systems that have upper bounds depending only on the entropy.
Theorem 5.2. Let U be an information system that is not restricted rela-
tive to the weight function Ψ for U. Then for an arbitrary ε > 0, there is
no function Φ that is limited within the interval [0, ε] and possesses the con-
dition hΨ(z, P) ≤Φ(H(P)) for any problem z over U and any probability
distribution P for z.
Proof. Let U = (A, F) be a k-valued information system. Assume that for
some ε > 0, there exists a function Φ such that Φ(x) ≤K, x ∈[0, ε], and
hΨ(z, P) ≤Φ(H(P)) for any problem z over U and any probability distri-
bution P for z. By the premise of the theorem, for each natural number i,
there exists an irreducible compatible system of equations Si with the weight
at least i. For i = 1, 2, . . ., set into correspondence to the system of equa-
tions Si a problem zi over U. Let Si = {f i
1(x) = δi
1, . . . , f i
ni(x) = δi
ni}. Then
zi = (νi, f i
1, . . . , f i
ni) where νi : {0, 1}ni →ω,
νi(¯δ) =

1 ,
if ¯δ = ¯δi ,
0 ,
if ¯δ ̸= ¯δi ,
and ¯δi = (δi
1, . . . , δi
ni). Let the table Tzi contain si rows. Deﬁne a probability
distribution Pi as follows:
Pi( ¯d) =

(s2
i −si + 1) ,
if ¯d = ¯δi ,
1,
if ¯d ̸= ¯δi .

82
5
Problems over Information Systems
Let the function Ψ be not limited. This allows for choosing the systems Si
such that each of them consists of a single equation. Then si ∈{2, . . . , k} for
any i ∈ω\{0}, and the value Φ(H(Pi)) takes at most k diﬀerent values. Con-
sequently, Φ(H(Pi)) is limited from above by some constant (for convenience
of notations let it be equal to K).
Let the function Ψ be limited. This allows for choosing the systems of
equations such that for any natural i the system Si contains at least i equa-
tions. Irreducibility of the system Si implies the inequality si ≥i. From the
deﬁnition of entropy it follows that H(Pi) ≥0 for any natural number i.
Apply the following transformations:
H(Pi) = log2 s2
i −1
s2
i
(s2
i −si + 1) log2(s2
i −si + 1)
= log2 s2
i −

1 −si −1
s2
i
 
log2 s2
i + log2(1 −si −1
s2

< −

1 −si −1
s2
i

log2

1 −si −1
s2
i

+ 2
si
log2 si .
One can see that for i →∞, both summands tend to zero. Then there exists
a number i0 ∈ω \ {0} such that H(Pi) < ε for i ≥i0. According to the
assumption, Φ(H(Pi)) ≤K for i ≥i0.
Let Γi be a decision tree for the problem zi that solves zi, and Γi be
optimal for Ψ, zi and Pi. Then there exists a complete path ξi in Γi such
that ¯δi ∈Tziπ(ξi). Since for an arbitrary row ¯d ∈Tzi, ¯d ̸= ¯δi, the relation
ν( ¯d) ̸= ν(¯δi) holds, the subtable Tziπ(ξi) does not contain other rows except
¯δi. Irreducibility of the system Si implies Ψ(ξi) ≥i, and the nonterminal
nodes of the path ξi are assigned with all attributes from the set {f i
1, . . . , f i
ni}.
Using the deﬁnition of the average weighted depth, we obtain
hΨ(Γ, Pi) ≥Ψ(ξi)Pi(δi)
N(Tzi, Pi) ≥i(s2
i −si + 1)
s2
i
≥i
2 .
Taking into account that the tree Γi is optimal for Ψ, zi and Pi, we have
hΨ(zi, Pi) ≥i/2. Therefore, there exists a number i1 ∈ω \ {0} such that
hΨ(zi, Pi) > K for i ≥i1. Then for any number i∗> max(i0, i1), the inequal-
ity hΨ(zi∗, Pi∗) > Φ(H(Pi∗)) holds. Consequently, the considered assumption
is wrong.
⊓⊔

5.2
Polynomiality Criterion for Algorithm A
83
5.2
Polynomiality Criterion for Algorithm A
Let U = (A, f1, f2, . . .) be an inﬁnite information system and Ψ a weight
function for U. Denote Z(U) the set of problems over the information system
U. For an arbitrary problem z, denote by dim z the number of attributes listed
in the description of z.
Consider the functions
SU(n) = max{|S(z)| : z ∈Z(U), dim z ≤n}
and
DU(n) = max{D(Tz) : z ∈Z(U), dim z ≤n}
that characterize the dependence of the maximum number of separable subta-
bles and the maximum number of rows on the number of columns in decision
tables over U.
Let Ψ be restricted from above by some constant, and Q(x) be some poly-
nomial. Theorem 4.2 implies that for an arbitrary problem z over U and an
arbitrary Q-restricted probability distribution for the problem z, the time
complexity of the algorithm A is restricted from above by a polynomial on
the number of attributes in the problem description if the functions SU(n)
and DU(n) are restricted from above by a polynomial on n. Also, one can see
that the time complexity of the algorithm A has an exponential lower bound
if the function SU(n) grows exponentially.
Theorem 5.3. Let U = (A, F) be a k-valued information system. Then the
following statements hold:
a) if U is r-restricted, then SU(n) ≤(nk)r + 1 and DU(n) ≤(nk)r + 1 for
any natural number n;
b) if U is not restricted, then SU(n) ≥2n −1 for any natural number n.
Proof. a) Let U be r-restricted and z = (ν, f1, . . . , fn) ∈Z(U). One can
see that the values |S(Tz)| and D(Tz) do not exceed the number of pairwise
nonequivalent compatible subsystems of the system of equations {f1(x) =
0, . . . , fn(x) = 0, . . . , f1(x) = k −1, . . . , fn(x) = k −1} including the empty
system (assume the set of solutions of the empty system to be equal to A).
Since the system of equations U is r-restricted, each compatible system of
equations over U contains an equivalent subsystem of at most r equations.
Then |S(z)| ≤(dim z)rkr+1 and D(Tz) ≤(dim z)rkr+1. Therefore, SU(n) ≤
(nk)r + 1 and DU(n) ≤(nk)r + 1.
b) Let U be not restricted and n be a natural number. Then there exists
an irreducible system of equations over U containing at least n. equations.
Since each its subsystem is irreducible, there exists an irreducible system

84
5
Problems over Information Systems
over U that consists of n equations. Let it be the system (5.1) which will be
denoted by W. Let us show that any two diﬀerent subsystems W1 and W2 of
W are not equivalent. Assume the contrary. Then the systems W \(W1 \W2)
and W \ (W2 \ W1) are equivalent to W, and at least one of them is a
proper subsystem of W that is impossible. Consider a diagnostic problem
z = (ν, f1, . . . , fn). One can set into correspondence to a proper subsys-
tem {fi1(x) = δ1, . . . , fit(x) = δt} of the system W the separable subtable
Tz(fi1, δ1) . . . (fit, δt) of the table Tz. Since any two diﬀerent subsystems are
nonequivalent to each other and to the system W, the subtables correspond-
ing to these subsystems are diﬀerent and nonterminal. Then |S(Tz)| ≥2n−1.
Therefore, SU(n) ≥2n −1.
⊓⊔

Conclusions
The monograph considers several aspects of the problem of constructing
decision trees with the minimum time complexity. A known bound on the
minimum average depth for a problem with a complete set of attributes is
generalized in two ways. First, a bound for an arbitrary problem is obtained
that depends on the parameter M(z). Second, a class of restricted informa-
tion systems is described; so all problems over a restricted information system
have a common bound depending only on the entropy. A necessary condition
for the problem decomposition is described that might be too restrictive for
using in applications, but it works in constructive proofs.
An exact algorithm A for construction of decision trees has been studied
both theoretically and experimentally. The experimental results described in
Chap. 4.4.2 show that A is capable of processing a table with 16 attributes
and more than 50000 rows. A class of all information systems was described
for which the algorithm has polynomial time complexity on the decision table
size. It allows further optimization by using branch and bound methods to
reduce the search space. Current parallel computing environments enable
an eﬀective implementation of such algorithms and make it applicable for
practical problems described by decision tables of a moderate size.

Appendix A
Closed Classes of Boolean Functions
The lattice of all classes of Boolean functions closed relative to the operation
of substitution has been described by Post in [67, 68]. In [36], Yablonskii,
Gavrilov and Kudriavtzev considered the structure of all classes of Boolean
functions closed relative to the operation of substitution and the operations
of insertion and deletion of inessential variable. Appendix contains the de-
scription of this structure that is slightly diﬀerent from Post’s lattice.The
text of Appendix is close to the text of Appendix in [50].
A.1
Some Deﬁnitions and Notation
Let U be a set of Boolean functions, f(x1, . . . , xn) be a function from U, and
gi be either a function from U or a variable, i = 1, . . . , n. We will say that
the function f(g1, . . . , gn) is obtained from functions from U by the operation
of substitution.
Let f(x1, . . . , xn) be a Boolean function. A variable xi of the function f
is essential if there exist two n-tuples ¯δ and ¯σ from En
2 that diﬀer only
in the i-th digit and for which f(¯δ) ̸= f(¯σ). The variables of the func-
tion f that are not essential are called inessential variables. Let xj be an
inessential variable of the function f and g(x1, . . . , xj−1, xj+1, . . . , xn) =
f(x1, . . . , xj−1, 0, xj+1, . . . , xn). We will say that the function g is obtained
from f by the operation of deletion of inessential variable. We will say that
the function f is obtained from g by the operation of insertion of inessential
variable.
Let U be a nonempty set of Boolean functions. We denote by [U] the clo-
sure of the set U relative to the operation of substitution and the operations
of insertion and deletion of inessential variable. The set U is called a closed
class if U = [U].
I. Chikalov: Average Time Complexity of Decision Trees, ISRL 21, pp. 87–85.
springerlink.com
c⃝Springer-Verlag Berlin Heidelberg 2011

88
A
Closed Classes of Boolean Functions
The notion of a formula over U is deﬁned inductively in the following way:
a) The expression f(x1, . . . , xn), where f(x1, . . . , xn) is a function from U,
is a formula over U.
b) Let f(x1, . . . , xn) be a function from U and ϕ1, . . . , ϕn be expres-
sions that are either formulas over U or variables. Then the expression
f(ϕ1, . . . , ϕn) is a formula over U.
A Boolean function corresponds in natural way to any formula over U. We
will say that the formula realizes this Boolean function.
Denote by [U]1 the closure of the set U relative to the operation of sub-
stitution. One can show that [U]1 coincides with the set of functions realized
by formulas over U. Denote by [U]2 the closure of the set [U]1 relative to
the operations of insertion and deletion of inessential variable. One can show
that [U] = [U]2.
We denote the logical negation operation by ¬ and the modulo 2 sum-
mation by ⊕. For a natural n and t ∈E2, denote by ˜tn the n-tuple
(t, t, . . . , t) ∈En
2 . Let f be a Boolean function depending on n variables.
The function f is called α-function if f(˜tn) = t for any t ∈E2, β-function if
f(˜tn) = 1 for any t ∈E2, and γ-function if f(˜tn) = 0 for any t ∈E2.
A function f is called a linear function if f = c0 ⊕c1x1 ⊕. . .⊕cnxn where
ci ∈E2, 0 ≤i ≤n. A function f is called a self-dual function if f(x1, . . . , xn)
= ¬f(¬x1, . . . , ¬xn). A function f is called a monotone function if for any
n-tuples ¯δ = (δ1, . . . , δn) and ¯σ = (σ1, . . . , σn) from En
2 such that δi ≤σi,
1 ≤i ≤n, the inequality f(¯δ) ≤f(¯σ) holds.
Let μ ∈ω \ {0, 1}. We will say that a function f(x1, . . . , xn) satisﬁes the
condition ⟨aμ⟩if for any μ tuples from En
2 on which f takes the value 0 there
exists a number j ∈{1, . . . , n} such that in each of the considered tuples the
j-th digit is equal to 0. We will say that the function f satisﬁes the condition
⟨a∞⟩if there exists a number j ∈{1, . . . , n} such that in any n-tuple from
En
2 on which f takes the value 0 the j-th digit is equal to 0. We will say that
the function f satisﬁes the condition ⟨Aμ⟩if for any μ tuples from En
2 on
which f takes the value 1 there exists a number j ∈{1, . . ., n} such that in
each of the considered tuples the j-th digit is equal to 1. We will say that a
function f satisﬁes the condition ⟨A∞⟩if there exists a number j ∈{1, . . . , n}
such that in any n-tuple from En
2 on which f takes the value 1 the j-th digit
is equal to 1. The constant 1, by deﬁnition, satisﬁes the condition ⟨a∞⟩and
does not satisfy the condition ⟨A2⟩. The constant 0, by deﬁnition, satisﬁes
the condition ⟨A∞⟩and does not satisfy the condition ⟨a2⟩.
Let μ ∈ω \ {0, 1}. Denote
hμ =
μ+1

i=1
(x1 ∧x2 ∧. . . ∧xi−1 ∧xi+1 ∧. . . ∧xμ+1)

A.2
Description of All Closed Classes of Boolean Functions
89
and
h∗
μ =
μ+1

i=1
(x1 ∨x2 ∨. . . ∨xi−1 ∨xi+1 ∨. . . ∨xμ+1) .
A.2
Description of All Closed Classes of Boolean
Functions
In this subsection, all closed classes of Boolean functions are listed. For each
class the Post notation is given, the description of functions contained in
the considered class is presented, and a ﬁnite set of Boolean functions is
given such that its closure relative to the operation of substitution and the
operations of insertion and deletion of inessential variable is equal to this
class.
As in [36], two Boolean functions are called equal if one of them can
be obtained from the other by the operations of insertion and deletion of
inessential variable.
The inclusion diagram for closed classes of Boolean functions [36] is de-
picted in Fig. A.1. Each closed class is represented by a dot. The dots cor-
responding to certain classes U and V are connected with an edge if V is
immediately included into U (there are no intermediate classes between U
and V ); in this case, the dot corresponding to the outer class U is placed
higher on the diagram. 1. The class O1 = [{x}]. This class consists of all
functions equal to the function x, and all functions obtained from them by
renaming of variables without identiﬁcation.
2. The class O2 = [{1}]. This class consists of all functions equal to the
function 1.
3. The class O3 = [{0}]. This class consists of all functions equal to the
function 0.
4. The class O4 = [{¬x}]. This class consists of all functions equal to
the functions x or ¬x, and all functions obtained from them by renaming of
variables without identiﬁcation.
5. The class O5 = [{x, 1}]. This class consists of all functions equal to
the functions 1 or x, and all functions obtained from them by renaming of
variables without identiﬁcation.
6. The class O6 = [{x, 0}]. This class consists of all functions equal to
the functions 0 or x, and all functions obtained from them by renaming of
variables without identiﬁcation.
7. The class O7 = [{0, 1}]. This class consists of all functions equal to the
functions 0 or 1.

90
A
Closed Classes of Boolean Functions
Fig. A.1 Inclusion diagram for closed classes of Boolean functions
8. The class O8 = [{x, 0, 1}]. This class consists of all functions equal to
the functions 0, 1 or x, and all functions obtained from them by renaming of
variables without identiﬁcation.
9. The class O9 = [{¬x, 0}]. This class consists of all functions equal to the
functions 0, 1, ¬x, or x, and all functions obtained from them by renaming
of variables without identiﬁcation.
10. The class S1 = [{x ∨y}]. This class consists of all disjunctions (i.e.,
functions of the form n
i=1 xi, n = 1, 2, . . . and all functions obtained from
them by renaming of variables without identiﬁcation).
11. The class S3 = [{x ∨y, 1}]. This class consists of all disjunctions and
all functions equal to 1.

A.2
Description of All Closed Classes of Boolean Functions
91
12. The class S5 = [{x ∨y, 0}]. This class consists of all disjunctions and
all functions equal to 0.
13. The class S6 = [{x∨y, 0, 1}]. This class consists of all disjunctions and
all functions equal to the functions 0 or 1.
14. The class P1 = [{x ∧y}]. This class consists of all conjunctions (i.e.,
functions of the form n
i=1 xi, n = 1, 2, . . . and all functions obtained from
them by renaming of variables without identiﬁcation).
15. The class P3 = [{x ∧y, 0}]. This class consists of all conjunctions and
all functions equal to 0.
16. The class P5 = [{x ∧y, 1}]. This class consists of all conjunctions and
all functions equal to 1.
17. The class P6 = [{x ∧y, 0, 1}]. This class consists of all conjunctions
and all functions equal to 0 or 1.
18. The class L1 = [{x ⊕y, 1}]. This class consists of all linear functions.
19. The class L2 = [{x⊕y⊕1}]. This class consists of all linear α-functions
and β-functions (i.e., functions of the form 2k
i=1 xi ⊕1, 2l+1
i=1 xi, k, l =
0, 1, 2, . . . and all functions obtained from them by renaming of variables
without identiﬁcation).
20. The class L3 = [{x ⊕y}]. This class consists of all linear α-functions
and γ-functions (i.e., functions of the form l
i=1 xi, l = 0, 1, 2, . . . and all
functions obtained from them by renaming of variables without identiﬁca-
tion).
21. The class L4 = [{x⊕y⊕z}]. This class consists of all linear α-functions
(i.e., functions of the form 2l+1
i=1 xi, l = 0, 1, 2, . . . and all functions obtained
from them by renaming of variables without identiﬁcation).
22. The class L5 = [{x ⊕y ⊕z ⊕1}]. This class consists of all linear
self-dual functions (i.e., functions of the form 2l+1
i=1 xi ⊕1, 2l+1
i=1 xi, l =
0, 1, 2, . . . and all functions obtained from them by renaming of variables
without identiﬁcation).
23. The class D2 = [{(x ∧y) ∨(x ∧z) ∨(y ∧z)}]. This class consists of all
self-dual monotone functions.
24. The class D1 = [{(x ∧y) ∨(x ∧¬z) ∨(y ∧¬z)}]. This class consists of
all self-dual α-functions.
25. The class D3 = [{(x ∧¬y) ∨(x ∧¬z) ∨(¬y ∧¬z)}]. This class consists
of all self-dual functions.
26. The class A1 = M1 = [{x ∧y, x ∨y, 0, 1}]. This class consists of all
monotone functions.
27. The class A2 = M2 = [{x ∧y, x ∨y, 1}]. This class consists of all
monotone α-functions and β-functions.

92
A
Closed Classes of Boolean Functions
28. The class A3 = M3 = [{x ∧y, x ∨y, 0}]. This class consists of all
monotone α-functions and γ-functions.
29. The class A4 = M4 = [{x∧y, x∨y}]. This class consists of all monotone
α-functions.
30. The class C1 = [{¬(x∧y)}]. This class consists of all Boolean functions.
31. The class C2 = [{x∨y, x⊕y ⊕1}]. This class consists of all α-functions
and β-functions.
32. The class C3 = [{x ∧y, x ⊕y}]. This class consists of all α-functions
and γ-functions.
33. The class C4 = [{x ∨y, x ∧(y ⊕z ⊕1)}]. This class consists of all
α-functions.
34. The class F μ
1 = [{x ∨(y ∧¬z), h∗
μ}], μ = 2, 3, . . . . This class consists
of all α-functions satisfying the condition ⟨aμ⟩.
35. The class F μ
2 , μ = 2, 3, . . . where F μ
2 = [{x ∨(y ∧z), h∗
2}] if μ = 2,
and F μ
2 = [{h∗
μ}] if μ ≥3. This class consists of all monotone α-functions
satisfying the condition ⟨aμ⟩.
36. The class F μ
3
= [{1, h∗
μ}], μ = 2, 3, . . . . This class consists of all
monotone functions satisfying the condition ⟨aμ⟩.
37. The class F μ
4 = [{x ∨¬y, h∗
μ}], μ = 2, 3, . . . . This class consists of all
functions satisfying the condition ⟨aμ⟩.
38. The class F μ
5 = [{x ∧(y ∨¬z), hμ}], μ = 2, 3, . . . . This class consists
of all α-functions satisfying the condition ⟨Aμ⟩.
39. The class F μ
6 , μ = 2, 3, . . . where F μ
6 = [{x ∧(y ∨z), h2}] if μ = 2,
and F μ
6 = [{hμ}] if μ ≥3. This class consists of all monotone α-functions
satisfying the condition ⟨Aμ⟩.
40. The class F μ
7
= [{0, hμ}], μ = 2, 3, . . . . This class consists of all
monotone functions satisfying the condition ⟨Aμ⟩.
41. The class F μ
8 = [{x ∧¬y, hμ}], μ = 2, 3, . . . . This class consists of all
functions satisfying the condition ⟨Aμ⟩.
42. The class F ∞
1
= [{x ∨(y ∧¬z)}]. This class consists of all α-functions
satisfying the condition ⟨a∞⟩.
43. The class F ∞
2
= [{x ∨(y ∧z)}]. This class consists of all monotone
α-functions satisfying the condition ⟨a∞⟩.
44. The class F ∞
3
= [{1, x ∨(y ∧z)}]. This class consists of all monotone
functions satisfying the condition ⟨a∞⟩.
45. The class F ∞
4
= [{x∨¬y}]. This class consists of all functions satisfying
the condition ⟨a∞⟩.
46. The class F ∞
5
= [{x ∧(y ∨¬z)}]. This class consists of all α-functions
satisfying the condition ⟨A∞⟩.

A.2
Description of All Closed Classes of Boolean Functions
93
47. The class F ∞
6
= [{x ∧(y ∨z)}]. This class consists of all monotone
α-functions satisfying the condition ⟨A∞⟩.
48. The class F ∞
7
= [{0, x ∧(y ∨z)}]. This class consists of all monotone
functions satisfying the condition ⟨A∞⟩.
49. The class F ∞
8
= [{x∧¬y}]. This class consists of all functions satisfying
the condition ⟨A∞⟩.

References
1. Ahlswede, R., Wegener, I.: Suchprobleme. Teubner Verlag, Stuttgart (1979) (in
German)
2. Akers, S.B.: Binary decision diagrams. IEEE Trans. Comput. 27, 509–516 (1978)
3. Alekhnovich, M., Braverman, M., Feldman, V., Klivans, A.R., Pitassi, T.: Learn-
ability and automatizability. In: Proceedings of the 45th Annual IEEE Sympo-
sium on Foundations of Computer Science, pp. 621–630. IEEE Computer Society,
Washington, DC, USA (2004)
4. Angluin, D.: Queries revisited. Theor. Comput. Sci. 313, 175–194 (2004)
5. Brace, K.S., Rudell, R.L., Bryant, R.E.: Eﬃcient implementation of a BDD pack-
age. In: Proceedings of the 27th ACM/IEEE Design Automation Conference,
DAC 1990, pp. 40–45. ACM, New York (1990)
6. Brandman, Y., Orlitsky, A., Hennessy, J.: A spectral lower bound technique for
the size of decision trees and two-level AND/OR circuits. IEEE Trans. Com-
put. 39, 282–287 (1990)
7. Breiman, L.: Random forests. Mach. Learn. 45, 5–32 (2001)
8. Breiman, L., et al.: Classiﬁcation and Regression Trees. Chapman & Hall, New
York (1984)
9. Breitbart, Y., Reiter, A.: A branch-and-bound algorithm to obtain an optimal
evaluation tree for monotonic Boolean functions. Acta Inf. 4, 311–319 (1975)
10. Bryant, R.: Graph-based algorithms for Boolean function manipulation. IEEE
Trans. Comp. C-35(8), 677–691 (1986)
11. Cerny, E., Mange, D., Sanchez, E.: Synthesis of minimal binary decision trees.
IEEE Trans. Comput. 28, 472–482 (1979)
12. Chakaravarthy, V.T., Pandit, V., Roy, S., Awasthi, P., Mohania, M.: Decision
trees for entity identiﬁcation: approximation algorithms and hardness results.
In: Proceedings of the 26-th ACM SIGMOD-SIGACT-SIGART Symposium on
Principles of Database Systems, PODS 2007, pp. 53–62. ACM, New York (2007)
13. Chang, H.Y.: An algorithm for selecting on optimum self-diagnostic tests. IEEE
Transactions on Electronic Computers EC-14(5), 706–711 (1965)
14. Chegis, I., Jablonsky, S.: Logical methods for controlling electric circuit function.
Proceedings of V.A. Steklov Inst. of Maths 51, 270–360 (1958) (in Russian)
15. Cheng, L., Chen, D., Wong, M.D.F.: DDBDD: delay-driven BDD synthesis for
FPGAs. In: Proceedings of the 44th Annual Design Automation Conference, DAC
2007, pp. 910–915. ACM, New York (2007)

96
References
16. Chikalov, I.: Lower and upper bounds on minimal average depth of decision trees.
Tech. Rep. 96-11(232), Institute of Informatics of Warsaw University, Warsaw,
Poland (1996); Abstracts of the minisemester ”Logic, Algebra and Computer
Science, Helena Rasiova in memoriam”
17. Chikalov, I.: Bounds on average weighted depth of decision trees depending only
on entropy. In: Proceedings of the Seventh International Conference on Informa-
tion Processing and Management of Uncertainty in Knowledge-Based Systems,
pp. 1190–1194. La Sorbonne, Paris (1998)
18. Chikalov, I.: On decision trees with minimal average depth. In: Polkowski, L.,
Skowron, A. (eds.) RSCTC 1998. LNCS (LNAI), vol. 1424, pp. 506–512. Springer,
Heidelberg (1998)
19. Chikalov, I.: On average time complexity of decision trees and branching pro-
grams. Fundam. Inf. 39, 337–357 (1999)
20. Chikalov, I.: Algorithm for constructing of decision trees with minimal average
depth. In: Proceedings of the 8th Conference on Information Processing and
Management of Uncertainty in Knowledge-Based Systems, Madrid, Spain, vol. 1,
pp. 376–379 (2000)
21. Chikalov, I., Moshkov, M., Zelentsova, M.S.: On optimization of decision trees. In:
Peters, J., Skowron, A. (eds.) Transactions on Rough Sets IV. LNCS, vol. 3700,
pp. 18–36. Springer, Heidelberg (2005)
22. Cox Jr., L.A., Qiu, Y., Kuehner, W.: Heuristic least-cost computation of discrete
classiﬁcation functions with uncertain argument values. Ann. Oper. Res. 21, 1–30
(1990)
23. Dorfman, R.: The detection of defective members of large populations. The An-
nals of Mathematical Statistics 14(4), 436–440 (1943)
24. Egler, J.F.: A procedure for converting logic table conditions into an eﬃcient
sequence of test instructions. Commun. ACM 6, 510–514 (1963)
25. Frank, A., Asuncion, A.: UCI machine learning repository (2010),
http://archive.ics.uci.edu/ml
26. Friedman, J.H.: Greedy function approximation: A gradient boosting machine.
Annals of Statistics 29, 1189–1232 (2000)
27. Garey, M.R.: Optimal binary identiﬁcation procedures. SIAM Journal on Applied
Mathematics 23(2), 173–186 (1972)
28. Garey, M.R., Graham, R.L.: Performance bounds on the splitting algorithm for
binary testing. Acta Inf. 3, 347–355 (1974)
29. Gavrilov, G.P., Sapozhenko, A.A.: Problems and Exercises in Discrete Mathe-
matics. Kluwer Texts in the Mathematical Sciences, vol. 14. Kluwer Academic
Publishers, Dordrecht (2010)
30. Gower, J.C., Payne, R.W.: A comparison of diﬀerent criteria for selecting binary
tests in diagnostic keys. Biometrika 62(3), 665–672 (1975)
31. Gyllenberg, H.: A general method for deriving determination schemes for random
collections of microbial isolates. Ann. Acad. Sci. Fenn (A)69, 1–23 (1963)
32. Heeringa, B., Adler, M.: Approximating optimal binary decision trees. Tech. Rep.
05-25, University of Massachusetts, Amherst (2005)
33. Heged˝us, T.: Generalized teaching dimensions and the query complexity of learn-
ing. In: Proceedings of the Eighth Annual Conference on Computational Learning
Theory, COLT 1995, pp. 108–117. ACM, New York (1995)
34. Humby, E.: Programs from Decision Tables. Macdonald and Co., American El-
sevier, London, New York (1973)

References
97
35. Hyaﬁl, L., Rivest, R.: Constructing optimal binary decision trees is NP-complete.
Information Processing Letters 5, 15–17 (1976)
36. Jablonsky, S.W., Gawrilow, G.P., Kudrjawzev, V.B.: Boolesche Funktionen und
Postsche Klassen. Akademie-Verlag, Berlin (1970) (in German)
37. Kletsky, E.J.: An application of the information theory approach to failure di-
agnosis. IRE Transactions on Reliability and Quality Control, RQC-9(3), 29–39
(1960)
38. Knuth, D.E.: Sorting and Searching, The art of computer programming, 2nd edn.
vol. 3. Addison-Wesley, Reading (1998)
39. Kospanov, E.S.: An algorithm for the construction of suﬃciently simple tests.
Discrete Analysis 8, 43–47 (1966) (in Russian)
40. Lee, C.Y.: Representation of switching circuits by binary-decision programs. The
Bell System Technical Journal 38(4), 985–999 (1959)
41. Markov, A.A.: Introduction to Coding Theory. Nauka, Moscow (1982) (in Rus-
sian)
42. Martelli, A., Montanari, U.: Optimizing decision trees through heuristically
guided search. Commun. ACM 21, 1025–1039 (1978)
43. Moret, B.E., Gonzalez, R.C., Thomson, M.: activity of a variable and its relation
to decision trees. ACM Trans. Program. Lang. Syst. 2, 580–595 (1980)
44. Moret, B.E.: Decision trees and diagrams. ACM Comput. Surv. 14, 593–623
(1982)
45. Moshkov, M.: On conditional tests. Soviet Physics Doklady 27, 528 (1982)
46. Moshkov, M.: Conditional tests. Problemy Kybernetiki 40, 131–170 (1983) (in
Russian)
47. Moshkov, M.: Decision Trees.Theory and Appliucations Nizhni Novgorod Uni-
versity Publishers (1994) (in Russian)
48. Moshkov, M.: About the depth of decision trees computing Boolean functions.
Fundam. Inf. 22(3), 203–215 (1995)
49. Moshkov, M.: Some bounds on minimal decision tree depth. Fundam. Inf. 27(2/3),
197–203 (1996)
50. Moshkov, M.J.: Time complexity of decision trees. In: Peters, J., Skowron, A.
(eds.) Transactions on Rough Sets III. LNCS, vol. 3400, pp. 244–459. Springer,
Heidelberg (2005)
51. Moshkov, M., Chikalov, I.: On the average depth of decision trees over informa-
tion systems. In: Proceedings of the Fourth European Congress on Intelligent
Techniques and Soft Computing, Aachen, Germany, vol. 1, pp. 220–222 (1996)
52. Moshkov, M., Chikalov, I.: Upper bound on average depth of decision trees over
information systems. In: Proceedings of the Fourth International Workshop on
Rough Sets, Fuzzy Sets and Machine Discovery, Tokyo, Japan, pp. 139–141 (1996)
53. Moshkov, M., Chikalov, I.: Bounds on average depth of decision trees. In: Pro-
ceedings of the Fifth European Congress on Intelligent Techniques and Soft Com-
puting, Aachen, Germany, pp. 226–230 (1997)
54. Moshkov, M., Chikalov, I.: Bounds on average weighted depth of decision trees.
Fundam. Inf. 31(2), 145–156 (1997)
55. Moshkov, M., Chikalov, I.: On algorithm for constructing of decision trees with
minimal depth. Fundam. Inf. 41, 295–299 (2000)
56. Moshkov, M., Chikalov, I.: Consecutive optimization of decision trees concerning
various complexity measures. Fundam. Inf. 61(2), 87–96 (2003)

98
References
57. Nguen, H.S., Nguen, S.H.: From optimal hyperplanes to optimal decision trees:
rough set and boolean reasoning approaches. In: Proceedings of the Fourth In-
ternational Workshop on Rough Sets, Fuzzy Sets and Machine Discovery, Tokyo,
Japan, pp. 82–88 (1996)
58. Nguen, H.S., Nguen, S.H.: Discretization methods in data mining. In: Polkowski,
L., Skowron, A. (eds.) Rough Sets in Knowledge Discovery 1. Methodology and
Applications. Studies in Fuzziness and Soft Computing, vol. 18, pp. 451–482.
Physica-Verlag, Heidelberg (1998)
59. Okolnishnikova, E.A.: Lower bounds for branching programs computing charac-
teristic functions of binary codes. Metody Discretnogo Analiza 51, 61–83 (1991)
60. Pattipati, K.R., Dontamsetty, M.: On a generalized test sequencing problem.
IEEE Transactions on Systems, Man, and Cybernetics 22(2), 392–396 (1992)
61. Pawlak, Z.: Information Systems – Theoretical Foundations. PWN, Warsaw
(1981) (in Polish)
62. Pawlak, Z.: Rough Sets: Theoretical Aspects of Reasoning about Data. Kluwer
Academic Publishers, Norwell (1992)
63. Picard, C.F.: Theorie des Questionnaries. Gauthier-Villars, Paris (1965) (in
French)
64. Pollack, S.L.: Conversion of limited-entry decision tables to computer programs.
Commun. ACM 8, 677–682 (1965)
65. Pollack, S.L.: Decision Tables: Theory and Practice. John Wiley & Sons, Chich-
ester (1971)
66. Ponzio, S.: Restricted branching programs and hardware veriﬁcation. Ph.D. the-
sis, Massachusetts Institute of Technology (1995)
67. Post, E.: Introduction to a general theory of elementary propositions. Amer. J.
Math. 43, 163–185 (1921)
68. Post, E.: The two-valued iterative systems of mathematical logic. Annals of Math-
ematical Studies 5, 1–122 (1941)
69. Preparata, F.P., Shamos, M.I.: Computational Geometry: an Introduction.
Springer, Heidelberg (1985)
70. Quinlan, J.R.: Induction of decision trees. Mach. Learn. 1, 81–106 (1986)
71. Quinlan, J.R.: C4.5: Programs for Machine Learning (Morgan Kaufmann Series
in Machine Learning), 1st edn. Morgan Kaufmann, San Francisco (1993)
72. Redkin, N.P.: Reliability and Diagnostics of Circuits. Izd-vo MGU, Moscow
(1992) (in Russian)
73. Reinwald, L.T., Soland, R.M.: Conversion of limited-entry decision tables to opti-
mal computer programs I: Minimum average processing time. J. ACM 13, 339–358
(1966)
74. Rosten, E., Drummond, T.: Fusing points and lines for high performance tracking.
In: IEEE International Conference on Computer Vision, vol. 2, pp. 1508–1511
(2005)
75. Rosten, E., Drummond, T.: Machine learning for high-speed corner detection. In:
European Conference on Computer Vision, vol. 1, pp. 430–443 (2006)
76. Schumacher, H., Sevcik, K.C.: The synthetic approach to decision table conver-
sion. Commun. ACM 19, 343–351 (1976)
77. Shannon, C.E.: A mathematical theory of communication. Bell System Technical
Journal 27, 379–423, 623–656 (1948)
78. Shwayder, K.: Conversion of limited-entry decision tables to computer programs
a proposed modiﬁcation to Pollack’s algorithm. Commun. ACM 14, 69–73 (1971)

References
99
79. Skowron, A., Rauszer, C.: The discernibility matrices and functions in informa-
tion systems. In: Slowinski, R. (ed.) Intelligent Decision Support. Handbook of
Applications and Advances of the Rough Set Theory, pp. 331–362. Kluwer Aca-
demic Publishers, Dordrecht (1992)
80. Slagle, J.R.: An eﬃcient algorithm for ﬁnding certain minimum-cost procedures
for making binary decisions. J. ACM 11, 253–264 (1964)
81. Solovyev, N.A.: Tests (Theory, Construction, Applications). Nauka, Novosibirsk
(1978) (in Russian)
82. Thayse, A., Davio, M., Deschamps, J.P.: Optimization of multivalued decision
algorithms. In: Proceedings of the Eighth International Symposium on Multiple-
Valued Logic, MVL 1978, pp. 171–178. IEEE Computer Society Press, Los Alami-
tos (1978)
83. Wegener, I.: The Complexity of Boolean Functions. John Wiley & Sons, B.G.
Teubner, Stuttgart (1987)
84. Wegener, I.: On the complexity of branching programs and decision trees for
clique functions. J. ACM 35, 461–471 (1988)
85. Z´ak, S.: An exponential lower bound for one-time-only branching programs. In:
Proceedings of the Mathematical Foundations of Computer Science, pp. 562–566.
Springer, London (1984)

Index
MΨ(z) parameter
7, 37–39, 80
algorithms
A,
12, 62–69, 83–84
greedy,
70–71
branching program,
10, 59
implementing a function,
60
read-once,
10, 59
complexity measure,
7
average depth,
7, 8, 18
average weighted depth,
7, 8
depth,
7, 10, 42
decision table,
5
partition,
50
decision tree,
5
complete path in,
6
implementing Boolean
function,
9, 42, 72–74
irredundant,
11, 63
optimal,
7
solving the problem,
6
entropy of probability distribution,
8
information system,
4
a system of equations over,
13, 80
restricted,
80–82
probability distribution,
5
Q-restricted,
12, 69, 83
problem over information system,
4
decomposition,
9, 26–36
diagnostic,
5, 8, 16
with a complete set of
attributes,
8, 16
separable subtables,
6
a graph of,
64–66
compatible set of,
50
terminal,
6
Shannon-type functions
DU(n),
14, 83
GB(n),
10, 42
HB(n),
10, 42–58
SU(n),
14, 83
threshold function,
48
weight function,
4, 80

