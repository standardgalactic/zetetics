B. Hoffmann and M. Minas (Eds.): Twelfth International
Workshop on Graph Computation Models (GCM 2021)
EPTCS 350, 2021, pp. 51â€“68, doi:10.4204/EPTCS.350.4
A Categorical Semantics for Hierarchical Petri Nets
Fabrizio Romano Genovese*
0000-0001-7792-1375
University of Pisa / Statebox
fabrizio.romano.genovese@gmail.com
Jelle Herold
0000-0002-1966-2536
Statebox
research@statebox.io
Fosco Loregianâ€ 
0000-0003-3052-465X
Tallinn University of Technology
fosco.loregian@gmail.com
Daniele Palombi
0000-0002-8107-5439
Sapienza University of Rome
danielepalombi@protonmail.com
We show how a particular variety of hierarchical nets, where the ï¬ring of a transition in the parent net
must correspond to an execution in some child net, can be modelled utilizing a functorial semantics
from a free category â€“ representing the parent net â€“ to the category of sets and spans between
them. This semantics can be internalized via Grothendieck construction, resulting in the category
of executions of a Petri net representing the semantics of the overall hierarchical net. We conclude
the paper by giving an engineering-oriented overview of how our model of hierarchical nets can be
implemented in a transaction-based smart contract environment.
1
Introduction
This paper is the fourth instalment in a series of works [24, 23, 22] devoted to describing the semantics of
extensions of Petri nets using categorical tools.
Category theory has been applied to Petri nets starting in the nineties [31]; see also [6, 11, 8, 7, 3, 10,
4, 9, 12, 5]. The main idea is that we can use different varieties of free monoidal categories to describe
the executions (or runs) of a net [30, 20]. These works have been inï¬‚uential since they opened up an
avenue of applying high-level methods to studying Petri nets and their properties. For instance, in [2] the
categorical approach allowed to describe glueing of nets leveraging on colimits and double categories,
while category-theory libraries such as [19] can be leveraged to implement nets in a formally veriï¬ed way.
These libraries implement category theory directly, so that one could translate the categorical deï¬nitions
deï¬ning some model object directly and obtain an implementation.
In [24], we started another line of research, where we were able to deï¬ne a categorical semantics for
coloured nets employing monoidal functors. The Grothendieck construction was then used to internalize
this semantics, obtaining the well-known result that coloured nets can be â€œcompiled backâ€ to Petri nets.
In [23, 22], we extended these ideas further, and we were able to characterize bounded nets and
mana-nets â€“ a new kind of nets useful to model chemical reactions â€“ in terms of generalized functorial
semantics.
This approach, based on the correspondence between slice categories and lax monoidal functors to
the category of spans [33], has still a lot to give. In this paper, we show how it can be used to model
hierarchical nets.
*The ï¬rst author was supported by the project MIUR PRIN 2017FTXR7S â€œIT-MaTTerSâ€ and by the Independent Ethvestigator
Program.
â€ The third author was supported by the ESF funded Estonian IT Academy research measure (project 2014-2020.4.05.19-0001).

52
A Categorical Semantics for Hierarchical Petri Nets
There are a lot of different ways to deï¬ne hierarchical nets [26, 18, 32, 25, 14], which can be seen as a
graph-based model. It means that we have one â€œparentâ€ Petri net and a bunch of â€œchildâ€ nets. A transition
ï¬ring in the parent net corresponds to some sort of run happening in a corresponding child net. The main
net serves to orchestrate and coordinate the executions of many child nets in the underlayer.
This paper will contain very little new mathematics. Instead, we will reinterpret results obtained
in [24] to show how they can be used to model hierarchical nets, moreover, in a way that makes sense
from an implementation perspective.
It is worth noting that category theory in this paper is used in a way that is slightly different than the
usage in graph transformations research: We wonâ€™t be using category theory to generalize deï¬nitions
and proofs to different classes of graph(-related) objects. Instead, we will employ categorical concepts to
actually build a semantics for hierarchical Petri nets.
2
Nets and their executions
We start by recalling some basic constructions of category theory and some basic facts about Petri nets
and their categorical formalization. The notions of bicategory, pseudofunctor, lax functor and bimodule
are not strictly necessary to understand this paper: They only show up in results that we cite and that
could in principle be taken for granted while skimming on the details. In any case, we list these notions
here for the reader interested in parsing these results in full depth. The ï¬rst deï¬nition we recall is the
one of bicategory. Intuitively, bicategories are categories where we also allow for â€œmorphisms between
morphismsâ€, called 2-cells. This in turn allows to deï¬ne a version of the associativity and identity laws
that is weaker than for usual categories, holding only up to isomorphism.
Deï¬nition 1 (Bicategory). A (locally small) bicategory B consists of the following data.
1. A class Bo of objects, denoted with Latin letters like A,B,..., also called 0-cells.
2. A collection of (small) categories B(A,B), one for each A,B âˆˆBo, whose objects are called 1-cells
or arrows with domain A and codomain B, and whose morphisms Î± : f â‡’g are called 2-cells or
transformations with domain f and codomain g; the composition law â—¦in B(A,B) is called vertical
composition of 2-cells.
3. A family of compositions
â€¢B,ABC : B(B,C)Ã—B(A,B) â†’B(A,C) : (g, f) 7â†’gâ€¢ f
deï¬ned for any triple of objects A,B,C. This is a family of functors between hom-categories, and its
action on morphisms is called horizontal composition of natural transformations, that we denote
Î± â€¢Î².
4. For every object A âˆˆBo there is an arrow idA âˆˆB(A,A).
To this basic structure we add
1. a family of invertible maps Î±fgh : (f â€¢g)â€¢h âˆ¼= f â€¢(gâ€¢h) natural in all its arguments f,g,h, which
taken together form the associator isomorphisms;
2. a family of invertible maps Î» f : idB â€¢ f âˆ¼= f and Ïf : f â€¢idA âˆ¼= f natural in its component f : A â†’B,
which taken together form the left unitor and right unitor isomorphisms.
Finally, these data are subject to the following axioms.

Genovese, Herold, Loregian, Palombi
53
1. For every quadruple of 1-cells f,g,h,k we have that the diagram
((f â€¢g)â€¢h)â€¢k
Î±f,g,hâ€¢k

Î± fg,h,k / (f â€¢g)â€¢(hâ€¢k)
Î± f,g,hk / f â€¢(gâ€¢(hâ€¢k))
(f â€¢(gâ€¢h))â€¢k
Î± f,gh,k
/ f â€¢((gâ€¢h)â€¢k)
fâ€¢Î±g,h,k
O
commutes.
2. For every pair of composable 1-cells f,g,
(f â€¢idA)â€¢g
Ïf â€¢g
%
aA,idA,g
/ f â€¢(idA â€¢ g)
fâ€¢Î»g
y
f â€¢g
commutes.
Deï¬nition 2 (2-category). A 2-category is a bicategory where the associator and unitors are the identity
natural transformations. In other words, a 2-category is precisely a bicategory where horizontal composi-
tion is strictly associative, and the identities idA work as strict identities for the horizontal composition
operation.
Some sources call â€˜2-categoryâ€™ what we call a bicategory, and â€˜strict 2-categoryâ€™ what we call a 2-category.
Something similar happens for monoidal categories: a monoidal category is called strict if its associator
and left/right unitors are identity natural transformations. This is not by chance: a (strict) monoidal
category V is exactly a (strict) 2-category with a single object âˆ—(so that the category V can be identiï¬ed
with the category of endomorphisms of âˆ—).
Example 1.
â€¢ There is a 2-category Cat where 0-cells are small categories, and the hom categories Cat(C,D)
are the categories of functors and natural transformations. Composition of functors is strictly
associative and unital.
â€¢ There is a bicategory of profunctors, as deï¬ned in [15, 16] and [29, Ch. 5]. Composition of
profunctors is associative up to a canonical isomorphism.
â€¢ Every category C is trivially a 2-category by taking the 2-cells to be identities. This is sometimes
called the â€˜discreteâ€™ 2-category obtained from a category C .
â€¢ There is a 2-category where 0-cells are partially ordered sets (P,â‰¤), and where the category
Pos(P,Q) is the partially ordered set of monotone functions f : P â†’Q and pointwise order (f âª¯g
iff âˆ€p.f p â‰¤gp in Q). Composition is strictly associative and unital.
Remark 1. The fact that for every bicategory B the maps
âŠŸB,ABC : B(B,C)Ã—B(A,B) â†’B(A,C) : (g, f) 7â†’gâ€¢ f
are functors with domain a product category entails the following identity:

54
A Categorical Semantics for Hierarchical Petri Nets
Given any diagram of 2-cells like
A

 Î±
E
 Î²
/ B

 Î³
E
 Î´
/ C
we have that (Î´ â€¢Î²)â—¦(Î³ â€¢Î±) = (Î´ â—¦Î³)â€¢(Î² â—¦Î±). This is usually called the interchange law
in B.
Pseudofunctors and lax functors, deï¬ned below, are some of the most widely used notions of morphism
between bicategories. These are useful to parse the deep results on which Section 6 relies.
Deï¬nition 3 (Pseudofunctor, (co)lax functor). Let B,C be two bicategories; a pseudofunctor consists of
1. a function Fo : Bo â†’Co,
2. a family of functors FAB : B(A,B) â†’C (FA,FB),
3. an invertible 2-cell Âµfg : F f â—¦Fg â‡’F(fg) for each A
gâˆ’â†’B
fâˆ’â†’C, natural in f (with respect to
vertical composition) and an invertible 2-cell Î· : Î· f : idFA â‡’F(idA), also natural in f.
These data are subject to the following commutativity conditions for every 1-cell A â†’B:
F f â—¦idA
ÏF f
/
F fâˆ—Î·

F f
F(Ï f )

idB â—¦F f
Î·âˆ—F f

Î»F f
/ F f
F(Î»f )

F f â—¦F(idA)
Âµf,idA
/ F(f â—¦idA)
F(idB)â—¦F f
ÂµidB,f
/ F(idB â—¦f)
(F f â—¦Fg)â—¦Fh
Î±F f,Fg,Fh
/
Âµfgâˆ—Fh

F f â—¦(Fgâ—¦Fh)
F fâˆ—Âµgh

F(fg)â—¦Fh
Âµfgâˆ—Fh

F f â—¦F(gh)
Âµf,gh

F((fg)h)
FÎ± fgh
/ F(f(gh))
(we denote invariably Î±,Î»,Ï the associator and unitor of B,C ).
A lax functor is deï¬ned by the same data, but both the 2-cells Âµ : F f â—¦Fg â‡’F(fg) and Î· : idFA â‡’
F(idA) can be non-invertible; the same coherence diagrams in Deï¬nition 3 hold. A colax functor reverses
the direction of the cells Âµ,Î·, and the commutativity of the diagrams in Deï¬nition 3 changes accordingly.
Another notion that we will make heavy use of is the one of comonad. On the other hand, monads
and morphisms between them, called bimodules, will only appear in Theorem 1. We will only use a
straightforward consequence of this theorem, and the hurrying reader may not linger too much on these
deï¬nitions.
Deï¬nition 4 (Monad, comonad). Let C be a category; a monad on C consists of an endofunctor
T : C â†’C endowed with two natural transformations

Genovese, Herold, Loregian, Palombi
55
â€¢ Âµ : T â—¦T â‡’T, the multiplication of the monad, and
â€¢ Î· : idC â‡’T, the unit of the monad,
such that the following axioms are satisï¬ed:
â€¢ the multiplication is associative, i.e. the diagram
T â—¦T â—¦T
Tâˆ—Âµ
/
Âµâˆ—T

T â—¦T
Âµ

T â—¦T
Âµ
/ T
is commutative, i.e. the equality of natural transformations Âµ â—¦(Âµ âˆ—T) = Âµ â—¦(T âˆ—Âµ) holds;
â€¢ the multiplication has the transformation Î· as unit, i.e. the diagram
T
Î·âˆ—T / T â—¦T
Âµ

T
Tâˆ—Î·
o
T
is commutative, i.e. the equality of natural transformations Âµ â—¦(Î· âˆ—T) = Âµ â—¦(T âˆ—Î·) = idT holds.
Dually, let C be a category; a comonad on C consists of an endofunctor T : C â†’C endowed with two
natural transformations
â€¢ Ïƒ : T â‡’T â—¦T, the comultiplication of the comonad, and
â€¢ Îµ : T â‡’idC , the counit of the comonad,
such that the following axioms are satisï¬ed:
â€¢ the comultiplication is coassociative, i.e. the diagram
T â—¦T â—¦T oTâˆ—Ïƒ
O
Ïƒâˆ—T
T â—¦T
O
Ïƒ
T â—¦T o
Ïƒ
T
is commutative.
â€¢ the comultiplication has the transformation Îµ as counit, i.e. the diagram
T o
Îµâˆ—T T â—¦T
O
Ïƒ
T
/
Tâˆ—Îµ
T
is commutative.
Deï¬nition 5 (Bimodule). Given a bicategory B having ï¬nite colimits (in the 2-categorical sense of [27]),
deï¬ne the 2-category Mod(B) of bimodules as in [38, 2.19]:
â€¢ 0-cells are the monads in B;
â€¢ 1-cells T â†’S are bimodules, i.e. 1-cells H : C â†’D (assuming T is a monad on C, and S a monad
on D) equipped with suitable action maps: Ï : HT â†’H and Î» : SH â†’H satisfying suitable axioms
expressing the fact that T acts on the right over H, via Ï (resp., S acts on the left on H, va Î»);
â€¢ 2-cells are natural transformations Î± : H â‡’K : T â†’S compatible with the action maps.

56
A Categorical Semantics for Hierarchical Petri Nets
2.1
Categorical Petri nets
Having recalled some of the category theory we are going to use, we now summarize some needed
deï¬nitions underlying the study of Petri nets from a categorical perspective.
Notation 1. Let S be a set; a multiset is a function S â†’N. Denote with SâŠ•the set of multisets over S.
Multiset sum and difference (only partially deï¬ned) are deï¬ned pointwise and will be denoted with âŠ•and
âŠ–, respectively. The set SâŠ•together with âŠ•and the empty multiset is isomorphic to the free commutative
monoid on S.
Deï¬nition 6 (Petri net). A Petri net is a pair of functions T
s,t
âˆ’â†’SâŠ•for some sets T and S, called the set of
places and transitions of the net, respectively. s,t are called input and output functions, respectively, or
equivalently source and target.
A morphism of nets is a pair of functions f : T â†’T â€² and g : S â†’Sâ€² such that the following square
commutes, with gâŠ•: SâŠ•â†’Sâ€²âŠ•the obvious lifting of g to multisets:
SâŠ•
T
SâŠ•
Sâ€²âŠ•
T â€²
Sâ€²âŠ•
s
sâ€²
tâ€²
t
gâŠ•
gâŠ•
f
Petri nets and their morphisms form a category, denoted Petri. Details can be found in [31].
Deï¬nition 7 (Markings and ï¬rings). A marking for a net T
s,t
âˆ’â†’SâŠ•is an element of SâŠ•, representing a
distribution of tokens in the net places. A transition u is enabled in a marking M if M âŠ–s(u) is deï¬ned.
An enabled transition can ï¬re, moving tokens in the net. Firing is considered an atomic event, and the
marking resulting from ï¬ring u in M is M âŠ–s(u)âŠ•t(u). Sequences of ï¬rings are called executions.
The main insight of categorical semantics for Petri nets is that the information contained in a given
net is enough to generate a free symmetric strict monoidal category representing all the possible ways
to run the net. There are multiple ways to do this [34, 20, 21, 30, 1]. In this work, we embrace the
individual-token philosophy, where tokens are considered distinct and distinguishable and thus require the
category in Deï¬nition 8 to have non-trivial symmetries.
Deï¬nition 8 (Category of executions â€“ individual-token philosophy). Let N : T
s,t
âˆ’â†’SâŠ•be a Petri net. We
can generate a free symmetric strict monoidal category (FSSMC), F(N), as follows:
â€¢ The monoid of objects is the free monoid generated by S. Monoidal product of objects A,B is
denoted with AâŠ—B.
â€¢ Morphisms are generated by T: each u âˆˆT corresponds to a morphism generator (u,su,tu),
pictorially represented as an arrow su uâˆ’â†’tu; morphisms are obtained by considering all the formal
(monoidal) compositions of generators and identities.
A detailed description of this construction can be found in [30].
In this deï¬nition, objects represent markings of a net. For instance, the object A âŠ•A âŠ•B means â€œtwo
tokens in A and one token in Bâ€. Morphisms represent executions of a net, mapping markings to markings.
A marking is reachable from another one if and only if there is a morphism between them. An example is
provided in Fig. 1.

Genovese, Herold, Loregian, Palombi
57
p1
t
p2
v
u
p3
p4
p1
t
â–²
p2
v
u
p3
p4
p1
t
p2
v
â–¼
u
p3
p4
p1
t
p2
v
u
â–¼
p3
p4
t
v
u
p1
p2
p3
p3
p2
p3
p4
p3
p4
p2
p4
p3
Figure 1: Graphical representation of a netâ€™s execution.
3
Hierarchical nets
Now we introduce the main object of study of the paper, hierarchical nets. As we pointed out in Section 1,
there are many different ways to model hierarchy in Petri nets [26], often incompatible with each other. We
approach the problem from a developerâ€™s perspective, wanting to model the idea that â€œï¬ring a transitionâ€
amounts to call another process and waiting for it to ï¬nish. This is akin to calling subroutines in a piece of
code. Moreover, we do not want to destroy the decidability of the reachability relation for our nets [17],
as it happens for other hierarchical models such as the net-within-nets framework [28]. We consider this
to be an essential requirement for practical reasons.
We will postpone any formal deï¬nition to Section 5. In the present work, we focus on giving an
intuitive explanation of what our requirements are.
Figure 2: A hierarchical net.
Looking at the net in Fig. 2, we see a net on the top, which we call parent. To each transition of the
parent net is attached another net, which we call child. Transitions can only have one child, but the parent
net may have multiple transitions, and hence multiple children overall. Connecting input and output
places of a transition in the parent net with certain places in the corresponding child, we can represent the

58
A Categorical Semantics for Hierarchical Petri Nets
orchestration by saying that each time a transition in the parent net ï¬res, its input tokens are transferred to
the corresponding child net, that takes them across until they reach a place connected with the output place
in the parent net. This way, the atomic act of ï¬ring a transition in the parent net results in an execution of
the corresponding child.
Figure 3: Replacing transitions in the parent net of Fig. 2 with its children.
Notice that we are not interested in considering the semantics of such hierarchical net to be akin to the
one in Fig. 3, where we replaced transitions in the parent net with their corresponding children. Indeed,
this way of doing things is similar to what happens in [32]: In this model, transitions in the parent net
are considered as placeholders for the children nets. There are two reasons why we distance ourselves
from this approach: First, we want to consider transition ï¬rings in the parent net as atomic events, and
replacing nets as above destroys this property. Secondly, such replacement is not so conceptually easy
given that we do not impose any relationship between the parent netâ€™s topologies and its children. Indeed,
the leftmost transition of the parent net in Fig. 2 consumes two inputs, while the corresponding leftmost
transition in its child only takes one. How do we account for this in specifying rewriting-based semantics
for hierarchical nets?
4
Local semantics for Petri nets
We concluded the last section pointing out reasons that make deï¬ning a semantics for hierarchical nets
less intuitive than one would initially expect. Moreover, requiring the transition ï¬rings in the parent net to
be considered as atomic events basically rules out the majority of the previous approaches to hierarchical
Petri nets, as the one sketched in [26, 32]. Embracing an engineering perspective, we could get away
with some ad-hoc solution to conciliate that parent and child net topologies are unrelated. One possible
way, for instance, would be imposing constraints between the shapes of the parent net and its children.
However, in deï¬ning things ad-hoc, the possibility for unforeseen corner cases and situations we do not
know how to deal with becomes high. To avoid this, we embrace a categorical perspective and deï¬ne
things up to some degree of canonicity.
Making good use of the categorical work already carried out on Petri nets, our goal is to leverage it
and get to a plausible deï¬nition of categorical semantics for hierarchical nets. Our strategy is to consider
a hierarchical net as an extension of a Petri net: The parent net will be the Petri net we extend, whereas
the children nets will be encoded in the extension.
This is precisely the main idea contained in [24], that is, the idea of describing net extensions with
different varieties of monoidal functors. Indeed, we intend to show how the theory presented in [24], and
initially serving a wholly different purpose, can be reworked to represent hierarchical nets with minimal
effort.
As for semantics, we will use strict monoidal functors and name it local because the strict-monoidality
requirement amounts to endow tokens with properties that cannot be shared with other tokens. To
understand this choice of naming a little bit better, it may be worth comparing it with the notion of
non-local semantics, deï¬ned in terms of lax-monoidal-lax functors, that we gave in [23].

Genovese, Herold, Loregian, Palombi
59
Deï¬nition 9 (Local semantics for Petri nets). Given a strict monoidal category S , a Petri net with a local
S -semantics is a pair
 N,Nâ™¯
, consisting of a Petri net N and a strict monoidal functor
Nâ™¯: F(N) â†’S .
A morphism F :
 M,Mâ™¯
â†’
 N,Nâ™¯
is just a strict monoidal functor F : F(M) â†’F(N) such that Mâ™¯=
F #Nâ™¯, where we denote composition in diagrammatic order; i.e. given f : c â†’d and g: d â†’e, we denote
their composite by (f #g): c â†’e.
Nets equipped with S -semantics and their morphisms form a monoidal category denoted PetriS ,
with the monoidal structure arising from the product in Cat.
In [24], we used local semantics to describe guarded Petri nets, using Span as our category of choice. We
brieï¬‚y summarize this, as it will become useful later.
Deï¬nition 10 (The category Span). We denote by Span the 1-category of sets and spans, where isomor-
phic spans are identiï¬ed. This category is symmetric monoidal. From now on, we will work with the
strictiï¬ed version of Span, respectively.
Notation 2. Recall that a morphism A â†’B in Span consists of a set S and a pair of functions A â†S â†’B.
When we need to extract this data from f, we write
A
f1
â†âˆ’Sf
f2
âˆ’â†’B
We sometimes consider the span as a function f : Sf â†’AÃ—B, thus we may write f(s) = (a,b) for s âˆˆSf
with f1(s) = a and f2(s) = b.
Deï¬nition 11 (Guarded nets with side effects). A guarded net with side effects is an object of PetriSpan.
A morphism of guarded nets with side effects is a morphism in PetriSpan.
Example 2. Let us provide some intuition behind the deï¬nition of PetriSpan.
Given a net N, its places (generating objects of F(N)) are sent to sets. Transitions (generating
morphisms of F(N)) are mapped to spans. Spans can be understood as relations with witnesses, provided
by elements in the apex of the span: Each path from the span domain to its codomain is indexed by some
element of the span apex, as it is shown in Fig. 4. Witnesses allow considering different paths between
the same elements. These paths represent the actions of processing the property a token is enowed with
according to some side effect. Indeed, an element in the domain can be sent to different elements in the
codomain via different paths. We interpret this as non-determinism: the ï¬ring of the transition is not only
a matter of the tokens input and output; it also includes the chosen path, which we interpret as having
side-effects interpreted outside of our model.
In Fig. 4 the composition of paths is the empty span: Seeing things from a reachability point of view, the
process given by ï¬ring the left transition and then the right will never occur. This is because the rightmost
transition has a guard that only accepts yellow tokens, so that a green token can never be processed by it.
This is witnessed by the fact that there is no path connecting the green dot with any dot on its right. The
relation with reachability can be made precise by recasting Deï¬nition 8.
Deï¬nition 12 (Markings for guarded nets). Given a guarded Petri net with side effects
 N,Nâ™¯
, a marking
for
 N,Nâ™¯
is a pair (X,x) where X is an object of F(N) and x âˆˆNâ™¯X. We say that a marking (Y,y)
is reachable from (X,x) if there is a morphism f : X â†’Y in F(N) and an element s âˆˆSf such that
Nâ™¯f(s) = (x,y).

60
A Categorical Semantics for Hierarchical Petri Nets
s1
s2
s3
z2
z1
Figure 4: Semantics in Span
5
Semantics for hierarchical nets
In the span semantics we can encode externalities in the tips of the spans to which we send transitions.
That is, given a bunch of tokens endowed with some properties, to ï¬re a transition, we need to provide a
witness that testiï¬es how these properties have to be handled. The central intuition of this paper is that
we can use side effects to encode the runs of some other net: To ï¬re a transition in the parent net, we
need to provide a trace of the corresponding child net. So we are saying that to ï¬re a transition in the
parent net, a valid execution of the corresponding child net must be provided. Relying on the results
in Section 2, we know that such valid executions are exactly the morphims in the free symmetric strict
monoidal category generated by the child net. Putting everything together, we want the tips of our spans
to â€œrepresentâ€ morphisms in the monoidal categories corresponding to the children nets. The following
result makes this intuition precise, explaining how monoidal categories and spans are related:
Theorem 1 ([38, Section 2.4.3]). Given a category A with ï¬nite limits, a category internal in A is a
monad in Span(A). Categories are monads in Span, whereas strict monoidal categories are monads
in Span(Mon), with Mon being the category of monoids and monoid homomorphisms. A symmetric
monoidal category is a bimodule in Span(Mon).
It is worth pointing out, at least intuitively, how this result works: Given a category C , we denote with C â€¢
and C â†’the sets1 of objects and morphisms of C , respectively. Then we can form a span:
C â€¢
dom
â†âˆ’âˆ’C â†’cod
âˆ’âˆ’â†’C â€¢
where the legs send a morphism to its domain and codomain, respectively. This is clearly not enough,
since in a category we have a notion of identity and composition, but asking for a monad provides exactly
this. For instance, the monad multiplication in this setting becomes a span morphism
C â†’Ã—C â€¢ C â†’
C â†’
C â†’
C â€¢
C â€¢
C â€¢
dom
cod
dom
cod
âŒ
monad multiplication
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’
C â†’
C â€¢
C â€¢
dom
cod
which gives composition of arrows. Similarly, the monad unit singles out identities, and the monad laws
witness the associativity and identity laws. In a similar way, monoidal categories are represented as above,
1Here we are assuming that the objects and morphisms of our categories arenâ€™t proper classes. This assumption is harmless in
our context unless one wants to consider a Petri net whose places and transitions, respectively, form a proper class.

Genovese, Herold, Loregian, Palombi
61
but we furthermore require C â€¢ and C â†’to be endowed with a monoid structure (representing the action
of the monoidal structure on the objects and morphisms of C , respectively), and that this structure is
preserved by the span legs, while the bimodule structure on top of the monad witnesses the monoidal
symmetries.
For the scope of our applications, we remember that each Petri net N generates a free symmetric strict
monoidal category F(N), which will correspond to a bimodule in Span(Mon). So, in particular, we have
a span of monoids2
Nâ€¢
dom
â†âˆ’âˆ’Nâ†’cod
âˆ’âˆ’â†’Nâ€¢
underlying a bimodule, with Nâ€¢ and Nâ†’, representing the objects and arrows of the category, respectively,
both free. We will refer to such a span as the FSSMC N (in Span(Mon)).
Deï¬nition 13 (Hierarchical nets â€“ External deï¬nition). A hierarchical net is a functor F(N) â†’Span(Mon)
deï¬ned as follows:
â€¢ Each generating object A of F(N) is sent to a set FA, aka the set of accepting states for the place A.
â€¢ Each generating morphism A
fâˆ’â†’B is sent to a span with the following shape:
(â–¶f Ã—Nâ€¢
f dom f )Ã—Nâ†’
f (codf Ã—Nâ€¢
f â– f )
(â–¶f Ã—Nâ€¢
f domf )
(codf Ã—Nâ€¢
f â– f )
FA
Nâ†’
f
FB
FA
Nâ€¢
f
Nâ€¢
f
FB
â–¶f
domf
codf
â– f
âŒ
âŒ
âŒ
The FSSMC Nf at the center of the span is called the child net associated to f; the morphisms â–¶f
and â– f are called play Nf and stop Nf , respectively.
Unrolling the deï¬nition, we are associating to each generating morphism of f of F(N) â€“ the parent net
â€“ a FSSMC Nf â€“ the child net. As the feet of the spans corresponding to the child nets will, in general,
be varying with the net themselves, we need to pre and post-compose them with other spans to ensure
composability: â–¶f and â– f represent morphisms that select the initial and accepting states of Nf , that
is, markings of Nf in which the computation starts, and markings of Nf in which the computation is
considered as concluded. Notice how this also solves the problems highlighted in Section 3, as â–¶f and
â– f mediate between the shape of inputs/outputs of the transition f and the shape of Nf itself.
Remark 2. Interpreting markings as in Deï¬nition 12, We see that to ï¬re f in the parent net we need to
provide a triple (a,x,b), where:
â€¢ a is an element of FA, witnessing that the tokens in the domain of f are a valid initial state for Nf .
â€¢ x is an element of Nâ†’
f , that is, a morphism of Nf , and hence an execution of the child net. This
execution starts from the marking â–¶f a and ends in the marking â– f b.
â€¢ b is an element of FB, witnessing that the resulting state of the execution x is accepting, and can be
lifted back to tokens in the codomain of f.
2We are abusing notation, and writing Nâ€¢, Nâ†’in place of F(N)â€¢, F(N)â†’, respectively.

62
A Categorical Semantics for Hierarchical Petri Nets
Deï¬nition 14 (Category of hierarchical Petri nets). Nets
 N,Nâ™¯
in the category PetriSpan with Nâ™¯having
the shape of Deï¬nition 13 form a subcategory, denoted with Petri , and called the category of hierarchical
Petri nets.
Remark 3. Using the obvious forgetful functor Mon â†’Set we obtain a functor Span(Mon) â†’Span,
which allows to recast our non-local semantics in a more liberal setting. In particular, we could send a
transition to spans whose components are subsets of the monoids heretofore considered. We could select
only a subset of the executions/states of the child net as valid witnesses to ï¬re a transition in the parent.
Everything we do in this work will go through smoothly, but we consider this approach less elegant;
thus, we will not mention it anymore.
6
Internalization
In Section 5 we deï¬ned hierarchical nets as nets endowed with a speciï¬c kind of functorial semantics
to Span. As things stand now, Petri nets correspond to categories, while hierarchical nets correspond to
functors. This difference makes it difï¬cult to say what a Petri net with multiple levels of hierarchy is:
intuitively, it is easy to imagine that the children of a parent net N can be themselves parents of other nets,
which are thus â€œgrandchildrenâ€ of N, and so on and so forth.
In realizing this, we are blocked by having to map N to hierarchical nets, which are functors and not
categories. To make such an intuition viable, we need a way to internalize the semantics in Deï¬nition 13
to obtain a category representing the executions of the hierarchical net.
Luckily, there is a way to turn functors into categories, which relies on an equivalence between the slice
2-category over a given category C , denoted Cat/C , and the 2-category of lax-functors C â†’Span [33].
This is itself the â€œ1-truncatedâ€ version of a more general equivalence between the slice of Cat over C ,
and the 2-category of lax normal functors to the bicategory Prof of profunctors (this has been discovered
by BÂ´enabou [13]; a fully worked out exposition, conducted in full detail, is in [29]).
Here, we gloss over these abstract motivations and just give a very explicit deï¬nition of what this
means, as what we need is just a particular case of the construction we worked out for guarded nets in [24].
Deï¬nition 15 (Internalization). Let
 M,Mâ™¯
âˆˆPetri
be a hierarchical net. We deï¬ne its internalization,
denoted
R Mâ™¯, as the following category:
â€¢ The objects of
R Mâ™¯are pairs (X,x), where X is an object of F(M) and x is an element of Mâ™¯X.
Concisely:
Obj(
R Mâ™¯) :=

(X,x)
(X âˆˆObj F(M))âˆ§(x âˆˆMâ™¯X)
	
.
â€¢ A morphism from (X,x) to (Y,y) in
R Mâ™¯is a pair (f,s) where f : X â†’Y in F(M) and s âˆˆSMâ™¯f in
the apex of the corresponding span that connects x to y. Concisely:
HomR Mâ™¯[(X,x),(Y,y)] :=
:=
n
(f,s)
(f âˆˆHomF(M) [X,Y])âˆ§(s âˆˆSMâ™¯f )âˆ§(Mâ™¯f(s) = (x,y))
o
.
The category
R Nâ™¯, called the Grothendieck construction applied to Nâ™¯, produces a place for each element
of the set we send a place to, and makes a transition for each path between these elements, as shown in
Figure 5.

Genovese, Herold, Loregian, Palombi
63
â‡
Figure 5: The Grothendieck construction applied to Nâ™¯.
Notice that in Fig. 5, on the left, each path between coloured dots is a triple (a,x,b) as in Remark 2.
This amounts to promote every possible trace of the child net â€“ together with a selection of initial and
accepting states â€“ to a transition in the parent net. This interpretation is justiï¬ed by the following theorem,
which we again proved in [24]:
Theorem 2. Given any strict monoidal functor F(N) Nâ™¯
âˆ’â†’Span, the category
R Nâ™¯is symmetric strict
monoidal, and free. Thus
R Nâ™¯can be written as F(M) for some net M.
Moreover, we obtain a projection functor
R Nâ™¯â†’F(N) which turns
R into a functor, in that for each
functor F :
 M,Mâ™¯
â†’
 N,Nâ™¯
there exists a functor bF making the following diagram commute:
R Mâ™¯
F(M)
R Nâ™¯
F(N)
Span
Ï€M
Ï€N
F
bF
Mâ™¯
Nâ™¯
Theorem 2 deï¬nes a functor PetriSpan â†’FSSMC, the category of FSSMCs and strict monoidal functors
between them. As Petri
is a subcategory of PetriSpan, we can immediately restrict Theorem 2 to
hierarchical nets. A net in the form
R Nâ™¯for some hiearchical net
 N,Nâ™¯
is called the internal categorical
semantics for N (compare this with Deï¬nition 13, which we called external).
Remark 4. Notice how internalization is very different from just copy-pasting a child net in place of a
transition in the parent net as we discussed in Section 3. Here, each execution of the child net is promoted
to a transition, preserving the atomicity requirement of transitions in the parent net.
Clearly, now we can deï¬ne hierarchical nets with a level of hierarchy higher than two by just mapping a
generator f of the parent net to a span where Nf is in the form
R Nâ™¯for some other hierarchical nets N,
and the process can be recursively applied any ï¬nite number of times for each transition.
7
Engineering perspective
We deem it wise to spend a few words on why we consider this way of doing things advantageous from an
applicative perspective. Petri nets have been considered as a possible way of producing software for a long
time, with some startups even using them as a central tool in their product offer [35]. Providing some form

64
A Categorical Semantics for Hierarchical Petri Nets
of hierarchical calling is needed to make the idea of â€œPetri nets as a programming language/general-purpose
design toolâ€ practical.
Our deï¬nition of hierarchy has the advantage of not making hierarchical nets more expressive than
Petri nets. If this seems like a downside, notice that a consequence of this is that decidability of any
reachability-related question is exactly as for Petri nets, which is a great advantage from the point of view
of model checking. The legitimacy of this assertion is provided by internalization, that allows us to reduce
hierarchical nets back to Petri nets. A further advantage of this is that we can use already widespread tools
for reachability checking [37] to answer reachability questions for our hierarchical nets, without having
necessarily to focus on producing new ones.
Moreover, and more importantly, our span formalism works really well in modelling net behaviour in a
distributed setting. To better understand this, imagine an infrastructure where each Petri net is considered
as a smart contract (as it would be, for instance, if we were to implement nets as smart contracts on a
blockchain). A smart contract is nothing more than a piece of code residing at a given address. Interaction
with smart contracts is transactional: One sends a request to the contract address with some data to be
processed (for example a list of functions to be called on some parameters). The smart contract executes
as per the transaction and returns the data processed.
In our Petri net example things do not change: A user sends a message consisting of a net address, the
transaction the user intends to ï¬re, and some transaction data. The infrastructure replies afï¬rmatively or
negatively if the transaction can be ï¬red, which amounts to accept or reject the transaction. As we already
stressed, this is particularly suitable for blockchain-related contexts and it is how applications such as [36]
implement Petri nets in their services.
dbbfe69836
t1
832344009d
dbbfe69836
t1
832344009d
from:
dbbfe69836
to:
832344009d
command:
t1
data:
from:
832344009d
to:
dbbfe69836
command:
OK
data:
Figure 6: In this diagram we describe the interaction between a user and a net, with downward pointing
arrows representing the ï¬‚ow of time. The user, having id dbbfe69836, sends a request to a net having
address 832344009d. The user is requesting to ï¬re transition t1 in the net. As the transition is enabled
and able to ï¬re, the request is granted, the state of the net updated, and a reply to the user is sent.
From this point of view, a hierarchical net would work exactly as a standard Petri net, with the
exception that in sending a transaction to the parent net, the user also has to specify, in the transaction
data, a proper execution of the child net corresponding to the ï¬ring transition.
Again, from a smart contract standpoint, this means that the smart contract corresponding to the
parent net will call the contract corresponding to the child net with some execution data, and will respond

Genovese, Herold, Loregian, Palombi
65
dbbfe69836
t1
832344009d
u1
u2
2f9b1ee0dc
u1
u2
2f9b1ee0dc
u1
u2
2f9b1ee0dc
dbbfe69836
t1
832344009d
from:
dbbfe69836
to:
832344009d
command:
t1
data:u1 #u2
from:
832344009d
to:
2f9b1ee0dc
command:
u1 #u2
data:
from:
2f9b1ee0dc
to:
832344009d
command:
OK
data:
from:
832344009d
to:
dbbfe69836
command:
OK
data:
Figure 7: In this diagram we describe the interaction between a user and a hierarchical net. This time the
user, having id dbbfe69836, sends a request to a net having address 832344009d. This net is hierarchical,
so in calling transition t1 in the parent net, the user has also to provide a valid execution for its child.
This is provided as transaction data, in this case u1 #u2. The parent net stores the address to the child net
corresponding to t1, which in this case is 2f9b1ee0dc. The request to ï¬re u1 and then u2 is forwarded
to 2f9b1ee0dc, which changes its state and responds afï¬rmatively. This means that 832344009d can
itself change its state and respond afï¬rmatively to dbbfe69836. Should any of these steps fail, the entire
transaction is rejected and each net reverts to its previous state.
afï¬rmatively to the user only if the generated call resolves positively.
Recalling the results in previous sections of this work, all the possible ways of executing the contracts
above form a category, which is obtained by internalizing the hierarchical net via Theorem 2. Internalized
categories being free, they are presented by Petri nets, which we can feed to any mainstream model
checker. Now, all sorts of questions about liveness and interaction of the contracts above can be analyzed
by model-checking the corresponding internalized net. This provides an easy way to analyze complex
contract interaction, relying on tools that have been debugged and computationally optimized for decades.
8
Conclusion and future work
In this work, we showed how a formalism for guarded nets already worked out in [24] can be used to
deï¬ne the categorical semantics of some particular variety of hierarchical nets, which works particularly
well from a model-checking and distributed-implementation point of view. Our effort is again part of a
more ample project focusing on characterizing the categorical semantics of extensions of Petri nets by

66
A Categorical Semantics for Hierarchical Petri Nets
studying functors from FSSMCs to spans [23, 22].
As a direction of future work, we would like to obtain a cleaner way of describing recursively
hierarchical nets. In this work, we relied on the Grothendieck construction to internalize a hierarchical
net, so that we could use hierarchical nets as children of some other another parent net, recursively. This
feels a bit like throwing all the carefully-typed information that the external semantics gives into the same
bucket, and as such it is a bit unsatisfactory. Ideally, we would like to get a fully external semantics for
recursively hierarchical nets, and generalize the internalization result to this case.
Another obvious direction of future work is implementing the ï¬ndings hereby presented, maybe
relying on some formally veriï¬ed implementation of category theory such as [19].
Acknowledgements
Being non-native speakers, we want to thank John Baez for pointing out that the
correct spelling in English was â€œHierarchical Petri netsâ€ and not â€œHierarchic Petri netsâ€ as we thought.
We also want to thank G. Pasquini and M. De Jorio for having inspired this work.
A video presentation of this paper can be found on Youtube at 4v5v8tgmiUM.
References
[1] John C. Baez, Fabrizio Genovese, Jade Master & Michael Shulman (2021): Categories of Nets. In: 36th
Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2021, Rome, Italy, June 29 - July 2,
2021, IEEE, pp. 1â€“13, doi:10.1109/LICS52264.2021.9470566.
[2] John C. Baez & Jade Master (2020): Open Petri nets. Mathematical Structures in Computer Science 30(3), p.
314â€“341, doi:10.1017/S0960129520000043.
[3] P. Baldan, M. Bocci, D. Brigolin, N. Cocco, M. Heiner & M. Simeoni (2018): Petri nets for modelling and
analysing trophic networks. Fundamenta Informaticae 160(1-2), pp. 27â€“52, doi:10.3233/FI-2018-1673.
[4] P. Baldan, F. Bonchi, F. Gadducci & G.V. Monreale (2014): Encoding synchronous interactions using
labelled Petri nets. In: International Conference on Coordination Languages and Models, Springer, pp. 1â€“16,
doi:10.1007/978-3-662-43376-8 1.
[5] P. Baldan, F. Bonchi, F. Gadducci & G.V. Monreale (2015): Asynchronous Traces and Open Petri Nets. In:
Programming Languages with Applications to Biology and Security, Springer, pp. 86â€“102, doi:10.1007/978-3-
319-25527-9 8.
[6] P. Baldan, F. Bonchi, F. Gadducci & G.V. Monreale (2015): Modular encoding of synchronous and
asynchronous interactions using open Petri nets. Science of Computer Programming 109, pp. 96â€“124,
doi:10.1016/j.scico.2014.11.019.
[7] P. Baldan, N. Cocco, F. De Nes, M.L. Segura & M. Simeoni (2011): MPath2PN-Translating metabolic
pathways into Petri nets. In: BioPPN2011 Int. Workshop on Biological Processes and Petri Nets, CEUR
Workshop Proceedings, 724, pp. 102â€“116.
[8] P. Baldan, A. Corradini, H. Ehrig & R. Heckel (2001): Compositional modeling of reactive systems using open
nets. In: International Conference on Concurrency Theory, Springer, pp. 502â€“518, doi:10.1007/3-540-44685-
0 34.
[9] P. Baldan, A. Corradini, H. Ehrig & B. KÂ¨onig (2008): Open Petri nets: Non-deterministic processes and com-
positionality. In: International Conference on Graph Transformation, Springer, pp. 257â€“273, doi:10.1007/978-
3-540-87405-8 18.
[10] P. Baldan, A. Corradini, F. Gadducci & U. Montanari (2010): From Petri nets to graph transformation systems.
Electronic Communications of the EASST 26, doi:10.14279/tuj.eceasst.26.368.

Genovese, Herold, Loregian, Palombi
67
[11] P. Baldan, A. Corradini & U. Montanari (2005): Relating SPO and DPO graph rewriting with Petri nets
having read, inhibitor and reset arcs. Electronic Notes in Theoretical Computer Science 127(2), pp. 5â€“28,
doi:10.1016/j.entcs.2005.02.003.
[12] P. Baldan & F. Gadducci (2019): Petri nets are dioids: a new algebraic foundation for non-deterministic net
theory. Acta Informatica 56(1), pp. 61â€“92, doi:10.1007/s00236-018-0314-0.
[13] J. BÂ´enabou: Introduction to Bicategories, pp. 1â€“77. 47, Springer Berlin Heidelberg, doi:10.1007/BFb0074299.
[14] P. Buchholz (1994): Hierarchical High Level Petri Nets for Complex System Analysis. In: Application and
Theory of Petri Nets, doi:10.1007/3-540-58152-9 8.
[15] J. BÂ´enabou & T. Streicher (2000): Distributors at work. Lecture notes written by Thomas Streicher.
[16] G. L. Cattani & G. Winskel (2005): Profunctors, open maps and bisimulation. Mathematical Structures in
Computer Science 15(03), pp. 553â€“614, doi:10.1017/S0960129505004718.
[17] J. Esparza & N. Mogens (1994): Decidability Issues for Petri Nets - a survey. J. Inf. Process. Cybern. 30(3),
pp. 143â€“160.
[18] R. Fehling (1991): A concept of hierarchical Petri nets with building blocks. In: International Conference on
Application and Theory of Petri Nets, Springer, pp. 148â€“168, doi:10.1007/3-540-56689-9 43.
[19] F. Genovese, A. Gryzlov, J. Herold, A. Knispel, M. Perone, E. Post & A. Videla: Idris-Ct: A Library to Do
Category Theory in Idris. Available at http://arxiv.org/abs/1912.06191.
[20] F. Genovese, A. Gryzlov, J. Herold, M. Perone, E. Post & A. Videla: Computational Petri Nets: Adjunctions
Considered Harmful. Available at http://arxiv.org/abs/1904.12974.
[21] F. Genovese & J. Herold: Executions in (Semi-)Integer Petri Nets Are Compact Closed Categories 287, pp.
127â€“144. doi:10.4204/EPTCS.287.7.
[22] F. Genovese, F. Loregian & D. Palombi: A Categorical Semantics for Bounded Petri Nets. Available at
http://arxiv.org/abs/2101.09100.
[23] F. Genovese, F. Loregian & D. Palombi: Nets with Mana: A Framework for Chemical Reaction Modelling,
doi:10.1007/978-3-030-78946-6 10. Available at http://arxiv.org/abs/2101.06234.
[24] F. Genovese & D.I. Spivak: A Categorical Semantics for Guarded Petri Nets. In F. Gadducci & Timo Kehrer,
editors: Graph Transformation, Lecture Notes in Computer Science 12150, Springer International Publishing,
pp. 57â€“74, doi:10.1007/978-3-030-51372-6 4.
[25] P. Huber, K. Jensen & R.M. Shapiro (1989): Hierarchies in coloured Petri nets. In: International Conference
on Application and Theory of Petri Nets, Springer, pp. 313â€“341, doi:10.1007/978-3-662-06289-0 3.
[26] K. Jensen & L.M. Kristensen: Coloured Petri Nets. Springer Berlin Heidelberg, doi:10.1007/BFb0046842.
[27] G.M. Kelly (1989): Elementary observations on 2-categorical limits. Bulletin of the Australian Mathematical
Society 39, pp. 301â€“317, doi:10.1017/S0004972700002781.
[28] M. KÂ¨ohler-BuÃŸmeier: A Survey of Decidability Results for Elementary Object Systems (1), pp. 99â€“123.
doi:10.3233/FI-2014-983.
[29] F. Loregian (2021): Coend Calculus. London Mathematical Society Lecture Note Series 468, Cambridge
University Press. ISBN 9781108746120.
[30] J. Master: Petri Nets Based on Lawvere Theories 30(7), pp. 833â€“864. doi:10.1017/S0960129520000262.
[31] J. Meseguer & U. Montanari: Petri Nets Are Monoids 88(2), pp. 105â€“155. doi:10.1016/0890-5401(90)90013-8.
[32] H. Oswald, R. Esser & R. Mattmann (1990): An environment for specifying and executing hierarchical Petri
nets. In: [1990] Proceedings. 12th International Conference on Software Engineering, IEEE, pp. 164â€“172,
doi:10.5555/100296.100319.
[33] D. PavloviÂ´c & S. Abramsky: Specifying Interaction Categories. In Eugenio Moggi & Giuseppe Rosolini,
editors: Category Theory and Computer Science, Lecture Notes in Computer Science 1290, Springer Berlin
Heidelberg, pp. 147â€“158, doi:10.5555/648335.755738.

68
A Categorical Semantics for Hierarchical Petri Nets
[34] V. Sassone: On the Category of Petri Net Computations. In: TAPSOFT â€™95: Theory and Practice of Software
Development, 915, Springer Berlin Heidelberg, pp. 334â€“348, doi:10.1007/3-540-59293-8 205.
[35] Statebox Team: The Mathematical Speciï¬cation of the Statebox Language. Available at http://arxiv.org/
abs/1906.07629.
[36] Statebox Team: Statebox, Compositional Diagrammatic Programming Language. Available at https:
//statebox.org.
[37] University of Torino: GreatSPN Github Page. Available at https://github.com/greatspn/SOURCES.
[38] F. Zanasi: Interacting Hopf Algebras: The Theory of Linear Systems. Available at http://arxiv.org/abs/
1805.03032.

