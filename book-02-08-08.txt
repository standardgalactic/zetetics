Sp
ecifying
Systems
First
Prin
ting
V
ersion
of
18
June
2002


Sp
ecifying
Systems
The
TLA+
Language
and
T
o
ols
for
Hardw
are
and
Soft
w
are
Engineers
Leslie
Lamp
ort
Microsoft
Researc
h
Boston

San
F
rancisco

New
Y
ork

T
oron
to

Mon
treal
London

Munic
h

P
aris

Madrid
Cap
eto
wn

Sydney

T
oky
o

Singap
ore

Mexico
Cit
y

Man
y
of
the
designations
used
b
y
man
ufacturers
and
sellers
to
distinguish
their
pro
ducts
are
claimed
as
trademarks.
Where
those
designations
app
ear
in
this
b
o
ok,
and
Addison-W
esley
w
as
a
w
are
of
a
trademark
claim,
the
designations
ha
v
e
b
een
prin
ted
with
initial
capital
letters
or
in
all
capitals.
The
author
and
publisher
ha
v
e
tak
en
care
in
the
preparation
of
this
b
o
ok,
but
mak
e
no
expressed
or
implied
w
arran
t
y
of
an
y
kind
and
assume
no
resp
onsibilit
y
for
errors
or
omissions.
No
liabilit
y
is
assumed
for
inciden
tal
or
consequen
tial
damages
in
connection
with
or
arising
out
of
the
use
of
the
information
or
programs
con
tained
herein.
The
publisher
oers
discoun
ts
on
this
b
o
ok
when
ordered
in
quan
tit
y
for
sp
ecial
sales.
F
or
more
information,
please
con
tact:
U.S.
Corp
orate
and
Go
v
ernmen
t
Sales
(800)
382-3419
corpsales@p
earson
tec
hgroup.com
F
or
sales
outside
of
the
U.S.,
please
con
tact:
In
ternational
Sales
(317)
581-3793
in
ternational@p
earson
tec
hgroup.com
Visit
Addison-W
esley
on
the
W
eb:
www.awpr
ofessional.c
om
Libr
ary
of
Congr
ess
Catalo
ging-in-Public
ation
Data
Lamp
ort,
Leslie
Sp
ecifying
systems
:
the
TLA+
language
and
to
ols
for
hardw
are
and
soft
w
are
engineers
/
Leslie
Lamp
ort.
p.
cm.
Includes
bibliographical
references
and
index.
ISBN
0-321-14306-X
(alk.
pap
er)
1.
System
design.
2.
Computer
systems{Sp
ecications.
3.
Logic,
sym
b
olic
and
mathematical.
I.
Title.
QA76.9.S88
L35
2003
2002074369
004.2
0
1--dc21
Cop
yrigh
t
c

2003
b
y
P
earson
Education,
Inc
All
righ
ts
reserv
ed.
No
part
of
this
publication
ma
y
b
e
repro
duced,
stored
in
a
re-
triev
al
system,
or
transmitted,
in
an
y
form,
or
b
y
an
y
means,
electronic,
mec
hanical,
photo
cop
ying,
recording,
or
otherwise,
without
the
prior
consen
t
of
the
publisher.
Prin
ted
in
the
United
States
of
America.
Published
sim
ultaneously
in
Canada.
F
or
information
on
obtaining
p
ermission
for
use
of
material
from
this
w
ork,
please
submit
a
written
request
to:
P
earson
Education,
Inc.
Righ
ts
and
Con
tracts
Departmen
t
75
Arlington
Street,
Suite
300
Boston,
MA
02116
F
ax:
(617)
848-7047
ISBN
0-321-14306-X
T
ext
prin
ted
on
recycled
pap
er
1
2
3
4
5
6
7
8
9
10-MA-0605040302
First
printing,
July
2002

T
o
Ellen


This
whole
b
o
ok
is
but
a
dr
aught|nay,
but
the
dr
aught
of
a
dr
aught.
Herman
Melville


Con
ten
ts
List
of
Figures
and
T
ables
xv
Ac
kno
wledgmen
ts
xvii
In
tro
duction
1
P
art
I
Getting
Started
5
1
A
Little
Simple
Math
9
1.1
Prop
ositional
Logic
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
9
1.2
Sets
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
11
1.3
Predicate
Logic
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
12
1.4
F
orm
ulas
and
Language
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
14
2
Sp
ecifying
a
Simple
Clo
c
k
15
2.1
Beha
viors
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
15
2.2
An
Hour
Clo
c
k
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
15
2.3
A
Closer
Lo
ok
at
the
Sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
18
2.4
The
Sp
ecication
in
TLA
+
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
19
2.5
An
Alternativ
e
Sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
21
3
An
Async
hronous
In
terface
23
3.1
The
First
Sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
24
3.2
Another
Sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
28
3.3
T
yp
es:
A
Reminder
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
30
3.4
Denitions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
31
3.5
Commen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
32
4
A
FIF
O
35
4.1
The
Inner
Sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
35
4.2
Instan
tiation
Examined
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
37
ix

x
CONTENTS
4.2.1
Instan
tiation
Is
Substitution
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
37
4.2.2
P
arametrized
Instan
tiation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
39
4.2.3
Implicit
Substitutions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
40
4.2.4
Instan
tiation
Without
Renaming
.
.
.
.
.
.
.
.
.
.
.
.
.
.
40
4.3
Hiding
the
Queue
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
41
4.4
A
Bounded
FIF
O
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
42
4.5
What
W
e're
Sp
ecifying
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
43
5
A
Cac
hing
Memory
45
5.1
The
Memory
In
terface
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
45
5.2
F
unctions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
48
5.3
A
Linearizable
Memory
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
51
5.4
T
uples
as
F
unctions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
53
5.5
Recursiv
e
F
unction
Denitions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
54
5.6
A
W
rite-Through
Cac
he
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
54
5.7
In
v
ariance
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
61
5.8
Pro
ving
Implemen
tation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
62
6
Some
More
Math
65
6.1
Sets
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
65
6.2
Silly
Expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
67
6.3
Recursion
Revisited
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
67
6.4
F
unctions
v
ersus
Op
erators
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
69
6.5
Using
F
unctions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
72
6.6
Cho
ose
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
73
7
W
riting
a
Sp
ecication:
Some
Advice
75
7.1
Wh
y
Sp
ecify
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
75
7.2
What
to
Sp
ecify
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
76
7.3
The
Grain
of
A
tomicit
y
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
76
7.4
The
Data
Structures
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
78
7.5
W
riting
the
Sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
79
7.6
Some
F
urther
Hin
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
80
7.7
When
and
Ho
w
to
Sp
ecify
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
83
P
art
I
I
More
Adv
anced
T
opics
85
8
Liv
eness
and
F
airness
87
8.1
T
emp
oral
F
orm
ulas
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
88
8.2
T
emp
oral
T
autologies
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
92
8.3
T
emp
oral
Pro
of
Rules
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
95
8.4
W
eak
F
airness
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
96
8.5
The
Memory
Sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
100

CONTENTS
xi
8.5.1
The
Liv
eness
Requiremen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
100
8.5.2
Another
W
a
y
to
W
rite
It
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
101
8.5.3
A
Generalization
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
105
8.6
Strong
F
airness
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
106
8.7
The
W
rite-Through
Cac
he
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
107
8.8
Quan
tication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
109
8.9
T
emp
oral
Logic
Examined
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
111
8.9.1
A
Review
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
111
8.9.2
Mac
hine
Closure
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
111
8.9.3
Mac
hine
Closure
and
P
ossibilit
y
.
.
.
.
.
.
.
.
.
.
.
.
.
.
113
8.9.4
Renemen
t
Mappings
and
F
airness
.
.
.
.
.
.
.
.
.
.
.
.
.
114
8.9.5
The
Unimp
ortance
of
Liv
eness
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
116
8.9.6
T
emp
oral
Logic
Considered
Confusing
.
.
.
.
.
.
.
.
.
.
.
116
9
Real
Time
117
9.1
The
Hour
Clo
c
k
Revisited
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
117
9.2
Real-Time
Sp
ecications
in
General
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
122
9.3
A
Real-Time
Cac
hing
Memory
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
124
9.4
Zeno
Sp
ecications
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
128
9.5
Hybrid
System
Sp
ecications
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
132
9.6
Remarks
on
Real
Time
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
134
10
Comp
osing
Sp
ecications
135
10.1
Comp
osing
Tw
o
Sp
ecications
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
136
10.2
Comp
osing
Man
y
Sp
ecications
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
138
10.3
The
FIF
O
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
140
10.4
Comp
osition
with
Shared
State
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
142
10.4.1
Explicit
State
Changes
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
144
10.4.2
Comp
osition
with
Join
t
Actions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
147
10.5
A
Brief
Review
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
150
10.5.1
A
T
axonom
y
of
Comp
osition
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
151
10.5.2
In
terlea
ving
Reconsidered
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
151
10.5.3
Join
t
Actions
Reconsidered
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
152
10.6
Liv
eness
and
Hiding
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
152
10.6.1
Liv
eness
and
Mac
hine
Closure
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
152
10.6.2
Hiding
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
154
10.7
Op
en-System
Sp
ecications
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
156
10.8
In
terface
Renemen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
158
10.8.1
A
Binary
Hour
Clo
c
k
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
158
10.8.2
Rening
a
Channel
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
159
10.8.3
In
terface
Renemen
t
in
General
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
163
10.8.4
Op
en-System
Sp
ecications
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
165
10.9
Should
Y
ou
Comp
ose?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
167

xii
CONTENTS
11
Adv
anced
Examples
169
11.1
Sp
ecifying
Data
Structures
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
170
11.1.1
Lo
cal
Denitions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
170
11.1.2
Graphs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
172
11.1.3
Solving
Dieren
tial
Equations
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
174
11.1.4
BNF
Grammars
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
179
11.2
Other
Memory
Sp
ecications
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
183
11.2.1
The
In
terface
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
183
11.2.2
The
Correctness
Condition
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
185
11.2.3
A
Serial
Memory
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
188
11.2.4
A
Sequen
tially
Consisten
t
Memory
.
.
.
.
.
.
.
.
.
.
.
.
.
195
11.2.5
The
Memory
Sp
ecications
Considered
.
.
.
.
.
.
.
.
.
.
.
200
P
art
I
I
I
The
T
o
ols
205
12
The
Syn
tactic
Analyzer
207
13
The
TLA
T
E
X
T
yp
esetter
211
13.1
In
tro
duction
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
211
13.2
Commen
t
Shading
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
212
13.3
Ho
w
It
T
yp
esets
the
Sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
213
13.4
Ho
w
It
T
yp
esets
Commen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
214
13.5
Adjusting
the
Output
F
ormat
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
216
13.6
Output
Files
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
217
13.7
T
rouble-Sho
oting
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
218
13.8
Using
L
A
T
E
X
Commands
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
219
14
The
TLC
Mo
del
Chec
k
er
221
14.1
In
tro
duction
to
TLC
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
221
14.2
What
TLC
Can
Cop
e
With
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
230
14.2.1
TLC
V
alues
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
230
14.2.2
Ho
w
TLC
Ev
aluates
Expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
231
14.2.3
Assignmen
t
and
Replacemen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
234
14.2.4
Ev
aluating
T
emp
oral
F
orm
ulas
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
235
14.2.5
Ov
erriding
Mo
dules
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
237
14.2.6
Ho
w
TLC
Computes
States
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
237
14.3
Ho
w
TLC
Chec
ks
Prop
erties
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
240
14.3.1
Mo
del-Chec
king
Mo
de
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
241
14.3.2
Sim
ulation
Mo
de
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
243
14.3.3
Views
and
Fingerprin
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
243
14.3.4
T
aking
Adv
an
tage
of
Symmetry
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
245
14.3.5
Limitations
of
Liv
eness
Chec
king
.
.
.
.
.
.
.
.
.
.
.
.
.
.
247
14.4
The
TLC
Mo
dule
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
248

CONTENTS
xiii
14.5
Ho
w
to
Use
TLC
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
251
14.5.1
Running
TLC
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
251
14.5.2
Debugging
a
Sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
253
14.5.3
Hin
ts
on
Using
TLC
Eectiv
ely
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
257
14.6
What
TLC
Do
esn't
Do
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
262
14.7
The
Fine
Prin
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
262
14.7.1
The
Grammar
of
the
Conguration
File
.
.
.
.
.
.
.
.
.
.
262
14.7.2
Comparable
TLC
V
alues
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
264
P
art
IV
The
TLA
+
Language
265
Mini-Manual
268{273
15
The
Syn
tax
of
TLA
+
275
15.1
The
Simple
Grammar
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
276
15.2
The
Complete
Grammar
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
283
15.2.1
Precedence
and
Asso
ciativit
y
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
283
15.2.2
Alignmen
t
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
286
15.2.3
Commen
ts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
288
15.2.4
T
emp
oral
F
orm
ulas
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
288
15.2.5
Tw
o
Anomalies
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
289
15.3
The
Lexemes
of
TLA
+
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
289
16
The
Op
erators
of
TLA
+
291
16.1
Constan
t
Op
erators
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
291
16.1.1
Bo
olean
Op
erators
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
293
16.1.2
The
Cho
ose
Op
erator
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
294
16.1.3
In
terpretations
of
Bo
olean
Op
erators
.
.
.
.
.
.
.
.
.
.
.
296
16.1.4
Conditional
Constructs
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
298
16.1.5
The
Let/In
Construct
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
299
16.1.6
The
Op
erators
of
Set
Theory
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
299
16.1.7
F
unctions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
301
16.1.8
Records
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
305
16.1.9
T
uples
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
306
16.1.10
Strings
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
307
16.1.11
Num
b
ers
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
308
16.2
Nonconstan
t
Op
erators
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
309
16.2.1
Basic
Constan
t
Expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
309
16.2.2
The
Meaning
of
a
State
F
unction
.
.
.
.
.
.
.
.
.
.
.
.
.
.
310
16.2.3
Action
Op
erators
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
312
16.2.4
T
emp
oral
Op
erators
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
314

xiv
CONTENTS
17
The
Meaning
of
a
Mo
dule
317
17.1
Op
erators
and
Expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
317
17.1.1
The
Arit
y
and
Order
of
an
Op
erator
.
.
.
.
.
.
.
.
.
.
.
.
318
17.1.2

Expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
319
17.1.3
Simplifying
Op
erator
Application
.
.
.
.
.
.
.
.
.
.
.
.
.
.
320
17.1.4
Expressions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
321
17.2
Lev
els
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
321
17.3
Con
texts
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
324
17.4
The
Meaning
of
a

Expression
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
325
17.5
The
Meaning
of
a
Mo
dule
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
327
17.5.1
Extends
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
328
17.5.2
Declarations
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
329
17.5.3
Op
erator
Denitions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
329
17.5.4
F
unction
Denitions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
329
17.5.5
Instan
tiation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
330
17.5.6
Theorems
and
Assumptions
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
332
17.5.7
Submo
dules
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
332
17.6
Correctness
of
a
Mo
dule
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
332
17.7
Finding
Mo
dules
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
333
17.8
The
Seman
tics
of
Instan
tiation
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
334
18
The
Standard
Mo
dules
339
18.1
Mo
dule
Se
quenc
es
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
339
18.2
Mo
dule
FiniteSets
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
340
18.3
Mo
dule
Bags
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
340
18.4
The
Num
b
ers
Mo
dules
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
344

List
of
Figures
and
T
ables
Figures
2.1
The
hour-clo
c
k
sp
ecication|t
yp
eset
and
ASCI
I
v
ersions.
.
.
.
.
20
3.1
Our
rst
sp
ecication
of
an
async
hronous
in
terface.
.
.
.
.
.
.
.
.
27
3.2
Our
second
sp
ecication
of
an
async
hronous
in
terface.
.
.
.
.
.
.
30
3.3
The
hour-clo
c
k
sp
ecication
with
commen
ts.
.
.
.
.
.
.
.
.
.
.
.
33
4.1
The
sp
ecication
of
a
FIF
O,
with
the
in
ternal
v
ariable
q
visible.
38
4.2
A
sp
ecication
of
a
FIF
O
buer
of
length
N.
.
.
.
.
.
.
.
.
.
.
.
43
5.1
The
sp
ecication
of
a
memory
in
terface.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
48
5.2
The
in
ternal
memory
sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
52
5.3
The
memory
sp
ecication.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
53
5.4
The
write-through
cac
he.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
55
5.5
The
write-through
cac
he
sp
ecication
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
57
9.1
The
real-time
sp
ecication
of
an
hour
clo
c
k.
.
.
.
.
.
.
.
.
.
.
.
.
121
9.2
The
R
e
alTime
mo
dule
for
writing
real-time
sp
ecications.
.
.
.
.
125
9.3
A
real-time
v
ersion
of
the
linearizable
memory
sp
ecication.
.
.
.
126
9.4
A
real-time
v
ersion
of
the
write-through
cac
he
.
.
.
.
.
.
.
.
.
.
.
129
10.1
A
nonin
terlea
ving
comp
osite
sp
ecication
of
the
FIF
O.
.
.
.
.
.
.
143
10.2
A
join
t-action
sp
ecication
of
a
linearizable
memory
.
.
.
.
.
.
.
.
150
10.3
A
sp
ecication
of
a
binary
hour
clo
c
k.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
160
10.4
Rening
a
c
hannel.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
162
11.1
A
mo
dule
for
sp
ecifying
op
erators
on
graphs.
.
.
.
.
.
.
.
.
.
.
.
175
11.2
A
mo
dule
for
sp
ecifying
the
solution
to
a
dieren
tial
equation.
.
178
11.3
The
denition
of
the
grammar
GSE
for
the
language
SE.
.
.
.
.
183
11.4
The
mo
dule
BNF
Gr
ammars.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
184
11.5
A
mo
dule
for
sp
ecifying
a
register
in
terface
to
a
memory
.
.
.
.
.
186
11.6
Mo
dule
InnerSerial
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
196
xv

xvi
LIST
OF
FIGURES
AND
T
ABLES
11.7
Mo
dule
InnerSe
quential
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
201
14.1
The
alternating
bit
proto
col
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
223
14.2
Mo
dule
MCA
lternatingBit.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
227
14.3
A
conguration
le
for
mo
dule
MCA
lternatingBit.
.
.
.
.
.
.
.
.
227
14.4
A
sp
ecication
of
correctness
of
the
alternating
bit
proto
col.
.
.
.
229
14.5
The
standard
mo
dule
TLC.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
248
14.6
The
BNF
grammar
of
the
conguration
le.
.
.
.
.
.
.
.
.
.
.
.
.
263
18.1
The
standard
Se
quenc
es
mo
dule.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
341
18.2
The
standard
FiniteSets
mo
dule.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
341
18.3
The
standard
Bags
mo
dule.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
343
18.4
The
Pe
ano
mo
dule.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
345
18.5
The
Pr
otoR
e
als
mo
dule
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
346
18.6
The
standard
Natur
als
mo
dule.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
348
18.7
The
standard
Inte
gers
mo
dule.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
348
18.8
The
standard
R
e
als
mo
dule.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
348
T
ables
T
able
1
The
constan
t
op
erators.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
268
T
able
2
Miscellaneous
constructs.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
269
T
able
3
Action
op
erators.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
269
T
able
4
T
emp
oral
op
erators.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
269
T
able
5
User-denable
op
erator
sym
b
ols.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
270
T
able
6
The
precedence
ranges
of
op
erators.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
271
T
able
7
Op
erators
dened
in
the
standard
mo
dules.
.
.
.
.
.
.
.
.
.
.
272
T
able
8
The
asci
i
represen
tations
of
t
yp
eset
sym
b
ols.
.
.
.
.
.
.
.
.
.
273

Ac
kno
wledgmen
ts
I
ha
v
e
sp
en
t
more
than
t
w
o
and
a
half
decades
learning
ho
w
to
sp
ecify
and
reason
ab
out
concurren
t
computer
systems.
Before
that,
I
had
already
sp
en
t
man
y
y
ears
learning
ho
w
to
use
mathematics
rigorously
.
I
cannot
b
egin
to
thank
ev
ery
one
who
help
ed
me
during
all
that
time.
But
I
w
ould
lik
e
to
express
m
y
gratitude
to
t
w
o
men
who,
more
than
an
y
one
else,
inuenced
this
b
o
ok.
Ric
hard
P
alais
taugh
t
me
ho
w
ev
en
the
most
complicated
mathematics
could
b
e
made
b
oth
rigorous
and
elegan
t.
Mart

n
Abadi
inuenced
the
dev
elopmen
t
of
TLA
and
w
as
m
y
collab
orator
in
dev
eloping
the
ideas
b
ehind
Chapters
9
and
10.
Muc
h
of
what
I
kno
w
ab
out
applying
the
mathematics
of
TLA
to
the
engi-
neering
problems
of
complex
systems
came
from
w
orking
with
Mark
T
uttle
and
Y
uan
Y
u.
Y
uan
Y
u
also
help
ed
turn
TLA
+
in
to
a
useful
to
ol
for
engineers
b
y
writing
the
TLC
mo
del
c
hec
k
er,
ignoring
m
y
w
arnings
that
it
w
ould
nev
er
b
e
practical.
While
writing
the
rst
v
ersion
of
the
Syn
tactic
Analyzer,
Jean-Charles
Gr

egoire
help
ed
me
ne
tune
the
TLA
+
language.
The
follo
wing
p
eople
made
helpful
commen
ts
on
earlier
v
ersions
of
this
b
o
ok:
Dominique
Couturier,
Douglas
F
rank,
Vino
d
Gro
v
er,
Da
vid
Jeerson,
Sara
Kalv
ala,
and
W
olfgang
Sc
hreiner
all
p
oin
ted
out
mistak
es.
Kazuhiro
Ogata
read
the
man
uscript
with
un
usual
care
and
found
a
n
um
b
er
of
mistak
es.
Kapila
P
ahala
w
atta
found
an
error
in
the
Pr
otoR
e
als
mo
dule.
P
addy
Krishnan
also
found
an
error
in
the
Pr
otoR
e
als
mo
dule
and
suggested
a
w
a
y
to
impro
v
e
the
presen
tation.
And
I
wish
to
extend
m
y
sp
ecial
thanks
to
Martin
Rudalics,
who
read
the
man
uscript
with
amazing
thoroughness
and
caugh
t
man
y
errors.
L
eslie
L
amp
ort
Palo
A
lto,
California
4
Mar
ch
2002
xvii


In
tro
duction
This
b
o
ok
will
teac
h
y
ou
ho
w
to
write
sp
ecications
of
computer
systems,
using
the
language
TLA
+
.
It's
rather
long,
but
most
p
eople
will
read
only
P
art
I,
whic
h
comprises
the
rst
83
pages.
That
part
con
tains
all
that
most
engineers
need
to
kno
w
ab
out
writing
sp
ecications;
it
assumes
only
the
basic
bac
kground
in
com-
puting
and
kno
wledge
of
mathematics
exp
ected
of
an
undergraduate
studying
engineering
or
computer
science.
P
art
I
I
con
tains
more
adv
anced
material
for
more
sophisticated
readers.
The
remainder
of
the
b
o
ok
is
a
reference
man
ual|
P
art
I
I
I
for
the
TLA
+
to
ols
and
P
art
IV
for
the
language
itself.
The
TLA
W
orld
Wide
W
eb
page
con
tains
material
to
accompan
y
the
b
o
ok,
including
the
TLA
+
to
ols,
exercises,
references
to
the
literature,
and
a
list
of
corrections.
There
is
a
link
to
the
TLA
W
eb
page
on
http://lamport.or
g
Y
ou
can
also
nd
the
page
b
y
searc
hing
the
W
eb
for
the
21-letter
string
omepage
uidlamporttlah
Do
not
put
this
string
in
an
y
do
cumen
t
that
migh
t
app
ear
on
the
W
eb.
What
Is
a
Sp
ecication?
Writing
is
natur
e's
way
of
letting
you
know
how
sloppy
your
thinking
is.
|
Guindon
A
sp
ecication
is
a
written
description
of
what
a
system
is
supp
osed
to
do.
Sp
ecifying
a
system
helps
us
understand
it.
It's
a
go
o
d
idea
to
understand
a
system
b
efore
building
it,
so
it's
a
go
o
d
idea
to
write
a
sp
ecication
of
a
system
b
efore
implemen
ting
it.
This
b
o
ok
is
ab
out
sp
ecifying
the
b
eha
vioral
prop
erties
of
a
system|also
called
its
functional
or
logical
prop
erties.
These
are
the
prop
erties
that
sp
ec-
ify
what
the
system
is
supp
osed
to
do.
There
are
other
imp
ortan
t
kinds
of
1

2
prop
erties
that
w
e
don't
consider,
including
p
erformance
prop
erties.
W
orst-
case
p
erformance
can
often
b
e
expressed
as
a
b
eha
vioral
prop
ert
y|for
example,
Chapter
9
explains
ho
w
to
sp
ecify
that
a
system
m
ust
react
within
a
certain
length
of
time.
Ho
w
ev
er,
sp
ecifying
a
v
erage
p
erformance
is
b
ey
ond
the
scop
e
of
the
metho
ds
describ
ed
here.
Our
basic
to
ol
for
writing
sp
ecications
is
mathematics.
Mathematics
is
nature's
w
a
y
of
letting
y
ou
kno
w
ho
w
slopp
y
y
our
writing
is.
It's
hard
to
b
e
precise
in
an
imprecise
language
lik
e
English
or
Chinese.
In
engineering,
impre-
cision
can
lead
to
errors.
T
o
a
v
oid
errors,
science
and
engineering
ha
v
e
adopted
mathematics
as
their
language.
The
mathematics
w
e
use
is
more
formal
than
the
math
y
ou'v
e
gro
wn
up
with.
F
ormal
mathematics
is
nature's
w
a
y
of
letting
y
ou
kno
w
ho
w
slopp
y
y
our
mathematics
is.
The
mathematics
written
b
y
most
mathematicians
and
scien
tists
is
not
really
precise.
It's
precise
in
the
small,
but
imprecise
in
the
large.
Eac
h
equation
is
a
precise
assertion,
but
y
ou
ha
v
e
to
read
the
accompan
ying
w
ords
to
understand
ho
w
the
equations
relate
to
one
another
and
exactly
what
the
theorems
mean.
Logicians
ha
v
e
dev
elop
ed
w
a
ys
of
eliminating
those
w
ords
and
making
the
mathematics
completely
formal
and,
hence,
completely
precise.
Most
mathematicians
and
scien
tists
think
that
formal
mathematics,
without
w
ords,
is
long
and
tiresome.
They're
wrong.
Ordinary
mathematics
can
b
e
expressed
compactly
in
a
precise,
completely
formal
language.
It
tak
es
only
ab
out
t
w
o
dozen
lines
to
dene
the
solution
to
an
arbitrary
dieren
tial
equation
in
the
Dier
entialEquations
mo
dule
of
Chapter
11.
But
few
sp
ecications
need
suc
h
sophisticated
mathematics.
Most
require
only
simple
application
of
a
few
standard
mathematical
concepts.
Wh
y
TLA
+
?
W
e
sp
ecify
a
system
b
y
describing
its
allo
w
ed
b
eha
viors|what
it
ma
y
do
in
the
course
of
an
execution.
In
1977,
Amir
Pn
ueli
in
tro
duced
the
use
of
temp
oral
logic
for
describing
system
b
eha
viors.
In
principle,
a
system
could
b
e
describ
ed
b
y
a
single
temp
oral
logic
form
ula.
In
practice,
it
couldn't.
Pn
ueli's
temp
oral
logic
w
as
ideal
for
describing
some
prop
erties
of
systems,
but
a
wkw
ard
for
others.
So,
it
w
as
usually
com
bined
with
a
more
traditional
w
a
y
of
describing
systems.
In
the
late
1980's,
I
in
v
en
ted
TLA,
the
T
emp
oral
Logic
of
Actions|a
simple
v
arian
t
of
Pn
ueli's
original
logic.
TLA
mak
es
it
practical
to
describ
e
a
system
b
y
a
single
form
ula.
Most
of
a
TLA
sp
ecication
consists
of
ordinary
,
non
temp
oral
mathematics.
T
emp
oral
logic
pla
ys
a
signican
t
role
only
in
describing
those
prop
erties
that
it's
go
o
d
at
describing.
TLA
also
pro
vides
a
nice
w
a
y
to
formalize
the
st
yle
of
reasoning
ab
out
systems
that
has
pro
v
ed
to
b
e
most
eectiv
e
in
practice|a
st
yle
kno
wn
as
assertional
reasoning.
Ho
w
ev
er,
this
b
o
ok
is
ab
out
sp
ecication;
it
sa
ys
almost
nothing
ab
out
pro
ofs.

3
T
emp
oral
logic
assumes
an
underlying
logic
for
expressing
ordinary
mathe-
matics.
There
are
man
y
w
a
ys
to
formalize
ordinary
math.
Most
computer
sci-
en
tists
prefer
one
that
resem
bles
their
fa
v
orite
programming
language.
I
c
hose
instead
the
one
that
most
mathematicians
prefer|the
one
logicians
call
rst-
order
logic
and
set
theory
.
TLA
pro
vides
a
mathematical
foundation
for
describing
systems.
T
o
write
sp
ecications,
w
e
need
a
complete
language
built
atop
that
foundation.
I
ini-
tially
though
t
that
this
language
should
b
e
some
sort
of
abstract
programming
language
whose
seman
tics
w
ould
b
e
based
on
TLA.
I
didn't
kno
w
what
kind
of
programming
language
constructs
w
ould
b
e
b
est,
so
I
decided
to
start
writing
sp
ecications
directly
in
TLA.
I
in
tended
to
in
tro
duce
programming
constructs
as
I
needed
them.
T
o
m
y
surprise,
I
disco
v
ered
that
I
didn't
need
them.
What
I
needed
w
as
a
robust
language
for
writing
mathematics.
Although
mathematicians
ha
v
e
dev
elop
ed
the
science
of
writing
form
ulas,
they
ha
v
en't
turned
that
science
in
to
an
engineering
discipline.
They
ha
v
e
de-
v
elop
ed
notations
for
mathematics
in
the
small,
but
not
for
mathematics
in
the
large.
The
sp
ecication
of
a
real
system
can
b
e
dozens
or
ev
en
h
undreds
of
pages
long.
Mathematicians
kno
w
ho
w
to
write
20-line
form
ulas,
not
20-page
form
ulas.
So,
I
had
to
in
tro
duce
notations
for
writing
long
form
ulas.
What
I
to
ok
from
programming
languages
w
ere
ideas
for
mo
dularizing
large
sp
ecications.
The
language
I
came
up
with
is
called
TLA
+
.
I
rened
TLA
+
in
the
course
of
writing
sp
ecications
of
disparate
systems.
But
it
has
c
hanged
little
in
the
last
few
y
ears.
I
ha
v
e
found
TLA
+
to
b
e
quite
go
o
d
for
sp
ecifying
a
wide
class
of
systems|from
program
in
terfaces
(APIs)
to
distributed
systems.
It
can
b
e
used
to
write
a
precise,
formal
description
of
almost
an
y
sort
of
discrete
system.
It's
esp
ecially
w
ell
suited
to
describing
async
hronous
systems|that
is,
systems
with
comp
onen
ts
that
do
not
op
erate
in
strict
lo
c
k-step.
Ab
out
this
Bo
ok
P
art
I,
consisting
of
Chapters
1
through
7,
is
the
core
of
the
b
o
ok
and
is
mean
t
to
b
e
read
from
b
eginning
to
end.
It
explains
ho
w
to
sp
ecify
the
class
of
prop
erties
kno
wn
as
safety
prop
erties.
These
prop
erties,
whic
h
can
b
e
sp
ecied
with
almost
no
temp
oral
logic,
are
all
that
most
engineers
need
to
kno
w
ab
out.
After
reading
P
art
I,
y
ou
can
read
as
m
uc
h
of
P
art
I
I
as
y
ou
lik
e.
Eac
h
of
its
c
hapters
is
indep
enden
t
of
the
others.
T
emp
oral
logic
comes
to
the
fore
in
Chapter
8,
where
it
is
used
to
sp
ecify
the
additional
class
of
prop
erties
kno
wn
as
liveness
prop
erties.
Chapter
9
describ
es
ho
w
to
sp
ecify
real-time
prop
erties,
and
Chapter
10
describ
es
ho
w
to
write
sp
ecications
as
comp
ositions.
Chapter
11
con
tains
more
adv
anced
examples.
P
art
I
I
I
serv
es
as
the
reference
man
ual
for
three
TLA
+
to
ols:
the
Syn
tactic
Analyzer,
the
TLA
T
E
X
t
yp
esetting
program,
and
the
TLC
mo
del
c
hec
k
er.
If

4
y
ou
w
an
t
to
use
TLA
+
,
then
y
ou
probably
w
an
t
to
use
these
to
ols.
They
are
a
v
ailable
from
the
TLA
W
eb
page.
TLC
is
the
most
sophisticated
of
them.
The
examples
on
the
W
eb
can
get
y
ou
started
using
it,
but
y
ou'll
ha
v
e
to
read
Chapter
14
to
learn
to
use
TLC
eectiv
ely
.
P
art
IV
is
a
reference
man
ual
for
the
TLA
+
language.
P
art
I
pro
vides
a
go
o
d
enough
w
orking
kno
wledge
of
the
language
for
most
purp
oses.
Y
ou
need
lo
ok
at
P
art
IV
only
if
y
ou
ha
v
e
questions
ab
out
the
ne
p
oin
ts
of
the
syn
tax
and
seman
tics.
Chapter
15
giv
es
the
syn
tax
of
TLA
+
.
Chapter
16
describ
es
the
precise
meanings
and
the
general
forms
of
all
the
built-in
op
erators
of
TLA
+
;
Chapter
17
describ
es
the
precise
meaning
of
all
the
higher-lev
el
TLA
+
con-
structs
suc
h
as
denitions.
T
ogether,
these
t
w
o
c
hapters
sp
ecify
the
seman
tics
of
the
language.
Chapter
18
describ
es
the
standard
mo
dules|except
for
mo
dule
R
e
alTime
,
describ
ed
in
Chapter
9,
and
mo
dule
TLC
,
describ
ed
in
Chapter
14.
Y
ou
migh
t
w
an
t
to
lo
ok
at
this
c
hapter
if
y
ou're
curious
ab
out
ho
w
standard
elemen
tary
mathematics
can
b
e
formalized
in
TLA
+
.
P
art
IV
do
es
ha
v
e
something
y
ou
ma
y
w
an
t
to
refer
to
often:
a
mini-man
ual
that
compactly
presen
ts
lots
of
useful
information.
P
ages
268{273
list
all
TLA
+
op
erators,
all
user-denable
sym
b
ols,
the
precedence
of
all
op
erators,
all
op
era-
tors
dened
in
the
standard
mo
dules,
and
the
asci
i
represen
tation
of
sym
b
ols
lik
e

.

P
art
I
Getting
Started
5


7
A
system
sp
ecication
consists
of
a
lot
of
ordinary
mathematics
glued
to-
gether
with
a
tin
y
bit
of
temp
oral
logic.
That's
wh
y
most
TLA
+
constructs
are
for
expressing
ordinary
mathematics.
T
o
write
sp
ecications,
y
ou
ha
v
e
to
b
e
familiar
with
this
ordinary
math.
Unfortunately
,
the
computer
science
de-
partmen
ts
in
man
y
univ
ersities
apparen
tly
b
eliev
e
that
uency
in
C++
is
more
imp
ortan
t
than
a
sound
education
in
elemen
tary
mathematics.
So,
some
readers
ma
y
b
e
unfamiliar
with
the
math
needed
to
write
sp
ecications.
F
ortunately
,
this
math
is
quite
simple.
If
exp
osure
to
C++
hasn't
destro
y
ed
y
our
abilit
y
to
think
logically
,
y
ou
should
ha
v
e
no
trouble
lling
an
y
gaps
in
y
our
mathematics
education.
Y
ou
probably
learned
arithmetic
b
efore
learning
C++,
so
I
will
as-
sume
y
ou
kno
w
ab
out
n
um
b
ers
and
arithmetic
op
erations
on
them.
1
I
will
try
to
explain
all
other
mathematical
concepts
that
y
ou
need,
starting
in
Chapter
1
with
a
review
of
some
elemen
tary
math.
I
hop
e
most
readers
will
nd
this
review
completely
unnecessary
.
After
the
brief
review
of
simple
mathematics
in
the
rst
c
hapter,
Chapters
2
through
5
describ
e
TLA
+
with
a
sequence
of
examples.
Chapter
6
explains
some
more
ab
out
the
math
used
in
writing
sp
ecications,
and
Chapter
7
reviews
ev
erything
and
pro
vides
some
advice.
By
the
time
y
ou
nish
Chapter
7,
y
ou
should
b
e
able
to
handle
most
of
the
sp
ecication
problems
that
y
ou
are
lik
ely
to
encoun
ter
in
ordinary
engineering
practice.
1
Some
readers
ma
y
need
reminding
that
n
um
b
ers
are
not
strings
of
bits,
and
2
33

2
33
equals
2
66
,
not
overow
err
or.

8

Chapter
1
A
Little
Simple
Math
1.1
Prop
ositional
Logic
Elemen
tary
algebra
is
the
mathematics
of
real
n
um
b
ers
and
the
op
erators
+,
 ,

(m
ultiplication),
and
=
(division).
Prop
ositional
logic
is
the
mathematics
of
the
t
w
o
Bo
olean
v
alues
tr
ue
and
f
alse
and
the
v
e
op
erators
whose
names
(and
common
pron
unciations)
are
^
conjunction
(and)
_
disjunction
(or)
:
negation
(not)
)
implication
(implies)

equiv
alence
(is
equiv
alen
t
to)
T
o
learn
ho
w
to
compute
with
n
um
b
ers,
y
ou
had
to
memorize
addition
and
m
ultiplication
tables
and
algorithms
for
calculating
with
m
ultidigit
n
um
b
ers.
Prop
ositional
logic
is
m
uc
h
simpler,
since
there
are
only
t
w
o
v
alues,
tr
ue
and
f
alse.
T
o
learn
ho
w
to
compute
with
these
v
alues,
all
y
ou
need
to
kno
w
are
the
follo
wing
denitions
of
the
v
e
Bo
olean
op
erators:
^
F
^
G
equals
tr
ue
i
b
oth
F
and
G
equal
tr
ue
.
i
stands
for
if
and
only
if.
Lik
e
most
mathemati-
cians,
I
use
or
to
mean
and/or.
_
F
_
G
equals
tr
ue
i
F
or
G
equals
tr
ue
(or
b
oth
do).
:
:F
equals
tr
ue
i
F
equals
f
alse.
)
F
)
G
equals
tr
ue
i
F
equals
f
alse
or
G
equals
tr
ue
(or
b
oth).

F

G
equals
tr
ue
i
F
and
G
b
oth
equal
tr
ue
or
b
oth
equal
f
alse.
9

10
CHAPTER
1.
A
LITTLE
SIMPLE
MA
TH
W
e
can
also
describ
e
these
op
erators
b
y
truth
tables.
This
truth
table
giv
es
the
v
alue
of
F
)
G
for
all
four
com
binations
of
truth
v
alues
of
F
and
G
:
F
G
F
)
G
tr
ue
tr
ue
tr
ue
tr
ue
f
alse
f
alse
f
alse
tr
ue
tr
ue
f
alse
f
alse
tr
ue
The
form
ula
F
)
G
asserts
that
F
implies
G
|that
is,
F
)
G
equals
tr
ue
i
the
statemen
t
\F
implies
G
"
is
true.
P
eople
often
nd
the
denition
of
)
confusing.
They
don't
understand
wh
y
f
alse
)
tr
ue
and
f
alse
)
f
alse
should
equal
tr
ue
.
The
explanation
is
simple.
W
e
exp
ect
that
if
n
is
greater
than
3,
then
it
should
b
e
greater
than
1,
so
n
>
3
should
imply
n
>
1.
Therefore,
the
form
ula
(n
>
3)
)
(n
>
1)
should
equal
tr
ue
.
Substituting
4,
2,
and
0
for
n
in
this
form
ula
explains
wh
y
F
)
G
means
F
implies
G
or,
equiv
alen
tly
,
if
F
then
G
.
The
equiv
alence
op
erator

is
equalit
y
for
Bo
oleans.
W
e
can
replace

b
y
=,
but
not
vice
v
ersa.
(W
e
can
write
f
alse
=
:tr
ue
,
but
not
2
+
2

4.)
It's
a
go
o
d
idea
to
write

instead
of
=
to
mak
e
it
clear
that
the
equal
expressions
are
Bo
oleans.
1
Just
lik
e
form
ulas
of
algebra,
form
ulas
of
prop
ositional
logic
are
made
up
of
v
alues,
op
erators,
and
iden
tiers
lik
e
x
that
stand
for
v
alues.
Ho
w
ev
er,
prop
ositional-logic
form
ulas
use
only
the
t
w
o
v
alues
tr
ue
and
f
alse
and
the
v
e
Bo
olean
op
erators
^,
_,
:,
),
and
.
In
algebraic
form
ulas,

has
higher
precedence
(binds
more
tigh
tly)
than
+,
so
x
+
y

z
means
x
+
(y

z
).
Similarly
,
:
has
higher
precedence
than
^
and
_,
whic
h
ha
v
e
higher
precedence
than
)
and
,
so
:F
^
G
)
H
means
((:F
)
^
G
)
)
H
.
Other
mathematical
op
erators
lik
e
+
and
>
ha
v
e
higher
precedence
than
the
op
erators
of
prop
ositional
logic,
so
n
>
0
)
n
 1

0
means
(n
>
0)
)
(n
 1

0).
Redundan
t
paren
theses
can't
h
urt
and
often
mak
e
a
form
ula
easier
to
read.
If
y
ou
ha
v
e
the
sligh
test
doubt
ab
out
whether
paren
theses
are
needed,
use
them.
The
op
erators
^
and
_
are
asso
ciativ
e,
just
lik
e
+
and
.
Asso
ciativit
y
of
+
means
that
x
+
(y
+
z
)
equals
(x
+
y
)
+
z
,
so
w
e
can
write
x
+
y
+
z
without
paren
theses.
Similarly
,
asso
ciativit
y
of
^
and
_
lets
us
write
F
^
G
^
H
or
F
_
G
_
H
.
Lik
e
+
and
,
the
op
erators
^
and
_
are
also
comm
utativ
e,
so
F
^
G
is
equiv
alen
t
to
G
^
F
,
and
F
_
G
is
equiv
alen
t
to
G
_
F
.
The
truth
of
the
form
ula
(x
=
2)
)
(x
+
1
=
3)
expresses
a
fact
ab
out
n
um
b
ers.
T
o
determine
that
it's
true,
w
e
ha
v
e
to
understand
some
elemen
tary
prop
erties
of
arithmetic.
Ho
w
ev
er,
w
e
can
tell
that
(x
=
2)
)
(x
=
2)
_
(y
>
7)
is
true
ev
en
if
w
e
kno
w
nothing
ab
out
n
um
b
ers.
This
form
ula
is
true
b
ecause
F
)
F
_
G
is
true,
regardless
of
what
the
form
ulas
F
and
G
are.
In
other
1
Section
16.1.3
on
page
296
explains
a
more
subtle
reason
for
using

instead
of
=
for
equalit
y
of
Bo
olean
v
alues.

1.2.
SETS
11
w
ords,
F
)
F
_
G
is
true
for
all
p
ossible
truth
v
alues
of
its
iden
tiers
F
and
G
.
Suc
h
a
form
ula
is
called
a
tautolo
gy.
In
general,
a
tautology
of
prop
ositional
logic
is
a
prop
ositional-logic
form
ula
that
is
true
for
all
p
ossible
truth
v
alues
of
its
iden
tiers.
Simple
tautologies
lik
e
this
should
b
e
as
ob
vious
as
simple
algebraic
prop
erties
of
n
um
b
ers.
It
should
b
e
as
ob
vious
that
F
)
F
_
G
is
a
tautology
as
that
x

x
+
y
is
true
for
all
non-negativ
e
n
um
b
ers
x
and
y
.
One
can
deriv
e
complicated
tautologies
from
simpler
ones
b
y
calculations,
just
as
one
deriv
es
more
complicated
prop
erties
of
n
um
b
ers
from
simpler
ones.
Ho
w
ev
er,
this
tak
es
practice.
Y
ou'v
e
sp
en
t
y
ears
learning
ho
w
to
manipulate
n
um
b
er-v
alued
expressions|for
example,
to
deduce
that
x

 x
+
y
holds
i
2

x

y
do
es.
Y
ou
probably
ha
v
en't
learned
to
deduce
that
:F
_
G
holds
i
F
)
G
do
es.
If
y
ou
ha
v
en't
learned
to
manipulate
Bo
olean-v
alued
expressions,
y
ou
will
ha
v
e
to
do
the
equiv
alen
t
of
coun
ting
on
y
our
ngers.
Y
ou
can
c
hec
k
if
a
form
ula
is
a
tautology
b
y
calculating
whether
it
equals
tr
ue
for
eac
h
p
ossible
assignmen
t
of
Bo
olean
v
alues
to
its
v
ariables.
This
is
b
est
done
b
y
constructing
a
truth
table
that
lists
the
p
ossible
assignmen
ts
of
v
alues
to
v
ariables
and
the
corresp
onding
v
alues
of
all
subform
ulas.
F
or
example,
here
is
the
truth
table
sho
wing
that
(F
)
G
)

(:F
_
G
)
is
a
tautology
.
F
G
F
)
G
:F
:F
_
G
(F
)
G)

:F
_
G
tr
ue
tr
ue
tr
ue
f
alse
tr
ue
tr
ue
tr
ue
f
alse
f
alse
f
alse
f
alse
tr
ue
f
alse
tr
ue
tr
ue
tr
ue
tr
ue
tr
ue
f
alse
f
alse
tr
ue
tr
ue
tr
ue
tr
ue
W
riting
truth
tables
is
a
go
o
d
w
a
y
to
impro
v
e
y
our
understanding
of
prop
o-
sitional
logic.
Ho
w
ev
er,
computers
are
b
etter
than
p
eople
at
doing
this
sort
of
calculation.
Chapter
14
explains,
on
page
261,
ho
w
to
use
the
TLC
mo
del
c
hec
k
er
to
v
erify
prop
ositional
logic
tautologies
and
to
p
erform
other
TLA
+
cal-
culations.
1.2
Sets
Set
theory
is
the
foundation
of
ordinary
mathematics.
A
set
is
often
describ
ed
as
a
collection
of
elemen
ts,
but
sa
ying
that
a
set
is
a
collection
do
esn't
explain
v
ery
m
uc
h.
The
concept
of
set
is
so
fundamen
tal
that
w
e
don't
try
to
dene
it.
W
e
tak
e
as
undened
concepts
the
notion
of
a
set
and
the
relation
2,
where
x
2
S
means
that
x
is
an
elemen
t
of
S
.
W
e
often
sa
y
is
in
instead
of
is
an
element
of.
A
set
can
ha
v
e
a
nite
or
innite
n
um
b
er
of
elemen
ts.
The
set
of
all
natural
n
um
b
ers
(0,
1,
2,
etc.)
is
an
innite
set.
The
set
of
all
natural
n
um
b
ers
less
than

12
CHAPTER
1.
A
LITTLE
SIMPLE
MA
TH
3
is
nite,
and
con
tains
the
three
elemen
ts
0,
1,
and
2.
W
e
can
write
this
set
f0;
1;
2g
.
A
set
is
completely
determined
b
y
its
elemen
ts.
Tw
o
sets
are
equal
i
they
ha
v
e
the
same
elemen
ts.
Th
us,
f0;
1;
2g
and
f2;
1;
0g
and
f0;
0;
1;
2;
2g
are
all
the
same
set|the
unique
set
con
taining
the
three
elemen
ts
0,
1,
and
2.
The
empt
y
set,
whic
h
w
e
write
fg,
is
the
unique
set
that
has
no
elemen
ts.
The
most
common
op
erations
on
sets
are
\
in
tersection
[
union

subset
n
set
dierence
Here
are
their
denitions
and
examples
of
their
use.
S
\
T
The
set
of
elemen
ts
in
b
oth
S
and
T
.
f1;
 1=2;
3g
\
f1;
2;
3;
5;
7g
=
f1;
3g
S
[
T
The
set
of
elemen
ts
in
S
or
T
(or
b
oth).
f1;
 1=2g
[
f1;
5;
7g
=
f1;
 1=2;
5;
7g
S

T
T
rue
i
ev
ery
elemen
t
of
S
is
an
elemen
t
of
T
.
f1;
3g

f3;
2;
1g
S
n
T
The
set
of
elemen
ts
in
S
that
are
not
in
T
.
f1;
 1=2;
3g
n
f1;
5;
7g
=
f 1=2;
3g
This
is
all
y
ou
need
to
kno
w
ab
out
sets
b
efore
w
e
start
lo
oking
at
ho
w
to
sp
ecify
systems.
W
e'll
return
to
set
theory
in
Section
6.1.
1.3
Predicate
Logic
Once
w
e
ha
v
e
sets,
it's
natural
to
sa
y
that
some
form
ula
is
true
for
all
the
elemen
ts
of
a
set,
or
for
some
of
the
elemen
ts
of
a
set.
Predicate
logic
extends
prop
ositional
logic
with
the
t
w
o
quan
tiers
8
univ
ersal
quan
tication
(for
all)
9
existen
tial
quan
tication
(there
exists)
The
form
ula
8
x
2
S
:
F
asserts
that
form
ula
F
is
true
for
ev
ery
elemen
t
x
in
the
set
S
.
F
or
example,
8
n
2
Nat
:
n
+
1
>
n
asserts
that
the
form
ula
n
+
1
>
n
is
true
for
all
elemen
ts
n
of
the
set
Nat
of
natural
n
um
b
ers.
This
form
ula
happ
ens
to
b
e
true.
The
form
ula
9
x
2
S
:
F
asserts
that
form
ula
F
is
true
for
at
least
one
ele-
men
t
x
in
S
.
F
or
example,
9
n
2
Nat
:
n
2
=
2
asserts
that
there
exists
a
natural
n
um
b
er
n
whose
square
equals
2.
This
form
ula
happ
ens
to
b
e
false.
F
orm
ula
F
is
true
for
some
x
in
S
i
F
is
not
false
for
all
x
in
S
|that
is,
i
it's
not
the
case
that
:F
is
true
for
all
x
in
S
.
Hence,
the
form
ula
(9
x
2
S
:
F
)

:(8
x
2
S
:
:F
)
(1.1)

1.3.
PREDICA
TE
LOGIC
13
is
a
tautology
of
predicate
logic,
meaning
that
it
is
true
for
all
v
alues
of
the
iden
tiers
S
and
F
.
2
Since
there
exists
no
elemen
t
in
the
empt
y
set,
the
form
ula
9
x
2
fg
:
F
is
false
for
ev
ery
form
ula
F
.
By
(1.1),
this
implies
that
8
x
2
fg
:
F
m
ust
b
e
true
for
ev
ery
F
.
The
quan
tication
in
the
form
ulas
8
x
2
S
:
F
and
9
x
2
S
:
F
is
said
to
b
e
b
ounde
d,
since
these
form
ulas
mak
e
an
assertion
only
ab
out
elemen
ts
in
the
set
S
.
There
is
also
un
b
ounded
quan
tication.
The
form
ula
8
x
:
F
asserts
that
F
is
true
for
all
v
alues
x
,
and
9
x
:
F
asserts
that
F
is
true
for
at
least
one
v
alue
of
x
|a
v
alue
that
is
not
constrained
to
b
e
in
an
y
particular
set.
Bounded
and
un
b
ounded
quan
tication
are
related
b
y
the
follo
wing
tautologies:
(8
x
2
S
:
F
)

(8
x
:
(x
2
S
)
)
F
)
(9
x
2
S
:
F
)

(9
x
:
(x
2
S
)
^
F
)
The
analog
of
(1.1)
for
un
b
ounded
quan
tiers
is
also
a
tautology:
(9
x
:
F
)

:(8
x
:
:F
)
Whenev
er
p
ossible,
it
is
b
etter
to
use
b
ounded
than
un
b
ounded
quan
tication
in
a
sp
ecication.
This
mak
es
the
sp
ecication
easier
for
b
oth
p
eople
and
to
ols
to
understand.
Univ
ersal
quan
tication
generalizes
conjunction.
If
S
is
a
nite
set,
then
8
x
2
S
:
F
is
the
conjunction
of
the
form
ulas
obtained
b
y
substituting
the
dif-
feren
t
elemen
ts
of
S
for
x
in
F
.
F
or
example,
(8
x
2
f2;
3;
7g
:
x
<
y
x
)

(2
<
y
2
)
^
(3
<
y
3
)
^
(7
<
y
7
)
W
e
sometimes
informally
talk
ab
out
the
conjunction
of
an
innite
n
um
b
er
of
form
ulas
when
w
e
formally
mean
a
univ
ersally
quan
tied
form
ula.
F
or
example,
the
conjunction
of
the
form
ulas
x

y
x
for
all
natural
n
um
b
ers
x
is
the
form
ula
8
x
2
Nat
:
x

y
x
.
Similarly
,
existen
tial
quan
tication
generalizes
disjunction.
Logicians
ha
v
e
rules
for
pro
ving
predicate-logic
tautologies
suc
h
as
(1.1),
but
y
ou
shouldn't
need
them.
Y
ou
should
b
ecome
familiar
enough
with
predicate
logic
that
simple
tautologies
are
ob
vious.
Thinking
of
8
as
conjunction
and
9
as
disjunction
can
help.
F
or
example,
the
asso
ciativit
y
and
comm
utativit
y
of
conjunction
and
disjunction
lead
to
the
tautologies
(8
x
2
S
:
F
)
^
(8
x
2
S
:
G
)

(8
x
2
S
:
F
^
G
)
(9
x
2
S
:
F
)
_
(9
x
2
S
:
G
)

(9
x
2
S
:
F
_
G
)
for
an
y
set
S
and
form
ulas
F
and
G
.
Mathematicians
use
some
ob
vious
abbreviations
for
nested
quan
tiers.
F
or
example,
2
Strictly
sp
eaking,
2
isn't
an
op
erator
of
predicate
logic,
so
this
isn't
really
a
predicate-logic
tautology
.

14
CHAPTER
1.
A
LITTLE
SIMPLE
MA
TH
8
x
2
S
;
y
2
T
:
F
means
8
x
2
S
:
(8
y
2
T
:
F
)
9
w
;
x
;
y
;
z
2
S
:
F
means
9
w
2
S
:
(9
x
2
S
:
(9
y
2
S
:
(9
z
2
S
:
F
)))
In
the
expression
9
x
2
S
:
F
,
logicians
sa
y
that
x
is
a
b
ound
variable
and
that
o
ccurrences
of
x
in
F
are
b
ound.
F
or
example,
n
is
a
b
ound
v
ariable
in
the
form
ula
9
n
2
Nat
:
n
+
1
>
n
,
and
the
t
w
o
o
ccurrences
of
n
in
the
sub
expression
n
+
1
>
n
are
b
ound.
A
v
ariable
x
that's
not
b
ound
is
said
to
b
e
fr
e
e,
and
o
ccurrences
of
x
that
are
not
b
ound
are
called
fr
e
e
o
ccurrences.
This
terminology
is
rather
misleading.
A
b
ound
v
ariable
do
esn't
really
o
ccur
in
a
form
ula
b
ecause
replacing
it
b
y
some
new
v
ariable
do
esn't
c
hange
the
form
ula.
The
t
w
o
form
ulas
9
n
2
Nat
:
n
+
1
>
n
9
x
2
Nat
:
x
+
1
>
x
are
equiv
alen
t.
Calling
n
a
v
ariable
of
the
rst
form
ula
is
a
bit
lik
e
calling
a
a
v
ariable
of
that
form
ula
b
ecause
it
app
ears
in
the
name
Nat
.
Nev
ertheless,
it
is
con
v
enien
t
to
talk
ab
out
an
o
ccurrence
of
a
b
ound
v
ariable
in
a
form
ula.
1.4
F
orm
ulas
and
Language
When
y
ou
rst
studied
mathematics,
form
ulas
w
ere
statemen
ts.
The
form
ula
2

x
>
x
w
as
just
a
compact
w
a
y
of
writing
the
statemen
t
\2
times
x
is
greater
than
x
."
In
this
b
o
ok,
y
ou
are
en
tering
the
realm
of
logic,
where
a
form
ula
is
a
noun.
The
form
ula
2

x
>
x
is
just
a
form
ula;
it
ma
y
b
e
true
or
false,
dep
ending
on
the
v
alue
of
x
.
If
w
e
w
an
t
to
assert
that
this
form
ula
is
true,
meaning
that
2

x
really
is
greater
than
x
,
w
e
should
explicitly
write
\2

x
>
x
is
true."
Using
a
form
ula
in
place
of
a
statemen
t
can
lead
to
confusion.
On
the
other
hand,
form
ulas
are
more
compact
and
easier
to
read
than
prose.
Reading
2

x
>
x
is
easier
than
reading
\2

x
is
greater
than
x
";
and
\2

x
>
x
is
true"
ma
y
seem
redundan
t.
So,
lik
e
most
mathematicians,
I
will
often
write
sen
tences
lik
e
W
e
kno
w
that
x
is
p
ositiv
e,
so
2

x
>
x
.
If
it's
not
ob
vious
whether
a
form
ula
is
really
a
form
ula
or
is
the
statemen
t
that
the
form
ula
is
true,
here's
an
easy
w
a
y
to
tell.
Replace
the
form
ula
with
a
name
and
read
the
sen
tence.
If
the
sen
tence
is
grammatically
correct,
ev
en
though
nonsensical,
then
the
form
ula
is
a
form
ula;
otherwise,
it's
a
statemen
t.
The
form
ula
2

x
>
x
in
the
sen
tence
ab
o
v
e
is
a
statemen
t
b
ecause
W
e
kno
w
that
x
is
p
ositiv
e,
so
Mary
.
is
ungrammatical.
It
is
a
form
ula
in
the
sen
tence
T
o
pro
v
e
2

x
>
x
,
w
e
m
ust
pro
v
e
that
x
is
p
ositiv
e.
b
ecause
the
follo
wing
silly
sen
tence
is
grammatically
correct:
T
o
pro
v
e
F
red,
w
e
m
ust
pro
v
e
that
x
is
p
ositiv
e.

Chapter
2
Sp
ecifying
a
Simple
Clo
c
k
2.1
Beha
viors
Before
w
e
try
to
sp
ecify
a
system,
let's
lo
ok
at
ho
w
scien
tists
do
it.
F
or
cen
turies,
they
ha
v
e
describ
ed
a
system
with
equations
that
determine
ho
w
its
state
ev
olv
es
with
time,
where
the
state
consists
of
the
v
alues
of
v
ariables.
F
or
example,
the
state
of
the
system
comprising
the
earth
and
the
mo
on
migh
t
b
e
describ
ed
b
y
the
v
alues
of
the
four
v
ariables
e
p
os
,
m
p
os
,
e
vel
,
and
m
vel
,
represen
ting
the
p
ositions
and
v
elo
cities
of
the
t
w
o
b
o
dies.
These
v
alues
are
elemen
ts
in
a
3-
dimensional
space.
The
earth-mo
on
system
is
describ
ed
b
y
equations
expressing
the
v
ariables'
v
alues
as
functions
of
time
and
of
certain
constan
ts|namely
,
their
masses
and
initial
p
ositions
and
v
elo
cities.
A
b
eha
vior
of
the
earth-mo
on
system
consists
of
a
function
F
from
time
to
states,
F
(t
)
represen
ting
the
state
of
the
system
at
time
t
.
A
computer
system
diers
from
the
systems
traditionally
studied
b
y
scien
tists
b
ecause
w
e
can
pretend
that
its
state
c
hanges
in
discrete
steps.
So,
w
e
represen
t
the
execution
of
a
system
as
a
sequence
of
states.
F
ormally
,
w
e
dene
a
b
ehavior
to
b
e
a
sequence
of
states,
where
a
state
is
an
assignmen
t
of
v
alues
to
v
ariables.
W
e
sp
ecify
a
system
b
y
sp
ecifying
a
set
of
p
ossible
b
eha
viors|the
ones
represen
ting
a
correct
execution
of
the
system.
2.2
An
Hour
Clo
c
k
Let's
start
with
a
v
ery
trivial
system|a
digital
clo
c
k
that
displa
ys
only
the
hour.
T
o
mak
e
the
system
completely
trivial,
w
e
ignore
the
relation
b
et
w
een
the
displa
y
and
the
actual
time.
The
hour
clo
c
k
is
then
just
a
device
whose
displa
y
cycles
through
the
v
alues
1
through
12.
Let
the
v
ariable
hr
represen
t
the
clo
c
k's
15

16
CHAPTER
2.
SPECIFYING
A
SIMPLE
CLOCK
displa
y
.
A
t
ypical
b
eha
vior
of
the
clo
c
k
is
the
sequence
[hr
=
11]
!
[hr
=
12]
!
[hr
=
1]
!
[hr
=
2]
!



(2.1)
of
states,
where
[hr
=
11]
is
a
state
in
whic
h
the
v
ariable
hr
has
the
v
alue
11.
A
pair
of
successiv
e
states,
suc
h
as
[hr
=
1]
!
[hr
=
2],
is
called
a
step.
T
o
sp
ecify
the
hour
clo
c
k,
w
e
describ
e
all
its
p
ossible
b
eha
viors.
W
e
write
an
initial
pr
e
dic
ate
that
sp
ecies
the
p
ossible
initial
v
alues
of
hr
,
and
a
next-state
r
elation
that
sp
ecies
ho
w
the
v
alue
of
hr
can
c
hange
in
an
y
step.
W
e
don't
w
an
t
to
sp
ecify
exactly
what
the
displa
y
reads
initially;
an
y
hour
will
do.
So,
w
e
w
an
t
the
initial
predicate
to
assert
that
hr
can
ha
v
e
an
y
v
alue
from
1
through
12.
Let's
call
the
initial
predicate
HCini
.
W
e
migh
t
informally
dene
HCini
b
y
The
sym
b
ol

=
means
is
dene
d
to
e
qual.
HCini

=
hr
2
f1;
:
:
:
;
12g
Later,
w
e'll
see
ho
w
to
write
this
denition
formally
,
without
the
\.
.
.
"
that
stands
for
the
informal
and
so
on.
The
next-state
relation
HCnxt
is
a
form
ula
expressing
the
relation
b
et
w
een
the
v
alues
of
hr
in
the
old
(rst)
state
and
new
(second)
state
of
a
step.
W
e
let
hr
represen
t
the
v
alue
of
hr
in
the
old
state
and
hr
0
represen
t
its
v
alue
in
the
new
state.
(The
0
in
hr
0
is
read
prime.)
W
e
w
an
t
the
next-state
relation
to
assert
that
hr
0
equals
hr
+
1
except
if
hr
equals
12,
in
whic
h
case
hr
0
should
equal
1.
Using
an
if/then/else
construct
with
the
ob
vious
meaning,
w
e
can
dene
HCnxt
to
b
e
the
next-state
relation
b
y
writing
HCnxt

=
hr
0
=
if
hr
6=
12
then
hr
+
1
else
1
HCnxt
is
an
ordinary
mathematical
form
ula,
except
that
it
con
tains
primed
as
w
ell
as
unprimed
v
ariables.
Suc
h
a
form
ula
is
called
an
action.
An
action
is
true
or
false
of
a
step.
A
step
that
satises
the
action
HCnxt
is
called
an
HCnxt
step.
When
an
HCnxt
step
o
ccurs,
w
e
sometimes
sa
y
that
HCnxt
is
exe
cute
d.
Ho
w
ev
er,
it
w
ould
b
e
a
mistak
e
to
tak
e
this
terminology
seriously
.
An
action
is
a
form
ula,
and
form
ulas
aren't
executed.
W
e
w
an
t
our
sp
ecication
to
b
e
a
single
form
ula,
not
the
pair
of
form
ulas
HCini
and
HCnxt
.
This
form
ula
m
ust
assert
ab
out
a
b
eha
vior
that
(i)
its
initial
state
satises
HCini
,
and
(ii)
eac
h
of
its
steps
satises
HCnxt
.
W
e
express
(i)
as
the
form
ula
HCini
,
whic
h
w
e
in
terpret
as
a
statemen
t
ab
out
b
eha
viors
to
mean
that
the
initial
state
satises
HCini
.
T
o
express
(ii),
w
e
use
the
temp
oral-logic
op
erator
2
(pronounced
b
ox
).
The
temp
oral
form
ula
2F
asserts
that
form
ula
F
is
alw
a
ys
true.
In
particular,
2HCnxt
is
the
assertion
that
HCnxt
is
true
for
ev
ery
step
in
the
b
eha
vior.
So,
HCini
^
2HCnxt
is
true
of
a
b
eha
vior
i
the
initial
state
satises
HCini
and
ev
ery
step
satises
HCnxt
.
This
form
ula
describ
es
all
b
eha
viors
lik
e
the
one
in
(2.1)
on
this
page;
it
seems
to
b
e
the
sp
ecication
w
e're
lo
oking
for.

2.2.
AN
HOUR
CLOCK
17
If
w
e
considered
the
clo
c
k
only
in
isolation
and
nev
er
tried
to
relate
it
to
another
system,
then
this
w
ould
b
e
a
ne
sp
ecication.
Ho
w
ev
er,
supp
ose
the
clo
c
k
is
part
of
a
larger
system|for
example,
the
hour
displa
y
of
a
w
eather
station
that
displa
ys
the
curren
t
hour
and
temp
erature.
The
state
of
the
sta-
tion
is
describ
ed
b
y
t
w
o
v
ariables:
hr
,
represen
ting
the
hour
displa
y
,
and
tmp
,
represen
ting
the
temp
erature
displa
y
.
Consider
this
b
eha
vior
of
the
w
eather
station:

hr
=
11
tmp
=
23:5

!

hr
=
12
tmp
=
23:5

!

hr
=
12
tmp
=
23:4

!

hr
=
12
tmp
=
23:3

!

hr
=
1
tmp
=
23:3

!



In
the
second
and
third
steps,
tmp
c
hanges
but
hr
remains
the
same.
These
steps
are
not
allo
w
ed
b
y
2HCnxt
,
whic
h
asserts
that
ev
ery
step
m
ust
incremen
t
hr
.
The
form
ula
HCini
^
2HCnxt
do
es
not
describ
e
the
hour
clo
c
k
in
the
w
eather
station.
A
form
ula
that
describ
es
any
hour
clo
c
k
m
ust
allo
w
steps
that
lea
v
e
hr
unc
hanged|in
other
w
ords,
hr
0
=
hr
steps.
These
are
called
stuttering
steps
of
the
clo
c
k.
A
sp
ecication
of
the
hour
clo
c
k
should
allo
w
b
oth
HCnxt
steps
and
stuttering
steps.
So,
a
step
should
b
e
allo
w
ed
i
it
is
either
an
HCnxt
step
or
a
stuttering
step|that
is,
i
it
is
a
step
satisfying
HCnxt
_
(hr
0
=
hr
).
This
suggests
that
w
e
adopt
HCini
^
2(HCnxt
_
(hr
0
=
hr
))
as
our
sp
ecication.
In
TLA,
w
e
let
[HCnxt
]
hr
stand
for
HCnxt
_
(hr
0
=
hr
),
so
w
e
can
write
the
I
pronounce
[HCnxt
]
hr
as
squar
e
HCnxt
sub
hr
.
form
ula
more
compactly
as
HCini
^
2[HCnxt
]
hr
.
The
form
ula
HCini
^
2[HCnxt
]
hr
do
es
allo
w
stuttering
steps.
In
fact,
it
allo
ws
the
b
eha
vior
[hr
=
10]
!
[hr
=
11]
!
[hr
=
11]
!
[hr
=
11]
!



that
ends
with
an
innite
sequence
of
stuttering
steps.
This
b
eha
vior
describ
es
a
clo
c
k
whose
displa
y
attains
the
v
alue
11
and
then
k
eeps
that
v
alue
forev
er|in
other
w
ords,
a
clo
c
k
that
stops
at
11.
In
a
lik
e
manner,
w
e
can
represen
t
a
terminating
execution
of
an
y
system
b
y
an
innite
b
eha
vior
that
ends
with
a
sequence
of
nothing
but
stuttering
steps.
W
e
ha
v
e
no
need
of
nite
b
eha
viors
(nite
sequences
of
states),
so
w
e
consider
only
innite
ones.
It's
natural
to
require
that
a
clo
c
k
do
es
not
stop,
so
our
sp
ecication
should
assert
that
there
are
innitely
man
y
nonstuttering
steps.
Chapter
8
explains
ho
w
to
express
this
requiremen
t.
F
or
no
w,
w
e
con
ten
t
ourselv
es
with
clo
c
ks
that
ma
y
stop,
and
w
e
tak
e
as
our
sp
ecication
of
an
hour
clo
c
k
the
form
ula
HC
dened
b
y
HC

=
HCini
^
2[HCnxt
]
hr

18
CHAPTER
2.
SPECIFYING
A
SIMPLE
CLOCK
2.3
A
Closer
Lo
ok
at
the
Sp
ecication
A
state
is
an
assignmen
t
of
v
alues
to
v
ariables,
but
what
v
ariables?
The
answ
er
is
simple:
all
v
ariables.
In
the
b
eha
vior
(2.1)
on
page
16,
[hr
=
1]
represen
ts
some
particular
state
that
assigns
the
v
alue
1
to
hr
.
It
migh
t
assign
the
v
alue
23
to
the
v
ariable
tmp
and
the
v
alue
p
 17
to
the
v
ariable
m
p
os
.
W
e
can
think
of
a
state
as
represen
ting
a
p
oten
tial
state
of
the
en
tire
univ
erse.
A
state
that
assigns
1
to
hr
and
a
particular
p
oin
t
in
3-space
to
m
p
os
describ
es
a
state
of
the
univ
erse
in
whic
h
the
hour
clo
c
k
reads
1
and
the
mo
on
is
in
a
particular
place.
A
state
that
assigns
p
 2
to
hr
do
esn't
corresp
ond
to
an
y
state
of
the
univ
erse
that
w
e
recognize,
b
ecause
the
hour
clo
c
k
can't
displa
y
the
v
alue
p
 2
.
It
migh
t
represen
t
the
state
of
the
univ
erse
after
a
b
om
b
fell
on
the
clo
c
k,
making
its
displa
y
purely
imaginary
.
A
b
eha
vior
is
an
innite
sequence
of
states|for
example:
[hr
=
11]
!
[hr
=
77:2]
!
[hr
=
78:2]
!
[hr
=
p
 2
]
!



(2.2)
A
b
eha
vior
describ
es
a
p
oten
tial
history
of
the
univ
erse.
The
b
eha
vior
(2.2)
do
esn't
corresp
ond
to
a
history
that
w
e
understand,
b
ecause
w
e
don't
kno
w
ho
w
the
clo
c
k's
displa
y
can
c
hange
from
11
to
77.2.
Whatev
er
kind
of
history
it
represen
ts
is
not
one
in
whic
h
the
clo
c
k
is
doing
what
it's
supp
osed
to.
F
orm
ula
HC
is
a
temp
oral
form
ula.
A
temp
oral
form
ula
is
an
assertion
ab
out
b
eha
viors.
W
e
sa
y
that
a
b
eha
vior
satises
HC
i
HC
is
a
true
assertion
ab
out
the
b
eha
vior.
Beha
vior
(2.1)
satises
form
ula
HC
.
Beha
vior
(2.2)
do
es
not,
b
ecause
HC
asserts
that
ev
ery
step
satises
HCnxt
or
lea
v
es
hr
unc
hanged,
and
the
rst
and
third
steps
of
(2.2)
don't.
(The
second
step,
[hr
=
77:2]
!
[hr
=
78:2],
do
es
satisfy
HCnxt
.)
W
e
regard
form
ula
HC
to
b
e
the
sp
ecication
of
an
hour
clo
c
k
b
ecause
it
is
satised
b
y
exactly
those
b
eha
viors
that
represen
t
histories
of
the
univ
erse
in
whic
h
the
clo
c
k
functions
prop
erly
.
If
the
clo
c
k
is
b
eha
ving
prop
erly
,
then
its
displa
y
should
b
e
an
in
teger
from
1
through
12.
So,
hr
should
b
e
an
in
teger
from
1
through
12
in
ev
ery
state
of
an
y
b
eha
vior
satisfying
the
clo
c
k's
sp
ecication,
HC
.
F
orm
ula
HCini
asserts
that
hr
is
an
in
teger
from
1
through
12,
and
2HCini
asserts
that
HCini
is
alw
a
ys
true.
So,
2HCini
should
b
e
true
for
an
y
b
eha
vior
satisfying
HC
.
Another
w
a
y
of
sa
ying
this
is
that
HC
implies
2HCini
,
for
an
y
b
eha
vior.
Th
us,
the
form
ula
HC
)
2HCini
should
b
e
satised
b
y
every
b
eha
vior.
A
temp
oral
form
ula
satised
b
y
ev
ery
b
eha
vior
is
called
a
the
or
em,
so
HC
)
2HCini
should
b
e
a
theorem.
1
It's
easy
to
see
that
it
is:
HC
implies
that
HCini
is
true
initially
(in
the
rst
state
of
the
b
eha
vior),
and
2[HCnxt
]
hr
implies
that
eac
h
step
either
adv
ances
hr
to
its
prop
er
next
v
alue
or
else
lea
v
es
hr
unc
hanged.
W
e
can
formalize
this
reasoning
using
the
pro
of
rules
of
TLA,
but
w
e're
not
going
to
delv
e
in
to
pro
ofs
and
pro
of
rules.
1
Logicians
call
a
form
ula
valid
if
it
is
satised
b
y
ev
ery
b
eha
vior;
they
reserv
e
the
term
the
or
em
for
pro
v
ably
v
alid
form
ulas.

2.4.
THE
SPECIFICA
TION
IN
TLA
+
19
2.4
The
Sp
ecication
in
TLA
+
Figure
2.1
on
the
next
page
sho
ws
ho
w
the
hour-clo
c
k
sp
ecication
can
b
e
written
in
TLA
+
.
There
are
t
w
o
v
ersions:
the
asci
i
v
ersion
on
the
b
ottom
is
the
actual
TLA
+
sp
ecication,
the
w
a
y
y
ou
t
yp
e
it;
the
t
yp
eset
v
ersion
on
the
top
is
one
that
the
TLA
T
E
X
program,
describ
ed
in
Chapter
13,
migh
t
pro
duce.
Before
trying
to
understand
the
sp
ecication,
observ
e
the
relation
b
et
w
een
the
t
w
o
syn
taxes.

Reserv
ed
w
ords
that
app
ear
in
small
upp
er-case
letters
(lik
e
extends)
are
written
in
asci
i
with
ordinary
upp
er-case
letters.

When
p
ossible,
sym
b
ols
are
represen
ted
pictorially
in
asci
i|for
example,
2
is
t
yp
ed
as
[
]
and
6=
as
#.
(Y
ou
can
also
t
yp
e
6=
as
/=.)

When
there
is
no
go
o
d
asci
i
represen
tation,
T
E
X
notation
2
is
used|for
example,
2
is
t
yp
ed
as
\in.
The
ma
jor
exception
is

=
,
whic
h
is
t
yp
ed
as
=
=
.
A
complete
list
of
sym
b
ols
and
their
asci
i
equiv
alen
ts
app
ears
in
T
able
8
on
page
273.
I
will
usually
sho
w
the
t
yp
eset
v
ersion
of
a
sp
ecication;
the
asci
i
v
ersions
of
all
the
sp
ecications
in
this
b
o
ok
can
b
e
found
through
the
TLA
W
eb
page.
No
w
let's
lo
ok
at
what
the
sp
ecication
sa
ys.
It
starts
with
module
HourClo
ck
whic
h
b
egins
a
mo
dule
named
HourClo
ck
.
TLA
+
sp
ecications
are
partitioned
in
to
mo
dules;
the
hour
clo
c
k's
sp
ecication
consists
of
this
single
mo
dule.
Arithmetic
op
erators
lik
e
+
are
not
built
in
to
TLA
+
,
but
are
themselv
es
dened
in
mo
dules.
(Y
ou
migh
t
w
an
t
to
write
a
sp
ecication
in
whic
h
+
means
addition
of
matrices
rather
than
n
um
b
ers.)
The
usual
op
erators
on
natural
n
um
b
ers
are
dened
in
the
Natur
als
mo
dule.
Their
denitions
are
incorp
orated
in
to
mo
dule
HourClo
ck
b
y
the
statemen
t
extends
Natur
als
Ev
ery
sym
b
ol
that
app
ears
in
a
form
ula
m
ust
either
b
e
a
built-in
op
erator
of
TLA
+
,
or
else
it
m
ust
b
e
declared
or
dened.
The
statemen
t
v
ariable
hr
declares
hr
to
b
e
a
v
ariable.
2
The
T
E
X
t
yp
esetting
system
is
describ
ed
in
The
T
E
Xb
o
ok
b
y
Donald
E.
Kn
uth,
published
b
y
Addison-W
esley
,
Reading,
Massac
h
usetts,
1986.

20
CHAPTER
2.
SPECIFYING
A
SIMPLE
CLOCK
module
HourClo
ck
extends
Natur
als
v
ariable
hr
HCini

=
hr
2
(1
:
:
12)
HCnxt

=
hr
0
=
if
hr
6=
12
then
hr
+
1
else
1
HC

=
HCini
^
2[HCnxt
]
hr
theorem
HC
)
2HCini
----------------
---
--
-
MODULE
HourClock
---------------
---
--
--
EXTENDS
Naturals
VARIABLE
hr
HCini
==
hr
\in
(1
..
12)
HCnxt
==
hr'
=
IF
hr
#
12
THEN
hr
+
1
ELSE
1
HC
==
HCini
/\
[][HCnxt]_hr
----------------
---
--
---
--
---
--
--
---
--
---
--
--
---
--
---
--
---
--
--
THEOREM
HC
=>
[]HCini
================
===
==
===
==
===
==
==
===
==
===
==
==
===
==
===
==
===
==
==
Figure
2.1:
The
hour-clo
c
k
sp
ecication|t
yp
eset
and
ASCI
I
v
ersions.
T
o
dene
HCini
,
w
e
need
to
express
the
set
f1;
:
:
:
;
12g
formally
,
without
the
ellipsis
\.
.
.
".
W
e
can
write
this
set
out
completely
as
f1;
2;
3;
4;
5;
6;
7;
8;
9;
10
;
11
;
12
g
but
that's
tiresome.
Instead,
w
e
use
the
op
erator
\
:
:",
dened
in
the
Natur
als
mo
dule,
to
write
this
set
as
1
:
:
12.
In
general
i
:
:
j
is
the
set
of
in
tegers
from
i
through
j
,
for
an
y
in
tegers
i
and
j
.
(It
equals
the
empt
y
set
if
j
<
i
.)
It's
no
w
ob
vious
ho
w
to
write
the
denition
of
HCini
.
The
denitions
of
HCnxt
and
HC
are
written
just
as
b
efore.
(The
ordinary
mathematical
op
erators
of
logic
and
set
theory
,
lik
e
^
and
2,
are
built
in
to
TLA
+
.)
The
line
can
app
ear
an
ywhere
b
et
w
een
statemen
ts;
it's
purely
cosmetic
and
has
no
mean-
ing.
F
ollo
wing
it
is
the
statemen
t
theorem
HC
)
2HCini
of
the
theorem
that
w
as
discussed
ab
o
v
e.
This
statemen
t
asserts
that
the
form
ula
HC
)
2HCini
is
true
in
the
con
text
of
the
statemen
t.
More
precisely
,
it

2.5.
AN
AL
TERNA
TIVE
SPECIFICA
TION
21
asserts
that
the
form
ula
follo
ws
logically
from
the
denitions
in
this
mo
dule,
the
denitions
in
the
Natur
als
mo
dule,
and
the
rules
of
TLA
+
.
If
the
form
ula
w
ere
not
true,
then
the
mo
dule
w
ould
b
e
incorrect.
The
mo
dule
is
terminated
b
y
the
sym
b
ol
The
sp
ecication
of
the
hour
clo
c
k
is
the
denition
of
HC
,
including
the
denitions
of
the
form
ulas
HCnxt
and
HCini
and
of
the
op
erators
:
:
and
+
that
app
ear
in
the
denition
of
HC
.
F
ormally
,
nothing
in
the
mo
dule
tells
us
that
HC
rather
than
HCini
is
the
clo
c
k's
sp
ecication.
TLA
+
is
a
language
for
writing
mathematics|in
particular,
for
writing
mathematical
denitions
and
theorems.
What
those
denitions
represen
t,
and
what
signicance
w
e
attac
h
to
those
theorems,
lies
outside
the
scop
e
of
mathematics
and
therefore
outside
the
scop
e
of
TLA
+
.
Engineering
requires
not
just
the
abilit
y
to
use
mathematics,
but
the
abilit
y
to
understand
what,
if
an
ything,
the
mathematics
tells
us
ab
out
an
actual
system.
2.5
An
Alternativ
e
Sp
ecication
The
Natur
als
mo
dule
also
denes
the
mo
dulus
op
erator,
whic
h
w
e
write
%.
The
form
ula
i
%
n
,
whic
h
mathematicians
write
i
mo
d
n
,
is
the
remainder
when
i
is
divided
b
y
n
.
More
formally
,
i
%
n
is
the
natural
n
um
b
er
less
than
n
satisfying
i
=
q

n
+
(i
%
n
)
for
some
natural
n
um
b
er
q
.
Let's
express
this
condition
mathematically
.
The
Natur
als
mo
dule
denes
Nat
to
b
e
the
set
of
natural
n
um
b
ers,
and
the
assertion
that
there
exists
a
q
in
the
set
Nat
satisfying
a
form
ula
F
is
written
9
q
2
Nat
:
F
.
Th
us,
if
i
and
n
are
elemen
ts
of
Nat
and
n
>
0,
then
i
%
n
is
the
unique
n
um
b
er
satisfying
(i
%
n
2
0
:
:
(n
 1))
^
(9
q
2
Nat
:
i
=
q

n
+
(i
%
n
))
W
e
can
use
%
to
simplify
our
hour-clo
c
k
sp
ecication
a
bit.
Observing
that
(11
%
12)
+
1
equals
12
and
(12
%
12)
+
1
equals
1,
w
e
can
dene
a
dieren
t
next-
state
action
HCnxt
2
and
a
dieren
t
form
ula
HC
2
to
b
e
the
clo
c
k
sp
ecication
HCnxt
2

=
hr
0
=
(hr
%
12)
+
1
HC
2

=
HCini
^
2[HCnxt
2]
hr
Actions
HCnxt
and
HCnxt
2
are
not
equiv
alen
t.
The
step
[hr
=
24]
!
[hr
=
25]
satises
HCnxt
but
not
HCnxt
2,
while
the
step
[hr
=
24]
!
[hr
=
1]
satises
HCnxt
2
but
not
HCnxt
.
Ho
w
ev
er,
an
y
step
starting
in
a
state
with
hr
in
1
:
:
12
satises
HCnxt
i
it
satises
HCnxt
2.
It's
therefore
not
hard
to
deduce
that
an
y
b
eha
vior
starting
in
a
state
satisfying
HCini
satises
2[HCnxt
]
hr
i
it
satises
2[HCnxt
2]
hr
.
Hence,
form
ulas
HC
and
HC
2
ar
e
equiv
alen
t.
In
other
w
ords,
HC

HC
2
is
a
theorem.
It
do
esn't
matter
whic
h
of
the
t
w
o
form
ulas
w
e
tak
e
to
b
e
the
sp
ecication
of
an
hour
clo
c
k.

22
CHAPTER
2.
SPECIFYING
A
SIMPLE
CLOCK
Mathematics
pro
vides
innitely
man
y
w
a
ys
of
expressing
the
same
thing.
The
expressions
6
+
6,
3

4,
and
141
 129
all
ha
v
e
the
same
meaning;
they
are
just
dieren
t
w
a
ys
of
writing
the
n
um
b
er
12.
W
e
could
replace
either
instance
of
the
n
um
b
er
12
in
mo
dule
HourClo
ck
b
y
an
y
of
these
expressions
without
c
hanging
the
meaning
of
an
y
of
the
mo
dule's
form
ulas.
When
writing
a
sp
ecication,
y
ou
will
often
b
e
faced
with
a
c
hoice
of
ho
w
to
express
something.
When
that
happ
ens,
y
ou
should
rst
mak
e
sure
that
the
c
hoices
yield
equiv
alen
t
sp
ecications.
If
they
do,
then
y
ou
can
c
ho
ose
the
one
that
y
ou
feel
mak
es
the
sp
ecication
easiest
to
understand.
If
they
don't,
then
y
ou
m
ust
decide
whic
h
one
y
ou
mean.

Chapter
3
An
Async
hronous
In
terface
W
e
no
w
sp
ecify
an
in
terface
for
transmitting
data
b
et
w
een
async
hronous
devices.
A
sender
and
a
r
e
c
eiver
are
connected
as
sho
wn
here.
Sender
Receiv
er
val
r
dy
-
-
ack

Data
is
sen
t
on
val
,
and
the
r
dy
and
ack
lines
are
used
for
sync
hronization.
The
sender
m
ust
w
ait
for
an
ac
kno
wledgmen
t
(an
A
ck
)
for
one
data
item
b
efore
it
can
send
the
next.
The
in
terface
uses
the
standard
t
w
o-phase
handshak
e
proto
col,
describ
ed
b
y
the
follo
wing
sample
b
eha
vior:
2
4
val
=
26
r
dy
=
0
ack
=
0
3
5
Send
37
 !
2
4
val
=
37
r
dy
=
1
ack
=
0
3
5
A
ck
 !
2
4
val
=
37
r
dy
=
1
ack
=
1
3
5
Send
4
 !
2
4
val
=
4
r
dy
=
0
ack
=
1
3
5
A
ck
 !
2
4
val
=
4
r
dy
=
0
ack
=
0
3
5
Send
19
 !
2
4
val
=
19
r
dy
=
1
ack
=
0
3
5
A
ck
 !



(It
do
esn't
matter
what
v
alue
val
has
in
the
initial
state.)
It's
easy
to
see
from
this
sample
b
eha
vior
what
the
set
of
all
p
ossible
b
eha
v-
iors
should
b
e|once
w
e
decide
what
the
data
v
alues
are
that
can
b
e
sen
t.
But,
b
efore
writing
the
TLA
+
sp
ecication
that
describ
es
these
b
eha
viors,
let's
lo
ok
at
what
I'v
e
just
done.
In
writing
this
b
eha
vior,
I
made
the
decision
that
val
and
r
dy
should
c
hange
in
a
single
step.
The
v
alues
of
the
v
ariables
val
and
r
dy
represen
t
v
oltages
23

24
CHAPTER
3.
AN
ASYNCHR
ONOUS
INTERF
A
CE
on
some
set
of
wires
in
the
ph
ysical
device.
V
oltages
on
dieren
t
wires
don't
c
hange
at
precisely
the
same
instan
t.
I
decided
to
ignore
this
asp
ect
of
the
ph
ysical
system
and
pretend
that
the
v
alues
of
val
and
r
dy
represen
ted
b
y
those
v
oltages
c
hange
instan
taneously
.
This
simplies
the
sp
ecication,
but
at
the
price
of
ignoring
what
ma
y
b
e
an
imp
ortan
t
detail
of
the
system.
In
an
actual
implemen
tation
of
the
proto
col,
the
v
oltage
on
the
r
dy
line
shouldn't
c
hange
un
til
the
v
oltages
on
the
val
lines
ha
v
e
stabilized;
but
y
ou
w
on't
learn
that
from
m
y
sp
ecication.
Had
I
w
an
ted
the
sp
ecication
to
con
v
ey
this
requiremen
t,
I
w
ould
ha
v
e
written
a
b
eha
vior
in
whic
h
the
v
alue
of
val
and
the
v
alue
of
r
dy
c
hange
in
separate
steps.
A
sp
ecication
is
an
abstraction.
It
describ
es
some
asp
ects
of
the
system
and
ignores
others.
W
e
w
an
t
the
sp
ecication
to
b
e
as
simple
as
p
ossible,
so
w
e
w
an
t
to
ignore
as
man
y
details
as
w
e
can.
But,
whenev
er
w
e
omit
some
asp
ect
of
the
system
from
the
sp
ecication,
w
e
admit
a
p
oten
tial
source
of
error.
With
m
y
sp
ecication,
w
e
can
v
erify
the
correctness
of
a
system
that
uses
this
in
terface,
and
the
system
could
still
fail
b
ecause
the
implemen
ter
didn't
kno
w
that
the
val
line
should
stabilize
b
efore
the
r
dy
line
is
c
hanged.
The
hardest
part
of
writing
a
sp
ecication
is
c
ho
osing
the
prop
er
abstraction.
I
can
teac
h
y
ou
ab
out
TLA
+
,
so
expressing
an
abstract
view
of
a
system
as
a
TLA
+
sp
ecication
b
ecomes
a
straigh
tforw
ard
task.
But
I
don't
kno
w
ho
w
to
teac
h
y
ou
ab
out
abstraction.
A
go
o
d
engineer
kno
ws
ho
w
to
abstract
the
essence
of
a
system
and
suppress
the
unimp
ortan
t
details
when
sp
ecifying
and
designing
it.
The
art
of
abstraction
is
learned
only
through
exp
erience.
When
writing
a
sp
ecication,
y
ou
m
ust
rst
c
ho
ose
the
abstraction.
In
a
TLA
+
sp
ecication,
this
means
c
ho
osing
the
v
ariables
that
represen
t
the
system's
state
and
the
gran
ularit
y
of
the
steps
that
c
hange
those
v
ariables'
v
alues.
Should
the
r
dy
and
ack
lines
b
e
represen
ted
as
separate
v
ariables
or
as
a
single
v
ariable?
Should
val
and
r
dy
c
hange
in
one
step,
t
w
o
steps,
or
an
arbitrary
n
um
b
er
of
steps?
T
o
help
mak
e
these
c
hoices,
I
recommend
that
y
ou
start
b
y
writing
the
rst
few
steps
of
one
or
t
w
o
sample
b
eha
viors,
just
as
I
did
at
the
b
eginning
of
this
section.
Chapter
7
has
more
to
sa
y
ab
out
these
c
hoices.
3.1
The
First
Sp
ecication
Let's
sp
ecify
the
async
hronous
in
terface
with
a
mo
dule
AsynchInterfac
e
.
The
sp
ecication
uses
subtraction
of
natural
n
um
b
ers,
so
our
mo
dule
extends
the
Natur
als
mo
dule
to
incorp
orate
the
denition
of
the
subtraction
op
erator
\ ".
W
e
next
decide
what
the
p
ossible
v
alues
of
val
should
b
e|that
is,
what
data
v
alues
ma
y
b
e
sen
t.
W
e
could
write
a
sp
ecication
that
places
no
restriction
on
the
data
v
alues.
The
sp
ecication
could
allo
w
the
sender
rst
to
send
37,
then
to
send
p
 15
,
and
then
to
send
Nat
(the
en
tire
set
of
natural
n
um
b
ers).
Ho
w
ev
er,
an
y
real
device
can
send
only
a
restricted
set
of
v
alues.
W
e
could
pic
k

3.1.
THE
FIRST
SPECIFICA
TION
25
some
sp
ecic
set|for
example,
32-bit
n
um
b
ers.
Ho
w
ev
er,
the
proto
col
is
the
same
regardless
of
whether
it's
used
to
send
32-bit
n
um
b
ers
or
128-bit
n
um
b
ers.
So,
w
e
compromise
b
et
w
een
the
t
w
o
extremes
of
allo
wing
an
ything
to
b
e
sen
t
and
allo
wing
only
32-bit
n
um
b
ers
to
b
e
sen
t
b
y
assuming
only
that
there
is
some
set
Data
of
data
v
alues
that
ma
y
b
e
sen
t.
The
constan
t
Data
is
a
parameter
of
the
sp
ecication.
It's
declared
b
y
the
statemen
t
const
ant
Data
Our
three
v
ariables
are
declared
b
y
v
ariables
val
;
r
dy
;
ack
The
k
eyw
ords
v
ariable
and
v
ariables
are
synon
ymous,
as
are
const
ant
and
const
ants.
The
v
ariable
r
dy
can
assume
an
y
v
alue|for
example,
 1=2.
That
is,
there
exist
states
that
assign
the
v
alue
 1=2
to
r
dy
.
When
discussing
the
sp
ecication,
w
e
usually
sa
y
that
r
dy
can
assume
only
the
v
alues
0
and
1.
What
w
e
really
mean
is
that
the
v
alue
of
r
dy
equals
0
or
1
in
ev
ery
state
of
an
y
b
eha
vior
satisfying
the
sp
ecication.
But
a
reader
of
the
sp
ecication
shouldn't
ha
v
e
to
understand
the
complete
sp
ecication
to
gure
this
out.
W
e
can
mak
e
the
sp
ecication
easier
to
understand
b
y
telling
the
reader
what
v
alues
the
v
ariables
can
assume
in
a
b
eha
vior
that
satises
the
sp
ecication.
W
e
could
do
this
with
commen
ts,
but
I
prefer
to
use
a
denition
lik
e
this
one:
T
yp
eInvariant

=
(val
2
Data
)
^
(r
dy
2
f0;
1g)
^
(ack
2
f0;
1g)
I
call
the
set
f0;
1g
the
typ
e
of
r
dy
,
and
I
call
T
yp
eInvariant
a
typ
e
invariant.
Let's
dene
typ
e
and
some
other
terms
more
precisely
.

A
state
function
is
an
ordinary
expression
(one
with
no
prime
or
2)
that
can
con
tain
v
ariables
and
constan
ts.

A
state
pr
e
dic
ate
is
a
Bo
olean-v
alued
state
function.

An
invariant
Inv
of
a
sp
ecication
Sp
e
c
is
a
state
predicate
suc
h
that
Sp
e
c
)
2Inv
is
a
theorem.

A
v
ariable
v
has
typ
e
T
in
a
sp
ecication
Sp
e
c
i
v
2
T
is
an
in
v
arian
t
of
Sp
e
c
.
W
e
can
mak
e
the
denition
of
T
yp
eInvariant
easier
to
read
b
y
writing
it
as
follo
ws.
T
yp
eInvariant

=
^
val
2
Data
^
r
dy
2
f0;
1g
^
ack
2
f0;
1g

26
CHAPTER
3.
AN
ASYNCHR
ONOUS
INTERF
A
CE
Eac
h
conjunct
b
egins
with
a
^
and
m
ust
lie
completely
to
the
righ
t
of
that
^.
(The
conjunct
ma
y
o
ccup
y
m
ultiple
lines).
W
e
use
a
similar
notation
for
disjunctions.
When
using
this
bulleted-list
notation,
the
^'s
or
_'s
m
ust
line
up
precisely
(ev
en
in
the
asci
i
input).
Because
the
inden
tation
is
signican
t,
w
e
can
eliminate
paren
theses,
making
this
notation
esp
ecially
useful
when
conjunctions
and
disjunctions
are
nested.
The
form
ula
T
yp
eInvariant
will
not
app
ear
as
part
of
the
sp
ecication.
W
e
do
not
assume
that
T
yp
eInvariant
is
an
in
v
arian
t;
the
sp
ecication
should
imply
that
it
is.
In
fact,
its
in
v
ariance
will
b
e
asserted
as
a
theorem.
The
initial
predicate
is
straigh
tforw
ard.
Initially
,
val
can
equal
an
y
elemen
t
of
Data
.
W
e
can
start
with
r
dy
and
ack
either
b
oth
0
or
b
oth
1.
Init

=
^
val
2
Data
^
r
dy
2
f0;
1g
^
ack
=
r
dy
No
w
for
the
next-state
action
Next
.
A
step
of
the
proto
col
either
sends
a
v
alue
or
receiv
es
a
v
alue.
W
e
dene
separately
the
t
w
o
actions
Send
and
R
cv
that
describ
e
the
sending
and
receiving
of
a
v
alue.
A
Next
step
(one
satisfying
action
Next
)
is
either
a
Send
step
or
a
R
cv
step,
so
it
is
a
Send
_
R
cv
step.
Therefore,
Next
is
dened
to
equal
Send
_
R
cv
.
Let's
no
w
dene
Send
and
R
cv
.
W
e
sa
y
that
action
Send
is
enable
d
in
a
state
from
whic
h
it
is
p
ossible
to
tak
e
a
Send
step.
F
rom
the
sample
b
eha
vior
ab
o
v
e,
w
e
see
that
Send
is
enabled
i
r
dy
equals
ack
.
Usually
,
the
rst
question
w
e
ask
ab
out
an
action
is,
when
is
it
enabled?
So,
the
denition
of
an
action
usually
b
egins
with
its
enabling
condition.
The
rst
conjunct
in
the
denition
of
Send
is
therefore
r
dy
=
ack
.
The
next
conjuncts
tell
us
what
the
new
v
alues
of
the
v
ariables
val
,
r
dy
,
and
ack
are.
The
new
v
alue
val
0
of
val
can
b
e
an
y
elemen
t
of
Data
|that
is,
an
y
v
alue
satisfying
val
0
2
Data
.
The
v
alue
of
r
dy
c
hanges
from
0
to
1
or
from
1
to
0,
so
r
dy
0
equals
1
 r
dy
(b
ecause
1
=
1
 0
and
0
=
1
 1).
The
v
alue
of
ack
is
left
unc
hanged.
TLA
+
denes
unchanged
v
to
mean
that
the
expression
v
has
the
same
v
alue
in
the
old
and
new
states.
More
precisely
,
unchanged
v
equals
v
0
=
v
,
where
v
0
is
the
expression
obtained
from
v
b
y
priming
all
its
v
ariables.
So,
w
e
dene
Send
b
y
Send

=
^
r
dy
=
ack
^
val
0
2
Data
^
r
dy
0
=
1
 r
dy
^
unchanged
ack
(I
could
ha
v
e
written
ack
0
=
ack
instead
of
unchanged
ack
,
but
I
prefer
to
use
the
unchanged
construct
in
sp
ecications.)
A
R
cv
step
is
enabled
i
r
dy
is
dieren
t
from
ack
;
it
complemen
ts
the
v
alue
of
ack
and
lea
v
es
val
and
r
dy
unc
hanged.
Both
val
and
r
dy
are
left
unc
hanged
i

3.1.
THE
FIRST
SPECIFICA
TION
27
module
AsynchInterfac
e
extends
Natur
als
const
ant
Data
v
ariables
val
;
r
dy
;
ack
T
yp
eInvariant

=
^
val
2
Data
^
r
dy
2
f0;
1g
^
ack
2
f0;
1g
Init

=
^
val
2
Data
^
r
dy
2
f0;
1g
^
ack
=
r
dy
Send

=
^
r
dy
=
ack
^
val
0
2
Data
^
r
dy
0
=
1
 r
dy
^
unchanged
ack
R
cv

=
^
r
dy
6=
ack
^
ack
0
=
1
 ack
^
unchanged
h
val
;
r
dy
i
Next

=
Send
_
R
cv
Sp
e
c

=
Init
^
2[Next
]
h
val
;r
dy
;ack
i
theorem
Sp
e
c
)
2T
yp
eInvariant
Figure
3.1:
Our
rst
sp
ecication
of
an
async
hronous
in
terface.
the
pair
of
v
alues
val
,
r
dy
is
left
unc
hanged.
TLA
+
uses
angle
brac
k
ets
h
and
i
to
enclose
ordered
tuples,
so
R
cv
asserts
that
h
val
;
r
dy
i
is
left
unc
hanged.
(Angle
brac
k
ets
are
t
yp
ed
in
asci
i
as
<<
and
>>.)
The
denition
of
R
cv
is
therefore
R
cv

=
^
r
dy
6=
ack
^
ack
0
=
1
 ack
^
unchanged
h
val
;
r
dy
i
As
in
our
clo
c
k
example,
the
complete
sp
ecication
Sp
e
c
should
allo
w
stuttering
steps|in
this
case,
ones
that
lea
v
e
all
three
v
ariables
unc
hanged.
So,
Sp
e
c
allo
ws
steps
that
lea
v
e
h
val
;
r
dy
;
ack
i
unc
hanged.
Its
denition
is
Sp
e
c

=
Init
^
2[Next
]
h
val
;r
dy
;ack
i
Mo
dule
AsynchInterfac
e
also
asserts
the
in
v
ariance
of
T
yp
eInvariant
.
It
app
ears
in
full
in
Figure
3.1
on
this
page.

28
CHAPTER
3.
AN
ASYNCHR
ONOUS
INTERF
A
CE
3.2
Another
Sp
ecication
Mo
dule
AsynchInterfac
e
is
a
ne
description
of
the
in
terface
and
its
handshak
e
proto
col.
Ho
w
ev
er,
it's
not
w
ell
suited
for
helping
to
sp
ecify
systems
that
use
the
in
terface.
Let's
rewrite
the
in
terface
sp
ecication
in
a
form
that
mak
es
it
more
con
v
enien
t
to
use
as
part
of
a
larger
sp
ecication.
The
rst
problem
with
the
original
sp
ecication
is
that
it
uses
three
v
ariables
to
describ
e
a
single
in
terface.
A
system
migh
t
use
sev
eral
dieren
t
instances
of
the
in
terface.
T
o
a
v
oid
a
proliferation
of
v
ariables,
w
e
replace
the
three
v
ariables
val
,
r
dy
,
ack
with
a
single
v
ariable
chan
(short
for
channel
).
A
mathematician
w
ould
do
this
b
y
letting
the
v
alue
of
chan
b
e
an
ordered
triple|for
example,
a
state
[chan
=
h
 1=2;
0;
1
i]
migh
t
replace
the
state
with
val
=
 1=2,
r
dy
=
0,
and
ack
=
1.
But
programmers
ha
v
e
learned
that
using
tuples
lik
e
this
leads
to
mistak
es;
it's
easy
to
forget
if
the
ack
line
is
represen
ted
b
y
the
second
or
third
comp
onen
t.
TLA
+
therefore
pro
vides
records
in
addition
to
more
con
v
en
tional
mathematical
notation.
Let's
represen
t
the
state
of
the
c
hannel
as
a
record
with
val
,
r
dy
,
and
ack
elds.
If
r
is
suc
h
a
record,
then
r
:val
is
its
val
eld.
The
t
yp
e
in
v
arian
t
asserts
that
the
v
alue
of
chan
is
an
elemen
t
of
the
set
of
all
suc
h
records
r
in
whic
h
r
:val
is
an
elemen
t
of
the
set
Data
and
r
:r
dy
and
r
:ack
are
elemen
ts
of
the
set
f0;
1g.
This
set
of
records
is
written
[val
:
Data
;
r
dy
:
f0;
1g;
ack
:
f0;
1g]
The
elds
of
a
record
are
not
ordered,
so
it
do
esn't
matter
in
what
order
w
e
write
them.
This
same
set
of
records
can
also
b
e
written
as
[ack
:
f0;
1g;
val
:
Data
;
r
dy
:
f0;
1g]
Initially
,
chan
can
equal
an
y
elemen
t
of
this
set
whose
ack
and
r
dy
elds
are
equal,
so
the
initial
predicate
is
the
conjunction
of
the
t
yp
e
in
v
arian
t
and
the
condition
chan
:ack
=
chan
:r
dy
.
A
system
that
uses
the
in
terface
ma
y
p
erform
an
op
eration
that
sends
some
data
v
alue
d
and
p
erforms
some
other
c
hanges
that
dep
end
on
the
v
alue
d
.
W
e'd
lik
e
to
represen
t
suc
h
an
op
eration
as
an
action
that
is
the
conjunction
of
t
w
o
separate
actions:
one
that
describ
es
the
sending
of
d
and
the
other
that
describ
es
the
other
c
hanges.
Th
us,
instead
of
dening
an
action
Send
that
sends
some
unsp
ecied
data
v
alue,
w
e
dene
the
action
Send
(d
)
that
sends
data
v
alue
d
.
The
next-state
action
is
satised
b
y
a
Send
(d
)
step,
for
some
d
in
Data
,
or
a
R
cv
step.
(The
v
alue
receiv
ed
b
y
a
R
cv
step
equals
chan
:val
.)
Sa
ying
that
a
step
is
a
Send
(d
)
step
for
some
d
in
Data
means
that
there
exists
a
d
in
Data
suc
h
that
the
step
satises
Send
(d
)|in
other
w
ords,
that
the
step
is
an
9
d
2
Data
:
Send
(d
)
step.
So
w
e
dene
Next

=
(9
d
2
Data
:
Send
(d
))
_
R
cv

3.2.
ANOTHER
SPECIFICA
TION
29
The
Send
(d
)
action
asserts
that
chan
0
equals
the
record
r
suc
h
that
r
:val
=
d
r
:r
dy
=
1
 chan
:r
dy
r
:ack
=
chan
:ack
This
record
is
written
in
TLA
+
as
[val
7!
d
;
r
dy
7!
1
 chan
:r
dy
;
ack
7!
chan
:ack
]
(The
sym
b
ol
7!
is
t
yp
ed
in
asci
i
as
|->
.)
Since
the
elds
of
records
are
not
ordered,
this
record
can
just
as
w
ell
b
e
written
[ack
7!
chan
:ack
;
val
7!
d
;
r
dy
7!
1
 chan
:r
dy
]
The
enabling
condition
of
Send
(d
)
is
that
the
r
dy
and
ack
lines
are
equal,
so
w
e
can
dene
Send
(d
)

=
^
chan
:r
dy
=
chan
:ack
^
chan
0
=
[val
7!
d
;
r
dy
7!
1
 chan
:r
dy
;
ack
7!
chan
:ack
]
This
is
a
p
erfectly
go
o
d
denition
of
Send
(d
).
Ho
w
ev
er,
I
prefer
a
sligh
tly
dieren
t
one.
W
e
can
describ
e
the
v
alue
of
chan
0
b
y
sa
ying
that
it
is
the
same
as
the
v
alue
of
chan
except
that
its
val
eld
equals
d
and
its
r
dy
eld
equals
1
 chan
:r
dy
.
In
TLA
+
,
w
e
can
write
this
v
alue
as
[chan
ex
cept
!
:val
=
d
;
!
:r
dy
=
1
 chan
:r
dy
]
Think
of
the
!
as
standing
for
the
new
record
that
the
ex
cept
expression
forms
b
y
mo
difying
chan
.
So,
the
expression
can
b
e
read
as
the
record
!
that
is
the
same
as
chan
except
!
:val
equals
d
and
!
:r
dy
equals
1
 chan
:r
dy
.
In
the
expression
that
!
:r
dy
equals,
the
sym
b
ol
@
stands
for
chan
:r
dy
,
so
w
e
can
write
this
ex
cept
expression
as
[chan
ex
cept
!
:val
=
d
;
!
:r
dy
=
1
 @]
In
general,
for
an
y
record
r
,
the
expression
[r
ex
cept
!
:c
1
=
e
1
;
:
:
:
;
!
:c
n
=
e
n
]
is
the
record
obtained
from
r
b
y
replacing
r
:c
i
with
e
i
,
for
eac
h
i
in
1
:
:
n
.
An
@
in
the
expression
e
i
stands
for
r
:c
i
.
Using
this
notation,
w
e
dene
Send
(d
)

=
^
chan
:r
dy
=
chan
:ack
^
chan
0
=
[chan
ex
cept
!
:val
=
d
;
!
:r
dy
=
1
 @]
The
denition
of
R
cv
is
straigh
tforw
ard.
A
v
alue
can
b
e
receiv
ed
when
chan
:r
dy
do
es
not
equal
chan
:ack
,
and
receiving
the
v
alue
complemen
ts
chan
:ack
:
R
cv

=
^
chan
:r
dy
6=
chan
:ack
^
chan
0
=
[chan
ex
cept
!
:ack
=
1
 @]
The
complete
sp
ecication
app
ears
in
Figure
3.2
on
the
next
page.

30
CHAPTER
3.
AN
ASYNCHR
ONOUS
INTERF
A
CE
module
Channel
extends
Natur
als
const
ant
Data
v
ariable
chan
T
yp
eInvariant

=
chan
2
[val
:
Data
;
r
dy
:
f0;
1g;
ack
:
f0;
1g]
Init

=
^
T
yp
eInvariant
^
chan
:ack
=
chan
:r
dy
Send
(d
)

=
^
chan
:r
dy
=
chan
:ack
^
chan
0
=
[chan
ex
cept
!
:val
=
d
;
!
:r
dy
=
1
 @]
R
cv

=
^
chan
:r
dy
6=
chan
:ack
^
chan
0
=
[chan
ex
cept
!
:ack
=
1
 @]
Next

=
(9
d
2
Data
:
Send
(d
))
_
R
cv
Sp
e
c

=
Init
^
2[Next
]
chan
theorem
Sp
e
c
)
2T
yp
eInvariant
Figure
3.2:
Our
second
sp
ecication
of
an
async
hronous
in
terface.
3.3
T
yp
es:
A
Reminder
As
dened
in
Section
3.1,
a
v
ariable
v
has
t
yp
e
T
in
sp
ecication
Sp
e
c
i
v
2
T
is
an
in
v
arian
t
of
Sp
e
c
.
Th
us,
hr
has
t
yp
e
1
:
:
12
in
the
sp
ecication
HC
of
the
hour
clo
c
k.
This
assertion
do
es
not
mean
that
the
v
ariable
hr
can
assume
only
v
alues
in
the
set
1
:
:
12.
A
state
is
an
arbitrary
assignmen
t
of
v
alues
to
v
ariables,
so
there
exist
states
in
whic
h
the
v
alue
of
hr
is
p
 2
.
The
assertion
do
es
mean
that,
in
ev
ery
b
eha
vior
satisfying
form
ula
HC
,
the
v
alue
of
hr
is
an
elemen
t
of
1
:
:
12.
If
y
ou
are
used
to
t
yp
es
in
programming
languages,
it
ma
y
seem
strange
that
TLA
+
allo
ws
a
v
ariable
to
assume
an
y
v
alue.
Wh
y
not
restrict
our
states
to
ones
in
whic
h
v
ariables
ha
v
e
the
v
alues
of
the
righ
t
t
yp
e?
In
other
w
ords,
wh
y
not
add
a
formal
t
yp
e
system
to
TLA
+
?
A
complete
answ
er
w
ould
tak
e
us
to
o
far
aeld.
The
question
is
addressed
further
in
Section
6.2.
F
or
no
w,
remem
b
er
that
TLA
+
is
an
un
t
yp
ed
language.
T
yp
e
correctness
is
just
a
name
for
a
certain
in
v
ariance
prop
ert
y
.
Assigning
the
name
T
yp
eInvariant
to
a
form
ula
giv
es
it
no
sp
ecial
status.

3.4.
DEFINITIONS
31
3.4
Denitions
Let's
examine
what
a
denition
means.
If
Id
is
a
simple
iden
tier
lik
e
Init
or
Sp
e
c
,
then
the
denition
Id

=
exp
denes
Id
to
b
e
synon
ymous
with
the
expression
exp
.
Replacing
Id
b
y
exp
,
or
vice-v
ersa,
in
an
y
expression
do
es
not
c
hange
the
meaning
of
that
expression.
This
replacemen
t
m
ust
b
e
done
after
the
expression
is
parsed,
not
in
the
\ra
w
input".
F
or
example,
the
denition
x

=
a
+
b
mak
es
x

c
equal
to
(a
+
b
)

c
,
not
to
a
+
b

c
,
whic
h
equals
a
+
(b

c
).
The
denition
of
Send
has
the
form
Id
(p
)

=
exp
,
where
Id
and
p
are
iden
ti-
ers.
F
or
an
y
expression
e
,
this
denes
Id
(e
)
to
b
e
the
expression
obtained
b
y
substituting
e
for
p
in
exp
.
F
or
example,
the
denition
of
Send
in
the
Channel
mo
dule
denes
Send
( 5)
to
equal
^
chan
:r
dy
=
chan
:ack
^
chan
0
=
[chan
ex
cept
!
:val
=
 5;
!
:r
dy
=
1
 @]
Send
(e
)
is
an
expression,
for
an
y
expression
e
.
Th
us,
w
e
can
write
the
form
ula
Send
( 5)
^
(chan
:ack
=
1).
The
iden
tier
Send
b
y
itself
is
not
an
expression,
and
Send
^
(chan
:ack
=
1)
is
not
a
grammatically
w
ell-formed
string.
It's
non-
syn
tactic
nonsense,
lik
e
a
+

b
+
.
W
e
sa
y
that
Send
is
an
op
er
ator
that
tak
es
a
single
argumen
t.
W
e
dene
op
erators
that
tak
e
more
than
one
argumen
t
in
the
ob
vious
w
a
y
,
the
general
form
b
eing
Id
(p
1
;
:
:
:
;
p
n
)

=
exp
(3.1)
where
the
p
i
are
distinct
iden
tiers
and
exp
is
an
expression.
W
e
can
consider
dened
iden
tiers
lik
e
Init
and
Sp
e
c
to
b
e
op
erators
that
tak
e
no
argumen
t,
but
w
e
generally
use
op
er
ator
to
mean
an
op
erator
that
tak
es
one
or
more
argumen
ts.
I
will
use
the
term
symb
ol
to
mean
an
iden
tier
lik
e
Send
or
an
op
erator
sym
b
ol
lik
e
+.
Ev
ery
sym
b
ol
that
is
used
in
a
sp
ecication
m
ust
either
b
e
a
built-
in
op
erator
of
TLA
+
(lik
e
2)
or
it
m
ust
b
e
declared
or
dened.
Ev
ery
sym
b
ol
declaration
or
denition
has
a
sc
op
e
within
whic
h
the
sym
b
ol
ma
y
b
e
used.
The
scop
e
of
a
v
ariable
or
const
ant
declaration,
and
of
a
denition,
is
the
part
of
the
mo
dule
that
follo
ws
it.
Th
us,
w
e
can
use
Init
in
an
y
expression
that
follo
ws
its
denition
in
mo
dule
Channel
.
The
statemen
t
extends
Natur
als
extends
the
scop
e
of
sym
b
ols
lik
e
+
dened
in
the
Natur
als
mo
dule
to
the
Channel
mo
dule.
The
op
erator
denition
(3.1)
implicitly
includes
a
declaration
of
the
iden
ti-
ers
p
1
,
.
.
.
,
p
n
whose
scop
e
is
the
expression
exp
.
An
expression
of
the
form
9
v
2
S
:
exp
has
a
declaration
of
v
whose
scop
e
is
the
expression
exp
.
Th
us
the
iden
tier
v
has
a
meaning
within
the
expression
exp
(but
not
within
the
expression
S
).

32
CHAPTER
3.
AN
ASYNCHR
ONOUS
INTERF
A
CE
A
sym
b
ol
cannot
b
e
declared
or
dened
if
it
already
has
a
meaning.
The
expression
(9
v
2
S
:
exp
1)
^
(9
v
2
T
:
exp
2)
is
all
righ
t,
b
ecause
neither
declaration
of
v
lies
within
the
scop
e
of
the
other.
Similarly
,
the
t
w
o
declarations
of
the
sym
b
ol
d
in
the
Channel
mo
dule
(in
the
denition
of
Send
and
in
the
expression
9
d
in
the
denition
of
Next
)
ha
v
e
disjoin
t
scop
es.
Ho
w
ev
er,
the
expression
(9
v
2
S
:
(exp
1
^
9
v
2
T
:
exp
2))
is
illegal
b
ecause
the
declaration
of
v
in
the
second
9
v
lies
inside
the
scop
e
of
its
declaration
in
the
rst
9
v
.
Although
con
v
en
tional
mathematics
and
program-
ming
languages
allo
w
suc
h
redeclarations,
TLA
+
forbids
them
b
ecause
they
can
lead
to
confusion
and
errors.
3.5
Commen
ts
Ev
en
simple
sp
ecications
lik
e
the
ones
in
mo
dules
AsynchInterfac
e
and
Channel
can
b
e
hard
to
understand
from
the
mathematics
alone.
That's
wh
y
I
b
egan
with
an
in
tuitiv
e
explanation
of
the
in
terface.
That
explanation
made
it
easier
for
y
ou
to
understand
form
ula
Sp
e
c
in
the
mo
dule,
whic
h
is
the
actual
sp
ecication.
Ev
ery
sp
ecication
should
b
e
accompanied
b
y
an
informal
prose
explanation.
The
explanation
ma
y
b
e
in
an
accompan
ying
do
cumen
t,
or
it
ma
y
b
e
included
as
commen
ts
in
the
sp
ecication.
Figure
3.3
on
the
next
page
sho
ws
ho
w
the
hour
clo
c
k's
sp
ecication
in
mo
dule
HourClo
ck
migh
t
b
e
explained
b
y
commen
ts.
In
the
t
yp
eset
v
ersion,
commen
ts
are
distinguished
from
the
sp
ecication
itself
b
y
the
use
of
a
dieren
t
fon
t.
As
sho
wn
in
the
gure,
TLA
+
pro
vides
t
w
o
w
a
ys
of
writing
commen
ts
in
the
asci
i
v
ersion.
A
commen
t
ma
y
app
ear
an
ywhere
enclosed
b
et
w
een
(*
and
*).
An
end-of-line
commen
t
is
preceded
b
y
\*.
Commen
ts
ma
y
b
e
nested,
so
y
ou
can
commen
t
out
a
section
of
a
sp
ecication
b
y
enclosing
it
b
et
w
een
(*
and
*),
ev
en
if
the
section
con
tains
commen
ts.
A
commen
t
almost
alw
a
ys
app
ears
on
a
line
b
y
itself
or
at
the
end
of
a
line.
I
put
a
commen
t
b
et
w
een
HCnxt
and

=
just
to
sho
w
that
it
can
b
e
done.
T
o
sa
v
e
space,
I
will
write
few
commen
ts
in
the
example
sp
ecications.
But
sp
ecications
should
ha
v
e
lots
of
commen
ts.
Ev
en
if
there
is
an
accompan
y-
ing
do
cumen
t
describing
the
system,
commen
ts
are
needed
to
help
the
reader
understand
ho
w
the
sp
ecication
formalizes
that
description.
Commen
ts
can
help
solv
e
a
problem
p
osed
b
y
the
logical
structure
of
a
sp
ec-
ication.
A
sym
b
ol
has
to
b
e
declared
or
dened
b
efore
it
can
b
e
used.
In
mo
dule
Channel
,
the
denition
of
Sp
e
c
has
to
follo
w
the
denition
of
Next
,
whic
h
has
to
follo
w
the
denitions
of
Send
and
R
cv
.
But
it's
usually
easiest
to

3.5.
COMMENTS
33
module
HourClo
ck
This
mo
dule
sp
ecies
a
digital
clo
c
k
that
displa
ys
the
curren
t
hour.
It
ignores
real
time,
not
sp
ecifying
when
the
displa
y
can
c
hange.
extends
Natur
als
v
ariable
hr
V
ariable
hr
represen
ts
the
displa
y
.
HCini

=
hr
2
(1
:
:
12)
Initially
,
hr
can
ha
v
e
an
y
v
alue
from
1
through
12.
HCnxt
This
is
a
w
eird
place
for
a
commen
t.

=
The
v
alue
of
hr
cycles
from
1
through
12.
hr
0
=
if
hr
6=
12
then
hr
+
1
else
1
HC

=
HCini
^
2[HCnxt
]
hr
The
complete
sp
ec.
It
p
ermits
the
clo
c
k
to
stop.
theorem
HC
)
2HCini
T
yp
e-correctness
of
the
sp
ec.
----------------
---
--
-
MODULE
HourClock
---------------
---
--
--
(****************
**
***
**
***
**
**
***
**
***
**
**
***
**
***
**
***
*)
(*
This
module
specifies
a
digital
clock
that
displays
*)
(*
the
current
hour.
It
ignores
real
time,
not
*)
(*
specifying
when
the
display
can
change.
*)
(****************
**
***
**
***
**
**
***
**
***
**
**
***
**
***
**
***
*)
EXTENDS
Naturals
VARIABLE
hr
\*
Variable
hr
represents
the
display.
HCini
==
hr
\in
(1
..
12)
\*
Initially,
hr
can
have
any
\*
value
from
1
through
12.
HCnxt
(*
This
is
a
weird
place
for
a
comment.
*)
==
(****************
**
***
**
***
**
**
***
**
***
**
**
***
**
**)
(*
The
value
of
hr
cycles
from
1
through
12.
*)
(****************
**
***
**
***
**
**
***
**
***
**
**
***
**
**)
hr'
=
IF
hr
#
12
THEN
hr
+
1
ELSE
1
HC
==
HCini
/\
[][HCnxt]_hr
(*
The
complete
spec.
It
permits
the
clock
to
stop.
*)
----------------
---
--
---
--
---
--
--
---
--
---
--
--
---
--
---
--
---
--
--
THEOREM
HC
=>
[]HCini
\*
Type-correctness
of
the
spec.
================
===
==
===
==
===
==
==
===
==
===
==
==
===
==
===
==
===
==
==
Figure
3.3:
The
hour-clo
c
k
sp
ecication
with
commen
ts.

34
CHAPTER
3.
AN
ASYNCHR
ONOUS
INTERF
A
CE
understand
a
top-do
wn
description
of
a
system.
W
e
w
ould
probably
rst
w
an
t
to
read
the
declarations
of
Data
and
chan
,
then
the
denition
of
Sp
e
c
,
then
the
denitions
of
Init
and
Next
,
and
then
the
denitions
of
Send
and
R
cv
.
In
other
w
ords,
w
e
w
an
t
to
read
the
sp
ecication
more
or
less
from
b
ottom
to
top.
This
is
easy
enough
to
do
for
a
mo
dule
as
short
as
Channel
;
it's
incon
v
enien
t
for
longer
sp
ecications.
W
e
can
use
commen
ts
to
guide
the
reader
through
a
longer
sp
ecication.
F
or
example,
w
e
could
precede
the
denition
of
Send
in
the
Channel
mo
dule
with
the
commen
t
Actions
Send
and
R
cv
b
elo
w
are
the
disjuncts
of
the
next-state
action
Next
.
The
mo
dule
structure
also
allo
ws
us
to
c
ho
ose
the
order
in
whic
h
a
sp
ec-
ication
is
read.
F
or
example,
w
e
can
rewrite
the
hour-clo
c
k
sp
ecication
b
y
splitting
the
HourClo
ck
mo
dule
in
to
three
separate
mo
dules:
HCV
ar
A
mo
dule
that
declares
the
v
ariable
hr
.
HCA
ctions
A
mo
dule
that
extends
mo
dules
Natur
als
and
HCV
ar
and
de-
nes
HCini
and
HCnxt
.
HCSp
e
c
A
mo
dule
that
extends
mo
dule
HCA
ctions
,
denes
form
ula
HC
,
and
asserts
the
t
yp
e-correctness
theorem.
The
extends
relation
implies
a
logical
ordering
of
the
mo
dules:
HCV
ar
precedes
HCA
ctions
,
whic
h
precedes
HCSp
e
c
.
But
the
mo
dules
don't
ha
v
e
to
b
e
read
in
that
order.
The
reader
can
b
e
told
to
read
HCV
ar
rst,
then
HCSp
e
c
,
and
nally
HCA
ctions
.
The
inst
ance
construct
in
tro
duced
b
elo
w
in
Chapter
4
pro
vides
another
to
ol
for
mo
dularizing
sp
ecications.
Splitting
a
tin
y
sp
ecication
lik
e
HourClo
ck
in
this
w
a
y
w
ould
b
e
ludicrous.
But
the
prop
er
splitting
of
mo
dules
can
help
mak
e
a
large
sp
ecication
easier
to
read.
When
writing
a
sp
ecication,
y
ou
should
decide
in
what
order
it
should
b
e
read.
Y
ou
can
then
design
the
mo
dule
structure
to
p
ermit
reading
it
in
that
order,
when
eac
h
individual
mo
dule
is
read
from
b
eginning
to
end.
Finally
,
y
ou
should
ensure
that
the
commen
ts
within
eac
h
mo
dule
mak
e
sense
when
the
dieren
t
mo
dules
are
read
in
the
appropriate
order.

Chapter
4
A
FIF
O
Our
next
example
is
a
FIF
O
buer,
called
a
FIF
O
for
short|a
device
with
whic
h
a
sender
pro
cess
transmits
a
sequence
of
v
alues
to
a
receiv
er.
The
sender
and
receiv
er
use
t
w
o
c
hannels,
in
and
out
,
to
comm
unicate
with
the
buer:
Sender
Buer
Receiv
er
in
out
-
-
V
alues
are
sen
t
o
v
er
in
and
out
using
the
async
hronous
proto
col
sp
ecied
b
y
the
Channel
mo
dule
of
Figure
3.2
on
page
30.
The
system's
sp
ecication
will
allo
w
b
eha
viors
with
four
kinds
of
nonstuttering
steps:
Send
and
R
cv
steps
on
b
oth
the
in
c
hannel
and
the
out
c
hannel.
4.1
The
Inner
Sp
ecication
The
sp
ecication
of
the
FIF
O
rst
extends
mo
dules
Natur
als
and
Se
quenc
es
.
The
Se
quenc
es
mo
dule
denes
op
erations
on
nite
sequences.
W
e
represen
t
a
nite
sequence
as
a
tuple,
so
the
sequence
of
three
n
um
b
ers
3,
2,
1
is
the
triple
h
3;
2;
1
i.
The
Se
quenc
es
mo
dule
denes
the
follo
wing
op
erators
on
sequences:
Se
q
(S
)
The
set
of
all
sequences
of
elemen
ts
of
the
set
S
.
F
or
example,
h
3;
7
i
is
an
elemen
t
of
Se
q
(Nat
).
He
ad
(s
)
The
rst
elemen
t
of
sequence
s
.
F
or
example,
He
ad
(h
3;
7
i)
equals
3.
35

36
CHAPTER
4.
A
FIF
O
T
ail
(s
)
The
tail
of
sequence
s
,
whic
h
consists
of
s
with
its
head
remo
v
ed.
F
or
example,
T
ail
(h
3;
7
i)
equals
h
7
i.
App
end
(s
;
e
)
The
sequence
obtained
b
y
app
ending
elemen
t
e
to
the
tail
of
sequence
s
.
F
or
example,
App
end
(h
3;
7
i;
3)
equals
h
3;
7;
3
i.
s

t
The
sequence
obtained
b
y
concatenating
the
sequences
s
and
t
.
F
or
example,
h
3;
7
i

h
3
i
equals
h
3;
7;
3
i.
(W
e
t
yp
e

in
asci
i
as
\o.)
L
en
(s
)
The
length
of
sequence
s
.
F
or
example,
L
en
(h
3;
7
i)
equals
2.
The
FIF
O's
sp
ecication
con
tin
ues
b
y
declaring
the
constan
t
Message
,
whic
h
represen
ts
the
set
of
all
messages
that
can
b
e
sen
t.
1
It
then
declares
the
v
ariables.
There
are
three
v
ariables:
in
and
out
,
represen
ting
the
c
hannels,
and
a
third
v
ariable
q
that
represen
ts
the
queue
of
buered
messages.
The
v
alue
of
q
is
the
sequence
of
messages
that
ha
v
e
b
een
sen
t
b
y
the
sender
but
not
y
et
receiv
ed
b
y
the
receiv
er.
(Section
4.3
has
more
to
sa
y
ab
out
this
additional
v
ariable
q
.)
W
e
w
an
t
to
use
the
denitions
in
the
Channel
mo
dule
to
sp
ecify
op
erations
on
the
c
hannels
in
and
out
.
This
requires
t
w
o
instances
of
that
mo
dule|one
in
whic
h
the
v
ariable
chan
of
the
Channel
mo
dule
is
replaced
with
the
v
ariable
in
of
our
curren
t
mo
dule,
and
the
other
in
whic
h
chan
is
replaced
with
out
.
In
b
oth
instances,
the
constan
t
Data
of
the
Channel
mo
dule
is
replaced
with
Message
.
W
e
obtain
the
rst
of
these
instances
with
the
statemen
t
InChan

=
inst
ance
Channel
with
Data
 
Message
;
chan
 
in
F
or
ev
ery
sym
b
ol

dened
in
mo
dule
Channel
,
this
denes
InChan
!

to
ha
v
e
the
same
meaning
in
the
curren
t
mo
dule
as

had
in
mo
dule
Channel
,
except
with
Message
substituted
for
Data
and
in
substituted
for
chan
.
F
or
example,
this
statemen
t
denes
InChan
!
T
yp
eInvariant
to
equal
in
2
[val
:
Message
;
r
dy
:
f0;
1g;
ack
:
f0;
1g]
(The
statemen
t
do
es
not
dene
InChan
!
Data
b
ecause
Data
is
declared,
not
dened,
in
mo
dule
Channel
.)
W
e
in
tro
duce
our
second
instance
of
the
Channel
mo
dule
with
the
analogous
statemen
t
OutChan

=
inst
ance
Channel
with
Data
 
Message
;
chan
 
out
The
initial
states
of
the
in
and
out
c
hannels
are
sp
ecied
b
y
InChan
!
Init
and
OutChan
!
Init
.
Initially
,
no
messages
ha
v
e
b
een
sen
t
or
receiv
ed,
so
q
should
1
I
lik
e
to
use
a
singular
noun
lik
e
Message
rather
than
a
plural
lik
e
Messages
for
the
name
of
a
set.
That
w
a
y
,
the
2
in
the
expression
m
2
Message
can
b
e
read
is
a.
This
is
the
same
con
v
en
tion
that
most
programmers
use
for
naming
t
yp
es.

4.2.
INST
ANTIA
TION
EXAMINED
37
equal
the
empt
y
sequence.
The
empt
y
sequence
is
the
0-tuple
(there's
only
one,
and
it's
written
h
i),
so
w
e
dene
the
initial
predicate
to
b
e
Init

=
^
InChan
!
Init
^
OutChan
!
Init
^
q
=
h
i
W
e
next
dene
the
t
yp
e
in
v
arian
t.
The
t
yp
e
in
v
arian
ts
for
in
and
out
come
from
the
Channel
mo
dule,
and
the
t
yp
e
of
q
is
the
set
of
nite
sequences
of
messages.
The
t
yp
e
in
v
arian
t
for
the
FIF
O
sp
ecication
is
therefore
T
yp
eInvariant

=
^
InChan
!
T
yp
eInvariant
^
OutChan
!
T
yp
eInvariant
^
q
2
Se
q
(Message
)
The
four
kinds
of
nonstuttering
steps
allo
w
ed
b
y
the
next-state
action
are
de-
scrib
ed
b
y
four
actions:
SSend
(msg
)
The
sender
sends
message
msg
on
the
in
c
hannel.
BufR
cv
The
buer
receiv
es
the
message
from
the
in
c
hannel
and
ap-
p
ends
it
to
the
tail
of
q
.
BufSend
The
buer
remo
v
es
the
message
from
the
head
of
q
and
sends
it
on
c
hannel
out
.
RR
cv
The
receiv
er
receiv
es
the
message
from
the
out
c
hannel.
The
denitions
of
these
actions,
along
with
the
rest
of
the
sp
ecication,
are
in
mo
dule
InnerFIF
O
of
Figure
4.1
on
the
next
page.
The
reason
for
the
adjectiv
e
Inner
is
explained
in
Section
4.3
b
elo
w.
4.2
Instan
tiation
Examined
The
inst
ance
statemen
t
is
seldom
used
except
in
one
idiom
for
hiding
v
ariables,
whic
h
is
describ
ed
in
Section
4.3.
So,
most
readers
can
skip
this
section
and
go
directly
to
page
41.
4.2.1
Instan
tiation
Is
Substitution
Consider
the
denition
of
Next
in
mo
dule
Channel
(page
30).
W
e
can
remo
v
e
ev
ery
dened
sym
b
ol
that
app
ears
in
that
denition
b
y
using
the
sym
b
ol's
def-
inition.
F
or
example,
w
e
can
eliminate
the
expression
Send
(d
)
b
y
expanding
the
denition
of
Send
.
W
e
can
rep
eat
this
pro
cess.
F
or
example,
the
\ "
that
app
ears
in
the
expression
1
 @
(obtained
b
y
expanding
the
denition
of
Send
)

38
CHAPTER
4.
A
FIF
O
module
InnerFIF
O
extends
Natur
als
;
Se
quenc
es
const
ant
Message
v
ariables
in
;
out
;
q
InChan

=
inst
ance
Channel
with
Data
 
Message
;
chan
 
in
OutChan

=
inst
ance
Channel
with
Data
 
Message
;
chan
 
out
Init

=
^
InChan
!
Init
^
OutChan
!
Init
^
q
=
h
i
T
yp
eInvariant

=
^
InChan
!
T
yp
eInvariant
^
OutChan
!
T
yp
eInvariant
^
q
2
Se
q
(Message
)
SSend
(msg
)

=
^
InChan
!
Send
(msg
)
^
unchanged
h
out
;
q
i
Send
msg
on
c
hannel
in
.
BufR
cv

=
^
InChan
!
R
cv
^
q
0
=
App
end
(q
;
in
:val
)
^
unchanged
out
Receiv
e
message
from
c
hannel
in
and
app
end
it
to
tail
of
q
.
BufSend

=
^
q
6=
h
i
^
OutChan
!
Send
(He
ad
(q
))
^
q
0
=
T
ail
(q
)
^
unchanged
in
Enabled
only
if
q
is
nonempt
y
.
Send
He
ad
(q
)
on
c
hannel
out
and
remo
v
e
it
from
q
.
RR
cv

=
^
OutChan
!
R
cv
^
unchanged
h
in
;
q
i
Receiv
e
message
from
c
hannel
out
.
Next

=
_
9
msg
2
Message
:
SSend
(msg
)
_
BufR
cv
_
BufSend
_
RR
cv
Sp
e
c

=
Init
^
2[Next
]
h
in
;
out
;
q
i
theorem
Sp
e
c
)
2T
yp
eInvariant
Figure
4.1:
The
sp
ecication
of
a
FIF
O,
with
the
in
ternal
v
ariable
q
visible.

4.2.
INST
ANTIA
TION
EXAMINED
39
can
b
e
eliminated
b
y
using
the
denition
of
\ "
from
the
Natur
als
mo
dule.
Con
tin
uing
in
this
w
a
y
,
w
e
ev
en
tually
obtain
a
denition
for
Next
in
terms
of
only
the
built-in
op
erators
of
TLA
+
and
the
parameters
Data
and
chan
of
the
Channel
mo
dule.
W
e
consider
this
to
b
e
the
\real"
denition
of
Next
in
mo
dule
Channel
.
The
statemen
t
InChan

=
inst
ance
Channel
with
Data
 
Message
;
chan
 
in
in
mo
dule
InnerFIF
O
denes
InChan
!
Next
to
b
e
the
form
ula
obtained
from
this
real
denition
of
Next
b
y
substituting
Message
for
Data
and
in
for
chan
.
This
denes
InChan
!
Next
in
terms
of
only
the
built-in
op
erators
of
TLA
+
and
the
parameters
Message
and
in
of
mo
dule
InnerFIF
O
.
Let's
no
w
consider
an
arbitrary
inst
ance
statemen
t
IM

=
inst
ance
M
with
p
1
 
e
1
;
:
:
:
;
p
n
 
e
n
Let

b
e
a
sym
b
ol
dened
in
mo
dule
M
and
let
d
b
e
its
\real"
denition.
The
inst
ance
statemen
t
denes
IM
!

to
ha
v
e
as
its
real
denition
the
expression
obtained
from
d
b
y
replacing
all
instances
of
p
i
b
y
the
expression
e
i
,
for
eac
h
i
.
The
denition
of
IM
!

m
ust
con
tain
only
the
parameters
(declared
constan
ts
and
v
ariables)
of
the
curren
t
mo
dule,
not
the
ones
of
mo
dule
M
.
Hence,
the
p
i
m
ust
consist
of
all
the
parameters
of
mo
dule
M
.
The
e
i
m
ust
b
e
expressions
that
are
meaningful
in
the
curren
t
mo
dule.
4.2.2
P
arametrized
Instan
tiation
The
FIF
O
sp
ecication
uses
t
w
o
instances
of
mo
dule
Channel
|one
with
in
substituted
for
chan
and
the
other
with
out
substituted
for
chan
.
W
e
could
instead
use
a
single
parametrized
instance
b
y
putting
the
follo
wing
statemen
t
in
mo
dule
InnerFIF
O
:
Chan
(ch
)

=
inst
ance
Channel
with
Data
 
Message
;
chan
 
ch
F
or
an
y
sym
b
ol

dened
in
mo
dule
Channel
and
an
y
expression
exp
,
this
de-
nes
Chan
(exp
)
!

to
equal
form
ula

with
Message
substituted
for
Data
and
exp
substituted
for
chan
.
The
R
cv
action
on
c
hannel
in
could
then
b
e
writ-
ten
Chan
(in
)
!
R
cv
,
and
the
Send
(msg
)
action
on
c
hannel
out
could
b
e
written
Chan
(out
)
!
Send
(msg
).
The
instan
tiation
ab
o
v
e
denes
Chan
!
Send
to
b
e
an
op
erator
with
t
w
o
argu-
men
ts.
W
riting
Chan
(out
)
!
Send
(msg
)
instead
of
Chan
!
Send
(out
;
msg
)
is
just
an
idiosyncrasy
of
the
syn
tax.
It
is
no
stranger
than
the
syn
tax
for
inx
op
era-
tors,
whic
h
has
us
write
a
+
b
instead
of
+(a
;
b
).
P
arametrized
instan
tiation
is
used
almost
exclusiv
ely
in
the
TLA
+
idiom
for
v
ariable
hiding,
describ
ed
in
Section
4.3.
Y
ou
can
use
that
idiom
without
under-
standing
it,
so
y
ou
probably
don't
need
to
kno
w
an
ything
ab
out
parametrized
instan
tiation.

40
CHAPTER
4.
A
FIF
O
4.2.3
Implicit
Substitutions
The
use
of
Message
as
the
name
for
the
set
of
transmitted
v
alues
in
the
FIF
O
sp
ecication
is
a
bit
strange,
since
w
e
had
just
used
the
name
Data
for
the
analogous
set
in
the
async
hronous
c
hannel
sp
ecications.
Supp
ose
w
e
had
used
Data
in
place
of
Message
as
the
constan
t
parameter
of
mo
dule
InnerFIF
O
.
The
rst
instan
tiation
statemen
t
w
ould
then
ha
v
e
b
een
InChan

=
inst
ance
Channel
with
Data
 
Data
;
chan
 
in
The
substitution
Data
 
Data
indicates
that
the
constan
t
parameter
Data
of
the
instan
tiated
mo
dule
Channel
is
replaced
with
the
expression
Data
of
the
curren
t
mo
dule.
TLA
+
allo
ws
us
to
drop
an
y
substitution
of
the
form

 
,
for
a
sym
b
ol
.
So,
the
statemen
t
ab
o
v
e
can
b
e
written
as
InChan

=
inst
ance
Channel
with
chan
 
in
W
e
kno
w
there
is
an
implied
Data
 
Data
substitution
b
ecause
an
inst
ance
statemen
t
m
ust
ha
v
e
a
substitution
for
ev
ery
parameter
of
the
instan
tiated
mo
d-
ule.
If
some
parameter
p
has
no
explicit
substitution,
then
there
is
an
implicit
substitution
p
 
p
.
This
means
that
the
inst
ance
statemen
t
m
ust
lie
within
the
scop
e
of
a
declaration
or
denition
of
the
sym
b
ol
p
.
It
is
quite
common
to
instan
tiate
a
mo
dule
with
this
kind
of
implicit
substi-
tution.
Often,
ev
ery
parameter
has
an
implicit
substitution,
in
whic
h
case
the
list
of
explicit
substitutions
is
empt
y
.
The
with
is
then
omitted.
4.2.4
Instan
tiation
Without
Renaming
So
far,
all
the
instan
tiations
w
e'v
e
used
ha
v
e
b
een
with
renaming.
F
or
exam-
ple,
the
rst
instan
tiation
of
mo
dule
Channel
renames
the
dened
sym
b
ol
Send
as
InChan
!
Send
.
This
kind
of
renaming
is
necessary
if
w
e
are
using
m
ultiple
instances
of
the
mo
dule,
or
a
single
parametrized
instance.
The
t
w
o
instances
InChan
!
Init
and
OutChan
!
Init
of
Init
in
mo
dule
InnerFIF
O
are
dieren
t
for-
m
ulas,
so
they
need
dieren
t
names.
Sometimes
w
e
need
only
a
single
instance
of
a
mo
dule.
F
or
example,
supp
ose
w
e
are
sp
ecifying
a
system
with
only
a
single
async
hronous
c
hannel.
W
e
then
need
only
one
instance
of
Channel
,
so
w
e
don't
ha
v
e
to
rename
the
instan
tiated
sym
b
ols.
In
that
case,
w
e
can
write
something
lik
e
inst
ance
Channel
with
Data
 
D
;
chan
 
x
This
instan
tiates
Channel
with
no
renaming,
but
with
substitution.
Th
us,
it
denes
R
cv
to
b
e
the
form
ula
of
the
same
name
from
the
Channel
mo
dule,
except
with
D
substituted
for
Data
and
x
substituted
for
chan
.
The
expressions
substituted
for
an
instan
tiated
mo
dule's
parameters
m
ust
b
e
dened.
So,
this
inst
ance
statemen
t
m
ust
b
e
within
the
scop
e
of
the
denitions
or
declarations
of
D
and
x
.

4.3.
HIDING
THE
QUEUE
41
4.3
Hiding
the
Queue
Mo
dule
InnerFIF
O
of
Figure
4.1
denes
Sp
e
c
to
b
e
Init
^
2[Next
]
:::
,
the
sort
of
form
ula
w
e'v
e
b
ecome
accustomed
to
as
a
system
sp
ecication.
Ho
w
ev
er,
form
ula
Sp
e
c
describ
es
the
v
alue
of
v
ariable
q
,
as
w
ell
as
of
the
v
ariables
in
and
out
.
The
picture
of
the
FIF
O
system
I
drew
on
page
35
sho
ws
only
c
hannels
in
and
out
;
it
do
esn't
sho
w
an
ything
inside
the
b
o
xes.
A
sp
ecication
of
the
FIF
O
should
describ
e
only
the
v
alues
sen
t
and
receiv
ed
on
the
c
hannels.
The
v
ariable
q
,
whic
h
represen
ts
what's
going
on
inside
the
b
o
x
lab
eled
Buer
,
is
used
to
sp
ecify
what
v
alues
are
sen
t
and
receiv
ed.
It
is
an
internal
v
ariable
and,
in
the
nal
sp
ecication,
it
should
b
e
hidden.
In
TLA,
w
e
hide
a
v
ariable
with
the
existen
tial
quan
tier
9
9
9
9
9
9
of
temp
oral
logic.
The
form
ula
9
9
9
9
9
9
x
:
F
is
true
of
a
b
eha
vior
i
there
exists
some
sequence
of
v
alues|one
in
eac
h
state
of
the
b
eha
vior|that
can
b
e
assigned
to
the
v
ariable
x
that
will
mak
e
form
ula
F
true.
(The
meaning
of
9
9
9
9
9
9
is
dened
more
precisely
in
Section
8.8.)
The
ob
vious
w
a
y
to
write
a
FIF
O
sp
ecication
in
whic
h
q
is
hidden
is
with
the
form
ula
9
9
9
9
9
9
q
:
Sp
e
c
.
Ho
w
ev
er,
w
e
can't
put
this
denition
in
mo
dule
InnerFIF
O
b
ecause
q
is
already
declared
there,
and
a
form
ula
9
9
9
9
9
9
q
:
:
:
:
w
ould
redeclare
it.
In-
stead,
w
e
use
a
new
mo
dule
with
a
parametrized
instan
tiation
of
the
InnerFIF
O
mo
dule
(see
Section
4.2.2
on
page
39):
module
FIF
O
const
ant
Message
v
ariables
in
;
out
Inner
(q
)

=
inst
ance
InnerFIF
O
Sp
e
c

=
9
9
9
9
9
9
q
:
Inner
(q
)
!
Sp
e
c
Observ
e
that
the
inst
ance
statemen
t
is
an
abbreviation
for
Inner
(q
)

=
inst
ance
InnerFIF
O
with
q
 
q
;
in
 
in
;
out
 
out
;
Message
 
Message
The
v
ariable
parameter
q
of
mo
dule
InnerFIF
O
is
instan
tiated
with
the
parame-
ter
q
of
the
denition
of
Inner
.
The
other
parameters
of
the
InnerFIF
O
mo
dule
are
instan
tiated
with
the
parameters
of
mo
dule
FIF
O
.
If
this
seems
confusing,
don't
w
orry
ab
out
it.
Just
learn
the
TLA
+
idiom
for
hiding
v
ariables
used
here
and
b
e
con
ten
t
with
its
in
tuitiv
e
meaning.
In
fact,
for
most
applications,
there's
no
need
to
hide
v
ariables
in
the
sp
ecication.
Y
ou
can
just
write
the
inner
sp
ecication
and
note
in
the
commen
ts
whic
h
v
ariables
should
b
e
regarded
as
visible
and
whic
h
as
in
ternal
(hidden).

42
CHAPTER
4.
A
FIF
O
4.4
A
Bounded
FIF
O
W
e
ha
v
e
sp
ecied
an
un
b
ounded
FIF
O|a
buer
that
can
hold
an
un
b
ounded
n
um
b
er
of
messages.
An
y
real
system
has
a
nite
amoun
t
of
resources,
so
it
can
con
tain
only
a
b
ounded
n
um
b
er
of
in-transit
messages.
In
man
y
situations,
w
e
wish
to
abstract
a
w
a
y
the
b
ound
on
resources
and
describ
e
a
system
in
terms
of
un
b
ounded
FIF
Os.
In
other
situations,
w
e
ma
y
care
ab
out
that
b
ound.
W
e
then
w
an
t
to
strengthen
our
sp
ecication
b
y
placing
a
b
ound
N
on
the
n
um
b
er
of
outstanding
messages.
A
sp
ecication
of
a
b
ounded
FIF
O
diers
from
our
sp
ecication
of
the
un-
b
ounded
FIF
O
only
in
that
action
BufR
cv
should
not
b
e
enabled
unless
there
are
few
er
than
N
messages
in
the
buer|that
is,
unless
L
en
(q
)
is
less
than
N
.
It
w
ould
b
e
easy
to
write
a
complete
new
sp
ecication
of
a
b
ounded
FIF
O
b
y
cop
ying
mo
dule
InnerFIF
O
and
just
adding
the
conjunct
L
en
(q
)
<
N
to
the
denition
of
BufR
cv
.
But
let's
use
mo
dule
InnerFIF
O
as
it
is,
rather
than
cop
ying
it.
The
next-state
action
BNext
for
the
b
ounded
FIF
O
is
the
same
as
the
FIF
O's
next-state
action
Next
except
that
it
allo
ws
a
BufR
cv
step
only
if
L
en
(q
)
is
less
than
N
.
In
other
w
ords,
BNext
should
allo
w
a
step
only
if
(i)
it's
a
Next
step
and
(ii)
if
it's
a
BufR
cv
step,
then
L
en
(q
)
<
N
is
true
in
the
rst
state.
In
other
w
ords,
BNext
should
equal
Next
^
(BufR
cv
)
(L
en
(q
)
<
N
))
Mo
dule
Bounde
dFIF
O
in
Figure
4.2
on
the
next
page
con
tains
the
sp
ecication.
It
in
tro
duces
the
new
constan
t
parameter
N
.
It
also
con
tains
the
statemen
t
assume
(N
2
Nat
)
^
(N
>
0)
whic
h
asserts
that,
in
this
mo
dule,
w
e
are
assuming
that
N
is
a
p
ositiv
e
natu-
ral
n
um
b
er.
Suc
h
an
assumption
has
no
eect
on
an
y
denitions
made
in
the
mo
dule.
Ho
w
ev
er,
it
ma
y
b
e
tak
en
as
a
h
yp
othesis
when
pro
ving
an
y
theorems
asserted
in
the
mo
dule.
In
other
w
ords,
a
mo
dule
asserts
that
its
assumptions
imply
its
theorems.
It's
a
go
o
d
idea
to
state
this
kind
of
simple
assumption
ab
out
constan
ts.
An
assume
statemen
t
should
b
e
used
only
to
mak
e
assumptions
ab
out
con-
stan
ts.
The
form
ula
b
eing
assumed
should
not
con
tain
an
y
v
ariables.
It
migh
t
b
e
tempting
to
assert
t
yp
e
declarations
as
assumptions|for
example,
to
add
to
mo
dule
InnerFIF
O
the
assumption
q
2
Se
q
(Message
).
Ho
w
ev
er,
that
w
ould
b
e
wrong
b
ecause
it
asserts
that,
in
an
y
state,
q
is
a
sequence
of
messages.
As
w
e
observ
ed
in
Section
3.3,
a
state
is
a
completely
arbitrary
assignmen
t
of
v
alues
to
v
ariables,
so
there
are
states
in
whic
h
q
has
the
v
alue
p
 17
.
Assuming
that
suc
h
a
state
do
esn't
exist
w
ould
lead
to
a
logical
con
tradiction.
Y
ou
ma
y
w
onder
wh
y
mo
dule
Bounde
dFIF
O
assumes
that
N
is
a
p
ositiv
e
natural,
but
do
esn't
assume
that
Message
is
a
set.
Similarly
,
wh
y
didn't
w
e

4.5.
WHA
T
WE'RE
SPECIFYING
43
module
Bounde
dFIF
O
extends
Natur
als
;
Se
quenc
es
v
ariables
in
;
out
const
ant
Message
;
N
assume
(N
2
Nat
)
^
(N
>
0)
Inner
(q
)

=
inst
ance
InnerFIF
O
BNext
(q
)

=
^
Inner
(q
)
!
Next
^
Inner
(q
)
!
BufR
cv
)
(L
en
(q
)
<
N
)
Sp
e
c

=
9
9
9
9
9
9
q
:
Inner
(q
)
!
Init
^
2[BNext
(q
)]
h
in
;out
;q
i
Figure
4.2:
A
sp
ecication
of
a
FIF
O
buer
of
length
N.
assume
that
the
constan
t
parameter
Data
in
our
async
hronous
in
terface
sp
eci-
cations
is
a
set?
The
answ
er
is
that,
in
TLA
+
,
ev
ery
v
alue
is
a
set.
2
A
v
alue
lik
e
the
n
um
b
er
3,
whic
h
w
e
don't
think
of
as
a
set,
is
formally
a
set.
W
e
just
don't
kno
w
what
its
elemen
ts
are.
The
form
ula
2
2
3
is
a
p
erfectly
reasonable
one,
but
TLA
+
do
es
not
sp
ecify
whether
it's
true
or
false.
So,
w
e
don't
ha
v
e
to
assume
that
Message
is
a
set
b
ecause
w
e
kno
w
that
it
is
one.
Although
Message
is
automatically
a
set,
it
isn't
necessarily
a
nite
set.
F
or
example,
Message
could
b
e
instan
tiated
with
the
set
Nat
of
natural
n
um
b
ers.
If
y
ou
w
an
t
to
assume
that
a
constan
t
parameter
is
a
nite
set,
then
y
ou
need
to
state
this
as
an
assumption.
(Y
ou
can
do
this
with
the
IsFiniteSet
op
erator
from
the
FiniteSets
mo
dule,
describ
ed
in
Section
6.1.)
Ho
w
ev
er,
most
sp
ecications
mak
e
p
erfect
sense
for
innite
sets
of
messages
or
pro
cessors,
so
there
is
no
reason
to
assume
these
sets
to
b
e
nite.
4.5
What
W
e're
Sp
ecifying
I
wrote
at
the
b
eginning
of
this
c
hapter
that
w
e
w
ere
going
to
sp
ecify
a
FIF
O
buer.
F
orm
ula
Sp
e
c
of
the
FIF
O
mo
dule
actually
sp
ecies
a
set
of
b
eha
viors,
eac
h
represen
ting
a
sequence
of
sending
and
receiving
op
erations
on
the
c
hannels
in
and
out
.
The
sending
op
erations
on
in
are
p
erformed
b
y
the
sender,
and
the
receiving
op
erations
on
out
are
p
erformed
b
y
the
receiv
er.
The
sender
and
receiv
er
are
not
part
of
the
FIF
O
buer;
they
form
its
envir
onment.
Our
sp
ecication
describ
es
a
system
consisting
of
the
FIF
O
buer
and
its
en
vironmen
t.
The
b
eha
viors
satisfying
form
ula
Sp
e
c
of
mo
dule
FIF
O
represen
t
those
histories
of
the
univ
erse
in
whic
h
b
oth
the
system
and
its
en
vironmen
t
2
TLA
+
is
based
on
the
mathematical
formalism
kno
wn
as
Zermelo-F
r
ank
el
set
theory
,
also
called
ZF.

44
CHAPTER
4.
A
FIF
O
b
eha
v
e
correctly
.
It's
often
helpful
in
understanding
a
sp
ecication
to
indicate
explicitly
whic
h
steps
are
system
steps
and
whic
h
are
en
vironmen
t
steps.
W
e
can
do
this
b
y
dening
the
next-state
action
to
b
e
Next

=
SysNext
_
EnvNext
where
SysNext
describ
es
system
steps
and
EnvNext
describ
es
en
vironmen
t
steps.
F
or
the
FIF
O,
w
e
ha
v
e
SysNext

=
BufR
cv
_
BufSend
EnvNext

=
(9
msg
2
Message
:
SSend
(msg
))
_
RR
cv
While
suggestiv
e,
this
w
a
y
of
dening
the
next-state
action
has
no
formal
sig-
nicance.
The
sp
ecication
Sp
e
c
equals
Init
^
2[Next
]
:::
;
c
hanging
the
w
a
y
w
e
structure
the
denition
of
Next
do
esn't
c
hange
its
meaning.
If
a
b
eha
vior
fails
to
satisfy
Sp
e
c
,
nothing
tells
us
if
the
system
or
its
en
vironmen
t
is
to
blame.
A
form
ula
lik
e
Sp
e
c
,
whic
h
describ
es
the
correct
b
eha
vior
of
b
oth
the
system
and
its
en
vironmen
t,
is
called
a
close
d-system
or
c
omplete-system
sp
ecication.
An
op
en-system
sp
ecication
is
one
that
describ
es
only
the
correct
b
eha
vior
of
the
system.
A
b
eha
vior
satises
an
op
en-system
sp
ecication
if
it
represen
ts
a
history
in
whic
h
either
the
system
op
erates
correctly
,
or
it
failed
to
op
erate
cor-
rectly
only
b
ecause
its
en
vironmen
t
did
something
wrong.
Section
10.7
explains
ho
w
to
write
op
en-system
sp
ecications.
Op
en-system
sp
ecications
are
philosophically
more
satisfying.
Ho
w
ev
er,
closed-system
sp
ecications
are
a
little
easier
to
write,
and
the
mathematics
underlying
them
is
simpler.
So,
w
e
almost
alw
a
ys
write
closed-system
sp
eci-
cations.
It's
usually
quite
easy
to
turn
a
closed-system
sp
ecication
in
to
an
op
en-system
sp
ecication.
But
in
practice,
there's
seldom
an
y
reason
to
do
so.

Chapter
5
A
Cac
hing
Memory
A
memory
system
consists
of
a
set
of
pro
cessors
connected
to
a
memory
b
y
some
abstract
in
terface,
whic
h
w
e
lab
el
memInt.
Pro
cessor
Pro
cessor
-

-

-

p
p
p
memInt
M
E
M
O
R
Y
In
this
section
w
e
sp
ecify
what
the
memory
is
supp
osed
to
do,
then
w
e
sp
ecify
a
particular
implemen
tation
of
the
memory
using
cac
hes.
W
e
b
egin
b
y
sp
ecifying
the
memory
in
terface,
whic
h
is
common
to
b
oth
sp
ecications.
5.1
The
Memory
In
terface
The
async
hronous
in
terface
describ
ed
in
Chapter
3
uses
a
handshak
e
proto
col.
Receipt
of
a
data
v
alue
m
ust
b
e
ac
kno
wledged
b
efore
the
next
data
v
alue
can
b
e
sen
t.
In
the
memory
in
terface,
w
e
abstract
a
w
a
y
this
kind
of
detail
and
represen
t
b
oth
the
sending
of
a
data
v
alue
and
its
receipt
as
a
single
step.
W
e
call
it
a
Send
step
if
a
pro
cessor
is
sending
the
v
alue
to
the
memory;
it's
a
R
eply
step
if
the
memory
is
sending
to
a
pro
cessor.
Pro
cessors
do
not
send
v
alues
to
one
another,
and
the
memory
sends
to
only
one
pro
cessor
at
a
time.
W
e
represen
t
the
state
of
the
memory
in
terface
b
y
the
v
alue
of
the
v
ariable
memInt
.
A
Send
step
c
hanges
memInt
in
some
w
a
y
,
but
w
e
don't
w
an
t
to
sp
ecify
exactly
ho
w.
The
w
a
y
to
lea
v
e
something
unsp
ecied
in
a
sp
ecication
is
to
mak
e
it
a
parameter.
F
or
example,
in
the
b
ounded
FIF
O
of
Section
4.4,
w
e
left
the
size
of
the
buer
unsp
ecied
b
y
making
it
a
parameter
N
.
W
e'd
45

46
CHAPTER
5.
A
CA
CHING
MEMOR
Y
therefore
lik
e
to
declare
a
parameter
Send
so
that
Send
(p
;
d
)
describ
es
ho
w
memInt
is
c
hanged
b
y
a
step
that
represen
ts
pro
cessor
p
sending
data
v
alue
d
to
the
memory
.
Ho
w
ev
er,
TLA
+
pro
vides
only
const
ant
and
v
ariable
parameters,
not
action
parameters.
1
So,
w
e
declare
Send
to
b
e
a
constan
t
op
erator
and
write
Send
(p
;
d
;
memInt
;
memInt
0
)
instead
of
Send
(p
;
d
).
In
TLA
+
,
w
e
declare
Send
to
b
e
a
constan
t
op
erator
that
tak
es
four
argu-
men
ts
b
y
writing
const
ant
Send
(
;
;
;
)
This
means
that
Send
(p
;
d
;
miOld
;
miNew
)
is
an
expression,
for
an
y
expressions
p
,
d
,
miOld
,
and
miNew
,
but
it
sa
ys
nothing
ab
out
what
the
v
alue
of
that
expression
is.
W
e
w
an
t
it
to
b
e
a
Bo
olean
v
alue
that
is
true
i
a
step
in
whic
h
memInt
equals
miOld
in
the
rst
state
and
miNew
in
the
second
state
represen
ts
the
sending
b
y
p
of
v
alue
d
to
the
memory
.
2
W
e
can
assert
that
the
v
alue
is
a
Bo
olean
b
y
the
assumption
assume
8
p
;
d
;
miOld
;
miNew
:
Send
(p
;
d
;
miOld
;
miNew
)
2
boolean
This
asserts
that
the
form
ula
Send
(p
;
d
;
miOld
;
miNew
)
2
boolean
is
true
for
all
v
alues
of
p
,
d
,
miOld
,
and
miNew
.
The
built-in
sym
b
ol
boolean
denotes
the
set
ftr
ue;
f
alseg,
whose
elemen
ts
are
the
t
w
o
Bo
olean
v
alues
tr
ue
and
f
alse
.
This
assume
statemen
t
asserts
formally
that
the
v
alue
of
Send
(p
;
d
;
miOld
;
miNew
)
is
a
Bo
olean.
But
the
only
w
a
y
to
assert
formally
what
that
v
alue
signies
w
ould
b
e
to
sa
y
what
it
actually
equals|that
is,
to
dene
Send
rather
than
making
it
a
parameter.
W
e
don't
w
an
t
to
do
that,
so
w
e
just
state
informally
what
the
v
alue
means.
This
statemen
t
is
part
of
the
in
trinsically
informal
description
of
the
relation
b
et
w
een
our
mathematical
abstraction
and
a
ph
ysical
memory
system.
T
o
allo
w
the
reader
to
understand
the
sp
ecication,
w
e
ha
v
e
to
describ
e
informally
what
Send
means.
The
assume
statemen
t
asserting
that
Send
(:
:
:)
is
a
Bo
olean
is
then
sup
eruous
as
an
explanation.
But
it's
a
go
o
d
idea
to
include
it
an
yw
a
y
.
1
Ev
en
if
TLA
+
allo
w
ed
us
to
declare
an
action
parameter,
w
e
w
ould
ha
v
e
no
w
a
y
to
sp
ecify
that
a
Send
(p
;
d
)
action
constrains
only
memInt
and
not
other
v
ariables.
2
W
e
exp
ect
Send
(p
;
d
;
miOld
;
miNew
)
to
ha
v
e
this
meaning
only
when
p
is
a
pro
cessor
and
d
a
v
alue
that
p
is
allo
w
ed
to
send,
but
w
e
simplify
the
sp
ecication
a
bit
b
y
requiring
it
to
b
e
a
Bo
olean
for
all
v
alues
of
p
and
d
.

5.1.
THE
MEMOR
Y
INTERF
A
CE
47
A
sp
ecication
that
uses
the
memory
in
terface
can
use
the
op
erators
Send
and
R
eply
to
sp
ecify
ho
w
the
v
ariable
memInt
c
hanges.
The
sp
ecication
m
ust
also
describ
e
memInt
's
initial
v
alue.
W
e
therefore
declare
a
constan
t
parameter
InitMemInt
that
is
the
set
of
p
ossible
initial
v
alues
of
memInt
.
W
e
also
in
tro
duce
three
constan
t
parameters
that
are
needed
to
describ
e
the
in
terface:
Pr
o
c
The
set
of
pro
cessor
iden
tiers.
(W
e
usually
shorten
pr
o
c
essor
identier
to
pr
o
c
essor
when
referring
to
an
elemen
t
of
Pr
o
c
.)
A
dr
The
set
of
memory
addresses.
V
al
The
set
of
p
ossible
memory
v
alues
that
can
b
e
assigned
to
an
address.
Finally
,
w
e
dene
the
v
alues
that
the
pro
cessors
and
memory
send
to
one
another
o
v
er
the
in
terface.
A
pro
cessor
sends
a
request
to
the
memory
.
W
e
represen
t
a
request
as
a
record
with
an
op
eld
that
sp
ecies
the
t
yp
e
of
request
and
additional
elds
that
sp
ecify
its
argumen
ts.
Our
simple
memory
allo
ws
only
read
and
write
requests.
A
read
request
has
op
eld
\Rd"
and
an
adr
eld
sp
ecifying
the
address
to
b
e
read.
The
set
of
all
read
requests
is
therefore
the
set
[op
:
f\Rd"
g;
adr
:
A
dr
]
of
all
records
whose
op
eld
equals
\Rd"
(is
an
elemen
t
of
the
set
f\Rd"
g
whose
only
elemen
t
is
the
string
\Rd"
)
and
whose
adr
eld
is
an
elemen
t
of
A
dr
.
A
write
request
m
ust
sp
ecify
the
address
to
b
e
written
and
the
v
alue
to
write.
It
is
represen
ted
b
y
a
record
with
op
eld
equal
to
\W
r"
,
and
with
adr
and
val
elds
sp
ecifying
the
address
and
v
alue.
W
e
dene
MR
e
q
,
the
set
of
all
requests,
to
equal
the
union
of
these
t
w
o
sets.
(Set
op
erations,
including
union,
are
describ
ed
in
Section
1.2
on
page
11.)
The
memory
resp
onds
to
a
read
request
with
the
memory
v
alue
it
read.
W
e
will
also
ha
v
e
it
resp
ond
to
a
write
request,
and
it
seems
nice
to
let
the
resp
onse
b
e
dieren
t
from
the
resp
onse
to
an
y
read
request.
W
e
therefore
require
the
memory
to
resp
ond
to
a
write
request
b
y
returning
a
v
alue
NoV
al
that
is
dieren
t
from
an
y
memory
v
alue.
W
e
could
declare
NoV
al
to
b
e
a
constan
t
parameter
and
add
the
assumption
NoV
al
=
2
V
al
.
(The
sym
b
ol
=
2
is
t
yp
ed
in
asci
i
as
\notin
.)
But
it's
b
est,
when
p
ossible,
to
a
v
oid
in
tro
ducing
parameters.
Instead,
w
e
dene
NoV
al
b
y
NoV
al

=
choose
v
:
v
=
2
V
al
The
expression
choose
x
:
F
equals
an
arbitrarily
c
hosen
v
alue
x
that
satises
the
form
ula
F
.
(If
no
suc
h
x
exists,
the
expression
has
a
completely
arbitrary
v
alue.)
This
statemen
t
denes
NoV
al
to
b
e
some
v
alue
that
is
not
an
elemen
t
of

48
CHAPTER
5.
A
CA
CHING
MEMOR
Y
module
MemoryInterfac
e
v
ariable
memInt
const
ants
Send
(
;
;
;
);
A
Send
(p
;
d
;
memInt
;
memInt
0
)
step
represen
ts
pro
cessor
p
sending
v
alue
d
to
the
memory
.
R
eply
(
;
;
;
);
A
R
eply
(p
;
d
;
memInt
;
memInt
0
)
step
represen
ts
the
memory
sending
v
alue
d
to
pro
cessor
p
.
InitMemInt
;
The
set
of
p
ossible
initial
v
alues
of
memInt
.
Pr
o
c
;
The
set
of
pro
cessor
iden
tiers.
A
dr
;
The
set
of
memory
addresses.
V
al
The
set
of
memory
v
alues.
assume
8
p
;
d
;
miOld
;
miNew
:
^
Send
(p
;
d
;
miOld
;
miNew
)
2
boolean
^
R
eply
(p
;
d
;
miOld
;
miNew
)
2
boolean
MR
e
q

=
[op
:
f\Rd"
g;
adr
:
A
dr
]
[
[op
:
f\W
r"
g;
adr
:
A
dr
;
val
:
V
al
]
The
set
of
all
requests;
a
read
sp
ecies
an
address,
a
write
sp
ecies
an
address
and
a
v
alue.
NoV
al

=
choose
v
:
v
=
2
V
al
An
arbitrary
v
alue
not
in
V
al
.
Figure
5.1:
The
sp
ecication
of
a
memory
in
terface.
V
al
.
W
e
ha
v
e
no
idea
what
the
v
alue
of
NoV
al
is;
w
e
just
kno
w
what
it
isn't|
namely
,
that
it
isn't
an
elemen
t
of
V
al
.
The
choose
op
erator
is
discussed
in
Section
6.6
on
page
73.
The
complete
memory
in
terface
sp
ecication
is
mo
dule
MemoryInterfac
e
in
Figure
5.1
on
this
page.
5.2
F
unctions
A
memory
assigns
v
alues
to
addresses.
The
state
of
the
memory
is
therefore
an
assignmen
t
of
elemen
ts
of
V
al
(memory
v
alues)
to
elemen
ts
of
A
dr
(memory
addresses).
In
a
programming
language,
suc
h
an
assignmen
t
is
called
an
arra
y
of
t
yp
e
V
al
indexed
b
y
A
dr
.
In
mathematics,
it's
called
a
function
from
A
dr
to
V
al
.
Before
writing
the
memory
sp
ecication,
let's
lo
ok
at
the
mathematics
of
functions,
and
ho
w
it
is
describ
ed
in
TLA
+
.
A
function
f
has
a
domain,
written
domain
f
,
and
it
assigns
to
eac
h
elemen
t
x
of
its
domain
the
v
alue
f
[x
].
(Mathematicians
write
this
as
f
(x
),
but
TLA
+
uses
the
arra
y
notation
of
programming
languages,
with
square
brac
k
ets.)
Tw
o
functions
f
and
g
are
equal
i
they
ha
v
e
the
same
domain
and
f
[x
]
=
g
[x
]
for
all
x
in
their
domain.
The
r
ange
of
a
function
f
is
the
set
of
all
v
alues
of
the
form
f
[x
]
with
x
in
domain
f
.
F
or
an
y
sets
S
and
T
,
the
set
of
all
functions
whose
domain
equals
S
and
whose
range
is
an
y
subset
of
T
is
written
[S
!
T
].

5.2.
FUNCTIONS
49
Ordinary
mathematics
do
es
not
ha
v
e
a
con
v
enien
t
notation
for
writing
an
ex-
pression
whose
v
alue
is
a
function.
TLA
+
denes
[x
2
S
7!
e
]
to
b
e
the
function
f
with
domain
S
suc
h
that
f
[x
]
=
e
for
ev
ery
x
2
S
.
3
F
or
example,
suc
c

=
[n
2
Nat
7!
n
+
1]
denes
suc
c
to
b
e
the
successor
function
on
the
natural
n
um
b
ers|the
function
with
domain
Nat
suc
h
that
suc
c
[n
]
=
n
+
1
for
all
n
2
Nat
.
A
record
is
a
function
whose
domain
is
a
nite
set
of
strings.
F
or
example,
a
record
with
val
,
ack
,
and
r
dy
elds
is
a
function
whose
domain
is
the
set
f\val"
;
\ack"
;
\rdy"
g
consisting
of
the
three
strings
\val"
,
\ack"
,
and
\rdy".
The
expression
r
:ack
,
the
ack
eld
of
a
record
r
,
is
an
abbreviation
for
r
[\ack"
].
The
record
[val
7!
42;
ack
7!
1;
r
dy
7!
0]
can
b
e
written
[i
2
f\val"
;
\ack"
;
\rdy"g
7!
if
i
=
\val"
then
42
else
if
i
=
\ack"
then
1
else
0]
The
ex
cept
construct
for
records,
explained
in
Section
3.2,
is
a
sp
ecial
case
of
a
general
ex
cept
construct
for
functions,
where
!
:c
is
an
abbreviation
for
!
[\c"
].
F
or
an
y
function
f
,
the
expression
[f
ex
cept
!
[c
]
=
e
]
is
the
function
^
f
that
is
the
same
as
f
except
with
^
f
[c
]
=
e
.
This
function
can
also
b
e
written
[x
2
domain
f
7!
if
x
=
c
then
e
else
f
[x
]
]
assuming
that
the
sym
b
ol
x
do
es
not
o
ccur
in
an
y
of
the
expressions
f
,
c
,
and
e
.
F
or
example,
[suc
c
ex
cept
!
[42]
=
86]
is
the
function
g
that
is
the
same
as
suc
c
except
that
g
[42]
equals
86
instead
of
43.
As
in
the
ex
cept
construct
for
records,
the
expression
e
in
[f
ex
cept
!
[c
]
=
e
]
can
con
tain
the
sym
b
ol
@,
where
it
means
f
[c
].
F
or
example,
[suc
c
ex
cept
!
[42]
=
2

@]
=
[suc
c
ex
cept
!
[42]
=
2

suc
c
[42]
]
In
general,
[f
ex
cept
!
[c
1
]
=
e
1
;
:
:
:
;
!
[c
n
]
=
e
n
]
3
The
2
in
[x
2
S
7!
e
]
is
just
part
of
the
syn
tax;
TLA
+
uses
that
particular
sym
b
ol
to
help
y
ou
remem
b
er
what
the
construct
means.
Computer
scien
tists
write
x
:
S
:e
to
represen
t
something
similar
to
[x
2
S
7!
e
]
,
except
that
their

expressions
aren't
quite
the
same
as
the
functions
of
ordinary
mathematics
that
are
used
in
TLA
+
.

50
CHAPTER
5.
A
CA
CHING
MEMOR
Y
is
the
function
^
f
that
is
the
same
as
f
except
with
^
f
[c
i
]
=
e
i
for
eac
h
i
.
More
precisely
,
this
expression
equals
[:
:
:
[
[f
ex
cept
!
[c
1
]
=
e
1
]
ex
cept
!
[c
2
]
=
e
2
]
:
:
:
ex
cept
!
[c
n
]
=
e
n
]
F
unctions
corresp
ond
to
the
arra
ys
of
programming
languages.
The
domain
of
a
function
corresp
onds
to
the
index
set
of
an
arra
y
.
F
unction
[f
ex
cept
!
[c
]
=
e
]
corresp
onds
to
the
arra
y
obtained
from
f
b
y
assigning
e
to
f
[c
].
A
function
whose
range
is
a
set
of
functions
corresp
onds
to
an
arra
y
of
arra
ys.
TLA
+
denes
[f
ex
cept
!
[c
][d
]
=
e
]
to
b
e
the
function
corresp
onding
to
the
arra
y
obtained
b
y
assigning
e
to
f
[c
][d
].
It
can
b
e
written
as
[f
ex
cept
!
[c
]
=
[@
ex
cept
!
[d
]
=
e
]]
The
generalization
to
[f
ex
cept
!
[c
1
]
:
:
:
[c
n
]
=
e
]
for
an
y
n
should
b
e
ob
vious.
Since
a
record
is
a
function,
this
notation
can
b
e
used
for
records
as
w
ell.
TLA
+
uniformly
main
tains
the
notation
that

:c
is
an
abbreviation
for

[\c"
].
F
or
example,
this
implies
[f
ex
cept
!
[c
]:d
=
e
]
=
[f
ex
cept
!
[c
][\d"
]
=
e
]
=
[f
ex
cept
!
[c
]
=
[@
ex
cept
!
:d
=
e
]]
The
TLA
+
denition
of
records
as
functions
mak
es
it
p
ossible
to
manipulate
them
in
w
a
ys
that
ha
v
e
no
coun
terparts
in
programming
languages.
F
or
example,
w
e
can
dene
an
op
erator
R
suc
h
that
R
(r
;
s
)
is
the
record
obtained
from
r
b
y
replacing
the
v
alue
of
eac
h
eld
c
that
is
also
a
eld
of
the
record
s
with
s
:c
.
In
other
w
ords,
for
ev
ery
eld
c
of
r
,
if
c
is
a
eld
of
s
then
R
(r
;
s
):c
=
s
:c
;
otherwise
R
(r
;
s
):c
=
r
:c
.
The
denition
is
R
(r
;
s
)

=
[c
2
domain
r
7!
if
c
2
domain
s
then
s
[c
]
else
r
[c
]
]
So
far,
w
e
ha
v
e
seen
only
functions
of
a
single
argumen
t,
whic
h
are
the
mathematical
analog
of
the
one-dimensional
arra
ys
of
programming
languages.
Mathematicians
also
use
functions
of
m
ultiple
argumen
ts,
whic
h
are
the
analog
of
m
ulti-dimensional
arra
ys.
In
TLA
+
,
as
in
ordinary
mathematics,
a
function
of
m
ultiple
argumen
ts
is
one
whose
domain
is
a
set
of
tuples.
F
or
example,
f
[5;
3;
1]
is
an
abbreviation
for
f
[h
5;
3;
1
i],
the
v
alue
of
the
function
f
applied
to
the
triple
h
5;
3;
1
i.
The
function
constructs
of
TLA
+
ha
v
e
extensions
for
functions
of
m
ultiple
argumen
ts.
F
or
example,
[g
ex
cept
!
[a
;
b
]
=
e
]
is
the
function
b
g
that
is
the
same
as
g
except
with
b
g
[a
;
b
]
equal
to
e
.
The
expression
[n
2
Nat
;
r
2
R
e
al
7!
n

r
]
(5.1)
equals
the
function
f
suc
h
that
f
[n
;
r
]
equals
n

r
,
for
all
n
2
Nat
and
r
2
R
e
al
.
Just
as
8
i
2
S
:
8
j
2
S
:
P
can
b
e
written
as
8
i
;
j
2
S
:
P
,
w
e
can
write
the
function
[i
2
S
;
j
2
S
7!
e
]
as
[i
;
j
2
S
7!
e
]
.

5.3.
A
LINEARIZABLE
MEMOR
Y
51
Section
16.1.7
on
page
301
describ
es
the
general
v
ersions
of
the
TLA
+
func-
tion
constructs
for
functions
with
an
y
n
um
b
er
of
argumen
ts.
Ho
w
ev
er,
functions
of
a
single
argumen
t
are
all
y
ou're
lik
ely
to
need.
Y
ou
can
almost
alw
a
ys
replace
a
function
of
m
ultiple
argumen
ts
with
a
function-v
alued
function|for
example,
writing
f
[a
][b
]
instead
of
f
[a
;
b
].
5.3
A
Linearizable
Memory
W
e
no
w
sp
ecify
a
v
ery
simple
memory
system
in
whic
h
a
pro
cessor
p
issues
a
memory
request
and
then
w
aits
for
a
resp
onse
b
efore
issuing
the
next
request.
In
our
sp
ecication,
the
request
is
executed
b
y
accessing
(reading
or
mo
difying)
a
v
ariable
mem
,
whic
h
represen
ts
the
curren
t
state
of
the
memory
.
Because
the
memory
can
receiv
e
requests
from
other
pro
cessors
b
efore
resp
onding
to
pro
cessor
p
,
it
matters
when
mem
is
accessed.
W
e
let
the
access
of
mem
o
ccur
an
y
time
b
et
w
een
the
request
and
the
resp
onse.
This
sp
ecies
what
is
called
a
line
arizable
memory
.
Less
restrictiv
e,
more
practical
memory
sp
ecications
are
describ
ed
in
Section
11.2.
In
addition
to
mem
,
the
sp
ecication
has
the
in
ternal
v
ariables
ctl
and
buf
,
where
ctl
[p
]
describ
es
the
status
of
pro
cessor
p
's
request,
and
buf
[p
]
con
tains
either
the
request
or
the
resp
onse.
Consider
the
request
r
e
q
that
equals
[op
7!
\W
r";
adr
7!
a
;
val
7!
v
]
It
is
a
request
to
write
v
to
memory
address
a
,
and
it
generates
the
resp
onse
NoV
al
.
The
pro
cessing
of
this
request
is
represen
ted
b
y
the
follo
wing
three
steps:
2
4
ctl
[p
]
=
\rdy"
buf
[p
]
=



mem
[a
]
=



3
5
R
e
q
(p
)
 !
2
4
ctl
[p
]
=
\busy"
buf
[p
]
=
r
e
q
mem
[a
]
=



3
5
Do
(p
)
 !
2
4
ctl
[p
]
=
\done"
buf
[p
]
=
NoV
al
mem
[a
]
=
v
3
5
Rsp
(p
)
 !
2
4
ctl
[p
]
=
\rdy"
buf
[p
]
=
NoV
al
mem
[a
]
=
v
3
5
A
R
e
q
(p
)
step
represen
ts
the
issuing
of
a
request
b
y
pro
cessor
p
.
It
is
enabled
when
ctl
[p
]
=
\rdy";
it
sets
ctl
[p
]
to
\busy"
and
sets
buf
[p
]
to
the
request.
A
Do
(p
)
step
represen
ts
the
memory
access;
it
is
enabled
when
ctl
[p
]
=
\busy"
and
it
sets
ctl
[p
]
to
\done"
and
buf
[p
]
to
the
resp
onse.
A
Rsp
(p
)
step
represen
ts
the
memory's
resp
onse
to
p
;
it
is
enabled
when
ctl
[p
]
=
\done"
and
it
sets
ctl
[p
]
to
\rdy"
.
W
riting
the
sp
ecication
is
a
straigh
tforw
ard
exercise
in
represen
ting
these
c
hanges
to
the
v
ariables
in
TLA
+
notation.
The
in
ternal
sp
ecication,
with
mem
,
ctl
,
and
buf
visible
(free
v
ariables),
app
ears
in
mo
dule
InternalMemory
on
the
follo
wing
t
w
o
pages.
The
memory
sp
ecication,
whic
h
hides
the
three
in
ternal
v
ariables,
is
mo
dule
Memory
in
Figure
5.3
on
page
53.

52
CHAPTER
5.
A
CA
CHING
MEMOR
Y
module
InternalMemory
extends
MemoryInterfac
e
v
ariables
mem
;
ctl
;
buf
IInit

=
The
initial
predicate
^
mem
2
[A
dr
!
V
al
]
^
ctl
=
[p
2
Pr
o
c
7!
\rdy"
]
^
buf
=
[p
2
Pr
o
c
7!
NoV
al
]
^
memInt
2
InitMemInt
Initially
,
memory
lo
cations
ha
v
e
an
y
v
alues
in
V
al
,
eac
h
pro
cessor
is
ready
to
issue
requests,
eac
h
buf
[p
]
is
arbitrarily
initialized
to
NoV
al
,
and
memInt
is
an
y
elemen
t
of
InitMemInt
.
T
yp
eInvariant

=
The
t
yp
e-correctness
in
v
arian
t.
^
mem
2
[A
dr
!
V
al
]
^
ctl
2
[Pr
o
c
!
f\rdy";
\busy"
;
\done"
g]
^
buf
2
[Pr
o
c
!
MR
e
q
[
V
al
[
fNoV
al
g]
mem
is
a
function
from
A
dr
to
V
al
.
ctl
[p
]
equals
\rdy"
,
\busy"
,
or
\done"
.
buf
[p
]
is
a
request
or
a
resp
onse.
R
e
q
(p
)

=
Pro
cessor
p
issues
a
request.
^
ctl
[p
]
=
\rdy"
Enabled
i
p
is
ready
to
issue
a
request.
^
9
r
e
q
2
MR
e
q
:
F
or
some
request
r
e
q
:
^
Send
(p
;
r
e
q
;
memInt
;
memInt
0
)
^
buf
0
=
[buf
ex
cept
!
[p
]
=
r
e
q
]
^
ctl
0
=
[ctl
ex
cept
!
[p
]
=
\busy"
]
Send
r
e
q
on
the
in
terface.
Set
buf
[p
]
to
the
request.
Set
ctl
[p
]
to
\busy"
.
^
unchanged
mem
Do
(p
)

=
P
erform
p
's
request
to
memory
.
^
ctl
[p
]
=
\busy"
Enabled
i
p
's
request
is
p
ending.
^
mem
0
=
if
buf
[p
]:op
=
\W
r"
then
[mem
ex
cept
!
[buf
[p
]:adr
]
=
buf
[p
]:val
]
else
mem
Lea
v
e
mem
unc
hanged
on
a
\Rd"
request.
W
rite
to
memory
on
a
\W
r"
request.
^
buf
0
=
[buf
ex
cept
!
[p
]
=
if
buf
[p
]:op
=
\W
r"
Set
buf
[p
]
to
the
resp
onse:
NoV
al
for
a
write;
the
memory
v
alue
for
a
read.
Set
ctl
[p
]
to
\done"
.
then
NoV
al
else
mem
[buf
[p
]:adr
]
]
^
ctl
0
=
[ctl
ex
cept
!
[p
]
=
\done"
]
^
unchanged
memInt
Figure
5.2a:
The
in
ternal
memory
sp
ecication
(b
eginning).

5.4.
TUPLES
AS
FUNCTIONS
53
Rsp
(p
)

=
Return
the
resp
onse
to
p
's
request.
^
ctl
[p
]
=
\done"
^
R
eply
(p
;
buf
[p
];
memInt
;
memInt
0
)
^
ctl
0
=
[ctl
ex
cept
!
[p
]
=
\rdy"]
^
unchanged
h
mem
;
buf
i
Enabled
i
req.
is
done
but
resp.
not
sen
t.
Send
the
resp
onse
on
the
in
terface.
Set
ctl
[p
]
to
\rdy".
INext

=
9
p
2
Pr
o
c
:
R
e
q
(p
)
_
Do
(p
)
_
Rsp
(p
)
The
next-state
action.
ISp
e
c

=
IInit
^
2[INext
]
h
memInt
;
mem
;
ctl
;
buf
i
The
sp
ecication.
theorem
ISp
e
c
)
2T
yp
eInvariant
Figure
5.2b:
The
in
ternal
memory
sp
ecication
(end).
5.4
T
uples
as
F
unctions
Before
writing
our
cac
hing
memory
sp
ecication,
let's
tak
e
a
closer
lo
ok
at
tu-
ples.
Recall
that
h
a
;
b
;
c
i
is
the
3-tuple
with
comp
onen
ts
a
,
b
,
and
c
.
In
TLA
+
,
this
3-tuple
is
actually
the
function
with
domain
f1;
2;
3g
that
maps
1
to
a
,
2
to
b
,
and
3
to
c
.
Th
us,
h
a
;
b
;
c
i[2]
equals
b
.
TLA
+
pro
vides
the
Cartesian
pro
duct
op
erator

of
ordinary
mathematics,
where
A

B

C
is
the
set
of
all
3-tuples
h
a
;
b
;
c
i
suc
h
that
a
2
A,
b
2
B
,
and
c
2
C
.
Note
that
A

B

C
is
dieren
t
from
A

(B

C
),
whic
h
is
the
set
of
pairs
h
a
;
p
i
with
a
in
A
and
p
in
the
set
of
pairs
B

C
.
The
Se
quenc
es
mo
dule
denes
nite
sequences
to
b
e
tuples.
Hence,
a
se-
quence
of
length
n
is
a
function
with
domain
1
:
:
n
.
In
fact,
s
is
a
sequence
i
it
equals
[i
2
1
:
:
L
en
(s
)
7!
s
[i
]
]
.
Belo
w
are
a
few
op
erator
denitions
from
the
Se
quenc
es
mo
dule.
(The
meanings
of
the
op
erators
are
describ
ed
in
Section
4.1.)
He
ad
(s
)

=
s
[1]
T
ail
(s
)

=
[i
2
1
:
:
(L
en
(s
)
 1)
7!
s
[i
+
1]]
s

t

=
[i
2
1
:
:
(L
en
(s
)
+
L
en
(t
))
7!
if
i

L
en
(s
)
then
s
[i
]
else
t
[i
 L
en
(s
)]
]
module
Memory
extends
MemoryInterfac
e
Inner
(mem
;
ctl
;
buf
)

=
inst
ance
InternalMemory
Sp
e
c

=
9
9
9
9
9
9
mem
;
ctl
;
buf
:
Inner
(mem
;
ctl
;
buf
)
!
ISp
e
c
Figure
5.3:
The
memory
sp
ecication.

54
CHAPTER
5.
A
CA
CHING
MEMOR
Y
5.5
Recursiv
e
F
unction
Denitions
W
e
need
one
more
to
ol
to
write
the
cac
hing
memory
sp
ecication:
recursiv
e
function
denitions.
Recursiv
ely
dened
functions
are
familiar
to
programmers.
The
classic
example
is
the
factorial
function,
whic
h
I'll
call
fact
.
It's
usually
dened
b
y
writing
fact
[n
]
=
if
n
=
0
then
1
else
n

fact
[n
 1]
for
all
n
2
Nat
.
The
TLA
+
notation
for
writing
functions
suggests
trying
to
dene
fact
b
y
fact

=
[n
2
Nat
7!
if
n
=
0
then
1
else
n

fact
[n
 1]]
This
denition
is
illegal
b
ecause
the
o
ccurrence
of
fact
to
the
righ
t
of
the

=
is
undened|fact
is
dened
only
after
its
denition.
TLA
+
do
es
allo
w
the
apparen
t
circularit
y
of
recursiv
e
function
denitions.
W
e
can
dene
the
factorial
function
fact
b
y
fact
[n
2
Nat
]

=
if
n
=
0
then
1
else
n

fact
[n
 1]
In
general,
a
denition
of
the
form
f
[x
2
S
]

=
e
can
b
e
used
to
dene
recursiv
ely
a
function
f
with
domain
S
.
The
function
denition
notation
has
a
straigh
tforw
ard
generalization
to
def-
initions
of
functions
of
m
ultiple
argumen
ts.
F
or
example,
A
cker
[m
;
n
2
Nat
]

=
if
m
=
0
then
n
+
1
else
if
n
=
0
then
A
cker
[m
 1;
0]
else
A
cker
[m
 1;
A
cker
[m
;
n
 1]]
denes
A
cker
[m
;
n
]
for
all
natural
n
um
b
ers
m
and
n
.
Section
6.3
explains
exactly
what
recursiv
e
denitions
mean.
F
or
no
w,
w
e
will
just
write
recursiv
e
denitions
without
w
orrying
ab
out
their
meaning.
5.6
A
W
rite-Through
Cac
he
W
e
no
w
sp
ecify
a
simple
write-through
cac
he
that
implemen
ts
the
memory
sp
ec-
ication.
The
system
is
describ
ed
b
y
the
picture
of
Figure
5.4
on
the
next
page.
Eac
h
pro
cessor
p
comm
unicates
with
a
lo
cal
con
troller,
whic
h
main
tains
three
state
comp
onen
ts:
buf
[p
],
ctl
[p
],
and
c
ache
[p
].
The
v
alue
of
c
ache
[p
]
represen
ts
the
pro
cessor's
cac
he;
buf
[p
]
and
ctl
[p
]
pla
y
the
same
role
as
in
the
in
ternal
memory
sp
ecication
(mo
dule
InternalMemory
).
(Ho
w
ev
er,
as
w
e
will
see
b
e-
lo
w,
ctl
[p
]
can
assume
an
additional
v
alue
\w
aiting"
.)
These
lo
cal
con
trollers

5.6.
A
WRITE-THR
OUGH
CA
CHE
55
q
q
q

c
ache
[p
]
6
?
buf
[p
]
-

memInt
-
Pro
cessor
p
ctl
[p
]
q
q
q
-
-
memQ
wmem

bus
Figure
5.4:
The
write-through
cac
he.
comm
unicate
with
the
main
memory
wmem
,
4
and
with
one
another,
o
v
er
a
bus.
Requests
from
the
pro
cessors
to
the
main
memory
are
in
the
queue
memQ
of
maxim
um
length
QL
en
.
A
write
request
b
y
pro
cessor
p
is
p
erformed
b
y
the
action
DoWr
(p
).
This
is
a
write-through
cac
he,
meaning
that
ev
ery
write
request
up
dates
main
memory
.
So,
the
DoWr
(p
)
action
writes
the
v
alue
in
to
c
ache
[p
]
and
adds
the
write
request
to
the
tail
of
memQ
.
When
the
request
reac
hes
the
head
of
memQ
,
the
action
MemQWr
stores
the
v
alue
in
wmem
.
The
DoWr
(p
)
action
also
up
dates
c
ache
[q
]
for
ev
ery
other
pro
cessor
q
that
has
a
cop
y
of
the
address
in
its
cac
he.
A
read
request
b
y
pro
cessor
p
is
p
erformed
b
y
the
action
DoR
d
(p
),
whic
h
obtains
the
v
alue
from
the
cac
he.
If
the
v
alue
is
not
in
the
cac
he,
the
action
R
dMiss
(p
)
adds
the
request
to
the
tail
of
memQ
and
sets
ctl
[p
]
to
\w
aiting"
.
When
the
enqueued
request
reac
hes
the
head
of
memQ
,
the
action
MemQR
d
reads
the
v
alue
and
puts
it
in
c
ache
[p
],
enabling
the
DoR
d
(p
)
action.
W
e
migh
t
exp
ect
the
MemQR
d
action
to
read
the
v
alue
from
wmem
.
Ho
w-
ev
er,
this
could
cause
an
error
if
there
is
a
write
to
that
address
enqueued
in
memQ
b
ehind
the
read
request.
In
that
case,
reading
the
v
alue
from
mem-
ory
could
lead
to
t
w
o
pro
cessors
ha
ving
dieren
t
v
alues
for
the
address
in
their
cac
hes:
the
one
that
issued
the
read
request,
and
the
one
that
issued
the
write
request
that
follo
w
ed
the
read
in
memQ
.
So,
the
MemQR
d
action
m
ust
read
the
v
alue
from
the
last
write
to
that
address
in
memQ
,
if
there
is
suc
h
a
write;
otherwise,
it
reads
the
v
alue
from
wmem
.
4
W
e
use
the
name
wmem
to
distinguish
this
v
ariable
from
v
ariable
mem
of
mo
dule
InternalMemory
.
W
e
don't
ha
v
e
to,
since
mem
is
not
a
free
(visible)
v
ariable
of
the
actual
memory
sp
ecication
in
mo
dule
Memory
,
but
it
helps
us
a
v
oid
getting
confused.

56
CHAPTER
5.
A
CA
CHING
MEMOR
Y
Eviction
of
an
address
from
pro
cessor
p
's
cac
he
is
represen
ted
b
y
a
separate
Evict
(p
)
action.
Since
all
cac
hed
v
alues
ha
v
e
b
een
written
to
memory
,
eviction
do
es
nothing
but
remo
v
e
the
address
from
the
cac
he.
There
is
no
reason
to
evict
an
address
un
til
the
space
is
needed,
so
in
an
implemen
tation,
this
action
w
ould
b
e
executed
only
when
a
request
for
an
uncac
hed
address
is
receiv
ed
from
p
and
p
's
cac
he
is
full.
But
that's
a
p
erformance
optimization;
it
do
esn't
aect
the
correctness
of
the
algorithm,
so
it
do
esn't
app
ear
in
the
sp
ecication.
W
e
allo
w
a
cac
hed
address
to
b
e
evicted
from
p
's
cac
he
at
an
y
time|except
if
the
address
w
as
just
put
there
b
y
a
MemQR
d
action
for
a
read
request
whose
DoR
d
(p
)
action
has
not
y
et
b
een
p
erformed.
This
is
the
case
when
ctl
[p
]
equals
\w
aiting"
and
buf
[p
]:adr
equals
the
cac
hed
address.
The
actions
R
e
q
(p
)
and
Rsp
(p
),
whic
h
represen
t
pro
cessor
p
issuing
a
request
and
the
memory
issuing
a
reply
to
p
,
are
the
same
as
the
corresp
onding
actions
of
the
memory
sp
ecication,
except
that
they
also
lea
v
e
the
new
v
ariables
c
ache
and
memQ
unc
hanged,
and
they
lea
v
e
unc
hanged
vmem
instead
of
mem
.
T
o
sp
ecify
all
these
actions,
w
e
m
ust
decide
ho
w
the
pro
cessor
cac
hes
and
the
queue
of
requests
to
memory
are
represen
ted
b
y
the
v
ariables
memQ
and
c
ache
.
W
e
let
memQ
b
e
a
sequence
of
pairs
of
the
form
h
p
;
r
e
q
i,
where
r
e
q
is
a
request
and
p
is
the
pro
cessor
that
issued
it.
F
or
an
y
memory
address
a
,
w
e
let
c
ache
[p
][a
]
b
e
the
v
alue
in
p
's
cac
he
for
address
a
(the
\cop
y"
of
a
in
p
's
cac
he).
If
p
's
cac
he
do
es
not
ha
v
e
a
cop
y
of
a
,
w
e
let
c
ache
[p
][a
]
equal
NoV
al
.
The
sp
ecication
app
ears
in
mo
dule
WriteThr
oughCache
on
pages
57{59.
I'll
no
w
go
through
this
sp
ecication,
explaining
some
of
the
ner
p
oin
ts
and
some
notation
that
w
e
ha
v
en't
encoun
tered
b
efore.
The
extends,
declaration
statemen
ts,
and
assume
are
familiar.
W
e
can
reuse
some
of
the
denitions
from
the
InternalMemory
mo
dule,
so
an
inst
ance
statemen
t
instan
tiates
a
cop
y
of
that
mo
dule
with
wmem
substituted
for
mem
.
(The
other
parameters
of
mo
dule
InternalMemory
are
instan
tiated
b
y
the
pa-
rameters
of
the
same
name
in
mo
dule
WriteThr
oughCache
.)
The
initial
predicate
Init
con
tains
the
conjunct
M
!
IInit
,
whic
h
asserts
that
ctl
and
buf
ha
v
e
the
same
initial
v
alues
as
in
the
in
ternal
memory
sp
ecication,
and
that
wmem
has
the
same
initial
v
alue
as
mem
do
es
in
that
sp
ecication.
The
write-through
cac
he
allo
ws
ctl
[p
]
to
ha
v
e
the
v
alue
\w
aiting"
that
it
didn't
in
the
in
ternal
memory
sp
ecication,
so
w
e
can't
reuse
the
in
ternal
memory's
t
yp
e
in
v
arian
t
M
!
T
yp
eInvariant
.
F
orm
ula
T
yp
eInvariant
therefore
explicitly
describ
es
the
t
yp
es
of
wmem
,
ctl
,
and
buf
.
The
t
yp
e
of
memQ
is
the
set
of
sequences
of
h
pro
cessor
;
request
i
pairs.
The
mo
dule
next
denes
the
predicate
Coher
enc
e
,
whic
h
asserts
the
basic
cac
he
coherence
prop
ert
y
of
the
write-through
cac
he:
for
an
y
pro
cessors
p
and
q
and
an
y
address
a
,
if
p
and
q
b
oth
ha
v
e
copies
of
address
a
in
their
cac
hes,
then
those
copies
are
equal.
Note
the
tric
k
of
writing
x
=
2
fy
;
z
g
instead
of
the
equiv
alen
t
but
longer
form
ula
(x
6=
y
)
^
(x
6=
z
).

5.6.
A
WRITE-THR
OUGH
CA
CHE
57
module
WriteThr
oughCache
extends
Natur
als
;
Se
quenc
es
;
MemoryInterfac
e
v
ariables
wmem
;
ctl
;
buf
;
c
ache
;
memQ
const
ant
QL
en
assume
(QL
en
2
Nat
)
^
(QL
en
>
0)
M

=
inst
ance
InternalMemory
with
mem
 
wmem
Init

=
The
initial
predicate
^
M
!
IInit
^
c
ache
=
[p
2
Pr
o
c
7!
[a
2
A
dr
7!
NoV
al
]
]
^
memQ
=
h
i
wmem
,
buf
,
and
ctl
are
initialized
as
in
the
in
ternal
memory
sp
ec.
All
cac
hes
are
initially
empt
y
(c
ache
[p
][a
]
=
NoV
al
for
all
p
,
a
).
The
queue
memQ
is
initially
empt
y
.
T
yp
eInvariant

=
The
t
yp
e
in
v
arian
t.
^
wmem
2
[A
dr
!
V
al
]
^
ctl
2
[Pr
o
c
!
f\rdy"
;
\busy"
;
\w
aiting"
;
\done"
g]
^
buf
2
[Pr
o
c
!
MR
e
q
[
V
al
[
fNoV
al
g]
^
c
ache
2
[Pr
o
c
!
[A
dr
!
V
al
[
fNoV
al
g]
]
^
memQ
2
Se
q
(Pr
o
c

MR
e
q
)
memQ
is
a
sequence
of
h
pro
c.,
request
i
pairs.
Coher
enc
e

=
Asserts
that
if
t
w
o
pro
cessors'
cac
hes
b
oth
ha
v
e
copies
of
an
address,
then
those
copies
ha
v
e
equal
v
alues.
8
p
;
q
2
Pr
o
c
;
a
2
A
dr
:
(NoV
al
=
2
fc
ache
[p
][a
];
c
ache
[q
][a
]g)
)
(c
ache
[p
][a
]
=
c
ache
[q
][a
])
R
e
q
(p
)

=
Pro
cessor
p
issues
a
request.
M
!
R
e
q
(p
)
^
unchanged
h
c
ache
;
memQ
i
Rsp
(p
)

=
The
system
issues
a
resp
onse
to
pro
cessor
p
.
M
!
Rsp
(p
)
^
unchanged
h
c
ache
;
memQ
i
R
dMiss
(p
)

=
Enqueue
a
request
to
write
v
alue
from
memory
to
p
's
cac
he.
^
(ctl
[p
]
=
\busy"
)
^
(buf
[p
]:op
=
\Rd"
)
^
c
ache
[p
][buf
[p
]:adr
]
=
NoV
al
^
L
en
(memQ
)
<
QL
en
^
memQ
0
=
App
end
(memQ
;
h
p
;
buf
[p
]
i)
^
ctl
0
=
[ctl
ex
cept
!
[p
]
=
\w
aiting"
]
^
unchanged
h
memInt
;
wmem
;
buf
;
c
ache
i
Enabled
on
a
read
request
when
the
address
is
not
in
p
's
cac
he
and
memQ
is
not
full.
App
end
h
p
;
request
i
to
memQ
.
Set
ctl
[p
]
to
\w
aiting"
.
Figure
5.5a:
The
write-through
cac
he
sp
ecication
(b
eginning).

58
CHAPTER
5.
A
CA
CHING
MEMOR
Y
DoR
d
(p
)

=
P
erform
a
read
b
y
p
of
a
v
alue
in
its
cac
he.
^
ctl
[p
]
2
f\busy"
;
\w
aiting"
g
^
buf
[p
]:op
=
\Rd"
^
c
ache
[p
][buf
[p
]:adr
]
6=
NoV
al
^
buf
0
=
[buf
ex
cept
!
[p
]
=
c
ache
[p
][buf
[p
]:adr
]
]
^
ctl
0
=
[ctl
ex
cept
!
[p
]
=
\done"
]
^
unchanged
h
memInt
;
wmem
;
c
ache
;
memQ
i
Enabled
if
a
read
request
is
p
ending
and
address
is
in
cac
he.
Get
result
from
cac
he.
Set
ctl
[p
]
to
\done"
.
DoWr
(p
)

=
W
rite
to
p
's
cac
he,
up
date
other
cac
hes,
and
enqueue
memory
up
date.
let
r

=
buf
[p
]
Pro
cessor
p
's
request.
in
^
(ctl
[p
]
=
\busy"
)
^
(r
:op
=
\W
r")
Enabled
if
write
request
p
ending
and
memQ
is
not
full.
^
L
en
(memQ
)
<
QL
en
^
c
ache
0
=
Up
date
p
's
cac
he
and
an
y
other
cac
he
that
has
a
cop
y
.
[q
2
Pr
o
c
7!
if
(p
=
q
)
_
(c
ache
[q
][r
:adr
]
6=
NoV
al
)
then
[c
ache
[q
]
ex
cept
!
[r
:adr
]
=
r
:val
]
else
c
ache
[q
]]
^
memQ
0
=
App
end
(memQ
;
h
p
;
r
i)
Enqueue
write
at
tail
of
memQ
.
Generate
resp
onse.
Set
ctl
to
indicate
request
is
done.
^
buf
0
=
[buf
ex
cept
!
[p
]
=
NoV
al
]
^
ctl
0
=
[ctl
ex
cept
!
[p
]
=
\done"
]
^
unchanged
h
memInt
;
wmem
i
vmem

=
The
v
alue
wmem
will
ha
v
e
after
all
the
writes
in
memQ
are
p
erformed.
let
f
[i
2
0
:
:
L
en
(memQ
)]

=
The
v
alue
wmem
will
ha
v
e
after
the
rst
i
writes
in
memQ
are
p
erformed.
if
i
=
0
then
wmem
else
if
memQ
[i
][2]:op
=
\Rd"
then
f
[i
 1]
else
[f
[i
 1]
ex
cept
!
[memQ
[i
][2]:adr
]
=
memQ
[i
][2]:val
]
in
f
[L
en
(memQ
)]
MemQWr

=
P
erform
write
at
head
of
memQ
to
memory
.
let
r

=
He
ad
(memQ
)[2]
The
request
at
the
head
of
memQ
.
in
^
(memQ
6=
h
i)
^
(r
:op
=
\W
r")
Enabled
if
He
ad
(memQ
)
a
write.
P
erform
the
write
to
memory
.
Remo
v
e
the
write
from
memQ
.
^
wmem
0
=
[wmem
ex
cept
!
[r
:adr
]
=
r
:val
]
^
memQ
0
=
T
ail
(memQ
)
^
unchanged
h
memInt
;
buf
;
ctl
;
c
ache
i
Figure
5.5b:
The
write-through
cac
he
sp
ecication
(middle).

5.6.
A
WRITE-THR
OUGH
CA
CHE
59
MemQR
d

=
P
erform
an
enqueued
read
to
memory
.
let
p

=
He
ad
(memQ
)[1]
The
requesting
pro
cessor.
r

=
He
ad
(memQ
)[2]
The
request
at
the
head
of
memQ
.
in
^
(memQ
6=
h
i)
^
(r
:op
=
\Rd"
)
Enabled
if
He
ad
(memQ
)
is
a
read.
Remo
v
e
the
head
of
memQ
.
^
memQ
0
=
T
ail
(memQ
)
^
c
ache
0
=
Put
v
alue
from
memory
or
memQ
in
p
's
cac
he.
[c
ache
ex
cept
!
[p
][r
:adr
]
=
vmem
[r
:adr
]]
^
unchanged
h
memInt
;
wmem
;
buf
;
ctl
i
Evict
(p
;
a
)

=
Remo
v
e
address
a
from
p
's
cac
he.
^
(ctl
[p
]
=
\w
aiting"
)
)
(buf
[p
]:adr
6=
a
)
Can't
evict
a
if
it
w
as
just
read
in
to
cac
he
from
memory
.
^
c
ache
0
=
[c
ache
ex
cept
!
[p
][a
]
=
NoV
al
]
^
unchanged
h
memInt
;
wmem
;
buf
;
ctl
;
memQ
i
Next

=
_
9
p
2
Pr
o
c
:
_
R
e
q
(p
)
_
Rsp
(p
)
_
R
dMiss
(p
)
_
DoR
d
(p
)
_
DoWr
(p
)
_
9
a
2
A
dr
:
Evict
(p
;
a
)
_
MemQWr
_
MemQR
d
Sp
e
c

=
Init
^
2[Next
]
h
memInt
;
wmem
;
buf
;
ctl
;
c
ache
;
memQ
i
theorem
Sp
e
c
)
2(T
yp
eInvariant
^
Coher
enc
e
)
LM

=
inst
ance
Memory
theorem
Sp
e
c
)
LM
!
Sp
e
c
The
memory
sp
ec.
with
in
ternal
v
ariables
hidden.
F
orm
ula
Sp
e
c
implemen
ts
the
memory
sp
ec.
Figure
5.5c:
The
write-through
cac
he
sp
ecication
(end).
The
actions
R
e
q
(p
)
and
Rsp
(p
),
whic
h
represen
t
a
pro
cessor
sending
a
re-
quest
and
receiving
a
reply
,
are
essen
tially
the
same
as
the
corresp
onding
actions
in
mo
dule
InternalMemory
.
Ho
w
ev
er,
they
m
ust
also
sp
ecify
that
the
v
ariables
c
ache
and
memQ
,
not
presen
t
in
mo
dule
InternalMemory
,
are
left
unc
hanged.
In
the
denition
of
R
dMiss
,
the
expression
App
end
(memQ
;
h
p
;
buf
[p
]
i)
is
the
sequence
obtained
b
y
app
ending
the
elemen
t
h
p
;
buf
[p
]
i
to
the
end
of
memQ
.
The
DoR
d
(p
)
action
represen
ts
the
p
erforming
of
the
read
from
p
's
cac
he.
If
ctl
[p
]
=
\busy"
,
then
the
address
w
as
originally
in
the
cac
he.
If
ctl
[p
]
=
\w
aiting"
,
then
the
address
w
as
just
read
in
to
the
cac
he
from
memory
.
The
DoWr
(p
)
action
writes
the
v
alue
to
p
's
cac
he
and
up
dates
the
v
alue
in
an
y
other
cac
hes
that
ha
v
e
copies.
It
also
enqueues
a
write
request
in
memQ
.
In
an
implemen
tation,
the
request
is
put
on
the
bus,
whic
h
transmits
it
to
the
other
cac
hes
and
to
the
memQ
queue.
In
our
high-lev
el
view
of
the
system,
w
e
represen
t
all
this
as
a
single
step.

60
CHAPTER
5.
A
CA
CHING
MEMOR
Y
The
denition
of
DoWr
in
tro
duces
the
TLA
+
let/in
construct.
The
let
clause
consists
of
a
sequence
of
denitions
whose
scop
e
extends
un
til
the
end
of
the
in
clause.
In
the
denition
of
DoWr
,
the
let
clause
denes
r
to
equal
buf
[p
]
within
the
in
clause.
Observ
e
that
the
denition
of
r
con
tains
the
parameter
p
of
the
denition
of
DoWr
.
Hence,
w
e
could
not
mo
v
e
the
denition
of
r
outside
the
denition
of
DoWr
.
A
denition
in
a
let
is
just
lik
e
an
ordinary
denition
in
a
mo
dule;
in
particular,
it
can
ha
v
e
parameters.
These
lo
cal
denitions
can
b
e
used
to
shorten
an
expression
b
y
replacing
common
sub
expressions
with
an
op
erator.
In
the
denition
of
DoWr
,
I
replaced
v
e
instances
of
buf
[p
]
b
y
the
single
sym
b
ol
r
.
This
w
as
a
silly
thing
to
do,
b
ecause
it
mak
es
almost
no
dierence
in
the
length
of
the
denition
and
it
requires
the
reader
to
remem
b
er
the
denition
of
the
new
sym
b
ol
r
.
But
using
a
let
to
eliminate
common
sub
expressions
can
often
greatly
shorten
and
simplify
an
expression.
A
let
can
also
b
e
used
to
mak
e
an
expression
easier
to
read,
ev
en
if
the
op
erators
it
denes
app
ear
only
once
in
the
in
expression.
W
e
write
a
sp
ecica-
tion
with
a
sequence
of
denitions,
instead
of
just
dening
a
single
monolithic
form
ula,
b
ecause
a
form
ula
is
easier
to
understand
when
presen
ted
in
smaller
c
h
unks.
The
let
construct
allo
ws
the
pro
cess
of
splitting
a
form
ula
in
to
smaller
parts
to
b
e
done
hierarc
hically
.
A
let
can
app
ear
as
a
sub
expression
of
an
in
expression.
Nested
lets
are
common
in
large,
complicated
sp
ecications.
Next
comes
the
denition
of
the
state
function
vmem
,
whic
h
is
used
in
den-
ing
action
MemQR
d
b
elo
w.
It
equals
the
v
alue
that
the
main
memory
wmem
will
ha
v
e
after
all
the
write
op
erations
curren
tly
in
memQ
ha
v
e
b
een
p
erformed.
Recall
that
the
v
alue
read
b
y
MemQR
d
m
ust
b
e
the
most
recen
t
one
written
to
that
address|a
v
alue
that
ma
y
still
b
e
in
memQ
.
That
v
alue
is
the
one
in
vmem
.
The
function
vmem
is
dened
in
terms
of
the
recursiv
ely
dened
func-
tion
f
,
where
f
[i
]
is
the
v
alue
wmem
will
ha
v
e
after
the
rst
i
op
erations
in
memQ
ha
v
e
b
een
p
erformed.
Note
that
memQ
[i
][2]
is
the
second
comp
onen
t
(the
request)
of
memQ
[i
],
the
i
th
elemen
t
in
the
sequence
memQ
.
The
next
t
w
o
actions,
MemQWr
and
MemQR
d
,
represen
t
the
pro
cessing
of
the
request
at
the
head
of
the
memQ
queue|MemQWr
for
a
write
request,
and
MemQR
d
for
a
read
request.
These
actions
also
use
a
let
to
mak
e
lo
cal
denitions.
Here,
the
denitions
of
p
and
r
could
b
e
mo
v
ed
b
efore
the
denition
of
MemQWr
.
In
fact,
w
e
could
sa
v
e
space
b
y
replacing
the
t
w
o
lo
cal
denitions
of
r
with
one
global
(within
the
mo
dule)
denition.
Ho
w
ev
er,
making
the
denition
of
r
global
in
this
w
a
y
w
ould
b
e
somewhat
distracting,
since
r
is
used
only
in
the
denitions
of
MemQWr
and
MemQR
d
.
It
migh
t
b
e
b
etter
instead
to
com
bine
these
t
w
o
actions
in
to
one.
Whether
y
ou
put
a
denition
in
to
a
let
or
mak
e
it
more
global
should
dep
end
on
what
mak
es
the
sp
ecication
easier
to
read.
The
Evict
(p
;
a
)
action
represen
ts
the
op
eration
of
remo
ving
address
a
from
pro
cessor
p
's
cac
he.
As
explained
ab
o
v
e,
w
e
allo
w
an
address
to
b
e
evicted
at
an
y
time|unless
the
address
w
as
just
written
to
satisfy
a
p
ending
read
request,

5.7.
INV
ARIANCE
61
whic
h
is
the
case
i
ctl
[p
]
=
\w
aiting"
and
buf
[p
]:adr
=
a
.
Note
the
use
of
the
\double
subscript"
in
the
ex
cept
expression
of
the
action's
second
conjunct.
This
conjunct
\assigns
NoV
al
to
c
ache
[p
][a
]".
If
address
a
is
not
in
p
's
cac
he,
then
c
ache
[p
][a
]
already
equals
NoV
al
and
an
Evict
(p
;
a
)
step
is
a
stuttering
step.
The
denitions
of
the
next-state
action
Next
and
of
the
complete
sp
ecica-
tion
Sp
e
c
are
straigh
tforw
ard.
The
mo
dule
closes
with
t
w
o
theorems
that
are
discussed
next.
5.7
In
v
ariance
Mo
dule
WriteThr
oughCache
con
tains
the
theorem
theorem
Sp
e
c
)
2(T
yp
eInvariant
^
Coher
enc
e
)
whic
h
asserts
that
T
yp
eInvariant
^
Coher
enc
e
is
an
in
v
arian
t
of
Sp
e
c
.
A
state
predicate
P
^
Q
is
alw
a
ys
true
i
b
oth
P
and
Q
are
alw
a
ys
true,
so
2(P
^
Q
)
is
equiv
alen
t
to
2P
^
2Q
.
This
implies
that
the
theorem
ab
o
v
e
is
equiv
alen
t
to
the
t
w
o
theorems
theorem
Sp
e
c
)
2T
yp
eInvariant
theorem
Sp
e
c
)
2Coher
enc
e
The
rst
theorem
is
the
usual
t
yp
e-in
v
ariance
assertion.
The
second,
whic
h
asserts
that
Coher
enc
e
is
an
in
v
arian
t
of
Sp
e
c
,
expresses
an
imp
ortan
t
prop
ert
y
of
the
algorithm.
Although
T
yp
eInvariant
and
Coher
enc
e
are
b
oth
in
v
arian
ts
of
the
temp
oral
form
ula
Sp
e
c
,
they
dier
in
a
fundamen
tal
w
a
y
.
If
s
is
an
y
state
satisfying
T
yp
eInvariant
,
then
an
y
state
t
suc
h
that
s
!
t
is
a
Next
step
also
satises
T
yp
eInvariant
.
This
prop
ert
y
is
expressed
b
y
theorem
T
yp
eInvariant
^
Next
)
T
yp
eInvariant
0
(Recall
that
T
yp
eInvariant
0
is
the
form
ula
obtained
b
y
priming
all
the
v
ariables
in
form
ula
T
yp
eInvariant
.)
In
general,
when
P
^
N
)
P
0
holds,
w
e
sa
y
that
predicate
P
is
an
in
v
arian
t
of
action
N
.
Predicate
T
yp
eInvariant
is
an
in
v
arian
t
An
in
v
arian
t
of
a
sp
ecication
S
that
is
also
an
in
v
arian
t
of
its
next-state
ac-
tion
is
sometimes
called
an
inductive
in
v
arian
t
of
S
.
of
Sp
e
c
b
ecause
it
is
an
in
v
arian
t
of
Next
and
it
is
implied
b
y
the
initial
predicate
Init
.
Predicate
Coher
enc
e
is
not
an
in
v
arian
t
of
the
next-state
action
Next
.
F
or
example,
supp
ose
s
is
a
state
in
whic
h

c
ache
[p
1][a
]
=
1

c
ache
[q
][b
]
=
NoV
al
,
for
all
h
q
;
b
i
dieren
t
from
h
p
1;
a
i

wmem
[a
]
=
2

memQ
con
tains
the
single
elemen
t
h
p
2;
[op
7!
\Rd"
;
adr
7!
a
]
i

62
CHAPTER
5.
A
CA
CHING
MEMOR
Y
for
t
w
o
dieren
t
pro
cessors
p
1
and
p
2
and
some
address
a
.
Suc
h
a
state
s
(an
assignmen
t
of
v
alues
to
v
ariables)
exists,
assuming
that
there
are
at
least
t
w
o
pro
cessors
and
at
least
one
address.
Then
Coher
enc
e
is
true
in
state
s
.
Let
t
b
e
the
state
obtained
from
s
b
y
taking
a
MemQR
d
step.
In
state
t
,
w
e
ha
v
e
c
ache
[p
2][a
]
=
2
and
c
ache
[p
1][a
]
=
1,
so
Coher
enc
e
is
false.
Hence
Coher
enc
e
is
not
an
in
v
arian
t
of
the
next-state
action.
Coher
enc
e
is
an
in
v
arian
t
of
form
ula
Sp
e
c
b
ecause
states
lik
e
s
cannot
o
ccur
in
a
b
eha
vior
satisfying
Sp
e
c
.
Pro
ving
its
in
v
ariance
is
not
so
easy
.
W
e
m
ust
nd
a
predicate
Inv
that
is
an
in
v
arian
t
of
Next
suc
h
that
Inv
implies
Coher
enc
e
and
is
implied
b
y
the
initial
predicate
Init
.
Imp
ortan
t
prop
erties
of
a
sp
ecication
can
often
b
e
expressed
as
in
v
arian
ts.
Pro
ving
that
a
state
predicate
P
is
an
in
v
arian
t
of
a
sp
ecication
means
pro
ving
a
form
ula
of
the
form
Init
^
2[Next
]
v
)
2P
This
is
done
b
y
nding
an
appropriate
state
predicate
Inv
and
pro
ving
Init
)
Inv
;
Inv
^
[Next
]
v
)
Inv
0
;
Inv
)
P
Since
our
sub
ject
is
sp
ecication,
not
pro
of,
I
w
on't
discuss
ho
w
to
nd
Inv
.
5.8
Pro
ving
Implemen
tation
Mo
dule
WriteThr
oughCache
ends
with
the
theorem
theorem
Sp
e
c
)
LM
!
Sp
e
c
where
LM
!
Sp
e
c
is
form
ula
Sp
e
c
of
mo
dule
Memory
.
This
theorem
asserts
that
ev
ery
b
eha
vior
satisfying
sp
ecication
Sp
e
c
of
the
write-through
cac
he
also
sat-
ises
LM
!
Sp
e
c
,
the
sp
ecication
of
a
linearizable
memory
.
In
other
w
ords,
it
asserts
that
the
write-through
cac
he
implemen
ts
a
linearizable
memory
.
In
TLA,
implemen
tation
is
implication.
A
system
describ
ed
b
y
a
form
ula
Sys
implemen
ts
a
sp
ecication
Sp
e
c
i
Sys
implies
Sp
e
c
|that
is,
i
Sys
)
Sp
e
c
is
a
theorem.
TLA
mak
es
no
distinction
b
et
w
een
system
descriptions
and
sp
ecications;
they
are
b
oth
just
form
ulas.
By
denition
of
form
ula
Sp
e
c
of
the
Memory
mo
dule
(page
53),
w
e
can
restate
the
theorem
as
theorem
Sp
e
c
)
9
9
9
9
9
9
mem
;
ctl
;
buf
:
LM
!
Inner
(mem
;
ctl
;
buf
)
!
ISp
e
c
where
LM
!
Inner
(mem
;
ctl
;
buf
)
!
ISp
e
c
is
form
ula
ISp
e
c
of
the
InternalMemory
mo
dule.
The
rules
of
logic
tell
us
that
to
pro
v
e
suc
h
a
theorem,
w
e
m
ust
nd
\witnesses"
for
the
quan
tied
v
ariables
mem
,
ctl
,
and
buf
.
These
witnesses
are

5.8.
PR
O
VING
IMPLEMENT
A
TION
63
state
functions
(ordinary
expressions
with
no
primes),
whic
h
I'll
call
omem
,
o
ctl
,
and
obuf
,
that
satisfy
Sp
e
c
)
LM
!
Inner
(omem
;
o
ctl
;
obuf
)
!
ISp
e
c
(5.2)
F
orm
ula
LM
!
Inner
(omem
;
o
ctl
;
obuf
)
!
ISp
e
c
is
form
ula
ISp
e
c
with
the
substi-
tutions
mem
 
omem
;
ctl
 
o
ctl
;
buf
 
obuf
The
tuple
h
omem
;
o
ctl
;
obuf
i
of
witness
functions
is
called
a
r
enement
mapping,
and
w
e
describ
e
(5.2)
as
the
assertion
that
Sp
e
c
implemen
ts
form
ula
ISp
e
c
under
this
renemen
t
mapping.
In
tuitiv
ely
,
this
means
Sp
e
c
implies
that
the
v
alue
of
the
tuple
h
memInt
;
omem
;
o
ctl
;
obuf
i
of
state
functions
c
hanges
the
w
a
y
ISp
e
c
asserts
that
the
tuple
h
memInt
;
mem
;
ctl
;
buf
i
of
v
ariables
should
c
hange.
I
will
no
w
briey
describ
e
ho
w
w
e
pro
v
e
(5.2);
for
details,
see
the
tec
hnical
pap
ers
ab
out
TLA,
a
v
ailable
through
the
TLA
W
eb
page.
Let
me
rst
in
tro
duce
a
bit
of
non-TLA
+
notation.
F
or
an
y
form
ula
F
of
mo
dule
InternalMemory
,
let
F
equal
LM
!
Inner
(omem
;
o
ctl
;
obuf
)
!
F
,
whic
h
is
form
ula
F
with
omem
,
o
ctl
,
and
obuf
substituted
for
mem
,
ctl
,
and
buf
.
In
particular,
mem
,
ctl
,
and
buf
equal
omem
,
o
ctl
,
and
obuf
,
resp
ectiv
ely
.
With
this
notation,
w
e
can
write
(5.2)
as
Sp
e
c
)
ISp
e
c
.
Replacing
Sp
e
c
and
ISp
e
c
b
y
their
denitions,
this
form
ula
b
ecomes
memInt
equals
memInt
,
since
memInt
is
a
v
ari-
able
distinct
from
mem
,
ctl
,
and
buf
.
Init
^
2[Next
]
h
memInt
;
wmem
;
buf
;
ctl
;
c
ache
;
memQ
i
)
IInit
^
2[INext
]
h
memInt
;
mem
;
ctl
;
buf
i
(5.3)
F
orm
ula
(5.3)
is
then
pro
v
ed
b
y
nding
an
in
v
arian
t
Inv
of
Sp
e
c
suc
h
that
^
Init
)
IInit
^
Inv
^
Next
)
_
INext
_
unchanged
h
memInt
;
mem
;
ctl
;
buf
i
The
second
conjunct
is
called
step
simulation.
It
asserts
that
a
Next
step
start-
ing
in
a
state
satisfying
the
in
v
arian
t
Inv
is
either
an
INext
step|a
step
that
c
hanges
the
4-tuple
h
memInt
;
omem
;
o
ctl
;
obuf
i
the
w
a
y
an
INext
step
c
hanges
h
memInt
;
mem
;
ctl
;
buf
i|or
else
it
lea
v
es
that
4-tuple
unc
hanged.
F
or
our
memory
sp
ecications,
the
state
functions
omem
,
o
ctl
,
and
obuf
are
dened
b
y
omem

=
vmem
o
ctl

=
[p
2
Pr
o
c
7!
if
ctl
[p
]
=
\w
aiting"
then
\busy"
else
ctl
[p
]]
obuf

=
buf
The
mathematics
of
an
implemen
tation
pro
of
is
simple,
so
the
pro
of
is
straigh
tforw
ard|in
theory
.
F
or
sp
ecications
of
real
systems,
suc
h
pro
ofs
can
b
e
quite
dicult.
Going
from
theory
to
practice
requires
turning
the
mathematics

64
CHAPTER
5.
A
CA
CHING
MEMOR
Y
of
pro
ofs
in
to
an
engineering
discipline.
This
is
a
sub
ject
that
deserv
es
a
b
o
ok
to
itself,
and
I
w
on't
try
to
discuss
it
here.
Y
ou
will
probably
nev
er
pro
v
e
that
one
sp
ecication
implemen
ts
another.
Ho
w
ev
er,
y
ou
should
understand
renemen
t
mappings
and
step
sim
ulation.
Y
ou
will
then
b
e
able
to
use
TLC
to
c
hec
k
that
one
sp
ecication
implemen
ts
another;
Chapter
14
explains
ho
w.

Chapter
6
Some
More
Math
The
mathematics
w
e
use
to
write
sp
ecications
is
built
on
a
small,
simple
collec-
tion
of
concepts.
Y
ou'v
e
already
seen
most
of
what's
needed
to
describ
e
almost
an
y
kind
of
mathematics.
All
y
ou
lac
k
is
a
handful
of
op
erators
on
sets
that
are
describ
ed
b
elo
w
in
Section
6.1.
After
learning
ab
out
them,
y
ou
will
b
e
able
to
dene
all
the
data
structures
and
op
erations
that
o
ccur
in
sp
ecications.
While
our
mathematics
is
simple,
its
foundations
are
nonob
vious|for
exam-
ple,
the
meanings
of
recursiv
e
function
denitions
and
the
choose
op
erator
are
subtle.
This
section
discusses
some
of
those
foundations.
Understanding
them
will
help
y
ou
use
TLA
+
more
eectiv
ely
.
6.1
Sets
The
simple
op
erations
on
sets
describ
ed
in
Section
1.2
are
all
y
ou
need
to
write
most
system
sp
ecications.
Ho
w
ev
er,
y
ou
ma
y
o
ccasionally
ha
v
e
to
use
more
sophisticated
op
erators|esp
ecially
if
y
ou
need
to
dene
data
structures
b
ey
ond
tuples,
records,
and
simple
functions.
Tw
o
p
o
w
erful
op
erators
of
set
theory
are
the
unary
op
erators
union
and
subset,
dened
as
follo
ws:
union
S
The
union
of
the
elemen
ts
of
S
.
In
other
w
ords,
a
v
alue
e
is
an
Mathematicians
write
union
S
as
S
S
.
elemen
t
of
union
S
i
it
is
an
elemen
t
of
an
elemen
t
of
S
.
F
or
example:
union
ff1;
2g;
f2;
3g;
f3;
4
gg
=
f1;
2;
3;
4g
subset
S
The
set
of
all
subsets
of
S
.
In
other
w
ords,
T
2
subset
S
i
Mathematicians
call
subset
S
the
p
ower
set
of
S
and
write
it
P
(S
)
or
2
S
.
T

S
.
F
or
example:
subset
f1;
2g
=
ffg;
f1g;
f2g;
f1;
2g
g
65

66
CHAPTER
6.
SOME
MORE
MA
TH
Mathematicians
often
describ
e
a
set
as
\the
set
of
all
.
.
.
suc
h
that
.
.
.
".
TLA
+
has
t
w
o
constructs
that
formalize
suc
h
a
description:
fx
2
S
:
p
g
The
subset
of
S
consisting
of
all
elemen
ts
x
satisfying
prop
ert
y
p
.
F
or
example,
the
set
of
o
dd
natural
n
um
b
ers
can
b
e
written
fn
2
Nat
:
n
%
2
=
1g.
The
iden
tier
x
is
b
ound
in
p
;
it
ma
y
The
mo
dulus
op
erator
%
is
describ
ed
in
Section
2.5
on
page
21.
not
o
ccur
in
S
.
fe
:
x
2
S
g
The
set
of
elemen
ts
of
the
form
e
,
for
all
x
in
the
set
S
.
F
or
example,
f2

n
+
1
:
n
2
Nat
g
is
the
set
of
all
o
dd
natural
n
um-
b
ers.
The
iden
tier
x
is
b
ound
in
e
;
it
ma
y
not
o
ccur
in
S
.
The
construct
fe
:
x
2
S
g
has
the
same
generalizations
as
9
x
2
S
:
F
.
F
or
ex-
ample,
fe
:
x
2
S
;
y
2
T
g
is
the
set
of
all
elemen
ts
of
the
form
e
,
for
x
in
S
and
y
in
T
.
In
the
construct
fx
2
S
:
P
g
,
w
e
can
let
x
b
e
a
tuple.
F
or
example,
fh
y
;
z
i
2
S
:
P
g
is
the
set
of
all
pairs
h
y
;
z
i
in
the
set
S
that
satisfy
P
.
The
grammar
of
TLA
+
in
Chapter
15
sp
ecies
precisely
what
set
expressions
y
ou
can
write.
All
the
set
op
erators
w
e'v
e
seen
so
far
are
built-in
op
erators
of
TLA
+
.
There
is
also
a
standard
mo
dule
FiniteSets
that
denes
t
w
o
op
erators:
Car
dinality
(S
)
The
n
um
b
er
of
elemen
ts
in
set
S
,
if
S
is
a
nite
set.
IsFiniteSet
(S
)
T
rue
i
S
is
a
nite
set.
The
FiniteSets
mo
dule
app
ears
on
341.
The
denition
of
Car
dinality
is
discussed
b
elo
w
on
page
70.
Careless
reasoning
ab
out
sets
can
lead
to
problems.
The
classic
example
of
this
is
Russell's
parado
x:
Let
R
b
e
the
set
of
all
sets
S
suc
h
that
S
=
2
S
.
The
denition
of
R
implies
that
R
2
R
is
true
i
R
=
2
R
is
true.
The
form
ula
R
=
2
R
is
the
negation
of
R
2
R,
and
a
form
ula
and
its
negation
can
neither
b
oth
b
e
true
nor
b
oth
b
e
false.
The
source
of
the
parado
x
is
that
R
isn't
a
set.
There's
no
w
a
y
to
write
it
in
TLA
+
.
In
tuitiv
ely
,
R
is
to
o
big
to
b
e
a
set.
A
collection
C
is
to
o
big
to
b
e
a
set
if
it
is
as
big
as
the
collection
of
all
sets|meaning
that
w
e
can
assign
to
ev
ery
set
a
dieren
t
elemen
t
of
C
.
That
is,
C
is
to
o
big
to
b
e
a
set
if
w
e
can
dene
an
op
erator
SMap
suc
h
that

SMap
(S
)
is
in
C
,
for
an
y
set
S
.

If
S
and
T
are
t
w
o
dieren
t
sets,
then
SMap
(S
)
6=
SMap
(T
).
F
or
example,
the
collection
of
all
sequences
of
length
2
is
to
o
big
to
b
e
a
set;
w
e
can
dene
the
op
erator
SMap
b
y
SMap
(S
)

=
h
1;
S
i
This
op
erator
assigns
to
ev
ery
set
S
a
dieren
t
sequence
of
length
2.

6.2.
SILL
Y
EXPRESSIONS
67
6.2
Silly
Expressions
Most
mo
dern
programming
languages
in
tro
duce
some
form
of
t
yp
e
c
hec
king
to
prev
en
t
y
ou
from
writing
silly
expressions
lik
e
3=\ab
c"
.
TLA
+
is
based
on
the
usual
formalization
of
mathematics
b
y
mathematicians,
whic
h
do
esn't
ha
v
e
t
yp
es.
In
an
un
t
yp
ed
formalism,
ev
ery
syn
tactically
w
ell-formed
expression
has
a
meaning|ev
en
a
silly
expression
lik
e
3=\ab
c"
.
Mathematically
,
the
expression
3=\ab
c"
is
no
sillier
than
the
expression
3=0,
and
mathematicians
implicitly
write
that
silly
expression
all
the
time.
F
or
example,
consider
the
true
form
ula
8
x
2
R
e
al
:
(x
6=
0)
)
(x

(3=x
)
=
3)
where
R
e
al
is
the
set
of
all
real
n
um
b
ers.
This
asserts
that
(x
6=
0)
)
(x

(3=x
)
=
3)
is
true
for
all
real
n
um
b
ers
x
.
Substituting
0
for
x
yields
the
true
form
ula
(0
6=
0)
)
(0

(3=0)
=
3)
that
con
tains
the
silly
expression
3=0.
It's
true
b
ecause
0
6=
0
equals
f
alse,
and
f
alse
)
P
is
true
for
an
y
form
ula
P
.
A
correct
form
ula
can
con
tain
silly
expressions.
F
or
example,
3=0
=
3=0
is
a
correct
form
ula
b
ecause
an
y
v
alue
equals
itself.
Ho
w
ev
er,
the
truth
of
a
correct
form
ula
cannot
dep
end
on
the
meaning
of
a
silly
expression.
If
an
expression
is
silly
,
then
its
meaning
is
probably
unsp
ecied.
The
denitions
of
=
and

(whic
h
are
in
the
standard
mo
dule
R
e
als
)
don't
sp
ecify
the
v
alue
of
0

(3=0),
so
there's
no
w
a
y
of
kno
wing
whether
that
v
alue
equals
3.
No
sensible
syn
tactic
rules
can
prev
en
t
y
ou
from
writing
3=0
without
also
prev
en
ting
y
ou
from
writing
p
erfectly
reasonable
expressions.
The
t
yping
rules
of
programming
languages
in
tro
duce
complexit
y
and
limitations
on
what
y
ou
can
write
that
don't
exist
in
ordinary
mathematics.
In
a
w
ell-designed
programming
language,
the
costs
of
t
yp
es
are
balanced
b
y
b
enets:
t
yp
es
allo
w
a
compiler
to
pro
duce
more
ecien
t
co
de,
and
t
yp
e
c
hec
king
catc
hes
errors.
F
or
programming
languages,
the
b
enets
seem
to
out
w
eigh
the
costs.
F
or
writing
sp
ecications,
I
ha
v
e
found
that
the
costs
out
w
eigh
the
b
enets.
If
y
ou're
used
to
the
constrain
ts
of
programming
languages,
it
ma
y
b
e
a
while
b
efore
y
ou
start
taking
adv
an
tage
of
the
freedom
aorded
b
y
mathematics.
A
t
rst,
y
ou
w
on't
think
of
dening
an
ything
lik
e
the
op
erator
R
dened
on
page
50
of
Section
5.2,
whic
h
couldn't
b
e
written
in
a
t
yp
ed
programming
language.
6.3
Recursion
Revisited
Section
5.5
in
tro
duced
recursiv
e
function
denitions.
Let's
no
w
examine
what
suc
h
denitions
mean
mathematically
.
Mathematicians
usually
dene
the
fac-
torial
function
fact
b
y
writing
fact
[n
]
=
if
n
=
0
then
1
else
n

fact
[n
 1]
;
for
all
n
2
Nat

68
CHAPTER
6.
SOME
MORE
MA
TH
This
denition
can
b
e
justied
b
y
pro
ving
that
it
denes
a
unique
function
fact
with
domain
Nat
.
In
other
w
ords,
fact
is
the
unique
v
alue
satisfying
fact
=
[n
2
Nat
7!
if
n
=
0
then
1
else
n

fact
[n
 1]
]
(6.1)
The
choose
op
erator,
in
tro
duced
on
pages
47{48
of
Section
5.1,
allo
ws
us
to
express
\the
v
alue
x
satisfying
prop
ert
y
p
"
as
choose
x
:
p
.
W
e
can
therefore
dene
fact
as
follo
ws
to
b
e
the
v
alue
satisfying
(6.1):
fact

=
choose
fact
:
fact
=
[n
2
Nat
7!
if
n
=
0
then
1
else
n

fact
[n
 1]
]
(6.2)
(Since
the
sym
b
ol
fact
is
not
y
et
dened
in
the
expression
to
the
righ
t
of
the
\

=
",
w
e
can
use
it
as
the
b
ound
iden
tier
in
the
choose
expression.)
The
TLA
+
denition
fact
[n
2
Nat
]

=
if
n
=
0
then
1
else
n

fact
[n
 1]
is
simply
an
abbreviation
for
(6:2).
In
general,
f
[x
2
S
]

=
e
is
an
abbreviation
for
f

=
choose
f
:
f
=
[x
2
S
7!
e
]
(6.3)
TLA
+
allo
ws
y
ou
to
write
silly
denitions.
F
or
example,
y
ou
can
write
cir
c
[n
2
Nat
]

=
choose
y
:
y
6=
cir
c
[n
]
(6.4)
This
app
ears
to
dene
cir
c
to
b
e
a
function
suc
h
that
cir
c
[n
]
6=
cir
c
[n
]
for
an
y
natural
n
um
b
er
n
.
There
ob
viously
is
no
suc
h
function,
so
cir
c
can't
b
e
dened
to
equal
it.
A
recursiv
e
function
denition
do
esn't
necessarily
dene
a
function.
If
there
is
no
f
that
equals
[x
2
S
7!
e
],
then
(6.3)
denes
f
to
b
e
some
unsp
ecied
v
alue.
Th
us,
the
nonsensical
denition
(6.4)
denes
cir
c
to
b
e
some
unkno
wn
v
alue.
Although
TLA
+
allo
ws
the
apparen
t
circularit
y
of
a
recursiv
e
function
de-
nition,
it
do
es
not
allo
w
circular
denitions
in
whic
h
t
w
o
or
more
functions
are
dened
in
terms
of
one
another.
Mathematicians
o
ccasionally
write
suc
h
m
utu-
ally
recursiv
e
denitions.
F
or
example,
they
migh
t
try
to
dene
functions
f
and
g
,
with
domains
equal
to
the
set
Nat
,
b
y
writing
f
[n
2
Nat
]

=
if
n
=
0
then
17
else
f
[n
 1]

g
[n
]
g
[n
2
Nat
]

=
if
n
=
0
then
42
else
f
[n
 1]
+
g
[n
 1]
This
pair
of
denitions
is
not
allo
w
ed
in
TLA
+
.
TLA
+
do
es
not
allo
w
m
utually
recursiv
e
denitions.
Ho
w
ev
er,
w
e
can
dene
these
functions
f
and
g
in
TLA
+
as
follo
ws.
W
e
rst
dene
a
function
mr
suc
h
that
mr
[n
]
is
a
record
whose
f
and
g
elds
equal
f
[n
]
and
g
[n
],
resp
ectiv
ely:
mr
[n
2
Nat
]

=
[f
7!
if
n
=
0
then
17
else
mr
[n
 1]:f

mr
[n
]:g
;
g
7!
if
n
=
0
then
42
else
mr
[n
 1]:f
+
mr
[n
 1]:g
]

6.4.
FUNCTIONS
VERSUS
OPERA
TORS
69
W
e
can
then
dene
f
and
g
in
terms
of
mr
:
f
[n
2
Nat
]

=
mr
[n
]:f
g
[n
2
Nat
]

=
mr
[n
]:g
This
tric
k
can
b
e
used
to
con
v
ert
an
y
m
utually
recursiv
e
denitions
in
to
a
sin-
gle
recursiv
e
denition
of
a
record-v
alued
function
whose
elds
are
the
desired
functions.
If
w
e
w
an
t
to
reason
ab
out
a
function
f
dened
b
y
f
[x
2
S
]

=
e
,
w
e
need
to
pro
v
e
that
there
exists
an
f
that
equals
[x
2
S
7!
e
].
The
existence
of
f
is
ob
vious
if
f
do
es
not
o
ccur
in
e
.
If
it
do
es,
so
this
is
a
recursiv
e
denition,
then
there
is
something
to
pro
v
e.
Since
I'm
not
discussing
pro
ofs,
I
w
on't
describ
e
ho
w
to
pro
v
e
it.
In
tuitiv
ely
,
y
ou
ha
v
e
to
c
hec
k
that,
as
in
the
case
of
the
factorial
function,
the
denition
uniquely
determines
the
v
alue
of
f
[x
]
for
ev
ery
x
in
S
.
Recursion
is
a
common
programming
tec
hnique
b
ecause
programs
m
ust
com-
pute
v
alues
using
a
small
rep
ertoire
of
simple
elemen
tary
op
erations.
It's
not
used
as
often
in
mathematical
denitions,
where
w
e
needn't
w
orry
ab
out
ho
w
to
compute
the
v
alue
and
can
use
the
p
o
w
erful
op
erators
of
logic
and
set
theory
.
F
or
example,
the
op
erators
He
ad
,
T
ail
,
and

are
dened
in
Section
5.4
with-
out
recursion,
ev
en
though
computer
scien
tists
usually
dene
them
recursiv
ely
.
Still,
there
are
some
things
that
are
b
est
dened
inductiv
ely
,
using
a
recursiv
e
function
denition.
6.4
F
unctions
v
ersus
Op
erators
Consider
these
denitions,
whic
h
w
e'v
e
seen
b
efore:
T
ail
(s
)

=
[i
2
1
:
:
(L
en
(s
)
 1)
7!
s
[i
+
1]]
fact
[n
2
Nat
]

=
if
n
=
0
then
1
else
n

fact
[n
 1]
They
dene
t
w
o
v
ery
dieren
t
kinds
of
ob
jects:
fact
is
a
function,
and
T
ail
is
an
op
erator.
F
unctions
and
op
erators
dier
in
a
few
basic
w
a
ys.
Their
most
ob
vious
dierence
is
that
a
function
lik
e
fact
b
y
itself
is
a
complete
expression
that
denotes
a
v
alue,
but
an
op
erator
lik
e
T
ail
is
not.
Both
fact
[n
]
2
S
and
fact
2
S
are
syn
tactically
correct
expressions.
But,
while
T
ail
(n
)
2
S
is
syn
tactically
correct,
T
ail
2
S
is
not.
It
is
gibb
erish|a
meaningless
string
of
sym
b
ols,
lik
e
x
+
>
0.
Unlik
e
an
op
erator,
a
function
m
ust
ha
v
e
a
domain,
whic
h
is
a
set.
W
e
cannot
dene
a
function
T
ail
so
that
T
ail
[s
]
is
the
tail
of
an
y
nonempt
y
sequence
s
;
the
domain
of
suc
h
a
function
w
ould
ha
v
e
to
include
all
nonempt
y
sequences,
and
the
collection
of
all
suc
h
sequences
is
to
o
big
to
b
e
a
set.
(As
explained
on
page
66,
a
collection
C
is
to
o
big
to
b
e
a
set
if
w
e
can
assign
to
eac
h
set
a
dieren
t
mem
b
er
of
C
.
The
op
erator
SMap
dened
b
y
SMap
(S
)

=
h
S
i
assigns

70
CHAPTER
6.
SOME
MORE
MA
TH
to
ev
ery
set
a
dieren
t
nonempt
y
sequence.)
Hence,
w
e
can't
dene
T
ail
to
b
e
a
function.
Unlik
e
a
function,
an
op
erator
cannot
b
e
dened
recursiv
ely
in
TLA
+
.
Ho
w-
ev
er,
w
e
can
usually
transform
an
illegal
recursiv
e
op
erator
denition
in
to
a
nonrecursiv
e
one
using
a
recursiv
e
function
denition.
F
or
example,
let's
try
to
dene
the
Car
dinality
op
erator
on
nite
sets.
(Recall
that
the
cardinalit
y
of
a
nite
set
S
is
the
n
um
b
er
of
elemen
ts
in
S
.)
The
collection
of
all
nite
sets
is
to
o
big
to
b
e
a
set.
(The
op
erator
SMap
(S
)

=
fS
g
assigns
to
eac
h
set
a
dieren
t
set
of
cardinalit
y
1.)
The
Car
dinality
op
erator
has
a
simple
in
tuitiv
e
denition:

Car
dinality
(fg)
=
0.

If
S
is
a
nonempt
y
nite
set,
then
S
n
fx
g
is
the
set
of
all
elemen
ts
in
S
except
x
.
Car
dinality
(S
)
=
1
+
Car
dinality
(S
n
fx
g)
where
x
is
an
arbitrary
elemen
t
of
S
.
Using
the
choose
op
erator
to
describ
e
an
arbitrary
elemen
t
of
S
,
w
e
can
write
this
as
the
more
formal-lo
oking,
but
still
illegal,
denition
Car
dinality
(S
)

=
This
is
not
a
legal
TLA
+
denition.
if
S
=
fg
then
0
else
1
+
Car
dinality
(S
n
fchoose
x
:
x
2
S
g)
This
denition
is
illegal
b
ecause
it's
circular|only
in
a
recursiv
e
function
de-
nition
can
the
sym
b
ol
b
eing
dened
app
ear
to
the
righ
t
of
the

=
.
T
o
turn
this
in
to
a
legal
denition,
observ
e
that,
for
a
giv
en
nite
set
S
,
w
e
can
dene
a
function
CS
suc
h
that
CS
[T
]
equals
the
cardinalit
y
of
T
for
ev
ery
subset
T
of
S
.
The
denition
is
CS
[T
2
subset
S
]

=
if
T
=
fg
then
0
else
1
+
CS
[T
n
fchoose
x
:
x
2
T
g]
Since
S
is
a
subset
of
itself,
this
denes
CS
[S
]
to
equal
Car
dinality
(S
),
if
S
is
a
nite
set.
(W
e
don't
kno
w
or
care
what
CS
[S
]
equals
if
S
is
not
nite.)
So,
w
e
can
dene
the
Car
dinality
op
erator
b
y
Car
dinality
(S
)

=
let
CS
[T
2
subset
S
]

=
if
T
=
fg
then
0
else
1
+
CS
[T
n
fchoose
x
:
x
2
T
g]
in
CS
[S
]
Op
erators
also
dier
from
functions
in
that
an
op
erator
can
tak
e
an
op
erator
as
an
argumen
t.
F
or
example,
w
e
can
dene
an
op
erator
IsPartialOr
der
so
that

6.4.
FUNCTIONS
VERSUS
OPERA
TORS
71
IsPartialOr
der
(R
;
S
)
equals
true
i
the
op
erator
R
denes
an
irreexiv
e
partial
order
on
S
.
The
denition
is
If
y
ou
don't
kno
w
what
an
irreex-
iv
e
partial
order
is,
read
this
denition
of
IsPartialOr
der
to
nd
out.
IsPartialOr
der
(R
(
;
);
S
)

=
^
8
x
;
y
;
z
2
S
:
R
(x
;
y
)
^
R
(y
;
z
)
)
R
(x
;
z
)
^
8
x
2
S
:
:R
(x
;
x
)
W
e
could
also
use
an
inx-op
erator
sym
b
ol
lik
e

instead
of
R
as
the
parameter
of
the
denition,
writing
IsPartialOr
der
(

;
S
)

=
^
8
x
;
y
;
z
2
S
:
(x

y
)
^
(y

z
)
)
(x

z
)
^
8
x
2
S
:
:(x

x
)
The
rst
argumen
t
of
IsPartialOr
der
is
an
op
erator
that
tak
es
t
w
o
argumen
ts;
its
second
argumen
t
is
an
expression.
Since
>
is
an
op
erator
that
tak
es
t
w
o
argumen
ts,
the
expression
IsPartialOr
der
(>;
Nat
)
is
syn
tactically
correct.
In
fact,
it
equals
tr
ue,
if
>
is
dened
to
b
e
the
usual
op
erator
on
n
um
b
ers.
The
expression
IsPartialOr
der
(+;
3)
is
also
syn
tactically
correct,
but
it's
silly
and
w
e
ha
v
e
no
idea
whether
or
not
it
equals
tr
ue.
There
is
one
dierence
b
et
w
een
functions
and
op
erators
that
is
subtle
and
not
v
ery
imp
ortan
t,
but
I
will
men
tion
it
an
yw
a
y
for
completeness.
The
denition
of
T
ail
denes
T
ail
(s
)
for
all
v
alues
of
s
.
F
or
example,
it
denes
T
ail
(1=2)
to
equal
[i
2
1
:
:
(L
en
(1=2)
 1)
7!
(1=2)[i
+
1]]
(6.5)
W
e
ha
v
e
no
idea
what
this
expression
means,
b
ecause
w
e
don't
kno
w
what
L
en
(1=2)
or
(1=2)[i
+
1]
mean.
But,
whatev
er
(6.5)
means,
it
equals
T
ail
(1=2).
The
denition
of
fact
denes
fact
[n
]
only
for
n
2
Nat
.
It
tells
us
nothing
ab
out
the
v
alue
of
fact
[1=2].
The
expression
fact
[1=2]
is
syn
tactically
w
ell-formed,
so
it
to
o
denotes
some
v
alue.
Ho
w
ev
er,
the
denition
of
fact
tells
us
nothing
ab
out
what
that
v
alue
is.
The
last
dierence
b
et
w
een
op
erators
and
functions
has
nothing
to
do
with
mathematics
and
is
an
idiosyncrasy
of
TLA
+
:
the
language
do
esn't
p
ermit
us
to
dene
inx
functions.
Mathematicians
often
dene
=
to
b
e
a
function
of
t
w
o
argumen
ts,
but
w
e
can't
do
that
in
TLA
+
.
If
w
e
w
an
t
to
dene
=,
w
e
ha
v
e
no
c
hoice
but
to
mak
e
it
an
op
erator.
One
can
write
equally
nonsensical
things
using
functions
or
op
erators.
Ho
w-
ev
er,
whether
y
ou
use
functions
or
op
erators
ma
y
determine
whether
the
non-
sense
y
ou
write
is
nonsyn
tactic
gibb
erish
or
syn
tactically
correct
but
seman
ti-
cally
silly
.
The
string
of
sym
b
ols
2(\a"
)
is
not
a
syn
tactically
correct
form
ula
b
ecause
2
is
not
an
op
erator.
Ho
w
ev
er,
2[\a"
],
whic
h
can
also
b
e
written
2:a
,
is
a
syn
tactically
correct
expression.
It's
nonsensical
b
ecause
2
isn't
a
function,
1
so
1
More
precisely
,
w
e
don't
kno
w
whether
or
not
2
is
a
function.

72
CHAPTER
6.
SOME
MORE
MA
TH
w
e
don't
kno
w
what
2[\a"
]
means.
Similarly
,
T
ail
(s
;
t
)
is
syn
tactically
incorrect
b
ecause
T
ail
is
an
op
erator
that
tak
es
a
single
argumen
t.
Ho
w
ev
er,
as
explained
in
Section
16.1.7
on
page
301,
fact
[m
;
n
]
is
syn
tactic
sugar
for
fact
[h
m
;
n
i],
so
it
is
a
syn
tactically
correct,
seman
tically
silly
form
ula.
Whether
an
error
is
syn
tactic
or
seman
tic
determines
what
kind
of
to
ol
can
catc
h
it.
In
particular,
the
parser
describ
ed
in
Chapter
12
catc
hes
syn
tactic
errors,
but
not
seman
tic
silliness.
The
TLC
mo
del
c
hec
k
er,
describ
ed
in
Chapter
14,
will
rep
ort
an
error
if
it
tries
to
ev
aluate
a
seman
tically
silly
expression.
The
distinction
b
et
w
een
functions
and
op
erators
seems
to
confuse
some
p
eo-
ple.
One
reason
is
that,
although
this
distinction
exists
in
ordinary
math,
it
usually
go
es
unnoticed
b
y
mathematicians.
If
y
ou
ask
a
mathematician
whether
subset
is
a
function,
she's
lik
ely
to
sa
y
y
es.
But
if
y
ou
p
oin
t
out
to
her
that
subset
can't
b
e
a
function
b
ecause
its
domain
can't
b
e
a
set,
she
will
probably
realize
for
the
rst
time
that
mathematicians
use
op
erators
lik
e
subset
and
2
without
noticing
that
they
form
a
class
of
ob
jects
dieren
t
from
functions.
Lo-
gicians
will
observ
e
that
the
distinction
b
et
w
een
op
erators
and
v
alues,
including
functions,
arises
b
ecause
TLA
+
is
a
rst-order
logic
rather
than
a
higher-order
logic.
When
dening
an
ob
ject
V
,
y
ou
ma
y
ha
v
e
to
decide
whether
to
mak
e
V
an
op
erator
that
tak
es
an
argumen
t
or
a
function.
The
dierences
b
et
w
een
op
erators
and
functions
will
often
determine
the
decision.
F
or
example,
if
a
v
ariable
ma
y
ha
v
e
V
as
its
v
alue,
then
V
m
ust
b
e
a
function.
Th
us,
in
the
memory
sp
ecication
of
Section
5.3,
w
e
had
to
represen
t
the
state
of
the
memory
b
y
a
function
rather
than
an
op
erator,
since
the
v
ariable
mem
couldn't
equal
an
op
erator.
If
these
dierences
don't
determine
whether
to
use
an
op
erator
or
a
function,
then
the
c
hoice
is
a
matter
of
taste.
I
usually
prefer
op
erators.
6.5
Using
F
unctions
Consider
the
follo
wing
t
w
o
form
ulas:
f
0
=
[i
2
Nat
7!
i
+
1]
(6.6)
8
i
2
Nat
:
f
0
[i
]
=
i
+
1
(6.7)
Both
form
ulas
imply
that
f
0
[i
]
=
i
+
1
for
ev
ery
natural
n
um
b
er
i
,
but
they
are
not
equiv
alen
t.
F
orm
ula
(6.6)
uniquely
determines
f
0
,
asserting
that
it's
a
function
with
domain
Nat
.
F
orm
ula
(6.7)
is
satised
b
y
lots
of
dieren
t
v
alues
of
f
0
.
F
or
example,
it
is
satised
if
f
0
is
the
function
[i
2
R
e
al
7!
if
i
2
Nat
then
i
+
1
else
i
2
]
In
fact,
from
(6.7),
w
e
can't
ev
en
deduce
that
f
0
is
a
function.
F
orm
ula
(6.6)
implies
form
ula
(6.7),
but
not
vice-v
ersa.

6.6.
CHOOSE
73
When
writing
sp
ecications,
w
e
almost
alw
a
ys
w
an
t
to
sp
ecify
the
new
v
alue
of
a
v
ariable
f
rather
than
the
new
v
alues
of
f
[i
]
for
all
i
in
some
set.
W
e
therefore
usually
write
(6.6)
rather
than
(6.7).
6.6
Cho
ose
The
choose
op
erator
w
as
in
tro
duced
in
the
memory
in
terface
of
Section
5.1
in
The
choose
op-
erator
is
kno
wn
to
logicians
as
Hilb
ert's
".
the
simple
idiom
choose
v
:
v
=
2
S
,
whic
h
is
an
expression
whose
v
alue
is
not
an
elemen
t
of
S
.
In
Section
6.3
ab
o
v
e,
w
e
sa
w
that
it
is
a
p
o
w
erful
to
ol
that
can
b
e
used
in
rather
subtle
w
a
ys.
The
most
common
use
for
the
choose
op
erator
is
to
\name"
a
uniquely
sp
ecied
v
alue.
F
or
example,
a
=b
is
the
unique
real
n
um
b
er
that
satises
the
form
ula
a
=
b

(a
=b
),
if
a
and
b
are
real
n
um
b
ers
and
b
6=
0.
So,
the
standard
mo
dule
R
e
als
denes
division
on
the
set
R
e
al
of
real
n
um
b
ers
b
y
a
=b

=
choose
c
2
R
e
al
:
a
=
b

c
(The
expression
choose
x
2
S
:
p
means
choose
x
:
(x
2
S
)
^
p
.)
If
a
is
a
nonzero
real
n
um
b
er,
then
there
is
no
real
n
um
b
er
c
suc
h
that
a
=
0

c
.
Therefore,
a
=0
has
an
unsp
ecied
v
alue.
W
e
don't
kno
w
what
a
real
n
um
b
er
times
a
string
equals,
so
w
e
cannot
sa
y
whether
or
not
there
is
a
real
n
um
b
er
c
suc
h
that
a
equals
\xyz"

c
.
Hence,
w
e
don't
kno
w
what
the
v
alue
of
a
=\xyz"
is.
P
eople
who
do
a
lot
of
programming
and
not
m
uc
h
mathematics
often
think
that
choose
m
ust
b
e
a
nondeterministic
op
erator.
In
mathematics,
there
is
no
suc
h
thing
as
a
nondeterministic
op
erator
or
a
nondeterministic
function.
If
some
expression
equals
42
to
da
y
,
then
it
will
equal
42
tomorro
w,
and
it
will
still
equal
42
a
million
y
ears
from
tomorro
w.
The
sp
ecication
(x
=
choose
n
:
n
2
Nat
)
^
2[x
0
=
choose
n
:
n
2
Nat
]
x
allo
ws
only
a
single
b
eha
vior|one
in
whic
h
x
alw
a
ys
equals
choose
n
:
n
2
Nat
,
whic
h
is
some
particular,
unsp
ecied
natural
n
um
b
er.
It
is
v
ery
dieren
t
from
the
sp
ecication
(x
2
Nat
)
^
2[x
0
2
Nat
]
x
that
allo
ws
all
b
eha
viors
in
whic
h
x
is
alw
a
ys
a
natural
n
um
b
er|p
ossibly
a
dieren
t
n
um
b
er
in
eac
h
state.
This
sp
ecication
is
highly
nondeterministic,
allo
wing
lots
of
dieren
t
b
eha
viors.

74
CHAPTER
6.
SOME
MORE
MA
TH

Chapter
7
W
riting
a
Sp
ecication:
Some
Advice
Y
ou
ha
v
e
no
w
learned
all
y
ou
need
to
kno
w
ab
out
TLA
+
to
write
y
our
o
wn
sp
ecications.
Here
are
a
few
additional
hin
ts
to
help
y
ou
get
started.
7.1
Wh
y
Sp
ecify
W
riting
a
sp
ecication
requires
eort;
the
b
enet
it
pro
vides
m
ust
justify
that
eort.
The
purp
ose
of
writing
a
sp
ecication
is
to
help
a
v
oid
errors.
Here
are
some
w
a
ys
it
can
do
that.

W
riting
a
TLA
+
sp
ecication
can
help
the
design
pro
cess.
Ha
ving
to
de-
scrib
e
a
design
precisely
often
rev
eals
problems|subtle
in
teractions
and
\corner
cases"
that
are
easily
o
v
erlo
ok
ed.
These
problems
are
easier
to
cor-
rect
when
disco
v
ered
in
the
design
phase
rather
than
after
implemen
tation
has
b
egun.

A
TLA
+
sp
ecication
can
pro
vide
a
clear,
concise
w
a
y
of
comm
unicating
a
design.
It
helps
ensure
that
the
designers
agree
on
what
they
ha
v
e
designed,
and
it
pro
vides
a
v
aluable
guide
to
the
engineers
who
implemen
t
and
test
the
system.
It
ma
y
also
help
users
understand
the
system.

A
TLA
+
sp
ecication
is
a
formal
description
to
whic
h
to
ols
can
b
e
applied
to
help
nd
errors
in
the
design
and
to
help
in
testing
the
system.
The
most
useful
to
ol
written
so
far
for
this
purp
ose
is
the
TLC
mo
del
c
hec
k
er,
describ
ed
in
Chapter
14.
75

76
CHAPTER
7.
WRITING
A
SPECIFICA
TION:
SOME
AD
VICE
Whether
the
b
enet
justies
the
eort
of
writing
the
sp
ecication
dep
ends
on
the
nature
of
the
pro
ject.
Sp
ecication
is
not
an
end
in
itself;
it
is
just
a
to
ol
that
an
engineer
should
b
e
able
to
use
when
appropriate.
7.2
What
to
Sp
ecify
Although
w
e
talk
ab
out
sp
ecifying
a
system,
that's
not
what
w
e
do.
A
sp
eci-
cation
is
a
mathematical
mo
del
of
a
particular
view
of
some
part
of
a
system.
When
writing
a
sp
ecication,
the
rst
thing
y
ou
m
ust
c
ho
ose
is
exactly
what
part
of
the
system
y
ou
w
an
t
to
mo
del.
Sometimes
the
c
hoice
is
ob
vious;
often
it
isn't.
The
cac
he-coherence
proto
col
of
a
real
m
ultipro
cessor
computer
ma
y
b
e
in
timately
connected
with
ho
w
the
pro
cessors
execute
instructions.
Finding
an
abstraction
that
describ
es
the
coherence
proto
col
while
suppressing
the
details
of
instruction
execution
ma
y
b
e
dicult.
It
ma
y
require
dening
an
in
terface
b
et
w
een
the
pro
cessor
and
the
memory
that
do
esn't
exist
in
the
actual
system
design.
The
primary
purp
ose
of
a
sp
ecication
is
to
help
a
v
oid
errors.
Y
ou
should
sp
ecify
those
parts
of
the
system
for
whic
h
a
sp
ecication
is
most
lik
ely
to
rev
eal
errors.
TLA
+
is
particularly
eectiv
e
at
rev
ealing
concurrency
errors|ones
that
arise
through
the
in
teraction
of
async
hronous
comp
onen
ts.
So,
when
writing
a
TLA
+
sp
ecication,
y
ou
will
probably
concen
trate
y
our
eorts
on
the
parts
of
the
system
that
are
most
lik
ely
to
ha
v
e
suc
h
errors.
If
that's
not
where
y
ou
should
b
e
concen
trating
y
our
eorts,
then
y
ou
probably
shouldn't
b
e
using
TLA
+
.
7.3
The
Grain
of
A
tomicit
y
After
c
ho
osing
what
part
of
the
system
to
sp
ecify
,
y
ou
m
ust
c
ho
ose
the
sp
ecica-
tion's
lev
el
of
abstraction.
The
most
imp
ortan
t
asp
ect
of
the
lev
el
of
abstraction
is
the
grain
of
atomicit
y
,
the
c
hoice
of
what
system
c
hanges
are
represen
ted
as
a
single
step
of
a
b
eha
vior.
Sending
a
message
in
an
actual
system
in
v
olv
es
m
ultiple
sub
op
erations,
but
w
e
usually
represen
t
it
as
a
single
step.
On
the
other
hand,
the
sending
of
a
message
and
its
receipt
are
usually
represen
ted
as
separate
steps
when
sp
ecifying
a
distributed
system.
The
same
sequence
of
system
op
erations
is
represen
ted
b
y
a
shorter
sequence
of
steps
in
a
coarser-grained
represen
tation
than
in
a
ner-grained
one.
This
almost
alw
a
ys
mak
es
the
coarser-grained
sp
ecication
simpler
than
the
ner-
grained
one.
Ho
w
ev
er,
the
ner-grained
sp
ecication
more
accurately
describ
es
the
b
eha
vior
of
the
actual
system.
A
coarser-grained
sp
ecication
ma
y
fail
to
rev
eal
imp
ortan
t
details
of
the
system.
There
is
no
simple
rule
for
deciding
on
the
grain
of
atomicit
y
.
Ho
w
ev
er,
there
is
one
w
a
y
of
thinking
ab
out
gran
ularit
y
that
can
help.
T
o
describ
e
it,
w
e

7.3.
THE
GRAIN
OF
A
TOMICITY
77
need
the
TLA
+
action-comp
osition
op
erator
\".
If
A
and
B
are
actions,
then
the
action
AB
is
executed
b
y
executing
rst
A
then
B
as
a
single
step.
More
precisely
,
A

B
is
the
action
dened
b
y
letting
s
!
t
b
e
an
A

B
step
i
there
exists
a
state
u
suc
h
that
s
!
u
is
an
A
step
and
u
!
t
is
a
B
step.
When
determining
the
grain
of
atomicit
y
,
w
e
m
ust
decide
whether
to
repre-
sen
t
the
execution
of
an
op
eration
as
a
single
step
or
as
a
sequence
of
steps,
eac
h
corresp
onding
to
the
execution
of
a
sub
op
eration.
Let's
consider
the
simple
case
of
an
op
eration
consisting
of
t
w
o
sub
op
erations
that
are
executed
sequen
tially
,
where
those
sub
op
erations
are
describ
ed
b
y
the
t
w
o
actions
R
and
L.
(Execut-
ing
R
enables
L
and
disables
R
.)
When
the
op
eration's
execution
is
represen
ted
b
y
t
w
o
steps,
eac
h
of
those
steps
is
an
R
step
or
an
L
step.
The
op
eration
is
then
describ
ed
with
the
action
R
_
L.
When
its
execution
is
represen
ted
b
y
a
single
step,
the
op
eration
is
describ
ed
with
the
action
R
L.
1
Let
S
2
b
e
the
ner-grained
sp
ecication
in
whic
h
the
op
eration
is
executed
in
t
w
o
steps,
and
let
S
1
b
e
the
coarser-grained
sp
ecication
in
whic
h
it
is
executed
as
a
single
R

L
step.
T
o
c
ho
ose
the
grain
of
atomicit
y
,
w
e
m
ust
c
ho
ose
whether
to
tak
e
S
1
or
S
2
as
the
sp
ecication.
Let's
examine
the
relation
b
et
w
een
the
t
w
o
sp
ecications.
W
e
can
transform
an
y
b
eha
vior

satisfying
S
1
in
to
a
b
eha
vior
b

satisfying
S
2
b
y
replacing
eac
h
step
s
R
L
!
t
with
the
pair
of
steps
s
R
!
u
L
!
t
,
for
some
state
u
.
If
w
e
regard

as
b
eing
equiv
alen
t
to
b

,
then
w
e
can
regard
S
1
as
b
eing
a
strengthened
v
ersion
of
S
2|one
that
allo
ws
few
er
b
eha
viors.
Sp
ecication
S
1
requires
that
eac
h
R
step
b
e
follo
w
ed
immediately
b
y
an
L
step,
while
S
2
allo
ws
b
eha
viors
in
whic
h
other
steps
come
b
et
w
een
the
R
and
L
steps.
T
o
c
ho
ose
the
appropriate
grain
of
atomicit
y
,
w
e
m
ust
decide
whether
those
additional
b
eha
viors
allo
w
ed
b
y
S
2
are
imp
ortan
t.
The
additional
b
eha
viors
allo
w
ed
b
y
S
2
are
not
imp
ortan
t
if
the
actual
sys-
tem
executions
they
describ
e
are
also
describ
ed
b
y
b
eha
viors
allo
w
ed
b
y
S
1.
So,
w
e
can
ask
whether
eac
h
b
eha
vior

satisfying
S
2
has
a
corresp
onding
b
eha
vior
e

satisfying
S
1
that
is,
in
some
sense,
equiv
alen
t
to

.
One
w
a
y
to
construct
e

from

is
to
transform
a
sequence
of
steps
s
R
!
u
1
A
1
!
u
2
A
2
!
u
3
:
:
:
u
n
A
n
!
u
n
+1
L
!
t
(7.1)
in
to
the
sequence
s
A
1
!
v
1
:
:
:
v
k
 2
A
k
!
v
k
 1
R
!
v
k
L
!
v
k
+1
A
k
+1
!
v
k
+2
:
:
:
v
n
+1
A
n
!
t
(7.2)
where
the
A
i
are
other
system
actions
that
can
b
e
executed
b
et
w
een
the
R
and
L
steps.
Both
sequences
start
in
state
s
and
end
in
state
t
,
but
the
in
termediate
states
ma
y
b
e
dieren
t.
1
W
e
actually
describ
e
the
op
eration
with
an
ordinary
action,
lik
e
the
ones
w
e'v
e
b
een
writing,
that
is
equiv
alen
t
to
R
L.
The
op
erator
\"
rarely
app
ears
in
an
actual
sp
ecication.
If
y
ou're
ev
er
tempted
to
use
it,
lo
ok
for
a
b
etter
w
a
y
to
write
the
sp
ecication;
y
ou
can
probably
nd
one.

78
CHAPTER
7.
WRITING
A
SPECIFICA
TION:
SOME
AD
VICE
When
is
suc
h
a
transformation
p
ossible?
An
answ
er
can
b
e
giv
en
in
terms
of
comm
utativit
y
relations.
W
e
sa
y
that
actions
A
and
B
comm
ute
if
p
erforming
them
in
either
order
pro
duces
the
same
result.
F
ormally
,
A
and
B
comm
ute
i
A

B
is
equiv
alen
t
to
B

A.
A
simple
sucien
t
condition
for
comm
utativit
y
is
that
t
w
o
actions
comm
ute
if
(i)
eac
h
one
lea
v
es
unc
hanged
an
y
v
ariable
whose
v
alue
ma
y
b
e
c
hanged
b
y
the
other,
and
(ii)
neither
enables
or
disables
the
other.
It's
not
hard
to
see
that
w
e
can
transform
(7.1)
to
(7.2)
in
the
follo
wing
t
w
o
cases:

R
comm
utes
with
eac
h
A
i
.
(In
this
case,
k
=
n
.)

L
comm
utes
with
eac
h
A
i
.
(In
this
case,
k
=
0.)
In
general,
if
an
op
eration
consists
of
a
sequence
of
m
subactions,
w
e
m
ust
decide
whether
to
c
ho
ose
the
ner-grained
represen
tation
O
1
_
O
2
_
:
:
:
_
O
m
or
the
coarser-grained
one
O
1

O
2



O
m
.
The
generalization
of
the
transformation
from
(7.1)
to
(7.2)
is
one
that
transforms
an
arbitrary
b
eha
vior
satisfying
the
ner-grained
sp
ecication
in
to
one
in
whic
h
the
sequence
of
O
1
,
O
2
,
.
.
.
,
O
m
steps
come
one
righ
t
after
the
other.
Suc
h
a
transformation
is
p
ossible
if
all
but
one
of
the
actions
O
i
comm
ute
with
ev
ery
other
system
action.
Comm
utativit
y
can
b
e
replaced
b
y
w
eak
er
conditions,
but
it
is
the
most
common
case.
By
comm
uting
actions
and
replacing
a
sequence
s
O
1
!



O
m
!
t
of
steps
b
y
a
single
O
1



O
m
step,
y
ou
ma
y
b
e
able
to
transform
an
y
b
eha
vior
of
a
ner-
grained
sp
ecication
in
to
a
corresp
onding
b
eha
vior
of
a
coarser-grained
one.
But
that
do
esn't
mean
that
the
coarser-grained
sp
ecication
is
just
as
go
o
d
as
the
ner-grained
one.
The
sequences
(7.1)
and
(7.2)
are
not
the
same,
and
a
sequence
of
O
i
steps
is
not
the
same
as
a
single
O
1



O
m
step.
Whether
y
ou
can
consider
the
transformed
b
eha
vior
to
b
e
equiv
alen
t
to
the
original
one,
and
use
the
coarser-grained
sp
ecication,
dep
ends
on
the
particular
system
y
ou
are
sp
ecifying
and
on
the
purp
ose
of
the
sp
ecication.
Understanding
the
relation
b
et
w
een
ner-
and
coarser-grained
sp
ecications
can
help
y
ou
c
ho
ose
b
et
w
een
them;
it
w
on't
mak
e
the
c
hoice
for
y
ou.
7.4
The
Data
Structures
Another
asp
ect
of
a
sp
ecication's
lev
el
of
abstraction
is
the
accuracy
with
whic
h
it
describ
es
the
system's
data
structures.
F
or
example,
should
the
sp
ecication
of
a
program
in
terface
describ
e
the
actual
la
y
out
of
a
pro
cedure's
argumen
ts
in
memory
,
or
should
the
argumen
ts
b
e
represen
ted
more
abstractly?
T
o
answ
er
suc
h
a
question,
y
ou
m
ust
remem
b
er
that
the
purp
ose
of
the
sp
ec-
ication
is
to
help
catc
h
errors.
A
precise
description
of
the
la
y
out
of
pro
cedure
argumen
ts
will
help
prev
en
t
errors
caused
b
y
misunderstandings
ab
out
that
la
y-
out,
but
at
the
cost
of
complicating
the
program
in
terface's
sp
ecication.
The

7.5.
WRITING
THE
SPECIFICA
TION
79
cost
is
justied
only
if
suc
h
errors
are
lik
ely
to
b
e
a
real
problem
and
the
TLA
+
sp
ecication
pro
vides
the
b
est
w
a
y
to
a
v
oid
them.
If
the
purp
ose
of
the
sp
ecication
is
to
catc
h
errors
caused
b
y
the
asyn-
c
hronous
in
teraction
of
concurren
tly
executing
comp
onen
ts,
then
detailed
de-
scriptions
of
data
structures
will
b
e
a
needless
complication.
So,
y
ou
will
proba-
bly
w
an
t
to
use
high-lev
el,
abstract
descriptions
of
the
system's
data
structures
in
the
sp
ecication.
F
or
example,
to
sp
ecify
a
program
in
terface,
y
ou
migh
t
in
tro
duce
constan
t
parameters
to
represen
t
the
actions
of
calling
and
return-
ing
from
a
pro
cedure|parameters
analogous
to
Send
and
R
eply
of
the
memory
in
terface
describ
ed
in
Section
5.1
(page
45).
7.5
W
riting
the
Sp
ecication
Once
y
ou'v
e
c
hosen
the
part
of
the
system
to
sp
ecify
and
the
lev
el
of
abstraction,
y
ou're
ready
to
start
writing
the
TLA
+
sp
ecication.
W
e'v
e
already
seen
ho
w
this
is
done;
let's
review
the
steps.
First,
pic
k
the
v
ariables
and
dene
the
t
yp
e
in
v
arian
t
and
initial
predicate.
In
the
course
of
doing
this,
y
ou
will
determine
the
constan
t
parameters
and
assumptions
ab
out
them
that
y
ou
need.
Y
ou
ma
y
also
ha
v
e
to
dene
some
additional
constan
ts.
Next,
write
the
next-state
action,
whic
h
forms
the
bulk
of
the
sp
ecication.
Sk
etc
hing
a
few
sample
b
eha
viors
ma
y
help
y
ou
get
started.
Y
ou
m
ust
rst
decide
ho
w
to
decomp
ose
the
next-state
action
as
the
disjunction
of
actions
describing
the
dieren
t
kinds
of
system
op
erations.
Y
ou
then
dene
those
actions.
The
goal
is
to
mak
e
the
action
denitions
as
compact
and
easy
to
read
as
p
ossible,
whic
h
requires
carefully
structuring
them.
One
w
a
y
to
reduce
the
size
of
a
sp
ecication
is
to
dene
state
predicates
and
state
functions
that
are
used
in
sev
eral
dieren
t
action
denitions.
When
writing
the
action
denitions,
y
ou
will
determine
whic
h
of
the
standard
mo
dules
y
ou
need
and
will
add
the
appropriate
extends
statemen
t.
Y
ou
ma
y
also
ha
v
e
to
dene
some
constan
t
op
erators
for
the
data
structures
that
y
ou
are
using.
Y
ou
m
ust
no
w
write
the
temp
oral
part
of
the
sp
ecication.
If
y
ou
w
an
t
to
sp
ecify
liv
eness
prop
erties,
y
ou
ha
v
e
to
c
ho
ose
the
fairness
conditions,
as
describ
ed
b
elo
w
in
Chapter
8.
Y
ou
then
com
bine
the
initial
predicate,
next-
state
action,
and
an
y
fairness
conditions
y
ou'v
e
c
hosen
in
to
the
denition
of
a
single
temp
oral
form
ula
that
is
the
sp
ecication.
Finally
,
y
ou
can
assert
theorems
ab
out
the
sp
ecication.
If
nothing
else,
y
ou
probably
w
an
t
to
add
a
t
yp
e-correctness
theorem.

80
CHAPTER
7.
WRITING
A
SPECIFICA
TION:
SOME
AD
VICE
7.6
Some
F
urther
Hin
ts
Here
are
a
few
miscellaneous
suggestions
that
ma
y
help
y
ou
write
b
etter
sp
eci-
cations.
Don't
b
e
to
o
clev
er.
Clev
erness
can
mak
e
a
sp
ecication
hard
to
read|and
ev
en
wrong.
The
form
ula
q
=
h
h
0
i

q
0
ma
y
lo
ok
lik
e
a
nice,
short
w
a
y
of
writing
(h
0
=
He
ad
(q
))
^
(q
0
=
T
ail
(q
))
(7.3)
But
not
only
is
q
=
h
h
0
i

q
0
harder
to
understand
than
(7.3),
it's
also
wrong.
W
e
don't
kno
w
what
a

b
equals
if
a
and
b
are
not
b
oth
sequences,
so
w
e
don't
kno
w
whether
h
0
=
He
ad
(q
)
and
q
0
=
T
ail
(q
)
are
the
only
v
alues
of
h
0
and
q
0
that
satisfy
q
=
h
h
0
i

q
0
.
There
could
b
e
other
v
alues
of
h
0
and
q
0
,
whic
h
are
not
sequences,
that
satisfy
the
form
ula.
In
general,
the
b
est
w
a
y
to
sp
ecify
the
new
v
alue
of
a
v
ariable
v
is
with
a
conjunct
of
the
form
v
0
=
exp
or
v
0
2
exp
,
where
exp
is
a
state
function|an
expression
with
no
primes.
A
t
yp
e
in
v
arian
t
is
not
an
assumption.
T
yp
e
in
v
ariance
is
a
prop
ert
y
of
a
sp
ecication,
not
an
assumption.
When
writing
a
sp
ecication,
w
e
usually
dene
a
t
yp
e
in
v
arian
t.
But
that's
just
a
denition;
a
denition
is
not
an
assumption.
Supp
ose
y
ou
dene
a
t
yp
e
in
v
arian
t
that
asserts
that
a
v
ariable
n
is
of
t
yp
e
Nat
.
Y
ou
ma
y
b
e
tempted
then
to
think
that
a
conjunct
n
0
>
7
in
an
action
asserts
that
n
0
is
a
natural
n
um
b
er
greater
than
7.
It
do
esn't.
The
form
ula
n
0
>
7
asserts
only
that
n
0
>
7.
It
is
satised
if
n
0
=
p
96
as
w
ell
as
if
n
0
=
8.
Since
w
e
don't
kno
w
whether
or
not
\ab
c"
>
7
is
true,
it
migh
t
b
e
satised
ev
en
if
n
0
=
\ab
c"
.
The
meaning
of
the
form
ula
is
not
c
hanged
just
b
ecause
y
ou'v
e
dened
a
t
yp
e
in
v
arian
t
that
asserts
n
2
Nat
.
In
general,
y
ou
ma
y
w
an
t
to
describ
e
the
new
v
alue
of
a
v
ariable
x
b
y
assert-
ing
some
prop
ert
y
of
x
0
.
Ho
w
ev
er,
the
next-state
action
should
imply
that
x
0
is
an
elemen
t
of
some
suitable
set.
F
or
example,
a
sp
ecication
migh
t
dene
2
A
ction
1

=
(n
0
>
7)
^
:
:
:
A
ction
2

=
(n
0

6)
^
:
:
:
Next

=
(n
0
2
Nat
)
^
(A
ction
1
_
A
ction
2)
2
An
alternativ
e
approac
h
is
to
dene
Next
to
equal
A
ction
1
_
A
ction
2
and
to
let
the
sp
ecication
b
e
Init
^
2[Next
]
:::
^
2(n
2
Nat
).
But
it's
usually
b
etter
to
stic
k
to
the
simple
form
Init
^
2[Next
]
:::
for
sp
ecications.

7.6.
SOME
FUR
THER
HINTS
81
Don't
b
e
to
o
abstract.
Supp
ose
a
user
in
teracts
with
the
system
b
y
t
yping
on
a
k
eyb
oard.
W
e
could
describ
e
the
in
teraction
abstractly
with
a
v
ariable
typ
and
an
op
erator
parameter
KeyStr
oke
,
where
the
action
KeyStr
oke
(\a"
;
typ
;
typ
0
)
represen
ts
the
user
t
yping
an
\a"
.
This
is
the
approac
h
w
e
to
ok
in
describing
the
comm
unication
b
et
w
een
the
pro
cessors
and
the
memory
in
the
MemoryInterfac
e
mo
dule
on
page
48.
A
more
concrete
description
w
ould
b
e
to
let
kb
d
represen
t
the
state
of
the
k
eyb
oard,
p
erhaps
letting
kb
d
=
fg
mean
that
no
k
ey
is
depressed,
and
kb
d
=
f\a"
g
mean
that
the
a
k
ey
is
depressed.
The
t
yping
of
an
a
is
represen
ted
b
y
t
w
o
steps,
a
[kb
d
=
fg]
!
[kb
d
=
f\a"
g]
step
represen
ts
the
pressing
of
the
a
k
ey
,
and
a
[kb
d
=
f\a"
g]
!
[kb
d
=
fg]
step
represen
ts
its
release.
This
is
the
approac
h
w
e
to
ok
in
the
async
hronous
in
terface
sp
ecications
of
Chapter
3.
The
abstract
in
terface
is
simpler;
t
yping
an
a
is
represen
ted
b
y
a
single
KeyStr
oke
(\a";
typ
;
typ
0
)
step
instead
of
a
pair
of
steps.
Ho
w
ev
er,
using
the
concrete
represen
tation
leads
us
naturally
to
ask:
what
if
the
user
presses
the
a
k
ey
and,
b
efore
releasing
it,
presses
the
b
k
ey?
That's
easy
to
describ
e
with
the
concrete
represen
tation.
The
state
with
b
oth
k
eys
depressed
is
kb
d
=
f\a"
;
\b"
g.
Pressing
and
releasing
a
k
ey
are
represen
ted
simply
b
y
the
t
w
o
actions
Pr
ess
(k
)

=
kb
d
0
=
kb
d
[
fk
g
R
ele
ase
(k
)

=
kb
d
0
=
kb
d
n
fk
g
The
p
ossibilit
y
of
ha
ving
t
w
o
k
eys
depressed
cannot
b
e
expressed
with
the
sim-
ple
abstract
in
terface.
T
o
express
it
abstractly
,
w
e
w
ould
ha
v
e
to
replace
the
parameter
KeyStr
oke
with
t
w
o
parameters
Pr
essKey
and
R
ele
aseKey
,
and
w
e
w
ould
ha
v
e
to
express
explicitly
the
prop
ert
y
that
a
k
ey
can't
b
e
released
un
til
it
has
b
een
depressed,
and
vice-v
ersa.
The
more
concrete
represen
tation
is
then
simpler.
W
e
migh
t
decide
that
w
e
don't
w
an
t
to
consider
the
p
ossibilit
y
of
t
w
o
k
eys
b
eing
depressed,
and
that
w
e
prefer
the
abstract
represen
tation.
But
that
should
b
e
a
conscious
decision.
Our
abstraction
should
not
blind
us
to
what
can
happ
en
in
the
actual
system.
When
in
doubt,
it's
safer
to
use
a
concrete
represen
tation
that
more
accurately
describ
es
the
real
system.
That
w
a
y
,
y
ou
are
less
lik
ely
to
o
v
erlo
ok
real
problems.
Don't
assume
v
alues
that
lo
ok
dieren
t
are
unequal.
The
rules
of
TLA
+
do
not
imply
that
1
6=
\a"
.
If
the
system
can
send
a
message
that
is
either
a
string
or
a
n
um
b
er,
represen
t
the
message
as
a
record
with
a
typ
e
and
value
eld|for
example,
[typ
e
7!
\String"
;
value
7!
\a"
]
or
[typ
e
7!
\Nat"
;
value
7!
1]
W
e
kno
w
that
these
t
w
o
v
alues
are
dieren
t
b
ecause
they
ha
v
e
dieren
t
typ
e
elds.

82
CHAPTER
7.
WRITING
A
SPECIFICA
TION:
SOME
AD
VICE
Mo
v
e
quan
tication
to
the
outside.
Sp
ecications
are
usually
easier
to
read
if
9
is
mo
v
ed
outside
disjunctions
and
8
is
mo
v
ed
outside
conjunctions.
F
or
example,
instead
of
Up

=
9
e
2
Elevator
:
:
:
:
Down

=
9
e
2
Elevator
:
:
:
:
Move

=
Up
_
Down
it's
usually
b
etter
to
write
Up
(e
)

=
:
:
:
Down
(e
)

=
:
:
:
Move

=
9
e
2
Elevator
:
Up
(e
)
_
Down
(e
)
Prime
only
what
y
ou
mean
to
prime.
When
writing
an
action,
b
e
careful
where
y
ou
put
y
our
primes.
The
expression
f
[e
]
0
equals
f
0
[e
0
];
it
equals
f
0
[e
]
only
if
e
0
=
e
,
whic
h
need
not
b
e
true
if
the
expression
e
con
tains
v
ariables.
Be
esp
ecially
careful
when
priming
an
op
erator
whose
denition
con
tains
a
v
ariable.
F
or
example,
supp
ose
x
is
a
v
ariable
and
op
is
dened
b
y
op
(a
)

=
x
+
a
Then
op
(y
)
0
equals
(x
+
y
)
0
,
whic
h
equals
x
0
+
y
0
,
while
op
(y
0
)
equals
x
+
y
0
.
There
is
no
w
a
y
to
use
op
and
0
to
write
the
expression
x
0
+
y
.
(W
riting
op
0
(y
)
do
esn't
w
ork
b
ecause
it's
illegal|y
ou
can
prime
only
an
expression,
not
an
op
erator.)
W
rite
commen
ts
as
commen
ts.
Don't
put
commen
ts
in
to
the
sp
ecication
itself.
I
ha
v
e
seen
p
eople
write
things
lik
e
the
follo
wing
action
denition:
A

=
_
^
x

0
^
:
:
:
_
^
x
<
0
^
f
alse
The
second
disjunct
is
mean
t
to
indicate
that
the
writer
in
tended
A
not
to
b
e
enabled
when
x
<
0.
But
that
disjunct
is
completely
redundan
t,
since
F
^
f
alse
equals
f
alse,
and
F
_
f
alse
equals
F
,
for
an
y
form
ula
F
.
So
the
second
disjunct
of
the
denition
serv
es
only
as
a
form
of
commen
t.
It's
b
etter
to
write
A

=
^
x

0
^
:
:
:
A
is
not
enabled
if
x
<
0

7.7.
WHEN
AND
HO
W
TO
SPECIFY
83
7.7
When
and
Ho
w
to
Sp
ecify
Sp
ecications
are
often
written
later
than
they
should
b
e.
Engineers
are
usually
under
sev
ere
time
constrain
ts,
and
they
ma
y
feel
that
writing
a
sp
ecication
will
slo
w
them
do
wn.
Only
after
a
design
has
b
ecome
so
complex
that
they
need
help
understanding
it
do
most
engineers
think
ab
out
writing
a
precise
sp
ecication.
W
riting
a
sp
ecication
helps
y
ou
think
clearly
.
Thinking
clearly
is
hard;
w
e
can
use
all
the
help
w
e
can
get.
Making
sp
ecication
part
of
the
design
pro
cess
can
impro
v
e
the
design.
I
ha
v
e
describ
ed
ho
w
to
write
a
sp
ecication
assuming
that
the
system
de-
sign
already
exists.
But
it's
b
etter
to
write
the
sp
ecication
as
the
system
is
b
eing
designed.
The
sp
ecication
will
start
out
b
eing
incomplete
and
probably
incorrect.
F
or
example,
an
initial
sp
ecication
of
the
write-through
cac
he
of
Section
5.6
(page
54)
migh
t
include
the
denition
R
dMiss
(p
)

=
Enqueue
a
request
to
write
v
alue
from
memory
to
p
's
cac
he.
Some
enabling
condition
m
ust
b
e
conjoined
here.
^
memQ
0
=
App
end
(memQ
;
buf
[p
])
^
ctl
0
=
[ctl
ex
cept
!
[p
]
=
\?"
]
^
unchanged
h
memInt
;
wmem
;
buf
;
c
ache
i
App
end
request
to
memQ
.
Set
ctl
[p
]
to
v
alue
to
b
e
determined
later.
Some
system
functionalit
y
will
at
rst
b
e
omitted;
it
can
b
e
included
later
b
y
adding
new
disjuncts
to
the
next-state
action.
T
o
ols
can
b
e
applied
to
these
preliminary
sp
ecications
to
help
nd
design
errors.

84
CHAPTER
7.
WRITING
A
SPECIFICA
TION:
SOME
AD
VICE

P
art
I
I
More
Adv
anced
T
opics
85


Chapter
8
Liv
eness
and
F
airness
The
sp
ecications
w
e
ha
v
e
written
so
far
sa
y
what
a
system
m
ust
not
do.
The
clo
c
k
m
ust
not
adv
ance
from
11
to
9;
the
receiv
er
m
ust
not
receiv
e
a
message
if
the
FIF
O
is
empt
y
.
They
don't
require
that
the
system
ev
er
actually
do
an
ything.
The
clo
c
k
need
nev
er
tic
k;
the
sender
need
nev
er
send
an
y
messages.
Our
sp
ecications
ha
v
e
describ
ed
what
are
called
safety
pr
op
erties.
If
a
safet
y
prop
ert
y
is
violated,
it
is
violated
at
some
particular
p
oin
t
in
the
b
eha
vior|b
y
a
step
that
adv
ances
the
clo
c
k
from
11
to
9,
or
that
reads
the
wrong
v
alue
from
memory
.
Therefore,
w
e
can
talk
ab
out
a
safet
y
prop
ert
y
b
eing
satised
b
y
a
nite
b
eha
vior,
whic
h
means
that
it
has
not
b
een
violated
b
y
an
y
step
so
far.
W
e
no
w
learn
ho
w
to
sp
ecify
that
something
do
es
happ
en|that
the
clo
c
k
k
eeps
tic
king,
or
that
a
v
alue
is
ev
en
tually
read
from
memory
.
W
e
sp
ecify
liveness
pr
op
erties
|ones
that
cannot
b
e
violated
at
an
y
particular
instan
t.
Only
b
y
examining
an
en
tire
innite
b
eha
vior
can
w
e
tell
that
the
clo
c
k
has
stopp
ed
tic
king,
or
that
a
message
is
nev
er
sen
t.
W
e
express
liv
eness
prop
erties
as
temp
oral
form
ulas.
This
means
that,
to
add
liv
eness
conditions
to
y
our
sp
ecications,
y
ou
ha
v
e
to
understand
temp
oral
logic|the
logic
of
temp
oral
form
ulas.
The
c
hapter
b
egins,
in
Section
8.1,
with
a
more
rigorous
lo
ok
at
what
a
temp
oral
form
ula
means.
T
o
understand
a
logic,
y
ou
ha
v
e
to
understand
what
its
true
form
ulas
are.
Section
8.2
is
ab
out
temp
oral
tautologies,
the
true
form
ulas
of
temp
oral
logic.
Sections
8.4{8.7
describ
e
ho
w
to
use
temp
oral
form
ulas
to
sp
ecify
liv
eness
prop
erties.
Section
8.8
completes
our
study
of
temp
oral
logic
b
y
examining
the
temp
oral
quan
tier
9
9
9
9
9
9
.
Finally
,
Section
8.9
reviews
what
w
e'v
e
done
and
explains
wh
y
the
undisciplined
use
of
temp
oral
logic
is
dangerous.
This
c
hapter
is
the
only
one
that
con
tains
pro
ofs.
It
w
ould
b
e
nice
if
y
ou
learned
to
write
similar
pro
ofs
y
ourself,
but
it
do
esn't
matter
if
y
ou
don't.
The
pro
ofs
are
here
b
ecause
studying
them
can
help
y
ou
dev
elop
the
in
tuitiv
e
understanding
of
temp
oral
form
ulas
that
y
ou
need
to
write
sp
ecications|
87

88
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
an
understanding
that
mak
es
the
truth
of
a
simple
temp
oral
tautology
lik
e
22F

2F
as
ob
vious
as
the
truth
of
a
simple
theorem
ab
out
n
um
b
ers
lik
e
8
n
2
Nat
:
2

n

n
.
Man
y
readers
will
nd
that
this
c
hapter
taxes
their
mathematical
abilit
y
.
Don't
w
orry
if
y
ou
ha
v
e
trouble
understanding
it.
T
reat
this
c
hapter
as
an
exercise
to
stretc
h
y
our
mind
and
prepare
y
ou
to
add
liv
eness
prop
erties
to
y
our
sp
ecications.
And
remem
b
er
that
liv
eness
prop
erties
are
lik
ely
to
b
e
the
least
imp
ortan
t
part
of
y
our
sp
ecication.
Y
ou
will
probably
not
lose
m
uc
h
if
y
ou
simply
omit
them.
8.1
T
emp
oral
F
orm
ulas
Recall
that
a
state
assigns
a
v
alue
to
ev
ery
v
ariable,
and
a
b
eha
vior
is
an
innite
sequence
of
states.
A
temp
oral
form
ula
is
true
or
false
of
a
b
eha
vior.
F
ormally
,
a
temp
oral
form
ula
F
assigns
a
Bo
olean
v
alue,
whic
h
w
e
write

j
=
F
,
to
a
b
eha
vior

.
W
e
sa
y
that
F
is
true
of

,
or
that

satises
F
,
i

j
=
F
equals
tr
ue
.
T
o
dene
the
meaning
of
a
temp
oral
form
ula
F
,
w
e
ha
v
e
to
explain
ho
w
to
determine
the
v
alue
of

j
=
F
for
an
y
b
eha
vior

.
F
or
no
w,
w
e
consider
only
temp
oral
form
ulas
that
don't
con
tain
the
temp
oral
existen
tial
quan
tier
9
9
9
9
9
9
.
It's
easy
to
dene
the
meaning
of
a
Bo
olean
com
bination
of
temp
oral
form
ulas
in
terms
of
the
meanings
of
those
form
ulas.
The
form
ula
F
^
G
is
true
of
a
b
eha
vior

i
b
oth
F
and
G
are
true
of

,
and
:F
is
true
of

i
F
is
not
true
of

.
These
denitions
are
written
more
formally
as

j
=
(F
^
G
)

=
(
j
=
F
)
^
(
j
=
G
)

j
=
:F

=
:
(
j
=
F
)
These
are
the
denitions
of
the
meaning
of
^
and
of
:
as
op
erators
on
temp
oral
form
ulas.
The
meanings
of
the
other
Bo
olean
op
erators
are
similarly
dened.
W
e
can
also
dene
in
this
w
a
y
the
ordinary
predicate-logic
quan
tiers
8
and
9
as
op
erators
on
temp
oral
form
ulas|for
example:

j
=
(9
r
:
F
)

=
9
r
:
(
j
=
F
)
Ordinary
quan
tication
o
v
er
constan
t
sets
is
dened
the
same
w
a
y
.
F
or
example,
if
S
is
an
ordinary
constan
t
expression|that
is,
one
con
taining
no
v
ariables|
then

j
=
(8
r
2
S
:
F
)

=
8
r
2
S
:
(
j
=
F
)
Quan
tiers
are
discussed
further
in
Section
8.8
b
elo
w.
All
the
unquan
tied
temp
oral
form
ulas
that
w
e'v
e
seen
ha
v
e
b
een
Bo
olean
com
binations
of
three
simple
kinds
of
form
ulas,
whic
h
ha
v
e
the
follo
wing
mean-
ings:
State
function
and
state
pr
e
di-
c
ate
are
dened
on
page
25.

A
state
predicate,
view
ed
as
a
temp
oral
form
ula,
is
true
of
a
b
eha
vior
i
it
is
true
in
the
rst
state
of
the
b
eha
vior.

8.1.
TEMPORAL
F
ORMULAS
89

A
form
ula
2P
,
where
P
is
a
state
predicate,
is
true
of
a
b
eha
vior
i
P
is
true
in
ev
ery
state
of
the
b
eha
vior.

A
form
ula
2[N
]
v
,
where
N
is
an
action
and
v
is
a
state
function,
is
true
of
a
b
eha
vior
i
ev
ery
successiv
e
pair
of
steps
in
the
b
eha
vior
is
a
[N
]
v
step.
Since
a
state
predicate
is
an
action
that
con
tains
no
primed
v
ariables,
w
e
can
b
oth
com
bine
and
generalize
these
three
kinds
of
temp
oral
form
ulas
in
to
the
t
w
o
kinds
of
form
ulas
A
and
2A,
where
A
is
an
action.
I'll
rst
explain
the
meanings
of
these
t
w
o
kinds
of
form
ulas,
and
then
dene
the
op
erator
2
in
general.
T
o
do
this,
I
will
use
the
notation
that

i
is
the
(i
+
1)
st
state
of
the
b
eha
vior

,
for
an
y
natural
n
um
b
er
i
,
so

is
the
b
eha
vior

0
!

1
!

2
!



.
W
e
in
terpret
an
arbitrary
action
A
as
a
temp
oral
form
ula
b
y
dening

j
=
A
to
b
e
true
i
the
rst
t
w
o
states
of

are
an
A
step.
That
is,
w
e
dene

j
=
A
to
b
e
true
i

0
!

1
is
an
A
step.
In
the
sp
ecial
case
when
A
is
a
state
predicate,

0
!

1
is
an
A
step
i
A
is
true
in
state

0
,
so
this
denition
of

j
=
A
generalizes
our
in
terpretation
of
a
state
predicate
as
a
temp
oral
form
ula.
W
e
ha
v
e
already
seen
that
2[N
]
v
is
true
of
a
b
eha
vior
i
eac
h
step
is
a
[N
]
v
step.
This
leads
us
to
dene

j
=
2A
to
b
e
true
i

n
!

n
+1
is
an
A
step,
for
all
natural
n
um
b
ers
n
.
W
e
no
w
generalize
from
the
denition
of

j
=
2A
for
an
action
A
to
the
denition
of

j
=
2F
for
an
arbitrary
temp
oral
form
ula
F
.
W
e
dened

j
=
2A
to
b
e
true
i

n
!

n
+1
is
an
A
step
for
all
n
.
This
is
true
i
A,
in
terpreted
as
a
temp
oral
form
ula,
is
true
of
a
b
eha
vior
whose
rst
step
is

n
!

n
+1
,
for
all
n
.
Let's
dene

+n
to
b
e
the
sux
of

obtained
b
y
deleting
its
rst
n
states:

+n

=

n
!

n
+1
!

n
+2
!



Then

n
!

n
+1
is
the
rst
step
of

+n
,
so

j
=
2A
is
true
i

+n
j
=
A
is
true
for
all
n
.
In
other
w
ords

j
=
2A

8
n
2
Nat
:

+n
j
=
A
The
ob
vious
generalization
is

j
=
2F

=
8
n
2
Nat
:

+n
j
=
F
for
an
y
temp
oral
form
ula
F
.
In
other
w
ords,

satises
2F
i
ev
ery
sux

+n
of

satises
F
.
This
denes
the
meaning
of
the
temp
oral
op
erator
2.
W
e
ha
v
e
no
w
dened
the
meaning
of
an
y
temp
oral
form
ula
built
from
ac-
tions
(including
state
predicates),
Bo
olean
op
erators,
and
the
2
op
erator.
F
or
example:

j
=
2((x
=
1)
)
2(y
>
0))

8
n
2
Nat
:

+n
j
=
((x
=
1)
)
2(y
>
0))
By
the
meaning
of
2.

8
n
2
Nat
:
(
+n
j
=
(x
=
1))
)
(
+n
j
=
2(y
>
0))
By
the
meaning
of
).

8
n
2
Nat
:
(
+n
j
=
(x
=
1))
)
(8
m
2
Nat
:
(
+n
)
+m
j
=
(y
>
0))
By
the
meaning
of
2.

90
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
Th
us,

j
=
2((x
=
1)
)
2(y
>
0))
is
true
i,
for
all
n
2
Nat
,
if
x
=
1
is
true
in
state

n
,
then
y
>
0
is
true
in
all
states

n
+m
with
m

0.
T
o
understand
temp
oral
form
ulas
in
tuitiv
ely
,
think
of

n
as
the
state
of
the
univ
erse
at
time
instan
t
n
during
the
b
eha
vior

.
1
F
or
an
y
state
pred-
icate
P
,
the
expression

+n
j
=
P
asserts
that
P
is
true
at
time
n
.
Th
us,
2((x
=
1)
)
2(y
>
0))
asserts
that,
an
y
time
x
=
1
is
true,
y
>
0
is
true
from
then
on.
F
or
an
arbitrary
temp
oral
form
ula
F
,
w
e
also
in
terpret

+n
j
=
F
as
the
assertion
that
F
is
true
at
time
instan
t
n
.
The
form
ula
2F
then
asserts
that
F
is
true
at
all
times.
W
e
can
therefore
read
2
as
always
or
henc
eforth
or
fr
om
then
on.
W
e
sa
w
in
Section
2.2
that
a
sp
ecication
should
allo
w
stuttering
steps|ones
that
lea
v
e
unc
hanged
all
the
v
ariables
app
earing
in
the
form
ula.
A
stuttering
step
represen
ts
a
c
hange
only
to
some
part
of
the
system
not
describ
ed
b
y
the
form
ula;
adding
it
to
the
b
eha
vior
should
not
aect
the
truth
of
the
form
ula.
W
e
sa
y
that
a
form
ula
F
is
invariant
under
stuttering
2
i
adding
or
deleting
a
stuttering
step
to
a
b
eha
vior

do
es
not
aect
whether

satises
F
.
A
sensible
form
ula
should
b
e
in
v
arian
t
under
stuttering.
There's
no
p
oin
t
writing
form
ulas
that
aren't
sensible,
so
TLA
allo
ws
y
ou
to
write
only
temp
oral
form
ulas
that
are
in
v
arian
t
under
stuttering.
A
state
predicate
(view
ed
as
a
temp
oral
form
ula)
is
in
v
arian
t
under
stutter-
ing,
since
its
truth
dep
ends
only
on
the
rst
state
of
a
b
eha
vior,
and
adding
a
stuttering
step
do
esn't
c
hange
the
rst
state.
An
arbitrary
action
is
not
in
v
ari-
an
t
under
stuttering.
F
or
example,
the
action
[x
0
=
x
+
1]
x
is
satised
b
y
a
b
eha
vior

in
whic
h
x
is
left
unc
hanged
in
the
rst
step
and
incremen
ted
b
y
2
in
the
second
step;
it
isn't
satised
b
y
the
b
eha
vior
obtained
b
y
remo
ving
the
initial
stuttering
step
from

.
Ho
w
ev
er,
the
form
ula
2[x
0
=
x
+
1]
x
is
in
v
arian
t
under
stuttering,
since
it
is
satised
b
y
a
b
eha
vior
i
ev
ery
step
that
c
hanges
x
is
an
x
0
=
x
+
1
step|a
condition
not
aected
b
y
adding
or
deleting
stuttering
steps.
In
general,
the
form
ula
2[A]
v
is
in
v
arian
t
under
stuttering,
for
an
y
action
A
and
state
function
v
.
Ho
w
ev
er,
2A
is
not
in
v
arian
t
under
stuttering
for
an
arbitrary
action
A.
F
or
example,
2(x
0
=
x
+
1)
can
b
e
made
false
b
y
adding
a
step
that
do
es
not
c
hange
x
.
So,
ev
en
though
w
e
ha
v
e
assigned
a
meaning
to
2(x
0
=
x
+
1),
it
isn't
a
legal
TLA
form
ula.
In
v
ariance
under
stuttering
is
preserv
ed
b
y
2
and
b
y
the
Bo
olean
op
erators|
that
is,
if
F
and
G
are
in
v
arian
t
under
stuttering,
then
so
are
2F
,
:F
,
F
^
G
,
8
x
2
S
:
F
,
etc.
So,
state
predicates,
form
ulas
of
the
form
2[N
]
v
,
and
all
for-
m
ulas
obtainable
from
them
b
y
applying
2
and
Bo
olean
op
erators
are
in
v
arian
t
under
stuttering.
1
It
is
b
ecause
w
e
think
of

n
as
the
state
at
time
n
,
and
b
ecause
w
e
usually
measure
time
starting
from
0,
that
I
n
um
b
er
the
states
of
a
b
eha
vior
starting
with
0
rather
than
1.
2
This
is
a
completely
new
sense
of
the
w
ord
invariant
;
it
has
nothing
to
do
with
the
concept
of
in
v
ariance
discussed
already
.

8.1.
TEMPORAL
F
ORMULAS
91
W
e
no
w
examine
v
e
esp
ecially
imp
ortan
t
classes
of
form
ulas
that
are
con-
structed
from
arbitrary
temp
oral
form
ulas
F
and
G
.
W
e
in
tro
duce
new
op
era-
tors
for
expressing
the
rst
three.
3F
is
dened
to
equal
:2:F
.
It
asserts
that
F
is
not
alw
a
ys
false,
whic
h
means
that
F
is
true
at
some
time:

j
=
3F


j
=
:2:F
By
denition
of
3.

:
(
j
=
2:F
)
By
the
meaning
of
:.

:
(8
n
2
Nat
:

+n
j
=
:F
)
By
the
meaning
of
2.

:
(8
n
2
Nat
:
:
(
+n
j
=
F
))
By
the
meaning
of
:.

9
n
2
Nat
:

+n
j
=
F
Because
:8
:
is
equiv
alen
t
to
9
.
W
e
usually
read
3
as
eventual
ly,
taking
ev
en
tually
to
include
no
w.
F
;
G
is
dened
to
equal
2(F
)
3G
).
The
same
kind
of
calculation
w
e
just
did
for

j
=
3F
sho
ws

j
=
(F
;
G
)

8
n
2
Nat
:
(
+n
j
=
F
)
)
(9
m
2
Nat
:
(
+(n
+m
)
j
=
G
))
The
form
ula
F
;
G
asserts
that
whenev
er
F
is
true,
G
is
ev
en
tually
true|that
is,
G
is
true
then
or
at
some
later
time.
W
e
read
;
as
le
ads
to.
3hAi
v
is
dened
to
equal
:2[:A]
v
,
where
A
is
an
action
and
v
a
state
function.
It
asserts
that
not
ev
ery
step
is
a
(:A)
_
(v
0
=
v
)
step,
so
some
step
is
a
:((:A)
_
(v
0
=
v
))
step.
Since
:(P
_
Q
)
is
equiv
alen
t
to
(:P
)
^
(:Q
),
for
an
y
P
and
Q
,
action
:((:A)
_
(v
0
=
v
))
is
equiv
alen
t
to
A
^
(v
0
6=
v
)
.
Hence,
3h
A
i
v
asserts
that
some
step
is
an
A
^
(v
0
6=
v
)
step|that
is,
an
A
step
that
c
hanges
v
.
W
e
dene
the
action
h
A
i
v
b
y
I
pronounce
h
A
i
v
as
angle
A
sub
v.
h
A
i
v

=
A
^
(v
0
6=
v
)
so
3h
A
i
v
asserts
that
ev
en
tually
an
h
A
i
v
step
o
ccurs.
W
e
think
of
3h
A
i
v
as
the
form
ula
obtained
b
y
applying
the
op
erator
3
to
h
A
i
v
,
although
tec
hnically
it's
not
b
ecause
h
A
i
v
isn't
a
temp
oral
form
ula.
23F
asserts
that
at
all
times,
F
is
true
then
or
at
some
later
time.
F
or
time
0,
this
implies
that
F
is
true
at
some
time
n
0

0.
F
or
time
n
0
+
1,
it
implies
that
F
is
true
at
some
time
n
1

n
0
+
1.
F
or
time
n
1
+
1,
it
implies
that
F
is
true
at
some
time
n
2

n
1
+
1.
Con
tin
uing
the
pro
cess,
w
e
see
that
F
is
true
at
an
innite
sequence
of
time
instan
ts
n
0
;
n
1
;
n
2
;
:
:
:
.
So,
23F
implies
that
F
is
true
at
innitely
man
y
instan
ts.
Con
v
ersely
,
if
F
is
true
at
innitely
man
y
instan
ts,
then,
at
ev
ery
instan
t,
F
m
ust
b
e
true
at
some
later
instan
t,
so
23F
is
true.
Therefore,
23F
asserts
that
F
is
innitely
often
true.
In
particular,
23h
A
i
v
asserts
that
innitely
man
y
h
A
i
v
steps
o
ccur.

92
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
32F
asserts
that
ev
en
tually
(at
some
time),
F
b
ecomes
true
and
remains
true
thereafter.
In
other
w
ords,
32F
asserts
that
F
is
eventual
ly
always
true.
In
particular,
32[N
]
v
asserts
that,
ev
en
tually
,
ev
ery
step
is
a
[N
]
v
step.
The
op
erators
2
and
3
ha
v
e
higher
precedence
(bind
more
tigh
tly)
than
the
Bo
olean
op
erators,
so
3F
_
2G
means
(3F
)
_
(2G
)
.
The
op
erator
;
has
lo
w
er
precedence
than
^
and
_.
8.2
T
emp
oral
T
autologies
A
temp
oral
theorem
is
a
temp
oral
form
ula
that
is
satised
b
y
all
b
eha
viors.
In
other
w
ords,
F
is
a
theorem
i

j
=
F
equals
tr
ue
for
all
b
eha
viors

.
F
or
example,
the
HourClo
ck
mo
dule
asserts
that
HC
)
2HCini
is
a
theorem,
where
HC
and
HCini
are
the
form
ulas
dened
in
the
mo
dule.
This
theorem
expresses
a
prop
ert
y
of
the
hour
clo
c
k.
The
form
ula
2HCini
)
HCini
is
also
a
theorem.
Ho
w
ev
er,
it
tells
us
nothing
ab
out
the
hour
clo
c
k
b
ecause
it's
true
regardless
of
ho
w
HCini
is
dened.
F
or
example,
substituting
x
>
7
for
HCini
yields
the
theorem
2(x
>
7)
)
(x
>
7).
A
form
ula
lik
e
2HCini
)
HCini
that
is
true
when
an
y
form
ulas
are
substituted
for
its
iden
tiers
is
called
a
tautolo
gy.
T
o
distinguish
them
from
the
tautologies
of
ordinary
logic,
tautologies
con
taining
temp
oral
op
erators
are
sometimes
called
temp
or
al
tautologies.
Let's
pro
v
e
that
2HCini
)
HCini
is
a
temp
oral
tautology
.
T
o
a
v
oid
con-
fusing
the
arbitrary
iden
tier
HCini
in
this
tautology
with
the
form
ula
HCini
dened
in
the
HourClo
ck
mo
dule,
let's
replace
it
b
y
F
,
so
the
tautology
b
ecomes
2F
)
F
.
There
are
axioms
and
inference
rules
for
temp
oral
logic
from
whic
h
w
e
can
pro
v
e
an
y
temp
oral
tautology
that,
lik
e
2F
)
F
,
con
tains
no
quan
tiers.
Ho
w
ev
er,
it's
often
easier
and
more
instructiv
e
to
pro
v
e
them
directly
from
the
meanings
of
the
op
erators.
W
e
pro
v
e
that
2F
)
F
is
a
tautology
b
y
pro
ving
that

j
=
(2F
)
F
)
equals
tr
ue,
for
an
y
b
eha
vior

and
an
y
form
ula
F
.
The
pro
of
is
simple:

j
=
(2F
)
F
)

(
j
=
2F
)
)
(
j
=
F
)
By
the
meaning
of
).

(8
n
2
Nat
:

+n
j
=
F
)
)
(
j
=
F
)
By
denition
of
2.

(8
n
2
Nat
:

+n
j
=
F
)
)
(
+0
j
=
F
)
By
denition
of

+0
.

tr
ue
By
predicate
logic.
The
temp
oral
tautology
2F
)
F
asserts
the
ob
vious
fact
that,
if
F
is
true
at
all
times,
then
it's
true
at
time
0.
Suc
h
a
simple
tautology
should
b
e
ob
vious
once
y
ou
b
ecome
accustomed
to
thinking
in
terms
of
temp
oral
form
ulas.
Here
are
three
more
simple
tautologies,
along
with
their
English
translations.
:2F

3:F
F
is
not
alw
a
ys
true
i
it
is
ev
en
tually
false.

8.2.
TEMPORAL
T
A
UTOLOGIES
93
2(F
^
G
)

(2F
)
^
(2G
)
F
and
G
are
b
oth
alw
a
ys
true
i
F
is
alw
a
ys
true
and
G
is
alw
a
ys
true.
Another
w
a
y
of
sa
ying
this
is
that
2
distributes
o
v
er
^.
3(F
_
G
)

(3F
)
_
(3G
)
F
or
G
is
ev
en
tually
true
i
F
is
ev
en
tually
true
or
G
is
ev
en
tually
true.
Another
w
a
y
of
sa
ying
this
is
that
3
distributes
o
v
er
_.
A
t
the
heart
of
the
pro
of
of
eac
h
of
these
tautologies
is
a
tautology
of
predicate
logic.
F
or
example,
the
pro
of
that
2
distributes
o
v
er
^
relies
on
the
fact
that
8
distributes
o
v
er
^:

j
=
(2(F
^
G
)

(2F
)
^
(2G
))

(
j
=
2(F
^
G
))

(
j
=
(2F
)
^
(2G
))
By
the
meaning
of
.

(
j
=
2(F
^
G
))

(
j
=
2F
)
^
(
j
=
2G
)
By
the
meaning
of
^.

(8
n
2
Nat
:

+n
j
=
(F
^
G
))

(8
n
2
Nat
:

+n
j
=
F
)
^
(8
n
2
Nat
:

+n
j
=
G
)
By
denition
of
2.

tr
ue
By
the
predicate-logic
tautology
(8
x
2
S
:
P
^
Q
)

(8
x
2
S
:
P
)
^
(8
x
2
S
:
Q
).
The
op
erator
2
do
esn't
distribute
o
v
er
_,
nor
do
es
3
distribute
o
v
er
^.
F
or
example,
2((n

0)
_
(n
<
0))
is
not
equiv
alen
t
to
(2(n

0)
_
2(n
<
0));
the
rst
form
ula
is
true
for
an
y
b
eha
vior
in
whic
h
n
is
alw
a
ys
a
n
um
b
er,
but
the
second
is
false
for
a
b
eha
vior
in
whic
h
n
assumes
b
oth
p
ositiv
e
and
negativ
e
v
alues.
Ho
w
ev
er,
the
follo
wing
t
w
o
form
ulas
are
tautologies:
(2F
)
_
(2G
)
)
2(F
_
G
)
3(F
^
G
)
)
(3F
)
^
(3G
)
Either
of
these
tautologies
can
b
e
deriv
ed
from
the
other
b
y
substituting
:F
for
F
and
:G
for
G
.
Making
this
substitution
in
the
second
tautology
yields
tr
ue

3((:F
)
^
(:G
))
)
(3:F
)
^
(3:G
)
By
substitution
in
the
second
tautology
.

3:(F
_
G
)
)
(3:F
)
^
(3:G
)
Because
(:P
^
:Q
)

:(P
_
Q
).

:2(F
_
G
)
)
(:2F
)
^
(:2G
)
Because
3:H

:2H
.

:2(F
_
G
)
)
:((2F
)
_
(2G
))
Because
(:P
^
:Q
)

:(P
_
Q
).

(2F
)
_
(2G
)
)
2(F
_
G
)
Because
(:P
)
:Q
)

(Q
)
P
).
This
pair
of
tautologies
illustrates
a
general
la
w:
from
an
y
temp
oral
tautology
,
w
e
obtain
a
dual
tautology
b
y
making
the
replacemen
ts
2
 
3
3
 
2
^
 
_
_
 
^
and
rev
ersing
the
direction
of
all
implications.
(An
y

or
:
is
left
unc
hanged.)
As
in
the
example
ab
o
v
e,
the
dual
tautology
can
b
e
pro
v
ed
from
the
original
b
y
replacing
eac
h
iden
tier
with
its
negation
and
applying
the
(dual)
tautologies
3:F

:2F
and
:3F

2:F
along
with
prop
ositional-logic
reasoning.

94
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
Another
imp
ortan
t
pair
of
dual
tautologies
assert
that
23
distributes
o
v
er
_
and
32
distributes
o
v
er
^:
23(F
_
G
)

(23F
)
_
(23G
)
32(F
^
G
)

(32F
)
^
(32G
)
(8.1)
The
rst
asserts
that
F
or
G
is
true
innitely
often
i
F
is
true
innitely
often
or
G
is
true
innitely
often.
Its
truth
should
b
e
fairly
ob
vious,
but
let's
pro
v
e
it.
T
o
reason
ab
out
23,
it
helps
to
in
tro
duce
the
sym
b
ol
9
1
,
whic
h
means
ther
e
exist
innitely
many.
In
particular,
9
1
i
2
Nat
:
P
(i
)
means
that
P
(i
)
is
true
for
innitely
man
y
natural
n
um
b
ers
i
.
On
page
91,
w
e
sho
w
ed
that
23F
asserts
that
F
is
true
innitely
often.
Using
9
1
,
w
e
can
express
this
as
(
j
=
23F
)

(9
1
i
2
Nat
:

+i
j
=
F
)
(8.2)
The
same
reasoning
pro
v
es
the
follo
wing
more
general
result,
where
P
is
an
y
op
erator:
(8
n
2
Nat
:
9
m
2
Nat
:
P
(n
+
m
))

9
1
i
2
Nat
:
P
(i
)
(8.3)
Here
is
another
useful
tautology
in
v
olving
9
1
,
where
P
and
Q
are
arbitrary
op
erators
and
S
is
an
arbitrary
set:
(9
1
i
2
S
:
P
(i
)
_
Q
(i
))

(9
1
i
2
S
:
P
(i
))
_
(9
1
i
2
S
:
Q
(i
))
(8.4)
Using
these
results,
it's
no
w
easy
to
pro
v
e
that
23
distributes
o
v
er
_:

j
=
23(F
_
G
)

9
1
i
2
Nat
:

+i
j
=
(F
_
G
)
By
(8.2).

(9
1
i
2
Nat
:

+i
j
=
F
)
_
(9
1
i
2
Nat
:

+i
j
=
G
)
By
(8.4).

(
j
=
23F
)
_
(
j
=
23G
)
By
(8.2).
F
rom
this,
w
e
deduce
the
dual
tautology
,
that
32
distributes
o
v
er
^.
In
an
y
TLA
tautology
,
replacing
a
temp
oral
form
ula
b
y
an
action
yields
a
tautology|a
form
ula
that
is
true
for
all
b
eha
viors|ev
en
if
that
form
ula
isn't
a
legal
TLA
form
ula.
(Remem
b
er
that
w
e
ha
v
e
dened
the
meaning
of
nonTLA
form
ulas
lik
e
2(x
0
=
x
+
1).)
W
e
can
apply
the
rules
of
logic
to
transform
those
nonTLA
tautologies
in
to
TLA
tautologies.
Among
these
rules
are
the
follo
wing
dual
equiv
alences,
whic
h
are
easy
to
c
hec
k:
[A
^
B
]
v

[A]
v
^
[B
]
v
h
A
_
B
i
v

h
A
i
v
_
h
B
i
v
(The
second
asserts
that
an
A
_
B
step
that
c
hanges
v
is
either
an
A
step
that
c
hanges
v
or
a
B
step
that
c
hanges
v
.)
As
an
example
of
substituting
actions
for
temp
oral
form
ulas
in
TLA
tautolo-
gies,
let's
substitute
h
A
i
v
and
h
B
i
v
for
F
and
G
in
the
rst
tautology
of
(8.1)
to
get
23(h
A
i
v
_
h
B
i
v
)

(23h
A
i
v
)
_
(23h
B
i
v
)
(8.5)

8.3.
TEMPORAL
PR
OOF
R
ULES
95
This
isn't
a
TLA
tautology
,
b
ecause
23(h
A
i
v
_
h
B
i
v
)
isn't
a
TLA
form
ula.
Ho
w
ev
er,
a
general
rule
of
logic
tells
us
that
replacing
a
subform
ula
b
y
an
equiv-
alen
t
one
yields
an
equiv
alen
t
form
ula.
Substituting
h
A
_
B
i
v
for
h
A
i
v
_
h
B
i
v
in
(8.5)
giv
es
us
the
follo
wing
TLA
tautology:
23h
A
_
B
i
v

(23h
A
i
v
)
_
(23h
B
i
v
)
8.3
T
emp
oral
Pro
of
Rules
A
pro
of
rule
is
a
rule
for
deducing
true
form
ulas
from
other
true
form
ulas.
F
or
example,
the
Mo
dus
Ponens
Rule
of
prop
ositional
logic
tells
us
that,
for
an
y
form
ulas
F
and
G
,
if
w
e
ha
v
e
pro
v
ed
F
and
F
)
G
,
then
w
e
can
deduce
G
.
Since
the
la
ws
of
prop
ositional
logic
hold
for
temp
oral
logic
as
w
ell,
w
e
can
apply
the
Mo
dus
Ponens
Rule
when
reasoning
ab
out
temp
oral
form
ulas.
T
emp
oral
logic
also
has
some
pro
of
rules
of
its
o
wn.
One
is
Generalization
Rule
F
rom
F
w
e
can
infer
2F
,
for
an
y
temp
oral
for-
m
ula
F
.
This
rule
asserts
that,
if
F
is
true
for
all
b
eha
viors,
then
so
is
2F
.
T
o
pro
v
e
it,
w
e
m
ust
sho
w
that,
if

j
=
F
is
true
for
ev
ery
b
eha
vior

,
then

j
=
2F
is
true
for
ev
ery
b
eha
vior

.
The
pro
of
is
easy:

j
=
2F

8
n
2
Nat
:

+n
j
=
F
By
denition
of
2.

8
n
2
Nat
:
tr
ue
By
the
assumption
that

j
=
F
equals
tr
ue
,
for
all

.

tr
ue
By
predicate
logic.
Another
temp
oral
pro
of
rule
is
Implies
Generalization
Rule
F
rom
F
)
G
w
e
can
infer
2F
)
2G
,
for
an
y
temp
oral
form
ulas
F
and
G
.
The
Generalization
Rule
can
b
e
deriv
ed
from
the
Implies
Generalization
Rule
and
the
tautology
tr
ue
=
2tr
ue
b
y
substituting
tr
ue
for
F
and
F
for
G
.
The
dierence
b
et
w
een
a
temp
oral
pro
of
rule
and
a
temp
oral
tautology
can
b
e
confusing.
In
prop
ositional
logic,
ev
ery
pro
of
rule
has
a
corresp
onding
tautology
.
The
Mo
dus
Ponens
Rule,
whic
h
asserts
that
w
e
can
deduce
G
b
y
pro
ving
F
and
F
)
G
,
implies
the
tautology
F
^
(F
)
G
)
)
G
.
But
in
temp
oral
logic,
a
pro
of
rule
need
not
imply
a
tautology
.
The
Generalization
Rule,
whic
h
states
that
w
e
can
deduce
2F
b
y
pro
ving
F
,
do
es
not
imply
that
F
)
2F
is
a
tautology
.
The
rule
means
that,
if

j
=
F
is
true
for
all

,
then

j
=
2F
is
true
for
all

.
That's
dieren
t
from
the
(false)
assertion
that
F
)
2F
is
a
tautology
,
whic
h
w
ould
mean
that

j
=
(F
)
2F
)
is
true
for
all

.
F
or
example,

j
=
(F
)
2F
)
equals
f
alse
if
F
is
a
state
predicate
that
is
true
in
the
rst
state
of

and
is
false
in
some
other
state
of

.
F
orgetting
the
distinction
b
et
w
een
a
pro
of
rule
and
a
tautology
is
a
common
source
of
mistak
es
when
using
temp
oral
logic.

96
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
8.4
W
eak
F
airness
It's
easy
to
sp
ecify
liv
eness
prop
erties
with
the
temp
oral
op
erators
2
and
3.
F
or
example,
consider
the
hour-clo
c
k
sp
ecication
of
mo
dule
HourClo
ck
in
Figure
2.1
on
page
20.
W
e
can
require
that
the
clo
c
k
nev
er
stops
b
y
asserting
that
there
m
ust
b
e
innitely
man
y
HCnxt
steps.
The
ob
vious
w
a
y
to
write
this
assertion
is
23HCnxt
,
but
that's
not
a
legal
TLA
form
ula
b
ecause
HCnxt
is
an
action,
not
a
temp
oral
form
ula.
Ho
w
ev
er,
an
HCnxt
step
adv
ances
the
v
alue
hr
of
the
clo
c
k,
so
it
c
hanges
hr
.
Therefore,
an
HCnxt
step
is
also
an
HCnxt
step
that
c
hanges
hr
|that
is,
it's
an
h
HCnxt
i
hr
step.
W
e
can
th
us
write
the
liv
eness
prop
ert
y
that
the
clo
c
k
nev
er
stops
as
23h
HCnxt
i
hr
.
So,
w
e
can
tak
e
HC
^
23h
HCnxt
i
hr
to
b
e
the
sp
ecication
of
a
clo
c
k
that
nev
er
stops.
Before
con
tin
uing,
I
m
ust
mak
e
a
confession
and
then
lead
y
ou
on
a
brief
digression
ab
out
subscripts.
Let
me
rst
confess
that
the
argumen
t
I
just
ga
v
e,
that
w
e
can
write
23h
HCnxt
i
hr
in
place
of
23HCnxt
,
w
as
slopp
y
(a
p
olite
term
for
wr
ong
).
Not
ev
ery
HCnxt
step
c
hanges
hr
.
Consider
a
state
in
whic
h
hr
has
some
v
alue
that
is
not
a
n
um
b
er|p
erhaps
a
v
alue
1.
An
HCnxt
step
that
starts
in
suc
h
a
state
sets
the
new
v
alue
of
hr
to
1
+
1.
W
e
don't
kno
w
what
1
+
1
equals;
it
migh
t
or
migh
t
not
equal
1.
If
it
do
es,
then
the
HCnxt
step
lea
v
es
hr
unc
hanged,
so
it
is
not
an
h
HCnxt
i
hr
step.
F
ortunately
,
states
in
whic
h
the
v
alue
of
hr
is
not
a
n
um
b
er
are
irrelev
an
t.
Because
w
e
are
conjoining
the
liv
eness
condition
to
the
safet
y
sp
ecication
HC
,
w
e
care
only
ab
out
b
eha
viors
that
satisfy
HC
.
In
all
suc
h
b
eha
viors,
hr
is
alw
a
ys
a
n
um
b
er,
and
ev
ery
HCnxt
step
is
an
h
HCnxt
i
hr
step.
Therefore,
HC
^
23h
HCnxt
i
hr
is
equiv
alen
t
to
the
nonTLA
form
ula
HC
^
23HCnxt
.
3
When
writing
liv
eness
prop
erties,
the
syn
tax
of
TLA
often
forces
us
to
write
h
A
i
v
instead
of
A,
for
some
action
A.
As
in
the
case
of
HCnxt
,
the
safet
y
sp
ecication
usually
implies
that
an
y
A
step
c
hanges
some
v
ariable.
T
o
a
v
oid
ha
ving
to
think
ab
out
whic
h
v
ariables
A
actually
c
hanges,
w
e
generally
tak
e
the
subscript
v
to
b
e
the
tuple
of
all
v
ariables,
whic
h
is
c
hanged
i
an
y
v
ariable
c
hanges.
But
what
if
A
do
es
allo
w
stuttering
steps?
It's
silly
to
assert
that
a
stuttering
step
ev
en
tually
o
ccurs,
since
suc
h
an
assertion
is
not
in
v
arian
t
under
stuttering.
So,
if
A
do
es
allo
w
stuttering
steps,
w
e
w
an
t
to
require
not
that
an
A
step
ev
en
tually
o
ccurs,
but
that
a
nonstuttering
A
step
o
ccurs|that
is,
an
h
A
i
v
step,
where
v
is
the
tuple
of
all
the
sp
ecication's
v
ariables.
The
syn
tax
of
TLA
forces
us
to
sa
y
what
w
e
should
mean.
When
discussing
form
ulas,
I
will
usually
ignore
the
angle
brac
k
ets
and
sub-
scripts.
F
or
example,
I
migh
t
describ
e
23h
HCnxt
i
hr
as
the
assertion
that
there
are
innitely
man
y
HCnxt
steps,
rather
than
innitely
man
y
h
Hnxt
i
hr
,
whic
h
is
what
it
really
asserts.
This
nishes
the
digression;
w
e
no
w
return
to
sp
ecifying
liv
eness
conditions.
3
Ev
en
though
HC
^
23HCnxt
is
not
a
TLA
form
ula,
its
meaning
has
b
een
dened,
so
w
e
can
determine
whether
it
is
equiv
alen
t
to
a
TLA
form
ula.

8.4.
WEAK
F
AIRNESS
97
Let's
mo
dify
sp
ecication
Sp
e
c
of
mo
dule
Channel
(Figure
3.2
on
page
30)
to
require
that
ev
ery
v
alue
sen
t
is
ev
en
tually
receiv
ed.
W
e
do
this
b
y
conjoining
a
liv
eness
condition
to
Sp
e
c
.
The
analog
of
the
liv
eness
condition
for
the
clo
c
k
is
23h
R
cv
i
chan
,
whic
h
asserts
that
there
are
innitely
man
y
R
cv
steps.
Ho
w
ev
er,
only
a
v
alue
that
has
b
een
sen
t
can
b
e
receiv
ed,
so
this
condition
w
ould
also
require
that
innitely
man
y
v
alues
b
e
sen
t|a
requiremen
t
w
e
don't
w
an
t
to
mak
e.
W
e
w
an
t
to
p
ermit
b
eha
viors
in
whic
h
no
v
alue
is
ev
er
sen
t,
so
no
v
alue
is
ev
er
receiv
ed.
W
e
require
only
that
an
y
v
alue
that
is
sen
t
is
ev
en
tually
receiv
ed.
T
o
assure
that
all
v
alues
that
should
b
e
receiv
ed
are
ev
en
tually
receiv
ed,
it
suces
to
require
only
that
the
next
v
alue
to
b
e
receiv
ed
ev
en
tually
is
receiv
ed.
(When
that
v
alue
has
b
een
receiv
ed,
the
one
after
it
b
ecomes
the
next
v
alue
to
b
e
receiv
ed,
so
it
m
ust
ev
en
tually
b
e
receiv
ed,
and
so
on.)
More
precisely
,
w
e
need
only
require
it
alw
a
ys
to
b
e
the
case
that,
if
there
is
a
v
alue
to
b
e
receiv
ed,
then
the
next
v
alue
to
b
e
receiv
ed
ev
en
tually
is
receiv
ed.
The
next
v
alue
is
receiv
ed
b
y
a
R
cv
step,
so
the
requiremen
t
is
4
2(There
is
an
unreceiv
ed
v
alue
)
3h
R
cv
i
chan
)
There
is
an
unreceiv
ed
v
alue
i
action
R
cv
is
enabled,
meaning
that
it
is
p
ossible
to
tak
e
a
R
cv
step.
TLA
+
denes
enabled
A
to
b
e
the
predicate
that
is
true
i
action
A
is
enabled.
The
liv
eness
condition
can
then
b
e
written
2(enabled
h
R
cv
i
chan
)
3h
R
cv
i
chan
)
(8.6)
In
the
enabled
form
ula,
it
do
esn't
matter
if
w
e
write
R
cv
or
h
R
cv
i
chan
.
W
e
add
the
angle
brac
k
ets
so
the
t
w
o
actions
app
earing
in
the
form
ula
are
the
same.
In
an
y
b
eha
vior
satisfying
the
safet
y
sp
ecication
HC
,
it's
alw
a
ys
p
ossible
to
tak
e
an
HCnxt
step
that
c
hanges
hr
.
Action
h
HCnxt
i
hr
is
therefore
al-
w
a
ys
enabled,
so
enabled
h
HCnxt
i
hr
is
true
throughout
suc
h
a
b
eha
vior.
Since
tr
ue
)
3h
HCnxt
i
hr
is
equiv
alen
t
to
3h
HCnxt
i
hr
,
w
e
can
replace
the
liv
eness
condition
23h
HCnxt
i
hr
for
the
hour
clo
c
k
with
2(enabled
h
HCnxt
i
hr
)
3h
HCnxt
i
hr
)
This
suggests
the
follo
wing
general
liv
eness
condition
for
an
action
A:
2(enabled
h
A
i
v
)
3h
A
i
v
)
This
condition
asserts
that,
if
A
ev
er
b
ecomes
enabled,
then
an
A
step
will
ev
en
tually
o
ccur|ev
en
if
A
remains
enabled
for
only
a
fraction
of
a
nanosecond
and
is
nev
er
again
enabled.
The
ob
vious
practical
dicult
y
of
implemen
ting
suc
h
a
condition
suggests
that
it's
to
o
strong.
So,
w
e
replace
it
with
the
w
eak
er
form
ula
WF
v
(A),
dened
to
equal
2(2enabled
h
A
i
v
)
3h
A
i
v
)
(8.7)
4
2(F
)
3G
)
equals
F
;
G
,
so
w
e
could
write
this
form
ula
more
compactly
with
;.
Ho
w
ev
er,
it's
more
con
v
enien
t
to
k
eep
it
in
the
form
2(F
)
3G
)

98
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
This
form
ula
asserts
that,
if
A
ev
er
b
ecomes
forev
er
enabled,
then
an
A
step
m
ust
ev
en
tually
o
ccur.
WF
stands
for
W
eak
F
airness,
and
the
condition
WF
v
(A)
is
called
we
ak
fairness
on
A.
W
e'll
so
on
see
that
our
liv
eness
conditions
for
the
clo
c
k
and
the
c
hannel
can
b
e
written
as
WF
form
ulas.
But
rst,
let's
examine
(8.7)
and
the
follo
wing
t
w
o
form
ulas,
whic
h
turn
out
to
b
e
equiv
alen
t
to
it:
23(:enabled
h
A
i
v
)
_
23h
A
i
v
(8.8)
32(enabled
h
A
i
v
)
)
23h
A
i
v
(8.9)
These
three
form
ulas
can
b
e
expressed
in
English
as
(8.7)
It's
alw
a
ys
the
case
that,
if
A
is
enabled
forev
er,
then
an
A
step
ev
en
tually
o
ccurs.
(8.8)
A
is
innitely
often
disabled,
or
innitely
man
y
A
steps
o
ccur.
(8.9)
If
A
is
ev
en
tually
enabled
forev
er,
then
innitely
man
y
A
steps
o
ccur.
The
equiv
alence
of
these
three
form
ulas
isn't
ob
vious.
T
rying
to
deduce
their
equiv
alence
from
the
English
expressions
often
leads
to
confusion.
The
b
est
w
a
y
to
a
v
oid
confusion
is
to
use
mathematics.
W
e
sho
w
that
the
three
form
ulas
are
equiv
alen
t
b
y
pro
ving
that
(8.7)
is
equiv
alen
t
to
(8.8)
and
that
(8.8)
is
equiv
alen
t
to
(8.9).
Instead
of
pro
ving
that
they
are
equiv
alen
t
for
an
individual
b
eha
vior,
w
e
can
use
tautologies
that
w
e'v
e
already
seen
to
pro
v
e
their
equiv
alence
directly
.
Here's
a
pro
of
that
(8.7)
is
equiv
alen
t
to
(8.8).
Studying
it
will
help
y
ou
learn
to
write
liv
eness
conditions.
2(2enabled
h
A
i
v
)
3h
A
i
v
)

2(:2enabled
h
A
i
v
_
3h
A
i
v
)
Because
(F
)
G
)

(:F
_
G
).

2(3:enabled
h
A
i
v
_
3h
A
i
v
)
Because
:2F

3:F
.

23(:enabled
h
A
i
v
_
h
A
i
v
)
Because
3F
_
3G

3(F
_
G
).

23(:enabled
h
A
i
v
)
_
23h
A
i
v
Because
23(F
_
G
)

23F
_
23G
.
The
equiv
alence
of
(8.8)
and
(8.9)
is
pro
v
ed
as
follo
ws:
23(:enabled
h
A
i
v
)
_
23h
A
i
v

:32(enabled
h
A
i
v
)
_
23h
A
i
v
Because
23:F

2:2F

:32F
.

32(enabled
h
A
i
v
)
)
23h
A
i
v
Because
(F
)
G
)

(:F
_
G
).
W
e
no
w
sho
w
that
the
liv
eness
conditions
for
the
hour
clo
c
k
and
the
c
hannel
can
b
e
written
as
w
eak
fairness
conditions.
First,
consider
the
hour
clo
c
k.
In
an
y
b
eha
vior
satisfying
HC
,
an
h
HCnxt
i
hr
step
is
alw
a
ys
enabled,
so
32(enabled
h
HCnxt
i
hr
)
equals
tr
ue.
Therefore,
HC
implies
that
WF
hr
(HCnxt
),
whic
h
equals
(8.9),
is
equiv
alen
t
to
form
ula
23h
HCnxt
i
hr
,
our
liv
eness
condition
for
the
hour
clo
c
k.

8.4.
WEAK
F
AIRNESS
99
No
w,
consider
the
c
hannel.
I
claim
that
the
liv
eness
condition
(8.6)
can
b
e
replaced
b
y
WF
chan
(R
cv
).
More
precisely
,
Sp
e
c
implies
that
these
t
w
o
form
ulas
are
equiv
alen
t,
so
conjoining
either
of
them
to
Sp
e
c
yields
equiv
alen
t
sp
ecica-
tions.
The
pro
of
rests
on
the
observ
ation
that,
in
an
y
b
eha
vior
satisfying
Sp
e
c
,
once
R
cv
b
ecomes
enabled
(b
ecause
a
v
alue
has
b
een
sen
t),
it
can
b
e
disabled
only
b
y
a
R
cv
step
(whic
h
receiv
es
the
v
alue).
In
other
w
ords,
it's
alw
a
ys
the
case
that
if
R
cv
is
enabled,
then
it
is
enabled
forev
er
or
a
R
cv
step
ev
en
tually
o
ccurs.
Stated
formally
,
this
observ
ation
asserts
that
Sp
e
c
implies
2
(
enabled
h
R
cv
i
chan
)
2(enabled
h
R
cv
i
chan
)
_
3h
R
cv
i
chan
)
(8.10)
W
e
sho
w
that
w
e
can
tak
e
WF
chan
(R
cv
)
as
our
liv
eness
condition
b
y
sho
wing
that
(8.10)
implies
the
equiv
alence
of
(8.6)
and
WF
chan
(R
cv
).
The
pro
of
is
b
y
purely
temp
oral
reasoning;
w
e
need
no
other
facts
ab
out
the
c
hannel
sp
ecication.
Both
for
compactness
and
to
emphasize
the
generalit
y
of
our
reasoning,
let's
replace
enabled
h
R
cv
i
chan
b
y
E
and
h
R
cv
i
chan
b
y
A.
Using
v
ersion
(8.7)
of
the
denition
of
WF,
w
e
m
ust
pro
v
e
2(E
)
2E
_
3A)
)
(2(E
)
3A)

2(2E
)
3A))
(8.11)
So
far,
all
our
pro
ofs
ha
v
e
b
een
b
y
calculation.
That
is,
w
e
ha
v
e
pro
v
ed
that
t
w
o
form
ulas
are
equiv
alen
t,
or
that
a
form
ula
is
equiv
alen
t
to
tr
ue,
b
y
pro
ving
a
c
hain
of
equiv
alences.
That's
a
go
o
d
w
a
y
to
pro
v
e
simple
things,
but
it's
usually
b
etter
to
tac
kle
a
complicated
form
ula
lik
e
(8.11)
b
y
splitting
its
pro
of
in
to
pieces.
W
e
ha
v
e
to
pro
v
e
that
one
form
ula
implies
the
equiv
alence
of
t
w
o
others.
The
equiv
alence
of
t
w
o
form
ulas
can
b
e
pro
v
ed
b
y
sho
wing
that
eac
h
implies
the
other.
More
generally
,
to
pro
v
e
that
P
implies
Q

R
,
w
e
pro
v
e
that
P
^
Q
implies
R
and
that
P
^
R
implies
Q
.
So,
w
e
pro
v
e
(8.11)
b
y
pro
ving
the
t
w
o
form
ulas
2(E
)
2E
_
3A)
^
2(E
)
3A)
)
2(2E
)
3A)
(8.12)
2(E
)
2E
_
3A)
^
2(2E
)
3A)
)
2(E
)
3A)
(8.13)
Both
(8.12)
and
(8.13)
ha
v
e
the
form
2F
^
2G
)
2H
.
W
e
rst
sho
w
that,
for
an
y
form
ulas
F
,
G
,
and
H
,
w
e
can
deduce
2F
^
2G
)
2H
b
y
pro
ving
F
^
G
)
H
.
W
e
do
this
b
y
assuming
F
^
G
)
H
and
pro
ving
2F
^
2G
)
2H
as
follo
ws:
1.
2(F
^
G
)
)
2H
Pr
oof:
By
the
assumption
F
^
G
)
H
and
the
Implies
Generalization
Rule
(page
95),
substituting
F
^
G
for
F
and
H
for
G
in
the
rule.
2.
2F
^
2G
)
2H
Pr
oof:
By
step
1
and
the
tautology
2(F
^
G
)

2F
^
2G
.

100
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
This
sho
ws
that
w
e
can
deduce
2F
^
2G
)
2H
b
y
pro
ving
F
^
G
)
H
,
for
an
y
F
,
G
,
and
H
.
W
e
can
therefore
pro
v
e
(8.12)
and
(8.13)
b
y
pro
ving
(E
)
2E
_
3A)
^
(E
)
3A)
)
(2E
)
3A)
(8.14)
(E
)
2E
_
3A)
^
(2E
)
3A)
)
(E
)
3A)
(8.15)
The
pro
of
of
(8.14)
is
easy
.
In
fact,
w
e
don't
ev
en
need
the
rst
conjunct;
w
e
can
pro
v
e
(E
)
3A)
)
(2E
)
3A)
as
follo
ws:
(E
)
3A)

(2E
)
E
)
^
(E
)
3A)
Because
2E
)
E
is
a
temp
oral
tautology
.
)
(2E
)
3A)
By
the
tautology
(P
)
Q
)
^
(Q
)
R
)
)
(P
)
R
).
The
pro
of
of
(8.15)
uses
only
prop
ositional
logic.
W
e
deduce
(8.15)
b
y
substi-
tuting
E
for
P
,
2E
for
Q
,
and
3A
for
R
in
the
follo
wing
prop
ositional-logic
tautology:
(P
)
Q
_
R
)
^
(Q
)
R
)
)
(P
)
R
)
A
little
though
t
should
mak
e
the
v
alidit
y
of
this
tautology
seem
ob
vious.
If
not,
y
ou
can
c
hec
k
it
b
y
constructing
a
truth
table.
These
pro
ofs
of
(8.14)
and
(8.15)
complete
the
pro
of
that
w
e
can
tak
e
WF
chan
(R
cv
)
instead
of
(8.7)
as
our
liv
eness
condition
for
the
c
hannel.
8.5
The
Memory
Sp
ecication
8.5.1
The
Liv
eness
Requiremen
t
Let's
no
w
strengthen
the
sp
ecication
of
the
linearizable
memory
of
Section
5.3
with
the
liv
eness
requiremen
t
that
ev
ery
request
m
ust
receiv
e
a
resp
onse.
(W
e
don't
require
that
a
request
ev
er
b
e
issued.)
The
liv
eness
requiremen
t
is
con-
joined
to
the
in
ternal
memory
sp
ecication,
form
ula
ISp
e
c
of
the
InternalMemory
mo
dule
(Figure
5.2
on
pages
52{53).
W
e
w
an
t
to
express
the
liv
eness
requiremen
t
in
terms
of
w
eak
fairness.
T
o
do
this,
w
e
m
ust
understand
when
actions
are
enabled.
The
action
Rsp
(p
)
is
enabled
only
if
the
action
R
eply
(p
;
buf
[p
];
memInt
;
memInt
0
)
(8.16)
is
enabled.
Recall
that
the
op
erator
R
eply
is
a
constan
t
parameter,
declared
in
the
MemoryInterfac
e
mo
dule
(Figure
5.1
on
page
48).
Without
kno
wing
more
ab
out
this
op
erator,
w
e
can't
sa
y
when
action
(8.16)
is
enabled.
Let's
assume
that
R
eply
actions
are
alw
a
ys
enabled.
That
is,
for
an
y
pro-
cessor
p
and
reply
r
,
and
an
y
old
v
alue
miOld
of
memInt
,
there
is
a
new
v
alue

8.5.
THE
MEMOR
Y
SPECIFICA
TION
101
miNew
of
memInt
suc
h
that
R
eply
(p
;
r
;
miOld
;
miNew
)
is
true.
F
or
simplicit
y
,
w
e
just
assume
that
this
is
true
for
all
p
and
r
,
and
add
the
follo
wing
assumption
to
the
MemoryInterfac
e
mo
dule:
assume
8
p
;
r
;
miOld
:
9
miNew
:
R
eply
(p
;
r
;
miOld
;
miNew
)
W
e
should
also
mak
e
a
similar
assumption
for
Send
,
but
w
e
don't
need
it
here.
W
e
will
subscript
our
w
eak
fairness
form
ulas
with
the
tuple
of
all
v
ariables,
so
let's
giv
e
that
tuple
a
name:
vars

=
h
memInt
;
mem
;
ctl
;
buf
i
When
pro
cessor
p
issues
a
request,
it
enables
the
Do
(p
)
action,
whic
h
remains
enabled
un
til
a
Do
(p
)
step
o
ccurs.
The
w
eak
fairness
condition
WF
vars
(Do
(p
))
implies
that
this
Do
(p
)
step
m
ust
ev
en
tually
o
ccur.
A
Do
(p
)
step
enables
the
Rsp
(p
)
action,
whic
h
remains
enabled
un
til
a
Rsp
(p
)
step
o
ccurs.
The
w
eak
fairness
condition
WF
vars
(Rsp
(p
))
implies
that
this
Rsp
(p
)
step,
whic
h
pro
duces
the
desired
resp
onse,
m
ust
ev
en
tually
o
ccur.
Hence,
the
requiremen
t
WF
vars
(Do
(p
))
^
WF
vars
(Rsp
(p
))
(8.17)
assures
that
ev
ery
request
issued
b
y
pro
cessor
p
m
ust
ev
en
tually
receiv
e
a
reply
.
W
e
w
an
t
this
condition
to
hold
for
ev
ery
pro
cessor
p
,
so
w
e
can
tak
e,
as
the
liv
eness
condition
for
the
memory
sp
ecication,
the
form
ula
Liveness

=
8
p
2
Pr
o
c
:
WF
vars
(Do
(p
))
^
WF
vars
(Rsp
(p
))
(8.18)
The
in
ternal
memory
sp
ecication
is
then
ISp
e
c
^
Liveness
.
8.5.2
Another
W
a
y
to
W
rite
It
I
nd
a
single
fairness
condition
simpler
than
the
conjunction
of
fairness
condi-
tions.
Seeing
the
conjunction
of
the
t
w
o
w
eak
fairness
form
ulas
in
the
denition
of
Liveness
leads
me
to
ask
if
it
can
b
e
replaced
b
y
a
single
w
eak
fairness
con-
dition
on
Do
(p
)
_
Rsp
(p
).
Suc
h
a
replacemen
t
isn't
alw
a
ys
p
ossible;
in
general,
the
form
ulas
WF
v
(A)
^
WF
v
(B
)
and
WF
v
(A
_
B
)
are
not
equiv
alen
t.
Ho
w
ev
er,
in
this
case,
w
e
can
replace
the
t
w
o
fairness
conditions
with
one.
If
w
e
dene
Liveness2

=
8
p
2
Pr
o
c
:
WF
vars
(Do
(p
)
_
Rsp
(p
))
(8.19)
then
ISp
e
c
^
Liveness2
is
equiv
alen
t
to
ISp
e
c
^
Liveness
.
As
w
e
will
see,
this
equiv
alence
holds
b
ecause
an
y
b
eha
vior
satisfying
ISp
e
c
satises
the
follo
wing
t
w
o
prop
erties:
DR1.
Whenev
er
Do
(p
)
is
enabled,
Rsp
(p
)
can
nev
er
b
ecome
enabled
unless
a
Do
(p
)
step
ev
en
tually
o
ccurs.

102
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
DR2.
Whenev
er
Rsp
(p
)
is
enabled,
Do
(p
)
can
nev
er
b
ecome
enabled
unless
a
Rsp
(p
)
step
ev
en
tually
o
ccurs.
These
prop
erties
are
satised
b
ecause
a
request
to
p
is
issued
b
y
a
R
e
q
(p
)
step,
executed
b
y
a
Do
(p
)
step,
and
resp
onded
to
b
y
a
Rsp
(p
)
step;
and
then,
the
next
request
to
p
can
b
e
issued
b
y
a
R
e
q
(p
)
step.
Eac
h
of
these
steps
b
ecomes
p
ossible
(the
action
enabled)
only
after
the
preceding
one
o
ccurs.
Let's
no
w
sho
w
that
DR1
and
DR2
imply
that
the
conjunction
of
w
eak
fairness
of
Do
(p
)
and
of
Rsp
(p
)
is
equiv
alen
t
to
w
eak
fairness
of
Do
(p
)
_
Rsp
(p
).
F
or
compactness,
and
to
emphasize
the
generalit
y
of
what
w
e're
doing,
let's
replace
Do
(p
),
Rsp
(p
),
and
vars
b
y
A,
B
,
and
v
,
resp
ectiv
ely
.
First,
w
e
m
ust
restate
DR1
and
DR2
as
temp
oral
form
ulas.
The
basic
form
of
DR1
and
DR2
is
Whenev
er
F
is
true,
G
can
nev
er
b
e
true
unless
H
is
ev
en
tually
true.
This
is
expressed
in
temp
oral
logic
as
2(F
)
2:G
_
3H
).
(The
assertion
\P
unless
Q
"
just
means
P
_
Q
.)
Adding
suitable
subscripts,
w
e
can
therefore
write
DR1
and
DR2
in
temp
oral
logic
as
DR1

=
2
(
enabled
h
A
i
v
)
2
:
enabled
h
B
i
v
_
3h
A
i
v
)
DR2

=
2
(
enabled
h
B
i
v
)
2
:
enabled
h
A
i
v
_
3h
B
i
v
)
Our
goal
is
to
pro
v
e
DR1
^
DR2
)
(
WF
v
(A)
^
WF
v
(B
)

WF
v
(A
_
B
)
)
(8.20)
This
is
complicated,
so
w
e
split
the
pro
of
in
to
pieces.
As
in
the
pro
of
of
(8.11)
in
Section
8.4
ab
o
v
e,
w
e
pro
v
e
an
equiv
alence
b
y
pro
ving
t
w
o
implications.
T
o
pro
v
e
(8.20),
w
e
pro
v
e
the
t
w
o
theorems
DR1
^
DR2
^
WF
v
(A)
^
WF
v
(B
)
)
WF
v
(A
_
B
)
DR1
^
DR2
^
WF
v
(A
_
B
)
)
WF
v
(A)
^
WF
v
(B
)
W
e
pro
v
e
them
b
y
sho
wing
that
they
are
true
for
an
arbitrary
b
eha
vior

.
In
other
w
ords,
w
e
pro
v
e
(
j
=
DR1
^
DR2
^
WF
v
(A)
^
WF
v
(B
))
)
(
j
=
WF
v
(A
_
B
))
(8.21)
(
j
=
DR1
^
DR2
^
WF
v
(A
_
B
))
)
(
j
=
WF
v
(A)
^
WF
v
(B
))
(8.22)
These
form
ulas
seem
daun
ting.
Whenev
er
y
ou
ha
v
e
trouble
pro
ving
something,
try
a
pro
of
b
y
con
tradiction;
it
giv
es
y
ou
an
extra
h
yp
othesis
for
free|namely
,
the
negation
of
what
y
ou're
trying
to
pro
v
e.
Pro
ofs
b
y
con
tradiction
are
esp
e-
cially
useful
in
temp
oral
logic.
T
o
pro
v
e
(8.21)
and
(8.22)
b
y
con
tradiction,
w
e
need
to
compute
:(
j
=
WF
v
(C
))
for
an
action
C
.
F
rom
the
denition
(8.7)
of
WF
,
w
e
easily
get
(
j
=
WF
v
(C
))

8
n
2
Nat
:
(
+n
j
=
2
enabled
h
C
i
v
)
)
(
+n
j
=
3h
C
i
v
)
(8.23)

8.5.
THE
MEMOR
Y
SPECIFICA
TION
103
This
and
the
tautology
:(8
x
2
S
:
P
)
Q
)

(9
x
2
S
:
P
^
:Q
)
of
predicate
logic
yields
:(
j
=
WF
v
(C
))

9
n
2
Nat
:
(
+n
j
=
2
enabled
h
C
i
v
)
^
:(
+n
j
=
3h
C
i
v
)
(8.24)
W
e
also
need
t
w
o
further
results,
b
oth
of
whic
h
are
deriv
ed
from
the
tautology
h
A
_
B
i
v

h
A
i
v
_
h
B
i
v
.
Com
bining
this
tautology
with
the
temp
oral
tautology
3(F
_
G
)

3F
_
3G
yields
3h
A
_
B
i
v

3h
A
i
v
_
3h
B
i
v
(8.25)
Com
bining
the
tautology
with
the
observ
ation
that
an
action
C
_
D
is
enabled
i
action
C
or
action
D
is
enabled
yields
enabled
h
A
_
B
i
v

enabled
h
A
i
v
_
enabled
h
B
i
v
(8.26)
W
e
can
no
w
pro
v
e
(8.21)
and
(8.22).
T
o
pro
v
e
(8.21),
w
e
assume
that

satises
DR1,
DR2
,
WF
v
(A),
and
WF
v
(B
),
but
it
do
es
not
satisfy
WF
v
(A
_
B
),
and
w
e
obtain
a
con
tradiction.
By
(8.24),
the
assumption
that

do
es
not
satisfy
WF
v
(A
_
B
)
means
that
there
exists
some
n
um
b
er
n
suc
h
that

+n
j
=
2
enabled
h
A
_
B
i
v
(8.27)
:(
+n
j
=
3h
A
_
B
i
v
)
(8.28)
W
e
obtain
a
con
tradiction
from
(8.27)
and
(8.28)
as
follo
ws:
1.
:(
+n
j
=
3h
A
i
v
)
^
:(
+n
j
=
3h
B
i
v
)
Pr
oof:
By
(8.28)
and
(8.25),
using
the
tautology
:(P
_
Q
)

(:P
^
:Q
).
2.
(a)
(
+n
j
=
enabled
h
A
i
v
)
)
(
+n
j
=
2
:enabled
h
B
i
v
)
(b)
(
+n
j
=
enabled
h
B
i
v
)
)
(
+n
j
=
2
:
enabled
h
A
i
v
)
Pr
oof:
By
denition
of
DR1,
the
assumption

j
=
DR1
implies
(
+n
j
=
enabled
h
A
i
v
)
)
(
+n
j
=
2
:
enabled
h
B
i
v
)
_
(
+n
j
=
3h
A
i
v
)
and
part
(a)
then
follo
ws
from
1.
The
pro
of
of
(b)
is
similar.
3.
(a
)
(
+n
j
=
enabled
h
A
i
v
)
)
(
+n
j
=
2
enabled
h
A
i
v
)
(b)
(
+n
j
=
enabled
h
B
i
v
)
)
(
+n
j
=
2
enabled
h
B
i
v
)
Pr
oof:
P
art
(a)
follo
ws
from
2(a),
(8.27),
(8.26),
and
the
temp
oral
tautology
2(F
_
G
)
^
2:G
)
2F
The
pro
of
of
part
(b)
is
similar.

104
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
4.
(a
)
(
+n
j
=
enabled
h
A
i
v
)
)
(
+n
j
=
3h
A
i
v
)
(b)
(
+n
j
=
enabled
h
B
i
v
)
)
(
+n
j
=
3h
B
i
v
)
Pr
oof:
The
assumption

j
=
WF
v
(A)
and
(8.23)
imply
(
+n
j
=
2enabled
h
A
i
v
)
)
(
+n
j
=
3h
A
i
v
)
P
art
(a)
follo
ws
from
this
and
3(a).
The
pro
of
of
part
(b)
is
similar.
5.
(
+n
j
=
3h
A
i
v
)
_
(
+n
j
=
3h
B
i
v
)
Pr
oof:
Since
2F
implies
F
,
for
an
y
F
,
(8.27)
and
(8.26)
imply
(
+n
j
=
enabled
h
A
i
v
)
_
(
+n
j
=
enabled
h
B
i
v
)
Step
5
then
follo
ws
b
y
prop
ositional
logic
from
step
4.
Steps
1
and
5
pro
vide
the
required
con
tradiction.
W
e
can
pro
v
e
(8.22)
b
y
assuming
that

satises
DR1,
DR2
,
and
WF
v
(A
_
B
),
and
then
pro
ving
that
it
satises
WF
v
(A)
and
WF
v
(B
).
W
e
pro
v
e
only
that
it
satises
WF
v
(A);
the
pro
of
for
WF
v
(B
)
is
similar.
The
pro
of
is
b
y
con
tradiction;
w
e
assume
that

do
es
not
satisfy
WF
v
(A)
and
obtain
a
con
tradiction.
By
(8.24),
the
assumption
that

do
es
not
satisfy
WF
v
(A)
means
that
there
exists
some
n
um
b
er
n
suc
h
that

+n
j
=
2
enabled
h
A
i
v
(8.29)
:
(
+n
j
=
3h
A
i
v
)
(8.30)
W
e
obtain
the
con
tradiction
as
follo
ws:
1.

+n
j
=
3h
A
_
B
i
v
Pr
oof:
F
rom
(8.29)
and
(8.26)
w
e
deduce

+n
j
=
2
enabled
h
A
_
B
i
v
.
By
the
assumption

j
=
WF
v
(A
_
B
)
and
(8.23),
this
implies

+n
j
=
3h
A
_
B
i
v
.
2.

+n
j
=
2
:
enabled
h
B
i
v
Pr
oof:
F
rom
(8.29)
w
e
deduce

+n
j
=
enabled
h
A
i
v
,
whic
h
b
y
the
assump-
tion

j
=
DR1
and
the
denition
of
DR1
implies
(
+n
j
=
2
:
enabled
h
B
i
v
)
_
(
+n
j
=
3h
A
i
v
)
The
assumption
(8.30)
then
implies

+n
j
=
2
:
enabled
h
B
i
v
.
3.
:
(
+n
j
=
3h
B
i
v
)
Pr
oof:
The
denition
of
enabled
implies
:
enabled
h
B
i
v
)
:
h
B
i
v
.
(A
h
B
i
v
step
can
o
ccur
only
when
it
is
enabled.)
F
rom
this,
simple
temp
oral
reasoning
implies
(
+n
j
=
2
:
enabled
h
B
i
v
)
)
:
(
+n
j
=
3h
B
i
v
)
(A
formal
pro
of
uses
the
Implies
Generalization
Rule
and
the
tautology
2:F

:3F
.)
W
e
then
deduce
:
(
+n
j
=
3h
B
i
v
)
from
2.
4.
:
(
+n
j
=
3h
A
_
B
i
v
)
Pr
oof:
By
(8.30),
3,
and
(8.25),
using
the
tautology
:P
^
:Q

:(P
_
Q
).

8.5.
THE
MEMOR
Y
SPECIFICA
TION
105
Steps
1
and
4
pro
vide
the
necessary
con
tradiction.
This
completes
our
pro
of
of
(8.22),
whic
h
completes
our
pro
of
of
(8.20).
8.5.3
A
Generalization
F
orm
ula
(8.20)
pro
vides
a
rule
for
replacing
the
conjunction
of
w
eak
fairness
requiremen
ts
on
t
w
o
actions
with
w
eak
fairness
of
their
disjunction.
W
e
no
w
generalize
it
from
t
w
o
actions
A
and
B
to
n
actions
A
1
,
.
.
.
,
A
n
.
The
general-
ization
of
DR1
and
DR2
is
DR
(i
;
j
)

=
2
(
enabled
h
A
i
i
v
)
2
:
enabled
h
A
j
i
v
_
3h
A
i
i
v
)
If
w
e
substitute
A
1
for
A
and
A
2
for
B
,
then
DR1
b
ecomes
DR
(1;
2)
and
DR2
b
ecomes
DR
(2;
1).
The
generalization
of
(8.20)
is
(8
i
;
j
2
1
:
:
n
:
(i
6=
j
)
)
DR
(i
;
j
))
)
(WF
v
(A
1
)
^
:
:
:
^
WF
v
(A
n
)

WF
v
(A
1
_
:
:
:
_
A
n
))
(8.31)
T
o
decide
if
y
ou
can
replace
the
conjunction
of
w
eak
fairness
conditions
b
y
a
single
one
in
a
sp
ecication,
y
ou
will
probably
nd
it
easier
to
use
the
follo
wing
informal
statemen
t
of
(8.31):
WF
Conjunction
Rule
If
A
1
,
.
.
.
,
A
n
are
actions
suc
h
that,
for
an
y
distinct
i
and
j
,
whenev
er
h
A
i
i
v
is
enabled,
h
A
j
i
v
cannot
b
ecome
en-
abled
unless
an
h
A
i
i
v
step
o
ccurs,
then
WF
v
(A
1
)
^
:
:
:
^
WF
v
(A
n
)
is
equiv
alen
t
to
WF
v
(A
1
_
:
:
:
_
A
n
).
P
erhaps
the
b
est
w
a
y
to
think
of
this
rule
is
as
an
assertion
ab
out
an
arbitrary
individual
b
eha
vior

.
Its
h
yp
othesis
is
then
that

j
=
DR
(i
;
j
)
holds
for
all
distinct
i
and
j
;
its
conclusion
is

j
=
(WF
v
(A
1
)
^
:
:
:
^
WF
v
(A
n
)

WF
v
(A
1
_
:
:
:
_
A
n
))
T
o
replace
WF
v
(A
1
)
^
:
:
:
^
WF
v
(A
n
)
b
y
WF
v
(A
1
_
:
:
:
_
A
n
)
in
a
sp
ecication,
y
ou
ha
v
e
to
c
hec
k
that
an
y
b
eha
vior
satisfying
the
safet
y
part
of
the
sp
ecication
also
satises
DR
(i
;
j
),
for
all
distinct
i
and
j
.
Conjunction
and
disjunction
are
sp
ecial
cases
of
quan
tication:
F
1
_
:
:
:
_
F
n

9
i
2
1
:
:
n
:
F
i
F
1
^
:
:
:
^
F
n

8
i
2
1
:
:
n
:
F
i
W
e
can
therefore
easily
restate
the
WF
Conjunction
Rule
as
a
condition
on
when
8
i
2
S
:
WF
v
(A
i
)
and
WF
v
(9
i
2
S
:
A
i
)
are
equiv
alen
t,
for
a
nite
set
S
.
The
resulting
rule
is
actually
v
alid
for
an
y
set
S
:
WF
Quan
tier
Rule
If,
for
all
i
2
S
,
the
A
i
are
actions
suc
h
that,
for
an
y
distinct
i
and
j
in
S
,
whenev
er
h
A
i
i
v
is
enabled,
h
A
j
i
v
cannot
b
ecome
enabled
unless
an
h
A
i
i
v
step
o
ccurs,
then
8
i
2
S
:
WF
v
(A
i
)
is
equiv
alen
t
to
WF
v
(9
i
2
S
:
A
i
).

106
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
8.6
Strong
F
airness
W
e
dene
SF
v
(A),
str
ong
fairness
of
action
A,
to
b
e
either
of
the
follo
wing
t
w
o
equiv
alen
t
form
ulas:
32(:
enabled
h
A
i
v
)
_
23h
A
i
v
(8.32)
23enabled
h
A
i
v
)
23h
A
i
v
(8.33)
In
tuitiv
ely
,
these
t
w
o
form
ulas
assert
A
is
ev
en
tually
disabled
forev
er,
or
innitely
man
y
A
steps
o
ccur.
(8.32)
If
A
is
innitely
often
enabled,
then
innitely
man
y
A
steps
o
ccur.
(8.33)
The
pro
of
that
(8.32)
and
(8.33)
are
equiv
alen
t
is
similar
to
the
pro
of
on
page
98
that
the
t
w
o
form
ulations
(8:8)
and
(8:9)
of
WF
v
(A)
are
equiv
alen
t.
Denition
(8.32)
of
SF
v
(A)
is
obtained
from
denition
(8.8)
of
WF
v
(A)
b
y
replacing
23(:
enabled
h
A
i
v
)
with
32(:
enabled
h
A
i
v
).
Since
32F
(ev
en-
tually
alw
a
ys
F
)
is
stronger
than
(implies)
23F
(innitely
often
F
)
for
an
y
form
ula
F
,
strong
fairness
is
stronger
than
w
eak
fairness.
W
e
can
express
w
eak
and
strong
fairness
as
follo
ws:

W
eak
fairness
of
A
asserts
that
an
A
step
m
ust
ev
en
tually
o
ccur
if
A
is
c
ontinuously
enabled.

Strong
fairness
of
A
asserts
that
an
A
step
m
ust
ev
en
tually
o
ccur
if
A
is
c
ontinual
ly
enabled.
Continuously
means
without
in
terruption.
Continual
ly
means
rep
eatedly
,
p
os-
sibly
with
in
terruptions.
Strong
fairness
need
not
b
e
strictly
stronger
than
w
eak
fairness.
W
eak
and
strong
fairness
of
an
action
A
are
equiv
alen
t
i
A
innitely
often
disabled
implies
that
either
A
ev
en
tually
b
ecomes
forev
er
disabled,
or
else
innitely
man
y
A
steps
o
ccur.
This
is
expressed
formally
b
y
the
tautology
(WF
v
(A)

SF
v
(A))

(
23(:
enabled
h
A
i
v
)
)
32(:
enabled
h
A
i
v
)
_
23h
A
i
v
)
In
the
c
hannel
example,
w
eak
and
strong
fairness
of
R
cv
are
equiv
alen
t
b
ecause
Sp
e
c
implies
that,
once
enabled,
R
cv
can
b
e
disabled
only
b
y
a
R
cv
step.
Hence,
if
R
cv
is
disabled
innitely
often,
then
it
either
ev
en
tually
remains
disabled
forev
er,
or
else
it
is
disabled
innitely
often
b
y
R
cv
steps.
The
analogs
of
the
WF
Conjunction
and
WF
Quan
tier
Rules
(page
105)
hold
for
strong
fairness|for
example:
SF
Conjunction
Rule
If
A
1
,
.
.
.
,
A
n
are
actions
suc
h
that,
for
an
y
distinct
i
and
j
,
whenev
er
action
A
i
is
enabled,
action
A
j
cannot
b
e-
come
enabled
un
til
an
A
i
step
o
ccurs,
then
SF
v
(A
1
)
^
:
:
:
^
SF
v
(A
n
)
is
equiv
alen
t
to
SF
v
(A
1
_
:
:
:
_
A
n
)
.

8.7.
THE
WRITE-THR
OUGH
CA
CHE
107
Strong
fairness
can
b
e
more
dicult
to
implemen
t
than
w
eak
fairness,
and
it
is
a
less
common
requiremen
t.
A
strong
fairness
condition
should
b
e
used
in
a
sp
ecication
only
if
it
is
needed.
When
strong
and
w
eak
fairness
are
equiv
alen
t,
the
fairness
prop
ert
y
should
b
e
written
as
w
eak
fairness.
Liv
eness
prop
erties
can
b
e
subtle.
Expressing
them
with
ad
ho
c
temp
oral
form
ulas
can
lead
to
errors.
W
e
will
sp
ecify
liv
eness
as
the
conjunction
of
w
eak
and/or
strong
fairness
prop
erties
whenev
er
p
ossible|and
it
almost
alw
a
ys
is
p
ossible.
Ha
ving
a
uniform
w
a
y
of
expressing
liv
eness
mak
es
sp
ecications
easier
to
understand.
Section
8.9.2
b
elo
w
discusses
an
ev
en
more
comp
elling
reason
for
using
fairness
to
sp
ecify
liv
eness.
8.7
The
W
rite-Through
Cac
he
Let's
no
w
add
liv
eness
to
the
write-through
cac
he,
sp
ecied
in
Figure
5.5
on
pages
57{59.
W
e
w
an
t
our
sp
ecication
to
guaran
tee
that
ev
ery
request
ev
en-
tually
receiv
es
a
resp
onse,
without
requiring
that
an
y
requests
are
issued.
This
requires
fairness
on
all
the
actions
that
mak
e
up
the
next-state
action
Next
except
for
the
follo
wing:

A
R
e
q
(p
)
action,
whic
h
issues
a
request.

An
Evict
(p
;
a
)
action,
whic
h
evicts
an
address
from
the
cac
he.

A
MemQWr
action,
if
memQ
con
tains
only
write
requests
and
is
not
full
(has
few
er
than
QL
en
elemen
ts).
Since
a
resp
onse
to
a
write
request
can
b
e
issued
b
efore
the
v
alue
is
written
to
memory
,
failing
to
execute
a
MemQWr
action
can
prev
en
t
a
resp
onse
only
if
it
prev
en
ts
the
dequeuing
of
a
read
op
eration
in
memQ
or
the
enqueuing
of
an
op
eration
(b
ecause
memQ
is
full).
F
or
simplicit
y
,
let's
require
fairness
for
the
MemQWr
action
to
o;
w
e'll
w
eak
en
this
requiremen
t
later.
Our
liv
eness
condition
then
has
to
assert
fairness
of
the
actions
MemQWr
MemQR
d
Rsp
(p
)
R
dMiss
(p
)
DoR
d
(p
)
DoWr
(p
)
for
all
p
in
Pr
o
c
.
W
e
no
w
m
ust
decide
whether
to
assert
w
eak
or
strong
fairness
for
these
actions.
W
eak
and
strong
fairness
are
equiv
alen
t
for
an
action
that,
once
enabled,
remains
enabled
un
til
it
is
executed.
This
is
the
case
for
all
of
these
actions
except
DoR
d
(p
),
R
dMiss
(p
),
and
DoWr
(p
).
The
DoR
d
(p
)
action
can
b
e
disabled
b
y
an
Evict
step
that
evicts
the
re-
quested
data
from
the
cac
he.
In
this
case,
fairness
of
other
actions
should
imply
that
the
data
will
ev
en
tually
b
e
returned
to
the
cac
he,
re-enabling
DoR
d
(p
).

108
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
The
data
cannot
b
e
evicted
again
un
til
the
DoR
d
(p
)
action
is
executed,
and
w
eak
fairness
then
suces
to
ensure
that
the
necessary
DoR
d
(p
)
step
ev
en
tually
o
ccurs.
The
R
dMiss
(p
)
and
DoWr
(p
)
actions
app
end
a
request
to
the
memQ
queue.
They
are
disabled
if
that
queue
is
full.
A
R
dMiss
(p
)
or
DoWr
(p
)
could
b
e
enabled
and
then
b
ecome
disabled
b
ecause
a
R
dMiss
(q
)
or
DoWr
(q
),
for
a
dieren
t
pro
cessor
q
,
app
ends
a
request
to
memQ
.
W
e
therefore
need
strong
fairness
for
the
R
dMiss
(p
)
and
DoWr
(p
)
actions.
So,
the
fairness
conditions
w
e
need
are
W
eak
F
airness
for
Rsp
(p
),
DoR
d
(p
),
MemQWr
,
and
MemQR
d
Strong
F
airness
for
R
dMiss
(p
)
and
DoWr
(p
).
As
b
efore,
let's
dene
vars
to
b
e
the
tuple
of
all
v
ariables.
vars

=
h
memInt
;
wmem
;
buf
;
ctl
;
c
ache
;
memQ
i
W
e
could
just
write
the
liv
eness
condition
as
^
8
p
2
Pr
o
c
:
^
WF
vars
(Rsp
(p
))
^
WF
vars
(DoR
d
(p
))
^
SF
vars
(R
dMiss
(p
))
^
SF
vars
(DoWr
(p
))
^
WF
vars
(MemQWr
)
^
WF
vars
(MemQR
d
)
(8.34)
Ho
w
ev
er,
I
prefer
replacing
the
conjunction
of
fairness
conditions
b
y
a
single
fairness
condition
on
a
disjunction,
as
w
e
did
in
Section
8.5
for
the
memory
sp
ecication.
The
WF
and
SF
Conjunction
Rules
(pages
105
and
106)
imply
that
the
liv
eness
condition
(8.34)
can
b
e
rewritten
as
^
8
p
2
Pr
o
c
:
^
WF
vars
(Rsp
(p
)
_
DoR
d
(p
))
^
SF
vars
(R
dMiss
(p
)
_
DoWr
(p
))
^
WF
vars
(MemQWr
_
MemQR
d
)
(8.35)
W
e
can
no
w
try
to
simplify
(8.35)
b
y
mo
ving
the
quan
tier
inside
the
WF
and
SF
form
ulas.
First,
b
ecause
8
distributes
o
v
er
^,
w
e
can
rewrite
the
rst
conjunct
of
(8.35)
as
^
8
p
2
Pr
o
c
:
WF
vars
(Rsp
(p
)
_
DoR
d
(p
))
^
8
p
2
Pr
o
c
:
SF
vars
(R
dMiss
(p
)
_
DoWr
(p
))
(8.36)
W
e
can
no
w
try
to
apply
the
WF
Quan
tier
Rule
(page
105)
to
the
rst
con-
junct
of
(8.36)
and
the
corresp
onding
SF
Quan
tier
Rule
to
its
second
conjunct.
Ho
w
ev
er,
the
WF
quan
tier
rule
do
esn't
apply
to
the
rst
conjunct.
It's
p
ossible
for
b
oth
Rsp
(p
)
_
DoR
d
(p
)
and
Rsp
(q
)
_
DoR
d
(q
)
to
b
e
enabled
at
the
same
time,
for
t
w
o
dieren
t
pro
cessors
p
and
q
.
The
form
ula

8.8.
QUANTIFICA
TION
109
WF
vars
(9
p
2
Pr
o
c
:
Rsp
(p
)
_
DoR
d
(p
))
(8.37)
is
satised
b
y
an
y
b
eha
vior
in
whic
h
innitely
man
y
Rsp
(p
)
and
DoR
d
(p
)
ac-
tions
o
ccur
for
some
pro
cessor
p
.
In
suc
h
a
b
eha
vior,
Rsp
(q
)
could
b
e
en-
abled
for
some
other
pro
cessor
q
without
an
Rsp
(q
)
step
ev
er
o
ccurring,
making
WF
vars
(Rsp
(q
)
_
DoR
d
(q
))
false,
whic
h
implies
that
the
rst
conjunct
of
(8.36)
is
false.
Hence,
(8.37)
is
not
equiv
alen
t
to
the
rst
conjunct
of
(8.36).
Similarly
,
the
analogous
rule
for
strong
fairness
cannot
b
e
applied
to
the
second
conjunct
of
(8.36).
F
orm
ula
(8.35)
is
as
simple
as
w
e
can
mak
e
it.
Let's
return
to
the
observ
ation
that
w
e
don't
ha
v
e
to
execute
MemQWr
if
the
memQ
queue
con
tains
only
write
requests
and
is
not
full.
In
other
w
ords,
w
e
ha
v
e
to
execute
MemQWr
only
if
memQ
is
full
or
con
tains
a
read
request.
Let's
dene
QCond

=
_
L
en
(memQ
)
=
QL
en
_
9
i
2
1
:
:
L
en
(memQ
)
:
memQ
[i
][2]:op
=
\Rd"
so
w
e
need
ev
en
tually
execute
a
MemQWr
action
only
when
it's
enabled
and
QCond
is
true,
whic
h
is
the
case
i
the
action
QCond
^
MemQWr
is
enabled.
In
this
case,
a
MemQWr
step
is
a
QCond
^
MemQWr
step.
Hence,
it
suces
to
require
w
eak
fairness
of
the
action
QCond
^
MemQWr
.
W
e
can
therefore
replace
the
second
conjunct
of
(8.35)
with
WF
vars
((QCond
^
MemQWr
)
_
MemQR
d
)
W
e
w
ould
do
this
if
w
e
w
an
ted
the
sp
ecication
to
describ
e
the
w
eak
est
liv
eness
condition
that
implemen
ts
the
memory
sp
ecication's
liv
eness
condition.
Ho
w-
ev
er,
if
the
sp
ecication
w
ere
a
description
of
an
actual
device,
then
that
device
w
ould
probably
implemen
t
w
eak
fairness
on
all
MemQWr
actions,
so
w
e
w
ould
tak
e
(8.35)
as
the
liv
eness
condition.
8.8
Quan
tication
Section
8.1
describ
es
the
meaning
of
ordinary
quan
tication
of
temp
oral
form
u-
las.
F
or
example,
the
meaning
of
the
form
ula
8
r
:
F
,
for
an
y
temp
oral
form
ula
F
,
is
dened
b
y

j
=
(8
r
:
F
)

=
8
r
:
(
j
=
F
)
where

is
an
y
b
eha
vior.
The
sym
b
ol
r
in
9
r
:
F
is
usually
called
a
b
ound
v
ariable.
But
w
e'v
e
b
een
using
the
term
variable
to
mean
something
else|something
that's
declared
b
y
a
v
ariable
statemen
t
in
a
mo
dule.
The
b
ound
\v
ariable"
r
is
actually
a
constan
t

110
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
in
these
form
ulas|a
v
alue
that
is
the
same
in
ev
ery
state
of
the
b
eha
vior.
5
F
or
example,
the
form
ula
9
r
:
2(x
=
r
)
asserts
that
x
has
the
same
v
alue
in
ev
ery
state
of
a
b
eha
vior.
Bounded
quan
tication
o
v
er
a
constan
t
set
S
is
dened
b
y

j
=
(8
r
2
S
:
F
)

=
(8
r
2
S
:

j
=
F
)

j
=
(9
r
2
S
:
F
)

=
(9
r
2
S
:

j
=
F
)
The
sym
b
ol
r
is
declared
to
b
e
a
constan
t
in
form
ula
F
.
The
expression
S
lies
outside
the
scop
e
of
the
declaration
of
r
,
so
the
sym
b
ol
r
cannot
o
ccur
in
S
.
It's
easy
to
dene
the
meanings
of
these
form
ulas
ev
en
if
S
is
not
a
constan
t|for
example,
b
y
letting
9
r
2
S
:
F
equal
9
r
:
(r
2
S
)
^
F
.
Ho
w
ev
er,
for
nonconstan
t
S
,
it's
b
etter
to
write
9
r
:
(r
2
S
)
^
F
explicitly
.
It's
also
easy
to
dene
the
meaning
of
choose
as
a
temp
oral
op
erator.
W
e
can
just
let

j
=
(choose
r
:
F
)
b
e
an
arbitrary
constan
t
v
alue
r
suc
h
that

j
=
F
equals
tr
ue,
if
suc
h
an
r
exists.
Ho
w
ev
er,
a
temp
oral
choose
op
erator
is
not
needed
for
writing
sp
ecications,
so
choose
r
:
F
is
not
a
legal
TLA
+
form
ula
if
F
is
a
temp
oral
form
ula.
W
e
no
w
come
to
the
temp
oral
existen
tial
quan
tier
9
9
9
9
9
9
.
In
the
form
ula
9
9
9
9
9
9
x
:
F
,
the
sym
b
ol
x
is
declared
to
b
e
a
v
ariable
in
F
.
Unlik
e
9
r
:
F
,
whic
h
asserts
the
existence
of
a
single
v
alue
r
,
the
form
ula
9
9
9
9
9
9
x
:
F
asserts
the
existence
of
a
v
alue
for
x
in
eac
h
state
of
a
b
eha
vior.
F
or
example,
if
y
is
a
v
ariable,
then
the
form
ula
9
9
9
9
9
9
x
:
2(x
2
y
)
asserts
that
y
alw
a
ys
has
some
elemen
t
x
,
so
y
is
alw
a
ys
a
nonempt
y
set.
Ho
w
ev
er,
the
elemen
t
x
could
b
e
dieren
t
in
dieren
t
states,
so
the
v
alues
of
y
in
dieren
t
states
could
b
e
disjoin
t.
W
e
ha
v
e
b
een
using
9
9
9
9
9
9
as
a
hiding
op
erator,
thinking
of
9
9
9
9
9
9
x
:
F
as
F
with
v
ariable
x
hidden.
The
precise
denition
of
9
9
9
9
9
9
is
a
bit
tric
ky
b
ecause,
as
dis-
cussed
in
Section
8.1,
the
form
ula
9
9
9
9
9
9
x
:
F
should
b
e
in
v
arian
t
under
stuttering.
In
tuitiv
ely
,
9
9
9
9
9
9
x
:
F
is
satised
b
y
a
b
eha
vior

i
F
is
satised
b
y
a
b
eha
vior

that
is
obtained
from

b
y
adding
and/or
deleting
stuttering
steps
and
c
hang-
ing
the
v
alue
of
x
.
A
precise
denition
app
ears
in
Section
16.2.4
(page
314).
Ho
w
ev
er,
for
writing
sp
ecications,
y
ou
can
simply
think
of
9
9
9
9
9
9
x
:
F
as
F
with
x
hidden.
TLA
also
has
a
temp
oral
univ
ersal
quan
tier
8
8
8
8
8
8
,
dened
b
y
8
8
8
8
8
8
x
:
F

=
:
9
9
9
9
9
9
x
:
:F
This
op
erator
is
hardly
ev
er
used.
TLA
+
do
es
not
allo
w
b
ounded
v
ersions
of
the
op
erators
9
9
9
9
9
9
and
8
8
8
8
8
8
.
5
Logicians
use
the
term
exible
variable
for
a
TLA
v
ariable,
and
the
term
rigid
variable
for
a
sym
b
ol
lik
e
r
that
represen
ts
a
constan
t.

8.9.
TEMPORAL
LOGIC
EXAMINED
111
8.9
T
emp
oral
Logic
Examined
8.9.1
A
Review
Let's
lo
ok
at
the
shap
es
of
the
sp
ecications
that
w
e'v
e
written
so
far.
W
e
started
with
the
simple
form
Init
^
2[Next
]
vars
(8.38)
where
Init
is
the
initial
predicate,
Next
the
next-state
action,
and
vars
the
tuple
of
all
v
ariables.
This
kind
of
sp
ecication
is,
in
principle,
quite
straigh
tforw
ard.
W
e
then
in
tro
duced
hiding,
using
9
9
9
9
9
9
to
bind
v
ariables
that
should
not
app
ear
in
the
sp
ecication.
Those
b
ound
v
ariables,
also
called
hidden
or
internal
v
ariables,
serv
e
only
to
help
describ
e
ho
w
the
v
alues
of
the
free
v
ariables
(also
called
visible
v
ariables)
c
hange.
Hiding
v
ariables
is
easy
enough,
and
it
is
mathematically
elegan
t
and
philo-
sophically
satisfying.
Ho
w
ev
er,
in
practice,
it
do
esn't
mak
e
m
uc
h
dierence
to
a
sp
ecication.
A
commen
t
can
also
tell
a
reader
that
a
v
ariable
should
b
e
re-
garded
as
in
ternal.
Explicit
hiding
allo
ws
implemen
tation
to
mean
implication.
A
lo
w
er-lev
el
sp
ecication
that
describ
es
an
implemen
tation
can
b
e
exp
ected
to
imply
a
higher-lev
el
sp
ecication
only
if
the
higher-lev
el
sp
ecication's
in
ternal
v
ariables,
whose
v
alues
don't
really
matter,
are
explicitly
hidden.
Otherwise,
implemen
tation
means
implemen
tation
under
a
renemen
t
mapping.
(See
Sec-
tion
5.8.)
Ho
w
ev
er,
as
explained
in
Section
10.8
b
elo
w,
implemen
tation
often
in
v
olv
es
a
renemen
t
of
the
visible
v
ariables
as
w
ell.
T
o
express
liv
eness,
the
sp
ecication
(8.38)
is
strengthened
to
the
form
Init
^
2[Next
]
vars
^
Liveness
(8.39)
where
Liveness
is
the
conjunction
of
form
ulas
of
the
form
WF
vars
(A)
and/or
SF
vars
(A),
for
actions
A.
(I'm
considering
univ
ersal
quan
tication
to
b
e
a
form
of
conjunction.)
8.9.2
Mac
hine
Closure
In
the
sp
ecications
of
the
form
(8.39)
w
e'v
e
written
so
far,
the
actions
A
whose
fairness
prop
erties
app
ear
in
form
ula
Liveness
ha
v
e
one
thing
in
common:
they
are
all
sub
actions
of
the
next-state
action
Next
.
An
action
A
is
a
subaction
of
Next
i
ev
ery
A
step
is
a
Next
step.
Equiv
alen
tly
,
A
is
a
subaction
of
Next
i
A
implies
Next
.
6
In
almost
all
sp
ecications
of
the
form
(8.39),
form
ula
Liveness
6
W
e
can
also
use
the
follo
wing
w
eak
er
denition
of
subaction:
A
is
a
subaction
of
for-
m
ula
(8.38)
i,
for
ev
ery
state
s
of
ev
ery
b
eha
vior
satisfying
(8.38),
if
A
is
enabled
in
state
s
then
Next
^
A
is
also
enabled
in
s
.

112
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
should
b
e
the
conjunction
of
w
eak
and/or
strong
fairness
form
ulas
for
subactions
of
Next
.
I'll
no
w
explain
wh
y
.
When
w
e
lo
ok
at
the
sp
ecication
(8.39),
w
e
exp
ect
Init
to
constrain
the
initial
state,
Next
to
constrain
what
steps
ma
y
o
ccur,
and
Liveness
to
describ
e
only
what
m
ust
ev
en
tually
happ
en.
Ho
w
ev
er,
consider
the
follo
wing
form
ula:
(x
=
0)
^
2[x
0
=
x
+
1]
x
^
WF
x
((x
>
99)
^
(x
0
=
x
 1))
(8.40)
The
rst
t
w
o
conjuncts
of
(8.40)
assert
that
x
is
initially
0
and
that
an
y
step
either
incremen
ts
x
b
y
1
or
lea
v
es
it
unc
hanged.
Hence,
they
imply
that
if
x
ev
er
exceeds
99,
then
it
forev
er
remains
greater
than
99.
The
w
eak
fairness
prop
ert
y
asserts
that,
if
this
happ
ens,
then
x
m
ust
ev
en
tually
b
e
decremen
ted
b
y
1|con
tradicting
the
second
conjunct.
Hence,
(8.40)
implies
that
x
can
nev
er
exceed
99,
so
it
is
equiv
alen
t
to
(x
=
0)
^
2[(x
<
99)
^
(x
0
=
x
+
1)]
x
Conjoining
the
w
eak
fairness
prop
ert
y
to
the
rst
t
w
o
conjuncts
of
(8.40)
forbids
an
x
0
=
x
+
1
step
when
x
=
99.
A
sp
ecication
of
the
form
(8.39)
is
called
machine
close
d
i
the
conjunct
Liveness
constrains
neither
the
initial
state
nor
what
steps
ma
y
o
ccur.
A
more
general
w
a
y
to
express
this
is
as
follo
ws.
Let
a
nite
b
eha
vior
b
e
a
nite
sequence
of
states.
7
W
e
sa
y
that
a
nite
b
eha
vior

satises
a
safet
y
prop
ert
y
S
i
the
b
eha
vior
obtained
b
y
adding
innitely
man
y
stuttering
steps
to
the
end
of

satises
S
.
If
S
is
a
safet
y
prop
ert
y
,
then
w
e
dene
the
pair
of
form
ulas
S
,
L
to
b
e
mac
hine
closed
i
ev
ery
nite
b
eha
vior
that
satises
S
can
b
e
extended
to
an
innite
b
eha
vior
that
satises
S
^
L.
W
e
call
(8.39)
mac
hine
closed
if
the
pair
of
form
ulas
Init
^
2[Next
]
vars
,
Liveness
is
mac
hine
closed.
W
e
seldom
w
an
t
to
write
a
sp
ecication
that
isn't
mac
hine
closed.
If
w
e
do
write
one,
it's
usually
b
y
mistak
e.
Sp
ecication
(8.39)
is
guaran
teed
to
b
e
mac
hine
closed
if
Liveness
is
the
conjunction
of
w
eak
and/or
strong
fairness
prop
erties
for
subactions
of
Next
.
8
This
condition
do
esn't
hold
for
sp
ecication
(8.40),
whic
h
is
not
mac
hine
closed,
b
ecause
(x
>
99)
^
(x
0
=
x
 1)
is
not
a
subaction
of
x
0
=
x
+
1.
Liv
eness
requiremen
ts
are
philosophically
satisfying.
A
sp
ecication
of
the
form
(8.38),
whic
h
sp
ecies
only
a
safet
y
prop
ert
y
,
allo
ws
b
eha
viors
in
whic
h
the
system
do
es
nothing.
Therefore,
the
sp
ecication
is
satised
b
y
a
system
that
do
es
nothing.
Expressing
liv
eness
requiremen
ts
with
fairness
prop
erties
is
less
satisfying.
These
prop
erties
are
subtle
and
it's
easy
to
get
them
wrong.
7
A
nite
b
eha
vior
therefore
isn't
a
b
eha
vior,
whic
h
is
an
innite
sequence
of
states.
Math-
ematicians
often
abuse
language
in
this
w
a
y
.
8
More
precisely
,
this
is
the
case
for
a
nite
or
coun
tably
innite
conjunction
of
prop
erties
of
the
form
WF
v
(A)
and/or
SF
v
(A),
where
eac
h
hAi
v
is
a
subaction
of
Next
.
This
result
also
holds
for
the
w
eak
er
denition
of
subaction
in
the
fo
otnote
on
the
preceding
page.

8.9.
TEMPORAL
LOGIC
EXAMINED
113
It
requires
some
though
t
to
determine
that
the
liv
eness
condition
for
the
write-
through
cac
he,
form
ula
(8.35)
on
page
108,
do
es
imply
that
ev
ery
request
receiv
es
a
reply
.
It's
tempting
to
express
liv
eness
prop
erties
more
directly
,
without
using
fair-
ness
prop
erties.
F
or
example,
it's
easy
to
write
a
temp
oral
form
ula
asserting
for
the
write-through
cac
he
that
ev
ery
request
receiv
es
a
resp
onse.
When
pro
cessor
p
issues
a
request,
it
sets
ctl
[p
]
to
\rdy"
.
W
e
just
ha
v
e
to
assert
that,
for
ev
ery
pro
cessor
p
,
whenev
er
a
state
in
whic
h
ctl
[p
]
=
\rdy"
is
true
o
ccurs,
there
will
ev
en
tually
b
e
a
Rsp
(p
)
step:
8
p
2
Pr
o
c
:
2((ctl
[p
]
=
\rdy")
)
3h
Rsp
(p
)
i
vars
)
(8.41)
While
suc
h
form
ulas
are
app
ealing,
they
are
dangerous.
It's
v
ery
easy
to
mak
e
a
mistak
e
and
write
a
sp
ecication
that
isn't
mac
hine
closed.
Except
in
un
usual
circumstances,
y
ou
should
express
liv
eness
with
fairness
prop
erties
for
subactions
of
the
next-state
action.
These
are
the
most
straigh
t-
forw
ard
sp
ecications,
and
hence
the
easiest
to
write
and
to
understand.
Most
system
sp
ecications,
ev
en
if
v
ery
detailed
and
complicated,
can
b
e
written
in
this
straigh
tforw
ard
manner.
The
exceptions
are
usually
in
the
realm
of
subtle,
high-lev
el
sp
ecications
that
attempt
to
b
e
v
ery
general.
An
example
of
suc
h
a
sp
ecication
app
ears
in
Section
11.2.
8.9.3
Mac
hine
Closure
and
P
ossibilit
y
Mac
hine
closure
can
b
e
though
t
of
as
a
p
ossibilit
y
condition.
F
or
example,
mac
hine
closure
of
the
pair
S
,
23h
A
i
v
asserts
that
for
ev
ery
nite
b
eha
vior

satisfying
S
,
it
is
p
ossible
to
extend

to
an
innite
b
eha
vior
satisfying
S
in
whic
h
innitely
man
y
h
A
i
v
actions
o
ccur.
If
w
e
regard
S
as
a
system
sp
ecication,
so
a
b
eha
vior
that
satises
S
represen
ts
a
p
ossible
execution
of
the
system,
then
w
e
can
restate
mac
hine
closure
of
S
,
23h
A
i
v
as
follo
ws:
in
an
y
system
execution,
it
is
alw
a
ys
p
ossible
for
innitely
man
y
h
A
i
v
actions
to
o
ccur.
TLA
sp
ecications
express
safet
y
and
liv
eness
prop
erties,
not
p
ossibilit
y
prop
erties.
A
safet
y
prop
ert
y
asserts
that
something
is
imp
ossible|for
exam-
ple,
the
system
cannot
tak
e
a
step
that
do
esn't
satisfy
the
next-state
action.
A
liv
eness
prop
ert
y
asserts
that
something
m
ust
ev
en
tually
happ
en.
System
re-
quiremen
ts
are
sometimes
stated
informally
in
terms
of
what
is
p
ossible.
Most
of
the
time,
when
examined
rigorously
,
these
requiremen
ts
can
b
e
expressed
with
liv
eness
and/or
safet
y
prop
erties.
(The
most
notable
exceptions
are
statistical
prop
erties,
suc
h
as
assertions
ab
out
the
probabilit
y
that
something
happ
ens.)
W
e
are
nev
er
in
terested
in
sp
ecifying
that
something
might
happ
en.
It's
nev
er
useful
to
kno
w
that
the
system
might
pro
duce
the
righ
t
answ
er.
W
e
nev
er
ha
v
e
to
sp
ecify
that
the
user
might
t
yp
e
an
\a"
;
w
e
m
ust
sp
ecify
what
happ
ens
if
he
do
es.

114
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
Mac
hine
closure
is
a
prop
ert
y
of
a
pair
of
form
ulas,
not
of
a
system.
Although
a
p
ossibilit
y
prop
ert
y
is
nev
er
a
useful
assertion
ab
out
a
system,
it
can
b
e
a
useful
assertion
ab
out
a
sp
ecication.
A
sp
ecication
S
of
a
system
with
k
eyb
oard
input
should
alw
a
ys
allo
w
the
user
to
t
yp
e
an
\a"
.
So,
ev
ery
nite
b
eha
vior
satisfying
S
should
b
e
extendable
to
an
innite
b
eha
vior
satisfying
S
in
whic
h
innitely
man
y
\a"
s
are
t
yp
ed.
If
the
action
h
A
i
v
represen
ts
the
t
yping
of
an
\a"
,
then
sa
ying
that
the
user
should
alw
a
ys
b
e
able
to
t
yp
e
innitely
man
y
\a"
s
is
equiv
alen
t
to
sa
ying
that
the
pair
S
,
23h
A
i
v
should
b
e
mac
hine
closed.
If
S
,
23h
A
i
v
isn't
mac
hine
closed,
then
it
could
b
ecome
imp
ossible
for
the
user
ev
er
to
t
yp
e
an
\a"
.
Unless
the
system
is
allo
w
ed
to
lo
c
k
the
k
eyb
oard,
this
w
ould
mean
that
there
w
as
something
wrong
with
the
sp
ecication.
This
kind
of
p
ossibilit
y
prop
ert
y
can
b
e
pro
v
ed.
F
or
example,
to
pro
v
e
that
it's
alw
a
ys
p
ossible
for
the
user
to
t
yp
e
innitely
man
y
\a"
s,
w
e
sho
w
that
conjoining
suitable
fairness
conditions
on
the
input
actions
implies
that
the
user
must
t
yp
e
innitely
man
y
\a"
s.
Ho
w
ev
er,
pro
ofs
of
this
kind
of
simple
prop
ert
y
don't
seem
to
b
e
w
orth
the
eort.
When
writing
a
sp
ecication,
y
ou
should
mak
e
sure
that
p
ossibilities
allo
w
ed
b
y
the
real
system
are
allo
w
ed
b
y
the
sp
ecication.
Once
y
ou
are
a
w
are
of
what
should
b
e
p
ossible,
y
ou
will
usually
ha
v
e
little
trouble
ensuring
that
the
sp
ecication
mak
es
it
p
ossible.
Y
ou
should
also
mak
e
sure
that
what
the
system
must
do
is
implied
b
y
the
sp
ecication's
fairness
conditions.
This
can
b
e
more
dicult.
8.9.4
Renemen
t
Mappings
and
F
airness
Section
5.8
(page
62)
describ
es
ho
w
to
pro
v
e
that
the
write-through
memory
implemen
ts
the
memory
sp
ecication.
W
e
ha
v
e
to
pro
v
e
Sp
e
c
)
ISp
e
c
,
where
Sp
e
c
is
the
sp
ecication
of
the
write-through
memory
,
ISp
e
c
is
the
in
ternal
sp
ec-
ication
of
the
memory
(with
the
in
ternal
v
ariables
made
visible),
and,
for
an
y
form
ula
F
,
w
e
let
F
mean
F
with
expressions
omem
,
o
ctl
,
and
obuf
substituted
for
the
v
ariables
mem
,
ctl
,
and
buf
.
W
e
could
rewrite
this
implication
as
(5.3)
b
ecause
substitution
(o
v
erbarring)
distributes
o
v
er
op
erators
lik
e
^
and
2,
so
w
e
had
IInit
^
2[INext
]
h
memInt
;
mem
;
ctl
;
buf
i

IInit
^
2[INext
]
h
memInt
;
mem
;
ctl
;
buf
i
Because
distributes
o
v
er
^.

IInit
^
2[INext
]
h
memInt
;
mem
;
ctl
;
buf
i
Because
distributes
o
v
er
2[

]
:::
.

IInit
^
2[INext
]
h
memInt
;
mem
;
ctl
;
buf
i
Because
distributes
o
v
er
h
:
:
:
i.

IInit
^
2[INext
]
h
memInt
;
mem
;
ctl
;
buf
i
Because
memInt
=
memInt
.
Adding
liv
eness
to
the
sp
ecications
adds
conjuncts
to
the
form
ulas
Sp
e
c
and
ISp
e
c
.
Supp
ose
w
e
tak
e
form
ula
Liveness
2,
dened
in
(8.19)
on
page
101,
as

8.9.
TEMPORAL
LOGIC
EXAMINED
115
the
liv
eness
prop
ert
y
of
ISp
e
c
.
Then
ISp
e
c
has
the
additional
term
Liveness
2,
whic
h
can
b
e
simplied
as
follo
ws:
Liveness
2

8
p
2
Pr
o
c
:
WF
vars
(Do
(p
)
_
Rsp
(p
))
By
denition
of
Liveness
2.

8
p
2
Pr
o
c
:
WF
vars
(Do
(p
)
_
Rsp
(p
))
Because
distributes
o
v
er
8
.
But
w
e
cannot
automatically
mo
v
e
the
inside
the
WF
b
ecause
substitution
do
es
not,
in
general,
distribute
o
v
er
enabled,
and
hence
it
do
es
not
distribute
o
v
er
WF
or
SF.
F
or
the
sp
ecications
and
renemen
t
mappings
that
o
ccur
in
practice,
including
this
one,
simply
replacing
eac
h
WF
v
(A)
b
y
WF
v
(A)
and
eac
h
SF
v
(A)
b
y
SF
v
(A)
do
es
giv
e
the
righ
t
result.
Ho
w
ev
er,
y
ou
don't
ha
v
e
to
dep
end
on
this.
Y
ou
can
instead
expand
the
denitions
of
WF
and
SF
to
get,
for
example:
WF
v
(A)

23:enabled
h
A
i
v
_
23h
A
i
v
By
denition
of
WF
.

23:enabled
h
A
i
v
_
23h
A
i
v
By
distributivit
y
of
.
Y
ou
can
compute
the
enabled
predicates
\b
y
hand"
and
then
p
erform
the
substitution.
When
computing
enabled
predicates,
it
suces
to
consider
only
states
satisfying
the
safet
y
part
of
the
sp
ecication,
whic
h
usually
means
that
enabled
h
A
i
v
equals
enabled
A.
Y
ou
can
then
compute
enabled
predicates
using
the
follo
wing
rules:
1.
enabled
(A
_
B
)

(enabled
A)
_
(enabled
B
),
for
an
y
actions
A
and
B
.
2.
enabled
(P
^
A)

P
^
(enabled
A),
for
an
y
state
predicate
P
and
action
A.
3.
enabled
(A
^
B
)

(enabled
A)
^
(enabled
B
),
if
A
and
B
are
actions
suc
h
that
the
same
v
ariable
do
es
not
app
ear
primed
in
b
oth
A
and
B
.
4.
enabled
(x
0
=
exp
)

tr
ue
and
enabled
(x
0
2
exp
)

(exp
6=
fg),
for
an
y
v
ariable
x
and
state
function
exp
.
F
or
example:
enabled
(Do
(p
)
_
Rsp
(p
))

(ctl
[p
]
=
\rdy")
_
(ctl
[p
]
=
\done"
)
By
rules
1{4.

(o
ctl
[p
]
=
\rdy")
_
(o
ctl
[p
]
=
\done"
)
By
the
meaning
of
.

116
CHAPTER
8.
LIVENESS
AND
F
AIRNESS
8.9.5
The
Unimp
ortance
of
Liv
eness
While
philosophically
imp
ortan
t,
in
practice
the
liv
eness
prop
ert
y
of
(8.39)
is
not
as
imp
ortan
t
as
the
safet
y
part,
Init
^
2[Next
]
vars
.
The
ultimate
purp
ose
of
writing
a
sp
ecication
is
to
a
v
oid
errors.
Exp
erience
sho
ws
that
most
of
the
b
enet
from
writing
and
using
a
sp
ecication
comes
from
the
safet
y
part.
On
the
other
hand,
the
liv
eness
prop
ert
y
is
usually
easy
enough
to
write.
It
t
ypically
constitutes
less
than
v
e
p
ercen
t
of
a
sp
ecication.
So,
y
ou
migh
t
as
w
ell
write
the
liv
eness
part.
Ho
w
ev
er,
when
lo
oking
for
errors,
most
of
y
our
eort
should
b
e
dev
oted
to
examining
the
safet
y
part.
8.9.6
T
emp
oral
Logic
Considered
Confusing
The
most
general
t
yp
e
of
sp
ecication
I'v
e
discussed
so
far
has
the
form
9
9
9
9
9
9
v
1
;
:
:
:
;
v
n
:
Init
^
2[Next
]
vars
^
Liveness
(8.42)
where
Liveness
is
the
conjunction
of
fairness
prop
erties
of
subactions
of
Next
.
This
is
a
v
ery
restricted
class
of
temp
oral-logic
form
ulas.
T
emp
oral
logic
is
quite
expressiv
e,
and
one
can
com
bine
its
op
erators
in
all
sorts
of
w
a
ys
to
express
a
wide
v
ariet
y
of
prop
erties.
This
suggests
the
follo
wing
approac
h
to
writing
a
sp
ecication:
express
eac
h
prop
ert
y
that
the
system
m
ust
satisfy
with
a
temp
oral
form
ula,
and
then
conjoin
all
these
form
ulas.
F
or
example,
form
ula
(8.41)
ab
o
v
e
expresses
the
prop
ert
y
of
the
write-through
cac
he
that
ev
ery
request
ev
en
tually
receiv
es
a
resp
onse.
This
approac
h
is
philosophically
app
ealing.
It
has
just
one
problem:
it's
practical
for
only
the
v
ery
simplest
of
sp
ecications|and
ev
en
for
them,
it
sel-
dom
w
orks
w
ell.
The
un
bridled
use
of
temp
oral
logic
pro
duces
form
ulas
that
are
hard
to
understand.
Conjoining
sev
eral
of
these
form
ulas
pro
duces
a
sp
ecica-
tion
that
is
imp
ossible
to
understand.
The
basic
form
of
a
TLA
sp
ecication
is
(8.42).
Most
sp
ecications
should
ha
v
e
this
form.
W
e
can
also
use
this
kind
of
sp
ecication
as
a
building
blo
c
k.
Chapters
9
and
10
describ
e
situations
in
whic
h
w
e
write
a
sp
ecication
as
a
conjunction
of
suc
h
form
ulas.
Section
10.7
in
tro
duces
an
additional
temp
oral
op
erator
+
 .
and
explains
wh
y
w
e
migh
t
w
an
t
to
write
a
sp
ecication
F
+
 .
G
,
where
F
and
G
ha
v
e
the
form
(8.42).
But
suc
h
sp
ecications
are
of
limited
practical
use.
Most
engineers
need
only
kno
w
ho
w
to
write
sp
ecications
of
the
form
(8.42).
Indeed,
they
can
get
along
quite
w
ell
with
sp
ecications
of
the
form
(8.38)
that
express
only
safet
y
prop
erties
and
don't
hide
an
y
v
ariables.

Chapter
9
Real
Time
With
a
liv
eness
prop
ert
y
,
w
e
can
sp
ecify
that
a
system
m
ust
ev
en
tually
resp
ond
to
a
request.
W
e
cannot
sp
ecify
that
it
m
ust
resp
ond
within
the
next
100
y
ears.
T
o
sp
ecify
timely
resp
onse,
w
e
m
ust
use
a
real-time
prop
ert
y
.
A
system
that
do
es
not
resp
ond
within
our
lifetime
isn't
v
ery
useful,
so
w
e
migh
t
exp
ect
real-time
sp
ecications
to
b
e
common.
They
aren't.
F
ormal
sp
ecications
are
most
often
used
to
describ
e
what
a
system
do
es
rather
than
ho
w
long
it
tak
es
to
do
it.
Ho
w
ev
er,
y
ou
ma
y
someda
y
w
an
t
to
sp
ecify
real-time
prop
erties
of
a
system.
This
c
hapter
tells
y
ou
ho
w.
9.1
The
Hour
Clo
c
k
Revisited
Let's
return
to
our
sp
ecication
of
the
simple
hour
clo
c
k
in
Chapter
2,
whic
h
asserts
that
the
v
ariable
hr
cycles
through
the
v
alues
1
through
12.
W
e
no
w
add
the
requiremen
t
that
the
clo
c
k
k
eep
correct
time.
F
or
cen
turies,
scien
tists
ha
v
e
represen
ted
the
real-time
b
eha
vior
of
a
system
b
y
in
tro
ducing
a
v
ariable,
tradi-
tionally
t
,
whose
v
alue
is
a
real
n
um
b
er
that
represen
ts
time.
A
state
in
whic
h
Remem
b
er
that
a
state
is
an
assign-
men
t
of
v
alues
to
all
v
ariables.
t
=
 17:51
represen
ts
a
state
of
the
system
at
time
 17:51,
p
erhaps
measured
in
seconds
elapsed
since
00:00
UT
on
1
Jan
uary
2000.
In
TLA
+
sp
ecications,
I
prefer
to
use
the
v
ariable
now
rather
than
t
.
F
or
linguistic
con
v
enience,
I
will
usually
assume
that
the
unit
of
time
is
the
second,
though
w
e
could
just
as
w
ell
c
ho
ose
an
y
other
unit.
Unlik
e
sciences
suc
h
as
ph
ysics
and
c
hemistry
,
computer
science
studies
sys-
tems
whose
b
eha
vior
can
b
e
describ
ed
b
y
a
sequence
of
discrete
states,
rather
than
b
y
states
that
v
ary
con
tin
uously
with
time.
W
e
consider
the
hour
clo
c
k's
displa
y
to
c
hange
directly
from
reading
12
to
reading
1,
and
ignore
the
con-
tin
uum
of
in
termediate
states
that
o
ccur
in
the
ph
ysical
displa
y
.
This
means
that
w
e
pretend
that
the
c
hange
is
instan
taneous
(happ
ens
in
0
seconds).
So,
a
117

118
CHAPTER
9.
REAL
TIME
real-time
sp
ecication
of
the
clo
c
k
migh
t
allo
w
the
step

hr
=
12
now
=
p
2:47

!

hr
=
1
now
=
p
2:47

The
v
alue
of
now
adv
ances
b
et
w
een
c
hanges
to
hr
.
If
w
e
w
an
ted
to
sp
ecify
ho
w
long
it
tak
es
the
displa
y
to
c
hange
from
12
to
1,
w
e
w
ould
ha
v
e
to
in
tro
duce
an
in
termediate
state
that
represen
ts
a
c
hanging
displa
y|p
erhaps
b
y
letting
hr
assume
some
in
termediate
v
alue
suc
h
as
12:5,
or
b
y
adding
a
Bo
olean-v
alued
v
ariable
chg
whose
v
alue
indicates
whether
the
displa
y
is
c
hanging.
W
e
w
on't
do
this,
but
will
b
e
con
ten
t
to
sp
ecify
an
hour
clo
c
k
in
whic
h
w
e
consider
the
displa
y
to
c
hange
instan
taneously
.
The
v
alue
of
now
c
hanges
b
et
w
een
c
hanges
to
hr
.
Just
as
w
e
represen
t
a
con
tin
uously
v
arying
clo
c
k
displa
y
b
y
a
v
ariable
whose
v
alue
c
hanges
in
discrete
steps,
w
e
let
the
v
alue
of
now
c
hange
in
discrete
steps.
A
b
eha
vior
in
whic
h
now
increases
in
fem
tosecond
incremen
ts
w
ould
b
e
an
accurate
enough
description
of
con
tin
uously
c
hanging
time
for
our
sp
ecication
of
the
hour
clo
c
k.
In
fact,
there's
no
need
to
c
ho
ose
an
y
particular
gran
ularit
y
of
time;
w
e
can
let
now
adv
ance
b
y
arbitrary
amoun
ts
b
et
w
een
clo
c
k
tic
ks.
(Since
the
v
alue
of
hr
is
unc
hanged
b
y
steps
that
c
hange
now
,
the
requiremen
t
that
the
clo
c
k
k
eep
correct
time
will
rule
out
b
eha
viors
in
whic
h
now
c
hanges
b
y
to
o
m
uc
h
in
a
single
step.)
What
real-time
condition
should
our
hour
clo
c
k
satisfy?
W
e
migh
t
require
that
it
alw
a
ys
displa
y
the
time
correctly
to
within

seconds,
for
some
real
n
um
b
er
.
Ho
w
ev
er,
this
is
not
t
ypical
of
the
real-time
requiremen
ts
that
arise
in
actual
systems.
Instead,
w
e
require
that
the
clo
c
k
tic
k
appro
ximately
once
p
er
hour.
More
precisely
,
w
e
require
that
the
in
terv
al
b
et
w
een
tic
ks
b
e
one
hour
plus
or
min
us

seconds,
for
some
p
ositiv
e
n
um
b
er
.
Of
course,
this
requiremen
t
allo
ws
the
time
displa
y
ed
b
y
the
clo
c
k
ev
en
tually
to
drift
a
w
a
y
from
the
actual
time.
But
that's
what
real
clo
c
ks
do
if
they
are
not
reset.
W
e
could
start
our
sp
ecication
of
the
real-time
clo
c
k
from
scratc
h.
Ho
w-
ev
er,
w
e
still
w
an
t
the
hour
clo
c
k
to
satisfy
the
sp
ecication
HC
of
mo
dule
HourClo
ck
(Figure
2.1
on
page
20).
W
e
just
w
an
t
to
add
an
additional
real-time
requiremen
t.
So,
w
e
will
write
the
sp
ecication
as
the
conjunction
of
HC
and
a
form
ula
requiring
that
the
clo
c
k
tic
k
ev
ery
hour,
plus
or
min
us

seconds.
This
requiremen
t
is
the
conjunction
of
t
w
o
separate
conditions:
that
the
clo
c
k
tic
k
at
most
once
ev
ery
3600
 
seconds,
and
at
least
once
ev
ery
3600
+

seconds.
T
o
sp
ecify
these
requiremen
ts,
w
e
in
tro
duce
a
v
ariable
that
records
ho
w
m
uc
h
time
has
elapsed
since
the
last
clo
c
k
tic
k.
Let's
call
it
t
for
timer
.
The
v
alue
of
t
is
set
to
0
b
y
a
step
that
represen
ts
a
clo
c
k
tic
k|namely
,
b
y
an
HCnxt
step.
An
y
step
that
represen
ts
the
passing
of
s
seconds
should
adv
ance
t
b
y
s
.
A
step
represen
ts
the
passing
of
time
i
it
c
hanges
now
,
and
suc
h
a
step
represen
ts
the
passage
of
now
0
 now
seconds.
So,
the
c
hange
to
the
timer
t
is
describ
ed
b
y
the
action
TNext

=
t
0
=
if
HCnxt
then
0
else
t
+
(now
0
 now
)

9.1.
THE
HOUR
CLOCK
REVISITED
119
W
e
let
t
initially
equal
0,
so
w
e
consider
the
initial
state
to
b
e
one
in
whic
h
the
clo
c
k
has
just
tic
k
ed.
The
sp
ecication
of
ho
w
t
c
hanges
is
then
a
form
ula
asserting
that
t
initially
equals
0,
and
that
ev
ery
step
is
a
TNext
step
or
else
lea
v
es
unc
hanged
all
relev
an
t
v
ariables|namely
,
t
,
hr
,
and
now
.
This
form
ula
is
Timer

=
(t
=
0)
^
2[TNext
]
h
t
;
hr
;
now
i
The
requiremen
t
that
the
clo
c
k
tic
k
at
least
once
ev
ery
3600
+

seconds
means
that
it's
alw
a
ys
the
case
that
at
most
3600
+

seconds
ha
v
e
elapsed
since
the
last
HCnxt
step.
Since
t
alw
a
ys
equals
the
elapsed
time
since
the
last
HCnxt
step,
this
requiremen
t
is
expressed
b
y
the
form
ula
MaxTime

=
2(t

3600
+
)
(Since
w
e
can't
measure
time
with
p
erfect
accuracy
,
it
do
esn't
matter
whether
w
e
use
<
or

in
this
form
ula.
When
w
e
generalize
from
this
example,
it
is
a
bit
more
con
v
enien
t
to
use
.)
The
requiremen
t
that
the
clo
c
k
tic
k
at
most
once
ev
ery
3600
 
seconds
means
that,
whenev
er
an
HCnxt
step
o
ccurs,
at
least
3600
 
seconds
ha
v
e
elapsed
since
the
previous
HCnxt
step.
This
suggests
the
condition
In
the
general-
ization,

will
b
e
more
con
v
enien
t
than
>.
2(HCnxt
)
(t

3600
 ))
(9.1)
Ho
w
ev
er,
(9.1)
isn't
a
legal
TLA
form
ula
b
ecause
HCnxt
)
:
:
:
is
an
action
(a
form
ula
con
taining
primes),
and
a
TLA
form
ula
asserting
that
an
action
is
alw
a
ys
true
m
ust
ha
v
e
the
form
2[A]
v
.
W
e
don't
care
ab
out
steps
that
lea
v
e
hr
unc
hanged,
so
w
e
can
replace
(9.1)
b
y
the
TLA
form
ula
MinTime

=
2[HCnxt
)
(t

3600
 )]
hr
The
desired
real-time
constrain
t
on
the
clo
c
k
is
expressed
b
y
the
conjunction
of
these
three
form
ulas:
HCTime

=
Timer
^
MaxTime
^
MinTime
F
orm
ula
HCTime
con
tains
the
v
ariable
t
,
and
the
sp
ecication
of
the
real-time
clo
c
k
should
describ
e
only
the
c
hanges
to
hr
(the
clo
c
k
displa
y)
and
now
(the
time).
So,
w
e
ha
v
e
to
hide
t
.
Hiding
is
expressed
in
TLA
+
b
y
the
temp
oral
exis-
ten
tial
quan
tier
9
9
9
9
9
9
,
in
tro
duced
in
Section
4.3
(page
41).
Ho
w
ev
er,
as
explained
in
that
section,
w
e
can't
simply
write
9
9
9
9
9
9
t
:
HCTime
.
W
e
m
ust
dene
HCTime
in
a
mo
dule
that
declares
t
,
and
then
use
a
parametrized
instan
tiation
of
that
mo
dule.
This
is
done
in
Figure
9.1
on
page
121.
Instead
of
dening
HCTime
in
a
completely
separate
mo
dule,
I
ha
v
e
dened
it
in
a
submo
dule
named
Inner
of
the
mo
dule
R
e
alTimeHourClo
ck
con
taining
the
sp
ecication
of
the
real-time
hour
clo
c
k.
Note
that
all
the
sym
b
ols
declared
and
dened
in
the
main
mo
dule

120
CHAPTER
9.
REAL
TIME
up
to
that
p
oin
t
can
b
e
used
in
the
submo
dule.
Submo
dule
Inner
is
instan
tiated
in
the
main
mo
dule
with
the
statemen
t
I
(t
)

=
inst
ance
Inner
The
t
in
HCTime
can
then
b
e
hidden
b
y
writing
9
9
9
9
9
9
t
:
I
(t
)
!
HCTime
.
The
form
ula
HC
^
(
9
9
9
9
9
9
t
:
I
(t
)
!
HCTime
)
describ
es
the
p
ossible
c
hanges
to
the
v
alue
of
hr
,
and
relates
those
c
hanges
to
the
v
alue
of
now
.
But
it
sa
ys
v
ery
little
ab
out
ho
w
the
v
alue
of
now
can
c
hange.
F
or
example,
it
allo
ws
the
follo
wing
b
eha
vior:

hr
=
11
now
=
23:5

!

hr
=
11
now
=
23:4

!

hr
=
11
now
=
23:5

!

hr
=
11
now
=
23:4

!



Because
time
can't
go
bac
kw
ards,
suc
h
a
b
eha
vior
do
esn't
represen
t
a
ph
ysical
p
ossibilit
y
.
Ev
ery
one
kno
ws
that
time
only
increases,
so
there's
no
need
to
forbid
this
b
eha
vior
if
the
only
purp
ose
of
our
sp
ecication
is
to
describ
e
the
hour
clo
c
k.
Ho
w
ev
er,
a
sp
ecication
should
also
allo
w
us
to
reason
ab
out
a
system.
If
the
clo
c
k
tic
ks
appro
ximately
once
p
er
hour,
then
it
can't
stop.
Ho
w
ev
er,
as
the
b
eha
vior
ab
o
v
e
sho
ws,
the
form
ula
HC
^
(
9
9
9
9
9
9
t
:
I
(t
)
!
HCTime
)
b
y
itself
allo
ws
the
clo
c
k
to
stop.
T
o
infer
that
it
can't,
w
e
also
need
to
state
ho
w
now
c
hanges.
W
e
dene
a
form
ula
R
Tnow
that
sp
ecies
the
p
ossible
c
hanges
to
now
.
This
form
ula
do
es
not
sp
ecify
the
gran
ularit
y
of
the
c
hanges
to
now
;
it
allo
ws
a
step
to
adv
ance
now
b
y
a
microsecond
or
b
y
a
cen
tury
.
Ho
w
ev
er,
w
e
ha
v
e
decided
that
a
step
that
c
hanges
hr
should
lea
v
e
now
unc
hanged,
whic
h
implies
that
a
step
that
c
hanges
now
should
lea
v
e
hr
unc
hanged.
Therefore,
steps
that
c
hange
now
are
describ
ed
b
y
the
follo
wing
action,
where
R
e
al
is
the
set
of
all
real
n
um
b
ers:
NowNext

=
^
now
0
2
fr
2
R
e
al
:
r
>
now
g
now
0
can
equal
an
y
real
n
um
b
er
>
now
.
^
unchanged
hr
F
orm
ula
R
Tnow
should
also
allo
w
steps
that
lea
v
e
now
unc
hanged.
The
initial
v
alue
of
now
is
an
arbitrary
real
n
um
b
er
(w
e
can
start
the
system
at
an
y
time),
so
the
safet
y
part
of
R
Tnow
is
(now
2
R
e
al
)
^
2[NowNext
]
now
The
liv
eness
condition
w
e
w
an
t
is
that
now
should
increase
without
b
ound.
Simple
w
eak
fairness
of
the
NowNext
action
isn't
go
o
d
enough,
b
ecause
it
allo
ws
W
eak
fairness
is
discussed
in
Chap-
ter
8.
\Zeno"
b
eha
viors
suc
h
as
[now
=
:9]
!
[now
=
:99]
!
[now
=
:999]
!
[now
=
:9999]
!



in
whic
h
the
v
alue
of
now
remains
b
ounded.
W
eak
fairness
of
the
action
NowNext
^
(now
0
>
r
)
implies
that
ev
en
tually
a
NowNext
step
will
o
ccur
in
whic
h
the
new
v
alue
of
now
is
greater
than
r
.
(This
action
is
alw
a
ys
enabled,
so
w
eak
fairness
implies
that
innitely
man
y
suc
h
actions
m
ust
o
ccur.)
Asserting

9.1.
THE
HOUR
CLOCK
REVISITED
121
module
R
e
alTimeHourClo
ck
extends
R
e
als,
HourClo
ck
v
ariable
now
The
curren
t
time,
measured
in
seconds.
const
ant
R
ho
A
p
ositiv
e
real
n
um
b
er.
assume
(R
ho
2
R
e
al
)
^
(R
ho
>
0)
module
Inner
v
ariable
t
TNext

=
t
0
=
if
HCnxt
then
0
else
t
+
(now
0
 now
)
Timer

=
(t
=
0)
^
2[TNext
]
h
t
;
hr
;
now
i
MaxTime

=
2(t

3600
+
R
ho
)
MinTime

=
2[HCnxt
)
t

3600
 R
ho
]
hr
HCTime

=
Timer
^
MaxTime
^
MinTime
t
is
the
elapsed
time
since
the
last
HCnxt
step.
t
is
alw
a
ys
at
most
3600
+
R
ho
.
An
HCnxt
step
can
o
ccur
only
if
t

3600
 R
ho
.
I
(t
)

=
inst
ance
Inner
NowNext

=
^
now
0
2
fr
2
R
e
al
:
r
>
now
g
^
unchanged
hr
A
NowNext
step
can
adv
ance
now
b
y
an
y
amoun
t
while
lea
ving
hr
unc
hanged.
R
Tnow

=
^
now
2
R
e
al
^
2[NowNext
]
now
^
8
r
2
R
e
al
:
WF
now
(NowNext
^
(now
0
>
r
))
R
Tnow
sp
ecies
ho
w
time
ma
y
c
hange.
R
THC

=
HC
^
R
Tnow
^
(
9
9
9
9
9
9
t
:
I
(t
)
!
HCTime
)
The
complete
sp
ecication.
Figure
9.1:
The
real-time
sp
ecication
of
an
hour
clo
c
k
that
tic
ks
ev
ery
hour,
plus
or
min
us
R
ho
seconds.
this
for
all
real
n
um
b
ers
r
implies
that
now
gro
ws
without
b
ound,
so
w
e
tak
e
as
the
fairness
condition
1
8
r
2
R
e
al
:
WF
now
(NowNext
^
(now
0
>
r
))
The
complete
sp
ecication
R
THC
of
the
real-time
hour
clo
c
k,
with
the
denition
of
form
ula
R
Tnow
,
is
in
the
R
e
alTimeHourClo
ck
mo
dule
of
Figure
9.1
on
this
page.
That
mo
dule
extends
the
standard
R
e
als
mo
dule,
whic
h
denes
the
set
R
e
al
of
real
n
um
b
ers.
1
An
equiv
alen
t
condition
is
8
r
2
R
e
al
:
3(now
>
r
),
but
I
lik
e
to
express
fairness
with
WF
and
SF
form
ulas.

122
CHAPTER
9.
REAL
TIME
9.2
Real-Time
Sp
ecications
in
General
In
Section
8.4
(page
96),
w
e
sa
w
that
the
appropriate
generalization
of
the
liv
e-
ness
requiremen
t
that
the
hour
clo
c
k
tic
k
innitely
often
is
w
eak
fairness
of
the
clo
c
k-tic
k
action.
There
is
a
similar
generalization
for
real-time
sp
ecications.
W
eak
fairness
of
an
action
A
asserts
that
if
A
is
con
tin
uously
enabled,
then
an
A
step
m
ust
ev
en
tually
o
ccur.
The
real-time
analog
is
that
if
A
is
con
tin
uously
enabled
for

seconds,
then
an
A
step
m
ust
o
ccur.
Since
an
HCnxt
action
is
alw
a
ys
enabled,
the
requiremen
t
that
the
clo
c
k
tic
k
at
least
once
ev
ery
3600
+

seconds
can
b
e
expressed
in
this
w
a
y
b
y
letting
A
b
e
HCnxt
and

b
e
3600
+
.
The
requiremen
t
that
an
HCnxt
action
o
ccur
at
most
once
ev
ery
3600
 
seconds
can
b
e
similarly
generalized
to
the
condition
that
an
action
A
m
ust
b
e
con
tin
uously
enabled
for
at
least

seconds
b
efore
an
A
step
can
o
ccur.
The
rst
condition,
the
upp
er
b
ound

on
ho
w
long
A
can
b
e
enabled
without
an
A
step
o
ccurring,
is
v
acuously
satised
if

equals
Innity
|a
v
alue
dened
in
the
R
e
als
mo
dule
to
b
e
greater
than
an
y
real
n
um
b
er.
The
second
condition,
the
lo
w
er
b
ound

on
ho
w
long
A
m
ust
b
e
enabled
b
efore
an
A
step
can
o
ccur,
is
v
acuously
satised
if

equals
0.
So,
nothing
is
lost
b
y
com
bining
b
oth
of
these
conditions
in
to
a
single
form
ula
con
taining

and

as
parameters.
I
no
w
dene
suc
h
a
form
ula,
whic
h
I
call
a
r
e
al-time
b
ound
c
ondition.
The
w
eak
fairness
form
ula
WF
v
(A)
actually
asserts
w
eak
fairness
of
the
ac-
tion
h
A
i
v
,
whic
h
equals
A
^
(v
0
6=
v
).
The
subscript
v
is
needed
to
rule
out
stut-
tering
steps.
Since
the
truth
of
a
meaningful
form
ula
can't
dep
end
on
whether
or
not
there
are
stuttering
steps,
it
mak
es
no
sense
to
sa
y
that
an
A
step
did
or
did
not
o
ccur
if
that
step
could
b
e
a
stuttering
step.
F
or
this
reason,
the
corresp
ond-
ing
real-time
condition
m
ust
also
b
e
a
condition
on
an
action
h
A
i
v
,
not
on
an
arbitrary
action
A.
In
most
cases
of
in
terest,
v
is
the
tuple
of
all
v
ariables
that
o
ccur
in
A.
I
therefore
dene
the
real-time
b
ound
form
ula
R
TBound
(A;
v
;

;
)
to
assert
that

An
h
A
i
v
step
cannot
o
ccur
un
til
h
A
i
v
has
b
een
con
tin
uously
enabled
for
at
least

time
units
since
the
last
h
A
i
v
step|or
since
the
b
eginning
of
the
b
eha
vior.

h
A
i
v
can
b
e
con
tin
uously
enabled
for
at
most

time
units
b
efore
an
h
A
i
v
step
o
ccurs.
R
TBound
(A;
v
;

;
)
generalizes
the
form
ula
9
9
9
9
9
9
t
:
I
(t
)
!
HCTime
of
the
real-time
hour-clo
c
k
sp
ecication,
and
it
can
b
e
dened
in
the
same
w
a
y
,
using
a
submo
d-
ule.
Ho
w
ev
er,
the
denition
can
b
e
structured
a
little
more
compactly
as
F
or
the
TLA
+
sp
ecication,
I
ha
v
e
replaced

and

b
y
D
and
E
.
R
TBound
(A;
v
;
D
;
E
)

=
let
Timer
(t
)

=
:
:
:
:
:
:
in
9
9
9
9
9
9
t
:
Timer
(t
)
^
:
:
:

9.2.
REAL-TIME
SPECIFICA
TIONS
IN
GENERAL
123
W
e
rst
dene
Timer
(t
)
to
b
e
a
temp
oral
form
ula
asserting
that
t
alw
a
ys
equals
the
length
of
time
that
h
A
i
v
has
b
een
con
tin
uously
enabled
since
the
last
h
A
i
v
step.
The
v
alue
of
t
should
b
e
set
to
0
b
y
an
h
A
i
v
step
or
a
step
that
disables
h
A
i
v
.
A
step
that
adv
ances
now
should
incremen
t
t
b
y
now
0
 now
i
h
A
i
v
is
enabled.
Changes
to
t
are
therefore
describ
ed
b
y
the
action
TNext
(t
)

=
t
0
=
if
h
A
i
v
_
:(enabled
h
A
i
v
)
0
then
0
else
t
+
(now
0
 now
)
W
e
are
in
terested
in
the
meaning
of
Timer
(t
)
only
when
v
is
a
tuple
whose
comp
onen
ts
include
all
the
v
ariables
that
ma
y
app
ear
in
A.
In
this
case,
a
step
that
lea
v
es
v
unc
hanged
cannot
enable
or
disable
h
A
i
v
.
So,
the
form
ula
Timer
(t
)
should
allo
w
steps
that
lea
v
e
t
,
v
,
and
now
unc
hanged.
Letting
the
initial
v
alue
of
t
b
e
0,
w
e
dene
Timer
(t
)

=
(t
=
0)
^
2[TNext
(t
)]
h
t
;
v
;
now
i
F
orm
ulas
MaxTime
and
MinTime
of
the
real-time
hour
clo
c
k's
sp
ecication
ha
v
e
the
ob
vious
generalizations:

MaxTime
(t
)
asserts
that
t
is
alw
a
ys
less
than
or
equal
to
E
:
MaxTime
(t
)

=
2(t

E
)

MinTime
(t
)
asserts
that
an
h
A
i
v
step
can
o
ccur
only
if
t

D
:
MinTime
(t
)

=
2[A
)
(t

D
)]
v
(An
equally
plausible
denition
of
MinTime
(t
)
is
2[h
A
i
v
)
(t

D
)]
v
,
but
the
t
w
o
are,
in
fact,
equiv
alen
t.)
W
e
then
dene
R
TBound
(A;
v
;
D
;
E
)
to
equal
9
9
9
9
9
9
t
:
Timer
(t
)
^
MaxTime
(t
)
^
MinTime
(t
)
W
e
m
ust
also
generalize
form
ula
R
Tnow
of
the
real-time
hour
clo
c
k's
sp
ecica-
tion.
That
form
ula
describ
es
ho
w
now
c
hanges,
and
it
asserts
that
hr
remains
unc
hanged
when
now
c
hanges.
The
generalization
is
the
form
ula
R
Tnow
(v
),
whic
h
replaces
hr
with
an
arbitrary
state
function
v
that
will
usually
b
e
the
tu-
ple
of
all
v
ariables,
other
than
now
,
app
earing
in
the
sp
ecication.
Using
these
denitions,
the
sp
ecication
R
THC
of
the
real-time
hour
clo
c
k
can
b
e
written
HC
^
R
Tnow
(hr
)
^
R
TBound
(HCnxt
;
hr
;
3600
 R
ho
;
3600
+
R
ho
)
The
R
e
alTime
mo
dule,
with
its
denitions
of
R
TBound
and
R
Tnow
,
app
ears
in
Figure
9.2
on
page
125.
Strong
fairness
strengthens
w
eak
fairness
b
y
requiring
an
A
step
to
o
ccur
not
just
if
action
A
is
con
tin
uously
enabled,
but
if
it
is
rep
eatedly
enabled.
Being

124
CHAPTER
9.
REAL
TIME
rep
eatedly
enabled
includes
the
p
ossibilit
y
that
it
is
also
rep
eatedly
disabled.
W
e
can
similarly
strengthen
our
real-time
b
ound
conditions
b
y
dening
a
stronger
form
ula
SR
TBound
(A;
v
;

;
)
to
assert
that

An
h
A
i
v
step
cannot
o
ccur
un
til
h
A
i
v
has
b
een
enabled
for
a
total
of
at
least

time
units
since
the
last
h
A
i
v
step|or
since
the
b
eginning
of
the
b
eha
vior.

h
A
i
v
can
b
e
enabled
for
a
total
of
at
most

time
units
b
efore
an
h
A
i
v
step
o
ccurs.
If

<
Innity
,
then
R
TBound
(A;
v
;

;
)
implies
that
an
h
A
i
v
step
m
ust
o
ccur
if
h
A
i
v
is
con
tin
uously
enabled
for

seconds.
Hence,
if
h
A
i
v
is
ev
er
enabled
forev
er,
innitely
man
y
h
A
i
v
steps
m
ust
o
ccur.
Th
us,
R
TBound
(A;
v
;

;
)
implies
w
eak
fairness
of
A.
More
precisely
,
R
TBound
(A;
v
;

;
)
and
R
Tnow
(v
)
together
imply
WF
v
(A).
Ho
w
ev
er,
SR
TBound
(A;
v
;

;
)
do
es
not
similarly
imply
strong
fairness
of
A.
It
allo
ws
b
eha
viors
in
whic
h
h
A
i
v
is
enabled
innitely
often
but
nev
er
executed|for
example,
A
can
b
e
enabled
for
=2
seconds,
then
for
=4
seconds,
then
for
=8
seconds,
and
so
on.
F
or
this
reason,
SR
TBound
do
es
not
seem
to
b
e
of
m
uc
h
practical
use,
so
I
w
on't
b
other
dening
it
formally
.
9.3
A
Real-Time
Cac
hing
Memory
Let's
no
w
use
the
R
e
alTime
mo
dule
to
write
a
real-time
v
ersions
of
the
lineariz-
able
memory
sp
ecication
of
Section
5.3
(page
51)
and
the
write-through
cac
he
sp
ecication
of
Section
5.6
(page
54).
W
e
obtain
the
real-time
memory
sp
ec-
ication
b
y
strengthening
the
sp
ecication
in
mo
dule
Memory
(Figure
5.3
on
page
53)
to
require
that
the
memory
resp
onds
to
a
pro
cessor's
requests
within
R
ho
seconds.
The
complete
memory
sp
ecication
Sp
e
c
of
mo
dule
Memory
w
as
obtained
b
y
hiding
the
v
ariables
mem
,
ctl
,
and
buf
in
the
in
ternal
sp
ecica-
tion
ISp
e
c
of
mo
dule
InternalMemory
.
It's
generally
easier
to
add
a
real-time
constrain
t
to
an
in
ternal
sp
ecication,
where
the
constrain
ts
can
men
tion
the
in
ternal
(hidden)
v
ariables.
So,
w
e
rst
add
the
timing
constrain
t
to
ISp
e
c
and
then
hide
the
in
ternal
v
ariables.
T
o
sp
ecify
that
the
system
m
ust
resp
ond
to
a
pro
cessor
request
within
R
ho
seconds,
w
e
add
an
upp
er-b
ound
timing
constrain
t
for
an
action
that
b
ecomes
enabled
when
a
request
is
issued,
and
that
b
ecomes
disabled
(p
ossibly
b
y
b
e-
ing
executed)
only
when
the
pro
cessor
resp
onds
to
the
request.
In
sp
ecication
ISp
e
c
,
resp
onding
to
a
request
requires
t
w
o
actions|Do
(p
)
to
p
erform
the
op-
eration
in
ternally
,
and
Rsp
(p
)
to
issue
the
resp
onse.
Neither
of
these
actions
is
the
one
w
e
w
an
t;
w
e
ha
v
e
to
dene
a
new
action
for
the
purp
ose.
There
is
a
p
ending
request
for
pro
cessor
p
i
ctl
[p
]
equals
\rdy"
.
So,
w
e
assert
that
the

9.3.
A
REAL-TIME
CA
CHING
MEMOR
Y
125
module
R
e
alTime
This
mo
dule
declares
the
v
ariable
now
,
whic
h
represen
ts
real
time,
and
denes
op
erators
for
writing
real-time
sp
ecications.
Real-time
constrain
ts
are
added
to
a
sp
ecication
b
y
conjoining
it
with
R
Tnow
(v
)
and
for-
m
ulas
of
the
form
R
TBound
(A;
v
;

;
)
for
actions
A,
where
v
is
the
tuple
of
all
sp
ecication
v
ariables
and
0





Innity
.
extends
R
e
als
v
ariable
now
The
v
alue
of
now
is
a
real
n
um
b
er
that
represen
ts
the
curren
t
time,
in
unsp
ecied
units.
R
TBound
(A;
v
;

;
)
asserts
that
an
h
A
i
v
step
can
o
ccur
only
after
h
A
i
v
has
b
een
con
tin
uously
enabled
for

time
units
since
the
last
h
A
i
v
step
(or
the
b
eginning
of
the
b
eha
vior),
and
it
m
ust
o
ccur
b
efore
h
A
i
v
has
b
een
con
tin
uously
enabled
for
more
than

time
units
since
the
last
h
A
i
v
step
(or
the
b
eginning
of
the
b
eha
vior).
R
TBound
(A;
v
;
D
;
E
)

=
let
TNext
(t
)

=
t
0
=
if
h
A
i
v
_
:(enabled
h
A
i
v
)
0
then
0
else
t
+
(now
0
 now
)
Timer
(t
)
asserts
that
t
is
the
length
of
time
h
A
i
v
has
b
een
con
tin
uously
enabled
without
an
h
A
i
v
step
o
ccur-
ring.
Timer
(t
)

=
(t
=
0)
^
2[TNext
(t
)]
h
t
;
v
;
now
i
MaxTime
(t
)

=
2(t

E
)
Asserts
that
t
is
alw
a
ys

E
.
MinTime
(t
)

=
2[A
)
(t

D
)]
v
Asserts
that
an
h
A
i
v
step
can
o
ccur
only
if
t

D
.
in
9
9
9
9
9
9
t
:
Timer
(t
)
^
MaxTime
(t
)
^
MinTime
(t
)
R
Tnow
(v
)
asserts
that
now
is
a
real
n
um
b
er
that
is
increased
without
b
ound,
in
arbitrary
incremen
ts,
b
y
steps
that
lea
v
e
v
unc
hanged.
R
Tnow
(v
)

=
let
NowNext

=
^
now
0
2
fr
2
R
e
al
:
r
>
now
g
^
unchanged
v
in
^
now
2
R
e
al
^
2[NowNext
]
now
^
8
r
2
R
e
al
:
WF
now
(NowNext
^
(now
0
>
r
))
Figure
9.2:
The
R
e
alTime
mo
dule
for
writing
real-time
sp
ecications.
follo
wing
action
cannot
b
e
enabled
for
more
than
R
ho
seconds
without
b
eing
executed:
R
esp
ond
(p
)

=
(ctl
[p
]
6=
\rdy")
^
(ctl
0
[p
]
=
\rdy")
The
complete
sp
ecication
is
form
ula
R
TSp
e
c
of
mo
dule
R
TMemory
in
Fig-
ure
9.3
on
the
next
page.
T
o
p
ermit
v
ariables
mem
,
ctl
,
and
buf
to
b
e
hid-
den,
the
R
TMemory
mo
dule
con
tains
a
submo
dule
Inner
that
extends
mo
dule
InternalMemory
.
Ha
ving
added
a
real-time
constrain
t
to
the
sp
ecication
of
a
linearizable
memory
,
let's
strengthen
the
sp
ecication
of
the
write-through
cac
he
so
it
sat-

126
CHAPTER
9.
REAL
TIME
module
R
TMemory
A
sp
ecication
that
strengthens
the
linearizable
memory
sp
ecication
of
Section
5.3
b
y
requiring
that
a
resp
onse
b
e
sen
t
to
ev
ery
pro
cessor
request
within
R
ho
seconds.
extends
MemoryInterfac
e
;
R
e
alTime
const
ant
R
ho
assume
(R
ho
2
R
e
al
)
^
(R
ho
>
0)
module
Inner
W
e
in
tro
duce
a
submo
dule
so
w
e
can
hide
the
v
ariables
mem
,
ctl
,
and
buf
.
extends
InternalMemory
R
esp
ond
(p
)

=
(ctl
[p
]
6=
\rdy")
^
(ctl
0
[p
]
=
\rdy"
)
R
esp
ond
(p
)
is
enabled
when
a
request
is
receiv
ed
from
p
;
it
is
disabled
when
a
R
esp
ond
(p
)
step
issues
the
resp
onse.
R
TISp
e
c

=
^
ISp
e
c
^
8
p
2
Pr
o
c
:
R
TBound
(R
esp
ond
(p
);
ctl
;
0;
R
ho
)
^
R
Tnow
(h
memInt
;
mem
;
ctl
;
buf
i)
W
e
assert
an
upp
er-b
ound
dela
y
of
R
ho
on
R
esp
ond
(p
),
for
all
pro
cessors
p
.
Inner
(mem
;
ctl
;
buf
)

=
inst
ance
Inner
R
TSp
e
c

=
9
9
9
9
9
9
mem
;
ctl
;
buf
:
Inner
(mem
;
ctl
;
buf
)
!
R
TISp
e
c
Figure
9.3:
A
real-time
v
ersion
of
the
linearizable
memory
sp
ecication.
ises
that
constrain
t.
The
ob
ject
is
not
just
to
add
an
y
real-time
constrain
t
that
do
es
the
job|that's
easy
to
do
b
y
using
the
same
constrain
t
that
w
e
added
to
the
memory
sp
ecication.
W
e
w
an
t
to
write
a
sp
ecication
of
a
real-time
algorithm|a
sp
ecication
that
tells
an
implemen
ter
ho
w
to
meet
the
real-time
constrain
ts.
This
is
generally
done
b
y
placing
real-time
b
ounds
on
the
original
actions
of
the
un
timed
sp
ecication,
not
b
y
adding
time
b
ounds
on
a
new
ac-
tion,
as
w
e
did
for
the
memory
sp
ecication.
An
upp
er-b
ound
constrain
t
on
the
resp
onse
time
should
b
e
ac
hiev
ed
b
y
enforcing
upp
er-b
ound
constrain
ts
on
the
system's
actions.
If
w
e
try
to
ac
hiev
e
a
b
ound
on
resp
onse
time
b
y
adding
real-time
b
ounds
to
the
write-through
cac
he
sp
ecication's
actions,
w
e
encoun
ter
the
follo
wing
prob-
lem.
Op
erations
b
y
dieren
t
pro
cessors
\comp
ete"
with
one
another
to
enqueue
op
erations
on
the
nite
queue
memQ
.
F
or
example,
when
servicing
a
write
re-
quest
for
pro
cessor
p
,
the
system
m
ust
execute
a
DoWr
(p
)
action
to
enqueue
the
op
eration
to
the
tail
of
memQ
.
That
action
is
not
enabled
if
memQ
is
full.
The
DoWr
(p
)
action
can
b
e
con
tin
ually
disabled
b
y
the
system
p
erforming
DoWr
or
R
dMiss
actions
for
other
pro
cessors.
That's
wh
y
,
to
guaran
tee
liv
eness|that
eac
h
request
ev
en
tually
receiv
es
a
resp
onse|in
Section
8.7
(page
107)
w
e
had
to
assert
strong
fairness
of
DoWr
and
R
dMiss
actions.
The
only
w
a
y
to
ensure

9.3.
A
REAL-TIME
CA
CHING
MEMOR
Y
127
that
a
DoWr
(p
)
action
is
executed
within
some
length
of
time
is
to
use
lo
w
er-
b
ound
constrain
ts
on
the
actions
of
other
pro
cessors
to
ensure
that
they
cannot
p
erform
DoWr
or
R
dMiss
actions
to
o
frequen
tly
.
Although
suc
h
a
sp
ecication
is
p
ossible,
it
is
not
the
kind
of
approac
h
an
y
one
is
lik
ely
to
tak
e
in
practice.
The
usual
metho
d
of
enforcing
real-time
b
ounds
on
accesses
to
a
shared
resource
is
to
sc
hedule
the
use
of
the
resource
b
y
dieren
t
pro
cessors.
So,
let's
mo
dify
the
write-through
cac
he
to
add
a
sc
heduling
discipline
to
actions
that
enqueue
op
erations
on
memQ
.
W
e
use
round-robin
sc
heduling,
whic
h
is
probably
the
easiest
one
to
implemen
t.
Supp
ose
pro
cessors
are
n
um
b
ered
from
0
through
N
 1.
Round-robin
sc
heduling
means
that
an
op
eration
for
pro
cessor
p
is
the
next
one
to
b
e
enqueued
after
an
op
eration
for
pro
cessor
q
i
there
is
not
an
op
eration
for
an
y
of
the
pro
cessors
(q
+
1)
%
N
,
(q
+
2)
%
N
,
.
.
.
,
(p
 1)
%
N
w
aiting
to
b
e
put
on
memQ
.
T
o
express
this
formally
,
w
e
rst
let
the
set
Pr
o
c
of
pro
cessors
equal
the
set
0
:
:
(N
 1)
of
in
tegers.
W
e
normally
do
this
b
y
dening
Pr
o
c
to
equal
0
:
:
(N
 1).
Ho
w
ev
er,
w
e
w
an
t
to
reuse
the
parameters
and
denitions
from
the
write-through
cac
he
sp
ecication,
and
that's
easiest
to
do
b
y
extending
mo
dule
WriteThr
oughCache
.
Since
Pr
o
c
is
a
parameter
of
that
mo
dule,
w
e
can't
dene
it.
W
e
therefore
let
N
b
e
a
new
constan
t
parameter
and
let
Pr
o
c
=
0
:
:
(N
 1)
b
e
an
assumption.
2
T
o
implemen
t
round-robin
sc
heduling,
w
e
use
a
v
ariable
lastP
that
equals
the
last
pro
cessor
whose
op
eration
w
as
enqueued
to
memQ
.
W
e
dene
the
op
erator
p
osition
so
that
p
is
the
p
osition
(p
)
th
pro
cessor
after
lastP
in
the
round-robin
order:
p
osition
(p
)

=
choose
i
2
1
:
:
N
:
p
=
(lastP
+
i
)
%
N
(Th
us,
p
osition
(lastP
)
equals
N
.)
An
op
eration
for
pro
cessor
p
can
b
e
the
next
to
access
memQ
i
there
is
no
op
eration
for
a
pro
cessor
q
with
p
osition
(q
)
<
p
osition
(p
)
ready
to
access
it|that
is,
i
c
anGoNext
(p
)
is
true,
where
c
anGoNext
(p
)

=
8
q
2
Pr
o
c
:
(p
osition
(q
)
<
p
osition
(p
))
)
:
enabled
(R
dMiss
(q
)
_
DoWr
(q
))
W
e
then
dene
R
TR
dMiss
(p
)
and
R
TDoWr
(p
)
to
b
e
the
same
as
R
dMiss
(p
)
and
DoWr
(p
),
resp
ectiv
ely
,
except
that
they
ha
v
e
the
additional
enabling
condition
c
anGoNext
(p
),
and
they
set
lastP
to
p
.
The
other
subactions
of
the
next-state
action
are
the
same
as
b
efore,
except
that
they
m
ust
also
lea
v
e
lastP
unc
hanged.
F
or
simplicit
y
,
w
e
assume
a
single
upp
er
b
ound
of
Epsilon
on
the
length
of
time
an
y
of
the
actions
of
pro
cessor
p
can
remain
enabled
without
b
eing
executed|except
for
the
Evict
(p
;
a
)
action,
whic
h
w
e
nev
er
require
to
happ
en.
In
general,
supp
ose
A
1
,
.
.
.
,
A
k
are
actions
suc
h
that
(i)
no
t
w
o
of
them
are
2
W
e
could
also
instan
tiate
mo
dule
WriteThr
oughCache
with
0
:
:
(N
 1)
substituted
for
Pr
o
c
;
but
that
w
ould
require
declaring
the
other
parameters
of
WriteThr
oughCache
,
including
the
ones
from
the
MemoryInterfac
e
mo
dule.

128
CHAPTER
9.
REAL
TIME
ev
er
sim
ultaneously
enabled,
and
(ii)
once
an
y
A
i
b
ecomes
enabled,
it
m
ust
b
e
executed
b
efore
another
A
j
can
b
e
enabled.
In
this
case,
a
single
R
TBound
constrain
t
on
A
1
_
:
:
:
_
A
k
is
equiv
alen
t
to
separate
constrain
ts
on
all
the
A
i
.
W
e
can
therefore
place
a
single
constrain
t
on
the
disjunction
of
all
the
actions
of
pro
cessor
p
,
except
that
w
e
can't
use
the
same
constrain
t
for
b
oth
DoR
d
(p
)
and
R
TR
dMiss
(p
)
b
ecause
an
Evict
(p
;
a
)
step
could
disable
DoR
d
(p
)
and
enable
R
TR
dMiss
(p
).
W
e
therefore
use
a
separate
constrain
t
for
R
TR
dMiss
(p
).
W
e
assume
an
upp
er
b
ound
of
Delta
on
the
time
MemQWr
or
MemQR
d
can
b
e
enabled
without
dequeuing
an
op
eration
from
memQ
.
The
v
ariable
memQ
represen
ts
a
ph
ysical
queue
b
et
w
een
the
bus
and
the
main
memory
,
and
Delta
m
ust
b
e
large
enough
so
an
op
eration
inserted
in
to
an
empt
y
queue
will
reac
h
the
memory
and
b
e
dequeued
within
Delta
seconds.
W
e
w
an
t
the
real-time
write-through
cac
he
to
implemen
t
the
real-time
mem-
ory
sp
ecication.
This
requires
an
assumption
relating
Delta
,
Epsilon
,
and
R
ho
to
assure
that
the
memory
sp
ecication's
timing
constrain
t
is
satised|namely
,
that
the
dela
y
b
et
w
een
when
the
memory
receiv
es
a
request
from
pro
cessor
p
and
when
it
resp
onds
is
at
most
R
ho
.
Determining
this
assumption
requires
computing
an
upp
er
b
ound
on
that
dela
y
.
Finding
the
smallest
upp
er
b
ound
is
hard;
it's
easier
to
sho
w
that
2

(N
+
1)

Epsilon
+
(N
+
QL
en
)

Delta
is
an
upp
er
b
ound.
So
w
e
assume
that
this
v
alue
is
less
than
or
equal
to
R
ho
.
The
complete
sp
ecication
app
ears
in
Figure
9.4
on
the
follo
wing
t
w
o
pages.
The
mo
dule
also
asserts
as
a
theorem
that
the
sp
ecication
R
TSp
e
c
of
the
real-
time
write-through
cac
he
implemen
ts
(implies)
the
real-time
memory
sp
ecica-
tion,
form
ula
R
TSp
e
c
of
mo
dule
R
TMemory
.
9.4
Zeno
Sp
ecications
I
ha
v
e
describ
ed
the
form
ula
R
TBound
(HCnxt
;
hr
;

;
)
as
asserting
that
an
HCnxt
step
m
ust
o
ccur
within

seconds
of
the
previous
HCnxt
step.
Ho
w
ev
er,
implicit
in
this
description
is
a
notion
of
causalit
y
that
is
not
presen
t
in
the
form
ula.
It
w
ould
b
e
just
as
accurate
to
describ
e
the
form
ula
as
asserting
that
now
cannot
adv
ance
b
y
more
than

seconds
b
efore
the
next
HCnxt
step
o
ccurs.
The
form
ula
do
esn't
tell
us
whether
this
condition
is
met
b
y
causing
the
clo
c
k
to
tic
k
or
b
y
prev
en
ting
time
from
adv
ancing.
Indeed,
the
form
ula
is
satised
b
y
a
\Zeno"
b
eha
vior:
3

hr
=
11
now
=
0

!

hr
=
11
now
=
=2

!

hr
=
11
now
=
3=4

!

hr
=
11
now
=
7=8

!



3
The
Greek
philosopher
Zeno
p
osed
the
parado
x
that
an
arro
w
rst
had
to
tra
v
el
half
the
distance
to
its
target,
then
the
next
quarter
of
the
distance,
then
the
next
eigh
th,
and
so
on;
th
us
it
should
not
b
e
able
to
land
within
a
nite
length
of
time.

9.4.
ZENO
SPECIFICA
TIONS
129
module
R
TWriteThr
oughCache
extends
WriteThr
oughCache
;
R
e
alTime
const
ant
N
assume
(N
2
Nat
)
^
(Pr
o
c
=
0
:
:
N
 1)
W
e
assume
that
the
set
Pr
o
c
of
pro
cessors
equals
0
:
:
N
 1.
const
ants
Delta
;
Epsilon
;
R
ho
Some
real-time
b
ounds
on
actions.
assume
^
(Delta
2
R
e
al
)
^
(Delta
>
0)
^
(Epsilon
2
R
e
al
)
^
(Epsilon
>
0)
^
(R
ho
2
R
e
al
)
^
(R
ho
>
0)
^
2

(N
+
1)

Epsilon
+
(N
+
QL
en
)

Delta

R
ho
W
e
mo
dify
the
write-through
cac
he
sp
ecication
to
require
that
op
erations
for
dieren
t
pro
cessors
are
enqueued
on
memQ
in
round-robin
order.
v
ariable
lastP
The
last
pro
cessor
to
enqueue
an
op
eration
on
memQ
.
R
TInit

=
Init
^
(lastP
2
Pr
o
c
)
Initially
,
lastP
can
equal
an
y
pro
cessor.
p
osition
(p
)

=
p
is
the
p
osition
(p
)
th
pro
cessor
after
lastP
in
the
round-robin
order.
choose
i
2
1
:
:
N
:
p
=
(lastP
+
i
)
%
N
c
anGoNext
(p
)

=
T
rue
if
pro
cessor
p
can
b
e
the
next
to
enqueue
an
op
eration
on
memQ
.
8
q
2
Pr
o
c
:
(p
osition
(q
)
<
p
osition
(p
))
)
:
enabled
(R
dMiss
(q
)
_
DoWr
(q
))
R
TR
dMiss
(p
)

=
^
c
anGoNext
(p
)
^
R
dMiss
(p
)
^
lastP
0
=
p
Actions
R
TR
dMiss
(p
)
and
R
TDoWr
(p
)
are
the
same
as
R
dMiss
(p
)
and
DoWr
(p
)
except
that
they
are
not
enabled
unless
p
is
the
next
pro
cessor
in
the
round-robin
order
ready
to
enqueue
an
op
eration
on
memQ
,
and
they
set
lastP
to
p
.
R
TDoWr
(p
)

=
^
c
anGoNext
(p
)
^
DoWr
(p
)
^
lastP
0
=
p
R
TNext

=
_
9
p
2
Pr
o
c
:
R
TR
dMiss
(p
)
_
R
TDoWr
(p
)
_
^
_
9
p
2
Pr
o
c
:
_
R
e
q
(p
)
_
Rsp
(p
)
_
DoR
d
(p
)
_
9
a
2
A
dr
:
Evict
(p
;
a
)
_
MemQWr
_
MemQR
d
^
unchanged
lastP
The
next-state
action
R
TNext
is
the
same
as
Next
except
with
R
TR
dMiss
(p
)
and
R
TDoWr
(p
)
replaced
b
y
R
dMiss
(p
)
and
DoWr
(p
),
and
with
other
actions
mo
died
to
lea
v
e
lastP
unc
hanged.
vars

=
h
memInt
;
wmem
;
buf
;
ctl
;
c
ache
;
memQ
;
lastP
i
Figure
9.4a:
A
real-time
v
ersion
of
the
write-through
cac
he
(b
eginning).

130
CHAPTER
9.
REAL
TIME
R
TSp
e
c

=
^
R
TInit
^
2[R
TNext
]
vars
^
R
TBound
(MemQWr
_
MemQR
d
;
vars
;
0;
Delta
)
^
8
p
2
Pr
o
c
:
^
R
TBound
(R
TDoWr
(p
)
_
DoR
d
(p
)
_
Rsp
(p
);
vars
;
0;
Epsilon
)
^
R
TBound
(R
TR
dMiss
(p
);
vars
;
0;
Epsilon
)
^
R
Tnow
(vars
)
W
e
put
an
upp
er-b
ound
de-
la
y
of
Delta
on
MemQWr
and
MemQR
d
actions
(whic
h
dequeue
op
erations
from
memQ
),
and
an
upp
er-b
ound
dela
y
of
Epsilon
on
other
actions.
R
TM

=
inst
ance
R
TMemory
theorem
R
TSp
e
c
)
R
TM
!
R
TSp
e
c
Figure
9.4b:
A
real-time
v
ersion
of
the
write-through
cac
he
(end).
in
whic
h

seconds
nev
er
pass.
W
e
rule
out
suc
h
Zeno
b
eha
viors
b
y
conjoining
to
our
sp
ecication
the
form
ula
R
Tnow
(hr
)|more
precisely
b
y
conjoining
its
liv
eness
conjunct
8
r
2
R
e
al
:
WF
now
(Next
^
(now
0
>
r
))
whic
h
implies
that
time
adv
ances
without
b
ound.
Let's
call
this
form
ula
NZ
(for
Non-Zeno).
Zeno
b
eha
viors
p
ose
no
problem;
they
are
trivially
forbidden
b
y
conjoining
NZ
.
A
problem
do
es
exist
if
a
sp
ecication
allo
ws
only
Zeno
b
eha
viors.
F
or
example,
supp
ose
w
e
conjoined
to
the
un
timed
hour-clo
c
k's
sp
ecication
the
condition
R
TBound
(HCnxt
;
hr
;

;
)
for
some

and

with

>
.
This
w
ould
assert
that
the
clo
c
k
m
ust
w
ait
at
least

seconds
b
efore
tic
king,
but
m
ust
tic
k
within
a
shorter
length
of
time.
In
other
w
ords,
the
clo
c
k
could
nev
er
tic
k.
Only
a
Zeno
b
eha
vior,
in
whic
h

seconds
nev
er
elapsed,
can
satisfy
this
sp
ecication.
Conjoining
NZ
to
this
sp
ecication
yields
a
form
ula
that
allo
ws
no
b
eha
viors|
that
is,
a
form
ula
equiv
alen
t
to
f
alse.
This
example
is
an
extreme
case
of
what
is
called
a
Zeno
sp
e
cic
ation.
A
Zeno
sp
ecication
is
one
for
whic
h
there
exists
a
nite
b
eha
vior

that
satises
the
safet
y
part
but
cannot
b
e
extended
to
an
innite
b
eha
vior
that
satises
b
oth
the
safet
y
part
and
NZ
.
4
In
other
w
ords,
the
only
complete
b
eha
viors
satisfying
the
safet
y
part
that
extend

are
Zeno
b
eha
viors.
A
sp
ecication
that
is
not
Zeno
is,
naturally
enough,
said
to
b
e
non-Zeno.
By
the
denition
of
mac
hine
closure
(in
Section
8.9.2
on
page
111),
a
sp
ecication
is
non-Zeno
i
it
is
mac
hine
closed.
More
precisely
,
it
is
non-Zeno
i
the
pair
of
prop
erties
consisting
of
the
safet
y
part
of
the
sp
ecication
(the
conjunction
of
the
un
timed
sp
ecication,
the
real-time
b
ound
conditions,
and
the
safet
y
part
of
the
R
Tnow
form
ula)
and
NZ
is
mac
hine
closed.
4
Recall
that,
on
page
112,
a
nite
b
eha
vior

w
as
dened
to
satisfy
a
safet
y
prop
ert
y
P
i
adding
innitely
man
y
stuttering
steps
to
the
end
of

pro
duces
a
b
eha
vior
that
satises
P
.

9.4.
ZENO
SPECIFICA
TIONS
131
A
Zeno
sp
ecication
is
one
in
whic
h
the
requiremen
t
that
time
increases
without
b
ound
rules
out
some
nite
b
eha
viors
that
w
ould
otherwise
b
e
allo
w
ed.
Suc
h
a
sp
ecication
is
lik
ely
to
b
e
incorrect
b
ecause
the
real-time
b
ound
condi-
tions
are
probably
constraining
the
system
in
unin
tended
w
a
ys.
In
this
resp
ect,
Zeno
sp
ecications
are
m
uc
h
lik
e
other
non-mac
hine-closed
sp
ecications.
Section
8.9.2
men
tions
that
the
conjunction
of
fairness
conditions
on
subac-
tions
of
the
next-state
relation
pro
duces
a
mac
hine
closed
sp
ecication.
There
is
an
analogous
result
for
R
TBound
conditions
and
non-Zeno
sp
ecications.
A
sp
ecication
is
non-Zeno
if
it
is
the
conjunction
of
(i)
a
form
ula
of
the
form
Init
^
2[Next
]
vars
,
(ii)
the
form
ula
R
Tnow
(vars
),
and
(iii)
a
nite
n
um
b
er
of
form
ulas
of
the
form
R
TBound
(A
i
;
vars
;

i
;

i
),
where
for
eac
h
i

0


i


i

Innity

A
i
is
a
subaction
of
the
next-state
action
Next
.
The
denition
of
a
subaction
app
ears
on
page
111.

No
step
is
b
oth
an
A
i
and
an
A
j
step,
for
an
y
A
j
with
j
6=
i
.
In
particular,
this
implies
that
the
sp
ecication
R
TSp
e
c
of
the
real-time
write-
through
cac
he
in
mo
dule
R
TWriteThr
oughCache
is
non-Zeno.
This
result
do
es
not
apply
to
the
sp
ecication
of
the
real-time
memory
in
mo
dule
R
TMemory
(Figure
9.3
on
page
126)
b
ecause
the
action
R
esp
ond
(p
)
is
not
a
subaction
of
the
next-state
action
INext
of
form
ula
ISp
e
c
.
The
sp
eci-
INext
is
dened
on
page
53
cation
is
nonetheless
non-Zeno,
b
ecause
an
y
nite
b
eha
vior

that
satises
the
sp
ecication
can
b
e
extended
to
one
in
whic
h
time
adv
ances
without
b
ound.
F
or
example,
w
e
can
rst
extend

to
resp
ond
to
all
p
ending
requests
immediately
(in
0
time),
and
then
extend
it
to
an
innite
b
eha
vior
b
y
adding
steps
that
just
increase
now
.
It's
easy
to
construct
an
example
in
whic
h
conjoining
an
R
TBound
form
ula
for
an
action
that
is
not
a
subaction
of
the
next-state
action
pro
duces
a
Zeno
sp
ecication.
F
or
example,
consider
the
form
ula
HC
^
R
TBound
(hr
0
=
hr
 1;
hr
;
0;
3600)
^
R
Tnow
(hr
)
(9.2)
where
HC
is
the
sp
ecication
of
the
hour
clo
c
k.
The
next-state
action
HCnxt
of
HC
asserts
that
hr
is
either
incremen
ted
b
y
1
or
c
hanges
from
12
to
1.
The
R
TBound
form
ula
asserts
that
now
cannot
adv
ance
for
3600
or
more
seconds
without
an
hr
0
=
hr
 1
step
o
ccurring.
Since
HC
asserts
that
ev
ery
step
that
c
hanges
hr
is
an
HCnxt
step,
the
safet
y
part
of
(9.2)
is
satised
only
b
y
b
eha
viors
in
whic
h
now
increases
b
y
less
than
3600
seconds.
Since
the
complete
sp
ecication
(9.2)
con
tains
the
conjunct
NZ
,
whic
h
asserts
that
now
increases
without
b
ound,
it
is
equiv
alen
t
to
f
alse
,
and
is
th
us
a
Zeno
sp
ecication.
When
a
sp
ecication
describ
es
ho
w
a
system
is
implemen
ted,
the
real-time
constrain
ts
are
lik
ely
to
b
e
expressed
as
R
TBound
form
ulas
for
subactions
of
the
next-state
action.
These
are
the
kinds
of
form
ulas
that
corresp
ond
fairly
directly
to
an
implemen
tation.
F
or
example,
mo
dule
R
TWriteThr
oughCache

132
CHAPTER
9.
REAL
TIME
describ
es
an
algorithm
for
implemen
ting
a
memory
,
and
it
has
real-time
b
ounds
on
subactions
of
the
next-state
action.
On
the
other
hand,
more
abstract,
higher-
lev
el
sp
ecications|ones
describing
what
a
system
is
supp
osed
to
do
rather
than
ho
w
to
do
it|are
less
lik
ely
to
ha
v
e
real-time
constrain
ts
expressed
in
this
w
a
y
.
Th
us,
the
high-lev
el
sp
ecication
of
the
real-time
memory
in
mo
dule
R
TMemory
con
tains
an
R
TBound
form
ula
for
an
action
that
is
not
a
subaction
of
the
next-
state
action.
9.5
Hybrid
System
Sp
ecications
A
system
describ
ed
b
y
a
TLA
+
sp
ecication
is
a
ph
ysical
en
tit
y
.
The
sp
ecica-
tion's
v
ariables
represen
t
some
part
of
the
ph
ysical
state|the
displa
y
of
a
clo
c
k,
or
the
distribution
of
c
harge
in
a
piece
of
silicon
that
implemen
ts
a
memory
cell.
In
a
real-time
sp
ecication,
the
v
ariable
now
is
dieren
t
from
the
others
b
ecause
w
e
are
not
abstracting
a
w
a
y
the
con
tin
uous
nature
of
time.
The
sp
ecication
allo
ws
now
to
assume
an
y
of
a
con
tin
uum
of
v
alues.
The
discrete
states
in
a
b
eha
vior
mean
that
w
e
are
observing
the
state
of
the
system,
and
hence
the
v
alue
of
now
,
at
a
sequence
of
discrete
instan
ts.
There
ma
y
b
e
ph
ysical
quan
tities
other
than
time
whose
con
tin
uous
nature
w
e
w
an
t
to
represen
t
in
a
sp
ecication.
F
or
an
air
trac
con
trol
system,
w
e
migh
t
w
an
t
to
represen
t
the
p
ositions
and
v
elo
cities
of
the
aircraft.
F
or
a
system
con
trolling
a
n
uclear
reactor,
w
e
migh
t
w
an
t
to
represen
t
the
ph
ysical
parameters
of
the
reactor
itself.
A
sp
ecication
that
represen
ts
suc
h
con
tin
uously
v
arying
quan
tities
is
called
a
hybrid
system
sp
e
cic
ation.
As
an
example,
consider
a
system
that,
among
other
things,
con
trols
a
switc
h
that
inuences
the
one-dimensional
motion
of
some
ob
ject.
Supp
ose
the
ob
ject's
p
osition
p
ob
eys
one
of
the
follo
wing
la
ws,
dep
ending
on
whether
the
switc
h
is
o
or
on:
d
2
p
=dt
2
+
c

dp
=dt
+
f
[t
]
=
0
d
2
p
=dt
2
+
c

dp
=dt
+
f
[t
]
+
k

p
=
0
(9.3)
where
c
and
k
are
constan
ts,
f
is
some
function,
and
t
represen
ts
time.
A
t
an
y
instan
t,
the
future
p
osition
of
the
ob
ject
is
determined
b
y
the
ob
ject's
curren
t
p
osition
and
v
elo
cit
y
.
So,
the
state
of
the
ob
ject
is
describ
ed
b
y
t
w
o
v
ariables|namely
,
its
p
osition
p
and
its
v
elo
cit
y
w
.
These
v
ariables
are
related
b
y
w
=
dp
=dt
.
W
e
describ
e
this
system
with
a
TLA
+
sp
ecication
in
whic
h
the
v
ariables
p
and
w
are
c
hanged
only
b
y
steps
that
c
hange
now
|that
is,
steps
represen
ting
the
passage
of
time.
W
e
sp
ecify
the
c
hanges
to
the
discrete
system
state
and
an
y
real-time
constrain
ts
as
b
efore.
Ho
w
ev
er,
w
e
replace
R
Tnow
(v
)
with
a
form
ula
ha
ving
the
follo
wing
next-state
action,
where
Inte
gr
ate
and
D
are
explained

9.5.
HYBRID
SYSTEM
SPECIFICA
TIONS
133
b
elo
w,
and
v
is
the
tuple
of
all
discrete
v
ariables:
^
now
0
2
fr
2
R
e
al
:
r
>
now
g
^
h
p
0
;
w
0
i
=
Inte
gr
ate
(D
;
now
;
now
0
;
h
p
;
w
i)
^
unchanged
v
The
discrete
v
ariables
c
hange
instan
taneously
.
The
second
conjunct
asserts
that
p
0
and
w
0
equal
the
expressions
obtained
b
y
solving
the
appropriate
dieren
tial
equation
for
the
ob
ject's
p
osition
and
v
elo
c-
it
y
at
time
now
0
,
assuming
that
their
v
alues
at
time
now
are
p
and
w
.
The
dieren
tial
equation
is
sp
ecied
b
y
D
,
while
Inte
gr
ate
is
a
general
op
erator
for
solving
(in
tegrating)
an
arbitrary
dieren
tial
equation.
T
o
sp
ecify
the
dieren
tial
equation
satised
b
y
the
ob
ject,
let's
supp
ose
that
switchOn
is
a
Bo
olean-v
alued
state
v
ariable
that
describ
es
the
p
osition
of
the
switc
h.
W
e
can
then
rewrite
the
pair
of
equations
(9.3)
as
d
2
p
=dt
2
+
c

dp
=dt
+
f
[t
]
+
(if
switchOn
then
k

p
else
0)
=
0
W
e
then
dene
the
function
D
so
this
equation
can
b
e
written
as
D
[t
;
p
;
dp
=dt
;
d
2
p
=dt
2
]
=
0
Using
the
TLA
+
notation
for
dening
functions
of
m
ultiple
argumen
ts,
whic
h
is
explained
in
Section
16.1.7
on
page
301,
the
denition
is
D
[t
;
p
0;
p
1;
p
2
2
R
e
al
]

=
p
2
+
c

p
1
+
f
[t
]
+
(if
switchOn
then
k

p
0
else
0)
W
e
obtain
the
desired
sp
ecication
if
the
op
erator
Inte
gr
ate
is
dened
so
that
Inte
gr
ate
(D
;
t
0
;
t
1
;
h
x
0
;
:
:
:
;
x
n
 1
i)
is
the
v
alue
at
time
t
1
of
the
n
-tuple
h
x
;
dx
=dt
;
:
:
:
;
d
n
 1
=dt
n
 1
i
where
x
is
a
solution
to
the
dieren
tial
equation
D
[t
;
x
;
dx
=dt
;
:
:
:
;
d
n
x
=ct
n
]
=
0
whose
0
th
through
(n
 1)
st
deriv
ativ
es
at
time
t
0
are
x
0
,
.
.
.
,
x
n
 1
.
The
deni-
tion
of
Inte
gr
ate
app
ears
in
the
Dier
entialEquations
mo
dule
of
Section
11.1.3
(page
174).
In
general,
a
h
ybrid-system
sp
ecication
is
similar
to
a
real-time
sp
ecica-
tion,
except
that
the
form
ula
R
Tnow
(v
)
is
replaced
b
y
one
that
describ
es
the
c
hanges
to
all
v
ariables
that
represen
t
con
tin
uously
c
hanging
ph
ysical
quan
ti-
ties.
The
Inte
gr
ate
op
erator
will
allo
w
y
ou
to
sp
ecify
those
c
hanges
for
man
y
h
ybrid
systems.
Some
systems
will
require
dieren
t
op
erators.
F
or
example,
describing
the
ev
olution
of
some
ph
ysical
quan
tities
migh
t
require
an
op
erator
for
describing
the
solution
to
a
partial
dieren
tial
equation.
Ho
w
ev
er,
if
y
ou
can
describ
e
the
ev
olution
mathematically
,
then
it
can
b
e
sp
ecied
in
TLA
+
.
Hybrid
system
sp
ecications
still
seem
to
b
e
of
only
academic
in
terest,
so
I
w
on't
sa
y
an
y
more
ab
out
them.
If
y
ou
do
ha
v
e
o
ccasion
to
write
one,
this
brief
discussion
should
indicate
ho
w
y
ou
can
do
it.

134
CHAPTER
9.
REAL
TIME
9.6
Remarks
on
Real
Time
Real-time
constrain
ts
are
used
most
often
to
place
an
upp
er
b
ound
on
ho
w
long
it
can
tak
e
the
system
to
do
something.
In
this
capacit
y
,
they
can
b
e
considered
a
strong
form
of
liv
eness,
sp
ecifying
not
just
that
something
m
ust
ev
en
tually
happ
en,
but
when
it
m
ust
happ
en.
In
v
ery
simple
sp
ecications,
suc
h
as
the
hour
clo
c
k
and
the
write-through
cac
he,
real-time
constrain
ts
usually
replace
liv
eness
conditions.
More
complicated
sp
ecications
can
assert
b
oth
real-time
constrain
ts
and
liv
eness
prop
erties.
The
real-time
sp
ecications
I
ha
v
e
seen
ha
v
e
not
required
v
ery
complicated
timing
constrain
ts.
They
ha
v
e
b
een
sp
ecications
either
of
fairly
simple
algo-
rithms
in
whic
h
timing
constrain
ts
are
crucial
to
correctness,
or
of
more
compli-
cated
systems
in
whic
h
real
time
app
ears
only
through
the
use
of
simple
timeouts
to
ensure
liv
eness.
I
susp
ect
that
p
eople
don't
build
systems
with
complicated
real-time
constrain
ts
b
ecause
it's
to
o
hard
to
get
them
righ
t.
I'v
e
describ
ed
ho
w
to
write
a
real-time
sp
ecication
b
y
conjoining
R
Tnow
and
R
TBound
form
ulas
to
an
un
timed
sp
ecication.
One
can
pro
v
e
that
all
real-time
sp
ecications
can
b
e
written
in
this
form.
In
fact,
it
suces
to
use
R
TBound
form
ulas
only
for
subactions
of
the
next-state
action.
Ho
w
ev
er,
this
result
is
of
theoretical
in
terest
only
b
ecause
the
resulting
sp
ecication
can
b
e
incredibly
complicated.
The
op
erators
R
Tnow
and
R
TBound
solv
e
all
the
real-
time
sp
ecication
problems
that
I
ha
v
e
encoun
tered;
but
I
ha
v
en't
encoun
tered
enough
to
sa
y
with
condence
that
they're
all
y
ou
will
ev
er
need.
Still,
I
am
quite
conden
t
that,
whatev
er
real-time
prop
erties
y
ou
ha
v
e
to
sp
ecify
,
it
will
not
b
e
hard
to
express
them
in
TLA
+
.

Chapter
10
Comp
osing
Sp
ecications
Systems
are
usually
describ
ed
in
terms
of
their
comp
onen
ts.
In
the
sp
ecications
w
e'v
e
written
so
far,
the
comp
onen
ts
ha
v
e
b
een
represen
ted
as
separate
disjuncts
of
the
next-state
action.
F
or
example,
the
FIF
O
system
pictured
on
page
35
is
sp
ecied
in
mo
dule
InnerFIF
O
on
page
38
b
y
represen
ting
the
three
comp
onen
ts
with
the
follo
wing
disjuncts
of
the
next-state
action:
Sender:
9
msg
2
Message
:
SSend
(msg
)
Buer:
BufR
cv
_
BufSend
Receiv
er:
RR
cv
In
this
c
hapter,
w
e
learn
ho
w
to
sp
ecify
the
comp
onen
ts
separately
and
comp
ose
their
sp
ecications
to
form
a
single
system
sp
ecication.
Most
of
the
time,
there's
no
p
oin
t
doing
this.
The
t
w
o
w
a
ys
of
writing
the
sp
ecication
dier
b
y
only
a
few
lines|a
trivial
dierence
in
a
sp
ecication
of
h
undreds
or
thousands
of
lines.
Still,
y
ou
ma
y
encoun
ter
a
situation
in
whic
h
it's
b
etter
to
sp
ecify
a
system
as
a
comp
osition.
First,
w
e
m
ust
understand
what
it
means
to
comp
ose
sp
ecications.
W
e
usu-
ally
sa
y
that
a
TLA
form
ula
sp
ecies
the
correct
b
eha
vior
of
a
system.
Ho
w
ev
er,
as
explained
in
Section
2.3
(page
18),
a
b
eha
vior
actually
represen
ts
a
p
ossible
history
of
the
en
tire
univ
erse,
not
just
of
the
system.
So,
it
w
ould
b
e
more
accurate
to
sa
y
that
a
TLA
form
ula
sp
ecies
a
univ
erse
in
whic
h
the
system
b
eha
v
es
correctly
.
Building
a
system
that
implemen
ts
a
sp
ecication
F
means
constructing
the
univ
erse
so
it
satises
F
.
(F
ortunately
,
correctness
of
the
sys-
tem
dep
ends
on
the
b
eha
vior
of
only
a
tin
y
part
of
the
univ
erse,
and
that's
the
only
part
w
e
m
ust
build.)
Comp
osing
t
w
o
systems
whose
sp
ecications
are
F
and
G
means
making
the
univ
erse
satisfy
b
oth
F
and
G
,
whic
h
is
the
same
as
making
it
satisfy
F
^
G
.
Th
us,
the
sp
ecication
of
the
comp
osition
of
t
w
o
systems
is
the
conjunction
of
their
sp
ecications.
135

136
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
W
riting
a
sp
ecication
as
the
comp
osition
of
its
comp
onen
ts
therefore
means
writing
the
sp
ecication
as
a
conjunction,
eac
h
conjunct
of
whic
h
can
b
e
view
ed
as
the
sp
ecication
of
a
comp
onen
t.
While
the
basic
idea
is
simple,
the
details
are
not
alw
a
ys
ob
vious.
T
o
simplify
the
exp
osition,
I
b
egin
b
y
considering
only
safet
y
prop
erties,
ignoring
liv
eness
and
largely
ignoring
hiding.
Liv
eness
and
hiding
are
discussed
in
Section
10.6.
10.1
Comp
osing
Tw
o
Sp
ecications
Let's
return
once
again
to
the
simple
hour
clo
c
k,
with
no
liv
eness
or
real-time
requiremen
t.
In
Chapter
2,
w
e
sp
ecied
suc
h
a
clo
c
k
whose
displa
y
is
represen
ted
b
y
the
v
ariable
hr
.
W
e
can
write
that
sp
ecication
as
(hr
2
1
:
:
12)
^
2[HCN
(hr
)]
hr
where
HCN
is
dened
b
y
HCN
(h
)

=
h
0
=
(h
%
12)
+
1
No
w
let's
write
a
sp
ecication
TwoClo
cks
of
a
system
comp
osed
of
t
w
o
separate
hour
clo
c
ks,
whose
displa
ys
are
represen
ted
b
y
the
v
ariables
x
and
y
.
(The
t
w
o
clo
c
ks
are
not
sync
hronized
and
are
completely
indep
enden
t
of
one
another.)
W
e
can
just
dene
TwoClo
cks
to
b
e
the
conjunction
of
the
t
w
o
clo
c
k
sp
ecications
TwoClo
cks

=
^
(x
2
1
:
:
12)
^
2[HCN
(x
)]
x
^
(y
2
1
:
:
12)
^
2[HCN
(y
)]
y
The
follo
wing
calculation
sho
ws
ho
w
w
e
can
rewrite
TwoClo
cks
in
the
usual
form
as
a
\monolithic"
sp
ecication
with
a
single
next-state
action:
1
TwoClo
cks

^
(x
2
1
:
:
12)
^
(y
2
1
:
:
12)
^
2[HCN
(x
)]
x
^
2[HCN
(y
)]
y

^
(x
2
1
:
:
12)
^
(y
2
1
:
:
12)
^
2
(
[HCN
(x
)]
x
^
[HCN
(y
)]
y
)
Because
2(F
^
G
)

(2F
)
^
(2G
).

^
(x
2
1
:
:
12)
^
(y
2
1
:
:
12)
^
2
(
^
HCN
(x
)
_
x
0
=
x
^
HCN
(y
)
_
y
0
=
y
)
By
denition
of
[:
:
:
]
x
and
[:
:
:
]
y
.
1
This
calculation
is
informal
b
ecause
it
con
tains
form
ulas
that
are
not
legal
TLA|namely
,
ones
of
the
form
2A
where
A
is
an
action
that
do
esn't
ha
v
e
the
syn
tactic
form
[B
]
v
.
Ho
w
ev
er,
it
can
b
e
done
rigorously
.

10.1.
COMPOSING
TW
O
SPECIFICA
TIONS
137

^
(x
2
1
:
:
12)
^
(y
2
1
:
:
12)
^
2
(
_
HCN
(x
)
^
HCN
(y
)
_
HCN
(x
)
^
(y
0
=
y
)
_
HCN
(y
)
^
(x
0
=
x
)
_
(x
0
=
x
)
^
(y
0
=
y
)
)
Because:
0
@
^
_
A
1
_
A
2
^
_
B
1
_
B
2
1
A

0
@
_
A
1
^
B
1
_
A
1
^
B
2
_
A
2
^
B
1
_
A
2
^
B
2
1
A

^
(x
2
1
:
:
12)
^
(y
2
1
:
:
12)
^
2
[
_
HCN
(x
)
^
HCN
(y
)
_
HCN
(x
)
^
(y
0
=
y
)
_
HCN
(y
)
^
(x
0
=
x
)
]
h
x
;
y
i
By
denition
of
[:
:
:
]
h
x
;
y
i
.
Th
us,
TwoClo
cks
is
equiv
alen
t
to
Init
^
2[TCNxt
]
h
x
;
y
i
where
the
next-state
action
TCNxt
is
TCnxt

=
_
HCN
(x
)
^
HCN
(y
)
_
HCN
(x
)
^
(y
0
=
y
)
_
HCN
(y
)
^
(x
0
=
x
)
This
next-state
action
diers
from
the
ones
w
e
are
used
to
writing
b
ecause
of
the
disjunct
HCN
(x
)
^
HCN
(y
),
whic
h
represen
ts
the
sim
ultaneous
adv
ance
of
the
t
w
o
displa
ys.
In
the
sp
ecications
w
e
ha
v
e
written
so
far,
dieren
t
comp
onen
ts
nev
er
act
sim
ultaneously
.
Up
un
til
no
w,
w
e
ha
v
e
b
een
writing
what
are
called
interle
aving
sp
ecica-
tions.
In
an
in
terlea
ving
sp
ecication,
eac
h
step
represen
ts
an
op
eration
of
only
one
comp
onen
t.
F
or
example,
in
our
FIF
O
sp
ecication,
a
(nonstuttering)
step
represen
ts
an
action
of
either
the
sender,
the
buer,
or
the
receiv
er.
F
or
w
an
t
of
a
b
etter
term,
w
e
describ
e
as
noninterle
aving
a
sp
ecication
that,
lik
e
TwoClo
cks
,
do
es
p
ermit
sim
ultaneous
actions
b
y
t
w
o
comp
onen
ts.
Supp
ose
w
e
w
an
t
to
write
an
in
terlea
ving
sp
ecication
of
the
t
w
o-clo
c
k
sys-
tem
as
the
conjunction
of
t
w
o
comp
onen
t
sp
ecications.
One
w
a
y
is
to
replace
the
next-state
actions
HCN
(x
)
and
HCN
(y
)
of
the
t
w
o
comp
onen
ts
b
y
t
w
o
ac-
tions
HCNx
and
HCNy
so
that,
when
w
e
p
erform
the
analogous
calculation
to
the
one
ab
o
v
e,
w
e
get

^
(x
2
1
:
:
12)
^
2[HCNx
]
x
^
(y
2
1
:
:
12)
^
2[HCNy
]
y


0
@
^
(x
2
1
:
:
12)
^
(y
2
1
:
:
12)
^
2
[
_
HCNx
^
(y
0
=
y
)
_
HCNy
^
(x
0
=
x
)
]
h
x
;
y
i
1
A
F
rom
the
calculation
ab
o
v
e,
w
e
see
that
this
equiv
alence
holds
if
the
follo
wing
three
conditions
are
satised:
(i)
HCNx
implies
HCN
(x
),
(ii)
HCNy
implies
HCN
(y
),
and
(iii)
HCNx
^
HCNy
implies
x
0
=
x
or
y
0
=
y
.
(Condition
(iii)
implies
that
the
disjunct
HCNx
^
HCNy
of
the
next-state
action
is
subsumed
b
y
one
of
the
disjuncts
HCNx
^
(y
0
=
y
)
and
HCNy
^
(x
0
=
x
).)
The
common
w
a
y

138
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
of
satisfying
these
conditions
is
to
let
the
next-state
action
of
eac
h
clo
c
k
assert
that
the
other
clo
c
k's
displa
y
is
unc
hanged.
W
e
do
this
b
y
dening
HCNx

=
HCN
(x
)
^
(y
0
=
y
)
HCNy

=
HCN
(y
)
^
(x
0
=
x
)
Another
w
a
y
to
write
an
in
terlea
ving
sp
ecication
is
simply
to
disallo
w
si-
m
ultaneous
c
hanges
to
b
oth
clo
c
k
displa
ys.
W
e
can
do
this
b
y
taking
as
our
sp
ecication
the
form
ula
TwoClo
cks
^
2[(x
0
=
x
)
_
(y
0
=
y
)]
h
x
;
y
i
The
second
conjunct
asserts
that
an
y
step
m
ust
lea
v
e
x
or
y
(or
b
oth)
unc
hanged.
Ev
erything
w
e
ha
v
e
done
for
the
t
w
o-clo
c
k
system
generalizes
to
an
y
system
comprising
t
w
o
comp
onen
ts.
The
same
calculation
as
ab
o
v
e
sho
ws
that
if
(v
1
0
=
v
1
)
^
(v
2
0
=
v
2
)

(v
0
=
v
)
This
asserts
that
v
is
unc
hanged
i
b
oth
v
1
and
v
2
are.
then

^
I
1
^
2[N
1
]
v
1
^
I
2
^
2[N
2
]
v
2


0
B
B
@
^
I
1
^
I
2
^
2
[
_
N
1
^
N
2
_
N
1
^
(v
2
0
=
v
2
)
_
N
2
^
(v
1
0
=
v
1
)
]
v
1
C
C
A
(10.1)
for
an
y
state
predicates
I
1
and
I
2
and
an
y
actions
N
1
and
N
2
.
The
left-hand
side
of
this
equiv
alence
represen
ts
the
comp
osition
of
t
w
o
comp
onen
t
sp
ecications
if
v
k
is
a
tuple
con
taining
the
v
ariables
that
describ
e
the
k
th
comp
onen
t,
for
k
=
1;
2,
and
v
is
the
tuple
of
all
the
v
ariables.
The
equiv
alen
t
form
ulas
in
(10.1)
represen
t
an
in
terlea
ving
sp
ecication
if
the
rst
disjunct
in
the
next-state
action
of
the
righ
t-hand
side
is
redundan
t,
so
it
can
b
e
remo
v
ed.
This
is
the
case
if
N
1
^
N
2
implies
that
v
1
or
v
2
is
unc
hanged.
The
usual
w
a
y
to
ensure
that
this
condition
is
satised
is
b
y
dening
eac
h
N
k
so
it
implies
that
the
other
comp
onen
t's
tuple
is
left
unc
hanged.
Another
w
a
y
to
obtain
an
in
terlea
ving
sp
ecication
is
b
y
conjoining
the
form
ula
2[(v
1
0
=
v
1
)
_
(v
2
0
=
v
2
)
]
v
.
10.2
Comp
osing
Man
y
Sp
ecications
W
e
can
generalize
(10.1)
to
the
comp
osition
of
an
y
set
C
of
comp
onen
ts.
Be-
cause
univ
ersal
quan
tication
generalizes
conjunction,
the
follo
wing
rule
is
a
generalization
of
(10.1):
Comp
osition
Rule
F
or
an
y
set
C
,
if
(8
k
2
C
:
v
k
0
=
v
k
)

(v
0
=
v
)
This
asserts
that
v
is
unc
hanged
i
all
the
v
k
are.

10.2.
COMPOSING
MANY
SPECIFICA
TIONS
139
then
(8
k
2
C
:
I
k
^
2[N
k
]
v
k
)

^
8
k
2
C
:
I
k
^
2

_
9
k
2
C
:
N
k
^
(8
i
2
C
n
fk
g
:
v
i
0
=
v
i
)
_
9
i
;
j
2
C
:
(i
6=
j
)
^
N
i
^
N
j
^
F
ij

v
for
some
actions
F
ij
.
The
second
disjunct
of
the
next-state
action
is
redundan
t,
and
w
e
ha
v
e
an
in-
terlea
ving
sp
ecication,
if
eac
h
N
i
implies
that
v
j
is
unc
hanged,
for
all
j
6=
i
.
Ho
w
ev
er,
for
this
to
hold,
N
i
m
ust
men
tion
v
j
for
comp
onen
ts
j
other
than
i
.
Y
ou
migh
t
ob
ject
to
this
approac
h|either
on
philosophical
grounds,
b
ecause
y
ou
feel
that
the
sp
ecication
of
one
comp
onen
t
should
not
men
tion
the
state
of
another
comp
onen
t,
or
b
ecause
men
tioning
other
comp
onen
t's
v
ariables
compli-
cates
the
comp
onen
t's
sp
ecication.
An
alternativ
e
approac
h
is
simply
to
assert
in
terlea
ving.
Y
ou
can
do
this
b
y
conjoining
the
follo
wing
form
ula,
whic
h
states
that
no
step
c
hanges
b
oth
v
i
and
v
j
,
for
an
y
i
and
j
with
i
6=
j
:
2
[
9
k
2
C
:
8
i
2
C
n
fk
g
:
v
i
0
=
v
i
]
v
This
conjunct
can
b
e
view
ed
as
a
global
condition,
not
attac
hed
to
an
y
comp
o-
nen
t's
sp
ecication.
F
or
the
left-hand
side
of
the
conclusion
of
the
Comp
osition
Rule
to
represen
t
the
comp
osition
of
separate
comp
onen
ts,
the
v
k
need
not
b
e
comp
osed
of
sep-
arate
v
ariables.
They
could
con
tain
dieren
t
\parts"
of
the
same
v
ariable
that
describ
e
dieren
t
comp
onen
ts.
F
or
example,
our
system
migh
t
consist
of
a
set
Clo
ck
of
separate,
indep
enden
t
clo
c
ks,
where
clo
c
k
k
's
displa
y
is
describ
ed
b
y
the
v
alue
of
hr
[k
].
Then
v
k
w
ould
equal
hr
[k
].
It's
easy
to
sp
ecify
suc
h
an
arra
y
of
clo
c
ks
as
a
comp
osition.
Using
the
denition
of
HCN
on
page
136
ab
o
v
e,
w
e
can
write
the
sp
ecication
as
Clo
ckA
rr
ay

=
8
k
2
Clo
ck
:
(hr
[k
]
2
1
:
:
12)
^
2[HCN
(hr
[k
])]
hr
[k
]
(10.2)
This
is
a
nonin
terlea
ving
sp
ecication,
since
it
allo
ws
sim
ultaneous
steps
b
y
dieren
t
clo
c
ks.
Supp
ose
w
e
w
an
ted
to
use
the
Comp
osition
Rule
to
express
Clo
ckA
rr
ay
as
a
monolithic
sp
ecication.
What
w
ould
w
e
substitute
for
v
?
Our
rst
though
t
is
to
substitute
hr
for
v
.
Ho
w
ev
er,
the
h
yp
othesis
of
the
rule
requires
that
v
m
ust
b
e
left
unc
hanged
i
hr
[k
]
is
left
unc
hanged,
for
all
k
2
Clo
ck
.
Ho
w
ev
er,
as
explained
in
Section
6.5
on
page
72,
sp
ecifying
the
v
alues
of
hr
[k
]
0
for
all
k
2
Clo
ck
do
es
not
sp
ecify
the
v
alue
of
hr
.
It
do
esn't
ev
en
imply
that
hr
is
a
function.
W
e
m
ust
substitute
for
v
the
function
hrfcn
dened
b
y
hrfcn

=
[k
2
Clo
ck
7!
hr
[k
]]
(10.3)

140
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
The
function
hrfcn
equals
hr
i
hr
is
a
function
with
domain
Clo
ck
.
F
orm
ula
Clo
ckA
rr
ay
do
es
not
imply
that
hr
is
alw
a
ys
a
function.
It
sp
ecies
the
p
ossible
v
alues
of
hr
[k
],
for
all
k
2
Clo
ck
,
but
it
do
esn't
sp
ecify
the
v
alue
of
hr
.
Ev
en
if
w
e
c
hanged
the
initial
condition
to
imply
that
hr
is
initially
a
function
with
domain
Clo
ck
,
form
ula
Clo
ckA
rr
ay
w
ould
not
imply
that
hr
is
alw
a
ys
a
function.
F
or
example,
it
w
ould
still
allo
w
\stuttering"
steps
that
lea
v
e
eac
h
hr
[k
]
unc
hanged,
but
c
hange
hr
in
unkno
wn
w
a
ys.
W
e
migh
t
prefer
to
write
a
sp
ecication
in
whic
h
hr
is
a
function
with
domain
Clo
ck
.
One
w
a
y
of
doing
this
is
to
conjoin
to
the
sp
ecication
the
form
ula
2IsFcnOn
(hr
;
Clo
ck
),
where
IsFcnOn
(hr
;
Clo
ck
)
asserts
that
hr
is
an
arbitrary
function
with
domain
Clo
ck
.
The
op
erator
IsFcnOn
is
dened
b
y
IsFcnOn
(f
;
S
)

=
f
=
[x
2
S
7!
f
[x
]]
W
e
can
view
the
form
ula
2IsFcnOn
(hr
;
Clo
ck
)
as
a
global
constrain
t
on
hr
,
while
the
v
alue
of
hr
[k
]
for
eac
h
comp
onen
t
k
is
describ
ed
b
y
that
comp
onen
t's
sp
ecication.
No
w,
supp
ose
w
e
w
an
t
to
write
an
in
terlea
ving
sp
ecication
of
the
arra
y
of
clo
c
ks
as
the
comp
osition
of
sp
ecications
of
the
individual
clo
c
ks.
In
general,
the
conjunction
in
the
Comp
osition
Rule
is
an
in
terlea
ving
sp
ecication
if
eac
h
N
k
implies
that
v
i
is
unc
hanged,
for
all
i
6=
k
.
So,
w
e
w
an
t
the
next-state
action
N
k
of
clo
c
k
k
to
imply
that
hr
[i
]
is
unc
hanged
for
ev
ery
clo
c
k
i
other
than
k
.
The
most
ob
vious
w
a
y
to
do
this
is
to
dene
N
k
to
equal
^
hr
0
[k
]
=
(hr
[k
]
%
12)
+
1
^
8
i
2
Clo
ck
n
fk
g
:
hr
0
[i
]
=
hr
[i
]
W
e
can
express
this
form
ula
more
compactly
using
the
ex
cept
construct.
This
The
ex
cept
con-
struct
is
explained
in
Section
5.2
on
page
48.
construct
applies
only
to
functions,
so
w
e
m
ust
c
ho
ose
whether
or
not
to
require
hr
to
b
e
a
function.
If
hr
is
a
function,
then
w
e
can
let
N
k
equal
hr
0
=
[hr
ex
cept
!
[k
]
=
(hr
[k
]
%
12)
+
1]
(10.4)
As
noted
ab
o
v
e,
w
e
can
ensure
that
hr
is
a
function
b
y
conjoining
the
form
ula
2IsFcnOn
(hr
;
Clo
ck
)
to
the
sp
ecication.
Another
w
a
y
is
to
dene
the
state
function
hrfcn
b
y
(10.3)
on
the
preceding
page
and
let
N
(k
)
equal
hrfcn
0
=
[hrfcn
ex
cept
!
[k
]
=
(hr
[k
]
%
12)
+
1]
A
sp
ecication
is
just
a
mathematical
form
ula;
as
w
e'v
e
seen
b
efore,
there
are
often
man
y
equiv
alen
t
w
a
ys
of
writing
a
form
ula.
Whic
h
one
y
ou
c
ho
ose
is
usually
a
matter
of
taste.
10.3
The
FIF
O
Let's
no
w
sp
ecify
the
FIF
O,
describ
ed
in
Chapter
4,
as
the
comp
osition
of
its
three
comp
onen
ts|the
Sender,
the
Buer,
and
the
Receiv
er.
W
e
start
with
the

10.3.
THE
FIF
O
141
in
ternal
sp
ecication,
in
whic
h
the
v
ariable
q
o
ccurs|that
is,
q
is
not
hidden.
First,
w
e
decide
what
part
of
the
state
describ
es
eac
h
comp
onen
t.
The
v
ariables
in
and
out
are
c
hannels.
Recall
that
the
Channel
mo
dule
(page
30)
sp
ecies
a
c
hannel
chan
to
b
e
a
record
with
val
,
r
dy
,
and
ack
comp
onen
ts.
The
Send
action,
whic
h
sends
a
v
alue,
mo
dies
the
val
and
r
dy
comp
onen
ts;
the
R
cv
action,
whic
h
receiv
es
a
v
alue,
mo
dies
the
ack
comp
onen
t.
So,
the
comp
onen
ts'
states
are
describ
ed
b
y
the
follo
wing
state
functions:
Sender:
h
in
:val
;
in
:r
dy
i
Buer:
h
in
:ack
;
q
;
out
:val
;
out
:r
dy
i
Receiv
er:
out
:ack
Unfortunately
,
w
e
can't
reuse
the
denitions
from
the
InnerFIF
O
mo
dule
on
page
38
for
the
follo
wing
reason.
The
v
ariable
q
,
whic
h
is
hidden
in
the
nal
sp
ecication,
is
part
of
the
Buer
comp
onen
t's
in
ternal
state.
Therefore,
it
should
not
app
ear
in
the
sp
ecications
of
the
Sender
or
Receiv
er
comp
onen
t.
The
Sender
and
Receiv
er
actions
dened
in
the
InnerFIF
O
mo
dule
all
men
tion
q
,
so
w
e
can't
use
them.
W
e
therefore
w
on't
b
other
reusing
that
mo
dule.
Ho
w
ev
er,
instead
of
starting
completely
from
scratc
h,
w
e
can
mak
e
use
of
the
Send
and
R
cv
actions
from
the
Channel
mo
dule
on
page
30
to
describ
e
the
c
hanges
to
in
and
out
.
Let's
write
a
nonin
terlea
ving
sp
ecication.
The
next-state
actions
of
the
comp
onen
ts
are
then
the
same
as
the
corresp
onding
disjuncts
of
the
Next
ac-
tion
in
mo
dule
InnerFIF
O
,
except
that
they
do
not
men
tion
the
parts
of
the
states
b
elonging
to
the
other
comp
onen
ts.
These
con
tain
Send
and
R
cv
actions,
instan
tiated
from
the
Channel
mo
dule,
whic
h
use
the
ex
cept
construct.
As
noted
ab
o
v
e,
w
e
can
apply
ex
cept
only
to
functions|and
to
records,
whic
h
are
Section
5.2
on
page
48
explains
wh
y
records
are
functions.
functions.
W
e
therefore
add
to
our
sp
ecication
the
conjunct
2(IsChannel
(in
)
^
IsChannel
(out
))
where
IsChannel
(c
)
asserts
that
c
is
a
c
hannel|that
is
a
record
with
val
,
ack
,
and
r
dy
elds.
Since
a
record
with
val
,
ack
,
and
r
dy
elds
is
a
func-
tion
whose
domain
is
f\val"
;
\ack"
;
\rdy"g,
w
e
can
dene
IsChannel
(c
)
to
equal
IsFcnOn
(c
;
f\val"
;
\ack"
;
\rdy"g).
Ho
w
ev
er,
it's
just
as
easy
to
dene
form
ula
IsChannel
(c
)
directly
b
y
IsChannel
(c
)

=
c
=
[ack
7!
c
:ack
;
val
7!
c
:val
;
r
dy
7!
c
:r
dy
]
In
writing
this
sp
ecication,
w
e
face
the
same
problem
as
in
our
original
FIF
O
sp
ecication
of
in
tro
ducing
the
v
ariable
q
and
then
hiding
it.
In
Chapter
4,
w
e
solv
ed
this
problem
b
y
in
tro
ducing
q
in
a
separate
InnerFIF
O
mo
dule,
whic
h
is
instan
tiated
b
y
the
FIF
O
mo
dule
that
denes
the
nal
sp
ecication.
W
e
do
essen
tially
the
same
thing
here,
except
that
w
e
in
tro
duce
q
in
a
submo
dule

142
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
instead
of
in
a
completely
separate
mo
dule.
All
the
sym
b
ols
declared
and
dened
at
the
p
oin
t
where
the
submo
dule
app
ears
can
b
e
used
within
it.
The
submo
dule
itself
can
b
e
instan
tiated
in
the
con
taining
mo
dule
an
ywhere
after
it
app
ears.
(Submo
dules
are
used
in
the
R
e
alTimeHourClo
ck
and
R
TMemory
sp
ecications
on
pages
121
and
126
of
Chapter
9.)
There
is
one
small
problem
to
b
e
solv
ed
b
efore
w
e
can
write
a
comp
osite
sp
ecication
of
the
FIF
O|ho
w
to
sp
ecify
the
initial
predicates.
It
mak
es
sense
for
the
initial
predicate
of
eac
h
comp
onen
t's
sp
ecication
to
sp
ecify
the
initial
v
alues
of
its
part
of
the
state.
Ho
w
ev
er
the
initial
condition
includes
the
require-
men
ts
in
:ack
=
in
:r
dy
and
out
:ack
=
out
:r
dy
,
eac
h
of
whic
h
relates
the
initial
states
of
t
w
o
dieren
t
comp
onen
ts.
(These
requiremen
ts
are
stated
in
mo
dule
InnerFIF
O
b
y
the
conjuncts
InChan
!
Init
and
OutChan
!
Init
of
the
initial
pred-
icate
Init
.)
There
are
three
w
a
ys
of
expressing
a
requiremen
t
that
relates
the
initial
states
of
m
ultiple
comp
onen
ts:

Assert
it
in
the
initial
conditions
of
all
the
comp
onen
ts.
Although
sym-
metric,
this
seems
needlessly
redundan
t.

Arbitrarily
assign
the
requiremen
t
to
one
of
the
comp
onen
ts.
This
in
tu-
itiv
ely
suggests
that
w
e
are
assigning
to
that
comp
onen
t
the
resp
onsibilit
y
of
ensuring
that
the
requiremen
t
is
met.

Assert
the
requiremen
t
as
a
conjunct
separate
from
either
of
the
comp
onen
t
sp
ecications.
This
in
tuitiv
ely
suggests
that
it
is
an
assumption
ab
out
ho
w
the
comp
onen
ts
are
put
together,
rather
than
a
requiremen
t
of
either
comp
onen
t.
When
w
e
write
an
op
en-system
sp
ecication,
as
describ
ed
in
Section
10.7
b
elo
w,
the
in
tuitiv
e
suggestions
of
the
last
t
w
o
approac
hes
can
b
e
turned
in
to
formal
requiremen
ts.
I'v
e
tak
en
the
last
approac
h
and
added
(in
:ack
=
in
:r
dy
)
^
(out
:ack
=
out
:r
dy
)
as
a
separate
condition.
The
complete
sp
ecication
is
in
mo
dule
Comp
ositeFIF
O
of
Figure
10.1
on
the
next
page.
F
orm
ula
Sp
e
c
of
this
mo
dule
is
a
nonin
terlea
ving
sp
ecication;
for
example,
it
allo
ws
a
single
step
that
is
b
oth
an
InChan
!
Send
step
(the
sender
sends
a
v
alue)
and
an
OutChan
!
R
cv
step
(the
receiv
er
ac
kno
wl-
edges
a
v
alue).
Hence,
it
is
not
equiv
alen
t
to
the
in
terlea
ving
sp
ecication
Sp
e
c
of
the
FIF
O
mo
dule
on
page
41,
whic
h
do
es
not
allo
w
suc
h
a
step.
10.4
Comp
osition
with
Shared
State
Th
us
far,
w
e
ha
v
e
b
een
considering
disjoint-state
c
omp
ositions
|ones
in
whic
h
the
comp
onen
ts
are
represen
ted
b
y
disjoin
t
parts
of
the
state,
and
a
comp
o-

10.4.
COMPOSITION
WITH
SHARED
ST
A
TE
143
module
Comp
ositeFIF
O
extends
Natur
als,
Se
quenc
es
const
ant
Message
v
ariables
in,
out
InChan

=
inst
ance
Channel
with
Data
 
Message
;
chan
 
in
OutChan

=
inst
ance
Channel
with
Data
 
Message
;
chan
 
out
SenderInit

=
(in
:r
dy
2
f0;
1g)
^
(in
:val
2
Message
)
Sender

=
SenderInit
^
2
[
9
msg
2
Message
:
InChan
!
Send
(msg
)
]
h
in
:val
;
in
:r
dy
i
The
Sender's
sp
ecication.
module
InnerBuf
v
ariable
q
BuerInit

=
^
in
:ack
2
f0;
1g
^
q
=
h
i
^
(out
:r
dy
2
f0;
1g)
^
(out
:val
2
Message
)
The
Buer's
in
ternal
sp
ecication,
with
q
visible.
BufR
cv

=
^
InChan
!
R
cv
^
q
0
=
App
end
(q
;
in
:val
)
^
unchanged
h
out
:val
;
out
:r
dy
i
BufSend

=
^
q
6=
h
i
^
OutChan
!
Send
(He
ad
(q
))
^
q
0
=
T
ail
(q
)
^
unchanged
in
:ack
InnerBuer

=
BuerInit
^
2[BufR
cv
_
BufSend
]
h
in
:ack
;
q
;
out
:val
;
out
:r
dy
i
Buf
(q
)

=
inst
ance
InnerBuf
Buer

=
9
9
9
9
9
9
q
:
Buf
(q
)
!
InnerBuer
The
Buer's
external
sp
ecication
with
q
hidden.
R
e
c
eiverInit

=
out
:ack
2
f0;
1g
R
e
c
eiver

=
R
e
c
eiverInit
^
2[OutChan
!
R
cv
]
out
:ack
The
Receiv
er's
sp
ecication.
IsChannel
(c
)

=
c
=
[ack
7!
c
:ack
;
val
7!
c
:val
;
r
dy
7!
c
:r
dy
]
Sp
e
c

=
^
2(IsChannel
(in
)
^
IsChannel
(out
))
^
(in
:ack
=
in
:r
dy
)
^
(out
:ack
=
out
:r
dy
)
^
Sender
^
Buer
^
R
e
c
eiver
Asserts
that
in
and
out
are
alw
a
ys
records.
Relates
dieren
t
comp
onen
ts'
initial
states.
Conjoins
the
three
sp
ecications.
Figure
10.1:
A
nonin
terlea
ving
comp
osite
sp
ecication
of
the
FIF
O.

144
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
nen
t's
next-state
action
describ
es
c
hanges
only
to
its
part
of
the
state.
2
W
e
no
w
consider
the
case
when
this
ma
y
not
b
e
p
ossible.
10.4.1
Explicit
State
Changes
W
e
rst
examine
the
situation
in
whic
h
some
part
of
the
state
cannot
b
e
parti-
tioned
among
the
dieren
t
comp
onen
ts,
but
the
state
c
hange
that
eac
h
comp
o-
nen
t
p
erforms
is
completely
describ
ed
b
y
the
sp
ecication.
As
an
example,
let's
again
consider
a
Sender
and
a
Receiv
er
that
comm
unicate
with
a
FIF
O
buer.
In
the
system
w
e
studied
in
Chapter
4,
sending
or
receiving
a
v
alue
required
t
w
o
steps.
F
or
example,
the
Sender
executes
a
Send
step
to
send
a
v
alue,
and
it
m
ust
then
w
ait
un
til
the
buer
executes
a
R
cv
step
b
efore
it
can
send
another
v
alue.
W
e
simplify
the
system
b
y
replacing
the
Buer
comp
onen
t
with
a
v
ariable
buf
whose
v
alue
is
the
sequence
of
v
alues
sen
t
b
y
the
Sender
but
not
y
et
receiv
ed
b
y
the
Receiv
er.
This
replaces
the
three-comp
onen
t
system
pictured
on
page
35
with
this
t
w
o-comp
onen
t
one:
Sender
Receiv
er
buf
-
The
Sender
sends
a
v
alue
b
y
app
ending
it
to
the
end
of
buf
;
the
Receiv
er
receiv
es
a
v
alue
b
y
remo
ving
it
from
the
head
of
buf
.
In
general,
the
Sender
p
erforms
some
computation
to
pro
duce
the
v
alues
that
it
sends,
and
the
Receiv
er
do
es
some
computation
on
the
v
alues
that
it
receiv
es.
The
system
state
consists
of
buf
and
t
w
o
tuples
s
and
r
of
v
ariables
that
describ
e
the
Sender
and
Receiv
er
states.
In
a
monolithic
sp
ecication,
the
system's
next-state
action
is
a
disjunction
Sndr
_
R
cvr
,
where
Sndr
and
R
cvr
describ
e
steps
tak
en
b
y
the
Sender
and
Receiv
er,
resp
ectiv
ely
.
These
actions
are
dened
b
y
Sndr

=
_
^
buf
0
=
App
end
(buf
;
:
:
:)
^
SComm
^
unchanged
r
_
^
SCompute
^
unchanged
h
buf
;
r
i
R
cvr

=
_
^
buf
6=
h
i
^
buf
0
=
T
ail
(buf
)
^
R
Comm
^
unchanged
s
_
^
R
Compute
^
unchanged
h
buf
;
s
i
2
In
an
in
terlea
ving
comp
osition,
a
comp
onen
t
sp
ecication
ma
y
assert
that
the
state
of
other
comp
onen
ts
is
not
c
hanged.

10.4.
COMPOSITION
WITH
SHARED
ST
A
TE
145
for
some
actions
SComm
,
SCompute
,
R
Comm
,
and
R
Compute
.
F
or
simplicit
y
,
w
e
assume
that
neither
Sndr
nor
R
cvr
allo
ws
stuttering
actions,
so
SCompute
c
hanges
s
and
R
Compute
c
hanges
r
.
W
e
no
w
write
the
sp
ecication
as
the
comp
osition
of
separate
sp
ecications
of
the
Sender
and
Receiv
er.
Splitting
the
initial
predicate
is
straigh
tforw
ard.
The
initial
conditions
on
s
b
elong
to
the
Sender's
initial
predicate;
those
on
r
b
elong
to
the
Receiv
er's
initial
predicate;
and
the
initial
condition
buf
=
h
i
can
b
e
assigned
arbitrarily
to
either
of
them.
No
w
let's
consider
the
next-state
actions
NS
and
NR
of
the
Sender
and
Receiv
er
comp
onen
ts.
The
tric
k
is
to
dene
them
b
y
NS

=
Sndr
_
(
^
(s
0
=
s
))
NR

=
R
cvr
_
(
^
(r
0
=
r
))
where

and

are
actions
con
taining
only
the
v
ariable
buf
.
Think
of

as
describing
p
ossible
c
hanges
to
buf
that
are
not
caused
b
y
the
Sender,
and

as
describing
p
ossible
c
hanges
to
buf
that
are
not
caused
b
y
the
Receiv
er.
Th
us,
NS
p
ermits
an
y
step
that
is
either
a
Sndr
step
or
one
that
lea
v
es
s
unc
hanged
and
is
a
c
hange
to
buf
that
can't
b
e
\blamed"
on
the
Sender.
Supp
ose

and

satisfy
the
follo
wing
three
conditions:

8
d
:
(buf
0
=
App
end
(buf
;
d
))
)

A
step
that
app
ends
a
v
alue
to
buf
is
not
caused
b
y
the
Receiv
er.

(buf
6=
h
i)
^
(buf
0
=
T
ail
(buf
))
)

A
step
that
remo
v
es
a
v
alue
from
the
head
of
buf
is
not
caused
b
y
the
Sender.

(
^
)
)
(buf
0
=
buf
)
A
step
that
is
caused
b
y
neither
the
Sender
nor
the
Receiv
er
cannot
c
hange
buf
.
Using
ob
vious
relations
suc
h
as
3
(buf
0
=
buf
)
^
(buf
6=
h
i)
^
(buf
0
=
T
ail
(buf
))

f
alse
a
computation
lik
e
the
one
b
y
whic
h
w
e
deriv
ed
(10.1)
sho
ws
2[NS
]
h
buf
;
s
i
^
2[NR
]
h
buf
;
r
i

2[Sndr
_
R
cvr
]
h
buf
;
s
;
r
i
Th
us,
NS
and
NR
are
suitable
next-state
actions
for
the
comp
onen
ts,
if
w
e
c
ho
ose

and

to
satisfy
the
three
conditions
ab
o
v
e.
There
is
considerable
freedom
in
that
c
hoice.
The
strongest
p
ossible
c
hoices
of

and

are
ones
that
describ
e
exactly
the
c
hanges
p
ermitted
b
y
the
other
comp
onen
t:


=
(buf
6=
h
i)
^
(buf
0
=
T
ail
(buf
))


=
9
d
:
buf
0
=
App
end
(buf
;
d
)
3
These
relations
are
true
only
if
buf
is
a
sequence.
A
rigorous
calculation
requires
the
use
of
an
in
v
arian
t
to
assert
that
buf
actually
is
a
sequence.

146
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
W
e
can
w
eak
en
these
denitions
an
y
w
a
y
w
e
w
an
t,
so
long
as
w
e
main
tain
the
condition
that

^

implies
that
buf
is
unc
hanged.
F
or
example,
w
e
can
dene

as
ab
o
v
e
and
let

equal
:
.
The
c
hoice
is
a
matter
of
taste.
I'v
e
b
een
describing
an
in
terlea
ving
sp
ecication
of
the
Sender/Receiv
er
sys-
tem.
No
w
let's
consider
a
nonin
terlea
ving
sp
ecication|one
that
allo
ws
steps
in
whic
h
b
oth
the
Sender
and
the
Receiv
er
are
computing.
In
other
w
ords,
w
e
w
an
t
the
sp
ecication
to
allo
w
SCompute
^
R
Compute
steps
that
lea
v
e
buf
un-
c
hanged.
Let
SSndr
b
e
the
action
that
is
the
same
as
Sndr
except
it
do
esn't
men
tion
r
,
and
let
RR
cvr
b
e
dened
analogously
.
W
e
then
ha
v
e
Sndr

SSndr
^
(r
0
=
r
)
R
cvr

RR
cvr
^
(s
0
=
s
)
A
monolithic
nonin
terlea
ving
sp
ecication
has
the
next-state
action
Sndr
_
R
cvr
_
(SSndr
^
RR
cvr
^
(buf
0
=
buf
))
It
is
the
conjunction
of
comp
onen
t
sp
ecications
ha
ving
the
next-state
actions
NS
and
NR
dened
b
y
NS

=
SSndr
_
(
^
(s
0
=
s
))
NR

=
RR
cvr
_
(
^
(r
0
=
r
))
where

and

are
as
ab
o
v
e.
This
t
w
o-pro
cess
situation
generalizes
to
the
comp
osition
of
an
y
set
C
of
comp
onen
ts
that
share
a
v
ariable
or
tuple
of
v
ariables
w
.
The
in
terlea
ving
case
generalizes
to
the
follo
wing
rule,
in
whic
h
N
k
is
the
next-state
action
of
comp
onen
t
k
,
the
action

k
describ
es
all
c
hanges
to
w
that
are
attributed
to
some
comp
onen
t
other
than
k
,
the
tuple
v
k
describ
es
the
priv
ate
state
of
k
,
and
v
is
the
tuple
formed
b
y
all
the
v
k
:
Shared-State
Comp
osition
Rule
The
four
conditions
1.
(8
k
2
C
:
v
k
0
=
v
k
)

(v
0
=
v
)
v
is
unc
hanged
i
the
priv
ate
state
v
k
of
ev
ery
comp
onen
t
is
unc
hanged.
2.
8
i
;
k
2
C
:
N
k
^
(i
6=
k
)
)
(v
i
0
=
v
i
)
The
next-state
action
of
an
y
comp
onen
t
k
lea
v
es
the
priv
ate
state
v
i
of
all
other
comp
onen
ts
i
unc
hanged.
3.
8
i
;
k
2
C
:
N
k
^
(w
0
6=
w
)
^
(i
6=
k
)
)

i
A
step
of
an
y
comp
onen
t
k
that
c
hanges
w
is
a

i
step,
for
an
y
other
comp
o-
nen
t
i
.
4.
(8
k
2
C
:

k
)

(w
0
=
w
)
A
step
is
caused
b
y
no
comp
onen
t
i
it
do
es
not
c
hange
w
.
imply
(8
k
2
C
:
I
k
^
2[N
k
_
(
k
^
(v
k
0
=
v
k
))]
h
w
;
v
k
i
)

(8
k
2
C
:
I
k
)
^
2
[9
k
2
C
:
N
k
]
h
w
;
v
i

10.4.
COMPOSITION
WITH
SHARED
ST
A
TE
147
Assumption
2
asserts
that
w
e
ha
v
e
an
in
terlea
ving
sp
ecication.
If
w
e
drop
that
assumption,
then
the
righ
t-hand
side
of
the
conclusion
ma
y
not
b
e
a
sensible
sp
ecication,
since
a
disjunct
N
k
ma
y
allo
w
steps
in
whic
h
a
v
ariable
of
some
other
comp
onen
t
assumes
arbitrary
v
alues.
Ho
w
ev
er,
if
eac
h
N
k
correctly
deter-
mines
the
new
v
alues
of
comp
onen
t
k
's
priv
ate
state
v
k
,
then
the
left-hand
side
will
b
e
a
reasonable
sp
ecication,
though
p
ossibly
a
nonin
terlea
ving
one
(and
not
necessarily
equiv
alen
t
to
the
righ
t-hand
side).
10.4.2
Comp
osition
with
Join
t
Actions
Consider
the
linearizable
memory
of
Chapter
5.
As
sho
wn
in
the
picture
on
page
45,
it
is
a
system
consisting
of
a
collection
of
pro
cessors,
a
memory
,
and
an
in
terface
represen
ted
b
y
the
v
ariable
memInt
.
W
e
no
w
tak
e
it
to
b
e
a
t
w
o-
comp
onen
t
system,
where
the
set
of
pro
cessors
forms
one
comp
onen
t,
called
the
envir
onment,
and
the
memory
is
the
other
comp
onen
t.
Let's
neglect
hiding
for
no
w
and
consider
only
the
in
ternal
sp
ecication,
with
all
v
ariables
visible.
W
e
w
an
t
to
write
the
sp
ecication
in
the
form
(IE
^
2[NE
]
vE
)
^
(IM
^
2[NM
]
vM
)
(10.5)
where
E
refers
to
the
en
vironmen
t
comp
onen
t
(the
pro
cessors)
and
M
to
the
memory
comp
onen
t.
The
tuple
vE
of
v
ariables
includes
memInt
and
the
v
ari-
ables
of
the
en
vironmen
t
comp
onen
t;
the
tuple
vM
includes
memInt
and
the
v
ariables
of
the
memory
comp
onen
t.
W
e
m
ust
c
ho
ose
the
form
ulas
IE
,
NE
,
etc.
so
that
(10.5),
with
in
ternal
v
ariables
hidden,
is
equiv
alen
t
to
the
memory
sp
ecication
Sp
e
c
of
mo
dule
Memory
on
page
53.
In
the
memory
sp
ecication,
comm
unication
b
et
w
een
the
en
vironmen
t
and
the
memory
is
describ
ed
b
y
an
action
of
the
form
Send
(p
;
d
;
memInt
;
memInt
0
)
or
R
eply
(p
;
d
;
memInt
;
memInt
0
)
where
Send
and
R
eply
are
unsp
ecied
op
erators
declared
in
the
MemoryInterfac
e
mo
dule
(page
48).
The
sp
ecication
sa
ys
nothing
ab
out
the
actual
v
alue
of
memInt
.
So,
not
only
do
w
e
not
kno
w
ho
w
to
split
memInt
in
to
t
w
o
parts
that
are
eac
h
c
hanged
b
y
only
one
of
the
comp
onen
ts,
w
e
don't
ev
en
kno
w
exactly
ho
w
memInt
c
hanges.
The
tric
k
to
writing
the
sp
ecication
as
a
comp
osition
is
to
put
the
Send
and
R
eply
actions
in
the
next-state
actions
of
b
oth
comp
onen
ts.
W
e
represen
t
the
sending
of
a
v
alue
o
v
er
memInt
as
a
joint
action
p
erformed
b
y
b
oth
the
memory
and
the
en
vironmen
t.
The
next-state
actions
ha
v
e
the
follo
wing
form:
NM

=
9
p
2
Pr
o
c
:
MR
qst
(p
)
_
MRsp
(p
)
_
MInternal
(p
)
NE

=
9
p
2
Pr
o
c
:
ER
qst
(p
)
_
ERsp
(p
)

148
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
where
an
MR
qst
(p
)
^
ER
qst
(p
)
step
represen
ts
the
sending
of
a
request
b
y
pro
ces-
sor
p
(part
of
the
en
vironmen
t)
to
the
memory
,
an
MRsp
(p
)
^
ERsp
(p
)
step
repre-
sen
ts
the
sending
of
a
reply
b
y
the
memory
to
pro
cessor
p
,
and
an
MInternal
(p
)
step
is
an
in
ternal
step
of
the
memory
comp
onen
t
that
p
erforms
the
request.
(There
are
no
in
ternal
steps
of
the
en
vironmen
t.)
The
sending
of
a
reply
is
con
trolled
b
y
the
memory
,
whic
h
c
ho
oses
what
v
alue
is
sen
t
and
when
it
is
sen
t.
The
enabling
condition
and
the
v
alue
sen
t
are
therefore
sp
ecied
b
y
the
MRsp
(p
)
action.
Let's
tak
e
the
in
ternal
v
ariables
of
the
memory
comp
onen
t
to
b
e
the
same
v
ariables
mem
,
ctl
,
and
buf
as
in
the
in
ternal
monolithic
memory
sp
ecication
of
mo
dule
InternalMemory
on
pages
52
and
53.
W
e
can
then
let
MRsp
(p
)
b
e
the
same
as
the
action
Rsp
(p
)
dened
in
that
mo
dule.
The
ERsp
(p
)
action
should
alw
a
ys
b
e
enabled,
and
it
should
allo
w
an
y
legal
resp
onse
to
b
e
sen
t.
A
legal
resp
onse
is
an
elemen
t
of
V
al
or
the
sp
ecial
v
alue
NoV
al
,
so
w
e
can
dene
ERsp
(p
)
to
equal
4
^
9
rsp
2
V
al
[
fNoV
al
g
:
R
eply
(p
;
rsp
;
memInt
;
memInt
0
)
^
:
:
:
where
the
\:
:
:
"
describ
es
the
new
v
alues
of
the
en
vironmen
t's
in
ternal
v
ariables.
The
sending
of
a
request
is
con
trolled
b
y
the
en
vironmen
t,
whic
h
c
ho
oses
what
v
alue
is
sen
t
and
when
it
is
sen
t.
Hence,
the
enabling
condition
should
b
e
part
of
the
ER
qst
(p
)
action.
In
the
monolithic
sp
ecication
of
the
Internal
-
Memory
mo
dule,
that
enabling
condition
w
as
ctl
[p
]
=
\rdy".
Ho
w
ev
er,
if
ctl
is
an
in
ternal
v
ariable
of
the
memory
,
it
can't
also
app
ear
in
the
en
vironmen
t
sp
ecication.
W
e
therefore
ha
v
e
to
add
a
new
v
ariable
whose
v
alue
indicates
whether
a
pro
cessor
is
allo
w
ed
to
send
a
new
request.
Let's
use
a
Bo
olean
v
ariable
r
dy
,
where
r
dy
[p
]
is
true
i
pro
cessor
p
can
send
a
request.
The
v
alue
of
r
dy
[p
]
is
set
false
when
p
sends
a
request
and
is
set
true
again
when
the
corresp
onding
resp
onse
to
p
is
sen
t.
W
e
can
therefore
dene
ER
qst
(p
),
and
complete
the
denition
of
ERsp
(p
),
as
follo
ws:
ER
qst
(p
)

=
^
r
dy
[p
]
^
9
r
e
q
2
MR
e
q
:
Send
(p
;
r
e
q
;
memInt
;
memInt
0
)
^
r
dy
0
=
[r
dy
ex
cept
!
[p
]
=
f
alse
]
ERsp
(p
)

=
^
9
rsp
2
V
al
[
fNoV
al
g
:
R
eply
(p
;
rsp
;
memInt
;
memInt
0
)
^
r
dy
0
=
[r
dy
ex
cept
!
[p
]
=
tr
ue]
The
memory's
MR
qst
(p
)
action
is
the
same
as
the
R
e
q
(p
)
action
of
the
Internal
-
Memory
mo
dule,
except
without
the
enabling
condition
ctl
[p
]
=
\rdy".
4
The
b
ound
on
the
9
isn't
necessary
.
W
e
can
let
the
pro
cessor
accept
an
y
v
alue,
not
just
a
legal
one,
b
y
taking
9
rsp
:
R
eply
(p
;
rsp
;
memInt
;
memInt
0
)
as
the
rst
conjunct.
Ho
w
ev
er,
it's
generally
b
etter
to
use
b
ounded
quan
tiers
when
p
ossible.

10.4.
COMPOSITION
WITH
SHARED
ST
A
TE
149
Finally
,
the
memory's
in
ternal
action
MInternal
(p
)
is
the
same
as
the
Do
(p
)
action
of
the
InternalMemory
mo
dule.
The
rest
of
the
sp
ecication
is
easy
.
The
tuples
vE
and
vM
are
h
memInt
;
r
dy
i
and
h
memInt
;
mem
;
ctl
;
buf
i,
resp
ectiv
ely
.
Dening
the
initial
predicates
IE
and
IM
is
straigh
tforw
ard,
except
for
the
decision
of
where
to
put
the
initial
condition
memInt
2
InitMemInt
.
W
e
can
put
it
in
either
IE
or
IM
,
in
b
oth,
or
else
in
a
separate
conjunct
that
b
elongs
to
neither
comp
onen
t's
sp
ecica-
tion.
Let's
put
it
in
IM
,
whic
h
then
equals
the
initial
predicate
IInit
from
the
InternalMemory
mo
dule.
The
nal
en
vironmen
t
sp
ecication
is
obtained
b
y
hid-
ing
r
dy
in
its
in
ternal
sp
ecication;
the
nal
memory
comp
onen
t
sp
ecication
is
obtained
b
y
hiding
mem
,
ctl
,
and
buf
in
its
in
ternal
sp
ecication.
The
com-
plete
sp
ecication
app
ears
in
Figure
10.2
on
the
next
page.
I
ha
v
e
not
b
othered
to
dene
IM
,
MRsp
(p
),
or
MInternal
(p
),
since
they
equal
IInit
,
Rsp
(p
),
and
Do
(p
)
from
the
InternalMemory
mo
dule,
resp
ectiv
ely
.
What
w
e'v
e
just
done
for
the
en
vironmen
t-memory
system
generalizes
nat-
urally
to
join
t-action
sp
ecications
of
an
y
t
w
o-comp
onen
t
system
in
whic
h
part
of
the
state
cannot
b
e
considered
to
b
elong
to
either
comp
onen
t.
It
also
gen-
eralizes
to
systems
in
whic
h
an
y
n
um
b
er
of
comp
onen
ts
share
some
part
of
the
state.
F
or
example,
supp
ose
w
e
w
an
t
to
write
a
comp
osite
sp
ecication
of
the
linearizable
memory
system
in
whic
h
eac
h
pro
cessor
is
a
separate
comp
onen
t.
The
sp
ecication
of
the
memory
comp
onen
t
w
ould
b
e
the
same
as
b
efore.
The
next-state
action
of
pro
cessor
p
w
ould
no
w
b
e
ER
qst
(p
)
_
ERsp
(p
)
_
OtherPr
o
c
(p
)
where
ER
qst
(p
)
and
ERsp
(p
)
are
the
same
as
ab
o
v
e,
and
an
OtherPr
o
c
(p
)
step
represen
ts
the
sending
of
a
request
b
y
,
or
a
resp
onse
to,
some
pro
cessor
other
than
p
.
Action
OtherPr
o
c
(p
)
represen
ts
p
's
participation
in
the
join
t
action
b
y
whic
h
another
pro
cessor
q
comm
unicates
with
the
memory
comp
onen
t.
It
is
dened
to
equal
9
q
2
Pr
o
c
n
fp
g
:
_
9
r
e
q
2
MR
e
q
:
Send
(q
;
r
e
q
;
memInt
;
memInt
0
)
_
9
rsp
2
V
al
[
fNoV
al
g
:
R
eply
(q
;
rsp
;
memInt
;
memInt
0
)
This
example
is
rather
silly
b
ecause
eac
h
pro
cessor
m
ust
participate
in
com-
m
unication
actions
that
concern
only
other
comp
onen
ts.
It
w
ould
b
e
b
etter
to
c
hange
the
in
terface
to
mak
e
memInt
an
arra
y
,
with
comm
unication
b
et
w
een
pro
cessor
p
and
the
memory
represen
ted
b
y
a
c
hange
to
memInt
[p
].
A
sensible
example
w
ould
require
that
a
join
t
action
represen
t
a
true
in
teraction
b
et
w
een
all
the
comp
onen
ts|for
example,
a
barrier
sync
hronization
op
eration
in
whic
h
the
comp
onen
ts
w
ait
un
til
they
are
all
ready
and
then
p
erform
a
sync
hronization
step
together.

150
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
module
JointA
ctionMemory
extends
MemoryInterfac
e
module
InnerEnvir
onmentComp
onent
v
ariable
r
dy
IE

=
r
dy
=
[p
2
Pr
o
c
7!
tr
ue
]
ER
qst
(p
)

=
^
r
dy
[p
]
^
9
r
e
q
2
MR
e
q
:
Send
(p
;
r
e
q
;
memInt
;
memInt
0
)
^
r
dy
0
=
[r
dy
ex
cept
!
[p
]
=
f
alse]
ERsp
(p
)

=
^
9
rsp
2
V
al
[
fNoV
al
g
:
R
eply
(p
;
rsp
;
memInt
;
memInt
0
)
^
r
dy
0
=
[r
dy
ex
cept
!
[p
]
=
tr
ue
]
NE

=
9
p
2
Pr
o
c
:
ER
qst
(p
)
_
ERsp
(p
)
IESp
e
c

=
IE
^
2[NE
]
h
memInt
;
r
dy
i
module
InnerMemoryComp
onent
extends
InternalMemory
MR
qst
(p
)

=
^
9
r
e
q
2
MR
e
q
:
^
Send
(p
;
r
e
q
;
memInt
;
memInt
0
)
^
buf
0
=
[buf
ex
cept
!
[p
]
=
r
e
q
]
^
ctl
0
=
[ctl
ex
cept
!
[p
]
=
\busy"
]
^
unchanged
mem
NM

=
9
p
2
Pr
o
c
:
MR
qst
(p
)
_
Do
(p
)
_
Rsp
(p
)
IMSp
e
c

=
IInit
^
2[NM
]
h
memInt
;
mem
;
ctl
;
buf
i
IEnv
(r
dy
)

=
inst
ance
InnerEnvir
onmentComp
onent
IMem
(mem
;
ctl
;
buf
)

=
inst
ance
InnerMemoryComp
onent
Sp
e
c

=
^
9
9
9
9
9
9
r
dy
:
IEnv
(r
dy
)
!
IESp
e
c
^
9
9
9
9
9
9
mem
;
ctl
;
buf
:
IMem
(mem
;
ctl
;
buf
)
!
IMSp
e
c
Figure
10.2:
A
join
t-action
sp
ecication
of
a
linearizable
memory
.
10.5
A
Brief
Review
The
basic
idea
of
comp
osing
sp
ecications
is
simple:
a
comp
osite
sp
ecication
is
the
conjunction
of
form
ulas,
eac
h
of
whic
h
can
b
e
considered
to
b
e
the
sp
eci-
cation
of
a
separate
comp
onen
t.
This
c
hapter
has
presen
ted
sev
eral
tec
hniques
for
writing
a
sp
ecication
as
a
comp
osition.
Before
going
further,
let's
put
these
tec
hniques
in
p
ersp
ectiv
e.

10.5.
A
BRIEF
REVIEW
151
10.5.1
A
T
axonom
y
of
Comp
osition
W
e
ha
v
e
seen
three
dieren
t
w
a
ys
of
categorizing
comp
osite
sp
ecications:
The
w
ord
inter-
le
aving
is
stan-
dard;
there
is
no
common
terminol-
ogy
for
the
other
concepts.
In
terlea
ving
v
ersus
nonin
terlea
ving.
An
in
terlea
ving
sp
ecication
is
one
in
whic
h
eac
h
(nonstuttering)
step
can
b
e
attributed
to
exactly
one
comp
o-
nen
t.
A
nonin
terlea
ving
sp
ecication
allo
ws
steps
that
represen
t
sim
ulta-
neous
op
erations
of
t
w
o
or
more
dieren
t
comp
onen
ts.
Disjoin
t-state
v
ersus
shared-state.
A
disjoin
t-state
sp
ecication
is
one
in
whic
h
the
state
can
b
e
partitioned,
with
eac
h
part
b
elonging
to
a
separate
comp
onen
t.
A
part
of
the
state
can
b
e
a
v
ariable
v
,
or
a
\piece"
of
that
v
ariable
suc
h
as
v
:c
or
v
[c
]
for
some
xed
c
.
An
y
c
hange
to
a
comp
onen
t's
part
of
the
state
is
attributed
to
that
comp
onen
t.
In
a
shared-state
sp
eci-
cation,
some
part
of
the
state
can
b
e
c
hanged
b
y
steps
attributed
to
more
than
one
comp
onen
t.
Join
t-action
v
ersus
separate-action.
A
join
t-action
sp
ecication
is
a
nonin-
terlea
ving
one
in
whic
h
some
step
attributed
to
one
comp
onen
t
m
ust
o
ccur
sim
ultaneously
with
a
step
attributed
to
another
comp
onen
t.
A
separate-
action
sp
ecication
is
simply
one
that
is
not
a
join
t-action
sp
ecication.
These
are
indep
enden
t
w
a
ys
of
classifying
sp
ecications,
except
that
a
join
t-
action
sp
ecication
m
ust
b
e
nonin
terlea
ving.
10.5.2
In
terlea
ving
Reconsidered
Should
w
e
write
in
terlea
ving
or
nonin
terlea
ving
sp
ecications?
W
e
migh
t
try
to
answ
er
this
question
b
y
asking:
can
dieren
t
comp
onen
ts
really
tak
e
sim
ulta-
neous
steps?
Ho
w
ev
er,
this
question
mak
es
no
sense.
A
step
is
a
mathematical
abstraction;
real
comp
onen
ts
p
erform
op
erations
that
tak
e
a
nite
amoun
t
of
time.
Op
erations
p
erformed
b
y
t
w
o
dieren
t
comp
onen
ts
could
o
v
erlap
in
time.
W
e
are
free
to
represen
t
this
ph
ysical
situation
either
with
a
single
sim
ultaneous
step
of
the
t
w
o
comp
onen
ts,
or
with
t
w
o
separate
steps.
In
the
latter
case,
the
sp
ecication
usually
allo
ws
the
t
w
o
steps
to
o
ccur
in
either
order.
(If
the
t
w
o
op
erations
m
ust
o
ccur
sim
ultaneously
,
then
w
e
ha
v
e
written
a
join
t-action
sp
ec-
ication.)
It's
up
to
y
ou
whether
to
write
an
in
terlea
ving
or
a
nonin
terlea
ving
sp
ecication.
Y
ou
should
c
ho
ose
whic
hev
er
is
more
con
v
enien
t.
The
c
hoice
is
not
completely
arbitrary
if
y
ou
w
an
t
one
sp
ecication
to
imple-
men
t
another.
A
nonin
terlea
ving
sp
ecication
will
not,
in
general,
implemen
t
an
in
terlea
ving
one
b
ecause
the
nonin
terlea
ving
sp
ecication
will
allo
w
sim
ultane-
ous
actions
that
the
in
terlea
ving
sp
ecication
prohibits.
So,
if
y
ou
w
an
t
to
write
a
lo
w
er-lev
el
sp
ecication
that
implemen
ts
a
higher-lev
el
in
terlea
ving
sp
ecica-
tion,
then
y
ou'll
ha
v
e
to
use
an
in
terlea
ving
sp
ecication.
As
w
e'v
e
seen,
it's
easy

152
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
to
turn
a
nonin
terlea
ving
sp
ecication
in
to
an
in
terlea
ving
one
b
y
conjoining
an
in
terlea
ving
assumption.
10.5.3
Join
t
Actions
Reconsidered
The
reason
for
writing
a
comp
osite
sp
ecication
is
to
separate
the
sp
ecications
of
the
dieren
t
comp
onen
ts.
The
mixing
of
actions
from
dieren
t
comp
onen
ts
in
a
join
t-action
sp
ecication
destro
ys
this
separation.
So,
wh
y
should
w
e
write
suc
h
a
sp
ecication?
Join
t-action
sp
ecications
arise
most
often
in
highly
abstract
descriptions
of
in
ter-comp
onen
t
comm
unication.
In
writing
a
comp
osite
sp
ecication
of
the
lin-
earizable
memory
,
w
e
w
ere
led
to
use
join
t
actions
b
ecause
of
the
abstract
nature
of
the
in
terface.
In
real
systems,
comm
unication
o
ccurs
when
one
comp
onen
t
c
hanges
the
state
and
another
comp
onen
t
later
observ
es
that
c
hange.
The
in
ter-
face
describ
ed
b
y
the
MemoryInterfac
e
mo
dule
abstracts
a
w
a
y
those
t
w
o
steps,
replacing
them
with
a
single
one
that
represen
ts
instan
taneous
comm
unication|
a
ction
that
do
es
not
exist
in
the
real
w
orld.
Since
eac
h
comp
onen
t
m
ust
re-
mem
b
er
that
the
comm
unication
has
o
ccurred,
the
single
comm
unication
step
has
to
c
hange
the
priv
ate
state
of
b
oth
comp
onen
ts.
That's
wh
y
w
e
couldn't
use
the
approac
h
of
Section
10.4.1
(page
144),
whic
h
requires
that
an
y
c
hange
to
the
shared
in
terface
c
hange
the
nonshared
state
of
just
one
comp
onen
t.
The
abstract
memory
in
terface
simplies
the
sp
ecication,
allo
wing
comm
u-
nication
to
b
e
represen
ted
as
one
step
instead
of
t
w
o.
But
this
simplication
comes
at
the
cost
of
blurring
the
distinction
b
et
w
een
the
t
w
o
comp
onen
ts.
If
w
e
blur
this
distinction,
it
ma
y
not
mak
e
sense
to
write
the
sp
ecication
as
the
con-
junction
of
separate
comp
onen
t
sp
ecications.
As
the
memory
system
example
illustrates,
decomp
osing
the
system
in
to
separate
comp
onen
ts
comm
unicating
with
join
t
actions
ma
y
require
the
in
tro
duction
of
extra
v
ariables.
There
ma
y
o
ccasionally
b
e
a
go
o
d
reason
for
adding
this
kind
of
complexit
y
to
a
sp
ecica-
tion,
but
it
should
not
b
e
done
as
a
matter
of
course.
10.6
Liv
eness
and
Hiding
10.6.1
Liv
eness
and
Mac
hine
Closure
Th
us
far,
the
discussion
of
comp
osition
has
neglected
liv
eness.
In
comp
osite
sp
ecications,
it
is
usually
easy
to
sp
ecifying
liv
eness
b
y
placing
fairness
con-
ditions
on
the
actions
of
individual
comp
onen
ts.
F
or
example,
to
sp
ecify
an
arra
y
of
clo
c
ks
that
all
k
eep
tic
king
forev
er,
w
e
w
ould
mo
dify
the
sp
ecication

10.6.
LIVENESS
AND
HIDING
153
Clo
ckA
rr
ay
of
(10.2)
on
page
139
to
equal
8
k
2
Clo
ck
:
(hr
[k
]
2
1
:
:
12)
^
2[HCN
(hr
[k
])]
hr
[k
]
^
WF
hr
[k
]
(HCN
(hr
[k
]))
When
writing
a
w
eak
or
strong
fairness
form
ula
for
an
action
A
of
a
comp
o-
nen
t
c
,
there
arises
the
question
of
what
the
subscript
should
b
e.
The
ob
vious
c
hoices
are
(i)
the
tuple
v
describing
the
en
tire
sp
ecication
state,
and
(ii)
the
tuple
v
c
describing
that
comp
onen
t's
state.
The
c
hoice
can
matter
only
if
the
safet
y
part
of
the
sp
ecication
allo
ws
the
system
to
reac
h
some
state
in
whic
h
an
A
step
could
lea
v
e
v
c
unc
hanged
while
c
hanging
v
.
Although
unlik
ely
,
this
could
conceiv
ably
b
e
the
case
in
a
join
t-action
sp
ecication.
If
it
is,
w
e
probably
don't
w
an
t
the
fairness
condition
to
b
e
satised
b
y
a
step
that
lea
v
es
the
comp
onen
t's
state
unc
hanged,
so
w
e
w
ould
use
the
subscript
v
c
.
F
airness
conditions
for
comp
osite
sp
ecications
do
raise
one
imp
ortan
t
ques-
tion:
if
eac
h
comp
onen
t
sp
ecication
is
mac
hine
closed,
is
the
comp
osite
sp
ec-
Mac
hine
clo-
sure
is
dened
in
Section
8.9.2
on
page
111.
ication
necessarily
mac
hine
closed?
Supp
ose
w
e
write
the
sp
ecication
as
8
k
2
C
:
S
k
^
L
k
,
where
eac
h
pair
S
k
;
L
k
is
mac
hine
closed.
Let
S
b
e
the
con-
junction
of
the
S
k
and
L
the
conjunction
of
the
L
k
,
so
the
sp
ecication
equals
S
^
L.
The
conjunction
of
safet
y
prop
erties
is
a
safet
y
prop
ert
y
,
5
so
S
is
a
safet
y
prop
ert
y
.
Hence,
w
e
can
ask
if
the
pair
S
;
L
is
mac
hine
closed.
In
general,
S
;
L
need
not
b
e
mac
hine
closed.
But,
for
an
in
terlea
ving
comp
o-
sition,
it
usually
is.
Liv
eness
prop
erties
are
usually
expressed
as
the
conjunction
of
w
eak
and
strong
fairness
prop
erties
of
actions.
As
stated
on
page
112,
a
sp
ec-
ication
is
mac
hine
closed
if
its
liv
eness
prop
ert
y
is
the
conjunction
of
fairness
prop
erties
for
subactions
of
the
next-state
action.
In
an
in
terlea
ving
comp
o-
sition,
eac
h
S
k
usually
has
the
form
I
k
^
2[N
k
]
v
k
where
the
v
k
satisfy
the
h
yp
othesis
of
the
Comp
osition
Rule
(page
138),
and
eac
h
N
k
implies
v
i
0
=
v
i
,
for
all
i
in
C
n
fk
g.
In
this
case,
the
Comp
osition
Rule
implies
that
a
subaction
of
N
k
is
also
a
subaction
of
the
next-state
action
of
S
.
Hence,
if
w
e
write
an
in
terlea
ving
comp
osition
in
the
usual
w
a
y
,
and
w
e
write
mac
hine-closed
comp
o-
nen
t
sp
ecications
in
the
usual
w
a
y
,
then
the
comp
osite
sp
ecication
is
mac
hine
closed.
It
is
not
so
easy
to
obtain
a
mac
hine-closed
nonin
terlea
ving
comp
osition|
esp
ecially
with
a
join
t-action
comp
osition.
W
e
ha
v
e
actually
seen
an
example
of
a
join
t-action
sp
ecication
in
whic
h
eac
h
comp
onen
t
is
mac
hine
closed
but
the
comp
osition
is
not.
In
Chapter
9,
w
e
wrote
a
real-time
sp
ecication
b
y
conjoining
one
or
more
R
TBound
form
ulas
and
an
R
Tnow
form
ula
to
an
un
timed
sp
ecication.
A
pathological
example
w
as
the
follo
wing,
whic
h
is
form
ula
(9.2)
on
page
131:
HC
is
the
hour-
clo
c
k
sp
ecication
from
Chapter
2.
HC
^
R
TBound
(hr
0
=
hr
 1;
hr
;
0;
3600)
^
R
Tnow
(hr
)
5
Recall
that
a
safet
y
prop
ert
y
is
one
that
is
violated
b
y
a
b
eha
vior
i
it
is
violated
at
some
particular
p
oin
t
in
the
b
eha
vior.
A
b
eha
vior
violates
a
conjunction
of
safet
y
prop
erties
S
k
i
it
violates
some
particular
S
k
,
and
that
S
k
is
violated
at
some
sp
ecic
p
oin
t.

154
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
W
e
can
view
this
form
ula
as
the
conjunction
of
three
comp
onen
t
sp
ecications:
1.
HC
sp
ecies
a
clo
c
k,
represen
ted
b
y
the
v
ariable
hr
.
2.
R
TBound
(hr
0
=
hr
 1;
hr
;
0;
3600)
sp
ecies
a
timer,
represen
ted
b
y
the
hidden
(existen
tially
quan
tied)
timer
v
ariable.
3.
R
Tnow
(hr
)
sp
ecies
real
time,
represen
ted
b
y
the
v
ariable
now
.
The
form
ula
is
a
join
t-action
comp
osition,
with
t
w
o
kinds
of
join
t
actions:

Join
t
actions
of
the
rst
and
second
comp
onen
ts
that
c
hange
b
oth
hr
and
the
timer.

Join
t
actions
of
the
second
and
third
comp
onen
ts
that
c
hange
b
oth
the
timer
and
now
.
The
rst
t
w
o
sp
ecications
are
trivially
mac
hine
closed
b
ecause
they
assert
no
liv
eness
condition,
so
their
liv
eness
prop
ert
y
is
tr
ue
.
The
third
sp
ecication's
safet
y
prop
ert
y
asserts
that
now
is
a
real
n
um
b
er
that
is
c
hanged
only
b
y
steps
that
incremen
t
it
and
lea
v
e
hr
unc
hanged;
its
liv
eness
prop
ert
y
NZ
asserts
that
now
increases
without
b
ound.
An
y
nite
b
eha
vior
satisfying
the
safet
y
prop
ert
y
can
easily
b
e
extended
to
an
innite
b
eha
vior
satisfying
the
en
tire
sp
ecication,
so
the
third
sp
ecication
is
also
mac
hine
closed.
Ho
w
ev
er,
as
w
e
observ
ed
in
Section
9.4,
the
comp
osite
sp
ecication
is
Zeno,
meaning
that
it's
not
mac
hine
closed.
10.6.2
Hiding
Supp
ose
w
e
can
write
a
sp
ecication
S
as
the
comp
osition
of
t
w
o
comp
onen
t
sp
ecications
S
1
and
S
2
.
Can
w
e
write
9
9
9
9
9
9
h
:
S
,
the
sp
ecication
S
with
v
ariable
h
hidden,
as
a
comp
osition|that
is,
as
the
conjunction
of
t
w
o
separate
comp
onen
t
sp
ecications?
If
h
represen
ts
state
that
is
accessed
b
y
b
oth
comp
onen
ts,
then
the
answ
er
is
no.
If
the
t
w
o
comp
onen
ts
comm
unicate
through
some
part
of
the
state,
then
that
part
of
the
state
cannot
b
e
made
in
ternal
to
the
separate
comp
onen
ts.
The
simplest
situation
in
whic
h
h
do
esn't
represen
t
shared
state
is
when
it
o
ccurs
in
only
one
of
the
comp
onen
t
sp
ecications|sa
y
,
S
2
.
If
h
do
esn't
o
ccur
in
S
1
,
then
the
equiv
alence
(
9
9
9
9
9
9
h
:
S
1
^
S
2
)

S
1
^
(
9
9
9
9
9
9
h
:
S
2
)
pro
vides
the
desired
decomp
osition.
No
w
supp
ose
that
h
o
ccurs
in
b
oth
comp
onen
t
sp
ecications,
but
do
es
not
represen
t
state
accessed
b
y
b
oth
comp
onen
ts.
This
can
b
e
the
case
only
if
dieren
t
\parts"
of
h
o
ccur
in
the
t
w
o
comp
onen
t
sp
ecications.
F
or
example,

10.6.
LIVENESS
AND
HIDING
155
h
migh
t
b
e
a
record
with
comp
onen
ts
h
:c
1
and
h
:c
2,
where
S
1
men
tions
only
h
:c
1
and
S
2
men
tions
only
h
:c
2.
In
this
case,
w
e
ha
v
e
(
9
9
9
9
9
9
h
:
S
1
^
S
2
)

(
9
9
9
9
9
9
h
1
:
T
1
)
^
(
9
9
9
9
9
9
h
2
:
T
2
)
where
T
1
is
obtained
from
S
1
b
y
substituting
the
v
ariable
h
1
for
the
expression
h
:c
1,
and
T
2
is
dened
similarly
.
Of
course
w
e
can
use
an
y
v
ariables
in
place
of
h
1
and
h
2;
in
particular,
w
e
can
replace
them
b
oth
b
y
the
same
v
ariable.
W
e
can
generalize
this
result
as
follo
ws
to
the
comp
osition
of
an
y
nite
n
um
b
er
6
of
comp
onen
ts:
Comp
ositional
Hiding
Rule
If
the
v
ariable
h
do
es
not
o
ccur
in
the
form
ula
T
i
,
and
S
i
is
obtained
from
T
i
b
y
substituting
h
[i
]
for
q
,
then
(
9
9
9
9
9
9
h
:
8
i
2
C
:
S
i
)

(8
i
2
C
:
9
9
9
9
9
9
q
:
T
i
)
for
an
y
nite
set
C
.
The
assumption
that
h
do
es
not
o
ccur
in
T
i
means
that
the
v
ariable
h
o
ccurs
in
form
ula
S
i
only
in
the
expression
h
[i
].
This
in
turn
implies
that
the
comp
osition
8
i
2
C
:
S
i
do
es
not
determine
the
v
alue
of
h
,
just
of
its
comp
onen
ts
h
[i
]
for
i
2
C
.
As
noted
in
Section
10.2
on
page
138,
w
e
can
mak
e
the
comp
osite
sp
eci-
cation
determine
the
v
alue
of
h
b
y
conjoining
the
form
ula
2IsFcnOn
(h
;
C
)
to
it,
where
IsFcnOn
is
dened
on
page
140.
The
h
yp
otheses
of
the
Comp
ositional
Hiding
Rule
imply
(
9
9
9
9
9
9
h
:
2IsFcnOn
(h
;
C
)
^
8
i
2
C
:
S
i
)

(8
i
2
C
:
9
9
9
9
9
9
q
:
T
i
)
No
w
consider
the
common
case
in
whic
h
8
i
2
C
:
S
i
is
an
in
terlea
ving
com-
p
osition,
where
eac
h
sp
ecication
S
i
describ
es
c
hanges
to
h
[i
]
and
asserts
that
steps
of
comp
onen
t
i
lea
v
e
h
[j
]
unc
hanged
for
j
6=
i
.
W
e
cannot
apply
the
Com-
p
ositional
Hiding
Rule
b
ecause
S
i
m
ust
men
tion
other
comp
onen
ts
of
h
b
esides
h
[i
].
F
or
example,
it
probably
con
tains
an
expression
of
the
form
h
0
=
[h
ex
cept
!
[i
]
=
exp
]
(10.6)
whic
h
men
tions
all
of
h
.
Ho
w
ev
er,
w
e
can
transform
S
i
in
to
a
sp
ecication
c
S
i
that
describ
es
only
the
c
hanges
to
h
[i
]
and
mak
es
no
assertions
ab
out
other
comp
onen
ts.
F
or
example,
w
e
can
replace
(10.6)
with
h
0
[i
]
=
exp
,
and
w
e
can
replace
an
assertion
that
h
is
unc
hanged
b
y
the
assertion
that
h
[i
]
is
unc
hanged.
The
comp
osition
8
i
2
C
:
c
S
i
ma
y
allo
w
steps
that
c
hange
t
w
o
dieren
t
com-
p
onen
ts
h
[i
]
and
h
[j
],
while
lea
ving
all
other
v
ariables
unc
hanged,
making
it
a
nonin
terlea
ving
sp
ecication.
It
will
then
not
b
e
equiv
alen
t
to
8
i
2
C
:
S
i
,
whic
h
requires
that
the
c
hanges
to
h
[i
]
and
h
[j
]
b
e
p
erformed
b
y
dieren
t
steps.
Ho
w
ev
er,
it
can
b
e
sho
wn
that
hiding
h
hides
this
dierence,
making
the
t
w
o
sp
ecications
equiv
alen
t.
W
e
can
then
apply
the
Comp
ositional
Hiding
Rule
with
S
i
replaced
b
y
c
S
i
.
6
The
Comp
ositional
Hiding
Rule
is
not
true
in
general
if
C
is
an
innite
set;
but
the
examples
in
whic
h
it
do
esn't
hold
are
pathological
and
don't
arise
in
practice.

156
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
10.7
Op
en-System
Sp
ecications
A
sp
ecication
describ
es
the
in
teraction
b
et
w
een
a
system
and
its
en
vironmen
t.
F
or
example,
the
FIF
O
buer
sp
ecication
of
Chapter
4
sp
ecies
the
in
teraction
b
et
w
een
the
buer
(the
system)
and
an
en
vironmen
t
consisting
of
the
sender
and
receiv
er.
So
far,
all
the
sp
ecications
w
e
ha
v
e
written
ha
v
e
b
een
complete-system
sp
ecications,
meaning
that
they
are
satised
b
y
a
b
eha
vior
that
represen
ts
the
correct
op
eration
of
b
oth
the
system
and
its
en
vironmen
t.
When
w
e
write
suc
h
a
sp
ecication
as
the
comp
osition
of
an
en
vironmen
t
sp
ecication
E
and
a
system
sp
ecication
M
,
it
has
the
form
E
^
M
.
An
op
en-system
sp
ecication
is
one
that
can
serv
e
as
a
con
tract
b
et
w
een
a
Op
en-system
sp
ecications
are
sometimes
called
r
ely-guar
ante
e
or
assume-guar
ante
e
sp
ecications.
user
of
the
system
and
its
implemen
ter.
An
ob
vious
c
hoice
of
suc
h
a
sp
ecication
is
the
form
ula
M
that
describ
es
the
correct
b
eha
vior
of
the
system
comp
onen
t
b
y
itself.
Ho
w
ev
er,
suc
h
a
sp
ecication
is
unimplemen
table.
It
asserts
that
the
system
acts
correctly
no
matter
what
the
en
vironmen
t
do
es.
A
system
cannot
b
eha
v
e
as
exp
ected
in
the
face
of
arbitrary
b
eha
vior
of
its
en
vironmen
t.
It
w
ould
b
e
imp
ossible
to
build
a
buer
that
satises
the
buer
comp
onen
t's
sp
ecication
regardless
of
what
the
sender
and
receiv
er
did.
F
or
example,
if
the
sender
sends
a
v
alue
b
efore
the
previous
v
alue
has
b
een
ac
kno
wledged,
then
the
buer
could
read
the
v
alue
while
it
is
c
hanging,
causing
unpredictable
results.
A
con
tract
b
et
w
een
a
user
and
an
implemen
ter
should
require
the
system
to
act
correctly
only
if
the
en
vironmen
t
do
es.
If
M
describ
es
correct
b
eha
vior
of
the
system
and
E
describ
es
correct
b
eha
vior
of
the
en
vironmen
t,
suc
h
a
sp
ecication
should
require
that
M
b
e
true
if
E
is.
This
suggests
that
w
e
tak
e
as
our
op
en-
system
sp
ecication
the
form
ula
E
)
M
,
whic
h
is
true
if
the
system
b
eha
v
es
correctly
or
the
en
vironmen
t
b
eha
v
es
incorrectly
.
Ho
w
ev
er,
E
)
M
is
to
o
w
eak
a
sp
ecication
for
the
follo
wing
reason.
Consider
again
the
example
of
a
FIF
O
buer,
where
M
describ
es
the
buer
and
E
the
sender
and
receiv
er.
Supp
ose
no
w
that
the
buer
sends
a
new
v
alue
b
efore
the
receiv
er
has
ac
kno
wledged
the
previous
one.
This
could
cause
the
receiv
er
to
act
incorrectly
,
p
ossibly
mo
difying
the
output
c
hannel
in
some
w
a
y
not
allo
w
ed
b
y
the
receiv
er's
sp
ecication.
This
situation
is
describ
ed
b
y
a
b
eha
vior
in
whic
h
b
oth
E
and
M
are
false|a
b
eha
vior
that
satises
the
sp
ecication
E
)
M
.
Ho
w
ev
er,
the
buer
should
not
b
e
considered
to
act
correctly
in
this
case,
since
it
w
as
the
buer's
error
that
caused
the
receiv
er
to
act
incorrectly
.
Hence,
this
b
eha
vior
should
not
satisfy
the
buer's
sp
ecication.
An
op
en-system
sp
ecication
should
assert
that
the
system
b
eha
v
es
correctly
at
least
as
long
as
the
en
vironmen
t
do
es.
T
o
express
this,
w
e
in
tro
duce
a
new
temp
oral
op
erator
+
 .
,
where
E
+
 .
M
asserts
that
M
remains
true
at
least
one
step
longer
than
E
do
es,
remaining
true
forev
er
if
E
do
es.
Somewhat
more
precisely
,
E
+
 .
M
asserts
that

E
implies
M
.

10.7.
OPEN-SYSTEM
SPECIFICA
TIONS
157

If
the
safet
y
prop
ert
y
of
E
is
not
violated
b
y
the
rst
n
states
of
a
b
eha
vior,
then
the
safet
y
prop
ert
y
of
M
is
not
violated
b
y
the
rst
n
+
1
states,
for
an
y
natural
n
um
b
er
n
.
(Recall
that
a
safet
y
prop
ert
y
is
one
that,
if
violated,
is
violated
at
some
denite
p
oin
t
in
the
b
eha
vior.)
A
more
precise
denition
of
+
 .
app
ears
in
Section
16.2.4
(page
314).
If
E
describ
es
the
desired
b
eha
vior
of
the
en
vironmen
t
and
M
describ
es
the
desired
b
eha
vior
of
the
system,
then
w
e
tak
e
as
our
op
en-system
sp
ecication
the
form
ula
E
+
 .
M
.
Once
w
e
write
separate
sp
ecications
of
the
comp
onen
ts,
w
e
can
usually
transform
a
complete-system
sp
ecication
in
to
an
op
en-system
one
b
y
simply
replacing
conjunction
with
+
 .
.
This
requires
rst
deciding
whether
eac
h
con-
junct
of
the
complete-system
sp
ecication
b
elongs
to
the
sp
ecication
of
the
en
vironmen
t,
of
the
system,
or
of
neither.
As
an
example,
consider
the
com-
p
osite
sp
ecication
of
the
FIF
O
buer
in
mo
dule
Comp
ositeFIF
O
on
page
143.
W
e
tak
e
the
system
to
consist
of
just
the
buer,
with
the
sender
and
receiv
er
forming
the
en
vironmen
t.
The
closed-system
sp
ecication
Sp
e
c
has
three
main
conjuncts:
Sender
^
Buer
^
R
e
c
eiver
The
conjuncts
Sender
and
R
e
c
eiver
are
clearly
part
of
the
en
vironmen
t
sp
ecication,
and
Buer
is
part
of
the
system
sp
ecication.
(in
:ack
=
in
:r
dy
)
^
(out
:ack
=
out
:r
dy
)
These
t
w
o
initial
conjuncts
can
b
e
assigned
to
either,
dep
ending
on
whic
h
comp
onen
t
w
e
w
an
t
to
blame
if
they
are
violated.
Let's
assign
to
the
comp
onen
t
sending
on
a
c
hannel
c
the
resp
onsibilit
y
for
establishing
that
c
:ack
=
c
:r
dy
holds
initially
.
W
e
then
assign
in
:ack
=
in
:r
dy
to
the
en
vironmen
t
and
out
:ack
=
out
:r
dy
to
the
system.
2(IsChannel
(in
)
^
IsChannel
(out
))
This
form
ula
is
not
naturally
attributed
to
either
the
system
or
the
en-
vironmen
t.
W
e
regard
it
as
a
prop
ert
y
inheren
t
in
our
w
a
y
of
mo
deling
the
system,
whic
h
assumes
that
in
and
out
are
records
with
ack
,
val
,
and
r
dy
comp
onen
ts.
W
e
therefore
tak
e
the
form
ula
to
b
e
a
separate
conjunct
of
the
complete
sp
ecication,
not
b
elonging
to
either
the
system
or
the
en
vironmen
t.
W
e
then
ha
v
e
the
follo
wing
op
en-system
sp
ecication
for
the
FIF
O
buer:
^
2(IsChannel
(in
)
^
IsChannel
(out
))
^
(in
:ack
=
in
:r
dy
)
^
Sender
^
R
e
c
eiver
+
 .
(out
:ack
=
out
:r
dy
)
^
Buer
As
this
example
suggests,
there
is
little
dierence
b
et
w
een
writing
a
comp
osite
complete-system
sp
ecication
and
an
op
en-system
sp
ecication.
Most
of
the

158
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
sp
ecication
do
esn't
dep
end
on
whic
h
w
e
c
ho
ose.
The
t
w
o
dier
only
at
the
v
ery
end,
when
w
e
put
the
pieces
together.
10.8
In
terface
Renemen
t
An
interfac
e
r
enement
is
a
metho
d
of
obtaining
a
lo
w
er-lev
el
sp
ecication
b
y
rening
the
v
ariables
of
a
higher-lev
el
sp
ecication.
Let's
start
with
t
w
o
exam-
ples
and
then
discuss
in
terface
renemen
t
in
general.
10.8.1
A
Binary
Hour
Clo
c
k
In
sp
ecifying
an
hour
clo
c
k,
w
e
describ
ed
its
displa
y
with
a
v
ariable
hr
whose
v
alue
(in
a
b
eha
vior
satisfying
the
sp
ecication)
is
an
in
teger
from
1
to
12.
Supp
ose
w
e
w
an
t
to
sp
ecify
a
binary
hour
clo
ck.
This
is
an
hour
clo
c
k
for
use
in
a
computer,
where
the
displa
y
consists
of
a
four-bit
register
that
displa
ys
the
hour
as
one
of
the
t
w
elv
e
v
alues
0001,
0010,
.
.
.
,
1100.
W
e
can
easily
sp
ecify
suc
h
a
clo
c
k
from
scratc
h.
But
supp
ose
w
e
w
an
t
to
describ
e
it
informally
to
someone
who
already
kno
ws
what
an
hour
clo
c
k
is.
W
e
w
ould
simply
sa
y
that
a
binary
hour
clo
c
k
is
the
same
as
an
ordinary
hour
clo
c
k,
except
that
the
v
alue
of
the
displa
y
is
represen
ted
in
binary
.
W
e
no
w
formalize
that
description.
W
e
b
egin
b
y
describing
what
it
means
for
a
four-bit
v
alue
to
represen
t
a
n
um
b
er.
There
are
sev
eral
reasonable
w
a
ys
to
represen
t
a
four-bit
v
alue
math-
ematically
.
W
e
could
use
a
four-elemen
t
sequence,
whic
h
in
TLA
+
is
a
function
whose
domain
is
1
:
:
4.
Ho
w
ev
er,
a
mathematician
w
ould
nd
it
more
natural
to
represen
t
an
(n
+
1)-bit
n
um
b
er
as
a
function
from
0
:
:
n
to
f0;
1g,
the
function
W
e
can
also
write
f0;
1g
as
0
:
:
1.
b
represen
ting
the
n
um
b
er
b
[0]

2
0
+
b
[1]

2
1
+
:
:
:
+
b
[n
]

2
n
.
In
TLA
+
,
w
e
can
dene
BitA
rr
ayV
al
(b
)
to
b
e
the
n
umerical
v
alue
of
suc
h
a
function
b
b
y
BitA
rr
ayV
al
(b
)

=
let
n

=
choose
i
2
Nat
:
domain
b
=
0
:
:
i
val
[i
2
0
:
:
n
]

=
Denes
val
[i
]
to
equal
b
[0]

2
0
+
:
:
:
+
b
[i
]

2
i
.
if
i
=
0
then
b
[0]

2
0
else
b
[i
]

2
i
+
val
[i
 1]
in
val
[n
]
T
o
sp
ecify
a
binary
hour
clo
c
k
whose
displa
y
is
describ
ed
b
y
the
v
ariable
bits
,
w
e
w
ould
simply
sa
y
that
BitA
rr
ayV
al
(bits
)
c
hanges
the
same
w
a
y
that
the
sp
ecication
HC
of
the
hour
clo
c
k
allo
ws
hr
to
c
hange.
Mathematically
,
this
means
that
w
e
obtain
the
sp
ecication
of
the
binary
hour
clo
c
k
b
y
substituting
BitA
rr
ayV
al
(bits
)
for
the
v
ariable
hr
in
HC
.
In
TLA
+
,
substitution
is
expressed
with
the
inst
ance
statemen
t.
W
riting
B

=
inst
ance
HourClo
ck
with
hr
 
BitA
rr
ayV
al
(bits
)

10.8.
INTERF
A
CE
REFINEMENT
159
denes
(among
other
things)
B
!
HC
to
b
e
the
form
ula
obtained
from
HC
b
y
substituting
BitA
rr
ayV
al
(bits
)
for
hr
.
Unfortunately
,
this
sp
ecication
is
wrong.
The
v
alue
of
BitA
rr
ayV
al
(b
)
is
sp
ecied
only
if
b
is
a
function
with
domain
0
:
:
n
for
some
natural
n
um
b
er
n
.
W
e
don't
kno
w
what
BitA
rr
ayV
al
(f\ab
c"
g)
equals.
It
migh
t
equal
7.
If
it
did,
then
B
!
HC
w
ould
allo
w
a
b
eha
vior
in
whic
h
the
initial
v
alue
of
bits
is
f\ab
c"
g.
W
e
m
ust
rule
out
this
p
ossibilit
y
b
y
substituting
for
hr
not
BitA
rr
ayV
al
(bits
),
but
some
expression
HourV
al
(bits
)
whose
v
alue
is
an
elemen
t
of
1
:
:
12
only
if
b
is
a
function
in
[(0
:
:
3)
!
f0;
1g].
F
or
example,
w
e
can
write
HourV
al
(b
)

=
if
b
2
[(0
:
:
3)
!
f0;
1g]
then
BitA
rr
ayV
al
(b
)
else
99
B

=
inst
ance
HourClo
ck
with
hr
 
HourV
al
(bits
)
This
denes
B
!
HC
to
b
e
the
desired
sp
ecication
of
the
binary
hour
clo
c
k.
Because
HC
is
not
satised
b
y
a
b
eha
vior
in
whic
h
hr
ev
er
assumes
the
v
alue
99,
B
!
HC
is
not
satised
b
y
an
y
b
eha
vior
in
whic
h
bits
ev
er
assumes
a
v
alue
not
in
the
set
[(0
:
:
3)
!
f0;
1g].
There
is
another
w
a
y
to
use
the
sp
ecication
HC
of
the
hour
clo
c
k
to
sp
ecify
the
binary
hour
clo
c
k.
Instead
of
substituting
for
hr
in
the
hour-clo
c
k
sp
eci-
cation,
w
e
rst
sp
ecify
a
system
consisting
of
b
oth
an
hour
clo
c
k
and
a
binary
hour
clo
c
k
that
k
eep
the
same
time,
and
w
e
then
hide
the
hour
clo
c
k.
This
sp
ecication
has
the
form
9
9
9
9
9
9
hr
:
IR
^
HC
(10.7)
where
IR
is
a
temp
oral
form
ula
that
is
true
i
bits
is
alw
a
ys
the
four-bit
v
alue
represen
ting
the
v
alue
of
hr
.
This
form
ula
asserts
that
bits
is
the
represen
tation
of
hr
as
a
four-bit
arra
y
,
for
some
c
hoice
of
v
alues
for
hr
that
satises
HC
.
Using
the
denition
of
HourV
al
giv
en
ab
o
v
e,
w
e
can
dene
IR
simply
to
equal
2(h
=
HourV
al
(b
)).
If
HC
is
dened
as
in
mo
dule
HourClo
ck
,
then
(10.7)
can't
app
ear
in
a
TLA
+
sp
ecication.
F
or
HC
to
b
e
dened
in
the
con
text
of
the
form
ula,
the
v
ariable
hr
m
ust
b
e
declared
in
that
con
text.
If
hr
is
already
declared,
then
it
can't
b
e
used
as
the
b
ound
v
ariable
of
the
quan
tier
9
9
9
9
9
9
.
As
usual,
this
problem
is
solv
ed
with
parametrized
instan
tiation.
The
complete
TLA
+
sp
ecication
BHC
of
the
binary
hour
clo
c
k
app
ears
in
mo
dule
BinaryHourClo
ck
of
Figure
10.3
on
the
next
page.
10.8.2
Rening
a
Channel
As
our
second
example
of
in
terface
renemen
t,
consider
a
system
that
in
teracts
with
its
en
vironmen
t
b
y
sending
n
um
b
ers
from
1
through
12
o
v
er
a
c
hannel.
W
e
rene
it
to
a
lo
w
er-lev
el
system
that
is
the
same,
except
it
sends
a
n
um
b
er

160
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
module
BinaryHourClo
ck
extends
Natur
als
v
ariable
bits
H
(hr
)

=
inst
ance
HourClo
ck
BitA
rr
ayV
al
(b
)

=
let
n

=
choose
i
2
Nat
:
domain
b
=
0
:
:
i
val
[i
2
0
:
:
n
]

=
Denes
val
[i
]
to
equal
b
[0]

2
0
+
:
:
:
+
b
[i
]

2
i
.
if
i
=
0
then
b
[0]

2
0
else
(b
[i
]

2
i
)
+
val
[i
 1]
in
val
[n
]
HourV
al
(b
)

=
if
b
2
[(0
:
:
3)
!
f0;
1g]
then
BitA
rr
ayV
al
(b
)
else
99
IR
(b
;
h
)

=
2(h
=
HourV
al
(b
))
BHC

=
9
9
9
9
9
9
hr
:
IR
(bits
;
hr
)
^
H
(hr
)
!
HC
Figure
10.3:
A
sp
ecication
of
a
binary
hour
clo
c
k.
as
a
sequence
of
four
bits.
Eac
h
bit
is
sen
t
separately
,
starting
with
the
left-
most
(most
signican
t)
one.
F
or
example,
to
send
the
n
um
b
er
5,
the
lo
w
er-lev
el
system
sends
the
sequence
of
bits
0,
1,
0,
1.
W
e
sp
ecify
b
oth
c
hannels
with
the
Channel
mo
dule
of
Figure
3.2
on
page
30,
so
eac
h
v
alue
that
is
sen
t
m
ust
b
e
ac
kno
wledged
b
efore
the
next
one
can
b
e
sen
t.
Supp
ose
HSp
e
c
is
the
higher-lev
el
system's
sp
ecication,
and
its
c
hannel
is
represen
ted
b
y
the
v
ariable
h
.
Let
l
b
e
the
v
ariable
represen
ting
the
lo
w
er-lev
el
c
hannel.
W
e
write
the
lo
w
er-lev
el
system's
sp
ecication
as
9
9
9
9
9
9
h
:
IR
^
HSp
e
c
(10.8)
where
IR
sp
ecies
the
sequence
of
v
alues
sen
t
o
v
er
h
as
a
function
of
the
v
alues
sen
t
o
v
er
l
.
The
sending
of
the
fourth
bit
on
l
is
in
terpreted
as
the
sending
of
the
complete
n
um
b
er
on
h
;
the
next
ac
kno
wledgmen
t
on
l
is
in
terpreted
as
the
sending
of
the
ac
kno
wledgmen
t
on
h
;
and
an
y
other
step
is
in
terpreted
as
a
step
that
do
esn't
c
hange
h
.
T
o
dene
IR
,
w
e
instan
tiate
mo
dule
Channel
for
eac
h
of
the
c
hannels:
Data
is
the
set
of
v
alues
that
can
b
e
sen
t
o
v
er
the
c
hannel.
H

=
inst
ance
Channel
with
chan
 
h
;
Data
 
1
:
:
12
L

=
inst
ance
Channel
with
chan
 
l
;
Data
 
f0;
1g
Sending
a
v
alue
d
o
v
er
c
hannel
l
is
th
us
represen
ted
b
y
an
L
!
Send
(d
)
step,
and
ac
kno
wledging
receipt
of
a
v
alue
on
c
hannel
h
is
represen
ted
b
y
an
H
!
R
cv
step.
The
follo
wing
b
eha
vior
represen
ts
sending
and
ac
kno
wledging
a
5,
where
I
ha
v
e

10.8.
INTERF
A
CE
REFINEMENT
161
omitted
all
steps
that
don't
c
hange
l
:
s
0
L
!
Send
(0)
 !
s
1
L
!
R
cv
 !
s
2
L
!
Send
(1)
 !
s
3
L
!
R
cv
 !
s
4
L
!
Send
(0)
 !
s
5
L
!
R
cv
 !
s
6
L
!
Send
(1)
 !
s
7
L
!
R
cv
 !
s
8
 !



This
b
eha
vior
will
satisfy
IR
i
s
6
!
s
7
is
an
H
!
Send
(5)
step,
s
7
!
s
8
is
an
H
!
R
cv
step,
and
all
the
other
steps
lea
v
e
h
unc
hanged.
W
e
w
an
t
to
mak
e
sure
that
(10.8)
is
not
satised
unless
l
represen
ts
a
correct
lo
w
er-lev
el
c
hannel|for
example,
(10.8)
should
b
e
false
if
l
is
set
to
some
bizarre
v
alue.
W
e
will
therefore
dene
IR
so
that,
if
the
sequence
of
v
alues
assumed
b
y
l
do
es
not
represen
t
a
c
hannel
o
v
er
whic
h
bits
are
sen
t
and
ac
kno
wledged,
then
the
sequence
of
v
alues
of
h
do
es
not
represen
t
a
correct
b
eha
vior
of
a
c
hannel
o
v
er
whic
h
n
um
b
ers
from
1
to
12
are
sen
t.
F
orm
ula
HSp
e
c
,
and
hence
(10.8),
will
then
b
e
false
for
suc
h
a
b
eha
vior.
F
orm
ula
IR
will
ha
v
e
the
standard
form
for
a
TLA
sp
ecication,
with
an
initial
condition
and
a
next-state
action.
Ho
w
ev
er,
it
sp
ecies
h
as
a
function
of
l
;
it
do
es
not
constrain
l
.
Therefore,
the
initial
condition
do
es
not
sp
ecify
the
initial
v
alue
of
l
,
and
the
next-state
action
do
es
not
sp
ecify
the
v
alue
of
l
0
.
(The
v
alue
of
l
is
constrained
implicitly
b
y
IR
,
whic
h
asserts
a
relation
b
et
w
een
the
v
alues
of
h
and
l
,
together
with
the
conjunct
HSp
e
c
in
(10.8),
whic
h
constrains
the
v
alue
of
h
.)
F
or
the
next-state
action
to
sp
ecify
the
v
alue
sen
t
on
h
,
w
e
need
an
in
ternal
v
ariable
that
remem
b
ers
what
has
b
een
sen
t
on
l
since
the
last
complete
n
um
b
er.
W
e
let
the
v
ariable
bitsSent
con
tain
the
sequence
of
bits
sen
t
so
far
for
the
curren
t
n
um
b
er.
F
or
con
v
enience,
bitsSent
con
tains
the
sequence
of
bits
in
rev
erse
order,
with
the
most
recen
tly-sen
t
bit
at
the
head.
This
means
that
the
high-order
bit
of
the
n
um
b
er,
whic
h
is
sen
t
rst,
is
at
the
tail
of
bitsSent
.
The
denition
of
IR
app
ears
in
mo
dule
ChannelR
enement
of
Figure
10.4
on
the
next
page.
The
mo
dule
rst
denes
Err
orV
al
to
b
e
an
arbitrary
v
alue
that
is
not
a
legal
v
alue
of
h
.
Next
comes
the
denition
of
the
function
BitSe
qT
oNat
.
If
s
is
a
sequence
of
bits,
then
BitSe
qT
oNat
[s
]
is
its
n
umeric
v
alue
in
terpreted
as
a
binary
n
um
b
er
whose
lo
w-order
bit
is
at
the
head
of
s
.
F
or
example
BitSe
qT
oNat
[h
0;
1;
1
i]
equals
6.
Then
come
the
t
w
o
instan
tiations
of
mo
dule
Channel
.
There
follo
ws
a
submo
dule
that
denes
the
in
ternal
sp
ecication|the
one
The
use
of
a
sub-
mo
dule
to
dene
an
in
ternal
sp
ec-
ication
w
as
in-
tro
duced
in
the
real-time
hour-
clo
c
k
sp
ecication
of
Section
9.1.
with
the
in
ternal
v
ariable
bitsSent
visible.
The
in
ternal
sp
ecication's
initial
predicate
Init
asserts
that
if
l
has
a
legal
initial
v
alue,
then
h
can
ha
v
e
an
y
legal
initial
v
alue;
otherwise
h
has
an
illegal
v
alue.
Initially
bitsSent
is
the
empt
y
sequence
h
i.
The
in
ternal
sp
ecication's
next-state
action
is
the
disjunction
of
three
actions:
SendBit
A
SendBit
step
is
one
in
whic
h
a
bit
is
sen
t
on
l
.
If
bitsSent
has
few
er
than
three
elemen
ts,
so
few
er
than
three
bits
ha
v
e
already
b
een
sen
t,
then
the
bit
is
prep
ended
to
the
head
of
bitsSent
and
h

162
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
module
ChannelR
enement
This
mo
dule
denes
an
in
terface
renemen
t
from
a
higher-lev
el
c
hannel
h
,
o
v
er
whic
h
n
um
b
ers
in
1
:
:
12
are
sen
t,
to
a
lo
w
er-lev
el
c
hannel
l
in
whic
h
a
n
um
b
er
is
sen
t
as
a
sequence
of
four
bits,
eac
h
separately
ac
kno
wl-
edged.
(See
the
Channel
mo
dule
in
Figure
3.2
on
page
30.)
F
orm
ula
IR
is
true
i
the
sequence
of
v
alues
as-
sumed
b
y
h
represen
ts
the
higher-lev
el
view
of
the
sequence
of
v
alues
sen
t
on
l
.
If
the
sequence
of
v
alues
as-
sumed
b
y
l
do
esn't
represen
t
the
sending
and
ac
kno
wledging
of
bits,
then
h
assumes
an
illegal
v
alue.
extends
Natur
als
;
Se
quenc
es
v
ariables
h
;
l
Err
orV
al

=
choose
v
:
v
=
2
[val
:
1
:
:
12;
r
dy
:
f0;
1g;
ack
:
f0;
1g]
BitSe
qT
oNat
[s
2
Se
q
(f0;
1g)]

=
BitSe
qT
oNat
[h
b
0
;
b
1
;
b
2
;
b
3
i]
=
b
0
+
2

(b
1
+
2

(b
2
+
2

b
3
))
if
s
=
h
i
then
0
else
He
ad
(s
)
+
2

BitSe
qT
oNat
[T
ail
(s
)]
H

=
inst
ance
Channel
with
chan
 
h
;
Data
 
1
:
:
12
L

=
inst
ance
Channel
with
chan
 
l
;
Data
 
f0;
1g
H
is
a
c
hannel
for
sending
n
um
b
ers
in
1
:
:
12;
L
is
a
c
hannel
for
sending
bits.
module
Inner
v
ariable
bitsSent
The
sequence
of
the
bits
sen
t
so
far
for
the
curren
t
n
um
b
er.
Init

=
^
bitsSent
=
h
i
^
if
L
!
Init
then
H
!
Init
else
h
=
Err
orV
al
Denes
the
initial
v
alue
of
h
as
a
function
of
l
.
SendBit

=
9
b
2
f0;
1g
:
^
L
!
Send
(b
)
^
if
L
en
(bitsSent
)
<
3
then
^
bitsSent
0
=
h
b
i

bitsSent
^
unchanged
h
else
^
bitsSent
0
=
h
i
^
H
!
Send
(BitSe
qT
oNat
[h
b
i

bitsSent
])
Sending
one
of
the
rst
three
bits
on
l
prep
ends
it
to
the
fron
t
of
bitsSent
and
lea
v
es
h
unc
hanged;
sending
the
fourth
bit
resets
bitsSent
and
sends
the
complete
n
um
b
er
on
h
.
R
cvBit

=
^
L
!
R
cv
^
if
bitsSent
=
h
i
then
H
!
R
cv
else
unchanged
h
^
unchanged
bitsSent
A
R
cv
action
on
l
causes
a
R
cv
action
on
h
i
it
follo
ws
the
sending
of
the
fourth
bit.
Err
or

=
^
l
0
6=
l
^
:((9
b
2
f0;
1g
:
L
!
Send
(b
))
_
L
!
R
cv
)
^
h
0
=
Err
orV
al
An
illegal
action
on
l
sets
h
to
Err
orV
al
.
Next

=
SendBit
_
R
cvBit
_
Err
or
InnerIR

=
Init
^
2[Next
]
h
l
;
h
;
bitsSent
i
I
(bitsSent
)

=
inst
ance
Inner
IR

=
9
9
9
9
9
9
bitsSent
:
I
(bitsSent
)
!
InnerIR
Figure
10.4:
Rening
a
c
hannel.

10.8.
INTERF
A
CE
REFINEMENT
163
is
left
unc
hanged.
Otherwise,
the
v
alue
represen
ted
b
y
the
four
bits
sen
t
so
far,
including
the
curren
t
bit,
is
sen
t
on
h
and
bitsSent
is
reset
to
h
i.
R
cvBit
A
R
cvBit
step
is
one
in
whic
h
an
ac
kno
wledgmen
t
is
sen
t
on
l
.
It
represen
ts
the
sending
of
an
ac
kno
wledgmen
t
on
h
i
this
is
an
ac
kno
wledgmen
t
of
the
fourth
bit,
whic
h
is
true
i
bitsSent
is
the
empt
y
sequence.
Err
or
An
Err
or
step
is
one
in
whic
h
an
illegal
c
hange
to
l
o
ccurs.
It
sets
h
to
an
illegal
v
alue.
The
inner
sp
ecication
InnerIR
has
the
usual
form.
(There
is
no
liv
eness
require-
men
t.)
The
outer
mo
dule
then
instan
tiates
the
inner
submo
dule
with
bitsSent
as
a
parameter,
and
it
denes
IR
to
equal
InnerIR
with
bitsSent
hidden.
No
w
supp
ose
w
e
ha
v
e
a
mo
dule
HigherSp
e
c
that
denes
a
sp
ecication
HSp
e
c
of
a
system
that
comm
unicates
b
y
sending
n
um
b
ers
from
1
through
12
o
v
er
a
c
hannel
hchan
.
W
e
obtain,
as
follo
ws,
a
lo
w
er-lev
el
sp
ecication
LSp
e
c
in
whic
h
the
n
um
b
ers
are
sen
t
as
sequences
of
bits
on
a
c
hannel
lchan
.
W
e
rst
declare
lchan
and
all
the
v
ariables
and
constan
ts
of
the
HigherSp
e
c
mo
dule
except
hchan
.
W
e
then
write
HS
(hchan
)

=
inst
ance
HigherSp
e
c
CR
(h
)

=
inst
ance
ChannelR
enement
with
l
 
lchan
LSp
e
c

=
9
9
9
9
9
9
h
:
CR
(h
)
!
IR
^
HS
(h
)
!
HSp
e
c
10.8.3
In
terface
Renemen
t
in
General
In
the
examples
of
the
binary
clo
c
k
and
of
c
hannel
renemen
t,
w
e
dened
a
lo
w
er-lev
el
sp
ecication
LSp
e
c
in
terms
of
a
higher-lev
el
one
HSp
e
c
as
LSp
e
c

=
9
9
9
9
9
9
h
:
IR
^
HSp
e
c
(10.9)
where
h
is
a
free
v
ariable
of
HSp
e
c
and
IR
is
a
relation
b
et
w
een
h
and
the
lo
w
er-
lev
el
v
ariable
l
of
LSp
e
c
.
W
e
can
view
the
in
ternal
sp
ecication
IR
^
HSp
e
c
as
the
comp
osition
of
t
w
o
comp
onen
ts,
as
sho
wn
here:
l
-
IR
HSp
e
c
h
-
W
e
can
regard
IR
as
the
sp
ecication
of
a
comp
onen
t
that
transforms
the
lo
w
er-
lev
el
b
eha
vior
of
l
in
to
the
higher-lev
el
b
eha
vior
of
h
.
F
orm
ula
IR
is
called
an
interfac
e
r
enement.

164
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
In
b
oth
examples,
the
in
terface
renemen
t
is
indep
enden
t
of
the
system
sp
ec-
ication.
It
dep
ends
only
on
the
represen
tation
of
the
in
terface|that
is,
on
ho
w
the
in
teraction
b
et
w
een
the
system
and
its
en
vironmen
t
is
represen
ted.
In
gen-
eral,
for
an
in
terface
renemen
t
IR
to
b
e
indep
enden
t
of
the
system
using
the
in
terface,
it
should
ascrib
e
a
b
eha
vior
of
the
higher-lev
el
in
terface
v
ariable
h
to
an
y
b
eha
vior
of
the
lo
w
er-lev
el
v
ariable
l
.
In
other
w
ords,
for
an
y
sequence
of
v
alues
for
l
,
there
should
b
e
some
sequence
of
v
alues
for
h
that
satisfy
IR
.
This
is
expressed
mathematically
b
y
the
requiremen
t
that
the
form
ula
9
9
9
9
9
9
h
:
IR
should
b
e
v
alid|that
is,
true
for
all
b
eha
viors.
So
far,
I
ha
v
e
discussed
renemen
t
of
a
single
in
terface
v
ariable
h
b
y
a
single
v
ariable
l
.
This
generalizes
in
the
ob
vious
w
a
y
to
the
renemen
t
of
a
collection
of
higher-lev
el
v
ariables
h
1
;
:
:
:
;
h
n
b
y
the
v
ariables
l
1
;
:
:
:
;
l
m
.
The
in
terface
renemen
t
IR
sp
ecies
the
v
alues
of
the
h
i
in
terms
of
the
v
alues
of
the
l
j
and
p
erhaps
of
other
v
ariables
as
w
ell.
F
orm
ula
(10.9)
is
replaced
b
y
LSp
e
c

=
9
9
9
9
9
9
h
1
;
:
:
:
;
h
n
:
IR
^
HSp
e
c
A
particularly
simple
t
yp
e
of
in
terface
renemen
t
is
a
data
r
enement,
in
whic
h
IR
has
the
form
2P
,
where
P
is
a
state
predicate
that
expresses
the
v
alues
of
the
higher-lev
el
v
ariables
h
1
;
:
:
:
;
h
n
as
functions
of
the
v
alues
of
the
lo
w
er-lev
el
v
ariables
l
1
;
:
:
:
;
l
m
.
The
in
terface
renemen
t
in
our
binary
clo
c
k
sp
ecication
is
a
data
renemen
t,
where
P
is
the
predicate
hr
=
HourV
al
(bits
).
As
another
example,
the
t
w
o
sp
ecications
of
an
async
hronous
c
hannel
in
ter-
face
in
Chapter
3
can
eac
h
b
e
obtained
from
the
other
b
y
an
in
terface
rene-
men
t.
The
sp
ecication
Sp
e
c
of
the
Channel
mo
dule
(page
30)
is
equiv
alen
t
to
the
sp
ecication
obtained
as
a
data
renemen
t
of
the
sp
ecication
Sp
e
c
of
the
AsynchInterfac
e
mo
dule
(page
27)
b
y
letting
P
equal
chan
=
[val
7!
val
;
r
dy
7!
r
dy
;
ack
7!
ack
]
(10.10)
This
form
ula
asserts
that
chan
is
a
record
whose
val
eld
is
the
v
alue
of
the
v
ari-
able
val
,
whose
r
dy
eld
is
the
v
alue
of
the
v
ariable
r
dy
,
and
whose
ack
eld
is
the
v
alue
of
the
v
ariable
ack
.
Con
v
ersely
,
sp
ecication
Sp
e
c
of
the
AsynchInterfac
e
mo
dule
is
equiv
alen
t
to
a
data
renemen
t
of
the
sp
ecication
Sp
e
c
of
the
Channel
mo
dule.
In
this
case,
dening
the
state
predicate
P
is
a
little
tric
ky
.
The
ob
vious
c
hoice
is
to
let
P
b
e
the
form
ula
Go
o
dV
als
dened
b
y
Go
o
dV
als

=
^
val
=
chan
:val
^
r
dy
=
chan
:r
dy
^
ack
=
chan
:ack
Ho
w
ev
er,
this
can
assert
that
val
,
r
dy
,
and
ack
ha
v
e
go
o
d
v
alues
ev
en
if
chan
has
an
illegal
v
alue|for
example,
if
it
is
a
record
with
more
than
three
elds.
Instead,
w
e
let
P
equal
if
chan
2
[val
:
Data
;
r
dy
:
f0;
1g;
ack
:
f0;
1g]
then
Go
o
dV
als
else
BadV
als

10.8.
INTERF
A
CE
REFINEMENT
165
where
BadV
als
asserts
that
val
,
r
dy
,
and
ack
ha
v
e
some
illegal
v
alues|that
is,
v
alues
that
are
imp
ossible
in
a
b
eha
vior
satisfying
form
ula
Sp
e
c
of
mo
dule
AsynchInterfac
e
.
(W
e
don't
need
suc
h
a
tric
k
when
dening
chan
as
a
function
of
val
,
r
dy
,
and
ack
b
ecause
(10.10)
implies
that
the
v
alue
of
chan
is
legal
i
the
v
alues
of
all
three
v
ariables
val
,
r
dy
,
and
ack
are
legal.)
Data
renemen
t
is
the
simplest
form
of
in
terface
renemen
t.
In
a
more
complicated
in
terface
renemen
t,
the
v
alue
of
the
higher-lev
el
v
ariables
cannot
b
e
expressed
as
a
function
of
the
curren
t
v
alues
of
the
lo
w
er-lev
el
v
ariables.
In
the
c
hannel
renemen
t
example
of
Section
10.8.2,
the
n
um
b
er
b
eing
sen
t
on
the
higher-lev
el
c
hannel
dep
ends
on
the
v
alues
of
bits
that
w
ere
previously
sen
t
on
the
lo
w
er-lev
el
c
hannel,
not
just
on
the
lo
w
er-lev
el
c
hannel's
curren
t
state.
W
e
often
rene
b
oth
a
system
and
its
in
terface
at
the
same
time.
F
or
ex-
ample,
w
e
ma
y
implemen
t
a
sp
ecication
H
of
a
system
that
comm
unicates
b
y
sending
n
um
b
ers
o
v
er
a
c
hannel
with
a
lo
w
er-lev
el
sp
ecication
LImpl
of
a
sys-
tem
that
sends
individual
bits.
In
this
case,
LImpl
is
not
itself
obtained
from
HSp
e
c
b
y
an
in
terface
renemen
t.
Rather,
LImpl
implemen
ts
some
sp
ecication
LSp
e
c
that
is
obtained
from
HSp
e
c
b
y
an
in
terface
renemen
t
IR
.
In
that
case,
w
e
sa
y
that
LImpl
implemen
ts
HSp
e
c
under
the
interfac
e
r
enement
IR
.
10.8.4
Op
en-System
Sp
ecications
So
far,
w
e
ha
v
e
considered
in
terface
renemen
t
for
complete-system
sp
ecica-
tions.
Let's
no
w
consider
what
happ
ens
if
the
higher-lev
el
sp
ecication
HSp
e
c
is
the
kind
of
op
en-system
sp
ecication
discussed
in
Section
10.7
ab
o
v
e.
F
or
simplicit
y
,
w
e
consider
the
renemen
t
of
a
single
higher-lev
el
in
terface
v
ariable
h
b
y
a
single
lo
w
er-lev
el
v
ariable
l
.
The
generalization
to
more
v
ariables
will
b
e
ob
vious.
Let's
supp
ose
rst
that
HSp
e
c
is
a
safet
y
prop
ert
y
,
with
no
liv
eness
condition.
As
explained
in
Section
10.7,
the
sp
ecication
attributes
eac
h
c
hange
to
h
either
to
the
system
or
to
the
en
vironmen
t.
An
y
c
hange
to
a
lo
w
er-lev
el
in
terface
v
ariable
l
that
pro
duces
a
c
hange
to
h
is
therefore
attributed
to
the
system
or
the
en
vironmen
t.
A
bad
c
hange
to
h
that
is
attributed
to
the
en
vironmen
t
mak
es
HSp
e
c
true;
a
bad
c
hange
that
is
attributed
to
the
system
mak
es
HSp
e
c
false.
Th
us,
(10.9)
denes
LSp
e
c
to
b
e
an
op
en-system
sp
ecication.
F
or
this
to
b
e
a
sensible
sp
ecication,
the
in
terface
renemen
t
IR
m
ust
ensure
that
the
w
a
y
c
hanges
to
l
are
attributed
to
the
system
or
en
vironmen
t
is
sensible.
If
HSp
e
c
con
tains
liv
eness
conditions,
then
in
terface
renemen
t
can
b
e
more
subtle.
Supp
ose
IR
is
the
in
terface
renemen
t
dened
in
the
ChannelR
enement
mo
dule
of
Figure
10.4
on
page
162,
and
supp
ose
that
HSp
e
c
requires
that
the
system
ev
en
tually
send
some
n
um
b
er
on
h
.
Consider
a
b
eha
vior
in
whic
h
the
system
sends
the
rst
bit
of
a
n
um
b
er
on
l
,
but
the
en
vironmen
t
nev
er
ac
kno
wl-
edges
it.
Under
the
in
terface
renemen
t
IR
,
this
b
eha
vior
is
in
terpreted
as
one
in
whic
h
h
nev
er
c
hanges.
Suc
h
a
b
eha
vior
fails
to
satisfy
the
liv
eness
condition

166
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
of
HSp
e
c
.
Th
us,
if
LSp
e
c
is
dened
b
y
(10.9),
then
failure
of
the
en
vironmen
t
to
do
something
can
cause
LSp
e
c
to
b
e
violated,
through
no
fault
of
the
system.
In
this
example,
w
e
w
an
t
the
en
vironmen
t
to
b
e
at
fault
if
it
causes
the
system
to
halt
b
y
failing
to
ac
kno
wledge
an
y
of
the
rst
three
bits
of
a
n
um
b
er
sen
t
b
y
the
system.
(The
ac
kno
wledgmen
t
of
the
fourth
bit
is
in
terpreted
b
y
IR
as
the
ac
kno
wledgmen
t
of
a
v
alue
sen
t
on
h
,
so
blame
for
its
absence
is
prop
erly
assigned
to
the
en
vironmen
t.)
Putting
the
en
vironmen
t
at
fault
means
making
LSp
e
c
true.
W
e
can
ac
hiev
e
this
b
y
mo
difying
(10.9)
to
dene
LSp
e
c
as
follo
ws:
LSp
e
c

=
Liveness
)
9
9
9
9
9
9
h
:
IR
^
HSp
e
c
(10.11)
where
Liveness
is
a
form
ula
requiring
that
an
y
bit
sen
t
on
l
,
other
than
the
last
bit
of
a
n
um
b
er,
m
ust
ev
en
tually
b
e
ac
kno
wledged.
Ho
w
ev
er,
if
l
is
set
to
an
illegal
v
alue,
then
w
e
w
an
t
the
safet
y
part
of
the
sp
ecication
to
determine
who
is
resp
onsible.
So,
w
e
w
an
t
Liveness
to
b
e
true
in
this
case.
W
e
dene
Liveness
in
terms
of
the
inner
v
ariables
h
and
bitsSent
,
whic
h
are
related
to
l
b
y
form
ula
InnerIR
from
the
Inner
submo
dule
of
mo
dule
ChannelR
enement
.
(Remem
b
er
that
l
should
b
e
the
only
free
v
ariable
of
LSp
e
c
.)
The
action
that
ac
kno
wledges
receipt
of
one
of
the
rst
three
bits
of
the
n
um
b
er
is
R
cvBit
^
(bitsSent
6=
h
i).
W
eak
fairness
of
this
action
asserts
that
the
required
ac
kno
wledgmen
ts
m
ust
ev
en
tually
b
e
sen
t.
F
or
the
case
of
illegal
v
alues,
recall
that
sending
a
bad
v
alue
on
l
causes
h
to
equal
Err
orV
al
.
W
e
w
an
t
Liveness
to
b
e
true
if
this
ev
er
happ
ens,
whic
h
means
if
it
ev
en
tually
happ
ens.
W
e
therefore
add
the
follo
wing
denition
to
the
submo
dule
Inner
of
the
ChannelR
enement
mo
dule:
InnerLiveness

=
^
InnerIR
^
_
WF
h
l
;
h
;
bitsSent
i
(R
cvBit
^
(bitsSent
6=
h
i))
_
3(h
=
Err
orV
al
)
T
o
dene
Liveness
,
w
e
ha
v
e
to
hide
h
and
bitsSent
in
InnerLiveness
.
W
e
can
do
this,
in
a
con
text
in
whic
h
l
is
declared,
as
follo
ws:
ICR
(h
)

=
inst
ance
ChannelR
enement
Liveness

=
9
9
9
9
9
9
h
;
bitsSent
:
ICR
(h
)
!
I
(bitsSent
)
!
InnerLiveness
No
w,
supp
ose
it
is
the
en
vironmen
t
that
sends
n
um
b
ers
o
v
er
h
and
the
system
is
supp
osed
to
ac
kno
wledge
their
receipt
and
then
pro
cess
them
in
some
w
a
y
.
In
this
case,
w
e
w
an
t
failure
to
ac
kno
wledge
a
bit
to
b
e
a
system
error.
So,
LSp
e
c
should
b
e
false
if
Liveness
is.
The
sp
ecication
should
then
b
e
LSp
e
c

=
Liveness
^
(
9
9
9
9
9
9
h
:
IR
^
HSp
e
c
)
Since
h
do
es
not
o
ccur
free
in
Liveness
,
this
denition
is
equiv
alen
t
to
LSp
e
c

=
9
9
9
9
9
9
h
:
Liveness
^
IR
^
HSp
e
c

10.9.
SHOULD
YOU
COMPOSE?
167
whic
h
has
the
form
(10.9)
if
the
in
terface
renemen
t
IR
of
(10.9)
is
tak
en
to
b
e
Liveness
^
IR
.
In
other
w
ords,
w
e
can
w
e
mak
e
the
liv
eness
condition
part
of
the
in
terface
renemen
t.
(In
this
case,
w
e
can
simplify
the
denition
b
y
adding
liv
eness
directly
to
InnerIR
.)
In
general,
if
HSp
e
c
is
an
op
en-system
sp
ecication
that
describ
es
liv
eness
as
w
ell
as
safet
y
,
then
an
in
terface
renemen
t
ma
y
ha
v
e
to
tak
e
the
form
of
form
ula
(10.11).
Both
Liveness
and
the
liv
eness
condition
of
IR
ma
y
dep
end
on
whic
h
c
hanges
to
the
lo
w
er-lev
el
in
terface
v
ariable
l
are
attributed
to
the
system
and
whic
h
to
the
en
vironmet.
F
or
the
c
hannel
renemen
t,
this
means
that
they
will
dep
end
on
whether
the
system
or
the
en
vironmen
t
is
sending
v
alues
on
the
c
hannel.
10.9
Should
Y
ou
Comp
ose?
When
sp
ecifying
a
system,
should
w
e
write
a
monolithic
sp
ecication
with
a
single
next-state
action,
a
closed-system
comp
osition
that
is
the
conjunction
of
sp
ecications
of
individual
comp
onen
ts,
or
an
op
en-system
sp
ecication?
The
answ
er
is:
it
usually
mak
es
little
dierence.
F
or
a
real
system,
the
denitions
of
the
comp
onen
ts'
actions
will
tak
e
h
undreds
or
thousands
of
lines.
The
dieren
t
forms
of
sp
ecication
dier
only
in
the
few
lines
where
w
e
assem
ble
the
initial
predicates
and
next-state
actions
in
to
the
nal
form
ula.
If
y
ou
are
writing
a
sp
ecication
from
scratc
h,
it's
probably
b
etter
to
write
a
monolithic
sp
ecication.
It
is
usually
easier
to
understand.
Of
course,
there
are
exceptions.
W
e
write
a
real-time
sp
ecication
as
the
conjunction
of
an
un-
timed
sp
ecication
and
timing
constrain
ts;
describing
the
c
hanges
to
the
system
v
ariables
and
the
timers
with
a
single
next-state
action
usually
mak
es
the
sp
ec-
ication
harder
to
understand.
W
riting
a
comp
osite
sp
ecication
ma
y
b
e
sensible
when
y
ou
are
starting
from
an
existing
sp
ecication.
If
y
ou
already
ha
v
e
a
sp
ecication
of
one
comp
onen
t,
y
ou
ma
y
w
an
t
to
write
a
separate
sp
ecication
of
the
other
comp
onen
t
and
comp
ose
the
t
w
o
sp
ecications.
If
y
ou
ha
v
e
a
higher-lev
el
sp
ecication,
y
ou
ma
y
w
an
t
to
write
a
lo
w
er-lev
el
v
ersion
as
an
in
terface
renemen
t.
Ho
w
ev
er,
these
are
rather
rare
situations.
Moreo
v
er,
it's
lik
ely
to
b
e
just
as
easy
to
mo
dify
the
original
sp
ecication
or
reuse
it
in
another
w
a
y
.
F
or
example,
instead
of
conjoining
a
new
comp
onen
t
to
the
sp
ecication
of
an
existing
one,
y
ou
can
simply
include
the
denition
of
the
existing
comp
onen
t's
next-state
action,
with
an
extends
or
inst
ance
statemen
t,
as
part
of
the
new
sp
ecication.
Comp
osition
pro
vides
a
new
w
a
y
of
writing
a
complete-system
sp
ecication;
it
do
esn't
c
hange
the
sp
ecication.
The
c
hoice
b
et
w
een
a
comp
osite
sp
ecication
and
a
monolithic
one
is
therefore
ultimately
a
matter
of
taste.
Disjoin
t-state
comp
ositions
are
generally
straigh
tforw
ard
and
presen
t
no
problems.
Shared-
state
comp
ositions
can
b
e
tric
ky
and
require
care.

168
CHAPTER
10.
COMPOSING
SPECIFICA
TIONS
Op
en-system
sp
ecications
in
tro
duce
a
mathematically
dieren
t
kind
of
sp
ec-
ication.
A
closed-system
sp
ecication
E
^
M
and
its
op
en-system
coun
terpart
E
+
 .
M
are
not
equiv
alen
t.
If
w
e
really
w
an
t
a
sp
ecication
to
serv
e
as
a
legal
con
tract
b
et
w
een
a
user
and
an
implemen
ter,
then
w
e
ha
v
e
to
write
an
op
en-
system
sp
ecication.
W
e
also
need
op
en-system
sp
ecications
if
w
e
w
an
t
to
sp
ecify
and
reason
ab
out
systems
built
b
y
comp
osing
o-the-shelf
comp
onen
ts
with
pre-existing
sp
ecications.
All
w
e
can
assume
ab
out
suc
h
a
comp
onen
t
is
that
it
satises
a
con
tract
b
et
w
een
the
system
builder
and
the
supplier,
and
suc
h
a
con
tract
can
b
e
formalized
only
as
an
op
en-system
sp
ecication.
Ho
w
ev
er,
y
ou
are
unlik
ely
to
encoun
ter
o-the-shelf
comp
onen
t
sp
ecications
during
the
early
part
of
the
t
w
en
t
y-rst
cen
tury
.
In
the
near
future,
op
en-system
sp
ecications
are
lik
ely
to
b
e
of
theoretical
in
terest
only
.

Chapter
11
Adv
anced
Examples
It
w
ould
b
e
nice
to
pro
vide
an
assortmen
t
of
t
ypical
examples
that
co
v
er
most
of
the
sp
ecication
problems
that
arise
in
practice.
Ho
w
ev
er,
there
is
no
suc
h
thing
as
a
t
ypical
sp
ecication.
Ev
ery
real
sp
ecication
seems
to
p
ose
its
o
wn
problems.
But
w
e
can
partition
all
sp
ecications
in
to
t
w
o
classes,
dep
ending
on
whether
or
not
they
con
tain
v
ariable
declarations.
A
sp
ecication
with
no
v
ariables
denes
data
structures
and
op
erations
on
those
structures.
F
or
example,
the
Se
quenc
es
mo
dule
denes
v
arious
op
erations
on
sequences.
When
sp
ecifying
a
system,
y
ou
ma
y
need
some
kind
of
data
structure
other
than
the
ones
pro
vided
b
y
the
standard
mo
dules
lik
e
Se
quenc
es
and
Bags
,
describ
ed
in
Chapter
18.
Section
11.1
giv
es
some
examples
of
data
structure
sp
ecications.
A
system
sp
ecication
con
tains
v
ariables
that
represen
t
the
system's
state.
W
e
can
further
divide
system
sp
ecications
in
to
t
w
o
classes|high-lev
el
sp
eci-
cations
that
describ
e
what
it
means
for
a
system
to
b
e
correct,
and
lo
w
er-lev
el
sp
ecications
that
describ
e
what
the
system
actually
do
es.
In
the
memory
ex-
ample
of
Chapter
5,
the
linearizable
memory
sp
ecication
of
Section
5.3
is
a
high-lev
el
sp
ecication
of
correctness,
while
the
write-through
cac
he
sp
ecica-
tion
of
Section
5.6
describ
es
ho
w
a
particular
algorithm
w
orks.
This
distinction
is
not
precise;
whether
a
sp
ecication
is
high-
or
lo
w-lev
el
is
a
matter
of
p
er-
sp
ectiv
e.
But
it
can
b
e
a
useful
w
a
y
of
categorizing
system
sp
ecications.
Lo
w
er-lev
el
system
sp
ecications
tend
to
b
e
relativ
ely
straigh
tforw
ard.
Once
the
lev
el
of
abstraction
has
b
een
c
hosen,
writing
the
sp
ecication
is
usually
just
a
matter
of
getting
the
details
righ
t
when
describing
what
the
system
do
es.
Sp
ec-
ifying
high-lev
el
correctness
can
b
e
m
uc
h
more
subtle.
Section
11.2
considers
a
high-lev
el
sp
ecication
problem|formally
sp
ecifying
a
m
ultipro
cessor
memory
.
169

170
CHAPTER
11.
AD
V
ANCED
EXAMPLES
11.1
Sp
ecifying
Data
Structures
Most
of
the
data
structures
required
for
writing
sp
ecications
are
mathemat-
ically
simple
and
are
easy
to
dene
in
terms
of
sets,
functions,
and
records.
Section
11.1.2
describ
es
the
sp
ecication
of
one
suc
h
structure|a
graph.
On
rare
o
ccasions,
a
sp
ecication
will
require
sophisticated
mathematical
concepts.
The
only
examples
I
kno
w
of
are
h
ybrid
system
sp
ecications,
discussed
in
Sec-
tion
9.5.
There,
w
e
used
a
mo
dule
for
describing
the
solutions
to
dieren
tial
equations.
That
mo
dule
is
sp
ecied
in
Section
11.1.3
b
elo
w.
Section
11.1.4
considers
the
tric
ky
problem
of
dening
op
erators
for
sp
ecifying
BNF
gram-
mars.
Although
not
the
kind
of
data
structure
y
ou're
lik
ely
to
need
for
a
system
sp
ecication,
sp
ecifying
BNF
grammars
pro
vides
a
nice
little
exercise
in
\math-
ematization".
The
mo
dule
dev
elop
ed
in
that
section
is
used
in
Chapter
15
for
sp
ecifying
the
grammar
of
TLA
+
.
But,
b
efore
sp
ecifying
data
structures,
y
ou
should
kno
w
ho
w
to
mak
e
lo
cal
denitions.
11.1.1
Lo
cal
Denitions
In
the
course
of
sp
ecifying
a
system,
w
e
write
lots
of
auxiliary
denitions.
A
system
sp
ecication
ma
y
consist
of
a
single
form
ula
Sp
e
c
,
but
w
e
dene
dozens
of
other
iden
tiers
in
terms
of
whic
h
w
e
dene
Sp
e
c
.
These
other
iden
tiers
often
ha
v
e
fairly
common
names|for
example,
the
iden
tier
Next
is
dened
in
man
y
sp
ecications.
The
dieren
t
denitions
of
Next
don't
conict
with
one
another
b
ecause,
if
a
mo
dule
that
denes
Next
is
used
as
part
of
another
sp
ecication,
it
is
usually
instan
tiated
with
renaming.
F
or
example,
the
Channel
mo
dule
is
used
in
mo
dule
InnerFIF
O
on
page
38
with
the
statemen
t
InChan

=
inst
ance
Channel
with
:
:
:
The
action
Next
of
the
Channel
mo
dule
is
then
instan
tiated
as
InChan
!
Next
,
so
its
denition
do
esn't
conict
with
the
denition
of
Next
in
the
InnerFIF
O
mo
dule.
A
mo
dule
that
denes
op
erations
on
a
data
structure
is
lik
ely
to
b
e
used
in
an
extends
statemen
t,
whic
h
do
es
no
renaming.
The
mo
dule
migh
t
dene
some
auxiliary
op
erators
that
are
used
only
to
dene
the
op
erators
in
whic
h
w
e're
in
terested.
F
or
example,
w
e
need
the
Dier
entialEquations
mo
dule
only
to
dene
the
single
op
erator
Inte
gr
ate
.
Ho
w
ev
er,
Inte
gr
ate
is
dened
in
terms
of
other
dened
op
erators
with
names
lik
e
Nbhd
and
IsDeriv
.
W
e
don't
w
an
t
these
denitions
to
conict
with
other
uses
of
those
iden
tiers
in
a
mo
dule
that
extends
Dier
entialEquations
.
So,
w
e
w
an
t
the
denitions
of
Nbhd
and
IsDeriv
to
b
e
lo
cal
to
the
Dier
entialEquations
mo
dule.
1
1
W
e
could
use
the
let
construct
to
put
these
auxiliary
denitions
inside
the
denition
of
Inte
gr
ate
,
but
that
tric
k
w
ouldn't
w
ork
if
the
Dier
entialEquations
mo
dule
exp
orted
other
op
erators
b
esides
Inte
gr
ate
that
w
ere
dened
in
terms
of
Nbhd
and
IsDeriv
.

11.1.
SPECIFYING
D
A
T
A
STR
UCTURES
171
TLA
+
pro
vides
a
local
mo
dier
for
making
denitions
lo
cal
to
a
mo
dule.
If
a
mo
dule
M
con
tains
the
denition
local
F
o
o
(x
)

=
:
:
:
then
F
o
o
can
b
e
used
inside
mo
dule
M
just
lik
e
an
y
ordinary
dened
iden
tier.
Ho
w
ev
er,
a
mo
dule
that
extends
or
instan
tiates
M
do
es
not
obtain
the
denition
of
F
o
o
.
That
is,
the
statemen
t
extends
M
in
another
mo
dule
do
es
not
dene
F
o
o
in
that
mo
dule.
Similarly
,
the
statemen
t
N

=
inst
ance
M
do
es
not
dene
N
!
F
o
o
.
The
local
mo
dier
can
also
b
e
applied
to
an
instan
ti-
ation.
The
statemen
t
local
inst
ance
Se
quenc
es
in
mo
dule
M
incorp
orates
in
to
M
the
denitions
from
the
Se
quenc
es
mo
dule.
Ho
w
ev
er,
another
mo
dule
that
extends
or
instan
tiates
M
do
es
not
obtain
those
denitions.
Similarly
,
a
statemen
t
lik
e
local
P
(x
)

=
inst
ance
N
mak
es
all
the
instan
tiated
denitions
lo
cal
to
the
curren
t
mo
dule.
The
local
mo
dier
can
b
e
applied
only
to
denitions
and
inst
ance
state-
men
ts.
It
cannot
b
e
applied
to
a
declaration
or
to
an
extends
statemen
t,
so
y
ou
c
annot
write
either
of
the
follo
wing:
local
const
ant
N
These
are
not
legal
statemen
ts.
local
extends
Se
quenc
es
If
a
mo
dule
has
no
const
ant
or
v
ariable
declarations
and
no
submo
dules,
then
extending
it
and
instan
tiating
it
are
equiv
alen
t.
Th
us,
the
t
w
o
statemen
ts
extends
Se
quenc
es
inst
ance
Se
quenc
es
are
equiv
alen
t.
In
a
mo
dule
that
denes
general
mathematical
op
erators,
I
lik
e
to
mak
e
all
denitions
lo
cal
except
for
the
ones
that
users
of
the
mo
dule
w
ould
exp
ect.
F
or
example,
users
exp
ect
the
Se
quenc
es
mo
dule
to
dene
op
erators
on
sequences,
suc
h
as
App
end
.
They
don't
exp
ect
it
to
dene
op
erators
on
n
um
b
ers,
suc
h
as
+.
The
Se
quenc
es
mo
dule
uses
+
and
other
op
erators
dened
in
the
Natur
als
mo
dule.
But
instead
of
extending
Natur
als
,
it
denes
those
op
erators
with
the
statemen
t
local
inst
ance
Natur
als
The
denitions
of
the
op
erators
from
Natur
als
are
therefore
lo
cal
to
Se
quenc
es
.
A
mo
dule
that
extends
the
Se
quenc
es
mo
dule
could
then
dene
+
to
mean
something
other
than
addition
of
n
um
b
ers.

172
CHAPTER
11.
AD
V
ANCED
EXAMPLES
11.1.2
Graphs
A
graph
is
an
example
of
the
kind
of
simple
data
structure
often
used
in
sp
ecica-
tions.
Let's
no
w
write
a
Gr
aphs
mo
dule
for
use
in
writing
system
sp
ecications.
W
e
m
ust
rst
decide
ho
w
to
represen
t
a
graph
in
terms
of
data
structures
that
are
already
dened|either
built-in
TLA
+
data
structures
lik
e
functions,
or
ones
dened
in
existing
mo
dules.
Our
decision
dep
ends
on
what
kind
of
graphs
w
e
w
an
t
to
represen
t.
Are
w
e
in
terested
in
directed
graphs
or
undirected
graphs?
Finite
or
innite
graphs?
Graphs
with
or
without
self-lo
ops
(edges
from
a
no
de
to
itself
)?
If
w
e
are
sp
ecifying
graphs
for
a
particular
sp
ecication,
the
sp
ecication
will
tell
us
ho
w
to
answ
er
these
questions.
In
the
absence
of
suc
h
guidance,
let's
handle
arbitrary
graphs.
My
fa
v
orite
w
a
y
of
represen
ting
b
oth
directed
and
undirected
graphs
is
to
sp
ecify
arbitrary
directed
graphs,
and
to
dene
an
undirected
graph
as
a
directed
graph
that
con
tains
an
edge
i
it
con
tains
the
opp
osite-p
oin
ting
edge.
Directed
graphs
ha
v
e
a
prett
y
ob
vious
represen
tation:
a
directed
graph
consists
of
a
set
of
no
des
and
a
set
of
edges,
where
an
edge
from
no
de
m
to
no
de
n
is
represen
ted
b
y
the
ordered
pair
h
m
;
n
i.
In
addition
to
deciding
ho
w
to
represen
t
graphs,
w
e
m
ust
decide
ho
w
to
structure
the
Gr
aphs
mo
dule.
The
decision
dep
ends
on
ho
w
w
e
exp
ect
the
mo
dule
to
b
e
used.
F
or
a
sp
ecication
that
uses
a
single
graph,
it
is
most
con
v
enien
t
to
dene
op
erations
on
that
sp
ecic
graph.
So,
w
e
w
an
t
the
Gr
aphs
mo
dule
to
ha
v
e
(constan
t)
parameters
No
de
and
Edge
that
represen
t
the
sets
of
no
des
and
edges
of
a
particular
graph.
A
sp
ecication
could
use
suc
h
a
mo
dule
with
a
statemen
t
inst
ance
Gr
aphs
with
No
de
 
:
:
:
;
Edge
 
:
:
:
where
the
\.
.
.
"s
are
the
sets
of
no
des
and
edges
of
the
particular
graph
ap-
p
earing
in
the
sp
ecication.
On
the
other
hand,
a
sp
ecication
migh
t
use
man
y
dieren
t
graphs.
F
or
example,
it
migh
t
include
a
form
ula
that
asserts
the
exis-
tence
of
a
subgraph,
satisfying
certain
prop
erties,
of
some
giv
en
graph
G
.
Suc
h
a
sp
ecication
needs
op
erators
that
tak
e
a
graph
as
an
argumen
t|for
exam-
ple,
a
Sub
gr
aph
op
erator
dened
so
Sub
gr
aph
(G
)
is
the
set
of
all
subgraphs
of
a
graph
G
.
In
this
case,
the
Gr
aphs
mo
dule
w
ould
ha
v
e
no
parameters,
and
sp
ecications
w
ould
incorp
orate
it
with
an
extends
statemen
t.
Let's
write
this
kind
of
mo
dule.
An
op
erator
lik
e
Sub
gr
aph
tak
es
a
graph
as
an
argumen
t,
so
w
e
ha
v
e
to
decide
ho
w
to
represen
t
a
graph
as
a
single
v
alue.
A
graph
G
consists
of
a
set
N
of
no
des
and
a
set
E
of
edges.
A
mathematician
w
ould
represen
t
G
as
the
ordered
pair
h
N
;
E
i.
Ho
w
ev
er,
G
:no
de
is
more
p
erspicuous
than
G
[1],
so
w
e
represen
t
G
as
a
record
with
no
de
eld
N
and
e
dge
eld
E
.
Ha
ving
made
these
decisions,
it's
easy
to
dene
an
y
standard
op
erator
on
graphs.
W
e
just
ha
v
e
to
decide
what
w
e
should
dene.
Here
are
some
generally
useful
op
erators:

11.1.
SPECIFYING
D
A
T
A
STR
UCTURES
173
IsDir
e
cte
dGr
aph
(G
)
T
rue
i
G
is
an
arbitrary
directed
graph|that
is,
a
record
with
no
de
eld
N
and
e
dge
eld
E
suc
h
that
E
is
a
subset
of
N

N
.
This
op
erator
is
useful
b
ecause
a
sp
ecication
migh
t
w
an
t
to
assert
that
something
is
a
directed
graph.
(T
o
understand
ho
w
to
assert
that
G
is
a
record
with
no
de
and
e
dge
elds,
see
the
denition
of
IsChannel
in
Section
10.3
on
page
140.)
Dir
e
cte
dSub
gr
aph
(G
)
The
set
of
all
subgraphs
of
a
directed
graph
G
.
Alternativ
ely
,
w
e
could
dene
IsDir
e
cte
dSub
gr
aph
(H
;
G
)
to
b
e
true
i
H
is
a
subgraph
of
G
.
Ho
w-
ev
er,
it's
easy
to
express
IsDir
e
cte
dSub
gr
aph
in
terms
of
Dir
e
cte
dSub
gr
aph
:
IsDir
e
cte
dSub
gr
aph
(H
;
G
)

H
2
Dir
e
cte
dSub
gr
aph
(G
)
On
the
other
hand,
it's
a
wkw
ard
to
express
Dir
e
cte
dSub
gr
aph
in
terms
of
IsDir
e
cte
dSub
gr
aph
:
Dir
e
cte
dSub
gr
aph
(G
)
=
choose
S
:
8
H
:
(H
2
S
)

IsDir
e
cte
dSub
gr
aph
(H
;
G
)
Section
6.1
explains
wh
y
w
e
can't
dene
a
set
of
all
directed
graphs,
so
w
e
had
to
dene
the
IsDir
e
cte
dGr
aph
op
erator.
IsUndir
e
cte
dGr
aph
(G
)
Undir
e
cte
dSub
gr
aph
(G
)
These
are
analogous
to
the
op
erators
for
directed
graphs.
As
men
tioned
ab
o
v
e,
an
undirected
graph
is
a
directed
graph
G
suc
h
that
for
ev
ery
edge
h
m
;
n
i
in
G
:e
dge
,
the
in
v
erse
edge
h
n
;
m
i
is
also
in
G
:e
dge
.
Note
that
Dir
e
cte
dSub
gr
aph
(G
)
con
tains
directed
graphs
that
are
not
undirected
graphs|except
for
certain
\degenerate"
graphs
G
,
suc
h
as
graphs
with
no
edges.
Path
(G
)
The
set
of
all
paths
in
G
,
where
a
path
is
an
y
sequence
of
no
des
that
can
b
e
obtained
b
y
follo
wing
edges
in
the
direction
they
p
oin
t.
This
denition
is
useful
b
ecause
man
y
prop
erties
of
a
graph
can
b
e
expressed
in
terms
of
its
set
of
paths.
It
is
con
v
enien
t
to
consider
the
one-elemen
t
sequence
h
n
i
to
b
e
a
path,
for
an
y
no
de
n
.
A
r
eConne
cte
dIn
(m
;
n
;
G
)
T
rue
i
there
is
a
path
from
no
de
m
to
no
de
n
in
G
.
The
utilit
y
of
this
op
erator
b
ecomes
eviden
t
when
y
ou
try
dening
v
arious
common
graph
prop
erties,
lik
e
connectivit
y
.
There
are
an
y
n
um
b
er
of
other
graph
prop
erties
and
classes
of
graphs
that
w
e
migh
t
dene.
Let's
dene
these
t
w
o:

174
CHAPTER
11.
AD
V
ANCED
EXAMPLES
IsStr
onglyConne
cte
d
(G
)
T
rue
i
G
is
strongly
connected,
meaning
that
there
is
a
path
from
an
y
no
de
to
an
y
other
no
de.
F
or
an
undirected
graph,
strongly
connected
is
equiv
alen
t
to
the
ordinary
denition
of
connected.
IsT
r
e
eWithR
o
ot
(G
;
r
)
T
rue
i
G
is
a
tree
with
ro
ot
r
,
where
w
e
represen
t
a
tree
as
a
graph
with
an
edge
from
eac
h
nonro
ot
no
de
to
its
paren
t.
Th
us,
the
paren
t
of
a
nonro
ot
no
de
n
equals
choose
m
2
G
:no
de
:
h
n
;
m
i
2
G
:e
dge
The
Gr
aphs
mo
dule
app
ears
on
the
next
page.
By
no
w,
y
ou
should
b
e
able
to
w
ork
out
for
y
ourself
the
meanings
of
all
the
denitions.
11.1.3
Solving
Dieren
tial
Equations
Section
9.5
on
page
132
describ
es
ho
w
to
sp
ecify
a
h
ybrid
system
whose
state
in-
cludes
a
ph
ysical
v
ariable
satisfying
an
ordinary
dieren
tial
equation.
The
sp
eci-
cation
uses
an
op
erator
Inte
gr
ate
suc
h
that
Inte
gr
ate
(D
;
t
0
;
t
1
;
h
x
0
;
:
:
:
;
x
n
 1
i)
is
the
v
alue
at
time
t
1
of
the
n
-tuple
h
x
;
dx
=dt
;
:
:
:
;
d
n
 1
x
=dt
n
 1
i
where
x
is
a
solution
to
the
dieren
tial
equation
D
[t
;
x
;
dx
=dt
;
:
:
:
;
d
n
x
=dt
n
]
=
0
whose
0
th
through
(n
 1)
st
deriv
ativ
es
at
time
t
0
are
x
0
,
.
.
.
,
x
n
 1
.
W
e
assume
that
there
is
suc
h
a
solution
and
that
it
is
unique.
Dening
Inte
gr
ate
illustrates
ho
w
to
express
sophisticated
mathematics
in
TLA
+
.
W
e
start
b
y
dening
some
mathematical
notation
that
w
e
will
use
to
dene
the
deriv
ativ
e.
As
usual,
w
e
obtain
from
the
R
e
als
mo
dule
the
denitions
of
the
set
R
e
al
of
real
n
um
b
ers
and
of
the
ordinary
arithmetic
op
erators.
Let
PosR
e
al
b
e
the
set
of
all
p
ositiv
e
reals:
PosR
e
al

=
fr
2
R
e
al
:
r
>
0g
and
let
Op
enInterval
(a
;
b
)
b
e
the
op
en
in
terv
al
from
a
to
b
(the
set
of
n
um
b
ers
greater
than
a
and
less
than
b
):
Op
enInterval
(a
;
b
)

=
fs
2
R
e
al
:
(a
<
s
)
^
(s
<
b
)g
(Mathematicians
usually
write
this
set
as
(a
;
b
).)
Let's
also
dene
Nbhd
(r
;
e
)
to
b
e
the
op
en
in
terv
al
of
width
2e
cen
tered
at
r
:
Nbhd
(r
;
e
)

=
Op
enInterval
(r
 e
;
r
+
e
)

11.1.
SPECIFYING
D
A
T
A
STR
UCTURES
175
module
Gr
aphs
A
mo
dule
that
denes
op
erators
on
graphs.
A
directed
graph
is
represen
ted
as
a
record
whose
no
de
eld
is
the
set
of
no
des
and
whose
e
dge
eld
is
the
set
of
edges,
where
an
edge
is
an
ordered
pair
of
no
des.
local
inst
ance
Natur
als
local
inst
ance
Se
quenc
es
IsDir
e
cte
dGr
aph
(G
)

=
T
rue
i
G
is
a
directed
graph.
^
G
=
[no
de
7!
G
:no
de
;
e
dge
7!
G
:e
dge
]
^
G
:e
dge

(G
:no
de

G
:no
de
)
Dir
e
cte
dSub
gr
aph
(G
)

=
The
set
of
all
(directed)
subgraphs
of
a
directed
graph.
fH
2
[no
de
:
subset
G
:no
de
;
e
dge
:
subset
(G
:no
de

G
:no
de
)]
:
IsDir
e
cte
dGr
aph
(H
)
^
H
:e
dge

G
:e
dge
g
IsUndir
e
cte
dGr
aph
(G
)

=
An
undirected
graph
is
a
directed
graph
in
whic
h
ev
ery
edge
has
an
opp
ositely
directed
one.
^
IsDir
e
cte
dGr
aph
(G
)
^
8
e
2
G
:e
dge
:
h
e
[2];
e
[1]
i
2
G
:e
dge
Undir
e
cte
dSub
gr
aph
(G
)

=
The
set
of
(undirected)
subgraphs
of
an
undirected
graph.
fH
2
Dir
e
cte
dSub
gr
aph
(G
)
:
IsUndir
e
cte
dGr
aph
(H
)g
Path
(G
)

=
The
set
of
paths
in
G
,
where
a
path
is
represen
ted
as
a
sequence
of
no
des.
fp
2
Se
q
(G
:no
de
)
:
^
p
6=
h
i
^
8
i
2
1
:
:
(L
en
(p
)
 1)
:
h
p
[i
];
p
[i
+
1]
i
2
G
:e
dge
g
A
r
eConne
cte
dIn
(m
;
n
;
G
)

=
T
rue
i
there
is
a
path
from
m
to
n
in
graph
G
.
9
p
2
Path
(G
)
:
(p
[1]
=
m
)
^
(p
[L
en
(p
)]
=
n
)
IsStr
onglyConne
cte
d
(G
)

=
T
rue
i
graph
G
is
strongly
connected.
8
m
;
n
2
G
:no
de
:
A
r
eConne
cte
dIn
(m
;
n
;
G
)
IsT
r
e
eWithR
o
ot
(G
;
r
)

=
T
rue
if
G
is
a
tree
with
ro
ot
r
,
where
edges
p
oin
t
from
c
hild
to
paren
t.
^
IsDir
e
cte
dGr
aph
(G
)
^
8
e
2
G
:e
dge
:
^
e
[1]
6=
r
^
8
f
2
G
:e
dge
:
(e
[1]
=
f
[1])
)
(e
=
f
)
^
8
n
2
G
:no
de
:
A
r
eConne
cte
dIn
(n
;
r
;
G
)
Figure
11.1:
A
mo
dule
for
sp
ecifying
op
erators
on
graphs.

176
CHAPTER
11.
AD
V
ANCED
EXAMPLES
T
o
explain
the
denitions,
w
e
need
some
notation
for
the
deriv
ativ
e
of
a
function.
It's
rather
dicult
to
mak
e
mathematical
sense
of
the
usual
notation
df
=dt
for
the
deriv
ativ
e
of
f
.
(What
exactly
is
t
?)
So,
let's
use
a
mathematically
simpler
notation
and
write
the
n
th
deriv
ativ
e
of
the
function
f
as
f
(n
)
.
(W
e
don't
ha
v
e
to
use
TLA
+
notation
b
ecause
dieren
tiation
will
not
app
ear
explicitly
in
our
denitions.)
Recall
that
f
(0)
,
the
0
th
deriv
ativ
e
of
f
,
equals
f
.
W
e
can
no
w
start
to
dene
Inte
gr
ate
.
If
a
and
b
are
n
um
b
ers,
InitV
als
is
an
n
-tuple
of
n
um
b
ers,
and
D
is
a
function
from
(n
+
2)-tuples
of
n
um
b
ers
to
n
um
b
ers,
then
Inte
gr
ate
(D
;
a
;
b
;
InitV
als
)
=
h
f
(0)
[b
];
:
:
:
;
f
(n
 1)
[b
]
i
where
f
is
the
function
satisfying
the
follo
wing
t
w
o
conditions:

D
[r
;
f
(0)
[r
];
f
(1)
[r
];
:
:
:
;
f
(n
)
[r
]]
=
0,
for
all
r
in
some
op
en
in
terv
al
con-
taining
a
and
b
.

h
f
(0)
[a
];
:
:
:
;
f
(n
 1)
[a
]
i
=
InitV
als
W
e
w
an
t
to
dene
Inte
gr
ate
(D
;
a
;
b
;
InitV
als
)
in
terms
of
this
function
f
,
whic
h
w
e
can
sp
ecify
using
the
choose
op
erator.
It's
easiest
to
c
ho
ose
not
just
f
,
but
its
rst
n
deriv
ativ
es
as
w
ell.
So,
w
e
c
ho
ose
a
function
g
suc
h
that
g
[i
]
=
f
(i
)
for
i
2
0
:
:
n
.
The
function
g
maps
n
um
b
ers
in
0
:
:
n
in
to
functions.
More
precisely
,
g
is
an
elemen
t
of
[0
:
:
n
!
[Op
enInterval
(a
 e
;
b
+
e
)
!
R
e
al
]
]
for
some
p
ositiv
e
e
.
It
is
the
function
in
this
set
that
satises
the
follo
wing
conditions:
1.
g
[i
]
is
the
i
th
deriv
ativ
e
of
g
[0],
for
all
i
2
0
:
:
n
.
2.
D
[r
;
g
[0][r
];
:
:
:
;
g
[n
][r
]
]
=
0,
for
all
r
in
Op
enInterval
(a
 e
;
b
+
e
).
3.
h
g
[0][a
];
:
:
:
;
g
[n
 1][a
]
i
=
InitV
als
W
e
no
w
ha
v
e
to
express
these
conditions
formally
.
T
o
express
the
rst
condition,
w
e
will
dene
IsDeriv
so
that
IsDeriv
(i
;
df
;
f
)
is
true
i
df
is
the
i
th
deriv
ativ
e
of
f
.
More
precisely
,
this
will
b
e
the
case
if
f
is
a
real-v
alued
function
on
an
op
en
in
terv
al;
w
e
don't
care
what
IsDeriv
(i
;
df
;
f
)
equals
for
other
v
alues
of
f
.
Condition
1
is
then
8
i
2
1
:
:
n
:
IsDeriv
(i
;
g
[i
];
g
[0])
T
o
express
the
second
condition
formally
,
without
the
\.
.
.
",
w
e
reason
as
follo
ws:
D
[r
;
g
[0][r
];
:
:
:
;
g
[n
][r
]
]
=
D
[
h
r
;
g
[0][r
];
:
:
:
;
g
[n
][r
]
i
]
See
page
50.
=
D
[
h
r
i

h
g
[0][r
];
:
:
:
;
g
[n
][r
]
i
]
T
uples
are
sequences
=
D
[
h
r
i

[i
2
1
:
:
(n
+
1)
7!
g
[i
 1][r
]]
]
An
(n
+
1)-tuple
is
a
function
with
domain
1
:
:
n
+
1.

11.1.
SPECIFYING
D
A
T
A
STR
UCTURES
177
The
third
condition
is
simply
8
i
2
1
:
:
n
:
g
[i
 1][a
]
=
InitV
als
[i
]
W
e
can
therefore
write
the
form
ula
sp
ecifying
g
as
9
e
2
PosR
e
al
:
^
g
2
[0
:
:
n
!
[Op
enInterval
(a
 e
;
b
+
e
)
!
R
e
al
]
]
^
8
i
2
1
:
:
n
:
^
IsDeriv
(i
;
g
[i
];
g
[0])
^
g
[i
 1][a
]
=
InitV
als
[i
]
^
8
r
2
Op
enInterval
(a
 e
;
b
+
e
)
:
D
[
h
r
i

[i
2
1
:
:
(n
+
1)
7!
g
[i
 1][r
]]
]
=
0
where
n
is
the
length
of
InitV
als
.
The
v
alue
of
Inte
gr
ate
(D
;
a
;
b
;
InitV
als
)
is
the
tuple
h
g
[0][b
];
:
:
:
;
g
[n
 1][b
]
i,
whic
h
can
b
e
written
formally
as
[i
2
1
:
:
n
7!
g
[i
 1][b
]]
T
o
complete
the
denition
of
Inte
gr
ate
,
w
e
no
w
dene
the
op
erator
IsDeriv
.
It's
easy
to
dene
the
i
th
deriv
ativ
e
inductiv
ely
in
terms
of
the
rst
deriv
ativ
e.
So,
w
e
dene
IsFirstDeriv
(df
;
f
)
to
b
e
true
i
df
is
the
rst
deriv
ativ
e
of
f
,
assuming
that
f
is
a
real-v
alued
function
whose
domain
is
an
op
en
in
terv
al.
Our
denition
actually
w
orks
if
the
domain
of
f
is
an
y
op
en
set.
2
Elemen
tary
calculus
tells
us
that
df
[r
]
is
the
deriv
ativ
e
of
f
at
r
i
df
[r
]
=
lim
s!r
f
[s]
 f
[r
]
s
 r
The
classical
\
-"
denition
of
the
limit
states
that
this
is
true
i,
for
ev
ery

>
0,
there
is
a

>
0
suc
h
that
0
<
js
 r
j
<

implies




d
f
[r
]
 f
[s]
 f
[r
]
s
 r




<

Stated
formally
,
this
condition
is
8

2
PosR
e
al
:
9

2
PosR
e
al
:
8
s
2
Nbhd
(r
;

)
n
fr
g
:
f
[s]
 f
[r
]
s
 r
2
N
bhd(d
f
[r
];
)
W
e
dene
IsFirstDeriv
(df
;
f
)
to
b
e
true
i
the
domains
of
df
and
f
are
equal,
and
this
condition
holds
for
all
r
in
their
domain.
The
denitions
of
Inte
gr
ate
and
all
the
other
op
erators
in
tro
duced
ab
o
v
e
app
ear
in
the
Dier
entialEquations
mo
dule
of
Figure
11.2
on
the
next
page.
The
local
construct
describ
ed
in
Section
11.1.1
ab
o
v
e
is
used
to
mak
e
all
these
denitions
lo
cal
to
the
mo
dule,
except
for
the
denition
of
Inte
gr
ate
.
2
A
set
S
is
op
en
i
for
ev
ery
r
2
S
there
exists
an

>
0
suc
h
that
the
in
terv
al
from
r
 
to
r
+

is
con
tained
in
S
.

178
CHAPTER
11.
AD
V
ANCED
EXAMPLES
module
Dier
entialEquations
This
mo
dule
denes
the
op
erator
Inte
gr
ate
for
sp
ecifying
the
solution
to
a
dieren
tial
equation.
If
a
and
b
are
reals
with
a

b
;
InitV
als
is
an
n
-tuple
of
reals;
and
D
is
a
function
from
(n
+
1)-tuples
of
reals
to
reals;
then
this
is
the
n
-tuple
of
v
alues
h
f
[b
];
df
dt
[b
];
:
:
:
;
d
n
 1
f
dt
n
 1
[b
]
i
where
f
is
the
solution
to
the
dieren
tial
equation
D
[t
;
f
;
df
dt
;
:
:
:
;
d
n
f
dt
n
]
=
0
suc
h
that
h
f
[a
];
df
dt
[a
];
:
:
:
;
d
n
 1
f
dt
n
 1
[a
]
i
=
InitV
als
local
inst
ance
R
e
als
local
inst
ance
Se
quenc
es
local
PosR
e
al

=
fr
2
R
e
al
:
r
>
0g
local
Op
enInterval
(a
;
b
)

=
fs
2
R
e
al
:
(a
<
s
)
^
(s
<
b
)g
local
Nbhd
(r
;
e
)

=
Op
enInterval
(r
 e
;
r
+
e
)
The
inst
ance
statemen
t
and
these
denitions
are
lo
cal,
so
a
mo
dule
that
extends
this
one
obtains
only
the
denition
of
Inte
gr
ate
.
local
IsFirstDeriv
(df
;
f
)

=
Assuming
domain
f
is
an
op
en
subset
of
R
e
al
,
this
is
true
i
f
is
dieren
tiable
and
df
is
its
rst
deriv
ativ
e.
Recall
that
the
deriv
ativ
e
of
f
at
r
is
the
n
um
b
er
df
[r
]
satisfying
the
follo
wing
condition:
for
ev
ery

there
exists
a

suc
h
that
0
<
js
 r
j
<

implies
jdf
[r
]
 (f
[s
]
 f
[r
])=(s
 r
)j
<
.
^
df
2
[domain
f
!
R
e
al
]
^
8
r
2
domain
f
:
8
e
2
PosR
e
al
:
9
d
2
PosR
e
al
:
8
s
2
Nbhd
(r
;
d
)
n
fr
g
:
(f
[s
]
 f
[r
])=(s
 r
)
2
Nbhd
(df
[r
];
e
)
local
IsDeriv
(n
;
df
;
f
)

=
T
rue
i
f
is
n
times
dieren
tiable
and
df
is
its
n
th
deriv
ativ
e.
let
IsD
[k
2
0
:
:
n
;
g
2
[domain
f
!
R
e
al
]
]

=
IsD
[k
;
g
]
=
IsDeriv
(k
;
g
;
f
)
if
k
=
0
then
g
=
f
else
9
gg
2
[domain
f
!
R
e
al
]
:
^
IsFirstDeriv
(g
;
gg
)
^
IsD
[k
 1;
gg
]
in
IsD
[n
;
df
]
Inte
gr
ate
(D
;
a
;
b
;
InitV
als
)

=
let
n

=
L
en
(InitV
als
)
gg

=
choose
g
:
9
e
2
PosR
e
al
:
^
g
2
[0
:
:
n
!
[Op
enInterval
(a
 e
;
b
+
e
)
!
R
e
al
]
]
^
8
i
2
1
:
:
n
:
^
IsDeriv
(i
;
g
[i
];
g
[0])
^
g
[i
 1][a
]
=
InitV
als
[i
]
^
8
r
2
Op
enInterval
(a
 e
;
b
+
e
)
:
D
[
h
r
i

[i
2
1
:
:
(n
+
1)
7!
g
[i
 1][r
]]
]
=
0
in
[i
2
1
:
:
n
7!
gg
[i
 1][b
]]
Figure
11.2:
A
mo
dule
for
sp
ecifying
the
solution
to
a
dieren
tial
equation.

11.1.
SPECIFYING
D
A
T
A
STR
UCTURES
179
11.1.4
BNF
Grammars
BNF,
whic
h
stands
for
Bac
kus-Naur
F
orm,
is
a
standard
w
a
y
of
describing
the
syn
tax
of
computer
languages.
This
section
dev
elops
the
BNF
Gr
ammars
mo
d-
ule,
whic
h
denes
op
erators
for
writing
BNF
grammars.
A
BNF
grammar
isn't
the
kind
of
data
structure
that
arises
in
system
sp
ecication,
and
TLA
+
is
not
particularly
w
ell
suited
to
sp
ecifying
one.
Its
syn
tax
do
esn't
allo
w
us
to
write
BNF
grammars
exactly
the
w
a
y
w
e'd
lik
e,
but
w
e
can
come
reasonably
close.
Moreo
v
er,
I
think
it's
fun
to
use
TLA
+
to
sp
ecify
its
o
wn
syn
tax.
So,
mo
dule
BNF
Gr
ammars
is
used
in
Chapter
15
to
sp
ecify
part
of
the
syn
tax
of
TLA
+
,
as
w
ell
as
in
Chapter
14
to
sp
ecify
the
syn
tax
of
the
TLC
mo
del
c
hec
k
er's
cong-
uration
le.
Let's
start
b
y
reviewing
BNF
grammars.
Consider
the
little
language
SE
of
simple
expressions
describ
ed
b
y
the
BNF
grammar
expr
::=
iden
t
j
expr
op
expr
j
(
expr
)
j
let
def
in
expr
def
::=
iden
t
=
=
expr
where
op
is
some
class
of
inx
op
erators
lik
e
+,
and
iden
t
is
some
class
of
iden
tiers
suc
h
as
ab
c
and
x
.
The
language
SE
con
tains
expressions
lik
e
ab
c
+
(let
x
==
y
+
ab
c
in
x

x
)
Let's
represen
t
this
expression
as
the
sequence
h
\ab
c"
;
\+"
;
\("
;
\LET"
;
\x"
;
\=="
;
\y";
\+"
;
\ab
c"
;
\IN"
;
\x"
;
\
";
\x"
;
\)"
i
of
strings.
The
strings
suc
h
as
\ab
c"
and
\+"
app
earing
in
this
sequence
are
usually
called
lexemes.
In
general,
a
sequence
of
lexemes
is
called
a
sentenc
e
;
and
a
set
of
sen
tences
is
called
a
language.
So,
w
e
w
an
t
to
dene
the
language
SE
to
consist
of
the
set
of
all
suc
h
sen
tences
describ
ed
b
y
the
BNF
grammar.
3
T
o
represen
t
a
BNF
grammar
in
TLA
+
,
w
e
m
ust
assign
a
mathematical
meaning
to
non
terminal
sym
b
ols
lik
e
def
,
to
terminal
sym
b
ols
lik
e
op,
and
to
the
grammar's
t
w
o
pro
ductions.
The
metho
d
that
I
nd
simplest
is
to
let
the
meaning
of
a
non
terminal
sym
b
ol
b
e
the
language
that
it
generates.
Th
us,
the
meaning
of
expr
is
the
language
SE
itself.
I
dene
a
gr
ammar
to
b
e
a
function
G
suc
h
that,
for
an
y
string
\str"
,
the
v
alue
of
G
[\str"]
is
the
language
generated
b
y
the
non
terminal
str
.
Th
us,
if
G
is
the
BNF
grammar
ab
o
v
e,
then
G
[\exp
r"]
is
the
complete
language
SE,
and
G
[\def"]
is
the
language
dened
b
y
the
pro
duction
for
def
,
whic
h
con
tains
sen
tences
lik
e
h
\y";
\=="
;
\qq"
;
\
";
\wxyz"
i
3
BNF
grammars
are
also
used
to
sp
ecify
ho
w
an
expression
is
parsed|for
example,
that
a
+
b

c
is
parsed
as
a
+
(b

c
)
rather
than
(a
+
b
)

c
.
By
considering
the
grammar
to
sp
ecify
only
a
set
of
sen
tences,
w
e
are
delib
erately
not
capturing
that
use
in
our
TLA
+
represen
tation
of
BNF
grammars.

180
CHAPTER
11.
AD
V
ANCED
EXAMPLES
Instead
of
letting
the
domain
of
G
consist
of
just
the
t
w
o
strings
\exp
r"
and
\def"
,
it
turns
out
to
b
e
more
con
v
enien
t
to
let
its
domain
b
e
the
en
tire
set
string
of
strings,
and
to
let
G
[s
]
b
e
the
empt
y
language
(the
empt
y
set)
for
all
strings
s
other
than
\exp
r"
and
\def"
.
So,
a
grammar
is
a
function
from
the
set
of
all
strings
to
the
set
of
sequences
of
strings.
W
e
can
therefore
dene
the
set
Gr
ammar
of
all
grammars
b
y
Gr
ammar

=
[string
!
subset
Se
q
(string
)]
In
describing
the
mathematical
meaning
of
records,
Section
5.2
explained
that
r
:ack
is
an
abbreviation
for
r
[\ack"
].
This
is
the
case
ev
en
if
r
isn't
a
record.
So,
w
e
can
write
G
:op
instead
of
G
[\op"
].
(A
grammar
isn't
a
record
b
ecause
its
domain
is
the
set
of
all
strings
rather
than
a
nite
set
of
strings.)
A
terminal
lik
e
iden
t
can
app
ear
an
ywhere
to
the
righ
t
of
a
\::="
that
a
non
terminal
lik
e
expr
can,
so
a
terminal
should
also
b
e
a
set
of
sen
tences.
Let's
represen
t
a
terminal
as
a
set
of
sen
tences,
eac
h
of
whic
h
is
a
sequence
consisting
of
a
single
lexeme.
Let
a
token
b
e
a
sen
tence
consisting
of
a
single
lexeme,
so
a
terminal
is
a
set
of
tok
ens.
F
or
example,
the
terminal
iden
t
is
a
set
con
taining
tok
ens
suc
h
as
h
\ab
c"
i,
h
\x"
i,
and
h
\qq"
i.
An
y
terminal
app
earing
in
the
BNF
grammar
m
ust
b
e
represen
ted
b
y
a
set
of
tok
ens,
so
the
==
in
the
grammar
for
SE
is
the
set
fh
\=="
ig.
Let's
dene
the
op
erator
tok
b
y
tok
is
short
for
token.
tok
(s
)

=
fh
s
ig
so
w
e
can
write
this
set
of
tok
ens
as
tok
(\=="
).
A
pro
duction
expresses
a
relation
b
et
w
een
the
v
alues
of
G
:str
for
some
gram-
mar
G
and
some
strings
\str"
.
F
or
example,
the
pro
duction
def
::=
iden
t
==
expr
asserts
that
a
sen
tence
s
is
in
G
:def
i
it
has
the
form
i

h
\=="
i

e
for
some
tok
en
i
in
iden
t
and
some
sen
tence
e
in
G
:expr
.
In
mathematics,
a
form
ula
ab
out
G
m
ust
men
tion
G
(p
erhaps
indirectly
b
y
using
a
sym
b
ol
dened
in
terms
of
G
).
So,
w
e
can
try
writing
this
pro
duction
in
TLA
+
as
G
:def
::=
ident
tok
(\=="
)
G
:expr
In
the
expression
to
the
righ
t
of
the
::=,
adjacency
is
expressing
some
op
eration.
Just
as
w
e
ha
v
e
to
mak
e
m
ultiplication
explicit
b
y
writing
2

x
instead
of
2x
,
w
e
m
ust
express
this
op
eration
b
y
an
explicit
op
erator.
Let's
use
&,
so
w
e
can
write
the
pro
duction
as
G
:def
::=
ident
&
tok
(\=="
)
&
G
:expr
(11.1)
This
expresses
the
desired
relation
b
et
w
een
the
sets
G
:def
and
G
:expr
of
sen-
tences
if
::=
is
dened
to
b
e
equalit
y
and
&
is
dened
so
that
L
&
M
is
the

11.1.
SPECIFYING
D
A
T
A
STR
UCTURES
181
set
of
all
sen
tences
obtained
b
y
concatenating
a
sen
tence
in
L
with
a
sen
tence
in
M
:
L
&
M

=
fs

t
:
s
2
L;
t
2
M
g
The
pro
duction
expr
::=
iden
t
j
expr
op
expr
j
(
expr
)
j
let
def
in
expr
can
similarly
b
e
expressed
as
The
precedence
rules
of
TLA
+
im-
ply
that
a
j
b
&
c
is
in
terpreted
as
a
j
(b
&
c
).
G
:expr
::=
ident
j
G
:expr
&
op
&
G
:expr
j
tok
(\(")
&
G
:exp
&
tok
(\)")
j
tok
(\LET"
)
&
G
:def
&
tok
(\IN"
)
&
G
:expr
(11.2)
This
expresses
the
desired
relation
if
j
(whic
h
means
or
in
the
BNF
grammar)
is
dened
to
b
e
set
union
([).
W
e
can
also
dene
the
follo
wing
op
erators
that
are
sometimes
used
in
BNF
grammars:

Nil
is
dened
so
that
Nil
&
S
equals
S
for
an
y
set
S
of
sen
tences:
Nil

=
fh
ig

L
+
equals
L
j
L
&
L
j
L
&
L
&
L
j
:
:
:
:
L
+
is
t
yp
ed
L^+
and
L

is
t
yp
ed
L^*.
L
+

=
let
LL[n
2
Nat
]

=
LL[n
]
=
L
j
:
:
:
j
n
+1
copies
z
}|
{
L
&
:
:
:
L
.
if
n
=
0
then
L
else
LL[n
 1]
j
LL[n
 1]
&
L
in
union
fLL[n
]
:
n
2
Nat
g

L

equals
Nil
j
L
j
L
&
L
j
L
&
L
&
L
j
:
:
:
:
L


=
Nil
j
L
+
The
BNF
grammar
for
SE
consists
of
t
w
o
pro
ductions,
expressed
b
y
the
TLA
+
form
ulas
(11.1)
and
(11.2).
The
en
tire
grammar
is
the
single
form
ula
that
is
the
conjunction
of
these
t
w
o
form
ulas.
W
e
m
ust
turn
this
form
ula
in
to
a
mathemat-
ical
denition
of
a
grammar
GSE
,
whic
h
is
a
function
from
strings
to
languages.
The
form
ula
is
an
assertion
ab
out
a
grammar
G
.
W
e
dene
GSE
to
b
e
the
small-
est
grammar
G
satisfying
the
conjunction
of
(11.1)
and
(11.2),
where
grammar
G
1
smaller
than
G
2
means
that
G
1
[s
]

G
2
[s
]
for
ev
ery
string
s
.
T
o
express
this
in
TLA
+
,
w
e
dene
an
op
erator
L
e
astGr
ammar
so
that
L
e
astGr
ammar
(P
)
is
the
smallest
grammar
G
satisfying
P
(G
):
L
e
astGr
ammar
(P
(
))

=
choose
G
2
Gr
ammar
:
^
P
(G
)
^
8
H
2
Gr
ammar
:
P
(H
)
)
(8
s
2
string
:
G
[s
]

H
[s
])

182
CHAPTER
11.
AD
V
ANCED
EXAMPLES
Letting
P
(G
)
b
e
the
conjunction
of
(11.1)
and
(11.2),
w
e
can
dene
the
grammar
GSE
to
b
e
L
e
astGr
ammar
(P
).
W
e
can
then
dene
the
language
SE
to
equal
GSE
:expr
.
The
smallest
grammar
G
satisfying
a
form
ula
P
m
ust
ha
v
e
G
[s
]
equal
to
the
empt
y
language
for
an
y
string
s
that
do
esn't
app
ear
in
P
.
Th
us,
GSE
[s
]
equals
the
empt
y
language
fg
for
an
y
string
s
other
than
\exp
r"
and
\def"
.
T
o
complete
our
sp
ecication
of
GSE
,
w
e
m
ust
dene
the
sets
ident
and
op
of
tok
ens.
W
e
can
dene
the
set
op
of
op
erators
b
y
en
umerating
them|for
example:
op

=
tok
(\+"
)
j
tok
(\ "
)
j
tok
(\
*
"
)
j
tok
(\/"
)
T
o
express
this
a
little
more
compactly
,
let's
dene
T
ok
(S
)
to
b
e
the
set
of
all
tok
ens
formed
from
elemen
ts
in
the
set
S
of
lexemes:
T
ok
(S
)

=
fh
s
i
:
s
2
S
g
W
e
can
then
write
op

=
T
ok
(
f\+"
;
\ "
;
\
*
"
;
\/"
g
)
Let's
dene
ident
to
b
e
the
set
of
tok
ens
whose
lexemes
are
w
ords
made
en
tirely
of
lo
w
er-case
letters,
suc
h
as
\ab
c"
,
\qq"
,
and
\x"
.
T
o
learn
ho
w
to
do
that,
w
e
m
ust
rst
understand
what
strings
in
TLA
+
really
are.
In
TLA
+
,
a
string
is
a
sequence
of
c
haracters.
(W
e
don't
care,
and
the
seman
tics
of
TLA
+
See
Section
16.1.10
on
page
307
for
more
ab
out
strings.
Re-
mem
b
er
that
w
e
tak
e
se
quenc
e
and
tuple
to
b
e
syn-
on
ymous.
do
esn't
sp
ecify
,
what
a
c
haracter
is.)
W
e
can
therefore
apply
the
usual
sequence
op
erators
on
them.
F
or
example,
T
ail
(\ab
c")
equals
\b
c"
,
and
\ab
c"

\de"
equals
\ab
cde"
.
The
op
erators
lik
e
&
that
w
e
just
dened
for
expressing
BNF
w
ere
applied
to
sets
of
sen
tences,
where
a
sen
tence
is
a
sequence
of
lexemes.
These
op
erators
can
b
e
applied
just
as
w
ell
to
sets
of
sequences
of
an
y
kind|including
sets
of
strings.
F
or
example,
f\one"
;
\t
w
o"
g
&
f\s"
g
equals
f\ones"
;
\t
w
os"
g,
and
f\ab"
g
+
is
the
set
consisting
of
all
the
strings
\ab"
,
\abab"
,
\ababab"
,
etc.
So,
w
e
can
dene
ident
to
equal
T
ok
(L
etter
+
),
where
L
etter
is
the
set
of
all
lexemes
consisting
of
a
single
lo
w
er-case
letter:
L
etter

=
f\a"
;
\b"
;
:
:
:
;
\z"
g
W
riting
this
denition
out
in
full
(without
the
\.
.
.
")
is
tedious.
W
e
can
mak
e
this
a
little
easier
as
follo
ws.
W
e
rst
dene
OneOf
(s
)
to
b
e
the
set
of
all
one-c
haracter
strings
made
from
the
c
haracters
of
the
string
s
:
OneOf
(s
)

=
fh
s
[i
]
i
:
i
2
domain
s
g
W
e
can
then
dene
L
etter

=
OneOf
(\ab
cdefghijklmnop
qrstuvwxyz"
)

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
183
GSE

=
let
op

=
T
ok
(
f\+"
;
\ "
;
\
";
\/"
g
)
ident

=
T
ok
(
OneOf
(\ab
cdefghijklmnop
qrstuvwxyz"
)
+
)
P
(G
)

=
^
G
:expr
::=
ident
j
G
:expr
&
op
&
G
:expr
j
tok
(\(")
&
G
:expr
&
tok
(\)"
)
j
tok
(\LET"
)
&
G
:def
&
tok
(\IN"
)
&
G
:expr
^
G
:def
::=
ident
&
tok
(\=="
)
&
G
:expr
in
L
e
astGr
ammar
(P
)
Figure
11.3:
The
denition
of
the
grammar
GSE
for
the
language
SE.
The
complete
denition
of
the
grammar
GSE
app
ears
in
Figure
11.3
on
this
page.
All
the
op
erators
w
e'v
e
dened
here
for
sp
ecifying
grammars
are
group
ed
in
to
mo
dule
BNF
Gr
ammars
,
whic
h
app
ears
in
Figure
11.4
on
the
next
page.
Using
TLA
+
to
write
ordinary
BNF
grammars
is
a
bit
silly
.
Ho
w
ev
er,
or-
dinary
BNF
grammars
are
not
v
ery
con
v
enien
t
for
describing
the
syn
tax
of
a
complicated
language
lik
e
TLA
+
.
In
fact,
they
can't
describ
e
the
alignmen
t
rules
for
its
bulleted
lists
of
conjuncts
and
disjuncts.
Using
TLA
+
to
sp
ecify
suc
h
a
language
is
not
so
silly
.
In
fact,
a
TLA
+
sp
ecication
of
the
complete
syn
tax
of
TLA
+
w
as
written
as
part
of
the
dev
elopmen
t
of
the
Syn
tactic
Ana-
lyzer,
describ
ed
in
Chapter
12.
Although
v
aluable
when
writing
a
TLA
+
parser,
this
sp
ecication
isn't
v
ery
helpful
to
an
ordinary
user
of
TLA
+
,
so
it
do
es
not
app
ear
in
this
b
o
ok.
11.2
Other
Memory
Sp
ecications
Section
5.3
sp
ecies
a
m
ultipro
cessor
memory
.
The
sp
ecication
is
unrealistically
simple
for
three
reasons:
a
pro
cessor
can
ha
v
e
only
one
outstanding
request
at
a
time,
the
basic
correctness
condition
is
to
o
restrictiv
e,
and
only
simple
read
and
write
op
erations
are
pro
vided.
(Real
memories
pro
vide
man
y
other
op
erations,
suc
h
as
partial-w
ord
writes
and
cac
he
prefetc
hes.)
W
e
no
w
sp
ecify
a
memory
that
allo
ws
m
ultiple
outstanding
requests
and
has
a
realistic,
w
eak
er
correctness
condition.
T
o
k
eep
the
sp
ecication
short,
w
e
still
consider
only
the
simple
op
erations
of
reading
and
writing
one
w
ord
of
memory
.
11.2.1
The
In
terface
The
rst
thing
w
e
m
ust
do
to
sp
ecify
a
memory
is
determine
the
in
terface.
The
in
terface
w
e
c
ho
ose
dep
ends
on
the
purp
ose
of
the
sp
ecication.
There
are
man
y
dieren
t
reasons
wh
y
w
e
migh
t
b
e
sp
ecifying
a
m
ultipro
cessor
memory
.
W
e
could

184
CHAPTER
11.
AD
V
ANCED
EXAMPLES
module
BNF
Gr
ammars
A
sen
tence
is
a
sequence
of
strings.
(In
standard
terminology
,
the
term
\lexeme"
is
used
instead
of
\string".)
A
tok
en
is
a
sen
tence
of
length
one|that
is,
a
one-elemen
t
sequence
whose
single
elemen
t
is
a
string.
A
language
is
a
set
of
sen
tences.
local
inst
ance
Natur
als
local
inst
ance
Se
quenc
es
OPERA
TORS
F
OR
DEFINING
SETS
OF
TOKENS
OneOf
(s
)

=
fh
s
[i
]
i
:
i
2
domain
s
g
If
s
is
a
string,
then
OneOf
(s
)
is
the
set
of
strings
formed
from
the
individual
c
haracters
of
s
.
F
or
example,
OneOf
(\ab
c"
)
=
f\a";
\b"
;
\c"
g.
tok
(s
)

=
fh
s
ig
T
ok
(S
)

=
fh
s
i
:
s
2
S
g
If
s
is
a
string,
then
tok
(s
)
is
the
set
con
taining
only
the
tok
en
made
from
s
.
If
S
is
a
set
of
strings,
then
T
ok
(S
)
is
the
set
of
tok
ens
made
from
elemen
ts
of
S
.
OPERA
TORS
F
OR
DEFINING
LANGUA
GES
Nil

=
fh
ig
The
language
con
taining
only
the
\empt
y"
sen
tence.
L
&
M

=
fs

t
:
s
2
L;
t
2
M
g
All
concatenations
of
sen
tences
in
L
and
M
.
L
j
M

=
L
[
M
L
+

=
L
j
L
&
L
j
L
&
L
&
L
j
:
:
:
let
LL[n
2
Nat
]

=
if
n
=
0
then
L
else
LL[n
 1]
j
LL[n
 1]
&
L
in
union
fLL[n
]
:
n
2
Nat
g
L


=
Nil
j
L
+
L
::=
M

=
L
=
M
Gr
ammar

=
[string
!
subset
Se
q
(string
)]
L
e
astGr
ammar
(P
(
))

=
The
smallest
grammar
G
suc
h
that
P
(G
)
is
true.
choose
G
2
Gr
ammar
:
^
P
(G
)
^
8
H
2
Gr
ammar
:
P
(H
)
)
8
s
2
string
:
G
[s
]

H
[s
]
Figure
11.4:
The
mo
dule
BNF
Gr
ammars.

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
185
b
e
sp
ecifying
a
computer
arc
hitecture,
or
the
seman
tics
of
a
programming
lan-
guage.
Let's
supp
ose
w
e
are
sp
ecifying
the
memory
of
an
actual
m
ultipro
cessor
computer.
A
mo
dern
pro
cessor
p
erforms
m
ultiple
instructions
concurren
tly
.
It
can
b
egin
new
memory
op
erations
b
efore
previous
ones
ha
v
e
b
een
completed.
The
memory
resp
onds
to
a
request
as
so
on
as
it
can;
it
need
not
resp
ond
to
dieren
t
requests
in
the
order
that
they
w
ere
issued.
A
pro
cessor
issues
a
request
to
a
memory
system
b
y
setting
some
register.
W
e
assume
that
eac
h
pro
cessor
has
a
set
of
registers
through
whic
h
it
comm
unicates
with
the
memory
.
Eac
h
register
has
three
elds:
an
adr
eld
that
holds
an
address,
a
val
eld
that
holds
a
w
ord
of
memory
,
and
an
op
eld
that
indicates
what
kind
of
op
eration,
if
an
y
,
is
in
progress.
The
pro
cessor
can
issue
a
command
using
a
register
whose
op
eld
equals
\F
ree"
.
It
sets
the
op
eld
to
\Rd"
or
\W
r"
to
indicate
the
op
eration;
it
sets
the
adr
eld
to
the
address
of
the
memory
w
ord;
and,
for
a
write,
it
sets
the
val
eld
to
the
v
alue
b
eing
written.
(On
a
read,
the
pro
cessor
can
set
the
val
eld
to
an
y
v
alue.)
The
memory
resp
onds
b
y
setting
the
op
eld
bac
k
to
\F
ree"
and,
for
a
read,
setting
the
val
eld
to
the
v
alue
read.
(The
memory
do
es
not
c
hange
the
val
eld
when
resp
onding
to
a
write.)
Mo
dule
R
e
gisterInterfac
e
in
Figure
11.5
on
the
next
page
con
tains
some
declarations
and
denitions
for
sp
ecifying
the
in
terface.
It
declares
the
constan
ts
A
dr
,
V
al
,
and
Pr
o
c
,
whic
h
are
the
same
as
in
the
memory
in
terface
of
Section
5.1,
and
the
constan
t
R
e
g
,
whic
h
is
the
set
of
registers.
(More
precisely
,
R
e
g
is
a
set
of
register
iden
tiers.)
A
pro
cessor
has
a
separate
register
corresp
onding
to
eac
h
elemen
t
of
R
e
g
.
The
v
ariable
r
e
gFile
represen
ts
the
pro
cessors'
registers,
r
e
gFile
[p
][r
]
b
eing
register
r
of
pro
cessor
p
.
The
mo
dule
also
denes
the
sets
of
requests
and
register
v
alues,
as
w
ell
as
a
t
yp
e
in
v
arian
t
for
r
e
gFile
.
11.2.2
The
Correctness
Condition
Section
5.3
sp
ecies
what
is
called
a
linearizable
memory
.
In
a
linearizable
mem-
ory
,
a
pro
cessor
nev
er
has
more
than
one
outstanding
request.
The
correctness
condition
for
the
memory
can
b
e
stated
as
The
result
of
an
y
execution
is
the
same
as
if
the
op
erations
of
all
the
pro
cessors
w
ere
executed
in
some
sequen
tial
order,
and
eac
h
op
era-
tion
is
executed
b
et
w
een
the
request
and
the
resp
onse.
The
second
clause,
whic
h
requires
the
system
to
act
as
if
eac
h
op
eration
w
ere
executed
b
et
w
een
its
request
and
its
resp
onse,
is
b
oth
to
o
w
eak
and
to
o
strong
for
our
sp
ecication.
It's
to
o
w
eak
b
ecause
it
sa
ys
nothing
ab
out
the
execution
order
of
t
w
o
op
erations
from
the
same
pro
cessor
unless
one
is
issued
after
the
other's
resp
onse.
F
or
example,
supp
ose
a
pro
cessor
p
issues
a
write
and
then
a
read
to
the
same
address.
W
e
w
an
t
the
read
to
obtain
either
the
v
alue
p
just
wrote,
or
a
v
alue
written
b
y
another
pro
cessor|ev
en
if
p
issues
the
read
b
efore

186
CHAPTER
11.
AD
V
ANCED
EXAMPLES
module
R
e
gisterInterfac
e
const
ant
A
dr
;
The
set
of
memory
addresses.
V
al
;
The
set
of
memory-w
ord
v
alues.
Pr
o
c
;
The
set
of
pro
cessors.
R
e
g
The
set
of
registers
used
b
y
a
pro
cessor.
v
ariable
r
e
gFile
r
e
gFile
[p
][r
]
represen
ts
the
con
ten
ts
of
register
r
of
pro
cessor
p
.
R
dR
e
quest

=
[adr
:
A
dr
;
val
:
V
al
;
op
:
f\Rd"
g]
WrR
e
quest

=
[adr
:
A
dr
;
val
:
V
al
;
op
:
f\W
r"
g]
F
r
e
eR
e
gV
alue

=
[adr
:
A
dr
;
val
:
V
al
;
op
:
f\F
ree"
g]
R
e
quest

=
R
dR
e
quest
[
WrR
e
quest
The
set
of
all
p
ossible
requests.
R
e
gV
alue

=
R
e
quest
[
F
r
e
eR
e
gV
alue
The
set
of
all
p
ossible
register
v
alues.
R
e
gFileT
yp
eInvariant

=
The
t
yp
e
correctness
in
v
arian
t
for
r
e
gFile
.
r
e
gFile
2
[Pr
o
c
!
[R
e
g
!
R
e
gV
alue
]]
Figure
11.5:
A
mo
dule
for
sp
ecifying
a
register
in
terface
to
a
memory
.
receiving
the
resp
onse
for
the
write.
This
isn't
guaran
teed
b
y
the
condition.
The
second
clause
is
to
o
strong
b
ecause
it
places
unnecessary
ordering
constrain
ts
on
op
erations
issued
b
y
dieren
t
pro
cessors.
If
op
erations
A
and
B
are
issued
b
y
t
w
o
dieren
t
pro
cessors,
then
w
e
don't
need
to
require
that
A
precedes
B
in
the
execution
order
just
b
ecause
B
w
as
requested
after
A's
resp
onse.
W
e
mo
dify
the
second
clause
to
require
that
the
system
act
as
if
op
erations
of
eac
h
individual
pro
cessor
w
ere
executed
in
the
order
that
they
w
ere
issued,
obtaining
the
condition
The
result
of
an
y
execution
is
the
same
as
if
the
op
erations
of
all
the
pro
cessors
w
ere
executed
in
some
sequen
tial
order,
and
the
op-
erations
of
eac
h
individual
pro
cessor
app
ear
in
this
sequence
in
the
order
in
whic
h
the
requests
w
ere
issued.
In
other
w
ords,
w
e
require
that
the
v
alues
returned
b
y
the
reads
can
b
e
explained
b
y
some
total
ordering
of
the
op
eration
executions
that
is
consisten
t
with
the
order
in
whic
h
eac
h
pro
cessor
issued
its
requests.
There
are
a
n
um
b
er
of
dieren
t
w
a
ys
of
formalizing
this
condition;
they
dier
in
ho
w
bizarre
the
explanation
ma
y
b
e.
The
dierences
can
b
e
describ
ed
in
terms
of
whether
or
not
certain
scenarios
are
p
ermitted.
In
the
scenario
descriptions,
Wr
p
(a
;
v
)
represen
ts
a
write
op
eration
of
v
alue
v
to
address
a
b
y
pro
cessor
p
,
and
R
d
p
(a
;
v
)
represen
ts
a
read
of
a
b
y
p
that
returns
the
v
alue
v
.
The
rst
decision
w
e
m
ust
mak
e
is
whether
all
op
erations
in
an
innite
b
eha
vior
m
ust
b
e
ordered,
or
if
the
ordering
m
ust
exist
only
at
eac
h
nite
p
oin
t

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
187
during
the
b
eha
vior.
Consider
a
scenario
in
whic
h
eac
h
of
t
w
o
pro
cessors
writes
its
o
wn
v
alue
to
the
same
address
and
then
k
eeps
reading
that
v
alue
forev
er:
In
these
scenar-
ios,
v
alues
and
addresses
with
dif-
feren
t
names
are
assumed
to
b
e
dif-
feren
t.
Pro
cessor
p
:
W
r
p
(a;
v
1);
R
d
p
(a;
v
1);
R
d
p
(a;
v
1);
R
d
p
(a;
v
1);
:
:
:
Pro
cessor
q
:
W
r
q
(a;
v
2);
R
d
q
(a;
v
2);
R
d
q
(a;
v
2);
R
d
q
(a;
v
2);
:
:
:
A
t
eac
h
p
oin
t
in
the
execution,
w
e
can
explain
the
v
alues
returned
b
y
the
reads
with
a
total
order
in
whic
h
all
the
op
erations
of
either
pro
cessor
precede
all
the
op
erations
of
the
other.
Ho
w
ev
er,
there
is
no
w
a
y
to
explain
the
en
tire
innite
scenario
with
a
single
total
order.
In
this
scenario,
neither
pro
cessor
ev
er
sees
the
v
alue
written
b
y
the
other.
Since
a
m
ultipro
cessor
memory
is
supp
osed
to
allo
w
pro
cessors
to
comm
unicate,
w
e
disallo
w
this
scenario.
The
second
decision
w
e
m
ust
mak
e
is
whether
the
memory
is
allo
w
ed
to
predict
the
future.
Consider
this
scenario:
Pro
cessor
p
:
W
r
p
(a;
v
1);
R
d
p
(a;
v
2)
Pro
cessor
q
:
W
r
q
(a;
v
2)
Here,
q
issues
its
write
of
v
2
after
p
has
obtained
the
result
of
its
read.
The
scenario
is
explained
b
y
the
ordering
Wr
p
(a
;
v
1),
Wr
q
(a
;
v
2),
R
d
p
(a
;
v
2).
Ho
w-
ev
er,
this
is
a
bizarre
explanation
b
ecause,
to
return
the
v
alue
v
2
for
p
's
read,
the
memory
had
to
predict
that
another
pro
cessor
w
ould
write
v
2
some
time
in
the
future.
Since
a
real
memory
can't
predict
what
requests
will
b
e
issued
in
the
future,
suc
h
a
b
eha
vior
cannot
b
e
pro
duced
b
y
a
correct
implemen
tation.
W
e
can
therefore
rule
out
the
scenario
as
unreasonable.
Alternativ
ely
,
since
no
correct
implemen
tation
can
pro
duce
it,
there's
no
need
to
outla
w
the
scenario.
If
w
e
don't
allo
w
the
memory
to
predict
the
future,
then
it
m
ust
alw
a
ys
b
e
able
to
explain
the
v
alues
read
in
terms
of
the
writes
that
ha
v
e
b
een
issued
so
far.
In
this
case,
w
e
ha
v
e
to
decide
whether
the
explanations
m
ust
b
e
stable.
F
or
example,
supp
ose
a
scenario
b
egins
as
follo
ws:
Pro
cessor
p
:
W
r
p
(a1;
v
1);
R
d
p
(a1;
v
3)
Pro
cessor
q
:
W
r
q
(a2;
v
2);
W
r
q
(a1;
v
3)
A
t
this
p
oin
t,
the
only
explanation
for
p
's
read
R
d
p
(a
1;
v
3)
is
that
q
's
write
Wr
q
(a
1;
v
3)
preceded
it,
whic
h
implies
that
q
's
other
write
Wr
q
(a
2;
v
2)
also
preceded
the
read.
Hence,
if
p
no
w
reads
a
2,
it
m
ust
obtain
the
v
alue
v
2.
But
supp
ose
the
scenario
con
tin
ues
as
follo
ws,
with
another
pro
cessor
r
joining
in:
Pro
cessor
p
:
W
r
p
(a1;
v
1);
R
d
p
(a1;
v
3);
R
d
p
(a2;
v
0)
Pro
cessor
q
:
W
r
q
(a2;
v
2);
W
r
q
(a1;
v
3)
Pro
cessor
r
:
W
r
r
(a1;
v
3)
W
e
can
explain
this
scenario
with
the
follo
wing
ordering
of
the
op
erations:
Wr
p
(a
1;
v
1);
Wr
r
(a
1;
v
3);
R
d
p
(a
1;
v
3);
R
d
p
(a
2;
v
0);
Wr
q
(a
2;
v
2);
Wr
q
(a
1;
v
3)

188
CHAPTER
11.
AD
V
ANCED
EXAMPLES
In
this
explanation,
pro
cessor
r
pro
vided
the
v
alue
of
a
1
read
b
y
p
,
and
p
read
the
initial
v
alue
v
0
of
memory
address
a
2.
The
explanation
is
bizarre
b
ecause
the
write
that
pro
vided
the
v
alue
of
a
1
to
p
w
as
actually
issued
after
the
completion
of
p
's
read
op
eration.
But,
b
ecause
the
explanation
of
that
v
alue
c
hanged
in
mid-execution,
the
system
nev
er
predicted
the
existence
of
a
write
that
had
not
y
et
o
ccurred.
When
writing
a
sp
ecication,
w
e
m
ust
decide
whether
or
not
to
allo
w
suc
h
c
hanges
of
the
explanation.
11.2.3
A
Serial
Memory
W
e
rst
sp
ecify
a
memory
that
cannot
predict
the
future
and
cannot
c
hange
its
explanations.
There
seems
to
b
e
no
standard
name
for
suc
h
a
memory;
I'll
call
it
a
serial
memory
.
Our
informal
correctness
condition
is
in
terms
of
the
sequence
of
all
op
era-
tions
that
ha
v
e
ev
er
b
een
issued.
There
is
a
general
metho
d
of
formalizing
suc
h
a
condition
that
w
orks
for
sp
ecifying
man
y
dieren
t
kinds
of
systems.
W
e
add
an
in
ternal
v
ariable
opQ
that
records
the
history
of
the
execution.
F
or
eac
h
pro
cessor
p
,
the
v
alue
of
opQ
[p
]
is
a
sequence
whose
i
th
elemen
t,
opQ
[p
][i
],
de-
scrib
es
the
i
th
request
issued
b
y
p
,
the
resp
onse
to
that
request
(if
it
has
b
een
issued),
and
an
y
other
information
ab
out
the
op
eration
needed
to
express
the
correctness
condition.
If
necessary
,
w
e
can
also
add
other
in
ternal
v
ariables
to
record
information
not
readily
asso
ciated
with
individual
requests.
F
or
a
system
with
the
kind
of
register
in
terface
w
e
are
using,
the
next-state
action
has
the
form
_
9
pr
o
c
2
Pr
o
c
;
r
e
g
2
R
e
g
:
_
9
r
e
q
2
R
e
quest
:
IssueR
e
quest
(pr
o
c
;
r
e
q
;
r
e
g
)
_
R
esp
ondT
oR
e
quest
(pr
o
c
;
r
e
g
)
_
Internal
(11.3)
where
the
comp
onen
t
actions
are
IssueR
e
quest
(pr
o
c
;
r
e
q
;
r
e
g
)
The
action
with
whic
h
pro
cessor
pr
o
c
issues
a
request
r
e
q
in
register
r
e
g
.
R
esp
ondT
oR
e
quest
(pr
o
c
;
r
e
g
)
The
action
with
whic
h
the
system
resp
onds
to
a
request
in
pro
cessor
pr
o
c
's
register
r
e
g
.
Internal
An
action
that
c
hanges
only
the
in
ternal
state.
Liv
eness
prop
erties
are
asserted
b
y
fairness
conditions
on
the
R
esp
ondT
oR
e
quest
and
Internal
actions.

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
189
A
general
tric
k
for
writing
the
sp
ecication
is
to
c
ho
ose
the
in
ternal
state
so
the
safet
y
part
of
the
correctness
condition
can
b
e
expressed
b
y
the
form
ula
2P
for
some
state
predicate
P
.
W
e
guaran
tee
that
P
is
alw
a
ys
true
b
y
letting
P
0
b
e
a
conjunct
of
eac
h
action.
I'll
use
this
approac
h
to
sp
ecify
the
serial
memory
,
taking
for
P
a
state
predicate
Serializable
.
W
e
w
an
t
to
require
that
the
v
alue
returned
b
y
eac
h
read
is
explainable
as
the
v
alue
written
b
y
some
op
eration
already
issued,
or
as
the
initial
v
alue
of
the
memory
.
Moreo
v
er,
w
e
don't
w
an
t
this
explanation
to
c
hange.
W
e
therefore
add
to
the
opQ
en
try
for
eac
h
completed
read
a
sour
c
e
eld
that
indicates
where
the
v
alue
came
from.
This
eld
is
set
b
y
the
R
esp
ondT
oR
e
quest
action.
W
e
w
an
t
all
op
erations
in
an
innite
b
eha
vior
ev
en
tually
to
b
e
ordered.
This
means
that,
for
an
y
t
w
o
op
erations,
the
memory
m
ust
ev
en
tually
decide
whic
h
one
precedes
the
other|and
it
m
ust
stic
k
to
that
decision.
W
e
in
tro
duce
an
in
ternal
v
ariable
opOr
der
that
describ
es
the
ordering
of
op
erations
to
whic
h
the
memory
has
already
committed
itself.
An
Internal
step
c
hanges
only
opOr
der
,
and
it
can
only
enlarge
the
ordering.
The
predicate
Serializable
used
to
sp
ecify
the
safet
y
part
of
the
correctness
condition
describ
es
what
it
means
for
opOr
der
to
b
e
a
correct
explanation.
It
asserts
that
there
is
some
consisten
t
total
ordering
of
the
op
erations
that
satises
the
follo
wing
conditions:

It
extends
opOr
der
.

It
orders
all
op
erations
from
the
same
pro
cessor
in
the
order
that
they
w
ere
issued.

It
orders
op
erations
so
that
the
source
of
an
y
read
is
the
latest
write
to
the
same
address
that
precedes
the
read,
and
is
the
initial
v
alue
i
there
is
no
suc
h
write.
W
e
no
w
translate
this
informal
sk
etc
h
of
the
sp
ecication
in
to
TLA
+
.
W
e
rst
c
ho
ose
the
t
yp
es
of
the
v
ariables
opQ
and
opOr
der
.
T
o
do
this,
w
e
dene
a
set
opId
of
v
alues
that
iden
tify
the
op
erations
that
ha
v
e
b
een
issued.
An
op
eration
is
iden
tied
b
y
a
pair
h
p
;
i
i
where
p
is
a
pro
cessor
and
i
is
a
p
osition
in
the
sequence
opQ
[p
].
(The
set
of
all
suc
h
p
ositions
i
is
domain
opQ
[p
]
.)
W
e
let
the
corresp
onding
elemen
t
of
opId
b
e
the
record
with
pr
o
c
eld
p
and
idx
eld
i
.
W
riting
the
set
of
all
suc
h
records
is
a
bit
tric
ky
b
ecause
the
p
ossible
v
alues
of
the
idx
eld
dep
end
on
the
pr
o
c
eld.
W
e
dene
opId
to
b
e
a
subset
of
the
set
of
records
whose
idx
eld
can
b
e
an
y
v
alue:
opId

=
foiv
2
[pr
o
c
:
Pr
o
c
;
idx
:
Nat
]
:
oiv
:idx
2
domain
opQ
[oiv
:pr
o
c
]g
F
or
con
v
enience,
w
e
dene
opIdQ
(oi
)
to
b
e
the
v
alue
of
the
opQ
en
try
iden
tied
b
y
an
elemen
t
oi
of
opId
:
opIdQ
(oi
)

=
opQ
[oi
:pr
o
c
][oi
:idx
]

190
CHAPTER
11.
AD
V
ANCED
EXAMPLES
The
source
of
a
v
alue
need
not
b
e
an
op
eration;
it
can
also
b
e
the
initial
con
ten
ts
of
the
memory
.
The
latter
p
ossibilit
y
is
represen
ted
b
y
letting
the
sour
c
e
eld
of
the
opQ
en
try
ha
v
e
the
sp
ecial
v
alue
InitWr
.
W
e
then
let
opQ
b
e
an
elemen
t
of
[Pr
o
c
!
Se
q
(opV
al
)],
where
opV
al
is
the
union
of
three
sets:
The
sets
R
e
quest
,
WrR
e
quest
,
and
R
dR
e
quest
are
dened
in
mo
dule
R
e
gisterInterfac
e
on
page
186.
[r
e
q
:
R
e
quest
;
r
e
g
:
R
e
g
]
Represen
ts
an
activ
e
request
in
the
register
of
the
requesting
pro
cessor
indicated
b
y
the
r
e
g
eld.
[r
e
q
:
WrR
e
quest
;
r
e
g
:
fDone
g]
Represen
ts
a
completed
write
request,
where
Done
is
a
sp
ecial
v
alue
that
is
not
a
register.
[r
e
q
:
R
dR
e
quest
;
r
e
g
:
fDone
g;
sour
c
e
:
opId
[
fInitWr
g]
Represen
ts
a
completed
read
request
whose
v
alue
came
from
the
op
eration
indicated
b
y
the
sour
c
e
eld,
or
from
the
initial
v
alue
of
the
memory
lo
cation
if
the
sour
c
e
eld
equals
InitWr
.
Note
that
opId
and
opV
al
are
state
functions
whose
v
alues
dep
end
up
on
the
v
alue
of
the
v
ariable
opQ
.
W
e
need
to
sp
ecify
the
initial
con
ten
ts
of
memory
.
A
program
generally
cannot
assume
an
ything
ab
out
the
memory's
initial
con
ten
ts,
except
that
ev
ery
address
do
es
con
tain
a
v
alue
in
V
al
.
So,
the
initial
con
ten
ts
of
memory
can
b
e
an
y
elemen
t
of
[A
dr
!
V
al
].
W
e
declare
an
\in
ternal"
constan
t
InitMem
,
whose
v
alue
is
the
memory's
initial
con
ten
ts.
In
the
nal
sp
ecication,
InitMem
will
b
e
hidden
along
with
the
in
ternal
v
ariables
opQ
and
opOr
der
.
W
e
hide
a
constan
t
with
ordinary
existen
tial
quan
tication
9
.
The
requiremen
t
that
InitMem
is
a
function
from
addresses
to
v
alues
could
b
e
made
part
of
the
initial
predicate,
but
it's
more
natural
to
express
it
in
the
quan
tier.
The
nal
sp
ecication
will
therefore
ha
v
e
the
form
9
InitMem
2
[A
dr
!
V
al
]
:
9
9
9
9
9
9
opQ
;
opOr
der
:
:
:
:
F
or
later
use,
w
e
dene
go
o
dSour
c
e
(oi
)
to
b
e
the
set
of
plausible
v
alues
for
the
source
of
a
read
op
eration
oi
in
opId
.
A
plausible
v
alue
is
either
InitWr
or
a
write
to
the
same
address
that
oi
reads.
It
will
b
e
an
in
v
arian
t
of
the
sp
ecication
that
the
source
of
an
y
completed
read
op
eration
oi
is
an
elemen
t
of
go
o
dSour
c
e
(oi
).
Moreo
v
er,
the
v
alue
returned
b
y
a
completed
read
op
eration
m
ust
come
from
its
source.
If
the
source
is
InitWr
,
then
the
v
alue
m
ust
come
from
InitMem
;
otherwise,
it
m
ust
come
from
the
source
request's
val
eld.
T
o
express
this
formally
,
observ
e
that
the
opQ
en
tries
only
of
completed
reads
ha
v
e
a
sour
c
e
eld.
Since
a
record
has
a
sour
c
e
eld
i
the
string
\source"
is
in
its
domain,
w
e
can
write
this
in
v
arian
t
as
Section
5.2
on
page
48
explains
that
a
record
is
a
function
whose
domain
is
a
set
of
strings.

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
191
8
oi
2
opId
:
(\source"
2
domain
opIdQ
(oi
))
)
^
opIdQ
(oi
):sour
c
e
2
go
o
dSour
c
e
(oi
)
^
opIdQ
(oi
):r
e
q
:val
=
if
opIdQ
(oi
):sour
c
e
=
InitWr
then
InitMem
[opIdQ
(oi
):r
e
q
:adr
]
else
opIdQ
(opIdQ
(oi
):sour
c
e
):r
e
q
:val
(11.4)
W
e
no
w
c
ho
ose
the
t
yp
e
of
opOr
der
.
W
e
usually
denote
an
ordering
relation
b
y
an
op
erator
suc
h
as
,
writing
A

B
to
mean
that
A
precedes
B
.
Ho
w
ev
er,
the
v
alue
of
a
v
ariable
cannot
b
e
an
op
erator.
So,
w
e
m
ust
represen
t
an
ordering
The
dierence
b
et
w
een
op
er-
ators
and
func-
tions
is
discussed
in
Section
6.4
on
page
69.
relation
as
a
set
or
a
function.
Mathematicians
usually
describ
e
a
relation

on
a
set
S
as
a
set
R
of
ordered
pairs
of
elemen
ts
in
S
,
with
h
A;
B
i
in
R
i
A

B
.
So,
w
e
let
opOr
der
b
e
a
subset
of
opId

opId
,
where
h
oi
;
oj
i
2
opOr
der
means
that
oi
precedes
oj
.
Our
in
ternal
state
is
redundan
t
b
ecause,
if
register
r
of
pro
cessor
p
con
tains
an
uncompleted
op
eration,
then
there
is
an
opQ
en
try
that
p
oin
ts
to
the
regis-
ter
and
con
tains
the
same
request.
This
redundancy
means
that
the
follo
wing
relations
among
the
v
ariables
are
in
v
arian
ts
of
the
sp
ecication:

If
an
opQ
en
try's
r
e
g
eld
is
not
equal
to
Done
,
then
it
denotes
a
register
whose
con
ten
ts
is
the
en
try's
r
e
q
eld.

The
n
um
b
er
of
opQ
en
tries
p
oin
ting
to
a
register
equals
1
if
the
register
con
tains
an
activ
e
op
eration,
otherwise
it
equals
0.
In
the
sp
ecication,
w
e
com
bine
this
condition,
form
ula
(11.4),
and
the
t
yp
e
in
v
arian
t
in
to
a
single
state
predicate
DataInvariant
.
Ha
ving
c
hosen
the
t
yp
es
of
the
v
ariables,
w
e
can
no
w
dene
the
initial
pred-
icate
Init
and
the
predicate
Serializable
.
The
denition
of
Init
is
easy
.
W
e
dene
Serializable
in
terms
of
totalOpOr
der
,
the
set
of
all
total
orders
of
opId
.
A
relation

is
a
total
order
of
opId
i
it
satises
the
follo
wing
three
conditions,
for
an
y
oi
,
oj
,
and
ok
in
opId
:
T
otalit
y:
Either
oi
=
oj
,
oi

oj
,
or
oj

oi
.
T
ransitivit
y:
oi

oj
and
oj

ok
imply
oi

ok
.
Irreexivit
y:
oi
6
oi
.
The
predicate
Serializable
asserts
that
there
is
a
total
order
of
opId
satisfying
the
three
conditions
on
page
189.
W
e
can
express
this
formally
as
the
assertion
that
there
exists
an
R
in
totalOpOr
der
satisfying
^
opOr
der

R
R
extends
opOr
der
^
8
oi
;
oj
2
opId
:
R
correctly
orders
op
erations
from
the
same
pro
cessor.
(oi
:pr
o
c
=
oj
:pr
o
c
)
^
(oi
:idx
<
oj
:idx
)
)
(h
oi
;
oj
i
2
R
)

192
CHAPTER
11.
AD
V
ANCED
EXAMPLES
^
8
oi
2
opId
:
F
or
ev
ery
completed
read
oi
in
opId
,
there
is
no
write
oj
to
the
same
address
that
(i)
precedes
oi
and
(ii)
follo
ws
the
source
if
that
source
is
not
InitWr
.
(\source"
2
domain
opIdQ
(oi
))
)
:
(
9
oj
2
go
o
dSour
c
e
(oi
)
:
^
h
oj
;
oi
i
2
R
^
(opIdQ
(oi
):sour
c
e
6=
InitWr
)
)
(h
opIdQ
(oi
):sour
c
e
;
oj
i
2
R
)
)
W
e
allo
w
eac
h
step
to
extend
opOr
der
to
an
y
relation
on
opId
that
satises
Serializable
.
W
e
do
this
b
y
letting
ev
ery
subaction
of
the
next-state
action
sp
ecify
opOr
der
0
with
the
conjunct
Up
dateOpOr
der
,
dened
b
y
Up
dateOpOr
der

=
^
opOr
der
0

(opId
0

opId
0
)
^
opOr
der

opOr
der
0
^
Serializable
0
The
next-state
action
has
the
generic
form
of
form
ula
(11.3)
on
page
188.
W
e
split
the
R
esp
ondT
oR
e
quest
action
in
to
the
disjunction
of
separate
R
esp
ondT
oWr
and
R
esp
ondT
oR
d
actions
that
represen
t
resp
onding
to
writes
and
reads,
resp
ec-
tiv
ely
.
R
esp
ondT
oR
d
is
the
most
complicated
of
the
next-state
action's
subac-
tions,
so
let's
examine
its
denition.
The
denition
has
the
form
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
)

=
let
r
e
q

=
r
e
gFile
[pr
o
c
][r
e
g
]
idx

=
choose
i
2
domain
opQ
[pr
o
c
]
:
opQ
[pr
o
c
][i
]:r
e
g
=
r
e
g
in
:
:
:
This
denes
r
e
q
to
b
e
the
request
in
the
register
and
idx
to
b
e
an
elemen
t
in
the
domain
of
opQ
[pr
o
c
]
suc
h
that
opQ
[pr
o
c
][idx
]:r
e
g
equals
r
e
g
.
If
the
register
is
not
free,
then
there
is
exactly
one
suc
h
v
alue
idx
;
and
opQ
[pr
o
c
][idx
]:r
e
q
,
the
idx
th
request
issued
b
y
pr
o
c
,
equals
r
e
q
.
(W
e
don't
care
what
idx
equals
if
the
register
is
free.)
The
in
expression
b
egins
with
the
enabling
condition
^
r
e
q
:op
=
\Rd"
whic
h
asserts
that
the
register
is
not
free
and
it
con
tains
a
read
request.
The
next
conjunct
of
the
in
expression
is
^
9
sr
c
2
go
o
dSour
c
e
([pr
o
c
7!
pr
o
c
;
idx
7!
idx
])
:
let
val

=
if
sr
c
=
InitWr
then
InitMem
[r
e
q
:adr
]
else
opIdQ
(sr
c
):r
e
q
:val
in
:
:
:
It
asserts
the
existence
of
a
v
alue
sr
c
,
whic
h
will
b
e
the
source
of
the
v
alue
returned
b
y
the
read;
and
it
denes
val
to
b
e
that
v
alue.
If
the
source
is
the
initial
con
ten
ts
of
memory
,
then
the
v
alue
is
obtained
from
InitMem
;
otherwise,

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
193
it
is
obtained
from
the
source
request's
val
eld.
The
inner
in
expression
has
t
w
o
conjuncts
that
sp
ecify
the
v
alues
of
r
e
gFile
0
and
opQ
0
.
The
rst
conjunct
asserts
that
the
register's
val
eld
is
set
to
val
and
its
op
eld
is
set
to
\F
ree"
,
indicating
that
the
register
is
made
free.
^
r
e
gFile
0
=
[r
e
gFile
ex
cept
!
[pr
o
c
][r
e
g
]:val
=
val
;
!
[pr
o
c
][r
e
g
]:op
=
\F
ree"]
The
second
conjunct
of
the
inner
in
expression
describ
es
the
new
v
alue
of
opQ
.
Only
the
idx
th
elemen
t
of
opQ
[pr
o
c
]
is
c
hanged.
It
is
set
to
a
record
whose
r
e
q
eld
is
the
same
as
the
original
request
r
e
q
,
except
that
its
val
eld
is
equal
to
val
;
whose
r
e
g
eld
equals
Done
;
and
whose
sour
c
e
eld
equals
sr
c
.
^
opQ
0
=
[opQ
ex
cept
!
[pr
o
c
][idx
]
=
[r
e
q
7!
[r
e
q
ex
cept
!
:val
=
val
];
r
e
g
7!
Done
;
sour
c
e
7!
sr
c
]
]
Finally
,
the
outer
in
clause
ends
with
the
conjunct
^
Up
dateOpOr
der
that
determines
the
v
alue
of
opOr
der
0
.
It
also
implicitly
determines
the
p
ossible
c
hoices
of
the
source
of
the
read|that
is,
the
v
alue
of
opQ
0
[pr
o
c
][idx
]:sour
c
e
.
F
or
some
c
hoices
of
this
v
alue
allo
w
ed
b
y
the
second
outer
conjunct,
there
will
b
e
no
v
alue
of
opOr
der
0
satisfying
Up
dateOpOr
der
.
The
conjunct
Up
dateOpOr
der
rules
out
those
c
hoices
for
the
source.
The
denitions
of
the
other
subactions
IssueR
e
quest
,
R
esp
ondT
oWr
,
and
Internal
of
the
next-state
action
are
simpler,
and
I
w
on't
explain
them.
Ha
ving
nished
the
initial
predicate
and
the
next-state
action,
w
e
m
ust
deter-
mine
the
liv
eness
conditions.
The
rst
condition
is
that
the
memory
m
ust
ev
en
tu-
ally
resp
ond
to
ev
ery
op
eration.
The
resp
onse
to
a
request
in
register
r
e
g
of
pro-
cessor
pr
o
c
is
pro
duced
b
y
a
R
esp
ondT
oWr
(pr
o
c
;
r
e
g
)
or
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
)
action.
So,
the
ob
vious
w
a
y
to
express
this
condition
is
8
pr
o
c
2
Pr
o
c
;
r
e
g
2
R
e
g
:
WF
h
:::
i
(R
esp
ondT
oWr
(pr
o
c
;
r
e
g
)
_
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
))
F
or
this
fairness
condition
to
imply
that
the
resp
onse
is
ev
en
tually
issued,
a
R
esp
ondT
oWr
(pr
o
c
;
r
e
g
)
or
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
)
step
m
ust
b
e
enabled
whenev
er
there
is
an
uncompleted
op
eration
in
pr
o
c
's
register
r
e
g
.
It
isn't
com-
pletely
ob
vious
that
a
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
)
step
is
enabled
when
there
is
a
read
op
eration
in
the
register,
since
the
step
is
enabled
only
if
there
exist
a
source
for
the
read
and
a
v
alue
of
opOr
der
0
that
satisfy
Serializable
0
.
The
re-
quired
source
and
v
alue
do
exist
b
ecause
Serializable
,
whic
h
holds
in
the
rst

194
CHAPTER
11.
AD
V
ANCED
EXAMPLES
state
of
the
step,
implies
the
existence
of
a
correct
total
order
of
all
the
op
er-
ations;
this
order
can
b
e
used
to
c
ho
ose
a
source
and
a
relation
opOr
der
0
that
satisfy
Serializability
0
.
The
second
liv
eness
condition
asserts
that
the
memory
m
ust
ev
en
tually
com-
mit
to
an
ordering
for
ev
ery
pair
of
op
erations.
It
is
expressed
as
a
fairness
condition,
for
ev
ery
pair
of
distinct
op
erations
oi
and
oj
in
opId
,
on
an
Internal
action
that
mak
es
oi
either
precede
or
follo
w
oj
in
the
order
opOr
der
0
.
A
rst
attempt
at
this
condition
is
8
oi
;
oj
2
opId
:
(oi
6=
oj
)
)
WF
h
:::
i
(
^
Internal
^
(h
oi
;
oj
i
2
opOr
der
0
)
_
(h
oj
;
oi
i
2
opOr
der
0
))
(11.5)
Ho
w
ev
er,
this
isn't
correct.
In
general,
a
form
ula
8
x
2
S
:
F
is
equiv
alen
t
to
8
x
:
(x
2
S
)
)
F
.
Hence,
(11.5)
is
equiv
alen
t
to
the
assertion
that
the
follo
wing
form
ula
holds,
for
all
constan
t
v
alues
oi
and
oj
:
(oi
2
opId
)
^
(oj
2
opId
)
)
0
B
B
@
(oi
6=
oj
)
)
WF
h
:::
i
(
^
Internal
^
(h
oi
;
oj
i
2
opOr
der
0
)
_
(h
oj
;
oi
i
2
opOr
der
0
))
1
C
C
A
In
a
temp
oral
form
ula,
a
predicate
with
no
temp
oral
op
erators
is
an
assertion
ab
out
the
initial
state.
Hence,
(11.5)
asserts
that
the
fairness
condition
is
true
for
all
pairs
of
distinct
v
alues
oi
and
oj
in
the
initial
v
alue
of
opId
.
But
opId
is
initially
empt
y
,
so
this
condition
is
v
acuously
true.
Hence,
(11.5)
is
trivially
implied
b
y
the
initial
predicate.
W
e
m
ust
instead
assert
fairness
for
the
action
^
(oi
2
opId
)
^
(oj
2
opId
)
^
Internal
^
(h
oi
;
oj
i
2
opOr
der
0
)
_
(h
oj
;
oi
i
2
opOr
der
0
))
(11.6)
for
all
distinct
v
alues
oi
and
oj
.
It
suces
to
assert
this
only
for
oi
and
oj
of
the
righ
t
t
yp
e.
Since
it's
b
est
to
use
b
ounded
quan
tiers
whenev
er
p
ossible,
let's
write
this
condition
as
8
oi
;
oj
2
[pr
o
c
:
Pr
o
c
;
idx
:
Nat
]
:
All
op
erations
are
ev
en
tually
ordered.
(oi
6=
oj
)
)
WF
h
:::
i
(^
(oi
2
opId
)
^
(oj
2
opId
)
^
Internal
^
(h
oi
;
oj
i
2
opOr
der
0
)
_
(h
oj
;
oi
i
2
opOr
der
0
))
F
or
this
form
ula
to
imply
that
an
y
t
w
o
op
erations
are
ev
en
tually
ordered
b
y
opOr
der
,
action
(11.6)
m
ust
b
e
enabled
if
oi
and
oj
are
unordered
op
erations
in
opId
.
It
is,
b
ecause
Serializable
is
alw
a
ys
enabled,
so
it
is
alw
a
ys
p
ossible
to
extend
opOr
der
to
a
total
order
of
all
issued
op
erations.

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
195
The
complete
inner
sp
ecication,
with
InitMem
,
opQ
,
and
opOr
der
visible,
is
in
mo
dule
InnerSerial
on
pages
196{198.
I
ha
v
e
made
t
w
o
minor
mo
dications
to
allo
w
the
sp
ecication
to
b
e
c
hec
k
ed
b
y
the
TLC
mo
del
c
hec
k
er.
(Chap-
ter
14
describ
es
TLC
and
explains
wh
y
these
c
hanges
are
needed.)
Instead
of
the
denition
of
opId
giv
en
on
page
189,
the
sp
ecication
uses
the
equiv
alen
t
denition
opId

=
union
f
[pr
o
c
:
p
;
idx
:
domain
opQ
[p
]
]
:
p
2
Pr
o
c
g
In
the
denition
of
Up
dateOpOr
der
,
the
rst
conjunct
is
c
hanged
from
opOr
der
0

opId
0

opId
0
to
the
equiv
alen
t
opOr
der
0
2
subset
(opId
0

opId
0
)
F
or
TLC's
b
enet,
I
also
ordered
the
conjuncts
of
all
actions
so
Up
dateOpOr
der
follo
ws
the
\assignmen
t
of
a
v
alue
to"
opQ
0
.
This
resulted
in
the
unchanged
conjunct
not
b
eing
the
last
one
in
action
Internal
.
The
complete
sp
ecication
is
written,
as
usual,
with
a
parametrized
instan-
tiation
of
InnerSerial
to
hide
the
constan
t
InitMem
and
the
v
ariables
opQ
and
opOr
der
:
module
SerialMemory
extends
R
e
gisterInterfac
e
Inner
(InitMem
;
opQ
;
opOr
der
)

=
inst
ance
InnerSerial
Sp
e
c

=
9
InitMem
2
[A
dr
!
V
al
]
:
9
9
9
9
9
9
opQ
;
opOr
der
:
Inner
(InitMem
;
opQ
;
opOr
der
)
!
Sp
e
c
11.2.4
A
Sequen
tially
Consisten
t
Memory
The
serial
memory
sp
ecication
do
es
not
allo
w
the
memory
to
predict
future
requests.
W
e
no
w
remo
v
e
this
restriction
and
sp
ecify
what
is
called
a
se
quential
ly
c
onsistent
memory
.
The
freedom
to
predict
the
future
can't
b
e
used
b
y
an
y
real
implemen
tation,
4
so
there's
little
practical
dierence
b
et
w
een
a
serial
and
a
sequen
tially
consisten
t
memory
.
Ho
w
ev
er,
the
sequen
tially
consisten
t
memory
has
a
simpler
sp
ecication.
This
sp
ecication
is
surprising
and
instructiv
e.
The
next-state
action
of
the
sequen
tial
memory
sp
ecication
has
the
same
structure
as
that
of
the
serial
memory
sp
ecication,
with
actions
IssueR
e
quest
,
4
The
freedom
to
c
hange
explanations,
whic
h
a
sequen
tially
consisten
t
memory
allo
ws,
could
conceiv
ably
b
e
used
to
p
ermit
a
more
ecien
t
implemen
tation,
but
it's
not
easy
to
see
ho
w.

196
CHAPTER
11.
AD
V
ANCED
EXAMPLES
module
InnerSerial
extends
R
e
gisterInterfac
e
;
Natur
als
;
Se
quenc
es
;
FiniteSets
const
ant
InitMem
The
initial
con
ten
ts
of
memory
,
whic
h
will
b
e
an
elemen
t
of
[Pr
o
c
!
A
dr
].
v
ariable
opQ
;
opQ
[p
][i
]
is
the
i
th
op
eration
issued
b
y
pro
cessor
p
.
opOr
der
The
order
of
op
erations,
whic
h
is
a
subset
of
opId

opId
.
(opId
is
dened
b
elo
w).
opId

=
union
f
[pr
o
c
:
fp
g;
idx
:
domain
opQ
[p
]
]
:
p
2
Pr
o
c
g
opIdQ
(oi
)

=
opQ
[oi
:pr
o
c
][oi
:idx
]
[pr
o
c
7!
p
;
idx
7!
i
]
iden
ties
op
eration
i
of
pro
cessor
p
.
InitWr

=
choose
v
:
v
=
2
[pr
o
c
:
Pr
o
c
;
idx
:
Nat
]
The
source
for
an
initial
memory
v
alue.
Done

=
choose
v
:
v
=
2
R
e
g
The
r
e
g
eld
v
alue
for
a
completed
op
eration.
opV
al

=
P
ossible
v
alues
of
opQ
[p
][i
].
[r
e
q
:
R
e
quest
;
r
e
g
:
R
e
g
]
[
[r
e
q
:
WrR
e
quest
;
r
e
g
:
fDone
g]
[
[r
e
q
:
R
dR
e
quest
;
r
e
g
:
fDone
g;
sour
c
e
:
opId
[
fInitWr
g]
An
activ
e
request
using
register
r
e
g
.
A
completed
write.
A
completed
read
of
sour
c
e
v
alue.
go
o
dSour
c
e
(oi
)

=
fInitWr
g
[
fo
2
opId
:
^
opIdQ
(o
):r
e
q
:op
=
\W
r"
^
opIdQ
(o
):r
e
q
:adr
=
opIdQ
(oi
):r
e
q
:adr
g
DataInvariant

=
^
R
e
gFileT
yp
eInvariant
Simple
t
yp
e
in
v
arian
ts
for
r
e
gFile
,
opQ
,
and
opOr
der
.
^
opQ
2
[Pr
o
c
!
Se
q
(opV
al
)]
^
opOr
der

(opId

opId
)
^
8
oi
2
opId
:
^
(\source"
2
domain
opIdQ
(oi
))
)
The
source
of
an
y
completed
read
is
either
InitWr
or
a
write
op
eration
to
the
same
address.
^
opIdQ
(oi
):sour
c
e
2
go
o
dSour
c
e
(oi
)
^
opIdQ
(oi
):r
e
q
:val
=
if
opIdQ
(oi
):sour
c
e
=
InitWr
then
InitMem
[opIdQ
(oi
):r
e
q
:adr
]
else
opIdQ
(opIdQ
(oi
):sour
c
e
):r
e
q
:val
A
read's
v
alue
comes
from
its
source.
^
(opIdQ
(oi
):r
e
g
6=
Done
)
)
opQ
correctly
describ
es
the
register
con
ten
ts.
(opIdQ
(oi
):r
e
q
=
r
e
gFile
[oi
:pr
o
c
][opIdQ
(oi
):r
e
g
])
^
8
p
2
Pr
o
c
;
r
2
R
e
g
:
Only
nonfree
registers
ha
v
e
corresp
onding
opQ
en
tries.
Car
dinality
(fi
2
domain
opQ
[p
]
:
opQ
[p
][i
]:r
e
g
=
r
g)
=
if
r
e
gFile
[p
][r
]:op
=
\F
ree"
then
0
else
1
Figure
11.6a:
Mo
dule
InnerSerial
(b
eginning).

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
197
Init

=
The
initial
predicate.
^
r
e
gFile
2
[Pr
o
c
!
[R
e
g
!
F
r
e
eR
e
gV
alue
]]
^
opQ
=
[p
2
Pr
o
c
7!
h
i]
^
opOr
der
=
fg
Ev
ery
register
is
free.
There
are
no
op
erations
in
opQ
.
The
order
relation
opOr
der
is
empt
y
.
totalOpOr
der

=
The
set
of
all
total
orders
on
the
set
opId
.
fR
2
subset
(opId

opId
)
:
^
8
oi
;
oj
2
opId
:
(oi
=
oj
)
_
(h
oi
;
oj
i
2
R
)
_
(h
oj
;
oi
i
2
R
)
^
8
oi
;
oj
;
ok
2
opId
:
(h
oi
;
oj
i
2
R
)
^
(h
oj
;
ok
i
2
R
)
)
(h
oi
;
ok
i
2
R
)
^
8
oi
2
opId
:
h
oi
;
oi
i
=
2
R
g
Serializable

=
Asserts
that
there
exists
a
total
order
R
of
all
op
erations
that
extends
opOr
der
,
orders
the
op
erations
of
eac
h
pro
cessor
correctly
,
and
mak
es
the
source
of
eac
h
read
the
most
recen
t
write
to
the
address.
9
R
2
totalOpOr
der
:
^
opOr
der

R
^
8
oi
;
oj
2
opId
:
(oi
:pr
o
c
=
oj
:pr
o
c
)
^
(oi
:idx
<
oj
:idx
)
)
(h
oi
;
oj
i
2
R
)
^
8
oi
2
opId
:
(\source"
2
domain
opIdQ
(oi
))
)
:
(
9
oj
2
go
o
dSour
c
e
(oi
)
:
^
h
oj
;
oi
i
2
R
^
(opIdQ
(oi
):sour
c
e
6=
InitWr
)
)
(h
opIdQ
(oi
):sour
c
e
;
oj
i
2
R
)
)
Up
dateOpOr
der

=
^
opOr
der
0
2
subset
(opId
0

opId
0
)
^
opOr
der

opOr
der
0
^
Serializable
0
An
action
that
c
ho
oses
the
new
v
alue
of
opOr
der
,
allo
wing
it
to
b
e
an
y
relation
that
equals
or
extends
the
curren
t
v
alue
of
opOr
der
and
satises
Serializable
.
This
action
is
used
in
dening
the
subactions
of
the
next-state
action.
IssueR
e
quest
(pr
o
c
;
r
e
q
;
r
e
g
)

=
Pro
cessor
pr
o
c
issues
request
r
e
q
in
register
r
e
g
.
^
r
e
gFile
[pr
o
c
][r
e
g
]:op
=
\F
ree"
The
register
m
ust
b
e
free.
^
r
e
gFile
0
=
[r
e
gFile
ex
cept
!
[pr
o
c
][r
e
g
]
=
r
e
q
]
Put
the
request
in
the
register.
^
opQ
0
=
[opQ
ex
cept
!
[pr
o
c
]
=
App
end
(@;
[r
e
q
7!
r
e
q
;
r
e
g
7!
r
e
g
])]
Add
request
to
opQ
[pr
o
c
].
^
Up
dateOpOr
der
R
esp
ondT
oWr
(pr
o
c
;
r
e
g
)

=
The
memory
resp
onds
to
a
write
request
in
pro
cessor
pr
o
c
's
register
r
e
g
.
^
r
e
gFile
[pr
o
c
][r
e
g
]:op
=
\W
r"
The
register
m
ust
con
tain
an
activ
e
write
request.
^
r
e
gFile
0
=
[r
e
gFile
ex
cept
!
[pr
o
c
][r
e
g
]:op
=
\F
ree"
]
The
register
is
freed.
^
let
idx

=
choose
i
2
domain
opQ
[pr
o
c
]
:
opQ
[pr
o
c
][i
]:r
e
g
=
r
e
g
The
appropriate
opQ
en
try
is
up
dated.
in
opQ
0
=
[opQ
ex
cept
!
[pr
o
c
][idx
]:r
e
g
=
Done
]
^
Up
dateOpOr
der
opOr
der
is
up
dated.
Figure
11.6b:
Mo
dule
InnerSerial
(middle).

198
CHAPTER
11.
AD
V
ANCED
EXAMPLES
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
)

=
The
memory
resp
onds
to
a
read
request
in
pro
cessor
pr
o
c
's
register
r
e
g
.
let
r
e
q

=
r
e
gFile
[pr
o
c
][r
e
g
]
pr
o
c
's
register
r
e
g
con
tains
the
request
r
e
q
,
whic
h
is
in
opQ
[pr
o
c
][idx
].
idx

=
choose
i
2
domain
opQ
[pr
o
c
]
:
opQ
[pr
o
c
][i
]:r
e
g
=
r
e
g
in
^
r
e
q
:op
=
\Rd"
The
register
m
ust
con
tain
an
activ
e
read
request.
^
9
sr
c
2
go
o
dSour
c
e
([pr
o
c
7!
pr
o
c
;
idx
7!
idx
])
:
The
read
obtains
its
v
alue
from
a
source
sr
c
.
let
val

=
if
sr
c
=
InitWr
then
InitMem
[r
e
q
:adr
]
else
opIdQ
(sr
c
):r
e
q
:val
The
v
alue
returned
b
y
the
read.
in
^
r
e
gFile
0
=
[r
e
gFile
ex
cept
!
[pr
o
c
][r
e
g
]:val
=
val
;
!
[pr
o
c
][r
e
g
]:op
=
\F
ree"]
Set
register's
val
eld,
and
free
the
register.
^
opQ
0
=
[opQ
ex
cept
opQ
[pr
o
c
][idx
]
is
up
dated
appropriately
.
!
[pr
o
c
][idx
]
=
[r
e
q
7!
[r
e
q
ex
cept
!
:val
=
val
];
r
e
g
7!
Done
;
sour
c
e
7!
sr
c
]
]
^
Up
dateOpOr
der
opOr
der
is
up
dated.
Internal

=
^
unchanged
h
r
e
gFile
;
opQ
i
^
Up
dateOpOr
der
Next

=
The
next-state
action.
_
9
pr
o
c
2
Pr
o
c
;
r
e
g
2
R
e
g
:
_
9
r
e
q
2
R
e
quest
:
IssueR
e
quest
(pr
o
c
;
r
e
q
;
r
e
g
)
_
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
)
_
R
esp
ondT
oWr
(pr
o
c
;
r
e
g
)
_
Internal
Sp
e
c

=
The
complete
in
ternal
sp
ecication.
^
Init
^
2[Next
]
h
r
e
gFile
;
opQ
;
opOr
der
i
^
8
pr
o
c
2
Pr
o
c
;
r
e
g
2
R
e
g
:
The
memory
ev
en
tually
resp
onds
to
ev
ery
request.
WF
h
r
e
gFile
;
opQ
;
opOr
der
i
(R
esp
ondT
oWr
(pr
o
c
;
r
e
g
)
_
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
))
^
8
oi
;
oj
2
[pr
o
c
:
Pr
o
c
;
idx
:
Nat
]
:
All
op
erations
are
ev
en
tually
ordered.
(oi
6=
oj
)
)
WF
h
r
e
gFile
;
opQ
;
opOr
der
i
(^
(oi
2
opId
)
^
(oj
2
opId
)
^
Internal
^
(h
oi
;
oj
i
2
opOr
der
0
)
_
(h
oj
;
oi
i
2
opOr
der
0
))
theorem
Sp
e
c
)
2(DataInvariant
^
Serializable
)
Figure
11.6c:
Mo
dule
InnerSerial
(end).

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
199
R
esp
ondT
oR
d
,
R
esp
ondT
oWr
,
and
Internal
.
Lik
e
the
serial
memory
sp
ecica-
tion,
it
has
an
in
ternal
v
ariable
opQ
to
whic
h
the
IssueR
e
quest
op
eration
app
ends
an
en
try
with
r
e
q
(request)
and
r
e
g
(register)
elds.
Ho
w
ev
er,
an
op
eration
do
es
not
remain
forev
er
in
opQ
.
Instead,
an
Internal
step
remo
v
es
it
after
it
has
b
een
completed.
The
sp
ecication
has
a
second
in
ternal
v
ariable
mem
that
represen
ts
the
con
ten
ts
of
a
memory|that
is,
the
v
alue
of
mem
is
a
function
from
A
dr
to
V
al
.
The
v
alue
of
mem
is
c
hanged
only
b
y
an
Internal
action
that
remo
v
es
a
write
from
opQ
.
Recall
that
the
correctness
condition
has
t
w
o
requiremen
ts:
1.
There
is
a
sequen
tial
execution
order
of
all
the
op
erations
that
explains
the
v
alues
returned
b
y
reads.
2.
This
execution
order
is
consisten
t
with
the
order
in
whic
h
op
erations
are
issued
b
y
eac
h
individual
pro
cessor.
The
order
in
whic
h
op
erations
are
remo
v
ed
from
opQ
is
an
explanatory
execution
order
that
satises
requiremen
t
1
if
the
Internal
action
satises
these
prop
erties:

When
a
write
of
v
alue
val
to
address
adr
is
remo
v
ed
from
opQ
,
the
v
alue
of
mem
[adr
]
is
set
to
val
.

A
read
of
address
adr
that
returned
a
v
alue
val
can
b
e
remo
v
ed
from
opQ
only
if
mem
[adr
]
=
val
.
Requiremen
t
2
is
satised
if
op
erations
issued
b
y
pro
cessor
p
are
app
ended
b
y
the
IssueR
e
quest
action
to
the
tail
of
opQ
[p
],
and
are
remo
v
ed
b
y
the
Internal
action
only
from
the
head
of
opQ
[p
].
W
e
ha
v
e
no
w
determined
what
the
IssueR
e
quest
and
Internal
actions
should
do.
The
R
esp
ondT
oWr
action
is
ob
vious;
it's
essen
tially
the
same
as
in
the
serial
memory
sp
ecication.
The
problem
is
the
R
esp
ondT
oR
d
action.
Ho
w
can
w
e
dene
it
so
that
the
v
alue
returned
b
y
a
read
is
one
that
mem
will
con
tain
when
the
Internal
action
has
to
remo
v
e
the
read
from
opQ
?
The
answ
er
is
surprisingly
simple:
w
e
allo
w
the
read
to
return
an
y
v
alue.
If
the
read
w
ere
to
return
a
bad
v
alue|for
example,
one
that
is
nev
er
written|then
the
Internal
action
w
ould
nev
er
b
e
able
to
remo
v
e
the
read
from
opQ
.
W
e
rule
out
that
p
ossibilit
y
with
a
liv
eness
condition
requiring
that
ev
ery
op
eration
in
opQ
ev
en
tually
b
e
remo
v
ed.
This
mak
es
it
easy
to
write
the
Internal
action.
The
only
remaining
problem
is
expressing
the
liv
eness
condition.
T
o
guaran
tee
that
ev
ery
op
eration
is
ev
en
tually
remo
v
ed
from
opQ
,
it
suf-
ces
to
guaran
tee
that,
for
ev
ery
pro
cessor
pr
o
c
,
the
op
eration
at
the
head
of
opQ
[pr
o
c
]
is
ev
en
tually
remo
v
ed.
The
desired
liv
eness
condition
can
therefore
b
e
expressed
as
8
pr
o
c
2
Pr
o
c
:
WF
h
:::
i
(R
emoveOp
(pr
o
c
))

200
CHAPTER
11.
AD
V
ANCED
EXAMPLES
where
R
emoveOp
(pr
o
c
)
is
an
action
that
unconditionally
remo
v
es
the
op
eration
from
the
head
of
opQ
[pr
o
c
].
F
or
con
v
enience,
w
e
let
the
R
emoveOp
(pr
o
c
)
action
also
up
date
mem
.
W
e
then
dene
a
separate
action
Internal
(pr
o
c
)
for
eac
h
pro
cessor
pr
o
c
.
It
conjoins
to
R
emoveOp
(pr
o
c
)
the
follo
wing
enabling
condition,
whic
h
asserts
that
if
the
op
eration
b
eing
remo
v
ed
is
a
read,
then
it
has
returned
the
correct
v
alue:
(He
ad
(opQ
[pr
o
c
]):r
e
q
:op
=
\Rd"
)
)
(mem
[He
ad
(opQ
[pr
o
c
]):r
e
q
:adr
]
=
He
ad
(opQ
[pr
o
c
]):r
e
q
:val
)
The
complete
in
ternal
sp
ecication,
with
the
v
ariables
opQ
and
mem
visible,
app
ears
in
mo
dule
InnerSe
quential
on
the
follo
wing
t
w
o
pages.
A
t
this
p
oin
t,
y
ou
should
ha
v
e
no
trouble
understanding
it.
Y
ou
should
also
ha
v
e
no
trouble
writing
a
mo
dule
that
instan
tiates
InnerSe
quential
and
hides
the
in
ternal
v
ariables
opQ
and
mem
to
pro
duce
the
nal
sp
ecication,
so
I
w
on't
b
other
doing
it
for
y
ou.
11.2.5
The
Memory
Sp
ecications
Considered
Almost
ev
ery
sp
ecication
w
e
write
admits
a
direct
implemen
tation,
based
on
the
initial
predicate
and
next-state
action.
Suc
h
an
implemen
tation
ma
y
b
e
completely
impractical,
but
it
is
theoretically
p
ossible.
It's
easy
to
implemen
t
the
linearizable
memory
with
a
single
cen
tral
memory
.
A
direct
implemen
tation
of
the
serial
memory
w
ould
require
main
taining
queues
of
all
op
erations
issued
th
us
far,
and
a
computationally
infeasible
searc
h
for
p
ossible
total
orderings.
But,
in
theory
,
it's
easy
.
Our
sp
ecication
of
a
sequen
tially
consisten
t
memory
cannot
b
e
implemen
ted
directly
.
A
direct
implemen
tation
w
ould
ha
v
e
to
guess
the
correct
v
alue
to
return
on
a
read,
whic
h
is
imp
ossible.
The
sp
ecication
is
not
directly
implemen
table
b
ecause
it
is
not
mac
hine
closed.
As
explained
in
Section
8.9.2
on
page
111,
a
non-mac
hine-closed
sp
ecication
is
one
in
whic
h
a
direct
implemen
tation
can
\pain
t
itself
in
to
a
corner,"
reac
hing
a
p
oin
t
at
whic
h
it
is
no
longer
p
ossible
to
satisfy
the
sp
ecication.
An
y
nite
scenario
of
memory
op
erations
can
b
e
pro
duced
b
y
a
b
eha
vior
satisfying
the
sequen
tially
consisten
t
memory's
initial
predicate
and
next-state
action|namely
,
a
b
eha
vior
that
con
tains
no
Internal
steps.
Ho
w
ev
er,
not
ev
ery
nite
scenario
can
b
e
extended
to
one
that
is
explain-
able
b
y
a
sequen
tial
execution.
F
or
example,
no
scenario
that
b
egins
as
follo
ws
is
p
ossible
in
a
t
w
o-pro
cessor
system:
This
notation
for
describing
scenar-
ios
w
as
in
tro
duced
on
page
186.
Pro
cessor
p
:
W
r
p
(a1;
v
1);
R
d
p
(a1;
v
2);
W
r
p
(a2;
v
2)
Pro
cessor
q
:
W
r
q
(a2;
v
1);
R
d
q
(a2;
v
2);
W
r
q
(a1;
v
2)
Here's
wh
y:

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
201
module
InnerSe
quential
extends
R
e
gisterInterfac
e
;
Natur
als
;
Se
quenc
es
;
FiniteSets
v
ariable
opQ
;
opQ
[p
][i
]
is
the
i
th
op
eration
issued
b
y
pro
cessor
p
.
mem
An
in
ternal
memory
.
Done

=
choose
v
:
v
=
2
R
e
g
The
r
e
g
eld
v
alue
for
a
completed
op
eration.
DataInvariant

=
^
R
e
gFileT
yp
eInvariant
^
opQ
2
[Pr
o
c
!
Se
q
(
[r
e
q
:
R
e
quest
;
r
e
g
:
R
e
g
[
fDone
g]
)
]
^
mem
2
[A
dr
!
V
al
]
^
8
p
2
Pr
o
c
;
r
2
R
e
g
:
Only
nonfree
registers
ha
v
e
corresp
onding
opQ
en
tries.
Car
dinality
(fi
2
domain
opQ
[p
]
:
opQ
[p
][i
]:r
e
g
=
r
g)
=
if
r
e
gFile
[p
][r
]:op
=
\F
ree"
then
0
else
1
Simple
t
yp
e
in
v
arian
ts
for
r
e
gFile
,
opQ
,
and
mem
.
Init

=
The
initial
predicate.
^
r
e
gFile
2
[Pr
o
c
!
[R
e
g
!
F
r
e
eR
e
gV
alue
]]
^
opQ
=
[p
2
Pr
o
c
7!
h
i]
^
mem
2
[A
dr
!
V
al
]
Ev
ery
register
is
free.
There
are
no
op
erations
in
opQ
.
The
in
ternal
memory
can
ha
v
e
an
y
initial
con
ten
ts.
IssueR
e
quest
(pr
o
c
;
r
e
q
;
r
e
g
)

=
Pro
cessor
pr
o
c
issues
request
r
e
q
in
register
r
e
g
.
^
r
e
gFile
[pr
o
c
][r
e
g
]:op
=
\F
ree"
^
r
e
gFile
0
=
[r
e
gFile
ex
cept
!
[pr
o
c
][r
e
g
]
=
r
e
q
]
^
opQ
0
=
[opQ
ex
cept
!
[pr
o
c
]
=
App
end
(@;
[r
e
q
7!
r
e
q
;
r
e
g
7!
r
e
g
])]
^
unchanged
mem
The
register
m
ust
b
e
free.
Put
request
in
register.
Add
request
to
opQ
[pr
o
c
].
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
)

=
The
memory
resp
onds
to
a
read
request
in
pro
cessor
pr
o
c
's
register
r
e
g
.
^
r
e
gFile
[pr
o
c
][r
e
g
]:op
=
\Rd"
The
register
m
ust
con
tain
an
activ
e
read
request.
^
9
val
2
V
al
:
val
is
the
v
alue
returned.
^
r
e
gFile
0
=
[r
e
gFile
ex
cept
!
[pr
o
c
][r
e
g
]:val
=
val
;
!
[pr
o
c
][r
e
g
]:op
=
\F
ree"
]
Set
the
register's
val
eld,
and
free
the
register.
^
opQ
0
=
let
idx

=
opQ
[pr
o
c
][idx
]
con
tains
the
request
in
register
r
e
g
.
choose
i
2
domain
opQ
[pr
o
c
]
:
opQ
[pr
o
c
][i
]:r
e
g
=
r
e
g
in
[opQ
ex
cept
!
[pr
o
c
][idx
]:r
e
q
:val
=
val
;
!
[pr
o
c
][idx
]:r
e
g
=
Done
]
Set
opQ
[pr
o
c
][idx
]'s
val
eld
to
val
and
its
r
e
g
eld
to
Done
.
^
unchanged
mem
Figure
11.7a:
Mo
dule
InnerSe
quential
(b
eginning).

202
CHAPTER
11.
AD
V
ANCED
EXAMPLES
R
esp
ondT
oWr
(pr
o
c
;
r
e
g
)

=
The
memory
resp
onds
to
a
write
request
in
pro
cessor
pr
o
c
's
register
r
e
g
.
^
r
e
gFile
[pr
o
c
][r
e
g
]:op
=
\W
r"
The
register
m
ust
con
tain
an
activ
e
write
request.
^
r
e
gFile
0
=
[r
e
gFile
ex
cept
!
[pr
o
c
][r
e
g
]:op
=
\F
ree"
]
F
ree
the
register.
^
let
idx

=
choose
i
2
domain
opQ
[pr
o
c
]
:
opQ
[pr
o
c
][i
]:r
e
g
=
r
e
g
Up
date
the
appropri-
ate
opQ
en
try
.
in
opQ
0
=
[opQ
ex
cept
!
[pr
o
c
][idx
]:r
e
g
=
Done
]
^
unchanged
mem
R
emoveOp
(pr
o
c
)

=
Unconditionally
remo
v
e
the
op
eration
at
the
head
of
opQ
[pr
o
c
]
and
up
date
mem
.
^
opQ
[pr
o
c
]
6=
h
i
opQ
[pr
o
c
]
m
ust
b
e
nonempt
y
.
^
He
ad
(opQ
[pr
o
c
]):r
e
g
=
Done
The
op
eration
m
ust
ha
v
e
b
een
completed.
^
mem
0
=
if
He
ad
(opQ
[pr
o
c
]):r
e
q
:op
=
\Rd"
then
mem
else
[mem
ex
cept
!
[He
ad
(opQ
[pr
o
c
]):r
e
q
:adr
]
=
He
ad
(opQ
[pr
o
c
]):r
e
q
:val
]
Lea
v
e
mem
unc
hanged
for
a
read
op
eration,
up
date
it
for
a
write
op
eration.
^
opQ
0
=
[opQ
ex
cept
!
[pr
o
c
]
=
T
ail
(@)]
Remo
v
e
the
op
eration
from
opQ
[pr
o
c
].
^
unchanged
r
e
gFile
No
register
is
c
hanged.
Internal
(pr
o
c
)

=
Remo
v
e
the
op
eration
at
the
head
of
opQ
[pr
o
c
].
But
if
it's
a
read,
only
do
so
if
it
returned
the
v
alue
no
w
in
mem
.
^
R
emoveOp
(pr
o
c
)
^
(He
ad
(opQ
[pr
o
c
]):r
e
q
:op
=
\Rd"
)
)
(mem
[He
ad
(opQ
[pr
o
c
]):r
e
q
:adr
]
=
He
ad
(opQ
[pr
o
c
]):r
e
q
:val
)
Next

=
The
next-state
action.
9
pr
o
c
2
Pr
o
c
:
_
9
r
e
g
2
R
e
g
:
_
9
r
e
q
2
R
e
quest
:
IssueR
e
quest
(pr
o
c
;
r
e
q
;
r
e
g
)
_
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
)
_
R
esp
ondT
oWr
(pr
o
c
;
r
e
g
)
_
Internal
(pr
o
c
)
Sp
e
c

=
^
Init
^
2[Next
]
h
r
e
gFile
;
opQ
;
mem
i
^
8
pr
o
c
2
Pr
o
c
;
r
e
g
2
R
e
g
:
The
memory
ev
en
tually
resp
onds
to
ev
ery
request.
WF
h
r
e
gFile
;
opQ
;
mem
i
(R
esp
ondT
oWr
(pr
o
c
;
r
e
g
)
_
R
esp
ondT
oR
d
(pr
o
c
;
r
e
g
))
^
8
pr
o
c
2
Pr
o
c
:
Ev
ery
op
eration
is
ev
en
tually
remo
v
ed
from
opQ
.
WF
h
r
e
gFile
;
opQ
;
mem
i
(R
emoveOp
(pr
o
c
))
theorem
Sp
e
c
)
2
DataInvariant
Figure
11.7b:
Mo
dule
InnerSe
quential
(end).

11.2.
OTHER
MEMOR
Y
SPECIFICA
TIONS
203
Wr
q
(a
1;
v
2)
precedes
R
d
p
(a
1;
v
2)
This
is
the
only
explanation
of
the
v
alue
read
b
y
p
.
precedes
Wr
p
(a
2;
v
2)
By
the
order
in
whic
h
op
erations
are
issued.
precedes
R
d
q
(a
2;
v
2)
This
is
the
only
explanation
of
the
v
alue
read
b
y
q
.
precedes
Wr
q
(a
1;
v
2)
By
the
order
in
whic
h
op
erations
are
issued.
Hence
q
's
write
of
a
1
m
ust
precede
itself,
whic
h
is
imp
ossible.
As
men
tioned
in
Section
8.9.2,
a
sp
ecication
is
mac
hine
closed
if
the
liv
eness
prop
ert
y
is
the
conjunction
of
fairness
prop
erties
for
actions
that
imply
the
next-state
action.
The
sequen
tial
memory
sp
ecication
asserts
w
eak
fairness
of
R
emoveOp
(pr
o
c
),
for
pro
cessors
pr
o
c
,
and
R
emoveOp
(pr
o
c
)
do
es
not
imply
the
next-state
action.
(The
next-state
action
do
es
not
allo
w
a
R
emoveOp
(pr
o
c
)
step
that
remo
v
es
from
opQ
[pr
o
c
]
a
read
that
has
returned
the
wrong
v
alue.)
V
ery
high-lev
el
system
sp
ecications,
suc
h
as
our
memory
sp
ecications,
are
subtle.
It's
easy
to
get
them
wrong.
The
approac
h
w
e
used
in
the
serial
mem-
ory
sp
ecication|namely
,
writing
conditions
on
the
history
of
all
op
erations|is
dangerous.
It's
easy
to
forget
some
conditions.
A
non-mac
hine-closed
sp
ecica-
tion
can
o
ccasionally
b
e
the
simplest
w
a
y
to
express
what
y
ou
w
an
t
so
sa
y
.

204
CHAPTER
11.
AD
V
ANCED
EXAMPLES

P
art
I
I
I
The
T
o
ols
205


Chapter
12
The
Syn
tactic
Analyzer
The
Syn
tactic
Analyzer
is
a
Ja
v
a
program,
written
b
y
Jean-Charles
Gr

egoire
and
Da
vid
Jeerson,
that
parses
a
TLA
+
sp
ecication
and
c
hec
ks
it
for
errors.
The
analyzer
also
serv
es
as
a
fron
t
end
for
other
to
ols,
suc
h
as
TLC
(see
Chapter
14).
It
is
a
v
ailable
from
the
TLA
W
eb
page.
Y
ou
will
probably
run
the
analyzer
b
y
t
yping
the
command
pr
o
gr
am
name
option
sp
e
c
le
where
pr
o
gr
am
name
dep
ends
on
y
our
particular
system.
It
migh
t
b
e
java
tlasany.SANY
sp
e
c
le
is
the
name
of
the
le
con
taining
the
TLA
+
sp
ecication.
Eac
h
mo
dule
named
M
that
app
ears
in
the
sp
ecication
(except
for
submo
dules)
m
ust
b
e
in
a
separate
le
named
M
.tla.
The
extension
.tla
ma
y
b
e
omitted
from
sp
e
c
le
.
option
is
either
empt
y
or
consists
of
one
of
the
follo
wing
t
w
o
options:
-s
Causes
the
analyzer
to
c
hec
k
only
for
syn
tactic
errors
and
not
for
se-
man
tic
errors.
(These
t
w
o
classes
of
error
are
explained
b
elo
w.)
Y
ou
can
use
this
option
to
nd
syn
tax
errors
when
y
ou
b
egin
writing
a
sp
ecication.
-d
Causes
the
analyzer
to
en
ter
debugging
mo
de
after
c
hec
king
the
sp
eci-
cation.
In
this
mo
de,
y
ou
can
examine
the
sp
ecication's
structure|for
example,
nding
out
where
it
thinks
a
particular
iden
tier
is
dened
or
declared.
The
do
cumen
tation
that
comes
with
the
analyzer
explains
ho
w
to
do
this.
207

208
CHAPTER
12.
THE
SYNT
A
CTIC
ANAL
YZER
The
rest
of
this
brief
c
hapter
pro
vides
some
hin
ts
for
what
to
do
when
the
Syn
tactic
Analyzer
rep
orts
an
error.
The
errors
that
the
analyzer
detects
fall
in
to
t
w
o
separate
classes,
whic
h
are
usually
called
syntactic
and
semantic
errors.
A
syn
tactic
error
is
one
that
mak
es
the
sp
ecication
grammatically
incorrect,
meaning
that
it
violates
either
the
BNF
grammar
or
the
precedence
and
alignmen
t
rules,
describ
ed
in
Chap-
ter
15.
A
seman
tic
error
is
one
that
violates
the
legalit
y
conditions
men
tioned
in
Chapter
17.
The
term
semantic
err
or
is
misleading,
b
ecause
it
suggests
an
error
that
mak
es
a
sp
ecication
ha
v
e
the
wrong
meaning.
All
errors
found
b
y
the
analyzer
are
ones
that
mak
e
the
sp
ecication
illegal|that
is,
not
syn
tactically
w
ell-formed|and
hence
mak
e
it
ha
v
e
no
meaning
at
all.
The
analyzer
reads
the
le
sequen
tially
,
starting
from
the
b
eginning,
and
it
rep
orts
a
syn
tax
error
if
and
when
it
reac
hes
a
p
oin
t
at
whic
h
it
b
ecomes
imp
ossible
for
an
y
con
tin
uation
to
pro
duce
a
grammatically
correct
sp
ecication.
F
or
example,
if
w
e
omitted
the
colon
after
9
r
e
q
2
MR
e
q
in
the
denition
of
R
e
q
from
mo
dule
InternalMemory
on
page
52,
w
e
w
ould
get
R
e
q
(p
)

=
^
ctl
[p
]
=
\rdy"
^
9
r
e
q
2
MR
e
q
^
Send
(p
;
r
e
q
;
memInt
;
memInt
0
)
^
buf
0
=
[buf
ex
cept
!
[p
]
=
r
e
q
]
^
ctl
0
=
[ctl
ex
cept
!
[p
]
=
\busy"
]
^
unchanged
mem
This
w
ould
cause
the
analyzer
to
prin
t
something
lik
e
***Parse
Error***
Encountered
"/\"
at
line
19,
column
11
Line
19,
column
11
is
the
p
osition
of
the
^
that
b
egins
the
last
line
of
the
denition
(righ
t
b
efore
the
unchanged).
Un
til
then,
the
analyzer
though
t
it
w
as
parsing
a
quan
tied
expression
that
b
egan
9
r
e
q
2
(MR
e
q
^
Send
(p
;
r
e
q
;
memInt
;
memInt
0
)
^
buf
0
=
:
:
:
(Suc
h
an
expression
is
silly
,
ha
ving
the
form
9
r
e
q
2
p
:
:
:
:
where
p
is
a
Bo
olean,
but
it's
legal.)
The
analyzer
w
as
in
terpreting
eac
h
of
these
^
sym
b
ols
as
an
inx
op
erator.
Ho
w
ev
er,
in
terpreting
the
last
^
of
this
denition
(at
line
19,
column
11)
as
an
inx
op
erator
w
ould
violate
the
alignmen
t
rules
for
the
outer
conjunction
list,
so
the
analyzer
rep
orted
an
error.
As
this
example
suggests,
the
analyzer
ma
y
disco
v
er
a
syn
tax
error
far
past
the
actual
mistak
e.
T
o
help
y
ou
lo
cate
the
problem,
it
prin
ts
out
a
trace
of
where
it
w
as
in
the
parse
tree
when
it
found
the
error.
F
or
this
example,
it
prin
ts

209
Residual
stack
trace
follows:
Quantified
form
starting
at
line
16,
column
14.
Junction
Item
starting
at
line
16,
column
11.
AND-OR
Junction
starting
at
line
15,
column
11.
Definition
starting
at
line
15,
column
1.
Module
body
starting
at
line
3,
column
1.
If
y
ou
can't
nd
the
source
of
an
error,
try
the
\divide
and
conquer"
metho
d:
k
eep
remo
ving
dieren
t
parts
of
the
mo
dule
un
til
y
ou
isolate
the
source
of
the
problem.
Seman
tic
errors
are
usually
easy
to
nd
b
ecause
the
analyzer
can
lo
cate
them
precisely
.
A
t
ypical
seman
tic
error
is
an
undened
sym
b
ol
that
arises
b
ecause
y
ou
mist
yp
e
an
iden
tier.
If,
instead
of
lea
ving
out
the
colon
in
the
denition
of
R
e
q
(p
),
w
e
had
left
out
the
e
in
MR
e
q
,
the
analyzer
w
ould
ha
v
e
rep
orted
line
16,
col
26
to
line
16,
col
28
of
module
InternalMemory
Could
not
resolve
name
'MRq'.
The
analyzer
stops
when
it
encoun
ters
the
rst
syn
tactic
error.
It
can
detect
m
ultiple
seman
tic
errors
in
a
single
run.

210
CHAPTER
12.
THE
SYNT
A
CTIC
ANAL
YZER

Chapter
13
The
TLA
T
E
X
T
yp
esetter
TLA
T
E
X
is
a
Ja
v
a
program
for
t
yp
esetting
TLA
+
mo
dules,
based
on
ideas
b
y
Dmitri
Sam
b
orski.
It
can
b
e
obtained
through
the
TLA
W
eb
page.
13.1
In
tro
duction
TLA
T
E
X
calls
the
L
A
T
E
X
program
to
do
the
actual
t
yp
esetting.
L
A
T
E
X
is
a
do
cumen
t-pro
duction
system
based
on
Donald
Kn
uth's
T
E
X
t
yp
esetting
pro-
gram.
1
L
A
T
E
X
normally
pro
duces
as
its
output
a
dvi
le
|a
le
with
extension
dvi
con
taining
a
device-indep
enden
t
description
of
the
t
yp
eset
output.
TLA
T
E
X
has
options
that
allo
w
it
to
call
another
program
to
translate
the
dvi
le
in
to
a
P
ostScript
or
PDF
le.
Some
v
ersions
of
L
A
T
E
X
pro
duce
a
PDF
le
directly
.
Y
ou
m
ust
ha
v
e
L
A
T
E
X
installed
on
y
our
computer
to
run
TLA
T
E
X.
L
A
T
E
X
is
public-domain
soft
w
are
that
can
b
e
do
wnloaded
from
the
W
eb;
proprietary
v
ersions
are
also
a
v
ailable.
The
TLA
W
eb
page
p
oin
ts
to
the
TLA
T
E
X
W
eb
page,
whic
h
con
tains
information
ab
out
obtaining
L
A
T
E
X
and
a
P
ostScript
or
PDF
con
v
erter.
Y
ou
will
probably
run
TLA
T
E
X
b
y
t
yping
java
tlatex.TLA
[options
]
leName
where
leName
is
the
name
of
the
input
le,
and
[options
]
is
an
optional
sequence
of
options,
eac
h
option
name
preceded
b
y
\-".
Some
options
are
follo
w
ed
b
y
an
argumen
t,
a
m
ulti-w
ord
argumen
t
b
eing
enclosed
in
double-quotes.
If
leName
do
es
not
con
tain
an
extension,
then
the
input
le
is
leName.tla.
F
or
example,
the
command
1
L
A
T
E
X
is
describ
ed
in
L
A
T
E
X:
A
Do
cument
Pr
ep
ar
ation
System,
Se
c
ond
Edition,
b
y
Leslie
Lamp
ort,
published
b
y
Addison-W
esley
,
Reading,
Massac
h
usetts,
1994.
T
E
X
is
describ
ed
in
The
T
E
Xb
o
ok
b
y
Donald
E.
Kn
uth,
published
b
y
Addison-W
esley
,
Reading,
Massac
h
usetts,
1986.
211

212
CHAPTER
13.
THE
TLA
T
E
X
TYPESETTER
java
tlatex.TLA
-ptSize
12
-shade
MySpec
t
yp
esets
the
mo
dule
in
the
le
MySp
e
c
:tla
using
the
ptSize
option
with
argumen
t
12
and
the
shade
option.
The
input
le
m
ust
con
tain
a
complete
TLA
+
mo
dule.
Running
TLA
T
E
X
with
the
help
option
pro
duces
a
list
of
all
options.
Running
it
with
the
info
option
pro
duces
most
of
the
information
con
tained
in
this
c
hapter.
(The
leName
argumen
t
can
b
e
omitted
when
using
the
help
or
info
option.)
All
y
ou
probably
need
to
kno
w
ab
out
using
TLA
T
E
X
is

TLA
T
E
X
can
shade
commen
ts,
as
explained
in
the
next
section.

The
next
section
also
explains
ho
w
to
get
TLA
T
E
X
to
pro
duce
a
P
ostScript
or
PDF
le.

The
numb
er
option
causes
TLA
T
E
X
to
prin
t
line
n
um
b
ers
in
the
left
mar-
gin.

Y
ou
should
use
the
latexCommand
option
if
y
ou
run
L
A
T
E
X
on
y
our
system
b
y
t
yping
something
other
than
latex.
F
or
example,
if
y
ou
run
L
A
T
E
X
on
le
f.tex
b
y
t
yping
locallatex
f.tex
then
y
ou
should
run
TLA
T
E
X
b
y
t
yping
something
lik
e
java
tlatex.TLA
-latexCommand
locallatex
leName

If
y
ou
happ
en
to
use
an
y
of
these
three
t
w
o-c
haracter
sequences
in
a
com-
men
t:
`~
`^
`.
then
y
ou'd
b
etter
read
Section
13.4
on
page
214
to
learn
ab
out
ho
w
TLA
T
E
X
formats
commen
ts.
TLA
T
E
X's
output
should
b
e
go
o
d
enough
for
most
purp
oses.
The
follo
wing
sections
describ
e
ho
w
y
ou
can
get
TLA
T
E
X
to
do
a
b
etter
job,
and
what
to
do
in
the
unlik
ely
case
that
it
pro
duces
w
eird
output.
13.2
Commen
t
Shading
The
shade
option
causes
TLA
T
E
X
to
t
yp
eset
commen
ts
in
shaded
b
o
xes.
A
sp
ecication
generally
lo
oks
b
est
when
commen
ts
are
shaded,
as
they
are
in
this
b
o
ok.
Ho
w
ev
er,
shading
is
not
supp
orted
b
y
some
programs
for
viewing
and
prin
ting
dvi
les.
Hence,
it
ma
y
b
e
necessary
to
create
a
P
ostScript
or
PDF
le
from
the
dvi
le
to
view
a
sp
ecication
with
shaded
commen
ts.
Here
are
all
the
options
relev
an
t
to
shading.

13.3.
HO
W
IT
TYPESETS
THE
SPECIFICA
TION
213
-grayLevel
num
Determines
the
darkness
of
the
shading,
where
num
is
a
n
um
b
er
b
et
w
een
0
and
1.
The
v
alue
0
means
completely
blac
k,
and
1
means
white;
the
default
v
alue
is
.85.
The
actual
degree
of
shading
dep
ends
on
the
output
device
and
can
v
ary
from
prin
ter
to
prin
ter
and
from
screen
to
screen.
Y
ou
will
ha
v
e
to
exp
erimen
t
to
nd
the
righ
t
v
alue
for
y
our
system.
-ps
-nops
These
options
tell
TLA
T
E
X
to
create
or
not
to
create
a
P
ostScript
or
PDF
output
le.
The
default
is
to
create
one
if
the
shade
option
is
sp
ecied,
and
otherwise
not
to.
-psCommand
cmd
This
is
the
command
run
b
y
TLA
T
E
X
to
pro
duce
the
P
ostScript
or
PDF
output
le.
Its
default
v
alue
is
dvips.
TLA
T
E
X
calls
the
op
erating
system
with
the
command
cmd
dviFile
where
dviFile
is
the
name
of
the
dvi
le
pro
duced
b
y
running
L
A
T
E
X.
If
a
more
sophisticated
command
is
needed,
y
ou
ma
y
w
an
t
to
use
the
nops
option
and
run
a
separate
program
to
create
the
P
ostScript
or
PDF
le.
13.3
Ho
w
It
T
yp
esets
the
Sp
ecication
TLA
T
E
X
should
t
yp
eset
the
sp
ecication
itself
prett
y
m
uc
h
the
w
a
y
y
ou
w
ould
w
an
t
it
to.
It
preserv
es
most
of
the
meaningful
alignmen
ts
in
the
sp
ecication|
for
example:
Input
Action
==
/\
x'
=
x
-
y
/\
yy'
=
123
/\
zzz'
=
zzz
Output
A
ction

=
^
x
0
=
x
 y
^
yy
0
=
123
^
zzz
0
=
zzz
Observ
e
ho
w
the
^
and
=
sym
b
ols
are
aligned
in
the
output.
Extra
spaces
in
the
input
will
b
e
reected
in
the
output.
Ho
w
ev
er,
TLA
T
E
X
treats
no
space
and
one
space
b
et
w
een
sym
b
ols
the
same:
Input
x+y
x
+
y
x
+
y
Output
x
+
y
x
+
y
x
+
y
TLA
T
E
X
t
yp
esets
the
single
TLA
+
mo
dule
that
m
ust
app
ear
in
the
input
le.
It
will
also
t
yp
eset
an
y
material
that
precedes
and
follo
ws
the
mo
dule
as
if

214
CHAPTER
13.
THE
TLA
T
E
X
TYPESETTER
it
w
ere
a
commen
t.
(Ho
w
ev
er,
that
text
w
on't
b
e
shaded.)
The
noPr
olo
g
and
noEpilo
g
options
suppress
t
yp
esetting
of
material
that
precedes
and
follo
ws
the
mo
dule,
resp
ectiv
ely
.
TLA
T
E
X
do
es
not
c
hec
k
that
the
sp
ecication
is
syn
tactically
correct
TLA
+
input.
Ho
w
ev
er,
it
will
rep
ort
an
error
if
the
sp
ecication
con
tains
an
illegal
lexeme,
suc
h
as
\;".
13.4
Ho
w
It
T
yp
esets
Commen
ts
TLA
T
E
X
distinguishes
b
et
w
een
one-line
and
m
ulti-line
commen
ts.
A
one-line
commen
t
is
an
y
commen
t
that
is
not
a
m
ulti-line
commen
t.
Multi-line
commen
ts
can
b
e
t
yp
ed
in
an
y
of
the
follo
wing
three
st
yles:
(**************)
\*************
(*
This
(*
This
is
*)
\*
This
is
is
a
(*
a
comment.
*)
\*
a
comment.
comment.
*)
(**************)
\*************
In
the
rst
t
w
o
st
yles,
the
(*
or
\*
c
haracters
on
the
left
m
ust
all
b
e
aligned,
and
the
last
line
(con
taining
the
commen
t
**



**)
is
optional.
In
the
rst
st
yle,
nothing
ma
y
app
ear
to
the
righ
t
of
the
commen
t|otherwise,
the
input
is
considered
to
b
e
a
sequence
of
separate
one-line
commen
ts.
The
third
st
yle
w
orks
b
est
when
nothing
app
ears
on
the
same
line
to
the
left
of
the
(*
or
to
the
righ
t
of
the
*).
TLA
T
E
X
tries
to
do
a
sensible
job
of
t
yp
esetting
commen
ts.
In
a
m
ulti-
line
commen
t,
it
usually
considers
a
sequence
of
non-blank
lines
to
b
e
a
single
paragraph,
in
whic
h
case
it
t
yp
esets
them
as
one
paragraph
and
ignores
line
breaks
in
the
input.
But
it
do
es
try
to
recognize
tables
and
other
kinds
of
m
ulti-line
formatting
when
deciding
where
to
break
lines.
Y
ou
can
help
it
as
follo
ws:

End
eac
h
sen
tence
with
a
p
erio
d
(\.").

Add
blank
lines
to
indicate
the
logical
separation
of
items.

Left-align
the
lines
of
eac
h
paragraph.
Belo
w
are
some
common
w
a
ys
in
whic
h
TLA
T
E
X
can
mess
up
the
t
yp
esetting
of
commen
ts,
and
what
y
ou
can
do
ab
out
it.
TLA
T
E
X
can
confuse
parts
of
a
sp
ecication
with
ordinary
text.
F
or
example,
iden
tiers
should
b
e
italicized,
and
the
min
us
in
the
expression
x
 y
should
b
e
t
yp
eset
dieren
tly
from
the
dash
in
x-r
ay.
TLA
T
E
X
gets
this
righ
t
most
of
the
time,
but
it
do
es
mak
e
mistak
es.
Y
ou
can
tell
TLA
T
E
X
to
treat
something
as
part
of
a
sp
ecication
b
y
putting
single
quotes
(`
and
')
around
it.
Y
ou
can
tell
it
to
treat
something
as
ordinary
text
b
y
putting
`^
and
^'
around
it.
F
or
example:

13.4.
HO
W
IT
TYPESETS
COMMENTS
215
Input
\****************
**
**
***
**
***
\*
A
better
value
of
`bar'
is
\*
now
in
`^http://foo/bar
^'.
\****************
**
**
***
**
***
Output
A
b
etter
v
alue
of
b
ar
is
no
w
in
h
ttp://fo
o/bar.
But
this
is
seldom
necessary;
TLA
T
E
X
usually
do
es
the
righ
t
thing.
W
arning:
Do
not
put
an
y
c
haracter
b
et
w
een
`^
and
^'
except
letters,
n
um
b
ers,
and
ordinary
punctuation|unless
y
ou
kno
w
what
y
ou're
doing.
In
particular,
the
follo
wing
c
haracters
ha
v
e
sp
ecial
meaning
to
L
A
T
E
X
and
can
ha
v
e
unexp
ected
eects
if
used
b
et
w
een
`^
and
^':
_
~
#
$
%
^
&
<
>
\
"
|
{
}
See
Section
13.8
on
page
219
for
further
information
ab
out
what
can
go
b
et
w
een
`^
and
^'.
TLA
T
E
X
isn't
v
ery
go
o
d
at
cop
ying
the
w
a
y
paragraphs
are
formatted
in
a
commen
t.
F
or
example,
note
ho
w
it
fails
to
align
the
t
w
o
As
in
Input
\****************
**
**
***
\*
gnat:
A
tiny
insect.
\*
\*
gnu:
A
short
word.
\****************
**
**
***
Output
gnat:
A
tin
y
insect.
gn
u:
A
short
w
ord.
Y
ou
can
tell
TLA
T
E
X
to
t
yp
eset
a
sequence
of
lines
precisely
the
w
a
y
they
app
ear
in
the
input,
using
a
xed-width
fon
t,
b
y
enclosing
the
lines
with
`.
and
.'
,
as
in
Input
\****************
**
**
***
*
\*
This
explains
it
all:
\*
\*
`.
---
---
\*
|
P
|--->|
M
|
\*
---
---
.'
\****************
**
**
***
*
Output
This
explains
it
all:
---
---
|
P
|--->|
M
|
---
---
Using
`.
and
.'
is
the
only
reasonable
thing
to
do
for
a
diagram.
Ho
w
ev
er,
if
y
ou
kno
w
(or
w
an
t
to
learn)
L
A
T
E
X,
Section
13.8
b
elo
w
on
using
L
A
T
E
X
commands
in
commen
ts
will
explain
ho
w
y
ou
can
get
TLA
T
E
X
to
do
a
go
o
d
job
of
formatting
things
lik
e
lists
and
tables.
TLA
T
E
X
will
o
ccasionally
t
yp
eset
a
paragraph
v
ery
lo
osely
,
with
one
or
more
lines
con
taining
lots
of
space
b
et
w
een
the
w
ords.
This
happ
ens
if
there
is
no
go
o
d
w
a
y
to
t
yp
eset
the
paragraph.
If
it
b
others
y
ou,
the
easiest
solution
is
to
rewrite

216
CHAPTER
13.
THE
TLA
T
E
X
TYPESETTER
the
paragraph.
Y
ou
can
also
try
to
x
the
problem
with
L
A
T
E
X
commands.
(See
Section
13.8
b
elo
w.)
TLA
T
E
X
usually
handles
pairs
of
double-quote
c
haracters
(")
the
w
a
y
it
should:
Input
\****************
**
**
\*
The
string
"ok"
is
\*
a
"good"
value.
\****************
**
**
Output
The
string
\ok"
is
a
\go
o
d"
v
alue.
Ho
w
ev
er,
if
it
gets
confused,
y
ou
can
use
single
quotes
to
iden
tify
string
v
alues
and
``
and
''
to
pro
duce
the
left
and
righ
t
double-quotes
of
ordinary
text:
Input
\****************
**
**
***
\*
He
asks
``Is
`"good"'
\*
bad?''
\****************
**
**
***
Output
He
asks
\Is
\go
o
d"
bad?"
TLA
T
E
X
ignores
an
y
(*
.
.
.
*)
commen
t
that
app
ears
within
another
com-
men
t.
So,
y
ou
can
get
it
not
to
t
yp
eset
part
of
a
commen
t
b
y
enclosing
that
part
b
et
w
een
(*
and
*).
But
a
b
etter
w
a
y
to
omit
part
of
a
commen
t
is
to
enclose
it
b
et
w
een
`~
and
~':
Input
\****************
**
**
\*
x+y
is
always
`~I
\*
hope~'
positive.
\****************
**
**
Output
x
+
y
is
alw
a
ys
p
ositiv
e.
13.5
Adjusting
the
Output
F
ormat
The
follo
wing
options
allo
w
y
ou
to
adjust
the
fon
t
size,
the
dimensions
of
the
prin
ted
area,
and
the
p
osition
of
the
text
on
the
page:
-ptSize
num
Sp
ecies
the
size
of
the
fon
t.
Legal
v
alues
of
num
are
10,
11,
or
12,
whic
h
cause
the
sp
ecication
to
b
e
t
yp
eset
in
a
10-,
11-,
or
12-p
oin
t
fon
t.
The
default
v
alue
is
10.
-textwidth
num
-textheight
num
The
v
alue
of
num
sp
ecies
the
width
and
heigh
t
of
the
t
yp
eset
output,
in
p
oin
ts.
A
p
oin
t
is
1/72
of
an
inc
h,
or
ab
out
1/3
mm.

13.6.
OUTPUT
FILES
217
-hoffset
num
-voffset
num
The
v
alue
of
num
sp
ecies
the
distance,
in
p
oin
ts,
b
y
whic
h
the
text
should
b
e
mo
v
ed
horizon
tally
or
v
ertically
on
the
page.
Exactly
where
on
a
page
the
text
app
ears
dep
ends
on
the
prin
ter
or
screen-displa
y
program.
Y
ou
ma
y
ha
v
e
to
adjust
this
v
alue
to
get
the
output
to
app
ear
cen
tered
on
the
prin
ted
page,
or
for
the
en
tire
output
to
b
e
visible
when
view
ed
on
the
screen.
13.6
Output
Files
TLA
T
E
X
itself
writes
either
t
w
o
or
three
les,
dep
ending
on
the
options.
The
names
of
these
les
are
normally
determined
from
the
name
of
the
input
le.
Ho
w
ev
er,
options
allo
w
y
ou
to
sp
ecify
the
name
of
eac
h
of
these
les.
TLA
T
E
X
also
runs
the
separate
L
A
T
E
X
program
and
p
ossibly
a
program
to
pro
duce
a
P
ostScript
or
PDF
le.
These
programs
pro
duce
additional
les.
Belo
w
are
the
le-related
options.
In
their
descriptions,
the
ro
ot
of
a
le
name
is
the
name
with
an
y
extension
or
path
sp
ecier
remo
v
ed;
for
example,
the
ro
ot
of
c:\foo\bar.tla
is
bar.
All
le
names
are
in
terpreted
relativ
e
to
the
directory
in
whic
h
TLA
T
E
X
is
run.
-out
leName
If
f
is
the
ro
ot
of
leName,
then
f.tex
is
the
name
of
the
L
A
T
E
X
input
le
that
TLA
T
E
X
writes
to
pro
duce
the
nal
output.
TLA
T
E
X
then
runs
L
A
T
E
X
with
f.tex
as
input,
pro
ducing
the
follo
wing
les:
f.dvi
The
dvi
output
le.
f.lo
g
A
log
le,
con
taining
L
A
T
E
X's
messages.
In
this
le,
an
overful
l
hb
ox
w
arning
means
that
a
sp
ecication
line
is
to
o
wide
and
extends
in
to
the
righ
t
margin,
and
an
underful
l
hb
ox
w
arning
means
that
L
A
T
E
X
could
nd
no
go
o
d
line
breaks
in
a
commen
t
paragraph.
Unfor-
tunately
,
the
line
n
um
b
ers
in
the
le
refer
to
the
f.tex
le,
not
to
the
sp
ecication.
But
b
y
examining
the
f.tex
le,
y
ou
can
probably
gure
out
where
the
corresp
onding
part
of
the
sp
ecication
is.
f.aux
A
L
A
T
E
X
auxiliary
le
that
is
of
no
in
terest.
The
default
out
le
name
is
the
ro
ot
of
the
input
le
name.
-alignOut
leName
This
sp
ecies
the
ro
ot
name
of
the
L
A
T
E
X
alignmen
t
le
TLA
T
E
X
writes|a
le
describ
ed
in
Section
13.7
b
elo
w
on
trouble-sho
oting.
If
f
is
the
ro
ot
of
leName,
then
the
alignmen
t
le
is
named
f.tex,
and
running
L
A
T
E
X
on
it
pro
duces
the
les
f.dvi,
f.lo
g,
and
f.aux.
Only
the
f.lo
g
le
is
of
in
terest.
If

218
CHAPTER
13.
THE
TLA
T
E
X
TYPESETTER
the
alignOut
option
is
not
sp
ecied,
the
alignmen
t
le
is
giv
en
the
same
name
as
the
out
le.
This
option
is
used
only
for
trouble-sho
oting,
as
describ
ed
in
the
section
b
elo
w.
-tlaOut
leName
This
option
causes
TLA
T
E
X
to
write
to
leName
a
le
that
is
almost
the
same
as
the
input
le.
(The
extension
tla
is
added
to
leName
if
it
has
no
extension.)
The
tlaOut
le
diers
from
the
input
in
that
an
y
p
ortion
of
a
commen
t
enclosed
b
y
`^
and
^'
is
remo
v
ed,
and
ev
ery
o
ccurrence
of
the
t
w
o-c
haracter
strings
`~
~'
`.
.'
is
replaced
b
y
t
w
o
blanks.
As
explained
in
Section
13.8
b
elo
w,
the
tlaOut
option
allo
ws
y
ou
to
main
tain
a
v
ersion
of
the
sp
ecication
that
is
readable
in
asci
i
while
using
L
A
T
E
X
commands
to
pro
vide
high-qualit
y
t
yp
esetting
of
commen
ts.
The
default
is
not
to
write
a
tlaOut
le.
-style
leName
This
option
is
of
in
terest
only
to
L
A
T
E
X
users.
Normally
,
TLA
T
E
X
inserts
a
cop
y
of
the
tlatex
pac
k
age
le
in
the
L
A
T
E
X
input
les
that
it
writes.
The
style
option
causes
it
instead
to
insert
a
\usepackage
command
to
read
the
L
A
T
E
X
pac
k
age
named
leName.
(L
A
T
E
X
pac
k
age
les
ha
v
e
the
extension
sty.
That
extension
is
added
to
leName
if
it's
not
already
there.)
The
TLA
T
E
X
st
yle
denes
a
n
um
b
er
of
sp
ecial
commands
that
are
written
b
y
TLA
T
E
X
in
its
L
A
T
E
X
input
les.
The
pac
k
age
le
sp
ecied
b
y
the
style
option
m
ust
also
dene
those
commands.
An
y
pac
k
age
le
should
therefore
b
e
created
b
y
mo
difying
the
standard
tlatex
pac
k
age,
whic
h
is
the
le
tlatex.sty
in
the
same
directory
as
TLA
T
E
X's
Ja
v
a
program
les.
Y
ou
migh
t
w
an
t
to
create
a
new
pac
k
age
to
c
hange
the
w
a
y
TLA
T
E
X
formats
the
sp
ecication,
or
to
dene
additional
commands
for
use
in
`^.
.
.
^'
text
in
commen
ts.
13.7
T
rouble-Sho
oting
TLA
T
E
X's
error
messages
should
b
e
self-explanatory
.
Ho
w
ev
er,
it
calls
up
on
the
op
erating
system
up
to
three
times
to
execute
other
programs:

It
runs
L
A
T
E
X
on
the
alignOut
le
that
it
wrote.

It
runs
L
A
T
E
X
on
the
out
le
that
it
wrote.

It
ma
y
execute
the
psCommand
to
create
the
P
ostScript
or
PDF
output
le.

13.8.
USING
L
A
T
E
X
COMMANDS
219
After
eac
h
of
the
last
t
w
o
executions,
TLA
T
E
X
writes
a
message
asserting
that
the
appropriate
output
le
w
as
written.
It
migh
t
lie.
An
y
of
those
executions
migh
t
fail,
p
ossibly
causing
no
output
le
to
b
e
written.
Suc
h
a
failure
can
ev
en
cause
the
op
erating
system
nev
er
to
return
con
trol
to
TLA
T
E
X,
so
TLA
T
E
X
nev
er
terminates.
This
t
yp
e
of
failure
is
the
lik
ely
problem
if
TLA
T
E
X
do
es
not
pro
duce
a
dvi
le
or
a
P
ostScript/PDF
le,
or
if
it
nev
er
terminates.
In
that
case,
y
ou
should
try
rerunning
TLA
T
E
X
using
the
alignOut
option
to
write
a
separate
alignmen
t
le.
Reading
the
t
w
o
log
les
that
L
A
T
E
X
pro
duces,
or
an
y
error
le
pro
duced
b
y
executing
psCommand,
ma
y
shed
ligh
t
on
the
problem.
Normally
,
the
L
A
T
E
X
input
les
written
b
y
TLA
T
E
X
should
not
pro
duce
an
y
L
A
T
E
X
errors.
Ho
w
ev
er,
incorrect
L
A
T
E
X
commands
in
tro
duced
in
`^.
.
.
^'
regions
can
cause
L
A
T
E
X
to
fail.
13.8
Using
L
A
T
E
X
Commands
TLA
T
E
X
puts
an
y
text
enclosed
b
et
w
een
`^
and
^'
in
a
commen
t
in
to
the
L
A
T
E
X
input
le
exactly
as
it
app
ears.
This
allo
ws
y
ou
to
insert
L
A
T
E
X
formatting
commands
in
commen
ts.
There
are
t
w
o
w
a
ys
to
use
this.

Y
ou
can
enclose
b
et
w
een
`^
and
^'
a
short
phrase
app
earing
on
a
single
line
of
input.
L
A
T
E
X
t
yp
esets
that
phrase
as
part
of
the
enclosing
paragraph.

Y
ou
can
enclose
one
or
more
complete
lines
of
a
m
ulti-line
commen
t
b
e-
t
w
een
`^
and
^'.
That
text
is
t
yp
eset
as
one
or
more
separate
paragraphs
whose
prev
ailing
left
margin
is
determined
b
y
the
p
osition
of
the
`^,
as
sho
w
here:
Input
\***************
**
**
***
\*
The
first
paragraph.
\*
\*
The
2nd
paragraph.
\*
\*
`^
Text
formatted
\*
by
\LaTeX.
^'
\***************
**
**
*
Output
The
rst
paragraph.
The
2nd
paragraph.
T
ext
formatted
b
y
L
A
T
E
X.
L
A
T
E
X
t
yp
esets
the
text
b
et
w
een
`^
and
^'
in
LR
mo
de
for
a
one-line
com-
men
t
and
in
paragraph
mo
de
for
a
m
ulti-line
commen
t.
The
L
A
T
E
X
le
pro
duced
b
y
TLA
T
E
X
denes
a
describe
en
vironmen
t
that
is
useful
for
formatting
text
in
a
m
ulti-line
`^.
.
.
^'
region.
This
en
vironmen
t
is
the
same
as
the
standard
L
A
T
E
X
description
en
vironmen
t,
except
that
it
tak
es
an
argumen
t,
whic
h
should
b
e
the
widest
item
lab
el
in
the
en
vironmen
t:

220
CHAPTER
13.
THE
TLA
T
E
X
TYPESETTER
Input
\****************
**
**
***
**
***
\*
`^\begin{describ
e}
{gn
at
:}
\*
\item[gnat:]
Tiny
insect.
\*
\item[gnu:]
Short
word.
\*
\end{describe}
^'
\****************
**
**
***
**
**
Output
gnat:
Tin
y
insect.
gn
u:
Short
w
ord.
As
this
example
sho
ws,
putting
L
A
T
E
X
commands
in
commen
ts
mak
es
the
com-
men
ts
in
the
input
le
rather
unreadable.
Y
ou
can
main
tain
b
oth
a
t
yp
eset
and
an
asci
i-readable
v
ersion
of
the
sp
ecication
b
y
enclosing
text
that
should
app
ear
only
in
the
asci
i
v
ersion
b
et
w
een
`~
and
~'.
Y
ou
can
then
accompan
y
eac
h
`^.
.
.
^'
region
with
its
asci
i
v
ersion
enclosed
b
y
`~
and
~'.
F
or
example,
the
input
le
could
con
tain
\****************
**
**
***
**
***
**
***
**
**
\*
`^
\begin{describe
}{g
na
t:}
\*
\item[gnat:]
A
tiny
insect.
\*
\item[gnu:]
A
short
word.
\*
\end{describe}
^'
\*
`~
gnat:
A
tiny
insect.
\*
\*
gnu:
A
short
word.
~'
\****************
**
**
***
**
***
**
***
**
**
The
tlaOut
option
causes
TLA
T
E
X
to
write
a
v
ersion
of
the
original
sp
ecication
with
`^.
.
.
^'
regions
deleted,
and
with
`~
and
~'
strings
replaced
b
y
spaces.
(The
strings
`.
and
.'
are
also
replaced
b
y
spaces.)
In
the
example
ab
o
v
e,
the
tlaOut
le
w
ould
con
tain
the
commen
t
\****************
**
**
***
**
***
**
***
**
**
\*
\*
gnat:
A
tiny
insect.
\*
\*
gnu:
A
short
word.
\****************
**
**
***
**
***
**
***
**
**
The
blank
line
at
the
top
w
as
pro
duced
b
y
the
end-of-line
c
haracter
that
follo
ws
the
^'.
W
arning:
An
error
in
a
L
A
T
E
X
command
inside
`^.
.
.
^'
text
can
cause
TLA
T
E
X
not
to
pro
duce
an
y
output.
See
Section
13.7
ab
o
v
e
on
trouble-sho
oting.

Chapter
14
The
TLC
Mo
del
Chec
k
er
TLC
is
a
program
for
nding
errors
in
TLA
+
sp
ecications.
It
w
as
designed
and
implemen
ted
b
y
Y
uan
Y
u,
with
help
from
Leslie
Lamp
ort,
Mark
Ha
yden,
and
Mark
T
uttle.
It
is
a
v
ailable
through
the
TLA
W
eb
page.
This
c
hapter
describ
es
TLC
V
ersion
2.
A
t
the
time
I
am
writing
this,
V
ersion
2
is
still
b
eing
implemen
ted
and
only
V
ersion
1
is
a
v
ailable.
Consult
the
do
cumen
tation
that
accompanies
the
soft
w
are
to
nd
out
what
v
ersion
it
is
and
ho
w
it
diers
from
the
v
ersion
describ
ed
here.
14.1
In
tro
duction
to
TLC
TLC
handles
sp
ecications
that
ha
v
e
the
standard
form
Init
^
2[Next
]
vars
^
T
emp
or
al
(14.1)
where
Init
is
the
initial
predicate,
Next
is
the
next-state
action,
vars
is
the
tu-
ple
of
all
v
ariables,
and
T
emp
or
al
is
a
temp
oral
form
ula
that
usually
sp
ecies
a
liv
eness
condition.
Liv
eness
and
temp
oral
form
ulas
are
explained
in
Chap-
ter
8.
If
y
our
sp
ecication
con
tains
no
T
emp
or
al
form
ula,
so
it
has
the
form
Init
^
2[Next
]
vars
,
then
y
ou
can
ignore
the
discussion
of
temp
oral
c
hec
king.
TLC
do
es
not
handle
the
hiding
op
erator
9
9
9
9
9
9
(temp
oral
existen
tial
quan
tica-
tion).
Y
ou
can
c
hec
k
a
sp
ecication
with
hidden
v
ariables
b
y
c
hec
king
the
in-
ternal
sp
ecication,
in
whic
h
those
v
ariables
are
visible.
The
most
eectiv
e
w
a
y
to
nd
errors
in
a
sp
ecication
is
b
y
trying
to
v
erify
that
it
satises
prop
erties
that
it
should.
TLC
can
c
hec
k
that
the
sp
ecication
satises
(implies)
a
large
class
of
TLA
form
ulas|a
class
whose
main
restriction
is
that
form
ulas
ma
y
not
con
tain
9
9
9
9
9
9
.
Y
ou
can
also
run
TLC
without
ha
ving
it
c
hec
k
an
y
prop
ert
y
,
in
whic
h
case
it
will
just
lo
ok
for
t
w
o
kinds
of
errors:
221

222
CHAPTER
14.
THE
TLC
MODEL
CHECKER

\Silliness"
errors.
As
explained
in
Section
6.2,
a
silly
expression
is
one
lik
e
3
+
h
1;
2
i,
whose
meaning
is
not
determined
b
y
the
seman
tics
of
TLA
+
.
A
sp
ecication
is
incorrect
if
whether
or
not
some
particular
b
eha
vior
satises
it
dep
ends
on
the
meaning
of
a
silly
expression.

Deadlo
c
k.
The
absence
of
deadlo
c
k
is
a
particular
prop
ert
y
that
w
e
often
w
an
t
a
sp
ecication
to
satisfy;
it
is
expressed
b
y
the
in
v
ariance
prop
ert
y
2(enabled
Next
).
A
coun
terexample
to
this
prop
ert
y
is
a
b
eha
vior
ex-
hibiting
deadlo
c
k|that
is,
reac
hing
a
state
in
whic
h
Next
is
not
enabled,
so
no
further
(nonstuttering)
step
is
p
ossible.
TLC
normally
c
hec
ks
for
deadlo
c
k,
but
this
c
hec
king
can
b
e
disabled
since,
for
some
systems,
dead-
lo
c
k
ma
y
just
indicate
successful
termination.
The
use
of
TLC
will
b
e
illustrated
with
a
simple
example|a
sp
ecication
of
the
alternating
bit
proto
col
for
sending
data
o
v
er
a
lossy
FIF
O
transmission
line.
An
algorithm
designer
migh
t
describ
e
the
proto
col
as
a
system
that
lo
oks
lik
e
this:
Sender
sent
sBit
sA
ck
Receiv
er
r
cvd
rBit
msgQ
-
ackQ

The
sender
can
send
a
v
alue
when
the
one-bit
v
alues
sBit
and
sA
ck
are
equal.
It
sets
the
v
ariables
sent
to
the
v
alue
it
is
sending
and
complemen
ts
sBit
.
This
v
alue
is
ev
en
tually
deliv
ered
to
the
receiv
er
b
y
setting
the
v
ariable
r
cvd
and
complemen
ting
the
one-bit
v
alue
rBit
.
Some
time
later,
the
sender's
sA
ck
v
alue
is
complemen
ted,
p
ermitting
the
next
v
alue
to
b
e
sen
t.
The
proto
col
uses
t
w
o
lossy
FIF
O
transmission
lines:
the
sender
sends
data
and
con
trol
information
on
msgQ
,
and
the
receiv
er
sends
ac
kno
wledgmen
ts
on
ackQ
.
The
complete
proto
col
sp
ecication
app
ears
in
mo
dule
A
lternatingBit
in
Figure
14.1
on
the
follo
wing
t
w
o
pages.
It
is
fairly
straigh
tforw
ard,
except
for
the
liv
eness
condition.
Because
messages
can
b
e
rep
eatedly
lost
from
the
queues,
strong
fairness
of
the
actions
that
receiv
e
messages
is
required
to
ensure
that
a
message
that
k
eeps
getting
resen
t
is
ev
en
tually
receiv
ed.
Ho
w
ev
er,
don't
w
orry
ab
out
the
details
of
the
sp
ecication.
F
or
no
w,
all
y
ou
need
to
kno
w
are
the
declarations
const
ant
Data
The
set
of
data
v
alues
that
can
b
e
sen
t.
v
ariables
msgQ
;
ackQ
;
sBit
;
sA
ck
;
rBit
;
sent
;
r
cvd
and
the
t
yp
es
of
the
v
ariables:

14.1.
INTR
ODUCTION
TO
TLC
223
module
A
lternatingBit
This
sp
ecication
describ
es
a
proto
col
for
using
lossy
FIF
O
transmission
lines
to
transmit
a
sequence
of
v
alues
from
a
sender
to
a
receiv
er.
The
sender
sends
a
data
v
alue
d
b
y
sending
a
sequence
of
h
b
;
d
i
messages
on
msgQ
,
where
b
is
a
con
trol
bit.
It
kno
ws
that
the
message
has
b
een
receiv
ed
when
it
re-
ceiv
es
the
ac
k
b
from
the
receiv
er
on
ackQ
.
It
sends
the
next
v
alue
with
a
dieren
t
con
trol
bit.
The
receiv
er
kno
ws
that
a
message
on
msgQ
con
tains
a
new
v
alue
when
the
con
trol
bit
diers
from
the
last
one
it
has
receiv
ed.
The
receiv
er
k
eeps
sending
the
last
con
trol
bit
it
receiv
ed
on
ackQ
.
extends
Natur
als,
Se
quenc
es
const
ants
Data
The
set
of
data
v
alues
that
can
b
e
sen
t.
v
ariables
msg
Q;
The
sequence
of
h
con
trol
bit,
data
v
alue
i
messages
in
transit
to
the
receiv
er.
ack
Q;
The
sequence
of
one-bit
ac
kno
wledgmen
ts
in
transit
to
the
sender.
sB
it;
The
last
con
trol
bit
sen
t
b
y
sender;
it
is
complemen
ted
when
sending
a
new
data
v
alue.
sAck
;
The
last
ac
kno
wledgmen
t
bit
receiv
ed
b
y
the
sender.
r
B
it;
The
last
con
trol
bit
receiv
ed
b
y
the
receiv
er.
sent;
The
last
v
alue
sen
t
b
y
the
sender.
r
cv
d
The
last
v
alue
receiv
ed
b
y
the
receiv
er.
ABInit

=
^
msgQ
=
h
i
^
ackQ
=
h
i
^
sBit
2
f0;
1g
^
sA
ck
=
sBit
^
rBit
=
sBit
^
sent
2
Data
^
r
cvd
2
Data
The
initial
condition:
Both
message
queues
are
empt
y
.
All
the
bits
equal
0
or
1
and
are
equal
to
eac
h
other.
The
initial
v
alues
of
sent
and
r
cvd
are
arbitrary
data
v
alues.
ABT
yp
eInv

=
^
msgQ
2
Se
q
(f0;
1g

Data
)
^
ackQ
2
Se
q
(f0;
1g)
^
sBit
2
f0;
1g
^
sA
ck
2
f0;
1g
^
rBit
2
f0;
1g
^
sent
2
Data
^
r
cvd
2
Data
The
t
yp
e-correctness
in
v
arian
t.
SndNewV
alue
(d
)

=
The
action
in
whic
h
the
sender
sends
a
new
data
v
alue
d
.
^
sA
ck
=
sBit
^
sent
0
=
d
^
sBit
0
=
1
 sBit
^
msgQ
0
=
App
end
(msgQ
;
h
sBit
0
;
d
i)
^
unchanged
h
ackQ
;
sA
ck
;
rBit
;
r
cvd
i
Enabled
i
sA
ck
equals
sBit
.
Set
sent
to
d
.
Complemen
t
con
trol
bit
sBit
Send
v
alue
on
msgQ
with
new
con
trol
bit.
Figure
14.1a:
The
alternating
bit
proto
col
(b
eginning).

224
CHAPTER
14.
THE
TLC
MODEL
CHECKER
R
eSndMsg

=
The
sender
resends
the
last
message
it
sen
t
on
msgQ
.
^
sA
ck
6=
sBit
^
msgQ
0
=
App
end
(msgQ
;
h
sBit
;
sent
i)
^
unchanged
h
ackQ
;
sBit
;
sA
ck
;
rBit
;
sent
;
r
cvd
i
Enabled
i
sA
ck
do
esn't
equal
sBit
.
Resend
the
last
v
alue
in
send
.
R
cvMsg

=
The
receiv
er
receiv
es
the
message
at
the
head
of
msgQ
.
^
msgQ
6=
h
i
^
msgQ
0
=
T
ail
(msgQ
)
^
rBit
0
=
He
ad
(msgQ
)[1]
^
r
cvd
0
=
He
ad
(msgQ
)[2]
Enabled
i
msgQ
not
empt
y
.
Remo
v
e
message
from
head
of
msgQ
.
Set
rBit
to
message's
con
trol
bit.
Set
r
cvd
to
message's
data
v
alue.
^
unchanged
h
ackQ
;
sBit
;
sA
ck
;
sent
i
SndA
ck

=
^
ackQ
0
=
App
end
(ackQ
;
rBit
)
The
receiv
er
sends
rBit
on
ackQ
at
an
y
time.
^
unchanged
h
msgQ
;
sBit
;
sA
ck
;
rBit
;
sent
;
r
cvd
i
R
cvA
ck

=
^
ackQ
6=
h
i
The
sender
receiv
es
an
ac
k
on
ackQ
.
It
remo
v
es
the
ac
k
and
sets
sA
ck
to
its
v
alue.
^
ackQ
0
=
T
ail
(ackQ
)
^
sA
ck
0
=
He
ad
(ackQ
)
^
unchanged
h
msgQ
;
sBit
;
rBit
;
sent
;
r
cvd
i
L
ose
(q
)

=
The
action
of
losing
a
message
from
queue
q
.
^
q
6=
h
i
^
9
i
2
1
:
:
L
en
(q
)
:
q
0
=
[j
2
1
:
:
(L
en
(q
)
 1)
7!
if
j
<
i
then
q
[j
]
else
q
[j
+
1]]
^
unchanged
h
sBit
;
sA
ck
;
rBit
;
sent
;
r
cvd
i
Enabled
i
q
is
not
empt
y
.
F
or
some
i
,
remo
v
e
the
i
th
message
from
q
.
Lea
v
e
ev
ery
v
ariable
unc
hanged
except
msgQ
and
ackQ
.
L
oseMsg

=
L
ose
(msgQ
)
^
unchanged
ackQ
Lose
a
message
from
msgQ
.
L
oseA
ck

=
L
ose
(ackQ
)
^
unchanged
msgQ
Lose
a
message
from
ackQ
.
ABNext

=
_
9
d
2
Data
:
SndNewV
alue
(d
)
_
R
eSndMsg
_
R
cvMsg
_
SndA
ck
_
R
cvA
ck
_
L
oseMsg
_
L
oseA
ck
The
next-state
action.
abvars

=
h
msgQ
;
ackQ
;
sBit
;
sA
ck
;
rBit
;
sent
;
r
cvd
i
The
tuple
of
all
v
ariables.
ABF
airness

=
^
WF
abvars
(R
eSndMsg
)
^
WF
abvars
(SndA
ck
)
^
SF
abvars
(R
cvMsg
)
^
SF
abvars
(R
cvA
ck
)
The
liv
eness
condition.
ABSp
e
c

=
ABInit
^
2[ABNext
]
abvars
^
ABF
airness
The
complete
sp
ecication.
theorem
ABSp
e
c
)
2ABT
yp
eInv
Figure
14.1b:
The
alternating
bit
proto
col
(end).

14.1.
INTR
ODUCTION
TO
TLC
225

msgQ
is
a
sequence
of
elemen
ts
in
f0;
1g

Data
.

ackQ
is
a
sequence
of
elemen
ts
in
f0;
1g.

sBit
,
sA
ck
,
and
rBit
are
elemen
ts
of
f0;
1g.

sent
and
r
cvd
are
elemen
ts
of
Data
.
The
input
to
TLC
consists
of
a
TLA
+
mo
dule
and
a
conguration
le.
TLC
assumes
the
sp
ecication
has
the
form
of
form
ula
(14.1)
on
page
221.
The
conguration
le
tells
TLC
the
names
of
the
sp
ecication
and
of
the
prop
erties
to
b
e
c
hec
k
ed.
F
or
example,
the
conguration
le
for
the
alternating
bit
proto
col
will
con
tain
the
declaration
SPECIFICATION
ABSpec
telling
TLC
to
tak
e
ABSp
e
c
as
the
sp
ecication.
If
y
our
sp
ecication
has
the
form
Init
^
2[Next
]
vars
,
with
no
liv
eness
condition,
then
instead
of
using
a
SPECIFICATION
statemen
t,
y
ou
can
declare
the
initial
predicate
and
next-state
action
b
y
putting
the
follo
wing
t
w
o
statemen
ts
in
the
conguration
le:
INIT
Init
NEXT
Next
The
prop
ert
y
or
prop
erties
to
b
e
c
hec
k
ed
are
sp
ecied
with
a
PROPERTY
state-
men
t.
F
or
example,
to
c
hec
k
that
ABT
yp
eInv
is
actually
an
in
v
arian
t,
w
e
could
ha
v
e
TLC
c
hec
k
that
the
sp
ecication
implies
2ABT
yp
eInv
b
y
adding
the
de-
nition
InvPr
op
erty

=
2ABT
yp
eInv
to
mo
dule
A
lternatingBit
and
putting
the
statemen
t
PROPERTY
InvProperty
in
the
conguration
le.
In
v
ariance
c
hec
king
is
so
common
that
TLC
allo
ws
y
ou
instead
to
put
the
follo
wing
statemen
t
in
the
conguration
le:
INVARIANT
ABTypeInv
The
INVARIANT
statemen
t
m
ust
sp
ecify
a
state
predicate.
T
o
c
hec
k
in
v
ariance
with
a
PROPERTY
statemen
t,
the
sp
ecied
prop
ert
y
has
to
b
e
of
the
form
2P
.
Sp
ecifying
a
state
predicate
P
in
a
PROPERTY
statemen
t
tells
TLC
to
c
hec
k
that
the
sp
ecication
implies
P
,
meaning
that
P
is
true
in
the
initial
state
of
ev
ery
b
eha
vior
satisfying
the
sp
ecication.
TLC
w
orks
b
y
generating
b
eha
viors
that
satisfy
the
sp
ecication.
T
o
do
this,
it
m
ust
b
e
giv
en
what
w
e
call
a
mo
del
of
the
sp
ecication.
T
o
dene
a
mo
del,
w
e
m
ust
assign
v
alues
to
the
sp
ecication's
constan
t
parameters.
The
only
constan
t
parameter
of
the
alternating
bit
proto
col
sp
ecication
is
the
set

226
CHAPTER
14.
THE
TLC
MODEL
CHECKER
Data
of
data
v
alues.
W
e
can
tell
TLC
to
let
Data
equal
the
set
con
taining
t
w
o
arbitrary
elemen
ts,
named
d
1
and
d
2,
b
y
putting
the
follo
wing
declaration
in
the
conguration
le:
The
k
eyw
ords
CONSTANT
and
CONSTANTS
are
equiv
alen
t,
as
are
INVARIANT
and
INVARIANTS.
CONSTANT
Data
=
{d1,
d2}
(W
e
can
use
an
y
sequence
of
letters
and
digits
con
taining
at
least
one
letter
as
the
name
of
an
elemen
t.)
There
are
t
w
o
w
a
ys
to
use
TLC.
The
default
metho
d
is
mo
del
che
cking,
in
whic
h
it
tries
to
nd
all
reac
hable
states|that
is,
all
states
1
that
can
o
ccur
in
b
eha
viors
satisfying
the
form
ula
Init
^
2[Next
]
vars
.
Y
ou
can
also
run
TLC
in
simulation
mo
de,
in
whic
h
it
randomly
generates
b
eha
viors,
without
trying
to
c
hec
k
all
reac
hable
states.
W
e
no
w
consider
mo
del
c
hec
king;
sim
ulation
mo
de
is
describ
ed
in
Section
14.3.2
on
page
243.
Exhaustiv
ely
c
hec
king
all
reac
hable
states
is
imp
ossible
for
the
alternating
bit
proto
col
b
ecause
the
sequences
of
messages
can
get
arbitrarily
long,
so
there
are
innitely
man
y
reac
hable
states.
W
e
m
ust
further
constrain
the
mo
del
to
mak
e
it
nite|that
is,
so
it
allo
ws
only
a
nite
n
um
b
er
of
p
ossible
states.
W
e
do
this
b
y
dening
a
state
predicate
called
the
c
onstr
aint
that
asserts
b
ounds
Section
14.3
b
e-
lo
w
describ
es
ho
w
actions
as
w
ell
as
state
predicates
can
b
e
used
as
constrain
ts.
on
the
lengths
of
the
sequences.
F
or
example,
the
follo
wing
constrain
t
asserts
that
msgQ
and
ackQ
ha
v
e
length
at
most
2:
^
L
en
(msgQ
)

2
^
L
en
(ackQ
)

2
Instead
of
sp
ecifying
the
b
ounds
on
the
lengths
of
sequences
in
this
w
a
y
,
I
prefer
to
mak
e
them
parameters
and
to
assign
them
v
alues
in
the
conguration
le.
W
e
don't
w
an
t
to
put
in
to
the
sp
ecication
itself
declarations
and
denitions
that
are
just
for
TLC's
b
enet.
So,
w
e
write
a
new
mo
dule,
called
MCA
lternatingBit
,
that
extends
the
A
lternatingBit
mo
dule
and
can
b
e
used
as
input
to
TLC.
This
mo
dule
app
ears
in
Figure
14.2
on
the
next
page.
A
p
ossible
conguration
le
for
the
mo
dule
app
ears
in
Figure
14.3
on
the
next
page.
Observ
e
that
the
conguration
le
m
ust
sp
ecify
v
alues
for
all
the
constan
t
parameters
of
the
sp
ecication|in
this
case,
the
parameter
Data
from
the
A
lternatingBit
mo
d-
ule
and
the
t
w
o
parameters
declared
in
mo
dule
MCA
lternatingBit
itself.
Y
ou
can
put
commen
ts
in
the
conguration
le,
using
the
TLA
+
commen
t
syn
tax
describ
ed
in
Section
3.5
(page
32).
When
a
constrain
t
Constr
is
sp
ecied,
TLC
c
hec
ks
ev
ery
state
that
app
ears
in
a
b
eha
vior
satisfying
Init
^
2[Next
]
vars
^
2Constr
.
In
the
rest
of
this
c
hapter,
these
states
will
b
e
called
the
r
e
achable
ones.
1
As
explained
in
Section
2.3
(page
18),
a
state
is
an
assignmen
t
of
v
alues
to
all
p
ossible
v
ariables.
Ho
w
ev
er,
when
discussing
a
particular
sp
ecication,
w
e
usually
consider
a
state
to
b
e
an
assignmen
t
of
v
alues
to
that
sp
ecication's
v
ariables.
That's
what
I'm
doing
in
this
c
hapter.

14.1.
INTR
ODUCTION
TO
TLC
227
module
MCA
lternatingBit
extends
A
lternatingBit
const
ants
msgQL
en,
ackQL
en
Se
qConstr
aint

=
^
L
en
(msgQ
)

msgQL
en
^
L
en
(ackQ
)

ackQL
en
A
constrain
t
on
the
lengths
of
sequences
for
use
b
y
TLC.
Figure
14.2:
Mo
dule
MCA
lternatingBit.
Ha
ving
TLC
c
hec
k
the
t
yp
e
in
v
arian
t
will
catc
h
man
y
simple
mistak
es.
When
w
e'v
e
corrected
all
the
errors
w
e
can
nd
that
w
a
y
,
w
e
then
w
an
t
to
lo
ok
for
less
ob
vious
ones.
A
common
error
is
for
an
action
not
to
b
e
enabled
when
it
should
b
e,
prev
en
ting
some
states
from
b
eing
reac
hed.
Y
ou
can
disco
v
er
if
an
action
is
nev
er
enabled
b
y
using
the
c
over
age
option,
describ
ed
on
page
252.
T
o
disco
v
er
if
an
action
is
just
sometimes
incorrectly
disabled,
try
c
hec
king
liv
eness
prop
erties.
An
ob
vious
liv
eness
prop
ert
y
for
the
alternating
bit
proto
col
is
that
ev
ery
message
sen
t
is
ev
en
tually
deliv
ered.
A
message
d
has
b
een
sen
t
when
sent
=
d
and
sBit
6=
sA
ck
.
So,
a
naiv
e
w
a
y
to
state
this
prop
ert
y
is
The
temp
oral
op-
erator
;
is
de-
ned
on
page
91.
SentL
e
adsT
oR
cvd

=
8
d
2
Data
:
(sent
=
d
)
^
(sBit
6=
sA
ck
)
;
(r
cvd
=
d
)
F
orm
ula
SentL
e
adsT
oR
cvd
asserts
that,
for
an
y
data
v
alue
d
,
if
sent
ev
er
equals
d
when
sBit
do
es
not
equal
sA
ck
,
then
r
cvd
m
ust
ev
en
tually
equal
d
.
This
do
esn't
assert
that
ev
ery
message
sen
t
is
ev
en
tually
deliv
ered.
F
or
example,
it
is
satised
b
y
a
b
eha
vior
in
whic
h
a
particular
v
alue
d
is
sen
t
t
wice,
but
receiv
ed
only
once.
Ho
w
ev
er,
the
form
ula
is
go
o
d
enough
for
our
purp
oses
b
ecause
the
proto
col
do
esn't
dep
end
on
the
actual
v
alues
b
eing
sen
t.
If
it
w
ere
p
ossible
for
the
same
v
alue
to
b
e
sen
t
t
wice
but
receiv
ed
only
once,
then
it
w
ould
b
e
p
ossible
for
t
w
o
dieren
t
v
alues
to
b
e
sen
t
and
only
one
receiv
ed,
violating
SentL
e
adsT
oR
cvd
.
W
e
therefore
add
the
denition
of
SentL
e
adsT
oR
cvd
to
mo
dule
MCA
lternatingBit
and
add
the
follo
wing
statemen
t
to
the
conguration
le:
PROPERTY
SentLeadsToRcvd
CONSTANTS
Data
=
{d1,
d2}
(*
Is
this
big
enough?
*)
msgQLen
=
2
ackQLen
=
2
\*
Try
3
next.
SPECIFICATION
ABSpec
INVARIANT
ABTypeInv
CONSTRAINT
SeqConstraint
Figure
14.3:
A
conguration
le
for
mo
dule
MCA
lternatingBit.

228
CHAPTER
14.
THE
TLC
MODEL
CHECKER
Chec
king
liv
eness
prop
erties
is
a
lot
slo
w
er
than
other
kinds
of
c
hec
king,
so
y
ou
should
do
it
only
after
y
ou'v
e
found
all
the
errors
y
ou
can
b
y
c
hec
king
in
v
ariance
prop
erties.
Chec
king
t
yp
e
correctness
and
prop
ert
y
SentL
e
adsT
oR
cvd
is
a
go
o
d
w
a
y
to
start
lo
oking
for
errors.
But
ultimately
,
w
e
w
ould
lik
e
to
see
if
the
proto
col
meets
its
sp
ecication.
Ho
w
ev
er,
w
e
don't
ha
v
e
its
sp
ecication.
In
fact,
it
is
t
ypical
in
practice
that
w
e
are
called
up
on
to
c
hec
k
the
correctness
of
a
system
design
without
an
y
formal
sp
ecication
of
what
the
system
is
supp
osed
to
do.
In
that
case,
w
e
can
write
an
ex
p
ost
facto
sp
ecication.
Mo
dule
ABCorr
e
ctness
in
Figure
14.4
on
the
next
page
is
suc
h
a
sp
ecication
of
correctness
for
the
alternating
bit
proto
col.
It
is
actually
a
simplied
v
ersion
of
the
proto
col's
sp
ecication
in
whic
h,
instead
of
b
eing
read
from
messages,
the
v
ariables
r
cvd
,
rBit
,
and
sA
ck
are
obtained
directly
from
the
v
ariables
of
the
other
pro
cess.
W
e
w
an
t
to
c
hec
k
that
the
sp
ecication
ABSp
e
c
of
mo
dule
A
lternatingBit
implies
form
ula
ABCSp
e
c
of
mo
dule
ABCorr
e
ctness
.
T
o
do
this,
w
e
mo
dify
mo
dule
MCA
lternatingBit
b
y
adding
the
statemen
t
inst
ance
ABCorr
e
ctness
and
w
e
mo
dify
the
PROPERTY
statemen
t
of
the
conguration
le
to
The
k
eyw
ords
PROPERTY
and
PROPERTIES
are
equiv
alen
t.
PROPERTIES
ABCSpec
SentLeadsToRcvd
This
example
is
at
ypical
b
ecause
the
correctness
sp
ecication
ABCSp
e
c
do
es
not
in
v
olv
e
v
ariable
hiding
(temp
oral
existen
tial
quan
tication).
Let's
no
w
sup-
p
ose
mo
dule
ABCorr
e
ctness
did
declare
another
v
ariable
h
that
app
eared
in
ABCSp
e
c
,
and
that
the
correctness
condition
for
the
alternating
bit
proto
col
w
as
ABCSp
e
c
with
h
hidden.
The
correctness
condition
w
ould
then
b
e
expressed
formally
in
TLA
+
as
follo
ws:
This
use
of
inst
ance
is
ex-
plained
in
Sec-
tion
4.3
(page
41).
AB
(h
)

=
inst
ance
ABCorr
e
ctness
theorem
ABSp
e
c
)
9
9
9
9
9
9
h
:
AB
(h
)
!
ABCSp
e
c
TLC
could
not
c
hec
k
this
theorem
directly
b
ecause
it
cannot
handle
the
temp
oral
existen
tial
quan
tier
9
9
9
9
9
9
.
W
e
w
ould
c
hec
k
this
theorem
with
TLC
the
same
w
a
y
w
e
w
ould
try
to
pro
v
e
it|namely
,
b
y
using
a
renemen
t
mapping.
As
explained
in
Section
5.8
on
page
62,
w
e
w
ould
dene
a
state
function
oh
in
terms
of
the
v
ariables
of
mo
dule
A
lternatingBit
and
w
e
w
ould
pro
v
e
ABSp
e
c
)
AB
(oh
)
!
ABCSp
e
c
(14.2)
T
o
get
TLC
to
c
hec
k
this
theorem,
w
e
w
ould
add
the
denition
ABCSp
e
cBar

=
AB
(oh
)
!
ABCSp
e
c
and
ha
v
e
TLC
c
hec
k
the
prop
ert
y
ABCSp
e
cBar
.

14.1.
INTR
ODUCTION
TO
TLC
229
module
ABCorr
e
ctness
extends
Natur
als
const
ants
Data
v
ariables
sBit
;
sA
ck
;
rBit
;
sent
;
r
cvd
ABCInit

=
^
sBit
2
f0;
1g
^
sA
ck
=
sBit
^
rBit
=
sBit
^
sent
2
Data
^
r
cvd
2
Data
CSndNewV
alue
(d
)

=
^
sA
ck
=
sBit
^
sent
0
=
d
^
sBit
0
=
1
 sBit
^
unchanged
h
sA
ck
;
rBit
;
r
cvd
i
CR
cvMsg

=
^
rBit
6=
sBit
^
rBit
0
=
sBit
^
r
cvd
0
=
sent
^
unchanged
h
sBit
;
sA
ck
;
sent
i
CR
cvA
ck

=
^
rBit
6=
sA
ck
^
sA
ck
0
=
rBit
^
unchanged
h
sBit
;
rBit
;
sent
;
r
cvd
i
ABCNext

=
_
9
d
2
Data
:
CSndNewV
alue
(d
)
_
CR
cvMsg
_
CR
cvA
ck
cvars

=
h
sBit
;
sA
ck
;
rBit
;
sent
;
r
cvd
i
ABCF
airness

=
WF
cvars
(CR
cvMsg
)
^
WF
cvars
(CR
cvA
ck
)
ABCSp
e
c

=
ABCInit
^
2[ABCNext
]
cvars
^
ABCF
airness
Figure
14.4:
A
sp
ecication
of
correctness
of
the
alternating
bit
proto
col.
When
TLC
c
hec
ks
a
prop
ert
y
,
it
do
es
not
actually
v
erify
that
the
sp
ecication
implies
the
prop
ert
y
.
Instead,
it
c
hec
ks
that
(i)
the
safet
y
part
of
the
sp
ecication
implies
the
safet
y
part
of
the
prop
ert
y
and
(ii)
the
sp
ecication
implies
the
liv
eness
part
of
the
prop
ert
y
.
F
or
example,
supp
ose
that
the
sp
ecication
Sp
e
c
and
the
prop
ert
y
Pr
op
are
Sp
e
c

=
Init
^
2[Next
]
vars
^
T
emp
or
al
Pr
op

=
Implie
dInit
^
2[Implie
dA
ction
]
pvars
^
Implie
dT
emp
or
al

230
CHAPTER
14.
THE
TLC
MODEL
CHECKER
where
T
emp
or
al
and
Implie
dT
emp
or
al
are
liv
eness
prop
erties.
In
this
case,
TLC
c
hec
ks
the
t
w
o
form
ulas
Init
^
2[Next
]
vars
)
Implie
dInit
^
2[Implie
dA
ction
]
pvars
Sp
e
c
)
Implie
dT
emp
or
al
This
means
that
y
ou
cannot
use
TLC
to
c
hec
k
that
a
non-mac
hine-closed
sp
eci-
cation
satises
a
safet
y
prop
ert
y
.
(Mac
hine
closure
is
discussed
in
Section
8.9.2
on
page
111.)
Section
14.3
b
elo
w
more
precisely
describ
es
ho
w
TLC
c
hec
ks
prop
erties.
14.2
What
TLC
Can
Cop
e
With
No
mo
del
c
hec
k
er
can
handle
all
the
sp
ecications
that
w
e
can
write
in
a
lan-
guage
as
expressiv
e
as
TLA
+
.
Ho
w
ev
er,
TLC
seems
able
to
handle
most
TLA
+
sp
ecications
that
p
eople
actually
write.
Getting
TLC
to
handle
a
sp
ecication
ma
y
require
a
bit
of
tric
k
ery
,
but
it
can
usually
b
e
done
without
ha
ving
to
mak
e
an
y
c
hanges
to
the
sp
ecication
itself.
This
section
explains
what
TLC
can
and
cannot
cop
e
with,
and
giv
es
some
w
a
ys
to
mak
e
it
cop
e.
The
b
est
w
a
y
to
understand
TLC's
limitations
is
to
understand
ho
w
it
w
orks.
So,
this
section
describ
es
ho
w
TLC
\executes"
a
sp
ecication.
14.2.1
TLC
V
alues
A
state
is
an
assignmen
t
of
v
alues
to
v
ariables.
TLA
+
allo
ws
y
ou
to
describ
e
a
wide
v
ariet
y
of
v
alues|for
example,
the
set
of
all
sequences
of
prime
n
um
b
ers.
TLC
can
compute
only
a
restricted
class
of
v
alues,
called
TLC
v
alues.
Those
v
alues
are
built
from
the
follo
wing
four
t
yp
es
of
primitiv
e
v
alues:
Bo
ole
ans
The
v
alues
tr
ue
and
f
alse.
Inte
gers
V
alues
lik
e
3
and
 1.
Strings
V
alues
lik
e
\ab3"
.
Mo
del
V
alues
These
are
v
alues
in
tro
duced
in
the
CONSTANT
statemen
t
of
the
conguration
le.
F
or
example,
the
conguration
le
sho
wn
in
Figure
14.3
on
page
227
in
tro
duces
the
mo
del
v
alues
d1
and
d2.
Mo
del
v
alues
with
dieren
t
names
are
assumed
to
b
e
dieren
t.
A
TLC
v
alue
is
dened
inductiv
ely
to
b
e
either
1.
a
primitiv
e
v
alue,
or

14.2.
WHA
T
TLC
CAN
COPE
WITH
231
2.
a
nite
set
of
comparable
TLC
v
alues
(c
omp
ar
able
is
dened
b
elo
w),
or
3.
a
function
f
whose
domain
is
a
TLC
v
alue
suc
h
that
f
[x
]
is
a
TLC
v
alue,
for
all
x
in
domain
f
.
F
or
example,
the
rst
t
w
o
rules
imply
that
ff\a"
;
\b"
g;
f\b"
;
\c"
g;
f\c"
;
\d"
gg
(14.3)
is
a
TLC
v
alue
b
ecause
rules
1
and
2
imply
that
f\a"
;
\b"
g
,
f\b"
;
\c"
g
,
and
f\c"
;
\d"
g
are
TLC
v
alues,
and
the
second
rule
then
implies
that
(14.3)
is
a
TLC
v
alue.
Since
tuples
and
records
are
functions,
rule
3
implies
that
a
record
or
tuple
whose
comp
onen
ts
are
TLC
v
alues
is
a
TLC
v
alue.
F
or
example,
h
1;
\a"
;
2;
\b"
i
is
a
TLC
v
alue.
T
o
complete
the
denition
of
what
a
TLC
v
alue
is,
I
m
ust
explain
what
c
omp
ar
able
means
in
rule
2.
The
basic
idea
is
that
t
w
o
v
alues
should
b
e
com-
parable
i
the
seman
tics
of
TLA
+
determines
whether
or
not
they
are
equal.
F
or
example,
strings
and
n
um
b
ers
are
not
comparable
b
ecause
the
seman
tics
of
TLA
+
do
esn't
tell
us
whether
or
not
\ab
c"
equals
42.
The
set
f\ab
c"
;
42g
is
therefore
not
a
TLC
v
alue;
rule
2
do
esn't
apply
b
ecause
\ab
c"
and
42
are
not
comparable.
On
the
other
hand,
f\ab
c"
g
and
f4;
2g
are
comparable
b
ecause
sets
ha
ving
dieren
t
n
um
b
ers
of
elemen
ts
m
ust
b
e
unequal.
Hence,
the
t
w
o-elemen
t
set
ff\ab
c"
g;
f4;
2gg
is
a
TLC
v
alue.
TLC
considers
a
mo
del
v
alue
to
b
e
com-
parable
to,
and
unequal
to,
an
y
other
v
alue.
The
precise
rules
for
comparabilit
y
are
giv
en
in
Section
14.7.2.
14.2.2
Ho
w
TLC
Ev
aluates
Expressions
Chec
king
a
sp
ecication
requires
ev
aluating
expressions.
F
or
example,
TLC
do
es
in
v
ariance
c
hec
king
b
y
ev
aluating
the
in
v
arian
t
in
eac
h
reac
hable
state|that
is,
computing
its
TLC
v
alue,
whic
h
should
b
e
tr
ue
.
T
o
understand
what
TLC
can
and
cannot
do,
y
ou
ha
v
e
to
kno
w
ho
w
it
ev
aluates
expressions.
TLC
ev
aluates
expressions
in
a
straigh
tforw
ard
w
a
y
,
generally
ev
aluating
sub
expressions
\from
left
to
righ
t".
In
particular:

It
ev
aluates
p
^
q
b
y
rst
ev
aluating
p
and,
if
it
equals
tr
ue,
then
ev
alu-
ating
q
.

It
ev
aluates
p
_
q
b
y
rst
ev
aluating
p
and,
if
it
equals
f
alse,
then
ev
alu-
ating
q
.
It
ev
aluates
p
)
q
as
:p
_
q
.

It
ev
aluates
if
p
then
e
1
else
e
2
b
y
rst
ev
aluating
p
,
then
ev
aluating
either
e
1
or
e
2
.
T
o
understand
the
signicance
of
these
rules,
let's
consider
a
simple
example.
TLC
cannot
ev
aluate
the
expression
x
[1]
if
x
equals
h
i,
since
h
i[1]
is
silly
.
(The

232
CHAPTER
14.
THE
TLC
MODEL
CHECKER
empt
y
sequence
h
i
is
a
function
whose
domain
is
the
empt
y
set
and
hence
do
es
not
con
tain
1.)
The
rst
rule
implies
that,
if
x
equals
h
i,
then
TLC
can
ev
aluate
the
form
ula
(x
6=
h
i)
^
(x
[1]
=
0)
but
not
the
(logically
equiv
alen
t)
form
ula
(x
[1]
=
0)
^
(x
6=
h
i)
(When
ev
aluating
the
latter
form
ula,
TLC
rst
tries
to
compute
h
i[1]
=
0,
rep
orting
an
error
b
ecause
it
can't.)
F
ortunately
,
w
e
naturally
write
the
rst
form
ula
rather
than
the
second
b
ecause
it's
easier
to
understand.
P
eople
under-
stand
a
form
ula
b
y
\men
tally
ev
aluating"
it
from
left
to
righ
t,
m
uc
h
the
w
a
y
TLC
do
es.
TLC
ev
aluates
9
x
2
S
:
p
b
y
en
umerating
the
elemen
ts
s
1
;
:
:
:
;
s
n
of
S
in
some
order
and
then
ev
aluating
p
with
s
i
substituted
for
x
,
successiv
ely
for
i
=
1;
:
:
:
;
n
.
It
en
umerates
the
elemen
ts
of
a
set
S
in
a
v
ery
straigh
tforw
ard
w
a
y
,
and
it
giv
es
up
and
declares
an
error
if
the
set
is
not
ob
viously
nite.
F
or
example,
it
can
ob
viously
en
umerate
the
elemen
ts
of
f0;
1;
2;
3g
and
0
:
:
3.
It
en
umerates
a
set
of
the
form
fx
2
S
:
p
g
b
y
rst
en
umerating
S
,
so
it
can
en
umerate
fi
2
0
:
:
5
:
i
<
4g
but
not
fi
2
Nat
:
i
<
4g
.
TLC
ev
aluates
the
expressions
8
x
2
S
:
p
and
choose
x
2
S
:
p
b
y
rst
en
umerating
the
elemen
ts
of
S
,
m
uc
h
the
same
w
a
y
as
it
ev
aluates
9
x
2
S
:
p
.
The
seman
tics
of
TLA
+
states
that
choose
x
2
S
:
p
is
an
arbitrary
v
alue
if
there
is
no
x
in
S
for
whic
h
p
is
true.
Ho
w
ev
er,
this
case
almost
alw
a
ys
arises
b
ecause
of
a
mistak
e,
so
TLC
treats
it
as
an
error.
Note
that
ev
aluating
the
expression
if
n
>
5
then
choose
i
2
1
:
:
n
:
i
>
5
else
42
will
not
pro
duce
an
error
b
ecause
TLC
will
not
ev
aluate
the
choose
expression
if
n

5.
(TLC
w
ould
rep
ort
an
error
if
it
tried
to
ev
aluate
the
choose
expression
when
n

5.)
TLC
cannot
ev
aluate
\un
b
ounded"
quan
tiers
or
choose
expressions|that
is,
expressions
ha
ving
one
of
the
forms
9
x
:
p
8
x
:
p
choose
x
:
p
TLC
cannot
ev
aluate
an
y
expression
whose
v
alue
is
not
a
TLC
v
alue,
as
dened
in
Section
14.2.1
ab
o
v
e.
In
particular,
TLC
can
ev
aluate
a
set-v
alued
expression
only
if
that
expression
equals
a
nite
set,
and
it
can
ev
aluate
a
function-v
alued
expression
only
if
that
expression
equals
a
function
whose
domain
is
a
nite
set.
TLC
will
ev
aluate
expressions
of
the
follo
wing
forms
only
if
it
can
en
umerate
the
set
S
:
9
x
2
S
:
p
8
x
2
S
:
p
choose
x
2
S
:
p
fx
2
S
:
p
g
fe
:
x
2
S
g
[x
2
S
7!
e
]
subset
S
union
S

14.2.
WHA
T
TLC
CAN
COPE
WITH
233
TLC
can
often
ev
aluate
an
expression
ev
en
when
it
can't
ev
aluate
all
sub
expres-
sions.
F
or
example,
it
can
ev
aluate
[n
2
Nat
7!
n

(n
+
1)][3]
whic
h
equals
the
TLC
v
alue
12,
ev
en
though
it
can't
ev
aluate
[n
2
Nat
7!
n

(n
+
1)]
whic
h
equals
a
function
whose
domain
is
the
set
Nat
.
(A
function
can
b
e
a
TLC
v
alue
only
if
its
domain
is
a
nite
set.)
TLC
ev
aluates
recursiv
ely
dened
functions
with
a
simple
recursiv
e
pro
ce-
dure.
If
f
is
dened
b
y
f
[x
2
S
]

=
e
,
then
TLC
ev
aluates
f
[c
]
b
y
ev
aluating
e
with
c
substituted
for
x
.
This
means
that
it
can't
handle
some
legal
function
denitions.
F
or
example,
consider
this
denition
from
page
68:
mr
[n
2
Nat
]

=
[f
7!
if
n
=
0
then
17
else
mr
[n
 1]:f

mr
[n
]:g
;
g
7!
if
n
=
0
then
42
else
mr
[n
 1]:f
+
mr
[n
 1]:g
]
T
o
ev
aluate
mr
[3],
TLC
substitutes
3
for
n
and
starts
ev
aluating
the
righ
t-hand
side.
But
b
ecause
mr
[n
]
app
ears
in
the
righ
t-hand
side,
TLC
m
ust
ev
aluate
the
sub
expression
mr
[3],
whic
h
it
do
es
b
y
substituting
3
for
n
and
starting
to
ev
aluate
the
righ
t-hand
side.
And
so
on.
TLC
ev
en
tually
detects
that
it's
in
an
innite
lo
op
and
rep
orts
an
error.
Legal
recursiv
e
denitions
that
cause
TLC
to
lo
op
lik
e
this
are
rare,
and
they
can
b
e
rewritten
so
TLC
can
handle
them.
Recall
that
w
e
dened
mr
to
express
the
m
utual
recursion:
f
[n
]
=
if
n
=
0
then
17
else
f
[n
 1]

g
[n
]
g
[n
]
=
if
n
=
0
then
42
else
f
[n
 1]
+
g
[n
 1]
The
sub
expression
mr
[n
]
app
eared
in
the
expression
dening
mr
[n
]
b
ecause
f
[n
]
dep
ends
on
g
[n
].
T
o
eliminate
it,
w
e
ha
v
e
to
rewrite
the
m
utual
recursion
so
that
f
[n
]
dep
ends
only
on
f
[n
 1]
and
g
[n
 1].
W
e
do
this
b
y
expanding
the
denition
of
g
[n
]
in
the
expression
for
f
[n
].
Since
the
else
clause
applies
only
to
the
case
n
6=
0,
w
e
can
rewrite
the
expression
for
f
[n
]
as
f
[n
]
=
if
n
=
0
then
17
else
f
[n
 1]

(f
[n
 1]
+
g
[n
 1])
This
leads
to
the
follo
wing
equiv
alen
t
denition
of
mr
:
mr
[n
2
Nat
]

=
[f
7!
if
n
=
0
then
17
else
mr
[n
 1]:f

(mr
[n
 1]:f
+
mr
[n
 1]:g
)
;
g
7!
if
n
=
0
then
42
else
mr
[n
 1]:f
+
mr
[n
 1]:g
]

234
CHAPTER
14.
THE
TLC
MODEL
CHECKER
With
this
denition,
TLC
has
no
trouble
ev
aluating
mr
[3].
The
ev
aluation
of
enabled
predicates
and
the
action-comp
osition
op
erator
\"
are
describ
ed
on
page
240
in
Section
14.2.6.
Section
14.3
explains
ho
w
TLC
ev
aluates
temp
oral-logic
form
ulas
for
temp
oral
c
hec
king.
If
y
ou're
not
sure
whether
TLC
can
ev
aluate
an
expression,
try
it
and
see.
But
don't
w
ait
un
til
TLC
gets
to
the
expression
in
the
middle
of
c
hec
king
the
en
tire
sp
ecication.
Instead,
mak
e
a
small
example
in
whic
h
TLC
ev
aluates
just
that
expression.
See
the
explanation
on
page
14.5.3
of
ho
w
to
use
TLC
as
a
TLA
+
calculator.
14.2.3
Assignmen
t
and
Replacemen
t
As
w
e
sa
w
in
the
alternating
bit
example,
the
conguration
le
m
ust
determine
the
v
alue
of
eac
h
constan
t
parameter.
T
o
assign
a
TLC
v
alue
v
to
a
constan
t
pa-
rameter
c
of
the
sp
ecication,
w
e
write
c
=
v
in
the
conguration
le's
CONSTANT
statemen
t.
The
v
alue
v
ma
y
b
e
a
primitiv
e
TLC
v
alue
or
a
nite
set
of
primitiv
e
TLC
v
alues
written
in
the
form
fv
1
;
:
:
:
;
v
n
g|for
example,
{1,
-3,
2}.
In
v
,
an
y
sequence
of
c
haracters
lik
e
a1
or
foo
that
is
not
a
n
um
b
er,
a
quoted
string,
or
TRUE
or
FALSE
is
tak
en
to
b
e
a
mo
del
v
alue.
In
the
assignmen
t
c
=
v
,
the
sym
b
ol
c
need
not
b
e
a
constan
t
parameter;
it
can
also
b
e
a
dened
sym
b
ol.
This
assignmen
t
causes
TLC
to
ignore
the
actual
denition
of
c
and
to
tak
e
v
to
b
e
its
v
alue.
Suc
h
an
assignmen
t
is
often
used
when
TLC
cannot
compute
the
v
alue
of
c
from
its
denition.
In
particular,
TLC
cannot
compute
the
v
alue
of
NotA
nS
from
the
denition
NotA
nS

=
choose
n
:
n
=
2
S
b
ecause
it
cannot
ev
aluate
the
un
b
ounded
choose
expression.
Y
ou
can
o
v
erride
this
denition
b
y
assigning
NotA
nS
a
v
alue
in
the
CONSTANT
statemen
t
of
the
conguration
le.
F
or
example,
the
assignmen
t
NotAnS
=
NS
causes
TLC
to
assign
to
NotA
nS
the
mo
del
v
alue
NS.
TLC
ignores
the
actual
denition
of
NotA
nS
.
If
y
ou
used
the
name
NotA
nS
in
the
sp
ecication,
y
ou'd
probably
w
an
t
TLC's
error
messages
to
call
it
NotAnS
rather
than
NS.
So,
y
ou'd
probably
use
the
assignmen
t
NotAnS
=
NotAnS
whic
h
assigns
to
the
sym
b
ol
NotA
nS
the
mo
del
v
alue
NotAnS.
Remem
b
er
that,
in
the
assignmen
t
c
=
v
,
the
sym
b
ol
c
m
ust
b
e
dened
or
declared
in
the
TLA
+
mo
dule,
and
v
m
ust
b
e
a
primitiv
e
TLC
v
alue
or
a
nite
set
of
suc
h
v
alues.
The
CONSTANT
statemen
t
of
the
conguration
le
can
also
con
tain
r
eplac
e-
ments
of
the
form
c
<-
d
,
where
c
and
d
are
sym
b
ols
dened
in
the
TLA
+
Note
that
d
is
a
dened
sym
b
ol
in
the
replacemen
t
c
<-
d
,
while
v
is
a
TLC
v
alue
in
the
substitution
c
=
v
.

14.2.
WHA
T
TLC
CAN
COPE
WITH
235
mo
dule.
This
causes
TLC
to
replace
c
b
y
d
when
p
erforming
its
calculations.
One
use
of
replacemen
t
is
to
giv
e
a
v
alue
to
an
op
erator
parameter.
F
or
exam-
ple,
supp
ose
w
e
w
an
ted
to
use
TLC
to
c
hec
k
the
write-through
cac
he
sp
eci-
cation
of
Section
5.6
(page
54).
The
WriteThr
oughCache
mo
dule
extends
the
MemoryInterfac
e
mo
dule,
whic
h
con
tains
the
declaration
const
ants
Send
(
;
;
;
);
R
eply
(
;
;
;
);
:
:
:
W
e
ha
v
e
to
tell
TLC
ho
w
to
ev
aluate
the
op
erators
Send
and
R
eply
.
W
e
do
this
b
y
rst
writing
a
mo
dule
MCWriteThr
oughCache
that
extends
the
WriteThr
oughCache
mo
dule
and
denes
t
w
o
op
erators
MCSend
(p
;
d
;
old
;
new
)

=
:
:
:
MCR
eply
(p
;
d
;
old
;
new
)

=
:
:
:
W
e
then
add
to
the
conguration
le's
CONSTANT
statemen
t
the
replacemen
ts
Send
<-
MCSend
Reply
<-
MCReply
A
replacemen
t
can
also
replace
one
dened
sym
b
ol
b
y
another.
In
a
sp
ecication,
w
e
usually
write
the
simplest
p
ossible
denitions.
A
simple
denition
is
not
alw
a
ys
the
easiest
one
for
TLC
to
use.
F
or
example,
supp
ose
our
sp
ecication
requires
an
op
erator
Sort
suc
h
that
Sort
(S
)
is
a
sequence
con
taining
the
elemen
ts
of
S
in
increasing
order,
if
S
is
a
nite
set
of
n
um
b
ers.
Our
sp
ecication
in
mo
dule
Sp
e
cMo
d
migh
t
use
the
simple
denition
Sort
(S
)

=
choose
s
2
[1
:
:
Car
dinality
(S
)
!
S
]
:
8
i
;
j
2
domain
s
:
(i
<
j
)
)
(s
[i
]
<
s
[j
])
T
o
ev
aluate
Sort
(S
)
for
a
set
S
con
taining
n
elemen
ts,
TLC
has
to
en
umerate
the
n
n
elemen
ts
in
the
set
[1
:
:
n
!
S
]
of
functions.
This
ma
y
b
e
unacceptably
slo
w.
W
e
can
write
a
mo
dule
MCSp
e
cMo
d
that
extends
Sp
e
cMo
d
and
denes
F
astSort
so
it
equals
Sort
when
applied
to
nite
sets
of
n
um
b
ers,
but
can
b
e
ev
aluated
more
ecien
tly
b
y
TLC.
W
e
can
then
run
TLC
with
a
conguration
le
con
taining
the
replacemen
t
Sort
<-
FastSort
One
p
ossible
denition
of
F
astSort
is
giv
en
in
Section
14.4,
on
page
250.
14.2.4
Ev
aluating
T
emp
oral
F
orm
ulas
Section
14.2.2
(page
231)
explains
what
kind
of
ordinary
expressions
TLC
can
ev
aluate.
The
sp
ecication
and
prop
erties
that
TLC
c
hec
ks
are
temp
oral
for-
m
ulas;
this
section
describ
es
the
class
of
temp
oral
form
ulas
it
can
handle.

236
CHAPTER
14.
THE
TLC
MODEL
CHECKER
TLC
can
ev
aluate
a
TLA
temp
oral
form
ula
i
(i)
the
form
ula
is
nic
e
|a
term
dened
in
the
next
paragraph|and
(ii)
TLC
can
ev
aluate
all
the
ordinary
expressions
of
whic
h
the
form
ula
is
comp
osed.
F
or
example,
a
form
ula
of
the
form
P
;
Q
is
nice,
so
TLC
can
ev
aluate
it
i
it
can
ev
aluate
P
and
Q
.
(Section
14.3
b
elo
w
explains
on
what
states
and
pairs
of
states
TLC
ev
aluates
the
comp
onen
t
expressions
of
a
temp
oral
form
ula.)
A
temp
oral
form
ula
is
nice
i
it
is
the
conjunction
of
form
ulas
that
b
elong
to
one
of
the
follo
wing
four
classes:
State
Predicate
In
v
ariance
F
orm
ula
A
form
ula
of
the
form
2P
,
where
P
is
a
state
predicate.
Bo
x-Action
F
orm
ula
A
form
ula
of
the
form
2[A]
v
,
where
A
is
an
action
and
v
is
a
state
function.
Simple
T
emp
oral
F
orm
ula
T
o
dene
this
class,
w
e
rst
mak
e
the
follo
wing
denitions:
The
terminology
used
here
is
not
standard.

The
simple
Bo
ole
an
op
er
ators
consist
of
the
op
erators
^
_
:
)

tr
ue
f
alse
of
prop
ositional
logic
together
with
quan
tication
o
v
er
nite,
constan
t
sets.

A
temp
or
al
state
formula
is
one
obtained
from
state
predicates
b
y
applying
simple
Bo
olean
op
erators
and
the
temp
oral
op
erators
2,
3,
and
;.
F
or
example,
if
N
is
a
constan
t,
then
8
i
2
1
:
:
N
:
2((x
=
i
)
)
9
j
2
1
:
:
i
:
3(y
=
j
))
is
a
temp
oral
state
form
ula.

A
simple
action
formula
is
one
of
the
follo
wing,
where
A
is
an
action
and
v
a
state
function:
WF
v
(A)
SF
v
(A)
23h
A
i
v
32[A]
v
The
comp
onen
t
expressions
of
WF
v
(A)
and
SF
v
(A)
are
h
A
i
v
and
enabled
h
A
i
v
.
(The
ev
aluation
of
enabled
form
ulas
is
describ
ed
on
page
240.)
A
simple
temp
oral
form
ula
is
then
dened
to
b
e
one
constructed
from
temp
oral
state
form
ulas
and
simple
action
form
ulas
b
y
applying
simple
Bo
olean
op
erators.
F
or
con
v
enience,
w
e
exclude
in
v
ariance
form
ulas
from
the
class
of
simple
tem-
p
oral
form
ulas,
so
these
four
classes
of
nice
temp
oral
form
ulas
are
disjoin
t.
TLC
can
therefore
ev
aluate
the
temp
oral
form
ula
8
i
2
1
:
:
N
:
3(y
=
i
)
)
WF
y
((y
0
=
y
+
1)
^
(y

i
))

14.2.
WHA
T
TLC
CAN
COPE
WITH
237
if
N
is
a
constan
t,
b
ecause
this
is
a
simple
temp
oral
form
ula
(and
hence
nice)
and
TLC
can
ev
aluate
all
of
its
comp
onen
t
expressions.
TLC
cannot
ev
aluate
3h
x
0
=
1
i
x
,
since
this
is
not
a
nice
form
ula.
It
cannot
ev
aluate
the
form
ula
WF
x
(x
0
[1]
=
0)
if
it
m
ust
ev
aluate
the
action
h
x
0
[1]
=
0
i
x
on
a
step
s
!
t
in
whic
h
x
=
h
i
in
state
t
.
A
PROPERTY
statemen
t
can
sp
ecify
an
y
form
ulas
that
TLC
can
ev
aluate.
The
form
ula
of
a
SPECIFICATION
statemen
t
m
ust
con
tain
exactly
one
conjunct
that
is
a
b
o
x-action
form
ula.
That
conjunct
sp
ecies
the
next-state
action.
14.2.5
Ov
erriding
Mo
dules
TLC
cannot
compute
2
+
2
from
the
denition
of
+
con
tained
in
the
standard
Natur
als
mo
dule.
Ev
en
if
w
e
did
use
a
denition
of
+
from
whic
h
TLC
could
compute
sums,
it
w
ould
not
do
so
v
ery
quic
kly
.
Arithmetic
op
erators
lik
e
+
are
implemen
ted
directly
in
Ja
v
a,
the
language
in
whic
h
TLC
is
written.
This
is
ac
hiev
ed
b
y
a
general
mec
hanism
of
TLC
that
allo
ws
a
mo
dule
to
b
e
o
v
erridden
b
y
a
Ja
v
a
class
that
implemen
ts
the
op
erators
dened
in
the
mo
dule.
When
TLC
encoun
ters
an
extends
Natur
als
statemen
t,
it
loads
the
Ja
v
a
class
that
o
v
errides
the
Natur
als
mo
dule
rather
than
reading
the
mo
dule
itself.
There
are
Ja
v
a
classes
to
o
v
erride
the
follo
wing
standard
mo
dules:
Natur
als
,
Inte
gers
,
Se
quenc
es
,
FiniteSets
,
and
Bags
.
(The
TLC
mo
dule
describ
ed
b
elo
w
in
Sec-
tion
14.4
is
also
o
v
erridden
b
y
a
Ja
v
a
class.)
In
trepid
Ja
v
a
programmers
will
nd
that
writing
a
Ja
v
a
class
to
o
v
erride
a
mo
dule
is
not
to
o
hard.
14.2.6
Ho
w
TLC
Computes
States
When
TLC
ev
aluates
an
in
v
arian
t,
it
is
calculating
the
in
v
arian
t's
v
alue,
whic
h
is
either
tr
ue
or
f
alse.
When
TLC
ev
aluates
the
initial
predicate
or
the
next-
state
action,
it
is
computing
a
set
of
states|for
the
initial
predicate,
the
set
of
all
initial
states,
and
for
the
next-state
action,
the
set
of
p
ossible
suc
c
essor
states
(primed
states)
reac
hed
from
a
giv
en
starting
(unprimed)
state.
I
will
describ
e
ho
w
TLC
do
es
this
for
the
next-state
action;
the
ev
aluation
of
the
initial
predicate
is
analogous.
Recall
that
a
state
is
an
assignmen
t
of
v
alues
to
v
ariables.
TLC
computes
the
successors
of
a
giv
en
state
s
b
y
assigning
to
all
unprimed
v
ariables
their
v
alues
in
state
s
,
assigning
no
v
alues
to
the
primed
v
ariables,
and
then
ev
aluating
the
next-
state
action.
TLC
ev
aluates
the
next-state
action
as
describ
ed
in
Section
14.2.2
(page
231),
except
for
t
w
o
dierences,
whic
h
I
no
w
describ
e.
This
description
assumes
that
TLC
has
already
p
erformed
all
the
assignmen
ts
and
replacemen
ts
sp
ecied
b
y
the
CONSTANT
statemen
t
of
the
conguration
le
and
has
expanded
all
denitions.
Th
us,
the
next-state
action
is
a
form
ula
con
taining
only
v
ariables,
primed
v
ariables,
mo
del
v
alues,
and
built-in
TLA
+
op
erators
and
constan
ts.

238
CHAPTER
14.
THE
TLC
MODEL
CHECKER
The
rst
dierence
in
ev
aluating
the
next-state
action
is
that
TLC
do
es
not
ev
aluate
disjunctions
from
left
to
righ
t.
Instead,
when
it
ev
aluates
a
subform
ula
A
1
_
:
:
:
_
A
n
,
it
splits
the
computation
in
to
n
separate
ev
aluations,
eac
h
taking
the
subform
ula
to
b
e
one
of
the
A
i
.
Similarly
,
when
it
ev
aluates
9
x
2
S
:
p
,
it
splits
the
computation
in
to
separate
ev
aluations
for
eac
h
elemen
t
of
S
.
An
implication
P
)
Q
is
treated
as
the
disjunction
(:P
)
_
Q
.
F
or
example,
TLC
splits
the
ev
aluation
of
(A
)
B
)
_
(C
^
(9
i
2
S
:
D
(i
))
^
E
)
in
to
separate
ev
aluations
of
the
three
disjuncts
:A,
B
,
and
C
^
(9
i
2
S
:
D
(i
))
^
E
T
o
ev
aluate
the
latter
disjunct,
it
rst
ev
aluates
C
.
If
it
obtains
the
v
alue
tr
ue
,
then
it
splits
this
ev
aluation
in
to
the
separate
ev
aluations
of
D
(i
)
^
E
,
for
eac
h
i
in
S
.
It
ev
aluates
D
(i
)
^
E
b
y
rst
ev
aluating
D
(i
)
and,
if
it
obtains
the
v
alue
tr
ue
,
then
ev
aluating
E
.
The
second
dierence
in
the
w
a
y
TLC
ev
aluates
the
next-state
action
is
that,
for
an
y
v
ariable
x
,
if
it
ev
aluates
an
expression
of
the
form
x
0
=
e
when
x
0
has
not
y
et
b
een
assigned
a
v
alue,
then
the
ev
aluation
yields
the
v
alue
tr
ue
and
TLC
assigns
to
x
0
the
v
alue
obtained
b
y
ev
aluating
the
expression
e
.
TLC
ev
aluates
an
expression
of
the
form
x
0
2
S
as
if
it
w
ere
9
v
2
S
:
x
0
=
v
.
It
ev
aluates
unchanged
x
as
x
0
=
x
for
an
y
v
ariable
x
,
and
unchanged
h
e
1
;
:
:
:
;
e
n
i
as
(unchanged
e
1
)
^
:
:
:
^
(unchanged
e
n
)
for
an
y
expressions
e
i
.
Hence,
TLC
ev
aluates
unchanged
h
x
;
h
y
;
z
i
i
as
if
it
w
ere
(x
0
=
x
)
^
(y
0
=
y
)
^
(z
0
=
z
)
Except
when
ev
aluating
an
expression
of
the
form
x
0
=
e
,
TLC
rep
orts
an
error
if
it
encoun
ters
a
primed
v
ariable
that
has
not
y
et
b
een
assigned
a
v
alue.
An
ev
aluation
stops,
nding
no
states,
if
a
conjunct
ev
aluates
to
f
alse.
An
ev
aluation
that
completes
and
obtains
the
v
alue
tr
ue
nds
the
state
determined
b
y
the
v
alues
assigned
to
the
primed
v
ariables.
In
the
latter
case,
TLC
rep
orts
an
error
if
some
primed
v
ariable
has
not
b
een
assigned
a
v
alue.
T
o
illustrate
ho
w
this
w
orks,
let's
consider
ho
w
TLC
ev
aluates
the
next-state
action
_
^
x
0
2
1
:
:
L
en
(y
)
^
y
0
=
App
end
(T
ail
(y
);
x
0
)
_
^
x
0
=
x
+
1
^
y
0
=
App
end
(y
;
x
0
)
(14.4)
W
e
rst
consider
the
starting
state
with
x
=
1
and
y
=
h
2;
3
i.
TLC
splits
the
computation
in
to
ev
aluating
the
t
w
o
disjuncts
separately
.
It
b
egins
ev
aluating

14.2.
WHA
T
TLC
CAN
COPE
WITH
239
the
rst
disjunct
of
(14.4)
b
y
ev
aluating
its
rst
conjunct,
whic
h
it
treats
as
9
i
2
1
:
:
L
en
(y
)
:
x
0
=
i
.
Since
L
en
(y
)
=
2,
the
ev
aluation
splits
in
to
separate
ev
aluations
of
^
x
0
=
1
^
y
0
=
App
end
(T
ail
(y
);
x
0
)
^
x
0
=
2
^
y
0
=
App
end
(T
ail
(y
);
x
0
)
(14.5)
TLC
ev
aluates
the
rst
of
these
actions
as
follo
ws.
It
ev
aluates
the
rst
con-
junct,
obtaining
the
v
alue
tr
ue
and
assigning
to
x
0
the
v
alue
1;
it
then
ev
al-
uates
the
second
conjunct,
obtaining
the
v
alue
tr
ue
and
assigning
to
y
0
the
v
alue
App
end
(T
ail
(h
2;
3
i);
1).
So,
ev
aluating
the
rst
action
of
(14.5)
nds
the
successor
state
with
x
=
1
and
y
=
h
3;
1
i.
Similarly
,
ev
aluating
the
second
action
of
(14.5)
nds
the
successor
state
with
x
=
2
and
y
=
h
3;
2
i.
In
a
similar
w
a
y
,
TLC
ev
aluates
the
second
disjunct
of
(14.4)
to
nd
the
successor
state
with
x
=
2
and
y
=
h
2;
3;
2
i.
Hence,
the
ev
aluation
of
(14.4)
nds
three
successor
states.
Next,
consider
ho
w
TLC
ev
aluates
the
next-state
action
(14.4)
in
a
state
with
x
=
1
and
y
equal
to
the
empt
y
sequence
h
i.
Since
L
en
(y
)
=
0
and
1
:
:
0
is
the
empt
y
set
f
g,
TLC
ev
aluates
the
rst
disjunct
as
^
9
i
2
f
g
:
x
0
=
i
^
y
0
=
App
end
(T
ail
(y
);
x
0
)
Ev
aluating
the
rst
conjunct
yields
f
alse,
so
the
ev
aluation
of
the
rst
disjunct
of
(14.4)
stops,
nding
no
successor
states.
Ev
aluating
the
second
disjunct
yields
the
successor
state
with
x
=
2
and
y
=
h
2
i.
Since
TLC
ev
aluates
conjuncts
from
left
to
righ
t,
their
order
can
aect
whether
or
not
TLC
can
ev
aluate
the
next-state
action.
F
or
example,
supp
ose
the
t
w
o
conjuncts
in
the
rst
disjunct
of
(14.4)
w
ere
rev
ersed,
lik
e
this:
^
y
0
=
App
end
(T
ail
(y
);
x
0
)
^
x
0
2
1
:
:
L
en
(y
)
When
TLC
ev
aluates
the
rst
conjunct
of
this
action,
it
encoun
ters
the
expres-
sion
App
end
(T
ail
(y
);
x
0
)
b
efore
it
has
assigned
a
v
alue
to
x
0
,
so
it
rep
orts
an
error.
Moreo
v
er,
ev
en
if
w
e
w
ere
to
c
hange
that
x
0
to
an
x
,
TLC
could
still
not
ev
aluate
the
action
starting
in
a
state
with
y
=
h
i,
since
it
w
ould
encoun
ter
the
silly
expression
T
ail
(h
i)
when
ev
aluating
the
rst
conjunct.
The
description
giv
en
ab
o
v
e
of
ho
w
TLC
ev
aluates
an
arbitrary
next-state
action
is
go
o
d
enough
to
explain
ho
w
it
w
orks
in
almost
all
cases
that
arise
in
practice.
Ho
w
ev
er,
it
is
not
completely
accurate.
F
or
example,
in
terpreted
literally
,
it
w
ould
imply
that
TLC
can
cop
e
with
the
follo
wing
t
w
o
next-state
actions,
whic
h
are
b
oth
logically
equiv
alen
t
to
(x
0
=
tr
ue)
^
(y
0
=
1)
:
(x
0
=
(y
0
=
1))
^
(x
0
=
tr
ue)
if
x
0
=
tr
ue
then
y
0
=
1
else
f
alse
(14.6)

240
CHAPTER
14.
THE
TLC
MODEL
CHECKER
In
fact,
TLC
will
pro
duce
error
messages
when
presen
ted
with
either
of
these
bizarre
next-state
actions.
Remem
b
er
that
TLC
computes
initial
states
b
y
using
a
similar
pro
cedure
to
ev
aluate
the
initial
predicate.
Instead
of
starting
from
giv
en
v
alues
of
the
unprimed
v
ariables
and
assigning
v
alues
to
the
primed
v
ariables,
it
assigns
v
alues
to
the
unprimed
v
ariables.
TLC
ev
aluates
enabled
form
ulas
essen
tially
the
same
w
a
y
it
ev
aluates
a
next-state
action.
More
precisely
,
to
ev
aluate
a
form
ula
enabled
A,
TLC
com-
putes
successor
states
as
if
A
w
ere
the
next-state
action.
The
form
ula
ev
aluates
to
tr
ue
i
there
exists
a
successor
state.
T
o
c
hec
k
if
a
step
s
!
t
satises
the
comp
osition
A

B
of
actions
A
and
B
,
TLC
rst
computes
all
states
u
suc
h
that
Action
comp
osi-
tion
is
discussed
on
page
77.
s
!
u
is
an
A
step
and
then
c
hec
ks
if
u
!
t
is
a
B
step
for
some
suc
h
u
.
TLC
ma
y
also
ha
v
e
to
ev
aluate
an
action
when
c
hec
king
a
prop
ert
y
.
In
that
case,
it
ev
aluates
the
action
as
it
w
ould
an
y
expression,
and
it
has
no
trouble
ev
aluating
ev
en
the
bizarre
actions
(14.6).
14.3
Ho
w
TLC
Chec
ks
Prop
erties
Section
14.2
ab
o
v
e
explains
ho
w
TLC
ev
aluates
expressions
and
computes
initial
states
and
successor
states.
This
section
describ
es
ho
w
TLC
uses
ev
aluation
to
c
hec
k
prop
erties|rst
for
mo
del-c
hec
king
mo
de
(its
default),
and
then
for
sim
ulation
mo
de.
First,
let's
dene
some
form
ulas
that
are
obtained
from
the
conguration
le.
In
these
denitions,
a
sp
e
cic
ation
c
onjunct
is
a
conjunct
of
the
form
ula
named
b
y
the
SPECIFICATION
statemen
t
(if
there
is
one),
a
pr
op
erty
c
onjunct
is
a
conjunct
of
a
form
ula
named
b
y
a
PROPERTY
statemen
t,
and
the
conjunction
of
an
empt
y
set
of
form
ulas
is
dened
to
b
e
tr
ue
.
The
denitions
use
the
four
classes
of
nice
temp
oral
form
ulas
dened
ab
o
v
e
in
Section
14.2.4
on
page
235.
Init
The
sp
ecication's
initial
state
predicate.
It
is
sp
ecied
b
y
an
INIT
or
SPECIFICATION
statemen
t.
In
the
latter
case,
it
is
the
conjunction
of
all
sp
ecication
conjuncts
that
are
state
predicates.
Next
The
sp
ecication's
next-state
action.
It
is
sp
ecied
b
y
a
NEXT
statemen
t
or
a
SPECIFICATION
statemen
t.
In
the
latter
case,
it
is
the
action
N
suc
h
that
there
is
a
sp
ecication
conjunct
of
the
form
2[N
]
v
.
There
m
ust
not
b
e
more
than
one
suc
h
conjunct.
T
emp
or
al
The
conjunction
of
ev
ery
sp
ecication
conjunct
that
is
neither
a
state
predicate
nor
a
b
o
x-action
form
ula.
It
is
usually
the
sp
ecication's
liv
eness
condition.
Invariant
The
conjunction
of
ev
ery
state
predicate
I
that
is
either
named
b
y
an
INVARIANT
statemen
t
or
for
whic
h
some
prop
ert
y
conjunct
equals
2I
.

14.3.
HO
W
TLC
CHECKS
PR
OPER
TIES
241
Implie
dInit
The
conjunction
of
ev
ery
prop
ert
y
conjunct
that
is
a
state
predicate.
Implie
dA
ction
The
conjunction
of
ev
ery
action
[A]
v
suc
h
that
some
prop
ert
y
conjunct
equals
2[A]
v
.
Implie
dT
emp
or
al
The
conjunction
of
ev
ery
prop
ert
y
conjunct
that
is
a
simple
temp
oral
form
ula,
but
is
not
of
the
form
2I
,
where
I
is
a
state
predicate.
Constr
aint
The
conjunction
of
all
state
predicates
named
b
y
CONSTRAINT
state-
men
ts.
A
ctionConstr
aint
The
conjunction
of
all
actions
named
b
y
ACTION-CONSTRAIN
T
statemen
ts.
An
action
constrain
t
is
similar
to
an
ordinary
constrain
t,
except
it
eliminates
p
ossible
transitions
rather
than
states.
An
ordinary
constrain
t
P
is
equiv
alen
t
to
the
action
constrain
t
P
0
.
14.3.1
Mo
del-Chec
king
Mo
de
TLC
k
eeps
t
w
o
data
structures:
a
directed
graph
G
whose
no
des
are
states,
and
a
queue
(a
sequence)
U
of
states.
A
state
in
G
means
a
state
that
is
a
no
de
of
the
graph
G
.
The
graph
G
is
the
part
of
the
state
reac
habilit
y
graph
that
TLC
has
found
so
far,
and
U
con
tains
all
states
in
G
whose
successors
TLC
has
not
y
et
computed.
TLC's
computation
main
tains
the
follo
wing
in
v
arian
ts:

The
states
of
G
satisfy
the
Constr
aint
predicate.

F
or
ev
ery
state
s
in
G
,
the
edge
from
s
to
s
is
in
G
.

If
there
is
an
edge
in
G
from
state
s
to
a
dieren
t
state
t
,
then
t
is
a
successor
state
of
s
that
satises
the
action
constrain
t.
In
other
w
ords,
the
step
s
!
t
satises
Next
^
A
ctionConstr
aint
.

Eac
h
state
s
of
G
is
reac
hable
from
an
initial
state
(one
that
satises
the
Init
predicate)
b
y
a
path
in
G
.

U
is
a
sequence
of
distinct
states
that
are
no
des
in
G
.

F
or
ev
ery
state
s
in
G
that
is
not
in
U
,
and
for
ev
ery
state
t
satisfying
Constr
aint
suc
h
that
the
step
s
!
t
satises
Next
^
A
ctionConstr
aint
,
the
state
t
and
the
edge
from
s
to
t
are
in
G
.
TLC
executes
the
follo
wing
algorithm,
starting
with
G
and
U
empt
y:
1.
Chec
k
that
ev
ery
assume
in
the
sp
ecication
is
satised
b
y
the
v
alues
assigned
to
the
constan
t
parameters.
2.
Compute
the
set
of
initial
states
b
y
ev
aluating
the
initial
predicate
Init
,
as
describ
ed
ab
o
v
e
in
Section
14.2.6.
F
or
eac
h
initial
state
s
found:

242
CHAPTER
14.
THE
TLC
MODEL
CHECKER
(a)
Ev
aluate
the
predicates
Invariant
and
Implie
dInit
in
state
s
;
rep
ort
an
error
and
stop
if
either
is
false.
(b)
If
the
predicate
Constr
aint
is
true
in
state
s
,
then
add
s
to
the
queue
U
and
add
no
de
s
and
edge
s
!
s
to
the
graph
G
.
3.
While
U
is
nonempt
y
,
do
the
follo
wing:
(a)
Remo
v
e
the
rst
state
from
U
and
let
s
b
e
that
state.
(b)
Find
the
set
T
of
all
successor
states
of
s
b
y
ev
aluating
the
next-state
action
starting
from
s
,
as
describ
ed
ab
o
v
e
in
Section
14.2.6.
(c)
If
T
is
empt
y
and
the
de
ad
lo
ck
option
is
not
selected,
then
rep
ort
a
deadlo
c
k
error
and
stop.
(d)
F
or
eac
h
state
t
in
T
,
do
the
follo
wing:
i.
If
Invariant
is
false
in
state
t
or
Implie
dA
ction
is
false
for
the
step
s
!
t
,
then
rep
ort
an
error
and
stop.
ii.
If
the
predicate
Constr
aint
is
true
in
state
t
and
the
step
s
!
t
satises
A
ctionConstr
aint
,
then
A.
If
t
is
not
in
G
,
then
add
it
to
the
tail
of
U
and
add
the
no
de
t
and
the
edge
t
!
t
to
G
.
B.
Add
the
edge
s
!
t
to
G
.
TLC
can
use
m
ultiple
threads,
and
steps
3(b){(d)
ma
y
b
e
p
erformed
concur-
ren
tly
b
y
dieren
t
threads
for
dieren
t
states
s
.
See
the
description
of
the
workers
option
on
page
253
b
elo
w.
If
form
ula
Implie
dT
emp
or
al
is
not
equal
to
tr
ue
,
then
whenev
er
it
adds
an
edge
s
!
t
in
the
pro
cedure
ab
o
v
e,
TLC
ev
aluates
all
the
predicates
and
actions
that
app
ear
in
form
ulas
T
emp
or
al
and
Implie
dT
emp
or
al
for
the
step
s
!
t
.
(It
do
es
this
when
adding
an
y
edge,
including
the
self-lo
ops
s
!
s
and
t
!
t
in
steps
2(b)
and
3(d)ii.A.)
P
erio
dically
during
the
computation
of
G
,
and
when
it
has
nished
computing
G
,
TLC
c
hec
ks
the
Implie
dT
emp
or
al
prop
ert
y
as
follo
ws.
Let
T
b
e
the
set
consisting
of
ev
ery
b
eha
vior

that
is
the
sequence
of
states
in
an
innite
path
in
G
starting
with
an
initial
state.
(F
or
example,
T
con
tains
the
path
s
!
s
!
s
!
:
:
:
for
ev
ery
initial
state
s
in
G
.)
Note
that
ev
ery
b
eha
vior
in
T
satises
Init
^
2[Next
]
vars
.
TLC
c
hec
ks
that
ev
ery
b
eha
vior
in
T
also
satises
the
form
ula
T
emp
or
al
)
Implie
dT
emp
or
al
.
(This
is
conceptually
what
happ
ens;
TLC
do
es
not
actually
c
hec
k
eac
h
b
eha
vior
separately
.)
See
Section
14.3.5
on
page
247
b
elo
w
for
a
discussion
of
wh
y
TLC's
c
hec
king
of
the
Implie
dT
emp
or
al
prop
ert
y
ma
y
not
do
what
y
ou
exp
ect.
The
computation
of
G
terminates
only
if
the
set
of
reac
hable
states
is
nite.
See
page
226
for
the
denition
of
r
e
achable
state.
Otherwise,
TLC
will
run
forev
er|that
is,
un
til
it
runs
out
of
resources
or
is
stopp
ed.

14.3.
HO
W
TLC
CHECKS
PR
OPER
TIES
243
TLC
do
es
not
alw
a
ys
p
erform
all
three
of
the
steps
describ
ed
ab
o
v
e.
It
do
es
step
2
only
for
a
non-constan
t
mo
dule,
in
whic
h
case
the
conguration
le
m
ust
sp
ecify
an
Init
form
ula.
TLC
do
es
step
3
only
if
the
conguration
le
sp
ecies
a
Next
form
ula,
whic
h
it
m
ust
do
if
it
sp
ecies
an
Invariant
,
Implie
dA
ction
,
or
Implie
dT
emp
or
al
form
ula.
14.3.2
Sim
ulation
Mo
de
In
sim
ulation
mo
de,
TLC
rep
eatedly
constructs
and
c
hec
ks
individual
b
eha
viors
of
a
xed
maxim
um
length.
The
maxim
um
length
can
b
e
sp
ecied
with
the
depth
option,
as
describ
ed
on
page
251
b
elo
w.
(Its
default
v
alue
is
100
states.)
In
sim
ulation
mo
de,
TLC
runs
un
til
y
ou
stop
it.
T
o
create
and
c
hec
k
a
b
eha
vior,
TLC
uses
the
pro
cedure
describ
ed
ab
o
v
e
for
constructing
the
graph
G
|except
with
the
follo
wing
dierence.
After
com-
puting
the
set
of
initial
states,
and
after
computing
the
set
T
of
successors
for
a
state
s
,
TLC
randomly
c
ho
oses
an
elemen
t
of
that
set.
If
the
elemen
t
do
es
not
satisfy
the
constrain
t,
then
the
computation
of
G
stops.
Otherwise,
TLC
puts
only
that
state
in
G
and
U
,
and
c
hec
ks
the
Invariant
and
the
Implie
dInit
or
the
Implie
dA
ction
form
ula
for
it.
(The
queue
U
isn't
actually
main
tained,
since
it
w
ould
nev
er
con
tain
more
than
a
single
elemen
t.)
The
construction
of
G
stops,
and
the
form
ula
T
emp
or
al
)
Implie
dT
emp
or
al
is
c
hec
k
ed,
when
the
sp
ecied
maxim
um
n
um
b
er
of
states
ha
v
e
b
een
generated.
TLC
then
rep
eats
the
pro
cedure,
starting
with
G
and
U
empt
y
.
TLC's
c
hoices
are
not
strictly
random,
but
are
generated
using
a
pseudo-
random
n
um
b
er
generator
from
a
randomly
c
hosen
seed.
The
seed
and
another
v
alue
called
the
aril
are
prin
ted
if
TLC
nds
an
error.
As
describ
ed
in
Sec-
tion
14.5.1
b
elo
w,
using
the
key
and
aril
options,
y
ou
can
get
TLC
to
generate
the
b
eha
vior
that
displa
y
ed
the
error.
14.3.3
Views
and
Fingerprin
ts
In
the
description
ab
o
v
e
of
ho
w
TLC
c
hec
ks
prop
erties,
I
wrote
that
the
no
des
of
the
graph
G
are
states.
That
is
not
quite
correct.
The
no
des
of
G
are
v
alues
of
a
state
function
called
the
view.
TLC's
default
view
is
the
tuple
of
all
declared
v
ariables,
whose
v
alue
determines
the
state.
Ho
w
ev
er,
y
ou
can
sp
ecify
that
the
Remem
b
er
that
w
e
are
using
the
term
state
infor-
mally
to
mean
an
assignmen
t
of
v
al-
ues
to
declared
v
ariables,
rather
than
to
all
v
ari-
ables.
view
should
b
e
some
other
state
function
myview
b
y
putting
the
statemen
t
VIEW
myview
in
the
conguration
le,
where
myview
is
an
iden
tier
that
is
either
dened
or
else
declared
to
b
e
a
v
ariable.
When
TLC
computes
initial
states,
it
puts
their
views
rather
than
the
states
themselv
es
in
G
.
(The
view
of
a
state
s
is
the
v
alue
of
the
VIEW
state
function
in

244
CHAPTER
14.
THE
TLC
MODEL
CHECKER
state
s
.)
If
there
are
m
ultiple
initial
states
with
the
same
view,
only
one
of
them
is
put
in
the
queue
U
.
Instead
of
inserting
an
edge
from
a
state
s
to
a
state
t
,
TLC
inserts
the
edge
from
the
view
of
s
to
the
view
of
t
.
In
step
3(d)ii.A
in
the
algorithm
ab
o
v
e,
TLC
c
hec
ks
if
the
view
of
t
is
in
G
.
When
using
a
view
other
than
the
default
one,
TLC
ma
y
stop
b
efore
it
has
found
all
reac
hable
states.
F
or
the
states
it
do
es
nd,
it
correctly
p
erforms
safet
y
c
hec
ks|that
is,
the
Invariant
,
Implie
dInit
,
and
Implie
dA
ction
c
hec
ks.
Moreo
v
er,
it
prin
ts
out
a
correct
coun
terexample
(a
nite
sequence
of
states)
if
it
nds
an
error
in
one
of
those
prop
erties.
Ho
w
ev
er,
it
ma
y
incorrectly
c
hec
k
the
Implie
dT
emp
or
al
prop
ert
y
.
Because
the
graph
G
that
TLC
is
constructing
is
not
the
actual
reac
habilit
y
graph,
it
ma
y
rep
ort
an
error
in
the
Implie
dT
emp
or
al
prop
ert
y
when
none
exists,
prin
ting
out
a
b
ogus
coun
terexample.
Sp
ecifying
a
nonstandard
view
can
cause
TLC
not
to
c
hec
k
man
y
states.
Y
ou
should
do
it
when
there
is
no
need
to
c
hec
k
dieren
t
states
that
ha
v
e
the
same
view.
The
most
lik
ely
alternate
view
is
a
tuple
consisting
of
some,
but
not
all,
declared
v
ariables.
F
or
example,
y
ou
ma
y
ha
v
e
added
one
or
more
v
ariables
to
help
debug
the
sp
ecication.
Using
the
tuple
of
the
original
v
ariables
as
the
view
lets
y
ou
add
debugging
v
ariables
without
increasing
the
n
um
b
er
of
states
that
TLC
m
ust
explore.
If
the
prop
erties
b
eing
c
hec
k
ed
do
not
men
tion
the
debugging
v
ariables,
then
TLC
will
nd
all
reac
hable
states
of
the
original
sp
ecication
and
will
correctly
c
hec
k
all
prop
erties.
In
the
actual
implemen
tation,
the
no
des
of
the
graph
G
are
not
the
views
of
states,
but
ngerprints
of
those
views.
A
TLC
ngerprin
t
is
a
64-bit
n
um
b
er
generated
b
y
a
\hashing"
function.
Ideally
,
the
probabilit
y
that
t
w
o
dieren
t
views
ha
v
e
the
same
ngerprin
t
is
2
 64
,
whic
h
is
a
v
ery
small
n
um
b
er.
Ho
w
ev
er,
it
is
p
ossible
for
a
c
ol
lision
to
o
ccur,
meaning
that
TLC
mistak
enly
thinks
that
t
w
o
dieren
t
views
are
the
same
b
ecause
they
ha
v
e
the
same
ngerprin
t.
If
this
happ
ens,
TLC
will
not
explore
all
the
states
that
it
should.
In
particular,
with
the
default
view,
TLC
will
rep
ort
that
it
has
c
hec
k
ed
all
reac
hable
states
when
it
hasn't.
When
it
terminates,
TLC
prin
ts
out
t
w
o
estimates
of
the
probabilit
y
that
a
ngerprin
t
collision
o
ccurred.
The
rst
is
based
on
the
assumption
that
the
probabilit
y
of
t
w
o
dieren
t
views
ha
ving
the
same
ngerprin
t
is
2
 64
.
(Under
this
assumption,
if
TLC
generated
n
views
with
m
distinct
ngerprin
ts,
then
the
probabilit
y
of
a
collision
is
ab
out
m

(n
 m
)

2
 64
.)
Ho
w
ev
er,
the
pro
cess
of
generating
states
is
highly
nonrandom,
and
no
kno
wn
ngerprin
ting
sc
heme
can
guaran
tee
that
the
probabilit
y
of
an
y
t
w
o
distinct
states
generated
b
y
TLC
ha
ving
the
same
ngerprin
t
is
actually
2
 64
.
So,
TLC
also
prin
ts
an
empirical
estimate
of
the
probabilit
y
that
a
collision
o
ccurred.
It
is
based
on
the
obser-
v
ation
that,
if
there
w
as
a
collision,
then
it
is
lik
ely
that
there
w
as
also
a
\near
miss".
The
estimate
is
the
maxim
um
v
alue
of
1=jf
1
 f
2
j
o
v
er
all
pairs
h
f
1
;
f
2
i
of
distinct
ngerprin
ts
generated
b
y
TLC.
In
practice,
the
probabilit
y
of
collision
turns
out
to
b
e
v
ery
small
unless
TLC
is
generating
billions
of
distinct
states.

14.3.
HO
W
TLC
CHECKS
PR
OPER
TIES
245
Views
and
ngerprin
ting
apply
only
to
mo
del-c
hec
king
mo
de.
In
sim
ulation
mo
de,
TLC
ignores
an
y
VIEW
statemen
t.
14.3.4
T
aking
Adv
an
tage
of
Symmetry
The
memory
sp
ecications
of
Chapter
5
are
symmetric
in
the
set
Pr
o
c
of
pro-
cessors.
In
tuitiv
ely
,
this
means
that
p
erm
uting
the
pro
cessors
do
esn't
c
hange
whether
or
not
a
b
eha
vior
satises
a
sp
ecication.
T
o
dene
symmetry
more
precisely
,
w
e
rst
need
some
denitions.
A
p
ermutation
of
a
nite
set
S
is
a
function
whose
domain
and
range
b
oth
equal
S
.
In
other
w
ords,

is
a
p
erm
utation
of
S
i
(S
=
domain

)
^
(8
w
2
S
:
9
v
2
S
:

[v
]
=
w
)
A
p
ermutation
is
a
function
that
is
a
p
erm
utation
of
its
(nite)
domain.
If

is
a
p
erm
utation
of
a
set
S
of
v
alues
and
s
is
a
state,
let
s

b
e
the
state
obtained
from
s
b
y
replacing
eac
h
v
alue
v
in
S
with

[v
].
T
o
see
what
s

means,
let's
tak
e
as
an
example
the
p
erm
utation

of
f\a"
;
\b"
;
\c"
g
suc
h
that

[\a"
]
=
\b"
,

[\b"
]
=
\c"
,
and

[\c"
]
=
\a"
.
Supp
ose
that,
in
state
s
,
the
v
alues
of
the
v
ariables
x
and
y
are
x
=
h
\b"
;
\c"
;
\d"
i
y
=
[i
2
f\a"
;
\b"
g
7!
if
i
=
\a"
then
7
else
42
]
Then
in
state
s

,
the
v
alues
of
the
v
ariables
x
and
y
are
x
=
h
\c"
;
\a"
;
\d"
i
y
=
[i
2
f\b"
;
\c"
g
7!
if
i
=
\b"
then
7
else
42
]
This
example
should
giv
e
y
ou
an
in
tuitiv
e
idea
of
what
s

means;
I
w
on't
try
to
dene
it
rigorously
.
If

is
the
b
eha
vior
s
1
;
s
2
;
:
:
:
,
let


b
e
the
b
eha
vior
s

1
;
s

2
;
:
:
:
.
W
e
can
no
w
dene
what
symmetry
means.
A
sp
ecication
Sp
e
c
is
symmetric
with
r
esp
e
ct
to
a
p
erm
utation

i
the
follo
wing
condition
holds:
for
an
y
b
eha
vior

,
form
ula
Sp
e
c
is
satised
b
y

i
it
is
satised
b
y


.
The
memory
sp
ecications
of
Chapter
5
are
symmetric
with
resp
ect
to
an
y
p
erm
utation
of
Pr
o
c
.
This
means
that
there
is
no
need
for
TLC
to
c
hec
k
a
b
eha
vior

if
it
has
already
c
hec
k
ed
the
b
eha
vior


for
some
p
erm
utation

of
Pr
o
c
.
(An
y
error
rev
ealed
b
y

w
ould
also
b
e
rev
ealed
b
y


.)
W
e
can
tell
TLC
to
tak
e
adv
an
tage
of
this
symmetry
b
y
putting
the
follo
wing
statemen
t
in
the
conguration
le:
SYMMETRY
Perms
where
Perms
is
dened
in
the
mo
dule
to
equal
Permutations
(Pr
o
c
),
the
set
of
all
p
erm
utations
of
Pr
o
c
.
(The
Permutations
op
erator
is
dened
in
the
TLC

246
CHAPTER
14.
THE
TLC
MODEL
CHECKER
mo
dule,
describ
ed
in
Section
14.4
b
elo
w.)
This
SYMMETRY
statemen
t
causes
TLC
to
mo
dify
the
algorithm
describ
ed
on
pages
241{242
so
that
it
nev
er
adds
a
state
s
to
its
queue
U
of
unexamined
states
and
to
its
state
graph
G
if
G
already
con
tains
the
state
s

,
for
some
p
erm
utation

of
Pr
o
c
.
If
there
are
n
pro
cesses,
this
reduces
the
n
um
b
er
of
states
that
TLC
examines
b
y
a
factor
of
n
!
.
The
memory
sp
ecications
of
Chapter
5
are
also
symmetric
with
resp
ect
to
an
y
p
erm
utation
of
the
set
A
dr
of
memory
addresses.
T
o
tak
e
adv
an
tage
of
this
symmetry
as
w
ell
as
the
symmetry
with
resp
ect
to
p
erm
utations
of
pro
cessors,
w
e
dene
the
symmetry
set
(the
set
sp
ecied
b
y
the
SYMMETRY
statemen
t)
to
equal
Permutations
(Pr
o
c
)
[
Permutations
(A
dr
)
In
general,
the
SYMMETRY
statemen
t
can
sp
ecify
an
arbitrary
symmetry
set
,
eac
h
elemen
t
of
whic
h
is
a
p
erm
utation
of
a
set
of
mo
del
v
alues.
More
pre-
cisely
,
eac
h
elemen
t

in

m
ust
b
e
a
p
erm
utation
suc
h
that
all
the
elemen
ts
of
domain

are
assigned
mo
del
v
alues
b
y
the
conguration
le's
CONSTANT
state-
men
t.
(If
the
conguration
has
no
SYMMETRY
statemen
t,
w
e
tak
e
the
symmetry
set

to
b
e
the
empt
y
set.)
T
o
explain
what
TLC
do
es
when
giv
en
an
arbitrary
symmetry
set
,
I
need
a
few
more
denitions.
If

is
a
sequence
h

1;
:
:
:
;

n
i
of
p
erm
utations
in
,
let
s

equal
(:
:
:
((s

1
)

2
)
:
:
:)

n
.
(If

is
the
empt
y
sequence,
then
s

is
dened
to
equal
s
.)
Dene
the
e
quivalenc
e
class
b
s
of
a
state
s
to
b
e
the
set
of
states
s

for
all
sequences

of
p
erm
utations
in
.
F
or
an
y
state
s
,
TLC
k
eeps
only
a
single
elemen
t
of
b
s
in
U
and
G
.
This
is
accomplished
b
y
the
follo
wing
mo
dications
to
the
algorithm
on
pages
241{242.
In
step
2(b),
TLC
adds
the
state
s
to
U
and
G
only
if
U
and
G
do
not
already
con
tain
a
state
in
b
s
.
Step
3(d)ii
is
c
hanged
to
A.
If
no
elemen
t
in
b
t
is
in
G
,
then
add
t
to
the
tail
of
U
and
add
the
no
de
t
and
the
edge
t
!
t
to
G
.
B.
Add
the
edge
s
!
tt
to
G
,
where
tt
is
the
unique
elemen
t
of
b
t
that
is
(no
w)
in
G
.
When
a
VIEW
statemen
t
app
ears
in
the
conguration
le,
these
c
hanges
are
mo
died
as
describ
ed
in
Section
14.3.3
ab
o
v
e
so
that
views
rather
than
states
are
put
in
G
.
If
the
sp
ecication
and
the
prop
erties
b
eing
c
hec
k
ed
are,
indeed,
symmetric
with
resp
ect
to
all
p
erm
utations
in
the
symmetry
set,
then
TLC's
Invariant
,
Implie
dInit
,
and
Implie
dA
ction
c
hec
king
will
nd
and
correctly
rep
ort
an
y
er-
ror
that
they
w
ould
ha
v
e
found
had
the
SYMMETRY
statemen
t
b
een
omitted.
Ho
w
ev
er,
TLC
ma
y
p
erform
Implie
dT
emp
or
al
c
hec
king
incorrectly|it
ma
y
miss
errors,
rep
ort
an
error
that
do
esn't
exist,
or
rep
ort
a
real
error
with
an
incor-
rect
coun
terexample.
So,
y
ou
should
do
Implie
dT
emp
or
al
c
hec
king
when
using
a
SYMMETRY
statemen
t
only
if
y
ou
understand
exactly
what
TLC
is
doing.

14.3.
HO
W
TLC
CHECKS
PR
OPER
TIES
247
If
the
sp
ecication
and
prop
erties
are
not
symmetric
with
resp
ect
to
all
p
erm
utations
in
the
symmetry
set,
then
TLC
ma
y
b
e
unable
to
prin
t
an
error
trace
if
it
do
es
nd
an
error.
In
that
case,
it
will
prin
t
the
error
message
Failed
to
recover
the
state
from
its
fingerprint.
The
symmetry
set
is
used
only
in
mo
del-c
hec
king
mo
de.
TLC
ignores
it
in
sim
ulation
mo
de.
14.3.5
Limitations
of
Liv
eness
Chec
king
If
a
sp
ecication
violates
a
safet
y
prop
ert
y
,
then
there
is
a
nite
b
eha
vior
that
Safet
y
prop
erties
w
ere
dened
on
page
87.
displa
ys
the
violation.
That
b
eha
vior
can
b
e
generated
with
a
nite
mo
del.
It
is
therefore,
in
principle,
p
ossible
to
disco
v
er
the
violation
with
TLC.
It
ma
y
b
e
imp
ossible
to
disco
v
er
a
violation
of
a
liv
eness
prop
ert
y
with
an
y
nite
mo
del.
T
o
see
wh
y
,
consider
the
follo
wing
simple
sp
ecication
EvenSp
e
c
that
starts
with
x
equal
to
zero
and
rep
eatedly
incremen
ts
it
b
y
2:
EvenSp
e
c

=
(x
=
0)
^
2[x
0
=
x
+
2]
x
^
WF
x
(x
0
=
x
+
2)
Ob
viously
,
x
nev
er
equals
1
in
an
y
b
eha
vior
satisfying
EvenSp
e
c
.
So,
EvenSp
e
c
do
es
not
satisfy
the
liv
eness
prop
ert
y
3(x
=
1).
Supp
ose
w
e
ask
TLC
to
c
hec
k
if
EvenSp
e
c
implies
3(x
=
1).
T
o
get
TLC
to
terminate,
w
e
m
ust
pro
vide
a
constrain
t
that
limits
it
to
generating
a
nite
n
um
b
er
of
reac
hable
states.
All
the
innite
b
eha
viors
satisfying
(x
=
0)
^
2[x
0
=
x
+
2]
x
that
TLC
generates
will
then
end
in
an
innite
n
um
b
er
of
stuttering
steps.
In
an
y
suc
h
b
eha
vior,
action
x
0
=
x
+
2
is
alw
a
ys
enabled,
but
only
a
nite
n
um
b
er
of
x
0
=
x
+
2
steps
o
ccur,
so
WF
x
(x
0
=
x
+
2)
is
false.
TLC
will
therefore
not
rep
ort
an
error
b
ecause
the
form
ula
WF
x
(x
0
=
x
+
2)
)
3(x
=
1)
is
satised
b
y
all
the
innite
b
eha
viors
it
generates.
When
doing
temp
oral
c
hec
king,
mak
e
sure
that
y
our
mo
del
will
p
ermit
in-
nite
b
eha
viors
that
satisfy
the
sp
ecication's
liv
eness
condition.
F
or
example,
consider
the
nite
mo
del
of
the
alternating
bit
proto
col
sp
ecication
dened
b
y
the
conguration
le
of
Figure
14.3
on
page
227.
Y
ou
should
con
vince
y
ourself
that
it
allo
ws
innite
b
eha
viors
that
satisfy
form
ula
ABF
airness
.
It's
a
go
o
d
idea
to
v
erify
that
TLC
is
p
erforming
the
liv
eness
c
hec
king
y
ou
exp
ect.
Ha
v
e
it
c
hec
k
a
liv
eness
prop
ert
y
that
the
sp
ecication
do
es
not
satisfy
and
mak
e
sure
it
rep
orts
an
error.

248
CHAPTER
14.
THE
TLC
MODEL
CHECKER
module
TLC
local
inst
ance
Natur
als
The
k
eyw
ord
local
means
that
denitions
from
the
instan
tiated
mo
dule
are
not
obtained
b
y
a
mo
dule
that
extends
TLC
.
local
inst
ance
Se
quenc
es
OPERA
TORS
F
OR
DEBUGGING
Print
(out
;
val
)

=
val
Causes
TLC
to
prin
t
the
v
alues
out
and
val
.
Assert
(val
;
out
)

=
if
val
=
tr
ue
then
tr
ue
else
choose
v
:
tr
ue
Causes
TLC
to
rep
ort
an
error
and
prin
t
out
if
val
is
not
true.
JavaTime

=
choose
n
:
n
2
Nat
Causes
TLC
to
prin
t
the
curren
t
time,
in
milliseconds
elapsed
since
00:00
on
1
Jan
1970
UT,
mo
dulo
2
31
.
OPERA
TORS
F
OR
REPRESENTING
FUNCTIONS
AND
SETS
OF
PERMUT
A
TIONS
d
:>
e

=
[x
2
fd
g
7!
e
]
f
@@
g

=
[x
2
(domain
f
)
[
(domain
g
)
7!
if
x
2
domain
f
then
f
[x
]
else
g
[x
]]
The
function
f
with
domain
fd
1
;
:
:
:
;
d
n
g
suc
h
that
f
[d
i
]
=
e
i
,
for
i
=
1;
:
:
:
;
n
can
b
e
written
d
1
:>
e
1
@@
:
:
:
@@
d
n
:>
e
n
Permutations
(S
)

=
ff
2
[S
!
S
]
:
8
w
2
S
:
9
v
2
S
:
f
[v
]
=
w
g
The
set
of
p
erm
utations
of
S
.
AN
OPERA
TOR
F
OR
SOR
TING
SortSe
q
(s
;

)

=
The
result
of
sorting
sequence
s
according
to
the
ordering
.
let
Perm

=
choose
p
2
Permutations
(1
:
:
L
en
(s
))
:
8
i
;
j
2
1
:
:
L
en
(s
)
:
(i
<
j
)
)
(s
[p
[i
]]

s
[p
[j
]])
_
(s
[p
[i
]]
=
s
[p
[j
]])
in
[i
2
1
:
:
L
en
(s
)
7!
s
[Perm
[i
]]]
Figure
14.5:
The
standard
mo
dule
TLC.
14.4
The
TLC
Mo
dule
The
standard
TLC
mo
dule,
in
Figure
14.5
on
this
page,
denes
op
erators
that
are
handy
when
using
TLC.
The
mo
dule
on
whic
h
y
ou
run
TLC
usually
ex-
tends
the
TLC
mo
dule,
whic
h
is
o
v
erridden
b
y
its
Ja
v
a
implemen
tation.
Mo
dule
o
v
erriding
is
explained
ab
o
v
e
in
Section
14.2.5.
Mo
dule
TLC
b
egins
with
the
statemen
t
local
inst
ance
Natur
als
As
explained
on
page
171,
this
is
lik
e
an
extends
statemen
t,
except
that
the
denitions
included
from
the
Natur
als
mo
dule
are
not
obtained
b
y
an
y
other
mo
dule
that
extends
or
instan
tiates
mo
dule
TLC
.
Similarly
,
the
next
statemen
t
lo
cally
instan
tiates
the
Se
quenc
es
mo
dule.

14.4.
THE
TLC
MODULE
249
Mo
dule
TLC
next
denes
three
op
erators
Print
,
Assert
,
and
JavaTime
.
They
are
of
no
use
except
in
running
TLC,
when
they
can
help
y
ou
trac
k
do
wn
problems.
The
op
erator
Print
is
dened
so
that
Print
(out
;
val
)
equals
val
.
But
when
TLC
ev
aluates
this
expression,
it
prin
ts
the
v
alues
of
out
and
val
.
Y
ou
can
add
Print
expressions
to
a
sp
ecication
to
help
lo
cate
an
error.
F
or
example,
if
y
our
sp
ecication
con
tains
^
Print
(\a"
;
tr
ue
)
^
P
^
Print
(\b"
;
tr
ue
)
and
TLC
prin
ts
the
"a"
but
not
the
"b"
b
efore
rep
orting
an
error,
then
the
error
happ
ened
while
TLC
w
as
ev
aluating
P
.
If
y
ou
kno
w
where
the
error
is
but
don't
kno
w
wh
y
it's
o
ccurring,
y
ou
can
add
Print
expressions
to
giv
e
y
ou
more
information
ab
out
what
v
alues
TLC
has
computed.
T
o
understand
what
gets
prin
ted
when,
y
ou
m
ust
kno
w
ho
w
TLC
ev
aluates
expressions,
whic
h
is
explained
ab
o
v
e
in
Sections
14.2
and
14.3.
TLC
usually
ev
aluates
an
expression
man
y
times,
so
inserting
a
Print
expression
in
the
sp
ec-
ication
can
pro
duce
a
lot
of
output.
One
w
a
y
to
limit
the
amoun
t
of
output
is
to
put
the
Print
expression
inside
an
if/then
expression,
so
it
is
executed
only
in
in
teresting
cases.
The
TLC
mo
dule
next
denes
the
op
erator
Assert
so
Assert
(val
;
out
)
equals
tr
ue
if
val
equals
tr
ue.
If
val
do
es
not
equal
tr
ue,
ev
aluating
Assert
(val
;
out
)
causes
TLC
to
prin
t
the
v
alue
of
out
and
to
halt.
(In
this
case,
the
v
alue
of
Assert
(val
;
out
)
is
irrelev
an
t.)
Next,
the
op
erator
JavaTime
is
dened
to
equal
an
arbitrary
natural
n
um
b
er.
Ho
w
ev
er,
TLC
do
es
not
ob
ey
the
denition
of
JavaTime
when
ev
aluating
it.
Instead,
ev
aluating
JavaTime
yields
the
time
at
whic
h
the
ev
aluation
tak
es
place,
measured
in
milliseconds
elapsed
since
00:00
Univ
ersal
Time
on
1
Jan
uary
1970,
mo
dulo
2
31
.
If
TLC
is
generating
states
slo
wly
,
using
the
JavaTime
op
erator
in
conjunction
with
Print
expressions
can
help
y
ou
understand
wh
y
.
If
TLC
is
sp
ending
to
o
m
uc
h
time
ev
aluating
an
op
erator,
y
ou
ma
y
b
e
able
to
replace
the
op
erator's
denition
with
an
equiv
alen
t
one
that
TLC
can
ev
aluate
more
ecien
tly
.
(See
Section
14.2.3
on
page
234.)
The
TLC
mo
dule
next
denes
the
op
erators
:>
and
@@
so
that
the
expression
d
1
:>
e
1
@@
:
:
:
@@
d
n
:>
e
n
is
the
function
f
with
domain
fd
1
;
:
:
:
;
d
n
g
suc
h
that
f
[d
i
]
=
e
i
,
for
i
=
1;
:
:
:
;
n
.
F
or
example,
the
sequence
h
\ab"
;
\cd"
i,
whic
h
is
a
function
with
domain
f1;
2g,
can
b
e
written
as
1
:>
"ab"
@@
2
:>
"cd"

250
CHAPTER
14.
THE
TLC
MODEL
CHECKER
TLC
uses
these
op
erators
to
represen
t
function
v
alues
that
it
prin
ts
when
ev
alu-
ating
a
Print
expression
or
rep
orting
an
error.
Ho
w
ev
er,
it
usually
prin
ts
v
alues
the
w
a
y
they
app
ear
in
the
sp
ecication,
so
it
usually
prin
ts
a
sequence
as
a
sequence,
not
in
terms
of
the
:>
and
@@
op
erators.
Next
comes
the
denition
of
Permutations
(S
)
to
b
e
the
set
of
all
p
erm
u-
tations
of
S
,
if
S
is
a
nite
set.
The
Permutations
op
erator
can
b
e
used
to
sp
ecify
a
set
of
p
erm
utations
for
the
SYMMETRY
statemen
t
describ
ed
in
Sec-
tion
14.3.4
ab
o
v
e.
More
complicated
symmetries
can
b
e
expressed
b
y
dening
a
set
f
1
;
:
:
:
;

n
g
of
p
erm
utations,
where
eac
h

i
is
written
as
an
explicit
func-
tion
using
the
:>
and
@@
op
erators.
F
or
example,
consider
a
sp
ecication
of
a
memory
system
in
whic
h
eac
h
address
is
in
some
w
a
y
asso
ciated
with
a
pro-
cessor.
The
sp
ecication
w
ould
b
e
symmetric
under
t
w
o
kinds
of
p
erm
utations:
ones
that
p
erm
ute
addresses
asso
ciated
with
the
same
pro
cessor,
and
ones
that
p
erm
ute
the
pro
cessors
along
with
their
asso
ciated
addresses.
Supp
ose
w
e
tell
TLC
to
use
t
w
o
pro
cessors
and
four
addresses,
where
addresses
a
11
and
a
12
are
asso
ciated
with
pro
cessor
p
1
and
addresses
a
21
and
a
22
are
asso
ciated
with
pro
cessor
p
2.
W
e
can
get
TLC
to
tak
e
adv
an
tage
of
the
symmetries
b
y
giving
it
the
follo
wing
set
of
p
erm
utations
as
the
symmetry
set:
Permutations
(fa
11;
a
12g)
[
fp
1
:>
p
2
@@
p
2
:>
p
1
@@
a
11
:>
a
21
@@
a
21
:>
a
11
@@
a
12
:>
a
22
@@
a
22
:>
a
12g
The
p
erm
utation
p
1
:>
p
2
@@
:
:
:
@@
a
22
:>
a
12
in
terc
hanges
the
pro
cessors
and
their
asso
ciated
addresses.
The
p
erm
utation
that
just
in
terc
hanges
a
21
and
a
22
need
not
b
e
sp
ecied
explicitly
b
ecause
it
is
obtained
b
y
in
terc
hang-
ing
the
pro
cessors,
in
terc
hanging
a
11
and
a
12,
and
in
terc
hanging
the
pro
cessors
again.
The
TLC
mo
dule
ends
b
y
dening
the
op
erator
SortSe
q
,
whic
h
can
b
e
used
to
replace
op
erator
denitions
with
ones
that
TLC
can
ev
aluate
more
ecien
tly
.
If
s
is
a
nite
sequence
and

is
a
total
ordering
relation
on
its
elemen
ts,
then
SortSe
q
(s
;
)
is
the
sequence
obtained
from
s
b
y
sorting
its
elemen
ts
accord-
ing
to
.
F
or
example,
SortSe
q
(h
3;
1;
3;
8
i;
>)
equals
h
8;
3;
3;
1
i.
The
Ja
v
a
implemen
tation
of
SortSe
q
allo
ws
TLC
to
ev
aluate
it
more
ecien
tly
than
a
user-dened
sorting
op
erator.
F
or
example,
here's
ho
w
w
e
can
use
SortSe
q
to
dene
an
op
erator
F
astSort
to
replace
the
Sort
op
erator
dened
on
page
235.
F
astSort
(S
)

=
let
MakeSe
q
[SS
2
subset
S
]

=
if
SS
=
fg
then
h
i
else
let
ss

=
choose
ss
2
SS
:
tr
ue
in
App
end
(MakeSe
q
[SS
n
fss
g];
ss
)
in
SortSe
q
(MakeSe
q
[S
];
<)

14.5.
HO
W
TO
USE
TLC
251
14.5
Ho
w
to
Use
TLC
14.5.1
Running
TLC
Exactly
ho
w
y
ou
run
TLC
dep
ends
on
what
op
erating
system
y
ou
are
using
and
ho
w
it
is
congured.
Y
ou
will
probably
t
yp
e
a
command
of
the
form
pr
o
gr
am
name
options
sp
e
c
le
where
pr
o
gr
am
name
is
sp
ecic
to
y
our
system.
It
migh
t
b
e
java
tlatk.TLC
.
sp
e
c
le
is
the
name
of
the
le
con
taining
the
TLA
+
sp
ecication.
Eac
h
TLA
+
mo
dule
named
M
that
app
ears
in
the
sp
ecication
m
ust
b
e
in
a
separate
le
named
M
.tla.
The
extension
.tla
ma
y
b
e
omitted
from
sp
e
c
le
.
options
is
a
sequence
consisting
of
zero
or
more
of
the
follo
wing
options:
-deadlock
T
ells
TLC
not
to
c
hec
k
for
deadlo
c
k.
Unless
this
option
is
sp
ecied,
TLC
will
stop
if
it
nds
a
deadlo
c
k|that
is,
a
reac
hable
state
with
no
successor
state.
-simulate
T
ells
TLC
to
run
in
sim
ulation
mo
de,
generating
randomly
c
hosen
b
e-
ha
viors,
instead
of
generating
all
reac
hable
states.
(See
Section
14.3.2
ab
o
v
e.)
-depth
num
This
option
causes
TLC
to
generate
b
eha
viors
of
length
at
most
num
in
sim
ulation
mo
de.
Without
this
option,
TLC
will
generate
runs
of
length
at
most
100.
This
option
is
meaningful
only
when
the
simulate
option
is
used.
-seed
num
In
sim
ulation
mo
de,
the
b
eha
viors
generated
b
y
TLC
are
determined
b
y
the
initial
seed
giv
en
to
a
pseudorandom
n
um
b
er
generator.
Nor-
mally
,
the
seed
is
generated
randomly
.
This
option
causes
TLC
to
let
the
seed
b
e
num
,
whic
h
m
ust
b
e
an
in
teger
from
 2
63
to
2
63
 1.
Running
TLC
t
wice
in
sim
ulation
mo
de
with
the
same
seed
and
aril
(see
the
aril
option
b
elo
w)
will
pro
duce
iden
tical
results.
This
option
is
meaningful
only
when
using
the
simulate
option.
-aril
num
This
option
causes
TLC
to
use
num
as
the
aril
in
sim
ulation
mo
de.
The
aril
is
a
mo
dier
of
the
initial
seed.
When
TLC
nds
an
error
in
sim
ulation
mo
de,
it
prin
ts
out
b
oth
the
initial
seed
and
an
aril

252
CHAPTER
14.
THE
TLC
MODEL
CHECKER
n
um
b
er.
Using
this
initial
seed
and
aril
will
cause
the
rst
trace
gen-
erated
to
b
e
that
error
trace.
Adding
Print
expressions
will
usually
not
c
hange
the
order
in
whic
h
TLC
generates
traces.
So,
if
the
trace
do
esn't
tell
y
ou
what
w
en
t
wrong,
y
ou
can
try
running
TLC
again
on
just
that
trace
to
prin
t
out
additional
information.
-coverage
num
This
option
causes
TLC
to
prin
t
\co
v
erage"
information
ev
ery
num
min
utes
and
at
the
end
of
its
execution.
F
or
ev
ery
action
conjunct
that
\assigns
a
v
alue"
to
a
v
ariable,
TLC
prin
ts
the
n
um
b
er
of
times
that
conjunct
has
actually
b
een
used
in
constructing
a
new
state.
The
v
alues
it
prin
ts
ma
y
not
b
e
accurate,
but
their
magnitude
can
pro
vide
useful
information.
In
particular,
a
v
alue
of
0
indicates
part
of
the
next-state
action
that
w
as
nev
er
\executed".
This
migh
t
indicate
an
error
in
the
sp
ecication,
or
it
migh
t
mean
that
the
mo
del
TLC
is
c
hec
king
is
to
o
small
to
exercise
that
part
of
the
action.
-recover
run
id
This
option
causes
TLC
to
start
executing
the
sp
ecication
not
from
the
b
eginning,
but
from
where
it
left
o
at
the
last
c
hec
kp
oin
t.
When
TLC
tak
es
a
c
hec
kp
oin
t,
it
prin
ts
the
run
iden
tier.
(That
iden
tier
is
the
same
throughout
an
execution
of
TLC.)
The
v
alue
of
run
id
should
b
e
that
run
iden
tier.
-cleanup
TLC
creates
a
n
um
b
er
of
les
when
it
runs.
When
it
completes,
it
erases
all
of
them.
If
TLC
nds
an
error,
or
if
y
ou
stop
it
b
efore
it
nishes,
TLC
can
lea
v
e
some
large
les
around.
The
cle
anup
option
causes
TLC
to
delete
all
les
created
b
y
previous
runs.
Do
not
use
this
option
if
y
ou
are
curren
tly
running
another
cop
y
of
TLC
in
the
same
directory;
if
y
ou
do,
it
can
cause
the
other
cop
y
to
fail.
-difftrace
num
When
TLC
nds
an
error,
it
prin
ts
an
error
trace.
Normally
,
that
trace
is
prin
ted
as
a
sequence
of
complete
states,
where
a
state
lists
the
v
alues
of
all
declared
v
ariables.
The
ditr
ac
e
option
causes
TLC
to
prin
t
an
abridged
v
ersion
of
eac
h
state,
listing
only
the
v
ariables
whose
v
alues
are
dieren
t
than
in
the
preceding
state.
This
mak
es
it
easier
to
see
what
is
happ
ening
in
eac
h
step,
but
harder
to
nd
the
complete
state.
-terse
Normally
,
TLC
completely
expands
v
alues
that
app
ear
in
error
mes-
sages
or
in
the
output
from
ev
aluating
Print
expressions.
The
terse
option
causes
TLC
instead
to
prin
t
partially
ev
aluated,
shorter
v
er-
sions
of
these
v
alues.

14.5.
HO
W
TO
USE
TLC
253
-workers
num
Steps
3(b){(d)
of
the
TLC
execution
algorithm
describ
ed
on
pages
241{242
can
b
e
sp
eeded
up
on
a
m
ultipro
cessor
computer
b
y
the
use
of
m
ultiple
threads.
This
option
causes
TLC
to
use
num
threads
when
nding
reac
hable
states.
There
is
no
reason
to
use
more
threads
than
there
are
actual
pro
cessors
on
y
our
computer.
If
the
option
is
omitted,
TLC
uses
a
single
thread.
-config
c
ong
le
Sp
ecies
that
the
conguration
le
is
named
c
ong
le
,
whic
h
m
ust
b
e
a
le
with
extension
.cfg.
The
extension
.cfg
ma
y
b
e
omitted
from
c
ong
le
.
If
this
option
is
omitted,
the
conguration
le
is
assumed
to
ha
v
e
the
same
name
as
sp
e
c
le
,
except
with
the
extension
.cfg.
-nowarning
There
are
TLA
+
expressions
that
are
legal
but
are
sucien
tly
unlik
ely
that
their
presence
probably
indicates
an
error.
F
or
example,
the
expression
[f
ex
cept
!
[v
]
=
e
]
is
probably
incorrect
if
v
is
not
an
elemen
t
of
the
domain
of
f
.
(In
this
case,
the
expression
just
equals
f
.)
TLC
normally
issues
a
w
arning
when
it
encoun
ters
suc
h
an
unlik
ely
expression;
this
option
suppresses
these
w
arnings.
14.5.2
Debugging
a
Sp
ecication
When
y
ou
write
a
sp
ecication,
it
usually
con
tains
errors.
The
purp
ose
of
run-
ning
TLC
is
to
nd
as
man
y
of
those
errors
as
p
ossible.
W
e
hop
e
an
error
in
the
sp
ecication
will
cause
TLC
to
rep
ort
an
error.
The
c
hallenge
of
debugging
is
to
nd
the
error
in
the
sp
ecication
that
caused
the
error
rep
orted
b
y
TLC.
Before
addressing
this
c
hallenge,
let's
rst
examine
TLC's
output
when
it
nds
no
error.
TLC's
Normal
Output
When
y
ou
run
TLC,
the
rst
thing
it
prin
ts
is
the
v
ersion
n
um
b
er
and
creation
date:
TLC's
messages
ma
y
dier
in
for-
mat
from
the
ones
describ
ed
here.
TLC
Version
2.12
of
26
May
2003
Alw
a
ys
include
this
information
when
rep
orting
an
y
problems
with
TLC.
Next,
TLC
describ
es
the
mo
de
in
whic
h
it's
b
eing
run.
The
p
ossibilities
are
Model-checking
in
whic
h
it
is
exhaustiv
ely
c
hec
king
all
reac
hable
states,
or

254
CHAPTER
14.
THE
TLC
MODEL
CHECKER
Running
Random
Simulation
with
seed
19018030140888511
11
.
in
whic
h
it
is
running
in
sim
ulation
mo
de,
using
the
indicated
seed.
(Seeds
are
describ
ed
on
pages
251{252.)
Let's
supp
ose
it's
running
in
mo
del-c
hec
king
mo
de.
If
y
ou
ask
ed
TLC
to
do
liv
eness
c
hec
king,
it
will
no
w
prin
t
something
lik
e
Implied-temporal
checking--relativ
e
complexity
=
8.
The
time
TLC
tak
es
for
liv
eness
c
hec
king
is
appro
ximately
prop
ortional
to
the
relativ
e
complexit
y
.
Ev
en
with
a
relativ
e
complexit
y
of
1,
c
hec
king
liv
eness
tak
es
longer
than
c
hec
king
safet
y
.
So,
if
the
relativ
e
complexit
y
is
not
small,
TLC
will
probably
tak
e
a
v
ery
long
time
to
complete,
unless
the
mo
del
is
v
ery
small.
In
sim
ulation
mo
de,
a
large
complexit
y
means
that
TLC
will
not
b
e
able
to
sim
ulate
v
ery
man
y
b
eha
viors.
The
relativ
e
complexit
y
dep
ends
on
the
n
um
b
er
of
terms
and
the
size
of
sets
b
eing
quan
tied
o
v
er
in
the
temp
oral
form
ulas.
TLC
next
prin
ts
a
message
lik
e
Finished
computing
initial
states:
4
states
generated,
with
2
of
them
distinct.
This
indicates
that,
when
ev
aluating
the
initial
predicate,
TLC
generated
4
states,
among
whic
h
there
w
ere
2
distinct
ones.
TLC
then
prin
ts
one
or
more
messages
suc
h
as
Progress(9):
2846
states
generated,
984
distinct
states
found.
856
states
left
on
queue.
This
message
indicates
that
TLC
has
th
us
far
constructed
a
state
graph
G
of
G
and
U
are
de-
scrib
ed
in
Sec-
tion
14.3.1
on
page
241.
diameter
2
9,
that
it
has
generated
and
examined
2846
states,
nding
984
distinct
ones,
and
that
the
queue
U
of
unexplored
states
con
tains
856
states.
After
running
for
a
while,
TLC
generates
these
progress
rep
orts
ab
out
once
ev
ery
v
e
min
utes.
F
or
most
sp
ecications,
the
n
um
b
er
of
states
on
the
queue
increases
monotonically
at
the
b
eginning
of
the
execution
and
decreases
monotonically
at
the
end.
The
progress
rep
orts
therefore
pro
vide
a
useful
guide
to
ho
w
m
uc
h
longer
the
execution
is
lik
ely
to
tak
e.
When
TLC
successfully
completes,
it
prin
ts
Model
checking
completed.
No
error
has
been
found.
It
then
prin
ts
something
lik
e
2
The
diameter
of
G
is
the
smallest
n
um
b
er
d
suc
h
that
ev
ery
state
in
G
can
b
e
reac
hed
from
an
initial
state
b
y
a
path
con
taining
at
most
d
states.
It
is
the
depth
TLC
has
reac
hed
in
its
breadth-rst
exploration
of
the
set
of
states.
When
using
m
ultiple
threads
(sp
ecied
with
the
workers
option),
the
diameter
TLC
rep
orts
ma
y
not
b
e
quite
correct.

14.5.
HO
W
TO
USE
TLC
255
Estimates
of
the
probability
that
TLC
did
not
check
all
reachable
states
because
two
distinct
states
had
the
same
fingerprint:
calculated
(optimistic):
.000003
based
on
the
actual
fingerprints:
.00007
As
explained
on
page
244,
these
are
TLC's
t
w
o
estimates
of
the
probabilit
y
of
a
ngerprin
t
collision.
Finally
,
TLC
prin
ts
a
message
lik
e
2846
states
generated,
984
distinct
states
found,
0
states
left
on
queue.
The
state
graph
has
diameter
15.
with
the
total
n
um
b
er
of
states
and
the
diameter
of
the
state
graph.
While
TLC
is
running,
it
ma
y
also
prin
t
a
message
suc
h
as
--
Checkpointing
run
states/99-05-20-1
5-4
7-
55
completed
This
indicates
that
it
has
written
a
c
hec
kp
oin
t
that
y
ou
can
use
to
restart
TLC
in
the
ev
en
t
of
a
computer
failure.
(As
explained
in
Section
14.5.3
on
page
260,
c
hec
kp
oin
ts
ha
v
e
other
uses
as
w
ell.)
The
run
iden
tier
states/99-05-20-1
5-
47
-55
is
used
with
the
r
e
c
over
option
to
restart
TLC
from
where
the
c
hec
kp
oin
t
w
as
tak
en.
If
only
part
of
this
message
w
as
prin
ted|for
example,
b
ecause
y
our
computer
crashed
while
TLC
w
as
taking
the
c
hec
kp
oin
t|there
is
a
sligh
t
c
hance
that
all
the
c
hec
kp
oin
ts
are
corrupted
and
y
ou
m
ust
start
TLC
again
from
the
b
eginning.
Error
Rep
orts
The
rst
problems
y
ou
nd
in
y
our
sp
ecication
will
probably
b
e
syn
tax
errors.
TLC
rep
orts
them
with
ParseException
in
parseSpec:
follo
w
ed
b
y
the
error
message
generated
b
y
the
Syn
tactic
Analyzer.
Chapter
12
explains
ho
w
to
in
terpret
the
analyzer's
error
messages.
Running
y
our
sp
eci-
cation
through
the
analyzer
as
y
ou
write
it
will
catc
h
a
lot
of
simple
errors
quic
kly
.
As
explained
in
Section
14.3.1
ab
o
v
e,
TLC
executes
three
basic
phases.
In
the
rst
phase,
it
c
hec
ks
assumptions;
in
the
second,
it
computes
the
initial
states;
and
in
the
third,
it
generates
the
successor
states
of
states
on
the
queue
U
of
unexplored
states.
Y
ou
can
tell
if
it
has
en
tered
the
third
phase
b
y
whether
or
not
it
has
prin
ted
the
\initial
states
computed"
message.

256
CHAPTER
14.
THE
TLC
MODEL
CHECKER
TLC's
most
straigh
tforw
ard
error
rep
ort
o
ccurs
when
it
nds
that
one
of
the
prop
erties
it
is
c
hec
king
do
es
not
hold.
Supp
ose
w
e
in
tro
duce
an
error
in
to
our
alternating
bit
sp
ecication
(Figure
14.1
on
pages
223
and
224)
b
y
replacing
the
rst
conjunct
of
the
in
v
arian
t
ABT
yp
eInv
with
^
msgQ
2
Se
q
(Data
)
TLC
quic
kly
nds
the
error
and
prin
ts
Invariant
ABTypeInv
is
violated
It
next
prin
ts
a
minimal-length
3
b
eha
vior
that
leads
to
the
state
not
satisfying
the
in
v
arian
t:
Note
that
TLC
in-
dicates
whic
h
part
of
the
next-state
action
allo
ws
the
step
that
pro
duces
eac
h
state.
The
behavior
up
to
this
point
is:
STATE
1:
<Initial
predicate>
/\
rBit
=
0
/\
sBit
=
0
/\
ackQ
=
<<
>>
/\
rcvd
=
d1
/\
sent
=
d1
/\
sAck
=
0
/\
msgQ
=
<<
>>
STATE
2:
<Action
at
line
66
in
AlternatingBit>
/\
rBit
=
0
/\
sBit
=
1
/\
ackQ
=
<<
>>
/\
rcvd
=
d1
/\
sent
=
d1
/\
sAck
=
0
/\
msgQ
=
<<
<<
1,
d1
>>
>>
TLC
prin
ts
eac
h
state
as
a
TLA
+
predicate
that
determines
the
state.
When
prin
ting
a
state,
TLC
describ
es
functions
using
the
op
erators
:>
and
@@
dened
in
the
TLC
mo
dule.
(See
Section
14.4
on
page
248.)
The
hardest
errors
to
lo
cate
are
usually
the
ones
detected
when
TLC
is
forced
to
ev
aluate
an
expression
that
it
can't
handle,
or
one
that
is
\silly"
b
ecause
its
v
alue
is
not
sp
ecied
b
y
the
seman
tics
of
TLA
+
.
As
an
example,
let's
in
tro
duce
a
t
ypical
\o-b
y-one"
error
in
to
the
alternating
bit
proto
col
b
y
replacing
the
second
conjunct
in
the
denition
of
L
ose
with
9
i
2
1
:
:
L
en
(q
)
:
q
0
=
[j
2
1
:
:
(L
en
(q
)
 1)
7!
if
j
<
i
then
q
[j
 1]
else
q
[j
]]
3
When
using
m
ultiple
threads,
it
is
p
ossible,
though
unlik
ely
,
for
there
to
b
e
a
shorter
b
eha
vior
that
also
violates
the
in
v
arian
t.

14.5.
HO
W
TO
USE
TLC
257
If
q
has
length
greater
than
1,
then
this
denes
L
ose
(q
)[1]
to
equal
q
[0],
whic
h
is
a
nonsensical
v
alue
if
q
is
a
sequence.
(The
domain
of
a
sequence
q
is
the
set
1
:
:
:
L
en
(q
),
whic
h
do
es
not
con
tain
0.)
Running
TLC
pro
duces
the
error
message
Error:
Applying
tuple
<<
<<
1,
d1
>>,
<<
1,
d1
>>
>>
to
integer
0
which
is
out
of
domain.
It
then
prin
ts
a
b
eha
vior
leading
to
the
error.
TLC
nds
the
error
when
ev
al-
uating
the
next-state
action
to
compute
the
successor
states
for
some
state
s
,
and
s
is
the
last
state
in
that
b
eha
vior.
Had
the
error
o
ccurred
when
ev
aluating
the
in
v
arian
t
or
the
implied-action,
TLC
w
ould
ha
v
e
b
een
ev
aluating
it
on
the
last
state
or
step
of
the
b
eha
vior.
Finally
,
TLC
prin
ts
the
lo
cation
of
the
error:
The
error
occurred
when
TLC
was
evaluating
the
nested
expressions
at
the
following
positions:
0.
Line
57,
column
7
to
line
59,
column
60
in
AlternatingBit
1.
Line
58,
column
55
to
line
58,
column
60
in
AlternatingBit
The
rst
p
osition
iden
ties
the
second
conjunct
of
the
denition
of
L
ose
;
the
second
iden
ties
the
expression
q
[j
 1].
This
tells
y
ou
that
the
error
o
ccurred
while
TLC
w
as
ev
aluating
q
[j
 1],
whic
h
it
w
as
doing
as
part
of
the
ev
aluation
of
the
second
conjunct
of
the
denition
of
L
ose
.
Y
ou
m
ust
infer
from
the
prin
ted
trace
that
it
w
as
ev
aluating
the
denition
of
L
ose
while
ev
aluating
the
action
L
oseMsg
.
In
general,
TLC
prin
ts
a
tree
of
nested
expressions|higher-lev
el
ones
rst.
It
seldom
lo
cates
the
error
as
precisely
as
y
ou
w
ould
lik
e;
often
it
just
narro
ws
it
do
wn
to
a
conjunct
or
disjunct
of
a
form
ula.
Y
ou
ma
y
need
to
insert
Print
expressions
to
lo
cate
the
problem.
See
the
discussion
on
page
259
for
further
advice
on
lo
cating
errors.
14.5.3
Hin
ts
on
Using
TLC
Eectiv
ely
Start
Small
The
constrain
t
and
the
assignmen
t
of
v
alues
to
the
constan
t
parameters
dene
a
mo
del
of
the
sp
ecication.
Ho
w
long
it
tak
es
TLC
to
c
hec
k
a
sp
ecication
dep
ends
on
the
sp
ecication
and
the
size
of
the
mo
del.
Running
on
a
600MHz
w
ork
station,
TLC
nds
ab
out
700
distinct
reac
hable
states
p
er
second
for
the
alternating
bit
proto
col
sp
ecication.
F
or
some
sp
ecications,
the
time
it
tak
es
TLC
to
generate
a
state
gro
ws
with
the
size
of
the
mo
del;
it
can
also
increase
as
the
generated
states
b
ecome
more
complicated.
F
or
some
sp
ecications
run
on
larger
mo
dels,
TLC
nds
few
er
than
one
reac
hable
state
p
er
second.

258
CHAPTER
14.
THE
TLC
MODEL
CHECKER
Y
ou
should
alw
a
ys
b
egin
testing
a
sp
ecication
with
a
tin
y
mo
del,
whic
h
TLC
can
c
hec
k
quic
kly
.
Let
sets
of
pro
cesses
and
of
data
v
alues
ha
v
e
only
one
elemen
t;
let
queues
b
e
of
length
one.
A
sp
ecication
that
has
not
b
een
tested
probably
has
lots
of
errors.
A
small
mo
del
will
quic
kly
catc
h
most
of
the
simple
ones.
When
a
v
ery
small
mo
del
rev
eals
no
more
errors,
y
ou
can
then
run
TLC
with
larger
mo
dels
to
try
to
catc
h
more
subtle
errors.
One
w
a
y
to
gure
out
ho
w
large
a
mo
del
TLC
can
handle
is
to
estimate
the
appro
ximate
n
um
b
er
of
reac
hable
states
as
a
function
of
the
parameters.
Ho
w
ev
er,
this
can
b
e
hard.
If
y
ou
can't
do
it,
increase
the
mo
del
size
v
ery
gradually
.
The
n
um
b
er
of
reac
hable
states
is
t
ypically
an
exp
onen
tial
function
of
the
mo
del's
parameters;
and
the
v
alue
of
a
b
gro
ws
v
ery
fast
with
increasing
v
alues
of
b
.
Man
y
systems
ha
v
e
errors
that
will
sho
w
up
only
on
mo
dels
to
o
large
for
TLC
to
c
hec
k
exhaustiv
ely
.
After
ha
ving
TLC
mo
del
c
hec
k
y
our
sp
ecication
on
as
large
a
mo
del
as
y
our
patience
allo
ws,
y
ou
can
run
it
in
sim
ulation
mo
de
on
larger
mo
dels.
Random
sim
ulation
is
not
an
eectiv
e
w
a
y
to
catc
h
subtle
errors,
but
it's
w
orth
trying;
y
ou
migh
t
get
luc
ky
.
Be
Suspicious
of
Success
Section
14.3.5
on
page
247
explains
wh
y
y
ou
should
b
e
suspicious
if
TLC
do
es
not
nd
a
violation
of
a
liv
eness
prop
ert
y;
the
nite
mo
del
ma
y
mask
errors.
Y
ou
should
also
b
e
suspicious
if
TLC
nds
no
error
when
c
hec
king
safet
y
prop-
erties.
It's
v
ery
easy
to
satisfy
a
safet
y
prop
ert
y
b
y
simply
doing
nothing.
F
or
example,
supp
ose
w
e
forgot
to
include
the
SndNewV
alue
action
in
the
alternat-
ing
bit
proto
col
sp
ecication's
next-state
action.
The
sender
w
ould
then
nev
er
try
to
send
an
y
v
alues.
But
the
resulting
sp
ecication
w
ould
still
satisfy
the
proto
col's
correctness
condition,
form
ula
ABCSp
e
c
of
mo
dule
ABCorr
e
ctness
.
(The
sp
ecication
do
esn't
require
that
v
alues
m
ust
b
e
sen
t.)
The
c
over
age
option
describ
ed
on
page
252
pro
vides
one
w
a
y
to
catc
h
suc
h
problems.
Another
w
a
y
is
to
mak
e
sure
that
TLC
nds
errors
in
prop
erties
that
should
b
e
violated.
F
or
example,
if
the
alternating
bit
proto
col
is
sending
messages,
then
the
v
alue
of
sent
should
c
hange.
Y
ou
can
v
erify
that
it
do
es
c
hange
b
y
c
hec
king
that
TLC
rep
orts
a
violation
of
the
prop
ert
y
8
d
2
Data
:
(sent
=
d
)
)
2(sent
=
d
)
A
go
o
d
sanit
y
c
hec
k
is
to
v
erify
that
TLC
nds
states
that
are
reac
hed
only
b
y
p
erforming
a
n
um
b
er
of
op
erations.
F
or
example,
the
cac
hing
memory
sp
eci-
cation
of
Section
5.6
should
ha
v
e
reac
hable
states
in
whic
h
a
particular
pro
cessor
has
b
oth
a
read
and
t
w
o
write
op
erations
in
the
memQ
queue.
Reac
hing
suc
h
a
state
requires
a
pro
cessor
to
p
erform
t
w
o
writes
follo
w
ed
b
y
a
read
to
an
un-
cac
hed
address.
W
e
can
v
erify
that
suc
h
a
state
is
reac
hable
b
y
ha
ving
TLC
nd
a
violation
of
an
in
v
arian
t
declaring
that
there
aren't
a
read
and
t
w
o
writes
for

14.5.
HO
W
TO
USE
TLC
259
the
same
pro
cessor
in
memQ
.
(Of
course,
this
requires
a
mo
del
in
whic
h
memQ
can
b
e
large
enough.)
Another
w
a
y
to
c
hec
k
that
certain
states
are
reac
hed
is
b
y
using
the
Print
op
erator
inside
an
if/then
expression
in
an
in
v
arian
t
to
prin
t
a
message
when
a
suitable
state
is
reac
hed.
Let
TLC
Help
Y
ou
Figure
Out
What
W
en
t
W
rong
When
TLC
rep
orts
that
an
in
v
arian
t
is
violated,
it
ma
y
not
b
e
ob
vious
what
part
of
the
in
v
arian
t
is
false.
If
y
ou
giv
e
separate
names
to
the
conjuncts
of
y
our
in
v
arian
t
and
list
them
separately
in
the
conguration
le's
INVARIANT
statemen
t,
TLC
will
tell
y
ou
whic
h
conjunct
is
false.
Ho
w
ev
er,
it
ma
y
b
e
hard
to
see
wh
y
ev
en
an
individual
conjunct
is
false.
Instead
of
sp
ending
a
lot
of
time
trying
to
gure
it
out
b
y
y
ourself,
it's
easier
to
add
Print
expressions
and
let
TLC
tell
y
ou
what's
going
wrong.
If
y
ou
rerun
TLC
from
the
b
eginning
with
a
lot
of
Print
expressions,
it
will
prin
t
output
for
ev
ery
state
it
c
hec
ks.
Instead,
y
ou
should
start
TLC
from
the
state
in
whic
h
the
in
v
arian
t
is
false.
Dene
a
predicate,
sa
y
Err
orState
,
that
describ
es
this
state,
and
mo
dify
the
conguration
le
to
use
Err
orState
as
the
initial
predicate.
W
riting
the
denition
of
Err
orState
is
easy|just
cop
y
the
last
state
in
TLC's
error
trace.
4
Y
ou
can
use
the
same
tric
k
if
an
y
safet
y
prop
ert
y
is
violated,
or
if
TLC
rep
orts
an
error
when
ev
aluating
the
next-state
action.
F
or
an
error
in
a
prop
ert
y
of
the
form
2[A]
v
,
rerun
TLC
using
the
next-to-last
state
in
the
error
trace
as
the
initial
predicate,
and
using
the
last
state
in
the
trace,
with
the
v
ariable
names
primed,
as
the
next-state
action.
T
o
nd
an
error
that
o
ccurs
when
ev
aluating
the
next-state
action,
use
the
last
state
in
the
error
trace
as
the
initial
predicate.
(In
this
case,
TLC
ma
y
nd
sev
eral
successor
states
b
efore
rep
orting
the
error.)
If
y
ou
ha
v
e
in
tro
duced
mo
del
v
alues
in
the
conguration
le,
they
will
un-
doubtedly
app
ear
in
the
states
prin
ted
b
y
TLC.
So,
if
y
ou
are
to
cop
y
those
states
in
to
the
mo
dule,
y
ou
will
ha
v
e
to
declare
the
mo
del
v
alues
as
constan
t
parameters
and
then
assign
to
eac
h
of
these
parameters
the
mo
del
v
alue
of
the
same
name.
F
or
example,
the
conguration
le
w
e
used
for
the
alternating
bit
proto
col
in
tro
duces
mo
del
v
alues
d
1
and
d
2.
So,
w
e
w
ould
add
to
mo
dule
MCA
lternatingBit
the
declaration
const
ants
d
1;
d
2
and
add
to
the
CONSTANT
statemen
t
of
the
conguration
le
the
assignmen
ts
d1
=
d1
d2
=
d2
whic
h
assign
to
the
constan
t
parameters
d
1
and
d
2
the
mo
del
v
alues
d1
and
d2,
resp
ectiv
ely
.
4
Dening
Err
orState
is
not
so
easy
if
y
ou
use
the
ditr
ac
e
option,
whic
h
is
a
reason
for
not
using
that
option.

260
CHAPTER
14.
THE
TLC
MODEL
CHECKER
Don't
Start
Ov
er
After
Ev
ery
Error
After
y
ou'v
e
eliminated
the
errors
that
are
easy
to
nd,
TLC
ma
y
ha
v
e
to
run
for
a
long
time
b
efore
nding
an
error.
V
ery
often,
it
tak
es
more
than
one
try
to
x
an
error
prop
erly
.
If
y
ou
start
TLC
from
the
b
eginning
after
correcting
an
error,
it
ma
y
run
for
a
long
time
only
to
rep
ort
that
y
ou
made
a
silly
mistak
e
in
the
correction.
If
the
error
w
as
disco
v
ered
when
taking
a
step
from
a
correct
state,
then
it's
a
go
o
d
idea
to
c
hec
k
y
our
correction
b
y
starting
TLC
from
that
state.
As
explained
ab
o
v
e,
y
ou
do
this
b
y
dening
a
new
initial
predicate
that
equals
the
state
prin
ted
b
y
TLC.
Another
w
a
y
to
a
v
oid
starting
from
scratc
h
after
an
error
is
b
y
using
c
hec
k-
p
oin
ts.
A
c
hec
kp
oin
t
sa
v
es
the
curren
t
state
graph
G
and
queue
U
of
unexplored
states.
It
do
es
not
sa
v
e
an
y
other
information
ab
out
the
sp
ecication.
Y
ou
can
restart
TLC
from
a
c
hec
kp
oin
t
ev
en
if
y
ou
ha
v
e
c
hanged
the
sp
ecication,
as
long
as
the
sp
ecication's
v
ariables
and
the
v
alues
that
they
can
assume
ha
v
en't
c
hanged.
More
precisely
,
y
ou
can
restart
from
a
c
hec
kp
oin
t
i
the
view
of
an
y
The
view
and
symmetry
set
are
dened
in
Sections
14.3.3
and
14.3.4,
resp
ectiv
ely
.
state
computed
b
efore
the
c
hec
kp
oin
t
has
not
c
hanged
and
the
symmetry
set
is
the
same.
When
y
ou
correct
an
error
that
TLC
found
after
running
for
a
long
time,
y
ou
ma
y
w
an
t
to
use
the
r
e
c
over
option
(page
252)
to
con
tin
ue
TLC
from
the
last
c
hec
kp
oin
t
instead
of
ha
ving
it
rec
hec
k
all
the
states
it
has
already
c
hec
k
ed.
5
Chec
k
Ev
erything
Y
ou
Can
V
erify
that
y
our
sp
ecication
satises
all
the
prop
erties
y
ou
think
it
should.
F
or
example,
y
ou
shouldn't
b
e
con
ten
t
to
c
hec
k
that
the
alternating
bit
pro-
to
col
sp
ecication
satises
the
higher-lev
el
sp
ecication
ABCSp
e
c
of
mo
dule
ABCorr
e
ctness
.
Y
ou
should
also
c
hec
k
lo
w
er-lev
el
prop
erties
that
y
ou
exp
ect
it
to
satisfy
.
One
suc
h
prop
ert
y
,
rev
ealed
b
y
studying
the
algorithm,
is
that
there
should
nev
er
b
e
more
than
t
w
o
dieren
t
messages
in
the
msgQ
queue.
So,
w
e
can
c
hec
k
that
the
follo
wing
predicate
is
an
in
v
arian
t:
Car
dinality
(
fmsgQ
[i
]
:
i
2
1
:
:
L
en
(msgQ
)
g
)

2
(W
e
m
ust
add
the
denition
of
Car
dinality
to
mo
dule
MCA
lternatingBit
b
y
adding
FiniteSets
to
its
extends
statemen
t.)
It's
a
go
o
d
idea
to
c
hec
k
as
man
y
in
v
ariance
prop
erties
as
y
ou
can.
If
y
ou
think
that
some
state
predicate
should
b
e
an
in
v
arian
t,
let
TLC
test
if
it
is.
Disco
v
ering
that
the
predicate
isn't
an
in
v
arian
t
ma
y
not
rev
eal
an
error,
but
it
will
probably
teac
h
y
ou
something
ab
out
y
our
sp
ecication.
5
Some
states
in
the
graph
G
ma
y
not
b
e
sa
v
ed
b
y
a
c
hec
kp
oin
t;
they
will
b
e
rec
hec
k
ed
when
restarting
from
the
c
hec
kp
oin
t.

14.5.
HO
W
TO
USE
TLC
261
Be
Creativ
e
Ev
en
if
a
sp
ecication
seems
to
lie
outside
the
realm
of
what
it
can
handle,
TLC
ma
y
b
e
able
to
help
c
hec
k
it.
F
or
example,
supp
ose
a
sp
ecication's
next-state
action
has
the
form
9
n
2
Nat
:
A(n
).
TLC
cannot
ev
aluate
quan
tication
o
v
er
an
innite
set,
so
it
apparen
tly
can't
deal
with
this
sp
ecication.
Ho
w
ev
er,
w
e
can
enable
TLC
to
ev
aluate
the
quan
tied
form
ula
b
y
using
the
conguration
le's
CONSTANT
statemen
t
to
replace
Nat
with
the
nite
set
0
:
:
n
,
for
some
n
.
Replacemen
t
is
explained
in
Sec-
tion
14.2.3.
This
replacemen
t
profoundly
c
hanges
the
sp
ecication's
meaning.
Ho
w
ev
er,
it
migh
t
nonetheless
allo
w
TLC
to
rev
eal
errors
in
the
sp
ecication.
Nev
er
forget
that
y
our
ob
jectiv
e
in
using
TLC
is
not
to
v
erify
that
a
sp
ecication
is
correct;
it's
to
nd
errors.
Use
TLC
as
a
TLA
+
Calculator
Misunderstanding
some
asp
ect
of
TLA
+
can
lead
to
errors
in
y
our
sp
ecication.
Use
TLC
to
c
hec
k
y
our
understanding
of
TLA
+
b
y
running
it
on
small
examples.
TLC
c
hec
ks
assumptions,
so
y
ou
can
turn
it
in
to
a
TLA
+
calculator
b
y
ha
ving
it
c
hec
k
a
mo
dule
with
no
sp
ecication,
only
assume
statemen
ts.
F
or
example,
if
g
equals
[f
ex
cept
!
[d
]
=
e
1
;
!
[d
]
=
e
2
]
what
is
the
v
alue
of
g
[d
]?
Y
ou
can
ask
TLC
b
y
letting
it
c
hec
k
a
mo
dule
con
taining
assume
let
f

=
[i
2
1
:
:
10
7!
1]
g

=
[f
ex
cept
!
[2]
=
3;
!
[2]
=
4]
in
Print
(g
[2];
tr
ue)
Y
ou
can
ha
v
e
it
v
erify
that
(F
)
G
)

(:F
_
G
)
is
a
tautology
b
y
c
hec
king
assume
8
F
;
G
2
boolean
:
(F
)
G
)

(:F
_
G
)
TLC
can
ev
en
lo
ok
for
coun
terexamples
to
a
conjecture.
Can
ev
ery
set
b
e
written
as
the
disjunction
of
t
w
o
dieren
t
sets?
Chec
k
it
for
all
subsets
of
1
:
:
4
with
assume
8
S
2
subset
(1
:
:
4)
:
if
9
T
;
U
2
subset
(1
:
:
4)
:
(T
6=
U
)
^
(S
=
T
[
U
)
then
tr
ue
else
Print
(S
;
tr
ue)
When
TLC
is
run
just
to
c
hec
k
assumptions,
it
ma
y
need
no
information
from
the
conguration
le.
But
y
ou
m
ust
pro
vide
a
conguration
le,
ev
en
if
that
le
is
empt
y
.

262
CHAPTER
14.
THE
TLC
MODEL
CHECKER
14.6
What
TLC
Do
esn't
Do
W
e
w
ould
lik
e
TLC
to
generate
all
the
b
eha
viors
that
satisfy
a
sp
ecication.
But
no
program
can
do
this
for
an
arbitrary
sp
ecication.
I
ha
v
e
already
men
tioned
some
limitations
of
TLC.
There
are
other
limitations
that
y
ou
ma
y
stum
ble
on.
One
of
them
is
that
the
Ja
v
a
classes
that
o
v
erride
the
Natur
als
and
Inte
gers
mo
dules
handle
only
n
um
b
ers
in
the
in
terv
al
 2
31
:
:
(2
31
 1);
TLC
rep
orts
an
error
if
an
y
computation
generates
a
v
alue
outside
this
in
terv
al.
TLC
can't
generate
all
b
eha
viors
satisfying
an
arbitrary
sp
ecication,
but
it
migh
t
ac
hiev
e
the
easier
goal
of
ensuring
that
ev
ery
b
eha
vior
it
do
es
generate
satises
the
sp
ecication.
Ho
w
ev
er,
for
reasons
of
eciency
,
TLC
do
esn't
alw
a
ys
meet
this
goal.
It
deviates
from
the
seman
tics
of
TLA
+
in
t
w
o
w
a
ys.
The
rst
deviation
is
that
TLC
do
esn't
preserv
e
the
precise
seman
tics
of
choose.
As
explained
in
Section
16.1,
if
S
equals
T
,
then
choose
x
2
S
:
P
should
equal
choose
x
2
T
:
P
.
Ho
w
ev
er,
TLC
guaran
tees
this
only
if
S
and
T
are
syn
tactically
the
same.
F
or
example,
TLC
migh
t
compute
dieren
t
v
alues
for
the
t
w
o
expressions
choose
x
2
f1;
2;
3g
:
x
<
3
choose
x
2
f3;
2;
1g
:
x
<
3
A
similar
violation
of
the
seman
tics
of
TLA
+
exists
with
case
expressions,
whose
seman
tics
are
dened
(in
Section
16.1.4)
in
terms
of
choose.
The
second
part
of
the
seman
tics
of
TLA
+
that
TLC
do
es
not
preserv
e
is
the
represen
tation
of
strings.
In
TLA
+
,
the
string
\ab
c"
is
a
three-elemen
t
sequence|that
is,
a
function
with
domain
f1;
2;
3g.
TLC
treats
strings
as
primitiv
e
v
alues,
not
as
functions.
It
th
us
considers
the
legal
TLA
+
expression
\ab
c"
[2]
to
b
e
an
error.
14.7
The
Fine
Prin
t
This
section
describ
es
in
detail
t
w
o
asp
ects
of
TLC
that
w
ere
sk
etc
hed
ab
o
v
e:
the
grammar
of
the
conguration
le,
and
the
precise
denition
of
TLC
v
alues.
14.7.1
The
Grammar
of
the
Conguration
File
The
grammar
of
TLC's
conguration
le
is
describ
ed
in
the
TLA
+
mo
dule
CongFileGr
ammar
in
Figure
14.6
on
the
next
page.
More
precisely
,
the
set
of
sen
tences
CongGr
ammar
:File
,
where
CongGr
ammar
is
dened
in
the
mo
dule,
describ
es
all
syn
tactically
correct
conguration
les
from
whic
h
commen
ts
ha
v
e
b
een
remo
v
ed.
The
CongFileGr
ammar
mo
dule
extends
the
BNF
Gr
ammars
mo
dule,
whic
h
is
explained
ab
o
v
e
in
Section
11.1.4
(page
179).
Here
are
some
additional
restrictions
on
the
conguration
le
that
are
not
sp
ecied
b
y
mo
dule
CongFileGr
ammar
.
There
can
b
e
at
most
one
INIT
and

14.7.
THE
FINE
PRINT
263
module
CongFileGr
ammar
extends
BNF
Gr
ammars
LEXEMES
L
etter

=
OneOf
(\ab
cdefghijklmnop
qrstuvwxyz_
ABCDEF
GHIJKLMNOPQRSTUVWXYZ")
Num

=
OneOf
(\0123456789"
)
L
etterOrNum

=
L
etter
[
Num
A
nyChar

=
L
etterOrNum
[
OneOf
(\

!
@
#
\
$
%
^
&

 +
=
j
(
)
f
g
[
]
,
:
;
`
'
<
>
.
?
/
")
SingularKW

=
f\SPECIFICA
TION"
;
\INIT"
;
\NEXT"
;
\VIEW";
\SYMMETRY"
g
Plur
alKW

=
f\CONSTRAINT"
;
\CONSTRAINTS"
;
\A
CTION-
CONSTRAINT"
;
\A
CTION-
CONSTRAINTS"
;
\INV
ARIANT"
;
\INV
ARIANTS"
;
\PROPERTY"
;
\PROPERTIES"
g
Keywor
d

=
SingularKW
[
Plur
alKW
[
f\CONST
ANT"
;
\CONST
ANTS"
g
A
nyIdent

=
L
etterOrNum

&
L
etter
&
L
etterOrNum

Ident

=
A
nyIdent
n
Keywor
d
CongGr
ammar

=
THE
BNF
GRAMMAR
let
P
(G
)

=
^
G
:File
::=
G
:Statement
+
^
G
:Statement
::=
T
ok
(SingularKW
)
&
T
ok
(Ident
)
j
T
ok
(Plur
alKW
)
&
T
ok
(Ident
)

j
T
ok
(f\CONST
ANT"
;
\CONST
ANTS"
g)
&
(G
:R
eplac
ement
j
G
:Assignment
)

^
G
:R
eplac
ement
::=
T
ok
(Ident
)
&
tok
(\< "
)
&
T
ok
(A
nyIdent
)
^
G
:Assignment
::=
T
ok
(Ident
)
&
tok
(\="
)
&
G
:IdentV
alue
^
G
:IdentV
alue
::=
T
ok
(A
nyIdent
)
j
G
:Numb
er
j
G
:String
j
tok
(\f"
)
&
(Nil
j
G
:IdentV
alue
&
(tok
(\,")
&
G
:IdentV
alue
)

)
&
tok
(\g"
)
^
G
:Numb
er
::=
(Nil
j
tok
(\ "
))
&
T
ok
(Num
+
)
^
G
:String
::=
tok
(\
"
"
)
&
T
ok
(A
nyChar

)
&
tok
(\
"
"
)
in
L
e
astGr
ammar
(P
)
Figure
14.6:
The
BNF
grammar
of
the
conguration
le.

264
CHAPTER
14.
THE
TLC
MODEL
CHECKER
one
NEXT
statemen
t.
There
can
b
e
one
SPECIFICATION
statemen
t,
but
only
if
there
is
no
INIT
or
NEXT
statemen
t.
(See
page
243
in
Section
14.3.1
for
conditions
on
when
these
statemen
ts
m
ust
app
ear.)
There
can
b
e
at
most
one
VIEW
statemen
t
and
at
most
one
SYMMETRY
statemen
t.
Multiple
instances
of
other
statemen
ts
are
allo
w
ed.
F
or
example,
the
t
w
o
statemen
ts
INVARIANT
Inv1
INVARIANT
Inv2
Inv3
sp
ecify
that
TLC
is
to
c
hec
k
the
three
in
v
arian
ts
Inv
1,
Inv
2,
and
Inv
3.
These
statemen
ts
are
equiv
alen
t
to
the
single
statemen
t
INVARIANT
Inv1
Inv2
Inv3
14.7.2
Comparable
TLC
V
alues
Section
14.2.1
(page
230)
describ
es
TLC
v
alues.
That
description
is
incomplete
b
ecause
it
do
es
not
dene
exactly
when
v
alues
are
comparable.
The
precise
denition
is
that
t
w
o
TLC
v
alues
are
comparable
i
the
follo
wing
rules
imply
that
they
are:
1.
Tw
o
primitiv
e
v
alues
are
comparable
i
they
ha
v
e
the
same
v
alue
t
yp
e.
This
rule
implies
that
\ab
c"
and
\123"
are
comparable,
but
\ab
c"
and
123
are
not.
2.
A
mo
del
v
alue
is
comparable
with
an
y
v
alue.
(It
is
equal
only
to
itself.)
3.
Tw
o
sets
are
comparable
if
they
ha
v
e
dieren
t
n
um
b
ers
of
elemen
ts,
or
if
they
ha
v
e
the
same
n
um
b
ers
of
elemen
ts
and
all
the
elemen
ts
in
one
set
are
comparable
with
all
the
elemen
ts
in
the
other.
This
rule
implies
that
f1g
and
f\a"
;
\b"
g
are
comparable
and
that
f1;
2g
and
f2;
3g
are
comparable.
Ho
w
ev
er,
f1;
2g
and
f\a"
;
\b"
g
are
not
com-
parable.
4.
Tw
o
functions
f
and
g
are
comparable
i
(i)
their
domains
are
comparable
and
(ii)
if
their
domains
are
equal,
then
f
[x
]
and
g
[x
]
are
comparable
for
ev
ery
elemen
t
x
in
their
domain.
This
rule
implies
that
h
1;
2
i
and
h
\a"
;
\b"
;
\c"
i
are
comparable,
and
that
h
1;
\a"
i
and
h
2;
\b
c"
i
are
comparable.
Ho
w
ev
er,
h
1;
2
i
and
h
\a";
\b"
i
are
not
comparable.

P
art
IV
The
TLA
+
Language
265


267
This
part
of
the
b
o
ok
describ
es
TLA
+
in
detail.
Chapter
15
explains
the
syn
tax;
Chapters
16
and
17
explain
the
seman
tics;
and
Chapter
18
con
tains
the
standard
mo
dules.
Almost
all
of
the
TLA
+
language
has
already
b
een
describ
ed|mainly
through
examples.
In
fact,
most
of
the
language
w
as
de-
scrib
ed
in
Chapters
1{6.
This
part
giv
es
complete
sp
ecication
of
the
language.
A
completely
formal
sp
ecication
of
TLA
+
w
ould
consist
of
a
formal
def-
inition
of
the
set
of
legal
(syn
tactically
w
ell-formed)
mo
dules,
and
a
precisely
dened
meaning
op
erator
that
assigns
to
ev
ery
legal
mo
dule
M
its
mathematical
meaning
[
[M
]
].
Suc
h
a
sp
ecication
w
ould
b
e
quite
long
and
of
limited
in
terest.
Instead,
I
ha
v
e
tried
to
pro
vide
a
fairly
informal
sp
ecication
that
is
detailed
enough
to
sho
w
mathematically
sophisticated
readers
ho
w
they
could
write
a
completely
formal
one.
These
c
hapters
are
hea
vy
going,
and
few
p
eople
will
w
an
t
to
read
them
completely
.
Ho
w
ev
er,
I
hop
e
they
can
serv
e
as
a
reference
man
ual
for
an
y
one
who
reads
or
writes
TLA
+
sp
ecications.
If
y
ou
ha
v
e
a
question
ab
out
the
ner
details
of
the
syn
tax
or
the
meaning
of
some
part
of
the
language,
y
ou
should
b
e
able
to
nd
the
answ
er
here.
T
ables
1{8
on
the
next
page
through
page
273
pro
vide
a
tin
y
reference
man-
ual.
T
ables
1{4
v
ery
briey
describ
e
all
the
built-in
op
erators
of
TLA
+
.
T
able
5
lists
all
the
user-denable
op
erator
sym
b
ols
and
indicates
whic
h
ones
are
already
used
b
y
the
standard
mo
dules.
It's
a
go
o
d
place
to
lo
ok
when
c
ho
osing
notation
for
y
our
sp
ecication.
T
able
6
giv
es
the
precedence
of
the
op
erators;
it
is
ex-
plained
in
Section
15.2.1
on
page
283.
T
able
7
lists
all
op
erators
dened
b
y
the
standard
mo
dules.
Finally
,
T
able
8
sho
ws
ho
w
to
t
yp
e
an
y
sym
b
ol
that
do
esn't
ha
v
e
an
ob
vious
asci
i
equiv
alen
t.

268
Logic
^
_
:
)

tr
ue
f
alse
boolean
[the
set
ftr
ue;
f
alseg]
8
x
:
p
9
x
:
p
8
x
2
S
:
p
(1)
9
x
2
S
:
p
(1)
choose
x
:
p
[An
x
satisfying
p
]
choose
x
2
S
:
p
[An
x
in
S
satisfying
p
]
Sets
=
6=
2
=
2
[
\

n
[set
dierence]
fe
1
;
:
:
:
;
e
n
g
[Set
consisting
of
elemen
ts
e
i
]
fx
2
S
:
p
g
(2)
[Set
of
elemen
ts
x
in
S
satisfying
p
]
fe
:
x
2
S
g
(1)
[Set
of
elemen
ts
e
suc
h
that
x
in
S
]
subset
S
[Set
of
subsets
of
S
]
union
S
[Union
of
all
elemen
ts
of
S
]
F
unctions
f
[e
]
[F
unction
application]
domain
f
[Domain
of
function
f
]
[x
2
S
7!
e
]
(1)
[F
unction
f
suc
h
that
f
[x
]
=
e
for
x
2
S
]
[S
!
T
]
[Set
of
functions
f
with
f
[x
]
2
T
for
x
2
S
]
[f
ex
cept
!
[e
1
]
=
e
2
]
(3)
[F
unction
b
f
equal
to
f
except
b
f
[e
1
]
=
e
2
]
Records
e
:h
[The
h
-eld
of
record
e
]
[h
1
7!
e
1
;
:
:
:
;
h
n
7!
e
n
]
[The
record
whose
h
i
eld
is
e
i
]
[h
1
:
S
1
;
:
:
:
;
h
n
:
S
n
]
[Set
of
all
records
with
h
i
eld
in
S
i
]
[r
ex
cept
!
:h
=
e
]
(3)
[Record
b
r
equal
to
r
except
b
r
:h
=
e
]
T
uples
e
[i
]
[The
i
th
comp
onen
t
of
tuple
e
]
h
e
1
;
:
:
:
;
e
n
i
[The
n
-tuple
whose
i
th
comp
onen
t
is
e
i
]
S
1

:
:
:

S
n
[The
set
of
all
n
-tuples
with
i
th
comp
onen
t
in
S
i
]
Strings
and
Num
b
ers
\c
1
.
.
.
c
n
"
[A
literal
string
of
n
c
haracters]
String
[The
set
of
all
strings]
d
1
:
:
:
d
n
d
1
:
:
:
d
n
:
d
n
+1
:
:
:
d
m
[Num
b
ers
(where
the
d
i
are
digits)]
(1)
x
2
S
ma
y
b
e
replaced
b
y
a
comma-separated
list
of
items
v
2
S
,
where
v
is
either
a
comma-separated
list
or
a
tuple
of
iden
tiers.
(2)
x
ma
y
b
e
an
iden
tier
or
tuple
of
iden
tiers.
(3)
!
[e
1
]
or
!
:h
ma
y
b
e
replaced
b
y
a
comma
separated
list
of
items
!
a
1



a
n
,
where
eac
h
a
i
is
[e
i
]
or
:h
i
.
T
able
1:
The
constan
t
op
erators.

269
if
p
then
e
1
else
e
2
[e
1
if
p
true,
else
e
2
]
case
p
1
!
e
1
2
:
:
:
2
p
n
!
e
n
[Some
e
i
suc
h
that
p
i
true]
case
p
1
!
e
1
2
:
:
:
2
p
n
!
e
n
2
other
!
e
[Some
e
i
suc
h
that
p
i
true,
or
e
if
all
p
i
are
false]
let
d
1

=
e
1
:
:
:
d
n

=
e
n
in
e
[e
in
the
con
text
of
the
denitions]
^
p
1
.
.
.
^
p
n
[the
conjunction
p
1
^
:
:
:
^
p
n
]
_
p
1
.
.
.
_
p
n
[the
disjunction
p
1
_
:
:
:
_
p
n
]
T
able
2:
Miscellaneous
constructs.
e
0
[The
v
alue
of
e
in
the
nal
state
of
a
step]
[A]
e
[A
_
(e
0
=
e
)]
h
A
i
e
[A
^
(e
0
6=
e
)]
enabled
A
[An
A
step
is
p
ossible]
unchanged
e
[e
0
=
e
]
A

B
[Comp
osition
of
actions]
T
able
3:
Action
op
erators.
2F
[F
is
alw
a
ys
true]
3F
[F
is
ev
en
tually
true]
WF
e
(A)
[W
eak
fairness
for
action
A]
SF
e
(A)
[Strong
fairness
for
action
A]
F
;
G
[F
leads
to
G
]
F
+
 .
G
[F
guaran
tees
G
]
9
9
9
9
9
9
x
:
F
[T
emp
oral
existen
tial
quan
tication
(hiding)]
8
8
8
8
8
8
x
:
F
[T
emp
oral
univ
ersal
quan
tication]
T
able
4:
T
emp
oral
op
erators.

270
Inx
Op
erators
+
(1)
 (1)

(1)
=
(2)

(3)
++

(1)
%
(1)
^
(1,4)
:
:
(1)
:
:
:
  
(5)
	
(5)




<
(1)
>
(1)

(1)

(1)
u
==




t
^^


<
:
:
>
(6)
&
&&
<
=
v
(5)
w
j
jj



?
%
%
`
a
j
=
=
j

##

'


=
$
$$
:
=
::=

:
=
??
!
!
/
o
]

@@
(6)
P
ostx
Op
erators
(7)
^+
^
^#
Prex
Op
erator
 (8)
(1)
Dened
b
y
the
Natur
als
,
Inte
gers
,
and
R
e
als
mo
dules.
(2)
Dened
b
y
the
R
e
als
mo
dule.
(3)
Dened
b
y
the
Se
quenc
es
mo
dule.
(4)
x
^y
is
prin
ted
as
x
y
.
(5)
Dened
b
y
the
Bags
mo
dule.
(6)
Dened
b
y
the
TLC
mo
dule.
(7)
e
^+
is
prin
ted
as
e
+
,
and
similarly
for
^
and
^#.
(8)
Dened
b
y
the
Inte
gers
and
R
e
als
mo
dules.
T
able
5:
User-denable
op
erator
sym
b
ols.

271
Prex
Op
erators
:
4{4
enabled
4{15
unchanged
4{15
2
4{15
3
4{15
subset
8{8
union
8{8
domain
9{9
 12{12
Inx
Op
erators
)
1{1
+
 .
2{2

2{2
;
2{2
^
3{3
(a)
_
3{3
(a)
6=
5{5
a
5{5
::=
5{5
:
=
5{5
<
5{5
=
5{5
=
j
5{5
>
5{5

5{5

5{5

=
5{5
:
=
5{5

5{5

5{5
2
5{5
=
2
5{5

5{5

5{5

5{5

5{5
/
5{5

5{5
'
5{5
<
5{5
v
5{5
=
5{5
w
5{5

5{5

5{5

5{5

5{5

5{5

5{5
`
5{5
j
=
5{5

(1)
5{14
(a)
@@
6{6
(a)
:
>
7{7
<
:
7{7
n
8{8
\
8{8
(a)
[
8{8
(a)
:
:
9{9
:
:
:
9{9
!
!
9{13
##
9{13
(a)
$
9{13
(a)
$$
9{13
(a)
??
9{13
(a)
u
9{13
(a)
t
9{13
(a)
]
9{13
(a)
o
9{14

10{10
(a)
+
10{10
(a)
++
10{10
(a)
%
10{11
%%
10{11
(a)
j
10{11
(a)
jj
10{11
(a)
	
11{11
(a)
 11{11
(a)
  11{11
(a)
&
13{13
(a)
&&
13{13
(a)

13{13
(a)

13{13

13{13
(a)

13{13
(a)

13{13
(a)
=
13{13
==
13{13

13{13
(a)

13{13
(a)

13{13

13{13
(a)
?
13{13
(a)
^
14{14
^^
14{14
.
(2)
17{17
(a)
P
ostx
Op
erators
^+
15{15
^*
15{15
^#
15{15
0
15{15
(1)
Action
comp
osition
(\cdot).
(2)
Record
eld
(p
erio
d).
T
able
6:
The
precedence
ranges
of
op
erators.
The
relativ
e
precedence
of
t
w
o
op
erators
is
unsp
ecied
if
their
ranges
o
v
erlap.
Left-asso
ciativ
e
op
erators
are
indicated
b
y
(a).

272
Mo
dules
Natur
als
,
Inte
gers
,
R
e
als
+
 (1)

=
(2)
^
(3)
:
:
Nat
R
e
al
(2)

%


<
>
Int
(4)
Innity
(2)
(1)
Only
inx
 is
dened
in
Natur
als
.
(2)
Dened
only
in
R
e
als
mo
dule.
(3)
Exp
onen
tiation.
(4)
Not
dened
in
Natur
als
mo
dule.
Mo
dule
Se
quenc
es

He
ad
Sele
ctSe
q
SubSe
q
App
end
L
en
Se
q
T
ail
Mo
dule
FiniteSets
IsFiniteSet
Car
dinality
Mo
dule
Bags

BagIn
CopiesIn
SubBag
	
BagOfA
l
l
EmptyBag
v
BagT
oSet
IsABag
BagCar
dinality
BagUnion
SetT
oBag
Mo
dule
R
e
alTime
R
TBound
R
Tnow
now
(declared
to
b
e
a
v
ariable)
Mo
dule
TLC
:>
@@
Print
Assert
JavaTime
Permutations
SortSe
q
T
able
7:
Op
erators
dened
in
the
standard
mo
dules.

273
^
/\
or
\land
:
~
or
\lnot
or
\neg
2
\in
h
<<
<
<

\leq
or
=<
or
<=

\ll

\prec

\preceq

\subseteq

\subset
<
\sqsubset
v
\sqsubseteq
`
|-
j
=
|=
!
->
\
\cap
or
\intersect
u
\sqcap

(+)
or
\oplus
	
(-)
or
\ominus

(.)
or
\odot

(\X)
or
\otimes

(/)
or
\oslash
9
\E
9
9
9
9
9
9
\EE
]
v
]_v
WF
v
WF_v
_
\/
or
\lor

<=>
or
\equiv
=
2
\notin
i
>>
>
>

\geq
or
>=

\gg

\succ

\succeq

\supseteq

\supset
=
\sqsupset
w
\sqsupseteq
a
-|
=
j
=|
 
<-
[
\cup
or
\union
t
\sqcup
]
\uplus

\X
or
\times
o
\wr
/
\propto
\s"
"s"
(1)
8
\A
8
8
8
8
8
8
\AA
i
v
>>_v
SF
v
SF_v
)
=>

=
==
6=
#
or
/=
2
[]
3
<>
;
~>
+
 .
-+->
7!
|->

\div

\cdot

\o
or
\circ

\bullet
?
\star

\bigcirc

\sim
'
\simeq

\asymp

\approx

=
\cong
:
=
\doteq
x
y
x^y
(2)
x
+
x^+
(2)
x

x^*
(2)
x
#
x^#
(2)
0
'
--------
(3)
--------
(3)
--------
(3)
========
(3)
(1)
s
is
a
sequence
of
c
haracters.
See
Section
16.1.10
on
page
307.
(2)
x
and
y
are
an
y
expressions.
(3)
a
sequence
of
four
or
more
-
or
=
c
haracters.
T
able
8:
The
asci
i
represen
tations
of
t
yp
eset
sym
b
ols.

274

Chapter
15
The
Syn
tax
of
TLA
+
This
b
o
ok
uses
the
asci
i
v
ersion
of
TLA
+
|the
v
ersion
based
on
the
asci
i
c
haracter
set.
One
can
dene
other
v
ersions
of
TLA
+
that
use
dieren
t
sets
of
c
haracters.
A
dieren
t
v
ersion
migh
t
allo
w
an
expression
lik
e

[

a
]

h
\
ca"
i.
Since
mathematical
form
ulas
lo
ok
prett
y
m
uc
h
the
same
in
most
languages,
the
basic
syn
tax
of
all
v
ersions
of
TLA
+
should
b
e
the
same.
Dieren
t
v
ersions
w
ould
dier
in
their
lexemes
and
in
the
iden
tiers
and
strings
they
allo
w.
This
c
hapter
describ
es
the
syn
tax
of
the
asci
i
v
ersion,
the
only
one
that
no
w
exists.
The
term
syntax
has
t
w
o
dieren
t
usages,
whic
h
I
will
somewhat
arbitrar-
ily
attribute
to
mathematicians
and
computer
scien
tists.
A
computer
scien
tist
w
ould
sa
y
that
h
a
;
a
i
is
a
syn
tactically
correct
TLA
+
expression.
A
mathemati-
cian
w
ould
sa
y
that
the
expression
is
syn
tactically
correct
i
it
app
ears
in
a
con
text
in
whic
h
a
is
dened
or
declared.
A
computer
scien
tist
w
ould
call
this
requiremen
t
a
semantic
rather
than
a
syn
tactic
condition.
A
mathematician
w
ould
sa
y
that
h
a
;
a
i
is
meaningless
if
a
isn't
dened
or
declared,
and
one
can't
talk
ab
out
the
seman
tics
of
a
meaningless
expression.
This
c
hapter
describ
es
the
syn
tax
of
TLA
+
,
in
the
computer
scien
tist's
sense
of
syn
tax.
The
\seman
tic"
part
of
the
syn
tax
is
sp
ecied
in
Chapters
16
and
17.
TLA
+
is
designed
to
b
e
easy
for
h
umans
to
read
and
write.
In
particu-
lar,
its
syn
tax
for
expressions
tries
to
capture
some
of
the
ric
hness
of
ordinary
mathematical
notation.
This
mak
es
a
precise
sp
ecication
of
the
syn
tax
rather
complicated.
Suc
h
a
sp
ecication
has
b
een
written
in
TLA
+
,
but
it's
quite
de-
tailed
and
y
ou
probably
don't
w
an
t
to
lo
ok
at
it
unless
y
ou
are
writing
a
parser
for
the
language.
This
c
hapter
giv
es
a
less
formal
description
of
the
syn
tax
that
should
answ
er
an
y
questions
lik
ely
to
arise
in
practice.
Section
15.1
sp
ecies
precisely
a
simple
grammar
that
ignores
some
asp
ects
of
the
syn
tax
suc
h
as
op-
erator
precedence,
inden
tation
rules
for
^
and
_
lists,
and
commen
ts.
These
other
asp
ects
are
explained
informally
in
Section
15.2.
Sections
15.1
and
15.2
describ
e
the
grammar
of
a
TLA
+
mo
dule
view
ed
as
a
sequence
of
lexemes,
where
275

276
CHAPTER
15.
THE
SYNT
AX
OF
TLA
+
a
lexeme
is
a
sequence
of
c
haracters
suc
h
as
|->
that
forms
an
atomic
unit
of
the
grammar.
Section
15.3
describ
es
ho
w
the
sequence
of
c
haracters
that
y
ou
actu-
ally
t
yp
e
are
turned
in
to
a
sequence
of
lexemes.
It
includes
the
precise
syn
tax
for
commen
ts.
This
c
hapter
describ
es
the
asci
i
syn
tax
for
TLA
+
sp
ecications.
T
yp
eset
v
ersions
of
sp
ecications
app
ear
in
this
b
o
ok.
F
or
example,
the
inx
op
erator
t
yp
eset
as

is
represen
ted
in
asci
i
as
\prec.
T
able
8
on
page
273
giv
es
the
corresp
ondence
b
et
w
een
the
asci
i
and
t
yp
eset
v
ersions
of
all
TLA
+
sym
b
ols
for
whic
h
the
corresp
ondence
ma
y
not
b
e
ob
vious.
15.1
The
Simple
Grammar
The
simple
grammar
of
TLA
+
is
describ
ed
in
BNF.
More
precisely
,
it
is
sp
ecied
b
elo
w
in
the
TLA
+
mo
dule
TLAPlusGr
ammar
.
This
mo
dule
uses
the
op
era-
tors
for
represen
ting
BNF
grammars
dened
in
the
BNF
Gr
ammars
mo
dule
of
Section
11.1.4
(page
179).
Mo
dule
TLAPlusGr
ammar
con
tains
commen
ts
de-
scribing
ho
w
to
read
the
sp
ecication
as
an
ordinary
BNF
grammar.
So,
if
y
ou
are
familiar
with
BNF
grammars
and
just
w
an
t
to
learn
the
syn
tax
of
TLA
+
,
y
ou
don't
ha
v
e
to
understand
ho
w
the
TLA
+
op
erators
for
writing
grammars
are
dened.
Otherwise,
y
ou
should
read
Section
11.1.4
b
efore
trying
to
read
the
follo
wing
mo
dule.
module
TLAPlusGr
ammar
extends
Natur
als,
Se
quenc
es,
BNF
Gr
ammars
This
mo
dule
denes
a
simple
grammar
for
TLA
+
that
ignores
man
y
asp
ects
of
the
language,
suc
h
as
op
erator
precedence
and
inden
tation
rules.
I
use
the
term
sentenc
e
to
mean
a
se-
quence
of
lexemes,
where
a
lexeme
is
just
a
string.
The
BNF
Gr
ammars
mo
dule
denes
the
follo
wing
standard
con
v
en
tions
for
writing
sets
of
sen
tences:
L
j
M
means
an
L
or
an
M
,
L

means
the
concatenation
of
zero
or
more
Ls,
and
L
+
means
the
concatenation
of
one
or
more
Ls.
The
concatenation
of
an
L
and
an
M
is
denoted
b
y
L
&
M
rather
than
the
cus-
tomary
juxtap
osition
L
M
.
Nil
is
the
n
ull
sen
tence,
so
Nil
&
L
equals
L
for
an
y
L.
A
token
is
a
one-lexeme
sen
tence.
There
are
t
w
o
op
erators
for
dening
sets
of
tok
ens:
if
s
is
a
lexeme,
then
tok
(s
)
is
the
set
con
taining
the
single
tok
en
h
s
i;
and
if
S
is
a
set
of
lexemes,
then
T
ok
(S
)
is
the
set
con
taining
all
tok
ens
h
s
i
for
s
2
S
.
In
commen
ts,
I
will
not
distin-
guish
b
et
w
een
the
tok
en
h
s
i
and
the
string
s
.
W
e
b
egin
b
y
dening
t
w
o
useful
op
erators.
First,
a
CommaList
(L)
is
dened
to
b
e
an
L
or
a
sequence
of
Ls
separated
b
y
commas.
CommaList
(L)

=
L
&
(tok
(\,")
&
L)

Next,
if
c
is
a
c
haracter,
then
w
e
dene
A
tL
e
ast
4(\c"
)
to
b
e
the
set
of
tok
ens
consisting
of
4
or
more
c
's.
A
tL
e
ast
4(s
)

=
T
ok
(fs

s

s
g
&
fs
g
+
)

15.1.
THE
SIMPLE
GRAMMAR
277
W
e
no
w
dene
some
sets
of
lexemes.
First
is
R
eserve
dWor
d
,
the
set
of
w
ords
that
can't
b
e
used
as
iden
tiers.
(Note
that
boolean,
tr
ue
,
f
alse,
and
string
are
iden
tiers
that
are
predened.)
R
eserve
dWor
d

=
f\ASSUME"
;
\ELSE"
;
\LOCAL";
\UNION"
;
\ASSUMPTION"
;
\ENABLED"
;
\MODULE"
;
\V
ARIABLE";
\AXIOM"
;
\EX
CEPT"
;
\OTHER"
;
\V
ARIABLES";
\CASE"
;
\EXTENDS"
;
\SF_"
;
\WF_"
;
\CHOOSE"
;
\IF"
;
\SUBSET"
;
\WITH"
;
\CONST
ANT"
;
\IN"
;
\THEN"
;
\CONST
ANTS"
;
\INST
ANCE"
;
\THEOREM"
;
\DOMAIN"
;
\LET"
;
\UNCHANGED"
g
Next
are
three
sets
of
c
haracters|more
precisely
,
sets
of
1-c
haracter
lexemes.
They
are
the
sets
of
letters,
n
um
b
ers,
and
c
haracters
that
can
app
ear
in
an
iden
tier.
L
etter

=
OneOf
(\ab
cdefghijklmnop
qrstuvwxyzABCDEF
GHIJKLMNOPQRSTUVWXYZ"
)
Numer
al

=
OneOf
(\0123456789"
)
NameChar

=
L
etter
[
Numer
al
[
f\_
"g
W
e
no
w
dene
some
sets
of
tok
ens.
A
Name
is
a
tok
en
comp
osed
of
letters,
n
um
b
ers,
and
_
c
haracters
that
con
tains
at
least
one
letter,
but
do
es
not
b
egin
with
\WF_"
or
\SF_
"
(see
page
290
for
an
explanation
of
this
restriction).
It
can
b
e
used
as
the
name
of
a
record
eld
or
a
mo
dule.
An
Identier
is
a
Name
that
isn't
a
reserv
ed
w
ord.
Name

=
T
ok
(
(NameChar

&
L
etter
&
NameChar

)
n
(f\WF_
";
\SF_
"g
&
NameChar
+
)
)
Identier

=
Name
n
T
ok
(R
eserve
dWor
d
)
An
IdentierOrT
uple
is
either
an
iden
tier
or
a
tuple
of
iden
tiers.
Note
that
h
i
is
t
yp
ed
as
<<
>>.
IdentierOrT
uple

=
Identier
j
tok
(\<<"
)
&
CommaList
(Identier
)
&
tok
(\>>"
)
A
Numb
er
is
a
tok
en
represen
ting
a
n
um
b
er.
Y
ou
can
write
the
in
teger
63
in
the
follo
wing
w
a
ys:
63,
63.00,
\b111111
or
\B111111
(binary),
\o77
or
\O77
(o
ctal),
or
\
h3f,
\H3f,
\h3F,
or
\
H3F
(hexadecimal).
Numb
erL
exeme

=
Numer
al
+
j
(Numer
al

&
f\."
g
&
Numer
al
+
)
j
f\\
b"
;
\\
B"g
&
OneOf
(\01"
)
+
j
f\\
o"
;
\\
O"
g
&
OneOf
(\01234567"
)
+
j
f\\
h"
;
\\
H"
g
&
OneOf
(\0123456789ab
cdefABCDEF"
)
+
Numb
er

=
T
ok
(Numb
erL
exeme
)
A
String
tok
en
represen
ts
a
literal
string.
See
Section
16.1.10
on
page
307
to
nd
out
ho
w
sp
ecial
c
haracters
are
t
yp
ed
in
a
string.

278
CHAPTER
15.
THE
SYNT
AX
OF
TLA
+
String

=
T
ok
(
f\
"
"g
&
string
&
f\
"
"g
)
W
e
next
dene
the
sets
of
tok
ens
that
represen
t
prex
op
erators
(lik
e
2),
inx
op
erators
(lik
e
+),
and
p
ostx
op
erators
(lik
e
prime
(
0
)).
See
T
able
8
on
page
273
to
nd
out
what
sym
b
ols
these
asci
i
strings
represen
t.
Pr
exOp

=
T
ok
(f
\-",
\~",
\\lnot",
\\neg",
\[
]",
\<
>",
\DOMAIN"
;
\ENABLED"
;
\SUBSET"
;
\UNCHANGED"
;
\UNION"
g)
InxOp

=
T
ok
(
f
\!!",
\#",
\##",
\$",
\$$",
\%",
\%%",
\&",
\&&",
\(+)",
\(-)",
\(.)",
\(/)",
\(\X)",
\*",
\**",
\+",
\++",
\-",
\-+->",
\--",
\-|",
\..",
\...",
\/",
\//",
\/=",
\/\",
\::=",
\:=",
\:>",
\<",
\<:",
\<=>",
\=",
\=<",
\=>",
\=|",
\>",
\>=",
\?",
\??",
\@@",
\\",
\\/",
\^",
\^^",
\|",
\|-",
\|=",
\||",
\~>",
\.",
\\
app
ro
x",
\\
geq",
\\
oslash",
\\
sqsupseteq",
\\
asymp",
\\
gg
",
\\
otimes",
\\
sta
r
",
\\
bigcirc",
\\
in",
\\
p
rec",
\\
subset",
\\
bullet",
\\
intersect",
\\
p
receq",
\\
subseteq",
\\
cap",
\\
land",
\\
p
ropto",
\\
succ",
\\
cdot",
\\
leq",
\\
sim",
\\
succeq",
\\
circ",
\\
ll",
\\
simeq",
\\
supset",
\\
cong
",
\\
lo
r
",
\\
sqcap",
\\
supseteq",
\\
cup",
\\
o",
\\
sqcup",
\\
union",
\\
div
",
\\
o
dot",
\\
sqsubset",
\\
uplus",
\\
doteq",
\\
ominus",
\\
sqsubseteq",
\\
wr
",
\\
equiv
",
\\
oplus",
\\
sqsupset"
g
)
PostxOp

=
T
ok
(f\^+",
\^*",
\^#",
\'"
g)
F
ormally
,
the
grammar
TLAPlusGr
ammar
of
TLA
+
is
the
smallest
grammar
satisfying
the
BNF
pro
ductions
b
elo
w.
TLAPlusGr
ammar

=
let
P
(G
)

=
Here
is
the
BNF
grammar.
T
erms
that
b
egin
with
\G
:",
lik
e
G
:Mo
dule
,
represen
t
non
termi-
nals.
The
terminals
are
sets
of
tok
ens,
either
dened
ab
o
v
e
or
describ
ed
with
the
op
erators
tok
and
T
ok
.
The
op
erators
A
tL
e
ast
4
and
CommaList
are
dened
ab
o
v
e.
^
G
:Mo
dule
::=
A
tL
e
ast
4(\-"
)
&
tok
(\MODULE"
)
&
Name
&
A
tL
e
ast
4(\-"
)
&
(Nil
j
(tok
(\EXTENDS"
)
&
CommaList
(Name
)))
&
(G
:Unit
)

&
A
tL
e
ast
4(\="
)

15.1.
THE
SIMPLE
GRAMMAR
279
^
G
:Unit
::=
G
:V
ariableDe
clar
ation
j
G
:ConstantDe
clar
ation
j
(Nil
j
tok
(\LOCAL"))
&
G
:Op
er
atorDenition
j
(Nil
j
tok
(\LOCAL"))
&
G
:F
unctionDenition
j
(Nil
j
tok
(\LOCAL"))
&
G
:Instanc
e
j
(Nil
j
tok
(\LOCAL"))
&
G
:Mo
duleDenition
j
G
:Assumption
j
G
:The
or
em
j
G
:Mo
dule
j
A
tL
e
ast
4(\-"
)
^
G
:V
ariableDe
clar
ation
::=
T
ok
(f\V
ARIABLE";
\V
ARIABLES"g)
&
CommaList
(Identier
)
^
G
:ConstantDe
clar
ation
::=
T
ok
(f\CONST
ANT"
;
\CONST
ANTS"
g)
&
CommaList
(G
:OpDe
cl
)
^
G
:OpDe
cl
::=
Identier
j
Identier
&
tok
(\(")
&
CommaList
(
tok
(\_
"
)
)
&
tok
(\)")
j
Pr
exOp
&
tok
(\_
")
j
tok
(\_
")
&
InxOp
&
tok
(\_"
)
j
tok
(\_
")
&
PostxOp
^
G
:Op
er
atorDenition
::=
(
G
:NonFixLHS
j
Pr
exOp
&
Identier
j
Identier
&
InxOp
&
Identier
j
Identier
&
PostxOp
)
&
tok
(\=="
)
&
G
:Expr
ession
^
G
:NonFixLHS
::=
Identier
&
(
Nil
j
tok
(\(")
&
CommaList
(
Identier
j
G
:OpDe
cl
)
&
tok
(\)")
)
^
G
:F
unctionDenition
::=
Identier
&
tok
(\["
)
&
CommaList
(G
:QuantierBound
)
&
tok
(\]"
)
&
tok
(\=="
)
&
G
:Expr
ession

280
CHAPTER
15.
THE
SYNT
AX
OF
TLA
+
^
G
:QuantierBound
::=
(
IdentierOrT
uple
j
CommaList
(Identier
)
)
&
tok
(\\in"
)
&
G
:Expr
ession
^
G
:Instanc
e
::=
tok
(\INST
ANCE"
)
&
Name
&
(
Nil
j
tok
(\WITH"
)
&
CommaList
(G
:Substitution
)
)
^
G
:Substitution
::=
(
Identier
j
Pr
exOp
j
InxOp
j
PostxOp
)
&
tok
(\<-"
)
&
G
:A
r
gument
^
G
:A
r
gument
::=
G
:Expr
ession
j
G
:Gener
alPr
exOp
j
G
:Gener
alInxOp
j
G
:Gener
alPostxOp
^
G
:Instanc
ePr
ex
::=
(
Identier
&
(
Nil
j
tok
(\("
)
&
CommaList
(G
:Expr
ession
)
&
tok
(\)"
)
)
&
tok
(\
!
"
)
)

^
G
:Gener
alIdentier
::=
G
:Instanc
ePr
ex
&
Identier
^
G
:Gener
alPr
exOp
::=
G
:Instanc
ePr
ex
&
Pr
exOp
^
G
:Gener
alInxOp
::=
G
:Instanc
ePr
ex
&
InxOp
^
G
:Gener
alPostxOp
::=
G
:Instanc
ePr
ex
&
PostxOp
^
G
:Mo
duleDenition
::=
G
:NonFixLHS
&
tok
(\=="
)
&
G
:Instanc
e
^
G
:Assumption
::=
T
ok
(f\ASSUME"
;
\ASSUMPTION"
;
\AXIOM"
g)
&
G
:Expr
ession
^
G
:The
or
em
::=
tok
(\THEOREM"
)
&
G
:Expr
ession
The
commen
ts
giv
e
examples
of
eac
h
of
the
dieren
t
t
yp
es
of
expression.
^
G
:Expr
ession
::=
G
:Gener
alIdentier
A(x
+
7)
!
B
!
Id
j
G
:Gener
alIdentier
&
tok
(\(")
&
CommaList
(G
:A
r
gument
)
&
tok
(\)"
)
A
!
Op
(x
+
1;
y
)
j
G
:Gener
alPr
exOp
&
G
:Expr
ession
subset
S
:fo
o

15.1.
THE
SIMPLE
GRAMMAR
281
j
G
:Expr
ession
&
G
:Gener
alInxOp
&
G
:Expr
ession
a
+
b
j
G
:Expr
ession
&
G
:Gener
alPostxOp
x
[1]
0
j
tok
(\("
)
&
G
:Expr
ession
&
tok
(\)")
(x
+
1)
j
T
ok
(f\\
A";
\\
E"
g)
&
CommaList
(G
:QuantierBound
)
&
tok
(\:")
&
G
:Expr
ession
8
x
2
S
;
h
y
;
z
i
2
T
:
F
(x
;
y
;
z
)
j
T
ok
(f\\
A";
\\
E"
;
\\
AA";
\\
EE"
g)
&
CommaList
(Identier
)
&
tok
(\:")
&
G
:Expr
ession
9
x
;
y
:
x
+
y
>
0
j
tok
(\CHOOSE"
)
&
IdentierOrT
uple
&
(Nil
j
tok
(\\
in"
)
&
G
:Expr
ession
)
&
tok
(\:"
)
&
G
:Expr
ession
choose
h
x
;
y
i
2
S
:
F
(x
;
y
)
j
tok
(\f"
)
&
(Nil
j
CommaList
(G
:Expr
ession
))
&
tok
(\g"
)
f1;
2;
2
+
2g
j
tok
(\f"
)
&
IdentierOrT
uple
&
tok
(\\in"
)
&
G
:Expr
ession
&
tok
(\:"
)
&
G
:Expr
ession
&
tok
(\g"
)
fx
2
Nat
:
x
>
0g
j
tok
(\f"
)
&
G
:Expr
ession
&
tok
(\:"
)
&
CommaList
(G
:QuantierBound
)
&
tok
(\g"
)
fF
(x
;
y
;
z
)
:
x
;
y
2
S
;
z
2
T
g
j
G
:Expr
ession
&
tok
(\["
)
&
CommaList
(G
:Expr
ession
)
&
tok
(\]"
)
f
[i
+
1;
j
]
j
tok
(\["
)
&
CommaList
(G
:QuantierBound
)
&
tok
(\|
->"
)
&
G
:Expr
ession
&
tok
(\]"
)
[i
;
j
2
S
;
h
p
;
q
i
2
T
7!
F
(i
;
j
;
p
;
q
)]
j
tok
(\["
)
&
G
:Expr
ession
&
tok
(\->
")
&
G
:Expr
ession
&
tok
(\]"
)
[(S
[
T
)
!
U
]
j
tok
(\["
)
&
CommaList
(
Name
&
tok
(\|-
>"
)
&
G
:Expr
ession
)
&
tok
(\]"
)
[a
7!
x
+
1;
b
7!
y
]

282
CHAPTER
15.
THE
SYNT
AX
OF
TLA
+
j
tok
(\["
)
&
CommaList
(
Name
&
tok
(\:")
&
G
:Expr
ession
)
&
tok
(\]"
)
[a
:
Nat
;
b
:
S
[
T
]
j
tok
(\["
)
[f
ex
cept
!
[1;
x
]:r
=
4;
!
[h
2;
y
i]
=
e
]
&
G
:Expr
ession
&
tok
(\EX
CEPT"
)
&
CommaList
(
tok
(\
!
")
&
(
tok
(\.")
&
Name
j
tok
(\[")
&
CommaList
(G
:Expr
ession
)
&
tok
(\]"
)
)
+
&
tok
(\=")
&
G
:Expr
ession
)
&
tok
(\]"
)
j
tok
(\<<"
)
&
CommaList
(G
:Expr
ession
)
&
tok
(\>>"
)
h
1;
2;
1
+
2
i
j
G
:Expr
ession
&
(T
ok
(f\\X";
\\
times"
g)
&
G
:Expr
ession
)
+
Nat

(1
:
:
3)

R
e
al
j
tok
(\["
)
&
G
:Expr
ession
&
tok
(\]_
")
&
G
:Expr
ession
[A
_
B
]
h
x
;y
i
j
tok
(\<<"
)
&
G
:Expr
ession
&
tok
(\>>_
")
&
G
:Expr
ession
h
x
0
=
y
+
1
i
(x
y
)
j
T
ok
(f\WF_"
;
\SF_"
g)
&
G
:Expr
ession
&
tok
(\(")
&
G
:Expr
ession
&
tok
(\)"
)
WF
vars
(Next
)
j
tok
(\IF"
)
&
G
:Expr
ession
&
tok
(\THEN"
)
&
G
:Expr
ession
&
tok
(\ELSE"
)
&
G
:Expr
ession
if
p
then
A
else
B
j
tok
(\CASE"
)
case
p
1
!
e
1
2
p
2
!
e
2
2
other
!
e
3
&
(
let
CaseA
rm

=
G
:Expr
ession
&
tok
(\->"
)
&
G
:Expr
ession
in
CaseA
rm
&
(tok
(\[
]"
)
&
CaseA
rm
)

)
&
(
Nil
j
(
tok
(\[
]"
)
&
tok
(\OTHER"
)
&
tok
(\->"
)
&
G
:Expr
ession
)
)
j
tok
(\LET"
)
&
(
G
:Op
er
atorDenition
j
G
:F
unctionDenition
j
G
:Mo
duleDenition
)
+
&
tok
(\IN"
)
&
G
:Expr
ession
let
x

=
y
+
1
f
[t
2
Nat
]

=
t
2
in
x
+
f
[y
]
j
(tok
(\/\
"
)
&
G
:Expr
ession
)
+
^
x
=
1
^
y
=
2
j
(tok
(\\
/"
)
&
G
:Expr
ession
)
+
_
x
=
1
_
y
=
2

15.2.
THE
COMPLETE
GRAMMAR
283
j
Numb
er
09001
j
String
\fo
o"
j
tok
(\@"
)
@
(Can
b
e
used
only
in
an
ex
cept
expression.)
in
L
e
astGr
ammar
(P
)
15.2
The
Complete
Grammar
W
e
no
w
complete
our
explanation
of
the
syn
tax
of
TLA
+
b
y
giving
the
de-
tails
that
are
not
describ
ed
b
y
the
BNF
grammar
in
the
previous
section.
Sec-
tion
15.2.1
giv
es
the
precedence
rules,
Section
15.2.2
giv
es
the
alignmen
t
rules
for
conjunction
and
disjunction
lists,
and
Section
15.2.3
describ
es
commen
ts.
Section
15.2.4
briey
discusses
the
syn
tax
of
temp
oral
form
ulas.
Finally
,
for
completeness,
Section
15.2.5
explains
the
handling
of
t
w
o
anomalous
cases
that
y
ou're
unlik
ely
ev
er
to
encoun
ter.
15.2.1
Precedence
and
Asso
ciativit
y
The
expression
a
+
b

c
is
in
terpreted
as
a
+
(b

c
)
rather
than
(a
+
b
)

c
.
This
con
v
en
tion
is
describ
ed
b
y
sa
ying
that
the
op
erator

has
higher
pr
e
c
e
denc
e
than
the
op
erator
+.
In
general,
op
erators
with
higher
precedence
are
applied
b
efore
op
erators
of
lo
w
er
precedence.
This
applies
to
prex
op
erators
(lik
e
subset
)
and
p
ostx
op
erators
(lik
e
0
)
as
w
ell
as
to
inx
op
erators
lik
e
+
and
.
Th
us,
a
+
b
0
is
in
terpreted
as
a
+
(b
0
),
rather
than
as
(a
+
b
)
0
,
b
ecause
0
has
higher
precedence
than
+.
Application
order
can
also
b
e
determined
b
y
asso
ciativit
y
.
The
expression
a
 b
 c
is
in
terpreted
as
(a
 b
)
 c
b
ecause
 is
a
left-asso
ciativ
e
inx
op
erator.
In
TLA
+
,
the
precedence
of
an
op
erator
is
a
range
of
n
um
b
ers,
lik
e
9{13.
The
op
erator
$
has
higher
precedence
than
the
op
erator
:>
b
ecause
the
precedence
of
$
is
9{13,
and
this
en
tire
range
is
greater
than
the
precedence
range
of
:>,
whic
h
is
7{7.
An
expression
is
illegal
(not
syn
tactically
w
ell-formed)
if
the
order
of
application
of
t
w
o
op
erators
is
not
determined
b
ecause
their
precedence
ranges
o
v
erlap
and
they
are
not
t
w
o
instances
of
an
asso
ciativ
e
inx
op
erator.
F
or
example,
the
expression
a
+
b

c
0
%
d
is
illegal
for
the
follo
wing
reason.
The
precedence
range
of
0
is
higher
than
that
of
,
and
the
precedence
range
of

is
higher
than
that
of
b
oth
+
and
%
,
so
this
expression
can
b
e
written
as
a
+
(b

(c
0
))
%
d
.
Ho
w
ev
er,
the
precedences
of
+
(10{10)
and
%
(10{11)
o
v
erlap,
so
w
e
don't
kno
w
if
the
expression
is
to
b
e
in
terpreted
as
(a
+
(b

(c
0
)))
%
d
or
a
+
((b

(c
0
))
%
d
),
and
it
is
therefore
illegal.

284
CHAPTER
15.
THE
SYNT
AX
OF
TLA
+
TLA
+
em
b
o
dies
the
philosoph
y
that
it's
b
etter
to
require
paren
theses
than
to
allo
w
expressions
that
could
easily
b
e
misin
terpreted.
Th
us,

and
=
ha
v
e
o
v
erlapping
precedence,
making
an
expression
lik
e
a
=b

c
illegal.
(This
also
mak
es
a

b
=c
illegal,
ev
en
though
(a

b
)=c
and
a

(b
=c
)
happ
en
to
b
e
equal
when

and
=
ha
v
e
their
usual
denitions.)
Uncon
v
en
tional
op
erators
lik
e
$
ha
v
e
wide
precedence
ranges
for
safet
y
.
But,
ev
en
when
the
precedence
rules
imply
that
paren
theses
aren't
needed,
it's
often
a
go
o
d
idea
to
use
them
an
yw
a
y
if
y
ou
think
there's
an
y
c
hance
that
a
reader
migh
t
not
understand
ho
w
an
expression
is
parsed.
T
able
6
on
page
271
giv
es
the
precedence
ranges
of
all
op
erators
and
tells
whic
h
inx
op
erators
are
left
asso
ciativ
e.
(No
TLA
+
op
erators
are
righ
t
asso-
ciativ
e.)
Note
that
the
sym
b
ols
2,
=,
and
\."
are
used
b
oth
as
xed
parts
of
constructs
and
as
inx
op
erators.
They
are
not
inx
op
erators
in
the
follo
wing
t
w
o
expressions:
fx
2
S
:
p
(x
)g
[f
ex
cept
!
:a
=
e
]
so
the
precedence
of
the
corresp
onding
inx
op
erators
pla
ys
no
role
in
parsing
these
expressions.
Belo
w
are
some
additional
precedence
rules
not
co
v
ered
b
y
the
op
erator
precedence
ranges.
F
unction
Application
F
unction
application
is
treated
lik
e
an
op
erator
with
precedence
range
16{16,
giving
it
higher
precedence
than
an
y
op
erator
except
p
erio
d
(\."),
the
record-
eld
op
erator.
Th
us,
a
+
b
:c
[d
]
0
is
in
terpreted
as
a
+
(((b
:c
)[d
])
0
).
Cartesian
Pro
ducts
In
the
Cartesian
pro
duct
construct,

(t
yp
ed
as
\X
or
\times)
acts
somewhat
lik
e
an
asso
ciativ
e
inx
op
erator
with
precedence
range
10{13.
Th
us,
A

B

C
is
in
terpreted
as
(A

B
)

C
,
rather
than
as
A

(B

C
).
Ho
w
ev
er,

is
part
of
a
sp
ecial
construct,
not
an
inx
op
erator.
F
or
example,
the
three
sets
A

B

C
,
(A

B
)

C
,
and
A

(B

C
)
are
all
dieren
t:
A

B

C
=
fh
a
;
b
;
c
i
:
a
2
A;
b
2
B
;
c
2
C
g
(A

B
)

C
=
fh
h
a
;
b
i;
c
i
:
a
2
A;
b
2
B
;
c
2
C
g
A

(B

C
)
=
fh
a
;
h
b
;
c
i
i
:
a
2
A;
b
2
B
;
c
2
C
g
The
rst
is
a
set
of
triples;
the
last
t
w
o
are
sets
of
pairs.
Undelimited
Constructs
TLA
+
has
sev
eral
expression-making
constructs
with
no
explicit
righ
t-hand
ter-
minator.
They
are:
choose,
if/then/else,
case,
let/in,
and
quan
tier
con-
structs.
These
constructs
are
treated
as
prex
op
erators
with
the
lo
w
est
p
ossible

15.2.
THE
COMPLETE
GRAMMAR
285
precedence,
so
an
expression
made
with
one
of
them
extends
as
far
as
p
ossible.
More
precisely
,
the
expression
is
ended
only
b
y
one
of
the
follo
wing:

The
b
eginning
of
the
next
mo
dule
unit.
(Mo
dule
units
are
pro
duced
b
y
the
Unit
non
terminal
in
the
BNF
grammar
of
Section
11.1.4;
they
include
denition
and
declaration
statemen
ts.)

A
righ
t
delimiter
whose
matc
hing
left
delimiter
o
ccurs
b
efore
the
b
eginning
of
the
construct.
Delimiter
pairs
are
(
),
[
],
f
g,
and
h
i.

An
y
of
the
follo
wing
lexemes,
if
they
are
not
part
of
a
sub
expression:
then,
else,
in,
comma
(,),
colon
(:),
and
!.
F
or
example,
the
sub
expression
8
x
:
P
is
ended
b
y
the
then
in
the
expression
if
8
x
:
P
then
0
else
1

The
case
separator
2
(not
the
prex
temp
oral
op
erator
that
is
t
yp
ed
the
same)
ends
all
of
these
constructs
except
a
case
statemen
t
without
an
other
clause.
That
is,
the
2
acts
as
a
delimiter
except
when
it
can
b
e
part
of
a
case
statemen
t.

An
y
sym
b
ol
not
to
the
righ
t
of
the
^
or
_
prexing
a
conjunction
or
dis-
junction
list
elemen
t
con
taining
the
construct.
(See
Section
15.2.2
on
the
next
page.)
Here
is
ho
w
some
expressions
are
in
terpreted
under
this
rule:
if
x
>
0
then
y
+
1
else
y
 1
+
2
means
if
x
>
0
then
y
+
1
else
(y
 1
+
2)
8
x
2
S
:
P
(x
)
_
Q
means
8
x
2
S
:
(P
(x
)
_
Q
)
As
these
examples
sho
w,
inden
tation
is
ignored|except
in
conjunction
and
dis-
junction
lists,
discussed
b
elo
w.
The
absence
of
a
terminating
lexeme
(an
end)
for
an
if/then/else
or
case
construct
usually
mak
es
an
expression
less
cluttered,
but
sometimes
it
do
es
require
y
ou
to
add
paren
theses.
Subscripts
TLA
uses
subscript
notation
in
the
follo
wing
constructs:
[A]
e
,
h
A
i
e
,
WF
e
(A),
and
SF
e
(A).
In
TLA
+
,
these
are
written
with
a
\_
"
c
haracter,
as
in
<<A>>_e.
This
notation
is,
in
principle,
problematic.
The
expression
<<A>>_x
/\
B,
whic
h
w
e
exp
ect
to
mean
(h
A
i
x
)
^
B
,
could
conceiv
ably
b
e
in
terpreted
as
h
A
i
(x
^B
)
.
The
precise
rule
for
parsing
these
constructs
isn't
imp
ortan
t;
y
ou
should
put
paren
theses
around
the
subscript
except
in
the
follo
wing
t
w
o
cases:

286
CHAPTER
15.
THE
SYNT
AX
OF
TLA
+

The
subscript
is
a
Gener
alIdentier
in
the
BNF
grammar.

The
subscript
is
an
expression
enclosed
b
y
one
of
the
follo
wing
matc
hing
delimiter
pairs:
(
),
[
],
h
i,
or
f
g|for
example,
h
x
;
y
i
or
(x
+
y
).
Although
[A]_f[x]
is
in
terpreted
correctly
as
[A]
f
[x
]
,
it
will
b
e
easier
to
read
in
the
asci
i
text
(and
will
b
e
formatted
prop
erly
b
y
TLA
T
E
X)
if
y
ou
write
it
as
[A]_(f[x]).
15.2.2
Alignmen
t
The
most
no
v
el
asp
ect
of
TLA
+
syn
tax
is
the
aligned
conjunction
and
disjunction
lists.
If
y
ou
write
suc
h
a
list
in
a
straigh
tforw
ard
manner,
then
it
will
mean
what
y
ou
exp
ect
it
to.
Ho
w
ev
er,
y
ou
migh
t
wind
up
doing
something
w
eird
through
a
t
yping
error.
So,
it's
a
go
o
d
idea
to
kno
w
what
the
exact
syn
tax
rules
are
for
these
lists.
I
giv
e
the
rules
here
for
conjunction
lists;
the
rules
for
disjunction
lists
are
analogous.
A
conjunction
list
is
an
expression
that
b
egins
with
^,
whic
h
is
t
yp
ed
as
/\.
Let
c
b
e
the
column
in
whic
h
the
/
o
ccurs.
The
conjunction
list
consists
of
a
sequence
of
conjuncts,
eac
h
b
eginning
with
a
^.
A
conjunct
is
ended
b
y
an
y
one
of
the
follo
wing
that
o
ccurs
after
the
/\:
1.
Another
/\
whose
/
c
haracter
is
in
column
c
and
is
the
rst
nonspace
c
haracter
on
the
line.
2.
An
y
nonspace
c
haracter
in
column
c
or
a
column
to
the
left
of
column
c
.
3.
A
righ
t
delimiter
whose
matc
hing
left
delimiter
o
ccurs
b
efore
the
b
eginning
of
the
conjunction
list.
Delimiter
pairs
are
(
),
[
],
f
g,
and
h
i.
4.
The
b
eginning
of
the
next
mo
dule
unit.
(Mo
dule
units
are
pro
duced
b
y
the
Unit
non
terminal
in
the
BNF
grammar;
they
include
denition
and
declaration
statemen
ts.)
In
case
1,
the
/\
b
egins
the
next
conjunct
in
the
same
conjunction
list.
In
the
other
three
cases,
the
end
of
the
conjunct
is
the
end
of
the
en
tire
conjunction
list.
In
all
cases,
the
c
haracter
ending
the
conjunct
do
es
not
b
elong
to
the
conjunct.
With
these
rules,
inden
tation
prop
erly
delimits
expressions
in
a
conjunction
list|for
example:
/\
IF
e
THEN
P
ELSE
Q
/\
R
means
^
(if
e
then
P
else
Q
)
^
R
It's
b
est
to
inden
t
eac
h
conjunction
completely
to
the
righ
t
of
its
^
sym
b
ol.
These
examples
illustrate
precisely
what
happ
ens
if
y
ou
don't:

15.2.
THE
COMPLETE
GRAMMAR
287
/\
x'
=
y
/\
y'=x
means
^
x
0
=
y
^
y
0
=
x
/\
x'
=
y
/\
y'=x
means
((^
x
0
)
=
y
)
^
(y
0
=
x
)
In
the
second
example,
^
x
0
is
in
terpreted
as
a
conjunction
list
con
taining
only
one
conjunct,
and
the
second
/\
is
in
terpreted
as
an
inx
op
erator.
Y
ou
can't
use
paren
theses
to
circum
v
en
t
the
inden
tation
rules.
F
or
example,
this
is
illegal:
/\
(x'
=
y)
/\
y'=x
The
rules
imply
that
the
rst
/\
b
egins
a
conjunction
list
that
is
ended
b
efore
the
=.
That
conjunction
list
is
therefore
^
(x
0
,
whic
h
has
an
unmatc
hed
left
paren
thesis.
The
conjunction/disjunction
list
notation
is
quite
robust.
Ev
en
if
y
ou
mess
up
the
alignmen
t
b
y
t
yping
one
space
to
o
few
or
to
o
man
y|something
that's
easy
to
do
when
the
conjuncts
are
long|the
form
ula
is
still
lik
ely
to
mean
what
y
ou
in
tended.
Here's
an
example
of
what
happ
ens
if
y
ou
misalign
a
conjunct:
/\
A
/\
B
/\
C
means
(
(^
A)
The
bulleted
list
^
A
of
one
conjunct;
it
equals
A.
^
B
)
This
^
is
in
terpreted
as
an
inx
op
erator.
^
C
This
^
is
in
terpreted
as
an
inx
op
erator.
While
not
in
terpreted
the
w
a
y
y
ou
exp
ected,
this
form
ula
is
equiv
alen
t
to
A
^
B
^
C
,
whic
h
is
what
y
ou
mean
t
in
the
rst
place.
Most
k
eyb
oards
con
tain
one
k
ey
that
is
the
source
of
a
lot
of
trouble:
the
tab
k
ey
(sometimes
mark
ed
on
the
k
eyb
oard
with
a
righ
t
arro
w).
On
m
y
computer
screen,
I
can
pro
duce
A
==
/\
x'
=
1
/\
y'
=
2
b
y
b
eginning
the
second
line
with
eigh
t
space
c
haracters
and
the
third
with
one
tab
c
haracter.
In
this
case,
it
is
unsp
ecied
whether
or
not
the
t
w
o
/
c
haracters
o
ccur
in
the
same
column.
T
ab
c
haracters
are
an
anac
hronism
left
o
v
er
from
the
da
ys
of
t
yp
ewriters
and
of
computers
with
memory
capacit
y
measured
in
kilob
ytes.
I
strongly
advise
y
ou
nev
er
to
use
them.
But,
if
y
ou
insist
on
using
them,
here
are
the
rules:

A
tab
c
haracter
is
considered
to
b
e
equiv
alen
t
to
one
or
more
space
c
har-
acters,
so
it
o
ccupies
one
or
more
columns.

Iden
tical
sequences
of
space
and
tab
c
haracters
that
o
ccur
at
the
b
eginning
of
a
line
o
ccup
y
the
same
n
um
b
er
of
columns.
There
are
no
other
guaran
tees
if
y
ou
use
tab
c
haracters.

288
CHAPTER
15.
THE
SYNT
AX
OF
TLA
+
15.2.3
Commen
ts
Commen
ts
are
describ
ed
in
Section
3.5
on
page
32.
A
commen
t
ma
y
app
ear
b
et
w
een
an
y
t
w
o
lexemes
in
a
sp
ecication.
There
are
t
w
o
t
yp
es
of
commen
ts:

A
delimited
commen
t
is
a
string
of
the
form
\
(
"

s

\
)
"
,
where
s
is
an
y
string
in
whic
h
o
ccurrences
of
\
(
"
and
\
)
"
are
prop
erly
matc
hed.
More
precisely
,
a
delimited
commen
t
is
dened
inductiv
ely
to
b
e
a
string
of
the
form
\
(
"

s
1





s
n

\
)
",
where
eac
h
s
i
is
either
(i)
a
string
con
taining
neither
the
substring
\
(
"
nor
the
substring
\
)
",
or
(ii)
a
delimited
commen
t.
(In
particular,
\
(
)
"
is
a
delimited
commen
t.)

An
end-of-line
commen
t
is
a
string
of
the
form
\
\

"

s

\h
lf
i",
where
s
is
an
y
string
not
con
taining
an
end-of-line
c
haracter
h
lf
i.
I
lik
e
to
write
commen
ts
as
sho
wn
here:
BufRcv
==
/\
InChan!Rcv
(***************
**
***
**
***
**
**
***
*)
/\
q'
=
Append(q,
in.val)
(*
Receive
message
from
channel
*)
/\
out
(*
`in'
and
append
to
tail
of
q.
*)
(***************
**
***
**
***
**
**
***
*)
Grammatically
,
this
piece
of
sp
ecication
has
four
distinct
commen
ts,
the
rst
and
last
consisting
of
the
same
string
(***



***).
But
a
p
erson
reading
it
w
ould
regard
them
as
a
single
commen
t,
spread
o
v
er
four
lines.
This
kind
of
commen
ting
con
v
en
tion
is
not
part
of
the
TLA
+
language,
but
it
is
supp
orted
b
y
the
TLA
T
E
X
t
yp
esetting
program,
as
describ
ed
in
Section
13.4
on
page
214.
15.2.4
T
emp
oral
F
orm
ulas
The
BNF
grammar
treats
2
and
3
simply
as
prex
op
erators.
Ho
w
ev
er,
as
explained
in
Section
8.1
(page
88),
the
syn
tax
of
temp
oral
form
ulas
places
re-
strictions
on
their
use.
F
or
example,
2(x
0
=
x
+
1)
is
not
a
legal
form
ula.
It's
not
hard
to
write
a
BNF
grammar
that
sp
ecies
legal
temp
oral
form
ulas
made
from
the
temp
oral
op
erators
and
ordinary
Bo
olean
op
erators
lik
e
:
and
^.
Ho
w
ev
er,
suc
h
a
BNF
grammar
w
on't
tell
y
ou
whic
h
of
these
t
w
o
expressions
is
legal:
let
F
(P
;
Q
)

=
P
^
2Q
in
F
(x
=
1;
x
=
y
+
1)
let
F
(P
;
Q
)

=
P
^
2Q
in
F
(x
=
1;
x
0
=
y
+
1)
The
rst
is
legal;
the
second
isn't
b
ecause
it
represen
ts
the
illegal
form
ula
(x
=
1)
^
2(x
0
=
y
+
1)
This
form
ula
is
illegal.
The
precise
rules
for
determining
if
a
temp
oral
form
ula
is
syn
tactically
w
ell-
formed
in
v
olv
e
rst
replacing
all
dened
op
erators
b
y
their
denitions,
using
the
pro
cedure
describ
ed
in
Section
17.4
b
elo
w.
I
w
on't
b
other
sp
ecifying
these
rules.

15.3.
THE
LEXEMES
OF
TLA
+
289
In
practice,
temp
oral
op
erators
are
not
used
v
ery
m
uc
h
in
TLA
+
sp
ecica-
tions,
and
one
rarely
writes
denitions
of
new
ones
suc
h
as
F
(P
;
Q
)

=
P
^
2Q
The
syn
tactic
rules
for
expressions
in
v
olving
suc
h
op
erators
are
of
academic
in
terest
only
.
15.2.5
Tw
o
Anomalies
There
are
t
w
o
sources
of
p
oten
tial
am
biguit
y
in
the
grammar
of
TLA
+
that
y
ou
are
unlik
ely
to
encoun
ter
and
that
ha
v
e
ad
ho
c
resolutions.
The
rst
of
these
arises
from
the
use
of
 as
b
oth
an
inx
op
erator
(as
in
2
 2)
and
a
prex
op
erator
(as
in
2
+
 2).
This
p
oses
no
problem
when
 is
used
in
an
ordinary
expression.
Ho
w
ev
er,
there
are
t
w
o
places
in
whic
h
an
op
erator
can
app
ear
b
y
itself:

As
the
argumen
t
of
a
higher-order
op
erator,
as
in
HOp
(+;
 ).

In
an
inst
ance
substitution,
suc
h
as
inst
ance
M
with
Plus
 
+
;
Minus
 
 In
b
oth
these
cases,
the
sym
b
ol
-
is
in
terpreted
as
the
inx
op
erator.
Y
ou
m
ust
t
yp
e
-.
to
denote
the
prex
op
erator.
Y
ou
also
ha
v
e
to
t
yp
e
-.
if
y
ou
should
ev
er
w
an
t
to
dene
the
prex
 op
erator,
as
in
 :
a

=
UMinus
(a
)
In
ordinary
expressions,
y
ou
just
t
yp
e
-
as
usual
for
b
oth
op
erators.
The
second
source
of
am
biguit
y
in
the
TLA
+
syn
tax
is
an
unlik
ely
expression
of
the
form
fx
2
S
:
y
2
T
g,
whic
h
migh
t
b
e
tak
en
to
mean
either
of
the
follo
wing:
let
p
(x
)

=
y
2
T
in
fx
2
S
:
p
(x
)g
This
is
a
subset
of
S
.
let
p
(y
)

=
x
2
S
in
fp
(y
)
:
y
2
T
g
This
is
a
subset
of
boolean
(the
set
ftr
ue;
f
alseg).
It
is
in
terpreted
as
the
rst
form
ula.
15.3
The
Lexemes
of
TLA
+
So
far,
this
c
hapter
has
describ
ed
the
sequences
of
lexemes
that
form
syn
tac-
tically
correct
TLA
+
mo
dules.
More
precisely
,
b
ecause
of
the
alignmen
t
rules,
syn
tactic
correctness
dep
ends
not
just
on
the
sequence
of
lexemes,
but
also
on
the
p
osition
of
eac
h
lexeme|that
is,
on
the
ro
w
and
columns
in
whic
h
the
c
har-
acters
of
the
lexeme
app
ear.
T
o
complete
the
denition
of
the
syn
tax
of
TLA
+
,

290
CHAPTER
15.
THE
SYNT
AX
OF
TLA
+
this
section
explains
ho
w
a
sequence
of
c
haracters
is
turned
in
to
a
sequence
of
lexemes.
All
c
haracters
that
precede
the
b
eginning
of
the
mo
dule
are
ignored.
Ignoring
a
c
haracter
do
es
not
c
hange
the
ro
w
or
column
of
an
y
other
c
haracter
in
the
sequence.
The
mo
dule
b
egins
with
a
sequence
of
four
or
more
dashes
(\-"
c
haracters),
follo
w
ed
b
y
zero
or
more
space
c
haracters,
follo
w
ed
b
y
the
six-
c
haracter
string
\MODULE"
.
(This
sequence
of
c
haracters
yields
the
rst
t
w
o
lexemes
of
the
mo
dule.)
The
remaining
sequence
of
c
haracters
is
then
con
v
erted
to
a
sequence
of
lexemes
b
y
iterativ
ely
applying
the
follo
wing
rule
un
til
the
mo
dule-ending
==



==
tok
en
is
found:
The
next
lexeme
b
egins
at
the
next
text
c
haracter
that
is
not
part
of
a
commen
t,
and
consists
of
the
largest
sequence
of
consecutiv
e
c
haracters
that
form
a
legal
TLA
+
lexeme.
(It
is
an
error
if
no
suc
h
lexeme
exists.)
Space,
tab,
and
the
end-of-line
c
haracter
are
not
text
c
haracters.
It
is
undened
whether
c
haracters
suc
h
as
form
feed
are
considered
text
c
haracters.
(Y
ou
should
not
use
suc
h
c
haracters
outside
commen
ts.)
In
the
BNF
grammar,
a
Name
is
a
lexeme
that
can
b
e
used
as
the
name
of
a
record
eld.
The
seman
tics
of
TLA
+
,
in
whic
h
r
:c
is
an
abbreviation
for
r
[\c"
],
w
ould
allo
w
an
y
string
to
b
e
a
Name
.
Ho
w
ev
er,
some
restriction
is
needed|for
example,
allo
wing
a
string
lik
e
\a+b"
to
b
e
a
Name
w
ould
mak
e
it
imp
ossible
in
practice
to
decide
if
r.a+b
mean
t
r
[\a+b"
]
or
r
[\a"
]
+
b
.
The
one
un
usual
restriction
in
the
denition
of
Name
on
page
277
is
the
exclusion
of
strings
b
eginning
with
(but
not
consisting
en
tirely
of
)
\WF_"
and
\SF_"
.
With
this
restriction,
suc
h
strings
are
not
legal
TLA
+
lexemes.
Hence,
the
input
WF_x(A)
is
brok
en
in
to
the
v
e
lexemes
\WF_",
\x",
\("
,
\A"
,
and
\)",
and
it
is
in
terpreted
as
the
expression
WF
x
(A).

Chapter
16
The
Op
erators
of
TLA
+
This
c
hapter
describ
es
the
built-in
op
erators
of
TLA
+
.
Most
of
these
op
erators
ha
v
e
b
een
describ
ed
in
P
art
I.
Here,
y
ou
can
nd
brief
explanations
of
the
op
era-
tors,
along
with
references
to
the
longer
descriptions
in
P
art
I.
The
explanations
co
v
er
some
subtle
p
oin
ts
not
men
tioned
elsewhere.
The
c
hapter
can
serv
e
as
a
reference
man
ual
for
readers
who
ha
v
e
nished
P
art
I
or
who
are
already
familiar
enough
with
the
mathematical
concepts
that
the
brief
explanations
are
all
they
need.
The
c
hapter
includes
a
formal
seman
tics
of
the
op
erators.
The
rigorous
description
of
TLA
+
that
a
formal
seman
tics
pro
vides
is
usually
needed
only
b
y
p
eople
building
TLA
+
to
ols.
If
y
ou're
not
building
a
to
ol
and
don't
ha
v
e
a
sp
ecial
fondness
for
formalism,
y
ou
will
probably
w
an
t
to
skip
all
the
subsections
titled
F
ormal
Semantics.
Ho
w
ev
er,
y
ou
ma
y
some
da
y
encoun
ter
an
obscure
question
ab
out
the
meaning
of
a
TLA
+
op
erator
that
is
answ
ered
only
b
y
the
formal
seman
tics.
This
c
hapter
also
denes
some
of
the
\seman
tic"
conditions
on
the
syn
tax
of
TLA
+
that
are
omitted
from
the
grammar
of
Chapter
15.
F
or
example,
it
tells
y
ou
that
[a
:
Nat
;
a
:
boolean
]
is
an
illegal
expression.
Other
seman
tic
conditions
on
expressions
arise
from
a
com
bination
of
the
denitions
in
this
c
hapter
and
the
conditions
stated
in
Chapter
17.
F
or
example,
this
c
hapter
denes
9
x
;
x
:
p
to
equal
9
x
:
(9
x
:
p
)
,
and
Chapter
17
tells
y
ou
that
the
latter
expression
is
illegal.
16.1
Constan
t
Op
erators
W
e
rst
dene
the
constan
t
op
erators
of
TLA
+
.
These
are
the
op
erators
of
ordinary
mathematics,
ha
ving
nothing
to
do
with
TLA
or
temp
oral
logic.
All
291

292
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
the
constan
t
op
erators
of
TLA
+
are
listed
in
T
able
1
on
page
268
and
T
able
2
on
page
269.
An
op
erator
com
bines
one
or
more
expressions
in
to
a
\larger"
expression.
F
or
example,
the
set
union
op
erator
[
com
bines
t
w
o
expressions
e
1
and
e
2
in
to
the
expression
e
1
[
e
2
.
Some
op
erators
don't
ha
v
e
simple
names
lik
e
[
.
There's
no
name
for
the
op
erator
that
com
bines
the
n
expressions
e
1
,
.
.
.
,
e
n
to
form
the
expression
fe
1
;
:
:
:
;
e
n
g.
W
e
could
name
it
f
;
:
:
:
;
g
or
f
;
:
:
:
;
g,
but
that
w
ould
b
e
a
wkw
ard.
Instead
of
explicitly
men
tioning
the
op
erator,
I'll
refer
to
the
c
onstruct
fe
1
;
:
:
:
;
e
n
g
.
The
distinction
b
et
w
een
an
op
erator
lik
e
[
and
the
nameless
one
used
in
the
construct
fe
1
;
:
:
:
;
e
n
g
is
purely
syn
tactic,
with
no
mathematical
signicance.
In
Chapter
17,
w
e'll
abstract
a
w
a
y
from
this
syn
tactic
dierence
and
treat
all
op
erators
uniformly
.
F
or
no
w,
w
e'll
sta
y
closer
to
the
syn
tax.
F
ormal
Seman
tics
A
formal
seman
tics
for
a
language
is
a
translation
from
that
language
in
to
some
form
of
mathematics.
W
e
assign
a
mathematical
expression
[
[e
]
],
called
the
me
an-
ing
of
e
,
to
certain
terms
e
in
the
language.
Since
w
e
presumably
understand
the
mathematics,
w
e
kno
w
what
[
[e
]
]
means,
and
that
tells
us
what
e
means.
Meaning
is
generally
dened
inductiv
ely
.
F
or
example,
the
meaning
[
[e
1
[
e
2
]
]
of
the
expression
e
1
[
e
2
w
ould
b
e
dened
in
terms
of
the
meanings
[
[e
1
]
]
and
[
[e
2
]
]
of
its
sub
expressions.
This
denition
is
said
to
dene
the
seman
tics
of
the
op
erator
[
.
Because
m
uc
h
of
TLA
+
is
a
language
for
expressing
ordinary
mathemat-
ics,
m
uc
h
of
its
seman
tics
is
trivial.
F
or
example,
the
seman
tics
of
[
can
b
e
dened
b
y
[
[e
1
[
e
2
]
]

=
[
[e
1
]
]
[
[
[e
2
]
]
In
this
denition,
the
[
to
the
left
of
the

=
is
the
TLA
+
sym
b
ol,
while
the
one
to
the
righ
t
is
the
set-union
op
erator
of
ordinary
mathematics.
W
e
could
mak
e
the
distinction
b
et
w
een
the
t
w
o
uses
of
the
sym
b
ol
[
more
ob
vious
b
y
writing
[
[e
1
\
cup
e
2
]
]

=
[
[e
1
]
]
[
[
[e
2
]
]
But
that
w
ouldn't
mak
e
the
denition
an
y
less
trivial.
Instead
of
trying
to
main
tain
a
distinction
b
et
w
een
the
TLA
+
op
erator
[
and
the
op
erator
of
set
theory
that's
written
the
same,
w
e
simply
use
TLA
+
as
the
language
of
mathematics
in
whic
h
to
dene
the
seman
tics
of
TLA
+
.
That
is,
w
e
tak
e
as
primitiv
e
certain
TLA
+
op
erators
that,
lik
e
[
,
corresp
ond
to
w
ell-kno
wn
mathematical
op
erators.
W
e
describ
e
the
formal
seman
tics
of
the
constan
t
op
erators
of
TLA
+
b
y
dening
them
in
terms
of
these
primitiv
e
op-
erators.
W
e
also
describ
e
the
seman
tics
of
some
of
the
primitiv
e
op
erators
b
y
stating
the
axioms
that
they
satisfy
.

16.1.
CONST
ANT
OPERA
TORS
293
16.1.1
Bo
olean
Op
erators
The
truth
v
alues
of
logic
are
written
in
TLA
+
as
tr
ue
and
f
alse.
The
built-in
constan
t
boolean
is
the
set
consisting
of
those
t
w
o
v
alues:
boolean

=
ftr
ue;
f
alseg
TLA
+
pro
vides
the
usual
op
erators
1
of
prop
ositional
logic:
^
_
:
)
(implication)

tr
ue
f
alse
They
are
explained
in
Section
1.1.
Conjunctions
and
disjunctions
can
also
b
e
written
as
aligned
lists:
^
p
1
.
.
.
^
p
n

=
p
1
^
:
:
:
^
p
n
_
p
1
.
.
.
_
p
n

=
p
1
_
:
:
:
_
p
n
The
standard
quan
tied
form
ulas
of
predicate
logic
are
written
in
TLA
+
as
8
x
:
p
9
x
:
p
I
call
these
the
unb
ounde
d
quan
tier
constructions.
The
b
ounde
d
v
ersions
are
written
as
8
x
2
S
:
p
9
x
2
S
:
p
The
meanings
of
these
expressions
are
describ
ed
in
Section
1.3.
TLA
+
allo
ws
some
common
abbreviations|for
example:
8
x
;
y
:
p

=
8
x
:
(8
y
:
p
)
9
x
;
y
2
S
;
z
2
T
:
p

=
9
x
2
S
:
(9
y
2
S
:
(9
z
2
T
:
p
))
TLA
+
also
allo
ws
b
ounded
quan
tication
o
v
er
tuples,
suc
h
as
8
h
x
;
y
i
2
S
:
p
This
form
ula
is
true
i,
for
an
y
pair
h
a
;
b
i
in
S
,
the
form
ula
obtained
from
p
b
y
substituting
a
for
x
and
b
for
y
is
true.
F
ormal
Seman
tics
Prop
ositional
and
predicate
logic,
along
with
set
theory
,
form
the
foundation
of
ordinary
mathematics.
In
dening
the
seman
tics
of
TLA
+
,
w
e
therefore
tak
e
as
primitiv
es
the
op
erators
of
prop
ositional
logic
and
the
simple
un
b
ounded
quan
tier
constructs
9
x
:
p
and
8
x
:
p
,
where
x
is
an
iden
tier.
Among
the
1
tr
ue
and
f
alse
are
op
erators
that
tak
e
no
argumen
ts.

294
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
Bo
olean
op
erators
describ
ed
ab
o
v
e,
this
lea
v
es
only
the
general
forms
of
the
quan
tiers,
giv
en
b
y
the
BNF
grammar
of
Chapter
15,
whose
meanings
m
ust
b
e
dened.
This
is
done
b
y
dening
those
general
forms
in
terms
of
the
simple
forms.
The
un
b
ounded
op
erators
ha
v
e
the
general
forms
8
x
1
;
:
:
:
;
x
n
:
p
9
x
1
;
:
:
:
;
x
n
:
p
where
eac
h
x
i
is
an
iden
tier.
They
are
dened
in
terms
of
quan
tication
o
v
er
a
single
v
ariable
b
y
8
x
1
;
:
:
:
;
x
n
:
p

=
8
x
1
:
(8
x
2
:
(:
:
:
8
x
n
:
p
)
:
:
:
)
and
similarly
for
9
.
The
b
ounded
op
erators
ha
v
e
the
general
forms
8
y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
:
p
9
y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
:
p
where
eac
h
y
i
has
the
form
x
1
;
:
:
:
;
x
k
or
h
x
1
;
:
:
:
;
x
k
i
,
and
eac
h
x
j
is
an
iden
ti-
er.
The
general
forms
of
8
are
dened
inductiv
ely
b
y
8
x
1
;
:
:
:
;
x
k
2
S
:
p

=
8
x
1
;
:
:
:
;
x
k
:
(x
1
2
S
)
^
:
:
:
^
(x
k
2
S
)
)
p
8
y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
:
p

=
8
y
1
2
S
1
:
:
:
:
8
y
n
2
S
n
:
p
8
h
x
1
;
:
:
:
;
x
k
i
2
S
:
p

=
8
x
1
;
:
:
:
;
x
k
:
(h
x
1
;
:
:
:
;
x
k
i
2
S
)
)
p
where
the
y
i
are
as
b
efore.
In
these
expressions,
S
and
the
S
i
lie
outside
the
scop
e
of
the
quan
tier's
b
ound
iden
tiers.
The
denitions
for
9
are
similar.
In
particular:
9
h
x
1
;
:
:
:
;
x
k
i
2
S
:
p

=
9
x
1
;
:
:
:
;
x
k
:
(h
x
1
;
:
:
:
;
x
k
i
2
S
)
^
p
See
Section
16.1.9
for
further
details
ab
out
tuples.
16.1.2
The
Cho
ose
Op
erator
A
simple
un
b
ounded
choose
expression
has
the
form
choose
x
:
p
As
explained
in
Section
6.6,
the
v
alue
of
this
expression
is
some
arbitrary
v
alue
v
suc
h
that
p
is
true
if
v
is
substituted
for
x
,
if
suc
h
a
v
exists.
If
no
suc
h
v
exists,
then
the
expression
has
a
completely
arbitrary
v
alue.
The
b
ounded
form
of
the
choose
expression
is
choose
x
2
S
:
p

16.1.
CONST
ANT
OPERA
TORS
295
It
is
dened
in
terms
of
the
un
b
ounded
form
b
y
choose
x
2
S
:
p

=
choose
x
:
(x
2
S
)
^
p
(16.1)
It
is
equal
to
some
arbitrary
v
alue
v
in
S
suc
h
that
p
,
with
v
substituted
for
x
,
is
true|if
suc
h
a
v
exists.
If
no
suc
h
v
exists,
the
choose
expression
has
a
completely
arbitrary
v
alue.
A
choose
expression
can
also
b
e
used
to
c
ho
ose
a
tuple.
F
or
example,
choose
h
x
;
y
i
2
S
:
p
equals
some
pair
h
v
;
w
i
in
S
suc
h
that
p
,
with
v
substituted
for
x
and
w
sub-
stituted
for
y
,
is
true|if
suc
h
a
pair
exists.
If
no
suc
h
pair
exists,
it
has
an
arbitrary
v
alue,
whic
h
need
not
b
e
a
pair.
The
un
b
ounded
choose
op
erator
satises
the
follo
wing
t
w
o
rules:
(9
x
:
P
(x
))

P
(choose
x
:
P
(x
))
(8
x
:
P
(x
)
=
Q
(x
))
)
((choose
x
:
P
(x
))
=
(choose
x
:
Q
(x
)))
(16.2)
for
an
y
op
erators
P
and
Q
.
W
e
kno
w
nothing
ab
out
the
v
alue
c
hosen
b
y
choose
except
what
w
e
can
deduce
from
these
rules.
The
second
rule
allo
ws
us
to
deduce
the
equalit
y
of
certain
choose
expres-
sions
that
w
e
migh
t
exp
ect
to
b
e
dieren
t.
In
particular,
for
an
y
op
erator
P
,
if
there
exists
no
x
satisfying
P
(x
),
then
choose
x
:
P
(x
)
equals
the
unique
v
alue
choose
x
:
f
alse.
F
or
example,
the
R
e
als
mo
dule
denes
division
b
y
a
=b

=
choose
c
2
R
e
al
:
a
=
b

c
F
or
an
y
nonzero
n
um
b
er
a
,
there
exists
no
n
um
b
er
c
suc
h
that
a
=
0

c
.
Hence,
a
=0
equals
choose
c
:
f
alse,
for
an
y
nonzero
a
.
W
e
can
therefore
deduce
that
1=0
equals
2=0.
W
e
w
ould
exp
ect
to
b
e
unable
to
deduce
an
ything
ab
out
the
nonsensical
expression
1=0.
It's
a
bit
disquieting
to
pro
v
e
that
it
equals
2=0.
If
this
upsets
y
ou,
here's
a
w
a
y
to
dene
division
that
will
mak
e
y
ou
happier.
First
dene
an
op
erator
Choic
e
so
that
Choic
e
(v
;
P
)
equals
choose
x
:
P
(x
)
if
there
exists
an
x
satisfying
P
(x
),
and
otherwise
equals
some
arbitrary
v
alue
that
dep
ends
on
v
.
There
are
man
y
w
a
ys
to
dene
Choic
e
;
here's
one:
Choic
e
(v
;
P
(
))

=
if
9
x
:
P
(x
)
then
choose
x
:
P
(x
)
else
(choose
x
:
x
:a
=
v
):b
Y
ou
can
then
dene
division
b
y
a
=b

=
let
P
(c
)

=
(c
2
R
e
al
)
^
(a
=
b

c
)
in
Choic
e
(a
;
P
)
This
denition
mak
es
it
imp
ossible
to
deduce
an
y
relation
b
et
w
een
1=0
and
2=0.
Y
ou
can
use
Choic
e
instead
of
choose
whenev
er
this
kind
of
problem
arises|if
y
ou
consider
1=0
equaling
2=0
to
b
e
a
problem.
But
there
is
seldom
an
y
practical
reason
for
w
orrying
ab
out
it.

296
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
F
ormal
Seman
tics
W
e
tak
e
the
construct
choose
x
:
p
,
where
x
is
an
iden
tier,
to
b
e
primitiv
e.
This
form
of
the
choose
op
erator
is
kno
wn
to
mathematicians
as
Hilb
ert's
".
Its
meaning
is
dened
mathematically
b
y
the
rules
(16.2).
2
An
un
b
ounded
choose
of
a
tuple
is
dened
in
terms
of
the
simple
un
b
ounded
choose
construct
b
y
choose
h
x
1
;
:
:
:
;
x
n
i
:
p

=
choose
y
:
(9
x
1
;
:
:
:
;
x
n
:
(y
=
h
x
1
;
:
:
:
;
x
n
i)
^
p
)
where
y
is
an
iden
tier
that
is
dieren
t
from
the
x
i
and
do
es
not
o
ccur
in
p
.
The
b
ounded
choose
construct
is
dened
in
terms
of
un
b
ounded
choose
b
y
(16.1),
where
x
can
b
e
either
an
iden
tier
or
a
tuple.
16.1.3
In
terpretations
of
Bo
olean
Op
erators
The
meaning
of
a
Bo
olean
op
erator
when
applied
to
Bo
olean
v
alues
is
a
standard
part
of
traditional
mathematics.
Ev
ery
one
agrees
that
tr
ue
^
f
alse
equals
f
alse.
Ho
w
ev
er,
b
ecause
TLA
+
is
un
t
yp
ed,
an
expression
lik
e
2
^
h
5
i
is
legal.
W
e
m
ust
therefore
decide
what
it
means.
There
are
three
w
a
ys
of
doing
this,
whic
h
I
call
the
c
onservative,
mo
der
ate,
and
lib
er
al
in
terpretations.
In
the
conserv
ativ
e
in
terpretation,
the
v
alue
of
an
expression
lik
e
2
^
h
5
i
is
completely
unsp
ecied.
It
could
equal
p
2
.
It
need
not
equal
h
5
i
^
2
.
Hence,
the
ordinary
la
ws
of
logic,
suc
h
as
the
comm
utativit
y
of
^,
are
v
alid
only
for
Bo
olean
v
alues.
In
the
lib
eral
in
terpretation,
the
v
alue
of
2
^
h
5
i
is
sp
ecied
to
b
e
a
Bo
olean.
It
is
not
sp
ecied
whether
it
equals
tr
ue
or
f
alse.
Ho
w
ev
er,
all
the
ordinary
la
ws
of
logic,
suc
h
as
the
comm
utativit
y
of
^,
are
v
alid.
Hence,
2
^
h
5
i
equals
h
5
i
^
2.
More
precisely
,
an
y
tautology
of
prop
ositional
or
predicate
logic,
suc
h
as
(8
x
:
p
)

:(9
x
:
:p
)
is
v
alid,
ev
en
if
p
is
not
necessarily
a
Bo
olean
for
all
v
alues
of
x
.
3
It
is
easy
to
sho
w
that
the
lib
eral
approac
h
is
sound.
4
F
or
example,
one
w
a
y
of
dening
op
erators
that
satisfy
the
lib
eral
in
terpretation
is
to
consider
an
y
non-Bo
olean
v
alue
to
b
e
equiv
alen
t
to
f
alse.
The
conserv
ativ
e
and
lib
eral
in
terpretations
are
equiv
alen
t
for
most
sp
eci-
cations,
except
for
ones
that
use
Bo
olean-v
alued
functions.
In
practice,
the
2
Hilb
ert's
"
is
discussed
at
length
in
Mathematic
al
L
o
gic
and
Hilb
ert's
"-Symb
ol
b
y
A.
C.
Leisenring,
published
b
y
Gordon
and
Breac
h,
New
Y
ork,
1969.
3
Equalit
y
(=)
is
not
an
op
erator
of
prop
ositional
or
predicate
logic;
this
tautology
need
not
b
e
v
alid
for
non-Bo
olean
v
alues
if

is
replaced
b
y
=.
4
A
sound
logic
is
one
in
whic
h
f
alse
is
not
pro
v
able.

16.1.
CONST
ANT
OPERA
TORS
297
conserv
ativ
e
in
terpretation
do
esn't
p
ermit
y
ou
to
use
f
[x
]
as
a
Bo
olean
expres-
sion
ev
en
if
f
is
dened
to
b
e
a
Bo
olean-v
alued
function.
F
or
example,
supp
ose
w
e
dene
the
function
tnat
b
y
tnat

=
[n
2
Nat
7!
tr
ue]
so
tnat
[n
]
equals
tr
ue
for
all
n
in
Nat
.
The
form
ula
8
n
2
Nat
:
tnat
[n
]
(16.3)
equals
tr
ue
in
the
lib
eral
in
terpretation,
but
not
in
the
conserv
ativ
e
in
terpre-
tation.
F
orm
ula
(16.3)
is
equiv
alen
t
to
8
n
:
(n
2
Nat
)
)
tnat
[n
]
whic
h
asserts
that
(n
2
Nat
)
)
tnat
[n
]
is
true
for
all
n
,
including,
for
example,
n
=
1=2.
F
or
(16.3)
to
equal
tr
ue,
the
form
ula
(1=2
2
Nat
)
)
tnat
[1=2],
whic
h
equals
f
alse
)
tnat
[1=2],
m
ust
equal
tr
ue
.
But
the
v
alue
of
tnat
[1=2]
is
not
sp
ecied;
it
migh
t
equal
p
2
.
The
form
ula
f
alse
)
p
2
equals
tr
ue
in
the
lib
eral
in
terpretation;
its
v
alue
is
unsp
ecied
in
the
conserv
ativ
e
in
terpretation.
Hence,
the
v
alue
of
(16.3)
is
unsp
ecied
in
the
conserv
ativ
e
in
terpretation.
If
w
e
are
using
the
conserv
ativ
e
in
terpretation,
instead
of
(16.3),
w
e
should
write
8
n
2
Nat
:
(tnat
[n
]
=
tr
ue
)
This
form
ula
equals
tr
ue
in
b
oth
in
terpretations.
The
conserv
ativ
e
in
terpretation
is
philosophically
more
satisfying,
since
it
mak
es
no
assumptions
ab
out
a
silly
expression
lik
e
2
^
h
5
i.
Ho
w
ev
er,
as
w
e
ha
v
e
just
seen,
it
w
ould
b
e
nice
if
the
not-so-silly
form
ula
f
alse
)
p
2
equaled
tr
ue
.
W
e
therefore
in
tro
duce
the
mo
derate
in
terpretation,
whic
h
lies
b
et
w
een
the
conserv
ativ
e
and
lib
eral
in
terpretations.
It
assumes
only
that
expressions
in
v
olving
f
alse
and
tr
ue
ha
v
e
their
exp
ected
v
alues|for
example,
f
alse
)
p
2
equals
tr
ue,
and
f
alse
^
2
equals
f
alse.
In
the
mo
derate
in
terpretation,
(16.3)
equals
tr
ue,
but
the
v
alue
of
h
5
i
^
2
is
still
completely
unsp
ecied.
The
la
ws
of
logic
still
do
not
hold
unconditionally
in
the
mo
derate
in
terpre-
tation.
The
form
ulas
p
^
q
and
q
^
p
are
equiv
alen
t
only
if
p
and
q
are
b
oth
Bo
oleans,
or
if
one
of
them
equals
f
alse.
When
using
the
mo
derate
in
terpre-
tation,
w
e
still
ha
v
e
to
c
hec
k
that
all
the
relev
an
t
v
alues
are
Bo
oleans
b
efore
applying
an
y
of
the
ordinary
rules
of
logic
in
a
pro
of.
This
can
b
e
burdensome
in
practice.
The
seman
tics
of
TLA
+
asserts
that
the
rules
of
the
mo
derate
in
terpreta-
tion
are
v
alid.
The
lib
eral
in
terpretation
is
neither
required
nor
forbidden.
Y
ou
should
write
sp
ecications
that
mak
e
sense
under
the
mo
derate
in
terpretation.
Ho
w
ev
er,
y
ou
(and
the
implemen
ter
of
a
to
ol)
are
free
to
use
the
lib
eral
in
ter-
pretation
if
y
ou
wish.

298
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
16.1.4
Conditional
Constructs
TLA
+
pro
vides
t
w
o
conditional
constructs
for
forming
expressions
that
are
in-
spired
b
y
constructs
from
programming
languages:
if/then/else
and
case.
The
if/then/else
construct
w
as
in
tro
duced
on
page
16
of
Section
2.2.
Its
general
form
is
if
p
then
e
1
else
e
2
It
equals
e
1
if
p
is
true,
and
e
2
if
p
is
false.
An
expression
can
sometimes
b
e
simplied
b
y
using
a
case
construct
instead
of
nested
if/then/else
constructs.
The
case
construct
has
t
w
o
general
forms:
case
p
1
!
e
1
2
:
:
:
2
p
n
!
e
n
case
p
1
!
e
1
2
:
:
:
2
p
n
!
e
n
2
other
!
e
(16.4)
If
some
p
i
is
true,
then
the
v
alue
of
these
expressions
is
some
e
i
suc
h
that
p
i
is
true.
F
or
example,
the
expression
case
n

0
!
e
1
2
n

0
!
e
2
equals
e
1
if
n
>
0
is
true,
equals
e
2
if
n
<
0
is
true,
and
equals
either
e
1
or
e
2
if
n
=
0
is
true.
In
the
latter
case,
the
seman
tics
of
TLA
+
do
es
not
sp
ecify
whether
the
expression
equals
e
1
or
e
2
.
The
case
expressions
(16.4)
are
generally
used
when
the
p
i
are
m
utually
disjoin
t,
so
at
most
one
p
i
can
b
e
true.
The
t
w
o
expressions
(16.4)
dier
when
p
i
is
false
for
all
i
.
In
that
case,
the
v
alue
of
the
rst
is
unsp
ecied,
while
the
v
alue
of
the
second
is
e
,
the
other
expression.
If
y
ou
use
a
case
expression
without
an
other
clause,
the
v
alue
of
the
expression
should
matter
only
when
9
i
2
1
:
:
n
:
p
i
is
true.
F
ormal
Seman
tics
The
if/then/else
and
case
constructs
are
dened
as
follo
ws
in
terms
of
choose:
if
p
then
e
1
else
e
2

=
choose
v
:
(p
)
(v
=
e
1
))
^
(:p
)
(v
=
e
2
))
case
p
1
!
e
1
2
:
:
:
2
p
n
!
e
n

=
choose
v
:
(p
1
^
(v
=
e
1
))
_
:
:
:
_
(p
n
^
(v
=
e
n
))
case
p
1
!
e
1
2
:
:
:
2
p
n
!
e
n
2
other
!
e

=
case
p
1
!
e
1
2
:
:
:
2
p
n
!
e
n
2
:(p
1
_
:
:
:
_
p
n
)
!
e

16.1.
CONST
ANT
OPERA
TORS
299
16.1.5
The
Let/In
Construct
The
let/in
construct
w
as
in
tro
duced
on
page
60
of
Section
5.6.
The
expression
let
d

=
f
in
e
equals
e
in
the
con
text
of
the
denition
d

=
f
.
F
or
example,
let
sq
(i
)

=
i

i
in
sq
(1)
+
sq
(2)
+
sq
(3)
equals
1

1
+
2

2
+
3

3,
whic
h
equals
14.
The
general
form
of
the
construct
is
let

1
:
:
:

n
in
e
where
eac
h

i
has
the
syn
tactic
form
of
an
y
TLA
+
denition.
Its
v
alue
is
e
in
the
con
text
of
the
denitions

i
.
More
precisely
,
it
equals
let

1
in
(let

2
in
(
:
:
:
let

n
in
e
)
:
:
:
)
Hence,
the
sym
b
ol
dened
in

1
can
b
e
used
in
the
denitions

2
,
.
.
.
,

n
.
F
ormal
Seman
tics
The
formal
seman
tics
of
the
let
construct
is
dened
b
elo
w
in
Section
17.4
(page
325).
16.1.6
The
Op
erators
of
Set
Theory
TLA
+
pro
vides
the
follo
wing
op
erators
on
sets:
2
=
2
[
\

n
union
subset
and
the
follo
wing
set
constructors:
fe
1
;
:
:
:
;
e
n
g
fx
2
S
:
p
g
fe
:
x
2
S
g
They
are
all
describ
ed
in
Section
1.2
(page
11)
and
Section
6.1
(page
65).
Equal-
it
y
is
also
an
op
erator
of
set
theory
,
since
it
formally
means
equalit
y
of
sets.
TLA
+
pro
vides
the
usual
op
erators
=
and
6=.
The
set
construct
fx
2
S
:
p
g
can
also
b
e
used
with
x
a
tuple
of
iden
tiers.
F
or
example,
fh
a
;
b
i
2
Nat

Nat
:
a
>
b
g
is
the
set
of
all
pairs
of
natural
n
um
b
ers
whose
rst
comp
onen
t
is
greater
than
its
second|pairs
suc
h
as
h
3;
1
i.
In
the
set
construct
fe
:
x
2
S
g,
the
clause
x
2
S
can
b
e
generalized
in
exactly
the
same
w
a
y
as
in
a
b
ounded
quan
tier
suc
h
as
8
x
2
S
:
p
.
F
or
example,
fh
a
;
b
;
c
i
:
a
;
b
2
Nat
;
c
2
R
e
al
g
is
the
set
of
all
triples
whose
rst
t
w
o
comp
onen
ts
are
natural
n
um
b
ers
and
whose
third
comp
onen
t
is
a
real
n
um
b
er.

300
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
F
ormal
Seman
tics
TLA
+
is
based
on
Zermelo-F
r
ank
el
set
theory
,
in
whic
h
ev
ery
v
alue
is
a
set.
In
set
theory
,
2
is
tak
en
as
a
primitiv
e,
undened
op
erator.
W
e
could
dene
all
the
other
op
erators
of
set
theory
in
terms
of
2
,
using
predicate
logic
and
the
choose
op
erator.
F
or
example,
set
union
could
b
e
dened
b
y
S
[
T

=
choose
U
:
8
x
:
(x
2
U
)

(x
2
S
)
_
(x
2
T
)
(T
o
reason
ab
out
[
,
w
e
w
ould
need
axioms
from
whic
h
w
e
can
deduce
the
existence
of
the
c
hosen
set
U
.)
Another
approac
h
w
e
could
tak
e
is
to
let
certain
of
the
op
erators
b
e
primitiv
e
and
dene
the
rest
in
terms
of
them.
F
or
example,
[
can
b
e
dened
in
terms
of
union
and
the
construct
fe
1
;
:
:
:
;
e
n
g
b
y
S
[
T

=
union
fS
;
T
g
W
e
w
on't
try
to
distinguish
a
small
set
of
primitiv
e
op
erators;
instead,
w
e
treat
[
and
union
as
equally
primitiv
e.
Op
erators
that
w
e
tak
e
to
b
e
primitiv
e
are
dened
mathematically
in
terms
of
the
rules
that
they
satisfy
.
F
or
example,
S
[
T
is
dened
b
y
8
x
:
(x
2
(S
[
T
))

(x
2
S
)
_
(x
2
T
)
Ho
w
ev
er,
there
is
no
suc
h
dening
rule
for
the
primitiv
e
op
erator
2
.
W
e
tak
e
only
the
simple
forms
of
the
constructs
fx
2
S
:
p
g
and
fe
:
x
2
S
g
as
primitiv
e,
and
w
e
dene
the
more
general
forms
in
terms
of
them.
S
=
T

=
8
x
:
(x
2
S
)

(x
2
T
)
.
e
1
6=
e
2

=
:(e
1
=
e
2
).
e
=
2
S

=
:(e
2
S
).
S
[
T
is
dened
b
y
8
x
:
(x
2
(S
[
T
))

(x
2
S
)
_
(x
2
T
).
S
\
T
is
dened
b
y
8
x
:
(x
2
(S
\
T
))

(x
2
S
)
^
(x
2
T
).
S

T

=
8
x
:
(x
2
S
)
)
(x
2
T
)
.
S
nT
is
dened
b
y
8
x
:
(x
2
(S
nT
))

(x
2
S
)
^
(x
=
2
T
).
subset
S
is
dened
b
y
8
T
:
(T
2
subset
S
)

(T

S
).
union
S
is
dened
b
y
8
x
:
(x
2
union
S
)

(9
T
2
S
:
x
2
T
).
fe
1
;
:
:
:
;
e
n
g

=
fe
1
g
[
:
:
:
[
fe
n
g,
where
fe
g
is
dened
b
y
8
x
:
(x
2
fe
g)

(x
=
e
)
F
or
n
=
0,
this
construct
is
the
empt
y
set
fg,
dened
b
y
8
x
:
x
=
2
fg

16.1.
CONST
ANT
OPERA
TORS
301
fx
2
S
:
p
g
where
x
is
a
b
ound
iden
tier
or
a
tuple
of
b
ound
iden
tiers.
The
expression
S
is
outside
the
scop
e
of
the
b
ound
iden
tier(s).
F
or
x
an
iden
tier,
this
is
a
primitiv
e
expression
that
is
dened
mathemati-
cally
b
y
8
y
:
(y
2
fx
2
S
:
p
g)

(y
2
S
)
^
b
p
where
the
iden
tier
y
do
es
not
o
ccur
in
S
or
p
,
and
b
p
is
p
with
y
substituted
for
x
.
F
or
x
a
tuple,
the
expression
is
dened
b
y
fh
x
1
;
:
:
:
;
x
n
i
2
S
:
p
g

=
fy
2
S
:
(9
x
1
;
:
:
:
;
x
n
:
(y
=
h
x
1
;
:
:
:
;
x
n
i)
^
p
)g
where
y
is
an
iden
tier
dieren
t
from
the
x
i
that
do
es
not
o
ccur
in
S
or
p
.
See
Section
16.1.9
for
further
details
ab
out
tuples.
fe
:
y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
g
where
eac
h
y
i
has
the
form
x
1
;
:
:
:
;
x
k
or
h
x
1
;
:
:
:
;
x
k
i,
and
eac
h
x
j
is
an
iden
tier
that
is
b
ound
in
the
expression.
The
expressions
S
i
lie
outside
the
scop
e
of
the
b
ound
iden
tiers.
The
simple
form
fe
:
x
2
S
g,
for
x
an
iden
tier,
is
tak
en
to
b
e
primitiv
e
and
is
dened
b
y
8
y
:
(y
2
fe
:
x
2
S
g)

(9
x
2
S
:
e
=
y
)
The
general
form
is
dened
inductiv
ely
in
terms
of
the
simple
form
b
y
fe
:
y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
g

=
union
f
fe
:
y
1
2
S
1
;
:
:
:
;
y
n
 1
2
S
n
 1
g
:
y
n
2
S
n
g
fe
:
x
1
;
:
:
:
;
x
n
2
S
g

=
fe
:
x
1
2
S
;
:
:
:
;
x
n
2
S
g
fe
:
h
x
1
;
:
:
:
;
x
n
i
2
S
g

=
f(let
z

=
choose
h
x
1
;
:
:
:
;
x
n
i
:
y
=
h
x
1
;
:
:
:
;
x
n
i
x
1

=
z
[1]
.
.
.
x
n

=
z
[n
]
in
e
)
:
y
2
S
g
where
the
x
i
are
iden
tiers,
and
y
and
z
are
iden
tiers
distinct
from
the
x
i
that
do
not
o
ccur
in
e
or
S
.
See
Section
16.1.9
for
further
details
ab
out
tuples.
16.1.7
F
unctions
F
unctions
are
describ
ed
in
Section
5.2
(page
48);
the
dierence
b
et
w
een
functions
and
op
erators
is
discussed
in
Section
6.4
(page
69).
In
TLA
+
,
w
e
write
f
[v
]
for

302
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
the
v
alue
of
the
function
f
applied
to
v
.
A
function
f
has
a
domain
domain
f
,
and
the
v
alue
of
f
[v
]
is
sp
ecied
only
if
v
is
an
elemen
t
of
domain
f
.
W
e
let
[S
!
T
]
denote
the
set
of
all
functions
f
suc
h
that
domain
f
=
S
and
f
[v
]
2
T
,
for
all
v
2
S
.
F
unctions
can
b
e
describ
ed
explicitly
with
the
construct
[x
2
S
7!
e
]
(16.5)
This
is
the
function
f
with
domain
S
suc
h
that
f
[v
]
equals
the
v
alue
obtained
b
y
substituting
v
for
x
in
e
,
for
an
y
v
2
S
.
F
or
example,
[n
2
Nat
7!
1=(n
+
1)]
is
the
function
f
with
domain
Nat
suc
h
that
f
[0]
=
1,
f
[1]
=
1=2,
f
[2]
=
1=3,
etc.
W
e
can
dene
an
iden
tier
fcn
to
equal
the
function
(16.5)
b
y
writing
fcn
[x
2
S
]

=
e
(16.6)
The
iden
tier
fcn
can
app
ear
in
the
expression
e
,
in
whic
h
case
this
is
a
recursiv
e
function
denition.
Recursiv
e
function
denitions
w
ere
in
tro
duced
in
Section
5.5
(page
54)
and
discussed
in
Section
6.3
(page
67).
The
ex
cept
construct
describ
es
a
function
that
is
\almost
the
same
as"
another
function.
F
or
example,
[f
ex
cept
!
[u
]
=
a
;
!
[v
]
=
b
]
(16.7)
is
the
function
b
f
that
is
the
same
as
f
,
except
that
b
f
[u
]
=
a
and
b
f
[v
]
=
b
.
More
precisely
,
(16.7)
equals
[x
2
domain
f
7!
if
x
=
v
then
b
else
if
x
=
u
then
a
else
f
[x
]]
Hence,
if
neither
u
nor
v
is
in
the
domain
of
f
,
then
(16.7)
equals
f
.
If
u
=
v
,
then
(16.7)
equals
[f
ex
cept
!
[v
]
=
b
].
An
exception
clause
can
ha
v
e
the
general
form
!
[v
1
]



[v
n
]
=
e
.
F
or
exam-
ple,
[f
ex
cept
!
[u
][v
]
=
a
]
(16.8)
is
the
function
e
f
that
is
the
same
as
f
,
except
that
e
f
[u
][v
]
equals
a
.
That
is,
e
f
is
the
same
as
f
,
except
that
e
f
[u
]
is
the
function
that
is
the
same
as
f
[u
],
except
that
e
f
[u
][v
]
=
a
.
The
sym
b
ol
@
o
ccurring
in
an
exception
clause
stands
for
the
\original
v
alue".
F
or
example,
an
@
in
the
expression
a
of
(16.8)
denotes
f
[u
][v
].
In
TLA
+
,
a
function
of
m
ultiple
argumen
ts
is
one
whose
domain
is
a
set
of
tuples;
and
f
[v
1
;
:
:
:
;
v
n
]
is
an
abbreviation
for
f
[h
v
1
;
:
:
:
;
v
n
i].
The
x
2
S
clause
(16.5)
and
(16.6)
can
b
e
generalized
in
the
same
w
a
y
as
in
a
b
ounded
quan
tier|
for
example,
here
are
t
w
o
dieren
t
w
a
ys
of
writing
the
same
function:
[m
;
n
2
Nat
;
r
2
R
e
al
7!
e
]
[h
m
;
n
;
r
i
2
Nat

Nat

R
e
al
7!
e
]

16.1.
CONST
ANT
OPERA
TORS
303
This
is
a
function
whose
domain
is
a
set
of
triples.
It
is
not
the
same
as
the
function
[h
m
;
n
i
2
Nat

Nat
;
r
2
R
e
al
7!
e
]
whose
domain
is
the
set
(Nat

Nat
)

R
e
al
of
pairs
lik
e
h
h
1;
3
i;
1=3
i,
whose
rst
elemen
t
is
a
pair
of
natural
n
um
b
ers.
F
ormal
Seman
tics
Mathematicians
traditionally
dene
a
function
to
b
e
a
set
of
pairs.
In
TLA
+
,
pairs
(and
all
tuples)
are
functions.
W
e
tak
e
as
primitiv
es
the
constructs
f
[e
]
domain
f
[S
!
T
]
[x
2
S
7!
e
]
where
x
is
an
iden
tier.
These
constructs
are
dened
mathematically
b
y
the
rules
they
satisfy
.
The
other
constructs,
and
the
general
forms
of
the
construct
[x
2
S
7!
e
],
are
dened
in
terms
of
them.
These
denitions
use
the
op
erator
IsAFcn
,
whic
h
is
dened
as
follo
ws
so
that
IsAFcn
(f
)
is
true
i
f
is
a
function:
IsAFcn
(f
)

=
f
=
[x
2
domain
f
7!
f
[x
]]
The
rst
rule,
whic
h
is
not
naturally
asso
ciated
with
an
y
one
construct,
is
that
t
w
o
functions
are
equal
i
they
ha
v
e
the
same
domain
and
assign
the
same
v
alue
to
eac
h
elemen
t
in
their
domain:
8
f
;
g
:
IsAFcn
(f
)
^
IsAFcn
(g
)
)
((f
=
g
)

^
domain
f
=
domain
g
^
8
x
2
domain
f
:
f
[x
]
=
g
[x
]
)
The
rest
of
the
seman
tics
of
functions
is
giv
en
b
elo
w.
There
is
no
separate
dening
rule
for
the
domain
op
erator.
f
[e
1
;
:
:
:
;
e
n
]
where
the
e
i
are
expressions.
F
or
n
=
1,
this
is
a
primitiv
e
expression.
F
or
n
>
1,
it
is
dened
b
y
f
[e
1
;
:
:
:
;
e
n
]
=
f
[h
e
1
;
:
:
:
;
e
n
i]
The
tuple
h
e
1
;
:
:
:
;
e
n
i
is
dened
in
Section
16.1.9.
[y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
7!
e
]
where
eac
h
y
i
has
the
form
x
1
;
:
:
:
;
x
k
or
h
x
1
;
:
:
:
;
x
k
i
,
and
eac
h
x
j
is
an
iden
tier
that
is
b
ound
in
the
expression.
The
expressions
S
i
lie
outside
the
scop
e
of
the
b
ound
iden
tiers.
The
simple
form
[x
2
S
7!
e
],
for
x
an
iden
tier,
is
primitiv
e
and
is
dened
b
y
t
w
o
rules:
(domain
[x
2
S
7!
e
])
=
S
8
y
2
S
:
[x
2
S
7!
e
][y
]
=
let
x

=
y
in
e

304
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
where
y
is
an
iden
tier
dieren
t
from
x
that
do
es
not
o
ccur
in
S
or
e
.
The
general
form
of
the
construct
is
dened
inductiv
ely
in
terms
of
the
simple
form
b
y
[x
1
2
S
1
;
:
:
:
;
x
n
2
S
n
7!
e
]

=
[
h
x
1
;
:
:
:
;
x
n
i
2
S
1

:
:
:

S
n
7!
e
]
[
:
:
:
;
x
1
;
:
:
:
;
x
k
2
S
i
;
:
:
:
7!
e
]

=
[
:
:
:
;
x
1
2
S
i
;
:
:
:
;
x
k
2
S
i
;
:
:
:
7!
e
]
[
:
:
:
;
h
x
1
;
:
:
:
;
x
k
i
2
S
i
;
:
:
:
7!
e
]

=
[
:
:
:
;
y
2
S
i
;
:
:
:
7!
let
z

=
choose
h
x
1
;
:
:
:
;
x
k
i
:
y
=
h
x
1
;
:
:
:
;
x
k
i
x
1

=
z
[1]
.
.
.
x
k

=
z
[k
]
in
e
]
where
y
and
z
are
iden
tiers
that
do
not
app
ear
an
ywhere
in
the
original
expression.
See
Section
16.1.9
for
details
ab
out
tuples.
[S
!
T
]
is
dened
b
y
8
f
:
f
2
[S
!
T
]

IsAFcn
(f
)
^
(S
=
domain
f
)
^
(8
x
2
S
:
f
[x
]
2
T
)
where
x
and
f
do
not
o
ccur
in
S
or
T
,
and
IsAFcn
is
dened
ab
o
v
e.
[f
ex
cept
!a
1
=
e
1
;
:
:
:
;
!a
n
=
e
n
]
where
eac
h
a
i
has
the
form
[d
1
]
:
:
:
[d
k
]
and
eac
h
d
j
is
an
expression.
F
or
the
simple
case
when
n
=
1
and
a
1
is
[d
],
this
is
dened
b
y
5
[f
ex
cept
!
[d
]
=
e
]

=
[y
2
domain
f
7!
if
y
=
d
then
let
@

=
f
[d
]
in
e
else
f
[y
]
]
where
y
do
es
not
o
ccur
in
f
,
d
,
or
e
.
The
general
form
is
dened
induc-
tiv
ely
in
terms
of
this
simple
case
b
y
[f
ex
cept
!
a
1
=
e
1
;
:
:
:
;
!
a
n
=
e
n
]

=
[
[f
ex
cept
!
a
1
=
e
1
;
:
:
:
;
!
a
n
 1
=
e
n
 1
]
ex
cept
!
a
n
=
e
n
]
[f
ex
cept
!
[d
1
]
:
:
:
[d
k
]
=
e
]

=
[f
ex
cept
!
[d
1
]
=
[@
ex
cept
!
[d
2
]
:
:
:
[d
k
]
=
e
]
]
f
[y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
]

=
e
is
dened
to
b
e
an
abbreviation
for
f

=
choose
f
:
f
=
[y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
7!
e
]
5
Since
@
is
not
actually
an
iden
tier,
let
@

=
:
:
:
isn't
legal
TLA
+
syn
tax.
Ho
w
ev
er,
its
meaning
should
b
e
clear.

16.1.
CONST
ANT
OPERA
TORS
305
16.1.8
Records
TLA
+
b
orro
ws
from
programming
languages
the
concept
of
a
record.
Records
w
ere
in
tro
duced
in
Section
3.2
(page
28)
and
further
explained
in
Section
5.2
(page
48).
As
in
programming
languages,
r
:h
is
the
h
eld
of
record
r
.
Records
can
b
e
written
explicitly
as
[h
1
7!
e
1
;
:
:
:
;
h
n
7!
e
n
]
whic
h
equals
the
record
with
n
elds,
whose
h
i
eld
equals
e
i
,
for
i
=
1;
:
:
:
;
n
.
The
expression
[h
1
:
S
1
;
:
:
:
;
h
n
:
S
n
]
is
the
set
of
all
suc
h
records
with
e
i
2
S
i
,
for
i
=
1;
:
:
:
;
n
.
These
expressions
are
legal
only
if
the
h
i
are
all
dieren
t.
F
or
example,
[a
:
S
;
a
:
T
]
is
illegal.
The
ex
cept
construct,
explained
in
Section
16.1.7
ab
o
v
e,
can
b
e
used
for
records
as
w
ell
as
functions.
F
or
example,
[r
ex
cept
!
:a
=
e
]
is
the
record
b
r
that
is
the
same
as
r
,
except
that
b
r
:a
=
e
.
An
exception
clause
can
mix
function
application
and
record
elds.
F
or
example,
[f
ex
cept
!
[v
]:a
=
e
]
is
the
function
b
f
that
is
the
same
as
f
,
except
that
b
f
[v
]:a
=
e
.
In
TLA
+
,
a
record
is
a
function
whose
domain
is
a
nite
set
of
strings,
where
r
:h
means
r
[\h
"],
for
an
y
expression
r
and
record
eld
h
.
Th
us,
the
follo
wing
t
w
o
expressions
describ
e
the
same
record:
[fo
7!
7;
b
a
7!
8]
[x
2
f\fo"
;
\ba"
g
7!
if
x
=
\fo"
then
7
else
8]
The
name
of
a
record
eld
is
syn
tactically
an
iden
tier.
In
the
asci
i
v
ersion
of
TLA
+
,
it
is
a
string
of
letters,
digits,
and
the
underscore
c
haracter
(_)
that
con
tains
at
least
one
letter.
Strings
are
describ
ed
b
elo
w
in
Section
16.1.10.
F
ormal
Seman
tics
The
record
constructs
are
dened
in
terms
of
function
constructs.
e
:h

=
e
[\h
"
]
[h
1
7!
e
1
;
:
:
:
;
h
n
7!
e
n
]

=
[y
2
f\h
1
"
;
:
:
:
;
\h
n
"g
7!
case
(y
=
\h
1
")
!
e
1
2
:
:
:
2
(y
=
\h
n
"
)
!
e
n
]
where
y
do
es
not
o
ccur
in
an
y
of
the
expressions
e
i
.
The
h
i
m
ust
all
b
e
distinct.

306
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
[h
1
:
S
1
;
:
:
:
;
h
n
:
S
n
]

=
f
[h
1
7!
y
1
;
:
:
:
;
h
n
7!
y
n
]
:
y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
g
where
the
y
i
do
not
o
ccur
in
an
y
of
the
expressions
S
j
.
The
h
i
m
ust
all
b
e
distinct.
[r
ex
cept
!a
1
=
e
1
;
:
:
:
;
!a
n
=
e
n
]
where
a
i
has
the
form
b
1
:
:
:
b
k
and
eac
h
b
j
is
either
(i)
[d
],
where
d
is
an
expression,
or
(ii)
:h
,
where
h
is
a
record
eld.
It
is
dened
to
equal
the
corresp
onding
function
ex
cept
construct
in
whic
h
eac
h
:h
is
replaced
b
y
[\h
"].
16.1.9
T
uples
An
n
-tuple
is
written
in
TLA
+
as
h
e
1
;
:
:
:
;
e
n
i.
As
explained
in
Section
5.4,
an
n
-tuple
is
dened
to
b
e
a
function
whose
domain
is
the
set
f1;
:
:
:
;
n
g,
where
h
e
1
;
:
:
:
;
e
n
i[i
]
=
e
i
,
for
1

i

n
.
The
Cartesian
pro
duct
S
1





S
n
is
the
set
of
all
n
-tuples
h
e
1
;
:
:
:
;
e
n
i
suc
h
that
e
i
2
S
i
,
for
1

i

n
.
In
TLA
+
,

is
not
an
asso
ciativ
e
op
erator.
F
or
example,
h
1;
2;
3
i
2
Nat

Nat

Nat
h
h
1;
2
i;
3
i
2
(Nat

Nat
)

Nat
h
1;
h
2;
3
i
i
2
Nat

(Nat

Nat
)
and
the
tuples
h
1;
2;
3
i,
h
h
1;
2
i;
3
i,
and
h
1;
h
2;
3
i
i
are
not
equal.
More
precisely
,
the
triple
h
1;
2;
3
i
is
unequal
to
either
of
the
pairs
h
h
1;
2
i;
3
i
or
h
1;
h
2;
3
i
i
b
ecause
a
triple
and
a
pair
ha
v
e
unequal
domains.
The
seman
tics
of
TLA
+
do
es
not
sp
ecify
if
h
1;
2
i
equals
1
or
if
3
equals
h
2;
3
i,
so
w
e
don't
kno
w
whether
or
not
h
h
1;
2
i;
3
i
and
h
1;
h
2;
3
i
i
are
equal.
The
0-tuple
h
i
is
the
unique
function
ha
ving
an
empt
y
domain.
The
1-tuple
h
e
i
is
dieren
t
from
e
.
That
is,
the
seman
tics
do
es
not
sp
ecify
whether
or
not
they
are
equal.
There
is
no
sp
ecial
notation
for
writing
a
set
of
1-tuples.
The
easiest
w
a
y
to
denote
the
set
of
all
1-tuples
h
e
i
with
e
2
S
is
fh
e
i
:
e
2
S
g.
In
the
standard
Se
quenc
es
mo
dule,
describ
ed
in
Section
18.1
(page
339),
an
n
-elemen
t
sequence
is
represen
ted
as
an
n
-tuple.
The
mo
dule
denes
sev
eral
useful
op
erators
on
sequences/tuples.
F
ormal
Seman
tics
T
uples
and
Cartesian
pro
ducts
are
dened
in
terms
of
functions
(dened
in
Section
16.1.7)
and
the
set
Nat
of
natural
n
um
b
ers
(dened
in
Section
16.1.11).
he
1
;
:
:
:
;
e
n
i

=
[i
2
fj
2
Nat
:
(1

j
)
^
(j

n
)g
7!
e
i
]
where
i
do
es
not
o
ccur
in
an
y
of
the
expressions
e
j
.

16.1.
CONST
ANT
OPERA
TORS
307
S
1





S
n

=
f
h
y
1
;
:
:
:
;
y
n
i
:
y
1
2
S
1
;
:
:
:
;
y
n
2
S
n
g
where
the
iden
tiers
y
i
do
not
o
ccur
in
an
y
of
the
expressions
S
j
.
16.1.10
Strings
TLA
+
denes
a
string
to
b
e
a
tuple
of
c
haracters.
(T
uples
are
dened
in
Sec-
tion
16.1.9
ab
o
v
e.)
Th
us,
\ab
c"
equals
h
\ab
c"
[1];
\ab
c"
[2];
\ab
c"
[3]
i
The
seman
tics
of
TLA
+
do
es
not
sp
ecify
what
a
c
haracter
is.
Ho
w
ev
er,
it
do
es
sp
ecify
that
dieren
t
c
haracters
(those
ha
ving
dieren
t
computer
represen
ta-
tions)
are
dieren
t.
Th
us
\a"
[1],
\b"
[1],
and
\A"
[1]
(the
c
haracters
a
,
b
,
and
A)
are
all
dieren
t.
The
built-in
op
erator
string
is
dened
to
b
e
the
set
of
all
strings.
Although
TLA
+
do
esn't
sp
ecify
what
a
c
haracter
is,
it's
easy
to
dene
op
er-
ators
that
assign
v
alues
to
c
haracters.
F
or
example,
here's
the
denition
of
an
op
erator
Ascii
that
assigns
to
ev
ery
lo
w
er-case
letter
its
asci
i
represen
tation.
6
Ascii
(char
)

=
96
+
choose
i
2
1
:
:
26
:
\ab
cdefghijklmnop
qrstuvwxyz"
[i
]
=
char
This
denes
Ascii
(\a"[1])
to
equal
97,
the
asci
i
co
de
for
the
letter
a
,
and
Ascii
(\z"
[1])
to
equal
122,
the
asci
i
co
de
for
z
.
Section
11.1.4
on
page
179
illustrates
ho
w
a
sp
ecication
can
mak
e
use
of
the
fact
that
strings
are
tuples.
Exactly
what
c
haracters
ma
y
app
ear
in
a
string
is
system-dep
enden
t.
A
Japanese
v
ersion
of
TLA
+
migh
t
not
allo
w
the
c
haracter
a
.
The
standard
asci
i
v
ersion
con
tains
the
follo
wing
c
haracters:
a
b
c
d
e
f
g
h
i
j
k
l
m
n
o
p
q
r
s
t
u
v
w
x
y
z
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P
Q
R
S
T
U
V
W
X
Y
Z
0
1
2
3
4
5
6
7
8
9
~
@
#
$
%
^
&

 +
=
(
)
f
g
[
]
<
>
j
=
n
;
:
?
:
;
`
'
"
h
ht
i
(tab)
h
lf
i
(line
feed)
h
ff
i
(form
feed)
h
cr
i
(carriage
return)
plus
the
space
c
haracter.
Since
strings
are
delimited
b
y
a
double-quote
("),
some
con
v
en
tion
is
needed
for
t
yping
a
string
that
con
tains
a
double-quote.
Con
v
en
tions
are
also
needed
to
t
yp
e
c
haracters
lik
e
h
lf
i
within
a
string.
In
the
asci
i
v
ersion
of
TLA
+
,
the
follo
wing
pairs
of
c
haracters,
b
eginning
with
a
\
c
haracter,
are
used
to
represen
t
these
sp
ecial
c
haracters:
\"
"
\t
h
ht
i
\f
h
ff
i
\\
\
\n
h
lf
i
\r
h
cr
i
6
This
clev
er
w
a
y
of
using
choose
to
map
from
c
haracters
to
n
um
b
ers
w
as
p
oin
ted
out
to
me
b
y
Georges
Gon
thier.

308
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
With
this
con
v
en
tion,
"a\\\"b\""
represen
ts
the
string
consisting
of
the
fol-
lo
wing
v
e
c
haracters:
a
n
"
b
".
In
the
asci
i
v
ersion
of
TLA
+
,
a
\
c
haracter
can
app
ear
in
a
string
expression
only
as
the
rst
c
haracter
of
one
of
these
six
t
w
o-c
haracter
sequences.
F
ormal
Seman
tics
W
e
assume
a
set
Char
of
c
haracters,
whic
h
ma
y
dep
end
on
the
v
ersion
of
TLA
+
.
(The
iden
tier
Char
is
not
a
pre-dened
sym
b
ol
of
TLA
+
.)
string

=
Se
q
(Char
)
where
Se
q
is
the
op
erator
dened
in
the
Se
quenc
es
mo
dule
of
Section
18.1
so
that
Se
q
(S
)
is
the
set
of
all
nite
sequences
of
elemen
ts
of
S
.
\c
1
:
:
:
c
n
"

=
h
c
1
;
:
:
:
;
c
n
i
where
eac
h
c
i
is
some
represen
tation
of
a
c
haracter
in
Char
.
16.1.11
Num
b
ers
TLA
+
denes
a
sequence
of
digits
lik
e
63
to
b
e
the
usual
natural
n
um
b
er|that
is,
63
equals
6

10
+
3.
TLA
+
also
allo
ws
the
binary
represen
tation
\b111111,
the
o
ctal
represen
tation
\o77,
and
the
hexadecimal
represen
tation
\h3F
of
that
n
um
b
er.
(Case
is
ignored
in
the
prexes
and
in
the
hexadecimal
represen
tation,
so
\H3F
and
\h3f
are
equiv
alen
t
to
\h3F.)
Decimal
n
um
b
ers
are
also
pre-dened
in
TLA
+
;
for
example,
3.14159
equals
314159=10
5
.
Num
b
ers
are
pre-dened
in
TLA
+
,
so
63
is
dened
ev
en
in
a
mo
dule
that
do
es
not
extend
or
instan
tiate
one
of
the
standard
n
um
b
ers
mo
dules.
Ho
w
ev
er,
sets
of
n
um
b
ers
lik
e
Nat
and
arithmetic
op
erators
lik
e
+
are
not.
Y
ou
can
write
a
mo
dule
that
denes
+
an
y
w
a
y
y
ou
w
an
t,
in
whic
h
case
40
+
23
need
not
equal
63.
Of
course,
40
+
23
do
es
equal
63
for
+
dened
b
y
the
standard
n
um
b
ers
mo
dules
Natur
als
,
Inte
gers
,
and
R
e
als
,
whic
h
are
describ
ed
in
Section
18.4.
F
ormal
Seman
tics
The
set
Nat
of
natural
n
um
b
ers,
along
with
its
zero
elemen
t
Zer
o
and
successor
function
Suc
c
,
is
dened
in
mo
dule
Pe
ano
on
page
345.
The
meaning
of
a
represen
tation
of
a
natural
n
um
b
er
is
dened
in
the
usual
manner:
0

=
Zer
o
1

=
Suc
c
[Zer
o
]
2

=
Suc
c
[Suc
c
[Zer
o
]]
:
:
:
The
Pr
otoR
e
als
mo
dule
on
pages
346{347
denes
the
set
R
e
al
of
real
n
um
b
ers
to
b
e
a
sup
erset
of
the
set
Nat
,
and
denes
the
usual
arithmetic
op
erators
on

16.2.
NONCONST
ANT
OPERA
TORS
309
real
n
um
b
ers.
The
meaning
of
a
decimal
n
um
b
er
is
dened
in
terms
of
these
op
erators
b
y
c
1



c
m
:
d
1



d
n

=
c
1



c
m
d
1



d
n
=10
n
16.2
Nonconstan
t
Op
erators
The
nonconstan
t
op
erators
are
what
distinguish
TLA
+
from
ordinary
mathe-
matics.
There
are
t
w
o
classes
of
nonconstan
t
op
erators:
action
op
erators,
listed
in
T
able
3
on
page
269,
and
temp
oral
op
erators,
listed
in
T
able
4
on
page
269.
Section
16.1
ab
o
v
e
talks
ab
out
the
meanings
of
the
built-in
constan
t
op
era-
tors
of
TLA
+
,
without
considering
their
argumen
ts.
W
e
can
do
that
for
constan
t
op
erators,
since
the
meaning
of

in
the
expression
e
1

e
2
do
esn't
dep
end
on
whether
or
not
the
expressions
e
1
and
e
2
con
tain
v
ariables
or
primes.
T
o
under-
stand
the
nonconstan
t
op
erators,
w
e
need
to
consider
their
argumen
ts.
Th
us,
w
e
can
no
longer
talk
ab
out
the
meanings
of
the
op
erators
in
isolation;
w
e
m
ust
describ
e
the
meanings
of
expressions
built
from
those
op
erators.
A
b
asic
expression
is
one
that
con
tains
built-in
TLA
+
op
erators,
declared
constan
ts,
and
declared
v
ariables.
W
e
no
w
describ
e
the
meaning
of
all
basic
TLA
+
expressions,
including
ones
that
con
tain
nonconstan
t
built-in
op
erators.
W
e
start
b
y
considering
basic
constan
t
expressions,
ones
con
taining
only
the
constan
t
op
erators
w
e
ha
v
e
already
studied
and
declared
constan
ts.
16.2.1
Basic
Constan
t
Expressions
Section
16.1
ab
o
v
e
denes
the
meanings
of
the
constan
t
op
erators.
This
in
turn
denes
the
meaning
of
an
y
expression
built
from
these
op
erators
and
declared
constan
ts.
F
or
example,
if
S
and
T
are
declared
b
y
const
ants
S
;
T
(
)
then
9
x
:
S

T
(x
)
is
a
form
ula
that
equals
tr
ue
if
there
is
some
v
alue
v
suc
h
that
ev
ery
elemen
t
of
S
is
an
elemen
t
of
T
(v
),
and
otherwise
equals
f
alse.
Whether
9
x
:
S

T
(x
)
equals
tr
ue
or
f
alse
dep
ends
on
what
actual
v
alues
w
e
assign
to
S
and
to
T
(v
),
for
all
v
;
so
that's
as
far
as
w
e
can
go
in
assigning
a
meaning
to
the
expression.
A
form
ula
is
a
Bo
olean-v
alued
expression.
There
are
some
basic
constan
t
form
ulas
that
are
true
regardless
of
the
v
alues
w
e
assign
to
their
declared
constan
ts|for
example,
the
form
ula
(S

T
)

(S
\
T
=
S
)
Suc
h
a
form
ula
is
said
to
b
e
valid.

310
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
F
ormal
Seman
tics
Section
16.1
denes
all
the
built-in
constan
t
op
erators
in
terms
of
a
subset
of
them
called
the
primitiv
e
op
erators.
These
denitions
can
b
e
form
ulated
as
an
inductiv
e
set
of
rules
that
dene
the
meaning
[
[c
]
]
of
an
y
basic
constan
t
expression
c
.
F
or
example,
from
the
denition
e
=
2
S

=
:(e
2
S
)
w
e
get
the
rule
[
[e
=
2
S
]
]
=
:([
[e
]
]
2
[
[S
]
])
These
rules
dene
the
meaning
of
a
basic
constan
t
expression
to
b
e
an
expression
con
taining
only
primitiv
e
constan
t
op
erators
and
declared
constan
ts.
A
basic
constan
t
expression
e
is
a
form
ula
i
its
meaning
[
[e
]
]
is
Bo
olean-
v
alued,
regardless
of
what
v
alues
are
substituted
for
the
declared
constan
ts.
As
explained
in
Section
16.1.3,
this
will
dep
end
on
whether
w
e
are
using
the
lib
eral,
mo
derate,
or
conserv
ativ
e
in
terpretations
of
the
Bo
olean
op
erators.
If
S
and
T
are
constan
ts
declared
as
ab
o
v
e,
then
the
meaning
[
[9
x
:
S

T
(x
)]
]
of
the
expression
9
x
:
S

T
(x
)
is
the
expression
itself.
Logicians
usually
carry
things
further,
assigning
some
meanings
[
[S
]
]
and
[
[T
]
]
to
declared
constan
ts
and
dening
[
[9
x
:
S

T
(x
)]
]
to
equal
9
x
:
[
[S
]
]

[
[T
]
](x
)
.
F
or
simplicit
y
,
I
ha
v
e
short-
circuited
that
extra
lev
el
of
meaning.
W
e
are
taking
as
giv
en
the
meaning
of
an
expression
con
taining
only
primitiv
e
constan
t
op
erators
and
declared
constan
ts.
In
particular,
w
e
tak
e
as
primitiv
e
the
notion
of
v
alidit
y
for
suc
h
expressions.
Section
16.1
denes
the
meaning
of
an
y
basic
constan
t
expression
in
terms
of
these
expressions,
so
it
denes
what
it
means
for
a
basic
constan
t
form
ula
to
b
e
v
alid.
16.2.2
The
Meaning
of
a
State
F
unction
A
state
is
an
assignmen
t
of
v
alues
to
v
ariables.
(In
ZF
set
theory
,
on
whic
h
the
seman
tics
of
TLA
+
is
based,
value
is
just
another
term
for
set.)
States
w
ere
discussed
in
Sections
2.1
and
2.3.
A
state
function
is
an
expression
that
is
built
from
declared
v
ariables,
de-
clared
constan
ts,
and
constan
t
op
erators.
(State
functions
can
also
con
tain
en-
abled
expressions,
whic
h
are
describ
ed
b
elo
w.)
State
functions
are
discussed
on
page
25
in
Section
3.1.
A
state
function
assigns
a
constan
t
expression
to
ev
ery
state.
If
state
function
e
assigns
to
state
s
the
constan
t
expression
v
,
then
w
e
sa
y
that
v
is
the
v
alue
of
e
in
state
s
.
F
or
example,
if
x
is
a
declared
v
ariable,
T
is
a
declared
constan
t,
and
s
is
a
state
that
assigns
to
x
the
v
alue
42;
then
the
v
alue
of
x
2
T
in
state
s
is
the
constan
t
expression
42
2
T
.
A
Bo
olean-v
alued
state
function
is
called
a
state
pr
e
dic
ate.
A
state
predicate
is
valid
i
it
has
the
v
alue
tr
ue
in
ev
ery
state.

16.2.
NONCONST
ANT
OPERA
TORS
311
F
ormal
Seman
tics
A
state
is
an
assignmen
t
of
v
alues
to
v
ariables.
F
ormally
,
a
state
s
is
a
function
whose
domain
is
the
set
of
all
v
ariable
names,
where
s
[\x"
]
is
the
v
alue
that
s
assigns
to
v
ariable
x
.
W
e
write
s
[
[x
]
]
instead
of
s
[\x"
].
A
b
asic
state
function
is
an
expression
that
is
built
from
declared
v
ariables,
declared
constan
ts,
constan
t
op
erators,
and
enabled
expressions,
whic
h
are
expressions
of
the
form
enabled
e
.
An
enabled-free
basic
state
function
is
one
with
no
enabled
expressions.
The
meaning
of
a
basic
state
function
is
a
mapping
from
states
to
v
alues.
W
e
let
s
[
[e
]
]
b
e
the
v
alue
that
state
function
e
assigns
to
a
state
s
.
Since
a
v
ariable
is
a
state
function,
w
e
th
us
sa
y
b
oth
that
state
s
assigns
s
[
[x
]
]
to
v
ariable
x
,
and
that
the
state
function
x
assigns
s
[
[x
]
]
to
state
s
.
Using
the
meanings
assigned
to
the
constan
t
op
erators
in
Section
16.1
ab
o
v
e,
w
e
inductiv
ely
dene
s
[
[e
]
]
for
an
y
enabled-free
state
function
e
to
b
e
an
ex-
pression
built
from
the
primitiv
e
TLA
+
constan
t
op
erators,
declared
constan
ts,
and
the
v
alues
assigned
b
y
s
to
eac
h
v
ariable.
F
or
example,
if
x
is
a
v
ariable
and
S
is
a
constan
t,
then
s
[
[x
=
2
S
]
]
=
:(s
[
[x
]
]
2
S
)
It
is
easy
to
see
that
s
[
[c
]
]
equals
[
[c
]
],
for
an
y
constan
t
expression
c
.
(This
expresses
formally
that
a
constan
t
has
the
same
v
alue
in
all
states.)
T
o
dene
the
meaning
of
all
basic
state
function,
not
just
enabled-free
ones,
w
e
m
ust
dene
the
meaning
of
an
enabled
expression.
This
is
done
b
elo
w.
The
formal
seman
tics
talks
ab
out
state
functions,
not
state
predicates.
Be-
cause
TLA
+
is
t
yp
eless,
there
is
no
formal
distinction
b
et
w
een
a
state
predicate
and
a
state
function.
By
a
state
predicate,
w
e
mean
a
state
function
e
suc
h
that
s
[
[e
]
]
is
Bo
olean-v
alued
for
ev
ery
reac
hable
state
s
of
some
sp
ecication.
See
the
discussion
of
actions
on
pages
313{314.
I
describ
ed
the
meaning
of
a
state
function
as
a
\mapping"
on
states.
This
mapping
cannot
b
e
a
function,
b
ecause
there
is
no
set
of
all
states.
Since
for
an
y
set
S
there
is
a
state
that
assigns
the
v
alue
S
to
eac
h
v
ariable,
there
are
to
o
man
y
states
to
form
a
set.
(See
the
discussion
of
Russell's
parado
x
on
page
66.)
T
o
b
e
formal,
w
e
should
dene
an
op
erator
M
suc
h
that,
if
s
is
a
state
and
e
is
a
syn
tactically
correct
basic
state
function,
then
M
(s
;
e
),
whic
h
w
e
write
s
[
[e
]
],
is
the
basic
constan
t
expression
that
is
the
meaning
of
e
in
state
s
.
Actually
,
this
w
a
y
of
describing
the
seman
tics
isn't
righ
t
either.
A
state
is
a
mapping
from
v
ariables
to
v
alues
(sets),
not
to
constan
t
expressions.
Since
there
are
an
uncoun
table
n
um
b
er
of
sets
and
only
a
coun
table
n
um
b
er
of
nite
sequences
of
strings,
there
are
v
alues
that
can't
b
e
describ
ed
b
y
an
y
expression.
Supp
ose

is
suc
h
a
v
alue,
and
let
s
b
e
a
state
that
assigns
the
v
alue

to
the
v
ariable
x
.
Then
s
[
[x
=
fg]
]
equals

=
fg,
whic
h
isn't
a
constan
t
expression
b
ecause

isn't
an
expression.
So,
to
b
e
r
e
al
ly
formal,
w
e
w
ould
ha
v
e
to
dene
a
seman
tic
constan
t
expression
to
b
e
one
made
from
primitiv
e
constan
t
op
erators,

312
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
declared
constan
ts,
and
arbitrary
v
alues.
The
meaning
of
a
basic
state
function
is
a
mapping
from
states
to
seman
tic
constan
t
expressions.
W
e
w
on't
b
other
with
these
details.
Instead,
w
e
dene
a
semi-formal
seman-
tics
for
basic
expressions
that
is
easier
to
understand.
Mathematically
sophis-
ticated
readers
who
understand
the
less
formal
exp
osition
should
b
e
able
to
ll
in
the
missing
formal
details.
16.2.3
Action
Op
erators
A
tr
ansition
function
is
an
expression
built
from
state
functions
using
the
prim-
ing
op
erator
(
0
)
and
the
other
action
op
erators
of
TLA
+
listed
in
T
able
3
on
page
269.
A
transition
function
assigns
a
v
alue
to
ev
ery
step,
where
a
step
is
a
pair
of
states.
In
a
transition
function,
an
unprimed
o
ccurrence
of
a
v
ariable
x
represen
ts
the
v
alue
of
x
in
the
rst
(old)
state,
and
a
primed
o
ccurrence
of
x
represen
ts
its
v
alue
in
the
second
(new)
state.
F
or
example,
if
state
s
assigns
the
v
alue
4
to
x
and
state
t
assigns
the
v
alue
5
to
x
,
then
the
transition
function
x
0
 x
assigns
to
the
step
s
!
t
the
v
alue
5
 4,
whic
h
equals
1
(if
 has
its
usual
denition).
An
action
is
a
Bo
olean-v
alued
transition
function,
suc
h
as
x
0
>
x
.
W
e
sa
y
that
action
A
is
true
on
step
s
!
t
,
or
that
s
!
t
is
an
A
step,
i
A
assigns
the
v
alue
tr
ue
to
s
!
t
.
An
action
is
said
to
b
e
valid
i
it
is
true
on
an
y
step.
The
action
op
erators
of
TLA
+
other
than
0
ha
v
e
the
follo
wing
meanings,
where
A
and
B
are
actions
and
e
is
a
state
function:
[A]
e

=
A
_
(e
0
=
e
)
hAi
e

=
A
^
(e
0
6=
e
)
enabled
A
is
the
state
function
that
is
true
in
state
s
i
there
is
some
state
t
suc
h
that
s
!
t
is
an
A
step.
unchanged
e

=
e
0
=
e
A

B
is
the
action
that
is
true
on
step
s
!
t
i
there
is
a
state
u
suc
h
that
s
!
u
is
an
A
step
and
u
!
t
is
a
B
step.
Priming
and
the
construct
[A]
v
are
in
tro
duced
in
Section
2.2
(page
15);
the
unchanged
op
erator
is
in
tro
duced
on
page
26
of
Section
3.1;
enabled
is
in-
tro
duced
on
page
97
of
Section
8.4;
the
construct
h
A
i
v
is
dened
on
page
91
of
Section
8.1;
and
the
action-comp
osition
op
erator
\"
is
in
tro
duced
in
Section
7.3
(page
76).

16.2.
NONCONST
ANT
OPERA
TORS
313
F
ormal
Seman
tics
A
b
asic
tr
ansition
function
is
a
basic
expression
that
do
es
not
con
tain
an
y
tem-
p
oral
op
erators.
The
meaning
of
a
basic
transition
function
e
is
an
assignmen
t
of
a
basic
constan
t
expression
h
s
;
t
i[
[e
]
]
to
an
y
pair
of
states
h
s
;
t
i.
(W
e
use
here
the
more
con
v
en
tional
notation
h
s
;
t
i
instead
of
s
!
t
.)
A
transition
function
is
v
alid
i
h
s
;
t
i[
[e
]
]
is
v
alid,
for
all
states
s
and
t
.
If
e
is
a
basic
state
function,
then
w
e
in
terpret
e
as
a
basic
transition
function
b
y
dening
h
s
;
t
i[
[e
]
]
to
equal
s
[
[e
]
].
As
indicated
ab
o
v
e,
unchanged
and
the
constructs
[A]
e
and
h
A
i
e
are
dened
in
terms
of
priming.
T
o
dene
the
meanings
of
the
remaining
action
op
erators,
w
e
rst
dene
existen
tial
quan
tication
o
v
er
all
states.
Let
IsAState
b
e
an
op
erator
suc
h
that
IsAState
(s
)
is
true
i
s
is
a
state|that
is,
a
function
whose
domain
is
the
set
of
all
v
ariable
names.
(It's
easy
to
dene
IsAState
using
the
op
erator
IsAFcn
,
dened
on
page
303.)
Existen
tial
quan
tication
o
v
er
all
states
is
then
dened
b
y
9
state
s
:
p

=
9
s
:
IsAState
(s
)
^
p
for
an
y
form
ula
p
.
The
meanings
of
all
transition
functions
and
all
state
functions
(including
enabled
expressions)
is
then
dened
inductiv
ely
b
y
the
denitions
already
giv
en
and
the
follo
wing
denitions
of
the
remaining
action
op
erators:
e
0
is
the
transition
function
dened
b
y
h
s
;
t
i[
[e
0
]
]

=
t
[
[e
]
]
for
an
y
state
function
e
.
enabled
A
is
the
state
function
dened
b
y
s
[
[enabled
A]
]

=
9
state
t
:
h
s
;
t
i[
[A]
]
for
an
y
transition
function
A.
A

B
is
the
transition
function
dened
b
y
h
s
;
t
i[
[A

B
]
]

=
9
state
u
:
h
s
;
u
i[
[A]
]
^
h
u
;
t
i[
[B
]
]
for
an
y
transition
functions
A
and
B
.
The
formal
seman
tics
talks
ab
out
transition
functions,
not
actions.
Since
TLA
+
is
t
yp
eless,
there
is
no
formal
distinction
b
et
w
een
an
action
and
an
arbitrary
transition
function.
W
e
could
dene
an
action
A
to
b
e
a
transition
function
suc
h
that
h
s
;
t
i[
[A]
]
is
a
Bo
olean
for
all
states
s
and
t
.
Ho
w
ev
er,
what
w
e
usually
mean
b
y
an
action
is
a
transition
function
A
suc
h
that
h
s
;
t
i[
[A]
]
is
a
Bo
olean
whenev
er
s
and
t
are
reac
hable
states
of
some
sp
ecication.
F
or
example,
a
sp
ecication
with
a
v
ariable
b
of
t
yp
e
boolean
migh
t
con
tain
an
action
b
^
(y
0
=
y
)
.
W
e
T
yp
es
are
ex-
plained
on
page
25.
can
calculate
the
meaning
of
enabled
(b
^
(y
0
=
y
))
as
follo
ws:
s
[
[enabled
(b
^
(y
0
=
y
))]
]
=
9
state
t
:
h
s
;
t
i[
[b
^
(y
0
=
y
)]
]
By
denition
of
enabled.
=
9
state
t
:
h
s
;
t
i[
[b
]
]
^
(h
s
;
t
i[
[y
0
]
]
=
h
s
;
t
i[
[y
]
])
By
denition
of
^
and
=.
=
9
state
t
:
s
[
[b
]
]
^
(t
[
[y
]
]
=
s
[
[y
]
])
By
denition
of
0
,
since
h
s
;
t
i[
[e
]
]
=
s
[
[e
]
],
for
an
y
state
function
e
.

314
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
If
s
[
[b
]
]
is
a
Bo
olean,
w
e
can
no
w
con
tin
ue
the
calculation
as
follo
ws:
9
state
t
:
s
[
[b
]
]
^
(t
[
[y
]
]
=
s
[
[y
]
])
=
s
[
[b
]
]
^
9
state
t
:
(t
[
[y
]
]
=
s
[
[y
]
])
By
predicate
logic,
since
t
do
es
not
o
ccur
in
s
[
[b
]
].
=
s
[
[b
]
]
The
existence
of
t
is
ob
vious|for
example,
let
it
equal
s
.
Hence,
s
[
[enabled
(b
^
(y
0
=
y
))]
]
equals
s
[
[b
]
],
if
s
[
[b
]
]
is
a
Bo
olean.
Ho
w
ev
er,
if
s
is
a
state
that
assigns
the
v
alue
2
to
the
v
ariable
b
and
the
v
alue
 7
to
the
v
ariable
y
,
then
s
[
[enabled
(b
^
(y
0
=
y
))]
]
=
9
state
t
:
2
^
(t
[
[y
]
]
=
 7)
The
last
expression
ma
y
or
ma
y
not
equal
2.
(See
the
discussion
of
the
in-
terpretation
of
the
Bo
olean
op
erators
in
Section
16.1.3
on
page
296.)
If
the
sp
ecication
w
e
are
writing
mak
es
sense,
it
can
dep
end
on
the
meaning
of
enabled
(b
^
(y
0
=
y
))
only
for
states
in
whic
h
the
v
alue
of
b
is
a
Bo
olean.
W
e
don't
care
ab
out
its
v
alue
in
a
state
that
assigns
to
b
the
v
alue
2,
just
as
w
e
don't
care
ab
out
the
v
alue
of
3=x
in
a
state
that
assigns
the
v
alue
\ab
c"
to
x
.
See
the
discussion
of
silly
expressions
in
Section
6.2
(page
67).
16.2.4
T
emp
oral
Op
erators
As
explained
in
Section
8.1,
a
temp
oral
form
ula
F
is
true
or
false
for
a
b
eha
vior,
where
a
b
eha
vior
is
a
sequence
of
states.
Syn
tactically
,
a
temp
oral
form
ula
is
dened
inductiv
ely
to
b
e
a
state
predicate
or
a
form
ula
ha
ving
one
of
the
forms
sho
wn
in
T
able
4
on
page
269,
where
e
is
a
state
function,
A
is
an
action,
and
F
and
G
are
temp
oral
form
ulas.
All
the
temp
oral
op
erators
in
T
able
4
are
explained
in
Chapter
8|except
for
+
 .
,
whic
h
is
explained
in
Section
10.7
(page
156).
The
form
ula
2F
is
true
for
a
b
eha
vior

i
the
temp
oral
form
ula
F
is
true
for

and
all
suxes
of

.
T
o
dene
the
constructs
2[A]
e
and
3h
A
i
e
,
w
e
regard
an
action
B
to
b
e
a
temp
oral
form
ula
that
is
true
of
a
b
eha
vior

i
the
rst
t
w
o
states
of

form
a
B
step.
Th
us,
2[A]
e
is
true
of

i
ev
ery
successiv
e
pair
of
states
of

is
a
[A]
e
step.
All
the
other
temp
oral
op
erators
of
TLA
+
,
except
9
9
9
9
9
9
,
8
8
8
8
8
8
,
and
+
 .
,
are
dened
as
follo
ws
in
terms
of
2:
3F

=
:2:F
WF
e
(A)

=
23:(enabled
h
A
i
e
)
_
23h
A
i
e
SF
e
(A)

=
32:(enabled
h
A
i
e
)
_
23h
A
i
e
F
;
G

=
2(F
)
3G
)
The
temp
oral
existen
tial
quan
tier
9
9
9
9
9
9
is
a
hiding
op
erator,
9
9
9
9
9
9
x
:
F
meaning
form
ula
F
with
the
v
ariable
x
hidden.
T
o
dene
this
more
precisely
,
w
e
rst
dene
\
to
b
e
the
(p
ossibly
nite)
sequence
of
states
obtained
b
y
remo
ving

16.2.
NONCONST
ANT
OPERA
TORS
315
from

all
stuttering
steps|that
is,
b
y
remo
ving
an
y
state
that
is
the
same
as
the
previous
one.
W
e
then
dene


x

to
b
e
true
i
\
and
\
are
the
same
except
for
the
v
alues
that
their
states
assign
to
the
v
ariable
x
.
Th
us,


x

is
true
i

can
b
e
obtained
from

(or
vice-v
ersa)
b
y
adding
and/or
remo
ving
stuttering
steps
and
c
hanging
the
v
alues
assigned
to
x
b
y
its
states.
Finally
,
9
9
9
9
9
9
x
:
F
is
dened
to
b
e
true
for
a
b
eha
vior

i
F
is
true
for
some
b
eha
vior

suc
h
that


x

.
The
temp
oral
univ
ersal
quan
tier
8
8
8
8
8
8
is
dened
in
terms
of
9
9
9
9
9
9
b
y
8
8
8
8
8
8
x
:
F

=
:(
9
9
9
9
9
9
x
:
:F
)
The
form
ula
F
+
 .
G
asserts
that
G
do
es
not
b
ecome
false
b
efore
F
do
es.
More
precisely
,
w
e
dene
a
form
ula
H
to
b
e
true
for
a
nite
prex

of
a
b
eha
vior

i
H
is
true
for
some
(innite)
b
eha
vior
that
extends
.
(In
particular,
H
is
true
of
the
empt
y
prex
i
H
satises
some
b
eha
vior.)
Then
F
+
 .
G
is
dened
to
b
e
true
for
a
b
eha
vior

i
(i)
F
)
G
is
true
for

and
(ii)
for
ev
ery
nite
prex

of

,
if
F
is
true
for

then
G
is
true
for
the
prex
of

that
is
one
state
longer
than
.
F
ormal
Seman
tics
F
ormally
,
a
b
eha
vior
is
a
function
from
the
set
Nat
of
natural
n
um
b
ers
to
states.
(W
e
think
of
a
b
eha
vior

as
the
sequence

[0],

[1],
.
.
.
of
states.)
The
meaning
Instead
of
writing

i
as
in
Chap-
ter
8,
w
e
use
here
the
standard
functional
nota-
tion

[i
].
of
a
temp
oral
form
ula
is
a
predicate
on
b
eha
viors|that
is,
a
mapping
from
b
eha
viors
to
Bo
oleans.
W
e
write

j
=
F
for
the
v
alue
that
the
meaning
of
F
assigns
to
the
b
eha
vior

.
The
temp
oral
form
ula
F
is
v
alid
i

j
=
F
is
true,
for
all
b
eha
viors

.
Ab
o
v
e,
w
e
ha
v
e
dened
all
the
other
temp
oral
op
erators
in
terms
of
2,
9
9
9
9
9
9
,
and
+
 .
.
F
ormally
,
since
an
action
is
not
a
temp
oral
form
ula,
the
construct
2[A]
e
is
not
an
instance
of
the
temp
oral
op
erator
2,
so
its
meaning
should
b
e
dened
separately
.
The
construct
3h
A
i
e
,
whic
h
is
similarly
not
an
instance
of
3,
is
then
dened
to
equal
:2[:A]
e
.
T
o
dene
the
meaning
of
2,
w
e
rst
dene

+n
to
b
e
the
b
eha
vior
obtained
b
y
deleting
the
rst
n
states
of

:

+n

=
[i
2
Nat
7!

[i
+
n
]
]
W
e
then
dene
the
meaning
of
2
as
follo
ws,
for
an
y
temp
oral
form
ula
F
,
tran-
sition
function
A
and
state
function
e
:

j
=
2F

=
8
n
2
Nat
:

+n
j
=
F

j
=
2[A]
e

=
8
n
2
Nat
:
h

[n
];

[n
+
1]
i[
[[A]
e
]
]

316
CHAPTER
16.
THE
OPERA
TORS
OF
TLA
+
T
o
formalize
the
denition
of
9
9
9
9
9
9
giv
en
ab
o
v
e,
w
e
rst
dene
\
as
follo
ws,
letting
f
b
e
the
function
suc
h
that

[n
]
=
\
[f
[n
]],
for
all
n
:
\

=
let
f
[n
2
Nat
]

=
if
n
=
0
then
0
else
if

[n
]
=

[n
 1]
then
f
[n
 1]
else
f
[n
 1]
+
1
S

=
ff
[n
]
:
n
2
Nat
g
in
[n
2
S
7!

[choose
i
2
Nat
:
f
[i
]
=
n
]
]
Next,
let
s
x
 v
b
e
the
state
that
is
the
same
as
state
s
except
that
it
assigns
to
the
v
ariable
x
the
v
alue
v
.
W
e
then
dene

x
b
y


x


=
\
=
[n
2
domain
\
7!

x
 \
[n
][
[x
]
]
]
W
e
next
dene
existen
tial
quan
tication
o
v
er
b
eha
viors.
This
is
done
m
uc
h
as
w
e
dened
quan
tication
o
v
er
states
on
page
313
ab
o
v
e;
w
e
rst
dene
IsABehavior
so
that
IsABehavior
(
)
is
true
i

is
a
b
eha
vior,
and
w
e
then
dene
9
b
eha
vior

:
F

=
9

:
IsABehavior
(
)
^
F
W
e
can
no
w
dene
the
meaning
of
9
9
9
9
9
9
b
y

j
=
9
9
9
9
9
9
x
:
F

=
9
b
eha
vior

:
(

x

)
^
(
j
=
F
)
Finally
,
w
e
dene
the
meaning
of
+
 .
as
follo
ws:

j
=
F
+
 .
G

=
let
Pr
exSat
(n
;
H
)

=
9
b
eha
vior

:
^
8
i
2
0
:
:
(n
 1)
:

[i
]
=

[i
]
^

j
=
H
in
^

j
=
F
)
G
^
8
n
2
Nat
:
Pr
exSat
(n
;
F
)
)
Pr
exSat
(n
+
1;
G
)

Chapter
17
The
Meaning
of
a
Mo
dule
Chapter
16
denes
the
meaning
of
the
built-in
TLA
+
op
erators.
In
doing
so,
it
denes
the
meaning
of
a
basic
expression|that
is,
of
an
expression
con
taining
only
built-in
op
erators,
declared
constan
ts,
and
declared
v
ariables.
W
e
no
w
dene
the
meaning
of
a
mo
dule
in
terms
of
basic
expressions.
Since
a
TLA
+
sp
ecication
consists
of
a
collection
of
mo
dules,
this
denes
the
seman
tics
of
TLA
+
.
W
e
also
complete
the
denition
of
the
syn
tax
of
TLA
+
b
y
giving
the
remain-
ing
con
text-dep
enden
t
syn
tactic
conditions
not
describ
ed
in
Chapter
15.
Here's
a
list
of
some
illegal
expressions
that
satisfy
the
grammar
of
Chapter
15,
and
where
in
this
c
hapter
y
ou
can
nd
the
conditions
that
mak
e
them
illegal.

F
(x
),
if
F
is
dened
b
y
F
(x
;
y
)

=
x
+
y
(Section
17.1)

(x
0
+
1)
0
(Section
17.2)

x
+
1,
if
x
is
not
dened
or
declared
(Section
17.3)

F

=
0,
if
F
is
already
dened
(Section
17.5)
This
c
hapter
is
mean
t
to
b
e
read
in
its
en
tiret
y
.
T
o
try
to
mak
e
it
as
readable
as
p
ossible,
I
ha
v
e
made
the
exp
osition
somewhat
informal.
Wherev
er
I
could,
I
ha
v
e
used
examples
in
place
of
formal
denitions.
The
examples
assume
that
y
ou
understand
the
appro
ximate
meanings
of
the
TLA
+
constructs,
as
explained
in
P
art
I.
I
hop
e
that
mathematically
sophisticated
readers
will
see
ho
w
to
ll
in
the
missing
formalism.
17.1
Op
erators
and
Expressions
Because
it
uses
con
v
en
tional
mathematical
notation,
TLA
+
has
a
rather
ric
h
syn
tax,
with
sev
eral
dieren
t
w
a
ys
of
expressing
the
same
basic
t
yp
e
of
math-
317

318
CHAPTER
17.
THE
MEANING
OF
A
MODULE
ematical
op
eration.
F
or
example,
the
follo
wing
expressions
are
all
formed
b
y
applying
an
op
erator
to
a
single
argumen
t
e
:
L
en
(e
)
 e
fe
g
e
0
This
section
dev
elops
a
uniform
w
a
y
of
writing
all
these
expressions,
as
w
ell
as
more
general
kinds
of
expressions.
17.1.1
The
Arit
y
and
Order
of
an
Op
erator
An
op
erator
has
an
arity
and
an
or
der.
An
op
erator's
arit
y
describ
es
the
n
um
b
er
and
order
of
its
argumen
ts.
It's
the
arit
y
of
the
L
en
op
erator
that
tells
us
L
en
is
dened
in
the
Se
quenc
es
mo
dule
on
page
341.
that
L
en
(s
)
is
a
legal
expression,
while
L
en
(s
;
t
)
and
L
en
(+)
are
not.
All
the
op
erators
of
TLA
+
,
whether
built-in
or
dened,
fall
in
to
three
classes:
0th-,
1st-,
and
2nd-order
op
erators.
1
Here
is
ho
w
these
classes,
and
their
arities,
are
dened:
0.
E

=
x
0
+
y
denes
E
to
b
e
the
0th-order
op
erator
x
0
+
y
.
A
0th-order
op
erator
tak
es
no
argumen
ts,
so
it
is
an
ordinary
expression.
W
e
represen
t
the
arit
y
of
suc
h
an
op
erator
b
y
the
sym
b
ol
(underscore).
1.
F
(x
;
y
)

=
x
[
fz
;
y
g
denes
F
to
b
e
a
1st-order
op
erator.
F
or
an
y
expres-
sions
e
1
and
e
2
,
it
denes
F
(e
1
;
e
2
)
to
b
e
an
expression.
W
e
represen
t
the
arit
y
of
F
b
y
h
;
i.
In
general,
a
1st-order
op
erator
tak
es
expressions
as
argumen
ts.
Its
arit
y
is
the
tuple
h
;
:
:
:
;
i,
with
one
for
eac
h
argumen
t.
2.
G
(f
(
;
);
x
;
y
)

=
f
(x
;
fx
;
y
g)
denes
G
to
b
e
a
2nd-order
op
erator.
The
op
erator
G
tak
es
three
argumen
ts:
its
rst
argumen
t
is
a
1st-order
op-
erator
that
tak
es
t
w
o
argumen
ts;
its
last
t
w
o
argumen
ts
are
expressions.
F
or
an
y
op
erator
Op
of
arit
y
h
;
i,
and
an
y
expressions
e
1
and
e
2
,
this
denes
G
(Op
;
e
1
;
e
2
)
to
b
e
an
expression.
W
e
sa
y
that
G
has
arit
y
h
h
;
i;
;
i.
In
general,
the
argumen
ts
of
a
2nd-order
op
erator
ma
y
b
e
expressions
or
1st-order
op
erators.
A
2nd-order
op
erator
has
an
arit
y
of
the
form
h
a
1
;
:
:
:
;
a
n
i,
where
eac
h
a
i
is
either
or
h
;
:
:
:
;
i
.
(W
e
can
consider
a
1st-order
op
erator
to
b
e
a
degenerate
case
of
a
2nd-order
op
erator.)
It
w
ould
b
e
easy
enough
to
dene
3rd-
and
higher-order
op
erators.
TLA
+
do
es
not
p
ermit
them
b
ecause
they
are
of
little
use
and
w
ould
mak
e
it
harder
to
c
hec
k
lev
el-correctness,
whic
h
is
discussed
in
Section
17.2
b
elo
w.
1
Ev
en
though
it
allo
ws
2nd-order
op
erators,
TLA
+
is
still
what
logicians
call
a
rst-order
logic
b
ecause
it
p
ermits
quan
tication
only
o
v
er
0th-order
op
erators.
A
higher-order
logic
w
ould
allo
w
us
to
write
the
form
ula
9
x
(
)
:
exp
.

17.1.
OPERA
TORS
AND
EXPRESSIONS
319
17.1.2

Expressions
When
w
e
dene
a
0th-order
op
erator
E
b
y
E

=
exp
,
w
e
can
write
what
the
op
erator
E
equals|it
equals
the
expression
exp
.
W
e
can
explain
the
meaning
of
this
denition
b
y
sa
ying
that
it
assigns
the
v
alue
exp
to
the
sym
b
ol
E
.
T
o
explain
the
meaning
of
an
arbitrary
TLA
+
denition,
w
e
need
to
b
e
able
to
write
what
a
1st-
or
2nd-order
op
erator
equals|for
example,
the
op
erator
F
dened
b
y
F
(x
;
y
)

=
x
[
fz
;
y
g
TLA
+
pro
vides
no
w
a
y
to
write
an
expression
that
equals
this
op
erator
F
.
(A
TLA
+
expression
can
equal
only
a
0th-order
op
erator.)
W
e
therefore
generalize
expressions
to

expr
essions,
and
w
e
write
the
op
erator
that
F
equals
as
the

expression

x
;
y
:
x
[
fz
;
y
g
The
sym
b
ols
x
and
y
in
this

expression
are
called

parameters.
W
e
use

expressions
only
to
explain
the
meaning
of
TLA
+
sp
ecications;
w
e
can't
write
a

expression
in
TLA
+
.
W
e
also
allo
w
2nd-order

expressions,
where
the
op
erator
G
dened
b
y
G
(f
(
;
);
x
;
y
)

=
f
(y
;
fx
;
z
g)
is
equal
to
the

expression

f
(
;
);
x
;
y
:
f
(y
;
fx
;
z
g)
(17.1)
The
general
form
of
a

expression
is

p
1
;
:
:
:
;
p
n
:
exp
,
where
exp
is
a

expression,
eac
h
parameter
p
i
is
either
an
iden
tier
id
i
or
has
the
form
id
i
(
;
:
:
:
;
),
and
the
id
i
are
all
distinct.
W
e
call
id
i
the
identier
of
the

parameter
p
i
.
W
e
consider
the
n
=
0
case,
the

expression

:
exp
with
no
parameters,
to
b
e
the
expression
exp
.
This
mak
es
a

expression
a
generalization
of
an
ordinary
expression.
A

parameter
iden
tier
is
a
b
ound
iden
tier,
just
lik
e
the
iden
tier
x
in
8
x
:
F
.
As
with
an
y
b
ound
iden
tiers,
renaming
the

parameter
iden
tiers
in
a

expression
do
esn't
c
hange
the
meaning
of
the
expression.
F
or
example,
(17.1)
is
equiv
alen
t
to

ab
c
(
;
);
qq
;
m
:
ab
c
(m
;
fqq
;
z
g)
F
or
obscure
historical
reasons,
this
kind
of
renaming
is
called

c
onversion.
If
Op
is
the

expression

p
1
;
:
:
:
;
p
n
:
exp
,
then
Op
(e
1
;
:
:
:
;
e
n
)
equals
the
result
of
replacing
the
iden
tier
of
the

parameter
p
i
in
exp
with
e
i
,
for
all
i
in
1
:
:
n
.
F
or
example,
(
x
;
y
:
x
[
fz
;
y
g)
(TT
;
w
+
z
)
=
TT
[
fz
;
(w
+
z
)g
This
pro
cedure
for
ev
aluating
the
application
of
a

expression
is
called

r
e-
duction.

320
CHAPTER
17.
THE
MEANING
OF
A
MODULE
17.1.3
Simplifying
Op
erator
Application
T
o
simplify
the
exp
osition,
I
assume
that
ev
ery
op
erator
application
is
written
in
the
form
Op
(e
1
;
:
:
:
;
e
n
).
TLA
+
pro
vides
a
n
um
b
er
of
dieren
t
syn
tactic
forms
for
op
erator
application,
so
I
ha
v
e
to
explain
ho
w
they
are
translated
in
to
this
simple
form.
Here
are
all
the
dieren
t
forms
of
op
erator
application
and
their
translations.

Simple
constructs
with
a
xed
n
um
b
er
of
argumen
ts,
including
inx
op
er-
ators
lik
e
+,
prex
op
erators
lik
e
enabled
,
and
constructs
lik
e
WF
,
func-
tion
application,
and
if/then/else.
These
op
erators
and
constructs
p
ose
no
problem.
W
e
can
write
+(a
;
b
)
instead
of
a
+
b
,
IfThenElse
(p
;
e
1
;
e
2
)
instead
of
if
p
then
e
1
else
e
2
and
Apply
(f
;
e
)
instead
of
f
[e
].
An
expression
lik
e
a
+
b
+
c
is
an
abbre-
viation
for
(a
+
b
)
+
c
,
so
it
can
b
e
written
+(+(a
;
b
);
c
).

Simple
constructs
with
a
v
ariable
n
um
b
er
of
argumen
ts|for
example,
fe
1
;
:
:
:
;
e
n
g
and
[h
1
7!
e
1
;
:
:
:
;
h
n
7!
e
n
].
W
e
can
consider
eac
h
of
these
constructs
to
b
e
rep
eated
application
of
simpler
op
erators
with
a
xed
n
um
b
er
of
argumen
ts.
F
or
example,
fe
1
;
:
:
:
;
e
n
g
=
fe
1
g
[
:
:
:
[
fe
n
g
[h
1
7!
e
1
;
:
:
:
;
h
n
7!
e
n
]
=
[h
1
7!
e
1
]
@@
:
:
:
@@
[h
n
7!
e
n
]
where
@@
is
dened
in
the
TLC
mo
dule,
on
page
248.
Of
course,
fe
g
can
b
e
written
Singleton
(e
)
and
[h
7!
e
]
can
b
e
written
R
e
c
or
d
(\h
"
;
e
).
Note
that
an
arbitrary
case
expression
can
b
e
written
in
terms
of
case
expressions
of
the
form
case
p
!
e
2
q
!
f
using
the
relation
case
p
1
!
e
1
2
:
:
:
2
p
n
!
e
n
=
case
p
1
!
e
1
2
(p
2
_
:
:
:
_
p
n
)
!
(case
p
2
!
e
2
2
:
:
:
2
p
n
!
e
n
)

Constructs
that
in
tro
duce
b
ound
v
ariables|for
example,
9
x
2
S
:
x
+
z
>
y
W
e
can
rewrite
this
expression
as
ExistsIn
(S
;

x
:
x
+
z
>
y
)
where
ExistsIn
is
a
2nd-order
op
erator
of
arit
y
h
;
h
i
i.
All
the
v
arian
ts
of
the
9
construct
can
b
e
represen
ted
as
expressions
using
either
9
x
2
S
:
e
or
9
x
:
e
.
(Section
16.1.1
sho
ws
ho
w
these
v
arian
ts
can
b
e
translated
in
to
expressions
using
only
9
x
:
e
,
but
those
translations
don't
main
tain
the

17.2.
LEVELS
321
scoping
rules|for
example,
rewriting
9
x
2
S
:
e
as
9
x
:
(x
2
S
)
^
e
mo
v
es
S
inside
the
scop
e
of
the
b
ound
v
ariable
x
.)
All
other
constructs
that
in
tro
duce
b
ound
v
ariables,
suc
h
as
fx
2
S
:
exp
g,
can
similarly
b
e
expressed
in
the
form
Op
(e
1
;
:
:
:
;
e
n
)
using

expressions
and
2nd-order
op
erators
Op
.
(Chapter
16
explains
ho
w
to
express
con-
structs
lik
e
fhx
;
y
i
2
S
:
exp
g,
whic
h
ha
v
e
a
tuple
of
b
ound
iden
tiers,
in
terms
of
constructs
with
ordinary
b
ound
iden
tiers.)

Op
erator
applications
suc
h
as
M
(x
)
!
Op
(y
;
z
)
that
arise
from
instan
tiation.
W
e
write
this
as
M
!
Op
(x
;
y
;
z
).

let
expressions.
The
meaning
of
a
let
expression
is
explained
in
Sec-
tion
17.4
b
elo
w.
F
or
no
w,
w
e
consider
only
let-free

expressions|ones
that
con
tain
no
let
expressions.
F
or
uniformit
y
,
I
will
call
an
op
erator
sym
b
ol
an
identier,
ev
en
if
it
is
a
sym
b
ol
lik
e
+
that
isn't
an
iden
tier
according
to
the
syn
tax
of
Chapter
15.
17.1.4
Expressions
W
e
can
no
w
inductiv
ely
dene
an
expression
to
b
e
either
a
0th-order
op
erator,
or
to
ha
v
e
the
form
Op
(e
1
;
:
:
:
;
e
n
)
where
Op
is
an
op
erator
and
eac
h
e
i
is
either
an
expression
or
a
1st-order
op
erator.
The
expression
m
ust
b
e
arity-c
orr
e
ct,
meaning
that
Op
m
ust
ha
v
e
arit
y
h
a
1
;
:
:
:
;
a
n
i,
where
eac
h
a
i
is
the
arit
y
of
e
i
.
In
other
w
ords,
e
i
m
ust
b
e
an
expression
if
a
i
equals
;
otherwise
it
m
ust
b
e
a
1st-order
op
erator
with
arit
y
a
i
.
W
e
require
that
Op
not
b
e
a

expression.
(If
it
is,
w
e
can
use

reduction
to
ev
aluate
Op
(e
1
;
:
:
:
;
e
n
)
and
eliminate
the

expression
Op
.)
Hence,
a

expression
can
app
ear
in
an
expression
only
as
an
argumen
t
of
a
2nd-order
op
erator.
This
implies
that
only
1st-order

expressions
can
app
ear
in
an
expression.
W
e
ha
v
e
eliminated
all
b
ound
iden
tiers
except
the
ones
in

expressions.
W
e
main
tain
the
TLA
+
requiremen
t
that
an
iden
tier
that
already
has
a
meaning
cannot
b
e
used
as
a
b
ound
iden
tier.
Th
us,
in
an
y

expression

p
1
;
:
:
:
;
p
n
:
exp
,
the
iden
tiers
of
the
parameters
p
i
cannot
app
ear
as
parameter
iden
tiers
in
an
y

expression
that
o
ccurs
in
exp
.
Remem
b
er
that

expressions
are
used
only
to
explain
the
seman
tics
of
TLA
+
.
They
are
not
part
of
the
language,
and
they
can't
b
e
used
in
a
TLA
+
sp
ecica-
tion.
17.2
Lev
els
TLA
+
has
a
class
of
syn
tactic
restrictions
that
come
from
the
underlying
logic
TLA
and
ha
v
e
no
coun
terpart
in
ordinary
mathematics.
The
simplest
of
these
is

322
CHAPTER
17.
THE
MEANING
OF
A
MODULE
that
\double-priming"
is
prohibited.
F
or
example,
(x
0
+
y
)
0
is
not
syn
tactically
w
ell-formed,
and
is
therefore
meaningless,
b
ecause
the
op
erator
0
(priming)
can
b
e
applied
only
to
a
state
function,
not
to
a
transition
function
lik
e
x
0
+
y
.
This
class
of
restriction
is
expressed
in
terms
of
levels.
In
TLA,
an
expression
has
one
of
four
basic
lev
els,
whic
h
are
n
um
b
ered
0,
1,
2,
and
3.
These
lev
els
are
describ
ed
b
elo
w,
using
examples
that
assume
x
,
y
,
and
c
are
declared
b
y
v
ariables
x
;
y
const
ant
c
and
sym
b
ols
lik
e
+
ha
v
e
their
usual
meanings.
0.
A
c
onstant
-lev
el
expression
is
a
constan
t;
it
con
tains
only
constan
ts
and
constan
t
op
erators.
Example:
c
+
3.
1.
A
state
-lev
el
expression
is
a
state
function;
it
ma
y
con
tain
constan
ts,
con-
stan
t
op
erators,
and
unprimed
v
ariables.
Example:
x
+
2

c
.
2.
A
tr
ansition
-lev
el
expression
is
a
transition
function;
it
ma
y
con
tain
an
y-
thing
except
temp
oral
op
erators.
Example:
x
0
+
y
>
c
.
3.
A
temp
or
al
-lev
el
expression
is
a
temp
oral
form
ula;
it
ma
y
con
tain
an
y
TLA
op
erator.
Example:
2[x
0
>
y
+
c
]
h
x
;
y
i
.
Chapter
16
assigns
meanings
to
all
basic
expressions|ones
con
taining
only
the
built-in
op
erators
of
TLA
+
and
declared
constan
ts
and
v
ariables.
The
meaning
assigned
to
an
expression
dep
ends
as
follo
ws
on
its
lev
el.
0.
The
meaning
of
a
constan
t-lev
el
basic
expression
is
a
constan
t-lev
el
basic
expression
con
taining
only
primitiv
e
op
erators.
1.
The
meaning
of
a
state-lev
el
basic
expression
e
is
an
assignmen
t
of
a
con-
stan
t
expression
s
[
[e
]
]
to
an
y
state
s
.
2.
The
meaning
of
a
transition-lev
el
basic
expression
e
is
an
assignmen
t
of
a
constan
t
expression
h
s
;
t
i[
[e
]
]
to
an
y
transition
s
!
t
.
3.
The
meaning
of
a
temp
oral-lev
el
basic
expression
F
is
an
assignmen
t
of
a
constan
t
expression

j
=
F
to
an
y
b
eha
vior

.
An
expression
of
an
y
lev
el
can
b
e
considered
to
b
e
an
expression
of
a
higher
lev
el,
except
that
a
transition-lev
el
expression
is
not
a
temp
oral-lev
el
expression.
2
F
or
example,
if
x
is
a
declared
v
ariable,
then
the
state-lev
el
expression
x
>
2
is
the
2
More
precisely
,
a
transition-lev
el
expression
that
is
not
a
state-lev
el
expression
is
not
a
temp
oral-lev
el
expression.

17.2.
LEVELS
323
temp
oral-lev
el
form
ula
suc
h
that

j
=
x
is
the
v
alue
of
x
>
2
in
the
rst
state
of

,
for
an
y
b
eha
vior

.
3
A
set
of
simple
rules
inductiv
ely
denes
whether
a
basic
expression
is
level-
c
orr
e
ct
and,
if
so,
what
its
lev
el
is.
Here
are
some
of
the
rules:

A
declared
constan
t
is
a
lev
el-correct
expression
of
lev
el
0.

A
declared
v
ariable
is
a
lev
el-correct
expression
of
lev
el
1.

If
Op
is
declared
to
b
e
a
1st-order
constan
t
op
erator,
then
the
expression
Op
(e
1
;
:
:
:
;
e
n
)
is
lev
el-correct
i
eac
h
e
i
is
lev
el-correct,
in
whic
h
case
its
lev
el
is
the
maxim
um
of
the
lev
els
of
the
e
i
.

e
1
2
e
2
is
lev
el-correct
i
e
1
and
e
2
are,
in
whic
h
case
its
lev
el
is
the
maxim
um
of
the
lev
els
of
e
1
and
e
2
.

e
0
is
lev
el-correct
and
has
lev
el
2
i
e
is
lev
el-correct
and
has
lev
el
at
most
1.
4

enabled
e
is
lev
el-correct
and
has
lev
el
1
i
e
is
lev
el-correct
and
has
lev
el
at
most
2.

9
x
:
e
is
lev
el-correct
and
has
lev
el
l
i
e
is
lev
el-correct
and
has
lev
el
l
,
when
x
is
considered
to
b
e
a
declared
constan
t.

9
9
9
9
9
9
x
:
e
is
lev
el-correct
and
has
lev
el
3
i
e
is
lev
el-correct
and
has
an
y
lev
el
other
than
2,
when
x
is
considered
to
b
e
a
declared
v
ariable.
There
are
similar
rules
for
the
other
TLA
+
op
erators.
A
useful
consequence
of
these
rules
is
that
lev
el-correctness
of
a
basic
expres-
sion
do
es
not
dep
end
on
the
lev
els
of
the
declared
iden
tiers.
In
other
w
ords,
an
expression
e
is
lev
el-correct
when
c
is
declared
to
b
e
a
constan
t
i
it
is
lev
el-
correct
when
c
is
declared
to
b
e
a
v
ariable.
Of
course,
the
lev
el
of
e
ma
y
dep
end
on
the
lev
el
of
c
.
W
e
can
abstract
these
rules
b
y
generalizing
the
concept
of
a
lev
el.
So
far,
w
e
ha
v
e
dened
the
lev
el
only
of
an
expression.
W
e
can
dene
the
lev
el
of
a
1st-
or
2nd-order
op
erator
Op
to
b
e
a
rule
for
determining
the
lev
el-correctness
and
lev
el
of
an
expression
Op
(e
1
;
:
:
:
;
e
n
)
as
a
function
of
the
lev
els
of
the
argumen
ts
e
i
.
The
lev
el
of
a
1st-order
op
erator
is
a
rule,
so
the
lev
el
of
a
2nd-order
op
erator
Op
is
a
rule
that
dep
ends
in
part
on
rules|namely
,
on
the
lev
els
of
the
argumen
ts
that
are
op
erators.
This
mak
es
a
rigorous
general
denition
of
lev
els
for
2nd-
order
op
erators
rather
complicated.
F
ortunately
,
there's
a
simpler,
less
general
3
The
expression
x
+
2
can
b
e
considered
to
b
e
a
temp
oral-lev
el
expression
that,
lik
e
the
temp
oral-lev
el
expression
2(x
+
2),
is
silly
.
(See
the
discussion
of
silliness
in
Section
6.2
on
page
67.)
4
If
e
is
a
constan
t
expression,
then
e
0
equals
e
,
so
w
e
could
consider
e
0
to
ha
v
e
lev
el
0.
F
or
simplicit
y
,
w
e
consider
e
0
to
ha
v
e
lev
el
2
ev
en
if
e
is
a
constan
t.

324
CHAPTER
17.
THE
MEANING
OF
A
MODULE
denition
that
handles
all
the
op
erators
of
TLA
+
.
Ev
en
more
fortunately
,
y
ou
don't
ha
v
e
to
kno
w
it,
so
I
w
on't
b
other
writing
it
do
wn.
All
y
ou
need
to
kno
w
is
that
there
exists
a
w
a
y
of
assigning
a
lev
el
to
ev
ery
built-in
op
erator
of
TLA
+
.
The
lev
el-correctness
and
lev
el
of
an
y
basic
expression
is
then
determined
b
y
those
lev
els
and
the
lev
els
of
the
declared
iden
tiers
that
o
ccur
in
the
expression.
One
imp
ortan
t
class
of
op
erator
lev
els
are
the
c
onstant
lev
els.
An
y
expression
built
from
constan
t-lev
el
op
erators
and
declared
constan
ts
has
constan
t
lev
el.
The
built-in
constan
t
op
erators
of
TLA
+
,
listed
in
T
ables
1
and
2
(pages
268
and
269)
all
ha
v
e
constan
t
lev
el.
An
y
op
erator
dened
solely
in
terms
of
constan
t-
lev
el
op
erators
and
declared
constan
ts
has
constan
t
lev
el.
W
e
no
w
extend
the
denition
of
lev
el-correctness
from
expressions
to

ex-
pressions.
W
e
dene
the

expression
p
1
;
:
:
:
;
p
n
:
exp
to
b
e
lev
el-correct
i
exp
is
lev
el-correct
when
the

parameter
iden
tiers
are
declared
to
b
e
constan
ts
of
the
appropriate
arit
y
.
F
or
example,
p
;
q
(
)
:
exp
is
lev
el-correct
i
exp
is
lev
el-correct
with
the
additional
declaration
const
ants
p
;
q
(
)
This
inductiv
ely
denes
lev
el-correctness
for

expressions.
The
denition
is
reasonable
b
ecause,
as
observ
ed
a
few
paragraphs
ago,
the
lev
el-correctness
of
exp
do
esn't
dep
end
on
whether
w
e
assign
lev
el
0
or
1
to
the

parameters.
One
can
also
dene
the
lev
el
of
an
arbitrary

expression,
but
that
w
ould
require
the
general
denition
of
the
lev
el
of
an
op
erator,
whic
h
w
e
w
an
t
to
a
v
oid.
17.3
Con
texts
Syn
tactic
correctness
of
a
basic
expression
dep
ends
on
the
arities
of
the
declared
iden
tiers.
The
expression
F
o
o
=
fg
is
syn
tactically
correct
if
F
o
o
is
declared
to
b
e
a
v
ariable,
and
hence
of
arit
y
,
but
not
if
it's
declared
to
b
e
a
(1st-order)
constan
t
of
arit
y
h
i.
The
meaning
of
a
basic
expression
also
dep
ends
on
the
lev
els
of
the
declared
iden
tiers.
W
e
can't
determine
those
arities
and
lev
els
just
b
y
lo
oking
at
the
expression
itself;
they
are
implied
b
y
the
con
text
in
whic
h
the
expression
app
ears.
A
non
basic
expression
con
tains
dened
as
w
ell
as
declared
op
erators.
Its
syn
tactic
correctness
and
meaning
dep
end
on
the
denitions
of
those
op
erators,
whic
h
also
dep
end
on
the
con
text.
This
section
denes
a
precise
notion
of
a
con
text.
F
or
uniformit
y
,
built-in
op
erators
are
treated
the
same
as
dened
and
de-
clared
op
erators.
Just
as
the
con
text
migh
t
tell
us
that
the
iden
tier
x
is
a
declared
v
ariable,
it
tells
us
that
2
is
declared
to
b
e
a
constan
t-lev
el
op
erator
of
arit
y
h
;
i
and
that
=
2
is
dened
to
equal
a
;
b
:
:(2
(a
;
b
))
.
W
e
assume
a
standard
con
text
that
sp
ecies
all
the
built-in
op
erators
of
TLA
+
.
T
o
dene
con
texts,
let's
rst
dene
declarations
and
denitions.
A
de
clar
a-
tion
assigns
an
arit
y
and
lev
el
to
an
op
erator
name.
A
denition
assigns
a
let-
free

expression
to
an
op
erator
name.
A
mo
dule
denition
assigns
the
meaning

17.4.
THE
MEANING
OF
A

EXPRESSION
325
of
a
mo
dule
to
a
mo
dule
name,
where
the
meaning
of
a
mo
dule
is
dened
in
Section
17.5
b
elo
w.
5
A
c
ontext
consists
of
a
set
of
declarations,
denitions,
and
mo
dule
denitions
suc
h
that
C1.
An
op
erator
name
is
declared
or
dened
at
most
once
b
y
the
con
text.
(This
means
that
it
can't
b
e
b
oth
declared
and
dened.)
C2.
No
op
erator
dened
or
declared
b
y
the
con
text
app
ears
as
the
iden
tier
of
a

parameter
in
an
y
denition's
expression.
C3.
Ev
ery
op
erator
name
that
app
ears
in
a
denition's
expression
is
either
a

parameter's
iden
tier
or
is
declared
(not
dened)
b
y
the
con
text.
C4.
No
mo
dule
name
is
assigned
meanings
b
y
t
w
o
dieren
t
mo
dule
denitions.
Mo
dule
and
op
erator
names
are
handled
separately
.
The
same
string
ma
y
b
e
b
oth
a
mo
dule
name
that
is
dened
b
y
a
mo
dule
denition
and
an
op
erator
name
that
is
either
declared
or
dened
b
y
an
ordinary
denition.
Here
is
an
example
of
a
con
text
that
declares
the
sym
b
ols
[,
a
,
b
,
and
2,
denes
the
sym
b
ols
c
and
fo
o
,
and
denes
the
mo
dule
Natur
als
:
f
[
:
h
;
i;
a
:
;
b
:
;
2
:
h
;
i;
c

=
[(a
;
b
);
fo
o

=
p
;
q
(
)
:
2
(p
;
[(q
(b
);
a
));
Natur
als
m
=
:
:
:
g
(17.2)
Not
sho
wn
are
the
lev
els
assigned
to
the
op
erators
[,
a
,
b
,
and
2
and
the
meaning
assigned
to
Natur
als
.
If
C
is
a
con
text,
a
C
-b
asic

expr
ession
is
dened
to
b
e
a

expression
that
con
tains
only
sym
b
ols
declared
in
C
(in
addition
to

parameters).
F
or
example,
x
:
2
(x
;
[(a
;
b
))
is
a
C
-basic

expression
if
C
is
the
con
text
(17.2).
Ho
w
ev
er,
neither
\(a
;
b
)
nor
x
:
c
(x
;
b
)
is
a
C
-basic

expression
b
ecause
neither
\
nor
c
is
declared
in
C
.
(The
sym
b
ol
c
is
dened,
not
declared,
in
C
.)
A
C
-basic

expression
is
syntactic
al
ly
c
orr
e
ct
if
it
is
arit
y-
and
lev
el-correct
with
the
arities
and
lev
els
assigned
b
y
C
to
the
expression's
op
erators.
Condition
C3
states
that
if
Op

=
exp
is
a
denition
in
con
text
C
,
then
exp
is
a
C
-basic

expression.
W
e
add
to
C3
the
requiremen
t
that
it
b
e
syn
tactically
correct.
W
e
also
allo
w
a
con
text
to
con
tain
a
sp
ecial
denition
of
the
form
Op

=
?
that
assigns
to
the
name
Op
an
\illegal"
v
alue
?
that
is
not
a

expression.
This
denition
indicates
that,
in
the
con
text,
it
is
illegal
to
use
the
op
erator
name
Op
.
17.4
The
Meaning
of
a

Expression
W
e
no
w
dene
the
meaning
C
[
[e
]
]
of
a

expression
e
in
a
con
text
C
to
b
e
a
C
-basic

expression.
If
e
is
an
ordinary
(non
basic)
expression,
and
C
is
the
5
The
meaning
of
a
mo
dule
is
dened
in
terms
of
con
texts,
so
these
denitions
app
ear
to
b
e
circular.
In
fact,
the
denitions
of
con
text
and
of
the
meaning
of
a
mo
dule
together
form
a
single
inductiv
e
denition.

326
CHAPTER
17.
THE
MEANING
OF
A
MODULE
con
text
that
sp
ecies
the
built-in
TLA
+
op
erators
and
declares
the
constan
ts
and
v
ariables
that
o
ccur
in
e
,
then
this
will
dene
C
[
[e
]
]
to
b
e
a
basic
expression.
Since
Chapter
16
denes
the
meaning
of
basic
expressions,
this
denes
the
meaning
of
an
arbitrary
expression.
The
expression
e
ma
y
con
tain
let
constructs,
so
this
denes
the
meaning
of
let,
the
one
op
erator
whose
meaning
is
not
dened
in
Chapter
16.
Basically
,
C
[
[e
]
]
is
obtained
from
e
b
y
replacing
all
dened
op
erator
names
with
their
denitions
and
then
applying

reduction
whenev
er
p
ossible.
Recall
that

reduction
replaces
(
p
1
;
:
:
:
;
p
n
:
exp
)
(e
1
;
:
:
:
;
e
n
)
with
the
expression
obtained
from
exp
b
y
replacing
the
iden
tier
of
p
i
with
e
i
,
for
eac
h
i
.
The
denition
of
C
[
[e
]
]
do
es
not
dep
end
on
the
lev
els
assigned
b
y
the
declarations
of
C
.
So,
w
e
ignore
lev
els
in
the
denition.
The
inductiv
e
denition
of
C
[
[e
]
]
consists
of
the
follo
wing
rules:

If
e
is
an
op
erator
sym
b
ol,
then
C
[
[e
]
]
equals
(i)
e
if
e
is
declared
in
C
,
or
(ii)
the

expression
of
e
's
denition
in
C
if
e
is
dened
in
C
.

If
e
is
Op
(e
1
;
:
:
:
;
e
n
),
where
Op
is
declared
in
C
,
then
C
[
[e
]
]
equals
the
expression
Op
(C
[
[e
1
]
];
:
:
:
;
C
[
[e
n
]
]).

If
e
is
Op
(e
1
;
:
:
:
;
e
n
),
where
Op
is
dened
in
C
to
equal
the

expression
d
,
then
C
[
[e
]
]
equals
the

reduction
of
d
(C
[
[e
1
]
];
:
:
:
;
C
[
[e
n
]
]),
where
d
is
obtained
from
d
b
y

con
v
ersion
(replacemen
t
of

parameters)
so
that
no

parameter's
iden
tier
app
ears
in
b
oth
d
and
some
C
[
[e
i
]
].

If
e
is
p
1
;
:
:
:
;
p
n
:
exp
,
then
C
[
[e
]
]
equals
p
1
;
:
:
:
;
p
n
:
D
[
[exp
]
]
,
where
D
is
the
con
text
obtained
b
y
adding
to
C
the
declarations
that,
for
eac
h
i
in
1
:
:
n
,
assign
to
the
i
th

parameter's
iden
tier
the
arit
y
determined
b
y
p
i
.

If
e
is
where
d
is
a

expression
and
exp
an
expression,
then
C
[
[e
]
]
equals
D
[
[exp
]
],
where
D
is
the
con
text
obtained
b
y
adding
to
C
the
denition
that
assigns
C
[
[d
]
]
to
Op
.

If
e
is
let
Op
(p
1
;
:
:
:
;
p
n
)

=
inst
ance
:
:
:
in
exp
then
C
[
[e
]
]
equals
D
[
[exp
]
],
where
D
is
the
new
curren
t
con
text
obtained
b
y
\ev
aluating"
the
statemen
t
Op
(p
1
;
:
:
:
;
p
n
)

=
inst
ance
:
:
:
in
the
curren
t
con
text
C
,
as
describ
ed
in
Section
17.5.5
b
elo
w.
The
last
t
w
o
conditions
dene
the
meaning
of
an
y
let
construct,
b
ecause

17.5.
THE
MEANING
OF
A
MODULE
327

The
op
erator
denition
Op
(p
1
;
:
:
:
;
p
n
)

=
d
in
a
let
means
Op

=
p
1
;
:
:
:
;
p
n
:
d

A
function
denition
Op
[x
2
S
]

=
d
in
a
let
means
Op

=
choose
Op
:
Op
=
[x
2
S
7!
d
]

The
expression
let
Op
1

=
d
1
:
:
:
Op
n

=
d
n
in
exp
is
dened
to
equal
let
Op
1

=
d
1
in
(let
:
:
:
in
(let
Op
n

=
d
n
in
exp
)
:
:
:)
The

expression
e
is
dened
to
b
e
legal
(syn
tactically
w
ell-formed)
in
the
con-
text
C
i
these
rules
dene
C
[
[e
]
]
to
b
e
a
legal
C
-basic
expression.
17.5
The
Meaning
of
a
Mo
dule
The
meaning
of
a
mo
dule
dep
ends
on
a
con
text.
F
or
an
external
mo
dule,
whic
h
is
not
a
submo
dule
of
another
mo
dule,
the
con
text
consists
of
declarations
and
denitions
of
all
the
built-in
op
erators
of
TLA
+
,
together
with
denitions
of
some
other
mo
dules.
Section
17.7
b
elo
w
discusses
where
the
denitions
of
those
other
mo
dules
come
from.
The
meaning
of
a
mo
dule
in
a
con
text
C
consists
of
six
sets:
Dcl
A
set
of
declarations.
They
come
from
const
ant
and
v
ariable
dec-
larations
and
declarations
in
extended
mo
dules
(mo
dules
app
earing
in
an
extends
statemen
t).
GDef
A
set
of
global
denitions.
They
come
from
ordinary
(non-local)
denitions
and
global
denitions
in
extended
and
instan
tiated
mo
d-
ules.
LDef
A
set
of
lo
cal
denitions.
They
come
from
local
denitions
and
local
instan
tiations
of
mo
dules.
(Lo
cal
denitions
are
not
obtained
b
y
other
mo
dules
that
extend
or
instan
tiate
the
mo
dule.)
MDef
A
set
of
mo
dule
denitions.
They
come
from
submo
dules
of
the
mo
d-
ule
and
of
extended
mo
dules.
Ass
A
set
of
assumptions.
They
come
from
assume
statemen
ts
and
from
extended
mo
dules.
Thm
A
set
of
theorems.
They
come
from
theorem
statemen
ts,
from
the-
orems
in
extended
mo
dules,
and
from
the
assumptions
and
theorems
of
instan
tiated
mo
dules,
as
explained
in
Section
17.5.5
b
elo
w.

328
CHAPTER
17.
THE
MEANING
OF
A
MODULE
The

expressions
of
denitions
in
GDef
and
LDef
,
as
w
ell
as
the
expressions
in
Ass
and
Thm
,
are
(C
[
Dcl
)-basic

expressions.
In
other
w
ords,
the
only
op
erator
sym
b
ols
they
con
tain
(other
than

parameter
iden
tiers)
are
ones
declared
in
C
or
in
Dcl
.
The
meaning
of
a
mo
dule
in
a
con
text
C
is
dened
b
y
an
algorithm
for
computing
these
six
sets.
The
algorithm
pro
cesses
eac
h
statemen
t
in
the
mo
dule
in
turn,
from
b
eginning
to
end.
The
meaning
of
the
mo
dule
is
the
v
alue
of
those
sets
when
the
end
of
the
mo
dule
is
reac
hed.
Initially
,
all
six
sets
are
empt
y
.
The
rules
for
handling
eac
h
p
ossible
t
yp
e
of
statemen
t
are
giv
en
b
elo
w.
In
these
rules,
the
curr
ent
c
ontext
C
C
is
dened
to
b
e
the
union
of
C
,
Dcl
,
GDef
,
LDef
,
and
MDef
.
When
the
algorithm
adds
elemen
ts
to
the
con
text
C
C
,
it
uses

con
v
er-
sion
to
ensure
that
no
dened
or
declared
op
erator
name
app
ears
as
a

pa-
rameter's
iden
tier
in
an
y

expression
in
C
C
.
F
or
example,
if
the
denition
fo
o

=
x
:
x
+
1
is
in
LDef
,
then
adding
a
declaration
of
x
to
Dcl
requires

con
v
ersion
of
this
denition
to
rename
the

parameter
iden
tier
x
.
This

con
v
ersion
is
not
explicitly
men
tioned.
17.5.1
Extends
An
extends
statemen
t
has
the
form
extends
M
1
;
:
:
:
;
M
n
where
eac
h
M
i
is
a
mo
dule
name.
This
statemen
t
m
ust
b
e
the
rst
one
in
the
mo
dule.
The
statemen
t
sets
the
v
alues
of
Dcl
,
GDef
,
MDef
,
Ass
,
and
Thm
equal
to
the
union
of
the
corresp
onding
v
alues
for
the
mo
dule
meanings
assigned
b
y
C
to
the
mo
dule
names
M
i
.
This
statemen
t
is
legal
i
the
mo
dule
names
M
i
are
all
dened
in
C
,
and
the
resulting
curren
t
con
text
C
C
do
es
not
assign
more
than
one
meaning
to
an
y
sym
b
ol.
More
precisely
,
if
the
same
sym
b
ol
is
dened
or
declared
b
y
t
w
o
or
more
of
the
M
i
,
then
those
duplicate
denitions
or
declarations
m
ust
all
ha
v
e
b
een
obtained
through
a
(p
ossibly
empt
y)
c
hains
of
extends
statemen
ts
from
the
same
denition
or
declaration.
F
or
example,
supp
ose
M
1
extends
the
Natur
als
mo
dule,
and
M
2
extends
M
1
.
Then
the
three
mo
dules
Natur
als
,
M
1
,
and
M
2
all
dene
the
op
erator
+.
The
statemen
t
extends
Natur
als
;
M
1
;
M
2
can
still
b
e
legal,
b
ecause
eac
h
of
the
three
denitions
is
obtained
b
y
a
c
hain
of
extends
statemen
ts
(of
length
0,
1,
and
2,
resp
ectiv
ely)
from
the
denition
of
+
in
the
Natur
als
mo
dule.
When
decomp
osing
a
large
sp
ecication
in
to
mo
dules,
w
e
often
w
an
t
a
mo
d-
ule
M
to
extend
mo
dules
M
1
,
.
.
.
,
M
n
,
where
the
M
i
ha
v
e
declared
constan
ts

17.5.
THE
MEANING
OF
A
MODULE
329
and/or
v
ariables
in
common.
In
this
case,
w
e
put
the
common
declarations
in
a
mo
dule
P
that
is
extended
b
y
all
the
M
i
.
17.5.2
Declarations
A
declaration
statemen
t
has
one
of
the
forms
const
ant
c
1
;
:
:
:
;
c
n
v
ariable
v
1
;
:
:
:
;
v
n
where
eac
h
v
i
is
an
iden
tier
and
eac
h
c
i
is
either
an
iden
tier
or
has
the
form
Op
(
;
:
:
:
;
),
for
some
iden
tier
Op
.
This
statemen
t
adds
to
the
set
Dcl
the
ob
vious
declarations.
It
is
legal
i
none
of
the
declared
iden
tiers
is
dened
or
declared
in
C
C
.
17.5.3
Op
erator
Denitions
A
global
op
erator
denition
6
has
one
of
the
t
w
o
forms
Op

=
exp
Op
(p
1
;
:
:
:
;
p
n
)

=
exp
where
Op
is
an
iden
tier,
exp
is
an
expression,
and
eac
h
p
i
is
either
an
iden
tier
or
has
the
form
P
(
;
:
:
:
;
),
where
P
is
an
iden
tier.
W
e
consider
the
rst
form
an
instance
of
the
second
with
n
=
0.
This
statemen
t
is
legal
i
Op
is
not
declared
or
dened
in
C
C
and
the

expression
p
1
;
:
:
:
;
p
n
:
exp
is
legal
in
con
text
C
C
.
In
particular,
no

parameter
in
this

expression
can
b
e
dened
or
declared
in
C
C
.
The
statemen
t
adds
to
GDef
the
denition
that
assigns
to
Op
the

expression
C
C
[
[p
1
;
:
:
:
;
p
n
:
exp
]
]
.
A
lo
cal
op
erator
denition
has
one
of
the
t
w
o
forms
local
Op

=
exp
local
Op
(p
1
;
:
:
:
;
p
n
)

=
exp
It
is
the
same
as
a
global
denition,
except
that
it
adds
the
denition
to
LDef
instead
of
GDef
.
17.5.4
F
unction
Denitions
A
global
function
denition
has
the
form
Op
[fcnar
gs
]

=
exp
6
An
op
erator
denition
statemen
t
should
not
b
e
confused
with
a
denition
clause
in
a
let
expression.
The
meaning
of
a
let
expression
is
describ
ed
in
Section
17.4.

330
CHAPTER
17.
THE
MEANING
OF
A
MODULE
where
fcnar
gs
is
a
comma-separated
list
of
elemen
ts,
eac
h
ha
ving
the
form
Id
1
;
:
:
:
;
Id
n
2
S
or
h
Id
1
;
:
:
:
;
Id
n
i
2
S
.
It
is
equiv
alen
t
to
the
global
op
erator
denition
Op

=
choose
Op
:
Op
=
[fcnar
gs
7!
exp
]
A
lo
cal
function
denition,
whic
h
has
the
form
local
Op
[fcnar
gs
]

=
exp
is
equiv
alen
t
to
the
analogous
lo
cal
op
erator
denition.
17.5.5
Instan
tiation
W
e
consider
rst
a
global
instan
tiation
of
the
form
I
(p
1
;
:
:
:
;
p
m
)

=
inst
ance
N
with
q
1
 
e
1
;
:
:
:
;
q
n
 
e
n
(17.3)
F
or
this
to
b
e
legal,
N
m
ust
b
e
a
mo
dule
name
dened
in
C
C
.
Let
NDcl
,
NDef
,
NAss
,
and
NThm
b
e
the
sets
Dcl
,
GDef
,
Ass
,
and
Thm
in
the
meaning
assigned
to
N
b
y
C
C
.
The
q
i
m
ust
b
e
distinct
iden
tiers
declared
b
y
NDcl
.
W
e
add
a
with
clause
of
the
form
Op
 
Op
for
an
y
iden
tier
Op
that
is
declared
in
NDcl
but
is
not
one
of
the
q
i
,
so
the
q
i
constitute
all
the
iden
tiers
declared
in
NDcl
.
Neither
I
nor
an
y
of
the
iden
tiers
of
the
denition
parameters
p
i
ma
y
b
e
dened
or
declared
in
C
C
.
Let
D
b
e
the
con
text
obtained
b
y
adding
to
C
C
the
ob
vious
constan
t-lev
el
declaration
for
eac
h
p
i
.
Then
e
i
m
ust
b
e
syn
tactically
w
ell-formed
in
the
con
text
D
,
and
D
[
[e
i
]
]
m
ust
ha
v
e
the
same
arit
y
as
q
i
,
for
eac
h
i
2
1
:
:
n
.
The
instan
tiation
m
ust
also
satisfy
the
follo
wing
lev
el-correctness
condition.
Dene
mo
dule
N
to
b
e
a
c
onstant
mo
dule
i
ev
ery
declaration
in
NDcl
has
constan
t
lev
el,
and
ev
ery
op
erator
app
earing
in
ev
ery
denition
in
NDef
has
constan
t
lev
el.
If
N
is
not
a
constan
t
mo
dule,
then
for
eac
h
i
in
1
:
:
n
:

If
q
i
is
declared
in
NDcl
to
b
e
a
constan
t
op
erator,
then
D
[
[e
i
]
]
has
constan
t
lev
el.

If
q
i
is
declared
in
NDcl
to
b
e
a
v
ariable
(a
0th-order
op
erator
of
lev
el
1),
then
D
[
[e
i
]
]
has
lev
el
0
or
1.
The
reason
for
this
condition
is
explained
in
Section
17.8
b
elo
w.
F
or
eac
h
denition
Op

=
r
1
;
:
:
:
;
r
p
:
e
in
NDef
,
the
denition
I
!
Op

=

p
1
;
:
:
:
;
p
m
;
r
1
;
:
:
:
;
r
p
:
e
(17.4)
is
added
to
GDef
,
where
e
is
the
expression
obtained
from
e
b
y
substituting
e
i
for
q
i
,
for
all
i
2
1
:
:
n
.
Before
doing
this
substitution,

con
v
ersion
m
ust
b
e

17.5.
THE
MEANING
OF
A
MODULE
331
applied
to
ensure
that
C
C
is
a
correct
con
text
after
the
denition
of
I
!
Op
is
added
to
GDef
.
The
precise
denition
of
e
is
a
bit
subtle;
it
is
giv
en
in
Section
17.8
b
elo
w.
W
e
require
that
the

expression
in
(17.4)
b
e
lev
el-correct.
(If
N
is
a
nonconstan
t
mo
dule,
then
lev
el-correctness
of
this

expression
is
implied
b
y
the
lev
el
condition
on
parameter
instan
tiation
describ
ed
in
the
preceding
paragraph.)
Legalit
y
of
the
denition
of
Op
in
mo
dule
N
and
of
the
with
substitutions
implies
that
the

expression
is
arit
y-correct
in
the
curren
t
con
text.
Remem
b
er
that
I
!
Op
(c
1
;
:
:
:
;
c
m
;
d
1
;
:
:
:
;
d
n
)
is
actually
written
in
TLA
+
as
I
(c
1
;
:
:
:
;
c
m
)
!
Op
(d
1
;
:
:
:
;
d
n
).
Also
added
to
GDef
is
the
sp
ecial
denition
I

=
?.
This
prev
en
ts
I
from
later
b
eing
dened
or
declared
as
an
op
erator
name.
If
NAss
equals
the
set
fA
1
;
:
:
:
;
A
k
g
of
assumptions,
then
for
eac
h
theorem
T
in
NThm
,
w
e
add
to
Thm
the
theorem
A
1
^
:
:
:
^
A
k
)
T
(As
ab
o
v
e,
T
and
the
A
j
are
obtained
from
T
and
the
A
j
b
y
substituting
e
i
for
q
i
,
for
eac
h
i
in
1
:
:
k
.)
A
global
inst
ance
statemen
t
can
also
ha
v
e
the
t
w
o
forms
I

=
inst
ance
N
with
q
1
 
e
1
;
:
:
:
;
q
n
 
e
n
inst
ance
N
with
q
1
 
e
1
;
:
:
:
;
q
n
 
e
n
The
rst
is
just
the
m
=
0
case
of
(17.3);
the
second
is
similar
to
the
rst,
except
the
denitions
added
to
GDef
do
not
ha
v
e
I
!
prep
ended
to
the
op
erator
names.
The
second
form
also
has
the
legalit
y
condition
that
none
of
the
dened
sym
b
ols
in
N
ma
y
b
e
dened
or
declared
in
the
curren
t
con
text,
except
in
the
follo
wing
case.
An
op
erator
denition
ma
y
b
e
included
m
ultiple
times
through
c
hains
of
inst
ance
and
extends
statemen
ts
if
it
is
dened
in
a
mo
dule
7
ha
ving
no
declarations.
F
or
example,
supp
ose
the
curren
t
con
text
con
tains
a
denition
of
+
obtained
through
extending
the
Natur
als
mo
dule.
Then
an
inst
ance
N
statemen
t
is
legal
ev
en
though
N
also
extends
Natur
als
and
therefore
denes
+.
Because
the
Natur
als
mo
dule
declares
no
parameters,
instan
tiation
cannot
c
hange
the
denition
of
+.
In
all
forms
of
the
inst
ance
statemen
t,
omitting
the
with
clause
is
equiv-
alen
t
to
the
case
n
=
0
of
these
statemen
ts.
(Remem
b
er
that
all
the
declared
iden
tiers
of
mo
dule
N
are
either
explicitly
or
implicitly
instan
tiated.)
A
lo
cal
inst
ance
statemen
t
consists
of
the
k
eyw
ord
local
follo
w
ed
b
y
an
inst
ance
statemen
t
of
the
form
describ
ed
ab
o
v
e.
It
is
handled
in
a
similar
fashion
to
a
global
inst
ance
statemen
t,
except
that
all
denitions
are
added
to
LDef
instead
of
GDef
.
7
An
op
erator
J!Op
is
dened
in
the
mo
dule
that
con
tains
the
J

=
inst
ance
:
:
:
statemen
t.

332
CHAPTER
17.
THE
MEANING
OF
A
MODULE
17.5.6
Theorems
and
Assumptions
A
theorem
has
one
of
the
forms
theorem
exp
theorem
Op

=
exp
where
exp
is
an
expression,
whic
h
m
ust
b
e
legal
in
the
curren
t
con
text
C
C
.
The
rst
form
adds
the
theorem
C
C
[
[exp
]
]
to
the
set
Thm
.
The
second
form
is
equiv
alen
t
to
the
t
w
o
statemen
ts
Op

=
exp
theorem
Op
An
assumption
has
one
of
the
forms
assume
exp
assume
Op

=
exp
The
expression
exp
m
ust
ha
v
e
constan
t
lev
el.
An
assumption
is
similar
to
a
theorem
except
that
C
C
[
[exp
]
]
is
added
to
the
set
Ass
.
17.5.7
Submo
dules
A
mo
dule
can
con
tain
a
submo
dule,
whic
h
is
a
complete
mo
dule
that
b
egins
with
module
N
for
some
mo
dule
name
N
,
and
ends
with
This
is
legal
i
the
mo
dule
name
N
is
not
dened
in
C
C
and
the
mo
dule
is
legal
in
the
con
text
C
C
.
In
this
case,
the
mo
dule
denition
that
assigns
to
N
the
meaning
of
the
submo
dule
in
con
text
C
C
is
added
to
MDef
.
A
submo
dule
can
b
e
used
in
an
inst
ance
statemen
t
that
app
ears
either
later
in
the
curren
t
mo
dule
or
in
a
mo
dule
that
extends
the
curren
t
mo
dule.
Submo
dules
of
a
mo
dule
M
are
not
added
to
the
set
MDef
of
a
mo
dule
that
instan
tiates
M
.
17.6
Correctness
of
a
Mo
dule
Section
17.5
ab
o
v
e
denes
the
meaning
of
a
mo
dule
to
consist
of
the
six
sets
Dcl
,
GDef
,
LDef
,
MDef
,
Ass
,
and
Thm
.
Mathematically
,
w
e
can
view
the
meaning
of
a
mo
dule
to
b
e
the
assertion
that
all
the
theorems
in
Thm
are
consequences

17.7.
FINDING
MODULES
333
of
the
assumptions
in
Ass
.
More
precisely
,
let
A
b
e
the
conjunction
of
all
the
assumptions
in
Ass
.
The
mo
dule
asserts
that,
for
ev
ery
theorem
T
in
Thm
,
the
form
ula
A
)
T
is
v
alid.
8
An
assumption
or
theorem
of
the
mo
dule
is
a
(C
[
Dcl
)-basic
expression.
F
or
an
outermost
mo
dule
(not
a
submo
dule),
C
declares
only
the
built-in
op
erators
of
TLA
+
,
and
Dcl
declares
the
declared
constan
ts
and
v
ariables
of
the
mo
dule.
Therefore,
eac
h
form
ula
A
)
T
asserted
b
y
the
mo
dule
is
a
basic
expression.
W
e
sa
y
that
the
mo
dule
is
semantic
al
ly
c
orr
e
ct
if
eac
h
of
these
expressions
A
)
T
is
a
v
alid
form
ula
in
the
con
text
Dcl
.
Chapter
16
denes
what
it
means
for
a
basic
expression
to
b
e
a
v
alid
form
ula.
By
dening
the
meaning
of
a
theorem,
w
e
ha
v
e
dened
the
meaning
of
a
TLA
+
sp
ecication.
An
y
mathematically
meaningful
question
w
e
can
ask
ab
out
a
sp
ecication
can
b
e
framed
as
the
question
of
whether
a
certain
form
ula
is
a
v
alid
theorem.
17.7
Finding
Mo
dules
F
or
a
mo
dule
M
to
ha
v
e
a
meaning
in
a
con
text
C
,
ev
ery
mo
dule
N
extended
or
instan
tiated
b
y
M
m
ust
ha
v
e
its
meaning
dened
in
C
|unless
N
is
a
submo
dule
of
M
or
of
a
mo
dule
extended
b
y
M
.
In
principle,
mo
dule
M
is
in
terpreted
in
a
con
text
con
taining
declarations
and
denitions
of
the
built-in
TLA
+
op
erator
names
and
mo
dule
denitions
of
all
mo
dules
needed
to
in
terpret
M
.
In
practice,
a
to
ol
(or
a
p
erson)
b
egins
in
terpreting
M
in
a
con
text
C
0
initially
con
taining
only
declarations
and
denitions
of
the
built-in
TLA
+
op
erator
names.
When
the
to
ol
encoun
ters
an
extends
or
inst
ance
statemen
t
that
men
tions
a
mo
dule
named
N
not
dened
in
the
curren
t
con
text
C
C
of
M
,
the
to
ol
nds
the
mo
dule
named
N
,
in
terprets
it
in
the
con
text
C
0
,
and
then
adds
the
mo
dule
denition
for
N
to
C
0
and
to
C
C
.
The
denition
of
the
TLA
+
language
do
es
not
sp
ecify
ho
w
a
to
ol
nds
a
mo
dule
named
N
.
A
to
ol
will
most
lik
ely
lo
ok
for
the
mo
dule
in
a
le
named
N
.tla.
The
meaning
of
a
mo
dule
dep
ends
on
the
meanings
of
the
mo
dules
that
it
extends
or
instan
tiates.
The
meaning
of
eac
h
of
those
mo
dules
in
turn
ma
y
dep
end
on
the
meanings
of
other
mo
dules,
and
so
on.
Th
us,
the
meaning
of
a
mo
dule
dep
ends
on
the
meanings
of
some
set
of
mo
dules.
A
mo
dule
M
is
syn
tactically
incorrect
if
this
set
of
mo
dules
includes
M
itself.
8
In
a
temp
oral
logic
lik
e
TLA,
the
form
ula
F
)
G
is
not
in
general
equiv
alen
t
to
the
assertion
that
G
is
a
consequence
of
assumption
F
.
Ho
w
ev
er,
the
t
w
o
are
equiv
alen
t
if
F
is
a
constan
t
form
ula,
and
TLA
+
allo
ws
only
constan
t
assumptions.

334
CHAPTER
17.
THE
MEANING
OF
A
MODULE
17.8
The
Seman
tics
of
Instan
tiation
Section
17.5.5
ab
o
v
e
denes
the
meaning
of
an
inst
ance
statemen
t
in
terms
of
substitution.
I
no
w
dene
precisely
ho
w
that
substitution
is
p
erformed
and
explain
the
lev
el-correctness
rule
for
instan
tiating
nonconstan
t
mo
dules.
Supp
ose
that
mo
dule
M
con
tains
the
statemen
t
I

=
inst
ance
N
with
q
1
 
e
1
;
:
:
:
;
q
n
 
e
n
where
the
q
i
are
all
the
declared
iden
tiers
of
mo
dule
N
,
and
that
N
con
tains
the
denition
F

=
e
where
no

parameter
iden
tier
in
e
is
dened
or
declared
in
the
curren
t
con
text
of
M
.
The
inst
ance
statemen
t
then
adds
to
the
curren
t
con
text
of
M
the
denition
I
!
F

=
e
(17.5)
where
e
is
obtained
from
e
b
y
substituting
e
i
for
q
i
,
for
all
i
in
1
:
:
n
.
A
fundamen
tal
principle
of
mathematics
is
that
substitution
preserv
es
v
alid-
it
y;
substituting
in
a
v
alid
form
ula
yields
a
v
alid
form
ula.
So,
w
e
w
an
t
to
dene
e
so
that,
if
F
is
a
v
alid
form
ula
in
N
,
then
I
!
F
is
a
v
alid
form
ula
in
M
.
A
simple
example
sho
ws
that
the
lev
el
rule
for
instan
tiating
nonconstan
t
mo
dules
is
necessary
to
preserv
e
the
v
alidit
y
of
F
.
Supp
ose
F
is
dened
to
equal
2[c
0
=
c
]
c
,
where
c
is
declared
in
N
to
b
e
a
constan
t.
Then
F
is
a
tem-
p
oral
form
ula
asserting
that
no
step
c
hanges
c
.
It
is
v
alid
b
ecause
a
constan
t
has
the
same
v
alue
in
ev
ery
state
of
a
b
eha
vior.
If
w
e
allo
w
ed
an
instan
tiation
that
substitutes
a
v
ariable
x
for
the
constan
t
c
,
then
I
!
F
w
ould
b
e
the
form
ula
2[x
0
=
x
]
x
.
This
is
not
a
v
alid
form
ula
b
ecause
it
is
false
for
an
y
b
eha
vior
in
whic
h
the
v
alue
of
x
c
hanges.
Since
x
is
a
v
ariable,
suc
h
a
b
eha
vior
ob
viously
exists.
Preserving
v
alidit
y
requires
that
w
e
not
allo
w
substitution
of
a
noncon-
stan
t
for
a
declared
constan
t
when
instan
tiating
a
nonconstan
t
mo
dule.
(Since
2
and
0
are
nonconstan
t
op
erators,
this
denition
of
F
can
app
ear
only
in
a
nonconstan
t
mo
dule.)
In
ordinary
mathematics,
there
is
one
tric
ky
problem
in
making
substitution
preserv
e
v
alidit
y
.
Consider
the
form
ula
(n
2
Nat
)
)
(9
m
2
Nat
:
m

n
)
(17.6)
This
form
ula
is
v
alid
b
ecause
it
is
true
for
an
y
v
alue
of
n
.
No
w,
supp
ose
w
e
substitute
m
+
1
for
n
.
A
naiv
e
substitution
that
simply
replaces
n
b
y
m
+
1
w
ould
yield
the
form
ula
(m
+
1
2
Nat
)
)
(9
m
2
Nat
:
m

m
+
1)
(17.7)

17.8.
THE
SEMANTICS
OF
INST
ANTIA
TION
335
Since
the
form
ula
9
m
2
Nat
:
m

m
+
1
is
equiv
alen
t
to
f
alse,
(17.7)
is
ob
vi-
ously
not
v
alid.
Mathematicians
call
this
problem
variable
c
aptur
e
;
m
is
\cap-
tured"
b
y
the
quan
tier
9
m
.
Mathematicians
a
v
oid
it
b
y
the
rule
that,
when
substituting
for
an
iden
tier
in
a
form
ula,
one
do
es
not
substitute
for
b
ound
o
ccurrences
of
the
iden
tier.
This
rule
requires
that
m
b
e
remo
v
ed
from
(17.6)
b
y

con
v
ersion
b
efore
m
+
1
is
substituted
for
n
.
Section
17.5.5
denes
the
meaning
of
the
inst
ance
statemen
t
in
a
w
a
y
that
a
v
oids
v
ariable
capture.
Indeed,
form
ula
(17.7)
is
illegal
in
TLA
+
b
ecause
the
sub
expression
m
+
1
2
Nat
is
allo
w
ed
only
in
a
con
text
in
whic
h
m
is
dened
or
declared,
in
whic
h
case
m
cannot
b
e
used
as
a
b
ound
iden
tier,
so
the
sub
ex-
pression
9
m
:
:
:
is
illegal.
The

con
v
ersion
necessary
to
pro
duce
a
syn
tactically
w
ell-formed
expression
mak
es
this
kind
of
v
ariable
capture
imp
ossible.
The
problem
of
v
ariable
capture
o
ccurs
in
a
more
subtle
form
in
certain
nonconstan
t
op
erators
of
TLA
+
,
where
it
is
not
prev
en
ted
b
y
the
syn
tactic
rules.
Most
notable
of
these
op
erators
is
enabled.
Supp
ose
x
and
y
are
declared
v
ariables
of
mo
dule
N
,
and
F
is
dened
b
y
F

=
enabled
(x
0
=
0
^
y
0
=
1)
Then
F
is
equiv
alen
t
to
tr
ue
,
so
it
is
v
alid
in
mo
dule
N
.
(F
or
an
y
state
s
,
there
exists
a
state
t
in
whic
h
x
=
0
and
y
=
1.)
No
w
supp
ose
z
is
a
declared
v
ariable
of
mo
dule
M
,
and
let
the
instan
tiation
b
e
I

=
inst
ance
N
with
x
 
z
;
y
 
z
With
naiv
e
substitution,
I
!
F
w
ould
equal
enabled
(z
0
=
0
^
z
0
=
1)
whic
h
is
equiv
alen
t
to
f
alse.
(F
or
an
y
state
s
,
there
is
no
state
t
in
whic
h
z
=
0
and
z
=
1
are
b
oth
true.)
Hence,
I
!
F
w
ould
not
b
e
a
theorem,
so
instan
tiation
w
ould
not
preserv
e
v
alidit
y
.
Naiv
e
substitution
in
a
form
ula
of
the
form
enabled
A
do
es
not
preserv
e
v
alidit
y
b
ecause
the
primed
v
ariables
in
A
are
really
b
ound
iden
tiers.
The
form
ula
enabled
A
asserts
that
ther
e
exist
v
alues
of
the
primed
v
ariables
suc
h
that
A
is
true.
Substituting
z
0
for
x
0
and
y
0
in
the
enabled
form
ula
is
really
substitution
for
a
b
ound
iden
tier.
It
isn't
ruled
out
b
y
the
syn
tactic
rules
of
TLA
+
b
ecause
the
quan
tication
is
implicit.
T
o
preserv
e
v
alidit
y
,
w
e
m
ust
dene
e
in
(17.5)
so
it
a
v
oids
capture
of
iden-
tiers
implicitly
b
ound
in
enabled
expressions.
Before
p
erforming
the
substi-
tution,
w
e
rst
replace
the
primed
o
ccurrences
of
v
ariables
in
enabled
expres-
sions
with
new
v
ariable
sym
b
ols.
That
is,
for
eac
h
sub
expression
of
e
of
the
form
enabled
A
and
eac
h
declared
v
ariable
q
of
mo
dule
N
,
w
e
replace
ev
ery
primed
o
ccurrence
of
q
in
A
with
a
new
sym
b
ol,
whic
h
w
e
write
$q
,
that
do
es
not
app
ear
in
A.
This
new
sym
b
ol
is
considered
to
b
e
b
ound
b
y
the
enabled
op
erator.
F
or
example,
the
mo
dule

336
CHAPTER
17.
THE
MEANING
OF
A
MODULE
module
N
v
ariable
u
G
(v
;
A)

=
enabled
(A
_
(fu
;
v
g
0
=
fu
;
v
g))
H

=
(u
0
=
u
)
^
G
(u
;
u
0
6=
u
)
has
as
its
global
denitions
the
set
f
G

=
v
;
A
:
enabled
(A
_
(fu
;
v
g
0
=
fu
;
v
g));
H

=
(u
0
=
u
)
^
enabled
((u
0
6=
u
)
_
(fu
;
u
g
0
=
fu
;
u
g))
g
The
statemen
t
I

=
inst
ance
N
with
u
 
x
adds
the
follo
wing
denitions
to
the
curren
t
mo
dule:
I
!
G

=
v
;
A
:
enabled
(A
_
(f$u
;
v
g
0
=
fx
;
v
g))
I
!
H

=
(x
0
=
x
)
^
enabled
(($u
0
6=
x
)
_
(f$u
;
$u
g
0
=
fx
;
x
g))
Observ
e
that
I
!
H
do
es
not
equal
(x
0
=
x
)
^
I
!
G
(x
;
x
0
6=
x
),
ev
en
though
H
equals
(u
0
=
u
)
^
G
(u
;
u
0
6=
u
)
in
mo
dule
N
and
the
instan
tiation
substitutes
x
for
u
.
As
another
example,
consider
the
mo
dule
module
N
v
ariables
u
;
v
A

=
(u
0
=
u
)
^
(v
0
6=
v
)
B
(d
)

=
enabled
d
C

=
B
(A)
The
instan
tiation
I

=
inst
ance
N
with
u
 
x
;
v
 
x
adds
the
follo
wing
denitions
to
the
curren
t
mo
dule:
I
!
A

=
(x
0
=
x
)
^
(x
0
6=
x
)
I
!
B

=
d
:
enabled
d
I
!
C

=
enabled
(($u
0
=
x
)
^
($v
0
6=
x
))
Observ
e
that
I
!
C
is
not
equiv
alen
t
to
I
!
B
(I
!
A).
In
fact,
I
!
C

tr
ue
and
I
!
B
(I
!
A)

f
alse.
W
e
sa
y
that
instan
tiation
distributes
o
v
er
an
op
erator
Op
if
Op
(e
1
;
:
:
:
;
e
n
)
=
Op
(e
1
;
:
:
:
;
e
n
)

17.8.
THE
SEMANTICS
OF
INST
ANTIA
TION
337
for
an
y
expressions
e
i
,
where
the
o
v
erlining
op
erator
(
)
denotes
some
arbitrary
instan
tiation.
Instan
tiation
distributes
o
v
er
all
constan
t
op
erators|for
exam-
ple,
+,
,
and
9
.
9
Instan
tiation
also
distributes
o
v
er
most
of
the
nonconstan
t
op
erators
of
TLA
+
,
lik
e
priming
(
0
)
and
2.
If
an
op
erator
Op
implicitly
binds
some
iden
tiers
in
its
argumen
ts,
then
instan
tiation
w
ould
not
preserv
e
v
alidit
y
if
it
distributed
o
v
er
Op
.
Our
rules
for
instan
tiating
in
an
enabled
expression
imply
that
instan
tiation
do
es
not
distribute
o
v
er
enabled.
It
also
do
es
not
distribute
o
v
er
an
y
op
erator
dened
in
terms
of
enabled|in
particular,
the
built-in
op
erators
WF
and
SF.
There
are
t
w
o
other
TLA
+
op
erators
that
implicitly
bind
iden
tiers:
the
action
comp
osition
op
erator
\",
dened
in
Section
16.2.3,
and
the
temp
oral
op
erator
+
 .
,
in
tro
duced
in
Section
10.7.
The
rule
for
instan
tiating
an
expression
A

B
is
similar
to
that
for
enabled
A|namely
,
b
ound
o
ccurrences
of
v
ariables
are
replaced
b
y
a
new
sym
b
ol.
In
the
expression
A

B
,
primed
o
ccurrences
of
v
ariables
in
A
and
unprimed
o
ccurrences
in
B
are
b
ound.
W
e
handle
a
form
ula
of
the
form
F
+
 .
G
b
y
replacing
it
with
an
equiv
alen
t
form
ula
in
whic
h
the
quan
tication
is
made
explicit.
10
Most
readers
w
on't
care,
but
here's
ho
w
that
equiv
alen
t
form
ula
is
constructed.
Let
x
b
e
the
tuple
h
x
1
;
:
:
:
;
x
n
i
of
all
declared
v
ariables;
let
b
,
c
x
1
,
.
.
.
,
c
x
n
b
e
sym
b
ols
distinct
from
the
x
i
and
from
an
y
b
ound
iden
tiers
in
F
or
G
;
and
let
b
e
b
e
the
expression
obtained
from
an
expression
e
b
y
substituting
the
v
ariables
c
x
i
for
the
corresp
onding
v
ariables
x
i
.
Then
F
+
 .
G
is
equiv
alen
t
to
8
8
8
8
8
8
b
:
(
^
(b
2
boolean)
^
2[b
0
=
f
alse
]
b
^
9
9
9
9
9
9
c
x
1
;
:
:
:
;
c
x
n
:
b
F
^
2(b
)
(x
=
b
x))
)
)
9
9
9
9
9
9
c
x
1
;
:
:
:
;
c
x
n
:
b
G
^
(x
=
b
x)
^
2[b
)
(x
0
=
b
x
0
)]
h
b
;x;
b
x
i
(17.8)
Here's
a
complete
statemen
t
of
the
rules
for
computing
e
,
for
an
arbitrary
expression
e
.
1.
Remo
v
e
all
+
 .
op
erators
b
y
replacing
eac
h
subform
ula
of
the
form
F
+
 .
G
with
the
equiv
alen
t
form
ula
(17.8).
2.
Recursiv
ely
p
erform
the
follo
wing
replacemen
ts,
starting
from
the
inner-
most
sub
expressions
of
e
,
for
eac
h
declared
v
ariable
x
of
N
:

F
or
eac
h
sub
expression
of
the
form
enabled
A,
replace
eac
h
primed
o
ccurrence
of
x
in
A
b
y
a
new
sym
b
ol
$x
that
is
dieren
t
from
an
y
iden
tier
and
from
an
y
other
sym
b
ol
that
o
ccurs
in
A.
9
Recall
the
explanation
on
pages
320{321
of
ho
w
w
e
consider
9
to
b
e
a
second-order
op
erator.
Instan
tiation
distributes
o
v
er
9
b
ecause
TLA
+
do
es
not
p
ermit
v
ariable
capture
when
substituting
in

expressions.
10
Replacing
enabled
and
\"
expressions
b
y
equiv
alen
t
form
ulas
with
explicit
quan
tiers
b
efore
substituting
w
ould
result
in
some
surprising
instan
tiations.
F
or
example,
if
N
con-
tains
the
denition
E
(A)

=
enabled
A,
then
I

=
inst
ance
N
w
ould
eectiv
ely
obtain
the
denition
I
!E
(A)

=
A.

338
CHAPTER
17.
THE
MEANING
OF
A
MODULE

F
or
eac
h
sub
expression
of
the
form
B

C
,
replace
eac
h
primed
o
ccur-
rence
of
x
in
B
and
eac
h
unprimed
o
ccurrence
of
x
in
C
b
y
a
new
sym
b
ol
$x
that
is
dieren
t
from
an
y
iden
tier
and
from
an
y
other
sym
b
ol
that
o
ccurs
in
B
or
C
.
F
or
example,
applying
these
rules
to
the
inner
enabled
expression
and
to
the
\"
expression
con
v
erts
enabled
((enabled
(x
0
=
x
))
0
^
((y
0
=
x
)

(x
0
=
y
)))
to
enabled
((enabled
($x
0
=
x
))
0
^
(($y
0
=
x
)

(x
0
=
$y
)))
and
applying
them
again
to
the
outer
enabled
expression
yields
enabled
((enabled
($x
0
=
$xx
))
0
^
(($y
0
=
x
)

($xx
0
=
$y
)))
where
$xx
is
some
new
sym
b
ol
dieren
t
from
x
,
$x
,
and
$y
.
3.
Replace
eac
h
o
ccurrence
of
q
i
with
e
i
,
for
all
i
in
1
:
:
n
.

Chapter
18
The
Standard
Mo
dules
Sev
eral
standard
mo
dules
are
pro
vided
for
use
in
TLA
+
sp
ecications.
Some
of
the
denitions
they
con
tain
are
subtle|for
example,
the
denitions
of
the
set
of
real
n
um
b
ers
and
its
op
erators.
Others,
suc
h
as
the
denition
of
1
:
:
n
,
are
ob
vious.
There
are
t
w
o
reasons
to
use
standard
mo
dules.
First,
sp
ecications
are
easier
to
read
when
they
use
basic
op
erators
that
w
e're
already
familiar
with.
Second,
to
ols
can
ha
v
e
built-in
kno
wledge
of
standard
op
erators.
F
or
example,
the
TLC
mo
del
c
hec
k
er
(Chapter
14)
has
ecien
t
implemen
tations
of
some
standard
mo
dules;
and
a
theorem-pro
v
er
migh
t
implemen
t
sp
ecial
decision
pro
cedures
for
some
standard
op
erators.
The
standard
mo
dules
of
TLA
+
are
describ
ed
here,
except
for
the
R
e
alTime
mo
dule,
whic
h
app
ears
in
Chapter
9.
18.1
Mo
dule
Se
quenc
es
The
Se
quenc
es
mo
dule
w
as
in
tro
duced
in
Section
4.1
on
page
35.
Most
of
the
op
erators
it
denes
ha
v
e
already
b
een
explained.
The
exceptions
are
SubSe
q
(s
;
m
;
n
)
The
subsequence
h
s
[m
];
s
[m
+
1];
:
:
:
;
s
[n
]
i
consisting
of
the
m
th
through
n
th
elemen
ts
of
s
.
It
is
undened
if
m
<
1
or
n
>
L
en
(s
),
except
that
it
equals
the
empt
y
sequence
if
m
>
n
.
Sele
ctSe
q
(s
;
T
est
)
The
subsequence
of
s
consisting
of
the
elemen
ts
s
[i
]
suc
h
that
T
est
(s
[i
])
equals
tr
ue
.
F
or
example,
PosSubSe
q
(s
)

=
let
IsPos
(n
)

=
n
>
0
in
Sele
ctSe
q
(s
;
IsPos
)
denes
PosSubSe
q
(h
0;
3;
 2;
5
i)
to
equal
h
3;
5
i.
339

340
CHAPTER
18.
THE
ST
AND
ARD
MODULES
The
Se
quenc
es
mo
dule
uses
op
erators
on
natural
n
um
b
ers,
so
w
e
migh
t
exp
ect
it
to
extend
the
Natur
als
mo
dule.
Ho
w
ev
er,
this
w
ould
mean
that
an
y
mo
dule
that
extends
Se
quenc
es
w
ould
then
also
extend
Natur
als
.
Just
in
case
someone
w
an
ts
to
use
sequences
without
extending
the
Natur
als
mo
dule,
the
Se
quenc
es
mo
dule
con
tains
the
statemen
t
local
inst
ance
Natur
als
This
statemen
t
in
tro
duces
the
denitions
from
the
Natur
als
mo
dule,
just
as
an
ordinary
inst
ance
statemen
t
w
ould,
but
it
do
es
not
exp
ort
those
denitions
to
another
mo
dule
that
extends
or
instan
tiates
the
Se
quenc
es
mo
dule.
The
local
mo
dier
can
also
precede
an
ordinary
denition;
it
has
the
eect
of
making
that
denition
usable
within
the
curren
t
mo
dule,
but
not
in
a
mo
dule
that
extends
or
instan
tiates
it.
(The
local
mo
dier
cannot
b
e
used
with
parameter
declarations.)
Ev
erything
else
that
app
ears
in
the
Se
quenc
es
mo
dule
should
b
e
familiar.
The
mo
dule
is
in
Figure
18.1
on
the
next
page.
18.2
Mo
dule
FiniteSets
As
describ
ed
in
Section
6.1
on
page
66,
the
FiniteSets
mo
dule
denes
the
t
w
o
op
erators
IsFiniteSet
and
Car
dinality
.
The
denition
of
Car
dinality
is
discussed
on
page
70.
The
mo
dule
itself
is
in
Figure
18.2
on
the
next
page.
18.3
Mo
dule
Bags
A
b
ag,
also
called
a
m
ultiset,
is
a
set
that
can
con
tain
m
ultiple
copies
of
the
same
elemen
t.
A
bag
can
ha
v
e
innitely
man
y
elemen
ts,
but
only
nitely
man
y
copies
of
an
y
single
elemen
t.
Bags
are
sometimes
useful
for
represen
ting
data
structures.
F
or
example,
the
state
of
a
net
w
ork
in
whic
h
messages
can
b
e
deliv
ered
in
an
y
order
could
b
e
represen
ted
as
a
bag
of
messages
in
transit.
Multiple
copies
of
an
elemen
t
in
the
bag
represen
t
m
ultiple
copies
of
the
same
message
in
transit.
The
Bags
mo
dule
denes
a
bag
to
b
e
a
function
whose
range
is
a
subset
of
the
p
ositiv
e
in
tegers.
An
elemen
t
e
b
elongs
to
bag
B
i
e
is
in
the
domain
of
B
,
in
whic
h
case
bag
B
con
tains
B
[e
]
copies
of
e
.
The
mo
dule
denes
the
follo
wing
op
erators.
In
our
customary
st
yle,
w
e
lea
v
e
unsp
ecied
the
v
alue
obtained
b
y
applying
an
op
erator
on
bags
to
something
other
than
a
bag.
IsABag
(B
)
T
rue
i
B
is
a
bag.
BagT
oSet
(B
)
The
set
of
elemen
ts
of
whic
h
bag
B
con
tains
at
least
one
cop
y
.

18.3.
MODULE
BA
GS
341
module
Se
quenc
es
Denes
op
erators
on
nite
sequences,
where
a
sequence
of
length
n
is
represen
ted
as
a
function
whose
domain
is
the
set
1
:
:
n
(the
set
f1;
2;
:
:
:
;
n
g).
This
is
also
ho
w
TLA
+
denes
an
n
-tuple,
so
tuples
are
sequences.
local
inst
ance
Natur
als
Imp
orts
the
denitions
from
Natur
als
,
but
do
esn't
exp
ort
them.
Se
q
(S
)

=
union
f[1
:
:
n
!
S
]
:
n
2
Nat
g
The
set
of
all
nite
sequences
of
elemen
ts
in
S
.
The
length
of
sequence
s
.
L
en
(s
)

=
choose
n
2
Nat
:
domain
s
=
1
:
:
n
s

t

=
The
sequence
obtained
b
y
concatenating
sequences
s
and
t
.
[i
2
1
:
:
(L
en
(s
)
+
L
en
(t
))
7!
if
i

L
en
(s
)
then
s
[i
]
else
t
[i
 L
en
(s
)]]
App
end
(s
;
e
)

=
s

h
e
i
The
sequence
obtained
b
y
app
ending
elemen
t
e
to
the
end
of
sequence
s
.
He
ad
(s
)

=
s
[1]
T
ail
(s
)

=
[i
2
1
:
:
(L
en
(s
)
 1)
7!
s
[i
+
1]]
The
usual
head
(rst)
and
tail
(rest)
op
erators.
SubSe
q
(s
;
m
;
n
)

=
[i
2
1
:
:
(1
+
n
 m
)
7!
s
[i
+
m
 1]]
The
sequence
h
s
[m
];
s
[m
+
1];
:
:
:
;
s
[n
]
i.
Sele
ctSe
q
(s
;
T
est
(
))

=
The
subsequence
of
s
consisting
of
all
elemen
ts
s
[i
]
suc
h
that
T
est
(s
[i
])
is
true.
let
F
[i
2
0
:
:
L
en
(s
)]

=
F
[i
]
equals
Sele
ctSe
q
(SubSe
q
(s
;
1;
i
);
T
est
).
if
i
=
0
then
h
i
else
if
T
est
(s
[i
])
then
App
end
(F
[i
 1];
s
[i
])
else
F
[i
 1]
in
F
[L
en
(s
)]
Figure
18.1:
The
standard
Se
quenc
es
mo
dule.
module
FiniteSets
local
inst
ance
Natur
als
Imp
orts
the
denitions
from
Natur
als
and
Se
quenc
es
,
but
do
esn't
exp
ort
them.
local
inst
ance
Se
quenc
es
IsFiniteSet
(S
)

=
A
set
is
nite
i
there
is
a
nite
sequence
con
taining
all
its
elemen
ts.
9
se
q
2
Se
q
(S
)
:
8
s
2
S
:
9
n
2
1
:
:
L
en
(se
q
)
:
se
q
[n
]
=
s
Car
dinality
(S
)

=
Cardinalit
y
is
dened
only
for
nite
sets.
let
CS
[T
2
subset
S
]

=
if
T
=
fg
then
0
else
1
+
CS
[T
n
fchoose
x
:
x
2
T
g]
in
CS
[S
]
Figure
18.2:
The
standard
FiniteSets
mo
dule.

342
CHAPTER
18.
THE
ST
AND
ARD
MODULES
SetT
oBag
(S
)
The
bag
that
con
tains
one
cop
y
of
ev
ery
elemen
t
in
the
set
S
.
BagIn
(e
;
B
)
T
rue
i
bag
B
con
tains
at
least
one
cop
y
of
e
.
BagIn
is
the
2
op
erator
for
bags.
EmptyBag
The
bag
con
taining
no
elemen
ts.
CopiesIn
(e
;
B
)
The
n
um
b
er
of
copies
of
e
in
bag
B
;
it
is
equal
to
0
i
BagIn
(e
;
B
)
is
false.
B
1

B
2
The
union
of
bags
B
1
and
B
2.
The
op
erator

satises
CopiesIn
(e
;
B
1

B
2)
=
CopiesIn
(e
;
B
1)
+
CopiesIn
(e
;
B
2)
for
an
y
e
and
an
y
bags
B
1
and
B
2.
B
1
	
B
2
The
bag
B
1
with
the
elemen
ts
of
B
2
remo
v
ed|that
is,
with
one
cop
y
of
an
elemen
t
remo
v
ed
from
B
1
for
eac
h
cop
y
of
the
same
elemen
t
in
B
2.
If
B
2
has
at
least
as
man
y
copies
of
e
as
B
1,
then
B
1
	
B
2
has
no
copies
of
e
.
BagUnion
(S
)
The
bag
union
of
all
elemen
ts
of
the
set
S
of
bags.
F
or
example,
BagUnion
(fB
1;
B
2;
B
3g)
equals
B
1

B
2

B
3.
BagUnion
is
the
analog
of
union
for
bags.
B
1
v
B
2
T
rue
i,
for
all
e
,
bag
B
2
has
at
least
as
man
y
copies
of
e
as
bag
B
1
do
es.
Th
us,
v
is
the
analog
for
bags
of
.
SubBag
(B
)
The
set
of
all
subbags
of
bag
B
.
SubBag
is
the
analog
of
subset
for
bags.
BagOfA
l
l
(F
;
B
)
The
bag
analog
of
the
construct
fF
(x
)
:
x
2
B
g.
It
is
the
bag
that
con
tains,
for
eac
h
elemen
t
e
of
bag
B
,
one
cop
y
of
F
(e
)
for
ev
ery
cop
y
of
e
in
B
.
This
denes
a
bag
i,
for
an
y
v
alue
v
,
the
set
of
e
in
B
suc
h
that
F
(e
)
=
v
is
nite.
BagCar
dinality
(B
)
If
B
is
a
nite
bag
(one
suc
h
that
BagT
oSet
(B
)
is
a
nite
set),
then
this
is
its
cardinalit
y|the
total
n
um
b
er
of
copies
of
elemen
ts
in
B
.
Its
v
alue
is
unsp
ecied
if
B
is
not
a
nite
bag.
The
mo
dule
app
ears
in
Figure
18.3
on
the
next
page.
Note
the
lo
cal
denition
of
Sum
,
whic
h
mak
es
Sum
dened
within
the
Bags
mo
dule
but
not
in
an
y
mo
dule
that
extends
or
instan
tiates
it.

18.3.
MODULE
BA
GS
343
module
Bags
local
inst
ance
Natur
als
Imp
ort
denitions
from
Natur
als
,
but
don't
exp
ort
them.
IsABag
(B
)

=
B
2
[domain
B
!
fn
2
Nat
:
n
>
0g]
T
rue
i
B
is
a
bag.
BagT
oSet
(B
)

=
domain
B
The
set
of
elemen
ts
at
least
one
cop
y
of
whic
h
is
in
B
.
SetT
oBag
(S
)

=
[e
2
S
7!
1]
The
bag
that
con
tains
one
cop
y
of
ev
ery
elemen
t
of
the
set
S
.
BagIn
(e
;
B
)

=
e
2
BagT
oSet
(B
)
The
2
op
erator
for
bags.
EmptyBag

=
SetT
oBag
(fg)
CopiesIn
(e
;
B
)

=
if
BagIn
(e
;
B
)
then
B
[e
]
else
0
The
n
um
b
er
of
copies
of
e
in
B
.
B
1

B
2

=
The
union
of
bags
B
1
and
B
2.
[e
2
(domain
B
1)
[
(domain
B
2)
7!
CopiesIn
(e
;
B
1)
+
CopiesIn
(e
;
B
2)]
B
1
	
B
2

=
The
bag
B
1
with
the
elemen
ts
of
B
2
remo
v
ed.
let
B

=
[e
2
domain
B
1
7!
CopiesIn
(e
;
B
1)
 CopiesIn
(e
;
B
2)]
in
[e
2
fd
2
domain
B
:
B
[d
]
>
0g
7!
B
[e
]]
local
Sum
(f
)

=
The
sum
of
f
[x]
for
all
x
in
domain
f
.
let
DSum
[S
2
subset
domain
f
]

=
let
elt

=
choose
e
2
S
:
tr
ue
in
if
S
=
fg
then
0
else
f
[elt
]
+
DSum
[S
n
felt
g]
in
DSum
[domain
f
]
BagUnion
(S
)

=
The
bag
union
of
all
elemen
ts
of
the
set
S
of
bags.
[e
2
union
fBagT
oSet
(B
)
:
B
2
S
g
7!
Sum
([B
2
S
7!
CopiesIn
(e
;
B
)])]
B
1
v
B
2

=
^
(domain
B
1)

(domain
B
2)
^
8
e
2
domain
B
1
:
B
1[e
]

B
2[e
]
The
subset
op
erator
for
bags.
SubBag
(B
)

=
The
set
of
all
subbags
of
bag
B
.
let
A
l
lBagsOfSubset

=
The
set
of
bags
SB
suc
h
that
BagT
oSet
(SB
)

BagT
oSet
(B
).
union
f[SB
!
fn
2
Nat
:
n
>
0g]
:
SB
2
subset
BagT
oSet
(B
)g
in
fSB
2
A
l
lBagsOfSubset
:
8
e
2
domain
SB
:
SB
[e
]

B
[e
]g
BagOfA
l
l
(F
(
);
B
)

=
The
bag
analog
of
the
set
fF
(x
)
:
x
2
B
g
for
a
set
B
.
[e
2
fF
(d
)
:
d
2
BagT
oSet
(B
)g
7!
Sum
([d
2
BagT
oSet
(B
)
7!
if
F
(d
)
=
e
then
B
[d
]
else
0])]
BagCar
dinality
(B
)

=
Sum
(B
)
The
total
n
um
b
er
of
copies
of
elemen
ts
in
bag
B
.
Figure
18.3:
The
standard
Bags
mo
dule.

344
CHAPTER
18.
THE
ST
AND
ARD
MODULES
18.4
The
Num
b
ers
Mo
dules
The
usual
sets
of
n
um
b
ers
and
op
erators
on
them
are
dened
in
the
three
mo
d-
ules
Natur
als
,
Inte
gers
,
and
R
e
als
.
These
mo
dules
are
tric
ky
b
ecause
their
denitions
m
ust
b
e
consisten
t.
A
mo
dule
M
migh
t
extend
b
oth
the
Natur
als
mo
dule
and
another
mo
dule
that
extends
the
R
e
als
mo
dule.
The
mo
dule
M
thereb
y
obtains
t
w
o
denitions
of
an
op
erator
suc
h
as
+,
one
from
Natur
als
and
one
from
R
e
als
.
These
t
w
o
denitions
of
+
m
ust
b
e
the
same.
T
o
mak
e
them
the
same,
w
e
ha
v
e
them
b
oth
come
from
the
denition
of
+
in
a
mo
dule
Pr
otoR
e
als
,
whic
h
is
lo
cally
instan
tiated
b
y
b
oth
Natur
als
and
R
e
als
.
The
Natur
als
mo
dule
denes
the
follo
wing
op
erators:
+

<

N
at

in
teger
division
 binary
min
us
^
exp
onen
tiation
>

:
:
%
mo
dulus
Except
for
,
these
op
erators
are
all
either
standard
or
explained
in
Chapter
2.
In
teger
division
()
and
mo
dulus
(%
)
are
dened
so
that
the
follo
wing
t
w
o
conditions
hold,
for
an
y
in
teger
a
and
p
ositiv
e
in
teger
b
:
a
%
b
2
0
:
:
(b
 1)
a
=
b

(a

b
)
+
(a
%
b
)
The
Inte
gers
mo
dule
extends
the
Natur
als
mo
dule
and
also
denes
the
set
Int
of
in
tegers
and
unary
min
us
( ).
The
R
e
als
mo
dule
extends
Inte
gers
and
in
tro-
duces
the
set
R
e
al
of
real
n
um
b
ers
and
ordinary
division
(=).
In
mathematics,
(unlik
e
programming
languages),
in
tegers
are
real
n
um
b
ers.
Hence,
Nat
is
a
subset
of
Int
,
whic
h
is
a
subset
of
R
e
al
.
The
R
e
als
mo
dule
also
denes
the
sp
ecial
v
alue
Innity
.
Innity
,
whic
h
represen
ts
a
mathematical
1,
satises
the
follo
wing
t
w
o
prop
erties:
8
r
2
R
e
al
:
 Innity
<
r
<
Innity
 ( Innity
)
=
Innity
The
precise
details
of
the
n
um
b
er
mo
dules
are
of
no
practical
imp
ortance.
When
writing
sp
ecications,
y
ou
can
just
assume
that
the
op
erators
they
dene
ha
v
e
their
usual
meanings.
If
y
ou
w
an
t
to
pro
v
e
something
ab
out
a
sp
ecication,
y
ou
can
reason
ab
out
n
um
b
ers
ho
w
ev
er
y
ou
w
an
t.
T
o
ols
lik
e
mo
del
c
hec
k
ers
and
theorem
pro
v
ers
that
care
ab
out
these
op
erators
will
ha
v
e
their
o
wn
w
a
ys
of
handling
them.
The
mo
dules
are
giv
en
here
mainly
for
completeness.
They
can
also
serv
e
as
mo
dels
if
y
ou
w
an
t
to
dene
other
basic
mathematical
structures.
Ho
w
ev
er,
suc
h
denitions
are
rarely
necessary
for
writing
sp
ecications.
The
set
Nat
of
natural
n
um
b
ers,
with
its
zero
elemen
t
and
successor
function,
is
dened
in
the
Pe
ano
mo
dule,
whic
h
app
ears
in
Figure
18.4
on
the
next
page.
It
simply
denes
the
naturals
to
b
e
a
set
satisfying
P
eano's
axioms.
This
denition
P
eano's
axioms
are
discussed
in
man
y
b
o
oks
on
the
foundations
of
mathematics.
is
separated
in
to
its
o
wn
mo
dule
for
the
follo
wing
reason.
As
explained
in
Section
16.1.9
(page
306)
and
Section
16.1.10
(page
307),
the
meanings
of
tuples
and
strings
are
dened
in
terms
of
the
natural
n
um
b
ers.
The
Pe
ano
mo
dule,

18.4.
THE
NUMBERS
MODULES
345
module
Pe
ano
This
mo
dule
denes
Nat
to
b
e
an
arbitrary
set
satisfying
P
eano's
axioms
with
zero
elemen
t
Zer
o
and
successor
function
Suc
c
.
It
do
es
not
use
strings
or
tuples,
whic
h
in
TLA
+
are
dened
in
terms
of
natural
n
um
b
ers.
Pe
anoAxioms
(N
;
Z
;
Sc
)

=
Asserts
that
N
satises
P
eano's
axioms
with
zero
elemen
t
Z
and
successor
function
Sc
.
^
Z
2
N
^
Sc
2
[N
!
N
]
^
8
n
2
N
:
(9
m
2
N
:
n
=
Sc
[m
])

(n
6=
Z
)
^
8
S
2
subset
N
:
(Z
2
S
)
^
(8
n
2
S
:
Sc
[n
]
2
S
)
)
(S
=
N
)
assume
9
N
;
Z
;
Sc
:
Pe
anoAxioms
(N
;
Z
;
Sc
)
Asserts
the
existence
of
a
set
satisfying
P
eano's
axioms.
Suc
c

=
choose
Sc
:
9
N
;
Z
:
Pe
anoAxioms
(N
;
Z
;
Sc
)
Nat

=
domain
Suc
c
Zer
o

=
choose
Z
:
Pe
anoAxioms
(Nat
;
Z
;
Suc
c
)
Figure
18.4:
The
Pe
ano
mo
dule.
whic
h
denes
the
natural
n
um
b
ers,
do
es
not
use
tuples
or
strings.
Hence,
there
is
no
circularit
y
.
As
explained
in
Section
16.1.11
on
page
308,
n
um
b
ers
lik
e
42
are
dened
in
TLA
+
so
that
0
equals
Zer
o
and
1
equals
Suc
c
[Zer
o
],
where
Zer
o
and
Suc
c
are
dened
in
the
Pe
ano
mo
dule.
W
e
could
therefore
replace
Zer
o
b
y
0
and
Suc
c
[Zer
o
]
b
y
1
in
the
Pr
otoR
e
als
mo
dule.
But
doing
so
w
ould
obscure
ho
w
the
denition
of
the
reals
dep
ends
on
the
denition
of
the
natural
n
um
b
ers
in
the
Pe
ano
mo
dule.
Most
of
the
denitions
in
mo
dules
Natur
als
,
Inte
gers
,
and
R
e
als
come
from
mo
dule
Pr
otoR
e
als
in
Figure
18.5
on
the
follo
wing
t
w
o
pages.
The
denition
of
the
real
n
um
b
ers
in
mo
dule
Pr
otoR
e
als
uses
the
w
ell-kno
wn
mathematical
result
that
the
reals
are
uniquely
dened,
up
to
isomorphism,
as
an
ordered
eld
in
whic
h
ev
ery
subset
b
ounded
from
ab
o
v
e
has
a
least
upp
er
b
ound.
The
details
will
b
e
of
in
terest
only
to
mathematically
sophisticated
readers
who
are
curious
ab
out
the
formalization
of
ordinary
mathematics.
I
hop
e
that
those
readers
will
b
e
as
impressed
as
I
am
b
y
ho
w
easy
this
formalization
is|once
y
ou
understand
the
mathematics.
Giv
en
the
Pr
otoR
e
als
mo
dule,
the
rest
is
simple.
The
Natur
als
,
Inte
gers
,
and
R
e
als
mo
dules
app
ear
in
Figures
18.6{18.8
on
page
348.
P
erhaps
the
most
striking
thing
ab
out
them
is
the
ugliness
of
an
op
erator
lik
e
R
!
+,
whic
h
is
the
v
ersion
of
+
obtained
b
y
instan
tiating
Pr
otoR
e
als
under
the
name
R
.
It
demonstrates
that
y
ou
should
not
dene
inx
op
erators
in
a
mo
dule
that
ma
y
b
e
used
with
a
named
instan
tiation.

346
CHAPTER
18.
THE
ST
AND
ARD
MODULES
module
Pr
otoR
e
als
This
mo
dule
pro
vides
the
basic
denitions
for
the
Natur
als
,
Inte
gers
,
and
R
e
als
mo
dule.
It
do
es
this
b
y
dening
the
real
n
um
b
ers
to
b
e
a
complete
ordered
eld
con
taining
the
naturals.
extends
Pe
ano
IsMo
delOfR
e
als
(R
;
Plus
;
Times
;
L
e
q
)

=
Asserts
that
R
satises
the
prop
erties
of
the
reals
with
a
+
b
=
Plus
[a
;
b
],
a

b
=
Times
[a
;
b
],
and
(a

b
)
=
(h
a
;
b
i
2
L
e
q
).
(W
e
will
ha
v
e
to
quan
tify
o
v
er
the
argumen
ts,
so
they
m
ust
b
e
v
alues,
not
op
erators.)
let
IsA
b
elianGr
oup
(G
;
Id
;
+
)

=
Asserts
that
G
is
an
Ab
elian
group
with
iden
tit
y
Id
and
group
op
eration
+.
^
Id
2
G
^
8
a
;
b
2
G
:
a
+
b
2
G
^
8
a
2
G
:
Id
+
a
=
a
^
8
a
;
b
;
c
2
G
:
(a
+
b
)
+
c
=
a
+
(b
+
c
)
^
8
a
2
G
:
9
minusa
2
G
:
a
+
minusa
=
Id
^
8
a
;
b
2
G
:
a
+
b
=
b
+
a
a
+
b

=
Plus
[a
;
b
]
a

b

=
Times
[a
;
b
]
a

b

=
h
a
;
b
i
2
L
e
q
in
^
Nat

R
^
8
n
2
Nat
:
Suc
c
[n
]
=
n
+
Suc
c
[Zer
o
]
^
IsA
b
elianGr
oup
(R
;
Zer
o
;
+)
^
IsA
b
elianGr
oup
(R
n
fZer
o
g;
Suc
c
[Zer
o
];
)
^
8
a
;
b
;
c
2
R
:
a

(b
+
c
)
=
(a

b
)
+
(a

c
)
^
8
a
;
b
2
R
:
^
(a

b
)
_
(b

a
)
^
(a

b
)
^
(b

a
)

(a
=
b
)
^
8
a
;
b
;
c
2
R
:
^
(a

b
)
^
(b

c
)
)
(a

c
)
^
(a

b
)
)
^
(a
+
c
)

(b
+
c
)
^
(Zer
o

c
)
)
(a

c
)

(b

c
)
^
8
S
2
subset
R
:
let
SBound
(a
)

=
8
s
2
S
:
s

a
in
(9
a
2
R
:
SBound
(a
))
)
(9
sup
2
R
:
^
SBound
(sup
)
^
8
a
2
R
:
SBound
(a
)
)
(sup

a
))
The
rst
t
w
o
conjuncts
assert
that
Nat
is
em
b
edded
in
R
.
The
next
three
conjuncts
assert
that
R
is
a
eld.
The
next
t
w
o
conjuncts
assert
that
R
is
an
ordered
eld.
The
last
conjunct
asserts
that
ev
ery
subset
S
of
R
b
ounded
from
ab
o
v
e
has
a
least
upp
er
b
ound
sup
.
theorem
9
R
;
Plus
;
Times
;
L
e
q
:
IsMo
delOfR
e
als
(R
;
Plus
;
Times
;
L
e
q
)
RM

=
choose
RM
:
IsMo
delOfR
e
als
(RM
:R
;
RM
:Plus
;
RM
:Times
;
RM
:L
e
q
)
R
e
al

=
RM
:R
Figure
18.5a:
The
Pr
otoR
e
als
mo
dule
(b
eginning).

18.4.
THE
NUMBERS
MODULES
347
W
e
dene
Innity
,
,
and
 so
 Innity

r

Innity
,
for
an
y
r
2
R
e
al
,
and
 ( Innity
)
=
Innity
.
Innity

=
choose
x
:
x
=
2
R
e
al
MinusInnity

=
choose
x
:
x
=
2
R
e
al
[
fInnity
g
Innity
and
MinusInnity
(whic
h
will
equal
 Innity
)
are
c
hosen
to
b
e
arbitrary
v
alues
not
in
R
e
al
.
a
+
b

=
RM
:Plus
[a
;
b
]
a

b

=
RM
:Times
[a
;
b
]
a

b

=
case
(a
2
R
e
al
)
^
(b
2
R
e
al
)
!
h
a
;
b
i
2
RM
:L
e
q
2
(a
=
Innity
)
^
(b
2
R
e
al
[
fMinusInnity
g)
!
f
alse
2
(a
2
R
e
al
[
fMinusInnity
g)
^
(b
=
Innity
)
!
tr
ue
2
a
=
b
!
tr
ue
a
 b

=
case
(a
2
R
e
al
)
^
(b
2
R
e
al
)
!
choose
c
2
R
e
al
:
c
+
b
=
a
2
(a
2
R
e
al
)
^
(b
=
Innity
)
!
MinusInnity
2
(a
2
R
e
al
)
^
(b
=
MinusInnity
)
!
Innity
a
=b

=
choose
c
2
R
e
al
:
a
=
b

c
Int

=
Nat
[
fZer
o
 n
:
n
2
Nat
g
W
e
dene
a
b
(exp
onen
tiation)
for
a
>
0,
or
b
>
0,
or
a
6=
0
and
b
2
Int
,
b
y
the
four
axioms
a
1
=
a
a
m
+n
=
a
m

a
n
if
a
6=
0
and
m
;
n
2
Int
0
b
=
0
if
b
>
0
a
b
c
=
(a
b
)
c
if
a
>
0
plus
the
con
tin
uit
y
condition
that
0
<
a
and
0
<
b

c
imply
a
b

a
c
.
a
b

=
let
RPos

=
fr
2
R
e
al
n
fZer
o
g
:
Zer
o

r
g
exp

=
choose
f
2
[(RPos

R
e
al
)
[
(R
e
al

RPos
)
[
((R
e
al
n
fZer
o
g)

Int
)
!
R
e
al
]
:
^
8
r
2
R
e
al
:
^
f
[r
;
Suc
c
[Zer
o
]]
=
r
^
8
m
;
n
2
Int
:
(r
6=
Zer
o
)
)
(f
[r
;
m
+
n
]
=
f
[r
;
m
]

f
[r
;
n
])
^
8
r
2
RPos
:
^
f
[Zer
o
;
r
]
=
Zer
o
^
8
s
;
t
2
R
e
al
:
f
[r
;
s

t
]
=
f
[f
[r
;
s
];
t
]
^
8
s
;
t
2
RPos
:
(s

t
)
)
(f
[r
;
s
]

f
[r
;
t
])
in
exp
[a
;
b
]
Figure
18.5b:
The
Pr
otoR
e
als
mo
dule
(end).

348
CHAPTER
18.
THE
ST
AND
ARD
MODULES
module
Natur
als
local
R

=
inst
ance
Pr
otoR
e
als
Nat

=
R
!
Nat
a
+
b

=
a
R
!+
b
R
!
+
is
the
op
erator
+
dened
in
mo
dule
Pr
otoR
e
als
.
a
 b

=
a
R
! b
a

b

=
a
R
!
b
a
b

=
a
R
!
^
b
a
b
is
written
in
asci
i
as
a^b.
a

b

=
a
R
!

b
a

b

=
b

a
a
<
b

=
(a

b
)
^
(a
6=
b
)
a
>
b

=
b
<
a
a
:
:
b

=
fi
2
R
!
Int
:
(a

i
)
^
(i

b
)g
a

b

=
choose
n
2
R
!
Int
:
9
r
2
0
:
:
(b
 1)
:
a
=
b

n
+
r
W
e
dene

and
%
so
that
a
=
b

(a

b
)
+
(a
%
b
)
for
all
in
tegers
a
and
b
with
b
>
0.
a
%
b

=
a
 b

(a

b
)
Figure
18.6:
The
standard
Natur
als
mo
dule.
module
Inte
gers
extends
Natur
als
The
Natur
als
mo
dule
already
denes
op
erators
lik
e
+
to
w
ork
on
all
real
n
um
b
ers.
local
R

=
inst
ance
Pr
otoR
e
als
Int

=
R
!
Int
 :
a

=
0
 a
Unary
 is
written
 :
when
b
eing
dened
or
used
as
an
op
erator
argumen
t.
Figure
18.7:
The
standard
Inte
gers
mo
dule.
module
R
e
als
extends
Inte
gers
The
Inte
gers
mo
dule
already
denes
op
erators
lik
e
+
to
w
ork
on
all
real
n
um
b
ers.
local
R

=
inst
ance
Pr
otoR
e
als
R
e
al

=
R
!
R
e
al
a
=b

=
a
R
!
=
b
R
!=
is
the
op
erator
=
dened
in
mo
dule
Pr
otoR
e
als
.
Innity

=
R
!
Innity
Figure
18.8:
The
standard
R
e
als
mo
dule.

Index
0
(prime),
16,
82,
312
0
(prime),
double,
322
`
.
.
.
',
214
`^,
212
`^
.
.
.
^',
214,
215,
218{220
`~,
212,
218
`~
.
.
.
~',
216,
220
`
.,
212
`
.
.
.
.
.
',
215,
218
"
(double
quote),
216,
307
\
.
.
.
"
(string),
47,
307,
308
^
(exp
onen
tiation),
344
^+
(BNF
op
erator),
181
^*
(BNF
op
erator),
181
j
(BNF
op
erator),
181
7!
(function/record
constructor),
29,
49,
302,
303
(separator),
20
(end
of
mo
dule),
21
j
=,
88,
315
=
(division),
73,
344
n
(set
dierence),
12,
299,
300
n
(end-of-line
commen
t),
32,
288
(underscore),
46,
285,
318
 (min
us),
289,
344
-
.
,
289
(o
v
erbar),
63,
114,
334,
336,
337
:,
se
e
negation
!
(set
of
functions),
48,
302,
304
!
(step),
16,
312
+
 .
(temp
oral
op
erator),
116,
156,
315,
316,
337

(stuttering
equiv
alen
t),
315,
316
~',
218
;
(leads
to),
91,
314

(in
teger
division),
344
+
(plus),
344
+
(BNF
op
erator),
181
+
(sux
op
erator),
89,
315

(Cartesian
pro
duct),
53,
284,
306,
307
=,
se
e
equalit
y
6=
(inequalit
y),
300
),
se
e
implies
,
se
e
equiv
alence

=
(dened
to
equal),
16,
31
m
=
,
325
1,
se
e
Innity
:
(syn
tax
elemen
t),
284
:
(record
eld),
28,
180,
305
:
:
(in
teger
in
terv
al),
20,
344
.
',
218
,
se
e
comp
osition
of
actions

(m
ultiplication),
344

(BNF
op
erator),
181

(sequence
concatenation),
36,
53

(bag
union),
342
	
(bag
dierence,
342
2
(alw
a
ys),
16,
89{90,
288,
314,
315
2
(case
separator),
285
3
(ev
en
tually),
91,
288,
314
<
(less
than),
344
 
(substitution),
36

(less
than
or
equal),
344

(subset),
12,
299,
300
v
(bag
subset),
342
(
:
:
:
)
(commen
t),
32,
288
f
[e
]
(function
application),
301,
303
[A]
v
(action
op
erator),
17,
285,
312
[h
1
7!
e
1
;
:
:
:
;
h
n
7!
e
n
]
(record
con-
structor),
29,
305
[S
!
T
]
(set
of
functions),
48,
302,
304
349

350
INDEX
[x
2
S
7!
e
]
(function
constructor),
49,
302,
303
[h
1
:
S
1
;
:
:
:
;
h
n
:
S
n
]
(set
of
records),
28,
305,
306
[
[e
]
]
(meaning),
292,
310
h
A
i
v
(action
op
erator),
91,
285,
312
h
e
1
;
:
:
:
;
e
n
i
(tuple),
27,
53,
306
f
g
(empt
y
set),
12,
300
fe
1
;
:
:
:
;
e
n
g
(set),
12,
299,
300
fx
2
S
:
p
g
(set
constructor),
66,
289,
299,
301
fe
:
x
2
S
g
(set
constructor),
66,
289,
299,
301
>
(greater
than),
344

(greater
than
or
equal),
344
^,
se
e
conjunction
\
(set
in
tersection),
12,
299,
300
_,
se
e
disjunction
[
(set
union),
12,
299,
300
:
(in
record
set
constructor),
28
:>
(function
constructor),
249
::=
(BNF
op
erator),
179
!
(in
ex
cept),
29,
49,
302,
304{306
!
(in
op
erator
name),
36,
39,
330,
334
?,
325
$,
335
%
(mo
dulus),
21,
344
&
(BNF
op
erator),
180
\,
314,
316
@
(in
ex
cept),
29,
302,
304
@@
(function
constructor),
249
8
,
se
e
univ
ersal
quan
tication
8
8
8
8
8
8
(temp
oral
univ
ersal
quan
tication),
110,
315
9
,
se
e
existen
tial
quan
tication
9
1
,
94
9
b
eha
vior
,
316
9
state
,
313
9
9
9
9
9
9
,
se
e
hiding
v
ariables

con
v
ersion,
319

reduction,
319
",
Hilb
ert's,
73,
296
2
(syn
tax
elemen
t),
284
in
function
expression,
49
2
(set
mem
b
ership),
11,
299
=
2
(not
elemen
t
of
),
47,
299,
300

expression,
49,
319
C
-basic,
325

expression,
legal,
327

expression,
meaning
of,
325{327

parameter,
319
0
(zero),
345
0-tuple,
37,
306
1
(one),
345
1-tuple,
306
Abadi,
Mart

n,
xvii
ABCorr
e
ctness
mo
dule,
228,
229
abstraction,
81
abstraction,
c
ho
osing
an,
24
abstraction,
lev
el
of,
76
action,
16,
312
as
temp
oral
form
ula,
89
comp
osition,
se
e
comp
osition
of
ac-
tions
constrain
t,
241
execution,
16
form
ula,
simple,
236
op
erator,
269,
312{314
action
parameter,
46
action,
next-state,
se
e
next-state
ac-
tion
ACTION-CONSTRAINT
statemen
t,
241
A
ctionConstr
aint
(in
TLC),
241
actions,
comm
utativit
y
of,
78
actions,
join
t,
147,
152
address,
memory
,
47
alignmen
t,
208,
286
alignOut
TLA
T
E
X
option,
217
alternating
bit
proto
col,
222
A
lternatingBit
mo
dule,
222,
223
alw
a
ys
(2),
16,
89{90,
288,
314,
315
am
biguit
y
in
TLA
+
grammar,
289
Analyzer,
Syn
tactic,
207
and
(^),
se
e
conjunction
and/or,
9
angle
brac
k
ets,
27,
96
App
end
,
36
application,
op
erator,
320
argumen
t
of
a
declared
constan
t,
46
of
a
function,
50
of
an
op
erator,
31
argumen
t,
TLA
T
E
X
option,
211

INDEX
351
aril
TLC
option,
243,
251
arithmetic
op
erator,
19
arit
y
of
an
op
erator,
318
arit
y-correct,
321
arra
y
,
48,
50
arra
y
of
clo
c
ks,
139
arra
y
,
m
ultidimensional,
50
asci
i
represen
tation
of
c
haracters,
307
of
reserv
ed
w
ords,
19
of
sp
ecication,
19
of
sym
b
ol,
19,
273
asci
i
v
ersion
of
TLA
+
,
275,
305,
307
asci
i-readable,
220
Ass
,
327
Assert
,
249
assertional
reasoning,
2
assignmen
t
in
TLC,
234
asso
ciativit
y
,
10,
283
assume,
42,
327,
332
c
hec
k
ed
b
y
TLC,
241,
261
assume-guaran
tee
sp
ecication,
156
assumption,
42,
327,
332
AsynchInterfac
e
mo
dule,
24,
27
async
hronous
in
terface,
23
async
hronous
system,
3
atomicit
y
,
grain
of,
76{78
aux
le,
217
axioms,
P
eano's,
344
Bac
kus-Naur
F
orm,
179
bag,
340
BagCar
dinality
,
342
BagIn
,
342
BagOfA
l
l
,
342
Bags
mo
dule,
340,
343
o
v
erridden
b
y
TLC,
237
BagT
oSet
,
340
BagUnion
,
342
barrier
sync
hronization,
149
basic
expression,
309
state
function,
311
transition
function,
313
b
eha
vior,
15,
18,
314,
315
satisfying
temp
oral
form
ula,
18
b
eha
vior,
nite,
17,
112,
130
b
eha
vior,
Zeno,
120,
128
b
eha
vioral
prop
ert
y
,
1
b
eha
viors,
equiv
alence
of,
77
b
enets
of
sp
ecication,
75
binary
hour
clo
c
k,
158
binary
represen
tation,
308
BinaryHourClo
ck
mo
dule,
159,
160
blame,
145
BNF,
179,
276
BNF
Gr
ammars
mo
dule,
179,
183,
184
boolean,
46,
293
Bo
olean
op
erator,
9,
293,
296
precedence,
10
Bo
olean
op
erator,
simple,
236
Bo
olean
v
alue,
9
b
ound
o
ccurrence,
14
b
ound
v
ariable,
14,
109
b
ound,
real-time,
122
b
ound,
strong
real-time,
124
b
ounded
FIF
O,
42{43
b
ounded
quan
tication,
13,
293
Bounde
dFIF
O
mo
dule,
43
b
o
x
(2),
se
e
alw
a
ys
buer
comp
onen
t,
135,
140
buer,
FIF
O,
35,
140{142
built-in
op
erator,
20
C++,
7
C
[
[e
]
],
325
C
-basic

expression,
325
cac
he,
write-through,
54{62,
107{109
cac
hing
memory
,
45
cac
hing
memory
,
real-time,
124{128
calculator,
using
TLC
as,
261
capture,
v
ariable,
335
Car
dinality
,
66,
70,
340
cardinalit
y
,
70
carriage
return,
307
Cartesian
pro
duct,
53,
306
case,
298
ev
aluated
b
y
TLC,
262
parsing,
284
causalit
y
,
128
C
C
,
328
c
hannel,
28,
97,
99
Channel
mo
dule,
30
c
hannel,
rening,
159

352
INDEX
ChannelR
enement
mo
dule,
161,
162
c
haracter,
307
c
hec
kp
oin
t
(TLC),
252,
255,
260
Chinese,
2
Choic
e
,
295
choose,
47,
73,
294
applied
to
temp
oral
form
ula,
110
ev
aluated
b
y
TLC,
232,
234,
262
parsing,
284
circular
denition,
70
class,
equiv
alence,
of
a
state,
246
class,
Ja
v
a,
237
cleanup
TLC
option,
252
clev
erness,
80
clo
c
k,
hour,
se
e
hour
clo
c
k
clo
c
ks,
arra
y
of,
139
closed-system
sp
ecication,
44,
167
closure,
mac
hine,
se
e
mac
hine
closure
coarser-grained
sp
ecication,
76
collection
of
all
sets,
66
collision,
244,
255
commen
t,
32{34,
82
in
TLC
conguration
le,
226
shading,
212
syn
tax,
288
t
yp
eset
b
y
TLA
T
E
X,
214
commen
t,
end-of-line,
32
commen
t,
nested,
32
commen
t,
space
in,
213
common
sub
expression,
60
comm
unication,
152
comm
utativit
y
of
actions,
78
comparable
v
alues,
231,
264
complete-system
sp
ecication,
44,
156
complexit
y
,
relativ
e,
254
comp
onen
t,
135
Comp
ositeFIF
O
mo
dule,
142,
143
comp
osition
of
actions
(),
77,
312,
313
and
instan
tiation,
337
ev
aluated
b
y
TLC,
240
comp
osition
of
sp
ecications,
135,
168
and
liv
eness,
152
and
mac
hine
closure,
152
with
disjoin
t
state,
142
with
shared
state,
142{149
Comp
osition
Rule,
138
Comp
ositional
Hiding
Rule,
155
conditional
constructs,
298
config
TLC
option,
253
CongFileGr
ammar
mo
dule,
262,
263
conguration
le
(TLC),
225,
253,
261
grammar,
262
conjunct,
prop
ert
y
,
240
conjunct,
sp
ecication,
240
conjunction
(^),
9,
293
applied
to
temp
oral
form
ulas,
88
as
quan
tication,
13,
105
ev
aluated
b
y
TLC,
231
of
innitely
man
y
form
ulas,
13
Conjunction
Rule,
SF,
106
Conjunction
Rule,
WF,
105
conjuncts,
list
of,
25,
286,
293
connected,
strongly
,
174
connectivit
y
,
173
conserv
ativ
e
in
terpretation
of
Bo
olean
op
erators,
296
const
ant,
25,
46,
327,
329
constan
t
declaration,
25
lev
el,
324
mo
dule,
330
op
erator,
268,
291{309
parameter,
25,
45
CONSTANT
statemen
t,
226
constan
t,
in
ternal,
190
constan
t-lev
el
expression,
322
const
ants,
25
CONSTANTS
statemen
t,
226
constrain
t,
226
Constr
aint
(in
TLC),
241
constrain
t,
action,
241
constrain
t,
global,
140
constrain
t,
real-time,
119
on
disjunction,
128
construct,
292
constructor,
set,
66,
299
con
text,
324{325
con
text,
curren
t,
328
con
tin
ually
enabled,
106
v
ersus
con
tin
uously
,
106
con
tin
uously
enabled,
106,
122
v
ersus
con
tin
ually
,
106

INDEX
353
con
tract,
sp
ecication
as,
156
con
tradiction,
pro
of
b
y
,
102
con
v
ersion,
,
319
CopiesIn
,
342
correct,
syn
tactically
,
325
correctness
of
mo
dule,
332
Couturier,
Dominique,
xvii
coverage
TLC
option,
227,
252,
258
curren
t
con
text,
328
d
Syn
tactic
Analyzer
option,
207
data
renemen
t,
164
data
structures,
78{79,
170
Dcl
,
327
deadlo
c
k,
222,
251
deadlock
TLC
option,
242,
251
debugging,
253
v
ariable,
244
decimal
represen
tation,
308
declaration,
324,
329
declaration,
constan
t,
25
declaration,
scop
e
of,
31
declaration,
v
ariable,
19
denition,
31{32,
324
of
function,
54,
329
of
op
erator,
329
o
v
erriding,
234,
235
denition,
global,
327
denition,
inductiv
e,
69
denition,
lo
cal,
170,
327
denition,
mo
dule,
324
delimiter,
285,
286
depth
TLC
option,
243,
251
deriv
ativ
e,
176
diameter
of
state
graph,
254
dierence,
set
(n),
12
dieren
tial
equation,
133,
174
Dier
entialEquations
mo
dule,
177,
178
difftrace
TLC
option,
252,
259
directed
graph,
173
discrete
step,
15
disjoin
t-state
comp
osition,
142{149
sp
ecication,
151
disjunction
(_),
9,
293
as
quan
tication,
13,
105
ev
aluated
b
y
TLC,
231
disjunction
(_),
real-time
constrain
t
on,
128
disjuncts,
list
of,
26,
286,
293
distribute
o
v
er,
93,
114,
336
distributed
system,
3
divide
and
conquer,
209
division
of
in
tegers,
344
of
real
n
um
b
ers,
73
domain,
48,
302
domain
of
a
function,
48,
302
double
quote
("),
216,
307
DR
1,
101
DR
2,
102
dual
tautology
,
93
dvi
le,
211,
217
dvips,
213
edge,
172
elemen
t,
11
empt
y
set,
12
EmptyBag
,
342
enabled,
97,
312,
313
and
instan
tiation,
337
ev
aluated
b
y
TLC,
240
predicate,
computing,
115
substitution
in,
335
enabled,
26
con
tin
ually
,
106
con
tin
uously
,
106,
122
rep
eatedly
,
124
enabled-free
state
function,
311
end-of-line
c
haracter,
288,
290
end-of-line
commen
t,
32
English,
2,
98
en
vironmen
t,
43,
147,
156
equalit
y
(=),
284,
300
of
sets,
12
v
ersus
equiv
alence,
10,
296
equation,
dieren
tial,
133,
174
equiv
alence
class
of
a
state,
246
of
sp
ecications,
21
equiv
alence
(),
9,
293
v
ersus
equalit
y
,
10,
296
equiv
alence
of
b
eha
viors,
77
error
rep
ort
(TLC),
255

354
INDEX
error
trace
(TLC),
247,
252,
259
error,
lo
cating,
with
TLC,
249
error,
seman
tic,
208
error,
syn
tactic,
208
ev
aluating
expressions,
231
ev
en
tually
(3),
91,
288,
314
ev
en
tually
alw
a
ys
(32),
92,
106
ex
cept,
29,
49,
302,
304{306
execution
of
an
action,
16
execution,
terminating,
17
existen
tial
quan
tication
(9
),
12,
293
as
disjunction,
13,
105
ev
aluated
b
y
TLC,
232
existen
tial
quan
tication,
temp
oral,
se
e
hiding
v
ariables
explanation
of
memory
scenario,
186
expression,
317,
321
expression
ev
aluation
b
y
TLC,
231
expression,
,
se
e

expression
expression,
basic,
309
expression,
lev
el
of,
322
expression,
silly
,
67,
222
ev
aluated
b
y
TLC,
256
extends,
19,
237,
328
extends,
structuring
sp
ecication
with,
34
factorial,
54,
67
failed
to
reco
v
er
state,
247
fairness
and
renemen
t,
114
fairness
conditions,
com
bining,
101,
105
fairness,
expressing
liv
eness
with,
112
fairness,
strong,
106{107
fairness,
w
eak,
96{100
real-time
analog,
122
f
alse
,
9,
293
F
astSort
,
250
eld
of
record,
28
FIF
O
buer,
35,
140{142
FIF
O
transmission
line,
222
FIF
O,
b
ounded,
42{43
le
name,
ro
ot
of,
217
le,
aux,
217
le,
dvi,
211,
217
le,
log,
217
le,
PDF,
211,
212
le,
TLC
conguration,
se
e
congura-
tion
le
les,
TLA
T
E
X
output,
217
ner-grained
sp
ecication,
76
ngerprin
t,
244,
247,
255
ngers,
coun
ting
on,
11
nite
b
eha
vior,
112,
130
FiniteSets
mo
dule,
66,
340,
341
o
v
erridden
b
y
TLC,
237
rst-order
logic,
3,
318
exible
v
ariable,
110
fon
t
of
commen
t,
32
fon
t
size,
216
form
feed,
290,
307
formal
mathematics,
2
formal
seman
tics,
292
form
ula,
309,
310
splitting,
60
used
in
a
sen
tence,
14
form
ula,
simple
action,
236
form
ula,
temp
oral,
se
e
temp
oral
form
ula
form
ula,
v
alid,
18,
309
F
rank,
Douglas,
xvii
free
o
ccurrence,
14
free
v
ariable,
14
function,
48{51,
72{73,
301
expressed
with
:>
and
@@
,
249
of
m
ultiple
argumen
ts,
50,
302
transition,
312
v
ersus
op
erator,
69{72
function
denition,
329
function,
hashing,
244
function,
nondeterministic,
73
function,
recursiv
ely
dened,
se
e
recur-
siv
e
function
denition
function,
state,
25,
310{312
functional
prop
ert
y
,
1
G
,
241,
254
GDef
,
327
Generalization
Rule,
95
gibb
erish,
nonsyn
tactic,
69
Gilk
erson,
Ellen,
v
global
constrain
t,
140
denition,
327

INDEX
355
function
denition,
329
op
erator
denition,
329
Gon
thier,
Georges,
307
grain
of
atomicit
y
,
76{78
Gr
ammar
,
180
grammar,
179
of
TLA
+
,
276{289
of
TLC
conguration
le,
262
gran
ularit
y
of
step,
24,
76{78
graph,
172
graph,
directed,
173
graph,
state
(G
),
se
e
state
graph
graph,
undirected,
173
Gr
aphs
mo
dule,
172,
175
grayLevel
TLA
T
E
X
option,
213
Gr

egoire,
Jean-Charles,
xvii,
207
Gro
v
er,
Vino
d,
xvii
Guindon,
1
handshak
e
proto
col,
23
hashing
function,
244
Ha
yden,
Mark,
221
He
ad
,
35,
53
help
TLA
T
E
X
option,
212
henceforth,
se
e
alw
a
ys
hexadecimal
represen
tation,
308
hiding
v
ariables,
39,
41,
110,
111,
221,
228,
314,
316
and
comp
osition,
154
high-lev
el
sp
ecication,
132,
169
higher-order
logic,
318
Hilb
ert's
",
73,
296
hoffset
TLA
T
E
X
option,
217
hour
clo
c
k,
15,
96,
98
hour
clo
c
k,
binary
,
158
hour
clo
c
k,
real-time,
117{121
HourClo
ck
mo
dule,
19,
20
with
commen
ts,
33
h
ybrid
sp
ecication,
132{133
iden
tier,
31,
277,
321
of

parameter,
319
iden
tier,
run,
252,
255
if/then/else,
16
ev
aluated
b
y
TLC,
231
parsing,
284,
298
i,
9
implemen
tation,
62,
111
under
in
terface
renemen
t,
165
implemen
tation,
pro
ving,
62{64
implemen
ting
real-time
constrain
ts,
126
implication,
9
as
implemen
tation,
62,
111
implicit
substitution
(in
inst
ance),
40
Implie
dA
ction
(in
TLC),
241
Implie
dInit
(in
TLC),
241
Implie
dT
emp
or
al
(in
TLC),
241
implies
()),
9,
293
denition
explained,
10
ev
aluated
b
y
TLC,
231
Implies
Generalization
Rule,
95
in,
se
e
let/in
inden
tation
in
con/disjunction
lists,
26,
286
inductiv
e
denition,
69
inductiv
e
in
v
arian
t,
61
innitely
often
(23),
91,
106
Innity
,
122,
344
inx
op
erator,
270,
278,
345
info
TLA
T
E
X
option,
212
Init
(in
TLC),
240
INIT
statemen
t,
225,
262
initial
predicate,
16
ev
aluated
b
y
TLC,
254
initial
state,
16
computed
b
y
TLC,
237,
240,
241
InnerFIF
O
mo
dule,
37,
38
InnerSe
quential
mo
dule,
200,
201
InnerSerial
mo
dule,
195,
196
inst
ance,
36{40,
330{331,
334{338
inst
ance,
local,
171
inst
ance,
structuring
sp
ecication
with,
34
instan
taneous
c
hange,
117
instan
tiation,
37{40,
330{331,
334{338
instan
tiation,
parametrized,
39
Int
(set
of
in
tegers),
344
in
teger
division,
344
in
teger
is
real
n
um
b
er,
344
Inte
gers
mo
dule,
344,
348
o
v
erridden
b
y
TLC,
237
Inte
gr
ate
,
132,
174
in
tegration,
133
in
terface
renemen
t,
158{167

356
INDEX
and
implemen
tation,
165
and
liv
eness,
165
for
op
en-system
sp
ecications,
165
in
terface,
async
hronous,
23
in
terface,
memory
,
183
in
terface,
program,
3,
78
in
terlea
ving
sp
ecication,
137,
151
in
ternal
constan
t,
190
in
ternal
v
ariable,
41,
111
InternalMemory
mo
dule,
52
in
tersection
(\),
12
in
terv
al,
op
en,
174
in
v
ariance,
pro
ving,
62
in
v
arian
t,
61{62
c
hec
king
b
y
TLC,
225,
242
of
a
sp
ecication,
25
of
an
action,
61
under
stuttering,
90
Invariant
(in
TLC),
240
INVARIANT
statemen
t,
225
in
v
arian
t,
inductiv
e,
61
in
v
arian
t,
t
yp
e,
25,
80
INVARIANTS
statemen
t,
226
irreexiv
e,
191
irreexiv
e
partial
order,
71
IsABag
,
340
IsABehavior
,
316
IsAFcn
,
303
IsAState
,
313
IsDeriv
,
176
IsFcnOn
,
140
IsFiniteSet
,
43,
66,
340
Ja
v
a
class,
237
JavaTime
,
249
Jeerson,
Da
vid,
xvii,
207
join
t
actions,
147,
152
JointA
ctionMemory
mo
dule,
150
Kalv
ala,
Sara,
xvii
key
TLC
option,
243
k
eyb
oard,
81
Kn
uth,
Donald
Ervin,
19,
211
Krishnan,
P
addy
,
xvii
lam
b
da,
se
e

Lamp
ort,
Leslie,
211,
221
language,
179
language,
programming,
3,
67
L
A
T
E
X,
211
L
A
T
E
X
commands
in
TLA
T
E
X,
219
latexCommand
TLA
T
E
X
option,
212
LDef
,
327
leads
to
(;),
91,
314
L
e
astGr
ammar
,
181
left
asso
ciativ
e,
283
legal

expression,
327
Leisenring,
A.
C.,
296
L
en
,
36
let/in,
60,
299
meaning
of,
326
parsing,
284
lev
el,
321{324
lev
el
of
abstraction,
76
lev
el,
constan
t,
324
lev
el-correct,
323
lexeme,
179
lexeme,
TLA+,
275,
289
lib
eral
in
terpretation
of
Bo
olean
op
er-
ators,
296
limit,
denition
of,
177
line
feed,
307
line
n
um
b
ers,
212
linearizable
memory
,
51,
100,
185
list
of
conjuncts,
25,
286,
293
list
of
disjuncts,
26,
286,
293
liv
eness
and
comp
osition,
152
considered
unimp
ortan
t,
116
expressed
with
fairness,
112
in
in
terface
renemen
t,
165
liv
eness
prop
ert
y
,
3,
87
c
hec
k
ed
b
y
TLC,
228,
242,
247
local,
171,
327,
329,
331,
340
lo
cal
denition,
170,
327
function
denition,
330
inst
ance,
331
op
erator
denition,
329
log
le,
217
logic,
rst-order,
3,
318
logic,
higher-order,
318
logic,
predicate,
12{14,
293
logic,
prop
ositional,
9{11,
293
logic,
temp
oral,
se
e
temp
oral
logic

INDEX
357
logical
prop
ert
y
,
1
logical
thinking,
danger
to,
7
lossy
transmission
line,
222
lo
w
er-lev
el
sp
ecication,
169
mac
hine
closure,
111{114,
130,
200,
230
and
comp
osition,
152
mapping,
renemen
t,
63,
228
mathematics,
2,
9,
21,
22,
65,
174
MaxTime
,
119,
123
MCA
lternatingBit
mo
dule,
226,
227
MDef
,
327
meaning,
292
of

expression,
325{327
of
temp
oral
form
ula,
88
Melville,
Herman,
vii
memory
address,
47
memory
in
terface,
183
Memory
mo
dule,
51,
53
memory
system,
45
memory
v
alue,
47
memory
,
cac
hing,
45
memory
,
linearizable,
51,
100,
185
memory
,
real-time
cac
hing,
124{128
memory
,
sequen
tially
consisten
t,
195
memory
,
serial,
188
MemoryInterfac
e
mo
dule,
48
MinTime
,
119,
123
mo
del,
225
mo
del
c
hec
king,
221,
226,
241
mo
del
v
alue,
230,
259
mo
del,
sp
ecication
as,
76
mo
derate
in
terpretation
of
Bo
olean
op-
erators,
296
module,
19
mo
dule,
19
correctness,
332
denition,
324
end,
21
nding,
333
name,
325
o
v
erriding,
237
unit,
285,
286
mo
dule,
constan
t,
330
mo
dule,
meaning
of,
317,
327{332
mo
dule,
standard,
272,
339
mo
dulus,
21,
344
Mo
dus
Ponens
Rule,
95
monolithic
sp
ecication,
136,
167
m
ulti-line
commen
t,
214
m
ultiset,
340
m
utual
recursion,
68,
233
names
of
mo
dules
and
op
erators,
325
of
sets,
36
Nat
(set
of
natural
n
um
b
ers),
12,
21,
308,
344
natural
n
um
b
er,
11
Natur
als
mo
dule,
19,
344,
348
o
v
erridden
b
y
TLC,
237
Nbhd
,
174
negation
(:),
9,
293
of
temp
oral
form
ula,
88
nested
commen
ts,
32
nested
quan
tiers,
13
Next
(in
TLC),
240
NEXT
statemen
t,
225,
264
next-state
action,
16
ev
aluated
b
y
TLC,
237
next-state
action,
nding
error
in,
259
next-state
action,
in
v
arian
t
of,
61
next-state
action,
subaction
of,
111
nice
temp
oral
form
ula,
236
Nil
,
181
no
de,
172
noEpilog
TLA
T
E
X
option,
214
non-mac
hine-closed
sp
ecication,
200
c
hec
king,
230
non-Zeno
sp
ecication,
130
nonconstan
t
op
erator,
309{316
nondeterministic
function,
73
nondeterministic
op
erator,
73
nonin
terlea
ving
sp
ecication,
137
nonsense,
71
nonsyn
tactic
gibb
erish,
69
non
terminal
sym
b
ol,
179
noProlog
TLA
T
E
X
option,
214
nops
TLA
T
E
X
option,
213
not,
se
e
negation
now
,
117
nowarning
TLC
option,
253
NowNext
,
120
n
um
b
er,
345

358
INDEX
number
TLA
T
E
X
option,
212
n
um
b
er,
natural,
11
n
um
b
ers,
line,
212
NZ
,
130
o
ccurrence,
b
ound,
14
o
ccurrence,
free,
14
Ogata,
Kazuhiro,
xvii
one
(1),
345
one-line
commen
t,
214
one-tuple,
306
OneOf
,
182
op
en
in
terv
al,
174
op
en
set,
177
op
en-system
sp
ecication,
44,
156{158,
167
in
terface
renemen
t,
165
Op
enInterval
,
174
op
erator,
31,
317
application,
320
denition,
329
name,
325
of
arithmetic,
19
precedence,
271,
283
seman
tics,
291{316
sym
b
ol,
user-denable,
270
v
ersus
function,
69{72
op
erator,
action,
269,
312{314
op
erator,
arit
y
of,
318
op
erator,
Bo
olean,
9,
293,
296
precedence,
10
op
erator,
built-in,
20
op
erator,
constan
t,
268,
291{309
with
argumen
ts,
46
op
erator,
dened
in
standard
mo
dule,
272
op
erator,
inx,
270,
278,
345
op
erator,
nonconstan
t,
309{316
op
erator,
nondeterministic,
73
op
erator,
order
of,
318
op
erator,
p
ostx,
270,
278
op
erator,
prex,
270,
278
op
erator,
recursiv
e
denition
of,
70
op
erator,
simple
Bo
olean,
236
op
erator,
temp
oral,
269,
314{316
option
(Syn
tactic
Analyzer),
207
d,
207
s,
207
option
(TLA
T
E
X),
211
alignOut,
217
grayLevel,
213
help,
212
hoffset,
217
info,
212
latexCommand,
212
noEpilog,
214
noProlog,
214
nops,
213
number,
212
out,
217
ps,
213
psCommand,
213
ptSize,
216
shade,
212
style,
218
textheight,
216
textwidth,
216
tlaOut,
218
voffset,
217
option
(TLC),
251
aril,
243,
251
cleanup,
252
config,
253
coverage,
227,
252,
258
deadlock,
242,
251
depth,
243,
251
difftrace,
252,
259
key,
243
nowarning,
253
recover,
252,
255,
260
seed,
251
simulate,
251
terse,
252
workers,
253
option
argumen
t
(TLA
T
E
X),
211
or
(_),
se
e
disjunction
order
of
an
op
erator,
318
order,
irreexiv
e
partial,
71
order,
total,
191
other,
298
out
TLA
T
E
X
option,
217
output
of
TLC,
253
o
v
erriding
a
denition,
234,
235

INDEX
359
a
mo
dule,
237
pac
k
age,
tlatex
,
218
P
ahala
w
atta,
Kapila,
xvii
P
alais,
Ric
hard,
xvii
parado
x,
Russell's,
66
p
ar
ameter
;
,
319
parameter,
action,
46
parameter,
constan
t,
25,
45
parametrized
instan
tiation,
39
paren
t
(in
a
tree),
174
paren
theses,
10,
284,
287
paren
theses,
eliminating,
26
parsing,
179
partial
order,
irreexiv
e,
71
path,
173
PDF
le,
211,
212
Pe
ano
mo
dule,
308,
344,
345
P
eano's
axioms,
344
p
erformance,
2
p
erm
utation,
245
Permutations
,
245,
250
philosoph
y
,
Greek,
128
Pn
ueli,
Amir,
2
p
oin
t
(unit
of
measure),
216
PosR
e
al
,
174
p
ossibilit
y
,
113
p
ostx
op
erator,
270,
278
P
ostScript,
211,
212
p
o
w
er
set,
65
precedence,
10
of
Bo
olean
op
erator,
10
of
op
erators,
271,
283
of
temp
oral
op
erators,
92
range,
283
predicate
logic,
12{14,
293
predicate,
initial,
16
ev
aluated
b
y
TLC,
254
predicate,
state,
se
e
state
predicate
prex
op
erator,
270,
278
prime
(
0
),
16,
82,
312,
313
prime
(
0
),
double,
322
primitiv
e
op
erator
of
seman
tics,
292
Print
,
249,
259
pro
cessor,
47
pro
duct,
Cartesian,
53,
306
pro
duction
(of
grammar),
179
program
in
terface,
3,
78
programming
language,
3,
67
pro
of
b
y
con
tradiction,
102
of
implemen
tation,
62{64
of
in
v
ariance,
62
rule,
temp
oral,
95
rule,
TLA,
18
prop
ert
y
c
hec
king
b
y
TLC,
229,
240
prop
ert
y
conjunct,
240
PROPERTY
statemen
t,
225,
237
prop
ert
y
,
b
eha
vioral,
1
prop
ert
y
,
functional,
1
prop
ert
y
,
liv
eness,
3,
87
c
hec
k
ed
b
y
TLC,
228,
242,
247
prop
ert
y
,
logical,
1
prop
ert
y
,
safet
y
,
3,
87,
153
prop
ositional
logic,
9{11,
293
proto
col,
alternating
bit,
222
proto
col,
handshak
e,
23
Pr
otoR
e
als
mo
dule,
308,
344,
346
ps
TLA
T
E
X
option,
213
psCommand
TLA
T
E
X
option,
213
pseudo-random
n
um
b
er
generator,
243,
251
ptSize
TLA
T
E
X
option,
216
quan
tication,
82
of
temp
oral
form
ula,
88,
109{110
o
v
er
tuple,
293
quan
tication,
b
ounded,
13,
293
quan
tication,
existen
tial
(9
),
12
quan
tication,
un
b
ounded,
13,
232,
293
quan
tication,
univ
ersal
(8
),
12
quan
tier,
12,
293
nesting,
13
parsing,
284
Quan
tier
Rule,
WF,
105
queue
of
unexplored
states
(U
),
241,
254
quote,
double
("),
216,
307
quotes,
single
(`
.
.
.
'),
214
range
of
a
function,
48
range,
precedence,
283
R
d
,
186
reac
hable
state,
226

360
INDEX
R
e
al
(set
of
real
n
um
b
ers),
67,
308,
344
real
time,
117{134
real-time
b
ound,
122
cac
hing
memory
,
124{128
constrain
t,
119
implemen
ting,
126
on
disjunction,
128
constrain
ts,
com
bining,
128
hour
clo
c
k,
117{121
R
e
als
mo
dule,
344,
348
R
e
alTime
mo
dule,
123,
125
R
e
alTimeHourClo
ck
mo
dule,
119,
121
reasoning,
assertional,
2
receiv
er,
23,
35,
144,
222
comp
onen
t,
135,
140
record,
28,
305
as
function,
49,
50
eld,
28
recover
TLC
option,
252,
255,
260
recursion,
m
utual,
68,
233
recursiv
e
function
denition,
54,
67{69,
302
ev
aluated
b
y
TLC,
233
redeclaration,
32
reduction,

,
319
renemen
t
mapping,
63,
228
and
fairness,
114
renemen
t
of
c
hannel,
159
renemen
t,
data,
164
renemen
t,
in
terface,
se
e
in
terface
re-
nemen
t
R
e
gisterInterfac
e
mo
dule,
185,
186
relation
as
set
of
pairs,
191
relation,
next-state,
se
e
next-state
ac-
tion
relativ
e
complexit
y
,
254
rely-guaran
tee
sp
ecication,
156
renaming,
instan
tiation
without,
40
renaming,
parameter,
319
rep
eatedly
enabled,
124
replacemen
t
in
TLC,
234,
261
request,
47
resource,
shared,
127
resp
onse,
47
rigid
v
ariable,
110
ro
ot
of
le
name,
217
ro
ot
of
tree,
174
round-robin
sc
heduling,
127
R
TBound
,
122
R
TMemory
mo
dule,
125,
126
R
Tnow
,
120,
123
R
TWriteThr
oughCache
mo
dule,
129
Rudalics,
Martin,
xvii
run
iden
tier,
252,
255
running
the
Syn
tactic
Analyzer,
207
running
TLA
T
E
X,
211
running
TLC,
251
Russell's
parado
x,
66
s
Syn
tactic
Analyzer
option,
207
safet
y
prop
ert
y
,
3,
87,
153
Sam
b
orski,
Dmitri,
211
scenario,
186
sc
heduling
shared
resource,
127
sc
heduling,
round-robin,
127
Sc
hreiner,
W
olfgang,
xvii
scop
e,
31
second
(unit
of
time),
117
seed,
243,
251,
254
seed
TLC
option,
251
Sele
ctSe
q
,
339
seman
tic
correctness,
333
error,
208
part
of
syn
tax,
275,
291
seman
tics
of
TLA
+
,
317
deviation
b
y
TLC,
262
seman
tics,
formal,
292
seman
tics,
primitiv
e
op
erator
of,
292
sender,
23,
35,
144,
222
comp
onen
t,
135,
140
sen
tence,
179
Se
q
,
35
sequence,
35,
53,
306
Se
quenc
es
mo
dule,
35,
53,
339,
341
o
v
erridden
b
y
TLC,
237
sequen
tially
consisten
t
memory
,
195
serial
memory
,
188
SerialMemory
mo
dule,
195
set,
11,
65{66
constructor,
66,
299
dierence
(n),
12
equalit
y
,
12,
300

INDEX
361
of
all
sets,
66
theory
,
3,
11,
43,
300
set,
empt
y
,
12
set,
op
en,
177
set,
p
o
w
er,
65
set,
symmetry
,
246
set,
to
o
big
to
b
e,
66
sets,
collection
of
all,
66
sets,
naming,
36
SetT
oBag
,
342
SF,
106,
285,
314
and
instan
tiation,
337
SF
Conjunction
Rule,
106
shade
TLA
T
E
X
option,
212
shading
commen
ts,
212
shared
resource,
sc
heduling,
127
shared-state
comp
osition,
142{149
sp
ecication,
151
Shared-State
Comp
osition
Rule,
146
silly
expression,
67,
222
ev
aluated
b
y
TLC,
256
simple
action
form
ula,
236
Bo
olean
op
erator,
236
temp
oral
form
ula,
236
simulate
TLC
option,
251
sim
ulation,
226,
243,
251
sim
ulation,
step,
63
c
hec
k
ed
b
y
TLC,
242
single
quotes
(`
.
.
.
'),
214
Sort
,
235,
250
SortSe
q
,
250
sound,
296
space
c
haracter,
290,
307
space
in
commen
t,
213
sp
ecication,
1
as
abstraction,
24
as
mo
del,
76
b
y
scien
tists,
15
conjunct,
240
in
v
arian
t,
25
parameter,
25,
45
splitting,
34
standard
form,
221
structure,
32{34
SPECIFICATION
statemen
t,
225,
237,
264
sp
ecication,
assume-guaran
tee,
156
sp
ecication,
b
enets
of,
75
sp
ecication,
closed-system,
44,
167
sp
ecication,
coarser-grained,
76
sp
ecication,
complete-system,
44,
156
sp
ecication,
disjoin
t-state,
151
sp
ecication,
ex
p
ost
facto,
228
sp
ecication,
ner-grained,
76
sp
ecication,
high-lev
el,
132,
169
sp
ecication,
h
ybrid,
132{133
sp
ecication,
in
terlea
ving,
137,
151
sp
ecication,
lo
w
er-lev
el,
169
sp
ecication,
monolithic,
136,
167
sp
ecication,
non-mac
hine-closed,
200
c
hec
king,
230
sp
ecication,
non-Zeno,
130
sp
ecication,
nonin
terlea
ving,
137
sp
ecication,
op
en-system,
44,
156{158,
167
sp
ecication,
rely-guaran
tee,
156
sp
ecication,
shared-state,
151
sp
ecication,
Zeno,
128{132
sp
ecications,
comp
osition
of,
135,
168
splitting
a
sp
ecication,
34
SR
TBound
,
124
standard
form
of
sp
ecication,
221
standard
mo
dule,
339
standard
mo
dule,
op
erators
dened
in,
272
state,
15,
18,
30,
310,
311
computed
b
y
TLC,
237
in
G
,
241
prin
ted
b
y
TLC,
256
sp
ecifying
univ
erse,
18
state
form
ula,
temp
oral,
236
state
function,
25,
310{312
basic,
311
state
graph
(G
),
241
diameter,
254
state
predicate,
25,
310,
311
as
temp
oral
form
ula,
88
state,
initial,
16
computed
b
y
TLC,
237,
240,
241
state,
reac
hable,
226
state,
successor,
237
state-lev
el
expression,
322
step,
16,
151,
312

362
INDEX
satisfying
an
action,
16
stuttering,
315
step
sim
ulation,
63
c
hec
k
ed
b
y
TLC,
242
step,
discrete,
15
step,
gran
ularit
y
of,
24,
76{78
step,
stuttering,
17,
90
string,
180,
307,
308
string,
182,
307
represen
ted
b
y
TLC,
262
strong
fairness,
106{107
strong
real-time
b
ound,
124
strongly
connected,
174
structure
of
a
sp
ecication,
32{34
stuttering
step,
17,
90,
315
stuttering,
in
v
arian
t
under,
90
style
TLA
T
E
X
option,
218
subaction,
111,
131
SubBag
,
342
subgraph,
173
submo
dule,
119,
125,
141,
327,
332
subscript,
96,
153,
285
SubSe
q
,
339
subsequence
op
erator,
339
subset,
65,
299,
300
subset,
12
substitution,
334
substitution,
implicit
(in
inst
ance),
40
substitution,
instan
tiation
as,
37
suc
c
,
49
successor
function,
49,
308
successor
state,
237
sym
b
ol,
31
user-denable,
270
sym
b
ol,
asci
i
represen
tation,
19,
273
sym
b
ol,
non
terminal,
179
sym
b
ol,
terminal,
179
symmetry
,
245,
250
symmetry
set,
246
SYMMETRY
statemen
t,
245,
264
sync
hronization,
barrier,
149
Syn
tactic
Analyzer,
207
syn
tactic
error,
208
syn
tactically
correct,
325
syn
tax,
275
syn
tax,
seman
tic
conditions
of,
291
system,
156
system
v
ersus
en
vironmen
t,
43
system,
async
hronous,
3
system,
distributed,
3
system,
h
ybrid,
132
system,
memory
,
45
tab
c
haracter,
287,
290,
307
table,
truth,
10,
11
T
ail
,
36,
53
tautology
c
hec
king
with
TLC,
261
of
predicate
logic,
13
of
prop
ositional
logic,
11,
296
of
temp
oral
logic,
92{95
v
ersus
pro
of
rule,
95
tautology
,
dual,
93
temp
oral
existen
tial
quan
tication,
se
e
hiding
v
ariables
form
ula,
18,
88{92,
314
c
hec
k
ed
b
y
TLC,
242
ev
aluated
b
y
TLC,
235
syn
tax,
288
v
alid,
315
form
ula,
meaning
of,
88
form
ula,
nice,
236
form
ula,
simple,
236
logic,
2,
116
tautology
,
92{95
logic
of
actions,
2
op
erator,
269,
314{316
precedence,
92
pro
of
rule,
95
state
form
ula,
236
theorem,
92
univ
ersal
quan
tication,
110,
315
T
emp
or
al
(in
TLC),
240
temp
oral-lev
el
expression,
322
terminal
sym
b
ol,
179
terminating
execution,
17
termination,
222
terse
TLC
option,
252
T
E
X,
19,
211
textheight
TLA
T
E
X
option,
216
textwidth
TLA
T
E
X
option,
216
theorem,
20,
327,
332
theorem,
18,
327,
332

INDEX
363
theorem,
temp
oral,
92
thinking,
83
Thm
,
327
threads
used
b
y
TLC,
242,
253
time,
real,
117{134
time,
unit
of,
117
Timer
,
119,
123
timer,
118
TLA,
2
TLA
pro
of
rule,
18
TLA
W
eb
page,
1,
19,
63,
207,
211,
221
TLA
+
,
3
tlaOut
TLA
T
E
X
option,
218
TLAPlusGr
ammar
mo
dule,
276
TLA
T
E
X,
211,
286,
288
output
les,
217
W
eb
page,
211
TLA
T
E
X,
running,
211
tlatex
L
A
T
E
X
pac
k
age,
218
TLC,
221{264
TLC
mo
dule,
248
o
v
erridden
b
y
TLC,
237
TLC
v
alue,
230
TLC,
running,
251
T
ok
,
182
tok
,
180
tok
en,
180
to
ol,
TLA
+
,
1,
3,
207
total
order,
191
trace,
TLC
error,
247,
252,
259
transition
function,
312
transition
function,
basic,
313
transition-lev
el
expression,
322
transitiv
e,
191
transmission
line,
FIF
O,
222
tree,
174
tr
ue,
9,
293
truth
table,
10,
11
tuple,
27,
53,
306
tuple,
quan
tication
o
v
er,
293
tuple,
sequence
as,
35
T
uttle,
Mark,
xvii,
221
t
w
o-phase
handshak
e,
23
t
yp
e
in
programming
language,
67
t
yp
e
in
v
arian
t,
25,
80
t
yp
e
of
a
v
ariable,
25,
30
t
yp
esetting
sp
ecications,
19,
211
U
,
241,
254
uid,
1
un
b
ounded
quan
tication,
13,
232,
293
unchanged,
26,
312
ev
aluated
b
y
TLC,
238
undirected
graph,
173
union,
65,
299,
300
union
([),
12
unit
of
time,
117
unit,
mo
dule,
285,
286
univ
ersal
quan
tication
(8
),
12,
293
as
conjunction,
13,
105
ev
aluated
b
y
TLC,
232
univ
ersal
quan
tication,
temp
oral,
110,
315
univ
erse
sp
ecied
b
y
state,
18,
43,
135
unless,
102
un
t
yp
ed,
30,
67,
296
URL,
1
user-denable
sym
b
ol,
270
v
alid
form
ula,
18,
309
v
alid
temp
oral
form
ula,
315
v
alue,
310
v
alue
as
set,
43
v
alue,
Bo
olean,
9
v
alue,
memory
,
47
v
alue,
mo
del,
230,
259
v
alue,
TLC,
230
v
alues,
comparable,
231,
264
v
ariable,
19,
327,
329
v
ariable
capture,
335
declaration,
19
hiding,
se
e
hiding
v
ariables
v
ariable,
b
ound,
14,
109
v
ariable,
debugging,
244
v
ariable,
exible,
110
v
ariable,
free,
14
v
ariable,
in
ternal,
41,
111
v
ariable,
rigid,
110
v
ariable,
t
yp
e
of,
25,
30
v
ariable,
visible,
41
v
ariables,
25
v
ersion
of
TLC,
221
view,
243
VIEW
statemen
t,
243,
264

364
INDEX
visible
v
ariable,
41
voffset
TLA
T
E
X
option,
217
w
eak
fairness,
96{100
real-time
analog,
122
w
eak
fairness,
equiv
alence
to
strong
fair-
ness,
106
W
eb
page,
TLA,
1,
19,
63,
207,
211,
221
W
eb
page,
TLA
T
E
X,
211
WF,
97,
285,
314
and
instan
tiation,
337
WF
Conjunction
Rule,
105
WF
Quan
tier
Rule,
105
WF,
equiv
alence
to
SF,
106
with,
36
omitted,
40
witness,
62
workers
TLC
option,
253
Wr
,
186
write-through
cac
he,
54{62,
107{109
WriteThr
oughCache
mo
dule,
57
writing,
1
writing,
ho
w
to
start,
24,
79
writing,
when
to
start,
83
Y
u,
Y
uan,
xvii
Zeno
b
eha
vior,
120,
128
Zeno
of
Elea,
128
Zeno
sp
ecication,
128{132
Zermelo-F
r
ank
el
set
theory
,
43,
300
Zer
o
,
308
zero
(0),
345
zero-tuple,
37,
306
ZF,
43,
300

