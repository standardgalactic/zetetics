17
A constructive denotational semantics for
Kahn networks in Coq
Christine Paulin-Mohring
INRIA Saclay - ˆIle-de-France and Universit´e Paris-Sud
Abstract
Semantics of programming languages and interactive environments for
the development of proofs and programs are two important aspects of
Gilles Kahn’s scientiﬁc contributions. In his paper “The semantics of a
simple language for parallel programming” [11], he proposed an interpre-
tation of (deterministic) parallel programs (now called Kahn networks)
as stream transformers based on the theory of complete partial orders
(cpos). A restriction of this language to synchronous programs is the
basis of the data-ﬂow Lustre language which is used for the development
of critical embedded systems [14, 10].
We present a formalization of this seminal paper in the Coq proof
assistant [4, 15]. For that purpose, we developed a general library for
cpos. Our cpos are deﬁned with an explicit function computing the least
upper bound (lub) of an increasing sequence of elements. This is diﬀerent
from what Kahn developed for the standard Coq library where only
the existence of lubs (for arbitrary directed sets) is required, giving no
way to explicitly compute a ﬁxpoint. We deﬁne a cpo structure for the
type of possibly inﬁnite streams. It is then possible to deﬁne formally
what is a Kahn network and what is its semantics, achieving the goal of
having the concept closed under composition and recursion. The library
is illustrated with an example taken from the original paper as well as
the Sieve of Eratosthenes, an example of a dynamic network.
17.1 Introduction
Semantics of programming languages and interactive environments for
the development of proofs and programs are two important aspects of
From Semantics to Computer Science Essays in Honour of Gilles Kahn, eds Yves Bertot,
G´erard Huet, Jean-Jacques L´evy and Gordon Plotkin. Published by Cambridge University
Press. c
⃝Cambridge University Press 2009.
383
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

384
C. Paulin-Mohring
Gilles Kahn’s scientiﬁc contributions. In his paper “The semantics of a
simple language for parallel programming” [11], he proposed an interpre-
tation of (deterministic) parallel programs (now called Kahn networks)
as stream transformers based on the theory of complete partial orders
(cpos). A restriction of this language to synchronous programs is the
basis of the data-ﬂow Lustre language [14, 10], which is used now for the
development of critical embedded systems. Because of the elegance and
generality of the model, Kahn networks are also a source of inspiration
for extensions of the data-ﬂow synchronous paradigm to higher-order
constructions [7] or to more permissive models of synchrony [8].
We present a formalization of this seminal paper in the Coq proof
assistant [4, 15]. For that purpose, we developed a general library for
cpos. Our cpos are deﬁned with an explicit function computing the least
upper bound (lub) of a monotonic sequence of elements. This is diﬀerent
from what Kahn developed for the standard Coq libraries where only
the existence of lubs is required, giving no way to explicitly compute a
ﬁxpoint. However, Kahn’s library was intended as the background for a
computer formalisation of the paper “Concrete Domains” by Kahn and
Plotkin [13] and it covers general cpos with the existence of a lub for
arbitrary directed sets whereas our work only considers ω-cpos with lubs
on monotonic sequences, which is a suﬃcient framework for modeling
Kahn networks.
We deﬁne a cpo structure for the type of possibly inﬁnite streams.
This is done using a coinductive type in Coq with two constructors,
one for adding an element in front of a stream, the second constructor
add a silent step Eps. From the structural point of view, our streams
are inﬁnite objects; this is consistent with the fact that these streams
are models for communication links which are continuously open even
if there is no traﬃc on the line. However, we identify the empty stream
with an inﬁnite stream of Eps constructors, so our data type models both
ﬁnite and inﬁnite streams. We deﬁne the preﬁx order on this data type
and the corresponding equality. We also develop useful basic functions:
the functions for head, tail and append used by Kahn [11], but also a
ﬁltering and a map function.
It is then possible to deﬁne formally what is a Kahn network and
what is its semantics, achieving the goal of having the concept closed
under composition and recursion. A Kahn network will be deﬁned by
a concrete set of edges corresponding to links in the network, each one
associated with the type of the objects which are transmitted on that
link. With each noninput edge is associated a node which is a continuous
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
385
function producing a stream of outputs from streams given as inputs.
This type of Kahn networks has a natural cpo structure. The semantics
of a Kahn network is obtained in the following way: we provide streams
for the input edges of the system, then the system is interpreted as an
equation on the streams corresponding to the traﬃc on all the edges, seen
as a continuous function. The semantics of the network is the ﬁxpoint
of this continuous function. We prove that this solution is a continuous
function both of the network and of the input streams. By selecting the
appropriate outputs, a system can be interpreted as a new node to be
used in another system. Furthermore, the continuity with respect to the
system itself gives the possibility of recursively deﬁning a system.
Our library is illustrated with an example taken from the original
paper as well as the Sieve of Eratosthenes, an example of a dynamic
network, recursively deﬁned.
Outline The remaining part of the introduction gives the main
notations used in this paper. Section 17.2 recalls Kahn’s approach
in [11], which introduces cpos as a natural structure for the semantics
of a simple parallel language. Section 17.3 introduces our deﬁnition of
cpo structures in Coq. It is based on a structure of ordered types. We
deﬁne the cpos of monotonic and continuous functions as well as several
constructions for product of cpos. Section 17.4 introduces the type of
possibly inﬁnite streams and deﬁnes a cpo structure on it (in particular
a lub function). We start with the simpler case of the ﬂat cpo. We deﬁne
a general function on the cpo of streams computing the value depending
on the head and tail of the stream (and giving the empty stream in case
the input is empty). We derive from this operator the constructions for
head, tail and append as well as functionals for mapping a function on
all elements of the stream or ﬁltering the elements of a stream with
respect to a boolean condition. We derive a cpo structure for natural
numbers as a particular case of streams. Section 17.5 deﬁnes a type for
Kahn networks and the associated semantics. Section 17.6 illustrates
our library with two examples, one taken from the original paper [11],
the other is the Sieve of Eratosthenes.
Notation In this paper, we use mathematical notations close to the
Coq notations.
The expression A →B represents both the type of functions from type
A to type B and the proposition: “A implies B”. The arrow associates
to the right: A →B →C represents A →(B →C).
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

386
C. Paulin-Mohring
The expression ∀x, P represents the proposition “for all x, P” or the
type of dependent functions which associate with each x an object of
type P. We can annotate a variable with its type and put several binders
as in ∀(x y : A)(z : B), P which represents the property: “for all x and
y of type A and z of type B, P holds”.
The function which maps a variable x of type A to a term t is written
fun x ⇒t or fun x : A ⇒t. We can introduce several binders at the same
time.
We write c x1 . . . xn
def
= t to introduce c as an abbreviation for the term
fun x1 . . . xn ⇒t. We write x = y for (polymorphic) deﬁnitional equality
in Coq (i.e. terms that are structurally equal). We use the notation
x == y for a speciﬁc equivalence relation associated with the type of x
and y, deﬁned as a setoid equality.1
We shall also use the Coq notation {x : A|P} for the type of pairs
(a, p) with a of type A and p a proof of P[a/x] and {x : A&{y : B|P}}
for the type of triples (a, b, p) with a of type A, b of type B and p a proof
of P[a/x, b/y].
17.2 From a simple parallel languages to cpos
In [11], Kahn proposes an algol-like language to describe parallel system.
Each process is deﬁned as a procedure with input and output parameters
which are interpreted as channels. In the body of the procedure, there
is a possibility to wait for a value on an input parameter or to send
a value on an output parameter. Global channels can be declared, the
processus can be instantiated and executed in parallel. The idea is that
each channel correponds to a ﬁfo in which values can be stored or read.
There is no bound on the size of the ﬁfo and a process can be blocked
waiting a value on an empty channel.
More precisely a Kahn network is built from autonomous computing
stations linked together. The stations exchange information through
communication lines. The assumptions are that a computing station
receives data from input lines, computes using its own memory and
produces result on some of the output lines. The communication lines
1 In Type theory, there is a natural polymorphic equality called the Leibniz equality
which corresponds to convertibility and which allows rewriting in an arbitrary
context. This equality is sometimes too strong. It is also possible to associate with
a type a speciﬁc equivalence relation. The type together with the relation is called
a setoid. The relation can be used pretty-much like an equality for rewriting, but
only under a context built using operators which are proved to preserve the setoid
relation. Coq oﬀers facilities to manipulate the setoids.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
387
are the only medium of communication between stations and the
transmission of data on these lines is done in a ﬁnite amount of time.
With each communication line, we associate the type of data which
transit on that line. Each node can use the history of the inputs to
produce an output, so it can be seen as a function from the streams
of inputs to the streams of outputs. This function is continuous, which
means that an output can be delivered without waiting for an inﬁnite
amount of information on the inputs lines.
A Kahn network is represented as an oriented graph. The nodes are
the computing stations and the edges are the communication lines. We
distinguish the input lines which have no source node. The graphical
representation of the example in Kahn’s paper is given in Figure 17.1.
h0
f
h1
g
Z
Y
T1
T2
X
Fig. 17.1. A simple example of Kahn network.
In Kahn semantics, we look at the sequence of values that will be sent
on each channel. This is a possibly inﬁnite sequence (a stream). Locally
each node is interpreted as a function taking as input a stream for each
input edge and computing a stream for each output edge.
The system itself will behave as the solution of a set of equations
deﬁning the stream of values on the channels (one equation for each
node). In our example, the system of equations will be:
X = f(Y, Z)
Y = h0(T1)
Z = h1(T2)
T1 = g1(X)
T2 = g2(X)
This is a recursive deﬁnition. In order to ensure the existence of a
solution, we use a cpo structure on the set of streams (with the preﬁx
order) and we prove that each node corresponds to a monotonic and
continuous function.
Now if we have a system and we distinguish input and output edges,
the solution is itself a continuous function from inputs to outputs so
behaves like a node. This is an essential property for a modular design
of systems. It gives also the possibility to recursively deﬁned a system,
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

388
C. Paulin-Mohring
like the Sieve of Eratosthenes which we describe in Section 17.6.2 and
which corresponds to the network in Figure 17.2.
fdiv
sift
app
X
Y
o
i
Fig. 17.2. A Kahn network for the Sieve of Eratosthenes.
The precise deﬁnition of nodes in the previous examples will be given
in Section 17.6.
17.3 Formalizing cpos constructively
The basic structure used for the interpretation of Kahn networks is the
ω-complete partial order. We developed a Coq library of general results
on ω-cpos.
17.3.1 Deﬁnition
An ω-cpo is a type D with a partial order ≤, a least element (usually
written ⊥) and a least-upper bound (written lubh) for any monotonic
sequence h of elements in D (h : nat →D such that ∀nm, n ≤m →
h n →h m).
An ω-cpo is actually a weaker structure than ordinary cpos where lubs
exist for any directed set of elements. However, ω-cpos are suﬃcient for
the construction of ﬁxpoints. In the following we refer to ω-cpos simply
as cpos.
17.3.1.1 Ordered structure
We deﬁne the type ord of ordered structures. An object in the type ord
is a dependent record with a type A, a binary relation ≤on A, and a
proof that this relation is reﬂexive and transitive.
An example of an ordered structure is the type nat of natural numbers
with the usual order. In the following, we shall abusively write nat for
the object of type ord corresponding to this structure.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
389
Notations When O is an ordered structure, we write x : O to mean
that x is an element of the carrier of O. The coercion mechanism in Coq
allows us to support this abuse of notation: whenever a type is expected
and an ordered structure O is provided, Coq automatically coerces the
term O to its carrier.
When O is an ordered structure and x, y : O, the Coq notation
mechanism allows us to write x ≤y to express that x and y are in the
relation associated with the ordered structure O. We shall write x ≤O y
when we want to make the ordered structure explicit.
Equality We deﬁne an equality on an ordered structure by:
x == y
def
= x ≤y ∧y ≤x;
this is obviously an equivalence relation.
Order on functions Given an ordered structure O and a type A, there
is a natural order on the type A →O of functions from A to O, called
the pointwise order, which is deﬁned by f ≤A→O g
def
= ∀x, f x ≤O g x.
We write A
o→O for the corresponding ordered structure.
Monotonic functions Given two ordered structures O1 and O2, we
introduce the type of monotonic functions from O1 to O2. Elements of
this type are records with a function f of type O1 →O2 (formally from
the carrier of O1 to the carrier of O2) and a proof that this function
is monotonic. With the pointwise order on functions, this type is an
ordered structure written O1
m
→O2.
If an object f has type O1
m
→O2, it is formally a pair with a function
and a proof of monotonicity. In Coq, we introduce a coercion from
f to a function from O1 to O2, such that we can write (f x) in a
way consistent with mathematical practice. We consequently have the
following property:
∀(f : O1
m
→O2)(x y : O1), x ≤y →f x ≤f y.
We also proved that any monotonic function preserves equality.
The composition of two monotonic functions is monotonic: when f :
O1
m
→O2 and g : O2
m
→O3, we deﬁne g@f of type O1
m
→O3 the
monotonic function such that (g@f) x = g (f x)
Notation fun x
m
⇒t. If t is an expression of type O2 depending on x of
type O1, we write fun x
m
⇒t for the object f in Coq of type O1
m
→O2,
which is a monotonic function such that f x = t. In Coq, the object
f is formally a pair built from the function fun x ⇒t and a proof
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

390
C. Paulin-Mohring
of monotonicity. The (informal) notation fun x
m
⇒t hides the proof of
monotonicity and helps us to insist on the functional behavior of f. In
our Coq development we try to systematically deﬁne objects in O1
m
→O2
using combinators like the composition of monotonic functions in order
to get proof of monotonicity for free relying on the type system. After
the deﬁnition of such an object f, we systematically prove a (trivial)
lemma f x = t which captures the functional behavior of the monotonic
function. This lemma is useful for rewriting the expressions involving f.
17.3.1.2 Cpo structure
A cpo structure is deﬁned as a record which contains:
• an ordered structure O;
• a least element ⊥of type O;
• a least upper-bound function lub for monotonic sequences;
the constant lub has type: (nat
m
→O) →O;
• proofs of the following properties:
– ∀x : O, ⊥≤x
– ∀(f : nat
m
→O)(n : nat), fn ≤lub f
– ∀(f : nat
m
→O)(x : O), (∀n, fn ≤x) →lub f ≤x.
A cpo structure is implicitly identiﬁed with the underlying ordered
structure. In particular, if D1 and D2 are two cpo structures, we can
write D1
m
→D2 for the ordered structure of monotonic functions from
D1 to D2.
Continuity It is easy to show from the properties of lub that given D1
and D2 two cpo structures, F : D1
m
→D2 a monotonic function from D1
to D2 and f a monotonic sequence on D1, we have
lub (F@f) ≤F (lub f)
We say that F is continuous whenever the other direction is true,
namely:
∀f : nat
m
→D1, F (lub f) ≤lub (F@f).
We write D1
c→D2 for the ordered structure of continuous functions.
When g has type D2
c→D3 and f has type D1
c→D2, we write g@ f
the element of D1
c→D3 which corresponds to the composition of f and
g, ie such that (g@ f) x = g (f x).
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
391
17.3.2 Cpo constructions
The structure of cpos is preserved by the usual constructions of functions
and products. In this part we show constructions for the cpos of
functions, monotonic functions and continuous functions as well as the
product of two cpos, of an arbitrary family of cpos and the k-times
product Dk of a cpo D.
17.3.2.1 Functional constructions
Given a cpo structure D and a type A, we can deﬁne a cpo structure on
the set of functions from A to D using a pointwise construction for ⊥
and lub:
⊥A→D
def
= fun x →⊥D
lubA→D h
def
= fun x ⇒lubD(fun n
m
⇒h n x)
We write A
O
→D for the cpo of simple functions from A to D.
Given an ordered type O, it is easy to show that ⊥O→D is a monotonic
function and that lub preserves monotonicity. So we have a cpo structure
written O
M
→D on the type of monotonic functions.
If D1 and D2 are two cpo structures, then because ⊥D1
m
→D2 is a
continuous function and lub preserves continuity, we also have a cpo
structure on continuous functions from D1 to D2. We write D1
C→D2
for this cpo structure.
17.3.2.2 Product constructions
We formalized other constructions on cpos corresponding to products.
Binary product The binary product D1 × D2 of two cpo structures
has a cpo structure written D1 ⊗D2.
⊥D1⊗D2
def
= (⊥D1, ⊥D2)
lubD1⊗D2 h
def
= (lubD1(fun n
m
⇒fst (h n)), lubD2(fun n
m
⇒snd(h n)))
The projection and pairing functions are continuous, we have deﬁned
• FST : ∀D1D2, D1 ⊗D2
C→D1
SND : ∀D1D2, D1 ⊗D2
C→D2;
• PAIR : ∀D1D2, D1
C→D2
C→D1 ⊗D2.
We also deﬁned functions for currying and uncurrying
• CURRY : ∀D1D2D3, ((D1 ⊗D2)
C→D3)
C→D1
C→D2
C→D3,
• UNCURRY : ∀D1D2D3, (D1
C→D2
C→D3)
C→(D1 ⊗D2)
C→D3.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

392
C. Paulin-Mohring
Indexed product  D For modeling Kahn networks, it is useful to
have a generalized product over an arbitrary number of cpos.
We take a set I of indexes and a family D of cpos indexed by I, that
is, D : I →cpo. The cpo structure for the product written  D is
just a dependent generalization of the function type I
o→D in which
the domain D may depend on the index. When D is a type expression
depending on a free variable i, we write 
i D for (fun i ⇒D)
• Carrier: ∀i : I, D i
• Order: x ≤ΠD y
def
= ∀i, x i ≤D i y i
• Least element: ⊥ΠD
def
= fun i ⇒⊥D i
• Least upper bound: lubΠD h
def
= fun i ⇒lubD i(fun n
m
⇒h n i).
The interesting constructions on that structure are listed here.
• A projection function PROJ of type: ∀i : I, ( D)
C→D i.
• Given two indexed families D and D′ over the set I, the mapping
MAPi of a continuous function on the elements of an indexed product
has type (∀i, Di
C→D′i) → D
C→ D′ and is deﬁned such that
MAPif p i = f i (p i).
• An operation to lift the indexes. Assume that we have two sets of
indexes I and J, a family D of cpos indexed by I, and a function
f : J →I. We deﬁne a continuous function LIFTi of type  D
C→

j D (f j) such that LIFTi p j = p (f j). It allows to select, reorganize
or duplicate the elements in the product.
Finite product Dk
It is also useful to have a ﬁnite product on the
same cpo D. Given k : nat, one possibility is to take the function space
{i|i < k}
O
→D, but in that case we will have to deal with the subset
type in Coq which is not always convenient. Instead we take the type
nat →D but instead of the pointwise order for functions, we introduce
an order up-to k: f ≤g
def
= ∀n, n < k →f n ≤g n. We write k →D for
the cpo structure with this order. The least element is deﬁned pointwise.
For the lub, there is a small diﬃculty. The natural deﬁnition would be:
lubk→D h n = lubD (fun p
m
⇒h p n)
But (fun p ⇒h p n) is monotonic only when n < k. However, the value
of lubk→D h n for k ≤n is meaningless so we can choose an arbitrary
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
393
one. Consequently we introduce h′ such that h′ p n = h p n when n < k
and ⊥otherwise. Then taking:
lubk→D h n = lubD (fun p
m
⇒h′ p n)
gives us the expected properties.
17.3.3 Fixpoints
Given a cpo structure D and a monotonic function F of type D
m
→D,
we can deﬁne a monotonic function (iter F) of type nat
m
→D such that
iterF 0 = ⊥and iter F (n + 1) = F (iter F n).
We deﬁne the ﬁxpoint of F as the least-upper bound of this sequence:
fixpF
def
= lub (iter F).
The constant fixp has type (D
m
→D) →D. It is itself a monotonic
function.
It is easy to show that fixpF ≤F (fixp F). The equality fixp F ==
F (fixp F) is provable under the assumption that F is a continuous
function.
We can also show that fixp is a continuous function from the cpo
(D
C→D) of continuous functions on D to D. Consequently, we are able
to deﬁne FIXP of type (D
C→D)
C→D, such that for all F of type D
C→D:
FIXPF = fixp (fun x
m
⇒F x)
FIXPF == F (FIXP F).
Scott’s induction principle We proved Scott’s induction principle. A
predicate is said to be admissible if it is true for the lub of a monotonic
sequence when it is true for all the elements of the sequence:
admissible P
def
= ∀f : nat
m
→D, (∀n, P (f n)) →P(lub f).
Scott’s induction principle states that when a predicate is admissible,
if it is true for ⊥and preserved by a monotonic function F : D
m
→D,
then it is true for the ﬁxpoint of F:
∀P, admissibleP →P ⊥→(∀x, P x →P (F x)) →P (fixpF)
Minimality It is easy to prove that the ﬁxpoint of a monotonic function
is the minimal solution for the equation. Namely:
∀(F : D
m
→D)(x : D), F x ≤x →fixpF ≤x.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

394
C. Paulin-Mohring
17.4 The cpo of streams
We now want to deﬁne a cpo structure for concrete data types. Before
developing the construction for streams, we show the simpler case of a
ﬂat cpo, which illustrates the main ideas.
17.4.1 The ﬂat cpo
The simplest nontrivial (i.e. not reduced to ⊥) cpo is the ﬂat domain.
Given a type A, we add an extra element ⊥and we have x ≤b if and
only if x = ⊥or x = b.
A natural solution could be to take as the carrier for this cpo the
option type on A with values either None or Some a with a : A.
Inductive option (A:Type) : Type :=
None :
option A | Some : A →option A
The constant None will be the least element. However we cannot deﬁne
constructively a least upper bound. Indeed, given an increasing sequence
of elements in our domain, we would have to decide whether all the
elements are ⊥in which case the lub is ⊥or if there exists an element
in the sequence which is of the form Somea in which case the lub is
this element. Because we follow a constructive approach in Coq where
functions correspond to algorithms, we cannot deﬁne a function which
takes such a decision.
The computation of lubs is possibly an inﬁnite process, a solution to
represent inﬁnite computations in Coq is to use coinductive types. This
is the approach taken by Capretta [6] for dealing with general recursive
functions in Coq. The solution is to introduce:
CoInductive flat (A:Type) : Type :=
Eps : flat A →flat A | Val : A →flat A
A value in type flat is either ﬁnite of the form
n



Eps (. . . (Eps(Val a)) . . .)
(written Epsn (Val a)) in which case it represents the value a (with extra
Eps steps corresponding to silent computations) or an inﬁnite object
Eps∞coinductively deﬁned by Eps∞= EpsEps∞corresponding to a
diverging computation.
Eps∞will be our least element and we need to identify all the represen-
tations of the value a ignoring the Eps constructors.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
395
In order to achieve that, we deﬁne co-inductively the order on the ﬂat
domain with these three rules:
x ≤y
Eps x ≤Eps y
x ≤Val a
Epsx ≤Vala
y = Epsn(Val a)
Val a ≤y
From this deﬁnition we proved reﬂexivity, transitivity and properties like
Eps∞≤x or Val a ≤x →x == Val a.
We can now look at the construction of lubs. We have a monotonic
sequence h of elements in flatA and we want (constructively) to build
the least upper bound which can be either ⊥or a value.
If x is an element of flatA, we write [x]n for the same element but
removing the n-th ﬁrst Eps constructors (or less if we ﬁnd a value before).
We have x == [x]n. Now in order to build the least upper bound, we
look at h 0. If we ﬁnd a value then we have our bound; if not, we produce
an Eps and we continue by looking at [h 0]1; [h 1]1 if we ﬁnd a value then
we are done, if the elements start with an Eps then we produce an Eps in
the least upper bound and we continue. At the n-th step we look at the
sequence [h 0]n; [h 1]n; . . . ; [h n]n, we try to ﬁnd a direct value, otherwise
we produce an Eps step and continue. This mechanism is illustrated in
Figure 17.3; the Coq formalization will be given in the more involved
case of streams. If one of the elements (h k) in the sequence is a value,
h 0
0
Eps
1
Eps
2
Eps
Eps∞
h1
Eps
Eps
Eps
Vala
h2
Eps
Vala
lubh
0
Eps
1
Eps
2
Vala
Fig. 17.3. Computation of lubs in a ﬂat domain.
then there exists n such that [h k]n = Val a so we will eventually ﬁnd
this value before the p-th step with k ≤p and n ≤p.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

396
C. Paulin-Mohring
17.4.2 Streams
We now look at the case of streams which is developed following the
same kind of reasoning.
17.4.2.1 Deﬁnition
The type of streams is co-inductively deﬁned as:
CoInductive Str (A:Type):Type :=
Eps : Str A →Str A | cons : A →Str A →Str A
As before Eps∞can be coinductively deﬁned by Eps∞= Eps Eps∞. It
represents the empty stream and is also our ⊥element. We deﬁne a
function [ ]n removing Eps in front of the stream by induction on n and
case analysis on the stream.
[s]0 = s
[Eps x]n+1 = [x]n
[consa x]n+1 = consa x
17.4.2.2 Order
The order we consider on streams is the preﬁx order, we must also ignore
the Eps steps which correspond to silent computations.
x ≤y
Eps x ≤y
[y]n = consa z
x ≤z
consa x ≤y
The idea is that in order to show that x ≤y, there are two cases: if x is
Epsx′ then we try to show x′ ≤y, if x is (consa x′) then after a ﬁnite
number of Eps, y should be of the form (cons a y′) and we need to show
that x′ is less than y′. We do not know how many Eps steps we should
remove so we cannot decide whether x ≤y or not, and similarly we
cannot decide whether a stream is ﬁnite or not. This corresponds well
to the vision of the streams as a model of asynchronous communication
links: it is not possible to know if more information will arrive and when.
If we want to transmit a ﬁnite number of elements, we have to decide
on a special character to indicate the end of the data.
Decidability of the empty stream is not required for the development
we want to perform and it is the price to pay for having an explicit
computation of lubs and ﬁxpoints.
We can prove the expected properties of the order besides reﬂexivity
and transitivity :
• Eps∞≤x
• ¬(consa x ≤Eps∞)
• consa x ≤consb y ↔a = b ∧x ≤y
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
397
Equality As in other ordered structures, equality on streams x == y is
deﬁned as x ≤y∧y ≤x. It is important to distinguish this equality from
intensional equality in Coq: x = y means that x and y are structurally
equal. For instance we have x == Eps x for all x while x = Eps x is only
true for the Eps∞stream.
Simulation properties Coinductive deﬁnitions in Coq correspond to
greatest ﬁxpoints. The primitive way to build a proof of x ≤y is to
use ﬁxpoint deﬁnitions in Coq, which should be guarded. This guarded
condition is very syntactic and not always convenient to use in tactics.
An alternative way is to deﬁne a co-induction principle which in this
case corresponds to a simulation principle.
We introduce a principle which does not rely on the intensional
representation of streams. We have to ﬁnd a relation R on streams that
is compatible with equality on streams and such that when R x y holds
and x is equal to a stream consa x′ then y is also equal to consa y′ and
R x′ y′ also holds. If such an R exists then it is included in the relation
≤on streams. This principle can be written as follows:
∀x y z t, x == z →y == t →R x y →R z t
∀a x y, R (cons a x) y →∃z, y == consa z ∧R x z
∀x y, R x y →x ≤y
From this we can derive a principle which says that in order to prove x ≤
y, it is enough to prove it in the particular case where x == consa x′.
This principle is in practice suﬃcient in order to avoid reasoning on
whether x is the empty stream or not.
17.4.2.3 Least upper bounds
Destructuring
streams We
introduce
a
predicate
is cons
on
streams. It is deﬁned as an inductive predicate with two constructors
is consx →is cons (Eps x) and is cons (consa x). We can prove
that is consx is equivalent to ∃a s, x == consa s.
In Coq is cons is a noninformative proposition: we know the existence
of a and s but we cannot use a and s to compute a value. However, if
we know that a stream contains a cons constructor, the algorithm that
removes Eps constructors will eventually stop on a cons constructor. In
Coq, we deﬁned a function uncons of type:
∀x, is cons x →{a : A&{s : Str A|x == consa s}}.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

398
C. Paulin-Mohring
From the computational point of view, this function takes a (nonempty)
stream as input and returns a pair (a, s) of its head and tail plus the
proof that x == consa s. Technically, the function uncons is deﬁned in
Coq by a ﬁxpoint doing a structural induction on the proof of (is consx)
and a case analysis on the structure of x.
Building lubs The construction of lubs for monotonic sequences of
streams is a generalization of the idea used in the case of ﬂat domains.
Consider a monotonic sequence h of streams, and a natural number
n. We can look at the ﬁrst constructor of h 0 . . .h (n −1). Either we
only have Eps steps or there exists m < n such that h m = consa s.
In this last case, the lub will start by cons a and we know that for all
p ≥m, the stream h p is equal to consa s′ (because h m ≤h p) such that
we can extract a subsequence of h corresponding to the tails of h p and
recursively ﬁnd the lub of this sequence. Following this idea, we built a
function fCon which takes as argument a sequence of stream h and a
natural number n and either answers that all h m starts with Eps for
all m < n or ﬁnd an element a and another sequence h′ such that there
exists m < n such that each h (k + m) is equal to consa (h′ k). Formally
the Coq type of fCon is:
∀(h : nat
m
→StrA)(n : nat),
{a : A & {h′ : nat
m
→Str A|
∃m, m < n ∧∀k, h (k + m) == cons a (h′ k)}}
+ {∀m, m < n →h m = Eps( )}
This function is deﬁned by structural recursion on n.
We write [h]
def
= fun n
m
⇒[h n]1 for the sequence h where we have
removed the ﬁrst Eps step of each stream, our lub function is deﬁned
with a coﬁxpoint:
CoFixpoint lubn (h:nat
m
→Str A) (n:nat) : Str A :=
match fCon h n with
(a,h’,_) ⇒cons a (lubn h’ 1)
|
⇒Eps (lubn[h] (n+1))
end
This recursive function is accepted by Coq because it is a guarded
ﬁxpoint: any recursive call in the body appears under a constructor of
the type of streams.
The lub of a stream sequence h is just deﬁned as (lubnh 1). We proved
that this is the lub of the sequence of streams.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
399
17.4.2.4 Useful functions on streams
In his paper, Gilles Kahn introduced several functions to manipulate
streams: taking the ﬁrst element, the stream without the ﬁrst element
or the concatenation of the ﬁrst element of a stream to another.
All these functions are proved to be continuous. In our development,
we derive them from the more general scheme of a function from streams
to streams deﬁned by case analysis on the structure of the input stream.
If the input is equal to consa x then the result is computed from a and
x by a given function F, if it is Eps∞then the result is Eps∞.
Let a parameter function F have type A →StrA
m
→StrB. The
function that we named case is coinductively deﬁned by:
caseF (Eps x) = Eps (caseF x)
caseF (consa x) = F a x
It is easy to check that caseF ⊥== ⊥and that x == consa y →
caseF x == F a y.
When F is a continuous function of type A →StrA
C→StrB, then
case(fun a s
c⇒F a s) is also a continuous function of type StrA
C→
StrB. The case construction is also continuous with respect to the
argument F, such that we can build CASE of type (A
O→StrA
C→
StrB)
C→StrA
C→StrB.
From this scheme, we derive the following functions:
• first has type Str A →Str A and is deﬁned by:
first
def
= case(fun a s
m
⇒consa ⊥)
• rem has type Str A →StrA and is deﬁned by:
rem
def
= case(fun a s
m
⇒s)
• app has type Str A →StrA →StrA and is deﬁned by:
appx y
def
= case(fun a s
m
⇒consa y) x.
We remark that app x y only takes the ﬁrst element of x, and adds
it in front of y. It corresponds to the “followed by” operation in
synchronous data-ﬂow languages and not to the usual append function
on lists which cannot be deﬁned in that framework.
We also build their continuous versions: FIRST and REM of type StrA
C→
StrA and APP of type Str A
C→Str A
C→Str A
We proved the properties which are given by Kahn [11]:
first⊥== rem ⊥= app ⊥x == ⊥
firstx == appx ⊥
x == app (firstx) (rem x)
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

400
C. Paulin-Mohring
Instead of x == ⊥∨rem (app x y) == y in Kahn [11], we proved that
is consx →rem(app x y) == y.
We also proved that app (firstx) y == app x y.
Bisimulation revisited Using the rem function, it is possible to
express a bisimulation principle. In order to prove that two streams are
equal, it is suﬃcient to ﬁnd a relation R which is stable by equality,
which implies equality on ﬁrst elements and is preserved by remainders
for nonempty streams. Such a relation R is included in equality:
∀D (R : Str A →Str A →Prop),
(∀x1 x2 y1 y2, R x1 y1 →x1 == x2 →y1 == y2 →R x2 y2)
→(∀x y, (is cons x ∨is consy) →R x y →firstx == firsty)
→(∀x y, (is cons x ∨is consy) →R x y →R (rem x) (rem y))
→∀x y, R x y →x == y.
17.4.2.5 Mapping and ﬁltering
Mapping A useful functional on streams is to apply a function F :
A →B to any element of a stream of A in order to obtain a stream of
B.
We easily build this function using our ﬁxpoint construction and case
analysis.
We ﬁrst build a function Mapf of type (Str A
C→Str B)
C→A
O→
StrA
C→StrB such that Mapff a s = cons(F a) (f s).
Then we introduce MAP
def
= FIXP(CASE@ Mapf) of type StrA
C→
StrB and map the underlying function of type StrA →Str B. From
the properties of FIXP, CASE and Mapf, we obtain easily the expected
equalities:
map ⊥== ⊥
map (consa s) == cons(F a) (map s).
Of course, we could have deﬁned map directly in Coq using a guarded
ﬁxpoint (a ﬁxpoint where recursive calls are directly under a constructor)
on the co-inductive type Str A which satisﬁes the following equations:
map (Eps x) = Eps (map x)
map (cons a x) = cons(F a) (map x)
Proving monotonicity and continuity of this function requires speciﬁc
co-recursive proofs. Our deﬁnition using FIXP and CASE gives us these
results directly without extra work.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
401
Our technique applies to recursive deﬁnitions of functions on streams
which do not directly correspond to guarded ﬁxpoints like the filter
function.
Filtering Filtering is an operation that selects elements of a stream that
satisfy a given (decidable) property P. This operator has been widely
studied because it is the typical example of a nonguarded deﬁnition on
co-inductively deﬁned inﬁnite streams.
Using p of type A →bool to decide the property P, a deﬁnition in
an Haskell-like language would be:
filterp (consa s) = if p a then consa (filterp s) else filterp s
The problem is that if P only holds on a ﬁnite number of elements of
the stream then the output is ﬁnite and there is no way to decide that.
Bertot [3] proposes a solution where there is an inductive proof that
P holds inﬁnitely many times in the input and this is used to produce
an inﬁnite stream as output. An alternative solution is to produce as
output an inﬁnite stream of values which are either a real value or a
dummy constant.
With our representation of streams, we can simply deﬁne the stream
in a similar way as for the map function using case analysis and ﬁxpoint.
We introduce Filterfp of type (Str A
C→Str A)
C→A
O
→Str A
C→
StrA such that Filterfp f a s = if p a then consa (f s) else f s.
Then we introduce FILTERp
def
= FIXP(CASE@ (Filterfp)) of type
StrA
C→Str A and (filter p) the corresponding function of type
StrA →StrA. We easily check the expected property:
filterp (cons a s) == if p a then consa (filterp s) else filterp s
17.4.2.6 Finiteness
We can deﬁne what it means for a stream to be ﬁnite or inﬁnite. As
usual, inﬁnity is deﬁned co-inductively and ﬁniteness is an inductive
predicate. We deﬁned them the following way:
Inductive finite (s:StrA) : Prop :=
fin bot : s ≤⊥→finites
| fin cons: finite(rem s) →finites.
CoInductive infinite (s:StrA) : Prop :=
inf intro : is cons s →infinite(rems) →infinites.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

402
C. Paulin-Mohring
We were able to prove
• s ≤t →infinites →infinitet
• s ≤t →finitet →finites.
This property is not provable if we take a diﬀerent version of finite
with an extra hypothesis (is conss) in the constructor fin cons.
With such a deﬁnition of finite, a proof of finitet is isomorphic
to the number of cons in t. Assuming s ≤t, a proof of finites
should give us the exact number of elements in s, but there is no way
to explicitly compute this number. With our deﬁnition of finite, a
proof of finites just gives us an upper bound of the number of cons
in the stream and is consequentely compatible with the order on the
streams.
• finites →¬infinites
17.4.3 The particular case of natural numbers
We put an ordered structure on the type nat of natural numbers but
this is not a cpo because there is no lub for the sequence h n = n. If
we want a cpo structure, we need to add an inﬁnite element. One way
to deﬁne a cpo for natural numbers reusing our previous library is to
take the type of streams on the trivial type unit with only one element
tt : unit. The 0 element will be Eps∞as before, the successor function
will be S x
def
= constt x. We can deﬁne the top element S∞with the
coﬁxpoint S∞= S S∞and prove ∀x, x ≤S∞.
We write Nat for this cpo. There is an obvious monotonic function
from nat to Nat.
This domain is used in order to deﬁne the length function from
StrA to Nat. It is just an application of the map construction with the
functional fun a ⇒tt. We were able to show the following properties:
• ∀s : StrA, infinite(lengths) ↔infinites
• ∀n : Nat, S n ≤n →infiniten
In the case of streams, we deﬁned the append of streams x and y,
just taking the ﬁrst element of x (if it exists) and putting it in front
of y. There is no way to deﬁne the usual append function on lists such
that the concatenation of the empty stream and y is y, because we never
know if x is empty by just looking at a ﬁnite preﬁx.
The situation is a bit diﬀerent for the cpo of natural numbers where
the concatenation corresponds to addition. When trying to add x with
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
403
y we might look alternatively at the head part of x and y. Whenever we
ﬁnd a successor, we can produce a successor on the output. If one of x
or y is 0 then we will always ﬁnd Eps step on this input and the output
will be equal to the other argument with just extra Eps steps inserted.
Following this idea, we have been able to deﬁne the addition as a
continuous function on Nat and prove that it is commutative and that
addn 0 == n.
17.5 Kahn networks
We shall now explain our representation of Kahn networks in Coq.
17.5.1 Representing nodes
We deﬁne a shallow embedding of nodes. A node with inputs of type
A1, . . . , An and outputs in types B1, . . . , Bp is a continuous function of
type 
i Str Ai
C→
j Str Bj.
In general we allow arbitrary sets of indexes I for inputs and J for
outputs. We associate with each index a type family A : I →Type and
B : J →Type, a node of signature A B is an element of 
i Str (A i)
C→

j Str (B j).
We distinguish the particular case of a simple node with only one
output. Given a set of indexes I for inputs, a type family A : I →Type
and a type B, we deﬁne a simple node of signature A B to be an element
of 
i Str (A i)
C→Str B.
A node with several outputs can just be seen as a set of simple nodes,
each one corresponding to the projection on the corresponding output.
17.5.2 Representing systems
We start from a concrete set of edges and we distinguish input edges
(given by a type I) from the other ones (given by a type J). We consider
all the noninput edges to be output edges, it is not relevant for the
system which outputs we want to observe.
We associate with each edge a type, so we have a type family A :
I + J →Type. The type I + J is the disjoint union of I and J. We write
(l i) (resp. (r j)) for the element of I + J associated with i : I (resp.
j : J).
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

404
C. Paulin-Mohring
We deﬁne SA
def
= fun i ⇒Str (A i) the type family indexed by I + J
of streams of elements of type A i and SAI
def
= fun i ⇒SA (l i) the type
family indexed by I associated with the inputs.
Now each edge which is not an input edge has a source which is a
node. Actually each edge is associated with one particular output of the
source node. We already mentioned that a general node with n outputs
is equivalent to n simple nodes.
In our model, each noninput edge is associated to one simple node (its
source).
A simple node in general is a function f of type 
k∈K StrA′
k
C→
StrB. We have to link the inputs of the node (indexed by K) with
the edges of the system. This corresponds to producing a function σ :
K →(I + J) which is compatible with the type system (i.e. A′
k is
convertible with A (σ k)). Given f and σ, we could use the DLIFTi
operation introduced in Section 17.3.2.2 in order to build a function f ′
of type  SA
C→Str B, which can also be seen as a simple node but
taking all the edges of the system as input.
Instead of introducing for each node the extra level of indirection with
the set K and the map σ : K →(I + J), we directly consider that an
output edge is associated with a (simple) node of the system which is a
continuous map taking all streams associated with an edge as input, i.e.
an element of  SA
C→Str B. This gives us a very simple and uniform
deﬁnition of the type of systems that we describe now.
A system with input edges I and output edges J of type A : I + J →
Type is an object of type:
systemA
def
= ∀j : J, (

SA)
C→Str (A (r j))
The set of systems has a cpo structure corresponding to an indexed
product 
j( SA
C→Str (A (r j))).
Equation associated with a system A system deﬁnes an equation
on the streams associated with the edges, provided we give values for
the input edges.
Formally if we have a system s on a type family A : I + J →Type as
before and an input inp which is a product of streams on I such that inp
has type  SAI, then we can deﬁne the set of equations as a continuous
function (EQN of systems inp) of type  SA
C→ SA such that
EQN of systems inp X (l i) = inp i
EQN of systems inp X (r j) = s j X
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
405
Taking the ﬁxpoint of this function gives us the output observed on all
the edges.
This function EQN of system is monotonic and continuous with
respect to both the system and the input arguments. It has type:
systemA
C→ SAI
C→( SA
C→ SA).
The solution of this equation for a system s and an input inp is
obtained by taking the ﬁxpoint of the functional (EQN of systems inp).
It is still a continuous function both of the system of the inputs, so we
obtain for each system s, a new node SOL of systems of type ( SAI)
C→
( SA) such that:
SOL of systems inp == EQN of systems inp (SOL of systems inp).
Now if we are only interested by a subset O of the output nodes, we
use a mapping π : O →J and we use again the lift function in order to
restrict our solution to a node indexed by I for inputs and O for outputs
of type ( SA)
C→(
o:O SA (r (π o))).
In the examples, we shall only be interested by one output o : J which
is simply obtained by applying SOL of systems inp to (r o).
17.5.3 Remarks
There are a few diﬀerences between our formalization and Kahn’s
original deﬁnition [11].
• Kahn deﬁned a node as a continuous function, associated with edges
for its inputs and outputs. In our formalism, we have the association
between the edges and the output of a node but nothing on the link
between the input of the node and the edges. The nodes are implicitly
related to all edges. In practice, as we shall see in the examples, we
shall start with a node deﬁned as a continuous function with the
appropriate number of arguments corresponding to the number of
input edges in the node. Then, when deﬁning the system, we simply
project the relevant edges of the system on the corresponding inputs
of the node.
• A noninput edge in our systems has one source node but may have
several target nodes. This avoids the explicit use of duplication nodes
which is discussed as a possible harmless extension in Kahn [11].
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

406
C. Paulin-Mohring
17.6 Examples
17.6.1 A simple example
We illustrate our approach with the same running example as in
Kahn [11].
17.6.1.1 Deﬁnition
We ﬁrst draw in Figure 17.4 the graphical scheme corresponding to the
network.
h 0
f
h 1
g
Z
Y
T1
T2
X
Fig. 17.4. A simple example of Kahn network.
The edges are X, Y , Z, T1, and T2. There is no input edge so the
set I is deﬁned as the empty type. The set J is an enumerated set with
elements X, Y , Z, T1, and T2. All the links contain values in type nat
such that the type family A : I + J →Type is deﬁned by A k = nat and
we have SA k = Strnat.
The functions corresponding to the nodes are f, g and h. The node g
has two outputs corresponding to the functions g1 and g2. They satisfy
the equations:
• f U V = app U (app V (f (remU) (rem V )))
• g1 U = appU (g1 (rem (rem U)))
• g2 U = app(rem U) (g2 (rem (rem U)))
• h n U = consn U
In Kahn [11], the equations involve an extra first application in the ﬁrst
argument of app, but because we proved: app (firstx) y == app x y,
we can eliminate it.
In order to deﬁne these nodes, we use the ﬁxpoint construction and
the composition of the (continuous) functions app, rem and cons on
streams.
The system itself (called sys) is translated from the scheme in the
Figure 17.4 which can also be seen as the set of equations:
X = f Y Z
Y = h 0 T1
Z = h 1 T2
T1 = g1 X
T2 = g2 X
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
407
In Coq, sys is a function from J to the continuous functions from
 SA
C→Str nat. Given p of type  SA, we have:
• sysX p = f (p (r Y )) (p (r Z))
• sysY p = h 0 (p (r T1))
• sysZ p = h 1 (p (r T2))
• sysT1 p = g1 (p (r X))
• sysT2 p = g2 (p (r X))
Now the resulting stream (called result) of type (Str nat) is obtained
the following way:
(i) The solution sol of the system sys has type  SAI
C→ SA.
(ii) Because I is empty, the type SAI containts a trivial element inp,
we apply sol to inp and get an object of type  SA.
(iii) The object solinp X that is the projection of the previous system
on the link X is the expected result.
17.6.1.2 Properties
Kahn’s paper proves that the result is an inﬁnite stream containing
alternatively 0 and 1. For that he proves: result == cons0 (cons1 result).
This is done in two steps, ﬁrst he proves that result satisﬁes the
following ﬁxpoint equation:
result == cons0 (cons1 (f (g1 result) (g2 result)))
then proves that f (g1 s) (g2 s) == s.
The ﬁrst equation is a consequence of two general properties of
ﬁxpoints.
(i) A ﬁxpoint on a continuous function is stable by composition:
FIXPf == FIXP (f@ f) == FIXPf n+1.
This is a consequence of a general lemma about ﬁxpoint of
composition of continuous functions:
∀(f g : D
C→D),
g@ f ≤f@ g →f (FIXPg) ≤FIXP g →FIXP(f@ g) == FIXPg
(ii) Fixpoint on products can be simpliﬁed when the output on an
index i depends only on the input on the same index i:
∀(I : Type)(D : I →cpo)(F :  D
C→ D)(i : I)(Fi : D i
C→D i),
(∀p :  D, F p i == Fi (p i)) →FIXPF i == FIXPFi.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

408
C. Paulin-Mohring
We take the equation EQN sys of type  SA
C→ SA associated with
the system sys together with the empty input stream and we compose
it three times. We obtain the equation:
EQN sys3 p (r X) = f (h 0 (g1 (p (r X)))) (h 1 (g2 (p (r X)))).
Consequently the stream result which is the ﬁxpoint of EQN sys on the
output X is also the ﬁxpoint of EQN sys3 on the output X and is also the
ﬁxpoint of FX with FX s = f (h 0 (g1 s)) (h 1 (g2 s)). Using the deﬁnition
of f and h, it is easy to see that: FX s == cons 0 (cons1 (f (g1 s) ( g2 s)).
What remains to be proved is that ∀s, f (g1 s) (g2 s) == s. Kahn’s
paper uses a structural induction which is not appropriate because the
stream s is possibly inﬁnite. Instead we use a bisimulation technique.
We use a variation of the bisimulation principle given in Section 17.4.2.4
which is:
∀D (R : Str A →Str A →Prop),
(∀x1 x2 y1 y2, R x1 y1 →x1 == x2 →y1 == y2 →R x2 y2)
→(∀x y, (is cons x ∨is consy) →R x y →firstx == firsty)
→(∀x y, (is cons (rem x) ∨is cons(rem y)) →
R x y →first(rem x) == first(rem y))
→(∀x y, (is cons (rem x) ∨is cons(rem y)) →
R x y →R (rem (rem x)) (rem (rem y)))
→∀x y, R x y →x == y.
We instantiate this principle by the relation R s t
def
= t == f (g1 s) (g2 s).
The proof is based on algebraic properties of f, g1, g2, rem, and first.
We end up with the expected property result = cons 0 (cons1 result)
from which we deduce that result is an inﬁnite stream because its
length is inﬁnite.
17.6.2 Sieve of Eratosthenes
The scheme corresponding to the sieve of Eratosthenes is given in
Figure 17.2 in Section 17.2. What is interesting is that it is a recursive
scheme. The scheme deﬁnes a node sift which is used as an internal
node in the scheme itself. This is done using a ﬁxpoint construction
which is possible because the interpretation of a scheme is a continuous
function of the nodes themselves.
The node fdiv is easily built using case and filter such that:
fdiv (cons a s) = filter(diva) s
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
409
We introduce the input index type I which is just a type with one
element i and the output index type J which contains three elements
X, Y and o. All the links have type nat, so using the same notation as
before we introduce A : I + J →Type, SA : I + J →cpo, SAI : I →cpo
such that A k = nat, SA k = Strnat and SAI i = Strnat.
We deﬁne the functional Fsift associated with the recursive system
which has type (Str nat
C→Str nat)
C→systemA and is deﬁned by case
on the output link with p of type  SA:
Fsiftf X p = fdiv(p (l i))
Fsiftf Y p = f (p (r X))
Fsiftf o p = app (p (l i)) (p (r Y ))
The construction SOL of system introduced in Section 17.5.2 gives
us a continuous function from systems to functions of type  SAI
C→
 SA from the streams corresponding to input edges to the streams
corresponding to all edges.
The composition of SOL of system with Fsift gives us a continuous
function from (Str nat
C→Strnat) to  SAI
C→ SA.
Now the recursive graphical construction of the system says that sift
is the functional corresponding to the input i and the output o.
Using pair1 (the continuous trivial function from D to 
i∈I D when
I has only one element), it is easy to build a continuous function focus
of type ( SAI
C→ SA)
C→Str nat
C→Str nat such that focush s =
h (pair1s) o.
The composition of focus, SOL of system and Fsift is now a
continuous function from (Str nat
C→Str nat) to (Str nat
C→Str nat).
We introduce sift as the ﬁxpoint of this operator.
We can prove, using the ﬁxpoint equation for sift, the following
equality:
sift == focus(SOL of systemA (Fsift sift)).
Using the ﬁxpoint equation for: SOL of systemA (Fsiftsift), it is easy
to derive successively the following equalities for all stream s:
• SOL of systemA (Fsiftsift) (pair1 s) (l i) == s.
• SOL of systemA (Fsiftsift) (pair1 s) (r X) == fdivs.
• SOL of systemA (Fsiftsift) (pair1 s) (r Y ) == sift(fdiv s).
• SOL of systemA (Fsiftsift) (pair1 s) (r o) == apps (sift(fdiv s)).
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

410
C. Paulin-Mohring
From these equalities, the property of fdiv, and the ﬁxpoint equality
for sift we easily deduce the expected property of sift:
sift (consa s) == consa (sift (filter(div a) s))
sift⊥== ⊥
17.7 Conclusion
17.7.1 Contributions
This paper describes three contributions.
The ﬁrst one is a general Coq library for ω-cpos. This is a constructive
version of cpos where there is an explicit function to build the least-upper
bound of any monotonic sequence. It contains useful constructions such
as generalized products, cpos of monotonic and continuous functions
and combinators to manipulate them. It also introduces a ﬁxpoint
combinator. This library has also been used in a Coq library for modeling
randomized programs as distributions [1, 2].
The second contribution is the deﬁnition of the cpo of streams of
elements in a type A. This type, deﬁned co-inductively, covers both the
case of ﬁnite and inﬁnite streams but without any explicit way to decide
if the stream is ﬁnite or not. The type itself is not very original, it
corresponds to an inﬁnite stream with values which can be present or
absent. What is interesting is the order deﬁned on that data structure
and the derived equality. Modulo this equality, we are able to reason
on this data structure by only considering the interesting cases where
the streams are equal to (cons a s). The most diﬃcult construction
on the type of streams was the least-upper bound. The ﬁxpoint given by
the cpo structure makes it possible to deﬁne in a natural way a function
like filter that selects the elements of a stream satisfying a predicate
P. This function is problematic with most representations of streams
in Coq because the output can be ﬁnite or inﬁnite depending on the
number of elements in the input which satisﬁes P.
The last contribution is the modeling of Kahn networks as they are
described in the paper [11]. We chose a shallow embedding where a
system is represented using a set of links and for each noninput link a
continuous function corresponding to the node. Each node can possibly
take as input all the links of the system. This leads to a very simple and
uniform deﬁnition of systems which itself can be seen as a cpo.
A system together with streams for inputs deﬁnes a continuous
function on the streams associated with the links of the system (the
history of the system). The ﬁxpoint of this function deﬁnes the behavior
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
411
of the system as a continuous function both from the inputs and the
system.
Using this interpretation, we were able to formalize both the main
example given by Kahn [11] and the sieve of Eratosthenes, an example
of a recursive scheme which was presented by Kahn and MacQueen [12].
17.7.2 Remarks
Coq
development The Coq development runs with Coq version
8.1 [15]. It makes an intensive use of the new setoid rewriting tactic. It
is available from the author’s web page. It contains approximately 1700
lines of deﬁnitions and statements and 3000 lines of proofs. The Coq
notation mechanism as well as implicit arguments makes it possible to
keep notations in Coq quite similar to the ones used in this paper.
What is mainly missing is a syntactic facility in order to automatically
build complex continuous functions by composition of simpler functions
and functionals.
Synchronous case As we mentioned before, one important application
of Kahn networks is their restriction to synchronous languages where no
buﬀer is needed to store the values on the links. The nodes receive the
inputs at a regular time given by a clock and instantaneously produce
an output. A denotational semantics of this calculus in Coq was given by
Boulm´e and Hamon [5]. Their approach is to make the type of the stream
dependent on the clock (which is an inﬁnite stream of boolean values),
so there is a control on which data is available or not. They do that by
considering ordinary inﬁnite streams (only the cons constructor) with
values which can either be an ordinary value in the type A of elements,
or an absent value (when the clock is oﬀ) or a failure (no value when
the clock is on).
We could adapt our development to this particular case by extending
the deﬁnition of streams to make them dependent on the clock.
CoInductive Str A :clock →Type :=
Eps : ∀c, Str A c →Str A (false::c)
| cons : ∀c, A →Str A c →Str A (true::c)
Then in order to deﬁne the bottom element of a stream on a clock c, it
is convenient to have a bottom element in the type A. So the natural
framework is to consider a cpo structure on A. Then the order on the
streams can be deﬁned in the following way (the clock argument of
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

412
C. Paulin-Mohring
constructors Eps and cons can be derived from the type of the stream
so it is left implicit in the Coq notation).
x ≤y
Eps x ≤Epsy
a ≤b
x ≤y
consa x ≤consb y
It is simpler than in our case because we know exactly where the cons
constructors are. The construction of lubs is also simpliﬁed, when the
clock is true, there is a cons constructor in each element of the sequence
of streams, we produce a cons constructor in the output with a value
corresponding to the lub of the heads. However, some extra properties
have to be proved on the sequence if we want to ensure that there is no
cons⊥left in the result.
Equations Kahn’s paper refers to the paper of Courcelle, Kahn and
Vuillemin [9] which proves the decidability of equivalence in a language
of ﬁxpoints.2 We started to write a Coq version of this paper and in
particular we deﬁned the notion of terms and built the cpo corresponding
to the canonical interpretation of equations built on sequences of terms.
But the full formalization of this part still remains to be done.
Bibliography
[1]
P. Audebaud and C. Paulin-Mohring. Proofs of randomized algorithms in
Coq. In T. Uustalu (ed.) Mathematics of Program Construction, MPC 2006,
volume 4014, Lecture Notes in Computer Science, Kuressaare, Estonia, July
2006. Springer-Verlag, 2006.
[2]
P. Audebaud and C. Paulin-Mohring. Proofs of randomized algorithms
in Coq. To appear in Science of Computer Programming. Extended version
of [1].
[3]
Y. Bertot. Filters on coinductive streams, an application to Eratos-
thenes’sieve. In P. Urzyczyn (ed.) International Conference of Typed Lambda
Calculi and Applications, volume 3461, Lecture Notes in Computer Science,
pp. 102–115. Springer-Verlag, 2005.
[4]
Y. Bertot and P. Cast´eran. Interactive Theorem Proving and Program
Development. Springer-Verlag, 2004.
[5]
S. Boulm´e and G. Hamon. Certifying synchrony for free. In International
Conference on Logic for Programming, Artiﬁcial Intelligence and Reasoning
(LPAR), volume 2250, Lecture Notes in Artiﬁcial Intelligence, La Havana,
Cuba, December 2001. Springer-Verlag, 2001. Short version of A clocked
denotational semantics for Lucid-Synchrone in Coq, available as a Technical
Report (LIP6), at www.lri.fr/∼pouzet.
2 Editor’s note: this article is reproduced in this book.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

Kahn networks in Coq
413
[6]
V. Capretta. General recursion via coinductive types. Logical Methods in
Computer Science, 1(2:1):1–28, 2005.
[7]
P. Caspi and M. Pouzet. Synchronous Kahn Networks. In ACM SIGPLAN
International
Conference
on
Functional
Programming,
Philadelphia,
Pensylvania, May 1996.
[8]
A. Cohen, M. Duranton, C. Eisenbeis, C. Pagetti, F. Plateau and
M. Pouzet. N-Synchronous Kahn networks: a relaxed model of synchrony
for real-time systems. In ACM International Conference on Principles of
Programming Languages (POPL’06), Charleston, South Carolina, USA,
January 2006.
[9]
B. Courcelle, G. Kahn and J. Vuillemin. Algorithmes d’´equivalence et de
r´eduction `a des expressions minimales dans une classe d’´equations r´ecursives
simples. In J. Loeckx (ed.) Automata, Languages and Programming,
volume 14, Lecture Notes in Computer Science, pp. 200–213. Springer-
Verlag, 1974. Translation from French by T. Veldhuizen with original text,
a few comments and additional references.
[10]
N. Halbwachs, P. Caspi, P. Raymond and D. Pilaud. The synchronous
dataﬂow
programming
language
lustre.
Proceedings
of
the
IEEE,
79(9):1305–1320, 1991.
[11]
G. Kahn. The semantics of a simple language for parallel programming.
In Information Processing 74. North-Holland, 1974.
[12]
G. Kahn and D. MacQueen. Coroutines and networks of parallel
processes. In B. Gilchrist (ed.) Information Processing 77. North-Holland,
1977.
[13]
G. Kahn and G. D. Plotkin. Concrete domains. Theoretical Computer
Science, 121(1& 2):187–277, 1993.
[14]
D. Pilaud, P. Caspi, N. Halbwachs and J. Plaice. Lustre: a declarative
language for programming synchronous systems. In 14th ACM Conference
on Principles of Programming Languages, pp. 178–188, Munich, January
1987.
[15]
The Coq Development Team. The Coq Proof Assistant Reference Manual
– Version V8.1, July 2006. http://coq.inria.fr.
https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

https://doi.org/10.1017/CBO9780511770524.018 Published online by Cambridge University Press

