Zoran Majkić
Intensional First-Order Logic

Also of Interest
Knowledge Engineering for Modern Information Systems
Methods, Models and Tools
Sharma, Kautish, Agrawal, Madaan, Gupta, Nanda (Eds.), 2022
ISBN 978-3-11-071316-9, e-ISBN 978-3-11-071363-3
Noise Filtering for Big Data Analytics
Bhattacharyya, Ghosh (Eds.), 2022
ISBN 978-3-11-069709-4, e-ISBN 978-3-11-069721-6
Big Data Analytics Methods
Analytics Techniques in Data Mining, Deep Learning and Natural
Language Processing
Ghavami, 2019
ISBN 978-1-5474-1795-7, e-ISBN 978-1-5474-0156-7
Big Data Management
Data Governance Principles for Big Data Analytics
Ghavami, 2020
ISBN 978-3-11-066291-7, e-ISBN 978-3-11-066406-5
Advanced Data Management
For SQL, NoSQL, Cloud and Distributed Databases
Wiese, 2015
ISBN 978-3-11-044140-6, e-ISBN 978-3-11-044141-3

Zoran Majkić
Intensional
First-Order Logic
|
From AI to New SQL Big Data

Author
Zoran Majkić
Via Palestro 13
00185 Rome
Italy
majk.1234@yahoo.com
ISBN 978-3-11-099494-0
e-ISBN (PDF) 978-3-11-098143-8
e-ISBN (EPUB) 978-3-11-098146-9
Library of Congress Control Number: 2022940161
Bibliographic information published by the Deutsche Nationalbibliothek
The Deutsche Nationalbibliothek lists this publication in the Deutsche Nationalbibliografie;
detailed bibliographic data are available on the Internet at http://dnb.dnb.de.
© 2022 Walter de Gruyter GmbH, Berlin/Boston
Cover image: dem10 / E+ / Getty Images
Typesetting: VTeX UAB, Lithuania
Printing and binding: CPI books GmbH, Leck
www.degruyter.com

|
Dedicated to my daughters
Viviana and Sofia
Calypso, the beautiful goddess, was the first to speak, and said: “Son of Laertes, sprung from
Zeus, Odysseus of many devices, would’st thou then fare now forthwith home to thy dear native
land! Yet, even so fare thee well. Howbeit if in thy heart thou knewest all the measure of woe it
is thy fate to fulfil before thou comest to thy native land thou wouldest abide here and keep this
house with me, and wouldest be immortal, for all thy desire to see thy wife for whom thou longest
day by day. Surely not inferior to her do I declare myself to be either in form or stature, for in no
wise is it seemly that mortal women should vie with immortals in form or comeliness.”
Then Odysseus of many wiles answered her, and said: “Mighty goddess, be not wroth with me for
this. I know full well of myself that wise Penelope is meaner to look upon than thou in comeliness
and in stature, for she is a mortal, while thou art immortal and ageless. But even so I wish and long
day by day to reach my home, and to see the day of my return. And if again some god shall smite
me on the wine-dark sea, I will endure it, having in my breast a heart that endures affliction. For
ere this I have suffered much and toiled much amid the waves and in war; let this also be added
unto that.”
So he spoke, and the sun set and darkness came on.
The Odyssey, book 5, by Homer.


Preface
In “Über Sinn und Bedeutung,” Frege concentrated mostly on the senses of names,
holding that all names have a sense (meaning). It is natural to hold that the same
considerations apply to any expression that has an extension. But two general terms
can have the same extension and different cognitive significance. So, general terms,
predicates, and sentences all have senses as well as extensions. The same goes for any
expression that has an extension, or is a candidate for extension.
The significant aspect of an expression’s meaning is its extension. We can stip-
ulate that the extension of a sentence is its truth-value, and that the extension of a
singular term is its referent. The extension of other expressions can be seen as asso-
ciated entities that contribute to the truth-value of a sentence in a manner broadly
analogous to the way in which the referent of a singular term contributes to the truth-
value of a sentence. In many cases, the extension of an expression will be what we
intuitively think of as its referent, although this need not hold in all cases. While Frege
himself is often interpreted as holding that a sentence’s referent is its truth-value, this
claim is counterintuitive and widely disputed. We can avoid that issue in the present
framework by using the technical term “extension.” In this context, the claim that the
extension of a sentence is its truth-value is a stipulation.
“Extensional” is most definitely a technical term. Say that the extension of a name
is its denotation, the extension of a predicate is the set of things it applies to, and the
extension of a sentence is its truth value. A logic is extensional if coextensional expres-
sions can be substituted one for another in any sentence of the logic “salva veritate,”
that is, without a change in truth value. The intuitive idea behind this principle is that
in an extensional logic the only logically significant notion of meaning that attaches
to an expression is its extension. An intensional logics is exactly one in which substi-
tutivity salva veritate fails for some of the sentences of the logic.
The first conception of intensional entities (or concepts) is built into the possible-
worlds treatment of Properties, Relations and Propositions (PRP)s. This conception
is commonly attributed to Leibniz, and underlies Alonzo Church’s alternative formu-
lation of Frege’s theory of senses (“A formulation of the Logic of Sense and Denota-
tion” in Henle, Kallen and Langer, 3–24, and “Outline of a Revised Formulation of the
Logic of Sense and Denotation” in two parts, Nous, VII (1973), 24–33, and VIII, (1974),
135–156). This conception of PRPs is ideally suited for treating the modalities (neces-
sity, possibility, etc.) and to Montague’s definition of intension of a given virtual pred-
icate ϕ(x1, . . . , xk) (a FOL open sentence with the tuple of free variables (x1, . . . xk)), as
a mapping from possible worlds into extensions of this virtual predicate. Among the
possible worlds, we distinguish the actual possible world. For example, if we con-
sider a set of predicates, of a given database, and their extensions in different time-
instances, then the actual possible world is identified by the current instance of the
time.
https://doi.org/10.1515/9783110981438-201

VIII
|
Preface
The second conception of intensional entities is to be found in Russell’s doctrine
of logical atomism. In this doctrine, it is required that all complete definitions of in-
tensional entities be finite as well as unique and noncircular: it offers an algebraic
way for definition of complex intensional entities from simple (atomic) entities (i. e.,
algebra of concepts), conception also evident in Leibniz’s remarks. In a predicate log-
ics, predicates and open-sentences (with free variables) expresses classes (properties
and relations), and sentences express propositions. Note that classes (intensional en-
tities) are reified, i. e., they belong to the same domain as individual objects (partic-
ulars). This endows the intensional logics with a great deal of uniformity, making it
possible to manipulate classes and individual objects in the same language. In par-
ticular, when viewed as an individual object, a class can be a member of another
class.
The distinction between intensions and extensions is important (as in lexicog-
raphy [1]), considering that extensions can be notoriously difficult to handle in an
efficient manner. The extensional equality theory of predicates and functions under
higher-order semantics (e. g., for two predicates with the same set of attributes p = q is
true iff these symbols are interpreted by the same relation), i. e., the strong equational
theory of intensions, is not decidable, in general. For example, the second-order pred-
icate calculus and Church’s simple theory of types, both under the standard seman-
tics, are not even semidecidable. Thus, separating intensions from extensions makes it
possible to have an equational theory over predicate and function names (intensions)
that is separate from the extensional equality of relations and functions.
Relevant recent work about the intension, and its relationship with FOL, has been
presented in [2] in the consideration of rigid and nonrigid objects, w. r. t. the possible
worlds, where the rigid objects, like “George Washington,” and are the same things
from possible world to possible world. Nonrigid objects, like “the Secretary-General of
United Nations,” are varying from circumstance to circumstance and can be modeled
semantically by functions from possible worlds to the domain of rigid objects, like
intensional entities.
Another approach used in intensional logic programming is a new form of logic
programming based on intensional logic and possible worlds semantics, and is a well-
defined practice in using the intensional semantics [3]. Intensional logic allows us to
use logic programming to specify nonterminating computations and to capture the
dynamic aspects of certain problems in a natural and problem-oriented style. The
meanings of formulas of an intensional first-order language are given according to
intensional interpretations and to elements of a set of possible worlds. Neighborhood
semantics is employed as an abstract formulation of the denotations of intensional op-
erators. The model-theoretic and fixed-point semantics of intensional logic programs
are developed in terms of least (minimum) intensional Herbrand models. Intensional
logic programs with intensional operator definitions are regarded as metatheories.
Some of the important questions about intensional First-order Logic (FOL) was
enounced by Melvin Fitting in his 2003 preprint [2]:

Preface
|
IX
“What is first-order modal logic for? Since this is obviously not a simple question; perhaps we should
begin by asking, what is propositional modal logic for? Here we are on well-explored ground. With
propositional modal logic, and its relational semantics, we want to explicate various constructs
from natural language, and explore nuances of certain concepts arising in philosophical investiga-
tions. We want to model knowledge, at least in an ideal sense. We want to reason about action. And
there is another purpose as well, one that has become clearer over the years. In studying proposi-
tional modal logics, – primarily those characterized by classes of frames, – we are also studying
fragments of classical first-order (and higher-order) logic. This is known as correspondence theory.
For this purpose axiomatizability (or not) is a central issue. In addition, axiom systems allow the
construction of canonical models, which provides a metamathematical methodology that is uniform
across many logics. Details matter a great deal, of course, but the broad outlines of propositional
modal logics have been standardized for some time.
But the original question above was, what is first-order modal logic for? What do quantifiers add to
the mix?”
But in his approach, differently from this one, Fitting changes also the syntax of the
FOL, by introducing an “extension of” the operator, ↓, in order to distinguish the inten-
sional entity “gross domestic product of Denmark,” and its use in “the gross domestic
product of Denmark is currently greater than gross domestic product of Finland.” In his
approach, if x is an intensional variable, ↓x is extensional, while ↓is not applicable
to extensional variables, different from ours, where each variable (concept) has both
intensional and extension. Moreover, in his approach the problem arises because the
action of letting x designate, i. e., evaluating ↓x, and the action of passing to an alter-
native possible world, that is of interpreting the existential modal operator ⬦, are not
actions that commute. To disambiguate this, one more piece of machinery is needed
as well, which substantially and ad hoc changes the syntax and semantics of FOL, in-
troduces the higher-order modal logics, and is not a conservative extension of Tarski’s
semantics. In the most recent work in [4, 5] is given an intensional version of first-order
hybrid logic, which is also a hybridized version of Fitting’s intensional FOL, by a kind
of generalized models; thus, is different from our approach to a conservative extension
of Tarski’s semantics to intensional FOL.
Another recent relevant work is presented by I-logic in [6], which combines both
approaches to semantics of intensional objects of Montague and Fitting.
In his approach, Fitting followed the Montague tradition, different from my wider
approach provided in this book that uses both Montague tradition and algebraic
Bealer’s approach, and enriched them by a more detailed investigation of modal
logics of FOL, and by the way introduced naturally the intensional semantics into tra-
ditional extensional FOL with Tarski’s semantics and, moreover, how to introduce in
such minimal intensional FOL and the “higher level” modal operators. Most relevant
for my personal research has been two significant approaches to intensional FOL:
1.
Montague’s approach based on possible world representation [7, 8, 9, 10, 11], the
intension of a proposition is a function from possible worlds 𝒲to truth-values, and
properties and functions from 𝒲to sets of possible (usually not actual) objects.

X
|
Preface
2.
Bealer’s approach in [12] to the intensional logic the fundamental entities are in-
tensional abstracts or so-called, “that-clauses” and his introduction of intensional
algebras.
These two approaches are unified in my approach, with providing a conservative ex-
tension of Tarski’s semantics to intensional FOL as well.
Quo vadis logic-based AI?
Why this title? I will try to explain it by my relevant research history from 2003 to
2020. At “La Sapienza,” Roma, Italy, we had a number of good professors and re-
searches in logic-based AI, and especially in the research group of my PhD advisor,
Professor M. Lenzerini (from 94 to 98), who in that period was chief of the PhD pro-
grams and research in knowledge basis and AI. In that period, the book [13] of the logic
based approach to AI was a reference for my introduction to this field, and my book
in some way is a continuation of that approach. I returned again to his department in
2002, 4 years after I finished my PhD thesis, to work for the European interuniversity
project of Semantic Web, called SEWASIE project IST-2001-34825. I have written, with
initial help of Lenzerini, three or four research papers for this European research pro-
gram. In that period, Lenzerini was the chief research leader in data integration and
it was also the very beginning of the P2P data integration systems, based on the first-
order logic and its second-order extensions for the interdatabase mappings. Thus, the
whole framework was just in standard extensional logics, which demonstrated a lot of
theoretical problems about mutually inconsistent information coming from different
sources.
Of course, all my work in this project was just in this working logic framework, but
I tried to consider many-valued logics to overcome these problems about the inconsis-
tences and to find a more robust data integration P2P system, trying to overcome the
strong (extensional) mapping between databases. When I organized a first short paper
with these new ideas, Lenzerini accepted to join with me to write the final version, but
from the fact that he published papers with his working group of other professors and
researches, he asked me to wait on the decision of this group if they would accept me
as new member of this group, and hence authorized to publish the research papers for
journals or conferences together.
Unfortunately for me, somebody in his group did not like my participation and
Lenzerini was sorry, but promised that if my papers were accepted for the confer-
ences or journals, that department would support all expenses (traveling, participa-
tion costs, etc.) for presentations. Their decision explains why, during the 3 years work-
ing with his research group for this European project, I have no any publication with
them in journals or conferences, and why all such work was done by me only. With
economical support by the department of Lenzerini, I published a dozen papers by

Quo vadis logic-based AI?
|
XI
myself, and I developed clear ideas about new intensional logic to use as a good solu-
tion for intensional weak semantic mappings between peer databases.
However, no one in the department followed my ideas, and after the invitation of
Director V. S. Subrahmaninan of UMIACS Laboratory of Computer Science at College
Park University (Washington, D. C.) in January 2005, I stopped this research for 1 year
to dedicate time for mathematical problems about algebra for the generation of ag-
gregates in temporal-probabilistic (TP) databases. We published two papers [14, 15],
and I finished this work by a fundamental revision of the erroneous Subrahmaninan’s
fixed-point semantics of TP-logic programs [16].
In that period, Jack Minker was an Emeritus Professor at the University of Mary-
land, Department of Computer Science, and I visited him, from the fact that I worked
just in his main research AI field where he was a leading authority, to hear what his
opinion was regarding current problems in logic-based AI and their applications. Pro-
fessor Minker was the editor of the book [17] in logic-based AI in 2001, so it was just a
good moment to exchange at least the short opinions with him. My intension was to
improve the standard database technology of RDB management systems (based on the
extensional FOL) with a more general intensional logic framework, with conservative
extension of classical RDB in order to support all previously developed RDB applica-
tions and be able to support the AI applications. From the fact that various logic-based
development frameworks as Prolog, Datalog, Golog, HiLog, etc., has been separated
from the mainstream database applications based on RDB, I wanted also to know if
there was another analog approach for a wide introduction of logic-based AI into a
conservative extension of RDB technology. I understood that there was not any such
a large project because AI fields worked differently with very specialized groups of re-
searches to resolve some ad hoc problems. A basic wide approach, with a big business
impact and with ambition to improve industrially dominant RDB technology, did not
get initiated.
With this impression in mind, from a leading authority at the end of his carrier,
after 2006 when I finished my post-PhD experience at UMIACS, I continued to work in
this direction alone, toward a new intensional FOL, by integrating Montague’s and al-
gebraic Bealer’s [12] approaches. The basic result was the publication of the conserva-
tive extension of Tarski’s semantics to intensional FOL [18], and two-step intensional
semantics [19], which guaranteed a conservative extension of current RDB, but with
more than 50-year-old technology, toward new IRDB (Intensional RDB). Indeed, in my
next Manifesto of IRDB [20], I hoped to find interested research groups and funds to
begin the realization of IRDB as a new platform (compatible with all previously devel-
oped RDB applications), and also able to support NewSQL for big data, and ready for
other AI improvements.
I returned again to Italy and tried to find a venture capital for a new start-up soft-
ware company, but without success. So, waiting for some opportunity, I dedicated my
free time to develop some new ideas on the completion of quantum mechanics (based

XII
|
Preface
on some Einstein’s ideas) and unification with classical mechanics and general rela-
tivity. When I finished this enormous work, published in three books,1 I returned to
the still open problem about “quo vadis logic-based AI,” and realized that after all
it seems like that now AI is reduced only to the development of algorithms2: pattern
matching, machine learning, visual recognitions, statistical “intelligent” mining, pre-
dictive statistical analysis, etc. It is enough to research in Google about “books in AI,”
and it seems that everything is about algorithms, and that logic-based AI remains as
it was 20 years ago. Within specialized and dedicated conferences and workshops,
it appears that logic-based AI has no any significant role in business life and in the
development of new software products.
No more logics??
Semantic Web (W3C) continues with ad hoc languages, and database systems still
use RDB with some extension to integration with data-federation (extensional inte-
gration) and is deeply analyzed in my book [21] in 2014. From such a situation, comes
my motivation to write this new book, after the previous theoretical book on exten-
sional database integration [21], but now this one is about new intensional FOL for a
conservative extension of extensional RDBs, and able to support the intensional DB
integration, many-valued AI applications, and a new SQL and vectorial big data man-
agement. Moreover, my aim is not only a complete development of the new logic-based
theory, but to provide different and fundamental examples for perspective industrial
applications as well.
Knowledge representation, strongly connected to the problem if knowledge pro-
cessing, reasoning and “drawing inferences,” is one of the main topics in AI. By re-
viewing the knowledge representation techniques that have been used by humans, we
will be aware of the importance of language. The predominant part of the IT industry
and user’s applications is based on some sublanguage of the standard (extensional)
FOL with Tarski’s semantics based (only) on the truth; my effort is to pass to a more
powerful evolution of the FOL able to support the meaning of knowledge as well, by
replacing the standard FOL and its DB theory and practice in the IT business. Twenty
years after Minker’s book (that consists of 24 refereed papers presented at the work-
shop), it is time for a new book in logic-based AI that is able to substitute old RDB
technology in a conservative way to protect the enormous amount of previously de-
veloped business applications.
1 Soft Computing Applications in Industry, B. Prasad, Z. Majkic (Eds), 2008. ISBN 978-3-540-
77464-8, e-ISBN 978-3-540-77465-5; Big Data Integration Theory: Theory and Methods of Database
Mappings, Programming Languages and Semantics, Zoran Majkic, 2014. ISBN 978-3-319-04155-1,
e-ISBN 978-3-319-04156-8.
2 https://www.guru99.com/ai-machine-learning-books.html,
https://builtin.com/artificial-intelligence/ai-books,
https://link.springer.com/search/page/3?facet-discipline="Computer+Science"&query=Artificial+
intelligence+2020 etc.

Quo vadis logic-based AI?
|
XIII
This book is not a collection of different research papers of different authors but
a result of unifying, coherent and complete development of a new Intensional FOL
(IFOL) as a result of my personal research in last 15 years with more than 70 % unpub-
lished. Conservative migration from the standard extensional FOL into more powerful
IFOL is able to express not only the logic truth but also the sense (meaning) of concepts
and is a basic promotion of the formal theory and applications in this new book. Partic-
ular attention is given to the new mathematical concepts of symmetry, both in logic se-
mantics (predicate compression and ontological encapsulation transformations) and
intensional abstract transformations with categorial symmetry. This approach to AI
by symmetries, which render invariant knowledge during transformations, is as far I
know an innovative method in AI (as it was in the development of the laws of physics).
The principal Chapter 1 of this book analyzes the minimal intensional seman-
tic enrichment of the syntax of the FOL language, by unification of different views:
Tarskian extensional semantics of the FOL, modal interpretation of quantifiers and a
derivation of the Tarskian theory of truth from unified semantic framework based on
a recursive compositional theory of meaning. We show that not all modal predicate
logics are intensional, and that an equivalent modal of Kripke’s interpretation of logic
quantifiers in FOL results in a particular pure extensional modal predicate logic (as
is the standard Tarskian semantics of the FOL). This minimal intensional enrichment
is obtained by adopting the theory of properties, relations and propositions (PRP) as
the universe or domain of the FOL, composed by particulars and universals (or con-
cepts), with the two-step interpretation [18] of the FOL that eliminates the weak points
of the Montague’s intensional semantics. Different from the Bealer’s intensional FOL,
we show that the introduction of the intensional abstraction in order to obtain the
intensional properties of the FOL is not necessary.
The final result of this chapter is represented by the commutative homomorphic
diagram that holds in each given possible world of this new intensional FOL, from
the free algebra of the FOL syntax, toward its intensional algebra of concepts, and
successively, to the new extensional relational algebra. Particular attention is given to
the reification intensional properties by the development of a new kind of intensional
abstract operator that transforms the FOLformulaeintoabstractedterms.Asignificant
number of applications of these operators are provided in all of the other chapters,
from Nilson’s probabilistic logic, constraint databases, semantic web, new intensional
RDBs with multivalued attributes, etc.


Acknowledgments
This work required a lot of time to conclude because of the necessary motivation to
provide a significant evolution of the first-order logic that is interesting not only from
the theoretical point of view, but also for the important industrial advancement of
current IT technology in the area of knowledge and database systems in a conservative
way that preserves most of today’s IT applications. Thanks to all of the people who
helped me to begin my research activity, to learn new topics and to improve my ideas
and confront our different points of view and experiences, and finally to finish this
effort.
I wanted to offer my help directly to young PhD students and post-PhD researches,
as a best way to transfer to them all what I have received previously from my aca-
demic fathers, and from 2005 to 2015 (also after my successful book in big data inte-
gration theory) to take the Assistant Professor position in the USA, by responding to
a big number of internet calls. I left this academic position at 1981 and believed that
my publishing activity and participation to a dozen international conferences would
be sufficient for taking such an initial position, but in today’s academic situation, it
seems that there are more important and strong recommendation letters (necessary
for young people still without a high number of publications). So, I hope that PhD
students will receive from this book all that what I could not transfer personally to
them. I was surprised as well, at the end of writing this book, of how I really worked
together in mathematics, category theory, lambda calculus and quasi all kinds of log-
ics and databases, so that this monograph is also a testament for new generations,
before my retirement from academic life.
Roma 2022
Zoran Majkić
https://doi.org/10.1515/9783110981438-202


Dependencies between the chapters
This book is divided into two parts: the first one, from Chapter 1 to Chapter 4, is ded-
icated to the conservative Tarskian extension of standard FOL into Intensional FOL
(IFOL), where Chapter 1 is theoretical and the other three chapters provide significant
applications of this new theory, with the most important work in Chapter 4 dedicated
to the big data extension of a standard Relational Data Base (RDB) into new Inten-
sional RDB (IRDB) with multivalued attributes as well. With this work, we propose
an evolution from FOL to IFOL, conservative in sense that this evolution preserves
software applications actually in practice, by offering new advanced features. It is a
fundamental advance w. r. t. the current database and P2P systems and semantic web
applications.
PART II, instead, from Chapter 5 to Appendix A, is a conservative generalization
of the Chapter 1 to many-valued IFOL able to support AI applications based on many-
valued, relevant and paraconsistent logics in a unique intensional FOL framework.
Chapter 5 is the theoretical development of many-valued FOL, with additional material
provided in Appendix A, with a number of applications presented in Chapter 6.
The readers interested more in theoretical issues after Chapter 1 can directly con-
tinue to Chapter 5, with the help of Appendix A. The reader interested in the semantic
web, P2P systems and newSQL and Big Data extensions of standard RDB, after Chap-
ter 1 can choose any other thematic chapter after it. The reader interested in nonclas-
sical logics (many-valued, relevant and paraconsistent logics will find Chapters 6 and
Appendix A interesting, with a number of new developments of nonstandard logics.
They are given as examples of how different kinds of nonclassical logics can be em-
bedded into this general intensional FOL framework.
Detailed Plan
Chapter 1: After introduction to FOL, modal and intensional logics (of Montague’s
and Bealer’s approaches) in Section 1.2 is presented with the PRP theory and the two-
step intensional semantics for modal predicate logics, with the unique intensional
interpretation I, which maps the logic formulae into the concepts (intensional enti-
ties), and the set of extensionalization functions, which determine the extension of
any given concept in different possible worlds. After that, we define an extensional
algebra of relations for the FOL, different from standard cylindric algebras and the
homomorphisms I∗
T (derived from Tarski’s FOL interpretation) from the syntax FOL
algebra 𝒜FOL into the extensional algebra 𝒜R of relations for the FOL, different from
standard cylindric algebras.
In Section 1.2.1, we consider the FOL syntax with the modal Kripke’s semantics for
each particular application of quantifiers (∃x), and we obtain a multimodal predicate
logic FOL𝒦, equivalent to the standard FOL with Tarski’s interpretation. Moreover, we
https://doi.org/10.1515/9783110981438-203

XVIII
|
Dependencies between the chapters
define the generalized Kripke semantics for modal predicate logics, and we show their
diagram of fundamental reductions, based on the restrictions over possible worlds.
In Section 1.2.2, we consider the intensionality of modal logics, and we show that not
all modal logics are intensional as supposed: in fact, the modal translation of the FOL
syntax results in a multimodal predicate logic FOL𝒦that is pure extensional as it is the
standard Tarskian FOL. Then we define the full intensional enrichment for multimodal
predicate logics.
In Section 1.3, we consider the minimal intensional enrichment of the FOL (which
does not change the syntax of the FOL), by defining FOLℐ(Γ) intensional logic with
the set of explicit possible worlds equal to the set of Tarski’s interpretations of the
standard extensional FOL. We show that its intensionality corresponds to the Mon-
tague’s point of view. Then we define the intensional algebra of concepts for this in-
tensional FOLℐ(Γ), and the homomorphic correspondence of the two-step intensional
semantics with the Tarskian semantics of the FOL [18], valid in every possible world of
FOLℐ(Γ). Finally, we obtain the commutative diagram of Frege/Russel semantics with
intermediate intensional algebra 𝒜int and equality between Tarski’s interpretation I∗
T
of the FOL syntax and composed mapping h ∘I where I is a fixed intensional interpre-
tation of FOL into intensional algebra and h the extensionalization mapping from it
into extensional algebra. In Section 1.3.1, we provide a new (different from Bealer’s se-
mantics) intensional abstraction operator theory, while in Section 1.3.2 new methods
in Computer Science are introduced based on mathematical (categorial) symmetries
for the invariant transformations of the logic knowledge.
Chapter 2 is dedicated to three examples of application of an intensional ab-
stract operator for reification of logic formulae, and hence to be used as terms inside
other predicates, without generation the second-order logic (for another special im-
portant example we dedicate the next chapter to intensional RDBs with multivalued
attributes). In Section 2.1, dedicated to the theory of predicate compression theory (by
introduction of hidden-quantifiers) with an application for constraint databases, we
use the nonground abstracted terms of a special unary predicate with the meaning “it
is abstracted that ϕ(x) by hiding variables in α,” for a number of examples where ϕ(x)
defines the 3-dimensional geometric objects.
The next application, given in Section 2.2, for Nilson’s probability theory, by trans-
forming it into a many-valued logic and introduction of a binary predicate that express
the value of probability of a given sentence, transformed into an abstracted ground
term of intensional FOL. So, by using such reification of sentences we are able to “rea-
son about probabilities of the sentences” by syntax and semantics of interval-based
probabilistic logic programs and TP databases.
The last application for web semantics (RDF and Web Ontology Language (OWL))
is presented in Section 2.3. We show the intensional properties of the Patrick Hayes
RDF model theory (RDFS support reflection on its own syntax that violates principles
of extensional set theory), and how it can be implemented inside intensional FOL by
using the intensional abstracted terms for the reification/nesting (natural-language

Detailed Plan
|
XIX
property) of RDF triples. The last subsection is an application of this RDF embedding
in intensional FOL for P2P view-based data integration applications that use the logic
programs for the semantic web with RDF ontologies.
Chapter 3: The notion of ontology has become widespread in the semantic web.
The meaning of concepts and views defined over some database ontology can be con-
sidered as intensional objects, which have a particular extension in some possible
world: for instance, in the actual world. This chapter is also a continuation of the se-
mantic web application in Chapter 2 with the unique difference that instead of RDF
triples for the definition of ontologies, here we are using standard RDB structures. The
intensional property of IFOL is used to define a new kind of interschema mappings be-
tween peer databases based on intensionally equivalent views.
The P2P database systems are formally defined in Section 3.2. Thus, a noninva-
sive mapping between completely independent peer databases in a P2P system can
be naturally specified by the set of couples of intensionally equivalent views, which
have the same mining (intension), over two different peers. Such a kind of mapping
has very different semantics from the standard view-based mappings based on the
material implication commonly used for data integration. We show that the extension
of a P2P database intensional FOL in the actual world can be modeled by a particu-
lar multimodal logic, where each peer database is an epistemic logic system with its
own modal operator “Peer knows that…,” while a global query answering, which de-
pends on a sound P2P query rewriting algorithm, corresponds to the extension of an
existential modal query formula.
The complete logical embedding of P2P systems into intensional FOL is provided
in Section 3.3, with the logical reasoning based on the bridge rules of local contextual
deduction and with the resulting kind of nonomniscient weak intensional inference.
For a query answering, we consider nonomniscient query agents and we define
an object-oriented class for them, which implements the method for the query rewrit-
ing algorithm. Finally, in Section 3.4 we show that this query answering algorithm is
sound and complete w. r. t. the weak deduction of the P2P intensional logic. Then, in
Section 3.5 we provide denotational coalgebraic semantics of query answering for P2P
systems defined in intensional FOL.
Chapter 4 is developed as a continuation of big data integration theory [21] (de-
veloped for standard (extensional) RDBs) to more powerful intensional RDB (IRDB), as
it was announced [20] by “IRDB Manifesto” in 2014. It is the most (also for IT industry)
important application of intensional FOL because there is a deep and potentially large
impact for a new DB platform in the future. Although the intensional FOL has a very
large possibility to be applied in AI and higher ontology-based applications, the pas-
sage from standard RDBs to IRDBs has a horizontal impact in the entire IT business.
Beacause of such an impact, the theory of IRDBs is a conservative w. r. t. traditional
RDB technology and preserves the software developed for current RDB models, but of-
fers new features as vector big data relations with NewSQL and multivalued attributes
of DB relations. This largest chapter is divided in three thematic parts:

XX
|
Dependencies between the chapters
After a short introduction in Section 4.1, in the next Section 4.2, is defined a new
IRDB, based on data integration theory where the ER model of the user’s application
is a global DB schema with empty relations, used as a user’s and software-application
interface and source DB has a big data architecture based on vector relations. Thus,
standard SQL written by users is rewritten by IRDBMS over such materialized big vec-
tor relations. Then canonical models are defined for such a data integration system
and an implementation of NewSQL by query-rewriting methodology. Finally, the fea-
tures of such new database IRD systems with an example of application to big data
interoperability systems are analyzed.
The strict conservative extension of classic RDBs into new IRDBs, described pre-
viously, is extended in Section 4.3 by the introduction of multivalued attributes as
intensional unary concepts of IFOL, by using the reification of them inside the source
vectorial database. The NewSQL is enriched by a new syntax in order to use the multi-
valued attributes as well. We provide the definition of canonical models for IRDB with
multivalued attributes and query-rewriting method for them as well. We specify the
migration from RDBs to IRDBS with multivalued attributes and also the inverse migra-
tion by using a new relational table containing the values of multivalued attributes,
so that extensional RDBs can use the standard joined with this new relation in order
to also manage this new information.
In last Section 4.4, we provide formal denotational (algebraic) semantics for the
IRDBs with multivalued attributes. These semantics are an extension of the denota-
tional functorial semantics for data integration systems developed previously for stan-
dard RDBs in [21], and hence based on the DB category for databases and functional
mappings between them, that is in the categorial Kleisli semantics with an introduc-
tion of saturated morphisms for the multivalued attributes.
Chapter 5: The first section is not only an introduction to MV-logics but also a de-
velopment of an alternative nonmatrix based model theory of MV-logics with a new
representation theorem based on the truth-preserving entailment. This new model of
semantics of MV-logics is founded on the new Kripke canonical autoreferential rep-
resentation of MV-logics by set-based complex algebras. The set of possible worlds
in this Kripke semantics is the set of join-irreducible truth elements of the complete
distributive lattice of truth values of a given MV-logic. Then we provide the important
application of this new theory to Belnap’s bilattice, used in a number of applications
in this book, from the fact that it permits the management of incomplete and inconsis-
tent knowledge as well, that often appear in practice, especially in the semantic web,
data integration and P2P systems.
In Section 5.2, we present a generalization of the intensional FOL (developed in
Chapter 1) to MV-logics, again in conservative way similar to ontological encapsula-
tion introduced in Section A.4, but without changing the syntax of predicates: the logic
values are presented only in the extensions (relations) of formulae with free variables.
Thus, we obtain a general model of intensional FOL, in which each concrete MV-logic
can be embedded. That is, in which are represented by all MV-logics in an unified

Detailed Plan
|
XXI
framework, with conservative extension of Tarski’s semantics to intensional FOL as
in Chapter 1. We introduce also the two many-valued, mutually independent, quan-
tifiers: existential and universal as in FOL. Finally, in the last section we provide the
resolution of the liar formula in this many-valued intensional FOL.
Chapter 6: It is dedicated to show a number of applications for the MV-intensional
FOL developed in Chapter 5. We provide three original examples of MV-logics: in Sec-
tion 6.1, we develop a relevant logic by weakening the fusion and fission logic con-
nectives of the infinitary Lukasiewicz–Tarski logic with complete distributive lattice
of truth values represented by fuzzy interval of reals [0, 1].
In Section 6.2, we present the new paraconsistent relevant mZ-logic obtained by
da Costa weakening of logic negation. It is shown that obtained logic is weakened in-
tuitionistic logic, and as examples are provided the weakened Kleene’s 3-valued logic,
Belnap’s 4-valued logic, fuzzy logic and the Gödel–Dummett logic.
The third example for MV-intensional FOL, developed in Chapter 5, is presented
in the last Section 6.3. Here, we propose Belnap’s 4-valued logic for management of
P2P data integration with incomplete and inconsistent data as well. Then we show
that the process of filtering of query preanswers is, from a logical point of view, repre-
sented equivalently by modal query language applied over databases with a particular
“quality-based” partial order.
Appendix A: In this chapter, we present only some basic technical notions for
algebras, MV-logics, database theory and and category theory that is used in previous
chapters of this book. These are very short introductions and more advanced notions
can be found in given references. This presentation is not fully self-contained; it needs
a good background in relational database theory, relational algebra and first-order
logic. This very short introduction is enough for the logic and database readers.
Two special sections, indicated as support for the many-valued intensional FOL
developed in Chapter 5, are Section A.3 dedicated to new autoreferential semantics for
many-valued modal logics based on complete latices of truth values, and Section A.4
with concepts of semantic reflection and ontological encapsulation of many-valued
into two-valued logics. They provide some fundamental methods used for definition
of intensional many-valued logic in Chapter 5.


Notation conventions
The symbol =def will be used for the explicit definition of the mathematical concepts,
while the symbol “=” (also it will be used sometimes for the same fact when it is clear
from the context) for the usual meaning of the equivalence of the left- and right-hand
sides in the equations.
The symbol ≡denotes standard logical equivalence, while ≐for the binary identity
predicate in the first-order logic. We denote by R= the Tarski’s interpretation of ≐. So,
for the equality we will use the standard symbol =, while for different equivalence
relations we will employ the symbols ≃, ≈, ≖, etc. The term “iff” is used for “if and only
if.”
We use logical symbols both in our formal languages and in the metalanguage.
The notation slightly differs: in classical propositional and FOL, we use ∧, ∨, ⇒, ¬ (and
∃, ∀for the FOL quantifiers). As the metasymbol for conjunction, the symbol “&” will
be used.
In our terminology, we distinguish functions (graphs of functions) and maps.
A (graph of) function from X to Y is a binary relation F ⊆X ×Y (subset of the Cartesian
product of the sets X and Y) with domain A satisfying the functionality condition
(x, y) ∈F&(x, z) ∈F implies y = z, and the triple ⟨f, X, Y⟩is then called a map (or
morphism in a category) from A to B, denoted by f : X →Y as well. The composition
of functions is denoted by g ⋅f, so that (g ⋅f )(x) = g(f (x)), while the composition of
mappings (in a given category) by g ∘f. 𝒩denotes the set of natural numbers. Here
are some other set-theoretic notation:
–
The symbol ℕis used for the set of natural numbers, while 0 denotes the empty
set;
–
𝒫(X) denotes the power set of a set X, and Xn =def
n
⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞
X × ⋅⋅⋅× X the n-ary Cartesian
product, and YX denotes the set of all functions from X to Y;
–
We use ⊆for inclusion, ⊂for proper inclusion (we use ≤, ⪯, ⊑for partial orders),
and X ⊆ω Y denotes that X is a finite subset of an infinite set Y. By X\Y or X −Y,
we denote the set difference between the set X and set Y;
–
R−1 is the converse of a binary relation R ⊆X × Y and R is the complement of R
(equal to (X × Y)\R);
–
idX is the identity map on a set X. |X| denotes the cardinality of a set (or list) X;
–
For a set of elements x1, . . . , xn ∈X, we denote by x the sequence (or tuple)
(x1, . . . , xn), and if n = 1 simply by x1, while for n = 0 the empty tuple ⟨⟩. An n-ary
relation R, with n = ar(R) ≥1, is a set (also empty) of tuples xi with |xi| = n, with
⟨⟩∈R (the empty tuple is a tuple of every relation);
–
By πK(R), where K = [i1, . . . , in] is a sequence of indexes with n = |K| ≥1, we
denote the projection of R with columns defined by ordering in K. If |K| = 1, we
write simply πi(R);
https://doi.org/10.1515/9783110981438-204

XXIV
|
Notation conventions
–
Given two sequences x and y, we write x ⊆y if every element in the list x is an
element in y (not necessarily in the same position) as well, and by x&y their con-
catenation; (x, y) denotes a tuple x&y composed by variables in x and y, while
⟨x, y⟩is a tuple of two tuples x and y. The set of elements of a list x is denoted
by x;
–
By f, t, we denote empty set 0 and singleton set {⟨⟩}, respectively (with the empty
tuple ⟨⟩, i. e., the unique tuple of 0-ary relation), which may be thought of as
falsity f and truth t, as those used in the relational algebra. For a given domain
of intensional logics 𝒟, we define that 𝒟0 is a singleton set {⟨⟩}, so that {f, t} =
𝒫(𝒟0), where 𝒫is the powerset operator.
A relational symbol (a predicate letter in FOL) r and its extension (relation table) R
will be often called shortly as “relation” where it is clear from the context. If R is the
extension of a relational symbol r, we write R = ‖r‖.

Contents
Preface | VII
Acknowledgments | XV
Dependencies between the chapters | XVII
Notation conventions | XXIII
1
Theory of new intensional first-order logic | 1
1.1
Introduction | 1
1.1.1
Introduction to first-order logic | 2
1.1.2
Introduction to multimodal logics | 6
1.1.3
Two significant approaches to intensional first-order logic | 8
1.2
Intensionality and intensional/extensional semantics | 11
1.2.1
First-order logic and modality | 20
1.2.2
Modal logics and intensionality | 28
1.3
First-order logic and intensionality | 33
1.3.1
Enrichment by intensional abstraction operator and its logic
inverse | 46
1.3.2
Logics via symmetry: intensional abstraction and ontological
encapsulation transformations | 58
2
Applications of the intensional abstraction operator | 66
2.1
Predicate (de)compression transformations | 66
2.1.1
Introduction of hidden-quantifiers for predicate logics | 69
2.1.2
Formal theory of the semantics of predicate compression | 74
2.1.3
Predicate compression by intensional abstract terms: application to
constraint databases | 83
2.1.4
Invariances and symmetries in predicate compression
transformations | 90
2.2
Nilsson’s structures and probabilistic logics | 92
2.2.1
Probabilistic algebra for Nilsson’s structure | 95
2.2.2
Probabilistic logic reasoning and intensionality | 98
2.2.3
Application to probabilistic logic programs | 102
2.2.4
Application to temporal-probabilistic databases | 105
2.3
Semantic WEB applications | 109
2.3.1
Introduction to semantic web languages RDF and OWL | 110
2.3.2
General embedding of RDF data structures into intensional FOL | 113
2.3.3
Logic programs for data integration with RDF ontologies | 118

XXVI
|
Contents
3
Intensional semantics for P2P database systems | 124
3.1
Intensionality and epistemic independency of database peers | 124
3.2
Peer-to-peer database systems | 127
3.2.1
Plausible query-answering inference in a peer database with also
inconsistent information | 132
3.2.2
Abstract object types for peer databases | 138
3.2.3
Database P2P network definition | 140
3.3
Modal intensional FOL for P2P systems | 143
3.3.1
Bridge rules for local contextual deduction | 147
3.3.2
Nonomniscient weak intensional inference | 153
3.4
Sound and complete query derivation of intensional
equivalence-classes | 156
3.4.1
Final coalgebra semantics for weak intensional deduction ⊪| 157
3.4.2
Sound and complete query rewriting algorithm with respect to weak
deduction ⊪| 159
3.5
(Co)algebraic representation of P2P query answering | 165
3.5.1
P2P query-answering dynamics | 169
4
Intensional RDB manifesto: flexible big data and NewSQL | 173
4.1
State of the art in RDBMS and NoSQL big data | 173
4.2
Intensional RDB: data integration system with a vector source
database | 177
4.2.1
Canonical models for IRDBs | 183
4.2.2
NewSQL property of the IRDBs | 188
4.2.3
Comparison with related work | 200
4.2.4
Big data interoperability with IRDBs | 203
4.3
Enrichment of IRDB by multivalued attributes | 216
4.3.1
Canonical models for IRDBs with multivalued attributes | 217
4.3.2
NewSQL property of the IRDBs with multivalued attributes | 222
4.4
Kleisli semantics for intensional RDB with multivalued
attributes | 230
4.4.1
Functorial semantics for IRDBs with multivalued attributes | 238
4.4.2
Kleisli semantics in DB category | 248
5
Theory of many-valued intensional first-order logic | 258
5.1
Introduction to many-valued logics | 258
5.1.1
Nonmatrix based representation theorem for many-valued
logics | 263
5.1.2
Canonical autoreferential representation for algebras over complete
distributive lattices | 269
5.1.3
Application to Belnap’s bilattice | 279

Contents
|
XXVII
5.2
General many-valued intensional first-order logic with abstraction
operator | 286
5.2.1
Many-valued algebra of concepts and extensions: embedding of
DL | 286
5.2.2
Syntax and interpretation of many-valued intensional FOL with
abstraction operator | 298
5.2.3
Model-based entailment and Kripke semantics for many-valued
intensional FOL | 309
5.3
Resolution of Liar formula in many-valued intensional FOL | 314
6
Applications of many-valued intensional first-order logic | 317
6.1
Relevant Lukasiewicz–Tarski logics | 317
6.1.1
Introduction to substructural properties of T-norm fuzzy logics | 321
6.1.2
Weakening of fission and fusion operations of Lukasiewicz
algebra | 329
6.2
Relevant mZ-logic: paraconsistent intuitionistic logic with Da Costa
weakening of intuitionistic negation | 341
6.2.1
Intuitionistic constructivism and Birkhoff’s polarity of negation in
mZ-logic | 348
6.2.2
Subintuitionistic paraconsistent mZ-logics derived from Kleene, Belnap,
fuzzy and Gödel–Dummett logics | 357
6.3
Belnap’s 4-valued P2P data integration with incomplete and
inconsistent data | 363
6.3.1
Filtering query preanswers: real world identity constraint | 369
6.3.2
Modal query language for databases with a partial order | 374
A
Appendix | 381
A.1
Introduction to lattices, algebras and propositional logics | 381
A.2
Introduction to deductive logic and binary sequent calculus | 385
A.3
Autoreferential semantics for many-valued modal logics | 388
A.3.1
Many-valued model-theoretic autoreferential semantics | 391
A.3.2
Hierarchy of negation operators for complete lattices | 396
A.3.3
Heyting’s and multimodal extensions of distributive lattices | 405
A.3.4
Direct autoreferential Kripke semantics for many-valued predicate
logics | 410
A.3.5
Autoreference, many-valuedness and paraconsistency | 421
A.4
Reduction of many-valued into two-valued modal logics | 425
A.4.1
Higher-order Herbrand interpretations: revision of
temporal-probabilistic logics | 431
A.4.2
Mathematics via symmetry: many-valued knowledge invariance in
ontological encapsulation by semantic reflection | 438
A.4.3
Binary sequent calculi for finite many-valued predicate logics | 448

XXVIII
|
Contents
A.4.4
General abstract reductions of many-valued into 2-valued logics | 456
A.5
Basic category theory | 460
A.5.1
Categorial symmetry | 469
A.5.2
Kripke polynomial functors and predicate lifting | 472
A.6
Introduction to RDB, database mappings and DB category | 474
A.6.1
Basic database concepts | 478
A.6.2
Database observations: idempotent power-view operator | 480
A.6.3
Schema mappings, sketches and functors into the DB category | 482
A.6.4
Data integration system | 488
Bibliography | 495
Index | 513

1 Theory of new intensional first-order logic
1.1 Introduction
Contemporary use of the term “intension” is derived from the traditional logical
Frege–Russell’s doctrine that an idea (logic formula) has both an extension and an in-
tension. Although there is divergence in formulation, it is accepted that the extension
of an idea consists of the subjects to which the idea applies, and the intension consists
of the attributes implied by the idea. From Montague’s point of view, the meaning of
an idea can be considered as particular extensions in different possible worlds. The
simplest aspect of an expression’s meaning is its extension. We can stipulate that the
extension of a sentence is its truth value, and that the extension of a singular term is
its referent. The extension of other expressions can be seen as associated entities that
contribute to the truth value of a sentence in a manner broadly analogous to the way
in which the referent of a singular term contributes to the truth value of a sentence.
“Extensional” is most definitely a technical term. Say that the extension of a name
is its denotation, the extension of a predicate is the set of things it applies to, and the
extension of a sentence is its truth value. A logic is extensional if coextensional expres-
sions can be substituted one for another in any sentence of the logic “salva veritate,”
i. e., without a change in truth value. In “Über Sinn und Bedeutung,” Frege concen-
trated mostly on the senses of names, holding that all names have a sense. It is natural
to hold that the same considerations apply to any expression that has an extension.
Two general terms can have the same extension and different cognitive significance;
two predicates can have the same extension and different cognitive significance; two
sentences can have the same extension and different cognitive significance. So gen-
eral terms, predicates and sentences all have senses as well as extensions. The same
goes for any expression that has an extension, or is a candidate for extension.
The distinction between intensions and extensions is important, considering that
extensions can be notoriously difficult to handle in an efficient manner. The exten-
sional equality theory of predicates and functions under higher-order semantics (e. g.,
for two predicates with the same set of attributes p = q is true iff these symbols are
interpreted by the same relation), i. e., the strong equational theory of intensions,
is not decidable, in general. For example, in the second-order predicate calculus
and Church’s simple theory of types, both under the standard semantics, is not even
semidecidable. Thus, separating intensions from extensions make it possible to have
an equational theory over predicate and function names (intensions) that is separate
from the extensional equality of relations and functions.
The first conception of intensional entities (or concepts) is built into the possible-
worlds treatment of Properties, Relations and Propositions (PRP)s. This conception
is commonly attributed to Leibniz, and underlies Alonzo Church’s alternative formu-
lation of Frege’s theory of senses (“A formulation of the Logic of Sense and Denota-
tion” in Henle, Kallen and Langer, 3–24, and “Outline of a Revised Formulation of the
https://doi.org/10.1515/9783110981438-001

2
|
1 Theory of new intensional first-order logic
Logic of Sense and Denotation” in two parts, Nous, VII (1973), 24–33, and VIII, (1974),
135–156). This conception of PRPs is ideally suited for treating the modalities (neces-
sity, possibility, etc.) and to Montague’s definition of intension of a given virtual pred-
icate ϕ(x1, . . . , xk) (a FOL open sentence with the tuple of free variables (x1, . . . xk)) as
a mapping from possible worlds into extensions of this virtual predicate. Among the
possible worlds, we distinguish the actual possible world. For example, if we consider
a set of predicates of a given database and their extensions in different time instances,
the actual possible world is identified by the current instance of the time.
The second conception of intensional entities is to be found in Russell’s doctrine
of logical atomism. On this doctrine, it is required that all complete definitions of in-
tensional entities be finite as well as unique and noncircular: it offers an algebraic way
for definition of complex intensional entities from simple (atomic) entities (i. e., alge-
bra of concepts), conception also evident in Leibniz’s remarks. In a predicate logics,
predicates and open-sentences (with free variables) expresses classes (properties and
relations), and sentences express propositions. Note that classes (intensional entities)
are reified, i. e., they belong to the same domain as individual objects (particulars).
This endows the intensional logics with a great deal of uniformity, making it possi-
ble to manipulate classes and individual objects in the same language. In particular,
when viewed as an individual object, a class can be a member of another class.
The standard semantics of First-order Logic (FOL) are Tarski-style models, which
are extensional. In this respect, FOL is extensional. But the open question is if it is pos-
sible to obtain also an intensional semantics of FOL such that the Tarski’s extensions
of its expressions are equal to extensions of concepts (intensional entities) of the same
FOL expressions in the actual possible world.
1.1.1 Introduction to first-order logic
We will shortly introduce the syntax of the first-order logic (FOL) language ℒ, and its
extensional semantics based on Tarski’s interpretations, as follows.
Definition 1. The syntax of the first-order logic language ℒis as follows: Logic opera-
tors (∧, ¬, ∃) over bounded lattice of truth values 2 = {f, t}, f for falsity and t for truth;
Predicate letters pk1
1 , pk2
2 , . . . with a given arity ki ≥1, i = 1, 2, . . . , and special built-in
identity binary predicate “≐,” in P; Functional letters f k1
1 , f k2
2 , . . . with a given arity ki ≥1
in F (language constants c, d, . . . are considered as particular case of nullary functional
letters); Variables x, y, z, . . . in 𝒱, and punctuation symbols (comma, parenthesis).
With the following simultaneous inductive definition of term and formula:
1.
All variables and constants are terms.
2.
If t1, . . . , tk are terms and f k
i ∈F is a k-ary functional symbol, then f k
i (t1, . . . , tk) is a
term, while pk
i (t1, . . . , tk) is a formula for a k-ary predicate letter pk
i ∈P.
3.
If ϕ and ψ are formulae, then (ϕ ∧ψ), ¬ϕ, and (∃xi)ϕ for xi ∈𝒱are formulae.

1.1 Introduction
|
3
An interpretation (Tarski) IT consists in a nonempty domain 𝒟and a mapping that
assigns to any predicate letter pk
i ∈P a relation R = IT(pk
i ) ⊆𝒟k, to any functional letter
f k
i ∈F a function IT(f k
i ) : 𝒟k →𝒟, or equivalently, its graph relation R = IT(f k
i ) ⊆𝒟k+1
where the k + 1-th column is the resulting function’s value, and to each individual
constant c ∈F one given element IT(c) ∈𝒟.
A predicate logic ℒP is a subset of the FOL without the quantifier ∃.
Remark. The propositional logic can be considered as a particular case of predicate
logic when all symbols in P are nullary, that is a set of propositional symbols, while F,
𝒟and 𝒱are empty sets. By considering that 𝒟0 = {⟨⟩} is a singleton set composed
by empty tuple ⟨⟩, then for any pi ∈P, IT(pi) ⊆𝒟0, i. e., IT(pi) = f (empty set) or
IT(pi) = t (singleton set {⟨⟩}). That is, IT becomes an interpretation IT : P →2 of this
logic, which can be homomorphically extended to all formulae in the unique standard
way.
In a formula (∃x)ϕ, the formula ϕ is called “action field” for the quantifier (∃x).
A variable y in a formula ψ is called bounded variable iff it is the variable of a quantifier
(∃y) in ψ, or it is in the action field of a quantifier (∃y) in the formula ψ. A variable x
is free in ψ if it is not bounded.
The universal quantifier is defined by ∀= ¬∃¬. Disjunction and implication are
expressed by ϕ∨ψ = ¬(¬ϕ∧¬ψ), and ϕ ⇒ψ = ¬ϕ∨ψ. In the FOL with the identity ≐,
the formula (∃1x)ϕ(x) denotes the formula (∃x)ϕ(x) ∧(∀x)(∀y)(ϕ(x) ∧ϕ(y) ⇒(x ≐y)).
We can introduce the sorts in order to be able to assign each variable xi to a sort
Si ⊆𝒟where 𝒟is a given domain for the FOL (e. g., for natural numbers, for reals, for
dates, etc. as used for some attributes in database relations). An assignment g : 𝒱→𝒟
for variables in 𝒱is applied only to free variables in terms and formulae. If we use
sorts for variables, then for each sorted variable xi ∈𝒱an assignment g must satisfy
the auxiliary condition g(xi) ∈Si.
Such an assignment g ∈𝒟𝒱can be recursively uniquely extended into the assign-
ment g∗: 𝒯→𝒟, where 𝒯denotes the set of all terms, by:
1.
g∗(ti) = g(x) ∈𝒟if the term ti is a variable x ∈𝒱.
2.
g∗(ti) = IT(c) ∈𝒟if the term ti is a constant c ∈F.
3.
If a term ti is f k
i (t1, . . . , tk), where f k
i ∈F is a k-ary functional symbol and t1, . . . , tk
are terms, then g∗(f k
i (t1, . . . , tk)) = IT(f k
i )(g∗(t1), . . . , g∗(tk)) or, equivalently, in the
graph interpretation of the function, g∗(f k
i (t1, . . . , tk)) = u such that (g∗(t1), . . . ,
g∗(tk), u) ∈IT(f k
i ) ⊆𝒟k+1.
In what follows, we will use the graph interpretation for functions in FOL like its inter-
pretation in intensional logics. We denote by ti/g (or ϕ/g) the ground term (or formula)
without free variables, obtained by assignment g from a term ti (or a formula ϕ), and
by ϕ[x/ti] the formula obtained by uniformly replacing x by a term ti in ϕ. A sentence
is a formula having no free variables.

4
|
1 Theory of new intensional first-order logic
A Herbrand base of a logic ℒis defined by
H = {pk
i (t1, . . . , tk) | pk
i ∈P and t1, . . . , tk are ground terms}.
A FOL interpretation I is a triple (𝒟, g, IT), where 𝒟is domain of interpretation, g ∈𝒟𝒱
an assignment and IT is a function (called valuation v as well) that maps constants of
FOL (nullary functions) into domain 𝒟, the k-ary predicate into relation 𝒟k and k-ary
function into relation 𝒟k+1 as explained above in reason of intensional FOL.
Tarski defined the satisfaction for the logic formulae in ℒand a given assignment
g : 𝒱→𝒟inductively (recursively), as follows.
If a formula ϕ is an atomic formula pk
i (t1, . . . , tk), then this assignment g satisfies
ϕ iff (g∗(t1), . . . , g∗(tk)) ∈IT(pk
i ); g satisfies ¬ϕ iff it does not satisfy ϕ; g satisfies ϕ ∧ψ
iff g satisfies ϕ and g satisfies ψ; g satisfies (∃xi)ϕ iff exists an assignment g′ ∈𝒟𝒱that
may differ from g only for the variable xi ∈𝒱, and g′ satisfies ϕ.
A model is ℳ= (𝒟, IT), so that for g ∈𝒟𝒱and a formula ϕ we use the notation
ℳ󳀀󳨐g ϕ
or
I∗
T (ϕ/g) = t ∈2,
(1.1)
which means “the formula ϕ is true in the model ℳ= (𝒟, IT), for assignment g.”
Remark. In what follows, instead of notation ℳ󳀀󳨐g ϕ, we prefer to use the nonstan-
dard functional notation I∗
T (ϕ/g), because in intensional FOL the new symbol I∗
T will
denote a homomorphism between the syntax algebra of FOL and extensional algebra of
relations (of extensional logic which allows evaluation of the truth value of a sentence,
in Corollary 1, Section 1.2). So, for ground atoms I∗
T is equal to Herbrand interpretation,
instead, for atoms with variables only it is equal to original Tarski’s mapping IT. That
is, for any atom pk
j (x) with variables x = (x1, . . . , xk),
IT(pk
j ) = I∗
T (pk
j (x)) = {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱, and I∗
T (pk
j (x)/g) = t}
(1.2)
A formula ϕ is true for a given interpretation IT iff ϕ is satisfied by every assign-
ment g ∈𝒟𝒱. A formula ϕ is valid (i. e., tautology) iff ϕ is true for every Tarski’s
interpretation IT ∈IT. An interpretation IT is a model of a set of formulae Γ iff every
formula ϕ ∈Γ is true in this interpretation. By FOL(Γ), we denote the FOL with a set
of assumptions Γ, and by IT(Γ) the subset of Tarski’s interpretations that are models
of Γ, with IT(0) = IT. A formula ϕ is said to be a logical consequence of Γ, denoted by
Γ ⊩ϕ, iff ϕ is true in all interpretations in IT(Γ).
Thus, ⊩ϕ iff ϕ is a tautology.
The basic set of axioms of the FOL are that of the propositional logic with two
additional axioms:
–
(A1) (∀x)(ϕ ⇒ψ) ⇒(ϕ ⇒(∀x)ψ), (x does not occur in ϕ and it is not bound
in ψ).

1.1 Introduction
|
5
–
(A2) (∀x)ϕ ⇒ϕ[x/ti], (neither x nor any variable in ti occurs bound in ϕ).
–
(A3) For the FOL with identity (the binary predicate ≐), we need the proper axiom
x1 ≐x2 ⇒(x1 ≐x3 ⇒x2 ≐x3).
We denote by R= the Tarski’s interpretation of ≐.
The inference rules are modus ponens and generalization (G) “if ϕ is a theorem and x
is not bound in ϕ, then (∀x)ϕ is a theorem.”
Here, the FOL denotes this minimal first-order logic (consistent and complete),
while FOL(Γ) denotes a logic extended by a new set of proper axioms in Γ and, gener-
ally (by the Gödel theorem), it is not complete.
In what follows, any open-sentence, a formula ϕ(x) with nonempty tuple of free
variables x = (x1, . . . , xm), will be called a m-ary virtual predicate, denoted also by
ϕ(x1, . . . , xm). This definition contains the precise method of establishing the ordering
of variables in this tuple: such a method that will be adopted here is the ordering of
appearance, from left to right, of free variables in ϕ, as explained in Definition 8 with
important properties for the intensional concepts of the intensional logics.
The FOL is considered as an extensional logic because two open sentences with
the same tuple of variables ϕ(x1, . . . , xm) and ψ(x1, . . . , xm) are equal iff they have the
same extension in a given interpretation IT, i. e., iff I∗
T (ϕ(x1, . . . , xm)) = I∗
T (ψ(x1, . . . , xm)),
where I∗
T is the unique extension of IT to all formulae, as follows:
1.
For a (closed) sentence ϕ/g, we have that I∗
T (ϕ/g) = t iff g satisfies ϕ, as recursively
defined above.
2.
For an open sentence ϕ with the tuple of free variables (x1, . . . , xm), we have that
I∗
T (ϕ(x1, . . . , xm)) =def {(g(x1), . . . , g(xm)) | g ∈𝒟𝒱and I∗
T (ϕ/g) = t}.
It is easy to verify that for a formula ϕ with the tuple of free variables (x1, . . . , xm),
I∗
T (ϕ(x1, . . . , xm)/g) = t
iff
(g(x1), . . . , g(xm)) ∈I∗
T (ϕ(x1, . . . , xm)).
This extensional equality of virtual predicates can be generalized to the extensional
equivalence when both predicates ϕ, ψ has the same set of free variables but their or-
dering in the tuples of free variables are not identical: such two virtual predicates are
equivalent if the extension of the first is equal to the proper permutation of columns
of the extension of the second virtual predicate. It is easy to verify that such an exten-
sional equivalence corresponds to the logical equivalence denoted by ϕ ≡ψ.
Let R = ⋃k∈ℕ𝒫(𝒟k) = ∑k∈ℕ𝒫(Dk) be the set of all k-ary relations over a do-
main 𝒟, where k ∈ℕ= {0, 1, 2, . . .}. Then this extensional equivalence between two
relations R1, R2 ∈R with the same arity will be denoted by R1 ≈R2, while the exten-
sional identity will be denoted in the standard way by R1 = R2.

6
|
1 Theory of new intensional first-order logic
1.1.2 Introduction to multimodal logics
A multimodal logic is a standard predicate/propositional logic (see Definition 1) ex-
tended by a number of existential modal operators ◊i, i ≥1. In the standard Kripke
semantics, each existential modal operator ◊i is defined by an accessibility binary re-
lation ℛi ⊆𝒲×𝒲, for a given set of possible worlds 𝒲. A more exhaustive and formal
introduction to modal logics and their Kripke’s interpretations can easily be found in
the literature, e. g., in [22].
Here, only a short version will be given, in order to clarify the definitions used in
the next paragraphs. We define 𝒩= {0, 1, 2, . . . , n} ⊂ℕwhere n is a maximal arity of
symbols in the finite set P ⋃F of predicate and functional symbols, respectively.
In the case of the propositional logics, we have that n = 0, so that P is a set of
propositional symbols (that are the nullary predicate symbols) and F = 0 is the empty
set. Here, we will present two definitions for modal logics, one for the propositional
and other for predicate logics, as is used in current literature.
Definition 2 (Propositional multimodal logic). By ℳ= (𝒲, {ℛi}, IK), we denote a mul-
timodal Kripke’s interpretation with a set of possible worlds 𝒲, the accessibility re-
lations ℛi ⊆𝒲× 𝒲, i = 1, 2, . . . , and a mapping IK : P →2𝒲, such that for any
propositional letter pi ∈P, the function IK(pi) : 𝒲→2 defines the truth of pi in a
world w ∈𝒲.
For any formula φ, we define ℳ󳀀󳨐w φ iff φ is satisfied in a world w ∈𝒲. For
example, a given propositional letter pi is true in w, i. e., ℳ󳀀󳨐w pi, iff IK(pi)(w) = t.
The Kripke semantics is extended to all formulae as follows:
ℳ󳀀󳨐w φ ∧ϕ
iff
ℳ󳀀󳨐w φ and ℳ󳀀󳨐w ϕ,
ℳ󳀀󳨐w ¬φ
iff
not ℳ󳀀󳨐w φ,
ℳ󳀀󳨐w ◊iφ
iff
exists w′ ∈𝒲such that (w, w′) ∈ℛi and ℳ󳀀󳨐w′ φ.
The universal modal operator ◻i is equal to ¬◊i¬. A formula φ is said to be true in a
Kripke’s interpretation ℳif for each possible world w, ℳ󳀀󳨐w φ. A formula is said to
be valid if it is true in each interpretation.
In a more general cases when n ≥1, we have the multimodal predicate logics
defined as follows.
Definition 3 (Predicate multimodal logic). By ℳ= (𝒲, {ℛi | 1 ≤i ≤k}, 𝒟, IK), we
denote a multimodal Kripke model with finite k ≥1 modal operators with a set of
possible worlds 𝒲, the accessibility relations ℛi ⊆𝒲× 𝒲, nonempty domain 𝒟, and
a mapping IK : 𝒲× (P ⋃F) →⋃n∈𝒩(2 ⋃𝒟)𝒟n, such that for any world w ∈𝒲,
1.
For any functional letter f k
i ∈F, IK(w, f k
i ) : 𝒟k →𝒟is a function (interpretation of
f k
i in w).

1.1 Introduction
|
7
2.
For any predicate letter pk
i ∈P, the function IK(w, pk
i ) : 𝒟k →2 defines the exten-
sion of pk
i in a world w,
󵄩󵄩󵄩󵄩pk
i (x1, . . . , xk)󵄩󵄩󵄩󵄩ℳ,w =def {(d1, . . . , dk) ∈𝒟k | IK(w, pk
i )(d1, . . . , dk) = t}.
For any formula φ, we define ℳ󳀀󳨐w,g φ iff φ is satisfied in a world w ∈𝒲for a
given assignment g : 𝒱→𝒟. For example, a given atom pk
i (x1, . . . , xk) is satisfied in w
by assignment g, i. e., ℳ󳀀󳨐w,g pk
i (x1, . . . , xk), iff IK(w, pk
i )(g(x1), . . . , g(xk)) = t.
The Kripke semantics is extended to all formulae as follows:
ℳ󳀀󳨐w,g φ ∧ϕ
iff
ℳ󳀀󳨐w,g φ and ℳ󳀀󳨐w,g ϕ,
ℳ󳀀󳨐w,g ¬φ
iff
not ℳ󳀀󳨐w,g φ,
ℳ󳀀󳨐w,g ◊iφ
iff
exists w′ ∈𝒲such that (w, w′) ∈ℛi and ℳ󳀀󳨐w′,g φ.
A formula φ is said to be true in a Kripke’s interpretation ℳif for each assignment
function g and possible world w, ℳ󳀀󳨐w,g φ. A formula is said to be valid if it is true in
each interpretation.
Any virtual predicate ϕ(x1, . . . , xk) has different extensions ‖ϕ(x1, . . . , xk)‖ℳ,w =def
{(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and ℳ󳀀󳨐w,g ϕ} for different possible worlds w ∈𝒲. Thus,
we cannot establish the simple extensional identity for two concepts as in FOL.
Remark. We can consider the following reductions and extensions of the modal pred-
icate logics:
–
The propositional modal logic can be considered as a particular case of a predi-
cate modal logic when all symbols in P are nullary, that is a set of propositional
symbols, while F, 𝒟and 𝒱are empty sets. So that IK is reduced to a mapping
IK : P →2𝒲, such that we do not use the assignments g, and for any proposi-
tional letter pi ∈P, the function IK(pi) : 𝒲→2 defines the truth of pi in a world
w ∈𝒲;
–
However, as we will present in Definition 12 we can generalize this standard Kripke
semantics of modal predicate logic by introducing generalized possible worlds
𝕎=def 𝒲×𝒟𝒱, so that each generalized world w = (w, g) ∈𝕎is a tuple of two dif-
ferent types of worlds, original (or explicit) worlds w ∈𝒲and the new kind of in-
trinsic worlds g ∈𝒟𝒱(i. e., the assignments g : 𝒱→𝒟), and by introducing more
powerful nonstandard Kripke interpretations IK : 𝕎× (P ⋃F) →⋃n∈𝒩(2 ⋃𝒟)𝒟n.
In this case, we obtain the satisfaction relation of a formula φ can be given simply
as in the case of the propositional modal logics, i. e., by ℳ󳀀󳨐w φ iff φ is satisfied
in a world w ∈𝕎. So, e. g., in the case of the standard predicate modal logic in
Definition 3 above, we will have that
ℳ󳀀󳨐w pk
i (x1, . . . , xk),
iff
IK(w, pk
i )(g(x1), . . . , g(xk)) = t.

8
|
1 Theory of new intensional first-order logic
We will see in next sections how we are able to enrich the FOL with intensional
properties, by giving them a modal semantics (for the FOL quantifiers) and by
providing the more sophisticated mappings IK.
It seams apparently that Tarski’s interpretation for the FOL and the Kripke’s inter-
pretation for modal predicate logics are inconceivable. Currently, each modal logic is
considered as a kind of intensional logic. The open question is what about the modal-
ity in the FOL, if it is intrinsic also in the FOL, i. e., if there is an equivalent multimodal
transformation of the FOL where the Kripke’s interpretation is equivalent to the orig-
inal Tarski’s interpretation for the FOL. The positive answer to these questions is one
of the main contributions of this chapter.
1.1.3 Two significant approaches to intensional first-order logic
Intensional entities are such things as concepts, propositions and properties. What
make them “intensional” is that they violate the principle of extensionality; the princi-
ple that extensional equivalence implies identity. All (or most) of these intensional en-
tities have been classified at one time or another as kinds of universals [23]. In the next
section, we will shortly consider two different approaches to intensions: Motague’s
and Bealer’s approaches.
Montague’s approach
In the Montague’s possible worlds representation [7–11], the intension of a proposition
is a function from possible worlds 𝒲to truth values, and properties and functions from
𝒲to sets of possible (usually not-actual) objects.
In what follows, we will use one simplified S5 modal logic framework (we will
not consider the time as one independent parameter as in Montague’s original work)
with a model ℳ= (𝒲, ℛ, 𝒟, IK), where 𝒲is the set of explicit possible worlds, ℛis a
reflexive, symmetric and transitive accessibility relation between worlds (ℛ= 𝒲×𝒲),
𝒟is a non-empty domain of individuals, while IK is a function defined in Definition 3.
Definition 4 (Montague’s intension). For a given logical language ℒ, Montague de-
fined the intension as a mapping
In : ℒ→R𝒲
where R = ⋃k∈ℕ𝒫(𝒟k) is the set of all k-ary relations, where k ∈ℕ= {0, 1, 2, . . .}.
One thing that should be immediately clear is that intensions are more general
that extensions: if the intension of an expression is given, one can determine its ex-
tension with respect to a particular world but not vice versa.

1.1 Introduction
|
9
Remark. The problematic issue of the Montague’s approach is that it is not a construc-
tive approach to intensional logic. The intension of one concept is defined mathemat-
ically as the mapping from the (possibly infinite) set of possible worlds to the possi-
ble extension of this concepts in these worlds. But we have no always the knowledge
in what is exactly this set of possible worlds, so that 𝒲can be a generally not well-
defined set (the set is defined by its members and we do not know all these members),
and especially, we do not know apriory what is exact extension for this concept in each
of these possible worlds (factual omniscience1). Simply, we are not able to define the
intension of any nonrigid2 concept so that we cannot use practically any algebra over
these intensional objects. Moreover, if we are not able to know all world, and hence
the extensions of two concepts in them, we are not able to specify that these two con-
cepts have the same mining (because can exists other unknown worlds in which they
have no the same extension). Just because of that, I used Bealer’s method for the gen-
eration of the intensional algebra of meanings, by defining the algebra 𝒜int, in which
we can use directly the terms of the equality of two intensional concepts of the same
type (as shown in Example 4 in Section 1.3).
In fact, we can consider that the extension of the same nonrigid concept in differ-
ent possible worlds can be different, so that we cannot use the standard extensional,
set-based logic for such concepts: but this extensional variability of the concept is the
result only of the fact that they are intensional concepts. As we noted, the intensional
concepts (or classes) are conceptual processes that examine real-world images, and
give the one of the possible answers: “yes,” “no,” or “do not know” for the fact that
this image is a member of this class. For example, let us consider as real-world image
any one-page text written in English, and the text mining software developed to rec-
ognize if a text presented as its input describes some car (and we suppose that it is
embedded into a black box; any attempt to access its code in order to analyze it would
destroy it): in that case, the intension of the nonrigid concept “car” corresponds to
the examination process implemented by this software. In any possible world (e. g.,
today, tomorrow, after tomorrow, etc.), we are able to present some number of docu-
ments to this software and obtain the answers: the set of documents with the answer
“yes” from this software will correspond to the extension of the intensional concept
‘car” in a given world. But we have no general set of all possible one-page documents
in order to be able to establish all possible extensions in all possible worlds. Practi-
cally, we are not able to define the meaning of this software based only on the finite
1 If the speaker knows the composition of all the possible worlds, the actual included, then he knows
the latter ipso fact. This conclusion, however, does not follow. What he is missing is the ability to tell
the actual world from the other possible worlds, i. e., the ability to recognize the actual world as such.
2 Variables may be given world-independent meanings in models. Such meanings are said to be rigid.
Historically, this was the first quantified modal semantics to be introduced, and technically it is the
simplest approach.

10
|
1 Theory of new intensional first-order logic
number of its elaborations, i. e., the intension of the concept “car” in this case can not
be constructively defined based on the extensions in possible worlds.
However, I decided to make the embedding of the Montague’s semantics as well,
because the syntactic rules of a natural language are formulated in his basic papers in
terms of recursive definitions (recursive semantics thesis of Donald Davidson, based
on Frege’s compositionality principle,
“the meaning of a sentence is a function of the meaning of its parts and of their mode of combina-
tions”)
specifying how complex sentences are to be formed out of simpler ones. These syntac-
tic rules constitute a categorial grammar. Researches of natural language tried previ-
ously to develop a notation to restrain natural language to an existing formal language
such as predicate calculus. The spirit of Montague’s contribution is exactly the oppo-
site: it models logical calculations according to the syntax of natural language, with
the aim of formalizing valid reasoning process, which resist being so restraint. This
recursive method I implemented in the intensional algebra 𝒜int in the way that by in-
tensional interpretation of the FOL syntax we obtain complex intensional terms of this
algebra.
Bealer’s approach
In his approach [12] to the intensional logic the fundamental entities are intensional
abstracts or the so-called, “that-clauses.” We assume that they are singular terms; In-
tensional expressions like “mean, and “assert” are standard two-place predicates that
take “that-clauses” as arguments. Expressions like “is interesting,” “is nice,” etc., can
be considered as one-place predicates that take “that”-clauses as arguments. For ex-
ample, in the “intensional sentence,” it is nice “that ϕ,” where ϕ is a proposition,
the “that ϕ” is denoted by the ⋖ϕ⋗, where ⋖⋗is the intensional abstraction operator,
which transforms a logic formula into a term. So that the sentence “it is nice that ϕ”
is expressed by the logic atom N(⋖ϕ⋗), where N is the unary predicate “is nice.”
In this way, we are able to avoid to have the higher-order syntax for our inten-
sional logic language (predicates appear in variable places of other predicates), as for
example, HiLog [24] where the same symbol may denote a predicate, a function or an
atomic formula. In the FOL with intensional abstraction, we have more fine distinction
between a sentence ϕ and its use as a term “that ϕ,” denoted by ⋖ϕ⋗and considered
as intensional name, inside some other predicate and, e. g., to have the first-order for-
mula ¬ϕ ∧p2
i (t, ⋖ϕ⋗) instead of the second-order HiLog formula ¬ϕ ∧p2
i (t, ϕ).
Definition 5. The syntax of the first-order logic language with intensional abstraction
⋖⋗, denoted by ℒ, is as follows:
Logic operators (∧, ¬, ∃); predicate letters in P (functional letters are considered
as particular case of predicate letters); variables x, y, z, . . . in 𝒱; abstraction ⋖_⋗and

1.2 Intensionality and intensional/extensional semantics
|
11
punctuation symbols (comma, parenthesis). With the following simultaneous induc-
tive definition of term and formula:
1.
All variables and constants (0-ary functional letters in P) are terms.
2.
If t1, . . . , tk are terms, then pk
i (t1, . . . , tk) is a formula (pk
i ∈P is a k-ary predicate
letter).
3.
If ϕ and ψ are formulae, then (ϕ ∧ψ), ¬ϕ, and (∃x)ϕ are formulae.
4.
If ϕ(x) is a formula and, from Definition 23 in Section 2.1.1, α ⊆x is a possibly
empty subset of hidden (compressed) variables, then ⋖ϕ(x)⋗β
α is an abstracted
term where β is remained subset of free visible variables in ϕ. So, the subtuples of
hidden and visible variables (preserving the ordering of the tuple x are π−βx and
π−αx, respectively). If α or β is empty sequence, then it can be omitted (e. g., if ϕ
is closed formula, then this term is denoted by ⋖ϕ⋗). An occurrence of a variable
xi in a formula (or a term) is bound (free) iff it lies (does not lie) within a formula
of the form (∃xi)ϕ (or a term of the form ⋖ϕ(x)⋗β
α with xi ∈α). A variable is free
(bound) in a formula (or term) iff it has (does not have) a free occurrence in that
formula (or term).
A sentence is a formula having no free variables. The logic operators ∀, ∨, ⇒are defined
in terms of (∧, ¬, ∃) in the usual way.
For example, “x tells that ϕ” is given by formula p2
k(x, ⋖ϕ⋗) (p2
k is a binary “tell”
predicate), ‘being a bachelor is the same thing as being an unmarried man” is given
by the identity of terms ⋖p2
k(x)⋗x = ⋖p1
i (x) ∧p1
j (x)⋗x (with p2
k for “bachelor,” p1
i for
“unmarried” and p1
j for “man,” unary predicates).
Remark. The k-ary functional symbols, for k ≥1, in standard (extensional) FOL are
considered as (k + 1)-ary predicate symbols pk+1: the function f : 𝒟k →𝒟is con-
sidered as a relation obtained from its graph R = {(d1, . . . , dk, f (d1, . . . , dk)) | di ∈𝒟},
represented by a predicate symbol pk+1.
1.2 Intensionality and intensional/extensional semantics
Contemporary use of the term “intension” derives from the traditional logical doctrine
that an idea has both an extension and an intension. Although there is divergence in
formulation, it is accepted that the extension of an idea consists of the subjects to
which the idea applies, and the intension consists of the attributes implied by the
idea. In contemporary philosophy, it is linguistic expressions (here it is a logic for-
mula), rather than concepts, that are said to have intensions and extensions. The in-
tension is the concept expressed by the expression, and the extension is the set of
items to which the expression applies. This usage resembles use of Frege’s use of “Be-
deutung” and “Sinn” [25]. It is evident that two ideas could have the same extension
but different intensions. The systematic study of intensional entities has been pursued

12
|
1 Theory of new intensional first-order logic
largely in the context of intensional logic; that part of logic in which the principle of
(extensional) substitutivity of equivalent expressions fails.
Intensional entities (or concepts) are such things as propositions, relations and
properties. What make them “intensional” is that they violate the principle of exten-
sionality; the principle that extensional equivalence implies identity. All (or most) of
these intensional entities have been classified at one time or another as kinds of uni-
versals [23]. Accordingly, standard traditional views about the ontological status of
universals carry over to intensional entities. Nominalists hold that they do not really
exist. Conceptualists accept their existence but deem it to be mind-dependent. Real-
ists hold that they are mind-independent. Ante rem realists hold that they exist inde-
pendently of being true of anything; in re realists require that they be true of something
[23]. In what follows, we adopt the Ante rem realism.
In a predicate logics, (virtual) predicates expresses classes (properties and rela-
tions), and sentences express propositions. Note that classes (intensional entities) are
reified, i. e., they belong to the same domain as individual objects (particulars). This
endows the intensional logics with a great deal of uniformity, making it possible to
manipulate classes and individual objects in the same language. In particular, when
viewed as an individual object, a class can be a member of another class.
The extensional reductions, such as propositional complexes and propositional
functions, to intensional entities are inadequate, there are several technical difficul-
ties [26], so that we adopt the nonreductionist approaches and we will show how it
corresponds to the possible world semantics. We begin with the informal theory that
universals (properties (unary relations), relations and propositions in PRP theory [27])
are genuine entities that bear fundamental logical relations to one another. To study
properties, relations and propositions, one defines a family of set-theoretical struc-
tures, one defines the intensional algebra, a family of set-theoretical structures most
of which are built up from arbitrary objects and fundamental logical operations (con-
junction, negation, existential generalization, etc.) on them.
The value of both traditional conceptions of PRPs (the “possible worlds” and “al-
gebraic” Russel’s approaches) is evident, and in Bealer’s work both conceptions are
developed side by side [12]. But Bealer’s approach to intensional logic locates the
origin of intensionality a single underlying intensional abstraction operation, which
transforms the logic formulae into terms, so that we are able to make reification of
logic formulae without the necessity of the second-order logics. In fact, the inten-
sional abstracts are the so-called “that-clauses,” as explained in the Introduction (Sec-
tion 1.1.3).
Definition 6 (Intensional logic PRP domain 𝒟). Inintensionllogic,theconcepts(prop-
erties, relations and propositions) are denotations for open and closed logic sen-
tences, thus elements of the structured domain 𝒟= D−1 + DI, (here + is a disjoint
union) where

1.2 Intensionality and intensional/extensional semantics
|
13
–
A subdomain D−1 is made of particulars (individuals).
–
The rest DI = D0 + D1 . . . + Dn . . . is made of universals (concepts):3 D0 for propo-
sitions with a distinct concept Truth ∈D0, D1 for properties (unary concepts) and
Dn, n ≥2, for the n-ary concept.
The concepts in 𝒟I are denoted by u, v, . . . , while the values (individuals) in D−1
by a, b, . . . The empty tuple ⟨⟩of the nullary relation r0 (i. e., the unique tuple of 0-ary
relation) is an individual in D−1, with 𝒟0 =def {⟨⟩}. Thus, we have that {f, t} = 𝒫(𝒟0) ⊆
𝒫(D−1), where by f and t we denote the empty set 0 and set {⟨⟩}, respectively.
A sort S is a subset of a domain 𝒟. For example, [0, 1] is closed interval of reals sort,
{0, 1, 2, 3, . . .} ⊆D−1 is the sort of integers, etc. These sorts are used for sorted variables
in many-sorted predicate logics so that the assigned values for each sorted variable
must belong to its sort. The unsorted variables can be considered as variables with a
top sort equal to 𝒟.
The intensional interpretation is a mapping between the set ℒof formulae of the
logic language and intensional entities in 𝒟, I : ℒ→𝒟is a kind of “conceptualiza-
tion,” such that an open sentence (virtual predicate) ϕ(x1, . . . , xk) with a tuple of all
free variables (x1, . . . , xk) is mapped into a k-ary concept, i. e., an intensional entity
u = I(ϕ(x1, . . . , xk)) ∈Dk, and (closed) sentence ψ into a proposition (i. e., logic con-
cept) v = I(ψ) ∈D0 with I(⊤) = Truth ∈D0 for the FOL tautology ⊤∈ℒ(the falsity
in the FOL is a logic formula ¬⊤∈ℒ). A language constant c is mapped into a partic-
ular a = I(c) ∈D−1 if it is a proper name, otherwise in a correspondent concept in 𝒟.
Thus, in any application of intensional FOL, this intensional interpretation that deter-
mines the meaning (sense) of the knowledge expressed by logic formulae is uniquely
determined (prefixed).
However, the extensions of the concepts (with this prefixed meaning) vary from
a context (possible world, expressed by an extensionalizzation function) to another
context in a similar way as for different Tarski’s interpretations of the FOL.
Definition 7 (Extensions and extensionalization functions). Let R = ⋃k∈ℕ𝒫(𝒟k) =
∑k∈ℕ𝒫(Dk) be the set of all k-ary relations, where k ∈ℕ= {0, 1, 2, . . .}. Notice that
{f, t} = 𝒫(𝒟0) ⊆R, i. e., f, t ∈R, and hence the truth values are extensions in R. We
define the function f⟨⟩: R →R, such that for any R ∈R,
f⟨⟩(R) =def {⟨⟩}
if R
̸= 0;
0 otherwise.
(1.3)
The extensions of the intensional entities (concepts) are given by the set ℰof exten-
sionalization functions h : 𝒟→D−1 + R, such that
3 In what follows, we will define also a language of concepts with intensional connectives defined as
operators of the intensional algebra 𝒜int in Definition 16, so that DI is the set of terms of this inten-
sional algebra.

14
|
1 Theory of new intensional first-order logic
h = h−1 + h0 + ∑
i≥1
hi : ∑
i≥−1
Di 󳨀→D−1 + {f, t} + ∑
i≥1
𝒫(Di)
(1.4)
where h−1 : D−1 →D−1 for the particulars, while h0 : D0 →{f, t} = 𝒫(𝒟0) assigns the
truth values in {f , t} to all propositions with the constant assignment h0(Truth) = t =
{⟨⟩}, and for each i ≥1, hi : Di →𝒫(Di) assigns a relation to each concept.
Consequently, intensions can be seen as names of atomic or composite concepts,
while the extensions correspond to various rules that these concepts play in different
worlds.
Thus, for any open sentence ϕ(x1, . . . , xk), we have that its extension, in a given
world w ∈𝒲of the Kripke’s interpretation ℳ= (𝒲, {ℛi | 1 ≤i ≤k}, 𝒟, IK) for modal
(intensional) logics in Definition 3, is equal to
h(I(ϕ(x1, . . . , xk))) = 󵄩󵄩󵄩󵄩ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩ℳ,w
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and ℳ󳀀󳨐w,g ϕ}.
The intensional entities for the same logic formula, e. g., x2 + 3 = x2
1 −4, which can
be denoted by ϕ(x2, x1) or ϕ(x1, x2), from above we need to differentiate their con-
cepts by I(ϕ(x2, x1))
̸= I(ϕ(x1, x2)) because otherwise we would obtain erroneously that
h(I(ϕ(x2, x1))) = h(I(ϕ(x1, x2))). Thus, in intensional logic the ordering in the tuple of
variables x in a given open formula ϕ is very important, as follows.
Definition 8 (Virtual predicates). The virtual predicate obtained from an open formula
ϕ ∈ℒis denoted by ϕ(x1, . . . , xm) where (x1, . . . , xm) is a particular fixed sequence of the
set of all free variables in ϕ. This definition contains the precise method of establishing
the ordering of variables in this tuple: such an method that will be adopted here is
the ordering of appearance, from left to right, of free variables in ϕ. This method of
composing the tuple of free variables is unique and canonical way of definition of the
virtual predicate from a given open formula.
The virtual predicates are useful also to replace the general FOL quantifier on vari-
ables (∃x) by specific quantifiers ∃i of the FOL syntax algebra 𝒜FOL, where i ≥1 is the
position of variable x inside a virtual predicate. For example, the standard FOL for-
mula (∃xk)ϕ(xi, xj, xk, xl, xm) will be mapped into intensional concept ∃3ϕ(x) ∈𝒜FOL
where x is the list(tuple) of variables (xi, xj, xk, xl, xm).
We will denote by ϕ(x1, . . . , xm)λ the virtual predicate, obtained from the (canoni-
cal) virtual predicate ϕ(x1, . . . , xm), with ordering of variables determined by the given
permutation λ : ℕ→ℕ.
Remark. The virtual predicates are used in the syntax FOL algebra 𝒜FOL, in order to
extend the intensional interpretation I into a homomorphism between 𝒜FOL and in-
tensional algebra 𝒜int. We will see that also for the intensional algebra of concepts 𝒜int
in Definition 16, we will use intensional unary operators existsk (corresponding to the
logic quantifiers ∃k), and hence we consider that each n-ary concept u ∈Dn implicitly

1.2 Intensionality and intensional/extensional semantics
|
15
has also the tuple x (with n = |x|) of concepts variables. Having this in mind, we will
never write u(x) ∈Dn, but simply u ∈𝒟n.
We recall that the concepts obtained by intensional mapping I of virtual predi-
cates, will implicitly preserve the (ordered) tuple of variables of such virtual predi-
cates.
It is well known that we are able to make the extensional algebraization of the FOL
by using the cylindric algebras [28] that are the extension of Boolean algebras with a
set of binary operators for the FOL identity relations and a set of unary algebraic oper-
ators (“projections”) for each case of FOL quantification (∃x). In what follows, we will
make an analog extensional algebraization over R but by interpretation of the logic
conjunction ∧by a set of natural join operators over relations introduced by Codd’s
relational algebra [29, 30] as a kind of a predicate calculus whose interpretations are
tied to the database.
Definition 9. Let us define the extensional relational algebra for the FOL by
𝒜R = (R, R=, {⟨⟩}, {⋈S}S∈𝒫(ℕ2), ∼, {π−n}n∈ℕ),
where {⟨⟩} ∈R is the algebraic value correspondent to the logic truth, R= is the binary
relation for extensionally equal elements, with the following operators:
1.
Binary operator ⋈S : R × R →R, such that for any two relations R1, R2 ∈R, the
R1 ⋈S R2 is equal to the relation obtained by natural join of these two relations if
S is a nonempty set of pairs of joined columns of respective relations (where the
first argument is the column index of the relation R1 while the second argument
is the column index of the joined column of the relation R2); otherwise it is equal
to the Cartesian product R1 × R2.
2.
Unary operator ∼: R →R, such that for any k-ary (with k ≥1) relation R ∈
𝒫(𝒟k) ⊂R we have that ∼(R) = 𝒟k\R ∈𝒫(𝒟k), where “\” is the substraction
of relations. For u ∈{f , t} = 𝒫(𝒟0) ⊆R, ∼(u) = 𝒟0\u.
3.
Unary operator π−n : R →R, such that for any k-ary (with k ≥1) relation R ∈
𝒫(𝒟k) ⊂R we have that π−n(R) is equal to the relation obtained by elimination of
the n-th column of the relation R if 1 ≤n ≤k and k ≥2; equal to, from (1.3), f⟨⟩(R)
if n = k = 1; otherwise it is equal to R.
We will use the symbol “=” for the extensional identity for relations in R.
Notice that R is a poset with the bottom element 0 and the top element {⟨⟩}, and
the partial ordering ⪯defined as follows: for any two relations R1, R2 ∈R,
R1 ⪯R2
iff
“for some operation ⋈S it holds that (R1 ⋈S R2) = R1.”
It is easy to verify that for any R ∈R and operation ⋈S it holds that (0 ⋈S R) = 0, and
(R ⋈S {⟨⟩}) = R. That is, 0 ⪯R ⪯{⟨⟩}.

16
|
1 Theory of new intensional first-order logic
Let us define the FOL syntax algebra 𝒜FOL. For example, the FOL formula ϕ(xi, xj,
xk, xl, xm) ∧ψ(xl, yi, xj, yj) will be replaced by a specific virtual predicate ϕ(xi, xj, xk,
xl, xm) ∧S ψ(xl, yi, xj, yj), with S = {(4, 1), (2, 3)}, and then traduced by the algebraic ex-
pression R1 ⋈S R2 where R1 ∈𝒫(𝒟5), R2 ∈𝒫(𝒟4) are the extensions for a given Tarski’s
interpretation IT of the virtual predicate ϕ, ψ relatively. In this example, the resulting
relation will have the following ordering of attributes: (xi, xj, xk, xl, xm, yi, yj). In the case
when S is empty (i. e., its cardinality |S| = 0), then the resulting relation is the Carte-
sian product of R1 and R2. Consequently, we have that for any two formulae ϕ, ψ ∈ℒ
and a particular join operator ⋈S uniquely determined by tuples of free variables in
these two formulae,
I∗
T (ϕ ∧S ψ) = I∗
T (ϕ) ⋈S I∗
T (ψ).
For example, the logic formula (a virtual predicate) ¬ϕ(xi, xj, xk, xl, xm) will be tra-
duced by the algebraic expression 𝒟5\R where R is the extensions for a given Tarski’s
interpretation IT of the virtual predicate ϕ. Consequently, we have that for any formula
ϕ ∈ℒ,
I∗
T (¬ϕ) =∼(I∗
T (ϕ)).
For example, the FOL formula (∃xk)ϕ(xi, xj, xk, xl, xm) will be replaced in 𝒜FOL by a
specific virtual predicate (∃3)ϕ(xi, xj, xk, xl, xm) and then traduced by the algebraic ex-
pression π−3(R) where R is the extension for a given Tarski’s interpretation IT of the vir-
tual predicate ϕ. The resulting relation will have the following ordering of attributes:
(xi, xj, xl, xm). Consequently, we have that for any formula ϕ ∈ℒwith a free variable x,
where m is equal to the position of this variable x in the tuple of free variables in ϕ (or
m = 0 otherwise, where π−0 is the identity function),
I∗
T ((∃m)ϕ) = π−m(I∗
T (ϕ)).
Based on the new set of logical connectives introduced above, where the standard
FOL operators ∧and ∃are substituted by a set of specialized operators {∧S}S∈𝒫(ℕ2) and
{∃n}n∈ℕas explained above, we can define the following free syntax algebra for the
FOL.
Corollary 1 (Extensional FOL semantics). Let 𝒜FOL = (ℒ, ≐, ⊤, {∧S}S∈𝒫(ℕ2), ¬, {∃n}n∈ℕ)
be an extended free syntax algebra for the first-order logic with identity ≐, with the set ℒ
of first-order logic formulae with the set of variables in 𝒱, with ⊤denoting the tautology
formula (the contradiction formula is denoted by ⊥≡¬⊤).
Then, for any Tarski’s interpretation IT its unique extension to all formulae I∗
T :
ℒ→R is also the Tarski’s homomorphism I∗
T : 𝒜FOL →𝒜R from the free syntax
FOL algebra into this extensional relational algebra.

1.2 Intensionality and intensional/extensional semantics
|
17
Proof. The proof is directly from the definition of the semantics of the operators in
𝒜R in Definition 9 and previous examples. Let us take, e. g., the case of conjunction
of logic formulae ϕ(xi, xj, xk, xl, xm) ∧ψ(xl, yi, xj, yj), for which S = {(4, 1), (2, 3)} and:
I∗
T (ϕ ∧S ψ)
= I∗
T (φ) = {(g(xi), g(xj), g(xk), g(xl), g(xm), g(yi), g(yj)) | I∗
T (φ/g) = t}
= {(g(xi), g(xj), g(xk), g(xl), g(xm), g(yi), g(yj)) | I∗
T (ϕ/g ∧S ψ/g) = t}
= {(g(xi), g(xj), g(xk), g(xl), g(xm), g(yi), g(yj)) | I∗
T (ϕ/g) = t and I∗
T (ϕ/g) = t}
= {(g(xi), g(xj), g(xk), g(xl), g(xm), g(yi), g(yj)) | (g(xi), g(xj), g(xk), g(xl), g(xm))
∈I∗
T (ϕ) and (g(xl), g(yi), g(xj), g(yj)) ∈I∗
T (ϕ)}
= I∗
T (ϕ) ⋈S I∗
T (ψ).
Thus, it is enough to show that it is also valid I∗
T (⊤) = {⟨⟩}, and I∗
T (¬⊤) = 0. The first
property comes from the fact that ⊤is a tautology, thus satisfied by every assignment
g, i. e., it is true, i. e., I∗
T (⊤) = t (and t is equal to the empty tuple {⟨⟩}). The second prop-
erty comes from the fact that I∗
T (¬⊤) =∼(I∗
T (⊤)) =∼({⟨⟩}) = 𝒟0\{⟨⟩} = {⟨⟩}\{⟨⟩} = 0.
That is, the tautology and the contradiction have the true and false logic value, respec-
tively, in R.
We have also that I∗
T (≐(x, y)) = IT(≐) = R= for every interpretation IT because ≐is
the built-in binary predicate, i. e., with the same extension in every Tarski’s interpre-
tation.
So, the mapping I∗
T : (ℒ, ≐, ⊤, {∧S}S∈𝒫(ℕ2), ¬, {∃n}n∈ℕ) →𝒜R is a homomorphism
that represents the extensional Tarskian semantics of the FOL.
Notice that the ordering of attributes of resulting relations corresponds to the
method used for generating the ordering of variables in the tuples of free variables
adopted for virtual predicates.
From a logic point of view, two possible worlds w and w′ are indistinguishable if
all sentences have the same extensions in them, so that we can consider an extension-
alization function h as a “possible world,” similar to the semantics of a probabilistic
logic, where possible worlds are Herbrand interpretations for given set of predicate
letters P in a given logic. Thus, for a given modal logic we will have that there is a bi-
jection ℱ: 𝒲→ℰbetween the set of possible worlds and the set of extensionalization
functions.
Definition 10 (Two-step intensional semantics [19]). The intensional semantics of the
logic language with the set of formulae ℒcan be represented by the mapping
ℒ󳨀→I 𝒟󳨐⇒h∈ℰR,
where 󳨀→I is a fixed intensional interpretation I : ℒ→𝒟with image im(I) ⊂𝒟, and
󳨐⇒h∈ℰis the set of all extensionalization functions h = ℱ(w) : im(I) →R in ℰ, where

18
|
1 Theory of new intensional first-order logic
the mapping ℱ: 𝒲→ℰis the mapping from the set of possible worlds to the set of
extensionalization functions.
We use the mapping In : ℒop →R𝒲in Definition 4, where ℒop is a subset of
formulae with free variables (virtual predicates), such that for any virtual predicate
ϕ(x1, . . . , xk) ∈ℒop the mapping In(ϕ(x1, . . . , xk)) : 𝒲→R is the Montague’s meaning
(i. e., intension) of this virtual predicate [7–11], i. e., the mapping, which returns with
the extension of this (virtual) predicate in every possible world in 𝒲.
Note that the domain of h ∈ℰis subset of 𝒟of intensional elements derived only
from the set of formulae ℒused by a singular application, so h1
̸= h2 is determined only
by elements in im(I) and so is determined also the set ℰof (different) extensionaliztion
functions.
Example 1. Let us consider the following two past participles: “bought” and “sold”
(with unary predicates p1
1(x), “x has been bought,” and p1
2(x), “x has been sold”). These
two different concepts in Montague’s semantics would have not only the same exten-
sion but also their intension, from the fact that their extensions are identical in every
possible world.
Within the two-steps formalism, we can avoid this problem by assigning two dif-
ferent concepts (meanings) u = I(p1
1(x)) and v = I(p1
2(x)) in ∈D1.
Note that the same problem we have in the Montague’s semantics for two sen-
tences with different meanings, which bear the same truth value across all possible
worlds: in Montague’s semantics, they will be forced to the same meaning.
Based on this definition, we can establish the direct relationship between Bealer’s
and Montague’s intensionality.
Proposition 1 (Bealer–Montague relationship). For any logic formula (a virtual pred-
icate) ϕ(x), with a tuple of free variables x, its extension in a possible world w ∈𝒲
satisfies the following equation:
ℱ(w)(I(ϕ(x))) = In(ϕ(x))(w)
(1.5)
Proof. The proof is directly from the definition of the identification of a possible world
w of Montague’s approach with the extensional function h = ℱ(w) ∈ℰin the Bealer’s
approach, where In(ϕ(x))(w) is the “functional” intension of Montague, and ℱ(w)
is the Bealer’s extensionalization function corresponding to the Montague’s world
w ∈𝒲.
We adopted this two-step intensional semantics, instead of the well-known Mon-
tague’s semantics (which lies in the construction of a compositional and recursive
semantics that covers both intension and extension) because of a number of its weak-
ness, as that in Example 1 above. But there is also another advantage of this two-step
intensional semantics in Definition 10: here, we are able to define an intensional al-
gebra 𝒜int over intensional entities in 𝒟, which is self-sufficient, different from Mon-

1.2 Intensionality and intensional/extensional semantics
|
19
tague’s semantics where the compositional and recursive semantics of intensions can
be defined only by their extensional properties.
As we will see in Section 1.3, this intensional algebra is defined in the way that
each extensional mapping h = ℱ(w) : 𝒟→R is also a homomorphism between this
intensional algebra 𝒜int and the extensional relational algebra 𝒜R that represents the
compositional and recursive semantics of the extensions in Corollary 1.
In this way, the compositional and recursive semantics of the intensions in 𝒜int
coincides with the Montague’ssemantics,where, e. g.,themappingIn(ϕ∧ψ) : 𝒲→R,
i. e., Montague’s intension of the composite formula ϕ∧ψ is functionally dependent on
the mappings In(ϕ) : 𝒲→R and In(ψ) : 𝒲→R (i. e., dependent on the Montague’s
intensions of ϕ and ψ).
Remark. The mapping In can be extended also to all sentences (the formulae without
free variables), such that for any sentence ϕ, In(ϕ) : 𝒲→{f, t} = 𝒫(𝒟0) ⊆R is a
mapping that defines the truth value (i. e., an extension in R in Definition 7) of this
sentence in each possible world 𝒲. Equivalently to this, Montague’s semantics for
intensions of logic formulae, we can use the Carnap’s semantics [31] of concepts in 𝒟,
i. e., In,c : 𝒟→R𝒲such that the intension of a concept u ∈𝒟is a mapping In,c(u) :
𝒲→R from possible worlds to extensions. This Carnap’s semantics of concepts is
similar to the second mapping of the diagram 𝒟⇒w∈𝒲R in the two-step intensional
semantics.
Tarski’s FOL interpretation we represent by new single mapping I∗
T : ℒ→R, as
explained in the Introduction dedicated to FOL in (1.1) and (1.2). But also intensional
semantics is given by h ∘I : ℒ→R where ∘is a composition of functions. So, if there
is a modal Kripke semantics with a set of possible worlds 𝒲(thus, an intensional
semantics) for FOL, equivalent to the standard FOL semantics given by the Tarski’s
interpretation IT, then we obtain correspondence I∗
T = h ∘I for such FOL, such that for
any ϕ ∈ℒ, h(I(ϕ)) = I∗
T (ϕ). For any constant c of the FOL language, we assume that
I(c) = IT(c) ∈𝒟.
Definition 11 (Tarski’s constraints). This intensional semantics has to preserve stan-
dard Tarski’s semantics of the FOL. That is, for any formula ϕ(x) ∈ℒwith a tuple
of free variables (x1, . . . , xk), and h ∈ℰ, the following conservative conditions for all
assignments g, g′ ∈𝒟𝒱has to be satisfied:
(T)
h(I(ϕ(x)/g)) = t
iff
(g(x1), . . . , g(xk)) ∈h(I(ϕ(x)))
(1.6)
and for each (k −1)-ary functional symbol f k−1 in standard FOL, k ≥2, in intensional
FOL we define ϕ to be a predicate letter pk
i , such that
(TF)
h(I(pk
i (x)/g)) = h(I(pk
i (x)/g′)) = t
and
∀1≤i≤k−1(g′(xi) = g(xi))
implies g′(xk+1) = g(xk+1).

20
|
1 Theory of new intensional first-order logic
We consider that the domain 𝒟is equal in each possible world w ∈𝒲. It is
demonstrated that also in the case of different domains 𝒟w in different possible
worlds, we can always obtain the constant domain model (as in Definition 2.1 in [32])
𝒟= ⋃w∈𝒲𝒟w and by introducing a new built-in binary predicate e(x, y) where x has
as domain the set of possible worlds, so that e(w, d) is true if d ∈𝒟w.
The particulars in 𝒟−1, which are rigid objects like the “Eiffel tower” or “George
Washington,” have equal extension (denotation) in each possible world: it holds from
the fact that for every rigid object c, a possible world w ∈𝒲, and a given intensional
interpretation I we have that d = I(c) ∈𝒟−1 and its extension is h(d) = ℱ(w)(d) = d
constant independently from w.
The nonrigid objects and relative complications considered by Fitting in [2, 32, 33],
as “the gross domestic product of Denmark” or “the Secretary General of the United
Nations,” here are constants c of the language that are mapped into particulars d =
I(c) ∈𝒟−1 with extension h(d) = ℱ(w)(d) = d that depends on the possible world
w ∈𝒲.
The previous considerations explain why in these two-step interpretations, inten-
sional and extensional, we can work in an unified general rigid framework, and over-
come the major difficulties for modal first-order logics, considered by Fitting in the
number of his papers, by introducing new operations like “extension of” operators ↓
and “predicate abstracts,” ⟨λx1, . . . , xn.ϕ⟩that transforms the logic formula with a tu-
ple of free variables ϕ(x1, . . . , xn) into new atomic formula ⟨λx1, . . . , xn.ϕ⟩(t1, . . . , tn) for
any given set of terms ti, i = 1, . . . , n (Definition 2.3 in [32]). Notice that different from
this Fitting’s approach, we do not consider a virtual predicate ϕ(x1, . . . , xn) as a new
atom, but as a standard logic formula.
Another relevant question w. r. t. this two-step interpretations of an intensional
semantics is how in it the extensional identity relation ≐, binary predicate of the iden-
tity of the FOL is managed (we prefer to distinguish this formal symbol ≐∈P of the
built-in identity binary predicate letter in the FOL from the standard mathematical
symbol “=” used in all mathematical definitions).
Here, this extensional identity relation is mapped into the binary concept Id = I(≐
(x, y)) ∈D2, such that (∀w ∈𝒲)(ℱ(w)(Id) = R=), where ≐(x, y) denotes an atom of
the FOL of the binary predicate for identity in FOL, usually written by FOL formula
x ≐y. That is, for every possible world w and its correspondent extensionalization
function h = ℱ(w), the extensional identity relation in 𝒟is the extension of the binary
concept Id ∈D2, as defined by Bealer’s approach to intensional FOL with intensional
abstraction in [12].
1.2.1 First-order logic and modality
In propositional modal logics (see Definition 2), the possible worlds are entities where
a given propositional symbol can be true or false. Thus, from logical point of view the

1.2 Intensionality and intensional/extensional semantics
|
21
possible worlds [34, 35] in Kripke’s relational semantics are characterized by property
to determine the truth of logic sentences. The important question relative to the syntax
of the FOL is if there is a kind of basic set of possible worlds that have such properties.
The answer is affirmative. In fact, if we consider a k-ary predicate letter pk
i as a new
kind of “propositional letter,” then an assignment g : 𝒱→𝒟can be considered as an
intrinsic (par excellence) possible world, where the truth of this “propositional letter”
pk
i is equal to the truth of the ground atom pk
i (g(x1), . . . , g(xk)). Consequently, in what
follows we will denote by 𝒲the set of explicit possible worlds (defined explicitly for
each particular case of modal logics), while the set 𝒟𝒱will be considered as the set
of intrinsic possible worlds (which is invariant and common for every predicate modal
logic introduced in Definition 3). In the case when 𝒱= 0 is the empty set, we obtain the
singleton set of intrinsic possible worlds 𝒟𝒱= {∗}, with the empty function ∗: 0 →𝒟.
By 𝕎⊆{(w, g) | w ∈𝒲, g ∈𝒟𝒱}, we denote the set of (generalized) possible
worlds. In this way, as in the case of propositional modal logic, we obtain that a for-
mula φ is true in a Kripke’s interpretation ℳif for each (generalized) possible world
u = (w, g) ∈𝕎, ℳ󳀀󳨐u φ. By ‖ϕ‖ = {(w, g) ∈𝕎| ℳ󳀀󳨐w,g ϕ}, we denote the set of
all worlds where the formula ϕ is satisfied by interpretation ℳ. Thus, as in the case
of the propositional modal logics, also in the case of predicate modal logics, we have
that a formula ϕ is true iff it is satisfied in all (generalized) possible worlds, i. e., iff
‖ϕ‖ = 𝕎.
Different from the FOL with original Tarski’s interpretation for the unique exis-
tential operator ∃, the modal point of view for the FOL with Kripke’s interpretation re-
places each (∃x), for a variable x ∈𝒱, with a particular existential modal operator ♦x
[36]. As usual, the universal modal operators defined for (∀x) = ¬(∃x)¬ are ◻x = ¬♦x¬.
Consequently, the same syntax for the FOL, given by algebra 𝒜FOL
= (ℒ, ≐,
⊤, {∧S}S∈𝒫(ℕ2), ¬, {∃n}n∈ℕ) in Corollary 1, of a formula (∃n)ϕ can have two equivalent
semantics: the original Tarski’s interpretation that interprets the existential operators
(∃n), and Kripke’s relational interpretation where (∃n) are interpreted as existential
modal operators ♦n. This is valid approach based on the fact that, from the algebraic
point of view, the syntax of (∃n) can be interpreted as an unary operation, which is ad-
ditive, i. e., it holds that (∃n)(ϕ ∨ψ) = (∃n)(ϕ) ∨(∃n)(ψ), and normal, i. e., (∃n)(⊥) = ⊥
where ⊥denotes a contradiction sentence (the negation of the tautology ⊤). This
property is common for all existential modal operators of the normal Kripke modal
logics. In fact, the generalization inference rule (G) of FOL here becomes the rule of
necessitation, and the axiom (A1) a particular case of Kripke axiom of normal modal
logics.
With this new arrangement, we can reformulate the standard semantics for mul-
timodal predicate logic in Definition 3 (π1 and π2 denote the first and the second pro-
jections).
Definition 12 (Generalized Kripke semantics for predicate modal logics). By ℳ
=
(𝕎, {ℛi}, 𝒟, IK), we denote a Kripke’s interpretation with a set of generalized pos-

22
|
1 Theory of new intensional first-order logic
sible worlds 𝕎(with a set of explicit possible worlds 𝒲= π1(𝕎) and 𝒟𝒱= π2(𝕎)),
the accessibility relations ℛi ⊆𝕎× 𝕎, i ∈ℕfor existential modal operators, domain
𝒟and a mapping IK : 𝕎× (P ⋃F) →⋃n∈𝒩2𝒟n, such that for any w = (w, g) ∈𝕎:
1.
For any predicate letter pk
i ∈P, the function IK(w, pk
i ) : 𝒟K →2 defines the exten-
sion of pk
i in a world w,
‖pk
i (x1, . . . , xk)‖ =def {(d1, . . . , dk) ∈𝒟k | IK(w, pk
i )(d1, . . . , dk) = t}.
2.
For any functional letter f k
i
∈F, here considered as a pk+1
i
predicate, IK(w, f k
i ) :
𝒟k+1 →2 defines the graph of this function in a world w (as for a predicate above,
with dk+1 equal to the result of this function).
For any formula φ, we define ℳ󳀀󳨐w φ iff φ is satisfied in a world w = (w, g) ∈𝕎. So,
a given letter pk
i is true in w = (w, g), i. e., ℳ󳀀󳨐w pk
i (x1, . . . , xk) iff IK(w, pk
i )(g(x1), . . . ,
g(xk)) = t.
The Kripke semantics is extended to all formulae as follows:
ℳ󳀀󳨐w φ ∧ϕ
iff
ℳ󳀀󳨐w φ and ℳ󳀀󳨐w ϕ,
ℳ󳀀󳨐w ¬φ
iff not
ℳ󳀀󳨐w φ,
ℳ󳀀󳨐w ◊iφ
iff
exists w′ ∈𝕎such that (w, w′) ∈ℛi and ℳ󳀀󳨐w′ φ.
The universal modal operator ◻i is equal to ¬◊i¬.
A formula φ is said to be true in a Kripke’s interpretation ℳif for each possible
world w, ℳ󳀀󳨐w φ. A formula is said to be valid if it is true in each interpretation.
Note that for the modal predicate logics with generalized Kripke semantics in the
definition above, the satisfaction relation 󳀀󳨐w, while it conserves the same semantics,
has the syntax equal to that used for the propositional modal logics.
Consequently, we have two particular “projections” of the generalized Kripke se-
mantics for multimodal logics, defined above: the first one is an explicit-worlds pro-
jection resulting in the Kripke semantics of multimodal propositional logics (i. e., “PL
𝒦-semantics”); the second one is an intrinsic-worlds projection resulting in the Kripke
semantics of FOL (i. e., “FOL 𝒦-semantics”).
Proposition 2 (Explicit-worlds “projection” into PL 𝒦-semantics). The Kripke seman-
tics of multimodal propositional logic in Definition 2 is a particular case of the Def-
inition 12 when 𝒟, F and 𝒱are empty sets, and P has only nullary symbols, i. e., the
propositional symbols.
Proof. In this case, when 𝒱= 0 is the empty set, we have that 𝒟𝒱is a singleton set,
denoted by {∗}, with unique element equal to the empty function ∗: 𝒱→𝒟(i. e.,
the function with empty graph). Thus, 𝕎= 𝒲× {∗} is equivalent to the set of explicit
worlds 𝒲, so that the original satisfaction relation ℳ󳀀󳨐w,g, where g = ∗, w ∈𝒲, of

1.2 Intensionality and intensional/extensional semantics
|
23
predicate modal logic in Definition 3 can be equivalently reduced to the satisfaction
relation ℳ󳀀󳨐w for only explicit worlds of propositional logic in Definition 3.
While IK : 𝒲× P →⋃n∈𝒩2𝒟n in this case 𝒩= {0} is reduced to IK : 𝒲× P →2𝒟0,
with a singleton set 𝒟0 =def {⟨⟩}, and hence 2𝒟0 is equivalent to 2. So, we obtain the
reduction into the mapping IK : 𝒲× P →2, and by currying (the λ abstraction), we
obtain the mapping I′
K : P →2W, such that for any pi ∈P and w ∈𝒲we have that
IK(w, pi) = I′
K(pi)(w) ∈2 is the truth value of propositional letter (nullary predicate
symbol in P) in the explicit possible world w. It is easy to verify that this obtained
mapping I′
K is that of the propositional modal logic given in Definition 2.
An interesting consequence of this explicit-world projection of the generalized
Kripke semantics is the idea of the extension of a propositional nullary predicate sym-
bol p0
i , denoted here as a propositional symbol pi, given by Definition 12 by
‖pi‖ = ‖p0
i ‖ =def {(d0) ∈𝒟0 | IK(w, p0
i )(d0) = t}
= {⟨⟩| IK(w, p0
i ) = t} = {⟨⟩| I′
K(pi)(w) = t} = I′
K(pi)(w).
That is, it is equal to t = {⟨⟩} if pi is true in the explicit world w, or equal to f (the
empty set) if pi is false in the explicit world w. It is analogous to the consideration of
extensions of sentences defined in the intensional semantics, as defined in Section 1.2,
where the truth is the extension of sentences, distinct from their meaning, i. e., their
intension (from Montague’s point of view, the intension of the propositional letter pi
used above would be the function I′
K(pi) : 𝒲→2).
It is well known for predicate logic and FOL (which is a predicate logic extended
by logic quantifiers) that we have not any defined set of explicit possible worlds. Thus,
trying to define the Kripke semantics (given by Definition 12) to FOL, we can assume
that the generalized possible worlds coincide with the intrinsic possible worlds, i. e.,
𝕎= 𝒟𝒱.
In the case of the pure predicate logic (without quantifiers), we do not need the
possible worlds: a ground atom in order to be true in such a Kripke’s interpretation
has to be true in every possible world (or, alternatively, it has to be false in every pos-
sible world). Consequently, in the predicate logics the truth of ground atoms and sen-
tences is invariant w. r. t. the possible worlds, which renders the definition unuseful of
possible worlds and Kripke’s semantics for these logics. But in the case of the modal
interpretation of the FOL, the FOL quantifiers have to be interpreted by modal opera-
tors and their accessibility relations: thus, the possible worlds are necessary in order
to determine the truth of logic formulae with quantifiers. So, we have the following
case of Definition 12 for the Kripke semantics of the FOL.
Definition 13 (Intrinsic-worlds “projection” into FOL 𝒦-semantics). Kripke semantics
of the FOL is a particular case of the Definition 12 when ℳ= (𝕎, {ℛn | n ∈ℕ}, 𝒟, IK)
is a multimodal Kripke’s interpretation of the FOL, with 𝒲= {ℏ}, where ℏdenotes the

24
|
1 Theory of new intensional first-order logic
so-called actual explicit world. So, a set of (generalized) possible worlds reduces to
𝕎= {ℏ} × 𝒟𝒱(i. e., to the set of intrinsic possible worlds (assignments)), the acces-
sibility relation for each existential modal operator ∃n (corresponding in 𝒜FOL to FOL
quantifier (∃x), x ∈𝒱),
ℛn = {(w1, w2) | w1 = (ℏ, g1), w2 = (ℏ, g2) ∈𝕎for all y ∈𝒱\{x}(g1(y) = g2(y))}
= {(g1, g2) | g1, g2 ∈𝒟𝒱for all y ∈𝒱\{x}(g1(y) = g2(y))},
with nonempty domain 𝒟and a mapping IK : 𝒲× (P ⋃F) →⋃n∈𝒩2𝒟n, such that for
the explicit actual world ℏ∈𝒲:
1.
For any predicate letter pk
i ∈P, the function IK(ℏ, pk
i ) : 𝒟k →2 defines the exten-
sion of pk
i in the actual world ℏ.
2.
For any functional letter f k
i
∈F, here considered as a pk+1
i
predicate, IK(ℏ, f k
i ) :
𝒟k+1 →2 defines the graph of this function in the actual world ℏ.
For a formula φ, we define ℳ󳀀󳨐w φ iff φ is satisfied in a world w = (ℏ, g) ∈𝕎. So,
a given letter pk
i is true in w = (ℏ, g), i. e., ℳ󳀀󳨐w pk
i (x1, . . . , xk) iff IK(ℏ, pk
i )(g(x1), . . . ,
g(xk)) = t, and we denote by ‖φ‖ =def {w = (ℏ, g) ∈𝕎| ℳ󳀀󳨐w φ} the set of worlds in
which φ is true.
The Kripke semantics is extended to all formulae for each word w = (ℏ, g) ∈𝕎
by:
ℳ󳀀󳨐w φ ∧ϕ
iff
ℳ󳀀󳨐w φ and ℳ󳀀󳨐w ϕ,
ℳ󳀀󳨐w ¬φ
iff
not ℳ󳀀󳨐w φ,
ℳ󳀀󳨐w ◊iφ
iff
exists w′ = (ℏ, g′) ∈𝕎such that (w, w′) ∈ℛi and ℳ󳀀󳨐w′ φ.
A formula φ is said to be true in a Kripke’s interpretation IK if for each possible world
w = (ℏ, g) ∈𝕎, we have that ℳ󳀀󳨐w φ. A formula is said to be valid if it is true in each
interpretation IK.
Remark. Notice that the satisfaction relation in the definition above, 󳀀󳨐w where w =
(ℏ, g) ∈𝒲× 𝒟𝒱, can be simplified by the syntax containing only the intrinsic worlds
󳀀󳨐g with g ∈𝒟𝒱, because the set of explicit worlds 𝒲is a singleton composed by the
actual world ℏonly. We will denote by FOL𝒦the FOL with these modal Kripke models.
We recall that FOL𝒦has the same syntax as 𝒜FOL, i. e., the same set of formulae, and
the same domain 𝒟.4
4 Different from the standard embedding of the modal predicate logics into the FOL: this standard
embedding introduces a new built-in predicate symbol for each binary accessibility relation ℛi, and
enlarges the original domain 𝒟with the set of possible worlds, and enlarges the set of variables 𝒱by
the new variables for these new built-in symbols.

1.2 Intensionality and intensional/extensional semantics
|
25
The introduction of the Kripke semantics of the FOL, in Definition 13, is fundamen-
tal in order to obtain a bijective mapping between the set of Kripke interpretations IK
of these modal semantics of FOL and the set of standard Tarski’s interpretation of the
FOL, as it will be demonstrated in the next theorem.
It is easy to verify that each accessibility binary relation ℛn of the modal operator
∃n (corresponding to the FOL quantifier (∃x)) is a reflexive, transitive and symmetric
relation. Thus, each pair of modal operators ♦n (here denoted by ∃n) and ∀n =def ¬∃n¬
is an example of existential and universal modal operators of the S5 modal logics, so
that ∀n is “it is known for all values assigned to x that” modal operator, whose seman-
tics is equivalent to standard FOL “for all values assigned to x” semantics.
It is analogous to monadic algebras of Halmos [37] and his algebraic study of quan-
tifiers, where S5 modal logic is characterized by the class of all closure algebras in
which each closed element is also open. In fact, the complex algebra (over the set of
possible worlds) of this S5 multimodal logic FOL𝒦uses several S5 algebraic modal
operators to provide a Boolean model features of FOL as indicated by Davis [38] in
his doctoral thesis supervised by Garret Birkhoff. As far as I know, Definition 13 is the
first attempt to give a relational Kripke semantics to the FOL, analogous to such an
algebraic approach. As we can see from the definition of Kripke models of the FOL,
every function and predicate are rigid in it, i. e., they have the same extension in every
possible world w ∈𝕎.
Theorem 1. The modal Kripke semantics, with a model ℳin Definition 13, is an ad-
equate semantics for the FOL. For each Tarski’s interpretation IT, there is a unique
Kripke’s interpretation IK, and vice versa, such that for any pk
i ∈P, f k
i
∈F, k ≥1,
(d1, . . . , dk) ∈𝒟k and any intrinsic world (assignment) g : Var →𝒟. It holds that:
IK(ℏ, pk
i )(d1, . . . , dk) = t
iff
(d1, . . . , dk) ∈IT(pk
i )
and
IK(ℏ, f k
i )(d1, . . . , dk, dk+1) = t
iff
dk+1 = IT(f k
i )(d1, . . . , dk).
We define IK(Γ) = {IK defined above from IT | IT ∈IT(Γ)} with the bijection ♭: IT(Γ) ≃
IK(Γ), so that for any Tarski’s interpretation we have its equivalent Kripke’s interpreta-
tion IK = ♭(IT), where Γ is a set of assumptions in this FOL. Moreover, there exists the
following diagram of reductions from the predicate modal logics in Definition 12:
Predicate modal logics
Intrinsic-worlds “projection,” 𝒲= {ℏ} ? FOL𝒦
Propositional modal logics
Explicit-worlds “projection”
?
Actual world reduction, 𝒲= {ℏ}
? Propositional logics
Reduction 𝒱= 𝒟= F = 0
?

26
|
1 Theory of new intensional first-order logic
Proof. Let (d1, . . . , dk) ∈IT(pk
i ), then from definition in this theorem IK(ℏ, pk
i )(d1, . . . ,
dk) = t, and from Definition 13 we obtain that |pk
i (d1, . . . , dk)| = 𝕎, i. e., the ground
atom pk
i (d1, . . . , dk) is true also in correspondent Kripke’s modal semantics. Vice versa,
if (d1, . . . , dk) ∉IT(pk
i ), then ‖pk
i (d1, . . . , dk)‖ = 0 is a empty set, i. e., the ground atom
pk
i (d1, . . . , dk) is false also in the correspondent Kripke’s modal semantics.
Let us suppose that for any closed formula (without free variables) ϕ/g with n logic
connectives, true w. r. t. Tarski’s interpretation IT, it holds that ‖ϕ/g‖ = 𝕎, i. e., it is
true in the correspondent Kripke’s interpretation IK = ♭(IT). Let us show that it holds
for any formula ψ with n + 1 logic connectives, true w. r. t. Tarski’s interpretation IT.
There are the following three cases:
1.
ψ = ϕ1 ∧S ϕ2. Then ‖ψ‖ = ‖ϕ1‖ ⋂‖ϕ2‖ = 𝕎, from the fact that both formulae ϕ1, ϕ2
must be true in Tarski’s interpretation IT and that have less than or equal to n logic
connectives, and consequently (by inductive assumption), ‖ϕi‖ = 𝕎for i = 1, 2.
That is, ψ is true in the correspondent Kripke’s interpretation IK = ♭(IT).
2.
ψ = ¬ϕ. Then ‖ψ‖ = 𝕎\‖ϕ‖ = 𝕎, from the fact that the formula ϕ must be false
in Tarski’s interpretation IT and that has less than or equal to n logic connectives,
and consequently (by inductive assumption), ‖ϕ‖ = 0. That is, ψ is true in the
correspondent Kripke’s interpretation IK = ♭(IT).
3.
ψ = ∃nϕ(x) where ϕ(x) denotes the formula ϕ with the unique free variable x
quantified in FOL by (∃x). From the fact that (∃x)ϕ(x) is true in Tarski’s interpre-
tation, we have that there is a value u ∈𝒟such that a sentence ϕ[x/u] (a formula
ϕ where the variable x is substituted by the value u ∈𝒟) is a true sentence. Then
we obtain
󵄩󵄩󵄩󵄩∃nϕ(x)󵄩󵄩󵄩󵄩= {(ℏ, g) | exists g′ such that (g, g′) ∈ℛn and ℳ󳀀󳨐(ℏ,g′) ϕ(x)} = 𝕎,
because for any assignment g ∈𝒟𝒱there is g′ ∈𝒟𝒱such that g′(x) = u and for
all y ∈(𝒱\{x})g′(y) = g(y), and consequently, (g, g′) ∈ℛn. It holds that ℳ󳀀󳨐(ℏ,g′)
ϕ(x), i. e., ϕ(x) is satisfied for the assignment g′, because g′(x) = u and ϕ(g′(x)) is
equivalent to ϕ[x/u], which is a true sentence with (from the inductive hypothesis)
‖ϕ[x/u]‖ = 𝕎.
Consequently, any sentence, which is true in Tarski’s interpretation, IT is also true
in the Kripke’s interpretation IK = ♭(IT). Vice versa, for any sentence true in Kripke’s
interpretation IK ∈IK(Γ), it can be analogously shown that it is also true in the Tarski’s
interpretation IT = ♭−1(IK), where ♭−1 is inverse of the bijection ♭. Thus, the Kripke’s
semantics given in Definition 13 is an adequate semantics for the FOL.
Thus, both “projections” in the diagram above (the arrow Intrinsic-worlds “projec-
tion” described in Definition 13, and the arrow Explicit-worlds “projection” described
in Proposition 2), where FOL𝒦denotes this adequate Kripke’s version of the FOL (i. e.,
of the 𝒜FOL where the quantifiers ∃n are interpreted as modal existential operators)
are valid.

1.2 Intensionality and intensional/extensional semantics
|
27
Let us show that also other two reductions (which are the arrows in the diagram
of this theorem) into propositional logics are well defined, so that this diagram com-
mutes. So, we consider the following arrows of the diagram:
1.
Actual world reduction, when 𝒲= {ℏ}, corresponding to the bottom horizontal ar-
row in the reduction diagram. Thus, for this unique explicit actual world ℏwe have
that we can have only one (nonempty) accessibility relation ℛi = {(ℏ, ℏ)}, so that
unique possible existential modal operator ♦i, of this modal propositional logic
obtained by this reduction, is an identity operation. That is, obtained reduction is
a propositional logic without modal operators, i. e., it is a pure propositional logic.
In fact, we have that for any propositional formula ϕ and the unique explicit ac-
tual world ℏ∈𝒲(see Definition 12),
ℳ󳀀󳨐ℏ♦iϕ
iff
exists w′ ∈𝒲such that (ℏ, w′) ∈ℛi and ℳ󳀀󳨐w′ ϕ iff ℳ󳀀󳨐ℏϕ.
The Kripke’s mapping IK : P →2𝒲, for the singleton set 𝒲= {ℏ} and the bijection
2{ℏ} ≃2, becomes the propositional interpretation I′
K : P →2. Thus, we obtained
a pure propositional logic in the actual world.
2.
Reduction 𝒱= 𝒟= F = 0, corresponding to the vertical arrow of the reduction
diagram. So, 𝒱is the empty set of variables, and hence P is composed only by
propositional symbols, and hence the obtained logic is without modal operators
(i. e., without the FOL quantifier ∃). Thus, the obtained logic is a propositional
logic with a unique generalized world equal to the empty function ∗: 0 →𝒟,
from the fact that 𝕎= 𝒟0 = {∗}. The Kripke’s mapping IK : 𝒲× P →⋃n∈𝒩2𝒟n
for FOL𝒦in this reduction becomes the mapping IK : {∗} × P →2𝒟0 where 𝒟0 is
the singleton set {⟨⟩}, so that from bijections {∗} × P ≃P and 2{⟨⟩} ≃2 = {f, t}, this
mapping becomes the propositional interpretation I′
K : P →2. Hence, the unique
generalized world ∗is just the actual world ℏ, so that we obtain exactly the same
propositional logics in the actual world, as in the case above.
There is a surprising result from this theorem and its commutative diagram: we ob-
tained that a FOL (i. e., its modal interpretation of quantifiers in FOL𝒦) is a particular
reduction from the predicate modal logics with generalized Kripke semantics (Defini-
tion 12).
It is well known that the propositional modal logics can be, based on modal corre-
spondence theory [39, 40], embedded into the FOL by transforming each propositional
letter pi into an unary predicate p1
i (x) (where x is a new variable with a domain of val-
ues equal to the set of possible worlds of the original propositional modal logic), and
by introducing a binary predicate ℛ(x, y) for the accessibility relation of the Kripke se-
mantics for propositional modal operators. For example, the (T) axiom ◻pi ⇒pi of the
propositional modal logic with the universal modal operator ◻and with the associated
binary accessibility relation ℛover the set of possible worlds, will be translated in the

28
|
1 Theory of new intensional first-order logic
FOL formula (∀x)((∀y)(ℛ(x, y) ⇒p1
i (y)) ⇒p1
i (x)). Analogously, the fact that a proposi-
tional letter pi is satisfied in the possible world w in a given Kripke interpretation ℳ,
denoted by ℳ󳀀󳨐w pi, is translated in the true ground FOL atom p1
i (w).
Let us show that the standard embedding of the modal predicate logic FOL𝒦into
the FOL is not possible. It is possible for translation of satisfaction of the atoms of
FOL𝒦in a possible world w = (ℏ, g), i. e., for ℳ󳀀󳨐w pk
i (x1, . . . , xk), into a ground FOL
atom pk
i (g(x1), . . . , g(xk)). But, for example, the translation of the satisfaction of the
modal formula of FOL𝒦, i. e., for ℳ󳀀󳨐w ∃mpk
i (x1, . . . , xm, . . . , xk) where ∃m is an exis-
tential modal operator corresponding to the FOL quantifier (∃xm), will be the formula
(∃g′)(ℛm(g, g′)∧pk
i (g′(x1), . . . , g′(xm), . . . , g′(xk))). But it is a second-order formula, be-
cause (∃g′) is a quantification over functions (or equivalently over predicates that rep-
resent the graphs of the assignment functions in 𝒟𝒱).
As we will also see that the predicate modal logic FOL𝒦is an extensional logic as
is the FOL (they are equivalent logics), notice that the general predicate modal logics
in Definition 12 are more expressive than the FOL, because they can have also modal
operators different from that used to translate FOL quantifiers. Hence, also without
enriching logics with the intensionality, the modal predicate logics with generalized
Kripke semantics are still more expressive then the FOL.
1.2.2 Modal logics and intensionality
FOL𝒦represents the modal interpretation of the first-order logic, with Kripke rela-
tional semantics based on the set of possible worlds 𝕎= {ℏ} × 𝒟𝒱with a unique
explicit possible world, equal to the actual world ℏ. Consequently, based on consider-
ations in Section 1.2, which demonstrate that each modal logic with a set of possible
worlds can be considered as an intensional logic, we are invited to conclude that also
FOL is intrinsically an intensional logic. That is, by introducing the particular struc-
ture of a domain 𝒟in Definition 6, based on PRPs, we are able to define the intensional
interpretation I of the FOL and the set of extensionalization functions h = ℱ(w) ∈ℰ
for any possible world w = (ℏ, g) ∈𝕎in the FOL𝒦Kripke semantics of the FOL. How-
ever, in the case of modal FOL𝒦we will see that the intensions of logic formulae are
equivalent to their extensions, i. e., the original FOL also with Kripke semantics (equiv-
alent to Tarski’s semantics) is not able to support the intensionality separately from
the extensionality.
Proposition 3. The intension (sense) of any virtual predicate ϕ(x1, . . . , xk) in the FOL𝒦,
with a set of only intrinsic possible worlds 𝕎= {ℏ}×𝒟𝒱, is equivalent to its extension in a
given Tarski’s interpretation of the FOL. That is, it is impossible to support the intensions
in the standard FOL with Tarskian semantics.
Proof. We have to show that the intension (see Definition 10) In(ϕ(x1, . . . , xk)) : 𝕎→R
of any FOL formula ϕ(x1, . . . , xk) in a given Tarski’s homomorphism I∗
T : ℒ→R is a

1.2 Intensionality and intensional/extensional semantics
|
29
constant function from the set of possible worlds 𝕎= {ℏ} × 𝒟𝒱in FOL𝒦, such that for
all w = (ℏ, g) ∈𝕎we have that In(ϕ(x1, . . . , xk))(w) = R, where R = I∗
T (ϕ(x1, . . . , xk)) is
the extension of this formula in Tarski’s interpretation. We can show it by the struc-
tural recursion:
Case 1: When ϕ(x1, . . . , xk) is a predicate letter pk
i ∈P, then
In(pk
i (x1, . . . , xk))(w) = 󵄩󵄩󵄩󵄩pk
i (x1, . . . , xk)󵄩󵄩󵄩󵄩
= {(d1, . . . , dk) ∈𝒟k | ℳ󳀀󳨐w pk
i (d1, . . . , dk)}
= {(d1, . . . , dk) | IK(ℏ, pk
i )(d1, . . . , dk) = t}
= {(d1, . . . , dk) | (d1, . . . , dk) ∈IT(pk
i )} = IT(pk
i ).
Case 2: When ϕ(x1, . . . , xk) is a virtual predicate, from Theorem 1 it holds that, for a
world w = (ℏ, g) ∈𝕎, if for this assignment g ∈𝒟𝒱a ground formula ϕ(x1, . . . , xk)/g
is true in a given Tarski’s interpretation IT (i. e., when I∗
T (ϕ(x1, . . . , xk)/g) = t), then
‖ϕ(x1, . . . , xk)/g‖ = mathbb W (it is true in the correspondent Kripke’s interpretation),
i. e., ℳ󳀀󳨐w ϕ(x1, . . . , xk)/g for every possible world w = (ℏ, g) ∈𝕎. Thus, we have that
the intension of this virtual predicate is
In(ϕ(x1, . . . , xk))(w)
= 󵄩󵄩󵄩󵄩ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩
= {(g(x1), . . . , g(xk)) ∈𝒟k | g ∈𝒟𝒱and ℳ󳀀󳨐w ϕ(x1, . . . , xk)/g}
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and I∗
T (ϕ(x1, . . . , xk)/g) = t}
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and (g(x1), . . . , g(xk)) ∈I∗
T (ϕ(x1, . . . , xk))}
= I∗
T (ϕ(x1, . . . , xk)).
Consequently, the function In is invariant w. r. t. the possible worlds w ∈𝕎, and re-
turns with the extension, of a considered (virtual) predicate, determined by a given
Tarski’s interpretation.
What does it mean? First of all, it means that not every modal logic with a given set
of possible worlds 𝕎is an intensional logic, and that the quality of the intensionality,
which can be expressed by a given modal logic depends on the set of possible worlds
𝕎and their capacity to model the possible extensions of logic formulae. For example,
if 𝕎is a finite set with very small cardinality, it often would not be able to express the
all possible extensions for logic formulae, and consequently, its intensional capability
will be very limited.
But also if 𝕎is infinite, as in the case above when 𝒟is an infinite domain, we
demonstrated that they are not able to express the intensionality (consider, e. g., Mon-
tague’s semantics of the intensional meaning, in which we need a lot of explicit possi-
ble worlds so that the extension in each of these worlds of the same formula with free

30
|
1 Theory of new intensional first-order logic
variables can be different in order to be able to define the intensional meaning (the
“sense”) of such a formula) for the FOL𝒦. The fundamental fact that FOL𝒦(with its
predicate modal semantics) is not an intensional logic is that the set of explicit pos-
sible worlds 𝒲is a singleton set composed by only actual world ℏ. Consequently, in
order to be able to express the full intensionality in a given predicate modal logic, it
is very important to choose the new appropriate set of possible worlds (by an exten-
sion of the explicit possible worlds 𝒲), independently from the original set of possible
worlds of the particular given modal logic.
In fact, from this point of view, the left arrow in the diagram in Theorem 1 repre-
sents the logics with (partial) intensionalities, while the right arrow of the same dia-
gram represents two extremal reductions of the intensionality, by identifying it with
the pure extensionality (the propositional logic can be seen as a modal logic with the
unique actual possible worlds, so that the intensionality corresponds to the exten-
sionality, as in the case of the FOL𝒦).
Remark. The natural choice for the set of explicit possible worlds for the fully inten-
sional logic is the set of interpretations of its original logic (modal or not, determined
by its set of axioms, inference relations and a predefined set Γ (possibly empty), for
which these interpretations are models), because such a set of interpretations is able
to express all logically possible extensions of the formulae of the original (not fully
intensional) logic. In what follows, we will provide this intensional upgrade for the
standard (not modal) FOL(Γ), but generally it can be done to every kind of logics, thus
to any kind of modal logics, and hence also to the modal logic FOL𝒦(Γ): in that case,
we obtain the two-levels of modal logic (as in [41, 42]).
At the lower level, we will have original modal logics with their original set of
possible worlds (the set 𝒟𝒱of intrinsic worlds, with a unique explicit world ℏ, in the
case of FOL𝒦(Γ)), while at the new upper level we have that each new explicit possible
world corresponds to the particular Kripke’s interpretation IK of the original modal
logics. This upper-level intensional logic has a kind of rigid semantics, where the
domains and the extensions of built-in predicates/propositions of the “lower-level”
modal logics are identical in every upper-level possible world.
A k-ary functional symbol f k
i
∈F in an intensional logic is considered as a
new k + 1-ary predicate symbol f k+1
i
∈P (with (TF) constraint in Definition 11)
whose extension is the graph of this function, such that cannot exists two tuples
(d1, . . . , dk, u1), (d1, . . . , dk, u2) in its extension with u1
̸= u2. Thus, in intensional FOL
we will have only the set of predicate symbols P while F is empty set.
This two-level intensional modal logic with the old possible worlds of the original
modal logic 𝕎= 𝒲×𝒟𝒱is enriched by a new set of explicit possible worlds IK (the set
of all Kripke interpretations IK ∈IK(Γ), of the original (nonintensional) modal logic,
in which all assumptions in Γ (possibly empty set) are true), means that the obtained
intensional modal logic has the set of explicit possible worlds equal to the cartesian
product of old worlds 𝒲and new added worlds in IK(Γ), so that new generalized

1.2 Intensionality and intensional/extensional semantics
|
31
possible worlds are equal to the set ̂
𝕎= IK(Γ)×𝕎= IK(Γ)×(𝒲×𝒟𝒱). Consequently,
the Kripke semantics of fully intensional modal logic, obtained as an enrichment of
the original modal logic, can be given by the following definition.
Definition 14 (Intensional enrichment of multimodal logics). Let ℳ= (𝕎, {ℛi}, 𝒟, IK)
be a Kripke’s model of a predicate multimodal logic with the set of possible worlds 𝕎=
𝒲× 𝒟𝒱and the set of existential modal “low-level” operators ♦i with accessibility
relations ℛi and the set of standard Kripke’s interpretations IK(Γ).
Then we define a Kripke’s interpretation of its intensional enrichment ̂
ℳ=
(̂
𝕎, {ℛi}, { ̂
ℛj}, 𝒟,̂IK), with the set of possible worlds ̂
𝕎= IK(Γ) × 𝕎, an optional set
of new intensional modal operators ̂♦j with the accessibility relations ̂
ℛj ⊆IK(Γ)2
and new mapping ̂IK : (IK(Γ) × 𝒲) × P →⋃n∈𝒩2𝒟n, such that for any explicit world
(IK, w) ∈IK(Γ) × 𝒲and pk
i ∈P we have that ̂IK(IK, w, pk
i ) =def IK(w, pk
i ) : 𝒟k →2. The
satisfaction relation 󳀀󳨐Ik,w,g for a given world (Ik, w, g) ∈̂
𝕎is defined as follows:
1.
̂
ℳ󳀀󳨐IK,w,g pk
i (x1, . . . , xk) iff ̂IK(IK, w, pk
i )(g(x1), . . . , g(xk)) = t.
2.
̂
ℳ󳀀󳨐IK,w,g φ ∧ϕ iff ̂
ℳ󳀀󳨐Ik,w,g φ and ̂
ℳ󳀀󳨐IK,w,g ϕ,
3.
̂
ℳ󳀀󳨐IK,w,g ¬φ iff not ̂
ℳ󳀀󳨐IK,w,g φ,
4.
̂
ℳ
󳀀󳨐IK,w,g
◊iφ iff exists (w′, g′)
∈
𝕎such that ((w, g), (w′, g′))
∈
ℛi and
̂
ℳ󳀀󳨐IK,w′,g′ φ.
5.
̂
ℳ󳀀󳨐IK,w,g ̂◊jφ iff exists I′
K ∈IK such that (IK, I′
K) ∈̂
ℛj and ̂
ℳ󳀀󳨐I′
K,w,g φ.
Notice that this intensional enrichment is maximal one: in fact, we have taken all
Kripke’s interpretations of the original modal logics for the possible worlds of this new
upgraded intensional logic. Moreover, from the points 4 and 5, it holds that this inten-
sional enrichment Kripke’s interpretation ̂
ℳis not a standard Kripke’s interpretation
with the “high-level” modal operators ̂♦j.
We can obtain partial intensional enrichments if we take only a strict subset of
S ⊂IK(Γ) in order to define generalized possible worlds ̂
𝕎= S × 𝕎. In that case, we
would introduce the nonmonotonic property for obtained intensional logic.
Example 2 (Intensional enrichment of the FOL). Let us consider the intensional en-
richment of the multimodal logic FOL𝒦(Γ) given by Definition 13 with the Kripke’s
interpretation ℳ= (𝕎, {ℛi | i ∈ℕ}, 𝒟, IK) of the FOL(Γ), with a set of (generalized)
possible worlds reduced only to the intrinsic worlds 𝕎= {ℏ} × 𝒟𝒱(from the fact that
𝒲is a singleton set composed by only actual world ℏ) and the accessibility relation
for each existential modal operator ∃i (corresponding in 𝒜FOL to the FOL quantifier
(∃x), x ∈𝒱), between intrinsic worlds g1, g2 ∈𝒟𝒱, ℛi = {(g1, g2) ∈𝕎2 | for all y ∈
𝒱\{x}(g1(y) = g2(y))} as was shown in Definition 13.
We denote by IK(Γ) the set of Kripke’s interpretations of this modal translation
of the FOL (bijective to the set of the Tarski’s interpretations of the FOL, as demon-
strated by Theorem 1). Then we define its intensional enrichment by a new Kripke’s

32
|
1 Theory of new intensional first-order logic
interpretation (the higher level w. r. t. the modal interpretation ℳof the FOL) ̂
ℳ=
(̂
𝕎, {ℛi}, { ̂
ℛj}, 𝒟,̂IK), with:
–
The set of generalized possible worlds ̂
𝕎= IK(Γ) × 𝕎= IK(Γ) × {ℏ} × 𝒟𝒱(here
the set of explicit worlds is 𝒲e =def IK(Γ) × {ℏ}, while the set of intrinsic worlds
remains equal to 𝒟𝒱);
–
An optional set of new modal operators ̂♦j with the accessibility relations ̂
ℛj over
the worlds in IK(Γ),
–
The new mappinĝIK : (IK(Γ)×{ℏ})×P →⋃n∈𝒩2𝒟n, such that for any explicit world
(IK, ℏ) ∈IK(Γ) × {ℏ} and pk
i ∈P we have that ̂IK(IK, ℏ, pk
i ) =def IK(ℏ, pk
i ) : 𝒟k →2.
For each world w = (IK, ℏ, g) ∈̂
𝕎, we have that
1.
̂
ℳ󳀀󳨐IK,ℏ,g pk
i (x1, . . . , xk) iff ̂IK(IK, ℏ, pk
i )(g(x1), . . . , g(xk)) = t.
2.
̂
ℳ󳀀󳨐IK,ℏ,g φ ∧ϕ iff ̂
ℳ󳀀󳨐Ik,ℏ,g φ and ̂
ℳ󳀀󳨐IK,ℏ,g ϕ,
3.
̂
ℳ󳀀󳨐IK,ℏ,g ¬φ iff not ̂
ℳ󳀀󳨐IK,ℏ,g φ,
4.
̂
ℳ󳀀󳨐IK,ℏ,g ◊iφ iff exists g′ ∈𝒟𝒱such that (g, g′) ∈ℛi and ̂
ℳ󳀀󳨐IK,ℏ,g′ φ,
5.
̂
ℳ󳀀󳨐IK,ℏ,g ̂◊jφ iff exists I′
K ∈IK(Γ) such that (IK, I′
K) ∈̂
ℛj and ̂
ℳ󳀀󳨐I′
K,ℏ,g φ.
So, from Definition 10 for the intensional semantics, the mapping In : ℒop →RIK(Γ),
where ℒop is the subset of formulae with free variables (virtual predicates), such that
for any virtual predicate ϕ(x1, . . . , xk) ∈ℒop the mapping In(ϕ(x1, . . . , xk)) : IK(Γ) →R
is Montague’s meaning (intension) of this virtual predicate, i. e., mapping, which re-
turns with the extension of this predicate in every possible world (i. e., Kripke’s inter-
pretation of FOL𝒦(Γ)), IK ∈IK(Γ). That is, we have that
In(ϕ(x1, . . . , xk))(IK) =def 󵄩󵄩󵄩󵄩ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩
= {(g(x1), . . . , g(xk)) ∈𝒟k | g ∈𝒟𝒱and ̂
ℳ󳀀󳨐IK,ℏ,g ϕ(x1, . . . , xk)}
(1.7)
In what follows, the minimal (i. e., without new intensional modal operators ̂♦i) in-
tensional enrichment of the multimodal logic FOL𝒦we will denote by FOL𝒦ℐ.
This two-level intensional modal logic, described above, has the following corre-
spondence property between the Kripke’s interpretation ℳof the original modal logic
and the Kripke’s interpretation ̂
ℳof its intensional enrichment:
Proposition 4. For any logic formulae ϕ of the original multimodal logic, with the set of
(generalized) possible worlds 𝕎= 𝒲× 𝒟𝒱and the set of existential modal operators
♦i with accessibility relations ℛi given by Definition 12, the following property holds:
̂
ℳ󳀀󳨐IK,w,g ϕ
iff
ℳ󳀀󳨐w,g ϕ
(1.8)
where ℳ= (𝕎, {ℛi}, 𝒟, IK) is Kripke’s interpretation of the original multimodal logic.
That is, this intensional extension from the “low-level” into the intensional (“high-level”)

1.3 First-order logic and intensionality
|
33
predicate modal logic is conservative one: if for a given Kripke interpretation IK of the
“low-level” the formula ϕ is satisfied in the world (w, g) than in the “high-level” world
(IK, w, g) it is satisfied as well, and vice versa.
Proof. Let us demonstrate it by structural induction on the length of logic formu-
lae. For any atom ϕ = pk
i (x1, . . . , xk), we have from Definition 14 that ̂
ℳ󳀀󳨐IK,w,g
pk
i (x1, . . . , xk) iff ̂IK(IK, w, pk
i )(g(x1), . . . , g(xk)) = IK(w, pk
i )(g(x1), . . . , g(xk)) = t iff ℳ󳀀󳨐w,g
pk
i (x1, . . . , xk). Let us suppose that such a property holds for every formula ϕ with less
than n logic connectives of the original multimodal logic (thus without new inten-
sional “high-level” existential modal operators ̂♦i), and let us show that it holds also
for any formula with n logic connectives. There are the following cases:
1.
The case when ϕ = ¬ψ where ψ has n −1 logic connectives. Then ̂
ℳ󳀀󳨐IK,w,g
ϕ iff ̂
ℳ󳀀󳨐IK,w,g ¬ψ iff not ̂
ℳ󳀀󳨐IK,w,g ψ iff (by inductive hypothesis) not ℳ󳀀󳨐w,g
ψ iff ℳ󳀀󳨐w,g ¬ψ iff ℳ󳀀󳨐w,g ϕ.
2.
The case when ϕ = ψ1 ∧ψ2, where both ψ1, ψ2 have less than n logic connectives,
is analogous to the case 1.
3.
The case when ϕ = ♦iψ where ψ has n −1 logic connectives. Then ̂
ℳ󳀀󳨐IK,w,g
ϕ iff ̂
ℳ󳀀󳨐IK,w,g ♦iψ iff exists w′ such that (w, w′) ∈ℛi and ̂
ℳ󳀀󳨐IK,w,g ψ iff (by
inductive hypothesis) exists w′ such that (w, w′) ∈ℛi and ℳ󳀀󳨐w,g ψ iff ℳ󳀀󳨐w,g
♦iψ iff ℳ󳀀󳨐w,g ϕ.
Notice that the property verified by this proposition is a direct consequence of the
definition of the new Kripke’s mapping ̂IK in Definition 14, such that the following
diagram (where Λ is the currying operator from lambda calculus used in diagram A.10
in Section A.5 in the Appendix)
CB × B
evalB,C? C
A × B
Λ(̂IK)
∪
?
idB
?
̂IK
?
where A = IK(Γ), B = 𝒲× P and C = ⋃n∈𝒩2𝒟n, so that the curried function Λ(̂IK) is an
inclusion. Consequently, for any “low-level” Kripke’s interpretation IK ∈A, we obtain
that Λ(̂IK)(IK) = IK : B →C, and hence for each (w, pk
i ) ∈B, evalB,C(IK, (w, pk
i )) =
IK(w, pk
i ), which from the commutativity of this diagram above is equal to ̂IK(IK,
(w, pk
i )).
1.3 First-order logic and intensionality
Thus, from the previous section, in order to be able to provide the intensions of logic
formulae, our modal Kripke semantics for the FOL(Γ) has to be enriched also by a

34
|
1 Theory of new intensional first-order logic
set of explicit possible worlds. In this way, e. g., in any two different explicit worlds a
given predicate can have different extensions (as required by Montague’s intensional
meaning of this predicate).
Such an intensional semantics of FOL(Γ) is strictly more expressive [36] than a sin-
gle Tarski’s semantics of FOL(Γ), as presented by Example 2 where the set of explicit
worlds is 𝒲e =def IK(Γ) × 𝒲, i. e., from the bijection between Tarski’s and Kripke’s
interpretations (see Theorem 1), ♭: IT(Γ) ≃IK(Γ), we can define 𝒲e =def IT(Γ) × 𝒲
and from fact that 𝒲= {ℏ} is a singleton set, we obtain the reduction of explicit worlds
𝒲e = IT(Γ) to the set of all Tarski’s interpretations of the FOL(Γ), which are models
of Γ. As we have seen in Section 1.2, the intensional semantics of FOL(Γ) with a set
of logic formulae ℒ(and with the bijection between Tarski’s homomorphisms 𝒲e =
IT(Γ) and the set of extensionalization functions of intensional logic, the bijection
ℱ: 𝒲e ≃ℰ) is given by the composed mapping ℒ󳨀→I 𝒟󳨐⇒h∈ℰR in Definition 10,
where (for a fixed intensional interpretation I) for each extensionalization function
h ∈ℰwe obtain a Tarski’s interpretation IT with the mapping I∗
T = h ∘I : ℒ→R.
In fact, with a given standard Tarski’s interpretation IT of FOL(Γ) we are not able to
express the intensional equality of two open formulae with the same tuple of free vari-
ables, ϕ(x1, . . . xn), ψ(x1, . . . xn), defined by (∀h)(h(I(ϕ(x1, . . . xn))) = h(I(ψ(x1, . . . xn)))).
So, as presented in Example 4 at the end of this section, if we introduce the intensional
equality, then it reduces the set of Tarski’s interpretations of the FOL that cannot con-
sider such intensional constraints. Consequently, the bijection ♭: IT(Γ) ≃IK(Γ) in
Theorem 1 is not more valid, because it was derived for the pure embedding of stan-
dard (extensional) FOL into minimal intensional FOL (without added intensional fea-
tures). So, we need a new definition of possible worlds 𝒲e valid also for intensional
extension of the FOL, for a given fixed intensional interpretation I:
𝒲e =def {I∗
T = h ∘I : ℒ→R | h : im(I) →R ∈ℰ} ⊆IT(Γ)
(1.9)
So, 𝒲e = IT(Γ) only for minimal intensional FOL used only for embedding of standard
(extensional) FOL, but not for proper extensions of intensional features.
Let us define this minimal intensional first-order logic FOLℐ(Γ), which has the
same syntax as standard FOL (hence without other “high-level” modal logic connec-
tives ̂♦i), by elimination of the singleton set 𝒲= {ℏ} in Definition 14 and Example 2,
when (1.9) reduces to 𝒲e = IT(Γ):
Definition 15 (Minimal intensional first-order logic (FOLℐ(Γ))). Let ℳ
=
(𝕎, {ℛi},
𝒟, IK) be Kripke’s model of a predicate multimodal logic, obtained from FOL(Γ) with a
set of its Tarski’s interpretations IT(Γ), which are models of Γ, with the set of possible
worlds 𝕎= 𝒟𝒱and the set of existential modal “low-level” operators ♦i for each
existential modal operator ∃i in 𝒜FOL (corresponding to FOL quantifier (∃x), x ∈𝒱)
with the accessibility relation ℛi = {(g1, g2) ∈(𝒟𝒱)2| for all y ∈𝒱\{x}(g1(y) = g2(y))} as
was shown in Definition 13.

1.3 First-order logic and intensionality
|
35
The mapping IK : P →⋃n∈𝒩2𝒟n is a standard Kripke’s interpretation such
that, for a given Tarski’s interpretation I∗
T ∈IT(Γ) of FOL(Γ) and a predicate pk
i ∈P,
IK(pk
i )(d1, . . . , dk) = I∗
T (pk
i (d1, . . . , dk)), i. e., from Theorem 1, IK = ♭(I∗
T ).
Then we define the Kripke’s interpretation of the intensional logic FOLℐ(Γ) by
ℳFOLℐ(Γ) = ̂
ℳ=def (̂
𝕎, {ℛi}, 𝒟,̂IK) with a set of (generalized) possible worlds ̂
𝕎=
IT(Γ)×𝒟𝒱, where 𝒲e = IT(Γ) is the set of explicit possible worlds(theset of Tarski’s in-
terpretation of FOL(Γ)), nonempty domain 𝒟, and themappinĝIK : 𝒲e×P →⋃n∈𝒩2𝒟n
such that for each I∗
T ∈𝒲e and pk
i ∈P, ̂IK(I∗
T , pk
i )(d1, . . . , dk) = IK(pk
i )(d1, . . . , dk) where
IK = ♭(I∗
T ).
For each world w = (IK, g) ∈̂
𝕎, we have that:
1.
̂
ℳ󳀀󳨐IK,g pk
i (x1, . . . , xk) iff ̂IK(IT, pk
i )(g(x1), . . . , g(xk)) = t.
2.
̂
ℳ󳀀󳨐IK,g φ ∧ϕ iff ̂
ℳ󳀀󳨐Ik,g φ and ̂
ℳ󳀀󳨐IK,g ϕ,
3.
̂
ℳ󳀀󳨐IK,g ¬φ iff not ̂
ℳ󳀀󳨐IK,g φ,
4.
̂
ℳ󳀀󳨐IK,g ◊iφ iff exists g′ ∈𝒟𝒱such that (g, g′) ∈ℛi and ̂
ℳ󳀀󳨐IK,g′ φ.
Notice that the intensional semantics above is given for the ordinary syntax of
the first-order logic with the existential quantifier ∃only, without other “high-level”
modal logic connectives ̂♦i, thus with the empty set of accessibility binary relations
over the set of explicit possible worlds 𝒲e = π1(̂
𝕎) = IT(Γ): this is the reason to
denominate it by “minimal.”
Let us show that this unique intensional Kripke model ℳFOLℐ(Γ) = (̂
𝕎, {ℛi}, 𝒟,̂IK)
models the Tarskian logical consequence of the first-order logic with a set of assump-
tions in Γ, so that the added intensionality preserves the Tarskian semantics of the
FOL.
Proposition 5 (Montague’s intension and Tarski’s interpretations). Let ℳFOLℐ(Γ)
=
(̂
𝕎, {ℛi}, 𝒟,̂IK) be the unique intensional Kripke model of the first-order logic with a
set of assumptions in Γ, as specified in Definition 15.
So, a formula ϕ is a logical consequence of Γ in the Tarskian semantics for the FOL,
i. e., Γ ⊩ϕ, iff ϕ is true in this Kripke intensional model ℳFOLℐ(Γ), i. e., iff ‖ϕ‖ = ̂
𝕎=
𝒲e × 𝒟𝒱with the set of Tarski’s interpretations, which are models of Γ (explicit worlds)
𝒲e = IT(Γ).
If In : ℒop →R𝒲e is the mapping given in Definition 10, then for any (virtual)
predicate ϕ(x1, . . . , xk), the mapping In(ϕ(x1, . . . , xk)) : 𝒲e →R represents Montague’s
meaning (intension) of this logic formula, such that for any Tarski’s interpretation (an
explicit possible world) I∗
T = w ∈𝒲e = π1(𝕎),
In(ϕ(x1, . . . , xk))(w) = w(ϕ(x1, . . . , xk)) = I∗
T (ϕ(x1, . . . , xk))
(1.10)
Proof. Let us show that for any first-order formula ϕ, it holds that ℳFOLℐ(Γ) 󳀀󳨐w,g
ϕ iff w(ϕ/g) = t, where w is the Tarski’s interpretation w = I∗
T ∈𝒲e = IT(Γ). Let us

36
|
1 Theory of new intensional first-order logic
demonstrate it by the structural induction on the length of logic formulae. For any
atom ϕ = pk
i (x1, . . . , xk), we have from Definition 15 that
ℳFOLℐ(Γ) 󳀀󳨐I∗
T ,g pk
i (x1, . . . , xk)
iff
IK(I∗
T , pk
i )(g(x1), . . . , g(xk)) = t
iff
I∗
T (pk
i (x1, . . . , xk)/g) = t.
Let us suppose that such a property holds for every formula ϕ with less than n logic
connectives of the FOL, and let us show that it holds also for any formula with n logic
connectives. There are the following cases:
1.
The case when ϕ = ¬ψ where ψ has n −1 logic connectives. Then ℳFOLℐ(Γ) 󳀀󳨐I∗
T ,g
ϕ iff ℳFOLℐ(Γ) 󳀀󳨐I∗
T ,g ¬ψ iff not ℳFOLℐ(Γ) 󳀀󳨐I∗
T ,g ψ iff (by inductive hypothesis) not
I∗
T (ψ/g) = t iff I∗
T (¬ψ/g) = t iff I∗
T (ϕ/g) = t.
2.
The case when ϕ = ψ1 ∧ψ2, where both ψ1, ψ2 have less than n logic connectives,
is analogous to the case 1.
3.
The case when ϕ = (∃x)ψ where ψ has n −1 logic connectives. It is enough
to consider the case when x is a free variable in ψ. Then ℳFOLℐ(Γ) 󳀀󳨐I∗
T ,g ϕ iff
ℳFOLℐ(Γ) 󳀀󳨐I∗
T ,g (∃x)ψ iff exists u ∈𝒟such that ℳFOLℐ(Γ) 󳀀󳨐I∗
T ,g ψ[x/u] iff (by
inductive hypothesis) exists u ∈𝒟such that I∗
T (ψ[x/u]/g) = t iff I∗
T ((∃x)ψ/g) = t
iff I∗
T ((ϕ/g)) = t.
It is easy to verify that the intension of predicates in the FOLℐ(Γ) defined above
can be expressed by the mapping In such that for any pk
i ∈P and w = I∗
T ∈𝒲e,
In(pk
i (x1, . . . , xk))(w) = w(pk
i (x1, . . . , xk)) = IT(pk
i (x1, . . . , xk)) and, more general, for any
virtual predicate ϕ(x1, . . . , xk),
In(ϕ(x1, . . . , xk))(w)
= 󵄩󵄩󵄩󵄩ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩
= {(g(x1), . . . , g(xk)) ∈𝒟k | g ∈𝒟𝒱and ℳFOLℐ󳀀󳨐w,g ϕ(x1, . . . , xk)}
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and w(ϕ(x1, . . . , xk)/g) = t}
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and (g(x1), . . . , g(xk)) ∈w(ϕ(x1, . . . , xk))}
= w(ϕ(x1, . . . , xk)) = I∗
T (ϕ(x1, . . . , xk)),
where w is the Tarski’s interpretation w = I∗
T ∈𝒲e = IT(Γ). Consequently, In(ϕ(x1, . . . ,
xk)) : 𝒲→R is t Montague’s meaning (i. e., the intension) of the (virtual) predicate
ϕ(x1, . . . , xk).
Note that the this result in equation (1.10), valid also for general case (1.9) of non-
minimal intensional FOLs, is analogous to the previous result in equation (1.7). It is
clear that in Kripke semantics of this intensional first-order logic, denoted by FOLℐ(Γ),
if the set of assumptions is empty (Γ = 0), then a formula ϕ is true in the intensional

1.3 First-order logic and intensionality
|
37
Kripke model ℳFOLℐ(Γ) iff it is valid in Tarskian semantics of the FOL, ie., iff ⊩ϕ in the
FOL.
The main difference between Tarskian semantics and this intensional semantics
is that this unique intensional Kripke model ℳFOLℐ(Γ) encapsulates the set of all Tarski
models of the first-order logic with a (possibly empty) set of assumptions Γ.
Corollary 2. The intensionalities of two different minimal intensional enrichments of the
first-order syntax, given by intensional logics FOLℐ(Γ) (in Definition 15) and FOL𝒦ℐ(Γ)
(in Example 2), are equivalent and correspond to Montague’s intensionality.
Proof. Let us denote by IFOLℐ(Γ)
n
, I
FOL𝒦ℐ(Γ)
n
: ℒop →R𝒲the intensional mappings
(from Definition 10 of the intensional semantics) for these two intensional enrich-
ments of the FOL(Γ). Notice that the set of explicit possible worlds 𝒲in FOLℐ(Γ) is
equal to IT(Γ) while in FOL𝒦ℐ(Γ) is equal to IK(Γ), with the bijection (from Theorem 1)
♭: IT(Γ) ≃IK(Γ). We have to show that for any formulae ϕ(x1, . . . , xn) ∈ℒop its exten-
sion, in a given explicit world IT ∈IT(Γ) of the intensional logic FOLℐ(Γ), is equal to
its extension in the correspondent explicit world IK = ♭(I∗
T ) ∈IK(Γ) of the intensional
logic FOL𝒦ℐ(Γ). In fact, we have that
IFOLℐ(Γ)
n
(ϕ(x1, . . . , xk))(IT)
= {(g(x1), . . . , g(xk)) ∈𝒟k | g ∈𝒟𝒱and ℳFOLℐ(Γ) 󳀀󳨐IT,g ϕ(x1, . . . , xk)}
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and I∗
T (ϕ(x1, . . . , xk)/g) = t}
(from Proposition 5)
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and ℳ󳀀󳨐g ϕ(x1, . . . , xk)}
(from Proposition 3 and Theorem 1 where ℳis the Kripke interpretation of
FOL𝒦(Γ) with IK = ♭(I∗
T ))
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and ̂
ℳFOL𝒦(Γ) 󳀀󳨐IK,g ϕ(x1, . . . , xk)}
(from Proposition 4)
= I
FOL𝒦ℐ(Γ)
n
(ϕ(x1, . . . , xk))(IK).
Remark. Consequently, independently on how we interpret the quantifiers of the FOL,
as in standard FOL or as modal operators in FOL𝒦, the intensionality of the FOL is
obtained only by one adequate semantic enrichment, without modifying its syntax.
Consequently, we have demonstrated that an intensional FOL does not need the other
logic operators as required by Bealer [12], i. e., we do not need an intensional abstrac-
tion operator or another modal operator. Because of that, such an intensional FOL is
denominated as the minimal intensional logic.
Another IFOL without the intensional abstraction is given in the following exam-
ple.

38
|
1 Theory of new intensional first-order logic
Example 3 (Enrichment of minimal intensional FOL by “high-level” modal operators).
In order to be able to recognize the intensional equivalence (different from intensional
identity) between (virtual) predicates, that may be used in intensional mapping be-
tween P2P databases [42–44], we need to extend this minimal intensional FOL also
syntactically, by introducing the new modal existential operator ̂♦(as the “high-level”
modal operators with the semantics introduced in point 5 of Definition 14 and Exam-
ple 2), so that ϕ(x1, . . . xn) and ψ(x1, . . . xn) are intensionally equivalent iff the modal
first-order formula ̂♦ϕ(x1, . . . xn) ≡̂♦ψ(x1, . . . xn) is true in this modal FOL.
The Kripke semantics for this extended modal first-order logic is a S5 modal FOL
with the accessibility relation ̂
ℛ= 𝒲e × 𝒲e.
Two intensional equivalent predicates does need to have equal extensions in each
explicit possible world as it is required by intensional equality (equal meaning from
Montague’s point of view) when ϕ(x1, . . . xn) ≡ψ(x1, . . . xn) is true, where “≡” is the
standard logic equivalence connective.
Notice that if they are intensionally equal, it does not mean that they are equal
concepts, i. e., that I(ϕ(x1, . . . xn)) = I(ϕ(x1, . . . xn)) ∈𝒟, but only that they are neces-
sarily equivalent. In fact, the two atoms p1
1(x), “x has been bought,” and p1
2(x), “x has
been sold,” are necessarily equivalent, i. e., it holds that p1
1(x) ≡p1
2(x) but they are two
different concepts, i. e., I(p1
1(x))
̸= I(p1
2(x)).
Remark. Such an distinction of equal concepts and of the intensional equality (i. e.,
the necessary equivalence) is not possible in Montague’s semantics, and explains why
we adopted the PRP theory and two-step intensional semantics in Definition 10 anal-
ogously to Bealer’s approach.
That is, if we denote by ‘≈’ this new intensional equivalence and by ‘≡’ the inten-
sional equality, we can show the following intensional logic property.
Corollary 3. Any two first-order open formulae, ϕ(x1, . . . xn) and ψ(x1, . . . xn), are inten-
sionally equivalent iff ̂♦ϕ(x1, . . . xn) and ̂♦ψ(x1, . . . xn) are intensionally equal, i. e.,
ϕ(x1, . . . xn) ≈ψ(x1, . . . xn)
iff
̂♦ϕ(x1, . . . xn) ≡̂♦ψ(x1, . . . xn)
(1.11)
Proof. We have that for any explicit possible world (Tarski’s homomorphism) w′ =
I∗′
T ∈𝒲e in (1.9):
In(̂♦ϕ(x1, . . . , xk))(w′)
= {(g(x1), . . . , g(xk)) ∈𝒟k | g ∈𝒟𝒱and ℳ󳀀󳨐w′,g ̂♦ϕ(x1, . . . , xk)}
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and exists w = I∗
T ∈𝒲e
such that (w′, w) ∈̂
ℛ= 𝒲e × 𝒲e and ℳ󳀀󳨐w,g ϕ(x1, . . . , xk)}
= {(g(x1), . . . , g(xk)) | g ∈𝒟𝒱and exists w = I∗
T ∈𝒲e
such that ℳ󳀀󳨐w,g ϕ(x1, . . . , xk)}

1.3 First-order logic and intensionality
|
39
=
⋃
w=IT∈𝒲e
In(ϕ(x1, . . . , xk))(w)
= ⋃
w∈𝒲
w(ϕ(x1, . . . , xk))
= ⋃
IT∈𝒲
I∗
T (ϕ(x1, . . . , xk)).
That is, the intension of ̂♦ϕ(x1, . . . xn) is a constant function (which does not depend
on the explicit possible world w ∈𝒲e).
Thus, ϕ(x1, . . . xn) and ψ(x1, . . . xn) are intensionally equivalent if
⋃
w∈𝒲e
In(ϕ(x1, . . . , xk))(w)
=
⋃
w∈𝒲e
In(ψ(x1, . . . , xk))(w), i. e.,
if In(♦ϕ(x1, . . . , xk))(w) = In(♦ϕ(x1, . . . , xk))(w) for every world w ∈𝒲, i. e.,
if ̂♦ϕ(x1, . . . xn) and ̂♦ψ(x1, . . . xn) are intensionally equal.
Another extension of this minimal intensional FOL is of course the intensional
FOL defined by Bealer in [12], if we use the bijective mapping ℱ: 𝒲e →ℰfrom (1.9) as
the Montague–Bealer’s isomorphism (bijection) between explicit possible worlds and
the set of extensionalization functions. Notice that both versions of intensional FOL
are modal logics, and hence we can define two different logic inferences for them: the
local inference relation ‘⊢w’ and the global inference relation ‘⊢’, is as follows:
1.
For a given set of logic formulae Γ, we tell that they locally infer the formula ϕ
in a possible world w ∈𝒲e, i. e., Γ ⊢w ϕ iff (∀models ℳ)(∀g)((∀ψ ∈Γ).ℳ󳀀󳨐w,g
ψ implies ℳ󳀀󳨐w,g ϕ).
2.
For a given set of logic formulae Γ, we tell that they globally infer the formula ϕ,
i. e., Γ ⊢ϕ iff (∀models ℳ)(∀g)(∀w ∈𝒲e)((∀ψ ∈Γ).ℳ󳀀󳨐w,g ψ implies ℳ󳀀󳨐w,g ϕ).
The intensional first-order logic FOLℐ(Γ) in Definition 15 has one unique Kripke model
ℳ= ℳFOLℐ(Γ). Thus, we obtain that in this modal intensional logic FOLℐ(Γ):
1.
Γ ⊢w ϕ iff ϕ is true in the Kripke model ℳFOLℐ(Γ) in a given possible world w ∈
IT(Γ), i. e., if ϕ is true in the Tarski’s model I∗
T = w of Γ. Thus, this local inference
⊢w corresponds to the derivation of true formulae in a given Tarski model I∗
T = w
of Γ.
2.
Γ ⊢ϕ iff ϕ is true in the Kripke model ℳFOLℐ(Γ), i. e., iff Γ ⊩ϕ, so that the global
inference ⊢corresponds to the Tarskian logical consequence ⊩in the standard
first-order logic.
In the rest of this section, we will consider the full homomorphic (algebraic) exten-
sions of intensional semantics defined in Definition 10.

40
|
1 Theory of new intensional first-order logic
The first step is to define the intensional algebra 𝒜int of concepts, analogous to
concept languages as, e. g., in the case of the Description Logic (DL).
Concept languages steam from semantic networks [45–47], which for a large group
of graphical languages used in the 1970s to represent and reason with conceptual
knowledge. But they did not have a rigorously defined statement as emphasized by
Brachman and Levesque [48, 49]. After that, different versions of DL [50] with formal
semantics appeared, as a family of knowledge representation formalisms that repre-
sent the knowledge of an application domain by first defining the relevant concepts
and roles as a terminology (TBox) and then the assertions (ABox) about named indi-
viduals in terms of this terminology. The concepts denote sets of individuals, and roles
denote binary relationships between individuals.
In our approach, we will use not only binary, but also general k-ary relationships
between individuals, in order to manage not only unary (as in DL) but all k-ary con-
cepts. This approach is similar to Bealer’s intensional algebra, with the difference
that our algebra is not an extension of intensional Boolean algebra as in the Bealer’s
work, where the intensional conjunction is extensionally interpreted by set intersec-
tion (here, instead, it is interpreted by the natural join operations, defined in the FOL
extensional algebra 𝒜R in Corollary 1).
So, we will define only the minimal intensional algebra (with a minimal number
of operators) able to support the homomorphic extension of the intensional mapping
I : ℒ→𝒟.
Definition 16 (Basic intensional FOL algebra). Intensional FOL algebra is a structure
𝒜int = (𝒟, Id, Truth, {conjS}S∈𝒫(ℕ2), neg, {existsn}n∈ℕ),
with binary operations conjS : DI ×DI →DI, unary operation neg : DI →DI and unary
operations existsn : DI →DI, such that for any extensionalization function h ∈ℰ, and
u ∈Dk, v ∈Dj, k, j ≥0,
1.
h(Id) = R= and h(Truth) = {⟨⟩}, for Id = I(≐(x, y)) and Truth = I(⊤).
2.
h(conjS(u, v)) = h(u) ⋈S h(v), where ⋈S is the natural join operation defined in
Definition 9 and conjS(u, v) ∈Dm where m = k + j −|S| if for every pair (i1, i2) ∈S it
holds that 1 ≤i1 ≤k, 1 ≤i2 ≤j (otherwise conjS(u, v) ∈Dk+j).
3.
h(neg(u)) =∼(h(u)) = 𝒟k\(h(u)), if k ≥1, where ∼is the operation defined in
Definition 9 and neg(u) ∈Dk. For u0 ∈𝒟0, h(neg(u0)) =∼(h(u0)) = 𝒟0\(h(u0)).
4.
h(existsn(u)) = π−n(h(u)), where π−n is the operation defined in Definition 9 and
existsn(u) ∈Dk−1 if 1 ≤n ≤k (otherwise existsn is the identity function).
Notice that for u, v ∈D0, so that h(u), h(v) ∈{f, t},
h(neg(u)) =∼(h(u)) = 𝒟0\(h(u)) = {⟨⟩}\(h(u)) ∈{f, t},
and
h(conj0(u, v)) = h(u) ⋈0 h(v) ∈{f , t}.

1.3 First-order logic and intensionality
|
41
We define a derived operation union : (𝒫(Di)\0) →Di, i ≥0, such that, for any B =
{u1, . . . , un} ∈𝒫(Di) and S = {(l, l) | 1 ≤l ≤i} we have that
union({u1, . . . , un})
=def { u1,
if n = 1
neg(conjS(neg(u1), conjS(neg(u2), . . . , neg(un)) . . .),
otherwise
(1.12)
Then we obtain that for n ≥2:
h(union(B)) = h(neg(conjS(neg(u1), conjS(neg(u2), . . . , neg(un)) . . .)
= 𝒟i\((𝒟i\h(u1)) ⋈S ⋅⋅⋅⋈S (𝒟i\h(un)))
= 𝒟i\((𝒟i\h(u1)) ⋂⋅⋅⋅⋂(𝒟i\h(un)))
= ⋃{h(uj) | 1 ≤j ≤n},
i. e.,
h(union(B)) = ⋃{h(u) | u ∈B}
(1.13)
Note that it is valid also for the propositions in u1, u2 ∈D0, so that h(union(u1, u2)) =
h(u1) ⋃h(n2) ∈{f, t} where f is empty set 0 while t is a singleton set {⟨⟩} with empty
tuple ⟨⟩, and hence the join {⟨⟩} ⋈0 = 0 and {⟨⟩} ⋈{⟨⟩} = {⟨⟩}.
We define the following homomorphic extension of the intensional interpretation
I : ℒ→𝒟for the formulae in syntax algebra 𝒜FOL from Corollary 1:
1.
The logic formula ϕ(xi, xj, xk, xl, xm) ∧S ψ(xl, yi, xj, yj) will be intensionally inter-
preted by the concept u1 ∈D7, obtained by the algebraic expression conjS(u, v)
where u = I(ϕ(xi, xj, xk, xl, xm)) ∈D5, v = I(ψ(xl, yi, xj, yj)) ∈D4 are the con-
cepts of the virtual predicates ϕ, ψ, relatively, and S
= {(4, 1), (2, 3)}. Conse-
quently, we have that for any two formulae ϕ, ψ ∈ℒand a particular operator
conjS uniquely determined by tuples of free variables in these two formulae,
I(ϕ ∧S ψ) = conjS(I(ϕ), I(ψ)).
2.
The logic formula ¬ϕ(xi, xj, xk, xl, xm) will be intensionally interpreted by the con-
cept u1 ∈D5, obtained by the algebraic expression neg(u) where u = I(ϕ(xi, xj, xk,
xl, xm)) ∈D5 is the concept of the virtual predicate ϕ. Consequently, we have that
for any formula ϕ ∈ℒ, I(¬ϕ) = neg(I(ϕ)).
3.
The logic formula (∃3)ϕ(xi, xj, xk, xl, xm) will be intensionally interpreted by the
concept u1 ∈D4, obtained by the algebraic expression exists3(u) where u =
I(ϕ(xi, xj, xk, xl, xm)) ∈D5 is the concept of the virtual predicate ϕ. Consequently,
we have that for any formula ϕ ∈ℒand a particular operator existsn uniquely
determined by the position of the existentially quantified variable in the tuple of
free variables in ϕ (otherwise n = 0 if this quantified variable is not a free variable
in ϕ), I((∃n)ϕ) = existsn(I(ϕ)).

42
|
1 Theory of new intensional first-order logic
Corollary 4 (Intensional/extensional FOL semantics). For any of Tarski’s interpreta-
tion IT of the minimal intensional FOL in Definition 15, the following diagram of homo-
morphisms commutes [18]:
𝒜int(concepts/meaning)
Frege/Russell
semantics
𝒜FOL (syntax)
I∗
T (Tarski’s homomorphism)
?
intensional interpret. I
?
h (extensionalization)
?
𝒜R (denotation)
(1.14)
where h = ℱ(w) is part of a two-step intensional semantics in Definition 10, where w =
I∗
T ∈𝒲e = IT(Γ) is the explicit possible world of the Kripke frame in Definition 15.
Proof. The homomorphism of intensional mapping I is defined by the intensional in-
terpretation above. Let us also show that the isomorphism (bijective mapping) ℱ:
𝒲e ≃ℰbetween Tarski’s homomorphism I∗
T ∈𝒲e and the extensionalization map-
pings h ∈ℰis uniquely determined in order to make the above diagram homomorphic
and commutative. It can be done by inductive structural recursion on the length of
FOL formulae in ℒ: for any atom pk
i (x1, . . . , xk) ∈ℒ, we define ℱ: I∗
T 󳨃→h by the
requirement that h(I(pk
i (x1, . . . , xk))) = IT(pk
i ). Let us suppose that for any formula ϕ
with n logic connectives it holds that the mapping ℱ: I∗
T 󳨃→h satisfies requirement
that h(I(ϕ)) = I∗
T (ϕ). Let us show that it holds also for any logic formula ϕ with n + 1
logic connectives. It is enough to show it in the case when φ = ϕ ∧S ψ (the other two
cases are analogous):
h(I(φ)) = h(I(ϕ ∧S ψ)) = h(conjS(I(ϕ), I(ψ)))
(from the homomorphism of I)
=def h(I(ϕ)) ⋈S h(I(ψ))
(from Definition 16)
= I∗
T (ϕ) ⋈S I∗
T (ψ)
(by inductive hypothesis)
= I∗
T (φ),
from the fact that the same conjunctive formula φ is mapped by I into conjS1 and by
I∗
T into ⋈S2 where S1 = S2.
This homomorphic diagram formally express the fusion of Frege’s and Russell’s
semantics [25, 51, 52] of meaning and denotation of the FOL language, and renders
mathematically correct the definition of what we call an “intuitive notion of intension-
ality,” in terms of which a language is intensional if denotation is distinguished from
sense: that is, if both a denotation and sense is ascribed to its expressions. This no-
tion is simply adopted from Frege’s contribution (without its infinite sense-hierarchy,
avoided by Russell’s approach where there is only one meaning relation, one fun-
damental relation between words and things, here represented by one fixed inten-

1.3 First-order logic and intensionality
|
43
sional interpretation I), where the sense contains a mode of presentation (here de-
scribed algebraically as an algebra of concepts (intensions) 𝒜int), and where sense
determines denotation for any given extensionalization function h (correspondent to
a given Traski’s interpretation I∗
T ).
More about the relationships between Frege’s and Russell’s theories of meaning
may be found in the Chapter 7, “Extensionality and meaning,” in [12]. As noted by Gott-
lob Frege and Rudolf Carnap (he uses terms intension/extension in the place of Frege’s
terms sense/denotation [31]), the two logic formulae with the same denotation (i. e.,
the same extension for a given Tarski’s interpretation IT) need not have the same sense
(intension), thus such codenotational expressions are not substitutable in general.
In fact, there is exactly one sense (meaning) of a given logic formula in ℒ, defined
by the uniquely fixed intensional interpretation I, and a set of possible denotations
(extensions) each determined by a given Tarski’s interpretation of the FOL as follows
from Definition 10:
ℒ󳨀→I 𝒟󳨐⇒h∈ℰR
(1.15)
Often “intension” has been used exclusively in connection with possible worlds se-
mantics, however, here we use (as in many others as Bealer, for example) “intension”
in a more wide sense, i. e., as an algebraic expression in the intensional algebra of
meanings (concepts) 𝒜int, which represents the structural composition of more com-
plex concepts (meanings) from the given set of atomic meanings. Consequently, not
only the denotation (extension) is compositional, but also the meaning (intension) is
compositional.
Notice that this compositional property holds also for the generation of subcon-
cepts: e. g., given a virtual predicate ϕ(x1, . . . xn) with correspondent concept I(ϕ) ∈Dn,
its subconcept is defined by I(ϕ[xi/c]) = I(ϕ(x1, . . . , xi−1, [xi/c], xi+1, . . . , xn)) ∈Dn−1,
where the i-th free variable of the original virtual predicate is substituted by a lan-
guage constant c. The following compositional relationship exists between extensions
of concepts and their subconcepts.
Proposition 6. For any extensionalization function h and a virtual predicate ϕ with a
tuple of free variables (x1, . . . , xi−1, xi, xi+1, . . . , xn), n ≥i ≥1, it holds that
h(I(ϕ[xi/c])) = { π−i({(u1, . . . , ui−1, ui, ui+1, . . . , un) ∈h(I(ϕ)) | ui = I(c)}),
if n ≥2
f⟨⟩({(u) ∈h(I(ϕ)) | u = I(c)}),
if i = n = 1
(1.16)
where the function f⟨⟩: R →R is that introduced in (1.3). For the sentences, we have
that for any virtual predicate ϕ(x1, . . . , xn) and an assignment g,
h(I(ϕ/g)) = t
iff
(g(x1), . . . , g(xn)) ∈h(I(ϕ)).

44
|
1 Theory of new intensional first-order logic
Proof. The proof is directly from the homomorphic diagram of Frege/Russell’s inten-
sional semantics in Corollary 4. Let us consider the first case when n ≥2, then
h(I(ϕ[xi/c]))
= I∗
T (ϕ[xi/c])
= {(g(x1), . . . , g(xi−1), g(xi+1), . . . , g(xn))
∈Dn−1 | g ∈𝒟𝒱and I∗
T (ϕ(g(x1), . . . , g(xi−1), I(c), g(xi+1), . . . , g(xn))) = t}
= π−i({(g(x1), . . . , g(xi−1), g(xi), g(xi+1), . . . , g(xn)) ∈Dn−1 | g ∈𝒟𝒱and I∗
T (ϕ/g) = t
and g(xi) = I(c)})
= π−i({(g(x1), . . . , g(xi−1), g(xi), g(xi+1), . . . , g(xn)) ∈I∗
T (ϕ) | g ∈𝒟𝒱and g(xi) = I(c)})
= π−i({(u1, . . . , ui−1, ui, ui+1, . . . , un) ∈I∗
T (ϕ) | ui = I(c)})
= π−i({(u1, . . . , ui−1, ui, ui+1, . . . , un) ∈h(I(ϕ)) | ui = I(c)}).
The other cases are similar.
From this proposition, it is clear that we are aware of the importance of the homo-
morphic extensions of the two-step intensional semantics in Definition 10. Without
this homomorphic commutativity with the Tarski’s interpretations, given by Corol-
lary 4, we will not be able to specify the interdependence of extensions of correlated
concepts in 𝒟. Thus, the homomorphic extension of Frege/Russell’s intensional se-
mantics is not only a meaningful theoretical contribution but also a necessary issue
to be able to define the correct intensional semantics for the FOL.
The commutative homomorphic diagram in (1.14) Corollary 4 explains in which
way the Tarskian semantics neglects meaning, as if truth in language where au-
tonomous. This diagram shows that such a Tarskian approach, quite useful in logic,
is very approximate. In fact, the Tarskian fact “ϕ is a true sentence” (horizontal arrow
in the diagram above with I∗
T (ϕ) = t), is equivalent to “ϕ expresses a true proposition”
(where the proposition is an intensional entity equal to I(ϕ), and its truth is obtained
by extensionalization mapping h(I(ϕ)) = t = {⟨⟩}, i. e., the set with unique empty
tuple ⟨⟩). That is, the diagram (1.14) considers also the theory of truth as a particular
case of the theory of meaning, where we are dealing with propositions in D0 ⊂𝒟.
Remark. Notice that the commutative diagram (1.14) in Corollary 4 between the al-
gebras (so that mappings are the homomorphisms) is not valid for the enrichment of
minimal intensional FOL by “high-level” modal operators ̂♦: 𝒜FOL →𝒜FOL presented
in Example 3. In fact, for this S5 modal logic with its accessibility relation ̂
ℛ= 𝒲e×𝒲e,
we have that for a given Tarski’s homomorphism I∗
T = w ∈𝒲e,
I∗
T (̂♦ϕ(x)) =def
⋃
w′∈𝒲e
w′(ϕ(x))
̸= ̂α(I∗
T (ϕ(x)))
(1.17)

1.3 First-order logic and intensionality
|
45
for each unary relational operator ̂α : R →R, from the fact that ̂α is a function such
that for a given relation R ∈R gives a result that depends only on this value R and
not on the union of another relations w′(ϕ(x)) ∈R. Consequently, we do not have a
homomorphic property between algebras 𝒜FOL and 𝒜R in the diagram above for the
“high-level” modal operators ̂♦.
Thus, the homomorphic diagram is valid for the minimal intensional FOL (just the
strict embedding of the extensional FOL into this more powerful IFOL), and also in the
case when the intensional algebra 𝒜int has a minimal requirement (structure) to ob-
tain the homomorphism of the intensional interpretation I : 𝒜FOL →𝒜int. So, in such
a minimal IFOL, it seems that intensionality of logic is completely representable by the
extensionality represented by Tarski’s homomorphism I∗
T : 𝒜FOL →𝒜R into the pure
extensional algebra 𝒜R. But as we have shown by the remark above, by introducing
“high-level” modal operators (which in the next section will be used to specify inten-
sional equivalence relationship), or by the introduction of the intensional abstraction
operator (in the next section), or by incrementing the expressive power of the inten-
sional algebra 𝒜int as follows.
Example 4 (Intensional equality). Let us consider now the intensional algebra 𝒜int in
Definition 16 enriched by the possibility to write the equations between intensional
terms (expressions of this algebra) of the same type, i. e., the equations u1 = u2 such
that u1, u2 ∈Dk ⊂𝒟for any finite k ≥−1. This intensional algebraic identity is different
from the binary identity predicate ≐introduced in Definition 1 in Section 1.1.1, and
this difference can be shown by considering a ground logic atom ≐(c1, c2) for two
given constants (nullary functions), c1 and c2, such that its intensional interpretation
is given by
I(≐(c1, c2)) =def equal(u1, u2) ∈D0
where ui = I(ci) ∈D−1, i = 1, 2
(1.18)
such that denotation of this intensional term for every extensionalization function h,
for any two u1, u2 ∈Dk, k ≥−1, is defined by
h(equal(u1, u2)) = t
iff
h(u1) = h(u2)
(1.19)
Take the case when u1 ∈D−1 is the intensional term “Morning Star” and u2 ∈D−1 is the
intensional term “Evening Star.”
Let “Morning Star” and “Evening Star” be two constants (nullary function sym-
bols) of FOL, so that both Tarski’s interpretation IT and intensional interpretations are
identities for them. However, while for standard FOL IT(“Evening Star”) = “Evening
Star” is a (simple) value in a domain 𝒟, for IFOL instead u = I(“Evening Star”) =
Evening Star ∈D1 ⊂𝒟is an intensional particular (name), for which the exten-
sion (denotation) is determined by the extensionalization function h, e. g., h(u) =
h(I(“Evening Star”)) = h(Evening Star) = “Venus.” Let us now specify an intensional

46
|
1 Theory of new intensional first-order logic
equation in the intensional algebra 𝒜int. Take the case when u1 ∈D−1 is the inten-
sional term u1 = I(“Morning Star”) = Morning Star and u2 ∈D−1 is the intensional
term Evening Star, and we define the equality (equation (1)) between these two in-
tensional terms of equal intensional type (in D−1) in 𝒜int:
(Eq. (1))
u1 = u2
(1.20)
Let us now define a ground logic atom of the FOL bynary identity predicate ≐, ≐(“Morn-
ing Star,” “Evening Star”), so that for every Tarski’s interpretation we have that
I∗
T (≐(“Morning Star,” “Evening Star”)) = f , because
(“Morning Star,” “Evening Star”) ∉IT(≐).
That is, for each Tarskian interpretation this ground atom is false. For the intensional
interpretation, instead we have from (1.19) that
∀h ∈ℰ.h(I(≐(“Morning Star,” “Evening Star”))) = t
in contrast with Tarskian interpretation, so that I∗
T
̸= h ∘I, i. e., the diagram in (1.14)
is not commutative. Moreover, in intensional FOL semantics, we have the two-step in-
terpretation, and hence as we have seen, by using the extensionalization function h,
we can express the fact that both Morning Star and Evening Star denote the planet
Venus.
Because of that, the intensionality is a generalization of the Tarskian theory of
truth that is useful in mathematical logic but inessential to the semantics for natu-
ral language. It explains why the modern intelligent information retrieval in Web P2P
database systems requires the intensionality, and the application of the general theory
of meaning in the place of the simpler Tarskian theory of truth.
1.3.1 Enrichment by intensional abstraction operator and its logic inverse
Semantics is the theory concerning the fundamental relations between words and
things. In Tarskian semantics of the FOL, one defines what it takes for a sentence
in a language to be true relative to a model. This puts one in a position to define
what it takes for a sentence in a language to be valid. Tarskian semantics often prove
quite useful in logic. Despite this, Tarskian semantics neglect meaning, as if truth
in language were autonomous. Because of that the Tarskian theory of truth becomes
inessential to the semantics for more expressive logics, or more “natural” languages, it
is the starting point of my investigation in the previous sections about how to provide
the necessary, or minimal, intensionality to the syntax of the FOL.
However, as it was shown, we are able to enrich the expressivity of such a mini-
mal FOL intensionality by new modal operators, or in different way provided in what

1.3 First-order logic and intensionality
|
47
follows. As we have seen in the introduction to Bealer’s intensional FOL, he intro-
duced the intensional abstraction operator in point 4 of Definition 5, which will be
considered in rest of this section, as a significant enrichment of the intensional FOL
considered in the previous section.
In reflective languages, reification data is causally connected to the related reified
aspect such that a modification to one of them affects the other. Therefore, the reifi-
cation data is always a faithful representation of the related reified aspect. Reification
data is often said to be made a first class object. In programming language design,
a first-class citizen (also type, object, entity or value) in a given programming lan-
guage is an entity, which supports all of the operations generally available to other
entities. These operations typically include being passed as an argument, returned
from a function, modified and assigned to a variable. The concept of first- and second-
class objects was introduced by Christopher Strachey in the 1960s when he contrasted
real numbers (first-class) and procedures (second-class) in ALGOL. In FOL, we have
the variables as arguments inside the predicates and terms, which can be assigned
to variables are first-class objects while the predicates are the second-class objects.
When we transform a virtual predicate into a term, by using the intensional abstrac-
tion operator, we transform a logic formula into the first class object to be used inside
another predicates as first-class objects. Thus, abstracted terms in the intensional FOL
are just such abstracted terms as reification of logic formulae. For example, the sen-
tence “Marco thinks that Zoran runs,” expressed by thinks(Marco, ⋖runs(Zoran)⋗) by
using the binary predicate thinks and unary predicate runs where the ground atom
runs(Zoran) is reified into the predicate thinks.
If ϕ(x) is a formula (virtual predicate) with a list (a tuple) of free variables in
x = (x1, . . . , xn) (with ordering from left-to-right of their appearance in ϕ), and α is
its subset of distinct variables, then ⋖ϕ(x)⋗β
α is a term, where β is the remaining set of
free variables in x. The externally quantifiable variables are the free variables not in α.
When n = 0, ⋖ϕ⋗is a term, which denotes a proposition, for n ≥1 it denotes a n-ary
concept.
We recall that we denote by t/g (or ϕ/g) the ground term (or formula) without free
variables, obtained by assignment g from a term t (or a formula ϕ), and by ϕ[x/t] the
formula obtained by uniformly replacing x by a term t in ϕ.
Definition 17 (Intensional abstraction convention). From the fact that we can use any
permutation of the variables in a given virtual predicate, we introduce the convention
that
⋖ϕ(x)⋗β
α
is a term obtained from virtual predicate ϕ(x)
(1.21)
if α is not empty such that α ⋃β is the set of all variables in the list (tuple of variables)
x = (x1, . . . , xn) of the virtual predicate (an open logic formula) ϕ, and α ⋂β = 0, so
that |α| + |β| = |x| = n. Only the variables in β (which are the only free variables of this

48
|
1 Theory of new intensional first-order logic
term), can be quantified. If β is empty, then ⋖ϕ(x)⋗α is a ground term. If ϕ is a sentence,
and hence both α and β are empty, we write simply ⋖ϕ⋗for this ground term.
An assignment g : 𝒱→𝒟for variables in 𝒱is applied only to free variables in
terms and formulae. Such an assignment g ∈𝒟𝒱can be recursively uniquely extended
into the assignment g∗: 𝒯→𝒟, where 𝒯denotes the set of all terms (here I is an
intensional interpretation of this FOL, as explained in what follows), by:
1.
g∗(t) = g(x) ∈𝒟if the term t is a variable x ∈𝒱.
2.
g∗(t) = I(c) ∈𝒟if the term t is a constant c ∈P.
3.
If t is an abstracted term obtained for an open formula ϕi, ⋖ϕi(xi)⋗βiαi, then
g∗(⋖ϕi(xi)⋗βi
αi) =def { I(ϕi(xi)) ∈D|αi|,
if βi is empty
I(ϕi[βi/g(βi)]) ∈D|αi|,
otherwise
(1.22)
where g(β) = g({y1, . . . , ym}) = {g(y1), . . . , g(ym)} and [β/g(β)] is a uniform replace-
ment of each i-th variable in the set β with the i-th constant in the set g(β). Notice
that α is the set of all free variables in the formula ϕ[β/g(β)].
4.
g∗(t) = I(ϕ(x)/g) ∈D0 ⊂𝒟if t is an intensional term I(ϕ(x)) ∈D|x|.5
The abstracted terms ⋖ϕ⋗β
α can be used as terms in any predicate pk
j ∈P, e. g., for an
atom p3
j (⋖ϕ⋗β
α, y, z) with free variables y, z and that in β. Let pk
j (t1, . . . , tk) be an atom
with at least one of abstract term ti = ⋖ϕi(xi)⋗βiαi with βi nonempty and let β denote
the union of all βi of the abstracted terms in this atom. We can consider this atom as
a virtual predicate ϕ(x) with ordered tuple of free variables x, and we denote by y
its ordered subtuple without variables in β with n = |y| ≤k. Then we have that for
each assignment g ∈𝒟β, pk
j (t1/g, . . . , tk/g) is a standard atom (all abstracted terms
ti/g = g∗(ti) by using (1.22) are transformed to values in 𝒟and I(pk
j (t1/g, . . . , tk/g)) ∈
Dn ⊂𝒟), while for Tarskian interpretation we obtain the following set of tuples:
I∗
T (pk
j (t1/g, . . . , tk/g)) =def {g1(y) | g1 ∈𝒟y and I∗
T (pk
j (t1/g, . . . , tk/g)[y/g1(y)]) = t}
(1.23)
where I∗
T (pk
j (t1/g, . . . , tk/g)[y/g1(y)]) = t iff (t1/g, . . . , tk/g)[y/g1(y)] ∈IT(pk
j ), and we
recall that I∗
T (pk
j (z1, . . . , zk)) =def IT(pk
j ) if all zi, 1 ≤i ≤k, are free variables.
So, general Tarski’s and intensional interpretations are defined by
I∗
T (pk
j (t1, . . . , tk)) =def ⋃{I∗
T (pk
j (t1/g, . . . , tk/g)) | g ∈𝒟β}
̸= IT(pk
j ) ⊆𝒟k
I(pk
j (t1, . . . , tn)) =def union({I(pk
j (t1/g, . . . , tk/g)) | g ∈𝒟β})
(1.24)
where the derived operator “union” of intensional algebra is given by (1.12).
5 It happens when the abstracted term (1.22) is inside another predicate and we make the assignment
for attributes of this predicate.

1.3 First-order logic and intensionality
|
49
Let us consider the logic atoms of the predicates with multivalued attributes, as
presented in Section 4.3.1, to correspond in the FOL to another predicate whose exten-
sion will have a number of tuples, each one corresponding to one particular value. So,
such a many-valued attribute has to be transformed into an abstracted term in order to
be an argument of the predicate with such multivalued attribute without generating a
second-order logic.
Example 5 (Multivalued attributes for RDBs). We will consider the intensional RDBs,
introduced in a dedicated chapter and specifically in Section 4.3.1. Let us introduce a
multivalued attribute hobies for the relation Contacts representing the concept with
a key (identifier) attribute with the name contactID of a person, his address and his
hobbies:
Contacts(contactID, firstName, lastName, street, zipCode, hobbies).
Let this attribute hobbies be represented by a binary predicate p2
i (x1, y) where the vari-
able x1 is used for the identifiers of contacts contactID and variable y for a number of
different hobbies referred to this contact identifier. If we represent the relation with
name Contacts by a 6-ary predicate letter p6
j , then this relation in intensional FOL will
be represented by the atom
p6
j (x1, x2, x3, x4, x5, ⋖p2
i (x1, y)⋗βi
αi)
(1.25)
with βi = {x1} and hidden variables αi = {y}. So, having only one abstracted term
t6 = ⋖p2
i (x1, y)⋗βiαi (traduced by “that y is a hobby of x1”) in this logic atom, we have
that β = βi = {x1} and let us take an assignment g ∈𝒟β = 𝒟{x1}, i. e., g : {x1} →𝒟, such
that g(x1) = 123 is a value of the attribute contactID and from (1.22),
u = g∗(t6) = g∗(⋖p2
i (x1, y)⋗βi
αi) = I(p2
i (123, y)) ∈D1
for a given intensional interpretation I. So, for this assignment of variables in β = {x1},
g ∈𝒟β, from atom (1.25) we obtain a standard FOL atom with variables:
p6
j (x1, x2, x3, x4, x5, ⋖p2
i (x1, y)⋗βi
αi)/g = p6
j (132, x2, x3, x5, x5, u)
(1.26)
This unary concept u ∈D1 ⊂𝒟(a property) in 𝒟can be represented, e. g., by the
name hobbies_of_123, and hence the extension of this intensional unary concept u =
I(p2
i (123, y)), corresponding to free variable y, has to be equal to the set of hobbies of
this Contact specified by its identifier ContactID = 123, i. e.,
h(u) = h(I(p2
i (123, y)))
= I∗
T (p2
i (123, y))
(from the commutativity I∗
T = h ∘I)
= {g′(y) ∈𝒟| g ∈𝒟{y} and I∗
T (p2
i (123, g′(y))) = t}

50
|
1 Theory of new intensional first-order logic
Let us consider now a total assignment g1 ∈𝒟𝒱, such that g1(x1) = g(x1) = 123 with
the ground atom of the predicate p6
j ,
p6
j (x1, x2, x3, x4, x5, ⋖p2
i (x1, y)⋗βi
αi)/g1 = p6
j (132, Zoran, Majkic, Appia, 0187, u)
(1.27)
where, from the fact that u ∈D1 is a value (name) hobbies_of_123 of a domain 𝒟, we
can see clearly how an obtained ground atom is a standard FOL ground atom (in which
we have no more of the abstracted terms). The atom (1.25) has a hidden variable y and
the tuple x = (x1, x2, x3, x4, x5) of free variables, so that its ordered subtuple without
variables in β is y = (x2, x3, x4, x5) with n = |y| = 4. Hence, the Tarski’s interpretation
of the atom in (1.26) is obtained, from (1.23), for an assignment g : β →𝒟, by
I∗
T (p6
j (x1, x2, x3, x4, x5, ⋖p2
i (x1, y)⋗βi
αi)/g)
= I∗
T (p6
j (132, x2, x3, x4, x5, u))
= {g′(x2, x3, x4, x5) | g′ ∈𝒟y and I∗
T (pk
j (132, x2, x3, x4, x5, u)[y/g′(y)]) = t}
where y = {x2, x3, x4, x5} denotes the set of variables. So, from (1.27) we have that
(Zoran, Majkic, Appia, 0187) ∈I∗
T (p6
j (x1, x2, x3, x4, x5, ⋖p2
i (x1, y)⋗βi
αi)/g).
However, in our case where the first attribute of p6
j is the KEY-attribute (identifier) and
is fixed by assignment g by g(x1) = 132, the Tarski’s interpretation above will return
exactly with one tuple:
I∗
T (p6
j (x1, x2, x3, x4, x5, ⋖p2
i (x1, y)⋗βi
αi)/g) = {(Zoran, Majkic, Appia, 0187)}.
Remark. The predicate p2
i dedicated to multivalued attribute needs to provide not only
a variable y for this attribute but also the subset of attributes, which define the KEY of
the relation that contains this multivalued variable. In our case, the KEY of the relation
Contact is composed by its single attribute contactID represented by variable x1.
In fact, if we eliminate these KEY attributes of the relation that contains this mul-
tivalued attribute, and propose a unary predicate for the multivalued attribute, p1
i (y),
then a relation Contact is given by the atom p6
j (x1, x2, x3, x4, x5, ⋖p1
i (y)⋗y) with ground
term t6 = ⋖p1
i (y)⋗y. Consequently, in this case, for all assignments g ∈𝒟𝒱, from (1.22),
we would obtain the same u = g∗(t6) = I(p1
i (y)) ∈D1, and hence the extension of
this unary concept for hobbies would have the set of hobbies used by all contacts in
the relation Contact. So, we would not be able to obtain the hobbies of each single
contact as that of (Zoran, Majkic, Appia, 0187) corresponding to value “132” of the KEY
attribute contactID.
We introduce the special new “it is abstracted” unary predicate A( _ ), which com-
poses well- defined atoms only for abstracted terms A(⋖ϕ(x)⋗β
α) ∈ℒω with the prefixed

1.3 First-order logic and intensionality
|
51
meaning6
“it is abstracted that ϕ(x) by hiding variables in α”
The meaning of “hiding” variables in α
̸= 0 is that these variables are not influenced in
this predicate A by the assignments, so that A(⋖ϕ(x)⋗β
α)/g is equal to A(⋖ϕ[β/g(β)]⋗α)
with remaining variables in α, and that for each variable x ∈α, the FOL formula
(∃x)A(⋖ϕ(x)⋗β
α) is not well-defined in Lω. So, we obtain the particular intensional and
Tarskian semantics for this predicate A( _ ) such that this predicate transfers the inter-
pretation directly to the reified formula inside abstracted term.
Definition 18 (Semantics of “it is abstracted” unary predicate). Intensional interpre-
tation of this unary predicate is defined by
I(A(⋖ϕ(x)⋗β
α)) =def { I(ϕ(x)),
if β is empty
union({I(ϕ[β/g(β)]) | g ∈𝒟β}),
otherwise
(1.28)
Consequently, for a Tarski’s interpretation IT, the atom A(⋖ϕ(x)⋗β
α)/g is considered as
a virtual predicate ϕ[β/g(β)] with free variables in (nonempty) α, so that
I∗
T (A(⋖ϕ(x)⋗β
α)/g) =def { π−β(I∗
T (ϕ[β/g(β)])) ⊆𝒟|α|,
if β is not empty
I∗
T (ϕ(x)),
otherwise
(1.29)
where
I∗
T (ϕ[β/g(β)])
= {g′(x) | g′ ∈𝒟𝒱such that ∀xj ∈β.(g′(xj) = g(xj)) and IT(ϕ(g′(x))) = t},
and, when β is not empty, in a general case:
I∗
T (A(⋖ϕ(x)⋗β
α)) = ⋃{I∗
T (A(⋖ϕ(x)⋗β
α)/g) | g ∈𝒟β}
(1.30)
Once one has found a method for specifying the denotations of singular terms of
ℒω (taken into consideration the particularity of abstracted terms), the Tarski-style
definitions of truth and validity for ℒω may be given in the customary way.
An intensional interpretation [12] of this intensional FOL is a mapping between the
set ℒof formulae of the logic language and intensional entities in 𝒟, I : ℒ→𝒟is a kind
6 In this way, we avoid the introduction of hidden quantifiers (󲆆xi)x of predicate-compression theory
provided in Definition 23, Section 2.1.1, where “it is abstracted” atom A(⋖ϕ(x)⋗β
α) is logically equiva-
lent to the formula ∏xi∈α(󲆆xi)x)ϕ(x). More about the embedding of hidden quantifiers by intensional
abstract terms is provided in Section 2.1.3.

52
|
1 Theory of new intensional first-order logic
of compositional “conceptualization,” as defined in Section 1.2, with the following
extension to the special new “ground” atoms from (1.28) for a given assignment g,
I(A(⋖ϕ(x)⋗β
α)/g) =def { I(ϕ[β/g(β)]) ∈D|α|,
if β is not empty
I(ϕ(x)),
otherwise
(1.31)
analog to that in (1.29) for Tarski’s interpretations. The interpretation of a more com-
plex abstract term ⋖ϕ(x)⋗β
α is defined in terms of the interpretations of the relevant
syntactically simpler expressions, because the interpretation of a more complex for-
mulae is defined in terms of the interpretation of the relevant syntactically simpler
formulae, based on the intensional algebra above. This is the recursive “composition
of meaning.” For example,
I(p1
i (x) ∧{(1,1)} p1
k(x)) = conj{(1,1)}(I(p1
i (x)), I(p1
k(x))),
and
I(¬ϕ) = neg(I(ϕ)), and I(∃xi)ϕ(xi, xj, xi, xk) = exists3(I(ϕ(xi, xj, xi, xk))).
What is being considered specifically is a method how we apply an assignment g ∈𝒟𝒱
to abstracted terms with free variables in β: so, from (1.22) we have that g∗(⋖ϕ(x)⋗β
α) =
I(ϕ[β/g(β)]) ∈D|α| will denote an appropriate property or relation, depending on the
value of |α| ≥1. We have seen in Example 5 how it can be used for multivalued at-
tributes in intensional RDBs.
Notice that if β = 0 is the empty set then, from (1.22), g∗(⋖ϕ(x)⋗β
α) = I(ϕ(x)) ∈D|x|.
In the case when ϕ is an atom pm
i (x1, . . . , xm), then g∗(⋖pm
i (x1, . . . , xm)⋗x1,...,xm)
=
I(pm
i (x1, . . . , xm)) ∈Dm. The application of an assignment to a more complex ab-
stract ⋖ϕ⋗α is defined in terms of the assignments of the relevant syntactically
simpler abstract(s) [12]. For example, g∗(⋖ϕ(x) ∧S ψ(x)⋗x) = I(ϕ(x) ∧S ψ(x)) =
conjS(I(ϕ(x)), I(ψ(x))) = conjS(g∗(⋖ϕ(x)⋗x), g∗(⋖ϕ(x)⋗x)) ∈D1, where “conjS” with
S = (1, 1), is the intensional operator in the intensional algebra 𝒜int corresponding
homorphically to the logic conjunction operator of the syntax algebra of the FOL
logic (in the extension of intensional interpretation I into the homomorphism, as for
example, in the commutative diagram (1.14) in Corollary 4, Section 1.3).
Consequently, based on the intensional algebra in Definition 16 and on inten-
sional mapping in (1.24), which eliminates the abstracted terms from intensional al-
gebra, it holds that the intensional interpretation of any formula in ℒwill be reduced
to an algebraic expression over interpretations of primitive atoms in ℒ. This obtained
expression is finite for any finite formula, and represents the composed meaning of
such finite formula.
The distinction between intensions and extensions is important especially be-
cause we are now able to have and equational theory over intensional entities (as ⋖ϕ⋗),
that is predicate and function names, and is separate from the extensional equality of
relations and functions. An extensionalization function h assigns to the intensional el-
ements of 𝒟an appropriate extension as specified in Definition 7, Section 1.2,

1.3 First-order logic and intensionality
|
53
h = h−1 + h0 + ∑
i≥1
hi : ∑
i≥−1
Di 󳨀→D−1 + {f, t} + ∑
i≥1
𝒫(Di)
and we have the two-step intensionally semantics in Definition 10, Section 1.2.
From the fact that the abstract terms in intensional FOL algebra 𝒜FOL does not
propagate to intensional concepts and intensional terms of intensional algebra 𝒜int,
for the extensionalization homomorphism h : 𝒜int →𝒜R all remains equal to the case
when we do not use abstracted terms, so also Tarski’s constraints in Definition 113
remains invariant.
Consequently, the extension of an abstracted term satisfy the following property.
Proposition 7. The commutative diagram (1.14) of the Frege/Russell semantics of the
minimal intensional FOL in Corollary 4, with I∗
T = h ∘I, is preserved also for the enrich-
ment by the intensional abstract operators.
Proof. Let us show that it holds in both cases: when abstracted terms are used inside
the special unary predicate A (with particular semantics), and in a more general case
when are used inside all other standard predicates:
1.
Case of the special atoms A(⋖ϕ(x)⋗β
α):
I∗
T (A(⋖ϕ(x)⋗β
α)/g) = I∗
T (ϕ[β/g(β)])
from (1.29)
= h(I(ϕ[β/g(β)]))
from Corollary 4
= h(I(A(⋖ϕ(x)⋗β
α)/g))
from (1.31)
So, in a general case, we obtain
I∗
T (A(⋖ϕ(x)⋗β
α)) = ⋃{I∗
T (A(⋖ϕ(x)⋗β
α)/g) | g ∈𝒟β}
from (1.30)
= ⋃{h(I(A(⋖ϕ(x)⋗β
α)/g)) | g ∈𝒟β}
from above
= ⋃{h(I(ϕ[β/g(β)])) | g ∈𝒟β}
from (1.31)
= h(union({I(ϕ[β/g(β)]) | g ∈𝒟β}))
from homomorphism of h
= h(I(A(⋖ϕ(x)⋗β
α)))
from (1.28).
2.
Case of any atom pk
j (t1, . . . , tk) with at least one of abstract term ti = ⋖ϕi(xi)⋗βiαi with
βi nonempty and let β denotes the union of all βi of the abstracted terms in this
atom. We can consider this atom as a virtual predicate ϕ(x) with ordered tuple of
free variables x, and we denote by y its ordered subtuple without variables in β
with n = |y| ≤k. So, we have that for each assignment g ∈𝒟β, pk
j (t1/g, . . . , tn/g) is
a standard atom (all abstracted terms ti/g = g∗(ti) by using (1.22) are transformed
to values in 𝒟and I(pk
j (t1/g, . . . , tk/g)) ∈Dn ⊂𝒟). From the fact that in the atom
pk
j (t1/g, . . . , tn/g), we have no abstracted terms, it is valid for them the Frege/Rus-
sell semantics of the intensional FOL in Corollary 4, with I∗
T = h ∘I, i. e.,

54
|
1 Theory of new intensional first-order logic
(1)
I∗
T (pk
j (t1/g, . . . , tn/g)) = I∗
T (pk
j (t1, . . . , tn)/g) = h(I(pk
j (t1, . . . , tn)/g)).
Thus, in a general case, from (1.24), we have that
I∗
T (pk
j (t1, . . . , tk))
= ⋃{I∗
T (pk
j (t1/g, . . . , tk/g)) | g ∈𝒟β}
= ⋃{h(I(pk
j (t1/g, . . . , tk/g))) | g ∈𝒟β}
from (1)
= h(union({I(pk
j (t1/g, . . . , tk/g)) | g ∈𝒟β}))
from homomorphism of h
= h(I(pk
j (t1, . . . , tk)))
from (1.24).
Thus, I∗
T = h ∘I also for the enrichment of the minimal intensional FOL (with-
out intensional equations, shown in Example 4) by intensional abstract opera-
tors.
Hence, from this proposition, for each Tarski’s interpretation IT of the intensional
FOL with intensional abstraction operators and fixed intensional interpretation I, we
have an extensionalization function h such that I∗
T = h ∘I, and hence the extension of
the “ground” predicate A(⋖ϕ(x)⋗β
α)/g = A(⋖ϕ(x)⋗β
α/g), is obtained by
I∗
T (A(⋖ϕ(x)⋗β
α/g)) = h(I(ϕ[β/g(β)])) = I∗
T (ϕ[β/g(β)]),
i. e.,
I∗
T (A(⋖ϕ(x)⋗β
α/g)) = {g′(π−β(x)) | g′ ∈𝒟α, I∗
T (ϕ[β/g(β)][α/g′(α)]) = t}
(1.32)
where π−β(x) is the sublist of x from which are eliminated the variables in β.
Example 6 (Global compression of predicates). Let us consider for a fixed set α of n =
|α| hidden variables, the following Herbrand base H =def {A(⋖rk
j (x)⋗β
α/g) | g ∈𝒟𝒱, rk
j ∈
P, k ≥|α|}, and flattened Herbrand base
HF =def {rk
j (x)[β/g(β)][α/g′(α)] | g′ ∈𝒟α, rk
j ∈P, k ≥|α|},
so that for 𝒲= 𝒟n, we have the bijection is : HF →H × 𝒲, the higher part of dia-
gram (A.3) in Section A.4 in the Appendix represent the following global compression
represented by higher order Herbrand base H and its flattened (standard) version HF,
2𝒲× 𝒲
eval
? 2
Higher-order
H × 𝒲
IH
?
idW
?
?
is
HF
IF
? 2
id2
?
(1.33)
such that for y subtuple of x composed by only variables in α, and any g′ ∈𝒟α, tuple
d = g′(y) ∈𝒲, we have that

1.3 First-order logic and intensionality
|
55
IH(A(⋖rk
j (x)⋗β
α/g))(d) = IF(rk
j (x)[β/g(β)][α/g′(α)])
Now we are able to define the intensional equivalences, introduced previously
in Example 3 and equation (1.11) in Corollary 3 for the minimal intensional FOL in
Definition 15 enriched by the universal “high-level” modal operator ̂◻and existential
modal operator ̂♦= ¬̂◻¬ with accessibility relation ℛ= 𝒲e × 𝒲e (where 𝒲e = IT(Γ)
is the set of all Tarski’s interpretation of this intensional FOL), between the abstracted
terms ⋖ϕ(x)⋗β1
α /g (i. e., ⋖ϕ[β1/g(β1)]⋗α) and ⋖ψ(y)⋗β2
α /g (i. e., ⋖ψ[β2/g(β2)]⋗α), where
all free variables (not in α) are instantiated by g ∈𝒟𝒱(we recall that A ≡B denotes
the formula (A ⇒B) ∧(B ⇒A)), i. e., the formula ¬(A ∧¬B) ∧¬(¬A ∧B):
1.
(Strong) intensional equivalence (or equality) “≍” is defined by
⋖ϕ(x)⋗β1
α /g ≍⋖ψ(y)⋗β2
α /g
iff
̂◻(ϕ[β1/g(β1)] ≡ψ[β2/g(β2)])
(1.34)
with ℳ󳀀󳨐w,g′ ̂◻φ[β1/g(β1)] iff for all w′ ∈𝒲e, (w, w′) ∈ℛimplies ℳ󳀀󳨐w′,g′
φ[β1/g(β1)].
So, we have that ⋖p1
1(x)⋗x ≍⋖p1
2(x)⋗x, i. e., “x has been bought” and “x has been
sold” are intensionally equivalent, but they have not the same meaning (the con-
cept I(p1
1(x)) ∈D1 is different from I(p1
2(x)) ∈D1).
2.
Weak intensional equivalence “≈” is defined by
⋖ϕ(x)⋗β1
α /g ≈⋖ψ(y)⋗β2
α /g
iff
̂♦ϕ[β1/g(β1)] ≡̂♦ψ[β2/g(β2)]
(1.35)
This weak equivalence is used for P2P database integration in a number of papers
[42, 53–58].
Note that if we want to use the intensional equality in our language, then we need the
correspondent operator “necess” in intensional algebra 𝒜int for the universal operator
“̂◻” (modal necessity logic operator).
This semantics is equivalent to the algebraic semantics for ℒin [27] for the case of
the conception where intensional entities are considered to be equal if and only if they
are necessarily equivalent. Intensional equality is much stronger that the standard ex-
tensional equality in the actual world, just because requires the extensional equality
in all possible worlds, in fact, if ⋖ϕ(x)⋗β1
α /g ≍⋖ψ(y)⋗β1
α /g then h(I(A(⋖ϕ(x)⋗β1
α /g))) =
h(I(A(⋖ψ(y)⋗β2
α /g))) for all extensionalization functions h ∈ℰ(i. e., for possible worlds
(Tarski’s interpretations), I∗
T = w = is−1(h) ∈𝒲e = IT(Γ)). It is easy to verify that the
intensional equality means that in every possible world w ∈𝒲e (i. e., Tarski’s inter-
pretation) the intensional entities u1 and u2 have the same extensions.
Let the logic modal formula ̂◻ϕ[β1/g(β1)], where the assignment g is applied only
to free variables in β1 of a formula ϕ not in the set of variables in α = (x1, . . . , xn),
n ≥1, represents a n-ary intensional concept such that I(̂◻ϕ[β1/g(β1)]) ∈Dn and, from
(1.22), I(ϕ[β1/g(β1)]) = g∗(⋖ϕ(x)⋗β1
α ) ∈Dn. Then the extension of this n-ary concept is

56
|
1 Theory of new intensional first-order logic
equal to (here the mapping necess : Di →Di for each i ≥0 is a new operation of the
intensional algebra 𝒜int in Definition 16):
h(I(̂◻ϕ[β1/g(β1)]))
= h(necess(I(ϕ[β1/g(β1)])))
= {(g′(x1), . . . , g′(xn)) | ℳ󳀀󳨐w,g′ ̂◻ϕ[β1/g(β1)] and g′ ∈𝒟𝒱}
= {(g′(x1), . . . , g′(xn)) | g′ ∈𝒟𝒱and ∀w1((w, w1) ∈ℛimplies ℳ󳀀󳨐w1,g′ ϕ[β1/g(β1)])}
= ⋂
h1∈ℰ
h1(I(ϕ[β1/g(β1)])).
While,
h(I(̂♦ϕ[β1/g(β1)]))
= h(I(¬̂◻¬ϕ[β1/g(β1)]))
= h(neg(necess(I(¬ϕ[β1/g(β1)])))) = 𝒟n\h(necess(I(¬ϕ[β1/g(β1)])))
= 𝒟n\( ⋂
h1∈ℰ
h1(I(¬ϕ[β1/g(β1)])))
= 𝒟n\( ⋂
h1∈ℰ
h1(neg(I(ϕ[β1/g(β1)]))))
= 𝒟n\( ⋂
h1∈ℰ
𝒟n\h1(I(ϕ[β1/g(β1)])))
= ⋃
h1∈ℰ
h1(I(ϕ[β1/g(β1)])).
Consequently, the modal formulae ̂◻ϕ[β1/g(β1)] and ̂♦ϕ[β1/g(β1)] are the built-in (or
rigid) concept as well, whose extensions does not depend on possible worlds.
Thus, two concepts are intensionally equal, i. e., ⋖ϕ(x)⋗β1
α /g ≍⋖ψ(y)⋗β2
α /g, iff
h(I(ϕ[β1/g(β1)])) = h(I(ψ[β2/g(β2)])) for every h, i. e., iff I∗
T (ϕ[β1/g(β1)]) = I∗
T (ψ[β2/
g(β2)]) for every Tarski’s homomorphism I∗
T ∈𝒲e.
Analogously, two concepts are weakly equivalent, i. e.,
⋖ϕ(x)⋗β1
α /g ≈⋖ψ(y)⋗β2
α /g,
iff
h(I(̂♦ϕ[β1/g(β1)])) = h(I(̂♦ψ[β2/g(β2)])),
i. e.,
iff
I∗
T (♦ϕ[β1/g(β1)]) = I∗
T (♦ψ[β2/g(β2)])
for every Tarski’s homomorphism I∗
T ∈𝒲e.
The weak equivalency will be used for the P2P database mappings, in the cases when
β1 = β2 = 0 are empty sets, and hence α is the set of all variables in the list (tuple) of
variables x, so that (1.35) is reduced to simpler form

1.3 First-order logic and intensionality
|
57
ϕ(x) ≈ψ(x)
iff
⋖ϕ(x)⋗α ≈⋖ψ(x)⋗α
iff
̂♦ϕ(x) ≡̂♦ψ(x)
(1.36)
where ϕ(x) and ψ(x) are two intensionally equivalent queries over peer databases in
such a P2P database system, with I′ ∗
T (̂♦ϕ(x)) = ⋃IT∈𝒲e I∗
T (ϕ(x)), which does not de-
pend on I′ ∗
T
and hence ̂♦ϕ(x) is rigid concept which Tarski’s interpretation can be
denoted by “least upper bound” lub(ϕ(x)), i. e.,
lub(ϕ(x)) =def
⋃
IT∈𝒲e
I∗
T (ϕ(x))
(1.37)
so that the intensional equivalence in (1.36) holds when
lub(ϕ(x)) = lub(ψ(x)),
(1.38)
i. e., when I∗
T (̂♦ϕ(x) ≡̂♦ψ(x)) = R, for each Tarski’s homomorphism I∗
T ∈𝒲e.
The bound (hidden) variables of the special “it is abstracted” unary atom A with
the argument given by an abstracted term ⋖ϕ(x)⋗β
α with at least one bound variable,
i. e., |α| ≥1, will be extensively used for the constraint databases in Section 2.1.3, where
these bound variables are hidden (encapsulated in the compressed virtual predicate)
and cannot be affected by the assignments and quantifiers. In order to give the possi-
bility to observe also these attributes of abstracted virtual predicate, it is convenient
to have also the inverse operator of the intensional abstraction, denoted by “⊲,” as
follows.
Definition 19 (Inverse operator to abstraction). The unary logic operator inverse of
the intensional abstraction operator for any given intensional FOL formula ψ(y),
which does not contain this operator “⊲,” is defined by a formula
⊲ψ(y)
is equivalent to { ϕ(x),
if ψ(y) is the atom A(⋖ϕ(x)⋗β
α) and y = π−βx
ψ(y),
otherwise
(1.39)
so that it left invariant any formula different from “it is abstracted” unary atom A.
Consequently, with introduction of this logic unitary operator, the Kripke semantics
of intensional FOL in Definition 15 does not change, because from above, for this new
operator we have
̂
ℳ󳀀󳨐IK,g⊲A(⋖ϕ(x)⋗β
α)
iff
̂
ℳ󳀀󳨐Ik,g ϕ(x)
where the right-hand side condition is already provided by Definition 15.
Remark. The definition of this unary logic operator “⊲′’ given by (1.39) extends to all
formulae of intensional FOL by a standard way:

58
|
1 Theory of new intensional first-order logic
1.
⊲(¬ψ(x)) = ¬(⊲ψ(x));
2.
⊲(ψ1(x) ⨀ψ2(y)) = (⊲ψ1(x)) ⨀(⊲ψ2(y)), for each FOL binary logic connec-
tive ⨀.
3.
⊲((∃xj)ψ(x)) = (∃xj) ⊲ψ(x), with constraint that if ψ(x) correspond to A(⋖ϕ(x)⋗β
α)
atoms then xj must be a visible variable in β.
The utility of this inverse operator for the observation of the hidden attributes of the
geometrical objects used in constrained databases will be considered in Section 2.1.3.
We will show how the truth of the sentence ⊲A(⋖ϕ(x)⋗β
α)/g is a possible way to observe
the values g(π−βx) of the hidden variables of the “ground” formula A(⋖ϕ(x)⋗β
α)/g.
1.3.2 Logics via symmetry: intensional abstraction and ontological encapsulation
transformations
Most related philosophical questions deal with specific symmetries, objectivity, inter-
preting limits on physicaltheories,classificationand lawsofnature.The recenthistory
of the philosophy of mathematics is largely focused on grasping and defining the na-
ture and essence of mathematics and its objects. Attempts to do this include explicat-
ing versions of: mathematics is just logic, mathematics is just structure, mathematics
is a meaningless game, mathematics is a creation of the mind, mathematics is a useful
fiction, etc.
Symmetries play a fundamental role in physics because they are related to conser-
vation laws. This is stated in Noether’s theorem, which says that invariance of the ac-
tion under a symmetry transformation implies the existence of a conserved quantity.
For instance, the conservation of the momentum vector 󳨀→p is associated with trans-
lation invariance of the Lagrangian, i. e., the Poincare transformation 󳨀→r →󳨀→r + 󳨀→
r0,
where 󳨀→
r0 is a constant vector; while the conservation of energy comes from the in-
variance under time translations t →t + t0. Thus, in the field theory of physics, the
Lagrangian density ℒG is a function of independent variables qj, for j = 0, 1, 2, 3 with q0
time coordinate, and other three are three orthogonal space coordinates, and depen-
dent variables vj, complex field Ψ(q0, q1, q2, q3) ∈ℂ, and their derivatives up to a fixed
but arbitrary order, thus ℒG(Ψ, 𝜕jΨ, qj, vj), and hence the Lagrangian LG is defined by
(we denote dV by d3q and dtdV by d4q):
LG = ∫
ℝ3
d3qℒG(Ψ, 𝜕jΨ, qj, vj)
(1.40)
Thus, for any closed finite time-interval [t0, t1] and time–space volume Ω = [t0, t1]×ℝ3,
the action of a field theory with Lagrangian density ℒG is defined by
S[Ψ] =
∫
[t0,t1]
dtLG = ∫
Ω
d4qℒG(Ψ, 𝜕jΨ, qj, vj)
(1.41)

1.3 First-order logic and intensionality
|
59
The action S is a functional of the field Ψ and we are looking for a field configuration
Ψ that extremizes the action, from which the equation of motion can be derived by the
Hamiltonian principle of least action (1.41).
Differently from physics, in logics, of a given predicate modal logic ℒwith the
set of sentences F(ℒ), the Herbrand base (ground atoms) H ⊆F(ℒ), and a given lattice
(X, ≤) of logic truth values, we have no the continuous functions and their derivations.
We also introduce the binary predicate p2
M, not present in ℒ, with first argument for ab-
stracted terms and second for logic truth values in X. So, let us consider the following
analogy:
1.
A discrete abstract time–space of points Ω = F(ℒ) × X, where “time” F(ℒ) is the
set of sentences ϕ ∈ℒand X is the “space.” Thus, the “integration” over “time–
space” will be replaced by set union.
2.
The concept of 2-valued scalar field Ψ : Ω →2, such that at a point (ϕ, x) ∈Ω,
Ψ(ϕ, x) ∈2 is the truth of the two-valued metasentence “the truth value of sen-
tence ϕ is equal to x,” denoted by the ground atom p2
M(⋖ϕ⋗, x) representing logical
knowledge.
3.
The “Lagrangian density” ℒG(Ψ, v) for the field Ψ and parameter v ∈XH (which is
a Herbrand valuation of this logic ℒ) can be defined by the logic inference relation
ℒ󳀀󳨐v of ℒ, that is by “the inference from ℒfor its Herbrand valuation v.”
4.
The “Lagrangian” at a time ϕ ∈F(ℒ), from (1.40), by
LG(ϕ) = ∫
X
dxℒG(Ψ(ϕ, x), v) =def {p2
M(⋖ϕ⋗, x) | x ∈X, p2
M(⋖ϕ⋗, x) is true},
i. e.,
LG(ϕ) = ∫
X
dxℒG(Ψ(ϕ, x), v) = {p2
M(⋖ϕ⋗, v∗(ϕ))}
(1.42)
where v∗(ϕ) denotes the inferred logic truth-value of ϕ (the “integration” over
“space” X can produce only one truth-value (space-position), so we obtain a sin-
gleton set). That is, the “logic Lagrangian” LG defines the truth value of each sen-
tence of this logic.
5.
Thus, the action (1.41) in Logics is obtained by
S[Ψ] = ∫
F(ℒ)
dϕLG(ϕ) =def
⋃
ϕ∈F(ℒ)
LG(ϕ) = {p2
M(⋖ϕ⋗, v∗(ϕ)) | ϕ ∈F(ℒ)}
(1.43)
which defines the extended valuation v∗: F(ℒ) →X of the “parameter” v :
H →X in Lagrangian density ℒG. So, for this parameter, the action S[Ψ] is com-
plete logical knowledge of predicate modal logic ℒ.
6.
Principle of minimal action: Let us consider a monotonicconsequencebinary rela-
tion ⊢(see Section A.2 in Appendix), and consider in our case the metalogic based
on the binary predicate p2
M, with Γ ≜{p2
M(⋖ϕ⋗, v(ϕ)) | ϕ ∈H}, which is the subset
of the set of ground atoms ℒ0 ≜{p2
M(⋖ϕ⋗, x) | ϕ ∈F(ℒ)}, x ∈X}, so that Γ ⊢

60
|
1 Theory of new intensional first-order logic
p2
M(⋖ϕ⋗, x) denotes that the sentence (ground atom) p2
M(⋖ϕ⋗, x) ∈ℒ0, is inferred
from the set Γ. Thus, we obtain the consequence operation (see Section A.2),
a mapping C : 𝒫(ℒ0) →𝒫(ℒ0), where 𝒫(ℒ0) denotes the set of all subsets of
ℒ0. Consequently, the Hamiltonian principle of minimal action in Logics is repre-
sented by
S[Ψ] = C(Γ) ≜{p2
M(⋖ϕ⋗, x) ∈ℒ0 | Γ ⊢p2
M(⋖ϕ⋗, x)},
(1.44)
i. e., by the fact that the action (1.43) is exactly the least fixed point of the conse-
quence relation. So, the Euler–Lagrange equation is the equation C(C(Γ)) = C(Γ).
From the fact that v ∈XH is a parameter of “Lagrangian density” ℒ󳀀󳨐v, this least action
is always well-defined. Note that this least action is the set of all facts (ground atoms)
with their truth-value, and hence represent the logic knowledge. So, we are able now
to represent the symmetry transformation Ψ 󳨃→Ψ′ in physics with equal actions (1.41),
S[Ψ] = S[Ψ′], by corresponding symmetry in logics.
Definition 20. The transformations of “field” Ψ 󳨃→Ψ′ represent a logic symmetry if
the following bijection of the least actions (1.44) is valid:
isS : S[Ψ] ≃S[Ψ′]
(1.45)
Note that from this extension of the symmetries from physics to logics, this bijec-
tion is the isomorphism in the Set category, of the two sets that represent the logic
knowledge. So, the Noether’s invariant charge, in Logic corresponds to the logic
knowledge: Symmetries are the transformations of a predicate modal logic ℒwhich
preserve the logic knowledge. The previous correspondence of symmetries in physics
and logics can be shortly represented in Table 1.1.
Table 1.1: Physics/Logics Correspondence.
Physics
Logics
Coordinates
time–space
sentence-truth
(q0, q1, q2, q3) ∈Ω = [t0, t1] × ℝ3
(ϕ, x) ∈Ω = F(ℒ) × X
Field
complex function Ψ
metasentences truth Ψ : Ω →2
Lagrangian density
ℒG(Ψ, 𝜕jΨ, qj, vj)
inference ℒG(Ψ, v), i. e., ℒ󳀀󳨐v
Transformations
Ψ 󳨃→Ψ′
ℒ󳨃→ℒ′, X 󳨃→X′
Symmetry
least action equality
least action isomorphism
S[ψ] = S[Ψ′]
isS : S[Ψ] ≃S[Ψ′]
Invariance
Noether’s charges
knowledge
From the very beginning of my academic research, the symmetry was the center of my
attention, and in fact my PhD thesis “Categories: Symmetry, n-dimensional levels and

1.3 First-order logic and intensionality
|
61
applications” [59] was just a development of a symmetry in abstract category theory.
In Section A.5.1 in the Appendix is provided a short introduction to internal catego-
rial symmetry, taken from my PhD thesis, and after a number of examples provided in
[59], 16 years after it, in my “Big Data Integration Theory” book [59] I developed a DB
category as a general denotational semantics model for RDB databases (seen as com-
plex objects) and semantic mapping morphisms (derived from a kind of second-order
logic sentences) between them with the categorial symmetry property: an algebraic
representation of an ontology. In fact, the notion of ontology has become widespread
in fields such as intelligent information integration, cooperative information systems,
information retrieval, electronic commerce and knowledge management, and also in
this book I presented a number of such examples.
Let us consider the following two kinds of logic transformations: First, one has
categorial but not logic symmetry, while second has logic but not categorial symmetry:
Intensional abstraction transformations
The categories heaving internal symmetry property (see Section A.5.1 in the Appendix)
are able to represent not only a particular theory but also the metatheories about
this basic “initial” particular theory inside the same category. So, such categories are
similar to the natural language properties, differently from, e. g., the standard (exten-
sional) first-order logic with Tarskian truth semantics. Such properties become impor-
tant in the area of semantic WEB, a proposal to build an infrastructure of machine-
readable semantics for the data (ontology) on the world wide web. The enormous
amount of data has made difficult to find, access, present and maintain the informa-
tion required by users. This is because information content is presented primarily in
natural language, and needs the formal language specification with natural language
features, as, for example, reification. Section 2.3 is dedicated just to the embedding of
the semantic web-languages RDF and Web Ontology Language (OWL) where the state-
ments are also resources, so that statement can be applied recursively to statements,
allowing their nesting (reification).
Now, if we consider such statements as the morphisms in a given category, the
necessity to use such morphisms also as the objects of this category in order to make
another statements about them (reification), then we need the categorial symmetry
inside this category. Intensional abstraction is a kind of language categories trans-
formation symmetry (of logic sentences into terms) different from semantic symme-
tries: of predicate compression transformations and of ontological encapsulation by
semantic reflection transformations of many-valued logics. In fact, in this case we do
not change the syntax of “reference” (standard) predicate logic but only an extension
of its terms by new terms obtained from the sentences. While the reification, which
uses these abstracted terms inside other predicates changes the logic knowledge of the
“reference” predicate logic, the (only) intensional abstraction transformation of logic
ground atoms into abstracted terms does not change this logic’s knowledge. Thus, the

62
|
1 Theory of new intensional first-order logic
logic’s knowledge remains invariant by intensional abstraction transformations only if
we do not use abstracted terms inside other predicates. This duality “sentences-terms”
is an analogy to the duality “arrows-objects” in mathematical concept of category, and
hence in this case we will generate a particular symmetry in the category for the Her-
brand base, where the morphisms represent the ground atoms in Herbrand base and
the objects are the terms.
So, the intensional abstraction of an atom into a term is just the transformation of
a morphism into an object, used in definition of categorial symmetry in Section A.5.1.
Definition 21. Let us define the graph GH of the Herbrand base H of the intensional
FOL with abstraction operator.
Each atom pk
i (d) ∈H is represented as an arrow l : d →xX in GH (left-hand side
in diagram (1.49)) from domain d = (d1, . . . , dk), tuple of values in 𝒟, into the logic-
variable xX of the lattice (X, ≤) of the truth values.
We denote by Sch(GH) the sketch category derived from this graph GH where to
each object (node) d is associated the identity arrow equal to the ground atom ≐(d, d),
and to each object equal to abstracted term ⋖A⋗for some atom A ∈H is associated
the identity arrow equal to the ground atom ≐(⋖A⋗, ⋖A⋗), where “≐” is the binary
identity predicate. The composition of morphisms (arrows) in Sch(GH) is defined by
logic conjunction ∧, so that two arrows in it are equal if are logically equivalent.
Note that there is no arrow from object xX (which is not terminal) toward other
objects and all identity arrows in category Sch(GH) are tautologies, and composition of
arrows is logic conjunction, so we can omit the identity arrows from the compositions.
The only nonidentity arrows in Sch(GH) (see in left-hand side of Figure 1.49) are that
obtained from the ground atoms in H.
If we extend the graph with the morphisms represented by sentences ϕ(x)/g :
g(x) →xX, then we obtain the sketch category with categorial symmetry extended to
all sentences of the logic language with objects (terms) ⋖ϕ(x)/g⋗as well.
Corollary 5. We have categorial symmetry of morphisms Mor and objects Ob in
Sch(GH). However, Sch(GH) is not conceptually closed category.
Proof. The function BT : Mor →Ob in Definition 128 in Section A.5.1 in the Appendix,
we define in the way that for each identity arrow in Sch(GH) it is equal to the dom ∈Σ,
which returns with the domain object of this arrow; otherwise it is equal to abstraction
operator ⋖⋗, which transforms logic atoms into terms. So, BT(idB) = B ≃B, and hence
is satisfied the representability principle.
From the fact that the operator ∗: Ob2 →Ob is partial mapping, we can omit it
completely because we have no composition of two arrows in C = Sch(GH) in which
both of them are different from the identity arrow. From the fact that in (Mor, ∘), we
can eliminate all identity arrows in composition only distinct, and we have no com-
position of two nonidentity arrows, in this case we can consider that there is no any

1.3 First-order logic and intensionality
|
63
composition of objects by the operator ∗. So, the Corollary 33 in Section A.5.1 in the
Appendix is satisfied.
Note that if we use the abstracted terms by reification inside other unary pred-
icates (what is the reason to introduce the intensional abstraction transformation),
then we obtain an enlarged Herbrand base with also reified atoms, and hence with
this we change the logic knowledge, and hence generally we do not obtain the logic
symmetry.
2. Ontological encapsulation transformations (from Section A.4.2 in the Appendix)
Sketches are called graph-based logic and provide very clear and intuitive specifica-
tion of computational data and activities. For any small sketch E, the category of mod-
els Mod(E) is an accessible category by Lair’s theorem and reflexive subcategory of
SetE by the Ehresmann–Kennison theorem. In fact, in our case for a given Herbrand
interpretation v : H →X, the covariant functor F = (F0, F1) : Sch(GH) →Set is a
model of Sch(GH) if it satisfies the following property.
Definition 22. For each Herbrand interpretation v : H →X, we can define the follow-
ing two functorial models of a given Herbrand base category Sch(GH) in Definition 21:
1.
The covariant functor F(v) = (F0, F1) : Sch(GH) →Set, such that for any object B
in Sch(GH), and a distinct constant ♭not belonging to domain 𝒟,
F0(B) = { X ⋃{♭},
if B = xX
{B, ♭},
otherwise
(1.46)
and for any nonidentity morphism (ground atom) l = pk
j (d) : d →xX, the function
fpk
j = F1(pk
j (d)) : {d, ♭} →(X ⋃{♭}) has to satisfy that
fpk
j (d) = v(pk
j (d)) ∈X
and
fpk
j (♭) = ♭
(1.47)
Obviously, it has to be satisfied also for the nested (reified) arrows p1
n(⋖A⋗) :
⋖A⋗→xX with A ∈H.
2.
The contravariant functor G(v) = (G
0, G
1) : Sch(GH) →Set, such that for the
objects G
0 = F0 is equal to the covariant functor F(v) above, while for any non-
identity morphism (ground atom) l = pk
j (d) : d →xX, we obtain the function
fpk+1
F
= G
1(pk
j (d)) : (X ⋃{♭}) →{d, ♭} (a reversed arrow), such that
fpk+1
F (a) = { d,
if a = v(pk
j (d)) ∈X
♭,
otherwise
(1.48)
Note that the contravariant functor G(v) = (G
0, G
1) : C →Set in point 2 above,
where the category C = Sch(GH), can be equivalently represented (see Section A.5

64
|
1 Theory of new intensional first-order logic
in the Appendix) by the covariant functor G(v) = (G0, G1) : COP →Set, such that
G0 = G
0 while for the arrows G1(lOP) = G
1(l), as represented by the following diagram
corresponding to the ontological encapsulation syntax transformation (the symme-
try), such that the opposite arrow of l = pk
j (d) in C is defined by 2-valued flattened
atom lOP = pk+1
F (d, xX):
d
d1
d2
. . .
d
d1
d2
. . .
xX
l1
?
?
l2
in C
l = pk
j (d)
?
xX
lOP
1
?
lOP
2
?
?
COP
lOP = pk+1
F (d, xX)
C = Sch(GH) 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
Ontological Encapsulation
COP
(1.49)
The knowledge invariance of the ontological encapsulation transformation based on
the categorial duality principle (a general form of categorial symmetry) can be formal-
ized by the following.
Corollary 6. The knowledge invariance of the ontological encapsulation transforma-
tions based on categorial duality, for a given Herbrand interpretation v : H →X, can
be mathematically expressed by the natural transformation η : F(v)
󳐂? G(v) from the
covariant functor F(v) into the contravariant functor G(v) specified by point 1 and 2 of
Definition 22 relatively, such that the arrows in Set obtained by this natural transforma-
tion are the identity arrows.
Proof. Let us consider the arrow l = pk
j (d) : d →xX in the category C = Sch(GH) (cor-
responding to the arrow lOP = pk+1
F (d, xX) in the dual category COP), which represent
the encapsulation (flattening) of the ground atom pk
j (d) into flattened atom pk+1
F (d, xX)
obtained by enlargement of the original atom by the truth-variable xX. Let us show that
the natural transformation η for the covariant functors F(v), G(v) : C →Set, applied
to the arrow l = pk
j (d), generates the following natural transformation diagram in the
Set:
A = F0(d) = {d, ♭}
ηA ? A = G
0(d) = {d, ♭}
B = F0(xX) = X ⋃{♭}
fpk
j = F1(pk
j (d))
?
ηB
? B = G
0(xX) = X ⋃{♭}
fpk+1
F
= G
1(pk
j (d))
?
(1.50)
where for ηA equal to identity arrow of the object A and ηB equal to identity arrow of
the object B this diagram commutes (easy to verify from Definition 22).

1.3 First-order logic and intensionality
|
65
Note that we obtained the identity composition, fpk+1
F ∘fpk
j = idA, but fpk
j ∘fpk+1
F
̸= idB,
i. e., there is not the natural transformation from the contravariant functor G(v) into
the covariant functor F(v) (in fact, for a ∈X such that a
̸= v(pk
j (d)), we obtain that
fpk+1
F (a) = ♭∉X, and hence fpk
j (fpk+1
F (a)) = ♭
̸= a).
The knowledge in our case, represented with Herbrand base H, is specified by
the truth of the facts expressed by ground atoms in H, i. e., this “logic knowledge” is
just expressed by given Herbrand interpretation v : H →X, which assigns the logic
value in X to each atom in H. So, we need to verify that this ontological encapsulation
transformations, expressed formally (mathematically) by the categorial natural trans-
formation η in Corollary 6 preserves by the logic knowledge of the “reference” (original
many-valued) logic. Note, that both functors F(v) and G(v) generates the models for the
reference logic and for the metalogic obtained by encapsulation, relatively, and hence
this identity natural transformation η indeed represents the invariance (“identity”) of
logic knowledge.
This invariance of knowledge is represented for a given v : H →X and each assign-
ment g to variables in x, as explained by “semantic-reflection” in Definitions 117, 118
and 119 in Section A.4.2 in the Appendix, by: if an atom pk
j (x)/g has, a logic value
a = v(pk
j (x)/g) ∈X, then the 2-valued flattened atom pk+1
F (x, a)/g = ℰ(pk
j (x)/g) is
true. So, for transformed “field” action S[Ψ′] ≜{p2
M(⋖ℰ(ϕ/g)⋗, 1) | ℳ󳀀󳨐w,g ℰ(ϕ) for
w
=
v∗(ϕ/g), the symmetry (1.45) is given by bijection isS(p2
M(⋖pk
j (x)/g⋗, a))
=
p2
M(⋖(pk+1
F (x, a)/g⋗, 1), i. e., for any sentence ϕ/g ∈F(ℒ),
isS(p2
M(⋖ϕ/g⋗, v∗(ϕ/g))) = p2
M(⋖ℰ(ϕ/g)⋗, 1)

2 Applications of the intensional abstraction
operator
2.1 Predicate (de)compression transformations
It is well known that the prominent role that symmetry plays in the development of the
laws of physics, e. g., the symmetries of the 9-D time-space Galilean group in quantum
theory [60, 61]. Physicists have generalized the term “symmetry” from descriptions of
objects to descriptions of the laws of nature. A law of nature exhibits a symmetry when
it can be viewed from multiple perspectives and still remain the same. We say that such
a law is “invariant” with respect to some change of perspective. Just as symmetry con-
siderations have helped clarify many issues in the philosophy of science so, too, our
work sheds light on familiar problems in the philosophy of mathematics. Mathemati-
cians talk about numerous geometrical or topological theorems such as the Jordan
curve theorem. This statement says that any nonself-intersecting (simple) closed con-
tinuous curve in the plane splits the plane into an “inside” and an “outside.” So, for
every closed continuous curve, there are two regions. Here, in the logic as domain of
discourse, we will split the attributes of a predicate into “hidden” and “visible” at-
tributes (variables), which is an invariant transformation w. r. t. the knowledge repre-
sented by this predicate (knowledge conservation law as a kind of categorial symmetry,
shown in Section 1.3.2). From this perspective, one can see how variables are so cen-
tral to the mathematical discourse and why mathematicians from Felix Klein to Tarski
to Whitehead touted their import for mathematics.
Knowledge-based systems must typically deal with imperfection in knowledge
in the form of incompleteness and uncertainty. Extensions to many-valued logic pro-
gramming and deductive databases for handling incompleteness/uncertainty are nu-
merous. They can broadly be characterized into nonprobabilistic and probabilistic for-
malisms. In Section A.4, we show how the higher types of Herbrand interpretations for
logic programs, where it is not possible to associate a fixed logic value (a constant from
a given domain of truth values) to a given ground atom of a Herbrand base, arise often
in practice when we have to deal with uncertain information. In such cases, we asso-
ciate some degree of belief to ground atoms, which can be simple probability, a prob-
ability interval or other more complex data structures, as for example, in Bayesian
logic programs where for a different kind of atoms we may associate different (from
probability) kind of measures also.
But we can see the approximate (uncertain) information as some kind of relativiza-
tion of truth values for sentences also: Let H be a Herbrand base for a logic program,
which handles the uncertain information, and r(d) a ground atom in H, which logi-
cally defines some particular fact for which we have only an approximated informa-
tion when it happened. Thus, this atom r(d) is not longer absolutely true or false, but
its truth depends on the approximate temporal information about this fact: in some
https://doi.org/10.1515/9783110981438-002

2.1 Predicate (de)compression transformations
|
67
time points it can be true, in others, it can be false. If we consider such temporal ap-
proximation as a context for this ground fact r(d) ∈H, then we obtain that the truth
of r(d) is a function from the time to the ordinary set of truth values 2 = {f, t} (with f
for false and t for true value, respectively). So that the truth values of ground atoms
in this Herbrand base are the functions, i. e., they have a higher-order type (this term
is taken from the typed lambda calculus) with respect to the set 2 of truth constants.
Intuitively, the approximated information is relativized to its context, and such con-
text further specifies the semantics for uncertain information. This intuitive way to
introduce the higher-order Herbrand model types framework for uncertain informa-
tion is not only an interesting point of view for such approximated information. Such
analogies are provided in other logic theories also: for instance, in the possible-world
semantics for a probabilistic logic programming [62–64]. All such context sensitive
applications, with higher-order Herbrand models, can be transformed (i. e., flattened)
to logic theories with basic (ordinary) Herbrand interpretations, by enlarging the orig-
inal predicates with new attributes for the properties of the context: in this way, the
context becomes a part of the language of the logic theory, i. e., it becomes visible.
The higher types of Herbrand interpretations arise also in the compression of
databases, i. e., in a kind of database encapsulation where some number of attributes
of its relations are hidden for users. More recently, other applications have required
the use of database technology to manage not only finite data but also infinite ones.
This phenomena is particularly important for the constraint databases [65]: Con-
straints are natural to describe temporal, spatial and geographic data. Since time and
space are infinite, spatial and temporal objects are commonly expressed over rational
or real variables using linear or polynomial inequalities. Starting from the observa-
tion that often infinite information can be finitely represented by using mathematical
constraints, constraint databases have been proposed with the aim of inserting math-
ematical constraints both at the data and at the language level. At the data level,
constraints allow the finite representation of infinite objects. At the language level,
constraints increase the expressive power of specific query languages, by allowing
mathematical computations. Thus, constraints are the logic formulae composed by
the built-in predicates. For example, a rectangle with its center at point (x0, y0) can be
described by the following constraint virtual predicate ϕ(x, y, x0, y0) defined by the
following composition of the built-in binary predicate “≤”:
(x ≤x0 + 5) ∧(x0 −5 ≤x) ∧(y ≤y0 + 14) ∧(y0 −14 ≤y).
By compression of the virtual predicate ϕ(x, y, x0, y0), we mean to hide (to compress)
the variables x and y (with infinite possible values inside this rectangle) and to rep-
resent this rectangle by new compressed virtual predicate denoted by ψα(x, y, x0, y0)
where α = {x, y} is the set of compressed (hidden) variables while the set of visible
variables β is composed by two coordinates β = {x0, y0} of the center of this rectan-
gle. Thus, for this virtual predicate ϕ(x, y, x0, y0) of classic two-valued logic, we will

68
|
2 Applications of the intensional abstraction operator
denote by ϕα(x, y, x0, y0) a compressed predicate, which does not belong to classical
two-valued logic.
In fact, for any assignment g ∈𝒟𝒱, the original (flat) virtual predicate ϕ/g =
ϕ(g(x0), g(y0), g(x), g(y)) can be only true or false (thus in classical two-valued FOL),
while for the same assignment this compressed virtual predicate ϕα(x, y, x0, y0)/g =
ϕα[β/g(β)] fixes only the center of this rectangle g(β) = {g(x0), g(y0)}; other two hidden
variables x and y in α remains free variables, so that the truth value of ϕα[β/g(β)] =
ϕα(x, y, g(x0), g(y0)) (representing however this rectangle) is a function f : ℝ2 →{0, 1},
such that for any point (a, b) ∈ℝ2, f(a, b) = 1 iff this point is inside the rectangle.
So, we obtained the higher-order Herbrand interpretation for compressed predicates:
see Definition 109 in Section A.4 for the functional space T equal to (2W2)W1, where
W1 = W2 = ℝand 𝒲= W1 × W2 = ℝ2, with “truth value” f ∈T = 2𝒲so that we obtain
an infinitary many-valued logic.
Knowledge-conservative predicate compression
Let H be the Herbrand base of a database DB and P be the set of all predicate sym-
bols used in this DB. The compression of a predicate r(x), for the list of variables
x = (x1, . . . , xn), generates the new compressed predicate rα(x) in the relational schema
of compressed database, i. e., rα ∈DBcom, where α ⊆(x1, . . . , xn) is the subset of com-
pressed (hidden) attributes. Let 𝒲be the domain of the subset β ⊆(x1, . . . , xn) of visible
attributes of the parameterized predicate r(x), r ∈P, and I : H →2 be a standard two-
valued Herbrand interpretation for a database 𝒟ℬ. Then, given a knowledge invariant
higher-order interpretation IE, we will have that for any “ground” atom rα[β/g(β)] with
hidden variables in y = π−βx, we obtain that IE(rα[β/g(β)]) : 𝒲→2 is a mapping such
that for any tuple of values g(y) ∈𝒲for a given assignment g ∈𝒟𝒱, holds that
IE(rα[β/g(β)])(g(y)) = I(r(x)/g)
(2.1)
as a particular case of a general case, as shown in the next section in Proposition 9.
In order to avoid such side effect and to remain in the standard two-valued logic
also when we are using the compressed predicates for the applications that use the
constraint databases, we can use the two-valued intensional FOL as it will be shown
in what follows.
Remark. Notice that the compressed predicate rα(x) is not a simple projection πα of
the original predicate for attributes in the set β, because it contains also all hidden
attributes, and its interpretations are of higher-type: the logic values of its ground
atoms are the functions instead of the set of classic logic values in 2 = {f, t}; these
functions encapsulate the semantics of the hidden attributes. Evidently, it is not the
result of the existential quantification, i. e., rα(x)
̸= ∃αr(x), because the last remains an
ordinary 2-valued formula, while the compressed predicate has the higher-order inter-
pretations. Notice that it has no relationship with abstract interpretation of logic pro-

2.1 Predicate (de)compression transformations
|
69
grams [66], not with abstract interpretation theory [67], which are approximate (gener-
ally finite) representations of computational objects to make the problem of program
dataflow analysis tractable and where abstract interpretations define a nonstandard
semantics, which can approximate the meaning or behavior of the program in a fi-
nite way. The functional analogy with the “currying,” applicable to the functions (in
a typed λ-calculus) is only apparent: here, we are dealing with compression of pred-
icates, by the compression of its attributes, and consequently by modifying the Her-
brand base of the original logic theory.
There are numerous applications where we have to deal with the data-base com-
pression, i. e., with a kind of database transformation where a number of attributes of
its relations are hidden (compressed) but not eliminated as in the case of ordinary pro-
jections over relations: we still consider all inferential effects of all information con-
tained in a database, but with respect to the reduced number of “visible” attributes.
For example, while the variables can be used for querying a database, the hidden
attributes cannot appear in a query language formulae, but they still are present in a
query-answering process (e. g., in join operations) so that the inference power of this
transformed (compressed) database is equal to the inferential power of the original
database.
As far as we know, there is no current literature for the definition for these con-
cepts, but we needed them for the formal development of the logic theory with gen-
eral imprecise, or context sensitive information, and to show that nonstandard logic
models, often introduced ad hoc for such logic systems can be effectively reduced
to canonical standard Herbrand models, as for example, by reducing the temporal-
probabilistic logic programs into constraint logic programs [68].
2.1.1 Introduction of hidden-quantifiers for predicate logics
In what follows, we will denote by 𝒟the universe of constants for a given predicate
logic language ℒP (without quantifiers) with the set of predicate symbols in P, such
that for any pn ∈P, with n = ar(p) is the arity of this predicate, and {x1, . . . xm} is a
subset of variables in 𝒱, used for predicate attributes. We assume that each attribute
of each predicate in P has a unique variable name in 𝒱. Each variable xi ∈𝒱has a
domain of constants, D(xi) ⊆𝒟, which can be assigned to this variable.
We denote by x = ⟨x1, . . . xn⟩the (ordered) tuple (list) of variables and by D(x) the
set of tuples of constants in 𝒟given by the Cartesian product D(x1)×⋅⋅⋅×D(xn) where
xi ∈𝒱, 1 ≤i ≤n; when it is an empty tuple (list) x = 0, then we denote its domain
by a particular empty-tuple singleton ⟨⟩∈𝒟, i. e., D(0) = {⟨⟩}. By x = {x1, . . . xn},
we denote the set of variables in the tuple x, and hence we have that D(x) = {g(x) =
(g(x1), . . . , g(xn)) | g ∈𝒟X}, and we can define the basic principle of predicate com-
pression.

70
|
2 Applications of the intensional abstraction operator
Definition 23. Given a tuple of n ≥1 variables x, with its set of variables x, for any
proposed set Y ⊆𝒱of variables that we desire to compress in the tuple x, we define
α =def x ⋂Y
and
β = x −α
(2.2)
where −is set substraction, so that α ⋂β = 0 and α ⋃β = x, where:
1.
α is called the set of really obtained hidden (compressed) variables in x, while the
order-preserving tuple of these hidden variable is given by y = π−βx, so that α = y.
2.
β is called the set of visible variables in x, while the order-preserving tuple of these
visible variables is given by y1 = π−αx, so that β = y1.
3.
In order to hide a free variable xi ∈𝒱in a given tuple x, i. e., when xi ∈x, we will
use the hidden-quantifiers denoted by
(󲆆xi)x
and traduced by “there exists hidden variable xi in the tuple x”
different from the existential (∃xi) and universal quantifier (∀xi) used in FOL but
with the common property that also these new quantifiers protect their variables
from the assignments g ∈𝒟𝒱.
4.
We define the bijective permutation-mapping1 isx/α : D(x) →D(z) × D(y), such
that it divides the tuples in D(x) =def {g(x) | g ∈𝒟x} into two order-preserving
subtuples composed by visible attributes in z = π−αx and by hidden attributes in
y = π−βx. Its inverse is−1 permutes the element of a tuple in D(z) × D(y) in order
to obtain the original tuple in D(x).
For any assignment g : 𝒱→𝒟, and a tuple of variables x we will denote by g(x) the
reduction of assignment g to the subset x of variables in x, such that for any variable
xi ∈x, g(xi) ∈D(xi) ⊆𝒟. Given a predicate logic language ℒP with predicates in P and
standard (classic) logic connectives ¬, ∧, ∨and ⇒(negation, conjunction, disjunction
and implication, respectively), used to compose logic formulae, any assignment g :
𝒱→𝒟, can be extended to all formulae and terms in a standard way as explained in
Section 1.1.1. A logic theory ℒis any subset of formulae in ℒP, i. e., any ℒ⊆ℒP.
We will define a Herbrand interpretation for a logic ℒP, a mapping IH : H →2,
where 2 = {f , t} is the set of classic logic values f (false) and t (true). Notice that these
constants can be alternatively seen as constant functions f0, f1 : D(0) →2, such that
f0(⟨⟩) = f and f1(⟨⟩) = t.
Definition 24 (Extended syntax of predicate logic by hidden quantifiers). Let ℒbe the
predicate logic theory of a given predicate logic language ℒP, with P the set of its pred-
icates and 𝒱the set of all variables of predicates in P. We define the extended logic
1 These mapping are based on the fact that each domain D(v) is a ordered Cartesian product of do-
mains of single variables in v, so for the permutation of variables σ : x →z × y and its inverse
permutation σ−1 : z × y →x we have that σ ∘σ−1 and σ−1 ∘σ are identities.

2.1 Predicate (de)compression transformations
|
71
theory ℒE, such that ℒ⊆ℒE, by using the symbol of compression of variables by
hidden-quantifiers (󲆆xi)x, as follows:
1.
We can introduce a new virtual predicate denoted shortly by pα(x) ∈ℒE, for a
given atom p(x) ∈ℒwith α ⊆X = x. We will call the attributes in α as hidden
attributes, while the rest, from (2.2), β = X −α, by visible attributes. For the ho-
mogeneity, we can denote the original predicates p(x) ∈P also by p0(x), where 0
denotes empty set of hidden (compressed) variables.
2.
This compression can be extended also to any composed formula ϕ(x) ∈ℒ, so
that ϕα(x) denotes shortly a logic formula with the hidden variables in α ⊆X and
visible free variables in β = X −α, where −is set substraction.
So, in the theory ℒE we can have only the formulae of ℒ(without compression sym-
bols) or the formulae ϕα(x) with the set of hidden variables in α ⊆x. Thus, the ex-
tended logic theory ℒE has also a set of unary hidden-quantifier operators (󲆆x)x intro-
duced in point 3 of Definition 23, so that the denoted virtual predicates with set α of
hidden variables are not well-defined syntax logic forms in ℒE, but only denote the
logic formulae using the hidden-quantifier operators. That is:
a.
pα(x) denotes the well-defined syntax (󲆆xi)x . . . (󲆆xj)xp(x), where α is the set of all
variables that appear in the hidden-quantifier operators in front of the predicate
p(x), and this formal syntax can be shortened by (∏xi∈α(󲆆xi)x)p(x);
b.
ϕα(x) denotes the well-defined syntax of a composed formula ϕ with the free vari-
ables in β ⊆x and with hidden-quantifiers (󲆆xi)x with xi ∈α (where α and β satisfy
the requirements2 in Definition 23) inside this formula ϕ. The Tarski’s interpreta-
tion I∗
T of compressed predicates, for a given assignment g ∈𝒟𝒱, is given by
I∗
T ((∏
xi∈α
(󲆆xi)x)p(x)/g)
= {g′(π−βx) | g′ ∈𝒟x such that ∀xi ∈β.(g′(xi) = g(xi)) and I∗
T (p(g′(x))) = t}
(2.3)
and, by extension to all compressed formulae (having inside it the hidden quan-
tifiers) ϕα(x) ∈ℒE,
I∗
T (ϕα(x)/g)
= {g′(π−βx) | g′ ∈𝒟x such that ∀xi ∈β.(g′(xi) = g(xi)) and I∗
T (ψ(g′(x))) = t}
(2.4)
2 Hidden-quantifier (󲆆xi)x can be correctly applied only to a formula for which the ordered list (from
left to right) of its free variables (visible and hidden) is equal to the tuple x of this quantifier. Otherwise,
its application to a formula has no any effect as, e. g., if we apply the standard existential FOL quantifier
(∃xi) to a formula ψ(y) such that xi ∉y.

72
|
2 Applications of the intensional abstraction operator
where the new formula ψ(x) ∈ℒis obtained from ϕ(x) by elimination all hidden
quantifiers from it. We define also the functional space (P-space) ℱP as follows:
–
{f0, f1} ⊆ℱP, where f0, f1 : D(0) →2, such that f0(⟨⟩) = f and f1(⟨⟩) = t;
–
For each y ⊆𝒱, 2D(y) ⊆ℱP, where 2D(y) denotes the set of all functions from
the set of tuples of constants in D(y) to the set 2. The tuples y corresponds to
hidden variables of compressed predicates.
For example, the assignment g ∈𝒟𝒱applied to compressed predicate denoted by
pα(x), that is to (∏xi∈α(󲆆xi)x)p(x), written as usual by (∏xi∈α(󲆆xi)x)p(x)/g, is equal to
formula (∏xi∈α(󲆆xi)x)p[β/g(β)] where β is the set of free variables in the logic formula
(∏xi∈α(󲆆xi)x)p(x).
Remark. We will use the words compression and decompression of a predicate p(x)
for the transformation of a visible predicate’s variable into a hidden variable by using
the hidden quantifiers (󲆆xi)x, and for the transformation of a hidden variable into a
visible variable by deleting the hidden quantifiers from the composed logic formulae
that defines this virtual predicate.
In what follows, we will present a simple example, in order to render more intu-
itive arguments.
Example 7 (Constraint databases and constraint logic programming). Letusconsider,
e. g., a logic theory with a concept of “class of spheres” given by a virtual predicate
ϕ(x) with the tuple of free variables x = (x, x0, y, y0, z, z0, v) where v represents the ra-
dius, {x0, y0, z0} coordinates of center and {x, y, z} a point inside a sphere. This virtual
predicate can be given by the built-in binary predicate ≤((x−x0)2+(y−y0)2+(z−z0)2, v2),
or with common mathematical expression, (x−x0)2+(y−y0)2+(z−z0)2 ≤v2. Let us now
consider a compressed virtual predicate ϕα(x) ∈ℒE, where the set of hidden (com-
pressed) variables is α = {x, y, z} and the set of visible variables is β = {v, x0, y0, z0},
with the order-preserving tuple of hidden variables y = π−βx = (x, y, z) and the order-
preserving tuple of visible variables z = π−αx = (x0, y0, z0, v). The logic formula of this
compressed virtual predicate, by using the hidden quantifiers, is given
(󲆆x)x(󲆆y)x(󲆆z)xϕ(x),
i. e., by
(󲆆x)x(󲆆y)x(󲆆z)x ≤((x −x0)2 + (y −y0)2 + (z −z0)2, v2)
(2.5)
Then a concrete concept of sphere, fixed by an assignment g ∈𝒟𝒱, with a radius
d = g(v) and the center in (a, b, c) = g(x0, y0, z0), is given by the “ground” compressed
virtual predicate ϕα(x)/g, i. e., by ϕα[β/g(β)], logically equivalent to the ordinary pred-
icate logic formula (without hidden quantifiers) ϕ(d, x, a, y, b, z, c) with the tuple of

2.1 Predicate (de)compression transformations
|
73
bound variables in y = π−βx = (x, y, z). However, in the last formula a given assign-
ment can have effects on these variables, while in compressed virtual predicate can-
not have the effects as shown above for ϕα(x)/g, and also these variables cannot be
quantified by the existential and universal FOL quantifiers. So, the compressed virtual
predicate is a really new kind of logic formulae underlined by the explicit use of new
hidden quantifiers in (2.5).
Let us consider now the case in which we have only a 2-dimensional device for
a visualization, so that we has to fix also the value for the coordinate z in the value
g(z) of this concrete sphere defined by compressed virtual predicate ϕα(x)/g. To do
this, we need to decompress this compressed virtual predicate by reducing the hidden
variables into the set α1 = {x, y}, i. e., into tuple y1 = (x, y). Hence, in the visible set of
variables β1 = {x0, y0, z0, v, z} we have the coordinate z as well, with tuple z1 = π−αx =
(x0, y0, z, z0, v), and hence we obtain new compressed virtual predicate ϕα1(x)/g with
formal synatx
(󲆆x)x(󲆆y)xϕ(x)/g
by elimination of the hidden quantifier (󲆆z)x. This new concrete concept ϕα1(x)/g, i. e.,
ϕα1[β1/g(β1)] represents a circle obtained from the intersection of the sphere ϕα(x)/g
with the plane z = g(z), from the fact that g(β1) = g(β) ⋃{g(z)}, rendering visible also
the coordinate g(z) of this plane. So, by compression and decompression we are able
to express different geometrical objects (geometrical projections) derived from a given
class-object ϕ(x).
The meaning (sense) of compressed virtual predicates is expressed by its hidden
variables: in the case of ϕα(x)/g its meaning is the set of all points inside a concrete
sphere defined by assignment g(β), while in the case of ϕα1(x)/g its meaning is the set
of all points of the circle obtained as intersection of the previous sphere by the plane
determined by z = g(z), i. e., by assignment g(β1) = g(β) ⋃{g(z)}. Indeed, this fact will
be usefully and naturally supported by the intensional FOL introduced in Chapter 1.
The visible variables in β can be fixed by an assignment g ∈𝒟𝒱, so that for a
concrete sphere ϕα(x)/g, we obtain the visible tuple g(y) = (a, b, c, d) which in our
natural language indeed represents a sphere with radius equal to d = g(v) and with
center in (a, b, c) = (g(x0), g(y0), g(z0)), and hence just the visible variables are used
to specify the geometrical objects.
The compressed virtual predicates cannot have an ordinary Herbrand interpreta-
tion because the assignment g has no effect on the hidden variables. To explain it,
let us consider the constrained databases, without the hidden-quantifiers, so that for
the sphere we need to define a particular predicate letter p7
j ∈P, with the tuple of vari-
ables x equal to that used in the virtual predicate ϕ(x). In this case, a particular sphere
ϕα[β/g(β)] is a the simple atom p7
j (x, a, y, b, z, c, d) with the order-preserving tuple of
free variables y = (x, y, z), and to define that this atom represents a particular sphere

74
|
2 Applications of the intensional abstraction operator
with radius d and center in point (a, b, c). In the constraint database, we will use the
following constraint logic programs clause:
p7
j (x, a, y, b, z, c, d) ←C(y)
(2.6)
where x, y, z are free variables of the constraint C(y) defined by the equation (x −a)2 +
(y −b)2 + (z −c)2 ≤d2. The characteristic function of this constraint fC(y) = fC(x, y, z) :
D(y) →2, satisfies that, for any tuple of constants d = (a1, b1, c1) ∈D(y) = ℝ3, we
have that fC(d) = t iff C(d) is true in a given Herbrand interpretation IH.
Let IH : H →2 be a Herbrand interpretation of this constraint database with such
programming language clauses having the Herbrand base H (of its ground atoms),
then the part of Herbrand base H determined by this atom p7
j (x, a, y, b, z, c, d) is given
by
MH = {p7
j (a1, a, b1, b, c1, c, d) | a1, b1, c1 ∈ℝ, (a1 −a)2 + (b1 −b)2 + (c1 −c)2 ≤d2},
i. e.,
IH(p7
j (a1, a, b1, b, c1, c, d)) = t
iff
(a1 −a)2 + (b1 −b)2 + (c1 −c)2 ≤d2.
Hence, for this Herbrand interpretation IH, if we want that the compressed virtual
predicate ϕα(x)/g with the hidden variables in y represents the same sphere defined
by the Herbrand subset MH, we need a new extended interpretation IE for this com-
pressed virtual predicate with variables in y, such that IE(ϕα(x)/g) = fC(y). So, from
the fact that fC(y) ∈2D(y), it means that the new interpretation IE of compressed
predicates must be a higher-order interpretation and hence this fact will be analyzed
in the next Example 8.
2.1.2 Formal theory of the semantics of predicate compression
In this section, we will develop the formal theory for predicate compression and de-
compression. While the ordinary (noncompressed) predicates will continue to have
standard logic values in (2, ≤) with f < t, the compressed virtual predicates denoted
by pα(x) will have the higher-order logic values in ℱP.
For example, in this case, for a given assignment of free (visible) variables g ∈𝒟β,
and a given Tarski’s interpretation I∗
T of ℒ, we can assign to pα(x) the higher-order
truth value f(y) ∈ℱP, i. e., the function f (y) : D(y) →2, where y = π−βx is the tuple
of only hidden variables, such that for any tuple of constants d ∈D(y),
f (d) = t
iff
d ∈I∗
T ((∏
xi∈α
(󲆆xi)x)p[β/g(β)])
(2.7)
From the fact that we can extend the compression (to hide the variables) to any com-
posed formula ϕ(x) ∈ℒP, we need to introduce into the functional space ℱP not only

2.1 Predicate (de)compression transformations
|
75
the truth-preorder ⊑, but also the algebraic operators corresponding to standard logic
operators in a given predicate logic theory ℒand to unary hidden-quantifiers, as fol-
lows.
Proposition 8. Let us define the following preordering ⊑in ℱP, based on the truth or-
dering in the lattice (2, ≤): For any fj : D(yj) →2, fk : D(yk) →2 ∈ℱP with y = yj × y∗
k,
where y∗
k is the tuple of variables obtained from the tuple yk by eliminating from it the
variables which appear also in yj, we define the preorder:
fj ⊑fk
iff
∀g ∈𝒟Y(fj(g(yj)) ≤fk(g(yk))).
We write fj ≈fk iff fj ⊑fk and fk ⊑fj (when yj = yk then the equivalence ‘≈’ is an identity
‘=’). So, we introduce the following operators:
1.
meet operator: fj ⋏fk : D(y) →2 is a function such that ∀g ∈𝒟Y((fj ⋏fk)(g(y)) =
fj(g(yj)) ∧fk(g(yk))).
2.
join operator: fj ⋎fk : D(y) →2 is a function such that ∀g ∈𝒟Y((fj ⋎fk)(g(y)) =
fj(g(yj)) ∨fk(g(yk))).
3.
negation operator: ∼fj : D(yj) →2 such that for any g ∈𝒟𝒱, ∼fj(g(yj)) = t iff
fj(g(yj)) = f and vice versa ∼fj(g(yj)) = f iff fj(g(yj)) = t; thus, ∼: ℱP →ℱP is
antimonotonic.
4.
(fj 󴁃󴀢fk) = (∼fj ⋎fk) is a function with the Galois connection, (fm ⋏fj) ⊑fk iff
fm ⊑(fj 󴁃󴀢fk), so that (fj(yj) 󴁃󴀢fk(yk)) ≈⋎{fm(y) | fm ⋏fj ⊑fk}, is a relative
pseudo-complement.
5.
hidden-quantifier: if y1 with y1 = y ⋃{xi} preserve the variable’s ordering in x,
󲆆xi∈xf(y) = f1 : D(y1) →2
if xi ∉y ⊆x;
= f (y)
otherwise.
The resulting function f1(y1) ∈ℱP is defined by: for every g ∈𝒟𝒱,
f1(g(y1)) = f(g(y)),
(2.8)
and hence in both cases we obtain the equivalence “≈”
󲆆xi∈xf ≈f,
(2.9)
i. e., in the complete lattice ℱP, the function 󲆆xi∈x : ℱP →ℱP maps each element f ∈ℱP
into itself.
Let D(V) be the complete domain of all variables in 𝒱. The constant functions, de-
noted by 1f : D(V) →{f } ⊆2 and 1t : D(V) →{t} ⊆2, are the bottom and top values
in ℱP. So, in the p-space algebra,

76
|
2 Applications of the intensional abstraction operator
𝒜P = (ℱP, ⊑, 1f , 1t, ⋏, ⋎, ∼, 󴁃󴀢, {󲆆xi∈x})
(2.10)
hold De Morgan laws, fj ⋏fk =∼(∼fj⋎∼fk) and fj ⋎fk =∼(∼fj⋏∼fk).
Proof. We have that if fj ⊑fk then ∼fj ⊒∼fk, i. e., ∼is antimonotonic, with ∼1t = 1f
and ∼1f = 1t. For any f ∈ℱP, (f⋏∼f ) ≈1f and (f⋎∼f ) ≈1t.
For any subset S ⊆ℱP, the joins ⋎S = f : D(y) →2, where y =def ⋃{yi | fi(yi) ∈S},
such that for any assignment g, f(g(y)) = ⋎{fi(g(yi)) | fi ∈S}. Thus, ⋎S ∈ℱP, and
fj ⋏fk ≈fj iff fj ⋎fk ≈fk iff fj ⊑fk, i. e., ⋏, ⋎are meet and join operators.
It is well known that in Boolean algebras (i. e., complemented distributive lattices)
each element can be expressed as joins of a subset of atoms. For each tuple of variables
y with n = |y| ≥1, the set of n-ary atoms in ℱP is defined by
Att(n) = {fa : D(y) →2 | a ∈D(y), such that for any b ∈D(y), fa(b) = t iff a = b}
So, any element fj(y), such that fj(g(y)) = t iff g(y) ∈Rj ⊆D(y), in the algebra ℱP
can be expressed in normal form as joins of atoms, fj(y) ≈⋎{fa(y) | a ∈Rj}, with
∼fj(y) ≈⋎{fa | a ∈D(y) and a ∉Rj}.
Thus, fj(y) ⊑fk(y) iff Rj ⊆Rk, fj(y) ⋏fk(y) ≈⋎{fa ∈Att(n) | a ∈Rj ⋂Rk}, and
fj(y) ⋎fk(y) ≈⋎{fa ∈Att(n) | a ∈Rj ⋃Rk}.
Analogously, (fj(y) 󴁃󴀢fk(y)) = (∼fj(y) ⋎fk(y)) ≈⋎{fa ∈Att(n) | a ∈(D(y)/Rj) ⋃Rk} =
⋎{fa∈R | (R ⋂Rj) ⊆Rk}, so that if we define fm(y) = ⋎{fa ∈Att(n) | a ∈R}, the we obtain
the relative pseudo-complement:
(fj(y) 󴁃󴀢fk(y)) ≈⋎{fm(y) ∈ℱP | (fm ⋏fj) ⊑fk}.
Between operators 󴁃󴀢and ⋏holds the Galois connection, i. e., from the fact that for any
assignment g holds the Galois connection of the classical 2-valued logic, fm(g(ym)) ∧
fj(g(yj)) ≤fk(g(yk)) iff fm(g(ym)) ≤fj(g(yj)) ⇒fk(g(yk)), we obtain that fm ⋏fj ⊑fk iff
fm ⊑fj 󴁃󴀢fk.
The proof for the hidden quantifier, f1(y1) = 󲆆xi∈xf (y) can be shown by the follow-
ing commutative diagram. We define α = y (with xi ∈β = x −α) and α1 = y1 with
z = π−αx and z1 = π−α1x, while the bijections (permutations) isx/α and isx/α1 and their
inversions are defined in point 4 of Definition 23, and derived bijection (permutation
of variables) is0 = isx/α ∘is−1
x/α1.
Let f(y) ∈2D(y) be a result of hiding the variables y of a predicate p(x) for a fixed
Tarski’s interpretation I∗
T . See the example in (2.7) with f0(x) : D(x) →2 such that for
any for any assignment g ∈𝒟𝒱, f0(g(x)) = I∗
T (p(x)/g). We denote by fg(β)(x) the reduc-
tion of the function f0(x) into its subdomain D(x[β/g(β)]). So, f (y) = Λ(fg(β)∘is−1
x/α)(g(z))
where λ is the currying operator from lambda calculus in the commutative diagram
(A.10) in the Appendix, and by hiding also the variable xi of the same predicate p(x),
f1(y1) = Λ(fg(β) ∘is−1
x/α1)(g(z1)), we obtain the following commutative diagram:

2.1 Predicate (de)compression transformations
|
77
2D(y) × D(y)
󲆆xi∈x × in ? 2D(y1) × D(y1[xi/g(xi)])
eval
? 2
{g(z)} × D(y)
Λ(fg(β) ∘is−1
x/α) × idD(y)
?
?
is0
{g(z1)} × D(y1[xi/g(xi)])
Λ(fg(β) ∘is−1
x/α1) × idD(y1[xi/g(xi)])
?
is−1
x/α1
? D(x[β/g(β)]) ⊂D(x)
fg(β)(x)
?
pα(x)/g
(󲆆xi)xpα(x) = pα1(x)/g
p(x[β/g(β)])
(2.11)
where the right-hand side commutative diagram is an example of diagram (A.10) in
the Appendix, where eval is the application of the first argument (function) over the
second argument. The bijection in : D(y) →D(y1[xi/g(xi)]) is just an extension of the
tuple in D(y) by the value g(xi). So, from the commutativity of this diagram, we obtain
(from the arrow above in the left) f1(y1) = 󲆆xi∈x(f (y)), such that for each assignment
g′ ∈𝒟V,
f1(g′(y1[xi/g(xi)])) = f (g′(y)) = fg(β)(g′(x[β/g(β)])).
So, from the fact that it holds for any g, and hence if g = g′, we obtain finally the
definition of f1 in (2.8), such that for each g′ ∈𝒟𝒱, f1(g′(y1)) = f(g′(y)), and hence the
definition of 󲆆xi∈x(f(y)).
In the bottom row, we represented an example of logic formulae corresponding
to vertical arrows of the commutative diagram above, such that the original clas-
sic 2-valued predicate p(x[β/g(β)]) has fg(β) : D(x[β/g(β)]) →2 as a reduction of a
2-valued characteristic function for a fixed Tarski’s interpretation IT to the subdomain
D(x[β/g(β)]) of D(x); the virtual predicate pα(x) has the characteristic many-valued
function f(y) = Λ(fg(β) ∘is−1
x/α)(g(z)), while the virtual predicate pα1(x) = (󲆆xi)xpα(x)
has the characteristic many-valued function 󲆆xi∈x(f(y)) = Λ(fg(β) ∘is−1
x/α1)(g(z1)). It
explains the relationship between attribute compression for predicates in logic and
λ-abstraction Λ that determines their characteristic functions, and the relationship
between logic attribute hidden-quantifier operator (󲆆xi)x and its algebraic correspond-
ing operator 󲆆xi∈x.
Notice that when β = {xi}, and hence y1 = x with empty tuple z1 = ⟨⟩, we obtain
for the central vertical arrow in the commutative diagram the reduction of the function
Λ(fg(β) ∘is−1
x/α1) : {⟨⟩} →2D(x) such that Λ(fg(β) ∘is−1
x/α1)(⟨⟩) = fg(β).
Let inp represents the inclusion which maps the tuple of values g(x) into the tuple
g(z1) × g(y1) of D(z1) × D(y1). Then each assignment g (i. e., inp ∘g) is an equalizer
of the functions (󲆆xi∈x ∘Λ(fg(β) ∘is−1
x/α) × in) ∘is0 and Λ(fg(β) ∘is−1
x/α1) × idD(y1), graphi-
cally

78
|
2 Applications of the intensional abstraction operator
{x}
inp ∘g
? D(z1) × D(y1)
(󲆆xi∈x ∘Λ(fg(β) ∘is−1
x/α) × in) ∘is0?
Λ(fg(β) ∘is−1
x/α1) × idD(y1)
?
2D(y1) × D(y1)
It is easy show that it holds De Morgan laws.
It is easy to verify that ⊑is reflexive and transitive but not antisymmetric (fj ⊑fk
and fk ⊑fj does not imply the identity fj = fk (because generally they have different
domains), but only the isomorphism fj ≈fk). That is, for any two fj, fk ∈ℱP, from this
Proposition 8 we have that
fj ≈fk
iff
fj ⊑fk and fk ⊑fj
(2.12)
The operators ⋏and ⋎are monoidal tensors, i. e., commutative fj ⋏fk ≈fk ⋏fj, asso-
ciative fj ⋏(fk ⋏fm) = (fj ⋏fk) ⋏fm, with identity element 1t for ⋏, i. e., (1t ⋏fj = fj) and
(dually) identity element 1f for ⋎, i. e., (1f ⋎fj ≈fj).
We introduced the functional space ℱP in order to use it as a complete lattice of
“truth values” f ∈ℱP with the truth partial ordering ⊑, for the compressed predicates.
However, in order to obtain the minimal lattice of “truth values” it is more convenient
to use the quotient algebra, obtained from ℱP and the equivalence relation ≈.
Corollary 7 (Skeletal functional space). Let us define the skeletal subset of ℱP by ℱS =
{S(f) | f ∈ℱP}, with the mapping S : ℱP →ℱS, such that for any element f (x) ∈ℱP,
i. e., f : D(x) →2, the representation element of all equivalent elements in ℱP is the
function fj(V) = S(f) : D(V) →2, such that from (2.12), fj(V) ≈f (x).
Thus, for any two fj, fk ∈ℱS we have that fj ≈fk iff fj = fk (because all functions in
ℱS have the same maximal domain D(V)), and hence ℱS is a poset and complete lattice
where ⋏, ⋎are the meet and join lattice operators, respectively.
So, we have the homomorphism im : (ℱS, ⊑, ⋏, ⋎, ∼) →(D(V), ⊆, ⋂, ⋃, −), where
im : ℱS →D(V) is a mapping such that for any f ∈ℱS, im(f) = {c ∈D(V) | f (c) = t}.
Consequently, (ℱS, ⊑, 1f , 1t, ⋏, ⋎, ∼, 󴁃󴀢) is a Boolean algebra with bottom and top el-
ements 1f and 1t, respectively, such that for any two elements fj, fk ∈ℱS if fj ⊑fk and
fk ⊑fj then fj and fk are the same elements in ℱS.
Thus, the elements in ℱS of this complete distributive lattice can be used as a min-
imal set of canonical “truth values” for the compressed predicates. So, we can define
the semantics of the extended predicate logic ℒE in Definition 24 as follows.
Definition 25 (Semantics). Let I∗
T be a Tarski’s interpretation for the underlying clas-
sic predicate logic ℒwith distinct proposition letters ⊤and ⊥for the tautology and
contradiction, respectively. Consequently, for the extension of this predicate logic ℒ
by hidden-quantifiers, ℒE in Definition 24, we obtain the following syntax algebra:
𝒜E = (ℒE, ⊥, ⊤, ∧, ∨, ¬, ⇒, {(󲆆xi)x})
(2.13)

2.1 Predicate (de)compression transformations
|
79
Then IE : ℒE →ℱP is the unique extension of this Herbrand interpretation to all
formulae in ℒE and homomorphism between the syntax algebra 𝒜E and truth-space
algebra 𝒜P in (2.10), with IE(⊤) = 1t and IE(⊥) = 1f , such that for any assignment
g ∈𝒟𝒱:
[a] For any atom p(x) with (also empty) set β ⊂x and y = π−βx, we obtain the
function IE(p[β/g(β)]) : D(y) →2 such that for any assignment g′ ∈𝒟𝒱,
IE(p[β/g(β)])(g′(y)) = I∗
T (p[β/g(β)]/g′), while for the ground atoms, IE(p(x)/g) = 1t
if I∗
T (p(g(x))) = t; 1f otherwise.
[b] For any two virtual predicates ϕ(x) and ψ(x1) with y = x × x′
1 where x′
1 is the
subtuple obtained from x1 by eliminating from it all variables which appear also
in x, we have that IE(ϕ(x)/g) = 1t : D(V) →2 if I∗
T (ϕ(g(x))) = t; 1f : D(V) →2
otherwise.
Moreover, for IE(ϕ(x)) : D(x) →2 and IE(ϕ(x1)) : D(x1) →2, and any assignment
g ∈𝒟𝒱, we have:
1.
IE(ϕ(x) ∧ψ(x)1) = IE(ϕ(x)) ⋏IE(ψ(x1)) : D(y) →2, and IE((ϕ ∧ψ)/g) = IE(ϕ/g) ⋏
IE(ψ/g) ∈{1f , 1t},
2.
IE(ϕ(x) ∨ψ(x)1) = IE(ϕ(x)) ⋎IE(ψ(x1)) : D(y) →2, and IE((ϕ ∨ψ)/g) = IE(ϕ/g) ⋎
IE(ψ/g) ∈{1f , 1t},
3.
IE(ϕ(x) ⇒ψ(x)1) = IE(ϕ(x)) 󴁃󴀢IE(ψ(x1)) : D(y) →2, and IE((ϕ ⇒ψ)/g) =
IE(ϕ/g) 󴁃󴀢IE(ψ/g) ∈{1f , 1t},
4.
IE(¬ϕ(x)) =∼IE(ϕ(x)) : D(x) →2, and IE(¬ϕ/g) =∼IE(ϕ/g) ∈{1f , 1t},
5.
IE((󲆆xi)xϕα(x)/g) = 󲆆xi∈x(IE(ϕα(x)/g)) ∉{1f , 1t} for xi ∈x −α.
It is easy to see that the interpretation IE is two-valued for all ground atoms and
sentences, but it is not two-valued for the “ground” compressed virtual predicates
(having hidden quantifiers) as shown in the point 5 above. Consequently, by extend-
ing classical two-valued predicate logic ℒinto this new predicate logic ℒE with also
hidden quantifiers, from the fact that the hidden variables are not affected by variable
assignments g ∈𝒟𝒱, the compressed virtual predicate cannot be transformed into a
sentence by assignment, and hence its truth value is not two-valued. As a result, the
predicate logic ℒE with hidden quantifiers, having compressed virtual predicates, is a
many-valued logic.
Corollary 8. The extended predicate logic ℒE with hidden-quantifier operators is a
truth-functional many-valued extension of the classic 2-valued predicate logic.
Proof. The definition of the semantics for the logic operators of this logic ℒE in Defi-
nition 25 results in the fact that the many-valued interpretation IE : ℒE →ℱP is an ho-
momorphism, so that the truth-compositionality is preserved, and consequently, this
logic is truth-functional. By elimination of all hidden-quantifier operators, we obtain
the classic 2-valued predicate logic. Thus, ℒE is conservative extension of the classic
Boolean 2-valued predicate logic, and this property is preserved also by the P-space

80
|
2 Applications of the intensional abstraction operator
ℱP of algebraic (functional) truth values, which is also Boolean algebra extended by
the set of unary algebraic operators 󲆆xi∈x for hidden quantifiers (attribute compres-
sions).
It is easy to verify that IE(pα(x)/g) = IE((∏xi∈α(󲆆xi)x)p[β/g(β)]) = fk : D(y) →2,
where β = x −α and y = π−βx, such that for any assignment g′ ∈𝒟𝒱for all xi ∈β,
g′(xi) = g(xi), we obtain fk(g′(y)) = IE(p(g(x))) = IH(p(g(x))). So, we can see how
these higher-order logic values for compressed predicates are derivable from the val-
ues of ground atoms of the original (underlying) logic ℒ, in the way that compressed
predicates are knowledge invariant transformations of the original predicates. That
is, any compressed atom pα(x) of the original two-valued atom p(x) contains the
same amount of knowledge, and we can use independently any of them: the flattened
knowledge of p(x) (the set of tuples of the original atom p(x) for which this atom is
true in the Herbrand interpretation IH) is transformed into hidden knowledge of the
compressed atom pα(x) with visible attributes in β in the way that the truth values
of this atom are characteristic functions for hidden attributes (that encapsulate the
hidden knowledge). That is, compressed predicates have less visible attributes of the
original predicates, but they do not lose the information of these hidden attributes.
In the extreme case of compression pα(x) when α = x and β = 0, we obtain that
f0 =def IE(pα(x)) : D(x) →2 is the characteristic function for the predicate p(x) (see
the last vertical arrow in the commutative diagram (2.11)) under the given Herbrand
interpretation IH : H →2 obtained for a given Tarski’s interpretation I∗
T , so that
IH(p(g(x))) = t iff g(x) ∈I∗
T (p(x)).
The functional P-space constitutes the complete lattice (ℱP, ⊑, ⋏, ⋎) of logic val-
ues for the extended logic ℒE; thus, what we obtained is a kind of many-valued logic,
where the set of logic values is of higher-order type (functions).
Proposition 9 (Knowledge-conservative predicate compression). For any compressed
virtual predicate ϕα(x) in ℒP with β = x −α and y = π−βx, for any assignment g ∈𝒟𝒱it
holds that
IE(ϕα(x)/g)(g(y)) = IE(ϕ(x)/g)(g(V)) ∈2
(2.14)
where ϕ(x) is the formula obtained from the formula ϕα(x) by eliminating all hidden-
quantifier operators from it, IE(ϕα(x)/g) ∈2D(y) is a function f (y) ∈ℱP and IE(ϕ(x)/g) ∈
{1f , 1t}. That is, it holds
f (y) =def IE(ϕα(x)/g) = IE(ϕ[β/g(β)]) : D(y) →2
(2.15)
where x[β/g(β)] is the tuple obtained from the tuple of variables in x by substituting the
variables in β by the values in g(β). From the fact that the Herbrand base of ℒP is equal
to that of ℒ, the reduction of IE to this Herbrand base is equal to Herbrand interpretation

2.1 Predicate (de)compression transformations
|
81
of ℒ, IH : H →2 defined for a given Tarski’s interpretation I∗
T for each predicate p ∈P
and each g ∈𝒟𝒱with p(x)/g ∈H, by
IH(p(x)/g) = t
iff
g(x) ∈I∗
T (p(x)),
so that for compressed predicates (2.14) reduces to
IE(pα(x)/g)(g(y)) = IH(p(x)/g).
Proof. By structural induction, it holds for all formulae with one logic operator. Let us
assume that it holds for all formulae with n logic operators. So, we can prove that it
holds also for all formulae with n + 1 operators, as for the following possible cases:
1. Let ϕα(x) = ¬ψα(x), where ψα(x) is a formula with n logic operators, so for any g,
IE(ϕα(x)/g)(g(y) = IE(¬ψα(x)/g)(g(y))
=∼IE(ψα(x)/g)(g(y))
(by homomorphic property of IE)
=∼IE(ψ(x)/g)(g(V)) =
(by inductive hypothesis)
= IE(¬ψ(x)/g)(g(V)) = IE(ϕ(x)/g)(g(V)).
2. Let ϕα(x) = ψα1(x1) ∧φα2(x2), where α = α1 ⋃α2, x = x1 ⋃x2. So, for any g,
IE(ϕα(x)/g)(g(y))
= IE(ψα1(x1)/g ∧φα2(x2)/g)(g(y))
= (IE(ψα1(x1)/g) ⋏IE(φα2(x2)/g))(g(y)) =
(by homomorphic property)
= IE(ψα1(x1)/g)(g(y1)) ⋏IE(φα2(x2)/g)(g(y2)) =
(from point 1 in Proposition 8)
= IE(ψ(x1)/g)(g(V)) ⋏IE(φ(x2)/g)(g(V)) =
(by inductive hypothesis)
= IE(ψ(x1)/g ∧φ(x2)/g)(g(V)) = IE(ϕ(x)/g)(g(V)).
3. Than, as in 2, we obtain the same result if ∧substitute by ∨or implication ⇒.
4. Let f (y) =def IE(ϕα(x)/g) ∈ℱP and by by inductive hypothesis f (g(y)) = IE(ϕα(x)/
g)(g(y)) = IE(ϕ(x)/g)(g(V)). Then for xi ∈x −α, we define the function f1(y1) =def
IE((󲆆xi)xϕα(x)/g) = 󲆆xi∈xIE(ϕα(x)/g) = 󲆆xi∈x(f(y)) ∈ℱP, where y1 = y ⋃{xi}. Thus,
IE((󲆆xi)xϕα(x)/g)(g(y1)) = f1(g(y1)) = f(g(y))
(by (2.8))
= IE(ϕα(x)/g))(g(y))(g(V)) = IE(ϕ(x)/g)(g(V))
(by inductive hypothesis)
The knowledge conservation means that any adding or deleting of hidden quan-
tifiers in a given formula we obtain a logically equivalent formula: because of such

82
|
2 Applications of the intensional abstraction operator
property, we call the compression and decompression invariant operators. It is easy to
show the validity of this proposition directly from the external commutative diagram
(2.11)
2D(y) × D(y)
eval
? 2
{g(z)} × D(y)
Λ(fg(β) ∘is−1
x/α) × idD(y)
?
is−1
x/α ? D(x[β/g(β)])
fg(β)(x)
?
ϕα(x)/g
ϕ(x[β/g(β)])
(2.16)
where f(y) = IE(ϕα(x)/g) =def Λ(fg(β) ∘is−1
x/α)(g(z)) ∈2D(y) and fg(β)(x) is the reduction
of f0(x) =def IE(ϕ(x)) ∈2D(x) to subdomain D(x[β/g(β)]). Then, from the commuta-
tivity of the diagram above, we obtain that IE(ϕα(x)/g)(g(y)) = f(g(y)) = f0(g(x)) =
IE(ϕ(x))(g(x))(g(V)) = IE(ϕ(g(x)))(g(V)), i. e., we obtained (2.14). Equation (2.15) re-
sults directly from the commutativity of this diagram. In the case when β is an empty
set, then g(z) is the empty tuple ⟨⟩, so that y = x, i. e., f(x) = Λ(fg(β) ∘is−1
x/α)(⟨⟩), and
hence (2.15) reduces to f(x) = f0(x).
Example 8 (Continuation of Example 7). Thus, the higher-order interpretations IE can
be naturally obtained by the predicate compression of constrained atoms (of the con-
straint databases), and if we use this extended predicate logic language ℒE with hid-
den quantifiers, we do not need to introduce ad hoc new predicates, like that for sphere
p7
j ∈P, and we do not need the constraint logic programming clauses (2.6),
p7
j (x, a, y, b, z, c, d) ←C(y)
but it is sufficient to use the compressed virtual predicate ϕα(x), provided by the for-
mula (2.5), for a direct definition of these constraint database concepts.
This fact would introduce the higher-order interpretations IE instead of standard
two-valued interpretations, but in next section we will see how to overcome this side
effect and to remain inside the two-valued intensional FOL.
It remains to show what kind of logical connectives are the hidden-quantifiers.
Corollary 9. The hidden-quantifiers (󲆆xi)x are modal logic operators. The functional
space algebra ℱP of the truth values of the many-valued modal predicate logic ℒE is
a Galois algebra (Section A.1 in the Appendix) where each operator (function) 󲆆xi∈x :
ℱP →ℱP is a self-adjoint modal operator.

2.1 Predicate (de)compression transformations
|
83
Proof. From point 4 of Proposition 8, we obtain that “negation” operator “∼” in the
complete bounded lattice _P is just the pseudo-complement, i. e., for any fk ∈ℱP,
∼fk = fk 󴁃󴀢1f so that ℱP is a Heyting algebra.
For any function 󲆆xi∈x, corresponding to a logic hidden-quantifier (󲆆xi)x and ele-
ments of this Heyting algebra f , f1 ∈ℱP, from point 5 in Proposition 8 and 󲆆xi∈xf ≈f in
(2.9), we obtain that f ⊑f1 implies that 󲆆xi∈xf ⊑󲆆xi∈xf1, and hence 󲆆xi∈x is a monotone
function. Moreover, from (2.9) it preserves the lattice meet operation,
󲆆xi∈x1t ≈1t
and
󲆆xi∈x(f ⋏f1) ≈(󲆆xi∈xf) ⋏(󲆆xi∈xf1),
and preserves the lattice join operation,
󲆆xi∈x1f ≈1f
and
󲆆xi∈x(f ⋎f1) ≈(󲆆xi∈xf) ⋎(󲆆xi∈xf1)
so that 󲆆xi∈x is self-adjoint modal operator in Heyting algebra ℱP, and consequently,
ℱP is a Galois algebra as well.
The Galois algebra in the functional-space ℱP of the truth values of the many-
valued predicate modal logic (with hidden quantifiers as self-adjoint, universal and
existential, modal operators) ℒE is the basis for the construction of the autoreferential
Kripke where the set of explicit possible worlds 𝒲e is just the set of the elements (truth
values) of this Galois algebra, where each possible world w ∈𝒲e = ℱP is a function.
But we have seen that also in intensional FOL with modal operators (transformed from
existential and universal logic quantifiers of FOL) has as possible worlds in We the
Tarski’s interpretations, which are the functions as well. Thus, it is not a surprise that
the hidden quantifiers in predicate modal logic LE have the similar Kripke semantics
where each possible world (the truth value in many-valued ℒE) is a higher-order ele-
ment (a function). The Kripke semantics for modal hidden-quantifier operators, that
is for the modal many-valued predicate logic ℒE, has been provided, e. g., in [69], and
for interested readers in the Appendix, Definition 107 in Section A.3.4. The example of
Galois algebra with a banal self-adjoint modal operator (identity function) is provided
by Proposition 41 in the Appendix, Section A.3.3.
2.1.3 Predicate compression by intensional abstract terms: application to
constraint databases
In order to implement the compressed predicates into intensional FOL, we must ex-
plain what will be their intensional concept, obtained by intensional interpretation
I from this compressed predicate, and consequently, what is its meaning (sense) by
using Montague’s definition.
Let us consider the following attributes (variables): x1 for the name, x2 for the fore-
name, x3 for the birthday and x4 for the personal Id for the predicate student p4(x),
which denotes a set of students. Its intensional interpretation is a concept I(p4(x)) ∈

84
|
2 Applications of the intensional abstraction operator
D4, while for its compression the intensional interpretation would be I(p4
α(x)) ∈D|α|
which, e. g., if we hide the birthday and Id, i. e., with α = {x3, x4}, p4
α(x)/g is inten-
sional concept of the “student” with individual name and forname defined by g(x1)
and g(x2), relatively, we have that the intensional concept I(p4
α(x)/g) ∈D2 is different
from the general concept I(p4(x)) ∈D4. Thus, the extension of predicate logic with the
compression of attributes is a natural candidate for intensional logics.
Notice that for the intensional FOL, in the case of the complete compression of
variables of a predicate p4(x), when α = x and β is empty set of visible variables, we
would obtain that I(p4
α(x)) = I(p4(x)) is the same intensional concept, also if, it is dif-
ferent from a noncompressed predicate p(x); the compressed predicate p4
α(x) has no
free variables (all of them are bound by hidden quantifiers). This intensional iden-
tity, of elementary predicate p4(x) and its total compression p4
α(x), is required from
the knowledge conservation, and hence the extension of this compressed predicate in
any possible world (Tarski’s interpretation which is a model of Γ, I∗
T = w ∈𝒲e = IT(Γ),
of intensional FOL as specified in Section 1.3 or, equivalently, the extensionalization
function h = ℱ(w) of a compressed predicate p4
α(x)) has to be equal to the set of tuples
for which the original 2-valued predicate p(x) is true for a given Tarski’s interpreta-
tion I∗
T .
Because of that, by considering that the semantics of intensional FOL with modal
operators for existential and universal quantifiers are based on the Kripke possible
worlds that are Tarski’s interpretations, we must define what is Tarski’s interpreta-
tion of any compressed virtual predicate and then demonstrate that the many-valued
interpretation ℐE of the many-valued predicate logic ℒE with modal operators for its
hidden quantifiers can be well-defined from the Tarski’s interpretations
Proposition 10. For a given Tarski’s interpretation I∗
T , the interpretation of compressed
predicates ϕα(x) with β = x −α, for a given assignment g ∈𝒟𝒱, is defined by
I∗
T (ϕα(x)/g) =def { π−β(I∗
T (ϕ[β/g(β)])) ⊆𝒟|α|,
if β is not empty
I∗
T (ϕ(x)),
otherwise
(2.17)
where
I∗
T (ϕ[β/g(β)]) = {g′(x) | g′ ∈𝒟𝒱such that ∀xj ∈β.(g′(xj) = g(xj))
and IT(ϕ(g′(x))) = t}.
So, for general compressed virtual predicate ϕα(x) and its truth value IE(ϕα(x)/g) :
D(y) →2 where y = π−βx is the tuple of hidden variables, for each tuple of values
d ∈D(y), we obtain the following general relationship between many-valued interpre-
tation IE in Definition 25 and Tarski’s interpretation I∗
T for the compressed predicates:
IE(ϕα(x)/g)(d) = t
iff
d ∈I∗
T (ϕα(x)/g)
(2.18)

2.1 Predicate (de)compression transformations
|
85
This equation is valid also in the case when β is empty (α = x and hence y = x) when we
have no visible variables. For noncompressed virtual predicates ϕ(x) when α is empty
(i. e., without hiddenquantifiers inside this formula), we obtain for each d ∈D(x),
IE(ϕ(x))(d) = t
iff
d ∈I∗
T (ϕ(x))
(2.19)
such that for any assignment g ∈𝒟𝒱the interpretation IE of the sentence ϕ(x)/g =
ϕ(g(x)) is two-valued corresponding to its Tarski’s interpretation as specified in point
[b] of Definition 25.
So, the many-valued interpretation IE is completely defined for a given Tarski’s in-
terpretation I∗
T .
Proof. From (2.15), we have that for a fixed g′ ∈𝒟α, IE(ϕα(x)/g′) = IE(ϕ[β/g′(β)]) :
D(y) →2. Then for each g ∈𝒟𝒱, such that for all xk ∈β.(g(xk) = g′(xk)), and tuple
of values d = g(y) ∈D(y) (which does not depend on g′ from the fact that the hidden
variables in y are disjoint from the visible variables in β), from (2.14) we obtain
IE(ϕα(x)/g)(d) = IE(ϕα(x)/g)(g(y)) = IE(ϕ(g(x)))(g(V)) = t
iff
IE(ϕ(g(x))) = 1t
iff
g(x) ∈I∗
T (ϕ(x))
(from point [b] in Definition 25)
iff
d = g(y) ∈π−βI∗
T (ϕ(x))
iff
d ∈I∗
T (ϕα(x)/g)
(from (2.17)).
So, we obtained (2.18).
Notice that in the simple cases when virtual predicate ϕ(x) is just a predicate pk ∈
P, from (2.18), we obtain for each tuple of values d ∈D(y), IE(pk
α(x)/g)(d) = t iff d ∈
I∗
T (pk
α(x))/g = I∗
T (pk
α[β/g(β)]), which was introduced in (2.7).
Let us show now that for each compressed predicate in ℒE, Montague’s mean-
ing can be derived from the many-valued interpretation IE of this many-valued modal
predicate logic ℒE, and hence also the compressed predicates have intensional prop-
erties.
Lemma 1. Montague’s meaning In : ℒE →R𝒲e, where the set of possible worlds 𝒲e is
the set of Tarski’s interpretations of ℒE, for any compressed predicate ϕα(x) ∈ℒE with
β = x −α and y = π−βx, assignment g ∈𝒟𝒱and possible world w ∈𝒲e, is defined by
In(ϕα(x)/g)(w) =def {d ∈D(y) | IE(ϕα(x)/g)(d) = t}
(2.20)
Proof. From Proposition 10, we have that for each possible world (Tarski’s interpreta-
tion), I∗
T = w ∈𝒲e of the many-valued modal predicate logic ℒE, we obtain a particular
many-valued interpretation IE of ℒE, and that from (1.10) in Section 1.3, we have that
In(ϕα(x)/g)(w) = I∗
T (ϕα(x)/g), and hence from (2.18) we obtain the result in (2.20).

86
|
2 Applications of the intensional abstraction operator
So, the truth values of a given compressed predicate determine the meaning of this
compressed predicate. We also can consider that each truth value IE(ϕα(x)/g) ∈ℱP of
the compressed predicate ϕα(x)/g corresponds to Montague’s possible world (as in
the case of autoreferential Kripke semantics of many-valued logics provided in the
Appendix).
However, if we extend the intensional FOL also with compressed predicates, such
that Tarski’s interpretation of them is that given in (2.17), in that case we would obtain
as a side effect the necessity to introduce the hidden quantifiers as well. We can avoid
this side effect by using the intensional abstract operators.
Corollary 10. Each well-defined compressed virtual predicate ϕα(x) with β = x −α of
the many-valued predicate logic ℒE can be substituted by the atom A(⋖ϕ(x)⋗β
α) in the
intensional FOL with intensional abstraction operators.
Proof. From the fact that from Proposition 10 each many-valued interpretation IE of
the many-valued predicate logic ℒE can be derived from the Tarski’s interpretation I∗
T ,
it is sufficient to demonstrate that the Tarski’s interpretation of the compressed virtual
predicate ϕα(x) is identical to the Tarski’s interpretation of the atom A(⋖ϕ(x)⋗β
α), for
any given Tarski’s interpretation I∗
T .
So from (1.29) in Section 1.3.1 and (2.17) above, we obtain for any assignment g ∈
𝒟𝒱directly that I∗
T (ϕα(x)/g) = I∗
T (A(⋖ϕ(x)⋗β
α)/g). Then generally:
1.
If β is not empty, then from (2.17),
I∗
T (ϕα(x)) = ⋃{I∗
T (ϕα(x)/g) | g ∈𝒟β}
= ⋃{I∗
T (A(⋖ϕ(x)⋗β
α)/g) | g ∈𝒟β}
= I∗
T (A(⋖ϕ(x)⋗β
α))
from (1.30) in Section 1.3.1.
2.
If β is empty, then from (2.17),
I∗
T (ϕα(x)) = I∗
T (ϕ(x)) = I∗
T (A(⋖ϕ(x)⋗β
α))
from (1.29) in Section 1.3.1.
Note that in the case of the replacement of the compressed predicates by the atoms
A(⋖ϕ(x)⋗β
α), we do not need the extension of the Tarski’s interpretation for a com-
pressed predicate given by (2.17), which was necessary for the many-valued modal
predicate logic ℒE. In fact, the Tarski’s interpretation of A(⋖ϕ(x)⋗β
α) and A(⋖ϕ(x)⋗β
α/g)
are already provided for intensional FOL in Definition 17, Section 1.3.1:
I∗
T (A(⋖ϕ(x)⋗β
α)/g) =def { π−β(I∗
T (ϕ[β/g(β)])) ⊆𝒟|α|,
if β is not empty
I∗
T (ϕ(x)),
otherwise
(2.21)
and when β is not empty, I∗
T (A(⋖ϕ(x)⋗β
α)) = ⋃{I∗
T (A(⋖ϕ(x)⋗β
α)/g) | g ∈𝒟β}.

2.1 Predicate (de)compression transformations
|
87
Example 9 (Constraint databases (continuation of Example 7)). The concept of “class
of spheres” given by a virtual predicate ϕ(x) with the tuple of free variables x =
(x, x0, y, y0, z, z0, v) where v represents the radius, {x0, y0, z0} coordinates of center and
{x, y, z} a point inside a sphere. This virtual predicate is provided by the built-in binary
predicate ≤((x −x0)2 + (y −y0)2 + (z −z0)2, v2), or with a common mathematical ex-
pression, (x −x0)2 + (y −y0)2 + (z −z0)2 ≤v2. Let us now consider a compressed virtual
predicate ϕα(x) ∈ℒE, where the set of hidden (compressed) variables is α = {x, y, z}
and the set of visible variables is β = {v, x0, y0, z0}, with the order-preserving tuple of
hidden variables y = π−βx = (x, y, z) and the order-preserving tuple of visible vari-
ables z = π−αx = (x0, y0, z0, v). The logic formula of this compressed virtual predicate,
by using the hidden quantifiers, is defined in intensional FOL by A(⋖ϕ(x)⋗β
α), i. e., if
p2
j ∈P is the built-in binary predicate “≤,” by
A(⋖p2
j ((x −x0)2 + (y −y0)2 + (z −z0)2, v2)⋗β
α)
(2.22)
Then a concrete concept of sphere, fixed by an assignment g ∈𝒟𝒱, with a radius
d = g(v) and the center in (a, b, c) = g(x0, y0, z0)′′, is given by the “ground” atom
A(⋖p2
j ((x −x0)2 + (y −y0)2 + (z −z0)2, v2)⋗β
α)/g,
i. e., to the atom A(⋖p2
j ((x −a)2 + (y −b)2 + (z −c)2, d2)⋗x,y,z). Note we do not need more
of the logic-program constraint (2.6) for the definition of the semantics of these atoms,
because they are rigid concepts whose extension is equal for any Tarski’s interpreta-
tion I∗
T ∈We (and corresponding extensionalization function h = ℱ(I∗
T ) such that for
a fixed intensional interpretation I, h ∘I = I∗
T ), defined by (1.29) in Section 1.3.1,
I∗
T (A(⋖p2
j ((x −a)2 + (y −b)2 + (z −c)2, d2)⋗x,y,z))
= π−β(I∗
T (p2
j ((x −a)2 + (y −b)2 + (z −c)2, d2)))
= {(g(x), g(y), g(z)) | g ∈𝒟𝒱, IT(p2
j ((g(x) −a)
2 + (g(y) −b)
2 + (g(z) −c)
2, d2)) = t}
= {(g(x), g(y), g(z)) | g ∈𝒟𝒱, ((g(x) −a)
2 + (g(y) −b)
2 + (g(z) −c)
2) ≤d2},
which represents all (infinite) points inside this sphere with radius equal to d = g(v)
and with a center in (a, b, c)
=
(g(x0), g(y0), g(z0)). So, the intensional concept
I(A(⋖p2
j ((x −a)2 + (y −b)2 + (z −c)2, d2)⋗x,y,z)) ∈D3 is a rigid concept in intensional
FOL. The advantage is that any assignment g cannot have the effects to the hidden
variables in the atom (2.22), which remains the concept of a sphere, different from the
binary atom with two terms p2
j ((x −x0)2 + (y −y0)2 + (z −z0)2, v2), which can be only
true or false.
The utility of such conceptual organization of compressed predicates in the inten-
sional FOL, provided by the example above, is also that we can use these constraint
database concepts A(⋖ϕ(x)⋗β
α), e. g., in (2.22), also to observe the knowledge hidden

88
|
2 Applications of the intensional abstraction operator
by compressed attributes in α, in a very simple way by controlling the truth of the sen-
tences ⊲A(⋖ϕ(x)⋗β
α)/g, where “⊲” is the inverse logic operator (w. r. t. the intensional
abstraction operators) defined by (1.39) in Section 1.3.1.
It can be realized if we fix the intensional interpretation I for such sentences ⊲
A(⋖ϕ(x)⋗β
α)/g in a different way than that used for open (without any assignment g ∈
𝒟𝒱) formula ⊲A(⋖ϕ(x)⋗β
α) for which, by using (1.39) in Section 1.3.1, I(⊲A(⋖ϕ(x)⋗β
α)) =
I(ϕ(x)) ∈D|x|, that is by
I(⊲A(⋖ϕ(x)⋗β
α)/g) =def pred(g(π−βx), I(A(⋖ϕ(x)⋗β
α)/g))
(2.23)
where the new intensional operator “pred” is defined by
pred : 𝒟k × Dk →D0,
k = 1, 2, 3, . . .
(2.24)
such that for any two u1 ∈𝒟k and u ∈Dk, and an extensionalization function h,
h(pred(u1, u)) = t
iff
u1 ∈h(u)
(2.25)
so that “pred” is a predication intensional operator (i. e., the membership relation).
So, in (2.23), we have that u1 = g(π−βx) ∈Dk
−1 where k = |α|, and u = I(A(⋖ϕ(x)⋗β
α)/
g)) ∈Dk, i. e., from (1.31) in Section 1.3.1,
u = I(A(⋖ϕ(x)⋗β
α)/g) =def { I(ϕ[β/g(β)]),
if β is not empty
I(ϕ(x)),
otherwise
(2.26)
Let us now consider the case when β is not empty, so that for a given extensionalization
function h, and hence the Tarski’s interpretation I∗
T = h ∘I, we obtain from (2.26) that
h(u) = h(I(A(⋖ϕ(x)⋗β
α)/g)) = I∗
T (A(⋖ϕ(x)⋗β
α)/g), i. e., from (2.21),
h(u) = π−β(I∗
T (ϕ[β/g(β)])) ⊆𝒟|α|,
(2.27)
which is the extension of the tuples of hidden variables in α. So, if we would like that
a tuple of values d ∈𝒟|α| is an element or not of h(u) in (2.27), then we define an
assignment g′ ∈𝒟α ⋃β such that g′(π−βx) = d and for each xj ∈β, g′(xj) = g(xj), then
the question if d is in h(u), it corresponds to the truth of the membership relation:
if
u1 = g′(π−βx) ∈h(u) = h(I(A(⋖ϕ(x)⋗β
α)/g′)),
if
h(pred(u1, u)) is true,
if
h(I(⊲A(⋖ϕ(x)⋗β
α)/g′)) is true, (from (2.23))
if
I∗
T (⊲A(⋖ϕ(x)⋗β
α)/g′) is true (from I∗
T = h ∘I, Proposition 7 in Section 1.3.1).
That is, if we consider the concrete sphere in the previous example (2.22), A(⋖p2
j ((x −
x0)2+(y−y0)2+(z−z0)2, v2)⋗β
α)/g, with the tuple of hidden variables π−βx = (x, y, z) cor-
responding to the points inside this spherewithcoordinatecenter(g′(x0), g′(y0), g′(z0))

2.1 Predicate (de)compression transformations
|
89
and radius g′(v), then the question if the point d is inside this particular sphere cor-
responds to the truth of the sentence
⊲A(⋖p2
j ((x −x0)2 + (y −y0)2 + (z −z0)2, v2)⋗β
α)/g′
(2.28)
in a given Tarski’s interpretation I∗
T of the constraint database where this sphere (2.22)
is defined. Consequently, we can observe the hidden tuples of values of a compressed
predicates, by the Tarski’s truth of the sentence (2.28).
In a similar way, e. g., we can define the intersection of two different spheres, de-
fined by the sentence, where ϕ(x) is equal to atom p2
j ((x −x0)2 +(y −y0)2 +(z −z0)2, v2),
A(⋖ϕ(x)⋗β
α)/g ∧A(⋖ϕ(x)⋗β
α)/g′
for two different assignments g
̸= g′ of the class sphere, with intensional interpreta-
tion
I(A(⋖ϕ(x)⋗β
α)/g ∧A(⋖ϕ(x)⋗β
α)/g′) = conj(I(A(⋖ϕ(x)⋗β
α)/g), I(A(⋖ϕ(x)⋗β
α)/g)).
Then, for the sentence,
⊲(A(⋖ϕ(x)⋗β
α)/g ∧A(⋖ϕ(x)⋗β
α)/g′),
(2.29)
we obtain its intensional interpretation,
I(⊲(A(⋖ϕ(x)⋗β
α)/g ∧A(⋖ϕ(x)⋗β
α)/g′)) = pred(π−βx, u),
where
u = I(A(⋖ϕ(x)⋗β
α)/g ∧A(⋖ϕ(x)⋗β
α)/g′) = conj(I(A(⋖ϕ(x)⋗β
α)/g), I(A(⋖ϕ(x)⋗β
α)/g)),
and hence
h(u) = I(A(⋖ϕ(x)⋗β
α)/g) ⋂I(A(⋖ϕ(x)⋗β
α)/g)
Consequently, the answer if the point d is inside the intersection of these two spheres
is given by the truth value of the sentence (2.29) for a given Tarski’s interpretation of
the constraint database.
Thus,by using“A” atomsto define different geometricalobjects(by acompression
of different virtual predicates), and logic connectives ¬, ∧and ∨we are able to obtain
the sentence describing very complex geometrical objets, and to use the same method,
presented previously for the intersection of two spheres, to verify if some given point
is inside or outside such complex objects.
Notice that this techniques can be used also for the applications which use the
nonrigid intensional concepts obtained from the compressed virtual predicates.

90
|
2 Applications of the intensional abstraction operator
2.1.4 Invariances and symmetries in predicate compression transformations
The knowledge-conservative predicate compression transforms any given atom pk
j (x)
with the tuple (sequence) of variables x = (x1, . . . , xk) (the set of these variables is de-
noted by x = {x1, . . . , xk}) into the compressed predicate denoted by pα(x) where α ⊆x
is a non-empty subset of hidden variables, and by β = x −α we denote the remaining
subset of visible (free) variables, as specified by Definition 23 in Section 2.1.1. Based
on the Corollary 10 in Section 2.1.3, such a compressed predicate pα(x) (by using hid-
den quantifiers for the variables in α) is represented by the atom A(⋖pk
j (x)⋗β
α) in the
intensional FOL with intensional abstraction operators (1.29).
In what follows, the subtuple (preserving ordering of variables) of the tuple x
composed by all variables in β is denoted by y, while the subtuple composed by all
variables in α is denoted by z, with the bijective permutation mapping (in point 4 of
Definition 23), isx/α : D(x) →D(z) × D(y), such that it divides the tuples of constants
in D(x) =def {g(x) | g ∈𝒟x} into two order-preserving subtuples of hidden and visible
attributes.
From the fact that a predicate compression regards each single predicate, we de-
fine the category D = Sch(Gpk
j ) for a k-ary predicate pk
j , obtained from the graph Gpk
j
with unique arrow pk
j (x) : x →xX representing a nonground atom of this predicate.
Note that all variables in x are “object” variables, while xX is distinguished “metavari-
able” of logic truth values.
Thus, for any given assignment of free variables in β, g ∈𝒟β, and given Tarski’s
interpretation I∗
T of intensional FOL with abstraction operators and the special unary
predicate A(_) with semantics specified by (1.29) in Definition 18, we can express the
logic equivalence of the “ground” compressed atom A(⋖pk
j (x)⋗β
α)/g with hidden vari-
ables in α with the standard (noncompressed) atom pk
j (x[β/g(β)]) where the variables
in α remain to be free variables (exposed to logic quantification and assignments) by
using functorial models in the category of functors SetD with the same method used
in Definition 22.
Definition 26. Let, for a k-ary predicate pk
j ∈P, the category D = Sch(Gpk
j ) be obtained
from the graph Gpk
j with a unique nonground atom’s arrow pk
j (x) : x →xX. Then given
Tarski’s interpretation I∗
T and assignment g ∈𝒟β, such that z is the subtuple of x
composed by only variables in α = x −β, we can introduce the following functors:
1.
The covariant functor F(I∗
T ; g) = (F0, F1) : D →Set, a model of pk
j (x)[β/g(β)],
such that F0(xX) = 2 = {f , t} and F0(x) = D(x[β/g(β)]) is the subset of D(x) in
which all attributes in β ⊂x are fixed by assignment g. The arrow component F1
of this functor for the unique nonidentity arrow pk
j (x) : x →xX in D is defined
by the function F1(pk
j (x)) = f0 : D(x[β/g(β)]) →2, such that for each assignment
g′ : α →𝒟,

2.1 Predicate (de)compression transformations
|
91
f0(x[β/g(β), α/g′(α)]) = t
iff
g′(z) ∈I∗
T (pk
j (x)[β/g(β)])
(2.30)
2.
The covariant functor G(I∗
T ; g) = (G0, G1) : D →Set, a model of the compressed
predicate, such that G0(xX) = 2 and G0(x) = D(z). The arrow component G1 of
this functor for the unique nonidentity arrow pk
j (x) : x →xX in D is defined by the
function G1(pk
j (x)) = l : D(z) →2, such that for each assignment g′ : α →𝒟,
l(g′(z)) = t
iff
g′(z) ∈I∗
T (A(⋖pk
j (x)⋗β
α)/g)
(2.31)
Note that the function f0 in (2.30) is derived from the extension of the (standard)
atom pk
j (x)[β/g(β)] while the function l in (2.31) is derived from the extension of the
compressed atom A(⋖pk
j (x)⋗β
α)/g, and that from (1.29) for any Tarski’s interpretation
I∗
T their extension is equal (knowledge remains invariant by predicate compression),
so that for every assignment g′ ∈𝒟α, from (2.30) and (2.302) we obtain the equality
l(g′(z)) = f0(x[β/g(β), α/g′(α)])
(2.32)
The knowledge invariance of the predicate compression transformation shown in all
details in Section 2.1 can be formalized by the following.
Corollary 11. The knowledge invariance of the predicate compression transformations
is based on categorial natural isomorphism symmetry τ : F(I∗
T ; g)
󳐂? G(I∗
T ; g) of
functors (models) in Definition 26, for a given Tarski’s interpretation I∗
T and assignment
g ∈𝒟β.
Proof. Let us consider the arrow pk
j (x) : x →xX in the category D = Sch(Gpk
j ). Let
us show that the natural transformation τ applied to the arrow pk
j (d), generates the
following natural transformation diagram in Set:
A = F0(x) = D(x[β/g(β)])
τA ? D(z) = G0(x)
B = F0(xX) = 2
f0 = F1(pk
j (d))
?
τB
? 2 = G0(xX)
l = G1(pk
j (d))
?
(2.33)
where for τA is the isomorphism, such that for each k-ary tuple dn ∈D(x[β/g(β)]),
τA(dn) = π−βdn ∈D(z), and τB is an identity arrow (thus isomorphic as well) of the ob-
ject B = 2. This diagram commutes (easy to verify from (2.32) for dn = x[β/g(β), α/g′(α)]
and π−βdn = g′(z) for an assignment g′ : α →𝒟). So, all components τA are isomor-
phic arrows, and hence τ is natural isomorphism. Note that the isomorphism between
objects of a category is a general case of the categorial symmetry of the objects.

92
|
2 Applications of the intensional abstraction operator
Consequently, as we have seen previously in Section 1.3.2 for two examples of
transformation we obtained two different symmetries: for the reification transforma-
tion, we obtained the internal categorial symmetry between morphisms and objects
but not the logic knowledge invariance; for the ontological encapsulation transfor-
mation, we obtained the symmetry of morphisms of categorial duality principle (be-
tween category and its opposite category) and logic knowledge invariance (symme-
try) as well. Here, instead, for the compression predicate transformations we obtain
the symmetry of objects (the isomorphism of objects, in our case in the category of
functors).
Thus, as in the case of the laws of nature that are results of specific symmetries
expressed by partial differential equations, also in the case of computer science, some
laws of invariant knowledge transformations are the result of specific symmetries.
2.2 Nilsson’s structures and probabilistic logics
The probability theory is a well-studied branch of mathematics, in order to carry out
formal reasoning about probability. Thus, it is important to have a logic, both for com-
putation of probabilities and for reasoning about probabilities, with a well-defined
syntax and semantics. Both current approaches, based on Nilsson’s probability struc-
tures/logics, and on linear inequalities in order to reason about probabilities, have
some weak points.
In this section, we will present the complete revision of both approaches. We
have shown that the full embedding of Nilsson’s probabilistic structure into propo-
sitional logic results in a truth-functional many-valued logic, different from Nilsson’s
intuition and current considerations about propositional probabilistic logic. Then we
will show that the logic for reasoning about probabilities can be naturally embedded
into a 2-valued intensional FOL with intensional abstraction, by avoiding the cur-
rent ad hoc system composed of two different 2-valued logics: one for the classical
propositional logic at a lower-level, and a new one at a higher-level for probabilis-
tic constraints with probabilistic variables. The obtained theoretical results are then
applied to probabilistic logic programming.
The main motivation for an introduction of the intensionality in the probabilistic
theory of the propositional logic is based on the desire to have the full logical embed-
ding of the probability into the First-Order Logic (FOL), with a clear difference from the
classic concept of truth of the logic formulae and the concept of their probabilities. In
this way, we are able to replace the ad hoc syntax and semantics, used in current prac-
tice for probabilistic logic programs [14, 16, 70, 71] and probabilistic deduction [72], by
the standard syntax and semantics used for the FOL where the probabilistic theory
properties are expressed simply by the particular constraints on their interpretations
and models.

2.2 Nilsson’s structures and probabilistic logics
|
93
In this section, we will consider the probabilistic semantics for the propositional
logic (it can be easily extended to predicate logics as well) [62, 63] with a fixed finite set
P = {p1, . . . , pn} of primitive propositions, which can be thought of as corresponding to
basic probabilistic events. The set ℒ(P) of the propositional formulae is the closure of
P under the Boolean operations for conjunction and negation, ∧and ¬, i. e., it is the
set of all formulae of the propositional logic (P, {∧, ¬}).
In order to give the probabilistic semantics to such formulae, we first need to re-
view briefly the probability theory (see, e. g., [73, 74]).
Definition 27. A probability space (S, 𝒳, μ) consists of a set S, called the sample space,
a σ-algebra 𝒳of subsets of S (i. e., a set of subsets of S containing S and closed under
complementation and countable union, but not necessarily consisting of all subsets
of S) whose elements are called measurable sets, and a probability measure μ : 𝒳→
[0, 1] where [0, 1] is the closed interval of reals from 0 to 1. This mapping satisfies Kol-
mogorov axioms [75]:
A.1 μ ≥0 for all X ∈𝒳.
A.2 μ(S) = 1.
A.3 μ(⋃i≥1 Xi) = ∑i≥1 μ(Xi),
if Xi’s are nonempty pairwise disjoint members of 𝒳. We define a probability density
function, KI = μ ∘in, where in : S 󳨅→𝒫(S) is an inclusion such that in(s) = {s}.
The μ({s}) = KI(s) is the value of probability in a single point of space s.
The property A.3 is called countable additivity for the probabilities in a space S. In
the case when 𝒳is a finite set, then we can simplify property A.3 above to
A.3′ μ(X ⋃Y) = μ(X) + μ(Y),
if X and Y are disjoint members of 𝒳, or, equivalently, to the following axiom:
A.3′′ μ(X) = μ(X ⋂Y) + μ(X ⋂Y),
where Y is the compliment of Y in S, so that μ(X) = 1 −μ(X).
In what follows, we will consider only finite sample space S, so that 𝒳= 𝒫(S).
Thus, in our case of a finite set S we obtain, form A.1 and A.2, that for any X ∈𝒫(S),
μ(X) = ∑
s∈X
μ({s}) = ∑
s∈X
KI(s)
(2.34)
Based on the work of Nilsson in [62], we can define for a given propositional logic with
a finite set of primitive propositions P the sample space S = 2P, where 2 = {0, 1} ⊂[0, 1],
so that the probability space is equal to the Nilsson’s structure N = (2P, 𝒫(2P), μ).
In his work (p. 2, lines 4–6 in [62]) Nilsson considered a probabilistic logic “in
which the truth values of sentences can range between 0 and 1. The truth value of a
sentence in probabilistic logic is taken to be the probability of that sentence in ordinary

94
|
2 Applications of the intensional abstraction operator
first-order logic.” That is, he considered this logic as a kind of a many-valued, but not a
compositional truth-valued logic. But in his paper he did not define the formal syntax
and semantics for such a probabilistic logic, but only the matrix equations where the
probability of a sentence ϕ ∈ℒ(P) is the sum of the probabilities of the sets of possible
worlds (equal to the set S = 2P) in which that sentence is true. So that he assigns two
different logic values to each sentence ϕ: one is its probability value and another is a
classic 2-valued truth value in a given possible world v ∈𝒲= S = 2P.
The logic inadequacy of this seminal work [62] of Nilsson is also considered in
[76], by extending this Nilsson’s structure into a more general probability structure
M = (2P, 𝒫(2P), μ, π), where π associates with each s ∈S = 2P the truth assignment
π(s) : P →2. However, in our case when S = 2P, π is just an identity, so not necessary,
and we consider each s as a truth valuation s = v : P →{0, 1}, which can be uniquely
extended to the truth assignment v∗to all formulae in ℒ(P), by taking the usual rules of
propositional logic (the unique homomorphic extension to all formulae), and we can
associate to each propositional formula ϕ ∈ℒ(P) the set ϕM consisting of all states
s ∈S where the sentence ϕ is true, so that
‖ϕ‖ = {v ∈𝒲= 2P | v∗(ϕ) = 1}.
But, different from Nilsson, in [76] we did not define a many-valued propositional
logic, but a kind of 2-valued logic based on probabilistic constraints. They denoted
by wN(ϕ) the weight or probability of ϕ in Nilsson structure N, correspondent to the
value μ(‖ϕ‖), so that the basic probabilistic 2-valued constraint can be defined by ex-
pressions c1 ≤wN(ϕ) and wN(ϕ) ≤c2 for given constants c1, c2 ∈[0, 1]. They expected
their logic to be used for reasoning about probabilities. But, again, they did not define
a unique logic, but two different logics: one for the classical propositional logic ℒ(P),
and a new one for 2-valued probabilistic constraints obtained from the basic proba-
bilistic formulae above and Boolean operators ∧and ¬. They did not consider the in-
troduced symbol wN as a formal functional symbol for a mapping wN : ℒ(P) →[0, 1],
such that for any propositional formula ϕ ∈ℒ(P), with 𝒲= S = 2P, the probability of
sentence ϕ is
wN(ϕ) = μ(‖ϕ‖) = ∑
v∈𝒲
KI(s).
Instead of this intuitive meaning for wN, they considered each expression wN(ϕ) as
a particular probabilistic term (more precisely, as a structured probabilistic variable
over the domain of values in [0, 1]).
It seams that such a dichotomy and difficulty to have a unique 2-valued probabilis-
tic logic, both for an original propositional formulae in ℒ(P) and for the probabilistic
constraints, is based on the fact that if we consider wN as a function with one argu-
ment then it has to be formally represented as a binary predicate wN(ϕ, a) (for the

2.2 Nilsson’s structures and probabilistic logics
|
95
graph of this function) where the first argument is a formula and the second is its re-
sulting probability value. Consequently, a constraint “the probability of ϕ is less or
equal to c,” has to be formally expressed by the logic formula wN(ϕ, a)∧≤(a, c) (here
we use a symbol ≤as a built-in rigid binary predicate where ≤(a, c) is equivalent to
a ≤c), which is a second-order syntax because ϕ is a logic formula in such a uni-
fied logic language. That is, the problem of obtaining the unique logical framework
for probabilistic logic comes out with the necessity of a reification feature of this logic
language, analogously to the case of the intensional semantics for RDF data structures
[77] in Section 2.3.
Consequently, we need a logic, which is able to deal directly with reification of
logic formulae, that transforms a propositional formulae ϕ ∈ℒ(P) into an abstracted
term, denoted by ⋖ϕ⋗(Section 1.3.1). By this approach, the expression wN(⋖ϕ⋗, a)∧≤
(a, c) remains to be an ordinary first-order formula. In fact, if ⋖ϕ⋗is translated into a
nonsentence “that ϕ,” then the first-order formula above corresponds to the sentence
“the probability that ϕ is true is less than or equal to c.”
2.2.1 Probabilistic algebra for Nilsson’s structure
The work of Jan Lukasiewicz was without doubt the most influential in the develop-
ment of many-valued modal logics [78–81]. In Lukasiewicz’s conception, the real def-
inition of a logic must be semantic and truth-functional (the logic connectives are to
be truth functions operating on these logical values): “logic is the science of objects
of a specific kind, namely a science of logical values.” Many-valued logics are non-
classical logics. They are similar to classical logic because they accept the principle of
truth functionality, namely, that the truth of a compound sentence is determined by
the truth values of its component sentences (and so remains unaffected when one of
its component sentences is replaced by another sentence with the same truth value).
But they differ from classical logic by the fundamental fact that they do not restrict
the number of truth values to only two: they allow for a larger set of truth degrees.
Introduction to many-valued logic and 𝒪-matrices is provided in the dedicated chap-
ter, Section 5.1 by Definition 54. We will use the reduction of Nielsen’s many-valued
logic into 2-valued logic, by reification of sentences into a particular binary predicate
wN, by ontological encapsulation, and more information is provided in Section A.4.2
in the Appendix.
Lukasiewicz’s work promoted the concept of logic matrix, a central concept for the
construction of many-valued logics, implicit in the works of C. S. Pierce and E. Post as
well (see also the second, nonmatrix based method in Section 5.1.1 and also in Sec-
tion A.4.4 in the Appendix). We denote by ℒ(P) the set of all formulae. Lindenbaum
algebra of ℒis the quotient algebra ℒ(P)≡, where for any two formulae ϕ, ψ ∈ℒ(P),
holds the equivalence ϕ ≡ψ iff ϕ ⊪ψ and ψ ⊪ϕ. The standard approach to ma-
trices uses a subset D ⊂X of the set of truth-values X (nullary operators, i. e., logic

96
|
2 Applications of the intensional abstraction operator
constants), denominated designated elements; informally a designated element rep-
resent an equivalence class of the theorems in ℒ. Given an algebra A = (X, {o}o∈𝒪), the
𝒪-matrix is the pair (A, D), where D ⊂X is a subset of designated elements.
Any modal 2-valued logic can be considered as a many-valued truth-functional
logic for a given set 𝒲of possible worlds as well, given by a complex algebra
A+ = (X+, ⊆, {⋂, ⋃, /, m, l}) of “truth-values,” where X+ ⊆𝒫(𝒲) is the complete lattice
of “truth values” (see, e. g., the case of the autoreferential canonic representation,
with the isomorphism (5.10) in Section 5.1.2) and ⋂, ⋃, / are algebraic operations
for conjunction, disjunction and negation (i.e„ the set-intersection, set-union and
set-substraction operators), respectively, while m and l are algebraic operations for
universal and existential modal logic operators: in this approach the “truth value” of
a given sentence ϕ is equal to the subset of possible worlds ‖ϕ‖ where this formula
ϕ is satisfied, i. e., equal to {w ∈𝒲| ℳ󳀀󳨐w ϕ} ∈𝒫(𝒲) (the general case of Kripke
semantics for many-valued logics is provided by Definition 65 and Theorem 17 in
Section 5.1.2). In what follows, we set that 𝒲=def S (sample space in Definition 27).
Notice that instead of a set-based algebra A+ = (X+, ⊆, {⋂, ⋃, /, m, l}) we can use
the functional algebra (̃A, {̃⋂, ̃⋃,̃/, ̃m,̃l}) with higher order “truth values” [82, 83] given
by functions in the functional space ̃A = 2𝒮, where for each Y ∈𝒫(S) we have the
correspondent functional truth-value f ∈2S, such that for any possible world s ∈S
it holds that f(s) = 1 iff s ∈Y. For example, the function f ̃⋂g : S →2 is defined for
any s ∈S by (f ̃⋂g)(s) = min{f(s), g(s)}, while (f ̃⋃g)(s) = max{f(s), g(s)} and (̃/f )(s) =
1 −f(s).
For any function f ∈2S, we denote its image by Im(f ) = {s ∈S | f(s) = 1}, so that
Im(f ̃⋂g) = Im(f) ⋂Im(g) and im(̃/f ) = S/ Im(f). Hence, we define basic functional
algebra Af = (2S, ≤, ̃⋂,̃/), with f ≤g iff im(f) ⊆im(g), so that ̃⋂is meet lattice oper-
ation. Here we consider the possibility to have also infinite matrices for many-valued
truth-functional logics, different from other approaches that consider only finite ma-
trices [84]. In fact, based on Nilsson’s probabilistic structure N = (2P, 𝒫(2P), μ), we can
define the following many-valued probabilistic algebra.
Definition 28. Let N = (2P, 𝒫(2P), μ) be Nilsson’s structure with a sample space S = 2P.
Then we define the probabilistic algebra A = (X, ⋏, ∼) based on the complete dis-
tributive lattice (X, ≼) =def (Af × [0, 1], ≤) of truth values such that (f, x) ≼(g, y) iff
im(f) ⊆im(g) and x ≤y, with the 𝒪-matrix (A, D) where D = {(f, μ(im(f))) | f ∈2S}
is a set of designated elements. Modal binary operator p-conjunction “⋏” and unary
operator p-negation “∼” are defined as follows:
⋏((f, x), (g, y)) = { (f ̃⋂g, μ(Im(f ̃⋂g))),
if x = μ(im(f)) and y = μ(im(g))
(f ̃⋂g, 0),
otherwise
∼(f , x) = { (̃/f, μ(im(̃/f ))),
if x = μ(im(f))
(̃/f, 0),
otherwise
(2.35)

2.2 Nilsson’s structures and probabilistic logics
|
97
Notice that each truth value of this algebra is a pair of elements a = (f , x) ∈X =
2P × [0, 1]: first, a function f = π1(a) : S →{0, 1} that defines the set of possible worlds
in S where a propositional formula in ℒ(P) is satisfied, while the second element x =
π2(a) is the probability of this formula (here πi, i = 1, 2 are first and second Cartesian
projections), so that the meet and join operators of this complete distributive lattice
is defined by (f, x) ⋀(g, y) = (f ̃⋂g, min(x, y)) and (f, x) ⋁(g, y) = (f ̃⋃g, max(x, y)), rela-
tively.
The set of truth values in X is infinite, but its subset of designated elements is
finite for the finite set of propositional variables in P. Let us show that this algebra
represents a truth-functional many-valued semantics for the propositional Nilsson’s
probabilistic logic.
Proposition 11. Let A = (X, ⋏, ∼) be probabilistic algebra of Nislon’s structure N =
(2P, 𝒫(2P), μ) with a sample space S = 2P, with the X = 2S × [0, 1] and 𝒪-matrix (A, D)
given by Definition 28. Each valuation v : P →X is a mapping that assigns the logic
values to propositional variables, such that for any p ∈P,
v(p) =def (f , μ(Im(f))),
for f : S →2 such that ∀s ∈S.f(s) = s(p).
We denote by v∗: (ℒ(P), ∧, ¬) →A the unique homomorphic extension of v to all formu-
lae of the propositional logic (ℒ(P), ∧, ¬).
Then, for any propositional formula ϕ ∈ℒ(P) we have that (A, D) 󳀀󳨐a
v ϕ implies
that π2(v∗(ϕ)) is the Nilsson’s probability of ϕ. That is, a many-valued truth-functional
assignment v∗is a model for this propositional probabilistic logic.
Proof. Let us demonstrate this proposition by structural induction on formulae ϕ ∈
ℒ(P):
1. For any basic propositional formula p ∈P, we have that (A, D) 󳀀󳨐a
v p (it holds
that v(p) = (f , μ(Im(f ))) ∈D).
Let us suppose that ϕ1, ϕ2 ∈ℒ(P) satisfy this property, i. e., v∗(ϕ1) = (f, μ(Im(f))) ∈
D and v∗(ϕ2) = (g, μ(Im(g))) ∈D. Then we have the following two cases:
Case 2.1 When ϕ = ϕ1 ∧ϕ2. Then
v∗(ϕ) = v∗(ϕ1 ∧ϕ2)
= ⋏(v∗(ϕ1), v∗(ϕ2))
(from the homomorphic property)
= ⋏((f, μ(Im(f))), (g, μ(Im(g)))) = (f ̃
⋂g, μ(Im(f) ⋂Im(g)))
(from Def. 28)
= (f ̃
⋂g, μ(Im(f ̃
⋂g))) ∈D
(from f ̃⋂g ∈2S).
Case 2.2 When ϕ = ¬ϕ1. Then
v∗(ϕ) = v∗(¬ϕ1)
=∼(v∗(ϕ1))
(from homomorphic property)

98
|
2 Applications of the intensional abstraction operator
=∼(f , μ(Im(f))) = (̃/(f), μ(S/ Im(f)))
(from Definition 28)
= (̃/(f ), μ(Im(̃/(f )))) ∈D
(from ̃/(f) ∈2S).
Thus, for any ϕ ∈ℒ(P) we have that v∗(ϕ) = (f, μ(Im(f )), where f : S →2 satisfies for
any s ∈S = 2P that f(s) = 1 if s(ϕ) = 1, so that μ(Im(f )) = π2(v∗(ϕ)) is the Nilsson’s
probability of the formula ϕ. From the fact that for any ϕ ∈ℒ(P) holds that (A, D) 󳀀󳨐a
v ϕ,
we deduce that v∗is a model for this propositional probabilistic logic.
Notice that for a given propositional logic (ℒ(P), ∧, ¬) and Nilsson’s structure N =
(2P, 𝒫(2P), μ), a model v∗: (ℒ(P), ∧, ¬) →A computes the probabilities of all formulae
in ℒ(P). But there is no way for this many-valued propositional logic (ℒ(P), ∧, ¬) to rea-
son about these probabilities. Notice that this approach to probabilistic many-valued
logic demonstrate that, different from Nilsson’s remark (l.3–5, p. 72 in [62]):
“…we present a semantic generalization of ordinary first-order logic in which the truth values of
sentences can range between 0 and 1. The truth value of a sentence in probabilistic logic is taken
to be the probability of that sentence …”
The truth value of a sentence is not the probability of that sentence but the pair (f, a)
where the first element f ∈2S is a mapping from the sample space S = 2P into the set 2;
only its second component a ∈[0, 1] is the probability of that sentence. It demonstrates
that his intuition was only correct but approximative one, and hence we need this
complete and formal revision of his original intuition.
The second consequence is that, different from THE current opinion in the com-
puter science community that the probabilistic logic is not truth-functionally many-
valued logic, we demonstrated that indeed it is: the truth value of a complex sentence
is functionally dependent on the truth values of its proper subsentences, as in stan-
dard many-valued logics.
2.2.2 Probabilistic logic reasoning and intensionality
In order to reason about probabilities of the logic formulae, both of propositional logic
with sample space S = 2P or a predicate logic where P is the set of predicate symbols
and S = 2HF where HF is Herbrand base of this logic, we need a kind of 2-valued met-
alogic with reification features [85]; thus, a kind of intensional FOL with intensional
abstraction was presented in Section 1.3.1.
The intensional abstract terms are “that clauses” so that, for a logic formula ϕ(x),
“that ϕ” is denoted by the ground abstracted term ⋖ϕ(x)[β/g(β)]⋗α (if ϕ is a sentence
then both α and β are empty). Hence, the sentence “the probability that a sentence ϕ
is less then or equal to c” is expressed by the first-order logic formula wN(⋖ϕ⋗, a)∧≤
(a, c), where ≤is the binary built-in predicate with standard denotation a ≤c, while
“the probability that ϕ is equal to a” is denoted by the ground atom wN(⋖ϕ⋗, a) with
the binary predicate wN.

2.2 Nilsson’s structures and probabilistic logics
|
99
The intensional FOL with abstracted terms, with the intensional algebra in Defi-
nition 16, Section 1.3, Algint = (𝒟, f , t, Id, Truth, {conjS}S∈𝒫(ℕ2), neg, {existsn}n∈ℕ), and
extensionalization functions h ∈ℰ, are provided in Section 1.2, in the form (1.4),
h = h−1 + ∑
i≥0
hi : ∑
i≥−1
Di 󳨀→D−1 + ∑
i≥0
𝒫(𝒟i)
where h−1 : D−1 →D−1 is the identity, h0 : D0 →{f , t} assigns the truth values in {f, t},
to all propositions, and hi : Di →𝒫(𝒟i), i ≥1 assigns an extension to all concepts.
Thus, the intensions can be seen as names of an abstract or concrete entities, while
the extensions correspond to various rules that these entities play in different worlds
and we use the bijective mapping ℱ: 𝒲→ℰ(see the two-step interpretation in Def-
inition 10) as the Montague–Bealer’s isomorphism (bijection) between explicit possi-
ble worlds and the set of extensionalization functions. The Tarski-style definitions of
truth and validity for this intensional FOL language ℒis given in the customary way
in Section 1.3, so we can introduce the following probabilistic logic.
Definition 29 (Syntax). The basic intensional logic language ℒPR for probabilistic the-
ory is composed by formulae in ℒ(P), with
1.
Application dependent predicate symbols in P, where propositional symbols are
0-ary predicate symbols p0
i = pi ∈P, with I(pk
i ) ∈Dk.
2.
Binary predicate p2
3 ∈P for the weight or probabilistic function wN.
3.
Binary built-in (with constant fixed extension in each h ∈ℰ) predicate p2
2 for ≤(the
binary predicate = for identity is defined by a = b iff a ≤b and b ≤a).
4.
Two built-in ternary predicates p3
1, p3
2, denoted by ⊕and ⊙, for addition and mul-
tiplication operations +, ⋅, respectively, as required for a logic for reasoning about
probabilities [63].
The 0-ary functional symbols a, b, c, . . . in this logic language will be used as numeric
constants for denotation of probabilities in [0, 1].
Thus, in the case of propositional logic, the extensionalization functions will be
reduced to the mappings h = h−1 + h0 + h2 + h3.
We recall that in intensional FOL each n-ary functional symbol is represented by
the (n + 1)-ary predicate letter, where the last attribute is introduced for the resulting
values of such a function. For example, the first attribute of the predicate letter wN will
contain the intensional abstract of a propositional formula in ℒ(P), while the second
place will contain the probabilistic value in the interval of reals [0, 1] ⊂D−1, so that
the ground atom wN(⋖ϕ⋗, a) in ℒPR will have the interpretation I(wN(⋖ϕ⋗, a)) ∈D0.
Analogously, for the ground atom ⊕(a, b, c), with a, b, c ∈D−1 real numbers, we
have that I(⊕(a, b, c)) ∈D0 such that for any h ∈ℰwe have that h(I(⊕(a, b, c))) = t
iff a + b = c. For the addition of more than two elements in this intensional logic
we will use intensional abstract, e. g., for the sum of three elements we can use a

100
|
2 Applications of the intensional abstraction operator
ground formula ⊕(a, b, d)∧⊕(d, c, e), such that it holds that h(I(⊕(a, b, d)∧⊕(d, b, c))) =
conj(I(⊕(a, b, d)), I(⊕(d, c, e))) = t iff a + b = d and d + c = e, i. e., iff a + b + c = e.
The fixed extensions of the two built-in ternary predicates ⊕(x, y, z) and ⊙(x, y, z)
are
R⊕= {(u1, u2, u1 + u2) | u1, u2 ∈D−1 are real numbers},
R⊙= {(u1, u2, u1 ⋅u2) | u1, u2 ∈D−1 are real numbers}
Notice that in the case of the intuitionistic FOL with a fixed intensional interpreta-
tion I, instead of probabilistic structure N = (2P, 𝒫(2P), μ) where P in this case is the
Herbrand base, we can use instead of possible worlds v ∈𝒲= 2P the possible worlds
h ∈𝒲= ℰ, from the fact that for each extensionalization function h, the valuation
v ∈2P is derivable from h as follows: for each ground atom in the Herbrand base A ∈P,
v(A) =def h(I(A))
so in the case of intensional FOL as set of possible worlds (Nilsson’s sample space)
we will take the set of extensionalization functions ℰ, and hence we can define the
satisfaction for the binary predicate wN as follows.
Definition 30 (Semantics). Intensional FOL ℒPR is a probabilistic logic with a Nils-
son’s structure N = (ℰ, 𝒫(ℰ), μ) if, for a fixed intensional interpretation I, satisfy the
following property for any formula ϕ ∈ℒ(P) and assignment g such that ‖ϕ/g‖ = {h∘I |
h ∈ℰand h(I(ϕ/g)) = t} is a subset of possible worlds 𝒲e in (1.9):
h(I(wN(g∗(⋖ϕ⋗β
α), a))) = t
iff
a =
∑
h′∘I∈‖ϕ/g‖
KI(h′ ∘I)
(2.36)
Thus, for the most simple linear inequality, “the probability that ϕ/g is less
then or equal to c,” expressed by the formula wN(⋖ϕ/g⋗, a)∧≤(a, c), is true iff
h(I(wN(⋖ϕ/g⋗, a)∧≤(a, c))) = t and a ≤c.
Similar to the results obtained for a logic for reasoning about probabilities in [63],
we obtain the following property.
Theorem 2. The intensional FOL ℒPR with binary predicate wN defined in Definition 30,
the built-in binary predicate ≤and ternary built-in predicates ⊕and ⊙is sound and com-
plete with respect to the measurable probability structures.
Proof. We will follow the demonstration analogous to the demonstration of Theo-
rem 2.2 in [63] for the sound and complete axiomatization of the axiomatic system
AXMEAS for logic reasoning about probabilities, divided into three parts, which deal re-
spectively with propositional reasoning, reasoning about linear inequalities and rea-
soning about probabilities:

2.2 Nilsson’s structures and probabilistic logics
|
101
1.
Propositional reasoning: the set of all instances of propositional tautologies, with
unique inference rule modus ponens.
2.
Reasoning about linear inequalities: the set of all instances of valid formulae
about linear inequalities of the form a1 ⋅x1 + ⋅⋅⋅+ ak ⋅xk ≤c, where a1, . . . , ak and
c are integers with k ≥1, while x1, . . . , xk are probabilistic variables.
3.
Reasoning about probability function wN in [63] (here transformed into the binary
predicate as it is done for all functional symbols in intensional FOL), such that
a = wN(ϕ/g) iff h(I(wN(g∗(⋖ϕ⋗β
α), a))) = t:
3.1 wN(ϕ/g) ≥0 (nonnegativity)
3.2 wN(true) = 1 (the probability of the event true is 1)
3.3 wN((ϕ ∧ψ)/g) + wN((ϕ ∧¬ψ)/g) = wN(ϕ/g) (additivity)
3.4 wN(ϕ/) = wN(ψ/g) if ϕ ≡ψ (distributivity).
It is easy to verify that for any axiom ϕ/g, we have that for all “worlds” h∘I ∈𝒲e it holds
that h(I(ϕ/g)) = t, so that it is true in the S5 Kripke model of the minimal intensional
FOL given in Definition 15 (Section 1.3) where 𝒲e = IT(Γ) is the set of explicit possible
worlds (here is the set of Tarski’s interpretation of FOL ℒPR) have bijection with ℰ(for
a fixed intensional interpretation I, from the two-step interpretation, for each h ∈ℰwe
have a unique I∗
T = h∘I ∈𝒲e), because all algebraic operationsin Algint inDefinition 16
(Section 1.3) are defined in order to satisfy standard propositional logic. Moreover, the
modus ponens rule is satisfied in every “world” h ∘I ∈𝒲e. Thus, the point 1 above is
satisfied by intensional logic ℒPR.
The definition of built-in predicates ⊙, ⊕and ≤satisfy all linear inequalities, thus
the point 2 above.
The definition of binary predicate wN(x, y) is given in order to satisfy Nilsson’s
probability structure, thus all properties of probability function in the point 3 above
are satisfied by wN(x, y) built-in predicate in every “world” h ∘I ∈𝒲e. Consequently,
the soundness and completeness of the intensional logic ℒPR with respect to measur-
able probability structures, based on Theorem 2.2 in [63] is satisfied.
For example, the satisfaction of the linear inequality a1⋅x1+a2⋅x2 ≤c, where x1 and
x2 are the probabilities of the sentences ϕ1 and ϕ2 relatively, (here the list of quantifi-
cations (∃x1) . . . (∃xk) is abbreviated by (∃x1, . . . , xk)), expressed by the following FOL
intensional formula:
(∃x1, x2, x3, x4, x5)(wN(⋖ϕ1⋗, x1) ∧wN(⋖ϕ2⋗, x2) ∧⊙(a1, x1, x3) ∧⊙(a2, x2, x4)
∧⊕(x3, x4, x5)∧≤(x5, c)),
is true iff
u1 =
∑
h∘I∈‖ϕ1‖
KI(h ∘I),
u2 =
∑
h∘I∈‖ϕ2‖
KI(h ∘I),
(I(a1), u1, v1), (I(a2), u2, v2) ∈R⊙, (v1, v2, v3) ∈R⊕and v3 ≤I(c),
where u1, u2, v1, . . . , v3 ∈D−1 are real numbers.

102
|
2 Applications of the intensional abstraction operator
Analogously, the satisfaction of any linear inequality a1 ⋅x1 +⋅⋅⋅+ak ⋅xk ≤c, where
xi are the probabilities of the propositional formulae ϕi for i = 1, . . . , k, k ≥2, can be
expressed by the logic formula
(∃x1, . . . , x3k)(wN(⋖ϕ1⋗, x1) ∧⋅⋅⋅∧wN(⋖ϕk⋗, xk)
∧⊙(a1, x1, xk+1) ∧⋅⋅⋅∧⊙(ak, xk, x2k) ∧⊕(0, xk+1, x2k+1)
∧⊕(x2k+1, xk+2, x2k+2) ∧⋅⋅⋅∧⊕(x2k−1, x2k, x3k)∧≤(x3k, c)).
Based on Theorem 2.9 in [63], we can conclude that the problem of deciding whether
such an intensional formula in ℒPR is satisfiable in a measurable probability structure
of Nilsson is NP-complete.
2.2.3 Application to probabilistic logic programs
The semantics of the interval-based Probabilistic Logic Programs (PLP), based on pos-
sible worlds with the fixed-point semantics for such programs [70], has been consid-
ered valid for more than 13 years. But in 2005, when I worked with Professor V. S. Sub-
rahmanian, Director of the UMIACS Institute, I had the opportunity to consider the
general problems of (temporal) probabilistic databases [15], to analyze their seman-
tics of interval-based probabilistic logic programs and to realize that unfortunately it
was not correctly defined.3
Because of that, I formally developed, in [68], the reduction of (temporal) proba-
bilistic databases into constraint logic programs. Consequently, it was possible to ap-
ply the interval PSAT in order to find the models of such interval-based probabilistic
programs, as presented and compared with other approaches in [16]. Moreover, in this
complete revision, presented in Section A.4.1 in the Appendix, it was demonstrated
that the temporal-probabilistic logic programs can be reduced into the particular case
of the ordinary probabilistic logic programs, so that our application of intensional se-
mantics can apply only to this last general case of logic programs.
In what follows, I will briefly introduce the syntax of probabilistic logic programs
(see also the introduction of Section A.4 in the Appendix). More about it can be found
in the original work in [70] and in its last revision in [16]. Let ground(PL) denote the
set of all ground instances of rules of a probabilistic logic program PL with a given
domain for object variables, and let H denote the Herbrand base of this program PL.
3 This application of intensional FOL theory provided by this book, I formalized during my J1 visa
post-doc work at UMIACS. After my examination of fixpoint semantics of PLP (a background for work
on TP-databases and resolution of complex algebraic problems of aggregations for such databases,
that was my primary goal) and invitation to correct his for long time erroneous fixpoint semantics of
PLP in order to publish this revision together, hi began to use his notorious relationships with con-
ference’s committees with requests to do not accept any my research paper. Anyway, I published two
good papers with him [14, 15], before leaving UMIACS. But after his decision, obviously, I could not
use any recommendation letter for my professionally successful work at College Park University.

2.2 Nilsson’s structures and probabilistic logics
|
103
Then each ground instance of rules in ground(PL) has the following syntax:
A : γ0 ←ϕ1 : γ1 ∧⋅⋅⋅∧ϕm : γm
(2.37)
where A ∈H is a ground atom in a Herbrand base H, ϕi, i ≥1 are logic formulae
composed by ground atoms and standard logic connectives ∧and ¬, while γi = (bi, ci),
i ≥0, where bi, ci ∈[0, 1], are the lower and upper probability boundaries.
The expression ϕi : γi is a probabilistic-annotated (p-annotated) basic formula,
which is true if the probability xi of the ground formula ϕi is between bi and ci; false
otherwise. Thus, this basic p-annotated formula is the particular case of the 2-valued
probabilistic formula:
(1 ⋅xi ≥ai) ∧(1 ⋅xi ≤bi)
(2.38)
composed by two linear inequalities.
Consequently, the standard logic embedding of annotated interval-based logic
programs can be easily obtained by the intensional logic ℒPR described in Section 2.2.2
where P is equal to the Herbrand base H of the annotated interval-based probabilistic
logic program PL.
Thus, based on the translation (2.38), the logic formula in intensional logic ℒPR
correspondent to basic annotated formula ϕi : γi of the annotated logic program
ground(PL) is equal to the following first-order closed formulae with a variable xi:
∃xi(wN(⋖ϕi⋗, xi)∧≤(bi, xi)∧≤(xi, ci))
(2.39)
Based on this translation, the rule (2.37) of the annotated logic program ground(PL)
can be replaced by the following rule of an intensional probabilistic logic program:
∃x0(wN(⋖A⋗, x0)∧≤(b0, x0)∧≤(x0, c0))
←∃x1(wN(⋖ϕ1⋗, x1)∧≤(b1, x1)∧≤(x1, c1))
∧⋅⋅⋅∧∃xm(wN(⋖ϕm⋗, xm)∧≤(bm, xm)∧≤(xm, cm)),
with the variables x0, x1, . . . , xm.
In this way, we obtain a grounded intensional probabilistic logic program PPR,
which has both the syntax and semantics different from the original annotated prob-
abilistic logic program ground(PL).
As an alternative to this full intensional embedding of the annotated logic pro-
grams into the first-order intensional logic, we can use a partial embedding by pre-
serving the old ad hoc annotated syntax of the probabilistic program ground(PL), by
extending the standard predicate-based syntax of the intensional FOL logic with an-
notated formulae and by defining only the new intensional interpretation I for these
annotated formulae, as follows:

104
|
2 Applications of the intensional abstraction operator
I(ϕi : γi) = I((∃x)(wN(⋖ϕi⋗, x)) ∧(≤(bi, x)∧≤(x, ci)))
= exist(conj{(1,1)}(I(wN(⋖ϕi⋗, x)), conj{(1,1)}(I(≤(bi, x)), I(≤(x, ci))))),
where I(wN(⋖ϕi⋗, x)), I(≤(bi, x)), I(≤(x, ci)) ∈D1.
So that h(I(ϕi : γi)) = t iff h(exist(u1)) = t, where
u1 = conj{(1,1)}(I(wN(⋖ϕi⋗, x)), conj{(1,1)}(I(≤(bi, x)), I(≤(x, ci)))) ∈D1,
iff
∃a(a ∈h(u1)) iff h(I(bi)) ≤a ≤h(I(ci)),
where a ∈[0, 1] ⊂D−1 is a particular value (probability of ϕi) of the variable x.
Notice that, from the Appendix and the fact that u1 ∈D1,
h(exist(u1)) = f⟨⟩(h(I(wN(⋖ϕi⋗, x))) ⋈{(1,1)} (h(I(≤(bi, x))) ⋈{(1,1)} h(I(≤(x, ci)))))
= f⟨⟩(h(I(wN(⋖ϕi⋗, x))) ⋂h(I(≤(bi, x))) ⋂h(I(≤(x, ci)))),
where f⟨⟩(R) = f if R = 0;
t otherwise.
The advantage of this second, partial embedding is that we can preserve the old
syntax for (temporal) probabilistic logic programs [16, 70], but providing to them the
standard intensional FOL semantics instead of current ad hoc semantics for such a
kind of logic programs.
There are two consequences of this full and natural embedding of the probability
theory in a logic:
1.
The full embedding of Nilsson’s probabilistic structure into propositional logic
results in a truth-functional many-valued logic, different from Nilsson’s intuition
and current considerations about propositional probabilistic logic.
2.
The logic for reasoning about probabilities can be embedded into an intensional
FOL that remains to be 2-valued logic, both for propositional formulae in ℒ(P) and
predicate formulae for probability constraints, based on the binary built-in predi-
cate ≤and binary predicate wN used for the probability function, where the basic
propositional letters in P are formally considered as nullary predicate symbols.
The intensional FOL for reasoning about probabilities is obtained by the particular
fusion of the intensional algebra (analogously to Bealer’s approach) and Montague’s
possible-worlds modal logic for the semantics of the natural language.
In this work, we enriched such a logic framework by a number of built-in binary
and ternary predicates, which can be used to define the basic set of probability in-
equalities and to render the probability weight function wN an explicit object in this
logic language. We conclude that this intensional FOL logic with intensional abstrac-
tion is a good candidate language for specification of probabilistic logic programs,
and we apply two different approaches: the first one is obtained by the translation of
the annotated syntax of current logic programs into this intensional FOL; the second
one, instead, modifies only the semantics of these logic programs by preserving their
current ad hoc annotated syntax.

2.2 Nilsson’s structures and probabilistic logics
|
105
2.2.4 Application to temporal-probabilistic databases
There are numerous applications where we have to deal with temporal uncertainty as-
sociated with events. We assume that every event occurs at a point in time. An instant
(time point or chronon) t is specified w. r. t. a given time granularity of a linear calen-
dar structure Sτ; for example, “day/month/year.” Often, however, we do not know the
exact time point; instead, we only know that the instant is located sometime during a
time interval. We call such an instant an indeterminate instant [86].
The Temporal Probabilistic (TP) database management systems should provide
support for valid-time indeterminacy of events, by proposing the concept of an inde-
terminate instant, i. e., an interval of time-points (event’s time-window) with an asso-
ciated, lower and upper, probability distribution. In particular, users should be able
to control, via query language constructs, the amount of temporal/probability approx-
imation present in derived information.
Basic notions about TP Logic programs and concepts are provided in Section A.4.1
in the Appendix. Moreover, it has presented [68] a new, equivalent to the denotational
specification, the logic specification of TP-databases as constraint databases (in Sec-
tion 2.1 we provide more details): The TP-database can be seen as a deductive database
with incomplete information, and consequently, with a number of possible Herbrand
models.
We can see the approximate (uncertain) information as some kind of relativiza-
tion of truth values for sentences also: Let H be a Herbrand base for a logic program,
which handles the uncertain information and rj(d) an event (ground atom) in Ev ⊂H,
which defines some particular event in time for which we have only an approximated
information when it happened. Thus, this atom rj(d) is not longer absolutely true or
false, but its truth depends on the approximate temporal information about this fact:
in some time points, it can be true, in others, it can be false. If we consider such tem-
poral approximation as a context for this ground fact rj(d) ∈H, then we obtain that
the truth of rj(d) is a function depending on the time. That is, they have a higher-order
type of truth constants (as explained in Section 2.1), and such context sensitive ap-
plications, with higher-order Herbrand models, can be transformed (i. e., flattened) to
logic theories with basic (ordinary) Herbrand interpretations, by enlarging the orig-
inal predicates with new attributes for the properties of the context: in this way, the
context becomes a part of the language of the logic theory, i. e., it becomes visible. Con-
sequently, in this case of TP databases, the original event expressed by a ground atom
rj(d) ∈Ev (of k-ary predicate rj) in higher-order Herbrand base H, will be flattened into
new flattened atoms (with flattened Herbrand base HF) by
rj(d) 󳨃→rT
j (d, y, Lj ⋅z, Uj ⋅z, z1)
(2.40)
where y is a time variable of the calendar, the real numbers Lj, Uj ∈[0, 1] with Lj ≤Uj
are lower and upper boundaries for the probability and z is variable for reals in [0, 1],

106
|
2 Applications of the intensional abstraction operator
and z1 is probability-variable. So, this new “flattened” predicate rT
j has k +3 attributes
where first k = |d| attributes are that of the original event’s predicate rj.
Note that in such a flattening, introduced in [68] (in Section 3, constraint logic
programs for TP-databases), we have the probability attribute directly in the flattened
event’s atoms, so we are able to reason about probabilities without introducing the
binary predicate wN as in previous sections.
Consequently, by using the temporal constraints C(y) of Definition 113 in Sec-
tion A.4.1 in the Appendix, and the built-in function δj = δ(rj(d)) : Sτ →[0, 1] (ob-
tained from mapping δ : Ev →[0, 1]Sτ for a given set of events Ev ⊂H, which is a sub-
set of higher-order Herbrand base) associated to this event rj(d) ∈Ev, the constraint
TP database uses the following constraint logic program clauses, analog to (2.6) in
Example 7 in Section 2.1.1, for each event rj(d) and by using the exclusive existential
quantifier (∃!) quantifier (“there exist a unique value such that”),
(∃!z1)rT
j (d, y, Lj ⋅z, Uj ⋅z, z1) ←C(y) ∧δj(y, z)
(2.41)
where a free variable is only the time-variable y used in constraint C(y), and δj(y, z)
is a graph representation of the built-in function δj (each functional symbol repre-
sented an intensional FOL as a predicate) where z is the result of function for the
argument y. The exclusive existential quantifier used for the probability express the
fact that, for a given Tarski’s interpretation I∗
T = h ∘I (for a fixed intensional in-
terpretation I), for any assignment g such that the C(g(y)) is true, from this clause
also the sentence (∃!z1)rT
j (d, g(y), Lj ⋅g(z), Uj ⋅(z), z1) must be true. Hence, there is ex-
actly one value a ∈[0, 1] for which the ground atom rT
j (d, g(y), Lj ⋅g(z), Uj ⋅(z), a) is
true for this interpretation I∗
T , corresponding to the fact that in a given time instance
ti = g(y) ∈sol(C(y)) = I∗
T (C(y)) this event rj(d) can have exactly one value a of its
probability.
We recall that this exclusive existential quantifier can be expressed by a formula
with only standard logic quantifiers, that is a sentence (∃!x)ψ(x) is logically equivalent
to the FOL formula (∃x)(ψ(x) ∧(∀x1)((x1 = x) ∨¬ψ(x1))).
Note that in the left-hand side of the logic clause (2.41) it was necessary to trans-
form the probability argument z1 into a bound variable in order to render impossibility
to assign the value to such probability variable a value by using the logic clauses. We
recall that the probabilistic value can be obtained only from Nilsson’s structure, and
not assigned by using the logic expression.
Remark. In the simplest case, we can assume that δi is a constant function such that
for each ti ∈Sτ, δj(ti) = 1, so that for each event rj(d) ∈Ev the uncertainty interval
is constant in time and equal to [Lj, Uj] ⊆[0, 1], as it is used in TP logic programs in
(2.37) in Section 2.2.3.
Let ϕ be the formula (∃!z1)rT
j (x, y, Lj ⋅z, Uj ⋅z, z1) with also free variables x =
(x1, . . . , xk), the tuple of variables of predicate rj of the event, and we denote by ϕ/g

2.2 Nilsson’s structures and probabilistic logics
|
107
the sentence obtained with assignment g ∈𝒟β for β = {x1, . . . , xk, y, z}, so that ϕ/g is
equal to the ground atom (∃!z1)rT
j (d, ti, Lt, Ut, z1) with d = g∗(x), ti = g(y), Lt = Lj ⋅δj(ti)
and Ut = Uj ⋅δj(ti), and we define the set of worlds (for a fixed intensional interpreta-
tion I),
‖ϕ/g‖ =def {h′ ∘I ∈𝒲e | h′(I(ϕ/g)) = t}
= {h′ ∘I ∈𝒲e | h′(I((∃!z1)rT
j (d, ti, Lt, Ut, z1))) = t}
so that from the clause (2.41), we obtain that
‖ϕ/g‖ = {h′ ∘I ∈𝒲e | h′(I(C(ti))) = t} ⊆𝒲e
(2.42)
In order to involve the probability as an argument for the probabilistic reasoning by
using the Nilsson’s semantics of the probabilistic logic (2.36) in Definition 30, with the
introduction of binary predicate wN, we can use the correspondence of the formula ϕ,
equal to (∃!z1)rT
j (x, y, Lj ⋅z, Uj ⋅z, z1), with the abstracted term ⋖rT
j (x, y, Lj ⋅z, Uj ⋅z, z1)⋗β
z1.
So, for a given possible world I∗
T = h ∘I ∈𝒲e, from (2.36) we obtain
h(I(wN(⋖rT
j (x, y, Lj ⋅z, Uj ⋅z, z1)⋗β
z1, z1)/g))
= h(I(wN(⋖rT
j (d, ti, Lt, Ut, z1⋗z1, g(z1))))) = t
iff
a = g(z1) =
∑
h′∘I∈‖ϕ/g‖
KI(h′ ∘I)
(2.43)
so that a = g(z1) is the probability of this event in the time-point ti = g(y) w. r. t. the
interpretation I∗
T = h ∘I ∈‖ϕ/g‖.
Thus, by introduction of the flattened predicate rT
j for the events, we are able to
reason about the probabilities of the temporal events in the TP-database. So, for the
case provided previously, we are able to express the satisfaction of the constraints for
the events in this TP-database by the truth of the followingsentencefor the assignment
g : {x1, . . . , xk, y, z, z1} →𝒟:
(rT
j (x, y, Lj ⋅z, Uj ⋅z, z1) ∧(Lj ⋅z ≤z1 ≤Uj ⋅z))/g,
(2.44)
which tells that the event rj(x)/g ∈Ev at time-point ti = g(y) has the probability a =
g(z1), in accordance with the constraints defined in the TP-database.
From the fact that I∗
T = h ∘i ∈‖ϕ/g‖ from the definition of ‖ϕ/g‖, we have that for
this interpretation I∗
T the sentence (∃!z1)rT
j (d, ti, Lt, Ut, z1) is true, and there is a unique
value a for quantified variable z1 such that
I∗
T (rT
j (d, ti, Lt, Ut, a)) = h(I(rT
j (d, ti, Lt, Ut, a))) = t
(2.45)
where, from (2.43), the value a is just the probability of this event in the time-point
ti as we intended. Thus, the extension of flattened predicate rT
j for Tarski’s interpre-

108
|
2 Applications of the intensional abstraction operator
tation I∗
T = h ∘I is the relation R = IT(rT
j ) ⊆𝒟k+4 composed by all events expressed
by this predicate and their probabilities in time, as it is required by the relations of
PT-databases. Consequently, it is enough to materialize only the relations of the flat-
tened predicates pT
j in the TP-databases (without using the binary relation wN), in
order to be able, by simple standard SQL expressions, to reason about the probabili-
ties of the events saved in relations of this TP-database. In this way, our materialized
TP-database is a standard RDB, and we used intensional FOL only for the embedding
of Nilsson’s probabilistic structure this intensional FOL and able to compute the prob-
abilities (2.43) of the events over possible worlds I∗
T = h ∘I ∈𝒲e.
Consequently, if the mathematical structure of “TP-tuples,” tp = (d, γ) analyzed
previously [68], can be seen as a denotational specification of events, then the con-
straint logic programs with clauses (2.41) defined in intensional FOL can be seen as a
declarative logical specification of events: so, we move from mathematical (algebraic)
toward logical semantics of databases for events, based on the classical two-valued
Herbrand models.
Such logic point of view can be useful for considering reasoning capabilities of
event-based databases, for data-integration semantics when we integrate two or more
event-based databases into one global virtual event-based database, for the logic def-
inition of query language (as in relational database: duality between SQL predicate-
logic language and relational algebra), etc.
In [86] is presented a syntactic extension to SQL, needed to support valid time
indeterminacy, and its operational semantic extension to ordinary SQL. In another
approach [87], based on the extension of probabilistic databases with time dimension
(Probabilistic Temporal Databases, or shortly TP-databases), is defined as a relational
algebra extension that integrates both time and probabilities: such algebra supports
also the partial probabilistic distribution for events. In this work, was shown how the
PDM can be modified to support temporal indeterminacy, even if there might be sev-
eral million elements in a set of possible chronons: it is obtained by passing from ex-
plicit (annotated) classical relations to implicit representation of events (called also
TP-relations) and executing the “implicit” algebra operations directly over such rep-
resentation.
The advantage of the logical point of view for a TP-database, provided in this
section, is that it can be easily integrated with an ordinary deductive database. By
adding to TP-database the set of clauses for ordinary database relations (which are
not event-based relations), we obtain a unique deductive logic theory where we inte-
grate the ordinary database relations with also temporal/probability event-based re-
lations. Another advantage is that we can also define a logic theory for integration of
different TP-mixed-databases, based on views, as in ordinary GLAV (Global and Lo-
cal As View) data integration systems. Based on the set of Herbrand models for such
logic programs, we can define [68] the event-based modal logic language and the set
of Kripke models, which define the semantics for it. Such modal language may be seen

2.3 Semantic WEB applications
|
109
as an epistemic extension of temporal logics, and can be used as basis for definition
of the high-level SQL-like query language for TP-databases also.
2.3 Semantic WEB applications
The notion of ontology has become widespread in fields such as intelligent informa-
tion integration, cooperative information systems, information retrieval, electronic
commerce and knowledge management. Using ontologies, semantic annotations on
Web resources will allow structural and semantic definitions of documents, providing
completely new possibilities: Intelligent search instead of keyword matching, query
answering instead of information retrieval, document exchange between departments
via ontology mappings and definition of views on documents. The semantic web is a
proposal to build an infrastructure of machine-readable semantics for the data on the
web.
The semantic web [88] and ontologies play very important role in the recent ex-
plosion of interest in the world wide web. The enormous amount of data has made
it difficult to find, access, present and maintain the information required by users.
This is because information content is presented primarily in a natural language, and
needs the formal language specification with natural language features, as, e. g., reifi-
cation.
In semantic web languages, such as Resource Description Framework (RDF) and
Web Ontology Language (OWL), a statement is a binary relation. It is used to link two
individuals or an individual and a value. Applications sometimes need to describe
other RDF statements, for instance, to record information like when statements were
made, or who made them, which is sometimes called “provenance” information. As
an example, we may want to represent properties of a relation, such as our certainty
about it, severity or strength of a relation, relevance of a relation, and so on. RDF [89]
follows the W3C design principles of interoperability, extensibility, evolution and de-
centralization. Particularly, the RDF model was designed with the following goals:
simple data model and extensible URI-based vocabulary allowing anyone to make
statements about any resource.
The RDF schema specification provides a machine-understandable formalism for
defining schemas for descriptive vocabularies like the Dublin Core. It allows design-
ers to specify classes of resource types and properties to convey descriptions of those
classes, relationships between those properties and classes and constraints on the al-
lowed combinations of classes, properties and values.
Basically, RDF defines a data model for describing machine understandable in-
formation on the web. The basic data model consists of three object types: resources,
properties and statements. The modeling primitives of RDF are very basic: actually
they correspond to binary predicates (RDF-properties) of ground terms (source and
value), where, however the predicates may be used as terms so that RDF cannot be

110
|
2 Applications of the intensional abstraction operator
embedded into the standard extensional first-order logic (FOL). RDF has blank nodes,
which are essentially globally quantified existential variables. The statements are also
resources, so that statements can be applied recursively to statements, allowing their
nesting (reification) but such most innovative feature (early versions of RDF made
quite strong claims for RDF reification) is not actually supported by RDF: such problem
will be explored in more detail in the following (one of the main reasons to introduce
the intensional FOL [27], as discussed in the introductory part of Section 1.3.1). Reifi-
cation is widely used in conceptual modeling. Reifying a relationship means viewing
it as an entity. The purpose of reifying a relationship is to make it explicit, when ad-
ditional information needs to be added to it (consider, e. g., the relationship “isMem-
berOf”).
Therefore, the RDF Schema (RDFS) specification [90] enriches RDF by giving
an externally specified semantics to specific resources, e. g., to rdf:subclassOf, to
rdf:Class, etc. It is only because of this external semantics that RDFS is useful. RDFS
is recognizable as an ontology representation language: it talks about classes and
RDF-properties (binary relations), range and domain constraints (on RDF-properties),
and subclass and subproperty (subsumption) relations.
2.3.1 Introduction to semantic web languages RDF and OWL
RDFS has a very interesting extension to natural language (e. g., reification), but at
least in some logical aspects is a weakly expressive language, and such limitations of
RDFS led to the development of new web ontology languages such as, e. g., DAML+OIL
adopted by W3C as the basis of a new OWL web ontology language [91].
So, all attempts to integrate RDFS into some more expressive FOL sublanguage
with a built-in extensional equality theory (as OWL, largely based on description logic,
or other interesting languages as logic programming, deductive databases or modal
logic languages (e. g., epistemic logic), etc.) are unsuccessful [92, 93]: these FOL sub-
languages cannot embed the reification, which is a natural-language property and is
a more innovative feature of the RDF w. r. t. other ontology specification languages
based on the FOL sublanguages. Thus, the motivation for this work is just to valorize
this very important feature of RDF, for building intelligent database systems.
The difficulty comes from the fact that all FOL sublanguages have the model the-
ory in which individuals are interpreted as elements of some domain, classes are inter-
preted as subsets of the domain and RDF-properties are interpreted as binary relations
on the domain. The semantics of RDFS, on the other hand, are given by a nonstan-
dard model theory, where individuals, classes and RDF-properties are all elements in
the domain, RDF-property elements have extension which are binary relations on the
domain, and class extensions are only implicitly defined by the rdf:type property.
Such properties can be directly embedded into Jigher-order logics (HOL) with a
built-in extensional equality theory (under standard HOL semantics, an equation be-

2.3 Semantic WEB applications
|
111
tween the predicate (or function) symbols is true if and only if these symbols are in-
terpreted via the same relation (extension)), in particular, the use of predicates in a
variable position. Unfortunately, extensional equality of predicates and functions is
not decidable, which carries over to the unification problem. For genuine second-order
theories (e. g., second-order predicate calculus and Church’s simple theory of types,
both under the standard semantics) extensional equality is not even semidecidable.
Moreover, RDFS support reflection on its own syntax: it is defined in terms of
classes and RDF-properties, which are interpreted in the same way as other classes
and RDF-properties, and whose meaning can be extended by statements in the lan-
guage. This violates the very principles of set theory, i. e., that set membership should
be a well-defined relationship, so when we try to integrate RDFS into some (exten-
sional) FOL sublanguage we meet Russel’s paradox, that result from an attempt to
make sets too powerful.
For example, it is not possible in RDFS to provide defined classes, classes that give
a formula that determines which resources belong to them. We can provide an even
richer theory of classes and RDF-properties, allowing for defined classes and more
relationships between classes.
The RDF syntax based on triples (RDF sentences) is a graph data structure, remi-
niscent of semantic networks. Such graph structure have well-known problems with
scoping of quantifiers, negations and disjunctions (consequently, with logic impli-
cation). RDF solves these problems by disallowing all these constructs (anonymous
nodes in RDF can be considered to be existentially quantified, but the scope of the
quantifier is the entire graph).
There is an attempt [94] of embedding RDF into the F-logic or its subcomponent
HiLog [24], which has the second-order syntax with intensional equality theory, but
from our point of view such approach degenerates and unusefully complicates the
original elegant syntax of RDF, which is one of the most important reasons for its wide
and unquestionable success.
The attempt [95, 96] of embedding RDF into (S)KIF is analog to HiLog (has the
second- order syntax with intensional equality theory). It is incomplete [93], and does
not address reification and anonymous resources, but has the similar semantics to
RDFS: it is not casual, the same author Patrick Hayes defined the semantics for RDF
[97].
In the RDF model theory is formally expressed as the adoption of the intensional
semantics, so that standard extensional FOL language is explicitly refused as a candi-
date for larger logic embedding framework [97]:
“The use of the explicit extension mapping also makes it possible for two properties to have ex-
actly the same values, or two classes to contain the same instances, and still be distinct entities.
This means that RDFS classes can be considered to be rather more than simple sets; they can be
thought of as “classifications” or “concepts,” which have a robust notion of identity that goes
beyond a simple extensional correspondence. This property of the model theory has significant
consequences in more expressive languages built on top of RDF, such as OWL [91], which are

112
|
2 Applications of the intensional abstraction operator
capable of expressing identity between properties and classes directly. This “intensional” nature
of classes and properties is sometimes claimed to be a useful property of a descriptive language
[97].”
Motivation and main contributions
This section is a formal continuation of this approach to the semantics of RDF
databases, considering that RDF is not First-order Logic (FOL), nor in syntax nor
in semantics: thus, what we will explore is the formal definition for a particular kind
of intensional FOL language with abstraction operator, which we consider as a natural
logic framework that uses only the minimum of the logic machinery for the formal
and full embedding of RDFS into FOL language. Notice that the abstraction operator is
a necessary prerequisite in order to avoid the second-order syntax as in HiLog and KIF,
and the confusion between predicate forms and the (intensional) names of the same
forms (which in our theory are terms of the language); as we will see this abstraction
operation is based on the particular kind of natural language “subsentences,” which
are different from ordinary “complete” logic sentences that cannot have logic values.
Because of all points discussed in precedence, our approach is very close to these
last two attempts, but we prefer to use the pure intensional FOL with an abstraction
operator [42, 58], as a natural and well-suited logic embedding of the RDFS data struc-
tures, which provides all nice features of the FOL language, all logic connectives (RDF
uses only conjunction for its triples), predicates, variables and quantifiers.
Other contribution, and a peculiarity of our approach, is that we consider RDF
language and its data structures as terms of an algebra of triples, i. e., of RDF graphs,
and not as logic theory itself: we distinguish the triple structure ⟨r, p, v⟩from a ground
atom p(r, v) in logic: the first one, as is, e. g., a tuple of a database, can be (or not)
an element of the given RDF ontology (RDF graph), and have no truth value, while
the second is a logic formula, which can be true or false. The embedding of such data
structures into logic is an analog of the embedding of relations and tuples of relational
databases into a predicate logic and ground atoms of the FOL.
Basically, we will avoid the second-order syntax by transforming predicates into
intensional terms by using an abstraction operation ⋖_⋗; thus, we consider each RDF
triple as a term, obtained by abstraction of the predicate corresponding to the property
element of this RDF triple.
Consequently, a RDF triple ⟨r, p, v⟩, where r, v are instances or values, is equal
to the intensional abstract (term) ⋖p(r, v)⋗of the ground atom of binary predicate p
in this intensional FOL. Thus, apart of this slight syntax difference, each RDF triple
is an intensional term in the intensional FOL for RDFS, and the reification structure
⟨⟨r, p, v⟩, p1, v1⟩is an intensional term ⋖p1(⋖p(r, v)⋗, v1)⋗, obtained by abstraction from
the ground atom p1(⋖p(r, v)⋗, v1).
As we see, this logic embedding is very close to the original RDF syntax, and as
we will see in the rest of this paper, the semantics of this intensional FOL fully in-

2.3 Semantic WEB applications
|
113
corporates the nonstandard semantics of RDF [93, 97]. In this framework, individuals
and data values correspond to FOL constants, classes and data types correspond to
unary predicates, properties to binary predicates and subclass/property relationships
correspond to logic implication.
2.3.2 General embedding of RDF data structures into intensional FOL
In this section, we will make a confrontation of the actual RDF model theory (model
theory) and the proposed intensional logic embedding of RDF into minimal inten-
sional FOL given by Definition 15 in Section 1.3 and enriched by intensional abstrac-
tion operator provided in Section 1.3.1.
RDF model theory
An interpretation IRDF of the RDF vocabulary V, i. e., RDF model theory, is a triple
(IR, IEXT, IS), where:
1.
A nonempty set IR is the domain (of resources), called the domain of the universe
of the IRDF.
2.
A set IP, called the set of properties of IRDF.
3.
A mapping IEXT : IP →𝒫(IR × IR), mapping each property in IP ⊂IR into the set
of pairs, which identify the arguments for which the property is true.
4.
A mapping IS : V →IR from URI references in V into IR.
5.
A mapping IL : V →IR from typed literals in V into IR.
6.
A distinguished subset LV (of real entities that “exist”) of IR, called the set of literal
values, which contains all the plain literals in V.
For example, the denotations of ground RDF graphs are as follows:
1.
if E is a plain literal “aaa” in V, then IRDF(E) = aaa;
2.
if E is a plain literal “aaa”@ttt in V, then IRDF(E) = ⟨aaa, ttt⟩;
3.
if E is a typed literal in V, then IRDF(E) = IL(E);
4.
if E is a URI reference in V, then IRDF(E) = IS(E);
5.
if E is a ground triple ⟨r, p, v⟩, then:
IRDF(E) = t
if r, p, v ∈V,
IRDF(p) ∈IP
and
(IRDF(r), IRDF(v)) ∈IEXT(IRDF(p));
f otherwise.
6.
if E is a ground RDF graph, then:
IRDF(E) = f
if IRDF(E′) = f for some triple E′ ∈E;
t otherwise.

114
|
2 Applications of the intensional abstraction operator
Embedding of RDFS into intensional FOL
In what follows, we will first show how to manage the RDF triples by the intensional
FOL defined in Section 1.3, and show that it is a conservative extension of RDF.
We will consider an RDF-ontology as finite set of triples ⟨r, p, v⟩, where r is a re-
source name (for class, an instance or a value), p is a property (InstanceOf or Property
in RDF, or subclass or property in RDFS), and v is a value (which could also be a re-
source name). We denote by 𝒯the set of all triples which satisfy such requirements.
Definition 31. Each RDFS ontology can be embedded into the intensional FOL ℒω as
follows:
1.
The individuals and data values correspond to FOL constants, the classes and data
types correspond to unary predicates, the properties to binary predicates and the
sub-class/property relationships correspond to the implication.
2.
RDF triple ⟨r, p, v⟩can be represented as a formula of the intensional FOL by:
2.1 If p is the special URI reference rdf:type, then ⟨r, p, v⟩󳨃→v(r),
2.2 If p is the special URI reference rdfs:subClassOf, then
⟨r, p, v⟩󳨃→(r(x) ⇒v(x)).
Otherwise:
Case 2.4 When r and v are classes,
⟨r, p, v⟩󳨃→p(⋖r(x)⋗x, ⋖v(y)⋗y),
where in the right-hand side, p is a binary predicate symbol intro-
duced for the property, while r, v are unary predicate symbols intro-
duced for the classes, subject and object, respectively.
Case 2.5 When r is a class andv is aninstanceorvalue,⟨r, p, v⟩󳨃→p(⋖r(x)⋗x, v),
Case 2.6 When v is a class and r is an instance or value, ⟨r, p, v⟩󳨃→p(r,
⋖v(y)⋗y),
Case 2.7 When r and v are the instances or the values (ground triple),
⟨r, p, v⟩󳨃→p(r, v).
3.
The RDFS ontology graph 𝒪= {⟨ri, pi, vi⟩| 1 ≤i ≤n, n ≥2} is embedded into the
formula ϕ1 ∧⋅⋅⋅∧ϕn, where ϕi is the embedding of a triple ⟨ri, pi, vi⟩, 1 ≤i ≤n.
A blank node x in a triple ⟨x, p, v⟩is embedded into the formula ∃x.p(x, ⋖v(y)⋗y) if v is
a class; into the formula ∃x.p(x, v) otherwise.
The reified RDF statements are embedded into the intensional terms by nidifying
abstraction operator. For example, ⟨⟨r, p, v⟩, p1, v1⟩is represented in intensional FOL
as a formula p1(⋖p(r, v)⋗, v1).

2.3 Semantic WEB applications
|
115
Notice that in this embedding of RDF triples, we consider them as intensional
terms, and not as logic sentences (as in current RDF interpretation and its model the-
ory), which identify a ground triple ⟨r, p, v⟩with a logic atom p(r, v). As we have ex-
plained in the Introduction, such an identification used in RDF will be epistemically
equivalent to consideration of a tuple t of a relation R, as the ground atom R(t), which
is not acceptable: tuples of constants are considered in a logic theory as the terms from
which we can build logic predicate forms and sentences. So, by the definition above of
transformation of RDF triples (considered as tuples of a ternary relation) into a formal
logic formulae, we obtained a correct epistemic framework as well.
Another advantage in this embedding is that we do not need to define the mean-
ing of a predicate rdfs:subClassOf by the axioms for reflexivity and transitivity
as in RDFS. We do not need more of the RDF axiom for the relationship between
rdfs:subClassOf and rdf:type as well.
Example 10. Let us consider some of the properties of RDFS, which cannot be embed-
ded into standard (extensional) FOL, but are perfectlyacceptedby intensionalFOL ℒω:
On the one hand, rdfs:Resource is an instance of rdfs:Class; on the other hand,
rdfs:Class is a subclass of rdfs:Resource. Thus, rdfs:Resource is an instance of its sub-
class.
This is a contradiction for a standard extensional FOL. But in the intensional FOL,
where there is distinction between the intension and extension of a given concept (for-
malized as a logical predicate), we have that for these two intensional concepts (rep-
resented in intensional FOL by unary predicates pR(x) and pC(y), respectively), e. g.,
in the actual world with the extensionalization function h, and an intensional inter-
pretation I : ℒ→𝒟:
I(pR(x)) = rdfs:Resource ∈D1 is an unary concept-instance, and hence an element
of the intensional concept I(pC(y)) = rdf:Class ∈D1. That is, rdfs:Resource = I(pR(x)) ∈
h(I(pC(y))) = h(rdf:Class), while the denotation of the intensional concept rdf:Class =
I(pC(y)) is a subset of a denotation of the intensional concept rdfs:Resource = I(pR(x)),
i. e., for the extensions of these two intensional concepts it holds that h(rdf:Class) ⊆
h(rdfs:Resource) ⊆𝒟. So, we have the following fact in the intensional FOL:
rdfs:Resource = I(pR(x)) ∈h(rdf:Class) ⊆h(rdfs:Resource)
(2.46)
Analysis of the embedding
Let us consider the correspondence between the RDF nonstandard model, with an
interpretation IRDF : V →IR, where V is the RDF vocabulary (in our case it is also
part of the syntax of the intensional FOL language ℒω), and IR is the domain of RDF
resources (in our case IR = D−1 ⋃D0 ⋃D1 ⋃D2 ⊆𝒟) with IP = D2 (the set of RDF
properties is the set of binary relation-in-intensions), and LV (the set of literal val-
ues of RDF) is a subset of D−1. In Figure 2.1, the embedding of the nonstandard RFS
model into the intensional FOL logic model is schematically represented: in grey color

116
|
2 Applications of the intensional abstraction operator
Figure 2.1: Embedding of RFS.
are represented the original RDF model components. There are the following differ-
ences:
1.
The original RDF model theory has a partial intensional structure: only its prop-
erties in IP (embedded into D2 ⊂𝒟) are intensional entities, and for them there
exists the extensionalization function IEXT. In intensional FOL language, all in-
tensional entities have an extension: thus, instead of the complex derivation of
the class extension ICEXT in RDF model theory, defined through the extension of
IS(rdf:type) ∈IP ⊂IR:
ICEXT(x) = {y | (y, x) ∈IEXT(IS(rdf:type))}
we can directly find the extension by the mapping component h1 of the extension-
alization function h of the intensional FOL model.

2.3 Semantic WEB applications
|
117
2.
The other difference is that in a language ℒω, for any ground RDF triple ⟨r, p, v⟩,
we have the logic atom p(r, v) and its intensional abstraction, i. e., a term ⋖p(r, v)⋗.
So, the RDF interpretation of the ground triple ⟨r, p, v⟩, IRDF(⟨r, p, v⟩), where r, v are
individual constants, corresponds to the following extension, in the actual world,
of the intensional “name” I(p(r, v)) ∈D0 of the ground atom p(r, v) obtained from
atom with variables p(x, y), where I is the intensional interpretation for ℒω:
IRDF(⟨r, p, v⟩) = h(I(p(r, v))) = t
iff
(h(I(r)), h(I(v))) ∈h(I(p(x, y))).
3.
The domain IR in RDFSmodel theory has no anyalgebraicstructure,differentfrom
the algebraic structure over a domain 𝒟where, e. g., I(A ∧B) = conj(I(A), I(B)),
and hence the denotation of all complex formulae in ℒω can be computed from
the denotation of its subformulae (the denotation relation of all the complex in-
tensional terms in ℒω is recursively defined).
4.
While the different extensions of the actual RDFS framework, e. g., by introducing
the predicates with arity bigger than two, would modify its nonstandard model
theory, in the model structure of the intensional FOL ℒω we do not need any
change for such extensions.
5.
We do not force the RDF triples and graphs to have logic values, but consider them
what they are: complex data structures.
6.
With FOL language ℒω, we have the full logic inference, based on the intensional
equality theory. We can enrich original RDFS graphs also with other n-ary pred-
icates, which can be useful for more compact ontology representations. We can
also introduce integrity constraints for such ontologies, which can use more com-
plex logic formulae with quantifiers.
In what follows, we will show that disadvantages of the actual nonstandard RDF
model theory (RDF model theory), taken from [98], does not hold in its embedding in
the intensional FOL ℒω:
1.
Too few entailment: Let us consider two formulae, q(x) be equal to Student(x) ∧
Employee(x) ∧European(x), and q1(x) be equal to Student(x) ∧Employee(x), such
that holds q(John). So, in the RDF model theory, since every concept is also an
object, there is no guarantee that if “John” is an instance of the class
Student ⋂Employee ⋂European
also if “John” is an instance of the class Student ⋂Employee. But by the embed-
ding into intensional FOL ℒω, we have that q(John) ⇒q1(John) is true, i. e.,
h(I(q(x))) = h(I(Student(x)) conj I(Employee(x)) conj I(European(x)))
= h(I(Student(x))) ⋂h(I(Employee(x))) ⋂h(I(European(x)))
⊆h(I(Student(x))) ⋂h(I(Employee(x))) = h(I(q1(x))).

118
|
2 Applications of the intensional abstraction operator
2.
“Contradiction” classes: Such problem does not exist when RDFS is embedded into
the intensional FOL: we cannot define a class “eg:C” as an instance of itself and
add a cardinality constraint “= 0;’ on the rdf:type property of it.
3.
Size of the universe: The semantic consequences of the RDFS thesis include that
all RDF properties (predicate symbols) are elements of discourse (i. e., of IR): it is
valid also in this embedding. We cannot have the situations as in RDFS with only
one object in universe, and hence to have an interpretation such that “John” is a
member of “Person,” but not a member of “Car.” In fact, in intensional FOL, all of
them are intensionallydifferent entities,andhencewemusthavetheir intensional
interpretations in 𝒟, so that the universe 𝒟cannot have only one object. Thus, in
intensional FOL, always there exist interpretations such that Person(John), and
¬ Car(John) are true.
This is a characteristic for all kinds of logics, which distinguish the intension from the
extension of its entities, and hence differentiate them from the logics with extensional
equality theory.
2.3.3 Logic programs for data integration with RDF ontologies
The approach to use conventional first-order logic (FOL) as the semantic underpinning
for RDF has many advantages: FOL is well established and well understood. There is
a family of languages based on various FOL subsets offering different tradeoffs with
respect to expressive power, complexity and computability, and the direct mapping of
such languages into a subset of FOL provides semantic interpretability also.
This approach is not directly compatible with full RDFS, as provided in the previ-
ous Section 2.3.2 by considering a general reification by means of abstracted terms of
intensional FOL, but it is compatible with the following simplified version of RDFS in
which it is not used the reification: In what follows, we will adopt the approach used
in [98] but not constrained only to description logic. Instead of that, we will consider
this RDF sublanguage as Herbrand semantic bases for a world-based introduction of
probabilistic information into RDF theory [14].
Data integration in RDF – motivation
The new P2P data integration systems in the semantic web [88] needs rich ontologies
for the peer databases and efficient query-answering algorithms for expressive SQL-
like query languages. So, the mapping between peer databases has to be based on the
views (expressed by such SQL-like query languages), defined over peer ontologies, as
in other cases of data integration systems [53, 99–101].
Thus, our attempt is to extend the database technology of data integration based
on rich ontologies and view-based P2P mappings also for semantic for the data on the

2.3 Semantic WEB applications
|
119
Web expressed in the RDF syntax: principal motivation is that RDF is a reality in Web
applications, so that P2P integration of RDF ontologies is necessarily a very important
issue. Just because of that, the introduction if new intensional RDB in Chapter 4 is
more important as well, because in such databases we unify classical RDB applica-
tions and these web applications written in RDF.
RDF ontology
We will consider an RDF-ontology as (only) finite set of triples ⟨r, p, v⟩, where r is a
resource name (for class, an instance or a value), p is a property (InstanceOf or prop-
erty in RDF, or subclass or property in RDFS), and v is a value (which could also be a
resource name). We denote by 𝒯the set of all triples, which satisfy such requirements.
Definition 32 (Embedding of RDF-ontologyinto logic programs). We define the logic
embedding into logic program clauses as a mapping 𝔼: 𝒯→ℒ, where ℒis inten-
sional FOL with a domain 𝒟and without an intensional abstract operator, such that
for any triple ⟨r, p, v⟩∈𝒯holds:
Case 1: when p = Subclass:
𝔼(⟨r, Subclass, v⟩) = r′(x) ←v′(x)
where r′, v′ are unary predicates for the subject and object of a triple, respectively, and
x is a variable over a domain 𝒟.
Case 2: When p = InstanceOf:
𝔼(⟨r, InstanceOf, v⟩) = r′(v) ←
where r′ is an unary predicate for the resource of the RDF triple.
Case 3: When p ∉{InstanceOf, Subclass}:
𝔼(⟨r, p, v⟩) = (r′(x) ∧v′(y)) ←p′(x, y),
if r, v are classes;
= r′(x) ←p′(x, v),
if r is a class and v is an instance or value;
= v′(y) ←p′(r, y),
if v is a class and r is an instance or value;
= p′(r, v) ←,
if r and v are instances or values;
where, in the right side of equation, p′ is a binary predicate assigned by this embed-
ding to the property name p, and r′, v′ are unary predicates assigned to the subject
and the object classes of a triple.
Given an RDF-ontology 𝒪⊂𝒯, we denote by 𝔼(𝒪) its logic ontology obtained
by this embedding, i. e., a logic program 𝔼(𝒪) =def {𝔼(⟨r, p, v⟩) | ⟨r, p, v⟩∈𝒪}. Let
IH : H →2 be a Herbrand model of this logic program with the Herbrand base H
obtained from an RDF-ontology. We define the RDF-model ℳ(𝒪) of an RDF-ontology

120
|
2 Applications of the intensional abstraction operator
𝒪recursively for any triple ⟨r, p, v⟩∈𝒪, and for the following cases (a, b are elements
of a domain 𝒟): ⟨a, p, b⟩∈ℳ(𝒪) if
1.
p′(a, b), r′(a), v′(b) ∈H are true in IH, when r, v are classes;
2.
p′(a, v), r′(a) ∈H are true in IH, when r is a class and v is an instance or value;
3.
p′(r, b), v′(b) ∈H are true in IH, when v is a class and r is an instance or value;
4.
p′(r, v) ∈H is true in IH, when r, v are instances or values.
Thus, all triples in the RDF-model of an ontology 𝒪are ground triples.
Remark. Notice that if ℳ(𝒪) is an RDF-model of an ontology 𝒪, then for any ground
RDF triple ⟨r, p, v⟩holds that clause
clause
𝔼(⟨r, p, v⟩)
is satisfied
iff
⟨r, p, v⟩∈ℳ(𝒪)
(2.47)
We can also enrich the RDF-ontology language by the negation operation.
Definition 33 (Negation). We define the negation algebraic operation ∼for extended
algebraic RDF-ontology language, for a RDF triple ⟨r, p, v⟩, by
𝔼(∼⟨r, p, v⟩) =def ¬𝔼(⟨r, p, v⟩),
where ¬ is the logic negation of program’s clauses such that
¬(ϕ ←ψ) =def ((ψ ∧¬ϕ) ←)
¬(ϕ ←) =def (¬ϕ ←)
The triples or their negations will be called RDF-literals.
Notice that for any ground RDF triple ⟨r, p, v⟩holds: 𝔼(∼⟨r, p, v⟩) is true iff
⟨r, p, v⟩∉ℳ(𝒪). It is reasonable to use negation ∼in order to specify complex terms
for RDF ontologies. It is kind of an explicit constraint. For example, when we introduce
the ground literal term ∼⟨r, p, v⟩in an ontology specification, we specify a constraint
that the triple ⟨r, p, v⟩cannot be part of any RDF-model of such ontology (like the
specification of explicit negative information in a logic ontology language).
The Peer-to-Peer (P2P) database systems offer an alternative to traditional client-
server systems for some application domains. A P2P system has no centralized schema
and no central administration. Instead, each peer is an autonomous information sys-
tem, and information integration is achieved by establishing P2P mappings among
various peers. Queries are posed to one peer, and the role of query processing is to
exploit both the data that are internal to the peer, and the mappings with other peers
in the system.
In what follows, we consider an RDF ontology as a basic data strata of a peer
database. In order to define the logical views over such RDF ontologies, we will use

2.3 Semantic WEB applications
|
121
the logic theory obtained by embedding this RDF-ontology 𝒪into intensional FOL
with abstraction, as provided previously.
It has become customary to define the notion of RDF programming via a long list
of triples (binary RDF-properties), which each resource must possess. In relational
language, instead, the data are conceptually grouped around n-ary predicates with a
set of attributes, which together describe different properties attributed to such logical
concept.
Views are an established technology for both relational and object-oriented
databases. They are mainly used to provide data customization, i. e., the adapta-
tion of content to meet the demands of specific applications and users, so that they
present the key technology for integrating heterogeneous and distributed systems,
facilitating interoperability by hiding the foibles of each information component
and gluing individual components together to form an integrated P2P application
system.
The simple idea is to see a view φ(x1, . . . , xn) over an RDF-ontology, expressed as a
formula in some query language for RDF databases (for example, as a SELECT-FROM-
WHERE structure in [102, 103], as n-ary relation-in-intension (intensional name)
whose extension in the actual world (a possible world corresponds to the possible
RDF database extension) is equal to its query answer.
Example 11 (from [104]). To find all (sculpture, museum) pairs, in an RDF peer data-
base, where the sculpture was created by Rodin, the museum houses the given sculp-
ture, and the museum web site was not modified since January 1, 2001, and we can
define the following query: rdql-query =:
SELECT ?sculpture, ?museum
WHERE (?sculpor, <ns1:lname>,“Rodin”),
(?sculptor, <ns1:creates>, ?sculpture),
(?sculpture, <ns1:exhibited>, ?museum),
(?museum, <ns1:last-modified>, ?date),
AND ?date <2001.01.01
USING ns1 FOR <http://www.icom.com/schema1>
and the correspondent view, by:
φ(x1, x2) = CREATEVIEW view-name AS rdql-query,
where φ(x1, x2) is a virtual predicate, obtained by the following FOL translation into
logic clause (Definition 32):

122
|
2 Applications of the intensional abstraction operator
φ(x1, x2) ←lname(y, “Rodin”) ∧creates(y, x1) ∧exhibited(x1, x2)
∧last-modified(x2, z) ∧(z < 2001.01.01),
where x1, x2 are free variables for sculpture and museum, respectively.
The peer database in this framework is just the logic theory, defined as union of
the RDF database’s FOL-embedding and a number of views defined over it (they con-
stitute a virtual user-type interface). Such an embedding of a RDF database, together
with its view-extension can be used as mean for intensional mapping with other peer
databases in a web P2P networks [57, 105]. There are the following nice properties for
this RDF peer database framework:
–
The FOL embedding of standard RDF database together with views corresponds
to the definite logic program, thus the database model of such RDF peer database
has a unique Herbrand model, different from the standard Data Integration Sys-
tems (DIS) with relational schema ontology, which usually suffer incomplete in-
formation and a very high number of Herbrand models (possible completions of
this withdraw): so, the query answering from peer databases with RDF database
is very efficient (polynomial complexity).
–
The defined views can be materialized and there are efficient algorithms [104]
for maintenance of RDF views when new RDF data triples are inserted in a peer
database, when some of them are deleted or modified.
–
From the theoretical point of view, the possibility to transform the original RDF
based peer database into the more expressive, but decidable, FOL sublanguages,
is important if we want to add also integrity constraints over a peer database on-
tology (e. g., in the simplest case, the key constraints over a view). In that case,
we are able to parse the original RDF structures into a deductive predicate-based
database. In such way, we are able to rich the expressive power of standard rela-
tional DIS (see more in the dedicated Chapter 3).
Now we can use the new intensional equivalence relation between intensional entities
(1.11), defined in intensional FOL by Corollary 3 in Section 1.3, which can be used as
intensional mapping between databases: we can define the set of intensionally equiv-
alent views over two different databases as semantic mapping between them as ex-
plained in detail in Chapter 3. Such approach to the mapping between RDF ontolo-
gies has been proposed in [54]. Such interschema mappings is not invasive w. r. t. the
local epistemic knowledge of any single peer: each database-peer with a proper RDF-
ontology and the number of intensional views defined by RDF queries is completely
free to change its local RDF structure (insert, delete and modification of RDF triples).
It does not import the extensional knowledge from other peer databases of a P2P sys-
tem, but specify only which part of its own knowledge has the same meaning as some
knowledge (intensional views) of other actors.

2.3 Semantic WEB applications
|
123
We consider only RDF ontologies, which can be embedded in the intensional FOL,
for which the resulting logic theory corresponds to definite logic programs with a
unique Herbrand model of a peer database: so, the query answering for such peer is
very efficient and suitable for intensive Web information retrieval.
The intensional views (RDF queries) over peers present the key technology for in-
tegrating heterogeneous and distributed systems, facilitating interoperability by hid-
ing the foibles of each information component and gluing individual components to-
gether to form an integrated P2P application system. The epistemic independence of
such peers is a guarantee for development of very robust P2P database systems.
The intensional mapping semantics for peer databases with RDF ontologies, pre-
sented here, constitutes a sound basis for studying the various issues related to inter-
schema knowledge representation and reasoning, especially for P2P database systems
in the web environment where peers can be considered as complex database agents.

3 Intensional semantics for P2P database systems
3.1 Intensionality and epistemic independency of database peers
Ontologies play a prominent role on the semantic web. An ontology specifies a con-
ceptualization of a domain in terms of concepts, attributes and relations. However,
because of the semantic web distributed nature, data on it will inevitably come from
many different ontologies. A key challenge in building the semantic web, one that
has received relatively little attention, is finding semantic mappings among the on-
tologies (peers). Given the decentralized nature of the development of the semantic
web, there will be an explosion in the number of ontologies. Many of these ontologies
will describe similar domains, but using different terminologies, and others will have
overlapping domains. To integrate data from disparate ontologies, we must know the
semantic correspondence between their elements [106]. Recently, a number of different
architecture solutions have been given [53, 101, 107–110].
Indeed, current P2P systems focus strictly on handling semantic-free, large-
granularity requests for objects by identifier (typically a name), which both limits
their utility and restricts the techniques that might be employed to distribute the
data. These current sharing systems are largely limited to applications in which ob-
jects are large, opaque and atomic, and whose content is well described by their name.
Moreover, they are limited to caching, prefetching or pushing of content at the object
level, and know nothing of overlap between objects.
These limitations arise because the P2P world is lacking in the areas of semantics,
data transformation and data relationships, yet these are some of the core strengths
of the data management community. Queries, views and integrity constraints can be
used to express relationships between existing objects.
The Peer-to-Peer (P2P) database systems offer an alternative to traditional client-
server systems for some application domains. A P2P system has no centralized schema
and no central administration. Instead, each peer is an autonomous information sys-
tem, and information integration is achieved by establishing P2P mappings among
various peers. Queries are posed to one peer, and the role of query processing is to
exploit both the data that are internal to the peer, and the mappings with other peers
in the system. An increasing amount of data is becoming available in the world wide
web, and the data is managed under an increasing diversity of a data model and ac-
cess mechanisms. Much of this data is semistructured. In what follows, we will con-
sider the reach ontology of peer databases, formally expressed as a global schema of
a data integration system (specified in Section A.6.4 in the Appendix). A Data Integra-
tion System (DIS) [21, 111] is a triple ℐi = (𝒢i, 𝒮i, ℳi), where 𝒢i = (𝒢Ti, ΣTi) is a global
schema (ontology), expressed in a language ℒ𝒪over an alphabet 𝒜𝒢i, ΣTi are the in-
tegrity constraints, 𝒮i is a source schema and ℳi is a set of mappings between a global
schema 𝒢Ti and a source schema 𝒮i.
https://doi.org/10.1515/9783110981438-003

3.1 Intensionality and epistemic independency of database peers
|
125
The main motivation for the introduction of intensional logic for the mappings
between peers is based on the desire to have the full epistemic independency of peer
databases: we consider that they can change their ontology and/or extension of their
knowledge independently from other peers and without any communication to other
peers. So, we intend to use the mappings between peers that are not controlled by any
centralized system, which are not permanently correct during the evolution of a P2P
system in time but express only assumptions based on their local belief about knowl-
edge of other peers: here, there is not any transfer of local knowledge of a peer to
knowledge of other peers, which can possibly generate inconsistency of other peers,
but only belief based assumption that they can speak about intensionally equivalent
concepts. From a practical point of view, we assume that there is no any omniscient
query agent and able to know the whole global P2P system. So, as in human commu-
nication, based on the fact that the same concepts have the same meaning, but not
extensions for any human being, query answering must be based on the weaker form
of deduction of that of the omniscient deduction, which uses the modus ponens and
necessity rule (for normal modal logic) to derive all possible deductions. In this way,
we intend to obtain very robust P2P systems but also the possibility to map naturally
P2P database systems into grid computation: if the peers are fully independent, it is
enough to associate each pair (peer, query formulae) to a particular resource of grid
computing, in order to obtain known answer from such peer.
The intensional logic is necessary in order to develop more intelligent query
agents, which have to manage the data concepts in similar way as humans. The clas-
sical extensional logic, developed to work with rigid concepts (which do not change
their extension in different circumstances (possible worlds)) as are mathematical
concepts, natural numbers, integers, prime numbers, reals or built-in relations over
numbers ≤, =, etc.), is too limited when we have to deal with nonrigid concepts, as for
example, the relation “Car,” whose extension in the same database change in time.
In the classic extensional logic, any two concepts are equal if they have the same
extension (any two sets with the same members are equal), so that the same concept
“Car,” as commonly considered by humans, in extensional logics will be divided in a
number of different concepts (each one with different set of members).
When we are dealing with problems concerning only a given world (e. g., the ac-
tual world in a given time instance), as the most traditional software applications do,
we can describe the data semantics by standard first-order extensional logic (whose
model will determine the actual extension for any database relation). But when, as
in this case, we pass to more intelligent P2P systems, when the query agent has to
consider the query-rewriting algorithms over two concepts in two different and epis-
temically independent peers, it is the identical meaning of these two concepts, which
has to be considered as a semantic connection between two different peers.
Similarly, as human do when they communicate: when I speak with my friend
about the “Car,” I know that we are speaking about the same concept also, when I do

126
|
3 Intensional semantics for P2P database systems
not know my whole knowledge extension about cars (and really I am not able to enu-
merate all instances of cars that is part of my memory), not his actual extension about
cars. This observation is useful in order to understand why the meaning of nonrigid
concepts cannot be defined constructively based on its possible extensions: it is the
human mental process, developed in the brain of one person, able to recognize that
one object is a car or is not a car that corresponds to the meaning of this concept for this
person. This distinction will be useful when we will approach the two complementary
approaches to intensional logics: Montague’s and Bealer’s.
The intensional mappings, based on intensionally equivalent views of two dif-
ferent peers, is considered also in [53, 55] where they used the extensional FOL and
described the algorithm able to extract the answers to conjunctive queries. Logic the-
ory was not defined in which the set of answers is the extension of a conjunctive query
(seen as virtual predicate) in a given model of this logic. That is, was not given was the
logic theory with the proof-theoretic framework where the set of answers is exactly the
set of inferred ground facts from this logic theory: in [53, 55] is presented the proce-
dural, algorithmic method for computing the answers to conjunctive queries, but they
missed the logic theoretical approach to query answering. The main contributions in
this chapter are:
1.
We define the two-level modal logic framework: At the higher level, we define the
intensional modal FOL with intensional identity for a P2P system, ℒω, and enrich
it with the intensional equivalence, as provided by Example 3 in Section 1.3. It is
a predicate modal logic (FOL quantifiers are transformed into modal operators).
This logic is used by query agents, and uses only predicates of mediator schema
of peer databases and views defined over them. This logic is modal logic where
the set of possible worlds is the set of all possible evolutions in a time of a given
P2P system (when peers modify their ontologies or their extension). We define the
weak deduction inference for this intensional logic to be implemented by a query
answering algorithm of nonomniscient query agents: this weak inference is the
result of the fact that, different from all other P2P systems based on extensional
mappings between peers, and there is no any dictionary, which contains the set
of all interpeer mappings (it corresponds to a kind of global P2P schema), but
the query agent, when they can access a particular peer can access only its local
semantic mappings to other peers.
2.
We show that the extensionalization function in the actual world h = 𝕜of the in-
tensional FOL ℒω, which defines the extension of all intensional entities of this
logic, interesting for a query answering, can be modeled by the second, lower
“computational” level multimodal logic, where each peer database Pi is charac-
terized by its “know” modal operator Ki. For the computation of the extension of
peer’s concepts in a given actual world we use the “normal” extensional logic. The
global P2P modal logic has two-level accessibility relations: the higher level is the
accessibility relation between peers, determined by the mappings between peers

3.2 Peer-to-peer database systems
|
127
defined by the developer of peer ontologies in public conciliation with other de-
velopers of web peers; This conceptual level is the workspace for query agents in
the web and corresponds to the query rewriting process. The lower level is repre-
sented by the accessibility relations of the S5 epistemic models of each local peer
database; this is the query computation level of the known answer for any peer
database, and can be translated directly to the grid computation nodes.
3.
Finally, we define an object-oriented class for query agents, which implements as
the method for the query rewriting algorithm, able to reformulate the original user
conjunctive query, specified over a peer Pi, in intensionally equivalent queries for
other peers. We show that this algorithm is sound and complete w. r. t. the weak
deduction of the intensional logic ℒω. This issue is much more complex than in ex-
tensional semantics of interpeers mappings (“strong” mappings) [101, 112] where
is possible to use the recursive DATALOG programs for query agents: for the in-
tensional semantics, which cannot be embedded into such extensional logic, we
need a new more general recursive approach based on the mathematical coalge-
bras and nonwell-founded sets [113, 114]. As far as we know, this is the first neces-
sary introduction of these mathematical instruments for query answering prob-
lems in databases, which is not part of the common background of the database
community, and we hope that it would not be serious obstacle for the comprehen-
sion of these techniques.
3.2 Peer-to-peer database systems
In what follows, we will introduce the Peer-to-Peer (P2P) database systems, where
each peer is considered as an independent two-tier architecture, of a data integration
system (specified in Section A.6.4 in the Appendix), with the virtual mediated (global)
schema used for posing the conjunctive queries, and the relations at the data sources,
and we will introduce the basic notion about the intensional FOL logic: Montague’s
and Bealer’s approaches.
P2P systems offer an alternative to traditional client-server systems for some appli-
cation domains. A P2P system has no centralized schema and no central administra-
tion. In P2P systems, every node (peer) of the system acts as both client and server and
provides part of the overall information available from an internet-scale distributed
environment. In this paper, we consider a formal framework based on the following
considerations [115]: what we need here is
–
A mechanism that is able, given any two peer databases, to define mappings be-
tween them, without resorting to any unifying (global) conceptual structure.
–
A completely decentralized network of database peers: all peers serve as en-
try points for search, offering their relational schema in order to formalize user
queries.

128
|
3 Intensional semantics for P2P database systems
–
Query answering, fundamentally based on interactions, which are strictly local
and guided by locally defined mappings of a considered peer w. r. t. other peers.
–
Not limit a priori the topology of the mapping assertions between peers in the
system: we do not impose acyclicity of assertions.
–
A semantic characterization that leads to setting where query answering is decid-
able, and possibly, polynomially tractable.
The last two considerations, decidability and nonacyclicity enforce the reason to use
an epistemic modal logic instead of FOL (see, e. g., [101]) to model P2P systems.
Epistemic multimodal logic framework for peers
We consider that a logic theory for a peer database (see, e. g., [116]) has one or more
minimal 2-valued Herbrand models: because of incomplete or inconsistent informa-
tion in the web we will usually have more than one minimal Herbrand model for a
peer database, one for each possible completion of incomplete information or for each
repairing of the inconsistent information. For generality, we define only a subset of
preferred minimal Herbrand models for a query answering from a peer (e. g., we can
consider only the set of “minimal” repairing for inconsistent information).
In the data integration framework [21], each peer can be seen as global schema,
which integrates incomplete semistructured web sources, with integrity constraints:
such integrity constraints introduce Skolem functions (constants). It is known that
such global schema can have also an infinite canonical database with Skolem con-
stants [117].
In the previous section, it was shown that plausible query answering, such that is
true in each preferred model of a peer database, corresponds to the cumulative non-
monotonic inference [118]; in the limit case when we consider all minimal Herbrand
models, we will have the case of known query answering. Anyway, if we consider the
set of preferred models as the set of possible worlds for a peer database, we obtain that
such query answering corresponds to the S5 modal logic, following Levesque [119] that
we can consider peer Pi as a kind of epistemic logic with universal modal operator Ki
“Peer Pi knows that …” Thus, queries should be formulas in an epistemic modal FOL,
Kiq(x), where q(x) is the original user that defined conjunctive query over the ontology
𝒪i of a peer Pi. Consequently, we consider that each peer database Pi is an independent
epistemic logic theory with incomplete information, such that given some conjunctive
query q(x) over its ontology, responds by known answers (true in all Herbrand mod-
els, and derived from them Tarski’s interpretations, of such a theory). Thus, following
Levesque [119], queries should be formulas in an epistemic modal FOL, with a single
universal modal operator Ki (for “know”). In this chapter, we will consider S5 modal
logic for peers (more details in Definition 36 of Section 3.3): we consider that if some
sentence is known in a peer Pi it is also true. Thus, given a single peer database, the

3.2 Peer-to-peer database systems
|
129
possible words are Herbrand models (legal databases) of this database, each one con-
nected to all others. Thus, a modal query formula at some world Kiq(x) is a believed
(known) iff q(x) is true with all possible words (Herbrand models). In [120], it was
proven that such modal semantics lead to first-order, Prolog-like, query evaluators.
Thus, we consider that each peer database Pi is an epistemic S5 normal modal
logic, where possible worlds are preferred Herbrand models of a peer database with
incomplete/inconsistent information, with an epistemic operator “peer Pi knows,” Ki,
and with relational database schema (ontology) 𝒪i for conjunctive query language.
Such an epistemic semantics of peers is presented in [53] based on the hybrid
mono-modal language with a unique universal modal operator ◻[121], so that where
Ki = @i◻, where new modal operator, @, for this hybrid logic enables to “retrieve”
worlds: A formula of the form @iφ is an instruction to move to the world labeled by
the variable i and evaluate φ there.
Let qPi(x) and qPk(x) be two views (conjunctive queries) over Pi and Pk, respec-
tively, with the same set of free variables x, then we can have two scenarios:
1.
The strong (extensional)multimodal mapping, introducedbyaformulaKiqPi(x) ⇒
KkqPk(x), where ‘⇒’ is the logic implication, used in a single S5 modality [101, 122,
123] (and also in Piazza P2P system [112], where they do not use the autoepis-
temic logic formalism, but they are considering the same query answering based
on certain (that is known) answers [124] from peers), and in K45 multi-modality
[123]. It tells that the knowledge of the peer Pi contained in its view qPi(x) must
be contained in the view qPk(x) of the peer Pk. In this case, this forced transfer
of the local data of one peer to other peers that can render inconsistent knowl-
edge of other peers, and from the semantic point of view, reassembles the kind of
strong data integration system, with a global logic of the whole P2P system and a
recursive datalog for query rewriting [101].
2.
The weak (intensional) mapping [43, 53, 125, 126], defined by the intensional equiv-
alences, denoted by qPi(x) ≈qPk(x). In what follows, we will consider only this
intensional version for P2P mapping based on considerations presented in [43].
The more complete comparative analysis of these two different approaches can
be found in [55].
What is the fundamental difference of these two approaches?
1.
First of all, in the first “strong” mapping case, the instance database of any peer
is strictly dependent of current (in a given instance of time) instance databases of
other peers. That means that we cannot encapsulateapeer asan independent ADT
(Abstract Data Type) and see it as a block module of data during query-answering
processing. Moreover, we need a global logic for all peers in order to determine the
exact extension of one peer database. Thus, also if we do not provide any “global
schema” of a P2P network, semantically we must assume it: the way in which it
is used for conjunctive-query answering as explained in [101], where it is used
as a recursive datalog for this whole P2P logic theory, in order to process a given

130
|
3 Intensional semantics for P2P database systems
conjunctive query over a single peer database. This global P2P datalog program
returns with the union of conjunctive queries for each peer database in the consid-
ered P2P network. Such query-rewriting approach, based on a global P2P recursive
datalog logic theory, avoids to materialize the propagations of facts between peer
databases, caused by material implications, KiqPi(x) ⇒KkqPk(x), between peers:
in web applications, such dynamic (and cyclic) transfer of ground facts between
peer databases practically cannot be accepted, because so high traffic of data in
the internet would drastically slow down the whole web system.
In the second approach, we do not have such problems: each logic theory of a sin-
gle peer database is completely independent from all other peers, and can be en-
capsulated in a modular P2P structure as an ADT (as will be explained in what fol-
lows), so easily implemented in a greed computation framework. Moreover, each
peer is free to change not only its data extension, but also its schema representa-
tion, without invalidating the P2P mapping system.
2.
The second problem is that in the first “strong” approach, the “system” has to
know the whole set of peer databases in the P2P network in any time; otherwise,
no one peer database can know which are other peers that maps the data to-
ward himself: thus, there must exist some centralized control. The addition of
other peer databases must be explicitly communicated to this global system con-
troller. This information is used by the query-answering agent (consequently, ev-
ery query-agent knows the global P2P database schema, different from the de-
clared fact against any globalization) with above described recursive datalog pro-
gram, which contains the whole logic theory of a P2P network. Otherwise, when
any other peer, which was not considered in the actually P2P network, makes one
mapping (by the material implication defined above) toward some existing peer
database in a P2P network, if the “system” (basic part of any query-answering
agent) is not aware of that, the query-answer is incomplete and can be also un-
sound (in the case when this new mapping introduces the mutually inconsistent
information in the P2P network system).
In the second, weak approach, there is no any concept explicitly or implicitly as-
sumed for a global P2P system. Different from the first approach where the map-
pings between peers are part of the underlying “system” (i. e., global logic theory
of the whole P2P network system), the mappings based on intensional equiva-
lences are a local component of a peer: each peer defines its belief set of the cor-
respondent equivalent views of other peers, and the query agent can use these
mappings only when it has access to a particular peer. When the user query is
generated over a schema (ontology) of a given peer, the activated query agent has
no any global knowledge about the whole P2P network system, but can only use
the local mappings of the accessed peer to pass to other locally mapped peers.
3.
The third problem is the inconsistency tolerance. When we consider a peer data-
base as a single data integration system with GLAV (Global/local as views) map-
pings between the data sources and the global (virtual) peer database schema,

3.2 Peer-to-peer database systems
|
131
the problem with mutually inconsistent information from different sources can
be localized and resolved inside the local peer database (its logic theory defined
by the data integration system), by a kind of 2-valued, e. g., in [127, 128], or many-
valued belief revision, e. g., 4-valued Belnap’s bilattice based belief revision [129].
Such approach for the resolution of local inconsistency inside a particular peer
database is valid, just because it is local to a peer, and there is a team of devel-
opers, which are responsible for a correct implementation of this particular peer
database. This handling of local inconsistency of a peer database is common for
both approaches to mapping semantics between different peers. What is problem-
atic in the first “strong” approach is that when each peer database is consistent
by himself (by handling its proper local consistency), the externally mapped data
from other peers into a particular peer database can generate the inconsistency
(in peer databases with integrity constraints) of this particular peer. In the first ap-
proach, such problem is addressed in [123] and does not have an easy, also from
a theoretical point of view, solution: in that approach, it is only partially resolved
by the very strong requirement to simply eliminate any external data coming from
another single peer, which is potentially inconsistent with the information of this
peer. But such drastic approach, which loses a part of information (instead of con-
sidering the mutually inconsistent information as “possible” versions of the same
information), it does not resolve the problem: let us consider, e. g., two different
data, which comes into the same peer from two different peers, and each of these
data, taken singularly, is consistent with the local knowledge of a peer, but these
two data are mutually inconsistent if taken together (e. g., the destination peer
has a key constraint for the attribute x of a relation Person(x,y) where x is name
of a person and y is its age, and two external data, which come from two different
peers are {John, 40} and {John, 41}).
In the weak mapping semantic, instead such problem does not exist, just because
there is not any correlation between extensions of concepts in different peers, but only
intensional mapping between them, based on belief sentences of each local peer. Dif-
ferent from the “strong” approach, where if we adopt the possibility of materializa-
tion of consequences of material implications between peers, an interrogated peer can
completely respond to the user query, in the “weak” approach it is not possible theo-
retically also: each peer who has the knowledge about the user query has to respond
by himself only to the (appropriately rewritten for it) user query; thus, we make an
epistemic difference between the certain answers of the peer interrogated directly by
the user, from the “possible” answers obtained from all other peers. We do not elim-
inate any information, which comes from different peers, but the user who receives
all answers will take the appropriate actions for him to verify the part of information
that he considers mutually inconsistent. It is easy to understand that the complexity
of the “weak” approach, in a presence of mutually inconsistent P2P information, is

132
|
3 Intensional semantics for P2P database systems
less than the complexity of the first-order multimodal logic for the “strong” semantic
mapping.
In what follows, we will consider only this new intensional version for P2P map-
ping better suited for fully independent peers [43]: different from the GLAV (Global-
Local-as-view) strong mappings, here the deductive system of the modal S5 inten-
sional FOL, given a user query, derives all intensionally equivalent queries over other
peers, and there is no any transfer of data from one peer to other, which can introduce
inconsistent information to other peers.
Consequently, what we argue is the full epistemic independency of peer databases
where there is no any forced transfer of a local knowledge of one peer to other peers,
but only their collaboration in order to answer to user queries. They can change their
ontology and/or extension of their knowledge independently from other peers and
without any communication to other peers. In this way, we intend to obtain very ro-
bust P2P systems, able to answer to user queries also when intended mappings be-
tween peers become incompatible with the modified ontologies (relational database
schemas) of peers, but also to have the possibility to map naturally P2P database sys-
tems into greed computation: having fully independent peers, which as we will see
can be represented as ADTs (Abstract Data Types), it is enough to associate each pair
(peer, query-formulae) to a particular resource of greed computing, in order to obtain
the known answer from such peer.
3.2.1 Plausible query-answering inference in a peer database with also
inconsistent information
In what follows, we will consider a peer database as a Data Integration System (DIS)
described in Section A.6.4. Each DIS must be robust enough in order to take in account
not only the incomplete but also inconsistent information of its source databases, typi-
cal in web applications: the extension of source databases change in an unpredictable
way so that in different time instances we pass from a consistent to inconsistent DIS
and vice versa. Thus, DIS will generally have a possibly infinite number of consis-
tent repairs in their models, and consequently, query answering in such DISs is very
complex and time consuming. The current systems adopt the two extreme solutions
for query answering: certain answers (true in all models of a given DIS) or all pos-
sible answers (true at any model). The first solution which uses certain answers is to
much strong requirement and practically nonapplicable in real situations, and the sec-
ond one is less meaningful and time/space consuming (they may be infinite also). In
this section, we provide the middle solution [118] between these two extremes based
on the plausible nonmonotonic query-answering inference. For the rest of this sec-
tion, we will use the basic notions of the deductive logic provided in Section A.2 in

3.2 Peer-to-peer database systems
|
133
the Appendix. The essential idea behind semantic modeling of nonmonotonic infer-
ence goes back to McCarthy’s classical paper on circumscription [130]: the essential
model-theoretic idea is to single out only a subset of “minimal” models. Shoham [131]
generalized the concept of circumscription, or minimal entailment, to a more abstract
notion: preferential entailment. Other approaches are used in order to generalize the
semantics for nonmonotonic reasoning [132–134], based on preference structures and
choice functions, and in [135] is presented the comparison between these two semantic
approaches. In this section is presented a reexamination of a choice function approach.
In the following, we denote the fixed part of a DIS ℐ= ⟨𝒢, 𝒮, ℳ⟩(i. e., without
the extension of its source data bases D) by ℐfix, so that we denote by ℐ= (ℐfix, D).
Informally, ℐfix is the set of sentences (usually universally quantified) of integrity con-
straints over global schema and mapping assertions (sentences). It may be the case
that, for a given source data base extension D, ℐ= (ℐfix, D) is inconsistent. We denote
with D ⊨ℐℐfix the fact that for this extension of a source databases D all integrity con-
straints and mappings are satisfied. In this case, we say that D is consistent w. r. t. ℐfix;
otherwise, we say that D is inconsistent w. r. t. ℐfix.
We denote by U the set of all consistent DISs. It is easy to verify that each model
of a consistent DIS ℐis a ℒ-maximal set of the underlying deductive logic ℒfor data
integration systems. Consider that a models of Γ (the set of sentences of ℒ) are inter-
pretations f : Γ →2, with truth values 2 = {0, 1}, i. e., subset of mappings f ∈2Γ,
which satisfy logical connectives (i. e., f(¬ϕ) = 1 −f (ϕ), f(ϕ ∧ϕ′) = min(f(ϕ), f(ϕ′)),
etc.). Thus, each model m = {ϕ ∈Γ | f(ϕ) = 1} is a closed set (theory in ℒ, such that
m = Cn(m)). The Herbrand model is the restriction of such closed set (i. e., model) m
to only ground atoms.
We define the mapping Mod : U →2Γ, such that for any consistent DIS, ℐ∈U, the
nonempty set Mod(ℐ) is the set of all models for this data integration system ℐ.
Now, following [136], given an extension D, possibly inconsistent with ℐfix, we say
that, for a given extension (instance) D′ of source databases, the DIS ℐ′ = (ℐfix, D′) is
a repair for ℐiff D′ ⊨ℐℐfix.
We denote by R(ℐ) the set of all repairs of ℐ; if ℐis consistent, then R(ℐ) = {ℐ}.
We say that a sentence ϕ holds in a state (i. e., DIS) ℐ∈U (relative to the DIS-
structure ℐℳ) and write ℐℳ⊩ℐϕ iff for every m ∈Mod(ℐ), ϕ ∈m. Intuitively, a
sentence ϕ is true in the state ℐ(consistent data integration system) just in case ϕ is
true in all models (set Mod(ℐ)) of this consistent DIS.
The set of consistent DISs in which ϕ holds will be written ̂ϕ = {ℐ∈U | ℐℳ⊩ℐ
ϕ} = {ℐ∈U | ϕ ∈⋂Mod(ℐ)}, and for a set of sentences Γ:
̂Γ = ⋂{̂ϕ | ϕ ∈Γ} = {ℐ∈U | Γ ⊆⋂Mod(ℐ)},
so by monotonicity of Cn, and the fact that ⋂Mod(ℐ) is a closed set, i. e., ⋂Mod(ℐ) =
Cn(⋂Mod(ℐ)), we obtain

134
|
3 Intensional semantics for P2P database systems
̂Γ = {ℐ∈U | Cn(Γ) ⊆⋂Mod(ℐ)},
i. e., ̂Γ is the set of all DISs in which all sentences in Γ are accepted.
Given a set of consistent DISs, X ⊆U, we may also define the set th(X) of sentences
that are accepted in all DISs in X, i. e., th(X) = {ϕ | X ⊆̂ϕ}.
Proposition 12. For any set X of consistent DISs, the set of accepted sentences th(X) is
a theory in ℒ.
Proof 1. th(X) = {ϕ | X ⊆̂ϕ} = {ϕ | ∀ℐ∈X.ϕ ∈⋂Mod(ℐ)} = ⋂{⋂Mod(ℐ) | ℐ∈X},
thus from the fact that the intersection of closed sets is a closed set, we obtain that
th(X) is a theory. In the singleton case, we obtain the theory th({ℐ}) = ⋂Mod(ℐ), while
th({}) = Γ.
It is easy to verify these two mappings form a Galois connection between 𝒫(Γ) and
𝒫(U), that is held:
1.
if Γ ⊆Δ, then ̂Δ ⊆̂Γ,
2.
if X ⊆Y, then th(Y) ⊆th(X),
3.
Γ ⊆th(̂Γ),
4.
X ⊆?
th(X).
Thus, the mapping Cℐ= ̂_∘th : 𝒫(U) →𝒫(U) is a closure operation on the set of DISs,
that is held for all X, Y ∈U:
1.
X ⊆Cℐ(X) =
?
{ϕ | X ⊆̂ϕ} = ⋂{̂ϕ | X ⊆̂ϕ},
2.
if X ⊆Y, then Cℐ(X) ⊆Cℐ(Y),
3.
Cℐ(X) = Cℐ(Cℐ(X)).
Proposition 13. Each closed (sub)set X ⊆U is the set of all repairs of some data inte-
gration system ℐ. We denote by Uclo the set of all closed subsets of U.
Proof 2. Let X be the set of all repairs of some DIS ℐ1. Let us prove that X = Cℐ(X).
From the property of the closure operator holds that X ⊆Cℐ(X). Let ℐ∈Cℐ(X) and
prove that ℐ∈X.
From ℐ∈Cℐ(X), we have that ℐ∈⋂{̂ϕ | X ⊆̂ϕ} = ⋂{̂ϕ | ℐ′ ∈̂ϕ for all
ℐ′ ∈X}. Suppose that ℐ∉X, i. e., that ℐis not a repair of ℐ1 so that does not satisfy the
constraints in ℐ1, but it is not possible because all members in the set ⋂{̂ϕ | ℐ′ ∈̂ϕ for
all ℐ′ ∈X} satisfy such constraints.
Example 12. For a consistent DIS ℐ∈U, we have that X = {ℐ} = R(ℐ) is closed subset
of U, i. e., {ℐ} = Cℐ({ℐ}).
Let us describe the semantics for plausible query answering in the data integra-
tion system ℐ= ⟨𝒢, 𝒮, ℳ⟩by the following structure.

3.2 Peer-to-peer database systems
|
135
Definition 34 (Prefered repairs). A DIS-structure based on the deductive logic ℒis a
tuple ℐℳ= ⟨U, Mod, F⟩, where F : Uclo →𝒫(U) is a choice function such that for any
inconsistent data integration system ℐtakes its preferred repairs, i. e., for any ℐ∈U
holds:
F(R(ℐ)) ⊆R(ℐ),
where R(ℐ) is a closed subset of U composed by all repairs of ℐ.
Example 13. For a consistent DIS ℐ∈U, we have that R(ℐ) = {ℐ}, thus F(R(ℐ)) =
F({ℐ}) ⊆R({ℐ}) = {ℐ}. So, we obtain that F({ℐ}) = {ℐ}.
Cumulative inference for query-answering in data integration
Instead of the monotonic deduction, presented in the Introduction, we will consider
nonmonotonic inference, considering that generally the query answering in data inte-
gration is nonmonotonic (e. g., when we use a negation operator in query languages,
in the case of incomplete information in sources, or in the case when we consider only
a subset of preferred repairs for mutually inconsistent information coming from dif-
ferent source databases).
The natural way is to relax the monotonicity property by introducing the cautious
monotonicity: it was introduced by Gabbay [137] for finite set of premises (Gentzen-
style), and by Makinson [138] (Tarski-style) for a more general infinite set of premises.
The last one is a necessary condition in the data integration framework: the incom-
plete information introduce Skolem functions and infinite Herbrand bases, so that to-
gether with recursive logic specification of global schema constraints, the models for
databases are possibly infinite.
The following table presents the definition for a cumulative nonmonotonic infer-
ence relation ⊢C and operation CC (reflexivity, cut and cautious monotonicity):
Finitistic or “Gentzen-style” (Table 3.1).
Table 3.1: Finitistic or “Gentzen-style”.
ϕ ∈Γ implies Γ ⊢C ϕ
Γ ⋃Δ ⊢C ϕ, ∀ψ ∈Δ.(Γ ⊢C ψ) implies Γ ⊢C ϕ
∀ψ ∈Δ.(Γ ⊢C ψ), Γ ⊢C ϕ implies Γ ⋃Δ ⊢C ϕ
Infinitistic or “Tarski-style” (Table 3.2).
It is easy to verify that the cut and cautious monotonicity can be combined into a
simple principle of cumulation:
Γ ⊆Δ ⊆CC(Γ)
implies CC(Γ) = CC(Δ)
(3.1)

136
|
3 Intensional semantics for P2P database systems
Table 3.2: Infinitistic or “Tarski-style”.
Γ ⊆CC(Γ)
Δ ⊆CC(Γ) implies CC(Γ ⋃Δ) ⊆CC(Γ)
Δ ⊆CC(Γ) implies Cn(Γ) ⊆CC(Γ ⋃Δ)
or to the following two conditions [132]:
–
Right weakening: if ∀ϕ ∈Δ.Γ ⊢C ϕ, and Δ ⊢ψ, then Γ ⊢C ψ i. e., Cn(CC(Γ)) ⊆CC(Γ)
–
Left logic equivalence: if ∀ϕ.(Γ ⊢ϕ iff Δ ⊢ϕ), then Γ ⊢C ψ iff Δ ⊢C ψ i. e., Cn(Γ) =
Cn(Δ) implies CC(Γ) = CC(Δ)
The common idea in the literature on nonmonotonic reasoning is the following: ϕ is
a nonmonotonic consequence of Γ, i. e., Γ ⊢C ϕ, just in the case α holds in all those
Γ-states (in our case Γ-DISs repairs) that are maximally plausible. Formally, we repre-
sented this idea by introducing a choice function F, which given a set R(ℐ) of all repairs
of DIS ℐ, picks out the set F(R(ℐ)) of all the “best” repairs in R(ℐ).
For the DIS-structure ℐℳ, based on the deductive logic ℒ, we define the following
relation ⊪between sets of sentences and single sentences:
Γ ⊪ϕ
iff
F(̂Γ) ⊆̂ϕ
(3.2)
We have to demonstrate that this relation is a nonmonotonic consequence (or plau-
sible inference). First, this definition will in general lead to ⊪being nonmonotonic,
since there is no guarantee that F(̂Γ) ⊆̂ϕ will imply that F( ?
Γ ⋃{ϕ}) ⊆̂ϕ.
Clearly, one of the best preferred Γ ⋃{ϕ}-states may fail to be a best preferred
member of the more inclusive class of Γ-states. Therefore, it need not be the case that
F( ?
Γ ⋃{ϕ}) ⊆̂Γ. Neither does it follow that F( ?
Γ ⋃{ϕ}) ⊆̂ϕ.
Different choices on the selection function F will give rise to different nonmono-
tonic logics.
Example 14. Let us consider the choice function, in the case of the so-called mini-
mal repairs w. r. t. set inclusion preference criterion [136]: the distance between two
database instances D1 and D2 is their symmetric difference δ(D1, D2) = (D1−D2) ⋃(D2−
D1). It is minimal under set inclusion in the class of instances that satisfy ℐfix.
Another example for the choice function is the minimal cardinality preference cri-
terion [139]: used in order to minimize deletions and insertions of tuples during a re-
pairing.
Let us now show the fundamental property of the introduced relation ⊪from data
integration systems.

3.2 Peer-to-peer database systems
|
137
Proposition 14. If ℐℳis a DIS-structure based on the deductive logic ℒ, then ⊪is a
cumulative inference relation based on ℒ. We define the cumulative operation C by
for any Γ′ ⊆Γ,
C(Γ′) = {ϕ | Γ′ ⊪ϕ}.
Proof. It is an analog to the proof of the Lemma 4.4. in [133].
Let now consider the problem of a plausible query-answering in data integration
systems. Let q(x) ∈ℒQ be a user query over a global schema 𝒢of the (possibly incon-
sistent) data integration system ℐ= ⟨𝒢, 𝒮, ℳ⟩. We can consider the set of sentences
th(R(ℐ)) = {ϕ | R(ℐ) ⊆̂ϕ}, where R(ℐ) is a set of all repairs of ℐ, and define the relation
⊨I as follows:
ℐ⊪I q(c)
iff
th(R(ℐ)) ⊪q(c)
(3.3)
where q(c) is a (ground) sentence obtained by substitution of a variables in x by
database constants in a query formula. Thus, a plausible answer to the query q(x) can
be defined by this cumulative nonmonotonic inference as follows:
q𝒟ℬ= {q(c) | ℐ⊪I q(c), c is a tuple of constants of a fixed DIS alphabet}.
This plausible query answering in DISs is a general one: it holds for any particular
query language ℒQ, any kind of mappings between source databases and a global
schema, and in presence of incomplete and inconsistent information.
Example 15. Let us see that in the case of a consistent DIS, this plausible answering
corresponds to the certain (or known) answering to queries.
When DIS ℐis consistent, then R(ℐ) = {ℐ}, and th(R(ℐ)) = th({ℐ}) = ⋂Mod(ℐ),
thus, for any given query q(x) we have that
ℐ⊪I q(c)
iff
th({ℐ}) ⊪q(c)
iff
F(?
th({ℐ})) ⊆̂
q(c)
(3.4)
So, from the fact that F(?
th({ℐ}) = F(Cℐ(ℐ)) = F({ℐ})) = {ℐ}, and the fact that ̂
q(c) =
{ℐ′ ∈U | q(c) ∈⋂Mod(ℐ′)}, we obtain that must hold
{ℐ} ⊆{ℐ′ ∈U | q(c) ∈⋂Mod(ℐ′)},
i. e., must hold q(c) ∈⋂Mod(ℐ). That is, q(c) must hold in all models of this consistent
ℐ, i. e., q(c) is a certain (or known) answer of this data integration system.
The algorithms for answering queries using views are already incorporated into
a number of data integration systems with integrity constraints to obtain certain an-
swers. The difficulties basically arise because of the need of dealing with incomplete
information and, moreover, with mutually inconsistent information, which comes

138
|
3 Intensional semantics for P2P database systems
from different source databases. So, we presented such general framework for a plau-
sible query-answering inference, based on choice functions. As a result, we obtained
a cumulative nonmonotonic inference for query answering in data integration.
In what follows, we will use this theory for the definition of single database peers
in a network of a given P2P system, by encapsulation in a single peer such as DIS
and able to deal with incomplete information and with mutually inconsistent infor-
mation, which comes from different source databases, and we will mathematically
present each such peer as an abstract data object able to respond to user’s queries by
plausible (known) answers.
3.2.2 Abstract object types for peer databases
The current world wide web has well over billions of pages, but the vast majority
of them are in human-readable format only (e. g., HTML). As a consequence, soft-
ware agents cannot understand and process this information, and much of the po-
tential of the web has so far remained untapped. In response, researchers have cre-
ated the vision of the semantic web [88], where data has structure and ontologies that
describe the semantics of the data. An ontology specifies a conceptualization of a do-
main in terms of concepts, attributes and relations [140], and thus introduce the medi-
ator schema for user queries, and consequently, data integration systems. When data
is marked up using mediator schemas (ontologies) software query agents can better
understand the semantics and, therefore, more intelligently locate and integrate data
for a wide variety of tasks [115, 141].
Information integration is the problem of combining the data residing at different
sources, and providing the user with a unifiedview of these data, called globalschema.
The global schema is therefore a reconciled view of the information, which can be
queried by the user. It can be thought of as a set of virtual relations, in the sense that
their extensions are not actually stored anywhere. A data integration system frees the
user from having to locate the sources relevant to a query, interact with each source
in isolation and manually combine the data from different sources.
Two basic approaches have been used to specify the mapping between sources
and the global schema. The first approach, called query centric or global-as-view
(GAV), requires that the global schema is expressed in terms of the data sources. More
precisely, to every concept of the global schema, a view over the data sources is as-
sociated, so that its meaning is specified in terms of the data residing at the sources.
The second approach, called source centric or local-as-view (LAV), requires the global
schema to be specified independently of the sources. The relationships between the
global schema and the sources are established by associating each element of the
sources with a view over the global schema. Thus, in the LAV approach, we specify
the meaning of the sources in terms of the concepts in the global schema.

3.2 Peer-to-peer database systems
|
139
The natural way to make more modular structure of a data-intensive internet sys-
tem, and to open up the possibility of effective query answering techniques is to orga-
nize a number of application-domain data integration systems as a P2P system. The
most important advantage of organizing a peer as a data integration system is that it
enables users to focus on specifying what they want, rather then thinking about how
to obtain the answers: so that we can see it as an Abstract Object Type (AOT), which
hides internal integration structure with data sources, and offers to users only a me-
diator schema with the standard query language in order to be able to formulate the
questions in a declarative way.
As result, it frees the users from the tedious tasks of finding the relevant data
sources, interacting with each source in isolation using a particular interface, and
combining data from multiple sources.
The main characteristic distinguishing data integration systems from distributed
and parallel database systems is that data sources underlying the system are au-
tonomous. In particular, a data integration system provides access to preexisting
sources, which were created independently.
The aim of the encapsulation of a data integration system into an Abstract Object
Type (AOT) is to hide the internal structure of such complex object and to offer to the
user the rich ontology of the global (mediator) schema in order to focus on specifying
what they want, by ordinary conjunctive queries.
The main point is that every peer can be seen as an AOT (Abstract Object Type),
which acts at the same level, with no unifying structure above it: in order to respond to
the complex user queries (union of conjunctive queries). Thus, we assume that expres-
sive power of peers can be generally given by a single-encapsulated data integration
semantic. In this way, considering the (incomplete) sources extracted by wrappers, we
may enrich the peer database schema by integrity constraints in order to overcome in-
completeness of heterogenous web information: we assume that each AOT peer has a
unique model or otherwise a canonical (universal) [142, 143] global database, and that
responds to user queries by certain (i. e., known [120]) answers.
–
Query reformulation: A user of an AOT poses queries in terms of the mediated
schema, rather than directly in the data sources, which are encapsulated and
hidden by AOT. As a consequence, the AOT must contain a module that uses the
source descriptions in order to reformulate a user query that refers directly to the
schemas of the sources. Clearly, we would like the reformulation to be sound, (i. e.,
the answers to the reformulated query should all be correct answers to the input
query), and complete (i. e., all the answers that can be extracted from the data
sources should be in the result of applying the reformulated query): the methods
of this AOT, which satisfy these requirements give to users the known answers.
–
Wrappers: The other layer of an AOT that does not exist in a traditional system
is the (hidden) wrapper layer. Unlike a traditional query execution engine that
communicates with a local storage manager to fetch the data, the query execu-
tion plan in the AOT must obtain data from remote sources. An encapsulated AOT

140
|
3 Intensional semantics for P2P database systems
wrapper is a program (method), which is specific to a data source, whose task is
to translate data from the source to a form that is usable by the query processor
(agent) of the system.
Dually to the theory of algebraic specifications where an Abstract Data Type (ADT) is
specified by a set of operations (constructors), the coagebraic specification of a class
of systems, i. e., Abstract Object Types (AOT), is characterized by a set of operations
(destructors), which tell us what can be observed out of a system-state (i. e., an ele-
ment of the carrier), and how can a state be transformed to successor state. Recently
[144], the coalgebraic semantics are extended to the logic programming, thus to the
specification of database ontologies.
We start introducing the class of coalgebras for database query-answering systems
by Definition 133 in the Appendix (Section A.6.2). They are presented in an algebraic
style, by providing a cosignature. In particular, sorts include one single “hidden sort,”
corresponding to the carrier of the coalgebra, and other “visible” sorts for inputs and
outputs, which are given a fixed interpretation. Visible sorts will be interpreted as sets
without any algebraic structure defined on them. Coalgebraic terms, built only over
destructors, have for us a precise interpretation as the basic observations that one can
make on the states of a coalgebra. Input sorts are considered as the set ℒQ of modal
conjunctive queries, Kiq(x), while output sorts are “valuations,” i. e., the set of a re-
sulting views, for each query q(x) over a database 𝒜(considered as a carrier of the
coalgebra).
In object-oriented terminology, the coalgebras just introduced are expressive
enough to specify parametric methods and attributes for a database (conjunctive)
query answering systems. In what follows, we conceive a peer Pi as a AOT software
module characterized by a network ontology Gi expressed in a language ℒ𝒪over an
alphabet 𝒜𝒢i. The internal structure of a peer database is hidden to the user, encap-
sulated in the way that only its logical relational schema 𝒢Ti can be seen by users, and
is able to respond to the union of conjunctive queries by known answers [111].
3.2.3 Database P2P network definition
In order to be able to share the knowledge with other peer Pj in the network 𝒩, each
peer Pi has also an export-interface module ℳij composed by groups of ordered pairs
of intensionally equivalent views (conjunctive queries over peer’s ontologies), de-
noted by (qi, qj), or equivalently, by qi(x) ≈qj(x), such that qi is a view defined over
DB schema of peer Pi and qj over Pj. The extension of such a view qi(x) is usually the
set of known (certain) answers to this conjunctive query, that is ground atoms q(c),
which are true in all preferred Herbrand models of a peer database Pi.

3.2 Peer-to-peer database systems
|
141
Notice that (qi, qj) does not mean that qi logically implicates qj or vice versa, as
in extensional mapping definitions, based on material implication. So, the syntax [53]
for the database P2P can be given as follows.
Definition 35. The P2P network system 𝒩is composed by 2 ≤N independent peers,
where each peer module Pi is defined as follows:
Pi =def ⟨𝒪i, ⋃
i ̸=j∈N
ℳij⟩
where ℳij is a (possibly empty) interface to other peer Pj in the network, defined as
a group of intensionally equivalent query connections, denoted by (qij
1k, qij
2k) where
qij
1k(x) is a conjunctive query defined over 𝒪i, while qij
2k(x) is a conjunctive query de-
fined over the ontology 𝒪j of the connected peer Pj:
ℳij = {(qij
1k, qij
2k) | 1 ≤k ≤|ij|}
and |ij| is the total number of query connections of the peer Pi toward a peer Pj.
Intuitively, when a user defines a conjunctive query over the ontology 𝒪i of the
peer Pi, the intensionally equivalent concepts between this peer and other peers will
be used in order to obtain the answers from a P2P system.
They will be the “bridges,” which a query agent can use to rewrite the original
user query over a peer Pi into intensionally equivalent query over other peer Pj, which
has different (and independent) ontology from the peer Pi.
The answers of other peers will be epistemically considered as possible answers
because they are based on the belief, which has the peer Pi about the knowledge of a
peer Pj: this belief is formally represented by supposition of a peer Pi that the pair of
queries (qij
1k, qij
2k) ∈ℳij is intensionally equivalent.
Example 16. Let us consider the acyclic P2P system in a Figure 3.1, with the peers: Pi,
with the ontology 𝒪i and the interface
ℳij = {(vim, vjm) | vim ≈vjm, and 1 ≤m ≤k}
toward the peer Pj with the ontology 𝒪j.
The idea is the following: given a query qi(x) over a peer Pi, a query agent
will rewrite (if it is possible) the identical query Ψ(vi1, . . . , vik) over the set of views
{vi1, . . . , vik} of a peer Pi, then it will use the set of intensional equivalences vim ≈
vjm, 1 ≤m ≤k, to obtain the intensionally equivalent query Ψ(vj1, . . . , vjk) over the set
of views {vj1, . . . , vjk} of a peer Pj, and then it will rewrite this query into the identical
query qj(x) over the ontology 𝒪j of the peer Pj.
The known answers of both peers Pi, Pj to the queries qi(x) and qj(x) will constitute
the subset of the global P2P answer to the original user query; other possible answers

142
|
3 Intensional semantics for P2P database systems
Figure 3.1: P2P database system.
to the same user query can be obtained by the similar method from the intensionally
equivalent queries over a peer Pk obtained from intensional mappings from Pi to Pk
and from Pj to Pk, respectively.
For example, all currently used integrity constraints (as the key and the foreign
key constraints) in a global schema are valid integrity constraints in order to use also
intensional semantics for the mapping between peer databases.
There is a number of different context-dependent scenarios for a query-answering
with intensional semantics, as in human society: for example, the confidential sce-
nario where an interviewer can interview a single person at time (we will denominate
it as a pure P2P context), or a conference scenario where an interviewer can interact
with a number of persons at a time and possibly integrate partial knowledge of them
in order to obtain the answer.
Let us consider the simplest scenario: the pure P2P context. Informally, given a
conjunctive query φ(x) over a peer Pi, the answer to this query of the whole P2P sys-
tem, w. r. t. intensional semantics is the union of known answers from this peer, and
(known) answers of all other peers, which have intensionally equivalent to φ(x) virtual
predicates. It corresponds to the query-answering paradigm in a society of individu-
als: given a question φ(x) to some person Pi, and its beliefs about the knowledge of
other persons in this society, the interviewer can obtain the answer from Pi and from
other persons who know something about the same concept φ(x). In the real-world
environment, the answer of other persons (in different languages) can be considered
certain also, but in the virtual P2P database framework their answer is mediated by
the belief of the Pi w. r. t. the knowledge of other peers, which may be imperfect, so
the answers of other peers are epistemically different, i. e., they can be epistemically
considered as possible answers.

3.3 Modal intensional FOL for P2P systems
|
143
3.3 Modal intensional FOL for P2P systems
As we have discussed in Chapter 1, the distinction between intensions and extensions
is important especially because we are now able to have an equational theory over
intensional entities, i. e., predicate and function “names,” that is separate from the
extensional equality of relations and functions. Thus, intensional FOL has the simple
Tarski first-order semantics, with a decidable unification problem, but we need also
the actual world mapping, which maps any intensional entity to its actual world ex-
tension. In what follows, we will identify a possible world by a particular mapping,
which assigns to intensional entities their extensions in such possible world. We have
see in Chapter 1 that the direct relationship between Bealer’s nonreductionistic and
Montague’s possible worlds (𝒲e) approach to intensional logic can be given by the
bijective mapping
ℱ: 𝒲e ≃ℰ
where ℰis a set of possible extensionalization functions corresponding to explicit pos-
sible worlds (up to the previous isomorphism). Such a correspondence, not present in
original intensional theory [23], is a natural identification of intensional logics with
modal Kripke based logics.
Each extensionalization function h ∈ℰassigns to the intensional elements of 𝒟
an appropriate extension as it was presented in Chapter 1. Among the possible func-
tions in ℰ, there is a distinguished function 𝕜, which is to be thought as the actual ex-
tensionalization function: it tells us the actual extension of the intensional elements
in the world w0 = ℱ−1(𝕜). The syntax and semantics of the intensional FOL algebra
𝒜int = (𝒟, Id, Truth, {conjS}S∈𝒫(ℕ2), neg, {existsn}n∈ℕ) of the minimal FOLℐ(Γ) has been
presented in Definition 16.
Definition 36. The intensional logic for P2P database systems is that described in Ex-
ample 3 in Section 1.3, obtained as an enrichment of minimal intensional FOL by
“high-level” modal operator ̂♦of S5 modal logic such that operator ¬̂♦¬ is a well-
known “necessity” modal operator w. r. t. the accessibility relation ̂
ℛ= 𝒲e × 𝒲e. So,
the Kripke model of this intensional logic is the extension of the ℳFOLℐ(Γ) in Defini-
tion 15,
̂
ℳ=def (̂
𝕎, {ℛi}, ̂
ℛ, 𝒟,̂IK)
with a set of (generalized) possible worlds ̂
𝕎= IT(Γ) × 𝒟𝒱, where 𝒲e = IT(Γ) is the
set of explicit possible worlds (Tarski’s interpretations), and for each possible world
w = (I∗
T , g) ∈̂
𝕎we have also (w. r. t. the first 4 satisfaction rules in Definition 15) this
fifth rule for “high-level” modal operator ̂♦,
5.
̂
ℳ󳀀󳨐IK,g ̂◊φ iff exists I∗′
T ∈𝒲e such that (I∗
T , I∗′
T ) ∈̂
ℛand ̂
ℳ󳀀󳨐I∗′
T ,g φ.

144
|
3 Intensional semantics for P2P database systems
This modal FOL for P2P database systems we will denote by ℒω(Γ) and its syntax al-
gebra, obtained from 𝒜int by addition of the new modal “high-level” operator ̂♦, we
will denote by 𝒜+
int.
These semantics are similar to the algebraic semantics for ℒω in [27] for the case
of the conception where intensional entities are considered to be identical if and only
if they are necessarily equivalent. Intensional identity is much stronger that the stan-
dard extensional equality in the actual world, just because it requires the extensional
equality in all possible worlds.
Example 17. Let two predicate formulae ϕ(x) and ψ(x) be intensionally equal, i. e.,
I(ϕ(x)) = I(ψ(x)), then for any h ∈ℰholds that h(I(ϕ(x))) = h(I(ψ(x))), i. e., have the
same extension, thus
ϕ(x) ≡ψ(x) is true
iff
(ϕ(x) ⇒ψ(x)) ∧(ψ(x) ⇒ϕ(x)) is true
in each world ℱ−1(h).
Consequently, ̂◻(ϕ(x) ≡ψ(x)) is true (where ̂◻for the S5 modal logic in Defini-
tion 36 is a universal “necessity” operator equal o ¬̂♦¬), and from the definition holds
the intensional identity for their intensional abstracts, ⋖ϕ(x) ⋗x=⋖ψ(x) ⋗x, and fi-
nally from (1.22), g∗(⋖ϕ(x) ⋗x) = I(ϕ(x)) = g ∗(⋖ψ(x) ⋗x) = I(ψ(x)).
Vice versa, if ̂◻(ϕ(x) ≡ψ(x)) then ⋖ϕ(x) ⋗x=⋖ψ(x) ⋗x, and we obtain that
I(ϕ(x)) = I(ψ(x)), and consequently, ϕ(x) and ψ(x) are intensionally equal. So, the
modal formula ̂◻(ϕ(x) ≡ψ(x)) corresponds to the intensional equality of ϕ(x) and
ψ(x).
Consequently, from Corollary 3 in Section 1.3, any two first-order open formu-
lae, ϕ(x1, . . . xn) and ψ(x1, . . . xn), are intensionally equivalent iff ̂♦ϕ(x1, . . . xn) and
̂♦ψ(x1, . . . xn) are intensionally equal, i. e., from (1.11),
ϕ(x1, . . . xn) ≈ψ(x1, . . . xn)
iff
̂♦ϕ(x1, . . . xn) ≡̂♦ψ(x1, . . . xn)
and we have the following conjunctive extension of the intensional equivalent logic
formulae with formulae with built-in predicates:
Proposition 15. Let C(x) be a logic formula defined from built-in predicates (ex, ≤, ≥,
etc.), then
ψ1(x) ≈ψ2(x)
implies (C(x) ∧ψ1(x)) ≈(C(x) ∧ψ2(x))
Proof. Immediately from the fact that a built-in formulae ϕ(x) has constant extension
in any possible world (Tarski’s interpretation I∗
T ) in 𝒲e.
Based on this intensional equivalence “≈,” we can define the following quotient
algebra.

3.3 Modal intensional FOL for P2P systems
|
145
Definition 37 (Intensional quotient algebra). This intensional equivalence “≈” de-
fines the quotient algebra 𝒜+
int/≈for a quotient-intensional first-order logic ℒω/≈, as
follows:
Given an intensional logic ℒω(Γ) with a basic, user defined, set of intensional
equivalences Seq ⊆Γ, and its deductive inference relation ⊢in of the S5 modal logic
with intensional equality theory, then for any virtual predicate ϕ(x) with tuple of free
variables x = {x1, . . . , xk}, we obtain an intensional-equivalence class
𝒞= {ψi(x) ∈ℒω(Γ) | ℒω(Γ) ⊢in ψi(x) ≈ϕ(x)}.
For any ϕ(x) ∈𝒜int/≈, the quotient intensional entity for this equivalence class, its
extension in a world I∗
T = w ∈𝒲e (with h = F(w) and h ∘I = I∗
T ) is defined by
F(w)(I(ϕ(x))) = {d ∈𝒟k | ψi(d) is true in w, ψi(x) ∈𝒞}
= ⋃
ψi∈𝒞
ℱ(w)(I(ψi(x))) = ⋃
ψi∈𝒞
I∗
T (ψi(x))
(3.5)
This definition of equivalence relation is the flat-accumulation case presented in
[43, 53]: if the first predicate is true in some world, then the second must be true in
some world also, and vice versa. Each equality is also intensional equivalence, but
not vice versa. In what concerns this paper, we will consider only the actual world
w0 = ℱ−1(𝕜). Moreover, the set of basic intensional equivalences are designed by
users, and we will not verify if they satisfy the modal formula used to define the in-
tensional equivalence: the definition above is of theoretical interest but useful to un-
derstand the meaning of the intensional equivalence, and the “omniscient” inference
relation ⊢in, able to deduce all other intensional equivalences from the given basic set.
The formal semantic framework for P2P database systems, presented previously in
[53] as a hybrid modal logic, in this section will be defined as quotient (by intensional
equivalence) intensional FOL. We will consider only the actual world w0 = ℱ−1(𝕜),
correspondent to the extensionalization function h = 𝕜of the intensional FOL ℒω(Γ):
the actual world for ℒω(Γ) corresponds to the actual extension (corresponding to a
current Tarski’s interpretation of the modal FOL logic theory of all peers Pi) of peer
databases. When a user defines a conjunctive query q(x) over an ontology 𝒪i of a peer
database Pi, the answer to this query is computed in this actual world w0, i. e., for
the Tarski’s interpretation I∗
T = w0 ∈𝒲e = IT(Γ), and hence in the actual extension
of all peer databases in a P2P network 𝒩= {Pi | 1 ≤i ≤N} where the extension
of each predicate pk
i (x1, . . . , xk) (corresponding to a given relational table r of a peer
database schema) is equal to relation R = I∗
T (pk
i (x1, . . . , xk)) = 𝕜(I(pk
i (x1, . . . , xk))) ⊆𝒟k
where I : ℒω →𝒟is a fixed intensional interpretation of logic formulae (into the PRP
domain in Definition 6, Section 1.2).
Definition 38 (Intensional embedding of P2P database systems). Let 𝒲0 = {Pi | 1 ≤
i ≤N} be a P2P database system. The intensional FOL ℒω(Γ) for a P2P network 𝒲0 (the

146
|
3 Intensional semantics for P2P database systems
FOL quantifiers are necessary for definition of the integrity constraints of each peer
database), with a given intensional mapping I : ℒω(Γ) →𝒟, is composed by:
1.
The set of basic intensional concepts must contain the disjoint union of entities
corresponding to the predicates (relations) of all peers SI = ⨄1≤i≤N{I(pk
i (x1, . . . ,
xk)) | r = pk
i ∈𝒪i}. Other intensional concepts has to be defined for each logic
formula (virtual predicate) in ϕ(x1, . . . , xk) ∈ℒw used to define the peer databases,
so that I(ϕ(x1, . . . , xk)) ∈Dk, k ≥1.
2.
The particulars of the domain, D−1, corresponds to the disjoint union of domains
of peer databases. The intension-in-proposition part, D0, contains also the dis-
joint union of peer’s Herbrand bases.
3.
The basic set of the equivalence relation ≈is defined as a disjoint union for each
peer Pi as follows: if (qij
1k, qij
2k) ∈ℳij, then qij
1k(x) ≈qij
2k(x), where qij
1k(x) is a view
(query) over peer Pi ontology (DB schema) and qij
2k(x) is a view over peer Pj ontol-
ogy. It is considered to be an axiom in Γ of ℒω,
(̂♦qij
1k(x) ≡̂♦qij
2k(x)) ∈Γ
The complete answer to a conjunctive query q(x), over a given peer Pi, is equal to the
extension of the quotient-intensional concept given by (3.5) in Definition 37, whose
equivalence class 𝒞is determined by the deductive omniscient closure of ⊢in, in the
quotient intensional P2P logic ℒω/≈.
The quotient modal intensional FOL ℒω/≈(its algebraic counterpart is a Linden-
baum–Tarski algebra) is fundamental for query answering in intensional P2P database
mapping systems: given a query q(x) over a peer Pi, the answer to this query is defined
as the extension of the intensional concept I(q(x)), in the intensional P2P logic ℒω/≈.
While this logical omniscience of the embedding of P2P database systems may
be acceptable in the study of theoretically perfect query-agent reasoners, any model
or belief with this property will be unacceptable for representing resource and time
bounded query agents.
In real web applications, we will never have omniscient query agents that will con-
temporarily have the complete and whole knowledge about all ontologies of all peers.
Such a supposition would generate the system with a global and centralized knowl-
edge, in contrast with our pragmatic and completely decentralized P2P systems with
completely independent peers, which can change their local ontology in any instance
of time without informing any other peer or “global” systems about it. Thus, what we
will consider for a query-agent reasoning system is a weaker form of deduction than
⊢in, of this ideal omniscient intensional logic inference, more adequate for the limited
and local knowledge of query agents about the peers.
What we consider is that a query agent will begin its work for a given user query
q(x) over a peer Pi, and by using only the local knowledge about this peer’s ontology
and the set of its local intensional mappings toward other peers, will be able to move to

3.3 Modal intensional FOL for P2P systems
|
147
the locally-next peers to obtain answers from them also. This context-sensitive query
answering is an analog to the human query answering: the interviewer will ask the
indicated person and will obtain his known answer, but this person can tell also which
other people, he believes are able to respond to this question also. It will be the task
of the interviewer to find other people and to reformulate the question to them. It is
practically impossible to have all people who know something about this question to
be in a common interaction one with all others to combine the partial knowledge of
each of them in order to provide the complete possible answer to such question.
This context dependent and locally-based query answering system is partially de-
scribed in Example 18. In the next section, we will define the weaker deductive infer-
ence relation also, denoted by ⊪, for the intensional FOL ℒω(Γ) of a P2P system in
Definition 36, such that the query answering algorithm used by these nonomniscient
query agents, is complete w. r. t. this intensional logic deductive system.
3.3.1 Bridge rules for local contextual deduction
It is well known that the standard epistemic logics used to model the agents suffer
from the omniscience problem. That is, an agent is logically omniscient if it knows
all of the valid formulae, and its knowledge is closed under logical equivalence (or
alternatively under logical implication). On the standard epistemic, possible worlds
model, we must assume that an agent can derive all consequences of a belief in an
instant, i. e., without computational effort.
We investigate why this might be a problem for real-life agents, especially when
the standard possible worlds model poses a problem for agents with a big number
of large databases, as we will have in semantic web applications and P2P databases.
Agents may establish immediately certain logical truths or simple consequences of
what they consciously assented to. However, there are highly remote dispositional
states, which could only be established by complex, time-consuming reasoning. The
modal framework cannot distinguish between a sentence that an agent consciously
assented to and a piece of potential knowledge, which could never be made actual by
the agent and is therefore not suited to model resource-bounded reasoning.
Whose aim is it to develop a usable logic in which they can reason about an
agent’s beliefs that commonly distinguish semantic from syntax approaches? The
former expresses the agent’s beliefs in a modal language with a modal operator for
belief, whereas the later uses a metalanguage, containing a belief predicate, to talk
about an agent’s beliefs.
Instead of epistemic modal operator for belief, in this section, we will use the “be-
lief” predicate of this intensional logic, as in the syntax approach [145, 146]. But in our
case, instead of using a singular referring term name as in classic extensional FOL, to
denote the sentence φ an agent is believing, we will use intensional abstract term,
which contains the whole structure of the sentence in composite algebraic form (the

148
|
3 Intensional semantics for P2P database systems
denotation of such abstract terms is an algebraic formula with the denotations of all
subcomponents of the original sentence, i. e., it has a recursive denotation definition).
We can use also the approach in [147], which takes a set of sentences in the internal
language of an agent (in our case it is the language for conjunctive queries), which
we can view as initial assumptions (in our case the set of intensional equivalences
between views of the actual peer database toward other peers), to comprise an agent’s
knowledge base. We combine this approach with the contextual reasoning [109, 148–
150], by considering, for instance, contexts as peer databases: each peer database is
a (local) context for a query agent. It can access to the local knowledge of this peer,
during a query-answering process, and also to the set of local bridge rules [150] of this
peer. We can consider the whole P2P database system, composed by a number of peer
databases, as a knowledge base, which contains a set of interacting contexts P1, . . . PN
(peer databases). The kind of bridge rules, of a context (peer) Pi toward the peer Pj, is
of the form:
vi : Pi
vj : Pj
where vi
≈vj are intensionally equivalent views (conjunctive queries) of a peer
database Pi and Pj, respectively. This rules allow us to bridge deductions in Pi to
deductions in Pj by allowing us to derive vj in Pj just because we have derived vi in Pi.
So, for any context, the query agent uses the subset of deduction rules ρ(Pi), derived
from a context Pi, in order to derive new information. We write Γ ⊢ρ(Pi) ϕ to denote
that ϕ is deducible from Γ using the rules assigned by ρ(Pi). A formula ϕ is said to be
believed by an agent, which Konolige writes Bϕ, where B is a belief modal operator,
iff it is in an agent’s belief set B, iff it is either in the agent’s initial knowledge base Γ
or else is derivable form the knowledge base by applying the agent’s deduction rules:
Bϕ
iff
ϕ ∈B
iff
ϕ ∈Γ or Γ ⊢ρ(Pi) ϕ
(3.6)
As Konolige, we assume the deductive closure of an agent’s belief set B w. r. t. the
agent’s deduction rules, i. e.,
If
B ⊢ρ(Pi) ϕ
and
B ⋃{ϕ} ⊢ρ(Pi) ψ,
then B ⊢ρ(Pi) ψ
(3.7)
The property of the deductive closure should not be confused with that of logical om-
niscience: if the deduction rules are logically incomplete, then there will be sentences
that are logical consequences of the base set and yet not in the belief set. Thus, deduc-
tive closure is a much weaker notion than closure under logical consequence of the in-
tensional FOL theory for P2P system. In what follows, we will call it “local contextual
deduction”: in general, agents modeled in the framework of the deduction model are
not logically omniscient because the rules they use, to derive new sentences in their
belief set, are in some respect incomplete because they are context-dependent. But if

3.3 Modal intensional FOL for P2P systems
|
149
an agent has a complete set of deduction rules, then all logical consequences of an
agent’s base beliefs will be in the belief set.
The contextual reasoning has some similarities with the Labeled Deduction Sys-
tem (LDS) [151]. In the LDS approach, the basic unit of a deductive process is not just
formulae but the labeled formulae, where the labels belong to a given “labeling al-
gebra” (which represents the additional information), and are explicitly incorporated
into the object language. In the contextual reasoning, we have no explicit labels asso-
ciated with logic formulae, and even more, we have no all inference rules (bridges),
which a deductive system can use in its deduction. We have standard logic formulae
but at each context only the subset of context dependent inference rules can be used
for a (nonlabeled) deduction. Also, there is not any centralized place where we can see
how are partitioned rules in different contexts. Thus, the deduction process is similar
to the traveling in an unknown country without any global map, by using only local
indications (actual context) in order to take the next decisions, which depends on the
traveler’s objectives (here it is represented by a user query).
The context of a peer Pi represents the whole information contribution of other
peers to the local knowledge of this peer, and consequently, can be used during the
query answering: given any conjunctive query φ(y) over a peer Pi in a world w, first we
compute the set of certain answers, and after that also the set of intensionally-possible
answers obtained from the information contribution from other peers, i. e., from the
context 𝒞(Pi) of the considered peer Pi. Thus, the answer to a query over a given peer
is context-dependent. By changing the context of a peer, we will obtain different set
of possible answers: the syntax of the interface module of a peer is a specification
for such context. For each peer, there are at least two modalities in order to obtain
intensionally possible answers:
1.
Atomic or pure P2P query answering: in this case, each peer can have a num-
ber of contexts, each one for a distinct interface toward another peer. The query
agent has to try to completely reformulate the original query φ(y) (specified over a
peer Pi) for any other peer Pj if in ℳij are specified bridges between Pi and Pj (i. e.,
if |ij| ≥1 in Definition 35). Then a peer Pj will be able to respond with its answers.
In this case, we define the context of Pi by 𝒞(Pi) = ℳij.
2.
Data integration P2P query answering: we can consider partial answers from all
contextual peers for a given peer Pi, defined in its interface module. The query
agent will assemble (join) the partial answers from them in order to obtain possi-
ble answers. In this case, we define the unique complete context as follows:
𝒞(Pi) = {(qil(xl), {qjl(xl) | (qil(xl), qjl(xl)) ∈ℛ}) | qil(xl) ∈π1(ℛ)}
where ℛ= ⋃1≤j≤N ℳij, and π1 is a first projection.
In what follows, we will consider the atomic case only.

150
|
3 Intensional semantics for P2P database systems
Definition 39 (Single bridge rule). For a given context 𝒞(Pi) = ℳij, we define its de-
duction model as follows:
1.
It is composed by the logic theory, ℒω,Pi for the single peer Pi, a disjoint component
of total P2P logic theory ℒω(Γ) obtained by embedding a P2P database system into
intensional FOL (from Definition 38), with only the interface ℳij to the peer Pj.
2.
For any query q(x) over a peer Pi, intensionally equivalent to the conjunctive query
C(x) ∧vi1 ∧⋅⋅⋅∧vik, where {vi1, . . . , vik} = π1({(vi1, vj1), . . . , (vik, vjk)}) ⊆π1(ℳij) is a
subset of views over Pi, and C(x) is a logic formula defined from built-in predicates
only (see Proposition 15) with the variables in x = (x1, . . . , xn), we introduce in ρ
the following deductive bridge rule:
(vi1 ≈vj1, . . . , vik ≈vjk, q(x) ≡(C(x) ∧vi1 ∧⋅⋅⋅∧vik)) : Pi
(q(x) ≈C(x) ∧vj1 ∧⋅⋅⋅∧vjk)) : Pj
(3.8)
Intuitively, the logic theory ℒω,Pi ⊂ℒω(Γ), is the logic of the “pure” peer Pi with
only the interface module toward a peer Pj, which for a given query q(x) over its on-
tology 𝒪i, is able to deduce if there is an intensionally equivalent query over its views
contained in the interface module 𝒞(Pi) = ℳij. If such deduction there exists (in prac-
tice for that we can use the perfect query-rewriting algorithms [99]), i. e., if ℒω,Pi ⊢in
q(x) ≈(C(x) ∧vi1 ∧⋅⋅⋅∧vik), then it is possible to use the bridge rule in order to derive,
intensionally equivalent to user query, the query C(x) ∧vj1 ∧⋅⋅⋅∧vjk overviews of the
other peer Pj.
We can introduce the reasoning capabilities of the query agents, able, for a given
user query q(x) over a peer Pi, to infer other query formulae, intensionally equivalent
to q(x) over the ontologies of other peers in a given P2P database system. Let us show
the way how we define the belief set B of the agent, composed by the intensionally
equivalent queries over peer databases to user’s query q(x), by using the bridge rules
in Definition 39.
Example 18 (One step local contextual deduction between two peers). Let
us
con-
sider the cyclic P2P system in Figure 3.2, with two peers: Pi, with the ontology 𝒪i
and the interface ℳij = {(vim, vjm) | vim ≈vjm, and 1 ≤m ≤k1} toward the peer Pj,
and the peer Pj, with the ontology 𝒪j and the interface ℳji = {(wjm, wim) | vjm ≈
vim, and 1 ≤m ≤n1} toward the peer Pi. In what follows, the bottom index of a query
identifies the peer relative to such a query.
Let qi(x) be the original user’s conjunctive query over the ontology 𝒪i of the peer
database Pi, and the query agent takes its first context 𝒞(Pi) = ℳij = {(vim, vjm) | vim ≈
vjm, and 1 ≤m ≤k1}. If we obtain the following logic equivalence eq1,
ℒω,Pi ⊢ρ(Pi) qi(x) ≡Ψ(vi1, . . . , vik)
(3.9)
where Ψ(vi1, . . . , vik) denotes a conjunctive formula C(x) ∧vi1 ∧⋅⋅⋅∧vik, then the agent
can use the bridge rule (3.8) in order to derive, intensionally equivalent to user query,

3.3 Modal intensional FOL for P2P systems
|
151
the query Ψ(vj1, . . . , vjk) equal to conjunctive formula C(x) ∧vj1 ∧⋅⋅⋅∧vjk overviews of
the other peer Pj, i. e.,
ℒω,Pi ⊢ρ(Pi) qi(x) ≈Ψ(vj1, . . . , vjk)
(3.10)
In the next step, the query agent will try to take the next context of the current peer Pi,
but there is no other nonelaborated previously context of this peer, and hence, based
on the precedent bridge rule, will pass from the peer Pi to the peer Pj, and will take its
context
𝒞(Pj) = ℳji = {(wjm, wim) | vjm ≈vim, and 1 ≤m ≤n1}.
We assume that when the agent changes the context, all intensional equivalences
where at least one argument is a query formula contained in its belief set B, are pre-
served together with its belief set in B. If for some query formula qj(x) over the ontology
of a peer PJ, hold the following logic equivalence eq2:
ℒω,Pj ⊢ρ(Pj) qj(x) ≡Ψ(vj1, . . . , vjk),
(3.11)
and hence from (3.9), (3.10) and (3.11) we obtain the intensional equivalence qj(x)qj(x),
between queries over two different peers Pi and Pj, which can be inserted into the
agent’s belief set B, i. e.,
(̂♦qi(x) ≡̂♦qj(x)) ∈B
(3.12)
This query-agent reasoning corresponds to the top-horizontal arrow in Figure 3.2.
Figure 3.2: Derivation of intensionally equivalent queries.
The analog process can be described for the bottom-horizontal arrow in Figure 3.2.
At the end of deduction, the set of intensionally equivalent queries over peers in
a P2P database system is equal to the set

152
|
3 Intensional semantics for P2P database systems
SI =
⋃
(̂♦qi(x)≡̂♦qj(x))∈B
{qi(x), qj(x)}
(3.13)
This set of queries SI is the set of intensional queries directly over peers ontologies
(database schemas) as a subset of the equivalent class 𝒞for the given initial user query,
which in the intensional FOL ℒω/≈is represented by the quotient intensional entity
Q(x), whose extension (from Definition 37) in the actual world w0 is defined by equa-
tion (3.5).
Remark. This query-answering process is valid also for the union of conjunctive
queries. In fact, given two intensional equivalences between conjunctive queries,
qi1 ≈qj1 and qi2 ≈qj2, we have that (qi1∨qi2) ≈(qj1∨qj2), from the fact that the S5 modal
intensional FOL is a normal modal logic where it holds that ̂◊(A ∨B) ≡(̂◊A ∨̂◊B).
Theorem 3. The local contextual deductive inference of a query agent at a peer Pi, ⊢ρ(Pi),
is a sound weakening of the omniscient deductive inference ⊢in of the S5 modal inten-
sional FOL, for the P2P database system ℒω with the peer databases, which does not
contain the integrity constraints in the form of negative clauses ¬A1 ∨⋅⋅⋅∨¬Am, m ≥2.
Proof. By structural induction on the number of conjuncts in the expression, it is
enough to prove for expressions composed by two conjuncts.
From the definition in (1.37) for a given Tarski’s interpretation I∗
T = w ∈𝒲e of the
intensional FOL and the commutativity I∗
T = h ∘I for fixed intensional interpretation I
and the extensionalization function h = ℱ(I∗
T ) = ℱ(w), we have that
lub(ϕ(x)) =def
⋃
w∈𝒲e
ℱ(w)(I(ϕ(x)))
(3.14)
so that we have from (1.36) and (1.38),
ϕ(x) ≈ϕ1(x)
iff
̂◊ϕ(x) ≡̂◊ϕ1(x)
iff
lub(ϕ(x)) = lub(ϕ1(x))
(3.15)
Let b1, b2 be any two (virtual) predicates over a peer Pi, qi1(x, y) and qi2(y, z), respec-
tively, and c1, c2 (equal to qj1(x, y) and qj2(y, z), respectively) any two (virtual) predi-
cates over a peer Pj, such that bi ≈ci ⋗, i = 1, 2. We have to prove that lub(φ(x, z)) =
lub(ψ(x, z)), where
φ(x, z) ≡(qi1(x, y) ∧qi2(y, z))
and
ψ(x, z) ≡(qj1(x, y) ∧qj2(y, z)).
From the facts that lub(qi1(x, y)) = lub(qj1(x, y)) and lub(qi2(y, z)) = lub(qj2(y, z)), we
define the set
SL = {(a, c) | ∃b.((a, b) ∈lub(qi1(x, y)) ∧(b, c) ∈lub(qi2(y, z)))}
= {(a, c) | ∃b.((a, b) ∈lub(qj1(x, y)) ∧(b, c) ∈lub(qj2(y, z)))}.

3.3 Modal intensional FOL for P2P systems
|
153
Let us prove that
lub(φ(x, z)) = ⋃
w∈We
{(a, c) | ∃b.((a, b) ∈ℱ(w)(I(qi1(x, y))) ∧(b, c) ∈ℱ(w)(I(qi2(x, y))))}
is equal to SL: First, from
ℱ(w)(I(qik(x, y))) ⊆lub(qik(x, y)),
k = 1, 2,
it holds that lub(φ(x, z)) ⊆SL.
Let us prove that also lub(φ(x, z)) ⊇SL, i. e., that for any (a, b) ∈SL also (a, b) ∈
lub(φ(x, z)).
Let us suppose that there is one (a, c) such that (a, c) ∈SL but (a, c) ∉lub(φ(x, z)),
i. e., that for all possible worlds for this P2P system,w ∈𝒲e,holdsthat π2(ℱ(w)(I(qi1(a,
y)))) ⋂π1(ℱ(w)(I(qi2(y, c)))) = {} (is empty), where π1, π2 are the first and the second
projections. That is, the following logic formula must hold ¬qi1(a, y)∨¬qi2(y′, c)∨¬(y =
y′).
But such constraint (negative clause) cannot exist in this class of peers, and hence
the supposition is false, and we conclude that SL = lub(φ(x, z)).
By the same way, we obtain that SL = lub(ψ(x, z)), thus φ(x, z) ≈ψ(x, z), and the
bridge rules of the query agents,
(vi1 ≈vj1, . . . , vik ≈vjk, q(x) ≈(C(x) ∧vi1 ∧⋅⋅⋅∧vik)) : Pi
(q(x) ≈(C(x) ∧vj1 ∧⋅⋅⋅∧vjk)) : Pj
are valid deductions also for the omniscient S5 modal intensional FOL ℒω of a P2P
system: thus ⊢ρ(Pi), is a sound weakening of the omniscient deductive inference ⊢in.
It is easy to verify, from vi1 ≈vj1, . . . , vik ≈vjk we conclude that (vi1 ∧⋅⋅⋅∧vik) ≈(vj1 ∧
⋅⋅⋅∧vjk), and from Proposition 15 we obtain that (C(x)∧vi1∧⋅⋅⋅∧vik) ≈(C(x)∧vj1∧⋅⋅⋅∧vjk);
from the fact that q(x) ≈(C(x)∧vi1 ∧⋅⋅⋅∧vik) and the transitivity of equivalence relation
“≈,” we deduce that q(x) ≈(C(x) ∧vj1 ∧⋅⋅⋅∧vjk).
3.3.2 Nonomniscient weak intensional inference
A query agent can use the “bridge rules,” described previously, to derive from the
original user query over a peer Pi, a new intensionally-equivalent query over another
peer Pj, which has different (and independent) ontology from the peer Pi. In this sec-
tion, we propose just this method presented in Example 18 to implement for the query
agents the local contextual logic inference ⊢ρ(Pi) formalized previously by the rule
bridges (3.10) and by query-rewriting methods for the logic equivalences (3.9) and
(3.11).

154
|
3 Intensional semantics for P2P database systems
The answers of other peers will be epistemically considered as possible answers
because they are based on the belief, which has the peer Pi about the knowledge of a
peer Pj. This belief is formally represented by supposition of a peer Pi that the pair of
queries (qij
1k, qij
2k) ∈ℳij (used for the bridge rules) is intensionally equivalent.
We discussed previously the necessity to employ nonomniscient query agents,
which can use only some local P2P information in order to answer to user queries.
In such context-dependent query answering, the answer to the query depends of the
topology of the P2P network, with the intensional equivalences (the “bridges”) be-
tween the peers, so that for equivalent queries, but formalized over different peers we
will generally obtain different answers. Thus, the semantics for this weaker form of
deduction of intensional equivalences, i. e., intensional equivalent queries over other
“contextual” peers, w. r. t. the user interrogated peer Pi, can be formally expressed by
deduction chains, which begin from a peer Pi.
However, each local contextual logic inference ⊢ρ(Pi) depends on a particular peer
Pi and of only a small part of intensional FOL logic ℒω,Pi of the total P2P database sys-
tem intensional FOL logic ℒω(Γ). We need to define the global nonomniscient (weak)
intensional inference relation valid for the whole logic P2P theory ℒω(Γ).
Proposition 16. Given an intensional logic ℒω(Γ) for a P2P system (in Definition 36),
with a basic, user defined, set of intensional equivalences Seq ⊆Γ, and its deductive
inference relation ⊢in, then we define the weak intensional inference relation ⊪for ℒω(Γ),
as follows:
–
ℒω(Γ) ⊪φ(x) ≈ϕ(x) iff there is a chain ψ1, ψ2, ψ3 . . . , ψ3n+1 of the formulae with
the same set of free variables in a tuple x but each of them expressed by relation
symbols of only one particular peer’s ontology, such that ψ1 corresponds to φ, ψ3n+1
corresponds to ϕ and ψi(x) ≅i+1 ψi+1(x), for ‘≅3i’ equal to intensional equivalence ‘≈’
used in local bridge deductions (3.10); to (strong) equivalence ‘≡’ otherwise (used
in query-rewriting local deductions (3.9) and (3.11)).
ψ3i−2(x) and ψ3i+1(x) are the queries over two different peer’s ontologies, and
ψ3i−1(x), ψ3i(x) over views of these peers, respectively, for 1 ≤i ≤n.
–
Such chains for the intensional logic ℒω(Γ) of a P2P database system are finite, and
holds that
ℒω(Γ) ⊪φ(x) ≈ϕ(x)
implies
ℒω(Γ) ⊢in φ(x) ≈ϕ(x)
but not vice versa.
Proof. This proposition, as in Example 18, tells us that two formulae, over any two
peer’s ontologies, with the same free variables, are intensionally equivalent, if there
is a chain of the formulae, identical or intensionally equivalent, and these two formu-
lae are initial and final formulae of such a chain. From the transitive property of the

3.3 Modal intensional FOL for P2P systems
|
155
equivalence, we obtain that initial and final formula in this chain are intensionally
equivalent.
The finite chain property for P2P systems is the result of the fact that, also in pres-
ence of cyclic mappings between peers, the number of different conjunctive queries
but intensionally equivalent, which can be expressed by the finite set S of views of a
peer Pi, used for an intensional mapping toward the peer Pj (i
̸= j), is always finite:
the number of subsets of this set S of view, sufficient to formalize the intensionally
equivalent conjunctive formula, is finite. So, the “bridge” passage from Pi to Pj during
the derivation of new intensional equivalences, can be used only a finite number of
time.
Moreover, this proposition explains the way in which this weak deduction of the
intensional FOL is able to derive the intensionally equivalent formulae from the basic
set (explicitly defined by a peer’s developers) of intensionally equivalent formulae:
in our case, from the set of intensionally equivalent views (conjunctive queries) over
different peers (see point 3 of Definition 38).
Proposition 17. Let for two queries of the same peer Pi we obtain ℒω(Γ) ⊪qi(x) ≈q′
i(x),
from a finite chain ψ1, ψ2, . . . , ψn (from the Proposition 16) of the formulae with the same
tuple x of free variables, such that
–
ψ1 corresponds to qi(x),
–
ψ2 corresponds to conjunctive query over peer’s views Ψ(v1, . . . , vk) (obtained by a
query-rewriting algorithm from qi(x)), with ψ1(x) ≡ψ2(x) (logic equivalence (3.9)),
–
ψn−1 corresponds to conjunctive query Φ(v1, . . . , vk)
–
ψn corresponds to q′
i(x) (obtained by query-unfolding algorithm from Φ(v1, . . . , vk)),
with ψn−1(x) ≡ψn(x) (logic equivalence (3.11)),
where conjunctive queries Ψ and Φ have the same set of views v1, . . . , vk.
Then for the extensionalization function 𝕜of the actual world w0 ∈𝒲e,
𝕜(I(q′
i(x))) ⊆𝕜(I(qi(x)))
(3.16)
Proof. It comes directly for all user conjunctive queries without built-in predicates:
two conjunctive queries with the same set of predicates and the same set of variables
in the query head are identical. In the case when the user query contains also a de-
rived built-in predicate C(x), we can take out this formula from the rest of query, and
consider the intensional equivalence only for such reduct without built-in predicates,
based on Proposition 15: at the end of derivation of the intensional equivalence class,
w. r. t. this reduct query, we can add to each conjunctive formula of this equivalence
class the formula “∧C(x).” The chain of derivations can only add some new conjunc-
tion of built-in predicates, thus we will obtain that Φ(x) ≡Ψ(x) ∧C1(x), where C1(x)
can be also empty. So,

156
|
3 Intensional semantics for P2P database systems
𝕜(I(Φ(v1, . . . , vk))) ⊆𝕜(I(Ψ(v1, . . . , vk))),
and hence from the logic equivalence with the two queries, initial and final in a chain,
we obtain (3.16).
This proposition tells us that any two intensionallyequivalentconjunctivequeries,
with the same set of virtual predicates (views v1, . . . , vk of a peer Pi) and the same set
of variables in the head of these two queries, the second derived query (in a given
chain of derivations) is extensionally contained in the first, so that we can stop the
propagation of deductions and to discard Φ(v1, . . . , vk), and hence also q′
i(x).
As a consequence of Propositions 16 and 17, given a query q(x) over a peer Pi, the
set of different conjunctive queries (such that one is not subsumed in other), but inten-
sionally equivalent to q(x), over any peer Pk is a finite set. This means that in principle
we are able to define a complete query rewriting algorithm for finite P2P database sys-
tems w. r. t. the weak deduction ⊪of the intensional FOL ℒω(Γ).
In what follows, we will consider that each single peer database (such as DIS) is
able to deal with incomplete information and with mutually inconsistent information,
which comes from different source databases, and we will mathematically present
such query answering by using the coalgebras able to respond to the user’s queries
by plausible (known) answers.
3.4 Sound and complete query derivation of intensional
equivalence-classes
The implementation of query answering in P2P systems needs a standard mathemat-
ical semantics based on an adequate (co)algebra, as for example, is the relational
(co)algebra for SQL query answering in relational databases. Here, the computation is
more intricate because of complex epistemic logic structures of peers and necessity of
query rewriting algorithms Rew (Minicon for the rewriting of query in the equivalence
(3.9) and Unfolding for the equivalence (3.11), for example).
We consider that the rule of the query agent is to start and to maintain a complete
query answering transaction: this transaction starts when it is given a user query q(x)
over a peer Pi. The query agent provides the Rew algorithm in order to construct inten-
sionally equivalent rewritten queries over other peers and then calls the grid compu-
tation network to calculate answers, by assigning to each grid computation node one
peer with a union of rewritten conjunctive queries for it. The transaction ends when
query agent receives the answers from all grid nodes, and presents collected (cumu-
lative) answers to the user. Note that the query agent does not extract the answers
to these rewritten queries from the peers, but for it is responsible the abstract object
types with its methods formally provided by a coalgebra as presented in Section 3.2.2
and Definition 133 in the Appendix.

3.4 Sound and complete query derivation of intensional equivalence-classes
|
157
So, the definition of this P2P query computing system, which abstracts all not nec-
essary implementation details, has to be given in an abstract (co)algebraic mathemat-
ical language; this abstract mathematical specification (coalgebraic abstract type) can
be successively implemented in any current grid computing system.
But the query answering for intensionally based P2P mappings cannot be embed-
ded into recursive datalog, as in the case of a standard view-based mappings based
on a material implication [101], so we need a more complex and general mathemati-
cal framework for it.
3.4.1 Final coalgebra semantics for weak intensional deduction ⊪
The Kripke structure of the frame ℱ= (̂
𝒲, {ℛi}, ̂
ℛ), given in Definition 36, is a pre-
requisite in order to obtain a coalgebraic semantics for query answering in the P2P
database framework. (Co)algebras provide a unifying view on a large variety of dy-
namic systems such as transition systems, automata, data structures and objects [152,
153] or Kripke models; they are especially useful for the dynamic query answering P2P
systems. Consequently, for whoever is not familiar with these mathematical instru-
ments, it will be useful to present the formal definition for coalgebras (see also Sec-
tion A.5, the category Set).
Definition 40 (Abstract coalgebras). Let Set be a category with its objects all (small)
sets and its arrows all functions, and T be an endofunctor T : Set →Set. A T-coalgebra
is a pair of a (small) set C and a Set-arrow α : C →TC, i. e., (C, α : C →TC).
T is called a signature functor or type, and C a carrier set. Let (C, α) and (D, β) be
T-coalgebras, and f : C →D a Set-arrow. f is said to be a morphism of T-coalgebras or
T-morphism, if β ∘f = Tf ∘α. It is an isomorphism if it is a bijective mapping.
Note that, instead, for T : Set →Set, a T-algebra is a pair of a (small) set C and an
arrow α : TC →C, i. e., (C, α : TC →C). If (D, β) is a T-algebra as well, and f : C →D a
Set-arrow, then f is a morphism of T-algebras, if f ∘α = β ∘Tf .
Example 19. Aczel’s semantics of CCS [113], is described by the coalgebra k : Prog →
𝒫fin(Act × Prog), of the endofunctor T = 𝒫fin(Act ×_ ) with the set of actions a ∈Act,
such that k(P) = {⟨a, P′⟩| P →ai P′} is the set of atomic transitions, which the CCS
program P can perform and pass to the new program P’. The symbol 𝒫fin is the finite
powerset operator. This semantics exploits the special final coalgebra theorem, that is
a unique homomorphism k@ : (Prog, k) →(gfp(T), ≃) to the final coalgebra, which is
a isomorphic (bijective) coalgebra: ≃: gfp(T) →𝒫fin(Act × Prog) with gfp(T), greatest
fixed point of T, the set of (infinite) labeled transition systems (labeled trees), which
are the greatest fixed points of the “behavioral functor” T = 𝒫fin(Act ×_ ), i. e., for every
program P, k@(P) = {⟨a, k@(P′)⟩| P →ai P′}, such that the following diagram:

158
|
3 Intensional semantics for P2P database systems
Prog
k@ ? gfp(T)
T(Prog)
k
?
T(k@)
? T(gfp(T))
≃
?
commutes. Final coalgebras are “strongly extensional,” i. e., two elements of the final
coalgebra are equal iff they are T-bisimilar.
The semantics above for the CCS and its properties can be generalized to arbi-
trary behaviors: in our case, for a given conjunctive query language ℒQ over relational
symbols of the P2P database system, we consider the programs as pairs (Pi, qi(x)) (a
query over a peer Pi ∈𝒲0), where 𝒲0 is the set of peers introduced by Definition 38,
can be considered as a program. The execution of this program will return the known
answers to this query, so that Prog = 𝒲0 × ℒQ, the set Act = {⊪3} as a singleton,
with the only deductive action ⊪3 (restriction of ⊪for chains of length 3 only), so that
𝒫fin(Act × Prog) can be substituted by 𝒫fin(Act × Prog), i. e., in our case T = 𝒫fin.
In what follows, we will denote by qij(x) the j-th query of the i-th peer Pi. Thus,
we can consider the intensional deduction process, defined in Proposition 16, as a co-
lalgebra k : 𝒲0 × ℒQ →𝒫fin(𝒲0 × ℒQ), such that, given an initial query qi1(x) ∈ℒQ
over a peer Pi that is a pair (Pi, qi1(x)) ∈𝒲0 × ℒQ, the inferential step will generate the
complete set k(Pi, qi1(x)) = {(Pj, qjn(x)) | ℳij is not empty } ∈𝒫fin(𝒲0 × ℒQ), where
qjn(x) ≈qi1(x) if can be derived an intensional-equivalent query qjn(x) over a peer Pj
(i. e., if ℒω(Γ) ⊪3 qi1(x) ≈qjn(x)); otherwise, qjn(x) = 0 is an empty query.
We can use 𝒫fin because the P2P system is composed by a finite number N of peers,
so that for any peer Pi the number of accessible peers for it is finite.
By recursively applying the function k, equivalent to the single application of the
unique homomorphism k@, we obtain a possibly infinite transition relation (tree) (see
Figure 3.3) with a root in the initial state (that is program): we consider the general
case of cyclic mappings of the P2P system as in Figure 3.2.
This tree will have a lot of nodes with empty queries, and possibly infinite copies
of nodes (with the same query over a given peer). So, we need to “normalize” this
unique solution of the weak deduction, by eliminating duplicates and nodes with an
empty query.
Consequently, we define the mapping, which generates for each peer Pi the com-
plete set of deduced queries for it (from the set of pairs (Pi, qik) in a given tree in
gfp(𝒫fin)), fl : gfp(𝒫fin) →𝒫fin(𝒲0 × 𝒫(ℒQ)), such that, given the unique solution
(a tree) k@(Pi, qi1(x)), and for each peer Pk the set of queries Sk = {qkn(x) | (Pk, qkn(x)) ∈
k@(Pi, qi1(x))},
fl(k@(Pi, qi1(x))) = {(Pk, Sk) | 1 ≤k ≤N},
(3.17)
where N ≥2 is the number of peers in 𝒲0.

3.4 Sound and complete query derivation of intensional equivalence-classes
|
159
Figure 3.3: Weak deduction solution.
In this way, we will obtain for each peer the set of all conjunctive queries, intensionally
equivalent to the user query qi,1(x). This set of queries for a given peer is complete (the
largest equivalence relation class, i. e., the closure C⊪(ℒω(Γ), qi1(x)) of the inference ⊪,
defined by q(x) ∈C⊪(ℒω(Γ), qi1(x)) iff ℒω(Γ) ⊪qi1(x) ≈q(x)) w. r. t. the intensional FOL
logic ℒω(Γ) and its weak deductive inference ⊪for intensionally equivalent formulae.
3.4.2 Sound and complete query rewriting algorithm with respect to weak
deduction ⊪
The P2P query one-step rewriting algorithm is defined by the following composition of
the three different algorithms corresponding to the three inference steps, of the logic
equivalence (3.9), which uses the algorithm “MiniCon,” of the “bridge” intensional
equivalence (3.10), which uses the algorithm “Subst” (the substitution of the views of a
peer Pi with intensionally equivalent views of the peer Pj), and of the logic equivalence
(3.11), which uses the algorithm “Unfolding” in the Example 18,
Rew =def Unfolding ∘Subst ∘MiniCon,
(3.18)
where ∘is the sequential composition for algorithms (as specified in the Appendix for
the composition of arrows in a category), can be described as follows (see the Exam-
ple 18):
1.
Given a conjunctive query q(x) over a peer Pi, by using the set of intensional equiv-
alences in its interface ℳij = {(vim, vjm) | vim ≈vjm, and 1 ≤m ≤k1} toward a peer
Pj (see Definition 35), in the case when such set is not enough for the complete and
equivalent rewriting [154], returns with the empty query qjn(x) = 0 for the peer Pj.
Otherwise it uses the MiniCon algorithm [154] over the set of views in {vi1, . . . , vik} ⊆
π1ℳij, to rewrite equivalently a query q(x) into a query Ψ(vi1, . . . , vik).

160
|
3 Intensional semantics for P2P database systems
2.
After that, it makes the substitution of views of Pi in {vi1, . . . , vik} by an intension-
ally equivalent set of views of Pj in {vj1, . . . , vjk}, to obtain the intensionally equiv-
alent query formula Ψ(vj1, . . . , vjk) over views of Pj.
3.
Finally, it uses the unfolding algorithm [154], to unfold Ψ(vj1, . . . , vjk) and to obtain
the query qjn(x) over the ontology of a peer Pj. Notice that in the case when the
ontology of Pj is changed, so that the set of views vi1, . . . , vik in the interface ℳij
of the peer Pi does not match with this new ontology of Pj, the algorithm returns
with the empty query, i. e., with qjn(x) = 0.
In order to have a decidable complete query answering, we need to prove that the set
of all rewritten queries for each peer is finite. After that, we need to prove that it termi-
nates, and returns with the same solution as the unique solution of the final coalgebra
for the weak deduction. In what follows, we define also the following functions for a
list of queries:
1.
“ln” (length) denotes the function which returns with a number of elements in a
list L = ⟨qi1(x), qi2(x), . . . , qin(x)⟩of queries over a peer Pi, so that ln(L) = n. For the
empty list ⟨⟩, we have that ln(⟨⟩) = 0.
2.
“push” is the function, which inserts the query ϕ over a peer Pi as the last element
of this list, i. e., push(L, ϕ) = ⟨qi1(x), qi2(x), . . . , qin(x), ϕi(n+1)(x)⟩.
Our aim now is to define the query agent in an object-oriented style, as a class, by
–
A coalgebra [152], st = ⟨fin, next⟩: X →B + X, with final map fin : X →B and
recursive map next : X →X, of a deterministic system for a polynomial functor
T = B + _ for a one-step query rewrite algorithm Rew in (3.18).
–
The set B = 𝒫fin(𝒲0×𝒫fin(ℒQ)) of termination values of query rewriting algorithm,
defined as the set of finite queries for each peer.
–
The set of internal states X = (LsQ × ℕ)𝒲0 of this query agent class. Each state is
the function f : 𝒲0 →LsQ × ℕ, which maps any peer Pi ∈𝒲0 into a list of con-
junctive queries over this peer in LsQ (LsQ is the set of lists L composed by possible
conjunctive queries over the alphabet of the P2P system), and to the pointer k ∈ℕ,
which defines the position of the last elaborated query for this peer. We denote by
πm, m = 1, 2, . . . the m-th projections, so that for any peer Pk, π1f (Pk) is the list of
its queries, and π2f (Pk) is the pointer to the last elaborated query in this list.
Such a query agent class is instantiated into a query agent objectby using the “new”
operation, performed by a user when he defines a query over a peer Pi, denoted by the
injective mapping in Set category new : 1 󳨅→X, where 1 = {∗} is the singleton set (the
terminal1 object in Set). This operation “new” specifies the initial state f0 of the agent
1 For any object in a category, there is a unique arrow from it to terminal object. So, in category Set,
for any set S there is a unique function from it into the terminal object 1.

3.4 Sound and complete query derivation of intensional equivalence-classes
|
161
object, f0 = new(∗) ∈X. So, it is a function f0 : 𝒲0 →LsQ × ℕ, such that for a given
initial user query qi1(x) over a peer Pi, for any Pk ∈𝒲)0 we have that
f0(Pk) = { (⟨qi1(x)⟩, 0),
if k = i
(⟨⟩, 0),
otherwise
(3.19)
where ⟨⟩denotes an empty list, and hence every query agent object (instance of this
object-oriented class) can be denoted as a couple (st, f0).
The polynomial functor T(X) = B + X, where + is the operation of the set union,
has the final coalgebra semantics [152], with gfp(B+_ ) = 𝒫fin(𝒲0×𝒫(ℒQ)), the infinite
extension of B when for each peer in W0 we can have also infinite number of queries,
so that B + gfp(B + _ ) = gfp(B + _ ) and holds the bijection ≃for the final coalgebra of
the functor T = B + _ as presented in commutative diagram of Example 19.
We denote the unique solution of the deterministic system st = ⟨fin, next⟩: X →
B + X (corresponding to the one-step query rewriting coalgebra), where next : X →X
is a recursive operation on the states in X and fin : X →B is the final execution of the
one-step rewriting mapping “st,” by the unique homomorphism between this coalge-
bra and the final coalgebra, i. e., st@ : (X, st) →(gfp(B + _), ≃); this homomorphism
corresponds to the top commutative diagram in the next diagram after the theorem.
The one-step query rewriting coalgebra
The coalgebra mapping, st, specifies the method of this query agent class for the one-
step query rewriting algorithm Rew (3.18) as follows: given an initial state f0 ∈X, the
st terminates with a result of query rewriting algorithm if all queries of every peer are
elaborated, and are not generated new queries; otherwise st, when it elaborates a first
non-elaborated query qkm(x) of a peer Pk, can generate the set of new intensionally
equivalent queries over other peers, and passes (deterministically) to the next state in
X = (LsQ × ℕ)𝒲0. Formally, for any state f : 𝒲0 →LsQ × ℕ,
st(f) = { fin(f) = {(Pk, {qkn | qkn ∈π1f (Pk)}) | Pk ∈𝒲0} ∈B,
if Nd = 0
next(f) = f1 : 𝒲0 →LsQ × ℕ, with f1 ∈X
otherwise
(3.20)
where Nd =def ∑Pi∈𝒲0 ln(π1f (Pi)) −π2f(Pi) corresponds to the final execution fin :
X →B of the st and fin(f) transform the final list into the set of rewritten queries. Note
that in the bottom line, the function f1 ∈X = (LsQ × ℕ)𝒲0 increments only the pointer
for next query to be elaborated in the list Lk of queries of Pk, i. e., if (Lk, n) = f (Pk)
then we obtain that f1(Pk) = (Lk, n + 1), and for each Pj locally (directly) “connected”
by intensional “bridge” to this Pk, with (Lj, m) = f (Pj) and l = ln(Lj),
f1(Pj) = { (push(Lj, qj(l+1)), m),
if ε (from Proposition 17)
f (Pj),
otherwise
(3.21)

162
|
3 Intensional semantics for P2P database systems
where qj(l+1) = Rew(πn(π1f (Pk)), Pj) is a one-step query rewriting of the n-th query of
peer Pk into the intensionally equivalent query over peer Pj if it is possible, or qj(l+1) is
empty query 0 otherwise (if rewriting is not successful), while ε denotes the following
condition:
qj(l+1)
̸= 0
and
∀1≤i≤l¬(qj(l+1) = πi(π1f (Pj))),
(3.22)
i. e., after one-step rewriting for a peer Pj, if it is successful and different from all
queries previously rewritten for the same peer, then this new query is added to the
set of rewritten queries for this peer.
We have the following simple property.
Proposition 18. The mapping next : X →X is monotonic w. r. t. the ordering ⪯such that
for any two internal agent’s states f1, f2 ∈X = (LsQ × ℕ)𝒲0,
f1 ⪯f2
iff
∀Pi ∈𝒲0(π1(f1(Pi)) ⊆π1(f2(Pi))).
For the least fix point for this “next-consequence-operator” of f0 = new(∗), denoted by
lst(f0), it holds that st@(f0) = st(lst(f0)).
Notice that this algorithm works well also for union of conjunctive queries: it works
well for Unfolding and MiniCon [154], while for Subst works from the fact that for a
normal modal logic holds ◊(A∨B) ≡◊A∨◊B. Instead, the Subst works for conjunctive
queries and the class of peers defined as follows.2
Proposition 19 ([43]). Let us consider the class of peers with the integrity constraints,
which does not contain negative clauses of the form ¬A1∨⋅⋅⋅∨¬Am, m ≥2. Then the inten-
sional equivalence is preserved by conjunction logic operation, i. e., if φ ≡(b1 ∧⋅⋅⋅∧bk),
k ≥1, is a conjunctive query over a peer Pi, and bi ≈ci, 1 ≤i ≤k, the set of intension-
ally equivalent views toward a peer Pj, then φ ≈ψ, where ≡is a logic equivalence and
ψ ≡(c1 ∧⋅⋅⋅∧ck) is the conjunctive query over a peer Pj.
We are able to define the mapping pop : X →𝒲0 × ℒQ between domains of the
query agent class coalgebra and deductive coalgebra, such that, for any f ∈X, i. e.,
f : 𝒲0 →LsQ × ℕ, with qin = πn(π1(f(Pi))),
pop(f) = { (Pi, π1f (Pi)),
if ln(π1f(Pi)) = 1 and ∀Pk ∈𝒲0.(π2f(Pk)) = 0
(P1, 0),
otherwise
(3.23)
where in (P1, 0) ∈𝒲0 × ℒQ the symbol 0 ∈ℒQ denotes an empty query, such that
k(P1, 0) = (P1, 0), and hence also k@(P1, 0) = (P1, 0), so that the weak deduction di-
agram (see next diagram) commutes as well, and hence this prefixed choice (with
2 See also Theorem 3 in Section 3.3.1.

3.4 Sound and complete query derivation of intensional equivalence-classes
|
163
empty query for a given peer) in equation (3.23) works well. That is, for (P1, 0) ∈𝒲0×ℒQ
by weak deduction for an empty query we do not deduce any other query.
For the first case above, when f is equal to f0 =def new(∗), we obtain from (3.19)
that (Pi, π1f (Pi)) = (Pi, π1f0(Pi)) = (Pi, qi1(x)) ∈𝒲0 × ℒQ, i. e., to the initial user’s query
qi1(x) over the peer Pi, so that by equalizer we obtain that the tree of all weak de-
ductions of intensionally equivalent formulae generated from this initial query corre-
sponds to all queries obtained by the query-rewriting algorithm, as follows.
Theorem 4. The query answering algorithm implemented by the query class st : X →
B + X will terminate for any user conjunctive query q(x) over a peer Pi. It is a sound and
complete algorithm w. r. t. the weak deduction inference ⊪of the intensional logic ℒω(Γ)
for a P2P database system. That is, for any user query action new, holds that
st@ ∘new = fl ∘k@ ∘pop ∘new
or, equivalently, any user’s action “new,” such that the initial agent’s state f0 = new(∗)
defines a conjunctive query q(x) over a peer Pi, is an equalizer (Section A.5 in the Ap-
pendix, for Set category with the limit LimE equal to terminal object 1 and h equal to
monomorpfism (injective function) “new”) of the functions st@ and fl ∘k@ ∘pop, i. e.,
graphically in the Set category:
1 ⊂new
? (LsQ × ℕ)𝒲0
st@
?
fl ∘k@ ∘pop
?
gfp(B + _ )
The meaning of this equalizer is that for any given initial query qi1(x) over a peer Pi,
the set of intensionally equivalent queries for any peer in the P2P system obtained by the
weak deduction ⊪is equal to the set of queries obtained by the query rewriting algorithm
Rew.
Proof. The query rewriting algorithm is sound, because it derives intensionally equiv-
alent queries. From the fact that it derives the subset of the intensionally equivalent
queries over peers, w. r. t. the weak deductive inference ⊪, which for a given finite P2P
system derives only a finite number of equivalent queries (from Propositions 16, 17), we
conclude that it must terminate. Let us now sketch the completeness proof for a given
user action new, which specifies a query qi1 over a peer Pi, such that f0 = new(∗), and
(Pi, qi1) = pop(f0): We can focus only on nonempty queries:
1.
Let (Pk, qkl), with qkl
̸= 0, be a node in the tree k@(Pi, qi1) ∈gfp(𝒫fin). So, there
is a chain (path) from the root of this tree (Pi, qi1) to this node: the set of mu-
tually different nodes with nonempty queries in this path must be finite num-
ber n. Thus, there is a maximal number m ≤n of consecutive executions of the
query rewriting method st, denoted by stm = nextm, so that qkl ∈π1(f (Pk)) for
f = stm(f0) = nextm(f0). So, there exists (Pk, S) ∈st@(f0) (a unique solution for the
user query in f0, with f0(Pi) = qi1) such that qkl ∈S.

164
|
3 Intensional semantics for P2P database systems
2.
Vice versa, let (Pk, S) ∈st@(f0) (a unique solution for the user query in f0, with
π1f0(Pi) = ⟨qi1⟩) such that qkl ∈S where S is a finite set of rewritten queries over Pk
peer. Let us show that (Pk, qkl) must be a node in the tree k@(Pi, qi1) ∈gfp(𝒫fin).
From the fact that (Pk, S) ∈st@(f0), we conclude that there exists a finite number n
such that fn = stn(f0) = nextn(f0) and qkl = πl(π1(fn(Pk))), with l = ln(π1(fn(Pk))).
Thus, there exists the following sequence-ordered subset of all recursive executions
of the query algorithm method st, which begins from f0 and ends with fn, inductively
defined in the backward direction: the immediate precedent to the step n in this subset
is the step m1 = n −1 in which the method st invokes the action fm1 to the increment
pointer of a locally-connected peer Pj, and fm1(Pk) = (push(Lk, q), m′), which inserts
q as the query qkl in the list Lk of the peer Pk; so, also for the step m2 = n −2 the
method st invokes the action push(Lm, q′) for a locally-connected peer Pm to Pj, i. e.,
fm2(Pj) = (push(Lj, q′), m′′), which inserts the query q′ as the query qjl′ in the list Lj
of the peer Pj, etc. In this kind of backward recursion, we will reach the beginning
element f0 for the initial query couple (Pi, qi1).
The chain of nodes C = ⟨(Pi, qi1), . . . , (Pj, qjl′), (Pk, qkl)⟩is a chain of intension-
ally equivalent queries; thus, must be a weak deduction inference chain, and con-
sequently, a part of the unique derivation tree k@(Pi, qi1) (with the root in the node
(Pi, qi1)), and consequently, (Pk, qkl) is a node in this tree.
This theorem can be represented by the following commutative diagram: the top
commutative square corresponds to the query agent with the (unique) solution for its
query rewriting algorithm, while the bottom commutative square corresponds to the
unique solution of the weak deduction inference. The dashed diagram in the middle
corresponds to the equalizer of this theorem, and intuitively, shows that each unique
solution of query answering algorithm is equal to the unique solution set obtained
by the weak deductive inference ⊪of the intensional logic ℒω(Γ) for a P2P database
system:
B + (LsQ × ℕ)𝒲0
1B + st@
? B + gfp(B + _ )
Query rewriting
1 ⊂new? (LsQ × ℕ)𝒲0
st
?
st@
? gfp(B + _ )
≃
?
Equalizer
𝒲0 × ℒQ
pop
?
k@
? gfp(𝒫fin)
fl
?
Weak deduction
𝒫fin(𝒲0 × ℒQ)
k
?
𝒫fin(k@) ? 𝒫fin(gfp(𝒫fin))
≃
?

3.5 (Co)algebraic representation of P2P query answering
|
165
In what follows, we will consider that each single peer database (such as DIS) is able
to deal with incomplete information and with mutually inconsistent information,
which comes from different source databases, and we will mathematically present
such query answering by using the coalgebras able to respond to user’s queries by
plausible (known) answers.
3.5 (Co)algebraic representation of P2P query answering
(Co)algebras provide an unifying view on a large variety of dynamic systems such as
transition systems, automata, data structures and objects [152, 153] or Kripke models;
they are especially useful for the dynamic query answering P2P systems.
The implementation of query answering in P2P systems by grid computing needs a
standard mathematical semantics based on an adequate (co)algebra: as for example,
the relational (co)algebra used for SQL query answering in relational databases. Here,
the computation is more intricate because of the complex epistemic logic structures of
peers and the necessity of query rewriting algorithms Rew. We consider that the rule
of the query agent is to start and to maintain complete a query answering transaction:
this transaction starts when s user query q(x) over a peer Pi is defined. A query agent
supports the Rew algorithm in order to construct intensionally equivalent rewritten
queries over other peers and then calls the grid computation network to calculate an-
swers, by assigning to each grid computation node one peer with a rewritten query
for it. The transaction (agent’s deduction) ends when the query agent receives the an-
swers from all grid nodes, and presents collected answers to the user.
In the previous sections, we considered only the deduction of the intensionally
equivalent queries over the P2P database system, when the user defines an initial
query q(x) over a given peer Pi. So, in order to obtain this finite set of intensionally
equivalent formulae to this initial user’s query q(x), from all peers in a given P2P sys-
tem, we embedded this P2P database system into the modal intensional FOL ℒω(Γ)
with one “high-level” existential S5 modal operator ̂♦, provided by Definition 36 in
Section 3.3.
However, the execution of these query formulae over a given single peer database,
which returns with a set of tuples R (a relation) extracted from a database of this peer,
does not use this intensional logic ℒω(Γ). In fact, for any peer Pi, in order to answer
to any of these query formulae q(x), we need to formulate for this peer an epistemic
extensional modal FOL logic with universal modal operator Ki which means“Peer Pi
knows that …” in order, in the situation of an incomplete data of this peer, to obtain the
meaningful subset of certain (known) tuples of data. In the rest of this section, we will
consider this particular extensional epistemic modal logic (different from the “global”
P2P intensional first-order modal logic ℒω(Γ), which we used only for derivation of
intensionally equivalent query-formulae for each peer in P2P system).

166
|
3 Intensional semantics for P2P database systems
The definition of this P2P grid computing system, which abstracts all not neces-
sary implementation details of a peer, and has to be given in an abstract (co)algebraic
mathematical language; so, this abstract mathematical specification (coalgebraic ab-
stract type) can be successively implemented in any current grid computing system.
In fact, we defined previously in Section 3.2 only an Abstract Object Type (AOT) as
an observational coalgebra (which hides the internal integration structure of the peer
database, e. g., defined as a data integration system by using GLAV schema mappings)
able to respond to the queries as presented in Section 3.2.2. They are functional compo-
nents of the universal algebraic mathematical language, which can be used to trans-
late the logical semantic structure of the P2P systems into (co)algebraic structures,
especially useful for the dynamic query answering P2P systems. The coalgebraic def-
inition of the Abstract Data Type (ADT) for a query answering from the single peer
database is presented in [55]. It is very similar to the consideration of the relationship,
that exists between the declarative (logic) SQL language and its mathematical transla-
tion into relational-algebra which can be effectively implemented in current database
technology.
Because of this pragmatic, implementation point of view toward the epistemic
P2P database systems, we need to pass from the epistemic model-theory for P2P sys-
tems into the (co)algebraic representation of its functional-mathematical structures
(in Definition 40), which can be used for the practical grid computation implementa-
tions also. The Kripke structure of the frame ℱR = (𝒲, {ℛi}), given in the Definition 3,
is a prerequisite in order to obtain a coalgebraic semantics for query answering in a
P2P database framework.
Example 20 (Coalgebraic semantics of predicate modal logics). Let ℳ= (𝒲, ℛ, 𝒟, IK)
be a simple monomodal Kripke model for a set of ground predicates in P and AP =def
{pn
j (g(x)) | pn
j ∈P, g ∈𝒟𝒱} is the set of all ground atoms obtained from the predicate
letters in P.
Let us define two functions, next : 𝒲→𝒫(𝒲) and prop : 𝒲→𝒫(AP), where
𝒫( _ ) is a powerset operator, such that for any w ∈𝒲:
next(w) = {wk | (w, wk) ∈ℛ},
(points that are potentially the next of w)
prop(w) = {pn
j (c) | pn
j ∈P, ℐK(w, pn
j )(c) = 1},
(ground atoms true at w).
Taking a Cartesian product, the coalgebraic semantics of predicate modal logic is the
mapping (𝒲, ⟨prop, next⟩: 𝒲→T(𝒲)) with the signature functor T = 𝒫(AP)×𝒫( _ ) :
Set →Set, where Set is the category of all sets and functions between them.
Remark. Here, we will use the standard extensional multimodal logic framework of
this “computational” level of query answering of each independent peer. This is very
important observation. What we obtained is relatively simple modal predicate logic
without quantifiers, with only a subset of predicates used in the global schema of peer

3.5 (Co)algebraic representation of P2P query answering
|
167
databases with the set of views (virtual predicates) defined for the queries. The ex-
tension of these predicates is wrapped by ADT of each peer independently. The logic
specification for these sophisticated wrappers can be obtained by using the epistemic
FOL logic [55] of each single peer database. Here, a peer is considered as a data inte-
gration system with Global-As-View (GAV) mappings between its source and its global
database schemas [111], and with integrity constraints over global schema also.
So, this P2P database architecture uses the strong (extensional) semantic map-
ping, based on views, inside each peer database, as in standard data integration sys-
tems [118, 155], with the possibility to use also the logic negation [156].
This architecture takes advantage of both semantical approaches: extensional for
building independent peer databases (a development of any particular peer database
can be done by an independent software group, dedicated to develop and to main-
tain in time its functionalities), with intensional, robust and noninvasive, mapping
between peers, based on the beliefs of developers of one peer about the intensionally
equivalent knowledge of other peers (which are not under their control).
Different from the intensional embedding in Definition 38 for the query rewriting,
here we need an extensional embedding of P2P database system in a multimodal epis-
temic logic for the query answering able to provide the set of certain (known) tuples
for the queries obtained previously by query rewriting of the intensionally equivalent
formulae.
Definition 41 (Extensional embedding of P2P database systems). For
a
query
an-
swering, we consider a model ℳ= (𝒲, {ℛi}, 𝒟, IK), for the extensional predicate
modal logic translation of a P2P database system, composed by N peers (with the set
P of predicate letters (each one corresponding to some relation in peer database or to
some built-in predicate) and set F of functional letters), where
–
The set of possible words (points) is a union 𝒲= ⋃1≤i≤N 𝒲i, with 𝒲i = {Pi} ×
Mod(Pi) for 1 ≤i ≤N, and 𝒲0 = {Pi | 1 ≤i ≤N} is the finite set of peers in the P2P
database system, such that:
1.
Each world, which is a peer Pi, is considered as a predicate modal logic
theory with incomplete information, composed by extensional (ground
atoms/facts).
2.
For each peer database Pi, the set of worlds Mod(Pi), 1 ≤i ≤N is a subset
of preferred Herbrand models of such peer database. Each w ∈Mod(Pi) as a
Herbrand base of the predicate modal logic of peer Pi, and hence can be seen
as a logical theory also, composed by only ground terms (only extensional
part).
–
The Cartesian product ℛi = 𝒲i × 𝒲i ⊂𝒲× 𝒲, for each 1 ≤i ≤N is a
binary accessibility relation, i. e., it is a reflexive, symmetric and transi-
tive relation in 𝒲i, used for the “known” universal S5 modal operator Ki
of the peer Pi.

168
|
3 Intensional semantics for P2P database systems
–
IK : 𝒲× (P ⋃F) →⋃n∈𝒩(2 ⋃𝒟)𝒟n, where 2 = {f, t}, is a function, which
assigns to each pair consisting of an n-place predicate letter rn
j ∈P and of
an element w ∈𝒲a function IK(w, rn
j ) from 𝒟n to {f, t} and for any n-ary
functional letter f n
j
∈F a function IK(w, f n
j ) from 𝒟n to 𝒟, such that for
any n-ary relation rn
j of peer Pi, n-ary tuple d ∈𝒟n,
3.
For any w = (Pi, H) ∈𝒲i, where H ∈Mod(Pi) is a one of the preferred Her-
brand models of this peer database, IK(w, rn
j )(d) = t if the ground atom rn
j (d)
is true in the world w = (Pi, H) ∈𝒲i, and hence
ℳ󳀀󳨐w,g rn
j (y)
iff
IK(w, rn
j )(g(y)) = t
(3.24)
The extension of satisfaction relation 󳀀󳨐w,g to all formulae is standard, as that pro-
vided in Definition 3, by considering that Ki = ¬♦i¬, so that for a formula qj(y)
(a n-ary virtual predicate qj with a tuple of variables in y),
ℳ󳀀󳨐w,g Kiqj(y)
iff
for all w′ ∈𝒲such that (w, w′) ∈ℛi holds ℳ󳀀󳨐w′,g qj(y)
(3.25)
so that the number of known tuples is defined by
󵄩󵄩󵄩󵄩Kiqj(y)󵄩󵄩󵄩󵄩ℳ,w = {g(y) ∈𝒟n | g ∈𝒟𝒱and ℳ󳀀󳨐Pi,H,g Kiqj(y)}
(3.26)
So, for any virtual n-ary predicate qj corresponding to the conjunctive query qj(y)
of a peer Pi, n ≥1, where y and c are n-tuples of variables and constants in 𝒟, re-
spectively, we obtain the extension (n-ary relation) in a world w = (Pi, H) ∈𝒲, for
H ∈Mod(Pi), of this predicate (see point 2 in Definition 3) by
‖Kiqj(y)‖ℳ,w = {g(y) ∈𝒟n | g ∈𝒟𝒱and ℳ󳀀󳨐Pi,H,g Kiqj(y)}
= ⋃
g∈𝒟𝒱
{g(y) ∈𝒟n | ∀(Pi, H′) ∈𝒲.((Pi, H), (Pi, H′)) ∈ℛi, ℳ󳀀󳨐Pi,H′,g qj(y)}
= ⋃
g∈𝒟𝒱
{g(y) ∈𝒟n | ∀H′ ∈Mod(Pi), ℳ󳀀󳨐Pi,H′,g qj(y)},
i. e., are extracted from the peer Pi database only the tuples that are satisfied in the
subset of preferred Herbrand models of this database, i. e., only the certain (known)
answers.
In this way, the binary relation of each partition (peer database), ℛi, i ≥1, is the
S5 modal logic (reflexive, symmetric and transitive): it models the local universal epis-
temic modal operator Ki for each peer database.

3.5 (Co)algebraic representation of P2P query answering
|
169
3.5.1 P2P query-answering dynamics
The main motivation for this section is to provide the clear semantics for P2P database
systems, based on the fact that each peer is a database with incomplete information
able to provide known answers based on its epistemic S5 modal logic, and to provide
the clear mathematical framework for its query-answering computation, which suc-
cessively can be implemented into massive grid computing frameworks.
In the case of a P2P database system network, 𝒲0 = {Pi | 1 ≤i ≤N}, with the
multimodal Kripke models defined in Definition 41, its coalgebraic semantics of the
query answering can be given by the following definition.
Definition 42 (Coalgebraic P2P query-answering system). Let ℳ= (𝒲, {ℛi}, 𝒟, IK) be
the Kripke model (in Definition 41) of the finite P2P database system with 𝒲0 = {Pi |
1 ≤i ≤N} ∈𝒲with the bijective function is0 : 𝒲0 →st@(f0) where f0 = new(∗) :
𝒲0 →LsQ ×ℕdefines the initial user’s query of a given peer in (3.19) and st@ the final
coalgebra defined in Section 3.4.2, such that for any Pk ∈𝒲0, is0(Pk) = (Pk, Sk) where
Sk is the set of all intensionally equivalent queries over the peer database Pk obtained
by the query-rewriting algorithm in Section 3.4.2.
In what follows, this initial state f0 will be called the “parameter” as well.
We define two functions, nM : 𝒲→𝒫(𝒲) and parameterized function pM
f0 =
⟨αM
f0 , dbM⟩: 𝒲→R × 𝒫(R), where R = ⋃k∈ℕ𝒫(𝒟k) is the set of all k-ary relations
introduced in Definition 4, as follows: for any w = (Pi, H) ∈𝒲:
1.
nM(w) = {wk | wk ∈𝒲i and ((Pi, H), wk) ∈ℛi} = Mod(Pi),
2.
the parameterized function αM
f0 = out ∘π2 ∘is0 ∘π1 : 𝒲0 →R, where out ∘π2 :
st@(f0) →R, such that for any (Pk, Sk) ∈st@(f0), and by using (3.26) we have that
out(Sk) = ⋃1≤n≤|Sk| ‖Kkπn(Sk)‖ℳ,w where |Sk| denotes the number of queries in the
set Sk.
3.
dbM : 𝒲→𝒫(R) such that dbM(w) = dbM(Pi, H) = {‖rn
j (x)‖ℳ,w | rn
j ∈P and
rn
j ∈SPi} = {d ∈𝒟n | IK(w, rn
j )(d) = t}, where SPi is the set of relational symbols of
Pi peer’s database schema.
The coalgebra ⟨pM
f0 , nM⟩: 𝒲→Q(𝒲), of the endofunctor Q = R×𝒫(R)×𝒫(_ ) : Set →
Set, defines the semantics of the P2P query-answering system.
It is easy to verify that the answers to the query are known answers: from the def-
inition of the function pM in the Definition 42, it holds that any tuple of the query
answer has to be true in every preferred Herbrand model of that peer database. By the
coalgebraic definition of a query answer, we obtain that for any w = (Pi, H) ∈𝒲, the
relation Ri (the set of tuples extracted from the peer database Pi):
Ri =def αM
f0 (w) = out ∘π2 ∘is0 ∘π1(Pi, H) = out ∘π2 ∘is0(Pi)
= out ∘π2(Pi, Si) = out(Si) =
⋃
1≤n≤|Si|
‖Kiπn(Si)‖ℳ,w ∈R

170
|
3 Intensional semantics for P2P database systems
where Si is the set of all intensionally equivalent queries rewritten over this peer Pi ∈
𝒲0 and |Si| is the number of queries in this set Si.
Proposition 20. Each peer database Pi is represented by the subcoalgebra ({Pi} ×
𝒲i, ⟨pM
i , nM
i ⟩) of the global P2P coalgebra in Definition 42, where pM
i and nM
i are restric-
tions of pM
f0 , nM on {Pi} × 𝒲i ⊂𝒲, respectively.
Proof. It is easy to prove, from Definition 42, by simple reduction of the possible worlds
only to a single peer database Pi.
The definition of the parameterized mapping pM
f0 reflects the epistemic multimodal
semantics for a P2P system: for a given parameter f0 = new(∗) (in equation (3.19)) such
that f0(Pi) = (⟨qi1(x)⟩, 0), the ground atoms defined by this mappings for a peer Pi (for
the restriction pM
i ) with a query qi1(x) is the set of known facts by this peer, i. e., they
must be true in all preferred Herbrand models 𝒲i = Mod(Pi) of this peer. This is just
the property of the epistemic multimodal P2P systems.
The union of these known answers from different peers Pi (answered to rewrit-
ten queries) is equal to ⋃Pi∈𝒲0 Ri. This union, collected by a query agent, of partial
(but known) answers from different peers, will eliminate duplicate tuples of known
answers of different peers. We assume that a query agent has a common thesauri in
order to eliminate synonymous.
Now we will apply the function introduced in Definition 42 in order to define the
entire categorial coalgebraic semantics for the query answering P2P system. Let qi1(x)
be the original user query specified over the i-th peer database, such that for the pa-
rameter (state) f0 = new(∗) : 𝒲0 →LsQ × ℕwith f0(Pi) = (⟨qi1(x)⟩, 0) (see the
query-rewriting diagram after Theorem 4). This initial user’s query qi1(x) is succes-
sively rewritten by a query one-step rewriting algorithm Rew (based on view-based
mappings between peers and represented in the query-rewriting diagram by the ar-
row st, in equation (3.20)) into the set of intensionally equivalent queries over peers
in the P2P system, given by the set
st@(f0) = {(Pk, Sk) | Pk ∈W0}
(3.27)
represented in the final coalgebraic semantics by the top commutative diagram of
query rewriting (part of the equalizer in Theorem 4), where Sk is the set of all inten-
sionally equivalent queries over the peer database Pk. Thus, we have the following.
Proposition 21. Let {(Pk, Sk) | Pk ∈W0} = st@(f0) be the final semantics of the query-
rewriting algorithm where for each peer database Pk, the set Sk is the set of all intension-
ally equivalent queries rewritten above the database schema of this peer database Pk,
for the given parameter (initial state) f0 = new(∗) : 𝒲0 →LsQ × ℕwith f0(Pi) =
(⟨qi1(x)⟩, 0) where qi1 is the initial user’s query over peer Pi, and for all other peers Pk,
k
̸= i, f0(Pk) = (⟨⟩, 0) (peers without initial user’s query).

3.5 (Co)algebraic representation of P2P query answering
|
171
Then, for this parameter (state) f0, the following diagram in Set category commutes
1 choice? 𝒲
⟨pM
f0 , nM⟩? R × 𝒫(R) × 𝒫(𝒲)
𝒲
idW
? ⟨pM
⊥, nM⟩? R × 𝒫(R) × 𝒫(𝒲)
⊥R × id𝒫(R) × id𝒫(W)
?
where the mapping choice : 1 →𝒲form the singleton set (terminal object in Set), 1 =
{∗}, and takes a single world w = (Pi, H) ∈𝒲i ⊆𝒲corresponding to the parameter f0
(to the unique peer Pi for which user defined initial query qi1(x) and a chosen preferred
Herbrand base H ∈Mod(Pi)). The functions pM
f0 and nM are provided by Definition 42.
The other two new functions (different from the identity functions id) are defined by:
1.
The mapping pM
⊥= ⟨⊥, dbM⟩: 𝒲→R × 𝒫(R), where dbM : 𝒲→𝒫(R) is defined
in point 3 of Definition 42, and constant function ⊥: 𝒲→R such that for each
w ∈𝒲, ⊥(w) = 0 is an empty set (relation).
2.
The constant function ⊥R : R →R, such that for every relation R ∈R, we have that
⊥R(R) = 0.
Proof. It is easy to verify because of the identity functions (the vertical arrows in this
commutative diagram), so that we need to verify the commutativity for the vertical
component ⊥R, but in that case it maps into the empty relation 0 ∈R and also the
component ⊥: 𝒲→R of the bottom horizontal mapping pM
⊥is a constant function
that maps to 0 as well.
Notice that in the diagram above, the bottom horizontal arrow corresponds to the
model of the P2P system in a stable idle state, i. e., to the Q-coalgebra (𝒲, ⟨pM
⊥, nM⟩) :
𝒲→Q(𝒲), for the endofunctor Q = R × 𝒫(R) × 𝒫(_ ) : Set →Set.
Any parameter f0 = new(∗), i. e., any user’s query qi1(x) over a peer Pi extends this
model by known answers for rewritten queries over all peers, which are able to give
a partial answer to this initial user’s query. This temporary extended model of a P2P
system is represented by the top horizontal arrow, i. e., to the Q-coalgebra:
(𝒲, ⟨pM
f0 , nM⟩) : 𝒲→Q(𝒲).
Consequently, we obtain the following generalized mathematical concept for the P2P
query-answering.
Corollary 12. Let us denote by CoAlgW(Q) the full subcategory composed by only
Q-coalgebras with a prefixed carrier set 𝒲for a given P2P system. Then:
1.
The Q-coalgebra of a P2P database system, (𝒲, ⟨pM
⊥, nM⟩) : 𝒲→Q(𝒲) is the
terminal object in CoAlgW(Q).

172
|
3 Intensional semantics for P2P database systems
2.
Each user’s query in this P2P database system determined by a parameter f0 =
new(∗) can be represented by the unique coalgebra morphism in CoAlgW(Q) from
the Q-coalgebra of the query answering system (𝒲, ⟨pM
f0 , nM⟩) : 𝒲→Q(𝒲) into the
terminal Q-coalgebra. This unique morphism corresponds to the vertical arrow of
the diagram in Proposition 21.
Proof. This proof comes directly from the commutative diagram in Proposition 21,
where this unique coalgebra morphism is theverticalarrowidW ×(⊥R×id𝒫(R)×id𝒫(W)).
This proposition defines the query answering of a P2P database system by the uni-
versal property of the terminal (unique) object: such object is the Kripke model of the
idle P2P database system (which is unique for a given P2P system). For each given
user’s query, there exists a unique arrow into this terminal (idle state) object, from the
extended (by rewritten intensionally equivalent queries) Kripke model, which con-
tains all known answers to the user’s given initial query.
It is interesting to observe how the coalgebraic view of query answering syntac-
tically represents its dynamic dimension, by a simple arrow between coalgebras: the
idle model of a P2P system (terminal object in CoAlgW(Q)), which define the Kripke’s
worlds (the set of preferred Herbrand models Mod(Pi) of each peer Pi), and by the
query extended model of a P2P system, which is complementary to the standard query
rewriting logic analysis. The known query answers obtained for a given parameter f0
(given the user’s query over a peer database Pi) can be seen as observations of this
terminal object (idle state of a P2P system). The obtained query-answer relation does
not modify the P2P system: this unique “forget” arrow into this terminal object, which
represents the Kripke model of the idle P2P database system represents this fact that
such observation does not produce the side effects on the P2P database system.
This coalgebraic semantics of P2P query answering can be used also as a sim-
ple mathematical instrument in order to study the behavioral equivalences between
different P2P systems based on the observations (obtained results of the thuser’s
queries).

4 Intensional RDB manifesto: flexible big data and
NewSQL
4.1 State of the art in RDBMS and NoSQL big data
This chapter is an ideal continuation of my previous “Big data integration theory”
book [21], which has been dedicated to extension of RDB databases and methods of
query rewriting in the data integration of traditional RDB’s: In that book, I developed
an abstract categorial framework and definition of categorial RDB, based on the stan-
dard FOL semantics, and topology of data integration between them. Here, instead,
we will introduce the new intensional RDB (IRDB) based on the intensional FOL the-
ory developed in this book, which are conservative but more powerful extensions of
standard RDBs. Because of that, the name of this chapter is just this “Manifesto for
new intensional RDBMS” [20].
This evolutive extension of the standard RDB technology can have a deep indus-
trial impact in IT practice as well, to all current DB applications, and because of that
this chapter is probably the central innovative (not only theoretically) issue of this
book, and hence dedicated to a very large number of IT experts and researches.
The program of this manifesto
In what follows, we provide the method of parsing of a standard relational (RDB)
instance-database A with the user-defined schema 𝒜into a vector relation
⃗A, used
in order to represent the information in a standard and simple key/value form, today
in various applications of big data, and introduces the intensional concepts for the
user-defined relations of the schema 𝒜. In Tarskian semantics of the FOL, used to de-
fine the semantics of the standard RDBs, one defines what it takes for a sentence in a
language to be true and relative to a model. This puts one in a position to define what
it takes for a sentence in a language to be valid. Tarskian semantics often prove to be
quite useful in logic. Despite this, Tarskian semantics neglects meaning, as if truth
in language were autonomous. Because of that, the Tarskian theory of truth becomes
inessential to the semantics for more expressive logics, or more “natural” languages.
Both Montague’s and Bealer’s approaches were useful for this investigation of the
intensional FOLwith intensionalabstraction operator,butthefirstis notadequateand
explains why we adopted two-step intensional semantics (intensional interpretation
with the set of extensionalization functions). Based on this intensional extension of
the FOL, we will define a new family of IRDBs. We will show that also with these ex-
tended intensional semantics we may continue to use the same SQL used for the RDBs.
This new family of IRDBs extends the traditional RDBS with new features. However,
it is compatible in the way how to present the data by user-defined database schemas
(as in RDBs) and with SQL for management of such a relational data. The structure of
https://doi.org/10.1515/9783110981438-004

174
|
4 Intensional RDB manifesto: flexible big data and NewSQL
RDB is parsed into a vector key/value relation so that we obtain a column representa-
tion of data used in big data applications, covering the key/value and column-based
big data applications as well, into a unifying RDB framework.
Note that the method of parsing is well suited for the migration from all existent
RDB applications where the data is stored in the relational tables, so that this solution
gives the possibility to pass easily from the actual RDBs into the new machine engines
for the IRDB. We preserve all metadata (RDB schema definitions) without modifica-
tion and only dematerialize its relational tables by transferring their stored data into
the vector relation rV (possibly in a number of disjoint partitions over a number of
nodes). From the fact that we are using the query rewriting IDBMS, the current user’s
(legacy) applications does not need any modification and they continue to “see” the
same user-defined RDB schema as before. Consequently, this IRDB solution is ade-
quate for a massive migration from the already obsolete and slow RDBMSs into a new
family of fast, NewSQL schema-flexible (with also “open schemas”) and big data scal-
able IRDBMSs.
Moreover, in other sections of this chapter, after this basic introduction to new
IRDBMS with query rewriting over its vectorial databases, we will provide other sig-
nificant features of this powerful evolution of standard RDBMSs.
First of all, let us analyze the state of the art of actual standard RDBs w. r. t. the new
big data applications and NoSQL languages for them. The term NoSQL was selected
in 2009 and used in the conferences for advocates of nonrelational databases. In an
article of the Computerworld magazine [157], June 2009, dedicated to the NoSQL meet-
up in San Francisco and reported the following: “NoSQLers came to share how they had
overthrown the tyranny of slow, expensive relational databases in favor of more efficient
and cheaper ways of managing data.” In this article, Computerworld summarizes the
following reasons:
–
High throughput. The NoSQLdatabasesprovideasignificantlyhigherdatathrough-
put than traditional RDBMSs.
–
Horizontal scalability. In contrast to RDBMSs, most NoSQL databases are designed
to scale well in the horizontal direction and not rely on highly available hardware.
–
Cost setting and complexity of database clusters. NoSQL does not need the com-
plexity and cost of sharing, which involves cutting up databases into multiple ta-
bles to run on large clusters or grids.
–
“One size fits all” [158] Database thinking is wrong. The thinks that the realization
and the search for alternatives toward traditional RDBMs can be explained by the
following two major trends: the continuous growth of data volumes and the grow-
ing need to process larger amounts of data in shorter time.
–
Requirement of cloud computing. Two major requirements are mentioned: High
until almost ultimate scalability (especially in the horizontal direction) and low
administration overhead. Developed cloud Amazon’s SimpleDB can store large

4.1 State of the art in RDBMS and NoSQL big data
|
175
collections of items, which themselves are hash tables containing attributes that
consist of key-value pairs.
–
Avoidance of unneeded complexity. The reach feature set and the ACID properties
implemented by RDBMSs might be more than necessary for particular applica-
tions. There are different scenarios where applications would be willing to com-
promise reliability for better performances.
Moreover, the NoSQL movements advocate that standard relational databases fit well
for data that is rigidly structured with relations and are designated for central deploy-
ments with single, large high-end machines, and not for distribution. Often they em-
phasize that SQL queries are expressed in a sophisticated language. But usually they
do not tell that also the NoSQL databases often need the sophisticated languages (as
object-oriented databases, or graph-based databases) as well. Moreover, they do not
say that SQL and RDB are based on a sound logical framework (a subset of the first-
order logic language), and hence it is not a procedural language, but a higher level
declarative language able to specify “what” we need instead of “how” to obtain what
we need. Thus, from the point of view of the development of computer science, in-
stead to go in the direction of the logically higher levels of knowledge representation
and query languages, more appropriated to the human understanding, they propose
the old technics as key-value representations or the simpler forms of object-oriented
representations and their relative procedural query languages.
They jumped into the past instead to jump in the future of the social and scien-
tific human development. It happened because the current RDBMSs were obsolete and
not ready to accept the new social-network web applications in the last 10 years, so
that the isolated groups of developers of these ad hoc systems (e. g., Google, Amazon,
LinkedIn, Facebook, etc.) could use only the readily old-known techniques and de-
velopment instruments in order to satisfy the highly urgent business market require-
ments. From the academic research side, instead, most of the work has been done in
the sematic web “industrial-funded” programs (e. g., the European IST projects) by
considering the new knowledge and reasoning logic systems, whose impact to the ex-
isting RDB applications framework would be very hard, with difficult migration and
implementation in these new semantics systems (it would need one or more decade
of time). Instead, we needed more fundamental and theoretical research for the sig-
nificant technological advances and evolutions of the existing RDB engine. Thus, the
core RDB technology was in some way “abandoned” from both major development
initiatives in the last 20 years. Nobody probably wanted to consider the most natural
evolution of the RDBMSs and its FOL and SQL query framework, and the database in-
dustry tried only to cover “with pieces” and “adding” the new emergent customer’s
necessities, without a strong investment and the necessary efforts for the complete
revision of their old System R based RDB engines of the 1970s. The world’s economic
crisis from 2007 did not help for such an effort.

176
|
4 Intensional RDB manifesto: flexible big data and NewSQL
However, from the technical point of view, it is clear that if we would come back
to make the application programs in Assembler, we probably will obtain better com-
putational performances for some algorithms than with more powerful programming
languages, but it is justifiable when we write the system infrastructures and parsers,
and not when we have to develop the legacy software for user’s requirements. Analo-
gously, we may provide the BD infrastructure and physical level in a form of simpler
structures, adequate to support the distributive and massive big data query computa-
tions, and by preserving the logically higher level interface to customer’s applications.
That is, it is possible to preserve the RDB interface to data, with SQL query languages
for the programmers of the software applications, with the “physical” parsing of data
in more simple structures, able to deal with big data scalability in a highly distributive
computation framework.
The first step to maintain the logical declarative (nonprocedural) SQL query lan-
guage level, is done by the group (M. I. T. and Microsoft) and in the widely adopted
paper “The end of an architectural era” (cf. [159] Michael Stonebraker et al.) where the
authors come to the conclusion
“that the current RDBMS code lines, while attempting to be a “one size fits all” solution, in fact
excel at nothing.”
At first, Stonebraker et al. argued that RDBMSs have been architected more than 25
years ago when the hardware characteristics, user requirements and database markets
were very different from those today. The resulting revision of traditional RDBMSs is
provided by developing H-store (M. I. T., Brown and Yale University), a next generation
OLTP systems that operates on distributed clusters of shared-nothing machines where
the data resides entirely in main memory, so that it was shown to significantly outper-
form (83 times) a traditional, disc-based DBMS. A more full-featured version of the sys-
tem [160] that is able to execute across multiple machines within a local area cluster
was presented in August 2008. The data storage in the H-store is managed by a single-
thread execution engine that resides underneath the transaction manager. Each indi-
vidual site executes an autonomous instance of the storage engine with a fixed amount
of memory allocated from its host machine. Multi-side nodes do not share any data
structures with collocated sites, and hence there is no need to use concurrent data
structures (every read-only table is replicated on all nodes and other tables are di-
vided horizontally into disjoint partitions with a k-safety factor two). Thus, H-store (at
http://hstore.cs.brown.edu/documentation/architecture-overview/) was designed as
a parallel, row-storage relational DBMS that runs on a cluster of shared-nothing, main
memory executor nodes. The commercial version of H-store’s design is VoltDB.
More recently, during 2010 and 2011, Stonebraker has been a critic of the NoSQL
movement [161, 162]:
“Here, we argue that using MR systems to perform tasks that are best suited for DBMSs yields less
than satisfactory results [163], concluding that MR is more like an extract-transform-load (ETL) sys-

4.2 Intensional RDB: data integration system with a vector source database
|
177
tem than a DBMS, as it quickly loads and processes large amounts of data in an ad hoc manner. As
such, it complements DBMS technology rather than competes with it.”
After a number of arguments about MR (MapReduction) w. r. t. SQL (with GROUP BY
operation), the authors conclude that parallel DBMSs provide the same computing
model as MR (popularized by Google and Hadoop to process key/value data pairs),
with the added benefit of using a declarative SQL language. Thus, parallel DBMSs of-
fer great scalability over the range of nodes that customers desire, where all parallel
DBMSs operate (pipelining) by creating a query plan that is distributed to the appro-
priate nodes at execution time. When one operator in this plan sends data to next
(running on the same or a different node), the data are pushed by the first to the sec-
ond operator (this concept is analog to the process described in my book [21], February
2014, in Section 5.2.1 dedicated to the normalization of SQL terms (completeness of the
action-relational-algebra category RA), so that (different from MR), the intermediate
data is never written to disk. The formal theoretical framework (the database category
DB) of the parallel DBMSs and the semantics of database mappings between them is
provided in “big data integration theory” as well [21].
It is interesting that in [162], the authors conclude that parallel DBMSs excel at
efficient querying of large data sets while MR key/value style systems excel at complex
analytics and ETL tasks, and propose:
“The result is a much more efficient overall system than if one tries to do the entire application in
either system. That is, ‘smart software’ is always a good idea.”
The aim of this chapter is to go one step in advance in developing this NewSQL ap-
proach, and to extend the “classic” RDB systems with both features: to offer, on the
user’s side, the standard RDB database schema for SQL querying, and on the computa-
tional side, the “vectorial” relational database able to efficiently support the low-level
key/value data structures together, in the same logical SQL framework. Moreover, this
parsing of the standard RDBs into a “vectorial” database efficiently resolves also the
problems of NoSQL applications with sparse-matrix and ‘open schema” data models.
4.2 Intensional RDB: data integration system with a vector source
database
The plan of this section is the following: we present the method of parsing of any RDB
into a vector relation of the key/value structure, compatible with most big data struc-
tures, and open schema solutions, but with preserving the RDB user-defined schema
for the software applications. We show that such a parsing changes the standard se-
mantics of the RDBs based on the FOL by introducing the intensional concepts for
user-defined relational tables, based on the conservative intensional extension of the
FOL provided in the first chapter, adequate to express the semantics for the IRDBs and

178
|
4 Intensional RDB manifesto: flexible big data and NewSQL
the SQL. Then we define a new semantics for the IRDBSs and their canonical models
based on the data integration systems, where the user-defined RDB is a global schema
and the source schema is composed by the unique vector relation rV, which contains
the parsed data of the whole used-defined RDB. As in GAV (Global-As-View) data inte-
gration systems (introduced in Sections A.6.3 and A.6.4 in the Appendix), we demate-
rialize the global schema (i. e., user-defined RDB) by providing the schema mappings
(tgds) from source DB schema with vector relation rV into global RDB user’s schema
(4.3). Finally, we define a query-rewriting algorithm to translate the original query writ-
ten for the user-defined RDB schema into the source database composed by the vector
relation rV containing the parsed data.
In what follows, we denote by BA the set of all functions from A to B, and by An
a n-folded Cartesian product A × ⋅⋅⋅× A for n ≥1, we denote by ¬, ∧, ∨, ⇒and ⇔the
logical operators negation, conjunction, disjunction, implication and equivalence, re-
spectively. For any two logical formulae ϕ and ψ, we define the XOR logical operator
∨by ϕ ∨ψ logically equivalent to (ϕ ∨ψ) ∧¬(ϕ ∧ψ). Then we will use the following
RDB definitions (more detail is provided in Section A.6 in the Appendix), based on the
standard First-Order Logic (FOL) semantics:
–
A database schema is a pair 𝒜= (SA, ΣA) where SA is a countable set of rela-
tional symbols (a subset of predicates P in FOL) r ∈ℝ⊂P with finite arity n =
ar(r) ≥1 (ar : ℝ→𝒩), disjoint from a countable infinite set att of attributes
(a domain of a ∈att is a nonempty finite subset dom(a) of a countable set of
individual symbols dom). For any r ∈ℝ, the sort of r, denoted by tuple a =
atr(r) = ⟨atrr(1), . . . , atrr(n)⟩where all ai = atrr(m) ∈att, 1 ≤m ≤n, must be dis-
tinct: if we use two equal domains for different attributes, then we denote them
by ai(1), . . . , ai(k) (ai equals to ai(0)). Each index (“column”) i, 1 ≤i ≤ar(r), has
a distinct column name nrr(i) ∈SN where SN is the set of names with nr(r) =
⟨nrr(1), . . . , nrr(n)⟩. A relation symbol r ∈ℝrepresents the relational name and
can be used as an atom r(x) of FOL with variables in x assigned to its columns,
so that ΣA denotes a set of sentences (FOL formulae without free variables) called
integrity constraints of the sorted FOL with sorts in att.
–
An instance-database of a nonempty schema 𝒜is given by A = (𝒜, IT) = {R =
‖r‖ = IT(r) | r ∈SA} where IT is a Tarski’s FOL interpretation, which satisfies
all integrity constraints in ΣA and maps a relational symbol r ∈SA into an n-ary
relation R = ‖r‖ ∈A. Thus, an instance-database A is a set of n-ary relations,
managed by relational database systems.
Let A and A′ = (𝒜, I′
T) be two instances of 𝒜, then a function h : A →A′ is a
homomorphism from A into A′ if for every k-ary relational symbol r ∈SA and every
tuple ⟨v1, . . . , vk⟩of this k-ary relation in A, ⟨h(v1), . . . , h(vk)⟩is a tuple of the same
symbol r in A′. If A is an instance-database and ϕ is a sentence, then we write
A 󳀀󳨐ϕ to mean that A satisfies ϕ. If Σ is a set of sentences, then we write A 󳀀󳨐Σ to
mean that A 󳀀󳨐ϕ for every sentence ϕ ∈Σ. Thus, the set of all instances of 𝒜is
defined by Inst(𝒜) = {A | A 󳀀󳨐ΣA}.

4.2 Intensional RDB: data integration system with a vector source database
|
179
–
We consider a rule-based conjunctive query over a database schema 𝒜as an ex-
pression q(x) ←󳨀r1(u1), . . . , rn(un), with finite n ≥0, ri are the relational symbols
(at least one) in 𝒜or the built-in predicates (e. g., ≤, =, etc.), q is a relational sym-
bol not in 𝒜and ui are free tuples (i. e., one may use either variables or constants).
Recall that if v = (v1, . . . , vm) then r(v) is a shorthand for r(v1, . . . , vm). Finally, each
variable occurring in x is a distinguished variable that must also occur at least
once in u1, . . . , un. Rule-based conjunctive queries (called rules) are composed of
a subexpression r1(u1), . . . , rn(un) that is the body, and the head of this rule q(x).
The Yes / No conjunctive queries are the rules with an empty head. If we can find
values for the variables of the rule, such that the body is logically satisfied, then
we can deduce the head-fact. This concept is captured by a notion of “valuation.”
The deduced head-facts of a conjunctive query q(x) defined over an instance A
(for a given Tarski’s interpretation IT of schema 𝒜) are equal to ‖q(x1, . . . , xk)‖A =
{⟨v1, . . . , vk⟩∈domk | A 󳀀󳨐∃y(r1(u1) ∧. . . ∧rn(un))[xi/vi]1≤i≤k} = I∗
T (∃y(r1(u1) ∧
. . . ∧rn(un))), where the y is a set of variables, which are not in the head of query,
and I∗
T is the unique extension of IT to all formulae. We recall that the conjunc-
tive queries are monotonic and satisfiable, and that a (Boolean) query is a class
of instances that is closed under isomorphism [164]. Each conjunctive query cor-
responds to a “select-project-join” term t(x) of SPRJU algebra obtained from the
formula ∃y(r1(u1) ∧. . . ∧rn(un)), as explained in Section 4.2.2.
–
We consider a finitary view as a union of a finite set S of conjunctive queries with
the same head q(x) over a schema 𝒜, and from the equivalent algebraic point of
view, it is a “select-project-join-rename + union” (SPJRU) finite-length term t(x),
which corresponds to union of the terms of conjunctive queries in S. In what fol-
lows, we will use the same notation for a FOL formula q(x) and its equivalent al-
gebraic SPJRU expression t(x). A materialized view of an instance-database A is
an n-ary relation R = ⋃q(x)∈S ‖q(x)‖A. Notice that a finitary view can also have an
infinite number of tuples. We denote the set of all finitary materialized views that
can be obtained from an instance A by TA.
The principal idea is to use an analogy with a GAV data integration [21, 111] (specified
in Section A.6.4 in the Appendix) by using the database schema 𝒜= (SA, ΣA) as a
global relational schema, used as a user/application-program interface for the query
definitions in SQL, and to represent the source database of this data integration system
by parsing of the RDB instance A of the schema 𝒜into a single vector relation ⃗A. Thus,
the original SQL query q(x) has to be equivalently rewritten over (materialized) source
vector database ⃗A.
Remark. The idea of a vector relation
⃗A for a given relational database instance A
comes from the investigation of the topological properties of the RDB systems, pre-
sented in Chapter 8 of my Big Data Integration book [21]:

180
|
4 Intensional RDB manifesto: flexible big data and NewSQL
In order to analyze the algebraic lattice of all RDB database instances, each in-
stance database A, composed by a set of finitary relations Ri ∈A, i = 1, . . . , n, in
Lemma 21 is defined as the transformation of the instance database A into a vector
relation ⃗A, with ⃗A = ⋃R∈A ⃗R where for each relation R ar(R) ≥1 is the arity (the num-
ber of its columns) of this relational table and πi is its i-th column projection, and
hence ⃗R = ⋃1≤i≤ar(R) πi(R). Such vectorial representation of a given database A in [21]
is enough to define the lattice of RDB lattices, because we do not need the converse
process (to define a database A from its vectorial representation).
However, by considering that a database A is interfaced by users and their soft-
ware applications (with the embedded SQL statements), while ⃗A is its single-table in-
ternal representation, over which a rewritten user’s query is executed, the extracted
information has to be converted in the RDB form w. r. t. the relational schema of the
original user’s model. Consequently, we need a teacher version of the vector database,
such that we can obtain an equivalent inverse transformation of it into the standard
user defined RDB schema.
Definition 43 (3-dim vector database coordinates). Each atomic value di in a tuple
d = (d1, . . . , di, . . . , dar(r)) of a relation Rk = ‖rk‖, rk ∈SA, of the instance database A, is
collocated in the 3-dim data space with the following dimensional coordinates:
1.
The relational name nr(r) of a given relation (predicate) letter r ∈P,
2.
The tuple index Hash(d) obtained by hashing the string of the tuple d,
3.
The attribute name nrr(i) of the i-th column.
Thus, the relational schema of the vector relation rV is composedby the four attributes,
relational name, tuple-index, attribute name and value, i. e., r-name, t-index, a-name
and value, respectively. The key of the relation rV in vector database
⃗A is composed
by all of its four attributes.1
So, if we assume rV (the name of the database 𝒜) for the name of this vector re-
lation ⃗A then this relation can be expressed by the 4-ary predicate letter rV ∈P of the
intensional FOL,
rV(r-name, t-index, a-name, value)
(4.1)
with its extension for a given Tarski’s interpretation IT, denoted by ‖rV‖ = I∗
T (rV).
So, the parsing of any RDB instance A of a schema 𝒜can be defined as
1 The fact that we chose to use all four attributes as the key of this relation instead of three-
dimensional coordinates permits us to generalize RDB with the possibility to have multivalued at-
tributes as well; in fact, for a given multivalued attribute, we can have more than one value in the
attribute value of this relation rV from the fact that also this attribute composes the key of this rela-
tion.

4.2 Intensional RDB: data integration system with a vector source database
|
181
Definition 44 (Parsing RDB instances). Given a database instance A = {R1, . . . , Rn},
n ≥1, of a RDB schema 𝒜= (SA, ΣA) with SA = {r1, . . . , rn} such that Rk = ‖rk‖, k =
1, . . . , n, then the extension ⃗A = ‖rV‖ of the vector relational symbol (name) rV with the
schema rV(r-name, t-index, a-name, value), and NOT NULL constraints for all its four
attributes, and with the primary key composed by the first three attributes, is defined
by the following.
We define the operation PARSE for a tuple d = (d1, . . . , dar(rk)) of the relation rk ∈SA
by the transformation
(rk, d) 󳨃→{(nr(rk), Hash(d), nrrk(i), di) | di
̸= NULL, 1 ≤i ≤ar(rk)},
so that
⃗A =def
⋃
rk∈SA,d∈‖rk‖
PARSE(rk, d)
(4.2)
Based on the vector database representation ‖rV‖, we define a GAV data integration
system ℐ= ⟨𝒜, 𝒮, ℳ⟩with the global schema 𝒜= (SA, ΣA), the source schema 𝒮=
({rV}, 0) and the set of mappings ℳexpressed by the tgds (tuple generating depen-
dencies, introduced in Section A.6.3 in the Appendix):2
∃z, z1, z2(rV(nr(rk), z, z1, z2))∧
∀y, x1, . . . , xar(rk)[((rV(nr(rk), y, nrrk(1), x1) ∨(x1 = NULL)) ∧. . .
. . . ∧(rV(nr(rk), y, nrrk(ar(rk)), xar(rk)) ∨(xar(rk) = NULL)))
⇒rk(x1, . . . , xar(rk))]
(4.3)
for each rk ∈SA.
The operation PARSE corresponds to the parsing of the tuple d of the relation
rk ∈SA of the user-defined database schema 𝒜into a number of tuples of the vector
relation rV. In fact, we can use this operation for virtual inserting/deleting of the tu-
ples in the user- defined schema 𝒜, and store them only in the vector relation rV. This
operation avoids to materialize the user-defined (global) schema, but only the source
database 𝒮, so that each user-defined SQL query has to be equivalently rewritten over
the source database (i. e., the big table ⃗A = ‖rV‖) as in standard FOL data integration
systems.
Notice that this parsing defines a kind of GAV Data integration system, where the
source database 𝒮is composed by the unique vector relation ‖rV‖ =
⃗A (big data vector
2 The first sentence ∃z, z1, z2(rV(nr(rk), z, z1, z2)) is true if there exists at least one tuple for the relation
rk, so that the second conjunctive component can be used to generate the extension of rk from the
vector relation ⃗A.

182
|
4 Intensional RDB manifesto: flexible big data and NewSQL
table), which does not contain NULL values, so that we do not unnecessarily save the
NULL values of the user-defined relational tables rk ∈SA in the main memories of the
parallel RDBMS used to horizontal partitioning of the unique big-table
⃗A. Moreover,
any adding of the new columns to the user-defined schema 𝒜does not change the ta-
ble ⃗A, while the deleting of a i-th column of a relation r will delete all tuples rV(x, y, z, v)
where x = nr(r) and z = nrr(i) in the main memory of the parallel RDBMS. Thus, we
obtain very schema-flexible RDB model for big data.
Other obtained NoSQL systems’ properties are:
–
Compatible with key/value systems. Note that the vector big-table
⃗A is in the 6th
normal form, that is with the primary key corresponding to the first three at-
tributes (the free-dimensional coordinates) and the unique value attribute. Thus,
we obtained the key/value style used for NoSQL big data systems. That is, the RDB
parsing with resulting data integration system subsumes all big data key/value
systems.
–
Compatible with ‘open schema” systems. Entity-attribute-value model (EAV) is a
data model to describe entities where the number of attributes (properties, pa-
rameters) that can be used to describe them is potentially vast, but the number
that will actually apply to a given entity is relatively modest. In mathematics, this
model is known as a sparse matrix. EAV is also known as an object-attribute-value
model, vertical database model and open schema. We can use the special rela-
tional symbol with name OpenSchema in the user database schema 𝒜so that its
tuples in
⃗A will correspond to atoms rV(OpenSchema, object, attribute, value). In
this case, the software developed for the applications, which use the open schema
data will directly access to the vector relation
⃗A and DBMS will restrict all oper-
ations only to tuples where the first attribute has the value equal to OpenSchema
(during an insertion of a new tuple ⟨object, attribute, value⟩the DBMS inserts also
the value OpenSchema in the first column of ⃗A).
But this simple and unifying framework needs more investigation for the SQL and un-
derlying logical framework. In fact, we can easy see that the mapping tgds used from
the big data vector table ⃗A (the source schema in data integration) into user-defined
RDB schema 𝒜(the global schema of this data integration system with integrity con-
straints) is not a simple FOL formula. Because the same element rk is used as a predi-
cate symbol (on the right side of the tgds implication) and as a value (on the left side
of the implication as the first value in the predicate rV). It means that the elements
of the domain of this logic are the elements of other classes and are the classes for
themselves as well. Such semantics are not possible in the standard FOL, but only in
the intensional FOL provided in Chapter 1, especially in Section 1.3, with the commu-
tative diagram (1.14) between intensional and Tarski’s (extensional) interpretations of
Frede/Russell semantics of Corollary 4:

4.2 Intensional RDB: data integration system with a vector source database
|
183
𝒜int (concepts/meaning)
Frege/Russell
semantics
𝒜FOL (syntax)
I∗
T (Tarski′s interpretation)
?
intensional interpret. I
?
h (extensionalization)
?
𝒜R (denotation)
(4.4)
Consequently, the Data Integration ℐis not a classic FOL data integration as in [111] but
an intensional data integration system. In the next sections, we will investigate what is
the proper logic framework for this class of RDBs, denominated as IRDBs (intensional
RDBs), and to show that the standard SQL is complete in this new logical framework.
4.2.1 Canonical models for IRDBs
The application of the intensional FOL semantics to the data integration system ℐ=
(𝒜, 𝒮, ℳ) in Definition 44 with the user-defined RDB schema 𝒜= (SA, ΣA) and the
vector big table rV can be summarized in the following:
–
Each relational name nr(rk) (first data coordinate in Definition 43), of the predicate
(relational) letter rk ∈SA = {r1, . . . , rn} with the arity m = ar(rk), is an intensional
m-ary concept nr(rk) = I(rk(x)) ∈Dm, obtained from the atom rk(x) of the inten-
sional FOL with the tuple of variables x = (x1, . . . , xm) for a given intensional inter-
pretation I. For a given Tarski’s interpretation IT, the extensionalization function
h is determined by h(I(rk(x))) = ‖rk‖ = {⟨d1, . . . , dm⟩∈𝒟m | I∗
T (rk(d1, . . . , dm)) =
t} = I∗
T (rk(x)) ∈A, corresponding to the commutativity of diagram (4.4). The in-
stance database A of the user-defined RDB schema 𝒜is a model of 𝒜if it satisfies
all integrity constraints in ΣA.
–
The relational name nr(rV) = I(rV(y1, y2, y3, y4)) ∈D4 of the vector big table is a par-
ticular 4-ary intensional concept, such that for a given model A = {‖r1‖, . . . , ‖rn‖} of
the user-defined RDB schema 𝒜, correspondent to a given Tarski’s interpretation
IT, its extension is determined by ‖rV‖ = h(nr(rV)) = I∗
T (rV(y1, y2, y3, y4)) =
⃗A.
–
Intensional nature of the IRDB is evident in the fact that each tuple
(nr(rk), Hash(d1, . . . , dm), nrrk(i), di) ∈
⃗A,
corresponding to the ground atom rV(y1, y2, y3, y4)/g for an assignment g with
g(y1) = nr(rk) ∈Dm, g(y3) = nrrk(i) ∈D−1, g(y4) = di ∈𝒟and g(y2) = Hash(d1, . . . ,
dm) ∈D−1, is equal to the intensional tuple (I(rk(x)), Hash(d1, . . . , dm), nrrk(i), di).
Notice that the intensional tuples are different from ordinary tuples composed by
only particulars (extensional elements) in D−1, what are the characteristics of the
standard FOL (where the domain of values is equal to D−1), while here the “value”
nr(rk) = I(rk(x)) ∈Dm is an m-ary intensional concept, for which h(nr(rk)) is a
m-ary relation.

184
|
4 Intensional RDB manifesto: flexible big data and NewSQL
Figure 4.1: Intensional hierarchy system of concepts.
Based on the intensional interpretation above, we are able to represent any instance
user-defined database A as an intensional hierarchy system of concepts, presented
in the diagram, where for each tuple of data di = (di1, . . . , dim) ∈Dm
−1, 1 ≤i ≤N, of
the relation h(rk) = ‖rk‖, we have that h(I(rV(nr(rk), Hash(di), nrrk(j), dij))) = t, for dij
different from NULL, j = 1, . . . , m.
The intensional data integration system ℐ= (𝒜, 𝒮, ℳ) in Definition 44 provides
the global schema 𝒜= (SA, ΣA), which is only virtual (empty) database used to define
the SQL user-defined query, which then has to be equivalently rewritten overthe vector
relation rV in order to obtain the answer to this query. Thus, the information of the
database is stored only in the big vector table ‖rV‖ while the materialization of the
original user-defined schema 𝒜can be obtained by the following operation:
Definition 45 (Materialization of the RDB). Given a user-defined RDB schema 𝒜
=
(SA, ΣA) with SA = {r1, . . . , rn} and a big vector table ‖rV‖, the (non-SQL) operator
MATTER, which materializes the schema 𝒜into an instance database A = {R1, . . . , Rn}
where Rk = ‖rk‖, for k = 1, . . . , n, is given by the following mapping derived from (4.3),
for any R ⊆‖rV‖:
(rk, R) 󳨃→{(d1, . . . , dar(rk)) | ∃y ∈π2(R)((rV(nr(rk), y, nrrk(1), d1) ∨(d1 = NULL)) ∧⋅⋅⋅
∧(rV(nr(rk), y, nrrk(ar(rk)), dar(rk)) ∨(dar(rk) = NULL)))},
so that the complete materialization of the schema 𝒜is defined for each rk ∈SA by
Rk = ‖rk‖ =def MATTER(rk, ‖rV‖)
(4.5)
The canonical models of the intensional data integration system ℐ= (𝒜, 𝒮, ℳ) in
Definition 44 are the database instances A of the schema 𝒜such that

4.2 Intensional RDB: data integration system with a vector source database
|
185
‖rk‖ = MATTER(rk, ⋃
d∈‖rk‖
PARSE(rk, d))
(4.6)
i. e., when
A = {MATTER(rk, ⃗A) | rk ∈SA}.
The canonical models of such intensional data integration system ℐ= ⟨𝒜, 𝒮, ℳ⟩can
be provided in a usual logical framework as well.
Proposition 22. Let the IRDB be given by a data integration system ℐ= ⟨𝒜, 𝒮, ℳ⟩for
a user-defined global schema 𝒜= (SA, ΣA) with SA = {r1, . . . , rn}, the source schema
𝒮= ({rV}, 0) with the vector big data relation rV and the set of mapping tgds ℳfrom the
source schema into he relations of the global schema.
Then a canonical model of ℐis any model of the schema 𝒜+ = (SA ⋃{rV}, ΣA ⋃ℳ⋃
ℳOP), where ℳOP is an opposite mapping tgds from 𝒜into rV given by the following set
of tgds:
ℳOP = {∀x1, . . . , xar(rk)[(rk(x1, . . . , xar(rk)) ∧(xi
̸= NULL))
⇒rV(nr(rk), Hash(x1, . . . , xar(rk)), nrrk(i), xi)] | 1 ≤i ≤ar(rk), rk ∈SA}.
Proof. It is enough to show that for each rk ∈SA, and x = (x1, . . . , xar(rk)),
rk(x) ⇔((rV(nr(rk), Hash(x), nrrk(1), x1) ∨(x1 = NULL)) ∧. . .
∧(rV(nr(rk), Hash(x), nrrk(ar(rk)), xar(rk)) ∨(xar(rk) = NULL))).
From ℳOP, we have
¬rk(x) ∨¬(xi
̸= NULL) ∨rV(nr(rk), Hash(x), nrrk(i), xi),
i. e.,
(a) ¬rk(x) ∨(xi = NULL ∨rV(nr(rk), Hash(x), nrrk(i), xi)).
From the other side, from the fact that we have the constraint NOT NULL for the at-
tribute value (in Definition 44), then
¬rk(x) ∨¬(xi = NULL) ∨¬rV(nr(rk), Hash(x), nrrk(i), xi),
i. e.,
(b) ¬rk(x) ∨¬(xi = NULL ∧rV(nr(rk), Hash(x), nrrk(i), xi)),
is true and also the conjunction of (a) and (b) has to be true, i. e.,
(¬rk(x) ∨(xi = NULL ∨rV(nr(rk), Hash(x), nrrk(i), xi)))
∧(¬rk(x) ∨¬(xi = NULL ∧rV(nr(rk), Hash(x), nrrk(i), xi)));

186
|
4 Intensional RDB manifesto: flexible big data and NewSQL
thus, by distributivity,
(c) ¬rk(x) ∨(xi = NULL ∨rV(nr(rk), Hash(x), nrrk(i), xi)).
If we repeat this for all 1 ≤i ≤ar(rk) and make conjunction of all these true formula,
by distributive property of such conjunction ∧, we obtain
¬rk(x) ∨((x1 = NULL ∨rV(nr(rk), Hash(x), nrrk(1), x1)) ∧. . .
∧(xar(rk) = NULL ∨rV(nr(rk), Hash(x), nrrk(ar(rk)), xar(rk)))),
i. e.,
(d) rk(x) ⇒((rV(nr(rk), Hash(x), nrrk(1), x1) ∨x1 = NULL) ∧. . . ∧(rV(nr(rk), Hash(x),
nrrk(ar(rk)), xar(rk)) ∨xar(rk) = NULL)).
Moreover, from the definition we also have
(e) rk(x) ⇐((rV(nr(rk), Hash(x), nrrk(1), x1) ∨x1 = NULL) ∧. . . ∧(rV(nr(rk), Hash(x),
nrrk(ar(rk)), xar(rk)) ∨xar(rk) = NULL)).
That is, the logical equivalence of the formula on the left-hand and on the right-hand
side of the logical implication, and hence if the atom rk(x) is true for some assignment
g to the variables so that the tuple (g(x1), . . . , g(xar(rk))) is in relation rk ∈𝒜, then for
the same assignment g the every formula
rV(nr(rk), Hash(x), nrrk(1), x1) ∨x1 = NULL,
. . . ,
rV(nr(rk), Hash(x), nrrk(ar(rk)), xar(rk)) ∨xar(rk) = NULL
has to be true, and hence generates the tuples in rV for NOT NULL values of g(xi),
1 ≤i ≤ar(rk).
Notice that the implication (d) corresponds to the non-SQL operator PARSE, while
the implication (e) is the logical semantics of the non-SQL operator MATTER.
Consequently, we obtain ‖rk‖
=
MATTER(rk, ⋃v∈‖rk‖ PARSE(rk, v)), i. e., A
=
{MATTER(rk, ⃗A) | rk ∈SA} and the database instance A, which satisfies all integrity
constraints ΣA ⋃ℳ⋃ℳOP is the canonical model of the intensional data integration
system ℐ= (𝒜, 𝒮, ℳ).
We are also able to render more flexible this approach and to decide only a subset
of relations to be the intensional concepts whose extension has to be parsed in to the
big vector table rV. For standard legacy systems, we can chose to avoid at all to have
the intensional concepts, thus to have the standard RDBs with standard FOL Tarski’s
semantics. By declaring any of the relational names of rk ∈SA as an intensional con-
cept, we conservatively extend the Tarski’s semantics for the FOL in order to obtain
more expressive intensional FOL semantics for the IRDBs.

4.2 Intensional RDB: data integration system with a vector source database
|
187
The fact that we assumed rV to be used only as particular (extensional entity) and
not as intensional 4-ary concept nr(rV) = I(rV(x1, x2, x3, x4)) is based on the fact that it
will always be materialized (into the nonempty relational table) as standard tables in
the RDBs. The other reason is that the extension h(nr(rV)) has to represent the whole
set of relations in the instance database A. That is, nr(rV) is not a significant user’s con-
cept but only a mathematical entity useful to parse the user’s conceptual ER database
and to contain its relations rk ∈SA in atomic vectorial form compatible with practice
of big data.
Consequently, we do not use the 4-ary intensional concept nr(rV) (equal to the
name of the database 𝒜) as a value in the tuples of other relations, or in any tuple
of vector relation rV, and we do not apply the parsing to rV different from all relations
rk ∈SA (assumed to be the intensional concepts as well)in the user-definedconceptual
RDB schema 𝒜.
This vector relation, hidden to users, is only a mathematical object, which sup-
ports the virtual reality of user’s defined conceptual RDB schema, and used to respond
to user’s queries over their RDB virtual schema by query-rewriting methods (transform-
ing original user’s query over his virtual RDB schema into a query over this material-
ized big vector relation rv).
Example 21 (Hypothesis of a recursive parsing of vector relation into itself). If
we
would decide to use also rV as an intensional concept in D4, we would be able to parse
it (as all other intensional concepts in 𝒜) into itself, and such recursive definition
will render (only theoretically) an infinite extension of the rV, thus nonapplicable, as
follows:
Let for an user-defined n-ary relational table rk ∈SA, it intensional n-ary concept
(name) be I(rk(x)) = nr(rk) = Person ∈Dn, and Pname an attribute-name of this ta-
ble rk, and let ID be the t-index value obtained by Hash function from one tuple of rk
where the value of the attribute Pname is “Marco Aurelio,” then we will obtain by pars-
ing these tuples in the vector table rV with its name (intensional concept) nr(rV) ∈D4:
1.
(Person, ID, Pname, Marco Aurelio) ∈‖rV‖;
then by parsing this tuple 1, we will obtain for
ID1 = Hash(Person, ID, Pname, Marco Aurelio)
also the following new tuples in the vector relation ‖rV‖:
2.
(nr(rV), ID1, r-name, Person);
3.
(nr(rV), ID1, t-index, ID);
4.
(nr(rV), ID1, a-name, Pname);
5.
(nr(rV), ID1, value, Marco Aurelio); then by parsing the tuple 2 above, we will ob-
tain for

188
|
4 Intensional RDB manifesto: flexible big data and NewSQL
ID2 = Hash(nr(rV), ID1, r-name, Person),
the following new tuples in the vector relation ‖rV‖:
6.
(nr(rV), ID2, r-name, nr(rV));
7.
(nr(rV), ID2, t-index, ID1);
8.
(nr(rV), ID2, a-name, r-name);
9.
(nr(rV), ID2, value, Person); then by parsing this tuple 9 above, we will obtain for
ID3 = Hash(nr(rV), ID2, r-name, Person),
the following new tuples:
10. (nr(rV), ID3, r-name, nr(rV));
etc.
Thus, as we see, the tuple 10 is equal to the tuple 6, but only with new t-index (tuple
index) value, so by continuing this process, theoretically (if we do not pose the limits
for the values of t-indexes) we obtain an infinite process and an infinite extension of rV.
Obviously, it can not happen in real RDBs, because the length of the attribute t-index
is finite so that at some point we will obtain the previously generated value for this
attribute (we reach a fixed point), and from the fact that this attribute is a part of the
primary key this tuple would not be inserted in rV because rV contains the same tuple
already.
Notice that this process, described in the example above, is analogous to the self-
referencing process, where we try to use an intensional concept as an element of itself
that has to be avoided, and hence there is no sense to use (in software applications)
rV as an intensional concept. Consequently, the IRDB has at least one relational table,
which is not used as an intensional concept, and hence will not be parsed: the big
vector table rV.
4.2.2 NewSQL property of the IRDBs
This section will be dedicated to demonstrate that the IRDBs are complete w. r. t. the
standard SQL. This demonstration is based on the fact that each SQL query, defined
over the user-defined schema 𝒜, which (in its full (virtual) intensional immersion) is
composed by the only intensional concepts, and hence will be executed over standard
relational tables that are not the intensional concepts. If a query is defined over the
nonintensional concepts (materialized relations with saved tuples) in 𝒜, in this case
it will be directly executed over these relational tables as in each RDB. If a query is
defined over the intensional relation-concepts nr(rk) = I(rk(x)), with rk ∈𝒜, (with-
out their direct materialized extensions tables h(nr(rk)) = h(I(rk(x))) = I∗
T (rk(x)) for a
given Tarski model IT of this data base), then we need to demonstrate the existence

4.2 Intensional RDB: data integration system with a vector source database
|
189
of an effective query rewriting into an equivalent SQL query over the (nonintensional
concept) big vector table rV.
In order to define this query rewriting, we will shortly introduce the abstract syn-
tax and semantics of Codd’s relational algebra, as follows. Five primitive operators
of Codd’s algebra are: the selection, the projection, the Cartesian product (also called
the cross-product or cross-join), the set union and the set difference. Another opera-
tor, rename, was not noted by Codd, but the need for it is shown by the inventors of
Information Systems Base Language (ISBL) for one of the earliest database manage-
ment systems, which implemented Codd’s relational model of data. These six opera-
tors are fundamental in the sense that if we omit any one of them, we will lose expres-
sive power. Many other operators have been defined in terms of these six. Among the
most important are set intersection, division and the natural join. In fact, ISBL made
a compelling case for replacing the Cartesian product with the natural join, of which
the Cartesian product is a degenerate case.
Remark. We recall the following notation conventions: for any k-ary relational table r,
with k = ar(r), with the injective function nrr : {1, . . . , k} →SN, which assigns distinct
names to each column of this relation r, we denote its tuple of attributes atr(r) = a =
(a1, . . . , ak) = (atrr(1), . . . , atrr(k)), and the set of attributes denoted by a = atr(r). We
recall that two relations r1 and r2 are union compatible iff atr(r1) = atr(r2). If a relation
r2 is obtained from a given relation r1 by permutating its columns, then we tell that
they are not equal (in set theoretic sense) but that they are equivalent. Notice that in
the RDB theory the two equivalent relations are considered equal as well.
In what follows, given any two lists (tuples), d = (d1, . . . , dk) and b = (b1, . . . , bm)
their concatenation (d1, . . . , dk, b1, . . . , bm) is denoted by d&b, where ‘&’ is the symbol
for concatenation of the lists. By ‖r‖, we denote the extension of a given relation (re-
lational symbol) r; it is extended to any term tR of Codd’s algebra, so that ‖tR‖ is the
relation obtained by computation of this term.
Let us briefly define these basic operators, and their correspondence with the for-
mulae of FOL:
1.
Rename is a unary operation written as “_ RENAME name1 AS name2” where the
result is identical to the input argument (relation) r except that the column i with
name nrr(i) = name1 in all tuples is renamed to nrr(i) = name2.
This operation is neutral w. r. t. the logic, where we are using the variables for the
columns of relational tables and not their names.

190
|
4 Intensional RDB manifesto: flexible big data and NewSQL
2.
The Cartesian product is a binary operation “_ TIMES _,” written also as “_ ⨂_,”
such that for the relations r1 and r2, first we do the rename normalization of r2
(w. r. t. r1), denoted by rρ
2, such that:
For each k-th copy of the attribute ai (or, equivalently, ai(0)) of the m-th column of r2
(with 1 ≤m ≤ar(r2)), denoted by ai(k) = atrr2(m) ∈atr(r2), such that the maximum
index of the same attribute ai in r1 is ai(n), we change r2 by:
1.
ai(k) 󳨃→ai(k + n);
2.
if name1 = nrr2(m) is a name that exists in the set of the column names in r1, then
we change the naming function nrr2 : {1, . . . , ar(r2)} →SN, by nrr2(m) = name2,
where name2 ∈SN is a new name distinct from all other used names, and we
define the renaming normalization ρ by mapping name1 󳨃→name2.
The relation obtained from r2, after this renaming normalization, will be denoted
by rρ
2. Then we define the new relation r (when both ‖r1‖
̸= {⟨⟩} and ‖r2‖
̸= {⟨⟩},
i. e., when are not empty relations) by r1 ⨂rρ
2, with ‖r‖ =def {d1&d2 | d1 ∈‖r1‖, d2 ∈
‖r2‖}, with the naming function nrr : {1, . . . , ar(r1) + ar(r2)} →SN, such that nrr(i) =
nrr1(i) for 1 ≤i ≤ar(r1) and nrr(i) = nrr2(i) for 1 + ar(r1) ≤i ≤ar(r1) + ar(r2),
and atrr : {1, . . . , ar(r1) + ar(r2)} →att function defined by atrr(i) = atrr1(i) for
1 ≤i ≤ar(r1) and atrr(i) = atrr2(i) for 1 + ar(r1) ≤i ≤ar(r1) + ar(r2).
This Cartesian product is given by the following logical equivalence, by consider-
ing the relational symbols as predicates,
r(x1, . . . , xar(r1), y1, . . . , yar(r2)) ⇔(r1(x1, . . . , xar(r1)) ∧r2(y1, . . . , yar(r2))),
so that ‖r‖ = 󵄩󵄩󵄩󵄩r1(x1, . . . , xar(r1)) ∧r2(y1, . . . , yar(r2))󵄩󵄩󵄩󵄩
(if ‖r1‖ is empty, then r1 ⨂rρ
2 = r2; if ‖r2‖ is empty, then r1 ⨂rρ
2 = r1).
3.
Projection is a unary operation written as “_ [S],” where S is a tuple of column
names such that for a relation r1 and S = ⟨nrr1(i1), . . . , nrr1(ik)⟩, with k ≥1 and
1 ≤im ≤ar(r1) for 1 ≤m ≤k, and im
̸= ij if m
̸= j, we define the relation r by r1[S],
with ‖r‖ = ‖r1‖ if ∃name ∈S. name ∉nr(r1); otherwise ‖r‖ = π⟨i1,...,ik⟩(‖r1‖), where
nrr(m) = nrr1(im), atrr(m) = atrr1(im), for 1 ≤m ≤k.
This projection is given by the following logical equivalence:
r(xi1, . . . , xik) ⇔∃xj1 . . . xjnr1(x1, . . . , xar(r1)),
where n = ar(r1) −k and for all 1 ≤m ≤n, jm ∉{i1, . . . , ik}, so that
‖r‖ = ‖∃xj1 . . . xjnr1(x1, . . . , xar(r1))‖.
4.
Selection is a unary operation written as “_ WHERE C,” where a condition C
is a finite-length logical formula that consists of atoms ‘(namei θ namej)’ or
‘(namei θd)’, with built-in predicates θ ∈Σθ ⊇{≐, ⟩, ⟨}, a constant d, and the

4.2 Intensional RDB: data integration system with a vector source database
|
191
logical operators ∧(AND), ∨(OR) and ¬ (NOT), such that for a relation r1 and
namei, namej the names of its columns, we define the relation r by
r1 WHERE C,
as the relation with atr(r) = atr(r1) and the function nrr equal to nrr1, where ‖r‖ is
composed by the tuples in ‖r1‖ for which C is satisfied.
This selection is given by the following logical equivalence:
r(xi1, . . . , xik) ⇔(r1(x1, . . . , xar(r1)) ∧C(x)),
where C(x) is obtained by substitution of each namei = nrr1(j) (of the j-th column
of r1) in the formula C by the variable xj, so that
‖r‖ = 󵄩󵄩󵄩󵄩r1(x1, . . . , xar(r1)) ∧C(x)󵄩󵄩󵄩󵄩.
5.
Union is a binary operation written as “_ UNION _,” such that for two union-
compatible relations r1 and r2, we define the relation r by: r1 UNION r2, where
‖r‖ =def ‖r1‖ ⋃‖r2‖, with atr(r) = atr(r1), and the functions atrr = atrr1, and nrr =
nrr1. This union is given by the following logical equivalence:
r(x1, . . . , xn) ⇔(r1(x1, . . . , xn) ∨r2(x1, . . . , xn)),
where n = ar(r) = ar(r1) = ar(r2), so that
‖r‖ = 󵄩󵄩󵄩󵄩r1(x1, . . . , xn) ∨r2(x1, . . . , xn)󵄩󵄩󵄩󵄩.
6.
Set difference is a binary operation written as “_ MINUS_” such that for two union-
compatible relations r1 and r2, we define the relation r by: r1 MINUS r2, where
‖r‖ =def {t | t ∈‖r1‖ such that t ∉‖r2‖}, with atr(r) = atr(r1), and the functions
atrr = atrr1 and nrr = nrr1.
Let r1 and r2 be the predicates (relational symbols) for these two relations. Then
their difference is given by the following logical equivalence:
r(x1, . . . , xn) ⇔(r1(x1, . . . , xn) ∧¬r2(x1, . . . , xn)),
where n = ar(r) = ar(r1) = ar(r2), and hence
‖r‖ = ‖r1(x1, . . . , xn) ∧¬r2(x1, . . . , xn)‖.
Natural join ⋈S is a binary operator, written as (r1⋈Sr2), where r1 and r2 are the relations.
The result of the natural join is the set of all combinations of tuples in r1 and r2 that are
equal on their common attribute names. In fact, (r1 ⋈S r2) can be obtained by creating
the Cartesian product r1 ⨂r2 and then by execution of the selection with the condition

192
|
4 Intensional RDB manifesto: flexible big data and NewSQL
C defined as a conjunction of atomic formulae (nrr1(i) = nrr2(j)) with (nrr1(i), nrr2(j)) ∈S
(where i and j are the columns of the same attribute in r1 and r2, respectively, i. e.,
satisfying atrr1(i) = atrr2(j)) that represents the equality of the commonattributenames
of r1 and r2. The natural join is arguably one of the most important operators since it
is the relational counterpart of logical AND. Note carefully that if the same variable
appears in each of two predicates that are linked by AND, then that variable stands for
the same thing and both appearances must always be substituted by the same value.
In particular, natural join allows the combination of relations that are associated by a
foreign key. It can also be used to define composition of binary relations.
Altogether the operators of relational algebra have identical expressive power to
that of the domain relational calculus or tuple relational calculus. However, relational
algebra is less expressive than first-order predicate calculus without function sym-
bols. Relational algebra corresponds to a subset of FOL (denominated relational cal-
culus), namely Horn clauses without recursion and negation (or union of conjunc-
tive queries). Consequently, relational algebra is essentially equivalent in expressive
power to relational calculus (and thus FOL and queries defined in Section 4.2); this
result is known as Codd’s theorem. However, the negation, applied to a formula of the
calculus, constructs a formula that may be true on an infinite set of possible tuples. To
overcome this difficulty, Codd restricted the operands of relational algebra to finite re-
lations only and also proposed restricted support for negation ¬ (NOT) and disjunction
∨(OR). Codd defined the term “relational completeness” to refer to a language that is
complete with respect to first-order predicate calculus apart from the restrictions he
proposed. In practice, the restrictions have no adverse effect on the applicability of his
relational algebra for database purposes.
Several papers have proposed new operators of an algebraic nature as candi-
dates for an addition to the original set. We choose the additional unary operator
“EXTEND_ADD a, name AS e” denoted shortly as _⟨a, name, e⟩, where a is a new
added attribute as the new column (at the end of relation) with a new fresh name
name and e is an expression (in the most simple cases it can be the value NULL or
a constant d, or the i-th column name nr(i) of the argument (i. e., relation) of this
operation), for update relational algebra operators, in order to cover all of the basic
features of data manipulation (DML) aspects of a relation models of data, so that
–
We define a unary operator _⟨a, name, e⟩, for an attribute a ∈att, its name, and
expression e, as a function with a set of column names, such that for a relation
r1 and expression e composed of the names of the columns of r1 with n = ar(r1),
we obtain the (ar(r1) + 1)-ary relation r by ⟨a, name, e⟩(r1), with naming function
nrr : {ar(r1) + 1} →SN such that nrr(i) = nrr1(i) if i ≤ar(r1); nrr(ar(r1) + 1) = name
otherwise, being a fresh new name for this column; with the attribute function
atrr : {ar(r1) + 1} →att such that atrr(i) = atrr1(i) if i ≤ar(r1); atrr(ar(r1) + 1) = a
otherwise, and
‖r‖ = {⟨⟩} ⋃{d&e(d) | d ∈‖r1‖},

4.2 Intensional RDB: data integration system with a vector source database
|
193
where e(d) ∈dom(a) is a constant or the value obtained from the function e where
each name nrr(i) is substituted by the value di of the tuple d = (d1, . . . , dn) ∈‖r1‖;
in the special cases, we can use nullary functions (constants) for the expression e
(e. g., for the NULL value).
(note that r is empty if e is an expression and r1 empty as well).
Then, for a nonempty relation r1, the EXTEND r1 ADD a, name AS e (i. e., r1⟨a,
name, e⟩) can be represented by the following logical equivalence:
r(x1, . . . , xn+1) ⇔(r1(x1, . . . , xn) ∧(xn+1 = e(x)))
where e(x) is obtained by substituting each namei = nrr1(j) (of the j-th column
of r1) in the expression e by the variable xj.
We are able to define a new relation with a single tuple (d1, . . . , dk), k ≥1 with the given
list of attributes (a1, . . . , ak), by the following finite length expression:
EXTEND(. . . (EXTEND r0 ADD a1, name1 AS d1) . . .) ADD ak, namek AS dk,
or equivalently by
r0(a1, name1, d1) ⨂⋅⋅⋅⨂r0(ak, namek, dk),
where r0 is the empty type relation with ‖r0‖ = {⟨⟩} = 𝒟0, ar(r0) = 0 introduced after
Definition 6 in Section 1.2, and empty functions atrr0 and nrr0. Such single tuple rela-
tions can be used for an insertion in a given relation (with the same list of attributes)
in what follows.
Update operators
The three update operators, “UPDATE,” “DELETE” and “INSERT” of the relational al-
gebra, are derived operators from these previously defined operators in the following
way:
1.
Each algebraic formulae “DELETE FROM r WHERE C” is equivalent to the formula
“r MINUS (r WHERE C).”
2.
Each algebraic expression (a term) “INSERT INTO r[S] VALUES (list of values),”
“INSERT INTO r[S] AS SELECT…,” is equivalent to “r UNION r1” where the union
compatible relation r1 is a one-tuple relation (defined by list) in the first, or a re-
lation defined by “SELECT…” in the second case.
In the case of a single tuple insertion (version with “VALUES”) into a given rela-
tion r, we can define a single tuple relation r1 by using “EXTEND…” operations.
3.
Each algebraic expression “UPDATE r SET [nrr(i1)
=
ei1, . . . , nrr(ik)
=
eik]
WHERE C,” for n = ar(r), where eim, 1 ≤im ≤n for 1 ≤m ≤k are the expres-

194
|
4 Intensional RDB manifesto: flexible big data and NewSQL
sions and C is a condition, is equal to the formula “(r WHERE ¬C) UNION r1,”
where r1 is a relation expressed by
(EXTEND(. . . (EXTEND (r WHERE C) ADD attr(1), name1 AS e1) . . .)
ADD attr(n), namen AS en)[S],
such that for each 1 ≤m ≤n, if m ∉{i1, . . . , ik} then em = nrr(m), and S =
⟨name1, . . . , namen⟩.
Consequently, all update operators of the relational algebra can be obtained by addi-
tion of these “EXTEND_ADD a, name AS e” operations.
Let us define the ΣR-algebras sa follows ([21], Definition 31 in Section 5.1).
Definition 46. We denote the algebra of the set of operations, introduced previously
in this section (points from 1 to 6 and “EXTEND_ADD a, name AS e”) with addi-
tional nullary operator (empty-relation constant) ⊥, by ΣRE. Its subalgebra with-
out “_MINUS_” operator is denoted by Σ+
R, and without ⊥and unary operators
‘EXTEND_ADD a, name AS e’ is denoted by ΣR (it is the “select-project-join-rename+
union” (SPJRU) subalgebra).
We define the set of terms 𝒯PX with variables in X of this ΣR-algebra (and analo-
gously for the terms 𝒯+
P X of Σ+
R-algebra), inductively as follows:
1.
Each relational symbol (a variable) r ∈X ⊆ℝand a constant (i. e., a nullary
operation) is a term in 𝒯PX;
2.
Given any term tR ∈𝒯PX and an unary operation oi ∈ΣR, oi(tR) ∈𝒯PX;
3.
Given any two terms tR, t′
R ∈𝒯PX and a binary operation oi ∈ΣR, oi(tR, t′
R) ∈𝒯PX.
We define the evaluation of terms in 𝒯PX, for X = ℝ, by extending the assignment
‖_ ‖ : ℝ→ϒ, which assigns a relation to each relational symbol (a variable) to all terms
by the function ‖_ ‖# : 𝒯Pℝ→ϒ (with ‖r‖# = ‖r‖), where ϒ is the universal database
instance (set of all relations for a given universe 𝒟). For a given term tR with relational
symbols r1, . . . , rk ∈ℝ, ‖tR‖# is the relational table obtained from this expression for
the given set of relations ‖r1‖, . . . , ‖rk‖ ∈ϒ, with the constraint that
‖tR UNION t′
R‖# = ‖tR‖# ⋃‖t′
R‖#
if the relations ‖tR‖# and ‖t′
R‖# are union compatible;
⊥= {⟨⟩} = ‖r0‖
(empty relation) otherwise.
We say that two terms tR, t′
R ∈𝒯PX are equivalent (or equal), denoted by tR ≈t′
R, if for
all assignments ‖tR‖# = ‖t′
R‖#.
We say that an extension ‖tR‖#, of a term tR ∈𝒯PX, is a vector relation of the vector
view denoted by 󳨀→
tR if the type of ‖tR‖# is equal to the type of the vector relation rV.

4.2 Intensional RDB: data integration system with a vector source database
|
195
Let R = ‖󳨀→
tR‖# be the relational table with the following four attributes (as in rV)
r-name, t-index, a-name and value, then its user-defined view representation can be
derived as follows
Definition 47 (View materialization). Let tR ∈𝒯PX be a user-defined SPJU (Select-
Project-Join-Union) view over a database schema 𝒜= (SA, ΣA) with the type (the
tuple of the view columns) S = ⟨(rk1, namek1), . . . , (rkm, namekm)⟩, where the i-th col-
umn (rki, nameki) is the column with name equal to nameki of the relation rki ∈SA,
1 ≤i ≤m, and 󳨀→
tR be the rewritten query over vector relation rV.
Let R = ‖󳨀→
tR‖# be the resulting relational table with the four attributes (as that of rV)
r-name, t-index, a-name and value. We define the operation VIEW of the transforma-
tion of R into the user defined view representation by:
VIEW(S, R) = {(d1, . . . , dm) | ∃ID ∈π2(R), ∀1≤i≤m(nr(rki), ID, nameki, di) ∈R;
otherwise set di to NULL}.
Notice that we have, from (4.6), for each rk ∈SA with R = ⋃d∈‖rk‖ PARSE(rk, d), and
S = ⟨(rk, nrrk(1)), . . . , (rk, nrrk(ar(rk)))⟩,
‖rk‖ = MATTER (rk, R) = VIEW (S, R)
(4.7)
and hence the non-SQL operation MATTER is a special case of the operation VIEW.
For any original user-defined query (term) tR over a user-defined database
schema 𝒜, by 󳨀→
tR we denote the equivalent (rewritten) query over the vector relation rV.
We have the following important result for the IRDBs.
Proposition 23 (SQL completeness of IRDB). There exists a finite algorithm for the term
rewriting of any user-defined SQL term tR over a schema 𝒜, of the full relational algebra
ΣRE in Definition 46, into an equivalent vector query 󳨀→
tR over the vector relation rV.
If tR is a user-defined SPJU term (in Definition 47) of the type S, then
‖tR‖# = VIEW(S, ‖󳨀→
tR‖#).
Proof. In this proof, we will use the convention that two NULL values cannot be com-
pared as equal, because their meaning is that the value is missing, and two missing
values not necessarily are equal. In fact, in rV we do not store the null values but
consider them as unknown missing values. Thus, when there are null values in the
columns of the user-defined tables being joined, the null values do not match each
other. For simplicity, we will use for relations symbols and their names the same sym-
bol in what follows.
Let us show that there is such a query (relation algebra term) rewriting for each
basic relational operator previously described, recursively (in what follows, if tR = r
then 󳨀→
tR = rV WHERE r-name = r):

196
|
4 Intensional RDB manifesto: flexible big data and NewSQL
1.
(Rename). t′
R = r RENAME name1 AS name2 where the result is identical to input
argument (relation) r except that the column i with name nrr(i) = name1 in all
tuples is renamed to nrr(i) = name2. The rewritten vector query is
󳨀→
t′
R = UPDATE rV SET [a-name = name2] WHERE (r-name = r) ∧(a-name = name1);
2.
(Projection). t′
R = tR[S], where S = ⟨(rj1, nrrj1 (i1)), . . . , (rjk, nrrjk (ik))⟩⊆S, with k ≥1
and 1 ≤im ≤ar(rjm) for 1 ≤m ≤k, is a subset of the type S of the term tR. We
define the rewritten vector query
󳨀→
t′
R = 󳨀󳨀󳨀→
tR[S] = 󳨀→
tR WHERE ((nr󳨀→
tR
(1) = rj1) ∧(nr󳨀→
tR
(2) = nrrj1 (i1))) ∨⋅⋅⋅
∨((nr󳨀→
tR
(1) = rjk) ∧(nr󳨀→
tR
(2) = nrrjk (ik)));
3.
(Join). t′
R = tR,1 ⋈S tR,2, where S = (((rl1, nrrl1 (i1)), (rn1, nrrn1 (j1))), . . . , (((rlm, nrrlm (im)),
(rnm, nrrnm (jm))))) with 1 ≤ik ≤|S1| and 1 ≤jk ≤|S2| for 1 ≤k ≤m, where S1 and
S2 are the types of tR,1 and tR,2, respectively.
Let us define the following relational algebra terms: r =
m
⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞
󳨀󳨀→
tR,1 ⨂⋅⋅⋅⨂󳨀󳨀→
tR,1 ⨂
m
⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞
󳨀󳨀→
tR,2 ⨂⋅⋅⋅⨂󳨀󳨀→
tR,2; (the first m are for the attributes of 󳨀󳨀→
tR,1 in S, and the last m are
for the corresponded joined attributes of 󳨀󳨀→
tR,2 in S). Note that each column name
of 󳨀󳨀→
tR,1 will be renamed m times in order to have for each column different name
in standard way as for attributes: for example, the column a-name in 󳨀󳨀→
tR,1 will be
repeated by a-name(1), . . . , a-name(m) (and similarly for each column name of 󳨀󳨀→
tR,2),
and the attribute atr(2) (of the column t-index in rV) will be repeated by its copies
atr(2)(1), . . . , atr(2)(2m) (in what follows will be also generated the (2m+1)-th copy
atr(2)(2m + 1) in the algebra term t2). Thus,
t1 = r WHERE ( ⋀
1≤k≤m
((nrr(4k −3) = rlk) ∧(nrr(4k −1) = nrrlk (ik))
∧(nrr(4(m + k) −3) = rnk) ∧(nrr(4(m + k) −1) = nrrnk (jk))
∧(nrr(4k) = nrr(4(m + k) + 4)))
∧((m = 1) ∨((nrr(2) = nrr(6) = . . . = nrr(4m −2))
∧(nrr(4m + 2) = nrr(4m + 6) = . . . = nrr(8m −2)))));
t2 = (EXTEND t1 ADD ((atrr(2))(2m + 1), name3, Hash(atrr(1), atrr(2), . . . ,
atrr(8m))))[nrt1(2), nrt1(4m + 2), name3];
where name3 is a fresh new name and

4.2 Intensional RDB: data integration system with a vector source database
|
197
‖t2‖# = {⟨ID1, ID2, ID3⟩| ID1
is the tuple index in ‖tR,1‖# and ID2 is the corresponding joined tuple index in
‖tR,2‖#, while ID3 is the fresh new generated (by Hash function) tuple index for
the tuple obtained by join operation}, then for the Cartesian products t3 = 󳨀󳨀→
tR,1 ⨂t2
and t4 = 󳨀󳨀→
tR,2 ⨂t2,
󳨀→
t′
R = 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
tR,1 ⋈S tR,2
= ((t3 WHERE (nrt3(2) = nrt3(5)))[nrt3(1), name3, nrt3(3), nrt3(4)])
UNION ((t4 WHERE (nrt4(2) = nrt4(6)))[nrt4(1), name3, nrt4(3), nrt4(4)]);
4.
(Selection). t′
R = tR WHERE C:
4.1 When a condition C is a finite-length logical formula that consists of atoms
‘((ri1, namei)θ(rj1, namej))’ or ‘(ri1, namei)θd’ or ‘(ri1, namei)’ NOT NULL with
built-in predicates θ ∈Σθ ⊇{≐, >, <}, a constant d, and the logical operators,
between the columns in the type S of the term tR.
The condition C, composed by k ≥1 different columns in S, we denote by
C((ri1, namei1), . . . , (rik, nameik)), k ≥1, and hence we define the rewritten vec-
tor query
󳨀→
t′
R = 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
tR WHERE C = 󳨀→
tR WHERE nr󳨀→
tR
(2) IN t1
where for r =
k
⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞
󳨀→
tR ⨂⋅⋅⋅⨂󳨀→
tR we define the unary relation, which contains
the tuple indexes of the relation ‖tR‖ for its tuples, which satisfy the selection
condition C, by the following selection term:
t1 = (r WHERE ((nrr(1) = ri1 ∧nrr(3) = namei1) ∧. . . ∧(nrr(1 + 4(k −1))
= rik ∧nrr(3 + 4(k −1)) = namei1)) ∧C(nrr(4), . . . , nrr(4k))
∧((k = 1) ∨(nrr(2) = nrr(6) = . . . = nrr(2 + 4(k −1)))))[nrr(2)];
4.2 Case when C = (ri1, namei) NULL,
󳨀→
t′
R = 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
tR WHERE (ri1, namei) NULL = 󳨀→
tR WHERE nr󳨀→
tR
(2) NOT IN t2,
where t2 = (󳨀→
tR WHERE ((nr󳨀→
tR
(1) = ri1) ∧(nr󳨀→
tR
(3) = namei))[(nr󳨀→
tR
(2)].
From the fact thattR WHERE C1∧C2 = (tR WHERE C1) WHEREC2 andtR WHERE
C1 ∨C2 = (tR WHERE C1) UNION (tR WHERE C2), and De Morgan laws, ¬(C1 ∧
C2) = ¬C1 ∨¬C2, ¬(C1 ∨C2) = ¬C1 ∧¬C2, we can always divide any selection in
the components of the two disjoint cases above;

198
|
4 Intensional RDB manifesto: flexible big data and NewSQL
5.
(Union). t′
R = tR,1 UNIONRtR,2, where R is a table {⟨rlk, namelk, rnk, namenk⟩| 1 ≤k ≤
m} such that S1 = ⟨(rl1, namel1), . . . , (rlm, namelm)⟩and S2 = ⟨(rn1, namen1), . . . , (rnm,
namenm)⟩are the types of tR,1 and tR,1, respectively, with the union-compatible
columns (⟨rlk, namelk) and (⟨rnk, namenk) for every 1 ≤k ≤m. We define the rela-
tional algebra term t1 = 󳨀󳨀→
tR,2 ⨂R, so that
󳨀→
t′
R = 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
tR,1 UNIONR tR,2
= 󳨀󳨀→
tR,1 UNION ((t1 WHERE ((nrt1(1) = nrt1(7))
∧(nrt1(3) = nrt1(8))))[nrt1(5), nrt1(2), nrt1(6), nrt1(4)]),
so that the relation-column names of the union will be equal to the column names
of the first term in this union;
6.
(Set difference). t′
R = tR,1 MINUSRtR,2, where R is a table {⟨rlk, nrrlk (ik), rnk, nrrnk (jk)⟩|
1 ≤k ≤m} such that S1 = ⟨(rl1, nrrl1 (i1)), . . . , (rlm, nrrlm (im))⟩and S2 = ⟨(rn1, nrrn1 (j1)),
. . . , (rnm, nrrnm (jm))⟩are the types of tR,1 and tR,1, respectively, with the union-
compatible columns (⟨rlk, nrrlk (ik)) and (⟨rnk, nrrnk (jk)) for every 1 ≤k ≤m. Let us
define the following relational algebra terms:
r =
m
⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞
󳨀󳨀→
tR,1 ⨂⋅⋅⋅⨂󳨀󳨀→
tR,1 ⨂
m
⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞
󳨀󳨀→
tR,2 ⨂⋅⋅⋅⨂󳨀󳨀→
tR,2;
(the first m are for the attributes of 󳨀󳨀→
tR,1 in S1, and the last m are for the corre-
sponded joined attributes of 󳨀󳨀→
tR,2 in S2). Thus,
t1 = (r WHERE ( ⋀
1≤k≤m
((nrr(4k −3) = rlk) ∧(nrr(4k −1)
= nrrlk (ik)) ∧(nrr(4(m + k) −3) = rnk) ∧(nrr(4(m + k) −1)
= nrrnk (jk)) ∧(nrr(4k) = nrr(4(m + k) + 4)))
∧((m = 1) ∨((nrr(2) = nrr(6) = . . . = nrr(4m −2))
∧(nrr(4m + 2) = nrr(4m + 6) = . . . = nrr(8m −2))))))[nrt1(2)];
where ‖t1‖# = {⟨ID1⟩| ID1 is the tuple index of a tuple in ‖tR,1‖# for which there
exists an equal tuple in ‖tR,2‖#}. Then
󳨀→
t′
R = 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
tR,1 MINUSRtR,2 = 󳨀󳨀→
tR,1 WHERE nr󳨀󳨀→
tR,1
(2) NOT IN t1.
It is easy to show that for the cases from 2 to 6, we obtain that ‖t′
R‖# = VIEW(S, ‖
󳨀→
t′
R‖#),
where S is the type of the relational algebra term t′
R. Thus, for any SPJU term tR ob-

4.2 Intensional RDB: data integration system with a vector source database
|
199
tained by the composition of these basic relational algebra operators we have that
‖tR‖# = VIEW(S, ‖󳨀→
tR‖#).
The update operators are rewritten as follows:
1.
(Insert). INSERT INTO r[S] VALUES (d1, . . . , dm), where S = ⟨nrr(i1), . . . , nrr(im)⟩,
1 ≤m ≤ar(r), is the subset of mutually different attribute names of r and all di,
1 ≤i ≤m are the values different from NULL. It is rewritten into the following set
of terms:
{INSERT INTO rV[r-name, t-index, a-name, value]
VALUES (r, Hash(d1, . . . , dm), nrr(ik), dk) | 1 ≤k ≤m}.
Note that before the execution of this set of insertion operations in rV, the DBMS
has to control if it satisfies all user-defined integrityconstraints in the user-defined
database schema 𝒜;
2.
(Delete). DELETE FROM r WHERE C, is rewritten into the term:
DELETE FROM rV WHERE t-index IN 󳨀→
tR[nr󳨀→
tR
(2)],
where 󳨀→
tR = 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
r WHERE C is the selection term as described in point 4 above;
3.
(Update). The existence of the rewriting of this operation is obvious from the fact
that it can always be decomposed as deletion and after that the insertion of the
tuples.
This proposition demonstrates that the IRDB is a SQL database, so that each user-
defined query over the used-defined RDB database schema 𝒜can be equivalently
transformed by query rewriting into a query over the vector relation rV. However, in
the IRDBMSs we can use more powerful and efficient algorithms in order to execute
each original user-defined query over the vector relation rV.
Notice that this proposition demonstrates that the IRDB is a kind of GAV Data In-
tegration System ℐ= (𝒜, 𝒮, ℳ) in Definition 44 where we do not materialize the user-
defined schema 𝒜but only the vector relation rV ∈𝒮and each original query q(x)
over the empty schema 𝒜will be rewritten into a vector query 󳨀󳨀󳨀→
q(x) of the type S over
the vector relation rV, and then the resulting view VIEW(S, ‖󳨀󳨀󳨀→
q(x)‖#) will be returned
to user’s software program.
For aggregate functions, SUM, MIN, MAX, COUNT and AVG, which are not affected
by null values in the column being aggregated, their definition over rV is combined by
a selection which specifies the relation-name and attribute-name for the column be-
ing aggregated. Thus, an IRDB is a member of the NewSQL, i. e., a member of a class
of modern relational database management systems that seek to provide the same
scalable performance of NoSQL systems for online transaction processing (read-write)
workloads while still maintaining the ACID guarantees of a traditional database sys-
tem.

200
|
4 Intensional RDB manifesto: flexible big data and NewSQL
4.2.3 Comparison with related work
The idea of having relational names as arguments goes back to [165] where the au-
thors describe an algebraic operator called SPECIFY that converts a single relation
name into its relation, but it is too far from our work by considering the Codd’s nor-
mal forms with their concept of “aggregation” and their concept of “generalization”
(as in Quillian’s semantic networks) and trying to mix both the database and AI areas.
The version of the relational model in which relation names may appear as ar-
guments of other relations is also provided in [166]. In such approach, an extension
of the relational calculus using HiLog as logical framework rather than FOL has been
proposed, and they call this extension “relational HiLog.” But this is an ad hoc second-
order logic where the variables may appear in predicate names, and where there is am-
biguity in programming semantics because there is no distinction between the vari-
ables, function, constant and predicate symbols. Thus, it seams syntactically to be a
FOL but it has the particular semantics of the second-order logic. In our approach, we
remain in the FOL syntax with only new terms for the intensional elements (n-ary con-
cepts) and with only simple intensional extension of the standard Tarski’s semantics
for the FOL. The extension of the relational algebra in [166] is very different from our
standard SQL algebra framework: instead of this standard relational SQL algebra, in
[166] are provided two relational algebra extensions:
1.
“E-relational algebra,” which extends standard relational algebra with a set of ex-
pansion operators (these operators expand a set of relation names into the union
of their relations, with the relational name as an extra argument, and hence not
to a key/value representations in big data used in our vector relation rV);
2.
The second is “T-relational algebra,” which extends e-relational algebra by a set of
“totality” operators (to allow the access to the names of all nonempty relations in
the relational database). Thus, from the algebraical, structural and logical frame-
work this approach is very different from our GAV Data integration model and a
minimal conservative intensional extension of the Tarski’s FOL semantics.
Another approach in which relation and attribute names may appear as arguments of
other relations are provided in the area of integration of heterogeneous databases. In
[167], a simple Prolog interpreter for a subset of F-logic was presented, but the nega-
tion in Prolog is not standard as in FOL, and such an approach is far from SQL models
of data and querying of RDB databases. Also in [168] is demonstrated the power of
using variables that uniformly range over data and metadata, for schema browsing
and interoperability, but their languages have a syntax closer to that of logic program-
ming languages, and far from that of SQL. The more powerful framework (where the
variables can range over the following five sets:
(i)
names of databases in a federation;
(ii) names of the relations in a database;
(iii) names of the attributes in the scheme of a relations;

4.2 Intensional RDB: data integration system with a vector source database
|
201
(iv) tuples in a given relation in a database;
(v) values appearing in a column corresponding to a given attribute in a relation) is
presented in SchemaSQL [169] where the SQL is extended in order to be able to
query metadata.
In our case, this is not necessary because we preserve the original RDB SQL in order
to be able to migrate from the RDB models into IRDB models with the big data vector
relation without unnecessarily complications. In fact, the extended relational algebra
in SchemaSQL would be a nondesirable complication in order to obtain the flexible
schema and big data RDB features. What is interesting work in this direction is to in-
vestigate the conservative intensional extension of Tarski’s FOL semantics used in our
approach also to the algebraic framework used in SchemaSQL.
One of the similar approaches to the flexible and sparsely populated schemas is
that of “Open Schema” EAV models, mentioned previously in Section 4.2. Such re-
quirements for the e-commerce applications have been presented in [170]. Such a spe-
cific e-commerce software has been adopted in the IBM Websphere Commerce Server
running on top of the DB2. But it needs ad hoc structures of the standard horizontal
table representations, where each such table must have a special key attribute for the
object identity. Thus, it cannot be applied to transform any RDB schema into vertical
table representation of the EAV type, composed by the three attributes: Oid (object
identifier), Key (attribute name) and Val (attribute value). They noted that the values
of the Key field in the vertical format become column names in the current database
systems (the metadata) and that such “higher-order views are not supported in the cur-
rent database systems” [170]. But they do not provide the logical framework for such
a new RDB model. They do not use the relation names as arguments of other relations
so their logical framework remains to be standard FOL.
Different from our approach, their approach loses data typing since all values
are stored as VARCHARs in the Val column (in our approach we store all values as
VARCHARs, however, we know its data type, which is saved in the users ER database
schema 𝒜, which is a necessary user-software interface in our data integration sys-
tem).
Their method is similar to that of the ShemaSQL, i. e., nonintrusive implemen-
tations without requiring changes of the database engine code and they extend the
relational algebra with two operations, v2h and h2V, that can be viewed as the spe-
cializations of unfold and fold in [169], respectively. They are analog to the opera-
tions MATTER(rk, _) and ⋃v∈‖_‖ PARSE( _, v), respectively. However, the difference is
not only in their syntactical and semantical compositions, but also in the fact that in
their framework v2h and h2V are new DDL instructions, which extend the standard
SQL RDB framework, while in our approach these operations are only internal func-
tionalities of IRDB and not a kind of DDL instructions, which can be used by program-
mers. Thus, in our more general framework we intentionally do not change the SQL

202
|
4 Intensional RDB manifesto: flexible big data and NewSQL
language (in order to migrate easily from RDBs to IRDBs, without any modification or
addition of new SQL instructions).
Their approach is not suitable for a general parsing of any horizontal database
representation into vertical representations. It is more restrictive and each horizontal
table representation must have a Oid column (it has to be the primary key of such a
table), which has to be also repeated in the vertical table representation as a part of
the primary key of this table.
Finally, we mention the work presented in [171], which introduces the PIVOT and
UNPIVOT operators on tabular data that exchange rows and columns, enabling data
transformations useful in data modeling and data presentation (e. g., Microsoft Excel
supports pivoting). These two operators can be used for the composition of our PARSE
and MATTER operators for a given user-defined table with a relational name rk and
number of columns n = ar(rk) ≥1, as follows (we are using the syntax introduced in
[171] (un)pivoting operators):
–
Parsing a relation rk. Let us define the following SQL terms:
t1 = EXTEND rk ADD atrrV (2), t-name AS Hash(S)
where atrrV (2) is the attribute for the column t-name in rV and S = (nrrk(1), . . . ,
nrrk(n)) is a list of column names (the variables) to be used by the Hash function
for each tuple v ∈‖rk‖;
t2 = t1 UNPIVOT value FOR a-name IN S;
t3 = (EXTEND t2 ADD atrrV (1), r-name AS rk)[r-name, t-name, a-name, value]
where atrrV (1) is the attribute for the column r-name in rV. Then the operation of
parsing of the relation rk into the vector table rV, ⋃v∈‖rk‖ PARSE (rk, v), is equal to
the relational algebra extended by the UNPIVOT operation,
INSERT INTO rV AS SELECT * FROM t3.
–
Materialization of a relation rk. The operation of materialization of the relation
‖rk‖, given in Definition 45 by MATTER (rk, ‖rV‖), can be expressed by the following
relational algebra (extended with the PIVOT operation) term:
(((rV WHERE r-name = rk)[t-name, a-name, value])
PIVOT (value FOR a-name IN S))[S].
–
Presentation of views. The operation of presentation of an user-defined view (SQL
term) tR of the type S = ⟨(rk1, namek1), . . . , (rkm, namekm)⟩, given in Definition 47 by
VIEW(S, ‖󳨀→
tR‖#), can be expressed the following relational algebra (extended with
the PIVOT operation) term:

4.2 Intensional RDB: data integration system with a vector source database
|
203
(󳨀→
tR PIVOT (nr󳨀→
tR
(4) FOR (nr󳨀→
tR
(1), nr󳨀→
tR
(3)) IN S)[S].
Different from [171], we did not use these operations as an extension of the SQL rela-
tional algebra, but only as an internal operation, which has to be implemented in the
IRDBMSs. The opportunity to extend the standard SQL with these two inverse oper-
ations can be considered in questions connected with optimization and execution of
certain user-defined query computations.
Note that PIVOT and UNPIVOT does not introduce the intensionality in the FOL
used for standard SQL semantics. While the PARSE operator introduce the intensional
elements(relational names) into the vector relation rV, and it is provided by the rela-
tional term t3 above, applied after the UNPIVOT operation in the term t2.
Another advantage of the parsing is that we can write the queries directly over the
vector relation rV, and hence the metadata are the “first-class” entities, so that in this
framework we are able to provide the queries that manipulate data as well as their
schema.
Note that the method of parsing is well suited for the migration from all existent
RDB applications where the data is stored in the relational tables, so that this solution
gives a possibility to pass easily from the actual RDBs into the new machine engines
for the IRDB. We preserve all metadata (RDB schema definitions) without modifica-
tion and only dematerialize its relational tables by transferring their stored data into
the vector relation rV (possibly in a number of disjoint partitions over a number of
nodes). From the fact that we are using the query rewriting IDBMS, the current user’s
(legacy) applications does not need any modification and they continue to “see” the
same user-defined RDB schema as before. Consequently, this IRDB solution is ade-
quate for a massive migration from the already obsolete and slow RDBMSs into a new
family of fast, NewSQL schema-flexible (with also ‘open schemas”) and big data scal-
able IRDBMSs.
4.2.4 Big data interoperability with IRDBs
The interoperability is the ability to share, interpret and manipulate the informa-
tion across the heterogeneous database systems supported by Multidatabase systems
(MDBS) in a distributed network by encompassing a heterogeneous mix of local
database systems. Languages based on higher-order logic have been used for the in-
teroperability by considering that the schematic information should be considered as
part of a database’s information content. The major advantage associated with such
approaches, used in SchemaLog [169, 172], is the declaratively they derive from their
logical foundation. The weak points of the SchemaLog is that it uses the second-order
logic syntax and an ad hoc Prolog-like fixed- point semantics. However, both of them
are not necessary, as we will show by using the IRDBs, just because the ordinary

204
|
4 Intensional RDB manifesto: flexible big data and NewSQL
RDBs have the FOL syntax and do not need fixed-point semantics but ordinary FOL
semantics.
However, before the presentation of the IRDB interoperability features, it is useful
to compare it in more detail with SchemaLog, and hence to provide the short intro-
duction of the syntax and semantics of SchemaLog in what follows. It will be useful
also to understand the objective difficulties for formalization of more sophisticated
database systems and to avoid in the same time the ad hoc languages and semantics,
as it is SchemaLog. With this in mind, readers will be able to appreciate the general in-
tensional extension of FOL, used in this book, with well-known FOL syntax but able,
with its intensional semantics, to satisfy the more complex requirements than what
the standard extensional FOL is able to provide.
The SchemaLog is syntactically higher-order clausal logic, and is based on the
technical benefits of soundness, completeness and compactness by a reduction to
first-order predicate calculus. It has a strictly higher expressive power than first-order
logic based on this syntax, different from IRDB, which has the standard FOL syntax
but with intensional semantics which is conservative w. r. t. the Tarski’s extensional
semantics.
The vocabulary of the SchemaLog language ℒS consists of the disjoint sets: 𝒢of
k-ary (k ≥1) functional symbols, 𝒮of nonfunctional symbols (language constants,
i. e., nullary functional symbols), 𝒱of variables and usual logical connectives ¬, ∨, ∧, ∃
and ∀.
Every symbol in 𝒮and 𝒱is a term of the language, i. e., 𝒮⋃𝒱⊆𝒯. If f ∈𝒢is a
n-ary function symbol and t1, . . . , tn are terms in 𝒯, then f (t1, . . . , tn) is a term in 𝒯.
An atomic formula of ℒS is an expression (note that it is not a predicate-based atom
of the FOL, i. e., in SchemaLog we do not use the predicate letters) of the following
forms [172]:
(i)
⟨db⟩:: ⟨rel⟩[⟨tid⟩: ⟨attr⟩→⟨val⟩];
(ii) ⟨db⟩:: ⟨rel⟩[⟨attr⟩];
(iii) ⟨db⟩:: ⟨rel⟩;
(iv) ⟨db⟩;
where ⟨db⟩(the database symbols or names), ⟨rel⟩(the relational symbols or names),
⟨attr⟩(the attribute symbols or names), ⟨tid⟩(the tuple ids) and ⟨val⟩are the sorts in
𝒮of ℒS.
The well-formed formulae (wff) of ℒS are defined as usual: every atom is a wff; ¬ϕ,
ϕ ∨ψ, ϕ ∧ψ, (∃x)ϕ and (∀x)ϕ are wffs of ℒS whenever ϕ and ψ are wffs and x ∈𝒱is a
variable.
A literal is an atom or the negation of an atom. A clause is a formula of the form
∀x1, . . . , ∀xm(L1∨. . .∨Ln) where each Li is a literal and x1, . . . , xm are the variables occur-
ring in L1 ∨. . . ∨Ln. A definite clause is a clause in which one positive literal is present
and represented as A ←B1, . . . , Bn where A is called the head and B1, . . . , Bn is called

4.2 Intensional RDB: data integration system with a vector source database
|
205
the body of the definite-clause. A unit clause is a clause of the form A ←, i. e., a definite
clause with an empty body.
Let 𝒟be a nonempty set of elements (called “intensions”). A semantic structure
[172] of the language ℒS is a tuple M = ⟨𝒟, ℐ, ℐfun, ℱ⟩where:
1.
ℐ: 𝒮→𝒟is a an interpretation of nonfunction symbols in 𝒮;
2.
ℐfun(f) : 𝒟n →𝒟is an interpretation of the functional symbol f ∈𝒢of arity n;
3.
ℱ: 𝒟󴁄󴀼[𝒟󴁄󴀼[𝒟󴁄󴀼[𝒟󴁄󴀼𝒟]]], where [A 󴁄󴀼B] denotes the set of all partial
functions from A to B.
To illustrate the role of ℱ, consider the atom d
::
r. For this atom to be true,
ℱ(ℐ(d))(ℐ(r)) should be defined in M. Similarly, for the atom d :: r[t : a →v] to be true,
ℱ(ℐ(d))(ℐ(r))(ℐ(a))(ℐ(t)) should be defined in M and ℱ(ℐ(d))(ℐ(r))(ℐ(a))(ℐ(t)) = ℐ(v).
A variable assignment g is a function g : 𝒱→𝒟(i. e., g ∈𝒟𝒱). We extend it to all
terms in 𝒯as follows:
g(s) = ℐ(s)
for every s ∈𝒮;
g(f(t1, . . . , tn)) = ℐfun(f)(g(t1), . . . , g(tn)) where f ∈𝒢is a functional symbol of arity n
and ti are terms.
For a given set of terms ti ∈𝒯, i = 1, 2, . . . and the formulae ϕ and ψ, we define the
satisfaction relation 󳀀󳨐g for a given assignment g and the structure M as follows:
1.
M 󳀀󳨐g t1 iff ℱ(g(t1)) is defined in M;
2.
M 󳀀󳨐g t1 :: t2 iff ℱ(g(t1))(g(t2)) is defined in M;
3.
M 󳀀󳨐g t1 :: t2[t3] iff ℱ(g(t1))(g(t2))(g(t3)) is defined in M;
4.
M 󳀀󳨐g t1 :: t2[t4 : t3 →t5] iff ℱ(g(t1))(g(t2))(g(t3))(g(t4)) is defined in M and
ℱ(g(t1))(g(t2))(g(t3))(g(t4)) = g(t5);
5.
M 󳀀󳨐g ϕ ∨ψ iff M 󳀀󳨐g ϕ or M 󳀀󳨐g ψ;
6.
M 󳀀󳨐g ¬ϕ iff not M 󳀀󳨐g ϕ;
7.
M 󳀀󳨐g (∃x)ϕ iff for some valuation g′, that may differ from g only on the variable x,
M 󳀀󳨐g′ ϕ.
The specification of an extension of a RDB in this logic framework can be done by
specification of the logic program with the (high) number of unit and definite ground
clauses (for each tuple in some relational table of such an RDB), which renders it
nonuseful for the big data applications, because such a logic program would be enor-
mous. Moreover, we do not need to use the fixed-point semantics of logic program-
ming for the definition of the extension of the RDBs instead of the standard Tarski’s
semantics of the FOL.
Thus, the SchemaLog framework, defined for the Multidatabase interoperability,
can not be used for the interoperability in big data applications, and hence we will
show that SchemaLog can be reduced to intensional RDB (IRDB), which is designed
for big data NewSQL applications.

206
|
4 Intensional RDB manifesto: flexible big data and NewSQL
The main work in this section is dedicated to the Multidatabase IRDBs and we
explain how a metadata interoperability SchemaLog framework is embedded into the
IRDBs big multidatabase systems.
From the introduction of SchemaLog, we can deduce that the definition of the
multidatabases has to be obtained mainly by the following unit clauses (the “facts” in
logic programming) of the following forms [172]:
(i)
(⟨db⟩:: ⟨rel⟩[⟨tid⟩: ⟨attr⟩→⟨val⟩]) ←;
(ii) (⟨db⟩:: ⟨rel⟩[⟨attr⟩]) ←;
(iii) (⟨db⟩:: ⟨rel⟩) ←;
(iv) ⟨db⟩←;
where the clause (i) correspond to the SQL-like operation of inserting the value ⟨val⟩
into the attribute ⟨attr⟩of the relation ⟨rel⟩of the database ⟨db⟩while other cases
correspond to the DDL-like operations of definitions of the attributes of the relations,
the relations of the databases and the databases. From the fact that we are interested
in the operations over the vector relations rV1, . . . , rVn, each one dedicated to a single
database of the given multidatabase system, the unit clause ⟨db⟩←corresponds to
the RDB DDL of the creation of the vector relation with the name rVi = ⟨db⟩with the
four fixed attributes r-name, t-index, a-name and value. We do not use the clauses (ii)
and (iii) for vector relations, and the only interesting clause is (i).
In fact, we can use only the clause (i), which corresponds to the SQL statement
“INSERT INTO rVi VALUES (⟨rel⟩, ⟨tid⟩, ⟨attr⟩, ⟨val⟩).”
However, here we can see why SchemaLog cannot be used for real Multidatabase sys-
tems. Because each insertion, deletion or update must be realized by the updating of
the whole Logic program PL, which defines the extension of the databases, and then
for such a modified program PL to compute its least fixed point. It is not only a hard
computational process (to rebuild the complete extension of all databases of a given
multidatabase system by the fixed-point semantics), but also very complicated task of
the concurrent updates of these databases by different users. This is the common prob-
lem and weak point for almost all AI logic-programming approaches to big databases,
and explains why they cannot replace the concurrent RDBMSs and why we intend to
translate the SchemaLog framework into the concurrent and big data IRDBMSs and
then to show that IRDBMs can support the interoperability for the multidatabase sys-
tems.
Remark. (*): We will consider only the meaningful cases of the SchemaLog used for
multidatabases, when each relation r of any database 𝒜is not empty and for each at-
tribute of such a relation there is at least one value different from NULL, i. e., when
every relation and its attributes are really used in such a database to contain the in-
formation.

4.2 Intensional RDB: data integration system with a vector source database
|
207
Implementation of SchemaLog interoperability by IRDB
Consequently, we consider the IRDB interoperability with a set of relational databases
SDB = {uDB1, . . . , uDBn}, for a given intensional interpretation (homomorphisms) I :
𝒜FOL →𝒜int in commutative diagram (4.4) in Section 4.2, where each
uDBi =def I(∃y2, y3, y4rVi(y1, y2, y3, y4)) = exists2,3,4(urVi ) ∈D1
(4.8)
for i = 1, . . . , n, is the intensional DB concept of the i-th RDB parsed into the vector
relation with the name rVi (with urVi = I(rVi(y1, . . . , y4)) ∈D4). So, the extension of the
intensional DB concept uDBi is, commutative diagram (4.4) in Section 4.2,
h(uDBi) = I∗
T (∃y2, y3, y4rVi(y1, y2, y3, y4)) = {nr(rij) | rij ∈𝒜i}
is just the set of relation names of the schema of i-th RDB 𝒜i.
Thus, in this interoperability framework, we will have n ≥1 tree-systems of con-
cepts with the top multidatabase intensional concept umdb = I(call1(x)) ∈D1 (where
call1 is the unary predicate letter introduced for this concept introduced for Schema-
Log reduction in [172]) such that h(umdb) = SDB is the set of database names in a given
tree-system of multidatabases, represented graphically in Figure 4.2.
Figure 4.2: Tree-system of multidatabases.
So, we can introduce the following intensional concepts (the terms intensional algebra
𝒜int of Definition 16 in Section 1.3, for the sorts of relations, tuples, attributes and
values):

208
|
4 Intensional RDB manifesto: flexible big data and NewSQL
1.
urel = disjS1(uDB1, disjS1(. . . , disjS1(uDBn−1, uDBn) . . .) ∈D1;
2.
utid = disjS2(exists1,3,4(urV1 ), disjS2(. . . , disjS2(exists1,3,4(urVn−1 ), exists1,3,4(urVn )) . . .) ∈
D1;
3.
uattr = disjS3(exists1,2,4(urV1 ), disjS3(. . . , disjS3(exists1,2,4(urVn−1 ), exists1,2,4(urVn )) . . .) ∈
D1;
4.
uval = disjS4(exists1,2,3(urV1 ), disjS4(. . . , disjS4(exists1,2,3(urVn−1 ), exists1,2,3(urVn )) . . .) ∈
D1;
where Si {(i, i)} for i = 1, 2, 3, 4. Notice that these intensional unary concepts above are
derived from the FOL formulae, as follows:
urel = I((∃x2, x3, x4)rV1(x1, x2, x3, x4) ∨(. . . ∨(∃x2, x3, x4)rVn(x1, x2, x3, x4) . . .));
utid = I((∃x1, x3, x4)rV1(x1, x2, x3, x4) ∨(. . . ∨(∃x1, x3, x4)rVn(x1, x2, x3, x4) . . .));
uattr = I((∃x1, x2, x4)rV1(x1, x2, x3, x4) ∨(. . . ∨(∃x1, x2, x4)rVn(x1, x2, x3, x4) . . .));
uval = I((∃x1, x2, x3)rV1(x1, x2, x3, x4) ∨(. . . ∨(∃x1, x2, x3)rVn(x1, x2, x3, x4) . . .));
Then, given a SchemaLog formula ϕ, its encoding in the intensional FOL of the IRDB is
determined by the recursive transformation rules given below. In this transformation,
s ∈S ⊆𝒯, f ∈𝒢, ti, trel, tattr, tid, tval ∈𝒯, tdb ∈{rV1, . . . , rVn} ⊂S ⊆𝒯, are the SchemaLog
terms, and ϕ, ψ are any formulae:
1.
encode(s) = s, encode(f) = f
2.
encode(f (t1, . . . , tm)) = encode(f)(encode(t1), . . . , encode(tm))
3.
encode(tdb :: trel[tid : tattr →tval]) == encode(tdb)(encode(trel), encode(tid),
encode(tattr), encode(tval))
4.
encode(tdb :: trel[tattr]) = (∃x2, x4) encode(tdb)(encode(trel), x2, encode(tattr), x4)
5.
encode(tdb :: trel) = (∃x2, x3, x4) encode(tdb)(encode(trel), x2, x3, x4)
6.
encode(tdb) = call1(tdb)
7.
encode(ϕ ⊙ψ) = encode(ϕ) ⊙encode(ψ), for ⊙∈{∧, ∨}
8.
encode(¬ϕ) = ¬ encode(ϕ)
9.
encode(→ϕ) = encode(ϕ)
10. encode(ψ →ϕ) = ¬ encode(ψ) ∨(encode(ψ) ∧encode(ϕ))
11. encode((Qx)ϕ) = (Qx) encode(ϕ), where Q ∈{∃, ∀}.
In the case of the intensional FOL defined in Definition 15 in Section 1.3, we obtain
the syntax of the standard FOL but with intensional semantics. Such a FOL has a well-
known Tarski’s interpretation I∗
T , defined in Chapter 1. Consequently, from the inten-
sional point of view, an interpretation of Tarski is a possible world in the Montague’s
intensional semantics, i. e., from Section 1.3, w = I∗
T ∈𝒲e, with the corresponding
extensionalization function h, such that I∗
T = h ∘I.

4.2 Intensional RDB: data integration system with a vector source database
|
209
Semantics
Given a SchemaLog structure M
= ⟨𝒟, ℐ, ℐfun, ℱ⟩, we construct a corresponding
Tarski’s interpretation IT = encode(M) on the domain 𝒟as follows:
IT(s) =def ℐ(s),
for each s ∈𝒮;
IT(fi(d1, . . . , dk)) =def ℐfun(fi)(d1, . . . , dk), for each k-ary functional symbol fi ∈𝒢and
d1, . . . , dk ∈𝒟;
Note that the Hash functional symbol has to be inserted into 𝒢, so that the
built-in function on strings ℐfun(Hash) satisfies the condition, for relation names
u = nr(rVi), u′ = nr(r) and ID, nrr(k), dk ∈𝒟, for k = 1, . . . , ar(r):
If (ℱ(u)(u′)(ID)(nrr(1)) = d1) ∧. . . ∧(ℱ(u)(u′)(ID)(nrr(ar(r))) = dar(r)),
then ID = ℐfun(Hash)(d1, . . . , dar(r)),
where some of values di can be equal to the value NULL ∈D−1 as well.
We recall that, for intensional FOL, each k-ary functional symbol fi is considered
as a (k + 1)-ary relational concept, so that I(fi) ∈Dk+1 with
IT(fi) = h(I(fi)) = {(d1, . . . , dk, ℐfun(fi)(d1, . . . , dk)) | d1, . . . , dk ∈𝒟}.
The unique relations that are materialized in IRDBs are the vector relations, and
hence we will consider only these relations rV1, . . . , rVn (corresponding to databases
𝒜1, . . . , 𝒜n of this multidatabase interoperability system), so that the Tarski’s interpre-
tation for them is constructed in the following way:
1.
For relation names u = nr(rVi), u′ = nr(r) and ID, a, d ∈𝒟, (u′, ID, a, d) ∈IT(rVi) iff
ℱ(u)(u′)(a)(ID) is defined in M and ℱ(u)(u′)(a)(ID) = d.
2.
For the unary predicate call1, such that from the Tarski’s constraints umdb =
I(call1(x)), we have that IT(call1) = h(I(call1(x))) = h(umdb) = SDB (the set of in-
tensional DB concepts (DB names) in the figure above). Then nr(rVi) ∈IT(call1) iff
ℱ(nr(rVi)) is defined in M.
Proposition 24. Let ϕ be a SchemaLog formula, M be a SchemaLog structure and g ∈
𝒟𝒱an assignment. Let encode(ϕ) be the first-order formula corresponding to ϕ and IT =
encode(M) the corresponding Tarski’s interpretation. Then, for a given assignmen g, we
denote by I∗
T 󳀀󳨐g ψ the fact that I∗
T (ψ/g) = t, and hence it holds that
M 󳀀󳨐g ϕ
iff
I∗
T 󳀀󳨐g encode(ϕ).
Proof. Let us show that it holds for all atoms of SchemaLog:
Case 1: When ϕ is equal to an atom (t1 :: t2[t4 : t3 →t5]), then

210
|
4 Intensional RDB manifesto: flexible big data and NewSQL
M 󳀀󳨐g (t1 :: t2[t4 : t3 →t5])
iff
ℱ(g(t1))(g(t2))(g(t3))(g(t4)) is in M and ℱ(g(t1))(g(t2))(g(t3))(g(t4)) = g(t5)
iff
⟨g(t2), g(t4), g(t3), g(t5)⟩∈IT(g(t2)) iff I∗
T 󳀀󳨐g (t1/g)(t2, t4, t3, t5)
iff
I∗
T 󳀀󳨐g (encode(t1)/g)(encode(t2), encode(t4), encode(t3), encode(t5))
iff
I∗
T 󳀀󳨐g encode(t1 :: t2[t4 : t2 →t5]).
Case 2: When ϕ is equal to an atom (t1 :: t2[t3]), then
M 󳀀󳨐g (t1 :: t2[t3])
iff
ℱ(g(t1))(g(t2))(g(t3))
is defined in M
iff
I∗
T 󳀀󳨐g (∃x2, x4)(t1/g)(t2, x2, t3, x4)
iff
I∗
T 󳀀󳨐g (∃x2, x4)(encode(t1)/g)(encode(t2), x2, encode(t3), x4)
iff
I∗
T 󳀀󳨐g encode(t1 :: t2[t3]).
Case 3: When ϕ is equal to an atom (t1 :: t2), then
M 󳀀󳨐g (t1 :: t2)
iff
ℱ(g(t1))(g(t2)) is defined in M
iff
I∗
T 󳀀󳨐g (∃x2, x3, x4)(t1/g)(t2, x2, x3, x4)
iff
I∗
T 󳀀󳨐g (∃x2, x3, x4)(encode(t1)/g)(encode(t2), x2, x3, x4)
iff
I∗
T 󳀀󳨐g encode(t1 :: t2).
Case 4: When ϕ is equal to an atom tdb, then
M 󳀀󳨐g tdb
iff
ℱ(g(tdb))
is defined in M
iff
g(tdb) ∈IT(call1) iff I∗
T 󳀀󳨐g call1(tdb) iff I∗
T 󳀀󳨐g encode(tdb).
Case 5: For the composed formulae, we can demonstrate by induction. Let us suppose
that this property holds for ϕ and for ψ. Then
M 󳀀󳨐g ϕ ∨ψ
iff
M 󳀀󳨐g ϕ or M 󳀀󳨐g ϕ
iff
I∗
T 󳀀󳨐g encode(ϕ) or I∗
T 󳀀󳨐g encode(ψ) iff I∗
T 󳀀󳨐g encode(ϕ ∨ψ),
and analogously for all other cases.
Note that w. r. t. the remark (*) above, the relations (predicates) call1, call2, call3
and call4 (obtained by a similar reduction of SchemaLog in FO logic programs in [172]),
can be defined by the vector relations in IRDBs as follows:
call4 = (EXTEND rV1 ADD a, db-name, rV1) UNION (. . . UNION(EXTEND rVn ADD
a, db-name, rVn) . . .),
where a is the attribute used for the database names;
call3 = call4[db-name, r-name, a-name];
call2 = call3[db-name, r-name];

4.2 Intensional RDB: data integration system with a vector source database
|
211
(note that we also have call1 = call2[db-name]), with h(urel) = ‖call4[r-name]‖#,
h(uattr) = ‖call4[a-name]‖#, and h(uval) = ‖call4[value]‖#.
Thus, based on [172], we obtain the result that technically SchemaLog has no more
expressive power than the intensional first-order logic used for IRDBs.
However, different from the SchemaLog that needs a particular extension ℰℛ𝒜of
the conventional (standard) relational algebra with the new operations, δ, ρ, α and γ
[172] (so that the resulting algebra is capable of accessing the database names, rela-
tional names and attribute names besides the values in a federation of database), here
we can use the conventional (standard) SQL over the vector relations rV1, . . . , rVn and
call1.
These new operators β, ρ, α are defined in IRDBs by the following SQL expressions:
δ() = ‖call1‖;
ρ(S) = call2 WHERE nrcall2(1) IN S, for each S ⊆‖call1‖#;
α(S) = call3 WHERE (nrcall2(1), nrcall2(2)) IN S, for each S ⊆‖call2‖#;
Only the operation γ is a more complex, defined in [172] as follows:
A pattern is a sequence (p1, . . . , pk), k ≥0, where each pi is one of the forms ‘ai →
di’, ‘ai →’, ‘→di’ and ‘→’. Here, ai is called the attribute component and di is called
the value component of pi. Let r be any relation, then
“ai →di” is satisfied by a tuple tid in relation r if tid[ai] = di;
‘ai →’
is satisfied by a tuple tid in relation r if ai is an attribute name in r;
“→di”
is satisfied by a tuple tid in relation r if there exists an attribute ai in the
scheme of r such that t[ai] = di;
‘→’
is trivially satisfied by every tuple tid in relation r.
A pattern (p1, . . . , pk) is satisfied by a tuple tid in relation r if every pi, i = 1, . . . , k, is
satisfied by tid.
Operator γ takes a binary relation S as input, and a pattern as a parameter and
returns a relation that consists of tuples corresponding to those parts of the database
where the queried pattern is satisfied. That is, let S be a binary relation and (p1, . . . , pk)
be a pattern, then [172],
γ(p1,...,pk)(S) =def {db, r, a1, d1, . . . , ak, dk|⟨db, r⟩∈S
and db is a database in the federation, and r is a relation in db, and ai’s are attributes
in r, and there exists a tuple tid in r such that tid[a1] = d1, . . . , tid[ak] = dk, and tid
satisfies (p1, . . . , pk)}.
Note that when the pattern is empty (k = 0), γ()(S) would return the set of all pairs
⟨db, r⟩∈S such that r is a nonempty relation in the database db in the federation.

212
|
4 Intensional RDB manifesto: flexible big data and NewSQL
Theorem 5. All new relational operators introduced in SchemaLog extended relational
algebra ℰℛ𝒜can be equivalently expressed by standard SQL terms in IRDBs.
Proof. The call1 and call2 are SQL terms (over the vector relations rVi of the federated
databases) defined previously, so that the definition of the SchemaLog operators δ, ρ
and α, given above, are the standard SQL terms as well. It is enough to demonstrate
that each γ(p1,...,pk) operator defined above, can be equivalently represented by a stan-
dard SQL term in the IRDBs as follows:
(i)
Case when k = 0. Then γ()(S) = ρ(S) (because from Remark (*) we are dealing with
the databases with all nonempty relations);
(ii) Case when k = 1. Then for the SQL term t = call4
γ(p1)(S) = (t WHERE Cp1)[db-name, r-name, a-name, value],
where the condition Cp1 is defined by (here ⊤is a tautology):
Cp1 =
{
{
{
{
{
{
{
{
{
(nrt(4) = ai) ∧(nrt(5) = di),
if p1 = ‘ai →di’
nrt(4) = ai,
if p1 = ‘ai →’
nrt(5) = di,
if p1 = ‘ →di’
⊤,
otherwise
(iii) Case when k ≥2. So, for the SQL Cartesian product
t =
k
⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞
call4 ⨂⋅⋅⋅⨂call4,
γ(p1,...,pk)(S) = (t WHERE (nrt(1) = . . . = nrt(5k −4))
∧(nrt(2) = . . . = nrt(5k −3)) ∧(nrt(3) = . . . = nrt(5k −2))
∧(Cp1 ∧. . . ∧Cpk))[nrt(1), nrt(2), nrt(4), nrt(5), nrt(9), nrt(10), . . . ,
nrt(5k −1), nrt(5k)],
where the conditions Cpm, for m = 1, . . . , k, are defined by
Cpm =
{
{
{
{
{
{
{
{
{
(nrt(5m −1) = ai) ∧(nrt(5m) = di)
if pm = ‘ai →di’
nrt(5m −1) = ai
if pm = ‘ai →’
nrt(5m) = di
if pm = ‘ →di’
⊤
otherwise
Example 22. Let us consider the multidatabase (federated) system given in Exam-
ple 2.1 in [172], consisting of RDBase univ_A, univ_B and univ_C corresponding to uni-
versities A, B and C. Each database maintains information on the university’s depart-
ments, staff and the average salary in 1997, as follows:
1.
The RDB univ_A has the following single relation pay-info, which has one tuple
for each department and each category in that department:

4.2 Intensional RDB: data integration system with a vector source database
|
213
‖pay-info‖ =
category
dept
avg-sal
Prof
CS
70,000
Assoc. Prof
CS
60,000
Secretary
CS
35,000
Prof
Math
65,000
2.
The RDB univ_B has the single relation, (also pay-info), but in this case, depart-
ment names appear as attribute names and the values corresponding to them are
the average salaries:
‖pay-info‖ =
category
CS
Math
Prof
80,000
65,000
Assoc. Prof
65,000
55,000
Assist. Prof
45,000
42,000
3.
The RDB univ_C has as many relations as there are departments, and has tuples
corresponding to each category and its average salary in each of the detpi rela-
tions:
‖CS‖ =
category
avg-sal
Prof
65,000
Assist. Prof
40,000
‖ece‖ =
category
avg-sal
Secretary
30,000
Prof
70,000
By parsing of these three RDBs, we obtain the three vector relations rV1 with the
name nr(rV1) = univ_A, rV2 with the name nr(rV2) = univ_B and rV3 with the name
nr(rV3) = univ_C. Let us consider the tuple ID1 = Hash(Secretary CS 35,000) of
the database univ_A, so that
‖rV1‖ ⊃
r-name
t-index
a-name
value
pay-info
ID1
category
Secretary
pay-info
ID1
dept
CS
pay-info
ID1
avg-sal
35,000
,
and consider the tuple ID2 = Hash(Secretary 30,000) of the relation ece of the
database univ_C, so that
‖rV3‖ ⊃
r-name
t-index
a-name
value
ece
ID2
category
Secretary
ece
ID2
avg-sal
30,000
so that the following set of tuples are the part of the relation obtained from the
SQL algebraic term call4:

214
|
4 Intensional RDB manifesto: flexible big data and NewSQL
‖call4‖# ⊃
db-name
r-name
t-index
a-name
value
univ_A
pay-info
ID1
category
Secretary
univ_A
pay-info
ID1
dept
CS
univ_A
pay-info
ID1
avg-sal
35,000
univ_C
ece
ID2
category
Secretary
univ_C
ece
ID2
avg-sal
30,000
,
Then the operation γ(→Secretary,→)(S) against the university databases above is
equivalent to the SQL term (for t = call4 ⨂call4)
(t WHERE (nrt(1) = nrt(6)) ∧(nrt(2) = nrt(7)) ∧(nrt(3) = nrt(7))
∧(nrt(5) = Secretary))[nrt(1), nrt(2), nrt(4), nrt(5), nrt(9), nrt(10)],
will yield for
S =
univ_A
pay-info
univ_B
pay-info
univ_C
CS
univ_C
ece
= ‖call2‖# = ‖call4[db-name, r-name]‖#
the relation
univ_A
pay-info
category
Secretary
dept
CS
univ_A
pay-info
category
Secretary
category
Secretary
univ_A
pay-info
category
Secretary
avg-sal
35,000
univ_C
ece
category
Secretary
category
Secretary
univ_C
ece
category
Secretary
avg-sal
30,000
Thus, we obtain he following completeness result for the SQL in the IRDBs w. r. t.
the querying fragment (ℒQ) of SchemaLog (provided in Definition 6.6 in [172]).
Corollary 13. Let 𝒟ℬbe a relational multidatabase system with nonempty relations and
attributes (in Remark (*)), 𝒫be a set of safe rules in the querying fragment ℒQ of the
SchemaLog and p any (virtual) predicate defined by 𝒫.
Then there exists a standard SQL expression t such that the computed relation ‖t‖#
in the IRDB obtained by parsing of this multidatabase system is equal to the relation
corresponding to p computed by SchemaLog.
Proof. From Lemma 6.1 in [172] for such a query p ∈ℒQ, there is an expression E of the
extended relational algebra ℰℛ𝒜, such that the relation corresponding to p is equal to
the relation obtained by computing the relational expression E. From Theorem 5, we
are able to translate this expression E ∈ℰℛ𝒜into an equivalent standard SQL term t
whose extension ‖t‖# in the IRDB obtained by parsing of this multidatabase system is
equal to the relation corresponding to p computed by SchemaLog.

4.2 Intensional RDB: data integration system with a vector source database
|
215
Consequently, any querying of data and metadata information (of nonempty rela-
tions and nonempty attributes, as explained in Remark (*)) of the federated relational
database system 𝒟ℬprovided by the interoperability framework of the SchemaLog
can be done in the IRDBs framework by the standard SQL.
Remark. If we need to use the interoperability framework also for the empty database
schemas or empty relations, in that case we need to create the relation table call3 not
by deriving it as a particular projections from call4 (SQL term) but directly from the
RDB dictionary of the multidatabase system.
Consequently, by permitting the SQL querying over the vector relations in the
IRBDs we can obtain the answers (see [172] for more useful cases), e. g.:
(Q4) “Find the names of all the relations in which the token ‘John’ appears”;
(Q5) “Given two relations r and s (in database db), whose schemas are unknown, com-
pute their natural join”;
etc.
The method of parsing of a relational instance-database A with the user-defined
schema 𝒜into a vector relation ⃗A = ‖rV‖, used in order to represent the information
in a standard and simple key/value form, today in various applications of big data,
introduces the intensional concepts for the user-defined relations of the schema 𝒜.
Moreover, we can consider the vector relations as the concept of mediator, proposed
by Wiederhold [173], as a means for integrating data from also nonrelational hetero-
geneous sources.
The expressive power of IRDB, which includes the expressive power of SchemaLog
and its ability to resolve data/metadata conflicts suggests that it has the potential for
being used in the interoperability frameworks for the multidatabase systems and as a
platform for developing mediators. This new family of IRDBs extends the traditional
RDBS with new features. However, it is compatible in the way of how to present the
data by user-defined database schemas (as in RDBs) and with SQL for management of
such a relational data.
The structure of RDB is parsed into a vector key/value relation so that we obtain
a column representation of data used in big data applications, covering the key/value
and column-based big data applications as well, into a unifying RDB framework. The
standard SQL syntax of IRDB makes it possible to express powerful queries and pro-
grams in the context of component database interoperability. We are able to treat the
data in the database, the schema of the individual databases in a multidatabase (a
federation) system, as well as the databases and relations themselves as first class
citizens, without using a higher-order syntax or semantics.

216
|
4 Intensional RDB manifesto: flexible big data and NewSQL
4.3 Enrichment of IRDB by multivalued attributes
MultiValue databases include commercial products from Rocket Software, TigerLogic,
jBASE, Revelation, Ladybridge, InterSystems, Northgate Information Solutions and
other companies. These databases differ from a relational database in that they have
features that support and encourage the use of attributes, which can take a list of val-
ues, rather than all attributes being single-valued. They are often categorized with
MUMPS within the category of post-relational databases, although the data model ac-
tually predates the relational model. In spite of a history of more than 40 years of
implementations, starting with TRW, many in the MultiValue industry have remained
current so that various MultiValue implementations now employ object-oriented ver-
sions of Data BASIC, support AJAX frameworks, and because no one needs to use SQL
(but some can) they fit under the NoSQL umbrella. In fact, MultiValue developers were
the first to acquire noSQL domain names, likely prior to other database products clas-
sifying their offerings as NoSQL as well. MultiValue is a seasoned data model, but with
so many vendors competing in this space, it has been constantly enhanced over the
years.
On the other side, the standard RDBs can only simulate the multivalued attributes,
by introducing the new relational tables for the values of these attributes, and cannot
use them directly as the multivalued attributes of the tables because in this case we
would need to pass from the FOL to the second-order logic. Consequently, in order to
pass from NoSQL multivalue databases to NewSQL relational multivalue databases we
need to semantically enrich the standard RDBs.
The first step to maintain the logical declarative (nonprocedural) SQL query lan-
guage level, is done by a revision of traditional RDBMSs: it was provided by developing
H-store (M. I. T., Brown and Yale University), a next generation OLTP systems that op-
erates on distributed clusters of shared-nothing machines where the data resides en-
tirely in the main memory, so that it was shown to significantly outperform (83 times)
a traditional, disc-based DBMS. A more full-featured version of the system [160] that
is able to execute across multiple machines within a local area cluster has been pre-
sented in August 2008. The data storage in the H-store is managed by a single-thread
execution engine that resides underneath the transaction manager. Each individual
site executes an autonomous instance of the storage engine with a fixed amount of
memory allocated from its host machine. The commercial version of H-store’s design
is VoltDB.
The parallel DBMSs offer great scalability over the range of nodes that customers
desire, where all parallel DBMSs operate (pipelining) by creating a query plan that
is distributed to the appropriate nodes at execution time. When one operator in this
plan sends data to next (running on the same or a different node), the data are pushed
by the first to the second operator (this concept is analog to the process described in
my book [21] dedicated to normalization of SQL terms (completeness of the action-
relational-algebra category RA)), so that (different from MR), the intermediate data is

4.3 Enrichment of IRDB by multivalued attributes
|
217
never written to disk. The formal theoretical framework (the database category DB) of
the parallel DBMSs and the semantics of database mappingsbetweenthemis provided
in big data integration theory as well [21]. It is interesting that in [162], the authors
conclude that parallel DBMSs excel at efficient querying of large data sets while MR
key/value style systems excel at complex analytics and ETL tasks, and propose:
“The result is a much more efficient overall system than if one tries to do the entire application in
either system. That is, “smart software” is always a good idea.”
In this section, we present a conceptually new version with multivalued attributes of
a family of Intensional RDBs (IRDBs). However, different from the basic version de-
scribed in previous sections, which are fully compatible with the standard RDBs, this
is a more powerful new conceptual RDB model, which does not support the first nor-
mal form in Codd’s requirements for RDBs, and hence permits the relaxation of the
atomicity requirement for data. Here, we do not use the intensional semantics only
for big data and to manage the queries with both data and metadata, but we are using
the full power of the intensional FOL in order to support the new intensional concepts
in these IRDBs able to store the multivalued attributes.
In order to preserve the standard table-based representation of query results, the
multivalued attributes in the tuples of this representation do not show any value but
a functional link, and hence, by activating it as the powerset function, we can obtain
the corresponding set of stored values. Moreover, these functional links in the tuples
(which are intensional concepts) can be used for the joins as well, because each of
them represents a set of values, and two links with the same set of values are inten-
sionally equal, and hence can be used in the joins as the standard atomic values.
We define a new query rewriting algorithm taking in consideration the multival-
ued attributes, based again on the GAV integration, so that each user-defined SQL
query is rewritten into a SQL query over the vector relation of the IRDB and an auxil-
iary binary relation used to store all sets of values for the multivalued attributes. Thus,
as in the basic case of IRDBs, the user-defined RDB schema is an empty global schema
used only for the RDB modeling and as the standard SQL interface. However, we will
also mention different SQL’s enrichments in order to manage more efficiently the mul-
tivalued attributes.
4.3.1 Canonical models for IRDBs with multivalued attributes
Let us show why we are not able to implement directly the multivalued attributes in
standard RDBs (without chaining the database’s schema by introducing the side ef-
fects with new relations in the schema used to store the set of values of the introduced
“multivalued attributes”), and why it is possible to do in IRDBs without any kind of
side effects, obtaining the full joins capability over the multivalued attributes as well.

218
|
4 Intensional RDB manifesto: flexible big data and NewSQL
Figure 4.3: Example for multivalued attributes.
Let us consider the following simple example with three relations:
1.
ZipLocations(zipCode, city, state), with primary key (PK) zipCode,
2.
Contacts(contactID, firstName, lastName, street, zipCode),withPKcorrespond-
ing to contactID, and foreign key (FK) to zipCode, and
3.
PhoneNumbers(contactID, phoneType, number), with FK contactID, such that for
each contact we can store the name and forename of the contacted person, his
address and phone numbers.
Suppose that we want to know what hobbies each person on our contact list is
interested in. Introduction of such a multivalued attribute in RDB can be only done
indirectly by introducing a new relation
4.
Hobbies(contactID, hobby), with FK contactID, and hence we obtained the
schema presented graphically.
We might add an attribute hobbies to relation Contacts to hold these. More likely,
someone added this attribute without thinking about it, obtaining the modified rela-
tion
Contacts(contactID, firstName, lastName, street, zipCode, hobbies),
but from the fact that the attribute hobbies must contain a set of values, in FOL it
corresponds to a unary predicate hobies(x), so that this modified relation would
have the following second-order formulation, Contacts(x1, x2, x3, x4, x5, hobbies(x));
consequently, this is the reason why we cannot implement directly the multivalued
attributes in standard RDBs.
However, in intensional FOL, this relation can be provided by the following
FOL atom, by using the intensional abstraction in order to substitute the predicate
hobbies(x) by the abstracted term, so that for a given intensional interpretation I (and

4.3 Enrichment of IRDB by multivalued attributes
|
219
corresponding assignment g). In intensional FOL, as explained in detail in Example 5
in Section 1.3.1 dedicated to formal semantics of abstracted terms applied just to this
case, we introduced a binary atom p2
i (x1, y) with name of this binary predicate letter
nr(p2
i ) = hobbies, where x1 is used for the KEY attribute ContactID of relation Contacts
and y used for the hobbies, and an atom for contacts p6
j (x1, x2, x3, x4, x5, ⋖p2
i (x1, y)⋗βiαi)
in (1.25) with nr(p6
j ) = Contacts. However, here instead of the formal predicate sym-
bols of intensional FOL, we will use directly their names, in order to render more easy
the presentation, so that these two intensional concepts are presented as follows for
a given assignment g ∈𝒟𝒱:
Contacts(x1, x2, x3, x4, x5, ⋖hobbies(x1, y)⋗x1
y )/g
= Contacts(132, Zoran, Majkic, Appia, 0187, u),
where from (1.22),
u = g∗(⋖hobbies(x1, y)⋗x1
y ) = I(hobbies(132, y)) ∈D1
(4.9)
is unary intensional concept (property) for the value g(x1) = 132 of the attribute
contactID. So, for example, in what follows, for this concept u we can generate auto-
matically from the name of this relation and this value as the name u
=
hobbies_of_132. If the set of hobbies of this contact 132 is S = {photography, travel,
art, music}, it must be equal to the extension of this unary concept, i. e.,
h(I(⋖hobbies(132, y)⋗y)) = h(u) = S.
The function list(S) is used to obtain a unique ordered list from a given set of strings
in S (e. g., by alphabetical ordering), so that we obtain the list list(S) = (art, music,
photography, travel).
Consequently, in order to save the extensions of the intensional concepts associ-
ated to each multivalued-attribute value (e. g., for the value u ∈D1 of a multivalued
attribute hobbies of the relation Contacts), we define the new relation
rMA(value, atom-value)
(4.10)
with FK value and PK is composed by both attributes value and atom-value. Thus, in
this example, we have that the set of tuples
{(u, photography), (u, travel), (u, art), (u, music)} ⊆‖rMA‖ = IT(rMA)
will be inserted in the table with name nr(rMA).
The application of the intensional FOL semantics to the data integration system
ℐ= (𝒜, 𝒮, ℳ) in Definition 44 with the user defined RDB schema 𝒜= (SA, ΣA) and the
vector big table rV is summarized in Section 4.2.1.

220
|
4 Intensional RDB manifesto: flexible big data and NewSQL
Figure 4.4: Hierarchy of concepts for IRDB with multivalued attributes.
Based on the intensional interpretation above, we are able to represent any instance
user-defined database A as an intensional hierarchy system of concepts, presented
in Fig. 4.4, which has one more level (last of this tree structure, for the multivalued
attribute’s values) than that in Section, where:
For each tuple of data di = (di1, . . . , dim), 1 ≤i ≤N, of the relation rk, we have that
h(I(rV(nr(rk), Hash(di), nrrk(j), dij))) = t, for dij (different from NULL), j = 1, . . . , m =
ar(rk). If, in this example, we consider that j-th column of relation rk is a multivalued
attribute, so that for dij ∈D1 (equal to the name of an unary concept (property) derived
from the multivalued attribute with name nrrk(j)), its extension h(dij) = {b1, . . . , bn} is
the set of values for this multivalued attribute linked to the tuple di of the relation
nr(rk). Note that the bottom level of the information hierarchy is stored in the rMA table
for all multivalued attributes of the instance database A.
The intensional data integration system ℐ= (𝒜, 𝒮, ℳ), in Definition 44 of Sec-
tion 4.2, is used in the way that the global schema is the only virtual (empty) database
with a user-defined schema 𝒜= (SA, SigmaA) used to define the SQL user-defined
query, which then has to be equivalently rewritten over the vector relation rV in order
to obtain the answer to this query. Thus, the information of the database is stored only
in the big table ‖rV‖. Thus, the materialization of the original user-defined schema 𝒜
can be obtained by the operation MATTER of Definition 45 in Section 4.2.
The canonical models of the intensional data integration system ℐ= (𝒜, 𝒮, ℳ) in
Definition 44 in Section 4.2 are the instances A of the schema 𝒜such that
‖rk‖ = MATTER(rk, ⋃
v∈‖rk‖
PARSE(rk, v)),
i. e., when

4.3 Enrichment of IRDB by multivalued attributes
|
221
A = {MATTER(rk, ⃗A) | rk ∈SA}.
Remark. Both operations, PARSE and MATTER, are equal to that of the IRDBs with-
out multivalued attributes (provided in Section 4.2). Thus, also the data integration
system holds the same. The only difference is that in the multivalued attribute version
of the IRDBs we have another relation rMA where all (and only) values of multival-
ued attributes of a given IRDB instance A are stored. Thus, if we will use the standard
RDB solution, where the instance database A is materialized, we will add to it also
the relational table rMA, and in order to select the values of a multivalued attribute
in A we would need to use a join with the first attribute value of rMA, in order to
pickup the atomic values of this multivalued attribute stored in the second attribute
atom-value. With such a join, for the tuple di = ⟨132, Zoran, Majkic, Appia, 0187, u⟩
of the table Contacts (presented previously), we would obtain the following set of
tuples (in our example we proposed for unary concept u to be the following name
u = hobbies_of_132):
con.ID
firstName
lastName
street
zipCode
hobbies
atom-value
132
Zoran
Majkic
Appia
0187
u
photography
132
Zoran
Majkic
Appia
0187
u
music
132
Zoran
Majkic
Appia
0187
u
art
132
Zoran
Majkic
Appia
0187
u
travel
But it has some disadvantages: we do not support directly the multivalued attributes,
so we have to repeat the same tuple for each different value of a multivalued attribute,
which is an explosive effect when we have more than one multivalued attribute in the
relations (for each combination of the values of these multivalued attributes we have
to repeat the same tuple). In what follows, we will provide a different “functional”
solution in order to avoid such an explosive repetition of the equal tuples.
The canonical models of such intensional data integration system ℐ= ⟨𝒜, 𝒮, ℳ⟩
can be provided in a usual logical framework as in Section 4.2, but for the multivalued
attribute features we need the following extension for the introduced relation rMA:
–
We introduce the multivalued attribute specification “a MULTIVALUED” (like
“a NOT NULL”) for an attribute a of a given relation.
Consequently, the canonical models of the IRDB with multivalued attributes are given
by the following.
Proposition 25. Let the IRDB be given by a data integration system ℐ= ⟨𝒜, 𝒮, ℳ⟩for
a used-defined global schema 𝒜= (SA, ΣA) with SA = {r1, . . . , rn} and auxiliary relation
rMA, the source schema 𝒮= ({rV}, 0) with the vector big data relation rV and the set of
mapping tgds ℳfrom the source schema into the relations of the global schema.

222
|
4 Intensional RDB manifesto: flexible big data and NewSQL
Then a canonical model of ℐis any model of the schema 𝒜+ = (SA ⋃{rV, rMA}, ΣA ⋃
ℳ⋃ℳOP ⋃{ρV}), where ℳOP is an opposite mapping tgds from 𝒜into rV given by the
following set of tgds:
ℳOP = {∀x1, . . . , xar(rk)((rk(x1, . . . , xar(rk)) ∧xi NOT NULL)
⇒rV(nr(rk), Hash(x1, . . . , xar(rk)), nrrk(i), xi)) | 1 ≤i ≤ar(rk), rk ∈SA},
and the new mapping ρV is equal to
∀x1, . . . , ∀x4∃y((rV(x1, x2, x3, x4) ∧x3 MULTIVALUED) ⇒rMA(x4, y))
Proof. For all relations of the schema 𝒜, the proof is equal to the case of non-
multivalued-attributes IRDB version provided in Proposition 22 in Section 4.2. It is
easy to verify that the canonical model of the auxiliary relation rMA is well-defined: in
fact, the mapping ρV guarantees that each nonempty multivalued attribute in RDB 𝒜
has the corresponding set of values in rMA.
Note that the auxiliary relation rMA for the values of the multivalued attributes is
a part of the global schema in the data integration system ℐand we have the mapping
ρV from the source schema into it. This auxiliary relation is necessary also in the case
when we decide to materialize the schema 𝒜, because it is a unique table where the
values are stored and contained in the multivalued attributes of schema 𝒜.
The fact that we assumed rV and rMA to be only the particulars (extensional en-
tities) is based on the fact that they always will be materialized (thus nonempty rela-
tional tables) as standard tables of the RDB 𝒜.
4.3.2 NewSQL property of the IRDBs with multivalued attributes
This last subsection will be dedicated to demonstrate that the IRDBs are complete
w. r. t. the standard SQL and to introduce the INSERT/DELETE operations for the tuples
with the multivalued attributes. As in the case of IRDB without multivalued attributed,
presented in Section 4.2.2, a user query is defined over the intensional concepts in 𝒜
(which will remain empty tables, i. e., nonmaterialized). Hence, we need to demon-
strate the existence of an effective query rewriting into an equivalent SQL query over
the (nonintensional concept) vector big table rV and auxiliary table rMA where the sets
of values of the multivalued attributes are stored. In order to define this query rewrit-
ing, we will shortly introduce the abstract syntax and semantics of Codd’s relational
algebra, as follows.
We recall that for any k-ary relational table r, with k = ar(r), with the injective
function nrr : {1, . . . , k} →SN, which assigns distinct names to each column of this re-
lation r, we denote its tuple of attributes atr(r) = a = (a1, . . . , ak) = (atrr(1), . . . , atrr(k)),
and the set of attributes denoted by a = atr(r). We recall that two relations r1 and r2 are

4.3 Enrichment of IRDB by multivalued attributes
|
223
union compatible iff atr(r1) = atr(r2). Given any two lists (tuples), d = ⟨d1, . . . , dk⟩and
b = ⟨b1, . . . , bm⟩, their concatenation ⟨d1, . . . , dk, b1, . . . , bm⟩is denoted by d&b, where
‘&’ is the symbol for concatenation of the lists. By ‖r‖, we denote the extension of a
given relation (relational symbol) r; it is extended to any term tR of Codd’s algebra, so
that ‖tR‖ is the relation obtained by computation of this term.
Five primitive operators of Codd’s algebra are: the selection, the projection, the
Cartesian product (also called the cross-product or cross-join), the set union and the
set difference. Another operator, rename, was not noted by Codd, but the need for it
is shown by the inventors of the Information Systems Base Language (ISBL) for one
of the earliest database management systems, which implemented Codd’s relational
model of data. They are provided in Section 4.2.2. Natural join ⋈S is a binary operator,
written as (r1 ⋈S r2), where r1 and r2 are the relations.
Remark. The multivalued attribute version of IRDBs SQL operations above differs
from the ordinary version without multivariable attributes only in the case of se-
lection operation “_WHERE C,” which uses also the multivalued attributes in the
condition C. In fact, for such attributes the values are not in the tuples of the original
relations, but in the auxiliary relation rMA.
Update operators for multivalued attribute version of IRDB
–
We define a unary operator “EXTEND_ADD a, name AS e.” for an added attribute
at the end of relation a ∈att, its name and expression e (in the most simple cases
it can be the value NULL or a constant d, or the i-th column name nr(i) of the argu-
ment (i. e., relation) of this operation), as a function with a set of column names,
such that for a relation r1 and expression e composed of the names of the columns
of r1 with n = ar(r1), we obtain the (ar(r1) + 1)-ary relation r by ⟨a, name, e⟩(r1),
with naming function nrr : {ar(r1) + 1} →SN such that nrr(i) = nrr1(i) if i ≤ar(r1);
nrr(ar(r1) + 1) = name otherwise, being a fresh new name for this column; with
the attribute function atrr : {ar(r1) + 1} →att such that atrr(i) = atrr1(i) if i ≤ar(r1);
atrr(ar(r1) + 1) = a otherwise, and
‖r‖ = {⟨⟩} ⋃{d&e(d) | d ∈‖r1‖},
where e(d) ∈dom(a) is a constant or the value obtained from the function e where
each name nrr(i) is substituted by the value di of the tuple d = ⟨d1, . . . , dn⟩∈‖r1‖;
in the special cases, we can use nullary functions (constants) for the expression e
(e. g., for the NULL value). Note that r is empty if e is an expression and r1 empty
as well.
Multivalued constraint: the multivalued attributes cannot be used in the expres-
sion e; if a is a multivalued attribute, then e must be equal to NULL.

224
|
4 Intensional RDB manifesto: flexible big data and NewSQL
We are able to define a new relation with a single tuple (d1, . . . , dk), k ≥1 with the
given list of attributes (a1, . . . , ak), by using the “EXTEND” operation as explained in
Section 4.2.2. The three update operators, “UPDATE,” “DELETE” and “INSERT” of the
relational algebra, are derived operators as explained in Section 4.2.2, with a multival-
ued attribute version of UPDATE as a combination of DELETE and INSERT operations,
and:
1.
Each algebraic expression (a term) “INSERT INTO r[S] VALUES (list of values),”
“INSERT INTO r[S] AS SELECT…,” is equivalent to “r UNION r1” where the union
compatible relation r1 is a one-tuple relation (defined by list) in the first, or a re-
lation defined by “SELECT…” in the second case.
Multivalued extension: In the case of a single tuple insertion (version with “VAL-
UES”) into a given relation r with multivalued attributes, for each multivalued
attribute instead of simple value has to be inserted empty set 0 or a nonempty set
of values {b1, . . . , bn}.
For example, the insertion of the contact 132 in the table Contacts used in the previous
section has to be done by the operation
INSERT INTO Contacts[contactID, firstName, lastName, street,
zipCode, hobbies] VALUES (132, Zoran, Majkic, Appia, 0187,
{photography, travel, art, music}).
This operation inserts the tuple ⟨132, Zoran, Majkic, Appia, 0187, u⟩in table Contacts
(where u, given by (4.9) is a unary concept, e. g., defined by name “hobbies_of_132”),
and the set of tuples S = {⟨u, photograpy⟩, ⟨u, travel⟩, ⟨u, art⟩, ⟨u, music⟩} in rMA.
Each algebraic expression “UPDATE r SET [nrr(i1)
=
ei1, . . . , nrr(ik)
=
eik]
WHERE C,” for n = ar(r), where eim, 1 ≤im ≤n for 1 ≤m ≤k are the expressions
and C is a condition, we will consider in the multivalued attribute version as a combi-
nation of DELETE and INSERT operations.
Remark. After a number of delete operations, we can obtain the situation where we
have the stored lists of values for the multivalued attributes, which are not used more,
so periodically we can delete them from rMA by, e. g., the following operation:
DELETE FROM rMA WHERE value NOT IN
((rV WHERE a-name MULTIVALUED)[value])
Notice that we are able to introduce also the new update operations, optimized to
change only the lists of values of the multivalued attributes (e. g., the deleting of one
value or inserting a new value in a list of values of a given multivalued attribute of
some tuple of relational tables with the multivalued attributes).

4.3 Enrichment of IRDB by multivalued attributes
|
225
We recall that the ΣR-algebra of the set of operations, introduced previously, with
its terms tR, which will be used in what follows, is introduced by Definition 46 in Sec-
tion 4.2.2.
Notice that the syntax and semantics of the relational algebra for IRDB with the
multivalued attributes is the same as in the case of IRDB without the multivalued at-
tributes. This orthogonality is obtained from the fact that in relational tables the mul-
tivalued attributes in the tuples are represented by unary concepts u ∈D1 provided in
(4.9). Thus, each computed relation ‖tR‖# is well-defined, and by using the joins with
the auxiliary table ‖rMA‖, we are able to obtain the complete list of values of each mul-
tivalued attribute in any tuple of ‖tR‖#. Hence, for any standard SQL statement (term)
tR, its evaluation must return the ordinary resulting view ‖tR‖# with the subset of tu-
ples in ‖rMA‖, which contains all lists of values used for the multivalued attributes in
the tuples of this view ‖tR‖#. This fact will be formally presented in next Definition 48
dedicated to views.
We say that an extension ‖tR‖#, of a term tR ∈𝒯PX, is a vector relation of the vector
view denoted by 󳨀→
tR if the type of ‖tR‖# is equal to the type of the vector relation rV.
Let R = ‖󳨀→
tR‖# be the relational table with the following four attributes (as in rV)
r-name, t-index, a-name and value, then its user-defined view representation can be
derived as follows (analog to Definition 47 without multivalued attributes).
Definition 48 (View materialization with multivalued attributes). Let tR ∈𝒯PX be a
user-defined SPJU (Select-Project-Join-Union) view over a database schema 𝒜
=
(SA, ΣA) with the type (the tuple of the view columns) S = ⟨(rk1, namek1), . . . , (rkm,
namekm)⟩, where the i-th column (rki, nameki) is the column with the name equal to
the nameki of the relation rki ∈SA, 1 ≤i ≤m, and 󳨀→
tR be the rewritten query over rV.
Let R = ‖󳨀→
tR‖# be the resulting relational table with the four attributes (as rV)
r-name, t-index, a-name and value. We define the operation VIEW of the transfor-
mation of R into the user defined view representation by:
VIEW(S, R) = (R1, R2),
where
R1 = {(d1, . . . , dm) | ∃ID ∈π3(R), ∀1≤i≤m((nr(rki), ID, nameki, di⟩∈R);
otherwise set di to NULL)}, and R2 = ‖t′
R‖# ⊆‖rMA‖ with
t′
R = rMA WHERE value IN (󳨀→
tR WHERE a-name MULTIVALUED)[value]),
which represents all lists of values for the multivalued attributes in the view R1.
Notice that we have, from (4.6), for each rk ∈SA with R = ⋃d∈‖rk‖ PARSE(rk, d), and
S = ⟨(rk, nrrk(1)), . . . , (rk, nrrk(ar(rk)))⟩, as in (4.7)
‖rk‖ = MATTER (rk, R) = VIEW (S, R),
and hence the non-SQL operation MATTER is a special case of the operation VIEW.

226
|
4 Intensional RDB manifesto: flexible big data and NewSQL
For any original user-defined query (term) tR over a user-defined database schema
𝒜, by 󳨀→
tR we denote the equivalent (rewritten) query over the vector relation rV. We have
the following important result for the IRDBs (analog to Proposition 23 in Section 4.2.2).
Proposition 26. There exists a complete algorithm for the term rewriting of any user-
defined SQL term tR over a schema 𝒜, of the full relational algebra ΣRE in Definition 46,
into an equivalent vector query 󳨀→
tR over the vector relation rV. If tR is a SPJU term (in
Definition 48) of the type S, then ‖tR‖# = π1(VIEW(S, ‖󳨀→
tR‖#)).
Proof. We will use the convention and recursive method used in the proof of Propo-
sition 23 in Section 4.2.2. The cases for Rename, Projection, Join, Union and Set dif-
ference are equal to the transformations presented in the proof of Proposition 23 used
in the IRDB without multivalued attributes. The only difference is for the Select oper-
ations in which the selection condition contains the multivalued attributes, because
the values of these attributes have to be checked in the auxiliary relation rMA. Thus,
for the Selection without multivalued attributes the transformation is equal to point
4 in the proof of Proposition 23. So, here we will consider only the Selection with also
multivalued attributes:
4.
(Selection). t′
R = tR WHERE C:
4.1 When a condition C is a finite-length logical formula that consists of atoms
‘((ri1, namei)θ(rj1, namej))’ or ‘(ri1, namei)θd’ or ‘(ri1, namei)’ NOT NULL with
built-in predicates θ ∈Σθ ⊇{≐, >, <}, a constant d
′ and the logical operators,
between the columns in the type S of the term tR. The condition C, composed
by k ≥1 different columns in S, we denote by C((ri1, namei1), . . . , (rik, nameik)),
k ≥1, and hence we defined the rewritten vector query
󳨀→
t′
R = 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
tR WHERE C = 󳨀→
tR WHERE nr󳨀→
tR
(2) IN t1
where for r =
k
⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞
󳨀→
tR ⨂⋅⋅⋅⨂󳨀→
tR we define the unary relation, which contains
the tuple-indexes of the relation ‖tR‖ for its tuples, which satisfy the selection
condition C, by the following selection term:
t1 = (r WHERE ((nrr(1) = ri1 ∧nrr(3) = namei1) ∧. . . ∧(nrr(1 + 4(k −1))
= rik ∧nrr(3 + 4(k −1)) = namei1)) ∧C′(nrr(4), . . . , nrr(4k)) ∧((k = 1)
∨(nrr(2) = nrr(6) = . . . = nrr(2 + 4(k −1)))))[nrr(2)],
where the transformed condition C′ is obtained from the original condition
C by substituting the atoms ‘((ri1, namei)θ(rj1, namej))’ where the left or right
side is a multivalued attribute, and ‘(ri1, namei)θd’ where (ri1, namei) is a mul-
tivalued attribute, by

4.3 Enrichment of IRDB by multivalued attributes
|
227
–
Case ‘((ri1, namei)θ(rj1, namej))’ where only (ri1, namei) is a multivalued
attribute. We substitute this expression by ∃x(rMA(namei, x) ∧(xθ(rj1,
namej)));
–
Case ‘((ri1, namei)θ(rj1, namej))’ where both sides are the multivalued at-
tributes.
We
substitute
this
expression
by
∃x∃y(rMA(namei, x) ∧
rMA(namej, y) ∧(xθy));
–
Case ‘(ri1, namei)θd’ where (ri1, namei) is a multivalued attribute. We sub-
stitute this expression by ∃x(rMA(namei, x) ∧(xθd)).
4.2 Case when C = (ri1, namei) NULL,
󳨀→
t′
R = 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
tR WHERE (ri1, namei) NULL = 󳨀→
tR WHERE nr󳨀→
tR
(2) NOT IN t2,
where t2 = (󳨀→
tR WHERE ((nr󳨀→
tR
(1) = ri1) ∧(nr󳨀→
tR
(3) = namei)))[(nr󳨀→
tR
(2)].
From the fact that tR WHERE C1 ∧C2 = (tR WHERE C1) WHERE C2 and tR WHERE C1 ∨
C2 = (tR WHERE C1) UNION (tR WHERE C2), and De Morgan laws, ¬(C1∧C2) = ¬C1∨¬C2,
¬(C1 ∨C2) = ¬C1 ∧¬C2, we can always divide any selection in the components of the
two disjoint cases above.
It is easy to show that for the selection, we obtain that ‖t′
R‖# = π1(VIEW(S, ‖
󳨀→
t′
R‖#)),
where S is the type of the relational algebra term t′
R, and for other operators (which
are equal as in the standard nonmany-valued attribute version of IRDB) it holds
as well, as it was demonstrated in Proposition 23. Thus, for any SPJU term tR ob-
tained by the composition of these basic relational algebra operators we have that
‖tR‖# = π1(VIEW(S, ‖󳨀→
tR‖#)). The update operators (for relation symbols we consider
their names depending on context):
1.
(Insert). INSERT INTO r[S] VALUES (d1, . . . , dm), where S = ⟨nrr(i1), . . . , nrr(im)⟩,
1 ≤m ≤ar(r), is the subset of mutually different attribute names of r and all dk,
1 ≤k ≤m are the values different from NULL. It is rewritten into the following set
of terms, for each attribute 1 ≤k ≤m:
(a) If the attribute nrr(ik) is not multivalued:
INSERT INTO rV[r-name, t-index, a-name, value] VALUES ((nr(r), Hash(c1, . . . ,
cm), nrr(ik), dk), where for 1 ≤i ≤m, ci = di if nrr(i) is not a multivalued at-
tribute; otherwise ci = ui for new unary intensional concept of nrr(i) for this
tuple to be inserted.
(b) If the attribute nrr(ik) is multivalued:
INSERT INTO rV[r-name, t-index, a-name, value] VALUES (nr(r), Hash(c1, . . . ,
cm), nrr(ik), uk)), where for 1 ≤i ≤m, ci = di if nrr(i) is not a multivalued
attribute; otherwise ci = ui (uk is one of them) for new unary intensional con-
cept of nrr(i) for this tuple to insert. Thus, if ¬∃yrMA(uk, y) then generate the
following set of terms for dk = {b1, . . . , bn}:

228
|
4 Intensional RDB manifesto: flexible big data and NewSQL
{INSERT INTO rMA[value, atom-value] VALUES (uk, bi) | 1 ≤i ≤n}.
Note that before the execution of this set of insertion operations in rV, the DBMS
has to control if it satisfies all user-defined integrityconstraints in the user-defined
database schema 𝒜;
2.
(Delete). DELETE FROM r WHERE C, is rewritten into the term:
DELETE FROM rV WHERE t-index IN 󳨀→
tR[nr󳨀→
tR
(2)],
where 󳨀→
tR = 󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀󳨀→
r WHERE C is the selection term as described above;
3.
(Update). The existence of the rewriting of this operation is obvious; it can always
be decomposed as a deletion and after that the insertion of the tuples.
This proposition demonstrates that the IRDB with multivalued attributes is a
SQL database, so that each user-defined query over the used-defined RDB database
schema 𝒜can be equivalently transformed by query rewriting into a query over the
vector relation rV and rMA. However, in the IRDBMSs we can use more powerful and ef-
ficient algorithms in order to execute each original user-defined query over the vector
relation rV and rMA.
Notice that this proposition demonstrates that the IRDB is a kind of GAV data in-
tegration system ℐ= (𝒜, 𝒮, ℳ) in Definition 44 where we do not materialize the user-
defined schema 𝒜but only the vector relation rV ∈𝒮and auxiliary relation rMA where
the sets of values of the multivalued attributes are stored. So, each original query q(x)
over the empty schema 𝒜will be rewritten into a vector query 󳨀󳨀󳨀→
q(x) of the type S over
the vector relation rV, and then the resulting view VIEW(S, ‖󳨀󳨀󳨀→
q(x)‖#) will be returned
to user’s application. Notice that this result is composed by two distinct tables: first
one R1 is the view relation and the second R2 is a subrelation of ‖rMA‖ composed by
all (and only) lists of values of the multivalued attributes for the tuples in R1. The vi-
sualization of an obtained resulting view can be, e. g., done for the table R1 where the
multivalued attributes are the colored links, and hence if one of them is pointed, then
the set of values of it will appear in a smaller window.
So, IRDB with multivalued attributes is a member of the NewSQL, i. e., a member
of a class of modern relational database management systems that seek to provide the
same scalable performance of NoSQL systems for online transaction processing (read-
write) workloads while still maintaining the ACID guarantees of a traditional database
system.
Example 23. For example, if we want to select all tuples in the table Contacts, such
that music is one of the hobbies of the contacts, we can use the SQL expression
“Contacts WHERE hobbies = music, ”
and we will obtain the two following tables:

4.3 Enrichment of IRDB by multivalued attributes
|
229
R1 =
contactID
firstName
lastName
street
zipCode
hobbies
. . .
. . .
. . .
. . .
. . .
. . .
132
Zoran
Majkic
Appia
0187
u
. . .
. . .
. . .
. . .
. . .
. . .
R2 =
value
atom-value
. . .
. . .
u
photography
u
music
u
art
u
travel
. . .
. . .
⊆‖rMA‖
Remark. With the condition “hobbies = music,” we extract all tuples in Contacts that
in the multivalued attribute hobbies have the set of values, which contain also the
value “music,” and not only the tuples that have exactly the singleton set {music}.
In order to make more powerful extractions, we can enrich the standard set of SQL
conditions also with multivalued features, like “hobbies CONTAINS [music, art],” so
that we are able to extract only tuples, which for this attribute, have the set of values
that contains the subset [music, art], or like “hobbies EQUALS [music, art]” in order
to extract only the tuples which for this attribute have exactly the set [music, art] of
values, etc.
Notice that by direct implementation of the multivalue attributes we are able, e. g.,
to extract the pairs of contacts that have the same set of hobbies by simply auto-joins
of the table Contacts over its multivalued-attribute hobbies.
So, this new family of IRDBs extends the traditional RDBS with new features, as
the interoperability, i. e., ability to share, interpret and manipulate across the hetero-
geneous database systems supported by multidatabase systems and to query together
their data and metadata. However, it is compatible in the way of how to present the
data by user-defined database schemas (as in RDBs) and with SQL for the management
of such a relational data.
Finally, we extend the ability of the IRDBs to support the SQL features also with
the presence of the multivalued attributes. Thanks to the intensional semantics, dif-
ferent from ordinary RDBs, which cannot directly support the multivalued attributes,
here we obtained a natural support for such a direct “reification-based” multivalued
framework. It is an orthogonal extension of the ordinary IRDBs without multivalued
attributes, from a semantic point of view, and hence all sets of the values of the mul-
tivalued attributes are stored in an auxiliary binary relation rMA. Consequently, the
computed view for any SQL query over a user-defined schema 𝒜returns two distinct
tables: the first one R1 is the ordinary view table with the indexed (links) values for
the multivalued attributes, and the second table R2 contains the sets of values of the
multivalued attributes in the tuples of the view table R1.

230
|
4 Intensional RDB manifesto: flexible big data and NewSQL
The passage from the existing RDB legacy systems into the IRDBs with multival-
ued attributes is easy: the structure of RDB is parsed into a vector key/value relation
so that we obtain a column representation of data used in big data applications, cov-
ering the key/value and column-based big data applications as well, into a unifying
RDB framework. After this step, we are able to add new multivalued attributes to the
database schema, and continue to work in this new framework. Note that the method
of parsing is well suited for the migration from all preexistent RDB applications where
the data is stored in the relational tables, so that this solution gives the possibility
to pass easily from the actual RDBs into the new machine engines for the IRDB. We
preserve all metadata (RDB schema definitions) without modification and only dema-
terialize its relational tables by transferring their stored data into the vector relation
rV (possibly in a number of disjoint partitions over a number of nodes). From the fact
that we are using the query rewriting IDBMS, the current user’s (legacy) applications
does not need any modification and they continue to “see” and manage the same user-
defined RDB schema as before. Consequently, this IRDB solution is adequate for a mas-
sive migration from the already obsolete and slow RDBMSs into a new family of fast,
NewSQL schema-flexible (with also ‘open schemas”) and big data scalable IRDBMSs.
We are able to return in any moment to the standard RDBMS by materialization
of the user defined schema into an RDB A and adding to this obtained RDB also the
auxiliary table rMA, which contains the sets of values for the multivalued attributes.
So, we can use the joins to link the values of the multivalued attributes in RDB A to
the sets of values in rMA in similar way as it is done in ad hoc indirect realization of
the multivalued attributes by introduction of new entities (tables) in the original RDB
schemas. Thus, the passage from RDBMs into the multivalued attribute version of the
IRDBs is easy and reversible as well.
4.4 Kleisli semantics for intensional RDB with multivalued
attributes
In this section, we present a denotational semantics of a new family of Intensional
RDBs (IRDBs) with also multivalued attributes. The categorial logic used for this deno-
tational semantics is based on the category DB where the objects are the instances of
RDBs and the morphisms are the set of functions, which express the schema mappings
between RDBs, provided by big data Integration theory [21] (see Section A.6 in the Ap-
pendix). It was demonstrated that the denotational semantics of database mappings
is given by morphisms of the Kleisli category given by a power-view monad over the
category DB. For the semantics of the multivalued attributes, we defined the particu-
lar “powerset” monad over DB and its Kleisli category. In this section, we demonstrate
that DB is able to support the intensional extension of the FOL and that the seman-
tics of the intensional elements, which represents the multivalued attributes can be
expressed by particular saturated morphisms in DB. We show that these saturated

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
231
morphisms are derived from the data integration mapping graph used to define the
canonical models of the IRDBs with the multivalued attributes.
The parallel DBMSs offer great scalability over the range of nodes that customers
desire, where all parallel DBMSs operate (pipelining) by creating a query plan that is
distributed to the appropriate nodes at execution time. When one operator in this plan
sends data to the next (running on the same or a different node), the data are pushed
by the first to the second operator (this concept is analog to the process described in
my book [21] dedicated to normalization of SQL terms (completeness of the action-
relational algebra category RA)), so that (different from MR), the intermediate data is
never written to disk.
The idea of using Kleisli categories (an introduction to category theory is given
in Section A.5 in the Appendix) in databases has been introduced for the database
mapping systems in [174], based on the power-view monad [175]. This approach of cat-
egorial semantics for the RDBs and their mappings is provided in [21] (an introduc-
tion is provided in Section A.6 in the Appendix). The notion of a monad is one of the
most general mathematical notions. For instance, every algebraic theory, i. e., every
set of operations satisfying equational laws, can be seen as a monad. Moggi [176, 177]
stressed the computational significance of monads and explained how they may help
understand programs “as functions from values to computations”. The idea of Moggi,
roughly, is to give denotational semantics to computations and it presents an alterna-
tive to the conceptual gap between the intensional (operational) and the extensional
(denotational) approaches to the semantics of programming languages.
The idea of monad as a model for computations, based on an endofunctor T for
a given category, is that for each set of values of type A, TA is the object of computa-
tions of “type A,” introduced in Section A.6.2 in the Appendix. Let us explain the way
we can use such denotational semantics, based on monads, in the case of relational
databases. It is well known that the relational databases are complex structures, de-
fined by some sets of n-ary relations. In addition, the mappings between the relational
databases are based on some sets of view mappings between a source database A and a
target database B, as specified in Section A.6.3 in the Appendix. We consider the views
as an universal property for databases (i. e., possible observations of the information
contained in some database).
We assume that a view of a database A as the relation (set of tuples) obtained
by a “Select-Project-Join + Union” (SPJRU) query q(x) where x is a list of attributes
of this view. We denote by ℒA the set of all such queries over a database A and by
ℒA/≈the quotient algebra obtained by introducing the equivalence relation ≈, such
that q(x) ≈q′(x) if both queries result in the same relation (view). Thus, a view can
be equivalently considered as a term of this quotient algebra ℒA/≈with carrier set of
relations in A and a finite arity of their operators, whose computation returns a set of
tuples of this view.
A categorical logic (denotational semantics) for database schema mapping based
on views, presented in [21], is a very general framework for database-integration/ex-

232
|
4 Intensional RDB manifesto: flexible big data and NewSQL
change and peer-to-peer. The base database category DB (instead of traditional Set
category of sets and functions between them), with objects instance-databases and
with morphisms (mappings which are not simple functions) between them, is used at
an instance level as a proper semantic domain for a database mapping based on a set
of complex query computations.
The higher logical schema level of mappings between databases, usually written
in some high expressive logical language ([111, 143], GLAV (LAV and GAV), tuple gen-
erating dependency) can then be translated functorially into this base “computation”
category. We will use such a framework also because an IRDB is formally defined as an
intensional GAV data integration system, so we are able to use all mathematical tools
developed in [21] in order to present a formal denotational semantics for the IRDBs
with multivalued attributes.
A similar approach in using Kleisli semantics to relax the atomicity requirement
for data in standard RDBs has been recently presented in [178], but in that case the
level of presentation of a database schema is given by the graphs (sketch categories)
composed by binary relations only and the functional dependencies between them.
Consequently, in such a low level schema representation we can use the topos Set
category as a base category and simple powerset functor as a monad, while in our
higher-level abstraction we present the whole RDB schema as a node of the sketch
and we represent also complex integrity constraints over schemas by schema map-
pings. Consequently, in our higher level presentation framework the monads have to
be developed for the weak monoidal topos DB, which is a somewhat mathematically
more complicated task.
The aim of this section is just to find the monad for DB, which is able to simulate
the powerset monad for Set, and to use the new sketch representation for the IRDB
schemas. So, this work is a direct continuation of the categorial semantics for standard
RDB data integration provided in my previous book, Big Data Integration [21].
We consider that a mapping between two database schemas 𝒜= (SA, ΣA) and
ℬ= (SB, ΣB) is expressed by an union of “conjunctive queries with the same head.”
Such mappings are called “view-based mappings,” defined by a set of FOL sentences
{∀xi(qAi(xi) ⇒qBi(yi)) | with yi ⊆xi, 1 ≤i ≤n}, where ⇒is the logical implication
between these conjunctive queries qAi(xi) and qBi(xi), over the databases 𝒜and ℬ,
respectively.
Schema mappings are often specified by the source-to-target tuple-generating de-
pendencies (tgds), used to formalize a data exchange [143], and in the data integration
scenarios under a name “GLAV assertions” [111, 142] as provided in detail with Defini-
tion 134 in Section A.6.3 in the Appendix. We use for the integrity constraints ΣA of a
database schema 𝒜both tgds and egds, while for the interschema mappings, between
a schema 𝒜= (SA, ΣA) and a schema ℬ= (SB, ΣB), only the tgds ∀x(qA(x) ⇒qB(x)).
The so-called second-order tgds (SO tgds) has been introduced in [179] as follows.

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
233
Definition 49 ([179]). Let 𝒜be a source schema and ℬa target schema. A second-order
tuple-generating dependency (SO tgd) is a formula of the form
∃f((∀x1(ϕ1 ⇒ψ1)) ∧. . . ∧(∀xn(ϕn ⇒ψn))), where:
1.
Each member of the tuple f is a functional symbol. Each variable in xi appears in
some atomic formula of ϕi.
2.
Each ϕi is a conjunction of:
–
atomic formulae of the form rA(y1, . . . , yk), where rA ∈SA is a k-ary relational
symbol of schema 𝒜and y1, . . . , yk are variables in xi, not necessarily distinct;
–
the formulae with conjunction and negation connectives and with built-in
predicate’s atoms of the form t ⊙t′, ⊙∈{≐, <, >, . . .}, where t and t′ are the
terms based on xi, f and constants.
3.
Each ψi is a conjunction of atomic formulae rB(t1, . . . , tm) where rB ∈SB is an m-ary
relational symbol of schema ℬand t1, . . . , tm are terms based on xi, f and constants.
Notice that each constant a in an atom on the left-hand side of implications must
be substituted by new fresh variable yi and by adding a conjunct (yi = a) in the left-
hand side of this implication, so that such atoms will have only the variables (condi-
tion 2 above). For the empty set of tgds, we will use the SOtgd tautology r0 ⇒r0. The
forth condition is a “safety” condition, analogous to that made for (first-order) tgds. It
is easy to see that every tgd is equivalent to one SOtgd without equalities. For exam-
ple, let σ be the tgd (consider, e. g., the mapping ρV in Proposition 25 in Section 4.3.1
for the data integration system of the IRDB with multivalued attributes)
∀x1 . . . ∀xm(ϕA(x1, . . . , xm) ⇒∃y1 . . . ∃ynψB(x1, . . . , xm, y1, . . . , yn)).
It is logically equivalent to the following SOtgd without equalities, which is obtained
by Skolemizing existential quantifiers in σ:
∃f1 . . . ∃fn(∀x1 . . . ∀xm(ϕA(x1, . . . , xm)
⇒ψB(x1, . . . , xm, f1(x1, . . . , xm), . . . , fn(x1, . . . , xm)))).
Given a finite set S of tgds of an interschema mapping (as, e. g., ℳand ℳOP in Propo-
sition 25), we can find a single SOtgd that is equivalent to S by taking, for each tgd σ
in S, a conjunct of the SOtgd to capture σ as described above (we use disjoint sets of
function symbols in each conjunct, as before). Thus, the mapping ρV here is trans-
formed into an equivalent SOtgd
∃f1(∀x1, . . . , ∀x4((rV(x1, x2, x3, x4) ∧x3 MULTIVALUED) ⇒rMA(x4, f1(x4))))
(4.11)
The integrity constraints of a schema 𝒜are transformed into schema mappings from
𝒜into the particular “FOL-identity” schema 𝒜⊤= ({r⊤}, 0) with empty set of integrity
constraints (introduced in [21], Section 4.1.1 for categorial semantics of database

234
|
4 Intensional RDB manifesto: flexible big data and NewSQL
schemas) where its binary built-in relation r⊤corresponds to FOL identity (so that the
ground atom r⊤(a, a) is true for each a ∈𝒟while, e. g., the ground atom r⊤(0, 1) is
false), based on the two following lemmas [21]:
Lemma 2. Any normalized tgd constraint of a schema 𝒜= (SA, ΣA), ∀x(ϕA(x) ⇒r(t)) ∈
Σegd
A
⊆ΣA, where t is a tuple of terms with variables in x and r ∈SA, is logically equivalent
to the FOL sentence ∀x((ϕA(x) ∧¬r(t)) ⇒r⊤(0, 1)).
Lemma 3. Any egd ∀x(ϕA(x) ⇒(y ≐z)) ∈Σegd
A
⊆ΣA of a given schema database
𝒜= (SA, ΣA) where y = ⟨xj1, . . . , xjk⟩⊆x and z = ⟨xl1, . . . , xlk⟩⊆x such that ji
̸= li for
1 ≤i ≤k, is logically equivalent to the FOL formula:
∀x((ϕA(x) ∧(y
̸= z)) ⇒r⊤(0, 1)),
where y
̸= z is an abbreviation for the formula (xj1
̸= xl1) ∨. . . ∨(xjk
̸= xlk).
Consequently, for the set of integrity constraints ΣA = Σtgd
A ⋃Σegd
A , of a RDB schema
𝒜= (SA, ΣA), we construct, by conjunction the SOtgd in ΣA denoted by a formula Φ,
and the schema “truth mapping” ⊤AA⊤= {Φ} : 𝒜→𝒜⊤, as explained in [21], Sec-
tion 4.1.1, Proposition 15. We recall that the “truth mapping” does not transfer any
tuple of data from the source to the target object.
Introduction to schema mappings, sketches and functorial semantics into DB cat-
egory, based on R-algebras, is provided in Section A.6.3 in the Appendix. Formal def-
inition of an R-algebra α as a mapping interpretation of a schema mapping ℳAB :
𝒜→ℬis given in [21] (Section 2.4.1, Definition 11) as follows.
Definition 50. Let ϕAi(x) ⇒rB(t) be an implication χ in a normalized SOtgd ∃f(Ψ)
(where Ψ is a FOL formula) of the mapping ℳAB, t be a tuple of terms with variables
in x = (x1, . . . , xm), and qi ∈MakeOperads(ℳAB) be the operad’s operation of this im-
plication obtained by MakeOperads algorithm, equal to the expression (e ⇒( _ )(t)) ∈
O(r1, . . . , rk, rB), where qi = vi ⋅qA,i with qA,i ∈O(r1, . . . , rk, rq) and vi ∈O(rq, rB) such that
for a new relational symbol rq, ar(rq) = ar(rB) ≥1.
Let S be an empty set and e[( _ )n/rn]1≤n≤k be the formula obtained from expression
e where each place-symbol ( _ )n is substituted by relational symbol rn for 1 ≤n ≤k.
Then do the following as far as it is possible: For each two relational symbols rj, rn in
the formula e[( _ )n/rn]1≤n≤k such that jh-th free variable (which is not an argument of
a functional symbol) in the atom rj(tj) is equal to nh-th free variable in the atom rn(tn)
(both atoms in e[( _ )n/rn]1≤n≤k), we insert the set {(jh, j), (nh, n)} as one element of S. At
the end, S is the set of sets that contain the pairs of mutually equal free variables.
An R-algebra α is a mapping interpretation of ℳAB : 𝒜→ℬif it is an extension of
a Tarski’s interpretation IT, of all predicate and functional symbols in FOL formula Ψ,
with I∗
T being its extension to all formulae, and if for each qi ∈MakeOperads(ℳAB) it
satisfies the following:

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
235
1.
For each relational symbol, ri
̸= r0 in 𝒜or ℬ, α(ri) = IT(ri).
2.
We obtain a function f = α(qA,i) : R1 × ⋅⋅⋅× Rk →α(rq),
where for each 1 ≤i ≤k, Ri = 𝒟ar(ri)\α(ri) if the place symbol ( _ )i ∈qi is preceded by
negation operator ¬; α(ri) otherwise, such that for every di ∈Ri:
f(d1, . . . , dk) = g∗(t) = (g∗(t1), . . . , g∗(tar(rB)))
if ⋀{πjh(dj) = πnh(dn) | {(jh, j), (nh, n)} ∈S} is true and the assignment g satis-
fies the formula e[( _ )n/rn]1≤n≤k; ⟨⟩(empty tuple) otherwise, where the assign-
ment g : {x1, . . . , xm} →𝒟is defined by the tuple of values (g(x1), . . . , g(xm)) =
Cmp(S, (d1, . . . , dk)), and its extension g∗to all terms such that for any term fi(t1, . . . , tn):
g∗(fi(t1, . . . , tn)) = IT(fi)(g∗(t1), . . . , g∗(tn))
if n ≥1; IT(fi) otherwise.
The algorithmCmp (compacting the list of tuples by eliminatingtheduplicatesdefined
in S) is defined as follows:
Input: a set S of joined (equal) variables defined above, and a list of tuples
(d1, . . . , dk).
Initialize d to d1. Repeat consecutively the following, for j = 2, . . . , k:
Let dj by a tuple of values (v1, . . . , vjn), then for i = 1, . . . , jn repeat consecutively the
following:
d = d&vi if there does not exist and element {(jh, j), (nh, n)} in S such that j ≤n; d,
otherwise.
(The operation of concatenation ‘&’ appends the value vi at the end of tuple d)
Output: The tuple Cmp(S, (d1, . . . , dk)) = d.
3.
α(rq) is equal to the image of the function f in point 2 above.
4.
The function h = α(vi) : α(rq) →α(rB) such that for each b ∈α(rq),
h(b) = b
if b ∈α(rB); empty tuple ⟨⟩otherwise.
Note that the formulae ϕAi(x) and expression e[( _ )n/rn]1≤n≤k are logically equiv-
alent, with the only difference that the atoms with characteristic functions fr(t) = 1
in the first formula are substituted by the atoms r(t), based on the fact that the as-
signment g satisfies r(t) iff g∗(fr(t)) = fr(g∗(t)) = 1, where fr : 𝒟ar(r) →{0, 1} is the
characteristic function of relation α(r) such that for each tuple c ∈𝒟ar(r), fr(c) = 1 if
c ∈α(r); 0 otherwise.
Example 24. Let us show how we construct the set S and the compacting of tuples
given by Definition 50 above.
Let us consider an operad qi ∈MakeOperads(ℳAB), obtained from a normal-
ized implication ϕAi(x) ⇒rB(t) in ℳAB, ((y = f1(x, z)) ∧r1(x, y, z) ∧r2(v, x, w) ∧
(fr3(y, z, w′, w) = 1)) ⇒rB(x, z, w, f2(v, z)), so that qi is equal to the expression (e ⇒

236
|
4 Intensional RDB manifesto: flexible big data and NewSQL
( _ )(t)) ∈O(r1, r2, r3, rB), where x = (x, y, z, v, w, w′) (the ordering of variables in the
atoms (with database relational symbols) from left to right), t = (x, z, w, f2(v, z)), and
the expression e equal to (y ≐f1(x, z)) ∧( _ )1(t1) ∧( _ )2(t2) ∧( _ )3(t3), with t1 = (x, y, z),
t2 = (v, x, w) and t3 = (y, z, w′, w). Consequently, we obtain
S = {{(1, 1), (2, 2)}, {(2, 1), (1, 3)}, {(3, 1), (2, 3)}, {(3, 2), (4, 3)}},
that are the positions of duplicates (or joined variables) of x, y, z and w, respectively.
Thus, for given tuples d1 = (a1, a2, a3) ∈α(r1), d2 = (b1, b2, b3) ∈α(r2) and d3 =
(c1, c2, c3, c4) ∈α(r3), the statement ⋀{πjh(dj) = πnh(dn) | {(jh, j), (nh, n)} ∈S} is equal to
(π1(d1) = π2(d2)) ∧(π2(d1) = π1(d3)) ∧(π3(d1) = π2(d3)) ∧(π3(d2) = π4(d3)), which is
true when a1 = b2, a2 = c1, a3 = c2 and b3 = c4.
The compacting of these tuples is equal to
d = Cmp(S, (d1, d2, d3)) = (a1, a2, a3, b1, b3, c3),
with the assignment to variables [x/a1], [y/a2], [z/a3], [v, b1], [w/b3] and [w′/c3].
That is, d = x[x/a1, y/a2, z/a3, v/b1, w/b3, w′/c3] is obtained by this assignment g
to the tuple of variables x, so that the sentence e[( _ )n/rn]1≤n≤k/g is well-defined and
equal to:
(a2 = IT(f1)(a1, a3)) ∧r1(a1, a2, a3) ∧r2(b1, a1, b3) ∧r3(a2, a3, c3, b3),
that is to
(a2 = IT(f1)(a1, a3)) ∧r1(d1) ∧r2(d2) ∧r3(d3),
and if this formula is satisfied by such an assignment g, i. e.,
I∗
T (e[( _ )n/rn]1≤n≤k/g) = 1,
then
f((d1, d2, d3)) = g∗(t) = (g(x), g(z), g(w), g∗(f2(v, z))) = (a1, a3, b3, IT(f2)(b1, a3)),
for a given Tarski’s interpretation IT, where I∗
T is the extension of IT to all FOL formulae.
If ℳAB is satisfied by the mapping interpretation α, this value of f ((d1, d2, d3))
corresponds to the truth of the normalized implication in the SOtgd of ℳAB, ϕAi(x) ⇒
rB(t) for the assignment g derived by substitution [x/d], when ϕAi(x)/g is true. Hence,
rB(t)/g is equal to rB(a1, a3, b3, IT(f2)(b1, a3)), i. e., to rB(f((d1, d2, d3))) and has to be true
as well (i. e., I∗
T (rB(f((d1, d2, d3)))) = 1 or, equivalently, f ((d1, d2, d3)) ∈α(rB) = IT(rB)).
Consequently, if ℳAB is satisfied by a mapping interpretation α (and hence α(vi) is
an injection function with α(rq) ⊆α(rB)) then f ((d1, d2, d3)) ∈‖rB‖, so that the function
f = α(qA,i) represents the transferring of the tuples in relations of the source instance
databases into the target instance database B = α∗(ℬ), according to the SOtgd Φ of the
mapping ℳAB = {Φ} : 𝒜→ℬ.
In this way, for a given R-algebra α which satisfies the conditions for the map-
ping interpretations in Definition 50, we translate a logical representation of database
mappings, based on SOtgds, into an algebraic representation based on relations of the
instance databases and the functions obtained from mapping operads.

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
237
It is easy to verify that for a query mapping ϕAi(x) ⇒rB(t), a mapping interpre-
tation α is an R-algebra such that the relation α(rq) is just equal to the image of the
function α(qA,i). The mapping interpretation of vi is the transfer of information of this
computed query into the relation α(rB) of the database ℬ.
When α satisfies this query mapping ϕAi(x) ⇒rB(t), then α(rq) ⊆α(rB) and, con-
sequently, the function α(vi) is an injection, i. e., the inclusion of α(rq) into α(rB). More-
over, each R-algebra α of a given set of mapping operads between a source schema 𝒜
and target schema ℬdetermines a particular information flux from the source into the
target schema.
Definition 51 (Information flux). Let α be a mapping interpretation (an R-algebra in
Definition 50) of a given set MAB = {q1, . . . , qn, 1r0} = MakeOperads(ℳAB) of mapping
operads, obtained from an atomic mapping ℳAB : 𝒜→ℬ, and A = α∗(SA) be an
instance of the schema 𝒜= (SA, ΣA) that satisfies all constraints in ΣA.
For each operation qi ∈MAB, qi = (e ⇒( _ )(ti)) ∈O(ri,1, . . . , ri,k, r′
i ), let xi be
its tuple of variables which appear at least one time free (not as an argument of a
function) in ti and appear as variables in the atoms of relational symbol of the schema
𝒜in the formula e[( _ )j/ri,j]1≤j≤k. Then we define:
(1) Var(MAB) = ⋃1≤i≤n{{x} | x ∈xi}.
We define the kernel of the information flux of MAB, for a given mapping interpretation
α, by (we denote the image of a function f by “im(f)”)
(2) Δ(α, MAB) = {πxi(im(α(qi))) | qi ∈MAB, and xi is not empty } ⋃⊥0, if Var(MAB)
̸= 0;
⊥0 otherwise.
We define the information flux from its kernel by
Flux(α, MAB) = T(Δ(α, MAB))
(4.12)
The flux of composition of MAB and MBC is defined by
Flux(α, MBC ∘MAB) = Flux(α, MAB) ⋂Flux(α, MBC)
(4.13)
We say that an information flux is empty if it is equal to ⊥0= {⊥} (and hence it is
not the empty set), analogously as for an empty instance database.
The information flux of the SOtgd of the mapping ℳAB for the instance-level map-
ping f = α∗(MAB) : A →α∗(ℬ), composed of the set of functions f = α∗(MAB) =
{α(q1), . . . , α(qn), q⊥}, is denoted by ̃f . Notice that ⊥∈̃f, and hence the information flux
̃f is a instance database as well.
From this definition, each instance mapping is a set of functions whose informa-
tion flux is the intersection of the information fluxes of all atomic instance mappings
that compose this composed instance mapping. These basic properties of the instance

238
|
4 Intensional RDB manifesto: flexible big data and NewSQL
mappings are used in order to define the database DB category where the instance
mappings are the morphisms (i. e., the arrows) of this category, while the instance
databases (each instance database is a set of relations of a schema also with the empty
relation ⊥) are its objects. So, we obtain the fundamental property in DB.
Equality of morphisms
Any two arrows f , g : A →B where A and B are the instance databases (the simple
sets of the relations) in DB are equal if ̃f = ̃g, i. e., if they have the same information
fluxes.
4.4.1 Functorial semantics for IRDBs with multivalued attributes
In what follows, we use the algorithm MakeOperads in [21] in order to transform logical
schema mappings ℳAB = {Φ} : 𝒜→ℬgiven by the SOtgds Φ in Definition 49 into
the algebraic operads MAB = MakeOperad(ℳAB) = {v1 ⋅qA,1, . . . , vn ⋅qA,1, 1r0} : 𝒜→ℬ.
The basic idea of the operad’s operations vi ∈O(r′, rB) and qA,i ∈O(r1, . . . , rk, r′), where
ri, 1 ≤i ≤k are relational symbols of the source schema 𝒜= (SA, ΣA) and rB is a
relational symbol of the target schema ℬ, and r′ has the same type as rB, is to formalize
algebraically a mapping from the set of source relations ri into a target relation rB. In
Section A.6.3 in the Appendix and Section 4.4, we provide an introduction to functorial
semantics of schema mappings into the DB category, with a number of examples.
In our IRDB case, for the two logical schema mappings we obtain the following
two algebraic operads:
TAA⊤= MakeOperads(⊤AA⊤) : 𝒜→𝒜⊤,
TAMAA⊤= MakeOperads(⊤AMAA⊤) : 𝒜MA →𝒜⊤.
Remark. The schema 𝒜MA = ({rMA}, 0) with an empty set of integrity constraints is
transformed in “truth mapping” ⊤AMAA⊤= {Ψ} : 𝒜MA →𝒜⊤, where Ψ is the SOtgd tau-
tology formally denoted by implication between the nullary relation r0 ⇒r0 (because
in the schema 𝒜MA we have the empty set of tgds and egds).
The R-algebra α is derived from a given Tarski’s interpretation IT of the given IRDB
schema (in Section 4.4): α is equal to IT for the relations of the data schemas, α(ri) =
IT(ri) is a relational table of the instance database A = α∗(𝒜) = {α(ri) | ri ∈SA} (α∗
denotes the extension of α to sets), and α(qA,i) : α(r1)×⋅⋅⋅×α(rk) →α(r′) is a surjective
function from the relations in the instance database A into its image (relation) α(r′),
with a function α(vi) : α(r′) →α(rB) into the relation of the instance database B =
α∗(ℬ).
From the fact that the operads can be composed, the composition of two schema
mappings ℳAB and ℳBC : ℬ→𝒞can be translated into the composition of operads,

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
239
which is associative, so that they can be represented by the sketch categories derived
from the graphs of the schema mappings. We have that for any R-algebra α, α(r0) = ⊥=
{⟨⟩} is the empty relation composed by only empty tuple ⟨⟩∈D−1, and 1r0 is the identity
operads operation of the empty relation r0, so that q⊥= α(1r0) = id⊥: ⊥→⊥is the
identity function. We denote by ⊥0 the database composed by only empty relations,
i. e., ⊥0 = {⊥}.
Now we can define the mapping graph between database schemas of an IRDB.
Definition 52. For a GAV data integration system ℐ= (𝒜, 𝒮, ℳ) of an IRDB 𝒜, where
𝒮= ({rV}, 0), and its extended schema
𝒜+ = (SA ⋃{rV, rMA}, ΣA ⋃ℳ⋃ℳOP ⋃{ρV})
in Proposition 25, we define its schema mapping noncommutative graph G,
𝒮
ℳ
?
?
ℳOP
𝒜
𝒜MA
ℳSAMA = {ρV}
?
⊤AMAA⊤
? 𝒜⊤
⊤AA⊤
?
with the auxiliary schema 𝒜MA = ({rMA}, 0) for the values of the multivalued attributes
in schema 𝒜.
Notice that all arrows of this graph are based on the SOtgds so that we can use the
MakeOperads algorithm for all arrows of this mapping graph in order to transform the
schema mapping graph G into the sketch category Sch(G) of the GAV data integration
system ℐof a IRDB 𝒜above. Sketches are called graph-based logic and provide very
clear and intuitive specifications of computational data and activities, as described in
Section 4.4.
In what follows, we will use the database category DB, developed in [21] and intro-
duce here in Section A.6 of the Appendix and in Section 4.4, with fundamental idempo-
tent power-view operator T : DB →DB, with the domain and codomain equal to the set
of all instance databases such that for any instance database A, the object TA = T(A)
denotes a database composed of the set of all views of A. For every object A, A ⊆TA
and TA = T(TA), i. e., each (element) view of database instance TA is also an element
(view) of a database instance A.
In fact, we translate each database mapping logic theory based on SOtgds into an
algebraic theory expressed by a sketch-category Sch(G) where all arrows are R-algebra
terms. Then we describe R-algebraic structures using these sketch categories for the-
ories and α functors into the base category DB in order to obtain the models of the
database-mapping theories.

240
|
4 Intensional RDB manifesto: flexible big data and NewSQL
Notice that the mapping arrow ℳin a graph G is replaced by the morphism M =
MakeOperads(ℳ) in this sketch [180], while the nodes (objects) are eventually aug-
mented by introducing another auxiliary schema 𝒜⊤as explained in the graph above
for the integrity constraints of the nodes (RDB schemas). Each mapping interpretation
α for the schema-mapping graph G is also a functor α∗: Sch(G) 󳨀→DB such that it
generates an instance database A = α∗(𝒜) for each schema 𝒜∈Sch(G), the unique
instance of “truth” schema AT = α∗(𝒜⊤) =def {α(r⊤), ⊥}, where α(r⊤) = R= (binary
identity built-in relation), and the following arrows in DB:
1.
For each schema 𝒜∈Sch(G), the identity morphism idA : A →A and, eventually,
its integrity-constraint morphism fΣA : A →A⊤as specified in [21], Section 4.1.1,
Proposition 15.
2.
For each mapping-operad arrow MAB : 𝒜→ℬin Sch(G), we define the morphism
f = α∗(MAB) : A →B, where A = α∗(𝒜) and B = α∗(ℬ).
Consequently, the set Int(G) of all mapping interpretations of a given mapping system
graph G is a subset of all functors from Sch(G) into DB, i. e., Int(G) ⊆DBSch(G), such
that for each functor α∗∈Int(G) of an IRDB we obtain the functorial mapping (where
α∗(𝒮) = {α(rV), ⊥} = {‖rV‖, ⊥}, α∗(𝒜MA) = {α(rMA), ⊥} = {‖rMA‖, ⊥}, fM = α∗(M) and
f OP
M = α∗(MOP)):
𝒮
M ?
?
MOP
𝒜
α∗(𝒮) = { ⃗A, ⊥}
fM
?
?
f OP
M
A ⋃{⊥}
α∗󳨃→
𝒜MA
MSAMA
?
TAMAA⊤
? 𝒜⊤
TAA⊤
?
α∗(𝒜MA) = {‖rMA‖, ⊥}
α∗(MSAMA) = {hρV , q⊥}
?
fMA
? A⊤= {R=, ⊥}
fΣA
?
in Sch(G)
in DB category
with q⊥: ⊥→⊥and the function hρV :
⃗A →‖rMA‖, such that for any tuple
d = ⟨nr(rk), ID, ai, d⟩∈
⃗A = ‖rV‖
where ai is multivalued attribute of relation rk, we obtain that (π2 ⋅hρV )(d) = π2(hρV (d))
is one of the values of this attribute ai in the tuple ID of the relation rk. The morphisms
fΣA and fMA are equivalent to the empty morphism ⊥1 =def {q⊥}.
It was demonstrated in [21], Proposition 17, Section 4.1.3, that α∗is a model of the
sketch Sch(G) iff for each its arrow MAB = MakeOperad(ℳAB) = {v1 ⋅qA,1, . . . , vn ⋅
qA,n, 1r0} : 𝒜→ℬwe have that all α(vi), 1 ≤i ≤n are injective functions. Thus, in what
follows, we will consider only the subset Mod(Sch(G)) ⊆Int(G) of the models of the
IRDBs, i. e., α∗∈Mod(Sch(G)).

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
241
The GAV categorial semantics for standard RDBs, for the schema mapping arrows
M, MOP and TAA⊤, are presented in detail in [21], Section 4.2.2, and here we demon-
strate the following property.
Theorem 6. For any α ∈Int(G) of the data integration graph G and corresponding
sketch Sch(G), such that α(𝒮) =⊥0 ⋃rk∈SA,d∈α(rk) PARSE(rk, d) and A = α∗(𝒜), the mor-
phisms fM = α∗(M) and f OP
M = α∗(MOP) are satisfied and fM ∘f OP
M = idA.
Conversely, if A = α∗(𝒜) and fM = α∗(M) and f OP
M
= α∗(MOP) are satisfied mor-
phisms then fM ∘f OP
M = idA and α(𝒮) =⊥0 ⋃rk∈SA,d∈α(rk) PARSE(rk, d).
Proof. We have the mapping ℳOP
=
{∀xk,1, . . . , xk,ar(rk)((rk(xk,1, . . . , xk,ar(rk)) ∧
xk,i NOT NULL) ⇒rV(nr(rk), Hash(xk,1, . . . , xk,ar(rk)), nrrk(i), xk,i)) | 1 ≤i ≤ar(rk), rk ∈
SA, 1 ≤k ≤n}. Thus,
MOP = MakeOperads(ℳOP) = {1r0} ⋃{qk,i|rk ∈SA and 1 ≤i ≤ar(rk)} : 𝒜→𝒮
with qk,i = ((( _ )(xk,1, . . . , xk,ar(rk)) ∧xk,i NOT NULL) ⇒( _ )(tk,i)) ∈O(rk, rV), where tk,i =
{t1, . . . , t4} with the terms:
1.
t1 is the nullary built-in function, i. e., the fixed constant, which does not depend
on Tarski’s interpretations, equal to the relation table name rk;
2.
t2
= Hash(xk,1, . . . , xk,ar(rk)) where Hash is a built in-function equal for every
Tarski’s interpretation;
3.
t3 is the nullary built-in function, i. e., the fixed constant, which does not depend
on Tarski’s interpretations, equal to the i-th columnname of the relationaltable rk;
4.
t4 is the variable xk,i.
Consequently, we obtain the function α(qk,i) : α(rk) →α(rV) =
⃗A, such that for its
image im(α(qk,i)) we obtain from the parsing that π4(im(α(qk,i))) = πi(α(rk)).
Thus, from Definition 13, Section 2.4.3 in [21], the kernel of the information flux of
MOP, for a given mapping interpretation α, is equal to
△(α, MOP) = {π4(im(α(qk,i))) | qk,i ∈MOP} ⋃⊥0
= {πi(α(rk)) | qk,i ∈MOP} ⋃⊥0
= {πi(α(rk)) | rk ∈SA, 1 ≤i ≤ar(rk)} ⋃⊥0.
Let us show that for the power-view operator T (which is a monotonic closure operator
[21] with TT = T),
T({πi(α(rk)) | rk ∈SA, 1 ≤i ≤ar(rk)} ⋃⊥0) = T({α(rk) | rk ∈SA} ⋃⊥0) :
(a) From monotonicity, T({πi(α(rk)) | rk ∈SA, 1 ≤i ≤ar(rk)} ⋃⊥0) ⊆T({α(rk) | rk ∈
SA, 1 ≤i ≤ar(rk)} ⋃⊥0) = T({α(rk) | rk ∈SA} ⋃⊥0) = T(A).

242
|
4 Intensional RDB manifesto: flexible big data and NewSQL
(b) We have that α(rk) ⊆π1(α(rk)) × ⋅⋅⋅× πar(rk)(α(rk)) ∈T({πi(α(rk)) | rk ∈SA, 1 ≤
i ≤ar(rk)} ⋃⊥0). Thus, A = {α(rk) | rk ∈SA} ⋃⊥0 ⊆T({πi(α(rk)) | rk ∈SA, 1 ≤i ≤
ar(rk)} ⋃⊥0) and, by applying T to left and right side, we obtain from the monotonic
and idempotent property of T,
T(A) = T({α(rk) | rk ∈SA} ⋃⊥0)
⊆T(T({πi(α(rk)) | rk ∈SA, 1 ≤i ≤ar(rk)} ⋃⊥0))
= T({πi(α(rk)) | rk ∈SA, 1 ≤i ≤ar(rk)} ⋃⊥0).
Consequently, from (a) and (b) weobtain the equivalencyabove.Thus,the information
flux of the morphisms f OP
M = α∗(MOP) is equal to
̃
f OP
M = T(△(α, MOP)) = T({πi(α(rk)) | rk ∈SA, 1 ≤i ≤ar(rk)} ⋃⊥0)
= T({α(rk) | rk ∈SA} ⋃⊥0) = T(A) = ̃
idA,
where idA = {idr1, . . . , idrn, q⊥} : A →A is the identity morphisms (with the identity
functions idrk : α(rk) →α(rk) for k = 1, . . . , n) of the object (database) A in DB.
Analogously, from Definition 44 for each rk ∈SA we have the tgd (4.3),
∃z, z1, z2(rV(nr(rk), z, z1, z2)) ∧∀y, x1, . . . , xar(rk)(((rV(nr(rk), y, nrrk(1), x1) ∨xk,1 NULL)
∧⋅⋅⋅∧(rV(nr(rk), y, nrrk(ar(rk)), xk,ar(rk)) ∨xar(rk) NULL)) ⇒rk(xk,1, . . . , xk,ar(rk)))
in ℳ. Consequently, we obtain M = {q1, . . . , qn, 1r0} : 𝒮→A, where qk = (e ⇒
( _ )(xk,1, . . . , xk,ar(rk))) ∈O(rV, rk), such that for the mapping interpretation α we obtain
the function α(qk) :
⃗A →α(rk) (where ⃗A = α(rV)), with im(α(qk)) = α(rk).
Consequently, the kernel of the information flux of M, for α, is equal to
△(α, M) = {π[1,...,ar(rk)](im(α(qk))) | qk ∈M} ⋃⊥0
= {im(α(qk)) | 1 ≤k ≤n} ⋃⊥0{α(rk) | 1 ≤k ≤n} ⋃⊥0 = A.
Thus, the information flux of the morphism fM = α∗(M) is equal to
̃
fM = T(△(α, M)) = T(A).
Consequently, ?
fM ∘f OP
M = ̃
fM ⋂̃
f OP
M = T(A) = ̃
idA, and hence
fM ∘f OP
M = idA : A →A.
This theorem is valid for any IRDB. In fact, if we have no the multivalued attributes
then the graph G of the sketch Sch(G) is still composed by these two mappings M

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
243
and MOP and the integrity-constraint mapping TAA⊤. The morphisms in DB category
obtained from the “truth arrows,” fMA = α∗(TAMAA⊤) and fΣA = α∗(TAA⊤) have empty
information flux, i. e., ̃
fMA = ̃
fΣA = ⊥0, so the only interesting mapping, derived from
the intensional nature of the IRDB and the multivalued attribute features, is MSAMA :
𝒮→𝒜MA:
MSAMA = MakeOperads({ρV}) = {qρV , 1r0} : 𝒮→𝒜MA,
qρV = v1 ⋅qS,1
with v1 = (( _ )(x, y) ⇒( _ )(x, y)) ∈O(r′, rMA) and qS,1 = ((( _ )(x1, x2, x3, x4) ∧x3
MULTIVALUED) ⇒( _ )(x4, f1(x4))) ∈O(rv, r′), so that α∗(MSAMA) = {hρV , q⊥} with the
composed function hρV = α(qρV ) = α(v1⋅qS,1) = α(v1)⋅α(qS,1), where α(v1) is an injection
and the function α(qS,1) : ‖rV‖ →α(r′) is defined for each tuple d = (nr(rk), IDt, ai, d)
by
α(qS,1)(d) =
{
{
{
{
{
(d, IT(f1)(d)),
if ai is a multivalued attribute of rk
and IT(f1)(d) is a value of this attribute
⟨⟩,
empty tuple otherwise
(4.14)
where α is derived from the Tarski’s interpretation IT, (with α(rV) = IT(rV) = ‖rV‖)
and IT(f1) is a Tarski’s interpretation of the Skolem function f1 introduced in SOtgd by
elimination of an existentially quantified variable. Let α(r′) = im(α(qS,1)) be the binary
relation equal to image of the function α(qS,1). So, if this mapping is satisfied then the
function α(v1) : α(r′) →α(rMA) = ‖rMA‖ is an injection, and hence the function
hρV = α(qρV ) : ‖rV‖ →‖rMA‖
(4.15)
is equal to the function α(qS,1) defined above. In the next section, we will see how we
can use the morphisms (4.15) above for the categorial semantics of the multivalued
attributes in DB category, because tgd ρV is second-order logic where the function f
is existentially quantified, and for a given (single) Tarski’s interpretation IT, IT(f1)(d)
gives only one value of this multivalued attribute, while we need to cover all values of
this attribute. So this morphism in DB has to be a “powerset” mapping denominated
“saturated” morphism as well, and we provide the new algorithm (nonpresent in [21])
for it in what follows.
Let ϕAi(x) ⇒rB(t), as in Definition 50 in Section 4.4, be an implication in a nor-
malized SOtgd ∃f(Ψ) (where Ψ is a FOL formula) of the mapping ℳAB : 𝒜→B with
the sketch’s arrow MAB = MakeOperads(ℳAB) = {q1, . . . , qn, 1r0}, t = (t1, . . . , tar(rB)) be a
tuple of terms with variables in x = (x1, . . . , xm), and qi ∈MAB be the operad’s opera-
tion of this implication, equal to the expression (e ⇒( _ )(t)) ∈O(r1, . . . , rk, rB), where
qi = vi ⋅qA,i with qA,i = (e ⇒( _ )(t)) ∈O(r1, . . . , rk, rq) and
vi = (( _ )(y1, . . . , yar(rB)) ⇒( _ )(y1, . . . , yar(rB))) ∈O(rq, rB)

244
|
4 Intensional RDB manifesto: flexible big data and NewSQL
such that for a new relational symbol rq, ar(rq) = ar(rB) ≥1. It is important to underline
that each term ti is a simple variable, which appears in the tuple x (left-hand side of
the implication) or the term fl(z) where the variables in the tuple z are a subset of the
variables in x.
Let dom, cod and graph be the operators, which for each function, return the do-
main, codomain and graph of this function, respectively, and 𝒫be the powerset oper-
ation.
For a given mapping interpretation α such that A = α∗(𝒜) and B = α∗(ℬ) are
two models of the schemas 𝒜and ℬ, respectively, and α satisfies the schema mapping
ℳAB = {∃fΨ}, with the tuple of existentially quantified Skolem functions f, the process
of saturation of the morphism h = α∗(MAB) = {α(q1), . . . , α(qn), q⊥} (such that a k-ary
function α(qi) : R1 ×⋅⋅⋅×Rk →‖rB‖ returns a single tuple (or empty tuple ⟨⟩) of ‖rB‖) is
relevant only for the operads operations qi, which have at least one functional symbol
of f in the right-hand side of implication, as follows.
Saturation algorithm Sat(α∗(MAB))
Input: A mapping arrow MAB = {q1, . . . , qN, 1r0} : 𝒜→ℬ, and a mapping interpreta-
tion α such that A = α∗(𝒜) and B = α∗(ℬ) are two models of the schemas 𝒜and ℬ,
respectively, and α obtained of a given Tarski’s interpretation IT, satisfies the schema
mapping ℳAB = {∃fΨ}, with the tuple of existentially quantified Skolem functions f.
Output: Saturated morphism from A into B in the DB category.
1.
Let h = α∗(MAB) = {h1,0, . . . , hN,0, id⊥}, hn,0 = α(qn), with Sat(h) = h, i = 0.
2.
i = i + 1. If i > N, go to 8.
3.
Let the mapping component qi ∈MAB be the expression (e ⇒( _ )(t)) ∈O(r1, . . . ,
rk, rB), where qi = vi ⋅qA,i with qA,i = (e ⇒( _ )(t)) ∈O(r1, . . . , rk, rq) and vi =
(( _ )(y1, . . . , yar(rB)) ⇒( _ )(y1, . . . , yar(rB))) ∈O(rq, rB). Define the set ℱ⊆f of all
functional symbols in the tuple of terms t. If ℱis empty, then go to 2.
4.
(Fix the function of qi for given α) Let α(qA,i) : R1×⋅⋅⋅×Rk →α(rq) be the function of
this mapping interpretation provided in Definition 50 in Section 4.4 where α(rq) ⊆
‖rB‖ is image of this function with relation ‖rB‖ = α(rB) ∈B, x = (x1, . . . , xm) be the
tuple of all variables in the left-side expression e of the operad’s operation qi, and
S be the set of sets that contain the pairs of mutually equal free variables in the
formula e[( _ )n/rn]1≤n≤k obtained from qi (in Definition 50).
Set RL = R1 × ⋅⋅⋅× Rk.
5.
(Expansion of qA,i) If RL is empty, then go to 2.
Take a tuple (d1, . . . , dk) ∈RL ⊆R1 × ⋅⋅⋅× Rk and delete it from RL. Then define the
assignment g : x →𝒟such that g(x) = Cmp(S, (d1, . . . , dk) (from Definition 50 in
Section 4.4).
If α(qA,i)((d1, . . . , dk)) = g∗(t) = (g(t1), . . . , g(tar(rB))
̸= ⟨⟩, then go to 6.
Go to 5.
6.
(Definition of the extension corresponding to the tuple (d1, . . . , dk))

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
245
Let Z be the set of indexes of the terms in t = (t1, . . . , tar(rB)), which are simple vari-
ables and we denote by nrrB(j) the name of the j-th column of the relation rB ∈ℬ.
Then we define the relation:
R =
󵄩󵄩󵄩󵄩󵄩󵄩󵄩󵄩
(SELECT (∗) FROM ‖rB‖ WHERE ⋀
j∈Z
(nrRB(j) = g(tj)))
󵄩󵄩󵄩󵄩󵄩󵄩󵄩󵄩#
\{g∗(t)}.
7.
If R is an empty relation, then go to 5.
Take from R a tuple b = (b1, . . . , bar(rB)) and delete it from R. We define a new
Tarski’s interpretation I′
T, different from IT only for the functional symbols fl ∈ℱ
of the j-th term tj = fl(xj1, . . . , xjp) ∈t, as follows:
1.
I′
T(fl)(g(xj1), . . . , g(xjp)) = bj
̸= g(tj) = IT(fl)(g(xj1), . . . , g(xjp));
2.
For all assignments g1
̸= g, we have that
I′
T(fl)(g1(xj1), . . . , g1(xjp)) = IT(fl)(g1(xj1), . . . , g1(xjp));
so that for the R-algebra α′ derived from the Tarski’s interpretation I′
T:
7.1
If ∃hi,n ∈Sat(h) such that (d1, . . . , dk) ∉graph(hi,n), then insert ((d1, . . . ,
dk), b) into graph(hi,n) and go to 5.
7.2 Generate, for new index m, a new function hi,m = α′(qA,i) : R1 × ⋅⋅⋅× Rk →
‖rB‖ with graph(hi,m =def {((d1, . . . , dk), b)}, insert it in Sat(h) and go to 7.
8.
Return the saturated morphism Sat(α∗(MAB)) : A →B after completion
of each function hi,n in it as follows: for each (d1, . . . , dk)) ∈(dom(hi,n)\
π1(graph(hi,n))), set hi,n(d1, . . . , dk)) = ⟨⟩.
By the saturation of h, we obtain the morphism Sat(h) : A →B from which we are
able to define the set ℱqi = {hi,j : dom(α(qi)) →cod(α(qi)) | hi,j ∈Sat(h)} and function
fqi = ⋃ℱqi with graph (fqi) =def ⋃hi,j∈ℱqi graph(hi,j), where
(℧)
graph(hi,j) = {((d1, . . . , dk), hi,j(d1, . . . , dk)) | (d1, . . . , dk) ∈dom(hi,j) and
hi,j(d1, . . . , dk)
̸= ⟨⟩}
is the nonempty-tuple graph of this function. Thus, in this way we obtain the p-func-
tion:
(℘)
fqi : dom(α(qi)) →𝒫(cod(α(qi))),
for each operad’s operation qi ∈MAB, which has the functional symbols on he right
side of implication in qi. We have the following property for these derived p-functions.

246
|
4 Intensional RDB manifesto: flexible big data and NewSQL
Lemma 4. Let the mapping component qi ∈MAB : 𝒜→ℬbe the expression (e ⇒
( _ )(t)) ∈O(r1, . . . , rk, rB), with the tuple x = (x1, . . . , xm) of all variables in the left-side
expression e, such that the set of functional symbols in the tuple of terms t is not empty.
Let R-algebra α be a model of MAB with Rn = α(rn) ∈A = α∗(𝒜), n = 1, . . . , k, and
‖rB‖ = α(rB) ∈B = α∗(ℬ), and hi,0 = α(qi) : R1 × ⋅⋅⋅× Rk →‖rB‖ with hi,0 ∈h = α∗(MAB) :
A →B. So, for the component qi ∈MAB : 𝒜→ℬ, the set
ℱqi = {hi,j : dom(α(qi)) →cod(α(qi)) | hi,j ∈Sat(h)}
we define the p-function:
fqi =def ⋃ℱqi : R1 × ⋅⋅⋅× Rk →𝒫(‖rB‖),
with graph(fqi) =
⋃
hi,j∈ℱqi
graph(hi,j)
(4.16)
Let Z be the set of indexes of the terms in t = (t1, . . . , tar(rB)), which are simple variables
and we denote by nrrB(j) the name of the j-th column of the relation rB ∈ℬ. Then, for
each tuple (d1, . . . , dk) ∈R1 × ⋅⋅⋅× Rk with the assignment g : {x1, . . . , xm} →𝒟such that
(g(x1), . . . , g(xm)) = Cmp(S, (d1, . . . , dk)) (from Definition 50 in Section 4.4), we obtain
fqi(d1, . . . , dk) = 󵄩󵄩󵄩󵄩SELECT (∗) FROM ‖rB‖ WHERE ⋀
j∈Z
(nrRB(j) = g(tj))󵄩󵄩󵄩󵄩#
(4.17)
and, if α(qi)(d1, . . . , dk) = ⟨⟩then fqi(d1, . . . , dk) = 0 ∈𝒫(‖rB‖).
Proof. From the steps 6 and 7 of the algorithm for saturation, we have that for every
tuple in b ∈R = ‖SELECT (∗) FROM ‖rB‖ WHERE ⋀j∈Z(nrRB(j) = g(tj))‖#, we have a
function hi,j ∈ℱqi, with b ∈π2(graph(hi,j)), and hence (4.17) is valid.
Corollary 14. For every R-algebra α which is a model of a given schema mapping MAB :
𝒜→ℬ, we have that α∗(MAB) : α∗(𝒜) →α∗(ℬ) and Sat(α∗(MAB)) : α∗(𝒜) →α∗(ℬ)
are two equal morphisms in the category DB. Thus, the saturation of morphisms is an
invariant process in DB, so that we can replace any nonsaturated morphisms with its
saturated version in any commutative diagram in DB.
Proof. From the fact that the introduction of the new functions changes only the terms
with nonbuilt-in functional symbols on the right sides of implications, so that they are
not in Var(MAB), and hence, from Definition 51 in Section 4.4, they do not change the
information flux of the morphism α∗(MAB).
Example 25 (Continuation of Example 23 in Section 4.3.2). We have the schema map-
ping ℳAB : 𝒜→ℬby the tgd
∀x1, x2, x3, x4, x5(Contacts(x1, x2, x3, x4, x5, x6) ⇒∃yrMA(x6, y)),
so that by Skolemization we obtain the SOtgd Φ equal to the logic formula

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
247
∃f1(∀x(Contacts(x) ⇒rMA(x6, f1(x6))),
where x = (x1, x2, x3, x4, x5, x6). So, MAB = MakeOperads({Φ}) = {q1, 1r0} : 𝒜→ℬ, with
q1 = v1 ⋅qA,1 ∈O(Contacts, rMA) with qA,1 = (( _ )(x) ⇒( _ )(t)) ∈O(Contacts, rq),
where t = ⟨t1, t2⟩with the term t1 equal to variable x6 and term t2 equal to f1(x6), and
v1 = (( _ )(y1, y2) ⇒( _ )(y1, y2)) ∈O(rq, rMA).
Let us consider a model of this schema mapping α, such that R1 = α(Contacts)
and ‖rB‖ = ‖rMA‖ = α(rMA), with
R1 =
contID
firstName
lastName
street
zipCode
hobbies
. . .
. . .
. . .
. . .
. . .
. . .
132
Zoran
Majkic
Appia
0187
hobbies_of_132
. . .
. . .
. . .
. . .
. . .
. . .
‖rB‖ = ‖rMA‖ =
value
atom-value
. . .
. . .
hobbies_of_132
photography
hobbies_of_132
music
hobbies_of_132
art
hobbies_of_132
travel
. . .
. . .
so that for d1 = (132, Zoran, Majkic, Appia, 0187, hobbies_of_132) ∈R1, we obtain the
assignment g : x →𝒟such that g(x) = Cmp(0, d1) = d1, i. e., g(x1) = 132, g(x2) =
Zoran, g(x3) = Majkic, g(x4) = Appia, g(x5) = 0187, and g(x6) = hobbies_of_132,
and for h1,0 = α(q1) : R1 →‖rB‖ such that h1,0(d1) = g∗(t) = (g(x6), f1(g(x6))) =
(hobbies_of_132, IT(f1)(hobbies_of_132)) = (hobbies_of_132, art), i. e.,
(a) IT(f1)(hobbies_of_132) = art.
Then in step 6 of the algorithm, we have Z = {t1} = {x6} with nrrMA(1) = value and
(b)
R =
󵄩󵄩󵄩󵄩󵄩󵄩󵄩󵄩
(SELECT (*) FROM ‖rB‖ WHERE ⋀
j∈Z
(nrRB(j) = g(tj)))
󵄩󵄩󵄩󵄩󵄩󵄩󵄩󵄩#
\{g∗(t)}
= 󵄩󵄩󵄩󵄩(SELECT (*) FROM ‖rB‖ WHERE value = hobbies_of_132)󵄩󵄩󵄩󵄩#\{g∗(t)}
=
value
atom-value
hobbies_of_132
photography
hobbies_of_132
music
hobbies_of_132
travel
Consequently, in step 7 of the algorithm will be introduced the three new functions
h1,j : R1 →‖rB‖, for each tuple b ∈R, into Sat(α∗(MAB)) so that (for u = hobbies_of_132)
h1,1(d1) = (u, photography),
with I′
T(f1)(u) = photography;

248
|
4 Intensional RDB manifesto: flexible big data and NewSQL
h1,2(d1) = (u, music),
with I′′
T (f1)(u) = music;
h1,3(d1) = (u, travel),
with I′′′
T (f1)(u) = travel .
Thus, from the algorithm we obtain {h1,0, h1,1, h1,2, h1,3, id⊥} ⊆Sat(h) and derived
p-function (4.16), fq1 = ⋃ℱq1 : α(Contacts) →𝒫(α(rMA)), with
fq1(d1) = fq1(132, Zoran, Majkic, Appia, 0187, hobbies_of_132)
=
value
atom-value
hobbies_of_132
art
hobbies_of_132
photography
hobbies_of_132
music
hobbies_of_132
travel
and hence, by using the second projection π2, we obtain that, for ID = 132,
(π2 ⋅fq1)(d1) = {photography, art, music, travel},
i. e., for each contact ID, the function π2 ⋅fq1 returns the set of hobbies of this ID.
In this way, we are able to represent also the 1:N relationships between relational
tables by the morphisms in DB category.
It is important that the saturation can be done only for the nonbuilt-in functional
symbols. In fact, we have only one prefixed interpretation of the built-in functional
symbols, so that their interpretation is equal for every Tarski’s interpretation.
4.4.2 Kleisli semantics in DB category
The notion of a monad is one of the most general mathematical notions [181–183].
For instance, every algebraic theory, i. e., every set of operations satisfying equational
laws, can be seen as a monad (which is also a monoid in a category of endofunc-
tors of a given category: the “operation” μ being the associative multiplication of this
monoid and η its unit). Given an endofunctor T : C →C with a natural transformation
η : idC
󳐂? T and a natural transformation μ : T2
󳐂? T (here T2 denotes the com-
position TT) such that the diagrams (A.9), in Section A.5 in the Appendix, of natural
transformations commute, then a triple (T, η, μ) is called a monad. Thus, monoid laws
of the monad do subsume all possible algebraic laws. More specifically, the monads
are used as a way of modeling computational/collection types [176, 177, 184, 185] as
we intend to use them in this section.
Example 26. It is very easy to use the monads over Set. In particular, within a Kleisli
instance it is permitted to relax the atomicity requirement for data (i. e., the first nor-
mal form in Codd’s requirements for RDBs). For example, for the List monad, List :

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
249
Set →Set, which assigns to any set S (an object in Set) the set of all lists List(S),
which can be obtained from elements in S, so that an arrow f : X →List(S) in Set as-
signs to each element a of the set X a particular list L in List(S). Similarly, the powerset
endofunctor 𝒫: Set →Set assigns to each set S the set of all its subsets 𝒫(S), and for
a function f : X →S (it is a “renaming” arrow in Set), the arrow 𝒫(f) : 𝒫(X) →𝒫(S)
is a function such that for each Y ∈𝒫(X) (i. e., Y ⊆X), 𝒫(f )(Y) = {f(a) | a ∈Y}.
Consequently, any arrow g : X →𝒫(S) specifies the assignment of a subset Y ⊆S of
values to the elements a ∈X, so that this mapping in Set can be used to assign a set
of values to the multivalued attributes.
This powerset endofunctor is a monad (𝒫, η, μ) where μ is the set union operation
and ηX : X →𝒫(X) is a function, which assigns to each element a ∈X the singleton set
{a}. Thus, this assignment of values to the multivalued attributes can be equivalently
done by a morphism fT : X →S in the Kleisli category of this monad.
So, we need to define a “powerset” monad for the category DB. We need it to rep-
resent the p-functions (4.16), fqi = ⋃ℱqi : R1 × ⋅⋅⋅× Rk →𝒫(‖rB‖) with graph(fqi) =
⋃hi,j∈ℱqi graph(hi,j), of saturated morphisms from Lemma 4 and Example 25.
Proposition 27. Let us define the mapping P = (P0, P1) : DB →DB, such that for any
object A = {R1, . . . , Rn, ⊥} in DB and a morphism f = {f1, . . . , fm, q⊥} : A →B:
1.
P(A) = P0(A) =def ⋃Ri∈A{R ⋃⊥| R ∈𝒫(Ri)};
2.
P(f ) = P1(f ) =def isB ∘f ∘is−1
A : P(A) →P(B) where isB : B →P(B) and is−1
A :
P(A) →A are two isomorphisms in DB.
Then (P, η, μ) is a monad, where η : IdDB
󳐂? P is natural isomorphism, P2 = P,
and μ : P2
󳐂? P is the identity natural transformation. Thus, for each object A, ηA :
A →P(A) is an isomorphism and μA = ηP(A) = idP(A) : P(A) →P(A) is the identity
morphism for the object P(A).
Proof. For any RDB (a set of relational tables) A = {R1, . . . , Rn, ⊥}, such that each rela-
tion has the empty tuple as well, ⟨⟩∈Ri (note that ⟨⟩∈D−1 is not the empty set 0),
and we have that P(Ri) is the set of all subrelations R ⊆Ri such that ⟨⟩∈R and
P({⊥}) = {⊥} (where ⟨⟩is the empty tuple and 𝒫(⊥) = {0, ⊥}. From the fact that each
relation has the empty tuple ⟨⟩∈R, we have 𝒫(⊥) = {0, ⊥} ⊆𝒫(R)), so that P(A) is an
object in DB (we recall that each object A (an instance database) in DB has the empty
relation ⊥as well, so that between any two objects A and B we have at least the empty
morphism ⊥1 = {q⊥} : A →B). Let us show that for any A we have the isomorphism
A ≃P(A). In fact, P(A) can be seen as the set of all relations, which can be obtained
by only the selection operations of SPRJU relational algebra (SQL), while T(A) is the
set of all relations that can be obtained from A by using all operations in SPRJU, and
consequently, we have that P(A) ⊆T(A), so that A ⊆P(A) ⊆T(A), and consequently
by applying the power-view operation T, T(A) ⊆T(P(A)) ⊆T(T(A)) = T(A), i. e.,

250
|
4 Intensional RDB manifesto: flexible big data and NewSQL
T(P(A)) = T(A), and from the fact that in DB, A ≃B iff T(A) = T(B), we obtain the
isomorphism
ηA : A ≃P(A)
(4.18)
Let us represent this isomorphism [21] by the arrow isA = {idR : R →R | R ∈A} :
A →P(A). Thus, the information flux is ̃
isA = T(A) = T(P(A)), and hence (from
Proposition 8, [21]), this arrow is an isomorphic arrow in DB. Its inverse is as usual
is−1
A = {idR : R →R | R ∈A} : P(A) →A, so that is−1
A ∘isA = {idR : R →R | R ∈A} = idA :
A →A, and isA ∘is−1
A = idP(A) : P(A) →P(A) from the fact that the information flux
?
isA ∘is−1
A = ̃
isA ⋂̃
is−1
A = T(A) ⋂T(A) = T(A) = T(P(A)) = ?
idP(A),
and hence, (from [21], Definition 23), isA ∘is−1
A = idP(A).
Let us show that for each identity arrow idA = {idR : R →R | R ∈A} : A →A, we
have that P(idA) = isA ∘idA ∘is−1
A = isA ∘is−1
A = idP(A) = {idR : R →R | R ∈P(A)} :
P(A) →P(A). In fact, ?
idP(A) = T(P(A)) = T(A).
For the composition of two arrows f : A →B and g : B →C, we have that
P(g ∘f ) = isC ∘(g ∘f) ∘is−1
A = isC ∘g ∘idB ∘f ∘is−1
A
= isC ∘g ∘(is−1
B ∘isB) ∘f ∘isA
(from idB = is−1
B ∘isB)
= (isC ∘g ∘is−1
B ) ∘(isB ∘f ∘isA) = P(g) ∘P(f ).
So, P is a well-defined endofunctor. It is easy to verify that (P, η, μ) is a monad where
η : IdDB ≃P is a natural isomorphism. Thus for any object A, the arrow ηA = {idR :
R →R | R ∈A} : A →P(A) is an isomorphism in DB, so that its information flux is
̃
ηA = T(A), while for any A = {R1, . . . , Rn, ⊥},
(a) P(A) ⊆P(P(A)), because P is monotonic operation;
(b) For any relation, R′ ⋃⊥∈P(P(A)) = {R′ ⋃⊥| R′ ∈𝒫(R), R ∈P(A)} and from
R ∈P(A), we have that R ∈𝒫(Ri) for some Ri ∈A. Thus, from R′ ∈𝒫(R) and
R ∈𝒫(Ri), we have R′ ∈𝒫(Ri), and hence R′ ⋃⊥∈{R′ ⋃⊥| R′ ∈𝒫(Ri)} ⊆
⋃Ri∈A{R′ ⋃⊥| R′ ∈𝒫(Ri)} = P(A). Hence, P(A) ⊇P(P(A)).
Consequently, for (a) and (b), P(A) = P(P(A)). Thus, P is idempotent, so that μA :
P(P(A)) →P(A) reduces to μA : P(A) →P(A) and if we take μA = idP(A) (with the
information flux ̃
μA = ?
idP(A) = T(P(A)) = T(A)) the two monad diagrams (where μ is
the identity natural transformation) commute.
Notice that, for each relational database instance A (an object in DB), we have that
the “powerset” object P(A) is a database instance obtained from A by evaluation of
all selection operations over the relations in A, while the power-view object T(A) is a
database instance obtained from A by evaluation of all terms of the SPRJU relational

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
251
algebra over the relations in A. So, we have that A ⊆P(A) ⊆T(A) and, from the fact
that T is a monotonic and idempotent operator, T(A) ⊆T(P(A)) ⊆T(T(A)) = T(A).
Thus, T(A) = T(P(A)) and, from the fact that two objects in DB are isomorphic, A ≃B
iff T(A) = T(B), we obtain the isomorphism of this monad A ≃P(A) expressed by the
natural isomorphism (4.18), ηA = isA : A →P(A).
Next, we will present the denotational semantics for the multivalued attributes
based on this “powerset” monad in relational database category DB and its Kleisli
category.
Definition 53. Given a monad (T, η, μ) over a category C, we have [181]:
–
Kleisli triple is a triple (T, η, −∗), where for f : A 󳨀→T(B) we have f ∗: T(A) 󳨀→
T(B), such that the following equations hold: η∗
A = idT(A), f ∗∘ηA = f, g∗∘f ∗=
(g∗∘f)∗, for f : A 󳨀→T(B) and g : B 󳨀→T(C). A Kleisli triple satisfies the mono
requirement provided ηA is monic for each object A.
–
Kleisli category CT has the same objects as C category. For any two objects A,B,
there is the bijection between arrows θ : ⋃A,B∈C C(A, TB) 󳨀→⋃A,B∈C CT(A, B), such
that for f : A →TB in C, θ(f) : A →B is the corresponding arrow in CT. For
any two arrows fT : A 󳨀→B, gT : B 󳨀→C in CT, their composition is defined by
gT ∘fT =def θ(μC ∘T(θ−1(gT)) ∘θ−1(fT)).
A Kleisli category is a “minimal” solution to the problem of finding an adjunc-
tion, which induces the given monad (T, η, μ). This “minimal; adjunction CT ?FT
GT
? C
is defined by
–
The functor GT sends the object X to T(X) and fT : X →Y (which is θ−1(fT) : X →
T(Y) in C) to μY ∘T(θ−1(fT)) : T(X) →T(Y);
–
The functor FT is the identity on objects and sends f : X →Y to θ(ηY ∘f ) : X →Y
in CT.
Lemma 5. The Kleisli category DBP of the monad (P, η, μ) satisfies the following prop-
erty for any two morphisms f : A →B and g : B →C of the DB category:
θ(ηC ∘(g ∘f)) = θ(ηC ∘g) ∘θ(ηB ∘f ),
where θ is bijective mapping in Definition 53.
The Kleisli triple (P, η, −∗), where −∗is equal to the arrow component P1 of the
endofunctor P = (P0, P1), satisfies the mono requirement.
Proof. From the definition of composition of the arrows in the Kleisli category, we have
that θ(ηC ∘g)∘θ(ηB ∘f ) = θ(μC ∘P(θ−1(θ(ηC ∘g)))∘θ−1(θ(ηB ∘f ))) = θ(μC ∘P(ηC ∘g)∘ηB ∘f).
Thus, it is enough to demonstrate the equality of two arrows in DB:
ηC ∘g ∘f = μC ∘P(ηC ∘g) ∘ηB ∘f = μC ∘isC ∘(ηC ∘g) ∘is−1
B ∘ηB ∘f : X →P(C).

252
|
4 Intensional RDB manifesto: flexible big data and NewSQL
That is, they must have the same information fluxes. In fact, from ̃f ⊆T(A) ⋂T(B),
̃g ⊆T(B) ⋂T(C), ̃
ηC = ̃
isC = T(C), ̃
ηB = ̃
isB = ̃
is−1
B = T(B) and ̃
μC = ?
idP(C) = T(P(C)) =
T(C), we have
(a)
?
ηC ∘g ∘f = ̃
ηC ⋂̃g ⋂̃f = ̃g ⋂̃f ;
(b)
?
μC ∘isC ∘(ηC ∘g) ∘is−1
B ∘ηB ∘f = ̃
μC ⋂̃
isC ⋂(̃
ηC ⋂̃g) ⋂̃
is−1
B ⋂̃
ηB ⋂̃f = ̃g ⋂̃f.
Consequently, from (a) and (b) these two arrows have the same information flux in DB,
and hence they are equal arrows in DB.
The mono requirement for the monad (P, η, μ) [177] is satisfied because, by Propo-
sition 9 in 3.2.1 in [21], for each object A the arrow ηA : A 󳨀→P(A) is an isomorphism
ηA = isA (we denote its inverse by η−1
A ), and hence it is also monic. Moreover, the iso-
morphism ηP(A) = isP(A) : P(A) →P2(A) = P(A) is just the identity arrow idP(A) and
P(ηA) = isP(A) ∘ηA ∘is−1
A = idP(A) ∘ηA ∘is−1
A = ηA ∘is−1
A = isA ∘is−1
A = idP(A).
Thus if we substitute −∗with the arrow component P1 of the endofunctor P, we
have that η∗
A = P(ηA) = idP(A) satisfies the Kleisli triple. Also, for f : A →P(B),
f ∗∘ηA = P(f )∘isA = isP(B) ∘f ∘is−1
A ∘isA = idP(B) ∘f ∘idA = f is the satisfied Kleisli triple.
Let us show the last condition, (g ∗∘f )∗= P(P(g) ∘f) = (from functorial property) =
P2(g) ∘P(f ) = (from idempotence of P) = P(g) ∘P(f) = g∗∘f ∗.
Consequently, the category DB is a computational model for “powerset” computa-
tions of the sets of values for the multivaluedattributes as well, with the typed operator
P, so that:
–
P(A) is a type of computations, which are the views of the database A obtained by
ony selection operations over the relations in A.
–
ηA is the inclusion of values into computations (i. e., inclusion of relations of the
DB A into the set of views in P(A)). It is the isomorphism ηA = isA : A 󳨀→P(A).
Let us see now how the Kleisli category DBT is “internalized” into the DB category.
Theorem 7. The Kleisli category DBP of the monad (P, η, μ) is isomorphic to DB cate-
gory. That is, it may be “internalized” in DB by the faithful forgetful functor K = (K0, K1) :
DBP 󳨀→DB such that object-component K0 is an identity function and the arrow-
component K1 =def ϕθ−1 where, for any two objects A and B, we have the following
bijections of the hom-sets:
θ:
DB(A, P(B)) ≅DBP(A, B) is Kleisli bijection and
ϕ: DB(A, P(B)) ≅DB(A, B) such that ϕ( _ ) = η−1
cod( _ ) ∘( _ ) is a DB category bijection
respectively, where for any object A, η−1
A : P(A) →A is the isomorphism (inverse of
the isomorphism ηA).
Proof. We can use the same method as in [174], or in [21] (Section 8.4, Theorem 17), but
here we will use an alternative way based on the Kleisli adjunction DBP ?FT
GT
? DB.

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
253
In fact, in order to demonstrate the isomorphism of the Kleisli category DBP and
DB, we have to show that there are the natural transformations ν : IdDB
󳐂? GTFT
and ϖ : IdDBP
󳐂? FTGT whose components are all isomorphisms. In fact, from
GTFT = P we take the natural isomorphism ν = η of the monad (P, η, μ).
Let us show that for each object A, ϖA = θ(ηP(A) ∘ηA) : A →P(A) is an isomorphic
arrow in Kleisli category DBP. Let us consider a morphism f : A →B, its correspond-
ing arrow fT = θ(ηB ∘f ) : A →B and the ϖ diagram in DBP:
A
ϖA ? P(A) = FTGT(A)
B
fT = θ(ηB ∘f )
? ϖB
? P(B) = FTGT(B)
FTGT(fT)
?
Let us show that this diagram is commutative and that ϖA and ϖA are two isomor-
phisms in DBP. In fact, we have that (from Lemma 5),
(a) FTGT(θ(ηB ∘f )) ∘ϖA = θ(ηP(B) ∘μB ∘P(ηB ∘f )) ∘θ(ηP(A) ∘ηA) = θ(g1)
where g1 = ηP(B) ∘μB ∘P(ηB ∘f ) ∘ηP(A) ∘ηA is an arrow in DB with the information flux
̃
g1 =
?
ηP(B) ∘μB ∘P(ηB ∘f ) ∘ηP(A) ∘ηA =
?
ηP(B) ⋂̃
μB ⋂?
P(ηB) ⋂̃
P(f) ⋂?
ηP(A) ⋂̃
ηA =
̃
P(f) = ̃f.
(b) ϖB ∘θ(ηB ∘f ) = θ(ηP(B) ∘ηB) ∘θ(ηB ∘f) = θ(g2) (from Lemma 5)
where g2 = ηP(B) ∘ηB ∘f is an arrow in DB with the information flux
̃
g2 =
?
ηP(B) ∘ηB ∘f = ?
ηP(B) ⋂̃
ηB ⋂̃f = ̃f.
Thus, from (a) and (b), g1 = g2 : A →P(B) in DB, so that θ(g1) = θ(g2) : A →P(B) in
DBP, and hence the natural transformation diagram above commutes, so that ϖ is a
natural transformation. Let us show that its components are all isomorphisms. In fact,
for any object A, we have that T(A) = T(P(A)), i. e., A ≃P(A), and ϖA = A →P(A)
is just this isomorphism in DBP (notice that ϖA = θ(ηP(A) ∘ηA) and ηP(A) ∘ηA =
idP(A) ∘ηA = ηA is an isomorphism in DB).
Remark. Each arrow fT : A 󳨀→B in DBP is “internalized” in DB by its representation
f =def K1(fT) = ϕθ−1(fT) = ηOP
B ∘θ−1(fT) : A 󳨀→B, where θ−1(fT) : A 󳨀→TB is a program
equivalent to the database mapping f : A 󳨀→B, i. e., θ−1(fT) ≈f .
The functor K is faithful. In fact, for any two arrows fT, hT : A 󳨀→B in DBP,
K1(fT) = K1(hT) implies fT = hT: from K1(fT) = K1(hT), we obtain ϕθ−1(fT) = ϕθ−1(hT),
and if we apply a bijection ϕθ−1, we obtain ϕθ−1ϕθ−1(fT)
=
ϕθ−1ϕθ−1(hT), i. e.,
θθ−1(fT) = θθ−1(hT), i. e., fT = hT (the compositions θθ−1 and ϕϕ−1 are the identity
functions).

254
|
4 Intensional RDB manifesto: flexible big data and NewSQL
Let us consider a model α∗∈Mod(Sch(G)), derived from the Tarski’s interpreta-
tion IT (and the extensionalization function h for the intensional entities in IRDB such
that for a given intensional interpretation I, the extended Tarski’s interpretation is
I∗
T = h ∘I), of a given IRDB 𝒜. It defines the instance database A = α∗(𝒜) = {Ri = ‖ri‖ =
α(ri) =def IT(ri) = h(I(ri)) = h(nr(ri)) | ri ∈SA} of the RDB schema 𝒜= (SA, ΣA) (the rela-
tions ri in 𝒜are the intensional n-ary concepts (names) nr(ri), which the extension is
determined by h and Tarski’s constraints), and other two databases S = α∗(𝒮) = { ⃗A, ⊥}
(of the vector relation of the “source” database) with ⃗A = ‖rV‖ = α(rV) =def IT(rV), and
AMA = α∗(𝒜MA) = {‖rMA‖, ⊥} where ‖rMA‖ = α(rMA) =def IT(rMA) = h(nr(rMA)), which
contains the values for the multivalued attributes in schema 𝒜.
Notice that the integrity-constraint arrows in Sch(G) do not map the information
from source to target schema but only are used to verify if the given R-algebra α is a
model or not. The schema mappings M and MOP define the extension of the database
𝒜and corresponding vector relation
⃗A and contain only the built-in functions Hash
and list (fixed, thus independent on various Tarski’s interpretations).
Consequently, only the unary functional symbol f1 in the SOtgd of the mapping
MSAMA : 𝒮→𝒜MA can have different Tarski’s interpretations, with α∗(MSAMA) =
{hρV , q⊥} : α∗(𝒮) →α∗(𝒜MA), where from (4.15) we have the function hρV = α(qρV ) :
‖rV‖ →‖rMA‖, such that for each d = (nr(rk), ID, ai, d) ∈
⃗A = ‖rV‖ from (4.14),
hρV (d) =
{
{
{
{
{
(d, IT(f1)(d)),
if ai is a multivalued attribute of rk
and IT(f1)(d) is a value of this attribute
⟨⟩,
empty tuple otherwise
We can have different Tarski’s interpretations for f , which does not change the exten-
sion of the schemas in the mapping system in Sch(G) but can change the interpretation
(the graph) of the existentially quantified function f . Thus, we can produce the satu-
ration of the morphism h = α∗(MSAMA) = {hρV , q⊥} : α∗(𝒮) →α∗(𝒜MA), with the satura-
tion algorithm [186] provided in the previous section with Example 25 (here we have
that h1,0 = hρV ). Consequently, we are able to define the following particular saturated
morphism Sat(α∗(MSAMA)) in DB for a given model α ∈Mod(Sch(G)).
Corollary 15 (Kleisli semantics for MV-attributes). Let α∗∈Mod(Sch(G)) be a model
of the IRDB with schema 𝒜(of the graph G in Definition 52) for a given Tarski’s interpre-
tation IT, with A = α∗(𝒜), S = {‖rV‖, ⊥} = α∗(𝒮) and AMA = {‖rMA‖, ⊥} = α∗(𝒜MA). Then
we define the saturated morphism ℱρV = Sat(α∗(MSAMA)) : S →AMA in DB. Hence, the
Kleisli “powerset” semantics for the multivalued attributes are given by the following
arrow in the Kleisli category DBP:
θ(ηAMA ∘ℱρV ) : S →AMA,
which for SMA = π2(‖rMA‖) and SV = ‖rV WHERE a-name MULTIVALUED‖# defines
uniquely the extensionalization function h for the intensional elements in π4(SV) associ-

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
255
ated to the multivalued attributes of any tuple in database A: for any d ∈SV, and unary
concept obtained for multivalued attributes u = π4(d) ∈D1,
h(u) =def π2{h1,i(d)
̸= ⟨⟩| h1,i ∈ℱρV , h1,i
̸= id⊥} ∈𝒫(SMA)
(4.19)
For any intensional element, u ∈π4(SV) is defined for a multivalued attribute ai
of some tuple ID in a given relation rk in the database instance A = α(𝒜), which is a
model of IRDB 𝒜represented by mapping system in the graph G. We have:
1.
The tuple d = ⟨nr(r4), ID, ai, u⟩in ‖rV‖ = α(rV) with unary concept u ∈D1;
2.
The set of values h(u) = X with cardinality n = |X| ≥1 corresponds to the set of
values of this multivalued attribute for the tuple d above.
3.
We have only to show that h(u) is completely covered by the functions in ℱρV : it
is easy to verify from the generation of saturated morphism, as is shown in next
Example 27.
The derived arrows ℱρV = {h1,i | h1,i ∈Sat(α(MSAMA))} in DB are saturated morphisms,
obtained from the sketch’s arrow MSAMA = {qρV , 1r0} : 𝒮→𝒜MA, because generally they
are not images of any functor α∗of the schema mapping MSAMA.
From such a saturated morphism, we can define the p-function (4.16),
fqρV =def ⋃ℱρV : α(rV) →𝒫(α(rMA)),
with graph(fqρV ) =
⋃
hi,j∈ℱρV
graph(hi,j)
This p-function represents the 1:N relationship between the relation rV and rMA, and
we have for the extensionalization function h that h(u) = π2(fqρV (u))\{⟨⟩}.
Example 27. : Let us consider the continuation of Example 25, for a model α of the
schema 𝒜, which contains the vector relation ⃗A = ‖rV‖ = α(rv) = IT(rV), obtained by
parsing all user’s relations, thus also the relation R1 = α(Contacts) in Example 25. So,
by parsing the tuple dC = (132, Zoran, Majkic, Appia, 0187, hobbies_of_132) ∈R1, we
have
‖rV‖ ⊇
r-name
t-index
a-name
value
. . .
. . .
. . .
. . .
Contacts
ID132
hobbies
hobbies_of_132
. . .
. . .
. . .
. . .
where ID132 = Hash(dC), and ‖rMA‖ = α(rMA) = IT(rMA) with ρV mapping corresponding
to the SOtgd (4.11)
∃f1(∀x1, . . . , ∀x4((rV(x1, x2, x3, x4) ∧x3 MULTIVALUED) ⇒rMA(x4, f1(x4)))).
Let SV = ‖rV WHERE a-name MULTIVALUED ‖# ⊆‖rV‖. The hobbies are a multivalued
attribute of the relation Contacts, so we have for the tuple

256
|
4 Intensional RDB manifesto: flexible big data and NewSQL
d = (Contacts, ID132, hobbies, hobbies_of_132) ∈SV ⊆‖rV‖,
and
‖rMA‖ ⊇
value
atom-value
. . .
. . .
hobbies_of_132
photography
hobbies_of_132
music
hobbies_of_132
art
hobbies_of_132
travel
. . .
. . .
where from (4.9) in Section 4.3.1,
u = hobbies_of_132 = g∗(⋖hobbies(x1, y)⋗x1
y )) = I(hobbies(132, y)) ∈D1 ⊂𝒟
is the intensional unary concept in the IRDB such that, from I∗
T (hobbies(132, y)) =
{photography, music, art, travel} and I∗
T = h ∘I, we obtain
h(u) = h(hobbies_of_132) = {photography, music, art, travel}
(4.20)
where h is the extensionalization function corresponding to the Tarski’s interpretation
IT and derived functor α∗. Let for Tarski’s model IT from which α is uniquely derived,
the function IT(f1) : 𝒟→𝒟satisfies IT(f1)(u) = music, and hence
h1,0(d) = α(qρV )(d) = (u, IT(f1)(u)) = (u, music) ∈‖rMA‖.
Consequently, from step 6 of Saturation algorithm and relation R in point (b) of Ex-
ample 25, in step 7 of the algorithm will be introduced the three new functions h1,j :
‖rV‖ →‖rMA‖, for each tuple b ∈R, into Sat(α∗(MAB)) so that, for u = hobbies_of_132,
h1,1(d) = (u, photography),
with I′
T(f1)(u) = photography;
h1,2(d) = (u, travel),
with I′′
T (f1)(u) = travel;
h1,3d) = (u, art),
with I′′′
T (f1)(u) = art,
so, from the saturation algorithm we obtain
ℱρV = Sat(α(MSAMA)) ⊃{h1,0, h1,1, h1,2, h1,3, id⊥}
and derived p-function (4.16), fqρV = ⋃ℱρV : α(rV) →𝒫(α(rMA)), with

4.4 Kleisli semantics for intensional RDB with multivalued attributes
|
257
fqρV (d) = fqρV (Contacts, ID132, hobbies, hobbies_of_132)
=
value
atom-value
hobbies_of_132
art
hobbies_of_132
photography
hobbies_of_132
music
hobbies_of_132
travel
and, from (4.19) in Corollary 15, we obtain
π2{h1,i(d)
̸= ⟨⟩| h1,i ∈ℱρV , h1,i
̸= id⊥}
= {photography, music, art, travel} = h(u) ∈𝒫(SMA),
from (4.20),
where SMA = π2(‖rMA‖).
Hence, the denotational semantics of database mappings are given by morphisms
of the Kleisli category DBT, based on the fundamental (from Universal algebra) monad
(power-view endofunctor) T, here instead the “powerset” endofunctor T = P : DB →
DB. The big data integration framework presented in [21] considers only the standard
RDBs with Tarskian semantics of the FOL, where one defines what it takes for a sen-
tence in a language to be true relative to a model.
Thanks to the intensional semantics, different from the ordinary RDBs multival-
ued framework, which cannot directly support the multivalued attributes, here we ob-
tained a natural support for such a direct “reification-based” property. In this section,
we demonstrated both facts, that DB is able to support the intensional extension of
the FOL and that the semantics of the intensional elements, which express the multi-
valued attribute properties can be done by the morphisms in DB derived from the data
integration mapping graph used to define the canonical models of the IRDBs.
We defined the particular “powerset” monad P for DB and demonstrated that
the denotational semantics of the intensional elements used for the multivalued at-
tributes can be given by particular saturated arrows of the Kleisli category DBP, which
may be “internalized” in DB category as multivalued attribute “computations.” In this
way, we obtained an algebraic denotational semantics for the data integration (de-
fined by logic formulae with second-order logic tgds) used to support the IRDB man-
agement system.
With this, we obtained a full theoretical model for the new IRDBs, and opened
the door and the opportunity for their concrete industrial developments and future
implementations, which what was primary objective of the initial IRDB Manifesto in
2014 [20].

5 Theory of many-valued intensional first-order logic
5.1 Introduction to many-valued logics
Many-valued logic was conceived as a logic for uncertain, incomplete and possibly
inconsistent information, which is very close to the statements containing the words
“necessary” and “possible,” i. e., to the statements that make an assertion about the
mode of truth of some other statement. Algebraic semantics interpret modal connec-
tives as operators, while Relational semantics uses relational structures, often called
Kripke models, whose elements are thought of variously as being possible worlds; for
example, moments of time, belief situations, states of a computer, etc. The two ap-
proaches are closely related: the subsets of relational structures from an algebra with
modal operators, while conversely any modal algebra can be embedded into an alge-
bra of subsets of a relational structure via extensions of Stone’s Boolean representa-
tion theory. For example, the first (1934) and the most known Stone’s representation
theorem for Boolean algebras [187], is the duality between the category of Boolean al-
gebras and the category of Stone spaces. Every Boolean algebra (BA, +, ⋅, \, 0, 1), where
+, ⋅, \ are corresponding algebraic operations (addition, multiplication and comple-
ment) for classical logic connectives ∨, ∧, ¬, respectively, is isomorphic to an algebra
of particular clopen (i. e., simultaneously closed and open) subsets of its Stone space.
Stone’s theorem has since been the model for many other similar representation the-
orems.
Our new representation theorem provided in next section, in the case of distribu-
tive complete lattice of truth values, is a particular Stone-like autoreferential represen-
tation based on the particular subsets of these truth values.
The representation theorems are based on Lindenbaum algebra of a logic ℒ=
(Var, 𝒪, ⊪), where Var is a set of propositional symbols of a language ℒ(denoted by
p, q, . . .), 𝒪is the set of logical connectives and ⊪is the entailment relation of this
logic. We denote by F(ℒ) the set of all formulae denoted by ϕ, ψ, φ . . . Notice that the
truth values in X ⊂Var ⊆F(ℒ) are the constant propositional symbols as well, and
we will use the same symbols for them as those used for elements in lattice (X, ≤),
with the bottom and top elements 0, 1, respectively. Lindenbaum algebra of ℒis the
quotient algebra F(ℒ)/ ≡, where for any two ϕ, ψ ∈F(ℒ), it holds that ϕ ≡ψ iff ϕ ⊪ψ
and ψ ⊪ϕ.
Remark. It is necessary to have clear in mind the difference between a many-valued
logic and its underlying algebra of truth values (e. g., the propositional logic and its
Boolean algebra, the intuitionistic logic and its Heyting algebra), so that we can in-
formally use the term lattice (of algebraic truth values) speaking about logics as well.
Next, for a many-valued logic with standard connectives ¬, ∧and ∨, the corresponding
algebraic operator in (X, ≤) will be usually denoted by ∼: X →X and ̃∧, ̃∨: X2 →X,
relatively.
https://doi.org/10.1515/9783110981438-005

5.1 Introduction to many-valued logics
|
259
A valuation v as a mapping v : Var →X such that for any x ∈X, v(x) = x. It can
be uniquely extended to the homomorphism from the absolutely free syntax algebra
to the many-valued algebra v∗: (F(ℒ), {o}o∈𝒪) →(X, {̃o}o∈𝒪) (i. e., for any ϕ, ψ ∈F(ℒ),
v∗(ϕ ⊙ψ) = v∗(ϕ) ⊛v∗(ψ), where ⊙∈{∧, ∨, ⇒} and corresponding algebraic operators
⊛∈{̃∧, ̃∨, 󴁃󴀢} relatively, v∗(¬ϕ) =∼v∗(ϕ), and v∗(◊iϕ) = ̃oi(v∗(ϕ)), where ∧, ∨, ⇒, ¬, ◊i
are conjunction, disjunction, implication, negation and existential logic modal oper-
ator, respectively). The set of logic universal modal operators will be denoted by the
standard way ◻i ∈𝒪. We denote by 𝕍the set of all valuations v : Var →X.
The algebraic existential modal operators oi : X →X, i = 1, 2, . . . , are monotonic,
additive (oi(x̃∨y) = oi(x)̃∨oi(y)) and oi(0) = 0 (the universal modal operators are mono-
tonic and multiplicative oi(x̃∧y) = oi(x)̃∧oi(y), oi(1) = 1). They appear often in many-
valued logics, e. g., as a conflation operator (knowledge negation [188]) and Moore’s
autoepistemic operator [189] in Belnap’s 4-valued bilattice [190], or modal operators
L and M of Lukasiewicz’s 4-valued logic [79, 81, 191], or recently in [192–195].
A many-valued modal logic here is a truth-functional many-valued logic with a
non-empty set of modal operators with properties defined above.
Relevant work
We will briefly present the previous work, based on algebraic matrices, and explain
some weak points of such a matrix-based approach.
The standard approach to representation theorems uses a subset D ⊂X of the
set of truth values X, denominated designated elements; informally the designated
elements represent the equivalence class of the theorems of ℒ. Given an algebra A =
(X, {o}o∈𝒪), the 𝒪-matrix is the pair (A, D), where D ⊂X is a subset of designated ele-
ments. The algebraic satisfaction relation 󳀀󳨐a (“a” stands for “algebraic”) is defined as
follows.
Definition 54. Let ℒ= (Var, 𝒪, ⊪) be a logic, M = (A, D) a 𝒪-matrix and ϕ ∈F(ℒ).
Let v : Var →X be a map that assigns logic values to propositional variables, and
v∗: F(ℒ) →X be its unique extension to all formulae in a language ℒ. Let M be a
class of 𝒪-matrices. We define the relation 󳀀󳨐a inductively as follows:
1.
(A, D) 󳀀󳨐a
v ϕ iff v∗(ϕ) ∈D,
2.
(A, D) 󳀀󳨐a ϕ iff v∗(ϕ) ∈D for every v : Var →X,
3.
M 󳀀󳨐a ϕ iff (A, D) 󳀀󳨐a ϕ for every (A, D) ∈M.
A logic ℒis sound w. r. t. M iff for every ϕ ∈F(ℒ), if ℒ⊪ϕ then M 󳀀󳨐a ϕ.
ℒis complete w. r. t. M iff for every ϕ ∈F(ℒ), if M 󳀀󳨐a ϕ then ℒ⊪ϕ.
Dual to algebraic semantics, based on the class M of 𝒪-matrices we also have the
Kripke-style semantics based on a class ℛof relational models where the satisfiability
relation 󳀀󳨐r is defined by induction on the structure of the formulae. Substantially, each

260
|
5 Theory of many-valued intensional first-order logic
relational model K ∈ℛis a Kripke frame over a set of possible worlds with additional
accessibility relations between possible worlds associated with logical operators. The
distinctive feature of this relational semantics is that the accessibility relations are
used in the definition of satisfiability, which is not just a mechanical truth-functional
translation of the formula structure into the model.
The definition of the algebraic/relational duality is based on the following as-
sumption.
Definition 55 (Representation assumption [196]). Assume that there exists a class ℛ
of relational structures such that there exist 𝔻: M →ℛ, 𝔼: ℛ→M such that (C):
(i)
for every K ∈ℛ, 𝔼(K) = (AK, DK) ∈M, where AK = (XK, {oK}o∈𝒪) is an algebra of
subsets of the support 1K (possible worlds) of K, i. e., with XK ⊆𝒫(1K);
(ii) for every M = (A, D) ∈M, if 𝔼(𝔻(M)) = (A𝔻(M), D𝔻(M)) then there is an injective
homomorphism in : A →A𝔻(M) with i−1
n (D𝔻(M)) ⊆D.
Let m : Var →XK be a meaning function (assigns logic values to propositional
variables), then (K, m) is the Kripke model for a Kripke-frame K = (1K, {Rj}j≤n) where 1K
is the set of possible worlds, {Rj}j≤n a finite set of accessibility relations between them
(relational structure). Then the definition of the relation 󳀀󳨐r can be given as follows.
Definition 56 ([196]). Assume that M and ℛsatisfy condition (C)(i). Let 𝒦∈ℛ, m :
Var →XK with XK ⊆𝒫(1K), and m∗: F(ℒ) →XK be its extended unique homomor-
phism of 𝒪-algebras. Let y be an element in the support of K. Then for y ∈1K:
1.
K 󳀀󳨐r
m,y ϕ iff y ∈m∗(ϕ);
2.
K 󳀀󳨐r
m ϕ iff m∗(ϕ) ∈DK;
3.
K 󳀀󳨐r ϕ iff for every m, K 󳀀󳨐r
m ϕ,
where ‖ϕ‖ = m∗(ϕ) is the set of possible worlds in 1K where ϕ is satisfied.
A logic ℒis sound w. r. t. ℛiff for every ϕ ∈F(ℒ), if ℒ⊪ϕ then ℛ󳀀󳨐r ϕ. ℒis
complete w. r. t. ℛiff for every ϕ ∈F(ℒ), if ℛ󳀀󳨐r ϕ then ℒ⊪ϕ.
In [196], it is demonstrated that if ℒ= (Var, 𝒪, ⊪) is sound and complete w. r. t.
a class M of 𝒪-matrices, and there exists a class ℛsuch that the Assumption (C) holds,
then ℒis sound and complete w. r. t. the class of Kripke-style models 𝒦ℳ,ℛ= {(K, m) |
K ∈ℛ, m : Var →XK where 𝔼(K) = (AK, DK)}. The strong and weak points of this
approach:
–
In a matrix-based many-valued logic, a formula is satisfied if its logic value is a
designated value. Such an approach, based on 𝒪-matrices, is very effective for
all kinds of 2-valued logic where the set of designated elements is a singleton set
composed by only true value, D = {1}, as in the case of classical, intuitionistic and
2-value modal logics (extension of Boolean algebra). It is only a partially good
solution for the case when a set of truth values cannot be easily divided into two
complementary subsets: D ⊂X for values for which we retain that a formula can

5.1 Introduction to many-valued logics
|
261
be considered satisfied, and its complement X\D for those, which we retain that
a formula cannot be considered satisfied. This difficulty can be found in the case
of bilattices [188, 197–202].
–
The second observation is that the representation theorems define the isomor-
phism between a many-valued algebra and the set-based algebra that is a subalge-
bra of the canonical extension of the original many-valued algebra. It will be use-
ful to define directly such an isomorphism based on the duality assumption (C).
In next section, we provide a new general representation theorem for many-valued log-
ics with the truth-invariance entailment for any set of truth values X. It is substantially
different w. r. t. the previous representation theorems that are all based on matrices,
and is based on algebraic models of a logic.
For example, in the case of logic programs, let v : Var →X be a many-valued
valuation, and (X, ≤) be the set X of logic values with partial truth order ≤. Then, given
any rule B ←B1 ∧⋅⋅⋅∧Bn where B is a propositional letter and Bi is a ground literal
(propositional letter or negation of them), we say that it is satisfied iff v(B) ≥v(B1) ∧
⋅⋅⋅∧v(Bn); the valuation that satisfies all rules is a model for such a logic program.
As we have seen in this case, instead of the subset D ⊆X of designated elements, we
simply use the truth ordering between logic values.
The simple way to extend this example to any propositional logic ℒ= (Var, 𝒪, ⊩) is
to consider equivalently this logic as a sequent system of (structural and logical) rules
s1,...,sk
s
where each si is a sequent ϕ1, . . . , ϕn ⊢ψ where, accordingly to Gentzen,1 the
commas in the left are conjunctions and ϕi, ψ ∈F(ℒ) are logic formulae. Notice that
this sequent-based approach is always possible, independently of the algebraic prop-
erties of the set of truth values in X, e. g., by transforming the original many-valued
logic into 2-valued modal logic [203, 204], and defining the classical 2-valued sequent
rules as presented in [205] with the truth-preserving entailment for many-valued log-
ics.
Definition 57 (New truth-preserving entailment). Let Γ = {ϕ1, . . . , ϕn} be a set of sen-
tences and we define the truth-preserving entailment in two alternative cases:
1.
Sequent-based entailment with sequents Γ ⊢ψ. We say that a valuation v :
Var →X satisfies this sequent iff v∗(ϕ1) ⋀⋅⋅⋅⋀v∗(ϕn) ≤v∗(ψ1), where ⋀is
the meet operator in lattice (X. ≤), and we denote this sequent satisfaction by
Γ 󳀀󳨐v ψ. A sequent is valid (an axiom) in (X, ≤) if it is satisfied for all valuations in
(X, ≤).
We denote by ϕ ⪯ψ iff for all homomorphisms v ∈𝕍, v∗(ϕ) ≤v∗(ψ).
Valuation v satisfies a rule s1,...,sk
s
iff v satisfies the conclusion sequent s of this rule
whenever it satisfies all sequent premises s1, . . . , sk of this rule. Then a model of
1 Our attention to singular Genzen systems (the sequents with exactly one sentence on the right side)
is less restrictive than it seems (compare Belnap’s “Display logic”).

262
|
5 Theory of many-valued intensional first-order logic
this logic is any valuation v, which satisfies all logic sequent rules of this logic (the
structural sequent rules as Cut, Weakening, etc. are satisfied by all valuations).
2.
Model-based entailment where Γ is the set of theses ϕi with associated prefixed
bottom-truth values ai ∈X, such that their models are defined as a subset of all
valuations:
𝕍Γ =def {v ∈𝕍| ∀ϕi ∈Γ.(v∗(ϕi) ≥ai)}
(5.1)
So, we introduce the model-based truth-preserving entailment of a sentence ψ
from the theses in Γ by
Γ 󳀀󳨐ψ
iff
(∃ϕi ∈Γ).(∀v ∈𝕍Γ).(v∗(ψ) ≥v∗(ϕi))
(5.2)
Different from an arbitrary fixing of the set of designated truth-values D (with the
introduction of possible errors for complex nontotally-ordered lattices), the idea of
truth-preserving entailment is a deep concept underlying many-valuedness valid for
classic 2-valued logics (with ai = 1 for all thesis) as well.
So, we can replace the duality algebras (matrices)-relational structures described
in the previous work, by the semantic duality algebraic models—Kripke models. The
examples by using Gentzen-like sequent calculi [205] to obtain the set of models of a
given logic, without using necessarily the subset of designated elements (matrices),
are provided in Section A.3.1 (with Example 44 and truth-preserving entailment in Def-
inition 102) and in Section A.4.3 by Definition 124. The example in Section A.3.1, when
X is a complete distributive lattice, is used in Section A.3.2 for a concrete definition
of Kripke frames based on an autoreferential assumption [69] where the set of possi-
ble worlds is fixed by a subset of algebraic truth values in X. The strict autoreferential
Kripke semantics of a many-valued logic is that the set of possible worlds 𝒲is the set
of truth values in the lattice (X, ≤), and that for a given valuation v each formula is
satisfied only in the world w = v∗(ϕ), or formally we have the following.
Definition 58 (Strict autoreferential Kripke semantics). For
a
given
propositional
many-valued logic ℒwith absolutely free syntax algebra 𝒜L = (F(ℒ), {oi}oi∈𝒪) and
corresponding algebra of truth-values A = (X, {̃oi}oi∈𝒪), we define the Kripke frame
K = (𝒲, {Roi}oi∈𝒪) with 𝒲= X and the accessibility relations:
1.
For each unary logic connective, oi ∈𝒪, Roi = {(̃oix, x) | x ∈𝒲};
2.
Fore each binary logic connective, oi ∈𝒪, Roi = {(x̃oiy, x, y) | x ∈𝒲}.
A Kripke model ℳ= (K, IK) with mapping IK : Var ×𝒲→2 defines the Kripke sat-
isfaction relation 󳀀󳨐w, for a given world w ∈𝒲by ℳ󳀀󳨐w p iff IK(p, w) = 1 for each
p ∈Var ⊆F(ℒ), and for any ϕ, ψ ∈F(ℒ), for unary and binary logic connectives,
respectively, by:
1.
ℳ󳀀󳨐w oiϕ iff ∃y(w, y) ∈Roi such that ℳ󳀀󳨐y ϕ;
2.
ℳ󳀀󳨐w ϕoiψ iff ∃y, z(w, y, z) ∈Roi such that ℳ󳀀󳨐y ϕ and ℳ󳀀󳨐z ψ.

5.1 Introduction to many-valued logics
|
263
This Kripke semantics is strictly autoreferential if, for a given valuation v : Var →X,
the mapping IK : Var ×𝒲→2, for each proposition p ∈Var ⊆F(ℒ) and x ∈𝒲, it
holds that IK(p, x) = 1 iff x = v(p).
So, we obtain the following simple property of strict autoreferential semantics.
Corollary 16. For any formula ϕ ∈F(ℒ) and possible world x ∈𝒲from Definition 58,
for strict autoreferential semantics we obtain that
ℳ󳀀󳨐x ϕ
iff
x = v∗(ϕ)
(5.3)
Proof. For each proposition p, it holds directly from Definition 58. Let it holds for
any ϕ. Then by structural induction on number of connectives it holds in both cases,
for unary and binary logic connectives from Definition 58.
In what follows, we denote by y < x iff (y ≤x and not x ≤y), and we denote by
x ⋈y two unrelated elements in X (so that not (x ≤y or y ≤x)).
5.1.1 Nonmatrix based representation theorem for many-valued logics
Based on the considerations of truth-preserving entailment in Definition 57 in the pre-
vious section, we intend to define an algebraic/relational duality in the way that we
do not need to define a subset of designated elements D of a many-valued algebra. Let
v : Var →X be a given many-valued model of the logic ℒ, extended homomorphically
to v∗: F(ℒ) →X to the set of all formulae F(ℒ), then we can use the algebraic model
(A, v), instead of o-matrices (A, D). Let Γ be a set of sentences (or sequents) of ℒ. The
intuitive idea is to use the models 𝕍Γ ⊂𝕍of the logic ℒ(notice that all v ∈𝕍Γ satisfy
each sentence (or sequent) in Γ, and that the representation theorem is interesting
only for logics that have at least one model, i. e., when 𝕍Γ is not empty).
In what follows, we will consider a bounded lattice (X, ≤, ∧, ∨, 0, 1) of truth values
for this many-valued logic, and {oi}oi∈𝒪the set of functions oi : Xn →X (with arity
n ≥1) assigned to operation names in 𝒪of the logic ℒ= (Var, 𝒪, ⊪). We assume
that the carrier set of every algebra for a logic ℒcontains also a set of propositional
variables in Var, so that the terms of an algebra A = (X, {o}o∈𝒪) are the terms with
variables in Var. Consequently, any pair (A, v) can be seen as a ground term algebra
obtained by assigning to Var the values in a model v of ℒ.
Thus, the algebraic satisfaction relation 󳀀󳨐a will be relative to a model v of the logic
ℒinstead of the prefixed set of elements in D. In fact, from the strict autoreferential
semantics in Definition 58, we can write the satisfaction (A, v) 󳀀󳨐a
x ϕ of the formula ϕ
at world x ∈X to be an algebraic analog to the Kripke satisfaction in (5.3), ℳ󳀀󳨐x ϕ (iff
x = v∗(ϕ)).
For example, in the case of a logic program ℒwe can use the Fitting’s 3-valued
fixed- point operator to obtain its well-founded 3-valued model. Here, we will apply

264
|
5 Theory of many-valued intensional first-order logic
the truth-preserving entailment principle in Definition 57, which is a conservative ex-
tension of the definition for classic 2-valued logic, the idea originally used to define
the inference closure in the bilattice based logics [203], and used to develop a new
sequent system for many-valued logics presented in [205] as well.
In any case, in the representation theorem framework we are interested in estab-
lishing what is a canonical isomorphic algebra for a logic ℒ, and its relationship with
Kripke relational structures. So, we can use models v ∈𝕍Γ of a logic ℒonly as a means
to obtain these results. Now we can introduce a new definition of the algebraic/rela-
tional duality, where instead of a class of 𝒪-matrices (A, D), we will consider a class of
models of the same given algebra A, as follows [206].
Definition 59 (New representation assumption). Let, for a fixed algebra A = (X, ∧, ∨,
{oK}o∈𝒪), M be a class of all algebraic models (A, v) (of all valuations v which are
models for a given logic ℒ), and for this algebra A there exists corresponding fixed
Kripke-frame K = (1K, {Rj}j≤n), where 1K is the set of possible worlds and {Rj}j≤n a fi-
nite set of accessibility relations between them (relational structure) and we denote
by 𝒦ℳa class of Kripke models of the same logic ℒfor this fixed frame.
Then assume that there exists a mapping 𝔻: M →𝒦ℳ, such that (K, IK) =
𝔻(A, v) ∈𝒦ℳ, with a mining mapping IK : Var ×1K →2 and there exists a mapping
𝔼: 𝒦ℳ→M+, where M+ is a class of set-based algebraic models of ℒsuch that:
(i)
for every Kripke model ℳ= (K, IK) ∈𝒦ℳof ℒ, the (AK, vK) = 𝔼((K, IK)) ∈M is
an algebraic model of ℒ, where AK = (XK, ⋂, ⋃, {oK}o∈𝒪) with XK ⊆𝒫(1K) is an
algebra of subsets of the support 1K of K with a set-valuation vK : Var →XK such
that for each formula ϕ in ℒ, v∗
K(ϕ) = {w ∈1K | I∗
K(ϕ, w) = 1};
(ii) for every algebraic model M = (A, v) ∈M of ℒ, the (K, IK) = 𝔻(M) is a Kripke
model, so that if 𝔼(𝔻(M)) = (AK, vK), then there is a injective mapping in :
X 󳨅→XK, such that vK = in ∘v : Var →XK.
A representation is autoreferential when 1K ⊆X.
Example 28. Thus, for an original algebraic model (A, v) with the strict autoreferential
Kripke model (with possible worlds 1K = 𝒲= X) in Definition 58 when for each
x ∈X, in(x) = {x}, for the set-based (complex) algebra (AK, vK) = 𝔼(𝔻(A, v)) with
XK = {{x} | x ∈X} ⊆𝒫(1K), for any formula ϕ, we have from (5.3) that ‖ϕ‖ = {x | ℳ󳀀󳨐x
ϕ} = {v(ϕ)} = v∗
K(ϕ), which is a singleton, and hence the ∧operation in A cannot be
represented by the set intersection operation ⋂in AK, and hence such Kripke models
do not satisfy the new representation assumptions. Let us consider instead another
examples that satisfy representation assumptions:
Case A: Let us consider the standard propositional logic ℒ= (Var, 𝒪, ⊪), where 𝒪=
{∧, ¬} and its simple Boolean algebra A = (X, ≤, ̃∧, ∼), where X = 2 = {0, 1} with logic
operators “and,” ∧, and logic negation ∼, respectively, with 0 ≤1. Let us take 1K =
X = {0, 1} = 2, so that the canonical representation of the Boolean algebra A is the

5.1 Introduction to many-valued logics
|
265
powerset algebra AK = (XK, ⊆, ⋂, ¬+), with XK ⊆𝒫({0, 1}) and ¬+0 = ¬+{0} =def {0, 1}
and ¬+{1} = ¬+{0, 1} =def {0} and with injection in : {0, 1} 󳨅→𝒫({0, 1}). We can define
that in(0) = {0} and in(1) = {0, 1}, and hence, from vk = in ∘v, for any p ∈Var, v(p) = 1
iff vK(p) = {0, 1} and v(p) = 0 iff vK(p) = {0}.
Case B: Let us consider the 4-valued Belnap’s distributive bilattice X = ℬ4 = {f, ⊥, ⊤, t}
in the next Section 5.1.3, with ⊥for unknown and ⊤for inconsistent logic value, f = 0,
t = 1 are bottom and top values w. r. t. the truth ordering 0 ≤⊥, 0 ≤⊤, ⊥≤1, ⊤≤1
and ⊥⋈⊤. It is the smallest many-valued logic capable of dealing with incomplete (un-
known) and inconsistent logics. In this case, we can take 1K = {0, ⊥, ⊤} ⊂X, with in-
jection in : (X, ≤, ̃∧, ̃∨) 󳨅→(XK, ⊆, ⋂, ⋃) where XK ⊆𝒫(X), such that: in(0) = {0}, in(⊥) =
{0, ⊥}, in(⊤) = {0, ⊤}, 1K = in(1) = {0, ⊥, ⊤}.
In this new definition, we replaced the old duality algebras-relational structures
by the semantic duality algebraic models—Kripke models of a logic ℒ.
Notice that in the definition above, we do not require the injection in to be an in-
jective homomorphism, as in Definition 55, but we require that the following diagram
commutes (here idXK is the identity mapping for XK):
Var
v
? X ? v∗
F(ℒ)
XK
vK
?
idXK ? XK
in
?
?idXK
XK
v∗
K
?
Now, from the fact that in new representation assumption in Definition 59 instead of
𝒪-matrices with subsets of designated truth values D, we used only the models of al-
gebras (valuations), we need also the new definition of algebraic and Kripke-frame
satisfaction relations that do not use more the subsets of designated truth values. The
algebraic satisfaction relation 󳀀󳨐a is defined as follows.
Definition 60. Let ℒ= (Var, 𝒪, ⊪) be a logic with a tautology ⊤, M = (A, v) ∈M be an
algebraic logic model of a logic ℒ, defined by a many-valued valuation v : Var →X,
and ϕ ∈F(ℒ), and v∗: F(ℒ) →X be its unique standard extension to all formulae in a
language ℒ.
Assume that M and 𝒦ℳsatisfy the assumptions in Definition 59 with (AK, vK) =def
𝔼(𝔻(A, v)) so that AK = (XK, ⊆, {oK}o∈𝒪) and vK = in ∘v : Var →XK. We define the
algebraic satisfaction relation 󳀀󳨐a as follows, for x ∈X:
1.
(A, v) 󳀀󳨐a
x ϕ iff x = v∗(ϕ)
2.
(A, v) 󳀀󳨐a ϕ iff v∗
K(ϕ) = v∗
K(⊤)
3.
M 󳀀󳨐a
x ϕ iff (A, v) 󳀀󳨐a
x ϕ for every (A, v) ∈M.
4.
M 󳀀󳨐a ϕ iff (A, v) 󳀀󳨐a ϕ for every (A, v) ∈M.

266
|
5 Theory of many-valued intensional first-order logic
We define the entailment relation of a logic ℒby:
for every ϕ ∈F(ℒ), x ∈X,
ℒ; x ⊪ϕ
iff
M 󳀀󳨐a
x ϕ.
Analogously, for the set-based algebraic models in M+ =def {𝔻(𝔼(A, v)) | (A, v) ∈M},
we define algebraic satisfaction for each set S = in(x) ∈XK, by:
1+. (AK, vK) 󳀀󳨐a
S ϕ iff S = v∗
K(ϕ)
2+. (AK, vK) 󳀀󳨐a ϕ iff v∗
K(ϕ) = v∗
K(⊤)
3+. M+ 󳀀󳨐a
S ϕ iff (AK, vK) 󳀀󳨐a
S ϕ for every (AK, vK) ∈M+.
4+. M+ 󳀀󳨐a ϕ iff (AK, vK) 󳀀󳨐a ϕ for every (AK, vK) ∈M+.
Notice that in this definition, analogous to Definition 54, we do not use the set of
designated values D, and we are able to determine which set of formulae is deduced for
each algebraic logic value x ∈X. It is a generalization of classical deduction, where
ℒ⊪ϕ is equivalent to this new definition ℒ; 1 ⊪ϕ and ℒ⊪¬ϕ are equivalent to
ℒ; 0 ⊪ϕ (i. e., ℒ; 1 ⊪¬ϕ). The inference of ϕ defined by Definition 54, based on set D
of designated values, can be expressed from this more accurate definition above by:
there exists x ∈D such that ℒ; x ⊪ϕ, i. e., “it is valid that ϕ has the truth value x.” In
the case when x = 1, this is classical validity for a formula ϕ when M 󳀀󳨐a ϕ.
Thus, this new entailment relation ⊪given by Definition 60 is more powerful and
more general than the entailment relation of ℒgiven by Definition 54. Notice that if
𝒢is a sequent theory for ℒ, then ℒ; x ⊪ϕ iff ∀v ∈𝕍Γ(v∗(ϕ) = x), i. e., in the case
of the sequent system, 𝒢⊩(ϕ ⊢x) and 𝒢⊩(x ⊢ϕ). Consequently, ⊪satisfies the
truth-preserving principle, as specified in details in Definition 102 in Appendix and in
Definition 57.
Definition 61. Assume that M and 𝒦ℳsatisfy the assumptions in Definition 59. Let
(K, IK) ∈𝒦ℳ, 1K be the support of K with IK : Var ×1K →2 and I∗
K : F(ℒ) × 1K →2
be the unique extension of IK for all formulae in F(ℒ), which defines the sets ‖ϕ‖ =def
{y ∈1K | I∗
K(ϕ, y) = 1} for each ϕ ∈F(ℒ). Let for a possible world w ∈1K and ϕ ∈F(ℒ):
1.
(K, IK) 󳀀󳨐w ϕ iff w ∈‖ϕ‖;
2.
(K, IK) 󳀀󳨐ϕ iff ‖ϕ‖ = 1K;
3.
𝒦ℳ󳀀󳨐w ϕ iff (K, I′
K) ∈𝒦ℳ, ({w′ ∈1K | I′ ∗
K (ϕ, w′) = 1} = ‖ϕ‖);
4.
𝒦ℳ󳀀󳨐ϕ iff (K, IK) 󳀀󳨐ϕ ∀(K, IK) ∈𝒦ℳ.
The following theorem is the basic result for the next representation theorem, and
shows that (from Definition 59) the new relational inference 󳀀󳨐is sound and complete
w. r. t. the algebraic inference 󳀀󳨐a.
Corollary 17. Assume that M and M+ satisfy the assumptions in Definition 59. Then, for
every ϕ ∈F(ℒ) and x ∈X,
M 󳀀󳨐a
x ϕ
iff
M+ 󳀀󳨐a
in(x) ϕ
(5.4)

5.1 Introduction to many-valued logics
|
267
Proof. Assume that M and 𝒦ℳsatisfy the assumptions in Definition 59, and show
from left to right:
Let us suppose that M 󳀀󳨐a
x ϕ, i. e., for each (A, v) ∈M we have that (A, v) 󳀀󳨐a
x ϕ,
and hence from point 1 in Definition 60, x = v∗(ϕ), i. e., in(x) = v∗
K(ϕ). In fact, from
(C)(ii), we obtain the composition of homomorphisms v∗
K = in ∘v∗it holds that v∗
K(ϕ) =
in(v∗(ϕ)) = in(x) with (AK, vK) 󳀀󳨐a
in(x) ϕ. Thus, we obtain the satisfaction at point 1+ of
Definition 59, and hence also the point 3+. Notice that the general standard result
M 󳀀󳨐a ϕ
iff
M+ 󳀀󳨐a ϕ
(5.5)
is just equal to (5.4) when x = 1 (equivalent to the points 2 and 2+) from the fact that
for all v, v(⊤) = 1 is the top truth value in X.
From this corollary, we are able to define a direct duality between algebraic and
Kripke-style semantics for a logic ℒ
M
𝔻? 𝒦ℳ
𝔼? M+
Theorem 8 (Representation theorem). Assume that M and ℛsatisfy the assumptions
in Definition 59. Injective mapping in can be extended to the injective homomorphism
in : (A, v) 󳨅→(AK, vK).
Thus, the dual representation of the algebra A is the subalgebra of AK defined by image
of the homomorphism in.
We call it canonical representation when in is an isomorphism.
Proof. It follows from the fact that v and IK are the homomorphisms between O-alge-
bras. So, we can show it by structural induction on the formulae in F(ℒ).
For example, for a formula composed by conjunction, ϕ ∧ψ, with x = v∗(ϕ) and
y = v∗(ψ), we have that
in(x ∧A y) = in(v∗(ϕ) ∧A v∗(ψ)) = in(v∗(ϕ ∧ψ)),
from the homomorphism of v∗
= (in ∘v∗)(ϕ ∧ψ) = v∗
K(ϕ ∧ψ),
from (C)(ii)
= v∗
K(ϕ) ∧K v∗
K(ψ)
from the homomorphism of vK
= in(v∗(ϕ)) ∧K in(v∗(ψ))
= in(x) ∧K in(y).
Thus, we obtained that the homomorphism holds for the restriction of in to the image
of v, but it is generally valid for any v.
Thus, in the case of the autoreferential semantics considered in next section, given
an algebraic model (A, v) of the algebra A = (X, ≤, {o}o∈𝒪) with many-valued valuation

268
|
5 Theory of many-valued intensional first-order logic
v : Var →X for a logic ℒ, the corresponding Kripke model ℳ= (K, IK) = 𝔻(A, v)
with the frame K = (1K, {Rj}) with the set of possible worlds 1K and accessibility rela-
tions Rj for the modal operators of ℒand Kripke interpretation IK : Var ×1K →2, the
representation of the original algebraic model (A, v) is the set-based algebraic model
(AK, vK) = 𝔼(K, IK) = 𝔼(𝔻(A, v)) where AK = (XK, ⊆, {oK}o∈𝒪) is a canonical represen-
tation of the algebra A. That is, in the autoreferential case we obtain that in is just an
isomorphism.
Example 29 (The continuation of Example 28). Case A: Let us consider now the alge-
braic models for ℒ, based on the Boolean algebra, with (A, v) ∈M, where v : Var →2
is the interpretation for propositional variables in Var, and on its canonical exten-
sion (AK, vK) = 𝔼(𝔻((A, v))), where (K, IK) = 𝔻((A, v)), AK = (𝒫({0, 1}), ⊆, ⋂, ¬+), with
¬+0 = ¬+{0} =def {0, 1} and ¬+{1} = ¬+{0, 1} =def {0} and with injective homomor-
phisms
in : ({0, 1}, ≤, ̃∧, ∼) 󳨅→(𝒫({0, 1}), ⊆, ⋂, ¬+).
We have that for any p ∈Var, v(p) = 1 iff vK(p) = {0, 1} and v(p) = 0 iff vK(p) = {0}.
We do not have any modal operator in these algebras, thus the frame K ∈(K, IK) =
𝔻((A, v)) has the set of only two possible worlds equal to 1K = 2 = {0, 1} and an empty
accessibility relation, i. e., K = ({0, 1}, {}). Thus, the subalgebra ({{0}, {0, 1}}, ⊆, ⋂, ¬+)
is canonical representation of Boolean algebra A because we obtain that in is just an
isomorphism.
Case B: Let us consider the 4-valued Belnap’s distributive bilattice X = ℬ4 = {f, ⊥, ⊤, t},
with f = 0 and t = 1, and in this case we can take 1K = {0, ⊥, ⊤} ⊂X, with injective ho-
momorphism in in Example 28. However, if we take that XK = {{0}, {0, ⊥}, {0, ⊤}, {0, ⊥,
⊤}} ⊂𝒫(X), then we obtain the isomorphism
in : (X, ≤, ̃∧, ̃∨) ≃(XK, ⊆, ⋂, ⋃),
i. e., canonical representation, with XK = {{0}, {0, ⊥}, {0, ⊤}, {0, ⊥, ⊤}} ⊂𝒫(X), such
that: in(0) = {0}, in(⊥) = {0, ⊥}, in(⊤) = {0, ⊤}, 1K = in(1) = {0, ⊥, ⊤}.
The general canonical autoreferential representation for algebras defined above
complete distributive lattices is given in next Section 5.1.2.
Extension to predicate logics
Note that all of this representation theory for a many-valued propositional logic can
be used also for the more expressive many-valued predicate logics. An extension of
propositional logic to corresponding predicate logics is direct and simple:
Let H be the Herbrand base (i. e., the set of all ground atoms that can be consid-
ered as propositions in propositional logic) for a given set P of n-ary predicates with

5.1 Introduction to many-valued logics
|
269
variables in 𝒱(e. g., and atom for a predicate letter p ∈P with ar(p) = n ≥1, we have
the atom p(x1, . . . , xn) with x1, . . . , xn ∈𝒱) and the domain 𝒟of values, with the set of
valuations g ∈G = 𝒟𝒱that assign the values to variables of logic atoms. Then we can
define an interpretation for this predicate logic as a map v : H →X.
Note that in the case of the predicate logic we use the ground atoms of Herbrand
base w. r. t. the propositional symbols in Var of a propositional logic. Because if that
we use the same symbol used for propositional valuation v : Var →X for the pred-
icate logic as well, by considering that we use now only the set of ground atoms
p(x1, . . . , xn)/g ∈H instead of the set of propositional letters p ∈Var.
Definition 62. This Herbrand interpretation v : H →X can be inductively extended
into the map v∗to all ground formulae in the standard truth-functional way, for any
two ground formulae (i. e., without free variables) ϕ and ψ (if ϕ is a formula with free
variables then by ϕ/g we define the ground formula obtained by the given assignment
g ∈G = 𝒟𝒱):
1.
v∗(p(x1, . . . , xn)/g) = v(p(x1, . . . , xn)/g), for any ground atom in H;
2.
v∗(ϕ ⊙ψ) = v∗(ϕ) ⊗v∗(ψ), for any binary connective ⊙∈{∧, ∨, ⇒, . . .} and its
algebraic operations ⊗∈{̃∧, ̃∨, ⇀, . . .};
3.
v∗(oiϕ) = ̃øi(v∗(ϕ)), for any unary modal or negation logical connective oi ∈
{¬, ♦i, . . .};
4.
v∗(∀xϕ) = ⋀g∈G(v∗(ϕ/g)), where ⋀is the extension of meet lattice binary operator
∧to the any set;
5.
v∗(∃xϕ) = ⋁g∈G(v∗(ϕ/g)), where ⋁is the extension of join lattice binary operator
∨to the any set.
We recall that the set-based (for infinite sets as well) of the operators ⋀and ⋁
is well- defined because our many-valued logics are based on the complete (and dis-
tributive) lattices (X, ≤), which satisfy these requirements. Then it can be easily shown,
that we can use the formulae with free variables as well (for this predicate logic with
existential ∃and universal ∀quantifiers as well), in the axiom schemas in proposi-
tional many-valued systems: for each assignment g : 𝒱→𝒟, we will obtain identical
propositional schemas.
5.1.2 Canonical autoreferential representation for algebras over complete
distributive lattices
In Examples 28 and 29, we have shown the cases for this new definition of represen-
tation theorem, based on models of a logic ℒ, which define only relational structures
K ∈(K, IK) = 𝔻((A, v)), with a set of possible worlds (support) equal to the set 1K ⊆X.

270
|
5 Theory of many-valued intensional first-order logic
Remark. In what follows, if the algebraic binary operations ̃∧and ̃∨correspond to the
meet and join lattice operators, we will denote them simply as corresponding logical
connectives ∧and ∨, respectively.
Moreover, we will consider the subclass of complete latices in which each lattice of
truth values (X, ≤, ∧, ∨) is isomorphic to the complete sublattice of the powerset lattice
(𝒫(X), ⊆, ⋂, ⋃). Consequently, we will consider the cases when there exists the subset
S = CL(𝒫(X)) ⊆𝒫(X), closed under intersection ⋂and union ⋃, with the isomorphism
is : (X, ≤, ∧, ∨) ≃(CL(𝒫(X)), ⊆, ⋂, ⋃), so that we obtain the inclusion map in =⊆∘is :
X 󳨅→AK ⊆𝒫(1K) as required in Definition 59.
For such a subclass of complete lattices (X, ≤, ∧, ∨), with |X| ≥3 of truth values,
we will obtain that the carrier set 1K ⊂X, of the many-valued logic algebra A, is the
set of possible worlds for the Kripke frame in Definition 59 for the dual relational rep-
resentation of the algebraic semantics: this is an autoreferential assumption [69]. The
relational semantic of other modal operators of the algebra A will be obtained succes-
sively by a correct definition of the accessibility relations of the Kripke frame.
It is well known that any complete lattice X has the following property: each (also
infinite) subset S of X has the least upper bound (supremum) denoted by ⋁S (when
S has only two elements, the supremum corresponds to the join operator ∨), and the
greatest lower bound (infimum) denoted by ⋀S (when S has only two elements the
infimum corresponds to the meet operator ∧). Thus, it has the bottom element 0 =
⋀X ∈X, and the top element 1 = ⋁X ∈X. The cardinality of the set of hereditary sub-
sets of X is generally greater than the cardinality of the lattice X. But in what follows we
will consider the class of complete distributive lattices X, for which we are able to de-
fine an isomorphism [207] between the original lattice X and the particular collection
X+ of hereditary subsets of X. Thus, in each distributive lattice we are able to define
the implication and negation logical operators based on relative pseudo-complement
and pseudo-complement relatively, i. e.,
(x ⇀y) =def ⋁{z ∈X | z ∧x ≤y},
and
∼x =def (x ⇀0)
(5.6)
From the Birkhoff’s representation theorem [207] for distributive lattices, every finite
(thus complete) distributive lattice is isomorphic to the lattice of lower sets of the poset
of join-irreducible elements. An element x
̸= 0 in X is a join-irreducible element iff
x = a ∨b implies x = a or x = b for any a, b ∈X. The lower set (down closed) is any
subset Y of a given poset (X, ≤) such that, for all elements x and y, if x ≤y and y ∈Y
then x ∈Y.
More details about autoreferential semantics is provided in Section A.3.2 in the
Appendix. However, here, in this section, we provide the complete autoreferential se-
mantics, and Kripke semantics based on it, by using only the subset of join-irreducible
elements of X instead of the complete set of truth-values in X.

5.1 Introduction to many-valued logics
|
271
Proposition 28 (0-Lifted Birkhoff isomorphism [207]). Let X be a complete distributive
lattice, then we define the following mapping ↓+: X →𝒫(X): for any x ∈X,
↓+ x = ↓x ⋂̂X,
where ̂X = {y | y ∈X and y is join-irreducible } ⋃{0}, such that for any S ⊆̂X,
S =↓+ ∨S
(5.7)
We define the set X+ = {↓+ a | a ∈X} ⊆𝒫(X), so that ↓+ ⋁= idX+ : X+ →X+
and ⋁↓+ = idX : X →X. Thus, the operator ↓+ is inverse of the supremum operation
⋁: X+ →X. The set (X+, ⊆) is a complete lattice, such that there is the following 0-lifted
Birkhoff isomorphism
↓+ : (X, ≤, ∧, ∨, 0, 1) ≃(X+, ⊆, ∩, ∪, {0}, ̂X)
(5.8)
Proof. See the proof of Proposition 38 and more details in Section A.3.2 in the Ap-
pendix. The closure property (5.7) we can show as follows: Let y = ⋁S, and hence
S ⊆↓+y. Let us suppose that S ⊂↓+y, so that exists z ∈̂X such that 0
̸= z ∉S
but z ∈↓+y. In this case, it has to be that y = ⋁(S ⋃{z}) with join-irreducible element
z ∉S, which is in contradiction with y = ⋁S because S is composed by join-irreducible
element as well. Consequently, it must hold the equation (5.7). From Birkhoff’s repre-
sentation theorem [207] for distributive lattices, every complete distributive lattice is
isomorphic to the lattice of lower sets of the poset of join-irreducible elements, i. e.,
(5.8) is such an isomorphism.
The fundamental result of this proposition is that ↓+ is a bijection between alge-
braic truth values X and the set X+ composed of subsets of joint-irreducible elements
in X plus bottom element 0, that is of the set ̂X. That is, the elements of the lattice
(X+, ⊆) can be used for the canonical set-based algebras of any algebra A with carrier
set composed by elements of the lattice (X, ≤). More over, each subset S ∈X+ is hered-
itary, such that if x ∈S ⊂̂X, then each y ∈̂X such that y ≤x must belong to S.
The name lifted here is used to denote the difference from the original Birkhoff’s
isomorphism. That is, we have that for any x ∈X, 0 ∈↓+x, so that ↓+ x is never
empty set (it is lifted by bottom element 0). It is easy to verify that ↓+ 0 = {0} is the
bottom element in X+. Notice that (A+, ⊆, ⋂, ⋃) is a subalgebra of the powerset algebra
(𝒫(A), ⊆, ⋂, ⋃).
Example 30. Belnap’s bilattice in the Example 28 is a distributive lattice w. r. t. the ≤t
ordering, with two join-irreducible elements ⊥and ⊤, so that ̂X = {0, ⊥, ⊤}. In this case,
we have that
↓+ 1 = ↓+(⊥∨⊤) = ↓+⊥⋃↓+⊤= ↓⊥⋃↓⊤= {0, ⊥, ⊤} = ̂X
̸=↓1 = X.

272
|
5 Theory of many-valued intensional first-order logic
Remark. For a many-valued logic with distributive complete lattice of truth values, we
have that XK = 𝒫(1K) ⊆𝒫(X), with 1K = ̂X and DK = X+, and the injective homomor-
phism ↓+: X →𝒫(X) corresponds to the injective homomorphism in : (A, v) 󳨅→(AK, vK)
in the representation Theorem 8. Thus, the dual representation of this algebra (in this
case a distributive complete lattice) A is the subalgebra (X+, ⊆, ⋂, ⋃) of AK, defined by
the image of the homomorphism in = ↓+.
Based on these results, we are able to extend the complete distributive lattices
with other unary algebraic operators oi : X →X and binary operators ⊗i : X × X →X
in order to obtain a class of algebras ((X, ≤, ∧, ∨), {oi}i∈N, {⊗i}i∈N), with the following
set-based canonical representation
Proposition 29 (Canonical representation). Let A = ((X, ≤, ∧, ∨, ¬c), {oi}i∈N, {⊗i}i∈N) be
a complete distributive lattice-based algebra. The unary operation ¬c corresponds to
the classical negation and is defined for each x ∈X by
¬cx =def ∨((̂X −↓+x) ∪{0})
(5.9)
We define its canonical representation by the algebra
A+ = ((X+, ⊆, ⋂, ⋃, ¬+
c ), {o+
i }i∈N, {⊗+
i }i∈N),
with the representation isomorphism:
↓+ : ((X, ≤, ∧, ∨, 0, 1), {oi}i∈N, {⊗i}i∈N) ≃((X+, ⊆, ∩, ∪, {0}, ̂X), {o+
i }i∈N, {⊗+
i }i∈N)
(5.10)
so that the operators of the canonical (set-based) algebra A+ are directly defined from
the operators of algebra A by
o+
i = ↓+oi∨: X+ →X+,
⊗+
i = ↓+ ⊗i (∨× ∨) : X+ × X+ →X+
(5.11)
Proof. For any x, y
∈
X, we have for any unary algebraic operator ↓+
oi(x)
=
↓+oi(⋁↓+)(x) = (↓+ oi ⋁)↓+x = o+
i (↓+ x) and for any binary operator ↓+ ⊗i(x, y) =
⊗+
i (↓+ x, ↓+ y). Thus, ↓+ is an isomorphism ↓+: A ≃A+.
Example 31. Consider two cases:
1.
Classical negation in Belnap’s bilattice: In this case, X = {0, ⊥, ⊤, 1} and ̂X =
{0, ⊥, ⊤}, so from (5.9) that ¬c0 = 1, ¬c1 = 0, ¬c⊥= ⊤and ¬c⊤= ⊥. The set-based
classical negation is defined by the homomorphism (5.10), ¬+
c (↓+ x) = ↓+(¬cx) =
↓+ ⋁((̂X −↓+x) ∪{0}) = (from (5.7)) = (̂X −↓+x) ∪{0} ⊆̂X. Thus, ¬+
c (↓+ 0) = ̂X,
¬+
c (↓+ 1) = {0}, ¬c(↓+ ⊥) = {0, ⊤} and ¬c(↓+ ⊤) = {0, ⊥}.
2.
For intuitionistic implication: Let us consider the binary implication operator
⊗i equal to the relative pseudo-complement ⇀over a complete distributive lattice.
Then we have that

5.1 Introduction to many-valued logics
|
273
(↓+ x) ⇀+ (↓+ y) = ⊗+
i (↓+ x, ↓+y) = ↓+ ⊗i (x, y) = ↓+(x ⇀y) = ↓+( ⋁{z | z ∧x ≤y})
= ⋃{↓+ z | z ∧x ≤y}
(from the homomorphism ↓+ w. r. t. the join operator of this lattice)
= ⋃{↓+ z | ↓+(z ∧x) ⊆↓+y}
(from ↓+v ⊆↓+w iff v ≤w)
= ⋃{↓+ z | ↓+z ⋂↓+x) ⊆↓+ y}
(from the homomorphism ↓+ w. r. t. the meet operator of this lattice)
= ⋃{S ∈X+ | S ⋂(↓+ x) ⊆↓+y}.
That is, we obtain that the correspondent operator ⊗+
i : X+ × X+ →X+ is a relative
pseudo-complement for the lattice X+.
It is well known that the standard unary existential modal operators are homo-
morphisms between join semilattices, oi : (X, ≤, ∨) →(X, ≤, ∨), and modal negation
operators ̃oi : (X, ≤, ∨) →(X, ≤, ∨)OP, where the dual join semilattice (X, ≤, ∨)OP has
≤OP=≥, and ∨OP = ∧. For the normal modal logics, they are monotone (x ≤y implies
oi(x) ≤oi(y), and ̃oi(x) ≤OP ̃oi(y)), additive (oi(x ∨y) = oi(x) ∨oi(y)) and (̃oi(x ∨y) =
̃oi(x) ∨OP ̃oi(y) = ̃oi(x) ∧̃oi(y)), and normal (oi(0) = 0 and ̃oi(0) = 0OP = 1).
Now we are able to show that for any algebraic model M = (A, I), of a logic ℒ
with relative pseudo-complement for implication and a number of unary modal op-
erators, there exists the correspondent Kripke model ℳK = 𝔻(M) = (K, IK). In what
follows, we denote by ⇒the logic connective for implication, correspondent to the
algebraic relative pseudo-complement ⇀, by ♦i the existential modal connective for
the algebraic additive operator oi, and by ¬i the logic negation modal connective for
the algebraic additive negation operator ̃oi, so that for the homomorphism (valuation)
v∗: F(ℒ) →X holds that v∗(ϕ ⇒ψ) = v∗(ϕ) ⇀v∗(ψ), v∗(♦iϕ) = oi(v∗(ϕ)) and
v∗(¬iϕ) = ̃oi(v∗(ϕ)).
Notice that if we denote by ↓X: ̂X →𝒫(̂X) the restriction of ↓: X →𝒫(X) to the
subset of join-irreducible elements ̂X ⊆X, then for any x ∈̂X we obtain
↓+x = ↓Xx = {y ∈̂X | y ≤x} ∈X+ ⊆𝒫(̂X)
(5.12)
Consequently, in the next Kripke-style definition for modal many-valued logics we will
use the set ̂X, of join-irreducible elements in X, for the set of possible worlds.
Now we will define the standard accessibility relation for any given additive nor-
mal existential modal operator ♦i and negation modal operator ¬i.

274
|
5 Theory of many-valued intensional first-order logic
Definition 63 (Accessibility relations for unary operators). Let oi : (X, ≤, ∨) →(X, ≤, ∨)
and negation operator ̃oi : (X, ≤, ∨) →(X, ≤, ∨)OP be the additive normal modal opera-
tors. Then we define the accessibility relation for existential modal operator ♦i by
ℛi =def {(x, y) | y ∈̂X, and x ∈↓+oi(y)},
and the incompatibility relation for negation connective ¬i by
̃
ℛi =def ⋃
x∈X
(↓+ x) × (↓+ ̃oi(x))
(5.13)
Remark. More about a hierarchy of negation operators for complete lattices and their
relational semantics can be found in [69] and Definition 104 in Section A.3.2 in the
Appendix. This semantics is based on the Birkhoff concept of polarity [207]:
If (X, R) is a set with a particular relation on a set X, R ⊆X × X, with mappings
λ : 𝒫(X) →𝒫(X)OP, ϱ : 𝒫(X)OP →𝒫(X), such that for subsets U, V ∈𝒫(X),
λU = {x ∈X | ∀u ∈U.((u, x) ∈R)},
ρV = {x ∈X | ∀v ∈V.((x, v) ∈R)},
where the powerset 𝒫(X) is a poset with bottom element empty set 0 and top ele-
ment X, and 𝒫(X)OP is its dual (with ⊆OP inverse of ⊆). Then we have an induced Galois
connection λ ⊣ρ, i. e., λU ⊆OP V iff U ⊆ρV. The additive modal operator λ is a set-
based corresponding operator for the modal negation operator ̃oi, when we consider
the relation R as an incompatibility (or “perp”) relation ̃
ℛi in (5.13) for this modal nega-
tion operator, and λU = {x ∈X | ∀u(u ∈U implies (u, x) ∈̃
ℛi)}, which will be used for
the relational Kripke-style semantics of modal negation operators in what follows.
The following lemma is relevant for the definition of the incompatibility relation
in (5.13).
Lemma 6. For a given negation (antitonic additive modal operator) ̃oi, we are able
to define the hereditary-incompatibility relation by (5.13) in order to define the split
negation λ, which satisfies the autoreferential semantics isomorphism (5.10), i. e., the
condition
λ = ↓+̃oi ⋁: X+ →X+
(5.14)
Proof. For the case when S = {0} ∈X+, from the fact that ↓+ 0 = {0} and ↓+ ̃oi0 =
↓+1 = ̂X, we obtain the banal result that λ{0} = ̂X ∈X+. Thus, we are interested only for
non-singleton hereditary subsets (with at least one join-irreducible element from ̂X),
S = ↓+x ∈X+ for some x ∈X, and hence we have that
λS =def {y ∈X | ∀u ∈S.(u, y) ∈̃
ℛi}
= {y ∈X | ∀u ∈(↓+ x).(u, y) ∈̃
ℛi}
⊇(↓+ ̃oix)
from (5.13).

5.1 Introduction to many-valued logics
|
275
Let us show that we obtain strictly the result λS = (↓+ ̃oix), i. e., that we have no any
contribution to λS of another components (↓+ a) × (↓+ ̃oia) ⊂̃
ℛi in (5.13). In order to
give such a contribution to λS, from definition of λ we must have that S ⊂(↓+ a) and
from the fact that S = (↓+ a) it is possible only if x < a, that is ̃oix ≥̃oia, and hence
(↓+ ̃oix) ⊇(↓+ ̃oia). Consequently, any y ∈(↓+ ̃oia) is already in (↓+ ̃oix) as well, and
we cannot have any new contribution to λS, i. e., we obtain the strict result that for
each x ∈X, (↓+ ̃oix) = λS = λ(↓+ x), and hence we obtain that ↓+ ̃oi = λ↓+, so that
λ = λ(↓+ ⋁) = (↓+ ̃oi) ⋁.
Example 32 (Continuation of Examples 28 and 30 for Belnap’s bilattice X = ℬ4). No-
tice that the knowledge negation operator—(see more in next section) is normal addi-
tive modal operator w. r. t. the ≤t ordering. As we will see in the next definition, its dual
is truth negation ¬, which is a normal modal operator w. r. t. the ≤k ordering. Thus,
in the case of the believe (conflation) modal operator, oi = −, in Belnap’s bilattice,
̂X = {f, ⊥, ⊤}, such that −f = f = 0, −t = t = 1, −⊥= ⊤, −⊤= ⊥, we obtain that
ℛ−= {(0, 0), (0, ⊥), (⊤, ⊥), (0, ⊤), (⊥, ⊤)},
while for the autoepistemic Moore’s operator [197], oi = μ : X →X, defined by
μ(x) = t = 1
if x ∈{⊤, t};
f = 0 otherwise, we have that
ℛμ = {(0, 0), (0, ⊥), (0, ⊤)(⊥, ⊤), (⊤, ⊤)}.
Both of these modal operators are additive and normal. For the modal negation addi-
tive operator ̃oi = ¬, we have the incompatibility relation:
̃
ℛ¬ = {(0, 0), (0, ⊥), (0, ⊤), (⊥, ⊥), (⊥, 0), (⊤, ⊤), (⊤, 0)}.
As we have seen, generally for the unary operators we need binary accessibility
relations, and hence for the binary operators we need generally ternary accessibility
relations. Only in some special cases, e. g., for relative pseudo-complement (used for
intuitionistic implication), which can be expressed by using lattice ordering ≤with
meet and join operators, we can use simpler binary accessibility lattice ordering re-
lation ≤(reflexive and transitive) directly (see Example 31) because intuitionistic im-
plication is a composition of universal “necessity” modal operator, which needs the
reflexive and transitive accessibility relation ≤and classical implication. So in next,
we will not consider these singular limited cases, but only more complex cases that
needs ternary accessibility relations, as follows.
Definition 64 (Accessibility relations for binary operators). Let ⊗i : (X, ≤, ∨)2 →(X,
≤, ∨) be a binary modal operator of an algebra A in Proposition 29. Then we define
the accessibility relation for these operators:
Ri =def {(z, x, y) | x, y ∈̂X, and z ∈↓+x ⊗i y}
(5.15)

276
|
5 Theory of many-valued intensional first-order logic
Now we are able to define the relational Kripke-style semantics for a propositional
modal logic ℒ, based on the modal Heyting algebras in Proposition 29.
Definition 65. For a complete distributive lattice-based logics, the mapping 𝔻: ℳ→
𝒦ℳis defined as follows: Let (A, v) ∈ℳbe an algebra model (with algebra A in Propo-
sition 29), then MK = (K, IK) = 𝔻(A, v) is the correspondent Kripke model, such that
K = ⟨(1K, ≤), {ℛj}j∈𝒩, {Rj}j∈𝒩⟩is a frame, where 1K = ̂X, ℛj is an accessibility rela-
tion in Definition 63 for a modal operator oj, Rj is a ternary accessibility relation in
Definition 64 for binary operator ⊗j (different from relative pseudo-complement), and
IK : Var ×1K →2 is a canonical valuation, such that for any atomic formula (proposi-
tional variable) p ∈Var and w ∈1K, IK(p, w) = 1 iff w ∈↓+(v(p)). Then, for any world
x ∈1K, and formulae ψ, ϕ ∈F(ℒ):
1.
MK 󳀀󳨐x p iff IK(p, x) = 1
2.
MK 󳀀󳨐x ϕ ∧ψ iff MK 󳀀󳨐x ϕ and MK 󳀀󳨐x ψ,
3.
MK 󳀀󳨐x ϕ ∨ψ iff MK 󳀀󳨐x ϕ or MK 󳀀󳨐x ψ,
4.
MK 󳀀󳨐x ¬cϕ iff x = 0 or not MK 󳀀󳨐x ϕ
5.
MK 󳀀󳨐x ϕ ⇒ψ iff ∀y ∈1K((y ≤x and MK 󳀀󳨐y ϕ) implies MK 󳀀󳨐y ψ),
6.
MK 󳀀󳨐x∼ϕ iff MK 󳀀󳨐x ϕ ⇒0,
7.
MK 󳀀󳨐x ♦jϕ iff ∃y ∈1K((x, y) ∈ℛj and MK 󳀀󳨐y ϕ), for a modal operator oj, (universal
modal operators are derived by ◻j = ¬c♦j¬c),
8.
MK 󳀀󳨐x ¬jϕ iff ∀y ∈1K(MK 󳀀󳨐y ϕ implies (y, x) ∈̃
ℛj),
iff
∀y ∈1K((x, y) ∈(1K × 1K −̃
ℛj)−1 implies not MK 󳀀󳨐y ϕ),
for a negation modal operator ̃oj,
9.
MK 󳀀󳨐x ϕ ⊗j ψ iff ∃y, z ∈1K((x, y, z) ∈Rj and MK 󳀀󳨐y ϕ and MK 󳀀󳨐z ψ), for a binary
operator ⊗j monotonic in both arguments,
10. MK 󳀀󳨐x ϕ ⊗j ψ iff ∃y, z ∈1K((x, y, z) ∈Rj and MK 󳀀󳨐y ϕ and MK 󳀀󳨐z ψ and ∀w ∈
1K(MK 󳀀󳨐w ϕ implies w ≤y)), for a binary operator ⊗j monotonic in second and
antitonic in first argument.
The mapping 𝔼: 𝒦ℳ→ℳis defined as follows: for any (K, IK) ∈𝒦ℳ,
𝔼(K, IK) =def (𝒫(1K), IK) ∈ℳ.
Notice that in the world x = 0 (bottom element in X) each formula ϕ ∈F(ℒ) is sat-
isfied: because of that we will denominate this world by inconsistent or trivial world.
The semantics for the implication is the Kripke modal semantics for the implication
of the intuitionistic logic (only with inverted ordering for the accessibility relation ≤).
In any modal logic, the set of worlds where a formula ϕ is satisfied is denoted by
‖ϕ‖ = {x | MK 󳀀󳨐x ϕ}, so that we have MK 󳀀󳨐x ϕ iff x ∈‖ϕ‖.

5.1 Introduction to many-valued logics
|
277
Theorem 9 (Soundness and completeness). Let (A, v) ∈ℳbe an algebraic model of
ℒand (K, IK) = 𝔻(A, v) be the correspondent Kripke model, with a frame K = ⟨(1K, ≤),
{ℛj}j∈𝒩, {Rj}j∈𝒩⟩, where 1K = ̂X, and the canonical valuation IK : Var ×1K →2 given by
Definition 65. Then, for any propositional formula ϕ, the set of worlds where ϕ holds is
equal to
‖ϕ‖ =def {x | MK 󳀀󳨐x ϕ} = ↓+(v∗(ϕ)) ∈X+
(5.16)
so that (A+, vK) = 𝔼((K, IK)) = 𝔼(𝔻(A, v)) is the set-based (complex) algebra where from
Definition 59, vK = in ∘v = ↓+ ∘v : Var →X+. Thus, from equation above ‖ϕ‖ = v∗
K(ϕ),
i. e., ‖ _ ‖ = v∗
K : F(ℒ) →X+, and hence A+ is canonical representation of the algebra A
of the isomorphism (5.10).
Proof. By structural induction (we will follow the ordering in Definition 65):
1.
For any proposition variable p ∈Var, x ∈̂X, MK 󳀀󳨐x p iff x ∈IK(p, x) = 1 iff (from
Definition) x ∈↓+(v(p)), thus ‖p‖ = ↓+(v(p)).
2.
From MK 󳀀󳨐x ϕ ∧ψ iff MK 󳀀󳨐x ϕ and MK 󳀀󳨐x ψ, holds that ‖ϕ ∧ψ‖ = ‖ϕ‖ ⋂‖ψ‖ =
↓+v∗(ϕ) ⋂↓+v∗(ψ), (by structural induction), = ↓+v∗(ϕ ∧ψ) (Proposition 28).
3.
Similarly, ‖ϕ ∨ψ‖ = ‖ϕ‖ ⋃‖ψ‖ = ↓+v∗(ϕ) ⋃↓+v∗(ψ) = ↓+v∗(ϕ ∨ψ).
4.
For classical negation: let from inductive hypotheses ‖ϕ‖ = ↓+v∗(ϕ), then ‖¬cϕ‖ =
{0} ⋃{x ∈̂X | not MK 󳀀󳨐x ϕ} = {0} ⋃{x ∈̂X | x ∉‖ϕ‖} = {0} ⋃(̂X −‖ϕ‖) = (from (5.7))
= ↓+ ⋁({0} ⋃(̂X −‖ϕ‖) = ↓+ ⋁({0} ⋃(̂X −↓+v∗(ϕ)) = (from (5.9)) = ↓+ (¬cv∗(ϕ)) =
(from homomorphism of v∗) = ↓+ v∗(¬cϕ).
5.
Suppose that ‖ϕ‖ = ↓+v∗(ϕ) and ‖ψ‖ = ↓+v∗(ψ). Then for any x ∈̂X we have
x ∈‖ϕ ⇒ψ‖ iff MK 󳀀󳨐x ϕ ⇒ψ iff ∀y ∈̂X((y ≤x and MK 󳀀󳨐y ϕ) implies MK 󳀀󳨐y ψ) iff
∀y ∈̂X((y ∈↓Xx and MK 󳀀󳨐y ϕ) implies MK 󳀀󳨐y ψ) iff (from (5.12) holds ↓+ x = ↓Xx)
∀y(y ∈↓+x ⋂‖ϕ‖ implies y ∈‖ψ‖) iff ↓+ x ⋂‖ϕ‖ ⊆‖ψ‖. So that S = ‖ϕ ⇒ψ‖ = {x |
↓+x ⋂‖ϕ‖ ⊆‖ψ‖}.
Then S = idX+(S) = ↓+ ⋁S = ⋃↓+S (from the homomorphism ↓+) = ⋃x∈S ↓+x =
⋃{↓+ x |↓+ x ⋂‖ϕ‖ ⊆‖ψ‖} = ⋃{S′ ∈X+ | S′ ⋂↓+v∗(ϕ) ⊆↓+ v∗(ψ)} = ↓+(v∗(ϕ) ⇀
v∗(ψ)) (as shown in the Example 5) = ↓+ v∗(ϕ ⇒ψ) (from the homomorphism of
the valuation v∗). Consequently, ‖ϕ ⇒ψ‖ = ↓+v∗(ϕ ⇒ψ).
6.
For the pseudo-complement negation ∼, it is derived from point 5, from the fact
that ∼ϕ is equal to ϕ ⇒0.
7.
For any additive algebraic modal operator oi, we obtain an existential logic modal
operator ♦i, so that for any x ∈̂X, MK 󳀀󳨐x ♦iϕ iff ∃y ∈̂X((x, y) ∈ℛi and MK 󳀀󳨐y ϕ),
iff ∃y ∈̂X((x, y) ∈ℛi and y ∈↓+α), where α = v∗(ϕ). Then ‖♦iϕ‖ = {x | ∃y((x, y) ∈
ℛi and y ∈↓+α)} = {x | ∃y(y ∈̂X, x ∈↓+oi(y) and y ∈↓+α)} = {x | y ∈↓+α and
x ∈↓+oi(y)} = {x | y ∈↓+α and x ∈↓+oi ⋁({y})} = {x | y ∈↓+α and x ∈o+
i ({y})} =
⋃y∈↓+α o+
i ({y}) = (from the additivity of oi) = o+
i (↓+ α) = ↓+oi ⋁(↓+ α) = ↓+oi(α).
Thus, we have that ‖♦iϕ‖ = ↓+oi(α) = ↓+oi(v∗(ϕ)) = ↓+v∗(♦iϕ).

278
|
5 Theory of many-valued intensional first-order logic
8.
For any additive algebraic negation operator ̃oi, we obtain a logic modal negation
operator ¬i, so that for any x ∈̂X, MK 󳀀󳨐x ¬iϕ iff ∀y(MK 󳀀󳨐y ϕ implies (y, x) ∈̃
ℛi),
iff ∀y(y ∈↓+α implies (y, x) ∈̃
ℛi), where α = v∗(ϕ). Then ‖¬iϕ‖ = {x | ∀y(y ∈↓+α
implies (y, x) ∈̃
ℛi)} = ↓+̃oiα (from definition of ̃
ℛi in (5.13) and Lemma 6).
Thus, we have that ‖¬iϕ‖ = ↓+̃oi(α) = ↓+̃oi(v∗(ϕ)) = ↓+v∗(¬iϕ).
9.
For the binary operators monotonic in both arguments: suppose that ‖ϕ‖ =
↓+v∗(ϕ) and ‖ψ‖ = ↓+v∗(ψ). Then ‖ϕ ⊗j ψ‖ = {x | ∃y, z ∈1K((x, y, z) ∈Rj and
MK 󳀀󳨐y ϕ and MK 󳀀󳨐z ψ)} = {x | ∃y, z ∈1K((x, y, z) ∈Rj and y ∈‖ϕ‖ and
z ∈‖ψ‖)} = {x | ∃y, z ∈1K((x, y, z) ∈Rj and y ∈‖ϕ‖ and z ∈‖ψ‖)} = ⋃y∈‖ϕ‖,z∈‖ψ‖{x |
(x, y, z) ∈Rj} = ⋃y∈↓+v∗(ϕ),z∈↓+v∗(ψ){x | (x, y, z) ∈Rj} = ⋃y∈↓+v∗(ϕ),z∈↓+v∗(ψ){↓+
(y ⊗j z)} = ↓+(v∗(ϕ) ⊗j v∗(ψ)) = (by homomorphism of v∗) = ↓+ v∗(ϕ ⊗j ψ).
10. For the binary operators monotonic in second and antitonic in first argument:
suppose that ‖ϕ‖ = ↓+v∗(ϕ) and ‖ψ‖ = ↓+v∗(ψ). Then ‖ϕ ⊗j ψ‖ = {x | ∃y, z ∈
1K((x, y, z) ∈Rj and MK 󳀀󳨐y ϕ and MK 󳀀󳨐z ψ and ∀w ∈1K(MK 󳀀󳨐w ϕ implies
w ≤y))} = {x | ∃y, z ∈1K((x, y, z) ∈Rj and y ∈↓+v∗(ϕ) and z ∈↓+v∗(ψ) and
∀w(w ∈↓+v∗(ϕ) implies w ≤y))} = {x | ∃z((x, v∗(ϕ), z) ∈Rj and z ∈‖ψ‖)} =
⋃z∈‖ψ‖{x | (x, v∗(ϕ), z) ∈Rj} = ⋃z∈↓+v∗(ψ){↓+ (v∗(ϕ) ⊗j z)} = ↓+(v∗(ϕ) ⊗j v∗(ψ)) =
(by homomorphism of v∗) = ↓+ v∗(ϕ ⊗j ψ).
This theorem demonstrates that the satisfaction relation in Definition 65 satisfies
the general property for relational semantics given by point 1 of Definition 61, i. e., that
holds (K, m) 󳀀󳨐x ϕ iff x ∈‖ϕ‖.
Remark. Notice that from this Theorem and (5.16), ‖ϕ‖ =def {x | MK 󳀀󳨐x ϕ} = ↓+(v∗(ϕ)),
we obtain that a formula is accepted by a possible world (satisfied in it) if the truth
value of the formula v∗(ϕ) is equal or bigger than the possible-world (truth) x.
The philosophical assumption of canonical autoreferential sematics is based on
the consideration that each possible world represents a level of credibility, so that only
propositions with the right logic value (i. e., level of credibility) can be accepted by
this world. The canonical autoreferential relational semantics of the Kripke is based
on this principle: each possible world, which has a given credibility can accept only
the formulae which have equal or bigger than that level of credibility (i. e., its truth
value). The bottom truth value in this complete lattice corresponds to the trivial world
in which each formula is satisfied, i. e., to the world with explosive inconsistency (the
world with zero credibility). That is, for each formula ψ holds that MK 󳀀󳨐0 ψ, and hence
0 ∈‖ψ‖.
Notice that in the case when a lattice X is a complete ordering where for any x ∈X,
↓+ x = ↓x (e. g., in the fuzzy logic), then the minimum requirement for an unary modal
operators oi is to be monotonic. We do not require it to be surjective, by defining the
accessibility relation as ℛi = {(oi(x), x) | x ∈X} ⋃{(x, 0) | x ∈X and ∄y(x = oi(y))}.
In that case, we have that MK 󳀀󳨐x ♦iϕ iff ∃y ∈X.((x, y) ∈ℛi and MK 󳀀󳨐y ϕ), iff ∃y ∈
X.(x = oi(y) and MK 󳀀󳨐y ϕ) iff (by inductive hypothesis ‖ϕ‖ = ↓v∗(ϕ)) ∃y ∈X.(x = oi(y)

5.1 Introduction to many-valued logics
|
279
and y ≤↓v∗(ϕ)) iff (from the monotonicity of oi) ∃y ∈X.(x = oi(y) ≤oi(v∗(ϕ))) iff ∃y ∈
X.(x = oi(y) ∈↓oi(v∗(ϕ))) iff (such y exists, at least as 0) x ∈↓oi(v∗(ϕ)) = ↓(v∗(♦iϕ)).
Consequently,
‖♦iϕ‖ = ↓(v∗(♦iϕ)) = ↓+(v∗(♦iϕ)).
From the canonical representation, we obtained that the isomorphism, between the
original algebra A with unary modal operators and its canonical representation alge-
bra AK = A+, corresponds to the representation of any propositional formula ϕ by the
set of worlds ‖ϕ‖ where ϕ is satisfied, in the canonical Kripke model for the algebra A.
So, e. g., the term ϕ∧ψ in the original algebra (A, v) corresponds to the set ‖ϕ‖ ⋂‖ψ‖ in
the canonical algebra (AK, vK), where ‖ϕ‖ is the set of worlds in the canonical Kripke
model in Definition 65, ⟨(1K, ≤), {ℛj}j∈𝒩, {Rj}j∈𝒩, IK⟩with 1K = ̂X, ℛj, where ϕ holds.
As a consequence, we obtained that this simple Kripke model is the model of the
normal modal logic with inference relation ψ ⊢ϕ iff ‖ψ‖ ⊆‖ϕ‖. In fact, ψ ⊢ϕ iff (based
on the truth ordering) v∗(ψ) ≤v∗(ϕ) iff (based on the monotonicity of ↓+)
‖ψ‖ = ↓+(v∗(ψ)) ⊆↓+(v∗(ϕ)) = ‖ϕ‖.
In next section, we will present the canonical autoreferential representation for the
Belnap’s 4-valued logic. More examples will be provided in the next chapter dedicated
to applications of many-valued intensional FOL.
5.1.3 Application to Belnap’s bilattice
In this section, we will apply the results obtained in the previous section to the
4-valued Belnap’s bilattice based logic ℒ. Such a logic is a significant extension of
normal strong Kleene’s 3-valued logic to the paraconsistent type of logics, where we
are able to obtain a nonexplosive inconsistency.
This is a very important class of logics, which is able to deal also with mutually-
inconsistent information, in typical Web data integration of different and independent
source data with mutually inconsistent information [129]. That is the main reason that
we applied a new representation theorem to this case instead of more complex bilat-
tices.
Bilattice theory is a ramification of multivalued logic by considering both truth ≤t
and knowledge ≤k partial orderings. Given two truth values x and y, if x ≤t y then y is
at least as true as x, i. e., x ≤t y iff x <t y or x = y. The negation operation for these two
orderings, ¬ and −, respectively, are defined as the involution operators, which satisfy
De Morgan law between the join and meet operations.
Definition 66 (Ginsberg [197]). A bilattice ℬis defined as a sixtuple (ℬ, ∧, ∨, ⊗, ⊕, ¬),
such that: The t-lattice (ℬ, ≤t, ∧, ∨) and the k-lattice (ℬ, ≤k, ⊗, ⊕) are both complete lat-

280
|
5 Theory of many-valued intensional first-order logic
tices, and ¬ : ℬ→ℬis an involution (¬¬ is the identity) mapping such that ¬ is a
lattice homomorphism from (ℬ, ∧, ∨) to (ℬ, ∨, ∧) and (ℬ, ⊗, ⊕) to itself.
The following definition introduces the subclass of D-bilattices [208] (the Belnap’s
bilattice is the smallest nontrivial D-bilattice). For more information and a more com-
pact definition of D-bilattices and their properties, as well as a number of significant
examples, the reader can use [209].
Definition 67 ([209]). A D-bilattice ℬis a distributive bilattice (ℬ, ∧, ∨, ⊗, ⊕, ¬) with the
isomorphism of truth-knowledge lattices 𝜕: (ℬ, ≤t) ≃(ℬ, ≤k), which is an involution.
Let us define the unary operator −=def 𝜕¬𝜕: ℬ→ℬ. Then we say that a D-lattice
is perfect if two truth negations, the intuitionistic negation ¬t (pseudocomplement),
such that ¬tx = ⋁{z | z∧x = 0}, and the bilattice negation ¬, are correlated by ¬ = ¬t−.
In each D-bilattice (ℬ, ∧, ∨, ⊗, ⊕, ¬), the operator −is self-adjoint modal operator
w. r. t. the ≤t, and the bilattice negation operator for k-lattice satisfy −1k = 0k, −0k = 1k,
while −1 = 1, −0 = 0.
Corollary 18 ([209]). For any D-bilattice ℬ, the duality operator 𝜕can be extended to
the following isomorphism of modal Heyting algebras
𝜕: (ℬ, ≤t, αt) ≃(ℬ, ≤k, αk),
with αt = {∧, ⇀, −} and αk = {⊗, ⇁, ¬}, where ⇀and ⇁are the intuitionistic implications
(the relative pseudo-complements) w. r. t. the ≤t and ≤k, respectively.
Informally, these dual lattices are the modal extensions of Heyting algebras. The
conjugate modal operators are the belief operators. As we will see, they correspond
also to default negations in dual algebras.
The smallest nontrivial D-bilattice is Belnap’s 4-valued bilattice [190], X = ℬ4 =
{t, f, ⊥, ⊤} = {1, 0, ⊥, ⊤} in Figure 5.1, where t = 1 is true, f = 0 is false, ⊤is inconsistent
(both true and false) or possible, and ⊥is unknown. In what follows, we denote by x⋈y
two unrelated elements in X (so that not (x ≤y or y ≤x)).
As Belnap observed, these values can be given two natural orders: truth order, ≤t,
and knowledge order, ≤k, such that f ≤t ⊤≤t t, f ≤t ⊥≤t t, ⊥⋈t ⊤and ⊥≤k f ≤k ⊤,
⊥≤k t ≤k ⊤, f ⋈k t. That is, bottom element 0 for ≤t ordering is f , and for ≤k ordering
is ⊥, and top element 1 for ≤t ordering is t, and for ≤k ordering is ⊤. Meet and join
operators under ≤t are denoted ∧and ∨; they are natural generalizations of the usual
conjunction and disjunction notions. Meet and join under ≤k are denoted ⊗and ⊕,
such that hold: f ⊗t = ⊥, f ⊕t = ⊤, ⊤∧⊥= f and ⊤∨⊥= t.
There is a natural notion of the bilattice truth negation, denoted ¬, (reverses the
≤t ordering, while preserving the ≤k ordering): switching f and t, leaving ⊥and ⊤and
corresponding knowledge negation (conflation), denoted −, (reverses the ≤k ordering,

5.1 Introduction to many-valued logics
|
281
Figure 5.1: Belnap’s bilattice.
while preserving the ≤t ordering), switching ⊥and ⊤, leaving f and t. These two kinds
of negation commute: −¬x = ¬ −x for every member x of a bilattice.
In what follows, we will use the relative pseudo-complements, defined by x ⇀y =
⋁{z | z ∧x ≤t y}, and pseudo-complements, defined by ¬tx =∼x = x ⇀f (and,
analogously, for ≤k ordering, x ⇁y and ¬kx = x ⇁⊥).
The conflation is a monotone function that preserves all finite meets (and joins)
w. r. t. the lattice (ℬ4, ≤t), thus it is the universal (and existential, because −
=
¬ −¬) modal many-valued operator: “it is believed that” for a bilattice (as in ordi-
nary 2-valued logic, the epistemic negation is composition of strong negation ¬t and
this belief operator, ¬ = ¬t−), which extends the 2-valued belief of the autoepistemic
logic as follows:
1.
if A is true than “it is believed that A,” i. e., −A, is true;
2.
if A is false than “it is believed that A” is false;
3.
if A is unknown than “it is believed that A” is inconsistent: it is really inconsistent
to believe in something that is unknown;
4.
if A is inconsistent (that is both true and false) than “it is believed that A” is un-
known: really, we cannot tell nothing about believing in something that is incon-
sistent.
This belief modal operator can be used to define the epistemic(bilattice) negation ¬,
as a composition of strong negation ¬t and this belief operator, i. e., ¬ = ¬t−. That
is, the epistemic negation is negation as a modal operator [210] and as a paraconsis-
tent negation [211]2 Such an autoepistemic intuitionistic logic, based on Belnap’s bi-
2 We can introduce also Moore’s autoepistemic operator [197], μ : ℬ→ℬ, for a Belnap’s bilattice,
defined by μ(x) = t if x ∈{⊤, t}; f otherwise. It is easy to verify that it is monotone w. r. t. the ≤t, that is

282
|
5 Theory of many-valued intensional first-order logic
lattice, (ℬ4, ≤t, ∧, ∨, ¬t, ⇀, −, μ, f, t) can be used for logic programming with incomplete
and partially inconsistent information [129]: in such a logic we use only the epistemic
negation ¬ = ¬t−.
Ginsberg [197] defined a world-based bilattices, considering a collection of
words W, where by world we mean some possible way of things might be the fol-
lowing.
Definition 68. [197] A pair [U, V] ∈𝒫(W) × 𝒫(W) of subsets of W (here 𝒫(W) denotes
the powerset of the set W) express truth of some sentence p, with ≤t, ≤k truth and
knowledge preorders relatively, as follows:
1.
U is a set of worlds where p is true, V is a set of worlds where p is false, P = U ⋂V
is a set where p is inconsistent (both true and false), and W −(U ⋃V) where p is
unknown.
2.
[U, V] ≤t [U1, V1] iff U ⊆U1 and V1 ⊆V
3.
[U, V] ≤k [U1, V1] iff U ⊆U1 and V ⊆V1.
The bilattice operations associated with ≤t and ≤k are:
4.
[U, V] ∧[U1, V1] = [U ⋂U1, V ⋃V1], [U, V] ∨[U1, V1] = [U ⋃U1, V ⋂V1]
5.
[U, V] ⊗[U1, V1] = [U ⋂U1, V ⋂V1], [U, V] ⊕[U1, V1] = [U ⋃U1, V ⋃V1]
6.
¬[U, V] = [V, U].
Let denote by ℬW the set 𝒫(W) × 𝒫(W), then (ℬW, ∧, ∨, ⊗, ⊕, ¬) is a bilattice.
Such definition is well suited for the 3-valued Kleene logic, but for the 4-valued
logic used to overcome “localizable” inconsistencies it is not useful, mainly for two
following reasons:
1.
The inconsistent (both true and false) top knowledge value ⊤in the Belnap’s bilat-
tice can’t be assigned to sentences, otherwise we will obtain an inconsistent logic
theory where all sentences are inconsistent [197]; because of that consistent logics
in this interpretation can have only three remaining values. Thus, we interpret ⊤
as possible value, which will be assigned to mutually inconsistent sentences, in
order to obtain the consistent 4-valued logic theories that overcome such 3-valued
inconsistencies.
2.
Let denote by T = U−P, F = U−P, where P is a set of worlds where p has a possible
logic value. Then we obtain that [U, V] ≤t [U1, V1] also when T ⊃T1, which is in
contrast with our intuition.
The world-based bilattice of Ginsberg, in Definition 68, is not the standard powerset
algebra with a subset ordering relation, ⊆, and set intersection ⋂as meet operation, as
multiplicative (μ(x∧y) = μ(x)∧μ(u) and μ(t) = t) and additive (μ(x∨y) = μ(x)∨μ(u) and μ(f) = f), con-
sequently also it is a self-adjoint (contemporary universal and existential) modal operator, μ = ¬tμ¬t.
Notice that differently from the belief modal operator −, Moore’s modal operator μ is not surjective.

5.1 Introduction to many-valued logics
|
283
the representation theorem requires. As the consequence of this approach, the exist-
ing representation theorem’s isomorphisms for Belnap’s bilattice suffer from the same
kind of deficiency, that is the obtained canonical Belnap’s bilattice algebras are not
powerset algebras.
Because of that we will use the autoreferential semantics for Belnap’s bilattice,
provided in Example 45, Section A.3.2 in the Appendix.
The approach that we will use in order to find the representation theorem for a
Belnap’s billatice, based on the fact that it is a D-bilattice, is different than the standard
one, based on the natural duality theorems [212], (a natural duality for a quasi-variety
gives us a uniform method to represent each algebra in the quasi-variety as the algebra
of all continuous homomorphisms over some structured Boolean space), but close in
spirit to the higher-order Herbrand model types [83].
A many-valued interpretation of a logic ℒin an algebraic model (A, v) = (ℬ4, ≤,
{oi}oi∈𝒪, v) is of the form v : Var →ℬ4, while for its canonical representation algebra,
provided by Proposition 29, (AK, vK) = 𝔼(𝔻((A, v))) and isomorphism (5.10), the inter-
pretation is set-based vK : Var →AK ⊆𝒫(ℬ4). In what follows, we will use both of
these algebras for truth and knowledge ordering of Belnap’s bilattice.
Both latices (ℬ4, ≤t) and (ℬ4, ≤k) are distributive latices, thus, from the Proposi-
tion 28 we obtain that:
1.
For the truth-ordered lattice (ℬ4, ≤t):
ℬ+
t = {↓+ a | a ∈ℬ4} = {{0}, {0, ⊥}, {0, ⊤}, {0, ⊥, ⊤}} ⊆𝒫({0, ⊥, ⊤}),
with bottom 0t = ↓+0 = {0}, and top element 1t = ↓+1 = {0, ⊥, ⊤}.
So, we have the isomorphism (5.10), it = ↓+ : (ℬ4, ≤t) ≃(ℬ+
t , ⊆) ⊂(𝒫(1t), ⊆), such
that it(0) = {0}, it(⊥) = {0, ⊥}, it(⊤) = {0, ⊤} and it(1) = {0, ⊥, ⊤}, which satisfies the
requirement (C)(ii) in Definition 59 for inclusion in ≡it.
2.
For the knowledge-ordered lattice (ℬ4, ≤k):
ℬ+
k = {↓+ a | a ∈ℬ4} = {{⊥}, {⊥, 0}, {⊥, 1}, {⊥, 0, 1}} ⊆𝒫({⊥, 0, 1}),
with bottom 0k = ↓+⊥= {⊥}, and top element 1k = ↓+⊤= {⊥, 0, 1}.
That is, we have the isomorphism (5.10), ik = ↓+ : (ℬ4, ≤k) ≃(ℬ+
k , ⊆) ⊂(𝒫(1k), ⊆),
such that ik(⊥) = {⊥}, ik(f ) = {⊥, 0}, ik(t) = {⊥, 1} and ik(⊤) = {⊥, 0, 1}.
These two lattices (ℬ+
t , ⊆) and (ℬ+
k , ⊆) satisfy the closure property [213] for elements of
these lattices (from Proposition 28), and we are able to define the relative-pseudocom-
plements for them (from Example 31) based on the algebra representation isomor-
phism (5.10) and from (5.11), ⊗+
i =def ↓+ ⊗i (∨× ∨) : X+ × X+ →X+,
⇀+= ↓+ ⇀(⋁× ⋁)
for ℬ+
t ,
and
⇁+= ↓+ ⇁(⋁× ⋁)
for ℬ+
k .

284
|
5 Theory of many-valued intensional first-order logic
Thus, (ℬ+
t , ⊆, {⋂, ⇀+}) and (ℬ+
k , ⊆, {⋂, ⇁+}) are Heyting algebras. The negation is de-
fined by ¬tY = Y ⇀+ 0t for any Y ∈ℬ+
t , and by ¬kY = Y ⇁+ 0k for any Y ∈ℬ+
k , re-
spectively. But as Halmos has shown [37], in the structures as (ℬ+
t , ⊆) (and also (ℬ+
k , ⊆))
each closed element is also open and can support also the modal operator ⬦conjugate
to itself. This is exactly our case.
Proposition 30. Let ⬦t and ⬦k be two operators on sets such that for a given set Y ∈
𝒫(1t),
⬦tY = {−x | x ∈Y},
and for Y ∈𝒫(1k),
⬦kY = {¬y | y ∈Y}.
Then (𝒫(1t), ⊆, {⋂, ⇀+, ⬦t}) and (𝒫(1k), ⊆, {⋂, ⇁+, ⬦k}) are modal extensions of Heyting
algebras. Their restriction on ℬ+
t and ℬ+
k are ⬦t = ↓+−⋁, ⬦k = ↓+¬ ⋁, and (ℬ+
t , ⊆, {⋂, ⇀+,
⬦t}) and (ℬ+
k , ⊆, {⋂, ⇁+, ⬦k}) are modal Heyting algebras.
Proof. We have that ⬦t({0}) = {−0} = {0}, so ⬦t is normal modal operator, and for any
two sets Z, Y ∈𝒫(1t), ⬦t(Z ⋃Y) = {−x | x ∈Z ⋃Y} = {−x | x ∈Z or x ∈Y} = {−x | x ∈
Z} ⋃{−x | x ∈Y} = ⬦t(Z) ⋃⬦t(Y), i. e., ⬦t is additive.
It is easy to show that for any Y ∈ℬ+
t , ⬦tY = ¬t ⬦t ¬tY = ◻tY ∈ℬ+
t , thus ⬦t ≡◻t,
i. e., it is conjugate to yourself. The same holds for ⬦k w. r. t. ℬ+
k , thus (ℬ+
t , ⊆, {⋂, ⇀+,
⬦t}) and (ℬ+
t , ⊆, {⋂, ⇁+, ⬦k}) are modal Heyting subalgebras of (𝒫(1t), ⊆, {⋂, ⇀+, ⬦t})
and (𝒫(1k), ⊆, {⋂, ⇁+, ⬦k}), respectively.
From Definition 63, we can define the accessibility relations for these two modal
operators used in truth and knowledge algebras in proposition above, for autorefer-
ential Kripke semantics. Thus, for Kripke frames of these modal Heyting algebras we
have that Kt = (1t, ≤t, R−), where for the modal operator ⬦t the accessibility relation is
ℛ−= {(x, y) | y ∈1t, and x ∈↓+ −(y)} = {(0, 0), (0, ⊥), (⊤, ⊥), (0, ⊤), (⊥, ⊤)}.
Dually, for knowledge ordering we obtain the Kripke frame Kk = (1k, ≤k, R¬), where for
a modal operator ⬦k the accessibility relation is
ℛ¬ = {(x, y) | y ∈1k, and x ∈↓+¬(y)} = {(⊥, ⊥), (⊥, 0), (1, 0), (⊥, 1), (0, 1)}.
It is easy to verify that these two Kripke frames are dual, i. e., 𝜕P : Kt ≃Kk.
Notice that we do not represent the bilattice negation ¬ as an independent modal
negation operator (in the truth-ordering lattice) with an incompatibility relation
(5.13) ℛ¬, because in Belnap’s bilattice it is derived as the composition ¬ = −¬t = ¬t−
of the selfadjoint (existential and universal) operator −(conflation) and pseudo-
complement ¬t. It is represented as self-adjoint modal operator in dual (knowledge
ordering) lattice instead.

5.1 Introduction to many-valued logics
|
285
Thus, for an intuitionistic autoepistemic 4-valued logic ℒ= (Var, {∧, ⇒, ♭}, ⊪),
where ⇒is the intuitionistic implication and ♭the belief modal operator, we have the
following.
Theorem 10 (Canonical representation for dual Heyting algebras of Belnap’s bilattice).
Let 𝜕: (ℬ4, ≤t, αt) ≅(ℬ4, ≤k, αk) be a D-bilattice isomorphism for Belnap’s bilattice ℬ,
with αt = {∧, ⇀, −} and αk = {⊗, ⇁, ¬}, and v : Var →ℬbe a many-valued interpretation
of intuitionistic autoepistemic logic ℒ= (Var, {∧, ⇒, ♭}, ⊪).
Let the isomorphism 𝜕𝒫be the extension of the isomorphism 𝜕to sets, i. e., for any
set Y ∈𝒫(1t), 𝜕𝒫Y = {𝜕x | x ∈Y} ∈𝒫(1k), while 𝜕∗
𝒫be its reduction to ℬ+
t and ℬ+
k
respectively. Then the following commutative diagram, where v′ = 𝜕v, vK = ↓+
tv, v′
K =
↓+
kv′, ℬ+
k = 𝜕∗
𝒫(ℬ+
t ), 1k = 𝜕𝒫(1t), for algebraic models of ℒholds
((ℬ4, ≤t, αt), v)
𝜕
? ((ℬ4, ≤k, αk), v′)
((ℬ+
t , {⋂, ⇀+, ⬦t}), vK)
↓+
t
?
𝜕∗
𝒫
? ((ℬ+
k , {⋂, ⇁+, ⬦k}), v′
K)
↓+
k
?
((𝒫(1t), {⋂, ⇀+, ⬦t}), vK)
int
?
𝜕𝒫
? ((𝒫(1k), {⋂, ⇁+, ⬦k}), v′
K)
ink
?
(𝔼∘𝔻)((ℬ4, ≤t, αt), v)
=
?
𝜕𝒫
? (𝔼∘𝔻)((ℬ4, ≤k, αk), v′)
=
?
where int, ink are injective homomorphisms, and ↓+
t , ↓+
k are the isomorphisms of ↓+
w. r. t. the truth and knowledge ordering, respectively.
Proof. It is easy to verify, based on Propositions 28, 29, 30 and Definition 67. Let us
consider a simple case, for the term ⊥∧⊤∈(ℬ4, ≤t, {∧, ⇀, −}). Then (𝜕∗
𝒫↓+
t )(⊥∧⊤) =
𝜕∗
𝒫({0, ⊥} ⋂{0, ⊤}) = {⊥, 0} ⋂{⊥, 1} = {⊥} = ↓+
k(0 ⊗1) = (↓+
k 𝜕)(⊥∧⊤).
In this diagram, we have to consider the horizontal arrows as a D-bilattice, from up
to down: Belnap’s original D-bilattice, its set-based isomorphic representation, and its
powerset extension. Notice that all arrows (homomorphism between modal Heyting
algebras) of the commutative diagram on the top are isomorphisms. The lower part
of the commutative diagram represents the fact that the modal Heyting algebras of
isomorphic representations are the subalgebras of the powerset extensions.

286
|
5 Theory of many-valued intensional first-order logic
5.2 General many-valued intensional first-order logic with
abstraction operator
In this section, we will consider the many-valued logic directly, instead by using
method of ontological encapsulation of many-valued logic provided by Section A.4.2
in the Appendix.3 So, the basic issue of the work in this section is a definition of
such a many-valued logic by generalization of the standard FOL, able to distinguish
the intensional and extensional aspects of the semantics and adopting only a trivial
equality theory of intensions for many-valued logics. The distinction between inten-
sions and extensions is important, considering that extensions can be notoriously
difficult to handle in an efficient manner. The extensional equality theory of predi-
cates and functions under higher-order semantics (e. g., for two predicates with the
same set of attributes p = q is true iff these symbols are interpreted by the same re-
lation), i. e., the strong equational theory of intensions, is not decidable, in general.
However, different from 2-valued logic where extension of a given predicate is com-
posed by only true atoms, here for MV-logics the ground atoms of extension of this
predicate can have all truth values except the false value. Thus, separating intensions
from extensions makes it possible to have an equational theory over predicate and
function names (intensions) that is separate from the extensional equality of relations
and functions.
The intensional predicate logic described in Section 1.2 is developed in the classic
2-valued framework. Consequently, we need to generalize such a framework and the
theory of the PRP intensionality for the case of predicate many-valued logics, based
on the complete (important for the semantics of many-valued existential and univer-
sal quantifiers) lattice (X, ≤, ̃∧, ̃∨) of algebraic truth values, with f , t the bottom and top
value, respectively, and with other many-valued logic connectives (e. g., ∼, ⇒, nega-
tion and implication respectively). We denote by 2 = {f, t} ⊆X the classic 2-valued logic
lattice. The smallest paraconsistent many-valued extension can be, e. g., an extension
of the strong Kleene’s 3-valued logic [214, 215], able to deal with Lear paradoxes.
5.2.1 Many-valued algebra of concepts and extensions: embedding of DL
Concept languages steam from semantic networks [45–47], which for a large group of
graphical languages used in the 1970s to represent and reason with conceptual knowl-
3 Moreover, in Section 2.2 we used an ad hoc solution for representation of the multivalued logic
for logic formulae by introducing a particular binary predicate wN(⋖ϕi⋗, x) that express the fact “the
sentence ϕi has a probability value x,” so that we remain in the framework of the classical two valued
logics (the ground atoms of this binary predicate wN can be only true o false). In fact, such a logic is
not really many-valued but indirectly speaks about values of the formulae, and was a good solution to
reason about the probabilities.

5.2 General many-valued intensional first-order logic with abstraction operator
|
287
edge. But they did not have a rigorously defined statement as emphasized by Brach-
man and Levesque [48, 49]. After that, different versions of description logics [50] with
formal semantics appeared, as a family of knowledge representation formalisms that
represent the knowledge of an application domain by first defining the relevant con-
cepts and roles as a terminology (TBox) and then the assertions (ABox) about named
individuals in terms of this terminology. The concepts denote sets of individuals, and
roles denote binary relationships between individuals.
Example 33 (Description Logic (DL)). In what follows, we will consider the attribute
language with complements, 𝒜ℒ𝒞, with a set of atomic concepts and roles denoted by
at and r, respectively. Concept descriptions, denoted by u, v, . . . , in 𝒜ℒ𝒞, introduced
in [216], are formed according to the following current form variable-free DL syntax:
u := at | ⊤| ⊥| ¬u | u1 ⊓u2 | ∀r.u | ∃r.u
An extensional interpretation ℐe for 𝒜ℒ𝒞concepts consist of a nonempty set 𝒟(do-
main of interpretation) and an interpretation function, which assigns to every atomic
(basic) concept at its extension ℐe(at), denoted as a set atℐe ⊆𝒟, and to every atomic
role r a binary relation rℐe = ℐe(r) ⊆𝒟× 𝒟. If we consider concepts as intensional
entities, then ℐe can be considered as a possible extensionalization mapping, which
for a given context (or “possible world”) determines the extension of this concept in
that context. The extensional interpretation is extended to concepts descriptions by
the following inductive definitions.
Definition 69 (DL semantics).
⊤ℐe = 𝒟,
for universal concept,
⊥ℐe = 0,
empty set for bottom (inconsistent) concept,
(¬u)ℐe = 𝒟\uℐe,
where \ is a set difference,
(u1 ⊓u2)ℐe = uℐe
1 ⋂uℐe
2 ,
(∀r.u)ℐe = {a ∈𝒟| ∀b.(a, b) ∈rℐe implies b ∈uℐe},
for value restriction,
(∃r.u)ℐe = {a ∈𝒟| ∃b.(a, b) ∈rℐe and b ∈uℐe},
for full existential quantification.
It is easy to verify that ⊥stands for ¬⊤, ∃r.u stands for ¬(∀r.(¬u)), and we can
introduce concept disjunction u⊔v as abbreviation for ¬(¬u⊓¬v). In fact, for this spe-
cial variable-free syntax (differently from predicate logics with variables) without any
reference to logic truth values, is more appropriate the name ‘concept algebra” then
description logic, analogously to the difference between relation algebra and predicate
logic.
Two concepts u1, u2 are equivalent, u1 ≡u2, if uℐe
1
= uℐe
2
for all interpretations;
a concept u is subsumed by a concept u1, u ⊑u1, if uℐe ⊆uℐe
1 for all interpretations.

288
|
5 Theory of many-valued intensional first-order logic
A TBox, or terminology, 𝒯is a set of axioms: concept descriptions u ≡ϕ and
subsumptions u ⊑ϕ, where ϕ is an expression of the concept language 𝒜ℒ𝒞. A base
interpretation of 𝒯is an interpretation for atomic concepts only. If this interpretation
can be extended to all derived concepts in 𝒯in a unique way then it is a model of a
terminology 𝒯. A concept u is satisfiable w. r. t. the TBox 𝒯if there exists a model ℐe
of 𝒯such that uℐe is nonempty.
Using conceptsu and rolesr, one can makeassertions ofthefollowingtwokinds in
an ABox: u(a), r(a, b), where a, b are any two individuals. In a simplified view, an ABox
can be seen as an instance of a relational database with only unary or binary relations.
However, contrary to the “closed-world assumption” (CWA) semantics of relational
databases, the semantics of ABoxes is an “open-world semantics” (OWA): it means
that we cannot assume that the knowledge is complete, different from a relational
database where a missed information is considered as false. That is, we have 3-valued
logic with third “unknown” truth value as well (as Kleene’s 3-valued logic).
An interpretation ℐe satisfies the concept assertion u(a) if aℐe ∈uℐe, and satisfies
the role assertion r(a, b) if (aℐe, bℐe) ∈rℐe. It is a model of an ABox 𝒜if it satisfies each
assertion in 𝒜. Finally, ℐe satisfies an assertion α or an ABox 𝒜with respect to a TBox
𝒯if in addition to being a model of α or of 𝒜, it is a model of 𝒯.
Different from standard 2-valued logics where we are using the logic concepts of
truth and falsity, in DL we are using only the concept of satisfaction: indeed it is an
algebra for concepts and relationships between them. Its logic translation into predi-
cate logic demonstrates that it is a 2-variable sublogic of FOL, where the concepts are
unary predicates, and roles are binary predicates. In this paper, we will see how this
DL algebra of concepts can be embedded into the algebra of concepts of many-valued
intensional predicate logic.
The description logic for databases 𝒟ℒℛ[50] extends the basic DL with n-ary re-
lations, n ≥3, with also two new syntax expressions, ($i/n : u) and ∃($i)r, with the
following semantics:
1.
($i/n : u) denotes all tuples of arity n in which the i-th component is an instance of
concept u, and thus represents a unary selection. It can be used in order to define
n-ary concept u from given set of unary (standard DL) concepts uk, 1 ≤k ≤n, by
description
u ≡($1/n : u1) ⊓⋅⋅⋅⊓($n/n : un),
which can be used to represent a Database n-ary relation.
2.
∃($i)r denotes all objects that participate as i-th component in an tuple of rela-
tion r, and thus represents a unary projection. Consequently, it is inverse to the
first operator and transforms n-ary roles into standard DL unary concepts, so that
the following description is an axiom: r ≡($1/n : ∃($1)r) ⊓⋅⋅⋅⊓($n/n : ∃($n)r),
for any n-ary role r.

5.2 General many-valued intensional first-order logic with abstraction operator
|
289
There are many aspects of description logics, which we have not considered here,
because they are not important for the present work. For example, we recall the
expressive description logics 𝒮ℋℐℱ(D) and 𝒮ℋ𝒪ℐ𝒩(D), which stand behind the
Web ontology languages OWL Lite and OWL DL [93, 217], respectively.
What we need here is a generalization of the extension for predicates in standard
2-valued logics, into an m-extension for predicates in the framework of many-valued
logics. In standard predicate logic with a set of predicate symbols in P, the extension
of any k-ary, k ≥1, predicate rk
i ∈P is determined by a given Herbrand interpretation
v : H →2, where H is a Herbrand base and 2 = {f , t} set of classic truth values, by
‖rk
i ‖ = {(t1, . . . , tk) | rk
i (t1, . . . , tk) ∈H and v(rk
i (t1, . . . , tk)) = t}
vice versa, given the extensions of all predicates, then the Herbrand interpretation
v : H →2 is determined by, for any rk
i (t1, . . . , tk) ∈H,
v(rk
i (t1, . . . , tk)) = t
if (t1, . . . , tk) ∈‖rk
i ‖;
f, otherwise.
In what follows, we will consider only conservative homomorphic many-valued ex-
tensions of the classic 2-valued logic with logical connectives ∧, ∨, ¬, ⇒, ≡(conjunc-
tion, disjunction, negation, implication and equivalence, respectively)and their corre-
sponding operators ̃∧, ̃∨, ∼, 󴁃󴀢and ⇔of the algebra of truth values in the lattice (X, ≤).
Definition 70. For a given many-valued predicate logic, by 𝒜mv = (X, ≤, ∼̃∧, ̃∨, 󴁃󴀢, ⇔)
we denote the algebra of the truth values in the complete lattice (X, ≤). The conjunction
“̃∧” and disjunction “̃∨” operators of this MV truth-algebra may be different from the
meet and join operator of the complete lattice X of truth values as well.4
We assume that there exist an element κ ∈X such that ∼κ = κ, where “∼” is
the unary antitonic negation operator, and the many-valued equivalence operator is
defined for any two a, b ∈X by
a ⇔b = { t,
if a = b
f,
otherwise
(5.17)
Note that differently from the 2-valued intensional logic introduced in Chapter 1, here
the bottom value f and top value t are not represented by 𝒫(D0) = 𝒫({⟨⟩}), i. e., f
̸= 0
and t
̸= ⟨⟩.
The fact that classic 2-valued algebra is the subalgebra of this many-valued al-
gebra X, means that X is a conservative extension of the classic logic operators, and
4 The classic 2-valued algebra 𝒜2 is particular case with lattice 2 = {f, t} and if 2 ⊂X (the top and
bottom elements in X).

290
|
5 Theory of many-valued intensional first-order logic
consequently, we have that for every a ∈X, f ≤a ≤t and ∼f = t, ∼t = f. This ex-
tension has to preserve the antitonic property for the negation operator ∼as well: for
example, from the fact that f < κ < t we obtain that t =∼f >∼κ = κ >∼t = f .
For example, the minimal 3-valued extension of the classic 2-valued logic is the
strong Kleene’s 3-valued logic with X = ℬ3 = {f < κ < t} where κ is considered as
“unknown” truth value, or its extension to Belnap’s 4-valued bilattice ℬ4 described
in Section 5.1.3. We define a m-extension (many-valued extension), denoted by ‖ _ ‖m,
which takes the logic values in its representation explicitly, as follows:
‖rk
i ‖m = {(t1, . . . , tk, a) | rk
i (t1, . . . , tk) ∈H and a = v(rk
i (t1, . . . , tk))
̸= f}
(5.18)
It is easy to verify that for the classic 2-valued predicate logic these two representations
of an extension, are equivalent, i. e., given standard extension ‖rk
i ‖ we derive that its
m-extension is equal to ‖rk
i ‖m = {(t1, . . . , tk, t) | (t1, . . . , tk) ∈‖rk
i ‖}. Otherwise, given an
m-extension ‖rk
i ‖m, we derive a standard extension by ‖rk
i ‖ = {(t1, . . . , tk) | (t1, . . . , tk, t) ∈
‖rk
i ‖m} = π−k−1(‖rk
i ‖m), where π−i, i ≥1 is the operation that eliminates i-th column of a
relation, while πi denotes i-th projection.
In any given m-valued predicate logic, where m ≥3 is a set of algebraic truth val-
ues in X, we can use only m-extensions which is an alternative specification of many-
valued Herbrand interpretation v : H →X, as we have shown above. That is, for any
rk
i (t1, . . . , tk) ∈H,
v(rk
i (t1, . . . , tk)) = { a,
if (t1, . . . , tk, a) ∈‖rk
i ‖m
f ,
otherwise
(5.19)
So that a many-valued extension is just the extension of an ontologically encapsuled
meta 2-valued logic, as presented in [218].
We assume that a concept algebra has a nonempty domain 𝒟= D0 + DI, (here +
is a disjoint union) where a subdomain D0 is made of particulars or individuals (we
denote by ® the non-meaning individuals, for interpretation of language entities that
are no meaningful, as “Unicorn” for example) with X ⊆D0.
The rest DI = D1+D2 . . .+Dn . . . is made of universals (concepts): D1 for many-valued
logic concepts, or L-concepts (their extension corresponds to some logic value), and
Dn, n ≥2, for concepts (their m-extension is an n-ary relation); we consider the prop-
erty (for an unary predicate) as a concept in D2. The concepts in 𝒟I are denoted by
u, v, . . . , while the values (individuals) in D0 by a, b, . . . .
Remark. Notice that all concepts in Di, i ≥2 corresponds to the ontologically en-
capsuled virtual predicates (as in the case of the ontological encapsulation of many-
valued atoms pn−1
i
(x1, . . . , xn−1) by extending them with another attribute to obtain ex-
tended 2-valued “flattened” atom pF(x1, . . . , xn−1, y) where domain of y is the set of
logic-values in X, in Section A.4.2).

5.2 General many-valued intensional first-order logic with abstraction operator
|
291
So, for a given assignment g ∈𝒟𝒱, and valuation (from Definition 62, Section 5.1.1)
v∗: ℒG
mv →X, where ℒG
mv is the set of sentences of the many-valued predicate logic
ℒmv, the ground many-valued atom pn−1
i
(g(x1), . . . , g(xn−1)) is substituted by the true
“flattened” atom pF(g(x1), . . . , g(xn−1), a) where a ∈X. If a = v(pn−1
i
(g(x1), . . . , g(xn−1)))
then this flattened atom pF(g(x1), . . . , g(xn−1), a) is true; false otherwise (as explained
in Section A.4.2 in the Appendix).
In this way, the last (k + 1)th attribute of the extension of any concept in Dk+1,
k ≥1, will have the assigned logic value to the original many-valued k-ary concept of
the many-valued predicate logic ℒmv for a given valuation v.
Sort S is a subset of a domain 𝒟. For example, X ⊂D0 is a many-valued-logic sort,
2 ⊆X is a classic-logic sort, [0, 1] ⊂D0 is closed-interval-of-reals sort, ℕ= {1, 2, 3, . . .} ⊂
D0 is a sort of positive integers, etc. These sorts are used for sorted variables in many-
sorted predicate logics so that the assigned values for each sorted variable must be-
long to its sort. The unsorted variables are the variables with a top sort equal to 𝒟.
Definition 71 (m-sorted extensions). We define the set of all m-extensions in the
many-sorted framework of universals,
Rm = ̃X ⋃{R ∈⋃
n≥1
𝒫(𝒟n × (X\{f })) | (u1, . . . , un, a), (u1, . . . , un, b) ∈R implies b = a}
(5.20)
so that each (n + 1)-ary relation is a graph of a function, and by Rmk, k ≥1, we will
denote the subset of all k-ary relations in Rm, and by 0 each empty relation in Rm,
with
̃X = {{a} | a ∈X and a
̸= f} ⋃{0}
(5.21)
and hence, 0 ∈̃X ⊂𝒫(X) ⊆𝒫(D0), with Rm1 = ̃X. So, (̃X, ⪯) is complete lattice with 0
bottom element and {a} ⪯{b} iff a ≤b, with the isomorphism of two lattices
inX : (X, ≤) →(̃X, ⪯),
such that inX(f ) = 0, and for all a
̸= f , inX(a) = {a}
Note that for an open formula ϕ(x1, . . . , xk) and any many-valued interpretation
v : H →X the relation R = I∗
mv(ϕ(x1, . . . , xk)) =def {(g(x1), . . . , g(xk), a) | g ∈𝒟𝒱and
a = v∗(ϕ/g)
̸= f} (see equation (5.31) and Theorem 11) is just one particular relation in
Rm.
We introduce for the concepts in DI an extensional interpretation h, which assigns
the m-extension to each intensional element in 𝒟, and can be considered as an in-
terpretation of concepts in 𝒟. Thus, each concept in DI represents a set of tuples in 𝒟,
and can be also an element of the extension of another concept and of itself also. Each

292
|
5 Theory of many-valued intensional first-order logic
extensional interpretation h assigns to the intensional elements of 𝒟(with image of in-
tensional interpretation I) an appropriate extension: in the case of particulars u ∈D0,
h0(u) ∈D0, such that for each logic value a ∈X ⊂D0, h0(a) = a. Thus, we have the par-
ticular’s mapping h0 : D0 →D0 and more generally (here + is considered as disjoint
union),
h = ∑
i∈ℕ
hi : 𝒟󳨀→D0 + ∑
i≥1
Rmi
(5.22)
where h1 : D1 →̃X assigns to each sentence u ∈D1 a relation (composed by the single
tuple h1(u) = {a} with a truth value a ∈X if a
̸= f), 0 otherwise, and hi : Di →Rmi,
i ≥2, assigns a m-extension to all concepts.
Definition 72 (Built-in concepts). Let ℰin be a fixed subset of extensionalization func-
tions (in what follows, we will consider the set of all well-defined extensionalization
functions for the many-valued intensional FOL ℒin, specified by Definitions 76 and 77).
We say that a given concept u ∈DI is a built-in concept if its extension is invari-
ant w. r. t. extensionalization functions. It is the case of elementary datatypes or data
values (used also in DL) as the “Natural-number,” “Real-number,” “Truth-value” that
are concepts in D2 such that for ℕ⊂D0 and X ⊂D0,
h2(Natural number) = {(n, t) | n ∈ℕ},
h2(Truth value) = {(a, t) | a ∈X}.
We define a number of another most used built-in concepts:
1.
We introduce the following many-valuedness assumptions for intensional ele-
ments in 𝒟and their extensionalization functions: for any algebraic truth value
a ∈X, we introduce a built-in truth-concept ua ∈D1 such that if a
̸= f,
∀h ∈ℰin(h(ua) = {a})
and
∀h ∈ℰin(h(uf ) = 0).
2.
The universal and bottom (inconsistent) unary DL concept ⊤, ⊥∈D2, respectively,
satisfy that for every h ∈ℰin, h(⊤) = 𝒟× {t} and h(⊥) = 0.
3.
The corresponding concept to the binary identity predicate = used in FOL is de-
noted by the symbol Id ∈D3. We have that for this “concept of identity” Id, its
m-extension is constant and 2-valued in every extensionalization function hℰin,
i. e.,
h(Id) = R= = {(u, v, t) | u, v ∈Dk, k ≥0 such that u = v in FOL}.
4.
The corresponding concept to the binary weak-intensional-equivalence predicate
=in is denoted by the symbol Eq ∈D3. We have that for this “concept of weak-

5.2 General many-valued intensional first-order logic with abstraction operator
|
293
intensional-equivalence” Eq, its m-extension is constant and 2-valued in every
extensionalization function h, i. e.,5
h(Eq) = R=in = {(u, v, t) | u, v ∈Dk, k ≥2 and ⋃
h∈ℰin
h(u) = ⋃
h∈ℰin
h(v)}
Another important concept that has a specific semantics, but is not built-in con-
cepts is the self-reference truth-concept uT ∈D2, such that for any particular exten-
sionalization function h we have that h(uT) = {(u, a) | u ∈D1, 0
̸= h(u) = {a}}. This
concept represents the truth of all logic-concepts in D1, in the way that for any logic-
concept u ∈D1 we have that h(u) = {a} iff (u, a) ∈h(uT).
We define the following partial ordering ⪯for the m-extensions in Rm.
Definition 73 (Extensional partial order in Rm). For any two m-relations R1, R2 ∈Rm
with arity k1 = ar(R1), k2 = ar(R2) and m = max(k1, k2), R1 ⪯R2 iff
for each (u1, . . . , um, a) ∈Ex(R1, m),
∃(u1, . . . , um, b) ∈Ex(R2, m)
with a ≤b,
where this expansion-mapping Ex : Rm →Rm is defined as follows for any R ∈Rm:
Ex(R, m) = { ⋃{{(u1, . . . , uk)} × 𝒟m−k × {a} | (u1, . . . , uk, a) ∈R},
if m > k
R,
otherwise
(5.23)
We denote by R1 ≃R2 iff R1 ⪯R2 and R2 ⪯R1, the equivalence relation between
m-extensions. We define the completion of R ∈Rm with i = ar(R) ≥1 by
Com(R) =
{
{
{
{
{
R ⋃{(v1, . . . , vi−1, f) | (v1, . . . , vi−1) ∉π−i(R) or R = 0},
if i ≥2
{f },
if R = 0
R,
otherwise
(5.24)
It is easy to verify that Ex is monotonic operation w. r. t. to the ordering ⪯, i. e., if
R1 ⪯R2 then Ex(R1, m) ⪯Ex(R2, m) for every m ∈ℕ.
We chose 0, {t} ∈Rm to be the representative elements of the bottom and top
equivalence classes in Rm relatively (determined by ≃), so that (∀R ∈Rm)(0 ⪯R ⪯{t}).
Consequently, the extensional ordering ⪯in Rm is the resulting consequence of the
logic truth ordering ≤in X where we have the analog result (∀a ∈X)(f ≤a ≤t).
5 This definition is a many-valued generalization of the flat-accumulation case presented in [43, 53,
105] for the 2-valued FOL: if the first predicate is true in some interpretation (or “possible world”)
h ∈ℰin then the second must be true in some interpretation h′ ∈ℰin as well, and vice versa. It has
been used successively in the intensional 2-valued FOL [42, 58, 219] for the semantic Web and P2P
data integration, but differently, by introducing a new existential modal S5 operator in that logical
language (here we avoided the introduction of this modal operator).

294
|
5 Theory of many-valued intensional first-order logic
In what follows, for each set of couples of indexes S ∈𝒫(ℕ2), the binary operation
⋈S is the natural join from relational database algebra if S is a nonempty set of pairs of
joined columns of respective relations (where the first argument is the column index
of the relation R1 while the second argument is the column index of the joined column
of the relation R2); otherwise it is equal to the cartesian product ×. We can define an
m-extensional algebra over the poset (Rm, ⪯) as follows.
Definition 74. Let us define the m-extensional relational algebra for a given truth-
values algebra 𝒜mv = (X, ≤, ∼, ̃∧, ̃∨, 󴁃󴀢) of Definition 70 by
𝒜Rm = ((Rm, ⪯, 0, {t}), R=, ⊘, {⊗S, ⊕S, ⊖S}S∈𝒫(ℕ2), {⊞i, ⊠i, ⋞i, ⋟i}i∈ℕ, Inc,
{⊳i,a, ⊲k
i,a}i≤k∈ℕ&f ̸=a∈X),
where R= is the binary relation for extensionally equal elements. We will use “=” for
the extensional identity for relations in Rm, and relation-completion mapping Com :
Rm →Rm in (5.24). The unary operators ⊘, ⊞i, ⊠i, ⋞i, ⋟i: Rm →Rm, and binary opera-
tors ⊗S, ⊕S, ⊖S, Inc : Rm2 →Rm, and particular DL-unary operators ⊳i,a: (Rm\Rm1) →
Rm2 and ⊲k
i,a: Rm2 →Rm, are defined as follows:
1.
For negation ⊘:
1.1 ⊘(R) = {∼a | {a} = R, ∼a
̸= f }, for ar(R) = 1.
1.2 ⊘(R) = {(v1, . . . , vi−1, ∼a) | (v1, . . . , vi−1, a) ∈Com(R), ∼a
̸= f}, for i = ar(R) ≥2.
2.
For any pair (⊙, ∘) ∈{(⊗S, ̃∧), (⊕S, ̃∨), (⊖S, 󴁃󴀢)}:
2.1 R1 ⊙R2 = {a ∘b | {a} = Com(R1), {b} = Com(R2) and a ∘b
̸= f }, for ar(R1) =
ar(R2) = 1 and S is the empty set.
2.2 R1 ⊙R2 = {(v1, . . . , vi−1, a ∘b) | (v1, . . . , vi−1, a) ∈Com(R1), {b} ∈Com(R2) and
a ∘b
̸= f }, for ar(R1) = i ≥2, ar(R2) = 1 and S is the empty set.
2.3 R1 ⊙R2 = {(v1, . . . , vi−1, a ∘b) | {a} ∈Com(R1), (v1, . . . , vi−1, b) ∈Com(R2) and
a ∘b
̸= f }, for ar(R1) = 1, ar(R2) = i ≥2 and S is the empty set.
2.4 Otherwise, let i = ar(R1) ≥2, ar(R2) ≥2, and from Definition 9, binary operator
⋈S : Rm×Rm →Rm, such that for any two relations R1, R2 ∈Rm, the R1 ⋈S R2
is equal to the relation obtained by natural join of these two relations if S is a
nonempty set of pairs of joined columns of respective relations (where the first
argument is the column index of the relation R1 while the second argument
is the column index of the joined column of the relation R2); otherwise it is
equal to the Cartesian product R1 × R2. Then R1 ⊙R2 = {(v1, . . . , vk, a ∘b) |
((v1, . . . , vi−1, a, vi, . . . , vk, b) ∈Com(R1)⋈S Com(R2) with (v1, . . . , vi−1, a) ∈R1 and
(vi, . . . , vk, b) is a (also empty) subtuple of R2 without elements in π2(S)) and
a ∘b
̸= f }.6
3.
For quantifiers ⊞i and ⊠i, (here “⋀” and “⋁” are the meet and join operators in
lattice of truth values X, respectively):
6 Note that in the case of the two-valued logic, we obtain that R1 ⊙R2 = (R1 ⋈S R2) × {t}.

5.2 General many-valued intensional first-order logic with abstraction operator
|
295
3.1 ⊞i(R) = ⊠i(R) = R, for ar(R) = 1.
3.2 ⊞i(R) = {b | if b = ⋁{a | (v, a) ∈Com(R)}
̸= f} if i = 1; R otherwise, ⊠i(R) = {b |
if b = ⋀{a | (v, a) ∈Com(R)}
̸= f} if i = 1; R otherwise, for ar(R) = 2.
3.3 ⊞i(R) = {(v1, . . . , vi−1, vi+1, . . . , vk, b) | if b = ⋁{a | (v1, . . . , vk, a) ∈Com(R)}
̸=
f } if 1 ≤i ≤k; R otherwise, ⊠i(R) = {(v1, . . . , vi−1, vi+1, . . . , vk, b) | if b = ⋀{a |
(v1, . . . , vk, a) ∈Com(R)}
̸= f } if 1 ≤i ≤k; R otherwise, for ar(R) ≥3.
4.
Control cardinality, where |R| denote the cardinality of R:
⋞i (R) = {t}
if |R| ≤i;
0 otherwise,
⋟i (R) = {t}
if |R| ≥i;
0 otherwise.
5.
Inclusion Inc(R1, R2) = {t} if ar(R1) = ar(R2) and there is a relation R′
2 obtained by
a permutation of columns in R2 such that R1 ⊆R′
2; 0 otherwise.
6.
⊳i,a (R) = {(vi, t) | (v1, . . . , vi, . . . , vk, a) ∈R} if i ≤k; empty binary m-relation
otherwise.
7.
⊲k
i,a (R) = {(v1, . . . , vi, . . . , vk, t) | (vi, a) ∈R and vm ∈𝒟, m
̸= i, 1 ≤m ≤k}.
Notice that definition of operators ⊞i, ⊠i are valid because X is complete lattice.
We define the following binary derived operator ⊛= ⊗(Inc( _ ), Inc(( _ )−1)) :
Rm2 →Rm, so that ⊛(R1, R2) = ⊗(Inc( _ ), Inc(( _ )−1))(R1, R2) = ⊗(Inc(R1, R2), Inc((R1,
R2)−1)) = ⊗(Inc(R1, R2), Inc(R2, R1)) ∈{0, {t}}.
Moreover, we define the many-valued-ISA relationship for concepts in u, v ∈DI by
u ⊑v iff for all h, (h(u) ⪯h(v)), which is a generalization of the ISA relationship in DL.
The strong intensional equality, denoted by u ≗v (i. e., (u, v) ∈≗), holds if (u ⊑v) and
(v ⊑u). We introduce the following algebra for concepts, that is conservative extension
of Concept language used in DL, and able to support the intensional semantics for the
FOL.
Definition 75. Algebra for concepts is a structure
𝒜mint = ⟨(𝒟, ⊑, uf , ut), Id, ̃¬, {⊓S, ⊔S, ⇒S}S∈𝒫(ℕ2), ↔, {∃i, ∀i, ≤i, ≥i, predi}i∈ℕ,
{∃($i, a), k($i, a)}i≤k∈ℕ&f ̸=a∈X⟩,
with unary negation, exists, for all and cardinality restriction operations ̃¬, ∃i, ∀i,
≤i, ≥i: DI →DI, binary operation for the intersection, union and implication of con-
cepts ⊓S, ⊔S, ⇒S: DI × DI →DI, binary operation for the equivalence of concepts
↔: DI × DI →D1, and predi : 𝒟i−1 × X × Di →D1; while ∃($i, a) : DI →D2,
k($i, a) : D2 →Dk+1 are particular generalized DL operations.
The semantics of these intensional algebraic operations for any given extension-
alization function h : DI →Rm is given as follows:
1.
h(̃¬u) = ⊘(h(u)).
2.
For any pair, (⊙, ∘) ∈{(⊓S, ⊗S), (⊔S, ⊕S), (⇒S, ⊖S)}, h(u ⊙v) = h(u) ∘h(v).

296
|
5 Theory of many-valued intensional first-order logic
3.
h(u ↔v) = ⊛(h(u), h(v)) = ⊗(Inc(h(u), h(v)), Inc(h(v), h(u))).
4.
h(∃iu) = ⊞i(h(u)), h(∀iu) = ⊠i(h(u)).
5.
h(≤i u) =⋞i (h(u)), h(≥i u) =⋟i (h(u)).
6.
h(predk(v1, . . . , vk, u)) = Inc({(v1, . . . , vk)}, Com(h(u))), where u ∈Dk, i. e., the pred-
ication that the tuple (v1, . . . , vk) is an element of the extension of the k-ary con-
cept u.
7.
h(∃($i, a)u) =⊳i,a (h(u)), h(k($i, a)u) =⊲k
i,a (h(u)).
Notice that if for all h, h(u ↔v) = {t} then u ≡v.
Example 34 (Embedding of DL into the concept algebra 𝒜mint). It is easy to verify that
the algebraic operators ⊓(1,1) and ¬ are a generalization of the analog operators in
(algebraic) description logic used for composition of unary concepts. The “predica-
tion” operation predi can be used to define the DL-assertions in this concept alge-
bra, e. g., the satisfied DL-assertion r(u1, u2) (i. e., when (u1, u2) ∈rℐe) here will be
defined by the algebraic expression pred3(u1, u2, t, r) ∈D1 with r ∈D3, such that
h(pred3(u1, u2, t, r)) = {t}, i. e., if the tuple (u1, u2, t) is an element of relation h(r). In-
deed, it is possible to make embedding also for other expressions of description logic,
which use atomic rules also.
For example, the value restriction (∀r.u) with r ∈D3, u ∈𝒟here is expressed
by the algebraic concept expression ∀2(r ⇒(2,1) u) ∈D2, while the full DL existential
quantification (∃r.u) is expressed by the algebraic concept expression ∃2(r⊓(2,1)u) ∈D2.
In the case of 2-valued DL, we have that each m-relation R ∈Rm with k = ar(R) −1 is
an element in 𝒫(𝒟k) × {t}, thus for h(r) ∈𝒫(𝒟2) × {t}, h(u) ∈𝒫(𝒟1) × {t}, we obtain
h(∃2(r ⊓(2,1) u)) = ⊞2(h(r) ⊗(2,1) h(u))
= ⊞2({(v1, v2, t) | (v1, v2, t, t) ∈h(r) ⋈(2,1) h(u)})
= ⊞2({(v1, v2, t) | (v1, v2, t) ∈h(r) and (v2, t) ∈h(u)})
= {(v1, t) | (v1, v2) ∈π−3(h(r)) and v2 ∈π−2(h(u))}
= {(v1, t) | v1 ∈(∃π−3r.π−2u)ℐe}.
That is, π−2h(∃2(r ⊓(2,1) u)) = (∃π−3r.π−2u)ℐe, by considering that the relations in DL are
m-relations without the last column, so that the concepts r, u in 𝒜int correspond to the
concepts π−3r, π−2u in DL relatively, and each h defines the correspondent DL interpre-
tation ℐe. The expressions ≤n r, ≥n r for r ∈DI are the DL cardinality restrictions.
It is easy to verify that for any u ∈Dk where k ≥2, we have that
h(u) =
⋃
f ̸=a∈ℬ
h(⊓S{(k($i, a)(∃($i, a)u)) | 1 ≤i ≤k}),
where S = {(1, 1, ), . . . , (k −1, k −1)} and ⊓S{u1, . . . uk} denotes the expression u1 ⊓S (u2 ⊓S
(. . . ⊓S uk) . . .).

5.2 General many-valued intensional first-order logic with abstraction operator
|
297
Aswehaveseen previously,in DL thereis no explicituseofthetruthand falsehood
as in classic 2-valued logics, but instead they are using the satisfaction as means for
the definition of semantics for concepts and assertions. But, as we noted, the conse-
quence of Open World Assumption (OWA) is that, in contrast with standard databases,
is some relationship is not known to hold, it is not assumed to be false. One conse-
quence of this is that any question about the membership of an individual in a con-
cept, or its relationship to another individual, has three possible answers: “yes,” “no”
or “unknown.”
It is a sign that from the truth-functional way of point, the DL has to be a kind of
3-valued logic, as for example, Kleene’s 3-valued logic.
Remark. This point which was not formally investigated is the one of the important
reasons to consider a possible embedding of DL into the many-valued algebra of con-
cepts 𝒜int, which is target object in the intensional interpretation of the predicate
many-valued intensional logic with abstraction ℒin, defined in Definition 76.
The relationships between the identity of u and v (i. e., when h(pred3(u, v, t, Id)) =
{t}) and (strong) equivalence u ≡v is the standard relationship: if u is identical to v,
then u ≡v but not vice versa: let us consider two different concepts u, v ∈D2 for “has
been sold” and “has been bought,” respectively, we have that u is not identical to v
(i. e., h(pred3(u, v, t, Id)) = 0), while u ≡v from the fact that for all h, h(u) = h(v).
Remark. By these operators, it is possible also to make metasentences about sen-
tences, i. e., if a is a algebraic value for the sentence u ∈D1 (i. e., if h(u) = {a}) then the
metalogic sentence “it is true that u has an algebraic truth value a” corresponds to the
fact h(pred1(a, u)) = {t}. So, it holds that for the self-reference truth-concept uT ∈D2,
h(pred2(u, a, uT)) = h(pred1(a, u)).
The following important homomorphism between intensional and extensional al-
gebras, provided by Definition 75 and Definition 74, there exists the following.
Corollary 19. The semantics of the algebra for concepts in Definition 75 extends an ex-
tensionalization function h given by (5.22) into the homomorphism from intensional into
the m-extensional algebra (in Definition 74):
h : 𝒜mint →𝒜Rm
(5.25)
We denote by ℰthe set of all homomorphisms between these two algebras, represented
by the following set-mapping:
𝒜mint 󳨐⇒h∈ℰ𝒜Rm
(5.26)
Proof. Directly from Definition 75, it preserves the ordering, i. e., if u ⊑v then h(u) ⪯
h(v), with h(uf ) = 0, h(ut) = {t} for bottom/top elements, and h(Id) = R=.

298
|
5 Theory of many-valued intensional first-order logic
For algebraic operations, we have that h(̃¬) = ⊘, h(⊓S) = ⊗S, h(⊔S) = ⊕S, h(⇒S) =
⊖S, h(↔) = ⊛, h(∃i) = ⊞i, h(∀i) = ⊠i, h(≤i) =⋞i, h(≥i) =⋟i, h(predi(v1, . . . , vi, _ )) =
Inc({(v1, . . . , vi)}, Com( _ )), h(∃($i, a)) =⊳i,a, h(k($i, a)) =⊲k
i,a.
5.2.2 Syntax and interpretation of many-valued intensional FOL with abstraction
operator
The syntax of the many-valued intensional first-order logic extends the syntax of the
standard two-valued First-order Logic (FOL) with identity, introduced in Section 1.1.1,
enriched by abstraction operator ⋖_ ⋗provided in Section 1.3.1, and hence with ex-
tended set of terms obtained by the abstraction of logic formulae. However, different
from previous section where is presented an example the embedding of a many-valued
logic (in our case DL), here we will consider the embedding of any kind of many-valued
predicate logic ℒmv (with examples given in the next chapter).
Definition 76 (Syntax of many-valued intensional FOL ℒin). Wedefinethesyntaxof ℒin,
obtained by embedding of a many-valued predicate logic ℒmv over a bounded com-
plete lattice of truth-values (X, ≤), by:
–
Variables x, y, z, . . . in 𝒱;
–
Language constants c, d, . . . are considered as nullary functional letters (all non-
nullary functional letters are represented as the predicate letters for graphs of
these functions);
–
Predicate letters in P, denoted by pk1
1 , pk2
2 , . . . with a given arity ki ≥1, i = 1, 2, . . .
Nullary predicate letters are considered as propositional letters, as for example,
the built-in predicate letters {pa | a ∈X};
–
The many-valued logic connectives: a negation ¬, logic conjunction ∧, disjunc-
tion ∨, implication ⇒and equivalence ≡, with additional set Σ of another specific
connectives of ℒmv, and many-valued quantifiers ∃i, ∀i; By 𝒜X, we denote the ex-
tension of the “minimal” many-valued algebra 𝒜mv in Definition 70 for the con-
nectives in Σ. We consider also that the extensional algebra 𝒜Rm in Definition 74
and intensional algebra 𝒜mint in Definition 75 are extended by new operators in Σ,
by preserving the homomorphisms of Corollary 19.
–
Abstraction operator ⋖_ ⋗, and punctuation symbols (comma, parenthesis).
With the following simultaneous inductive definition of terms and formulae:
1.
All variables and constants (0-ary functional letters in P) are terms. We denote by
pa a logic constant (built-in 0-ary predicate symbol) for each truth value a ∈X, so
that a set of constants is a not empty set.
2.
If t1, . . . , tk are terms, then pk
i (t1, . . . , tk) is a formula (pk
i ∈P is a k-ary predicate
letter).

5.2 General many-valued intensional first-order logic with abstraction operator
|
299
3.
In what follows, any open-formula ϕ(x) with nonempty tuple of free variables x =
(x1, . . . , xm), will be called a m-ary virtual predicate, denoted also by ϕ(x1, . . . , xm)
and provided in Definition 8 in Section 1.2.
If ϕ and ψ are formulae, then ¬ϕ, (∀kx)ϕ, (∃kx)ϕ and, for each connective ⊙, if
binary ϕ ⊙ψ or if unary ⊙ϕ, are the formulae. In a formula (∃k)ϕ(x) (or (∀k)ϕ(x)),
the virtual predicate ϕ(x) is called “action field” for the quantifier (∃k) (or (∀k)) of
the k-th free variable in the tuple x. A variable y in a formula ϕ is called bounded
variable iff it is the variable quantified by (∃k) (or (∀k)). A variable x is free in ψ(x)
if it is not bounded. A sentence is a closed-formula having no free variables.
4.
If ϕ(x) is a formula and, from Definition 23 in Section 2.1.1, α ⊆x is a possibly
empty subset of hidden (compressed) variables, then ⋖ϕ(x)⋗β
α is an abstracted
term, as provided in Definition 17 in Section 1.3.1, where β is remained subset of
free visible variables in ϕ. So, the subtuples of hidden and visible variables (pre-
serving the ordering of the tuple x are π−βx and π−αx, respectively). If α or β is an
empty sequence, than it can be omitted (e. g., if ϕ is closed formula, then this term
is denoted by ⋖ϕ⋗).
An occurrence of a variable xi in a term ⋖ϕ(x)⋗β
α is bound if xi ∈α, free if xi ∈β, so that
the variables in α are not subjects of assignment g ∈𝒟𝒱and cannot be quantified by
existential and universal FOL quantifiers.
In particular, we introduce the following distinguished predicates:
(a) The binary predicate letter p2
1 ∈P is singled out as a distinguished logical predi-
cate and formulae of the form p2
1(t1, t2) are to be rewritten in the form t1 = t2. It is
a 2-valued built-in predicate for the identity.
(b) The binary predicate letter p2
2 ∈P is singled out as a distinguished logical predi-
cate and formulae of the form p2
2(t1, t2) are to be rewritten in the form t1 =in t2. It is
a 2-valued built-in predicate for the weak-intensional-equivalence.
(c) The unary predicate letter p1
1 ∈P is singled out as distinguished truth-predicate
for sentences and formulae of the form p1
1(t1) are to be rewritten in the form T(t1).
Notice that “built-in” is used for predicate letters that have fixed invariant inter-
pretation, and consequently fixed invariant extension: each possible interpretation
of ℒin has to satisfy this constraint for built-in predicates, so that different interpre-
tations can be used only for the remaining set of predicate letters in P. The T is the
many-valued version of the truth-predicate in the standard 2-valued logic where a for-
mula T(⋖ϕ⋗) is true iff the (closed) sentence ϕ is true.
We can introduce the sorts in order to be able to assign each variable xi to a sort
Si ⊆𝒟. An assignment g : 𝒱→𝒟for variables in 𝒱is applied only to free variables in
terms and formulae. If we use sorts for variables, then for each sorted variable xi ∈𝒱
an assignment g must satisfy the auxiliary condition g(xi) ∈Si. We denote by t1/g (or
ϕ/g) the ground term (or formula), without free variables, obtained by assignment g
from a term t1 (or a formula ϕ). We denote by ℒand 𝒯the set of all formulae and terms

300
|
5 Theory of many-valued intensional first-order logic
in his logic ℒin, respectively. The assignment g : 𝒱→𝒟can be extended to all terms
g∗: 𝒯→𝒟as specified in Definition 17 of Section 1.3.1.
A Herbrand base of the logic ℒin is defined by H = {pk
i (g(x1), . . . , g(xk)) | pk
i ∈P
and g ∈𝒟𝒱} ⊂ℒ.
The main difference with standard FOL syntax is that here we can use abstracted
terms obtained from logic formulae, as provided in Section 1.3.1: for example, “x be-
lieves that A” is given by formula p2
i (x, ⋖ϕ⋗) (where p2
i is binary “believe” predicate).
Let ϕ(x) be any well-formed virtual predicate in ℒin, then ⋖ϕ(x)⋗β
α/g with the set
of hidden variables α = (x1, . . . , xm), m ≥1, is the ground term (the assignment g is
applied only to free visible variables in β = x −α as explained in Section 1.3.1) whose
semantics correlate is an intensional entity (concept) of degree m. If m = 0, the inten-
sional correlate of this singular ground term is the proposition (sentence) “that ϕ”; if
m = 1, the intensional correlate is the property of “being something x1 such that ϕ”;
if m > 1, then the intensional correlate is the concept “the relation among x1, . . . , xm
such that ϕ”.
Certain complex nominative expressions (namely, gerundive and infinitive
phrases) are best represented as singular terms of the sort provided by our gener-
alized bracket notation ⋖ϕ(x)⋗β
x1,...,xm, where m ≥1. This MV-intensional logic ℒin
differs from two-valued intensional FOL in Chapter 1 in heaving these singular terms
⋖ϕ(x)⋗β
x1,...,xm where the virtual predicate ϕ(x) is many-valued. Such abstracted terms
obtained not from the sentences but from the virtual predicates ϕ(x) can be embedded
also into a particular unary predicate A(⋖ϕ(x)⋗β
x1,...,xm), as explained in Section 1.3.1
with its “ground” (for a given assignment g ∈𝒟𝒱) intensional interpretation (1.31),
which for a given extensionalization function h can have a many-valued extension
of the formula ϕ[β/g(β)]. More about intensional abstract operators is provided in
Section 1.3.1.
As in the case of two-valued intensional FOL, in this many-valued case we will
use the virtual predicates provided by Definition 8 in Section 1.2, useful for intensional
mapping into concepts in 𝒟I, i. e., into intensional algebra 𝒜mint provided by Defini-
tion 75.
Now we can consider the intensional semantics of ℒin, based on the translation
of this logic into the intensional algebra of concepts 𝒜mint, given by Definition 75.
It is an algebraic two-step semantics based on the two consecutive interpretations:
intensional interpretation of logic formulae into intensional entities (concepts) and
extensional semantics of concepts given by Corollary 19 in previous section.
The intensional interpretation I maps each nullary predicate symbol into D1, and
for each logic constant pa, a ∈X, we have that I(pa) = ua ∈D1. The language constants
(nullary functional symbols in P) are mapped in concepts in 𝒟. Notice that for any non-
meaningful language constant (as “Unicorn” for example) we have that I(c) = ® ∈D0.
Consequently, each atom pk
i (t1, . . . , tk), pk
i ∈P, is mapped into the concept u ∈
Dm+1, where m is a number of the free variables of the virtual predicate obtained from
this atom. Consequently, each ground atom pk
i (t1, . . . , tk) is mapped into D1, and if there

5.2 General many-valued intensional first-order logic with abstraction operator
|
301
is any ti, 1 ≤i ≤k, such that I(ti) = ®, then I(pk
i (t1, . . . , tk)) = uκ, where κ ∈X such
that ∼κ = κ is the “unknown” logic value. In this way, we guarantee that unmean-
ingful sentences as blu(Unicorn) will always have the “unknown” logic value. This
intensional interpretation can be given also to all contradictory formulae that cannot
be nor true nor false, as the Liars paradoxes.
We have that I(p2
1(x, y)) = I(x = y) = Id ∈D3, while I(p2
1(x, y)/g) = I((x = y)/g) =
pred3(g(x), g(y), t, Id) ∈D1. Analogously, we have that I(p2
2(x, y)) = I(x =in y) = Eq ∈
D3, while I(p2
2(x, y)/g) = I((x =in y)/g) = pred3(g(x), g(y), t, Eq) ∈D1. The atom T(x)
is mapped into self-reference concept, i. e., I(T(x)) = I(p1
1(x)) = uT ∈D2 (notice that
from footnotes in Definition 78 we have that for any assignment g, the ground atom
T(ti)/g is equivalent to the ground formula ϕ/g if ti in this predicate T represents the
term ⋖ϕ/g⋗; to built-in predicate letter pf otherwise).
For example, given two virtual predicates with the same set of free variables,
ϕ(x1, . . . , xk) and ψ(y1, . . . , yk), with ψ(y1, . . . , yk)λ virtual predicate obtained by a per-
mutation λ with the same sequence of variables as in virtual predicate ϕ(x1, . . . , xk),
then we are able to establish the weak-intensional equivalence (1.35) between them,
⋖ϕ(x1, . . . , xk)⋗α ≈⋖ψ(x1, . . . , xk)λ⋗α, where α = (x1, . . . , xk). Consequently, from the
fact that intensionally equivalent concepts are rigid concepts (with extension equal
in each possible world w ∈𝒲, introduced in next Definition 79 and used in the Kripke
semantics for many-valued intensional FOL in Section 5.2.3, corresponding to the ex-
tensionalization function h = isin(w) in Theorem 11) we can use the definition of the
intensional equivalence given by modal formula in (1.35), and extend the Kripke se-
mantics, provided in next Definitions 81 and 82 in Section 5.2.3, by this new existential
modal operator in Proposition 33 in Section 6.3.
This kind of intensional equivalence has been used in the 2-valued intensional
FOL for P2P intensional view-based data-integration in a number of papers [42, 54, 55,
58, 105, 219], where RDB views can be considered as particular virtual predicates. This
equivalence, both with embedding of description logic in ℒin (explained previously),
is a main point for pragmatic considerations about many-valued intensional FOL in
order to be used as more advanced logic layer in semantic web.
Corollary 20. The intensional interpretation defines the homomorphism between free
syntax FOL language algebra 𝒜mFOL = (ℒ, ∧, ∨, ¬, ⇒, ≡, {∃i, ∀i}i∈ℕ), representing the
many-valued intensional FOL ℒin in Definition 76, into the intensional algebra 𝒜mint,
I : 𝒜mFOL →𝒜mint
(5.27)
Proof. We define the following extension of the intensional interpretation from atoms
to all formulae I : ℒ→𝒟(notice that in this recursive definition we are using virtual
predicates obtained from open formulae in ℒ):
1.
The logic formula ϕ(xi, xj, xk, xl, xm)∧ψ(xl, yi, xj, yj) will be intensionally interpreted
by the concept u1 ∈D8, obtained by the algebraic expression u ⊓S v where u =

302
|
5 Theory of many-valued intensional first-order logic
I(ϕ(xi, xj, xk, xl, xm)) ∈D6, v = I(ψ(xl, yi, xj, yj)) ∈D5 are the concepts of the vir-
tual predicates ϕ, ψ, relatively, and S = {(4, 1), (2, 3)}. Consequently, we have that
for any two formulae ϕ, ψ ∈ℒand a particular operator uniquely determined by
tuples of free variables in these two formulae, I(ϕ ∧ψ) = I(ϕ) ⊓S I(ψ), and, anal-
ogously,
I(ϕ ∨ψ) = I(ϕ) ⊔S I(ψ),
I(ϕ ⇒ψ) = I(ϕ) ⇒S I(ψ),
I(ϕ ⇔ψ) = I(ϕ) ↔I(ψ).
2.
The logic formula ¬ϕ(xi, xj, xk, xl, xm) will be intensionally interpreted by the con-
cept u1 ∈D6, obtained by the algebraic expression ̃¬u where u = I(ϕ(xi, xj, xk, xl,
xm)) ∈D6 is the concept of the virtual predicate ϕ. Consequently, we have that for
any formula ϕ ∈ℒ, I(¬ϕ) = ̃¬(I(ϕ)).
3.
The logic formula ψ equal to the formula (∃i)ϕ(x) where ϕ(x) is a virtual predicate
with x = (x1, . . . , xm), and xi ∈(x1, . . . , xm) is i-th variable in ϕ. Then we obtain the
virtual predicate ψ(x1, . . . , xi−1, xi+1, . . . , xm), so that I(ψ) = I((∃i)ϕ) = ∃iu ∈Dm
where u = I(ϕ) ∈Dm+1. For example, the logic formula (∃3)ϕ(xi, xj, xk, xl, xm) will
be intensionally interpreted by the concept u1 ∈D5, obtained by the algebraic
expression ∃3u where u = I(ϕ(xi, xj, xk, xl, xm)) ∈D6 is the concept of the virtual
predicate ϕ. Thus, we have that for any formula (∃n)ϕ ∈ℒ, the operator ∃n is
uniquely determined by the n-th position of the existentially quantified variable
in the tuple of free variables in the virtual predicate ϕ,
I((∃n)ϕ) = ∃n(I(ϕ)),
and, analogously,
I((∀n)ϕ) = ∀n(I(ϕ)).
For the set of additional many-valued connectives in Σ for any concrete many-
valued logic ℒmv, we consider that this homomorphism is valid also for them. Now
we are able to define formally the intensional semantics of this logic.
Definition 77 (Two-step algebraic intensional semantics). The intensional semantics
of the logic ℒin with the set of formulae ℒcan be represented by the mapping
ℒ󳨀→I 𝒟󳨐⇒h∈ℰin⊆ℰRm
(5.28)
where 󳨀→I is a fixed intensional interpretation (homomorphism in Corollary 20)
I : ℒ→𝒟and 󳨐⇒h∈ℰin is the subset of all homomorphisms h ∈ℰin Corollary 19,
such that respect all built-in concepts in Definition 72, and for any virtual predicate
ϕ(x1, . . . , xn) ∈ℒ, the following many-valued generalization of Tarski’s FOL constraint
is valid:
h(I(ϕ(x1, . . . , xn))) =def {(g(x1), . . . , g(xn), a) | g ∈𝒟𝒱, h(I(ϕ(x1, . . . , xn)/g)) = {a}, a
̸= f }
(5.29)
with h(I(ϕ(x1, . . . , xn)/g)) = 0 iff (g(x1), . . . , g(xn)) ∉π−n−1(h(I(ϕ(x1, . . . , xn)))).

5.2 General many-valued intensional first-order logic with abstraction operator
|
303
This set ℰin of homomorphisms h : 𝒜mint →𝒜Rm will be called as possible worlds
as well.
Notice that for any h ∈ℰin and a permutation λ, Inc(h(ϕ(x1, . . . , xm)λ), h(ϕ(x1, . . . ,
xm))) = Inc(h(ϕ(x1, . . . , xm)), h(ϕ(x1, . . . , xm)λ)) = {t}. We are able to define the many-
valued algebraic semantics of ℒin, based on the standard extension of Herbrand inter-
pretations to all sentences ℒ0 of ℒin.
Definition 78 (Semantics of many-valued intensional FOL). The algebraic semantics
of the many valued intensional FOL ℒin given in Definition 76 and its syntax-algebra
𝒜mFOL in Corollary 20, can be obtained by the unique extension of a given Herbrand
interpretation v : H →X, into the valuation v∗: ℒ0 →X (from Definition 62, Sec-
tion 5.1.1), where ℒ0 ⊂ℒis the strict subset of all sentences (formulae without free
variables), inductively as follows:
for any formula ϕ, ψ ∈ℒand a given assignment g : 𝒱→𝒟, we have that (here ⋀
and ⋁are the meet and joint operators of the lattice X, respectively)
1.
v∗(¬ϕ/g) =∼v∗(ϕ/g),
2.
v∗(ϕ/g ⊙ψ/g) = v∗(ϕ/g)̂⊙v∗(ψ/g), for each logic connective ⊙∈{∧, ∨, ⇒, ≡} into
𝒜mv-operators ̃⊙∈{̃∧, ̃∨, 󴁃󴀢, ⇔},
3.
v∗(((∃i)ϕ)/g) = v∗(ϕ/g) if i-th variable x is not a free in ϕ; = ⋁{v∗(ϕ/g1) | g1 ∈𝒟V
such that for all y ∈𝒱\{x}, g1(y) = g(y)} otherwise,
4.
v∗(((∀i)ϕ)/g) = v∗(ϕ/g) if i-th variable x is not a free in ϕ; = ⋀{v∗(ϕ/g1) | g1 ∈𝒟V
such that for all y ∈𝒱\{x}, g1(y) = g(y)} otherwise.
We denote by ℐMV ⊆Xℒ0 the set of all many-valued valuations of ℒin that have fixed
(invariant) interpretation for each built-in predicate.7
Clearly, the many-valued quantifiers defined in definition above does not satisfy
the standard FOL property that ∀=∼∃∼, but in the case of the 2-valued logic when
X = 2, then this requirement is satisfied by Definition 78 and points 3 and 4 corre-
sponds to the standard semantics of quantifiers of the FOL.
Notice that this many-valued extended interpretation v∗: ℒ0 →X defined above
is not a homomorphism, because of the point 3 (and 4 as well), where the truth of the
closed formula (∀xi)ϕ(xi) cannot be obtained from the logic value of ϕ(xi) from the fact
that to any formula with free variables we cannot associate any logic value. Because
of that, we define a new version of many-valued interpretation, denominated “MV-
interpretation.”
7 As, for example, the identity predicate p2
1 ∈P or nullary predicate letters {pa | a ∈X} for which
it must be satisfied that for any v∗∈ℐMV, v∗(pa) = a, v∗(p2
1(u1, u2)) = t iff (u1, u2, t) ∈R=, and
v∗(p2
2(u1, u2)) = t iff (u1, u2, t) ∈R=in, and for any assignment g, v∗(p1
1(ti)) = v∗(T(ti)) =def v∗(ϕ/g)
if term ti = ⋖ϕ/g⋗; f otherwise. The difference between ℐMV and the total set of Herbrand interpreta-
tions XH is caused by the presence of the built-in predicates.

304
|
5 Theory of many-valued intensional first-order logic
Definition 79 (MV-interpretations). We define, for a valuation v∗: ℒ0 →X of the sen-
tences in ℒ0 ⊂ℒof the many-valued intensional FOL ℒin in Definition 76, the MV-
interpretation I∗
mv : ℒ0 →Rm, such that for any sentence ϕ/g ∈ℒ0,
I∗
mv(ϕ/g) = { {v∗(ϕ/g)} ∈̃X ⊂Rm,
if v∗(ϕ/g)
̸= f
0,
otherwise
(5.30)
and we define also the unique extension of I∗
mv to all open formulae ℒin ℒin as well,
such that for any open formula (virtual predicate) ϕ(x1, . . . , xk) ∈ℒ,
I∗
mv(ϕ(x1, . . . , xk)) = {(g(x1), . . . , g(xk), a) | g ∈𝒟𝒱and a = v∗(ϕ/g)
̸= f} ∈Rm
(5.31)
We denote by 𝒲the set of all MV-interpretations derived from the set of many-valued
interpretations v∗∈ℐMV specified in Definition 78, with bijection isMV : ℐMV ≃𝒲such
that for any v∗∈ℐMV we have that I∗
mv = isMV(v∗) : ℒ→Rm.
Now we can demonstrate that the many-valued semantics given by Definition 78
of the logic ℒin is corresponds to the two-step concept-algebra semantics given by Def-
inition 77.
Theorem 11 (Many-valuedness and concept-algebra semantics). For any fixed inten-
sional interpretation I of ℒin into algebra of concepts 𝒜mint, there is a bijection isin :
𝒲≃ℰin, so that for any many-valued interpretation v∗∈ℐMV, i. e., MV-interpretation
I∗
mv = isMV(v∗) ∈𝒲(in Definition 79) the correspondent equivalent extensionaliza-
tion functions is h = isin(I∗
mv) ∈ℰin (by T-constraint (5.29) and Definition 72), and vice
versa, given any extensionalization homomorphism h : 𝒜mint →𝒜Rm the correspon-
dent equivalent MV-interpretation of ℒin is I∗
mv = is−1
in (h) ∈𝒲, so that the following
truth-diagram:
𝒜mint
ℒ0
I∗
mv
?
I
?
𝒜Rm
h
?
commutes, as a consequence of the basic Herbrand base correspondence
I∗
mv(pk
i (u1, . . . , uk)) = h(I(pk
i (u1, . . . , uk)))
(5.32)
for each ground atom pk
i (u1, . . . , uk) in Herbrand base H ⊂ℒ0.
The arrow I∗
mv : ℒ0 →̃X = Rm1 ⊂Rm is the “standard” many-valued seman-
tics, while the arrow h ∘I : ℒ0 →𝒜mR corresponds to the two-step concept-algebra
semantics.

5.2 General many-valued intensional first-order logic with abstraction operator
|
305
Proof. Notice that only the arrow h in the diagram above is a homomorphism (5.25),
while I is a nonhomomorphic restriction of the homomorphism I : 𝒜mFOL →𝒜mint
given by (5.27) in Corollary 20 to the subset ℒ0 of closed formulae of the free syn-
tax algebra 𝒜mFOL of the ℒin. Thus, this diagram is not homomorphic. In what fol-
lows, we consider that the intensional interpretation is fixed one. We have to show
that for any given extensionalization function h the MV-interpretation I∗
mv = h ∘I
is uniquely determined by the commutative diagram above, i. e., from the fact that
for any ϕ ∈ℒand assignment g ∈𝒟𝒱it holds that v∗(ϕ/g) = is−1
MV(I∗
mv)(ϕ/g), i. e.,
is−1
in (isMV(v∗))(ϕ/g) = h(I(ϕ/g)).
First, from the correspondence (5.32), this diagram commutes for each ground
atom in Herbrand base, and we need only to show that it is valid for any other com-
posed sentence in ℒ0. Notice that it is satisfied for the unary self-reference predicate
p1
1 and for the binary identity predicate p2
1 as well. We will use the structural induction
on number of logic operators of the sentences in ℒ0. Suppose that it holds for every
closed formula ψ1/g ∈ℒ0 (with R1 = Com(h(I(ψ/g))) = {a1} and a1 = v∗(ψ1/g)) with
n −1 connectives, and ψ2/g ∈ℒ0 (with R2 = Com(h(I(ψ/g))) = {a2} and a2 = v∗(ψ2/g)
with less than n logic connectives, and let us demonstrate that it holds for any formula
ϕ with n or more connectives. There are the following cases:
1.
ϕ = ¬ψ1. Then h(I(¬ψ1/g)) = h(̃¬I(ψ1/g)) = (by Definition 75) = ⊘h(I(ψ1/g)) = (by
Definition 74)
= { {∼a1},
if ∼a1
̸= f
0,
otherwise,
while I∗
mv(¬ψ1/g) = (from (5.30))
= { {¬v∗(ψ1/g)} = {∼a1},
if ∼a1
̸= f
0,
otherwise.
2.
ϕ = (ψ1 ∧ψ2). Then, h(I(ϕ/g)) = h(I(ψ1/g) ⊓I(ψ2/g)) = (by Definition 75) =
h(I(ψ1/g)) ⊗h(I(ψ2/g))) = R1 ⊗R2 = (by Def. 74)
= { {a1̃∧a2},
if a1̃∧a2
̸= f
0,
otherwise,
while I∗
mv(ψ1/g ∧ψ2/g) = (from Definition 78 and (5.30))
= { {v∗(ψ1/g)̃∧v∗(ψ2/g)} = {a1̃∧a2},
if a1 ∧a2
̸= f
0,
otherwise
Analogously, we obtain for cases when ϕ is ψ1 ∨ψ2 or ψ1 ⇒ψ2, or ψ1 ≡ψ2.
3.
ϕ = (∃x1)ψ(x1), with h(I(ψ(x1))) = Imv(ψ(x1)), in accordance with (5.29) and (5.31),
and R = h(I(ψ(x1))).

306
|
5 Theory of many-valued intensional first-order logic
Then h(I(ϕ/g)) = h(I((∃x1)ψ(x1))) = h(∃1I(ψ(x1))) = (by Definition 75)
= ⊞1(h(I(ψ(x1)))) =
(by Defintion 74)
= { b = ⋁{a | (u, a) ∈R},
if b
̸= f
0,
otherwise,
while I∗
mv(ϕ/g) = I∗
mv((∃x1)ψ(x1)) = (from Definition 78 and (5.30))
= { b = ⋁{a | (u, a) ∈R},
if b
̸= f
0,
otherwise
where ⋁is the join operator in lattice X. Analogously, we obtain for cases when
ϕ = (∀xi)ψ(x1, . . . , xi, . . . , xk). Thus, for any fixed intensional interpretation I of ℒin,
the diagram commutes and the bijection isin is well-defined.
This truth diagram explains the equivalence of many-valued interpretations of
the logic ℒin, and the two-step semantics for concept algebras. But it is given only
for the set of ground (without free variables) formulae, and its nucleus composed by
ground atoms of the Herbrand base H: the truth of (closed) sentences with quantifiers
is uniquely determined by the truth of atoms of this Herbrand base. Now we will ex-
tend this correspondence to open formulae in ℒas well. The following Intensional/ex-
tensional many-valued FOL semantics is a generalization of the Intensional/exten-
sional semantics of the standard FOL, presented in Corollary 4, Section 1.3.
Corollary 21 (Intensional/extensional many-valued FOL semantics). For a given fixed
intensional interpretation I and any many-valued interpretation v∗: ℒ0 →X of the
ℒin, with MV-interpretation I∗
mv = isMV(v∗), the following diagram, as a homomorphic
extension of the diagram in Theorem 11, commutes
𝒜mint (concepts/meaning)
Frege/Russell
semantics
𝒜mFOL (syntax)
I∗
mv (MV-interpretation)
?
I (intensional interpr.)
?
h (extensionalization)
?
𝒜Rm (denotation)
where h = isin(I∗
mv) represents the bijective semantic equivalence given by Theorem 11
and the set of sentences ℒ0 ⊂ℒis substituted by the free syntax algebra 𝒜mFOL of the
many-valued intensional FOL ℒin, introduced in Corollary 20, with the carrier set of all
formulae ℒ.
Proof. The homomorphism of intensional mapping I is defined by Corollary 20. Let
us show that also for a given many-valued valuation v∗∈ℐMV, which determines the

5.2 General many-valued intensional first-order logic with abstraction operator
|
307
MV-interpretation I∗
mv = isMV(Imv) from Definition 79 and, from Theorem 11, the exten-
sionalization h = isin(I∗
mv), the diagram above commutes.
In fact, for any closed formula ϕ/g ∈ℒ0 ⊂ℒ, by definition of I∗
mv we have that
I∗
mv(ϕ) = (from the commutative diagram in Theorem 11) = (h∘I)(ϕ) = h(I(ϕ)), and the
set of different “possible worlds”
𝒲= {I∗
mv = isMV(v∗) | v∗∈ℐMV ⊂XH} ≃ℐMV
(5.33)
For any open formula (virtual predicate) ϕ(x1, . . . , xk) ∈ℒ, from definition of I∗
mv we
have that I∗
mv(ϕ(x1, . . . , xk)) = {(g(x1), . . . , g(xk), a) | g ∈𝒟𝒱and a = v∗(ϕ/g)
̸= f }
= (from Theorem 11) = {(g(x1), . . . , g(xk), a) | g ∈𝒟𝒱and a = h(I(ϕ/g))
̸= f} = (from
many-valued generalization of Tarski’s constraint for the algebraic two-step semantics
in Definition 77) = h(I(ϕ(x1, . . . , xk))).
Thus, the diagram above commutes for every formula in ℒ, and we obtain that
I∗
mv = I ∘h is a many-valued homomorphism between the free syntax algebra of the
logic ℒin and the extensional algebra 𝒜Rm of m-extensions.
Remark. Notice that for X = 2 we obtain a m-version of the 2-valued intensional FOL
presented in Corollary 4, Section 1.3. The only difference is that in this more general
many-valued representation each virtual predicate ϕ(x1, . . . , xk) is ontologically encap-
suled into (k + 1)-arity virtual predicate by adding at the end of list of variables also
the logic-value attribute, so that
I∗
mv(ϕ(x1, . . . , xk)) = I∗
T (ϕ(x1, . . . , xk)) × {t},
and
I∗
T (ϕ(x1, . . . , xk)) = π−(k+1)I∗
mv(ϕ(x1, . . . , xk))
(5.34)
This homomorphic diagram formally express the fusion of Frege’s and Russell’s
semantics [25, 51, 52] of meaning and denotation of the FOL language, and renders
mathematically correct the definition of what we call an “intuitive notion of inten-
sionality,” in terms of which a language is intensional if denotation is distinguished
from sense: that is, if both a denotation and sense is ascribed to its expressions.
This notion is simply adopted from Frege’s contribution (without its infinite sense-
hierarchy, avoided by Russell’s approach where there is only one meaning relation,
one fundamental relation between words and things, here represented by one fixed
intensional interpretation I), where the sense contains mode of presentation here
described algebraically as an algebra of concepts (intensions) 𝒜mint, and where sense
determines denotation for any given extensionalization function h (corresponding to
a given many-valued interpretation v∗). More about the relationships between Frege’s
and Russell’s theories of meaning may be found in the Chapter 7, “Extensionality and
Meaning,” in [12].
As noted by Gottlob Frege and Rudolf Carnap (he uses terms intension/exten-
sion in the place of Frege’s terms sense/denotation [31]), the two logic formulae with

308
|
5 Theory of many-valued intensional first-order logic
the same denotation (i. e., the same m-extension for a given many-valued interpreta-
tion v∗) need not have the same sense (intension), thus such co-denotational expres-
sions are not substitutable in general.
In fact, there is exactly one sense (meaning) of a given logic formula in ℒ, defined
by the uniquely fixed intensional interpretation I, and a set of possible denotations
(extensions) each determined by a given many-valued interpretation of the FOL as
follows from Definition 77 and Theorem 11:
ℒ󳨀→I 𝒟󳨐⇒h=isin(I∗
mv)&I∗
mv∈𝒲Rm
(5.35)
Often “intension” has been used exclusively in connection with possible worlds se-
mantics, however, here we use (as many others; as Bealer for example) “intension”
in a more wide sense, that is as an algebraic expression in the intensional algebra of
meanings (concepts) 𝒜mint, which represents the structural composition of more com-
plex concepts (meanings) from the given set of atomic meanings.
Consequently, not only the denotation (extension) is compositional, but also the
meaning (intension) is compositional. So, the Montague’s intension given by Defini-
tion 4, can be generalized fir the many-valued intensional FOL as well.
Definition 80 (MV-Montague’s intension). For a given many-valued intensional FOL
language ℒin with the set of logic formulae ℒ, the MV-Montague intension as a mapping
(higher-order function)
In : ℒ→Rm𝒲
where the set of possible worlds 𝒲is the set of MV-interpretations given by (5.33).
Thus, for any virtual predicate ϕ(x1, . . . , xk) ∈ℒwe obtain the mapping fk = In(ϕ(x1, . . . ,
xk)) : 𝒲→Rm, such that for each I∗
mv ∈𝒲, R = In(ϕ(x1, . . . , xk))(I∗
mv) ∈Rm is equal
to the relation I∗
mv(ϕ(x1, . . . , xk)) obtained from the MV-interpretation I∗
mv (derived from
many-valued interpretation v∗= is−1
MV(I∗
mv) : ℒ0 →X where the bijection isMV is de-
fined in Definition 79). That is, for each virtual predicate ϕ(x1, . . . , xk) ∈ℒand “world”
h ∈𝒲, from the commutative diagram of Corollary 21, the equation
In(ϕ(x1, . . . , xk))(I∗
mv) = I∗
mv(ϕ(x1, . . . , xk))
(5.36)
is analog to (1.10) and explains how works the idea of MV-Montague’s intension.
It is easy to verify that in the case of the two-valued intensional FOL, when X = 2,
the MV-Montague’s intension is equal to the standard Montague’s intension given by
Definition 4 in Section 1.1.3. Just from this fact that the many-valued intensional FOL,
developed previously in this chapter, is a conservative extension of the standard two-
valued intensional FOL, the complex theoretical work presented previously has im-
portant impact to practical applications of any kind of intensional logics.

5.2 General many-valued intensional first-order logic with abstraction operator
|
309
A number of new relevant many-valued logics, improved by the modification of
classic logic connectives of some significant examples of many-valued logics, which
can be embedded in this intensional many-valued FOL ℒin, is developed as examples
in a dedicated next chapter.
5.2.3 Model-based entailment and Kripke semantics for many-valued intensional
FOL
The distinction between intensions and extensions is important especially because
we are now able to have an equational theory over intensional entities (as ⋖A⋗), that
is predicate and function “names,” that is separate from the extensional equality of
relations and functions. Thus, intensional predicate many-valued logic has the simple
Tarski first-order semantics, with a decidable unification problem, but we need also
the actual world mapping which maps any intensional entity to its actual world exten-
sion. As we have seen previously for the Montague’s representation of the intension
in Definition 80 for a many-valued intensional FOL, we identified the possible worlds
𝒲as a particular set of MV-interpretations and by a particular mapping In, which as-
signs to intensional entities (virtual predicates ϕ(x1, . . . , xk) ∈ℒ) their extensions in
such possible world w = I∗
mv ∈𝒲, such that is satisfied the equation (5.36). It is the di-
rect bridge between intensional and the possible worlds representation [7–11], where
intension of a proposition is a function from a set of possible worlds 𝒲to truth values,
and properties and functions (in predicate intensional logics each functional k-ary
symbol f k
i is substituted by a (k + 1)-ary predicate) from 𝒲to sets of possible (usually
not-actual) objects.
The Model-based entailment: For any embedding of a predicate many-valued logic
ℒmv with a lattice (X, ≤) of truth values, into intensional FOL ℒin, and the given set of
thesis ϕi ∈Γ, ϕi ∈ℒ0, with associated prefixed bottom-truth values ai ∈X different
from f, the many-valued models of ℒin is defined, from (5.1), as a subset of all valua-
tions:
𝕍Γ =def {I∗
mv ∈𝒲| ∀ϕi ∈Γ.(I∗
mv(ϕi) ⪰{ai})}
(5.37)
So, we introduce the model-based truth-preserving entailment of a formula ψ of in-
tensional many-valued FOL ℒin, for a given assignment g, from the theses of ℒin in Γ
and from (5.38), by
Γ 󳀀󳨐ψ/g
iff
(∃ϕi ∈Γ).(∀I∗
mv ∈𝕍Γ).(I∗
mv(ψ/g) ⪰I∗
mv(ϕi))
(5.38)
In propositional modal logics, the possible worlds are entities where a given proposi-
tional symbol can be true or false. Thus, from logical point of view the possible worlds
in Kripke’s relational semantics are characterized by property to determine the truth
of logic sentences. The important question relative to the syntax of the many-valued

310
|
5 Theory of many-valued intensional first-order logic
FOL is if there is a kind of basic set of possible worlds that have such properties. The
answer is affirmative as in the case of the standard two-valued FOL, and we can use
the analog results provided in Section 1.3, by adapting them to the many-valued ap-
proach.
In fact, if we consider a k-ary many-valued predicate letter pk
i as a new kind of
“propositional letter,” then an assignment g : 𝒱X →𝒟can be considered as an intrin-
sic (par excellence) possible world, where the truth of this “propositional letter” pk
i
is equal to the truth of the ground atom pk
i (g(x1), . . . , g(xk)) ∈ℒ0 of the many-valued
intensional FOL ℒin. Here, 𝒱X = 𝒱⋃{xX} where xX is the new typed “logic” variable
(whose domain is the set of truth values in X ⊂D0) not used in the intensional many-
valued FOL ℒin whose syntax is given in Definition 76, so that for any assignment
g ∈𝒟𝒱X, g(xX) ∈X.
Consequently, in what follows, analogously to the two-valued framework of the
generalized Kripke semantics for predicate modal logics, given by Definition 12 in Sec-
tion 1.2.1, we will denote by 𝒲the set of explicit possible worlds (defined explicitly for
each particular case of modal logics, and in Definition 77 for this logic ℒin), while the
set 𝒟𝒱X we will be called as the set of intrinsic possible worlds (which is invariant and
common for every predicate modal logic). By 𝕎⊆{(w, g) | w ∈𝒲, g ∈𝒟𝒱X}, we will
denote the set of (generalized) possible worlds. In this way, as in the case of proposi-
tional modal logic, we will have that a formula φ is true in a Kripke’s interpretation ℳ
if for each (generalized) possible world u = (w, g) ∈𝕎, ℳ󳀀󳨐u φ.
We denote by ‖ϕ‖ = {(w, g) ∈𝕎| ℳ󳀀󳨐w,g ϕ} the set of all worlds where the
formula ϕ is satisfied by interpretation ℳ. Thus, as in the case of propositional modal
logics, also in the case of predicate modal logics we have that a formula ϕ is true iff it
is satisfied in all (generalized) possible worlds, i. e., iff ‖ϕ‖ = 𝕎.
With this new arrangement, we can reformulate the generalized Kripke semantics
for two-valued modal predicate logic in Definition 12 in Section 1.2.1 (as usual, π1 and
π2 denote the first and the second projections, and we recall that we replaced each
functional symbol by corresponding predicatesymbol, so the set F of functional letters
is empty).
Definition 81 (Generalized Kripke semantics for many-valued logics). We denote by
ℳ= (𝕎, {ℛi}, 𝒟, IK) a multimodal Kripke’s interpretation with a set of (generalized)
possible worlds 𝕎= 𝒲× 𝒟𝒱X, a set of explicit possible worlds 𝒲= π1(𝕎) and
π2(𝕎) = 𝒟𝒱X, the accessibility relations ℛi ⊆𝕎× 𝒫(𝕎), i = 1, 2, . . . , nonempty
domain 𝒟, and a function IK : 𝒲× P →⋃n∈𝒩2𝒟n, such that for any explicit world
w ∈𝒲: For any predicate letter pk
i ∈P, the function IK(w, pk
i ) : 𝒟k →2 defines the
m-extension of pk
i in an explicit world w,
󵄩󵄩󵄩󵄩pk
i (x1, . . . , xk)󵄩󵄩󵄩󵄩ℳ,w =def {(d1, . . . , dk+1) ∈𝒟k×X | IK(w, pk
i )(d1, . . . , dk+1) = t and dk+1
̸= f }.
Based on this generalized Kripke semantics for many-valued logics, we can refor-
mulate the standard Kripke semantics for two-valued minimal intensional FOL logic in

5.2 General many-valued intensional first-order logic with abstraction operator
|
311
Definition 15 in Section 1.3, and hence we can present the Kripke semantics for many-
valued intensional FOL logic ℒin.
Definition 82 (Kripke semantics for ℒin). Let (I, 𝒲) be the two-step intensional se-
mantics in (5.35) for many-valued intensional FOL ℒin (where the functional letters
with arity greater than zero are substituted by predicate letters) given in Definition 77
with I∗
mv ∈𝒲possible worlds in (5.33).
By ℳ= (𝕎, ℛ∼, ℛ̃∧, ℛ̃∨, ℛ󴁃󴀢, {ℛ∃xi, ℛ∀xi}i∈ℕ, {ℛ⊙}⊙∈Σ, 𝒟, IK), we denote a multi-
modal Kripke’s interpretation with a set of (generalized) possible worlds 𝕎, a set of
explicit possible worlds 𝒲= π1(𝕎) and π2(𝕎) = 𝒟𝒱X, nonempty domain 𝒟, the
accessibility relations:
a.
ℛ⊙= {(g, g1) | g, g1 ∈𝒟𝒱X, such that for all x ∈𝒱, g1(x) = g(x) and g(xX) =
⊙g1(xX)}, for each unary operator different from the quantifiers, ⊙∈{∼, . . .},
b.
ℛ⊙= {(g, g1, g2) | g, g1, g2 ∈𝒟𝒱X, such that for all x ∈𝒱, g1(x) = g2(x) = g(x) and
g(xX) = g1(xX) ⊙g2(xX)}, for each ⊙∈{̃∧, ̃∨, 󴁃󴀢, ⇔, . . .},
c.
ℛ⊙⊆𝒟𝒱X × 𝒫(𝒟𝒱X), such that
(g, G) ∈ℛ⊙
iff
g(xX) = ⬦{g′(xX) | g′ ∈G and for all x ∈𝒱\{xi}, g′(x) = g(x)},
for each pair (⊙, ⬦) ∈{(∃xi, ⋁), (∀xi, ⋀)}, where ⋀and ⋁are the meet and join
operator of lattice X, respectively,
with mapping IK : 𝒲×P →⋃n∈𝒩2𝒟n×X, such that for any explicit world w = I∗
mv ∈𝒲,
i. e., many-valued interpretation v∗= is−1
MV(I∗
mv), pk
i ∈P and (u1, . . . , uk+1) ∈𝒟k × X,
IK(I∗
mv, pk
i )(u1, . . . , uk+1) = t
iff
uk+1 = v∗(pk
i (u1, . . . , uk)).
Then, for any world (w, g) ∈𝕎with w = I∗
mv ∈𝒲, we define the many-valued satis-
faction, denoted by 󳀀󳨐w,g, as follows:
1.
ℳ󳀀󳨐w,g pk
i (x1, . . . , xk) iff IK(w, pk
i )(g(x1), . . . , g(xk), g(xX)) = t,
2.
ℳ󳀀󳨐w,g ⊙ϕ iff ∃g1 ∈𝒟𝒱X.((g, g1) ∈ℛ⊙and ℳ󳀀󳨐w,g1 ϕ), for each unary logic
connective different from the quantifiers ⊙∈{¬, . . .},
3.
ℳ󳀀󳨐w,g ϕ ⊛ψ iff ∃g1, g2 ∈𝒟𝒱X.((g, g1, g2) ∈ℛ⊙and ℳ󳀀󳨐w,g1 ϕ and ℳ󳀀󳨐w,g2 ψ), for
each ⊛∈{∧, ∨, ⇒, . . .} and ⊙∈{̃∧, ̃∨, 󴁃󴀢, . . .}, relatively,
4.
ℳ󳀀󳨐w,g (∃xi)ϕ(x1, . . . , xi, . . . , xk) iff exists (g, G) ∈ℛ∃xi such that G = {g1 ∈𝒟𝒱X |
∀1≤j≤kj
̸= i.(g1(xj) = g(xj)) and g1(xX) ∈Com(w(ϕ/g1))}, and (g1 ∈G iff ℳ󳀀󳨐w,g1 ϕ),
5.
ℳ󳀀󳨐w,g (∀xi)ϕ(x1, . . . , xi, . . . , xk) iff exists (g, G) ∈ℛ∀xi such that G = {g1 ∈𝒟𝒱X |
∀1≤j≤kj
̸= i.(g1(xj) = g(xj)) and g1(xX) ∈Com(w(ϕ/g1))}, and (g1 ∈G iff ℳ󳀀󳨐w,g1 ϕ),
6.
ℳ󳀀󳨐w,g ϕ ≡ψ iff ℳ󳀀󳨐w,g ϕ and ℳ󳀀󳨐w,g ψ.
Note that we used ternary Kripke accessibility relations as in Definition 119 in Sec-
tion A.4.2 in the Appendix, used for the two-valued reduction (ontological encapsula-
tion) of the many-valued logics. Let us show that this multimodal Kripke semantics of

312
|
5 Theory of many-valued intensional first-order logic
ℒin is correct semantics, able to support the Montague’s approach to the intensional
semantics.
Theorem 12. For any given multimodal Kripke interpretation ℳof ℒin, it is valid that
for any formula ϕ(x1, . . . , xk) ∈ℒ, k ≥0, and world (w, g) ∈𝕎where w = I∗
mv with
many-valued interpretation v∗= is−1
MV(w):
ℳ󳀀󳨐w,g ϕ(x1, . . . , xk)
iff
g(xX) = v∗(ϕ(x1, . . . , xk)/g)
(5.39)
that is, by Theorem 11, iff (g(xX)
̸= f and w(ϕ(x1, . . . , xk)/g) = {g(xX)}, or g(xX) = f and
w(ϕ(x1, . . . , xk)/g) = 0). So,
ℳ󳀀󳨐w,g ϕ ≡ψ
iff
v∗(ϕ/g) = v∗(ψ/g).
Consequently, the m-extension of ϕ(x1, . . . , xk) computed by the multimodal Kripke’s in-
terpretaion ℳin a given explicit world w = I∗
mv ∈𝒲is equal to m-extension of the same
formula computed by the intensional semantics of the ℒin, i. e.,
󵄩󵄩󵄩󵄩ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩ℳ,w = w(ϕ(x1, . . . , xk))
(5.40)
Thus, from the Montague’s approach to the intension (meaning) of the logic formulae
given by the mapping In : ℒ→Rm𝒲in Definition 80, it holds that In(ϕ(x1, . . . , xk))(w) =
‖ϕ(x1, . . . , xk)‖ℳ,w is the m-extension of this formula in this possible world. Conse-
quently, this multimodal Kripke semantics for ℒin is adequate to support Montague’s
intensional semantics.
Proof. Let us prove (5.39) by structural induction on number of logic operators in a
virtual predicate (open formula) ϕ(x1, . . . , xk):
1.
Let ϕ(x1, . . . , xk) be an atom pk
i (x1, . . . , xk) (with zero logic operators). Conse-
quently, if ℳ󳀀󳨐w,g pk
i (x1, . . . , xk) then, from point 1 of Definition 82 we have
that IK(w, pk
i )(g(x1), . . . , g(xk), g(xX)) = t, that is g(xX) = v∗(pk
i (x1, . . . , xk)/g). And
vice versa.
2.
Let us suppose that this theorem holds for each open formula with less than n ≥1
logic operators, and consider any formula ϕ(x1, . . . , xk) with n operators. There are
the following cases:
2.1. ϕ(x1, . . . , xk) = ¬ψ(x1, . . . , xk) where ψ(x1, . . . , xk) has less than n operators.
Let ℳ󳀀󳨐w,g ϕ(x1, . . . , xk), so that from the point 2 of Definition 82 we ob-
tain that ℳ󳀀󳨐w,g1 ψ(x1, . . . , xk) with g1(xX) = a, g(xX) =∼a, and conse-
quently, by inductive hypothesis v∗(ψ(x1, . . . , xk)/g1) = v∗(ψ(x1, . . . , xk)/g) = a.
Then g(xX) =∼a =∼v∗(ψ(x1, . . . , xk)/g) = (from point 1 of Definition 78)
= v∗(¬ψ(x1, . . . , xk)/g) = v∗(ϕ(x1, . . . , xk)/g), and vice versa, analogously, for
another unary logic connectives different from the quantifiers.
2.2. ϕ(x1, . . . , xk) = ψ1 ∧ψ2 where ψ1, ψ2 have less than n operators.

5.2 General many-valued intensional first-order logic with abstraction operator
|
313
Let ℳ󳀀󳨐w,g ϕ(x1, . . . , xk), so that from the point 3 of Definition 82 we obtain
that ℳ󳀀󳨐w,g1 ψ1 and ℳ󳀀󳨐w,g2 ψ2 with g(xX) = g1(xX)̃∧g2(xX). Consequently, by
inductive hypothesis g1(xX) = v∗(ψ1/g1) = v∗(ψ1/g) and g2(xX) = v∗(ψ2/g2) =
v∗(ψ2/g). Then g(xX) = g1(xX)̃∧g2(xX) = v∗(ψ1/g)̃∧v∗(ψ1/g) = (from point 2 of
Definition 78) = v∗(ψ1/g ∧ψ2/g) = v∗(ϕ(x1, . . . , xk)/g)), and vice versa. Anal-
ogously, we can show that it holds for the cases when ϕ(x1, . . . , xk) is ψ1 ⊙ψ2
for other binary connectives as well.
2.3. ϕ(x1, . . . , xk) = (∃xi)ψ where ψ has less than n operators.
Let ℳ󳀀󳨐w,g ϕ(x1, . . . , xk), so that from the point 4 of Definition 82 we obtain
that ℳ󳀀󳨐w,g (∃xi)ψ with g(xX) = ⋁G = ⋁{gi(xX) | ℳ󳀀󳨐w,gi ψ, gi ∈𝒟𝒱
such that for all x ∈𝒱\{xi}, gi(x) = g(x)}, so that from the inductive hypoth-
esis g(xX) = ⋁{gi(xX) | gi(xX) = v∗(ψ/gi), gi ∈𝒟𝒱such that for all x ∈
𝒱\{xi}, gi(x) = g(x)} = ⋁{v∗(ψ/gi) | gi ∈𝒟𝒱such that for all x ∈𝒱\{xi}, gi(x) =
g(x)} = (from point 3 of Definition 78) = v∗((∃xi)ψ), and vice versa.
Analogously, we can show that it holds for the case when ϕ(x1, . . . , xk) = (∀xi)ψ as
well.
Consequently, we obtain (5.40),
󵄩󵄩󵄩󵄩ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩ℳ,w =def {(g(x1), . . . , g(xk), g(xX)) | g ∈𝒟𝒱and ℳ󳀀󳨐w,g ϕ(x1, . . . , xk)}
= w(ϕ(x1, . . . , xk))
= I∗
mv(ϕ(x1, . . . , xk))
= In(ϕ(x1, . . . , xk))(I∗
mv),
from (5.36),
and hence correspondence with Montague’s approach to the intension (mean-
ing).
Notice that the meaning of the logic formulae is given by mapping In : ℒ→
Rm𝒲, such that for any formula ϕ(x1, . . . , xk) ∈ℒits Montague’s meaning is a function
In(ϕ(x1, . . . , xk)) : 𝒲→R that maps each explicit possible world into the m-extension
of this formula in each given possible world, given by
In(ϕ(x1, . . . , xk))(w) = ‖ϕ(x1, . . . , xk)‖ℳ,w.
This meaning is compositional. That is, the meaning of a complex logic formula (or
the complex concept obtained by applying the intensional interpretation I to this for-
mula), is functionally dependent on meanings of its subformulae. It is result of the
fact that for any formula,
In(ϕ(x1, . . . , xk))(w) = 󵄩󵄩󵄩󵄩ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩ℳ,w = w(ϕ(x1, . . . , xk)) = I∗
mv(ϕ(x1, . . . , xk)),
from the fact that w = I∗
mv and is a homomorphism between free syntax algebra 𝒜mFOL
and algebra of m-extensions 𝒜Rm given in Corollary 21. For example,

314
|
5 Theory of many-valued intensional first-order logic
In(ϕ ∧ψ)(w) = I∗
mv(ϕ ∧ψ) = I∗
mv(ϕ) ⊗S I∗
mv(ϕ) = In(ϕ)(w) ⊗S In(ψ)(w),
where S is uniquely determined by the common subset of free variables in ϕ and in ψ.
Consequently, the Kripke semantics of ℒin given by Definition 82, based on pos-
sible worlds and accessibility relations, represents this intensional aspect of the
logic ℒin.
The meaning, concept-algebra semantics and the many-valuedness of any logic
formulae ϕ(x1, . . . , xk) in ℒin, can be represented synthetically by the following equal-
ities:
In(ϕ(x1, . . . , xk))(w)
(Montague’s “meaning” semantics)
= 󵄩󵄩󵄩󵄩ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩ℳ,w
(Kripke semantics)
= I∗
mv(ϕ(x1, . . . , xk))
(concept-algebra semantics)
= {(g(x1), . . . , g(xk), v∗(ϕ(x1, . . . , xk)/g)) | g ∈𝒟𝒱}
(many-valued semantics),
where I∗
mv = is−1
in (h) (from Corollary 21) is a MV-interpretation of ℒin, equivalent to the
Bealer’s concept-extensionalization function h for a given fixed intensional homomor-
phic interpretation I : 𝒜mFOL →𝒜mint.
5.3 Resolution of Liar formula in many-valued intensional FOL
Let us introduce the Liar paradox in the standard 2-valued FOL of arithmetic (stan-
dard 2-valued first-order Peano arithmetic), extended by a primitive satisfaction bi-
nary predicate (Gödel) Sat(x, y), governed by Tarskian axioms. This system of axioms
governing Sat(x, y) was given in [220].
The philosophical significance of such FOL logic is discussed in [221], compared
with minimalistic extensions generated by adding just the “T-schema” (the set of for-
mulae T(⌜ϕ⌝) ⇔ϕ where ⌜ϕ⌝is the code (positive integer) obtained by Gödel’s codifi-
cation of logic formula ϕ, and T is a unary truth predicate introduced in Definition 76).
Similar constructions are considered in [222].
The idea is then Sat(x, y) expresses the satisfaction relation between (codes of)
formulae and (codes of) sequences of the formulae. Then T(x) expresses the concept
of truth for such formulae and sequences. In fact, it can be shown that this theory
satisfies Tarski’s convention (T): i. e., that
T(⌜ϕ⌝) ⇔ϕ
(5.41)
is a theorem in this 2-valued Peano arithmetic FOL.
If ϕ is any formula with one free variable x, then the diagonalization of ϕ, can
be defined by mapping d : ℒ→ℒ, such that d(ϕ(x)) = ϕ(⌜ϕ(x)⌝), equivalent to the
formula (∃y)(y = ⌜ϕ(x)⌝∧ϕ(y)).

5.3 Resolution of Liar formula in many-valued intensional FOL
|
315
Based on this mapping, we can define the mapping diag : N →N, such that for
any non-negative integer n ∈N, diag(n) = ⌜d(ϕ(x))⌝if n = ⌜ϕ(x)⌝; 0 otherwise.
Now we can introduce the binary predicate Diag(x, y) such that for any two
n, k ∈N, Diag(k, n) is true iff n = diag(k)
̸= 0, i. e., if n is the code of the formula
obtained by diagonalization of the formula ϕ(x) whose code is equal to k.
From the diagonalization lemma (or fixed-point theorem) in Peano arithmetic
FOL, there must be a fixed-point formula λ such that, the following formula is a
theorem in this logic:
λ ⇔∼T(⌜λ⌝),
for λ equal to d(∼T(diag(x)))
(5.42)
It is easy to show that ∼T(diag(x)) is equal to the formula (∃y)(Diag(x, y)∧∼T(y))
with the free variable x. Thus,
λ is equal to the formula d((∃y)(Diag(x, y)∧∼T(y))),
that is, to (∃z)(Diag((⌜∃y)(Diag(x, y)∧∼T(y))⌝, z)∧∼T(z))
(5.43)
The analysis of the proof of this diagonalization lemma [223, 224] shows that this for-
mula λ must contain the predicate T(x). This formula is the formal analogue of the
so-called “strengthened liar” for this system. It is a formula that “says of itself that it is
not true.”
In fact, it expresses the Liar paradox. If we assume that λ is true than ∼T(⌜λ⌝)
must be true, i. e., T(⌜λ⌝) must be false and, consequently, from (5.41) we obtain that λ
is false: the contradiction. This is the same contradiction that we obtain if we assume
that λ is false.
Let us consider now this problem inside the intensional many-valued FOL ℒin de-
fined previously. In fact, instead of the formula λ ⇔∼T(⌜λ⌝) in (5.42) for the sentence
λ defined in (5.43), we can use the intensional abstraction operator ⋖_ ⋗and obtain
equivalent to it formula
λ ⇔∼T(⋖λ⋗)
(5.44)
where the ground atom T(⋖λ⋗) has the natural language meaning “it is true that λ,”
so that in the classic 2-valued logic again we obtained famous Liar contradiction.
Let us show that the unary truth-predicate T in ℒin (with ℒ0 the subset of closed
formulae) used to represent the concept of truth defined by the equivalence (5.41) can-
not be 2-valued as in the case of the standard 2-valued FOL. In fact, if we try to define
it as a 2-valued built-in predicate, such that for each I∗
mv ∈𝒲,
I∗
mv(T(x)) =def {(⋖ψ⋗, t) | ψ ∈ℒ0 and I∗
mv(ψ) = {t}}
then for any sentence ϕ from (5.44) we would have that I∗
mv(ϕ) ∈{0, {t}}, thus I∗
mv(λ) ∈
{0, {t}}, but in that case for the Liar formula (5.42) we will have that I∗
mv(λ) = I∗
mv(∼

316
|
5 Theory of many-valued intensional first-order logic
T(⋖λ⋗)) = ⊘I∗
mv(T(⋖λ⋗)) = ⊘I∗
mv(λ) what is impossible for any I∗
mv ∈𝒲, because ⊘0 =
{t}
̸= 0 and ⊘{t} = 0
̸= {t}.
Consequently, the built-in unary predicate T has to be many-valued as well and to
satisfy the condition (5.44), as we defined for the many-valued semantics of T in the
logic ℒin.
From the considerations above, in ℒin there is no any MV-interpretation I∗
mv ∈𝒲
such that I∗
mv(λ) ∈{0, {t}}. But for each MV-interpretation I∗
mv of ℒin, we may fix I∗
mv(λ) =
{κ} in the way that the fixed-point Liar formula λ satisfy (5.44), with the many-valued
unary predicate T, such that
(⋖λ⋗, κ) ∈I∗
mv(T(x)),
(5.45)
and hence to avoid the “Liar paradox” in the many-valued intensional FOL ℒin.
Corollary 22. The Liar self-reference sentence is not a paradox in ℒin, thus, does not
create the contradictions.
Proof. For any MV-interpretation I∗
mv, such that I∗
mv(λ) = {κ} (or an equivalent many-
valued interpretation v∗such that v∗(λ) = κ), such that ∼κ = κ in the lattice of truth
values X we have that I∗
mv(∼T(⋖λ⋗)) = ⊘I∗
mv(λ) = ⊘({κ}) = {κ} = I∗
mv(λ) so that (5.42) is
satisfied. Thus, in ℒin the value to λ is assigned without any contradiction.
Remark. The minimal many-valued logic that resolve this problem can be the Kleene
three-valued logic (where κ is “unknown” value). However, for this case better solu-
tion would be to use the 4-valued Belnap’s bilattice X = ℬ4 (more about it can be found
in Section 5.1.3), by assigning the ⊤(“inconsistent value”) to κ. In effect, Belnap’s bi-
lattice ℬ4 is the best candidate to use the many-valued intensional FOL ℒin for data
integration systems where we can have both unknown and mutually inconsistent in-
formation coming from different sources.
Analogously, the Gödel’s contradictory formulae obtained by diagonalization of
the formula ∼Prov(diag(x)), where Prov(x) is a formula representing provability in
the Peano arithmetic FOL can be resolved in ℒin by interpreting these formulae with
the value κ = ⊥(“unknown value”) of Belnap’s bilattice.
Moreover, in Section 6.3 we will consider the P2P database systems, such that each
peer database is a single data integration system (adopting, however, the Belnap’s
multivalued logic for each peer in order to consider directly the incomplete and in-
consistent data), with inter-peer mappings defined by intensionally equivalent many-
valued views, in the way as described the query-answering in the P2P database systems
(see Sections 3.2 and 3.2.3) by classic two-valued FOL in Chapter 3.
All these examples, and much more provided in [209], explain how the Belnap’s
based intensional FOL ℒI can have very important rule in the mathematical logics
theory and practice.

6 Applications of many-valued intensional
first-order logic
6.1 Relevant Lukasiewicz–Tarski logics
As far as I know, the study of the relevant implication dates back at least to 1928 with
I. E. Orlov’s axiomatization of propositional logic weaker than classical logic [225],
shown by my colleague from Belgrade, Kosta Dosen [226]: we worked independently
and at different times on the possible weakening of negation logical connective [210],
but different from him, I worked for the weakening of the negation for the da Costa
paraconsistent logic [227, 228] presented with some new advances here in Section 6.2.
In Orlov’s system, the only rule is modus ponens, and he axiomatized this logic
in order to “represent relevance between propositions in symbolic form,” as follows:
ϕ ⇒¬¬ϕ
double negation introduction
¬¬ϕ ⇒ϕ
double negation elimination
ϕ ⇒(¬ϕ ⇒¬ϕ)
contraposed reduction
(ϕ ⇒ψ) ⇒(¬ψ ⇒¬ϕ)
contraposition
(ϕ ⇒(ψ ⇒φ)) ⇒(ψ ⇒(ϕ ⇒φ))
permutation
(ϕ ⇒ψ) ⇒((φ ⇒ϕ) ⇒(φ ⇒ψ))
prefixing
ϕ, ϕ ⇒ψ ⊢ψ
modus ponens rule
The axioms and rules here form a traditional Hilbert system. Neither of the follow-
ing formulae are provable in Orlov’s system:
ϕ ⇒(ψ ⇒ψ),
¬(ψ ⇒ψ) ⇒ϕ
These axioms and the rule do not explicitly represent any notion of relevance. Instead,
we have an axiomatic system governing the behavior of implication and negation. The
system tells us about relevances in virtue of what it leaves out, rather than what it
includes. In Orlov’s system, a formula ϕ ⇒ψ is provable only when ϕ and ψ share a
propositional atom. There is no way to prove a condition in which the antecedent and
the consequent have nothing to do with one another! The effect, as was demonstrated
more than 30 years later, Orlov axiomatized the implication and negation fragment of
the now well-known relevant logic R.
In 1958, Anderson and Belnap took up ideas from Church and Ackermann, and
started a research program into what in time became relevance (now often called rel-
evant) logic. Their chosen name picked up an informal use before that time of the
epithet “relevant” to characterize a consequence relation, and an implication, which
was not paradoxical in the way material and strict implications were. For example,
the truth-functional material implication ϕ ⇒ψ is true whenever ϕ is false or ψ
https://doi.org/10.1515/9783110981438-006

318
|
6 Applications of many-valued intensional first-order logic
is true, i. e., equivalent to (¬ϕ ∨ψ) for the truth-functional disjunction ∨and nega-
tion ¬. Among the paradoxes of material implication are the following: ϕ ⇒(ψ ⇒ϕ),
¬ϕ ⇒(ϕ ⇒ψ) and (ϕ ⇒ψ) ∨(ψ ⇒φ). The first asserts that every proposition
implies a true one; the second suggests that a false proposition implies every proposi-
tion, and the third, that for any three propositions, either the first implies the second
or the second implies the third.
Also, the strict implication defined by ¬◊(ϕ ∧¬ψ), where ◊is an existential “pos-
sible” modal operator, so that it is true whenever it is not possible that ϕ is true and ψ
false has a number of paradoxes.
Relevance logicians have attempted to construct logics that reject theses and ar-
guments that commit “fallacies of relevance.” For example, they do not admit the clas-
sical valid inference such as, “The moon is made of green cheese. Therefore, either it is
raining in Ecuador now or it is not.”
I believe that are the correct philosophical reasons for rejecting classical logic and
adopting a relevant logic as a correct description of the basis of inference. These are
not, in general, the reasons which led historically to the development of the subject,
and are not those emphasized in the writings of Anderson, Belnap and Dunn.
In relevance logic, it is admitted that “if ϕ then ψ” can be false without ϕ being
true or ψ false, so that ‘if” is not truth-functional material implication but a binary
modal operator. From the realization that “if” is not truth-functional, we can draw
three morals. The first is that ex falso quodlibet is invalid.
The Lewis arguments
We can return to the famous derivation of ψ from ϕ and “not-ϕ,” which Lewis gave.
The derivation was not original to Lewis. The earliest presentation I know was given by
Alexander Neckam in his De Naturis Rerum [229], written around 1200. Neckam retails
many of the logical subtleties and included among these is the following derivation.
The derivation proceeds rapidly by two applications of simplification, one of addition,
and the notorious final step of disjunctive syllogism:
“I am amazed also at those criticising the claim that from the impossible in itself anything whatever
follows. This may be established in many ways, but few will show more clearly. Is it not the case that
if Socrates is a man and Socrates is not a man, then Socrates is a man? But if Socrates is a man,
Socrates is a man or a stone. So if Socrates is a man and Socrates is not a man, Socrates is a man
or a stone. But if Socrates is a man and Socrates is not a man, Socrates is not a man. So if Socrates
is a man and Socrates is not a man, Socrates is a stone. By a similar deduction, it may be proved
that if Socrates is a man and Socrates is not a man, Socrates is a goat, and so on for any other thing,
such as a rose, a lily and so on. Don’’t you therefore see that in this way from this impossibility, that
Socrates is a man and Socrates is not a man, anything follows?”
The structure of the argument is as follows:
(1) Suppose ϕ and not-ϕ
(2) Then ϕ (by Simplification of (1)),

6.1 Relevant Lukasiewicz–Tarski logics
|
319
(3) whence ϕ or ψ (by Addition),
(4) not-ϕ (by Simplification of (1) again),
(5) and finally ψ (by Disjunctive syllogism from (3) and (4)).
However, I will not consider the relevant implication, studied so long time, but other
logic connectives. So, I would chose initially the logics, which do not use the impli-
cation as logic connective, and hence the first candidate to analyze is the De Morgan
logic, which uses three other classical logic connectives. From the fact that the nega-
tion connective is often used as an epistemic modal operator, I think that it is a more
original approach to consider the relevance of other two binary (extensional) connec-
tives, disjunction and conjunction, which are algebraically defined as join and meet
operations in a given lattice (X, ≤) of truth values (also in the case of the classical two-
valued logics), and to replace them with the new intensional disjunction and conjunc-
tion. Such intensional disjunction and conjunction are introduced in the well-known
infinite-valued Lukasiewicz–Tarski logic called fusion and fission connectives as well.
With this approach, I will try to give some original new contributions for the relevance
logics.
Orlov’s work looked at the behavior of other connectives definable in terms of con-
junction and negation. He showed that defining a conjunction connective
ϕ ∧ψ =def ¬(ϕ ⇒¬ψ)
(6.1)
gives you a connective that can be shown to be commutative and associative
ϕ ∧ψ ⇒ψ ∧ϕ,
(ϕ ∧ψ) ∧φ ⇒ϕ ∧(ψ ∧φ),
ϕ ∧(ψ ∧φ) ⇒(ϕ ∧ψ) ∧φ,
(6.2)
and square increasing
ϕ ⇒ϕ ∧ϕ
(6.3)
In the same way, Orlov defined disjunction connective
ϕ ∨ψ =def ¬ϕ ⇒ψ,
(6.4)
which can be shown to be associative, commutative and square decreasing,
ϕ ∨ϕ ⇒ϕ
(6.5)
It follows that these defined connectives for conjunction and disjunction do not have
the full force of the lattice meet and join operations present in classical and intuition-
istic logic. In effect, his conjunction and disjunction are intensional notions, while
that based on lattice operations are extensional ones. At the very first example of the
study of substructural logics, we are at the doorstep of one of the profound insights

320
|
6 Applications of many-valued intensional first-order logic
made clear in this area: the splitting of notions identified in stronger logical systems.
In the literature of relevant logic, the intensional notions of conjunction and disjunc-
tion (6.2) and (6.4), and call them fusion and fission.
Remark. My aim is just to define a new semantics of conjunction and disjunction con-
nectives (fusion and fission) as intensional notions, but different from Orlov, such that
they do not satisfy the associativity. The same approach will be in detail applied to
infinite-valued Lukasiewicz–Tarski logics where square increasing and decreasing are
opposite of this Orlov’s system.
Moreover, I would like to render the relevant implication independent from these
two basis connectives, I will not define the conjunction and disjunction from the im-
plication connective, and will leave the implication outside of this investigation and
will work only with these basic logical connectives and with negation, and hence will
consider the De Morgan logics.
From the fact that I will try to remain also after transformation of these two binary
logic connectives in De Morgan logics, where the conjunction operator is derivable
from the negation and disjunction, i. e., ϕ ∧ψ is logically equivalent to the formula
¬(¬ϕ ∨¬ψ), the only logical connective considered for the relevance “weakening”
in this methodological approach is the disjunction connective, i. e., its corresponding
algebraic operation denoted by ̃∨(derived from it, by De Morgan law, intensional con-
junction (fission) will be denoted by ̃∧).
Consequently, the most work will be dedicated to the De Morgan algebras of truth
values in a lattice (X, ≤), where the relevant disjunction will be a binary modal opera-
tion. The semantics that is presented here for this binary modal operator for disjunc-
tion is the ternary relation semantics, due to Richard Routley and Robert K. Meyer.
These semantics are a development of Alasdair Urquhart’s “semilattice semantics”
[230]. There is a similar semantics, due to Kit Fine, that was developed at the same
time as the Routley–Meyer theory [231]. And there is an algebraic semantics due to J.
Michael Dunn. The idea behind the ternary relation semantics is rather simple. Con-
sider C. I. Lewis’ attempt to avoid the paradoxes of material implication. He added a
new connective to classical logic, that of strict implication. Unfortunately, from a rele-
vant point of view, the theory of strict implication is still irrelevant. One interpretation
is suggested in Jon Barwise [232] and developed in Restall [233]. On this view, worlds
are taken to be information-theoretic “sites” and “channels.” A site is a context in
which information is received and a channel is a conduit through which information
is transferred. Another interpretation is developed in Mares [234]. This interpretation
takes the Routley–Meyer semantics to be a formalization of the notion of “situated im-
plication.” This interpretation takes the “worlds” of the Routley–Meyer semantics to
be situations. A situation is a perhaps partial representation of the universe. The infor-
mation contained in two situations, a and b might allow us to infer further informa-
tion about the universe that is contained in neither situation. Another informational
interpretation is in Dunn [235].

6.1 Relevant Lukasiewicz–Tarski logics
|
321
Note that we cannot use Dunn’s Gaggle theory [236] as a general method for ob-
taining Kripke-style semantics for our algebraic logics, where n-ary logical connective
is associated with n + 1-ary relation over a set of possible worlds, because in our case
does not hold more square increasingness x ≤x ̃∧x for the modal conjunctive opera-
tion ̃∧for our intensional (modal) logical conjunction. In fact, in our relevant De Mor-
gan sublogics of the infinite-valued Lukasiewicz’s logic, we will have that x ̃∨x ≥x;
so that from fact that ∼∼x = x we obtain x ̃∧x =∼(∼x ̃∨∼x) ≤∼∼x = x, for the De
Morgan negation ∼. So, in order to dedicate our attention to the definition of relevant
Lukasiewicz’s logic based on the lattice of reals X = [0, 1] with fusion defined as a
t-norm, we will begin to consider the substructural properties of t-norm fuzzy logics
in the next section.
Moreover, we cannot use the Routley–Meyer Kripke-style frames with ternary ac-
cessibility relations for the binary conjunction operation ̃∧, which has to be used in De
Morgan monoids and its Routley–Meyer representation. The fact is that our conjunc-
tion operation is not associative (it is only commutative), so a lattice-ordered groupoid
(X, ≤, ⋀, ⋁, ̃∧), where ⋀and ⋁are the lattice’s meet and join operations, respectively,
cannot be a lattice-ordered semigroup (see Definition 1 in [237]). So with this binary
modal operation ̃∧, we cannot obtain the Pierce grupoid, and hence Pierce monoid.
Moreover, we cannot obtain also the De Morgan monoid, which requires the square
increasingness x ≤x ̃∧x [237] as in the case of the Dunn’s Gaggle theory.
So, I followed a new approach used also for the definition of the autoreferential
Kripke semantics for many-valued logics, in different context, from the strict autorefer-
ential semantics (provided in Definition 58 in Section 5.1) to a more general canonical
semantics case in Section A.3, and a new philosophical interpretation in order to give
a real meaning on this autoreferential semantics where the set of possible worlds is
just the (sub)set of truth values of the many-valued logic.
6.1.1 Introduction to substructural properties of T-norm fuzzy logics
In the application of fuzzy logic to expert systems, fuzzy control and the like, it is not
a single logic that is used, but a plethora of distinct logics. The choice used in a spe-
cific application is often ad hoc decided on the basis of empirical factors or mere whim.
There is a technical commonality to these logics in that they all arise in the same man-
ner through the specification of an algebra of truth values, i. e., a set of truth values
equipped with algebraic operations corresponding to each of the logical connectives
in question.
The difference and the logical meaning are introduced when an algebra of truth
values is given. This is just an algebra with the same number of basic operations as
there are connective symbols and with matching arities. In many cases, the operations
corresponding to conjunction and disjunction are taken to be idempotent or to have

322
|
6 Applications of many-valued intensional first-order logic
other special properties. However, we wish to stress that we are not placing any such
restrictions on the algebra, as for instance in [238].
We apply our methods to the study of fuzzy logics arising from truth value algebras
on the unit interval that are strict De Morgan systems. This class of logics includes also,
e. g., the ones in which the fuzzy conjunction is given by the usual multiplication of
real numbers, a common choice in applications.
However, here we mainly consider applications to the t-norm fuzzy logic (t-norm
fuzzy logics impose certain natural constraints on the truth function of intensional
(strong) conjunction in Definition 83) as members of the family of fuzzy logics, and
then we will modify the disjunction and conjunction connectives to obtain a kind of
relevant fuzzy logics. The standard set of truth degrees for fuzzy logics is the real unit
interval X = [0, 1] with its natural ordering ≤, ranging from total falsity (represented
by 0) to total truth (represented by 1) through a continuum of intermediate truth de-
grees. The most fundamental assumption of (mainstream) mathematical fuzzy logic
is that connectives are to be interpreted truth-functionally over the set of truth de-
grees. Such truth functions are assumed to behave classically on the extremal values
0 and 1. A very natural behavior of conjunction and disjunction is achieved by impos-
ing x ⋀y = min{x, y} and x ⋁y = max{x, y} for each x, y ∈X, so that ⋀and ⋁are the
meet and join operations of the lattice (X, ≤).
Another, nonidempotent, binary conjunction ⊗is typically added to account for
the intuition that by applying a partially true hypothesis twice might lead to a different
degree of truth than using it only once. That is, for x ∈X,
x ⊗x
̸= x
(6.6)
So, it is not necessarily idempotent, but still commutative and nondecreasing in both
arguments, associative and has 1 as a neutral element (see point 4 of Definition 83
where T is this binary conjunction). These operations are called t-norms (triangular
norms) and their mathematical properties have been thoroughly studied. Prominent
examples of t-norms are the already mentioned function min (meet lattice operation),
the standard product of real numbers and the Lukasiewicz t-norm: x ⊗y = max{x + y −
1, 0}.
Definition 83. A binary function T : [0, 1]2 →[0, 1] is called a triangular norm (simply
a t-norm) in the theory of probabilistic metric spaces, if the following holds for x, y, z:
1.
T(x, y) = T(y, x),
2.
x ≤y implies T(x, z) ≤T(y, z).
3.
T(x, T(y, z)) = T(T(x, y), z),
4.
T(x, 1) = x.
Continuity of the function T (the previous conditions reduce this requirement to the
continuity in either argument) informally expresses the assumption that microscopic

6.1 Relevant Lukasiewicz–Tarski logics
|
323
changes of the truth degrees of conjuncts should not result in a macroscopic change
of the truth degree of their conjunction.
Thus, ([0, 1], ⊗, 1) forms a commutative monoid if we define ⊗by x ⊗y = T(x, y).
Formulae that always evaluate to 1 are called tautologies with respect to the given
left-continuous t-norm ⊗or ⊗-tautologies. The set of all ⊗-tautologies is called the logic
of the t-norm ⊗, as these formulae represent the laws of fuzzy logic (determined by the
t-norm), which hold (to degree 1) regardless of the truth degrees of atomic formulae.
Some formulae are tautologies with respect to a larger class of left-continuous t-norms;
the set of such formulae is called the logic of the class. Important t-norm logics are the
logics of particular t-norms or classes of t-norms, e. g.:
1.
Basic fuzzy logic BL is the logic of (the class of) all continuous t-norms,
2.
Lukasiewicz logic is the logic of the Lukasiewicz t-norm x ⊗y = max{x + y −1, 0},
3.
Gödel–Dummett logic of the minimum t-norm x ⊗y = min{x, y} was implicit in
Gödel’s 1932 proof of infinite-valuedness of intuitionistic logic,
4.
Product fuzzy logic is the logic of the product t-norm x ⊗y = x ⋅y.
Basic fuzzy Logic (or shortly BL), the logic of the continuous t-norms is one of the
t-norm fuzzy logics. It belongs to the broader class of substructural logics, or logics
of residuated lattices. Basic fuzzy logic and its corresponding BL-algebras were intro-
duced by Hájek (see [239] and the references given there) with the purpose of formaliz-
ing the many-valued semantics induced by the continuous t-norms on the real unitary
interval X = [0, 1].
Definition 84. A generalized BL is an algebra (X, ⋀, ⋁, ⊗, →, 1) such that:
1.
(X, ⋀, ⋁) is a lattice with greatest element 1,
2.
(X, ⊗, 1) is an abelian monoid (commutative and associative monoid with the unit
element 1), with equations:
3.
x →x = 1
4.
(x ⊗y) →z = x →(y →z)
5.
x ⋀y = x ⊗(x →y)
6.
(x →y) ⋁(y →x) = 1
A BL-algebra (X, ⋀, ⋁, ⊗, →, 1, 0) is bounded generalized BL algebra with 0 the lower
bound.
Hájek showed that a propositional formula is provable in BL if and only if it is a
tautology in any linearly ordered BL-algebra.
Definition 85. An algebra (X, ⋀, ⋁, ⊗, →, 1) is a commutative residuated lattice if:
1.
(X, ⋀, ⋁) is a lattice,
2.
(X, ⊗, 1) is an Abelian monoid (commutative and associative monoid with the unit
element 1),
3.
for x, y ∈X, x ⊗y ≤z iff x ≤y →z (the law of residuation).

324
|
6 Applications of many-valued intensional first-order logic
A commutative residuated lattice (X, ⋀, ⋁, ⊗, →, 1) is a FLew algebra if 1 is the greatest
element and 0 is least element in the lattice.
The residuum of a left-continuous t-norm can explicitly be defined as (x →y) =
⋁{z | z ⊗x ≤y}. This ensures that the residuum is the pointwise largest function such
that for all x, y ∈X, x ⊗(x →y) ≤y. The latter can be interpreted as a fuzzy version of
the modus ponens rule of inference.
Truth functions of further propositional connectives can be defined by means of
the t-norm and its residuum, for instance the residual negation ∼x = (x →0).
Remark. The sequent calculus FLew is obtained from Gentzen’s sequent system LJ for
intuitionistic logic by deleting the contraction rule [240] and adding rules for the logical
connective fusion ⊗. The algebraic condition which corresponds to the contraction rule
is x ⊗x ≥x (square-increasingness), from which the inequality x ⊗y ≥x ⋀y holds. For
each FLew-algebra M, the monoid operation ⊗is square-increasing in M iff it is equal
to the meet operation ⋀, iff M is Heyting algebra where x ⊗x = x ⋀x = x.
In fact, the Gentzen’s sequent system for FLew consists of the following two ax-
ioms1 (here ⊥denotes the falsity nullary logical constant, such that for each many-
valued valuation v, v(⊥) = 0, while ⊤denotes the tautology nullary logic constant
such that for all valuations v(⊤) = 1), from [240]2:
1.
ϕ ⊢ϕ
2.
Γ, ⊥⊢ϕ, Γ ⊢⊤
and the following rules of inference:
Γ ⊢ϕ,
Γ1, ϕ ⊢ψ
Γ, Γ1 ⊢ψ
(cut/transitivity rule)
Γ, ϕ, ψ, Γ1 ⊢φ
Γ, ψ, ϕ, Γ1 ⊢φ
(exchange),
Γ ⊢ψ
Γ, ϕ ⊢ψ
(weak)
Rules for logical connectives:
Γ, ϕ ⊢ψ
Γ ⊢ϕ ⇒ψ
(→⇒),
Γ ⊢ϕ,
Γ1, ψ ⊢φ
Γ, ϕ ⇒ψ ⊢φ
(⇒→)
Γ ⊢ϕ
Γ ⊢ϕ ∨ψ
(→∨)1,
Γ ⊢ψ
Γ ⊢ϕ ∨ψ
(→∨)2
Γ, ϕ ⊢φ,
Γ, ψ ⊢φ
Γ, ϕ ∨ψ ⊢φ
(∨→)
1 We recall that, for a Γ = {ϕ1, . . . , ϕn}, the sequent Γ ⊢ψ is an axiom iff it is valid, i. e., when for all
valuations v, v∗(Γ) =def v∗(ϕ1) ⋀. . . ⋀v∗(ϕn) ≤v∗(ψ).
2 From my opinion, this sequent system is not complete because the “residuation property” between
implication and fusion is not provided. Because of that, I explicitly added these two rules in (6.8).

6.1 Relevant Lukasiewicz–Tarski logics
|
325
Γ ⊢ϕ,
Γ ⊢ψ
Γ ⊢ϕ ∧ψ
(→∧)
Γ, ϕ ⊢φ
Γ, ϕ ∧ψ ⊢φ
(∧→)1,
Γ, ψ ⊢φ
Γ, ϕ ∧ψ ⊢φ
(∧→)2
Γ ⊢ϕ,
Γ1 ⊢ψ
Γ, Γ1 ⊢ϕ ⊗ψ
(→⊗),
Γ, ϕ, ψ ⊢φ
Γ, ϕ ⊗ψ ⊢φ
(⊗→)
(6.7)
and, added by me, for the “residuation property” between implication and fusion
ϕ ⊗ψ ⊢φ
ϕ ⊢ψ ⇒φ
(res 1),
ϕ ⊢ψ ⇒φ
ϕ ⊗ψ ⊢φ
(res 2)
(6.8)
where (6.7) are the insertion and elimination rules for the t-norm strong conjunction
logical connective.
Example 35. Let us show that the monoidal Abelian properties of the fusion ⊗can be
obtained from two axioms and rules in (6.7):
1.
Commutativity: from axioms and (→⊗), ϕ⊢ϕ,
ψ⊢ψ
ϕ,ψ⊢ϕ⊗ψ . Then by the exchange rule
ϕ, ψ 󳨃→ψ, ϕ and with φ equal to ϕ ⊗ψ, from (⊗→), we obtain ψ ⊗ϕ ⊢ϕ ⊗ψ. We
derive analogously also ϕ ⊗ψ ⊢ψ ⊗ϕ.
2.
Monoidal unit property: From axioms and (→⊗), ϕ⊢⊤,
ϕ⊢ϕ
ϕ⊢ϕ⊗⊤
, and from (⊗→),
ϕ,⊤⊢ϕ
ϕ⊗⊤⊢ϕ.
3.
Associativity: from axioms and (→
⊗), ψ⊢ψ,
φ⊢φ
ψ,φ⊢ψ⊗φ . Then again from (→
⊗),
ϕ⊢ϕ,
ψ,φ⊢ψ⊗φ
ϕ,ψ,φ⊢ϕ⊗(ψ⊗ϕ) and from exchange and (⊗→), we obtain φ,ϕ,ψ⊢ϕ⊗(ψ⊗φ)
φ,ϕ⊗ψ⊢ϕ⊗(ψ⊗φ). And again
from exchange and (⊗→), we obtain
ϕ⊗ψ,φ⊢ϕ⊗(ψ⊗φ)
(ϕ⊗ψ)⊗φ⊢ϕ⊗(ψ⊗φ), i. e., (ϕ⊗ψ)⊗φ ⊢ϕ⊗(ψ⊗φ).
Sometimes we call substructural logics over FLew, or logics without contraction
rule, although the contraction rule holds in some of them. The class of logics with-
out the contraction rule contains intermediate logics, BCK-logics, Lukasiewicz’s many-
valued logics and fuzzy logics (in the sense of [239]).
It has been shown that Hájek’s basic logic BL is an extension of the substructural
logic FLew, or equivalently, Höhle’s monoidal logic. Thus, fuzzy logics can be viewed
as a special subclass of substructural logics. On the other hand, their close connec-
tions areoften overlooked,sincethese twoclasses oflogicshavebeenmotivatedby dif-
ferent aims, and so introduced and studied separately. So, we start to give a definition
of commutative residuated lattices and then give a definition of FLew-algebras. MV-
algebras, the algebras of Lukasiewicz infinite-valued logic (Lukasiewicz-Tarski logic
[241]), form a subvariety of BL, which is characterized by the De Morgan equation
∼∼x = x (see [239]), and hence we can naturally view fuzzy logics and Lukasiewicz’’s
many-valued logics as extensions of the substructural logic FLew. The variety of MV-
algebras is denoted by 𝕄𝕍. Relations between BL and Lukasiewicz infinite valued
logic are similar to the ones existing between intuitionistic and classical logics [242].

326
|
6 Applications of many-valued intensional first-order logic
Propositional infinite-valued Lukasiewicz logic can also be axiomatized by adding
the following axioms to the axiomatic system of monoidal t-norm logic FLew.
Divisibility
(ϕ ∧ψ) ⇒(ϕ ⊗(ϕ ⇒ψ)) (see equation (6.10) of the MV-algebras). With this axiom,
extending FLew algebra by equation x ⋀y = x ⊗(x →y), we obtain fuzzy logic with
BL-algebra (point 5 in Definition 84).
Double negation
¬¬ϕ ⇒ϕ. By adding the equation ∼∼x = x to BL-algebra, we obtain MV-algebra (see
poit 4 in Definition 87).
That is, infinite-valued Lukasiewicz logic arises by adding the axiom of double
negation to basic t-norm logic BL. The axioms of the infinite-valued Lukasiewicz logic
are the following:
(A1) ϕ ⇒(ψ ⇒ϕ)
(A2) (ϕ ⇒ψ) ⇒((ψ ⇒φ) ⇒(ϕ ⇒φ))
(A3) ((ϕ ⇒ψ) ⇒ψ) ⇒((ψ ⇒ϕ) ⇒ϕ)
(A4) (¬ϕ ⇒¬ψ) ⇒(ψ ⇒ϕ)
and with modus ponens as the only primitive rule: ϕ, ϕ ⇒ψ ⊢ψ.
Thus, Lukasiewicz’’s infinite-valued logic is commonly defined as the set of for-
mulae that take the value 1 under all evaluations in the Lukasiewicz algebra on the
unit real interval. In the literature, a deductive system axiomatized in a Hilbert style
was associated to it, and was later shown to be semantically defined from Lukasiewicz
algebra by using a truth-preserving scheme. However, there exists no Gentzen calcu-
lus fully adequate for it.
Here, instead, we use the framework of abstract algebraic logic to study a dif-
ferent deductive system, which uses the aforementioned algebra under a scheme of
“preservation of degrees of truth” used in this book and provided in Section 5.1 by
Definition 57. This deductive system is algebraizable, nonself-extensional and does
not satisfy the deduction theorem [243]. The resulting deductive system is defined in
a natural way by using the lattice filters of Wajsberg algebras (X, →, ∼) (equivalent to
DL algebras by defining all other operations as presented below, and by adding the
equation ∼∼x = x) and also by using a structural Gentzen calculus, which is shown
to be fully adequate for it.
Definition 86. Wajsberg algebras (X, →, ∼) are defined by the following set of equa-
tions:
(W1) y = (x →x) →y
(W2) x →x = (x →y) →((y →x) →(x →z))
(W3) (x →y) →y = (y →x) →x
(W4) (x →x) = (∼x →∼y) →(y →x)

6.1 Relevant Lukasiewicz–Tarski logics
|
327
These algebras are polynomially equivalent [243] to Wajsberg algebras as origi-
nally defined by Rodriguez in [244]. The variety of all Wajsberg algebras, denoted
by W, is generated by the lattice on the unit real interval (X, ⋀, ⋁) with the well-known
Lukasiewicz operations ∼x = 1 −x and x →y = min{1, 1 −x + y}.
This logic is an interesting example for the general theory: it is self-extensional,
non-protoalgebraic, and satisfies a “graded” deduction theorem. Moreover, the Gent-
zen system is algebraizable following Blok and Pigozzi’s theory in [245]. The first men-
tioned deductive system turns out to be the extension of the second by the rule of
modus ponens.
By considering the logical language ℒwith only two connectives (¬, ⇒) of type
(1, 2) with also defined connectives ∧, ∨, ⊗and ⊕given by
ϕ ∨ψ defined by (ϕ ⇒ψ) ⇒ψ
ϕ ∧ψ defined by ¬(¬ϕ ∨¬ψ)
ϕ ⊗ψ defined by ¬(ϕ ⇒¬ψ)
ϕ ⊕ψ defined by ¬ϕ ⇒ψ
the Gentzen’s sequent system G∞for Lukasiewicz’s logic [243], consists of the follow-
ing axioms and rules:
(1) ϕ ⊢ϕ
(2) ⊢ϕ ⇒ϕ
(3) ϕ ⇒(ψ ⇒φ) ⊢(ψ ⇒ϕ) ⇒φ
and the following rules of inference:
Γ ⊢ϕ,
Γ1, ϕ ⊢ψ
Γ, Γ1 ⊢ψ
(cut)
Γ ⊢φ
Γ, ϕ ⊢φ
(weak)
rules for logical connectives:
Γ ⊢ϕ
Γ ⊢ϕ ∨ψ
(→∨)1,
Γ ⊢ψ
Γ ⊢ϕ ∨ψ
(→∨)2
Γ, ϕ ⊢φ,
Γ, ψ ⊢φ
Γ, ϕ ∨ψ ⊢φ
(∨→)
Γ ⊢ϕ,
Γ ⊢ψ
Γ ⊢ϕ ∧ψ
(→∧)
Γ, ϕ ⊢φ
Γ, ϕ ∧ψ ⊢φ
(∧→)1,
Γ, ψ ⊢φ
Γ, ϕ ∧ψ ⊢φ
(∧→)2
ϕ ⊢ψ
¬ψ ⊢¬ϕ
(¬)
Γ ⊢ϕ
Γ ⊢¬¬ϕ
(→¬¬),
Γ, ϕ ⊢φ
Γ, ¬¬ϕ ⊢φ
(¬¬ →),
residuation property rules,3
3 They are identical to that given by (6.8), and from the fact that ⊗is a defined (derived) operation,
we simply substituted ϕ ⊗ψ by ¬(ϕ ⇒¬ψ), without changing in any way the Gentzen’s sequent sys-

328
|
6 Applications of many-valued intensional first-order logic
¬(ϕ ⇒¬ψ) ⊢φ
ϕ ⊢ψ ⇒φ
(res 1),
ϕ ⊢ψ ⇒φ
¬(ϕ ⇒¬ψ) ⊢φ
(res 2)
(6.9)
Notice that it is not necessary to put the structural rules of exchange and contraction
explicitly, because the left-hand side of our sequents are finite sets of formulae. Thus,
this Gentzen system satisfies all structural rules. Notice also that from defined connec-
tives, both (∧, ∨, ¬) and (⊗, ⊕, ¬) satisfy De Morgan laws.
Example 36. We obtain the following deductions:
1.
By weakening the axiom (2) in ϕ ⊢ϕ ⇒ϕ, from (res2), we obtain ϕ ⊗ϕ ⊢ϕ, i. e.,
ϕ ⊗ϕ ⪯ϕ (for all valuations v∗(ϕ ⊗ϕ) ≤v∗(ϕ) from Definition 57 in Section 5.1,
or algebraically x ⊗x ≤x for all x ∈X = [0, 1]), that is the result that fusion is
square-decreasing in Lukasiewicz logic.
2.
The rule (¬) means algebraically that if x ≤y then ∼y ≤∼x, while from axiom
(1) and two rules (→¬¬) and (¬¬ →), we obtain ϕ ⊢¬¬ϕ and ¬¬ϕ ⊢ϕ, this the
idempotent negation, algebraically ∼∼x = x for all x ∈X.
3.
By rule (weak) for every ψ, it holds from axiom (2), ψ ⊢ϕ ⇒ϕ, so for all valuations
v∗(ϕ ⇒ϕ) = 1, or algebraically x →x = 1 for each x ∈X.
However, if we take the negation ∼and the monoid (X, ⊕, 0) with intensional dis-
junction (fission) as two basic binary operations from which derived operations are
fusion x ⊗y =def∼(∼x⊕∼y) and implication x →y =def∼x ⊕y, such that the join and
meet lattice operations can be derived by the following two equations:
x ⋁y = (x⊗∼y) ⊕y,
x ⋀y = x ⊗(x →y),
(6.10)
and hence the algebraic structure (X, ⊕, ∼, 0) represents completely the algebraic struc-
ture of infinite-valued Lukasiewicz logic (and its dual algebraic structure (X, ⊗, ∼, 1) as
well). That is, we obtain an MV-algebra.
Definition 87. An MV-algebra is an algebraic structure (X, ⊕, ∼, 0), which satisfies the
following equations for each x, y, z ∈X:
1.
x ⊕(y ⊕z) = (x ⊕y) ⊕z,
2.
x ⊕0 = x,
3.
x ⊕y = y ⊕x,
4.
∼∼x = x,
5.
x⊕∼0 =∼0,
6.
∼(∼x ⊕y) ⊕y =∼(∼y ⊕x) ⊕x.
tem G∞for Lukasiewicz’s logic [243]. In this way, we can change the semantics of fusion ⊗without
elimination of any axiom or inference rule from this given by [243], but only to provide some new
axioms/rules for the introduction of these different fusion operations nonderivable more from the im-
plication and negation operations of Lukasiewicz’s algebra/logic.

6.1 Relevant Lukasiewicz–Tarski logics
|
329
A standard MV-algebra with operations x ⊕y = min{1, x + y} and ∼x = 1 −x, in
mathematical fuzzy logic, forms the standard real-valued semantics of Lukasiewicz
logic.
If we take out the last two equations (5) and (6), then we obtain a generalized De
Morgan algebra.
By virtue of the first three axioms, (X, ⊕, 0) is an Abelian commutative monoid. Be-
ing defined by equations, MV-algebras form a variety of algebras. The variety of MV-
algebras is a subvariety of the variety of BL-algebras, which is characterized by equa-
tion ∼∼x = x, and contains all Boolean algebras. An MV-algebra can equivalently be
defined (Hájek [239]) as a prelinear commutative bounded integral residuated lattice
(X, ⋀, ⋁, ⊗, →, 0, 1) satisfying the additional equation x ⋁y = (x →y) →y (the first
equation in (6.10)).
6.1.2 Weakening of fission and fusion operations of Lukasiewicz algebra
We have explained that the relations between residuated-based BL and Lukasiewicz
infinite valued logic similar to the ones existing between intuitionistic and classi-
cal logics [242]. Thus, the fact that in Lukasiewics’z logic the fusion ⊗is a t-norm
in our weakening of it and it will not be more t-norm, but the subalgebra (X, ⊕, ⊗, ∼)
will still remain a De Morgan algebra. Consequently, for the wider family of relevant
Lukasievicz-based logics in the first position come their classical logic property based
on De Morgan subalgebras. In order to underline this more general point of view, the
relationship with BL algebras is not fundamental, but the classical logic properties
based on the two basic De Morgan subalgebras of the Lukasiewicz’s algebras.
The unique two equations of the De Morgan algebras are that they fix the seman-
tics of negation ∼in the following particular way:
1.
∼∼x = x;
2.
DeMorgan laws between conjunction and disjunction, mediated by such a nega-
tion operation, ∼(x ∧y) =∼x∨∼y, so that the minimal requirement for the
conjunction and negation operations is to be mutually commutative.
In the De Morgan algebras, the law of excluded middle ∼x ∨x = 1 and the law of
noncontradiction ¬x ∧x = 0 do not always hold (in fact for the meet ⋀and join ⋁
connectives in Lukasiewicz’s algebra they do not hold, while for the fusion ⊗and ⊕
intensional connectives they hold).
De Morgan algebras are important for the study of the mathematical aspects of
fuzzy logic. The standard fuzzy algebra is an example of a De Morgan algebra [246, 247]
where the laws of excluded middle and noncontradiction do not hold. De Morgan alge-
bras are not the only plausible way to generalize Boolean algebras. Another way is to
keep ∼x ∧x = 0 (i. e., the law of noncontradiction) but to drop the law of the excluded

330
|
6 Applications of many-valued intensional first-order logic
middle and the law of double negation. This approach (called semicomplementation)
is well-defined even for a (meet) semilattice; if the set of semicomplements has a great-
est element, it is usually called a pseudo-complement. If the pseudo-complement sat-
isfies the law of the excluded middle, the resulting algebra is also Boolean. However, if
only the weaker law ∼x∨∼∼x = 1 is required, this results in Stone algebras. More gen-
erally, both De Morgan and Stone algebras are proper subclasses of Ockham algebras
[248].
De Morgan algebras (called quasi-Boolean algebras as well), which are (not nec-
essarily bounded) distributive lattices with a De Morgan negation, has been intro-
duced by Bialynicki-Birula and Rasiowa [249]. This type of algebras was investigated
by Moisil [250] under the term De Morgan lattices, and by Kalman under the term dis-
tributive i-lattices (cf. [251], pp. 44–48). They have been widely discussed in the liter-
ature on universal algebra [251–253], relevance logic [254], Belnap’s four-valued logic
and the logic of bilattices [255, 256], rough set theory and prerough algebras [257], etc.,
from algebraic and logical perspectives.
The connection between Belnap’s 4-valued logic and the class of De Morgan lat-
tices (or algebras)was also recognized from the very beginning, and has been shown
that the class of De Morgan lattices is the algebraic counterpart of Belnap’s logic [258].
The Belnap’s logic is in fact considered in this book in Section 6.3 for the application
of the Intensional FOL for the important application of a P2P data integration system
in order to manage mutually-inconsistent and incomplete information as well.
Based on this classical logic point of view, founded on the De Morgan algebras, it is
easy to verify that we can define the underlying algebra of infinite-valued Lukasiewicz
logic as follows.
Definition 88 (Infinite-valued Lukasiewicz algebra operations). It is defined on the
lattice of reals X = [0, 1] with ⋀and ⋁meet and join operations in the lattice (X, ≤),
relatively, such that for x, y ∈X, x ⋁y = min{x, y}, x ⋁y = max{x, y}, and:
1.
Implication
x →y =def min{1, 1 −x + y}
(6.11)
2.
De Morgan subalgebra (X, ⋀, ⋁, ∼) with negation
∼x =def 1 −x
(6.12)
so that ∼x = x →0, with two derived operations:
[a]. Intensional disjunction (fission) of the Abelian monoid (X, ⊕, 0), defined clas-
sically
x ⊕y =def∼x →y
(6.13)

6.1 Relevant Lukasiewicz–Tarski logics
|
331
[b]. Intensional conjunction (fusion) ⊕, which defines its second De Morgan sub-
algebra (X, ⊗, ⊕, ∼), i. e.,
x ⊗y =∼(∼x⊕∼y) =∼(x →¬y)
(6.14)
We will denote by A = (X, ≤, ⋀, ⋁, →, 0, 1) the “minimal” Lukasiewicz algebra, by
considering ∼, ⊕and ⊗derived algebraic operators. Analogously, we denote by 𝒜L =
(ℒ, ∧, ∨, ⇒, ⊤, ⊥) where ⊤is “tautology” and ⊥the ‘contradiction,” such that for any
given valuation v : Var →X, v(⊤) = 1 and v(⊥) = 0. Such a valuation can be uniquely
extended to all formulae in ℒto homomorphism from the syntax algebra 𝒜L into A:
v∗: (ℒ, ∧, ∨, ⇒, ⊤, ⊥) →(X, ≤, ⋀, ⋁, →, 0, 1)
(6.15)
An advantage of such presentation of Lukasiewicz’salgebra isthat its basic lattice-
based operations are defined as De Morgan subalgebra in points 1 and 2, while the
other two “nonstandard” operations fission and fusion, derived from the two basic
operations, define a second De Morgan subalgebra, such that we obtain well-known
operations: from [a] the fission ⊕, and from [b] the fusion ⊗:
x ⊕y = min{1, x + y}
x ⊗y = max{0, x + y −1}
Consequently, from a particular definition of fission and fusion operations, given by
[a] and [b], we obtain the famous residuation property
x →y = ⋁{z | x ⊗z ≤y},
and hence it is satisfied for the law of residuation in point 3 of Definition 85, so that ⊗
is really a t-norm (satisfies Definition 83), and hence its subalgebra (X, ⋀, ⋁, ⊗, →, 1) is
a FLew algebra.
As anticipated, we would like to generate a relevant Lukasiewicz logic, by the
weakening of the intensional disjunction and conjunctions ⊕and ⊗in the way that
they preserve their De Morgan properties, but are not more definable from the basic
two connectives, negation and implication. In this way, such relevant Lukasiewicz al-
gebras will be separated from the Hájek’s residuated lattices, and will generate a new
class of algebras.
This can be done by elimination of the Abelian monoidal properties of fission and
fusion operations, and hence also the law of residuation between fusion and implica-
tion is specified in Definition 85. By this proposed weakening, only the commutative
property for the fission and fusion operations will be preserved and the new relevant
Lukasiewicz’s logic will not be more a t-norm logic. Consequently, we can define a
class of bi-Morgan algebras BDM = (X, ⋁, ⋀, ∼, →, ⊕, ⊗, 0, 1) that cover a number of

332
|
6 Applications of many-valued intensional first-order logic
preexistent algebras from classical propositional to Lukasievicz–Tarski and new rele-
vant Lukasiewicz algebras.
Definition 89 (Bi-Morgan algebras). We define a class of bi-Morgan algebras BDM =
(X, ⋁, ⋀, ∼, →, ⊕, ⊗, 0, 1) over a bounded lattice (X, ⋁, ⋀, 0, 1) with bottom and top ele-
ments 0 and 1, relatively, such that for each x, y ∈X:
1.
Implication operation →, antitonic forthe firstand monotonicfor thesecondargu-
ment, satisfies the classical propositional implication in the sublattice 2 = {0, 1} ⊆
X, conservatively extended to all x, y ∈X by, if x ≤y then x →y = 1.
2.
(X, ⋁, ⋀, ∼) is the (extensional) De Morgan algebra with the negation operation ∼;
i. e., satisfying x ⋀y =∼(∼x ⋁∼y) and ∼∼x = x.
3.
Let ⊕be the fission (intensional disjunction), then (X, ⊕, ⊗, ∼) is an intensional De
Morgan algebra such that the fusion (intensional conjunction) is defined by x ⊗
y =def∼(∼x⊕∼y). We have two alternative cases.
3.1 Lukasiewicz’s relevance logic: with the square-increasing property for fission
for each x ∈X, x ⊕x ≥x, and the square-decreasing property for fusion,
x ⊗x ≤x, i. e., by equations
x →(x ⊕x) = 1
and
(x ⊗x) →x = 1
(6.16)
3.2 Orlov’s relevance logic (see (6.2) and (6.4)): with the square-decreasing prop-
erty for fission for each x ∈X, x ⊕x ≤x, and the square-increasing property
for fusion, x ⊗x ≥x, i. e., by equations
(x ⊕x) →x = 1
and
x →(x ⊗x) = 1
(6.17)
Thus, BDM-algebras are fundamentally composed by an extensional and an in-
tensional De Morgan subalgebras. The relationship between intensional De Morgan
subalgebra with the remaining part of the algebra is provided by the common negation
operation of these two De Morgan subalgebras and by the relationship of implication
and intensional connectives given by two equations (6.16) and (6.17).
Example 37. Let us consider the following examples of BDM-algebras:
1.
Standard propositional logic: for X = 2, from point 1, the implication is that of
standard propositional logic, and negation defined by ∼x =def x →0. In this
case, the intensional operations coincide with extensional (lattice) operations,
and two De Morgan subalgebras are identical with x ⊕x = x ⊗x = x for (6.16) and
(6.17).
2.
Lukasiewicz–Tarski infinitary logic: X = [0, 1] and the rest is provided in Defini-
tion 88. Note that in this case the intensional connectives, fission and fusion, are
derivable operations from implication and negation operations. It is easy to verify
that (6.16) is satisfied as well.

6.1 Relevant Lukasiewicz–Tarski logics
|
333
3.
Relevant Lukasiewicz logics: In this case, the implication and negation operations
are that provided by points 1 and 2 of Definition 88. However, in this case the
intensional connectives, fission and fusion, are not more derivable from lattice
connectives, implication and negation. Thus, they can be weakened by reducing
some of their properties that they have in original Lukasiewicz logic, and this will
be considered in what follows.
In effect, we can see that the original fission operation ⊕, such that x ⊕y = min{1,
x + y}, of the original Lukasiewicz’s algebra in Definition 88 is given as a composition
of the arithmetic operation + : X2 →[0, 2], which generates Abelian monoid (X2, +, 0)
commutative and associative as well, and a unary monotone and linear function f :
[0, 2] →X, by ⊕= f ∘+, with
f = 1 ⋀_ : [0, 2] →X
(6.18)
where ⋀is the meet operation of the lattice of reals ([0, 2], ≤). Note that this char-
acteristic function f(z), such that f (0) = 0, f (2) = 1 and f (z) ≥
z
2, used in original
Lukasiewicz’s algebra is a continuous linear function with f (z) = z if z ≤1; 1 other-
wise. So, its first derivative is antitonic but not continuous, in the value z = 1.
Let us now define a class of functions that can be used for the relevant Lukasiewicz
algebras, that preserve the properties of f(z) above, but their first derivative is contin-
uous as well
Definition 90. We define the following class Fdm of monotone and continuous non-
linear functions fL, fO : [0, 2] →X, which first derivatives are continuous as well, such
that satisfy the following requirements:
(a) Min and max values are fL(0) = fO(0) = 0, fL(2) = fO(2) = 1;
(b) Lukasiewicz’s function fL(z) ≥z
2 for all z ∈(0, 2) and its derivative is antitonic.
By fS, we denote the subset of strong Lukasiewicz’s functions that satisfy also:
fS(1) = 1, and for its derivative f ′
S(z) = dfS
dz , f ′
S(0) ≥1 and f ′
S(1) = 0 as well.
(c) Orlov’s function fO(z) ≤z
2 for all z ∈(0, 2) and its derivative is monotonic.
Now we can define the first class of relevant De Morgan algebras with square-
decreasing intensional conjunction (Case 3.1 in Definition 89) for the relevant Luka-
siewicz’s logics (we will denote these new weakened fusion and fission operations by
̃∧and ̃∨instead of nonweakened ⊗and ⊕, relatively).
Corollary 23 (Fusion and fission for relevant Lukasiewicz’s logic). If
we
define
the
weakening of the t-norm ⊗of the Lukasiewicz–Tarski logic such that for any x, y ∈X, and
a nonlinear continuous function fL ∈Fdm specified by points (a) and (b) in Definition 90,
x ̃∧y =def 1 −fL(2 −x −y),
(6.19)

334
|
6 Applications of many-valued intensional first-order logic
and hence with the intensional disjunction ̃∨, derived by De Morgan’s law, x ̃∨y =def∼(∼
x ̃∧∼y),
x ̃∨y = fL ∘+(x, y) = fL(x + y)
(6.20)
They satisfy the bi-Morgan algebras in Definition 89 with point 3.1, such that for these
weakened fusion and fission operations:
1.
Will not be satisfied the associativity property;
2.
Top value 1 will not be the unit for the fusion operation, i. e., x ̃∧1
̸= x and 0 will not
be the unit for the fission operation, i. e., x ̃∨0
̸= x.
Consequently, the weakened fusion operation is not a t-norm, and the following prop-
erties are satisfied: x ̃∧y ≤x ⋁y, x ̃∧y ≤x ̃∨y, i. e., the following equations in the bi-
Morgan BDM-algebra are satisfied:
(x ̃∧y) →(x ⋁y) = 1
and
(x ̃∧y) →(x ̃∨y) = 1
(6.21)
However, x ̃∧y ≤x ⋀y and x ̃∨y ≥x ⋁y are not generally valid (they are valid only for
x = y as specified in (6.16)).
If in (6.19) and (6.20) we substitute fL with a strong Lukasiewicz’s function fS, then
we obtain the strong fusion and fission operations (as that used in original Lukasiewicz’s
algebra), such that for each x, y ∈X,
x ̃∧y ≤x ⋀y ≤x ⋁y ≤x ̃∨y
so that, instead of equations (6.21), we obtain stronger equations:
(x ̃∧y) →(x ⋀y) = 1
and
(x ⋁y) →(x ̃∨y) = 1
(6.22)
Proof. It is easy to verify that the first two t-norm properties in Definition 83 of derived
intensional conjunction ̃∧are preserved, from the fact that fL(2−x −y) is commutative
(−x −y = −y −x) and is monotone as well. We have that, from the fact that fL is a non-
linear function, (x ̃∧y) ̃∧z = 1−fL(1+f(2−x−y)−z)
̸= 1−fL(1−x−fL(2−y−z)) = x ̃∧(y ̃∧z),
and hence the point 1 is satisfied.
Point 2: it will be shown by contradiction. We have that there exists x ∈X such
that x ̃∧1 = 1 −fL(1 −x)
̸= x. Suppose that 1 −fL(1 −x) = x, i. e., for z = 1 −x, fL(z) = z for
all 0 ≤z ≤1. But in that case for z = 1 we would have fL(1) = 1, and hence for all other
1 < z ≥2 from the monotonic property we must have that for this interval fL(z) = 1
(maximum value of this function). Let 0 < z0 ≤1 (from (a), fL(0) = 0) be the first
point in which this monotone and continuous function reaches the maximal value 1,
and hence in this point will not be satisfied the continuity of the first derivative of this
function in contradiction with the requirements.

6.1 Relevant Lukasiewicz–Tarski logics
|
335
Square-decreasing property (6.16): let us suppose that there exists x ∈X such that
x ⊗x = 1 −fL(2 −2x) > x. But, if we substitute 2 −2x by z, then we obtain fL(z) < z
2,
which is in contrast with requirement (b) for the Lukasiewicz’s functions.
Consequently, the semantics of intensional conjunction (fusion) is well-defined.
So, also the definition of the intensional disjunction (fission) ̃∨by the De Morgan law
is correct and we obtain from (6.19), for any x, y ∈X, x ̃∨y = fL(x + y), which is square-
increasing, i. e., x ̃∨x = fL(2x) ≥x. In fact, by substitution z = 2x, we obtain fL(z) ≥z
2,
as it was specified by requirement (b) in Definition 90.
Let us show (6.21): in fact, x ̃∧y = 1 −fL(2 −x −y) ≤1 −2−x−y
2
= x+y
2
≤max{x, y} =
x ⋁y. To show that x ̃∧y ≤x ̃∨y, we have to show that 1−fL(2−x−y) ≤fL(x+y), i. e., that
fL(x +y)+fL(2−x −y) ≥1, which is true because fL(x +y) ≥x+y
2 and fL(2−x −y) ≥2−x−y
2
.
So, we have from (b) in Definition 90 that
x ̃∧y ≤x + y
2
≤x ̃∨y
(6.23)
and hence, for x = y, we obtain square-increasing and square decreasing properties of
the fission and fusion, respectively, with 0 = 0 ̃∧0 ≤0 ̃∨0 = 0 and 1 = 1 ̃∧1 ≤1 ̃∨1 = 1,
all result obtained from original Lukasiewicz’s logic.
Let us show that if we use the strong Lukasiewicz’s functions fS(z) : [0, 2] →X
instead of fL, then stronger equations (6.22) are valid. Let us show for the second, an
suppose that x ≥y. Then, from the fact that fS is monotonic with first derivative at
z = 0 greater than one and decreasing we have that in the interval [0, 1], fS(z) ≥z, so
that x ̃∨y = fS(x + y) ≥x + y ≥x = x ⋁y. Note that in the rest of interval z ∈[1, 2],
fS(z) = 1, and that in z = 1 also the first derivative of fS(z) is continuous as required
generally for all functions in Fdm by Definition 90. That is, the fission operation is a
strong disjunction. Analogously, it can be shown that in this case the fusion operation
is a strong conjunction.
Consequently, the De Morgan algebra with intensional conjunction and disjunc-
tion, obtained from Lukasiewicz’s functions fL or stronger fS, DM = (X, ≤, ̃∧, ̃∨, ∼) is
well-defined, such that for any x ∈X,
∼x = 1 −x,
x ̃∧x ≤x,
x ̃∨x ≥x
(6.24)
Notice that our weakening preserves square-decreasingness for Lukasiewicz’s t-norm
conjunction ⊗, but does not preserve its associative property and its monoidal prop-
erty (x ⊗1 = x), and hence it is not satisfied the monoidal property of intensional
conjunction in point 1 of Definition 88 for the infinite-valued Lukasiewicz logic (while
all other points from 2 to 4 are satisfied).
Consequently, the logic obtained by replacing Lukasievicz’s t-norm conjunction
and disjunction with these new intensional connectives ̃∧and ̃∨deduces less sen-
tences than the original Lukasiewicz’s infinite-valued logic.

336
|
6 Applications of many-valued intensional first-order logic
Example 38. In this example, we will consider the Lukasiewicz’s functions fL and LS,
used to define the new fusion as a fission operation. First, we will consider the strong
functions fS from which we obtain the strong conjunction ̃∧and disjunction opera-
tions ̃∨of intensional De Morgan algebras (X, ̃∨, ̃∧, ∼), and after that, their weakened
versions that use the functions fL:
1.
Strong fusion and fission: Let us consider the family of functions, for each α = m
n ,
where m ≤n are positive integers:
fS(z) =def { (2z −z2)α,
if z ∈X
1,
if z ∈[1, 2]
(6.25)
with first derivative f ′
S(z) = 2α(1 −z)/(2z −z2)1−α so that f ′
S(0) ≥1 and f ′
S(1) = 0, as
required. It is easy to show that fS(z) ≥z for z ∈[0, 1], and that with decreasing of
α we obtain stronger intensional conjunction and disjunction. From the fact that
in the interval z ∈X, 1 ≥zα−1, we obtain 2 ≥z + zα−1, i. e., (2z −z2)α ≥z, and hence
it holds that for each x, y ∈X, and z = x + y ≤1, x ̃∨y = fS(z) ≥z = x + y ≥x ⋁y.
Otherwise, if x + y > 1, then fS(x + y) = 1 ≥x ⋁y. Thus, ̃∨is a strong intensional
disjunction and square-increasing (analogously we obtain that x ̃∧y ≤x ⋀y, and
hence ̃∧is a strong intensional conjunction and square-decreasing).
2.
Nonstrong fusion and fission: in this case, we are using the functions fL, and we
can consider two extremal cases:
2.1 The family of functions for quasistrong fusion/fission:
fL(z) =
n√sin(π
4 z),
n = 1, 2, 3, . . .
(6.26)
with the strongest cases when n ≫1 (extremely nonlinear functions). These
functions are monotone in the interval [0.2] and their first derivative is anti-
tonic and continuous as well, with fL(0) = 0, fL(2) = 1 and fL(z) ≥z
2 for all
z ∈(0, 2), so that they satisfy all requirements in Definition 90. Hence, for any
small positive value δ ≪1, there exist enough big value n ≫1, such that for
a function (6.26), we obtain that practically fL(z) ≈0 if z ≤δ; 1 otherwise.
So, we obtain x ̃∨y =∼(x ̃∧y) ≥x ⋁y if δ < x + y < 2 −delta; x ̃∧y other-
wise. That is, almost always we obtain the strong fusion and fission opera-
tions (6.22), when x ̃∧y ≤x ⋀y ≤x ⋁y ≤x ̃∨y (only for infinitesimal intervals
0 ≤x +y ≤δ and 2−δ ≤x +y ≤2 this strong intensional connectives property
does not hold).
2.2 The family of quasilinear functions for weakest fusion/fission for infinitely-
small positive values δ:
fL(z) = z
2 + 𝒪(z),
𝒪(z) < δ
(6.27)

6.1 Relevant Lukasiewicz–Tarski logics
|
337
with infinitesimal monotonic functions 𝒪(z) such that 𝒪(0) = 𝒪(2) = 0. Thus,
these are the smallest Lukasiewicz’s function satisfying all requirements in
Definition 90. In this case, we obtain that x ̃∧y ≈
x+y
2
≈x ̃∨y, and almost
always the fusion and fission connectives are very weak, i. e., x ⋀y ≤x ̃∧y
but ̃∧is still square-decreasing (x ⋀x ≥x ̃∧x = x) and x ̃∨y ≤x ⋁y, but still
square-increasing (x ̃∨x ≥x ⋁x = x).
Consequently, we obtained a different relevant logic from the Orlov’s logic where
the conjunction is square-increasing, and for which we cannot use the Kripke-style
semantics and Dunn’s Gaggle theory (as explained at the end of Section 6.1). The rel-
evant Orlov’s logic is obtained by defining fission by x ̃∨y =def fO ∘+(x, y) = fo(x + y)
and fusion derived by the De Morgan law.
The Gentzen’s sequent system G
S
∞for the relevant Lukasiezic’s logic, obtained
by the weakening of fusion and fission intensional connectives by using strong
Lukasiewicz’s functions fS(z) : [0, 2] →X, which satisfied the equations (6.22), must
be obtained by an extension of the original Gentzen’s system G∞provided previously
(where we eliminated the t-norm fusion ⊗in (6.9) because it is derived operation from
implication and negation operations of the original Lukasiewicz’s algebra). We need
new axioms and rules for these new fusion/fission logical connectives, which are now
completely independent of the rest of logical connectives (∨, ∧and implication ⇒),
and only have the relationship with negation ¬ in their inter-De Morgan law relation-
ship. Thus, in order to consider these new axioms and rules of inference, it is useful to
analyze the Gentzen’s system for the sequent calculus for FLem, especially for the rules
(6.7) and (6.8) for the fusion t-norm ⊗, and Example 35 where we have shown how the
commutative and associative properties of the fusion ⊗are direct consequences of the
rules for introduction and elimination of fusion in (6.7). If we eliminate one of these
two rules, then it would not be possible to obtain the commutativity and associativity
of ⊗.
In effect, this is just the case, because the rule for the introduction of ⊗is not more
valid for its substitution by weaker connective ̃∧. From the truth-preserving semantics
of satisfaction of a sequent, in Definition 54 in Section 5.1, there exists a valuation v,
which satisfies the upper sequents of the rule (6.7), v∗(Γ) ≤v∗(ϕ) and v∗(Γ1) ≤v∗(ψ),
but not v∗(Γ, Γ1) = v∗(Γ) ⋀v∗(Γ1) ≤v∗(ϕ ̃∧ψ), because it holds that v∗(ϕ ̃∧ψ) ≤v∗(ϕ ∧
ψ) = v∗(ϕ) ⋀v∗(ψ). Analogously, the rule for elimination of intensional disjunction
(fission) does not hold more. Hence, from the fact that we must exclude the rule for
introduction of intensional conjunction ̃∧and the rule for elimination of intensional
disjunction ̃∨, and hence without the possibility to derive from the inference rules the
commutativity of these two logical connectives, we need to specify their commutativ-
ity by two new axioms. In an analog way, from the fact that we cannot obtain the De
Morgan relationship between these two logical connectives by the rules of inference,
also for the De Morgan relationship we must introduce two new rules, as follows.

338
|
6 Applications of many-valued intensional first-order logic
Corollary 24. The Gentzen’s sequent system G
S
∞for the relevant Lukasiezic’s logic, ob-
tained by the weakening of fusion and fission intensional connectives by using strong
Lukasiewicz’s functions fS(z) : [0, 2] →X, which satisfies the equations (6.22), is ob-
tained by the extension of the original Gentzen’s system G∞provided previously (where
we eliminated the t-norm fusion ⊗in (6.9), by the following new axioms:
(4) ϕ ̃∧ψ ⊢ψ ̃∧ϕ commutativity
(5) ¬(¬ϕ ̃∧¬ψ) ⊢ϕ ̃∨ψ De Morgan 1
(6) ϕ ̃∨ψ ⊢¬(¬ϕ ̃∧¬ψ) De Morgan 2
and the following new rules for relevant fusion and fission connectives:
Γ ⊢ϕ
Γ ⊢ϕ ̃∨ψ
(→̃∨)1,
Γ ⊢ψ
Γ ⊢ϕ ̃∨ψ
(→̃∨)2
(6.28)
Γ, ϕ ⊢φ
Γ, ϕ ̃∧ψ ⊢φ
(̃∧→)1,
Γ, ψ ⊢φ
Γ, ϕ ̃∧ψ ⊢φ
(̃∧→)2
(6.29)
Proof. We obtain the following results:
1.
From the axiom (4) of the commutativity of fusion connective ̂∧, the rules for nega-
tion in G∞, and two De Morgan axioms, we obtain the commutativity of fission as
well:
(a) ϕ ̃∨ψ ⊢ψ ̃∨ϕ
2.
From the rule (̃∧→)1, in the case when Γ is empty and φ equal to ϕ, so that in the
upper level we obtain the axiom ϕ ⊢ϕ, as consequence we obtain:
(b) ϕ ̃∧ψ ⊢ϕ,
and hence when ψ is equal to ϕ we derived that square-decreasing property of the
fusion, ϕ ̃∧ϕ ⊢ϕ.
3.
from the rule (→̃∨)1, in the case when Γ = {ϕ}, again the upper sequent is an
axiom, and as a consequence we obtain:
(c) ϕ ⊢ϕ ̃∨ψ,
and hence when ψ is equal to ϕ we derived that square-increasing property of the
fission, ϕ ⊢ϕ ̃∨ϕ.
4.
From (b) and from the axiom (4) of the commutativity, we obtain also ϕ ̃∧ψ ⊢ψ,
and by using the rule (→∧) of G∞for Γ = {ϕ ̃∧ψ}, as a consequence we obtain:
(d) ϕ ̃∧ψ ⊢ϕ ∧ψ
5.
From (c), and analogously derived ψ ⊢ϕ ̃∨ψ, and by using the (∨→) of G∞for Γ
empty and φ equal to ϕ ̃∨ψ, as a consequence we obtain:
(e) ϕ ∨ψ ⊢ϕ ̃∨ψ
Consequently, from (d) and (e), and from the sequant ⊢ϕ∧ψ ⊢ϕ ̃∨ψ derived from
G∞, we obtain the chain of sequents:
ϕ ̃∧ψ ⊢ϕ ∧ψ ⊢ϕ ∨ψ ⊢ϕ ̃∨ψ

6.1 Relevant Lukasiewicz–Tarski logics
|
339
i. e., from the truth-preserving semantics of satisfaction of sequent in Definition 54
in Section 5.1,
ϕ ̃∧ψ ⪯ϕ ∧ψ ⪯ϕ ∨ψ ⪯ϕ ̃∨ψ,
i. e., strong fusion and fission property corresponding to algebraic equations in
(6.22).
Remark. Note that if instead of strong Lukasiewic’z functions fS(z) we use weaker ver-
sions fL(z), and define fusion and fission operations by (6.19) and (6.20), we have to
eliminate the inference rules in (6.28) and (6.29) and insert another two axioms, cor-
responding to algebraic equations in (6.21), respectively,
(7) ϕ ̃∧ψ ⊢ϕ ⋁ψ
(8) ϕ ̃∧ψ ⊢ϕ ̃∨ψ
so that from axiom (5) in the case when ψ is equal to ϕ and from a derived sequent
ϕ ⋁ϕ ⊢ϕ in G∞, by rule (cut) in G∞, we obtain the square decreasing property of
fusion
ϕ ̃∧ϕ ⊢ϕ
which in the case when ϕ is equal to ¬ψ (where ψ is equivalent to ¬ϕ), we obtain by
substitution the sequent ¬ψ ̃∧¬ψ ⊢¬ψ, and from the rule (¬) in G∞, we obtain the
sequent ¬¬ψ ⊢¬(¬ψ ̃∧¬ψ) and from the axiom (5), by using the cut rule in G∞, we
obtain the sequent ¬¬ψ ⊢ψ ̃∨ψ. Hence, from this sequent and from the derivable
sequent ψ ⊢¬¬ψ in G∞, by applying the cut rule, we obtain the square-increasing
property for the fission:
ψ ⊢ψ ̃∨ψ.
Now we can define the relevant Lukasiewicz’s algebra and its canonical represen-
tation algebra.
Definition 91 (Relevant Lukasiewicz algebra). From Corollary 23 for the weakened fu-
sion ̃∧in (6.19) and weakened fission ̃∨in (6.20), which now are not more derivable
from the another Lukasiewicz’s algebra operations, and from the fact that the nega-
tion ∼is derived from the implication (which is not relative pseudo-complement) by
∼x =def (x →0), we obtain the following relevant Lukasiewicz’s algebra:
A = (X, ≤, ∧, ∨, →, ̃∧, ̃∨),
(6.30)
and hence by Proposition 29 in Section 5.1.2, from the fact for the total ordering in X,
̂X = X = [0, 1] we obtain a canonical representation isomorphism (5.10),
↓+: ((X, ≤, ∧, ∨, 0, 1), →, ̃∧, ̃∨) ≃((X+, ⊆, ∩, ∪, {0}, X), →+, ̃∧+, ̃∨+)
(6.31)

340
|
6 Applications of many-valued intensional first-order logic
with set-based canonical relevant Lukasiewicz’s algebra A+ = ((X+, ⊆, ∩, ∪, {0}, X), →+,
̃∧+, ̃∨+), with, from general definitions in (5.11), new set-based operations:
1.
→+= ↓+ →(⋁× ⋁) = ↓+ min{1, 1 −⋁_ + ⋁_} : X+ × X+ →X+,
2.
̃∧+ = ↓+ ̃∧(⋁× ⋁) = ↓+(1 −fL(2 −⋁_ −⋁_)) : X+ × X+ →X+,
3.
̃∨+ = ↓+ ̃∨(⋁× ⋁) = ↓+fL(⋁_ + ⋁_) : X+ × X+ →X+,
where, for each x ∈X, ↓+ x = [0, x] ∈X+.
Consequently, based on the canonical representation Theorem 17 in Section 5.1.2,
the relational Kripke semantics of this relevant Lukasiewicz’s logic is a following par-
ticular case of Definition 65 in Section 5.1.2.
Definition 92. The Kripke semantics of relevant Lukasiewicz’s logic given by its alge-
bra A provided by Definition 91 is given by a Kripke model MK = (K, IK) with the frame
K = ⟨(X, ≤), R→, R∧, R∨⟩, where these three ternary accessibility relations are provided
in Definition 63 in Section 5.1.2, for implication →in (6.11), weakened fusion ̃∧in (6.19)
and weakened fission ̃∨in (6.20) relatively. Mapping IK : Var ×1K →2 is a canonical
valuation, such that for any atomic formula (propositional variable) p ∈Var, formulae
ψ, ϕ ∈F(ℒ), and possible world x ∈X:
1.
MK 󳀀󳨐x p iff IK(p, x) = 1
2.
MK 󳀀󳨐x ϕ ∧ψ iff MK 󳀀󳨐x ϕ and MK 󳀀󳨐x ψ,
3.
MK 󳀀󳨐x ϕ ∨ψ iff MK 󳀀󳨐x ϕ or MK 󳀀󳨐x ψ,
4.
MK 󳀀󳨐x ϕ ̃∧ψ iff ∃y, z ∈X((x, y, z) ∈R∧and MK 󳀀󳨐y ϕ and MK 󳀀󳨐z ψ),
5.
MK 󳀀󳨐x ϕ ̃∨ψ iff ∃y, z ∈X((x, y, z) ∈R∨and MK 󳀀󳨐y ϕ and MK 󳀀󳨐z ψ),
6.
MK 󳀀󳨐x ϕ ⇒ψ iff ∃y, z ∈X((x, y, z) ∈R→and MK 󳀀󳨐y ϕ and MK 󳀀󳨐z ψ and ∀w ∈
X(MK 󳀀󳨐w ϕ implies w ≤y)).
Notice that in this definition of Kripke semantics we considered the fact that the
fusion ̃∧and fission ̃∨are monotonic in both arguments, while implication ⇒(which
is not intuitionistic, and hence representable algebraically by a relative pseudo-
complement) is monotonic for second and antimonotonic for the first argument.
Now, based on this Kripke models MK = (K, IK), we are able for such a model to
define the mapping v : Var →X, such that for each atomic formula p ∈Var, v(p) = w iff
IK(p, w) = 1, and to extend this mapping to the unique homomorphism v∗: F(ℒ) →X
for the formulae ϕ ∈F(ℒ) of this relevant Lukasiewicz’s logic. So, from Theorem 17 in
Section 5.1.2, it holds that
‖ϕ‖ = ↓+v∗(ϕ) = [0, v∗(ϕ)] ∈X+
(6.32)
where v∗(ϕ) ∈X is the truth value of the formula ϕ in this Kripke model MK = (K, IK).
Thus, by this division of the fusion and fission logical connectives from the lattice
conjunction, disjunction and implication connectives, we can also consider indepen-
dently the weakening of the implication to obtain a more relevant implication. For

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
341
example, instead of original Lukasiewicz’s implication (6.11), defined algebraically by
x →y =def min{1, 1 −x + y}, we can use an intuitionistic implication (with residuation
property w. r. t. lattice meet operation ⋀) such that
x →y =def ⋁{z | x ⋀z ≤y}
(6.33)
and to obtain still more relevant Lukasiewicz’s logics.
6.2 Relevant mZ-logic: paraconsistent intuitionistic logic with
Da Costa weakening of intuitionistic negation
In what follows, we will try to summarize, by a short introduction, the previous his-
toric approach to two important concepts in the logics: paraconsistency and construc-
tivism.
A paraconsistent logic is a logical system that attempts to deal with contradictions
in a discriminating way. Alternatively, paraconsistent logic is the subfield of logic that
is concerned with studying and developing paraconsistent (or inconsistency-tolerant)
systems of logic. Paraconsistent logics are propositionally weaker than classical logic;
that is, they deem fewer propositional inferences valid. The point is that a paraconsis-
tent logic can never be a propositional extension of classical logic, i. e., propositionally
validate everything that classical logic does. In that sense, then paraconsistent logic
is more conservative or cautious than classical logic.
The recent history of the development of substructural relevant logics has an im-
portant example of reduction of Classical Propositional Calculus (CPC) in a number
of its substructural logics, called intermediate propositional logics as well, as we pre-
sented in Section 6.1. In this framework of progressively weakening of CPC, we ob-
tained a lattice of the intermediate logics, where the top element of this lattice was CPC
and the bottom element the Intuitionistic Propositional Calculus (IPC). This “weak-
ening” from CPC into IPC can be seen as weakening of the interdependence of the
basic for logic connectives: negation ¬ (unary operation) and binary operations, con-
junction ∧, disjunction ∨and implication ⇒. In order to distinguish these connectives
(¬ and ⇒only) in this hierarchy of different propositional logics, we will label them
by a kind of logics: by a label C for the CPC and label I for the IPC, while the logic
connectives of mZ will remain unlabeled.
The fundamental distinguishing characteristic of intuitionism is its interpretation
of what it means for a mathematical statement to be true. In Brouwer’s original intu-
itionism, the truth of a mathematical statement is a subjective claim: a mathematical
statement corresponds to a mental construction, and a mathematician can assert the
truth of a statement only by verifying the validity of that construction by intuition. To
an intuitionist, the claim that an object with certain properties exists is a claim that

342
|
6 Applications of many-valued intensional first-order logic
an object with those properties can be constructed. Any mathematical object is con-
sidered to be a product of a construction of a mind and, therefore, the existence of an
object is equivalent to the possibility of its construction. This contrasts with the classi-
cal approach, which states that the existence of an entity can be proved by refuting its
nonexistence. For the intuitionist, this is not valid; the refutation of the nonexistence
does not mean that it is possible to find a construction for the putative object, as is
required in order to assert its existence.
The interpretation of negation is different in intuitionist logic than in classical
logic. In classical logic, the negation of a statement asserts that the statement is false;
to an intuitionist, it means the statement is refutable (e. g., that there is a counterex-
ample). There is thus an asymmetry between a positive and negative statement in intu-
itionism. If a statement ϕ is provable, then it is certainly impossible to prove that there
is no proof of ϕ. But even if it can be shown that no disproof of ϕ is possible, we cannot
conclude from this absence that there is a proof of ϕ. Thus, ϕ is a stronger statement
than ¬¬ϕ. As such, intuitionism is a variety of mathematical constructivism; but it is
not the only kind. Regardless of how it is interpreted, intuitionism does not equate
the truth of a mathematical statement with its provability. However, because the in-
tuitionistic notion of truth is more restrictive than that of classical mathematics, the
intuitionist must reject some assumptions of classical logic to ensure that everything
he/she proves is in fact intuitionistically true. This gives rise to intuitionistic logic.
Intuitionistic logic allows ϕ ∨¬ϕ not to be equivalent to true, while paraconsis-
tent logic allows ϕ ∧¬ϕ not to be equivalent to false. Thus, it seems natural to re-
gard paraconsistent logic as the dual of intuitionistic logic. However, intuitionistic
logic is a specific logical system whereas paraconsistent logic encompasses a large
class of systems. Accordingly, to this historic approach, the dual notion to paraconsis-
tency is called paracompleteness, and the “dual” of intuitionistic logic (a specific para-
complete logic) is a specific paraconsistent system called antiintuitionistic or dual-
intuitionistic logic (sometimes referred to as Brazilian logic, for historical reasons)
[211, 259–261]. The duality between the two systems is best seen within a sequent cal-
culus framework.
The intuitionistic implication operator cannot be treated like “(¬Cϕ ∨ψ),” but as
a modal formula ◻(¬Cϕ ∨ψ) where ¬C is the classic negation and ◻universal modal
S4 operator with reflexive and transitive accessibility relation R in Kripke semantics.
Dual-intuitionistic logic [262] contains a connective 󴀞󴀷known as pseudo-difference,
which is the dual of intuitionistic implication. Very loosely, ϕ 󴀞󴀷ψ can be read as “ϕ
but not ψ” and is equivalent to a modal formula ♦(ϕ∧¬Cψ), where ♦is the existential
modal operator with inverse accessibility relation R−1 in a Kripke-like semantics [263].
Dual of intuitionistic logic has been investigated to varying degrees of success
using algebraic, relational, axiomatic and sequent-based perspectives. The concept
of anti-intuitionism, proposed through the concept of a dual intuitionistic logic, was
already mentioned in the 1940s by K. Popper (without any formalism), but he disap-

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
343
proved such a logic as “too weak to be useless.” In fact, K. Popper puts in the Logic of
Scientific Discovery [264]:
“The falsifying mode of inference here referred to—the way in which the falsification of conclusion
entails the falsification of the system from which it is derived—is the modus tollens of classic logic.”
Consequently, dual intuitionistic logic can be labeled as “falsification logic.” In the
falsification, logic truth is essentially nonconstructive as opposed to falsity that is con-
ceived constructively. In intuitionistic logic, instead, falsity is essentially nonconstruc-
tive as opposed to truth that is conceived constructively. Thus, historically, the main
research about the relationships between intuitionistic and paraconsistent logic was
directed toward an exploration of their dual and opposite properties instead of inves-
tigation of their possible common properties. Such common properties are interesting
in order to obtain the logics that may have a reasonable balance of both opposite (dual)
properties: the logics where both ¬(ϕ ∧¬ψ) is not false and ¬(ϕ ∨¬ψ) is not true.
This consideration was the basic motivation at the beginning of my investigation
of intuitionism and paraconsistency, in order to obtain an useful logic for significant
practical applications as well. In fact, after a meeting with Walter Carnielli, M. Coniglio
and J. Y. Béziau at IICAI-2007 (Pune, India), I decided to dedicate much more time to
these problems. My first result was the publication of an autoreferential semantics for
modal logics based on a complete distributive lattice [69]. In this research, I dedicated
the last section exclusively to the paraconsistency of this new semantics w. r. t. the
formal LFI system [261], which I obtained in preprint personally from Walter.
My decisive advances in this direction of research was published in [227] and then
upgraded in [228] by considering the paraconsistent properties of newly introduced
mZn logics. Consequently, in this paper, we will consider in a more detailed way, the
dual quasi-intuitionistic properties of this mZn logic.
There are different approaches to paraconsistent logics. The first one is the non-
constructive approach, based on abstract logic (as LFI [261]), where logic connectives
and their particular semantics are not considered. The second one is the constructive
approach and is divided in two parts: an axiomatic proof theoretic (in Da Costa [265]
and [254, 266, 267]), and a many-valued model theoretic [69] based on truth-functional
valuations (i. e., it satisfies the truth-compositionality principle). The best scenario is
when we obtain both, the proof and the model theoretic definition, which are mutually
sound and complete.
One of the main founders with Stanislav Jaskowski [268], Da Costa, built his
propositional paraconsistent system Cω in [265] by weakening the logic negation op-
erator ¬, in order to avoid the explosive inconsistency [261, 269] of the classic propo-
sitional logic, where the ex falso quodlibet proof rule ϕ,¬ϕ
ψ
is valid. In fact, in order to
avoid this classic logic rule, he changed the semantics for the negation operator, so
that:

344
|
6 Applications of many-valued intensional first-order logic
–
NdC1: in these calculi, the principle of noncontradiction, in the form ¬(ϕ ∧¬ϕ),
should not be a generally valid schema, but if it does hold for formula ϕ, it is a
well-behaved formula and is denoted by ϕ∘;
–
NdC2: from two contradictory formulae, ϕ and ¬ϕ, it would not in general be pos-
sible to deduce an arbitrary formula ψ. That is, it does not hold the ex falso quodli-
bet proof rule ϕ,¬ϕ
ψ ;
–
NdC3: it should be simple to extend these calculi to corresponding predicate cal-
culi (with or without equality);
–
NdC4: they should contain most parts of the schemata and rules of classical
propositional calculus, which do not infer with the first conditions
In fact, Da Costa’s paraconsistent propositional logic is made up of the unique modus
ponens inferential rule
(MP)ϕ, ϕ ⇒ψ ⊢ψ,
and two axiom subsets. But before stating them, we need the following definition as it
is done in Da Costa’s systems (cf. [265, p. 500]), which uses three binary connectives,
∧for conjunction, ∨for disjunction and ⇒for implication.
Definition 93. Let ϕ be a formula and 1 ≤n < ω. Then we define ϕ∘, ϕn, ϕ(n) as follows:
ϕ∘=def ¬(ϕ ∧¬ϕ),
ϕn =def ϕ
n
⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞⏞
∘∘⋅⋅⋅∘,
and
ϕ(n) =def ϕ1 ∧ϕ2 ∧⋅⋅⋅∧ϕn.
The first one is for the positive propositional logic (without negation), composed
by the following eight axioms, borrowed from the classic propositional logic of the
Kleene L4 system, and also from the more general propositional intuitionistic system
IPC (these two systems differ only regarding axioms with the negation operator),
(IPC+) positive logic axioms
(1) ϕ ⇒(ψ ⇒ϕ)
(2) (ϕ ⇒ψ) ⇒((ϕ ⇒(ψ ⇒φ)) ⇒(ϕ ⇒φ))
(3) ϕ ⇒(ψ ⇒(ϕ ∧ψ))
(4) (ϕ ∧ψ) ⇒ϕ
(5) (ϕ ∧ψ) ⇒ψ
(6) ϕ ⇒(ϕ ∨ψ)
(7) ψ ⇒(ϕ ∨ψ)
(8) (ϕ ⇒φ) ⇒((ψ ⇒φ) ⇒((ϕ ∨ψ) ⇒φ))
We change the original axioms for negation operator of the classic propositional logic
(CPL in Section A.1 in the Appendix), by defining the semantics of negation operator
by the following subset of axioms:

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
345
(NLA) logic axioms for negation
(9) ϕ ∨¬ϕ
(10)¬¬ϕ ⇒ϕ
(11) ψ(n) ⇒((ϕ ⇒ψ) ⇒((ϕ ⇒¬ψ) ⇒¬ϕ)) (Reductio relativization axiom)
(12) (ϕ(n) ∧ψ(n)) ⇒((ϕ ∧ψ)(n) ∧(ϕ ∨ψ)(n) ∧(ϕ ⇒ψ)(n))
It is easy to see that the axiom (11) relativizes the classic reduction axiom
(ϕ ⇒ψ) ⇒((ϕ ⇒¬ψ) ⇒¬ϕ)
which is equivalent to the contraposition axiom (ϕ ⇒¬ψ) ⇒(ψ ⇒¬ϕ) and the triv-
ialization axiom ¬(ϕ ⇒ϕ) ⇒ψ, only for propositions ψ such that ψ(n) is valid, and
in this way avoids the validity of the classic ex falso quodlibet proof rule. It provides
a qualified form of reduction, helping to prevent general validity of ψ(n) in the para-
consistent logic Cn. The axiom (12) regulates only the propagation of n-consistency.
It is easy to verify that n-consistency also propagates through negation, i. e., ϕ(n) ⇒
(¬ϕ)(n) is provable in Cn. So that for any fixed n (from 0 to ω) we obtain a particular Da
Costa paraconsistent logic Cn. Each Cn is strictly weaker than any of its predecessors,
i. e., denoting by Th(S) the set of theorems of calculus S, we have
Th(CPL) ⊃Th(C1) ⊃⋅⋅⋅⊃Th(Cn) ⊃⋅⋅⋅⊃Th(Cω).
Thus, we are fundamentally interested in the C1 system, which is a paraconsistent
logic closer to the CPL (Classical propositional logic), i. e., C1 is the paraconsistent
logic of Da Costa’s hierarchy obtained by minimal change of CPL.
It is well known that the classic propositional logic based on the classic 2-valued
complete distributive lattice (2, ≤) with the set 2 = {0, 1} of truth values, has a truth-
compositional model theoretic semantics. For this, Da Costa calculi is not given any
truth-compositional model theoretic semantics instead.
Based on these observations, in [227] are explained some weak properties of the
Da Costa weakening for a negation operator and it was shown that negation is not
antitonic, different from the negations in the classic and intuitionistic propositional
logics (that have the truth-compositional model theoretic semantics).
The negation in the classic and intuitionistic logics are not paraconsistent (see,
e. g., Proposition 30, p. 118, in [69]), so that basic idea in [227] was to make a weakening
of the intuitionistic negation by considering only its general antitonic property. In fact,
the formula (ϕ ⇒ψ) ⇒(¬ψ ⇒¬ϕ) is a thesis in both classic and intuitionistic
logics. Consequently, our idea was to use the Da Costa weakening of the intuitionistic
negation [227, 228], e. g., from [228] where it has been shown than such obtained mZn
logic does not depend on n, because is satisfies Da Costa axioms for all n ≥1. Because
of that, we will denote mZn in [228] simply by mZ-logic in what follows.

346
|
6 Applications of many-valued intensional first-order logic
Definition 94 (Relevant paraconsistent intuitionistic mZ logic). WedefinethemZlogic
by adding the following axioms to eight axioms of the system IPC+:
(9b) (ϕ ⇒ψ) ⇒(¬ψ ⇒¬ϕ)
(10b) 1 ⇒¬0
(11b) ϕ ⇒1, 0 ⇒ϕ
(12b) (¬ϕ ∧¬ψ) ⇒¬(ϕ ∨ψ)
This mZ logic is a relevant intuitionistic logic obtained by weakening negation by the
Da Costa paraconsistent method. Another mCZ logic can be formulated by adding the
axiom
(13b) ¬(ϕ ∧ψ) ⇒(¬ϕ ∨¬ψ)
to these formulae.
The following formulae are derivable in mZ logic (since mZ contains IPC+):
((ϕ ⇒ψ) ∧(ϕ ⇒φ)) ⇒(ϕ ⇒(ψ ∧φ))
(T0)
(ϕ ⇒(ψ ⇒φ)) ⇒(ψ ⇒(ϕ ⇒φ))
(T1)
(ϕ ⇒ψ) ⇒((ψ ⇒φ) ⇒(ϕ ⇒φ))
(T2)
(ϕ ⇒(ψ ⇒φ)) ≡((ϕ ∧ψ) ⇒φ)
(T3)
where we denote by ϕ ≡ψ the formulae (ϕ ⇒ψ) ∧(ψ ⇒ϕ).
Theorem 13. The mZ and mCZ logics are paraconsistent.
Proof. We interpret the negation as a function always giving the truth value 1, whereas
other connectives are interpreted in a standard way done in two valued for classical
propositional calculus.
Lemma 7 ([228]). The following formulae are derivable in mZ logic:
(ϕ ∧¬ϕ) ⇒¬ψ
(NEFQ)
¬¬(ϕ ∧ψ) ⇒(¬¬ϕ ∧¬¬ψ)
(♥)
¬((ϕ ∗ψ)n) ⇒(¬(ϕn) ∨¬(ψn))
(♣)
where ∗∈{⇒, ∧, ∨}.
Proof. Let us derive NEFQ:
1
ϕ ⇒(ψ ⇒ϕ)
[(1)]
2
(ψ ⇒ϕ) ⇒(¬ϕ ⇒¬ψ)
[(9b)]
3
ϕ ⇒(¬ϕ ⇒¬ψ)
[1, 2, (T2)]
4
(ϕ ∧¬ϕ) ⇒¬ψ
[3, (T3), (MP)]
Notice that NEFQ is not desirable for some logicians of paraconsistent systems.

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
347
Let us derive ~ now. We will only prove the following, since the case in which ¬¬ϕ
is replaced by ¬¬ψ can be proved analogously: ¬¬(ϕ ∧ψ) ⇒¬¬ϕ.
This can be proved easily by making use of axioms (3) and (9b).
Let us derive | now. The proof runs as follows:
1
¬((ϕ ∗ψ)n) ≡¬¬((ϕ ∗ψ)n−1 ∧¬(ϕ ∗ψ)n−1)
[Definition of ϕn]
2
¬¬((ϕ ∗ψ)n−1 ∧¬(ϕ ∗ψ)n−1) ⇒(¬¬(ϕ ∗ψ)n−1 ∧¬¬¬(ϕ ∗ψ)n−1)
[(♥)]
3
(¬¬(ϕ ∗ψ)n−1 ∧¬¬¬(ϕ ∗ψ)n−1) ⇒¬(ϕn)
[(NEFQ)]
4
¬(ϕn) ⇒(¬(ϕn) ∨¬(ψn))
[(6)]
5
¬((ϕ ∗ψ)n) ⇒(¬(ϕn) ∨¬(ψn))
[1, 2, 3, 4, (T2), (MP)]
Let us show now that the axioms (11) and (12) are redundant in the mZ logic.
Theorem 14 ([228]). The axioms (11) and (12) are redundant in mZ logic in the sense
that they can be proved by another axioms.
Proof. The redundance of the axiom (11) can be proved as follows:
1
(ϕ ⇒(ψ ∧¬ψ)) ⇒(¬(ψ ∧¬ψ) ⇒¬ϕ)
[(9b)]
2
¬(ψ ∧¬ψ) ⇒((ϕ ⇒(ψ ∧¬ψ)) ⇒¬ϕ)
[1, (T1), (MP)]
3
ψ(n) ⇒ψ1
[Definition of ψ(n)]
4
ψ(n) ⇒¬(ψ ∧¬ψ)
[Definition of ψ1]
5
ψ(n) ⇒((ϕ ⇒(ψ ∧¬ψ)) ⇒¬ϕ)
[2, 4, (T2), (MP)]
Let us prove the redundance of the axiom (12). It would be sufficient to prove the fol-
lowing in order to prove the desired result:
(ϕ(n)∧ψ(n)) ⇒(ϕ∗ψ)n
(♦)
Indeed, if we have (♦) at hand then we can prove (ϕ(n) ∧ψ(n)) ⇒(ϕ ∗ψ)m for any
1 ≤m ≤n and combining all these cases, we obtain (ϕ(n) ∧ψ(n)) ⇒(ϕ ∗ψ)(n) which is
axiom (12). So, we now prove (♦), which runs as follows:
1
(ϕ(n) ∧ψ(n)) ⇒(((ϕ ∗ψ)n−1 ∧¬(ϕ ∗ψ)n−1) ⇒(¬(ϕn−1) ∨¬(ψn−1)))
[(♣)]
2
(ϕ(n) ∧ψ(n)) ⇒(((ϕ ∗ψ)n−1 ∧¬(ϕ ∗ψ)n−1) ⇒((ϕn−1 ∧¬(ϕn−1)) ∨(ψn−1 ∧¬(ψn−1))))
[1, Definition 93]
3
(((ϕ ∗ψ)n−1 ∧¬(ϕ ∗ψ)n−1) ⇒((ϕn−1 ∧¬(ϕn−1)) ∨(ψn−1 ∧¬(ψn−1)))) ⇒(¬((ϕn−1 ∧
¬(ϕn−1)) ∨(ψn−1 ∧¬(ψn−1))) ⇒¬((ϕ ∗ψ)n−1 ∧¬(ϕ ∗ψ)n−1))
[(9b)]
4
(ϕ(n) ∧ψ(n)) ⇒(¬((ϕn−1 ∧¬(ϕn−1))∨(ψn−1 ∧¬(ψn−1))) ⇒¬((ϕ∗ψ)n−1 ∧¬(ϕ∗ψ)n−1))
[2, 3, (T2), (MP)]
5
(¬(ϕn−1 ∧¬(ϕn−1)) ∧¬(ψn−1 ∧¬(ψn−1))) ⇒¬((ϕn−1 ∧¬(ϕn−1)) ∨(ψn−1 ∧¬(ψn−1)))
[(12b)]
6
(ϕ(n) ∧ψ(n)) ⇒((ϕn ∧ψn) ⇒(ϕ ∗ψ)n)
[4, (T1), 5, (T2), Definition 93, (MP)]
7
(ϕ(n) ∧ψ(n)) ⇒(ϕn ∧ψn)
[Definition 93]
8
(ϕ(n) ∧ψ(n)) ⇒(ϕ ∗ψ)n
[6, 7, (2), (MP)]

348
|
6 Applications of many-valued intensional first-order logic
Although it is not directly connected to the story of mZ and mCZ, it should be noted
that the propagation axiom for negation, i. e., the following formula can be derived in
an analogous manner: ϕ(n) ⇒(¬ϕ)(n).
Therefore, the propagation axioms can be fully proved in systems mZ and mCZ.
Remark. After all, we now know that systems mZ do not form a hierarchy but are
equivalent to a single system, which consists of IPC+ together with axioms (9b), (10b),
(11b), (12b).
6.2.1 Intuitionistic constructivism and Birkhoff’s polarity of negation in mZ-logic
It was demonstrated in [227] (Proposition 3) that the positive fragment of mZ sys-
tem corresponds to the complete distributive lattice (X, ≤, ∧, ∨, 0, 1) (the positive frag-
ment of the Heyting algebra), where the logic implication corresponds to the relative
pseudo-complement, (x ⇀y) =def ∨{z | z ∧x ≤y} and 0 and 1 are the bottom and top
elements in X, respectively.
The autoreferential representation of such truth-values lattice is provided in Sec-
tion 5.1.2. From Proposition 28, we have that X+ = {↓+ x | x ∈X} is a hereditary set
of join-irreducible elements of truth values in X, and (X+, ⊆) is a complete lattice with
meet operator ⋂(set intersection), and join operator ⋃(set union).
For the positive intuitionistic logic fragment IPC+ of mZ logic, the following au-
toreferential representation isomorphism holds for the Heyting algebras (from Propo-
sition 29 in Section 5.1.2, where we use only the relative pesudo-complement ⇀for the
binary operators ⊗i in algebras A for its representation isomorphism (5.10)):
↓+: (X, ≤, ∧, ∨, ⇀, 0, 1) ≃(X+, ⊆, ∩, ∪, 󴀚󴀠, {0}, ̂X)
(6.34)
such that for any two ↓+ x, ↓+ y ∈X+, (↓+ x) 󴀚󴀠(↓+ y) = ↓+(x ⇀y) (from Example 31
in Section 5.1.2).
A hierarchy of negation operators [69] for many-valued logics based on complete
lattices of truth values (X, ≤), w. r. t. their homomorphic properties is introduced in
Definition 104, Section A.3.2 in the Appendix. The negation with the lowest require-
ments (antitonic) denominated “general” negation can be defined in any complete
lattice (e. g., see [227]) as a monotone mapping between posets (≤OP is inverse of ≤),
¬ : (X, ≤) →(X, ≤)OP,
such that 1 ∈{¬x | x ∈X}
such that (see Lemma 14 in Section A.3.2 in the Appendix) for any x, y ∈X,
¬(x ∨y) ≤¬x ∧¬y,
¬(x ∧y) ≥¬x ∨¬y,
with ¬0 = 1

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
349
Remark. We can see (as demonstrated in [227]) that the negation in the system mZ
without axiom (12b) is a particular case of general negation, that the negation in the
whole system mZ is a split negation, as specified in Definition 104, Section A.3.2 in the
Appendix, while the negation in the system mCZ [227] is a constructive negation.
Thus, from Section 5.1.2, the set-based semantics for the split negations (with Ga-
lois connections) can be given by the Bikhoff polarity operator
λ : (𝒫(X), ⊆) →(𝒫(X), ⊆)
OP,
such that for any U ∈𝒫(X),
λU = {x ∈X | ∀u ∈U.((u, x) ∈ℛ)} = {x ∈X | ∀u.(u ∈U implies (u, x) ∈ℛ)},
which in a modal logic can be represented (the relation ℛis an incompatibility rela-
tion) by,
“ℳ󳀀󳨐x ¬ϕ iff ∀u.(ℳ󳀀󳨐u ϕ implies (u, x) ∈ℛ).”
The construction of the incompatibility (“perp”) relation ℛfor a given split negation
¬ is provided by (5.13) in Section 5.1.2 (where is denoted by operation ̃oi : (X, ≤) →
(X, ≤)OP). The set-based semantics for the constructive negation is obtained in the case
where the incompatibility relation ℛis symmetric.
Hence, what we have to do is only to extend the Heyting algebras in (6.34) by al-
gebraic negation operation λ, corresponding to the logical negation ¬ of the mZ logic
(different from the intuitionistic negation), and to obtain from the following represen-
tation algebra for many-valued mZ logics:
↓+: (X, ≤, ∧, ∨, ⇀, ¬, 0, 1) ≃(X+, ⊆, ∩, ∪, 󴀚󴀠, λ, {0}, ̂X)
(6.35)
from Proposition 29 in Section 5.1.2, where for negative operator ̃oi we use the symbol ¬
in the algebra A for its representation isomorphism (5.10), with homomorphic property
(5.14), λ = ↓+̃oi ⋁: X+ →X+, for λ, so that for each ↓∗x ∈X+, λ(↓+ x) = ↓+(¬x) ∈X+.
It is easy to see that, as in the demonstration given in [227], for any given incom-
patibility relation ℛ, the additive algebraic operator λ can be used as a split negation
for mZ logic.
Corollary 25 ([228]). Each split negation (modal negation), based on the hereditary in-
compatible relation of Birkhoff polarity, satisfies the Da Costa weakening axioms (11)
and (12).
Proof. To prove the Birkhoff polarity, we note that the following additivity property
holds for any hereditary subsets U, V ∈X+: λ(U ⋃V) = λU ⋃OP λV = λU ⋂λV, with
λ0 = 0OP = X. It is well known that Heyting algebra operators are closed for hereditary
subsets, so that λ applied to a hereditary subset U ∈X+ has to result in a hereditary
subset λ(U) ∈X+ as well (from homomorphic property (5.14), λ = ↓+̃oi ⋁: X+ →X+),
and the Lemma 6 in Section 5.1.2 demonstrates that it is satisfied if the relation ℛis

350
|
6 Applications of many-valued intensional first-order logic
hereditary as provided by (5.13). It is enough now to prove that in mZ logic the fol-
lowing formulae are valid (the logic negation operator ¬ corresponds to the algebraic
operator λ):
¬(ϕ ∨ψ) ≡(¬ϕ ∧¬ψ),
and
¬0 ≡1.
Indeed, we can derive this as follows:
1
(1 ⇒¬0) ⇒((¬0 ⇒1) ⇒((0 ⇒¬1) ∧(¬1 ⇒0)))
[(3)]
2
(¬0 ⇒1) ⇒((0 ⇒¬1) ∧(¬1 ⇒0))
[1, (10b), (MP)]
3
(0 ⇒¬1) ∧(¬1 ⇒0)
[2, (11b), (MP)]
4
¬0 ≡1,
[3, definition of ≡]
and,
1
(ϕ ⇒(ϕ ∨ψ)) ⇒(¬(ϕ ∨ψ) ⇒¬ϕ)
[(9b)]
2
(ψ ⇒(ϕ ∨ψ)) ⇒(¬(ϕ ∨ψ) ⇒¬ψ)
[(9b)]
3
¬(ϕ ∨ψ) ⇒¬ϕ
[1, (6), (MP)]
4
¬(ϕ ∨ψ) ⇒¬ψ
[2, (7), (MP)]
5
(¬(ϕ ∨ψ) ⇒¬ϕ) ∧(¬(ϕ ∨ψ) ⇒¬ψ)
[3, 4, (3), (MP)]
6
((¬(ϕ ∨ψ) ⇒¬ϕ) ∧(¬(ϕ ∨ψ) ⇒¬ψ)) ⇒(¬(ϕ ∨ψ) ⇒(¬ϕ ∧¬ψ))
[(T0)]
7
¬(ϕ ∨ψ) ⇒(¬ϕ ∧¬ψ)
[5, 6, (MP)]
8
¬(ϕ ∨ψ) ≡(¬ϕ ∧¬ψ)
[7, (12b), definition of ≡]
This property holds for the constructive negation as well, thus for the systems
mCZ. Thus, for these two paraconsistent systems we can define the Kripke semantics
in the similar way as for the intuitionistic logic. Let us show that in this weak intu-
itionistic negation, modeled by Birkhoff polarity, the Da Costa principle NdC1 of non-
contradiction is generally valid.
Lemma 8 ([228]). In these mZ calculi, the principle of noncontradiction, in the form,
¬(ϕ ∧¬ϕ), should not be a generally valid schema.
Proof. In order to show that ¬(ϕ ∧¬ϕ) is not valid in mZ calculi, it is enough to find
an example for a system mZ calculi, where this schema ¬(ϕ ∧¬ϕ) is not valid. Con-
sider, e. g., the mZ logic in Lemma 9, with the minimal cardinality is represented by
the 3-valued logic X = {0, 1
2, 1} (a Belnap’s sublattice obtained by elimination of the
value ⊤) but with negation different from the well-known 3-valued Kleene logic. In
the proof of this lemma is demonstrated that ¬( 1
2 ∧¬ 1
2)
̸= 1.
Consequently, in the system mZ calculi, the schema ¬(ϕ ∧¬ϕ) is not valid.
Consequently, this system mZ satisfies Da Costa’s requirements, NdC1 and NdC2,
and NdC4 as well, because the positive fragment of this logics is equal to the positive
part of propositional logic, and hence it is conservative extension of positive proposi-
tional logic.

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
351
The mZ logic is many-valued propositional logic with a set X of logic truth val-
ues, with autoreferential representation in (6.35). That is, different from the original
Da Costa weakening of the classical negation that results in a nontruth-functional log-
ics, mZ is a system of many-valued truth-functional logics with a lattice (X, ≤) of truth
values. Consequently, we are able to obtain an embedding of mZ logics into the MV
intensional FOL presented in a dedicated chapter of this book.
The intuitionistic interpretation of negation and logic constructivism
The fundamental characteristic of the IPC is that negation is a derived operation from
the constructive implication, i. e., ¬Iϕ is defined by ϕ ⇒0. Thus, in order to analyze
the intuitionistic negation ¬I we have to consider the intuitionistic implication ⇒. In
Kolmogorov [270], he took care to lay down the meaning of constructive implication:
“The meaning of the symbol ϕ ⇒ψ is exhausted by the fact that, once convinced of the truth of ϕ,
we have to accept the truth of ϕ, too.”
From this point of view, the ex falso (quodlibet) principle (EF) ¬ϕ ⇒(ϕ ⇒ψ) was
questionable, to say the least. In fact, he decided to reject it (in the sense of paraconsis-
tent logic). He argued that axiom now considered does not have and cannot have any
intuitive foundation, since it asserts something about the consequence of something
impossible. In 1932, Kolmogorov published [271] a full version of this “problematic in-
terpretation,” by considering a proposition ϕ as a problems and constructive truth of
ϕ comes to “we have a solution of A.” Thus, a problem (proposition) ϕ ⇒ψ is formu-
lated as “given a solution of ϕ, find solution of ψ.” The ex falso axiom ¬Iϕ ⇒(ϕ ⇒ψ)
was accepted by Kolmogorov on the strength of the following convention:
“As far as problem ¬Iϕ ⇒(ϕ ⇒ψ) is concerned, as soon as ¬Iϕ is solved, the solution of ϕ is
impossible, and the problem ϕ ⇒ψ has no content. In what follows, the proof that a problem is
without content will always be considered as its solution.”
Thus, this convention about negation is highly nonconstructive. The modern formula-
tion of intuitionistic implication appears first time in 1934 in Heyting [272], page 14:
“A proof of a proposition consists of the realization of the construction demanded by it. ϕ ⇒ψ
means the intension on a construction, which leads from any proof of ϕ to a proof of ψ.”
Kolmogorov never returned to intuitionistic logic and the matter of EF rule, Heyting
on the other hand returned to this principle in his intuitionism where he recognized
that in the case of a false antecedent the construction interpretation is problematic:
“Now suppose that ¬Iϕ is true, i. e., we have deduced a contradiction from supposition that ϕ were
carried out. Then, in sense, this can be considered as a construction, which, joined to a prof of ϕ
(which cannot exist) leads to a proof of ψ. I shall interpret the implication in this wider sense.”

352
|
6 Applications of many-valued intensional first-order logic
Thus, Heyting’s justification of the intuitionistic negation is, albeit hesitant, the stan-
dard argument of today. We recall that the current intuitionistic meaning of logic con-
nectives:
–
A proof of ϕ∧ψ consists of a proof of ϕ and a proof of ψ plus the conclusion ϕ∧ψ,
or in Kripke semantics, for any possible world w ∈𝒲,
ℳ⊨w ϕ ∧ψ
iff
ℳ⊨w ϕ and ℳ⊨w ψ.
–
A proof of ϕ ∨ψ consists of a proof of ϕ or a proof of ψ plus the conclusion ϕ ∨ψ,
or in Kripke semantics, for any possible world w ∈𝒲,
ℳ⊨w ϕ ∨ψ
iff
ℳ⊨w ϕ or ℳ⊨w ψ.
–
A proof of ϕ ⇒ψ consists of a method (or algorithm) of converting any proof of ϕ
into a proof of ψ, or in Kripke semantics, for any possible world w ∈𝒲,
ℳ⊨w ϕ ⇒ψ
iff
(∀w′ ∈𝒲)((w, w′) ∈R◻implies (ℳ⊨w′ ϕ implies ℳ⊨w′ ψ)),
where R◻is a reflexive and transitive relation, so that ϕ ⇒ψ is equivalent to a
modal formula ◻(ϕ ⇒c ψ) ≡◻(¬cϕ ∨ψ), where ◻is the universal modal “neces-
sary” operator of S4 modal logic and ⇒c, ¬c the classical implication and nega-
tion, respectively.
Notice that ¬Iϕ is obtained when ψ is the falsum 0, so that ¬Iϕ ≡◻¬cϕ.
–
No proof of 0 (falsum) exists, i. e., for each w ∈𝒲, ℳ⊭w 0, i. e., “not ℳ⊨w 0.”
These historical considerations give more justifications in our attempt to modify this
intuitionistic unconstructive negation into another more constructive and paraconsis-
tent.
Proposition 31. A paraconsistent negation in mZ logic is paraconsistently-constructive,
i. e., ¬ = ◻P¬c where ¬c is the classical negation and ◻P is new universal paraconsistent
modal operator.
Proof. Let us consider the standard Kripke semantics of the intuitionistic negation ¬Iϕ
(equivalent to ϕ ⇒0) with the set of possible worlds 𝒲for intuitionistic negation
(pseudocomplement), where ¬c is the classic negation and ◻is the universal modal
“necessity” (S4) operator, with the reflexive+transitive accessibility relation R◻⊆𝒲×
𝒲between theoretical constructions (from the Brower’s constructive point of view).
So that (w, w′) ∈R◻means that a theoretical construction (proof) w′ is a result of
positive development of a theoretical construction w. So that,
ℳ⊨w ¬Iϕ
iff
ℳ⊨w ϕ ⇒0
iff
∀w′ ∈𝒲((w, w′) ∈R◻implies (ℳ⊨w′ ϕ implies ℳ⊨w′ 0))

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
353
iff
∀w′ ∈𝒲((w, w′) ∈R◻implies (not ℳ⊨w′ ϕ or ℳ⊨w′ 0))
iff
∀w′ ∈𝒲((w, w′) ∈R◻implies not ℳ⊨w′ ϕ) iff ℳ⊨w ◻¬cϕ,
So, from this constructive point of view, an informal Kripke semantics is as follows:
“¬Iϕ is proved in the framework w iff in the framework of every possible construction w′ (which is
the result of some development of the construction w) ϕ is not proved.”
The Kripike semantics for a paraconsistent negation ¬ in mZ is, instead, based on an
incompatibility relation ℛ(from Birkhoff’s polarity), defined by
‖¬ϕ‖ = λ(‖ϕ‖) = {w ∈𝒲| ∀w′ ∈‖ϕ‖.(w′, w) ∈ℛ},
i. e.,
ℳ⊨w ¬ϕ
iff
∀w′(ℳ⊨w′ ϕ implies (w′, w) ∈ℛ)
iff
∀w′ (not ℳ⊨w′ ϕ or (w′, w) ∈ℛ)
iff
∀w′((w′, w) ∉ℛimplies not ℳ⊨w′ ϕ)
iff
∀w′((w, w′) ∈R◻P implies not ℳ⊨w′ ϕ) iff ℳ⊨w ◻P¬cϕ,
where R◻P = ((𝒲×𝒲)−ℛ)−1 is the paraconsistently-constructive accessibility relation
for the universal paraconsistent modal operator ◻P.
However, our working framework is based on the canonical autoreferential repre-
sentation and Kripke semantics provided by Definition 65 in Section 5.1.2, and hence
we will use the set of possible worlds 𝒲= ̂X in what follows.
What we obtain for the mZ logic is that it is a bimodal logic with two universal
modal operators, the necessity universal modal operator ◻(with accessibility binary
relation equal to a poset (̂X, ≤)) used for the intuitionistic implication ⇒equal to ◻⇒s
where ⇒s is standard (classical) implication, and the universal paraconsistent modal
operator ◻P (with the accessibility binary relation R◻P = ((̂X × ̂X) −ℛ)−1 derived from
the hereditary incompatibility relation ℛdefined by (5.13) in Section 5.1.2) used for the
modal paraconsistent operator ¬ equal to ◻P¬c where ¬c is classical negation.
Thus, here we will provide a Kripke semantics for the mZ logic, as a particular case
of Definition 65 in Section 5.1.2.
Definition 95. We define the Kripke model ℳ= (̂X, ≤, ℛ, IK) for the mZ logic, where
the set of possible worlds is ̂X (join-irreducible elements plus bottom value 0), for a
many-valued algebra represented by (6.35), ℛis an hereditary incompatibility binary
accessibility relation (5.13) for weakened paraconsistent negation, with R◻P = ((̂X ×
̂X) −ℛ)−1, and IK : Var ×̂X →1 is a Kripke interpretation. Then, for any world x ∈̂X,
and formulae ψ and ϕ,
1.
ℳ󳀀󳨐x p iff IK(p, x) = 1, for any p ∈Var.
2.
ℳ󳀀󳨐x ϕ ∧ψ iff ℳ󳀀󳨐x ϕ and ℳ󳀀󳨐x ψ,
3.
ℳ󳀀󳨐x ϕ ∨ψ iff ℳ󳀀󳨐x ϕ or ℳ󳀀󳨐x ψ,
4.
ℳ󳀀󳨐x ϕ ⇒ψ iff ∀y ∈̂X((y ≤x and ℳ󳀀󳨐y ϕ) implies ℳ󳀀󳨐y ψ),

354
|
6 Applications of many-valued intensional first-order logic
5.
ℳ󳀀󳨐x ¬ϕ iff ∀y ∈̂X(ℳ󳀀󳨐y ϕ implies (y, x) ∈ℛ), iff ∀y ∈̂X((x, y) ∈R◻P implies not
ℳ󳀀󳨐y ϕ),
for a negation modal operator ¬.
Consequently, from Theorem 17 in Section 5.1.2, we obtain that for any mZ formula
ψ, ‖ψ‖ ∈X+ =def {↓+ x | x ∈X}. is a hereditary subset of join-irreducible truth values
of the complete distributive lattice (X, ≤) as represented by the isomorphism (6.35).
Let us show that the intuitionistic negation ¬I may be obtained as a special case
of the Birkhoff’s polarity as well (as is our paraconsistent negation).
Corollary 26. For the incompatibility relation defined by ℛ= (̂X×̂X)−R−1
◻, where R◻is a
reflexive and transitive accessibility relation of the intuitionistic logic, from the Birkhoff’s
polarity method we obtain exactly the intuitionistic negation.
Proof. We have that R◻= ((̂X × ̂X) −ℛ)−1, and from Birkhoff’s polarity,
‖¬ϕ‖ = λ(‖ϕ‖) = {x ∈̂X | ∀y ∈‖ϕ‖.(y, x) ∈ℛ},
i. e.,
ℳ⊨x ¬ϕ
iff
∀y(ℳ⊨y ϕ implies (y, x) ∈ℛ)
iff
∀y((x, y) ∈R◻implies not ℳ⊨y ϕ) iff ℳ⊨x ◻¬cϕ iff ℳ⊨x ¬Iϕ.
Proposition 31 and Corollary 26 demonstrate the general constructive approach
to the paraconsistent negations based on the construction of an incompatibility rela-
tion with Birkhoff’s polarity, and show that in this very general framework, the non-
paraconsistent intuitionistic logic is only a special particular case.
Consequently, if we consider these three logics (the intermediate logics between
IPC and CPC are well understood and studied already), this weakening of logic con-
nectives can be summarized as follows:
–
CPC: here we have only to independent operators: the negation ¬c and one (usu-
ally taken implication) of the three binary operators. Another two operators are
only derived operators.
–
IPC: here we have the three mutually independent operators, ∧, ∨and ⇒, while
negation operator ¬I is derived one such that ¬Iϕ is logically equivalent to the
formula ϕ ⇒0, where 0 is a contradiction (falsum) constant.
–
mZ: here, we have generally all four operators mutually independent, where the
negation ¬ is obtained as a weakening of the intuitionistic negation ¬I by preserv-
ing its two fundamental properties: antitonicity and modal additivity.
This kind of weakening of the interdependence of the logic operators is a kind of
obtaining of more powerful and relevant logics, by progressively extending classical
logic with more powerful semantics: IPC can be seen as a means of extending classi-
cal logic with constructive semantics, so that IPC ≺CPC, where ⪯is the ordering in the
current lattice of intermediate logics.

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
355
In what follows, we will see that mZ logic can be seen as means of extending IPC
with paraconsistent semantics as well. So, from the philosophical point of view, mZ
will become a new bottom element of the lattice of intermediate logics, that is mZ ≺
IPC.
Consequently, mZ extends a constructive logic IPC with Da Costa paraconsistent
semantics. In this hierarchy, we obtain more and more relevant logics (where the num-
ber of derivable theorems is progressively diminished), in the way that mZ is more rel-
evant logic than IPC, and IPC is more relevant logic than all intermediate logics, while
CPC is not relevant at all.
In this new point of view, the relationship between intuitionistic and paraconsis-
tent logics is rather new one and in apparent opposition with the previous historical
approach, where these two approaches are considered “dual,” and are seen as two
opposite extremes.
Theorem 15. All negative axioms in mZ logic are the theorems in IPC.
Consequently, mZ ≺IPC is a strict constructive paraconsistent weakening of the
intuitionistic logic.
Proof. 1.
From definition of the intutitionistic negation, (ϕ ⇒0) ≡¬Iϕ, it holds that
(ϕ ⇒0) ⇒¬Iϕ and by substituting ϕ with 0 (denoted by ϕ 󳨃→0) we obtain
1.1 (0 ⇒0) ⇒¬I0,
1.2 ϕ ⇒ϕ,
[theorem in IPC]
1.3 0 ⇒0,
[1.2, and substitution ϕ 󳨃→0]
1.4 ¬I0,
[1.1, 1.3, (MP)]
1.5 ¬I0 ⇒(1 ⇒¬I0),
[axiom (1) IPC+, with ϕ 󳨃→¬I0, ψ 󳨃→1]
(10.b) 1 ⇒¬I0,
[1.4, 1.5, (MP)]
1.6 (1 ⇒(ϕ ⇒1)),
[axiom (1) IPC+, with ϕ 󳨃→1, ψ 󳨃→ϕ]
1.7 theorem 1,
[theorem in IPC]
(11.b) ϕ ⇒1,
[1.6, 1.7, (MP)]
2.
(11.b) 0 ⇒ϕ is an axiom in IPC.
3.
Let us show that the weak contraposition (9.b), (ϕ ⇒ψ) ⇒(¬Iψ ⇒¬Iϕ), is a
theorem in IPC:
3.1. The formula (T2), (ϕ ⇒ψ) ⇒((ψ ⇒φ) ⇒(ϕ ⇒φ)), is a theorem in IPC.
3.2. By substitution of φ with 0 in (T2), we obtain (ϕ ⇒ψ) ⇒((ψ ⇒0) ⇒(ϕ ⇒
0)), that is, from the fact that ¬Iψ in IPC is defined by ψ ⇒0, we obtain that
(9.b) is a theorem in IPC.
4.
From the IPC+ theorem ((ϕ ∨ψ) ⇒φ) ≡((ϕ ⇒φ) ∧(ψ ⇒φ)), by substitution
of φ by 0 and by definition of intuitionistic negation ¬I, we obtain ¬I(ϕ ∨ψ) ≡
(¬Iϕ∧¬Iψ) (modal additive property for intuitionistic negation), thus the theorem:
(12.b) ¬I(ϕ ∨ψ) ⇒(¬Iϕ ∧¬Iψ).
Notice that, as in mZ logic, also in IPC, the intuitionistic negation ¬I is an additive
modal operator with Birkhoff’s polarity semantics given in Corollary 26.

356
|
6 Applications of many-valued intensional first-order logic
Corollary 27. The relationship between the intuitionistic negation ¬I and the weakened
paraconsistent negation ¬ in mZ logic is: ¬I ≤¬.
Proof. The meaning of ¬I ≤¬ in the Heyting algebra (X, ≤, ∧, ∨, ⇀), extended by the
modal paraconsistent negation ¬ : X →X, is expressed by the sentence (∀x ∈X)(¬Ix ≤
¬x) or, equivalently, in mZ logic, by the theorem ¬Iϕ ⇒¬ϕ for any ϕ. By considering
that ¬Iϕ is a formula ϕ ⇒0, it means that we have to show that a formula (ϕ ⇒0) ⇒
¬ϕ is a theorem as follows:
1
(ϕ ⇒1) ⇒((ϕ ⇒(1 ⇒φ)) ⇒(ϕ ⇒φ)),
[axiom (2) IPC+, where ψ 󳨃→1]
2
(ϕ ⇒(1 ⇒φ)) ⇒(ϕ ⇒φ),
[1, (11,b), (MP)]
3
((1 ⇒φ) ⇒(1 ⇒φ)) ⇒((1 ⇒φ) ⇒φ),
[2, where ϕ 󳨃→1 ⇒φ]
4
(1 ⇒φ) ⇒φ,
[3, (1 ⇒φ) ⇒(1 ⇒φ), (MP)]
5
(1 ⇒¬ϕ) ⇒¬ϕ,
[4, where φ 󳨃→¬ϕ]
6
¬ϕ ≡(1 ⇒¬ϕ),
[5, axiom (1) IPC+ with ψ 󳨃→1]
7
(ϕ ⇒0) ⇒(¬0 ⇒¬ϕ),
[from axiom (9.b), where ψ 󳨃→0]
8
(ϕ ⇒0) ⇒(1 ⇒¬ϕ),
[¬0 ≡1, from (10.b) and (11.b) with ϕ 󳨃→¬0]
9
(ϕ ⇒0) ⇒¬ϕ,
[from 8 and 5]
i. e., ¬Iϕ ⇒¬ϕ.
Now we will show which axioms are necessary to add to mZ logic in order to obtain
the intuitionistic logic.
Proposition 32. The intuitionistic logic IPC is equal to mZ plus axiom (¬ϕ ⇒(ϕ ⇒0)).
Consequently, both formulae, ϕ∨¬ϕ and ¬(ϕ∧¬ϕ), excluded middle and paracon-
sistent noncontradiction relatively, are not valid schemas in mZ.
Proof. The IPC is defined by eight positive axioms in IPC+, plus:
(11.b) 0 ⇒ϕ, falsity axiom, plus two axioms for the intuitionistic negation,
(N1) ¬ϕ ⇒(ϕ ⇒0),
(N2) (ϕ ⇒0) ⇒¬ϕ.
Consequently, it is enough only to show that (ϕ ⇒0) ⇒¬ϕ is a theorem in mZ.
From the weak contraposition axiom schemata (9.b) in the case when ψ is substi-
tuted by 0, we obtain that (ϕ ⇒0) ⇒(¬0 ⇒¬ϕ) and from the fact that ¬0 ≡1 (from
(11.b) when ϕ is substituted by ¬0 and (10.b)), we obtain (ϕ ⇒0) ⇒(1 ⇒¬ϕ).
It is enough to show that (1 ⇒¬ϕ) ≡¬ϕ is a theorem in mZ, and it is demonstrated
in point 6 of the proof of Corollary 27.
Thus, we have that the noncontradiction schema is not a valid schema in mZ (from
previous Lemma 8). Moreover, if we denote the set of theorems of IPC by ℒICP and the
set of theorems of mZ by ℒmZ, from the fact that ℒmZ ⊂ℒICP and from the fact that
the excluded-middle schema does not hold in IPC, i. e., ϕ ∨¬ϕ ∉ℒICP, we also obtain
ϕ ∨¬ϕ ∉ℒmZ.

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
357
Consequently, based on Theorem 15 and Proposition 32, we obtain that mZ is con-
structive logic as IPC (they have the same set of theorems for their positive fragment),
but the set of theorems with negation operator ¬ in mZ is a strict paraconsistent subset
of theorems with intuitionistic negation ¬I in IPC.
Consequently, mZ is a subintuitionistic logic, and hence mZ is a more useful logic
than IPC, i. e., more relevant w. r. t. the IPC, because it avoids explosive inconsistency.
From the point of Da Costa paraconsistency of the mZ logic, it was demonstrated (by
Theorem 14) that the Da Costa axioms (11) and (12) are theorems in mZ, so that in mZ all
hierarchy of Da Costa’s systems are present in this single mZ logic; thus, mZ logic is by
itself Da Costa paraconsistent and its axioms implicitly cover the Da Costa’s reductio
relativization property (and its propagation) and combines it with the constructive
property of the intuitionistic logics.
These results demonstrate that the paraconsistency is not simply dual to the con-
structivism, as it was historically supposed and investigated. In fact, mZ logic com-
bines both constructive and paraconsistent properties, where both excluded middle
and the non-contradiction schemas are not valid.
We have demonstrated that the paraconsistency is based on a very constructive
approach, and we will show it in next sections by the construction of incompatibility
relations for the paraconsistent negations: we will present a number of useful subin-
tuitionistic mZ logics for practical applications as well.
6.2.2 Subintuitionistic paraconsistent mZ-logics derived from Kleene, Belnap,
fuzzy and Gödel–Dummett logics
In what follows, we will present a number of examples of many-valued logics that are
members of the mZ system. We will use the Kripke-style models of the mZ logics in
Definition 95, where the set of possible worlds 𝒲= ̂X used for the Birkhof-polarity
semantics of its algebraic split negation λ, used for negation connective ¬ in mZ logic,
with the algebra on hereditary subsets (X+, ⊆, ⋂, ⋃, 󴀚󴀠, λ) as provided by representa-
tion isomorphism (6.35) between many-valued Heyting algebra of truth values in X
(with implication defined as pseudo-complement x ⇀y = ⋁{z ∈X | z ∧x ≤y} and
negation by ¬x = x ⇀0) and its set-based representation algebra (6.34),
↓+: (X, ≤, ∧, ∨, ⇀, ¬, 0, 1) ≃(X+, ⊆, ∩, ∪, 󴀚󴀠, λ, {0}, ̂X)
in Section 6.2.1, where the set-based implication operator is defined by
(↓+ x) 󴀚󴀠(↓+ y) = ↓+(x ⇀y)
Thus, what we need is only to replace the intuitionistic negation used in Heyting alge-
bras by their paraconsistent weakening (substitute ̂¬ by λ in the isomorphism above),

358
|
6 Applications of many-valued intensional first-order logic
and hence to find the incompatibility relation ℛused in Birkhoff-polarity for the split
negation λ, in order to preserve this representation-isomorphism above.
Now we will apply this definition of autoreferential semantics to a number of ex-
amples of the logics to be transformed into the mZ intuitionistic paraconsistent sys-
tems. In particular, we will consider the logics with a minimal cardinality (three and
four-valued logics) and then of also infinite-valued logics.
In [190], Belnap introduced a logic intended to deal in a useful way with incon-
sistent or incomplete information, as we explained in Section 5.1.3, but here we will
represent slightly different its four truth values in accordance with representation of
truth values in mZ logic. So, we denote the four logic values as X = ℬ4 = {0, 1
2, 1, ⊤},
where 1 is true, 0 is false, ⊤is inconsistent (both true and false) or possible, and 1
2 is
unknown. As Belnap observed, these values can be given two natural orders: truth or-
der, ≤, and knowledge order, ≤k, such that 0 ≤⊤≤1, 0 ≤1
2 ≤1, and 1
2 ≤k 0 ≤k ⊤,
1
2 ≤k 1 ≤k ⊤.
1
⊤
1
2
≤
?
(ℬ4, ≤, ∧, ∨)
⊤
?
≤
0
≤k
?
(ℬ4, ≤k, ⊗, ⊕)
1
?
≤k
0
≤
?
?
≤
1
2
≤k
?
?
≤k
Meet and join operators under ≤are denoted ∧and ∨; they are natural generalizations
of the usual conjunction and disjunction notions. Meet and join under ≤k are denoted
⊗(consensus, because it produces the most information that two truth values can agree
on) and ⊕(gullibility, it accepts anything it’s told). We have that:
0 ⊗1 = 1
2,
0 ⊕1 = ⊤,
⊤∧1
2 = 0 and ⊤∨1
2 = 1.
There is an epistemic notion of truth negation, denoted by ∼, (reverses the truth ≤
ordering, while preserving the knowledge ≤k ordering): switching 0 and 1, leaving
1
2 and ⊤. Let us consider the minimal cardinality for such one many-valued logic of
the system mZ.
Lemma 9. In the mZ logic, the minimal cardinality is represented by the 3-valued logic
X = {0, 1
2, 1} (a Belnap’s sublattice obtained by elimination of the value ⊤) but with nega-
tion different from the well-known 3-valued Kleene logic. We obtain a weakening of the
Kleene-negation by the fact that, instead of ¬1 = 0, we have that ¬1 = 1
2.

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
359
Proof. The set of join-irreducible elements is 𝒲= { 1
2, 1} and ̂X = 𝒲⋃{0}, with the iso-
morphism (6.34) such that ↓+ 0 = {0}, ↓+ 1
2 = {0, 1
2} and ↓+ 1 = {0, 1
2, 1} = ̂
X, and hence
X+ = {{0}, {0, 1
2}, ̂X} and hereditary relation, from (5.13), ℛ= {(0, 0), (0, 1
2), (0, 1), ( 1
2, 0),
( 1
2, 1
2), (1, 0), (1, 1
2)} for the split negation λ.
It is easy to verify that λ(̂X) = {0, 1
2}
̸= {0} (i. e., from the algebra isomorphism
(6.34), ¬1 = 1
2
̸= 0) and that for V = {0, 1
2}, λ(V ⋂λ(V)) = {0, 1
2}
̸= ̂X (i. e., ¬( 1
2 ∧¬ 1
2) =
1
2
̸= 1), so that the principle of noncontradiction is valid.
It is different from the Kleene logic where ¬1 = 0, while in our 3-valued paracon-
sistent mZ logic we have by the weakening of negation that ¬1 = 1
2 (i. e., ¬1 = ¬ 1
2 =
1
2, ¬0 = 1), but ¬ is monotonic w. r. t. the knowledge ordering ≤k so that this logic can
be used for logic programming with Fitting’s fixed-point semantics and stable mod-
els.
Note that this paraconistent 3-valued logic satisfy all axioms of the mCZ logics as
well.
Let us show that in mZ system there is a Belnap’s bilattice based logic with weak-
ened negation that is monotonic w. r. t. the knowledge ordering ≤k. Consequently, we
can use this 4-valued paraconsistent mZ logic for a logic programming for the standard
bilattice negation ∼.
Lemma 10. In the mZ systems, the bilattice based logic is represented by the 4-valued
Belnap’s bilattice X = ℬ4 = {0, 1
2, 1, ⊤}, but with negation ¬ different from the original
bilattice negation ∼. We obtain a weakening of the negation ∼by the fact that, instead
of ∼1 = 0 and ∼⊤= ⊤, we define ¬1 = 1
2 and ¬⊤= 1, respectively.
Proof. The set of join-irreducible elements is 𝒲= { 1
2, ⊤} and ̂X = 𝒲⋃{0}, with the
isomorphism (6.34) such that ↓+ 0 = {0}, ↓+
1
2 = {0, 1
2}, ↓+ ⊤= {0, ⊤} and ↓+ 1 =
{0, 1
2, ⊤} = ̂
X, and hence X+ = {{0}, {0, 1
2}, {0, ⊤}, ̂X} and hereditary relation, from (5.13),
ℛ= {(0, 0), (0, 1
2), (0, ⊤), ( 1
2, 0), ( 1
2, 1
2), (⊤, 0), (⊤, 1
2), (⊤, ⊤)} for the split negation λ. It is
easy to verify that λ(̂X) = {0, 1
2}
̸= {0} and for V = {0, 1
2}, λ(V ⋂λ(V)) = {0, 1
2}
̸= ̂X, so
that the principle of noncontradiction is valid.
We have that λ({0, 1
2}) = {0, 1
2} and λ({0, ⊤}) = ̂X = {0, 1
2, ⊤}.
Consequently, we obtain that ¬1 = ¬ 1
2 = 1
2 and ¬0 = 1 and ¬⊤= 1. Consequently, it
is easy to verify that the obtained weakened negation ¬ is monotonic w. r. t. the knowl-
edge ordering ≤k and we are able to use Fitting’s fixed-point semantics and stable mod-
els, in the same way as the Belnap’s logic with the standard negation ∼.
Note that if we omit the 4-th value ⊤from the paraconsistent Belnap’s logic in
Lemma 10, i. e., replace it by 1
2, we obtain, as reduction, the paraconsistent Kleene’s
logic in Lemma 9, as my be seen from their truth-value tables:

360
|
6 Applications of many-valued intensional first-order logic
IPC
mZ
0
1
1
1
2
⊤
1
2
1
0
1
2
⊤
1
2
1
󳨃→
IPC
mZ
0
1
1
1
2
1
2
1
2
1
0
1
2
In both cases of these two lemmas for mZ-logics obtained from intuitionistic Kleene’s
and Belnap’s logics, the split negation λ is modeled by the incompatibility relation
ℛ= ⋃x∈X(↓+ x) × (↓+ ¬x) in (5.13) in Section 5.1.2.
Now we will apply this method to an important infinitary many valued logic:
Zadeh’s fuzzy logic.
Da Costa paraconsistent Zadeh-fuzzy logic
Let us consider the original set of Zadeh fuzzy operators on the closed interval X =
[0, 1] of reals, with negation ¬, conjunction ∧and disjunction ∨, defined as follows:
1.
¬x = 1 −x;
2.
x ∧y = min(x, y);
3.
x ∨y = max(x, y);
so that the conjunctionand disjunction arethe meetandjoinoperatorsofthe complete
distributive lattice ([0, 1], ≤).
The closed interval of reals [0, 1] is a total ordering, i. e., a complete distributive
lattice, so that we can enrich the original fuzzy logic with intuitionistic implication (as
in t-norm logics), that is with a relative pseudo-complement. Thus, for any x, y ∈[0, 1]
we define x ⇀y by ⋁{z | x ∧z ≤y} = max{z | min(x, z) ≤y}.
It is easy to verify that the fuzzy logic is not Da Costa paraconsistent, because of
the fact that ¬1 = 0. In the standard fuzzy logic, the sentences are considered true
if their truth value x satisfy 0 < ε1 ≤x ≤1 for a prefixed value ϵ1, so that the set
of designated truth values is D = [ε1, 1] (each sentence with the truth value in D is
considered as true sentence).
Consequently, as in the case of the 3-valued Kleene logic and 4-valued Belnap’s
bilattice logic, we need to change the original negation, where ¬x = 1 −x, in the way
that ¬1 = ε0 > 0, where ε0 > 0 is a prefixed positive infinitesimal value. In this way,
with this very slightly changed fuzzy logic, we obtain a paraconsistent fuzzy mZ logic.
We recall that in any many-valued mZ logic the set of designated elements is ex-
actly the singleton {1} (this fact comes out from the Kripke-like semantics of the mZ
system, where a sentence (proposition) is true only and only if it is true in all possible
worlds ̂X). Thus the set of truth values in the paraconsistent fuzzy logic that is a mem-
ber of mZ system has to be changed from [0, 1] for the set D of designated elements in
the fuzzy logic, as follows.

6.2 Relevant mZ-logic: paraconsistent intuitionistic logic
|
361
Lemma 11. Let us consider a fuzzy logic with a matrix defined by a set of designated
elements D = [ε1, 1], with 0.5 < ε1 ≤1, and let us fix an infinitesimal positive value ε0
such that 0 < ε0 ≪ε1. We define the intuitionistic implication by the relative-pseudo-
complement ⇀in X = [0, 1], and the negation operator for any x ∈X,
¬x = max(ε0, 1 −x)
(6.36)
Then the logic (X, ≤, ∧, ∨, ⇀, ¬) is a paraconsistent mZ fuzzy logic.
Proof. First of all, let us show that ¬ is an antitonic additive operator, thus a split
negation that can be modeled by Birkhof polarity and its incompatibility relation.
In fact, for any two x, y ∈X if x ≥y then ¬x = max(ε0, 1 −x) ≤max(ε0, 1 −y) = ¬y.
Thus, it is antitonic. The antitonicity is preserved in the cases when ¬x = 1 as well. Let
us show that it is also additive:
1.
For the bottom element 0 ∈X, we have that ¬0 = max(ε0, 1) = 1.
2.
For x, y ∈X, ¬(x∨y) = ¬(max(x, y)) = max(ε0, 1−max(x, y)) = max(ε0, min(1−x, 1−
y)) = max(ε0, (1−x)∧(1−y)) = ε0∨((1−x)∧(1−y)) = (ε0∨(1−x))∧(ε0∨(1−x)) = ¬x∧¬y.
Thus, ¬ is an additive antitonic operation, and consequently, it is a split negation.
Let us define the hereditary incompatible relation for this split negation. The sub-
set of join-irreducible elements of X is the set 𝒲= [0, 1] −{0}.
So, the set of all hereditary subsets of the complete distributive lattice 𝒲is X+ =
{↓+ x | x ∈X} = {[0, x] | x ∈X}. Thus, based on (5.13) in Section 5.1.2 the incompatibil-
ity relation for λ is
ℛ= ⋃
x∈X
[0, x] × [0, max(ε0, 1 −x)],
Consequently, for each x ∈X, λ([0, x]) = [0, max(ε0, 1 −x)], and it corresponds to
¬x = max(ε0, 1 −x).
Thus, this is a well-defined paraconsistent fuzzy logic, which belongs to the mZ
logics.
It is easy to verify, that in the limit case for the set of designated elements D = {1},
i. e., when ε1 = 1, we obtain that ¬x ∈D (i. e., it is true) if and only if x = 0.
Notice that for each max{ε0, 1 −ε1} < x < ε1, we have that ¬(x ∧¬x) ∉D (i. e., it is
not true), which satisfies the principle of noncontradiction Nd1 of Da Costa negation
weakening (consider, e. g., the limit case when ε1 = 1).
Paraconsistent subintuitionistic Gödel–Dummett logic
Gödel–Dummett logic (the logic of the minimum t-norm) was implicit in Gödel’s 1932
proof of infinite-valuedness of intuitionistic logic [273]. Later (1959), it was explicitly
studied by Dummett who proved a completeness theorem for the logic [274].

362
|
6 Applications of many-valued intensional first-order logic
Definition 96. Gödel–Dummett logics, LCn
= (Xn, ∧, ∨, ⇀, ¬, 0, 1), where for finite
n ≥2, Xn = {0,
1
n−1, . . . , n−2
n−1, 1} and for infinite n, X∞= [0, 1] (closed interval of reals)
are both total orders, where ∧, ∨are the meet and join operators of these distributive
complete lattices and ⇀and ¬ are defined as in the IPC.
Thus, they are intermediate logics, i. e., IPC + (ϕ ⇒ψ) ∨(ψ ⇒ϕ).
From the fact that this (added to IPC) axiom (ϕ ⇒ψ) ∨(ψ ⇒ϕ) does not contain
negation symbols, we conclude that the logic obtained by addition of this axiom to
mZ axiom system would not change the paraconsistent weakening of the intuitionistic
negation. Consequently, we are able to make the paraconsistent weakening of Gödel–
Dummett logic in the same way as for IPC.
Lemma 12. The paraconsistent Gödel–Dummett logic is obtained by addition the axiom
(ϕ ⇒ψ) ∨(ψ ⇒ϕ) to mZ system.
In this case, we do not change Xn and we define X∞= {0} ⋃[a, 1] for an enough big
value n ≫2 and atom a =
1
n−1, and the paraconsistent negation for any x in Xn:
¬x = 1
if x = 0;
a otherwise.
Proof. It is easy to verify that ¬ is an antitonic operator. Let us show that it is an addi-
tive modal operator as well:
1.
¬0 = 1.
2.
Let us show that for each x, y ∈X, ¬(x ∨y) = ¬x ∧¬y:
2.1 when x = 0 (or y = 0), we have ¬(0 ∨y) = ¬y = 1 ∧¬y = ¬0 ∧¬y.
2.2 when both x and y are different from 0: ¬(x ∨y) = a = a ∧a = ¬x ∧¬y.
Notice that the set of join-irreducible elements is 𝒲= X\{0}, so that the incom-
patibility relation, based on (5.13) in Section 5.1.2, is
ℛ= ⋃
x∈Xn
(↓+ x) × (↓+ ¬x) = {{0} × Xn}
⋃
x∈Xn−{0}
(↓+ x) × {0,
1
n −1}
= ( ⋃
x∈Xn
{(0, x), (x, 0), (x,
1
n −1)}) −{(0,
1
n −1)}
so that for each x ∈X,
λ(↓+ x) = Xn
if x = 0;
{0,
1
n −1} otherwise.
It is easy to verify that ¬I ⪯¬, as demonstrated by Corollary 27 for mZ logic, and ¬I
̸= ¬.
It is interesting to note that
¬x
̸= ¬Ix =def (x ⇀a) = 1
if x ∈{0, a};
a otherwise.

6.3 Belnap’s 4-valued P2P data integration with incomplete and inconsistent data
|
363
Both formulae, ϕ ∨¬ϕ and ¬(ϕ ∧¬ϕ), are not theorems. In fact for each x ∈Xn such
that x
̸= 0, we have that ¬(x ∧¬x) = a < 1, and for every x ∉{0, 1}, ¬x ∨x = x < 1.
Notice that by the paraconsistent weakening of the minimal cardinality Gödel–
Dummett logic (when n = 3), we obtain the paraconsistent Kleene logic in Lemma 9.
6.3 Belnap’s 4-valued P2P data integration with incomplete and
inconsistent data
Data quality in Cooperative Information Systems (CISs), which integrate a number of
local heterogeneous database systems is an increasingly important issue. Current in-
practice developed CISs are based on different software and architectural paradigms,
and are specified a number of ad hoc algorithms for quality query answering, without
an unifying logic framework (different from well-defined semantics in DIS (Data Inte-
gration Systems), introduced in Section A.6.4). The consequence is that each software
system responds in some way to user queries with record for which is not often clear
if it is really a logic answer from CISs database, if it is certain or only possible answer,
or, in some way, a new created information nonlogically deducible from a database.
Sometimes it is not also clear if the records obtained are complete answers w. r. t. the
logically derivable answers from the system. Because of such considerations, in this
section we present a general framework for a query answering in a logic theory in
Data Quality Cooperative Information Systems (DaQuinCIS) [275], by an epistemic ex-
tension of the standard data integration systems, and we introduce also a 4-valued
logic based on the Belnap’s bilattice (introduced in Section 5.1.3) and applied also in
Section 5.3, in order to deal with incomplete and inconsistent information.
The Cooperative Information Systems (CISs) is distributed and heterogeneous in-
formation systems that cooperate by sharing information, constraints, and goals [276].
CISs include data integration systems as well as systems that share common informa-
tion while not explicitly integrating data. It is well known that quality of data is a nec-
essary requirement for a CIS, i. e., CISs need data quality. First, a system in the CIS will
not easily exchange data with another system without a knowledge on their quality,
and cooperation becomes difficult without data exchanges. Second, when poor qual-
ity data are exchanged, there is a progressive deterioration of data stored in the whole
CIS.
Quality of data is not simply their correctness. Let us consider the case of an
address to delivery some mail: it can be correct, as having a street name and a
street number specified, but if not having a city included, it is useless for most
applications. The example shows that quality of data also means completeness. In
a similar way, we could show that data quality means many other things, such as
currency, interpretability, consistency and other “dimensions,” often depending from
the context where data are used and also from specific users within a given context.
It follows that data of good quality are not easy to be obtained: data quality itself is

364
|
6 Applications of many-valued intensional first-order logic
a complex concept defined by multiple dimensions, depending from many variables,
often very subjective.
The Data Quality in CIS (DaQuinCIS) is a platform for exchanging and improving
data quality in cooperative information systems, such that includes a data integration
system that allows to access data and quality “dimensions” (metadata): a data inte-
gration system ℐ[111] is a triple ℐ= ⟨𝒢, 𝒮, ℳ⟩, where 𝒢is the global schema, 𝒮is the
source schema, and ℳis the mapping between 𝒢and 𝒮(see Section A.6.4).
Organizations export data and quality data according to a common model, re-
ferred to as the Data and Data Quality (D2Q) model. It includes the definitions of con-
structs to represent data, a common set of data quality properties, constructs to rep-
resent them and the association between data and quality data. More details on the
model can be found in [277].
Thus, in DaQuinCIS, the Data integration system of an application is extended by
a number of auxiliary concepts used to support quality “dimensions” for correspon-
dent concepts of application: the structure of such auxiliary information is expressed
in the same definition language of the ordinary data integration system. We restrict
the consideration of D2Q models to those models where both ordinary “application-
oriented” data and their metadata (quality “dimensions”) are embedded into the same
definition language: we refer such D2Q models as flattened models. The characteristic
of flattened D2Q models is that metadata concern only data values: they do not deal
with aspects concerning quality of logical schema and data format. Also the query
language for such D2Q models is able to elaborate these metadata as ordinary data, so
that we are able to formulate complex queries over both data and their metadata.
Thus, formal framework for DaQuinCIS is that of data integration system, ℐQ, is a
triple ℐQ = ⟨𝒢Q, 𝒮Q, ℳQ⟩, where 𝒢Q is the global schema, an extension of 𝒢by quality
“dimensions” concepts, 𝒮Q is the source schema, an extension of 𝒮by quality “dimen-
sions” concepts, and ℳQ is the mapping between 𝒢Q and 𝒮Q, an extension of ℳby
mappings between “dimension” concepts. We will refer to ℐQ by: logic theory, which
define this quality-data integration system.
Generally speaking, when data are considered locally, they must satisfy only the
integrity constraints specified in the source to which they belong, but they are not
required to satisfy the fundamental integrity constraint for the global schema: the real
world entity must be represented by the unique record of the corresponding concept
in the global schema. In CIS, such requirement is often unsatisfied: different records
from local (source) databases (each one of them can have a particular quality), which
corresponds to the same real world entity are mapped to the concept in global schema.
Thus, while integrating data coming from different sources, it often happens that the
global database, which is constructed in the integration process, is inconsistent with
such fundamental integrity constraint. Because of that in CIS we do not impose any
integrity constraint over global schema, but we need to distinguish the true records in
the global schema (which uniquely represents some real world entity) from possible
records (the case when more than two records represent the same real world entity,

6.3 Belnap’s 4-valued P2P data integration with incomplete and inconsistent data
|
365
and there is not any system-provided inference able to choose some of them as true).
Notice that also in the presence of quality filtering, such as the best quality principle,
can happen that two different records of the same real world entity have the same best
quality value.
Another aspect is that the set of available sources might not store exactly the data
needed to answer a query posed to the system, so that the mapping cannot be consid-
ered exact. Hence, query processing in a data integration system is, in general, a form
of reasoning with incomplete information. In the context of data integration, the in-
complete information is introduced by existentially quantified integration rules: such
quantifiers are eliminated by introducing Skolem functions in the place of existen-
tially quantified attributes of concepts in a global schema.
Example 39. For example, a set of public administrations, which need to exchange
information about citizens and their health state in order to provide social aids, is a
cooperative business system derived from the Italian e-Government scenario [278]. In
order to improve the quality of the data, and thus to improve the service level offered to
businesses and enterprises, the agencies can deploy a cooperative information system
according to the architecture; therefore, each agency exports its data according to a
local schema (see Figure 6.1).
Figure 6.1: Conceptual representation of local schemas.
In the shown figure, two simplified versions of the local schemas are shown: two agen-
cies, namely the Social Security Agency, referred to as INPS (Istituto Nazionale Previ-
denza Sociale) at the left-hand side and the Chambers of Commerce, referred to as CoC
(Camere di Commercio) at the right-hand side.
Let us assume that the global schema derived from INPS and CoC local schemas
is composed by two analog concepts:
1.
Business: with Name, ID and Legal/Address attributes, denoted by PG(xn, xID, xa)
2.
Holder: with, FiscalCode, Address and Name attributes.

366
|
6 Applications of many-valued intensional first-order logic
Let PINPS(xn, xID) and PCoC(xn, xID, xa) denote the local concepts in local schemas re-
spectively, then the following mapping ℳQ, between global and local schemas, can
be given in the first-order logic:
∃xaPG(xn, xID, xa) ←PINPS(xn, xID)
PG(xn, xID, xa) ←PCoC(xn, xID, xa)
Thus, the first of these two mapping formulae introduce incomplete information in
the attribute Legal/Address of Business in the global schema. Consequently, also for
global schemas without any integration constraint, we can have incomplete informa-
tion in the database of the global schema. The records in global schema with Skolem
constants, introduced for existentially quantified attributes, may be considered an un-
known facts, which is not possible to support directly in the classical two-valued FOL,
and hence we can assign to them the logic value ⊥of the Belnap’s bilattice by working
with many-valued intensional FOL, introduced in Section 5.2.
Once one has made the transition from classical 2-valued to partial models, or
three-valued logic models, allowing incomplete information, it is a small step toward
allowing models admitting inconsistent information: introducing 4-th “possible” logic
value, and consequently the minimal 4-valued Belnap’s bilattice.
It is obvious that data integration over different local source databases make in-
consistent the database system also in the case of the more fundamental database
constraint based on the principle that each real world entity has to be represented
by at most one record in a database. If we consider the Example 39, we can for in-
stance suppose that the attribute FiscalCode is right identification for persons (real
world instances) in each local database, and that such identification constraint on
local databases is explicitly expressed in the local schema definition. But if we now
define explicitly such identity constraint over global schema, we would (possibly) ob-
tain an inconsistent database, i. e., a database with empty set of models.
Usually, during the design phase of an application database we try to render ex-
plicit all user constraint by means of integrity constraints over a database. Here, we
consciously reject such a method: we do not impose any constraint over the global
schema, thus the explicit (formal, or system) constrains are always satisfied but the
implicit (user) constraints are not satisfied. Just because of such problems, in Cooper-
ative Information Systems (CIS) it has been introduced auxiliary quality “dimensions”
information. Such added information would be used during query-answering process,
in order to satisfy this implicit user requirement also: in the case when more than one
tuple of data, for the same real world entity, are returned by the certain answer, the
record matching algorithm has to provide the unique record (with the best quality) to
the user. Thus, this matching algorithm, is an alternative “external-to-DBtheory” way
(w. r. t. the explicit “internal” integrity constraint over database) to guarantee the sat-
isfaction of this fundamental user implicit requirement.

6.3 Belnap’s 4-valued P2P data integration with incomplete and inconsistent data
|
367
In the rest of this section, we will show that also in such setting, the obtained
database system, while formally (explicitly) consistent, remains again implicitly “in-
consistent” (more than one records for the same real world entity may happen in the
query answering). There are two questions in order to resolve such impasse:
–
The first is to consider all records of the cluster not as true but as possible answers.
In this case, we abandon the strict 2-valued logic and assume the more flexible
4-valued Belnap’s logic.
–
The second is to abandon the query-answering semantics and to accept other dif-
ferent principle: “creating the best-answering” principle. Shortly, the cluster of
records in the certain answer to the query, related to the same real world entity, is
used to create a new, in some way best-quality, or more-true, record. In this case,
we must consider the databases with partial orders (e. g., the truth ordering of the
lattice of truth values) and develop a query language for such databases.
Because of this problem it is necessary to give a formal definitions in order to dis-
tinguish these two query-answering approaches: the query answering from the best-
answer creation. This approach is reasonable if CIS is composed by different epistem-
ically independent peer-databases (as two independent databases of INPS and CoC in
Example 39), so that we obtain the P2P where each of them is a single Data integration
system with the Belnap’s multivalued logic. The interpeer mappings can be defined
by intensionally equivalent views, in the way as described the query-answering in the
P2P database systems (see Sections 3.2 and 3.2.3) by classic two-valued FOL in Chap-
ter 3. So, we need to define the intensional equivalence “≈” between P2P databases
(see Corollary 3 in Section 1.3) but in the many-valued logic framework.
Because of that we can enrich the many-valued intensional FOL ℒin by an exis-
tential modal operator “♦,” and hence its Kripke semantics in Definition 82 will be
enlarged by the new accessibility relation ℛ◊and many-valued satisfaction as follows.
Proposition 33 (MV intensional equivalence). We enrich the many-valued intensional
logic ℒin by the existential modal operator ♦, by enlarging its Kripke’s interpretation ℳ
in Definition 82 by new accessibility relation ℛ♦=def 𝒲× 𝒲, such that for any world
(w, g) ∈𝕎= 𝒲× 𝒟𝒱ℬwith w = I∗
mv ∈𝒲,
ℳ󳀀󳨐w,g ♦ϕ
iff
exists w′ ∈𝒲, (w, w′) ∈ℛ♦and ℳ󳀀󳨐w′,g ϕ,
(6.37)
and hence we define the many-valued intensional equivalence “≈” between two virtual
predicates ϕ and ψ with the same tuple of free variables x = (x1, . . . , xn), analogously to
(1.11),
ϕ(x1, . . . xn) ≈ψ(x1, . . . xn)
iff
♦ϕ(x1, . . . xn) ⇔♦ψ(x1, . . . xn)
(6.38)
So, any two first-order open formulae, ϕ(x1, . . . xn) and ψ(x1, . . . xn), are intensionally
equivalent iff ̂♦ϕ(x1, . . . xn) and ̂♦ψ(x1, . . . xn) are intensionally equal.

368
|
6 Applications of many-valued intensional first-order logic
Proof. We have that for any explicit possible world (MV-interpretation) w′ = I∗
mv ∈𝒲,
corresponding to the many-valued interpretation I′
mv,
In(̂♦ϕ(x1, . . . , xk))(w′)
= 󵄩󵄩󵄩󵄩♦ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩ℳ,w′
(from (5.36) and (5.40))
= {(g(x1), . . . , g(xk), g(xB)) | g ∈𝒟𝒱ℬand g(xB) = I′
mv(♦ϕ/g)
̸= f }
(from (5.31))
= {(g(x1), . . . , g(xk), g(xB)) | g ∈𝒟𝒱ℬ, g(xB)
̸= f and ℳ󳀀󳨐w′,g ̂♦ϕ(x1, . . . , xk)}
(from (5.39))
= {(g(x1), . . . , g(xk), g(xB)) | g ∈𝒟𝒱ℬ, g(xB)
̸= f and exists w ∈𝒲
such that (w′, w) ∈ℛ♦= 𝒲× 𝒲and ℳ󳀀󳨐w,g ϕ(x1, . . . , xk)}
(from (6.37))
= {(g(x1), . . . , g(xk), g(xB)) | g ∈𝒟𝒱ℬ, g(xB)
̸= f and exists w ∈𝒲
with ℳ󳀀󳨐w,g ϕ(x1, . . . , xk)}
= ⋃
w∈𝒲
{(g(x1), . . . , g(xk), g(xB)) | g ∈𝒟𝒱ℬ, g(xB)
̸= f and ℳ󳀀󳨐w,g ϕ(x1, . . . , xk)}
= ⋃
w∈𝒲
󵄩󵄩󵄩󵄩ϕ(x1, . . . , xk)󵄩󵄩󵄩󵄩ℳ,w′
= ⋃
w∈𝒲
In(ϕ(x1, . . . , xk))(w).
That is, the intension of ♦ϕ(x1, . . . xn), i. e., In(ϕ(x1, . . . , xk)) : 𝒲→Rm, is a constant
function (which does not depend on explicit possible world w ∈𝒲).
Thus, ϕ(x1, . . . xn) and ψ(x1, . . . xn) are intensionally equivalent if
⋃
w∈𝒲
In(ϕ(x1, . . . , xk))(w) = ⋃
w∈𝒲
In(ψ(x1, . . . , xk))(w),
i. e.,
if In(♦ϕ(x1, . . . , xk))(w) = In( ♦ϕ(x1, . . . , xk))(w)
for every world w ∈𝒲,
i. e.,
if ♦ϕ(x1, . . . xn) and ♦ψ(x1, . . . xn)
are intensionally equal.
It is easy to verify that the definition of the many-valued intensional equivalence
(6.38) is just a generalization of the two-valued intensional equivalence (1.11), where
the two-valued logic equality “≡” is substituted by the many-valued “⇔” version.
Moreover, it is easy to show that
ℳ󳀀󳨐w,g ♦ϕ(x1, . . . xn) ⇔♦ψ(x1, . . . xn)
iff
∃w, w′ ∈𝒲,
ℳ󳀀󳨐w,g ϕ(x1, . . . xn) and ℳ󳀀󳨐w′,g ψ(x1, . . . xn),
that is,
iff
ℳ󳀀󳨐w,g ϕ(x1, . . . xn)
implies ∃w′ ∈𝒲such that ℳ󳀀󳨐w′,g ψ(x1, . . . xn).
So, we are able to use the query-answering in the P2P database systems in this many-
valued framework based on Belnap’s bilattice ℬ4, based on the query-rewriting algo-
rithms used in Chapter 3 for the two-valued FOL.

6.3 Belnap’s 4-valued P2P data integration with incomplete and inconsistent data
|
369
A more general information of the meaning of possible logic value in the frame-
work of logic programming for databases with inconsistent information is given in
[279]. In this way, we consider the possible value as weak true value and not as in-
consistent (that is both true and false). We have more knowledge for record with such
value, w. r. t. the true record, because we know also that there are other records in
database, which are different from this one but are referred to the same real world en-
tity, and the user query which extracts such real world entity from a database must
also retrieve all records referred to it, in order to obtain complete answer.
In effect, by using the many-valued logic based on the Belnap’s bilattice, each peer
database in a network of P2P databases used in CIS will respond by a set of records, so
the union of the records obtained from all these peer databases will not be only many-
valued but also we will have two records obtained from two different peer databases
refer to the same real world entity. Because of that, this union of records obtained as
query-answer from different peer databases will be called the preanswers, and in CIS
we will need also some kind of filtering of them, in order to chose the best candidate
record from the cluster of record that refer the same real world entity. By such a post-
query-answering process of filtering we will obtain the desired result in which we will
have that for any real world entity there is only one and the best quality record in the
query answer. This post query filtering of the query preanswer will be analyzed in the
next sections.
6.3.1 Filtering query preanswers: real world identity constraint
As we have explained, the preanswer obtained as a union of records (obtained as the
simple union of query answers to given user query from different peer databases in a
given CIS P2P system, by using the MV-intensional equivalences between views of dif-
ferent peers) needs, as counterpart, the record matching algorithms during the query
answering processing, in order to select (for each cluster of many-valued answers to
a query from different peer databases in a given P2P system) at maximum one record
for a real world entity underlined in the query.
We recall (see Section A.6.4) that each peer database is a DIS (ℐ, 𝒟) where ℐ=
⟨𝒢, 𝒮, ℳ⟩is a data integration system with global schema ℳ, source schema 𝒮and
GLAV mapping ℳbetween them, and 𝒟be a source database for ℐ. Given a user query
q(x) the answered records will be many-valued: an answered record will be “possible”
answer (with logic value ⊤∈ℬ4) if from two different source data of 𝒮we obtain
mutually inconsistent answers; will be “unknown” answer (with logic value ⊥∈ℬ4)
if we have Skolem constants in this record; otherwise the true record (with logic value
t ∈ℬ4).
The preanswers q(x)ℐ,𝒟defined in precedence will has to be successively filtered
in order to avoid to have more records associated by user to the same real world entity.
Thus, all DaQuinCIS database systems hidden some part of preanswers, q(x)ℐ,𝒟, in

370
|
6 Applications of many-valued intensional first-order logic
order to satisfy the implicit (user’s) real world identity constraint. If we consider such
constraint at epistemic (user’s) meta-level, the following two logic principles must be
satisfied:
1.
Epistemic consistency: at maximum one record for a real world entity can be con-
tained in the answer.
2.
Epistemic completeness: the filtered answers has to contain a record for every real
world entity referred by model-theoretic answers.
The first principle is clear and discussed in precedence. The second is more complex
to understand: roughly, it has to guarantee to users that every real world entity, which
satisfies the user query, in a given logic theory of DaQuinCIS, must be represented at
the answer by one record. For instance, such logic principle is not satisfied by the al-
gorithm for querying for best quality data in a LAV (Local as view) integration system,
[280], thus, it is not a query-answering system: it is based on data integration system
but needs some other formal logic semantics in order to define what is the meaning of
their answers to user queries.
Let us try now to give a general logical/mathematical framework for the semantics
of query answering, which satisfy also epistemic principles defined in precedence.
Let |x| denote the number of variables (attributes) of the query q(x), and the set
Sk = {i | 1 ≤i ≤k}, so that S|x| = {1, 2, . . . , |x|}. Thus, we introduce the functional
space, 2space = {{0, 1}Sk | k = 1, 2, . . .}, such that each element fk ∈2space is a function
fk : Sk →{0, 1} for some k ≥1. Thus, we can define the choice of the matching key
algorithm, Ωmkey, such that for any given preanswer q(x)ℐ,𝒟returns with the matching
key set of attributes xID, as follows.
Definition 97. Let ℒQ denote the set of all queries, 𝒟Q
I the set of all DaQuinCIS P2P
systems, and 𝒫(V) the powerset of all variables in ℒQ. Then the choice of the matching
key algorithm can be defined as the function Ωmkey : ℒQ × 𝒟Q
I →𝒫(V), such that for
any query q(x) ∈ℒQ and DaQuinCIS system (ℐ, 𝒟) ∈𝒟Q
I ,
xID = Ωmkey(q(x), (ℐ, 𝒟)) ⊆x,
where xID is the obtained matching key, thus a subset of all attributes x of the
query.
Notice that in the case when in a data integration systems ℐare defined ID-
attributes for their concepts in global and local schemas (e. g., when global schema
is defined as the universal relation [281]), the function Ωmkey does not depend by
the second argument, i. e., its λ-abstraction, function Λ(Ωmkey) : 𝒟Q
I →𝒫(V)ℒQ is a
constant mapping, where Λ is the currying operator from lambda calculus used in
diagram A.10 in Section A.5. In this case, the matching key is defined directly from
ID-attributes used in the query q(x).

6.3 Belnap’s 4-valued P2P data integration with incomplete and inconsistent data
|
371
Example 40. In [282], it is proposed to exploit quality data exported by each cooper-
ating organization in order to automatically choose the matching key. The idea is to
choose a high “quality” key. Let us consider as an example the choice of a key with a
low completeness value; after a sorting on the basis of such a key, the potential match-
ing records can be not close to each other, due to null values. Similar considerations
can be made also in the case of low accuracy or low consistency of the chosen key; a
low accurate or low consistent key does not allow to have potential matching records
close to each other. Therefore, we evaluate the quality of the matching key in terms
of accuracy, consistency and completeness. Besides quality of data, the other element
influencing the choice of the key is the identification power.
The Identification Power IPj of the field j is defined as
Number of eqj Classes
Total Number of Records
where eqj Classes are the equivalence classes originated by the relation eqj applied to
the totality of records: given two records (tuples) r1 and r2, and given a field j of the
two records, we define the equivalence relation eqj such that
r1 eqj r1
iff
πj(r1) = πj(r2),
i. e., the values of the field j of the records r1 and r2 are equal.
The data quality parameter called “Data Quality of the field j” (DQj) represents
an overall quality value for the field j and can be calculated in different ways. As an
example, in [282], we calculate (DQj) as a linear combination of accuracy, consistency
and completeness values for the field j, where the coefficients were experimentally
determined.
Given the overall quality value DQj and the identification power IPj, we introduce
the parameter Kj equal to multiplication of DQj and IPj.
Let us consider all the fields j of records, different from the last field containing
the logic value of this record, the steps to calculate the matching key are the following
ones:
–
Computation of the Data Quality DQj of the field j.
–
Computation of the Identification Power IPj of the field j.
–
Computation of the parameter Kj = DQj ⋅IPj.
–
Selection of the matching key as max {Kj}.
The selection of a set of fields to construct the key is also possible and the computation
of the data quality and the identification power can be easily extended to such cases.
In this way, the algorithm for function Ωmkey is well-defined.
When we obtain matching key for a given query q(x) over DaQuinCIS database
system, we are ready to consider matching method in order to obtain a partition of

372
|
6 Applications of many-valued intensional first-order logic
records (set of clusters), each one consisting of records referring to the same world
entity.
Example 41. Usually a matching decision is based on a specific edit distance function;
string or edit distance functions consider the amount of difference between strings of
symbols. We can chose the Levenshtein distance [283], which is a well-known early
edit distance where the difference between two text strings is simply the number of
insertions, deletions or substitutions of letters to transform one string into another.
The function we use for deciding if two strings S1 and S2 are the same is also de-
pendent from the lengths of the two strings as follows:
f (S1, S2) = max(length(S1), length(S2)) −LD(S1, S2)
max(length(S1), length(S2))
According to such a function, we normalize the value of the Levenshtein distance
LD(S1, S2) by the maximum between the lengths of the two strings, i. e., the function f
is 0 if the strings are completely different, 1 if the strings are completely equal.
The procedure we propose to decide if two records match each other is the follow-
ing:
–
the function f is applied to the values of a same field in the two records. If the
result is greater than a fixed threshold T1, the two values are considered equal; we
call T1 field the similarity threshold. It is fixed experimentally.
–
If the number of equal pairs of values in the two records is greater than a thresh-
old T2, then the two records are considered as match; we call T2 record the simi-
larity threshold. It is fixed experimentally.
Let now try to give an abstract definition for matching algorithm.
Definition 98 (Matching algorithm for partition of preanswers). The matching algo-
rithm for a DaQuinCIS system (ℐ, 𝒟) ∈𝒟Q
I with the set of queries ℒQ over it (with
the set V of all free variables in ℒQ) can be given by the following function: Match :
ℒQ × 𝒫(V) × Rm × Rm →{0, 1}, such that for a query q(x) ∈ℒQ, tuple of variables
y ∈𝒫(V) and records r1, r2 ∈Rm, we have that
Match(q(x), y, r1, r2) = { 1,
if y = xID, r1, r2 ∈q(x)ℐ,𝒟and r1 ≈r2
0,
otherwise
(6.39)
where xID = Ωmkey(q(x), (ℐ, 𝒟)) ⊆x, q(x)ℐ,𝒟is the query preanswer in the DaQuinCIS
system (ℐ, 𝒟) and r1 ≈r2 means that they refer the same real world entity (are in the
same cluster).
By λ-abstraction, we obtain the function Λ(Match) : ℒQ × 𝒫(V) →{0, 1}Rm×Rm,
so that for a given query q(x) we obtain the derived matching function
Matchq(x) = Λ(Match)(q(x), Ωmkey(q(x), (ℐ, 𝒟))) : q(x)ℐ,𝒟× q(x)ℐ,𝒟→{0, 1}.

6.3 Belnap’s 4-valued P2P data integration with incomplete and inconsistent data
|
373
The meaning of this abstraction is that the reduced function Matchq(x) contains implic-
itly all data quality “dimensions” (metadata), necessary to compare any two records
r1, r2 ∈q(x)ℐ,𝒟in order to decide if they are referred to the same real-world entity. For-
mally, only this functional abstractions deal with metadata knowledge of DaQuinCIS
database systems, their semantics represent the metadata of DaQuinCIS, i. e., we may
consider that metadata are encapsulated into such functional abstractions. So, for any
given query q(x) over DaQuinCIS database system (ℐ, 𝒟), and for any two records in
the pre-answer, r1, r2 ∈q(x)ℐ,𝒟⊆Rm, they are in the same cluster,
t1 ≈t2
if Matchq(x)(r1, r2) = 1.
In the simplest case when the functional abstraction Matchq(x) does not depend of
the metadata (quality dimensions), then it is the characteristic function of the equal-
ity |r1|xID = |r2|xID, r1, r2 ∈q(x)ℐ,𝒟, where |r|xID denotes a projection of the record r
on attributes in xID. Now we will introduce the following quality preorders, different
from that in [275] in the 2-valued framework, for the many-valued logic framework of
database peers in the CIS based on the Belnap’s bilattice ℬ4.
Definition 99 (Quality preorder between tuples in query preanswers). We define the
quality function by Qual : ℒQ × 𝒟Q
I × Rm →ℝ, where ℝis a set of real numbers,
such that for a given query q(x) ∈ℒQ, a DaQuinCIS system (ℐ, 𝒟) ∈𝒟Q
I , and any two
records r1, r2 ∈Rm, with k = |x| + 1,
Qual(q(x), (ℐ, 𝒟), r1) < Qual((ℐ, 𝒟), r2)
iff
r1, r2 ∈q(x)ℐ,𝒟
with
πk(r1) = πk(r2),
Matchq(x)(r1, r2) = 1 and r2 has better computed quality than r1.
So, we are able to define the total quality preorder between the tuples in any cluster
of the query preanswer q(x)ℐ,𝒟with number k = |x| + 1 of query free variables, for any
two r1, r2 ∈q(x)ℐ,𝒟with Matchq(x)(r1, r2) = 1, by
r1 ⪯r2
iff
{
{
{
{
{
πk(r1) <t πk(r2), or
πk(r1) = ⊥and πk(r2) = ⊤, or
πk(r1) = πk(r2) and Qual(q(x), (ℐ, 𝒟), r1) ≤Qual((ℐ, 𝒟), r2)
(6.40)
where “<t” is the truth-order in the Belnap’s bilattice ℬ4.
Note that for each record in query preanswer, r ∈q(x)ℐ,𝒟, with k = |x| + 1, we
have that its last field contains a logic value of this record, with πk(r) ∈{t, ⊥, ⊤} ⊂ℬ4,
so that quality preorder “⪯” in the clusters of this preanswer is generated by the truth
and knowledge orders in Belnap’s billatice, and only when both record have the same
truth value we need also the computation of the quality Qual(q(x), (ℐ, 𝒟), r) in order
to define “⪯.” The most simple way to compute this quality is to assign to any peer
database the unique level of its data quality w. r. t. all other peers, because if we have

374
|
6 Applications of many-valued intensional first-order logic
in any cluster two records with the same truth value these two records are obtained as
query answers from two different peers.
Now we are ready to give the formal definition for the semantics of a query an-
swering in DaQuinCIS database systems.
Corollary 28 (Filtering preanswers by their quality preorders). For any query q(x) ∈
ℒQ and DaQuinCIS system (ℐ, 𝒟) ∈𝒟Q
I , the quality preorder “⪯” in each cluster of the
query preanswer q(x)ℐ,𝒟is a total preorder.
Consequently, by using this quality preorders in each cluster, we can extract the best
quality record, and hence we obtain a perfectly filtered answers that satisfy both epis-
temic constraints: consistency and completeness.
We will denote this filtering algorithm by a mapping malg : Rm →Rm, such that for
a query preanswer q(x)ℐ,𝒟, the perfectly filtered answer is equal to malg(q(x)ℐ,𝒟).
Proof. It is easy to verify that “⪯” is really a preorder, so that for any r ∈q(x)ℐ,𝒟, from
the third line in (6.40), we obtain that r ⪯r. Moreover, for each cluster from the fact
that πk(r) ∈{t, ⊥, ⊤} ⊂ℬ4 with ⊥<t t and ⊤<t t, for each two record of a given cluster
at least one of the three conditions in (6.40) is satisfied.
Thus, at each cluster we have a uniquely determined best quality record, and
hence at maximum one record for a real world entity (corresponding to a given cluster
in q(x)ℐ,𝒟) we will have for the user, after this filtering of the query preanswer. From
the fact that each real world entity corresponds to some cluster in the query preanswer
and that by filtering we obtain the best record for each cluster, and also the epistemic
completeness is satisfied.
In next section, we will provide for this filtering process, based on the quality pre-
order “⪯,” over a query preanswer, the equivalent logic form of the user’s query, such
that filtered query answer corresponds to the satisfaction of this new logic formulae
(obtained by an epistemic modification of the original user’s query).
6.3.2 Modal query language for databases with a partial order
The Abstract Object Type (AOT) for a query-answering system of a CIS for a computa-
tion of query preanswers from the P2P many-valued database system, can be repre-
sented by the coalgebra provided in Definition 133 in Section A.6.2 in the Appendix,
by substitution ℒA 󳨃→ℒQ, ϒ 󳨃→Rm and XA is a hidden sort (a set of internal states of
the CIS).
So, the AOT for a query-answering system of a CIS together with the external algo-
rithm malg : Rm →Rm for the query preanswers in Corollary 28, can be represented
by the following filter-process coalgebra:
α = ⟨Λ(NextQ), malg ∘Λ(OutQ)⟩: XA →XℒQ
A
× RmℒQ
(6.41)

6.3 Belnap’s 4-valued P2P data integration with incomplete and inconsistent data
|
375
where Λ is the currying operator from lambda calculus used in diagram A.10 in Sec-
tion A.5.
Such database with external software (algorithm malg) can be equivalently rep-
resented as an AOT for a database with a partial order⪯(obtained by embedding of
the algorithm malg into a database logic theory), denoted by “A+ ⪯,” and given by a
following logically query-modified coalgebra:
β = ⟨Λ(NextmQ), Λ(OutmQ)⟩: XA+⪯→XℒmQ
A+⪯× RmℒmQ
(6.42)
of the polynomial endofunctor ( _ )ℒmQ × RmℒmQ : Set →Set, where ℒmQ is the set of
all modified conjunctive queries, ℒmQ = {󳶚q(x) | q(x) ∈ℒQ}, so that 󳶚q(x)ℐ,𝒟denotes
the set of filtered answers equal to malg(q(x)ℐ,𝒟). The set of internal states of this AOT
is defined by XA+⪯= {s ⋃R⪯| s ∈WA}, where R⪯denotes the partial ordered set with,
(r1, r2) ∈R⪯iff r2 ⪯r1, which is an invariance (i. e., it holds in all internal states of AOT
system).
We denote by ≃A: XA →XA+⪯this bijection between these two sets of states.
The idea is to obtain the behavioral equivalence of these two AOT’s: that is, the
original CIS P2P database, for a given conjunctive query q(x) in the first step computes
the query preanswer q(x)ℐ,𝒟, and successively filtered answer malg(q(x)ℐ,𝒟), while the
AOT of a database with hidden internal states A+ ⪯computes the (equivalent) answer
to the modified logic formula 󳶚q(x).
Example 42. It is easy to verify [275] that, for the Example 59 in Section A.5.2 in the
Appendix, 󳶚q(x) is equivalent to the modified query formula q(x) ∧∀x′.((q(x′) ∧x ⪯
x′) ⇒x′ ⪯x), so that the semantics of the operator 󳶚corresponds to the mapping
malg, i. e.,
[󳶚] = malg.
Proposition 34. The following commutative diagrams represent the behavioral equiv-
alence for AOT’s of a CIS P2P database system with external and embedded algorithm
malg of Corollary 28, respectively,
XA × ℒQ
⟨NextQ, OutQ⟩? XA × Rm
(XA
α ? XℒQ
A
× RmℒQ)
XA+⪯× ℒmQ
≃A ×󳶚
?
⟨NextmQ, OutmQ⟩? XA+⪯× Rm
≃A ×malg
?
(XA+⪯
≃−1
A
?
β? XℒmQ
A+⪯× RmℒmQ)
γ = γ1 × γ2
?
where the coalgebras α and β are given by (6.41) and (6.42), respectively, and:
–
γ1 : XℒQ
A
→XℒmQ
A+⪯is defined for each f : ℒQ →XA, we take function γ1(f) = f1 :
ℒmQ →XA+⪯such that for each 󳶚q(x) ∈LmQ, f1(󳶚q(x)) =≃A (f(q(x)));

376
|
6 Applications of many-valued intensional first-order logic
–
γ2 : RmℒQ →RmℒmQ is defined for each function l : ℒQ →Rm, we take function
γ2(l) = l1 : ℒmQ →Rm such that for each 󳶚q(x) ∈LmQ, l1(󳶚q(x)) = l(q(x));
So, for any filter-processing coalgebra α, its behaviorally-equivalent query-modified
coalgebra (generated by different functor) is β = γ ∘α ∘≃−1
A determined by the second
commutative diagram.
This behavior-equivalence can be also represented by the isomorphism between
coalgebras ≃A: (XA, α) ≃(XA+⪯, δ), where δ = θ ∘β, of the polynomial functor Tc =
( _ )ℒQ × RmℒQ : Set →Set for the language of conjunctive queries ℒQ, and the mapping
θ = θ1 × θ2 : XℒmQ
A+⪯× RmℒmQ →Tc(XA+⪯) where:
–
θ1 : XℒmQ
A+⪯→XℒQ
A+⪯is defined for each f : ℒmQ →XA+⪯, we take function θ1(f) = f1 :
ℒQ →XA+⪯such that for each q(x) ∈LQ, f1(q(x)) = f(󳶚q(x));
–
θ2 : RmℒmQ →RmℒQ is defined for each function l : ℒmQ →Rm, we take function
θ2(l) = l1 : ℒQ →Rm, such that for each q(x) ∈LQ, l1(q(x)) = l(󳶚q(x)).
Proof. Notice that in the right commutative diagram, the horizontal arrows α and β
represents these two equivalent AOT’s, for database with external algorithm and the
“encapsulated” database with embedded algorithm, respectively, such that for any
state of database s ∈XA, and the conjunctive query q(x) ∈ℒQ, we obtain that for a two
bisimilar states (s, s1), i. e., s1 =≃A (s) ∈XA+⪯:
s′
1 =≃A (s′),
where
s′ = NextQ(s, q(x)) = Λ(NextQ)(s)(q(x))
and
s′
1 = NextmQ(s1, 󳶚q(x)) = Λ(NextmQ)(s1)(󳶚q(x))
are two next (bisimilar) states of these two AOTs, and
malg(OutQ(s, q(x))) = malg(Λ(OutQ)(s)(q(x))) = OutmQ(s1, 󳶚q(x))
= Λ(OutmQ)(s1)(󳶚q(x))
are identical observations (i. e., answers to user queries).
Let verify the second part of the proposition. The first commutative diagram can
be equivalently represented by the following commutative diagram:
XA × ℒQ
⟨NextQ, OutQ⟩? XA × Rm
id × malg
? XA × Rm
XA+⪯× ℒmQ
≃A ×󳶚
?
⟨NextmQ, OutmQ⟩
? XA+⪯× Rm
≃A ×id
?

6.3 Belnap’s 4-valued P2P data integration with incomplete and inconsistent data
|
377
The horizontal arrow above corresponds to the AOT of the original CIS P2P database
system and represents the two-step query computation: the first step computes query
preanswer to the conjunctive query and then is applied the filtering algorithm malg
(external to the logic theory of CIS); while the horizontal arrow below corresponds to
the AOT of query answering of the CIS based on the query-modification taking in con-
sideration the quality preorder ⪯in Definition 99. From this diagram, by λ-abstraction
(currying) we obtain the following commutative diagram:
XA
α? XℒQ
A
× RmℒQ = Tc(XA)
(XA, α)
XA+⪯
≃A
?
δ
? XℒQ
A+⪯× RmℒQ = Tc(XA+⪯)
Tc(≃A)
?
(XA+⪯, δ)
≃A
?
where δ = θ ∘β = ⟨Λ(NextmQ ∘(id ×󳶚)), Λ(OutmQ ∘(id ×󳶚))⟩and Tc(≃A) = (≃A ∘_) × id.
This diagram is the isomorphism (bijective homomorphism) ≃A:
(XA, α)
→
(XA+⪯, δ) between two coalgebras of the polynomial functor Tc = ( _ )ℒQ × RmℒQ :
Set →Set.
We need that for the “best answering,” w. r. t. the given partial order ⪯and user
defined conjunctive query q(x), is satisfied the following condition:
󳶚q(x)ℐ,𝒟= malg(q(x)ℐ,𝒟).
Now we will show that the semantics of the syntax symbol 󳶚corresponds to the modal
logic operator, so that ℒmQ is the modal query language. We begin from the fact that
for any given CIS (ℐ, 𝒟) with set of records X ⊂Rm, the couple (X, R⪯), with R⪯⊆X2,
corresponds to the frame with X the set of worlds, and partial order R⪯its accessibility
relation.
Definition 100. We define the set of all views (preanswers) ϒ of given CIS (ℐ, 𝒟), and
the set of all tuples (records) X, which can be obtained from a CIS P2P database (ℐ, 𝒟),
as follows:
ϒ = {q(x)ℐ,𝒟| q(x) ∈ℒQ},
X =
⋃
w∈ϒ𝒟ℬ
w.
The frame (X, R⪯), with R⪯⊂X2, can be represented by the coalgebra γ : X →𝒫(X),
where 𝒫is a powerset operation (moreover, it is powerset functor 𝒫: Set →Set) and
for any r ∈X ⊂Rm, γ(r) is the set of all successors of the world (record) r (i. e., the set
of all r′ such that (r, r′) ∈R⪯, or, equivalently, r′ ⪯r).
For any subset Y ⊆X of the partially ordered set (poset) X, we denote by ⋁Y the
subset of all Least Upper Bounds (lub’s) in Y.

378
|
6 Applications of many-valued intensional first-order logic
Example 43. It is easy to verify that for any conjunctive query q(x) for its preanswer
w = q(x)ℐ,𝒟∈ϒ, we have that ⋁w = ⋁q(x)ℐ,𝒟= malg(q(x)ℐ,𝒟).
That is, in our framework the “best answers” filtering algorithm malg is an opera-
tion, which extracts only lub’s of the conjunctive-query preanswer.
The idea that the functor of a coalgebra determines a certain modal logic was first
put forward by Moss [284]. He developed it for very general functors, namely those
which admit the existence of the initial algebra, however, it is lack of abstract syntax.
Here, we will use the other approach [285, 286] based on Kripke polynomial functors:
Multimodal logic for coalgebras, which utilize predicate lifting to interpret modalities
(interested reader can find a short overview in Section A.5.2 of the Appendix).
Definition 101. Based on Definition 100, we define a partial-bounded set of successors
for a frame (X, R⪯) by the following mapping: l : X × ϒ →𝒫(X) such that for any point
(record) r ∈X and the query preanswer w ∈ϒ ⊆𝒫(X), (thus w ⊆X), holds that
l(r, w) = { γ(r) ⋂w,
if r ∈⋁w
X,
otherwise
(6.43)
We denote by Λ(l) its λ-abstraction (curring), Λ(l) : X →𝒫(X)ϒ. It is a coalgebra
(X, Λ(l)) with a carrier set X, of the functor T = 𝒫( _ )ϒ : Set →Set.
Based on this definition, and point 4 of Definition 131 in Section A.5.2 in the Ap-
pendix, we have the following property.
Proposition 35 (Modal operator for filtering). The operator 󳶚is a next time modal op-
erator defined for any conjunctive query q(x), and w = q(x)ℐ,𝒟∈ϒ by the path p =
eval(w) ⋅𝒫: 𝒫( _ )ϒ 󴁄󴀼Id, so that
[eval(w) ⋅𝒫](w) = (Λ(l))
−1 ∘( _ )eval(w)⋅𝒫(w) = malg(w)
(6.44)
Thus, by generalization, we obtain the interpretation of the modal operator 󳶚, restricted
to a subset ϒ ⊆𝒫(X), given by
[󳶚] = (Λ(l))
−1 ∘( _ )eval( _ )⋅𝒫: ϒ →𝒫(X)
(6.45)
Proof. For any preanswer w ∈ϒ, thus, w ⊂X, we have that
[eval(w) ⋅𝒫](w)
= (Λ(l))
−1 ∘( _ )eval(w)⋅𝒫(w)
from (A.11) in Definition 132 in the Appendix:
= (Λ(l))
−1((w)eval(w)⋅𝒫) = (Λ(l))
−1(𝒫(w))
eval(w)
= (Λ(l))
−1({f | f (w) ∈𝒫(w)})
from point 4 in Definition 132, Section A.5.2 in the Appendix:

6.3 Belnap’s 4-valued P2P data integration with incomplete and inconsistent data
|
379
= {x | Λ(l)(x) ∈{f | f(w) ∈𝒫(w)}}
= ⋁w,
from the fact that x ∉⋁w iff Λ(l)(x)(w) = l(x, w) = X ∉𝒫(w)
= malg(w).
Corollary 29. The query formulae for a databases enriched with partial order (by an
embedded best-answer filtering algorithm) are the modal logic formulae obtained by
predicate lifting of original conjunctive queries. The answer to such lifted query is equal
to the (by algorithm) filtered answer to the original conjunctive query.
Now, from the fact that 󳶚is the syntax of the (surjective) modal operation 󳶚:
ℒQ →ℒmQ, where the set of modified conjunctive queries, ℒmQ is the image of this
mapping, we can introduce its inverse mapping, denoted by 󳶚−1, such that for any
󳶚q(x) ∈ℒmQ, we obtain that 󳶚−1(󳶚q(x)) = q(x) ∈ℒQ. Thus, the Tc-coalgebra isomor-
phism ≃A: (XA, α) →(XA+⪯, δ), of the polynomial functor Tc = ( _ )ℒQ × ϒℒQ : Set →Set
for the language ℒQ of finite conjunctive queries, can be equivalently, represented
by the coalgebra isomorphism ≃−1
A : (XA+⪯, β) →(XA, δ1), of the “modal” endofunctor
Tm = ( _ )ℒmQ × RmℒmQ : Set →Set for the modal language ℒmQ.
That is, the following commutative diagram holds:
XA × ℒmQ
id × 󳶚−1
? XA × ℒQ
⟨NextQ, malg ∘OutQ⟩? XA × Rm
XA+⪯× ℒmQ
≃−1
A ×id
?
⟨NextmQ, OutmQ⟩
? XA+⪯× Rm
≃−1
A ×id
?
where the horizontal arrow above corresponds to the three steps computation: for a
given modal formula first step, reduce it to the conjunctive query, after that is com-
puted a certain answer for this query on a database A, and it is filtered by the algorithm
malg. From this diagram, by λ-abstraction (curring) we obtain the following commuta-
tive diagram:
XA
δ1
? XℒmQ
A
× RmℒmQ = Tm(XA)
(XA, δ1)
XA+⪯
≃−1
A
?
β
? XℒmQ
A+⪯× RmℒmQ = Tm(XA+⪯)
Tm(≃−1
A )
?
(XA+⪯, β)
≃−1
A
?
where Tm(≃A) = id is the identity and δ1 =≃A ∘β = ⟨Λ(NextQ ∘(id ×󳶚−1)), Λ(malg ∘
OutQ ∘(id ×󳶚−1))⟩.
These two isomorphisms, ≃A: (XA, α) →(XA+⪯, δ), and ≃−1
A : (XA+⪯, β) →(XA, δ1),
represent the behavioral equivalence of these two AOTs: AOT for a original CIS P2P

380
|
6 Applications of many-valued intensional first-order logic
database system with the external-to-database algorithm malg w. r. t. the conjunctive
query language ℒQ, and the AOT for CIS P2P database system with these modal queries
in ℒmQ, respectively.
So, we have proposed a novel formal logic method to the well known and impor-
tant, yet frequently ignored problem of considering the query-answering semantics in
information integration with also filtering algorithms, which restricts the answers to
conjunctive queries in a subset of “best consistent” answers. This problem has not,
to our best knowledge, been adequately addressed before: the developed in practice
software systems are mainly focused in formalization and implementation of their
filtering algorithms, considering that such software systems implicitly support their
particular operational semantics, by a particular developed algorithm, for a query an-
swering of the whole system.
But such discrepancy in the formal logic theory of the database and, external to it,
the software which implements filtering algorithm needs to be improved by the logic:
theoretical considerations in order to provide a model theoretic (denotational) seman-
tics for the query answering.
The formalization of query-answering database systems by mean of abstract
object types is useful for embedding other procedural database features also. Such
abstraction, together with the concept of behavior equivalence for query answering
is a good framework to analyze the model theoretic properties of the whole system,
but also to define the specification for mappings, based on views, between different
database systems, as for example, in complex P2P database systems, where each peer
can be considered as an AOT which possibly encapsulate a database system (thus
all internal structure and application embedded algorithms, of a database peer, are
hidden).

A Appendix
A.1 Introduction to lattices, algebras and propositional logics
Lattices are the posets (partially ordered sets) such that for all their elements a and b,
the set {a, b} has both a join ((lub) least upper bound and a meet (glb) greatest lower
bound) with a partial order ≤(reflexive, transitive and antisymmetric). A bounded
lattice has the greatest (top) and least (bottom) element, denoted by convention as
1 and 0. Finite meets in a poset will be written as 1, ∧and finite joins as 0, ∨. By (W, ≤,
∧, ∨, 0, 1), we denote a bounded lattice iff for every a, b, c ∈W and the following equa-
tions are valid:
1.
a ∨a = a, a ∧a = a (idempotency laws)
2.
a ∨b = b ∨a, a ∧b = b ∧a (commutativity laws)
3.
a ∨(b ∨c) = (a ∨b) ∨c, a ∧(b ∧c) = (a ∨b) ∧c (associativity laws)
4.
a ∨0 = a, a ∧1 = a
5.
a ∨(b ∧a) = a, a ∧(b ∨a) = a (absorption laws).
It is distributive if it satisfies the distributivity laws:
6.
a ∨(b ∧c) = (a ∨b) ∧(a ∨c), a ∧(b ∨c) = (a ∧b) ∨(a ∧c).
A lattice W is complete if each (also infinite) subset S ⊆W (or S ∈𝒫(W) where 𝒫
is the powerset symbol, with empty set 0 ∈𝒫(W)) has the least upper bound (lub,
supremum) denoted by ⋁S ∈W. When S has only two elements, the supremum cor-
responds to the join operator “∨.” Each finite bounded lattice is a complete lattice.
Each subset S has the greatest lower bound (glb, infimum) denoted by ⋀S ∈W, given
as ⋁{a ∈W | ∀b ∈S.a ≤b}. A complete lattice is bounded and has the bottom element
0 = ⋁0 = ⋀W ∈W and the top element 1 = ⋀0 = ⋁W ∈W. An element a ∈W is
compact iff whenever ⋀S exists and a ≤⋀S for S ⊆W, then a ≤⋀S′ for some finite
S′ ⊆W. W is compactly generated iff every element in W is a supremum of compact
elements. A lattice W is algebraic if it is complete and compactly generated.
A function l : W →Y between the posets W, Y is monotone if a ≤a′ implies
l(a) ≤l(a′) for all a, a′ ∈W. Such a function l : W →Y is said to have a right (or upper)
adjoint if there is a function r : Y →W in the reverse direction such that l(a) ≤b iff
a ≤r(b) for all a ∈W, b ∈Y. Such a situation forms a Galois connection and will often
be denoted by l ⊣r. Then l is called a left (or lover) adjoint of r. If W, Y are complete
lattices (posets), then l : W →Y has a right adjoint iff l preserves all joins (it is additive,
i. e., l(a∨b) = l(a)∨l(b) and l(0W) = 0Y where 0W, 0Y are bottom elements in complete
lattices W and Y, respectively). The right adjoint is then r(b) = ⋁{c ∈W | l(c) ≤b}.
Similarly, a monotone function r : Y →W is a right adjoint (it is multiplicative, i. e., has
a left adjoint) iff r preserves all meets; the left adjoint is then l(a) = ⋀{c ∈Y | a ≤r(c)}.
https://doi.org/10.1515/9783110981438-007

382
|
A Appendix
Each monotone function l : W →Y on a complete lattice (poset) W has both a
least fixed-point (Knaster–Tarski) μl ∈W and greatest fixed-point νl ∈W. These can
be described explicitly as μl = ⋀{a ∈W | l(a) ≤a} and νl = ⋁{a ∈W | a ≤l(a)}.
In what follows, we write b < a iff (b ≤a and not a ≤b) and we denote by a⋈b two
unrelated elements in W (so that not (a ≤b or b ≤a)). An element in a lattice c
̸= 0
is a join-irreducible element iff c = a ∨b implies c = a or c = b for any a, b ∈W. An
element in a lattice a ∈W is an atom iff a > 0 and ∄b.(a > b > 0).
A lower set (down closed) is any subset Y of a given poset (W, ≤) such that, for all
elements a and b, if a ≤b and b ∈Y then a ∈Y.
A Heyting algebra is a distributive bounded lattice W with finite meets and joins
such that for each element a ∈W, the function ( _ ) ∧a : W →W has a right adjoint
a ⇀( _ ), also called an algebraic implication. An equivalent definition can be given
by considering a bonded distributive lattice such that for all a and b in W there is a
greatest element c in W, denoted by a ⇀b, such that c ∧a ≤b, i. e., a ⇀b = ⋁{c ∈
W | c ∧a ≤b} (relative pseudo-complement). We say that a lattice is relatively pseudo-
complemented (r. p. c.) lattice if a ⇀b exists for every a and b in W. Thus, a Heyting
algebra is, by definition, an r. p. c. lattice that has 0.
Formally, a distributive bounded lattice (W, ≤, ∧, ∨, 0, 1) is a Heyting algebra iff
there is a binary operation ⇀on W such that for every a, b, c ∈W:
7.
a ⇀a = 1,
8.
a ∧(a ⇀b) = a ∧b, b ∧(a ⇀b) = b,
9.
a ⇀(b ∧c) = (a ⇀b) ∧(a ⇀c).
In a Heyting algebra, we can define the negation ¬a as a pseudo-complement a ⇀0.
Then a ≤¬¬a. Each finite distributive lattice is a Heyting algebra. A complete Heyting
algebra is a Heyting algebra H = (W, ≤, ∧, ∨, ⇀, ¬, 0, 1), which is complete as a poset.
A complete distributive lattice is thus a complete Heyting algebra iff the following in-
finite distributivity holds [287]:
10. a ∧⋁i∈I bi = ⋁i∈I(a ∧bi), for every a, bi ∈W, i ∈I.
The negation and implication operators can be represented as the following monotone
functions: ¬ : W →WOP and ⇀: W × WOP →WOP, where WOP is the lattice with
inverse partial ordering and ∧OP = ∨, ∨OP = ∧.
The following facts are valid in any H:
(H1) a ≤b iff a ⇀b = 1, (a ⇀b) ∧(a ⇀¬b) = ¬a
(H2) ¬0 = 0OP = 1, ¬(a ∨b) = ¬a ∨OP ¬b = ¬a ∧¬b (additive negation), with the
following weakening of classical propositional logic:
(H3) ¬a ∨b ≤a ⇀b, a ≤¬¬a, ¬a = ¬¬¬a
(H4) a ∧¬a = 0, a ∨¬a ≤¬¬(a ∨¬a) = 1 (weakening excluded middle)
(H5) ¬a ∨¬b ≤¬(a ∧b) (weakening of De Morgan laws)

A.1 Introduction to lattices, algebras and propositional logics
|
383
Notice that since negation ¬ : W →WOP is a monotonic and additive operator, it is
also a modal algebraic negation operator. The smallest complete distributive lattice is
denoted by 2 = {0, 1} with twp classic values, false and true, respectively. It is also a
complemented Heyting algebra, and hence it is Boolean.
From the point of view of universal algebra, given a signature Σ with a set of func-
tional symbols oi ∈Σ with arity ar : Σ →𝒩, an algebra (or algebraic structure)
A = (W, ΣA) is a carrier set W together with a collection ΣA of operations on W with
an arity n ≥0. An n-ary operator (functional symbol) oi ∈Σ, ar(oi) = n on W will be
named an n-ary operation (a function) ̂oi : Wn →W in ΣA that takes n elements of W
and returns a single element of W. Thus, a 0-ary operator (or nullary operation) can be
simply represented as an element of W, or a constant, often denoted by a letter like a
(thus, all 0-ary operations are included as constants into the carrier set of algebra).
An algebra A is finite if the carrier set W is finite; it is finitary if each operator in ΣA
has a finite arity. For example, a lattice is an algebra with signature ΣL = {∧, ∨, 0, 1},
where ∧and ∨are binary operations (meet and join operations, respectively), while
0, 1 are two nullary operators (the constants). The equational semantics of a given al-
gebra is a set of equations E between the terms (or expressions) of this algebra (e. g.,
a distributive lattice is defined by the first six equations above).
Given two algebras A = (W, ΣA), A′ = (W′, ΣA) of the same type (with the same
signature Σ and set of equations), a map h : W →W′ is called a homomorphism if for
each n-ary operation ̂oi ∈ΣA and a1, . . . , an ∈W, h(̂oi(a1, . . . , an)) = ̂o′
i(h(a1), . . . , h(an)).
A homomorphism h is called an isomorphism if h is a bijection between respective car-
rier sets; it is called a monomorphism (or embedding) if h is injective function from
W into W′. An algebra A′ is called a homomorphic image of A if there exists a homo-
morphism from A onto A′. An algebra A′ is a subalgebra of A if W′ ⊆W, the nullary
operators are equal and the other operators of A′ are the restrictions of operators of A
to W′.
A subuniverse of A is a subset W′ of W, which is closed under operators of A, i. e.,
for any n-ary operation ̂oi ∈ΣA and a1, . . . , an ∈W′, ̂oi(a1, . . . , an) ∈W′. Thus, if A’ is
a subalgebra of A, then W′ is a subuniverse of A. The empty set may be subuniverse,
but it is not the underlying carrier set of any subalgebra. If A has nullary operators
(constants), then every subuniverse contains them as well.
Given an algebra A, Sub(A) denotes the set of subuniverses of A, which is an al-
gebraic lattice. For Y ⊆W, we say that Y generates A (or Y is a set of generators of A)
if W = Sg(Y) =def ⋂{Z | Y ⊆Z and Z is a subuniverse of A}. Sg is an algebraic closure
operator on W: for any Y ⊆W, let F(Y) = Y ⋃{̂oi(b1, . . . , bk)|oi ∈ΣA and b1, . . . , bk ∈Y},
with F0(Y) = Y, Fn+1(Y) = F(Fn(Y)), n ≥0, so that for finitary A, Y ⊆F(Y) ⊆F2(Y) ⊆
. . . , and consequently, Sg(Y) = Y ⋃F(Y) ⋃F2(Y) ⋃. . . , and from this it follows that if
a ∈Sg(Y), then a ∈Fn(Y) for some n < ω; hence, for some finite Z ⊆Y, a ∈Fn(Z), thus
a ∈Sg(Z), i. e., Sg is an algebraic closure operator.
The algebra A is finitely generated if it has a finite set of generators.

384
|
A Appendix
Let X be a set of variables. We denote by 𝒯X the set of terms with variables x1, x2, . . .
in X of a type Σ of algebras, defined recursively by
–
all variables and constants (nullary functional symbols) are in 𝒯X;
–
if oi ∈Σ, n = ar(oi) ≥1, and t1, . . . , tn ∈𝒯X, then oi(t1, . . . , tn) ∈𝒯X.
If X = 0, then 𝒯0 denotes the set of ground terms. Given a class K of algebras of the
same type (signature Σ), the term algebra (𝒯X, Σ) is a free algebra with universal (ini-
tial algebra) property: for every algebra A = (W, Σ) ∈K and map f : X →W, there
is a unique homomorphism f# : 𝒯X →W that extends f to all terms. Given a term
t(x1, . . . , xn) over X and given an algebra A = (W, ΣA) of type Σ, we define a map-
ping ̂t : Wn →W by: (1) if t is a variable xi then ̂t(a1, . . . , an) = ai is the i-th projec-
tion map; (2) if t is of the form oi(t1(x1, . . . , xn), . . . , tk(x1, . . . , xn)), where oi ∈Σ, then
̂t(a1, . . . , an) = ̂oi(̂t1(a1, . . . , an), . . . ,̂tk(a1, . . . , an)). Thus, ̂t is the term function on A cor-
responding to term t. For any subset Y ⊆W,
Sg(Y) = {̂t(a1, . . . , an) | t is n-ary term of type Σ, n < ω, and a1, . . . , an ∈Y}.
The product of two algebras of the same type A and A′ is the algebra A × A′ = (W ×
W′, Σ×) such that for any n-ary operator ̂
oi,2 ∈Σ× and (a1, b1), . . . , (an, bn) ∈W × W′,
n ≥1, ̂
oi,2((a1, b1), . . . , (an, bn)) = (̂oi(a1, . . . , an), ̂o′
i(b1, . . . , bn)). In what follows, where
there is no ambiguity, we will write oi(a1, . . . , an) for ̂oi(a1, . . . , an) as well and Σ for ΣA
of any algebra A of this type Σ.
Given a Σ-algebra A with the carrier W, we say that an equivalence relation Q on W
agrees with the n-ary operation oi ∈Σ when for n-tuples (a1, . . . , an), (b1, . . . , bn) ∈Wn
we have (oi(a1, . . . , an), oi(b1, . . . , bn)) ∈Q if (ai, bi) ∈Q for i = 1, . . . , n. We say that
equivalence relation Q on a Σ-algebra A is a congruence on A if it agrees with every
operation in Σ. If A is a Σ-algebra and Q a congruence on A, then there exists a unique
Σ-algebra on the quotient set W/Q of the carrier W of A such that the natural mapping
W →W/Q (which maps each element a ∈W into its equivalence class [a] ∈W/Q)
is a homomorphism. We will denote such an algebra as A/Q = (W/Q, Σ) and will call
it a quotient algebra of an algebra A by the congruence Q, such that for each its k-ary
operation ̂o′
i, we have ̂o′
i([a1], . . . , [ak]) = [̂oi(a1, . . . , ak)].
Let K be a class of algebras of the same type. We say that K is a variety if K is closed
under homomorphic images, subalgebras and products. Each variety can be seen as
a category with objects being the algebras and arrows the homomorphisms between
them.
The fundamental Birkhoff’s theorem in universal algebra demonstrates that a
class of algebras forms a variety iff it is equationally definable. For example, the class
of all Heyting algebras (which are definable by the set E of nine equations above), de-
noted by ℋ𝒜= (ΣH, E), is a variety. Arend Heyting produced an axiomatic system of
propositional logic, which was claimed to generate as theorems, precisely those sen-
tences that are valid according to the intuitionistic conception of truth. Its axioms are

A.2 Introduction to deductive logic and binary sequent calculus
|
385
all axioms of the Classic Propositional Logic (CPL) heaving a set of propositional sym-
bols p, q, . . . ∈PR and the following axioms (ϕ, ψ, φ denotes arbitrary propositional
formulae):
(1) ϕ ⇒(ϕ ∧ϕ)
(2) (ϕ ∧ψ) ⇒(ψ ∧ϕ)
(3) (ϕ ⇒ψ) ⇒((ϕ ∧φ) ⇒(ψ ∧φ))
(4) ((ϕ ⇒ψ) ∧(ψ ⇒φ)) ⇒(ϕ ⇒φ)
(5) ψ ⇒(ϕ ⇒ψ)
(6) (ϕ ∧(ϕ ⇒ψ)) ⇒ψ
(7) ϕ ⇒(ϕ ∨ψ)
(8) (ϕ ∨ψ) ⇒(ψ ∨ϕ)
(9) ((ϕ ⇒φ) ∧(ψ ⇒φ)) ⇒((ϕ ∨ψ) ⇒φ) and for negation in CPL:
(10)ϕ ⇒(¬ϕ ⇒ψ)
(11) ((ϕ ⇒ψ) ∧(ϕ ⇒¬ψ)) ⇒¬ϕ
(12) ϕ ∨¬ϕ
except for the 12th axiom of “excluded middle,” which according to constructivist atti-
tude (L. E. J. Brouwer) has to be replaced by “either I have constructively demonstrated
ϕ, or I have constructively demonstrated that ϕ is false,” equivalent to modal formula
◻ϕ ∨◻¬ϕ, where ◻is a “necessity” universal modal operator in S4 modal logic (with
transitive and symmetric accessibility relation between the possible worlds in Kripke
semantics, i. e., where this relation is partial ordering ≤). In the same constructivist
attitude, ¬¬ϕ ⇒ϕ is not valid (different from CLP). According to Brouwer, to say that
ϕ is not true means only that I have not at this time constructed ϕ, which is not the
same as saying ϕ is false.
In fact in Intuitionistic Logic (IL), ϕ ⇒ψ is equivalent to ◻(ϕ ⇒c ψ), i. e., to
◻(¬cϕ∨ψ) where “⇒c” is a classical logical implication and “¬c” is classical negation
and ¬ϕ is equivalent to ◻¬cϕ. Thus, in IL, the conjunction and disjunction are that of
CPL and only the implication and negation are modal versions of classical versions of
the implication and negation, respectively.
A.2 Introduction to deductive logic and binary sequent calculus
The concepts introduced here, based on the work of Tarski, are basic to the develop-
ment of nonmonotonic logic in the rest of the paper.
We assume that a fixed 2-valued (f, false and t, true) object language ℒis given.
The details of ℒare left open, except that it contains the standard connectives, ⇒, ∧, ∨
(material implication, conjunction and disjunction, respectively). Hence, the set ℒ0 of
sentences of ℒis closed under the rules: f ∈ℒ0 ; if ϕ, ψ ∈ℒ0, then ϕ ⇒ψ, ϕ ∧ψ, ϕ ∨
ψ ∈ℒ0. ¬ϕ is taken as an abbreviation of ϕ ⇒f . We use ∀symbol for the “for all”
quantifier, and ∃for the existential quantifier.

386
|
A Appendix
A consequence relation is a binary relation ⊢, which takes a set of sentences Γ ⊆ℒ0
as its first argument and a single sentences ϕ ∈ℒ0 as its second, denoted by Γ ⊢ϕ.
Equivalently, we can define a consequence operation (infinitary) mapping C : 𝒫(ℒ0) →
𝒫(ℒ0) (here 𝒫(ℒ0) denotes the set of all subsets of ℒ0), such that C(Γ) = {ϕ | Γ ⊢ϕ},
and vice versa, Γ ⊢ϕ iff ϕ ∈C(Γ). The finitary version of this operator is a mapping
Cfin : 𝒫fin(ℒ0) →𝒫(ℒ0), where 𝒫fin is a finitary powerset operator. We write C(Γ, Δ)
instead of C(Γ ⋃Δ), and C(ϕ) instead of C({ϕ}). The following table define properties
of the deductive monotonic consequence relation (reflexivity, cut, monotonicity and
compactness):
The finitistic or “Gentzen-style” (Table A.1):
Table A.1: The finitistic or “Gentzen-style”.
ϕ ∈Γ implies Γ ⊢ϕ
Γ ⋃Δ ⊢ϕ, ∀ψ ∈Δ.(Γ ⊢ψ) implies Γ ⊢ϕ
Γ ⊢ϕ, Γ ⊆Δ implies Δ ⊢ϕ
if Γ ⊢ϕ then for some finite Δ ⊆Γ, Δ ⊢ϕ
The infinitistic or “Tarski-style” (Table A.2):
Table A.2: The infinitistic or “Tarski-style”.
Γ ⊆C(Γ)
Δ ⊆C(Γ) implies C(Γ ⋃Δ) ⊆C(Γ)
Γ ⊆Δ implies C(Γ) ⊆C(Δ)
C(Γ) ⊆⋃{C(Δ) | Δ ⊆Γ and Δ is finite}
For example, the classical propositional logic is a deductive logic.
It is easy to verify that C is a closure idempotent operator: for any Γ, we obtain the
closet set, called theory T = C(Γ) = C(C(Γ)).
For Γ, Δ ⊆ℒ0 we shall say that Γ is consistent iff C(Γ)
̸= ℒ0 and that Γ is consistent
with Δ iff C(Γ, Δ)
̸= ℒ0. A set is inconsistent iff it is not consistent.
A set Γ is ℒ-maximal iff is consistent and for every Δ, if Γ ⊆Δ and Δ consistent,
then Γ = Δ.
We denote by ℳL the set of all ℒ-maximal sets, and by 𝒯L the set of all theories in
𝒫(ℒ0), and by |Γ| = {M ∈ℳL | Γ ⊆M} the set of all maximal extensions of Γ.
For any deductive logic, the following properties hold:
1.
Every ℒ-maximal set Γ is a theory (i. e., Γ = C(Γ)).
2.
(Lindenbaum) Every consistent set is included in some ℒ-maximal theory.
3.
If ϕ ∉C(Γ), then there exists a ℒ-maximal theory M such that C(Γ) ⊆M and ϕ ∉M.

A.2 Introduction to deductive logic and binary sequent calculus
|
387
4.
C(Γ) = ⋂|Γ|, i. e., ϕ is a consequence of Γ iff ϕ belongs to every maximal extension
of Γ.
So far, our discussion has been purely syntactical and proof-theoretic. We shall also
suppose that, with the language ℒand the consequence operator C comes a suitable
semantics in the form of a set 𝒲(the universe), the elements of which we shall call
worlds, and the relation ⊨⊆𝒲× 𝒫(ℒ0) of satisfaction between worlds and formulae:
ϕ ∈C(Γ) iff ∀w ∈𝒲.(w ⊨Γ implies w ⊨ϕ).
We will use a deductive logics as underlying logic in order to define the inference
operator for (generally nonmonotonic) query-answering in general data integration
framework in Section 3.2.1.
Binary sequent calculus
It has been developed by Gentzen [288], inspired on ideas of Paul Hertz [289]. Given a
propositional logic language ℒA (a set of logic formulae), a binary sequent is a conse-
quence pair of formulae, s = (ϕ; ψ) ∈ℒA × ℒA, denoted also by ϕ ⊢ψ.
A Gentzen system, denoted by a pair 𝒢= ⟨𝕃, ⊩⟩, where ⊩is a consequence relation
on a set of sequents in 𝕃⊆ℒA × ℒA, is said to be normal if it satisfies the following
conditions: for any sequent s = ϕ ⊢ψ ∈𝕃and a set of sequents Γ = {si = ϕi ⊢ψi ∈𝕃|
i ∈I},
1.
reflexivity: if s ∈Γ, then Γ ⊩s
2.
transitivity: if Γ ⊩s and for every s′ ∈Γ, Θ ⊩s′, then Θ ⊩s
3.
finiteness: if Γ ⊩s, then there is finite Θ ⊆Γ such that Θ ⊩s.
4.
for any homomorphism σ from 𝕃into itself (i. e., a substitution), if Γ ⊩s then
σ[Γ] ⊩σ(s), i. e., {σ(ϕi) ⊢σ(ψi) | i ∈I} ⊩(σ(ϕ) ⊢σ(ψ)).
Notice that from (1) and (2) we obtain this monotonic property:
5.
if Γ ⊩s and Γ ⊆Θ, then Θ ⊩s.
We denote the Tarskian closure operator by C : 𝒫(𝕃) →𝒫(𝕃), such that C(Γ) =def {s ∈
𝕃| Γ ⊩s}, with the properties: Γ ⊆C(Γ) (from reflexivity (1)); it is monotonic, i. e.,
Γ ⊆Γ1 implies C(Γ) ⊆C(Γ1) (from (5)), and an involution C(C(Γ)) = C(Γ) as well. Thus,
we obtain:
6.
Γ ⊩s iff s ∈C(Γ).
Any sequent theory Γ ⊆𝕃is said to be a closed theory iff Γ = C(Γ). This closure property
corresponds to the fact that Γ ⊩s iff s ∈Γ.
Each sequent theory Γ can be considered as a bivaluation (a characteristic func-
tion) β : 𝕃→2 such that for any sequent s ∈𝕃, β(s) = 1 iff s ∈Γ.

388
|
A Appendix
A.3 Autoreferential semantics for many-valued modal logics
In this section, we consider the class of truth-functional modal many-valued logics
with the complete lattice of truth values. The conjunction and disjunction logic oper-
ators correspond to the meet and join operators of the lattices, while the negation is
independently introduced as a hierarchy of antitonic operators, which invert bottom
and top elements. The nonconstructive logic implication will be defined for a subclass
of modular lattices, while the constructive implication for distributive lattices (Heyt-
ing algebras) is based on relative pseudo-complements as in intuitionistic logic. We
show that the complete lattices are intrinsically modal, with a banal identity modal
operator. We define the autoreferential set-based representation for the class of modal
algebras, and show that the autoreferential Kripke-style semantics for this class of
modal algebras is based on the set of possible worlds equal to the complete lattice of
algebraic truth values.
Remark. For many-valued logics, we tell that has an autoreferential Kripke semantics
if the set of possible worlds is the (sub)set of truth values of this MV-logic. We tell
that it is canonical if it is the result of the representation theorem (see Section 5.1 and
Section 5.1.1 for more details).
The philosophical assumption of canonical autoreferential sematics is based on
the consideration that each possible world represents a level of credibility, so that only
propositions with the right logic value (i. e., level of credibility) can be accepted by this
world. Then we connect it with paraconsistent properties and LFI logics. The bottom
truth value in this complete lattice corresponds to the trivial world in which each for-
mula is satisfied, i. e., to the world with explosive inconsistency. The top truth value
corresponds to the world with classical logics, while all intermediate possible worlds
represent the different levels of paraconsistent logics.
The main result of this section is a general way of establishing links between al-
gebraic and Kripke-style semantics for the class of many-valued modal logics based
on a complete lattice of truth values, by introducing autoreferential duality: it means
that we will use as a set of possible worlds in Kripke-style semantics for these modal
logics exactly the lattice of its truth values.
A significant number of real-world applications in artificial intelligence has to deal
with partial, imprecise and uncertain information, and that is the principal reason
for introducing nonclassic truth-functional many-valued logics, as for example, fuzzy,
bilattice-based and paraconsistent logics, etc. All of these logics use the conjunction
and disjunction logic operators as meet and join lattice operators with truth partial
ordering between the set of truth values. The class of complete lattices of truth values
is the most significant for logics, just because each finite set of truth values, or totally
ordering in infinite set of values (as in fuzzy logic) is a complete lattice.
Thus, the many-valued modal logics we consider have a natural algebraic seman-
tics based on a complete lattice of truth values, extended by other algebraic opera-

A.3 Autoreferential semantics for many-valued modal logics
|
389
tors: negation, implication for a subclass of modular lattices, relative pseudocomple-
ment (for distributive lattices) [290] for intuitionistic many-valued implication, and
unary normal modal operators (the first formal semantics for modal logic was based
on many-valuedness, proposed by Lukasiewicz in 1918–1920, and consolidated in 1953
in a 4-valued system of modal logic [79]).
There are strong links between the structural rules the logics satisfy and the prop-
erties of their algebraic models (which are, in the case of predicate based logic, the
many-valued Herbrand models). The distinctive feature of algebraic semantics is that
it is truth-functional. Besides algebraic models also Kripke-style or relational models
exist. The distinctive feature of Kripke-style semantics is that accessibility relations
over possible worlds are used in the definition of satisfiability, which is not just a me-
chanical truth-functional translation of the logic formula into the model.
There is a lot of work dedicated to this duality for lattices [291] with operators.
A good recent overview can be found in [196, 212, 292, 293].
Differently from their general approach, we introduce the autoreferential duality
for complete lattices: we use (autoreferentially) as a set of possible worlds for a Kripke
frame the underlying complete lattice of truth values. This is a particular case where
the frame is a partial order, as for example, in [294]. Consequently, the main contri-
bution of this section is a general way of establishing links between algebraic and
Kripke-style semantics for the class of many-valued modal logics, based on this au-
toreferential duality, and the consequent paraconsistent properties.
An introduction of multimodal predicate logic with their Kripke semantics, based
on the set 𝒲of possible worlds, is given in Section 1.1.2. More about complete lattice
is provided in Section A.1.
Remark. Here, as in the section dedicated to lattices and their algebraic extensions,
we will use the values 0, 1 ∈2 instead of corresponding values f , t respectively, used
for intensional FOL. In what follows, we will use the algebraic meet and join symbols
of a complete lattice (X, ≤), where X is a set of algebraic truth values and ≤a partial
order in X (an extension of the complete lattice 2), also as symbols for corresponding
logic connectives, conjunction and disjunction, while for other connectives we will
maintain the formal distinction.
Generally, normal 2-valued modal logics are not truth-valued (there is no homo-
morphism between the syntactical structure of the logic language and the Boolean
algebra (i. e., distributive lattices with complements) of truth functions (2, ≤), because
we have only four unary functions in 22: identity, negation, tautology and contra-
diction. Thus, the existential unary modal operator ♦i, and its dual universal modal
operator ◻i, cannot be represented as the function from 2 into 2, and it was the reason
why Jan Lukasiewicz introduced, around 1918, more truth values than the ordinary
two.
In fact, there is always the equivalent truth-functional many-valued logic, with the
set of higher-order truth values [82] in the Boolean-lattice functional space (2𝒲, ≤,

390
|
A Appendix
∧, ∨, ¬), isomorphic to the powerset Boolean algebra (𝒫(𝒲), ⊆, ⋂, ⋃, −), i. e., there is
the isomorphism of Boolean algebras im : (2𝒲, ≤, ∧, ∨, ¬) ≃(𝒫(𝒲), ⊆, ⋂, ⋃, −), such
that for any two functional algebraic values f1, f2 ∈2𝒲, f1 ≤f2 iff im(f1) ⊆im(f2), where
im(f) = {w ∈𝒲| f(w) = 1} is the image of f.
The meet, join and negation operations in the Boolean algebra (2𝒲, ≤, ∧, ∨, ¬) are
defined by this isomorphism as:
f = f1 ∧f2 : 𝒲→2,
such that im(f) = im(f1) ⋂im(f2),
f = f1 ∨f2 : 𝒲→2,
such that im(f) = im(f1) ⋃im(f2),
f = ¬f1 : 𝒲→2,
such that im(f ) = 𝒲−im(f1),
where −is the set substriction.
The logic implication in this Boolean algebra is defined classically by f1 ⇒f2 =def
¬f1 ∨f2. The truth-functional universal (multiplicative) modal operator ◻i : 2𝒲→2𝒲
for normal Kripke logic with the binary accessibility relation ℛi is defined by
f = ◻if1 : 𝒲→2,
such that im(f) = {w | ∀w′((w, w′) ∈ℛi implies w′ ∈im(f1))}.
So that, a nontruth-functional 2-valued modal logic is equivalently represented by a
many-valued truth-functional algebraic logic based on Boolean algebra extended by
normal modal algebraic operators (X, 0, 1, ≤, ∧, ∨, ¬, ◻i), where X = 2𝒲and 0, 1 ∈X
are the bottom and top value in X, with also an infinite number of algebraic truth val-
ues [295]. The same approach can be applied to any many-valued nontruth-functional
modal logic, thus it is enough to analyze only the algebraic truth-functional many-
valued modal logics, as is done in what follows. Vice versa, any algebraic many-valued
logic logic program, based on the complete lattice of truth values, can be equivalently
represented by a nontruth-functional 2-valued multimodal logic [204] with ternary ac-
cessibility relations.
Given a modal algebra (X, 0, 1, ≤, ∧, ∨, ¬, ◻i), the standard relational semantics
based on Stone’s representation theorem, is represented by a descriptive general
frame introduced by Goldblat [296, 297], where a possible world is an ultrafilter F
defined as a subset of X, which satisfies the following conditions:
1 ∈F and not 0 ∈F
if x, y ∈F, then x ∧y ∈F
if x ∈F and x ≤y then y ∈F
for each x ∈X, either x ∈F or ¬x ∈F.
Instead of this standard relational semantics for modal logic, where a possible world
is a subset of elements in X (an ultrafilter), in this section we will use a more simple
autoreferential semantics where a possible world is an element in X.

A.3 Autoreferential semantics for many-valued modal logics
|
391
A.3.1 Many-valued model-theoretic autoreferential semantics
A short introduction to binary sequent calculus is provided in Section A.2. The theory
presented here is more general than that used in Section A.4.3 for finite many-valued
predicate logic and its reduction into 2-valued logics.
Let ℒmv be a propositional logic language obtained as free algebra, from the con-
nectives in Σ of an algebra based on a complete lattice (X, ≤) of algebraic truth val-
ues (e. g., meet and join {∧, ∨} ⊆Σ are binary operators, negation ¬ ∈Σ and other
modal operators are unary operators, while each a ∈X ⊆Σ is a constant (nullary
operator)) and a set Var of propositional letters (Herbrand base H for predicate logic)
denoted by p, r, q, . . . . We will use letters ϕ, ψ, . . . for the formulae of ℒmv. We define
for (many-valued) valuation v : Var →X a unique extension v∗: ℒmv →X (notice
that X ⊆ℒmv are the constants of this language and we will use the same symbols as
for elements of the lattice X), which is an homomorphism (e. g., for any p, q ∈Var,
v∗(p ⊙q) = v(p) ⊙v(q), ⊙∈{∧, ∨, ⇒} and v∗(¬p) = ¬v(p), where ∧, ∨, ⇒, ¬ are conjunc-
tion, disjunction, implication and negation, respectively) and is an identity for ele-
ments in X, i. e., for any x ∈X, v(x) = x. We denote by 𝕍the set XVar of all many-valued
valuations. So, we define the lattice-based consequence binary relation ⊢⊆ℒmv × ℒmv
between the formulae (it is analog to the binary consequence system from [193] for the
distributive lattice logic DLL), where each consequence pair ϕ ⊢ψ is a sequent also.
Example 44. Let us consider the Distributive modal logic [193] (with ◻universal modal
operator, and its left-adjoint existential modal operator ⋄, with ⋄⊣◻) and with a neg-
ative modal operator ¬. The Gentzen-like system 𝒢of this logic language ℒmv contains
the following axioms (sequents) and rules:
(AXIOMS) 𝒢contains the following sequents:
1.
ϕ ⊢ϕ (reflexive)
2.
ϕ ⊢1, 0 ⊢ϕ (top/bottom axioms)
3.
ϕ ∧ψ ⊢ϕ, ϕ ∧ψ ⊢ψ (product projections: axioms for meet)
4.
ϕ ⊢ϕ ∨ψ, ψ ⊢ϕ ∨ψ (coproduct injections: axioms for join)
5.
ϕ ∧(ψ ∨φ) ⊢(ϕ ∧ψ) ∨(ϕ ∧φ) (distributivity axiom)
6.
◻(ϕ ∧ψ) ⊢◻ϕ ∧◻ψ, 1 ⊢◻1 (multiplicative modal property axioms)
7.
⋄(ϕ ∨ψ) ⊢⋄ϕ ∨⋄ψ, ⋄0 ⊢0 (additive modal property axioms)
8.
¬ϕ ∧¬ψ ⊢¬(ϕ ∨ψ), 1 ⊢¬0 (additive modal negation axiom)
9.
The set of sequents, which define the poset of the lattice of truth values (X, ≤): for
any two x, y ∈X, if x ≤y then x ⊢y ∈𝒢.
(INFERENCE RULES) 𝒢is closed under the following inference rules:
1.
ϕ⊢ψ,ψ⊢φ
ϕ⊢φ
(cut/transitivity rule)
2.
ϕ⊢ψ,ϕ⊢φ
ϕ⊢ψ∧φ , ϕ⊢ψ,φ⊢ψ
ϕ∨φ⊢ψ (lower/upper lattice bound rules)
3.
ϕ⊢ψ
◻ϕ⊢◻ψ,
ϕ⊢ψ
⋄ϕ⊢⋄ψ (monotonicity of modal operators rules)

392
|
A Appendix
4.
ϕ⊢ψ
¬ψ⊢¬ϕ (antitonicity of modal negation rule)
5.
ϕ⊢ψ
σ(ϕ)⊢σ(ψ) (substitution rule: σ is substitution (γ/p)).
The rules in point 2 are the consequences of diagonal mapping △: X →Y, where
Y = X ×X and △x = (x, x), (which is both additive and multiplicative modal operator),
and its Galois adjunctions with the meet (multiplicative) and join (additive) operators
∧, ∨: Y →X, i. e., with △⊣∧and ∨⊣△; that is, △x ≤Y (y, z) (i. e., x ≤y and x ≤z) iff
x ≤∧(y, z) = y ∧z, and x ∨y = ∨(x, y) ≤z iff (x, y) ≤Y △z (i. e., x ≤z and y ≤z).
The axioms from 1 to 5 and the rules 1 and 2 are taken from [193] for the DLL and
it was shown that this sequent based Genzen-like system is sound and complete. If
we omit the distributivity axiom 5, we obtain the system 𝒢for complete lattice logics.
Thus, for a lattice based modal many-valued logics we obtain a normal modal Gentzen-
like deductive system, where each sequent is a valid truth-preserving consequence
pair defined by the poset of the complete lattice (X, ≤) of truth values (which are also
the constants of this modal propositional language ℒmv), so that each occurrence of
the symbol ⊢can be substituted by the partial order ≤of this complete lattice.
In according with the truth-preserving entailment for general sequents pro-
vided by Definition 57 in Section 5.1, here we introduce its simpler case for binary
sequent.
Definition 102 (Binary-sequent truth-preserving entailment). For any two sentences
ϕ, ψ ∈ℒmv, the truth-preserving consequence pair (sequent), denoted by ϕ ⊢ψ is sat-
isfied by a given valuation v∗: ℒmv →X if v∗(ϕ) ≤v∗(ψ). This sequent is a tautology
if it is satisfied by all valuations, i. e., when ∀v ∈𝕍.(v∗(ϕ) ≤v∗(ψ)).
For a normal Gentzen-like sequent system 𝒢of the many-valued logic ℒmv, with
the set of sequents Seq𝒢⊆ℒmv × ℒmv and a set of inference rules in Rul𝒢, we tell that
a many-valued valuation v is its model if it satisfies all sequents in 𝒢. The set of all
models of a given set of sequents (theory) Γ is denoted by
𝕍Γ =def {v ∈𝕍| ∀(ϕ ⊢ψ) ∈Γ(v∗(ϕ) ≤v∗(ψ))} ⊆𝕍.
Proposition 36 (Soundness). All axioms of the Gentzen-like sequent system 𝒢, of a
many-valued logic ℒmv based on complete lattice (X, ≤) of algebraic truth values, are
the tautologies, and all its rules are sound for model satisfiability and preserve the
tautologies.
Proof. It is straightforward to check (see Example 44) that all axioms are tautologies
(all constant sequents specify the poset of the complete lattice (X, ≤), thus are tautolo-
gies) and that all rules preserve the tautologies. Moreover, if all premises of any rule in
𝒢are satisfied by given many-valued valuation v∗: ℒmv →X, then also the deduced
sequent of this rule is satisfied by the same valuation, i. e., the rules are sound for the
model satisfiability.

A.3 Autoreferential semantics for many-valued modal logics
|
393
It is easy to verify that for any two x, y ∈X we have that x ≤y iff x ⊢y, i. e.,
the truth-preserving entailment coincides with the partial truth-ordering in a lattice
(X, ≤). Notice that it is compatible with lattice operators, i. e., for any two formulae
ϕ, ψ ∈ℒmv, ϕ∧ψ ⊢ψ and ϕ ⊢ψ∨ϕ. This entailment imposes the following restrictions
to the logic implication: in order to satisfy the “deduction theorem “z ⊢x ⇒y iff
z∧x ⊢y” (i. e., inference rules for elimination and introduction of the logic connective
⇒, z⊢x⇒y
z∧x⊢y and z∧x⊢y
z⊢x⇒y ) by this entailment, the logic implication must satisfy (the case
when z = 1) the requirement that for any x, y ∈X, x ⇒y = 1 iff x ≤y, while it must
satisfy x ∧(x ⇒y) ≤y in order to satisfy the modus ponens inference rule.
The particularity of this entailment is that any consequence pair (sequent) ϕ ⊢ψ
is algebraically an equation ϕ ∧ψ = ϕ (or, ϕ ∨ψ = ψ).
It is easy to verify, that in the case of the classic 2-valued propositional logic
this entailment is equal to the classic propositional entailment, so that the truth-
preserving entailment is only a generalization of the classic entailment for a many-
valued propositional logics.
Remark. It is easy to observe that each sequent is, from the logic point of view,
a 2-valued object so that all inference rules are embedded into the classic 2-valued
framework, i. e., given a bivaluation β : ℒmv × ℒmv →2, we have that a sequent
s = ϕ ⊢ψ is satisfied when β(s) = 1, so that we have the relationship between se-
quent bivaluations and many-valued valuations v used in Definition 102. This sequent
feature, which is only an alternative formulation for the 2-valued classic logic, is fun-
damental in the framework of many-valued logics, where often the semantics for the
entailment, based on algebraic matrices (X, D) is arbitrary: consider, e. g., fuzzy logic,
where the subset of designated elements D ⊆X is an closed interval [a, 1], where
0 < a ≤1 is an arbitrary value, so difficult to fix.
Thus, this correct definition of the 2-valued entailment in the sequent system 𝒢,
based only on the lattice ordering, can replace the current entailment based on the
algebraic matrices (X, D), where D ⊆X is the subset of designated elements, which is
upward closed, i. e., if x ∈D and x ≤y, then y ∈D (thus 1 ∈D), and where the matrix-
entailment, defined by ϕ ⊢D ψ, is valid iff ∀v ∈𝕍.(v∗(ϕ) ∈D implies v∗(ψ) ∈D). It is
easy to verify also that ϕ ⊢ψ implies ϕ ⊢D ψ.
This opinion is based also on the consideration that all many-valued, implication
based (IF), logic program languages, are based on clauses A ←B1 ∧⋅⋅⋅∧Bn where
A is a ground atom and Bi are ground literals (ground atoms or negation of ground
atoms), we tell that it is satisfied by a valuation v∗iff v∗(A) ≤v∗(B1) ∧⋅⋅⋅∧v∗(Bn);
Thus, this clause is the sequent (B1 ∧⋅⋅⋅∧Bn) ⊢A, so that a logic program is in fact
a set of sequents; the valuation v∗which satisfies all clauses (sequents) is a model
for such a logic program, and demonstrates how we are able to define the models
of many-valued logics without the necessity to define the algebraic matrices (X, D).
The other class of many valued logic programs, Signed logic programs [298, 299] and
its subclass of annotation based (AB) programs [300, 301] a clause is of the form A :

394
|
A Appendix
f(δ1, . . . , δn) ←B1 : δ1, . . . , Bn : δn, which asserts “the certainty of the atom A is least
(or is in) f (δ1, . . . , δn), whenever the certainty of the atom Bi is at least (or is in) δi,
1 ≤i ≤n,” where f is an n-ary computable function and δi is either a constant or a
variable ranging over many-valued logic values. But they are not really many-valued
logics, but a kind of meta many-valued logics, because all annotated literals Bn : δn
are classic 2-valued objects (a valuation v is a model of the literal Bn : δn if v∗(Bn) ≥δn
(or v∗(Bn) ∈δn)), and all connectives in the clauses are also classic 2-valued. In fact,
in [204] it is shown that the annotated elements are 2-valued modal formulae, so that
an annotated logic is a kind of 2-valued multimodal logics; the same result can be
proven also in the more general case of Signed logic programming. Thus, we are able
now to introduce the many-valued valuation-based (i. e., model-theoretic) semantics
for many-valued logics.
Definition 103. A many-valued model-theoretic semantics of a given many-valued
logic ℒmv, with a Gentzen system 𝒢= ⟨𝕃, ⊩⟩, is the semantic deducibility relation 󳀀󳨐m,
defined for any set Γ = {si = (ϕi ⊢ψi)} and sequent s = (ϕ ⊢ψ) ∈𝕃⊆ℒmv × ℒmv by
Γ 󳀀󳨐m s iff all many-valued models of Γ are the models of s. That is,
Γ 󳀀󳨐m s
iff
∀v ∈𝕍(∀(ϕi ⊢ψi) ∈Γ(v∗(ϕi) ≤v∗(ψi)) implies v∗(ϕ) ≤v∗(ψ))
iff
∀v ∈𝕍Γ(∀(ϕi ⊢ψi) ∈Γ(v∗(ϕi) ≤v∗(ψi)) implies v∗(ϕ) ≤v∗(ψ))
iff
∀v ∈𝕍Γ(v∗(ϕ) ≤v∗(ψ)).
It is easy to verify that any complete-lattice based many-valued logic has the
Gentzen-like system 𝒢= ⟨𝕃, ⊩⟩(see the example above), which is normal logic.
Theorem 16. The many-valued model theoretic semantics is an adequate semantics for
a many-valued logic ℒmv specified by a Gentzen-like logic system 𝒢= ⟨𝕃, ⊩⟩, i. e., it is
sound and complete. Consequently, Γ 󳀀󳨐m s iff Γ ⊩s.
Proof. Let us prove that for any many valued model v ∈𝕍Γ, the obtained sequent
bivaluation β = eq ∘⟨π1, ∧⟩∘(v∗× v∗) : ℒmv × ℒmv →2 is the characteristic function of
the closed theory Γv = C(T) with T = {ϕ ⊢x, x ⊢ϕ | ϕ ∈ℒmv, x = v∗(ϕ)}.
From the definition of β, we have that β(ϕ ⊢ψ) = β(ϕ; ψ) = eq ∘⟨π1, ∧⟩∘
(v∗× v∗)(ϕ; ψ) = eq ∘⟨π1, ∧⟩(v∗(ϕ), v∗(ψ)) = eq⟨π1(v∗(ϕ), v∗(ψ)), ∧(v∗(ϕ), v∗(ψ))⟩=
eq(v∗(ϕ), ∧(v∗(ϕ), v∗(ψ))) = eq(v∗(ϕ), v∗(ϕ) ∧v∗(ψ)), where π1 is the first projection,
eq : X ×X →2 ⊆X is the equality characteristic function such that eq(x, y) = 1 if x = y.
Thus, β(ϕ ⊢ψ) = 1 iff v∗(ϕ) ≤v∗(ψ), i. e., when this sequent is satisfied by v∗.
1.
Let us show that for any sequent s, s ∈Γv implies β(s) = 1: First of all, any sequent
s ∈T is of the form φ ⊢x or x ⊢φ, where x = v∗(φ), so that it is satisfied by v∗
(holds that v∗(φ) ≤v∗(φ) in both cases). So, all sequents in T are satisfied by v∗.
By the Proposition 36, we have that all inference rules in 𝒢are sound w. r. t. the model
satisfiability, thus for any deduction T ⊩s (i. e., s ∈Γv) where all sequents in premises

A.3 Autoreferential semantics for many-valued modal logics
|
395
are satisfied by the many-valued valuation (model) v∗, also the deduced sequent s =
(ϕ ⊢ψ) must be satisfied, that is it must hold v∗(ϕ) ≤v∗(ψ), i. e., β(s) = 1.
2.
Let us show that for any sequent s, β(s) = 1 implies s ∈Γv:
For any sequent s = (ϕ ⊢ψ) ∈ℒmv × ℒmv if β(s) = 1, then x = v∗(ϕ) ≤v∗(ψ) = y
(i. e., s is satisfied by v). From the definition of T, we have that ϕ ⊢x, y ⊢ψ ∈T,
and from x ≤y we have x ⊢y ∈Ax𝒢(where Ax𝒢are axioms (sequents) in 𝒢, with
{x ⊢y | x, y ∈X, x ≤y} ⊆Ax𝒢, thus satisfied by every valuation) by the transitivity
rule, from ϕ ⊢x, x ⊢y, y ⊢ψ, we obtain that T ⊩(ϕ ⊢ψ), i. e., s = (ϕ ⊢ψ) ∈C(T) = Γv.
So, from (1) and (2) we obtain that β(s) = 1 iff s ∈Γv, i. e., the sequent bivaluation
β is the characteristic function of a closed set. Thus, any many-valued model v∗of this
many-valued logic ℒmv corresponds to the closed bivaluation β, which is a characteris-
tic function of a closed theory of sequents: we define the set of all closed bivaluations
obtained from the set of many-valued models v ∈𝕍Γ: BivΓ = {Γv | v ∈𝕍Γ}. From the
fact that Γ is satisfied by every v ∈𝕍Γ, we have that for every Γv ∈BivΓ, Γ ⊆Γv, so that
C(Γ) = ⋂BivΓ (intersection of closed sets is a closed set also). So, for s = (ϕ ⊢ψ),
Γ 󳀀󳨐m s
iff
∀v ∈𝕍Γ(∀(ϕi ⊢ψi) ∈Γ(v∗(ϕi) ≤v∗(ψi)) implies v∗(ϕ) ≤v∗(ψ))
iff
∀v ∈𝕍Γ(∀(ϕi ⊢ψi) ∈Γ(β(ϕi ⊢ψi) = 1) implies β(ϕ ⊢ψ) = 1)
iff
∀v ∈𝕍Γ(∀(ϕi ⊢ψi) ∈Γ((ϕi ⊢ψi) ∈Γv) implies s ∈Γv)
iff
∀Γv ∈BivΓ(Γ ⊆Γv implies s ∈Γv)
iff
∀Γv ∈BivΓ(s ∈Γv), because Γ ⊆Γv for each Γv ∈BivΓ
iff
s ∈⋂BivΓ = C(Γ), that is, iff Γ ⊩s.
Thus, in order to define the model-theoretic semantics for a many-valued log-
ics we do not need to define the problematic matrices: we are able to use only the
many-valued valuations, and many-valued models (i. e., valuations, which satisfy all
sequents in Γ of a given many-valued logic ℒmv). This point of view is used also for
definition of a new representation theorem for many-valued logics in [206].
Different from the classic logic where a formula is a theorem if it is true in all mod-
els of the logic, here in a many-valued logic ℒmv, but specified by a set of sequents
in Γ, for a formula ϕ ∈ℒmv, which has the same value x ∈X (for any algebraic truth-
value x) for all many-valued models v ∈𝕍Γ, we have that its sequent-based version
ϕ ⊢x and x ⊢ϕ are theorems; that is, ∀v ∈𝕍Γ(v∗(ϕ) = x) iff (Γ ⊩(ϕ ⊢x) and Γ ⊩
(x ⊢ϕ)).
But such a value x ∈A does not need to be a designated element x ∈D, as in
matrix semantics for a many-valued logic, and it explains why we do not need the
rigid semantic specification by matrix designated elements. Thus, by a translation of
a many-valued logic ℒmv into its “meta” sequent-based 2-valued logic, we obtain an
unambiguous theory of inference without the introduction of problematic matrices.

396
|
A Appendix
There are also two other ways, alternative to 2-valued sequent systems, to reduce the
many-valued logics into “meta” 2-valued logics as provided in Section A.4.
Based on this Genzen-like sequent deductive system 𝒢, we are able to define
the equivalence relation ≈L between the formulae of any modal propositional logic
based on a complete lattice in order to define the Lindenbaum algebra for this logic,
(ℒmv/ ≈L, ⊑), where for any two formulae ϕ, ψ ∈ℒmv:
(a) ϕ ≈L ψ iff ϕ ⊢ψ and ψ ⊢ϕ, i. e., iff ∀v∗.(v∗(ϕ) ≤v∗(ψ)) and ∀v∗.(v∗(ϕ) ≥v∗(ψ)).
So, the quotient algebra ℒmv/ ≈L has as elements equivalence classes, denoted by
[ϕ], and the partial ordering ⊑, defined by
(b) [ϕ] ⊑[ψ] iff ϕ ⊢ψ (i. e., if ϕ ≤ψ).
It is easy to verify that each equivalence class (set of all equivalent formulae w. r. t. ≈L)
[ϕ] has exactly one constant x ∈X, which is an element of this equivalence class, and
we can use it as the representation element for this equivalence class: so that every
formula in this equivalence class has the same truth value as this constant.
Thus, we have the bijection is : ℒmv/ ≈L→X between elements in the complete
lattice (X, ≤) and elements in the Lindenbaum algebra, such that for any equivalence
class [ϕ] ∈ℒmv/ ≈L, the constant is([ϕ]) ∈X is the representation element for this
equivalence class. It is easy to extend this bijection into an isomorphism between the
original algebra and this Lindenbaum algebra, by definition of correspondent connec-
tives in the Lindenbaum algebra, e. g.,
[ϕ] ∧L [ψ] =def is−1(is([ϕ]) ∧is([ϕ])),
[ϕ] ∨L [ψ] =def is−1(is([ϕ]) ∨is([ϕ])),
¬L[ϕ] =def is−1(¬(is([ϕ]))),
etc.
In the autoreferential semantics, we will assume that each equivalence class of formu-
lae [ϕ] in this Lindenbaum algebra corresponds to one “state-description,” that is to
one possible world in the Kripke-style semantics for the original many-valued modal
logic. But, from the isomorphism is, we can take, instead of equivalence class [ϕ], only
its representation element x = is([ϕ]) ∈X. Consequently, the set of possible worlds in
this autoreferential semantics corresponds to the set of truth values in the complete
lattice (X, ≤).
A.3.2 Hierarchy of negation operators for complete lattices
Generally, lattices arise concretely as the substructures of closure systems (intersec-
tion systems) where a closure system is a family ℱ(X) of subsets of a set X such that
X ∈ℱ(X) and if Ai ∈ℱ(X), i ∈I, then ⋂i∈I Ai ∈ℱ(X). Then the representation problem
for general lattices is to establish that every lattice can be viewed, up to an isomor-
phism, as a collection of subsets in a closure system (on some set X), closed under the
operations of the system.

A.3 Autoreferential semantics for many-valued modal logics
|
397
Closure operators are canonically obtained by the composition of two maps of
Galois connections. The Galois connections can be obtained from any binary relation
on a set X [207] (Birkhoff polarity) in a canonical way:
If (X, R) is a set with a particular relation on a set X, R ⊆X × X, with mappings
λ : 𝒫(X) →𝒫(X)OP, ϱ : 𝒫(X)OP →𝒫(X),
such that for any U, V ∈𝒫(X),
λU = {x ∈X | ∀u ∈U.((u, x) ∈R)},
ρV = {x ∈X | ∀v ∈V.((x, v) ∈R)},
where 𝒫(X) is the powerset poset with the bottom element empty set 0 and top ele-
ment X, and 𝒫(X)OP its dual (with ⊆OP inverse of ⊆), then we obtain the induced Galois
connection
λ ⊣ρ,
i. e.,
λU ⊆OP V iff U ⊆ρV.
The following lemma is useful for the relationship of these set-based operators with
the operation of negation in the complete lattices.
Lemma 13 (Incompatibility relation). Let (X, ≤) be a complete lattice. Then we can use
a binary relation R ⊆X × X as an incompatibility relation for set-based negation
operators λ and ρ, with the following properties: for any U, V ⊆X,
1.
λ(U ⋃V) = λU ⋃OP λV = λU ⋂λV, with λ0 = 0OP = X (additivity),
2.
ρ(U ⋂OP V) = ρ(U ⋃V) = ρU ⋂ρV, with ρXOP = ρ0 = X (multiplicativity),
3.
while λ(U ⋂V) ≥λU ⋃λV, ρ(U ⋂V) ≥ρU ⋃ρV and λρV ≥V, ρλU ≥U.
We will consider the case when (X, R) is a complete lattice with the binary rela-
tion R equal to the partial order ≤in the lattice X. The resulting Galois connection
on this partial order is the familiar Dedekind–McNeile Galois connection of antitonic
mappings λ and ρ (We denote by ↓x the ideal {y ∈X | yℒmv eq x}):
λU = {x ∈X | ∀u ∈U.(u ≤x)},
ρV = {x ∈X | ∀v ∈V.(x ≤v)},
Setting ⊡= ρλ : 𝒫(X) →𝒫(X), the operator ⊡is a monotone mapping and a closure
operator, such that for any U, V ∈𝒫(X) :
1.
U ⊆V implies ⊡(U) ⊆⊡(V),
2.
U ⊆⊡(U), for any U ∈𝒫(X),
3.
⊡⊡(U) = ⊡(U)
The set {U ∈𝒫(X) | U = ⊡(U)} is called the set of stable (closed) sets.
It is easy to verify that for every subset S ⊆X, we obtain ⊡(S) = ↓⋁(S), which is a
multiplicative monotone operator: the closure operator ⊡satisfies the multiplicative
property ⊡(U ⋂V) = ⊡(U) ⋂⊡(V), and ⊡(X) = X, which is the top element in 𝒫(X).
Thus, ⊡= ↓⋁is a universal modal operator for the complete lattice (𝒫(X), ⊆)
(which is a Boolean algebra, i. e., a complemented distributive lattice), so that we ob-
tain the modal algebra (𝒫(X), ⊆, ⋂, ⋃, ⊡) for the complete lattice (X, ≤).

398
|
A Appendix
Notice that ⊡(0) = ⊡({0}) = {0}. Thus, from the monotone property of ⊡and from
0 ⊆U (for any U ∈𝒫(X)) we obtain that {0} = ⊡(0) ⊆⊡(U). That is, any stable (closed)
set contains the bottom element 0 ∈X, and that the minimal stable set is {0} and not
an empty set 0, while naturally the maximal stable set is X.
Moreover, each stable set is a down-closed ideal and there is the bijection between
the set of stable sets and the set of algebraic truth-values in X, so that we can define
the first (noncanonical) representation theorem for a complete lattice (X, ≤) as follows.
Proposition 37 (Autoreferential representation theorem for complete lattices). Let
(X, ≤) be a complete lattice. We define the Dedekind–McNeile coalgebra ↓: X →𝒫(X),
where ↓= ⊡in, ⊡= ρλ is a Dedekind–McNeile closure operator and in : X →𝒫(X) the
inclusion map x 󳨃→{x}, such that for any two x, y ∈X holds (we denote by—the set
substraction)
(1) ⋃{S ∈𝒫(X) | S ⋂↓x ⊆↓y} = (X−↓x) ⋃↓y.
We denote by ℱ(X) = {↓x | x ∈X} the closure system because for each x ∈X, ↓x is
a stable set. Then the (ℱ(X), ⊆) is a complete lattice with meet operator ⋂(set intersec-
tion), and join operator ⨄= ⊡⋃= ↓⋁⋃different from the set union ⋃, such that the
noncanonical autoreferential representation isomorphism holds:
(2) ↓: (X, ≤, ∧, ∨, 0, 1) ≃(ℱ(X), ⊆, ⋂, ⨄, {0}, X).
Proof. We will show that each stable set U ∈ℱ(X) is an ideal in (X, ≤). In fact, it holds
that for any x ∈X, ↓x = ⊡in(x) = ρλ({x}) = {x′ ∈X | x′ ≤x} is an ideal. Thus, for any
two x, y ∈X we have that:
1.
If x ≤y, then ↓x ⊆↓y,
2.
↓x ⋂↓y = {x′ ∈X | x′ ≤x} ⋂{y′ ∈X | y′ ≤y} = {z ∈X | z ≤x ∧y} ↓(x ∧y) ∈ℱ(X),
3.
↓x ⨄↓y = ↓⋁⋃(↓x, ↓y) = ↓⋁(↓x ⋃↓y) = ↓⋁({x′ ∈X | x′ ≤x} ⋃{y′ ∈X | y′ ≤
y}) = ↓(x ∨y) ∈ℱ(X).
The operator ⨄is the join operator in ℱ(X), that is it holds ↓x ⊆↓y iff ↓x ⨄↓y = ↓y.
Thus, the original lattice (X, ≤) is isomorphic to the lattice (ℱ(X), ⊆) via map
x 󳨃→↓x. It is easy to verify that the inverse of ↓, i. e., ↓−1= (⊡in)−1 = in−1⊡−1 : 𝒫(X) →X
is equal to supremum ⋁, i. e., ↓−1 (U) = ⋁{x ∈U}, with ⋁↓x = x, i. e., ⋁↓= idX and ↓
⋁= idℱ(X) are the identity functions for x and ℱ(X), respectively. It is easy to verify
that ℱ(X) is a complete lattice with bottom element ↓0 = {0} and top element ↓1 = X,
and for any U = ↓x, V = ↓y ∈ℱ(X), U ⋂V = ↓(x ∧y) ∈ℱ(X) and U ⨄V = ↓(x ∨y) ∈
ℱ(X).
Remark. What is important to notice is that the autoreferential representation, based
only on the lattice ordering of truth values, naturally introduce the modality in this
logic. In fact, the universal modal operator ⊡: 𝒫(X) →ℱ(X) ⊂𝒫(X), based on the
partial order of the complete lattice (X, ≤), plays the fundamental role for the modal

A.3 Autoreferential semantics for many-valued modal logics
|
399
disjunction ⨄in the canonical autoreferential algebra ℱ(X). We need it because gen-
erally for any two x, y ∈X, we have that ↓x ⋃↓y ∉ℱ(X). Its restriction on ℱ(X) is an
identity function idℱ(X), which is a self-adjoint (universal and existential) modal oper-
ator. If we denote by ◻the logic modal operator correspondent to the algebraic modal
operator ⊡, we can define the join operator ∨(many-valued disjunction) from the clas-
sic disjunction ∨c (for which holds ↓∨c = ⋃↓, i. e., ↓(x ∨c y) = ↓x ⋃↓y) and this
modal operator, as follows: for any two logic formulae ϕ and ψ: ϕ∨ψ = ◻(ϕ∨c ψ). This
property will be used when we will define the Kripke-style semantics for this many-
valued logic.
Notice also that in Lewis’s approach he distinguishes the standard or extensional
disjunction ∨c, from the intensional disjunction ∨“in such that at least one of the dis-
joined propositions is necessarily true” [302] (1912, p. 523). In the same way, he defined
also the “strict” logic implication ϕ ⇒ψ = ◻(ϕ ⇒c ψ) where ⇒c is the classic ex-
tensional implication such that ϕ ⇒c ψ = ¬cϕ ∨c ψ (here ¬c denotes the classic
logic negation). In what follows, we will see that this property holds also for a many-
valued implication defined as relative pseudo-complement in a complete distributive
lattice X, i. e., for the intuitionistic logic implication.
Thus, the noncanonical autoreferential semantics for many-valued logic, based
on the partial order of the lattice, defines the intensional disjunction1 and implication
as a many-valued generalization of Lewis’s 2-valued logic.
It remains to explain what an algebraic universal modal operator for a lattice X
is, corresponding to the universal algebraic modal operator ⊡in 𝒫(X). The answer is
simple: it is an identity operator id : X →X. In fact, we have that the homomorphism
↓between the many-valued algebra over X and the powerset algebra over 𝒫(X) is ex-
tended by ↓id = ⊡↓. Then we obtain that ↓x =↓id(x) = ⊡↓x = ↓⋁↓x = ↓x, and
that ↓(x ∨y) = ↓(id ∨c(x, y)) = (from ↓id = ⊡↓) = ⊡↓∨c(x, y) = (from ↓∨c = ⋃↓)
= ⊡⋃↓(x, y) = ⊡⋃(↓x, ↓y) = ⊡(↓x ⋃↓y).
While, ↓(x∧y) = ↓(id ∧c(x, y)) = (from ↓id = ⊡↓) = ⊡↓∧c(x, y) = (from ↓∧c = ⋂↓)
= ⊡⋂↓(x, y) = ⊡⋂(↓x, ↓y) = ⊡(↓x ⋂↓y) = (the operator ⊡is an identity for stable
sets) = ↓x ⋂↓y = ↓(x ∧y).
That is, the modal operator id has no effect on the conjunction, because ↓x ⋂↓
y ∈ℱ(X) is a stable set, different from ↓x ⋃↓y ∉ℱ(X), which is not.
Thus, we obtain the following modal version of the noncanonical autoreferential
representation for many-valued algebras based on a complete lattice X:
↓: (X, ≤, ∧, ∨, id, 0, 1) ≃(ℱ(X), ⊆, ⋂, ⊡⋃, idℱ(X), {0}, X)
⊈(𝒫(X), ⊆, ⋂, ⋃, ⊡, 0, X),
1 In the canonical autoreferential semantics, in what follows, we will preserve the classical disjunc-
tion, represented by standard union on sets.

400
|
A Appendix
i. e., ℱ(X) is not a subalgebra of the powerset Boolean distributive algebra 𝒫(X) with a
modal operator ⊡, as in the standard representation theorems for algebras. In fact,
here we do not impose that X (or ℱ(X)) has to be distributive, as it holds for any
Boolean sublattice.
Example 45. The smallest nontrivial bilattice is Belnap’s 4-valued bilattice [188, 190,
209], analyzed in Section 5.1.3, ℬ= {t, f, ⊥, ⊤} where t is true, f is false, ⊤is inconsistent
(both true and false) or possible, and ⊥is unknown. As Belnap observed, these values
can be given two natural orders: truth order, ≤t and knowledge order, ≤k, such that
f ≤t ⊤≤t t, f ≤t ⊥≤t t, ⊥⋈t ⊤and ⊥≤k f ≤k ⊤, ⊥≤k t ≤k ⊤, f ⋈k t. That is, the bottom
element 0 for ≤t ordering is f, and for ≤k ordering is ⊥, and the top element 1 for ≤t
ordering is t, and for ≤k ordering is ⊤.
Meet and join operators under ≤t are denoted ∧and ∨; they are natural general-
izations of the usual conjunction and disjunction notions. Meet and join under ≤k are
denoted ⊗and ⊕, such that hold: f ⊗t = ⊥, f ⊕t = ⊤, ⊤∧⊥= f and ⊤∨⊥= t.
The bilattice negation [197] is given by ¬f = t, ¬t = f, ¬⊥= ⊥and ¬⊤= ⊤, In
what follows, we will use the relative pseudo-complements for implication (Belnap’s
4-valued lattice is distributive), defined by x ⇀y = ⋁{z | z ∧x ≤t y}, and the pseudo-
complements for negation, defined by ¬tx = x ⇀f (which is different from the bilattice
negation ¬). It is easy to see that it holds the De Morgan law ¬t(x ∧y) = ¬tx ∨¬ty. We
have that, w. r. t. the truth ordering ≤t, ↓f = {f}, ↓⊥= {f, ⊥}, ↓⊤= {f, ⊤} and ↓t = ℬ.
Thus, ↓⊥⨄↓⊤= ↓⋁(↓⊥⋃↓⊤) = ↓⋁{f , ⊥, ⊤} = ↓t = ℬ
̸=↓⊥⋃↓⊤, i. e., ⨄
̸= ⋃.
It is easy to verify that the join operator ⨄in the compact set-based representation
ℱ(X) reduces to the standard set union ⋃when the complete lattice (X, ≤) is a total
ordering (as, e. g., the fuzzy logic with the closed interval of reals X = [0, 1] for the
set of truth values). It can be extended to all distributive lattices, such that for any x ∈
X and Y ⊆X, x∧(⋁Y) = ⋁{x∧y | y ∈Y}. Let us consider how to obtain this reduction in
a general case. From Birkhoff’s representation theorem [207] for distributive lattices,
every finite (thus complete) distributive lattice is isomorphic to the lattice of lower sets
of the poset of join-irreducible elements.
Proposition 38 (0-Lifted Birkhoff isomorphism [207]). Let X be a complete distributive
lattice, then we define the following mapping ↓+: X →𝒫(X): for any x ∈X,
↓+ x = ↓x ⋂̂X,
where ̂X = {y | y ∈X and y is join-irreducible} ⋃{0}.
We define the set X+ = {↓+ a | a ∈X} ⊆𝒫(X), so that ↓+ ⋁= idX+ : X+ →X+ and ⋁↓+=
idX : X →X. Thus, the operator ↓+ is the inverse of the supremum operation ⋁: X+ →X.
The set (X+, ⊆) is a complete lattice, such that there is the following 0-lifted Birkhoff
isomorphism ↓+: (X, ≤, ∧, ∨) ≃(X+, ⊆, ⋂, ⋃).

A.3 Autoreferential semantics for many-valued modal logics
|
401
Proof. Let us show the homomorphic property of ↓+:
↓+ (x ∧y) = ↓(x ∧y) ⋂̂X = (↓x ⋂↓y) ⋂̂X = (↓x ⋂̂X) ⋂(↓y ⋂̂X)
= ↓+x ⋂↓+ y,
and
↓+ (x ∨y) = ↓(x ∨y) ⋂̂X = (↓x ⋃↓y) ⋂̂X = (↓x ⋂̂X) ⋃(↓y ⋂̂X)
=↓+ x ⋃↓+ y.
The isomorphic property holds from Bikhoff’s theorem.
The name “lifted” is used to denote the difference from the original Birkhoff’s iso-
morphism: that is, we have that for any x ∈X, 0 ∈↓+ x, so that ↓+ x is never an empty
set (it is lifted by the bottom element 0).
Notice that when X is a distributive lattice then (X+, ⊆, ⋂, ⋃) is a subalgebra of
the powerset Boolean algebra (𝒫(X), ⊆, ⋂, ⋃), different from the case when X is not
distributive. Thus, we obtain canonical representation:
↓+: (X, ≤, ∧, ∨, idX) ≃(X+, ⊆, ⋂, ⋃, idX+) ⊆(𝒫(X), ⊆, ⋂, ⋃, ⊡+),
where ⊡+ = ↓+ ⋁: 𝒫(X) →𝒫(X) is a modal algebraic monotone multiplicative opera-
tor. Its reduction to the subset of join-irreducible elements ̂X ⊆X is equal to
⊡+ = ⊡: 𝒫(̂X) →𝒫(̂X).
Example 46. Belnap’s bilattice in Example 45 is a distributive lattice w. r. t. the ≤t or-
dering with two join-irreducible elements ⊥and ⊤. In that case, we have that ↓+ t =
↓+(⊥∨⊤) = ↓+⊥⋃↓+ ⊤= ↓⊥⋃↓⊤= {f , ⊥, ⊤}
̸=↓t = ℬ.
Now we will introduce a hierarchy of negation operators for complete lattices,
based on their homomorphic properties: the negation with the lowest requirements
(such that it inverts the truth ordering of the lattice of truth values and is able to pro-
duce falsity and truth, i. e., the bottom and top elements of the lattice), denominated
“general” negation, can be defined in any complete lattice (see the example below).
Definition 104 (Hierarchy of negation operators). Let (X, ≤, ∧, ∨) be a complete lattice.
Then we define the following hierarchy of negation operators on it:
1.
A general negation is a monotone mapping between posets (≤OP is inverse of ≤),
¬ : (X, ≤) →(X, ≤)OP, such that {0, 1} ⊆{y = ¬x | x ∈X}.
2.
A split negation is a general negation extended into the join-semilattice homo-
morphism, ¬ : (X, ≤, ∨) →(X, ≤, ∨)OP, with (X, ≤, ∨)OP = (X, ≤OP, ∨OP), ∨OP = ∧.
3.
A constructive negation is a general negation extended into full lattice homo-
morphism, ¬ : (X, ≤, ∧, ∨) →(X, ≤, ∧, ∨)OP, with (X, ≤, ∧, ∨)OP = (X, ≤OP, ∧OP∨OP),
and ∧OP = ∨.

402
|
A Appendix
4.
A De Morgan negation is a constructive negation when the lattice homomorphism
is an involution (¬¬x = x).
The names given to these different kinds of negations follow from the fact that a
split negation introduces the second right-adjoint negation, a constructive negation
satisfies the constructive requirement (as in Heyting algebras) ¬¬x ≥x, while a De
Morgan negation satisfies the well-known De Morgan laws.
Lemma 14 (Negation properties). Let (X, ≤) be a complete lattice. Then the following
properties for negation operators hold: for any x, y ∈X,
1.
for general negation: ¬(x ∨y) ≤¬x ∧¬y, ¬(x ∧y) ≥¬x ∨¬y, with ¬0 = 1, ¬1 = 0.
2.
for split negation: ¬(x ∨y) = ¬x ∧¬y, ¬(x ∧y) ≥¬x ∨¬y. It is an additive modal
operator with right-adjoint (multiplicative) negation ∼: (X, ≤)OP →(X, ≤), and the
Galois connection ¬x ≤OP y iff x ≤∼y, such that ∼¬x ≥x and ¬ ∼x ≥x.
3.
for constructive negation: ¬(x ∨y) = ¬x ∧¬y, ¬(x ∧y) = ¬x ∨¬y. It is a self-
adjoint operator, ¬ =∼, with ¬¬x ≥x satisfying the proto De Morgan inequalities
¬(¬x ∨¬y) ≥x ∧y and ¬(¬x ∧¬y) ≥x ∨y.
4.
for De Morgan negation (¬¬x = x): it satisfies also De Morgan laws ¬(¬x ∨¬y) =
x ∧y and ¬(¬x ∧¬y) = x ∨y, and is contrapositive, i. e., x ≤y iff ¬x ≥¬y.
Proof. 1. From the definition of a general negation as monotonic mapping between
posets, ¬ : (X, ≤) →(X, ≤)OP, we have that x ≤y implies ¬x ≤OP ¬y, i. e., it inverts the
ordering, ¬x ≥¬y. Thus, x∧y ≤x and x∧y ≤y implies ¬(x∧y) ≥¬x and ¬(x∧y) ≥¬y,
consequently ¬(x ∧y) ≥¬x ∨¬y. Analogously, x ∨y ≥x and x ∨y ≥y implies ¬(x ∨y) ≤
¬x and ¬(x ∨y) ≤¬y, consequently ¬(x ∨y) ≤¬x ∧¬y. From the property ∀y(0 ≤
y implies ¬0 ≥¬y), and the fact that 1 ∈{z = ¬y | y ∈X} must hold ¬0 ≥1, i. e., ¬0 = 1.
Analogously, we can show also that ¬1 = 0.
2. From the homomorphic definition of the split negation (which is also general,
thus with ¬(x ∧y) ≥¬x ∨¬y) we have that ¬(x ∨y) = ¬x ∨OP ¬y = ¬x ∧¬y, and from
¬0 = 1 = 0OP we conclude that it is a monotone additive mapping, thus it has the
right multiplicative adjoint ∼: (X, ≤)OP →(X, ≤) with the Galois connection ¬ ⊣∼, i. e.,
¬x ≤OP y iff x ≤∼y, i. e., ¬x ≥y iff x ≤∼y. The operators ¬ ∼and ∼¬ are the closure
operators in 𝒫(X); it thus holds that ¬ ∼x ≥x and ∼¬x ≥x.
3. The constructive negation is also a split negation, thus it is an additive modal op-
erator. Let us show that it is also multiplicative; consequently, self-adjoint, i. e., ∼= ¬:
it holds from the lattice homomorphism for meet operators, ¬(x ∧y) = ¬x ∧OP ¬y (i. e.,
= ¬x ∨¬y), and from ¬1 = 0 = 1OP . Thus, ¬¬x = ¬ ∼x ≥x is its constructive property.
From this constructive property and the additive and multiplicative properties, we ob-
tain that ¬(¬x ∧¬y) = ¬¬x ∨¬¬y ≥x ∨y (because ∨is monotone for both arguments).
Analogously, ¬(¬x ∨¬y) = ¬¬x ∧¬¬y ≥x ∧y (because also ∧is monotone for both
arguments), i. e., we obtained the proto De Morgan inequalities.
4. The De Morgan negation is the split negation, which is an evolution, thus we
have that ¬(¬x ∧¬y) = ¬¬x ∨¬¬y = x ∨y and ¬(¬x ∨¬y) = ¬¬x ∧¬¬y = x ∧y. We

A.3 Autoreferential semantics for many-valued modal logics
|
403
have that ¬x ≥¬y implies ¬¬x ≤¬¬y. So from ¬¬x = x, we obtain also that ¬x ≥
¬y implies x ≤y, thus the contraposition x ≤y iff ¬x ≥¬y.
Notice the naturality of this hierarchy, where from the general negation (the most
weak negation) we reach from the antitonicity x ≤y implies ¬x ≥¬y the stronger re-
quirement of the contraposition (x ≤y iff ¬x ≥¬y) for De Morgan (the most strong)
negation. Notice also how we pass from inequalities to stronger equality requirements.
This is valid for any complete lattice where these negations exist (general negations
always exist). If we impose the stronger requirements on complete lattices, as for ex-
ample, distributivity, then De Morgan negations coincide with the strongest classic
Boolean negation (where for all x ∈X, ¬x ∧x = 0 and ¬x ∨x = 1).
The set-based semantics for the split negations (with Galois connections) can be
given by the Bikhoff polarity operator λ : (𝒫(X), ⊆) →(𝒫(X), ⊆)OP, such that for any
U ∈𝒫(X), λU = {x ∈X | ∀u ∈U.((u, x) ∈R)} = {x ∈X | ∀u.(u ∈U implies (u, x) ∈R)},
which in a modal logic can be represented by
ℳ󳀀󳨐x ¬ϕ
iff
∀u.(ℳ󳀀󳨐u ϕ implies (u, x) ∈R)
(the relation R is an incompatibility relation in Lemma 13). The set-based semantics
for the constructive negation is obtained in the case where the incompatibility relation
R is symmetric.
Example 47. The example for any complete lattice (X, ≤) is a general negation given
by ¬x = ⋁Sx where S = {z ∈X | z ∧x = 0}. It is well-defined for complete lattices also
when Sx is an infinite set as, e. g., in fuzzy logic where X = [0, 1] is the closed interval of
reals between 0 and 1, where for ¬0 we have that S0 = {z ∈X | z∧0 = 0} = [0, 1]. Notice
that differently from distributive lattices, generally we have that in nondistributive
lattices ¬x ∉Sx, and ¬x ∧x
̸= 0 (we have that ¬x ∧x ∈{0, x}, i. e., ¬x ∧x = x if x ≤¬x (it
cannot be x > ¬x), and ¬x∧x = 0 where x and ¬x are not comparable; thus, ¬x∧x ≤x).
This negation in distributive lattices corresponds to the pseudo-complement negation
where for any x ∈X, x∧¬x = 0 (thus it cannot be used as paraconsistent negation) and
is “constructive” x ≤¬¬x but ¬¬x ≰x. This negation in distributive algebras, where
x ∨¬x = 1 for any x ∈X is also valid, corresponds to the classic Boolean negation.
We are able to define also “nonconstructive” general negation in any complete
lattice by ¬ = ⋁−↓: X →X where −is the set complement in X, such that ¬x = 0 if
x = 1; 1 otherwise. It is easy to verify that for any x ∈X, ¬x ≤¬x, ¬x∨x = 1 and ¬¬x ≤x.
One example for distributive complete lattice with paraconsistent De Morgan negation
is the fuzzy negation ¬x = 1 −x for x ∈X = [0, 1] (where x ∧¬x = min(x, 1 −x)
̸= 0). In
fact, it is additive and multiplicative (¬(x∧y) = 1−min(x, y) = max(1−x, 1−y) = ¬x∨¬y
and ¬(x ∨y) = 1 −max(x, y) = min(1 −x, 1 −y) = ¬x ∨¬y); thus, it is self-adjoint with
¬¬x = x.
Another paraconsistent De Morgan negation is the bilattice negation [197]: in Bel-
nap’s 4-valued bilattice, it corresponds to the epistemic negation, such that ¬f = t,

404
|
A Appendix
¬t = f, ¬⊥= ⊥and ¬⊤= ⊤, with x ∧¬x
̸= 0 (while the pseudo-complement negation
¬t given in Example 45 (which is not a bilattice negation) is not paraconsistent).
The most simple definition for implication for bounded lattices, which satisfies
the modus ponens (y ⇒x, y ⊢x) and deduction theorem (z, y ⊢x iff z ⊢y ⇒x)
inference rules where ⊢relation is equal to the ≤partial order in the lattice (as in Def-
inition 102, and where the logic entailment “preserves the truth,” i. e., x ⊢y iff x ≤y),
is given by, y ⇒x = 1 if y ≤x; x otherwise. But as we can see in this definition the
value of y does not appear in the resulting value of the implication.
Both values x and y appear in the resulting value of the implication in the case
when the lattice is modular (Dedekind’s lattices) and satisfies ¬x ∧x = 0 for every
x ∈X, when the deduction theorem from left to right does not hold.
The lattice is called modular when x ≤z implies x ∨(y ∧z) = (x ∨y) ∧z.
Proposition 39. Let X be a complete modular lattice where ¬x = ⋁{z | z ∧x = 0} and
¬x ∧x = 0 for every x ∈X, then we define the implication ⇒: X × X →X for any two
elements x, y ∈X as follows:
y ⇒x =def
{
{
{
1,
if y ≤x
¬y ∨x,
if y > x
¬y ∨(x ∧y),
otherwise
(A.1)
Then y ⇒x = 1 iff y ≤x, and holds the modus ponens “rule,” y ∧(y ⇒x) ≤x and half
of the Galois connection, i. e., “z ≤y ⇒x implies z ∧y ≤x.”
If we assume that the consequence pair relation ⊢of this logic coincides with the
partial order ≤of this complete modular lattice (in Definition 102), then in this logic holds
the modus ponens rule y ∧(y ⇒x) ⊢x and the partial deduction theorem, i. e., “z ⊢y ⇒
x implies z, y ⊢x.”
Proof. The definition of the implication is correct, i. e., it is monotonic w. r. t. the first
argument and antitonic w. r. t. the second argument. Moreover, it is similar to the def-
inition of the classic material implication.
Let us show that holds the modus ponens “rule,” i. e., (y ⇒x) ∧y ≤x.
1.1 case when y ≤x: then (y ⇒x) ∧y = 1 ∧y = y ≤x.
1.2 case when y > x: then (y ⇒x) ∧y = (¬y ∨x) ∧y =(by modular property) =
(¬y ∧y) ∨x = 0 ∨x = x.
1.3 case when x and y are not comparable: then (y ⇒x) ∧y = (¬y ∨(x ∧y)) ∧y =(by
the modular property and x ∧y ≤y) = (¬y ∧y) ∨(x ∧y) = 0 ∨(x ∧y) = x ∧y ≤x.
For the deduction theorem, we have that if z ≤y ⇒x, then:
2.1 case when y ≤x: then from z ≤y ⇒x = 1, we have z = 1, so that z∧y = 1∧y = y ≤x.
2.2 case when y > x: then from z ≤y ⇒x = ¬y ∨x, we have (by the monotonicity of
∧), z ∧y ≤y ∧(¬y ∨x) = (by the modular property) = (¬y ∧y) ∨x = 0 ∨x = x.

A.3 Autoreferential semantics for many-valued modal logics
|
405
2.3 case when x and y are not comparable: then from z ≤y ⇒x = ¬y ∨(x ∧y), we
have (by the monotonicity of ∧) that z ∧y ≤y ∧(¬y ∨(x ∧y)) = (by the modular
property) = (¬y ∧y) ∨(x ∧y) = 0 ∨(x ∧y) = x ∧y ≤x.
Now for y ⇒x = 1 and z = 1, and (z ≤y ⇒x implies z ∧y ≤x), we obtain that
(y ⇒x = 1 implies z ∧y = 1 ∧y = y ≤x), and from the definition of ⇒we have that
y ≤x implies y ⇒x = 1. Consequently, in this modular lattice we have y ⇒x = 1 (or
alternatively ⊢y ⇒x) iff y ≤x.
Thus, if we assume that ⊢is equal to ≤, then the MP “rule” y∧(y ⇒x) ≤x coincides
with the modus ponens rule of inference and we obtain ⊢(y ∧(y ⇒x)) ⇒x, i. e., that
(y ∧(y ⇒x)) ⇒x is an axiom. Analogously, the Galois implication becomes half of
the deduction theorem.
This class of modular lattices is strictly more general than the class of orthomod-
ular lattices [303], where it is also required that ¬¬x = x and x ∨¬x = 1 for every x.
In any distributive lattice, where ¬x ∧x = 0 is always satisfied for every x ∈X,
which is also modular; the definition of the implication given in Proposition 39 is al-
ways possible. But as we will see in what follows, in any distributive lattice the modus
ponens and deduction theorem inference rules can be completely satisfied, and the
logic implication can be defined precisely by this requirement.
A.3.3 Heyting’s and multimodal extensions of distributive lattices
The meet and join operators correspond to the logic conjunction and disjunction. In
order to have a full logic language, we need also logic implication and logic negation.
For the class of distributive lattices, we can introduce the negation operator as the
pseudo-complement ¬x = ⋁{z | z ∧x = 0}, with ¬x = 1 iff x = 0, used in intuitionistic
logics. In this section, we will extend this distributive lattice with other unary modal
operators, and based on them, two dual logic operators: the implication ⇀: X×X →X,
and its dual coimplication operator 󴁄󴀼: X × X →X. As we will see, the natural choice
for the implication in complete lattices is the intuitionistic implication, based on the
relative pseudo-complement, which always exists in complete distributive lattices. It
is well known that the relative pseudo-complement x ⇀y = ⋁{z | z ∧x ≤y} and
classic implication satisfy the following left exponential commutative diagram:
(x ⇀y) ∧x
≤
? y
(x 󴁄󴀼y) ∨x
?≥
y
z ∧x
≤
?
=
?
≤
? y
=
?
z ∨x
≥
?
=
??
≥
y
=
?

406
|
A Appendix
where the arrow (x ⇀y) ∧x ≤y is the modus ponens inference rule (x ⇀y), x ⊢y,
while for any x ∈X the additive modal operator lx = _ ∧x : X →X and its right-adjoint
multiplicative operator rx = x ⇀_ : X →X define the Galois connection lx ⊣rx, i. e.,
lx(z) = z ∧x ≤y iff z ≤x ⇀y = rx(y), corresponding to the deduction theorem, z, x ⊢y
iff z ⊢x ⇀y, (where the consequence relation ⊢is equal to ≤, based on the “truth
preservation” principle for valid logic derivations in Definition 102).
The family of operators {lx = _ ∧x | x ∈X} may be considered as the family of
existential modal operators, derived from the basic lattice meet operator ∧, while rx
acts as its dual universal modal operator, but with rx
̸= ¬lx¬ and lx
̸= ¬rx¬.
The fundamental property (from the Galois connection when z = 1) of relative
pseudo-complement is that x ≤y iff x ⇀y = 1 (i. e., x ⊢y iff ⊢x ⇀y ). The right-hand
coexponential commutative diagram is dual (the arrows, i. e., the partial ordering, are
inverted), where the conjunction is replaced by disjunction (coconjunction) and the
implication by its dual coimplication. The dual modal operators, for any x ∈X are the
multiplicative modal operator rc
x = _ ∨x : X →X and its left-adjoint additive operator
lc
x = x 󴁄󴀼_ : X →X define the Galois connection lc
x ⊣rc
x, i. e., lc
x(y) = x 󴁄󴀼y ≤z iff
y ≤z∨x = rc
x(z), corresponding to the codeduction theorem, y ⊢z∨x iff x 󴁄󴀼y ⊢z. The
arrow (x 󴁄󴀼y)∨x ≥y corresponds to the comodus ponens inference rule y ⊢(x 󴁄󴀼y)∨x.
Thus, the coimplication is defined by x 󴁄󴀼y = lc
x(y) = ⋀{z | y ≤z ∨x = rc
x(z)}, such
that, x ≤y iff ¬(y 󴁄󴀼x) = 1 (i. e., x ⊢y iff ⊢¬(y 󴁄󴀼x)).
Thus, x ⇀y is an axiom iff ¬(y 󴁄󴀼x) is an axiom, i. e., ⊢x ⇀y iff ⊢¬(y 󴁄󴀼x).
Notice that in Boolean algebras (distributive lattices with ¬x ∨x = 1 for any x ∈X)
we have that x ⇀y = ¬x ∨y and x 󴁄󴀼y = ¬x ∧y.
Proposition 40. Each complete distributive lattice (X, ≤) with bottom and top element
0, 1, respectively, can be extended into Heyting algebra B = (X, ≤, ∧, ∨, ¬, ⇀, 0, 1) with
implication ⇀defined by x ⇀y = ⋁{z ∈X | z∧x ≤y} and negation ¬ : X →X defined by
¬x = x ⇀0. The corresponding complete distributive lattice (ℱ(X), ⊆, ⋂, ⨄, ̂¬, 󴀚󴀠, {0}, X)
is the Heyting algebra with implication defined, for any U, V ∈ℱ(X), by U 󴀚󴀠V = ⨄{Z ∈
ℱ(X) | Z ⋂U ⊆V} and the negation operator (pseudo-complement) ̂¬, ̂¬U = U 󴀚󴀠{0}.
Then for any x, y ∈X, ̂¬ ↓x = ↓(¬x) and ↓x 󴀚󴀠↓y = ↓(x ⇀y), i. e., the following
representation for any complete Heyting algebra is valid:
(1) ↓: (X, ≤, ∧, ∨, ¬, ⇀, 0, 1) ≃(ℱ(X), ⊆, ⋂, ⨄, ̂¬, 󴀚󴀠, {0}, X),
and canonical case.
(2) ↓+: (X, ≤, ∧, ∨, ¬, ⇀, 0, 1) ≃(X+, ⊆, ⋂, ⋃, ̂¬, 󴀚󴀠, {0}, ̂X),
where the operations ̂¬, 󴀚󴀠are obtained in the same way as in (1) by substituting ℱ(X)
by X+, ⨄by ⋃, and ↓by ↓+.
Proof. We obtain ↓x 󴀚󴀠↓y = ⨄{↓z ∈ℱ(X) |↓z ⋂↓x ⊆↓y} = ⨄{↓z ∈ℱ(X) |↓
(z ∧x) ⊆↓y} = ⨄{↓z ∈ℱ(X) | z ∧x ≤y} = ↓∨{z ∈X | z ∧x ≤y} = ↓(x ⇀y) ∈ℱ(X),
i. e., it is a stable set. Analogously, ̂¬ ↓x = ↓(¬x) ∈ℱ(X) is a stable set.

A.3 Autoreferential semantics for many-valued modal logics
|
407
Now we are able to introduce also the unary modal operators for these Heyting
algebras, based on complete distributive lattices.
Proposition 41. Each Heyting algebra A = (X, ≤, ∧, ∨, ¬, ⇀, 0, 1) has an invariant modal
extension denominated banal Galois algebra G = (X, ≤, ∧, ∨, id, ¬, ⇀, 0, 1), isomorphic to
(ℱ(X), ⊆, ⋂, ⨄, idℱ(X), ̂¬, 󴀚󴀠, {0}, X), where ⨄= ⊡⋃and the identity function id : X →X
is a self-adjoint id ⊣id modal operator correspondent to the universal modal operator
⊡: 𝒫(X) →𝒫(X), whose reduction to the set of stable elements in ℱ(X) ⊂𝒫(X) is the
identity operator idℱ(X) = ↓⋁: ℱ(X) →ℱ(X).
We can extend a Heyting algebra A by any other unary additive modal operator
m : X →X or m : X →XOP (for modal negations in Lemma 14) so that we obtain the
extended representation isomorphism for obtained Galois algebras:
1.
↓: (X, ≤, ∧, ∨, id, ¬, ⇀, m, 0, 1) ≃(ℱ(X), ⊆, ⋂, ⨄, idℱ(X), ̂¬, 󴀚󴀠, ̂m, {0}, X) where ̂m =
↓m ↓−1: ℱ(X) →ℱ(X), and ↓−1= ⋁is inverse homomorphism of ↓.
2.
↓+: (X, ≤, ∧, ∨, id, ¬, ⇀, m, 0, 1) ≃(X+, ⊆, ⋂, ⋃, idX+, ̂¬, 󴀚󴀠, ̂m, {0}, ̂X), obtained in the
same way as in point 1, by substituting ℱ(X) by X+, ⨄by ⋃and ↓by ↓+.
Proof. Let A = (X, ≤, ∧, ∨, ¬, ⇀, 0, 1) be a Heyting algebra. Then the identity function
id : X →X is monotone, i. e., x ≤x′ implies id(x) = x ≤y = id(y), and preserves the
meets: for any x, y ∈X, id(x ∧y) = x ∧y = id(x) ∧id(y). Thus, it is equivalent to the
banal Galois algebra G = (X, ≤, ∧, ∨, id, ¬, ⇀, 0, 1). The left adjoint to id is the operator
m : X →X, such that m(x) = ⋀{z ∈Y | id(z) ≥x} = x, i. e., m = id, so that id is
self-adjoint.
By introducing this identity modal operator, we obtain the Galois banal algebra
identical to the original Heyting algebra, so this is an invariant modal extension for
Heyting algebras, and can be considered as minimal modal extension for Heyting al-
gebras. This fact explains that modal logic is intrinsic in any complete lattice (X, ≤),
and is based on the partial ordering ≤of the poset X.
Let m : X →X be an additive modal operator (monotone which preserves all
meets), then it has left adjoint g : X →X, such that g(x) ≤y iff x ≤m(y). Then
x ≤y implies m(x) ≤m(y), and ↓m(x) ≤↓m(y), i. e., ↓m ↓−1 (↓x) ≤↓m ↓−1 (↓y) with
↓x ⊆↓y ∈ℱ(X), i. e., the monotone operator ↓m ↓−1: ℱ(X) →ℱ(X) exists.
Thus, for any U, V ∈ℱ(X), ↓m ↓−1 (U ⋂V) = ↓m ↓−1 (↓(x ∧y)) = ↓m(x ∧y) =
↓m(x) ⋂↓m(y) = ↓m ↓−1 (↓x) ⋂↓m ↓−1 (↓x). Consequently, ↓m ↓−1 preserves the
meets, and both with a monotone property, which means that it is an additive unary
modal operator in a canonical Heyting algebra. Moreover, from g(x) ≤y iff x ≤m(y) we
obtain ↓g ↓−1 (↓x) ≤↓y iff ↓x ≤↓m ↓−1, i. e., ↓g ↓−1 is the left adjoint of the ↓m ↓−1,
with ↓g ↓−1= ̂¬ ↓g ↓−1 ̂¬. Consequently, ↓m ↓−1 is the universal while ↓g ↓−1 is the
existential modal operator in the canonical Heyting (i. e., Galois) algebra ℱ(X).
Example 48. In Belnap’s bilattice, the conflation—is a monotone function, which pre-
serves all finite meets (and joins) w. r. t. the lattice (ℬ4, ≤t); thus, it is a universal (and

408
|
A Appendix
existential, i. e., m = g = −, because −= ¬t −¬t) modal many-valued operator: “it is
believed that,” which extends the 2-valued belief of the autoepistemic logic as follows:
1.
if ϕ is true, then “it is believed that ϕ,” i. e., −ϕ, is true;
2.
if ϕ is false, then “it is believed that ϕ” is false;
3.
if ϕ is unknown, then “it is believed that ϕ” is inconsistent: it is really inconsistent
to believe in something that is unknown;
4.
if ϕ is inconsistent (that is both true and false), then “it is believed that ϕ” is un-
known: really, we cannot tell anything about believing in something that is incon-
sistent.
This belief modal operator can be used to define the epistemic(bilattice) negation ¬,
as a composition of strong negation ¬t and this belief operator, i. e., ¬ = ¬t−. That
is, the epistemic negation is negation as a modal operator [210] and as a paraconsis-
tent negation [211]. We can introduce also Moore’s autoepistemic operator [197], μ :
ℬ4 →ℬ4, for a Belnap’s bilattice, defined by μ(x) = t if x ∈{⊤, t}; f otherwise.
It is easy to verify that it is monotone w. r. t. the ≤t, that is multiplicative
(μ(x ∧y) = μ(x) ∧μ(y) and μ(t) = t) and additive (μ(x ∨y) = μ(x) ∨μ(y) and μ(f ) = f),
consequently also it is a self-adjoint (contemporary universal and existential) modal
operator, μ = ¬tμ¬t. Notice that differently from the belief modal operator −, Moore’s
modal operator μ is not surjective.
Such an autoepistemic intuitionistic logic, based on Belnap’s bilattice, (ℬ4, ≤t,
∧, ∨, ¬t, ⇀, −, μ, f , t) can be used for logic programming with incomplete and partially
inconsistent information [129]: in such a logic, we use only the epistemic negation
¬ = ¬t−.
We have seen that the for distributive lattices we can define the “strict” impli-
cation (relative pseudo-complement), such that for any two logic formulae ϕ and ψ
holds that ϕ ⇀ψ = ◻(ϕ ⇒c ψ), where ⇒c is the classical extensional implication
such that ϕ ⇒c ψ = ¬cϕ ∨c ψ (here, ¬c and ∨c denote the classic logic negation and
disjunction, respectively) and ◻is not necessarily truth-functional in this distributive
lattice. This “strict” implication is the intuitionistic logic implication, where all ax-
ioms of the classic propositional logic are satisfied, except the axiom for disjunction
¬x ∨x = (x ⇀0) ∨x.
Now we will investigate the subclass of distributive complete lattices, where there
exists the algebraic truth-functional counterpart r◻: X →X, of the logic modal nec-
essary operator ◻, and is an identity, so that ¬x ∨y (i. e., (x ⇀0) ∨y) can be used as
implication x ⇒y. In what follows, we will show that this “or-implication” satisfies
the modus ponens, but generally does not satisfy the deduction theorem.
Proposition 42. The or-implication x ⇒y =def ¬x ∨y satisfies the modus ponens but
not the deduction theorem w. r. t. the entailment in Definition 102, i. e., for any x ∈X,
r = ¬x ∨_ : X →X is a monotone multiplicative operator; thus, right adjoint of the
operator l : X →X, with l
̸= _ ∧x.

A.3 Autoreferential semantics for many-valued modal logics
|
409
Proof. For the or-implication, we have that, from the distributivity, (x ⇒y) ∧x =
(¬x ∨y) ∧x = (¬x ∧x) ∨(y ∧x) = 0 ∨(y ∧x) = y ∧x ≤y, i. e., the modus ponens rule
holds. The operator r = ¬x∨_ is monotone because ∨is monotone for both arguments.
And, from the distributivity, r(y ∧z) = ¬x ∨(y ∧z) = (¬x ∨y)∧(¬x ∨z) = r(y)∧r(z), and
r(1) = ¬x ∨1 = 1; thus, r is multiplicative, so that its left-adjoint operator l is defined
for any y ∈X, by l(y) = ⋀{z | y ≤r(z) = ¬x ∨z}, with l(y)
̸= y ∧x.
The deduction theorem cannot be satisfied because there exist x, y ∈X such that
¬x ∨y < x ⇀y = ⋁{z | z ∧x ≤y}, and if we substitute the relative pseudo-complement
x ⇀y by the “or-implication” ¬x ∨y we are not able to obtain the commutative expo-
nential diagram as in the case of a relative pseudo-complement.
Thus, in order to satisfy the deduction theorem, the or-implication r(y) = ¬x ∨
y must be a right adjoint to l = _ ∧x, i. e., must be equal to the relative pseudo-
complement x ⇀y. In the next proposition, we will define the subclass of complete
distributive lattices where such a condition is satisfied.
Proposition 43. Each complete distributive lattice (X, ≤) with the set of join-irreducible
elements ̂X −{0} equal to the set of atoms X, is a complete distributive lattice, where for
every x, y ∈X, x ⇀y = ¬x ∨y and vice versa.
Proof. First of all, we will show that X = ̂X −{0} is a sufficient condition for x ⇀y =
¬x ∨y. Each atom is join-irreducible, thus X ⊆̂X −{0}. Suppose that X ⊂̂X −{0}.
Then, from the Birkhoff theorem for distributive lattices, ⋁X < ⋁(̂X −{0}) = 1, and
for any atom a ∈X, ¬a < ⋁X (because a < ⋁X), so that ¬a ∨a ≤⋁X ∨a = ⋁X < 1,
while a ⇀a = 1, i. e., we obtain that ¬a ∨a
̸= a ⇀a, which is a contradiction. Thus,
X = ̂X −{0} must be correct.
Let us assume that X = ̂X −{0}, and show that for every x, y ∈X, x ⇀y = ¬x ∨y
must hold. We consider the following cases:
Case 1: When x ≤y: in that case x ⇀y = 1, and from the Birkhoff isomorphism
(Proposition 38), we have that for unique subsets Sx, Sy ⊆X such that x = ⋁Sx, y =
⋁Sy, must hold Sx ⊆Sy, i. e., Sy = Sx ⋃△and −Sx ⋃Sy = −Sx ⋃(Sx ⋃△) = X ⋃△= X.
Thus, x ⇀y = 1 = ⋁X = ⋁(−Sx ⋃Sy) = ⋁(−Sx) ∨(⋁Sy) = ¬x ∨y.
Case 2: When x ≰y and ¬x = 0: Let us show that in this case x = 1 must be
correct. Suppose that ∃x
̸= 1.¬x = 0, then ∄y ⋈x.(y
̸= 0 and y = ¬x), i. e., x = ⋁X
but 1 = ⋁X, and from the Birkhoff bijection (isomorphism) must be x = 1, so that
x ⇀y = 1 ⇀y = ⋁{z | z ∧1 = z ≤y} = y = ¬x ∨y.
This case holds when x > y. In fact, ¬x = 0 must be correct, otherwise the sublat-
tice 0 < ¬x < ¬x ∨x, 0 < y < x < ¬x ∨x is a N5 diagram, which cannot be a sublattice
of modular (thus distributive) lattice (X, ≤).
Case 3: When x ⋈y and ¬x
̸= 0: it is enough to consider only x, y ∉{0, 1}, which
are particular subcases of the cases above. It is easy to verify that for any distributive
lattice it holds that
(**) x ⇀y ≥¬x ∨y (because x ⇀y ≥¬x and x ⇀y ≥y, from y ∈{z | z ∧x ≤y}).

410
|
A Appendix
Suppose that x ⇀y > ¬x ∨y, then there are the following subcases:
3.1 When y > ¬x = ⋁{z | z ∧x = 0}: then ¬x ∨y = y, so that y ≥x (otherwise, ¬x = y),
which is in contradiction with x ⋈y.
3.2 When y < ¬x: then we obtain the following N5 sublattice, 0 < x < x ∨¬x, 0 < y <
¬x < x ∨¬x, which cannot hold for modular (thus distributive) lattices.
3.3 When y = ¬x: then x ⇀y < 1 (because x 󳠠y) and cannot be x ≤x ⇀y. If so, then
x ∧(x ⇀y) = x (modus ponens in distributive lattices), i. e., y = ¬x ≥x, which is
in contradiction with x ⋈y. It cannot be x > x ⇀y (if so, then ¬x ∨y = y ≥x ∧(x ⇀
y) = x ⇀y, which is in contradiction with hypothesis x ⇀y > ¬x ∨y). Thus, we
obtain the N5 sublattice 0 < x < x ∨(x ⇀y), 0 < ¬x ∨y < x ⇀y < x ∨(x ⇀y),
which cannot hold for modular (thus distributive) lattices.
3.4 When y ⋈¬x: then cannot be x ≤x ⇀y (if so, then x = x ∧(x ⇀y) ≤y (from
definition of x ⇀y), which is in contradiction with x ⋈y. Suppose that x ≥x ⇀y,
then x ⇀y = x ∧(x ⇀y) ≤y (from definition of x ⇀y), and from x ⇀y ≥y we
obtain that x ⇀y = y. Thus, ¬x ∨y ≥y = x ⇀y, which is in contrast with (**)
x ⇀y ≥¬x ∨y. Consequently, x ⋈(x ⇀y), and x ∨(x ⇀y) > x ⇀y and x ∨(x ⇀
y) > x (notice that from x ⋈y we have that x ∧y < x and ¬x ∨y > x ∧(¬x ∨y) =
(x ∧¬x) ∨(x ∧y) = 0 ∨(x ∧y) = x ∧y).
Thus, we obtain the N5 sublattice x ∧y < x < x ∨(x ⇀y), x ∧y < ¬x ∨y < x ⇀y <
x ∨(x ⇀y), which cannot hold for modular (thus distributive) lattices.
Remark. If for every x, y ∈X, x ⇀y = ¬x ∨y, then ¬x ∨x = x ⇀x = 1, and from the
general property for distributive lattices, ¬x ∧x = 0, we obtain that the distributive
lattices with the property defined in Proposition 43 are Boolean algebras.
Example 49. The classic logic with 2-valued lattice (2 = {0, 1}, ≤) is a Boolean algebra:
the set of atoms is equal to the set of join-irreducible elements {1}. The Cartesian prod-
uct X = 22 = 2×2 = {(0, 0), (0, 1), (1, 0), (1, 1)}, with (x, y) ≤(v, w) iff x ≤v and y ≤w, is a
Boolean algebra with the set of atoms (i. e., join-irreducible elements) X = {(0, 1), (1, 0)}
and the negation is defined by ¬(x, y) = (¬x, ¬y). It is isomorphic to the Belnap’s
4-valued lattice ℬ4 where f 󳨃→(0, 0), t 󳨃→(1, 1), ⊥󳨃→(0, 1) and ⊤󳨃→(1, 0).
It is easy to verify that every lattice Xn = (2K, ≤), where K ≥2 and (x1, . . . , xk) ≤
(y1, . . . , yk) if for all 1 ≤i ≤K, xi ≤yi, is a Boolean algebra where negation is defined by
¬(x1, . . . , xk) = (¬x1, . . . , ¬xk). But we have also that in each Boolean algebra (𝒫(S), ⊆,
⋂, ⋃, −) where −is the set complement, the set S is exactly the set of atoms. Thus, we
have the following isomorphisms of latices: (2, ≤) ≃(𝒫({a1}), ⊆), (ℬ4, ≤) ≃(22, ≤) ≃
(𝒫({a1, a2}), ⊆), . . . , (2K, ≤) ≃(𝒫({a1, . . . , aK}), ⊆), K ≥2.
A.3.4 Direct autoreferential Kripke semantics for many-valued predicate logics
In Section 5.1.2, we provided the canonical autoreferential Kripke semantics for the
possible worlds given by the subset of join-irreducible truth values. Here, instead, we

A.3 Autoreferential semantics for many-valued modal logics
|
411
will consider the direct autoreferential Kripke semantics, where the set of possible
worlds is equal to the complete set of truth values. We will use the invariant and in-
trinsic modal properties of complete lattices and Heyting algebras in order to obtain
a basic Kripke structure for any such algebra in a general way. By 2 = {0, 1} ⊆X, we
denote the set of classic logic values (false and true, respectively), and by H the Her-
brand base, i. e., the set of all ground atoms in a many-valued predicate logic with
subset of sentences ℒG
mv, with H ⊆ℒG
mv.
Given a many-valued interpretation IH : H →X, we denote by I∗
H : ℒG
mv →X
its unique extension to all formulae, obtained inductively as follows: for any ground
atom, r(c1, . . . , cn) ∈H, I∗
H(r(c1, . . . , cn)) = IH(r(c1, . . . , cn)); for any two sentences, ϕ, ψ ∈
ℒG
mv, I∗
H(ϕ∧ψ) = I∗
H(ϕ)∧I∗
H(ψ); I∗
H(ϕ∨ψ) = I∗
H(ϕ)∨I∗
H(ψ); I∗
H(ϕ ⇒ψ) = I∗
H(ϕ) ⇀I∗
H(ψ);
I∗
H(¬ϕ) = ¬I∗
H(ϕ), and for any algebraic additive modal operator oi, I∗
H(♦iϕ) = oiI(ϕ),
where ♦i is a logic symbol for an existential modal operator (and ◻i is its correspon-
dent universal logic modal operator).
Based on the general representation theorem for many-valued logic in [206], and
the autoreferential assumption, we assume that the set of possible worlds of relational
Kripke frames is the set of algebraic truth values in a complete lattice X of this many-
valued logic, or alternatively, the set of join-irreducible elements ̂X [206] for distribu-
tive complete lattices with normal additive modal operators only. In what follows, we
will present the first approach, which is valid also for nondistributive lattices (for logics
where the implication cannot be a relative pseudo-complement).
From the formal mathematical point of view, we can consider the stable sets in
ℱ(X) as “stable characteristic functions” in 2X (2X denotes the set of all functions from
X to 2), i. e., the functions whose image is a stable set (element in ℱ(X)). Let ℱX ≃ℱ(X)
denote such a set of stable functions, bijective to ℱ(X), whose elements are functions
(i. e., higher-order algebraic truth values [83]). Than any many-valued valuation v, of a
propositional logic with a set of propositional letters in P, based on this set of higher-
order truth values is a mapping v : P →ℱX ⊂2X. So that we are able to define the
valuation IK : P × X →2, such that for any p ∈P, x ∈X, IK(p, x) = v(p)(x) ∈2,
which is identical to Kripke valuations used for standard 2-valued Kripke models of
propositional modal logics, if we accept (by autoreferential assumption) for the set of
possible worlds the set of algebraic truth-values X.
Now we will define the accessibility relation for any given modal operator oi.
Definition 105. Let oi : X →X be a monotonic operator with S = {(oi(x), x) | x ∈X},
and the set Sm ⊆S obtained by elimination of each element (x, y) ∈S if there exists
another element (x, z) ∈S such that z ≤y.
Then we define the accessibility relation for oi by ℛi = Sm ⋃{(x, y) | ∄(x, v) ∈Sm},
where
y = { 0,
if x = 0
z,
if ∃(v, z) ∈Sm.(x ≤v)}
(A.2)

412
|
A Appendix
Notice that if x
̸= 0 and ∄y ∈X.(x ≤oi(y)) then x ∉π1(ℛi), where π1 is the first
projection.
Example 50. In the case of the believe (conflation) modal operator—in Belnap’s bi-
lattice, we obtain that ℛ−= Sm = S = {(f, f ), (⊤, ⊥), (⊥, ⊤), (t, t)}, while for the au-
toepistemic Moore’s operator μ, S = {(f , f ), (f, ⊥), (t, ⊤), (t, t)}, Sm = {(f, f), (t, ⊤)} ⊂
S and ℛμ = {(f , f), (t, ⊤), (⊤, ⊤), (⊤, t), (⊥, ⊤), (⊥, t)}.
Definition 106. Let ̃oi : (X, ≤) →(X, ≤)OP be a split negation operator. We define the
binary relation S as follows:
(a) Set initially S = {(x, ̃oi(x)) | x ∈X}, then
(b) For every y ∈X substitute S by the relation (S −Sy) ⋃{(⋁π1Sy, y)}, where Sy =
{(x, y) | (x, y) ∈S} ⊂S and π1 is the first projection.
Then we define the relation ̃
ℛi for ̃oi by downward completion of S:
S ⊆̃
ℛi
and if (x, y) ∈̃
ℛi and x′ ≤x, y′ ≤y then (x′, y′) ∈̃
ℛi.
The split negation operators ̃oi correspond to the monotone additive operators
̃oi : X →XOP, and the correspondent relations ̃
ℛi are “perp” (Perpendicular or incom-
patibility) relations, introduced by Goldblatt in [304].
Notice that the point (b) for each y ∈X substitutes the equivalence class Sy (of all
x ∈X such that y = ̃oi(x)) by the single pair (x, y) where x = ⋁π1Sy = ⋁{z | (z, y) ∈Sy},
so that the following lemma holds (by π2 we denote the second projection).
Lemma 15. Let S be a binary relation in Definition 106 for a split negation operator ̃oi =
¬ : (X, ≤) →(X, ≤)OP . Then ¬r : (S1, ≤) →(S2, ≤)OP, where S1 = π1S ⊆X, S2 = π2S ⊆X
is the bijective domain reduction of the split operator ¬ (i. e., for each x ∈S1, ¬rx = ¬x),
with its inverse ¬−1
r
: (S2, ≤)OP →(S1, ≤), such that:
1.
for any two x, x′ ∈S1, x < x′ iff ¬x > ¬x′,
2.
for any x ∈X, we have that x′ = ¬−1
r ¬x ∈S1, and such that ¬x = ¬rx′ with x ≤x′.
Proof. Let us show that ¬r is a domain reduction of ¬. In fact, after the actions defined
in point (b) of Definition 106, we have that the cardinalities of S1 and S2 are equal, and
for any y ∈S2 we have the unique pair (x, y) ∈S where x = ⋁π1Sy = ⋁{z | (z, y) ∈Sy}.
Let us show that ¬rx = y: in fact, by definition ¬rx =def ¬x = ¬ ⋁{z | (z, y) ∈Sy} =
⋀{¬z | (z, y) ∈Sy} (from the act that ¬ is a split negation, thus an additive operator)
= y (because from the definition of the equivalence class Sy in Definition 106 we have
that for each (z, y) ∈Sy, ¬z = y). Thus, the definition of ¬r as the domain reduction
of ¬ is correct. We have also that for any two (x, y), (x′, y′) ∈S we have that x
̸= x′ iff
y
̸= y′; thus, ¬r is a bijection, with inverse mapping ¬−1
r
: S2 →S1 defined by, for any
y ∈S2, ¬−1
r (y) = x, where (x, y) ∈S. Thus, ¬−1
r ¬r = idS1 and ¬r¬−1
r
= idS2. Consequently,
also ¬−1
r is monotone, i. e., for any two ¬rx, ¬rx′ ∈S2, if ¬rx >OP ¬rx′ (i. e., ¬rx < ¬rx′),

A.3 Autoreferential semantics for many-valued modal logics
|
413
then ¬−1
r (¬rx) = x > ¬−1
r (¬rx′) = x′, and from the monotonicity of ¬ (and its domain
reduction ¬r) we obtain that the point (1) of this lemma holds.
Point (2): from the definition of S, x′ is the join of all elements in π1Sy in an equiv-
alence class Sy, where y = ¬x, with x ∈π1Sy, so that x ≤x′.
Example 51. Finite cases: In the case of the bilattice (epistemic) negation operator ¬ in
Belnap’s bilattice, which is a paraconsistent De Morgan negation (thus split negation
also), we obtain
S = {(f, t), (⊤, ⊤), (⊥, ⊥), (t, f)},
with S1 = S2 = X = ℬ4, ¬r = ¬−1
r
= ¬,
and
̃
ℛ¬ = {(f, f), (f, ⊥), (f, ⊤), (f, t)(⊥, ⊥), (⊥, f), (⊤, ⊤), (⊤, f), (t, f)}.
Infinite cases: In the case of the fuzzy logic, ¬x = 1 −x, it is a paraconsistent De Mor-
gan negation, thus also split negation, with S = {(x, 1 −x) | x ∈X = [0, 1]}. Thus,
from Definition 106, we obtain a symmetric infinite incompatibility relation ̃
ℛ¬ as in
the example above: it must be so because both negations are self-adjoint, so that this
incompatibility relation must be symmetric. Other cases for paraconsistent split nega-
tions are given in belief and confidence level logics and their fuzzy extensions [202].
Now we are able to define the many-valued relational Kripke-style semantics (the
2-valued Kripke-style semantics is presented in [204]) for a predicate modal logic ℒmv
based on the modal Heyting algebras in Proposition 41.
Definition 107. Given a predicate modal logic ℒmv, based on the modal Heyting alge-
bra in Proposition 41, we define the Kripke model for this logic ℳ= (K, 𝒟, IK) with the
frame K = ⟨(X, ≤), {ℛi, ̃
ℛi}⟩, where each ℛi, ̃
ℛi, i = 1, 2, . . . , is the accessibility relation
for existential (additive) modal operators oi and negation modal operator ̃
oi, respec-
tively, given in Definition 105, with a decreasing valuation IK : X × P →⋃n<ω2Sn, such
that for any predicate symbol r ∈P with arity n, and tuple of constants (c1, . . . , cn) ∈𝒟n
(i. e., ground atom r(c1, . . . , cn) ∈H), there exists a particular value y ∈X, such that
∀x ∈X(IK(x, r)(c1, . . . , cn) = 1 iff x ≤y).
Then, for any world x ∈X and assignment g, we define the many-valued satisfac-
tion relation for a formula ϕ ∈ℒmv, denoted by ℳ󳀀󳨐x,g ϕ, as follows:
1.
ℳ󳀀󳨐x,g r(x1, . . . , xn) iff IK(x, r)(g(x1), . . . , g(xn)) = 1,
2.
ℳ󳀀󳨐x,g ϕ ∧ψ iff ℳ󳀀󳨐x,g ϕ and ℳ󳀀󳨐x,g ψ,
3.
ℳ󳀀󳨐x,g ϕ ∨ψ iff ∀y((y ≤x and not ℳ󳀀󳨐y,g ϕ) implies ℳ󳀀󳨐y,g ψ),
4.
ℳ󳀀󳨐x,g ϕ ⇒ψ iff ∀y((y ≤x and ℳ󳀀󳨐y,g ϕ) implies ℳ󳀀󳨐y,g ψ),
5.
ℳ󳀀󳨐x,g ¬ϕ iff ℳ󳀀󳨐x,g ϕ ⇒⊥, where ⊥is a contradiction formula,
6.
ℳ󳀀󳨐x ♦iϕ iff ∃y((x, y) ∈ℛi and ℳ󳀀󳨐y ϕ), for any monotone modal operator ♦i.
7.
ℳ󳀀󳨐x∼i ϕ iff ∀y(ℳ󳀀󳨐y ϕ implies (y, x) ∈̃
ℛi), for any modal negation operator ∼i,
so that ‖ ∼i ϕ‖ = λ‖ϕ‖ = {x | ∀y ∈‖ϕ‖.(y, x) ∈̃
ℛi)}.

414
|
A Appendix
By definition, ℳis a Kripke-style model of a logic ℒmv if it satisfies all formulae in
ℒmv.
The reason that we use both negations, the pseudo-complement ¬ and modal
(weak) negations ∼i is justified by necessity to consider also the paraconsistent many-
valued logics in which ¬ cannot be used as paraconsistent negation (in Proposi-
tion 45).
Notice that in the world x = 0 (the bottom element in X) every sentence ϕ is sat-
isfied: because of that we will denominate this world by a trivial world. The seman-
tics for implication is similar (but different) to the Kripke style definition for intuition-
istic implication (where the time sequence for the accessibility relation is used, up-
ward (in the future) closed and based on the principle “persistence of truth in time”
[305]). Otherwise, the definition for disjunction is not standard. In fact, it holds that
(ℳ󳀀󳨐x,g ϕ or ℳ󳀀󳨐x,g ψ) implies ℳ󳀀󳨐x,g ϕ ∨ψ, but not vice versa. It results from the
fact that the disjunction in the canonical representation is the set operator ⨄, (gener-
ally) different from the standard set union ⋃. The satisfaction for disjunction can be
given alternatively by
3.(a) ℳ󳀀󳨐x,g ϕ ∨ψ iff ∃y, z(x ≤y ∨z and ℳ󳀀󳨐y,g ϕ and ℳ󳀀󳨐z,g ψ).
So, the conjunction disjunction and implication are defined independently as in in-
tuitionistic logic [306]. In fact, the Definition 107 for a Kripke model of many-valued
modal logics is similar but not equal (downward closed instead of upward closed
hereditary subsets, and the worlds are not the time-points as in Kripke interpretation
but the autoreferential truth-levels of credibility) to that of Kripke-style intuitionistic
logic because not only the implication (as in [306]) but also the disjunction is inten-
sional: it is based on Lewis’s approach, as discussed in Remark after Proposition 37,
where he distinguishes the standard or extensional logic connectives ∧c, ∨c, ⇒c, from
the intensional logic connectives ∧, ∨, ⇒, such that x ⊙y = ◻(x ⊙c y), for ⊙∈{∧, ∨, ⇒}
where ◻is “necessarily” a universal logic modal operator corresponding to the alge-
braic modal operator ⊡: 𝒫(X) →𝒫(X).
The accessibility relation for the multiplicative modal operator “necessary” ◻is
the partial order ≥=≤−1 in Definition 107. For its left-adjoint (additive) dual modal op-
erator ⬦, ⬦⊣◻, such that the Galois connection ⬦x ≤y iff x ≤◻y holds, the accessi-
bility relation can be obtained by the gaggle theory of Dunn [236, 307], for this simple
Galois connection with the following traces and tonicities:
function
tonicity
trace
◻
+
+ 󳨃→+
⬦
+
−󳨃→−
From [307], it holds that the binary accessibility relations of these two unary adjoint
operators are mutually inverse, i. e., ℛ⬦= (ℛ◻)−1 = (X × X −ℛ◻)−1 = X × X−≤.

A.3 Autoreferential semantics for many-valued modal logics
|
415
It is intuitive also because these two operators are usually given as two mappings
⬦: (X, ≤) →(X, ≤) and ◻: (X, ≤)OP →(X, ≤)OP, where (X, ≤)OP is a poset with inverted
arrows (ordering).
We will consider that the downward closure for the satisfaction holds for each
ground formula ϕ/g, i. e., if ℳ󳀀󳨐x,g ϕ than for every y ≤x holds ℳ󳀀󳨐y,g ϕ: it is
satisfied for all ground atoms, directly from the definition of the mapping IK in Def-
inition 107, and will be proven in Theorem 17 below. Thus, we can use the standard
Kripke definition for the satisfaction relation for these intensional connectives, i. e.:
1.
For the principal modal operator ◻:
ℳ󳀀󳨐x,g ◻r(x1, . . . , xn)
iff
∀y(y ≤x implies ℳ󳀀󳨐y,g r(x1, . . . , xn))
iff
ℳ󳀀󳨐x,g r(x1, . . . , xn).
Thus, it is invariant for ground atoms. Moreover, for any ground formula ϕ/g such
that ‖ϕ/g‖ = {x | ℳ󳀀󳨐x,g ϕ} ∈ℱ(X), i. e., ‖ϕ/g‖ = ↓α for some α ∈X, we have that
ℳ󳀀󳨐x,g ◻ϕ iff ∀y(y ≤x implies ℳ󳀀󳨐y,g ϕ) iff ∀y(y ≤x implies y ∈↓α) iff x ≤α iff
ℳ󳀀󳨐x,g ϕ. That is, ◻is an identity.
But if ‖ϕ/g‖ ∉ℱ(X), then ◻is not an identity, but ‖◻ϕ/g‖ = ⊡‖ϕ/g‖ ∈ℱ(X).
Also, in the case of the dual, existential, modal operator ⬦, we have for that any
ground formula ϕ/g such that ‖ϕ/g‖ = {x | ℳ󳀀󳨐x,g ϕ} ∈ℱ(X), i. e., ‖ϕ/g‖ = ↓α for
some α ∈X holds ℳ󳀀󳨐x,g ⬦ϕ iff ∃y(x ≤y and ℳ󳀀󳨐y,g ϕ) iff ∃y(x ≤y and y ∈↓α)
iff x ≤α iff ℳ󳀀󳨐x,g ϕ. That is, ⬦is an identity.
2.
For the intensional conjunction:
ℳ󳀀󳨐x,g ϕ ∧ψ
iff
ℳ󳀀󳨐x,g ◻(ϕ ∧c ψ)
iff
∀y(y ≤x implies ℳ󳀀󳨐y,g ϕ ∧c ψ)
iff
∀y(y ≤x implies (ℳ󳀀󳨐y,g ϕ and ℳ󳀀󳨐y,g ψ))
iff
ℳ󳀀󳨐x,g ϕ and ℳ󳀀󳨐x,g ψ.
Thus, the intensional conjunction has the same semantics as the extensional con-
junction.
3.
For the intensional implication:
ℳ󳀀󳨐x,g ϕ ⇒ψ
iff
ℳ󳀀󳨐x,g ◻(ϕ ⇒c ψ)
iff
∀y(y ≤x implies ℳ󳀀󳨐y,g ϕ ⇒c ψ)
iff
∀y(y ≤x implies (ℳ󳀀󳨐y,g ϕ implies ℳ󳀀󳨐y,g ψ))
iff
∀y((y ≤x and ℳ󳀀󳨐y,g ϕ) implies ℳ󳀀󳨐y,g ψ).
Here, ‖(ϕ ⇒c ψ)/g‖ = {y | ℳ󳀀󳨐y,g ϕ implies ℳ󳀀󳨐y,g ψ} ∉ℱ(X), but we have
‖◻(ϕ ⇒c ψ)/g‖ = ⊡‖(ϕ ⇒c ψ)/g‖ = ⊡(⋃{Z | Z ⋂‖ϕ/g‖ ⊆‖ϕ/g‖}) ∈ℱ(X).
If ‖ϕ/g‖, ‖ψ/g‖ ∈ℱ(X), then ‖◻(ϕ ⇒c ψ)/g‖ = ‖ϕ/g‖ 󴀚󴀠‖ϕ/g‖ ∈ℱ(X).

416
|
A Appendix
4.
For the intensional disjunction:
ℳ󳀀󳨐x,g ϕ ∨ψ
iff
ℳ󳀀󳨐x,g ◻(ϕ ∨c ψ)
iff
∀y(y ≤x implies ℳ󳀀󳨐y,g ϕ ∨c ψ)
iff
∀y(y ≤x implies (ℳ󳀀󳨐y,g ϕ or ℳ󳀀󳨐y,g ψ))
iff
∀y(y ≤x implies (not ℳ󳀀󳨐y,g ϕ implies ℳ󳀀󳨐y,g ψ))
iff
∀y((y ≤x and not ℳ󳀀󳨐y,g ϕ) implies ℳ󳀀󳨐y,g ψ).
Here, ‖(ϕ ∨c ψ)/g‖ = {y | ℳ󳀀󳨐y,g ϕ or ℳ󳀀󳨐y,g ψ} = ‖ϕ/g‖ ⋃‖ψ/g‖ ∉ℱ(X);
thus, ◻is not an identity, but holds that ‖◻(ϕ ∨c ψ)/g‖ = ⊡‖(ϕ ∨c ψ)/g‖ =
⊡(‖ϕ/g‖ ⋃‖ψ/g‖) = ‖ϕ/g‖ ⨄‖ψ/g‖ ∈ℱ(X).
Notice that in the case when (X, ≤) is a distributive lattice (when we are using also
logic implication and negation defined as in Heyting algebras) and we are using for
the set of worlds the set ̂X of join-irreducible elements in X (the canonical alternative
for autoreferential assumption, based on the representation isomorphisms in point 2
of Propositions 40 and 41), we obtain the standard semantics for extensional disjunc-
tion, i. e., ℳ󳀀󳨐x,g ϕ ∨ψ iff ℳ󳀀󳨐x,g ϕ or ℳ󳀀󳨐x,g ψ. In this particular case when the set
of worlds is the set ̂X ⊂X, for the logic connectives ∧, ∨, ¬, ⇒, we obtain Kripke-style
semantics of intuitionistic logic, but with inverted accessibility relation, of complete
distributive lattice for the operator ◻. This version is presented in [206] for the com-
plete distributive lattices with additive normal modal operators.
Based on all these considerations, we can see how important a role the closure op-
erator and universal “necessity” operator ⊡have, based on the Dedekind–McNeile Ga-
lois connection over partial order of a complete lattice (X, ≤) of algebraic truth values.
The next proposition shows that there is a bijective correspondence (see also in [206])
between the algebraic many-valued Herbrand models of a modal logic ℒmv, based on
the complete lattice of truth values (X, ≤), and the relational (or Kripke-style) models
(based on the set of possible worlds equal to the set of truth values X) of the same
logic ℒmv.
Proposition 44. For any given Kripke model of a modal predicate logic ℒmv, based on
a complete lattice (X, ≤) of truth values, which satisfies Definition 107, we are able to
obtain the algebraic many-valued Herbrand model IH : H →X of the same logic ℒmv,
such that for any ground atom r(c1, . . . , cn) ∈H holds:
(a) IH(r(c1, . . . , cn)) = ⋁{x ∈X | ℳ󳀀󳨐x r(c1, . . . , cn)}.
Vice versa, for any given algebraic many-valued Herbrand model IH : H →X of a logic
ℒmv, we are able to obtain the Kripke model of ℒmv, which satisfies Definition 107, such
that for any world x ∈X, a predicate symbol r ∈P with arity n, and a tuple of constants
(c1, . . . , cn) ∈Sn holds:
(b) IK(x, r)(c1, . . . , cn) = 1 iff x ≤IH(r(c1, . . . , cn)).

A.3 Autoreferential semantics for many-valued modal logics
|
417
Easy to verify, directly from Definition 107, the next theorem shows the clear rela-
tionships between the representation algebra based on the complete lattice (ℱ(X), ⊆)
and the Kripke-style model of a many-valued modal logic ℒmv.
Theorem 17. Let K = ⟨(X, ≤), {ℛi}⟩be a frame and IH : H →X be a Herbrand valuation
of a many-valued logic ℒmv, given by Definition 107. Then, for a given assignment g and
for any formula ϕ, the set of worlds where ϕ/g (a formula ϕ where all variables are
substituted by the assignment g) holds is
‖ϕ/g‖ = ↓(I∗
H(ϕ/g)) ∈ℱ(X).
Proof. By structural induction: We have that x ∈‖ϕ/g‖ iff ℳ󳀀󳨐x ϕ/g iff ℳ󳀀󳨐x,g ϕ.
1.
For any ground atom r(c1, . . . , cn) ∈H, x ∈X, ℳ󳀀󳨐x,g
r(c1, . . . , cn) iff x ≤
I(r(c1, . . . , cn)), thus ‖r(c1, . . . , cn)‖ = ↓IH(r(c1, . . . , cn)). Notice that it can be ob-
tained directly from the equation (a) of Proposition 44, i. e., by applying the
operator ↓to both sides of this equation (a) we obtain ↓IH(r(c1, . . . , cn)) = ↓⋁{x ∈
X | ℳ󳀀󳨐x r(c1, . . . , cn)} = {x ∈X | ℳ󳀀󳨐x r(c1, . . . , cn)} = ‖r(c1, . . . , cn)‖.
Suppose by hypothesis that ‖ϕ/g‖ = ↓(I∗
H(ϕ/g)) and ‖ψ/g‖ = ↓(I∗
H(ψ/g)), then:
2.
From ℳ󳀀󳨐x ϕ/g ∧ψ/g, iff ℳ󳀀󳨐x ϕ/g and ℳ󳀀󳨐x ψ/g, holds that x ∈‖ϕ/g ∧ψ/g‖ iff
x ∈‖ϕ/g‖ ⋂‖ψ/g‖, (and by structural induction hypothesis) iff x ∈↓I∗
H(ϕ/g) ⋂↓
I∗
H(ψ/g) = ↓I∗
H(ϕ/g ∧ψ/g). Thus, ‖ϕ/g ∧ψ/g‖ = ↓I∗
H(ϕ/g ∧ψ/g).
3.
From ℳ󳀀󳨐x,g ϕ ∨ψ iff ∀y((y ≤x and not ℳ󳀀󳨐y,g ϕ) implies ℳ󳀀󳨐y,g ψ) iff ∀y(y ≤
x and not y ≤I∗
H(ϕ/g) implies y ≤I∗
H(ψ/g) iff ∀y((y ∈↓x ⋂(X −‖ϕ/g‖) implies y ∈
‖ψ/g‖)) iff ↓x ⋂(X−‖ϕ/g‖) ⊆‖ψ/g‖, so that S = ‖ϕ/g∨ψ/g‖ = {x |↓x ⋂(X−‖ϕ/g‖) ⊆
‖ψ/g‖}.
Then S = idℱ(X)(S) = ↓⋁S = ⨄↓S (from the homomorphism ↓) = ⨄x∈S ↓x = ⨄{↓
x |↓x ⋂(X −‖ϕ/g‖) ⊆‖ψ/g‖} = ↓⋁⋃{↓x |↓x ⋂(X −‖ϕ/g‖) ⊆‖ψ/g‖} = (from (1)
in Proposition 37) = ↓⋁((X −(X −‖ϕ/g‖)) ⋃‖ψ/g‖) = ↓⋁(‖ϕ/g‖ ⋃‖ψ/g‖) = (from
inductive hypothesis) = ↓⋁(↓I∗
H(ϕ/g) ⋃↓I∗
H(ψ/g)) = (from the homomorphism ↓)
= ↓⋁↓(I∗
H(ϕ/g) ∨I∗
H(ψ/g)) = ↓(I∗
H(ϕ/g) ∨I∗
H(ψ/g)).
That is, ‖ϕ/g ∨ψ/g‖ = ↓I∗
H(ϕ/g ∨ψ/g).
The proof for the alternative Definition 3(a) is as follows:
From ℳ󳀀󳨐x,g ϕ ∨ψ, iff ∃y, z(x ≤y ∨z and ℳ󳀀󳨐y,g ϕ and ℳ󳀀󳨐z,g ψ), holds
that x ∈‖ϕ/g ∨ψ/g‖ iff (by structural induction hypothesis) ∃y, z(x ≤y ∨z and y ≤
I∗
H(ϕ/g) and z ≤I∗
H(ψ/g)) iff x ≤⋁{y ∨z | y ≤I∗
H(ϕ/g) and z ≤I∗
H(ψ/g)} = I∗
H(ϕ/g) ∨
I∗
H(ψ/g) = I∗
H(ϕ/g ∨ψ/g). Thus, ‖ϕ/g ∨ψ/g‖ = ↓I∗
H(ϕ/g ∨ψ/g).
4.
From x ∈‖ϕ/g ⇒ψ/g‖ iff ℳ󳀀󳨐x ϕ/g ⇒ψ/g iff ∀y(((x ≤y and ℳ󳀀󳨐y ϕ/g) implies
ℳ󳀀󳨐y ψ/g)) iff ∀y(y ≤x and y ≤I∗
H(ϕ/g) implies y ≤I∗
H(ψ/g)) iff ∀y(y ∈↓x ⋂‖ϕ/g‖
implies y ∈‖ψ/g‖) iff ↓x ⋂‖ϕ/g‖ ⊆‖ψ/g‖, so that S = ‖ϕ/g ⇒ψ/g‖ = {x |↓
x ⋂‖ϕ/g‖ ⊆‖ψ/g‖}.

418
|
A Appendix
Then S = idℱ(X)(S) = ↓⋁S = ⋃↓S (from the homomorphism ↓) = ⋃x∈S ↓x = ⋃{↓
x |↓x ⋂‖ϕ/g‖ ⊆‖ψ/g‖} = ⋃{S′ ∈ℱ(X) | S′ ⋂↓I∗
H(ϕ/g) ⊆↓I∗
H(ψ/g)} == ↓I∗
H(ϕ/g) 󴀚󴀠↓
I∗
H(ψ/g) = ↓(I∗
H(ϕ/g) ⇀I∗
H(ψ/g)) = ↓I∗
H(ϕ/g ⇒ψ/g) (from the homomorphism of the
valuation I∗
H). Consequently, ‖ϕ/g ⇒ψ/g‖ = ↓I∗
H(ϕ/g ⇒ψ/g).
5.
For any additive algebraic modal operator oi, we obtain the existential logic modal
operator ♦i, so that ℳ󳀀󳨐x ♦iϕ/g iff ∃y ∈X((x, y) ∈ℛi and ℳ󳀀󳨐y ϕ/g), iff
∃y((x, y) ∈ℛi and y ≤I∗
H(ϕ/g)).
Let us denote it by α = I∗
H(ϕ/g), then the condition above, (∗)∃y((x, y) ∈ℛi and y ≤α),
is satisfied in one of the following possible cases:
Case 5.1.1 when x ∈π1(Sm). Then (∗) corresponds to x = oi(y) and oi(y) ≤oi(α),
(because oi is monotone), i. e., x ≤oi(α), i. e., x ∈↓oi(α);
Case 5.1.2 when x ∉π1(Sm), but (x, y) ∈ℛi. Then ∃(v, y) ∈Sm.(x ≤v), i. e., x ≤v =
oi(y), and from (∗), y ≤α, and from the monotonicity of oi, oi(y) ≤oi(α), we obtain
x ≤oi(α), i. e., x ∈↓oi(α).
Vice versa, let us show that for any x ∈↓oi(α), the condition (∗) is satisfied:
Case 5.2.1 when x = oi(α). We have (oi(α), α) ∈Sm ⊆ℛi; thus, y = α and (∗) is
satisfied;
Case 5.2.2 when x < oi(α) and ∃y.x = oi(y). Then (x, y) ∈Sm ⊆ℛi. Suppose that
y > α, then from the monotonicity of oi it will hold that oi(y) > oi(α) > x, which is in
contrast with x = oi(y). So, it must hold that y ≤α, and (∗) is satisfied;
Case 5.2.3 when x < oi(α) and ∄y.x = oi(y). Then (z, y) ∈Sm ⊆ℛi such that z =
oi(y) ≥x, and consequently, oi(α) ∈{oi(y1) | (x, y1) ∈ℛi\Sm}, and (x, y) ∈ℛi\Sm for
y = α (from the fact that x ≤oi(y) = oi(α)), so that (∗) is satisfied.
Thus, we have ‖♦iϕ/g‖ = ↓oi(α) = ↓oi(I∗
H(ϕ/g)) = ↓I∗
H(♦iϕ/g).
6.
For any negation operator ̃oi, we obtain the modal operator ∼i, and we have
ℳ󳀀󳨐x∼i ϕ iff ∀y(ℳ󳀀󳨐y ϕ implies (y, x) ∈̃
ℛi) iff ∀y(y ∈‖ϕ‖ implies (y, x) ∈̃
ℛi) iff
(by inductive hypothesis ‖ϕ‖ = ↓α where α = I∗
H(ϕ/g) )∀y(y ≤α implies (y, x) ∈
̃
ℛi), i. e., ‖ ∼i ϕ‖ = {x | ∀y(y ≤α implies (y, x) ∈̃
ℛi)}.
It is easy to verify that for each x ≤¬α and y ≤α, (y, x) ∈̃
ℛi (from Definition 106 and
the point 2 of Lemma 15), we have that x ∈‖ ∼i ϕ‖. Thus, ‖ ∼i ϕ‖ ⊇↓α.
Suppose that there exists x > ¬α such that x ∈‖ ∼i ϕ‖. In that case, there are two
possible cases (here S is the binary relation in Lemma 15 of this negation operator):
6.1 There exists β ∈π1S ⊆π1̃
ℛi such that x = ¬β > ¬α: then (from the point 1 of
Lemma 15) β < α, and (β, ¬β) ∈S ⊆̃
ℛi, but (α, ¬β) ∉̃
ℛi (from Definition 106)
so that ∀y(y ≤α implies (y, ¬β) ∈̃
ℛi) is false (the case when y = α cannot be
satisfied), in contradiction with the hypothesis.
6.2 Does not exist β such that x = ¬β > ¬α: thus (α, x) ∈̃
ℛi only if ∃α1.¬α1 > x with
(α1, ¬α1) ∈S ⊆̃
ℛi (from Definition 106), but from ¬α1 > x > ¬α we have (from the
point 1 of Lemma 15) that α1 < α, so that (α, α1) ∉̃
ℛi, and consequently, (α, x) ∉̃
ℛi.

A.3 Autoreferential semantics for many-valued modal logics
|
419
Thus, ∀y(y ≤α implies (y, x) ∈̃
ℛi) is false, in contradiction with the hypothesis.
Consequently, ‖ ∼i ϕ‖ = ↓α.
Remark. Notice that in the proof for existential modal operators, we used only the
monotonic property for these operators and not its additive property. That means that
the definition of the satisfaction for existential modal operators (point 6 in Defini-
tion 107) can be extended to any monotonic operator, and particularly to universal
modal operators also. In this case, we are able to have the same existential defini-
tion for both joined modal operators, but with each one based on its proper specific
accessibility relation. This is important if we consider that the satisfaction for uni-
versal modal operators ℳ󳀀󳨐x ◻iϕ/g is not given by the classic definition, i. e., by
∀y ∈X((x, y) ∈ℛ♦i implies ℳ󳀀󳨐y ϕ/g), where ℛ♦i is the accessibility relation given
by Definition 105 for the existential modal operator. It can not be defined by ℳ󳀀󳨐x
¬♦i¬ϕ/g because in distributive lattices, for two adjoint modal operators ♦i ⊣◻i gen-
erally does not hold ♦i = ¬◻i¬ and ◻i = ¬♦i¬. Thus, we can define the semantics for
the satisfaction of universal modal operator by this new way,
7(a) ℳ󳀀󳨐x ◻iϕ/g iff ∃y ∈X((x, y) ∈ℛ◻i and ℳ󳀀󳨐y ϕ/g),
where ℛ◻i is an accessibility relation obtained by Definition 105 applied to the univer-
sal modal operator ◻i, such that ℛ◻i
̸= ℛ♦i, or by dual result, when ♦i is an additive
modal operator, obtained for accessibility relations of adjoint unary modal operators
and for the “gaggle” theory of Dunn (here A denotes the set complement of A).
7(b) ℳ󳀀󳨐x ◻iϕ/g iff ∀y ∈X((x, y) ∈(ℛ♦i)−1 implies ℳ󳀀󳨐y ϕ/g).
This is really a new result, which generalizes the relational semantics for normal
Kripke modal logic: for any couple of adjoint modal operators l ⊢r (Galois connec-
tion), which results in a normal Kripke modal logic, we are able to define the sat-
isfaction relation of these two (universal versus existential) operators based on two
accessibility relations but in the same standard way used only for existential modal
operators.
This result is particularly important when we are dealing with positive modal
logic [193, 294] (without negation) for which Definition 105 holds also if we substitute
point 7, with this new definition for universal modal operator, based on its proper
accessibility relation, which is different from the relation used for a existential modal
operator.
Example 52. In the case of Belnaps’ 4-valued logic, we can verify that ℳ󳀀󳨐⊥,g ¬t⊤
iff ℳ󳀀󳨐⊥,g (⊤⇒0) iff ∀y((y ≤⊥and ℳ󳀀󳨐y,g ⊤) implies ℳ󳀀󳨐y,g 0), which is true
(consider that ℳ󳀀󳨐y,g 0 is true only if y = f , and false otherwise); thus, ‖¬t⊤‖ =
↓IH(¬t⊤) = ↓IH(⊥) = ↓⊥= {f, ⊥}. While ℳ󳀀󳨐⊤,g ¬t⊤iff ℳ󳀀󳨐⊤,g ⊤⇒0 iff ∀y((y ≤
⊤and ℳ󳀀󳨐y,g ⊤) implies ℳ󳀀󳨐y,g 0) is false (consider the case when y = ⊤, then y ≤
⊤and ℳ󳀀󳨐y,g ⊤is true, while ℳ󳀀󳨐⊤,g 0 is false), consequently ⊤∉‖¬t⊤‖. The Kripke

420
|
A Appendix
frame for autoepistemic intuitionistic logic based on Belnap’s 4-valued logic is very
simple, with two accessibility relations:
ℛ−= {(f , f), (⊤, ⊥), (⊥, ⊤), (t, t)},
for the belief (conflation) modal operator, and
ℛμ = {(f , f ), (t, ⊤), (⊤, ⊤), (⊤, t), (⊥, ⊤), (⊥, t)},
for the Moore’s autoepistemic modal operator μ. Both of them can be obtained from
Definition 105 by applying it independently to the existential or universal operator,
just because in these two cases they are self-adjoint (equal). Let us consider a more
general case:
M
L
t
t
⊤
⊤
t
⊤
⊥
⊥
f
f
⊥
f
It is easy to verify that the operator M is the multiplicative monotone operator (i. e.,
M(α ∧β) = M(α) ∧M(β) and M(t) = t), used for universal modal logic operator ◻. The
operator L is its correspondent (by Galois connection L ⊣M) additive operator (i. e.,
L(α∨β) = L(α)∨L(β) and L(f) = f ), used for an existential modal logic operator ♦, such
that M = ¬tL¬t (because the Belnap’s lattice ℬ4 is a Boolean algebra) with ¬t¬t = id an
identity. The accessibility relations for these two monotone operators, obtained from
Definition 105 are ℛ♦= {(⊤, ⊤), (f, f )} and ℛ◻= {(t, ⊤), (⊤, ⊤), (⊤, t), (⊥, f), (f , f)}, and
we will denominate them as joint accessibility relations. Thus, for the existential modal
operator
ℳ󳀀󳨐x ♦ϕ/g
iff
∃y ∈X((x, y) ∈ℛ♦and ℳ󳀀󳨐y ϕ/g),
while for the universal modal operator we have two alternative definitions:
ℳ󳀀󳨐x ◻ϕ/g
iff
ℳ󳀀󳨐x ¬♦¬ϕ/g iff ∀y ∈X((x, y) ∈ℛ♦implies ℳ󳀀󳨐y ϕ/g),
based on the relation ℛ♦, or independently, based on accessibility relation ℛ◻,
ℳ󳀀󳨐x ◻ϕ/g
iff
∃y ∈X((x, y) ∈ℛ◻and ℳ󳀀󳨐y ϕ/g).
Finally, from the canonical representation for a complete distributive lattice based
modal intuitionistic logics in Proposition 41, we obtained that the isomorphism, be-
tween the original Galois algebra G = (X, ≤, ∧, ∨, ¬, ⇀, {oi}i≤ω, 0, 1) with unary modal
operators in {oi}i≤ω and its canonical representation algebra GK = (ℱ(X), ⊆, ⋂, ⨄, ̂¬, 󴀚󴀠,

A.3 Autoreferential semantics for many-valued modal logics
|
421
{̂oi}i≤ω, 0, 1), where ̂oi = ↓oi ↓−1, i = 1, 2, . . . , corresponds to the representation of any
ground formula ϕ/g by the set of worlds ‖ϕ/g‖ in the canonical Kripke model for the
modal algebra G. So, e. g., a ground term ϕ/g∧ψ/g in a predicate modal logic ℒ(based
on the Galois algebra G) with a many-valued Herbrand model IH : H →X, corresponds
to the set ‖ϕ/g‖ ⋂‖ψ/g‖ in the canonical algebra GK ≃G, where ‖ϕ/g‖ = ↓y ( y is an
algebraic truth value in a Herbrand model I for the ground formula ϕ/g) is equal to
the set of worlds in the canonical Kripke model ℳ= (K, S, V) (given by Definition 107)
where ϕ/g holds.
A.3.5 Autoreference, many-valuedness and paraconsistency
The paraconsistent logic goes beyond consistency but prevents triviality, i. e., the ex-
plosive inconsistency of classic logic described above. In paraconsistent logics, we can
have a kind of local inconsistency, which has no total explosive feature as in 2-valued
classical logic. Thus, in the presence of these local inconsistencies paraconsistent
logic still separates propositions into two nonempty classes, derivable and nonderiv-
able ones.
The most important criteria for choosing paraconsistent logics, as suggested in
[227, 265, 308], and recently formalized into the Logic of Formal Inconsistencies (LFI)
[261], is their abstract degree of nontriviality, rather than the mere absence of contra-
diction.
The LFI internalizes the very notions of consistency and inconsistency at the
object-language level, instead of the usual metalogic level. It designs an expressive
logic language, able of recovering both consistent reasoning and allowing for some
inconsistency.
In what follows, the set of standard logic connectives {∧, ∨, ⇒, ¬} correspond to the
Heyting algebra in Proposition 40, and the finite number of unary modal (normal and
nonnormal) operators. We will denote by AX the extended many-valued Heyting alge-
bra by a finite set of modal operators {oi : X →X}i<ω, i. e., AX = (X, ≤, ∧, ∨, ⇀, ¬, {oi :
X →X}i<ω). Any many-valued valuation v : H →X, i. e., the Herbrand interpretation,
can be uniquely extended to all formulae in ℒG
mv (the set of all sentences in ℒmv) by
the homomorphism v∗: ℒG
mv →AX. By (AX, D), we will denote the matrix where D ⊆X
is any subset of designated algebraic values.
We will formally define the multimodal many-valued logic as a pair (ℒG
mv, ⊩) where
⊩⊆𝒫(ℒG
mv)×ℒG
mv is a consequence relation for a logic ℒG
mv, generally defined as follows:
for any theory Δ (a subset of sentences of ℒG
mv), the sentence ϕ ∈ℒG
mv is a logical
consequence of Δ, denoted by Δ ⊩ϕ, iff ∀v(∀ψ ∈Δ.v∗(ψ) ∈D implies v∗(ϕ) ∈D). It is
said that a theory Δ is closed iff {ϕ ∈ℒG
mv | Δ ⊩ϕ} = Δ.
In what follows, we will briefly present basic concepts in LFI, and invite the read-
ers to use [261, 269] for more information. The logic (ℒG
mv, ⊩) with a paraconsistent

422
|
A Appendix
negation ∼, which has to be antitonic and must satisfy ∼1 = 0 and ∼0 = 1 but dif-
ferent from strong supplementary negation [261] based on the pseudo-complement,
¬α = α ⇀0, where ⇀, defined as a relative pseudo-complement, is a deductive impli-
cation [261], which satisfies the modus ponens and deduction theorem [208] (notice
that w. r. t. [261] here we inverted the symbols for these two negations) is:
1.
contradictory, if ∀Δ∃ϕ(Δ ⊩ϕ, and Δ ⊩∼ϕ).
2.
trivial, if ∀Δ∀ϕ(Δ ⊩ϕ).
3.
explosive, if ∀Δ∀ϕ∀ψ(Δ, ϕ, ∼ϕ ⊩ψ).
4.
gently explosive, if ∀Δ∀ϕ∀ψ(Δ, ϕ, ∼ϕ, O(ϕ) ⊩ψ),
where O(ϕ) is a possibly empty set of formulae, which depends only on ϕ, satisfying
the following: there are formulae α, β such that O(α), α ⊮β and O(α), ∼α ⊮β.
5.
consistent, if it is both explosive and nontrivial.
6.
paraconsistent, if it is inconsistent yet not trivial.
In [261], it was shown that for Tarskian (monotonic) logic hold:
1.
if logic is trivial, then it is both contradictory and explosive,
2.
an explosive logic fails nontriviality iff it fails noncontradiction.
Finally, in [261] a Logic of Formal Inconsistency (LFI) is defined as a logic, which is not
explosive but is gently explosive. Different from LFI, we consider all kinds of many-
valued logics (also nonmonotonic where the property (Δ ⊩ϕ and Δ ⊆Λ) implies
Λ ⊩ϕ) based on a complete distributive lattice of algebraic truth values does not
hold.
In what follows, we will demonstrate that all many-valued logics based on a com-
plete distributive lattice of truth values (MVCL logics) are gently explosive, i. e., they
are LFIs. Now we will define the paraconsistent negation ∼for MVCL logics. Given an
unary operator ⊙: X →X, we will denote its image by im ⊙= {y = ⊙(x) | x ∈X}. For a
paraconsistent negation, we need the condition ∃x ∈X.(x∧∼x
̸= 0) (in that case we
take that x ∧¬x ∈D is a designated element), so it must hold 2 ⊂im ∼.
Proposition 45. Strong negation ¬, defined by the pseudo-complement ¬α = α ⇀0 in
a complete distributive lattice (X, ≤), cannot be used as a paraconsistent negation.
Proof. In fact, for any x ∈X we have that x ∧¬x = x ∧(⋁{y | x ∧y = 0}) = ⋁{x ∧y |
x ∧y = 0} = 0. Thus, ∄x ∈X.x ∧¬x
̸= 0 , and ¬ is the supplementary negation.
An atom in a lattice (X, ≤) is an element x ∈X different from 0, such that ∄y
̸=
0.(y < x). Now we will show how we are able to define the paraconsistent negation for
any complete distributive lattice (X, ≤).
Proposition 46. Any bounded lattice (X, ≤), with cardinality bigger than 2, can have a
paraconsistent negation ∼.

A.3 Autoreferential semantics for many-valued modal logics
|
423
Proof. For any fixed α ∈X, such that α ∉{0, 1}, we define
∼x = 1
if x = 0; 0 if x = 1; α otherwise.
It is easy to show that for any two x, y ∈X, if x ≤y then ¬x ≥¬y. So that ∼is a general
negation given by Definition 104. It is easy to verify that α ∧¬α = α
̸= 0.
But in some cases there are also other kinds of paraconsistent negations:
1.
When X is an infinite set and there exists the isomorphism with the closed interval
of reals [a, b], ω : (X, ≤, ∧, ∨) ≃([a, b], ≤, min, max), then we define for any x ∈X,
∼x = ω−1(b + a −ω(x)), where ω−1 is the inverse of ω.
2.
When X is finite with the cardinality n = |X| ≥3. We define the following isomor-
phism σ : (X, ≤, ∧, ∨) ≃({ i
n | 1 ≤i ≤n}, ≤, min, max), and we define for any x ∈X,
∼x = σ−1( 1+n
n −σ(x)), where σ−1 is the inverse of σ.
Example 53. Let us consider the following cases:
1.
In the case of fuzzy logic, where the complete lattice is a closed interval of reals,
X = [0, 1], we have Case 1.1 where ω is defined by ω(x) = a + (b −a) ∗x for any
x ∈X, and ω−1(y) = (y −a)/(b−a) for any y ∈[a, b]. Thus, ∼x = ω−1(b+a−ω(x)) =
(b+a−ω(x)−a)/(b−a) = 1−(ω(x)−a)/(b−a) = 1−ω−1(ω(x)) = 1−x is a standard
negation of fuzzy logic.
The set of designated elements is D = {y | y ∈X and a ≤y} for some 0 < a ≤1.
2.
In the case of the 3-valued logic where X = {0, 1
2, 1}, and σ(x) = 1+2x
3 , we obtain
∼(0) = 1, ∼( 1
2) = 1
2 and ∼(1) = 0. The set of designated elements is D = { 1
2, 1}.
3.
In the case of Belnap’s 4-valued logic, X = {f, ⊤, ⊥, t}, where 0 corresponds to
f and 1 to t, we have two atoms, ⊤and ⊥, and we obtain that ∼= ¬t−is standard
epistemic bilattice negation, where ¬t is a pseudo-complement (supplementary
negation) and −the belief modal operator (conflation). The set of designated ele-
ments is D = {⊤, t}.
Now we will introduce the particular nonnormal modal operators (they are not
monotone functions), used in [204] for the reduction of any MVCL logic into 2-valued
modal logic, and based on them the paraconsistent negation ∼. Then we will define
the consistency operator ∘: X →X as follows.
Definition 108. Given a complete lattice (X, ≤), we define the family of unary modal
operators [x] : X →X, for each x ∈X, as follows: for any α ∈X,
[x]α = 1
if α = x; 0 otherwise.
Based on them, we define the following global modal consistency operator ∘: X →X
for a lattice (X, ≤): for any α ∈X,
∘α =def ⋀{∼[x]α | x ∈X\2},
where \ is the set substraction.

424
|
A Appendix
Notice that in the case of the classic 2-valued logic we obtain for any formula ϕ,
∘ϕ = 1, because the meet of the empty set is equal to 1.
Otherwise, for a n-valued logic, ∘α = 1 for α ∈2 and is otherwise equal to 0.
Theorem 18 (Many-valuedness and paraconsistency). Any many-valued logic based
on a complete lattice (X, ≤) with |X| ≥3 is a LFI with the consistency operator defined in
Definition 108.
Proof. It is easy to verify that the following matrix holds:
∼
[x1]
[x2]
. . .
[xi]
. . .
[xn]
∘
1
0
0
0
. . .
0
. . .
0
1
x1
y1
1
0
. . .
0
. . .
0
0
x2
y2
0
1
. . .
0
. . .
0
0
.
.
.
.
. . .
.
. . .
.
.
.
.
.
.
. . .
.
. . .
.
.
xi
yi
0
0
. . .
1
. . .
0
0
.
.
.
.
. . .
.
. . .
.
.
.
.
.
.
. . .
.
. . .
.
.
xn
yn
0
0
. . .
0
. . .
1
0
0
1
0
0
. . .
0
. . .
0
1
where for all 1 ≤i ≤n, xi ∈X\2 and yi ∈X\2, and n ≥1.
It is easy to verify that ∀x ∈X.(x∧∼x ∧∘x = 0); consequently, ∀Δ∀ϕ∀ψ(Δ, ϕ,
∼ϕ, O(ϕ) ⊩ψ), while ∘1, 1 ⊮0 and ∘0, ∼0 ⊮0. Thus, a many-valued logic based on a
complete lattice (X, ≤) of algebraic truth values is gently explosive, i. e., it is a LFI.
So, for any finite many-valued logic (each finite lattice is a complete lattice) we
are able to define the paraconsistent negation in Proposition 46 in order to obtain a
LFI. It is possible also in the case of infinite set of algebraic truth values, when this
set is a complete lattice (as, e. g., in the case of the fuzzy logic in Example 53). The re-
lationship between the many-valuedness and the autoreferential assumption is given
in precedent sections by representation theorems and dual Kripke-style semantics for
many-valued logics based on complete lattices of truth values (Proposition 41 and Def-
initions 105 and 107).
All that remains is to explain the last relationshipinthetrianglemany-valuedness-
autoreference-paraconsistency: the relationship between the autoreference assump-
tion for Kripke-style semantics of many-valued logics and paraconsistency.
Let us consider the multimodal many-valued logic (ℒmv, ⊩) based on the extended
many-valued Heyting algebra AX = (X, ≤, ∧, ∨, ⇀, ¬, {oi : X →X}i<ω), and a particular
set of formulae (theory) Δ ⊂ℒmv, with the Herbrand base H, for which the Kripke-
style semantics is given by Definitions 105 and 107.
Let v : H →X be a many-valued Herbrand model of this theory Δ, and v∗: ℒG
mv →
AX its unique homomorphic extension to all ground formulae. Then from Theorem 17

A.4 Reduction of many-valued into two-valued modal logics
|
425
we have that the set of ground formulae, which are satisfied in a world x ∈X is
S(x) =def {ϕ ∈ℒG
mv | v∗(ϕ) ≥x}.
If we consider a world x as the matrix (AX, D(x)) where D(x) = {y ∈X | y ≥x} is the set
of designated elements of this matrix, then the set S(x) is the set of formulae, which
are satisfied w. r. t. this matrix. That is, ∀ϕ ∈S(x)(v∗(ϕ) ∈D(x)), so that v is a model for
all formulae in S(x). Thus, we can introduce the following preorder between matrices:
(AX, D(x)) ⪯(AX, D(y))
iff
S(x) ⊇S(y)
iff
x ≤y.
So, the bottom matrix is (AX, D(0)) = (AX, X). It corresponds to the bottom world 0,
where the set S(0) = ℒG
mv is the set of all sentences: this world is trivial, and corre-
sponds to classic explosive inconsistency, so that this world cannot be paraconsistent.
The top world 1 corresponds to the matrix (AX, D(1)) = (AX, {1}), with the smallest
set of formulae S(1). In this world, we cannot have any true formula ϕ∧¬ϕ, because if
v∗(ϕ) ∈D(1) = {1}, i. e., v∗(ϕ) = 1, then v∗(¬ϕ) = 0, i. e., v∗(¬ϕ) ∉D(1) = {1}, and con-
sequently, v∗(ϕ ∧¬ϕ) ∉D(1) = {1}. That is, this world also cannot be paraconsistent.
Thus, to be able to permit paraconsistent reasoning we need at least three different
worlds, i. e., n-valued logic with n ≥3.
In that case, for the world 0 < x < 1 we are able to have the formulae ϕ ∧¬ϕ such
that v∗(ϕ∧¬ϕ) = x, i. e., v∗(ϕ∧¬ϕ) ∈D(x). Consequently, this world is paraconsistent.
An interesting point is how the hierarchy between the possible worlds (lattice or-
dering of truth values) corresponds to the hierarchy of matrices for the same theory,
and consequently, to the hierarchy of paraconsistent logics. The level of paraconsis-
tency is inverse to the truth level of the possible world: the higher truth level of the
possible world corresponds to a lower paraconsistent logic (with a smaller number of
paraconsistent formulae).
A.4 Reduction of many-valued into two-valued modal logics
Large databases obtained by the data integration of different source databases can be
incomplete and inconsistent in many ways. The classical logic is not the appropriate
formalism for reasoning about inconsistent databases. Certain local inconsistencies
should not be allowed to significantly alter the intended meaning of such logic pro-
grams. The variety of semantical approaches that have been invented for logic pro-
grams is quite broad. In particular, we are interested for many-valued logics with nega-
tion, based on bilattices.
Semantics of logic programs are generally based on a classical 2-valued logic by
means of stable models [116, 309]. Under these circumstances, not every program has a
stable model. Three-valued or partial model semantics had an extensive development
for logic programs generally [310, 311]. Przymusinski extended the notion of a stable

426
|
A Appendix
model to allow 3-valued or partial, stable models, [312], and showed every program has
at least one partial stable model, and the well-founded model is the smallest among
them [313]. Once one has made the transition from classical to partial models allowing
incomplete information, it is a small step to also allow models admitting inconsistent
information. Doing so provides a natural framework for the semantic understanding
of logic programs that are distributed over several sites, with possibly conflicting in-
formation coming from different places.
So far, research in many-valued logic programming has proceeded along different
directions: Signed logics [298, 299] and annotated logic programming [300, 301, 314],
which can be embedded into the first, bilattice-based logics, [188, 197], and quantita-
tive rule sets [315, 316]. Earlier studies of these approaches quickly identified various
distinctions between these frameworks. For example, one of the key insights behind
bilattices was the interplay between the truth values assigned to sentences and the
(nonclassic) notion of implication in the language under considerations. Thus, rules
(implications) had weights (or truth values) associated with them as a whole. The
problem was to study how truth values should be propagated “across” implications.
Annotated logics, on the other hand, appeared to associate truth values with each
component of an implication rather than the implication as a whole. Roughly, based
on the way in which uncertainty is associated with facts and rules of a program, these
frameworks can be classified into implication based (IB) and annotation based (AB).
In the IB approach, a rule is of the form A ←α B1, . . . , Bn, which says that the
certainty associated with the implication is α. Computationally, given an assignment I
of logical values to the Bis, the logical value of A is computed by taking the conjunction
of logical values I(Bi) and then somehow propagating it to the rule head A.
In the AB approach, a rule is of the form A : f(β1, . . . , βn) ←B1 : β1, . . . , Bn : βn,
which asserts “the certainty of the atom A is least (or is in) f (β1, . . . , βn), whenever the
certainty of the atom Bi is at least (or is in) βi, 1 ≤i ≤n,” where f is an n-ary computable
function and βi is either constant or a variable ranging over many-valued logic values.
The comparison in [317] shows:
1.
While the way implication is treated on the AB approach is closer to the classical
logic, the way rules are fired in the IB approach has definite intuitive appeal.
2.
The AB approach is strictly more expressive than IB. The down side is that query
processing in the AB approach is more complicated, e. g., the fix-point operator is
not continuous in general, while it is in the IB approaches.
From the above points, it is believed that IB approach is easier to use and is more
amenable for efficient implementations. In [301], it is shown how Fitting’s 3-valued
bilattice logic can be embedded into annotated logic programming.
The higher-order types of Herbrand interpretations for many-valued logic pro-
grams, where we are not able to associate a fixed logic value to a given ground atom
of a Herbrand base but a function in a given functional space, often arise in practice

A.4 Reduction of many-valued into two-valued modal logics
|
427
when we have to deal with uncertain information. In such cases, we associate some de-
gree of belief to ground atoms, which can be simple probability, probability interval
or other more complex data structures, as for example, in Bayesian logic programs
where for a different kind of atoms we may associate different kinds of measures as
well.
But we can see approximate (uncertain) information as a kind of relativization of
truth values for sentences as follows. Let H be a Herbrand base for a logic program,
with predicate and proposition letters in P, that handles the uncertain information,
and for k-ary predicate pk
i ∈P, pk
i (d) a ground atom in H that logically defines a par-
ticular fact for which we have only an approximated information about when it hap-
pened. Thus, this atom pk
i (d) is no longer absolutely true or false, but rather its truth
depends on the approximate temporal information about this fact: in some time points
it can be true, in others it can be false. If we consider such a temporal approximation
as a context for this ground fact pk
i (d) ∈H, then we obtain that the truth of pk
i (d) is a
function from the time to the ordinary set of truth values 2 = {0, 1}. Consequently, the
truth values of ground atoms in this Herbrand base are the functions, i. e., they have
a higher-order type (this term is taken from the typed lambda calculus) with respect
to the set 2 of truth constants. Intuitively, the approximated information is relativized
to its context, and such a context further specifies the semantics for this uncertain
information.
The contextualization is a kind of premodal Kripke modeling: in fact, if we consider
a context as a Kripke possible world, then the relativization of the truth to particular
contexts is equivalent to Kripke semantics for a modal logic where the truth (or falsity)
of the formulae is relativized to possible worlds. In fact, as we will see in what follows,
the higher-order Herbrand models obtained by contextualization are precursors for
an introduction of 2-valued epistemic concepts, i. e., for a development of (absolute)
2-valued logics, and it explains their role in a 2-valued reduction of many-valued
logics.
Definition 109 (Higher-order Herbrand interpretation types [83]). Let H be a Her-
brand base, then the higher-order Herbrand interpretations are defined by IH
:
H →T, where T is a functional space W1 ⇒(. . . (Wn ⇒2) . . .), denoted also as
(. . . ((2Wn)Wn−1) . . .)W1, and Wi, i ∈[1, n], n ≥1 are the sets of parameters (the values
of given domains). In the case n = 1, 𝒲= W1, T = (𝒲⇒2), we will denote this
interpretation by IH : H →2𝒲.
In [318], a general method has been developed of constructing 2-valued autoepis-
temic language concepts for each many-valued ground atom with higher-order Her-
brand interpretation given in Definition 109, for which we would like to have a corre-
spondent 2-valued logic language concept. The number of such atomic concepts to be
used in the applications is always a finite subset HM of M elements of the Herbrand
base H.

428
|
A Appendix
Definition 110 (Epistemic concepts). [318] Let HM be a finite sequence of N ground
atoms in H, HM a set of elements in HM and iN : HM 󳨅→H be an inclusion mapping
for this finite subset of ground atoms. We define the bijection iC : HM ≃CM, with the
set of derived concepts CM = {◻iA | A = πi(HM), 1 ≤i ≤M}, where πi is i-th projection,
such that for any ground atom A = πi(HM), iC(A) = ◻iA.
The idea of how to pass to the possible world Kripke semantics for universal modal
operators ◻i, used above for an epistemic definition of concepts, is as follows: for a
given 𝒲= W1 × ⋅⋅⋅× Wn, we define the set
Qi = {w ∈𝒲| pk
i (d) = πi(HM) ∈H and I(pk
i (d))(w) = 1}.
It is easy to verify that Qi is the set of all points w ∈𝒲= W1 × ⋅⋅⋅× Wn where the
ground atom pk
i (d) = πi(HM), for a given higher-order Herbrand model, is true. As a
consequence, we may consider 𝒲as a set of possible worlds and define this higher-
order Herbrand model for IH : H →T as a Kripke model. It follows that a higher-order
language concept ◻iA is false if and only if there is not any possible world where the
ground atom A = πi(HM) ∈H is satisfied, and true if it is satisfied exactly in the set of
possible worlds that defines the meaning of this ground atom. We will show, in the fol-
lowing definition, how to define the accessibility relations for modal operators, used
to extend an original many-valued logic by a finite set of higher-order language con-
cepts. For example, for any ground modal atom (“concept”) ◻iA, where A = πi(HM),
we will obtain that |◻iA| ∈{0, 𝒲}, i. e., it is a 2-valued modal logic formula (here 0 is
the empty set).
Definition 111 (Kripke semantics for epistemic concepts). Let IH : H →T be a higher-
order Herbrand interpretation type, where T denotes a functional space W1
⇒
(. . . (Wn ⇒2) . . .), with 𝒲= W1 × ⋅⋅⋅× Wn, and P is the set of predicates. Then,
for a given sequence of language concepts HM, a quadruple ℳI = (𝒲, {ℛi}, 𝒟, IK) is a
Kripke model for this interpretation IH, such that:
1.
A mapping (see Definition 3) IK : 𝒲× P →⋃n∈𝒩2𝒟n, such that for any w =
(w1, . . . , wn) ∈𝒲, pn
j ∈P and d ∈𝒟n it holds that
IK(w, pn
j )(d) = IH(pn
j (d))(w1) . . . (wn),
where 𝒟n denotes the set of all n-tuples of domain 𝒟, and 2𝒟n the set of all func-
tions from the set 𝒟n to the set 2.
2.
Finite set of accessibility relations: for any pn
j (d) = πi(HM), ℛi = 𝒲× Qi if Qi
̸= 0;
𝒲× 𝒲otherwise, where Qi = {w ∈𝒲| IK(w, pn
j )(d) = 1}.
Then, for any world w ∈𝒲and assignment g, we define the many-valued satisfaction
relation, denoted by ℳI 󳀀󳨐g,w, as follows:

A.4 Reduction of many-valued into two-valued modal logics
|
429
A1. ℳI 󳀀󳨐g,w pn
j (x1, . . . , xn) iff IK(w, pn
j )(g(x1), . . . , g(xn)) = 1, for any atom,
A2. ℳI 󳀀󳨐g,w ◻ipn
j (x1, . . . , xn) iff ∀w′((w, w′) ∈ℛi implies ℳ󳀀󳨐g,w′ pn
j (x1, . . . , xn)).
Notice that we obtained the multimodal Kripke models with universal modal op-
erators ◻i, i. e., a kind of 2-valued reduction for a many-valued atom pn
j (d). Obviously,
this technique can only be used if the number of introduced universal modal operators
is finite. The encapsulated information in this Kripke frame can be rendered explicit
by flattening a Kripke model of this more abstract vision of data, into an ordinary Her-
brand model where the original predicates are extended by set of new attributes for
the hidden information.
Definition 112 (Flattening [83]). Let IH : H →T be a higher-order Herbrand inter-
pretation, where T denotes a functional space W1 ⇒(. . . (Wn ⇒2) . . .) and 𝒲=
W1 × ⋅⋅⋅× Wn is a Cartesian product. We define its flattening into the Herbrand in-
terpretation IF : HF →2, where HF = {rF(d, w) | pn
j (d) ∈H and w ∈𝒲} is the
Herbrand base of new predicates rF, obtained by an extension of original predicates
pn
j by a tuple of parameters w = (w1, . . . , wn), such that for any rF(d, w) ∈HF, it holds
that IF(rF(d, w)) = IH(pn
j (d))(w1) . . . (wn).
By this flattening of the higher-order Herbrand models, we again obtain a 2-valued
logic, but with a changed Herbrand base HF. We will apply the general results obtained
previously to a more specific case of many-valued logics. This is a case of many-valued
logics with uncertain, approximated or context-dependent information. We consider
only the class of many-valued logics ℒmv based on a bounded lattice X = 𝒲of al-
gebraic truth values, with 2 ⊂𝒲. Then the ordering relations and operations in a
bounded lattice 𝒲are propagated to the function space 𝒲H, which is bounded lattice
as well [319]. A many-valued Herbrand interpretation v ∈𝒲H, a mapping v : H →𝒲,
can be extended to all formulae as a homomorphism v∗: ℒG
mv →𝒲, also called a
many-valued valuation, where ℒG
mv is the subset of all ground formulae in ℒmv.
Example 54. Let us, with Belnap’s bilattice, consider also the following bounded lat-
tices:
1.
Fuzzy data [239, 320, 321]: then 𝒲= [0, 1] is the infinite set of real numbers from
0 to 1. For any ground atom pn
j (d) ∈H, the I(pn
j (d)) represents its plausibility. For
any two x, y ∈𝒲, we have that x ∧y = min{x, y}, x ∨y = max{x, y}, and negation
connective ∼is determined by ∼x = 1 −x.
2.
Belief quantified data [70, 322, 323]: then 𝒲= 𝒞[0, 1] is the set of all closed
subintervals over [0, 1]. For any ground atom pn
j (d) ∈H, the (L, U) = v(pn
j (d))
represents the lower and upper bounds for expert’s belief in pn
j (d). For any
two [x, y], [x1, y1] ∈𝒲, we have that [x, y] ∧[x1, y1] = [min{x, x1}, min{y, y1}],
[x, y] ∨[x1, y1] = [max{x, x1}, max{y, y1}].The belief (or truth) ordering is defined
as follows: [x, y] ≤[x1, y1] iff (x ≤x1 and y ≤y1). We define the epistemic nega-
tion [197] of a belief [x, y] as the doubt ∼[x, y], such that ∼[x, y] = [∼y, ∼x] =

430
|
A Appendix
[1 −y, 1 −x]. The bottom value of this lattice is 0 = [0, 0], while the top value is
1 = [1, 1].
3.
Confidence level quantified data [200, 324]: then 𝒲= 𝒞[0, 1] × 𝒞[0, 1]. For any
ground atom pn
j (d) ∈H, we have ((L1, U1), (L2, U2)) = v(pn
j (d)), where (L1, U1) rep-
resents the lower and upper bounds for expert’s belief in pn
j (d), while (L2, U2) rep-
resents the lower and upper bounds for the expert’s doubt in pn
j (d), respectively.
Let α = ([x, y], [z, v]), β = ([x1, y1], [z1, v1]) ∈𝒲, then
α ∧β = ([min{x, x1}, min{y, y1}], [max{z, z1}, max{v, v1}]),
α ∨β = ([max{x, x1}, max{y, y1}], [min{z, z1}, min{v, v1}]).
We are interested in the ordering ≤that increases the belief and decreases the doubt
of facts, ([x, y], [z, v]) ≤([x1, y1], [z1, v1]) iff [x, y] ≤[x1, y1] and [z1, v1] ≤[z, v].
The negation ∼, which reverses this truth ordering, of this lattice is defined by
Ginsberg [197], with ∼([x, y], [z, v]) = ([z, v], [x, y]). The bottom value of this lattice is
0 = ([0, 0], [1, 1]), while the top value is 1 = ([1, 1], [0, 0]).
All examples above are more than bounded lattices: they are complete distributive
lattices [208, 209]. Thus, we consider also that for any two elements a, b ∈𝒲the many-
valued implication a →b for complete lattices can be defined as a reduct (the relative
pseudo-complement), a →b = ∨{c ∈𝒲| c ∧a ≤b}, so that a →b = 1 iff a ≤b.
For any ground atom pn
j (d) ∈H with a logic value w = v(pn
j (d)), we can generate
a contextual atom, a couple (pn
j (d), w) ∈H × 𝒲, which tell us that “the atom pn
j (d) in
the context w is true.” So, we obtain that the bijection is : HF →H × 𝒲, such that
for any extended (or flattened) ground atom rF(d, w) ∈HF it holds that is(rF(d, w)) =
(pn
j (d), w). This contextualization of a many-valued logic can be represented by this
commutative diagram
2𝒲× 𝒲
eval
? 2
Higher-order
H × 𝒲
IH
?
idW
?
?
is
HF
IF
? 2
id2
?
Many-valued
𝒲× 𝒲
v
?
idW
?
△
? 2
id2
?
(A.3)
where eval is the application of the first argument (function) to the second argument,
id’s are the identities, and △is the “diagonal” function, such that △(w, w′) = 1 iff

A.4 Reduction of many-valued into two-valued modal logics
|
431
w = w′, so that the higher-order Herbrand interpretation is obtained from a many-
valued Herbrand interpretation by IH = Λ(△∘(v × idW)), where Λ is the currying (λ
abstraction) operator for functions used in diagram (A.10) in Section A.5. The flattened
Herbrand interpretation (of a “meta” logic obtained by an ontological encapsulation
of original many-valued logic), is equal to IF = eval ∘(Λ(△∘(v × idW)) × idW) ∘is.
Intuitively, the diagram above shows that for any many-valued interpretation v,
we obtain the correspondent 2-valued interpretation IF (but with modified Herbrand
base HF), and equivalent to it the higher-order Herbrand interpretation IH.
By this contextualization of a many-valued logic, we obtain the simplest case of
the higher-order Herbrand interpretation given by Definition 109, IH : H →2𝒲, such
that for any atom pn
j (d) ∈H and w ∈𝒲holds that:
IH(pn
j (d))(w) = 1
iff
w = v(r(d)).
The accessibility relations ℛi = 𝒲× Qi, for any pn
j (d) = πi(HM) ∈H, in Definition 111
for many-valued logic does not depend on the number of ground atoms in a Herbrand
base, but only on the number of logic values in 𝒲: it results from the fact that to any
ground atom in a consistent many-valued logic we can assign only one logic value, so
that Qi = {w ∈𝒲| pn
j (d) = πi(HM) ∈H and IH(pn
j (d))(w) = 1} = {w} is a singleton,
with w = v(pn
j (d)). As we can see from the examples above, we assume the autorefer-
ential semantics, i. e., that the set of possible worlds of the relational Kripke frames,
used for the transformation of many-valued into multimodal 2-valued logic, is the set
of logic values of this many-valued logic [69].
A.4.1 Higher-order Herbrand interpretations: revision of temporal-probabilistic
logics
In this subsection, we will provide the theory of flattening of higher-order Herbrand
interpretation shown by diagram (A.3) in the previous section, and its intensional FOL
representation by diagram (1.33) in Section 1.3.1 dedicated to intensional abstraction
operator.
The reasoning with probabilistic information based on PSAT (Probabilistic Satis-
fiability) is the problem of determining wether a set of assignments of probabilities
to a collection of Boolean formulas of atomic events is consistent has a long history
[325–327], and is proven that is NP-complete. But the probabilities derived from any
sources may have tolerances associated with them, and Fenstad [328] has shown that
when enough information is not available about the interaction between events, the
probability of compound events cannot be determined precisely: one can only give
bounds, lower and upper probability bounds. Consequently, the probability intervals
used for uncertain information, as for interval bounded lattices for belief quantified
data in Point 2 of the previous section, are the simplest extension of the traditional

432
|
A Appendix
probability modes [329–331] and are used also as belief measure for uncertainty in
fuzzy logics. Such metric for nontemporal logic programming (p-programs), of the AB
approach (annotation based, as explained in the previous section) is used in a number
of papers [70, 200, 323, 332, 333].
We assume that every event occurs at a point in time with a probability interval
of reals [a, b] ⊆[0, 1] An instant (time point or chronon) t is specified w. r. t. a given
time granularity of a linear calendar structure 𝒯; for example, “day/month/year.” Of-
ten, however, we do not know the exact time point; instead, we only know that the
instant is located sometime during a time interval. We call such an instant an indeter-
minate instant [86]. Dyreson and Snodgrass have drawn attention to the fact that, in
many temporal database applications, there is often uncertainty about the start time
of events, the end time of events and the duration of events. The indeterminacy refers
to the time when an event occurred, not whether the event occurred or not. An indeter-
minate instant is described by lower and upper time bound, and a probability distri-
bution (mass) function (PDF) [87] which, for every time point in this interval, returns
with a lower and upper probability value assigned to a chronons. Generally, for the
interval-based lattice the first introduction of interval-based Temporal Probabilistic
Logic Programs (TP-programs) is presented in [334], and is extended to TP-databases
[87], so that the semantic of interval-based probabilistic logic programs based on pos-
sible worlds and the fix-point semantics for such programs [70] is considered valid for
more than 13 years. But in 2005, during my one year visiting stage at College Park, I
had the possibility to approach the general problems with such TP databases [15], to
consider the semantics of TP-logic programs and to realize that it is not correctly de-
fined. The reason for the fact that more than dozen papers published in very important
conferences and journals from 1992 to 2005 are passed with this drawback is probably
because of the complexity of the issue and the fact that the fix-point semantics were
not used in practical applications.
Main drawback of V. S. Subrahmaninan’s theory of TP-logic programs
The initial suspect for the validity of the fix-point semantics w. r. t. the model theory of
the p-programs (probabilistic programs), defined in the seminal paper [70] and suc-
cessively repeated in all other papers, was based on the two observations: on an un-
natural semantics for the probability interval-based bilattice used for computation of
the fix point, and on the intuition that would be possible to convert the p-programs
with interval-based annotated atoms into the probabilistic constraint programs, and
for them there is no guarantee that the solution will contain only simple probabilistic
intervals for atoms [16].
The first consideration was analyzed and presented in [202]. In [70], it is used for
the knowledge (precision) ordering for a computation of the least fix-point semantics
for interval-based logic programs, but the disjunction can produce as a result of incon-
sistent values [x, y] such that x > y; moreover, while the bottom solution is reasonably

A.4 Reduction of many-valued into two-valued modal logics
|
433
assigned the whole interval 0K = [0, 1] (bottom value of the lattice), to the “best so-
lution” is assigned the top value of the lattice [0, 1] (denominated empty interval 0 in
[70]), which is inconsistent (i. e., the best solutions result inconsistently).2
Also, the second observation was investigated by the author and the result is
presented in [68] with the reduction of TP-databases into constraint logic programs:
consequently, we are able to apply interval PSAT in order to find the models of such
interval-based probabilistic programs, but such models cannot, in the general case,
be described by single intervals associated with atoms of a program. In fact, there are
the cases when the least fix point of a p-program P is not a model of P: it happens
always when there is a rule with an atom in the body with the probability interval
more thin then the interval for this atom assigned by the least fix point (so that this
rule could not be satisfied during the least fix-point computation) and with the atom
in the head of this rule with the probability interval more thin that the interval for this
atom computed by the least fix point.
The main drawbacks of the work in [334] can be summarized as follows: its fix-
point semantics is incorrect w. r. t. its model theory in the analog way described above
in the case of more simple p-programs; the second is based on the fact that its se-
mantics for probability, based on possible worlds, is apparently taken without any
plausible connection with the standard semantics for p-programs based on Herbrand
interpretations, principally because they did not explore the possible reductions of TP-
programs into p-programs (similarly as in the case when in [70] was not considered
the possible reduction into constraint logic programs, and the price was the incorrect
fix-point semantics).
In order to obtain a serious revision for TP-programs and their semantics, we
needed some additional mathematical tools also, based on the concepts of the pred-
icate compression and higher-order Herbrand model types [83] (used also for “ab-
stracted” databases in [68] and presented here in the previous section) as follows:
1.
The definition of the new syntax and the model theory for temporal probabilistic
programs, denominated PT-programs (probabilistic temporal programs), where is
considered the full temporal property of events by including the attribute for time
points inside of all atoms (basic events): such atoms will be denominated t-atoms
2 Independently from this, my investigation about the validity of the given semantics for interval-
based p-programs, and presumably in the same time (such coincidence is astounding), also the two
coauthors, which previously worked on this issue for more than 5 years [332, 334], discovered the in-
correctness of their previous definition of fixed-point semantics for interval-based p-programs. So that
in the first paper [71] they presented the counterexamples, and proved that the fix-point semantics of
p-programs is unsound (their Proposition 1 shows that the fix-point semantics derives the interpreta-
tions, which are not models of a p-program) and incomplete (their Proposition 3 shows that there are
models of a p-program, which are not interval-based, so that the fix-point operator is unable to find
any solution). The correct semantics for probabilistic programs (p-programs), based on interval PSAT,
is presented recently [335] and shows that the entailment problem for p-programs is co-NP-complete.

434
|
A Appendix
in what follows. By this intuitive and simple operation, we obtain t-Herbrand mod-
els and indirectly the reduction of PT-programs into the p-programs with t-atoms,
so that the possible world semantics for the PT-programs with this new syntax is
based on standard Herbrand models.
2.
Such new PT-programs has the same possible world semantics for p-programs
[335], which can be solved, in the general case, by interval PSAT as discussed in
precedence.
3.
PT-programs can be transformed in the previous version of TP-programs described
in [334], by means of predicate compression for the temporal attribute: thus, the
possible worlds of old TP-programs is is the set of higher-order Herbrand interpre-
tations, which are result of this predicate compression. The TP-programs obtained
by this transformation (which is knowledge invariant) do not suffer the semantics
drawback as in [334], and can be considered as the minimal revision of the work
presented in [334].
We will use the same terminology as in [334]. The main difference is that our event
atoms, different from event atoms [334], have also the temporal attribute y with a do-
main represented by Sτ, the set of all valid time points ti ∈Sτ of a calendar of a type 𝒯.
For example, let p(d) be an ordinary atom with an n-ary predicate symbol p and a tuple
of n constants or variables d. Then A = rF(d, y), where rF is n + 1-ary predicate sym-
bol obtained from p by enlarging it with a new temporal attribute, is an event’s t-atom
(temporal atom). When the tuple d is composed by only constants and y is a time point
in Sτ, then A is said to be a ground t-atom. If A1, . . . , Ak are the (simple) t-atoms, then
A1 ∧⋅⋅⋅∧Ak and A1 ∨⋅⋅⋅∨Ak are called compound t-atoms.
Let L be a language generated for compound events by a given set of constants
(Herbrand universe) and temporal predicate symbols. We assume that all variable
symbols from L are partitioned into three classes: the object variables (contains the
regular first-order logic variable symbols: variables in a tuple d of the example above),
the probabilistic variables (range over the interval of reals in [0, 1]) and temporal vari-
ables (range over the set of time points Sτ of a given calendar: in the examples, we will
use integer numbers for time points): the temporal variable y in t-atoms will be called
principal variable y and all other temporal variables will be called independent. We
define two types of terms: the temporal terms, with constants in Sτ and probabilistic
terms with constants in [0, 1].
Definition 113 (Temporal constraint). A temporal constraint C = c(y, y1, . . . , yk) with
principal t-variable y and other variables y1, . . . , yk is defined inductively:
1.
let λ be a temporal term with the set of variables y1, . . . , yk, then (y op λ), where
op ∈{≤, <, =, ̸=, >, ≥}, is a temporal constraint. The y : λ1 ∼λ1 is a short denotation
for y ≥λ1 ∧y ≤λ1.
2.
if C1 and C2 are temporal constraints with the same principal variable y, then C1 ∧
C2, C1 ∨C2 and ¬C1 are temporal constraints.

A.4 Reduction of many-valued into two-valued modal logics
|
435
A temporal constraint is called normal if it does not contain variables different from
the principal variable.
Let C = c(y) be a normal temporal constraint, the solution set of time points of C
is equal to sol(C) = {t | t ∈Sτ and c(t) is true}, with the cardinality | sol(C)|.
Probabilistic weight function
For any given temporal constraint C = c(y, y1, . . . , yk), we define the function ωC :
Sk+1
τ
→[0, 1], such that for any tuple of time-points (t, t1, . . . , tk) ∈Sk+1
τ
, if ωC(t, t1, . . . ,
tk)
̸= 0 then t ∈sol(C).
Alternatively, in the case when | sol(C)| = m is a finite number, we will specify the
weight function in the form of the time-ordered set of values {d1, . . . , dm}: For example,
if sol(c(y)) = {t1, . . . , t3}, a weight function ωC can be represented as {0.4, 1, 0.5}, and it
will mean that ωC(t1) = 0.4, ωC(t2) = 1, ωC(t3) = 0.5. We will denote by ♯the constant
weight function (equal to 1) for the constraints with | sol(C)| = 1.
The intuition underlying the above definition is that a probabilistic weight func-
tion ωC, of a given temporal constraint C, assigns a probability p ≥0 to each time
point in the solution set of this temporal constraint (for all other time points it must
be equal to zero).
Temporal probabilistic annotation
A tp-annotation γi is a triple ⟨C, ωCL, ωCU⟩where C is temporal constraint, ωCL and ωCU
are probabilistic weight functions for lower and upper boundary, respectively.
Remark. This is a more general definition than in [334], but gives us the possibility to
model lower and upper probability boundaries independently.
Definition 114 (Probabilistic temporal program). Let ψ = A1 ⊙⋅⋅⋅⊙Ak be a compound
event t-formula, where ⊙∈{∧, ∨}, and γ = ⟨C, ωCL, ωCU⟩be a tp-annotation, then ψ : γ
is a tp-annotated basic formula.
Let A : γ and ψ1 : γ1, . . . , ψm : γm be tp-annotated basic formulae and A a t-atom.
Then
A : γ ←ψ1 : γ1 ∧⋅⋅⋅∧ψm : γm
is a tp-clause.
A PT-program is a finite set of tp-clauses. If P is a PT-program, we let ground(P) denote
the set of all ground instances of rules of P. By HF, we denote the Herbrand base of a
program P for a given set of constants for object variables.
As we can see, this syntax is a simile to the syntax for TP-programs presented
in [334]. The main difference is that all atoms in our definition of PT-programs are
t-atoms: thus, we will have that the temporal constraint in tp-basic formulae is an “in-
ternal” annotation for the t-atoms (the temporal attribute of any t-atom corresponds to

436
|
A Appendix
the dependent variable of the temporal constraint), while the probabilistic annotation
remains an external (standard) annotation for t-atoms.
We will show that each PT-program PR has the standard probabilistic model the-
ory based on the Herbrand base HF of PR, with the set of possible worlds (equal to
sample space S of the probability space in Definition 27 in Sections 2.2 and 2.2.2) is
the set of Herbrand interpretations 𝒲= 2HF, (see diagram (A.3) in the previous sec-
tion). Each model theory assumes that in the real world each t-atom in HF is either
true or false. In our case, the set of possible worlds (equal to sample space S of the
probability space in Definition 27 in Sections 2.2 and 2.2.2) is the set of Herbrand inter-
pretations 𝒲= 2HF, so that for any in any possible world IF ∈2HF, for any t-predicate
symbol rF and the tuple of constants d of its object variables, the set of time points
{ti | rF(d, ti) ∈HF and IF(rF(d, ti)) = 1} corresponds to the temporal uncertainty of this
event: in each time point of this set, the event’s uncertainty is bounded in a form of a
probability interval.
A variable assignment g ∈𝒟𝒱maps each object variable to an object constant and
each temporal variable to the set Sτ ⊂𝒟of time points of the calendar. The truth of
the events, expressed by the formulae ϕ ∈ℒ(P), where P is the set of predicate letters,
for a valuation v = IF ∈𝒲under g, denoted by Kripke-like satisfaction ℳ󳀀󳨐v,g ϕ, is
inductively defined for every t-atom rF(a1, . . . , ak, y) and for all formulae ϕ as follows:
1.
ℳ󳀀󳨐v,g rF(a1, . . . , ak, y) iff v(rF(g(a1), . . . , g(y))) = 1,
2.
ℳ󳀀󳨐v,g ϕ ∧ψ iff ℳ󳀀󳨐v,g ϕ and ℳ󳀀󳨐v,g ψ,
3.
ℳ󳀀󳨐v,g ϕ ∨ψ iff ℳ󳀀󳨐v,g ϕ or ℳ󳀀󳨐v,g ψ.
An event ϕ is true in a possible world v, or v is a model of ϕ, denoted ℳ󳀀󳨐v ϕ, iff
ℳ󳀀󳨐v,g ϕ for all variable assignments g. In order to be able to apply the results of
the standard possible world semantics for PT-programs, we have to show that each
PT-program corresponds to standard probabilistic program (p-program).
Proposition 47. Each PT-program is a pure probabilistic logic program.
Proof. It can be shown by simply unfoldingofthetemporalconstraintsintp-annotated
basic formulae, that is, by partial grounding of the temporal attributes of t-atoms in a
given PT-program. That is, given a tp-clause, A : γ0 ←⋀1≤k≤m ψk : γk, with the t-atom
A = rF(x, y) with a tuple of object variables e/o constants in x and γk = ⟨Ck, ωCLk , ωCUk ⟩,
for 0 ≤k ≤m, we can unfold this tp-clause in the following finite set (because the
calendar is finite) of p-clauses, for each ti ∈sol(C0):
rF(x, ti) : [ωCL0 (ti), ωCU0 (ti)] ←
⋀
1≤k≤m
(
⋀
tj∈sol(Ck)
Φk(tj))
where Φk(tj) = ψk(tj) : [ωCLk (tj), ωCUk (tj)], and ψk(tj) is obtained from the ψk by sub-
stitution of the temporal variable in t-atoms of ψk by the constant (time point) tj.

A.4 Reduction of many-valued into two-valued modal logics
|
437
So, we obtain a p-program where all annotations of basic p-formulae are constant
probabilistic intervals.
Thus, given Herbrand base HF of a PT-program PR (equal to the Herbrand base of
the p-program obtained by the unfolding described above), a world probability den-
sity function KI is defined as KI : 2HF →[0, 1] (from Kolmogorov axioms in Defini-
tion 27 in Section 2.2), so that for all v ∈𝒲= 2HF, KI(v) ≥0 and ∑v∈𝒲KI(v) = 1.
A probabilistic interpretation (p-interpretation) Ip : HF →[0, 1] of a PT-program P
is defined as follows for the set of possible worlds 𝒲= 2HF:
if ‖A/g‖ = {v ∈𝒲| ℳ󳀀󳨐v,g A} ⊆𝒲,
then Ip(A) =def
∑
v∈‖A/g‖
KI(v),
for any ground t-atom A ∈HF. That is, p-interpretation assigns probabilities to individ-
ual ground t-atoms of HF by adding up the probabilities of all worlds v ∈𝒲in which
a given t-atom is true (i. e., v(A/g) = 1).
Given a p-interpretation Ip, it can be extended to all compound events in ℒ(P)
by the mapping I∗
p : ℒ(P) →[0, 1], such that the probability of an event ψ in the
probabilistic interpretation I∗
p under a variable assignment g, denoted I∗
p (ψ/g), is the
sum of all KI(v) such that ℳ󳀀󳨐v,g ϕ. That is, for ‖ψ/g‖ = {v ∈𝒲| ℳ󳀀󳨐v,g ψ} ∈𝒫(𝒲),
I∗
p (ψ/g) =def
∑
v∈‖ψ/g‖
KI(v)
(A.4)
p-interpretations specify the model-theoretic semantics of p-programs, as follows:
1.
Ip 󳀀󳨐g ψ : [a, b] iff I∗
p (ψ/g) ∈[a, b], i. e., iff a ≤I∗
p (ψ) ≤b;
2.
Ip 󳀀󳨐g (ψ1 : [a1, b1] ∧⋅⋅⋅∧ψn : [an, bn]) iff (∀1 ≤i ≤n)(Ip 󳀀󳨐g ψi : [ai, bi]);
3.
Ip 󳀀󳨐g (A : [a, b] ←ψ1 : [a1, b1] ∧⋅⋅⋅∧ψn : [an, bn]) iff Ip 󳀀󳨐g ψ : [a, b] or Ip ⊭g (ψ1 :
[a1, b1] ∧⋅⋅⋅∧ψn : [an, bn]).
As we can see, from the point 1 above, the satisfaction of p-programs is based on the
interval PSAT for the system of inequalities: any assignment by Ip of point probabilities
to the atoms that satisfies these constraints is a model of PT-program PR.
Now we are ready to specify the model-theoretic semantics for PT-programs, as
follows.
Definition 115 (Satisfaction). Let g be an assignment only for object variables, then for
any open formula ϕ ∈ℒ(P) with principal t-variable y :
1.
Ip 󳀀󳨐σ ψ : γ iff (∀t ∈sol(C))(Ip 󳀀󳨐σ ψ[y/t] : [ωCL(t), ωCU(t)]),
where γ = ⟨C, ωCL, ωCU⟩and ψ[y/t] is obtained from ψ by substitution of the temporal
variable in t-atoms of ψ by the constant (time-point) t;
2.
Ip 󳀀󳨐g (ψ1 : γ1 ∧⋅⋅⋅∧ψn : γn) iff (∀1 ≤i ≤n)(Ip 󳀀󳨐g ψi : γi);
3.
Ip 󳀀󳨐g (A : μ ←ψ1 : γ1 ∧⋅⋅⋅∧ψn : γn) iff Ip 󳀀󳨐g A : γ or Ip ⊭g (ψ1 : γ1 ∧⋅⋅⋅∧ψn : γn).

438
|
A Appendix
A tp-clause Cl is true in a probabilistic interpretation Ip (i. e., in its extension I∗
p ),
or Ip is a model of Cl, denoted Ip 󳀀󳨐Cl, iff Ip 󳀀󳨐g Cl for all object variable assignments
g. Ip is a model of a PT-program PR if it is a model for all tp-clauses in PR.
Let Mod(PP) denote the set of all models of a PT-program PR; PR is called consis-
tent iff Mod(P)
̸= 0, otherwise PR is called inconsistent.
A PT-program PR is satisfiable iff a model of PR exists.
A tp-annotated basic formula ψ : γ is a logical consequence of a PT-program PR,
or PR entails ψ : γ, denoted PR 󳀀󳨐ψ : γ, iff each model of PR is also model of ψ : γ.
Proposition 48. The consistency problem for PT-programs is NP-complete, while the en-
tailment problem for PT-programs is co-NP-complete.
It derives from the reduction of PT-programs into ordinary p-programs, and from
the complexity of interval PSAT for linear inequalities (see Theorem 4.11 in [63] and
Theorem 3 in [335]).
The examples and the comparison of TP and PT model theories can be found in
[16]. TP-programs and PT-programs have the same solution for their models based on
the interval PSAT.
A.4.2 Mathematics via symmetry: many-valued knowledge invariance in
ontological encapsulation by semantic reflection
In this section, we will use again the mathematical concept of symmetry (categorial
symmetry in Section 1.3.2) for the transformation of many-valued into 2-valued logic
programs by ontological encapsulation of predicates using semantic reflection trans-
formation, analog to that used for predicate (de)compression in Section 2.1. The ap-
proach based on the contextualization of many-valued logics with the introduction of
higher-order Herbrand interpretation types, provided in Section A.4, introduces ex-
plicitly the coexistence of a set of algebraic truth values of original many-valued logic,
transformed as parameters (or possible worlds), and the set of classic two logic val-
ues. This approach offers the possibility of using the standard semantics based on Her-
brand interpretations. Moreover, it uses the properties of the higher-order Herbrand
types, as their fundamental nature is based on autoreferential Kripke semantics [69]
where the possible worlds are algebraic truth values of original many-valued logic.
This autoreferential Kripke semantics, which has the possibility of flattening
higher-order Herbrand interpretations into ordinary 2-valued Herbrand interpre-
tations, gives us a clearer insight into the relationship between many-valued and
2-valued multimodal logics. Following this, we generalize the reduction to general
structural many-valued logics, in an abstract way, based on Suszko’s informal non-
constructive idea. In all cases, by using developed 2-valued reductions we obtain a
kind of nontruth-valued modal metalogic, where two-valued formulae are modal sen-

A.4 Reduction of many-valued into two-valued modal logics
|
439
tences obtained by application of particular modal operators to original many-valued
formulae.
In what follows, we will consider a general case of a many-valued logics based on
bounded lattice (X, 0, 1, ≤.∧, ∨) with antitonic negation “∼” (such that hold De Mor-
gan rules) top value 1 and bottom value 0. The reduction of many-valued logics into
the standard 2-valued logic was considered by Suszko [336], where he illustrated how
Lukasiewicz’s 3-valued logic could be given a 2-valued, nontruth-functional seman-
tics. The main point, according to Suszko, is to make a distinction between the alge-
braic truth values in X of many-valued logics, which were supposed to play a merely
referential role, while only two logical truth values in 2 = {0, 1} (0 for false and 1 for true
value) would really exist. It is also based on the fact that the abstract logic is based on
a consequence relation that is bivalent: given a set of logic formulae S, a formula ϕ can
be inferred from S or not, i. e., the answer to the question “if ϕ is inferred from S” can
only be “Yes” or “No.”
This point of view for “logic values” is also considered correct by other authors,
and it is also applied in our case of an ontological encapsulation of many-valued alge-
braic logic programs into 2-valued logic programs. Moreover, in a 2-valued reduction,
for any propositional formula ϕ that has an “algebraic truth-value” α, we can consider
a 2-valued meta-sentence “the truth-value of ϕ is α.”
Suszko’s thesis for the reduction of every Tarskian (monotonic) n-valued logic into
a 2-valued logic is based on this division of a set of logic values into a subset of des-
ignated and undesignated elements, but it is quite a nonconstructive result. In fact,
he does not explain how he obtained a 2-valued semantics, or how such a procedure
could be effectively applied.
In the paper by D.Batens [337], the author proposes a sort of binary print of the
algebraic truth values for the 2-valued reduction, where each truth value is to be put
into one-to-one correspondence with one element of a set of conveniently long “equiv-
alent” sequences of 0’s and 1’s. This method is similar to what had been proposed by
D. Scott, a decade before [338]. But this method is not universally applicable, and thus
cannot be effectively used. Some other authors argued against Suszko’s thesis [339] us-
ing examples of paraconsistent logic and Malinowski’s inferential many-valuedness.
But recently in [340], based on Suszko’s observations on complementarity of desig-
nated and undesignated elements, a method was exhibited for the effective imple-
mentation of Suszko’s reduction to a subclass of finite-valued truth-functional logics,
whose truth values satisfy the particular assumption of separability, where the “alge-
braic truth values” can be individualized by means of the linguistic resources of the
logic. What is important for the present work is that they show that a reduction of
truth-functional many-valued logic into 2-valued logic will simply make it lose truth-
functionality: in fact, my transformation will result in modal logics.
Consequently, the main contribution of this section is to use a constructive ap-
proach to Suszko’s method, and to exhibit a method for the effective implementation of

440
|
A Appendix
2-valued reduction for all kinds of many-valued logics. It avoids the necessity of divid-
ing (in problematic way based on subjective opinions) a set of algebraic truth values
into designated and undesignated disjoint subsets in order to define the satisfaction
relation (i. e., entailment), by using the valuations (model-theoretic semantics): the
entailment S 󳀀󳨐ϕ means that every model (valuation) of S is a model of ϕ.
Let us consider an epistemic logic program PG composed by a set of predicate
and function symbols, P, F, respectively, with the Herbrand base H, composed the
set of all ground atoms over the Herbrand universe ΓU = 𝒟⋃Ω, where 𝒟is ordinary
domain and Ω is an infinite enumerable set of marked null values (Skolem constants),
Ω = {ω0, ω1, . . .}. We denote the set of all terms by 𝒯S, and its subset of ground terms
by 𝒯0.
For example, any rule in a many-valued logic program A ←B1, . . . , Bn is satisfied
if, for a given valuation v, the algebraic truth value of the head is greater than the value
of the body, i. e., if v(A) ≥v∗(B1∧⋅⋅⋅∧Bn) for a given Herbrand interpretation v : H →X.
More discussion about this approach can be found in in Sections 5.1 and 5.1.1.
Example 55. Let us consider the example X = ℬ4 of Belnap’s 4-valued epistemic logic
program PG. The truth and knowledge ordering relations and operations in a bilattice
ℬ4 propagates to the function space ℬH
4 of all Herbrand interpretations v : H →ℬ4.
This makes a function space ℬH
4 itself a complete infinitary distributive bilattice [319].
One of the key insights behind bilattices [188, 197] was the interplay between the
truth values assigned to sentences and the (nonclassic) notion of implication. The
problem was to study how truth values should be propagated “across” implications.
In [341] is proposed the following IB based approach to the “object” 4-valued logic pro-
gramming, which extends the definition given for a 3-valued logic programming [312]:
Let PB be the subset of built-in predicates. The valuation, v : H →ℬ4, is extended to
logic implication of a ground clause p(c) ←ϕ, where ϕ = B1 ∧⋅⋅⋅∧Bn, with Bi ∈H,
for 1 ≤i ≤n, by
v∗(ϕ →pn
j (c)) = t
iff
v(pn
j (c)) ≥t v∗(ϕ)
or
(pn
j ∈PB and v(ϕ) = ⊤).
We assumed the inconsistency acceptance principle: if pn
j ∈PB is a built-in predicate,
this clause is satisfied also when v(pn
j (c)) = f and v∗(ϕ) = ⊤.
The built-in predicates (ex, =, ≤, ≥, . . .) may be used for integrity constraints: let
p(x, y) be a predicate and we define the key-constraint for attributes in x by (y = z) ←
p(x, y), p(x, z), where the atom y = z is based on the built-in predicate ′ =′. Let consider
a program : p(x, y) ←r(x, y), (y = z) ←p(x, y), p(x, z) where r is a source database re-
lation with two tuples, (a, b), (a, c), p is a virtual relation of this database with key
constraint, and x, y, z are variables. The built-in predicates have the same prefixed ex-
tension in each model of a logic program, and their ground atoms are true or false. If
we assume that r(a, b), r(a, c) are true, then such facts are mutually inconsistent for p
because of key constraint (b = c is false). Thus, only one of them may be true in any

A.4 Reduction of many-valued into two-valued modal logics
|
441
model of this logic program, e. g., r(a, b) . So, if we assign the “possible” value ⊤to
r(a, c) (or to both of them), we obtain that the clause (b = c) ←p(a, b), p(a, c), thanks
to the inconsistency acceptance, is satisfied.
The many-valued definition for implication, which generalize the 2-valued defi-
nition of clause satisfaction for Lukasiewicz’s and Kleene’s strong 3-valued matrices
[218], f←: ℬ4 × ℬ4 →ℬ4, can be defined (with α = t and α =⊥for Lukasiewicz’s and
Kleene’s case, respectively) by
→
t
⊥
⊤
f
t
t
⊥
⊤
f
⊥
t
α
⊤
⊥
⊤
t
t
t
t
f
t
t
t
t
For our purposes, we assume the Lukasiewicz’s extension, i. e., α = t, in order to have
a tautology a ←a for any formula a, and also to guarantee the truth of a clause (im-
plication) p(c) ←ϕ, whenever v(p(c)) ≥t v∗(ϕ), as used in fix-point semantics for
“immediate consequence operators.” Such conservative extensions are based on the
following observation: the problem to study how the truth values should be propa-
gated “across” implications can be restricted only to true implications (in fact we do
not use implications when they are not true, because the “immediate consequence
operator” derives new facts only for true clauses, i. e., when the implication used in
the clauses is true).
I considered [204] two approaches for predicate many-valued logics (the proposi-
tional version can be considered as a special case, when all predicate symbols have a
zero arity): the first one introduces the unary modal operator for each truth value of
original many-valued logic; the second approach introduces the binary modal opera-
tor for each binary truth-valued logic operator (conjunction, disjunction, implication)
of original many-valued logic. Both of them transform an original truth-functional
many-valued logic into nontruth-functional 2-valued modal logic, and here we will con-
sider only the second one, based on the ontological embedding into the syntax of new
2-valued encapsulated many-valued logic.
The “object” many-valued logic is based on the lattice X of truth values, which are
epistemic. Sentences are to be marked with some of these lattice logic values, accord-
ing as to what the computer has been told; or, with only a slight metaphor, according
to what it believes or knows. Of course, these sentences have also Frege’s ontological
truth values (true and false), independently of what the computer has been told: we
want that the computer can use also these ontological “meta”knowledge. Let, e. g., the
computer believes that the sentence ϕ has a value a ∈X; then the “meta” sentence,”I
(computer) believe that ϕ has a value “a” is ontologically true. The many-valued encap-
sulation is just the way to pass from the epistemic (“object”) many-valued logic into
ontological (“meta”) 2-valued logic.

442
|
A Appendix
It can be seen as a flattening of a many-valued logic, where an algebraic truth
value β ∈X of an original ground atom pk
j (c1, . . . , ck) is deposited into the logic at-
tribute of a new predicate rF, obtained by an extension of the old predicate pk
j , so that
we obtain the “flattened” 2-valued ground atom rF(c1, . . . , ck, β). In that case, we will
obtain the positive multimodal logic programs with binary modal operators for con-
junction, disjunction and implication and unary modal operator for negation.
The flattening of an original many-valued lattice-based program into a modal met-
alogic is a kind of ontological-encapsulation, where the encapsulation of an original
many-valued logic program into the 2-valued modal metalogic program corresponds to
a flattening process described in Definition 112. This approach is developed in a num-
ber of papers, and more information can be found in [83, 203, 218, 342]. Here, we will
present a slightly modified version. Such an encapsulation is characterized by hav-
ing capability for semantic reflection: intuitively, for each predicate symbol we need
some function, which reflects its logic semantic over a domain ΓU. We introduce also
the set of functional symbols κp over a domain ΓU in our logical language in order to
obtain an enriched logical language [218] where we can encapsulate the “object” (ordi-
nary) many-valued logic programming. Such set of functional symbols will be derived
from the lattice-semantic mapping 𝒦. We will also introduce a new symbol e (for “er-
ror condition”), necessary in order to render complete the functions for a generalized
interpretation and a semantic reflection.
Definition 116. Let PG be a many-valued logic program with a set of predicate and
functional symbols P and F, respectively, with a Herbrand model v : H →X where
H is a Herbrand base, with a set 𝒯0 of all ground terms and a set 𝒯= ⋃k∈𝒩𝒯k
0 with
𝒩= {1, 2, . . . , n} where n is the maximal arity of symbols in P ⋃F.
1.
A generalized interpretation is a mapping ℐ: P × 𝒯→X ⋃{e}, such that for any
c = (c1, . . . , cn) ∈𝒯, ℐ(p, c) = v(p(c)) if ar(p) = n; e otherwise.
2.
A semantic reflection is defined by a mapping 𝒦= Λ(ℐ) : P →(X ⋃{e})𝒯, where Λ
is the currying operator from lambda calculus used in diagram A.10 in Section A.5.
For each p ∈P that is not a built-in 2-valued predicate, we define a new functional
symbol κp for a mapping 𝒦(p) : 𝒯→X ⋃{e}.
3.
If p is a 2-valued built-in predicate, then the mapping κp is defined uniquely and
independently of v, by: for any c ∈𝒯ar(p)
0
, κp(c) = 1 if p(c) is true; 0 otherwise.
We recall the well-known fact that 2-valued built-in predicates (as ≤, =, etc.) have
constant extensions in any Herbrand interpretation (they preserve the same meaning
for any logic interpretation, different from ordinary predicates).
A semantic reflection 𝒦, obtained from a generalized interpretation ℐ, introduces
a function symbol κp = 𝒦(p) for each predicate p ∈P of the original logic program
PG, such that for any c = (c1, . . . , cn) ∈𝒯, it holds that κp(c) = v(p(c)) if ar(p) = n;
{e} otherwise. These new function symbols will be used in a new metalogic language,

A.4 Reduction of many-valued into two-valued modal logics
|
443
used to transform each original many-valued atom p in P into a new atom pF obtained
as an extension of the original atom p by one “logic” attribute with the domain of
values in X. The interpretation of κp in this new metalogic program has to reflect the
meaning of the original many-valued predicate p in the original many-valued logic
program PG.
Consequently, we are able to introduce a program encapsulation (flattening)
transformation ℰ. The many-valued ground atoms of a many-valued logical lan-
guage ℒmv can be transformed in “encapsulated” atoms of a 2-valued logic in the
following simple way [218]: the original (many-valued) fact that the ground atom A =
pn
j (c1, . . . , cn), of the n-ary predicate pn
j ∈P, has an epistemic value α = κp(c1, . . . , cn)
in ℬ4, we transform in encapsulated atom pF(c1, . . . , cn, α) with meaning “A has a
value α.” Indeed, what we do is to replace the original n-ary predicate pn
j (x1, . . . , xn)
with n + 1-ary predicate pF(x1, . . . , xn, α) (flattening), with the added logic-attribute α.
It is easy to verify that for any given many-valued valuation v ∈XH, each ground
atom pF(c1, . . . , cn, α) is ontologically true (when α = v(pn
j (c1, . . . , cn))) or false. Let EMV
denote this new 2-valued encapsulation of many-valued logic for logic programming.
Syntax
We distinguish between what the reasoner believes in (at the object (epistemic many-
valued sublanguage) level), and what is actually true or false in the real world (at the
EMV ontological “meta” level); thus, roughly, the “meta” level is an (classic) encapsu-
lation of the object-level.
Definition 117. Let PG be an “object” many-valued logic program with the set of predi-
cate symbols P. The translation in the syntax of encapsulated program PF is as follows:
1.
Each positive literal pn
j ∈P, ℰ(pn
j (x1, . . . , xn)) = pF(x1, . . . , xn, κp(x1, . . . , xn));
Each negative literal in P, ℰ(∼pn
j (x1, . . . , xn)) = pF(x1, . . . , xn, ∼κp(x1, . . . , xn));and we
denote by PE the set of new obtained predicates pF.
2.
ℰ(∼ϕ) =∼F ℰ(ϕ);
3.
ℰ(ϕ ⊙φ) = ℰ(ϕ) ⊙F ℰ(φ); for ⊙∈{∧, ∨, ←},
where ∼F, ∧F, ∨F and ←F are new syntax symbols for the negation, conjunction, dis-
junction and implication at the encapsulated 2-valued “meta” level.
Thus, the obtained “meta” program is equal to PF = {ℰ(ϕ) | ϕ is a clause in PG},
with the 2-valued Herbrand base HF = {pF(c1, . . . , cn, α) | pn
j (c1, . . . , cn) ∈H and α ∈X}.
We denote by ℒF the set of formulae obtained from the set of predicate letters in
PE and new operators ∼F, ∧F, ∨F and ←F.
This embedding of the many-valued “object” logic program PG into a 2-valued
“meta” logic program PF is an ontological embedding [218]: we consider the formulae

444
|
A Appendix
of PG as beliefs and interpret negation ∼pn
j (x1, . . . , xn) in rather restricted sense—as be-
lief in the falsehood of pn
j (x1, . . . , xn), rather as not believing that pn
j (x1, . . . , xn) is true
(like in an ontological embedding for classical negation), as in Moore’s autoepistemic
operator, for the encapsulation modal operator ℰ, ℰϕ is intended to capture the no-
tion of, “I know that ϕ has a value v(ϕ),” for a given valuation v of the “object” logic
program.
Let ℒG
mv be the set of all sentences defined by this Herbrand base H and lattice
operations (included many-valued implication ←also), with X ⊆ℒG
mv. So, we have
the following.
Corollary 30. The encapsulation operator ℰis:
1.
Modal operator, such that, for any α ∈X, ℰ(α) = t if α = t; f otherwise.
2.
Homomorphism between the “object” algebra (ℒmv, ∧, ∨, ←) with carrier set of (pos-
itive and negative) literals, and “meta” algebra (ℒF, ∧F, ∨F, ←F), where ∧F, ∨F and
←F are 2-valued operators corresponding to lattice’s meet and join, respectively (de-
noted by ∧, ∨as well).
Semantics
With the transformation of the original “object” logic program PG into its annotated
“meta” version program PF we obtain always positive consistent logic program.
A Herbrand interpretation of PF is a 2-valued mapping IF : HF →2. We denote
by 2HF the set of all interpretations from HF into 2, and by XH the set of all Herbrand
many-valued interpretations, from H to the lattice X. The meaning of the encapsu-
lation of this “object” logic program PG into this “meta” logic program PF is fixed
into the kind of interpretation to give to such new introduced functional symbols
κp = 𝒦(p): in fact, we want [341] that they reflect the semantics of the “object” level
logic program PG.
Definition 118 (Satisfaction). The encapsulation of an epistemic “object” logic pro-
gram PG into the “meta” program PF means that, for any many-valued Herbrand in-
terpretation v ∈XH, the function κp = 𝒦(p), p ∈P reflects this semantics, i. e., for any
tuple c ∈𝒯arity(p)
0
,
κp(c) = v(p(c)).
So, we obtain a mapping, Θ : XH →2HF, such that IF = Θ(v) ∈2HF with: for any ground
atom p(c) , IF(ℰ(p(c))) = t, if κp(c) = v(p(c)); f otherwise.
Let g : 𝒱→ΓU be an assignment to variables in 𝒱such that g(ℰ(pn
j (x1, . . . , xn))) =
ℰ(pn
j (g(x1), . . . , g(xn))), and
1.
IF ⊨g ℰ(pn
j (x1, . . . , xn)) iff κp((g(x1), . . . , g(xn))) = v(pn
j (g(x1), . . . , g(xn))).
2.
IF ⊨g ℰ(∼pn
j (x1, . . . , xn)) iff κp((g(x1), . . . , g(xn))) =∼v(pn
j (g(x1), . . . , g(xn))).

A.4 Reduction of many-valued into two-valued modal logics
|
445
Notice that in this semantics the “meta” implication used in logic program clauses
←F between two sentences ϕ and ψ, in ℰ(ϕ) ←F ℰ(ψ) = ℰ(ϕ ←ψ), is based on the
“object” epistemic many-valued implication ←(which is not classical, i. e., ϕ ←ψ
̸=
ϕ∨∼ψ) and determines how the logical value of a body of clause “propagates” to its
head. That is, ℰ(ϕ) ←F ℰ(ψ) is true if v(ϕ/g ←ψ/g) is true. So, the semantics of the
logic operators in this “meta” (encapsuled) level are modal operators.
Corollary 31. The semantics of encapsulation ℰis obtained by identifying the semantic
reflection with the λ-abstraction of generalized Herbrand interpretation, 𝒦= Λ(ℐ), so
that the semantics of many-valued logic programs can be determined by ℐ(at “object”
level) or, equivalently, by its reflection 𝒦(at encapsulated or “meta” level).
Proof. From 𝒦= Λ(ℐ), where Λ is the currying operator from lambda calculus used in
diagram A.10 in Section A.5, we obtain that for any p(c) ∈H holds v(p(c)) = ℐ(p, c) =
Λ(ℐ)(p)(c) = 𝒦(p)(c) = κp(c), which is the semantic of encapsulation.
We can consider the λ-abstraction of generalized Herbrand interpretation as an
epistemic semantics, because given a Herbrand many-valued (epistemic) interpreta-
tion v : H →X, for any predicate p and constant c ∈𝒯arity(p)
0
, it holds that Λ(ℐ)(p)(c) =
v(p(c)). So, the semantic of encapsulation may be expressed by the following knowl-
edge invariance:
“ontological semantic reflection ≡epistemic semantics,” i. e., 𝒦= Λ(ℐ).
These semantics have been used to provide coalgebraic semantics for logic programs
[144].
Remark. The new introduced logic symbols ∼F, ∧F, ∨F and ←F for the metalogic con-
nectives are not truth-functional as are original many-valued operators but modal.
Hence, by this transformation of PR we obtain a modal logic program PF that is a pos-
itive logic program (without negation). Different from a sentence ϕ ∈ℒG
mv, the trans-
formed meta-formula Φ = ℰ(ϕ) ∈ℒF can be only true or false in a given possible world
w ∈𝒲= X for this metamodal logic (in a given Kripke model ℳof obtained metalogic
program PF).
In this definition of a metalogic program PF, the set of mappings {κp = 𝒦(p) |
p ∈P} is considered as a set of built-in functions, determined by a given semantic
reflection 𝒦, that extends a given set of functional symbols in F.
The encapsulation operator ℰis intended to have the following property for a val-
uation v∗: ℒG
mv →X (a homomorphic extension of Herbrand interpretation v to all
formulae in ℒG
mv) of a many-valued logic program PG: for any sentence ϕ, the encap-
sulated metaformula ℰ(ϕ) intends to capture the notion of ϕ with its value v(ϕ) as
well, in the way that
“ℰ(ϕ) is true exactly in the possible world w = v∗(ϕ) ∈𝒲= X.”

446
|
A Appendix
In order to introduce a concept of absolute truth or falsity (not relative to a single pos-
sible world in 𝒲= X) for the sentences in ℒF, we need a new autoepistemic modal
operator ♦. Consequently, for any given sentence Φ ∈ℒF, similar to Moore’s autoepis-
temic operator, a formula ♦Φ is able to capture the 2-valued notion of
“Φ is a semantic reflection of a many-valued logic program model v.”
Notice that in this encapsulation, e. g., the metaimplication ←F derived from the
many-valued implication, ℰ(ϕ) ←F ℰ(ψ) = ℰ(ϕ ←ψ), specifies how, for a given
clause in PG, a logic value of the body “propagates” to the head of this clause. It is
not functionally dependent on the truth values of its arguments, thus it must be a
binary modal operator. The idea to use ternary relations to model binary modal oper-
ators comes from relevance logic [226, 230, 236, 343]. So, based on the autoreferential
semantics in Definition 58 in Section 5.1, we can define the following Kripke models.
Definition 119. Let PG be a many-valued logic program with a set of predicate sym-
bols P, a many-valued Herbrand model v : H →X and its semantic reflection 𝒦.
Then the model of the flattened program PF in Definition 117 is defined as the
Kripke-style model ℳ= (𝒲, {ℛ∼, ℛ∧, ℛ∨, ℛ→, ℛ× = 𝒲× 𝒲}, 𝒟, IK) with 𝒲= X,
where
ℛ∧= {(x ∧y, x, y) | x, y ∈𝒲},
ℛ∨= {(x ∨y, x, y) | x, y ∈𝒲},
ℛ→= {(x →y, x, y) | x, y ∈𝒲and x ≤y},
ℛ∼= {(∼x, x) | x ∈𝒲},
and IK : 𝒲× PE →⋃n∈𝒩2𝒟n×𝒲(from Definition 3), such that for any pn
j ∈P with
arity n (i. e., pF ∈PF with arity n + 1), a tuple of constants (c1, . . . , cn) ∈𝒟n and a world
w ∈𝒲, IK(w, pF)(c1, . . . , cn, α) = 1 iff w = α = κp(c1, . . . , cn), such that, for any formula
Φ, Ψ ∈ℒF, the satisfaction relation 󳀀󳨐w,g, for a given assignment g and a world w ∈𝒲,
is defined as follows:
1.
ℳ󳀀󳨐w,g pF(x1, . . . xn, α) iff IK(w, pF)(g(x1), . . . , g(xn), α) = 1.
2.
ℳ󳀀󳨐w,g∼F Φ iff ∃y((w, y) ∈ℛ∼and ℳ󳀀󳨐y,g Φ).
3.
ℳ󳀀󳨐w,g ∧F(Φ, Ψ) iff ∃y, z((w, y, z) ∈ℛ∧and ℳ󳀀󳨐z,g Φ and ℳ󳀀󳨐y,g Ψ).
4.
ℳ󳀀󳨐w,g ∨F(Φ, Ψ) iff ∃y, z((w, y, z) ∈ℛ∨and ℳ󳀀󳨐z,g Φ and ℳ󳀀󳨐y,g Ψ).
5.
ℳ󳀀󳨐w,g←F (Φ, Ψ) iff ∃y, z((w, y, z) ∈ℛ→and ℳ󳀀󳨐z,g Φ and ℳ󳀀󳨐y,g Ψ).
6.
ℳ󳀀󳨐w,g ♦Φ iff ∃y((w, y) ∈ℛ× and ℳ󳀀󳨐y,g Φ).
The binary operators ∧F, ∨F and ←F for this multimodal logic are the existen-
tial modal operators w. r. t. the ternary relation ℛ∧, ℛ∨and ℛ→, respectively, while ∼F
and ♦are the existential unary modal operator w. r. t. the binary relation ℛ∼and ℛ×,
respectively.
Proposition 49. For any assignment g and a formula Φ ∈ℒF, we have that ‖♦Φ/g‖ ∈
{0, 𝒲}, where 0 is the empty set and 𝒲= X is the set of truth values. That is, for any

A.4 Reduction of many-valued into two-valued modal logics
|
447
many-valued formula ϕ ∈ℒmv the formula ♦ℰ(ϕ/g) is true in the Kripke-style relational
model ℳgiven by Definition 119, so that a Kripke-style model ℳof PF corresponds to
the many-valued algebraic model v of the original program PG.
Proof. In what follows, we denote by v∗the (homomorphic) extension of a Herbrand
model v to all sentences. Let us demonstrate that for any ϕ ∈ℒ, i. e., ℰ(ϕ) ∈ℒF, holds
that ℳ󳀀󳨐w,g ℰ(ϕ) iff w = v∗(ϕ/g).
1.
For any atomic formula p(x1, . . . , xn), we have that ℳ󳀀󳨐w,g
ℰ(p(x1, . . . , xn)) iff
V(w, pF)(g(x1), . . . , g(xn), κp(g(x1), . . . , g(xn))) = 1 iff w = κp(g(x1), . . . , g(xn)) =
Λ(ℐ)(p)(g(x1), . . . , g(xn)) = v(p(g(x1), . . . , g(xn))) = v(p(x1, . . . , xn)/g). Vice versa,
if w = v(p(x1, . . . , xn)/g), i. e., w = v(p(x1, . . . , xn)/g) = κp(g(x1), . . . , g(xn)), then
V(w, pF)(g(x1), . . . , g(xn), κp(g(x1), . . . , g(xn))) = 1, and consequently, from point 1
of definition above, ℳ󳀀󳨐w,g ℰ(p(x1, . . . , xn)).
Suppose, by the inductive hypothesis that ℳ󳀀󳨐z,g ℰ(ϕ) iff z = v∗(ϕ/g), and ℳ󳀀󳨐y,g
ℰ(ψ) iff y = v∗(ψ/g), then:
2.
For any formula φ =∼ϕ, we have that ℳ󳀀󳨐w,g ℰ(φ) iff ℳ󳀀󳨐w,g ℰ(∼ϕ) iff ℳ󳀀󳨐w,g∼F
ℰ(ϕ) iff (∃z((w, z) ∈ℛ∼and ℳ󳀀󳨐z,g ℰ(ϕ))), i. e., if w =∼z (from the definition of
accessibility relation ℛ∼)=∼v∗(ϕ/g) = v∗(∼ϕ/g) (from a homomorphic property
of v∗)= v∗(φ/g). Vice versa, if w = v∗(φ/g) = v∗(∼ϕ)/g =∼v∗(ϕ/g) =∼z then,
from the inductive hypothesis, ℳ󳀀󳨐w,g∼F ℰ(ϕ), i. e., ℳ󳀀󳨐w,g ℰ(φ).
3.
For any formula φ = ϕ ⊙ψ, where ⊙∈{∧, ∨, →}, we have that ℳ󳀀󳨐w,g ℰ(φ) iff
ℳ󳀀󳨐w,g ℰ(ϕ ⊙ψ) iff ℳ󳀀󳨐w,g ℰ(ϕ) ⊙F ℰ(ψ) iff (∃y, z((w, y, z) ∈ℛ⊙and ℳ󳀀󳨐z,g
ℰ(ϕ) and ℳ󳀀󳨐y,g ℰ(ψ))), i. e., if w = z ⊙y (from a definition of relation ℛ⊙)=
v∗(ϕ/g) ⊙v∗(ψ/g) = v∗(ϕ/g ⊙ψ/g) (from a homomorphic property of v∗)= v∗((ϕ ⊙
ψ)/g) = v∗(φ/g). Vice versa, if w = v∗(φ/g) = v∗(ϕ ⊙ψ)/g = v∗(ϕ/g) ⊙v∗(ψ/g) =
z ⊙y then, from the inductive hypothesis, ℳ󳀀󳨐w,g ℰ(ϕ)∧F ℰ(ψ), i. e., ℳ󳀀󳨐w,g ℰ(φ).
Thus, for any Φ ∈ℒF we have that ‖Φ/g‖ = {w} for some w ∈𝒲, if Φ/g = ℰ(ϕ/g); other-
wise ‖Φ/g‖ = 0. Consequently, we have that ‖♦Φ/g‖ = {w | ∃y((w, y) ∈ℛ× and ℳ󳀀󳨐y,g
Φ)} = 𝒲if Φ/g = ℰ(ϕ/g); otherwise ‖♦Φ/g‖ = 0. That is, each sentence ♦Φ/g for any
Φ ∈ℒF is a 2-valued formula.
From Definition 119, we have seen how a many-valued model v of a logic program
PG uniquely determines a Kripke model ℳof its metalogic modal program PF. Let
us now show the opposite direction, i. e., how a Kripke model ℳof a modal logic
program PF obtained by ontological encapsulation of the original many-valued logic
program PG, determines uniquely a many-valued model v of the logic program PG. In
fact, we define uniquely the mapping v : H →X, as follows: for any modal atomic
formula ♦pF(c1, . . . , cn, α), true in the Kripke model ℳ, we set v(p(c1, . . . , cn)) = α. It is
easy to verify that such a definition of v : H →X is a Herbrand model of a many-valued
logic program PG.

448
|
A Appendix
This transformation of multivalued logic programs into 2-valued multimodal logic
programs can be briefly explained as follows: we transform the original multivalued
atoms into the meta 2-valued atoms by enlarging the original atoms with a new logic
attribute with the domain of truth values in X. This ontological encapsulation also
eliminates the negation (in this case the negation ∼) by introducing a unary modal
operator ∼F. The remained binary multivalued lattice operations are substituted by
the 2-valued binary modal operators with ternary accessibility relations.
Remark. In addition, this ontological encapsulation of logic programs into the posi-
tive (without the negation) modal programs can be used, with some opportune modi-
fications of the definitions above where a ground atom pF(c1, . . . cn, α) ∈HF is true only
for exactly one value α ∈X, to deal with the inconsistency of 2-valued logic programs:
the resulting positive modal program is a paraconsistent logic program, i. e., for any
given ground atom p(c1, . . . cn) of the original 2-valued logic program that is inconsis-
tent (both true and false), in the transformed consistent positive modal program we
can (consistently) have two true ground atoms, pF(c1, . . . cn, 1) and pF(c1, . . . cn, 0).
A.4.3 Binary sequent calculi for finite many-valued predicate logics
A short introduction to binary sequent calculus is provided in Section A.2. We are
able to reduce [204] the multivalued predicate logic ℒmv, with finite set of logic val-
ues aj ∈X, to the multimodal 2-valued algebraic logic language ℒ∗
M, by introducing
the finite number of modal nonstandard (nonmonotonic) algebraic truth-functional
operators [ai] : Y →2, where Y = X ⋃2 such that for any ai, aj ∈Y, [ai](aj) = 1 if
ai = aj; 0 otherwise.
Definition 120 (Syntax). Let ℒmv be a predicate many-valued logic language with Her-
brand base H, the set of valuations 𝕍= XH, such that each v ∈𝕍. v∗is homomorphi-
cally extended to all sentences ℒG
mv ⊂ℒmv, a finite set of truth values X (of a many-
valued logic with a set of logic operators in Σ) and the complete distributive two-valued
lattice (2, ∧, ∨). The multimodal 2-valued logic language ℒ∗
M is the set of all modal for-
mulae (we will use letters Φ, Ψ for the formulae of ℒ∗
M) defined as follows:
1.
2 ⊆ℒ∗
M.
2.
[ai]ϕ ∈ℒ∗
M, for any ai ∈X, ϕ ∈ℒmv.
3.
[ai]Φ ∈ℒ∗
M, for any ai ∈2, Φ ∈ℒ∗
M.
4.
Φ, Ψ ∈ℒ∗
M implies Φ ∧Ψ, Φ ∨Ψ ∈ℒ∗
M.
We denote the sublanguage of ℒ∗
M without free variables by ℒM (the ground atoms in
ℒM are considered as propositional letters).
The constants 0, 1 ∈2 correspond to the tautology and contradiction proposition,
respectively, and they can be considered as nullary operators in ℒM. We can use this

A.4 Reduction of many-valued into two-valued modal logics
|
449
2-valued multimodal logic language ℒM in order to define the sequents as elements
of the Cartesian product ℒM × ℒM, i. e., each sequent s is denoted by Φ ⊢Ψ, where
Φ, Ψ ∈ℒM.
Definition 121 (Algebraic semantics). For any many-valued valuation v ∈𝕍= XH ex-
tended to all formulae in ℒG
mv, we define the “modal valuation” α : ℒM →2, for any
ϕ ∈ℒG
mv, Φ, Ψ ∈ℒM, ai ∈X and ak ∈2, as follows:
1.
α(0) = 0, α(1) = 1.
2.
α([ai]ϕ) = 1 iff ai = v∗(ϕ).
3.
α([ak]Φ) = 1 iff ak = α(Φ).
4.
α(Φ ∧Ψ) = α(Φ) ∧α(Ψ), α(Φ ∨Ψ) = α(Φ) ∨α(Ψ).
This transformation from many-valued into modal valuations can be expressed by the
mapping F : 𝕍→𝕍M, where 𝕍M is the set of modal valuations α : ℒM →2.
It is easy to verify that the mapping F is a bijection, with its inverse F−1 defined as
follows: for any modal valuation α ∈𝕍M, for the many-valued valuation v = F−1(α) :
H →X, its unique extension for any sentence ϕ ∈ℒG
mv is defined by v∗(ϕ) = ai ∈X
iff α([ai]ϕ) = 1. A many-valued valuation v : H →X satisfies a 2-valued multimodal
formula Φ ∈ℒM iff F(v)(Φ) = 1.
Given two Φ, Ψ ∈ℒM, the sequent Φ ⊢Ψ is satisfied by v if F(v)(Φ) ≤F(v)(Ψ).
A sequent Φ ⊢Ψ is an axiom if it is satisfied by every valuation α ∈𝕍M.
From this definition of satisfaction for sequents, we obtain the reflexivity (axiom)
Φ ⊢Φ and transitivity (cut) inference rule, i. e., from Φ ⊢Ψ and Ψ ⊢ϒ, we deduce
Φ ⊢ϒ.
Let us define the set of 2-valued multimodal literals (or modal atoms) as
Pmm = {[a1] . . . [ak]A ∈ℒM | A ∈H and k ≥1}.
For example, if v∗(ϕ)
=
ai then F(v)([1][ai]ϕ)
=
1, while if v∗(ϕ)
̸=
ai then
F(v)([0][ai]ϕ) = 1. Notice that the number of nested modal operators can be reduced
from the fact that [0][0] and [1][1] are identities for the formulae in ℒM. For [ai]ϕ ∈ℒM,
we have [0][1][1][0][ai]ϕ ≡[0][0][ai]ϕ ≡[ai]ϕ, where ≡is a logic equivalence.
Then, given a formula ϕ ∈ℒG
mv, the modal formula [ai]ϕ ∈ℒM can be naturally
reduced to an equivalent formula, denoted by ?
[ai]ϕ, where the modal operators [ai]
are applied only to atoms in Herbrand base H (considered as propositional letters).
Moreover, for any formula Φ ∈ℒM, there is an equivalent formula ̂Φ composed by log-
ical connectives ∧, ∨, and by multimodal literals in Pmm. So, we obtain the canonical
reduction.
Definition 122 (Canonical reduction). Let us define the following reduction rules, for
ϕ, ψ ∈ℒG
mv, ai ∈X, Φ, Ψ ∈ℒM and aj ∈2:

450
|
A Appendix
1.
For any unary operator ∼∈Σ, [ai](∼ϕ) 󳨃→⋁ak∈X.ai=∼ak[ak]ϕ,
2.
For any binary operator ⊙∈Σ, [ai](ϕ ⊙ψ) 󳨃→⋁ak,an∈X.ai=ak⊙an([ak]ϕ ∧[an]ψ).
3.
For ⊙∈{∧, ∨}, [aj](Φ ⊙Ψ) 󳨃→⋁ak,an∈2.aj=ak⊙an([ak]Φ ∧[an]Ψ).
The canonic formula obtained by applying recursively these reduction rules to the for-
mula [ai]Φ is denoted by ?
[ai]Φ.
The next tree propositions for this canonical reduction has been proved in [344].
Proposition 50. Canonical reductions are truth preserving. That is, for any ai ∈X and
ϕ ∈ℒG
mv we have that [ai]ϕ is logically equivalent to ?
[ai]ϕ. Analogously, for any ai ∈2
and Φ ∈ℒM, we have that [ai]Φ is logically equivalent to ?
[ai]Φ.
The following proposition shows that the result of the canonical reduction of a for-
mula Φ ∈ℒM is a disjunction of modal conjunctions, which in the case of the formulae
without nested modal operators is a simple disjunctive modal formula.
Proposition 51. Any 2-valued logic formulae Φ ∈ℒM is logically equivalent to a dis-
junctive modal formula ⋁1≤i≤m(⋀1≤j≤mi([aij1] . . . [aijkij])Aij), where for all 1 ≤i ≤m, and
1 ≤j ≤mi, we have that 1 ≤kij, aijkij ∈X, and Aij ∈H.
In the case when we have no nested modal operators, then kij = 1 for all ij. Thus,
Φ ∈ℒM is logically equivalent to a disjunctive modal formula ⋁1≤i≤m[ai]ϕi, where for all
1 ≤i ≤m, ai ∈X, ϕi ∈ℒG
mv.
With this normal reduction, by using truth-value tables of many-valued logical
connectives, we introduced the structural compositionality and truth preserving for
the 2-valued modal encapsulation of a many-valued logic ℒmv as well. In fact, the fol-
lowing property is valid:
Proposition 52. Given a many-valued valuation v : H →X and a formula ϕ ∈ℒG
mv, the
normal reduct formula ?
[ai]ϕ ∈ℒM is satisfied by v iff ai = v∗(ϕ).
Thus, as a consequence, for any ϕ ∈ℒG
mv and a many-valued valuation v ∈𝕍, we
have that F(v)(?
[ai]ϕ) = 1 iff ai = v∗(ϕ).
We are able to define an equivalence relation ≈L between the formulae of any
many-valued logic based on the set of truth values X, in order to define the Linden-
baum algebra for this logic (ℒ/ ≈L), where for any two formulae ϕ, ψ ∈ℒG
mv, ϕ ≈L ψ
iff ∀v ∈𝕍(v∗(ϕ) = v∗(ψ)). Thus, the elements of this quotient algebra ℒ/ ≈L are the
equivalence classes, denoted by ⟨ϕ⟩.
In an autoreferential semantics [69, 81, 227], we assume that each equivalence
class of formulae ⟨ϕ⟩in this Lindenbaum algebra corresponds to one “state descrip-
tion.” In particular, we are interested in the subset of “state descriptions” that are
invariant w. r. t. many-valued interpretations v, so that can be used as the possible
worlds in the Kripke-style semantics for the original many-valued modal logic.

A.4 Reduction of many-valued into two-valued modal logics
|
451
Let us now consider the Kripke model for the 2-valued multimodal logic lan-
guage ℒM.
Definition 123 (Kripke semantics). Let ℒmv be a many-valued predicate logic lan-
guage, based on a set X of truth values, with a set of predicate letters P and Herbrand
base H. Let ℳv = (F, 𝒟, IK) be a Kripke model of its correspondent 2-valued multi-
modal logic language ℒ∗
M with the frame F = (𝒲, {ℛw = 𝒲× {w} | w ∈𝒲}) with the
set of possible worlds 𝒲= X ⋃2 and with mapping IK : 𝒲× P →⋃n<ω2𝒟n such that
for any n-ary predicate pn
j ∈P and tuple (c1, . . . , cn) ∈𝒟n, there exists a unique w ∈𝒲
such that IK(w, pn
j )(c1, . . . , cn) = 1.
It defines the Herbrand interpretation v : H →X such that v(pn
j (c1, . . . , cn)) = w iff
IK(w, pn
j )(c1, . . . , cn) = 1, and its unique homomorphic extension v∗: ℒG
mv →X.
For any many-valued formula ϕ ∈Lmv, the assignment g : 𝒱→𝒟and w ∈𝒲, the
satisfaction relation 󳀀󳨐w,g is defined by ℳv 󳀀󳨐w,g ϕ iff v∗(ϕ/g) = w.
It is extended to all modal formulae in ℒ∗
M as follows:
1.
ℳv 󳀀󳨐w,g 1 and ℳv ⊭w,g 0 for tautology and contradiction, respectively.
2.
ℳv 󳀀󳨐w,g [ai]Φ iff ∀w′((w, w′) ∈ℛai implies ℳv 󳀀󳨐w′,g Φ), for any Φ ∈ℒ∗
M or
Φ ∈ℒmv.
3.
ℳv 󳀀󳨐w,g Φ ∧Ψ iff ℳv 󳀀󳨐w,g Φ and ℳv 󳀀󳨐w,g Ψ, for Φ, Ψ ∈ℒ∗
M.
4.
ℳv 󳀀󳨐w,g Φ ∨Ψ iff ℳv 󳀀󳨐w,g Φ or ℳv 󳀀󳨐w,g Ψ, for Φ, Ψ ∈ℒ∗
M.
Let Ψ/g ∈ℒM be a sentence obtained from Ψ ∈ℒ∗
M by assignment g. So, we denote
the set of worlds where the sentence Ψ/g ∈ℒM is satisfied by ‖Ψ/g‖, with
󵄩󵄩󵄩󵄩pn
j (x1, . . . , xn)/g󵄩󵄩󵄩󵄩= {v(pn
j (g(x1), . . . , g(xn))}
and
‖ϕ/g‖ = {v∗(ϕ/g))},
ϕ ∈ℒmv.
Different from the many-valued ground atoms in ℒmv, the modal atoms in ℒM have the
standard 2-valued property: they are true or false in these Kripke models. So, this pos-
itive multimodal logic with modal atoms ℒM satisfies the classic 2-valued properties.
Proposition 53. For any sentence Φ/g of the positive multimodal logic ℒM defined in
Definition 120, ‖Φ/g‖ ∈{0, 𝒲}, where 0 is the empty set.
Proof. By structural induction:
1.
‖1‖ = 𝒲and ‖0‖ = 0, and ‖[ai]ϕ/g‖ = 𝒲if ai = v(ϕ/g); 0 otherwise.
Let Φ, Ψ be the two atomic modal formulae such that, by inductive hypothesis
‖Φ/g‖, ‖Ψ/g‖ ∈{0, 𝒲}. Then,
2.
‖[ai]Φ‖ = {w ∈𝒲| ai ∈‖Φ/g‖} = 𝒲if ‖Φ/g‖ = 𝒲; 0 otherwise.
3.
‖(Φ ∧Ψ)/g‖ = ‖Φ/g‖ ⋂‖Ψ/g‖ ∈{0, 𝒲}.
4.
‖(Φ ∨Ψ)/g‖ = ‖Φ/g‖ ⋃‖Ψ/g‖ ∈{0, 𝒲}.

452
|
A Appendix
Thus, from the fact that any formula Φ ∈ℒ∗
M is logically equivalent to disjunctive
modal formula ⋁1≤i≤m(⋀1≤j≤mi([aij1] . . . [aijkij])Aij) (from Proposition 51), where each
Aij ∈H is a ground atom (such that by inductive hypothesis for any modal atom it is
true that ‖([aij1] . . . [aijkij])Aij/g‖ ∈{0, 𝒲}), and from points 3 and 4 above, we obtain
that
‖Φ/g‖ =
󵄩󵄩󵄩󵄩󵄩󵄩󵄩󵄩
⋁
1≤i≤m
( ⋀
1≤j≤mi
([aij1] . . . [aijkij])Aij/g)
󵄩󵄩󵄩󵄩󵄩󵄩󵄩󵄩
∈{0, 𝒲}.
The following proposition demonstrates the existence of a one-to-one correspon-
dence between the unique many-valued model of a many-valued logic ℒmv and the
Kripke model of a multimodal positive logic ℒM. The proof is provided in [344] by
structural recursion and by Propositions 53 and 32.
Corollary 32. For any many-valued formula ϕ/g ∈ℒmv and v : H →X,
v(ϕ/g) = ai
iff
F(v)([ai]ϕ/g) = 1 iff ‖[ai]ϕ/g‖ = 𝒲,
and for any sentence Φ/g ∈ℒM, F(v)(Φ/g) = 1 iff ‖Φ/g‖ = 𝒲, (i. e., Φ/g is true in the
Kripke model in Definition 123).
From this corollary, we obtain that any true formula Φ ∈ℒM is also true in the
Kripke model, and vice versa. That is, the autoreferential Kripke-style semantics for
the multi-modal logic ℒM, in Definition 123, is sound and complete.
Binary sequent calculi
The Gentzen-like system 𝒢of the 2-valued propositional logic ℒM (where the set of
propositional letters corresponds to the set Pmm = {[a1] . . . [ak]A ∈ℒM | k ≥1 and A ∈
H}) is a 2-valued distributive logic (DLL in [193]), i. e., 2 ⊆ℒM, extended by the set of
sequent axioms, defined for each many-valued logic connective in Σ of the logic ℒmv,
by:
(AXIOMS) The Gentzen-like system 𝒢= ⟨𝕃, ⊩⟩contains the following sequents in 𝕃
for any Φ, Ψ, ϒ ∈ℒM and many-valued sentences ϕ, ψ ∈ℒG
mv:
1.
Φ ⊢Φ (reflexive)
2.
Φ ⊢1, 0 ⊢Φ (top/bottom axioms)
3.
Φ ∧Ψ ⊢Φ, Φ ∧Ψ ⊢Ψ (product projections: axioms for meet)
4.
Φ ⊢Φ ∨Ψ, Φ ⊢Ψ ∨Φ (coproduct injections: axioms for join)
5.
Φ ∧(Ψ ∨ϒ) ⊢(Φ ∧Ψ) ∨(Φ ∧ϒ) (distributivity axiom)
6.
The set of introduction axioms for many-valued connectives:
6.1 ⋁ak,an∈2.ai=ak⊙an([ak]Φ ∧[an]Ψ) ⊢[ai](Φ ⊙Ψ), for any ⊙∈{∧, ∨}.
6.2 ⋁ak∈X.ai=∼ak[ak]ϕ ⊢[ai](∼ϕ), for any unary operator ∼∈Σ.
6.3 ⋁ak,an∈X.ai=ak⊙an([ak]ϕ ∧[an]ψ) ⊢[ai](ϕ ⊙ψ), for any binary operator ⊙∈Σ.
7.
The set of elimination axioms for many-valued connectives:

A.4 Reduction of many-valued into two-valued modal logics
|
453
7.1
[ai](Φ ⊙Ψ) ⊢⋁ak,an∈2.ai=ak⊙an([ak]Φ ∧[an]Ψ), for any ⊙∈{∧, ∨}.
7.2 [ai](∼ϕ) ⊢⋁ak∈X.ai=∼ak[ak]ϕ, for any unary operator ∼∈Σ.
7.3 [ai](ϕ ⊙ψ) ⊢⋁ak,an∈X.ai=ak⊙an([ak]ϕ ∧[an]ψ) f,or any binary operator ⊙∈Σ.
(INFERENCE RULES) 𝒢is closed under the following inference rules:
1.
Φ⊢Ψ,Ψ⊢ϒ
Φ⊢ϒ
(cut/transitivity rule)
2.
Φ⊢Ψ,Φ⊢ϒ
Φ⊢Ψ∧ϒ , Φ⊢Ψ,ϒ⊢Ψ
Φ∨ϒ⊢Ψ (lower/upper lattice bound rules)
3.
Φ⊢Ψ
σ(Φ)⊢σ(Ψ) (substitution rule: σ is substitution (γ/p)).
The axioms from 1 to 5 and the rules 1 and 2 are taken from [193] for the DLL and it was
shown that this sequent based Gentzen-like system is sound and complete. The new
axioms 6 and 7 correspond to the canonical (equivalent) reductions in Definition 122.
The set of sequents that define the poset of the classic 2-valued lattice of truth values
(2, ≤) is a consequence of the top/bottom axioms: for any two ai, ak ∈2, if ai ≤ak then
ai ⊢ak ∈𝒢.
Thus, for many-valued logics, we obtain a normal modal Gentzen-like deductive
system, where each sequent is a valid truth-preserving consequence-pair defined by
the poset of the complete lattice (2, ≤) of classic truth values (which are also the con-
stants of this positive propositional language ℒM), so that each occurrence of the sym-
bol ⊢can be substituted by the partial order ≤of this complete lattice (2, ≤).
Example 56. Let us consider the Gödel’s 3-valued logic X = {0, 1
2, 1} with implication:
⇒
0
1
2
1
0
1
1
1
1
2
0
1
1
1
0
1
2
1
One of the possible m-sequents for introduction rules for this connective, taken from
[345], (each rule corresponds to the conjunction of disjunctive forms, where each dis-
junctive form is one m-sequent in the premise), is
⟨Γ|△, ϕ|Π, ϕ⟩⟨Γ1, ψ| △1 |Π1⟩
⟨Γ, Γ1, ϕ ⇒ψ|△, △1|Π, Π1⟩⇒: 0,
⟨Γ| △|Π, ϕ⟩⟨Γ1|△1, ψ|Π1⟩
⟨Γ, Γ1, |△, △1, ϕ ⇒ψ|Π, Π1⟩⇒: 1
2
⟨Γ, ϕ|△, ϕ|Π, ψ⟩⟨Γ1, ϕ|△1, ψ|Π1, ψ⟩
⟨Γ, Γ1, |△, △1|Π, Π1, ϕ ⇒ψ⟩
⇒: 1
but in our approach, we obtain the unique set of binary sequent introduction axioms:
([1
2]ϕ ∧[0]ψ) ∨([1]ϕ ∧[0]ψ) ⊢[0](ϕ ⇒ψ)
[1]ϕ ∧[1
2]ψ ⊢[1
2](ϕ ⇒ψ)

454
|
A Appendix
⋁
ai,ak∈X&(ai,ak)∉S
([ai]ϕ ∧[ak]ψ) ⊢[1](ϕ ⇒ψ)
where S = {( 1
2, 0), (1, 0), (1, 1
2)}, and elimination axioms:
[0](ϕ ⇒ψ) ⊢([1
2]ϕ ∧[0]ψ) ∨([1]ϕ ∧[0]ψ)
[1
2](ϕ ⇒ψ) ⊢[1]ϕ ∧[1
2]ψ
[1](ϕ ⇒ψ) ⊢
⋁
ai,ak∈X&(ai,ak)∉S
([ai]ϕ ∧[ak]ψ).
Definition 124. For any two formulae Φ, Ψ ∈ℒM when the sequent Φ ⊢Ψ is satisfied
by a 2-valued modal valuation α : ℒM →2 from Definition 121 (i. e., when α(Φ) ≤α(Ψ)
as in standard 2-valued logics), we say that it is satisfied by the many-valued valuation
v = F−1(α) : H →X. This sequent is a tautology if it is satisfied by all modal valuations
α = F(v) ∈𝕍M, i. e., when ∀v ∈𝕍.(F(v)(Φ) ≤F(v)(Ψ)).
For a normal Gentzen-like sequent system 𝒢= ⟨𝕃, ⊩⟩of a many-valued logic lan-
guage ℒmv, with the set of sequents 𝕃⊆ℒM ×ℒM, we tell that a many-valued valuation
v is its model if it satisfies all sequents in 𝒢. The set of all models of a given set of se-
quents Γ is
𝕍Γ = {v ∈𝕍| ∀(Φ ⊢Ψ) ∈Γ(F(v)(Φ) ≤F(v)(Ψ))} ⊆𝕍.
The following proposition has been proven in [344].
Proposition 54 (Sequent’s bivaluations and soundness). Let us define the mapping
B : 𝕍→2ℒM×ℒM from valuations into sequent bivaluations such that for any valua-
tion v ∈𝕍, we obtain the sequent bivaluation β = B(v) = eq ∘⟨π1, ∧⟩∘(F(v) × F(v)) :
ℒM × ℒM →2, where π1 is the first projection, ∘is the functional composition and
eq : 2 × 2 →2 is the equality mapping such that eq(ai, ak) = 1 iff ai = ak.
Then a sequent s = (Φ ⊢Ψ) is satisfied by v iff β(s) = B(v)(s) = 1.
All axioms of the Gentzen-like sequent system 𝒢, of a many-valued logic language
ℒmv based on a set X of truth values are tautologies, and all of its rules are sound for
model satisfiability and preserve the tautologies.
It is easy to verify that this entailment is equal to the classic propositional entail-
ment.
Remark. It is easy to observe that each sequent is, from the logic point of view,
a 2-valued object so that all inference rules are embedded into the classic 2-valued
framework, i. e., given a bivaluation β = B(v) : ℒM × ℒM →2, we have that a se-
quent s = Φ ⊢Ψ is satisfied, β(s) = 1 iff F(v)(Φ) ≤F(v)(Ψ), so that we have a direct
relationship between sequent bivaluations β and many-valued valuations v.

A.4 Reduction of many-valued into two-valued modal logics
|
455
The definition of the 2-valued entailment in the sequent system 𝒢, given in Defini-
tion 124, can replace the current entailment based on algebraic matrices (X, D) where
D ⊆X is a subset of designated elements. Thus, we are now able to introduce the
many-valued valuation-based (i. e., model-theoretic) semantics for many-valued log-
ics [227].
Definition 125. A many-valued model-theoretic semantics of a given many-valued
logic ℒ, with a Gentzen system 𝒢= ⟨𝕃, ⊩⟩, is the semantic deducibility relation 󳀀󳨐m,
defined for any set Γ = {si = (Φi ⊢Ψi)} and a sequent s = (Φ ⊢Ψ) ∈𝕃⊆ℒM × ℒM, by
Γ 󳀀󳨐m s
iff
all many-valued models of Γ are the models of s,
iff
∀v ∈𝕍(∀(Φi ⊢Ψi) ∈Γ)(F(v)(Φi) ≤F(v)(Ψi) implies F(v)(Φ) ≤F(v)(Ψ)).
Lemma 16 ([344]). For any set Γ = {si = (Φi ⊢Ψi)} and a sequent s = (Φ ⊢Ψ), we have
that Γ 󳀀󳨐m s iff ∀v ∈𝕍Γ(B(v)(s) = 1).
So, any many-valued logic has a Gentzen-like system 𝒢= ⟨𝕃, ⊩⟩(see the definition
at the beginning of this section) is a normal logic. Many-valued model theoretic seman-
tics is an adequate semantics for a many-valued logic ℒmv specified by a Gentzen-like
logic system 𝒢= ⟨𝕃, ⊩⟩, i. e., it is sound and complete [344]. It is shown by Theorem 16
in Section A.3.1 that Γ 󳀀󳨐m s iff Γ ⊩s.
Thus, in order to define the model-theoretic semantics for finite many-valued log-
ics, we do not need to use the matrices: we are able to use only the many-valued valu-
ations and many-valued models (i. e., the valuations which satisfy all sequents in Γ of
a given many-valued logic ℒmv).
Example 57. Let us show that given an assumption Γ = {1 ⊢[ai]ϕ, 1 ⊢[ak]ψ} then
[an](ϕ ⊙ψ) for an = ai ⊙ak is deduced from Γ, i. e., Γ ⊩([an](ϕ ⊙ψ)); or equivalently
if [ai]ϕ and [ak]ψ are valid (i. e., for every valuation v ∈𝕍, v : H →X, the values of
ϕ and ψ are equal to ai and ak, respectively, i. e., ∀v ∈𝕍.(v∗(ϕ) = ai and v∗(ψ) = ak))
then [an](ϕ ⊙ψ) is valid as well.
As a first step, we introduce the equivalence relation ≡such that Φ ≡Ψ iff Φ ⊢
Ψ and Ψ ⊢Φ (i. e., Φ iff Ψ). Consequently, from the reflexivity axiom in 𝒢, Φ ≡Φ, as for
example, 1 ≡1. The equivalent formulae can be used in the substitution inference rule:
if Φ ≡Ψ, then we can use the substitution of Φ by Ψ, i. e., the substitution σ : Φ 󳨃→Ψ.
Let us show the simple equivalence Φ ∨Φ ≡Φ: from the reflexivity axiom Φ ⊢Φ,
by using the upper bound inference rule (when Ψ = Φ), we deduce Φ ∨Φ ⊢Φ. Then,
from the axioms for join Φ ⊢Φ ∨Φ, we obtain Φ ∨Φ ≡Φ.
Now, from the assumptions 1 ⊢[ai]ϕ, 1 ⊢[ak]ψ ∈Γ, by the lower bound inference
rule in 𝒢, we obtain (a) 1 ⊢[ai]ϕ ∧[ak]ψ, i. e., Γ ⊩(1 ⊢[ai]ϕ ∧[ak]ψ). Let an = ai ⊙ak
and let us denote [ai]ϕ ∧[ak]ψ by Φ, so that (a) becomes (a′) 1 ⊢Φ. Now we can
take the axiom for join, (b) Φ ⊢Φ ∨⋁aj,am∈X.aj⊙am=an([aj]ϕ ∧[am]ψ), so from (a′) and
(b) and the transitivity rule, we obtain 1 ⊢Φ ∨⋁aj,am∈X.aj⊙am=an([aj]ϕ ∧[am]ψ), i. e.,

456
|
A Appendix
(c) 1 ⊢Φ ∨Φ ∨Ψ, where Ψ = ⋁aj,am∈X(aj ̸=ai,am ̸=ak,aj⊙am=an)([aj]ϕ ∧[am]ψ). Thus, by
substitution σ : {1 󳨃→1, Φ ∨Φ 󳨃→Φ} and by applying the substitution rule to (c), we
deduce the sequent 1 ⊢Φ ∨Ψ. That is, (d) 1 ⊢⋁aj,am∈X.aj⊙am=an([aj]ϕ ∧[am]ψ) (from
Φ ∨Ψ = ⋁aj,am∈X,aj⊙am=an([aj]ϕ ∧[am]ψ)). Consequently, by applying the transitivity
rule to the sequent (d) and the introduction axiom ⋁aj,am∈X,aj⊙am=an([aj]ϕ ∧[am]ψ) ⊢
[an](ϕ ⊙ψ), we deduce 1 ⊢[an](ϕ ⊙ψ), i. e.,
Γ ⊩(1 ⊢[an](ϕ ⊙ψ)).
Notice that in such deductions, no value of ai, ak, an need to be a designated value. We
do not make any distinction for the truth values in X.
Based on Suszko’s thesis, with a nonconstructive approach based on a distinc-
tion between designated and undesignated algebraic truth values, in these sections
we analyzed a different possibility of reducing these many-valued logics into 2-valued
logics in a constructive way. The reduction of a many-valued logic with finite set X into
2-valued logic, results in a nontruth-functional modal metalogic, which obviously is
not an original “reference” many-valued logic. This process is explained by the fact
that this reduction is based on new sentences about the original many-valued sen-
tences, and that, by avoiding the second-order syntax of these metasentences, what
is required is the introduction of new modal operators in this equivalent but 2-valued
metalogic.
A.4.4 General abstract reductions of many-valued into 2-valued logics
The term “abstract” used for this general many-valued reduction means that we do
not consider any further the specific reduction of particular functional logic operators
in Σ of a many-valued logic into correspondent modal operators, but rather a general
reduction independent of them, based on structural consequence operations or ma-
trices.
In what follows, we will provide a reduction of a many-valued predicate logic
ℒmv, with a Herbrand base H and subset of sentences ℒG
mv, into a 2-valued logic. For a
given set of thesis (sentences) Γ of a many-valued logic ℒmv, by Γ 󳀀󳨐ϕ we denote the
2-valued structural consequence relation (entailment), which means that a sentence
ϕ is a structural consequence of the set of sentences in Γ, i. e., that ϕ ∈C(Γ) where
C : 𝒫(ℒG
mv) →𝒫(ℒG
mv) is a structural consequence (closure) operation conforming
Tarski’s conditions for a logic.
We denote by 𝕍= XH the set of Herbrand many-valued interpretations v : H →X,
v ∈𝕍, for a many-valued logic ℒmv with a Herbrand base H and a set of algebraic
truth values in X. Let 𝕍Γ ⊂𝕍be a nonempty subset of models of Γ, i. e., valuations
v ∈𝕍Γ that satisfy every sentence in Γ. Then the truth of Γ 󳀀󳨐ϕ is equivalent to the
fact that every valuation v ∈𝕍Γ is a model of ϕ (i. e., satisfies a sentence ϕ) as well.

A.4 Reduction of many-valued into two-valued modal logics
|
457
In the case when we consider a many-valued logic with a given matrix (X, D), where
D ⊂X is a subset of designated algebraic truth values (see also Section 2.2.1 for a short
introduction, based on the work of Jan Lukasiewicz [78–81]), the well-known matrix-
based inference is specified by (extension of v to ϕ ∈ℒG
mv is denoted by v∗):
Γ 󳀀󳨐ϕ
iff
(∀v ∈𝕍Γ).(v∗(ϕ) ∈D)
(A.5)
with the set of models 𝕍Γ of Γ defined as the set of valuations v such that (∀ψ ∈
Γ).(v∗(ψ) ∈𝒟). In the classic 2-valued truth-invariance semantics of logic entailment,
we have
(CL) Γ 󳀀󳨐ϕ iff (∀v ∈𝕍Γ).(v∗(ϕ) = 1).
Thus, classic 2-valued entailment deduces both true and false sentences if they have
the same truth value in all models of Γ with D = {1} ⊂2. The consequence relation
󳀀󳨐1 defines the Tarskian closure operator C : 𝒫(ℒG
mv) →𝒫(ℒG
mv) such that C(Γ) = {ϕ |
ϕ ∈ℒG
mv and Γ 󳀀󳨐1 ϕ}. In the 2-valued logics, we do not need to use the consequence
relation 󳀀󳨐0 because the set of false sentences deduced from Γ is equal to the set {¬ϕ |
ϕ ∈ℒG
mv and Γ 󳀀󳨐1 ϕ} = {¬ϕ | ϕ ∈C(Γ)}. This particular property explains why, in
the classic 2-valued logic, it is enough to consider only the consequence relation for
deduction of true sentences, or alternatively the Tarskian closure operator C.
In the case of many-valued logics, it is not generally the case and we need the
consequence relations for the derivation of sentences that are not true as well. Conse-
quently, we will extend this classic 2-valued model-theoretic truth-invariance seman-
tics of logic entailment (5.2) in Definition 57, Section 5.1, to many-valued logics as well.
It is easy to verify that both semantics, the truth-invariance (5.2) and the matrix-based
(A.5), in the case of classic 2-valued logics, where D = {1}, coincide. As we will see,
both abstract reductions will result in a kind of 2-valued modal logic that are not truth-
functional, as we obtained in the specific case for logic programs in Section A.4.2.
First case
In [346], Suszko’s thesis was presented. This paper is extremely dense and very short,
and thus it is not easy to understand; it is a kind of synthesis, in four pages, of some
deep reflections carried out by Suszko over 40 years. Only 15 years after this publica-
tion, Malinowski’s book [347] has thrown some light on it (see especially Chapter 10,
Section 10.1). Unfortunately, neither the quoted paper by Suszko nor Malinowski’s
book explicitly state Suszko’s thesis, but in another paper [348] Malinowski has writ-
ten:
“Suszko’s thesis … states that each logic, i. e., a structural consequence operation conforming
Tarski’s conditions, is logically two-valued,” and (p. 73)
“each (structural) propositional logic (L, C) can be determined by a class of logical valuations of
the language ℒor, in other words, it is logically two-valued.”

458
|
A Appendix
In what follows, for a fixed set of (initial) thesis Γ ⊂ℒG
mv that defines a structural many-
valued logic (Γ, C), we will transform the left-side construct Γ 󳀀󳨐( _ ) in a composed
modal operator ◻Γ (“Γ-deductive”), so that a metasentence Γ 󳀀󳨐ϕ can be replaced by
an equivalent modal formula ◻Γϕ in this 2-valued metalogic.
Thus, analogously to the more specific cases for logic programs, also in this gen-
eral abstract 2-valued reduction we are not speaking about the two-valuedness of an
original many-valued formula, but about a modal formula of a 2-valued metalogic ob-
tained by this transformation. What remains now is to define a Kripke semantics for
this modal meta-logic, denoted by ℒℱ, obtained from a set of sentences ℱ= {◻Γϕ |
ϕ ∈ℒG
mv} and the standard 2-valued logic connectives (conjunction, disjunction, im-
plication and negation).
Definition 126. Given a structural many-valued logic (Γ, C), where Γ ⊂ℒG
mv is a subset
of theses, with Herbrand base H, let 𝕍Γ ⊂XH be a nonempty subset of models of Γ,
i. e., the set of valuations v : H →X that satisfy every sentence in Γ.
We define a Kripke-style model for sentences of modal metalogic ℒℱ, based on
Suszko’s reduction ℱ= {◻Γϕ | ϕ ∈ℒG
mv} where ◻Γ = ◊◻, by ℳ= (𝒲, ℛ◊, ℛ◻, 𝒟, IK),
with the set of possible worlds 𝒲= Γ×𝕍Γ, ℛ◊= {((ϕi, v), (ϕk, v)) | (ϕi, v) ∈𝒲, ϕk ∈Γ},
ℛ◻= {((ϕi, v), (ϕi, v1)) | (ϕi, v) ∈𝒲, v1 ∈𝕍Γ} and IK : 𝒲× ℒG
mv →2, such that for any
many-valued sentence ψ ∈ℒG
mv and a world w = (ϕi, v) ∈𝒲:
IK(w, ψ) = IK((ϕi, v), ψ) = 1
iff
v∗(ψ) ≥v∗(ϕi)
(A.6)
where v∗is unique extension of Herbrand interpretation v : H →X to all sentences
in ℒG
mv. The satisfaction relation 󳀀󳨐w, for a world w = (ϕi, v) ∈𝒲, for any many-valued
sentence ψ, ϕ ∈ℒG
mv, is defined as follows:
1.
ℳ󳀀󳨐w ψ iff IK(w, ψ) = 1.
2.
ℳ󳀀󳨐w ◻Γψ iff ℳ󳀀󳨐w ◊◻ψ iff ∃w1((w, w1) ∈ℛ◊and ℳ󳀀󳨐w1 ◻ψ) iff ∃w1((w, w1) ∈
ℛ◊and (∀w2((w1, w2) ∈ℛ◻implies ℳ󳀀󳨐w2 ψ)),
3.
ℳ󳀀󳨐w ¬◻Γψ iff not ℳ󳀀󳨐w ◻Γψ,
4.
ℳ󳀀󳨐w ◻Γϕ ∧◻Γψ iff ℳ󳀀󳨐w ◻Γϕ and ℳ󳀀󳨐w ◻Γψ,
5.
ℳ󳀀󳨐w ◻Γϕ ∨◻Γψ iff ℳ󳀀󳨐w ◻Γϕ or ℳ󳀀󳨐w ◻Γψ,
6.
ℳ󳀀󳨐w ◻Γϕ →◻Γψ iff ℳ󳀀󳨐w ◻Γϕ implies ℳ󳀀󳨐w ◻Γψ,
where the logic connectives ∧, ∨, →and ¬ are the classic 2-valued conjunction, dis-
junction, implication and negation, respectively.
Notice that a satisfaction of the 2-valued formulae of this metalogic ℒℱ, obtained
by Suszko’s reduction of the original many-valued logic, is relative to points from 2
to 6 in the definition above. Consequently, the two-valuedness is a property not of the
original many-valued formulae, but of the modal formulae in this nontruth-functional
modal meta-logic. Let us show that this reduction is sound and complete.

A.4 Reduction of many-valued into two-valued modal logics
|
459
Lemma 17. Given a Kripke model ℳ= (𝒲, ℛ◊, ℛ◻, 𝒟, IK) in Definition 126, for a given
many-valued logic (Γ, C), where Γ ⊂ℒG
mv is a subset of sentences, then for any formula
ϕ ∈ℒmv and assignment g we have that
Γ 󳀀󳨐ϕ/g
iff
◻Γϕ/g is true in ℳ.
Proof. From point 2 in Definition 126, from the fact that ∃w1(w, w1) ∈ℛ◊for w1 = (ϕk, v)
is equivalent to ∃ϕk ∈Γ and ∀w2((w1, w2) ∈ℛ◻from w2 = (ϕk, v1) is equivalent to
∀v1 ∈𝕍Γ, we obtain that
ℳ󳀀󳨐w ◻Γϕ/g
iff
(∃ϕk ∈Γ).(∀v1 ∈𝕍Γ).(v∗
1 (ϕ/g) ≥v∗
1 (ϕk))
i. e., from definition (5.2), ℳ󳀀󳨐w ◻Γϕ/g iff Γ 󳀀󳨐ϕ/g, and from the fact that it holds for
any w ∈𝒲, we obtain that Γ 󳀀󳨐ϕ/g iff ‖◻Γϕ/g‖ = 𝒲, i. e., ◻Γϕ/g is true in ℳ.
These results confirm da Costa’s idea [349] that a reduction to 2-valuedness can
be done at an abstract level, without taking into account the underlying structure of
the set of many-valued formulae (different from the particular case of logic programs
given in Section A.4.2).
Second case
It is not necessary to make a detour by matrices in order to get this reduction. But in
the case where we have a many-valued logic with a given matrix (X, D), where D ⊂
X is a subset of designated algebraic truth values, then we are able to define a new
modal 2-valued reduction for such a many-valued logic, based on the universal modal
operator ◻D (“matrix-deductive”). What remains now is to define a Kripke semantics
for this matrix-based reduction to a modal metalogic, denoted by ℒℰ, obtained from a
set of formulae {◻Dϕ | ϕ ∈ℒG
mv} and standard 2-valued logic connectives (conjunction,
disjunction, implication and negation).
Definition 127. Given a many-valued logic ℒmv with a given matrix (X, D) and a Her-
brand base H, let 𝕍Γ ⊂𝕍= XH be a nonempty subset of models of Γ, i. e., the set of
valuations v : H →X that satisfy every sentence in Γ.
We define a Kripke-style model of modal metalogic ℒℰ, based on Suszko’s matrix-
based reduction {◻Dϕ | ϕ ∈ℒG
mv}, by ℳ= (𝒲, ℛD, 𝒟, IK), with the set of possible
worlds 𝒲= 𝕍, accessibility relation ℛD = 𝒲× 𝕍Γ for universal modal operator ◻D,
and IK : 𝒲× ℒG
mv →2, such that for any many-valued sentence ψ ∈ℒG
mv and a world
w ∈𝒲,
IK(w, ψ) = 1
iff
w∗(ψ) ∈D
(A.7)
where w∗is unique extension of Herbrand interpretation w : H →X to all sentences
in ℒG
mv. The satisfaction relation 󳀀󳨐w, for a world w ∈𝒲, for any many-valued sentence
ψ, ϕ ∈ℒG
mv, is defined as follows:

460
|
A Appendix
1.
ℳ󳀀󳨐w ψ iff IK(w, ψ) = 1.
2.
ℳ󳀀󳨐w ◻Dψ iff ∀w1((w, w1) ∈ℛD implies ℳ󳀀󳨐w1 ψ),
3.
ℳ󳀀󳨐w ¬◻Dϕ iff not ℳ󳀀󳨐w ◻Dϕ
4.
ℳ󳀀󳨐w ◻Dϕ ∧◻Dψ iff ℳ󳀀󳨐w ◻Dϕ and ℳ󳀀󳨐w ◻Dψ
5.
ℳ󳀀󳨐w ◻Dϕ ∨◻Dψ iff ℳ󳀀󳨐w ◻Dϕ or ℳ󳀀󳨐w ◻Dψ
6.
ℳ󳀀󳨐w ◻Dϕ →◻Dψ iff ℳ󳀀󳨐w ◻Dϕ implies ℳ󳀀󳨐w ◻Dψ,
where the logic connectives ∧, ∨, →and ¬ are the classic 2-valued conjunction, dis-
junction, implication and negation, respectively.
Notice that a satisfaction of the 2-valued formulae of this metalogic ℒℰ, obtained
by the matrix-based reduction of original many-valued logic, is relative to points 2 to
6 in the definition above.
Let us show that this matrix-based reduction is sound and complete.
Lemma 18. Let ℳ= (𝒲, ℛD, 𝒟, IK) be a Kripke model, given in Definition 127, for a
many-valued logic (Γ, C) with a matrix (X, D), where Γ ⊂ℒG
mv is a subset of sentences,
then for any formula ϕ ∈ℒmv and assignment g, from definition (A.5), we have that
Γ 󳀀󳨐ϕ/g
iff
◻Dϕ/g is true in ℳ.
Proof. From point 2 in Definition 127, from the fact that ∀w1((w, w1) ∈ℛD) is equivalent
to ∀w1 ∈𝕍Γ, we obtain that ℳ󳀀󳨐w ◻Dϕ/g iff (∀w1 ∈𝕍Γ).(w∗
1 (ϕ/g) ∈D), i. e., from
definition (A.5), ℳ󳀀󳨐w ◻Dϕ/g iff Γ 󳀀󳨐ϕ/g, and from the fact that it holds for any
w ∈𝒲, we obtain that Γ 󳀀󳨐ϕ/g iff ‖◻Dϕ/g‖ = 𝒲, i. e., ◻Dϕ/g is true in ℳ.
A.5 Basic category theory
Category theory is an area of mathematics that examines in an abstract way the prop-
erties of particular mathematical concepts, by formalizing them as collections of
objects and arrows (also called morphisms, although this term also has a specific,
noncategory-theoretic sense), where these collections satisfy certain basic condi-
tions. Many significant areas of mathematics can be formalized as categories, and
the use of category theory allows many intricate and subtle mathematical results in
these fields to be stated and proved, in a much simpler way than without the use of
categories.
The most accessible example of a category is the category Set of sets, where the
objects are sets and the arrows are functions between them. However, it is important
to note that the objects of a category need not be sets or the arrows functions; any way
of formalizing a mathematical concept such that it meets the basic conditions on the
behavior of objects and arrows is a valid category, and all the results of category theory
will apply to it.

A.5 Basic category theory
|
461
Categories were first introduced by Samuel Eilenberg and Saunders Mac Lane in
1942–1945 [181], in connection with algebraic topology. The study of categories is an
attempt to axiomatically capture what is commonly found in various classes of re-
lated mathematical structures by relating them to the structure-preserving functions
between them. A systematic study of category theory then allows us to prove general
results about any of these types of mathematical structures from the axioms of a cat-
egory.
A category C consists of the following three mathematical entities:
–
A class ObC whose elements are called objects;
–
A class MorC whose elements are called morphisms or maps or arrows. Each mor-
phism f has a unique source object A and target object B. The expression (arrow)
f : A →B would be verbally stated as “f is a morphism from A to B.” The expres-
sion hom(A, B) — alternatively expressed as homC(A, B), or mor(A, B), or C(A, B) —
denotes the hom-class of all morphisms from A to B. If for all A, B this hom-class
is a set, this category C is called locally small.
–
A binary operation ∘, called composition of morphisms, such that for any three ob-
jects A, B and C, we have a function ∘: hom(A, B) × hom(B, C) →hom(A, C). Each
morphism f ∈hom(A, B) has a domain A = dom(f) and codomain B = cod(f),
which are objects.
The composition of f : A →B and g : B →C is written as g ∘f , with two axioms:
Associativity: If f : A →B, g : B →C and h : C →D, then h ∘(g ∘f ) = (h ∘g) ∘f,
Identity: For every object A, there exists a morphism idA : A →A called the
identity morphism for A, such that for every morphism f : A →B, we have
idB ∘f = f ∘idA = f.
From these axioms, it can be proved that there is exactly one identity morphism for
every object. Because of that we can identify each object with its identity morphism.
Relations among morphisms are often depicted using commutative diagrams, with
nodes representing objects and arrows representing morphisms, e. g., g ∘f = h is
graphically represented by the following commutative diagram:
A
f
? B
C
g
?
g ∘f
?
Examples:
1.
Category Set, where the objects are sets and the arrows are functions from one set
to another.
2.
A preorder is a set X together with a binary relation ≤, which is reflexive (i. e., x ≤x
for all x ∈X), and transitive (i. e., x ≤y and y ≤z imply x ≤z for all x, y, z ∈X).

462
|
A Appendix
This can be seen as a category, with set of objects X and for every pair of objects
(x, y) such that x ≤y, exactly one arrow x →y.
3.
Any set X can be seen as a discrete category, with a set of objects X and only with
the identity morphisms.
A morphism f : A →B can have any of the following properties:
1.
Monomorphism (or monic) if f ∘g1 = f ∘g2 implies g1 = g2 for all morphisms g1, g2 :
X →A. It is denoted by f : A 󳨅→B.
2.
Epimorphism (or epic) if g1 ∘f = g2 ∘f implies g1 = g2 for all morphisms g1, g2 : B →
X. It is denoted by f : A 󴀀󴀤B. This epic is called split if there is g : B →A such that
f ∘g = idB (then f is a retraction of g).
3.
Isomorphism if there exists a morphism g : B →A such that f ∘g = idB and g ∘f =
idA. It is denoted by f : A ≃B. Often we denote simply by A ≃B the isomorphism
of two objects. If f is split epic and monic, f is an isomorphism.
For example, in Set the epimorphisms are surjective functions, the monomorphisms
are injective functions, the isomorphisms are bijective functions.
Duality principle
The definition of epic is dual to the definition of monic. Given a category C = (ObC,
MorC, id, ∘), by COP = (ObC, MorCOP, id, ∘COP) we denote the opposite category that have
the same objects and where all arrows are reversed: f COP ∘COP gCOP = (g ∘f )COP (see
diagram (A.8)), with bijection C(A, B) ≃COP(B, A). Thus, f is monic in the category C
iff f OP is epic in COP, and vice versa. In general, given a property P of an object, arrow,
diagram, etc., we can associate with P the dual property POP. The object or arrow has
a property P in C iff it has POP in COP. For example, if g ∘f is monic then f is monic.
From this, by duality, if f OP ∘gOP is epic then f OP is epic.
An object X is called terminal if for any object Y there is exactly one morphism
from it into X in the category. Dually, one object X is called initial if for any object Y
there is exactly one morphism from X to Y in the category. An object X is called the
zero object if it is both terminal and initial. For example, in Set the empty set is initial,
while any singleton set is (up to isomorphism) the terminal object.
Given two categories C and D, we can define the product category C×D, which has
as objects pairs (X, Y) ∈ObC × ObD and as arrows: (X, Y) →(X′, Y′) pairs (f , g) with
f : X →X′ in C, and g : Y →Y′ in D.
Functors are structure-preserving maps between categories. They can be thought
of as morphisms in the category Cat of all (small) categories as objects, and all functors
as morphisms. A (covariant) functor F from a category C to a category D, written F :
C →D, consists of a pair of functions F = (F0, F1), F0 : ObC →ObD and F1 : MorC →
MorD (in what follows, we will simply use F for both functions as well):

A.5 Basic category theory
|
463
1.
For each object X in C, an object F0(X) in D; and
2.
For each morphism f : X →Y in C, a morphism F1(f) : F0(X) →F0(Y), such that
the following two properties hold:
3.
For every object X in C, F1(idX) = idF(X);
4.
For all morphisms f : X →Y and g : Y →Z, F1(g ∘f) = F1(g) ∘F1(f).
A contravariant functor F : C →D, is like a covariant functor, except that it “turns
morphisms around” (“reverses all the arrows”). More specifically, every morphism
f : X →Y in C must be assigned to a morphism F1(f) : F0(Y) →F0(X) in D. In
other words, a contravariant functor is a covariant functor from the opposite category
Cop to D. Opposite category Cop has the same objects as the category C. Given a com-
position of arrows f ∘g in C its opposite arrow in Cop is (f ∘g)OP = gOP ∘f OP.
Every functor preserves epi, mono and isomorphisms.
A locally small category C, for any object X, has a representable functor FX =
C(X, _ ) : C →Set, such that for any object Y, FX(Y) = C(X, Y), and any arrow f :
Y →Y′ gives by composition a function FX(f) : C(X, Y) →C(X, Y′).
A functor F : C →D is called full if for every two objects A and B of C, F : C(A, B) →
D(F(A), F(B)) is a surjection. A functor F is called faithful if this map is always injective.
A functor F is called an endofunctor if D = C.
A functor F reflects a property P if whenever the F-image of something (object,
arrow, etc.) has P, then that that something has P. For example, the faithful functor
reflects epimorphisms and monomorphisms. Each endofunctor F : C →C defines the
algebras and coalgebras (the left and right commutative diagrams)
F(A)
F(f)? F(B)
F(A)
F(f1)? F(B)
A
h
?
f
? B
k
?
A
h1
?
f1
? B
k1
?
so that the morphism f : (A, h) →(B, k), which represents the commutative diagram
on the left, is a morphism between F-algebras (A, h) and (B, k). For example, let F :
Set →Set be the polynomial endofunctor, such that for the set A of all reals, F(A) =
A + A + A2 + A2 (where + is a disjoint union) we can represent the algebra for operators
{exp : A →A, log : A →A, max : A2 →A, min : A2 →A}, where A2 is the Cartesian
product A × A, by the morphism h = [exp, log, max, min] : (A + A + A2 + A2) →A in Set,
i. e., by the F-algebra (A, h).
Analogously, the morphism f1 : (A, h1) →(B, k1), which represents the commuta-
tive diagram on the right, is a morphism between F-coalgebras (A, h1) and (B, k1).
Let G : D →C be a functor, and C an object of C. A universal arrow from C to G is
a pair (D, g) where D is an object of D and g : C →G(D) a morphism in C such that,

464
|
A Appendix
for any object D′ of D and morphism f : C →G(D′), there exists a unique morphism
̂f : D →D′ in D such that f = G(̂f) ∘g. Diagrammatically,
C
g ? G(D)
D
G(D′)
G(̂f )
?
f
?
D′
̂f
?
A natural transformation is a relation between two functors. Functors often describe
“natural constructions” and natural transformations then describe “natural homo-
morphisms” between two such constructions. Sometimes two quite different construc-
tions yield “the same” result; this is expressed by a natural isomorphism between the
two functors.
If F and G are (covariant) functors between the categories C and D, then a natural
transformation η from F to G associates to every object X in C a morphism ηX : F(X) →
G(X) in D such that for every morphism f : X →Y in C, we have ηY ∘F(f) = G(f ) ∘ηX.
This means that the following diagram is commutative:
F(X)
F(f)? F(Y)
G(X)
ηX
?
G(f)? G(Y)
ηY
?
Example. Let P and Q be two preorders, regarded as categories. A functor F from P to
Q is a monotone function, and there exists a unique natural transformation between
two such, η : F
󳐂? G, exactly if F(X) ≤G(X) for all X in P.
If η : F
󳐂? G and ε : G
󳐂? H are natural transformations between functors
F, G, H : C →D, then we can compose them to get a natural transformation ε ∙η :
F
󳐂? H.
This is done componentwise: (ε ∙η)X = εX ∘ηX : F(X) →H(X).
This vertical composition of natural transformation is associative and has an iden-
tity, and allows one to consider the collection of all functors C →D itself as a category
DC of all functors from C to D.
There is also a horizontal composition of natural transformations, given the func-
tors F, G : B →C, F′, G′ : C →D, and two natural transformations η : F
󳐂? G and ε :
F′
󳐂? G′, defined by ε ∘η : F′ ∘F
󳐂? G′ ∘G, between the composed functors
F′ ∘F, G′ ∘G : B →D.
The two functors F and G are called naturally isomorphic if there exists a natural
transformation η from F to G such that ηX is an isomorphism for every object X in C.

A.5 Basic category theory
|
465
The Yoneda lemma is one of the most famous basic results of category theory. It
describes representable functors in functor categories. The Yoneda embedding for any
given category C is given by the covariant functor H : C →SetCOP such that, for any
object X in C, we obtain the contravariant hom-functor hX = COP(X, _) : COP →Set.
Consequently, for any object Y′ in COP, hX(Y1) = COP(X, Y1), while for any arrow
f OP : Y1 →Y2 in COP, we obtain the arrow (function) in Set, hX(f OP) : COP(X, Y1) →
COP(X, Y2) is a composition with f OP, i. e., for any gOP : X →Y1 in COP(X, Y1) we obtain
the arrow hX(f OP)(gOP) = f OP∘gOP = (g∘f)OP : X →Y2, such that the following diagram
commutes in COP (or, dually in C):
Y2 ? f OP
Y1
Y2
f
? Y1
X
gOP
?
?
COP
(g ∘f )OP
X
g ∈C(Y1, X)
?
in C
g ∘f
?
(A.8)
In the case when f OP : Y1 →Y2 in COP is a universal arrow, the function hX(f OP) :
COP(X, Y1) →COP(X, Y2) (an arrow in Set) is a bijection.
Let us consider two significant cases of Yoneda embedding for categorial products
and coproducts (without the necessity to introduce the more general case of limits and
colimits):
1. The universal arrows for the products f OP = (π1, π2) : (A × B, A × B) 󴀀󴀤(A, B) in
COP = D × D, and a given object X = (C, C) ∈COP, where π1 : A × B 󴀀󴀤A, π2 : A ×
B 󴀀󴀤B are two epimorphisms in D corresponding to the first and second projections,
respectively. Thus, we obtain the following case for the commutative diagram above
in COP = D × D (and its corresponding commutative diagram in D on the right), where
Y2 = (A, B) and Y1 = (A × B, A × B), gOP = (⟨k, l⟩, ⟨k, l⟩) : (C, C) →(A × B, A × B), with
k : C →A, l : C →B two arrows in D:
(A, B)
?(π1, π2)
(A × B, A × B)
A ?? π1
A × B
π2 ?? B
(C, C)
gOP
?
?
COP
(k, l)
C
⟨k, l⟩
?
l
?
?
in D
k
The bijective function hX(f OP) : COP(X, Y1) →COP(X, Y2) in this case means that for
any arrow (k, l) : (C, C) →(A, B) in COP(X, Y2) (i. e., the couple of arrows k : C →A,
l : C →B in D) there is the unique arrow (⟨k, l⟩, ⟨k, l⟩) : (C, C) →(A × B, A × B) in
COP(X, Y1) (i. e., the unique arrow ⟨k, l⟩: C →A × B in D).
2. Universal arrows for the coproducts f = (in1, in2) : (A, B) 󳨅→(A + B, A + B) in
C = D × D, and a given object X = (C, C) ∈C, where in1 : A 󳨅→A + B, in2 : B 󳨅→

466
|
A Appendix
A + B are two monomorphisms in D corresponding to the first and second injections,
respectively. Thus, we obtain the following case for the commutative diagram above
in C = D × D (and its corresponding commutative diagram in D on the right), where
Y2 = (A, B) and Y1 = (A + B, A + B), g = ([k, l], [k, l]) : (A + B, A + B) →(C, C), with
k : A →C, l : B →C two arrows in D:
(A, B)
(in1, in2)?
(A + B, A + B)
A ⊂
in1? A + B ?in2
⊃B
(C, C)
g
?
in C
(k, l)
?
C
[k, l]
?
?
l
in D
k
?
The bijective function hX(f OP) : C(Y1, X) →C(Y2, X) in this case means that for any
arrow (k, l) : (A, B) →(C, C) in C(Y2, X) (i. e., the couple of arrows k : A →C, l : B →C
in D) there is the unique arrow ([k, l], [k, l]) : (A + B, A + B) →(C, C) in C(Y1, X) (i. e.,
the unique arrow [k, l] : A + B →C in D).
For example, in Set the object A×B is the Cartesian product of the set A and set B,
while A + B is the disjoint union of the set A and set B.
Products and coproducts are the particular cases of adjunctions. Given two func-
tors F : C →D, G : D →C, we say that F is left adjoint to G, or G is right adjoint
to F, is there are the natural isomorphism: θ : C( _ , G( _ ))
󳐂? D(F( _ ), _ ), where
C( _ , G( _ )) : COP × D →Set is the result of composing the bivariant hom-functor
C( _ , _ ) with IdCOP × G, and D(F( _ ), _ ) is similar.
Equivalently, they are adjoint if there are two natural transformations, counit ε :
FG
󳐂? IdD and unit η : IdC
󳐂? GF, such that the following diagrams of natural
transformations commute:
G
󳐂
η ⋆G
? GFG
F
󳐂
F ∘η
? FGF
G
󳐂G ∘ε
?
󳐂
IdG
?
F
󳐂ε ⋆F
?
󳐂
IdF
?
where η ⋆G denotes the natural transformation with components (functions) ηG(X) :
G(X) →GFG(X) and G∘ε denotes the natural transformation with components G(εX) :
GFG(X) →G(X), for each object X in D.
This adjunction is denoted by tuple (F, G, ε, η), with ηC : C →G(F(C)) a universal
arrow for each object C. In fact, for any object D′ in D and morphism f : C →G(D′)
there exists a unique morphism ̂f : D →D′, where D = F(C), such that the following

A.5 Basic category theory
|
467
two adjoint diagrams commute:
C
ηC? G(F(C))
F(C)
F(f )
? F(G(D′))
G(D′)
G(̂f)
?
f
?
D′
̂f
?
?
εD′
so that ηC is a universal arrow from C into G and, dually, εD′ is a couniversal arrow
from F into D′. Consequently, in a given adjunction, the unit η generates a universal
arrow for each object in C and counit ε generates a couniversal arrow for each object
in D. In the case when C and D are poset categories, f and ̂f define this adjunction as
a Galois connection, denoted by F ⊣G.
In category theory, the abstract notion of a limit captures the essential properties
of universal constructions such as products, pullbacks and inverse limits. The dual
notion of a colimit generalizes constructions such as disjoint unions, direct sums, co-
products, pushouts and direct limits. Limits and colimits, like the strongly related no-
tions of universal properties and adjoint functors, exist at a high level of abstraction.
Limits and colimits in a category C are defined by means of diagrams in C.
For example, the equalizers are a particular case of limits (of pullbacks). For each
pair of simple morphisms f , g : A →B, the LimE is a limit object (up to isomorphism)
of the diagram B ?f
?
g
A, so that the following diagram is an equalizer:
B ?
f
?
g
A ?
h
⊃LimE
C
k
?
...............
?
m
with f ∘h = g ∘h where h is a monomorphism (every equalizer is monic), and for any
arrow m such that f ∘m = g ∘m, there is a unique arrow k such that m = h ∘k.
Two categories C and D are equivalent if they are adjoint with the unit and counit
whose components are all isomorphisms.
Given an adjunction (F, G, ε, η), let us look at the endofunctor T = GF : C →C.
We have a natural transformation η : idC
󳐂? T and a natural transformation μ :
T2
󳐂? T with components for each object C, μC = G(εF(C)) : T2C →TC (here T2
denotes the composition TT and T3 the composition TTT). Furthermore, the equalities
(commutative diagrams of natural transformations)

468
|
A Appendix
T3
󳐂
Tμ
? T2
T
󳐂
ηT
? T2 ?
󳐂
Tη
T
T2
μT 󳐂
?
󳐂
μ
? T
󳐂μ
?
T
󳐂μ
?
?
󳐂
idT
󳐂
idT
?
(A.9)
hold. Here, (Tμ)C = T(μC) : T3C →TC and (μT)C = μTC : T3C →TC (similarly for
ηT and Tη).
A triple (T, η, μ) satisfying these equalities is called a monad.
The notion of a monad is one of the most general mathematical notions. For in-
stance, every algebraic theory, i. e., every set of operations satisfying equational laws,
can be seen as a monad (which is also a monoid in a category of endofunctors of a
given category: the “operation” μ being the associative multiplication of this monoid
and η its unit).
Thus, monoid laws of the monad do subsume all possible algebraic laws.
We will use monads [181–183] for giving denotational semantics to database map-
pings, and more specifically as a way of modeling computational/collection types [176,
177, 184, 185].
A dual structure to a monad is a comonad (T, ηC, μC) such that all arrows in the
commutative monad’s diagrams above are inverted, so that we obtain
T3 ?
󳐂
TμC
T2
T ?
󳐂
ηC
T
T2
󳐂
TηC ? T
T2
μCT 󳐂
?
?
󳐂
μC
T
󳐂μC
?
T
󳐂μC
?
󳐂
idT
?
?
󳐂
idT
A monoidal category is a structure (C, ⊗, I, α, β, γ) where C is a category, ⊗: C ×
C →C is a functor (tensor), I is a distinguished object of C (unit), α, β, γ are natural
transformations (structural isos for associativity, left and right identity) with compo-
nents: αA,B,C : (A ⊗B) ⊗C ≃A ⊗(B ⊗C), βA : I ⊗A ≃A, γA : A ⊗I ≃A, such that the
following diagrams commute (coherence conditions):
(A ⊗I) ⊗B
αA,I,B
? A ⊗(I ⊗B)
A ⊗B
?
idA ⊗βB
γA ⊗idB
?

A.5 Basic category theory
|
469
((A ⊗B) ⊗C) ⊗D
αA,B,C ⊗idD
? (A ⊗(B ⊗C)) ⊗D
αA,B⊗C,D
? A ⊗((B ⊗C) ⊗D)
((A ⊗B) ⊗(C ⊗D)
αA⊗B,C,D
?
αA,B,C⊗D
? A ⊗(B ⊗(C ⊗D))
idA ⊗αB,C,D
?
A strict monoidal category is one for which all of these natural transformations are
identities.
If the category is finitely complete and has the exponentiation as well, then it is a
Cartesian Closed Category (CCC). We say that a category has exponentiation if it has a
product for any two objects, and if for any given objects B and C there is an object CB
and an arrow evalB,C : CB × B →C, called an evolution arrow, such that for any object
A and arrow f : A×B →C, there is a unique arrow Λ(f) : A →CB making the following
diagram commute:
CB × B
evalB,C? C
A × B
Λ(f )
?
idB
?
f
?
(A.10)
such that evalB,C ∘(Λ(f) × idB) = f. The assignment of the curried3 function Λ(f ) to f
establishes a bijection Λ from the arrows from A × B to C and the arrows from A to CB.
The most known CCC is the category Set, and the meaning of the diagram above is
simple:
For each pair of elements a ∈A and b ∈B, we obtain a function h =def Λ(f)(a) :
B →C, such that by applying the function evalB,C we obtain that it applies the function
h to the element b, so that evalB,C(h, b) =def h(b) = f(a, b).
This very short introduction to category theory is dedicated to experts in DB the-
ory, which did not work previously with the concepts of the category theory.
A.5.1 Categorial symmetry
The concept of categorial symmetry was introduced in my PhD thesis [59] with a num-
ber of its applications. Here, I will only introduce some of the fundamental properties
3 Currying provides a way for working with functions that take multiple arguments, and using them
in frameworks where functions might take only one argument. This property is inherited from lambda
calculus, where multiargument functions are usually represented in curried form. A curried function is
a function, which takes multiple parameters one at a time, by taking the first argument, and returning
a series of functions, which each take the next argument until all the parameters have been fixed, and
the function application can complete, at which point, the resulting value is returned.

470
|
A Appendix
of this particular class of categories, which has been considered in the database cat-
egory DB. It is well known that all categories can be defined by only their morphisms
(arrows) because each object is equivalently represented by its identity morphism.
Fundamentally, a symmetric category has a nice property of a kind of (incomplete) du-
ality between objects and arrows. In fact, there is an operator ′∗′ for the composition
of objects, analogous to the standard composition of arrows ′∘′. However, differently
from ∘that is not commutative (preserves the sequential composition of the arrows),
the composition ∗of objects can be a (not necessarily) commutative binary operator
as well, because the objects have no directionality.
The objects obtained from arrows will be called conceptualized objects. For ex-
ample, let us consider the polynomial function f(x) = (x2 −3x + 1), with the domain
being the closed interval of reals from 0 to 1, and codomain ℝof all reals. It is an arrow
f : [0, 1] →ℝin the category Set. The conceptualized object obtained from this arrow,
denoted by ̃f , is the set (hence an object in Set) equal to the graph of this polynomial
function. That is, ̃f = {(x, f(x)) | x ∈[0, 1]} ∈ObSet. Let us now formally introduce the
following definitions [59] for the categorial symmetry.
Definition 128 (Categorial symmetry). Let C be a category with a function BT
:
MorC 󳨀→ObC such that for each identity arrow idA : A →A, BT(idA) ≃A (the “rep-
resentability” principle), and with an associative composition operator for objects ∗
such that, for any composition g ∘f ∈MorC of arrows, BT(g) ∗BT(f ) = BT(g ∘f ).
The conceptualized object BT(f) of an arrow f : A 󳨀→B in C will be denoted by ̃f.
Remark. This symmetry property allows us to consider all properties of an arrow as
properties of objects and their compositions. For a given category C, its “arrow cate-
gory” is denoted by C ↓C. Objects of this arrow category are the triples ⟨A, B, f⟩where
f : A →B is a morphism in C, and each morphism in this arrow category is a couple
of two morphisms (k1; k2) : ⟨A, B, f ⟩→⟨C, D, g⟩such that k2 ∘f = g ∘k1 : A →D.
Let us introduce, for a category C and its arrow category C ↓C, an encapsulation
operator J : MorC 󳨀→ObC↓C and its inverse ψ, such that for any arrow f : A 󳨀→B,
J(f) = ⟨A, B, f⟩is its corresponding object in C ↓C and ψ(⟨A, B, f⟩) = f .
We denote the first and the second comma functorial projections by Fst, Snd : (C ↓
C) 󳨀→C such that for any arrow (k1; k2) : ⟨A, B, f ⟩→⟨A′, B′, g⟩in C ↓C (i. e., when
k2 ∘f = g ∘k1 in C) we have that F0
st(⟨A, B, f⟩) = A, F1
st(k1; k2) = k1, S0
nd(⟨A, B, f ⟩) =
B and S1
nd(k1; k2) = k2. It is easy to extend the operator ψ into a natural transformation
ψ : Fst
󳐂? Snd such that its component for an object J(f) in C ↓C is the arrow
ψJ(f ) = ψ(J(f)) = f. We denote the diagonal functor by 󳵳: C 󳨀→(C ↓C) such that, for
any object A in a category C, 󳵳0(A) = ⟨A, A, idA⟩.
An important subset of symmetric categories are the conceptually closed and ex-
tended symmetric categories, as follows.

A.5 Basic category theory
|
471
Definition 129. [59] A conceptually closed category is a symmetric category C with a
functor Te = (T0
e , T1
e) : (C ↓C) 󳨀→C, such that T0
e = BTψ, i. e., BT = T0
e J, with a natural
isomorphism φ : Te ∘󳵳⋍IC, where IC is an identity functor for C.
C is an extended symmetric category if τ−1 ∙τ = ψ : Fst
󳐂? Snd, for vertical
composition of natural transformations τ : Fst
󳐂? Te and τ−1 : Te
󳐂? Snd.
It is easy to verify also that in extended symmetric categories the following is valid:
τ = (T1
e(τIF0
st; ψ)) ∙(φ−1F0
st),
τ−1 = (φ−1S0
nd) ∙(T1
e(ψ; τIS0
nd)),
where τI : IC 󳨀→IC is an identity natural transformation (for any object A in C, τI(A) =
idA).
Example 58. The Set is an extended symmetric category: given any function f
:
A 󳨀→B, the conceptualized object of this function is the graph of this function
(which is a set),
̃f = BT(f) =def {(x, f(x)) | x ∈A}.
The composition of objects ∗is defined as an associative composition of binary re-
lations (graphs of functions), BT(g ∘f) = {(x, (g ∘f)(x)) | x ∈A} = {(y, g(y)) | y ∈
B} ∘{(x, f(x)) | x ∈A} = BT(g) ∗BT(f ).
Set is also conceptually closed by the functor Te, such that for any object J(f) =
⟨A, B, f ⟩, T0
e (J(f )) =def BT(f ) = {(x, f (x)) | x ∈A}, and for any arrow (k1; k2) : J(f) →J(g),
the component T1
e is defined by,
for any (x, f(x)) ∈T0
e (J(f )),
T1
e(k1; k2)(x, f(x)) = (k1(x), k2(f(x))).
It is easy to verify the compositional property for T1
e, and that T1
e(idA; idB) =
idT0
e (J(f )). For example, Set is also an extended symmetric category, such that for any
object J(f ) = ⟨A, B, f⟩in Set ↓Set, τ(J(f)) : A 󴀀󴀤BT(f) is an epimorphism, such that for
any x ∈A, τ(J(f))(x) = (x, f(x)), while τ−1(J(f)) : BT(f ) 󳨅→B is the second projection,
such that for any (x, f(x)) ∈BT(f),
τ−1(J(f))(x, f (x)) = f(x).
Thus, each arrow in Set is a composition of an epimorphism (surjective function) and
a monomorphism (injective function).
The categorial symmetry can be better understood by considering a category C as
a two-sorted algebra AlgC = ((ObC, MorC), ΣC) (two-sorted carrier set is composed of its
objects and its morphisms) with the signature ΣC = {dom, cod, id, ∘} ⋃{oi | 0 ≤i ≤n},
where:

472
|
A Appendix
1.
dom, cod : MorC →ObC are two operations such that for any morphism f : A →B,
dom(f ) = A, cod(f) = B;
2.
id : ObC →MorC is the operation such that for any object A, id(A) = idA : A →A
is the identity arrow for this object;
3.
∘: Mor2
C →MorC is a partial function, such that for any two morphisms f, g, f ∘g
is defined if dom(f) = cod(g), with the following set of equations:
–
associativity: (f ∘g) ∘h = f ∘(g ∘h), if dom(g) = cod(h) and dom(f) = cod(g),
–
identity: f ∘id(dom(f)) = f and id(cod(f)) ∘f = f ;
4.
For each operator oi ∈ΣC, the composition of objects oi : Obar(oi)
C
→ObC (as, e. g.,
the product, coproduct, etc.), or the composition of morphisms oi : Morar(oi)
C
→
MorC (as, e. g., the product, coproduct, the various pairings (structural opera-
tions) (, ), ⟨, ⟩, [, ], etc.).
Consequently, the categorial symmetry can be done by following corollary:
Corollary 33. A category C is symmetric if for its algebra AlgC = ((ObC, MorC), ΣC) we
have the additional binary partial operator ∗: Ob2
C →ObC and unary operator BT ∈ΣC
which is a homomorphism BT : (MorC, ∘) →(ObC, ∗), such that for every object A ∈ObC
there exists the isomorphism, BT(id(A)) ≃A (representability principle).
Notice that the partial operations can be equivalently represented by a set of stan-
dard (total) operations. For example, the partial operation “∘” can be equivalently rep-
resented by the set of total operations, {∘A,B,C : C(A, B) × C(B, C) →C(A, C) | A, B, C ∈
OBC}.
A significant example of such categorial symmetry, here applied to database map-
ping, is the DB category, as introduced in Section A.6 and developed in [21].
A.5.2 Kripke polynomial functors and predicate lifting
We shall be using a particular collection of functors (on a category Set with sets as
objects and functions between them as arrows), T : Set →Set, as interfaces of coal-
gebras. These so-called Kripke polynomial functors are built up inductively from the
identity and constants, using products, coproducts (disjoint unions), exponents (with
constants) and powersets. Products of sets S1, S2, written as S1 × S2, have two projec-
tions πi : S1 × S2 →Si (for i = 1, 2). Coproducts, S1 + S2, come with injective functions
κi : Si →S1 + S2 (for i = 1, 2). The collection of functions from a set X to Y is denoted
by YX with the evaluation mapping evalX,Y : YX × X →Y.
For a function f : Y →Z, there is an associated function f X : YX →ZX by g 󳨃→f ∘g,
where ∘is a composition of functions. The covariant powerset functor 𝒫: Set →Set
sends a set Y to the set of its subsets 𝒫(Y) = {S | S ⊆Y}, and a function f : Y →Z to
the function 𝒫(f) : 𝒫(Y) →𝒫(Z) given by image: S 󳨃→f (S) = {f(y) | y ∈S}.

A.5 Basic category theory
|
473
Definition 130. The collection of Kripke polynomial functors (KPFs) is defined as fol-
lows:
1.
The identity functor Id : Set →Set is a KPF.
2.
For each nonempty finite set D, the constant functor D : Set →Set, given by
X 󳨃→D and (f : Y →Z) 󳨃→idD, is a KPF.
3.
The product X 󳨃→T1(X) × T2(X) of two KPFs T1, T2 is a KPF.
4.
The coproduct X 󳨃→T1(X) + T2(X) of two KPFs T1, T2 is a KPF.
5.
For a KPF T, and an arbitrary nonempty set D the exponent functor X 󳨃→T(X)D is
a KPF.
6.
For a KPF T, the functor X 󳨃→𝒫(T(X)) is a KPF.
The collection of finite KPFs is constructed in the same way, except that in the last
point the finite powerset 𝒫fin is used, instead of the ordinary one.
A coalgebra of a KPF, T : Set →Set, consists of a set X, usually called the state
space or set of states, together with a function c : X →T(X), giving the operations of
the coalgebra. A homomorphism of coalgebras from c : X →T(X) to d : Y →T(Y)
is a function f : X →Y between the underlying state spaces, which commutes with
operations: d ∘f = T(f) ∘c.
Now we will consider [285, 286] the unfolding and structural properties of Kripke
Polynomial Functors (KPFs), T : Set →Set, such that T = . . . S . . . is a composition of
its KPFs subcomponents S. We shall make such occurrences explicit by defining how
such an S can be reached via a path p inside T, denoted by a relation p : T 󴁄󴀼S.
The path p is a finite set of symbols (see the paragraph for KPF) π1, π2, κ1, κ2, ev(d), for
elements d ∈D of sets D occurring as exponents in T.
Definition 131. The relation p : T 󴁄󴀼S, for any two KPFs, is the least relation defined
as follows:
1.
⟨⟩: T 󴁄󴀼T, where ⟨⟩is the empty list.
2.
π1 ⋅p : T1 × T2 󴁄󴀼T for p : T1 󴁄󴀼S, and π2 ⋅p : T1 × T2 󴁄󴀼T for p : T2 󴁄󴀼S.
3.
κ1 ⋅p : T1 + T2 󴁄󴀼T for p : T1 󴁄󴀼S, and κ2 ⋅p : T1 + T2 󴁄󴀼T for p : T2 󴁄󴀼S.
4.
eval(d) ⋅p : TD 󴁄󴀼S for all d ∈D and p : T 󴁄󴀼S.
5.
𝒫⋅p : 𝒫(T) 󴁄󴀼S for all p : T 󴁄󴀼S.
We define the set of (global) nextime-modal operators Op(T) of the KPF T as Op(T) =
{p | p : T 󴁄󴀼Id}.
It is easy to see that these paths can be composed (via concatenation of lists): if
p : T1 󴁄󴀼T2 and q : T2 󴁄󴀼T3, then p ⋅q : T1 󴁄󴀼T3.
Basically, we are only interested in the paths having identity functors as targets,
but for a generality we introduce the following general concept of a “predicate lifting”
[285, 286].

474
|
A Appendix
Definition 132. For a path p : T 󴁄󴀼S and an arbitrary set X, there is a “predicate
lifting” function ( _ )p : 𝒫(S(X)) →𝒫(T(X)), defined on Y ⊆S(X) by induction on p:
1.
Y⟨⟩= Y.
2.
Yπi⋅p = {z | πi(z) ∈Yp}, for i = 1, 2.
3.
Yκi⋅p = {z | ∀y.z = κi(y) ⇒y ∈Yp}, for i = 1, 2.
4.
Yeval(d)⋅p = {f | f (d) ∈Yp}.
5.
Y𝒫⋅p = {Z | Z ⊆Yp}.
For a coalgebra c : X →T(X), we define for a modal operator (p : T 󴁄󴀼Id) ∈Ob(T)
and interpretation function [p] : 𝒫(X) →𝒫(X), for any Y ∈𝒫(X),
[p](Y) = c−1(Yp) = {x ∈X | c(x) ∈Yp};
(A.11)
thus, [p] = c−1 ∘( _ )p.
Example 59. The frame (X, R⪯), for R⪯⊆X2, can be represented by the coalgebra γ :
X →𝒫(X), and for any x ∈X, γ(x) is the set of all successors of the point x (i. e., the
set of all x′ such that (x, x′) ∈R⪯, or, equivalently, x′ ⪯x).
Let us consider the unique modal operator p = 𝒫: T 󴁄󴀼Id for the functor T = 𝒫.
Thus, we obtain its interpretation function [𝒫] such that for any Y ⊆X,
[𝒫](Y) = γ−1((Y)𝒫) = γ−1({Z | Z ⊆Y}) = {x ∈X | γ(x) ∈{Z | Z ⊆Y}}
= {x ∈X | γ(x) ⊆Y},
i. e., this modal operator is the standard universal modal operator ◻.
A.6 Introduction to RDB, database mappings and DB category
Database schema mappings are so important in information integration that many
mapping formalisms have been proposed for different tasks. A schema mapping is
a high-level declarative specification of the relationship between two schemas; it
specifies how data structured under one schema, called source schema, is to be con-
verted into data structured under possibly different schema, called the target schema.
It the last decade, schema mappings have been fundamental components for both
data exchange and data integration. In this work, we will consider the declarative
schema mappings between relational databases. A widely used formalism for specify-
ing relational-to-relational schema mappings is that of tuple generating dependencies
(tgds). In the terminology of data integration, tgds are equivalent to global-and-local-
as-view (GLAV) assertions. Using a language that is based on tgds for specifying (or
“programming”) database schema mappings has several advantages over lower-level
languages, such as XSLT scripts of Java programs in that it is declarative and it has
been widely used in the formal study of the semantics of data exchange and data

A.6 Introduction to RDB, database mappings and DB category
|
475
integration. Declarative schema mapping formalisms have been used to provide for-
mal semantics for data exchange [143], data integration [111], peer data management
[350, 351], pay-as-you-go integration systems [352] and model management operators
[353].
Most of the work in the data integration/exchange and peer-to-peer (P2P) frame-
work is based on a logical point of view (particularly for the integrity constraints, in or-
der to define the right models for certain answers) in a “local” mode (source-to-target
database) where proper attention to the general “global” problem of the compositions
of complex partial mappings, which possibly involve a high number of databases has
not been given. Today, this “global” approach cannot be avoided because of the ne-
cessity of P2P open-ended networks of heterogenous databases. Recently [21], we pro-
vided a definition of a DB category for the database mappings, which has to be more
suitable than a generic Set domain category since the databases are more complex
structures w. r. t. the sets and the mappings between them are so complex that they
cannot be represented by a single function (which is one arrow in Set). In such an
enriched categorical semantic domain for the databases, it is possible:
–
To give a proper solution for a general problem of complex database-mappings
and for the high-level algebra operators of the databases (merging, matching,
etc.), by preserving the traditional common practice logical language for schema
database mapping definitions.
–
The schema mapping specifications are not the integral parts of the standard
relational-database theory (used to define a database schema with its integrity
constraints); they are the programs and we need an enriched denotational se-
mantics context that is able to formally express these programs (derived by the
mappings between the databases).
–
Let us consider, e. g., the P2P systems or the mappings in a complex data ware-
house. We would like to have a synthetic graphical representations of the database
mappings and queries and to be able to develop a graphical tool for the metamap-
ping descriptions of complex (and partial) mappings in various contexts, with a
formal mathematical background.
Hence, we need a framework of interdatabase mappings. The main difference between
the previous categorial approaches to databases and that presented in [21] is the level
of abstraction used for the prime objects of the theory.
Another difference is methodological. In fact, the logics for relational databases
are based on different kinds of First-Order Logic (FOL) sublanguages as, e. g., descrip-
tion logic, relational database logic, DATALOG, etc. So, the previous work on cate-
gorical semantics for the DB theory strictly follows an earlier research for categorial
many-sorted FOL on the predicates with types where each attribute of a predicate has
a particular sort with a given set of values. Thus, the fibred semantics for predicates
is assumed for such a typed logic, where other basic operations as negation, conjunc-
tion and FOL quantifiers (that are algebraically connected with the Galois connection

476
|
A Appendix
of their types, traduced by left and right adjunction of their functors in categorical
translation) are defined algebraically in such a fibrational formulation. This algebraic
method, of translation the FOL in a categorical language, is successively and directly
applied to the DB theory seen as a sublanguage of the FOL. So, there are no the new re-
sults, from the previous developed for the FOL, in this translation of DB-theory into a
categorical framework. No new particular base category is defined for databases (dif-
ferent from Set), as it happened in the cases, e. g., of the Cartesian Closed Categories
(CCC) for typed λ-calculus, Bicartesian closed poset categories for Heyting algebras,
or the elementary topos (with the subobject classifier diagrams) for the intuitionistic
logic [354, 355]. Basically, all previously works use the Set category as the base deno-
tational semantics category, without considering the question if such a topos is also
necessary requirement for the database-mapping theory.
In our case, we are working with Relational Databases (RDB), and consequently,
with Structured Query Language (SQL), which is an extension of Codd’s “Select-
Project-Join + Union” (SPJRU) relational algebra [29, 356]. We assume a view of a
database A as an observation on this database, presented as a relation (a set of tuples)
obtained by a query q(x) (SPJRU term with a list of free variables in x), where x is a list
of attributes of this view. Let ℒA be the set of all such queries over A and ℒA/≈be the
quotient term algebra obtained by introducing the equivalence relation ≈, such that
q(x) ≈q′(x) if both queries return with the same relation (view). Thus, a view can be
equivalently considered as a term of this quotient-term algebra ℒA/≈with carrier set
of relations in A and a finite arity of their SPRJU operators whose computation returns
a set of tuples of this view. If this query is a finite term of this algebra, then it is called
a “finitary view” (a finitary view can have an infinite number of tuples as well).
In this coalgebraic methodological approach to databases, we consider a database
instance A of a given database schema 𝒜(i. e., the set of relations that satisfy all in-
tegrity constraints of a given database schema) as a black box and any view (the re-
sponse to a given query) is considered as an observation. Thus, in this framework we
do not consider a categorical semantic for the free syntax algebra of a given query
language, but only the resulting observations and the query-answering system of this
database (an Abstract Object Type (AOT)), i. e., the coalgebra. Consequently, all alge-
braic aspects of the query language are encapsulated in the single power-view oper-
ator T, such that for a given database instance A (first object in our base database
category) the object TA is the set of all possible views of this database A that can be
obtained from a given query language ℒA/≈.
A functorial translation of database schema intermappings (a small graph cate-
gory) into the database category DB is fundamentally based on a functor that rep-
resents a given model of this database schema intermappings theory. This functor
maps a data schema of a given database into an single object of the DB category, i. e.,
a database instance A of this database schema 𝒜(a model of this database schema,
composed of a set of relations that satisfy the schema’s integrity constraints). The mor-
phisms in the DB category are not simple functions as in the Set category. Thus, the

A.6 Introduction to RDB, database mappings and DB category
|
477
category DB is not an elementary (standard) topos. In fact, it was shown in [357] that
if we want to progress to more expressive sketches w. r. t. the original Ehresmann’s
sketches for diagrams with limits and coproducts, by eliminating nondatabase objects
as, e. g., Cartesian products of attributes or powerset objects, we need more expressive
arrows for sketch categories (diagram predicates in [357] that are analog to the ap-
proach of Makkai in [358]). As we progress to a more abstract vision in which objects
are the whole databases, following the approach of Makkai, in [21] we obtained more
complex arrows in this new basic DB category for databases in which objects are just
the database instances (each object is a set of relations that compose this database
instance). Such arrows are not just simple functions as in the case of the Set category
but complex trees (i. e., operads) of view-based mappings: each arrow is equivalent to
the sets of functions. In this way, while Ehresmann’s approach prefers to deal with a
few fixed diagram properties (commutativity, (co)limitness), we enjoy the possibility
of setting a full relational-algebra signature of diagram properties.
Different properties of this DB category were presented in a number of previously
published papers, in initial versions, [175, 359–362] as well, and it has been demon-
strated that this category is a weak monoidal topos. The fundamental power view-
operator T has been defined in [363]. For the database applications, the powerview-
monad T : DB →DB is used to provide denotational semantics to database mappings
[21, 175]: in order to interpret a database mappings (morphisms) in the category DB,
we distinguish the object A ∈ObDB (a database instance of type 𝒜) from the object TA
of observations (computations of type 𝒜without side-effects) and take as a denotation
of (view) mappings the elements of TA (which are the views of type 𝒜). In particular,
we identify A with the object of values (of type 𝒜) and we obtain the object of observa-
tions by applying the unary type-constructor T (power-view operator) to A, and hence
in DB we have the isomorphism A ≃TA (for this monad η is a natural isomorphism,
i. e., for each object A, ηA : A ≃TA, and μ generates the identity morphisms, i. e.,
μA : T2A →TA is the identity morphism idTA with T2A = TA). In fact, each query (the
union of conjunctive queries), expressed by FOL formulae, has an equivalent finite-
length algebraic term of the SPJRU algebra, and hence the power view-operator T can
be defined by the initial SPRJU algebra of ground terms. We define this fundamental
idempotent power-view operator T, in Section A.6.2, with the domain and codomain
equal to the set of all instance-databases such that for any instance-database A, the
object TA = T(A) denotes a database composed of the set of all views of A. For every
object A, A ⊆TA and TA = T(TA), i. e., each (element) view of database instance TA is
also an element (view) of a database instance A.
The Kleisli category and the semantics of morphisms in the DB category, based on
the monad (endofunctor T) have been presented in [174]. The semantics for merging
and matching database operators based on complete database lattice, as in [364], were
defined as well and presented in a number of papers cited above. This section is useful
for better understanding of the applications of the Intensional FOL for the intensional

478
|
A Appendix
mapping between the P2P databases and for the extension of the standard RDB theory
to the more powerful Intensional Relational Databases (IRDB) defined in this book.
A.6.1 Basic database concepts
The database mappings, for a logic language (we assume the FOL language in Defini-
tion 1) with a set of predicate letters P, are usually defined at a schema level by:
1.
A database schema is a pair 𝒜= (SA, ΣA) where SA is a countable set of rela-
tional symbols (predicates in FOL) r ∈P with finite arity n = ar(r) ≥1 (ar :
P →𝒩), disjoint from a countable infinite set att of attributes (a domain of a ∈
att is a nonempty finite subset dom(a) of a countable set of individual symbols
dom, with 𝒟= dom ⋃SK). For any r ∈P, the sort of r, denoted by tuple a =
atr(r) = ⟨atrr(1), . . . , atrr(n)⟩where all ai = atrr(m) ∈att, 1 ≤m ≤n, must be dis-
tinct: if we use two equal domains for different attributes, then we denote them
by ai(1), . . . , ai(k) (ai equals to ai(0)). Each index (“column”) i, 1 ≤i ≤ar(r), has
a distinct column name nrr(i) ∈SN where SN is the set of names with nr(r) =
⟨nrr(1), . . . , nrr(n)⟩. A relation r ∈P can be used as an atom r(x) of FOL with vari-
ables in x assigned to its columns, so that ΣA denotes a set of sentences (FOL for-
mulae without free variables) called integrity constraints of the sorted FOL with
sorts in att. We denote the empty schema by 𝒜0 = ({r0}, 0), where r0 is the relation
with empty set of attributes (truth propositional letter in FOL, Definition 1), and
we denote the set of all database schemas for a given (also infinite) set P by 𝕊.
2.
An instance-database of a nonempty schema 𝒜is given by A = (𝒜, IT) = {R =
‖r‖ = IT(r) | r ∈SA} where IT is a Tarski’s FOL interpretation in Definition 1,
which satisfies all integrity constraints in ΣA and maps a relational symbol r ∈
SA into an n-ary relation R = ‖r‖ ∈A. Thus, an instance-database A is a set of
n-ary relations, managed by relational database systems (DBMSs). Let A and A′ =
(𝒜, I′
T) be two instances of 𝒜, then a function h : A →A′ is a homomorphism from
A into A′ if for every k-ary relational symbol r ∈SA and every tuple ⟨v1, . . . , vk⟩
of this k-ary relation in A, ⟨h(v1), . . . , h(vk)⟩is a tuple of the same symbol r in A′.
If A is an instance-database and ϕ is a sentence, then we write A 󳀀󳨐ϕ to mean
that A satisfies ϕ. If Σ is a set of sentences, then we write A 󳀀󳨐Σ to mean that
A 󳀀󳨐ϕ for every sentence ϕ ∈Σ. Thus, the set of all instances of 𝒜is defined by
Inst(𝒜) = {A | A 󳀀󳨐ΣA}. We denote the set of all values in A by val(A) ⊆𝒟. Then
the “atomic database” JA = {{⟨vi⟩} | vi ∈val(A)} is infinite iff SK ⊆val(A). Note
that for each a ∈atr(r), a subset dom(a) ⊆dom is finite, and any introduction of
Skolem constants is ordered ω0, ω1, . . . .
3.
We consider a rule-based conjunctive query over a database schema 𝒜as an ex-
pression q(x) ←󳨀r1(u1), . . . , rn(un), with finite n ≥0, ri are the relational sym-
bols (at least one) in 𝒜or the built-in predicates (e. g., ≤, =, etc.) q is a relational

A.6 Introduction to RDB, database mappings and DB category
|
479
symbol not in 𝒜and ui are free tuples (i. e., one may use either variables or con-
stants). Recall that if v = (v1, . . . , vm), then r(v) is a shorthand for r(v1, . . . , vm).
Finally, each variable occurring in x is a distinguished variable that must also oc-
cur at least once in u1, . . . , un. Rule-based conjunctive queries (called rules) are
composed of a subexpression r1(u1), . . . , rn(un) that is the body, and the head of
this rule q(x). The Yes/No conjunctive queries are the rules with an empty head.
If we can find values for the variables of the rule, such that the body is logically
satisfied, then we can deduce the head-fact. This concept is captured by a no-
tion of “valuation.” The deduced head-facts of a conjunctive query q(x) defined
over an instance A (for a given Tarski’s interpretation IT of schema 𝒜) are equal
to ‖q(x1, . . . , xk)‖A = {⟨v1, . . . , vk⟩∈𝒟k | A 󳀀󳨐∃y(r1(u1) ∧⋅⋅⋅∧rn(un))[xi/vi]1≤i≤k} =
I∗
T (∃y(r1(u1) ∧⋅⋅⋅∧rn(un))), where the y is a set of variables, which are not in the
head of a query. We recall that the conjunctive queries are monotonic and satis-
fiable, and that a (Boolean) query is a class of instances that is closed under the
isomorphism [164]. Each conjunctive query corresponds to a “select-project-join”
term t(x) of SPRJU algebra obtained from the formula ∃y(r1(u1) ∧⋅⋅⋅∧rn(un)).
4.
We consider a finitary view as a union of a finite set S of conjunctive queries with
the same head q(x) over a schema 𝒜, and from the equivalent algebraic point of
view, it is a “select-project-join + union” (SPJRU) finite-length term t(x), which
corresponds to the union of the terms of conjunctive queries in S. In what follows,
we will use the same notation for a FOL formula q(x) and its equivalent algebraic
SPJRU expression t(x). A materialized view of an instance-database A is an n-ary
relation R = ⋃q(x)∈S ‖q(x)‖A. Notice that a finitary view can also have an infinite
number of tuples. We denote the set of all finitary materialized views that can be
obtained from an instance A by TA.
We consider the views as a universal property for databases: they are the possible
observations of the information containedin an instancedatabase.Wecan usethem in
order to establish an equivalence relation between databases. Database category DB,
defined in [21], is at the instance level, i. e., any object in DB is an instance database.
Interesting extensions of FOL by a number of second-order features are monadic
second-order quantifiers (MSO). Such quantifiers can range over particular subsets of
the universe (in monadic extensions we can use the quantification ∃X where X is a
subset of the universe, differently from FOL where X is an element of the universe).
We can consider two particular restrictions:
1.
An ∃MSO formula starts with a sequence of existential second-order quantifiers,
which is followed by an FOL formula.
2.
An ∀MSO formula starts with a sequence of universal second-order quantifiers,
which is followed by an FOL formula. For example, ∃MSO and ∀MSO are different
for graphs. For strings, MSO collapses to ∃MSO and captures exactly the regular
languages [365]. If we restrict attention to FOL over strings, then it captures exactly
the star-free languages.

480
|
A Appendix
MSO can be used over trees (for XML documents as trees, such queries choose cer-
tain nodes from trees) and tree automata, e. g., for monadic DATALOG, which can be
evaluated in time linear both in the size of the program and the size of the string [366].
A.6.2 Database observations: idempotent power-view operator
We consider the views as a universal property for the databases: they are the possible
observations of the information contained in an instance-database and we can use
them in order to establish an equivalence relation between databases.
In the theory of algebraic specifications, an Abstract Data Type (ADT) is specified
by a set of operations (constructors) that determine how the values of the carrier set are
built up and by a set of formulae (in the simplest case, the equations) stating which
values should be identified. In the standard initial algebra semantics, the defining
equations impose a congruence on the initial algebra. Dually, a coagebraic specifica-
tion of a class of systems, i. e., Abstract Object Types (AOT), is characterized by a set of
operations (destructors) that specify what can be observed out of a system-state (i. e.,
an element of the carrier) and how a state can be transformed to a successor state.
We will introduce a class of coalgebras for database query-answering systems for
a given instance-database A of a schema 𝒜by Definition 133. They will be presented in
an algebraic style by providing a cosignature. In particular, the sorts include a single
“hidden sort,” corresponding to the carrier of a coalgebra, and other “visible” sorts
for the inputs and outputs with a given fixed interpretation. Visible sorts will be inter-
preted as the sets without any algebraic structure defined on them. For us, the coal-
gebraic terms, built by operations (destructors), are interpreted by the basic observa-
tions, which one can make on the states of a coalgebra.
Input sorts for a given instance-database A is a countable set ℒA of the union of a
finite set S of conjunctive finite-length queries q(x) (with the same head with a finite tu-
ple of variables x) so that R = evA(q(x)) = ⋃q(x)∈S ‖q(x)‖A is the relation (a materialized
view) obtained by applying this query to A.
Each query (FOL formula introduced in Definition 1) has an equivalent finite-
length algebraic term of the SPJRU algebra (or equivalent to it, SPCU algebra, Chapter
4.5, 5.4 in [356]) as shortly introduced in the previous section, and hence the power
view-operator T can be defined by the initial SPRJU algebra of ground terms. We define
this fundamental idempotent power-view operator T, with the domain and codomain
equal to the set of all instance databases such that for any instance-database A, the
object TA = T(A) denotes a database composed of the set of all views of A. The object
TA, for a given instance-database A, corresponds to the carrier of the quotient-term
Lindenbaum algebra ℒA/≈, i. e., the set of the equivalence classes of queries (such a
query is equivalent to a term in 𝒯PX of an SRRJU relational algebra ΣR, with the select,
project, join and union operators, with relational symbols of a database schema 𝒜).
More precisely, TA is “generated” from A by this quotient-term algebra ℒA/≈and a

A.6 Introduction to RDB, database mappings and DB category
|
481
given evaluation of queries in ℒA, evA : ℒA
?? TA, which is surjective function.
From the factorization theorem, there is a unique bijection isA : ℒA/≈→TA such that
ℒA
evA?? TA
ℒA/≈
nat≈
?
isA
?
commutes, where the surjective function nat≈: ℒA →ℒA/≈is a natural representation
for the equivalence of the queries ≈. For every object A, A ⊆TA and TA = T(TA), i. e.,
each (element) view of database instance TA is also an element (view) of a database
instance A. It is easy to verify that T corresponds to the closure operator Sg on A (intro-
duced in Section A.1) for the ΣR relational (SPJRU) algebra, but with relations instead
of variables (i. e., relational symbols). Notice that when A has a finite number of re-
lations, but at least one relation with an infinite number of tuples, then TA has an
infinite number of relations (i. e., views of A), and hence can be an infinite object.
Based on the theory of database observations and its power-view operator T, de-
fined in Section A.6.2, the output sort of this database AOT is the set TA of all resulting
views (i. e., resulting n-ary relations) obtained by computation of queries q(x) ∈ℒA. It
is considered as the carrier of a coalgebra as well.
Definition 133. AOT for a Database query-answering system, for a given instance-
database A, is a pair (S, ΣAOT) such that:
1.
The carrier set S = (XA, ℒA, ϒ) of the sorts where XA is a hidden sort (a set of states
of this database system), ℒA is an input sort (a set of the unions of conjunctive
queries over A), and ϒ is the set of all finitary relations for a given universe 𝒟.
2.
The following mappings:
2.1 A method Next : XA×ℒA →XA that corresponds to an execution of a next query
q(x) ∈ℒA in a current state s ∈XA of a database A, such that a database A
passes to the next state; so, we introduce the destructor Λ(Next) : XA →XℒA
A ,
where Λ is the currying operator from lambda calculus used in diagram A.10
in Section A.5.
2.2 An attribute Out : XA × ℒA →ϒ such that for each s ∈XA, q(x) ∈ℒA,
Out(s, q(x)) is a relation computed by a query q(x); analogously, we introduce
the second destructor Λ(Out) : XA →ϒℒA.
Then the abstract object type for a query-answering system is given by a coalgebra
with the signature ΣAOT = {Λ(Next), Λ(Out)}:
⟨Λ(Next), Λ(Out)⟩: XA →FXA
of the polynomial endofunctor F =def ( _ )ℒA × ϒℒA : Set →Set.

482
|
A Appendix
In an object-oriented terminology, the coalgebras are expressive enough in or-
der to specify the parametric methods and the attributes for a database (conjunctive)
query answering systems. In a transition system terminology, such coalgebras can
model a deterministic, nonterminating, transition system with inputs and outputs.
In [367], a complete equational calculus for such coalgebras of restricted class of poly-
nomial functors has been defined.
Here, we will consider only the database query-answering systems without the
side effects. That is, the obtained results (views) will not be materialized as a new
relation of this database A but only visualized. Thus, when a database answers to a
query, it remains in the same initial state. Thus, the set XA is a singleton {A} for a given
database A, and consequently, it is isomorphic to the terminal object 1 in the Set cate-
gory. As a consequence, from 1ℒA ≃1, we obtain that a method Next is just an identity
function id : 1 →1. Thus, the only interesting part of this AOT is the attribute part
Out : XA × ℒA →ϒ, with the fact that XA × ℒA = {A} × ℒA ≃ℒA.
Consequently, we obtain an attribute mapping Out : ℒA →ϒ, whose graph is
equal to the query-evaluation surjective mapping evA : ℒA
?? TA, introduced in the
previous diagram.
Corollary 34. A canonical method for the construction of the power-view database TA
can be obtained by an abstract data-object type (S, ΣAOT) for a query-answering system
without side effects as follows:
TA =def {Out(qi(x)) | qi(x) ∈ℒA}.
This corollary is a direct proof that the power-view database operator T, in-
troduced previously, represents the observational point of view for the instance-
databases. This mapping evA : ℒA
?? TA can be used as a semantic foundation
for the database mappings.
A.6.3 Schema mappings, sketches and functors into the DB category
The problem of sharing data from multiple sources has recently received significant at-
tention, and a succession of different architectures has been proposed, beginning with
federated databases [368, 369], followed by data integration systems [111, 142, 370],
data exchange systems [143, 351, 371] and Peer-to-Peer (P2P) data management sys-
tems [53, 122, 123, 125, 350, 372]. A lot of research has been focused on the development
of logic languages for semantic mapping between data sources and mediated schemas
[111, 112, 364, 373–375], and algorithms that use mappings to answer queries in data
sharing systems [105, 115, 117, 141, 219, 370, 376–378].
We consider that a mapping between two database schemas 𝒜= (SA, ΣA) and ℬ=
(SB, ΣB) is expressed by an union of “conjunctive queries with the same head.” Such

A.6 Introduction to RDB, database mappings and DB category
|
483
mappings are called “view-based mappings,” defined by a set of FOL sentences
{∀xi(qAi(xi) ⇒qBi(yi))| with yi ⊆xi, 1 ≤i ≤n}, where ⇒is the logical implication
between these conjunctive queries qAi(xi) and qBi(xi), over the databases 𝒜and ℬ,
respectively.
Schema mappings are often specified by the source-to-target tuple-generating de-
pendencies (tgds), used to formalize a data exchange [143], and in the data integra-
tion scenarios under a name “GLAV assertions” [111, 142]. A tgd is a logical sentence
(FOL formula without free variables), which says that if some tuples satisfying certain
equalities exist in the relation, then some other tuples (possibly with some unknown
values) must also exist in another specified relation.
An equality-generating dependency (egd) is a logical sentence, which says that
if some tuples satisfying certain equalities exist in the relation, then some values in
these tuples must be equal. Functional dependencies are egds of a special form, e. g.,
primary-key integrity constraints. Thus, egds are only used for the specification of in-
tegrity constraints of a single database schema, which define the set of possible mod-
els of this database. They are not used for interschema database mappings.
These two classes of dependencies together comprise the embedded implica-
tion dependencies (EID) [379], which seem to include essentially all of the naturally-
occurring constraints on relational databases (we recall that the bold symbols x, y, . . .
denote a nonempty list of variables).
Definition 134. We introduce the following two kinds of EIDs [379]:
1.
A tuple-generating dependency (tgd)
∀x(qA(x) ⇒qB(x)),
where qA(x) is an existentially quantified formula ∃yϕA(x, y) and qB(x) is an ex-
istentially quantified formula ∃zψA(x, z), and where the formulae ϕA(x, y) and
ψA(x, z) are conjunctions of atomic formulae (conjunctive queries) over the given
database schemas. We assume the safety condition, i. e., that every distinguished
variable in x appears in qA.
We will consider also the class of weakly-full tgds for which query answering is
decidable, i. e., when qB(x) has no existentially quantified variables, and if each
yi ∈y appears at most once in ϕA(x, y).
2.
An equality-generating dependency (egd)
∀x(qA(x) ⇒(y ≐z)),
where qA(x) is a conjunction of atomic formulae over a given database schema,
and y = ⟨y1, . . . , yk⟩, z = ⟨z1, . . . , zk⟩are among the variables in x, and y ≐z is a
shorthand for the formula (y1 ≐z1)∧⋅⋅⋅∧(yk ≐zk) with the built-in binary identity
predicate ≐of the FOL.

484
|
A Appendix
Note that a tgd ∀x(∃yϕA(x, y) ⇒∃zψA(x, z)) is logically equivalent to the formula
∀x∀y(ϕA(x, y) ⇒∃zψA(x, z)), i. e., to ∀x1(ϕA(x1) ⇒∃zψA(x, z)) with the set of dis-
tinguished variables x ⊆x1. We will use for the integrity constraints ΣA of a database
schema 𝒜both tgds and egds, while for the interschema mappings, between a schema
𝒜= (SA, ΣA) and a schema ℬ= (SB, ΣB), only the tgds ∀x(qA(x) ⇒qB(x)), as follows.
Definition 135. An elementary schema mapping is a triple (𝒜, ℬ, ℳ) where 𝒜and ℬ
are schemas with no relational symbol in common and ℳis a set of tgds ∀x(qA(x) ⇒
qB(x)), such that qA(x) is a conjunctive query with conjuncts equal to relational sym-
bols in SA or to a formula with built-in relational symbols, ≐, <, >, etc.), while qB(x) is
a conjunctive query with relational symbols in SB.
An instance of ℳis an instance pair (A, B) (where A is an instance of 𝒜and B is
an instance of ℬ) that satisfies every tgds in ℳ, denoted by (A, B) 󳀀󳨐ℳAB. We write
Inst(ℳ) to denote all instances (A, B) of ℳ.
Notice that the formula with built-in predicates, in the left side of implication of
a tgd, can be expressed by only two logical connectives, conjunction and negation,
from the fact that implication and disjunction can be reduced to equivalent formulae
with these two logical connectives. Recall that in data exchange terminology, B is a
solution for A under ℳif (A, B) ∈Inst(ℳ), and that an instance of ℳsatisfies all
FOL formulae in ΣA ⋃ΣB ⋃ℳ. For a given set of FOL formulas S, we denote by ⋀S the
conjunction of all formulae in the set S.
Lemma 19. For any given Tarski’s interpretation IT that is a model of the schemas 𝒜=
(SA, ΣA) and ℬ= (SB, ΣB) and of the set of tgds in the mapping ℳ, i. e., when I∗
T (⋀ΣA) =
I∗
T (⋀ΣB) = I∗
T (⋀ℳ) = t, one has ({IT(r) | r ∈SA}, {IT(r) | r ∈SB}) ∈Inst(ℳ).
Proof. Due to the fact that I∗
T (⋀ΣA) = t means that all integrity constraints of 𝒜are
satisfied, one has that A = {IT(r) | r ∈SA} is an instance (model) of 𝒜. The same holds
for the schema ℬ, so that B = {IT(r) | r ∈SB} is an instance of ℬ.
From the fact that I∗
T (⋀ℳ) = t, each tgd ϕ ∈ℳAB is satisfied, i. e., I∗
T (ϕ) = t, and
hence (A, B) 󳀀󳨐ℳ, i. e., (A, B) ∈Inst(ℳ).
The formulae (tgds) in the set ℳexpress the constraints that an instance (A, B)
over the schemas 𝒜and ℬmust satisfy. We assume that the satisfaction relation be-
tween formulae and instances is preserved under isomorphism, which means that if
an instance satisfies a formula then every isomorphic instance also satisfies that for-
mula.
This is a mild condition that is true for all standard logical formalisms, such as
first-order logic, second-order logic, fixed-point logics and infinitary logics.
Thus, such formulae represent the queries in the sense of Chandra and Harel [164].
An immediate consequence of this property is that Inst(ℳ) is closed under isomor-
phism.

A.6 Introduction to RDB, database mappings and DB category
|
485
Remark. Different from [179, 374, 380], eachformula in ℳcontainsthe relationalsym-
bols of both source and target schema (the integrity constraints are contained in their
schemas), in order to represent an interschema mapping graphically as a graph edge
ℳAB : 𝒜→ℬas in standard mathematical denotation of a mapping.
The problem of computing semantic mappings [179, 353, 380–383], given a se-
mantic mapping ℳAB between data schemas 𝒜and ℬ, and ℳBC between ℬand 𝒞,
generally was to answer if it is possible to generate a direct semantic mapping ℳAC
(possibly in the same logic language formalism) between 𝒜and 𝒞that is “equivalent”
to the original mappings. Here, “equivalent” means that for any query in a given class
of queries Q and for any instance of data sources, using the direct mapping yields ex-
actly the same answer that would be obtained by the two original mappings [380].
The semantics of the composition of the schema mappings proposed by Mad-
havan and Halevy [380] was a significant first step. However, it suffers from cer-
tain drawbacks that are caused by the fact that this semantics is given relative to a
class of queries. In this setting, the set of formulae specifying a composition ℳAC
of ℳAB and ℳBC relative to a class Q of queries need not be unique up to logical
equivalence, even when the class Q of queries is held fixed. It was shown [179] that
this semantics is rather fragile, because a schema mapping ℳAC may be a composi-
tion of ℳAB and ℳBC when Q is the class of conjunctive queries, but may fail to be
composition of these two (inter)schema mappings when Q is the class of conjunctive
queries with inequalities.
We use the algorithm MakeOperads in [21] in order to transform logical schema
mappings ℳAB = {Φ} : 𝒜→ℬgiven by the SOtgds Φ in Definition 49 into the alge-
braic operads MAB = MakeOperad(ℳAB) = {v1 ⋅qA,1, . . . , vn ⋅qA,1, 1r0} : 𝒜→ℬ. The
basic idea of the operad’s operations vi ∈O(r′, rB) and qA,i ∈O(r1, . . . , rk, r′), where
ri, 1 ≤i ≤k are relational symbols of the source schema 𝒜= (SA, ΣA) and rB is a rela-
tional symbol of the target schema ℬ, and r′ has the same type as rB, is to formalize
algebraically a mapping from the set of source relations ri into a target relation rB.
Example 60. Schema 𝒜= (SA, 0) consists of a unary relation EmpAcme that represents
the employees of Acme, a unary relation EmpAjax that represents the employees of
Ajax, and unary relation Local that represents employees that work in the local office
of their company. Schema ℬ= (SB, 0) consists of a unary relation Emp that represents all
employees, a unary relation Local1 that is intended to be a copy of Local, and unary
relation Over65 that is intended to represent people over age 65. Schema 𝒞= (SC, 0)
consists of a binary relation Office that associates employees with office numbers and
unary relation CanRetire that represents employees eligible for retirement. Consider
now the following schema mappings:
ℳAB = {∀xe(EmpAcme(xe) ⇒Emp(xe)) ∧∀xe(EmpAjax(xe)
⇒Emp(xe)) ∧∀xp(Local(xp) ⇒Local1(xp))},
and

486
|
A Appendix
ℳBC = {∃f1(∀xe((Emp(xe) ∧Local1(xe))
⇒Office(xe, f1(xe))) ∧∀xe((Emp(xe) ∧Over65(xe)) ⇒CanRetire(xe)))}.
Then, by their composition, we obtain the composed mapping ℳAC : 𝒜→𝒞equal to
ℳAC = {∃f1∃f2∃fOver65(∀xe((EmpAcme(xe) ∧Local(xe)) ⇒Office(xe, f1(xe)))
∧∀xe((EmpAjax(xe) ∧Local(xe)) ⇒Office(xe, f2(xe)))
∧∀xe((EmpAcme(xe) ∧(fOver65(xe) ≐1)) ⇒CanRetire(xe))
∧∀xe((EmpAjax(xe) ∧(fOver65(xe) ≐1)) ⇒CanRetire(xe)))},
where fOver65 is the characteristic function of the relation (predicate) Over65 which is
not part of schema 𝒜. Then, by transformation into abstract operad’s operations, we
obtain MAC = MakeOperads(ℳAC) = {qA
1 , qA
2 , qA
3 , qA
4, 1r0}, qA
i = vi ⋅qA,i, where:
1.
The operations qA
1 ∈O(EmpAcme, Local, Office) and qA,1 ∈O(EmpAcme, Local, r′
1)
correspond to the expression (( _ )1(xe) ∧( _ )2(xe)) ⇒( _ )(xe, f1(xe)) and v1 ∈
O(r′
1, Office) to ( _ )1(xe, xp) ⇒( _ )(xe, xp);
2.
The operations qA
2 ∈O(EmpAjax, Local, Office) and qA,2 ∈O(EmpAjax, Local, r′
2)
correspond to the expression (( _ )1(xe) ∧( _ )2(xe)) ⇒( _ )(xe, f2(xe)) and v2 ∈
O(r′
2, Office) to ( _ )1(xe, xp) ⇒( _ )(xe, xp);
3.
The operations qA
3 ∈O(EmpAcme, Over65, CanRetire) and qA,3 ∈O(EmpAcme, Over65,
r′
3) correspond to the expression (( _ )1(xe) ∧( _ )2(xe)) ⇒( _ )(xe) and v3 ∈O(r′
3,
CanRetire) to ( _ )1(xe) ⇒( _ )(xe);
4.
The operations qA
4 ∈O(EmpAjax, Over65, CanRetire) and qA,4 ∈O(EmpAjax, Over65,
r′
4) correspond to the expression (( _ )1(xe) ∧( _ )2(xe)) ⇒( _ )(xe) and v4 ∈O(r′
4,
CanRetire) to ( _ )1(xe) ⇒( _ )(xe).
These three arrows MAB : 𝒜→ℬ, MBC : ℬ→𝒞and MAC : 𝒜→𝒞compose a graph
G of this database mapping system. From the fact that the operads can be composed,
the composition of two schema mappings MAB and MBC can be translated into compo-
sition of operads, which is associative, so that they can be represented by the sketch
category Sch(G) derived from the graph G of the schema mappings.
Sketches are called graph-based logic and provide very clear and intuitive spec-
ification of computational data and activities. For any small sketch E, the category
of models Mod(E) is an accessible category by Lair’s theorem and reflexive subcat-
egory of SetE by the Ehresmann–Kennison theorem. A generalization to base cate-
gories other than Set was proved by Freyd and Kelly (1972) [384]. The generalization
to DB category is exhaustively provided in [21], so that the functorial semantics of a
database mapping system expressed by a graph G is defined by a functor (R-algebra)
α∗: Sch(G) →DB.
The R-algebra α is derived from a given Tarski’s interpretation IT of the given
database schema mapping graph G and represented by a sketch category Sch(G)

A.6 Introduction to RDB, database mappings and DB category
|
487
(with arrows MAB : 𝒜→ℬ, as in Example 60). R-algebra α is equal to IT for the
relations of the data schemas, α(ri) = IT(ri) is a relational table of the instance
database A = α∗(𝒜) = {α(ri) | ri ∈SA} (α∗denotes the extension of α to sets),
and α(qA,i) : α(r1) × ⋅⋅⋅× α(rk) →α(r′) is a surjective function from the relations in the
instance database A into its image (relation) α(r′), with a function α(vi) : α(r′) →α(rB)
into the relation of the instance database B = α∗(ℬ). Formal definition of an R-algebra
α as a mapping-interpretation of a schema mapping ℳAB : 𝒜→ℬis given in [21]
(Section 2.4.1, Definition 11) also when we have the negation in the left sides of the
implications in a SOtgd of such a mapping.
We have that for any R-algebra α, α(r0) = ⊥= {⟨⟩} is the empty relation composed
by only empty tuple ⟨⟩∈D−1, and 1r0 is the identity operads operation of the empty
relation r0, so that q⊥= α(1r0) = id⊥: ⊥→⊥is the identity function.
Example 61. For the operads defined in Example 60, let a mapping-interpretation
(an R-algebra) α be an extension of Tarski’s interpretation IT of the source schema
𝒜= (SA, ΣA) that satisfies all constraints in ΣA and defines its database instance
A = α∗(SA) = {α(ri) | ri ∈SA} and, analogously, an interpretation of 𝒞.
Let α satisfy the SOtgd of the mapping ℳAC by the Tarski’s interpretation for the
functional symbols fi, for 1 ≤i ≤2, in this SOtgd (denoted by IT(fi)).
Then we obtain the relations α(EmpAcme), α(EmpAjax), α(Local), α(Office) and
α(CanRetire). The interpretation of fOver65 is the characteristic function of the relation
α(Over65 in the instance B = α∗(SB) of the database ℬ= (SB, ΣB), so that f Over65(a) = 1
if ⟨a⟩∈α(Over65)).
Then this mapping interpretation α defines the following functions:
1.
The function α(qA,1) : α(EmpAcme) × α(Local) →α(r′
1), such that for any tuple ⟨a⟩∈
α(EmpAcme) and ⟨b⟩∈α(Local),
α(qA,1)(⟨a⟩, ⟨b⟩) = ⟨a, IT(f1(a))⟩
if a = b;
⟨⟩otherwise.
And for any ⟨a, b⟩∈α(r′
1), α(v1)(⟨a, b⟩) = ⟨a, b⟩if ⟨a, b⟩∈α(Office); ⟨⟩otherwise.
2.
The function α(qA,2) : α(EmpAjax) × α(Local) →α(r′
2), such that for any tuple
⟨a⟩∈α(EmpAjax) and ⟨b⟩∈α(Local),
α(qA,2)(⟨a⟩, ⟨b⟩) = ⟨a, IT(f2(a))⟩
if a = b;
⟨⟩otherwise.
And for any ⟨a, b⟩∈α(r′
2), α(v2)(⟨a, b⟩) = ⟨a, b⟩if ⟨a, b⟩∈α(Office); ⟨⟩otherwise.
3.
The function α(qA,3) : α(EmpAcme) × α(Over65) →α(r′
3), such that for any tuple
⟨a⟩∈α(EmpAcme) and ⟨b⟩∈α(Over65),
α(qA,3)(⟨a⟩, ⟨b⟩) = ⟨a⟩,
if a = b;
⟨⟩otherwise.
And for any ⟨a⟩∈α(r′
3), α(v3)(⟨a⟩) = ⟨a⟩if ⟨a⟩∈α(CanRetire); ⟨⟩otherwise.

488
|
A Appendix
4.
The function α(qA,4) : α(EmpAjax) × α(Over65) →α(r′
4), such that for any tuple
⟨a⟩∈α(EmpAjax) and ⟨b⟩∈α(Over65)
α(qA,4)(⟨a⟩, ⟨b⟩) = ⟨a⟩,
if a = b;
⟨⟩otherwise.
And for any ⟨a⟩∈α(r′
4), α(v4)(⟨a⟩) = ⟨a⟩if ⟨a⟩∈α(CanRetire); ⟨⟩otherwise.
From the fact that the mapping-interpretation satisfies the schema mappings, based
on Corollary 4 in Section 2.4.1 [21], all functions α(vi), for 1 ≤i ≤4, are the injections.
A.6.4 Data integration system
In this section, we illustrate the formalization of a data integration system (DIS) [142]
that is based on the relational model with integrity constraints.
In the relational model, predicate symbols are used to denote the relations in the
database, whereas constant symbols denote the values stored in the relations. We as-
sume to have a fixed (infinite) alphabet DΓ ⊂𝒟of constants. Unless specified other-
wise, we consider only the databases defined over such an alphabet. In such a setting,
the Unique Name Assumption (UNA) is implicit (i. e., different constants denote differ-
ent objects).
A relational schema (or simply a schema) consists of the following:
1.
An alphabet 𝒜of predicate (or relation) symbols, each one with an associated
arity. Arity represents the number of arguments of a given predicate or the number
of attributes of a given relation.
2.
A set Σ𝒢of integrity constraints. That is, assertions on the symbols of the alpha-
bet 𝒜. The assertions express the conditions that are intended to be satisfied in
every database that is coherent with the schema. In the proposed framework, we
consider two kinds of constraints:
2.1 Key constraints (we assume that, in the global schema, there is exactly one
key constraint for each relation).
2.2 Foreign key constraints: a foreign key constraint is a statement of the form
r1[A] ⊆r2[B], where r1 and r2 are relations and A is a sequence of distinct
attributes of r1 and B is key(r2). Such a constraint is satisfied in a database 𝒟ℬ
if for each tuple t1 in r𝒟ℬ
1
there exists a tuple t2 in r𝒟ℬ
2
such that t1[A] = t2[B]
where t1[A] is the projection of the tuple t1 over A.
A relational database (or simply a database) 𝒟ℬfor a schema 𝒞is a set of relations
in which the constants are atomic values and in addition, there is one relation r𝒟ℬof
arity n for each predicate symbol r of arity n in the alphabet 𝒜. The relation r𝒟ℬis the
interpretation in 𝒟ℬof the predicate symbol r, in the sense that it contains the set of
tuples that satisfies the predicate r in 𝒟ℬ.

A.6 Introduction to RDB, database mappings and DB category
|
489
A relational query is a formula that specifies a set of tuples that needs to be re-
trieved from a database. We consider the class of safe conjunctive queries in which
the answer to a query q of arity n over a database 𝒟ℬfor 𝒢, denoted q𝒟ℬ, is the set
of n-tuples of constants (c1, . . . , cn) such that when each xi is replaced with ci then the
formula ∃(y1, . . . , yn).conj(x1, . . . , xn, y1, . . . , ym) evaluates to true in 𝒟ℬ. When n = 1 and
all variables yi, 1 ≤i ≤m are replaced by the constants in DΓ, then the queries become
Yes/No type.
A data integration system ℐis a triple ℐ= ⟨𝒢, 𝒮, ℳ⟩, where:
–
The global schema is expressed in the relational model with constraints Σ𝒢.
–
The source schema is expressed without integrity constraints.
–
The mapping ℳis defined following the GAV approach. That is, to each relation
r of the global schema 𝒢we associate a query ρ(r) over the source schema 𝒮. Log-
ically, such mapping is standard material implication ρ(r)(X) ⇒r(Y) where X ⊆Y
are the sets of attributes of these (virtual) predicates (in the case when X ⊂Y we
have incomplete information).
We call any database for 𝒢as global database for ℐor simply database for ℐ.
Let D be a finite source database instance for ℐ= ⟨𝒢, 𝒮, ℳ⟩that is constituted by
one relation r𝒟for each source r in 𝒮. A database ℬfor ℐis said to be legal with respect
to D if:
–
ℬsatisfies the integrity constraints Σ𝒢of 𝒢.
–
ℬsatisfies ℳwith respect to 𝒟. That is, for each relation r in 𝒢, the set of tuples
rℬthat ℬassigns to r is a superset of the set of tuples ρ(r)𝒟computed by the as-
sociated query ρ(r) over D, i. e., ρ(r)𝒟⊆rℬ.
–
we denote by sem𝒟(ℐ) the set of databases for ℐthat are legal w. r. t. 𝒟, i. e., that
satisfies both the constraints of 𝒢as well as the mapping ℳwith respect to D. If
sem𝒟(ℐ)
̸= 0, then ℐis said to be consistent w. r. t. D.
Note that the above definition amounts to consider any view ρ(r) as sound [111, 154]. It
means that the data provided by the sources is only an (incomplete) subset (can be a
proper subset) of the data that would satisfy the relations of the global schema.
By the definition above, it is clear that the semantics of a data integration system
is formulated in terms of a set of databases, rather than a single one.
Retrieved global database
ret(ℐ, D) for a given finite source database instance D is defined as follows. For each re-
lation r of the global schema, we compute the relation r𝒟by evaluating the query ρ(r)
over the source database D. We assume that for each relation r of the global schema,
the query ρ(r) over the source schema 𝒮that the mapping ℳassociates to r preserves
the key constraint of r (this may require that ρ(r) implements a suitable duplicate

490
|
A Appendix
record elimination strategy). This assumption is to make sure that the retrieved global
database satisfies all the key constraints in 𝒢.
Query-answering
in the data integration system: Let q be a conjunctive query to a data integration sys-
tem ℐ(atoms in q have symbols in 𝒢as predicates). The set of certain answers qℐ,𝒟to
q w. r. t. ℐand D is the set of tuples t of constants of the same arity as q, and t ∈qℬ,
for each ℬ∈sem𝒟(ℐ).
Let Δℐbe a set of formulas belongs to a language ℒused to define the data integra-
tion system ℐ= ⟨𝒢, 𝒮, ℳ⟩and a formula A belongs to ℒ. We denote a model-theoretic
consequence relation (logical entailment) with ⊨, defined as follows: Δℐ⊨A when all
models of the formulas contained in Δℐare models of A; ⊨ℬA when a formula A is
true in a particular model ℬ. Then the certain answer to q(x) is given in the following
way:
qℐ,𝒟= {t | t ∈Darity(q)
Γ
and ⊨ℬq(t) for each ℬ∈sem𝒟(ℐ)}.
As a result, in this framework with key and foreign key constraints, we can visual-
ize a data integration system ℐ= ⟨𝒢, 𝒮, ℳ⟩as a logical theory 𝒫𝒢(a definite logic pro-
gram is provided by Cali et al. [142]) that is composed by: (1) a retrieved global database
ret(ℐ, D) as an extensional part of a database theory, and (2) the integrity constraints
for a global schema as its intensional part. The existential quantifiers in the foreign
key constraints are eliminated by introducing the appropriate Skolem functions:
HT(𝒢) = {fr,i | r ∈𝒢and i ≤arity(r) and i
̸∈key(r)}.
Each fr,i is a function symbol with the same arity as the number of attributes of key(r),
i. e., arity(fr,i) = arity(key(r)).
Intuitively, the role of the term fr,i(α1, . . . , αk) is to denote the value in the i-th col-
umn of the tuple of r having α1, . . . , αk in the key columns. The domain of such func-
tions is the alphabet DΓ.
The construction of the canonical model for a global schema of this logical theory
𝒫𝒢is presented by Cali et al. [142]. This model is an universal (canonical) one. That is,
it is an initial minimal Herbrand model [356] such that for every other legal database
model ℬof the global schema, there is a unique homomorphism [142] ψ : can(ℐ, D) 󳨀→
ℬand defines the following sound and complete query rewriting algorithms:
–
exp𝒢( _ ) that expands the original conjunctive query q(x) over a global schema
into exp𝒢(q(x)) query over ret(ℐ, D).
–
unfℳ( _ ) algorithm which unfolds the resulting query over ret(ℐ, D) and returns
with the query unfℳ(exp𝒢(q(x))) over a source data base D, such that for each
tuple t ∈Darity(q)
Γ
, t ∈q(x)ℐ,𝒟iff t ∈[unfℳ(exp𝒢(q(x)))]𝒟

A.6 Introduction to RDB, database mappings and DB category
|
491
so that the certain answer to a conjunctive query q(x) is equal to
q(x)ℐ,𝒟=def {t | t ∈Darity(q)
Γ
and ⊨M𝒟unfℳ(exp𝒢(q(t)))},
where M𝒟is the unique minimal Herbrand model of a source database D.
Finite canonical database for DIS with incomplete information
Here, we introduce a new approach to canonical model and this approach is more
close to the data exchange approach presented by Fagin et al. [143]. The approach is
not restricted to the existence of query-rewriting algorithms. As a result, it can be used
to define coherent closed world assumption [156] for data integration systems in the
absence of query-rewriting algorithms also. The construction of the canonical model
for a global schema of the logical theory 𝒫𝒢for data integration system is similar to
the construction of the canonical database can(ℐ, D) described by Cali et al. [142]. The
difference lies in the fact that in the construction of this revisited canonical model
denoted by canM(ℐ, D), for a global schema, fresh marked null values (set Ω of Skolem
constants [356]) are used instead of the terms involving Skolem functions. This follows
the idea of the construction of the restricted chase of a database described by David
et al. [385]. Thus, we enlarge a set of constants of our language by UΓ = DΓ ⋃Ω.
Topor and Sonenberg [356] informally proposed the term canonical model to de-
scribe a model that is selected (often from many incomparable minimal Herbrand
models) to represent the “meaning” of logical programs. Another motivation for con-
centrating on canonical models is the view [386] that many logic programs are ap-
propriately thought of as having two components: an intensional database (IDB) that
represents the reasoning component and the extensional database (EDB) that repre-
sents a collection of facts. Over the course of time, we can “apply” the same IDB to
many quite different EDBs. In this context, it makes sense to think of the IDB as if it is
implicitly defining a transformation from an EDB to a set of derived facts. We would
like the set of derived facts to be the canonical model.
Now, we inductively construct the revisited canonical database model canM(ℐ, D)
over the domain UΓ by starting from ret(ℐ, D) (here is an EDB) and repeatedly applying
the following rule based on IDB:
if (x1, . . . , xh) ∈rcanM(ℐ,D)
1
[A], (x1, . . . , xh)
̸∈rcanM(ℐ,D)
2
[B], and the foreign key constraint
r1[A] ⊆r2[B] is in 𝒢, then insert in rcanM(ℐ,𝒟)
2
the tuple t such that
–
t[B] = (x1, . . . , xh), and
–
for each i such that 1 ≤i ≤arity(r2), and i not in B, t[i] = ωk, where ωk is a fresh
marked null value.
Note that the above rule does enforce the satisfaction of the foreign key constraint
r1[A] ⊆r2[B] (which is a part of IDB), by adding a suitable tuple in r2: the key of the
new tuple is determined by the values in r1[A], and the values of the nonkey attributes

492
|
A Appendix
are formed by means of the fresh marked values ωk during the application of the rule
above.
The above rule defines the “immediate consequence” monotonic operator TB de-
fined by
TB(I) = I ⋃{A | A ∈B𝒢, A ←A1 ∧⋅⋅⋅∧An
is a ground instance of a rule in Σ𝒢and {A1, . . . , An} ∈I}
where, at beginning I = ret(ℐ, D), and B𝒢is a Herbrand base for a global schema.
Thus, canM(ℐ, D) is a least a fixed point of this immediate consequence operator.
Example 62. Suppose that we have two relations r and s in 𝒢, both of arity 2 and hav-
ing the first attribute as the key and that the following dependencies hold on 𝒢:
r[2] ⊆s[1],
s[1] ⊆r[1].
Suppose that the retrieved global database (EDB) stores a single tuple (a, b) in r. Then,
by applying the above rule, we insert the tuple (b, ω1) in s; successively we add (b, ω2)
in r, then (ω2, ω3) in s and so on. Observe that the two dependencies are cyclic. In
this case, the construction of the canonical database requires an infinite sequence of
applications of the rules. The following table represents the correspondence between
old and revisited canonical database:
rcan(ℐ,D)
scan(ℐ,D)
rcanM(ℐ,D)
scanM(ℐ,D)
a, b
b, fs2(b)
a, b
b, ω1
b, fr2(b)
fr2(b), fs2fr2(b)
b, ω2
ω2, ω3
fr2(b), f 2
r2(b)
f 2
r2(b), fs2f 2
r2(b)
ω2, ω4
ω4, ω5
f 2
r2(b), f 3
r2(b)
f 3
r2(b), fs2f 3
r2(b)
ω4, ω6
ω6, ω7
. . .
. . .
. . .
. . .
Thus, the canonical model canM(ℐ, D) is a legal database model for the global schema.
Let us also introduce an unary predicate Val(x), such that for any constant c ∈UΓ,
Val(c) is true if c ∈DΓ, false otherwise. Each certain answer of the original user query
q(x), x = {x1, , xk} over a global schema is equal to the answer qL(x)canM(ℐ,D) of the
lifted query qL(x) ≡q(x)∧Val(x1)∧⋅⋅⋅∧Val(xk) over this canonical model. Thus, in the
cases when it is possible to materialize this canonical model, certain answers could be
obtained over such a database. Usually, it is not possible because (as in the example
above) this canonical model is infinite. In that case, we can use the revisited fix-point
semantics described in [117]. This is based on the fact that after some point, the new
tuples added into a canonical model insert only new Skolem constants that are not
useful in order to obtain certain answers. In fact, Skolem constants are not part of any

A.6 Introduction to RDB, database mappings and DB category
|
493
certain answer to conjunctive query. Consequently, we are able to obtain a finite subset
of a canonical database, which is big enough to obtain certain answers.
Example 63. If we consider Example 62, the finitedatabaser = {(a, b), (b, ω2), (ω2, ω4)},
s = {(b, ω1), (ω2, ω3)} is such a finite least fixed point, which can be used in order to
obtain certain answers to the lifted queries.
In fact, we introduced marked null values (instead of Skolem functions) in order
to define and materialize such finite database. It is not a model of the data integration
system (which is infinite) but has all necessary query-answering properties. It is able
to give all certain answers to conjunctive queries over a global schema. Thus, it can be
materialized and used for query answering, instead of query-rewriting algorithms. Let
us denote such finite database by 𝒞M(ℐ, D). So, we can prove the following property.
Proposition 55. Yes/No query q(c), c = {c1, , cn} ∈Dn
Γ, n = arity(q) over a canonical
database 𝒞M(ℐ, D) ⊆canM(ℐ, D) and the rewritten query unfℳ(exp𝒢(q(c))) over a
source database D, return the same logical true/false value.
There is a unique homomorphism η : canM(ℐ, D) 󳨀→can(ℐ, D).
Proof. The first part of this proposition is a direct consequence of the query rewrit-
ing algorithms and it is also based on the fact that each Yes/No query over a source
database 𝒟and over a canonical database canM(ℐ, D) returns with the true/false
value. Proof of the second part: from a definition of certain answers (i. e., answers
which are true in all models of a database with incomplete information. Each pos-
sible completion of this incomplete information will provide a possible model), we
have that qℐ,𝒟= {t | t ∈Darity(q)
Γ
and ⊨ℬq(t) for each ℬ∈sem𝒟(ℐ)}. Thus, t ∈qℐ,𝒟
(or, equivalently, ⊨canM(ℐ,D) q(t)) iff ⊨ℬq(t) for each ℬ∈sem𝒟(ℐ), but, ⊨canM(ℐ,D) q(t)
iff ⊨M𝒟unfℳ(exp𝒢(q(t))).
Example 64. If we consider Example 62, we define φ homomorphism as follows: for
any constant in DΓ, it is an identity function (this is an intrinsic homomorphism prop-
erty). For Skolem constants, we have that η(ω1) = fs2(b), ω2i = f 2i−1
r,2 (b) and ω2i+1 =
fs,2(ω2i) = fs,2f 2i−1
r,2 (b), for i = 1, 2, . . . .
In order to define a peer database with relational view-based logic schemata (peer
ontology), the previous example on the application of data integration in web appli-
cations will be used as the building blocks for the P2P systems defined in the next
section. The possibility of using the negation logic operator also for querying such
data integration systems with generalized closed-world assumption was elaborated
in [156]. By abstracting the internal structure of such peers, we will obtain ADTs for
peers, while their relational view-based external interface (for the users) will be used
for intensional mappings between the peers based on relational views.
The universal (canonical) database can(ℐ, D), of the encapsulated Data integra-
tion system with the source database D, has the interesting property of faithfully rep-

494
|
A Appendix
resenting all legal databases (the construction of the canonical database is similar to
the construction of the restricted chase of a database described in [385]).
Thus, theoretically, the lifted query will filter only known answers from can(ℐ, D).
In practice, we do not use this canonical database in order to give the answer to the
query, and we use a query rewriting technics under constraints in data integration sys-
tems (e. g., a data integration systems with key and inclusion integrity constraints
[142]) to submit the rewritten query directly to source databases, extracted by wrap-
pers from the world wide web.

Bibliography
[1]
J. Pustejovsky and B. Boguraev, “Lexical knowledge representation and natural language
processing,” Artif. Intell., 63, pp. 193–223, 1993.
[2]
M.C. Fitting, “First-Order Intensional Logic,” Ann. Pure Appl. Log., 127, pp. 171–193, 2004.
[3]
M. Orgun and W. Wadge, “Towards a unified theory of intensional logic programming,” J. Log.
Program., 13(4), pp. 413–440, 1992.
[4]
T. Braüner, “Adding intensional machinery to hybrid logic,” J. Log. Comput., 18(4), 2008.
[5]
T. Braüner and S. Ghilardi, “First-order modal logic,” In Handbook of Modal Logic, Elsevier,
pp. 549–620, 2007.
[6]
S. Bond and M. Denecker, “I-logic:an intensional logic of informations,” In Proceedings of the
19th Belgian-Dutch Conference on Artificial Intelligence, Utreht, Nederlands, pp. 49–56, 2007.
[7]
D.K. Lewis, “On the plurality of worlds,” Oxford: Blackwell, 1986.
[8]
R. Stalnaker, “Inquiry,” Cambridge, MA: MIT Press, 1984.
[9]
R. Montague, “Universal grammar,” Theoria, 36, pp. 373–398, 1970.
[10]
R. Montague, “The proper treatment of quantification in ordinary English,” In Approaches to
Natural Language, J. Hintikka et al. (Eds.), Dordrecht: Reidel, pp. 221–242, 1973.
[11]
R. Montague, In Formal philosophy. selected papers of Richard Montague R. Thomason (Ed.),
New Haven, London: Yale University Press, pp. 108–221, 1974.
[12]
G. Bealer, “Quality and concept,” USA: Oxford University Press, 1982.
[13]
A. Thayse, “From modal logic to deductive dtatabases: Introducing a logic cased approach to
artificial intelligence,” John Wiley & Sons Press, 1988.
[14]
O. Udrea, V.S. Subrahmanian, and Z. Majkić, “Probabilistic RDF,” In IEEE Conference on
Information Reuse and Integration (IEEE IRI 2006), September 16–18, Waikoloa, Hawaii, USA,
2006.
[15]
Z. Majkić, O. Udrea, and V.S. Subrahmanian, “Aggregates in generalized temporally
indeterminate databases,” In Int. Conference on Scalable Uncertainty Management (SUM
2007), October 10–12, Washington DC, USA, LNCS 4772, pp. 171–186, 2007.
[16]
Z. Majkić, “Temporal Probabilistic logic programs: State and revision,” In International
Conference in Artificial Intelligence and Pattern Recognition (AIPR-07), July 9–12, 2007,
Orlando, FL, USA, 2007.
[17]
J. Minker, “Logic-based artificial intelligence,” Springer, 2000.
[18]
Z. Majkić, “Conservative intensional extension of Tarski’s semantics,” In Advances in Artificial
Intelligence, Hindawi Publishing Corporation, 23 October, pp. 1–17, 2012. ISSN: 1687-7470.
[19]
Z. Majkić, “Intensionality and two-steps interpretations,” arXiv:1103.0967, pp. 1–15, 2011.
[20]
Z. Majkić, “Intensional RDB manifesto: a unifying NewSQL model for flexible Big Data,”
arXiv:1403.0017, pp. 1–29, 2014.
[21]
Z. Majkić, In Big Data Integration Theory, Spinger-Verlag, Texts in Computer Science, New
York, pp. 516, 2014.
[22]
P. Blackburn, J.F. Benthem, and F. Wolter, “Handbook of modal logic,” In Studies in Logic and
Practical Reasoning 3. Elsevier Science Inc., 2006.
[23]
G. Bealer, “Universals,” J. Philos., 90, pp. 5–32, 1993.
[24]
W. Chen, M. Kifer, and D.S. Warren, “HiLog: A foundation for higher-order logic
programming,” J. Log. Program., 15, pp. 187–230, 1993.
[25]
G. Frege, “’́Uber Sinn und Bedeutung,” In Zeitschrift für Philosophie und Philosophische
Kritik, pp. 22–50, 1892.
[26]
G. Bealer, “A solution to Frege’s puzzle,” In Philosophical Perspectives 7, J. Tomberlin (Ed.),
Atascadero, CA: Ridgeview Press, pp. 17–61, 1993.
[27]
G. Bealer, “Theories of properties, relations, and propositions,” J. Philos., 76, pp. 634–648,
1979.
https://doi.org/10.1515/9783110981438-008

496
|
Bibliography
[28]
L. Henkin, J.D. Monk, and A. Tarski, “Cylindic algebras I,” North-Holland, 1971.
[29]
E.F. Codd, “A relational model of data for large shared data banks,” Commun. ACM, 13(6),
pp. 377–387, 1970.
[30]
A. Pirotte, “A precise definition of basic relational notions and of the relational algebra,”
SIGMOD Rec., 13(1), pp. 30–45, 1982.
[31]
R. Carnap, “Meaning and Necessity,” Chicago, 1947.
[32]
M.C. Fitting, “Intensional Logic – Beyond First Order,” In Trends in Logic: 50 Years of Studia
Logica, Kluwer Academic Publishers, pp. 87–108, 2003.
[33]
M.C. Fitting and R. Mendelsohn, “First-Order Modal Logic,” Kluwer, 1998.
[34]
H. Wansing, “A general possible worlds framework for reasoning about knowledge and
belief,” Stud. Log., 49, pp. 523–539, 1990.
[35]
H. Wansing and D. Pearce, “On the methodology of possible worlds semantics, II: Nonnormal
worlds and propositional attitudes,” Report 2/1989, Gruppe für Logik, Wissenstheorie und
Information, Freie Universität Berlin, 1989.
[36]
Z. Majkić, “First-order logic: Modality and intensionality,” arXiv:1103.0680v1, pp. 1–33, 2011.
[37]
P.R. Halmos, “Algebraic logic,” New York: Chelsea, 1962.
[38]
C. Davis, “Modal operators, equivalence relations, and projective algebras,” Am. J. Math., 76,
pp. 746–762, 1954.
[39]
J. Van Benthem, “Correspondence Theory,” In Handbook of Philosophical Logic, Vol. II, D.
Gabbay and F. Guenthner (Eds.), D. Reidel Publishing Company, Holand, pp. 167–247, 1984.
[40]
H. Wansing and D. Pearce, “On the methodology of possible worlds semantics, I:
Correspondence theory,” Notre Damme J. Forma Logic, 29, pp. 482–496, 1988.
[41]
Z. Majkić, “Sound and complete query-answering in intensional P2P data integration,”
arXiv:1103.0490v1, pp. 1–27, 2011.
[42]
Z. Majkić, “Intensional first-order logic for P2P database systems,” In Journal of Data
Semantics (JoDS XII), LNCS 5480, Berlin Heidelberg: Springer, pp. 131–152, 2009.
[43]
Z. Majkić, “Intensional logic and epistemic independency of intelligent database agents,”
In 2nd International Workshop on Philosophy and Informatics (WSPI 2005), April 10–13,
Kaiserslautern, Germany, 2005.
[44]
Z. Majkić, “Weak deduction for queries in intensional P2P database systems,” In International
Conference on Enterprise Information Systems and Web Technologies (EISWT-09), Orlando FL,
USA, July 13–16, 2009.
[45]
P.J. Hayes, “Some problems and non-problems in representation theory,” In Proc. AISB
Summer Conference, University of Sussex, pp. 63–79, 1974.
[46]
W.A. Woods, “What’s in a link: Foundations for semantic networks,” In Representation and
Understanding: Studies in Cognitive Science, D.G. Bobrow and A.M. Collins (Eds.), pp. 35–82,
1975.
[47]
P.J. Hayes, “The logic of frames,” In Frame Conceptions and Text Understanding, D. Metzing
(Ed.), Walter de Gruyter and Co., pp. 46–61, 1979. Republished in [387].
[48]
H.J. Levesque and R.J. Brachman, “A fundamental tradeoff in knowledge representation and
reasoning,” In Readings in Knowledge Representation, R.J. Brachman and H.J. Levesque
(Eds.), pp. 41–70, 1985.
[49]
H.J. Levesque and R.J. Brachman, “Expressiveness and tractability in knowledge
representation and reasoning,” Comput. Intell., 3, pp. 78–93, 1987.
[50]
F. Baader, D. Calvanese, D.L. Mc Guiness, D. Nardi, and P.F. Patel-Schneider, “Description
Logic Handbook,” Cambridge University Press, 2002.
[51]
B. Russell, “On Denoting,” In Mind, XIV, Reprinted in Russell, Logic and Knowledge,
pp. 479–493, 1905.
[52]
A.N. Whitehead and B. Russell, “Principia Mathematica, Vol. I,” Cambridge, 1910.

Bibliography
|
497
[53]
Z. Majkić, “Weakly-coupled ontology integration of P2P database systems,” In 1st Int.
Workshop on Peer-to-Peer Knowledge Management (P2PKM), August 22, Boston, USA, 2004.
[54]
Z. Majkić, “Intensional P2P mapping between RDF ontologies,” In 6th International
Conference on Web Information Systems (WISE-05), November 20–22, New York, M.
Kitsuregawa (Ed.), LNCS 3806, pp. 592–594, 2005.
[55]
Z. Majkić, “Intensional semantics for P2P data integration,” In Journal on Data Semantics
(JoDS) VI, Special Issue on ‘Emergent Semantics’, LNCS 4090, pp. 47–66, 2006.
[56]
Z. Majkić, “Non omniscient intensional contextual reasoning for query-agents in P2P
systems,” In 3rd Indian International Conference on Artificial Intelligence (IICAI-07),
December 17–19, Pune, India, 2007.
[57]
Z. Majkić, “Coalgebraic specification of query computation in intensional P2P database
systems,” In Int. Conference on Theoretical and Mathematical Foundations of Computer
Science (TMFCS-08), Orlando FL, USA, July 7–9, 2008.
[58]
Z. Majkić, “RDF view-based interoperability in intensional FOL for Peer-to-Peer database
systems,” In International Conference on Enterprise Information Systems and Web
Technologies (EISWT-08), Orlando FL, USA, July 9–11, 2008.
[59]
Z. Majkić, “Categories: symmetry, n-dimensional levels and applications”, PhD Thesis,
University “La Sapienza”, Roma, Italy, 1998.
[60]
Z. Majkić, “Completion and Unification of Quantum Mechanics with Einstein’s GR Ideas, Part
I: Completion of QM,” New York: Nova Science Publishers, ISBN 978-1-53611-946-6, 2017.
[61]
Z. Majkić, “Completion and Unification of Quantum Mechanics with Einstein’s GR Ideas,
Part III: Advances, Revisions and Conclusions,” New York: Nova Science Publishers, ISBN
978-1-53617-200-3, 2020.
[62]
N.J. Nilsson, “Probabilistic logic,” Artif. Intell., 28, pp. 71–88, 1986.
[63]
R. Fagin, J. Halpern, and N. Megiddo, “A logic for reasoning about probabilities,” Inf. Comput.,
87, pp. 78–128, 1990.
[64]
J.Y. Halpern, “An analysis of first-order logics of probability,” Artif. Intell., 46, pp. 311–350,
1990.
[65]
G. Kuper, L. Libkin, and J. Paredaens, “Constraint Databases,” Springer, 2000.
[66]
K. Marriot and H. Sondergaard, “Bottom-up abstract interpretation of logic programs,” In
Proc. 5th Int. Conf. and Symposium on Logic Programming, Washington, Seatle, 1988.
[67]
P. Cousot and R. Cousot, “Abstract interpretation: A unified lattice model for static analysis of
programs by construction or approximation of fixpoints,” In Int. Conf. 4th ACM Symposium on
Principles of Programming Languages (POPL77), pp. 238–252, 1977.
[68]
Z. Majkić, “Constraint logic programming and logic modality for event’s valid-time
approximation,” In 2nd Indian International Conference on Artificial Intelligence (IICAI-05),
December 20-22, Pune, India, 2005.
[69]
Z. Majkić, “Autoreferential semantics for many-valued modal logics,” J. Appl. Non-Class. Log.,
18(1), pp. 79–125, 2008.
[70]
R.T. Ng and V.S. Subrahmanian, “Probabilistic logic programming,” Inf. Comput., 101(2),
pp. 150–201, 1992.
[71]
A. Dekhtyar and M.I. Dekhtyar, “Possible worlds semantics for probabilistic logic programs,”
In ICLP 2004, pp. 137–148, 2004.
[72]
Z. Majkić, “Probabilistic deduction and pattern recognition of complex events,” In
International Conference on Information Security and Privacy (ISP-09), Orlando FL, USA, July
13–16, 2009.
[73]
W. Feller, “An introduction to Probability Theory and its applications, Vol. I,” 2nd edition, New
York: Wiley, 1957.
[74]
P. Halmos, “Measure theory,” Van Nostrand, 1950.

498
|
Bibliography
[75]
A.N. Kolmogorov, In A.N. Shiryayev, editor, “Selected works of A.N. Kolmogorov: vol. 2
Probability theory and mathematical statistics,” Moscow: Nauka, 1986.
[76]
R. Fagin and J.Y. Halpern, “Uncertainty, belief, and probability,” In IJCAI 89, pp. 1161–1167,
1989.
[77]
Z. Majkić, “Intensional semantics for RDF data structures,” In 12th International Database
Engineering & Applications Systems (IDEAS08), Coimbra, Portugal, 10–13 September, 2008.
[78]
J. Lukasiewicz, “Comptes rendus des seances de la societe des sciences et des letters de
Varsovie, cl. III 23,” J. Philos. Bemerk. Syst. Aussagenlogik, pp. 51–77, 1930.
[79]
J. Lukasiewicz, “A system of modal logic,” J. Comp. Syst., 1, pp. 111–149, 1953.
[80]
J. Lukasiewicz, “Selected Works,” In Studies in Logic and the Foundations of Mathematics, L.
Borkowski (Ed.) Amsterdam: North-Holland, 1970.
[81]
Z. Majkić and B. Prasad, “Lukasiewicz’s 4-valued logic and normal modal logics,” In 4th
Indian International Conference on Artificial Intelligence (IICAI-09), December 16–18, Tumkur,
India, 2009.
[82]
Z. Majkić, “Functional many-valued logic and global predicate compression,” In MVLPA
Multivalued Logic Programming and Applications (with ICLP), 17–20 August, Seatle, WA,
2006.
[83]
Z. Majkić, “Many-valued logic programming and fixpoint semantics for higher-order Herbrand
models,” In 20th Workshop on (Constraint) Logic Programming (WLP 2006), February 22–24,
Vienna, Austria, 2006.
[84]
J.Y. Béziau, “Non truth-functional many-valued semantics,” In Aspects of Universal Logic,
J.-Y. Béziau, A. Costa-Leite and A. Facchini (Eds.), Neuchâtel: Université de Neuchâtel,
pp. 199–218, 2004.
[85]
Z. Majkić, “Probabilistic logic: Many-valuedness and intensionality,” arXiv:1103.0676v1,
pp. 1–15, 2011.
[86]
C. Dyreson and R. Snodgrass, “Supporting valid-time indeterminacy,” ACM Trans. Database
Syst., 23, pp. 1–57, 1998.
[87]
A. Dekhtyar, R. Ross, and V.S. Subrahmanian, “Probabilistic temporal databases, I:Algebra,”
ACM Trans. Database Syst., 26, pp. 41–95, 2001.
[88]
T. Berners-Lee, J. Hendlar, and O. Lassila, “The semantic web,” Sci. Am., 279, 2001.
[89]
O. Lassila and R.R. Swick, “Resource description framework (RDF): Model and syntax
specification,” World Wide Web Consortium, http://www.w3.org/TR/REC-rdf-syntax, 1999.
[90]
D. Brickley and R. Guha, “Resource description framework (RDF) schema specification 1.0,”
World Wide Web Consortium, http://www.w3.org/TR/2000/CR-rdf-schema-20000327, 2000.
[91]
F. van Harmelen, J. Handler, I. Horrocks, D.L. McGuinnes, P.F. Patel-Schneider, M. Dean, D.
Connolly, and L.A. Stein, “OWL Web ontology language 1.0 reference,” http://www.w3.org/
TR/owl-ref/, 2002.
[92]
P.F. Patel-Schneider and D. Fensel, “Layering the semantic Web: Problems and directions,” In
2002 International Sematic Web Conference, 2002.
[93]
I. Horrocks and P.F. Patel-Schneider, “Three thesis of representation in the semantic web,” In
Proc. of the 12th International World Wide Web Conference (WWW2003), pp. 39–47, 2003.
[94]
G. Yang and M. Kifer, “On the semantics of anonimous identity and reification,” In Lecture
Notes in Comp. Science (ODBASE2002) 2519, pp. 1047–1066, 2002.
[95]
M.R. Genesereth, “Knowledge interchange format,” T.Report NCITS. T2/98-004, Stanford
University, 1998.
[96]
P. Hayes and C. Menzel, “A semantics for the knowledge interchange format,” In Workshop on
the IEEE Standard Upper Ontology (in IJCAI), 2001.
[97]
P. Hayes, “RDF Model theory,” T.Report W3C, http:/www.w3.org/TR/rdf-mt, 2002.
[98]
J.Z. Pan and I. Horrocks, “RDFS(FA): A DL-ised sub-language of RDFS,” In Proc. of the 2003
Description Logic Workshop, (DL 2003), CEUR 81, pp. 95–102, 2003.

Bibliography
|
499
[99]
A. Levy, A. Mendelzon, and Y. Sagiv, “Answering queries using views,” In Proc. 14th ACM
Symp. on Principles of Database Systems, pp. 95–104, 1995.
[100] K. Aberer, M. Punceva, M. Hauswirth, and R. Schmidt, “Improving data access in P2P
systems,” In IEEE Internet Computing, 2002.
[101]
D. Calvanese, G. De Giacomo, M. Lenzerini, and R. Rosati, “Logical foundations of
Peer-to-Peer data integration,” In PODS 2004, June 14–16, Paris, France, 2004.
[102] Hewlett-Packard, “RDQL-RDF data query language,” http://www.hpl.hp.com/semweb/rdql.
html.
[103] S. Alexaki, V. Christophides, D. Plexousakis, M. Scholl, G. Karvounarakis, A. Magnaraki, and
K. Tolle, “Quering the semantic web with RQL,” Comput. Netw. ISDN Syst. J., 42, 2003.
[104] Y. Deng, E. Hung, and V.S. Subrahmanian, “Maintaining RDF views,” Tech. Rep. CS-TR-4612
(UMIACS-TR-2004-54), 2004.
[105]
Z. Majkić, “Flexible intentional query-answering for RDF Peer-to-Peer systems,” In 7th
International Conference on Flexible Query Answering Systems (FQAS 2006), 7–10 June,
Milano, Italy, 2006.
[106] M. Ushold, “Where is the semantics in the semantic web,” In Workshop on Ontologies in
Agent Systems (OAS) at the 5th International Conference on Autonomous Agents, 2001.
[107]
S. Gribble, A. Halevy, Z. Ives, M. Rodrig, and D. Suciu, “What can databases do for
Peer-to-Peer?,” In WebDB Workshop on Databases and the Web, 2001.
[108] L. Serafini, F. Giunchiglia, J. Mylopoulos, and P.A. Bernstein, “The local relational model:
Model and proof theory,” Technical Report 0112-23, ITC-IRST, 2001.
[109] C. Ghidini and F. Giunchiglia, “Local models semantics or contextual reasoning = locality +
compatibility,” Artif. Intell., 127, pp. 221–259, 2001.
[110]
R. Reiter, “Towards a logical reconstruction of relational database theory,” In On Conceptual
Modeling: Perspectives from Artificial Intelligence Databases and Programming Languages,
M.L. Brodie, J. Mylopoulos and J.W. Schmidt (Eds.), 1984.
[111]
M. Lenzerini, “Data integration: a theoretical perspective,” 2002, pp. 233–246.
[112]
A.Y. Halevy, D. Suiu, Z.G. Ives, and I. Tatarinov, “Schema mediation for large-scale semantic
data sharing,” VLDB J., 14(1), pp. 68–83, 2005.
[113]
P. Aczel, Non-well-founded sets, Number 14 in Lecture Notes CSLI, 1988.
[114]
P. Aczel, J. Adamek, S. Milius, and J. Velebil, “Infinite trees and completely iterative theories:
a coalgebraic view,” Theor. Comput. Sci., 300, pp. 1–45, 2003.
[115]
M. Lenzerini and Z. Majkić, “General framework for query reformulation,” In Semantic Webs
and Agents in Integrated Economies, D3.1, IST-2001-34825, February, 2003.
[116]
M. Gelfond and V. Lifshitz, “The stable model semantics for logic programming,” In Proc. of
the Fifth Logic Programming Symposium, Cambridge, MA: MIT Press, pp. 1070–1080, 1988.
[117]
Z. Majkić, “Fixpoint semantics for query answering in data integration systems,” In AGP03 –
8th Joint Conference on Declarative Programming, Reggio Calabria, pp. 135–146, 2003.
[118]
Z. Majkić, “Plausible query-answering inference in data integration,” In 18th International
Florida Artificial Intelligence Conference (FLAIRS 2005), May 15–17, Clearwater Beach, USA,
2005.
[119]
H.J. Levesque, “All I know: a study in autoepistemic logic,” Artif. Intell., 42, pp. 263–310,
1990.
[120] R. Reiter, “What should a database know?,” J. Log. Program., 14, pp. 127–153, 1992.
[121]
P. Blackburn, “Representation, reasoning, and relational structures: a hybrid logic manifesto.
Methods for Modalities 1,” Log. J. IGPL, 8, pp. 339–365, 2000.
[122]
E. Franconi, G. Kuper, A. Lopatenko, and L. Serafini, “A robust logical and computational
characterization of Peer-to-Peer data systems,” Technical Report DIT-03-051, University of
Trento, Italy, 2003.

500
|
Bibliography
[123]
D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, and R. Rosati, “Inconsistency tollerance
in P2P data integration: an epistemic approach,” In Proc. 10th Int. Workshop on Database
Programming Language, 2005.
[124] S. Abitebul and O. Duschka, “Complexity of answering queries using materialized views,” In
Proc. of PODS, Seattle, WA, pp. 254–263, 1998.
[125]
Z. Majkić, “Weakly-coupled P2P system with a network repository,” In 6th Workshop on
Distributed Data and Structures (WDAS’04), July 5–7, Lausanne, Switzerland, 2004.
[126] Z. Majkić, “Massive parallelism for query answering in weakly integrated P2P systems,” In
Workshop GLOBE 04, August 30–September 3, Zaragoza, Spain, 2004.
[127]
M. Arenas, L.E. Bertossi, and J. Chomicki, “Consistent query answers in inconsistent
databases,” In Proc. of the 18th ACM Symp. on Principles of Database Systems, pp. 68–79,
1999.
[128] G. Greco, S. Greco, and E. Zampano, “A logic programming approach to the integration,
repairing and querying of inconsistent databases,” In Proc. of the 17th Int. Conf. on Logic
Programming 2237, pp. 348–364, 2001.
[129]
Z. Majkić, “Autoepistemic logic programming for reasoning with inconsistency,” In
International Symposium on Logic-based Program Synthesis and Transformation (LOPSTR),
September 7–9, 2005, Imperial College, London, UK, 2005.
[130] J. McCarthy, “Circumscription – a form of non-monotonic reasoning,” Artif. Intell., 13, 1980.
[131]
Y. Shoham, “A semantical approach to nonmonotonic logics,” In Proc. 2nd IEEE Symp. on
Logic in Computer Science, pp. 275–279, 1987.
[132]
S. Kraus, D. Lehmann, and M. Magidor, “Non-monotonic reasoning, preferential models and
cumulative logics,” Artif. Intell., 44, pp. 167–207, 1990.
[133]
S. Lindstrom, “A semantical approach to nonmonotonic reasoning: Inference operations and
choice,” Tech. Rep. Upsala Prints and Preprints in Philosophy, 1994:10, University of Upsala,
1994.
[134]
N. Friedman and J.Y. Halpern, “Plausibility measures and default reasoning,” In Proc. AAAI’96,
pp. 1297–1304, 1996.
[135]
D. Lehman, “Non monotonic logics and semantics,” Tech. Rep. TR-98-6, Institute of Comp.
Science, Hebrew University, Jerusalem, 1998.
[136] M. Arenas, L. Bertossi, and J. Chomicki, “Consistent query answers in inconsistent
databases,” In Proc. ACM Symp. on Principles of Database Systems, pp. 68–79, 1999.
[137]
D. Gabbay, “Theoretical foundations for non-monotonic reasoning in expert systems,” In
Logics and Models of Concurrent Systems, NATO ASI Series F13, Springer, 1985.
[138] D. Makinson, “General theory of cumulative inference,” In Non-Monotonic Reasoning, Lecture
Notes on Artificial Intelligence 346, Spinger Verlag, 1989.
[139]
M. Dalal, “Investigations into a theory of knowledge base revision,” In Proc. National
Conference on Artificial Intelligence, pp. 475–479, 1988.
[140] D. Fensel, Ontologies: A Silver Bullet for Knowledge Management and Electronic Commerce,
2001.
[141]
M. Lenzerini and Z. Majkić, “First release of the system prototype for query management,” In
Semantic Webs and Agents in Integrated Economies, D3.3, IST-2001-34825, 2003.
[142] A. Calì, D. Calvanese, G. De Giacomo, and M. Lenzerini, “Data integration under integrity
constraints,” pp. 262–279, 2002.
[143]
R. Fagin, P.G. Kolaitis, R.J. Miller, and L. Popa, In DATA Exchange: Semantics and query
answering, pp. 207–224, 2003.
[144] Z. Majkić, “Coalgebraic semantics for logic programming,” In 18th Worshop on (Constraint)
Logic Programming, W(C)LP 2004, March 04–06, Berlin, Germany, 2004.
[145]
J. de Riviers and H. Levesque, “The consistency of syntactical treatments of knowledge,”
Comput. Intell., 4, pp. 31–41, 1988.

Bibliography
|
501
[146] M. Morreau and S. Kraus, “Syntactical treatments of propositional attitudes,” In Artificial
Intelligence, 1998.
[147]
K. Konolige, “A deduction model of belief,” Morgan Kaufman, 1986.
[148] D. Lewis, “Index, Context, and Content,” In Philosophy and Grammar, S. Kranger and S.
Ohman (Eds.), D. Reidel Publishing Company, pp. 79–100, 1980.
[149] J. McCarthy, “Notes on formalizing context,” In Proc. of the 13th International Joint Conference
on Artificial Intelligence, Chambery, France, pp. 555–560, 1993.
[150]
F. Giunchiglia, “Contextual reasoning,” In Epistemologia, special issue on I Linguaggi e le
Macchine, XVI, pp. 345–364, 1993.
[151]
D.M. Gabbay, “Labelled Deductive Systems,” Volume 1 – Founrations. Tech. Report
MPI-I-94-223, Max-Planc-Institut Für Informatik, 1994.
[152]
B. Jacobs, “Objects and classes, co-algebrically,” In Object-Orientation with Parallelism and
Persistence, Kluwer Acad. Publ., pp. 83–103, 1996.
[153]
J. Rutten, “Universal coalgebra: A theory of systems,” Theor. Comput. Sci., 249, pp. 3–90,
2000.
[154]
A.Y. Halevy, “Answering queries using views: A survey,” VLDB J., 10(4), pp. 270–294, 2001.
[155]
D. Lembo, M. Lenzerini, and R. Rosati, “Source inconsistency and incompleteness in data
integration,” In Proc. of the 9th Int. Workshop on Knowledge Representation meets Databases
(KRDB 2002) CEUR, 2002.
[156]
Z. Majkić, “Querying with negation in data integration systems,” In 9th International
Database Engineering and Application Symposium (IDEAS), July 25–27, 2005, Montreal,
Canada, IEEE Computer Society, pp. 58–70, 2005.
[157]
COMPUTERWORLD, “No to SQL? Anti-database movement gains steam,” , https://www.
computerworld.com/article/2526317/no-to-sql--anti-database-movement-gains-steam.html,
2009.
[158]
M. Stonebraker and C. Ugur, “One size fits all,” In ICDE 05 Proceedings, Washington, DC, USA:
IEEE Computer Society, pp. 2–11, 2005.
[159]
M. Stonebraker, S. Madden, D. Abadi, S. Harizopoulos, N. Hachem, and P. Helland, “The end
of and architectural era: (it’s time for a complete rewrite),” In VLDB 07 Proceedings, VLDB
Endowment, pp. 1150–1160, 2007.
[160] R. Kallman, H. Kimura, J. Natkins, A. Pavio, S. Zdonik, D.J. Abadi, E.P. C. Jones, S. Madden, A.
Rasin, M. Stonebraker, Y. Zhang, and J. Hugg, “H-store: a high-performance, distributed main
memory transaction processing system,” In Proceedings of the VLDB 08, VLDB Endowment,
pp. 1496–1499, 2008.
[161]
M. Stonebraker, “SQL databases v. NoSQL databases,” Commun. ACM, 53, pp. 4, 2010.
[162] M. Stonebraker, D.J. Abadi, D.J. Dewitt, S. Madden, E. Paulson, A. Pavio, and A. Rasin,
“MapReduce and parallel DBMSs: Friends or Foes?,” Commun. ACM, 53, pp. 64, 2010.
https://doi.org/10.1145/1629175.1629197.
[163] A. Pavio, E. Paulson, D.J. Abadi, D.J. Dewitt, S. Madden, A. Rasin, and M. Stonebraker, “A
comparison of approaches to large-scale data analysis,” In Proceedings of the 35th SIGMOD
Conference, New York: ACM Press, pp. 165–178, 2009.
[164] A.K. Chandra and D. Harel, “Structure and complexity of relational queries,” J. Comput. Syst.
Sci., 25(1), pp. 99–128, 1982.
[165]
J.M. Smith and D.C. P. Smith, “Database abstractions: Aggregation and generalization,” ACM
Trans. Database Syst., 2(2), pp. 105–133, 1977.
[166] K.A. Ross, “Relations with relation names as arguments: Algebra and calculus,” In
Proceedings of the 11th ACM Symposium on Principles of Database Systems, San Diego,
California, pp. 346–353, 1992.
[167]
A. Lefebvre, P. Brnus, and R. Topor, “Query transformation for accesing heterogeneous
databases,” In Workshop on Deductive Databases in conjunction with JICSLP, pp. 31–40,
1992.

502
|
Bibliography
[168] R. Krishnamurthy, W. Litwin, and W. Kent, “Language features for interoperability of
databases with schematic discrepancies,” In Proceedings of the ACM SIGMOD, New York,
pp. 40–49, 1991.
[169] L.V. S. Lakshmanan, F. Sadri, and I.N. Subramanian, “SchemaSQL-an extension to SQL for
multidatabase interoperability,” ACM Trans. Database Syst., 26(4), pp. 476–519, 2001.
[170]
R. Agrawal, A. Somani, and Y. Xu, “Storage and querying of E-commerce data,” In Proceedings
of the VLDB 01, 27th VLDB Conference, Roma, Italy, 2001.
[171]
C. Cunningham, C.A. Galindo-Legaria, and G. Graefe, “PIVOT and UNPIVOT: Optimization and
execution strategies in an RDBMS,” In Proceedings of the 30th VLDB Conference, Toronto,
pp. 998–1009, 2004.
[172]
L.V. S. Lakshmanan, F. Sadri, and I.N. Subramanian, “Logic and algebraic languages for
interoperability in multidatabase systems,” J. Log. Program., 33(2), pp. 101–149, 1997.
[173]
G. Wiederhold, “Mediators in the architecture of future information systems,” In IEEE
Computer, 1992.
[174]
Z. Majkić and B. Prasad, “Kleisli category for database mappings,” Int. J. Intell. Inf. Database
Syst., 4(5), pp. 509–527, 2010.
[175]
Z. Majkić, “Data base mappings and monads: (co)induction,” arXiv:1102.4769v1, pp. 1–31,
2011.
[176]
E. Moggi, “Computational lambda-calculus and monads,” In Proceedings. Fourth Annual
Symposium on Logic in Computer Science, pp. 14–23, 1989.
[177]
E. Moggi, “Notions of computation and monads,” Inf. Comput., 93(1), pp. 55–92, 1991.
[178]
D.I. Spivak, “Kleisli database instances,” arXiv:1209.1011, pp. 1–23, 2012.
[179]
R. Fagin, P.G. Kolaitis, L. Popa, and W. Tan, “Composing schema mappings: second-order
dependencies to the rescue,” ACM TODS, 30(4), pp. 994–1055, 2005.
[180] Z. Majkić, “Data base mappings and theory of sketches,” arXiv:1104.4899v1, pp. 1–21, 2011.
[181]
S. Mac Lane, “Categories for the Working Mathematician,” Springer, 1971.
[182] J. Lambek and P. Scott, “Introduction to higher order categorial logic,” Cambidge University
Press, 1986.
[183] G.M. Kelly and A.J. Power, “Adjuntions whose counits are coequalizers, and presentations of
finitary enriched monads,” J. Pure Appl. Algebra, 89, pp. 163–179, 1993.
[184] P. Buneman, S. Naqui, V. Tanen, and L. Wong, “Principles of programming with complex
objects and collection types,” Theor. Comput. Sci., 149(1), 1995.
[185]
G.D. Plotkin and A.J. Power, “Adequacy for algebraic effects,” In Proc. FOSSACS 2001, LNCS
2030, pp. 1–24, 2001.
[186] Z. Majkić, “Saturation of the morphisms in the database category,” arXiv:1405.3955, pp. 1–17,
2014.
[187]
P.T. Johnstone, “Stone spaces,” Cambridge: Cambridge University Press, ISBN 0-521-23893-5,
1982.
[188] M.C. Fitting, “Bilattices and the semantics of logic programming,” J. Log. Program., 11,
pp. 91–116, 1991.
[189] M.L. Ginsberg, “Bilattices and modal operators,” Tech. Rep. N. 94305, Comp. Science Dept.
Stanford University, California, 1990.
[190] N.D. Belnap, “A useful four-valued logic,” In Modern Uses of Multiple-Valued Logic, J-M. Dunn
and G. Epstein (Eds.), D. Reidel, 1977.
[191]
J. Lukasiewicz, “Aristotele’s syllogistic from the standpoint of modern formal logic,” (2nd
enlaged edition), Oxford: Clarendon Press, 1957.
[192]
M. Gehrke and B. Jonsson, “Bounded distributive lattices with operators,” Math. Jpn., 40(2),
pp. 207–215, 1994.
[193]
J.M. Dunn, “Positive Modal Logic,” Stud. Log., 55, pp. 301–317, 1995.

Bibliography
|
503
[194] J. Dunn and C. Zhou, “Negation in the context of gaggle theory,” Stud. Log., 80(2–3),
pp. 235–264, 2005.
[195]
G. Restall, “Constant domain quantified modal logics without boolean negation,” Aust. J.
Logic, 3, pp. 45–62, 2005.
[196] V. Sofronie-Stokkermans, In Representation theorems and the semantics of non-classical
logics, and applications to automated theorem proving, M. Fitting and E. Orlowska (Eds.),
Springer Verlag series Studies in Fuzziness and Soft Computing, pp. 59–100, 2003.
[197]
M. Ginsberg, “Multivalued logics: A uniform approach to reasoning in artificial intelligence,”
Comput. Intell., 4, pp. 265–316, 1988.
[198] O. Arieli and A. Avron, “Logical bilattices and inconsistent data,” In Proc. 9th IEEE Annual
Symp. on Ligic in Computer Science, pp. 468–476, IEEE Press, 1994.
[199] P. Ruet and F. Fages, “Combining explicit negation and negation by failure via Belnap’s logic,”
In Workshop on Uncertainty in Databases and Deductive Systems (ILPS-94), 1994.
[200] V.S. Lakshmanan and F. Sadri, “Probabilistic deductive databases,” In Proc. Intl. Logic
Programming Symposium, Ithaca, NY: MIT Press, pp. 254–268, 1994.
[201] K.M. Sim, “Bilattices and reasoning in artificial intelligence: Concepts and foundations,” In
Artificial Intelligence Review 15, Kluwer Ac. Publishers, pp. 219–240, 2001.
[202] Z. Majkić, “Beyond fuzzy: Parameterized approximations of Heyting algebras for uncertain
knowledge,” In 2nd Indian International Conference on Artificial Intelligence (IICAI-05),
December 20–22, Pune, India, 2005.
[203] Z. Majkić, “Many-valued intuitionistic implication and inference closure in a bilattice based
logic,” In 35th International Symposium on Multiple-Valued Logic (ISMVL 2005), May 18–21,
Calgary, Canada, 2005.
[204] Z. Majkić, “Reduction of many-valued logic programs into two-valued modal logics,”
In Intellectual Archive Bulletin, Shiny World Corp., Toronto, ID:493, ISSN 1929-1329
(arXiv:1103.0920), 21 June, pp. 1–27, 2012.
[205] Z. Majkić, “Binary sequent calculi for truth-invariance entailment of finite many-valued
logics,” arXiv:1103.1334, 2011.
[206] Z. Majkić, “A new representation theorem for many-valued modal logics,” arXiv:1103.0248v1,
pp. 1–19, 2011.
[207] G. Birkhoff, “Lattice theory,” reprinted 1979, Amer. Math. Soc. Colloquium Publications XXV,
1940.
[208] Z. Majkić, “Intuitionistic truth-knowledge symmetric bilattices for uncertainty in intelligent
systems,” In 3rd Int. IEEE Conf. on Intelligent Systems (IS06), 4–6 Sept., London, UK,
pp. 703–710, 2006.
[209] Z. Majkić, “Bilattices, intuitionism and truth-knowledge duality: Concepts and foundations,”
J. Mult.-Valued Log. Soft Comput., 14(6), pp. 525–564, 2008.
[210] K. Došen, “Negation as a modal operator,” Rep. Math. Log., 20, pp. 15–28, 1986.
[211]
J.Y. Béziau, “Are paraconsistent negations negations?,” In Paraconsistency: the logical way to
the inconsistent, W. Carnielli (Ed.), New York: Marcel Dekker, pp. 465–486, 2002.
[212]
D.M. Clark and B.A. Davey, “Natural dualities for the working algebraist,” In Cambridge
studies in advanced mathematics 57, 1st edition, Cambridge University Press, 1998.
[213]
J.C. C. McKinsey and A. Tarski, “On closed elements in closure algebras,” Ann. Math., 47,
pp. 122–162, 1946.
[214] M.C. Fitting, “Kleene’s logic, generalized,” J. Log. Comput., 1, pp. 797–810, 1992.
[215]
M.C. Fitting, “Kleene’s three valued logics and their children,” Fundam. Inform., 20,
pp. 113–131, 1994.
[216] M. Schmidt-Schauß and G. Smolka, “Attributive concept descriptions with complements,”
Artif. Intell., 48(1), pp. 1–26, 1991.

504
|
Bibliography
[217]
I. Horrocks and P.F. Patel-Schneider, “Reducing OWL entailment to description logic
satisfiability,” In ISWC 2003, LNCS 2870, Heidelberg: Springer, pp. 17–29, 2003.
[218] Z. Majkić, “Ontological encapsulation of many-valued logic,” In 19th Italian Symposium of
Computational Logic (CILC04), June 16–17, Parma, Italy, 2004.
[219]
Z. Majkić and B. Prasad, “Soft query-answering computing in P2P systems with epistemically
independent peers,” In Book on Soft Computing Applications in Industry, STUDFUZZ 226,
Berlin: Springer, pp. 331–356, 2008.
[220] A. Tarski, “Der wahrheitsbegriff in den formalisierten sprachen,” Studia Philos., 1,
pp. 261–405, 1936. English translation, ‘The concepts of truth in formalized langiuges’,
appeared in A. Tarski 1956, Logic, Semantics and Metamathematics: Papers by Alfred Tarski
from 1923 to 1938, Oxford: Clarendon Press.
[221]
J. Ketland, “Deflationism and tarski’s paradise,” Mind, 108, pp. 69–94, 1999.
[222] S. Shapiro, “Truth and proof – through thick and thin,” J. Philos., 95, pp. 493–522, 1998.
[223] G. Boolos and R. Jeffrey, “Computability and Logic,” 3rd edition, Cambridge University Press,
1989.
[224] J. Ketland, “A proof of the (strethened) liar formula in a semantic extension of Peano
arithmetic,” Analysis, 60, pp. 1–4, 2000.
[225] I.E. Orlov, “The calculus of compatibility of propositions,” Mat. Sb., 35, pp. 263–286, 1928 (in
Russian).
[226] K. Došen, “A brief survey of frames for the Lambek calculus,” Z. Math. Log. Grundl. Math., 38,
pp. 179–187, 1992.
[227] Z. Majkić, “Weakening of intuitionistic negation for many-valued paraconsistent da Costa
system,” Notre Dame J. Form. Log., 49(4), pp. 401–424, 2008.
[228] Z. Majkić, “Paraconsistent logic and weakening of intuitionistic negation,” Int. J. Intell. Syst.,
3, pp. 255–270, 2012.
[229] A. Neckam, “De naturis rerum,” T. Wright, editor, London, 1863.
[230] A. Urquhart, “Semantics for relevant logics,” J. Symb. Log., 37(1), pp. 159–169, 1972.
[231]
K. Fine, “Models for entailment,” J. Philos. Log., 3, pp. 347–372, 1974.
[232] J. Barwise, “Constraints, channels and the flow of information,” In Situation Theory and Its
Applications 3, P. Aczel and et al. (Eds.), Stanford: CSLI Publications, pp. 3–27, 1993.
[233] G. Restall, “Information flow and relevant logics,” In Logic, Language and Computation
(Volume 1), J. Seligman and D. Westerstahl (Eds.), Stanford: CSLI Publications, pp. 463–478,
1996.
[234] E.D. Mares, “Four-valued semantics for the relevant logic R,” J. Philos. Log., 33, pp. 327–341,
2004.
[235] J.M. Dunn, “The relevance of relevance to relevance logic,” In Logic and its Applications: 6th
Indian Conference, ICLA 2015, Mumbai, India, M. Banerjee and S.N. Krishna (Eds.), 2015.
[236] J.M. Dunn, “Partial gaggles applied to logics with restricted structural rules,” In Substructural
logics, in Logic and Computation 2, P. Schröeder-Heister and K. Došen (Eds.), Oxford
University Press, pp. 63–108, 1993.
[237] J.M. Dunn, “A representation of relation algebras using routley-meyer frames,” In Logic,
Meaning and Computation C.A. Anderson and M. Zeleny, (Eds.), Synthese Library (Studies
in Epistemology, Logic, Methodology, and Philosophy of Science) 305, Dordrecht: Springer,
2001.
[238] M. Gehrke, C. Walker, and E. Walker, “A mathematical setting for fuzzy logics,” Int. J.
Uncertain. Fuzziness Knowl.-Based Syst., 5(3), pp. 223–238, 1997.
[239] P. Hájek, “Metamathematics of fuzzy logic,” Trends in Logic 4. Dodrecht: Kluwer Academic
Publishers, 1998.
[240] H. Ono, “Logics without the contraction rule and residuated lattices,” Australas. J. Log., 8,
pp. 50–81, 2010.

Bibliography
|
505
[241]
J. Lukasiewicz and A. Tarski, “Untersuchungen über den aussagenkalkül,” Comp. Rend. Soc.
Sci. Lett. Varsovie Cl. III, 23, pp. 30–50, 1930.
[242] R. Cignoli and A. Torrens, “Hájek basic fuzzy logic and Lukasiewicz infinite-valued logic,”
Arch. Math. Log., 42, pp. 361–370, 2003.
[243] J.M. Font, A.J. Gil, A. Torrens, and V. Verdu, “On the infinite-valued Lukasiewicz logic that
preserves degrees of truth,” Arch. Math. Log., 45(7), pp. 839–868, 2006.
[244] A.J. Rodriguez, “Un estudio algebraico del calculo proposicional de lukasiewicz,” Ph.D.
Dissertation, Universitat de Barcelona, 1980.
[245] W. Blok and D. Pigozzi, “Algebraizable logics,” Mem. Amer. Math. Soc. 396. Providence:
A.M.S, 1989.
[246] M. Gehrke, C. Walker, and E. Walker, “De morgan systems on the unit interval,” Int. J. Intell.
Syst., 11, pp. 733–750, 1996.
[247] M. Gehrke, C. Walker, and E. Walker, “Fuzzy logics arising from strict De Morgan systems,”
In Topological and Algebraic Structures in Fuzzy Sets: A Handbook of Recent Developments
in the Mathematics of Fuzzy Sets, S.E. Rodabaugh and E.P. Klement (Eds.), Springer,
pp. 280–281, 2003.
[248] T.S. Blyth and J.C. Varlet, “Ockham algebras,” Oxford University Press, 1994.
[249] A. Bialynicki-Birula and H. Rasiowa, “On the representation of quasi-Boolean algebras,” Bull.
Polish Acad. Sci., Cl. III, 5, pp. 159–261, 1957.
[250] J.Y. Béziau, “A history of truth-values,” In Logic: A History of its Central Concepts, D.M.
Gabbay, F.J. Pelletier and J. Woods (Eds.), North Holland, pp. 280–281, 2012.
[251]
H. Rasiowa, “An algebraic approach to non-classical logics,” Amsterdam: North-Holland Co.,
1974.
[252] M. Dunn, “A relational representation of quasi-Boolean algebras,” Notre Dame J. Form. Log.,
23(4), pp. 353–357, 1982.
[253] R. Balbes and P. Dwinger, “Distributive lattices,” Abstract Space Publishing, 2011.
[254] A. Anderson and N. Belnap, “Entailment: the logic of relevance and necessity,” Princeton, NY:
Princeton University Press, 1975.
[255]
O. Arieli and A. Avron, “Reasoning with logical bilattices,” J. Log. Lang. Inf., 5, pp. 25–63,
1996.
[256] F. Bou and U. Rivieccio, “The logic of distributive bilattices,” Log. J. IGPL, 19(1), pp. 183–216,
2011.
[257] A. Saha, J. Sen, and M.K. Chakraborty, “Algebraic structures in the vicinity of pre-rough
algebra and their logics,” Inf. Sci., 282, pp. 296–320, 2014.
[258] J.M. Font, “Belnap’s four-valued logic and De Morgan lattices,” Log. J. IGPL, 5(3),
pp. 413–440, 1997.
[259] H. Aoyama, “LK, LJ, dual intuitionistic logic, and quantum logic,” Notre Dame J. Form. Log.,
45(4), pp. 193–213, 2004.
[260] A. Brunner and W. Carnielli, “Anti-intuitionism and paraconsistency,” J. Appl. Log., 3(1),
pp. 161–184, 2005.
[261] W. Carnielli, M.E. Coniglio, and J. Marcos, “Logics of Formal Inconsistency,” In Handbook of
Philosophical Logic 14, 2nd edition, D. Gabbay and F. Guenthner (Eds.), Kluwer Academic
Publishers, pp. 1–93, 2006. Available at http://wslc.math.ist.utl.pt/ftp/pub/MarcosJ/03-
CCM-lfi.pdf.
[262] I. Urbas, “Dual-intuitionistic logic,” Notre Dame J. Form. Log., 37(3), pp. 440–451, 1996.
[263] C. Rauszer, “Applications of Kripke models to Hayting-Brouwer logic,” Stud. Log., 34,
pp. 61–71, 1977.
[264] K. Popper, “The logic of scientific discovery,” English translation of Logik der Forschung,
Vienna: Julius Springer Verlag, 1936.

506
|
Bibliography
[265] N.C. A. da Costa, “On the theory of inconsistent formal systems,” Notre Dame J. Form. Log.,
15, pp. 497–510, 1974.
[266] D. Batens, “Dialectical dynamics within formal logics,” Log. Anal., 114, pp. 161–173, 1980.
[267] D. Batens, “A survey of inconsistency-adaptive logics,” In Frontiers in Paraconsistent Logic,
Proc. I World Congress on Paraconsistency, Ghent, pp. 49–73, 2000.
[268] S. Jaskowski, “A propositional calculus for inconsistent deductive systems,” Stud. Soc. Sci.
Torun., Sect. A, 5, pp. 57–71, 1948.
[269] W. Carnielli and J. Marcos, “A Taxonomy of C-Systems,” In Paraconsistency – the Logical Way
to the Inconsistent, W.A. Carnielli, M.E. Coniglio and I.M.L. D’Ottaviano (Eds.), Lecture Notes in
Pure and Applied Mathematics 228. New York: Marcel Dekker, pp. 1–94 2002.
[270] A. Kolmogorov, “On the principle of tertium non datur,” Mat. Sb., 32, 1925. (Traduced in van
Heijenoort, From Frege to Gödel, C.U.P., 414–437, 1967).
[271]
A. Kolmogorov, “Zur dentung der intuitionistischen logik,” Math. Z., 35, pp. 58–65, 1932.
[272] A. Heyting, “Mathematische grundlagenforschung. Intuitionismus, beweistheorie,” Berlin:
Springer, 1934.
[273] K. Gödel, “Zum intuitionistischen aussagenkalkül,” Anz. Akad. Wiss. Wien, 69, pp. 65–66,
1932.
[274] M. Dummett, “A propositional calculus with denumerable matrix,” J. Symb. Log., 27,
pp. 97–106, 1959.
[275] Z. Majkić, “General framework for query answering in Data Quality Cooperative Information
Systems,” In International Workshop on Information Quality in Information Systems (IQIS),
June 18, Paris, France, 2004.
[276] J. Mylopoulos and M.P. Papazoglou, “Cooperative Information Systems (Special Issue),” IEEE
Intell. Syst. Appl., 12(5), 1997.
[277] M. Mecella, M. Scannapieco, A. Virgillito, R. Baldoni, T. Catarci, and C. Batini, “Managing
Data Quality in Cooperative Information Systems,” In Proceedings, Lecture Notes in Computer
Science 2519, Springer, pp. 486–502, 2002.
[278] C. Batini and M. Mecella, “Enabling Italian e-Government Through a Cooperative
Architecture,” IEEE Comput., 34(2), 2001.
[279] Z. Majkić, “From inconsistency to possibility: A unique minimal Herbrand model,” Notes in
http://www.dis.uniroma1.it/~majkic/, 2004.
[280] F. Naumann, U. Leser, and J.C. Freytag, “Quality-driven Integration of Heterogenous
Information Systems,” In Proceedings of 25th International Conference on Very Large Data
Bases (VLDB’99), Edinburgh, Scotland, UK, 1999.
[281] D. Maier, J.D. Ullman, and M.Y. Vardi, “On the foundations of the universal relation model,”
ACM Trans. Database Syst., 9, pp. 283–308, 1984.
[282] P. Bertolazzi, L. De Santis, and M. Scannapieco, “Automatic Record Matching in Cooperative
Information Systems,” In Proceedings of the ICDT’03 International Workshop on Data Quality
in Cooperative Information Systems (DQCIS’03), Siena, Italy, 2003.
[283] V.I. Levenshtein, “Binary codes capable of correcting deletions, insertions and reversals,”
Dokl. Akad. Nauk SSSR, 10(8), 1966.
[284] L.S. Moss, “Coalgebraic logic,” Ann. Pure Appl. Log., 96, pp. 277–317, 1999.
[285] B. Jacobs, “Towards a duality result in coalgebraic modal logic,” In Coalgebraic Methods in
computer science, H. Reichel (Ed.), Elec. Notes in Theor. Comp. Sci. 33, 2000.
[286] B. Jacobs, “Many-sorted coalgebraic modal logic: a model-theoretic study,” Theor. Inform.
Appl., 35(1), pp. 31–59, 2001.
[287] H. Rasiowa and R. Sikorski, “The mathematics of metamathematics,” (3rd edition), Warsaw:
PWN - Polisch Scientific Publishers, 1970.
[288] G. Gentzen, “Über die Existenz unabhängiger Axiomensysteme zu unendlichen
Satzsystemen,” Math. Ann., 107, pp. 329–350, 1932.

Bibliography
|
507
[289] P. Hertz, “Über Axiomensysteme für beliebige Satzsysteme,” Math. Ann., 101, pp. 457–514,
1929.
[290] J. Jipsen and C. Tsinakis, “A survey of residuated lattices,” In Ordered Algebraic Structures, J.
Martinez (Ed.), Kluwer Academic Publishers, pp. 19–56, 2002.
[291]
A. Urquhart, “A topological representation theory for lattices,” Algebra Univers., 8, pp. 45–58,
1978.
[292] C. Brink, D. Gabbay, and H.H. Olhbach, “Towards automating duality,” Technical Repotr
MPI-I-93-220, Max-Planck-Institut fur Informatic, Saarbrucken, Germany, 1993.
[293] M. Haim, “Duality for lattices with operators: a modal logic approach,” http://citeseer.ist.
psu.edu/haim00duality.html, 2000.
[294] S. Celani and R. Jansana, “A new semantics for positive modal logic,” Notre Dame J. Form.
Log., 38, 1997.
[295] J. Dugundji, “Note on a property of matrices for Lewis and Langford’s calculi of propositions,”
J. Symb. Log., 5, pp. 150–151, 1940.
[296] R. Goldblatt, “Metamathematics of modal logic,” Rep. Math. Log., 6, pp. 41–78, 7, pp. 21–52,
1976.
[297] R.A. Bull and K. Segerberg, “Basic modal logic,” In Handbook of Philosophical Logic II, D.
Gabbay and F. Guenther (Eds.), Dodrecht: Reidel, pp. 1–88, 1984.
[298] B. Beckert, R. Hanhle, and F. Manyá, “Transformations between signed and classical clause
logic,” In Proc. 29th Int. Symposium on Multiple-Valued Logics, pp. 248–255, Freiburg,
Germany, 1999.
[299] G. Escalada Imaz and F. Manyá, “The satisfiability problem for multiple-valued Horn
formulae,” In Proc. International Symposium on Multiple-Valued Logics (ISMVL), Boston,
Los Alamitos: IEEE Press, pp. 250–256, 1994.
[300] H.A. Blair and V.S. Subrahmanian, “Paraconsistent logic programming,” Theor. Comput. Sci.,
68, pp. 135–154, 1989.
[301] M. Kifer and V.S. Subrahmanian, “Theory of generalized annotated logic programming and its
applications,” J. Log. Program., 12(4), pp. 335–368, 1992.
[302] C.I. Lewis, “Implication and the algebra of logic,” Mind (New Ser.), 21, pp. 522–531, 1912.
[303] G. Kalmbach, “Orthomodular lattices,” London: Academic Press, 1983.
[304] R. Goldblatt, “Semantic analysis of Orthologic,” J. Philos. Log., pp. 19–35, 1974.
[305] S.A. Kripke, “Semantical analysis of Intuitionistic logic I,” In Formal Systems and Recursive
Functions, J.N. Crossley and M.A. E. Dummett (Eds.), North Holland, pp. 92–130, 1965.
[306] J.C. C. McKinsey and A. Tarski, “Some theorems about the sentential calculi of Lewis and
Langford,” J. Symb. Log., 13, pp. 1–15, 1948.
[307] J.M. Dunn, “Gaggle theory: An abstraction of Galois connections and residuation with
applications to negation and various logical operations,” In JELIA 1990, European Workshop
on Logics and Artificial Intelligence, LNCS 478, Springer, 1991.
[308] D. Nelson, “Negation and separation of concepts in construtive systems,” In Studies in Logic
and the Foundations of Mathematics, Amsterdam: North Holland, pp. 208–225, 1959.
[309] K. Fine, “The justification of negation as failure,” In Logic, Methodology and Philosophy of
Science VIII, Amsterdam: North Holland, pp. 263–301, 1989.
[310] M.C. Fitting, “A Kripke/Kleene semantics for logic programs,” J. Log. Program., 2,
pp. 295–312, 1985.
[311]
K. Kunen, “Negation in logic programming,” J. Log. Program., 4, pp. 289–308, 1987.
[312]
T. Przymusinski, “Every logic program has a natural stratification and an iterated fixed point
model,” In Eighth ACM Symposium on Principles of Databases Systems, pp. 11–21, 1989.
[313]
T. Przymusinski, “Well-founded semantics coincides with thre-valued stable-semantics,”
Fundam. Inform., 13, pp. 445–463, 1990.

508
|
Bibliography
[314] M. Kifer and E.L. Lozinskii, “A logic for reasoning with inconsistency,” J. Autom. Reason., 9(2),
pp. 179–215, 1992.
[315]
M.H. van Emden, “Quantitative deduction and its fixpoint theory,” J. Log. Program., 4(1),
pp. 37–53, 1986.
[316] S. Morishita, “A unified approach to semantics of multi-valued logic programs,” Tech. Report
RT 5006, IBM Tokyo, 1990.
[317]
V.S. Laksmanan and N. Shiri, “A parametric approach to deductive databases with
uncertainty,” IEEE Trans. Knowl. Data Eng., 13(4), pp. 554–570, 2001.
[318] Z. Majkić, “Logic methods for many-valued logics: Higher-order autoepistemic language
concepts,” In 4th Indian International Conference on Artificial Intelligence (IICAI-09),
Bangalore, India, December, 2009.
[319]
M.C. Fitting, “Bilattices are nice things,” In Proceedings of Conference on Self-Reference,
Copenhagen, Denmark, 2002.
[320] M. Zemankova and A. Kandel, “Implementing imprecision in information systems,” Inf. Sci.,
37, pp. 107–141, 1985.
[321]
D. Dubois and H. Prade, “Handling incomplete of uncertain data and vague queries in
database applications,” In Possibility Theory: An Approach to Computerized Processing of
Uncertainty 6, New York and London: Plenum Press, pp. 217–257, 1989.
[322] M. Kifer and A. Li, “On the semantics of rule-based expert systems with uncertainty,” In
2nd Intl. Conference on Database Theory, LNCS 326, Bruges, Belgium: Spinger Verlag,
pp. 102–117, 1988.
[323] V.S. Lakshmanan, N. Leone, R. Ross, and V.S. Subrahmanian, “A flexible probabilistic
database system,” ACM Trans. Database Syst., pp. 419–469, 1997.
[324] V.S. Lakshmanan and F. Sadri, “On a theory of probabilistic deductive databases,” CoRR cs.
DB/0312043, 2003.
[325] G. Boole, “The laws of thought,” London: Macmillan, 1884.
[326] T. Hailperin, “Best possible inequalities for the probability of a logical function of events,”
Am. Math. Mon., 72, pp. 343–359, 1965.
[327] G. Georgakopoulos, D. Kavvadias, and C.H. Papadimitriou, “Probabilistic satisfiability,” J.
Complex., 4, pp. 1–11, 1988.
[328] J.E. Fenstad, “The structure of probabilities defined on first-order languages,” In Studies in
inductive logic and probabilities 2, University of California Press, pp. 251–262, 1980.
[329] P. Walley, “Statistical reasoning with imprecise probabilities,” Chapman and Hall, 1991.
[330] L.M. de Campos, J.F. Huete, and S. Moral, “Probability intervals: A tool for uncertain
reasoning,” Int. J. Uncertain. Fuzziness Knowl.-Based Syst., 2(2), pp. 167–196, 1994.
[331]
K. Weichselberger, “The theory of interval-probability as a unifying concept for uncertainty,”
In Proc. 1st Int. Symp. on Imprecise Probabilities and Their Applications, 1999.
[332] M. Dekhtyar, A. Dekhtyar, and V.S. Subrahmanian, “Hybrid probabilistic programs:
Algorithms and complexity,” In UAI 1999, pp. 160–169, 1999.
[333] A. Dekhtyar and V.S. Subrahmanian, “Hybrid probabilistic programs,” J. Log. Program., 43(3),
pp. 187–250, 2000.
[334] M. Dekhtyar, A. Dekhtyar, and V.S. Subrahmanian, “Temporal probabilistic logic programs,”
In ICLP 99, Las Cruces, USA, pp. 109–123, 1999.
[335] M. Dekhtyar and A. Dekhtyar, “Revisiting the semantics of interval probabilistic logic
programs,” In LPNMR 2005, September 5–8, Diamante, Cosenza, Italy, pp. 330–342, 2005.
[336] R. Suszko, “Remarks on Lukasiewicz’s three-valued logic,” Bull. Sect. Log., 4, pp. 87–90,
1975.
[337] D. Batens, “A bridge between two-valued and many-valued semantic systems: n-tuple
semantics,” In Proc. of the XII ISMVL, pp. 318–322, 1982.

Bibliography
|
509
[338] D. Scott, “Completeness and axiomatizability in many-valued logic,” In Proc. of Tarski
Symposium, Proc. of Symposia in Pure Mathematics 25, pp. 411–436, 1974.
[339] N.C. A. da Costa, J.Y. Béziau, and O.A. S. Bueno, “Malinowski and Suszko on
many-valuedness: on the reduction of many-valuedness to two-valuedness,” Mod. Log., 6,
pp. 272–299, 1996.
[340] C. Caleiro, W.A. Carnielli, M.E. Coniglio, and J. Marcos, “Two’s company: The humbug of many
logical values,” In Logica Universalis, J.Y. Béziau (Ed.), Birkhauser Verlag, pp. 169–189, 2005.
[341]
Z. Majkić, “Two-valued encapsulation of many-valued logic programming,” Technical Report,
University ‘La Sapienza’, Roma, http://www.dis.uniroma1.it/~majkic/, 2003.
[342] Z. Majkić, “Truth and knowledge fixpoint semantics for many-valued logic programming,”
In 19th Workshop on (Constraint) Logic Programming (W(C)LP 2005), February 21–25, Ulm,
Germany, 2005.
[343] R. Routley and R.K. Meyer, “Semantics of entailment I,” In Truth Syntax and Modality, H.
Leblanc (Ed.), Amsterdam: North-Holland, pp. 199–243, 1973.
[344] Z. Majkić and B. Prasad, “Binary sequent calculi for finite many-valued logics,” In 5th Indian
International Conference on Artificial Intelligence (IICAI-11), India, December, 2011.
[345] M. Baaz, C.G. Fermüller, and R. Zach, “Systematic construction of natural deduction systems
for many-valued logics,” In 23rd Int. Syp. on Multiple Valued Logic, pp. 208–213, 1993.
[346] R. Suszko, “The Fregean axiom and polish mathematical logic in the 1920s,” Stud. Log., 36,
pp. 377–380, 1977.
[347] G. Malinowski, “Many-valued logics,” Oxford Logic Guides 25. Oxford: Clarendon Press, 1993.
[348] G. Malinowski, “Inferential many-valuedness,” In Philosophical Logic in Poland, J. Wolenski
(Ed.), Dodrecht: Kluwer Academic Publishers, pp. 75–84, 1994.
[349] J. Kotas and N.C. A. da Costa, “Some problems on logical matrices and valorizations,” In Proc.
of the 3rd Brazilian Conference on Mathematical Logic, pp. 131–145, 1980.
[350] A.Y. Halevy, Z.G. Ives, J. Madhavan, P. Mork, D. Suciu, and I. Tatarinov, “The Piazza peer data
management system,” IEEE Trans. Knowl. Data Eng., 16(7), pp. 787–798, 2004.
[351]
A. Fuxman, P.G. Kolaitis, R. Miller, and W.C. Tan, “Peer data exchange,” ACM TODS, 31(4),
pp. 1454–1498, 2006.
[352] M.A. V. Salles, J.P. Dittrich, S.K. Karakashian, O.R. Girard, and L. Blunschi, “iTrial:
Pay-as-you-go information integration in dataspaces,” In Proc. of VLDB, Vienna, Austria,
pp. 663–674, 2007.
[353] P. Bernstein, A. Halevy, and R. Pottinger, “A vision for management of complx models,”
SIGMOD Rec., 29(4), pp. 55–63, 2000.
[354] R. Goldblat, “Topoi: the categorial analysis of logic,” Amsterdam: North-Holland, 1979.
[355]
G. Rosolini, “Continuity and effectiveness in Topoi,” Ph.D. dissertation, Oxford University,
Also preprint, Department of Computer Science, Carnegie-Mellon University, 1986.
[356] S. Abiteboul, R. Hull, and V. Vianu, “Foundations of Databases,” Reading, Massachusetts:
Addison Wesley Publ. Co., 1995.
[357] Z. Diskin, “Generalized sketches as an algebraic graph-based framework for semantic
modeling and database design,” Laboratory for Database Design, FIS/LDBD-97-03, 1997.
[358] M. Makkai, “Generalized sketches as a framework for completeness theorems,” Technical
report, McGill University, 1994.
[359] Z. Majkić, “Algebraic operators for matching and merging of relational databases,” In
International Conference in Artificial Intelligence and Pattern Recognition (AIPR-09), Orlando
FL, USA, July 13–16, 2009.
[360] Z. Majkić, “Induction principle in relational database category,” In Int. Conference on
Theoretical and Mathematical Foundations of Computer Science (TMFCS-09), Orlando FL,
USA, July 13–16, 2009.

510
|
Bibliography
[361] Z. Majkić, “DB category: Denotational semantics for view-based database mappings,”
arXiv:1103.0217v1, pp. 1–40, 2011.
[362] Z. Majkić, “Matching, merging and structural properties of data base category,”
arXiv:1102.2395v1, pp. 1–27, 2011.
[363] Z. Majkić, “Abstract database category based on relational-query observations,” In
International Conference on Theoretical and Mathematical Foundations of Computer Science
(TMFCS-08), Orlando FL, USA, July 7–9, 2008.
[364] P. Buneman, S. Davidson, and A. Kosky, “Theoretical aspects of schema merging,” In EDBT
1992, pp. 152–167, 1992.
[365] J.R. Büchi, “Weak second-order arithmetic and finite automata,” Z. Math. Logic Grundl. Math.,
6, pp. 66–92, 1960.
[366] G. Gotlob and C. Koch, “Monadic datalog and the expressive power of languages for web
information extraction,” J. ACM, 51, pp. 74–113, 2004.
[367] A. Corradini, “A complete calculus for equational deduction in coalgebraic specification,”
Report SEN-R9723, National Research Institute for Mathematics and Computer Science,
Amsterdam, 1997.
[368] D. McLeod and D. Heimbigner, “A Federated architecture for information management,” ACM
Trans. Inf. Syst., 3(3), pp. 253–278, 1985.
[369] A. Sheth and J. Larsen, “Federated database systems for managing distributed,
heterogenuous and autonomous databases,” ACM Comput. Surv., 22(3), pp. 183–236, 1990.
[370] A. Calì, D. Calvanese, G. De Giacomo, and M. Lenzerini, “Reasoning in data integration
systems: why LAV and GAV are siblings,” In Proceedings of the 14th International Symposium
on Methodologies for Intelligent Systems, ISMIS 2003 2871, Springer, pp. 282–289, 2003.
[371]
R. Fagin, “Inverting schema mappings,” ACM TODS, 32(4), pp. 25–78, 2005.
[372] A. Kementsietsidis, M. Arenas, and R.J. Miller, “Mapping data in peer-to-peer systems:
Semantics and alghotitmic issues,” In Proc. of SIGMOD, 2003.
[373] S. Davidson, P. Buneman, and A. Kosky, “Semantics of database transformations,” In
Semantics in Databases, B. Thalheim and L. Libkin (Eds.), LNCS 1358, pp. 55–91, 1998.
[374] R. Miller, L. Haas, and M. Hernandez, “Schema mapping as query discovery,” In Proc. VLDB,
pp. 77–88, 2000.
[375] Z. Majkić, “The category-theoretic semantics for database mappings,” Technical Report
14-03, University ‘La Sapienza’, Roma, Italy, 2003.
[376] J. Madhavan, P.A. Bernstein, P. Domingos, and A.Y. Halevy, “Representing and reasoning
about mappings between domain models,” In AAAI/IAAI, pp. 80–86, 2002.
[377] D. Beneventano, M. Lenzerini, F. Mandreoli, and Z. Majkić, “Techniques for query
reformulation, query merging, and information reconciliation-part A,” In Semantic Webs and
Agents in Integrated Economies, D3.2.A, IST-2001-34825, 2003.
[378] I. Zaihrayeu, “Query answering in peer-to-peer database networks,” Technical Report
DIT-03-012, University of Trento, Italy, 2003.
[379] R. Fagin, “Horn clauses and database dependencies,” J. ACM, 29, pp. 952–985, 1982.
[380] J. Madhavn and A. Halevy, “Composing mappings among data sources,” In Proc. of VLDB,
pp. 572–583, 2003.
[381] S. Melnik, P.A. Bernstein, A. Halevy, and E. Rahm, “Supporting executable mapping in model
management,” In SIGMOD, pp. 167–178, 2005.
[382] A. Nash, P. Bernstein, and S. Melnik, “Composition of mappings given by embedded
dependencies,” In Proc. of PODS, pp. 172–183, 2005.
[383] R. Fagin, P.G. Kolaitis, L. Popa, and W. Tan, “Quasy-inverses of schema mappings,” ACM
TODS, 33(2), pp. 1–52, 2008.
[384] P.J. Freyd and G.M. Kelly, “Categories of continuous functors, I,” J. Pure Appl. Algebra, 2,
pp. 169–191, 1972.

Bibliography
|
511
[385] D.S. Johnson and A.C. Klug, “Testing containment of conjunctive queries under functional and
inclusion dependencies,” J. Comput. Syst. Sci., 28, pp. 167–189, 1984.
[386] R. Reiter, “On closed world databases,” In Logic and Databases, H. Gallaire and J. Minker
(Eds.), New York: Plenul Press, pp. 55–76, 1978.
[387] R.J. Brachman and H.J. Levesque, editors. “Readings in Knowledge Representation,” 1985.


Index
3-D parsing of RDBs 180
Abstract Object Types (AOT) 139, 166, 374, 375,
476
action-relational SQL algebra 177
Aczel’s final coalgebra semantics 157
algebraic lattice 381
algebraic satisfaction relation 259, 265
autoreferential Kripke semantics 262, 264, 270,
276, 278, 284, 388, 396, 398, 411, 414, 416
Basic fuzzy Logic 323
Bealer–Montague relationship 18
Belnap’s bilattice 279, 316, 359, 363, 366, 373,
401, 408, 413
Bikhoff polarity 349
Birkhoff-based isomorphism 270
canonical representation of algebras 272
Cartesian Closed Category (CCC) 469, 476
categorial symmetry 470
Clasic Propositional Logic (CPL) 6, 27, 93, 98,
264, 332, 343–345, 385
closure operator 241, 383, 387, 397
coalgebraic semantics 140, 476
comonad 468
complete lattice 381
congruence relation 384
Constraint Logic Programming 72
Constratint Databases 72
Data Integration System (DIS) 488
Database management system (DBMS) 173,
176, 203, 206, 230, 478
DB skethes and functorial semantics 232, 238
denotational semantics 108, 230, 257, 380, 468
embedded implication dependencies (EID) 483
equality generating dependency (egd) 234, 483
final coalgebraic semantics for query-answering
170
First-Order Logic (FOL) 2, 8, 45, 189, 192, 479,
483, 484
FOL extensional algebra 15
FOL syntax algebra 16
Frege/Russel semantics 1, 41, 306
Galois algebra 83, 407, 420
Galois connection 134, 274, 349, 397, 414, 420,
467
global-and-local-as-view (GLAV) 108, 132, 232,
369, 474, 483
Heyting algebra 83, 276, 284, 348, 351, 382,
405, 406, 413
hidden quantifiers 69
higher-order Herbrand model 67, 105, 427
homomorphism of algebras 16, 17, 42, 53, 78,
157, 272, 280, 297, 305, 377, 383, 472,
478, 493
in-memory H-store DBMS 176
information flux 237
initial algebra 384
integrity constraints 133, 178, 186, 233, 478,
483, 488
intensional abstraction 10, 47, 86, 98, 100, 107,
114
intensional algebra for Description Logic 296
intensional bridge rules 150
intensional equality 45
intensional equivalence 38, 55, 129, 144, 151,
301, 367
intensional FOL algebra 40
intensional FOL quotient algebra 145
Intensional Many-valued FOL 298
Intensional RDB with multivalued attributes 218
intensional RDBMS 173
intensional Tarski’s constraints 19
Intuitionistic Logic (IL) 281, 323, 341, 348, 351,
356, 361, 385, 405, 414
IRDB Data integration 239
key/value open schema Database 182
Kleisli category 232, 251, 252, 254, 477
Kleisli semantics for IRDBs 231, 248
Knaster–Tarski fixpoints 382
Kolmogorov axioms 93
Konolige’s bridge rules 148
Kripke semantics of FOL 24
Labelled Deduction System (LDS) 149
Liar formula resolution 314
Lindenbaum-Tarski algebra 480
https://doi.org/10.1515/9783110981438-009

514
|
Index
many-valued Montague’s intension 308
many-valuedness and concept-algebra 304
mapping-interpretations 236, 237, 487
minimal intensional FOL 34
model-based entailment 309
monad 230, 248, 251, 252, 257, 468
monoidal category 468
Montague’s intension representation 8
MultiValue databases 216
mZ relevant Belnap’s logic 359
mZ relevant Gödel–-Dummett logic 362
mZ relevant Zadeh-fuzzy logic 360
new representation assumption 264
NewSQL Big Data query rewriting 188
NewSQL IRDBs 222
Nilsson’s probabilistic structure 93, 96, 100
non-omniscient contextual reasoning 147
NoSQL Big Data 177
operads 236, 238, 239, 485
peer-to-peer (P2P) 118, 122, 165, 169, 171, 293,
316, 363, 367, 377, 475, 482
plausible query-answering non-monotonic
inference 133
power-view operator 239, 249, 257, 476, 477,
480, 482
predicate compression 68, 74, 80
Probabilistic Logic Programs 103
PRP theory 12
query rewriting 139, 174
query rewriting coalgebra 161
quotient algebra 258, 384
RDF and OWL 109
reification 12, 47, 61, 95, 98, 109, 229, 257
Relational Database (RDB) 478
relevant da Costa subintuitionistic mZ logic 346
relevant infinitary Lukasiewicz’s logic 333
relevant Orlov’s logic 317
representation assumption 260
representation theorem non matrix-based 267
saturation of morphisms 243
SchemaLog with IRDB interoperability 204
Second Order tgd (SOtgd) 232
Select-Project-Rename-Join-Union (SPRJU)
algbra 179, 249, 480
Semantic WEB 109, 124
signature of algebra 383, 471
Tarski’s interpretations 4, 16, 28, 484, 487
Temporal Probabilistic Database 105
truth-preserving entailment 261
tuple generating dependency (tgd) 233, 474,
483, 484
two-step intensional semantics 17, 38, 44, 311
virtual predicates 14, 73, 74, 142, 367
weak intensional inference 155, 157
Weak monoidal Topos 232, 477
wrappers 139

