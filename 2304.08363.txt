A ZX-Calculus Approach to Concatenated Graph Codes
Zipeng Wu,1 Song Cheng,2, ∗and Bei Zeng1
1Department of Physics, Hong Kong University of Science and Technology
2Yanqi Lake Beijing Institute of Mathematical Sciences and Applications
(Dated: April 18, 2023)
Quantum Error-Correcting Codes (QECCs) are vital for ensuring the reliability of quantum computing and
quantum communication systems. Among QECCs, stabilizer codes, particularly graph codes, have attracted
considerable attention due to their unique properties and potential applications. Concatenated codes, which
combine multiple layers of quantum codes, offer a powerful technique for achieving high levels of error cor-
rection with a relatively low resource overhead. In this paper, we examine the concatenation of graph codes
using the powerful and versatile graphical language of ZX-calculus. We establish a correspondence between
the encoding map and ZX-diagrams, and provide a simple proof of the equivalence between encoding maps in
the Pauli X basis and the graphic operation “generalized local complementation" (GLC) as previously demon-
strated in [J. Math. Phys. 52, 022201]. Our analysis reveals that the resulting concatenated code remains a
graph code only when the encoding qubits of the same inner code are not directly connected. When they are
directly connected, additional Clifford operations are necessary to transform the concatenated code into a graph
code, thus generalizing the results in [J. Math. Phys. 52, 022201]. We further explore concatenated graph codes
in different bases, including the examination of holographic codes as concatenated graph codes. Our ﬁndings
showcase the potential of ZX-calculus in advancing the ﬁeld of quantum error correction.
I.
INTRODUCTION
Quantum Error-Correcting Codes (QECCs) play a crucial role in the advancement of quantum computing and quantum com-
munication systems. Due to the inherently fragile nature of quantum information, it is highly susceptible to errors arising from
environmental noise, imperfect quantum gates, and measurement inaccuracies. These errors can lead to signiﬁcant losses in
computational accuracy and jeopardize the overall performance of quantum systems. To counteract these issues, QECCs have
been developed to detect and correct errors without disturbing the delicate quantum states, thus safeguarding the integrity of
quantum information and enabling the realization of fault-tolerant quantum computing [1].
Stabilizer codes are prominent families of QECCs that have garnered considerable attention due to their unique properties
and potential applications. Stabilizer codes a re a generalization of additive classical codes to the quantum domain. They are
characterized by a set of stabilizer operators, which preserve the encoded quantum state and provide a framework for efﬁciently
detecting and correcting errors [2, 3]. Graph codes, a subclass of stabilizer codes, utilize graph states to represent codewords,
where each vertex corresponds to a qubit, and edges represent entangling operations [4–9]. The graph structure provides an
intuitive way of visualizing the quantum state and its interactions, making these codes particularly appealing for constructing
quantum codes with desirable error-correcting capabilities [10–12]. Additionally, every graph code is local Clifford equivalent
to a stabilizer code, which means that they can be transformed into each other through local Clifford operations [13–15]. In
general a graph code can be represented by an encoding circuit as shown in FIG. 1.
...
U
Encoded
by CZ
...
G
...
...
H
H
...
|0⟩
|0⟩
...
k

)
n
FIG. 1: Encoding circuit for graph code: k qubits are encoded into n qubits; the k qubits are input in the computational basis,
followed by some k-qubit unitary U that is a change of basis; G is the encoding circuit for the corresponding graph state of the
graph code; “Encoded by CZ” encodes the k qubits into n-qubit graph code by some controlled-Z (CZ gates).
∗Electronic address: chengsong@bimsa.cn
arXiv:2304.08363v1  [quant-ph]  17 Apr 2023

2
Concatenated quantum codes provide an important avenue for achieving high levels of error correction in quantum systems.
By combining multiple layers of quantum codes, concatenated codes can achieve exponential improvements in error-correction
performance with only a polynomial increase in resource overhead. This powerful technique enhances the resilience of quantum
information against errors and is essential for the development of large-scale, fault-tolerant quantum computers [16–20]. Fur-
thermore, the versatility of concatenated codes allows for the integration of various types of QECCs, such as stabilizer codes
and graph codes, leading to novel hybrid constructions that can leverage the advantages of each constituent code to optimize
error-correcting capabilities [21, 21]. Encoding circuit for a concatenated code is illustrated in FIG. 2.
...
...
U
Encoded
by CZ
H
H
|0⟩
|0⟩
U ′
H
|0⟩
...
...
...
...
...
G
...
...
...
...
H
|0⟩
...
...
G’
...
Encoded
by CZ
FIG. 2: Encoding circuit for concatenated code: some qubits of the outer code (ﬁrst layer of encoding on the left) are encoded
into a inner code (second layer of encoding on the right), which is a graph code associated with graph G′, with the Clifford
operation U ′ that changes the basis of the encoded outer code qubits.
In [22], a graphical method was developed for concatenating graph codes. The main results of [22] can be summarized as
follows:
I1. For connected codes, the basis change map U ′ given by applying Hadamard H to each encoding qubit of the inner code
(i.e. encoding in the Pauli X basis) is equivalent to a graphical operation known as “generalized local complementation"
(GLC).
I2. When a GLC is applied to every encoding qubit of the inner code, the resulting concatenated code remains a graph code.
The primary advantage of this method lies in the ability to analyze code concatenation through a purely graphical approach.
However, several questions remain unresolved, including:
Q1. While the resulting concatenated code remains a graph code and can be obtained from the graphical operation GLC, the
proof can only be provided using an algebraic method.
Q2. The graphical method cannot be employed to analyze concatenation in any other basis (i.e. other choices of U ′), as the
resulting concatenated code is not a graph code. Instead, it is a stabilizer code that requires certain Clifford operations to
be transformed into a graph code.
ZX-calculus is a powerful and versatile graphical language for reasoning about and manipulating quantum states, particularly
within the context of graph codes [23–25]. Rooted in category theory principles, ZX-calculus uses a compact set of rules and
graphical elements called ZX-diagrams to represent and manipulate quantum operations and states. In the domain of graph
codes, ZX-diagrams offer an intuitive and visually appealing means of illustrating the underlying graph structure, where vertices
represent qubits and edges indicate entangling operations. Applying the rules of ZX-calculus enables efﬁcient transformations
and simpliﬁcations of ZX-diagrams, which can assist in the analysis, optimization, and synthesis of graph codes. This graphical
approach not only facilitates understanding complex quantum operations but also promotes the development of innovative error-
correcting codes by exploring the rich combinatorial structures of graphs. Consequently, the integration of ZX-calculus and
graph codes shows immense potential for advancing quantum error correction, ultimately leading to more efﬁcient and robust
quantum computing and communication systems.
The adaptability and ﬂexibility of ZX-diagrams in handling stabilizer states and graph states suggest that they could be an
effective tool for analyzing graph code concatenation. In this work, we apply ZX-calculus to examine the concatenation of graph

3
codes. By establishing a correspondence between the encoding map and ZX-diagrams, we offer a straightforward proof of I1
using ZX-rules, providing a purely graphical method to address Q1. Upon further investigation, we ﬁnd that I2 does not always
hold; it is only valid when the encoding qubits of the inner code are not directly connected. When the encoding qubits are directly
connected, additional Clifford operations are needed to transform the resulting concatenated code into a graph code. We then
expand our analysis by utilizing ZX-diagrams to study concatenated graph codes for different Us (as answers for Q2), including
the examination of holographic codes as concatenated graph codes. This approach illustrates the potential of ZX-calculus in
driving the ﬁeld of quantum error correction and enabling more efﬁcient and resilient quantum computing and communication
systems.
II.
PRELIMINARIES
In this section, we present an overview of the preliminary concepts related to graph states, graph codes, and ZX-calculus,
which will serve as the foundation for the subsequent parts of the paper.
A.
Graph states and graph codes
Qubits are two-level quantum systems represented by the basis |0⟩, |1⟩. The Pauli matrices X and Z are deﬁned as X|0⟩=
|1⟩, X|1⟩= |0⟩, and Z|0⟩= |0⟩, Z|1⟩= −|1⟩. The Pauli group, generated by the Pauli matrices X and Z, consists of all
operators of the form ±XaZb, where a, b ∈{0, 1}n. We can represent these operators by the 2-length vector (a|b). Two Pauli
operators commute if their corresponding vectors are orthogonal with respect to the symplectic inner product: (a|b) ∗(a′|b′) =
ab′ −a′b. Now, consider k pairwise commuting Pauli matrices g1, . . . , gk that generate a group without non-trivial multiples
of the identity. These can be diagonalized simultaneously, and their eigenvalues are ±1. Let |ψ⟩be the eigenvector of g1, . . . , gk
with eigenvalues 1. Then, for each i, we have gi|ψ⟩= |ψ⟩. |ψ⟩is the stabilizer state corresponding to the stabilizer group
generated by g1, . . . , gk.
The Clifford group is the normalizer of the Pauli group and is generated by the Hadamard gate, phase gate, and controlled-
NOT gate. Clifford operators are important because they transform stabilizer states into stabilizer states. If |ψ⟩is a stabilizer
state with stabilizer group S and L is a Clifford operator, then L|ψ⟩is also a stabilizer state. Two stabilizer states are called
“local Clifford equivalent” if they can be transformed into each other using local Clifford operators. Local Clifford operators
preserve the entanglement of the states.
For the encoding circuits for graph codes, we need only two Clifford operators. First is the Hadamard gate H|r⟩=
1
√
2(|0⟩+
(−1)r|1⟩). Notice that H = H†, HXH = Z and HZH = X. Hence, H is in the Clifford group. The next operator is a
two-qubit gate which is called controlled-Z and is deﬁned by Cz|r⟩|s⟩= |r⟩Zr|s⟩= (−1)rs|r⟩|s⟩. We have
CzX ⊗IC†
z = X ⊗Z,
CzI ⊗XC†
z = Z ⊗X,
CzZ ⊗IC†
z = Z ⊗I,
CzI ⊗ZC†
z = I ⊗Z,
and thus by deﬁnition Cz is in the Clifford group.
Graph states are a special type of stabilizer states that can be represented by a graph with an adjacency matrix G. They
can be generated using Hadamard and controlled-Z gates. Studying graph states helps us understand stabilizer states since any
stabilizer state is local Clifford equivalent to a graph state. To create a graph state corresponding to a graph with adjacency
matrix G, we prepare n qubits in the state |0⟩, apply the Hadamard gate to each, and then apply controlled-Z gates on qubits
i and j with phase factor (−1)gij. If we have a graph state |ψ⟩G corresponding to a graph G with adjacency matrix G, and we
measure the last qubit in the standard basis, the resulting state (without the measured qubit) is also a graph state. The new graph
state corresponds to the original graph G with the last vertex removed.
A [[n, k, d]] graph code encodes k qubits into n qubits using a graph state |ψ⟩G. To encode a state like H ⊗· · ·⊗H|r1 . . . rk⟩,
we ﬁrst ﬁnd the classical codeword α in the linear code C, which is a subspace of Fn
2. We can represent C by k basis vectors
α1, . . . , αk. The state is then encoded into Zr1α1+···+rkαk|ψ⟩G. The encoding circuit for a [[n, k, d]] graph code can be given
as in the procedure below.
Procedure 1. Encoding circuit for a graph code, as demonstrated in FIG. 1.
1. Generate the graph state |ψ⟩G with the encoding circuit G.
2. Apply the gate U to the ﬁrst k qubits that we want to encode.

4
3. For each pair of qubits: qi of the encoding qubits and the j-th qubit of |ψ⟩G, apply a controlled-Z gate with phase factor
αij, where αij is the j-th coordinate of the basis vector αi.
4. Apply the Hadamard gate H to the ﬁrst k qubits.
5. Measure the ﬁrst k qubits in the computational basis.
B.
ZX-calculus
In this section, we present a brief introduction to the ZX-calculus, a graphical language and powerful mathematical framework
for representing and reasoning about quantum circuits and linear maps between qubits. For a comprehensive understanding, see
e.g. Ref. [25]. ZX-calculus provides a diagrammatic notation for quantum states and operations, making it an invaluable tool for
the manipulation, optimization, and simpliﬁcation of quantum circuits.
Quantum computations in ZX calculus are represented as ZX-diagrams, consisting of two types of nodes: Z nodes (or Z
spiders) and X nodes (or X spiders). Nodes are connected by edges that represent quantum entanglement or linear maps between
the nodes. The linear maps corresponding to Z and X spiders can be explicitly written in Dirac notation, as illustrated in FIG. 3.
α
...
...
:= |0...0⟩⟨0...0| + eiα|1...1⟩⟨1...1|
...
...
:=
α
| + ...+⟩⟨+... + | + eiα| −...−⟩⟨−... −|
FIG. 3: Deﬁnition of Z spider and X spider. Z spiders are represented by white nodes and X spiders are represented by grey
nodes within this paper.
Another crucial element in ZX-calculus is the Hadamard gate, which is often represented by a white square or dashed line for
simplicity, as demonstrated in FIG. 4. We will also give the ZX-diagram of controlled-Z gate without proof.
CZ =
:=
FIG. 4: Representation of Hadamard gate and controlled-Z gate. The dashed line and white box both represent Hadamard gate.
In this paper, our primary focus is on Clifford ZX-diagrams, a special class of ZX-diagrams that represent Clifford circuits.
Clifford circuits are quantum circuits composed exclusively of Clifford gates, which map Pauli operators to other Pauli operators
(for example, Hadamard, CNOT, and Phase gates). Due to their efﬁcient classical simulation algorithms and applications in
quantum error correction, Clifford circuits play a signiﬁcant role in quantum computing.
Clifford ZX-diagrams associate Z and X nodes with phases that are multiples of π/2. These diagrams can be simpliﬁed using
a set of rewrite rules that preserve the semantics of the represented quantum computation. The complete set of rules for Clifford
ZX-diagrams is shown in FIG. 5.
α
β
...
...
...
...
...
α + β
...
...
...
...
=
α
...
...
...
...
α
=
=
π
α
−α
π
π
...
...
α
...
...
=
=
=
=
(f)
(h)
(id)
(hh)
(π)
(b)
(c)
FIG. 5: Basic rules for Clifford ZX-diagrams. These rules hold for all α, β ∈[0, 2π), and due to (h) and (hh) all rules also hold
with the colours interchanged.
We will also frequently use two rules given in FIG. 6. By applying all these rules, we will construct rules for graph code
concatenation.

5
α
β
...
...
α
β
...
...
=
α
. . .
=
. . .
α + π
(a)
(d)
FIG. 6: Two frequently used rules within this paper, as illustrated by Equations (83) and (94) in the work of [25].
III.
FROM ENCODING CIRCUIT TO ZX-DIAGRAMS
In this section we discuss encoding circuit (as given by Procedure 1) with ZX-diagrams. We start from mapping the encoding
circuit as given in FIG. 1 into the form of a ZX-diagram.
...
U
Encoded
by CZ
...
G
...
H
H
...
|0⟩
|0⟩
...
...
U
...
G
...
Connect by Encoding
k

k

)
n
)
n
FIG. 7: Encoding circuit of a graph code (left) as a ZX-digram (right).The encoder encodes k qubits into n qubits.
We have the following observation:
Observation 1. As shown in FIG. 7, for any encoding circuit of the left, we can map it into into a ZX-graph as the right. Here
U is some Clifford operation and G is a graph encoder for the left and a “graph state" as in ZX-calculus. The encoder encodes
k qubits into n qubits.
Notice that this has some connections to [26], but not used for the same purpose. To show that Observation 1 is valid, we
translate the part of “encode by CZ" to ZX-diagram as shown in FIG. 8.
...
U
Encoded
by CZ
...
G
...
H
H
...
|0⟩
|0⟩
...
U
...
G
...
...
...
...
...
Connect by encoding
...
U
...
G
...
...
...
...
Connect by encoding
...
U
...
G
...
...
...
Connect by encoding
...
U
...
G
...
...
...
Connect by encoding
...
U
...
G
...
Connect by Encoding
k

k

)
n
)
n
FIG. 8: Proof of Observation 1: the mapping from encoding circuit to ZX-diagram, procedure goes from top left to bottom
right, by ﬁrst translating the “Encoded by CZ” and measurement part to a ZX-diagram, then apply the ZX-diagram rules.
We will give some concrete examples about how to translate encoding circuit into ZX-diagram.
Example 1. Consider a [[3,1,1]] stabilizer code, its encoding circuit is shown in FIG.9. By Observation 1, we ﬁrst connect
qubit 1, 2, 3 by graph and then encode q0 with 1, 2, 3 with CZ.
Example 2. Consider a graph code with three input and three output, as shown in FIG. 10.
In this case we have the U given by
U = CZ01CZ15CZ05

6
H
H
H
|q0⟩
|0⟩
|0⟩
|0⟩
H
H
1
2
3
1
3
2
=
=
|0⟩
FIG. 9: Figure of Example 1: Encoding circuit for [[3, 1, 1]] stabilizer code can be translated into ZX-diagram according to
Observation 1.
0
1
2
3
4
5
0
1
2
3
4
5
H
H
H
|q0⟩
|q1⟩
|q2⟩
|0⟩
|0⟩
|0⟩
H
H
H
|0⟩
|0⟩
|0⟩
FIG. 10: Figure of Example 2: A graph code with three input and three output. The ZX-diagram and corresponding encoding
circuit.
Based on Observation 1, concatenated graph code by concatenating the encoding circuit (as illustrated in FIG.2) will corre-
sponds to the connecting the ZX-graphs on the right. We demonstrate this with the following example.
Example 3. Concatenation of two ﬁve-qubit codes, as shown in FIG. 11.
A
2
3
α
β
1
B
4
5
6
γ′
α′
A
1
3
β
α
2
H
H
H
|q0⟩
|0⟩
|0⟩
|0⟩
|0⟩
|0⟩
H
H
5
6
γ′
4
H
H
H
|0⟩
|0⟩
|0⟩
|0⟩
H
B |q1⟩
H
H
H
|0⟩
|0⟩
|0⟩
FIG. 11: Figure of Example 3: ZX-diagram and encoding circuit for concatenation of two pentagon codes. The output qubit α
of the outer code is concatenated with the input qubit α′ of the inner code.
Here we ﬁrst encode A into a graph of 1, 2, 3, α, β, then we identify α with α′ and further encode α and B into 4, 5, 6, γ′. The
encoding circuits is given on the right. For the encoding of α and B into 4, 5, 6, γ′, the corresponding U ′ is given by CZBα.
Once can see the result is the same as if we ﬁrst encode B into 4, 5, 6, α′, γ′, then we identify α with α′ and further encode α′
and A into 1, 2, 3, β.
Notice that, in general, concatenated graph codes are not graph codes. Of course, they are still stabilizer codes that are local
Clifford equivalent to graph codes. It is observed in [22] that for the special case when U ′ is the tensor product of Hadamard on
each encoding qubit of the inner code (for simplicity we call this case U ′ = H), the resulted concatenated graph code remains
a graph code. This is achieved by a graphical operation called “generalized local complementation” on each encoded qubit. We
will look at this case in detail in the next section.

7
IV.
GENERALIZED LOCAL COMPLEMENTATION
The most important ingredient of [22] for constructing concatenated graph code is the operation of “generalized local com-
plementation", as deﬁned below:
Generalized local complementation (GLC): given a graph G, denote the set of adjacent vertices of the vertex i by N(i). Also let
S be another subset of vertices, note that if S = N(i), the GLC would coincide with the deﬁnition of local complementation(LC),
while the chosen S in this paper is disjoint from N(i). A generalized local complementation on i with respect to S is to replace
the bipartite subgraph induced on N(i) ∪S with its complement., as shown in FIG. 12.
N(i)
Si
N(i)
Si
FIG. 12: Generalized local complementation on i with respect to a set Si
We now put the GLC in the context of encoding graphs for concatenated codes. Given a qubit i, we deﬁne the set N(i) to be
all adjacent nodes of i in the outer graph [22], Si to be the set of nodes in the “inner” graph which connected to i by an encoding
mapping. The gray node in the left is the encoder of the inner graph as shown in FIG. 13.
i
encoding map
N(i)
Si
FIG. 13: Encoding map for qubit i, with N(i) the all adjacent nodes of i in the outer graph, Si the set of nodes in the sinner
graph which connected to i by encoding mapping.
i
encoding map
≜
i
FIG. 14: Concatenation encoding map with U ′ = H.

8
The main result of [22] is based on the following observation.
Observation 2. GLC is equivalent to apply the follow concatenation encoding map with U ′ = H, as shown in FIG. 14.
The proof in [22] of this observation is given by algebraic method. Here we prove this observation by ZX-diagrams, as shown
in FIG. 15.
i
N(i)
Si
N(i)
Si
N(i)
Si
N(i)
Si
N(i)
Si
N(i)
Si
FIG. 15: Proof of Observation 2: the equivalence between concatenated encoding with U ′ = H and generalized local
complementation rule.
The last equivalence in FIG. 15 is given by rule (d) in FIG. 6. At the same time, the encoder of oute graph and inner graph
also merged into a uniﬁed encoder.
Remark: GLC can also be understood as a speciﬁc situation of the variational pivot rule in Eq. (103) of [25] with k = j = 0
and N(u) ∩N(v) = ∅, as shown in FIG. 16.
α1
αn
jπ
kπ
βn
β1
γ1
γn
=
α1 + kπ
αn + kπ
γn + jπ
γ1 + jπ
βn + (j + k + 1)π
β1 + (j + k + 1)π
FIG. 16: The variational pivot rule in Eq. (103) of [25] with k = j = 0 and N(u) ∩N(v) = ∅.
Applying the rule shown in FIG. 16 will also lead to the equivalence between concatenated encoding with U ′ = H and
generalized local complementation, as shown in FIG. 17.
We now look at an example.
Example 4. Concatenation of two encoders of Example 1. We start from top-left of FIG. 18 and sequentially apply bialgebra
rule (b), Hadamard rule (h) and fusing rule (f), which lead to the last ﬁgure of graph code.
Two more examples can be found in Appendix (Example 8 and Example 9).
V.
CONCATENATION WITH U ′ = H
In this section, we consider the case where multiple inner codes occur at the same time.

9
u
v
N(i)
Si
u
v
N(i)
Si
N(i)
Si
N(i)
Si
FIG. 17: The equivalence between concatenated encoding with U ′ = H and generalized local complementation, derived from
the variational pivot rule given in FIG. 16.
FIG. 18: Figure for Example 4: Concatenation of two three-qubit graph codes with U ′ = H .One of the output qubits of the
outer code concatenates with the input qubit of the inner code. After ZX-diagram simpliﬁcation, resulting in a graph code is the
same as applying GLC.
The main result of [22] are I1 and I2 as summarized in Section I. In Section III, we used ZX-diagram to show that I1 is
indeed the case. However, by further examine the resulted concatenated codes, it turns out that I2 is is not always the case. To
be more precise, I2 would not hold when qubits in the inner code correspond to multiple encoded qubits of the outer code and
those encoded qubits are connected directly.
A.
Concatenation without loop
As per the deﬁnition of "concatenation without loop," we require that each qubit in the inner code corresponds to a unique
encoded qubit in the outer code.
Observation 3. When outer code and multiple inner codes concatenate without loop, the resulted concatenated code is a graph
code.
G0
u
v
eu
ev
G0
u
v
k1
k1
k2
k2
G1/{k1}
G2/{k2}
k1
k1
k2
k2
G1/{k1}
G1/{k1}
G0
v
ev
k1
k1
k2
k2
G1/{k1}
G1/{k1}
between
N(u)
k1
and
Complementation
Local
G0
k1
k1
k2
k2
G1/{k1}
G1/{k1}
between
N(u)
k1
and
Complementation
Local
between
N(v)
k2
and
Complementation
Local
FIG. 19: Proof of Observation 3: GLC for the general case when concatenation without loop.

10
B.
Loop concatenation without cooperative nodes connected directly
In the case of loop concatenation, one node in the inner code may correspond to several encoded nodes in the outer code.
For clarity, if two encoded nodes have common encoding node in inner codes, we deﬁne these encoded nodes as “cooperative
nodes”.
Let us start from applying the variational pivot rule in FIG. 16, for the case two cooperative nodes didn’t connected directly,
as illustrated in FIG. 20. We require that the encoded white node v does not belong to the adjacent set N(u) of another encoded
white node u, since the pair of cooperative nodes (v, u) share common encoding qubits in the inner code.
u
eu
N(u)
N(eu)
ev
v
u
eu
N(eu)
ev
v
N(u)
N(eu)
ev
v
N(u)
N(ev)
ev
v
N(v)
N(ev)
N(v)
FIG. 20: GLC for the case for cooperative nodes are not connected directly.
Now, we look at the general case where encoded white nodes with common encoding qubits are not directly connected
Observation 4. When all cooperative outer codes are not connected directly, the resulted concatenated code is a graph code.
To show Observation 4 is valid, consider two arbitrary cooperative encoded nodes u and v connected in two inner graphs G1
and G2 through a Hadamard encoder. As shown in FIG. 21, where eµ and eν denote the encoders of nodes µ and ν respectively,
j1 ∈G1 and j2 ∈G2 denote the sets of vertices that are connected to both eµ and eν. k1 denotes the set of vertices that are only
connected to eµ, and k2 denotes the set of vertices that are only connected to eν. Without loss of generality, we can arrange all
k1 ∈G1 and all k2 ∈G2 by redeﬁning G1 and G2, as there is no limitation on the links between G1 and G2.
Our goal is to prove that the loop concatenated code remains a graph state, unless nodes u and v are directly connected.
To do so,we need to remove the nodes u and v, as well as their corresponding encoders eu and ev, from the graph. Then, we
can apply the variational pivot rule in FIG.16. The procedure is illustrated in FIG. 21.
Firstly, we note that the subgraphs G0/N(v) ∪N(u), G1/k1 ∪j1, and G2/k2 ∪j2 are entirely irrelevant to the variational
pivot process, and they will remain unchanged until the end.
Since N(u) ∩N(eu) = ∅, the variational pivot rule will be reduced to the local complementation (LC) operation between
N(u) and k1 ∪j1 ∪j2. The output of the LC operation will be another graph state.
A crucial fact is that v /∈N(u), which prevents node v from connecting to nodes in k1 ∪j1 ∪j2 after the ﬁrst LC operation.
This ensures that the π phase factor does not occur in the next pivot operation. Otherwise, if N(v) ∩N(ev) ∈j1 ∪j2, all nodes
in j1 ∪j2 would receive a π phase according to FIG. 16.
Once v /∈N(u), N(v) ∩N(ev) could only be ∅, so the next pivot rule would also reduce to LC operation, which output graph
state. Thus we removed nodes u, v and their corresponding encoders eu and ev and output a graph state.
We can repeat the above procedure to eliminate another two nonadjacent encoded white nodes.

11
G0
u
v
eu
ev
G0
u
v
k1
k1
k2
k2
j1
j2
G1/{k1 ∪j1}
G2/{k2 ∪j2}
j1
N(u)
u
v
N(v)
G0/{N(v) ∪N(u)}
N(u)
v
N(v)
G0/{N(v) ∪N(u)}
ev
between
N(u)
k1 ∪j1 ∪j2
and
N(u)
N(v)
G0/{N(v) ∪N(u)}
Complementation
between
N(u)
k1 ∪j1 ∪j2
and
between
N(v)
k2 ∪j1 ∪j2
and
Local
Complementation
Local
Complementation
Local
k1
k1
k2
k2
j1
j2
G1/{k1 ∪j1}
G1/{k1 ∪j1}
j1
eu
ev
k1
k1
k2
k2
j1
j2
G1/{k1 ∪j1}
G2/{k2 ∪j2}
j1
k1
k1
k2
k2
j1
j2
G1/{k1 ∪j1}
G2/{k2 ∪j2}
j1
k1
k1
k2
k2
j1
j2
G1/{k1 ∪j1}
G2/{k2 ∪j2}
j1
FIG. 21: Proof of Observation 4: GLC for the general case when the cooperative qubits are not connected directly.
It can also be easily veriﬁed that this is true for n encoded white nodes simultaneously, as long as they are not directly
connected to each other.
In summary, if the encoded white nodes remain nonadjacent to each other, the concatenated code could result in a graph state
after several local complementation operations.
We will also give a simple example here.
Example 5. Loop concatenation without directly connected cooperative nodes. We deliberately construct such concatenation.
There is no edge between cooperative nodes. of inner codes that are used for next level concatenation.
FIG. 22: Figure for Example 5:Concatenation without loop and its steps of simpliﬁcation.
C.
Loop concatenation with cooperative nodes connected directly
When direct edges exist between cooperative qubits, the following observations can be made (referred to as loop concatenation
with directly connected cooperative nodes):
Observation 5. If two cooperative encoded nodes are directly connected, the resulting concatenated code is no longer a graph
code, but is local Clifford equivalent to a graph code.
To show Observation 5 is valid, we use the graphical approach as illustrated in FIG. 23 and FIG. 24. In this case, the common
nodes in inner codes, which are both encoded by u and v, will end up with an extra π phase factor. We provide an example to
further elaborate on loop concatenation with cooperative nodes connected directly.

12
u
v
N(u)
N(v)
u
v
N(v)
N(u)
N(v)
N(u)
B
v
u
C
A
π
π
B
C
π
π
A
FIG. 23: GLC for loop concatenation with cooperative nodes connected directly and steps of simpliﬁcation. Compared with
Fig 20, the cooperative nodes has a edge.
G0
u
v
eu
ev
G0
u
v
k1
k1
k2
k2
j1
j2
G1/{k1 ∪j1}
G2/{k2 ∪j2}
j1
N(u)
u
v
N(v)
G0/{N(v) ∪N(u)}
N(u)
v
N(v)
G0/{N(v) ∪N(u)}
ev
between
N(u)
k1 ∪j1 ∪j2
and
N(u)
N(v)
G0/{N(v) ∪N(u)}
Complementation
between
N(u)
k1 ∪j1 ∪j2
and
between
N(v)
k2 ∪j1 ∪j2
and
Local
Complementation
Local
Complementation
Local
k1
k1
k2
k2
j1
j2
G1/{k1 ∪j1}
G1/{k1 ∪j1}
j1
eu
ev
k1
k1
k2
k2
j1
j2
G1/{k1 ∪j1}
G2/{k2 ∪j2}
j1
k1
k1
k2
k2
j1
j2
G1/{k1 ∪j1}
G2/{k2 ∪j2}
j1
k1
k1
k2
k2
π
π
G1/{k1 ∪j1}
G2/{k2 ∪j2}
π
FIG. 24: GLC for the general case when the cooperative qubits are directly connected by Hadamard edge.
Example 6. Loop concatenation with cooperative nodes connected directly There exists direct edge between cooperative nodes.
One more example can be found in Appendix (Example 10).

13
π
FIG. 25: Figure for Example 6:Loop concatenation with cooperative nodes connected directly and steps of simpliﬁcation.
Compared with Example 5, the cooperative nodes has a edge.
VI.
CONCATENATION WITH U ′ = I
In this section, we discuss the ZX-digram approach for concatenation with U ′ = I
Consider G1 and G2 as two general graph states. We adopt the following notations:
• Node i: the node in G1 which connected to the encoder and G2.
• N(i): the set of i’s adjacent nodes in G1.
• Node j: the node in G2 which be pushed through by hadamard.
• Si/j: the set of i’s adjacent nodes in G2 without the node j.
• W(j): the set of j’s adjacent nodes in G2.
• G2/j: the subgraph of G2 without the node j.
Now we discuss the general procedure of concatenation for U ′ = I.
Procedure 2. As shown in FIG. 26., after several standard procedure of pushing hadamard, the preliminary concatenation
result of two general graphs G1 and G2 for U ′ = I would correspond to :
1. The encoder of G1 is connected to N(i), j and W(j).
2. j is connected through hadamard to N(i) and Si/j.
3. W(j) and Si/j are fully connected by hadamard, at this step.
4. G2/j would be connected to W(j) or Si/j via node k if the same node k is included in W(j) or Si/j.
Now let us merge the same node in G2/j, W(j) and Si/j:
1. For each node k ∈G2/j, if k in both W(j) and Si/j, then add a π phase to k, otherwise unchanged.
2. For each edge (k, l) ∈G2/j, if any of the follow conditions exist, (k, l) keep unchanged:
• k, l ∈W(j) and k, l ∈Si/j.
• k, l /∈W(j) or k, l /∈Si/j.
• k /∈W(j) and k /∈Si/j.
• l /∈W(j) and l /∈Si/j.
otherwise, cancel (k, l).
3. cancel all edges between W(j) and Si/j.
4. Merge each k ∈G2/j with the same node in W(j) or Si/j, cancel all self-edge(in fact, no self-edge would be found, step
3 killed all possible self-edges, step 1 counted the phase already).
We now look at an example.
Example 7. We consider a concatenation with U ′ = I. The resulted graph is no longer a graph code. But we can transform it
into a graph code by pushing one Hadamard to right. The procedure is shown in FIG. 27.
One more example can be found in Appendix (Example 11).

14
N(i)
j
W(j)
Si/j
G2/j
G1
G2
i
j
j
j
FIG. 26: General procedure of concatenation for U ′ = I.
π
π
FIG. 27: Figure for Example 6: Concatenation of [[3,1,1]] stabilizer code with U ′ = I. The resulting code is local Clifford
equivalent to graph code in Fig.18.
VII.
HOLOGRAPHIC CODE AS A CONCATENATED CODE: CONCATENATION WITH ENTANGLING U
Holographic codes are a class of quantum error-correcting codes that draw inspiration from the AdS/CFT holographic duality
in theoretical physics [27, 28]. These codes use encoding isometries to model the radial time evolution in Anti-de Sitter (AdS)
space, mapping logical qudits in the bulk of AdS to physical qudits on the boundary of the corresponding Conformal Field
Theory (CFT). Typically represented by tensor networks associated with a tiling of hyperbolic space, holographic codes protect
against erasure errors on the boundary. The error-correction properties of these codes are often characterized in terms of which
logical operators can be reconstructed after erasures. Speciﬁcally, bulk operators outside the entanglement wedges of the erased
boundary operators can be reconstructed using the remaining boundary operators.
In [29], holographic codes are examined from the perspective of stabilizer codes and graph codes. In this work, we will utilize
the ZX-calculus approach to demonstrate that holographic codes can be viewed as concatenated graph codes. We will use the
example from [29], where 4 bulk qubits are encoded to 12 boundary qubits, and we will apply the following concatenation step:

15
• Encoding qubit A into a ﬁve-qubit graph.
• Encoding qubit α along with qubit B, into qubits 4, 5, 6, and γ′ using some unitary transformation (the encoding circuit is
demonstrated in Example 3).
• Encoding qubit γ′ along with qubit C, into qubits 7, 8, 9, and δ using some unitary transformation.
• Encoding qubits δ, β along with qubit C, into qubits 10, 11, 12, using some unitary transformation, resulting in a fully
encoded holographic code.
We illustrate this procedure in FIG. 29 with U ′ = I. We start from the top left concatenated code and obtain the bottom right
ZX-diagram that is local Clifford equivalent to a graph code.
Upon obtaining the encoding ZX diagram, we can further extract the logical state and its corresponding graph representation.
The logical state |Gopt
000⟩of the encoding circuit, as shown in FIG. 28, is found to be local Clifford equivalent to the result obtained
in Ref. [29].
12
3
4
6
7
8
9
10
1
2
11
5
12
3
4
6
7
8
9
10
1
2
11
5
FIG. 28: |Gopt
000⟩of holographic code. The left one is constructed by code concatenation with ZX-diagram and the right one is
given in [29]. These two graphs are local Clifford equivalent, meaning they can be transformed into each other by local
complementation.
VIII.
CONCLUSION AND DISCUSSION
In this paper, we have successfully employed ZX-calculus as a graphical language to analyze the concatenation of graph
codes. We have established a correspondence between the encoding map and ZX-diagrams and utilized the ZX-rules to provide
a purely graphical proof of I1, addressing Q1. Our ﬁndings have revealed that I2 does not always hold, as it depends on the
connectivity of the encoding qubits of the inner code. Furthermore, we have expanded our study by examining concatenated
graph codes for different values of U, including holographic codes, offering insights into Q2.
The results presented in this work demonstrate the power and potential of ZX-calculus in the realm of quantum error cor-
rection. By providing a visually intuitive and algebraically rigorous framework for the analysis of graph code concatenation,
we have laid the groundwork for further advancements in the design and optimization of error-correcting codes for quantum
computing and communication systems.
Our study also suggests several avenues for future research. One possible direction is the generalization of our approach
to the concatenation of stabilizer codes, not just concatenated graph codes. As an example, Shor’s code can be viewed as an
concatenated code.
Example 8. Shor’s code can be given by concatenation. However it is not in the form a graph code. It is indeed local Clifford
(LC) equivalent to the graph code right ﬁgure below.
By extending the methods developed in this paper, we may uncover new insights into the structure and properties of concate-
nated stabilizer codes, opening up new possibilities for error correction in a broader range of quantum systems.
Another promising area for future work is the investigation of symmetry in concatenated codes. It turns out, the concatenated
graph code maintains some symmetry of the inner and outer code, as shown in various examples in this paper. A deeper
understanding of the symmetries present in these codes could potentially lead to the development of more efﬁcient error detection
and correction procedures. Additionally, the exploration of symmetries may reveal connections between seemingly distinct
codes, further enriching our understanding of the space of quantum error-correcting codes.

16
2
1
3
β
α
A
δ
γ
8
9
7
C
11
β′
δ′
α′
γ′
5
12
10
4
6
D
B
2
1
3
β
α
A
δ
γ
8
9
7
C
11
β′
δ′
α′
γ′
5
12
10
4
6
D
B
2
1
3
β
A
δ
γ
8
9
7
C
11
β′
δ′
γ′
5
12
10
6
D
B
2
1
δ
γ
8
9
7
C
11
β′
δ′
γ′
12
10
6
D
2
1
δ
γ
8
9
7
C
11
β′
δ′
12
10
6
D
2
1
δ
γ
8
9
7
C
11
β′
δ′
12
10
6
D
π
2
1
δ
8
9
7
C
11
β′
δ′
12
10
6
D
π
2
1
δ
8
9
C
11
β′
δ′
12
10
6
D
π
2
1
δ
9
11
β′
δ′
12
10
6
D
π
2
1
8
9
11
β′
δ′
12
10
D
π
2
1
9
11
β′
12
10
D
π
π
2
1
9
11
β′
12
D
π
π
2
1
β′
12
π
π
2
1
12
π
π
π
2
1
12
π
π
π
2
3
A
12
π
π
π
2
12
π
π
π
π
π
π
π
FIG. 29: Holographic code as a concatenated graph code. It encodes 4 qubits (ABCD) into 12 qubits (1 −12). We start from
the top left ﬁgure, and subsequently remove qubit labels in later ﬁgures for simplicity. The result is the bottom right ﬁgure,
where nodes with π phase are input qubits.

17
FIG. 30: ZX-diagram:Shor’s code as a concatenated graph code.
In conclusion, the application of ZX-calculus to the analysis of concatenated graph codes has not only yielded important
insights into the structure and properties of these codes but has also paved the way for further research in the ﬁeld of quantum
error correction. By continuing to explore the rich combinatorial structures of graph codes and their concatenation, we can
contribute to the development of more efﬁcient and robust quantum computing.
Acknowledgement
We thank Markus Grassl and Chao Zhang for helpful discussions. This work is support by GRF (grant no. 16305121) and the
National Science Foundation of China (Grants No. 12004205).
[1] M. A. Nielsen and I. Chuang, Quantum computation and quantum information (2002).
[2] D. Gottesman, Stabilizer codes and quantum error correction (California Institute of Technology, 1997).
[3] A. R. Calderbank, E. M. Rains, P. M. Shor, and N. J. Sloane, IEEE Transactions on Information Theory 44, 1369 (1998).
[4] H. J. Briegel and R. Raussendorf, Physical Review Letters 86, 910 (2001).
[5] R. Raussendorf and H. J. Briegel, Physical review letters 86, 5188 (2001).
[6] M. Hein, W. Dür, J. Eisert, R. Raussendorf, M. Nest, and H.-J. Briegel, arXiv preprint quant-ph/0602096 (2006).
[7] D. Schlingemann, arXiv preprint quant-ph/0111080 (2001).
[8] D. Schlingemann and R. F. Werner, Physical Review A 65, 012308 (2001).
[9] M. R. Markus Grassl, Andreas Klappenecker, in Proceedings IEEE International Symposium on Information Theory, (IEEE, 2002), p. 45.
[10] A. Cross, G. Smith, J. Smolin, and B. Zeng, IEEE Transactions on Information Theory 1, 433 (2009).
[11] I. Chuang, A. Cross, G. Smith, J. Smolin, and B. Zeng, Journal of Mathematical Physics 50, 042109 (2009).
[12] X. Chen, B. Zeng, and I. L. Chuang, Physical Review A 78, 062315 (2008).
[13] M. Van den Nest, J. Dehaene, and B. De Moor, Physical Review A 69, 022316 (2004).
[14] J. Dehaene and B. De Moor, Physical Review A 68, 042318 (2003).
[15] E. Hostens, J. Dehaene, and B. De Moor, Physical Review A 71, 042315 (2005).
[16] E. Knill and R. Laﬂamme, arXiv preprint quant-ph/9608012 (1996).
[17] E. Knill, R. Laﬂamme, and W. Zurek, arXiv preprint quant-ph/9610011 (1996).
[18] E. Knill, R. Laﬂamme, and W. H. Zurek, Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering
Sciences 454, 365 (1998).
[19] C. Zalka, arXiv preprint quant-ph/9612028 (1996).
[20] D. Aharonov and M. Ben-Or, in Proceedings of the twenty-ninth annual ACM symposium on Theory of computing (1997), pp. 176–188.
[21] M. Grassl, P. Shor, G. Smith, J. Smolin, and B. Zeng, Physical Review A 79, 050306 (2009).
[22] S. Beigi, I. Chuang, M. Grassl, P. Shor, and B. Zeng, Journal of Mathematical Physics 52, 022201 (2011).
[23] B. Coecke and R. Duncan, Preprint (2007).
[24] R. Duncan and S. Perdrix, in Conference on Computability in Europe (Springer, 2009), pp. 167–177.
[25] J. van de Wetering, arXiv preprint arXiv:2012.13966 (2020).
[26] C. Cao and B. Lackey, PRX Quantum 3, 020332 (2022).
[27] F. Pastawski, B. Yoshida, D. Harlow, and J. Preskill, Journal of High Energy Physics 2015, 1 (2015).
[28] A. Almheiri, X. Dong, and D. Harlow, Journal of High Energy Physics 2015, 1 (2015).
[29] G. A. Munné, V. Kasper, and F. Huber, arXiv preprint arXiv:2209.08954 (2022).

18
Appendix: More examples
Example 9. Concatenation of two ﬁve-qubit code with U ′ = H:
FIG. 31: Concatenation of two ﬁve-qubit code. Notice that only one qubit of the outer code is encoded into an inner ﬁve-qubit
code. One can use a similar procedure to encode all ﬁve qubits of the outer code, which will result in FIG.9 of [22].
Example 10. Concatenation of Steane code:
FIG. 32: Concatenation of Steane code. Notice that only one qubit of the outer code is encoded into an inner Steane code. One
can use a similar procedure to encode all seven qubits of the outer code, which will result in FIG.10 of [22].

19
Example 11. Concatenated code with loop:
FIG. 33: Concatenated code with loop.

20
Example 12. Concatenation of two ﬁve-qubit code with U ′ = I:
FIG. 34: Concatenation of two ﬁve-qubit code with U ′ = I.

