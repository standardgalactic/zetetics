Oblivious Transfer from Zero-Knowledge Proofs
Or How to Achieve Round-Optimal Quantum Oblivious Transfer and
Zero-Knowledge Proofs on Quantum States
Léo Colisson
1,3, Garazi Muguruza2,3, Florian Speelman
2,3
leo.colisson@cwi.nl, g.muguruzalasa@uva.nl, f.speelman@uva.nl
1 Centrum Wiskunde & Informatica, Amsterdam, Netherlands
2 Informatics Institute, University of Amsterdam, Netherlands
3 QuSoft, Amsterdam, Netherlands
Abstract. We provide a generic construction to turn any classical Zero-Knowledge (ZK)
protocol into a composable (quantum) oblivious transfer (OT) protocol, mostly lifting the
round-complexity properties and security guarantees (plain-model/statistical security/unstructured
functions. . . ) of the ZK protocol to the resulting OT protocol. Such a construction is un-
likely to exist classically as Cryptomania is believed to be diﬀerent from Minicrypt.
In particular, by instantiating our construction using Non-Interactive ZK (NIZK), we pro-
vide the ﬁrst round-optimal (2-message) quantum OT protocol secure in the random oracle
model, and round-optimal extensions to string and k-out-of-n OT.
At the heart of our construction lies a new method that allows us to prove properties on
a received quantum state without revealing (too much) information on it, even in a non-
interactive way and/or with statistical guarantees when using an appropriate classical ZK
protocol. We can notably prove that a state has been partially measured (with arbitrary
constraints on the set of measured qubits), without revealing any additional information
on this set. This notion can be seen as an analog of ZK to quantum states, and we expect
it to be of independent interest as it extends complexity theory to quantum languages, as
illustrated by the two new complexity classes we introduce, ZKstatesQIP and ZKstatesQMA.
Keywords: Quantum Cryptography, Oblivious Transfer, Zero-Knowledge on Quantum States,
Multi-Party Computing, Zero-Knowledge
arXiv:2303.01476v2  [quant-ph]  6 Mar 2023

Table of Contents
1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
1.1
Contributions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4
1.2
Overview of the main contributions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.3
Open problems and ongoing works . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
2
Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.1
Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.2
Model of security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.3
Cryptographic requirements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
3
Protocol for bit OT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
3.1
The protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
3.2
Security proof . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
4
(NI)ZKoQS and k-out-of-n string OT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
4.1
ZKoQS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
4.2
Proof of partial measurement: a generic framework to get ZKoQS . . . . . . . . . . . . .
23
4.3
Protocol to prove that a state has been semi-collapsed . . . . . . . . . . . . . . . . . . . . . . .
25
4.4
ZKstatesQIPS[k] and ZKstatesQMAS: ZKoQS from a complexity theory point of
view . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
4.5
Applications to build string and k-out-of-n OT protocols . . . . . . . . . . . . . . . . . . . . .
30
5
Composability of [Unr15] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
6
Acknowledgment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
A Proofs of statements in preliminaries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
B Proofs of security of the bit OT protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
C Proof of the ZKoQS and k-out-of-n string OT protocols . . . . . . . . . . . . . . . . . . . . . . . . . .
48
D Proof of the composability of [Unr15] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56

1
Introduction
Oblivious Transfer (OT) is an extremely powerful primitive, as it was shown [Kil88] to be
suﬃcient to perform multi-party computing (MPC), allowing multiple parties to jointly compute
any function while keeping the input of each party secret. Since the introduction of 2-party
computing in the seminal article of Yao [Yao82], followed by the famous generalisation to
arbitrary many parties of Goldreich, Micali and Wigderson [GMW87], OT and MPC received
a tremendous amount of attention [Wie83, PVW08, Rab05, EGL85, CGS02, DGJ+20, KP17,
LT22, YAV+22].
However, all classical OT protocols need to use some structured computational assumptions
providing trapdoors. Said diﬀerently, OT (classically) lives in Cryptomania [Imp95], a world
where public-key cryptography exists. On the other hand, it was recently shown [GLS+21,
BCK+21] that quantumly, OT lives in MiniQCrypt, meaning that it is possible to obtain OT
protocols using a much weaker assumption, based only on (unstructured) one-way functions.
There are many reasons to avoid using trapdoor functions. For instance, this additional
structure can often be exploited by quantum computers, leading to attacks. As a result, many OT
protocols (based on RSA, quadratic residue, elliptic curves. . . ) are vulnerable against quantum
adversaries. While some proposals [BD18, Qua20] based on post-quantum assumptions like the
Learning-With-Errors problem (LWE) still seem to resist against quantum adversaries, minimizing
assumptions is an important safety-guard against potential future attacks on the computational
assumptions. Understanding the minimal required assumptions is also an active ﬁeld of research,
with the recent introduction of the notion of pseudo-random quantum states [JLS18], which is
an even weaker assumption than one-way functions.
However, while classically we know 2-message OT protocols (optimal in term of round
complexity) [BD18], quantumly there is no known round-optimal protocol. The original pro-
posal [CK88] for quantum OT (studied and improved in a long line of research [BBC+92, MS94,
Yao95, DFL+09, Unr10, BF10], see also this review [SMP22] for quantum OT protocols based on
physical assumptions, that we will not cover here) requires 7 messages, and [ABK+22] managed
to obtain a 3-message protocol (computationally secure, in the random oracle model). However,
they left the following question open:
Does there exist two-message quantum chosen-input bit OT, that allows both parties to choose
inputs?
They also raise the question of the existence of a 2-message string OT, even when the bit
chosen by the receiver is random. The main bottle-neck to further reduce the communication
complexity of these protocols is the use of a “cut-and-choose” approach, where the receiver
sends a quantum state and some commitments on the description of this state, gets a challenge
from the sender to ensure that the quantum states were honestly prepared, and opens some
commitments. Classically, we can avoid cut-and-choose by using Non-Interactive Zero-Knowledge
proofs (NIZK) in order to prove an NP statement on a classical string without revealing anything
on that string except the fact that the statement is true. However, deﬁning NIZK proofs on
quantum states is challenging as any measurement on a quantum state will irremediably alter it.
While NIZK proofs on Quantum States (NIZKoQS) have been recently introduced [CGK21] and
can be used to prove really advanced properties, they rely on trapdoor functions (LWE), and
therefore live in Cryptomania, and are moreover fundamentally only computationally secure.
[CGK21] actually raised two open questions:
Is it possible to do NIZKoQS without relying on LWE? Or with statistical security?
3

Article
Classical
Setup
Messages
MiniQCrypt
Composable
Statistical
[BD18]
Yes
Plain M.
2
No (LWE)
Sender
Receiver
[CK88] + later works
No
Depends
7
Yes
Yes [DFL+09, Unr10]
Either
[GLS+21]
No
Plain M./
CRS
poly/
cte ≥7
Yes
Yes
No
[BCK+21]
No
Plain M./
CRS
poly/
cte ≥7
Yes
Yes
Sender
[ABK+22]
No
RO
3
Yes
Yes
No
This work + [BD18]
No
RO
2
Yes
Yes
No
This work + [HSS11]
No
Plain M.
> 2
No (LWE)
Yes
No
This work + S-NIZK
No
Like ZK
2
Like ZK
Yes
Sender
This work + NIZK proof
No
Like ZK
2
Like ZK
Yes
Receiver
This work + ZK
No
Like ZK
ZK +1 or 24
Like ZK
Yes
Like ZK
Fig. 1: Comparison with related works. “RO” stands for Random Oracle, “Plain M.” stands
for “plain model”, “Like ZK” means that the properties (mostly) inherit from the property
of the underlying ZK protocol, the party in the “statistical” column represents the malicious
party allowed to be unbounded to get statistical security (note that using [WW06] we can get
statistical security against the other party (of course we lose the statistical security against the
ﬁrst party [Lo97]), at the cost of an additional message).
1.1
Contributions.
In this work, we answer positively all these open questions. We ﬁrst state our results on OT
protocols (see also Fig. 1 for a table comparing existing works):
Theorem 1.1 (informal). There exists a 2-message string OT (even k-out-of-n string OT)
quantum protocol composably secure in the random oracle model.
Actually, we provide a much more generic construction that allows us to obtain a variety
of quantum OT protocols, depending on whether we want to optimize the round-complexity,
the security (against unbounded sender, or unbounded veriﬁer), the setup model (plain-model,
Common Reference String (CRS), Random Oracle), or the computational assumptions (one-way
functions, LWE, etc.).
Theorem 1.2 (informal).
Assuming the existence of a collision-resistant hiding one-way
function, given any n-message ZK proof (or argument) of knowledge, we can obtain a n + 1-
message OT5 protocol (or n + 2 in the plain model6).
Moreover, if the ZK protocol is secure against any unbounded veriﬁer (resp. prover) and if
the function is statistically hiding (resp. injective), the resulting OT protocol is secure against
any unbounded sender (resp. receiver).
Note that classical ZK is a widely studied primitive as it turns out to be extremely useful in
many applications, including in MPC, authentication, blockchain protocols [ELE], and more.
4+1 in the Common Random String model, +2 in the plain model.
5This holds for all variations of OT: bit OT, string OT, and k-out-of-n OT.
6The model of security is the same as the ZK protocol if we want a n + 2-message protocol, and if we add the
Common (uniform) Reference String assumption (weaker than the Random Oracle model) to provide the hash
function, we can obtain a protocol with n + 1 messages.
4

Trapdoors are not necessary to build ZK as they can be built using only hash functions, and
therefore live in Minicrypt. Many candidates have been proposed to achieve various ZK ﬂavors:
statistical security against malicious prover or malicious veriﬁer, non-interactive or constant
rounds protocols, security in the plain model, CRS, or random oracle [GMR85, Lin13, Unr15,
BD18, HSS11, PS19]. . . In this paper, we notably consider the non-interactive ZK protocol of
Unruh [Unr15], proven secure in the random oracle, together with the ZK protocol of Hallgren,
Smith and Song [HSS11], proven secure in the plain-model assuming the hardness of LWE, but
much work has been done to study ZK under many other assumptions [Wat09, AL20, Unr12,
BS20, LMS21].
At the heart of our approach lies the ﬁrst creation of a (potentially statistically secure when
instantiated correctly) ZK protocol on quantum states, that can be seen as an extension of ZK
and complexity theory to quantum languages:
Theorem 1.3 (informal). Under the same assumptions as Theorem 1.2, a receiver can obtain
a quantum state while being sure that a subset T of the qubits has been measured, without getting
any information on T beside the fact that it fulﬁls some arbitrary ﬁxed constraints.
The resulting protocol is n-message (n + 1 in the plain model), and can in particular be
non-interactive when using a NIZK protocol. Statistical security can also be obtained under the
conditions described in Theorem 1.2 (the receiver playing the role of the prover, and the sender
the veriﬁer).
We also deﬁne formally the concept of ZK on Quantum State (ZKoQS), together with
quantum languages and the ﬁrst two “quantum-language” based complexity classes ZKstatesQIP
and ZKstatesQMA. Finally, we prove relations between ZKoQS and various ideal functionalities,
we prove that we can realize them, and we show examples of quantum languages belonging to
ZKstatesQIP and ZKstatesQMA.
1.2
Overview of the main contributions.
In this section, we provide a quick, informal, overview of our approach. The OT functionality
can be described as follows: a sender, Bob, owns two bits7 m0 and m1, and Alice wants to learn
mb where the bit b is provided as an input. Importantly, a malicious Bob should be unable to
learn the value b of Alice, and a malicious Alice should be unable to get information on both m0
and m1.
First attempt: a naive OT protocol. A ﬁrst remark we can make is that if we are given a
state in the computational basis |l⟩for some bit l, rotating it by applying a Zm gate for some
bit m will leave the state unchanged (up to a global phases). On the other hand, if we are given
a state in the Hadamard basis H |r⟩for some bit r, applying a Zm gate will ﬂip the encoded
bit if m = 1, giving the state H |r ⊕m⟩. Therefore, we can imagine a naive protocol for OT:
Alice could prepare two states |ψ(b)⟩:= H |r(b)⟩and |ψ(1−b)⟩:= |l⟩for some random bits r(b)
and l, send |ψ(0)⟩and |ψ(1)⟩to Bob, Bob could rotate the i-th qubit according to Zmi, and
measure them in the Hadamard basis, getting outcomes z(i) that will be sent back to Alice. In
the light of the above comment, it is easy to see that z(b) = mb ⊕r(b) while z(1−b) is a random bit,
uncorrelated with m1−b. Therefore, Alice can easily recover mb = z(b) ⊕r(b) while she is unable
to recover m1−b. Moreover, because the density matrix of 1
2(|0⟩⟨0| + |1⟩⟨1|) = 1
2(|+⟩⟨+| + |−⟩⟨−|)
is the completely mixed state, Bob cannot recover any information on b. . .
7Our approach also works for strings or k-out-of-n OT.
5

Unfortunately, this protocol is not secure: Alice can easily cheat by sending two |+⟩states to
learn both m0 and m1.
The need for ZK on quantum state. To avoid this trivial cheating strategy, we would like,
informally, to prove to Bob that at least one of the received state is in the computational basis. . .
without revealing the position of this qubit, and without destroying that state. So in a sense, we
would like a quantum equivalent of ZK, except that the statement is on a quantum state instead
of on a classical bit string.
As a ﬁrst sight, this might seems to contradict laws of physics: it is impossible to learn
the basis of a random state, and anyway any measurement would certainly disturb the state.
However, we can change a bit the procedure to send |ψ(0)⟩and |ψ(1)⟩, by sending instead a
bigger, more structured state, letting Bob do some (non-destructive) tests on this large state,
before collapsing it to a 2-qubit system. Since we already know how to do ZK on classical strings,
it would be handy to attribute a classical string (partially) encoding the description of the
quantum state, and provide a way to check that the qubit is indeed described by this string.
This way, we could use ZK on the classical string to verify, indirectly, properties on the quantum
state.
We can actually do this encoding as follows: instead of sending |l⟩, we sample a random bit
string w(1−b)
l
starting with a 0 (this will be important later, but informally this indicates that this
is a valid, non-dummy element) and send |ψ(1−b)⟩:= |l⟩|w(1−b)
l
⟩, together with the hash h(1−b)
l
:=
h(l∥w(1−b)
l
). Similarly, we can apply this idea on states in superposition: instead of sending
|0⟩+(−1)r(b) |1⟩, we sample similarly w(b)
0
and w(b)
1 , and send |ψ(b)⟩:= |0⟩|w(b)
0 ⟩+(−1)r(b) |1⟩|w(b)
1 ⟩,
together with the hashes h(b)
0
:= h(0∥w(b)
0 ) and h(b)
1
:= h(1∥w(b)
1 ). Of course, now, it is relatively
easy to distinguish both qubits, as the qubit in the computational basis comes with a single
classical hash, while the other comes with two hashes. To avoid this issue, we add a “dummy”
hash by sampling a random w(1−b)
1−l
starting with a 1 (indicating that the hash is dummy), and
deﬁning h(1−b)
1−l
:= h(l∥w(1−b)
1−l ). Importantly, given a hash, it is impossible to see if it is a dummy
hash, as the hash function is hiding its input. However, Alice can prove to Bob, using classical
ZK, that at least one of the provided hashes is a dummy hash, without revealing its position.
Therefore, to sum-up, Alice sends the hashes, proves that she knows a preimage for all of them
and that one of them is a dummy hash (i.e. its preimage has a 1 in its second position), before
sending the states |ψ(0)⟩and |ψ(1)⟩to Bob (if the ZK proof is non-interactive, she can send
everything in a single message).
Then, after verifying the ZK proof, Bob will verify that |ψ(0)⟩and |ψ(1)⟩are in a superposition
of valid, non-dummy, preimages. More precisely, for i ∈{0, 1}, he applies the unitary |x⟩|w⟩|0⟩→
|x⟩|w⟩|w[1] = 0 ∧h(x∥w) ∈{h(i)
0 , h(i)
1 }⟩on the i-th qubit (after adding an auxiliary qubit), and
measures the last register to check if it’s equal to 1. Note that for honestly prepared state, this
measurement will not alter the state, as the last registers always contains a |1⟩and can therefore
be factored out as the state is separable. Once the check is performed, we can shrink both states
to obtain a 2-qubit state by measuring the second register containing the w’s in the Hadamard
basis, getting two outcomes s(i)’s. One can easily check that since |ψ(1−b)⟩is already in the
computational basis, it will not alter the ﬁrst qubit, resulting in the |l⟩state, i.e. a qubit in the
computational basis. On the other hand, it is not hard to see that the qubit |ψ(b)⟩will be turned
into |0⟩|w(b)
0 ⟩+ (−1)r(b)⊕⟨s,w(b)
0
⊕w(b)
1
⟩|1⟩, i.e. the ﬁnal state will be in the Hadamard basis (the
encoded bit might be ﬂipped, but Alice can easily recover that bit ﬂip knowing the outcomes of
the measurements).
6

This way, we are back to the original requirement of the naive oblivious transfer described
above: Bob can rotate each qubit i using Zmi, measure them in the Hadamard basis, and send
the outcomes z(i) to Alice, together with the measurements s(0) and s(1). Alice will then be able
to recover the ﬁnal bit mb by computing r(b) ⊕⟨s, w(b)
0
⊕w(b)
1 ⟩⊕z(b).
This protocol is summarized in Protocol 1, and can easily be generalized to string OT or
k-out-of-n OT by sending one “hashed qubit” per bit to transmit, and proving via ZK the wanted
properties on the number and position of the dummy hashes (e.g. either the ﬁrst half of hashes
are dummy, or the second half). This will be described in more details below.
Sketch of security proof. Interestingly, this method is signiﬁcantly simpler to analyse than
the interactive cut-and-choose approach used in previous works, as illustrated by the long line of
research trying to prove the security of the original proposal [BBC+92, MS94, Yao95, DFL+09,
Unr10, BF10]. Of course, part of this analysis is oﬄoaded to the ZK protocol, but we like to see
it as a feature: this allows us to have a more modular protocol (any improvement on ZK directly
implies an improvement on OT), and the analysis only needs to be done once for the classical
ZK protocol.
At a very high level, since the ZK protocol leaks no information on the witness, and because
the hash is hiding8, Bob learns no information on b. Note that the quantum state does not help
as one can see that for any bit string x0, x1 the density matrix of |x⟩where x
$←{x0, x1} is
equal to the density matrix of |x0⟩± |x1⟩, where the sign is randomly chosen. To translate this
informal argument into a composable security proof, we design our simulator by ﬁrst replacing
the ZK proof with a simulated proof (that does not need access to the witness), then we turn
the dummy hash into a non-dummy hash (indistinguishable since h is hiding), and we sample
|ψ(1−b)⟩like |ψ(b)⟩(indistinguishable by the above argument on density matrices). This way, the
simulator can extract both m0 and m1, and provide them to the ideal functionality for OT, that
will be in charge of discarding m1−b and outputting mb. More details can be found in the proof
of Theorem 3.1.
On the other hand, to learn information about both m0 and m1, Alice needs to produce
two non-collapsed states. But the tests performed by Bob force Alice to send a superposition of
non-dummy preimages (in case she does not, the test might pass with some probability, but the
state will be anyway projected on a superposition of non-dummy valid preimages in that case).
However, by the ZK property, at least one of the classical hashes must be a dummy hash, and
therefore if the corresponding qubit contains a superposition of multiple valid preimages, one of
them must either collide with the dummy hash, or with the non-dummy one. This collision can
even be obtained with non-negligible probability by measuring the state in the computational
basis and comparing the outcome with the preimages extracted by the simulator during the ZK
protocol. More details can be found in the proof of Theorem 3.1.
Note that if all the properties hold against an unbounded Alice (resp. Bob), notably by
instantiating the protocol with a ZK proof of knowledge and an injective function h (resp. a
statistical ZK and a statistically hiding function) our OT protocol is secure against an unbounded
receiver (resp. sender). Note also that since our adversaries are non-uniform, we need to ﬁnd a
way to distribute the function h in such a way that the non-uniform advice cannot depend on
h (or it might hardcode a collision). By relying on the CRS assumption (actually a uniformly
random string is enough), the hash function can be distributed non-interactively by the CRS (or
8In practice, we ask for h to be “second-bit hardcore”, meaning that it is not possible to learn the second bit
of x given h(x), but we could also certainly extend the construction to work for any one-way function using the
Goldreich-Levin construction and rejection sampling.
7

heuristically replaced with a ﬁxed hash function). If we want to stay in the plain model we can
instead ask Bob to sample the function and send it to Alice at the beginning of the protocol,
adding an additional message (providing a (n + 2)-message OT protocol instead of n + 1, where
n is the number of messages of the ZK protocol).
Extensions, and formalisation of ZKoQS and quantum language. In the rest of the
article, we also formalize the notion of quantum language (Deﬁnition 4.3), that can be seen as
a generalization of classical languages (used to deﬁne most existing complexity classes) where
the instances are quantum states instead of classical strings. We also formally deﬁne the notion
of Zero-Knowledge on Quantum states (ZKoQS, Deﬁnition 4.5), that, informally, states that a
protocol can prove that a received quantum state belongs to a given quantum language, and we
deﬁne the corresponding complexity classes ZKstatesQIPS[k] and ZKstatesQMAS (Deﬁnition 4.16).
While this notion is quite generic, it does not translate naturally to an ideal functionality, useful
to prove the security of protocols in the simulation-based and composable quantum standalone
framework [HSS11]. As a result, we deﬁne a relatively generic ideal functionality that is in
charge of applying some measurement operators (Deﬁnition 4.8), and we prove that under some
assumptions on the measurement operators (called postponable measurements, Deﬁnition 4.9),
this functionality implies ZKoQS (Theorem 4.10). While for now we do not know a realization of
this functionality for any measurement operator, we consider a particular case (Deﬁnition 4.11)
where the functionality is in charge of measuring a subset T of qubits (such that Pred(T) = ⊤for
an arbitrary predicate Pred) and rotating randomly the other qubits. We show in Theorem 4.12
how to realize this functionality, and we prove in Corollary 4.15 that it is a ZKoQS functionality
for the language LPred
SemCol of semi-collapsed states (Deﬁnition 4.14). We provide in Corollary 4.18
the implications in term of complexity theory (e.g. LPred
SemCol is in ZKstatesQMARO). We also show
in Theorem 4.19 that this functionality can be used to realize a very generic notion of OT
protocol that we call Pred-OT, and in particular string-OT and k-out-of-n OT (Corollary 4.20).
Finally, since our result requires the use of (NI)ZK protocols, we prove in Section 5 that the
non-interactive protocol of [Unr15] (proven secure in the RO model) can be expressed in the
quantum standalone framework, and can therefore be used in our protocol ([HSS11] already
provides another interactive protocol in the plain-model).
1.3
Open problems and ongoing works
The modularity of our OT construction and our ZKoQS protocol raise multiple open questions:
– Reducing entanglement: our protocols require the preparation of states representing a
superposition of bit strings, and the application of a hash function h in superposition. For
practical considerations, it would be great to see if we could get 2-message quantum OT
protocols and/or ZKoQS with single-qubit operations (or prove impossibility results).
– Universal composability: the model of security we are using allows sequential compos-
ability but not parallel composability. A priori, we expect our proof method to extend to a
general composability framework like Composable Cryptography or Universal Composability,
but we also need to ﬁnd ZK protocols secure in this stronger model of security (note that
[Unr15] already provides online extractability and is therefore certainly a good starting
point).
– Characterization of ZKstatesQIP and ZKstatesQMA: For now we have only proven the
belonging of a small class of quantum languages in ZKstatesQMARO and ZKstatesQIPpm
S , but
it would be thrilling to study the set of quantum languages that belong (or does not belong)
8

to the various classes ZKstatesQIP and ZKstatesQMA. For instance it would be interesting to
see if it is possible to prove that states belong to the Hadamard basis or to the computational
basis (methods inspired by quantum money might be useful).
– ZK for statistical security: While our approach states that we can get quantum OT
with statistical security assuming the existence of statistical ZK argument of knowledge (for
unbounded veriﬁer/sender) or ZK proof of knowledge (for unbounded prover/receiver), it is
important to check that such protocols exist (for now the protocols we analyse only bring
computational security, which results in a computationally secure OT, like [ABK+22]). There
are countless classical candidates and ways to analyse them quantumly ([Wat09, AL20, BS20,
LMS21], especially with the recent breakthrough of [LMS21], but each construction often
uses their own slightly diﬀerent deﬁnitions of ZK. Therefore, a proper analysis is needed to
see which protocol ﬁts in the quantum standalone framework. Similarly, ﬁnding a ZK in the
plain model not based on trapdoors could provide a simpler proof for the results of [GLS+21,
BCK+21], and even if candidates exists, we have not yet analysed them properly to see if
they ﬁt in the quantum standalone framework. Finally, the ZK construction [Unr15] that we
use to get 2-message OT is in the random oracle model, and it would be great to obtain a
similar ZK construction in the CRS model.
– Even weaker assumptions: recently, pseudo-random states [JLS18] were introduced to
provide an ever lower assumption compared to one-way functions. Since they imply com-
mitment, they should also imply ZK proofs, but we also need OWF to produce the “hashed
qubits”: removing OWF in ZKoQS is therefore an open question.
– Reducing complexity: for now, when doing string OT of size n we sample 2n random w’s,
and therefore we need to do 2n ZK proofs on them. However, it might seem reasonable to
use the same randomness for the ﬁrst n bits, and a second randomness for the last n bits,
leading to a much shorter ZK proof. It could also be great to see if it’s possible somehow
to re-use the same quantum register containing the randomness to also lower the quantum
complexity for string OT.
– Reducing communication in the plain model: while our approach can get us to the
optimal round-complexity (2 messages), such optimal complexity cannot be obtained in
the plain-model, at least in a composable framework. It would be interesting to study the
minimum number of rounds in the plain-model (but staying in MiniQCrypt), possibly giving
up on composable proofs.
– Applications: While OT is deﬁnitely an important application for the ZKoQS protocol, we
expect ZKoQS to ﬁnd applications in other ﬁelds. Exploring the potential applications would
therefore be an interesting line of research.
– Weaker ZK protocols: For now we assume the existence of a ZK protocol for NP, but we
informally mainly want to prove that some classical languages contain few elements, which
might be more eﬃcient to realize than with a fully ﬂedged ZK protocol for NP. Studying
the links with witness indistinguishability or witness elimination [KZ09] might also be nice
to see how we can weaken the assumptions. Moreover, interestingly we don’t need the PoK
property to extract the mb’s, only to get the value of b. It might be interesting to see if we
can get rid of the PoK assumption of the ZK protocol.
– Comparison of quantum communication: while our approach potentially needs non-
trivial quantum operations on the server side (notably applying h in superposition, note
that all ZK operations are fully classical), the quantum communication seems relatively low
compared to other works like [ABK+22]. The reason is that we only send the randomness w,
so if we take a randomness of size 160 (that should be enough to avoid brute-force attacks
9

and quadratic improvement in grover-like attacks), we can transmit 2 × 161 = 322 qubits
to get 80 bits of security. Instead, our understanding of [ABK+22] is that we need to send
3200λ = 256 000 qubits for a similar security guarantee. However, a proper analysis should
be made.
2
Preliminaries
2.1
Notations
We assume basic familiarities with quantum computing [NC10]. For any Hermitian matrix A,
we denote its trace norm as ∥A∥1 := Tr(
√
A†A) = P
i |λi| where λi’s are the eigen-values of A
(considered with there multiplicity). We denote the trace distance between two density matrices
ρ and σ as TD(ρ, σ) := 1
2∥ρ −σ∥1. A bipartite state between two registers or parties A and B
will be denoted ρA,B. For any bit string x and x′, x[i] is the i-th element of x, starting from 1,
and ⟨x, x′⟩:= ⊕ix[i]x′[x]. For a gate Z and a quantum state |ψ⟩, ZB,i |ψ⟩B,E represents the state
obtained after applying Z on the i-th qubit of the register B of ψ (we might omit the register
when it is clear from the context). We might abuse notations and consider that outputting
true is the same as outputting 1, but for more complex formulas P it can be handy to deﬁne
δP ∈{0, 1} such that δP = 1 iﬀP is true.
2.2
Model of security
We follow the quantum stand-alone security model deﬁned in [HSS11] that we quickly summarize
here.
Quantum Interactive Machines (QIM). In this model, a quantum interactive machine
(QIM) A = {Aλ}λ∈N is a sequence of quantum circuits Aλ indexed by the security parameter λ
working on an input, output and network register. Two machines can interact by sharing their
network register while they are activated alternately. A (two-party) protocol Π = (A, B) is
a couple of QIM. We denote by A ↭B the sequence of quantum maps (indexed by λ ∈N)
representing the interaction between Aλ and Bλ: Namely this map takes as input a quantum
state on two registers SA and SB, provides to Aλ (resp. Bλ) the input SA (resp. SB), let
Aλ and Bλ interact and outputs at the end of the interaction the two registers containing
the outputs of Aλ and Bλ. We might also write z ←OUTB(Aλ(x) ↭Bλ(y)) instead of
(_, z) ←(Aλ(x) ↭Bλ(y)) to denote the output of the party B. A protocol is said to be
poly-time if all the parties run in polynomial time. The security of a protocol is expressed with
respect to a functionality F (having no input) playing the role of a trusted third party. A
functionality is a QIM interacting with all parties: for two QIM A and B, we similarly denote as
A
F
↭B the quantum map that forwards the two input registers to A and B and that returns
their outputs after letting both of them interact (only) with F, as pictured in Fig. 2. Note that
we might provide access to oracles H (QIM that answer queries to functions, e.g. a random
oracle), in which case we will either denote it as AH ↭BH or A
H
↭B (in this case H is the
functionality that answers queries and forwards other messages). Moreover, for two sequences
of quantum maps A = {Aλ}λ∈N and B = {Bλ}λ∈N, we also deﬁne naturally their sequential
composition as AB := {AλBλ}λ∈N.
10

Adversaries. An adversary A is a QIM able to corrupt parties (i.e. A will replace the corrupted
parties). We consider only static adversaries, meaning that A ∈{ ˆA, ˆB} chooses before the
beginning of the protocol the set of corrupted party. In particular, we denote by ˆA the adversary
that corrupts (and replaces) A (similarly ˆB would corrupt B). We deﬁne Π ↭A as the
quantum map obtained when the protocol Π is run in the presence of the adversary A: Notably,
Π ↭ˆA = ˆA ↭B and Π ↭ˆB = A ↭ˆB.
Real and ideal worlds. The security relies on the usual simulation paradigm involving a
real-world and an ideal-world, where the real-world represents a run of the protocol where some
parties can potentially be corrupted while the ideal-world paradigm represents an idealized
version of the protocol where the parties are only allowed to interact through the trusted ideal
functionality. A QIM Z called environment will be in charge of distinguishing these two worlds.
Informally, if both worlds are indistinguishable, the protocol is said secure as any attack doable
in the real-world would apply in the ideal-world (otherwise it would provide a way to distinguish
both worlds) and therefore on the ideal functionality F, which is secure by deﬁnition. In order
to “fake” a transcript from the real world during an execution of the ideal world, we replace any
honest party A by a idealized party9 ˜A that honestly interact with F (it is typically trivially
interacting with F by forwarding the inputs and outputs to/from F and is therefore often
omitted), and we write ˜Π := ( ˜A, ˜B) to denote this dummy protocol. Moreover, to deal with the
corrupted parties, we introduce a special kind of adversary SA called a simulator, that must
corrupt the same party as the adversary A and whose goal is to fake the transcript outputted
by A (i.e. simulate A, hence its name).
We formalize now this concept:
Deﬁnition 2.1. Let Π = (A, B) be a two-party protocol, A be a static adversary as deﬁned
above, SA be a simulator, σ = {σλ ∈SA(λ) ⊗SB(λ) ⊗W(λ)}λ∈N be a sequence of quantum
states and Z be a QIM called environment outputting a single classical bit. We denote by
REALσ
Π,A,Z := Z((Π ↭A) ⊗I)σ the (sequence of) binary random variables outputted by the
environment Z at the end of an interaction where the adversary A corrupts some parties in Π.
We deﬁne similarly IDEALσ,F
˜Π,SA,Z := Z(( ˜Π
F
↭SA) ⊗I)σ as the (sequence of) binary random
variables outputted by the environment Z at the end of an interaction where the simulator can
corrupt some dummy parties interacting with the ideal functionality F.
Deﬁnition 2.2 (Indistinguishable random variables). Two sequences of random variables
X = {Xλ}λ∈N and Y = {Yλ}λ∈N are said to be ε-indistinguishable, denoted X ≈εY, if
| Pr [ Xn = 1 ] −Pr [ Yn = 1 ] | ≤ε(λ). In particular, if ε = negl(λ), X and Y are said to be
indistinguishable, denoted X ≈Y.
Deﬁnition 2.3 (Indistinguishable quantum maps). Two sequences of quantum maps X =
{Xλ}λ∈N and Y = {Yλ}λ∈N are said to be computationally (resp. statistically) indistinguishable,
denoted X ≈c Y (resp. X ≈s Y), if for any poly-time (resp. unbounded) Z = {Zλ}λ∈N and any
sequence of bipartite advices σ = {σλ}λ, Z(X ⊗I)σ ≈Z(Y ⊗I)σ.
Deﬁnition 2.4 (Quantum stand-alone (*-QSA) realization of a functionality [HSS11]).
Let F be a poly-time two-party functionality and Π be a poly-time two-party protocol. We say
that Π computationally quantum-stand-alone (C-QSA) (resp. statistically quantum-stand-alone
(S-QSA)) realizes F if for any poly-time (resp. unbounded) adversary A there is a poly-time (in
9This is the analogue of ﬁlters in constructive cryptography.
11

the time taken by A) simulator SA such that for any poly-time (resp. unbounded) environment
Z and family of states σ = {σλ}λ∈N, REALσ
Π,A,Z ≈IDEALσ,F
˜Π,SA,Z.
Moreover, we extend this deﬁnition by saying that Π CSS-QSA (where S is a set of subset of
parties realizes F when statistical security holds only if the adversary corrupts10 a set of parties
in S (i.e. if A corrupts a set of party in S then A and Z are allowed to be unbounded, otherwise
they are poly-time). In particular, if the protocol has two parties A and B, CS∅-QSA = C-QSA
and CS{∅,{A},{B},{A,B}}-QSA = S-QSA. Note that because it is always possible to turn malicious
parties into honest parties, CSS-QSA implies CSS∪{X}-QSA for any X ⊆s such that s ∈S (for
instance CS{A,B}-QSA) implies CS{∅,{A},{B},{A,B}}-QSA). For this reason, we will consider from
now only maximal sets S with respect to this augmentation procedure and we will often only
write the larger set: We will notably be particularly interested in statistical security against a
malicious Alice (CS{∅,{A}}-QSA, or CSA-QSA for short) or a malicious Bob (CS{∅,{B}}-QSA, or
CSB-QSA for short).
σλ
σZ
λ
Z
z ∈{0, 1}
σA
λ
σ ˆ
B
λ
A
ˆB
OA
O ˆ
B
(a) Real-world.
σλ
σZ
λ
Z
z ∈{0, 1}
σA
λ
σ ˆ
B
λ
˜A
S ˆ
B
OA
O ˆ
B
F
(b) Ideal-world.
Fig. 2: Real-world and ideal-world executions when Bob is malicious.
Some functionalities. We present here some ideal functionalities used in the rest of the paper,
starting with the goal functionality:
Deﬁnition 2.5 (Functionality for bit oblivious transfer FOT [HSS11]). We deﬁne the
ideal functionality FOT for oblivious transfer as follows:
– it receives two messages m0 and m1 from Bob’s interface, or an abort message
– it receives one bit b ∈{0, 1} from Alice’s interface, or an abort message
– if no party decided to abort, it sends mb to Alice.
We deﬁne trivially the dummy parties ˜Π = ( ˜A, ˜B) that forward the inputs/outputs to/from FOT .
We will then prove that our protocol can trivially be extended to more advanced OT
functionalities. First, we deﬁne a generic functionality where the statements can be proven on
any predicate on the bits of the message, we will then consider particular cases like string OT
(to receive strings instead of bits) or k-out-of-m string OT (to receive k strings among n):
10Remember that the adversary is static, and therefore determines the set of parties to corrupt before the
beginning of the protocol. Note that we will omit in the proof the case where A corrupts all parties as this case is
trivial (the simulator can just run the adversary and ignore the functionality).
12

Deﬁnition 2.6 (Functionality for predicate oblivious transfer F Pred
OT ). Let n ∈N and
Pred: P([n]) →{0, 1} be a predicate11 on any subset of bits. We deﬁne the ideal functionality
F Pred
OT
for predicate oblivious transfer as follows:
– It receives n bits (mi)i∈[n] from Bob’s interface, or an abort message.
– It receive a subset B ⊆[n] from Alice’s interface (we might also encode B as a bit string,
where B[x] = 1 iﬀx ∈B), or an abort message.
– If B = ⊥or Pred(B) = ⊥, it sends an abort message to Bob.
– If no party decided to abort and Pred(B) = ⊤, it sends (mi)i∈B to Alice. Otherwise it sends
⊥to all parties.
We deﬁne trivially the dummy parties ˜Π = ( ˜A, ˜B) that forward the inputs/outputs to/from FOT .
We deﬁne particular cases of interest:
– String OT: If n = 2m and Pred(B) is true iﬀB ∈{1n0n, 0n1m} then we call this function-
ality string OT, denoted F str
OT (to sent the two messages ma and mb, we deﬁne m = ma∥mb).
– k-out-of-m string OT: If n = lm and Pred(B) is true iﬀB = B1∥. . . Bm with ∀i, |Bi| =∈
{0l, 1l}, such that the number of Bi’s equal to 1l is equal to n, then we call this functionality
k-out-of-m string OT, denoted F k−m
OT
(to sent the m messages ma and mb, we deﬁne
m = ma∥mb).
Classical Zero-Knowledge (ZK) proofs allow a party (the prover) to prove a statement to
another party (the veriﬁer) without revealing anything beyond the fact that this statement is true.
Our protocols use a ZK protocol as a blackbox. We deﬁne now the functionality corresponding
to ZK.
Deﬁnition 2.7 (Functionality for zero-knowledge F R
ZK [HSS11]). We deﬁne the ideal
functionality F R
ZK for zero-knowledge, where R is a relation describing a given language L
(x ∈L ⇔∃w, xRw):
– it receives (x, w) from the prover’s (a.k.a. Alice) interface or an abort message ⊥,
– if xRw then the veriﬁer (a.k.a. Bob) receives x otherwise it receives ⊥.
This functionality also implies that the ZK protocol is a proof of knowledge protocol (PoK,
quantumly it is also know as state-preserving as extracting the witness should not disturb the
state of the adversary) as the functionality can extract the witness. But our protocol could be
proven secure in diﬀerent ways:
– One of them is to assume that the protocol is a state-preserving PoK (PoK is not needed to
extract m0 and m1 from a malicious Bob, but is handy to extract b from a malicious Alice).
That’s the approach taken in this paper since it has the advantage of applying also in the
plain model.
– It should also be possible to obtain similar guarantees without state-preserving PoK, notably
by assuming that the simulator can extract the queries made to the oracle (either by relying
on Common Reference String (CRS) or on the random oracle model (ROM)). However, this
approach is less modular and seems to rely heavily on CRS/RO and is therefore harder to
generalize to the plain model. Moreover, we already know state-preserving NIZK PoK in the
RO model [Unr15], so this second approach seems less interesting and will not be explored
in this article.
11This predicate might depend on a secret witness w known only to the prover, in which case we always replace
Pred(· · · ) with Pred(w, · · · ), w being sent to the ideal functionalities and used in the ZK proofs. For simplicity,
we will omit the witness from now.
13

Moreover, we often make the distinction between ZK arguments (computational soundness
against malicious prover), ZK proofs (statistical soundness against malicious prover) and statis-
tical ZK (ZK also holds against a malicious unbounded veriﬁer). In the quantum stand-alone
formalism, ZK proofs are protocols that CSP -QSA realize F R
ZK and statistical ZK are protocols
that CSV -QSA realize F R
ZK.
Note that nearly all the properties of our protocol reduce to the properties of the ZK scheme.
If we use a Non-Interactive ZK (NIZK) protocol secure in the Quantum Random Oracle (OT)
model or in the Common Reference String (CRS) model, then our ﬁnal protocols will be optimal
in term of round complexity (2-message OT, or 1-message NIZKoQS) but will rely on the RO or
CRS assumption. On the other hand, we may prefer to use a n-message NIZK protocol in the
plain model: in that case our protocols will be secure in the plain model, and the communication
complexity will be n for the NIZKoQS protocol, resulting in an n + 1-message OT protocol.
There are multiple protocols realising the F R
ZK functionality, either in the plain model [HSS11]
or non-interactively in the random-oracle model [Unr15] (this last work is not expressed in
the quantum stand-alone model, but we prove in Section 5 that it can be reformulated in this
framework).
Because we are dealing with non-uniform adversaries, we need to sample hash functions
independently of the non-uniform advice, and this is usually done via a Common-Reference-
String (CRS) assumption. CRS assumes that a string, honestly sampled according to a ﬁxed
procedure, can be shared among all parties (this is typically not counted in the communication
as in practice we can often heuristically take a publicly known string instead, for instance by
feeding the generation procedure with a known uniformly sampled string. . . unless the sampling
needs trapdoor which is not our case here). While this adds an assumptions, it can be practical
sometimes to obtain more eﬃcient protocols (in term of communication complexity), and often
can be heuristically replaced by a publicly known string (e.g. if the string contains the description
of a collision resistant function like in our case, we might pick the well known SHA-256 hash
function instead). Note that our protocol can also be realized without a CRS assumption at the
cost of an additional message as discussed in Section 3.2 and in Lemma 2.13. We model CRS as
an ideal functionality:
Deﬁnition 2.8. Let Gen be a PPT sampling procedure. Then the ideal functionality F Gen
CRS
samples x ←Gen(1λ) and outputs x to all parties.
Hybrid models. For the sake of modularity, it is often handy to express a protocol realizing
a functionality F assuming that there exists another (unspeciﬁed) protocol realizing a more
primitive functionality G (G might also be considered as a setup assumption, like in the CRS
model). To that end, we denote as ΠG a protocol where each party can interact with a trusted
party running G (of course each party having only access to their respective interface), and we
say that we are in the G-hybrid model. The FCRS-hybrid model is also called the CRS model,
and if not such assumption is made, we say that we are in the plain model. Importantly, if a
protocol realizes G and if a G-hybrid protocol realizes F, then combining both protocols in the
natural way gives a (non-hybrid) protocol realizing G.
2.3
Cryptographic requirements.
Before stating our security guarantees, we need to deﬁne some security deﬁnitions. A function
is said to have a hardcore second-bit if it is hard to ﬁnd the second bit of x given h(x). More
formally:
14

Deﬁnition 2.9 (Hardcore second-bit).
We say that a function h has a computational
(resp. statistical) hardcore second-bit property if for any l ∈{0, 1}, any QPT (resp. unbounded)
adversary A and for any advice σ = {σλ}λ∈N:
Pr
h
A(λ, σλ, h(x)) = 1
 x
$←{l} × {0} × {0, 1}l(λ) i
−Pr
h
A(λ, σλ, h(x))
 x
$←{l} × {1} × {0, 1}l(λ) i
= 1
 ≤negl(λ)
(1)
We extend this deﬁnition to a family of functions {hk : {0, 1}l(λ) →{0, 1}m(λ)}k∈K if for any
k ∈K, hk has a computational hardcore second-bit property, and if one can eﬃciently check for
any k whether k ∈K or not.
We note that many functions have (or are expected to have) a hardcore second-bit property.
It is the case for random functions (e.g. in the RO model), where it is even possible to get
statistical security if the function is lossy (i.e. many inputs map to the same output), and we
expect it to be true for hash functions used nowadays. We note that people often consider a
weaker assumption called hardcore bit predicate (even achievable from any one-way function
thanks to the Goldreich-Levin construction [GL89]), where the unknown bit is a ﬁxed predicate
b(x) instead of the second bit of x. While we believe that our construction could be adapted to
that setting (by doing a rejection sampling to ﬁnd x such that b(x) has the right value), this
complicates the constructions with no obvious beneﬁt.
Deﬁnition 2.10 (Collision resistance). A family of functions {hk : {0, 1}l(λ) →{0, 1}m(λ)}k∈K
is said to be (computationally) collision-resistant if there exists a polynomial generation algorithm
k ←Genh(1λ) such that for any k ∈K, hk can be classically evaluated in polynomial time, and
for any (potentially non-uniform) QPT adversary A and advice {σλ}λ∈N:
Pr
h
x ̸= x′ ∧h(x) = h(x′)
 k ←Genh(1λ), (x, x′) ←A(k, σλ)
i
≤negl(λ)
(2)
Note that even if we heuristically expect the protocol to stay secure when we replace hk
with a ﬁxed hash function like SHA-256, to prove the security we need to sample the function
hk after the beginning of the protocol. The reason is that the adversaries are non-uniform (i.e.
get an arbitrary advice), and the advice could contain a collision if it was chosen after hk. As a
result, one needs to decide who is going to sample hk, leading to various tradeoﬀs:
– If we let a user12 sample the function, then we need to send an additional message from Bob
to Alice, but on the other side we are in the plain-model.
– Otherwise, we can assume that the circuit of hk is provided by a CRS, which requires no
additional round of communication, but we are not anymore in the plain-model.
In order to keep the proof independent of this choice, we abstract the distribution of the value
of hk in an ideal functionality:
Deﬁnition 2.11. Let {hk : {0, 1}l(λ) →{0, 1}m(λ)}k∈K be a family of collision resistant functions
generated by Gen, with a hardcore second-bit property. Then, we deﬁne the ideal functionality
F Gen
H
as follows. F Gen
H
receives an input c from Bob’s interface, if c = ⊤, the functionality samples
k ←Gen(1λ) and sends k to both parties, otherwise if c ∈K, it forwards c to Alice’s interface.
The ideal party AI just forwards the received k, while the ideal party BI sends c = ⊤to the
functionality and outputs the received k.
12Only Bob can sample the function as collision resistance must hold against Alice and a malicious Alice could
cheat when generating the function.
15

We prove now that this functionality can be realized in the plain-model with one message or
non-interactively in the CRS model.
Lemma 2.12 (FH in the CRS model). In the CRS model (a.k.a. F Gen
CRS-hybrid model), the
trivial 0-message protocol where both Alice and Bob output the value given by F Gen
CRS realizes the
functionality F Gen
H .
See proof in section A.
Lemma 2.13 (FH in the plain model). The 1-message protocol where Bob samples x ←
Gen(1λ) and sends x to Alice, and Alice outputs x only if x ∈K realizes the functionality F Gen
H
in the plain model.
See proof in section A.
3
Protocol for bit OT
3.1
The protocol
While we will deﬁne formally ZKoQS later, together with more advanced OT protocols (string-
OT, k-out-of-n OT. . . ), in this section we provide a self-contained description and security proof
of our bit-OT protocol. For an intuitive explanation of our protocol, we refer to the overview in
Section 1.2. The bit OT protocol is described in Protocol 1.
3.2
Security proof
We prove now our main theorem, i.e. that Protocol 1 securely realizes the OT functionality.
Theorem 3.1 (Security and correctness).
Let {hk}k∈K be a family of collision resis-
tant functions sampled by Gen, having the hardcore second-bit property (Deﬁnition 2.9). Let
Πh = (Ah, Bh) be a protocol13 CSSh-QSA realizing F Gen
CRS and Πzk = (Azk, Bzk) be a proto-
col that CSS-QSA realizes the ZK functionality F R
ZK, where (h0
0, h0
1, h1
0, h1
1)R(w0
0, w0
1, w1
0, w1
1) ⇔
∀c, d, h(d∥wc
d) = hc
d and ∃c, d such that wc
d[1] = 1.
Then the Protocol 1, in which h is obtained by ﬁrst running Πh, C-QSA realizes the function-
ality FOT . More precisely, it CSS′-QSA realizes FOT for any set S′ of unbounded parties such
that:
– S′ ⊆S ∩Sh,
– {B} ∈S′ only if h has the statistical hardcore second-bit property,
– {A} ∈S′ only if for any k ∈K, hk is injective (i.e. statistically collision resistant).
Sketch of proof. For a ﬁrst intuitive proof of the correctness and security, we refer to the
corresponding paragraph in Section 1.2. We provide here only a sketch of the proof, and we refer
the reader to the full security proof in section B.
13As a reminder, this protocol is sampling and distributing a function h according to Gen, and can either be done
without communication in the CRS model (or heuristically if we replace h with a well known collision-resistant
hash function), or with one message in the plain model.
16

Protocol 1: Protocol for 2-message chosen bit Oblivious Transfer
Alice(b ∈{0, 1})
Bob((m0, m1) ∈{0, 1}2)
// Witness for L(b) = {0, 1}:
∀d ∈{0, 1}, w(b)
d
$←{0} × {0, 1}n
// Witness for L(1−b) = {l}:
l
$←{0, 1}
w(1−b)
l
$←{0} × {0, 1}n
w(1−b)
1−l
$←{1} × {0, 1}n
// Compute the characterization
// of the languages:
∀(c, d) ∈{0, 1}2, h(c)
d
:= h(d∥w(c)
d )
h is a collision-resistant (Deﬁnition 2.10) and
second-bit hardcore (Deﬁnition 2.9) function dis-
tributed using FH (Deﬁnition 2.11), either non-
interactively via a CRS, heuristically using a ﬁxed
hash function, or sent by Bob, adding an additional
message (Lemma 2.13)
// Proof that at least one language
// contains a single element
π := (NI)ZK proof that:
If the ZK proof is interactive,
then we actually run the ZK
protocol (before sending the
quantum state) instead of send-
ing the proof (of course this
adds additional rounds of com-
munication).
∃(w(c)
d )c,d, ∀c, d, h(c)
d
= h(d∥w(c)
d ))
and ∃c, d s.t. w(c)
d [1] = 1.
// Deﬁne the quantum states:
r(b)
$←{0, 1}
|ψ(b)⟩:= |0⟩|w(b)
0 ⟩+ (−1)r(b) |1⟩|w(b)
1 ⟩
|ψ(1−b)⟩:= |l⟩|w(1−b)
l
⟩
∀(c, d) : h(c)
d , π, |ψ(0)⟩, |ψ(1)⟩
// Check that one language has size ≤1:
Check (or run if interactive proof) π.
// Check that the state contains a superposition
// of (valid) elements of L(0) and L(1):
∀c, apply on |ψ(c)⟩|0⟩the unitary:
x, w 7→w[1] ̸= 1 ∧∃d, h(x∥w) = h(c)
d ,
measure the last (output) register
and check that the outcome is 1.
∀c, measure the second register of |ψ(c)⟩
At that step, |ψ(b)⟩= |0⟩± |1⟩
and |ψ(1−b)⟩= |l⟩, but Bob does
not know b (NIZKoQS).
in the Hadamard basis (outcome s(c)).
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . End of NIZKoQS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
∀c, apply Zmc on |ψ(c)⟩and measure it
in the Hadamard basis (outcome z(c)).
∀c, s(c), z(c)
Compute α := r(b) ⊕⟨s(b), w(b)
0
⊕w(b)
1 ⟩
return α ⊕z(b)
// Should be mb
17

Case 2: malicious sender (Bob). We consider the case where the adversary A = ˆB corrupts
the sender Bob. Informally the goal of the simulator S ˆB is to extract the two values m0 and
m1 from ˆB to provide these two values to the ideal functionality. To that end, at a high level,
the simulator will interact with ˆB by providing a transcript that an honest Alice could provide,
except that |ψ(1−b)⟩is sampled like |ψ(b)⟩: since the state is now in the Hadamard basis, it can
also recover m1−b following the procedure used by Alice to recover mb. However, because it is
now impossible to run the ZK proof (because the statement is not even true!) the simulator will
run instead the simulator of the ZK proof to convince the distinguisher that the statement is
true while it is not. To prove that this simulator is valid, we write a series of hybrid games: we
start from the protocol where Alice is honest, then we replace the ZK proof with the simulated
proof (indistinguishable by the ZK property). In the next step we sample w1−b as a non-dummy
witness (i.e. starting with a 0, indistinguishable because the function h is hiding). Then we
set |ψ(1−b)⟩= |0⟩|w(1−b)
0
⟩+ (−1)r(1−b) |1⟩|w(1−b)
1
⟩where r(1−b) ←{0, 1} is sampled uniformly at
random (indistinguishable because the density matrices are equal: for any (potentially known)
string x and y, 1
2(|x⟩⟨x| + |y⟩⟨y|) = 1
4
P
r∈{0,1}(|x⟩+ (−1)r |y⟩)(⟨x| + (−1)r ⟨y|)). Note that one
might be worried that the output of Alice leaks additional information on this quantum state:
however, the output of Alice is linked with the other, non-dummy, quantum state and any
additional information regarding this dummy state are anyway discarded. Finally, we can now
apply the decoding performed by Alice on both outputs and output only the one corresponding
to mb: this is exactly the role of the ideal functionality. Since nothing depends on any secret
(except this very last step where the functionality discards m1−b and outputs mb), the simulator
can fully run this procedure. See the full security proof in section B for more details.
Case 3: malicious receiver (Alice). We consider now the case where the adversary A = ˆA
corrupts the receiver Alice.
Informally the goal of the simulator S ˆA is to extract the value b from Alice in order to
provide this value to the ideal functionality, and to appropriately use the mb provided by the
functionality to fake measurement outcomes expected by Alice. At a high level, since the ZK
protocol is a (state-preserving) proof (or argument) of knowledge (PoK), we can use this property
to extract the witnesses (w(c)
d )c,d. From this witness we can ﬁnd a w(b)
d
that starts with a 1 in
order to learn b. Then, to fake the measurement outcomes, the simulator can apply exactly
the same quantum operations as the one done by the honest Bob, using the mb given by the
functionality, except that the simulator will choose m1−b = 0. Note that if the malicious Alice
really sent a state |ψ(1−b)⟩in the computational basis, then the Zm1−b rotation does nothing,
irrespective of the value of m1−b. Now, if Alice sent a state that is in superposition of two
pre-images with non-negligible amplitude, since it must pass the test checking that it contains
non-dummy preimage of h, then it means that Alice “knows” a collision for h. . . or rather, we
can measure the state to get a ﬁrst preimage and compare it with the preimages extracted during
the ZK protocol to get another preimage: with non-negligible probability (on the measurement
outcome) they will be diﬀerent, breaking the collision resistant property of h which contradicts
our assumption. Note that some care must be taken as the probability of ﬁnding a collision
diﬀers across runs, but we can formalize this argument as shown is the full proof. In practice, we
will deﬁne a few hybrid games, by ﬁrst replacing the distribution of h and the ZK protocol by
their simulated versions (since the ZK is a PoK, the simulator can learn b and the preimages
of h), then we remove the Zm1−b rotation (indistinguishable or the state is far from a state in
the computational basis, in which case we can recover a collision). Finally, since this does not
18

depend on the secret m1−b, we can reorganize the elements to recover the ideal word. See the
full security proof in section B for more details.
4
(NI)ZKoQS and k-out-of-n string OT
4.1
ZKoQS
The main contribution in our main protocol (Protocol 1) is to provide a method to prove
(potentially non-interactively) a statement on a received quantum state without revealing much
information beside the fact that this statement is true: we call this property (Non-Interactive)
Zero-Knowledge proofs on Quantum State ((NI)ZKoQS), by analogy with their classical analogue.
While we have not yet introduced formally this deﬁnition in order to provide a self-contained
OT protocol and proof, we will address this issue here.
NIZKoQS were introduced in [CGK21], but the protocol we present here is using a very
diﬀerent approach. While [CGK21] can be used to prove more advanced properties on the
obtained quantum state, it also has multiple drawbacks that were left as open questions:
– First, while their protocol is purely classical, their approach is fundamentally incompatible
with statistical security (like other potential approaches based on quantum multi-party
computing [DNS12, DGJ+20, KKM+21], since these protocols build upon classical MPC,
which are not only impossible to do with statistical security [Lo97], but they also require
OT, which is one application of ZKoQS). A malicious unbounded veriﬁer/receiver can always
fully describe the received state. On the other hand, with our approach we can get statistical
security for both parties (not as the same time).
– Secondly, [CGK21] relies on lattice based cryptography (LWE), living in Cryptomania, and
the protocol is really costly to implement in practice as the parameters used in the LWE
instance lead to very large functions. On the other side, our approach only relies on hash
functions, does not exploit any structure or trapdoors, and is therefore much more eﬃcient.
Note that the deﬁnition of ZKoQS introduced in [CGK21] is slightly too restrictive for our
setting as their notion of quantum language does not allow states to be ε-close to the quantum
language, the states cannot be entangled with an adversary, they omit the step where the
description is given back to the sender (which is important when the protocol is used in other
protocols), and their adversaries are QPT. For this last reason, we introduce diﬀerent notations
inspired by classical ZK proofs: when the prover is unbounded (resp. bounded) we say that we
have a ZK proof (resp. argument) on quantum states, denoted ZKPoQS (resp. ZKAoQS). When
the veriﬁer is unbounded, we say that we have a statistical ZKoQS (S-ZKoQS). Note than when
the protocol in Non-Interactive (a single message from the prover to the veriﬁer), we replace the
“ZK” with “NIZK” in these acronyms. We formalize now these concepts.
Quantum language. First, we deﬁne a quantum language (we draw a parallel with classical
ZK in Fig. 3, and illustrate this with an example in Example 4.1), which is informally speaking
a set LQ of bipartite quantum states on two registers V and P that characterizes all states that
a malicious adversary might be able to obtain (the register V being controlled by the honest
veriﬁer, and P by the malicious prover and/or the environment14). Moreover, we also provide
14Sometimes, we will write (P, Z) instead of P to denote a more precise cut between the two sub-registers
owned by the prover and the environment.
19

(x, w)
x
P
V
⊤/⊥
(a) Usual setting of classical ZK protocols: we
typically have x ∈Lw, with Lw := {x | xRw}.
(x, w)
P
V
x/⊥
(b) Alternative equivalent setting of classical
ZK protocols.
w
P
V
x
x/⊥
(c) Another alternative setting of classical ZK
protocols (e.g. if x can be derived from w). We
expect x ∈Lw.
ω
P
V
ωs
ρ/⊥
(d) Setting of ZK on Quantum States: ρ is the
(quantum) equivalent of x, and (ω, ωs) can be
seen as a (partial, see (cf. Remark 4.2)) classical
description of ρ: we expect ρ ∈Lω,ωs.
Fig. 3: Parallel between classical ZK and ZK on Quantum States: while classically all the above
deﬁnitions are mostly equivalent, quantumly we cannot send ρ (the quantum equivalent of x)
as an input since the laws of physics forbid us from extracting any information from ρ without
altering it. See also Remark 4.2 for the justiﬁcation of the choice of ω and ωs.
additional information on the honest expected behavior, via sets of (bipartite15) quantum states
Lω ⊆LQ: when the prover is given as input a class ω (the quantum equivalent16 of witnesses),
we expect the ﬁnal state to belong to Lω. Because there might be many states in Lω, the prover
will also output a subclass ωs to further describe the ﬁnal state, interpreted as “the veriﬁer
obtained a state belonging to Lω,ωs ⊆Lω ⊆LQ”.
Example 4.1. For instance, one might be interested in LQ deﬁned as the set of states where the
registers V contains exactly two qubits, where at least one of them is non-entangled with any
other qubit and collapsed in the computational basis (think “even if the prover is malicious,
any state obtained by the prover belongs to LQ, i.e. contains at least one qubit collapsed in the
computational basis). For the honest behavior, we can for instance deﬁne L0,0 = {|+⟩|0⟩, |+⟩|1⟩},
L0,1 = {|−⟩|0⟩, |−⟩|1⟩}, L1,0 = {|0⟩|+⟩, |1⟩|+⟩}, L1,1 = {|0⟩|−⟩, |1⟩|−⟩}, L0 = L0,0 ∪L0,1 and
L1 = L1,0 ∪L1,1: this way, if the prover gets input 0 and outputs 1, the veriﬁer is expected to
output a state in L0,1 = {|−⟩|0⟩, |−⟩|1⟩}: the class ω represents the position of the state in the
Hadamard basis, and the sub-class ωs represents the value encoded in this state.
Remark 4.2 (On the choice of deﬁnition of ω and ωs). Note that (ω, ωs) only partially describes
the state (in our example above, we remove the description of the state in the computational
15Contrary to LQ that must represent all states potentially obtainable by a malicious party (hence the need for
a second register), here Lω are only used to denote the states obtainable by honest parties, and can therefore
often be seen as a set of states on a single register owned by the veriﬁer. The reason we deﬁne it as a bipartite
state here is that we might later be interested by the generation of truly bipartite states like graph states.
16Note that classically, we can see a witness in two diﬀerent ways: it can be used to eﬃciently verify that x ∈L,
but more abstractly it can be seen as a way to partition L into multiple Lw’s: in an honest setting, given w, we
expect to have x ∈Lw, where Lw = {x | xRw}. Quantumly, we will use this second point of view, as given ω (the
quantum equivalent of w) we expect in an honest setting to have ρ ∈Lω, even if ω cannot be used directly to
verify that property once ρ is generated because of the laws of physics.
20

basis) as otherwise we are unable to prove the security of the scheme (but the lost information
on ρ is anyway of no interest since it is discarded in the OT protocol). One might also ask why
ωs is sent as an output and is not part of the input ω: while in some cases it might be possible
to move everything inside the input ω and remove ωs (e.g. if we got a |+⟩instead of a |−⟩the
prover could send another message “apply an additional Z gate” to ﬂip the encoded qubit), but
this comes at the cost of an additional message. In most applications, the exact value of ωs does
not really matters as it is only a random key, while saving an additional round of communication
is important.
Deﬁnition 4.3 (Quantum Language). Let EV,P = ∪(n,m)∈N2L◦(Hn ⊗Hm) be the set of ﬁ-
nite dimensional quantum states on two registers. A quantum language (LQ, C, Cs, {Lω,ωs}ω∈C,ωs∈Cs)
is characterized by a set LQ ⊆EV,P of bipartite quantum states17, a set C ⊆{0, 1}∗of
classes (or witnesses) motivated above, a set Cs ⊆{0, 1}∗of sub-classes, and for any ω ∈C,
ωs ∈Cs, a set Lω,ωs of bipartite quantum states called quantum sub-classes. We also de-
ﬁne for any ω, Lω = ∪ωs∈CsLω,ωs (some of these sets might be empty in case ω is not a
valid class), and require ∪ωLω ⊆LQ. Moreover, for any set of quantum states L, we deﬁne
ρ ∈ε L ⇔∃σ ∈L, TD(ρ, σ) ≤ε, and ρ /∈ε L ⇔¬(ρ ∈ε L).
ZKoQS. We introduce now ZKoQS, that morally provides three guarantees, similar to classical
ZK (cf. Fig. 3):
– Correctness: if the parties are honest, the prover is given a class ω and ends up with the
partial (cf. Remark 4.2) description (ω, ωs) of the state ρ obtained by the prover, i.e. such
that ρ ∈Lω,ωs ⊆Lω ⊆LQ.
– Soundness: if the sender is malicious, the honest receiver still ends up with a state ρ ∈LQ.
– Zero-Knowledge: if the veriﬁer is malicious, they cannot learn the value of the class/witness
ω.
Example 4.4. To continue our above Example 4.1, the correctness guarantees that given an
input bit ω ∈{0, 1}, the ω-th qubit of ρ is H |ωs⟩while the other qubit is in the computational
basis (we lose the information of the encoded value). The soundness mostly guarantees that even
if the sender is malicious, the received quantum state contains at least one qubit collapsed in
the computational basis. The ZK property guarantees that a malicious veriﬁer cannot learn ω,
the expected position of the qubit in the Hadamard basis.
Note that the formal deﬁnition is given with respect to a “simulator”, simulating the whole
protocol (and not anymore a single malicious party as usual), including in the soundness and
correctness part (while usually simulators are only used in the ZK part). While we could deﬁne
it without any simulator to get a more restricted deﬁnition (and during a ﬁrst read, it might
actually be easier to replace the simulator with the original process), simulators are helpful for
multiple reasons to make the deﬁnition more useful:
– In zero-knowledge: the typical ZK deﬁnitions already use simulators to denote the fact the
we can simulate the view of the malicious veriﬁer without access to the witness. . . Therefore
it should come at no surprise that we also use a simulator in the ZK property.
17LQ represents informally the set of states that any malicious party can generate, where the ﬁrst register is the
output of the veriﬁer and the second register corresponds to registers potentially controlled by an adversary. Since
only LQ is needed to characterize the security of a protocol, it is sometimes called directly the quantum language.
21

– In soundness: In a real protocol, a malicious prover might be able to produce states
negligibly close (in trace distance) to the quantum language LQ, but not strictly speaking in
LQ. One might be tempted to introduce an approximate notion ρ ∈ε LQ taking into account
trace distance to ﬁx this issue, unfortunately it is not suﬃcient as this deﬁnition does not
take into account states that are statistically speaking far from LQ, but computationally
speaking “close” to LQ. . . Indeed, sometimes provers might actually be able to produce
states far (in trace distance) from any state in LQ, but because they are computationally
bounded, they are unable to exploit that fact. This kind of false “attack” can actually be
done against our protocol if the function h is not injective (explaining why we require h
to be injective when considering an unbounded malicious receiver), by simply running the
ZK protocol in superposition18: in that case the output state might be relatively close to
a |+⟩or |−⟩if h is well balanced (while we expect the state to be close to |0⟩or |1⟩), but
a computationally bounded receiver cannot exploit this property as they need to compute
all preimages of h to know if we are close to |+⟩or |−⟩. Simulator are therefore useful in
the soundness deﬁnition to capture this “computational distance”, and discard ineﬀective
attacks.
– In correctness: Perhaps surprisingly, we also use a simulator in the correctness deﬁnition.
While this might not be useful when considering only a game-based security notion, we need
simulator to prove for instance statements like “If a protocol Π realises a given functionality,
then this protocol is a ZKoQS protocol” (see e.g. Theorem 4.10). Without further details on
Π, the correctness of Π only tells us that Π is indistinguishable from a functionality that
produces states in LQ, but it does not mean that Π itself produces such states, hence the
need for a simulator.
We formalize the notion of ZKoQS:
Deﬁnition 4.5 (Zero-Knowledge Proof on Quantum State (ZKoQS)).
Let L := (LQ, C, Cs, {Lω,ωs}ω∈C,ωs∈Cs) be a quantum language (Deﬁnition 4.3). We say that a
protocol Π = (P, V) is a ZKoQS protocol for L, where P takes as input a class ω ∈C and outputs
a sub-class ωs ∈Cs and19 a quantum state ρP, and V takes no input and outputs a bit a, that is
equal to 1 if V does not abort, together with a quantum state ρV (potentially entangled with ρP),
if the following properties are respected:
– Correctness: There exists a poly-time simulator S and a negligible function ε such that
(P ↭V) ≈c S, and for any ω such that Lω ̸= ∅:
Pr
h
a = 1 ∧ρV,P ∈Lω,ωs
 ((ωs, ρP), (a, ρV)) ←S(ω)
i
= 1
(3)
– Soundness: For any malicious prover ˆP = {ˆPλ}λ∈N, (QPT for ZKAoQS, unbounded for
ZKPoQS) there exists a simulator SˆP = {Sλ,ˆP}λ∈N (running in time polynomial in the
runtime of ˆP) such that (ˆP ↭V) ≈c SˆP (≈s for ZKPoQS), and such that there exists a
negligible function ε such that for any sequence of bipartite state {σP,Z
λ
}λ∈N and λ ∈N:
Pr
h
a = 1 ∧ρV,(P,Z) /∈LQ
 (ρP, (a, ρV), ρZ) ←(SP
λ,ˆP ⊗IZ) ⊗σP,Z
λ
i
≤ε(λ)
(4)
18Of course by still measuring the classical transcript to send to the veriﬁer.
19ρP will actually not be necessary in our main application, but we still include it in case it turns out to be
useful in future applications.
22

– Quantum Zero-Knowledge: For any malicious veriﬁer ˆV = {ˆVλ}λ∈N (QPT for ZKoQS,
unbounded for S-ZKoQS), there exists a simulator SˆV(b, ·) (where b ∈{0, 1} indicates if Lω
is non-empty, and · represents an additionally quantum input from the environment), and an
eﬃciently computable map ξ·(·) (such that ∀ω, ξω takes one quantum register as input and
outputs a classical message in Cs and a quantum state ρP), both running in polynomial time
in the runtime of ˆV, such that for any ω ∈C:
(P(ω) ↭ˆV) ≈c (ξω ⊗I)(SˆV(Lω ̸= ∅))
(5)
(≈s for ZKPoQS)
It can sometimes be handy to cut the protocol into two phases: the honest veriﬁer will output the
state ρV at the end of the ﬁrst send phase, wile the output of the honest prover will be delivered in
a second describe phase (allowing the prover to describe the state outputted earlier by the veriﬁer).
A ZKoQS protocol where each phase consists of a single message is said to be non-interactive
(denoted NIZKoQS, we can similarly add the “NI” preﬁx to the previously seen notions, to get
NIZKPoQS, S-NIZKoQS. . . ). Finally, for a set of parties S, we write ZKoQSS to denote the
fact that the protocol is S-ZKoQS if V ∈S and ZKPoQS if P ∈S.
Note that in ZK protocols, there is a notion of extractability, where a simulator can extract
the witness w from a valid transcript (not all ZK protocols are extractable). We could deﬁne a
similar notion here allowing the simulator to extract ω, but since LQ might contain states not
belonging to any Lω (potentially producible by malicious provers), we need to slightly update
the deﬁnition of quantum language by also introducing a special “malicious” subclass ⊥, so that
LQ = ∪ω(Lω ∪Lω,⊥), and such that the simulator in the soundness property can extract the ω
of the state produced by a malicious adversary:
Deﬁnition 4.6 (Extractability). A ZKoQS protocol is said to be extractable with respect to
(Lω,⊥)ω∈C (⊥being a special subclass not belonging to Cs) such that LQ = ∪ω(Lω ∪Lω,⊥), and
such that the soundness property is turned into:
– Extractability: For any malicious prover ˆP = {ˆPλ}λ∈N, (QPT for ZKAoQS, unbounded
for ZKPoQS) there exists a simulator SˆP = {Sλ,ˆP}λ∈N (running in time polynomial in the
runtime of ˆP) such that (ˆP ↭V) ≈c SˆP (≈s for ZKPoQS), and such that there exists a
negligible function ε such that for any sequence of bipartite state {σP,Z
λ
}λ∈N and λ ∈N:
Pr
h
a = 1 ∧ρV,(P,Z) /∈(Lω ∪Lω,⊥)
 (ρP, (a, ρV), ρZ, ω) ←(Sλ,ˆP(σP
λ)) ⊗σZ
λ
i
≤ε(λ)
(6)
4.2
Proof of partial measurement: a generic framework to get ZKoQS
While the notion of ZKoQS (Deﬁnition 4.5) does not explicitly mention functionalities, it is
often handy to model a ZKoQS protocol inside an ideal functionality as it is easier to interpret
it and use it inside other protocols. While it is not clear how to translate the ZKoQS deﬁnition
into a functionality, we provide below a few ideal functionalities that “imply” ZKoQS. We will
ﬁrst see what is a ZKoQS ideal functionality, then we will see a class of functionalities that are
ZKoQS, and we will show that our protocol realizes a particular case of these functionalities.
Deﬁnition 4.7 (ZKoQS ideal functionality). Let (LQ, C, Cs, {Lω,ωs}ω∈C,ωs∈Cs) be a quan-
tum language (Deﬁnition 4.3). We say that an ideal functionality F is a ZKoQS (resp. ZKoQSS)
ideal functionality for LQ iﬀfor any protocol Π = (P, V) that quantum standalone realizes F (resp.
CSS-QSA-realizes F), Π is a ZKoQS protocol (resp. ZKoQSS protocol) for LQ (Deﬁnition 4.5).
23

The most natural class of ideal functionalities leading to ZKoQS are the ones in which the
functionality applies an operation (a partial measurement) on an arbitrary input to enforce some
structures on the output state:
Deﬁnition 4.8 (Partial measurement F M,f0
PartMeas).
Let M := {Mm}m∈M be a collection
of measurement operators20 (i.e. operators such that P
m M†
mMm = I [NC10, Sec. 2.2.3]),
implementable in quantum polynomial time, and let f0 : M →Cs be an eﬃciently computable
function21. Then, we deﬁne the proof of partial measurement functionality F M,f0
PartMeas as follows:
– F M,f0
PartMeas receives a state ρ from the prover’s interface, together with an abort bit a.
– If a = ⊥, it sends ⊥to both parties and stops.
– Otherwise, F M,f0
PartMeas measures ρ using M, obtaining an outcome m ∈M and a post-
measured state
ρ′ := ξm(ρ) :=
MmρM†
m
Tr(M†
mMmρ)
(7)
– It sends ρ′ to the veriﬁer, and waits back for a message f, such that either f = ⊥(in
which case the functionality sends ⊥to the prover to abort and stops), f = ⊤(in which
case the ideal functionality redeﬁnes f := f0), or f is an eﬃciently computable function
f : M →{0, 1}∗.
– Finally, it sends f(m) to the prover.
We would like to prove that this functionality is a ZKoQS functionality, but not all such
functionalities are ZKoQS (in particular, if the post-measured state contains information on
ω, it has no chance of being ZK). For this reason, we expect our functionality to have an
additional property, intuitively saying that we can postpone the actual measurement after
sending the quantum state. While this might seem counter intuitive, this can actually be realized
exploiting entanglement, and similar techniques were used in previous works to prove security of
protocols [DFP+14].
Deﬁnition 4.9 (Postponable measurement operator). A measurement operator M out-
putting a quantum state and a classical measurement outcome is said to be postponable with
respect to a collection of sampling procedures {Gω}ω∈A outputting a quantum state if there exist
a bipartite state ρV,F and a quantum map M′ taking as input a bipartite system and outputting
a measurement outcome m′ such that for all ω ∈A, MGω ≈s (IV ⊗M′)(ρV,F ⊗Gω):
Gω
M
=
Gω
ρ
M′
(8)
We prove now that such a functionality is a ZKoQS functionality for a given quantum
language and appropriately deﬁned dummy ideal parties:
Theorem 4.10 (FPartMeas implies ZKoQS).
Let EV0,P = ∪(n,m)∈N2L◦(Hn ⊗Hm) be the
set of ﬁnite dimensional quantum states on two registers V0 and P. Let C and Cs be two sets,
20They are the most generic way to represent a measurement.
21Informally, f0 is used to ﬁlter some information on the measurement outcome m during an honest protocol.
24

and for any ω ∈C, let Eω ⊆EV0,P be a set of bipartite quantum states. Let M := {Mm}m∈M be
a collection of measurement operators (and ξm as deﬁned in Deﬁnition 4.8), and f0 : M →Cs
be a function. We deﬁne for any ω ∈C and ωs ∈Cs:
Lω,ωs := {ρV,P | ∃ρV0,P
0
∈Eω, m ∈M, s.t. ωs = f0(m), ρV,P = ξm(ρV0,P
0
)}
(9)
Lω := ∪ωsLω,ωs
(10)
LQ := {(ξm ⊗ˆξf0(m))ρV,(P,Z) | ρ ∈EV0,(P,Z), m ∈M, m ̸= ⊥,
ˆξf0(m) being an arbitrary CPTP map depending on f0(m).}
(11)
Then, let ˜P and ˜V be any poly-time ideal parties, such that:
– If Eω = ∅, ˜P(ω) sends the abort bit a = ⊥to the functionality and outputs ⊥. Otherwise, ˜P(ω)
produces a state in Eω according to an arbitrary sampling procedure G, sends the register V0
to the ideal functionality, and outputs the ωs given back from the functionality together with
the register P.
– If ˜V receives ⊥from the functionality, it outputs a = ⊥and stop. Otherwise, it outputs the
state ρ′ given by the functionality together with a bit a = ⊤and sends back to the functionality
f = ⊤.
Then, if M are postponable measurement operators with respect to {Gω}ω,Lω̸=∅(Deﬁnition 4.9),
F M,f0
PartMeas is a ZKoQS protocol (actually ZKoQSS for any set S, see Deﬁnition 4.7) for the
language LQ previously deﬁned.
Sketch of proof. The proof mostly derives from the deﬁnitions, and from the fact that having
postponable operators allows us to push the part of the ideal functionality that depends on the
secret after the interaction with the adversary, preserving the ZK property. We refer to the full
security proof in section C for more details.
While the above results show that we can obtain a ZKoQS protocol from any protocol
realizing the functionality F M,f0
PartMeas (where M must be postponable), we show in the next
section how we can realize such a functionality to prove that a state was partially collapsed
(measured in the computational basis) without revealing the position of the collapsed qubit. We
will then see that, as a corollary, there exists a ZKoQS protocol for the quantum language of
“semi-collapsed” states.
4.3
Protocol to prove that a state has been semi-collapsed
We prove now that we can realize the functionality below, that informally measures a set T of
qubits (the measured qubits, chosen by the prover, being constraint to respect Pred(T) = ⊤, for
an arbitrary predicate Pred), randomly rotates the other one, and provides the resulting state
to the veriﬁer.
Deﬁnition 4.11 (Semi-collapsing functionality F Pred
SemCol). Let n ∈N, and Pred: P([n]) →
{⊤, ⊥} be an eﬃciently computable predicate on the subsets of [n]. We deﬁne the semi-collapsing
functionality F Pred
SemCol as F M,f0
PartMeas (Deﬁnition 4.8), where:
– M is the measurement operator that receives a quantum state on two registers, measures
the ﬁrst register22 in the computational basis to get (an encoding of) T ⊆[n], checks if
22Informally this register contains the subset of qubits in the second register to measure. Since the ﬁrst operation
of M is to measure them, we can (and will) also consider them as classical inputs.
25

Pred(T) = ⊤: if not it outputs m = ⊥and a dummy quantum state |⊥⟩. Otherwise, it
measures (non-destructively) in the computational basis all qubits in the second register
whose index belongs to the set of “target” qubits T, getting outcomes {m(j)}j∈T , and for any
i ∈[n] \ T, it samples a random bit r(i)
$←{0, 1}, and applies Zr(i) on the i-th qubit. Finally
it outputs m = (T, (m(j))j∈T , (r(i))i∈[n]\T ) and the post-measured state.
– If m = ⊥, f0(m) = ⊥, otherwise if m = (T, (m(j))j∈T , (r(i))i∈[n]\T ), f0(m) = (r(i))i∈[n]\T ).
We also consider the following dummy ideal parties:
– ˜P(T, ρ) sends a = Pred(T) and ρ to the ideal functionality F Pred
SemCol, and it forwards the
received message from the functionality.
– ˜V checks if it receives a = ⊥from the functionality, or if the received quantum state is |⊥⟩.
If so it sends back f = ⊥to the functionality and aborts, and otherwise it sets f = ⊤for the
functionality and outputs the quantum state to the environment.
We prove now that we can realize the functionality F Pred
SemCol:
Theorem 4.12 (Realization of F Pred
SemCol).
Let {hk}k∈K be a family of collision resistant
functions sampled by Gen, having the hardcore second-bit property (Deﬁnition 2.9). Let Πh =
(Ph, Vh) be a protocol23 CSSh-QSA realizing F Gen
CRS and Πzk = (Azk, Bzk) be a protocol that
CSS-QSA realizes the ZK functionality F R
ZK, where (h(c)
d )c∈[n],d∈{0,1}R(T, (w(c)
d )c∈[n],d∈{0,1}) ⇔
Pred(T) = ⊤∧∀c, d, h(d∥w(c)
d ) = h(c)
d
and ∀c ∈T, ∃c such that w(c)
d [1] = 1.
Then, the protocol ΠSemCol (Protocol 2) CSS′-QSA-realizes F Pred
SemCol for any S′ such that:
– S′ ⊆S ∩Sh,
– {P} ∈S′ only if h has the statistical hardcore second-bit property,
– {V} ∈S′ only if for any k ∈K, hk is injective (i.e. statistically collision resistant).
Sketch of proof. Part of the proofs of this theorem are generalizations of Theorem 3.1. Some
care must be taken to show that the distributions in the honest case (ideal world versus real
world) are really indistinguishable, we do so by computing the appropriate density matrices.
There is also a slight diﬀerence as here we measure the state instead of applying a rotation, but
it turns out that measuring is indistinguishable from rotating a state and discarding the rotation
angle. We refer to the full security proof in section C for more details.
We will see that the F Pred
SemCol functionality can be used to trivially get more advanced OT
protocols, notably string OT and k-out-of-n OT for any k and n. But ﬁrst, we prove that it
is a ZKoQS functionality for the quantum language of “semi-collapsed” states with respect to
a predicate Pred. Informally, we deﬁne the quantum language of semi-collapsed states as the
set states such that there exists a subset T of qubits such that Pred(T) = ⊤, and such that
all qubits in T are collapsed, i.e. measured in the computational basis and equal to |0⟩or |1⟩
(therefore not entangled with any other system). Moreover, the identity of the set T of collapsed
qubits stays hidden to a malicious veriﬁer, and in an honest protocol the non-collapsed qubits
are either a |+⟩or a |−⟩, this description being known to the prover.
23As a reminder, this protocol is sampling and distributing a function h according to Gen, and can either be done
without communication in the CRS model (or heuristically if we replace h with a well known collision-resistant
hash function), or with one message in the plain model.
26

Protocol 2: ZKoQS protocol to realize F Pred
SemCol
P(T ⊆[n], ρ(1),...,(n))
V
// T is a subset of qubits to measure.
Run Ph to obtain h.
Run Vh to obtain h.
h is a collision-resistant (Deﬁnition 2.10) and
second-bit hardcore (Deﬁnition 2.9) function dis-
tributed using FH (Deﬁnition 2.11), either non-
interactively via a CRS, heuristically using a ﬁxed
hash function, or sent by the veriﬁer, adding an ad-
ditional message (Lemma 2.13)
If Pred(T) = ⊥abort and send ⊥to V.
∀d ∈{0, 1}, i ∈[n] \ T, w(i)
d
$←{0} × {0, 1}n
∀j ∈T, l
$←Measure non destructively ρ(j)
w(j)
l
$←{0} × {0, 1}n
w(j)
1−l
$←{1} × {0, 1}n
// Compute the characterization
// of the languages:
∀(c, d) ∈T × {0, 1}, h(c)
d
:= h(d∥w(c)
d )
π := (NI)ZK proof that:
If the ZK proof is interactive,
then we actually run the ZK
protocol (before sending the
quantum state) instead of send-
ing the proof (of course this
adds additional rounds of com-
munication).
∃T ⊆[n], (w(c)
d )c∈T,d∈{0,1},
∀c, d, h(c)
d
= h(d∥w(c)
d )
and ∀j ∈T, ∃d s.t. w(j)
d [1] = 1,
and Pred(T) = ⊤.
∀i ∈[n] \ T, r(i)
$←{0, 1}
∀i ∈[n] \ T, applies Zr(i)ρ(i)
∀c ∈[n], Apply on ρ(c): |x⟩7→|x⟩|w(c)
x ⟩
(call ρ(1),...,(n)
1
the resulting state)
∀(c ∈[n], d ∈{0, 1}) : h(c)
d , π, ρ(1),...,(n)
1
If Alice sent an abort message ⊥, return ⊥
Check (or run if interactive proof) π.
∀c, apply on ρ(c)
1
⊗|0⟩⟨0| the unitary
implementing:
x, w 7→w[1] ̸= 1 ∧∃d, h(x∥w) = h(c)
d ,
measure the last (output) register
and check that the outcome is 1.
∀c, measure the second register of ρ(c)
1
in the Hadamard basis (outcome s(c)).
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . End of the send procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
return Remaining (ﬁrst) qubit of each ρ(i)
1 .
∀c, s(c)
Compute:
ωs := (r(i) ⊕⟨s(i), w(i)
0
⊕w(i)
1 ⟩)i∈[n]\T
return ωs
27

Remark 4.13. Note that the predicate Pred might (implicitly24) depend on an additional secret
classical witness (like a password, a signature provided by some trusted parties, or any NP
statement) only known by the prover. This can allow the prover to prove even more advanced
statements, like “Either all states are collapsed, or I am the owner of this bitcoin wallet and a
single state is collapsed”, which can for instance be useful to obtain “anonymous authorized OT”
(i.e. an OT protocol where only parties knowing the witness can participate, while the sender
never knows if the receiver knows the witness or not).
Deﬁnition 4.14 (Semi-collapsed states LPred
SemCol). The quantum language LPred
SemCol of semi-
collapsed states relative to a predicate Pred: P([n]) →{⊤, ⊥} on the subsets of qubits is
composed of the classes C = P([n]) (denoting the set of collapsed qubits), the sub-classes
Cs = {s ∈{0, 1}∗| |s| ≤n} (denoting the description of the non-collapsed qubits), and the
quantum (sub-)classes deﬁned as follows, for any T ∈C and ωs ∈Cs:
– LT,ωs is the empty set if Pred(T) = false or if |ωs| ̸= |T|, and otherwise is the set of all
n-qubits states where qubits in T are either |0⟩or |1⟩, and other qubits i (i ∈{1, . . . , |T|} is
the index of the qubits in [n] \ T) are equal to |+⟩if ωs[i] = 0 and |−⟩otherwise.
– LPred
SemCol is the set of bipartite states on registers P and V such that V contains n qubits, and
such that there exists T ⊆[n] such that Pred(T) = ⊥and for any i ∈T, i-th qubit of register
V is not entangled with any other qubit and either |0⟩or |1⟩.
Corollary 4.15 (ZKoQS for semi-collapsed states). Let G(T) be the procedure that sam-
ples (r(i))i∈[n]
$←{0, 1} and outputs the quantum state N
i Hδi/∈T |a(i)⟩(i.e. all qubits in T are in
the computational basis, others are in the Hadamard basis).
The functionality F Pred
SemCol (where the ideal party ˜P is slightly updated25: instead of receiving
T and ρ, it receives T ⊆[n], and samples ρ ←G(T), before continuing as usual) is a ZKoQS
ideal functionality (Deﬁnition 4.7) for the quantum language LPred
SemCol (Deﬁnition 4.14).
In particular, if we consider the protocol where the honest prover gets as input T, picks
ρ ←G(T), and runs Protocol 2, this protocol is a ZKoQS protocol for the quantum language
LPred
SemCol.
This is mostly a corollary of Theorem 4.10. The only non-trivial statement is to prove that
the measurement is postponable: this can be done by teleporting the state without applying any
correction. See proof in section C.
4.4
ZKstatesQIPS[k] and ZKstatesQMAS: ZKoQS from a complexity theory point
of view
While we deﬁned ZKoQS using a “cryptographic” deﬁnition, we can also consider them from the
point of view of complexity theory. While classically, complexity classes involve a veriﬁer taking
an input x potentially belonging to a given classical language L, and outputting a single accept
bit (this is not an issue as the input x can anyway be copied by the veriﬁer if it needs to be
used later), for quantum languages this deﬁnition turns out to be hard (or even impossible) to
use as the veriﬁcation procedure will alter the input state. ([KA04] does something along that
24In which case, the witness must be used to generate the ZK proof.
25F Pred
SemCol can be used for any input quantum state, but for the ZKoQS we need to consider a particular case
where the initial state is picked by the party instead of by the environment. The reason is that in ZKoQS protocols,
an honest prover is only given as input a class.
28

line, but needs to send many copies of the input state, which is of little interest in cryptography
as it leads to polynomial security.) To overcome this issue, it is therefore natural to say that the
quantum state belonging to the quantum language must be an output of the veriﬁer. This is the
successful point of view that we took above, and a similar approach has also been used before
in [RY22] to quantify the complexity to produce a given state by deﬁning a complexity class
stateQIP. However, the class stateQIP only captures how hard it is to generate a given state, but
it does not capture any notion of privacy against a malicious veriﬁer. The following deﬁnition
addresses this issue:
Deﬁnition 4.16 (ZKstatesQIPS[k] and ZKstatesQMAS). Let L be a quantum language (Def-
inition 4.3), k ∈N be a number of exchanged messages, S ∈{∅, P, V} be a subset of parties
allowed to be unbounded, and setup be a given setup assumption (e.g. CRS, Random Oracle, or
plain-model). We say that L belongs to the complexity class ZKstatesQIPsetup
S
[k] if there exists a
ZKoQSS protocol for L, secure assuming the setup assumption setup, whose send phase consists
of k exchanged messages (note that we might omit S, setup, or k if we do not want to constraint
this parameter).
Similarly, we deﬁne ZKstatesQMAsetup
S
= ZKstatesQIPsetup
S
[1] to capture non-interactive pro-
tocols.
Remark 4.17. Note that [RY22] deﬁnes multiple complexity classes like stateQIP (update: sim-
ilarly, [DGL+23], that was uploaded online a day after our own work, deﬁnes stateQMA): it
is therefore natural to want to compare stateQIP and ZKstatesQIP, similarly to the result
stateQIP = statePSPACE presented in [MY23]. However, note that since [RY22] and [DGL+23]
mostly care about the complexity required to create quantum states, there is no notion of hiding
or witnesses26: expressed with our terminology, their quantum languages have a single element
(for a ﬁxed, public, n) |ψn⟩. Said diﬀerently, the veriﬁer knows in advance the state |ψn⟩that
will be generated with the help of the prover. On the other side, we have no reasons to introduce
in ZKstatesQIP an asymptotic parameter n denoting the size of the quantum state obtained by
the veriﬁer, as ZKoQS already makes sense for a ﬁxed n = 2 (but of course, nothing prevents LQ
from containing states of various sizes). However, it might be possible to generalize the deﬁnition
of [RY22] by replacing (|ψn⟩)n∈N with LQ, where the parameter n could represent the size of
the state obtained by the veriﬁer, or to consider a sequence of quantum languages (LQ,n)n∈N, in
order to deﬁne statesQIP (the additional s being used to denote the fact that the veriﬁer might
produce a state among multiple, valid, candidates). However, properly generalizing [RY22] and
deﬁning statesQIP/statesQMA is out of the scope of this paper.
We prove now that LPred
SemCol belongs to these classes:
Corollary 4.18 (LPred
SemCol is in ZKstatesQMARO). For any predicate Pred, the quantum lan-
guage LPred
SemCol belong to ZKstatesQMARO (where RO stands for Random Oracle model). Moreover,
assuming the hardness of LWE (see [HSS11] for the exact assumptions), LPred
SemCol belongs to
ZKstatesQIPpm (where pm stands for plain-model).
More generally, assuming the existence of a k-message ZK protocol CSS-QSA realizing FZK
for any NP statement assuming a setup setup, LPred
SemCol belong to ZKstatesQIPsetup
S
[k].
26Actually, in [DGL+23], they do deﬁne witnesses but in a diﬀerent way, as they send the witness directly to
the veriﬁer: thus, their notion of witness corresponds rather to the transcript of the proof in our case, and should
not be understood as an information that must be hidden to the veriﬁer like our own notion of witness (a.k.a.
class).
29

These statements can be proven using Corollary 4.15, together with the constructions of
[Unr15] and [HSS11]. See proof in section C.
4.5
Applications to build string and k-out-of-n OT protocols
We prove in this section that the above functionality F Pred
SemCol actually allows us to have string
OT or k-out-of-n OT. But ﬁrst, we show that we can realize this functionality:
Theorem 4.19. Let Pred be a predicate on subsets of [n]. Assuming the existence of a protocol
ΠSemCol = (ASemCol, BSemCol) that CSS-QSA-realises F Pred
SemCol, there Protocol 3 CSS-QSA-realises
F Pred
OT .
This is a generalisation of the last part of the proof of Theorem 3.1. See proof in section C.
Protocol 3: Protocol to compile a ZKoQS protocol (ASemCol, BSemCol) for the quantum
language LPred
SemCol into a predicate OT protocol.
Alice(B ⊆{0, 1}n)
Bob((m1, . . . , mn) ∈{0, 1}n)
If Pred(B) = ⊥, abort.
∀i ∈[n], r(i) ←{0, 1}
ρ := ⊗i∈[n]Hδi∈B |r(i)⟩
(s(i))i∈B ←ASemCol(B, ρ)
ρ ←BSemCol
Abort if the previous step aborted.
If the previous step aborted, abort.
∀c, apply Zmc on ρ(c) and measure it
in the Hadamard basis (outcome z(c)).
return (r(i) ⊕s(i) ⊕z(i))i∈B
∀c, z(c)
Corollary 4.20. By choosing appropriate values for Pred like in Deﬁnition 2.6, the protocol
Protocol 3 realizes the string OT functionality F str
OT and the k-out-of-n OT functionality F k−m
OT
.
Proof. This is a direct consequence of Theorem 4.19 and of the deﬁnition of F k−m
OT
and F str
OT .
5
Composability of [Unr15]
We are now going to prove that the online extractable NIZK protocol from [Unr15] quantum
stand-alone realizes the F R
ZK functionality in Deﬁnition 2.7, when the RO assumption is made.
The polynomial-time QIM prover P and veriﬁer V from [Unr15, Fig. 1] have access to two
random oracles, G and H, which can be queried in superposition by both parties (for simplicitly
we will just refer to a single oracle H). We will denote the polynomial-time two-party protocol
by ΠH
zk = (P, V) to stress the interaction between two machines and the trusted random oracles
P
H
↭V. Note that a single message is sent from the prover P to the veriﬁer V, leading to a
so-called non-interactive protocol.
The protocol ΠH
zk is proven to be complete, zero-knowledge and (even simulation-sound)
online-extractable. We recall the deﬁnitions in Deﬁnition D.1 for clarity (note that we assume
they also hold against non-uniform adversaries).
In the following we will prove that the protocol ΠH
zk quantum stand-alone realizes the
functionality F R
ZK.
30

Theorem 5.1. Let H be a random oracle. The non-interactive protocol ΠH
zk = (P, V) quantum
stand-alone realizes the classical zero-knowledge functionality F R
ZK, were x ∈L ⇔∃w, xRw.
See proof in section D.
6
Acknowledgment
The authors deeply thank Christian Schaﬀner for many insightful exchanges, together with
Stacey Jeﬀery, Geoﬀroy Couteau and James Bartusek for precious discussions.
This work is co-funded by the European Union (ERC, ASC-Q, 101040624). Views and
opinions expressed are however those of the author(s) only and do not necessarily reﬂect those
of the European Union or the European Research Council. Neither the European Union nor the
granting authority can be held responsible for them.
References
[ABK+22]
A. Agarwal, J. Bartusek, D. Khurana, and N. Kumar. A New Framework for Quantum
Oblivious Transfer, 2022.
[AL20]
P. Ananth and R. L. La Placa. Secure Quantum Extraction Protocols. In R. Pass and K.
Pietrzak, editors, Theory of Cryptography, Lecture Notes in Computer Science, pages 123–
152, Cham. Springer International Publishing, 2020.
[BBC+92]
C. H. Bennett, G. Brassard, C. Crépeau, and M.-H. Skubiszewska. Practical Quantum
Oblivious Transfer. In J. Feigenbaum, editor, Advances in Cryptology — CRYPTO ’91,
Lecture Notes in Computer Science, pages 351–366, Berlin, Heidelberg. Springer, 1992.
[BCK+21]
J. Bartusek, A. Coladangelo, D. Khurana, and F. Ma. One-Way Functions Imply Secure
Computation in a Quantum World. In T. Malkin and C. Peikert, editors, Advances in
Cryptology – CRYPTO 2021, Lecture Notes in Computer Science, pages 467–496, Cham.
Springer International Publishing, 2021.
[BD18]
Z. Brakerski and N. Döttling. Two-Message Statistically Sender-Private OT from LWE. In
A. Beimel and S. Dziembowski, editors, Theory of Cryptography. Volume 11240, Lecture
Notes in Computer Science, pages 370–390. Springer International Publishing, Cham, 2018.
[BF10]
N. J. Bouman and S. Fehr. Sampling in a Quantum Population, and Applications. In
T. Rabin, editor, Advances in Cryptology – CRYPTO 2010, Lecture Notes in Computer
Science, pages 724–741, Berlin, Heidelberg. Springer, 2010.
[BS20]
N. Bitansky and O. Shmueli. Post-quantum zero knowledge in constant rounds. In Proceed-
ings of the 52nd Annual ACM SIGACT Symposium on Theory of Computing, STOC 2020,
pages 269–279, New York, NY, USA. Association for Computing Machinery, June 22, 2020.
[CGK21]
L. Colisson, F. Grosshans, and E. Kasheﬁ. Non-Destructive Zero-Knowledge Proofs on
Quantum States, and Multi-Party Generation of Authorized Hidden GHZ States. April 10,
2021.
[CGS02]
C. Crépeau, D. Gottesman, and A. Smith. Secure multi-party quantum computation. In
Proceedings of the Thiry-Fourth Annual ACM Symposium on Theory of Computing, STOC
’02, pages 643–652, New York, NY, USA. Association for Computing Machinery, May 19,
2002.
[CJP+21]
T. Carette, E. Jeandel, S. Perdrix, and R. Vilmart. Completeness of Graphical Languages
for Mixed&#xa0;State Quantum Mechanics. ACM Transactions on Quantum Computing,
2(4):17:1–17:28, December 21, 2021.
[CK17]
B. Coecke and A. Kissinger. Picturing Quantum Processes: A First Course in Quantum
Theory and Diagrammatic Reasoning. Cambridge University Press, Cambridge, 2017.
[CK88]
C. Crepeau and J. Kilian. Achieving oblivious transfer using weakened security assumptions.
In [Proceedings 1988] 29th Annual Symposium on Foundations of Computer Science. [Pro-
ceedings 1988] 29th Annual Symposium on Foundations of Computer Science, pages 42–52,
October 1988.
31

[DFL+09]
I. Damgård, S. Fehr, C. Lunemann, L. Salvail, and C. Schaﬀner. Improving the Security
of Quantum Protocols via Commit-and-Open. In S. Halevi, editor, Advances in Cryptology
- CRYPTO 2009, Lecture Notes in Computer Science, pages 408–427, Berlin, Heidelberg.
Springer, 2009.
[DFP+14]
V. Dunjko, J. F. Fitzsimons, C. Portmann, and R. Renner. Composable Security of Dele-
gated Quantum Computation. In P. Sarkar and T. Iwata, editors, Advances in Cryptology –
ASIACRYPT 2014, Lecture Notes in Computer Science, pages 406–425, Berlin, Heidelberg.
Springer, 2014.
[DGJ+20]
Y. Dulek, A. B. Grilo, S. Jeﬀery, C. Majenz, and C. Schaﬀner. Secure Multi-party Quantum
Computation with a Dishonest Majority. In A. Canteaut and Y. Ishai, editors, Advances
in Cryptology – EUROCRYPT 2020, Lecture Notes in Computer Science, pages 729–758,
Cham. Springer International Publishing, 2020.
[DGL+23]
H. Delavenne, F. L. Gall, Y. Liu, and M. Miyamoto. Quantum Merlin-Arthur proof systems
for synthesizing quantum states, March 3, 2023.
[DNS12]
F. Dupuis, J. B. Nielsen, and L. Salvail. Actively Secure Two-Party Evaluation of Any
Quantum Operation. In R. Safavi-Naini and R. Canetti, editors, Advances in Cryptology
– CRYPTO 2012, Lecture Notes in Computer Science, pages 794–811, Berlin, Heidelberg.
Springer, 2012.
[EGL85]
S. Even, O. Goldreich, and A. Lempel. A randomized protocol for signing contracts. Com-
munications of the ACM, 28(6):637–647, June 1, 1985.
[ELE]
ELECTRIC COIN COMPANY. Zcash: Privacy-protecting digital currency. Zcash. url:
https://z.cash/ (visited on 02/10/2023).
[GL89]
O. Goldreich and L. A. Levin. A hard-core predicate for all one-way functions. In Proceedings
of the Twenty-First Annual ACM Symposium on Theory of Computing, STOC ’89, pages 25–
32, New York, NY, USA. Association for Computing Machinery, February 1, 1989.
[GLS+21]
A. B. Grilo, H. Lin, F. Song, and V. Vaikuntanathan. Oblivious Transfer Is in MiniQCrypt.
In A. Canteaut and F.-X. Standaert, editors, Advances in Cryptology – EUROCRYPT
2021, Lecture Notes in Computer Science, pages 531–561, Cham. Springer International
Publishing, 2021.
[GMR85]
S. Goldwasser, S. Micali, and C. Rackoﬀ. The knowledge complexity of interactive proof-
systems. In Proceedings of the Seventeenth Annual ACM Symposium on Theory of Comput-
ing, STOC ’85, pages 291–304, New York, NY, USA. Association for Computing Machinery,
December 1, 1985.
[GMW87]
O. Goldreich, S. Micali, and A. Wigderson. How to play ANY mental game. In Proceedings
of the Nineteenth Annual ACM Symposium on Theory of Computing, STOC ’87, pages 218–
229, New York, NY, USA. Association for Computing Machinery, January 1, 1987.
[HSS11]
S. Hallgren, A. Smith, and F. Song. Classical Cryptographic Protocols in a Quantum World.
In P. Rogaway, editor, Advances in Cryptology – CRYPTO 2011, Lecture Notes in Computer
Science, pages 411–428, Berlin, Heidelberg. Springer, 2011.
[Imp95]
R. Impagliazzo. A personal view of average-case complexity. In Proceedings of Structure in
Complexity Theory. Tenth Annual IEEE Conference. Proceedings of Structure in Complex-
ity Theory. Tenth Annual IEEE Conference, pages 134–147, June 1995.
[JLS18]
Z. Ji, Y.-K. Liu, and F. Song. Pseudorandom Quantum States. In H. Shacham and A.
Boldyreva, editors, Advances in Cryptology – CRYPTO 2018, Lecture Notes in Computer
Science, pages 126–152, Cham. Springer International Publishing, 2018.
[KA04]
E. Kasheﬁand C. M. Alves. On the Complexity of Quantum Languages, April 12, 2004.
[Kil88]
J. Kilian. Founding crytpography on oblivious transfer. In Proceedings of the Twentieth
Annual ACM Symposium on Theory of Computing, STOC ’88, pages 20–31, New York, NY,
USA. Association for Computing Machinery, January 1, 1988.
[KKM+21]
T. Kapourniotis, E. Kasheﬁ, L. Music, and H. Ollivier. Delegating Multi-Party Quantum
Computations vs. Dishonest Majority in Two Quantum Rounds. September 9, 2021.
[KP17]
E. Kasheﬁand A. Pappa. Multiparty Delegated Quantum Computing. Cryptography, 1(2):12,
2, September 2017.
32

[KZ09]
A. Kiayias and H.-S. Zhou. Zero-Knowledge Proofs with Witness Elimination. In S. Jarecki
and G. Tsudik, editors, Public Key Cryptography – PKC 2009, Lecture Notes in Computer
Science, pages 124–138, Berlin, Heidelberg. Springer, 2009.
[Lin13]
Y. Lindell. A Note on Constant-Round Zero-Knowledge Proofs of Knowledge. Journal of
Cryptology, 26(4):638–654, October 1, 2013.
[LMS21]
A. Lombardi, F. Ma, and N. Spooner. Post-Quantum Zero Knowledge, Revisited (or: How
to Do Quantum Rewinding Undetectably), November 23, 2021.
[Lo97]
H.-K. Lo. Insecurity of quantum secure computations. Physical Review A, 56(2):1154–1162,
August 1, 1997.
[LT22]
P. Laud and R. Talviste. Review of the state of the art in secure multiparty computation.
In Cybernetica As, 2022.
[MS94]
D. Mayers and L. Salvail. Quantum oblivious transfer is secure against all individual mea-
surements. In Proceedings Workshop on Physics and Computation. PhysComp ’94. Pro-
ceedings Workshop on Physics and Computation. PhysComp ’94, pages 69–77, November
1994.
[MY23]
T. Metger and H. Yuen. stateQIP = statePSPACE, January 18, 2023.
[NC10]
M. A. Nielsen and I. L. Chuang. Quantum Computation and Quantum Information: 10th
Anniversary Edition, December 2010.
[PS19]
C. Peikert and S. Shiehian. Noninteractive Zero Knowledge for NP from (Plain) Learning
with Errors. In A. Boldyreva and D. Micciancio, editors, Advances in Cryptology – CRYPTO
2019, Lecture Notes in Computer Science, pages 89–114, Cham. Springer International
Publishing, 2019.
[PVW08]
C. Peikert, V. Vaikuntanathan, and B. Waters. A Framework for Eﬃcient and Composable
Oblivious Transfer. In D. Wagner, editor, Advances in Cryptology – CRYPTO 2008, Lecture
Notes in Computer Science, pages 554–571, Berlin, Heidelberg. Springer, 2008.
[Qua20]
W. Quach. UC-Secure OT from LWE, Revisited. In C. Galdi and V. Kolesnikov, editors,
Security and Cryptography for Networks, Lecture Notes in Computer Science, pages 192–
211, Cham. Springer International Publishing, 2020.
[Rab05]
M. O. Rabin. How To Exchange Secrets with Oblivious Transfer, 2005.
[RY22]
G. Rosenthal and H. Yuen. Interactive proofs for synthesizing quantum states and unitaries.
In M. Braverman, editor, 13th Innovations in Theoretical Computer Science Conference,
ITCS 2022, January 31 - February 3, 2022, Berkeley, CA, USA, volume 215 of LIPIcs,
112:1–112:4. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2022.
[SMP22]
M. B. Santos, P. Mateus, and A. N. Pinto. Quantum oblivious transfer: a short review.
Entropy, 24(7):945, July 7, 2022.
[Unr10]
D. Unruh. Universally Composable Quantum Multi-party Computation. In H. Gilbert, ed-
itor, Advances in Cryptology – EUROCRYPT 2010, Lecture Notes in Computer Science,
pages 486–505, Berlin, Heidelberg. Springer, 2010.
[Unr12]
D. Unruh. Quantum Proofs of Knowledge. In D. Pointcheval and T. Johansson, editors, Ad-
vances in Cryptology – EUROCRYPT 2012, Lecture Notes in Computer Science, pages 135–
152, Berlin, Heidelberg. Springer, 2012.
[Unr15]
D. Unruh. Non-Interactive Zero-Knowledge Proofs in the Quantum Random Oracle Model.
In E. Oswald and M. Fischlin, editors, Advances in Cryptology - EUROCRYPT 2015, Lec-
ture Notes in Computer Science, pages 755–784, Berlin, Heidelberg. Springer, 2015.
[vdWet20]
J. van de Wetering. ZX-calculus for the working quantum computer scientist. December 27,
2020.
[Wat09]
J. Watrous. Zero-Knowledge against Quantum Attacks. SIAM Journal on Computing, 39(1):25–
58, January 1, 2009.
[Wie83]
S. Wiesner. Conjugate coding. ACM SIGACT News, 15(1):78–88, January 1, 1983.
[Wil17]
M. M. Wilde. From Classical to Quantum Shannon Theory. 2017.
[WW06]
S. Wolf and J. Wullschleger. Oblivious Transfer Is Symmetric. In S. Vaudenay, editor, Ad-
vances in Cryptology - EUROCRYPT 2006, Lecture Notes in Computer Science, pages 222–
232, Berlin, Heidelberg. Springer, 2006.
33

[Yao82]
A. C. Yao. Protocols for secure computations. In 23rd Annual Symposium on Foundations
of Computer Science (Sfcs 1982). 23rd Annual Symposium on Foundations of Computer
Science (Sfcs 1982), pages 160–164, November 1982.
[Yao95]
A. C.-C. Yao. Security of quantum protocols against coherent measurements. In Proceed-
ings of the Twenty-Seventh Annual ACM Symposium on Theory of Computing, STOC ’95,
pages 67–75, New York, NY, USA. Association for Computing Machinery, May 29, 1995.
[YAV+22]
V. K. Yadav, N. Andola, S. Verma, and S. Venkatesan. A Survey of Oblivious Transfer
Protocol. ACM Computing Surveys, 54:211:1–211:37, 10s, September 13, 2022.
34

Supplementary Material
A
Proofs of statements in preliminaries
Proof of Lemma 2.12. The proof is trivial: we can split the proof in multiple cases. If no party
is corrupted (correctness), then the outputs of both parties are always distributed according to
F Gen
CRS, so no environment can (even statistically) distinguish between the ideal and real world.
If Alice gets corrupted, we deﬁne the simulator exactly as the malicious Alice ˆA, and both
worlds are identical (up to the name we give to the diﬀerent parts of the world) and therefore
indistinguishable. If Bob ( ˆ
Bob) is malicious, then we deﬁne the simulator as outputting c = ⊤
to the functionality, and then feeding the received advice and the received k to
ˆ
Bob. Again, the
ideal and real worlds are equal, which concludes the proof.
Proof of Lemma 2.13. The proof is trivial and very similar to Lemma 2.12. The only case where
it diﬀers is when Bob is malicious. Then the simulator runs ˆB and forwards the output to the
ideal functionality: the test performed by the functionality is exactly the test performed by Alice
in the real world, so both worlds are equal.
B
Proofs of security of the bit OT protocol
Proof of Theorem 3.1. Let A be a static adversary. To prove that the above protocol realizes
the above functionality, we will split the proof depending on the parties that the static adversary
A can corrupt.
Case 1: correctness (no corrupted party). If no party is corrupted, we are proving that
the protocol is correct. First, we can cut A and B in four parts: the part that runs Ah, the part
that generates h(c)
c , the part that runs the ZK proof, and the rest. Because of the correctness
of the protocol distributing h, and because of the completeness of the ZK protocol, we can
indistinguishably replace the ﬁrst and third parts of A and B with the ideal dummy parties and
the corresponding functionalities. Now, because w(1−b)
1−l [1] = 1, the statement that we prove in
the NIZK proof is true, so by the completeness of the NIZK protocol the check succeeds. Then,
during the second step we apply the unitary that maps |x⟩|w⟩|0⟩to |x⟩|w⟩|1⟩only if w[1] ̸= 1
(the witness is valid) and if h(x∥w) appears in the list of hashes, which is true for all terms
appearing in |ψ(b)⟩and |ψ(1−b)⟩by construction, so after this step the two states become:
|ψ(b)⟩⇝|0⟩|w(b)
0 ⟩|1⟩+ (−1)r(b) |1⟩|w(b)
1 ⟩|1⟩= |ψ(b)⟩|1⟩
(12)
|ψ(1−b)⟩⇝|l⟩|w(b)
l ⟩|1⟩= |ψ(1−b)⟩|1⟩
(13)
Because the last register (let us call them T (b) and T (1−b)) of each state is not entangled with
their respective ﬁrst two registers, measuring T (b) and T (1−b) will output 1 in both cases and
will not disturb the states on the ﬁrst two registers. Then, we measure the second register of
each state in the Hadamard basis, i.e. we ﬁrst apply Hadamard gates on all qubits and then we
measure in the computational basis. After the Hadamard gates, the state |ψ(b)⟩is turned into
(omitting the constants):
(I ⊗Hn+1) |ψ(b)⟩
(14)
35

= |0⟩Hn+1 |w(b)
0 ⟩+ (−1)r(b) |1⟩Hn+1 |w(b)
1 ⟩
(15)
= |0⟩
X
s(b)∈{0,1}n+1
(−1)⟨s(b),w(b)
0 ⟩|s(b)⟩+ (−1)r(b) |1⟩
X
s(b)∈{0,1}n+1
(−1)⟨s(b),w(b)
1 ⟩|s(b)⟩
(16)
= |0⟩+ |1⟩


X
s(b)∈{0,1}n+1
(−1)r(b)⊕⟨s(b),w(b)
0 ⊕w(b)
1 ⟩|s(b)⟩


(17)
where ⟨a, b⟩:= ⊕ia[i]b[i] is the standard inner product of bit strings. If we measure then an
outcome s(b) and deﬁne α := r(b) ⊕⟨s(b), w(b)
0
⊕w(b)
1 ⟩the above state collapses to:
|ψ′(b)⟩:= |0⟩+ (−1)α |1⟩
(18)
(note that the state is in the Hadamard basis.)
For the second state |ψ(1−b)⟩= |l⟩|w(1−b)
l
⟩, the ﬁrst register is not entangled with the second,
so measuring the second register does not disturb the ﬁrst one. So we end up with the state
|ψ′(1−b)⟩:= |l⟩
(19)
(i.e. the state is in the computational basis).
In the ﬁnal step, Bob rotates the two states:
Zmb |ψ′(b)⟩= |0⟩+ (−1)α⊕mb |1⟩
Zm1−b |ψ′(1−b)⟩= Zm1−b |l⟩= |l⟩
(20)
(note that the rotation does nothing in the second case, hence all information about m1−b is
lost). Then, Bob measures both states in the Hadamard basis: therefore we have z(b) = α ⊕mb
and z(1−b) is just a random bit since we measure a qubit in the computational basis. So at the
end, Alice outputs α ⊕z(b) = mb which ends the proof of correctness.
Case 2: malicious sender (Bob). We consider now the case where the adversary A = ˆB
corrupts the sender Bob. For an intuitive overview of the proof, see Section 1.2, together with
the sketch of proof after Theorem 3.1.
First, we notice that since the functionality FZK sends the word x (in our case the hashes
h(c)
d ) to the veriﬁer, we do not need to send x another time before (if needed we can assume that
the ZK protocol starts by sending x). Let ˆB be an adversary. Without loss of generality27, we
can decompose ˆB into ˆB0 and ˆB1, where ˆB0 is the QIM running during the ZK protocol (so it
receives an arbitrary advice σ and interacts with A during the ZK protocol), forwarding its ﬁnal
internal state to ˆB1 that runs the rest of the protocol (in particular ˆB1 receives the quantum
state and is supposed to output some measurement outcomes). For any Z and family of states
σ = {σλ}λ∈N, we deﬁne below the following hybrids:
– World0 := REALσ
Π, ˆB,Z is the real world (where Alice runs internally the ZK protocol Azk
with ˆB) as pictured in Fig. 4.
– World1 is like World0 except that the Πh protocol (in charge of sharing h) is replaced by the
simulated version as pictured in Fig. 5.
– World2 is like World0 except that the ZK protocol is replaced by the simulated version as
pictured in Fig. 6.
27If the ZK is non-interactive, ˆB0 would just store the proof π, the hashes (hi,j) and advice σ and forward it
to ˆB1.
36

– World3 is like World2 except that we remove FZK and always forward (hc
d)c,d to S ˆB0 as
pictured in Fig. 7.
– World4 is like World3 except that we sample w(1−b)
1−l
$←{0} × {0, 1}n as pictured in Fig. 8.
– World5 is like World4 except that we deﬁne instead |ψ(1−b)⟩:= |0⟩|w(1−b)
0
⟩+(−1)r(1−b) |1⟩|w(1−b)
1
⟩
where r(1−b)
$←{0, 1} is a random bit as pictured in Fig. 9.
– World6, pictured in Fig. 10, is like World5 except that we reorder some operations and we cut
Alice in three parts: a simulator S ˆB (the simulator will also absorb S ˆB0 and ˆB1 by simply
forwarding the input σ to S ˆB0 and the output of ˆB1 to Z), the ideal functionality FOT ,
and the dummy party ˜A that forwards b to FOT and outputs the answer mb of FOT (in
Fig. 10 FOT and ˜A are drawn together for to save space). More precisely, we see that all the
messages sent to ˆB are sampled exactly in the same way, irrespective of the value of b, so we
can push that outside of Alice into the simulator. The only part that still depends on b is
the output message. To avoid this dependency, the simulator will compute the two outputs
(when b = 0 and when b = 1) and send them to FOT that will be in charge of outputting the
appropriate value. This way, we see that World6 = IDEALσ,FOT
˜Π,S ˆB,Z.
A(b ∈{0, 1})
ˆB(σ ˆB)
Z(σZ)
Run Ah to obtain h.
ˆB0
∀c, d, sample w(c)
d
and h(c)
d
like in the main protocol
Run Azk(∀c, d, w(c)
d , h(c)
d )
ˆB1
Sample |ψ(0)⟩,|ψ(1)⟩like
in the main protocol
|ψ(0)⟩, |ψ(1)⟩
Compute α like
∀c, s(c), z(c)
ˆB2
state
in the main protocol
α ⊕z(b)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 4: World0
First, we see that World0 ≈World2 because we assumed that the underlying protocol CSS-QSA
realizes FZK: If it were not the case, then we could easily break the CSS′-QSA property of FZK
(and therefore the CSS-QSA property of FZK since S′ ⊆S) by merging the classical sampling
procedure inside σ to get a new σ′ (the value of the witness being kept as a side-information for
Z in σ′) and the rest of the procedure (preparation of the quantum state and running ˆB1) inside
Z to produce a new Z′ able to attack FZK with exactly the same probability.
Then, World2 = World3: by construction, there always exists a witness starting with a 0, so
FZK will always forward (hc
d)c,d.
We also have World3 ≈World4 because of the hardcore second-bit property (see Deﬁnition 2.9).
Otherwise, we can easily break the hardcore second-bit property by deﬁning A as World3 except
that the w(1−b)
1−l
is sampled externally by the “challenger” that only provides h(1−b)
1−l
to A (note
that w(1−b)
1−l
is not needed here except to compute h(1−b)
1−l ). Note that this attacker is only valid if
the computational power of ˆB is lower than the computational power deﬁned in the hardcore
second-bit property, but this is ﬁne if {B} ∈S′ only if h has the statistically hardcore second-bit
property as assumed.
37

A(b ∈{0, 1})
ˆB(σ ˆB)
Z(σZ)
Run F Gen
H
to obtain h.
h
Sh, ˆB0
i.e. check if h ∈K.
∀c, d, sample w(c)
d
and h(c)
d
like in the main protocol
Run Azk(∀c, d, w(c)
d , h(c)
d )
ˆB1
Sample |ψ(0)⟩,|ψ(1)⟩like
in the main protocol
|ψ(0)⟩, |ψ(1)⟩
Compute α like
∀c, s(c), z(c)
ˆB2
state
in the main protocol
α ⊕z(b)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 5: World1
A(b ∈{0, 1})
ˆB(σ ˆB)
Z(σZ)
Run F Gen
H
to obtain h,
h
Sh, ˆB0
i.e. check if h ∈K.
∀c, d, sample w(c)
d
and h(c)
d
like in the main protocol
Run F R
ZK, i.e. check if
∃c′, d′, h(d′∥w(c′)
d′ ) = h(c′)
d′
and outputs all h(c)
d
∀c, d, h(c)
d
Szk, ˆB1
Sample |ψ(0)⟩,|ψ(1)⟩like
in the main protocol
|ψ(0)⟩, |ψ(1)⟩
Compute α like
∀c, s(c), z(c)
ˆB2
state
in the main protocol
α ⊕z(b)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 6: World2
38

A(b ∈{0, 1})
ˆB(σ ˆB)
Z(σZ)
Run F Gen
H
to obtain h,
h
Sh, ˆB0
i.e. check if h ∈K.
∀c, d, sample w(c)
d
and h(c)
d
like in the main protocol
Check . . .
∀c, d, h(c)
d
Szk, ˆB1
Sample |ψ(0)⟩,|ψ(1)⟩like
in the main protocol
|ψ(0)⟩, |ψ(1)⟩
Compute α like
∀c, s(c), z(c)
ˆB2
state
in the main protocol
α ⊕z(b)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 7: World3
A(b ∈{0, 1})
ˆB(σ ˆB)
Z(σZ)
Run F Gen
H
to obtain h,
h
Sh, ˆB0
i.e. check if h ∈K.
∀c, d, sample w(c)
d
and h(c)
d
like
in the main protocol, except for
w(1−b)
1−l
$←{0} × {0, 1}n.
∀c, d, h(c)
d
Szk, ˆB1
Sample |ψ(0)⟩,|ψ(1)⟩like
in the main protocol
|ψ(0)⟩, |ψ(1)⟩
Compute α like
∀c, s(c), z(c)
ˆB2
state
in the main protocol
α ⊕z(b)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 8: World4
39

A(b ∈{0, 1})
ˆB(σ ˆB)
Z(σZ)
Run F Gen
H
to obtain h,
h
Sh, ˆB0
i.e. check if h ∈K.
∀c, d, sample w(c)
d
and h(c)
d
like
in the main protocol, except for
w(1−b)
1−l
$←{0} × {0, 1}n.
∀c, d, h(c)
d
Szk, ˆB1
Sample |ψ( b )⟩like in the main
protocol, r(1−b)
$←{0, 1} and
|ψ(1−b)⟩:= |0⟩|w(1−b)
0
⟩
+(−1)r(1−b) |1⟩|w(1−b)
1
⟩
|ψ(0)⟩, |ψ(1)⟩
Compute α like
∀c, s(c), z(c)
ˆB2
state
in the main protocol
α ⊕z(b)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 9: World5
AI(b) and FOT
S ˆB(σ ˆB)
Z(σZ)
(h, state0) ←Sh, ˆB0(σ ˆB)
Check if h ∈K.
∀c, d, sample w(c)
d
and h(c)
d
like
in the main protocol, except for
w(1−b)
1−l
$←{0} × {0, 1}n.
(state1) ←Szk, ˆB1(∀c, d, h(c)
d , state0)
Sample |ψ( b )⟩like in the main
protocol, r(1−b)
$←{0, 1} and
|ψ(1−b)⟩:= |0⟩|w(1−b)
0
⟩
+(−1)r(1−b) |1⟩|w(1−b)
1
⟩
(∀c, s(c), z(c), state2) ←ˆB2(|ψ(0)⟩, |ψ(1)⟩, state1)
m(0), m(1)
∀c, m(c) = (r(c) ⊕
M
i
s(c)[i](w(c)
0
⊕w(c)
1 )[i]) ⊕z(c)
FOT outputs m(b)
state2
m(b)
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 10: World6
40

World4 = World5, because for any x and x′, it is statistically impossible to distinguish
|x⟩+ (−1)r(1−b) |x′⟩from |x′′⟩where x′′ equals x with probability 1
2 and x′ otherwise, even given
x and x′ (the random sign r(1−b) must however stay hidden28). Indeed, we can simply study the
density matrices, ﬁrst of |x⟩± |x′⟩(the ﬁrst sum is on the random choice r(1−b) of the sign):
1
2(|x⟩+ |x′⟩
√
2
⟨x| + ⟨x′|
√
2
+ |x⟩−|x′⟩
√
2
⟨x| −⟨x′|
√
2
)
(21)
= 1
4(|x⟩⟨x| + |x⟩⟨x′| + |x′⟩⟨x| + |x′⟩⟨x′| + |x⟩⟨x| −|x⟩⟨x′| −|x′⟩⟨x| + |x′⟩⟨x′|)
(22)
= 1
2(|x⟩⟨x| + |x′⟩⟨x′|)
(23)
But this last expression is exactly the density matrix of |x′′⟩where x′′ equals x with probability
1/2 and x′ otherwise.
In our case, we have x = 0∥w(1−b)
0
, x′ = 1∥w(1−b)
1
and x′′ = l∥w(1−b)
l
since l plays the role of
the random coin determining the element to send in World4 (you can see that l plays no role in
World5 since we can re-order the steps in the sampling procedure). Since l and r(1−b) are only
used to determine |ψ(1−b)⟩and since both worlds are equal beside the choice of |ψ(1−b)⟩, we can
conclude that World4 = World5 as otherwise we could “factor out” |ψ(1−b)⟩from the worlds and
use the remaining part to distinguish between |x⟩+ (−1)r(1−b) |x′⟩from |x′′⟩which is physically
impossible as we just saw.
Finally, World5 = World6 since we just reordered the sampling procedure, delocalized their
computation to S ˆB and used FOT to discard the message corresponding to m1−b in order to
keep only mb as in World5.
Therefore, by transitivity, World0 ≈World6, i.e. REALσ
Π, ˆB,Z ≈IDEALσ,FOT
˜Π,S ˆB,Z which concludes
this part of the proof.
Case 3: malicious receiver (Alice). We consider now the case where the adversary A = ˆA
corrupts the receiver Alice. For an intuitive overview of the proof, see Section 1.2, together with
the sketch of proof after Theorem 3.1.
Like in case 2, without loss of generality we can decompose ˆA into three parts: ˆA0 will be
the part running the Πh protocol, ˆA1 will be the part running the ZK protocol, forwarding its
internal state to ˆA2 that will be in charge of the rest of the protocol as pictured in Fig. 11. In
the following, we deﬁne, for any bit b, X (b) as the register containing the state |ψ(b)⟩, W(1−b) as
the sub-register of X (b) containing the witness w (so all but the ﬁrst qubit) and W(1−b)[1] as
the ﬁrst qubit in the register W(1−b).
We formalize this reasoning by deﬁning the following hybrid worlds:
– World0 := REALσ
Π, ˆA,Z is the real world (where Bob runs internally the ZK protocol Bzk with
ˆA) as pictured in Fig. 11.
– World1 is like World0 except that we replace Πh with the ideal world ( ˆA0 is replaced with
S ˆA0, and Bh is now replaced with the ideal resource F Gen
H
and the idealized party Bh,I
sampling honestly h ←Gen(1λ)), as pictured in Fig. 12.
– World2 is like World1 except that we replace ˆA1 with the simulator of the ZK protocol
interacting with FZK, and integrate the ideal resource checking if there exists w1−b starting
with a 1 in B as pictured in Fig. 13.
28It is also possible to remove the sign, but then the proof is harder and only applies statistically if h is lossy.
41

– World3 is like World2 except that it does not perform the Zm1−b rotation, as pictured in
Fig. 14.
– For World4, we can realize that in World3, the code does not depend on m1−b anymore. So we
can reorganise the elements of World3 to let the functionality provide mb and discard m1−b:
we split B into three parts: the functionality FOT , a dummy Bob that just forwards m0 and
m1 to FOT , and a simulator S ˆA that runs the code of B in the previous World (extracting b
in the same way), except that it sends b to FOT to get mb. We also let S ˆA absorb ˆA, Bh,I,S ˆA0
and S ˆA1 (appropriately forwarding their input/outputs): this way World4 = IDEALσ,FOT
˜Π,S ˆ
A,Z.
This is pictured Fig. 15.
ˆA(σ ˆA)
B(m0, m1)
Z(σZ)
ˆA0
Run Bh to obtain h
ˆA1
Run Bzk to obtain ∀c, d, h(c)
d
ˆA2
|ψ⟩(0) , |ψ⟩(1)
Do the measurements and
rotations of the real protocol.
ˆA3
∀c, s(c), z(c)
state
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 11: Case 3 (malicious Alice): World0
ˆA(σ ˆA)
B(m0, m1)
Z(σZ)
Sh, ˆA0
h
h ←Gen(1λ)
ˆA1
Run Bzk to obtain ∀c, d, h(c)
d
ˆA2
|ψ⟩(0) , |ψ⟩(1)
Do the measurements and
rotations of the real protocol
ˆA3
∀c, s(c), z(c)
state
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 12: Case 3 (malicious Alice): World1
First, we see that World0 ≈World1 because we assumed that the Πh protocol CSSh-QSA
realizes FZK: If it were not the case, then we could easily break the CSS′-QSA property of Πh
(and therefore the CSSh-QSA property since S′ ⊆Sh) by merging basically all the procedure
after the Πh protocol inside Z to produce a new Z′ able to attack FZK with exactly the same
probability.
We have also that World1 ≈World2 because we assumed that the underlying protocol CSS-QSA
realizes FZK: If it were not the case, then we could easily break the CSS′-QSA property of this
underlying protocol (and therefore its CSS-QSA property since S′ ⊆S) by merging basically all
the procedure after the ZK protocol inside Z to produce a new Z′ able to attack FZK with
exactly the same probability.
Then, we prove that World2 ≈World3.
42

ˆA(σ ˆA)
B(m0, m1)
Z(σZ)
Sh, ˆA0
h
h ←Gen(1λ)
Szk, ˆA1
∀c, d, w(c)
d , h(c)
d
Run FZK, i.e. check if w’s
are valid witnesses for R
(notably ∃b, h(l∥w(b)
l
) = h(b)
l ).
ˆA2
|ψ⟩(0) , |ψ⟩(1)
Do the measurements and
rotations of the real protocol.
ˆA3
∀c, s(c), z(c)
state
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 13: Case 3 (malicious Alice): World2
ˆA(σ ˆA)
B(m0, m1)
Z(σZ)
Sh, ˆA0
h
h ←Gen(1λ)
Szk, ˆA1
∀c, d, w(c)
d , h(c)
d
Run FZK, i.e. check if w’s
are valid witnesses for R
(notably ∃b, h(l∥w(b)
l
) = h(b)
l ).
ˆA2
|ψ⟩(0) , |ψ⟩(1)
Do the measurements and
rotations of the real protocol,
ˆA3
∀c, s(c), z(c)
except Zm1−b.
state
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 14: Case 3 (malicious Alice): World3
43

S ˆA(σ ˆ
A)
˜B(m0, m1) & FOT Z(σZ)
h ←Gen(1λ)
state0 ←Sh, ˆA0(σ ˆA, h)
(∀c, d, w(c)
d , h(c)
d , state1) ←Szk, ˆA1(state0)
Run FZK, i.e. check if w’s
are valid witnesses for R
(notably ∃b, h(l∥w(b)
l
) = h(b)
l ).
b
(|ψ⟩(0) , |ψ⟩(1) , state2) ←ˆA2(state1)
mb
Do the measurements and
rotations of the real protocol,
except Zm1−b.
state3 ←ˆA3(∀c, s(c), z(c), state2)
state3
−−−−−−−−−−−−−−−−−−−−−−→
return anything
Fig. 15: Case 3 (malicious Alice): World4
This part is slightly more technical, but intuitively the goal is to show that the state sent
by Alice is close in trace distance to a state in the computational basis (otherwise we can
break the collision resistance property of h), and therefore a Z rotation does not signiﬁcantly
disturb the state.
To formalize this intuition, we will ﬁrst associate a quantity β to each run, show that this
β is linked to the probability of ﬁnding a collision and to the trace distance to the measured
state, and ﬁnally we show that the average29 value of β must be negligible, like that average
trace distance between the two worlds. To that aim, it is handy to consider, for a ﬁxed run, a
(normalized) puriﬁcation |ψ⟩T ,B,E = |t⟩P
x,y β(1−b)
x,y
|x⟩|y⟩of the states |ψ(0)⟩and |ψ(1)⟩sent
by ˆA and partially measured30 by B with the result of the tests it the register T , including
any potential entanglement with the adversary or environment by adding a third register E
(we also put in this register the internal memory of ˆA right after she sent the state to B).
Moreover, we can assume without loss of generality that ˆA does nothing before receiving the
measurement outcomes sent by Bob, by simply postponing in time its actions.
Then, we can ﬁrst study the simplest case: if h is injective (a.k.a. statistically collision
resistant), then World2 = World3:
First, if t = 0 (invalid test), then the remaining actions in World2 and World3 are identical.
Now, if t = 1, because h is injective there exists at most one x(1−b) such x(1−b) has a 0
at the second position and h(x(1−b)) ∈{h(1−b)
0
, h(1−b)
1
} (we already extracted above one
pre-image of h(1−b)
0
or h(1−b)
1
with a 1 at the second position in the ZK protocol, and by
injectivity of h there are at most two pre-images to this set, so a single image can have a 0
at the second position). Because Bob measured exactly that the ﬁrst register is a pre-image
29We could also, equivalently, prove that the probability of having a non-negligible β is negligible, but this
introduce two polynomials, leading to a less elegant proof.
30We are referring to the operations where Bob extracts the witness, where it checks that the quantum register
containing the witnesses in superposition starts with a 0 and that they are valid pre-images. The result of these
tests (t = 1 iﬀall tests pass) is put in a new register T .
44

of {h(1−b)
0
, h(1−b)
1
} (since t = 1), the state |ψ⟩B,E will collapse into |x(1−b)⟩(P
y β(1−b)
x,y
|y⟩)
(up to a renormalisation factor). Therefore, since Zm |x⟩= |x⟩, applying Zm1−b
2
or not
does not change the state at all (this is true for any run), leading to World2 = World3.
Now, we consider the case where h is only computationally collision-resistant. During a valid
extraction of the witness, we found an element x(1−b)
1−l
whose witness part starts with a 1
(x(1−b)
1−l [2] = 1) such that h(x(1−b)
1−l ) ∈{h(1−b)
0
, h(1−b)
1
}: let x∗:= x(1−b)
l
be the other part of
the witness such that h(x∗) ∈{h(1−b)
0
, h(1−b)
1
} (if both of them start with a 1, we can choose
arbitrarily). Then, there exists β ∈[0, 1] (possibly equal to 1 if x∗starts with a 1), a normalized
pure state |φ∗⟩, and a normalized pure state |φ⟩such that Tr((|x∗⟩⟨x∗| ⊗I)|φ⟩⟨φ|) = 0 such
that:
|ψ⟩T ,B,E = |t⟩(
p
1 −β |x∗⟩|φ∗⟩+
p
β |φ⟩)
(24)
This can easily be seen by rewriting |ψ⟩B,E appropriately:
|ψ⟩B,E =
X
x,y
β(1−b)
x,y
|x⟩|y⟩
(25)
= |x∗⟩(
X
y
β(1−b)
x∗,y |y⟩) +
X
x̸=x∗,y
β(1−b)
x,y
|x⟩|y⟩
(26)
= (
X
y
|β(1−b)
x∗,y |2) |x∗⟩(
1
P
y |β(1−b)
x∗,y |2
X
y
β(1−b)
x∗,y |y⟩) +
X
x̸=x∗,y
β(1−b)
x,y
|x⟩|y⟩
(27)
Then, because |ψ⟩B,E is normalized, we have 0 ≤P
y |β(1−b)
x∗,y |2 ≤1, so by deﬁning
β := 1 −(
X
y
|β(1−b)
x∗,y |2)2
|φ∗⟩:=
1
P
y |β(1−b)
x∗,y |2
X
y
β(1−b)
x∗,y |y⟩
|φ⟩:=
1
√β (|ψ⟩B,E −
p
1 −β |φ∗⟩)
(if β = 0, |φ⟩= 0) we have that β ∈[0, 1], |φ∗⟩is normalized, |ψ⟩B,E = √1 −β |x∗⟩|φ∗⟩+
√β |φ⟩, Tr((|x∗⟩⟨x∗|⊗I)|φ⟩⟨φ|) = 0 (since |φ⟩∝|ψ⟩B,E−√1 −β |φ∗⟩= P
x̸=x∗,y β(1−b)
x,y
|x⟩|y⟩,
i.e. a sum on terms x ̸= x∗), and |φ⟩is also normalized since |ψ⟩B,E is also normalized.
We observe now that the probability of ﬁnding a collision is greater than tβ:
First, if t = 0 (the test fails), then tβ = 0 so this is obviously true. Now, if t = 1, this can
be seen by ﬁrst remarking that if we measure the register B of |ψ⟩B,E, we get an outcome
x: since Tr((|x∗⟩⟨x∗| ⊗I)|φ⟩⟨φ|) = 0, x equals x∗with probability √1 −β2 = 1 −β,
i.e. x ̸= x∗with probability β. Moreover, because t = 1, we know that x[2] = 0 and
h(x) ∈{h(1−b)
0
, h(1−b)
1
}. In the ﬁrst case, if h(x) = h(1−b)
1−l , then x ̸= x(1−b)
1−l
since x[2] = 1
and x(1−b)
1−l [2] = 0 so (x, x(1−b)
1−l ) is a collision (reminder: x(1−b)
1−l
was extracted by the
simulator during the ZK protocol). In the second case, if h(x) = h(1−b)
l
, because with
probability β we have x ̸= x∗, (x, x∗) forms a collision with probability β. Therefore we
can ﬁnd a collision with probability greater than β = tβ.
Moreover, we observe that the trace distance between |ψ⟩T ,B,E and Ztm1−b
B,2
|ψ⟩B,E is smaller
than 2t√β:
45

First, if t = 0, both states are strictly equal, so their trace distance is 0. If t = 1, this
can be seen using the triangle inequality (ﬁrst inequality), the fact that on states in the
computational basis, Z |x⟩= |x⟩, Lemma B.1, and the well known fact that the trace
distance is preserved under unitary transform (TD(U |ψ⟩, U |φ⟩) = TD(|ψ⟩, |φ⟩)):
TD(|ψ⟩T ,B,E , (Ztm1−b
B,2
|ψ⟩T ,B,E)) = TD(|t⟩|ψ⟩B,E , |t⟩Ztm1−b
B,2
|ψ⟩B,E)
(28)
≤TD(|ψ⟩B,E , |x∗⟩|φ∗⟩) + TD(|x∗⟩|φ∗⟩, Zm1−b
2
|x∗⟩|φ∗⟩)
+ TD(Zm1−b
2
|x∗⟩|φ∗⟩, Zm1−b
2
|ψ⟩B,E)
(29)
≤
p
β + 0 + TD(|x∗⟩|φ∗⟩, |ψ⟩B,E)
(30)
≤2
p
β = 2t
p
β
(31)
We prove now that World2 ≈αWorld3, where α :=
E
|t⟩|ψ⟩B,E←ξ0(σ)
 2t
pβψ
.
First, we remark that by stopping the worlds right before the Z rotations, we can de-
ﬁne two binary POVM31 ξ0 (taking as input (a puriﬁcation of) σλ and outputting the
state |ψ⟩T ,B,E = |t⟩|ψB,E⟩deﬁned above) and ξ1 (performing the rest Zmb rotation, the
measurement in the H basis, the adversary ˆA2 and Z) such that World3 is the sequential
composition of ξ0 and ξ1, and World2 is the sequential composition of ξ0, Ztm1−b
2
and ξ1.
This way, we can write:
| Pr [ World3 = 1 ] −Pr [ World2 = 1 ] |
(32)
=

Pr
|t⟩|ψ⟩B,E←ξ0(σ)
h
ξ1(|t⟩|ψ⟩B,E) = 1
i
−
Pr
|t⟩|ψ⟩B,E←ξ0(σ)
h
ξ1(|t⟩(Ztm1−b
B,2
|ψ⟩B,E) = 1
i
(33)
=

Z
|t⟩|ψ⟩B,E
Pr
h
ξ0(σ) = |t⟩|ψ⟩B,E
i 
Pr
h
ξ1(|t⟩|ψ⟩B,E) = 1
i
−Pr
h
ξ1(|t⟩(Ztm1−b
B,2
|ψ⟩B,E))
i
(34)
≤
Z
|t⟩|ψ⟩B,E
Pr
h
ξ0(σ) = |t⟩|ψ⟩B,E
i Pr
h
ξ1(|t⟩|ψ⟩B,E) = 1
i
−Pr
h
ξ1

|t⟩(Ztm1−b
B,2
|ψ⟩B,E)

= 1
i
(35)
=
E
ξ0(σ)=|t⟩|ψ⟩B,E
h Pr
h
ξ1(|t⟩|ψ⟩B,E) = 1
i
−Pr
h
ξ1(|t⟩(Ztm1−b
B,2
|ψ⟩B,E)) = 1
i
i
(36)
Moreover, it is well known that for any state ρ and σ, TD(ρ, σ) = maxP Tr P(ρ −σ) =
maxP Pr [ P(ρ) = 1 ] −Pr [ P(σ) = 1 ] (see e.g. [NC10, eq. 9.22]), where the maximum is
taken over any POVM. Since ξ1 is a POVM, we have therefore
| Pr
h
ξ1(|t⟩|ψ⟩B,E) = 1
i
−Pr
h
ξ1(|t⟩(Ztm1−b
B,2
|ψ⟩B,E)) = 1
i
|
(37)
31We slightly abuse notations, as technically a POVM is not a map but a set of projectors (one for each
outcome), so we deﬁne Pr [ ξ0(ρ) = 1 ] = Tr(ξ0ρ).
46

≤TD(|ψ⟩T ,B,E , Ztm1−b
B,2
|ψ⟩T ,B,E)
(38)
(31)
≤2t
q
βψ
(39)
(Note that β is diﬀerent for any value of |ψ⟩T ,B,E, hence the notation βψ)
By injecting that into Eq. (36), we get
| Pr [ World3 = 1 ] −Pr [ World2 = 1 ] | ≤
E
|t⟩|ψ⟩B,E←ξ0(σ)
h
2t
q
βψ
i
= α
(40)
Finally, the last step is to prove that α is negligible, by reducing it to the probability of
ﬁnding a collision.
We already shown above that given |t⟩|ψ⟩B,E, there is a procedure Ph to ﬁnd a collision
with probability greater than tβψ (but the initial state might depend on h). From that,
we can deﬁne the algorithm that ﬁrst runs ξ0(σλ) (σλ is now independent of h, and h is
sampled according to Gen(1λ) in ξ0 as expected), then Ph. The probability success of this
procedure is therefore:
α′ :=
E
|t⟩|ψ⟩B,E←ξ0(σ) [ tβψ ]
(41)
Because h is collision resistant (Deﬁnition 2.10), we have α′ = negl(λ). Moreover, by
deﬁning f(x) =
√
2x, f is concave, and therefore using Jensen’s inequality we get:
α =
E
|t⟩|ψ⟩B,E←ξ0(σ)
h
2t
q
βψ
i
(42)
=
E
|t⟩|ψ⟩B,E←ξ0(σ)
h
2
q
tβψ
i
(43)
≤2
r
E
|t⟩|ψ⟩B,E←ξ0(σ) [ tβψ ]
(44)
= 2√α
(45)
= negl(λ)
(46)
Therefore, since we know that World2 ≈αWorld3 and we just proved that α is negligible,
we get that World2 ≈World3.
Finally, it is easy to see that World3 = World4 since they are actually exactly the same quantum
map, except that we attribute the operations to diﬀerent parties. By deﬁning S ˆA,Z as the block
composed of all elements on the left of the ideal resource, we have World5 = IDEALσ,FOT
˜Π,S ˆ
A,Z.
By transitivity, we have World0 ≈World4, i.e. REALσ
Π, ˆA,Z ≈IDEALσ,FOT
˜Π,S ˆ
A,Z which concludes
the proof.
This small lemma is useful to prove Theorem 3.1:
Lemma B.1. Let |φ⟩and |φ′⟩be two normalized orthogonal pure states and β ∈[0, 1]. We
consider the normalized state |ψ⟩= √1 −β |φ⟩+ √β |φ′⟩. Then, TD(|φ⟩, |ψ⟩) = √β.
47

Proof of Lemma B.1. This is a direct characterization of the fact that for any pure states |φ⟩
and |ψ⟩, TD(|φ⟩, |φ⟩) =
p
1 −| ⟨ψ|φ⟩|2 (see e.g. [Wil17, eq. (9.173)]):
TD(|φ⟩, |ψ⟩) =
q
1 −| ⟨φ|ψ⟩|2 =
q
1 −| ⟨φ| (
p
1 −β |φ⟩+
p
β |φ′⟩)|2
(47)
=
q
1 −|
p
1 −β|2 =
p
β
(48)
C
Proof of the ZKoQS and k-out-of-n string OT protocols
Proof of Theorem 4.10. Let S be any subset of parties, and let us assume the above assumptions.
Let Π = (P, V) be a protocol that CSS-QSA-realizes F M,f0
PartMeas with the above dummy ideal
parties. We prove that Π is a ZKoQSS protocol, by proving ﬁrst the completeness.
First, since Π CSS-QSA-realizes F M,f0
PartMeas, by deﬁning S(ω) := ˜P(ω)
F M,f0
P artMeas
↭
˜V, we have in
particular (P ↭V) ≈c S and S runs in poly-time since M is eﬃciently implementable. Let
ω such that Lω ̸= ∅. Because Lω ̸= ∅, ˜P(ω) produces, by deﬁnition, a state ρV0,P
0
in Eω, and
since ˜V sends f = ⊤, ˜P outputs ωs = f0(m), where m is the measurement outcome of the ideal
functionality. Also, by deﬁnition of F M,f0
PartMeas, the post-measured state is ρP,V = ξm(ρV0,P
0
).
Therefore, by deﬁnition of Lω,ωs, the output state ρP,V belongs to Lω,ωs with probability 1,
and ˜V always outputs a = 1. Therefore, Eq. (3) is true, completing the proof of completeness.
We proceed now with the soundness:
Let ˆP = {ˆPλ}λ∈N be a malicious prover (unbounded if P ∈S, in which case all symbols
≈c should be replaced with ≈s in the rest of this proof). Because Π CSS-QSA-realizes
F M,f0
PartMeas, there exists S′
ˆP such that (ˆP ↭V) ≈c S′
ˆP
F M,f0
P artMeas
↭
˜V. So let us deﬁne SˆP(σP
λ) =
(S′
ˆP(σP
λ)
F M,f0
P artMeas
↭
˜V): we then have (ˆP ↭V) ≈c SˆP. Moreover, since LQ corresponds to
all the bipartite states that can be obtained when applying ξm for some m on the ﬁrst
register, and an arbitrary deviation depending on f0(m) on the other register (remember that
F M,f0
PartMeas gives back f0(m) to the adversary, so ˆξf0(m) would be deﬁned as the second part
of SˆP, after waiting for the answer of the functionality), Eq. (4) is true (even with probability
1), completing the proof.
We ﬁnish now with the quantum ZK property:
Let ˆV = {ˆVλ}λ∈N be a malicious veriﬁer (unbounded if V ∈S, in which case all symbols ≈c
should be replaced with ≈s in the rest of this proof). Because Π CSS-QSA-realizes F M,f0
PartMeas,
there exists S′
ˆV such that (P ↭ˆV) ≈c (˜P
F M,f0
P artMeas
↭
S′
ˆV). Then, we deﬁne SˆV(b) as follows.
First, if b = ⊥, it forwards the input of the environment to S′
ˆV together with ⊥(pretending
to be the functionality F M,f0
PartMeas). Since ˜P(ω) aborts iﬀLω = ∅, we actually have for any ω
such that Lω = ∅, ˜P(ω)
F M,f0
P artMeas
↭
S′
ˆV = (ξω ⊗I)(SˆV(Lω ̸= ∅) where ξω is given b as input and
outputs ⊥if b = ⊥: by transitivity, Eq. (5) is true in that case. Otherwise, if b = ⊤, since M
are postponable measurement operators with respect to G, there exists by deﬁnition ρV,F
and a quantum map M′ such that MG ≈s (IV ⊗M′)(ρV,F ⊗G). Therefore, ˜P
F M,f0
P artMeas
↭
S′
ˆV is
equivalent to:
48

1. Generate ρV,F and send ρV to S′
ˆV (pretending to be F M,f0
PartMeas) to get a function f and
an output state ρ′.
2. Run M′(ρF ⊗G(ω)) to get outcome m′, send back fω(m′) to ˜P(ω) and outputs the ﬁnal
state of ˜P(ω).
However, if we deﬁne SˆV to do the ﬁrst step, and ξω to be the second and third step (when
b = 1), we have (˜P
F M,f0
P artMeas
↭
S′
ˆV) = (ξω ⊗I)SˆV, therefore Eq. (5) is respected, concluding the
proof.
Proof of Theorem 4.12. Case 1: correctness (no corrupted party).
We prove ﬁrst correctness when the parties are all honest:
First, if Pred(T) = ⊥, the parties abort in both the ideal and real worlds. Otherwise, like
in Theorem 3.1, the ZK proof in the real world succeeds by the completeness of the ZK
protocol, and the ﬁrst measurement of Bob will not disturb the state, so we can remove
indistinguishably the ZK proof and the ﬁrst measurement of Bob (we should technically
deﬁne new worlds as we did before, but we omit them for conciseness as we already applied
similar arguments earlier). Similarly, since for any j ∈T, the ﬁrst register of the state ρ(j) is
already measured, the Hadamard basis measurement on its second register does not alter
the state, so we can remove indistinguishably all operations involving ρ(j)’s except for the
measurements in the computational basis by P. Therefore, we can concentrate now on ρ(i)
for i ∈[n] \ T, and show that the random rotation Zr(i) followed by the map x →x, w(i)
x ,
the Hadamard measurement on the second register, and the update of r(i) is statistically
indistinguishable from a single random Zr(i).
Let i ∈[n] \ T. We can show this property in two ways: either by doing the computation
directly on density matrices (which is a bit long, but we do it below for completeness),
or remark that the map and Hadamard measurement commute with the Zr(i), and that
the map and Hadamard measurement performs a Z⟨s(b),w(b)
0 ⟩rotation: therefore we can
sample r(i) after knowing the outcome of the measurement, and since the distribution
r(i) is indistinguishable from the distribution c ⊕r(i) for any constant c, we can take
c = ⟨s(b), w(b)
0 ⟩to cancel the rotation applied earlier by the Hadamard, making it virtually
equal to a single rotation Zr(i).
We provide now an alternative proof, more verbose but certainly more formal, by
directly computing the appropriate density matrices. If we consider a puriﬁcation32 of ρ(i),
there exists two vectors |ψ0⟩and |ψ1⟩such that ρ(i) = α0 |0⟩|ψ0⟩+ α1 |1⟩|ψ1⟩. Moreover,
if we consider the density operator of this whole process, we have after the sampling of a
(put on the ﬁrst register) and Za rotation:
1
2(|0⟩(α0 |0⟩|ψ0⟩+ α1 |1⟩|ψ1⟩))((α∗
0 ⟨ψ0| ⟨0| + α∗
1 ⟨ψ1| ⟨1|) ⟨0|)
+1
2(|1⟩(α0 |0⟩|ψ0⟩−α1 |1⟩|ψ1⟩))((α∗
0 ⟨ψ0| ⟨0| −α∗
1 ⟨ψ1| ⟨1|) ⟨1|)
(49)
32Technically ρ(i) could be entangled with other ρ(i′), so this puriﬁcation might contain elements in ρ(i′). This
is not an issue as soon as we apply this transformation sequentially, on a single i at a time.
49

Then, after the x 7→x, w(c)
x
operation, and the Hadamard (omitting the normalisation
factor), we get:
X
sb
X
s′(i)
(1
2(|0⟩(α0(−1)⟨s(i),w(i)
0 ⟩|0⟩|ψ0⟩|s(i)⟩+ α1(−1)⟨s(i),w(i)
1 ⟩|1⟩|ψ1⟩|s(i)⟩))
((α∗
0(−1)⟨s′(i),w(i)
0 ⟩⟨s′(i)| ⟨ψ0| ⟨0| + α∗
1(−1)⟨s′(i),w(i)
1 ⟩⟨s′(i)| ⟨ψ1| ⟨1|) ⟨0|)
+ 1
2(|1⟩(α0(−1)⟨s(i),w(i)
0 ⟩|0⟩|ψ0⟩|s(i)⟩−α1(−1)⟨s(i),w(i)
1 ⟩|1⟩|ψ1⟩|s(i)⟩))
((α∗
0(−1)⟨s′(i),w(i)
0 ⟩⟨s′(i)| ⟨ψ0| ⟨0| −α∗
1(−1)⟨s′(i),w(i)
1 ⟩⟨s′(i)| ⟨ψ1| ⟨1|) ⟨1|))
(50)
However, since the output of P XOR to b the value ⟨s(i), w(i)
0 ⊕w(i)
1 ⟩, the ﬁnal density matrix
representing this process is as follows (to obtain this, we factored out the (−1)⟨s(i),w(i)
0 ⟩
that gets canceled as a global phase, we rename αs(i) := ⟨s(i), w(i)
0 ⊕w(i)
1 ⟩, and we XOR
the ﬁrst register with αs(i)):
1
2
X
sb
X
s′(i)
((|αs(i)⟩(α0 |0⟩|ψ0⟩|s(i)⟩+ α1(−1)αs(i) |1⟩|ψ1⟩|s(i)⟩))
((α∗
0 ⟨s′(i)| ⟨ψ0| ⟨0| + α∗
1(−1)αs′(i) ⟨s′(i)| ⟨ψ1| ⟨1|) ⟨αs(i)|)
+ (|1 ⊕αs(i)⟩(α0 |0⟩|ψ0⟩|s(i)⟩−α1(−1)αs(i) |1⟩|ψ1⟩|s(i)⟩))
((α∗
0 ⟨s′(i)| ⟨ψ0| ⟨0| −α∗
1(−1)αs′(i) ⟨s′(i)| ⟨ψ1| ⟨1|) ⟨1 ⊕αs(i)|))
(51)
Moreover, the last register s(i) is discarded, so we can trace is out:
1
2
X
sb
((|αs(i)⟩(α0 |0⟩|ψ0⟩+ α1(−1)αs(i) |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| + α∗
1(−1)αs(i) ⟨ψ1| ⟨1|) ⟨αs(i)|)
+ (|1 ⊕αs(i)⟩(α0 |0⟩|ψ0⟩−α1(−1)αs(i) |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| −α∗
1(−1)αs(i) ⟨ψ1| ⟨1|) ⟨1 ⊕αs(i)|))
(52)
We have now two cases: if w(i)
0 ⊕w(i)
1
= 0 . . . 0, then αs(i) = 0 and we actually see that the
second register is not even entangled with the ﬁrst one, so the Hadamard measurement
does not change the ﬁrst qubit, therefore we only apply a random Za on it and output
a, like in the ideal world. Now, if w(i)
0 ⊕w(i)
1
̸= 0, then the the number of s(i) such that
αs(i) = 0 is exactly equal to the number of cases where αs(i) = 1:
To see that, since w(i)
0 ⊕w(i)
1
̸= 1, there exists one position where they diﬀer: then, just
ﬂipping the bit of s(i) at that position will also ﬂip the value of αs(i), providing a simple
way to partition s(i)’s in two sets of equal size, each set having the same value of αs(i).
Therefore, we can sum over αs(i) instead of sb (this adds a ﬁxed constant (thanks to the
argument we just mentioned) factor that we ignore for simplicity):
1
2
X
αs(i)∈{0,1}
((|αs(i)⟩(α0 |0⟩|ψ0⟩+ α1(−1)αs(i) |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| + α∗
1(−1)αs(i) ⟨ψ1| ⟨1|) ⟨αs(i)|)
+ (|1 ⊕αs(i)⟩(α0 |0⟩|ψ0⟩−α1(−1)αs(i) |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| −α∗
1(−1)αs(i) ⟨ψ1| ⟨1|) ⟨1 ⊕αs(i)|))
(53)
50

= 1
2((|0⟩(α0 |0⟩|ψ0⟩+ α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| + α∗
1 ⟨ψ1| ⟨1|) ⟨0|)
+ (|1⟩(α0 |0⟩|ψ0⟩−α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| −α∗
1 ⟨ψ1| ⟨1|) ⟨1|)
+ (|1⟩(α0 |0⟩|ψ0⟩−α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| −α∗
1 ⟨ψ1| ⟨1|) ⟨1|)
+ (|0⟩(α0 |0⟩|ψ0⟩+ α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| + α∗
1 ⟨ψ1| ⟨1|) ⟨0|))
(54)
= 1
2((|0⟩(α0 |0⟩|ψ0⟩+ α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| + α∗
1 ⟨ψ1| ⟨1|) ⟨0|)
+ (|1⟩(α0 |0⟩|ψ0⟩−α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| −α∗
1 ⟨ψ1| ⟨1|) ⟨1|)
+ (|1⟩(α0 |0⟩|ψ0⟩−α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| −α∗
1 ⟨ψ1| ⟨1|) ⟨1|)
+ (|0⟩(α0 |0⟩|ψ0⟩+ α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| + α∗
1 ⟨ψ1| ⟨1|) ⟨0|))
(55)
= (|0⟩(α0 |0⟩|ψ0⟩+ α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| + α∗
1 ⟨ψ1| ⟨1|) ⟨0|)
+ (|1⟩(α0 |0⟩|ψ0⟩−α1 |1⟩|ψ1⟩))
((α∗
0 ⟨ψ0| ⟨0| −α∗
1 ⟨ψ1| ⟨1|) ⟨1|)
(56)
We see (once we renormalize this state) that this is exactly the density matrix of the ideal
world that applies a random Za operation on the qubit and outputs a in the ﬁrst register.
Case 2: malicious veriﬁer. We prove now the equivalence of the ideal and real worlds if
the adversary corrupts the veriﬁer.
We consider now the case where the adversary A = ˆV corrupts the veriﬁer. The proof of this
section is quite close to the second case of the proof of Theorem 3.1, so we will be quicker here.
First, as before we cut ˆV into multiple parts (ˆV0 running against Ah to generate h, ˆV1 will be
the circuit run when receiving ⊥(since the interaction will stop there in that case, ˆV1 only
outputs a state for the environment), otherwise ˆV2 will be the circuit playing the ZK proof,
and ˆV3 receiving the quantum state and outputting a ﬁnal state and the measurements back
to A). Then, similarly to what we did before we deﬁne the simulator SˆV as follows: ﬁrst, the
simulator will simulate the protocol Πh by running Sh, ˆB0 to get h. Then, if the output of the
functionality F Pred
SemCol is ⊥, it will run ˆV1 and forward the output of ˆV1 to the environment.
Otherwise, it samples all w(d)
c
starting with a 0, computes the hashes {h(c)
d }c∈[n],d∈{0,1}, and
runs the ZK simulator Szk, ˆB2((h(c)
d )c,d). Then, for all c ∈[n], it will sample r(c)
$←{0, 1}
and send the states ρ(c) = |0⟩|w(c)
0 ⟩+ (−1)r(c) |1⟩|w(c)
1 ⟩. After receiving the {s(c)}c∈{0,1}, it
deﬁnes f(T, (m(j))j∈T , (r(i))i∈[n]\T ) := (r(i) ⊕L
k s(i)[k](w(i)
0 ⊕w(i)
1 )[k])i∈[n]\T and sends f to
the functionality.
51

To prove that we have P ↭ˆV ≈c ˜P
F Pred
SemCol
↭
SˆV (≈c are replaced with ≈s if {V} ∈S),
we can ﬁrst study the case where the classical message T sent to the prover is such that
Pred(T) = ⊥. In that case, by deﬁnition of P, P will abort, and send ⊥to ˆV, which is also
exactly what SˆV is doing once ˜P sent the abort bit forwarded by the functionality to the
simulator. Now, we focus on T such that Pred(T) = ⊤, and therefore ˆV1 is never called. We
can design as before a series of games, where we also cut P is a part that runs Πh, a part P0
that checks Pred, a part P1 that measures the state and samples w’s, a part P2 that runs the
ZK proof, and the last part P3 that runs the rest of the protocol (we refer to Theorem 3.1 for
more details on the steps that are almost identical).
– We start from P ↭ˆV. Then, we replace P0 interacting with ˆB0 with Sh, ˆB0 to get h. Both
worlds are indistinguishable since Πh CSSh-QSA realizes F Gen
CRS.
– Then, since the statement proven is true, we can replace P2 interacting with V2 with
Szk,V2 that only takes as input the hashes. This is indistinguishable since Πzk CSS-QSA
realizes FZK.
– Then, we can new sample all w’s such that they start with a 0, which is indistinguishable
thanks to the hardcore second-bit property (Deﬁnition 2.9) of h.
– Then, we sample r(i) for all i ∈[n], and instead of measuring the qubits for i ∈T, we
rotate them according to Zr(i). This is statistically indistinguishable since neither l nor
r(i) are reused anywhere else, and are therefore discarded. But one can easily see that
measuring and discarding the outcome is statistically equivalent to applying Zr(i) and
discarding r(i). This can easily be seen diagrammatically (using the doubling formalism),
or via simple computations:
If we purify a state as α0 |0⟩|ψ0⟩+ α1 |1⟩|ψ1⟩, then applying a random Z phase on the
ﬁrst qubit gives the density matrix:
1
2((α0 |0⟩|ψ0⟩+ α1 |1⟩|ψ1⟩)(α∗
0 ⟨ψ0| ⟨0| + α∗
1 ⟨ψ1| ⟨1|)
+ (α0 |0⟩|ψ0⟩−α1 |1⟩|ψ1⟩)(α∗
0 ⟨ψ0| ⟨0| −α∗
1 ⟨ψ1| ⟨1|))
(57)
= |α0|2 |0⟩|ψ0⟩⟨ψ0| ⟨0| + |α1|2 |1⟩|ψ1⟩⟨ψ1| ⟨1|
(58)
and this second line corresponds to the density matrix of a (non-destructive) measure-
ment in the computational basis.
– Finally, by reorganizing the elements and using the functionality with the appropriately
chosen function f deﬁned above to pick the appropriate r(i) ⊕⟨s(i), w(i)
0 ⊕w(i)
1 ⟩only for
i ∈[n] \ T, we obtain the ideal world concluding the proof.
Case 3: malicious prover. We prove now the equivalence of the ideal and real worlds if
the adversary corrupts the prover.
We consider now the case where the adversary A = ˆP corrupts the prover. The proof of this
section is quite close to the last case of the proof of Theorem 3.1, so we will be quicker here.
First, we can divide ˆP and V into multiple parts: ˆP0 will interact with V0 that will play the
protocol Vh to obtain h, then ˆP1 will interact with V1 to run the ZK protocol, and ﬁnally ˆP2
will interact with V2 for the remaining part of the protocol.
Now, we can, as before, deﬁne a series of indistinguishable worlds.
– First, we start from the ideal world, and we replace ˆP0 and V0 with the simulator Sh,ˆP0
interacting with F Gen
H . This is indistinguishable since Πh realises F Gen
H .
52

– Similarly, we replace ˆP1 and V1 with the simulator Szk,ˆP1 interacting
– Then, since the simulator has now access to the set T, it can measure all the states in T
once the quantum test passes. To show that it is indistinguishable, we use the exact same
argument as the one made in case 3 of Theorem 3.1 to show that World2 ≈World3. The
only diﬀerences is that now we measure more states (but we can apply sequentially the
same argument for one state at a time, and since the number of states is polynomial the
distinguishing probability is still negligible: note that in the current proof the ZK contains
more statements, but in particular the statements needed in Theorem 3.1 are fulﬁlled).
The second diﬀerence is that we show that the trace distance between ρ and Z1ρZ†
1 is
smaller than 2t√β (Eq. (31)), while here we want to show that the trace distance between
ρ and the measured ρ (non-destructively and in the computational basis) denoted ρ′ is
negligible. However, we showed in Eq. (58) that rotating by a random Za (and discarding
the a) is strictly equivalent to measuring (non-destructively) and discarding the outcome.
Therefore:
TD(ρ, Mρ) = TD(ρ, 1
2ρ + 1
2Z1ρZ†
1)
(59)
≤1
2(TD(ρ, ρ) + TD(ρ, Z1ρZ†
1)
(60)
≤1
22t
p
β ≤2t
p
β
(61)
which allows us to conclude.
– Then, because the state is collapsed before applying the Hadamard basis measurement
on its second register, it is still collapsed after applying this measurement: so we can
indistinguishably apply a second measurement in the computational basis after.
– We can also, at the very end of the protocol, sample random (r(i))i∈[n]\T , and apply Zr(i)
twice on the i-th qubit: this is strictly equivalent since ZZ = I.
– Then, we can just attribute the operations to the appropriate parties and F Pred
SemCol to
obtain the ideal world: the simulator will run all the tasks, except that it sends ⊥to
F Pred
SemCol if the ZK protocol aborted, the second measurement in the computational basis on
qubits in T, together with the sampling of (r(i))i∈[n]\T and the ﬁrst rotation Zr(i) is done
by F Pred
SemCol (as expected by deﬁnition). Note that the second rotation Zr(i) (cancelling
the ﬁrst one) can be applied later by the simulator since ˜V sends f = ⊥, and therefore
the r(i)’s are sent back to the simulator. Since all these attribution does not change the
global map performed by all parties, this is statistically indistinguishable, concluding the
proof of security.
Proof of Corollary 4.15. The ﬁrst statement is a quite direct application of Theorem 4.10, where
we deﬁne:
– M like in Deﬁnition 4.11,
– and for any T ∈[n] = C, if Pred(T) = ⊤then ET := |T⟩⊗(|0⟩(T) |+⟩([n]\T)), otherwise
ET = ∅.
The only non-trivial check is to show that M are postponable measurement operators (Deﬁni-
tion 4.9) with respect to {GT }T,LT ̸=∅= {GT }T,Pred(T)=⊤. The idea is to do teleportation without
corrections, exploiting the fact that the uncorrected corrections just ﬂip the encoded bit without
53

changing its basis (note that to avoid dirty matrix computations, we give a more intuitive proof
in the ZX calculus (but it’s of course possible to derive the same proof with the usual matrix
algebra). We refer curious readers unfamiliar with the ZX calculus to [vdWet20].). More precisely,
we deﬁne ρV,F as the system containing n Bell pairs |00⟩+ |11⟩shared between registers V and
F (the Bell pairs being between the V(i) and F (i) for all i). Then, we deﬁne M′ as follows:
– M′ takes as input the register F containing Bell pairs, and a state ρ0 (sampled by GT ).
– Then, it runs Mρ0, to get a post-measured state ρ1 and a measurement outcome
(T, (m(j))j∈T , (r(i))i∈[n]\T )
(62)
– Then, for all i ∈[n], it performs a Bell measurement (i.e. it does a projection on {|0x⟩+
(−1)z |1¯x⟩}x∈{0,1},z∈{0,1}) between the i-th qubit of F and the i-th qubit of V to get outcomes
(x(i), z(i)).
– Finally, it outputs the outcome measurement (T, (x(j) ⊕m(j))j∈T , (z(i) ⊕r(i))i∈[n]\T )
We prove now that MGω ≈s (IV ⊗M′)(ρV,F ⊗Gω). Note that both M and M′ work separately
on each system composed of the i-th qubit of each register, we can therefore just consider each
system i ∈[n] separately. Let T ∈P([n]) such that Pred(T) = ⊤, and i ∈[n]. Then GT outputs
on qubit i the state Hδi/∈T |0⟩with probability 1/2 and Hδi/∈T |1⟩otherwise. We do two cases: if
i /∈T, then GT generated a state H |a⟩(we omit the index, H |a⟩being represented as
aπ
in
the ZX calculus), and M (and therefore M′) will perform a random Zr ﬂip on it (represented as
rπ
), we can easily see (manually or with the ZX calculus) that the ﬁnal state at the end of
the procedure (IV ⊗M′)(ρV,F ⊗Gω) is Zr⊕zH |a⟩:
xπ
aπ
rπ
zπ
Bell measurement
ρV,F = Bell pair:
(S)
=
xπ
(a⊕r⊕z)π
(C)
=
(a⊕r⊕z)π
(S)
=
aπ
(r⊕z)π
(63)
(the ﬁrst equality comes from the spider fusion rule that allows to merge spiders of the same
color, adding the angles modulo 2π, the second rule being a particular case of the copy rule and
the “only topology matters” principle that states that one can deform a graph without changing
its interpretation). Note that since r is sampled uniformly at random, and since the outcome of
the measurement z is independent of the value of rπ and uniformly distributed (this is easy to
see as the norm of this state (computable by computing the trace using the discarding ground
operation that trivially absorbs33 all terms:
(a⊕r⊕z)π
=
) is independent of the value of all
the variables). Therefore, by deﬁning r′ := r ⊕z, r′ is sampled uniformly at random, and the
ﬁnal state corresponds to a random rotation Zr′ of the original qubit, exactly like in the original
M operation, concluding the proof34.
Now, if i ∈T, then M′ will measure the state |a⟩provided by GT , but since it is anyway
already in the computational basis this measurement has no eﬀect (except revealing the value of
a). Then, the Bell measurement similarly gives:
xπ
aπ
zπ
(C)
=
xπ
aπ
(S)
=
(a⊕x)π
(64)
33Note that here we removed all scalars and global phases as they are just constant re-normalisation factors.
34If wants to be even more formal, we can actually compute the exact density matrix of the whole process,
including the outcome of the measurement, using either standard linear algebra, or diagrammatically using the
discard construction [CJP+21] or using the doubling formalism [CK17] to represent density matrices, but this
lead to the same result.
54

where
(a⊕x)π
= |a ⊕x⟩. We can similarly see that the outcome x is independent of a. Therefore,
since a and x are uniformly at random, the ﬁnal state is a state sampled uniformly at random
in the computational basis, exactly like in MGω, concluding this part of the proof.
Finally, the second statement is trivial to check: since we just shown that the functionality
F Pred
SemCol is a ZKoQS, all protocols realizing it are ZKoQS protocols. However, we already know
from Theorem 4.12 that Protocol 2 realizes F Pred
SemCol, with a slightly diﬀerent dummy ideal
party, say ˜P0. However, since we obtain the new ideal dummy party and new protocol by doing
exactly the same pre-processing (˜P = ˜P0(GT ) and P = P0(GT ), where P0 is the original party in
Protocol 2), the distinguishing probability between the new real world and ideal world is lower,
otherwise a distinguisher could apply GT to attack the original protocol known to be secure.
Proof of Corollary 4.18. The last statement is a direct consequence of Corollary 4.15 and of
the deﬁnition of ZKstatesQMAsetup
S
k. The ﬁrst statement is obtained by instantiating the ZK
protocol using the NIZK construction of [Unr15] secure in the Random Oracle model (we prove
in Section 5 that their deﬁnition can be translated in a the quantum standalone framework). The
second statement is obtained by instantiating the ZK protocol using the construction of [HSS11],
proven secure in the plain-model assuming the hardness of LWE (this construction is already
proven secure on the quantum standalone model, so no additional work is required).
Proof of Theorem 4.19. This is a straightforward generalisation of the last part of the proof of
Theorem 3.1. We start with correctness.
Case 1: correctness (no corrupted party). Since ΠSemCol CSS-QSA-realises F Pred
SemCol, we can
indistinguishably replace ASemCol and BSemCol with dummy ideal adversaries interacting with
F Pred
SemCol. Then, we show that this world is indistinguishable from the real world: if the input B is
such that Pred(T) = ⊥, all parties would abort like in the real world. Otherwise, if Pred(T) = ⊤,
then the functionality measures states not in B. . . but since these states are already measured,
it left them unchanged. It also rotates the qubits in B (in the Hadamard basis) them by Zz(i).
Therefore, for all i ∈B, the i-th qubit becomes ρ(i) = Zr(i)⊕s(i) |+⟩. After the rotation performed
by B, we get Zr(i)⊕s(i)⊕mi |+⟩, and therefore the measurement in the Hadamard basis gives
z(i) = r(i) ⊕s(i) ⊕mi. Since A outputs for each i ∈B, r(i) ⊕s(i) ⊕z(i) = mi, the output of A is
exactly the same as in the ideal world, making both worlds indistinguishable, concluding the
correctness proof.
Case 2: malicious receiver Alice. If ˆA is malicious, we can cut ˆA in two parts, ˆA0 interacting
with BSemCol and ˆA1 doing the rest of the computation. Since ΠSemCol CSS-QSA-realises F Pred
SemCol,
there exists a simulator S ˆ
A0 such that ˆA0 ↭BSemCol ≈c S ˆ
A0
F Pred
SemCol
↭
˜
BSemCol (or ≈s if P ∈S).
We can therefore indistinguishably replace the ﬁrst one with the last one. Since
˜
BSemCol measures
qubits not in B, the rotation on these qubits performed by Bob has no eﬀect: as a result, we
can remove them indistinguishably. Now, neither A nor B depends on mi for i /∈B, we can
therefore move them into the ﬁnal simulator, using the (mi)i∈B provided by F Pred
OT
otherwise
(note that if Pred(B) = ⊥, F Pred
OT
would not provide these values and abort, but this is not an
issue since anyway F Pred
SemCol also aborts in that case). This new world is therefore equal to the
ideal world, and indistinguishable from the previous world, concluding the proof of security.
Case 3: malicious sender Bob. If ˆB is malicious, we can cut ˆB in two parts, ˆB0 interacting
with ASemCol and ˆB1 doing the rest of the protocol. Since ΠSemCol CSS-QSA-realises F Pred
SemCol,
55

there exists a simulator S ˆB0 such that ASemCol ↭ˆB0 ≈c
˜
BSemCol
F Pred
SemCol
↭
S ˆB0 (or ≈s if P ∈S).
We can therefore indistinguishably replace the ﬁrst one with the last one. Then, since the qubits
in B are already in the computational basis, the functionality can skip the measurements of
these qubits without being detected. Similarly, as we already saw it earlier, since sampling a
qubit in |0⟩or |1⟩is indistinguishable from sampling a qubit in |+⟩or |−⟩(the encoded value
being discarded), we can indistinguishably apply an H gate on these qubits to turn them back
into qubits in the Hadamard basis, and also compute r(i) ⊕s(i) ⊕z(i) for these qubits (it will be
discarded anyway). Then, except for the return procedure of P that discards some terms, all the
steps are independent of mi’s: we can therefore move everything into our ﬁnal simulator, let
it send the r(i) ⊕s(i) ⊕z(i) to the ideal functionality F Pred
OT
that will be in charge of discarded
elements not it T. This last step is indistinguishable as we only moved some operations, ending
this proof of security.
D
Proof of the composability of [Unr15]
Deﬁnition D.1. 1. Completeness ([Unr15, Def. 1]): ΠH
zk is complete iﬀfor any quantum-
polynomial-time oracle algorithm A and advice (σλ)λ∈N,
Pr
h
(x, w) ∈R ∧y = 0
H ←ROdist, (x, w) ←AH(σλ),
y ←OUTV⟨P(x, w)
H
↭V⟩
i
≤negl(λ).
(65)
2. Zero-knowledge ([Unr15, Def. 2]): ΠH
zk is zero-knowledge iﬀthere exists a polynomial-time
simulator S = (Sinit, SP ) such that for every quantum-polynomial-time oracle algorithm A
and advice (σλ)λ∈N,
Pr
h
z = 1
 H ←ROdist, z ←AH,P(σλ)
i
−Pr
h
z = 1
 H ←Sinit, z ←AH,SP (σλ)
i ≤negl(λ).
(66)
Since in the quantum setting we cannot allow the simulator to learn the input for each query,
because this can be done in superposition, here the simulator Sinit outputs a circuit describing
a classical function representing the initial random oracle instead. We assume that both Sinit
and SP have access to the polynomial upper bound on the runtime of A.
3. Online-extractability ([Unr15, Def. 3]): ΠH
zk is online extractable with respect to Sinit iﬀ
there exists a polynomial-time extractor E such that for any quantum-polynomial-time oracle
algorithm A and advice (σλ)λ∈N,
Pr
h
y = 1 ∧(x, w) ̸∈R
H ←Sinit(), (x, π) ←AH(σλ), y ←VH(x, π),
w ←E(H, x, π)
i
≤negl(λ).
(67)
We assume that both Sinit and E have access to the polynomial upper bound on the runtime
of A.
Note that Unruh’s original deﬁnition he considers only uniform adversaries, here we assume
that the above conditions hold for the protocol when the adversary receives advice.
56

Proof of Theorem 5.1. We deﬁne trivially the dummy parties ˜Πzk = (˜P, ˜V) that forward the
inputs/outputs to/from F R
ZK. We want to show that for any (poly-)time adversary A there
exists a (poly-)time simulator S such that, for any poly-time distinguisher Z and input state σλ,
we have REALσ
Πzk,A,Z ≈IDEAL
σ,F R
ZK
˜Πzk,SA,Z. We will split the proof depending on the parties that
the static adversary A corrupts (nobody, the prover P or the veriﬁer V).
Note that in the non-interactive protocol ΠH
zk the prover rejects if it receives a non-valid
witness (x, w) ̸∈R, which is essential.
Case 1: correctness (no corrupted party). For any bipartite input state σP,Z
λ
∈D(Sλ ⊗Rλ),
with Rλ an arbitrary reference system, we want to show that for any environment Z the probability
of distinguishing ΠH
zk from the ideal functionality ˜Πzk is negligible
Pr
h
Z(y, σZ
λ ) = 1
 H ←ROdist, y ←OUTV⟨P(σP
λ)
H
↭V⟩
i
−Pr

Z(y, σZ
λ ) = 1
 H ←ROdist, y ←OUTV⟨˜P(σP
λ)
F
↭˜V⟩
 ≤negl(λ).
(68)
In order to prove the above inequality we are interested in rewriting the probability of the
distinguisher outputting 1 in terms of the input/output of the interaction. Since the prover
expects a classical message, we can model σP,Z
λ
as a quantum instrument:
σP,Z
λ
=
X
x,w
px,w|x, w⟩⟨x, w| ⊗σλ,x,w.
(69)
This allows to write the LHS of Eq. (68) as
X
x,w
px,w Pr
h
Z(y, σλ,x,w) = 1
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
(70)
=
X
b∈{0,1}
X
x,w

px,w Pr [ Z(b, σλ,x,w) = 1 ]
· Pr
h
y = b
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
(71)
For the dummy protocol ˜Πzk the above equation has a very simple form since if (x, w) ∈R
(resp. (x, w) ̸∈R), then ˜Πzk will output 1 (resp. 0) with probability 1. Therefore, for any input
state σP,Z
λ
we can simplify the RHS of Eq. (68) to
X
(x,w)∈R
px,w Pr [ Z(1, σλ,x,w) = 1 ] +
X
(x,w)̸∈R
px,w Pr [ Z(0, σλ,x,w) = 1 ]
(72)
For the honest protocol ΠH
zk, note that for invalid witnesses (x, w) ̸∈R the honest prover
PH will also always reject, therefore for (x, w) ̸∈R:
Pr
h
y = 1
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
= 0,
(73)
thus for an arbitrary mixture of invalid witnesses P
(x,w)̸∈R qx,w|x, w⟩⟨x, w| we will have that
X
(x,w)̸∈R
qx,w Pr
h
y = 1
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
= 0,
(74)
57

and consequently
X
(x,w)̸∈R
qx,w Pr
h
y = 0
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
= 1.
(75)
The case of valid witnesses is also easy as we know from completeness Eq. (65) that given
any input state (x, w) ∈R, if we pick the constant algorithm A : σP
λ 7→(x, w), then
Pr
h
y = 0
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
≤negl(λ),
(76)
thus for an arbitrary mixture of valid witnesses P
(x,w)∈R qx,w|x, w⟩⟨x, w| we will have that
X
(x,w)∈R
qx,w Pr
h
y = 0
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
≤negl(λ),
(77)
and consequently
X
(x,w)∈R
qx,w Pr
h
y = 1
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
≥1 −negl(λ).
(78)
We can combine the above Eqs. (74), (75), (77) and (78) to obtain the desired inequal-
ity Eq. (68) for any input σP,Z
λ
and any distinguisher Z by noting that for any received input
b ∈{0, 1} and advice σλ,x,w, the probability of the distinguisher outputing 1 is bounded
Pr [ Z(b, σλ,x,w) = 1 ] ≤1,
(79)
and therefore by developing Eq. (68) in terms of the advice as in Eq. (71) we can bound the
diﬀerence by
≤

X
(x,w)∈R
px,w Pr
h
y = 0
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i

+

X
(x,w)∈R
px,w

Pr
h
y = 1
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
−1


+

X
(x,w)̸∈R
px,w

Pr
h
y = 0
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i
−1


+

X
(x,w)̸∈R
px,w Pr
h
y = 1
 H ←ROdist, y ←OUTV⟨P(x, w)
H
↭V⟩
i

≤negl(λ),
(80)
Case 2: malicious Alice. If the adversary corrupts the prover A = ˆP, we will use online-
extractability to construct the desired simulator.
Simulator SA := (S, E, Sinit): Prover is corrupted.
1. S initializes ˆP with whatever input state it receives.
58

2. S obtains (x, π) from ˆP.
3. S initializes E with (x, π) and the description of the oracle H given by the simulator
Sinit.
4. E(H, x, π) extracts a witness w or an abort message ⊥and sends it to S.
5. S sends (x, w) or ⊥to F R
ZK.
We will now prove that no distinguisher can diﬀerentiate between the real protocol with
corrupted Alice and the ideal functionality with the above simulator. This proof relies on the
closeness of the following hybrid worlds (see Appendix D for a graphical depiction):
– World0 := IDEAL
σ,F R
ZK
˜Πzk,SA,Z is the ideal world. Consists of one output by the functionality
(forwarded by the dummy veriﬁer) which is accepting if the witness obtained by the extractor
in Item 4 is valid, i.e., (x, w) ∈R.
– World1 is like World0 except that we substitute the dummy veriﬁer by a merge of Unruh’s
veriﬁer V and the simulator. In particular, we replace ˜V by a veriﬁer V1 that forwards the
proof from the simulator to the extractor E. If the extractor provides a witness w, then V1
accepts y = x and else aborts y = ⊥.
– World2 is like World1 except that we drop the extractor (as it is only being used to check the
proof) and the dummy veriﬁer V1 which is only forwarding information, and we use Unruh’s
veriﬁer V to perform the check of the proof received by the simulator S instead.
– World3 is like World2 except that we drop the simulator S as it is only forwarding the
information to the veriﬁer.
– World4 diﬀers from World3 in that we replace the simulator Sinit by the oracle H that is
simulating. Note that now World4 := REALσ
Πzk,A,Z.
Z
S
(x, π)
(x, π)
ˆP
E
w/⊥
(x, w)/⊥
σP
λ
σλ
σZ
λ
σP
λ
Sinit
F ZK :
(
(x, w) ∈R 7→x
(x, w) /∈R 7→⊥
˜V
y ∈{x, ⊥}
y
Fig. 16: World0
Z
S
(x, π)
(x, π)
ˆP
E
w/⊥
σP
λ
σλ
σZ
λ
σP
λ
Sinit
V1
y ∈{x, ⊥}
(x, π)
x/⊥
V
Fig. 17: World1
59

The similarity of the ﬁrst two worlds, World0 ≈World1, is a consequence of online-extractability.
More precisely, if we could distinguish these two worlds, there would exit an input σP
λ such that
Pr

Z(y, σZ
λ ) = 1
 H ←Sinit(), y ←OUT˜V⟨SA(σP
λ)
F
↭˜V⟩

−Pr
h
Z(y, σZ
λ ) = 1
 H ←Sinit(), y ←OUTV1⟨SA(σP
λ) ↭V1⟩
i > negl(λ).
(81)
In order to work with them jointly we expand them in terms of the veriﬁer accepting/rejecting
y ∈{x, ⊥}:
Pr

Z(y, σZ
λ ) = 1
 H ←Sinit(), y ←OUT˜V⟨SA(σP
λ)
F
↭˜V⟩

−Pr
h
Z(y, σZ
λ ) = 1
 H ←Sinit(), y ←OUTV1⟨SA(σP
λ) ↭V1⟩
i
(82)
=

X
b∈{x,⊥}
Pr
h
Z(b, σZ
λ ) = 1
i
Pr

y = b
 H ←Sinit(), y ←OUT˜V⟨SA(σP
λ)
F
↭˜V⟩

−
X
b∈{x,⊥}
Pr
h
Z(b, σZ
λ ) = 1
i
Pr
h
y = b
 H ←Sinit(), y ←OUTV1⟨SA(σP
λ) ↭V1⟩
i

(83)
=
 Pr
h
Z(x, σZ
λ ) = 1
i
·
X
M∈{˜V,V1}
(−1)δV Pr

y = x
 H ←Sinit(), y ←OUTM⟨SA(σP
λ)
F
↭M⟩

+ Pr
h
Z(⊥, σZ
λ ) = 1
i
·
X
M∈{˜V,V1}
(−1)δV Pr
h
y = ⊥
 H ←Sinit(), y ←OUTM⟨SA(σP
λ) ↭M⟩
i 
(84)
≤

X
M∈{˜V,V1}
(−1)δ(V ) Pr

y = x
 H ←Sinit(), y ←OUTM⟨SA(σP
λ)
F
↭M⟩

+

X
M∈{˜V,V1}
(−1)δ(V ) Pr

y = ⊥
 H ←Sinit(), y ←OUTM⟨SA(σP
λ)
F
↭M⟩

.
(85)
We write down the probabilities of each protocol accepting, y = x, to better visualize:
Pr

y = x
 H ←Sinit(), y ←OUT˜V⟨SA(σP
λ)
F
↭˜V⟩

(86)
= Pr
h
y = x
H ←Sinit(), (x, π) ←ˆPH(σP
λ), w′ ←E(x, π, H),
y ←FZK(x, w′)
i
(87)
= Pr
h
w′ ̸= ⊥∧(x, w′) ∈R
H ←Sinit(), (x, π) ←ˆPH(σP
λ),
w′ ←E(x, π, H)
i
,
(88)
Pr
h
y = x
 H ←Sinit(), y ←OUTV1⟨SA(σP
λ) ↭V1⟩
i
(89)
60

= Pr
h
y = x ∧w′ ̸= ⊥
H ←Sinit(), (x, π) ←ˆPH(σP
λ), w′ ←E(x, π, H),
y ←V (x, π)
i
(90)
= Pr
h
y = x ∧w′ ̸= ⊥∧(x, w′) ∈R
H ←Sinit(), (x, π) ←ˆPH(σP
λ),
w′ ←E(x, π, H), y ←V (x, π)
i
(91)
+ Pr
h
y = x ∧w′ ̸= ⊥∧(x, w′) ̸∈R
H ←Sinit(), (x, π) ←ˆPH(σP
λ),
w′ ←E(x, π, H), y ←V (x, π)
i
,
(92)
where in the last equality we just used the marginal probability expansion. Moreover, by
online-extractability Eq. (67), we know that for all σP
λ:
Pr
h
y = x ∧w′ ̸= ⊥∧(x, w′) ̸∈R
H ←Sinit(), (x, π) ←ˆPH(σP
λ),
y ←V(x, π), w′ ←E(x, π, H)
i
< negl(λ),
(93)
Pr
h
y = x ∧w′ ̸= ⊥∧(x, w′) ∈R
H ←Sinit(), (x, π) ←ˆPH(σP
λ),
y ←V(x, π), w′ ←E(x, π, H)
i
> 1 −negl(λ),
(94)
thus bounding Eq. (92). Note that we can bound Eq. (91) by Eq. (88), as the former adds one
more restriction to the output. Therefore, the probabilities of each protocol accepting is nearly
the same as
Pr

y = x
 H ←Sinit(), y ←OUT˜V⟨SA(σP
λ)
F
↭˜V⟩

−Pr
h
y = x
 H ←Sinit(), y ←OUTV1⟨SA(σP
λ) ↭V1⟩
i
(95)
≤
Pr
h
w′ ̸= ⊥∧(x, w′) ∈R
H ←Sinit(), (x, π) ←ˆPH(σP
λ),
w′ ←E(x, π, H)
i
(96)
−Pr
h
y = x ∧w′ ̸= ⊥∧(x, w′) ∈R
H ←Sinit(), (x, π) ←ˆPH(σP
λ),
w′ ←E(x, π, H), y ←V (x, π)
i + negl(λ)
(97)
≤negl(λ).
(98)
This bound in enough to show the similarity of the worlds as
Pr

y = ⊥
 H ←Sinit(), y ←OUTM⟨SA(σP
λ)
F
↭M⟩

= 1 −Pr

y = x
 H ←Sinit(), y ←OUTM⟨SA(σP
λ)
F
↭M⟩

,
(99)
for both M = ˜V and M = V1.
We can also prove World1 ≈World2 using online extractability, as the veriﬁer V1 is only using
the extractor to see if it does not abort. More precisely, following the same argument as before,
and expanding the probability of accepting for the protocol from World2:
Pr
h
y = x
 H ←Sinit(), y ←OUTV⟨SA(σP
λ) ↭V⟩
i
(100)
61

Z
S
(x, π)
ˆP
σP
λ
σλ
σZ
λ
σP
λ
Sinit
(x, π)
y ∈{x, ⊥}
V
Fig. 18: World2
ˆP
σλ
σZ
λ
σP
λ
(x, π)
y ∈{x, ⊥}
V
Z
Sinit
Fig. 19: World3
ˆP
σλ
σZ
λ
σP
λ
(x, π)
y ∈{x, ⊥}
H
V
Z
Fig. 20: World4
= Pr
h
y = x
 H ←Sinit(), (x, π) ←ˆPH(σP
λ), y ←V(x, π)
i
(101)
= Pr
h
y = x ∧(x, w′) ∈
 H ←Sinit(), (x, π) ←ˆPH(σP
λ), y ←V(x, π)
i
+ Pr
h
y = x
 H ←Sinit(), (x, π) ←ˆPH(σP
λ), y ←V(x, π)
i
.
(102)
In order to proof the equivalence it is enough to note that
Pr
h
y = x
 H ←Sinit(), y ←OUTV1⟨SA(σP
λ) ↭V1⟩
i
−Pr
h
y = x
 H ←Sinit(), y ←OUTV⟨SA(σP
λ) ↭V⟩
i
(103)
=
Pr
h
y = x ∧w′ ̸= ⊥
H ←Sinit(), (x, π) ←ˆPH(σP
λ), w′ ←E(x, π, H),
y ←V (x, π)
i
−Pr
h
y = x
 H ←Sinit(), (x, π) ←ˆPH(σP
λ), y ←V (x, π)
i .
(104)
= Pr
h
y = x ∧w′ = ⊥
H ←Sinit(), (x, π) ←ˆPH(σP
λ), w′ ←E(x, π, H),
y ←V (x, π)
i
(105)
= Pr
h
y = x ∧w′ = ⊥∧(x, w′) ̸∈R
H ←Sinit(), (x, π) ←ˆPH(σP
λ),
w′ ←E(x, π, H), y ←V (x, π)]
(106)
<negl(λ),
(107)
where in Eq. (106) we used that {w′ = ⊥} ⊆{(x, w′) ̸∈R}.
The rest of the relations are obvious since World3 is just World2 with a diﬀerent routing of
the messages – the simulator S is only redirecting the information. World3 ≈World4 is changing
the Sinit by the oracle that it is simulating H.
Case 3: malicious Bob. If the adversary corrupts the veriﬁer A = V, the simulator from
[Unr15] from the zero-knowledge property will be enough.
Recall that in his description of the adversary it also encompasses the distinguisher, but by
allowing adversaries that receive advice, it is equivalent to assuming an adversary that outputs
62

a proof for the veriﬁer. This is, Unruh’s simulator S = (Sinit, S′
P ) fulﬁlls
Pr
h
Z(y, σZ
λ ) = 1
 H ←ROdist, (x, π) ←PH(σP
λ), y ←ˆV(x, π, σV
λ )
i
−Pr
h
Z(y, σZ
λ ) = 1
 H ←Sinit(), (x, π) ←S′
P (σP
λ), y ←ˆV(x, π, σV
λ )
i
< negl(λ).
(108)
Note that the simulator S′
P is replacing both the ideal functionality F R
ZK and the dummy veriﬁer
˜P in the ideal world, i.e. aborts whenever (x, w) ̸∈R and runs SP (x, σV
λ ) otherwise. However,
we can easily modify this simulator to obtain the desired one in terms of the subsimulator SP .
Simulator SA := (S, Sinit): Veriﬁer is corrupted.
1. If S does not receive an abort ⊥message from the ideal functionality F R
ZK, redirects the
input x to the simulator SP . Else, it aborts.
2. S receives (x, π) from the simulator SP (x).
3. S sends (x, π, σλ) to the veriﬁer V.
4. S redirects the output of the veriﬁer V to the distinguisher Z.
It is clear that Z cannot distinguish between the proofs provided by the veriﬁer and the
simulator, as our simulator is just a rewiering of Unruh’s simulator, see Fig. 23.
Z
S′
P
σλ
σZ
λ
σP,V
λ
SP
ˆV
y
(x, π)
x/⊥
 x, π, σV
λ

Sinit
σP
λ
Fig. 21: Protocol for S′
P .
Z
S
˜P
σP
λ
σλ
σZ
λ
σP
λ
SP
F ZK :
(
(x, w) ∈R 7→x
(x, w) /∈R 7→⊥
ˆV
y ∈{x, ⊥}
y
σV
λ
x
(x, π)
x/⊥
 x, π, σV
λ

Sinit
Fig. 22: Ideal functionality with SA.
Fig. 23: Construction of the simulator for adversarial veriﬁer.
63

