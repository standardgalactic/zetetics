Constrained Submodular Optimization for Vaccine Design
Zheng Dai,1 David K. Gifford, 1
1 Computer Science and Artiﬁcial Intelligence Laboratory, Massachusetts Institute of Technology
Cambridge, Massachusetts 02139 USA
zhengdai@mit.edu, gifford@mit.edu
Abstract
Advances in machine learning have enabled the predic-
tion of immune system responses to prophylactic and
therapeutic vaccines. However, the engineering task of
designing vaccines remains a challenge. In particular,
the genetic variability of the human immune system
makes it difﬁcult to design peptide vaccines that provide
widespread immunity in vaccinated populations. We in-
troduce a framework for evaluating and designing pep-
tide vaccines that uses probabilistic machine learning
models, and demonstrate its ability to produce designs
for a SARS-CoV-2 vaccine that outperform previous de-
signs. We provide a theoretical analysis of the approx-
imability, scalability, and complexity of our framework.
1
Introduction
Peptide vaccines that expand and activate T cells have
emerged as a promising prophylactic and therapeutic
approach for addressing health related challenges in-
cluding infectious diseases and cancer (Malonis, Lai,
and Vergnolle 2019). In contrast to more conventional
live-attenuated vaccines that are based on entire organ-
isms, or subunit vaccines that are based on entire pro-
tein subunits, peptide vaccines are based on a small set
of protein fragments (peptides) that are sufﬁcient to in-
duce a T cell immune response, enabling the elicitation
of far more targeted responses that avoid allergenic and
reactogenic responses (Li et al. 2014).
The design of a peptide vaccine consists of selecting
immunogenic protein fragments, usually referred to as
epitopes (Li et al. 2014), that when included in a vaccine
expand epitope speciﬁc T cells. Advances in machine
learning have enabled our ability to predict which pep-
tides will be presented by major histocompatibilty com-
plex (MHC) molecules for surveillance by the adaptive
immune system (Ching et al. 2018, Reynisson et al.
2020), which can be used to identify which epitopes will
be displayed (Sohail et al. 2021).
The epitopes displayed by an individual depend upon
the speciﬁc alleles of their MHC genes, and thus the
peptides displayed by the immune system can vary
greatly from individual to individual (Zaitouna, Kaur,
Copyright © 2023, Association for the Advancement of Arti-
ﬁcial Intelligence (www.aaai.org). All rights reserved.
and Raghavan 2020). Therefore, the engineering task of
ﬁnding a set of peptides that is predicted to be displayed
by a large portion of the population remains challenging
despite progress on the peptide-MHC display task.
In this work we introduce a framework for evalu-
ating and designing peptide vaccines that uses proba-
bilistic interpretations of machine learning models, and
demonstrate its ability to produce designs for the SARS-
CoV-2 vaccine design task that outperform previous de-
signs. We complement this with a theoretical analysis of
the approximability, scalability, and complexity of our
framework, which may be of independent interest.
1.1
Our contribution
To improve the effectiveness of a vaccine it is important
to introduce redundancies into its design so the failure
of a single displayed peptide to elicit an immune re-
sponse does not become a single point of failure (Liu
et al. 2021). Vaccines designed with an n-times cover-
age objective aim to obtain at least n immunogenic pep-
tide “hits” in each person. Having more than one “hit”
provides redundancy to expand multiple T cell clono-
types in an individual to ﬁght disease, protects against
peptide sequence drift resulting from pathogen or tu-
mor mutations, protects against the loss of an MHC
gene, and accounts for the variability of peptide im-
munogenicity between individuals.
We show that optimizing the population coverage for
strict n-times coverage guarantees cannot be tractably
approximated to any constant factor assuming the in-
tractability of the GAP-SMALL-SET EXPANSION prob-
lem (Raghavendra and Steurer 2010), a result which
may be of independent interest. We therefore propose
a diminishing returns framework that uses a soft redun-
dancy guarantee as its objective. The resulting objec-
tive is both submodular and monotonic, and can there-
fore be approximated via a greedy approach which we
call Optivax-P. We supplement the theoretical improve-
ment with an empirical comparison of vaccines de-
signed using our approach and previous designs. Our
proposed framework also contributes the following de-
sirable properties: it makes explicit the utility of hav-
ing redundancy, does not discount the beneﬁts of be-
ing covered without redundancy, and is able to reason
arXiv:2206.08336v2  [q-bio.QM]  27 Jan 2023

with uncertainty. We demonstrate how uncertainty val-
ues for epitope identiﬁcation can be derived by calibrat-
ing state-of-the-art peptide-MHC display predictors.
While redundancies in a design are important, it is
also important that they be dissimilar redundancies,
since reasons for failure may be shared between similar
peptides. This additional constraint that selected pep-
tides be dissimilar is problematic as it allows the prob-
lem formulation to encode NP-hard graph problems that
in general cannot be approximated to any constant fac-
tor. However, by parameterizing on the structure of the
constraints, we can derive lower bounds for the per-
formance of the greedy approach which show that the
greedy approach can still provide approximation guar-
antees under certain assumptions. These bounds may
also be of independent interest.
1.2
Related work
The use of computational methods to aid vaccine design
has taken on an increasingly important role in the vac-
cine design process over the past two decades (Moise
et al. 2015). Much of the advancement stems from im-
provements in the epitope identiﬁcation task, which has
seen impressive improvements with advances in data
collection strategies and machine learning (Ching et al.
2018, Reynisson et al. 2020). While good epitope pre-
diction tools are essential to vaccine design, the focus
of this work is on the downstream task of calibrating
the predictions and selecting deﬁned epitopes for vac-
cine inclusion.
Earlier works on vaccine design are reviewed in
Oyarzun and Kobe (2015), and employ discrete opti-
mization techniques such as integer linear programming
and genetic algorithms to optimize population cover-
age. However, they do not anticipate or solve the prob-
lem of coverage with dissimilar redundancies (Liu et al.
2021), which we do in this work. Furthermore, they do
not consider the epistemic uncertainty associated with
epitope predictions, which we do.
Our work is closely related to the work in (Liu et al.
2021), where the use of an objective that accounts for
dissimilar redundancies is proposed. However, approx-
imating their proposed objective to any constant fac-
tor appears to be an intractable problem, while our ob-
jective permits constant factor approximations in poly-
nomial time. Our framework also allows for reasoning
about redundancies with uncertainty, which theirs does
not.
1.3
Presentation
In the remaining four sections of the paper we present
the optimization problem that we wish to solve (Sec-
tion 2), provide an algorithm for solving the problem
and analyze its runtime and approximation guarantees
(Section 3), apply our framework to the SARS-CoV-2
vaccine design problem (Section 4), and conclude with
a discussion (Section 5). Theorems are presented where
appropriate throughout. Proofs, including intuitive de-
scriptions, are relegated to Appendix A for improved
ﬂow.
2
A diminishing returns objective enables
theoretical performance guarantees
Our goal in this section is to formalize the vaccine de-
sign problem as an optimization problem. We ﬁrst show
theoretical barriers to obtaining performance guarantees
for previous formalizations, and then introduce the di-
minishing returns framework which addresses this.
Peptide vaccines are designed by considering the
peptide sequence(s) of a target of interest, for example
the proteome of a virus, and selecting a small set of pep-
tides within the target sequences to include in the vac-
cine. Vaccine peptides are selected such that they elicit
an immune response in a large portion of a suscepti-
ble population that we wish to vaccinate. This is done
by selecting vaccine peptides that are displayed on the
cell surface by MHC proteins. The resulting peptide-
MHC complexes activate the cellular immune system.
The challenge of selecting a set of peptides arises from
the polymorphism present in MHCs within a popula-
tion. Different MHC alleles have different peptide bind-
ing properties, so the peptides must be carefully chosen
in order to elicit widespread immune responses from a
given population.
2.1
Preliminaries
Let R≥0 denote non-negative real numbers. Let E be
some ﬁnite set of elements. Let F : 2E →R≥0. We say
F is submodular if F(S1 ∪{e}) −F(S1) ≥F(S2 ∪
{e}) −F(S2) whenever S1 ⊆S2 and e ∈E , and we
say that F is monotonically increasing if S1 ⊆S2 =⇒
F(S1) ≤F(S2) for all S1, S2 ⊆E.
Suppose G = (V, E) is a graph. For simplicity, we
will at times use GV to denote its vertex set V and GE
to denote its edge set E. The kth power of G, denoted
Gk, is deﬁned as the graph (Gk
V , Gk
E), where Gk
V =
GV and Gk
E contains all pairs of vertices between which
there exists a path of length less than or equal to k in G.
We will use 1X to denote an indicator that evaluates
to 1 if X is true and 0 otherwise for any proposition X.
2.2
Optimizing population coverage with
redundancies is computationally difﬁcult
It is important for a vaccine to cause the display of mul-
tiple epitopes in individuals to provide redundancy in
the activation of T cell clonotypes, to expand multiple
T cell clonotypes in an individual to ﬁght disease, to
protect against peptide sequence drift as a consequence
of pathogen or tumor mutations, to protect against the
loss of an MHC gene, and to account for the variabil-
ity of peptide immunogenicity between individuals (Liu
et al. 2021). In Liu et al. (2021), the authors showed
that previous vaccine designs fail to cover signiﬁcant
portions of the population when coverage criteria in-
clude these redundancies. To address this, they intro-
duce the n-times coverage framework, which involves

solving the max n-times coverage problem. The prob-
lem is deﬁned as follows:
Deﬁnition 1. Given a ground set, a set of weights over
the ground set, a collection of multisets whose elements
are from the ground set, and some cardinality constraint
k, ﬁnd a collection of k multisets such that the aggre-
gate weights of the elements in the ground set that are
covered at least n times is maximized.
The sum of the weights of the the elements that are
covered at least n times is then called the n-times cov-
erage. For vaccine design, the ground set corresponds
to MHC genotypes, the weights correspond to the per-
centage of the population with the genotypes, and each
multiset corresponds to a peptide, which covers cer-
tain genotypes a variable number of times. Solving this
problem with cardinality constraint k then gives a vac-
cine design consisting of k peptides, with the objective
that a large portion of the population display at least n
peptides (i.e. have at least n peptide-MHC hits).
While this is a natural extension of earlier vaccine
design paradigms that do not account for redundancies,
it is a computationally difﬁcult problem. The authors
have shown in their work that this is an NP-hard op-
timization problem, and so they propose heuristic ap-
proaches. However their proposed approaches have no
performance guarantees. Here, we show that this prob-
lem is related to GAP-SMALL-SET EXPANSION, which
suggests that ﬁnding any constant factor approximation
cannot be achieved in polynomial time.
Theorem 1. For any ϵ > 0, if there exists a poly-
nomial time algorithm that can achieve an approx-
imation factor of ϵ to max n-times coverage, then
there exists a polynomial time algorithm that can de-
cide GAP-SMALL-SET EXPANSION(η) for some η ∈
(0, 0.5).
There is currently no known polynomial time al-
gorithm for GAP-SMALL-SET EXPANSION(η) for any
η ∈(0, 0.5). The Small Set Expansion Hypothesis
conjectures that GAP-SMALL-SET EXPANSION(η) is
NP-hard for any η ∈(0, 0.5), and is currently an
open problem related to the Unique Games Conjecture
(Raghavendra and Steurer 2010).
2.3
A diminishing returns framework for
vaccine design provides a submodular
optimization objective
A key reason underlying the complexity of the max
n-times coverage problem is that the utility of a pep-
tide may be hidden until we are close to reaching n-
times coverage. This makes it difﬁcult select peptides
optimally before its utility becomes apparent. To ad-
dress this, we propose a diminishing returns framework,
where peptides will improve the objective at any cover-
age level. Intuitively, this provides a “gradient” along
which an optimization procedure can climb.
Formally, let U : R≥0 →R≥0 be some non-negative
monotonically increasing concave function such that
U(0) = 0. Let M denote the set of MHC genotypes
observed in the population. Let w : M →R≥0 be a
weight function that gives the frequency of each geno-
type in the population. Let P denote the set of candidate
peptides from which a subset is selected for the vaccine
design. If p ∈P and m ∈M, let display(p, m) de-
note the predicate of whether p is displayed in an in-
dividual with genotype m. To model uncertainty, we
let display(p, m) vary over the sample space of some
probability space, and we assume that the subset of the
probability space where display(p, m) evaluates to true
is always measurable. The objective, parametrized by
U, can then be written as follows:
FU (S) =
X
m∈M
w(m) E[U(
X
p∈S
1display(p,m))]
(1)
Where S ⊆P is the set of peptides selected for
vaccine inclusion. This objective is a monotonically in-
creasing submodular function.
Theorem 2. For any U : R≥0 →R≥0 that is monoton-
ically increasing and concave, FU is a monotonically
increasing submodular function.
As a consequence, we can attain a (1 −e−1)-factor
approximation using the greedy approach if no addi-
tional constraints are given aside from the cardinality of
the peptide set (Nemhauser, Wolsey, and Fisher 1978).
Beyond submodularity, this objective contributes the
following desirable properties: ﬁrst, it accounts for the
fact that having peptide-MHC hits is useful, even if the
redundancy does not obtain a given threshold. While
having high redundancy is better than having low re-
dundancy, having low redundancy is better than not dis-
playing any peptides. Second, the utility we expect from
attaining a given number of peptide-MHC hits is made
explicit through U. Third, it allows reasoning with un-
certainty by allowing display(p, m) to be an uncertain
event. Many prediction models output a soft classiﬁca-
tion instead of a hard one, which we can calibrate to
attach uncertainties to the classiﬁcations.
For an arbitrary distribution over the set of indica-
tor variables 1display(p,m) we may need to approximate
the expectation in FU via sampling. However, we can
compute the objective FU exactly and efﬁciently if we
suppose that for a given MHC genotype m, the set of
indicator variables 1display(p,m) are independent. This
is almost certainly false given a sufﬁciently large pool
of peptide sequences, since we should be able to sig-
niﬁcantly improve the performance of a predictor by
training it on a sufﬁciently large number of peptide se-
quences. However, we can weaken this assumption to
k-wise independence if we only consider vaccine de-
signs that include at most k peptides. For values of k
that are reasonable in the context of designing peptide
vaccines, this assumption is more reasonable than the
full independence assumption.
Under the independence assumption we can calculate
the objective by computing the distribution of the sum
via iterated convolutions of Bernoulli distributions, and
then taking the expectation using the distribution (see

Appendix C for additional details). This runs in time
O(|M||S|2), where |M| is the number of genotypes
and |S| is the number of peptides in the vaccine design.
2.4
Peptide selections need to be constrained
to avoid unreasonable designs
We impose two types of constraints on the set of pep-
tides selected for vaccine inclusion: a cardinality con-
straint, and a set of pairwise constraints.
The cardinality constraint is necessary since our ob-
jective function is monotonically increasing. Therefore,
the full set of candidate peptides P will maximize it.
This is undesirable, since peptide vaccines need to be
compact to permit effective delivery and to induce ef-
fective intolerance in the context of limited immune sys-
tem capacity. Therefore, we will impose a cardinality
constraint on the set of selected peptides such that it
cannot exceed a given size k.
The pairwise constraints are required to avoid very
similar peptides from being included. Peptide candi-
dates for vaccine inclusion are generated by sliding win-
dows of various sizes across the protein sequence we
wish to target. The produces peptides that are highly
similar in sequence, such as nested sequences, and in-
cluding highly related sequences does not truly improve
the effectiveness of the vaccine. Furthermore, the as-
sumption that the variables indicating peptide-MHC in-
teractions are independent likely does not hold when
peptides are very similar, since it is possible that the
predictor makes use of similar features, which result
in systematic errors. Therefore, we introduce a set of
pairwise constraints G as a graph where the vertex set
GV = P, and where edges exist between peptides that
are deemed redundant. We then require that the peptides
in the vaccine design form an independent set within G.
3
Methods
3.1
A greedy approach provides performance
guarantees under the diminishing returns
framework
Our goal is the following: given a peptide set P, a set
of MHC genotypes M, binding credences between all
peptides and MHCs, a monotonically increasing con-
cave utility function U : R≥0 →R≥0 with U(0) = 0,
a cardinality constraint k, and pairwise constraints G,
ﬁnd a set S ⊆P that satisﬁes all the constraints and
maximizes the objective function FU(S). We deﬁne the
binding credence between a peptide p and an MHC m as
the measure of the subset of the probability space where
display(p, m) evaluates to true. Practically, these val-
ues behave like probabilities. We use the term credence
to emphasize the epistemic nature of the uncertainty.
We present Optivax-P, a greedy approach outlined in
Algorithm 1, to produce a solution to this problem. The
procedure is straightforward: at each iteration we add
the peptide that maximally improves the solution to the
solution set, then eliminate that peptide and all similar
peptides from consideration for all future steps.
Algorithm 1: Optivax-P
Input: A ground set of candidate peptides P, a car-
dinality constraint k, a similarity graph (P, E), and
a monotone submodular function F : 2P →R≥0
where F(∅) = 0
Output: A set S ⊆P such that |S| ≤k
S ←∅
Q ←P
while (Q ̸= ∅) ∧(|S| < k) do
x ←arg maxx∈Q F(S ∪{x})
S ←S ∪x
N ←{y|{x, y} ∈E} ∪{x}
Q ←Q \ N
end while
return S
Runtime analysis of Optivax-P
The naive runtime is
O(k3|P||M|): the objective function is evaluated |P|
times to compute the arg max, the arg max is computed
at most k times, and each evaluation of the objective
function takes time O(k2|M|) since the designs will
never contain more than k elements.
We can improve the runtime by evaluating the
marginal improvement rather than the full objective,
bringing the overall runtime down to O(k2|P||M|) (see
Appendix C). We can further vectorize the computa-
tion to evaluate the arg max in O(1) vector operations,
reducing the runtime to O(k) vector operations and
O(|P|k) operations for constraint handling (see Ap-
pendix C). However, vector operations require batching
if |M| and |P| are large, so those parameters still play
a signiﬁcant role in the runtime.
Our implementation can generate designs of size
k ≈102 over a peptide set of size |P| ≈103 with
|M| ≈106 genotypes in approximately 5 minutes when
parallelized over 8 Titan RTX GPUs. See Appendix C
for additional details.
Approximation ratio of Optivax-P
Let S∗denote
the true optimum of the optimization problem. If we let
each peptide and MHC genotype interact with probabil-
ity 1 and let k be sufﬁciently large, then the desired opti-
mization is equivalent to ﬁnding the maximum indepen-
dent set within G. Finding any constant factor approx-
imation to max-clique is NP-hard (Zuckerman 2006),
which then immediately implies that S∗cannot be ap-
proximated to any constant factor. Therefore, the qual-
ity of the solution produced by Optivax-P cannot be un-
conditionally bounded by a constant factor with respect
to S∗, since Optivax-P runs in polynomial time.
However, we can bound the solution by looking at
the graph structure of G. Since we are considering cases
where similarity relations are mostly generated from
sliding windows over linear sequences, we might ex-
pect the resulting graph to be of low degree. Let ∆(G)
denote the degree of G. Note that in the special case
where ∆(G) = 0, there are no pairwise constraints, so
the problem reduces to the optimization of a monotonic

submodular function under a cardinality constraint. It is
well established that the greedy approach attains an ap-
proximation ratio of (1 −e−1) in this case (Nemhauser,
Wolsey, and Fisher 1978), and that attaining an approx-
imation ratio of (1 −e−1 + ϵ) for any ϵ > 0 is NP-hard
(Feige 1998).
Another property we can look at is the graph power of
G. We may expect that in the case where a graph looks
like a path, taking the graph power would not add too
many extra constraints, in which case replacing G with
its graph power Gp would not yield a optimum that is
too different. Let S∗
p denote the solutions to the more
constrained optimizations:
S∗
p =
arg max
S⊆P: |S|≤k
v1,v2∈S =⇒{v1,v2}/
∈Gp
E
FU (S)
(2)
We can then bound the output of Optivax-P by incor-
porating these extra graph parameters:
Theorem 3. Let ˆS be the output of Optivax-P. Then:
1. If ∆(G) = 0, then FU( ˆS) ≥FU(S∗)(1 −e−1)
2. If ∆(G) > 0, then FU( ˆS) ≥max( FU(S∗
2 )
2
, FU(S∗)
1+∆(G))
We can upper bound the best possible performance of
polynomial time algorithms.
Theorem 4. Unless P = NP, there exists no polynomial
time algorithm that can output an approximation ˆS that
guarantees either of the following on all inputs for any
ϵ > 0:
1. FU( ˆS) ≥FU(S∗
2)(1 −e−1 + ϵ)
2. FU( ˆS) ≥FU(S∗)(
1
1+∆(G))(1−ϵ)
3.2
Using machine learning based models to
attain binding credences
We deﬁne display(p, m) as a random event in a prob-
ability space of beliefs that peptide p is presented by
MHC genotype m. We use well established state-of-the-
art neural network based models (NetMHCpan4.1 and
NetMHCpanII4.0 (Reynisson et al. 2020)) to generate
predictions that we use to derive Pr(display(p, m)). We
will assume that the derived beliefs are independent (al-
though it is sufﬁcient to assume k-wise independence,
and only between events that share a genotype - see
Section 2.3). While this may not necessarily be true for
closely related sequences, we circumvent this by con-
straining our designs so that they do not contain closely
related sequences (see Section 2.4).
There are two classes of MHC molecules that we
need to design our vaccine to bind to. However, due to
molecular differences between the two molecules the
peptides they bind are largely disjoint. We can there-
fore simplify the problem to that of producing two sepa-
rate designs, one for Class I MHCs and one for Class II
MHCs. NetMHCpan4.1 provides predictions between
peptides and Class I MHCs while NetMHCIIpan4.0
provides predictions between peptides and Class II
MHCs. For simplicity, we will refer to these predictors
together as NetMHCpan.
Having ﬁxed our class of interest, we then deﬁne
an MHC genotype to be a set of 3-6 distinct alle-
les. NetMHCpan provides binding predictions between
peptides and individual alleles rather than genotypes, so
to attain credences for whether a peptide is displayed by
a genotype we assume independence between our be-
liefs that the peptides are displayed by individual alleles
and compute the credence as the following:
Pr(display(p, m)) = 1 −
Y
x∈m
(1 −cp,x)
(3)
Where cp,x is the credence for binding between a
peptide p and a speciﬁc allele x.
NetMHCpan outputs likelihoods for binding between
any given peptide p and any given MHC molecule x.
However, it is important to ensure that this likelihood
is well calibrated. By default, NetMHCpan calibrates
itself by comparing the scores it outputs against a reper-
toire of naturally occurring peptides and classifying a
sequence as being displayed if it scores higher than
99.5% of those peptides when characterizing binding to
Class I MHC and 98% of those peptides when classify-
ing binding to Class II MHC.
To attain well calibrated credences, we make use of
publicly available datasets that were used to validate
NetMHCpan, which contain no overlap with the dataset
used to train NetMHCpan (Reynisson et al. 2020). The
dataset consists of a set of epitopes, the MHC molecule
they bind to, and the natural context they occur in. The
epitopes were used as positive samples while the con-
text sequences were used to generate negative samples.
The samples were weighted such that the ratio of the
weight of all positive samples to that of all negative
samples is 1 : 199 for Class I MHC and 1 : 49 for
Class II MHC to match the fraction of natural peptides
that NetMHCpan implicitly assumes to be binders. The
samples were then all fed into NetMHCpan to produce
predictions. See Appendix B for additional details. The
samples were then binned into 20 equally sized bins and
the weighted fraction of positive samples within each
bin was calculated to produce a calibration curve, which
we present in Figure 1A. We then generate a calibration
function H by minimizing the following objective:
n−n′
X
i=1
 Pn′
j=1 wi+j(H(xi+j) −yi+j)
Pn′
j=1 wi+j
2
(4)
Where all samples are indexed by an integer between
1 and n, xi denotes the NetMHCpan predicted value
of the sample, yi is 1 if the sample is positive and 0 if
the sample is negative, and wi is the weight assigned
to the sample. The samples are ordered such that xi ≤
xi+1 for all 0 ≤i < n, so n′ can be interpreted as the
window size. We constrain H to be non-decreasing and
non-negative, so this is a form of isotonic regression.
Additional details can be found in Appendix B.
If NetMHCpan outputs y on an input peptide p and
MHC m, we set our credence that p binds to x as H(y).
A calibration curve of the calibrated predictions of the
validation dataset is shown in Figure 1B.

A)
B)
Figure 1: Calibration curves for Class I MHC with un-
calibrated (A) and calibrated (B) predictions. Matching
plots for Class II MHC can be found in Appendix B.
The curve is made of 20 equally spaced bins between 0
and 1. Populated bins and the fraction of positive sam-
ples they contain are indicated by a “+”, with the sur-
rounding column indicating the interquartile (IQR), in-
terventile (IVR) and full range of a set of 1000 boot-
strapped values.
4
Results
4.1
Greedy selection outperforms baseline
methods
Optivax-P has good worst case theoretical guarantees
which are even optimal in the absence of pairwise con-
straints unless P=NP. Here we empirically check its
performance against two baseline approaches in ran-
dom settings. The ﬁrst baseline is the random approach,
where peptides are chosen randomly. The second base-
line is via linear approximation, where the concave
function U in Equation 1 is removed to produce a sur-
rogate objective. This surrogate is linear, so it can be
trivially optimized to produce a solution.
We compare the algorithms by generating peptide
vaccine designs of 64 different sizes in 2000 randomly
generated settings, where each setting randomizes the
number of genotypes and peptides, the display cre-
dences, and the concave function U in the objective FU
(Equation 1). Details can be found in Appendix D. We
ﬁnd that Optivax-P outperforms the baselines in most
settings (Figure 2).
4.2
Designing a SARS-CoV2 vaccine with
Optivax-P
We apply Optivax-P in a practical setting by producing
vaccine designs for SARS-CoV2. To design our vac-
cine, we use a set of candidate peptides sourced from
Figure 2: For each design size between 1 and 64 in-
clusive, we compute the fraction of the 2000 settings
under which Optivax-P outperforms both baselines, and
test the hypothesis of whether Optivax-P outperforms
the best score obtained by the baselines via a one-sided
Wilcoxcon signed-rank test. The fraction and p-values
(corrected for multiple hypothesis by a factor of 64) are
then plotted as a function of the number of peptides se-
lected.
Liu et al. (2021) which includes peptides from SARS-
CoV2 that have been ﬁltered for undesirable properties
like high mutation rates, cleavage, and glycosylation.
Peptides that were present in the human proteome were
also removed, since they may trigger adverse autoim-
mune responses. Liu et al. (2021) have also published
a set of genotypes and their frequencies which we use.
These frequencies are derived from diverse populations
and have been selected to be representative of the global
population. We calculated binding credences for each
peptide-genotype pair as described in Section 3.2. Ad-
ditionally, if a peptide was not present in representative
genomes of the Omicron BA.1 and Omicron BA.2 vari-
ants of SARS-CoV2 (accession number OM873778 and
OW123901 respectively, both retrieved from the The
COVID-19 Data Portal (Harrison et al. 2021)) then we
set the credence of that peptide being displayed on any
MHC molecule to 0.
We applied Optivax-P to design vaccines with pep-
tide sets of size 1 and 150 inclusive. Designs were con-
strained such that no pair of peptides can be within 3 ed-
its (insertions, deletions, or substitutions) of each other
for the MHC Class I design, and 5 edits for the MHC
Class II design. Designs were optimized for the objec-
tive FUT for T between 1 and 20 inclusive, where UT
is deﬁned as:
UT (x) = min(x, T )
(5)
T can be viewed as a threshold parameter. This cor-
responds to a model where each peptide-MHC hit pro-
vides incremental protection until a person attains T
hits, at which point they are fully protected and stop see-
ing additional beneﬁts. A comparison between Optivax-
P designs and previous designs is shown in Figure 3,
where we can see all Optivax-P designs score substan-
tially higher on FU5. Evaluations on FUT for other T
show similar trends and are presented in Appendix D.
While this demonstrates that our optimization proce-
dure works and that there are deﬁciencies in previous
designs that are addressed through our designs if our
utility model is reﬂective of reality, it may not be en-
tirely surprising that vaccine designs optimized for FUT

A)
B)
Figure 3: For each vaccine design S we compute
FU5(S), divide it by 5, and plot it as a function of |S|.
Designs for both MHC Class I (A) and MHC Class II
(B) are given. For each design size we plot the entire
range of designs of that size generated using Optivax-
P optimized for FUT with 1 ≤T ≤20 (OP), and
the interquartile (IQR), interdecile (IDR), interventile
(IVR), and full range of 1000 designs of that size sam-
pled uniformly at random. We also plot the locations
of the ILP n=3 (ILP3), ILP n=5 (ILP5), and Marginal-
Greedy (MG) designs from Liu et al. (2021) as well
as 29 other designs (Other) (Abdelmageed et al. 2020,
Ahmed, Quadeer, and McKay 2020, Akhand et al. 2020,
Alam et al. 2020, Banerjee, Santra, and Maiti 2020,
Baruah and Bose 2020, Bhattacharya et al. 2020, Fast,
Altman, and Chen 2020, Gupta, Mishra, and Niraj 2020,
Herst et al. 2020, Lee and Koohy 2020, Mitra, Pandey,
and Swaroop, Poran et al. 2020, Ramaiah and Arumu-
gaswami 2021, Saha and Prasad 2020, Singh et al. 2020,
Srivastava et al. 2020, Tahir ul Qamar et al. 2020, Vashi,
Jagrit, and Kumar 2020).
score well on FUT , even for mismatching T. To control
for this, we also evaluate designs produced by Optivax-
P on the n-times coverage objective proposed by Liu
et al. (2021) and described in Section 2.2. We modify
our credences such that they are only 0 or 1, and such
that they closely match the values used by Liu et al.
(2021) (i.e. Pr(display(p, m)) = 1 if and only if the
genotype m is present within the peptide p, where pep-
tides are viewed as multisets of genotypes in the max
n-times coverage framework).
We then produced designs of size 19 using UT for all
T between 1 and 10 inclusive. These designs were then
assigned a score equal to their n-times coverage for n
between 1 and 20 inclusive. In Figure 4 we compare
these scores to the scores attained by designs generated
by Liu et al. (2021), which also each contain 19 pep-
tides. We see that Optivax-P is highly competitive even
when evaluated on a objective separate from the one it
was optimized for.
A)
B)
Figure 4: We compare designs generated by Optivax-
P (OP) to designs generated by the ILP and Marginal-
Greedy (MG) approaches from Liu et al. (2021) us-
ing the n-times coverage objective. A white square at
position (x, y) indicates that the design proposed by
Optivax-P optimized against FUy outperforms both the
ILP and MarginalGreedy design when evaluated with
x-times coverage. A black square indicates that the
Optivax-P design was outperformed by the ILP or MG
design, and a gray square indicates that the Optivax-P
design was outperformed by either the ILP or MG de-
sign. Comparisons for both MHC Class I (A) and MHC
Class II (B) are given.
5
Discussion
We have introduced the diminishing returns framework
and Optivax-P for designing epitope based peptide vac-
cines. The framework is based on constrained submod-
ular optimization, which permits Optivax-P to provide
performance guarantees despite the NP-hardness of the
problem, unlike previous approaches. We also show
how we can probabilistically interpret the outputs of
machine learning models to allow reasoning with uncer-
tainty within the framework. Finally, we demonstrated
that Optivax-P achieves superior performance against
past vaccine designs on the SARS-CoV-2 vaccine de-
sign task, and achieves comparable performance even
when evaluated against previous objectives.
Optivax-P is highly scalable, allowing us to optimize
over potentially millions of candidate peptides for a sin-
gle vaccine. The ability to reason with uncertainty also
gives us a much richer language for expressing the prop-
erties of a peptide: for instance, instead of ﬁltering out
peptides prone to mutation, we can consider the proba-
bility of sequence drift. These factors allow us to con-
sider a far wider range of peptide vaccine design tasks,
which we plan to use in the future.
Acknowledgements
This work was supported in part by Schmidt Futures
and a C3.ai grant. The authors would also like to thank

Ge Liu, Alexander Dimitrakakis, Brandon Carter, and
members of the Gifford lab for useful discussions and
feedback.
References
Abdelmageed, M.; Abdelmoneim, A.; Mustafa, M.;
Elfadol, N.; Murshed, N.; Shantier, S.; and Makhawi,
A. 2020. Design of multi epitope-based peptide vaccine
against E protein of human 2019-nCoV: An immunoin-
formatics approach. bioRxiv 2020. Preprint, 1–21.
Ahmed, S. F.; Quadeer, A. A.; and McKay, M. R. 2020.
Preliminary identiﬁcation of potential vaccine targets
for the COVID-19 coronavirus (SARS-CoV-2) based
on SARS-CoV immunological studies. Viruses, 12(3):
254.
Akhand, M. R. N.; Azim, K. F.; Hoque, S. F.; Moli,
M. A.; Joy, B. D.; Akter, H.; Aﬁf, I. K.; Ahmed, N.;
and Hasan, M. 2020. Genome based evolutionary study
of SARS-CoV-2 towards the prediction of epitope based
chimeric vaccine. BioRxiv.
Alam, A.; Khan, A.; Imam, N.; Siddiqui, M. F.;
Waseem, M.; Malik, M. Z.; and Ishrat, R. 2020. Design
of an epitope-based peptide vaccine against the severe
acute respiratory syndrome coronavirus-2 (SARS-CoV-
2): a vaccine-informatics approach. BioRxiv.
Banerjee, A.; Santra, D.; and Maiti, S. 2020. Energet-
ics based epitope screening in SARS CoV-2 (COVID
19) spike glycoprotein by Immuno-informatic analysis
aiming to a suitable vaccine development. bioRxiv.
Baruah, V.; and Bose, S. 2020.
Immunoinformatics-
aided identiﬁcation of T cell and B cell epitopes in the
surface glycoprotein of 2019-nCoV. Journal of medical
virology, 92(5): 495–500.
Bhattacharya, M.; Sharma, A. R.; Patra, P.; Ghosh, P.;
Sharma, G.; Patra, B. C.; Lee, S.-S.; and Chakraborty,
C. 2020. Development of epitope-based peptide vac-
cine against novel coronavirus 2019 (SARS-COV-2):
Immunoinformatics approach. Journal of medical vi-
rology, 92(6): 618–631.
Ching, T.; Himmelstein, D. S.; Beaulieu-Jones, B. K.;
Kalinin, A. A.; Do, B. T.; Way, G. P.; Ferrero, E.;
Agapow, P.-M.; Zietz, M.; Hoffman, M. M.; et al. 2018.
Opportunities and obstacles for deep learning in biology
and medicine. Journal of The Royal Society Interface,
15(141): 20170387.
Fast, E.; Altman, R. B.; and Chen, B. 2020. Potential
T-cell and B-cell epitopes of 2019-nCoV. BioRxiv.
Feige, U. 1998. A threshold of ln n for approximating
set cover. Journal of the ACM (JACM), 45(4): 634–652.
Gupta, E.; Mishra, R. K.; and Niraj, R. R. K. 2020. Iden-
tiﬁcation of potential vaccine candidates against SARS-
CoV-2, A step forward to ﬁght COVID-19: A Reverse
Vaccinology Approach. bioRxiv.
Harrison, P. W.; Lopez, R.; Rahman, N.; Allen, S. G.;
Aslam, R.; Buso, N.; Cummins, C.; Fathy, Y.; Felix,
E.; Glont, M.; et al. 2021. The COVID-19 Data Por-
tal: accelerating SARS-CoV-2 and COVID-19 research
through rapid open access data sharing. Nucleic acids
research, 49(W1): W619–W623.
Herst, C. V.; Burkholz, S.; Sidney, J.; Sette, A.; Har-
ris, P. E.; Massey, S.; Brasel, T.; Cunha-Neto, E.; Rosa,
D. S.; Chao, W. C. H.; et al. 2020. An effective CTL
peptide vaccine for Ebola Zaire Based on Survivors’
CD8+ targeting of a particular nucleocapsid protein epi-
tope with potential implications for COVID-19 vaccine
design. Vaccine, 38(28): 4464–4475.
Lee, C. H.; and Koohy, H. 2020. In silico identiﬁcation
of vaccine targets for 2019-nCoV. F1000Research, 9.
Li, W.; Joshi, M. D.; Singhania, S.; Ramsey, K. H.; and
Murthy, A. K. 2014. Peptide vaccine: progress and chal-
lenges. Vaccines, 2(3): 515–536.
Liu, G.; Dimitrakakis, A.; Carter, B.; and Gifford, D.
2021. Maximum n-times Coverage for Vaccine Design.
In International Conference on Learning Representa-
tions.
Malonis, R. J.; Lai, J. R.; and Vergnolle, O. 2019.
Peptide-based vaccines: current progress and future
challenges. Chemical reviews, 120(6): 3210–3229.
Mitra, D.; Pandey, J.; and Swaroop, S. ????
Multi-
epitope-based peptide vaccine design against SARS-
CoV-2 using its spike protein, BioRxiv.(2020) 2020.04.
23.055467.
Moise, L.; Gutierrez, A.; Kibria, F.; Martin, R.; Tas-
sone, R.; Liu, R.; Terry, F.; Martin, B.; and De Groot,
A. S. 2015. iVAX: An integrated toolkit for the selection
and optimization of antigens and the design of epitope-
driven vaccines. Human vaccines & immunotherapeu-
tics, 11(9): 2312–2321.
Nemhauser, G. L.; Wolsey, L. A.; and Fisher, M. L.
1978. An analysis of approximations for maximizing
submodular set functions—I. Mathematical program-
ming, 14(1): 265–294.
Oyarzun, P.; and Kobe, B. 2015. Computer-aided de-
sign of T-cell epitope-based vaccines: addressing popu-
lation coverage. International journal of immunogenet-
ics, 42(5): 313–321.
Poran, A.; Harjanto, D.; Malloy, M.; Rooney, M. S.;
Srinivasan, L.; and Gaynor, R. B. 2020.
Sequence-
based prediction of vaccine targets for inducing T cell
responses to SARS-CoV-2 utilizing the bioinformatics
predictor RECON. bioRxiv.
Raghavendra, P.; and Steurer, D. 2010. Graph expan-
sion and the unique games conjecture. In Proceedings
of the forty-second ACM symposium on Theory of com-
puting, 755–764.
Ramaiah, A.; and Arumugaswami, V. 2021.
Insights
into cross-species evolution of novel human coron-
avirus SARS-CoV-2 and deﬁning immune determinants
for vaccine development. BioRxiv, 2020–01.
Reynisson, B.; Alvarez, B.; Paul, S.; Peters, B.; and
Nielsen, M. 2020. NetMHCpan-4.1 and NetMHCIIpan-
4.0: improved predictions of MHC antigen presentation
by concurrent motif deconvolution and integration of

MS MHC eluted ligand data. Nucleic acids research,
48(W1): W449–W454.
Saha, R.; and Prasad, B. V. 2020. In silico approach
for designing of a multi-epitope based vaccine against
novel Coronavirus (SARS-COV-2). BioRxiv.
Singh, A.; Thakur, M.; Sharma, L. K.; and Chandra, K.
2020. Designing a multi-epitope peptide based vaccine
against SARS-CoV-2. Scientiﬁc reports, 10(1): 1–12.
Sohail, M. S.; Ahmed, S. F.; Quadeer, A. A.; and
McKay, M. R. 2021. In silico T cell epitope identiﬁca-
tion for SARS-CoV-2: Progress and perspectives. Ad-
vanced drug delivery reviews, 171: 29–47.
Srivastava, S.; Verma, S.; Kamthania, M.; Kaur, R.;
Badyal, R. K.; Saxena, A. K.; Shin, H.-J.; Kolbe,
M.; and Pandey, K. C. 2020.
Structural basis to de-
sign multi-epitope vaccines against Novel Coronavirus
19 (COVID19) infection, the ongoing pandemic emer-
gency: an in silico approach. bioRxiv.
Tahir ul Qamar, M.; Rehman, A.; Tusleem, K.; Ashfaq,
U. A.; Qasim, M.; Zhu, X.; Fatima, I.; Shahid, F.; and
Chen, L.-L. 2020. Designing of a next generation mul-
tiepitope based vaccine (MEV) against SARS-COV-2:
Immunoinformatics and in silico approaches. PloS one,
15(12): e0244176.
Vashi, Y.; Jagrit, V.; and Kumar, S. 2020. Understanding
the B and T cell epitopes of spike protein of severe acute
respiratory syndrome coronavirus-2: A computational
way to predict the immunogens. Infection, Genetics and
Evolution, 84: 104382.
Zaitouna, A. J.; Kaur, A.; and Raghavan, M. 2020. Vari-
ations in MHC class I antigen presentation and im-
munopeptidome selection pathways. F1000Research,
9.
Zuckerman, D. 2006. Linear degree extractors and the
inapproximability of max clique and chromatic number.
In Proceedings of the thirty-eighth annual ACM sympo-
sium on Theory of computing, 681–690.

A
Proofs
A.1
Proof of Theorem 1
Proof sketch. We can encode a graph into the n-times coverage problem. To do this, we let each peptide represent a
vertex and we let each genotype represent an edge. A genotype displays a peptide (i.e. a peptide contains a genotype
under the multiset formulation) if and only if the edge it represents is incident to the peptide. If we require 2-times
coverage, then an edge is “covered” only if both vertices at its endpoints are included in the selected set.
Therefore, selecting a set of peptides that cover a lot of genotypes is equivalent to ﬁnding a set of vertices that have
a lot of edges between them. If the graph is regular, this is equivalent to ﬁnding a non-expanding set. This then allows
us to reduce from GAP-SMALL-SET EXPANSION.
For reference, we state the deﬁnition of GAP-SMALL-SET EXPANSION(η) adapted from (Raghavendra and Steurer
2010):
Deﬁnition 2. Given a d-regular graph G = (V, E) and some integer k, determine which of the following is the case:
1. There exists S ⊆V with |S| = k such that the number of edges leaving S is less than dkη.
2. For all S ⊆V where |S| = k, the number of edges leaving S is more than dk(1 −η).
This is a promise problem: if neither is true then we are free to output whatever we want.
Suppose that there exists a polynomial time algorithm that approximates n-times coverage to an approximation ratio
of ϵ > 0 (i.e. if OPT is the value of the true solution, the solution returned by the algorithm attains value ϵOPT).
Then there exists an η ∈(0, 0.5) such that we can solve GAP-SMALL-SET EXPANSION(η): given an input d-
regular graph, let each vertex represent a peptide, and let each edge represent a genotype. A peptide is displayed by a
genotype if and only if the vertex represented by that peptide is incident to the edge represented by that genotype. We
then compute an approximation for max 2-times coverage using our algorithm with cardinality constraint k.
Let ˆS be the value of the solution returned by the algorithm, and let S∗be the value of the optimal solution. Let ˆE
be the number of genotypes covered by ˆS and let E∗be the number of genotypes covered by S∗.
Let f(x) = dk−2x. Since each vertex has degree k, and ˆE and E∗are the number of edges that have both endpoints
in ˆS and S∗respectively, f( ˆE) and f(E∗) are the number of edges that leave ˆS and S∗respectively.
Let p be some sufﬁciently large value that is greater than 0 such that ϵ(1 −ϵp) > ϵp and such that ϵp < 0.5. Output
case 1 if f( ˆE) < dk(1 −ϵp), and output case 2 otherwise.
This
procedure
completes
in
polynomial
time,
and
we
claim
that
this
correctly
solves
GAP-SMALL-SET EXPANSION(ϵp). To verify this, suppose that we are in case 1. We then have:
f(E∗) < ϵp
(6)
dk(1 −ϵp) < 2E∗
(7)
Since ˆS attains an approximation ratio of ϵ, we have:
f( ˆE) ≤f(ϵE∗)
(8)
< f(ϵ(dk(1 −ϵp))
(9)
= dk(1 −ϵ(1 −ϵp))
(10)
< dk(1 −ϵp)
(11)
The last line follows since we deﬁned p to be large enough for that to hold. Since f( ˆE) < dk(1 −ϵp), the algorithm
indeed outputs case 1.
Suppose instead that we are in case 2. But then f( ˆE) > dk(1 −ϵp) because all sets of size k have more than
dk(1 −ϵp) edges leaving it. Therefore, the algorithm correctly outputs case 2.
Therefore, this procedure decides GAP-SMALL-SET EXPANSION(ϵp) in polynomial time.
A.2
Proof of Theorem 2
Proof sketch. Since U is concave, the marginal utility of each peptide diminishes as number of bound peptides increase
when looking at a speciﬁc genotype, given a particular realization of which peptides are displayed and which ones do
not. The objective function from Equation 1 can be viewed as a weighted average of the marginal utilities that has been
averaged over each genotype and each possible realization of which peptides bind and which ones do not. Since the
marginal utilities are individually diminishing, a convex combination of those utilities must also be diminishing.

Let S ⊆T ⊊P, and let e ∈U\T. Let S′ = S∪{e} and let T ′ = T ∪{e}. It sufﬁces to show that FU(S′)−FU(S) ≥
FU(T ′) −FU(T). We have the following:
FU(S′) −FU(S) =
X
m∈M
w(m) E[U(
X
p∈S′
1display(p,m)) −U(
X
p∈S
1display(p,m))]
(12)
=
X
m∈M
w(m)
X
u∈U
Pr(u)
 U(H(S′, u)) −U(H(S, u))

(13)
Where U denotes the set of all possible outcomes (i.e. all possible truth assignments to the predicates display(p, m)
for all p ∈P and m ∈M), and H(S, u) denotes the number of hits found in set S under outcome u. Pr(u) denotes
the probability assigned to outcome u.
Since S ⊆T, it must be the case that H(S, u) ≤H(T, u) for any outcome u ∈U. Since e is either a hit or not a hit
under outcome u, H(S′, u) −H(S, u) = H(T ′, u) −H(T, u) = H({e}, u) for any outcome u ∈U.
When these two conditions are paired with the observation that U is concave, we have:
FU(S′) −FU(S) =
X
m∈M
w(m)
X
u∈U
Pr(u)
 U(H(S′, u)) −U(H(S, u))

(14)
≥
X
m∈M
w(m)
X
u∈U
Pr(u)
 U(H(T ′, u)) −U(H(T, u))

(15)
= FU(T ′) −FU(T)
(16)
Which then implies that FU is submodular.
A.3
Proof of Theorem 3
Proof sketch. Suppose we have our greedy solution, and suppose we then ask an oracle for what the true solution is.
If we take the union of these two solutions then by monotonicity of the objective this combined set scores at least as
well as the true optimum.
We now note that the reason the greedy procedure did not pick the members of the true solution was because
they either add less marginal gain than any of the elements that were picked, or because they were removed from
consideration at some point by the choice of some element in the greedy solution. We then note that each element can
only block a limited number of other elements, and if the greedy algorithm chose that element over the elements it
blocked then it must have had greater marginal utility. This then allows us bound the amount by which the true solution
can augment the greedy solution, which in turn bounds the approximation ratio of the greedy solution.
If ∆(G) = 0, then there are not constrains, and it is well established that the greedy approach indeed attains an
approximation ratio of (1 −e−1)(Nemhauser, Wolsey, and Fisher 1978).
Suppose otherwise. Let e1, e2, ..., ea be the elements chosen by Algorithm 1 in that order. Let o1, o2, ..., ob be the
elements of S∗
2 \ ˆS. Pair an ei an oj if ei shares an edge with oj. If a single oj shares edges with multiple ei, choose
the pair randomly. A single ei cannot share edges with more than one oi, since otherwise that would imply that there
exists a path of length two between those two oi that passes through the ei.
Suppose some oj are left over. We then pair them up randomly with the remaining ei. If there are unpaired elements,
it must be the ei, since otherwise the unpaired oj would have been added to the greedy solution.
Now consider the trajectory of adding elements to a solution in the order e1, e2, ..., ea, o1, o2, ..., ob. By monotonic-
ity, this must attain a value at least as great as S∗
2.
Suppose ei is paired with oj. Then the marginal improvement of taking ei must have been better than the marginal
improvement of taking oj, since otherwise oj would have been chosen instead of ei. Therefore, the score attained by
e1, e2, ..., ea, o1, o2, ..., ob cannot be more than 2 times larger than the score attained by e1, e2, ..., ea. But since the
value attained by S∗
2 can be no greater than e1, e2, ..., ea, o1, o2, ..., ob, it must be the case that the value attained by S∗
2
is no more than 2 times larger that the value attained by the greedy solution. This establishes the following:
FU( ˆS) ≥FU(S∗
2)
2
(17)
Similarly, let q1, q2, ...qb be the elements of S∗\ ˆS. We similarly associate ei with qj if they share an edge, and if a
qj shares edges with multiple ei the association is chosen arbitrarily. Note that no ei can by associated with more than
∆(G) qj.
We associate the remaining qj with pi such that no pi is associated with more than ∆(G) qj. If there are leftovers
they must belong to ˆS because otherwise they would have been included in the greedy solution.

Now consider the trajectory of adding elements to a solution in the order e1, e2, ..., ea, q1, q2, ..., qb. By monotonic-
ity, this must attain a value at least as great as S∗.
Suppose ei is associated with qj. Then the marginal improvement of taking ei must have been better than the
marginal improvement of taking qj, since otherwise qj would have been chosen instead of ei. Since each ei can be
associated with up to ∆(G) qi, the score attained by e1, e2, ..., ea, q1, q2, ..., qb can be no larger than ∆(G) + 1 times
the value attained by ˆS. But then that means S∗does not attain a value that is more than ∆(G) + 1 times the value of
the greedy solution. This establishes the following:
FU( ˆS) ≥FU(S∗)
1 + ∆(G)
(18)
Combining the two inequalities then yields the desired statement:
FU( ˆS) ≥max(FU(S∗
2)
2
, FU(S∗)
1 + ∆(G))
(19)
A.4
Proof of Theorem 4
Proof sketch. The ﬁrst guarantee cannot be met because Feige (1998) showed that a special case of our optimization
(max k-cover) cannot be approximated to within the given factor.
The ﬁrst guarantee cannot be met because Zuckerman (2006) showed that a special case of our optimization (max
clique) cannot be approximated to within the given factor.
We restate the two approximation guarantees that cannot be given if P ̸= NP:
1. FU( ˆS) ≥FU(S∗
2)(1 −1
e + ϵ)
2. FU( ˆS) ≥( FU(S∗)
1+∆(G))(1−ϵ)
To establish the ﬁrst inapproximability result, we can encode an instance of max k-cover in our optimization prob-
lem: let each genotype represent a member of the ground set and let each peptide represent an element of the set
system. We let the genotype display a peptide with probability 1 if the element represented by the peptide is con-
tained in the set represented by the genotype, and with probability 0 otherwise. Deﬁne the concave utility function
as U(x) = min(x, 1), and let G be a set of unconnected vertices, so FU(S∗) = FU(S∗
2). If each genotype is given
weight 1, then FU(S) gives the number of elements covered by S. The ﬁrst inapproximability result then follows from
the inapproximability of max k-cover to a ratio of (1 −1
e + ϵ) for any ϵ > 0 (Feige 1998).
To establish the second inapproximability result, we can encode an instance of independent set in our optimization
problem: let each peptide represent a vertex, and for each peptide introduce a genotype that displays that peptide
with probability 1 and displays all other peptides with probability 0. Deﬁne the concave utility function as U(x) =
min(x, 1). If each genotype is given weight 1, then FU(S) gives the number of elements contained in S. If we set G
to be the instance of indepenent set we wish to encode, then FU(S∗) is the size of the largest independent set. The
second inapproximability result then follows from the fact that independent set cannot be approximated to a ratio of
|GV |1−ϵ for any ϵ > 0 (Zuckerman 2006), and from the fact that 1 + ∆(G) ≤|GV |.

A)
B)
Figure 5: Calibration curves for Class II MHC with uncalibrated (A) and calibrated (B) predictions. Populated bins
and the fraction of positive samples they contain are indicated by a “+”, with the surrounding column indicating the
interquartile (IQR), interventile (IVR) and full range of a set of 1000 bootstrapped values.
B
Calibration
B.1
Data processing
Epitope data that were used to evaluate the performance of NetMHCpan4.1 and NetMHCIIpan4.0 was acquired from
servers linked to by Reynisson et al. (2020). The dataset consists of a set of triplets containing the epitope sequence,
context sequence, and the HLA that the epitope binds to. The dataset has been ﬁltered so that it contains no overlap
with the training set of NetMHCpan4.1 and NetMHCIIpan4.0 (Reynisson et al. 2020).
We ﬁrst completely remove the epitope from the context sequence, potentially chopping the context into multiple
chunks. We then slide a window with the same length as that of the epitope into the context chunks, producing multiple
peptides that match the length of the epitope. The epitope is then assigned a weight of 1, while the remaining peptides
are assigned weights such that the sum of those weights is 199 for Class I and 49 for Class II. This is to reﬂect the
rule-of-thumb that within a natural distribution of peptides, the top scoring 0.5% (for Class I) and 2% (for Class II)
of peptides are strong binders, which is the default rule used by NetMHCpan4.1 and NetMHCIIpan4.0 to classify
peptides.
Each sequence was then fed to NetMHCpan4.1 or NetMHCIIpan4.0 for to produce binding likelihoods to their
associated HLA. The epitope is given a ground truth value of 1 and the peptides derived from the contexts are given
a ground truth value of 0. This potentially underestimates the number of binders, since it is possible that peptides in
the context sequences also bind. However, our credences maintain soundness: it should not be the case that a vaccine
design that is unlikely to work will appear to be effective with high probability under these credences.
Our processing transforms the Class I MHC dataset of 1660 (epitope, HLA, context) triplets into 1645988 (predic-
tion, ground truth, weight) triplets, and the Class II MHC dataset of 917 (epitope, HLA, context) triplets into 1201559
(prediction, ground truth, weight) triplets.
B.2
Calculating calibration curves
Given a set of (prediction, ground truth, weight) triplets, we compute the calibration curve by binning the triplets by
their prediction values. We use 20 bins spaced equally between 0 and 1. For each bin that is populated, we calculate
the weighted average of its ground truth values:
P
i wi ∗yi
P
i wi
(20)
Where i indexes the peptides within a bin and wi and yi denote the weight and ground truth value of peptide i
respectively. The weighted average of a bin is a statistic computed from a set of triplets, so we quantify the uncertainty
of that statistic using 1000 bootstrapped samples of the triplets of that bin. Figure 1 gives calibration curves for Class
I MHC, while matching curves for Class II MHC are provided in Figure 5.
B.3
Generating the calibration function
We use a variant of isotone regression to generate a calibration function H as described in Section 3.2. Given a list of
n triplets (xi, yi, wi), where xi is raw predicted value of peptide i, yi is the ground truth value of peptide i, and wi is
the weight assigned to peptide i, ordered such that for all 1 ≤i < n we have xi ≤xi+1, we generate H by minimizing
the following function, subject to the constraint that a ≤b =⇒H(a) ≤H(b) and ∀a H(a) ≥0.

n−n′
X
i=1
 Pn′
j=1 wi+j(H(xi+j) −yi+j)
Pn′
j=1 wi+j
2
(21)
Implementation-wise, what we do is to slide a window of size n′ across a list of triplets sorted by prediction outputs
to produce a pair of weighted averages of calibrated predictions and weighted averages of ground truth values. For
our use case we take n′ to be 1000. We then calculate the squared error and perform projected gradient descent with
respect to the squared error over the calibrated weighted predictions. Projection is used to maintain the monotonicity
of the calibrated predictions.
This optimization deﬁnes H over the ﬁnite domain of raw predicted values. Let X be the set of all raw predicted
values. We use the following criterion to extend these predictions to R.
H(x) = max

{H(x)|x′ ≤x, x′ ∈X} ∪{0}

(22)
While the objective is strictly convex with respect to the averaged values, there are potentially multiple sets of
values that produce the same set of averaged values, leading to potentially multiple solutions that optimize Equation
21. We therefore ﬁx the ﬁrst n′ −1 calibrated predictions to be 0, which is reasonable since it turns out that the ﬁrst
999 ground truth values are also 0. Having ﬁxed these values, there is now a bijective linear function between the
remaining n −n + 1′ calibrated prediction values and the set of n −n + 1′ averaged calibration values. Therefore, the
objective is also strictly convex with respect to the unaveraged calibrated prediction values.

C
Implementation details
C.1
Computing FU
To compute FU(S) in time O(|M||S|2), it sufﬁces to calculate E[U(P
p∈S 1display(p,m)) in time O(|S|2) for each
m ∈M since we can then add up all the values.
To calculate E[U(P
p∈S 1display(p,m)) in time O(|S|2), we use iterated convolutions. We store a zero indexed list
D of size |S| + 1 initialized such that Di = 0 except for i = 0, where we have D0 = 1. Then for each p ∈S,
we loop in reverse order from i = |S| to i = 0 and update the list by setting Di to (1 −x)Di + (x)Di−1, where
x is the credence that p is displayed by m. D0 is set to (x)D0. The result is a convolution of a distribution with
probability mass function D a Bernoulli random variable whose chance of success is x. In other words, after each
iteration of the loop the value of Di represents the probability of attaining i hits from a vaccine given the peptides that
have already been looped over. Performing this loop for all members of S then gives the probability distribution for
P
p∈S 1display(p,m) if all random variables in the sum are independent. We can then take the expectation by using the
identity E[f(Y )] = P
y f(y)Pr(Y = y). Each loop runs in time O(|S|), O(|S|) loops need to be run, so computing
the distribution takes time O(|S|2) overall. If the utility function is provided in some data structure that allows random
access (e.g. an array), then the expectation can be computed in time O(|S|). Thus, E[U(P
p∈S 1display(p,m)) can be
calculated in time O(|S|2), which gives an overall runtime of O(|M||S|2) for calculating FU(S).
C.2
Computing the marginal improvement
Let S be ﬁxed, and suppose S′ = S ∪{e} for some e ∈P. Then we can calculate FU(S′) −FU(S) in time
O(|M||S|) instead if we store the distribution of P
p∈S 1display(p,m) for each m ∈M. This is because we only
need to convolve a single Bernoulli random variable over the distribution of P
p∈S 1display(p,m) to get the distribution
of P
p∈S′ 1display(p,m). This then allows us to calculate the expectation in time O(|S|), which then gives an overall
runtime of O(|M||S|) for calculating the marginal improvement.
At the end of each greedy step, we can update the distributions of P
p∈S 1display(p,m) to P
p∈S′ 1display(p,m) for
all m ∈M in time O(|M||S|) by performing a single convolution between the distribution and a Bernoulli random
variable.
C.3
Vectorization
The calculation of the marginal differences can be vectorized: let D′ be the probability mass function of
P
p∈S′ 1display(p,m) and let D be the probability mass function of P
p∈S 1display(p,m). Let x be the credence that
the element in S′ \ S is displayed on m. Let D and D′ be represented by vectors where Di is the probability that the
random variable distributed with probability mass function D takes on value i, and likewise for D′. Let U be a vector
representing the utility function, where Ui = U(i). Then the expected value of U(Y ) is U · D if Y is distributed with
probability mass function D (likewise for D′).
If Z is a vector, let Sh(Z) denote a shift operation where Sh(Z)i = Zi−1 and Sh(Z)0 = 0. Let Sh−1(Z) be the
reverse operation where Sh(Z)i = Zi+1 and Sh(Z)n = 0 if n is the size of Z. If we ensure that the entry at the last
index of D is 0 such that Z · D = Sh(Z) · Sh(D) and Sh−1(Sh(D)) = D, then the marginal difference is:
E[U(
X
p∈S′
1display(p,m))] −E[U(
X
p∈S
1display(p,m))] = U · D′ −U · D
(23)
This can be rearranged as the following:
U · D′ −Sh(U) · Sh(D) = U · ((x)Sh(D) + (1 −x)D) −Sh(U) · Sh(D)
(24)
= U · (x)Sh(D) −(x)Sh(U) · Sh(D)
(25)
= (x)(U −Sh(U)) · (sh(D))
(26)
= (x)(Sh−1(U) −U) · D
(27)
Therefore, if we precompute and vectorize (Sh−1(U) −U), the marginal difference is simply a scaled dot product.
This is a vector operation. We can then further tensor over M and P to parallelize most of the operations.
C.4
Details on hardware, software, and runtime
Our experiments were all run on Titan RTX GPUs, each with 24190MiB of memory. Our algorithms were all im-
plemented in Python 3.7.3 and make use of PyTorch 1.7.1 and Numpy 1.18.5, and were all run on Ubuntu 18.04.3
LTS.

We benchmarked the runtime of Algorithm 1 by generating vaccine designs of size 20 using synthetic datasets
where binding credences are drawn uniformly and independently between 0 and 1, with |M| = 106 and varying sizes
of |P|. 10 runs were excecuted for each |P|. We ran the benchmarks both parallelized over 8 GPUs. We also ran
the benchmarks using a single GPU to check how much parallelization over multiple GPUs helps. The runtimes we
recorded are given in Figure 6A and 6B.
Furthermore, we ﬁxed |P| to 103, and generated vaccine designs of size between 10 and 100 inclusive. The runtimes
are given in Figure 6C.

(a) Overall runtimes of Optivax-P on one Titan RTX GPU are provided in strip plots on the left panel. Each box is generated
from 10 executions. Overall runtimes for each greedy iteration on one Titan RTX GPU are provided on the right panel, where
is box is generated from 200 runtimes (20 iterations for 10 runs). The y-axis is presented on a log scale. Some instability
in the runtime arises when running on small numbers of peptides because startup and preprocessing times are signiﬁcant at
those timescales.
(b) Overall runtimes of Optivax-P on 8 Titan RTX GPUs are provided in strip plots on the left panel. Each box is generated
from 10 executions. Overall runtimes for each greedy iteration on 8 Titan RTX GPUs are provided on the right panel, where
is box is generated from 200 runtimes (20 iterations for 10 runs). The y-axis is presented on a log scale.
(c) Average runtimes over 10 executions of Optivax-P on 8 Titan RTX GPUs are plotted in the left panel, parameterized by
the size of the vaccine design. The range of runtimes are also given. Average runtimes for each greedy iteration on 8 Titan
RTX GPUs are provided on the right panel, along with the observed ranges.
Figure 6: Runtime benchmarks

A)
B)
Figure 7: We compare baseline designs against designs generated by Algorithm 1 on 2000 randomly generated settings.
We compute the amount by which Algorithm 1 outperforms a baseline via percent outperformance, where we subtract
the score attained by Algorithm 1 by the score attained by the baseline, and then divide by the score attained by
Algorithm 1. We then plot for each design size the interquartile (IQR), interdecile (IDR), interventile (IVR), and full
range of the distribution of percent outperformances, as well as the mean and median of the distribution. The scores
are plotted on a quartic root scale (i.e. the y position of a point with a y value of y′ is |y′|1/4 ∗sgn(y′), where sgn
denotes the sign function). We compare the outputs of Algorithm 1 against the linear approximation baseline in (A),
and against the random baseline in (B).
D
Benchmarking details
D.1
Generating random settings for optimization
We generate 2000 settings in which to benchmark our algorithms against baselines. The number of peptides, the
number of genotypes, the genotype weights, the credences assigned to whether a given genotype displays a given
peptide, and the optimization objective FU were all randomized independently and were drawn in the following way:
1. The number of peptides |P| and number of genotypes |M| were drawn uniformly from integers between 512 and
2048 inclusive.
2. All genotype weights were drawn independently and identically from the exponential distribution and then nor-
malized so that they sum to 1. Note that the scale parameter of the distribution is irrelevant since the values are
normalized.
3. A value α is set to be 0.005 ∗100X, where X is drawn from the uniform distribution supported between 0 and 1.
4. For each p ∈P and m ∈M, Pr(display(p, m)) is assigned Xα
p,m, where the values for Xp,m are drawn indepen-
dently and identically from the uniform distribution supported between 0 and 1.
5. The function U parametrizing FU was set to be the following for all integer values:
U(x) =
x
X
i=1
10
X
j=i
Zj
(28)
Where for 1 ≤j ≤10, the Zj are drawn independently and uniformly from the lognormal distribution with
location parameter 0 and scale paramter 2. For simplicity we deﬁne Pb
i=a t = 0 if a > b regardless of t. This
ensures that U has decreasing second difference and a non-negative ﬁrst difference, which in turn ensures that U is
monotonically increasing and concave (i.e. has monotonically decreasing ﬁrst differences).
For each setting, designs of size 1-64 inclusive were generated using Algorithm 1. Baseline designs of size 1-64
inclusive were chosen by greedily selecting peptides that were displayed on the most (weighted) genotypes with-
out regards to potentially diminishing returns (linear approximation). A second set of baseline designs were chosen
by sampling uniformly at random without replacement to produce a trajectory of 64 designs of size 1-64 inclusive
(random). We show in the main body of this work that Algorithm 1 outperforms both approaches (see Figure 2).
We also calculated the amount by which Algorithm 1 outperforms the baseline, which we present in Figure 7.
The linear approximation baseline is much more competitive than the random baseline, although Algorithm 1 still
outperforms it by more than 10% in some settings.

A)
E)
B)
F)
C)
G)
D)
H)
Figure 8: For each vaccine design S we compute FUT (S), divide it by T, and plot it as a function of |S|. Designs
for both MHC Class I (A-D) and MHC Class II (E-H) are given. For each size we plot the entire range of designs
of that size generated using the diminishing returns framework optimized for FUX with 1 ≤X ≤20 (DR(range)),
and the interquartile (IQR), interdecile (IDR), interventile (IVR), and full range of 1000 designs of that size sampled
uniformly at random. We also plot the locations of the designs generated by optimizing for FUT speciﬁcally (DRT),
the locations of the ILP n=3 (ILP3), ILP n=5 (ILP5), and MarginalGreedy (MG) designs from Liu et al. (2021) as
well as 29 other designs (Other) (Abdelmageed et al. 2020, Ahmed, Quadeer, and McKay 2020, Akhand et al. 2020,
Alam et al. 2020, Banerjee, Santra, and Maiti 2020, Baruah and Bose 2020, Bhattacharya et al. 2020, Fast, Altman,
and Chen 2020, Gupta, Mishra, and Niraj 2020, Herst et al. 2020, Lee and Koohy 2020, Mitra, Pandey, and Swaroop,
Poran et al. 2020, Ramaiah and Arumugaswami 2021, Saha and Prasad 2020, Singh et al. 2020, Srivastava et al. 2020,
Tahir ul Qamar et al. 2020, Vashi, Jagrit, and Kumar 2020). Designs were evaluated using FU1 (A,E), FU3 (B,F), FU8
(C,G), and FU20 (D, H).

D.2
Analysis of diminishing returns designs on additional utility scores
Figure 3 compares designs generated via the diminishing returns framework against previous designs using FU5.
Additional comparisons using FU1, FU3, FU8, and FU20 are provided in Figure 8. We similarly observe that the
diminishing returns based designs achieve the best performance.
We also provide the FU5 scores for the benchmark designs in Table 1, with comparisons against diminishing returns
designs of matching size.
D.3
Comparison of designs using n-times coverage
We compare the performance of vaccines with 19 peptides designed from the diminishing returns framework against
vaccines with 19 peptides from Liu et al. (2021) in Figure 4. We additionally compare the performance of designs
of varying sizes in Figure 9. The credences used in the objective for optimizing the diminishing returns designs were
binarized to closely match the binding data used by Liu et al. (2021), while the n-times coverage evaluation was
reproduced from Liu et al. (2021).
Similarly to our analysis from Figure 4, we ﬁnd that diminishing returns designs are highly competitive even when
evaluated on the n-times coverage objective. We ﬁnd that this is especially the case for designs for Class II MHCs,
where prior approaches appear to get stuck at a certain thresholds.

Peptide vaccine design (MHC1)
Vaccine size
(number of peptides)
FU5
FU5 evaluated on the diminishing
returns design of the same size op-
timized for FU5
Herst et al. (2020)
52
3.76697
4.99580
Liu et al. (2021)
19
3.39579
4.69175
Liu et al. (2021)
19
3.20910
4.69175
Fast, Altman, and Chen (2020)
13
2.93663
4.16200
Srivastava et al. (2020)
37
2.14414
4.97735
Poran et al. (2020)
10
1.80712
3.63369
Herst et al. (2020) top16
16
1.68352
4.49048
Ahmed, Quadeer, and McKay (2020)
16
1.46971
4.49048
Lee and Koohy (2020)
13
1.34565
4.16200
Vashi, Jagrit, and Kumar (2020)
51
1.12589
4.99536
Abdelmageed et al. (2020)
10
0.95321
3.63369
Akhand et al. (2020)
31
0.91429
4.95097
Gupta, Mishra, and Niraj (2020)
7
0.69957
2.82761
Baruah and Bose (2020)
5
0.64483
2.12411
Mitra, Pandey, and Swaroop
9
0.57102
3.39366
Alam et al. (2020)
3
0.49469
1.33187
Saha and Prasad (2020)
5
0.48918
2.12411
Bhattacharya et al. (2020)
13
0.41408
4.16200
Singh et al. (2020)
7
0.40922
2.82761
Peptide vaccine design (MHC2)
Vaccine size
(number of peptides)
FU5
FU5 evaluated on the diminishing
returns design of the same size op-
timized for FU5
Ramaiah and Arumugaswami (2021)
134
4.99516
4.99988
Liu et al. (2021)
19
3.28835
4.69175
Liu et al. (2021)
19
3.25892
4.69175
Fast, Altman, and Chen (2020)
13
2.54511
4.16200
Vashi, Jagrit, and Kumar (2020)
20
1.95264
4.73921
Abdelmageed et al. (2020)
10
1.90814
3.63369
Akhand et al. (2020)
31
1.72526
4.95097
Banerjee, Santra, and Maiti (2020)
9
1.71810
3.39366
Poran et al. (2020)
10
1.10991
3.63369
Mitra, Pandey, and Swaroop
5
0.96545
2.12411
Tahir ul Qamar et al. (2020)
11
0.77791
3.83742
Ahmed, Quadeer, and McKay (2020)
5
0.55950
2.12411
Singh et al. (2020)
7
0.40133
2.82761
Baruah and Bose (2020)
3
0.00000
1.33187
Table 1: 33 prior designs evaluated on FU5, compared against designs generated by optimizing for FU5 using the
diminishing returns framework (Algorithm 1).

A)
D)
B)
E)
C)
F)
Figure 9: For each vaccine design S we compute the n-times coverage of S and plot it as a function of |S|. Designs
for both MHC Class I (A-C) and MHC Class II (D-F) are given. For each size we plot the n-times coverage of designs
generated via the diminishing returns framework optimized via FU3 (DR3), FU5 (DR5), and FU8 (DR8), as well as the
n-times coverage of the ILP n=3 (ILP3), ILP n=5 (ILP5), and MarginalGreedy (MG) designs from Liu et al. (2021).
n-times coverage was computed for n = 3 (A,D), n = 5 (B,E), and n = 8 (C,F).

References
MI Abdelmageed, AH Abdelmoneim, MI Mustafa, NM Elfadol, NS Murshed, SW Shantier, and AM Makhawi. De-
sign of multi epitope-based peptide vaccine against e protein of human 2019-ncov: An immunoinformatics approach.
biorxiv 2020. Preprint, pages 1–21, 2020.
Syed Faraz Ahmed, Ahmed A Quadeer, and Matthew R McKay. Preliminary identiﬁcation of potential vaccine targets
for the covid-19 coronavirus (sars-cov-2) based on sars-cov immunological studies. Viruses, 12(3):254, 2020.
Mst Rubaiat Nazneen Akhand, Kazi Faizul Azim, Syeda Farjana Hoque, Mahmuda Akther Moli, Bijit Das Joy, Hafsa
Akter, Ibrahim Khalil Aﬁf, Nadim Ahmed, and Mahmudul Hasan. Genome based evolutionary study of sars-cov-2
towards the prediction of epitope based chimeric vaccine. BioRxiv, 2020.
Aftab Alam, Arbaaz Khan, Nikhat Imam, Mohd Faizan Siddiqui, Mohd Waseem, Md Zubbair Malik, and Romana
Ishrat. Design of an epitope-based peptide vaccine against the severe acute respiratory syndrome coronavirus-2 (sars-
cov-2): a vaccine-informatics approach. BioRxiv, 2020.
Amrita Banerjee, Dipannita Santra, and Smarajit Maiti. Energetics based epitope screening in sars cov-2 (covid 19)
spike glycoprotein by immuno-informatic analysis aiming to a suitable vaccine development. bioRxiv, 2020.
Vargab Baruah and Sujoy Bose. Immunoinformatics-aided identiﬁcation of t cell and b cell epitopes in the surface
glycoprotein of 2019-ncov. Journal of medical virology, 92(5):495–500, 2020.
Manojit Bhattacharya, Ashish R Sharma, Prasanta Patra, Pratik Ghosh, Garima Sharma, Bidhan C Patra, Sang-Soo
Lee, and Chiranjib Chakraborty. Development of epitope-based peptide vaccine against novel coronavirus 2019 (sars-
cov-2): Immunoinformatics approach. Journal of medical virology, 92(6):618–631, 2020.
Ethan Fast, Russ B Altman, and Binbin Chen. Potential t-cell and b-cell epitopes of 2019-ncov. BioRxiv, 2020.
Uriel Feige. A threshold of ln n for approximating set cover. Journal of the ACM (JACM), 45(4):634–652, 1998.
Ekta Gupta, Rupesh Kumar Mishra, and Ravi Ranjan Kumar Niraj. Identiﬁcation of potential vaccine candidates
against sars-cov-2, a step forward to ﬁght covid-19: A reverse vaccinology approach. bioRxiv, 2020.
Charles V Herst, Scott Burkholz, John Sidney, Alessandro Sette, Paul E Harris, Shane Massey, Trevor Brasel, Edecio
Cunha-Neto, Daniela S Rosa, William Chong Hang Chao, et al. An effective ctl peptide vaccine for ebola zaire based
on survivors’ cd8+ targeting of a particular nucleocapsid protein epitope with potential implications for covid-19
vaccine design. Vaccine, 38(28):4464–4475, 2020.
Chloe H Lee and Hashem Koohy. In silico identiﬁcation of vaccine targets for 2019-ncov. F1000Research, 9, 2020.
Ge Liu, Alexander Dimitrakakis, Brandon Carter, and David Gifford. Maximum n-times coverage for vaccine design.
In International Conference on Learning Representations, 2021.
D Mitra, J Pandey, and S Swaroop. Multi-epitope-based peptide vaccine design against sars-cov-2 using its spike
protein, biorxiv.(2020) 2020.04. 23.055467.
George L Nemhauser, Laurence A Wolsey, and Marshall L Fisher. An analysis of approximations for maximizing
submodular set functions—i. Mathematical programming, 14(1):265–294, 1978.
Asaf Poran, Dewi Harjanto, Matthew Malloy, Michael S Rooney, Lakshmi Srinivasan, and Richard B Gaynor.
Sequence-based prediction of vaccine targets for inducing t cell responses to sars-cov-2 utilizing the bioinformatics
predictor recon. bioRxiv, 2020.
Prasad Raghavendra and David Steurer. Graph expansion and the unique games conjecture. In Proceedings of the
forty-second ACM symposium on Theory of computing, pages 755–764, 2010.
Arunachalam Ramaiah and Vaithilingaraja Arumugaswami. Insights into cross-species evolution of novel human
coronavirus sars-cov-2 and deﬁning immune determinants for vaccine development. BioRxiv, pages 2020–01, 2021.
Birkir Reynisson, Bruno Alvarez, Sinu Paul, Bjoern Peters, and Morten Nielsen. Netmhcpan-4.1 and netmhciipan-4.0:
improved predictions of mhc antigen presentation by concurrent motif deconvolution and integration of ms mhc eluted
ligand data. Nucleic acids research, 48(W1):W449–W454, 2020.
Ratnadeep Saha and Burra VLS Prasad. In silico approach for designing of a multi-epitope based vaccine against
novel coronavirus (sars-cov-2). BioRxiv, 2020.
Abhishek Singh, Mukesh Thakur, Lalit Kumar Sharma, and Kailash Chandra. Designing a multi-epitope peptide based
vaccine against sars-cov-2. Scientiﬁc reports, 10(1):1–12, 2020.
Sukrit Srivastava, Sonia Verma, Mohit Kamthania, Rupinder Kaur, Ruchi Kiran Badyal, Ajay Kumar Saxena, Ho-
Joon Shin, Michael Kolbe, and Kailash C Pandey. Structural basis to design multi-epitope vaccines against novel
coronavirus 19 (covid19) infection, the ongoing pandemic emergency: an in silico approach. bioRxiv, 2020.
Muhammad Tahir ul Qamar, Abdur Rehman, Kishver Tusleem, Usman Ali Ashfaq, Muhammad Qasim, Xitong Zhu,
Israr Fatima, Farah Shahid, and Ling-Ling Chen. Designing of a next generation multiepitope based vaccine (mev)
against sars-cov-2: Immunoinformatics and in silico approaches. PloS one, 15(12):e0244176, 2020.

Yoya Vashi, Vipin Jagrit, and Sachin Kumar.
Understanding the b and t cell epitopes of spike protein of severe
acute respiratory syndrome coronavirus-2: A computational way to predict the immunogens. Infection, Genetics and
Evolution, 84:104382, 2020.
David Zuckerman. Linear degree extractors and the inapproximability of max clique and chromatic number. In
Proceedings of the thirty-eighth annual ACM symposium on Theory of computing, pages 681–690, 2006.

