Scilab Textbook Companion for
Digital Image Processing
by S. Jayaraman, S. Esakkirajan And T.
Veerakumar1
Created by
R.Senthilkumar
M.E., Assistant Professor
Electronics Engineering
Inst. of Road and Transport Tech., Erode
College Teacher
Dr. R.K.Gnanamurhty, Principal,V. C. E. W.
Cross-Checked by
Anuradha Amrutkar, IIT Bombay
July 31, 2019
1Funded by a grant from the National Mission on Education through ICT,
http://spoken-tutorial.org/NMEICT-Intro. This Textbook Companion and Scilab
codes written in it can be downloaded from the ”Textbook Companion Project”
section at the website http://scilab.in

Book Description
Title: Digital Image Processing
Author: S. Jayaraman, S. Esakkirajan And T. Veerakumar
Publisher: Tata McGraw - Hill Education Pvt. Ltd, New Delhi
Edition: 3
Year: 2010
ISBN: 978-0-07-014479-8
1

Scilab numbering policy used in this document and the relation to the
above book.
Exa Example (Solved example)
Eqn Equation (Particular equation of the above book)
AP Appendix to Example(Scilab Code that is an Appednix to a particular
Example of the above book)
For example, Exa 3.51 means solved example 3.51 of this book. Sec 2.3 means
a scilab code whose theory is explained in Section 2.3 of the book.
2

Contents
List of Scilab Codes
4
1
Introduction to Image Processing System
6
2
2D Signals and Systems
9
3
Convolution and Correlation
12
4
Image Transforms
20
5
Image Enhancement
30
6
Image Restoration and Denoising
40
7
Image Segmentation
60
8
Object Recognition
69
9
Image Compression
73
10 Binary Image Processing
77
11 Colur Image Processing
81
12 Wavelet based Image Processing
95
3

List of Scilab Codes
Exa 1.3
Program to calculate number of samples re-
quired for an image . . . . . . . . . . . . . .
6
Exa 1.13
False contouring Scilab code . . . . . . . . .
7
Exa 2.12
Frequency Response
. . . . . . . . . . . . .
9
Exa 2.16
Frequency Response
. . . . . . . . . . . . .
9
Exa 3.1
2D Linear Convlolution
. . . . . . . . . . .
12
Exa 3.2
2D Linear Convolution . . . . . . . . . . . .
12
Exa 3.3
2D Linear Convolution . . . . . . . . . . . .
13
Exa 3.7
2D Linear Convolution . . . . . . . . . . . .
14
Exa 3.8
2D Linear Convolution . . . . . . . . . . . .
14
Exa 3.11
Linear Convolution of any signal with an im-
pule signal given rise to the same signal
. .
15
Exa 3.12
Circular Convolution between two 2D matrices
15
Exa 3.13
Circular Convolution exspressed as linear con-
volution plus alias
. . . . . . . . . . . . . .
16
Exa 3.14
Linear Cross correlation of a 2D matrix . . .
17
Exa 3.15
Circular correlation between two signals
. .
17
Exa 3.16
Circular correlation between two signals
. .
18
Exa 3.17
Linear auto correlation of a 2D matrix . . .
18
Exa 3.18
Linear Cross correlation of a 2D matrix . . .
19
Exa 4.4
DFT of 4x4 grayscale image . . . . . . . . .
20
Exa 4.5
2D DFT of 4X4 grayscale image . . . . . . .
20
Exa 4.6
Scilab code to intergchange phase information
between two images . . . . . . . . . . . . . .
21
Exa 4.10
Program to compute discrete cosine transform
22
Exa 4.12
Program to perform KL tranform for the given
2D matrix . . . . . . . . . . . . . . . . . . .
24
4

Exa 4.13
Program to ﬁnd the singular value decompo-
sition of given matrix . . . . . . . . . . . . .
28
Exa 5.5
Scilab code for brightness enhancement . . .
30
Exa 5.7
Scilab code for brightness suppression . . . .
32
Exa 5.9
Scilab code for Contrast Manipulation
. . .
32
Exa 5.13
Scilab code to determine image negative . .
34
Exa 5.16
Scilab code that performs threshold operation
34
Exa 5.20
Program performs gray level slicing without
background . . . . . . . . . . . . . . . . . .
36
Exa 6.1
Scilab code to create motion blur . . . . . .
40
Exa 6.5
Scilab code performs inverse ﬁltering . . . .
41
Exa 6.7
Scilab code performs inverse ﬁltering . . . .
44
Exa 6.9
Scilab code performs Pseudo inverse ﬁltering
46
Exa 6.13
Scilab code to perform wiener ﬁltering of the
corrupted image . . . . . . . . . . . . . . . .
50
Exa 6.18
Scilab code to Perform Average Filtering op-
eration . . . . . . . . . . . . . . . . . . . . .
51
Exa 6.21
Scilab code to Perform median ﬁltering . . .
53
Exa 6.23
Scilab code to Perform median ﬁltering of colour
image
. . . . . . . . . . . . . . . . . . . . .
55
Exa 6.24
Scilab code to Perform Trimmed Average Fil-
ter . . . . . . . . . . . . . . . . . . . . . . .
57
Exa 7.23
Scilab code for Diﬀerentiation of Gaussian func-
tion
. . . . . . . . . . . . . . . . . . . . . .
60
Exa 7.25
Scilab code for Diﬀerentiation of Gaussian Fil-
ter function . . . . . . . . . . . . . . . . . .
63
Exa 7.27
Scilab code for Edge Detection using Diﬀerent
Edge detectors
. . . . . . . . . . . . . . . .
65
Exa 7.30
Scilab code to perform watershed transform
65
Exa 8.4
To verify the given matrix is a covaraince ma-
trix . . . . . . . . . . . . . . . . . . . . . . .
69
Exa 8.5
To compute the covariance of the given 2D
data . . . . . . . . . . . . . . . . . . . . . .
69
Exa 8.9
Develop a perceptron AND function with bipo-
lar inputs and targets
. . . . . . . . . . . .
71
Exa 9.9
Program performs Block Truncation Coding
BTC . . . . . . . . . . . . . . . . . . . . . .
73
Exa 9.59
Program performs Block Truncation Coding
75
5

Exa 10.17
Scilab Code for dilation and erosion process
77
Exa 10.19
Scilab Code to perform an opening and clos-
ing operation on the image . . . . . . . . . .
78
Exa 11.4
Read an RGB image and extract the three
colour components red green blue . . . . . .
81
Exa 11.12
Read a Colour image and separate the colour
image into red green and blue planes . . . .
82
Exa 11.16
Compute the histogram of the colour image
84
Exa 11.18
Perform histogram equalisation of the given
RGB image . . . . . . . . . . . . . . . . . .
86
Exa 11.21
This program performs median ﬁltering of the
colour image . . . . . . . . . . . . . . . . . .
87
Exa 11.24
Fitlering only the luminance component
. .
89
Exa 11.28
Perform gamma correction for the given colour
image
. . . . . . . . . . . . . . . . . . . . .
90
Exa 11.30
Perform Pseudo Colouring Operation . . . .
91
Exa 11.32
Read an RGB image and segment it using the
threshold method . . . . . . . . . . . . . . .
93
Exa 12.9
Scilab code to perform wavelet decomposition
95
Exa 12.42
Scilab code to generate diﬀerent levels of a
Gaussian pyramid . . . . . . . . . . . . . . .
96
Exa 12.57
Scilab code to implement watermarking in spa-
tial domain . . . . . . . . . . . . . . . . . .
97
Exa 12.63
Scilab code to implement wavelet based wa-
termarking
. . . . . . . . . . . . . . . . . .
100
6

List of Figures
1.1
False contouring Scilab code . . . . . . . . . . . . . . . . . .
8
2.1
Frequency Response
. . . . . . . . . . . . . . . . . . . . . .
10
2.2
Frequency Response
. . . . . . . . . . . . . . . . . . . . . .
11
4.1
Scilab code to intergchange phase information between two
images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
4.2
Program to compute discrete cosine transform . . . . . . . .
25
4.3
Program to compute discrete cosine transform . . . . . . . .
26
5.1
Scilab code for brightness enhancement . . . . . . . . . . . .
31
5.2
Scilab code for brightness suppression . . . . . . . . . . . . .
33
5.3
Scilab code for Contrast Manipulation
. . . . . . . . . . . .
35
5.4
Scilab code to determine image negative
. . . . . . . . . . .
35
5.5
Scilab code that performs threshold operation . . . . . . . .
37
5.6
Program performs gray level slicing without background
. .
39
6.1
Scilab code to create motion blur . . . . . . . . . . . . . . .
41
6.2
Scilab code performs inverse ﬁltering
. . . . . . . . . . . . .
43
6.3
Scilab code performs inverse ﬁltering
. . . . . . . . . . . . .
45
6.4
Scilab code performs inverse ﬁltering
. . . . . . . . . . . . .
47
6.5
Scilab code performs Pseudo inverse ﬁltering . . . . . . . . .
49
6.6
Scilab code to perform wiener ﬁltering of the corrupted image
52
6.7
Scilab code to Perform Average Filtering operation
. . . . .
54
7

6.8
Scilab code to Perform median ﬁltering . . . . . . . . . . . .
56
6.9
Scilab code to Perform median ﬁltering of colour image . . .
57
6.10 Scilab code to Perform Trimmed Average Filter . . . . . . .
59
7.1
Scilab code for Diﬀerentiation of Gaussian function . . . . .
61
7.2
Scilab code for Diﬀerentiation of Gaussian function . . . . .
62
7.3
Scilab code for Diﬀerentiation of Gaussian Filter function . .
63
7.4
Scilab code for Diﬀerentiation of Gaussian Filter function . .
64
7.5
Scilab code for Edge Detection using Diﬀerent Edge detectors
66
7.6
Scilab code to perform watershed transform
. . . . . . . . .
68
9.1
Program performs Block Truncation Coding . . . . . . . . .
76
10.1 Scilab Code for dilation and erosion process
. . . . . . . . .
78
10.2 Scilab Code to perform an opening and closing operation on
the image
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
80
11.1 Read an RGB image and extract the three colour components
red green blue . . . . . . . . . . . . . . . . . . . . . . . . . .
83
11.2 Read a Colour image and separate the colour image into red
green and blue planes . . . . . . . . . . . . . . . . . . . . . .
85
11.3 This program performs median ﬁltering of the colour image .
88
11.4 Fitlering only the luminance component
. . . . . . . . . . .
90
11.5 Perform gamma correction for the given colour image . . . .
91
11.6 Perform Pseudo Colouring Operation . . . . . . . . . . . . .
93
11.7 Read an RGB image and segment it using the threshold method
94
12.1 Scilab code to generate diﬀerent levels of a Gaussian pyramid
98
12.2 Scilab code to implement watermarking in spatial domain . .
100
8

Chapter 1
Introduction to Image
Processing System
Scilab code Exa 1.3 Program to calculate number of samples required for an image
1
// Caption : Program
to
c a l c u l a t e
number
of
samples
r e q u i r e d
f o r
an image
2
// Example1 . 3
3
// page
12
4
clc;
5
close;
6
// dimension
of
the
image
in
i n c h e s
7
m = 4;
8
n = 6;
9
N = 400; //number
of
dots
per
inch
in
each
d i r e c t i o n
10
N2 = 2*N; //number
of
dots
per
inch
in
both
h o r i z o n t a l & v e r t i c a l
11
Fs = m*N2*n*N2;
12
disp(Fs , ’ Number
of
samples
r e u q i r e d
to
p r e s e r v e
the
i n f o r m a t i o n
in
the
image= ’ )
13
// Result
14
//Number
of
samples
r e u q i r e d
to
p r e s e r v e
the
i n f o r m a t i o n
in
the
image=
15
// 15360000.
9

check Appendix AP 4 for dependency:
gray.sci
check Appendix AP 5 for dependency:
grayslice.sci
Scilab code Exa 1.13 False contouring Scilab code
1
// Caption :
False
contouring
S c i l a b
code
2
// Fig1 .13
3
// page
13
4
clc;
5
close;
6
a =ReadImage( ’E: \DIP JAYARAMAN\ Chapter1 \ tigerpub . jpg
’ );
7
a = uint8(a);
8
figure
9
imshow(a)
10
title( ’ O r i g i n a l
image ’ );
11
// using
128
gray
l e v e l s
12
figure
13
a_128 = grayslice(a ,128);
14
gray_128 = gray (128);
15
ShowImage(a_128 , ’ Image
with
128
gray
l e v e l s ’ ,
gray_128);
16
// using
64
gray
l e v e l s
17
figure
18
a_64 = grayslice(a,64);
19
gray_64 = gray (64);
20
ShowImage(a_64 , ’ Image
with
64
gray
l e v e l s ’ ,gray_64);
21
// using
32
gray
l e v e l s
22
figure
23
a_32 = grayslice(a,32);
10

Figure 1.1: False contouring Scilab code
24
gray_32 = gray (32);
25
ShowImage(a_32 , ’ Image
with
32
gray
l e v e l s ’ ,gray_32);
26
// using
16
gray
l e v e l s
27
figure
28
a_16 = grayslice(a,16);
29
gray_16 = gray (16);
30
ShowImage(a_16 , ’ Image
with
16
gray
l e v e l s ’ ,gray_16);
31
// using
8
gray
l e v e l s
32
a_8 = grayslice(a,8);
33
gray_8 = gray (8);
34
ShowImage(a_8 , ’ Image
with 8 gray
l e v e l s ’ ,gray_8);
11

Chapter 2
2D Signals and Systems
Scilab code Exa 2.12 Frequency Response
1
// Caption :
Frequency
Response
2
// Fig2 .12
3
// page
60
4
clc;
5
close;
6
[X, Y] = meshgrid(-%pi :.09: %pi);
7
Z = 2*cos(X)+2* cos(Y);
8
surf(X,Y,Z);
9
xgrid (1)
Scilab code Exa 2.16 Frequency Response
1
// Caption :
Frequency
Response
2
// Fig2 .16
3
// page
64
12

Figure 2.1: Frequency Response
4
clc;
5
close;
6
[X, Y] = meshgrid(-%pi :.05: %pi);
7
Z = 2-cos(X)-cos(Y);
8
surf(X,Y,Z);
9
xgrid (1)
13

Figure 2.2: Frequency Response
14

Chapter 3
Convolution and Correlation
Scilab code Exa 3.1 2D Linear Convlolution
1
// Caption : 2−D Linear
Convolution
2
// Example3 . 1 & Example3 . 4
3
// page
85 & page
107
4
clc;
5
x =[4 ,5 ,6;7 ,8 ,9];
6
h = [1;1;1];
7
disp(x, ’ x= ’ )
8
disp(h, ’ h= ’ )
9
[y,X,H] = conv2d2(x,h);
10
disp(y, ’ Linear
2D c o n v o l u t i o n
r e s u l t
y = ’ )
11
// Result
12
// Linear
2D c o n v o l u t i o n
r e s u l t
y =
13
//
14
//
4 .
5 .
6 .
15
//
11 .
1 3.
15.
16
//
11 .
1 3.
15.
17
//
7 .
8 .
9 .
Scilab code Exa 3.2 2D Linear Convolution
15

1
// Caption : 2−D Linear
Convolution
2
// Example3 . 2 & Example3 . 5 & Example3 . 9
3
// page
91 & page
108 & page
116
4
clc;
5
x =[1 ,2 ,3;4 ,5 ,6;7 ,8 ,9];
6
h = [1 ,1;1 ,1;1 ,1];
7
y = conv2d2(x,h);
8
disp(y, ’ Linear
2D c o n v o l u t i o n
r e s u l t
y = ’ )
9
// Result
10
//
Linear
2D c o n v o l u t i o n
r e s u l t
y =
11
//
12
//
1 .
3 .
5 .
3 .
13
//
5 .
12.
16 .
9 .
14
//
12 .
2 7.
33.
18.
15
//
11 .
2 4.
28.
15.
16
//
7 .
15.
17 .
9 .
17
//
Scilab code Exa 3.3 2D Linear Convolution
1
// Caption : 2−D Linear
Convolution
2
// Example3 . 3 & Example3 . 6 & Example3 . 10
3
// page
100 & page
109 & page
119
4
clc;
5
x =[1 ,2 ,3;4 ,5 ,6;7 ,8 ,9];
6
h = [3,4,5];
7
y = conv2d2(x,h);
8
disp(y, ’ Linear
2D c o n v o l u t i o n
r e s u l t
y = ’ )
9
// Result
10
// Linear
2D c o n v o l u t i o n
r e s u l t
y =
11
//
12
//
3 .
10.
22 .
2 2.
15.
13
//
12 .
3 1.
58.
49.
30 .
14
//
21 .
5 2.
94.
76.
45 .
16

Scilab code Exa 3.7 2D Linear Convolution
1
// Caption : 2−D Linear
Convolution
2
// Example3 . 7
3
// page
111
4
clc;
5
x =[1 ,2;3 ,4];
6
h = [5 ,6;7 ,8];
7
y = conv2d2(x,h);
8
disp(y, ’ Linear
2D c o n v o l u t i o n
r e s u l t
y = ’ )
9
// Result
10
//
Linear
2D c o n v o l u t i o n
r e s u l t
y =
11
// Linear
2D c o n v o l u t i o n
r e s u l t
y =
12
//
13
//
5 .
16.
12 .
14
//
22 .
6 0.
40.
15
//
21 .
5 2.
32
Scilab code Exa 3.8 2D Linear Convolution
1
// Caption : 2−D Linear
Convolution
2
// Example3 . 8
3
// page
113
4
clc;
5
x =[1 ,2 ,3;4 ,5 ,6;7 ,8 ,9];
6
h = [1;1;1];
7
y = conv2d2(x,h);
8
disp(y, ’ Linear
2D c o n v o l u t i o n
r e s u l t
y = ’ )
9
// Result
10
//
Linear
2D c o n v o l u t i o n
r e s u l t
y =
11
// //
1 .
2 .
3 .
12
//
5 .
7 .
9 .
17

13
//
12 .
1 5.
18.
14
//
11 .
1 3.
15.
15
//
7 .
8 .
9 .
Scilab code Exa 3.11 Linear Convolution of any signal with an impule signal given
1
// Caption :
Linear
COnvolution
of
any
s i g n a l
with an
impulse
s i g n a l
g i v e s
2
// r i s e
to
the
same
s i g n a l
3
// Example3 . 11
4
// page
121
5
clc;
6
x =[1 ,2;3 ,4];
7
h = 1;
8
y = conv2d2(x,h);
9
disp(y, ’ Linear
2D c o n v o l u t i o n
r e s u l t
y = ’ )
10
// Result
11
// Linear
2D c o n v o l u t i o n
r e s u l t
y =
12
// //
Linear
2D c o n v o l u t i o n
r e s u l t
y =
13
//
14
//
1 .
2 .
15
//
3 .
4 .
Scilab code Exa 3.12 Circular Convolution between two 2D matrices
1
// Caption :
C i r c u l a r
Convolution
between two 2D
matrices
2
// Example3 . 12
3
// page
122
4
clc;
5
x = [1 ,2;3 ,4];
6
h = [5 ,6;7 ,8];
7
X = fft2d(x); //2D FFT of
x matrix
18

8
H = fft2d(h); //2D FFT of
h matrix
9
Y = X.*H;
// Element by Element
m u l t i p l i c a t i o n
10
y = ifft2d(Y);
11
disp(y, ’ C i r c u l a r
Convolution
Result
y = ’ )
12
// Result
13
// C i r c u l a r
Convolution
Result
y =
14
//
15
//
70 .
6 8.
16
//
62 .
6 0.
Scilab code Exa 3.13 Circular Convolution exspressed as linear convolution plus al
1
// Caption :
C i r c u l a r
Convolution
expressed
as
l i n e a r
c o n v o l u t i o n
plus
a l i a s
2
// Example3 . 13
3
// page
123
4
clc;
5
x = [1 ,2;3 ,4];
6
h = [5 ,6;7 ,8];
7
y = conv2d(x,h);
8
y1 = [y(:,1)+y(:,$),y(:,2)];
9
y2 = [y1(1,:)+y1($,:);y1(2,:)]
10
disp(y, ’ Linear
Convolution
r e s u l t
y= ’ )
11
disp(y2 , ’ c i r c u l a r
c o n v o l u t i o n
expessed
as
l i n e a r
c o n v o l u t i o n
plus
a l i a s = ’ )
12
// Result
13
//
Linear
Convolution
r e s u l t
y=
14
//
15
//
5 .
16.
12 .
16
//
22 .
6 0.
40.
17
//
21 .
5 2.
32.
18
//
19
//
c i r c u l a r
c o n v o l u t i o n
expessed
as
l i n e a r
c o n v o l u t i o n
plus
a l i a s =
20
//
19

21
//
70 .
6 8.
22
//
62 .
6 0.
23
//
Scilab code Exa 3.14 Linear Cross correlation of a 2D matrix
1
// Caption :
l i n e a r
c r o s s
c o r r e l a t i o n
of
a 2D matrix
2
// Example3 . 14
3
// page
129
4
clc;
5
x = [3 ,1;2 ,4];
6
h1 = [1 ,5;2 ,3];
7
h2 = h1(:,$: -1:1);
8
h = h2($:-1:1,:);
9
y = conv2d(x,h)
10
disp(y, ’ Linear
c r o s s
C o r r e l a t i o n
r e s u l t
y= ’ )
11
// Result
12
// Linear
c r o s s
C o r r e l a t i o n
r e s u l t
y=
13
//
14
//
9 .
9 .
2 .
15
//
21 .
2 4.
9 .
16
//
10 .
2 2.
4 .
Scilab code Exa 3.15 Circular correlation between two signals
1
// Caption :
C i r c u l a r
c o r r e l a t i o n
between two
s i g n a l s
2
// Example3 . 15
3
// page
131
4
clc;
5
x = [1 ,5;2 ,4];
6
h = [3 ,2;4 ,1];
7
h = h(:,$: -1:1);
8
h = h($:-1:1,:);
20

9
X = fft2d(x);
10
H = fft2d(h);
11
Y = X.*H;
12
y = ifft2d(Y);
13
disp(y, ’ C i r c u l a r
C o r r e l a t i o n
r e s u l t
y= ’ )
14
// Result
15
// C i r c u l a r
C o r r e l a t i o n
r e s u l t
y=
16
//
17
//
37 .
2 3.
18
//
35 .
2 5.
Scilab code Exa 3.16 Circular correlation between two signals
1
// Caption :
C i r c u l a r
c o r r e l a t i o n
between two
s i g n a l s
2
// Example3 . 16
3
// page
134
4
clc;
5
x = [5 ,10;15 ,20];
6
h = [3 ,6;9 ,12];
7
h = h(:,$: -1:1);
8
h = h($:-1:1,:);
9
X = fft2d(x);
10
H = fft2d(h);
11
Y = X.*H;
12
y = ifft2d(Y);
13
disp(y, ’ C i r c u l a r
C o r r e l a t i o n
r e s u l t
y= ’ )
14
// Result
15
//
C i r c u l a r
C o r r e l a t i o n
r e s u l t
y=
16
//
17
//
300.
330.
18
//
420.
450.
Scilab code Exa 3.17 Linear auto correlation of a 2D matrix
21

1
// Caption :
l i n e a r
auto
c o r r e l a t i o n
of
a 2D matrix
2
// Example3 . 17
3
// page
136
4
clc;
5
x1 = [1 ,1;1 ,1];
6
x2 = x1(:,$: -1:1);
7
x2 = x2($:-1:1,:);
8
x = conv2d(x1 ,x2)
9
disp(x, ’ Linear
auto
C o r r e l a t i o n
r e s u l t
x= ’ )
10
// Result
11
// Linear
auto
C o r r e l a t i o n
r e s u l t
x=
12
//
13
//
1 .
2 .
1 .
14
//
2 .
4 .
2 .
15
//
1 .
2 .
1 .
Scilab code Exa 3.18 Linear Cross correlation of a 2D matrix
1
// Caption :
l i n e a r
c r o s s
c o r r e l a t i o n
of
a 2D matrix
2
// Example3 . 18
3
// page
141
4
clc;
5
x = [1 ,1;1 ,1];
6
h1 = [1 ,2;3 ,4];
7
h2 = h1(:,$: -1:1);
8
h = h2($:-1:1,:);
9
y = conv2d(x,h)
10
disp(y, ’ Linear
c r o s s
C o r r e l a t i o n
r e s u l t
y= ’ )
11
// Result
12
// Linear
c r o s s
C o r r e l a t i o n
r e s u l t
y=
13
//
14
//
4 .
7 .
3 .
15
//
6 .
10.
4 .
16
//
2 .
3 .
1 .
22

Chapter 4
Image Transforms
Scilab code Exa 4.4 DFT of 4x4 grayscale image
1
// Caption :
2D DFT of
4x4
g r a y s c a l e
image
2
// Example4 . 4
3
// page
170
4
clc;
5
f = [1,1,1,1;1,1,1,1;1,1,1,1;1,1,1,1];
6
N =4; //4−point DFT
7
kernel = dft_mtx(N);
8
F = kernel *(f*kernel ’);
9
disp(F, ’ 2D DFT of
given
2D image = ’ )
10
// Result
11
//2D DFT of
given
2D image =
12
//
13
//
16 .
0
0
0
14
//
0
0
0
0
15
//
0
0
0
0
16
//
0
0
0
0
Scilab code Exa 4.5 2D DFT of 4X4 grayscale image
23

1
// Caption :
2D DFT of
4x4
g r a y s c a l e
image
2
// Example4 . 5
3
// page
171
4
clc;
5
F = [16,0,0,0;0,0,0,0;0,0,0 ,0;0,0,0,0];
6
N =4; //4−point DFT
7
kernel = dft_mtx(N);
8
f = (kernel *(F*kernel ’))/(N^2);
9
f = real(f);
10
disp(f, ’ I n v e r s e
2D DFT of
the
transformed
image
f = ’
)
11
// Result
12
// I n v e r s e
2D DFT of
the
transformed
image
f =
13
//
14
//
1 .
1 .
1 .
1 .
15
//
1 .
1 .
1 .
1 .
16
//
1 .
1 .
1 .
1 .
17
//
1 .
1 .
1 .
1 .
check Appendix AP 1 for dependency:
fft2d.sce
check Appendix AP 2 for dependency:
ifft2d.sce
Scilab code Exa 4.6 Scilab code to intergchange phase information between two imag
1
// Caption : S c i l a b
code
to
i n t e r g c h a n g e
phase
i n f o r m a t i o n
between two
images
2
// Example4 . 6
3
// page 174−175
4
clc;
5
close;
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter4 \ lena . png ’ );
//SIVP toolbox
24

7
b = imread( ’E: \DIP JAYARAMAN\ Chapter4 \baboon . png ’ );
8
a = rgb2gray(a);
9
b = rgb2gray(b);
10
a = imresize(a ,0.5);
11
b = imresize(b ,0.5);
12
figure (1)
13
ShowImage(a, ’ O r i g i n a l
lena
Image ’ );
//IPD toolbox
14
title( ’ O r i g i n a l
lena
Image ’ );
15
figure (2)
16
ShowImage(b, ’ O r i g i n a l
baboon Image ’ );
17
title( ’ O r i g i n a l
baboon Image ’ )
18
ffta = fft2d(double(a));
19
fftb = fft2d(double(b));
20
mag_a = abs(ffta);
21
mag_b = abs(fftb);
22
ph_a = atan(imag(ffta),real(ffta));
23
ph_b = atan(imag(fftb),real(fftb));
24
newfft_a = mag_a .*( exp(%i*ph_b));
25
newfft_b = mag_b .*( exp(%i*ph_a));
26
rec_a = ifft2d(newfft_a);
27
rec_b = ifft2d(newfft_b);
28
figure (3)
29
ShowImage(uint8(rec_a), ’ lena
Image
a f t e r
phase
r e v e r s a l ’ );
30
title( ’ lena
Image
a f t e r
phase
r e v e r s a l ’ )
31
figure (4)
32
ShowImage(uint8(rec_b), ’ baboon Image
a f t e r
phase
r e v e r s a l ’ );
33
title( ’ baboon Image
a f t e r
phase
r e v e r s a l ’ )
Scilab code Exa 4.10 Program to compute discrete cosine transform
25

Figure 4.1: Scilab code to intergchange phase information between two im-
ages
26

1
// Caption :
Program
to
compute
d i s c r e t e
c o s i n e
tranform
2
// Example4 . 10
3
// page
198
4
clc;
5
N =4; //DCT matrix
of
order
f o u r
6
X = dct_mtx(N);
7
disp(X, ’DCT matrix
of
order
f o u r ’ )
8
// Result
9
//DCT matrix
of
order
f o u r
10
//
11
//
0. 5
0 .5
0.5
0. 5
12
//
0.6532815
0.2705981
−0.2705981
−
0.6532815
13
//
0. 5
−0. 5
−0. 5
0 .5
14
//
0.2705981
−0.6532815
0.6532815
−
0.2705981
Scilab code Exa 4.12 Program to perform KL tranform for the given 2D matrix
1
// Caption :
Program
to
perform KL transform
f o r
the
given
2D matrix
2
// Example4 . 12
3
// page
208
4
clear;
5
clc;
6
X = [4,3,5,6;4,2,7,7;5,5,6,7];
7
[m,n]= size(X);
8
A = [];
9
E = [];
10
for i =1:n
27

Figure 4.2: Program to compute discrete cosine transform
28

Figure 4.3: Program to compute discrete cosine transform
29

11
A = A+X(:,i);
12
E = E+X(:,i)*X(:,i) ’;
13
end
14
mx = A/n;
//mean matrix
15
E = E/n;
16
C = E - mx*mx ’;// c o v a r i a n c e
matrix C = E[ xx ’] −mx∗mx’
17
[V,D] = spec(C); // e i g e n
v a l u e s
and
e i g e n
v e c t o r s
18
d = diag(D); // diagonal
elements
od
e i g e n
v a l u e s
19
[d,i] = gsort(d); // s o r t i n g
the
elements
of D in
descending
order
20
for j = 1: length(d)
21
T(:,j)= V(:,i(j));
22
end
23
T =T’
24
disp(d, ’ Eigen
Values
are U = ’ )
25
disp(T, ’ The
e i g e n
v e c t o r
matrix T = ’ )
26
disp(T, ’ The KL tranform
b a s i s
i s = ’ )
27
//KL transform
28
for i = 1:n
29
Y(:,i)= T*X(:,i);
30
end
31
disp(Y, ’KL t r a n s f o r m a t i o n
of
the
input
matrix Y = ’ )
32
// Reconstruction
33
for i = 1:n
34
x(:,i)= T’*Y(:,i);
35
end
36
disp(x, ’ Reconstruct
matrix
of
the
given
sample
matrix X = ’ )
37
// Result
38
//
Eigen
Values
are U =
39
//
6.1963372
40
//
0.2147417
41
//
0.0264211
42
// The
e i g e n
v e c t o r
matrix T =
43
//
0.4384533
0.8471005
0.3002988
44
//
0.4460381
−0.4951684
0.7455591
45
//
−0.7802620
0.1929481
0.5949473
46
// The KL tranform
b a s i s
i s =
30

47
//
0.4384533
0.8471005
0.3002988
48
//
0.4460381
−0.4951684
0.7455591
49
//
−0.7802620
0.1929481
0.5949473
50
// KL t r a n s f o r m a t i o n
of
the
input
matrix Y =
51
//
6.6437095
4.5110551
9.9237632
10.662515
52
//
3.5312743
4.0755729
3.2373664
4.4289635
53
//
0.6254808
1.0198466
1.0190104
0.8336957
54
//
Reconstruct
matrix
of
the
given
sample
matrix x =
55
//
4 .
3 .
5 .
6 .
56
//
4 .
2 .
7 .
7 .
57
//
5 .
5 .
6 .
7 .
Scilab code Exa 4.13 Program to find the singular value decomposition of given mat
1
// Caption :
Program
to
f i n d
the
s i n g u l a r
value
decomposition
of
given
matrix
2
// Example4 . 13
3
// page
210
4
clear;
5
clc;
6
A = [1,-2,3;3,2,-1];
7
[U,S,V]= svd(A);
8
A_recon = U*S*V’;
9
disp(U, ’U = ’ )
10
disp(S, ’ S = ’ )
11
disp(V, ’V = ’ )
12
disp(A_recon , ’A matrix
from
svd = ’ )
13
// Result
14
// U =
15
//
16
//
−0.7071068
0.7071068
17
//
0.7071068
0.7071068
31

18
//
19
// S =
20
//
21
//
4.2426407
0 .
0 .
22
//
0 .
3.1622777
0 .
23
//
24
// V =
25
//
26
//
0.3333333
0.8944272
−0.2981424
27
//
0.6666667
−2.776D−16
0.7453560
28
//
−0.6666667
0.4472136
0.5962848
29
//
30
// A matrix
from
svd =
31
//
32
//
1 .
−2 .
3 .
33
//
3 .
2 .
−1 .
32

Chapter 5
Image Enhancement
Scilab code Exa 5.5 Scilab code for brightness enhancement
1
// Caption : S c i l a b
code
f o r
b r i g h t n e s s
enhancement
2
// Fig5 . 5
3
// page
246
4
clc;
5
close;
6
//a = imread ( ’E: \DIP JAYARAMAN\ Chapter5 \ p l a t e . GIF ’ ) ;
//SIVP toolbox
7
a = imread( ’E: \DIP JAYARAMAN\ Chapter4 \baboon . png ’ );
8
a = rgb2gray(a);
9
b = double(a)+50;
10
b = uint8(b);
11
figure (1)
12
ShowImage(a, ’ O r i g i n a l
Image ’ );
13
title( ’ O r i g i n a l
Image ’ )
14
figure (2)
15
ShowImage(b, ’ Enhanced Image ’ );
16
title( ’ Enhanced Image ’ )
33

34

Scilab code Exa 5.7 Scilab code for brightness suppression
1
// Caption : S c i l a b
code
f o r
b r i g h t n e s s
s u p p r e s s i o n
2
// Fig5 . 7
3
// page
247
4
clc;
5
close;
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter4 \baboon . png ’ );
7
a = rgb2gray(a);
8
b = double(a) -50;
9
b = uint8(b);
10
figure (1)
11
ShowImage(a, ’ O r i g i n a l
Image ’ );
12
title( ’ O r i g i n a l
Image ’ )
13
figure (2)
14
ShowImage(b, ’ B r i g h t n e s s
Supressed
Image ’ );
15
title( ’ B r i g h t n e s s
Supressed
Image ’ )
Scilab code Exa 5.9 Scilab code for Contrast Manipulation
1
// Caption : S c i l a b
code
f o r
Contrast
Manipulation
2
// Fig5 . 9
3
// page
248
4
clc;
5
close;
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter4 \ lena . png ’ );
7
a = rgb2gray(a);
8
b = double(a)*0.5;
9
b = uint8(b)
10
c = double(b)*2;
35

36

11
c = uint8(c)
12
figure (1)
13
ShowImage(a, ’ O r i g i n a l
Image ’ );
14
title( ’ O r i g i n a l
Image ’ )
15
figure (2)
16
ShowImage(b, ’ Decrease
in
Contrast ’ );
17
title( ’ Decrease
in
Contrast ’ )
18
figure (3)
19
ShowImage(c, ’ I n c r e a s e
in
Contrast ’ );
20
title( ’ I n c r e a s e
in
Contrast ’ )
Scilab code Exa 5.13 Scilab code to determine image negative
1
// Caption : S c i l a b
code
to
determine
image
n e g a t i v e
2
// Fig . 5 . 1 3
3
// page
252
4
clc;
5
close;
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter5 \ l a b e l . jpg ’ );
7
k = 255- double(a);
8
k = uint8(k);
9
imshow(a);
10
title( ’ O r i g i n a l
onca
Image ’ )
11
imshow(k);
12
title( ’ Negative
of
O r i g i n a l
Image ’ )
Scilab code Exa 5.16 Scilab code that performs threshold operation
37

Figure 5.3: Scilab code for Contrast Manipulation
Figure 5.4: Scilab code to determine image negative
38

1
// Caption : S c i l a b
code
that
performs
t h r e s h o l d
o p e r a t i o n
2
// Fig5 .16
3
// page
254
4
clc;
5
close;
6
a = imread( ’E: \ Digital Image Processing Jayaraman \
Chapter5 \ lena . png ’ );
7
a = rgb2gray(a);
8
[m n] = size(a);
9
t = input( ’ Enter
the
t h r e s h o l d
parameter ’ );
10
for i = 1:m
11
for j = 1:n
12
if(a(i,j)<t)
13
b(i,j)=0;
14
else
15
b(i,j)=255;
16
end
17
end
18
end
19
figure (1)
20
ShowImage(a, ’ O r i g i n a l
Image ’ );
21
title( ’ O r i g i n a l
Image ’ )
22
figure (2)
23
ShowImage(b, ’ Thresholded
Image ’ );
24
title( ’ Thresholded
Image ’ )
25
xlabel(sprintf( ’ Threshold
value
i s %g ’ ,t))
26
// Result
27
// Enter
the
t h r e s h o l d
parameter
140
Scilab code Exa 5.20 Program performs gray level slicing without background
39

40

1
// Caption :
Program
performs
gray
l e v e l
s l i c i n g
without
background
2
// Fig . 5 . 2 0
3
// page256
4
clc;
5
x = imread( ’E: \ Digital Image Processing Jayaraman \
Chapter5 \ lena . png ’ );
6
x = rgb2gray(x);
7
y = double(x);
8
[m,n]= size(y);
9
L = max(max(x));
10
a = round(L/2);
11
b = L;
12
for i =1:m
13
for j =1:n
14
if(y(i,j) >=a & y(i,j) <=b)
15
z(i,j) = L;
16
else
17
z(i,j)=0;
18
end
19
end
20
end
21
z = uint8(z);
22
figure (1)
23
ShowImage(x, ’ O r i g i n a l
Image ’ );
24
title( ’ Orginal
Image ’ )
25
figure (2)
26
ShowImage(z, ’ Gray
Level
S l i c i n g ’ );
27
title( ’ Gray
Level
S l i c i n g
without
p r e s e r v i n g
background ’ )
41

Figure 5.6: Program performs gray level slicing without background
42

Chapter 6
Image Restoration and
Denoising
Scilab code Exa 6.1 Scilab code to create motion blur
1
// Caption : S c i l a b
code
to
c r e a t e
motion
blur
2
// Fig6 . 1
3
// page
326
4
clc;
5
close;
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter6 \humm. jpg ’ );//
SIVP toolbox
7
// f i l t e r
c o e f f i c i e n t s
of
f s p e c i a l ( ’ motion ’ , 1 0 , 2 5 )
8
H =[0 ,0 ,0 ,0 ,0 ,0 ,0 ,0.0032 ,0.0449 ,0.0865 ,0.0072;...
9
0 ,0 ,0 ,0 ,0 ,0.0092 ,0.0509 ,0.0925 ,0.0629 ,0.0213 ,0;...
10
0 ,0 ,0 ,0.0152 ,0.0569 ,0.0985 ,0.0569 ,0.0152 ,0 ,0 ,0;...
11
0 ,0.0213 ,0.0629 ,0.0925 ,0.0509 ,0.0092 ,0 ,0 ,0 ,0 ,0;...
12
0.0072 ,0.0865 ,0.0449 ,0.0032 ,0 ,0 ,0 ,0 ,0 ,0 ,0];
13
Motion_Blur = imfilter(a,H);
14
Motion_Blur =uint8(Motion_Blur);
15
ShowImage(a, ’ o r i g i n a l
Image ’ )
16
title( ’ o r i g i n a l
Image ’ )
17
figure
18
ShowImage(Motion_Blur , ’ Motion
Blurred
Image ’ )
43

Figure 6.1: Scilab code to create motion blur
19
title( ’ 10 x25 Motion
Blurred
Image ’ )
check Appendix AP 1 for dependency:
fft2d.sce
check Appendix AP 2 for dependency:
ifft2d.sce
Scilab code Exa 6.5 Scilab code performs inverse filtering
1
// Caption : S c i l a b
code
performs
i n v e r s e
f i l t e r i n g
2
// Degrade
the
image by means
of
a known
blur
3
// Apply
i n v e r s e
f i l t e r
to
the
b l u r r e d
image and
see
the
r e s t o r e d
image
4
// Fig6 . 5
5
// page
330
6
clc;
7
close;
44

8
x =imread( ’E: \DIP JAYARAMAN\ Chapter6 \ f l o w e r 2 . jpg ’ );
9
x=double(rgb2gray(x));
10
[M N]= size(x);
11
h = zeros(M,N);
12
for i = 1:11
13
for j = 1:11
14
h(i,j) = 1/121;
15
end
16
end
17
sigma = sqrt (4*10^( -7));
18
freqx = fft2d(x); // Fourier
transform
of
input
image
19
freqh = fft2d(h);// Fourier
transform
of
degradation
20
y = real(ifft2d(freqh .* freqx));
21
freqy = fft2d(y);
22
powfreqx = freqx .^2/(M*N);
23
alpha = 0.5; // I n d i c a t e s
i n v e r s e
f i l t e r
24
freqg = (( freqh.’) ’).*abs(powfreqx)./( abs(freqh .^2)
.*abs(powfreqx)+alpha*sigma ^2);
25
Resfreqx = freqg .* freqy;
26
Resa = real(ifft2d(Resfreqx));
27
x = uint8(x);
28
y = uint8(y);
29
Resa = uint8(Resa)
30
ShowImage(x, ’ O r i g i n a l
Image ’ )
31
title( ’ O r i g i n a l
Image ’ )
32
figure
33
ShowImage(y, ’ Degraded Image ’ )
34
title( ’ Degraded Image ’ )
35
figure
36
ShowImage(Resa , ’ Restored
Image ’ )
37
title( ’ Restored
Image ’ )
check Appendix AP 1 for dependency:
fft2d.sce
check Appendix AP 2 for dependency:
45

46

ifft2d.sce
Scilab code Exa 6.7 Scilab code performs inverse filtering
1
// Caption : S c i l a b
code
performs
i n v e r s e
f i l t e r i n g
2
// Degrade
the
image by means
of
a known
blur
and
white
n o i s e
3
//The image
i s
degraded
as
w e l l
as
corrupted
by
n o i s e
4
// Apply
i n v e r s e
f i l t e r
to
r e s t o r e
the
image
5
// Fig6 . 7
6
// page
332
7
clc;
8
close;
9
x =imread( ’E: \DIP JAYARAMAN\ Chapter6 \ f l o w e r 2 . jpg ’ );
10
x=double(rgb2gray(x));
11
[M N]= size(x);
12
h = zeros(M,N);
13
for i = 1:11
14
for j = 1:11
15
h(i,j) = 1/121;
16
end
17
end
18
sigma = sqrt (4*10^( -7));
19
freqx = fft2d(x); // Fourier
transform
of
input
image
20
freqh = fft2d(h);// Fourier
transform
of
degradation
21
y = real(ifft2d(freqh .* freqx))+10* rand(M,N, ’ normal ’ )
;
22
freqy = fft2d(y);
23
powfreqx = freqx .^2/(M*N);
24
alpha = 0.5; // I n d i c a t e s
i n v e r s e
f i l t e r
25
freqg = (( freqh.’) ’).*abs(powfreqx)./( abs(freqh .^2)
.*abs(powfreqx)+alpha*sigma ^2);
26
Resfreqx = freqg .* freqy;
47

48

27
Resa = real(ifft2d(Resfreqx));
28
x = uint8(x);
29
y = uint8(y);
30
Resa = uint8(Resa)
31
ShowImage(x, ’ O r i g i n a l
Image ’ )
32
title( ’ O r i g i n a l
Image ’ )
33
figure
34
ShowImage(y, ’ Degraded+n o i s e
Image ’ )
35
title( ’ Degraded+n o i s e
Image ’ )
36
figure
37
ShowImage(Resa , ’ Restored
Image ’ )
38
title( ’ Restored
Image ’ )
check Appendix AP 1 for dependency:
fft2d.sce
check Appendix AP 2 for dependency:
ifft2d.sce
Scilab code Exa 6.9 Scilab code performs Pseudo inverse filtering
1
// Caption : S c i l a b
code
performs
Pseudo
i n v e r s e
f i l t e r i n g
2
// Degrade
the
image by means
of
a known
blur
and
white
n o i s e
3
//The image
i s
degraded
as
w e l l
as
corrupted
by
n o i s e
4
// Apply Pseudo
i n v e r s e
f i l t e r
to
r e s t o r e
the
image
5
// Fig6 . 9
6
// page
333
7
clc;
8
close;
9
x =imread( ’E: \DIP JAYARAMAN\ Chapter6 \ f l o w e r 2 . jpg ’ );
49

50

10
x=double(rgb2gray(x));
11
[M N]= size(x);
12
h = zeros(M,N);
13
for i = 1:11
14
for j = 1:11
15
h(i,j) = 1/121;
16
end
17
end
18
mask_b = ones (11 ,11) /121;
19
[m1 ,n1] = size(mask_b);
20
Thr_Freq = 0.2;
21
freqx = fft2d(x); // Fourier
transform
of
input
image
22
freqh = fft2d(h);// Fourier
transform
of
degradation
23
y = real(ifft2d(freqh .* freqx))+25* rand(M,N, ’ normal ’ )
;
24
freqy = fft2d(y);
25
psf=zeros(M,N);
26
psf(M/2+1 -(m1 -1) /2:M/2+1+(m1 -1)/2,N/2+1 -(n1 -1) /2:N
/2+1+(n1 -1) /2) = mask_b;
27
psf = fftshift(psf);
28
freq_res = fft2d(psf);
29
Inv_filt = freq_res ./(( abs(freq_res)).^2+ Thr_Freq);
30
z = real(ifft2d(freqy .* Inv_filt));
31
x = uint8(x);
32
y = uint8(y);
33
z = uint8(z)
34
ShowImage(x, ’ O r i g i n a l
Image ’ )
35
title( ’ O r i g i n a l
Image ’ )
36
figure
37
ShowImage(y, ’ Degraded+n o i s e
Image ’ )
38
title( ’ Degraded+n o i s e
Image ’ )
39
figure
40
ShowImage(z, ’ Restored
Image ’ )
41
title( ’ Restored
Image ’ )
check Appendix AP 1 for dependency:
51

52

fft2d.sce
check Appendix AP 2 for dependency:
ifft2d.sce
Scilab code Exa 6.13 Scilab code to perform wiener filtering of the corrupted imag
1
// Caption :
S c i l a b
code
to
perform
wiener
f i l t e r i n g
of
the
corrupted
image
2
// Fig6 .13
3
// Page 339
4
close;
5
clc;
6
x = imread( ’E: \DIP JAYARAMAN\ Chapter6 \ f l o w e r 2 . jpg ’ );
//SIVP toolbox
7
x=double(rgb2gray(x));
8
sigma = 50;
9
Gamma = 1;
10
alpha = 1; //
I t
i n d i c a t e s
Wiener
f i l t e r
11
[M N]= size(x);
12
h = zeros(M,N);
13
for i = 1:5
14
for j = 1:5
15
h(i,j) = 1/25;
16
end
17
end
18
Freqa = fft2d(x);
19
Freqh = fft2d(h);
20
y = real(ifft2d(Freqh .* Freqa)) // image
degradation
21
y = y+25* rand(M,N,” normal ”); // Adding random
n o i s e
with
normal
d i s t r i b u t i o n
22
Freqy = fft2d(y);
23
Powy = abs(Freqy).^2/(M*N);
24
sFreqh = Freqh .*( abs(Freqh) >0)+1/ Gamma *(abs(Freqh)
==0);
53

25
iFreqh = 1/ sFreqh;
26
iFreqh = iFreqh ’.*( abs(Freqh)*Gamma >1)+Gamma*abs(
sFreqh)*iFreqh *(abs(sFreqh)*Gamma <=1);
27
iFreqh = iFreqh /(max(max(abs(iFreqh))));
28
Powy = Powy .*(Powy >sigma ^2)+sigma ^2*( Powy <= sigma ^2);
29
Freqg = iFreqh .*(Powy -sigma ^2) ./(Powy -(1- alpha)*
sigma ^2);
30
ResFreqa = Freqg .* Freqy;
31
Resa = real(ifft2d(ResFreqa));
32
x = uint8(x);
33
y = uint8(y);
34
Resa = uint8(Resa);
35
ShowImage(x, ’ O r i g i n a l
Image ’ )
36
title( ’ O r i g i n a l
Image ’ )
37
figure
38
ShowImage(y, ’ Degraded Image ’ )
39
title( ’ Degraded Image ’ )
40
figure
41
ShowImage(Resa , ’ Restored
Image ’ )
42
title( ’ Restored
Image ’ )
Scilab code Exa 6.18 Scilab code to Perform Average Filtering operation
1
// Caption : S c i l a b
code
to
Perform
Average
F i l t e r i n g
o p e r a t i o n
2
// Fig6 .18
3
// page
349
4
clc;
5
close;
6
a= imread( ’E: \DIP JAYARAMAN\ Chapter6 \ lenna . jpg ’ );//
SIVP toolbox
7
a=imnoise(a, ’ s a l t & pepper ’ , 0.2); //Add
s a l t&pepper
n o i s e
tothe
image
54

55

8
a=double(a);
9
[m n]= size(a);
10
N=input( ’ e n t e r
the
window
s i z e= ’ ); //The window
s i z e
can be 3x3 , 5 x5etc
11
Start =(N+1) /2;
12
Out_Imag=a;
13
for i=Start :(m-Start +1)
14
for j=Start :(n-Start +1)
15
limit =(N-1) /2;
16
Sum =0;
17
for k=-limit:limit ,
18
for l=-limit:limit ,
19
Sum=Sum+a(i+k,j+l);
20
end
21
end
22
Out_Imag(i,j)=Sum/(N*N);
23
end
24
end
25
a = uint8(a);
26
Out_Imag = uint8(Out_Imag);
27
ShowImage(a, ’ o r i g i n a l
Image ’ )
28
title( ’ Noisy
Image ’ )
29
figure
30
ShowImage(Out_Imag , ’ average
f i l t e r e d
Image ’ )
31
title( ’ 5x5
average
f i l t e r e d
Image ’ );
Scilab code Exa 6.21 Scilab code to Perform median filtering
1
// Caption : S c i l a b
code
to
Perform
median
f i l t e r i n g
2
// Fig6 .21
3
// page
352
4
clc;
5
close;
56

Figure 6.7: Scilab code to Perform Average Filtering operation
6
c = imread( ’E: \DIP JAYARAMAN\ Chapter6 \cameraman . jpg ’
);//SIVP toolbox
7
N = input( ’ Enter
the
window
s i z e ’ );
8
a = double(imnoise(c, ’ s a l t & pepper ’ ,0.2));
9
[m,n] = size(a);
10
b = a;
11
if(modulo(N,2) ==1)
12
Start = (N+1) /2;
13
End = Start;
14
limit1 = (N-1) /2;
15
limit2 = limit1;
16
else
17
Start = N/2;
18
End = Start +1;
19
limit1 = (N/2) -1;
20
limit2 = limit1 +1;
21
end
22
for i = Start :(m-End +1)
23
for j = Start :(n-End +1)
24
I =1;
25
for k = -limit1:limit2
26
for l = -limit1:limit2
27
mat(I)= a(i+k,j+1)
28
I = I+1;
29
end
57

30
end
31
mat = gsort(mat);
32
if(modulo(N,2) ==1)
33
b(i,j) = (mat (((N^2) +1) /2));
34
else
35
b(i,j) = (mat((N^2) /2)+mat (((N^2) /2) +1))/2;
36
end
37
end
38
end
39
a = uint8(a);
40
b = uint8(b);
41
figure
42
ShowImage(c, ’ O r i g i n a l
Image ’ )
43
title( ’ O r i g i n a l
Image ’ )
44
figure
45
ShowImage(a, ’ noisy
image ’ )
46
title( ’ noisy
image ’ )
47
figure
48
ShowImage(b, ’ Median
F i l t e r e d
Image ’ )
49
title( ’ 5x5 Median
F i l t e r e d
Image ’ )
check Appendix AP 3 for dependency:
Func_medianall.sci
Scilab code Exa 6.23 Scilab code to Perform median filtering of colour image
1
// Caption : S c i l a b
code
to
Perform
median
f i l t e r i n g
of
c o l o u r
image
2
// Fig6 . 2 3 ( a )
3
// page
353
4
clc;
5
close;
58

Figure 6.8: Scilab code to Perform median ﬁltering
6
a=imread( ’E: \DIP JAYARAMAN\ Chapter6 \ peppers . png ’ );
//SIVP toolbox
7
N=input( ’ e n t e r
the
window
s i z e ’ );
8
b=imresize(a ,[256 ,256]);
9
b=imnoise(b, ’ s a l t & pepper ’ ,.1);
10
[m n]= size(b);
11
R=b(:,:,1);
12
G=b(:,:,2);
13
B=b(:,:,3);
14
Out_R=Func_medianall(R,N);// Applying
Median
f i l t e r
to
R
plane
15
Out_G=Func_medianall(G,N);// Applying
Median
f i l t e r
to
G
plane
16
Out_B=Func_medianall(B,N);// Applying
Median
f i l t e r
to
B
plane
17
Out_Image (:,:,1)=Out_R;
18
Out_Image (:,:,2)=Out_G;
19
Out_Image (:,:,3)=Out_B;
59

Figure 6.9: Scilab code to Perform median ﬁltering of colour image
20
b = uint8(b);
21
Out_Image = uint8(Out_Image);
22
// ShowColorImage (b , ’ n o i s e
added ’ )
23
// t i t l e ( ’ n o i s e
added ’ )
24
figure
25
ShowColorImage(Out_Image , ’ 3x3 median
f i l t e r e d ’ )
26
title( ’ 3x3 median
f i l t e r e d ’ )
Scilab code Exa 6.24 Scilab code to Perform Trimmed Average Filter
1
// Caption : S c i l a b
code
to
Perform Trimmed Average
F i l t e r
2
// Alpha trimmed
average
f i l t e r
3
// Fig6 .24
4
// page
355
5
clc;
6
close;
60

7
c = imread( ’E: \DIP JAYARAMAN\ Chapter6 \ lenna . jpg ’ );//
SIVP toolbox
8
s = 1; // s
denotes
the
number
of
v a l u e s
to
be
l e f t
in
the
end
9
r = 1;
10
N = 9; //3x3 window
11
a = double(imnoise(c, ’ gaussian ’ ));
12
[m,n] = size(a);
13
b = zeros(m,n);
14
for i= 2:m-1
15
for j = 2:n-1
16
mat = [a(i,j),a(i,j-1),a(i,j+1),a(i-1,j),a(i
+1,j),a(i-1,j-1) ,...
17
a(i-1,j+1),a(i-1,j+1),a(i+1,j+1)];
18
sorted_mat = gsort(mat);
19
Sum =0;
20
for k=r+s:(N-s)
21
Sum = Sum+mat(k);
22
end
23
b(i,j)= Sum/(N-r-s);
24
end
25
end
26
a = uint8(a);
27
b = uint8(b);
28
// f i g u r e
29
// imshow ( c )
30
// t i t l e ( ’ O r i g i n a l
Image ’ )
31
figure
32
ShowImage(a, ’ noisy
image ’ )
33
title( ’ noisy
image ’ )
34
figure
35
ShowImage(b, ’ Trimmed Average
F i l t e r e d
Image ’ )
36
title( ’ Trimmed Average
F i l t e r e d
Image ’ )
61

Figure 6.10: Scilab code to Perform Trimmed Average Filter
62

Chapter 7
Image Segmentation
Scilab code Exa 7.23 Scilab code for Differentiation of Gaussian function
1
// Caption :
S c i l a b
code
f o r
D i f f e r e n t i a t i o n
of
Gaussian
f u n c t i o n
2
// Fig7 .23
3
// page388
4
clc;
5
close;
6
sigma=input( ’ Enter
the
value
of
sigma : ’ )
7
i= -10:.1:10;
8
j= -10:.1:10;
9
r=sqrt(i.*i+j.*j);
10
y=(1/( sigma ^2))*(((r.*r)/sigma ^2) -1).*exp(-r.*r/2*
sigma ^2);
11
plot(i,y)
12
legend(sprintf( ’ The sigma
value
i s %g ’ ,sigma))
13
xtitle( ’ D i f f e r e n t i a t i o n
of
Gaussian
f u n c t i o n ’ )
63

Figure 7.1: Scilab code for Diﬀerentiation of Gaussian function
64

Figure 7.2: Scilab code for Diﬀerentiation of Gaussian function
65

Figure 7.3: Scilab code for Diﬀerentiation of Gaussian Filter function
Scilab code Exa 7.25 Scilab code for Differentiation of Gaussian Filter function
1
// Caption :
S c i l a b
code
f o r
D i f f e r e n t i a t i o n
of
Gaussian
F i l t e r
f u n c t i o n
2
// Fig7 .25
3
// page389
4
clc;
5
close;
6
sigma1 = input( ’ Enter
the
value
of
sigma1 : ’ )
7
sigma2 = input( ’ Enter
the
value
of
sigma2 : ’ )
8
i= -10:.1:10;
9
j= -10:.1:10;
10
r=sqrt(i.*i+j.*j);
66

Figure 7.4: Scilab code for Diﬀerentiation of Gaussian Filter function
11
y1 = (1/( sigma1 ^2))*(((r.*r)/sigma1 ^2) -1).*exp(-r.*r
/2* sigma1 ^2);
12
y2 = (1/( sigma2 ^2))*(((r.*r)/sigma2 ^2) -1).*exp(-r.*r
/2* sigma2 ^2);
13
y = y1 -y2;
14
plot(i,y)
15
xtitle( ’ Shape
of DOG F i l t e r ’ )
16
// Result
17
// Enter
the
value
of
sigma1 :
4
18
// Enter
the
value
of
sigma2 :
1
19
//
67

Scilab code Exa 7.27 Scilab code for Edge Detection using Different Edge detectors
1
// Caption :
S c i l a b
code
f o r
Edge
Detection
using
D i f f e r e n t
Edge
d e t e c t o r s
2
// [ 1 ] .
Sobel
[ 2 ] . Prewitt
[ 3 ] . Log
[ 4 ] . Canny
3
// Fig7 .27
4
// page389
5
close;
6
clc;
7
a = imread( ’E: \DIP JAYARAMAN\ Chapter7 \ s a i l i n g . jpg ’ );
8
a = rgb2gray(a);
9
c = edge(a, ’ s o b e l ’ );
10
d = edge(a, ’ p r e w i t t ’ );
11
e = edge(a, ’ log ’ );
12
f = edge(a, ’ canny ’ );
13
ShowImage(a, ’ O r i g i n a l
Image ’ )
14
title( ’ O r i g i n a l
Image ’ )
15
figure
16
ShowImage(c, ’ Sobel ’ )
17
title( ’ Sobel ’ )
18
figure
19
ShowImage(d, ’ Prewitt ’ )
20
title( ’ Prewitt ’ )
21
figure
22
ShowImage(e, ’ Log ’ )
23
title( ’ Log ’ )
24
figure
25
ShowImage(f, ’ Canny ’ )
26
title( ’ Canny ’ )
Scilab code Exa 7.30 Scilab code to perform watershed transform
68

Figure 7.5: Scilab code for Edge Detection using Diﬀerent Edge detectors
69

1
// Caption :
S c i l a b
code
to
perform
watershed
transform
2
// Fig7 .30
3
// Page396
4
clc;
5
close;
6
b = imread( ’E: \DIP JAYARAMAN\ Chapter7 \ t e a s e t . png ’ );
7
a = rgb2gray(b);
8
global EDGE_SOBEL;
9
Gradient = EdgeFilter(a, EDGE_SOBEL);
10
Threshold1 = CalculateOtsuThreshold(Gradient); //
determine
a
t h r e s h o l d
11
EdgeImage = ~SegmentByThreshold(Gradient ,Threshold1)
;
12
DistanceImage = DistanceTransform(EdgeImage);
13
Threshold2 = CalculateOtsuThreshold(DistanceImage)
//
determine
a
t h r e s h o l d
14
ThresholdImage = SegmentByThreshold(DistanceImage ,
Threshold2);
15
MarkerImage = SearchBlobs(ThresholdImage);
16
SegmentedImage = Watershed(Gradient ,MarkerImage);
17
figure
18
ShowColorImage(b, ’ t e a s e t ’ )
19
title( ’ t e a s e t . png ’ )
20
figure
21
ColorMapLength = length(unique(SegmentedImage));
22
ShowImage(SegmentedImage , ’ Result
of
Watershed
Transform ’ ,jetcolormap(ColorMapLength));
70

Figure 7.6: Scilab code to perform watershed transform
71

Chapter 8
Object Recognition
Scilab code Exa 8.4 To verify the given matrix is a covaraince matrix
1
// Caption :
To
v e r i f y
the
given
matrix
i s
a
c o v a r a i n c e
matrix
2
// Problem 4
3
// page438
4
close;
5
clear;
6
clc;
7
K = [37 , -15; -15 ,37];
8
evals = spec(K);
9
evals = gsort(evals);
10
disp(evals , ’ Eigen
Values
are = ’ )
11
if (evals ==abs(evals)) then
12
disp( ’ Both
the
e i g e n
v a l u e s
are
non−n e g a t i v e
and
the
given
matrix
i s
a
c o v a r i a n c e
matrix ’ );
13
else
14
disp( ’ non−c o v a r i a n c e
matrix ’ )
15
end
Scilab code Exa 8.5 To compute the covariance of the given 2D data
72

1
// Caption :
To compute
the
c o v a r i a n c e
of
the
given
2D
data
2
// Problem 5
3
// page439
4
close;
5
clear;
6
clc;
7
X1 = [2,1]’;
8
X2 = [3,2]’;
9
X3 = [2,3]’;
10
X4 = [1,2]’;
11
X = [X1 ,X2 ,X3 ,X4];
12
disp(X, ’X= ’ );
13
[M,N] = size(X); //M=rows , N = columns
14
for i =1:N
15
m(i) = mean(X(:,i));
16
A(:,i) = X(:,i)-m(i);
17
end
18
m = m’;
19
disp(m, ’ mean = ’ );
20
K = A’*A;
21
K = K/(M-1);
22
disp(K, ’ The Covaraince
matix
i s K = ’ )
23
// Result
24
//X=
25
//
2 .
3 .
2 .
1 .
26
//
1 .
2 .
3 .
2 .
27
//mean =
28
//
1. 5
2 .5
2.5
1. 5
29
//
30
//The Covaraince
matix
i s K =
31
//
0. 5
0 .5
−0. 5
−0. 5
32
//
0. 5
0 .5
−0. 5
−0. 5
33
//
−0. 5
−0. 5
0 .5
0.5
34
//
−0. 5
−0. 5
0 .5
0.5
73

Scilab code Exa 8.9 Develop a perceptron AND function with bipolar inputs and targ
1
// Caption :
Develop a
perceptron AND f u n c t i o n
with
b i p o l a r
inputs
and
t a r g e t s
2
// Problem 9
3
// page441
4
close;
5
clear;
6
clc;
7
X1 = [1,-1,1,-1]; //X1 and X2 are
input
v e c t o r s
to
AND f u n c t i o n
8
X2 = [1,1,-1,-1];
9
//b = [ 1 , 1 , 1 , 1 ] ;
// Biasing
v e c t o r
10
T = [1,-1,-1,-1]; // Target
v e c t o r
f o r AND f u n c t i o n
11
W1 = 0; // Weights
are
i n i t i a l i z e d
12
W2 = 0;
13
b = 0;
// b i a s
i n i t i a l i z e d
14
alpha = 1; // l e a r n i n g
r a t e
15
for i = 1: length(X1)
16
Yin(i) = b+X1(i)*W1+X2(i)*W2;
17
if (Yin(i) >=1)
18
Y(i)=1;
19
elseif ((Yin(i) <1)&(Yin(i) >=-1))
20
Y(i)=0;
21
elseif(Yin(i) <-1)
22
Y(i)=-1;
23
end
24
disp(Yin(i), ’ Yin= ’ )
25
disp(Y(i), ’Y= ’ )
26
if(Y(i)~=T(i))
27
b = b+alpha*T(i);
28
W1 = W1+alpha*T(i)*X1(i);
29
W2 = W2+alpha*T(i)*X2(i);
30
disp(b, ’ b= ’ )
74

31
disp(W1 , ’W1= ’ )
32
disp(W2 , ’W2= ’ )
33
end
34
end
35
disp( ’ Final
Weights
a f t e r
one
i t e r a t i o n
are ’ )
36
disp(b, ’ Bias
Weigth b= ’ )
37
disp(W1 , ’W1= ’ )
38
disp(W2 , ’W2= ’ )
75

Chapter 9
Image Compression
Scilab code Exa 9.9 Program performs Block Truncation Coding BTC
1
// Caption :
Program
performs
Block
Truncation
Coding (
BTC)
2
// Example
9. 9
3
// page512
4
close;
5
clear;
6
clc;
7
x =
[65 ,75 ,80 ,70;72 ,75 ,82 ,68;84 ,72 ,62 ,65;66 ,68 ,72 ,80];
8
disp(x, ’ O r i g i n a l
Block
i s
x = ’ )
9
[m1 n1]= size(x);
10
blk=input( ’ Enter
the
block
s i z e : ’ );
11
for i = 1 : blk : m1
12
for j = 1 : blk : n1
13
y = x(i:i+(blk -1),j:j+(blk -1)) ;
14
m = mean(mean(y));
15
disp(m, ’ mean value
i s m = ’ )
16
sig=std2(y);
17
disp(sig , ’ Standard
d e v i a t i o n
of
the
block
i s
= ’ )
76

18
b = y > m ; // the
binary
block
19
disp(b, ’ Binary
a l l o c a t i o n
matrix
i s B= ’ )
20
K = sum(sum(b));
21
disp(K, ’ number
of
ones = ’ )
22
if (K ~= blk^2 ) & ( K ~= 0)
23
ml = m-sig*sqrt(K/(( blk ^2)-K));
24
disp(ml , ’ The value
of
a = ’ )
25
mu = m+sig*sqrt ((( blk ^2)-K)/K);
26
disp(mu , ’ The value
of
b = ’ )
27
x(i:i+(blk -1), j:j+(blk -1)) = b*mu
+(1- b)*ml;
28
end
29
end
30
end
31
disp(round(x), ’ Reconstructed
Block
i s
x = ’ )
32
// Result
33
// O r i g i n a l
Block
i s
x =
34
//
35
//
65 .
7 5.
80.
70 .
36
//
72 .
7 5.
82.
68 .
37
//
84 .
7 2.
62.
65 .
38
//
66 .
6 8.
72.
80 .
39
//
40
// Enter
the
block
s i z e : 4
41
//mean value
i s m =
72.25
42
// Standard
d e v i a t i o n
of
the
block
i s =
6.6282225
43
// Binary
a l l o c a t i o n
matrix
i s B=
44
//
45
//
F T T F
46
//
F T T F
47
//
T F F F
48
//
F F F T
49
//
50
//number
of
ones =
6
51
//The value
of
a =
67.115801
52
//The value
of
b =
80.806998
53
// Reconstructed
Block
i s
x =
54
//
77

55
//
67 .
8 1.
81.
67.
56
//
67 .
8 1.
81.
67.
57
//
81 .
6 7.
67.
67.
58
//
67 .
6 7.
67.
81.
Scilab code Exa 9.59 Program performs Block Truncation Coding
1
// Caption :
Program
performs
Block
Truncation
Coding (
BTC) by
choosing
d i f f e r e n t
2
// block
s i z e s
3
// Fig . 9 . 5 9 : MATLAB Example1
4
// page514
5
close;
6
clc;
7
x =imread( ’E: \ Digital Image Processing Jayaraman \
Chapter9 \ lenna . jpg ’ );
//SIVP toolbox
8
//x=i m r e s i z e ( x , [ 2 5 6
2 5 6 ] ) ;
9
x1=x;
10
x=double(x);
11
[m1 n1]= size(x);
12
blk=input( ’ Enter
the
block
s i z e : ’ );
13
for i = 1 : blk : m1
14
for j = 1 : blk : n1
15
y = x(i:i+(blk -1),j:j+(blk -1)) ;
16
m = mean(mean(y));
17
sig=std2(y);
18
b = y > m ; // the
binary
block
19
K = sum(sum(b));
20
if (K ~= blk^2 ) & ( K ~= 0)
21
ml = m-sig*sqrt(K/(( blk ^2)-K));
22
mu = m+sig*sqrt ((( blk ^2)-K)/K);
23
x(i:i+(blk -1), j:j+(blk -1)) = b*mu
+(1- b)*ml;
24
end
25
end
78

Figure 9.1: Program performs Block Truncation Coding
26
end
27
// imshow ( uint8 ( x ) )
28
// t i t l e ( ’ Reconstructed
Image ’ )
29
x = uint8(x);
30
figure (1)
31
imshow(x1)
32
title( ’ O r i g i n a l
Image ’ );
//IPD toolbox
33
figure (2)
34
ShowImage(x,
’ Reconstructed
Image ’ );
//IPD toolbox
35
title( ’ Block
S i z e = 8 ’ )
79

Chapter 10
Binary Image Processing
Scilab code Exa 10.17 Scilab Code for dilation and erosion process
1
// Caption :
S c i l a b
Code
f o r
d i l a t i o n
and
e r o s i o n
p r o c e s s
2
// Fig . 1 0 . 1 7
3
// Page553
4
close;
5
clear;
6
clc;
7
a = imread( ’E: \DIP JAYARAMAN\ Chapter10 \morph1 . bmp ’ );
//SIVP toolbox
8
//b
= [ 1 , 1 , 1 ; 1 , 1 , 1 ; 1 , 1 , 1 ] ;
9
StructureElement = CreateStructureElement( ’ square ’ ,
3) ;
10
a1 = DilateImage(a,StructureElement);
11
a2 = ErodeImage(a,StructureElement);
12
// Displaying
o r i g i n a l
Image
13
// imshow ( a )
14
figure (1)
15
ShowImage(a, ’ O r i g i n a l
Image ’ );
16
// Displaying
Dilated
Image
17
// imshow ( a1 )
18
figure (2)
80

Figure 10.1: Scilab Code for dilation and erosion process
19
ShowImage(a1 , ’ Dilated
Image ’ );
20
xtitle( ’ Dilated
Image ’ )
21
// Displaying
Eroded Image
22
// imshow ( a2 )
23
figure (3)
24
ShowImage(a2 , ’ Eroded Image ’ );
25
xtitle( ’ Eroded Image ’ )
Scilab code Exa 10.19 Scilab Code to perform an opening and closing operation on t
1
// Caption :
S c i l a b
Code to
perform
an
opening
and
c l o s i n g
o p e r a t i o n
on
the
image
2
// Fig . 1 0 . 1 9
3
// Page555
4
close;
5
clear;
6
clc;
7
a = imread( ’E: \DIP JAYARAMAN\ Chapter10 \morph2 . bmp ’ );
//SIVP toolbox
81

8
//b
= [ 1 , 1 , 1 ; 1 , 1 , 1 ; 1 , 1 , 1 ] ;
9
StructureElement = CreateStructureElement( ’ square ’ ,
3) ;
10
// Opening
i s
done by
f i r s t
applying
e r o s i o n
and then
d i l a t i o n
o p e r a t i o n s
on image
11
b1 = ErodeImage(a,StructureElement);
12
b2 = DilateImage(b1 ,StructureElement);
13
// Closing
i s
done by
f i r s t
applying
d i l a t i o n
and
then
e r o s i o n
o p e r a t i o n
on image
14
a1 = DilateImage(a,StructureElement);
15
a2 = ErodeImage(a1 ,StructureElement);
16
// Displaying
o r i g i n a l
Image
17
figure (1)
18
ShowImage(a, ’ O r i g i n a l
Image ’ );
19
// Displaying
Opened Image
20
figure (2)
21
ShowImage(b2 ,
’ Opened Image ’ );
22
xtitle( ’ Opened Image ’ )
23
// Displaying
Closed
Image
24
figure (3)
25
ShowImage(a2 ,
’ Closed
Image ’ );
26
xtitle( ’ Closed
Image ’ )
82

Figure 10.2: Scilab Code to perform an opening and closing operation on the
image
83

Chapter 11
Colur Image Processing
Scilab code Exa 11.4 Read an RGB image and extract the three colour components red
1
// Caption : Read an RGB image and
e x t r a c t
the
t h r e e
c o l o u r
components :
red , green
2
// and
blue
3
// Fig . 1 1 . 4 : MATLAB Example1
4
// page588
5
clc;
6
close;
7
RGB = imread( ’E: \DIP JAYARAMAN\ Chapter11 \ peppers . png
’ );
//SIVP toolbox
8
R = RGB;
9
G = RGB;
10
B = RGB;
11
R(:,:,2)=0;
12
R(:,:,3)=0;
13
G(:,:,1)=0;
14
G(:,:,3)=0;
15
B(:,:,1)=0;
16
B(:,:,2)=0;
17
figure (1)
18
ShowColorImage(RGB ,
’ O r i g i n a l
Color
Image ’ );
//IPD
toolbox
84

19
title( ’ O r i g i n a l
Color
Image ’ );
20
figure (2)
21
ShowColorImage(R,
’ Red Component ’ );
22
figure (3)
23
ShowColorImage(G,
’ Green Component ’ );
24
figure (4)
25
ShowColorImage(B,
’ Blue Component ’ );
Scilab code Exa 11.12 Read a Colour image and separate the colour image into red g
1
// Caption : Read a Colour
image and
s e p a r a t e
the
c o l o u r
image
i n t o :
red , green
2
// and
blue
planes
3
// Fig . 1 1 . 1 2 : MATLAB Example2
4
// page592
5
clc;
6
close;
7
RGB = imread( ’E: \DIP JAYARAMAN\ Chapter11 \ peppers . png
’ );
//SIVP toolbox
8
a1 = RGB;
9
b1 = RGB;
10
c1 = RGB;
11
a1(:,:,1)=0;
12
b1(:,:,2)=0;
13
c1(:,:,3)=0;
14
figure (1)
15
ShowColorImage(RGB ,
’ O r i g i n a l
Color
Image ’ );
//IPD
toolbox
16
figure (2)
17
ShowColorImage(a1 ,
’ Red Missing ’ );
18
figure (3)
19
ShowColorImage(b1 ,
’ Green
Missing ’ );
20
figure (4)
85

Figure 11.1: Read an RGB image and extract the three colour components
red green blue
86

21
ShowColorImage(c1 ,
’ Blue
Missing ’ );
Scilab code Exa 11.16 Compute the histogram of the colour image
1
// Caption : Compute the
histogram
of
the
c o l o u r
image
2
// Fig . 1 1 . 1 6 : MATLAB Example3
3
// page595
4
clc;
5
close;
6
I = imread( ’E: \DIP JAYARAMAN\ Chapter11 \ lavender . jpg ’
);
//SIVP toolbox
7
figure (1)
8
ShowColorImage(I,
’ O r i g i n a l
Color
Image ’ );
//IPD
toolbox
9
J = im2double(I);
10
[index ,map] = RGB2Ind(I); //IPD toolbox
11
pixels = prod(size(index));
12
hsv = rgb2hsv(J);
13
h = hsv (:,1);
14
s = hsv (:,2);
15
v = hsv (:,3);
16
// Finds
l o c a t i o n
of
black
and
white
p i x e l s
17
darks = find(v <0.2);
18
lights = find(s <0.05 & v >0.85);
19
h([ darks lights ])=-1;
20
// Gets
the
number
of
a l l
p i x e l s
f o r
each
c o l o u r
bin
21
black_pixels = length(darks)/pixels;
22
white_pixels = length(lights)/pixels;
23
red = length(find ((h > .9167 | h <= .083) & h ~=
-1)
)/pixels;
24
yellow = length(find(h > .083 & h <= .25))/pixels;
25
green = length(find(h > .25 & h <= .4167))/pixels;
26
cyan = length(find(h > .4167 & h <= .5833))/pixels;
87

Figure 11.2: Read a Colour image and separate the colour image into red
green and blue planes
88

27
blue = length(find(h > .5833 & h <= .75))/pixels;
28
magenta = length(find(h > .75 & h <= .9167))/pixels;
29
// Plots
histogram
30
figure (2)
31
a=gca();
32
a.data_bounds =[0 ,0;8 ,1]
33
n = 0:0.1:1;
34
plot2d2(n,red*ones(1,length(n)) ,5)
35
n1 = 1:0.1:2;
36
plot2d2(n1 ,yellow*ones(1,length(n)) ,7)
37
n2 = 2:0.1:3;
38
plot2d2(n2 ,green*ones(1,length(n)) ,8)
39
n3 = 3:0.1:4;
40
plot2d2(n3 ,cyan*ones(1,length(n)) ,9)
41
n4 = 4:0.1:5;
42
plot2d2(n4 ,blue*ones(1,length(n)) ,2)
43
n5 = 5:0.1:6;
44
plot2d2(n5 ,magenta*ones(1,length(n)) ,3)
45
n6 = 6:0.1:7;
46
plot2d2(n6 ,white_pixels*ones(1,length(n)) ,0)
47
n7 = 7:0.1:8
48
plot2d2(n7 ,black_pixels*ones(1,length(n)) ,5)
Scilab code Exa 11.18 Perform histogram equalisation of the given RGB image
1
// Caption : Perform
histogram
e q u a l i s a t i o n
of
the
given RGB image
2
// Fig . 1 1 . 1 8 : MATLAB Example4
3
// page596
4
clc;
5
close;
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter11 \ peppers . png ’ )
;
//SIVP toolbox
7
// c o n v e r s i o n
of RGB to YIQ format
8
b = rgb2ntsc(a);
89

9
// Histogram
e q u a l i s a t i o n
of Y component
alone
10
b(:,:,1) =
11
// c o n v e r s i o n
of YIQ to RGB format
12
c = ntsc2rgb(b);
13
figure (1)
14
ShowColorImage(a,
’ O r i g i n a l
Image ’ );
//IPD toolbox
15
figure (2)
16
ShowColorImage(c,
’ Histogtram
e q u a l i z e d
Image ’ );
//IPD toolbox
Scilab code Exa 11.21 This program performs median filtering of the colour image
1
// Caption : This
program
performs
median
f i l t e r i n g
of
the
c o l o u r
image
2
// Fig . 1 1 . 2 1 : MATLAB Example5
3
// page598
4
clc;
5
close;
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter11 \ peppers . png ’ )
;
//SIVP toolbox
7
b = imnoise(a,
’ s a l t & pepper ’ , 0.2);
8
c(:,:,1)= MedianFilter(b(:,:,1), [3 3]);
9
c(:,:,2)= MedianFilter(b(:,:,2), [3 3]);
10
c(:,:,3)= MedianFilter(b(:,:,3), [3 3]);
11
figure (1)
12
ShowColorImage(a,
’ O r i g i n a l
Image ’ );
//IPD toolbox
13
figure (2)
14
ShowColorImage(b,
’ corrupted
Image ’ );
//IPD
toolbox
15
figure (3)
16
ShowColorImage(c,
’ Median
F i l t e r e d
Image ’ );
//IPD
toolbox
90

Figure 11.3: This program performs median ﬁltering of the colour image
91

Scilab code Exa 11.24 Fitlering only the luminance component
1
// Caption : F i t l e r i n g
only
the
luminance
component
2
// Fig . 1 1 . 2 4 : MATLAB Example6
3
// page599
4
clc;
5
close;
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter11 \ peppers . png ’ )
;
//SIVP toolbox
7
// c o n v e r s i o n
of RGB to YIQ format
8
yiq = rgb2ntsc(a);
9
// Extract
the Y component
alone
10
b = yiq(:,:,1);
11
h = [-1,-1,-1;-1,8,-1;-1,-1,-1];
12
// Perform
high
pass
f i l t e r i n g
only
on Y component
13
c1 = conv2d2(b,h);
14
[m,n]= size(b);
15
for i =1:m
16
for j=1:n
17
D(i,j)= c1(i,j);
18
end
19
end
20
yiq(:,:,1)=D;
21
// convert YIQ to RGB format
22
a1 = ntsc2rgb(yiq);
23
figure (1)
24
ShowColorImage(a,
’ O r i g i n a l
Image ’ );
//IPD toolbox
25
figure (2)
26
ShowColorImage(a1 ,
’ High
Pass
f i l t e r e d
Image ’ );
//
IPD toolbox
92

Figure 11.4: Fitlering only the luminance component
Scilab code Exa 11.28 Perform gamma correction for the given colour image
1
// Caption : Perform gamma c o r r e c t i o n
f o r
the
given
c o l o u r
image
2
// Fig . 1 1 . 2 8 : MATLAB Example7
3
// page603
4
close;
5
clear;
6
clc;
7
I = imread( ’E: \DIP JAYARAMAN\ Chapter11 \ ararauna . png ’
);
//SIVP toolbox
8
gamma_Value = 0.5;
9
max_intensity = 255; // f o r
uint8
image
10
// Look up
t a b l e
c r e a t i o n
11
LUT = max_intensity .*(([0: max_intensity ]./
max_intensity).^ gamma_Value);
12
LUT = floor(LUT);
13
// Mapping
of
input
p i x e l s
i n t o
lookup
t a b l e
v a l u e s
14
K = double(I)+1;
93

Figure 11.5: Perform gamma correction for the given colour image
15
J = zeros(I);
16
[m,n,p]= size(K);
17
for i = 1:m
18
for j =1:n
19
for k = 1:p
20
J(i,j,k)= LUT(K(i,j,k));
21
end
22
end
23
end
24
figure (1)
25
ShowColorImage(I,
’ O r i g i n a l
Image ’ );
//IPD toolbox
26
figure (2)
27
ShowColorImage(uint8(J),
’Gamma Corrected
Image ’ );
//IPD toolbox
Scilab code Exa 11.30 Perform Pseudo Colouring Operation
1
// Caption : Perform
Pseudo−Colouring
Operation
2
// Fig . 1 1 . 3 0
3
// page604
94

4
close;
5
clear;
6
clc;
7
K = imread( ’E: \DIP JAYARAMAN\ Chapter11 \ lenna . jpg ’ );
//SIVP toolbox
8
[m,n]= size(K);
9
I = uint8(K);
10
for i = 1:m
11
for j =1:n
12
if (I(i,j) >=0 & I(i,j) <50)
13
J(i,j,1)=I(i,j)+50;
14
J(i,j,2)=I(i,j)+100;
15
J(i,j,3)=I(i,j)+10;
16
elseif (I(i,j) >=50 & I(i,j) <100)
17
J(i,j,1)=I(i,j)+35;
18
J(i,j,2)=I(i,j)+128;
19
J(i,j,3)=I(i,j)+10;
20
elseif(I(i,j) >=100 & I(i,j) <150)
21
J(i,j,1)=I(i,j)+152;
22
J(i,j,2)=I(i,j)+130;
23
J(i,j,3)=I(i,j)+15;
24
elseif(I(i,j) >=150 & I(i,j) <200)
25
J(i,j,1)=I(i,j)+50;
26
J(i,j,2)=I(i,j)+140;
27
J(i,j,3)=I(i,j)+25;
28
elseif(I(i,j) >=200 & I(i,j) <=256)
29
J(i,j,1)=I(i,j)+120;
30
J(i,j,2)=I(i,j)+160;
31
J(i,j,3)=I(i,j)+45;
32
end
33
end
34
end
35
figure (1)
36
ShowImage(K,
’ O r i g i n a l
Image ’ );
//IPD toolbox
37
figure (2)
38
ShowColorImage(J,
’ Pseudo
Coloured
Image ’ );
//IPD
toolbox
95

Figure 11.6: Perform Pseudo Colouring Operation
Scilab code Exa 11.32 Read an RGB image and segment it using the threshold method
1
// Caption : Read an RGB image and segment
i t
using
the
t h r e s h o l d
method
2
// Fig11 .32
3
// Page605
4
close;
5
clc;
6
I = imread( ’E: \DIP JAYARAMAN\ Chapter11 \ ararauna . png ’
);
//SIVP toolbox
7
// Conversion
of RGB to YCbCr
8
b = rgb2ycbcr_1(I); //SIVP toolbox
9
[m,n,p]= size(b);
10
b = uint8(b);
11
// Threshold
i s
a p p l i e d
only
to Cb component
12
mask = b(:,:,2) >120;
13
figure (1)
96

Figure 11.7: Read an RGB image and segment it using the threshold method
14
ShowColorImage(I, ’ O r i g i n a l
Image ’ );
//IPD toolbox
15
figure (2)
16
ShowImage(mask ,
’ Segmented Image ’ );
//IPD toolbox
97

Chapter 12
Wavelet based Image
Processing
Scilab code Exa 12.9 Scilab code to perform wavelet decomposition
1
// Caption :
S c i l a b
code
to
perform
wavelet
decomposition
2
// Fig12 .10
3
// Page624
4
clc;
5
close;
6
x = ReadImage( ’E: \DIP JAYARAMAN\ Chapter12 \ lenna . jpg ’
);
7
//The image
in
unsigned
i n t e g e r
or
double
has
to
be
converted
i n t o
normalized
8
// double
format
9
x = im2double(x);
10
// F i r s t
Level
decomposition
11
[CA ,CH ,CV ,CD]= dwt2(x, ’ db1 ’ );
12
// Second
l e v e l
decomposition
13
[CA1 ,CH1 ,CV1 ,CD1]= dwt2(CA , ’ db1 ’ );
14
CA = im2int8(CA);
15
CH = im2int8(CH);
16
CV = im2int8(CV);
98

17
CD = im2int8(CD);
18
CA1 = im2int8(CA1);
19
CH1 = im2int8(CH1);
20
CV1 = im2int8(CV1);
21
CD1 = im2int8(CD1);
22
A = [CA ,CH;CV ,CD];
23
B = [CA1 ,CH1;CV1 ,CD1];
24
imshow(B)
25
title( ’ Result
of
Second
Level
Decomposition ’ )
Scilab code Exa 12.42 Scilab code to generate different levels of a Gaussian pyram
1
// Caption :
S c i l a b
code
to
generate
d i f f e r e n t
l e v e l s
of
a Gaussian
pyramid
2
// Fig12 .42
3
// Page651
4
clc;
5
close;
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter12 \ apple3 . bmp ’ );
7
a = rgb2gray(a);
8
b = a;
9
kernelsize = input( ’ Enter
the
s i z e
of
the
k e r n e l : ’ );
10
sd = input( ’ Enter
the
standard
d e v i a t i o n
of
hte
Gaussian window : ’ );
11
rf = input( ’ Enter
the
Reduction
Factor : ’ );
12
// Routine
to
generate
Gaussian
k e r n e l
13
k = zeros(kernelsize , kernelsize);
14
[m n] = size(b);
15
t = 0;
16
for i = 1: kernelsize
17
for j=1: kernelsize
18
k(i,j) = exp(-((i-kernelsize /2) .^2+(j-
kernelsize /2) .^2) /(2* sd .^2))/(2* %pi*sd
.^2);
19
t = t+k(i,j);
99

20
end
21
end
22
for i = 1: kernelsize
23
for j = 1: kernelsize
24
k(i,j) = k(i,j)/t;
25
end
26
end
27
for t = 1:1: rf
28
// convolve
i t
with
the
p i c t u r e
29
FilteredImg = b;
30
if t==1
31
FilteredImg = filter2(k,b)/255;
32
else
33
FilteredImg = filter2(k,b);
34
end;
35
// compute
the
s i z e
of
the
reduced
image
36
m = m/2;
37
n = n/2;
38
// c r e a t e
the
reduced
image
through
sampling
39
b = zeros(m,n);
40
for i = 1:m
41
for j = 1:n
42
b(i,j) = FilteredImg(i*2,j*2);
43
end;
44
end;
45
end;
46
figure
47
ShowImage(a, ’ O r i g i n a l
Image ’ )
48
figure
49
ShowImage(b, ’ D i f f e r e n t
Levels
of
Gausain
Pyramid ’ )
50
title( ’ D i f f e r e n t
Levels
of
Gausain
Pyramid
Level
2 ’ )
Scilab code Exa 12.57 Scilab code to implement watermarking in spatial domain
100

Figure 12.1: Scilab code to generate diﬀerent levels of a Gaussian pyramid
101

1
// Caption :
S c i l a b
code
to
implement
watermarking
in
s p a t i a l
domain
2
// Fig12 .57
3
// Page662
4
clc
5
close
6
a = imread( ’E: \DIP JAYARAMAN\ Chapter12 \cameraman . jpg
’ );
7
figure
8
imshow(a)
9
title( ’ Base Image ’ );
10
b = imread( ’E: \DIP JAYARAMAN\ Chapter12 \ keyimage . jpg ’
);
11
b = rgb2gray(b);
12
b = imresize(b ,[32 32], ’ b i c u b i c ’ );
13
[m1 n1]= size(b);
14
figure
15
imshow(b)
16
title( ’ Mark Image ’ );
17
[m n]= size(a);
18
i1 = 1;
19
j1 = 1;
20
p = 1;
21
c = a;
22
iii = 1;
23
jjj = 1;
24
a = uint8(a);
25
b = uint8(b);
26
for ff = 1:8
27
for i = 1:32
28
jjj = 1;
29
for j = j1:j1+n1 -1
30
a(i,j) = bitand(a(i,j),uint8 (254)); //
LSB of
base
image
i s
s e t
to
zero .
31
temp = bitand(b(i,jjj),uint8 ((2^ff) -1));
//MSB of
the mark
i s
e x t r a c t e d .
32
temp = temp /((2^ ff) -1);
33
c(i,j) = bitor(a(i,j),uint8(temp));//MSB
102

Figure 12.2: Scilab code to implement watermarking in spatial domain
of
mark
i s
i n e r t e d
i n t o
the %LSB of
the
base
34
jjj = jjj +1;
35
end
36
end
37
j1 = j1 +32;
38
end
39
imshow(c)
40
title( ’ Marked Image ’ );
41
imwrite(c, ’E: \DIP JAYARAMAN\ Chapter12 \markimg . jpg ’ );
Scilab code Exa 12.63 Scilab code to implement wavelet based watermarking
1
// Caption :
S c i l a b
code
to
implement
wavelet −based
watermarking
2
// Fig12 .63
3
// Page666
4
clc;
5
close;
103

6
// O r i g i n a l
Image
7
img = imread( ’E: \DIP JAYARAMAN\ Chapter12 \cameraman .
jpg ’ );
8
figure
9
imshow(img)
10
title( ’ O r i g i n a l
Image ’ );
11
[p q] = size(img);
12
// Generate
the
key
13
// key = imread ( ’E: \DIP JAYARAMAN\ Chapter12 \ keyimg1 .
png ’ ) ;
14
// key = i m r e s i z e ( key , [ p q ] ) ;
15
key = imread( ’E: \DIP JAYARAMAN\ Chapter12 \ keyimage .
jpg ’ );
16
key = rgb2gray(key);
17
c = 0.001; // I n i t i a l i s e
the
weight
of
Watermarking
18
figure
19
imshow(key)
20
title( ’Key ’ );
21
// Wavelet
transform
of
o r i g i n a l
image
( base
image )
22
img = double(img);
23
key = double(key);
24
[ca ,ch ,cv ,cd] = dwt2(img , ’ db1 ’ );//Compute 2D wavelet
transform
25
// Perform
the
watermarking
26
y = [ca ch;cv cd];
27
Y = y + c*key;
28
p=p/2;
29
q=q/2;
30
for i=1:p
31
for j=1:q
32
nca(i,j) = Y(i,j);
33
ncv(i,j) = Y(i+p,j);
34
nch(i,j) = Y(i,j+q);
35
ncd(i,j) =
Y (i+p,j+q);
36
end
37
end
38
// Display
the
Watermarked image
39
wimg = idwt2(nca ,nch ,ncv ,ncd , ’ db1 ’ );
104

40
wimg1 = uint8(wimg);
41
figure
42
imshow(wimg1)
43
title( ’ Watermarked Image ’ )
44
// Extraction
of
key
from Watermarked image
45
[rca ,rch ,rcv ,rcd] = dwt2(wimg , ’ db1 ’ ); //Compute 2D
wavelet
transform
46
n1=[rca ,rch;rcv ,rcd];
47
N1=n1 -y;
48
N1 = N1*4;
49
N1 = im2int8(N1);
50
figure
51
imshow(N1)
52
title( ’ Extract
the
key
from
watermarked
image ’ )
105

Appendix
Scilab code AP 1 2D Fast Fourier Transform
1
function [a2] = fft2d(a)
2
//a = any
r e a l
or
complex 2D matrix
3
// a2 = 2D−DFT of
2D matrix
’ a ’
4
m=size(a,1)
5
n=size(a,2)
6
//
f o u r i e r
transform
along
the
rows
7
for i=1:n
8
a1(:,i)=exp(-2*%i*%pi *(0:m-1) ’.*.(0:m-1)/m)*a(:,i)
9
end
10
//
f o u r i e r
transform
along
the
columns
11
for j=1:m
12
a2temp=exp(-2*%i*%pi *(0:n-1) ’.*.(0:n-1)/n)*(a1(j,:))
.’
13
a2(j,:)=a2temp.’
14
end
15
for i = 1:m
16
for j = 1:n
17
if((abs(real(a2(i,j))) <0.0001) &(abs(imag(a2(
i,j))) <0.0001))
18
a2(i,j)=0;
19
elseif(abs(real(a2(i,j))) <0.0001)
20
a2(i,j)= 0+%i*imag(a2(i,j));
21
elseif(abs(imag(a2(i,j))) <0.0001)
22
a2(i,j)= real(a2(i,j))+0;
23
end
24
end
106

25
end
Scilab code AP 2 2D Inverse FFT
1
function [a] =ifft2d(a2)
2
// a2 = 2D−DFT of
any
r e a l
or
complex 2D matrix
3
//a = 2D−IDFT of
a2
4
m=size(a2 ,1)
5
n=size(a2 ,2)
6
// I n v e r s e
Fourier
transform
along
the
rows
7
for i=1:n
8
a1(:,i)=exp (2*%i*%pi *(0:m-1) ’.*.(0:m-1)/m)*a2(:,i)
9
end
10
// I n v e r s e
f o u r i e r
transform
along
the
columns
11
for j=1:m
12
atemp=exp (2*%i*%pi *(0:n-1) ’.*.(0:n-1)/n)*(a1(j,:)).’
13
a(j,:)=atemp.’
14
end
15
a = a/(m*n)
16
a = real(a)
17
endfunction
Scilab code AP 3 Median Filtering function
1
//The input
to
the
f u n c t i o n
are
the
corrupted
image
a
and
the
dimension
2
function [Out_Imag] = Func_medianall(a,N)
3
a=double(a);
4
[m n]= size(a);
5
Out_Imag=a;
6
if(modulo(N,2) ==1)
7
Start =(N+1) /2;
8
End=Start;
9
else
10
Start=N/2;
11
End=Start +1;
12
end
13
if(modulo(N,2) ==1)
107

14
limit1 =(N-1) /2;
15
limit2=limit1;
16
else
17
limit1 =(N/2) -1;
18
limit2=limit1 +1;
19
end
20
for i=Start :(m-End +1),
21
for j=Start :(n-End +1),
22
I=1;
23
for k=-limit1:limit2 ,
24
for l=-limit1:limit2 ,
25
mat(I)=a(i+k,j+l);
26
I=I+1;
27
end
28
end
29
mat=gsort(mat);
// Sort
the
elements
to
f i n d
the
median
30
if(modulo(N,2) ==1)
31
Out_Imag(i,j)=(mat (((N^2) +1) /2));
32
else
33
Out_Imag(i,j)=(mat((N^2) /2)+mat (((N^2) /2)
+1))/2;
34
end
35
end
36
end
Scilab code AP 4 To caculate gray level
1
function [g] = gray(m)
2
g = (0:m-1) ’/max(m-1,1)
3
g = [g g g]
4
endfunction
Scilab code AP 5 To change the gray level of gray image
1
function [bout] = grayslice(I,z)
2
108

3
// Output
v a r i a b l e s
i n i t i a l i s a t i o n
( not
found
in
input
v a r i a b l e s )
4
bout =[];
5
6
// Number
of
arguments
in
f u n c t i o n
c a l l
7
[%nargout ,%nargin] = argn (0)
8
9
if %nargin ==1 then
10
z = 10;
11
elseif ~type(z)==1 then
12
z = double(z);
13
end;
14
n = z;
15
if typeof(I)==” uint8 ” then
16
z = (255*(0:n-1))/n;
17
elseif isa(I,
’ uint16 ’ ) | isa(I,
’ i n t 1 6 ’ ) then
18
z = 65535*(0:(n-1))/n;
19
else //
I
i s
double
or
s i n g l e
20
z = (0:(n-1))/n
21
end;
22
[m,n] = size(I);
23
b = zeros(m,n);
24
// Loop
over
a l l
i n t e r v a l s ,
except
the
l a s t
25
for i = 1: length(z) -1
26
//
j
i s
the
index
value we
w i l l
output ,
so
i t
depend upon
s t o r a g e
c l a s s
27
if typeof(b)== ’ uint8 ’
28
j = i-1;
29
else
30
j = i;
31
end
32
d = find(I>=z(i) & I<z(i+1));
33
if ~isempty(d),
34
b(d) = j;
35
end
36
end
37
38
// Take
care
of
that
l a s t
i n t e r v a l
109

39
d = find(I >= z($));
40
if ~isempty(d) then
41
//
j
i s
the
index
value we
w i l l
output ,
so
i t
depend upon
s t o r a g e
c l a s s
42
if typeof(b)==” uint8 ” then
43
j = length(z) -1;
44
else
45
j = length(z);
46
end;
47
b(d) = j;
48
end;
49
bout = b;
50
bout = double(bout);
51
endfunction
110

