A Dynamic Topological Sort Algorithm for
Directed Acyclic Graphs
DAVID J. PEARCE
Victoria University of Wellington
and
PAUL H. J. KELLY
Imperial College London
We consider the problem of maintaining the topological order of a directed acyclic graph (DAG) in
the presence of edge insertions and deletions. We present a new algorithm and, although this has
inferior time complexity compared with the best previously known result, we ﬁnd that its simplicity
leads to better performance in practice. In addition, we provide an empirical comparison against
the three main alternatives over a large number of random DAGs. The results show our algorithm
is the best for sparse digraphs and only a constant factor slower than the best on dense digraphs.
Categories and Subject Descriptors: E.1 [Data Structures]: Graphs and Networks; F.2.2 [Analysis
of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems—Compu-
tations on discrete structures; G.2.2 [Discrete Mathematics]: Graph Theory—Graph algorithms
General Terms: Algorithms, Experimentation, Theory
Additional Key Words and Phrases: Dynamic graph algorithms, topological sort
1. INTRODUCTION
A topological ordering, ordD, of a directed acyclic graph D = (V, E) maps each
vertex to a priority value such that ordD(x) < ordD( y) holds for all edges
This work was supported by the UK Engineering and Physical Sciences Research Council (EPSRC)
through a PhD studentship and grant number GR/R15566.
A preliminary version of this paper was presented at the 3rd International Workshop on Efﬁcient
and Experimental Algorithms (WEA04), 2004. This work includes a more detailed analysis of algo-
rithms for the dynamic topological order problem and an improved experimental study. We must
also report that, since the WEA04 workshop, an error in our implementation of algorithm AHRSZ
was found. As a result, the performance data reported for AHRSZ in this paper differs from that
shown in the workshop paper.
Authors’ Addresses: David J. Pearce, School of Mathematics, Statistics and Computer Science,
Victoria University of Wellington, Wellington, New Zealand; email: david.pearce@mcs.vuw.ac.nz;
Paul H.J. Kelly, Department of Computing, 180 Queen’s Gate, South Kensington Campus, Imperial
College London, SW7 2AZ, United Kingdom; email: p.kelly@imperial.ac.uk.
Permission to make digital or hard copies of part or all of this work for personal or classroom use is
granted without fee provided that copies are not made or distributed for proﬁt or direct commercial
advantage and that copies show this notice on the ﬁrst page or initial screen of a display along
with the full citation. Copyrights for components of this work owned by others than ACM must be
honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers,
to redistribute to lists, or to use any component of this work in other works requires prior speciﬁc
permission and/or a fee. Permissions may be requested from Publications Dept., ACM, Inc., 2 Penn
Plaza, Suite 701, New York, NY 10121-0701 USA, fax +1 (212) 869-0481, or permissions@acm.org.
C
⃝2006 ACM 1084-6654/06/0001-ART1.7 $5.00
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006, Pages 1–24.

2
•
D. J. Pearce and P. H. J. Kelly
x →y ∈E. There exist well-known linear time algorithms for computing the
topological order of a DAG (e.g., Cormen et al. [2001]). However, these solutions
are considered static as they compute the solution from scratch.
In this paper, we examine efﬁcient algorithms for updating the topological
order of a DAG after some graph change (e.g., edge insertion); we refer to this
as the dynamic topological order (DTO) problem. We say that an algorithm
is fully dynamic if it supports both edge insertions and deletions. A partially
dynamic algorithm is termed incremental/decremental if it supports only edge
insertions/deletions. Furthermore, an algorithm is described as unit change if
it offers no advantage to processing updates in batches rather than one at a
time. The main contributions of this paper are as follows:
1. A new fully dynamic, unit change algorithm for maintaining the topological
order of a directed acyclic graph.
2. The ﬁrst experimental study of algorithms for this problem. We compare
against two previous algorithms [Marchetti–Spaccamela et al. 1996; Alpern
et al. 1990] and a simple, asymptotically optimal static solution.
We show that, while our algorithm has inferior time complexity compared with
[Alpern et al. 1990], its simplicity leads to better overall performance, in prac-
tice. We also ﬁnd that our algorithm is signiﬁcantly more efﬁcient than that
of Marchetti–Spaccamela et al. on sparse digraphs and only a constant factor
slower on dense digraphs.
The rest of this paper is organized as follows: Section 2 covers necessary back-
ground material; Section 3 begins with the presentation of our new algorithm,
followed by a detailed discussion of the two main previous solutions [Marchetti–
Spaccamela et al. 1996; Alpern et al. 1990]; Section 4 reports on experiments
comparing the performance of the three algorithms and the standard (i.e.,
static) solution using randomly generated digraphs; Section 5 covers related
work; ﬁnally, we summarize our ﬁndings and discuss future work in Section 6.
2. BACKGROUND
At this point, it is necessary to clarify some notation used throughout the re-
mainder of the paper. In the following we assume D = (V, E) is a digraph:
Deﬁnition 2.1.
We say that x reaches a vertex y, written x ; y, if x = y or
x →y ∈E or ∃z.[x →z ∈E ∧z ; y]. We also say that y is reachable from x.
Deﬁnition 2.2.
The set of outedges for a vertex set, S ⊆V , is deﬁned as
E+(S) = {x →y | x →y ∈E ∧x ∈S}. The set of inedges, E−(S) is deﬁned
analogously and the set of all edges is E(S) = E+(S) ∪E−(S).
Deﬁnition 2.3.
The extended size of a set of vertices, K ⊆V , is denoted
∥K ∥= |K | + |E(K )|. This deﬁnition originates from Alpern et al. [1990].
For the standard (i.e., static) topological sorting problem, algorithms with
(∥V ∥) (i.e., (v+e)) time are well known (e.g., Cormen et al. [2001]). However,
the problem of dynamically maintaining a topological ordering appears to have
received little attention. A trivial solution, based upon a standard (i.e., static)
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
3
Fig. 1.
Algorithm STO, a simple solution to the DTO problem, where ord is implemented as an
array of size |V |.
topological sort, is shown in Figure 1. Note that we generally omit the D from
ordD when it is clear from the context. This algorithm implements ord using an
array of size |V |, which maps each vertex to a unique integer from {1 . . . |V |}.
Thus, ord is a total and contiguous ordering of vertices. The idea is to perform
a full topological sort only when an edge x →y is inserted, which breaks the
ordering (i.e., when ord( y) < ord(x)). Therefore, STO traverses the entire graph
for one-half of all possible edge insertions and, for a single edge insertion, has a
lower and upper bound on its time complexity of (1) and O(∥V ∥), respectively.
An important observation is that edge deletions are trivial, since they cannot
invalidate the ordering.
In practice, STO performs poorly unless the batch size is sufﬁciently large
and several works have attempted to improve upon it [Alpern et al. 1990;
Marchetti–Spaccamela et al. 1996; Hoover 1987; Zhou and M¨uller 2003;
Ramalingam and Reps 1994]. Of these, only two are of interest, since they
provide the key results in this ﬁeld. Henceforth, they are referred to as AHRSZ
[Alpern et al. 1990] and MNR [Marchetti–Spaccamela et al. 1996]. We exam-
ine these algorithms in some detail later on, but, ﬁrst, we consider the known
results on their time complexity. MNR has been shown to require O(ve) time
to process any sequence of (e) edge insertions [Marchetti–Spaccamela et al.
1996]. One difﬁculty with this result is that it does not tell us whether the al-
gorithm is (in any sense) optimal. To that end, the work of Alpern et al. is more
enlightening as they used an alternative mechanism for theoretically evalu-
ating their algorithm. Their approach was to develop a complexity parameter
capturing the minimal amount of work needed to update a topological order:
Deﬁnition 2.4.
Let D = (V, E) be a directed acyclic graph and ord a valid
topological order. For an edge insertion, x →y, the set K of vertices is a cover
if ∀a, b ∈V.[a ; b ∧ord(b) < ord(a) ⇒a ∈K ∨b ∈K ].
This states that, for any a and b connected by some path, which are incor-
rectly prioritized, a cover K must include a or b or both. We say a cover is min-
imal, written Kmin, if it is not larger than any valid cover. Thus, Kmin captures
the least number of vertices any algorithm must reorder to obtain a solution.
Alpern et al. recognized it that is difﬁcult to do this without traversing edges ad-
jacent to those being reordered. They used a variation on this parameter, which
we call K ∗
min, where ∥K ∗
min∥≤∥K ∥for any valid cover K . Therefore, ∥K ∗
min∥cap-
tures the minimal amount of work required, assuming adjacent edges must be
traversed. It remains an open problem as to whether this assumption is true
of all algorithms for this problem. Certainly, it holds for those being studied
here.1 Algorithm AHRSZ obtains an O(∥K ∗
min∥log ∥K ∗
min∥) bound on the time
1Strictly speaking, only if a reﬁned notion of extended size (see Deﬁnition 2.8) is used.
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

4
•
D. J. Pearce and P. H. J. Kelly
required for a single edge insertion. In contrast, we show in Section 3.2 that
MNR is not bounded by ∥K ∗
min∥and, thus, that it has inferior time-complexity.
2.1 The Complexity Parameter δxy
In the above, we introduced the complexity parameter ∥K ∗
min∥as a measure of
the least work an algorithm must perform to update an invalidated topological
order. Unfortunately, the time complexity for most of the algorithms examined
in this paper cannot be expressed in terms of ∥K ∗
min∥. Therefore, we must use
an alternative to evaluate and understand them:
Deﬁnition 2.5.
Let D = (V, E) be a directed acyclic graph and ord a valid
topological order. For an edge insertion x →y, the affected region is denoted
ARxy and deﬁned as {k ∈V | ord( y) ≤ord(k) ≤ord(x)}.
Deﬁnition 2.6.
Let D = (V, E) be a directed acyclic graph and ord a valid
topological order. For an edge insertion x →y, the set δxy is deﬁned as δF
xy ∪δB
xy,
where δF
xy = {k ∈ARxy | y ; k} and δB
xy = {k ∈ARxy | k ; x}.
Notice that, δxy = ∅only when x and y are already correctly prioritized (i.e.,
when ord(x) < ord( y)). Also, it is fairly easy to see that no member of δF
xy reaches
any in δB
xy, since this would introduce a cycle. To understand δxy better, it is useful
to consider its meaning in a graphical manner:
Here, vertices are laid out in topological order (i.e., increasing in ord value)
from left to right and the gaps may contain vertices, which we have omitted
to simplify the presentation. The edge x →y invalidates the topological order
(i.e., it has just been inserted) and is referred to as an invalidating edge, since
ord( y) < ord(x). Thus, δxy = { y, a, b, c, x}, since it must include all those vertices
in the affected region, which reach x or are reachable from y. One feature
common to all the algorithms we will consider is that they only reorder vertices
within the affected region. This is possible because, for any edge v →w where
v /∈ARxy and w ∈ARxy, we can reposition w anywhere within the affected region
without breaking the invariant ord(v) < ord(w). A similar argument holds when
v ∈ARxy and w /∈ARxy. Another interesting property is the following:
LEMMA 2.7.
Let D = (V, E) be a directed acyclic graph and ord a valid
topological order. For an edge insertion x →y, it holds that Kmin ⊆δxy.
PROOF.
Suppose this were not the case. Then there must be a vertex v ∈
Kmin, where v /∈δxy. By Deﬁnition 2.4, v is incorrectly prioritized with respect
to some vertex w. Thus, either w ; v or v ; w. Consider the case when w ; v
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
5
and, hence, ord(v) < ord(w). Since ord is valid for all edges except x →y, any
path from w to v must cross x →y. Therefore, y ; v and w ; x and we have
v ∈ARxy as ord( y) ≤ord(v) ≤ord(w) ≤ord(x). A contradiction follows as, by
Deﬁnition 2.6, v ∈δxy. The case when v ; w is similar.
In fact, Kmin = δxy only when both are empty. Now, ∥K ∗
min∥≤∥Kmin∥≤∥δxy∥
and, hence, we know ∥δxy∥is not strictly a measure of minimal work for the
DTO problem. Finally, it turns out that a reﬁnement on the notion of extended
size is actually more useful when comparing algorithms for the DTO problem:
Deﬁnition 2.8.
Let D = (V, E) be a directed acyclic graph and ord a valid
topological order. For some set K ⊆V , let the extended-out size be ∥K ∥+ =
|K | + |E+(K )| and the extended-in size be ∥K ∥−= |K | + |E−(K )|. Then, for an
invalidating edge insertion x →y, the total search cost is ⟨⟨K ⟩⟩= ∥K F∥+ +
∥K B∥−, where K F = {z ∈K | y ; z} and K B = {z ∈K | z ; x}
Intuitively, the difference between ∥K ∥and ⟨⟨K ⟩⟩is that the former assumes
all edges adjacent to a vertex must be iterated, while the latter assumes only
inedges or outedges (not both) need to be. This makes sense as the set of vertices
to reorder can always be found by searching forward from y and backward from
x. Furthermore, a forward (backward) search does not traverse the inedges
(outedges) of those visited. Finally, in what follows, we often reuse the term
K ∗
min to represent a cover where ⟨⟨K ∗
min⟩⟩≤⟨⟨K ⟩⟩holds for any valid cover K .
While this usage is slightly ambiguous, since a set K which minimizes ⟨⟨K ⟩⟩
does not necessarily minimize ∥K ∥, our meaning should always be clear from
the context.
3. ALGORITHMS FOR THE DYNAMIC TOPOLOGICAL ORDER PROBLEM
In this section, we begin by presenting our new algorithm for the dynamic
topological order problem. We then examine in detail the two main existing
solutions and contrast them with our development.
3.1 Algorithm PK
Algorithm PK is our new solution to the DTO problem. As we will see in the
coming sections, this is similar in design to MNR, but achieves a time complexity
bounded by ⟨⟨δxy⟩⟩(resulting in better performance on sparse graphs). While this
still remains inferior to that of AHRSZ, our claim is that its simplicity makes
it more efﬁcient in practice. Like all the algorithms under consideration, PK is
a unit change algorithm operating on directed acyclic graphs.
The topological ordering, ord, is implemented as a total and contiguous or-
dering using an array of size |V |. This maps each vertex to a unique integer
in {1 . . . |V |}, such that for any edge x →y, ord(x) < ord( y) always holds. The
main observation behind this algorithm is that we can obtain a correct ordering
by simply reorganizing vertices in δxy. That is, in the new ordering, ord′, vertices
in δxy are repositioned to ensure a valid topological ordering, using only posi-
tions previously held by members of δxy. All other vertices remain unaffected.
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

6
•
D. J. Pearce and P. H. J. Kelly
For example:
As before, vertices are laid out in topological order from left to right. Only
members of δxy are shown and, as ord is total and contiguous, the gaps must
contain vertices omitted to simplify the presentation. Thus, δF
xy = { y, a, c} and
δB
xy = {b, x} and we obtain a correct ordering by repositioning vertices to ensure
all of δB
xy are left of δF
xy:
In doing this, the original (relative) order of vertices in δF
xy must be preserved
and likewise for δB
xy. This ensures the following invariant, where ord′ is the new
ordering being computed, is maintained:
∀x ∈δF
xy.[ord(x) ≤ord′(x)] ∧∀y ∈δB
xy.[ord′( y) ≤ord( y)]
The above states that members of δF
xy cannot be given lower priorities than
they already have, while those in δB
xy cannot get higher ones. This is because,
for any vertex in δF
xy, we have identiﬁed all in the affected region that must
be higher than it (i.e., right of it). However, we have not determined all those
which must come lower and, hence, cannot safely move them in this direction. A
similar argument holds for δB
xy. Thus, we begin to see how the algorithm works:
it ﬁrst identiﬁes δB
xy and δF
xy. Then, it pools the indices occupied by their vertices
and, starting with the lowest, allocates increasing indices ﬁrst to members of δB
xy
and then δF
xy. Thus, in the above example, the algorithm proceeds by allocating
b the lowest available index, like so:
After this, it will allocate x to the next lowest index, then y and so on. The
algorithm is presented in Figure 2 and the following summarizes the two stages:
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
7
Fig. 2.
The PK algorithm. The “sort” function sorts an array such that x comes before y iff ord[x] <
ord[ y]. “merge” combines two arrays into one while maintaining sortedness (i.e., merge sort). Cycles
need only be checked for in dfs-f(), since an invalidating edge x →y can only give rise to a cycle if
y reaches x (and dfs-f() will establish this).
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

8
•
D. J. Pearce and P. H. J. Kelly
3.1.1
Discovery.
The set δxy is identiﬁed using a forward depth-ﬁrst search
from y and a backward depth-ﬁrst search from x. Vertices outside the affected
region are not explored. Those visited by the forward and backward search are
placed into δF
xy and δB
xy, respectively. Thus, (⟨⟨δxy⟩⟩) time is needed for this stage.
Observe that cycles need only be checked for during the forward search, since
an invalidating edge x →y can only give rise to a cycle if y reaches x (and the
forward search will establish this).
3.1.2
Reassignment.
The two sets are now sorted separately into increas-
ing topological order (i.e., according to ord), which we assume takes (δxy log δxy)
time. We then load δB
xy into array L followed by δF
xy. In addition, the pool of avail-
able indices, R, is constructed by merging indices used by elements of δB
xy and
δF
xy together. Finally, we allocate by giving index R[i] to vertex L[i]. This whole
procedure takes (δxy log δxy) time.
Therefore, algorithm PK has time-complexity ((δxy log δxy) + ⟨⟨δxy⟩⟩). Finally,
we provide the correctness proof of algorithm PK:
LEMMA 3.1.
Assume D = (V, E) is a DAG and ord an array, mapping ver-
tices to unique values in {1 . . . |V |}, which is a valid topological order. If an
inserted invalidating edge, x →y, does not introduce a cycle, then algorithm
PK obtains a correct topological ordering.
PROOF.
Let ord′ be the new ordering found by the algorithm. To show this
is a correct topological order, we must show, for any two vertices a, b where
a →b, that ord′(a) < ord′(b) holds. An important fact to remember is that the
algorithm only uses indices of those in δxy for allocation. Therefore, z ∈δxy ⇒
ord( y) ≤ord′(z) ≤ord(x). There are six cases to consider:
1. a, b /∈ARxy. Here neither a nor b have been moved as they lie outside the
affected region. Thus, ord(a) = ord′(a) and ord(b) = ord′(b), which (by defn
of ord) implies ord′(a) < ord′(b).
2. (a ∈ARxy∧b /∈ARxy)∨(a /∈ARxy∧b ∈ARxy). When a ∈ARxy we know ord(a) ≤
ord(x) < ord(b). If a ∈δxy then ord′(a) ≤ord(x). Otherwise, ord′(a) = ord(a).
A similar argument holds when b ∈ARxy.
3. a, b ∈ARxy ∧a, b /∈δxy. Similar to case 1 as neither a or b have been moved.
4. a, b ∈δxy∧x ; a∧x ̸= a. Here, a is reachable from x only along x →y, which
means y ; a ∧y ; b. Thus, a, b ∈δF
xy and their relative order is preserved in
ord′ by sorting.
5. a, b ∈δxy ∧b ; y ∧y ̸= b. Here, b reaches y along x →y, so b ; x and a ; x.
Therefore, a, b ∈δB
xy and their relative order is preserved in ord′ by sorting.
6. x = a ∧y = b. Here, we have a ∈δB
xy ∧b ∈δF
xy and ord′(a) < ord′(b) follows,
because all elements of δB
xy are allocated lower indices than those of δF
xy.
3.2 The MNR Algorithm
The algorithm of Marchetti-Spaccamela et al. also implements ord as a total,
contiguous ordering of vertices using an array of size |V |. As with PK, this maps
each vertex to a (unique) integer in {1 . . . |V |}. In addition, a second array ord−1
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
9
of size |V | is used, which is the reverse of ord—it maps each index in the order to
the corresponding vertex. Hence, both ord−1(ord(x)) = x and ord(ord−1(i)) = i
always hold. The algorithm itself is quite similar to PK except that only δF
xy,
rather than all of δxy, is identiﬁed (using a forward depth-ﬁrst search). Thus,
for the example used, previously only y, a, c would be visited:
To obtain a correct solution the algorithm shifts vertices in δF
xy up the order
so that they hold the highest positions within the affected region. For the above
example, this gives the following (valid) ordering:
Notice that these vertices always end up alongside x and that, unlike PK,
each vertex in the affected region receives a new position. This has achieved a
similar effect to PK, as every vertex in δB
xy now has a lower index than any in
δF
xy. Pseudocode for the algorithm is presented in Figure 3. The time needed for
the DFS (discovery) phase is (∥δF
xy∥+). The reassignment phase (i.e., procedure
shift) requires (ARxy) time as each element of ARxy is visited. Therefore, we
obtain an (∥δF
xy∥+ + ARxy) bound on the time for a single-edge insertion. Note,
only an amortized result was given by Marchetti-Spaccamela et al. and we feel
this new result provides better insight into MNR’s performance (see Section 3.4
for more on this topic).
3.3 The AHRSZ Algorithm
The algorithm of Alpern et al. [1990] employs a special data structure because
of Dietz and Sleator to implement a priority space [Dietz and Sleator 1987;
Bender et al. 2002]. This permits new priorities to be created between existing
ones in O(1) worse-case time. A side effect of using it is that AHRSZ maintains
a partial ordering of vertices (unlike PK and MNR, which must maintain a
total ordering). Thus, the topological ordering, ord, is implemented as an array
of size |V |, mapping vertices to priority values. Like the others, this algorithm
operates in two stages: discovery and reassignment. We now examine these
(assuming x →y is an invalidating edge):
3.3.1
Discovery.
The set of vertices, K , to be reprioritized is determined by
simultaneously searching forward from y and backward from x. During this,
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

10
•
D. J. Pearce and P. H. J. Kelly
Fig. 3.
The MNR algorithm.
vertices queued for visitation by the forward (backward) search are said to be
on the forward (backward) frontier. At each step, the algorithm extends the
frontiers toward each other. The forward (backward) frontier is extended by
visiting a member with the lowest (largest) priority. The following diagrams
aim to clarify this:
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
11
In the above, members of the forward/backward frontiers are marked with
a dot. Initially, each frontier consists of a single starting vertex, determined by
the invalidating edge. The algorithm proceeds by extending each frontier:
Here we see that the forward frontier has been extended by visiting y and this
results in a, e being added and y removed. In the next step, a will be visited as
it has the lowest priority of any on the frontier. Likewise, the backward frontier
has been extended by visiting x and, next time, b will be visited as it has the
largest priority. Thus, we see that the two frontiers are moving toward each
other and the search stops either when one frontier is empty or they “meet”—
when each vertex on the forward frontier has a priority greater than any on the
backward frontier. The set of vertices, K , to be reprioritized contains exactly
those visited before this happens. We refer to this procedure as lock-step search,
since both frontiers move in unison.
LEMMA 3.2.
Let D = (V, E) be a directed acyclic graph and ord a valid
topological order. For an invalidating edge insertion x →y, the set K ⊆V
found by lock-step search is a cover.
PROOF.
Assume it is not. By Deﬁnition 2.4, some a, b /∈K exist where
a ; b ∧ord(a) ≥ord(b). Partition K into K + = {z ∈K | y ; z} and K −= {z ∈
K | z ; x}. Let FF = {w | ∃v ∈K + ∧v →w} and BF = {v | ∃w ∈K −∧v →w}.
Now, ∀v ∈FF, w ∈BF.[ord(v) > ord(w)] as the search stops only when this
holds. This implies ∀v ∈(δF
xy −K +), w ∈(δB
xy −K −).[ord(v) > ord(w)], as ord
is valid for all edges except x →y. The contradiction follows as, by a similar
argument to that of Lemma 2.7, b ∈(δF
xy −K +) and a ∈(δB
xy −K −).
LEMMA 3.3.
Let D = (V, E) be a directed acyclic graph, ord a valid topolog-
ical order, and x →y an invalidating edge insertion. The set K ⊆V found by
lock-step search contains O(Kmin) vertices.
PROOF.
Partition K into K + = {z ∈K | y ; z} and K −= {z ∈K | z ; x}. The
lock-step search guarantees |K +| = |K −| (since both frontiers extend simul-
taneously) and ∀v ∈K +, w ∈K −.

ord(v) < ord(w)

. Thus, either K + ⊆Kmin
or K −⊆Kmin must hold, as every vertex in K + is incorrectly prioritized with
every vertex in K −. This implies |K +| ≤|Kmin| ≤|K | ≤2.|K +| ≤2.|Kmin|.
Thus, we obtain an O(⟨⟨Kmin⟩⟩log ⟨⟨Kmin⟩⟩) bound on discovery using the lock-
step search. The log factor arises from the use of priority queues to implement
the frontiers, which we assume are heaps. In fact, Alpern et al. use a clever
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

12
•
D. J. Pearce and P. H. J. Kelly
strategy to reduce work further. Consider:
Here, vertex a has high outdegree (which can be imagined as much larger
than shown). Thus, visiting vertex a is expensive as its outedges must be iter-
ated. Instead, we could visit b, c, d in potentially much less time and still up-
date the order correctly. The algorithm described so far cannot do this because
it moves both frontiers in each step. The full AHRSZ algorithm, however, allows
them to move independently to capitalize on situations like the above. Essen-
tially, the frontier whose next vertex has the least number of adjacent edges is
moved at each step. If it is a draw, then both are simultaneously moved. Thus,
in the above, the backward frontier would be repeatedly extended. To ensure
the amount of work done is still strictly bounded by O(∥Kmin∥), a counter C(n)
is maintained for each vertex n. This is initialized by the total number of edges
incident on n (i.e., both inedges and outedges). At each step, min(C( f ), C(b)) is
subtracted from C( f ) and C(b), where f and b are next on the forward and back-
ward frontiers, respectively. Thus, the forward frontier is extended, if C( f ) = 0,
and the backward, if C( y) = 0. Alpern et al. [1990] proved that this ensures
an O(∥K ∗
min∥log ∥K ∗
min∥) bound on the work done in this stage. This can be im-
proved to O(⟨⟨K ∗
min⟩⟩log⟨⟨K ∗
min⟩⟩) by initializing C(n) more appropriately [Katriel
and Bodlaender 2005]. Speciﬁcally, if n is on the forward frontier, then C(n) is
initialized with E+(n), otherwise E−(n) is used.
3.3.2
Reassignment.
The reassignment process also operates in two
stages. The ﬁrst is a depth-ﬁrst search of all vertices in K , which computes
a ceiling on the new priority of each:
ceiling(x) = min({ord( y) | y /∈K ∧x →y}∪
{ceiling( y) | y ∈K ∧x →y} ∪{+∞})
In a similar fashion, the second stage of reassignment computes the ﬂoor using
ord′, the new topological order formed so far:
ﬂoor( y) = max({ord′(x) | x →y} ∪{−∞})
Once the ﬂoor has been computed for a vertex, the algorithm assigns a new
priority, ord′(k), such that floor(k) < ord′(k) < ceiling(k). An important consid-
eration here, is to minimize the number of new priorities created [Alpern et al.
1990]. Otherwise, the underlying Dietz and Sleator ordered list structure may
not achieve peak performance. Alpern et al. pointed out that, if an arbitrary
topological order is used to compute the ﬂoor and priority of each v ∈K , more
priorities may be created than necessary. The following example highlights this,
where members of K are shaded and the (ﬁxed) priorities of nonmembers are
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
13
shown below:
The problem is that more priorities are created if v, rather than w, is re-
assigned ﬁrst. This is because v must be assigned a priority between it’s ﬂoor
ord(s) and it’s ceiling ord(t), reusing existing priorities whenever possible. Thus,
the new assignment must be ord(v) = P2. This implies each of w, x, and y
require a new priority to be created, which is suboptimal, since a valid reas-
signment is possible that creates only two new priorities. To address this, Alpern
et al. use a mechanism similar to breadth-ﬁrst search to ensure vertices with
the same ﬂoor get the same priority. Speciﬁcally, they employ a min-priority
queue with ﬂoor(k) as the priority of each member k. Initially, this contains all
vertices k ∈K with no predecessor in K . The algorithm proceeds by popping
all vertices z with the lowest ﬂoor off the queue and determining the minimum
ceiling, zmin, between them. Each z is then assigned the same priority Pz, where
ﬂoor(z) < Pz < zmin. In doing this, the lowest existing priority is always used
when possible, otherwise a new priority is created. At this point, all remaining
vertices whose predecessors are either not in K or have already been reassigned
are pushed onto the queue. The whole process is repeated until all of K is re-
assigned. For the above example, this procedure creates the minimum number
of new priorities. However, Alpern et al. did not prove that this holds for the
general case, although it seems likely.
Finally, since all edges touching vertices in K must be scanned to generate
the ﬂoor and ceiling information, the time needed for this stage is bounded by
O(∥K ∗
min∥+ K ∗
min log K ∗
min). The log factor arises from the use of a min-priority
queue. In fact, Katriel and Bodlaender [2005] showed that this can be reduced
to O(K ∗
min), using a simpler mechanism. However, this does not minimize the
number of new priorities created and, thus, is expected to perform worse in
practice.
The original bound given by Alpern et al. on the total time needed to process
an edge insertion was O(∥K ∗
min∥log ∥K ∗
min∥) [Alpern et al. 1990; Ramalingam
and Reps 1994]. This gives O(⟨⟨K ∗
min⟩⟩log ⟨⟨K ∗
min⟩⟩) if the improved discovery
algorithm and the simpler approach to reassignment are used. Pseudo-code for
our implementation is provided in Figure 4 and there are a few remarks to
make about it. In particular, the improved discovery algorithm of Katriel and
Bodlaender is used, although their simpler reassignment algorithm is not—
even though it offers lower time complexity. As discussed above, this is because
their approach does not minimize the number of new priorities created and,
hence, is expected to perform poorly in practice [Alpern et al. 1990].
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

14
•
D. J. Pearce and P. H. J. Kelly
Fig. 4.
Algorithm AHRSZ. The forward frontier is represented by ForwFron, and implemented
using a min-priority queue. BackFron is similar, but using a max-priority queue. Notice that
ForwEdges and BackEdges implement the counter C(n) discussed in the text. Finally, Q is im-
plemented using a min-priority queue.
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
15
Finally, there are a few points to make about the Dietz and Sleator [1987]
ordered list structure, which AHRSZ relies on: ﬁrst, it is difﬁcult to implement
and suffers high overheads in practice (both in time and space); secondly, only a
certain number of priorities can be created for a given word size, thus limiting
the maximum number of vertices. For example, only 220 priorities can be created
if 32-bit integers are being used.
3.4 Discussion of Complexity
At this point, it seems prudent to clarify the relative complexity of all three algo-
rithms. Comparing AHRSZ and PK is straightforward. The former is bounded
by ⟨⟨K ∗
min⟩⟩and the latter by ⟨⟨δxy⟩⟩. Since ⟨⟨K ∗
min⟩⟩≤⟨⟨Kmin⟩⟩≤⟨⟨δxy⟩⟩follows from
Lemma 2.7, AHRSZ has a strictly tighter bound on its runtime than PK.
Comparing MNR and PK is more subtle, since neither achieves a strictly
tighter bound than the other. Recall that MNR takes (∥δF
xy∥++ ARxy) time for a
single edge insertion, while PK takes ((δxy log δxy)+⟨⟨δxy⟩⟩) time. Furthermore,
we have that ∥δF
xy∥+ < ⟨⟨δxy⟩⟩and |δxy| ≤|ARxy|. Thus, if |ARxy| is sufﬁciently
greater than ⟨⟨δxy⟩⟩, PK will do less work than MNR (otherwise, the converse is
true). Since this is more likely to be true when inserting into a sparse graph,
we expect PK to perform better than MNR in these conditions (and viceversa
for dense graphs). In practice, however, PK is never much worse than MNR on
dense graphs, while MNR can be signiﬁcantly worse than PK on sparse graphs
(as demonstrated in the next section).
3.5 Discussion of Practicality
The central claim of this paper is that, although algorithm PK has an inferior
worst-case bound on its runtime compared with AHRSZ, its simplicity leads
to greater efﬁciency in practice. The question then, is what it means to be
simpler. At a superﬁcial level, it is quite apparent that the pseudocode of AHRSZ
(Figure 4) is longer than that of PK (Figure 2). Indeed, while PK is presented in
its entirety, all details of the Dietz and Sleator ordered list structure are omitted
from the presentation of AHRSZ. A closer inspection of the two algorithms
reveals the following observations:
1. During discovery, algorithm PK uses a simple traversal algorithm (i.e.,
depth-ﬁrst search) with small overheads; in contrast, AHRSZ uses prior-
ity queues (for the frontiers) to implement the traversal (which will almost
certainly have higher overheads).
2. During reassignment, algorithm PK sorts the set of discovered vertices (i.e.,
δF
xy and δB
xy) and performs two full passes over them to complete reassignment
(note, the merge operation is not counted as, in practice, this is done during
the last pass at little extra cost); in contrast, AHRSZ performs a topological
sort of the discovered set (to compute ceiling information) and then performs
two full passes over this set (both of which require iterating adjacent edges)
to complete reassignment. Again, it is apparent that AHRSZ must do more
work when reassigning a given set of vertices that algorithm PK.
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

16
•
D. J. Pearce and P. H. J. Kelly
3. Algorithm PK uses an array of integer indices to represent the topological
sort, which imposes minimal runtime overhead; AHRSZ, on the other hand,
uses the Dietz and Sleator ordered list structure, some of whose operations
(such as comparing whether one priority is less than another) can be rather
more expensive in practice.
The above gives an informal account of why we believe algorithm PK is simpler
than algorithm AHRSZ. In Section 4, we present experimental data, which
conﬁrms our hypothesis. We ﬁnd that, while the number of vertices discovered
by AHRSZ is often much less than for PK, the performance of AHRSZ is always
worse than PK’s—indicating the higher costs involved in its implementation.
4. EXPERIMENTAL STUDY
In this section, we experimentally compare four algorithms for the DTO prob-
lem: MNR, AHRSZ, PK, and STO (recall Figure 1). The experiments measure
how the average cost per insertion (ACPI) varies with graph density and batch
size, over a large number of randomly generated DAGs.
Deﬁnition 4.1.
For a DAG with v vertices and e edges, deﬁne its density to
be
e
1
2 v(v−1). Thus, it is the ratio of the actual number of edges to the maximum
possible.
Furthermore, in an effort to correlate our theoretical analysis, we also inves-
tigated how ⟨⟨δxy⟩⟩, |ARxy| and ⟨⟨K ⟩⟩, where K is the actual cover computed by
AHRSZ, vary on average with graph density.
4.1 Generating a Random DAG
The standard model for uniformly generating a random undirected graph is
G(v, p), which deﬁnes a graph with v vertices, where each edge is picked with
probability p. Erd¨os and R´enyi [1960] were the ﬁrst to study this random graph
model. They found that, for certain properties such as connectedness, graphs
whose edge count was below a certain threshold were very unlikely to have
the property, while those with just a few more edges were almost certain to
have it. This is known as the phase transition and is a curious and pervasive
phenomenon (see Janson et al. [2000, Chapter 5] for more on this). Several
other random graph models exist, such as one for generating graphs, which
obey a power law [Aiello et al. 2000]. For this work, we are only concerned with
generating uniform random DAGs and the model Gdag(v, p), ﬁrst deﬁned by
Barak and Erd¨os [1984], is used here:
Deﬁnition 4.2.
The model Gdag(v, p) is a probability space containing all
graphs having a vertex set V = {1, 2, . . . , v} and an edge set E ⊆{(i, j) | i < j}.
Each edge of such a graph exists with a probability p independently of the
others.
For a DAG in Gdag(v, p), we know that there are, at most, v(v−1)
2
possible edges.
Thus, we can select uniformly from Gdag(v, p) by enumerating each possible
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
17
Fig. 5.
Our procedure for measuring insertion cost over a random DAG. Note that, through careful
implementation, we have minimized the cost of the other operations in the loop, which might have
otherwise interfered. In particular, the order in which edges are picked from S is precomputed,
using a random shufﬂe.
edge and inserting with probability p. In our experiments, we used p = x to
generate a DAG with v vertices and expected density x.
The approach to generating random DAGs suggested here is by no means the
only method. One alternative is to use a Markov Chain where each step consists
of picking two vertices at random and either deleting the edge between them
(if one is present) or inserting an edge between them (if one is not) [Melacon
et al. 2001; Ide and Cozman 2002]. Note that, if inserting an edge would in-
troduce a cycle, then nothing is done. In general, it remains unclear how the
two generation methods compare and further work could examine this in more
detail.
An interesting aspect of our random DAGs is how they are affected by the
phase transition phenomenon. This issue was addressed by Pittel and Tungol
[2001]. They showed for Gdag(v, p) that, if p = c(ln v)
v
, then the size of the largest
transitive closure of any vertex is asymptotic to vc ln v, 2v(ln ln v)
v
and v(1 −1
c ),
when c < 1, c = 1 and c > 1, respectively. This means the phase transition
occurs roughly at a graph density of ln v
v , after which point it is likely that there
exists a vertex connected by a path to every other vertex. In the experiments
which follow, the graphs have 2000 vertices and, thus, the phase transition
should occur around 0.0038. For this reason, we consider graphs with density
below this threshold as sparse, and those over it as dense.
4.2 Experimental Procedure
Our general procedure for measuring the ACPI for an algorithm was to gener-
ate, for some |V | and density, a random DAG and measure the time taken to
insert a sample of edges while maintaining a topological order. Figure 5 out-
lines the procedure.2 Note, the sample size was ﬁxed at 0.0001 (i.e., 0.01% of
all 1
2v(v −1) possible edges). Although this seems like a small number, it is
2This differs from the procedure used in Pearce and Kelly [2004], which maintained |E| constant
during the experiment by deleting edges from within the inner loop. However, we eventually found
the overhead of doing this interfered with the results and, thus, we abandoned this approach.
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

18
•
D. J. Pearce and P. H. J. Kelly
important to realize that most of the interesting observations occur between
0.001 and 0.02 density and, thus, larger sample sizes would swamp our re-
sults. To generate each data point, we averaged over 100 runs of this procedure
(i.e., over 100 random DAGs). An important aspect of our procedure is that the
sample may include noninvalidating edges and these dilute our measurements,
since all four algorithms do no work for these cases. Our purpose, however, was
to determine what performance can be expected in practice, where it is unlikely
all edge insertions will be invalidating.
As mentioned already, some of our experiments measured the average set
size of our complexity metrics, instead of ACPI. The procedure for doing this
was almost identical to before, except, instead of measuring time, exact values
for ⟨⟨K ⟩⟩, ⟨⟨δxy⟩⟩and |ARxy| were recorded. These were obtained from the cor-
responding algorithm (AHRSZ for ⟨⟨K ⟩⟩, PK for ⟨⟨δxy⟩⟩and MNR for |ARxy|) by
counting vertices visited and edges iterated where appropriate.
Finally, all experiments were performed on a 900-Mhz Athlon-based machine
with 1 GB of main memory, running Redhat 8.0. The executables were com-
piled using gcc 3.2, with optimization level “-O3” and timing was performed
using the gettimeofday function, which gives microsecond resolution. To re-
duce interference, experiments were performed with all nonessential system
daemons/services (e.g., X windows, crond) disabled and no other user-level pro-
grams running. The implementation itself was in C++ and took the form of
an extension to the Boost Graph Library [Siek et al. 2002] and utilized the
adjacency_list class to represent the DAG. Our implementation of AHRSZ
employs the O(1) amortized (not O(1) worse-case) time structure of Dietz and
Sleator [1987]. This seems reasonable as they themselves state it likely to be
more efﬁcient in practice. The complete implementation, including C++ code
for all three algorithms and the random graph generator, is available online at
http://www.mcs.vuw.ac.nz/∼djp.
4.3 Single Insertion Experiments
The purpose of these experiments was to investigate the performance of the
three unit change algorithms, AHRSZ, PK, and MNR. Speciﬁcally, we exam-
ined how ACPI varied with |E| and we report our ﬁndings here. Furthermore,
we include data for a control experiment (labeled as CTRL), whose purpose is
to indicate the best possible performance any algorithm could obtain. To gen-
erate data for our control, we perform exactly the same steps as for the other
algorithms, except that no work is done to actually maintain the topological
order. Thus, it measures the cost of inserting edges into our underlying graph
data structure.
Figure 6 shows the effect on ACPI and the complexity parameters of varying
density, while maintaining |V | constant. Although the highest density shown
is 0.1, we have explored beyond this and found the plots extend as expected.
Therefore, we limit our attention to this density range as it is most interesting.
From the topmost graphs, we see that all three algorithms have quite different
behavior. The main observations are: ﬁrst, MNR performs poorly on sparse
graphs, but is the most efﬁcient on dense graphs; second, PK performs well
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
19
Fig. 6.
Various plots of our experimental data. The top-most two graphs plot ACPI against density
for the three algorithms and our control. The middle two graphs plot the complexity metrics, which
measure the work done by each algorithm. Finally, the bottom two graphs show the percentage of
invalidating edges encountered when processing the insertion sample for PK and AHRSZ.
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

20
•
D. J. Pearce and P. H. J. Kelly
on very sparse and dense graphs, but not as well on those in between; ﬁnally,
AHRSZ is relatively poor on very sparse graphs, but otherwise has constant
performance, which is reasonably competitive with the others. By looking at
the middle two graphs of Figure 6, a clear resemblance can be seen between
the plots of ACPI for PK and ⟨⟨δxy⟩⟩, between that for MNR and |ARxy|, and
between that for AHRSZ and ⟨⟨K ⟩⟩.
The curves observed for the three complexity metrics are key to understand-
ing the performance of the algorithms. Their shape can be explained if we
consider the number of invalidating edges in the insertion sample. The bottom
two graphs of Figure 6 plot this and they show that the proportion of invalidat-
ing edges goes down rapidly with density. However, why is this? Well, we know
that as density increases, the chance of a path existing between any two vertices
must also increase. From this, it follows that the number of possible invalidat-
ing edges must go down as density goes up. This is because an edge x →y is
invalidating only if there is no path from x to y. The steepness of these plots is
governed by the phase-transition phenomenon, which dictates that the chance
of a path existing between two vertices quickly approaches 1 as soon as the
0.0038 density threshold is passed. From these facts, the curves seen for |ARxy|
and ⟨⟨δxy⟩⟩can be explained: ﬁrst, the average size of an affected region must go
down as density increases, since |ARxy| = 0 for noninvalidating edges; second,
the average size of ⟨⟨δxy⟩⟩must (initially) increase with density, since its size is
determined by the chance of a path existing between two vertices. However, the
decreasing number of invalidating edges will eventually overpower this and,
hence, ⟨⟨δxy⟩⟩is determined by the trade-off between these two factors.
The shape seen for ⟨⟨K ⟩⟩is more subtle. We had expected to see something
more closely resembling that of ⟨⟨δxy⟩⟩. That is, we had expected to see ⟨⟨K ⟩⟩
go up initially and then fall. In fact, a small positive gradient can be seen
roughly between 0.001 and 0.005 density which, we argue, corresponds to the
increasing chance of a path existing between two vertices at this point. The
most important feature of this plot, namely the negative initial gradient, is
more curious. In particular, it seems strange that ⟨⟨K ⟩⟩is ever larger than ⟨⟨δxy⟩⟩.
This does make sense, however, if we contrast the bottom two graphs of Figure 6
against each other. What we see is that the proportion of invalidating edges for
AHRSZ starts at a much higher point than for PK. This arises because, on very
sparse graphs, AHRSZ will assign most vertices the same priority—so most
insertions are invalidating. In contrast, for PK, all vertices have a different
priority, regardless of density. This means there is (roughly) a 50% chance that
any edge insertion x →y will be invalidating, since y is equally likely to come
after x in the ordering than before it. Thus, as both ⟨⟨K ⟩⟩and ⟨⟨δxy⟩⟩are empty on
valid insertions, we can see that ⟨⟨δxy⟩⟩is smaller than ⟨⟨K ⟩⟩on very sparse graphs
simply because it is measured over fewer invalidating edges. Unfortunately, it
still remains somewhat unclear why a negative gradient is seen for ⟨⟨K ⟩⟩.
Finally, while ⟨⟨K ⟩⟩is generally much smaller than ⟨⟨δxy⟩⟩, AHRSZ still per-
forms worse than PK and this reﬂects the larger constants involved in its imple-
mentation (see Section 3.5 for more on this). The fact that MNR outperforms
PK on dense graphs is also expected following the discussion of Section 3.4.
What may be surprising, however, is that MNR only ever achieves a constant
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
21
Fig. 7.
Plots of our experimental data, illustrating for each algorithm how ACPI varies with batch
size for sparse (density 0.0001) and dense graphs (density 0.01).
factor improvement over PK on dense graphs. MNR outperforms PK because it
only uses a forward search (i.e., ∥δF
xy∥+), rather than a forward and backward
search (i.e., ⟨⟨δxy⟩⟩) as PK does. However, for our random graphs, it is likely that
∥δF
xy∥+ ≈∥δB
xy∥−and, hence, only a constant factor improvement is obtained. We
suspect this property will hold true for most real-world problems, provided there
are sufﬁcient edge insertions. This is because, in a dense graph, it is difﬁcult
to construct situations where edge insertions consistently yield signiﬁcantly
smaller forward-search trees compared with backward-search trees.
4.4 Batch Insertion Experiments
The purpose of these experiments was to investigate the performance of the
three dynamic algorithms against STO, which you may recall from Figure 1,
uses a standard (i.e., static) topological sort based on depth-ﬁrst search. Thus,
following the same experimental procedure as before, we measured ACPI for
these algorithms while maintaining |V | and |E| constant and varying the batch
size b.
Figure 7 shows the performance of PK, MNR, AHRSZ, and STO across vary-
ing batch sizes on sparse and dense graphs. They show a signiﬁcant advantage
is to be gained from using the dynamic algorithms when the batch size is small.
Indeed, the data suggests that they compare favorably even for large batch
sizes. It is important to realize here that, as the dynamic algorithms are unit
change (i.e., they only process one edge at a time), their plots are ﬂat, since
they obtain no advantage from seeing the edge insertions in batches. Finally,
the plots indicate that, as density increases, the batch size at which STO be-
comes favorable also increases.
5. RELATED WORK
The main algorithms for the problem of dynamically maintaining a topologi-
cal order have been covered in Section 3. However, a number of other works
on this subject exist. Of particular relevance is that of Katriel and Bodlaen-
der [2005] who obtained an O(min{m3/2 log v, m3/2 + v2 log v}) bound to insert
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

22
•
D. J. Pearce and P. H. J. Kelly
m edges into an empty graph for algorithm AHRSZ. They also showed that,
for DAGs with treewidth k, it needs, at most, O(mk log2 v) time to insert m
edges and that, for the special case of trees, this reduces to O(v log v). The
bound on the time to insert m edges for AHRSZ has since been improved to
O(v2.75) by Ajwani, Friedrich and Meyer [2006]. Elsewhere, Katriel [2004] has
demonstrated algorithm PK to be worse-case optimal with respect to the num-
ber of vertices reordered over a series of edge insertions. Zhou and M¨uller [2003]
have improved the space requirements of algorithm AHRSZ. Ramalingam and
Reps [1994] proved that no algorithm for the DTO problem can have a constant
competitive ratio.
The approach taken in Section 3 to theoretically evaluating algorithms for
the DTO problem is known as incremental complexity analysis. This methodol-
ogy is really a natural extension of complexity analysis based on input size. It
recognizes that, for a dynamic problem, there is typically no ﬁxed input captur-
ing the minimal amount of work to be performed. Instead, work is measured in
terms of a parameter δ representing the (minimal) change in input and output
required. For example, in the DTO problem, the input is the current DAG and
topological order, while the output after an edge insertion is the updated DAG
and (any) valid ordering. Thus, δ is the (minimal) set of vertices, which must be
reordered (i.e., Kmin) plus the inserted edge. Incremental complexity analysis
is about identifying the parameter δ for the dynamic problem in question. An
algorithm is described as bounded, if its time complexity can be expressed only
in terms of |δ| or ∥δ∥for all inputs and outputs. Otherwise, it is said to be un-
bounded. The inclusion of ∥δ∥here, as opposed to just |δ|, is simply to include
algorithms that depend upon visiting the edges incident to vertices in δ. This is
necessary to obtaining a bounded algorithm for all dynamic graph problems we
are aware of. The ideas of incremental complexity were developed over several
previous works [Berman 1992; Ramalingam and Reps 1996; Ramalingam 1996]
and there are many examples of its use (e.g., Reps [1982]; Alpern et al. [1990];
Reps et al. [1986]; Wirn [1993]; Frigioni et al. [1994]; Yeh [1983]; Ramalingam
[1996]).
In general, the majority of work on dynamic algorithms for directed graphs
has focused on shortest/longest paths and transitive closure (e.g., King and
Sagert [1999]; Demetrescu and Italiano [2000]; Djidjev et al. [2000]; Demetrescu
et al. [2000]; Frigioni et al. [1998]; Baswana et al. [2002]; Katriel et al. [2005]).
For undirected graphs, there has been substantially more work and a survey
of this area can be found in Italiano et al. [1999]. Perhaps closest to the prob-
lem studied in this paper is that of dynamically identifying strongly connected
components in digraphs. We have shown elsewhere how algorithms MNR and
PK can be modiﬁed for this purpose [Pearce et al. 2004; Pearce 2005].
6. CONCLUSION
We have presented a new algorithm for dynamically maintaining the topo-
logical order of a DAG, provided a complexity analysis, correctness proof, and
shown that it performs better on sparse graphs than any previously known. Fur-
thermore, we have provided the ﬁrst experimental comparison of algorithms
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

A Dynamic Topological Sort Algorithm for Directed Acyclic Graphs
•
23
for this problem over a large number of randomly generated directed acyclic
graphs.
For the future, we would like to investigate performance over different classes
of random graphs (e.g., power law graphs [Aiello et al. 2000]). We are also aware
that random graphs may not reﬂect real life structures and, thus, experimenta-
tion on physically occurring graphs would be useful. Finally, we are particularly
interested in ﬁnding batch variants on these algorithms, which would perform
minimal work across a batch of edge insertions.
ACKNOWLEDGMENTS
Special thanks to Irit Katriel for her excellent comments and observations on
this work. We also thank Umberto Nanni and the anonymous JEA and WEA
referees for their helpful comments on earlier versions of this paper.
REFERENCES
AIELLO, W., CHUNG, F., AND LU, L.
2000.
A random graph model for power law graphs. In Proceed-
ings of the ACM Symposium on the Theory of Computing (STOC). 171–180.
AJWANI, D., FRIEDRICH, T., AND MEYER, U.
2006.
An O(n2.75) algorithm for online topological order-
ing. In Proceedings of the Scandinavian Workshop on Algorithm Theory (SWAT). Lecture Notes
in Computer Science, vol. 4059. Springer-Verlag, New York. 53–74.
ALPERN, B., HOOVER, R., ROSEN, B. K., SWEENEY, P. F., AND ZADECK, F. K.
1990.
Incremental evalu-
ation of computational circuits. In Proceedings of the ACM-SIAM Symposium on Discrete Algo-
rithms (SODA). ACM Press, New York. 32–42.
BARAK, A. AND ERD¨OS, P.
1984.
On the maximal number of strongly independent vertices in a
random acyclic directed graph. 5, 4, 508–514.
BASWANA, S., HARIHARAN, R., AND SEN, S.
2002.
Improved decremental algorithms for maintaining
transitive closure and all-pairs shortest paths in digraphs under edge deletions. In Proceedings
of the ACM Symposium on Theory of Computing (STOC). ACM Press, New York. 117–123.
BENDER, M. A., COLE, R., DEMAINE, E. D., FARACH-COLTON, M., AND ZITO, J.
2002.
Two simpliﬁed algo-
rithms for maintaining order in a list. In Proceedings of the European Symposium on Algorithms
(ESA). Lecture Notes in Computer Science, vol. 2461. Springer-Verlag, New York. 152–164.
BERMAN, A. M.
1992.
Lower and upper bounds for incremental algorithms. Ph.D. thesis, Rutgers
University, New Brunswick, New Jersey.
CORMEN, T. H., LEISERSON, C. E., RIVEST, R. L., AND STEIN, C.
2001.
Introduction to Algorithms. MIT
Press, Cambridge, MA.
DEMETRESCU, C. AND ITALIANO, G. F.
2000.
Fully dynamic transitive closure: breaking through
the O(n2) barrier. In Proceedings of the IEEE Symposium on Foundations of Computer Science
(FOCS). IEEE Computer Society Press, Washington, DC. 381–389.
DEMETRESCU, C., FRIGIONI, D., MARCHETTI-SPACCAMELA, A., AND NANNI, U.
2000.
Maintaining shortest
paths in digraphs with arbitrary arc weights: An experimental study. In Proceedings of the Work-
shop on Algorithm Engineering (WAE). Lecture Notes in Computer Science, vol. 1982. Springer-
Verlag, New York. 218–229.
DIETZ, P. F. AND SLEATOR, D. D.
1987.
Two algorithms for maintaining order in a list. In Proceedings
of the ACM Symposium on Theory of Computing (STOC). ACM Press, New York. 365–372.
DJIDJEV, H., PANTZIOU, G. E., AND ZAROLIAGIS, C. D.
2000.
Improved algorithms for dynamic shortest
paths. Algorithmica 28, 4, 367–389.
ERD¨OS, P. AND R´ENYI, A.
1960.
On the evolution of random graphs. Mathematical Institute of the
Hungarian Academy of Sciences 5, 17–61.
FRIGIONI, D., MARCHETTI-SPACCAMELA, A., AND NANNI, U.
1994.
Incremental algorithms for the
single-source shortest path problem. In Proceedings of the conference on Foundations of Software
Technology and Theoretical Computer Science (FSTTCS). Lecture Notes in Computer Science,
vol. 880. Springer-Verlag, New York. 113–124.
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

24
•
D. J. Pearce and P. H. J. Kelly
FRIGIONI, D., MARCHETTI-SPACCAMELA, A., AND NANNI, U.
1998.
Fully dynamic shortest paths and
negative cycles detection on digraphs with arbitrary arc weights. In Proceedings of the European
Symposium on Algorithms (ESA). Lecture Notes in Computer Science, vol. 1461. Springer-Verlag,
New York. 320–331.
HOOVER, R.
1987.
Ph.D. thesis. Ph.D. thesis, Department of Computer Science, Cornell Univer-
sity, Ithaca, New York.
IDE, J. S. AND COZMAN, F. G.
2002.
Random generation of bayesian networks. In Proceedings of the
Brazillian Symposium on Artiﬁcial Intelligence (SBIA). Vol. 2507. Springer-Verlag, New York.
366–375.
ITALIANO, G. F., EPPSTEIN, D., AND GALIL, Z.
1999.
Dynamic graph algorithms. In Handbook of
Algorithms and Theory of Computation, Chapter 22. CRC Press, Boca Raton, FL.
JANSON, S., LUCZAK, T., AND RUCINSKI, A.
2000.
Random Graphs. Wiley, New York.
KATRIEL, I.
2004.
Online topological ordering and sorting. Tech. rep., Max-Planck-Institut f¨ur
Informatik.
KATRIEL, I. AND BODLAENDER, H. L.
2005.
Online topological ordering. In Proceedings of the ACM
Symposium on Discrete Algorithms (SODA). ACM Press, New York. 443–450.
KATRIEL, I., MICHEL, L., AND HENTENRYCK, P. V.
2005.
Maintaining longest paths incrementally.
Constraints 10, 2, 159–183.
KING, V. AND SAGERT, G.
1999.
A fully dynamic algorithm for maintaining the transitive closure.
In Proceedings of the ACM Symposium on Theory of Computing (STOC). ACM Press, New York.
492–498.
MARCHETTI-SPACCAMELA, A., NANNI, U., AND ROHNERT, H.
1996.
Maintaining a topological order
under edge insertions. Information Processing Letters 59, 1, 53–58.
MELA¸CON, G., BOUSQUET-MELOU, M., AND DUTOR, I.
2001.
Random generation of directed acyclic
graphs. In Proceedings of the Euroconference on Combinatorics, Graph Theory and Applications
(COMB). Elsevier Science, New York. 12–15.
PEARCE, D. J.
2005.
Some directed graph algorithms and their application to pointer analysis.
Ph.D. thesis, Imperial College, London.
PEARCE, D. J. AND KELLY, P. H. J.
2004.
A dynamic algorithm for topologically sorting directed
acyclic graphs. In Proceedings of the Workshop on Efﬁcient and experimental Algorithms (WEA).
Lecture Notes in Computer Science, vol. 3059. Springer-Verlag, New York. 383–398.
PEARCE, D. J., KELLY, P. H. J., AND HANKIN, C.
2004.
Online cycle detection and difference propa-
gation: Applications to pointer analysis. Software Quality Journal 12, 309–335.
PITTEL, B. AND TUNGOL, R.
2001.
A phase transition phenomenon in a random directed acyclic
graph. RSA: Random Structures & Algorithms 18, 2, 164–184.
RAMALINGAM, G.
1996.
Bounded incremental computation. Ph.D. thesis. Lecture Notes in Com-
puter Science, vol. 1089. Springer-Verlag, New York.
RAMALINGAM, G. AND REPS, T.
1994.
On competitive on-line algorithms for the dynamic priority-
ordering problem. Information Processing Letters 51, 3, 155–161.
RAMALINGAM, G. AND REPS, T.
1996.
On the computational complexity of dynamic graph problems.
Theoretical Computer Science 158, 1–2, 233–277.
REPS, T.
1982.
Optimal-time incremental semantic analysis for syntax-directed editors. In Pro-
ceedings of the ACM Symposium on Principles of Programming Languages (POPL). ACM Press,
New York. 169–176.
REPS, T., MARCEAU, C., AND TEITELBAUM, T.
1986.
Remote attribute updating for language-based
editors. In Proceedings of the ACM Symposium on the Principles of Programming Languages
(POPL). ACM Press, New York. 1–13.
SIEK, J., LEE, L.-Q., AND LUMSDAINE, A.
2002.
The Boost Graph Library: User Guide and Reference
Manual. Addison-Wesley, Reading, MA.
WIRN, M.
1993.
Bounded incremental parsing. In Proceedings of the Twente Workshop on Lan-
guage Technology (TWLT). University of Twente, University of Twente, Enschede, The Nether-
lands. 145–156.
YEH, D.
1983.
On incremental evaluation of ordered attributed grammars. BIT 23, 308–320.
ZHOU, J. AND M¨ULLER, M.
2003.
Depth-ﬁrst discovery algorithm for incremental topological sorting
of directed acyclic graphs. Information Processing Letters 88, 4, 195–200.
Received October 2004; revised March 2006; accepted September 2006
ACM Journal of Experimental Algorithmics, Vol. 11, Article No. 1.7, 2006.

