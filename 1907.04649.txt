1 
 
Quantifying the pathways to life using assembly spaces 
 
Stuart M. Marshall,1 Douglas G. Moore,2 Alastair R. G. Murray,1 Sara I. Walker,2,3* and Leroy 
Cronin1* 
1 School of Chemistry, University of Glasgow, Glasgow, G12 8QQ, UK.  
2 BEYOND Center for Fundamental Concepts in Science, Arizona State University, Tempe, 
AZ, USA 
3 School of Earth and Space Exploration, Arizona State University, Tempe, AZ, USA 
*Corresponding author email: Lee.Cronin@glasgow.ac.uk, sara.i.walker@asu.edu  
 
Abstract 
We have developed the theory of pathway assembly to explore the extrinsic information 
required to distinguish a given object from a random ensemble. To quantify the assembly in an 
agnostic way, we determine the pathway assembly information contained within such an object 
by deconstructing the object into its irreducible parts, and then evaluating the minimum number 
of steps to reconstruct the object. The formalisation of this approach uses an assembly space. 
By finding the minimal number of steps contained in the route by which the objects can be 
assembled within that space, we can compare how much information (𝐼𝐼) is gained from 
knowing this pathway assembly index (PA) according to 𝐼𝐼𝑃𝑃𝑃𝑃= 𝑙𝑙𝑙𝑙𝑙𝑙 
|𝑁𝑁|
|𝑁𝑁𝑃𝑃𝑃𝑃|  where, for an end 
product with 𝑃𝑃𝑃𝑃= 𝑥𝑥,  N is the set of objects possible that can be created from the same 
irreducible parts within 𝑥𝑥 steps regardless of PA, and NPA is the subset of those objects with 
the precise pathway assembly index 𝑃𝑃𝑃𝑃= 𝑥𝑥.  Applying this theory to objects formed in 1D, 
2D and 3D leads to the identification of objects in the world or wider Universe that have high 
assembly numbers. We propose that objects with high PA will be uniquely identifiable as those 
that must have been produced by biological or technological processes, rather than the 
assembly occurring via unbiased random processes alone, thereby defining a new scale of 
aliveness. We think this approach is needed to help identify the new physical and chemical 
laws needed to understand what life is, by quantifying what life does. 
 
Introduction 
In the thought experiment known as the “infinite monkey theorem”, an infinite number of 
monkeys, each having a typewriter, produce strings of text by hitting keys at random (1). Given 
infinite resources, it can be deduced that the monkeys will produce all possible strings, 

2 
 
including the complete works of Shakespeare. However, when constrained to the bounds of the 
physical universe, the likelihood that any particular text is produced by a finite number of 
monkeys drops rapidly with the length of the text (2). This can also be extended to physical 
objects like cars, aeroplanes, and computers, which must be constructed from a finite set of 
objects - just as meaningful text is constructed from a finite set of letters. Even if we were to 
convert nearly all matter in the universe to object constructing monkeys, and give them the age 
of the universe in which to work, the probability that any monkey would construct any 
sufficiently complex physical object is negligible (3). This is an entropic argument – the 
number of possible arrangements of the objects of a given composition increases exponentially 
with the object size. For example, if the number of possible play-sized strings is sufficiently 
large, it would be practically impossible to produce a predetermined Shakespearean string 
without the author. This argument implies information external to the object itself is necessary 
to construct an object if it is of sufficiently high complexity (4,5): in biology the requisite 
information partly comes from DNA, the sequence of which has been acquired through 
progressive rounds of evolution. Although Shakespeare’s works are – in the absence of an 
appropriate constructor (6) (an author) - as likely to be produced as any other string of the same 
length, our knowledge of English, and Shakespeare in particular, allows us to partition the set 
of possible strings to generate information about those strings containing meaning, and to 
construct them. 
 
Biological systems have access to a lot of information - genetically, epigenetically, 
morphologically, and metabolically - and the acquisition of that information occurs via 
evolutionary selection over successive cycles of replication and propagation (7). One way to 
look at such systems is by comparing the self-dissimilarity between different classes of 
complex system, allowing a model free comparison (8).  However, it has also been suggested 
that much of this information is effectively encrypted, with the heritable information being 
encoded with random keys from the environment (9). As such, these random keys are recorded 
as frozen accidents and increase the operative information content, as well as help direct the 
system during the process of evolution, producing objects that can construct other objects (10). 
This is significant since one important characteristic of objects produced autonomously by 
machinery (such as life), which itself is instructed in some way, is their relative complexity as 
compared to objects that require no information for their assembly beyond what chemistry and 
physics alone can provide. This means that for complex objects there is ‘object-assembly’ 
information that is generated by an evolutionary system, and is not just the product of laws of 

3 
 
physics and chemistry alone. Biological systems are the only known source of agency in the 
universe (11), and it has been suggested that new physical laws are needed to understand the 
phenomenon of life (12). The challenge is how to explore the complexity of objects generated 
by evolutionary systems without a priori having a model of the system.  
 
Herein, we present the foundations of a new theoretical approach to agnostically quantify the 
amount of potential pathway assembly information contained within an object. This is achieved 
by considering how the object can be deconstructed into its irreducible parts, and then 
evaluating the minimum number of steps necessary to reconstruct the object along any 
pathway. The analysis of pathway assembly is done by the recursive deconstruction of a given 
object using shortest paths, and this can be used to evaluate the effective pathway assembly 
index for that object (13). In developing pathway assembly, we have been motivated to create 
an intrinsic measure of an object forming through random processes, where the only knowledge 
required of the system is the basic building blocks and the permitted ways of joining structures 
together. This allows determining when an extrinsic agent or evolutionary system is necessary 
to construct the object, permitting the search for complexity in the abstract, without any specific 
notions of what we are looking for, thus removing the requirement for an external imposition 
of meaning, see Figure 1. 
 
 
 
Figure 1: The Pathway Assembly process (centre) (13) is compared to implementations of 
Shannon Entropy (14) (left) and Kolmogorov Complexity (15) (right) for blue and white 
blocks. The Pathway Assembly process leads to a measure of structural complexity that 
accounts for the structure of the object and how it could have been constructed, which is in all 
cases computable and unambiguous. 

4 
 
 
The development of the Pathway Assembly (13) index (PA) was motivated by the desire to 
define a biological threshold, such that any object found in abundance with PA above the 
threshold would have required the intervention of one or more biological processes to form 
(16). The Pathway Assembly index (PA) of an object is the length of the shortest pathway to 
construct the object starting from its basic building blocks. It should be noted that this approach 
is entirely classical (17), allowing quantifying pathways through assembly space 
probabilistically as a way to understand what life does. We construct the object using a 
sequence of joining operations, where at each step any structures already created are available 
for use in subsequent steps, see Figure 2. The shortest pathway approach is in some ways 
analogous to Kolmogorov complexity (15), which in the case of strings is the shortest computer 
program that can output a given string. However, Pathway Assembly differs in that we only 
allow joining operations as defined in our model. This restriction is intended to allow the 
Pathway Assembly process to mimic the natural construction of objects through random 
processes, and it also importantly allows the PA of an object to be computable for all finite 
objects (see Theorem 4 in the SI).  
 
 
 
Figure 2: The basic concept of pathway assembly is shown here. Each of the final structures 
can be created from white and blue basic objects in four joining operations, giving a Pathway 
Assembly Index of 4. Pathway (a) shows the creation of a structure that can only be formed in 
four steps by adding one basic object at a time, while pathway (c) represents the maximum 
increase in size per step, by combining the largest object in the pathway with itself at each 
stage. Pathway (b) is an intermediate case.  

5 
 
Given a system where objects interact randomly and with equal probability, it is intuitively 
clear that the likelihood of an object being formed in 𝑛𝑛 steps decreases rapidly with 𝑛𝑛. 
However, it is also true that a highly contrived set of biases could guarantee the formation of 
any object. For example, this could occur if we were to model the system such that any 
interactions contributing to the formation of the object were certain to be successful, while 
other interactions were prohibited. For complex objects, such a serendipitous set of biases 
would seem unlikely in the absence of external information about the end products, but physical 
systems generally do have biases in their interactions, and we can explore how these affect the 
likelihood of formation of objects. However, we expect for any perceived “construction 
processes” that requires a large enough set of highly contrived biases, we can deduce that 
external information is required in the form of a “machine” that is doing the constructing. 
 
Technological processes are bootstrapped to biological ones, and hence, by extension, 
production of technosignatures involves processes that necessarily have a biological origin. 
Examples of biosignatures and technosignatures include chemical products produced by the 
action of complex molecular systems such as networks of enzymes (18), and also objects whose 
creation involved any biological organisms such as technological artefacts (19), complex 
chemicals made in the laboratory (20), and the complete works of Shakespeare. Finding the 
object in some abundance, or a single object with a large number of complex, but precisely 
repeating features, is required in order to distinguish single random occurrences from 
deliberately generated objects. For example, a system which produces long random strings will 
generate many that have high PA, but not in abundance. Finding the same long string more 
than once will tell us that there is a bias in the system towards creating that string, thus 
searching for signatures of life should involve looking for objects with high PA found in 
relatively high abundance.  
 
Formalism 
In this manuscript, we explore the foundations of Pathway Assembly, as well as some of its 
properties and variants. We also describe how Pathway Assembly can be incorporated into a 
new information measure, Pathway Information, and how this can help identify objects, above 
a threshold, that must have been produced by living systems. Finally, we offer some examples 
of the use of pathway assembly in systems of varying dimensionality, and describe some 
potential real-world applications of this approach. The Pathway Assembly process is formally 
defined in the context of an Assembly Space, which comprises an acyclic quiver Γ (a quiver 

6 
 
being a directed graph that allows multiple edges between pairs of nodes and has no directed 
cycles), where the vertices in the quiver are objects in the space, along with an edge labelling 
map 𝜙𝜙 which associates each edge with a vertex in the quiver (see Definition 11 in the SI). The 
quiver is associated with a reachability relationship ≤ where for vertices 𝑎𝑎, 𝑏𝑏 in Γ, 𝑎𝑎≤𝑏𝑏 if 
there is a path from 𝑎𝑎 to 𝑏𝑏, in other words it is possible reach 𝑏𝑏 starting at 𝑎𝑎 by following a 
sequence of edges along their respective directions. If for an edge 𝑒𝑒 from object 𝑥𝑥 to object 𝑧𝑧, 
𝜙𝜙(𝑒𝑒) = 𝑦𝑦, then this can be thought of as 𝑧𝑧 being constructed through the combination of 𝑥𝑥 and 
𝑦𝑦. We also require that the symmetric operation exists within the space, i.e. there is an edge 𝑔𝑔 
from 𝑦𝑦 to 𝑧𝑧 such that 𝜙𝜙(𝑔𝑔) = 𝑥𝑥. 
 
We define an assembly subspace Δ on an assembly space Γ to be an assembly space that 
contains a subset of the objects in Γ, maintaining all the relationships between them (see 
Definition 15 in the SI). An assembly subspace is said to be rooted if it contains a nonempty 
subset of the basic objects. This is an important distinction in the definition of the Assembly 
Index below, as it allows us to define the shortest construction pathway for objects using a 
consistent set of basic objects. We define the basis of an Assembly Space Γ as the set of minimal 
vertices in the space with regard to ≤, and refer to those vertices as basic objects, basic vertices, 
or basic elements (see Definition 12 in the SI). We define an assembly map (see Definition 17 
in the SI) as a map from one assembly space Γ to another Δ that maintains the relationship 
between objects, but may map multiple objects in Γ to the same object in Δ. One such map that 
is generally applicable is the mapping of each object to its size, see Figure 3. Assembly maps 
can be useful for finding a lower bound to the assembly index (described below, and Definition 
19 in the SI), by mapping to a system that may be more computationally tractable to work in 
than the original system of interest (see Theorem 3 in the SI). 
 

7 
 
 
Figure 3: An assembly space comprised of objects formed by joining together white and blue 
blocks. Some of the morphisms have been omitted for clarity. The dotted region is an assembly 
subspace, and topological ordering of the objects in the subspace represents a minimal 
assembly pathway for any subspace containing the sequence of four blue boxes. 
 
We define the cardinality and augmented cardinality as the number of objects in the assembly 
space, where the augmented cardinality excludes the basic objects (defined separately, as this 
measure is used in the assembly index). We then define an assembly pathway and the assembly 
index. An assembly pathway is a set of all the objects in an assembly space Γ in some order 
that respects the reachability relationship ≤, i.e. a topological order. If we take all the rooted 
assembly subspaces of Γ that contain some object 𝑥𝑥, we then define the assembly index as the 
augmented cardinality of the smallest rooted assembly subspace that contains 𝑥𝑥. The subspace 
must be rooted, as otherwise a subspace containing only 𝑥𝑥 would meet this criterion. We use 
the augmented cardinality of this subspace, as defined above, as defining the assembly index 
without including basic objects in accord with the physical interpretations that motivated this 
measure; however, the cardinality could instead be used if desired, and the difference in the 
measures for any structures with shared basic objects would be require a constant. The 
assembly index then represents the minimum number of joining operations required to 

8 
 
construct object 𝑥𝑥, as illustrated in Figure 2. For a formal definition, see Definition 19 in the 
SI. 
 
When mapping from assembly space Γ to assembly space Δ through an assembly map f, the 
assembly index of a mapped object in Δ acts as a lower bound for the assembly index of the 
original object in Γ. This can allow us, for example, to map an assembly space to another in 
which finding the assembly index is less computationally intensive in order to calculate a useful 
lower bound, see Theorem 3 in the SI. The assembly index of an object in any rooted assembly 
subspace of Γ is an upper bound for the assembly index of the object in Γ, see Lemma 6 in the 
SI.  A split-branched space is an assembly space Γ where for each pair of objects 𝑥𝑥, 𝑦𝑦 in Γ, 𝑥𝑥≤
𝑦𝑦 or 𝑦𝑦≤𝑥𝑥 whenever 𝑉𝑉(𝑥𝑥↓) ∩𝑉𝑉(𝑦𝑦↓) ≠∅ (see Definition 14 in the SI). This means that, other 
than basic objects, when combining two different objects neither of them can have an assembly 
pathway that uses objects created in the construction of the other. They may use objects that 
are considered identical (e.g. the same string) but these are separate objects within the space. 
Since we can define an assembly map that maps these identical objects to a new space where 
they map to the same object, the split-branched assembly index for a system is an upper bound 
for the assembly index on that system. 
 
We use the space of integers under addition to explore these assembly maps, where an addition 
chain for an integer is a sequence of integers, starting with 1, with each integer in the sequence 
being the sum of two previous integers, see Figure 4. A minimal addition chain for an integer 
is the shortest addition chain that terminates in that integer, and the size of that addition chain 
is equivalent to the pathway assembly index of the integer (after subtracting 1 to account for 
the single basic object). The objects in this space can be considered as abstract integers, or as 
representing the size of objects in some other assembly space. See the “Example Applications” 
section below for more information on addition chains. We model the assembly process as a 
weighted decision tree where at each level there is a choice of objects that can be formed. The 
number of choices at each level of the tree is constrained by the number of integers that have 
the assembly index associated with that level. To obtain the assembly indices, we used data for 
all minimal addition chain lengths for integers up to 100,000, as published in the Online 
Encyclopaedia of Integer Sequences (21). 
 

9 
 
 
 
Figure 4: An assembly map that maps an assembly space of white and blue blocks onto 
integers representing the object size.  
 
In the initial case of zero bias, the probability of each step was drawn from a uniform random 
distribution. In subsequent steps, a value 𝑥𝑥 was drawn from a uniform random distribution 
between 0 and a value ℎ, and the probability of the step was assigned a value 10𝑥𝑥, subsequently 
normalised so that all probabilities sum to 1. As ℎ increases, so does the bias of the distribution, 
with each increase of 𝑥𝑥 by 1 representing a 10-fold increase in likelihood of that choice. We 
then calculated the probability of the most likely pathway to assess the impact of the bias. In 
the case of zero bias, at assembly index 25, the integer generated along the most probable 
pathway will be found has approximately 10−7 probability of being formed. Increasing the bias 
to the maximum level ℎ= 5, the integer generated along the most probable pathway at 
assembly index 25 will appear approximately 12% of the time, see Figure 5.  

10 
 
 
 
Figure 5: Left – Minimal addition chains modelled as a decision tree. Right – probability of 
the most likely pathway at different levels of bias. 
 
These probabilities will reduce further when considering greater number of choices, such as in 
situations of higher dimensionality, like strings, grid structures, and graphs (see “Example 
Applications” section below). In the maximum bias case explored here, where ℎ= 5, the 
choices with 𝑥𝑥= 5 will be 10,000 times more likely than those with 𝑥𝑥= 1.  This argument 
demonstrates that using a pathway assembly model will result in a threshold above which it is 
unlikely that any specific object would be found, with the threshold depending on the system 
of objects and joining operations, and the physical limits of the inherent biases present in the 
process. Even in a significantly biased system, such a threshold will exist, and any objects 
found in abundance with PA above the threshold will require some process inducing specificity 
outside of the random (bias) model to form. We consider these additional processes to be 
biological. Exploration of the processes and biases of a specific system can then be used, along 
with experimental data, to determine this threshold.  
 
In addition to using the assembly index to determine this biological threshold, it is useful to 
consider an information measure based on the number of possible structures that can be created 
using assembly pathways, see Figure 6. One way to do this is to consider a bounded set of 
possible structures 𝑁𝑁, and then the subset of possible structures with a specified pathway 
assembly index, 𝑁𝑁𝑃𝑃𝑃𝑃. The "pathway information" is the amount of uncertainty the pathway 
assembly index reduces beyond what knowledge of only the size or general composition can 
provide. In this case, using the approach of Shannon Information (14), the information provided 
by the Pathway Assembly index, 𝐼𝐼𝑃𝑃𝑃𝑃, is given by: 

11 
 
𝐼𝐼𝑃𝑃𝑃𝑃= 𝑙𝑙𝑙𝑙𝑙𝑙 |𝑁𝑁|
|𝑁𝑁𝑃𝑃𝑃𝑃|  
 
 
Figure 6: Pathway Information. The precise definitions of 𝑁𝑁 and 𝑁𝑁𝑃𝑃𝑃𝑃 will depend on the 
specific implementation. 
 
It should be noted that this information measure provides a way of formalizing information 
over states (size, composition) and over paths (PA) within a common mathematical framework. 
To calculate IPA, there are several possible choices for 𝑁𝑁, all of which must be finite. In one 
option, for an end product with 𝑃𝑃𝑃𝑃= 𝑥𝑥, N is the set of objects possible that can be created from 
the same irreducible parts within 𝑥𝑥 steps regardless of PA, and NPA is the subset of those objects 
with the precise pathway assembly index 𝑃𝑃𝑃𝑃= 𝑥𝑥. This then gives us a measure of the 
information provided by learning the assembly index, within the context of all objects that 
could be created by traversing that distance in the assembly space. The difference in utility 
between the Pathway Assembly index and the pathway information, is that the Assembly Index 
provides a simple threshold based on pathway length, whereas pathway information can 

12 
 
provide an intuition on what the assembly index tells us about the space of possible objects and 
how much additional information is provided by knowing the paths. The information increases 
rapidly with Assembly Index, as the space of objects accessible within a given number of steps 
grows rapidly with the number of steps, see Figure 7.  Pseudo code describing the algorithm to 
calculate the pathway assembly of a given object is described in the SI.  
 
 
Figure 7: Pathway Information vs Pathway Assembly index for strings consisting of 6 x letter 
“A” and 6 x letter “B”. If we have a string with Assembly Index of 9, i.e. it can be constructed 
in 9 steps, the pathway information is much higher than with Assembly Index 8, as the number 
of objects that can be constructed in 𝑥𝑥 steps grows much more rapidly than the number of 
objects with 𝑃𝑃𝑃𝑃= 𝑥𝑥. 
 
Example Applications 
In the following sections we describe how the pathway assembly approach can be applied to 
systems of varying dimensionality, see Figure 8. 
 
An addition chain is defined (22) as “a finite sequence of positive integers  
1 = 𝑎𝑎0  ≤ 𝑎𝑎1 … ≤ 𝑎𝑎𝑟𝑟 =  𝑛𝑛 with the property that for all 𝑖𝑖 >  0 there exists 𝑗𝑗, 𝑘𝑘 with  
𝑎𝑎𝑖𝑖 = 𝑎𝑎𝑗𝑗 + 𝑎𝑎𝑘𝑘 𝑎𝑎𝑎𝑎𝑎𝑎 𝑟𝑟 ≥ 𝑖𝑖 >  𝑗𝑗 ≥ 𝑘𝑘 ≥ 0. An optimal addition chain is one with the shortest 
possible length. An example of an optimum addition chain is for 𝑛𝑛= 123 is 
 
{1, 2, 3, 5, 10, 15, 30, 60, 63, 123} 

13 
 
 
An assembly space (Γ, 𝛷𝛷) for addition chains can be defined where 𝑉𝑉(Γ) = ℕ\{0} =
{1, 2, 3, … }, the set of positive integers, and for an edge 𝑒𝑒~[𝑧𝑧𝑧𝑧], 𝜙𝜙(𝑒𝑒) = 𝑦𝑦 if and only if 𝑥𝑥+
𝑦𝑦= 𝑧𝑧. In this space, an assembly pathway on a subspace representing the assembly index of 
an integer will be equivalent to an optimum addition chain (subtracting 1 to account for the 
single basic object). Addition chains can provide a useful lower bound for the assembly index 
in other assembly spaces, as we can define an assembly map in an assembly space that maps 
each object to an integer representing the number of basic objects within it (see Figure 3).  
Addition chains can be generalised to vectorial addition chains (23), in which we define a 
vectorial addition chain for an k-dimensional vector of natural numbers 𝑛𝑛∈ℕ𝑘𝑘/{0} (excluding 
the 0 vector) as a sequence of 𝑎𝑎𝑖𝑖∈ℕ𝑘𝑘/{0} such that for −𝑘𝑘+ 1 ≤𝑖𝑖≤0, 𝑎𝑎𝑖𝑖 are the standard 
basis of unit vectors {(1, 0, . . . , 0), (0, 1, . . . , 0), . . . , (0, 0, . . . , 1)}, and for each 𝑖𝑖> 0 there exists 
𝑗𝑗, 𝑘𝑘 with 𝑎𝑎𝑖𝑖= 𝑎𝑎𝑗𝑗+ 𝑎𝑎𝑘𝑘 and 𝑖𝑖> 𝑗𝑗≥𝑘𝑘. An example of a vectorial addition chain for [8,8,10] is 
 
[[1,0,0], [0,1,0], [0,0,1], [1,1,0], [1,1,1], [2,2,2], [4,4,4], [8,8,8], [8,8,9], [8,8,10]] 
 
 
 
Figure 8: Example assembly pathways for systems of varying dimensionality 
 
 

14 
 
We can also define an assembly map from other assembly spaces to vectorial addition chains, 
where each element in a vector represents the count of a type of basic object (e.g. [1, 2, 3] for 
1 red block, 2 blue blocks, 3 green blocks), so this can provide another lower bound. In this 
case, there also exists a trivial assembly map from vectorial addition chains to addition chains, 
by summing the vector, so the assembly index on addition chains is a lower bound for the 
assembly index on vectorial addition chains.  In one-dimensional strings we can define an 
assembly space (Γ, 𝜙𝜙) of strings, where each 𝑠𝑠∈𝑉𝑉(Γ) is a string and if a string 𝑧𝑧 can be 
produced by concatenating strings 𝑥𝑥 and 𝑦𝑦, then there exists an edge 𝑒𝑒~[𝑧𝑧𝑧𝑧] with  𝜙𝜙(𝑒𝑒) = 𝑦𝑦, 
if 𝑧𝑧 can be produced by concatenating 𝑥𝑥 and 𝑦𝑦. There are multiple systems that have string 
representations, including text strings, binary signals and polymers.  
 
 
 
Figure 9: Examples of text assembly pathways for 16-character strings. The first example 
demonstrates the shortest possible assembly index of any such string. The second example has 
a nontrivial assembly pathway, while the third example is a string without any shorter pathway 
than adding one character at a time. This model assumes that text fragments cannot be reversed 
when concatenating. 
 
Two other methods for analysing the complexity / information content of strings are the 
Shannon Information (14) and the Kolmogorov Complexity (15). The Shannon information 
content of a string is based on the probability of occurrence of its characters.  For example, for 
a string “ABBCCCDDDD”, the Shannon entropy (using base 2) is given by 
 
𝐻𝐻= −
෍
𝑝𝑝𝑖𝑖𝑝𝑝𝑖𝑖
𝑖𝑖∈{𝐴𝐴,𝐵𝐵,𝐶𝐶,𝐷𝐷}
 = −(0.10.1 + 0.20.2 + 0.30.3 + 0.40.4 ) ≃1.84 
 

15 
 
In the case of strings, the probabilities 𝑝𝑝𝑖𝑖 for each character 𝑖𝑖 represent the likelihood of finding 
it in the string, i.e. the inverse of the count of that character within the string. The Shannon 
information content is defined as the reduction in entropy (uncertainty) on being presented with 
some information, and in the case where we are presented with the string itself (reducing 
entropy to zero) the entropy and information are numerically equal. Unlike Pathway Assembly, 
Shannon information in this implementation does not consider the structure of the string, e.g. 
the information content will be the same for “ABBCCCDDDD” as for “ABCDBCDCDD”. 
The Kolmogorov Complexity (15) of an object is the length of the shortest program that outputs 
that object, in a given Turing-complete language. Although Kolmogorov Complexity is 
dependent on the language used, it can be shown that the Kolmogorov complexity 𝐶𝐶 in any 
language 𝜙𝜙 can be related to the Kolmogorov complexity in a universal language 𝑈𝑈 by  
𝐶𝐶𝑈𝑈(𝑥𝑥) ≤𝐶𝐶𝐶𝐶(𝑥𝑥) + 𝑐𝑐 for some constant 𝑐𝑐 (24). If a string cannot be expressed in a universal 
language by a program shorter than its length, it is considered random. It has been shown that 
the Kolmogorov complexity is not computable, whereas the Pathway Assembly index is 
computable (see Theorem 4 in the SI). 
 
We can extend Pathway Assembly to two dimensions by considering a grid of pixels, or 
coloured boxes, for example a digital image. For simplicity we will consider images with black 
and white basic objects, although this could be simply extended to greyscale images or colour 
images (e.g. greyscale images could have 256 basic objects representing different pixel 
intensities, as in an 8-bit greyscale image). We can define an assembly space with assemblages 
of black and white pixels as objects. In this space, two assemblages 𝑎𝑎 and 𝑥𝑥 are connected by 
an edge 𝑒𝑒 ~ [𝑥𝑥𝑥𝑥] if 𝑎𝑎 is a substructure of 𝑥𝑥. The edge 𝑒𝑒 is labelled as 𝜙𝜙(𝑒𝑒) = 𝑏𝑏 with 𝑏𝑏 the 
complement of 𝑎𝑎 in 𝑥𝑥. In other words, you can connect 𝑎𝑎 and 𝑏𝑏 together to get 𝑥𝑥. A choice can 
be made about whether to enforce the preservation of orientation, or whether to consider 
substructures rotated by 90 degrees to be equivalent, and the latter choice can be related to the 
former by way of an assembly map. An illustration of an assembly pathway in this space can 
be seen in Figure 10.  

16 
 
 
 
Figure 10: Illustrative assembly pathway of a two-dimensional image. This does not 
necessarily represent the minimal assembly pathway for this shape. Here, images that are 
rotated are considered equivalent. 
 
The assembly index of an image can be bounded by an assembly map to the one-dimensional 
case, for example by mapping to a numeric list containing a count of the number of black pixels 
in each column. It can also be mapped to the space of addition chains as normal and to a reduced 
representation of the image such as those generated by pooling operations used in convolutional 
neural networks, or quantisation matrices used in jpeg compression. To extend pathway 
assembly to three dimensions we can consider structures created out of cubic building blocks 
as a natural extension of the two-dimensional model. Pathway assembly does not need to be 
applied to objects as a whole, but can be applied to shared motifs or networks found within the 
objects (13), which can in some cases map to the problem of cubic building blocks. Pathway 
assembly, as described here, currently has no simple extension to continuous objects, however 
we can use an  assembly map to define a function that consistently maps similar features to 
larger block structures, and can calculate the assembly index of that structural motif to explore 
whether it is over the biological threshold, if found in some abundance. As in the two-
dimensional case, the assembly index of cubic structures can be bounded by an assembly map 
to the two-dimensional case, the one-dimensional case, or to the case of addition chains. 
 
An undirected graph 𝐺𝐺(𝑉𝑉, 𝐸𝐸) is defined by a set of vertices 𝑉𝑉 and a set of edges 𝐸𝐸⊆𝑉𝑉× 𝑉𝑉.  
An assembly space for connected graphs (directed or undirected) can be defined where Γ is the 
space of all connected graphs, with the basis set 𝐵𝐵 consisting of a single node. The reachability 
relationship ≤ is defined on Γ such that 𝜙𝜙([𝐺𝐺𝑥𝑥, 𝐺𝐺𝑎𝑎]) = 𝐺𝐺𝑏𝑏 if 𝑉𝑉𝑥𝑥= 𝑉𝑉𝑎𝑎∪𝑉𝑉𝑏𝑏 and 𝐸𝐸𝑥𝑥= 𝐸𝐸𝑎𝑎∪𝐸𝐸𝑏𝑏∪
𝐸𝐸𝑎𝑎𝑎𝑎 where 𝐸𝐸𝑎𝑎𝑎𝑎⊆𝑉𝑉𝑎𝑎× 𝑉𝑉𝑏𝑏 and 𝐸𝐸𝑎𝑎𝑎𝑎≠∅ . In other words, 𝐺𝐺𝑥𝑥 contains all vertices and edges of 

17 
 
𝐺𝐺𝑎𝑎 and 𝐺𝐺𝑏𝑏, and also at least one edge between them. Similar spaces can be defined for graphs 
that are not necessarily connected by removing the requirement that 𝐸𝐸𝑎𝑎𝑎𝑎≠∅. Vertex colours 
can be incorporated by expanding the basis set 𝐵𝐵. A graph assembly space can also be defined 
with edges as the basic objects, instead of vertices. Additional constraints allow for the study 
of spaces of other useful graph structures, for example restriction of vertex degree allows for 
the study of the space of molecular graphs, which are studied in an upcoming paper. As in the 
block structures, the assembly space of graphs can be used to analyse objects that have identical 
network motifs in them while not being identical in other ways. Assembly maps can be defined 
from the space of graphs to the space of addition chains, as a count of the number of vertices, 
and also to vectorial addition chains if the vertices are coloured. 
 
There are various other examples where the pathway assembly approach could be used to 
provide useful analysis of objects. One example is in audio / electromagnetic signals, or music. 
By utilising notes and silences as basic objects, possibly incorporating frequency/pitch, we 
could use pathway assembly to distinguish natural signals such as those from a pulsar, or the 
sound of wind moving through a complex landscape, from sounds such as birdsong or 
structured communications. In such a system, abundance could be considered to be the same 
signal from multiple locations, or from the same location but repeated. We can also consider 
the morphology of apparent geological formations to look for evidence of biological influence 
in the form of duplicated complex patterns. 
 
Pathway assembly can also be used to define a compression algorithm, similar to the widely 
known Lempel-Ziv-Welch (LZW) algorithm (25). In the LZW algorithm, repeated portions of 
text are represented by additional symbols in an expanded character set, and the need for a 
separate dictionary is removed by building the dictionary in such a way that it can be 
reconstructed during decompression. In a pathway assembly-based implementation, we could 
initially calculate an assembly pathway for the string, and then use the additional character set 
to indicate points at which substrings are duplicated or stored for re-use. It is unlikely that such 
a compression algorithm would be commercially useful due to the computational complexity 
of finding a minimal assembly pathway, but analysing compressibility in this way could 
provide further insights around the information content of string-like objects from an assembly 
space perspective.  
 

18 
 
Conclusions 
The pathway assembly model, and pathway information, can be used to explore the possible 
ways an object could have formed from its building blocks through random interactions, and 
we have now built on our initial work (26) by establishing a robust mathematical formalism. 
By doing so, we can define a threshold above which extrinsic information from a biological 
source would have been required to create an observable abundance of an object because it is 
too improbable to have formed in abundance otherwise. The pathway assembly of an object, 
when above the threshold, can be used as an agnostic biosignature, giving a clear indication of 
the influence of information in constructing objects (e.g. via biological processes) without 
knowledge of the system that produced the end product. In other words, it can be used to detect 
biological influence even when we don’t know what we are looking for.  Of interest is the 
ability to search for new types of life forms in the lab, alien life on other worlds, as well as 
identifying the conditions under which the random world embarks on the path towards life, as 
characterised by the emergence of physical systems that produce objects with high pathway 
assembly. As such, pathway assembly information might be enable us to not only look for the 
abiotic to living transition, identifying the emergence of life, but also to identify 
technosignatures associated with intelligent life with even higher pathway assemblies within a 
unified quantitative framework. We therefore feel that the concept of pathway assembly can 
be used to help us explore the universe for structures that must have been produced using an 
information-driven construction process; in fact we could go as far as to suggest that any such 
process requiring information is a biological or technological process.  This also means that 
pathway assembly information provides a new window on the problem of understanding the 
physics of life simply because the physics of information is the physics of life. We believe that 
such an approach might help us reframe the question from philosophy of what life is (27), to a 
physics of what life does. 
 
Acknowledgements 
The authors gratefully acknowledge financial support from the EPSRC (Grant Nos 
EP/R01308X/1, EP/L023652/1, EP/P00153X/1), the ERC (project 670467 SMART-POM), the 
John Templeton Foundation Grant ID 60625 and Grant ID 61184 and the National Aeronautics 
and Space Administration through grant NNX15AL24G S02. We thank Dr. Cole Mathis and 
Prof. Paul Davies for useful discussions. 
 
 

19 
 
Author Contributions 
L.C. conceived of the overall concept and developed the algorithm together with S.M.M. 
A.R.G.M explored the initial mathematical description, and this was expanded and validated 
by D.G.M and S.I.W. L.C. and S. M. M. wrote the manuscript with input from all the authors. 
 
References 
1. 
C. R. S. Banerji, T. Mansour, and S. Severini, A Notion of Graph Likelihood and an 
Infinite Monkey Theorem. J. Phys. A 47, 035101 (2014). 
2. 
C. Adami and T. Labar, “From Entropy to Information: Biased Typewriters and the 
Origin of Life” in From Matter to Life: Information and Causality, G. F. R. Ellis, P. C. 
W. Davies, S. I. Walker, Eds. (Cambridge University Press, Cambridge, 2017), pp. 130-
154. 
3. 
F. Hoyle as Quoted in Hoyle on Evolution. Nature 294, 105 (1981). 
4. 
D. Deutsch, Constructor Theory. Synthese 190, 4331-4359 (2013). 
5. 
C. Marletto, Constructor Theory of Life. J. R. Soc. Interface 12, 20141226 (2015). 
6. 
J. V. Neumann, Theory of Self-Reproducing Automata (University of Illinois Press, 
Champaign IL, 1966). 
7. 
A. Danchin, Bacteria as Computers Making Computers. FEMS Microbiol. Rev. 33, 3-
26 (2009). 
8. 
D. H. Wolpert and W. Macready, Using Self-Dissimilarity to Quantify Complexity. 
Complexity 12, 77-85 (2007). 
9. 
D. Krakauer, Cryptographic Nature. arXiv:1505.01744 (7 May 2015). 
10. 
J. P. Crutchfield and O. Görnerup, Objects That Make Objects: The Population 
Dynamics of Structural Complexity. J. R. Soc. Interface 3, 345-349 (2006). 
11. 
S. Kauffman and P. Clayton, On Emergence, Agency, and Organization. Biology & 
Philosophy 21, 501-521 (2006). 
12. 
S. I. Walker and P. C. W. Davies, The Algorithmic Origins of Life. J. R. Soc. Interface 
10, 20120869 (2013). 
13. 
S. M. Marshall, A. R. G. Murray, and L. Cronin, A Probabilistic Framework for 
Identifying Biosignatures Using Pathway Complexity. Phil. Trans. R. Soc. A 375, 
20160342 (2017). 
14. 
C. E. Shannon, A Mathematical Theory of Communication. Bell Syst. Tech. J. 27, 379-
423 (1948). 

20 
 
15. 
A. N. Kolmogorov, Three Approaches to the Quantitative Definition of Information. 
Int. J. Comput. Math. 2, 157-168 (1968). 
16. 
D. H. Lee, J. R. Granja, J. A. Martinez, K. Severin, and M. R. Ghadiri, A Self-
Replicating Peptide. Nature 382, 525-528 (1996). 
17. 
S. Pressé, K. Ghosh, J. Lee, K. A. Dill, Principles of Maximum Entropy and Maximum 
Caliber in Statistical Physics. Rev. Mod. Phys., 85, 1115-1141 (2013).  
18. 
H. Kim, H. B. Smith, C. Mathis, J. Raymond, and S. I. Walker, Universal Scaling across 
Biochemical Networks on Earth. Science Advances 5, eaau0149 (2019). 
19. 
C. Grimaldi and G. W. Marcy, Bayesian Approach to Seti. Proc. Natl. Acad. Sci. USA, 
201808578 (2018). 
20. 
S. Steiner, J. Wolf, S. Glatzel, A. Andreou, J. M. Granda, G. Keenan, T. Hinkley, G. 
Aragon-Camarasa, P. J. Kitson, D. Angelone, and L. Cronin, Organic Synthesis in a 
Modular Robotic System Driven by a Chemical Programming Language. Science 363, 
144-152 (2019). 
21. 
D. Wilson and A. Mathys, Sequence A003313, the On-Line Encyclopedia of Integer 
Sequences. https://oeis.org/A003313 accessed June 2019. 
22. 
N. M. Clift, Calculating Optimal Addition Chains. Computing 91, 265-284 (2011). 
23. 
G. J. Chaitin, Information-Theoretic Computational Complexity. IEEE T. Inf. Theory, 
20, 10-15 (1974)  
24. 
J. Olivos, On Vectorial Addition Chains. J. Algorithms 2, 13-21 (1981). 
25. 
T. A. Welch, A Technique for High-Performance Data Compression. Computer 17, 8-
19 (1984). 
26. 
A. R. G. Murray, S. M. Marshall, and L. Cronin, Defining Pathway Assembly and 
Exploring Its Applications. arXiv:1804.06972 (9 April 2018). 
27. 
E. Schrödinger, What is Life? The Physical Aspect of the Living Cell (Cambridge 
University Press, Cambridge, 1944). 
 

Supplementary Information: Quantifying the pathways to life 
using assembly spaces 
Stuart M. Marshall,1 Douglas G. Moore,2 Alastair R. G. Murray,1 Sara I. Walker,2,3* and 
Leroy Cronin1* 
1 School of Chemistry, University of Glasgow, Glasgow, G12 8QQ, UK.  
2 BEYOND Center for Fundamental Concepts in Science, Arizona State University, Tempe, 
AZ, USA 
3 School of Earth and Space Exploration, Arizona State University, Tempe, AZ, USA 
*Corresponding author email: Lee.Cronin@glasgow.ac.uk, sara.i.walker@asu.edu  
1. Introduction 
This formalism arose as a means of rigorously describing the “simplest” way of assembling a 
given object by combining basing building blocks. With this in mind, we consider a universe 
of objects and binary relations between them signifying that one can be compose with some 
third object to create the second. Each relation then is associated with that third object. In this 
setting, the concrete rules or laws describing this assembly processes are neglected though 
they are certainly necessary for initially constructing the space. We quickly come to the 
conclusion that a graph formalization is appropriate when we consider this kind of process in 
general, but a more general mathematical structure than the standard concept of a graph is 
necessarily; namely quivers1. As such, the fundamental mathematical structure we define and 
explore herein, referred to as an assembly space, can be described as an acyclic quiver with 
edges labeled with vertices in the quiver which satisfies three simple axioms. With assembly 
spaces defined, we are able to define an assembly index for each object in the space which 
characterizes how directly that object can be assembled. Further, we prove several axioms 
relating to method of bounding the assembly index for a given object and algorithms for 
computing or approximating it. 
To facilitate this exposition, we have broken the text into three sections. First, in Section 2. 
we describe the graph-theoretic prerequisites associated with quivers and morphisms 
(mappings) between them. We proceed then to define assembly spaces, subspaces and maps 
between them, and to prove several lemmas in Section 3. Finally, we define the assembly 
index, prove that it is computable and two methods for bounding it above and below, and 
present algorithms for computing or approximating it in Section 4. 
2. Graph-Theoretic Prerequisites 
We begin by considering a set of objects, possibly infinitely many objects, which can be 
combined in various ways to produce others. If an object 𝑎𝑎 can be combined with some other 
 
1 Many texts refer to this structure as a multigraph, with the term quiver preferred in 
settings where the edges represent morphism or processes rather than simply relationships. 
Since we view the “relations” as an active process of combination, we prefer quiver in this 
text. The reader would lose nothing by mentally substituting the terms. 

object to yield an object 𝑏𝑏, we represent the relationship between 𝑎𝑎 and 𝑏𝑏 by drawing a 
directed edge or arrow from 𝑎𝑎 to 𝑏𝑏. Altogether, this structure is a quiver, also called a 
multigraph, as we allow for the possibility that there is more than one way to produce 𝑏𝑏 from 
𝑎𝑎; that is, there may be more than one edge from 𝑎𝑎 to 𝑏𝑏. 
Definition 1. A quiver 𝛤𝛤 consists of 
1. a set of vertices 𝑉𝑉(𝛤𝛤) 
2. a set of edges 𝐸𝐸(𝛤𝛤) 
3. a pair of maps 𝑠𝑠𝛤𝛤, 𝑡𝑡𝛤𝛤: 𝐸𝐸(𝛤𝛤) →𝑉𝑉(𝛤𝛤) 
For an edge 𝑒𝑒∈𝐸𝐸(𝛤𝛤), 𝑠𝑠𝛤𝛤(𝑒𝑒) is referred to as the source and 𝑡𝑡𝛤𝛤(𝑒𝑒) the target of the edge, and 
we will often leave off the subscripts when the context is clear, e.g. 𝑠𝑠 and 𝑡𝑡. We will often 
describe an edge 𝑒𝑒∈𝐸𝐸(𝛤𝛤) with 𝑠𝑠(𝑒𝑒) = 𝑎𝑎 and 𝑡𝑡(𝑒𝑒) = 𝑏𝑏 as 𝑒𝑒∼[𝑏𝑏𝑏𝑏]. This does not mean that 
𝑒𝑒 is a unique edge with endpoints 𝑎𝑎 and 𝑏𝑏; it is possible that two edges 𝑒𝑒≠𝑓𝑓 have the same 
endpoints 𝑒𝑒∼𝑓𝑓∼[𝑏𝑏𝑏𝑏]. 
 
From here, we consider paths, that is sequences of edges, which describe the process of 
sequentially combining objects to yield intermediate objects and ultimately some terminal 
object. 
Definition 2. If 𝛤𝛤 is a quiver, a path 𝛾𝛾= 𝑎𝑎𝑛𝑛… 𝑎𝑎1 in 𝛤𝛤 of length 𝑛𝑛≥1 is a sequence of edges 
such that 𝑡𝑡(𝑎𝑎𝑖𝑖) = 𝑠𝑠(𝑎𝑎𝑖𝑖+1) for 1 ≤𝑖𝑖≤𝑛𝑛−1. The functions 𝑠𝑠 and 𝑡𝑡 can be extended to paths 
as 𝑠𝑠(𝛾𝛾) = 𝑠𝑠(𝑎𝑎1) and 𝑡𝑡(𝛾𝛾) = 𝑡𝑡(𝑎𝑎𝑛𝑛). We write |𝛾𝛾| to denote the length, or number of edges, in 
the path. Additionally, for each vertex 𝑥𝑥∈𝛤𝛤 there is a zero path, denoted 𝑒𝑒𝑥𝑥, with length 0 
and 𝑠𝑠(𝑒𝑒𝑥𝑥) = 𝑡𝑡(𝑒𝑒𝑥𝑥) = 𝑥𝑥. 
 
A natural point is that combining two objects should never yield something that can be used 
to create either of those objects. Essentially, there are no directed cycles – sequences of edges 
that form a closed cycle – within the quiver. 
Definition 3. A path 𝛾𝛾 in a quiver 𝛤𝛤 is a directed cycle if |𝛾𝛾| ≥1 with 𝑡𝑡(𝛾𝛾) = 𝑠𝑠(𝛾𝛾). 
Definition 4. A quiver 𝛤𝛤 is acyclic if it has no directed cycles. 
 
We can think of an object 𝑏𝑏 as being reachable from an object 𝑎𝑎 if there’s a path from 𝑎𝑎 to 𝑏𝑏, 
and this relationship forms a partial ordering on the quiver if the quiver is acyclic. 
Definition 5. Let 𝛤𝛤 be an acyclic quiver and let 𝑥𝑥, 𝑦𝑦∈𝑉𝑉(𝛤𝛤). We say 𝑦𝑦 is reachable from 𝑥𝑥 if 
there exists a path 𝛾𝛾 such that 𝑠𝑠(𝛾𝛾) = 𝑥𝑥 and 𝑡𝑡(𝛾𝛾) = 𝑦𝑦, where |𝛾𝛾| ≥0. 
Lemma 1. Let 𝛤𝛤 be an acyclic quiver, and define a binary relation ≤ on the vertices of 𝛤𝛤 
such that 𝑥𝑥≤𝑦𝑦 if and only if 𝑦𝑦 is reachable from 𝑥𝑥. (𝑉𝑉(𝛤𝛤), ≤) is a partially ordered set, and 
≤ is referred to as the reachability relation on 𝛤𝛤. 
Proof. For ≤ to be a partial ordering on 𝑉𝑉(𝛤𝛤), we need to show that it is reflexive, transitive 
and antisymmetric. Reflexivity follows directly from the definition of reachability as 𝑥𝑥 is 

reachable from itself via the zero path 𝑒𝑒𝑥𝑥. To show transitivity, let 𝑎𝑎≤𝑏𝑏 and 𝑏𝑏≤𝑐𝑐. If 𝑎𝑎= 𝑏𝑏 
or 𝑏𝑏= 𝑐𝑐, then we’re done. Otherwise there are paths 𝛾𝛾𝑏𝑏𝑏𝑏= 𝑢𝑢𝑚𝑚… 𝑢𝑢1 from 𝑎𝑎 to 𝑏𝑏 and 𝛾𝛾𝑐𝑐𝑐𝑐=
𝑣𝑣𝑛𝑛… 𝑣𝑣1 from 𝑏𝑏 to 𝑐𝑐. The composite path 𝛾𝛾𝑐𝑐𝑐𝑐∘𝛾𝛾𝑏𝑏𝑏𝑏= 𝑣𝑣𝑛𝑛… 𝑣𝑣1𝑢𝑢𝑛𝑛… 𝑢𝑢1 is a path from 𝑎𝑎 to 𝑐𝑐; 
thus 𝑐𝑐 is reachable from 𝑎𝑎 so that 𝑎𝑎≤𝑐𝑐. Now consider antisymmetry and suppose that 𝑎𝑎≤𝑏𝑏 
and 𝑏𝑏≤𝑎𝑎. Then there exist paths 𝛾𝛾𝑏𝑏𝑏𝑏 and 𝛾𝛾𝑎𝑎𝑎𝑎 from 𝑎𝑎 to 𝑏𝑏 and 𝑏𝑏 to 𝑎𝑎, respectively. Then 
𝛾𝛾𝑎𝑎𝑎𝑎∘𝛾𝛾𝑏𝑏𝑏𝑏 is a path from 𝑎𝑎 to itself. Since 𝛤𝛤 is acyclic, this implies that 𝛾𝛾𝑎𝑎𝑎𝑎∘𝛾𝛾𝑏𝑏𝑏𝑏= 𝑒𝑒𝑎𝑎, and 
consequently that 𝛾𝛾𝑎𝑎𝑎𝑎= 𝛾𝛾𝑏𝑏𝑏𝑏= 𝑒𝑒𝑎𝑎. Thus 𝑎𝑎= 𝑏𝑏 and ≤ is antisymmetric. 
 
∎ 
 
The idea of reachability allows us to think of all objects that are reachable from (or above) a 
given object 𝑥𝑥, the upper quiver of 𝑥𝑥. Similarly, we can think of all objects that can reach 𝑥𝑥, 
the lower quiver. 
Definition 6. Let 𝛤𝛤 be an acyclic quiver and let ≤ be the reachability relation on it. The 
upper quiver of 𝑥𝑥∈𝑉𝑉(𝛤𝛤) is 𝑥𝑥↑ with vertices 𝑉𝑉(𝑥𝑥↑) = {𝑦𝑦∈𝑉𝑉(𝛤𝛤) | 𝑥𝑥≤𝑦𝑦}, edges 𝐸𝐸(𝑥𝑥↑
) = {𝑒𝑒∈𝐸𝐸(𝛤𝛤) | 𝑠𝑠𝛤𝛤(𝑒𝑒), 𝑡𝑡𝛤𝛤(𝑒𝑒) ∈𝑉𝑉(𝑥𝑥↑)}, 𝑠𝑠𝑥𝑥↑= 𝑠𝑠𝛤𝛤|𝐸𝐸(𝑥𝑥↑), and 𝑡𝑡𝑥𝑥↑= 𝑡𝑡𝛤𝛤|𝐸𝐸(𝑥𝑥↑). The lower 
quiver of 𝑥𝑥∈𝑉𝑉(𝛤𝛤) is 𝑥𝑥↓ with vertices 𝑉𝑉(𝑥𝑥↓) = {𝑦𝑦∈𝑉𝑉(𝛤𝛤) | 𝑦𝑦≤𝑥𝑥}, edges 𝐸𝐸(𝑥𝑥↓) =
{𝑒𝑒∈𝐸𝐸(𝛤𝛤) | 𝑠𝑠𝛤𝛤(𝑒𝑒), 𝑡𝑡𝛤𝛤(𝑒𝑒) ∈𝑉𝑉(𝑥𝑥↓)}, 𝑠𝑠𝑥𝑥↓= 𝑠𝑠𝛤𝛤|𝐸𝐸(𝑥𝑥↓), and 𝑡𝑡𝑥𝑥↓= 𝑡𝑡𝛤𝛤|𝐸𝐸(𝑥𝑥↓). 
Similarly, the upper quiver of a subset 𝑄𝑄⊆𝑉𝑉(𝛤𝛤) in 𝛤𝛤 is 𝑄𝑄↑ with vertices 𝑉𝑉(𝑄𝑄↑) = {𝑦𝑦∈
𝑉𝑉(𝛤𝛤) | (∃𝑞𝑞∈𝑄𝑄)𝑞𝑞≤𝑦𝑦}, edges 𝐸𝐸(𝑄𝑄↑) = {𝑒𝑒∈𝐸𝐸(𝛤𝛤) | 𝑠𝑠𝛤𝛤(𝑒𝑒), 𝑡𝑡𝛤𝛤(𝑒𝑒) ∈𝑉𝑉(𝑄𝑄↑)}, 𝑠𝑠𝑄𝑄↑=
𝑠𝑠𝛤𝛤|𝐸𝐸(𝑄𝑄↑), and 𝑡𝑡𝑄𝑄↑= 𝑡𝑡𝛤𝛤|𝐸𝐸(𝑄𝑄↑). The lower set of a subset is defined dually. 
 
Going further, we can consider those objects that cannot be reached as minimal and those that 
cannot reach anything as maximal. An object which can be reached by finitely many objects 
is called finite. 
Definition 7. Let 𝛤𝛤 be an acyclic quiver, ≤ be the reachability relation on it and 𝑥𝑥 a vertex in 
𝛤𝛤. Then 𝑥𝑥 is said to be maximal in 𝛤𝛤 if, whenever 𝑥𝑥≤𝑦𝑦 in 𝛤𝛤, we have 𝑥𝑥= 𝑦𝑦. Dually, 𝑥𝑥 is 
minimal in 𝛤𝛤 if, whenever 𝑦𝑦≤𝑥𝑥 in 𝛤𝛤, we have 𝑥𝑥= 𝑦𝑦. The set of all maximal vertices of 𝛤𝛤 is 
denoted max(𝛤𝛤) with min(𝛤𝛤) defined dually. 
Definition 8. A quiver 𝛤𝛤 is said to be 𝐟𝐟𝐟𝐟𝐟𝐟𝐟𝐟𝐟𝐟𝐟𝐟 if its vertex and edge sets are both finite. 
Similarly, a vertex 𝑥𝑥 in a quiver 𝛤𝛤 is said to be finite if 𝑥𝑥↓ in 𝛤𝛤 is a finite quiver. 
 
With this idea of a quiver of objects defined, we can consider asking about subsets of objects 
and relations between them in the context of the quiver as a whole. 
Definition 9. Let 𝛤𝛤 and 𝛤𝛤′ be quivers. Then 𝛤𝛤′ is a subquiver of 𝛤𝛤 if 𝑉𝑉(𝛤𝛤′) ⊆𝑉𝑉(𝛤𝛤), 𝐸𝐸(𝛤𝛤′) ⊆
𝐸𝐸(𝛤𝛤), 𝑠𝑠𝛤𝛤′ = 𝑠𝑠𝛤𝛤|𝐸𝐸(𝛤𝛤′) and 𝑡𝑡𝛤𝛤′ = 𝑡𝑡𝛤𝛤|𝐸𝐸(𝛤𝛤′). We will denote this relationship as 𝛤𝛤′ ⊆𝛤𝛤. 
Lemma 2. If 𝑋𝑋, 𝑌𝑌 and 𝑍𝑍 are quivers such that 𝑋𝑋⊆𝑌𝑌 and 𝑌𝑌⊆𝑍𝑍, then 𝑋𝑋⊆𝑍𝑍. That is, the 
binary relation ⊆ on quivers is transitive. 
Proof. Suppose 𝑋𝑋, 𝑌𝑌 and 𝑍𝑍 are quivers with 𝑋𝑋⊆𝑌𝑌 and 𝑌𝑌⊆𝑍𝑍. Then 𝑉𝑉(𝑋𝑋) ⊆𝑉𝑉(𝑌𝑌) ⊆𝑉𝑉(𝑍𝑍), 
so that 𝑉𝑉(𝑋𝑋) ⊆𝑉𝑉(𝑍𝑍). Similarly, 𝐸𝐸(𝑋𝑋) ⊆𝐸𝐸(𝑍𝑍). Next, since 𝑠𝑠𝑋𝑋= 𝑠𝑠𝑌𝑌|𝐸𝐸(𝑋𝑋), 𝑠𝑠𝑌𝑌= 𝑠𝑠𝑍𝑍|𝐸𝐸(𝑌𝑌) and 

𝐸𝐸(𝑋𝑋) ⊆𝐸𝐸(𝑌𝑌), 𝑠𝑠𝑋𝑋= 𝑠𝑠𝑍𝑍|𝐸𝐸(𝑋𝑋). The same argument applies to show that 𝑡𝑡𝑋𝑋= 𝑡𝑡𝑍𝑍|𝐸𝐸(𝑋𝑋). Thus 𝑋𝑋⊆
𝑍𝑍, so that ⊆ is transitive. 
 
∎ 
 
Finally, we will need to consider how to map one quiver to another in a consistent fashion, 
maintaining the basic relational structure of the original quiver. 
Definition 10. Let 𝛤𝛤 and 𝛤𝛤′ be quivers. A quiver morphism, denoted 𝑚𝑚: 𝛤𝛤→𝛤𝛤′, consists of 
a pair 𝑚𝑚= (𝑚𝑚𝑣𝑣, 𝑚𝑚𝑒𝑒) of functions 𝑚𝑚𝑣𝑣: 𝑉𝑉(𝛤𝛤) →𝑉𝑉(𝛤𝛤′) and 𝑚𝑚𝑒𝑒: 𝐸𝐸(𝛤𝛤) →𝐸𝐸(𝛤𝛤′) such that 𝑚𝑚𝑣𝑣∘
𝑠𝑠𝛤𝛤= 𝑠𝑠𝛤𝛤′ ∘𝑚𝑚𝑒𝑒 and 𝑚𝑚𝑣𝑣∘𝑡𝑡𝛤𝛤= 𝑡𝑡𝛤𝛤′ ∘𝑚𝑚𝑒𝑒. That is, the following diagrams commute: 
 
3. Assembly Spaces, Subspaces and Maps 
Up to this point, we have focused on the binary idea that one object can be used as a 
structural ingredient of another. However, we need something more if we want to capture the 
idea that two things must be combined in order to assemble another. We do this by labeling 
the edges of the quiver with the object that the source of the edge is combined with to 
produce the target. Further, this labeling has to be consistent. If 𝑎𝑎 can be combined with 𝑏𝑏 to 
yield 𝑐𝑐, then 𝑏𝑏 can be combined with 𝑎𝑎 to yield 𝑐𝑐. Additionally, we require that there exists a 
set of minimal objects – building blocks from which all other objects can be assembled. 
Definition 11. An assembly space is an acyclic quiver 𝛤𝛤 together with an edge-labeling map 
𝜙𝜙: 𝐸𝐸(𝛤𝛤) →𝑉𝑉(𝛤𝛤) which satisfies the following axioms: 
4. 
min(𝛤𝛤) is finite and non-empty 
5. 
𝛤𝛤= min(𝛤𝛤) ↑ 
6. 
If 𝑎𝑎 is an edge from 𝑥𝑥 to 𝑧𝑧 in 𝛤𝛤 with 𝜙𝜙(𝑎𝑎) = 𝑦𝑦, then there exists an edge 𝑏𝑏 from 𝑦𝑦 to 
𝑧𝑧 with 𝜙𝜙(𝑏𝑏) = 𝑥𝑥. 
Such an assembly space is denoted (𝛤𝛤, 𝜙𝜙) or simply 𝛤𝛤 where appropriate. We will continue 
to write 𝑥𝑥∈𝛤𝛤 to mean that 𝑥𝑥 is a vertex of the quiver. 
Definition 12. The set of minimal vertices of an assembly space 𝛤𝛤 is referred to as the basis 
of 𝛤𝛤 and is denoted 𝐵𝐵𝛤𝛤. Elements of the basis are referred to as basic objects, basic vertices or 
basic elements. 
Definition 13. An assembly pathway of an assembly space 𝛤𝛤 is any topological ordering of 
the vertices of 𝛤𝛤 with respect to the reachability relation. 

Definition 14. An assembly space 𝛤𝛤 with reachability relation ≤ is said to be split-branched 
if for all 𝑥𝑥, 𝑦𝑦∈𝛤𝛤, 𝑥𝑥≤𝑦𝑦 or 𝑦𝑦≤𝑥𝑥 whenever 𝑉𝑉(𝑥𝑥↓) ∩𝑉𝑉(𝑦𝑦↓) ≠∅. 
Definition 15. Let (𝛤𝛤, 𝜙𝜙) and (𝛤𝛤′, 𝜓𝜓) be assembly spaces. Then (𝛤𝛤′, 𝜓𝜓) is an assembly 
subspace of (𝛤𝛤, 𝜙𝜙) if 𝛤𝛤′ is a subquiver of 𝛤𝛤 and 𝜓𝜓= 𝜙𝜙|𝐸𝐸(𝛤𝛤′). This relationship is denoted as 
(𝛤𝛤, 𝜙𝜙) ⊆(𝛤𝛤′, 𝜓𝜓), or simply 𝛤𝛤⊆𝛤𝛤′ when there is no ambiguity. 
Definition 16. Let 𝛤𝛤′ be an assembly subspace of 𝛤𝛤. Then 𝛤𝛤′ is rooted in 𝛤𝛤 if 𝐵𝐵𝛤𝛤′ ⊆𝐵𝐵𝛤𝛤 as 
sets. 
Lemma 3. Let 𝑈𝑈, 𝑉𝑉 and 𝑊𝑊 be assembly spaces with 𝑈𝑈⊆𝑉𝑉 and 𝑉𝑉⊆𝑊𝑊, then 𝑈𝑈⊆𝑊𝑊. 
Further, if 𝑈𝑈 is rooted in 𝑉𝑉, and 𝑉𝑉 is rooted in 𝑊𝑊, then 𝑈𝑈 is rooted in 𝑊𝑊. 
Proof. Let (𝑈𝑈, 𝜙𝜙𝑈𝑈), (𝑉𝑉, 𝜙𝜙𝑉𝑉) and (𝑊𝑊, 𝜙𝜙𝑊𝑊) be assembly spaces such that (𝑈𝑈, 𝜙𝜙𝑈𝑈) ⊆(𝑉𝑉, 𝜙𝜙𝑉𝑉) 
and (𝑉𝑉, 𝜙𝜙𝑉𝑉) ⊆(𝑊𝑊, 𝜙𝜙𝑊𝑊). Since 𝑈𝑈, 𝑉𝑉 and 𝑊𝑊 are quivers, 𝑈𝑈⊆𝑊𝑊 by the transitivity of ⊆ on 
quivers. Further, since 𝜙𝜙𝑈𝑈= 𝜙𝜙𝑉𝑉|𝐸𝐸(𝑈𝑈), 𝜙𝜙𝑉𝑉= 𝜙𝜙𝑊𝑊|𝐸𝐸(𝑉𝑉) and 𝐸𝐸(𝑈𝑈) ⊆𝐸𝐸(𝑊𝑊), we have 𝜙𝜙𝑈𝑈=
𝜙𝜙𝑊𝑊|𝐸𝐸(𝑊𝑊). Thus, (𝑈𝑈, 𝜙𝜙𝑈𝑈) ⊆(𝑊𝑊, 𝜙𝜙𝑊𝑊). That is, ⊆ is transitive on assembly spaces. If 𝑈𝑈 is 
rooted in 𝑉𝑉 and 𝑉𝑉 is rooted in 𝑊𝑊, then 𝐵𝐵𝑈𝑈⊆𝐵𝐵𝑉𝑉⊆𝐵𝐵𝑊𝑊. That is, 𝑈𝑈 is rooted in 𝑊𝑊. 
 
∎ 
Lemma 4. Let (𝛤𝛤, 𝜙𝜙) be an assembly space and let 𝑥𝑥∈𝛤𝛤. If 𝑒𝑒∼[𝑏𝑏𝑏𝑏] is an edge in 𝛤𝛤 with 
𝑎𝑎, 𝑏𝑏∈𝑥𝑥↓, then 𝜙𝜙(𝑒𝑒) ∈𝑥𝑥↓. 
Proof. Since 𝛤𝛤 is an assembly space, we have 𝜙𝜙(𝑒𝑒) ≤𝑏𝑏 where ≤ is the reachability relation 
on 𝛤𝛤. By construction, 𝑏𝑏≤𝑥𝑥 so that 𝜙𝜙(𝑒𝑒) ≤𝑥𝑥. Therefore 𝜙𝜙(𝑒𝑒) ∈𝑥𝑥↓. 
 
∎ 
Lemma 5. Let (𝛤𝛤, 𝜙𝜙) be an assembly space and let 𝑥𝑥∈𝛤𝛤. Then (𝑥𝑥↓, 𝜙𝜙|𝑥𝑥↓) is a rooted 
assembly subspace of 𝛤𝛤. 
Proof. We first show that (𝑥𝑥↓, 𝜙𝜙|𝑥𝑥↓) is an assembly space. Since (𝛤𝛤, 𝜙𝜙) is an assembly space, 
it is the upper set of its basis 𝐵𝐵𝛤𝛤. As such min(𝑥𝑥↓) is a non-empty subset of 𝐵𝐵𝛤𝛤 and 𝑥𝑥↓=
min(𝑥𝑥↓) ↑ giving us axiom 1. The remaining axiom follows directly from lemma 4. What’s 
more, we already have that min(𝑥𝑥↓) = 𝐵𝐵𝑥𝑥↓⊆𝐵𝐵𝛤𝛤, so 𝑥𝑥↓ is rooted in 𝛤𝛤. 
 
∎ 
Definition 17. Let (𝛤𝛤, 𝜙𝜙) and (𝛥𝛥, 𝜓𝜓) be assembly spaces. An assembly map is a quiver 
morphism 𝑓𝑓: 𝛤𝛤→𝛥𝛥 such that 𝜓𝜓∘𝑓𝑓𝑒𝑒= 𝑓𝑓𝑣𝑣∘𝜙𝜙. That is, the following diagram commutes: 
 
 

Our first theorem provides a basis for the lower bounds developed in the next section. The 
essential point is that the image of an assembly space under an assembly space is an assembly 
space. 
Theorem 1. If 𝑓𝑓: 𝛤𝛤→𝛥𝛥 is an assembly map between assembly spaces (𝛤𝛤, 𝜙𝜙) and (𝛥𝛥, 𝜓𝜓), 
then (𝑓𝑓(𝛤𝛤), 𝜑𝜑) with 𝜑𝜑= 𝜓𝜓|𝐸𝐸(𝑓𝑓(𝛤𝛤)) is an assembly subspace of 𝛥𝛥. 
Proof. Since 𝑓𝑓 is a quiver morphism and 𝛥𝛥 is acyclic, 𝑓𝑓(𝛤𝛤) is an acyclic subquiver of 𝛥𝛥. By 
construction, 𝜑𝜑= 𝜓𝜓|𝐸𝐸(𝑓𝑓(𝛤𝛤)). What remains is to prove the three assembly space axioms. Let 
𝑓𝑓𝑣𝑣 and 𝑓𝑓𝑒𝑒 be the vertex and edge maps comprising 𝑓𝑓. 
Axiom 1 We must show that 𝐦𝐦𝐦𝐦𝐦𝐦(𝒇𝒇(𝜞𝜞)) is finite and non-empty. 
We start by showing that min(𝑓𝑓(𝛤𝛤)) ≠∅. To see this, consider an element 𝑏𝑏∈
𝑓𝑓𝑣𝑣(min(𝛤𝛤)), and suppose there exists a path from an element 𝑥𝑥∈𝑓𝑓(𝛤𝛤) to 𝑏𝑏. Then let 𝑣𝑣∈
𝑓𝑓𝑣𝑣
−1(𝑥𝑥) and let 𝛾𝛾 be a path from a basic element 𝑢𝑢∈min(𝛤𝛤) to 𝑣𝑣 – which must exist 
since 𝛤𝛤 is an assembly space. The image of this path is a path in 𝑓𝑓(𝛤𝛤) from 𝑓𝑓𝑣𝑣(𝑢𝑢) to 𝑥𝑥, 
and consequently a path from 𝑓𝑓𝑣𝑣(𝑢𝑢) to 𝑏𝑏. Since 𝑓𝑓𝑣𝑣(min(𝛤𝛤)) is finite, we can repeat this 
process beginning with the newly identified element of 𝑓𝑓𝑣𝑣(min(𝛤𝛤)) only finitely many 
times before a cycle is formed. However, that cycle must have length zero since 𝛥𝛥 
contains no cycles of greater length. As such, the final element of 𝑓𝑓𝑣𝑣(𝑢𝑢) produced is in 
min(𝑓𝑓(𝛤𝛤)) since there is nothing below it in 𝑓𝑓(𝛤𝛤). Thus, min(𝑓𝑓(𝛤𝛤)) is non-empty. 
We now show that, min(𝑓𝑓(𝛤𝛤)) is in fact finite. In particular, min(𝑓𝑓(𝛤𝛤)) is a subset of a 
finite set, namely 𝑓𝑓𝑣𝑣(min(𝛤𝛤)), so it too is finite. Let 𝑥𝑥∈min(𝑓𝑓(𝛤𝛤)). Then there exists an 
element 𝑏𝑏∈𝑓𝑓𝑣𝑣
−1(𝑥𝑥) and at least one path 𝛾𝛾 from a basic element 𝑎𝑎∈min(𝛤𝛤) to 𝑏𝑏. The 
image of 𝛾𝛾 under 𝑓𝑓 is a path in 𝑓𝑓(𝛤𝛤) from 𝑓𝑓𝑣𝑣(𝑏𝑏) to 𝑥𝑥. Since 𝑥𝑥 is minimal in 𝑓𝑓(𝛤𝛤), the 
only paths that terminate at 𝑥𝑥 are zero paths. Thus 𝑓𝑓𝑣𝑣(𝑏𝑏) = 𝑥𝑥. Since 𝑥𝑥 was a generic 
element of min(𝑓𝑓(𝛤𝛤)), every element of min(𝑓𝑓(𝛤𝛤)) is the image of a basic element of 𝛤𝛤. 
That is min(𝑓𝑓(𝛤𝛤)) ⊆𝑓𝑓𝑣𝑣(min(𝛤𝛤)), so it’s finite. 

Axiom 2 Next we prove that 𝒇𝒇(𝜞𝜞) = 𝐦𝐦𝐦𝐦𝐦𝐦(𝒇𝒇(𝜞𝜞)) ↑. Let 𝒙𝒙 be an element of 𝒇𝒇(𝜞𝜞). We aim 
to show that there exists a path from a basic element of 𝒇𝒇(𝜞𝜞) to 𝒙𝒙. Let 𝒃𝒃 be an element of 
𝜞𝜞 which maps to 𝒙𝒙 under application of 𝒇𝒇. Then, since 𝜞𝜞 is an assembly space, we know 
there exists at least one path, 𝜸𝜸 from a basic element of 𝜞𝜞, say 𝒂𝒂∈𝐦𝐦𝐦𝐦𝐦𝐦(𝜞𝜞), to 𝒃𝒃. The 
image of this path in 𝒇𝒇(𝜞𝜞) is itself a path from 𝒇𝒇𝒗𝒗(𝒂𝒂) to 𝒙𝒙, namely 𝒇𝒇𝒆𝒆(𝜸𝜸). If 𝒇𝒇𝒗𝒗(𝒂𝒂) is a 
basic element of 𝒇𝒇(𝜞𝜞) the we are done. Otherwise, we can use the processes described in 
the proof of Axiom 1 to construct a path from 𝒇𝒇𝒗𝒗(𝒂𝒂) through basic and non-basic 
elements which will ultimately terminate at a basic element. Composing this path with 
𝒇𝒇𝒆𝒆(𝜸𝜸) then yields a path from a basic element to 𝒙𝒙. As such, every element of 𝒇𝒇(𝜞𝜞) is 
above at least one basic element of 𝒇𝒇(𝜞𝜞), i.e. 𝒇𝒇(𝜞𝜞) = 𝐦𝐦𝐦𝐦𝐦𝐦(𝒇𝒇(𝜞𝜞)) ↑. 
Axiom 3 We now must show that for every edge 𝒂𝒂∈𝑬𝑬(𝒇𝒇(𝜞𝜞)) with 𝒂𝒂∼[𝒛𝒛𝒛𝒛] and 
𝝋𝝋(𝒂𝒂) = 𝒚𝒚, then there exists an edge 𝒃𝒃∈𝑬𝑬(𝒇𝒇(𝜞𝜞)) with 𝒃𝒃∼[𝒛𝒛𝒛𝒛] and 𝝋𝝋(𝒃𝒃) = 𝒙𝒙. To see 
that this is the case, take 𝒂𝒂 as described. Then there exists an edge 𝒖𝒖∈𝒇𝒇𝒆𝒆
−𝟏𝟏(𝒂𝒂) in 𝜞𝜞 with 
𝒖𝒖∼[𝒓𝒓𝒓𝒓], 𝒇𝒇𝒗𝒗(𝒓𝒓) = 𝒛𝒛, 𝒇𝒇𝒗𝒗(𝒒𝒒) = 𝒚𝒚 and 𝝓𝝓(𝒖𝒖) = 𝒑𝒑. Since 𝜞𝜞 is an assembly space, there 
exists an edge 𝒗𝒗∈𝑬𝑬(𝜞𝜞) with 𝒗𝒗∼[𝒓𝒓𝒓𝒓] and 𝝓𝝓(𝒗𝒗) = 𝒒𝒒. The commutivity property of 
assembly maps then gives us 𝝋𝝋(𝒇𝒇𝒆𝒆(𝒗𝒗)) = 𝒇𝒇𝒗𝒗(𝝓𝝓(𝒗𝒗)) = 𝒇𝒇𝒗𝒗(𝒒𝒒) = 𝒚𝒚. Calling 𝒇𝒇𝒗𝒗(𝒑𝒑) = 𝒙𝒙 
we then have an edge in 𝒇𝒇(𝜞𝜞), namely 𝒇𝒇𝒆𝒆(𝒗𝒗), which terminates at 𝒛𝒛 and is labeled as 𝒚𝒚. 
This satisfies Axiom 3. 
 
 
∎ 
7. The Assembly Index 
This final section turns to the definition and computation of the assembly index, a measure of 
how directly an object can be constructed from basic objects. 
Definition 18. The cardinality of an assembly space (𝛤𝛤, 𝜙𝜙) is the cardinality of the 
underlying quiver’s vertex set, |𝑉𝑉(𝛤𝛤)|. The augmented cardinality of the (𝛤𝛤, 𝜙𝜙) with basis 𝐵𝐵𝛤𝛤 
is |𝑉𝑉(𝛤𝛤)\𝐵𝐵𝛤𝛤| = |𝑉𝑉(𝛤𝛤)| −|𝐵𝐵𝛤𝛤|. 
Definition 19. The assembly index 𝑐𝑐𝛤𝛤(𝑥𝑥) of a finite object 𝑥𝑥∈𝛤𝛤 is the minimal augmented 
cardinality of all rooted assembly subspaces containing 𝑥𝑥. This can be written 𝑐𝑐(𝑥𝑥) when the 
relevant assembly space 𝛤𝛤 is clear from context. 
4.1 Bounds on the Assembly Index 
First of all, we can bound the assembly index of an object from above by computing the 
assembly index of that object in a rooted subspace. Essentially, since assembly subspace 
generally has fewer edges, there are fewer “shortcuts” to assembly the giving object. 
Lemma 6. Let 𝑋𝑋 be an assembly space and 𝑌𝑌 a rooted assembly subspace of 𝑋𝑋. For every 
finite 𝑦𝑦∈𝑌𝑌, the assembly index of 𝑦𝑦 in 𝑌𝑌 is greater than or equal to the assembly index of 𝑦𝑦 
in 𝑋𝑋. That is, 𝑐𝑐𝑌𝑌(𝑦𝑦) ≥𝑐𝑐𝑋𝑋(𝑦𝑦) for all 𝑦𝑦∈𝑌𝑌. 
Proof. Let 𝑦𝑦∈𝑌𝑌 and suppose 𝑐𝑐𝑌𝑌(𝑦𝑦) < 𝑐𝑐𝑋𝑋(𝑦𝑦). Then there exists a rooted assembly subspace 
𝑍𝑍⊆𝑌𝑌 containing 𝑦𝑦 such that |𝑍𝑍\𝐵𝐵𝑍𝑍| = 𝑐𝑐𝑌𝑌(𝑦𝑦). But, by the transitivity of subset inclusion 
(lemma 3) 𝑍𝑍 is a rooted assembly subspace of 𝑋𝑋. But if that’s the case, there exists a rooted 
assembly subspace of 𝑋𝑋 with augmented cardinality less than 𝑐𝑐𝑋𝑋(𝑦𝑦), namely 𝑍𝑍; a 

contradiction. 
 
∎ 
 
Since the lower quiver of an object 𝑥𝑥 is a rooted assembly subspace, we know the assembly 
index of the object in 𝑥𝑥↓ bounds the real assembly index of the object from above. However, 
we can do better – 𝑐𝑐𝛤𝛤(𝑥𝑥) = 𝑐𝑐𝑥𝑥↓(𝑥𝑥). This is a very powerful result as it allows us any 
computational approaches aiming to compute 𝑐𝑐(𝑥𝑥) to focus only on the objects below 𝑥𝑥. 
Theorem 2. Let 𝛤𝛤 be an assembly space and let 𝑥𝑥∈𝛤𝛤 be finite. Then 𝑐𝑐𝛤𝛤(𝑥𝑥) = 𝑐𝑐𝑥𝑥↓(𝑥𝑥). 
Proof. Since 𝑥𝑥↓ is finite, we need only consider finite, rooted assembly subspaces of 𝛤𝛤. Let 
𝛥𝛥⊆𝛤𝛤 be such a subspace containing 𝑥𝑥, and suppose that 𝛥𝛥⊈𝑥𝑥↓. Let 𝑦𝑦∈𝛥𝛥 such that 𝑦𝑦∉
𝑥𝑥↓, then (𝛥𝛥\𝑦𝑦↑) is a rooted assembly subspace of 𝛤𝛤 containing 𝑥𝑥 with augmented 
cardinality strictly less than 𝛥𝛥. As such |𝛥𝛥\𝐵𝐵𝛥𝛥| ≠𝑐𝑐𝛤𝛤(𝑥𝑥). In other words, if 𝛥𝛥 is not a subspace 
of 𝑥𝑥↓, then it cannot have the augmented cardinality 𝑐𝑐𝛤𝛤(𝑥𝑥). Thus, by contrapositive if 
|𝛥𝛥\𝐵𝐵𝛥𝛥| = 𝑐𝑐𝛤𝛤(𝑥𝑥), then 𝛥𝛥⊆𝑥𝑥↓. Since 𝛥𝛥 is rooted in 𝛤𝛤, it must also be rooted in 𝑥𝑥↓. 
Therefore, if a rooted subspace of 𝛤𝛤 has the minimal augmented cardinality in 𝛤𝛤, it must be a 
rooted assembly subspace of 𝑥𝑥↓. This implies that 𝑐𝑐𝛤𝛤(𝑥𝑥) ≥𝑐𝑐𝑥𝑥↓(𝑥𝑥). Additionally, by lemma 
6, 𝑐𝑐𝛤𝛤(𝑥𝑥) ≤𝑐𝑐𝑥𝑥↓(𝑥𝑥). Then 𝑐𝑐𝛤𝛤(𝑥𝑥) = 𝑐𝑐𝑥𝑥↓(𝑥𝑥). 
 
∎ 
 
Finally, assembly maps allow us to place lower-bounds on the assembly index – the assembly 
index of the image of an object bounds the object’s actual assembly index below. In other 
words, we can place lower bounds on the assembly index of an object by mapping the 
assembly space into a simpler space and computing the assembly index there. 
Theorem 3. If 𝑓𝑓: 𝛤𝛤→𝛥𝛥 is an assembly map, then 𝑐𝑐𝑓𝑓(𝛤𝛤)(𝑓𝑓(𝑥𝑥)) ≤𝑐𝑐𝛤𝛤(𝑥𝑥) for all finite 𝑥𝑥∈𝛤𝛤. 
Proof. Let 𝛴𝛴⊆𝛤𝛤 be an assembly subspace containing 𝑥𝑥 with |𝛴𝛴\𝐵𝐵𝛴𝛴| = 𝑐𝑐𝛤𝛤(𝑥𝑥). The restriction 
of 𝑓𝑓 to 𝛴𝛴 is an assembly map 𝑓𝑓∗: 𝛴𝛴→𝑓𝑓(𝛤𝛤). Then we have 
|𝛴𝛴\𝐵𝐵𝛴𝛴|
≥|𝑓𝑓∗(𝛴𝛴\𝐵𝐵𝛴𝛴)|
= |𝑓𝑓∗(𝛴𝛴\𝐵𝐵𝛴𝛴) ∩(𝑓𝑓∗(𝛴𝛴)\𝐵𝐵𝑓𝑓∗(𝛴𝛴))| + |𝑓𝑓∗(𝛴𝛴\𝐵𝐵𝛴𝛴) ∩𝐵𝐵𝑓𝑓∗(𝛴𝛴)|
≥|𝑓𝑓∗(𝛴𝛴\𝐵𝐵𝛴𝛴) ∩(𝑓𝑓∗(𝛴𝛴)\𝐵𝐵𝑓𝑓∗(𝛴𝛴))|.
 
As an assembly map, 𝑓𝑓∗ maps basis elements of 𝛴𝛴 onto basis elements of 𝑓𝑓∗(𝛴𝛴). So every for 
𝑢𝑢∈𝑓𝑓∗(𝛴𝛴)\𝐵𝐵𝑓𝑓∗(𝛴𝛴), there exists a 𝑣𝑣∈𝛴𝛴\𝐵𝐵𝛴𝛴 such that 𝑓𝑓∗(𝑣𝑣) = 𝑢𝑢. This gives us 
𝑐𝑐𝛤𝛤
= |𝛴𝛴\𝐵𝐵𝛴𝛴|
≥|𝑓𝑓∗(𝛴𝛴\𝐵𝐵𝛴𝛴) ∩(𝑓𝑓∗(𝛴𝛴)\𝐵𝐵𝑓𝑓∗(𝛴𝛴))|
= |𝑓𝑓∗(𝛴𝛴)\𝐵𝐵𝑓𝑓∗(𝛴𝛴)|
≥𝑐𝑐𝑓𝑓(𝛤𝛤)(𝑓𝑓(𝑥𝑥)).
  
 

4.2  Computability and Algorithms 
Theorem 4. If 𝛤𝛤 is an assembly space and 𝑥𝑥∈𝛤𝛤 is finite, then 𝑐𝑐(𝑥𝑥) is computable. 
Proof. As shown in the proof of theorem 2, every rooted assembly subspace with minimal 
augmented cardinality and containing 𝑥𝑥 is a minimal rooted assembly subspace of 𝑥𝑥↓. Since 
𝑥𝑥 is finite, 𝑥𝑥↓ is finite, the set of assembly subspace of 𝑥𝑥↓ is finite, and each such subspace 
is finite. Consequently, the basis of each subspace is computable. As such, the set of all 
rooted subspaces is computable. The cardinality of each subspace is computable, so the set of 
cardinalities of all rooted subspaces is computable. Finally, the minimum of a finite set of 
natural numbers is computable. Therefore, 𝑐𝑐𝛤𝛤(𝑥𝑥) is computable. 
 
∎ 
An algorithm for finding the pathway assembly index of an object within an assembly subspace 
is described below. 
The Assembly Index in assembly space Γ ≡(Γ, 𝜙𝜙) of a target object 𝑡𝑡∈Γ, with basic objects 
𝐵𝐵⊆Γ. 
 
Function Main(B, t) 
Global Variable PA // the pathway assembly index 
Set PA = upper bound of assembly index + |B| 
AssemblyIndex(B, t) 
Return PA - |B| 
End Function 
Function AssemblyIndex(S, t) 
 
For each pair of objects s1, s2 ∈S 
 
 
If there exists an edge 𝑒𝑒~[𝑡𝑡𝑡𝑡1] with 𝜙𝜙(𝑒𝑒) = 𝑠𝑠2 and PA > |S ∪t|  
 
 
 
PA = |S ∪T| 
 
 
Else there exists an edge 𝑒𝑒~[𝑢𝑢𝑢𝑢1] with 𝜙𝜙(𝑒𝑒) = 𝑠𝑠2 for some u ∈Γ 
 
 
 
AssemblyIndex(Γ, S ∪u, t) 
 
 
End If 
 
End For 
End Function 
 
We have also defined above the Split-Branched Assembly Index. Calculation of this index can 
be more computationally tractable than the assembly index, as often a lower number of 
pathways will need to be enumerated.  An algorithm to calculate this index is shown below. 
The Split-Branched Assembly Index in assembly space Γ ≡(Γ , 𝜙𝜙) of a target object 𝑡𝑡∈Γ 
with, with basic objects 𝐵𝐵⊆𝑉𝑉(Γ) 
Function SplitBranchedAssemblyIndex(Γ, B, t, I) 
 
Set PA = upper bound of assembly index for t 
 
For each partition of U into connected sub-objects ΓP = {Γ1 … Γn} 
 
 
Set PartitionIndex = 0 
 
 
Partition UP into K = {{Γ11, … , Γ1i}, ൛Γ21, … , Γ2jൟ, … , {Γm1 … Γmk}} 
 
 
Where for each Kn, the Γnx are identical for all x 
 
 
For each Ki ∈K 
 
 
 
If Ki1 ∈B 
 
 
 
 
PartitionIndex +=  1 
 
 
 
Else 
 
 
 
 
PartitionIndex +=  SplitBranchedAssemblyIndex(Γ, B, Ki1) 

+ |Ki| −1 
 
 
End If 
 
End For 
 
 
PA = min (PartitionIndex, PA) 
 
End For 
 
Return PA 
End Function 
References 
1. 
S. M. Marshall, A. R. G. Murray, and L. Cronin, A Probabilistic Framework for 
Identifying Biosignatures Using Pathway Complexity. Phil. Trans. R. Soc. A 375, 
20160342 (2017). 
 
 
 

