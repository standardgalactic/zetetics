Theoretical Computer Science 920 (2022) 46–63
Contents lists available at ScienceDirect
Theoretical Computer Science
www.elsevier.com/locate/tcs
From reversible programming languages to reversible 
metalanguages
Robert Glück a, Robin Kaarsgaard c,∗, Tetsuo Yokoyama b
a DIKU, Department of Computer Science, University of Copenhagen, Denmark
b Department of Software Engineering, Nanzan University, Nagoya, Japan
c School of Informatics, University of Edinburgh, United Kingdom
a r t i c l e 
i n f o
a b s t r a c t
Article history:
Received 8 April 2020
Received in revised form 5 October 2021
Accepted 16 February 2022
Available online 22 February 2022
Keywords:
Formal semantics
Reversible programming
Recursion
Iteration
Partial injective functions
During the past decade reversible programming languages have been formalized using var-
ious established semantics frameworks. However, these semantics fail to effectively specify 
the distinct properties of reversible languages at the metalevel, even including the central 
question of whether the deﬁned language is reversible. In this paper, we build a met-
alanguage foundation for reversible languages from categorical principles, based on the 
category of sets and partial injective functions. We exemplify our approach by a step-by-
step development of the full semantics of an r-Turing complete reversible while-language 
with recursive procedures. The use of the metalanguage leads to a formalization of the 
reversible semantics. A language deﬁned in the metalanguage is guaranteed to have re-
versibility and inverse semantics. Also, program inverters for this language are obtained for 
free. We further discuss applications and directions for reversible semantics.
© 2022 Elsevier B.V. All rights reserved.
1. Introduction
Over the last ten years, reversible programming languages ranging from imperative to functional and object-oriented 
languages have been formalized using established semantics frameworks, such as state transition functions, structural op-
erational semantics, and recently, denotational semantics (e.g. [1–4]). These frameworks, which have been used to provide 
meaning to a wide range of advanced language features and computation models (such as nondeterminism and parallelism), 
have turned out to be ineffective at specifying the distinct semantics properties of reversible languages. Even questions 
about the uniqueness of inverse semantics and the inversion of programs in reversible languages, and in particular the 
central question of whether a language is reversible or not, cannot be answered immediately.
In this paper, we build a metalanguage foundation for reversible languages based on the category PInj of sets and partial 
injective functions. The philosophy behind this approach is straightforward: Interpretations of syntax are composed in ways 
that preserve their injectivity. More speciﬁcally, interpretations of syntax are composed of sequential composition, Cartesian 
product, disjoint union, function inversion, iteration, and recursion. For this, we make use of the categorical foundation 
developed elsewhere (e.g. [5–7]; see also the fully abstract denotational semantics of Janus in [8] based on partial injective 
functions). Our approach exploits the fact that reversible programs have reversible semantics: We regard a program as 
(compositionally) reversible iff each of its meaningful subprograms is partially invertible. This allows us to provide a clean 
reversible semantics to a reversible language.
* Corresponding author.
E-mail addresses: glueck@acm.org (R. Glück), robin.kaarsgaard@ed.ac.uk (R. Kaarsgaard), tyokoyama@acm.org (T. Yokoyama).
https://doi.org/10.1016/j.tcs.2022.02.024
0304-3975/© 2022 Elsevier B.V. All rights reserved.

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
We demonstrate the aforementioned idea by a step-by-step development of a full formal semantics of the reversible 
procedural language R-WHILE including iteration and recursion. The use of the metalanguage leads to a formalization of the 
reversible semantics. Any language deﬁned in the metalanguage is guaranteed to have reversibility and inverse semantics. 
The reversibility of the language follows immediately from its semantics, and it can be seen from the signatures of semantic 
functions that the language is clean and without any hidden tracing. This metalanguage approach is independent of the 
speciﬁc details of the deﬁned language and can be extended to other ways of composing semantic functions, provided their 
injectivity is preserved. Also, program inverters for this language are obtained for free.
R-WHILE with procedures is a reversible while-language with structured control-ﬂow operators, and dynamic data struc-
tures [3,4].1 The language is reversibly universal (r-Turing complete), which means that it is computationally as powerful 
as any reversible programming language can be. It has features representative of reversible imperative and functional lan-
guages, including reversible assignments, pattern matching, and inverse invocation of recursive procedures.
The metalanguage used here has a distinct property familiar from reversible programming: It is not possible to deﬁne an 
irreversible (non-injective) language semantics. To ensure reversibility, conventional metalanguages require discipline in the 
formalization, e.g., when using conventional denotational semantics. In the case of operational semantics, which permits the 
description of arbitrary relations, it is unclear how to restrict such an inference system to a purely reversible one without 
requiring an explicit proof of reversibility. A future direction of research can be to investigate extensions of the metalanguage 
to capture other forms of composition and language features, which may include object-oriented features, combinators, and 
machine languages.
Overview: Section 2 introduces the elements of the formal semantics, and Section 3 describes the reversible language
R-WHILE with procedures. In Section 4, the formal semantics of the language is developed step-by-step. Section 5 demon-
strates the extension of the language and equational reasoning. Section 6 and Section 7 offer related work, concluding 
remarks, and directions for future work. We assume that the reader is familiar with the basic notions of reversible lan-
guages (e.g., [2]) and formal semantics (e.g., [9]).
Extensions: This paper is an extended version of a paper [10] presented at the workshop on Reversibility in Programming, 
Languages, and Automata (RPLA 2019). Aside from a number of corrections and extensions throughout the paper serving to 
make exposition more clear (in Section 2, Section 3, and Section 4), we also explicate how one can extend the syntax and 
semantics of a reversible language with a number of useful features (Section 5) and perform equational reasoning when we 
use the presented specialized metalanguage L (Section 4.8).
2. Elements of the formal semantics
This section is concerned with some of the details of sets and partial injective functions as they will be used in the 
following sections (compare, e.g., [11–13]). While the constructions mentioned in this section are extracted from the study of 
the category PInj of sets and partial injective functions, no categorical background is assumed (though a basic understanding 
of sets, partial functions, and domain theory is).
2.1. Composition and inversion
Partial functions are ordinary functions, save for the fact that they may be undeﬁned on parts of their domain. To indicate 
that a partial function X
f−→Y is undeﬁned on some x0 ∈X (e.g., in the deﬁnition of a piecewise function), we use symbol ↑
and write f (x0) =↑. A partial function is injective iff whenever f (x) and f (y) are both deﬁned and f (x) = f (y), it is also 
the case that x = y. Injectivity is preserved by composition (i.e., if X
f−→Y and Y
g−→Z are both partial injective functions so 
is X
g◦f
−−→Z), and each identity function X
idX
−−→X is trivially injective.
Partial injective functions can be inverted in a unique way: for every partial injective function X
f−→Y there exists a 
unique partial injective function Y
f †
−→X which undoes whatever f does, in the sense that f ◦f † ◦f = f , and, vice versa, 
f † ◦f ◦f † = f †.
Aside from sequential composition, partial injective functions can also be composed in parallel in two ways. The ﬁrst is 
using the Cartesian product of sets X and Y , which we denote X ⊗Y . If X
f−→X′ and Y
g−→Y ′ are partial injective functions, 
we can form a new partial injective function on the Cartesian product, X ⊗Y
f ⊗g
−−→X′ ⊗Y ′, by ( f ⊗g)(x, y) = ( f (x), g(y)). 
Note, however, that we do not have projections (such as X ⊗Y π1
−→X given by π1(x, y) = x) available, as these are never 
injective. We will denote the unit, up to bijective correspondence, of the Cartesian product (any distinguished singleton set 
will do) by 1. For any set X, we shall call the bijection witnessing that 1 is the unit of the Cartesian product on the left by 
X
λX
−→1 ⊗X, and on the right by X
ρX
−→X ⊗1.
Another parallel composition is given on the disjoint union of sets X and Y , which we denote X ⊕Y . We think of elements 
of X ⊕Y as being tagged with either left (inl ·) or right (inr ·) depending on their set of origin; for example, if x ∈X then 
1 An online interpreter for R-WHILE with procedures and the example program in this paper are available at http://tetsuo .jp /ref /RPLA2019.
47

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
inl x ∈X ⊕Y , and if y ∈Y then inr y ∈X ⊕Y . Up to bijective correspondence, the unit of disjoint union is the empty set 
∅, which we will also denote as 0. The tagged union of partial injective functions X
f−→X′ and Y
g−→Y ′ is then a partial 
injective function of tagged unions, X ⊕X′
f ⊕g
−−→Y ⊕Y ′, performing a case analysis on the inputs and tagging outputs with 
their origin:
( f ⊕g)(x) =

inl f (x′)
if x = inl x′
inr g(x′)
if x = inr x′
While the Cartesian product lost its projections in the setting of partial injective functions, the disjoint union retains its 
usual injections: There are injections X κ1
−→X ⊕Y and Y κ2
−→X ⊕Y given by κ1(x) = inl x and κ2(y) = inr y. Note in particular 
that since we consider partial injective functions, these have partial inverses κ†
i (sometimes called quasiprojections) which 
remove the tag, but are only deﬁned for elements from the i’th part of the union. For example, X ⊕Y
κ†
1
−→X is given by 
κ†
1(inl x) = x and κ†
1(inr y) =↑.
Finally, note the interactions between the Cartesian product and disjoint union: X ⊗0 is empty for all sets X, and 
analogous to the behavior of addition and multiplication in a (semi)ring, there is a bijective correspondence (given by the 
so-called distributor) between X ⊗(Y ⊕Z) and (X ⊗Y) ⊕(X ⊗Z) for all sets X, Y, Z.
2.2. Fixed points and iteration
Both sets and partial injective functions are well-behaved when it comes to recursive deﬁnitions. For sets, any recursive 
deﬁnition of a set involving only disjoint unions, Cartesian products, and already deﬁned sets (including 0 and 1) has a 
unique least and greatest solution: As is usual in domain theory, we use μX ... for the least solution (the least ﬁxed point) 
and ν X ... for the greatest solution (the greatest ﬁxed point). For example, the set of ﬂat lists with entries taken from a set 
A is given by the least ﬁxed point μX.1 ⊕(A ⊗X).
A useful property of partial functions, as opposed to total ones, is that the set of all partial functions with speciﬁed 
domain and target forms a directed complete partial order. This has useful consequences for the recursive description of 
partial injective functions. In particular, any continuous function PInj(X, Y) →PInj(X, Y) has a least ﬁxed point (where 
PInj(X, Y) denotes the set of partial injective functions between sets X and Y ). By its deﬁnition, the least ﬁx point must be 
a partial injective function X →Y (i.e., an element of PInj(X, Y)).
For the continuity requirement, we note that all previously presented operations on partial injective functions are con-
tinuous (i.e., sequential composition, partial inversion, parallel composition using Cartesian products and disjoint unions, 
as well as the trace discussed below), so any function involving only these operations is guaranteed to be continuous. To 
this end, it is shown in [6] that continuity in PInj amounts to preserving joins of partial functions (i.e., unions of function 
graphs), and continuity of sequential composition, partial inversion, and traces is shown. For parallel composition using 
Cartesian products and disjoint sums, the join characterization of continuity means that this reduces to the well-known 
properties of set-theoretic union of (X ∪X′) ⊗Y = (X ⊗Y) ∪(X′ ⊗Y) and (X ∪X′) ⊕Y = (X ⊕Y) ∪(X′ ⊕Y).
Finally, partial injective functions can also be tail-recursively described using the trace operator. Intuitively, the trace of 
a partial injective function X ⊕U
f−→Y ⊕U is a function X
Tr( f )
−−−→Y given as follows: If f (inl x) = inl y for some y, this y
is returned directly. Otherwise, if f is deﬁned at inl x, it must be the case that f (inl x) = inr u for some u. If this is the 
case, this inr u is fed back into f , and the feedback loop continues until it either terminates to some inl y, which is then 
returned, or does not, in which case the trace is undeﬁned at x.
This trace operator may be described as a function PInj(U ⊕X, U ⊕Y) 
Tr
−→PInj(X, Y). It is most easily deﬁned using a 
tail-recursively described pretrace PInj(U ⊕X, U ⊕Y) 
pretrace
−−−−→PInj(U ⊕X, Y) given as follows:
pretrace( f )(x) =

pretrace( f )(inl y)
if f (x) = inl y
y
if f (x) = inr y
With this, it is deﬁned simply as Tr( f )(x) = pretrace( f )(inr x).
The data ﬂow of Tr( f ) is typically illustrated using the diagram
in which the ﬂow is from left to right and the feedback loop represents the repeated application of f to outputs of type U.
While less general than the ﬁxed point (which can be used to describe arbitrary recursion), this tail recursion operator 
is very well behaved with respect to inversion, as it satisﬁes
48

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
m ::= p ··· p
p ::= proc f (q) c; return q;
c ::= x = e | q ⇐q | c;c | if e then c else c ﬁe | from e do c loop c until e
q ::= x | s | (q.q) | call f (q) | uncall f (q)
e ::= x | s | (e.e) | hd(e) | tl(e) | =? e e
Fig. 1. Syntax of the reversible language R-WHILE with procedures.
Tr( f †) = Tr( f )†
for all partial injective functions U ⊕X
f−→U ⊕Y . (Formally, the trace operator can also be deﬁned as a ﬁxed point using 
the trace formula, see [14].)
2.3. Summary of the metalanguage
Collecting the injective constructs for the formal semantics introduced above, we can specify a clean reversible metalan-
guage L for describing objects of PInj:
f ::= a | κi | idX | μφ. f | f ⊕f | f ⊗f | f ◦f | Tr( f ) | f † | φ .
For any expression in L, the least ﬁxed point exists. The formal argument of the least ﬁxed point φ is a partial injective 
function. L is closed under inversion, and the inverse semantics of each expression is unique and immediate. Any language 
described by the metalanguage is (compositionally) reversible. L is expressive enough to fully formalize the semantics of 
reversibly-universal languages, as demonstrated below for R-WHILE.
An atomic function a can be any auxiliary partial injective function. In what follows, we use the following four injective 
helper functions: i) X
ρX
−→X ⊗1, deﬁned above, ii) 1 
constv
−−−→V deﬁned by constv(⋆) = v where ⋆is the unique element in 1
and v is any value, and iii) (X ⊗Y) ⊗Z
assocr⊗
−−−−→X ⊗(Y ⊗Z) deﬁned by assocr⊗((x, y), z) = (x, (y, z)). By abuse of notation, 
Xi
κi
−→X1 ⊕(X2 ⊕(···(Xi ⊕···(Xn−1 ⊕Xn) ···)) returns the nested injection:
κi(x) =
⎧
⎪⎪⎪⎨
⎪⎪⎪⎩
inr(···(inr

	

i−1
(inl x))···)
if 1 ≤i < n
inr(···(inr

	

n−1
x)···)
if i = n
3. R-WHILE with reversible recursion and iteration
We describe the semantics of the reversible language R-WHILE with procedures informally, and illustrate it with a 
recursive program that translates inﬁx expressions to Polish notation, a classic translation that is reversible. The data domain 
of the language is tree-structured data (lists known from Lisp and many modern languages). Readers familiar with reversible 
programming can skip to Example 1 below and return to the informal description later.
The syntax of the language [4] is shown in Fig. 1. A program m is a sequence of procedures p ··· p, where the ﬁrst 
procedure is the main procedure. A procedure p has a name f , an argument pattern q, a command c as its body, and a 
return pattern q. The input to and output from a procedure is through the argument and return patterns, respectively. Each 
procedure has a single argument and a single return value. Thus, it is convenient to compose and decompose input and 
output values by patterns. Fig. 2 shows example procedures.
A command c is either a reversible assignment x = e, a reversible replacement q ⇐q, a reversible conditional if...ﬁ, or a 
reversible loop from...until.
The variable x in a reversible assignment x = e must not occur in expression e, which calculates a value (e.g., x = x is 
not well formed). The assignment sets x to the value of e if the value of x is nil and sets x to nil if the values of x and 
e are equal; otherwise, the assignment is undeﬁned. In other words, x is exclusively set or reset depending on its value. 
The assignment is only deﬁned for these two cases. This deﬁnition ensures the reversibility of assignments. The hat  of 
assignment operator = is reminiscent of an exclusive-or operator. For example, if x is nil then x = y sets x to the value of y. 
If x and y are equal then x = y resets x to nil. In the ﬁrst case, the value of y is duplicated; in the second case, the value of 
x is nil-cleared using the value of y. The variables that occur in the expression on the right side, here y, are never changed, 
only x is updated reversibly [15].
A reversible replacement q1 ⇐q2 arranges values according to patterns q1 and q2. For example, (y.x) ⇐(x.y) swaps the 
values of variables x and y. In contrast to an assignment, no value can be duplicated by a reversible replacement. Before the 
value constructed by q2 on the right side is matched with q1 on the left side, all variables in q2 are nil-cleared. This means 
that the same variables may occur on both sides of a replacement (unlike an assignment).
49

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
1: proc in2preﬁx(t)
2:
y ⇐call pre((t.nil ));
3:
return y;
4:
5: proc pre2inﬁx(y)
6:
(t.nil ) ⇐uncall pre(y);
7:
return t;
8:
9: proc pre((t.y))
10:
if =? t 0
then
11:
y ⇐(t.y)
12:
else
13:
(l.(d.r)) ⇐t;
14:
y ⇐call pre((r.y));
15:
y ⇐call pre((l.y));
16:
y ⇐(d.y)
17:
ﬁ=? hd(y) 0 ;
18:
return y;
(* inﬁx exp to Polish notation *)
(* call preorder traversal
*)
(* Polish notation to inﬁx exp *)
(* uncall preorder traversal
*)
(* recursive preorder traversal *)
(* tree t is a leaf?
*)
(* add leaf to list y
*)
(* decompose tree t
*)
(* traverse right subtree r
*)
(* traverse left subtree l
*)
(* add label d to list y
*)
(* head of list y is a leaf?
*)
Fig. 2. Translation between inﬁx expressions and Polish notation in R-WHILE.
Patterns play a central role in the construction and deconstruction of values, and are used in both ways in the language. 
For example, replacement (t.y) ⇐y decomposes the value of y on the right side by the pattern (t.y) on the left side into 
head t and tail y provided the original value is indeed a pair and the value of t is initially nil. Another example is y ⇐(t.y)
that pairs the values of t and y by the pattern (t.y) on the right side, nil-clears t and y, and binds the new pair to y on 
the left side. It is easy to see that sequence y ⇐(t.y); (t.y) ⇐y restores the original values of t and y.
A pattern q is a variable x, a symbol s, a pair of patterns (q.q), or an invocation or inverse invocation of a procedure 
by call f (q) or uncall f (q). All patterns are linear (no variable occurs more than once in a pattern). The semantics of a 
procedure uncall is the inverse semantics of a procedure call. Procedures can only be invoked in patterns, not in expressions. 
This will be formalized later. Examples can be seen in Fig. 2.
The conditional if...ﬁand the loop from...until are two control structures which are also found in other reversible ﬂowchart 
languages (e.g., [2]), and they work as follows: Compared to conventional control structures, they are equipped with asser-
tions. The exit of a conditional, ﬁe, is an assertion that must evaluate to true after the then-branch and to false after the 
else-branch. The entry of a loop, from e, is an assertion that must evaluate to true before entering the loop and to false after 
each iteration. The control structures are undeﬁned if their assertions do not evaluate as required.
Expressions are conventional. An expression e is either a variable x, a symbol s, or the application of an operator, i.e., 
constructor cons (· . ·), selectors head hd and tail tl, or equality test =?. An expression deﬁnes a partial function that is not 
necessarily injective (e.g., hd, tl are not injective). Other operators can easily be added to expressions.
Variables in a program are denoted by small letters, such as l, d, r, and symbols are underlined, such as nil, 0, 1.
Example 1. The translation of inﬁx expressions into Polish notation, and vice versa, has many practical applications. Because 
this function is injective, it can be programmed cleanly in a reversible language and run in both directions.
In R-WHILE inﬁx expressions can be represented by full binary trees
tree ::= 0 | (tree.(1. tree)) ,
where symbols 0 and 1 stand for an operand (leaf) and a binary operator (inner label) in an expression, respectively. To 
keep it simple, we will only use these two symbols in expressions. The corresponding expressions in Polish notation can be 
represented by proper lists
list ::= nil | (0. list) | (1. list) ,
where nil stands for the empty list.
Fig. 2 shows the recursive procedure pre that reversibly translates an inﬁx expression into a preﬁx expression (Polish 
notation) by a preorder traversal of the full binary tree t. Procedure pre is called and uncalled in the two procedures 
in2preﬁx and pre2inﬁx to translate to Polish notation, and vice versa. For example, the inﬁx expression
t = ((0.(1. 0)).(1. 0))
translates to Polish notation
y = (1.(1.(0.(0.(0. nil))))) .
Using syntactic sugar, this can be written as the translation of an inﬁx expression ((0 1 0) 1 0) to Polish notation (1 1 0 0 0).
In in2preﬁx the translation is invoked by a call to pre (line 2)
y ⇐call pre((t.nil)) ,
50

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
where the argument of the call is a pair (t.nil) of t and the empty list nil, and the result is matched with trivial pattern y, 
which binds it to y.
In pre2inﬁx the inverse translation of pre is invoked by an uncall of pre (line 6)
(t.nil) ⇐uncall pre(y) ,
where y is the argument of the uncall and t is picked from the resulting pair. Given y, uncall pre computes the inﬁx 
expression t. The uncall invokes the inverse computation of the recursive traversal implemented by pre.
The body of pre is a reversible conditional if...ﬁ(lines 10–17) with the entry test (=? t 0) and the exit assertion 
(=? hd(y) 0). If t is a leaf 0 then t is added to list y by y ⇐(t.y) (line 11). Otherwise, in the else-branch, pre calls it-
self recursively on the right and left subtrees r and l with the current list y (lines 14–15). The two subtrees and the label 
d are selected from t by (l.(d.r)) ⇐t. List y is built from right to left, so d is added to y after both subtrees are translated 
(line 16). The exit assertion (=? hd(y) 0) is always true after the then-branch and always false after the else-branch provided 
t is a correct inﬁx expression.
The arity of all procedures is one, so it is convenient to decompose the argument value by pattern (t.y) already in 
the head of pre (line 9). Due to the reversibility of the language, pre performs a deterministic traversal in both directions 
when invoked by call and uncall (lines 2, 6). Inverting the traversal of binary trees, not only of full binary trees, is a classic 
programming problem for which related reversible solutions were given [4]. The reversible semantics that follows in the 
next section underpins all these solutions.
4. An intrinsically reversible semantics
In this section, we illustrate the principle of reversible semantics by constructing a denotational semantics for R-WHILE
with procedures using sets and partial injective functions. This is done ﬁrst by constructing the domains of computation, 
and then constructing an interpretation of each syntactic construct, proceeding by syntactic category. While this results in 
a semantics for R-WHILE with procedures, we stress rather the use of abstract concepts (e.g., Cartesian products, disjoint 
unions, traces, and ﬁxed points) to construct these semantics in reversible programming languages in general, rather than 
the concrete realization of R-WHILE with procedures.
In the following, we use standard notations of denotational semantics [9] including brackets for semantic functions ·, 
mapping syntactic constructs to semantic ones. Note, in particular, the use of semantic functions parameterized by a state or 
program context – see, e.g., patterns in Section 4.3). Such an interpretation should not be regarded as a single function, but 
rather as a family of functions indexed by the appropriate parameter (e.g., a state or program context).
4.1. States and values
We begin by constructing the appropriate domains of computation for values and states. To do this, we assume that we 
are given an alphabet 	 of semantic representations of symbols, elements of which we denote using an overline, e.g., 0, nil, 
etc. Note, in particular, the distinction between semantic symbols (e.g., 0, nil) and their syntactic representations (e.g., 0, nil). 
As is usual, we will assume that these two sets are distinct but in bijective correspondence.
The set of values V is then constructed as the set of binary trees with elements from 	 at the leaves. More formally, 
this set can be constructed by the least ﬁxed point of sets V = μX.	 ⊕(X ⊗X). If t1 and t2 are such binary trees, we will 
use the notation t1 • t2 (read: “t1 cons t2”) to mean the binary tree constructed from t1 and t2, i.e.,
t1
t2
A state associates each variable with a value. The set of states 
 can be constructed as colists of values (i.e., lists of in-
ﬁnite length), that is, 
 = V ⊗V ⊗··· (explicitly, this is constructed as the greatest ﬁxed point ν X.I ⊕(V ⊗X) where 
I is identity). Owing to this intuition, we will write states as inﬁnite vectors of values, e.g., (v1, v2, ...). Note that colists 
arising from computational states will all be ﬁnitely supported, i.e., they will only contain ﬁnitely many non-nil values. By 
associating each variable in the language (of which there are countably many) with a distinct index, a state is then precisely 
a description of the contents of all variables. In keeping with this principle, we shall write variables as x1, x2, x3, etc. rather 
than (as is usual) as x, y, z, etc.
4.2. Expressions
In irreversible languages, expressions are usually interpreted as partial functions of the signature 
 →V . Because mul-
tiple states result in the same value, the function is not injective and cannot be an atomic function a in the metalanguage 
L. Instead, expressions are interpreted as partial injective functions with the signature:
51

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63

 ⊗V
Ee
−−→
 ⊗V .
Regardless of their concrete form, interpretations of expressions are deﬁned as
Ee1(σ, v) =
⎧
⎪⎨
⎪⎩
(σ,E′e1σ )
if v = nil
(σ, nil)
if v = E′e1σ ̸= nil
↑
otherwise
where E′eσ ∈V , given below, is understood as the value of e in the state σ . Precisely, a family of the inﬁnite number of 
the semantic functions E′· is indexed by the subscript σ . When v in Ee1(σ, v) is nil, the value of e1 in σ is obtained. 
When v is equal to the value of e1 in σ , nil is obtained. In both cases, σ is left unchanged. Otherwise, the meaning is 
undeﬁned. In other words, when a state σ is ﬁxed, Ee(σ, v) is only ever deﬁned on two choices of v, namely v = nil and 
v = E′e1σ . In these two cases, it sends (σ, nil) to (σ, E′e1σ ) and vice versa; thus, it is injective. Another way to say 
this is that the semantics function deﬁnes a reversible update [15] of the value argument with the state σ kept unchanged, 
which also implies that it is self-inverse. This is the general principle hidden here.
Concretely, E′ is deﬁned as follows, depending on the form of e:
E′xiσ = vi
where σ = (v1, v2,..., vi,...)
E′ s1 σ = s1
E′(e1.e2)σ = E′e1σ • E′e2σ
E′hd(e1)σ =

v1
if E′e1σ = v1 • v2
↑
otherwise
E′tl(e1)σ =

v2
if E′e1σ = v1 • v2
↑
otherwise
E′=? e1 e2σ =

nil • nil
if E′e1σ = E′e2σ
nil
otherwise
As such, the meaning of a variable in a state is given by its contents, and the meaning of a symbol is given by its direct 
representation in the alphabet 	. The meaning of the cons of expressions is given by the cons of their meanings, while the 
head (resp., tail) of an expression takes the head (resp. tail) of its meaning, diverging if not of this form. The meaning of 
equality check =? returns a distinct value depending on e1 and e2 having the same value. The deﬁnition uses the convention 
that nil is considered to be false, and any other value to be true.
It is obvious that more operators can be added to this list. Note that an element v ∈V is uniquely associated with a 
(necessarily injective) function 1 →V , which maps the unique element of 1 to v. This justiﬁes the fact that the interpreta-
tion of an expression may diverge (as is the case for, e.g., E′hd(e1)σ ).
The use of a non-injective function in the deﬁnition of an injective function is often found in the context of reversible 
computation. Above, Ee, a reversible update deﬁned using non-injective E′e, is injective for any e. Because Ee is not 
deﬁned exclusively in terms of the metalanguage, we regard it as deﬁning an atomic function a of L.
4.3. Patterns
Since patterns may include procedure invocation, the meaning of a pattern depends on the program context φ in which 
it is interpreted. The program context φ is the disjoint union of the meaning of all procedures fi in the program: φ =
f1 ⊕( f2 ⊕(···( fn−1 ⊕fn)) ···). Program contexts are constructed at the level of programs as we shall see in Section 4.7. 
Patterns in a program context are all interpreted as partial injective functions with the signature

Qqφ
−−−−→
 ⊗V .
In particular, note that this signature allows patterns to alter the state. Indeed, patterns may have side effects (here, in the 
form of altering the store): They should be regarded as a means to prepare a given value in a state, in such a way that may 
alter the state it began with. To more easily deﬁne the interpretation of patterns, we use injective helper functions: One is 

 
extracti
−−−−→
 ⊗V given by extracti(v1, ..., vi−1, vi, ...) = ((v1, ..., vi−1, nil, ...), vi) (extracting the i’th value from the state) 
and V ⊗V
cons
−−→V given by cons(v1, v2) = v1 • v2. The interpretation of patterns is then deﬁned as follows, depending on 
the form of q:
Qx jφ = extract j
Qsφ = (id
 ⊗consts) ◦ρ
52

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
Qcall fi(q1)φ = (id
 ⊗(κ†
i ◦φ ◦κi)) ◦Qq1φ
Quncall fi(q1)φ = (id
 ⊗(κ†
i ◦φ† ◦κi)) ◦Qq1φ
Q(q1.q2)φ = (id
 ⊗cons) ◦assocr⊗◦(Qq2φ ⊗idV ) ◦Qq1φ
The meaning of a variable, as a pattern, is to simultaneously extract its contents and clear it, as handled by the extracti
function. The meaning of a symbol is given by the bijection witnessing on the right ρ
, which yields a new state and the 
unique element ⋆, and then the consts function, which takes the latter ⋆and yields the value s. A procedure call call fi(q1)
is interpreted as passing the value of q1 to the i’th component of the program context φ and extracting from the i’th 
component afterwards, which, as we will see in Section 4.8, corresponds precisely to invoking the i’th procedure. Uncall 
to a procedure is handled analogously, but using the inverse to the program context φ† instead. Finally, the meaning of a 
cons pattern (q1.q2) is as a kind of sequential composition. First, the interpretation of q2 results in a new state σ ′ and 
value v2. Then, the interpretation of q1 results in this new state σ ′ with v2 kept unchanged by idV , yielding a ﬁnal state 
σ ′′ and value v1. The injective helper function assocr⊗deﬁned in Section 2.3 rearranges the nested pair ((σ ′′, v1), v2) to 
(σ ′′, (v1, v2)). The two values v1 and v2 are then consed together using the injective helper function cons, ﬁnally resulting 
in the state σ ′′ and prepared value v1 • v2. Recall that no variable occurs more than once in a pattern. Hence, it does not 
matter whether a cons pattern (q1.q2) is interpreted from left to right, or vice versa.
Alternatively, uncall can be deﬁned using the inverted procedures instead of the inverse to the program context, φ†, 
provided the inverted procedures are in φ. We will see how to add the inverse procedures to φ in Section 4.8.
4.4. Predicates
The predicate interpretation provides a different way of interpreting expressions that are to be used to determine branch-
ing of control ﬂow. They are interpreted as partial injective functions with the signature

T e
−−−→
 ⊕
 .
We use the convention that nil is false and the other values are true. The predicate interpretation of an expression e is 
deﬁned as follows:
T e1(σ) =

inl σ
if E′e1σ ̸= nil
inr σ
if E′e1σ = nil
As such, the predicate interpretation of e1 sends control ﬂow to the ﬁrst component if e1 is considered false in the given 
state, and to the second component if it is considered true. As we will see in Section 4.5, this style makes for a straightfor-
ward interpretation of conditional execution of commands (see also [5,16]).
4.5. Commands
Commands in R-WHILE with procedures are interpreted as invertible state transformations, i.e., as partial injective func-
tions with signature

Ccφ
−−−→
 .
The interpretation of commands is deﬁned as follows, depending on the syntactic form of c:
Cc1;c2φ = Cc2φ ◦Cc1φ
Cxi = e1φ = (Qxiφ)† ◦Ee1 ◦Qxiφ
Cq1 ⇐q2φ = (Qq1φ)† ◦Qq2φ
Cif e1 then c1 else c2 ﬁe2φ = T e2† ◦(Cc1φ ⊕Cc2φ) ◦T e1
Cfrom e1 do c1 loop c2 until e2φ = Tr

(Cc2φ ⊕id
) ◦T e2 ◦Cc1φ ◦T e1†
Note, in particular, the use of inverses to patterns and predicates in the deﬁnition above. The inverse to a predicate cor-
responds to its corresponding assertion, whereas the inverse to a pattern performs state preparation consuming (part of) a 
value (rather than, in the forward direction, value preparation consuming part of a state).
Pattern inverses are illustrated in both reversible assignments and pattern matching, each consisting of a value prepa-
ration (indeed, the expression interpretation can be seen as side-effect free value preparation), using the interpretation of 
patterns, followed by a state preparation using the inverse. Similarly, the interpretation of conditionals, which may be illus-
trated using the string diagram
53

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
where the upper Cc2φ and the lower Cc1φ correspond to the meaning of else and then branches, respectively, and loops, 
illustrated with the diagram
relies on predicate inverses: In both cases, they serve as conditional join points, corresponding to an assertion that e2
(respectively e1) is expected to be true when coming from the then branch of the conditional (respectively from the outside
of the loop), and false when coming from the else branch (respectively from the inside of the loop).
4.6. Procedures
Since for the sake of simplicity R-WHILE with procedures only uses local state, procedure deﬁnitions are interpreted (in 
a program context) as partial injective value transformations, i.e., partial injective functions of the form
V
P f φ
−−−−→V .
To deﬁne the interpretation of procedures, we use an injective helper function V
ξ−→
 ⊗V given by
ξ(v) = (#»o , v) ,
where #»o = (nil, nil, ...) is the state in which all variables are cleared (i.e., contain nil). This canonical state is the initial 
computation state in which all procedures are executed. A procedure deﬁnition in the program context φ is interpreted as
Pproc f (q1) c1; return q2φ = ξ † ◦Qq2φ ◦Cc1φ ◦(Qq1φ)† ◦ξ .
This deﬁnition should be read as follows: In the canonical state #»o , the state described by the inverse interpretation of the 
input pattern q1 is ﬁrst prepared. Then, the body of the procedure is executed, resulting in a new state which is then used 
to prepare a value as speciﬁed by interpretation of the output pattern q2. At this point, the system must again be in the 
canonical state #»o , which, if this is the case, can then be discarded, leaving only the output value.
4.7. Programs
Finally, at the level of programs, these are interpreted as the meaning of their topmost deﬁned procedure, and, as such, 
are interpreted as partial injective functions of the signature
V
Mm
−−−−→V .
Since procedures may be deﬁned to invoke themselves as well as other procedures, we need to wrap them in a ﬁxed point, 
passing the appropriate program context φ to each procedure interpretation. This yields the interpretation
Mp1 ··· pn = κ†
1 ◦(μφ.Pp1φ ⊕··· ⊕Ppnφ) ◦κ1 .
Note the inner interpretation of procedures p1 ··· pn as a disjoint union Pp1φ ⊕··· ⊕Ppnφ: This gives one large partial 
injective function, which behaves just the partial injective functions Ppiφ when inputs are injected into the i’th compo-
nent, save for the fact that outputs (if any) are also placed in the i’th component. This explains the need for injections κi
and quasiprojections κ†
i in the deﬁnition of procedure calls in Section 4.3.
The interpretations E′· and T · are atomic functions in the metalanguage L. The interpretation (M·, P·φ, and 
C·φ) maps syntax to injective (value, stores, . . . ) transformations (on stores, values). The injective (value, store, . . . ) trans-
formations can be expressed in L.
54

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
Ix = e ≡x = e
Iq1 ⇐q2 ≡q2 ⇐q1
Ic1;c2 ≡Ic2; Ic1
Iif e1 then c1 else c2 ﬁe2 ≡if e2 then Ic1 else Ic2 ﬁe1
Ifrom e1 do c1 loop c2 until e2 ≡from e2 do Ic1 loop Ic2 until e1
Ipproc fi(q1) c1; return q2; ≡proc f inv
i
(q2) RIc1; return q1;
Imp1 ··· pn ≡Ipp1 ··· Ippn
Fig. 3. A command inverter I, a procedure inverter Ip, and a program inverter Im for R-WHILE with procedures. R renames each called/uncalled 
procedure fi to its inverse f inv
i
without changing its meaning.
4.8. Applications of the semantics
In conventional programming languages, programs are not guaranteed to be injective, program inversion usually needs a 
global program analysis, and inverse interpretation requires extra computation overhead. However, owing to the formaliza-
tion, programs in object languages formalized in L are always injective, program inversion can be obtained by a recursive 
descendent transformation, and inverse interpretation often has no extra overhead. The intrinsic properties of the metalan-
guage are a great help in deriving rules for program inversion. For any command c, the inverse semantics (Ccφ)† can be a 
composition of the semantics of its components and traces, which can be mechanically obtained by properties of PInj [5]. 
For example, we have for a reversible replacement
(Cq1 ⇐q2φ)† = ((Qq1φ)† ◦Qq2φ)† = (Qq2φ)† ◦Qq1φ ,
and hence we obtain that the inverse semantics of replacement is
(Cq1 ⇐q2φ)† = Cq2 ⇐q1φ .
The right-hand sides of the semantic function of commands are mostly symmetric, and their inversion rules are obtained in 
a similar way (Fig. 3). The only inversion rule that requires some work to derive is the one for loops, which relies on the 
dinaturality law (see [17]) of traces, Tr((id ⊕g) ◦f ) = Tr( f ◦(id ⊕g)), or graphically
A similar asymmetry appears in the operational semantics of Janus [1], in which the inference rule for the loop can be 
either right or left recursive.
In the semantic function of patterns, the inverse semantics φ† of the program context deﬁnes the meaning of a procedure 
uncall. The inverse semantics of procedures are equal to the semantics of inverted procedures. This leads to an alternative 
formalization of the same meaning. First, the inverted procedures are added to the program context in addition to the 
original procedures:
μφ. P f1φ ⊕··· ⊕P fnφ ⊕(P f1φ)† ⊕··· ⊕(P fnφ)† .
Given such an extended program context φ, the access to the inverse semantics κ†
i ◦φ† ◦κi in the pattern execution 
Quncall fi(q1)φ(σ) (Section 4.3) can be replaced by κ†
n+i ◦φ ◦κn+i, i.e., accessing the n + i’th function.
Program equivalences.
Another application of the semantics, perhaps more familiar to readers with a background in classical 
programming languages, is for deriving semantic equivalences of program fragments. One such equivalence is the equiva-
lence of the replacement commands
q2 ⇐call fi(q1) ≡uncall fi(q2) ⇐q1
for all patterns q1, q2 and any procedure fi, as it holds for any program context φ that
55

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
Cq2 ⇐call fi(q1)φ = (Qq2φ)† ◦Qcall fi(q1)φ
= (Qq2φ)† ◦(id
 ⊕(κ†
i ◦φ ◦κi)) ◦Qq1φ
= (Qq2φ)† ◦(id
 ⊕(κ†
i ◦φ ◦κi))†† ◦Qq1φ
= (Qq2φ)† ◦(id
 ⊕(κ†
i ◦φ† ◦κi))† ◦Qq1φ
= ((id
 ⊕(κ†
i ◦φ† ◦κi)) ◦Qq2φ)† ◦Qq1φ
= (Quncall fi(q2)φ)† ◦Qq1φ
= Cuncall fi(q2) ⇐q1φ .
Similarly, we have the equivalence of the replacement commands
q2 ⇐uncall fi(q1) ≡call fi(q2) ⇐q1 .
By applying these equivalences, we see in action the familiar idea that uncalling nested procedure calls happens in reverse 
procedure call order, i.e.,
q2 ⇐call g(call f (q1))
≡
uncall g(q2) ⇐call f (q1)
≡
uncall f (uncall g(q2)) ⇐q1
and we obtain various other equivalences for replacements, such as
q2 ⇐uncall g(call f (q1))
≡
call g(q2) ⇐call f (q1)
≡
uncall f (call g(q2)) ⇐q1 .
It is easy to see the general principle that calls correspond to uncalls when they change sides in a replacement and that the 
order of nested calls and uncalls is reversed. This shows that the semantics is useful for deriving new equivalences that are 
not known in irreversible programming languages. Even further, since R-WHILE is a relatively simple ﬁrst-order language, 
given a suitable operational semantics, we expect soundness, computational adequacy, and full abstraction to all be provable 
(see analogous results in [5,8]). If this does turn out to be the case, the denotational semantics could also be used to derive 
contextual equivalences.
5. Extensions to R-WHILE and their semantics
In this section, we consider some syntactic extensions to R-WHILE, and show how to give semantics to these using 
the presented metalanguage. While they are presented for R-WHILE, it should be stressed that these are general reversible 
language constructs, and ought to ﬁt the vast majority of imperative reversible programming languages.
5.1. Skip, simple loops, and conditional execution
Arguably the simplest extension to R-WHILE we can consider is the skip command, which does absolutely nothing—it 
behaves as the identity. Introducing this requires extending the syntax of commands:
c ::= ··· | skip .
Though it may not be obvious, skip can be considered an alias for s ⇐s for any choice of symbol s. We then have
Cskipφ = Cs ⇐sφ = (Qsφ)† ◦Qsφ
and to support our claim, it suﬃces to show that the last term is equal to the identity:
((id
 ⊗consts) ◦ρ
)† ◦(id
 ⊗consts) ◦ρ
= ρ†

 ◦(id†

 ⊗const†
s) ◦(id
 ⊗consts) ◦ρ
= ρ†

 ◦((id†

 ◦id
) ⊗(const†
s ◦consts)) ◦ρ
= ρ†

 ◦ρ
= id
 .
Since both consts and id
 are total, it follows that (Qsφ)† ◦Qsφ = id
, and hence Cskipφ = id
, as expected.
56

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
Using skip as the empty command of R-WHILE allows us to derive some simpler versions of the ﬂow control constructs 
presented in the previous sections. For example, the one-armed conditional (similar to control in reversible circuit logic) can 
now be expressed as syntactic sugar for the conditional,
if e then c ﬁe′ ≡if e then c else skip ﬁe′ ,
and the simpler while-loop [3,5] can be seen as syntactic sugar for the loop,
from e loop c until e′ ≡from e do skip loop c until e′ .
The abort command cannot even “do nothing” such as the skip command, it always fails to reach a next state. Adding 
such a construct to R-WHILE requires extending the syntax of commands:
c ::= ··· | abort .
The command can be considered an alias for an impossible match s ⇐s′ where s ̸= s′ (e.g., let abort be an alias for 0 ⇐1). 
Hence, we have the interpretation Cabortφ(σ) =↑for any store σ , as expected.
5.2. Multiconditionals
Another simple extension to R-WHILE is the introduction of reversible multiconditionals or case-constructs: Where an 
ordinary (i.e., binary) reversible conditional if e1 then c1 else c2 ﬁe′
1 has two branches and two predicates to distinguish 
them, an n-armed reversible multiconditional has n branches and 2n predicates to distinguish them, extending the syntax 
of commands:
c ::= ··· | case e1 : c1 : e′
1; ··· ; en : cn : e′
n esac .
With this syntax in place, the interpretation of an n-armed reversible multiconditional can be speciﬁed by extending the 
semantics function for commands using the recursive deﬁnition
Ccase e1 : c1 : e′
1; ··· ; en : cn : e′
n esacφ =

T e′
1† ◦(Cc1φ ⊕Ccase e2 : c2 : e′
2; ··· ; en : cn : e′
n esacφ) ◦T e1
if n ≥1
Cabortφ
if n = 0.
The reader may note that multiconditionals have the same semantics as simply nested conditionals
if e1 then c1 else (if e2 then c2 else (···(if en then cn else abort ﬁe′
n)···) ﬁe′
2) ﬁe′
1 .
That the semantics function and the interpretation of the nested conditionals are equivalent can be seen by the following 
derivation. When n ≥1 we have the derivation
Ccase e1 : c1 : e′
1; ··· ; en : cn : e′
n esacφ
= Cif e1 then c1 else (if e2 then c2 else (···
(if en then cn else abort ﬁe′
n)···) ﬁe′
2) ﬁe′
1φ
= T e′
1† ◦(Cc1φ ⊕Cif e2 then c2 else (···
(if en then cn else abort ﬁe′
n)···) ﬁe′
2φ) ◦T e1
= T e′
1† ◦(Cc1φ ⊕Ccase e2 : c2 : e′
2; ··· ; en : cn : e′
n esacφ) ◦T e1
and when n = 0 multiconditionals behave as abort.
Multiconditionals follow the symmetric ﬁrst match policy introduced in the reversible functional programming language
rfun [18]. We test e1, e2, ..., en in sequence until we ﬁnd the ﬁrstly satisﬁed expression ei. Then, the i’th branch is selected 
and ci is executed. The computation continues if assertion e′
i holds and all previous assertions e′
1, e′
2, ..., e′
i−1 do not hold.
Under this assumption, the default branch like in the switch statements in C can be realized by making both en and 
e′
n have a non-nil value, e.g., en ≡e′
n ≡(nil.nil), which is interpreted as true. These non-nil expressions can be hidden by 
syntactic sugar:
case e1 : c1 : e′
1; ··· ; en−1 : cn−1 : e′
n−1 else cn esac ≡
case e1 : c1 : e′
1; ··· ; en−1 : cn−1 : e′
n−1; (nil.nil) : cn : (nil.nil) esac
In particular, this new case command with a single branch is just interpreted as an if conditional:
case e1 : c1 : e′
1 else c2 esac ≡if e1 then c1 else c2 ﬁe′
1 .
The correctness of those equivalences can be checked by simple derivations using the presented metalanguage.
57

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
1: proc post(t)
2:
s ⇐(t.nil);
3:
from =? y nil loop
4:
rewrite (s.y) by
5:
((0.s)
.y) ⇒(s
.(0.y));
6:
(((l.(1.r)).s).y) ⇒((r.(l.s)).(1.y))
7:
etirwer
8:
until =? s nil;
9: return y;
(* iter.postorder traversal *)
(* init stack s to tree t
*)
(* list y empty at entry?
*)
(* rewrite s and y
*)
(* stack top is leaf
*)
(* stack top is inner node *)
(* end rewrite
*)
(* stack s empty at exit?
*)
Fig. 4. Translation between inﬁx expressions and reverse Polish notation using rewriting.
5.3. Rewriting
A reversible rewrite construct turns out to be very useful for implementing rewriting systems [19]. First, we illustrate 
the construct with an iterative translation of inﬁx expressions into reverse Polish notation, a representation popular in 
stack-oriented programming languages. Then, we formalize the rewrite extension.
Example 2. The procedure in Fig. 4 translates an inﬁx expression t to reverse Polish notation (RPN) y by iteratively rewriting 
a stack of trees s and adding leaves and labels to y (lines 3–8). Stack s is initialized to t (line 2). The representation of t is 
the same as in Example 1. The reversible iteration is implemented by a while-loop (see Section 5.1). Initially, y is empty; 
the loop terminates when s is empty. The body of the loop consists of a rewrite statement rewrite...etirwer (lines 4–7) that 
tests the value of (s.y) against two patterns and rewrites it once. If a leaf is on top of the stack as required by (0.s) in the 
ﬁrst pattern (line 5) then 0 is popped from the stack and consed onto y. Otherwise, if an inner node is on top of the stack 
as required by (l.(1.r)) in the second pattern (line 6), the subtrees l and r are pushed onto the stack and label 1 is consed 
onto y. The two patterns on the left side are disjoint as are the two patterns on the right side, which make the rewrite 
statement reversible. Hence, the procedure is reversible, which means uncalling post translates expressions written in RPN 
back to inﬁx notation.
Extending R-WHILE with such a construct requires extending the syntax of commands:
c ::= ··· | rewrite q by q1 ⇒q′
1; ··· ;qn ⇒q′
n etirwer .
The intended semantics of a rewrite block is as follows: The pattern q is tested against the patterns q1, ..., qn until a match 
is found — the patterns q1, ..., qn are assumed to be disjoint such that q can match at most one of these, as are q′
1, ..., q′
n
to ensure reversibility. Once a match qi is found, q is rewritten by the pattern on the right-hand side, q′
i: Knowing that qi
and q match, performing this rewriting amounts to performing the command qi ⇐q; q ⇐q′
i.
Recall that the reversible replacement q1 ⇐q2 acts as an assertion with side effects: If the two patterns q1 and q2 match, 
the replacement is performed, and if they do not, the replacement q1 ⇐q2 is undeﬁned. As such, determining whether two 
patterns q1 and q2 match in a given state (with program context φ) amounts to checking whether Qq1 ⇐q2φ is deﬁned
at that state. For example, the patterns foo and x match in all states where the variable x evaluates to foo — which is the 
same as saying that Qfoo ⇐xφ is deﬁned at all states where x evaluates to foo.
In this way, checking that two patterns match in a given state can be reduced to checking whether a partial function is 
deﬁned at a given point. For a given partial injection X
f−→Y , we deﬁne the classifying predicate X
χ f
−→X ⊕X (related, but 
not equivalent, to the idea of classiﬁed partiality, see, e.g., [20,21]) deﬁned as follows:
χ f (x) =

inr x
if f deﬁned at x
inl x
otherwise .
In the convention that left injection corresponds to falsehood, and right injections to truth, χ f is true at x if and only if 
when f is deﬁned at x. This allows us to give semantics to rewrite blocks in the following way:
Crewrite q by q1 ⇒q′
1; ··· ; qn ⇒q′
n etirwerφ(σ) =

f (Crewrite q by q2 ⇒q′
2; ··· ; qn ⇒q′
n etirwerφ)(σ)
if n ≥1
Cabortφ(σ)
if n = 0
where f (x) = (χCq′
1⇐qφ)† ◦(x ⊕Cq1 ⇐q;q ⇐q′
1φ) ◦χCq1⇐qφ .
The right-hand side of the equation is expanded as
f ( f (···( f

	

n
(Cabortφ))···))(σ) .
58

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
Fig. 5. An overview of (certain) L terms and their graphical representation in the style of [8].
As such, this is essentially an n-armed multiconditional using the classifying predicate χCqi⇐qφ to test whether the i’th 
branch should be chosen, and using the inverse classifying predicate (χCq′
i⇐qφ)† as the exit assertion of the i’th branch. 
Since q′
i ⇐q is inverse to q ⇐q′
i (see Section 4.8), it must be deﬁned after performing q ⇐q′
i if this is deﬁned at all, 
and since q′
1, ..., q′
n are assumed to be disjoint, at most one of the classifying predicates χCq′
i⇐qφ is true at any one time. 
Hence, the exit assertion property is satisﬁed.
Note that since q1, ..., qn and q′
1, ..., q′
n, respectively, are required to be disjoint, in principle, we are free to change the 
order of branches. This approach is more conservative than the symmetric ﬁrst match policy used in the reversible functional 
programming language rfun [18].
Alternatively, we can deﬁne χCq1⇐qφ in the presented metalanguage L:
χCq1⇐qφ = ((Qqφ)† ⊕( f † ◦κ2)) ◦f
where f = Q′q1φ ◦Qqφ and 
 × V
Q′q
−−−→(
 × V) ⊕
. Essentially, Q′qφ behaves like the inverse of Qqφ and its 
result is with the tag inr. But Q′qφ can also detect pattern matching failures. When pattern matching fails, the result is 
the original input with the tag inl. Speciﬁcally, we can represent the functionality of Q′qφ as follows:
Q′qφ(σ, v) =

inr ((Qqφ)†(σ, v))
if (Qqφ)† is deﬁned at (σ, v)
inl (σ, v)
otherwise .
The exact deﬁnition of this function in the presented metalanguage L is in Appendix C.
6. Related work
Formal meaning has been given to reversible programming languages using well-established formalisms such as opera-
tional semantics to the imperative language Janus [1], the functional language RFUN [18], and to concurrent languages [22], 
small-step operational semantics to the assembler language PISA [15], transition functions to the ﬂowchart language 
RFCL [2], and denotational semantics to R-WHILE [3,4]. The reversibility of a language is not directly expressed by these 
formalisms. It is up to the language designer’s discipline to capture reversibility and to show the inversion properties for 
each language individually. Additionally, the semantics of R-WHILE was ﬁrst expressed irreversibly [1]. The type and effects 
systems were studied for reversible languages [23] (see also [24]).
In this paper, the reversible elements of R-WHILE are composed by the metalanguage L in a manner that preserves 
their reversibility. Compositional approaches to reversibility have been used in various disguises including the diagrammatic 
composition of reversible circuits from reversible logic gates and reversible structured ﬂowcharts from reversible control-
ﬂow operators [2]. The categorical approach to reversible structured ﬂowchart semantics was pioneered by [5]. Similarly, 
reversible Turing machines were built from reversible rotary elements [25].
The category PInj of sets and partial injective functions has a rich history of study in relation to various reversible 
computation models (e.g., [26,12]), but perhaps in particular those arising from the Geometry of Interaction (see [27] for 
an overview). An interesting recent example concerns the denotational semantics of Janus based on partial injective func-
tions [8], and given that this approach is based on the same category as our metalanguage L is, there are many similarities, 
though presentations differ. To make similarities clearer, we show in Fig. 5 the representation of (certain) L terms in the 
graphical language employed by [8] (see also [13] regarding graphical languages).
59

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
To give meaning to reversible languages by translators and interpreters is another operational approach to a semantics. 
Examples include reversible interpreters [1,3], translation of the high-level language R to the reversible assembler language 
PISA [28], mapping hardware descriptions in SyReC to reversible circuits [29], and processor architectures [30]. A different 
approach is the reversibilization of irreversible languages by extending the operational semantics by tracing to undo program 
runs [31]. Alternatively, irreversible programs can be inverted using different program inversion approaches, e.g., [32–34]. 
Reversible cellular automata may have non-injective local maps, but if the local map is injective, the update by the global 
map is guaranteed to be reversible [35].
7. Conclusion
Reversible systems have reversible semantics. In the present paper, we built on a metalanguage foundation intended to 
describe the semantics of reversible programming languages, which we demonstrated by the full development of a formal 
semantics of the reversibly-universal language R-WHILE. It allowed us to concisely formalize features representative of 
many reversible languages, including iteration, recursion, pattern matching, dynamic data structures, and access to a pro-
gram’s inverse semantics. The intrinsic properties of the metalanguage were essential in giving formal reversible semantics. 
A language deﬁned in the metalanguage is guaranteed to have reversibility, which means it requires no explicit proof of 
reversibility. We argued that this metalanguage approach serves as a strong basis for understanding and reasoning about 
reversible programs.
It could be interesting to further explore how advanced object-oriented structures, combinators, or features for con-
currency are best described and the metalanguage features that may be useful. Characterizing reversible heap allocation 
and concurrent reversible computations are some of those challenges. However, its practical feasibility and relationship to 
advanced reversible automata including nondeterminism, e.g., [36] remains to be explored.
Declaration of competing interest
The authors declare that they have no known competing ﬁnancial interests or personal relationships that could have 
appeared to inﬂuence the work reported in this paper.
Acknowledgements
The authors would like to thank Markus Holzer and Martin Kutrib for editing this special issue, and the anonymous 
reviewers for their useful feedback. The second author is supported by the Independent Research Fund Denmark under DFF-
International Postdoc Fellowship No. 0131-00025B. The third author is supported by JSPS KAKENHI Grant Number 18K11250 
and Nanzan University Pache Research Subsidy I-A-2 for the 2021 academic year.
Appendix A. The correctness of command inverter I
As in [5, Section 8], the correctness of the command inverter I deﬁned in Fig. 3 are shown as follows. We prove that for 
any command c there is a command Ic such that CIcσ = (Ccσ )† for any σ . To prove it by structural induction on 
command c, it is suﬃcient to show the following derivations:
CIc1;c2φ
= CIc2; Ic1φ
= CIc2φ ◦CIc1φ
= (Cc2φ)† ◦(Cc1φ)†
= (Cc1φ ◦Cc2φ)†
= (Cc1; c2φ)†
CIxi = e1σ
= Cxi = e1σ
= (Qxiφ)† ◦Ee1 ◦Qxiφ
= ((Qxiφ)† ◦(Ee1)† ◦(Qxiφ)††)†
= ((Qxiφ)† ◦Ee1 ◦Qxiφ)†
= (Cxi = e1σ )†
CIq1 ⇐q2φ
60

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
= Cq2 ⇐q1φ
= (Qq2φ)† ◦Qq1φ
= ((Qq1φ)† ◦Qq2φ)†
= (Cq1 ⇐q2φ)†
CIif e1 then c1 else c2 ﬁe2φ
= Cif e2 then Ic1 else Ic2 ﬁe1φ
= T e2† ◦(CIc2φ ⊕CIc1φ) ◦T e1
= (T e2† ◦((CIc2φ)† ⊕(CIc1φ)†) ◦T e1)†
= (T e2† ◦(Cc2φ ⊕Cc1φ) ◦T e1)†
= (Cif e2 then c1 else c2 ﬁe1φ)†
CIfrom e1 do c1 loop c2 until e2φ
= Cfrom e2 do Ic1 loop Ic2 until e1φ
= Tr

(id
 ⊕CIc2φ) ◦T e1 ◦CIc1φ ◦T e2†
= Tr

T e1 ◦CIc1φ ◦T e2† ◦(id
 ⊕CIc2φ)

=

Tr

(id
 ⊕(CIc2φ)†) ◦T e2 ◦(CIc1φ)† ◦T e1††
=

Tr

(id
 ⊕Cc2φ) ◦T e2 ◦Cc1φ ◦T e1††
= (Cfrom e1 do c1 loop c2 until e2φ)†
Because for any σ , CIIcσ = (CIcσ )† = (Ccσ )††, we have IIc = c.
Appendix B. Renaming procedure names R
The translator R replaces each procedure fi with its inverse f inv
i
with preserving the meaning. Note that call/uncall 
patterns are ﬂipped to uncall/call patterns, respectively.
Rx j ≡x j
Rs ≡s
Rcall fi(q1) ≡uncall f inv
i
(Rq1)
Runcall fi(q1) ≡call f inv
i
(Rq1)
R(q1.q2) ≡(Rq1.Rq2)
Rx = e ≡x = e
Rq1 ⇐q2 ≡Rq1 ⇐Rq2
Rc1;c2 ≡Rc1; Rc2
Rif e1 then c1 else c2 ﬁe2 ≡if e1 then Rc1 else Rc2 ﬁe2
Rfrom e1 do c1 loop c2 until e2 ≡from e1 do Rc1 loop Rc2 until e2
Appendix C. The helper semantic function Q′qφ
Q′x jφ(σ, v) =

inr (extract†
j(σ, v))
if π j(σ) = v
inl (σ, v)
otherwise
Q′sφ(σ, v) =

inr σ
if s = v
inl (σ, v)
otherwise
61

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
Q′call fi(q1)φ(σ, v) =

inr σ1
if Q′q1φ(σ, v1) = inr σ1 and κ†
i (φ†(κi(v1))) = v
inl (σ, v)
if Q′q1φ(σ, v) = inl x
Q′uncall fi(q1)φ(σ, v) =
⎧
⎪⎨
⎪⎩
inr σ1
if Q′q1φ(σ, v1) = inr σ1 and κ†
i (φ(κi(v))) = v1
inl (σ, v)
if (Q′q1φ(σ, v1) = inl x and κ†
i (φ(κi(v))) = v1)
or Q′q1φ(σ, v) = inl x
Q′(q1.q2)φ(σ, v1 • v2) =
⎧
⎪⎨
⎪⎩
inr σ1
if Q′q2φ(σ, v2) = inr σ2 and Q′q1φ(σ2, v1) = inr σ1
inl (σ, v1 • v2)
if (Q′q2φ(σ, v2) = inr σ2 and Q′q1φ(σ2, v1) = inl x)
or Q′q2φ(σ, v2) = inl x
Appendix D. Conditionals as syntax sugar
This is an example equational reasoning using L.
We can swap two values swap(x1, x2) by using the zeroed variable x3.
swap(x1, x2) ≡x3 ⇐x1; x1 ⇐x2; x2 ⇐x3
The one-armed loop is suﬃcient to simulate reversible conditionals as demonstrated in [3]:
if x1 else c1 ﬁx1 ≡from x2 loop c1; swap(x1, x2) until x1; swap(x1, x2)
This law is proved by the following derivation. We assume T x2(σ) = inr σ . Let f = (Cc1; swap(x1, x2)φ ⊕id
) ◦
T x1 ◦T x2†.
Cfrom x2 loop c1; swap(x1, x2) until x1φ(σ)
= Tr( f )(σ)
= pretrace( f )(inr σ)
=

σ
if T x1(σ) = inr σ
pretrace( f )(inl (Cc1; swap(x1, x2)φ(σ)))
if T x1(σ) = inl σ
=

σ
if T x1(σ) = inr σ
Cc1; swap(x1, x2)φ(σ)
if T x1(σ) = inl σ
Hence, we have
Cfrom x2 loop c1; swap(x1, x2) until x1; swap(x1, x2)φ(σ)
=

Cswap(x1, x2)φ(σ)
if T x1(σ) = inr σ
Cc1φ(σ)
if T x1(σ) = inl σ
=

σ
if T x1(σ) = inr σ
Cc1φ(σ)
if T x1(σ) = inl σ
= (T x1 ◦(id
 ⊕Cc1φ) ◦T x1†)(σ)
= Cif x1 else c1 ﬁx1φ(σ)
References
[1] T. Yokoyama, R. Glück, A reversible programming language and its invertible self-interpreter, in: Partial Evaluation and Semantics-Based Program 
Manipulation, Proceedings, ACM Press, 2007, pp. 144–153.
[2] T. Yokoyama, H.B. Axelsen, R. Glück, Fundamentals of reversible ﬂowchart languages, Theor. Comput. Sci. 611 (2016) 87–115.
[3] R. Glück, T. Yokoyama, A minimalist’s reversible while language, IEICE Trans. Inf. Syst. E100-D (5) (2017) 1026–1034.
[4] R. Glück, T. Yokoyama, Constructing a binary tree from its traversals by reversible recursion and iteration, Inf. Process. Lett. 147 (2019) 32–37.
[5] R. Glück, R. Kaarsgaard, A categorical foundation for structured reversible ﬂowchart languages: soundness and adequacy, Log. Methods Comput. Sci. 
14 (3) (2018).
[6] R. Kaarsgaard, H.B. Axelsen, R. Glück, Join inverse categories and reversible recursion, J. Log. Algebraic Methods Program. 87 (2017) 33–50.
[7] R. Kaarsgaard, Inversion, iteration, and the art of dual wielding, in: M.K. Thomsen, M. Soeken (Eds.), Reversible Computation, Proceedings, in: LNCS, 
vol. 11497, Springer, 2019, pp. 34–50.
[8] L. Paolini, M. Piccolo, L. Roversi, A certiﬁed study of a reversible programming language, in: T. Uustalu (Ed.), 21st International Conference on Types 
for Proofs and Programs (TYPES 2015), in: Leibniz International Proceedings in Informatics (LIPIcs), vol. 69, Schloss Dagstuhl–Leibniz-Zentrum für 
Informatik, 2018, 7.
62

R. Glück, R. Kaarsgaard and T. Yokoyama
Theoretical Computer Science 920 (2022) 46–63
[9] G. Winskel, The Formal Semantics of Programming Languages: An Introduction, MIT Press, 1993.
[10] R. Glück, R. Kaarsgaard, T. Yokoyama, Reversible programs have reversible semantics, in: E. Sekerinski, et al. (Eds.), Formal Methods, FM 2019 Interna-
tional Workshops, Proceedings, in: LNCS, vol. 12233, Springer, 2020, pp. 413–427.
[11] R. Cockett, S. Lack, Restriction categories III: colimits, partial limits and extensivity, Math. Struct. Comput. Sci. 17 (4) (2007) 775–817.
[12] B. Giles, An investigation of some theoretical aspects of reversible computing, Ph.D. thesis, University of Calgary, 2014.
[13] P. Selinger, A survey of graphical languages for monoidal categories, in: B. Coecke (Ed.), New Structures for Physics, in: LNP, vol. 813, Springer, 2010, 
pp. 289–355.
[14] E. Haghverdi, A categorical approach to linear logic, geometry of proofs and full completeness, Ph.D. thesis, Carlton University and University of Ottawa, 
2000.
[15] H.B. Axelsen, R. Glück, T. Yokoyama, Reversible machine code and its abstract processor architecture, in: V. Diekert, M.V. Volkov, A. Voronkov (Eds.), 
Computer Science - Theory and Applications, Proceedings, in: LNCS, vol. 4649, Springer, 2007, pp. 56–69.
[16] R. Kaarsgaard, Condition/decision duality and the internal logic of extensive restriction categories, Electron. Notes Theor. Comput. Sci. 347 (2019) 
179–202.
[17] A. Joyal, R. Street, D. Verity, Traced monoidal categories, Math. Proc. Camb. Philos. Soc. 119 (3) (1996) 447–468.
[18] T. Yokoyama, H.B. Axelsen, R. Glück, Towards a reversible functional language, in: A. De Vos, R. Wille (Eds.), Reversible Computation, Proceedings, in: 
LNCS, vol. 7165, Springer, 2012, pp. 14–29.
[19] R. Glück, T. Yokoyama, A linear-time self-interpreter of a reversible imperative language, Comput. Softw. 33 (3) (2016) 108–128.
[20] A. Kock, Algebras for the partial map classiﬁer monad, in: A. Carboni, M.C. Pedicchio, G. Rosolini (Eds.), Category Theory, Proceedings, in: LNM, 
vol. 1488, Springer, 1991, pp. 262–278.
[21] J. Cockett, S. Lack, Restriction categories II: partial map classiﬁcation, Theor. Comput. Sci. 294 (1) (2003) 61–102.
[22] S. Kuhn, I. Ulidowski, A calculus for local reversibility, in: S. Devitt, I. Lanese (Eds.), Reversible Computation, Proceedings, in: LNCS, vol. 9720, Springer, 
2016, pp. 20–35.
[23] R.P. James, A. Sabry, Information effects, in: Principles of Programming Languages, Proceedings, ACM Press, 2012, pp. 73–84.
[24] R. Kaarsgaard, N. Veltri, En garde! Unguarded iteration for reversible computation in the delay monad, in: G. Hutton (Ed.), Mathematics of Program 
Construction, Proceedings, in: LNCS, vol. 11825, Springer, 2019, pp. 366–384.
[25] K. Morita, Reversible computing and cellular automata — a survey, Theor. Comput. Sci. 395 (1) (2008) 101–131.
[26] S. Abramsky, A structural approach to reversible computation, Theor. Comput. Sci. 347 (3) (2005) 441–464.
[27] E. Haghverdi, P. Scott, Geometry of interaction and the dynamics of proof reduction: a tutorial, in: B. Coecke (Ed.), New Structures for Physics, in: LNP, 
vol. 813, Springer, 2010, pp. 357–417.
[28] M.P. Frank, Reversibility for eﬃcient computing, Ph.D. thesis, MIT, 1999.
[29] R. Wille, E. Schönborn, M. Soeken, R. Drechsler, SyReC: a hardware description language for the speciﬁcation and synthesis of reversible circuits, 
Integration 53 (2016) 39–53.
[30] M.K. Thomsen, H.B. Axelsen, R. Glück, A reversible processor architecture and its reversible logic design, in: A. De Vos, R. Wille (Eds.), Reversible 
Computation, Proceedings, in: LNCS, vol. 7165, Springer, 2012, pp. 30–42.
[31] J. Hoey, I. Ulidowski, S. Yuen, Reversing parallel programs with blocks and procedures, in: J.A. Pérez, S. Tini (Eds.), Expressiveness in Concurrency, 
Structural Operational Semantics, Proceedings, in: Electronic Proceedings in Theoretical Computer Science, vol. 276, 2018, pp. 69–86.
[32] R. Glück, M. Kawabe, Revisiting an automatic program inverter for Lisp, SIGPLAN Not. 40 (5) (2005) 8–17.
[33] M. Kawabe, R. Glück, The program inverter LRinv and its structure, in: H. Manuel, D. Cabeza (Eds.), Practical Aspects of Declarative Languages, Pro-
ceedings, in: LNCS, vol. 3350, Springer, 2005, pp. 219–234.
[34] R. Glück, V.F. Turchin, Application of metasystem transition to function inversion and transformation, in: International Symposium on Symbolic and 
Algebraic Computation, Proceedings, ACM Press, 1990, pp. 286–287.
[35] J. Kari, Reversible cellular automata: from fundamental classical results to recent developments, New Gener. Comput. 36 (3) (2018) 145–172.
[36] M. Holzer, M. Kutrib, Reversible nondeterministic ﬁnite automata, in: I. Phillips, H. Rahaman (Eds.), Reversible Computation, Proceedings, in: LNCS, 
vol. 10301, Springer, 2017, pp. 35–51.
63

