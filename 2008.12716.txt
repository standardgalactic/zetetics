arXiv:2008.12716v1  [cs.PL]  28 Aug 2020
Practical Idiomatic Considerations for
Checkable Meta-Logic in Experimental
Functional Programming
Baltasar Tranc´on y Widemann and Markus Lepper
semantics GmbH, Berlin
Abstract. Implementing a complex concept as an executable model in
a strongly typed, purely functional language hits a sweet spot between
mere simulation and formal speciﬁcation. For research and education it is
often desirable to enrich the algorithmic code with meta-logical annota-
tions, variously embodied as assertions, theorems or test cases. Checking
frameworks use the inherent logical power of the functional paradigm
to approximate theorem proving by heuristic testing. Here we propose
several novel idioms to enhance the practical expressivity of checking,
namely meta-language marking, nominal axiomatics, and constructive
existentials. All of these are formulated in literate Haskell’98 with some
common language extensions. Their use and impact are illustrated by
application to a realistic modeling problem.
Keywords: Executable modeling; property-based testing; reiﬁed logic
1
Introduction
This paper discusses general programming methodology in terms of a particular
implementation in Haskell. Thus it is provided as a literate Haskell [10] program.1
1.1
Proving and Checking
Purely functional programming has arguably a friendlier relationship to meta-
logic, the discipline of formal reasoning about program properties, than conven-
tional state-based paradigms [1]. This has been exploited in a number of ways
that diﬀer greatly in their pragmatic context.
At one end of the spectrum, strongly normalizing languages and the types-as-
propositions approach, ultimately based on the Brouwer–Heyting–Kolmogorov
interpretation of constructive logic, have led to the uniﬁcation of algorithmic
programming and constructive theorem proving. The practice has evolved from
basic models such as the Calculus of Constructions [6] to full-blown languages
and interactive programming environments such as Agda [9]. The basic approach
1 A full and self-contained source archive for practical evaluation is publicly available
at http://bandm.eu/download/purecheck/.

is that a program is statically validated with respect to a type signature that
encodes the desired meta-logical property, if and only if it truly possesses that
property. This approach does evidently not scale to Turing-complete languages. 2
Thus, for meta-logic over complete programming languages, it is not suﬃcient
to demonstrate inhabitation of a type to obtain a proof, but it must also stand
the test of successful evaluation.
At the other end of the spectrum, freedom from side eﬀects allows for liber-
ally sprinkling program code with online assertions, that is, computations whose
values the program depends on not for its outcome, but for ensuring its cor-
rect operation. Some care must be exercised when timing and strictness details
matter [2], but otherwise the technique is just as powerful as for conventional
programming paradigms [4], minus the need for a pure assertion sublanguage.
The middle ground is covered by oﬄine checking3, that is, evaluation of
meta-logical properties as a separate mode of program execution. Oﬄine check-
ing is of course less rigorous than theorem proving, and may involve incomplete
and heuristic reasoning procedures. On the other hand, it is more abstract and
static than online assertions; thus cases that are not reached during online evalu-
ation can be covered, and the checking eﬀort can be shifted to convenient points
in the software lifecycle. Oﬄine checking ﬁlls the same role as conventional unit
testing procedures, although the focus is a bit diﬀerent: checking purely func-
tional programs is commonly both simpler in control, due to the lack of state of
the unit under test that needs to be set up and observed, and more complex in
data, due to the pervasiveness of higher-order functions.
There are various popular oﬄine checking frameworks for functional pro-
gramming languages, such as QuickCheck, (Lazy) SmallCheck, SmartCheck,
ScalaCheck or PropEr, and we assume the reader is familiar with their general
design and operation, for instance with the seminal QuickCheck [3] for Haskell.
1.2
Executable Modeling
The ﬁeld of executable modeling, that is, the construction of experimental pro-
grams that embody theoretical concepts of systems and processes, and imbue
them with practically observable behavior, poses speciﬁc challenges. In particu-
lar, some mechanism is needed to validate the implementation, that is, establish
trust in its faithful representation of the concepts under study. Since executable
models are designed to exceed behavioral a-priori intuition (otherwise their con-
tent were trivial)[5], it is intrinsically hard to diﬀerentiate bugs from features.
In a naive idealistic sense, model programs should be derived and proved rig-
orously. However, that presupposes a complete, computable and operationalized
theory. For the two scenarios where a theory exists but is not fully operational-
ized, and where models are used inductively as approximations to a future theory,
2 Consider the “constructive” logical reading of the type of a generic recursion opera-
tor, (α →α) →α; it says literally that begging the question, α →α, is a valid proof
method for any proposition α.
3 Thus named here for clear contrast with the alternatives, but largely synonymous
with property-based testing [7].
2

we consider less rigorous approaches, and oﬄine checking in particular, the more
viable validation procedure. It may even be educational to both check and run
models that behave evidently wrong.
1.3
The PureCheck Framework
The checking idioms to be proposed in the following have been developed in the
context of an experimental checking framework, PureCheck, implemented as a
plain Haskell library. The design of PureCheck largely follows the paradigm of
popular frameworks such as QuickCheck[3] or SmallCheck[?], with some notable
deviations.
Like other frameworks, PureCheck leverages the internal logical language of
functional programming, and type-directed generation of test data for universal
propositions. PureCheck prioritizes purity and non-strictness; text execution is
rigidly non-monadic, and thus equally suitable for both oﬄine checks and online
assertions. Unlike QuickCheck, test data are generated by deterministic rather
than randomized combinatorial procedures. Unlike SmallCheck, sample sizes can
be bounded precisely, without risk of combinatorial explosion. Test data sets
are pessimistically assumed to be possibly insuﬃcient, and thus the direction of
logical approximation is signiﬁcant; evaluation may yield false positives, resulting
from undiscovered counterexamples, but never false negatives.
The contribution of the present paper is a collection of three novel and exper-
imental idioms for oﬄine checking. The deﬁnitions and an example application
are given in the following two main sections, respectively. These features have
been implemented in Haskell for PureCheck, but are theoretically compatible
with other frameworks and host languages.
PureCheck Basics At the heart of the framework is an encapsulation for
heuristic checks.
newtype Check = Check {perform :: Int →Bool }
The heuristic is parameterized with an Int called the conﬁdence parameter.
Because of monotonicity, higher values may require more computational eﬀort,
but can only improve the test accuracy by eliminating more false positives.
The propositions that can be encapsulated in this way come in various shapes;
thus we deﬁne a type class with an ad-hoc polymorphic encapsulation operation.
class Checkable α where check :: Meta α →Check
The wrapper Meta should be ignored for now; it shall be discussed in due detail
in the following section. The base case is a propositional constant.
instance Checkable Bool where check (Meta b) = Check (const b)
Checks bear the obvious conjunctive monoid structure. Since the aggregate con-
ﬁdence in the truth of a conjunction can be no higher than the individual con-
ﬁdence in any of its clauses, the parameter is copied clause-wise.
3

instance Monoid Check where
mempty
= Check (λn →True)
mappend (Check c) (Check d) = Check (λn →c n ∧d n)
instance Checkable () where check (Meta ()) = mempty
instance (Checkable α, Checkable β) ⇒Checkable (α, β) where
check (Meta (p, q)) = check (Meta p) ‘mappend‘ check (Meta q)
instance (Checkable α) ⇒Checkable [α] where
check (Meta ps) = mconcat (map (check ◦Meta) ps)
For quantiﬁed universals, a generator for representative samples of the argu-
ment space is required. The conﬁdence parameter is taken as the recommended
maximum sample size (unlike SmallCheck, where the parameter is a depth to
be exhausted, such that sample size may be only exponentially related). Unlike
in the conjunctive case, nested universal quantiﬁers are not simply dealt with
recursively. Instead, it is recommended to use uncurried forms quantiﬁed over
tuples to ensure proper weight-balancing between argument samples.
checkWith :: Generator α →Meta (α →Bool) →Check
checkWith g (Meta p) = Check (λn →all p (generate g n))
instance (Some α) ⇒Checkable (α →Bool) where
check = checkWith some
Test data generators are wrapped pure functions, and thus deterministic
in the size parameter n. Useful generators return at most (preferably approxi-
mately) n elements (preferably distinct and with commensurate internal variety).
newtype Generator α = Generator {generate :: Int →[α]}
A type class provides default generators for its instance types.
class Some α where some :: Generator α
Generators for simple types are straightforward, for instance:
instance Some Bool where
some = Generator $ ﬂip take [False, True ]
Generator combinators for complex types need to consider the issues of weight
balancing between dimensions and of inﬁnite enumerations; the details are out
of scope here.4
2
Proposed Idioms
2.1
Meta-Language Marking
The principle of types as propositions in a functional programming language is
a two-sided coin. On the upside, the internal logical language is automatically
4 Implementations can be found in the full source.
4

consistent with the language semantics, and quite expressive. On the downside,
the expressive power of advanced abstractions such as higher-order functions and
polymorphism is a bit too much for the logical needs of the average user. Unre-
strained use can make the meta-logical aspects of the codebase overwhelmingly
hard to both write and read. 5
We propose that, for both education and engineering, it is a wise move to
delimit the parts of the codebase that are intended as meta-logical vocabulary
explicitly. To this end, we introduce a generic wrapper type.
data Meta α = Meta {reﬂect :: α}
Then the codebase is manifestly stratiﬁed into four layers:
Operational deﬁnitions do not use the Meta type/value constructor.
Assertive deﬁnitions use the Meta constructor in root position.
Tactical deﬁnitions use the Meta constructor in non-root position.
Transcendent deﬁnitions are polymorphic over a type (constructor) variable that
admits some Meta α (or Meta itself, respectively) as an instance.
The eﬀect of this stratiﬁed marking discipline is that, contrarily to the patho-
logical foldl example presented above, the intented reading of type signatures
becomes clear. For instance:
– Meta Bool is the type of atomic assertive meta-expressions that are expected to
evaluate straightforwardly to True; deﬁnitions of this type incur a singleton static
checking obligation, that is a test case.
– Meta Int is a type of meta-expressions without a truth-value, let alone an expected
one; deﬁnitions of this type incur no static checking obligation.
– Meta (A →Bool)6 is the type of quantiﬁed assertive meta-expressions that are
expected to evaluate to True for all parameter values of type A; deﬁnitions of this
type incur a static checking obligation for some values (preferably a representative
set).
– A →Meta Bool is the type of tactics that can construct such assertions from
parameter values of type A; deﬁnitions of this type incur no static checking obli-
gation, but may implement an aspect of a test strategy.
– Meta A →Meta B is the type of tactics that can transform an assertion of type
A to an assertion of type B; deﬁnitions of this type incur no checking obligation,
but may implement an aspect of a test strategy.
– Meta A →Bool is the type of tactics that can evaluate a meta-property of an
assertion of type A; deﬁnitions of this type incur no checking obligation, but may
implement an aspect of a test strategy.
– Meta (α →Bool) →Meta ([α] →Bool) is the type of parametrically polymorphic
predicate transformers that lifts an assertion meta-expression quantiﬁed over an
arbitrary element type α to one quantiﬁed over the corresponding list type [α].
5 The reader is invited to contemplate for example the variety of possible higher-order
logical meanings of the following specialization of a well-known Haskell Prelude
function: foldl :: (Foldable τ) ⇒(Bool →α →Bool) →Bool →τ α →Bool
6 Note the discourse-level meta-variable A for a monomorphic Haskell type, instead
of an object-level type variable α.
5

Note that transport of operational subexpressions into the meta-logical layer
is the simple matter of a Meta data constructor. By contrast, the reverse trans-
port using the projection reﬂect is discouraged except for certain idiomatic cases.
Evidently level marking makes no contribution to algorithmic computations.
That it is pragmatically valuable documentation nevertheless is demonstrated
by the explicit meta-logical universal quantiﬁer:
foreach :: (α →Meta β) →Meta (α →β)
foreach f = Meta (λx →reﬂect (f x))
If f is a predicate that is used pointwise to form meta-expressions, then foreach f
is a singular meta-expression that quantiﬁes over all points. For example,
Meta ◦even :: Int →Meta Bool
is clearly a predicate intended to be used pointwise since the alternative reading,
“all integers are even”, is blatantly false. By contrast,
foreach (Meta ◦even ◦(∗2)) :: Meta (Int →Bool)
is a (true) universal assertion quantiﬁed over all (non-⊥) values of type Int.
As a more relevant example, consider a preorder of meta-logical interest, say
a semantic approximation relation, on some data type A.
(⊑) :: A →A →Meta Bool
This is directly usable as a binary predicate that characterizes the relationship
of two particular elements. By converting one quantiﬁer, we obtain a unary
predicate that characterizes a particular element as globally minimal:
minimal :: A →Meta (A →Bool)
minimal x = foreach (x ⊑)
By converting the other quantiﬁer also, we obtain a nullary predicate that char-
acterizes the preorder as trivial:
trivial :: Meta (A →A →Bool)
trivial = foreach minimal
The ﬁnal conversion to the recommended uncurried type Meta ((A, A) →Bool)
can be performed explicitly (left as an exercise to the reader), or implicitly by a
suitable instance of Checkable.
This style ensures that higher-order functions and meta-logical reading are
orthogonal means of expressivity.
All checking ultimately involves the evaluation of an expression of type
Meta Bool. The denotational semantics of this Haskell type has four meaningful
values, namely:
6

Value
Verdict: The checked property
Issue Type
Meta True
. . . holds
—
Meta False
. . . does not hold
logical falsehood
Meta ⊥
. . . cannot be decided
logical error
⊥
. . . cannot be stated
tactical error
Semantic ⊥values occuring intermediately, such as in tactical computations
or test data generation, are not constrained by our framework. To the contrary,
non-strictness can be exploited in useful ways to manipulate complex meta-
logical constructs. For instance, consider a form of bounded quantiﬁcation, where
an explicit sample generator is provided:
data For α β = For {bound :: Generator α, body :: α →β}
instance Checkable (For α Bool) where
check (Meta (For g p)) = checkWith g (Meta p)
Nested bounded quantiﬁcations of the form For g (λx →For h (λy →p))
cannot be merged or transposed straightforwardly, because a lambda abstraction
intervenes. However, semantics can be exploited if h is independent of, and thus
non-strict in x.
qmerge :: For α (For β γ) →For (α, β) γ
qmerge (For g k) = let h = bound (k ⊥)
in For (gpair g h) (λ(x, y) →body (k x) y)
Here gpair forms a Cartesian sample product for marginal generators g and h.7
2.2
Nominal Axiomatics
In a types-as-propositions approach to meta-logic of functional programs, a prop-
erty of interest is encoded as a dependent type, and holds if the type can be
demonstrated to be inhabited in a constructive semantics.
By contrast, checking approaches are empirical: Properties of interest are
tested by computable functions, and thus collapse to the result type Bool, of
which only the value True is accepted. A seemingly trivial, but practically sig-
niﬁcant consequence is that type signatures are not helpful to prevent accidental
confusion of structurally similar properties.
This issue is compounded, quite paradoxically, by abstraction mechanisms.
Often a proposition can be stated in concise generic form by abstraction from
values, types or type class instances. The actual checking then operates on a
particular concretization (by application in the former and type inference in the
latter two cases, respectively).
In this context, misreference or omission errors are easy to commit and hard
to detect. Hence it is of some practical importance to organize the meta-logical
propositions attached to a particular reusable program part clearly and account-
ably. Adequate solutions appear to depend heavily on the programming style; the
following guidelines should thus be understood as both ﬂexible and incomplete.
7 The implementation of gpair is explained in detail in the full source.
7

Theory Type Classes A substantial part of model-ish functional programs is
about the algebra of data structures. For structures organized in the idiomatic
Haskell way as type classes, the associated meta-logic can conveniently be orga-
nized as a companion type class with default implementations. This bundles the
laws and makes them accessible to simultaneous instantiation, and to automatic
enumeration via meta-programming (which is not discussed here).
For example, consider the implied laws of the Prelude type class Monoid:
class (Monoid α) ⇒MonoidTheory α where
monoid left unit :: (Eq α) ⇒Meta (α →Bool)
monoid left unit = Meta (λx →mempty ⋄x ≡x)
monoid right unit :: (Eq α) ⇒Meta (α →Bool)
monoid right unit = Meta (λx →x ⋄mempty ≡x)
monoid assoc :: (Eq α) ⇒Meta ((α, α, α) →Bool)
monoid assoc = Meta (λ(x, y, z)
→(x ⋄y) ⋄z ≡x ⋄(y ⋄z))
Note that there is some design leeway with respect to type class contexts. For il-
lustration, we have distinguished here between the “essential” context Monoid α,
declared on the type class and hence detected upon instantiation, and the “ac-
cidental” context Eq α, declared on each method and hence detected upon use.
The distinction may or may not be ambiguous in practice, however.
Type-Level Ad-Hoc Programming For more ad-hoc data structures, where
operations are not organized as methods of a type class, but rather passed explic-
itly to higher-order functions, or where extra laws are assumed locally, a likewise
looser style of meta-logic appears more adequate. Fortunately, there is no need
to relinquish the assistance of the Haskell type and context checker altogether.
A type class can be used to map symbolic names of laws, deﬁned as constructors
of ad-hoc datatypes, to their logical content.
class Axiom α π | α →π where axiomatic :: α →Meta π
In line with the previous example, an extra law that is not reﬂected by a
Haskell type class can be deﬁned and made referable by a singleton polymorphic
datatype.
data MonoidCommute α = MonoidCommute
instance (Monoid α, Eq α) ⇒
Axiom (MonoidCommute α) ((α, α) →Bool) where
axiomatic MonoidCommute = Meta (λ(x, y) →x ⋄y ≡y ⋄x)
A law for an ad-hoc data structure with explicitly passed operations is analo-
gously deﬁned as a record-like datatype. For instance consider a law of monoid
actions (also cf. the type signature of foldl):
type RAction α β = β →α →β
data RActionUnit α β = RActionUnit (RAction α β)
8

instance (Monoid α, Eq β) ⇒
Axiom (RActionUnit α β) (β →Bool) where
axiomatic (RActionUnit (⊳)) = Meta (λx →x ⊳mempty ≡x)
data RActionCompose α β = RActionCompose (RAction α β)
instance (Monoid α, Eq β) ⇒
Axiom (RActionCompose α β) (β →α →α →Bool) where
axiomatic (RActionCompose (⊳)) = Meta (λx y z →x ⊳(y ⋄z) ≡(x ⊳y) ⊳z)
For richer classiﬁcation, type subclasses can be used to create ad-hoc subsets
of “axiom space”. This both adds to the documentation value of actual meta-
level code, and protects against misuse of tactics. For instance, consider a class
of Int-parameterized meta-level expressions that need only be checked for non-
negative parameter values:
class (Axiom α (Int →β)) ⇒NonNegAxiom α β
This subclass can be accompanied with an axiom-level operator, by giving a
constructor type and corresponding operational lifting:
data NonNeg α = NonNeg α
instance (NonNegAxiom α β) ⇒Axiom (NonNeg α) (Int →β) where
axiomatic (NonNeg a) = Meta (reﬂect (axiomatic a) ◦abs)
The restriction of the instance context to the subclass NonNegAxiom ensures
application of this (generally unsafe) tactic only to axioms that have an explicit
membership declaration, which can serve as an anchor for individual justiﬁcation,
be it prose reasoning or checkable lemmata.
2.3
Constructive Existentials
The natural logical reading of the type operator (→) is universal quantiﬁcation.
But existential quantiﬁcation also often arises in formulas, either explicitly or by
DeMorgan’s laws, when universal quantiﬁcation occurs in a negative position,
such as under negation or on the left hand side of implication.
Checking existential quantiﬁcation with the same sampling-based mecha-
nisms as universal quantiﬁcation would break the monotonicity of heuristics:
For universal quantiﬁers, only false positives can arise if counterexamples exist
but are not present in the sample. As such, conﬁdence can only improve when the
sample size is increased. By contrast, for existential quantiﬁers, false negatives
can arise when witness exist but are not present in the sample. False negatives
are at best annoying when they occur at the top level and raise false alarms, but
at worst, when arising negatively nested in a complex formula, they can make
overall conﬁdence decrease with increasing sample size.
Therefore we propose to treat existential quantiﬁcation as entirely distinct,
and in the true spirit of constructive logic, by eﬀective Skolemization. To make
an existential assertion checkable, a witness must be provided in an eﬀectively
computable fashion.
9

class Witness α β | α →β where witness :: α →Maybe β
Here α is a data type that encodes the meta-logical predicate to quantify, and β
is the domain to quantify over. The ad-hoc polymorphic operation witness may
yield Nothing to indicate that no witness could be found for the given predicate
instance. The extraction of a witness can then be composed with a payload
predicate to form bounded existential quantiﬁcations.
exists :: (Witness α β) ⇒α →(β →Bool) →Bool
exists p q = case witness p of
Just x
→q x
Nothing →False
Note that the exists itself quantiﬁer is not marked with Meta, as it is perfectly
suitable for use in the operational codebase layer as well.
existsSome :: (Witness α β) ⇒α →Bool
existsSome p = exists p (const True)
existsOrVacuous :: (Witness α β) ⇒α →(β →Bool) →Bool
existsOrVacuous p q = case witness p of
Just x
→q x
Nothing →True
3
Example Application: Theory of (String) Patches
We illustrate the use and impact of the checking idioms described above by ap-
plying them to a conceptual problem arising from real-world software engineering
research: An algebraic theory of compositional patching.
The generic level of the theory studies non-Abelian groups of patches acting
partially on some arbitrary state space. As a simple but illuminating example
instance, we consider the particular space of ordinary character strings, and a
group generated by atomic insert and delete operations and their evident seman-
tics. Establishing the decidability of the word problem of this group is already a
non-trivial modeling task, where the expressivity gained by our proposed check-
ing idioms comes in handy for rapid validation.
3.1
Group Words and Actions
The theoretical background for a type of patches π is its (right) action, a partial
function on some state space σ.
class Patch σ π where action :: σ →π →Maybe σ
Application of patches can also be reverted.
class (Patch σ π) ⇒InvPatch σ π where undo :: σ →π →Maybe σ
This should be an inverse operation where deﬁned:
10

data PatchInvert σ π = PatchInvert
instance (InvPatch σ π, Eq σ) ⇒
Axiom (PatchInvert σ π) (σ →π →Bool) where
axiomatic PatchInvert = Meta (λs p →case action s p of
Nothing →True
Just s′
→undo s′ p ≡Just s)
If the patch type has a polarity, that is some internal form of inversion, then
the forward direction action suﬃces to imply the backward direction undo.
class Polar α where
inv :: α →α
instance (Patch σ π, Polar π) ⇒InvPatch σ π where
undo x p = action x (inv p)
The most important forms of patch types are group words, made up from
polarized primitives:
data Polarity = Positive | Negative
instance Polar Polarity where
inv Positive = Negative
inv Negative = Positive
data Literal α = Literal Polarity α
instance Polar (Literal α) where
inv (Literal b x) = Literal (inv b) x
instance (InvPatch σ α) ⇒Patch σ (Literal α) where
action s (Literal Positive p) = action s p
action s (Literal Negative p) = undo
s p
Group words are essentially lists that polarize elementwise, but also reverse their
order in the process, to accomodate for non-commutative groups.
newtype Word α = Word [Literal α]
instance Polar (Word α) where
inv (Word w) = Word (reverse (map inv w))
They act in the obvious way by folding, strictly over the Maybe monad.
instance (InvPatch σ α) ⇒Patch σ (Word α) where
action s (Word w) = foldM action s w
3.2
String Editing Operations
As an example instance of the generic theory, consider the editing of a character
string. Suitable partial invertible atomic edit operations are:
11

– Inserting a given character at a given position if that does not exceed the
end of the string, and inversely
– deleting a given character at a given position if it occurs there.
data EditOp = Insert | Delete
instance Polar EditOp where
inv Insert = Delete
inv Delete = Insert
data Edit = Edit {op :: EditOp, pos :: Int, arg :: Char }
instance Polar Edit where
inv (Edit f i x) = Edit (inv f ) i x
The operational semantics are modeled eﬀectively by a type class that interprets
the two operations, giving rise to an action on some state space.
class Editable α where
insert :: α →Int →Char →Maybe α
delete :: α →Int →Char →Maybe α
instance (Editable σ) ⇒Patch σ Edit where
action s (Edit Insert i x) = insert s i x
action s (Edit Delete i x) = delete s i x
The instance for the datatype String implements the above informal intuition.
instance Editable String where
insert s
0 x = return (x : s)
insert [ ]
i x = Nothing
insert (y : t) i x = liftM (y:) (insert t (i −1) x)
delete [ ]
i x = Nothing
delete (y : t) 0 x = guard (x ≡y) >> return t
delete (y : t) i x = liftM (y:) (delete t (i −1) x)
3.3
Semantic Model
Group words only form a free monoid, in the obvious way inherited from the list
type [ ], but partial applications of ﬂip action induce a proper group of partial
bijections on the state space. The extensional equality of induced group elements,
and thus the word problem of the group presentation encoded in the action, is
universally quantiﬁed, and thus hard to decide for large or even inﬁnite state
spaces. A heuristic evaluation would be suﬃcient as a meta-expression in simple
oﬄine checks, but not in negative positions, nor for online assertions, nor even
in the operational layer of the codebase, such as in model animations.
This situation can be improved substantially by giving a semantic model
in the form of an algebraic datatype with inductively derived equality, which
12

is fully abstract in the sense that it admits a normal form where extensionally
equal semantic functions are represented by the same data value.
For the example theory considered here, there is such a normal form of string-
transducing automata. Because these automata do not require circular transi-
tions, they can be modeled by a family of mutually linearly recursive datatypes,
and evaluated by straightforward recursion.
data Editor
= Try Insertion | Fail
data Insertion
= Ins String Consumption
data Consumption = Skip Insertion
| Del Char Insertion
| Return
The operational idea is to apply each operator node to a position in an input
string, advancing left to right. The detailed meaning of operators is as follows:
Fail Applies to no string at all, immediately reject.
Try Applies to some strings, begin processing at start position.
Ins Insert zero or more characters before the position.
Skip Advance the position over one character if available, otherwise reject.
Del Remove the next character if available and matched, otherwise reject.
Return Stop processing and accept, returning the remainder of the string as is.
The sorting of operators into diﬀerent data types ensures that insertion and
consumption alternate properly.
Note that, unlike random-access Edit terms, subsequent operator nodes are
only ever applied to the original input string, not to the output of their pre-
decessors. This is also the cause for the Skip and Fail operators which do not
appear in the Edit language; they arise from attempting to delete a previously
inserted character consistently and inconsistently, respectively.
The type Insertion is not to be constructed directly, but by the following
smart constructor that avoids a degenerate corner case: Namely, insertions be-
fore and after a deletion are operationally indistinguishable. This ambiguity is
avoided by avoiding insertions after a deletion, lumping adjacent insertions to-
gether beforehands, which preserves the desired normal form.
ins :: String →Consumption →Insertion
ins pre (Del y (Ins ﬁx next)) = Ins (pre ++ ﬁx) (Del y (Ins [ ] next))
ins preﬁx next
= Ins preﬁx next
The semantic model type Editor covers the middle ground between the syn-
tactic encoding Word Edit and the semantic state space String, in the sense
that it instantiates both Editable and Patch String, giving the respective eﬀec-
tive connections. The latter is the simpler one of the pair, and implements the
intuition stated above.
instance Patch String Editor where
action s Fail
= Nothing
13

action s (Try steps)
= action s steps
instance Patch String Insertion where
action s (Ins preﬁx next) = do t ←action s next
return (preﬁx ++ t)
instance Patch String Consumption where
action s Return
= return s
action s (Skip
rest)
= do (x, t) ←uncons s
u
←action t rest
return (x : u)
action s (Del y rest)
= do (x, t) ←uncons s
u
←action t rest
guard (x ≡y)
return u
The instantiation of Editable essentially amounts to splicing a single edit
operation into an automaton while preserving the normal form. The technical
details are too gruesome to be presented here in full.
instance Editable Editor · · ·
instance Editable Insertion · · ·
instance Editable Consumption · · ·
This instantiation implies an instance of Patch Editor Edit, which can be lifted
to group words by folding over the Maybe monad.
semantics
:: Word Edit →Editor
semantics
= fromMaybe ◦foldM action done ◦toList
done :: Insertion
done = Ins [ ] Return
fromMaybe :: Maybe Insertion →Editor
fromMaybe = maybe Fail Try
The adequacy of the semantics can be stated concisely in terms of two propo-
sitions for soundness and full abstraction, respectively.
semantics sound :: Meta (Word Edit →String →Bool)
semantics sound = foreach (λx →patch eq x (semantics x))
semantics abstract :: Meta ((Editor, Editor) →Bool)
semantics abstract = foreach (uncurry cons eq)
The former uses extensional equivalence under action in positive position, hence
the universal quantiﬁers can be nested, and sampled together at checking time.
patch eq :: (Patch σ α, Patch σ β, Eq σ) ⇒α →β →Meta (σ →Bool)
patch eq x y = Meta (λs →action s x ≡action s y)
By contrast, the latter conceptually uses extensional equivalence in negative
position: “if two automata are extensionally equivalent then they are equal”.
This form of quantiﬁcation cannot be approximated monotonically by sampling.
14

Hence a constructive solution for the DeMorganized corresponding existential is
required; if two automata are extensionally inequivalent, then a witness state for
which they fail to coincide must be found.
cons eq :: (Eq α, Witness (Diﬀα) β) ⇒α →α →Meta Bool
cons eq t u = Meta (t ≡u ∨existsSome (t :̸≡u))
The operator :̸≡of constructive logic is conveniently deﬁned as the constructor
of a new datatype Diﬀ, since it requires an ad-hoc instance of Witness to hold
each construction algorithm.
data Diﬀα = (:̸≡) α α
It turns out that a straightforward algorithm requires three auxiliary construc-
tive predicates, which bear witness that an automaton accepts some input, that
an automaton rejects some input, and that one automaton accepts an input
whereas another one rejects it, respectively.
data Def α
= Def α
data Undef α
= Undef α
data DefUndef α = (:⩾) α α
The implementations are too complex to be discussed here in detail.
instance Witness (Diﬀ
Editor) String · · ·
instance Witness (Def
Editor) String · · ·
instance Witness (Undef
Editor) String · · ·
instance Witness (DefUndef Editor) String · · ·
However, the intended semantics can be speciﬁed precisely, and checked, in a
self-application of the meta-logical language.
def sound complete :: Meta (Editor →Bool)
def sound complete = Meta
(λx →x ≡Fail ∨exists (Def x) (λs →isJust (action s x)))
undef sound complete :: Meta (Editor →Bool)
undef sound complete = Meta
(λx →isTotal x ∨exists (Undef x) (λs →¬ (isJust (action s x))))
def undef sound :: Meta ((Editor, Editor) →Bool)
def undef sound = Meta
(λ(x, y) →existsOrVacuous (x :⩾y) (λs →isJust (action s x) ∧
¬ (isJust (action s y))))
diﬀsound complete :: Meta ((Editor, Editor) →Bool)
diﬀsound complete = Meta
(λ(x, y) →x ≡y ∨exists (x :̸≡y) (λs →action s x ̸≡action s y))
Note that the target semantics abstract is a consequence of diﬀsound complete
a fortiori already, but there is no obvious way to exploit that logical relationship
in a checking framework.
15

Now we can operationalize the word problem by comparing automata,
(∼=) :: Word Edit →Word Edit →Bool
x ∼= y = semantics x ≡semantics y
and conclude for instance that fromList [Edit Insert 2 ’a’, Edit Delete 3 ’b’]
∼= fromList [Edit Delete 2 ’b’, Edit Insert 2 ’a’].
3.4
Strategical Remarks
The above examples let us have a glimpse at the power of recursive tactics avail-
able in an embedded higher-order logical language: Equational reasoning about
the data to be modeled is reduced to the word problem of a group presenta-
tion, an extensional property quantiﬁed over all possible inputs that can only
be checked heuristically and positively. For broader checkability, this problem
is factored through a normalizable automaton representation. The soundness
and full abstraction of this semantics, and thus the equivalence of its equa-
tional reasoning, are checkable properties that contain existential quantiﬁcation,
for which constructive witnesses are given. The correctness and completeness
of these constructions are universally quantiﬁed properties again, which can be
checked heuristically.
Note that this does not mean we are going in circles; the correctness of the
semantics needs only to be established once, and can be used as a shortcut for
deciding equations of the original model henceforth. Yet the same language, tools
and workﬂow are used for all phases.
4
Conclusion
We have proposed three advanced features of meta-logical language for oﬄine
checking of functional programs, namely meta-level marking, nominal axiomat-
ics and constructive existentials. We have shown their implementation in the
Haskell checking framework PureCheck, and demonstrated their use and inter-
action by means of a nontrivial executable modeling problem. Other aspects of
PureCheck, such as ensuring the eﬃciency of deterministic sampling, are both
work in progress and out of scope here, and shall be discussed in a forthcoming
companion paper.
Dialectically, the stylistic ideal that underlies our experiments is contrary
to the one employed in the construction of this paper: The checking paradigm
expresses reasoning about the program in (a marked level of) the code, as op-
posed to the prose embellishment of the literate paradigm. We are hopeful that
a thorough synthesis of the two can be demonstrated as synergetic and useful in
the future.
Expressive oﬄine checking language is an important step towards the reiﬁca-
tion of the algebraic concepts that pervade functional program design; consider
the ubiquitous informal equational theory associated with Haskell type classes.
16

Marking the Meta level explicitly has not only the demonstrated advantages
for the human reader, but may also serve as an anchor for meta-programming
procedures, such as automatic test suite extraction without magic names.
The concept of constructive existentials is an explicitly controlled counter-
part to implicit search strategies provided by the logical programming paradigm.
Unlike SmartCheck, where constructive existentials are dismissed for often be-
ing hard to ﬁnd in practice, we contend that in a (self-)educational context
such as executable modeling, the understanding gained by implementing the
construction witnesses for existential meta-logical properties of interest is re-
warding rather than onerous. Furthermore foresee interesting potential in the
transfer of our ideas to a functional–logic language such as Curry [8] with built-
in encapsulated search capabilities, but leave the exploration for future work.
References
1. John Backus. “Can Programming Be Liberated From the von Neumann Style?
A Functional Style and Its Algebra of Programs”. In: Comm. ACM 21.8 (1978),
pp. 613–641.
2. Olaf Chitil and Frank Huch. “A Pattern Logic for Prompt Lazy Assertions in
Haskell”. In: IFL 2006. Vol. 4449. Lecture Notes in Computer Science. Springer,
2007. doi: 10.1007/978-3-540-76637-7 4.
3. Koen Claessen and John Hughes. “QuickCheck: A Lightweight Tool for Random
Testing of Haskell Programs”. In: SIGPLAN Not. 35.9 (Sept. 2000), pp. 268–279.
doi: 10.1145/357766.351266.
4. Lori A. Clarke and David S. Rosenblum. “A historical perspective on runtime asser-
tion checking in software development”. In: ACM SIGSOFT Software Engineering
Notes 31.3 (2006), pp. 25–37. doi: 10.1145/1127878.1127900.
5. Jonathan Cooper, Jon Olav Vik, and Dagmar Waltemath. “A call for virtual ex-
periments: accelerating the scientiﬁc process”. In: PeerJ PrePrints (2014). doi:
10.7287/peerj.preprints.273v1.
6. Thierry
Coquand
and
G´erard
Huet.
“The
calculus
of
constructions”.
In:
Information
and
Computation
76
(2–3
1988),
pp.
95–120.
doi:
10.1016/0890-5401(88)90005-3.
7. George Fink and Matt Bishop. “Property-Based Testing; A New Approach to
Testing for Assurance”. In: Software Engineering Notes 22.4 (1997), pp. 74–80.
doi: 10.1145/263244.263267.
8. Michael Hanus. Curry: A Truly Integrated Functional Logic Language. 2014. url:
https://www-ps.informatik.uni-kiel.de/currywiki/.
9. Ulf Norell. “Towards a practical programming language based on dependent type
theory”. PhD thesis. Chalmers University of Technology, 2007.
10. Simon Peyton Jones. “Literate comments”. In: The Haskell 98 Report. 2002. url:
https://www.haskell.org/onlinereport/literate.html.
11. Colin Runciman, Matthew Naylor, and Fredrik Lindblad. “Smallcheck and lazy
smallcheck: automatic exhaustive testing for small values”. In: Haskell ’08: Pro-
ceedings of the ﬁrst ACM SIGPLAN symposium on Haskell. 2008, pp. 37–48. doi:
10.1145/1411286.1411292.
17

