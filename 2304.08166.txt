arXiv:2304.08166v1  [quant-ph]  17 Apr 2023
This work is licensed under the
Creative Commons Attribution License.
Flow-preserving ZX-calculus rewrite rules for optimisation
and obfuscation
Tommy McElvanney
School of Computer Science
University of Birmingham
txm639@student.bham.ac.uk
Miriam Backens
School of Computer Science
University of Birmingham
m.backens@cs.bham.ac.uk
In the one-way model of measurement-based quantum computation (MBQC), computation proceeds
via measurements on a resource state. So-called ﬂow conditions ensure that the overall computation
is deterministic in a suitable sense, with Pauli ﬂow being the most general of these. Computations,
represented as measurement patterns, may be rewritten to optimise resource use and for other pur-
poses. Such rewrites need to preserve the existence of ﬂow to ensure the new pattern can still be
implemented deterministically. The majority of existing work in this area has focused on rewrites
that reduce the number of qubits, yet it can be beneﬁcial to increase the number of qubits for certain
kinds of optimisation, as well as for obfuscation.
In this work, we introduce several ZX-calculus rewrite rules that increase the number of qubits
and preserve the existence of Pauli ﬂow. These rules can be used to transform any measurement
pattern into a pattern containing only (general or Pauli) measurements within the XY-plane. We also
give the ﬁrst ﬂow-preserving rewrite rule that allows measurement angles to be changed arbitrarily,
and use this to prove that the ‘neighbour unfusion’ rule of Staudacher et al. preserves the existence of
Pauli ﬂow. This implies it may be possible to reduce the runtime of their two-qubit-gate optimisation
procedure by removing the need to regularly run the costly gﬂow-ﬁnding algorithm.
1
Introduction
The ZX-calculus is a graphical language for representing and reasoning about quantum computations,
allowing us to conveniently represent and reason about computations in both the quantum circuit model
and the one-way model of measurement based quantum-computation (MBQC), as well as to translate
between the two. The ZX-calculus has various complete sets of rewrite rules, meaning that any two
diagrams representing the same linear map can be transformed into each other entirely graphically [1,
14, 20] and provide tools for uses in optimization [24] [12], obfuscation [7] and other areas of research
in quantum computing.
The one-way model of MBQC involves the implementation of quantum computations by performing
successive adaptive single-qubit measurements on a resource state [21], largely without using any unitary
operations. This contrasts with the more commonly-used circuit model and has applications in server-
client scenarios as well as for certain quantum error-correcting codes.
An MBQC computation is given as a pattern, which speciﬁes the resource state – usually a graph state
– and a sequence of measurements of certain types [11]. As measurements are non-deterministic, future
measurements need to be adapted depending on the outcomes of past measurements to obtain an overall
deterministic computation. Yet not every pattern can be implemented deterministically. Sufﬁcient (and
in some cases necessary) criteria for determinism are given by the different kinds of ﬂow, which deﬁne
a partial order on the measured qubits and give instructions for how to adapt the future computation if a
measurement yields the undesired outcome [6, 10] (cf. Section 2.3).

2
Flow-preserving ZX-calculus rewrite rules for optimisation and obfuscation
In addition to the applications mentioned above, the ﬂexible structure of MBQC patterns is also
useful as a theoretical tool. For example, translations between circuits and MBQC patterns have been
used to trade off circuit depth versus qubit number [5] or to reduce the number of T-gates in a Clifford+T
circuit [16]. When translating an MBQC pattern (back) into a circuit, it is important that the pattern still
have ﬂow, as circuit extraction algorithms rely on ﬂow [3, 10, 12, 19].
ZX-calculus diagrams directly corresponding to MBQC-patters are said to be in MBQC-form. Many
of the standard ZX-calculus rewrite rules do not preserve the MBQC-form structure nor the existence
of a ﬂow, which we often want to preserve, thus circuit optimisation using MBQC and the ZX-calculus
relies on proofs that preserve both MBQC-form and ﬂow [3, 12]. Much of the previous work on this has
focused on rewrite rules that maintain or reduce the number of qubits, which ﬁnd direct application in
T-count optimisation [12]. Nevertheless, it is sometimes desirable to increase the number of qubits in an
MBQC pattern while preserving the existence of ﬂow, such as for more involved optimisation strategies
[23] or for obfuscation.
In this work we introduce several ZX-calculus rewrite rules that preserve the MBQC-form structure
as well as Pauli ﬂow [6], alongside proofs of this preservation. These rules have various applications,
such as being used in obfuscation techniques for blind quantum computation [7]. Notably, we introduce
the ﬁrst Pauli ﬂow preserving rewrite rule that allows us to change measurement angles arbitrarily, with
all previous rules only allowing for changes that are integer multiples of π
2 . Using this, we prove that the
‘neighbour unfusion’ rule of [24] always preserves the existence of Pauli ﬂow. Additionally, we show
that neighbour unfusion only preserves gﬂow [6], a less general ﬂow condition, if and only if one of the
two neighbours is in the correction set of the other.
2
Preliminaries
In this section, we give an overview of the ZX-calculus and then use it to introduce measurement-based
quantum computing. We discuss the notion of ﬂow that will be used in this paper and some existing
rewrite rules which preserve the existence of this ﬂow.
2.1
The ZX-calculus
The ZX-calculus is a diagrammatic language for reasoning about quantum computations. We will pro-
vide a short introduction here; for a more thorough overview, see [8, 25].
A ZX-diagram consists of spiders and wires. Diagrams are read from left to right: wires entering a
diagram from the left are inputs while wires exiting the diagram on the right are outputs, like in the quan-
tum circuit model. ZX-diagrams compose in two distinct ways: horizontal composition, which involves
connecting the output wires of one diagram to the input wires of another, and vertical composition (or
the tensor product), which just involves drawing one diagram vertically above the other. The linear map
corresponding to a ZX-diagram D is denoted by JDK.
ZX-diagrams are generated by two families of spiders which may have any number of inputs or
outputs, corresponding to the Z and X bases respectively. Z-spiders are drawn as green dots and X-
spiders as red dots; with m inputs, n outputs, and using (·)⊗k to denote a k-fold tensor power, we have:
t
α
...
...
|
= |0⟩⊗n ⟨0|⊗m +eiα |1⟩⊗n ⟨1|⊗m
t
α
...
...
|
= |+⟩⊗n ⟨+|⊗m +eiα |−⟩⊗n ⟨−|⊗m

T. McElvanney & M. Backens
3
α
β
...
...
...
...
=
α +β
...
...
α
=
α
=
=
π
α
...
...
−α
...
...
=
π
π
π
α
...
...
=
=
...
...
...
...
...
...
...
...
...
...
Figure 1: A complete set of rewrite rules for the scalar-free stabilizer ZX-calculus. Each rule also holds
with the colours or the directions reversed.
Spiders with exactly one input and output are unitary, in particular J
α
K = |0⟩⟨0|+eiα |1⟩⟨1| = Zα
and J
α
K = |+⟩⟨+|+eiα |−⟩⟨−| = Xα.
Two diagrams D and D′ are said to be equivalent (written D ∼= D′) if JDK = zJD′K for some non-zero
complex number z. For the rest of the paper, whenever we write a diagram equality we will mean equality
up to some global scalar in this way. For treatments of the ZX-calculus which do not ignore scalars see
[2] for the stabilizer fragment, [14] for the Clifford+T fragment and [15, 20] for the full ZX-calculus.
The Hadamard gate H = |+⟩⟨0| +|−⟩⟨1| ∼= Z π
2 ◦X π
2 ◦Z π
2 will be widely used throughout the paper.
It has two common syntactic sugars – a yellow square, or a blue dotted line – with the latter only used
between spiders:
π
2
π
2
π
2
=
=
The ZX-calculus is equipped with a set of rewrite rules which can be used to transform a ZX-diagram
into another diagram representing the same linear map. The following rules, along with the deﬁnition of
, is complete for stabilizer ZX-diagrams: any two stabilizer ZX-diagrams which correspond (up to
non-zero scalar factor) to the same linear map can be rewritten into one another using these rules [1].
2.2
Measurement-based Quantum computation
Measurement-based Quantum computation (MBQC) is a particularly interesting model of quantum com-
putation with no classical analogue. In the one-way model of MBQC, one ﬁrst constructs a highly en-
tangled resource state that can be independent of the speciﬁc computation that one wants to perform
(only depending on the ‘size’ of the computation) by preparing qubits in the |+⟩state and applying
CZ-gates to certain pairs of qubits. The computation then proceeds by performing single qubit measure-
ments in a speciﬁed order. MBQC is a universal model for quantum computation – any computation can
be performed by choosing an appropriate resource state and then performing a certain combination of
measurements on said state.
Measurement-based computations are traditionally expressed as measurement patterns, which use
a sequence of commands to describe how the resource state is constructed and how the computation
proceeds [11]. As the resource states are graph states, a graphical representation of MBQC protocols can
be more intuitive; we shall therefore introduce MBQC with ZX-diagrams.
Deﬁnition 2.1 ([13]). A graph state diagram is a ZX-diagram where each vertex is a (phase-free) green
spider, each edge connecting spiders has a Hadamard gate on it, and there is a single output wire incident
on each vertex.

4
Flow-preserving ZX-calculus rewrite rules for optimisation and obfuscation
operator
⟨+XY,α|i
⟨+XZ,α|i
⟨+YZ,α|i
⟨+X,0|i
⟨+Y,0|i
⟨+Z,0|i
⟨+X,π|i
⟨+Y,π|i
⟨+Z,π|i
diagram
−α(i)
π
2
α(i)
α(i)
- π
2
π
π
2
π
Table 1: MBQC measurement effects in Dirac notation and their corresponding ZX-diagrams
Deﬁnition 2.2. [3, Deﬁnition 2.18] A ZX-diagram is in MBQC-form if it consists of a graph state diagram
in which each vertex of the graph may furthermore be connected to an input (in addition to its output),
and a measurement effect instead of its output.
MBQC restricts the allowed single-qubit measurements to three planes of the Bloch sphere: those
spanned by the eigenstates of two Pauli matrices, called the XY, YZ and XZ planes. Each time a qubit u
is measured in a plane λ(u) at an angle α, one may obtain either the desired outcome, denoted ⟨+λ(u),α|,
or the undesired outcome ⟨−λ(u),α| = ⟨+λ(u),α+π|. Measurements where the angle is an integer multiple
of π
2 are Pauli measurements; the corresponding measurement type is denoted by simply X, Y, or Z. The
ZX-diagram corresponding to each (desired) measurement outcome is given in Table 1. The structure of
an MBQC protocol is formalised as follows.
Deﬁnition 2.3. A labelled open graph is a tuple Γ = (G,I,O,λ), where G = (V,E) is a simple undi-
rected graph, I ⊆V is a set of input vertices, O ⊆V is a set of output vertices, and λ : V \ O →
{X,Y,Z,XY,XZ,YZ} assigns a measurement plane or Pauli measurement to each non-output vertex.
2.3
Pauli ﬂow
Measurement-based computations are inherently probabilistic because measurements are probabilistic.
Computations can be made deterministic overall (up to Pauli corrections on the outputs) by tracking
which measurements result in undesired outcomes and then correcting for these by adapting future mea-
surements. A sufﬁcient (and in some cases necessary) condition for this to be possible on a given labelled
open graph is Pauli ﬂow. In the following, P(A) denotes the powerset of a set A.
Deﬁnition 2.4 ([6, Deﬁnition 5]). A labelled open graph (G,I,O,λ) has Pauli ﬂow if there exists a map
p : V \O →P(V \I) and a partial order ≺over V such that for all u ∈V \O,
1. if v ∈p(u), v ̸= u and λ(v) ̸∈{X,Y}, then u ≺v.
2. if v ∈OddG(p(u)), v ̸= u and λ(v) ̸∈{Y,Z}, then u ≺v.
3. if ¬(u ≺v), u ̸= v and λ(v) = Y, then v ∈p(u) ⇐⇒v ∈OddG(p(u)).
4. if λ(u) = XY, then u ̸∈p(u) and u ∈OddG(p(u)).
5. if λ(u) = XZ, then u ∈p(u) and u ∈OddG(p(u)).
6. if λ(u) = YZ, then u ∈p(u) and u ̸∈OddG(p(u)).
7. if λ(u) = X, then u ∈OddG(p(u)).
8. if λ(u) = Z, then u ∈p(u).
9. if λ(u) = Y then either u ∈p(u) and u ̸∈OddG(p(u)) or u ̸∈p(u) and u ∈OddG(p(u)).
Here, the partial order is related to time order in which the qubits need to be measured. The set p(u)
denotes qubits that are modiﬁed by Pauli-X to compensate for an undesired measurement outcome on u,
OddG(p(u)) denotes the set of vertices that are modiﬁed by Pauli-Z.

T. McElvanney & M. Backens
5
Pauli ﬂow is a sufﬁcient condition for strong, stepwise and uniform determinism: this means all
branches of the computation should implement the same linear operator up to a phase, any interval of
the computation should be deterministic on its own, and the computation should be deterministic for
all choices of measurement angles that satisfy λ [6, p. 5]. Pauli ﬂow (and related ﬂow conditions)
are particularly interesting from a ZX-calculus perspective as there are polynomial-time algorithms for
extracting circuits from MBQC-form ZX-diagrams with ﬂow [3, 12, 22], while circuit extraction from
general ZX-diagrams is #P-hard [4].
There are certain Pauli ﬂows where the side effects of any correction are particularly limited, these
are called focused and they exist whenever a labelled open graph has Pauli ﬂow.
Deﬁnition 2.5 (rephrased from [22, Deﬁnition 4.3]). Suppose the labelled open graph (G,I,O,λ) has a
Pauli ﬂow (p,≺). Deﬁne Su = V \(O∪{u}) for all u ∈V. Then (p,≺) is focused if for all u ∈V \O:
• Any v ∈Su ∩p(u) satisﬁes λ(v) ∈{XY,X,Y}.
• Any v ∈Su ∩Odd(p(u)) satisﬁes λ(v) ∈{XZ,YZ,Y,Z}.
• Any v ∈Su such that λ(v) = Y satisﬁes v ∈p(u) if and only if v ∈Odd(p(u)).
Lemma 2.6 ([22, Lemma 4.6]). If a labelled open graph has Pauli ﬂow, then it has a focused Pauli ﬂow.
2.4
Existing ﬂow-preserving rewrite rules
The basic ZX-calculus rewrite rules in Figure 1 do not generally preserve even the MBQC-form structure
of a ZX-calculus diagram. Yet there are some more complex derived rewrite rules that are known to pre-
serve both the MBQC-form structure and the existence of a ﬂow. These rules were previously considered
in the context of gﬂow [12] and extended gﬂow [3]; the Pauli-ﬂow preservation proofs are due to [22].
The simplest of these rules are Z-deletion and Z-insertion:
Lemma 2.7 ([22, Lemma D.6]). Deleting a Z-measured vertex preserves the existence of Pauli ﬂow.
...
...
...
...
aπ
=
...
...
aπ
aπ
aπ
aπ
...
...
...
...
...
...
Lemma 2.8 ([17, Proposition 4.1]). Inserting a Z-measured vertex (i.e. the inverse of Z-deletion) also
preserves the existence of Pauli ﬂow.
Other rewrite rules are based around quantum generalisations of two graph-theoretic operations.
Deﬁnition 2.9. Let G = (V,E) be a graph and u ∈V. The local complementation of G about u is
the operation which maps G to G ⋆u := (V,E a{(b,c) | (b,u),(c,u) ∈E and b ̸= c}), where a is the
symmetric difference operator given by AaB = (A ∪B) \(A ∩B). The pivot of G about the edge (u,v)
is the operation mapping G to the graph G∧uv := G⋆u⋆v⋆u.
Local complementation keeps the vertices of the graph the same but toggles some edges: for each
pair of neighbours of u, i.e. v,v′ ∈NG(u), there is an edge connecting v and v′ in G ⋆u if and only if
there is no edge connecting v and v′ in G. Pivoting is a series of three local complementations about two
neighbouring vertices, and is denoted by G∧uv = G⋆u⋆v⋆u.
Both local complementation and pivoting give rise to operations on MBQC-form diagrams which
preserve the MBQC form as well as the existence of Pauli ﬂow (after some simple merging of single-
qubit Cliffords into measurement effects, cf. [3, Section 4.2]). We illustrate the operations with examples
as they are difﬁcult to express in ZX-calculus in generality.

6
Flow-preserving ZX-calculus rewrite rules for optimisation and obfuscation
Lemma 2.10 ([22, Lemma D.12]). A local complementation about a vertex u preserves the existence of
Pauli ﬂow.
...
u
=
...
−π
2
π
2
π
2
π
2
u
Lemma 2.11 ([22, Lemma D.21]). A pivot about an edge (u,v) preserves the existence of Pauli ﬂow.
=
v
u
u
v
π
π
Observation 2.12. Lemmas 2.10 and 2.11 provide their own inverses: four successive local complemen-
tations about the same vertex or two successive pivots about the same edge leave a diagram invariant.
3
Converting planar measurements to XY-measurements
In the graph-like diagrams [12] used in PyZX, all spiders are green and all edges are Hadamard edges.
‘Phase gadgets’ consist of a degree-1 green spider connected to a phase-free green spider by a Hadamard
edge as in the left-most diagram of (1). When converting graph-like diagrams to MBQC-form, it is
difﬁcult to know whether to interpret phase gadgets as a single YZ-measured vertex (middle diagram) or
as an X-measured vertex connected to a degree-1 XY-measured vertex (right-most diagram):
α
...
α
...
α
...
(1)
The following proposition shows that both interpretations are valid and can be interconverted.
Proposition 3.1. Let (G,I,O,λ) be a labelled open graph with Pauli ﬂow where G = (V,E), and suppose
there exists x ∈V with λ(x) = YZ. Then (G′,I,O,λ ′) has Pauli ﬂow, where V ′ = V ∪{x′}, E′ = E ∪
{{x,x′}}, and λ ′(x) = X, λ ′(x′) = XY, and λ ′(v) = λ(v) otherwise.
Proof. Consider the following sequence of rewrites.
α
...
α
...
...
=
=
α
x
x
x′
x′
x
Here we insert the Z-measured vertex x′ connected only to x, then pivot along the edge (x,x′). Both
Z-insertion and pivoting preserve the existence of Pauli ﬂow, thus our new rewrite rule also preserves the
existence of Pauli ﬂow.
A similar sequence of rewrites allows us to rewrite XZ-measurements in terms of just Y-measurements
and XY-measurements

T. McElvanney & M. Backens
7
Proposition 3.2. Let (G,I,O,λ) be a labelled open graph with Pauli ﬂow where G = (V,E), and suppose
there exists x ∈V with λ(x) = XZ. Then (G′,I,O,λ ′) has Pauli ﬂow, where V ′ = V ∪{x′}, E′ = E ∪
{{x,x′}}, and λ ′(x) = Y, λ ′(x′) = XY and λ ′(v) = λ(v) otherwise.
Proof. Consider the following sequence of rewrites.
α
...
α
...
...
=
=
x
x
x′
x
x′
π
2
π
2
α
π
2
...
x′
x
π
2
α
=
Here we insert a Z-measured vertex x′ connected to the XZ-measured vertex x, perform local com-
plementation about x′, then pivot along the edge (x,x′). Each of these rewrites preserves the existence of
Pauli ﬂow, thus the resulting pattern has Pauli ﬂow.
Using the two previous propositions, we are able to re-write any XZ- and YZ-planar measurements
into a Pauli measurement plus an XY-measurement. This implies the following.
Proposition 3.3. Let (G,I,O,λ) be an arbitrary MBQC-form diagram with Pauli ﬂow. Then there exists
an equivalent diagram (G′,I′,O′,λ ′) with Pauli ﬂow where λ ′(v) ∈{X,Y,XY} for all v ∈V ′.
Proof. We begin by applying Z-deletion (Lemma 2.7) to all Z-measured vertices, leaving us with only
X, Y, XY, XZ and YZ vertices. It remains to remove all XZ and YZ measurements.
By Proposition 3.1, we can convert every YZ-measured vertex into an X-measured vertex connected
to an XY-measured vertex while preserving the existence of Pauli ﬂow. Then, by Proposition 3.2 we
can convert every XZ-measured vertex into a Y-measured vertex connected to an XY-measured vertex.
We now only have X, Y and XY measured vertices remaining, and each rewrite rule used to get here
preserves the existence of Pauli ﬂow, thus the resulting graph has Pauli ﬂow.
Remark 3.4. Note that Pauli ﬂow is important here: the gﬂow conditions need not be satisﬁed if the
newly-introduced Pauli measurements were taken to be arbitrary XY-measurements instead.
For example, the ﬁrst of the following two diagrams has a gﬂow (g,≺) with g(a) = {c}, g(b) = {d},
g(x) = {c,d,x} and a,b,x ≺c,d. The second diagram has Pauli ﬂow by Proposition 3.1, but it does not
have gﬂow: any ﬂow (p,≺′) on the second diagram must have x ∈p(x′) to satisfy x′ ∈Odd(p(x′)), as
inputs a,b do not appear in correction sets. Similarly, x′ ∈p(x) as it is the only neighbour. Thus the
gﬂow conditions would require x ≺′ x′ and x′ ≺′ x simultaneously, which is not possible.
α
β
a
b
c
d
γ
x
α
β
a
b
c
d
γ
x′
x
4
Subdividing an edge
Research on ﬂow-preserving rewrite rules so far has been geared towards optimization, which usually
involves reducing the number of vertices in a pattern. Yet there are also cases where it is desirable to
introduce new vertices. An example of this is the obfuscation protocol for blind quantum computing
of [7], which used an unpublished rewrite rule proved by one of the authors. We give the proof below.

8
Flow-preserving ZX-calculus rewrite rules for optimisation and obfuscation
Proposition 4.1. Let G = (V,E) be a graph with vertices V and edges E. Suppose the labelled open
graph (G,I,O,λ) has Pauli ﬂow. Pick an edge {v,w} ∈E and subdivide it twice, i.e. let G′ := (V ′,E′),
where V ′ := V ∪{v′,w′} contains two new vertices v′,w′, and
E′ := (E \{{v,w}})∪{{v,w′},{w′,v′},{v′,w}}.
Then (G′,I,O,λ ′) has Pauli ﬂow, where λ ′(v′) = λ ′(w′) = X and λ ′(u) = λ(u) for all u ∈V \O.
Proof. We may subdivide an edge by inserting two Z-measured vertices as shown in the following dia-
gram, then pivoting about these two Z-measured vertices.
=
=
=
...
...
...
...
...
...
...
...
As inserting Z-measured vertices and pivoting both preserve the existence of Pauli ﬂow, subdividing an
edge also preserves the existence of Pauli ﬂow.
5
Splitting a vertex
Each of the previously mentioned Pauli-ﬂow preserving rewrite rules only changes measurement angles
by integer multiples of π
2 . Here we introduce the ﬁrst Pauli-ﬂow preserving rewrite rule which allows
us to change measurement angles arbitrarily. To simplify the proof, the proposition requires that all
measurements in the pattern are XY, X or Y; by Proposition 3.3 this is without loss of generality.
Proposition 5.1. Let G = (V,E) be a graph with vertices V and edges E. Suppose the labelled open
graph (G,I,O,λ) has Pauli ﬂow and satisﬁes λ(u) ∈{XY,X,Y} for all u ∈Oc. Pick a vertex x ∈Oc
such that λ(x) = XY and split it, i.e. let G′ := (V ′,E′), where V ′ :=V ∪{x′,x′′} contains two new vertices
x′,x′′, and choose some (possibly empty) subset W ⊆N(x) such that
E′ := (E \{{x,w} | w ∈W})∪{{x′′,w} | w ∈W}∪{{x,x′},{x′,x′′}}.
Then (G′,I,O,λ ′) has Pauli ﬂow, where λ ′(x′) = X, λ ′(x′′) = XY, and λ ′(u) = λ(u) for all u ∈V \O.
...
...
7→
x
x
x′
x′′
α
α′′
α′
...
NG(x)
W
NG(x)\W
Proof. Let (p,≺) be a focused Pauli ﬂow for (G,I,O,λ); this exists as the labelled open graph has Pauli
ﬂow. Since all measurements are XY, X or Y, the focusing conditions from Deﬁnition 2.5 reduce to:
• For all u ∈V \O, if v ∈OddG (p(u)) \(O∪{u}) then λ(v) = Y.
• For all u ∈V \O and all v ∈V \(O∪{u}) such that λ(v) =Y, we have v ∈p(u) ↔v ∈OddG (p(u)).

T. McElvanney & M. Backens
9
Now, for all u ∈V \O, deﬁne
p′(u) :=











p(u)∪{x′,x′′}
if x ∈p(u) and |p(u)∩W| ≡1
(mod 2)
p(u)∪{x′′}
if x ∈p(u) and |p(u)∩W| ≡0
(mod 2)
p(u)∪{x′}
if x /∈p(u) and |p(u)∩W| ≡1
(mod 2)
p(u)
if x /∈p(u) and |p(u)∩W| ≡0
(mod 2),
then it is straightforward to check that OddG′ (p′(u)) = OddG (p(u)). For example, in the ﬁrst case, note
that ∪can be replaced by ∆since x′,x′′ are new vertices that cannot appear in p(u). Thus
OddG′  p′(u)

= OddG′  p(u)∆{x′,x′′}

= OddG′ (p(u)) ∆OddG′  {x′,x′′}

= OddG′ (x) ∆

∆
w∈p(u)\(W∪{x}∪O)OddG′ (w)

∆

∆
w∈(p(u)∩W)\OOddG′ (w)

∆{x,x′,x′′}∆W
= OddG (x) ∆

∆
w∈p(u)\(W∪{x}∪O)OddG (w)

∆

∆
w∈(p(u)∩W)\OOddG (w)∆{x,x′′}

∆{x,x′′}
= OddG (p(u)),
where the third step uses OddG′ (x) = OddG (x) ∆W ∆{x′}, and the ﬁnal step uses |p(u)∩W| ≡1
(mod 2).
Let1 p′(x′) := {x′′}, and let p′(x′′) := p′(x)∆{x′}, resulting in the following odd neighbourhoods:
OddG′  p′(x′)

= OddG′  {x′′}

= W ∪{x′}
(2)
and
OddG′  p′(x′′)

= OddG′  p′(x)

∆OddG′  {x′}

= OddG (p(x)) ∆{x,x′′}
= (OddG (p(x)) ∪{x′′})\{x}
(3)
where the ﬁnal step uses the fact that x ∈OddG (p(x)) and x′′ ̸∈OddG (p(x)) (since x′′ is not even in G).
Let ≺′ be the transitive closure of
≺∪
n
(w,x′′) | w ≺x
o
∪
n
(x′′,w) | x ≺w
o
∪
n
(x′,w) | w ∈W
o
∪
n
(x′,x′′)
o
.
This is a partial order since x′′ has the same relationships as x (except for being a successor of x′) and x′
only has successors.
The proof that (p′,≺′) is a Pauli ﬂow for G′ can be found in Appendix A.
We are able to obtain other useful rewrite rules as immediate corollaries of this.
Corollary 5.2. Using Proposition 5.1 with W = /0 and α′′ = 0, we obtain the following rule used in [7].
α
=
α
This rule can alternatively be derived in a more round-about way from Z-insertion and pivoting, but
we next prove a rule that truly requires vertex splitting.
1Note there is a choice for p′(x′), since x′ can be corrected either via x or via x′′; we pick the latter for some slight notational
convenience.

10
Flow-preserving ZX-calculus rewrite rules for optimisation and obfuscation
6
Neighbour unfusion
In [24], a rewrite rule called neighbour unfusion was used to reduce the number of two-qubit gates in
circuits via the ZX-calculus. Using neighbour unfusion allowed for the two-qubit gate count to be greatly
reduced, but introduced a new problem: neighbour unfusion, which introduces two new qubits in each
application, was found to not always preserve gﬂow. Yet a ﬂow is needed to be able to translate back
to a circuit after the application of the two-qubit gate count reduction algorithm. We now show that
neighbour unfusion preserves the existence of Pauli ﬂow, so circuit re-extraction is always possible.
Corollary 6.1. By applying vertex splitting with |W| = 1, we obtain the following ‘neighbour unfusion’
rule, where α = α′ +α′′ (the measurement for the right-most vertex is not drawn as it can be measured
in any plane, or even be an output).
=
α′′
α
α′
Staudacher et al. [24] state that, in the case of only XY-measurements, neighbour unfusion fails to
preserve gﬂow if the two vertices to which neighbour unfusion is applied are extracted to different qubits
in the circuit extraction process. We now formalise this idea and characterise exactly the situations where
neighbour unfusion does preserve gﬂow.
Proposition 6.2. Suppose neighbour unfusion is applied to two adjacent vertices a and b in a labelled
open graph Γ = (G,I,O,λ) where λ(a) = λ(b) = XY and |I| = |O|. This preserves the existence of
gﬂow if and only if there is some gﬂow (g,≺) on the original labelled open graph where a ∈g(b) or
where b ∈g(a).
Proof. Consider a labelled open graph which has a focused gﬂow (g,≺) and contains the subdiagram
α
a
b
β
For the ‘if’ direction, assume without loss of generality that b ∈g(a), the other case is symmetric.
Neighbour unfusion yields a labelled open graph Γ′ = (G′,I,O,λ ′) with the following subdiagram:
α′′
α′
β
a
b
x
x′
(4)
Given b ∈g(a), we can construct a gﬂow for the new pattern by deﬁning the correction sets as follows:
g′(v) =











g(v)
if v ̸∈{a,x,x′}
g(a)∪{x}
if v = a
{x′}
if v = x
{b}
if v = x′
Take ≺′ to be the transitive closure of ≺∪{(a,x),(x,x′),(x′,b)}, then (g′,≺′) is a gﬂow for Γ′: each of
a,x and x′ is in the odd neighbourhood of its correction set. The relation ≺′ is a strict partial order and
satisﬁes the gﬂow conditions for the newly introduced vertices. Finally, all of the other gﬂow conditions
are satisﬁed as (g,≺) is a gﬂow for Γ.

T. McElvanney & M. Backens
11
For the ‘only if’ direction, we will prove the contrapositive: Assume the post–neighbour-unfusion
measurement pattern has gﬂow, then the original measurement pattern has a gﬂow where a is in the
correction set of b, or a gﬂow where b is in the correction set of a. So suppose we have a pattern
Γ′ with the subdiagram (4). Assume that Γ′ has a focused gﬂow (g′,≺′). Let Γ′′ = (G′′,I,O,λ ′′) be
the induced sub-pattern containing only those vertices of G′ that are either outputs or measured in the
XY-plane; this must include all inputs since those cannot be measured in planes XZ or YZ. This new
measurement pattern still contains the subdiagram (4) and it has gﬂow [3, Lemma 3.15]. In fact, since
(g′,≺′) is focused, it implicitly follows from [3, Proposition 3.14 and Lemma 3.15] that the gﬂow of the
new pattern is just the restriction of the old gﬂow function to a smaller domain, and this is still focused;
denote it by (g′′,≺′′).
Now every focused gﬂow in a pattern with only XY-plane measurements and equal numbers of inputs
and outputs can be reversed in a very strict sense [18]: let Γ′′′ = (G′′,O,I,λ ′′′) be the reversed pattern
with the roles of inputs and outputs swapped and λ ′′′ mapping all non-outputs to XY. Then there exists a
focused gﬂow (g′′
rev,≺′′
rev) for Γ′′′ where ≺′′
rev is the reverse of ≺′′ and u ∈g′′
rev(v) if and only if v ∈g′′(u)
[3, Corollary 2.47].
As x is XY-measured and has two neighbours, to satisfy x ∈OddG′′ (g′′(x)) and x ∈OddG′′ (g′′
rev(x))
we require the following to hold, where ⊕is the exclusive-or operator:
(a ∈g′′(x)∧x ∈g′′(x′))⊕(x′ ∈g′′(x)∧x ∈g′′(a)).
As x′ is also XY-measured and has two neighbours, by the same reasoning we obtain the following:
(b ∈g′′(x′)∧x′ ∈g′′(x))⊕(x ∈g′′(x′)∧x′ ∈g′′(b)).
Then, as we cannot have both x ∈g′′(x′) and x′ ∈g′′(x), we have either that a ∈g′′(x), x ∈g′′(x′) and
x′ ∈g′′(b) or that b ∈g′′(x′), x′ ∈g′′(x) and x ∈g′′(a) for (g′′,≺′′) to be a gﬂow for Γ′′. But (g′′,≺′′) is the
restriction of (g′,≺′) to the XY-measured vertices in Γ′. Thus either a ∈g′(x), x ∈g′(x′) and x′ ∈g′(b)
or that b ∈g′(x′), x′ ∈g′(x) and x ∈g′(a).
Now, consider the following sequence of rewrites corresponding to the inverse of neighbour unfusion:
α′′
α′
β
a
b
x
x′
=
α′
β
a
b
x
x′
α′′
=
α′
β
a
b
x′
α′′
α′ +α′′
β
a
b
=
where we ﬁrst pivot along the edge (x,x′), then apply Z-deletion to x′ and ﬁnally apply the phase gadget
identity rule of [16] to add the phase of x′ to that of a. Each of these rules preserves the existence of
gﬂow, thus the inverse of neighbour unfusion preserves the existence of gﬂow. Moreover, if x ∈g′(a),
x′ ∈g′(x) and b′ ∈g′(x′), then after applying the inverse of neighbour unfusion we get a gﬂow (g,≺)
for Γ with b ∈g(a) (and similarly if a ∈g′(x), x ∈g′(x′) and x′ ∈g′(b) we get a gﬂow with a ∈g(b)).
Therefore, if the measurement pattern after neighbour unfusion has gﬂow, then the original pattern has a
gﬂow where b is in the correction set of a, or a gﬂow where a is in the correction set of b.
An analogous argument works if b is an output, in which case the only option is for b to be in the
correction set of a. Therefore the above proposition covers all the cases relevant to Staudacher et al.’s
work on patterns where all measurements are in the XY-plane.
Example 6.3. The following two measurement patterns are related by neighbour unfusion along the edge
between vertices a and b:

12
Flow-preserving ZX-calculus rewrite rules for optimisation and obfuscation
α
β
a
b
c
d
α′
β
a
b
c
d
α′′
x
x′
In the ﬁrst pattern, a and b are both inputs and thus cannot appear in correction sets. Hence the pattern
does not have a gﬂow where a is in the correction set of b or where b is in the correction set of a. Yet it
does have a gﬂow (g,≺) with g(a) = {c}, g(b) = {d} and a,b ≺c,d.
For the second pattern to have a ﬂow (p,≺′), we require x′ ∈p(x) and x ∈p(x′) since both vertices
need to be in the odd neighbourhood of their correction set and inputs cannot appear in correction sets.
This diagram can therefore not have a gﬂow, as the gﬂow conditions would require that x ≺′ x′ and
x′ ≺′ x simultaneously, so ≺′ would not be strict. This diagram does have a Pauli ﬂow however, as the
X-measured vertex x does not need to come after x′ in the partial order in the case of Pauli ﬂow. The
Pauli ﬂow satisﬁes p(a) = {c}, p(b) = {d}, p(x) = {d,x′} and p(x′) = {c,x} with x ≺a,b,x′ ≺c,d.
As neighbour unfusion does not always preserve the existence of gﬂow, the algorithm in [24] had
poor runtime as it would need to explicitly calculate a new gﬂow (using a gﬂow-ﬁnding algorithm such
as that in [3]) every time this rule was used. Yet neighbour unfusion preserves the existence of Pauli
ﬂow, so by using Pauli ﬂow instead of gﬂow, it should be possible to avoid running the gﬂow-ﬁnding
algorithm after each application of neighbour unfusion (and instead track the changes to the ﬂow as in
the proof of Proposition 5.1), and thus improve the runtime of this algorithm as a whole.
7
Conclusion
We have introduced several rewrite rules which preserve the existence of Pauli ﬂow, including the ﬁrst
ﬂow-preserving rewrite rule which allows us to change phases arbitrarily, rather than just by multiples
of π
2 . An immediate corollary of this rule preserving Pauli ﬂow is that the neighbour unfusion rule of
[24] also preserves Pauli ﬂow, potentially leading to a reduced runtime for their two-qubit gate count
reduction algorithm.
At present, the circuit extraction algorithm for diagrams with Pauli ﬂow introduces more two-qubit
gates than the corresponding circuit extraction algorithm for diagrams with gﬂow – future work could
involve using known work on Pauli gadget optimization, such as that of [9], to reduce the number of
two-qubit gates obtained when performing circuit extraction on diagrams with Pauli ﬂow.
Other future work could involve ﬁnding an analogous result to the stabiliser completeness proof
of [17] for a more general fragment of the MBQC-form ZX-calculus, using Proposition 5.1 to introduce
phases that are not just integer multiples of π
2 .
Acknowledgements
We would like to thank Korbinian Staudacher and Shuxiang Cao for bringing the topic of rewriting
measurement patterns to add new qubits to our attention, as well as for interesting conversations in
developing this paper. We would also like to thank Will Simmons for useful conversations on related
topics.

T. McElvanney & M. Backens
13
References
[1] Miriam Backens (2014):
The ZX-calculus is complete for stabilizer quantum mechanics.
New Journal of Physics 16(9), p. 093021, doi:10.1088/1367-2630/16/9/093021.
Available at
http://dx.doi.org/10.1088/1367-2630/16/9/093021.
[2] Miriam Backens (2015): Making the stabilizer ZX-calculus complete for scalars. Electronic Pro-
ceedings in Theoretical Computer Science 195, p. 17–32, doi:10.4204/eptcs.195.2. Available at
http://dx.doi.org/10.4204/EPTCS.195.2.
[3] Miriam
Backens,
Hector
Miller-Bakewell,
Giovanni
de
Felice,
Leo
Lobski
&
John
van
de
Wetering
(2021):
There
and
back
again:
A
circuit
extrac-
tion
tale.
Quantum
5,
p.
421,
doi:10.22331/q-2021-03-25-421.
Available
at
http://dx.doi.org/10.22331/q-2021-03-25-421.
[4] Niel de Beaudrap,
Aleks Kissinger & John van de Wetering (2022):
Circuit Extrac-
tion for ZX-diagrams can be #P-hard,
doi:10.48550/ARXIV.2202.09194.
Available at
https://arxiv.org/abs/2202.09194.
[5] Anne Broadbent & Elham Kasheﬁ(2009): Parallelizing quantum circuits. Theoretical Computer
Science 410(26), pp. 2489–2510, doi:10.1016/j.tcs.2008.12.046.
[6] Daniel
E
Browne,
Elham
Kasheﬁ,
Mehdi
Mhalla
&
Simon
Perdrix
(2007):
Gen-
eralized
ﬂow
and
determinism
in
measurement-based
quantum
computation.
New
Journal
of
Physics
9(8),
p.
250–250,
doi:10.1088/1367-2630/9/8/250.
Available
at
http://dx.doi.org/10.1088/1367-2630/9/8/250.
[7] Shuxiang Cao (2022): Multi-agent blind quantum computation without universal cluster state,
doi:10.48550/ARXIV.2206.13330. Available at https://arxiv.org/abs/2206.13330.
[8] Bob Coecke & Aleks Kissinger (2017): Picturing Quantum Processes: A First Course in Quantum
Theory and Diagrammatic Reasoning. Cambridge University Press, doi:10.1017/9781316219317.
[9] Alexander
Cowtan,
Silas
Dilkes,
Ross
Duncan,
Will
Simmons
&
Seyon
Sivarajah
(2020):
Phase Gadget Synthesis for Shallow Circuits.
Electronic Proceedings in The-
oretical
Computer Science 318,
pp. 213–228,
doi:10.4204/eptcs.318.13.
Available at
https://doi.org/10.4204%2Feptcs.318.13.
[10] Vincent
Danos
&
Elham
Kasheﬁ
(2006):
Determinism
in
the
one-way
model.
Phys.
Rev.
A
74,
p.
052310,
doi:10.1103/PhysRevA.74.052310.
Available
at
https://link.aps.org/doi/10.1103/PhysRevA.74.052310.
[11] Vincent Danos, Elham Kasheﬁ& Prakash Panangaden (2005): Parsimonious and robust re-
alizations of unitary maps in the one-way model.
Physical Review A 72(6), p. 064301,
doi:10.1103/PhysRevA.72.064301.
[12] Ross
Duncan,
Aleks
Kissinger,
Simon
Perdrix
&
John
van
de
Wetering
(2020):
Graph-theoretic
Simpliﬁcation
of
Quantum
Circuits
with
the
ZX-
calculus.
Quantum
4,
p.
279,
doi:10.22331/q-2020-06-04-279.
Available
at
https://doi.org/10.22331/q-2020-06-04-279.
[13] Ross Duncan & Simon Perdrix (2009): Graph States and the Necessity of Euler Decomposi-
tion. In Klaus Ambos-Spies, Benedikt Löwe & Wolfgang Merkle, editors: Mathematical The-
ory and Computational Practice, Springer Berlin Heidelberg, Berlin, Heidelberg, pp. 167–177,
doi:10.1007/978-3-642-03073-4_18.

14
Flow-preserving ZX-calculus rewrite rules for optimisation and obfuscation
[14] Emmanuel Jeandel, Simon Perdrix & Renaud Vilmart (2018): A Complete Axiomatisation of
the ZX-Calculus for Clifford+T Quantum Mechanics.
In:
Proceedings of the 33rd Annual
ACM/IEEE Symposium on Logic in Computer Science, LICS ’18, Association for Comput-
ing Machinery, New York, NY, USA, p. 559–568, doi:10.1145/3209108.3209131. Available at
https://doi.org/10.1145/3209108.3209131.
[15] Emmanuel Jeandel, Simon Perdrix & Renaud Vilmart (2018):
Diagrammatic Reasoning be-
yond Clifford+T Quantum Mechanics.
In:
Proceedings of the 33rd Annual ACM/IEEE
Symposium on Logic in Computer Science, LICS ’18, Association for Computing Ma-
chinery, New York, NY, USA, p. 569–578, doi:10.1145/3209108.3209139.
Available at
https://doi.org/10.1145/3209108.3209139.
[16] Aleks Kissinger & John van de Wetering (2020): Reducing the number of non-Clifford gates in
quantum circuits. Physical Review A 102(2), p. 022406, doi:10.1103/PhysRevA.102.022406.
[17] Tommy McElvanney & Miriam Backens (2022): Complete ﬂow-preserving rewrite rules for
MBQC patterns with Pauli measurements, doi:10.48550/ARXIV.2205.02009.
Available at
https://arxiv.org/abs/2205.02009.
[18] Mehdi Mhalla, Mio Murao, Simon Perdrix, Masato Someya & Peter S Turner (2011): Which graph
states are useful for quantum information processing? In: Conference on Quantum Computation,
Communication, and Cryptography, Springer, pp. 174–187, doi:10.1007/978-3-642-54429-3_12.
[19] Jisho
Miyazaki,
Michal
Hajdušek
&
Mio
Murao
(2015):
Analysis
of
the
trade-off
between
spatial
and
temporal
resources
for
measurement-based
quantum
computation.
Physical Review A 91(5),
p. 052302,
doi:10.1103/PhysRevA.91.052302.
Available at
https://link.aps.org/doi/10.1103/PhysRevA.91.052302.
[20] Kang Feng Ng & Quanlong Wang (2017):
A universal completion of the ZX-calculus,
doi:10.48550/arXiv.1706.09877. Available at http://arxiv.org/abs/1706.09877.
[21] Robert Raussendorf & Hans J. Briegel (2001): A One-Way Quantum Computer. Phys. Rev. Lett.
86, pp. 5188–5191, doi:10.1103/PhysRevLett.86.5188.
[22] Will Simmons (2021): Relating Measurement Patterns to Circuits via Pauli Flow. In Chris He-
unen & Miriam Backens, editors: Proceedings 18th International Conference on Quantum Physics
and Logic, Gdansk, Poland, and online, 7-11 June 2021, Electronic Proceedings in Theoretical
Computer Science 343, Open Publishing Association, pp. 50–101, doi:10.4204/EPTCS.343.4.
[23] Korbinian Staudacher (2021):
Optimization Approaches for Quantum Circuits using ZX-
calculus.
Master’s
thesis,
Ludwig-Maximilians-Universität,
München.
Available
at
https://www.mnm-team.org/pub/Diplomarbeiten/stau21/PDF-Version/stau21.pdf.
[24] Korbinian Staudacher, Tobias Guggemos, Sophia Grundner-Culemann & Wolfgang Gehrke (2022):
Reducing 2-qubit gate count for ZX-calculus based quantum circuit optimization.
[25] John van de Wetering (2020):
ZX-calculus for the working quantum computer scientist,
doi:10.48550/ARXIV.2012.13966. Available at https://arxiv.org/abs/2012.13966.
A
Splitting a vertex preserves the existence of Pauli ﬂow
The following case distinction forms part of the proof of Proposition 5.1.

T. McElvanney & M. Backens
15
Let G′, p′ and ≺′ be deﬁned as in Proposition 5.1. We shall show that (p′,≺′) satisfy the nine
conditions of Pauli ﬂow.
Claim 1: For all u ∈Oc, if v ∈p′(u) and u ̸= v and λ ′(v) /∈{X,Y}, then u ≺′ v.
• For original vertices u ∈V \ O, v ∈p′(u) implies v ∈p(u) or v ∈{x′,x′′}. If v ∈p(u)
then either u ≺v and thus u ≺′ v by the deﬁnition of ≺′ or λ(u) = λ ′(u) ∈{X,Y}. If
v = x′ then λ ′(v) = X and thus we don’t need to consider this case. Finally, if v = x′′ then
x ∈p(u), thus u ≺x which gives us u ≺′ v = x′′ by the deﬁnition of ≺′.
• For u = x′, the only element of p(x′) is x′′ and we have x′ ≺′ x′′.
• For u = x′′, v ∈p′(x′′) implies v ∈p(x) or v = x′. For the latter case, λ ′(x′) = X and
thus we do not need to consider this. In the former case, v ∈p(x) gives us that x ≺v or
λ(v) = λ ′(v) ∈{X,Y} as (p,≺) is a Pauli ﬂow. So either x′′ ≺v by the deﬁnition of ≺′
or the property is trivial anyway.
Claim 2: For all u ∈Oc, if v ∈OddG′ (p′(u)) and u ̸= v and λ ′(v) /∈{Y,Z}, then u ≺′ v.
• For original vertices u ∈V \ O, we have deﬁned p′ in such a way that OddG′ (p′(u)) =
OddG (p(u)), thus this property is inherited from (p,≺) being a Pauli ﬂow.
• For u = x′, we have OddG′ (p′(x′)) =W ∪{x′}, and x′ ≺′ w for any w ∈W by the deﬁnition
of ≺′.
• For u = x′′, v ∈OddG′ (p′(x′′)) and v ̸= x′′ implies v ∈OddG (p(x)) by (3). As x′′ has the
same successors as x, we get that x′′ ≺′ v as desired.
Claim 3: For all u ∈Oc, if ¬(u ≺′ v) and u ̸= v and λ ′(v) = Y, then v ∈p′(u) ←→v ∈OddG′ (p′(u)).
• For original vertices u ∈V \ O, this is inherited from (p,≺), as the only changes to
correction sets and odd neighbourhoods involve adding or removing x or x′, which are
not Y-measured.
• For u = x′, we have p′(x′)∪OddG′ (p′(x′)) =W ∪{x′,x′′}. By the deﬁnition of the partial
order, x′ ≺x′′ and x′ ≺′ w for all w ∈W, so the claim is trivially true.
• For u = x′′,
λ ′(v) = Y and v ∈p′(x′′) implies v ∈p(x).
As (p,≺) is a focused Pauli ﬂow, we must have v ∈OddG (p(x)), thus v ∈OddG′ (p′(x))
and ﬁnally v ∈OddG′ (p′(x′′)) by (3).
For the other direction,
λ ′(v) = Y and v ∈OddG′  p′(x′′)

implies v ∈OddG (p(x)).
As (p,≺) is a Pauli ﬂow, v ∈p(x) thus v ∈p′(x) and ﬁnally v ∈p′(x′′), as desired.
Claim 4: For all u ∈Oc, if λ ′(u) = XY, then u /∈p′(u) and u ∈OddG′ (p(u)).
• If u = x′′, then this is true by inspection.
• If u = x′, then the claim is true trivially since λ ′(x′) ̸= XY.
• If u ∈V \O, then this property is inherited from (p,≺).
Claim 5: For all u ∈Oc, if λ ′(u) = XZ, then u ∈p′(u) and u ∈OddG′ (p′(u)).
• This is trivially true as we have no XZ-measured vertices.
Claim 6: For all u ∈Oc, if λ ′(u) = YZ, then u ∈p′(u) and u /∈OddG′ (p′(u)).

16
Flow-preserving ZX-calculus rewrite rules for optimisation and obfuscation
• This is trivially true as we have no YZ-measured vertices.
Claim 7: For all u ∈Oc, if λ ′(u) = X, then u ∈OddG′ (p′(u)).
• if u = x′′, then this is true trivially since λ ′(x′′) ̸= X.
• If u = x′, then the claim is true by (2).
• If u ∈V \O, then this property is inherited from (p,≺).
Claim 8: For all u ∈Oc, if λ ′(u) = Z, then u ∈p′(u).
• This is trivially true as we have no Z-measured vertices.
Claim 9: For all u ∈Oc, if λ ′(u) = Y, then u ∈p′(u) and u /∈OddG (p′(u)), or u /∈p′(u) and u ∈
OddG (p′(u)).
• This is true trivially for x, x′ and x′′, and inherited for all other vertices.
All nine properties are satisﬁed, therefore (p′,≺′) is a Pauli ﬂow for G′.

