

Software Development for Engineers
with C, Pascal, C++, Assembly
Language, Visual Basic, HTML,
JavaScript and Java
William J. Buchanan, BSc, CEng, PhD
Senior Lecturer, Department of Electrical and Electronic Engineering, Napier
University, Edinburgh, UK

Table of Contents
Cover image
Title page
Dedication
Copyright
Preface
PART A: C/PASCAL
Chapter 1: Introduction
1.1 Introduction
1.2 Hardware, Software And Firmware
1.3 Basic Computer Architecture
1.4 Compiling, Linking And Producing An Executable Program
1.5 C Compilation
1.6 Pascal Compilation
1.7 Introduction To C
1.8 Introduction To Pascal

1.9 Exercises
Chapter 2: Input/Output
2.1 Introduction
2.2 Pascal Input/Output
2.3 C Input/Output
2.4 Examples
Chapter 3: Selection Statements
3.1 If … Else Statements
3.2 Switch Statement
3.3 Exercises
Chapter 4: Repetitive Statements
4.1 Introduction
4.2 For
4.3 Examples
4.4 Exercises
4.5 While()
4.6 Repeat..Until() And Do..While()
4.7 Examples
4.8 Exercises
Chapter 5: Functions
5.1 Introduction
5.2 Arguments And Parameters
5.3 C Functions

5.4 Pascal Functions
5.5 Examples
5.6 Exercises
Chapter 6: Parameter Passing
6.1 Introduction
6.2 Pascal Parameter Passing
6.3 C Parameter Passing
6.4 Examples
6.5 Exercises
Chapter 7: Arrays
7.1 Introduction
7.2 C Arrays
7.3 Pascal Arrays
7.4 Examples
7.5 Exercises
Chapter 8: Strings
8.1 Introduction
8.2 Pascal Strings
8.3 C Character Arrays
8.4 Examples
8.5 Exercises
Chapter 9: File I/O
9.1 Introduction

9.2 Pascal File I/O
9.3 C File I/O
9.4 Examples
9.5 Reading And Writing One Character At A Time
9.6 Exercises
Chapter 10: Structures and Records
10.1 Introduction
10.2 Records In Pascal
10.3 Structures In C
10.4 Array Of Structures
10.5 Exercises
PART B: C++
Chapter 11: Introduction to C++
11.1 Introduction
11.2 Enhancements To C++
11.3 I/O Stream
11.4 Comments
11.5 Function Overloading
11.6 Classes
11.7 Complex Numbers
11.8 Exercises
Chapter 12: More C++
12.1 Constructors And Destructors

12.2 Function Templates
12.3 Class Templates
12.4 I/O Streams
12.5 Exercises
PART C: Assembly Language
Chapter 13: Introduction
13.1 Introduction
13.2 Basic Computer Architecture
13.3 Bits And Bytes
13.4 Binary Arithmetic
13.5 Numbers And Representations
13.6 Memory Addressing Size
13.7 Exercises
Chapter 14: Computer Architecture
14.1 History Of The PC
14.2 Intel Microprocessors
14.3 80386/ 80486 Microprocessor
14.4 Registers
14.5 Memory Segmentation
14.6 View Inside The Processor
14.7 Machine Code And Assembly Language
14.8 Exercises
Chapter 15: 8086/88 Instructions

15.1 Introduction
15.2 Characters And Numbers
15.3 Comments
15.4 Move (MOV)
15.5 Addressing Memory
15.6 Addition And Subtraction (ADD And SUB)
15.7 Compare (CMP)
15.8 Unary Operations (INC, DEC And NEG)
15.9 Boolean Bitwise Instructions (AND, OR, XOR And NOT)
15.10 Shift/Rotate Instructions (SHL, SAL, SHR, SAR, ROL, ROR, RCL And RCR)
15.11 Unconditional Jump (JMP)
15.12 Conditional Jumps
15.13 Subroutine Calls (CALL And RET)
15.14 Push And Pop
15.15 Moving Around Data In Memory
15.16 Assembler Directives
15.17 Data Definition
15.18 Equates (EQU)
15.19 Exercises Part 1
15.20 Exercises Part 2
Chapter 16: 8086 Interfacing and Timing
16.1 Introduction
16.2 Interfacing With Memory
16.3 Memory Mapped I/O
16.4 Isolated I/O
16.5 Digital I/O Using The 8255

16.6 Digital I/O Programs
16.7 Timing
16.8 Exercises
Chapter 17: 8086 Interrupts
17.1 Interrupts (INT)
17.2 Interrupt 21h: DOS Services
17.3 Interrupt 10h: BIOS Video Mode
17.4 Interrupt 11h: BIOS Equipment Check
17.5 Interrupt 13h: BIOS Disk Access
17.6 Interrupt 14h: BIOS Serial Communications
17.7 Interrupt 17h: BIOS Printer
17.8 Interrupt 16h: BIOS Keyboard
17.9 Interrupt 19h: BIOS Reboot
17.10 Interrupt 1Ah: BIOS System Time
17.11 C And Pascal Interrupts
17.12 Exercises
PART D: Visual Basic
Chapter 18: Introduction
18.1 Introduction
18.2 Event-Driven Programming
18.3 Visual Basic Files
18.4 Other Terms
18.5 Main Screen
18.6 Properties Window

18.7 Controls And Event
18.8 Exercises
Chapter 19: Visual Basic Language
19.1 Introduction
19.2 Programming Language
19.3 Entering A Program
19.4 Language Reference
19.5 Exercises
Chapter 20: Forms
20.1 Introduction
20.2 Setting Properties
20.3 Forms And Code
20.4 Temperature Conversion Program
20.5 Quadratic Roots Program
20.6 Resistance Calculation With Slider Controls Program
20.7 Exercises
Chapter 21: Menus and Dialog Boxes
21.1 Introduction
21.2 Menu Editor
21.3 Common Dialog Control
21.4 Running An Application Program
21.5 Exercises
Chapter 22: Events

22.1 Introduction
22.2 Program Events
22.3 Exercises
Chapter 23: Graphics
23.1 Introduction
23.2 Loading Graphics Files
23.3 Colours
23.4 Drawing
23.5 Exercises
PART E: HTML/Java
Chapter 24: HTML (Introduction)
24.1 Introduction
24.2 Links
24.3 Lists
24.4 Colours
24.5 Background Images
24.6 Displaying Images
24.7 Horizontal Lines
24.8 Exercises
Chapter 25: Further HTML
25.1 Introduction
25.2 Anchors
25.3 Tables

25.4 CGI Scripts
25.5 Forms
25.6 Multimedia
25.7 Exercises
Chapter 26: JavaScript
26.1 Introduction
26.2 JavaScript Language
26.3 JavaScript Values, Variables And Literals
26.4 Expressions And Operators
26.5 JavaScript Operators
26.6 JavaScript Statements
26.7 Conditional Statements
26.8 Loops
26.9 Comments
26.10 Functions
26.11 Objects And Properties
26.12 Document Objects
26.13 Event Handling
26.14 Window Objects
26.15 Object Manipulation Statements And Operators
26.16 Exercises
Chapter 27: Java (Introduction)
27.1 Introduction
27.2 Creating An Applet
27.3 Applet Basics

27.4 Stand-Alone Programs
27.5 Java Reserved Words
27.6 Applet Variables
27.7 Java Operators
27.8 Mathematical Operations
27.9 Loops
27.10 Conditional Statements
27.11 Exercises
Chapter 28: Java (Extended functions)
28.1 Introduction
28.2 Initialization And Exit Functions
28.3 Mouse Events
28.4 Mouse Selection
28.5 Keyboard Input
28.6 Graphics Images
28.7 Graphics
28.8 Sound
28.9 Dialog Boxes
28.10 Fonts
28.11 Exercises
PART F: DOS
Chapter 29: Introduction
29.1 Introduction
29.2 Introduction To DOS

29.3 Disks
29.4 Formatting Floppy Disks (FORMAT)
29.5 File System Structure
29.6 DOS Filenames
29.7 File Types
29.8 Listing Files (DIR)
Chapter 30: DOS File System/Editor
30.1 Changing Directory (CD Or CHDIR)
30.2 Making A Directory (MKDIR Or MD)
30.3 Viewing A File (TYPE)
30.4 Wild-Cards (*Or?)
30.5 Creating A Text File
30.8 Deleting Files (DEL Or ERASE)
30.9 Copying Files (COPY)
PART G: Windows 3.x
Chapter 31: Introduction
31.1 Introduction
31.2 Running Windows
31.3 Windows Desktop
31.4 Window Items
31.5 Mouse Controls
31.6 Program Manager Menus
31.7 Moving And Resizing A Window
31.8 Closing A Window With The Control Menu

31.9 Exercises
Chapter 32: File Management
32.1 Introduction
32.2 File Manager
32.3 Exercises
PART H: Windows 95/NT
Chapter 33: Windows 95/NT
33.1 Introduction
33.2 Servers, Workstations And Clients
33.3 Workgroups And Domains
33.4 Windows NT User And Group Accounts
33.5 File Systems
33.6 Running Windows 95 And NT
33.7 Basic Windows NT/95
33.8 Mouse Controls
33.9 Quitting Windows
33.10 Moving And Resizing A Window
33.11 Closing A Window With The Control Menu
33.12 Start
33.13 My Computer
33.14 Running DOS
33.15 Windows 95/NT Network Drives
33.16 Exercises

Chapter 34: Extra Windows
34.1 Saving Important Set-Up Files
34.2 Running A Program When Windows Starts Up
34.3 Capturing Windows Screen
34.4 Swapping Between Applications
34.5 Terminating Programs Which Have Crashed
34.6 Windows File Extensions
34.7 Exercises
PART I: UNIX
Chapter 35: Introduction to UNIX
35.1 Introduction
35.2 Login Into The System
35.3 Directory Structure
35.4 On-Line Manual
35.5 Changing Directory
35.6 Listing Directories
35.7 File Attributes
35.8 Special Characters (*,? And [ ])
35.9 Listing Contents Of A File
35.10 Making And Removing Directories
35.11 Copying, Renaming And Removing
35.12 Standard Input And Output
35.13 Compiling C Programs
35.14 Displaying The Time And Date
35.15 Where To Find Things

35.16 Exercises
35.17 Summary
Chapter 36: UNIX Commands
36.1 Process Control
36.2 Compilers
36.3 File Manipulation Commands
36.4 Other Commands
36.5 Exercises
Chapter 37: Editing and Text Processing
37.1 Introduction
37.2 Visual Editor
37.3 Example Of Text Editing
37.4 Sed Editor
37.5 Grep
37.6 Sort
37.7 Exercises
Chapter 38: Csh (C Shell)
38.1 Introduction
38.2 Entering The C Shell
38.3 Leaving The C Shell
38.4 History
38.5 Reexecuting Events
38.6 Alias
38.7 Variables

38.8 Special Forms ($#, $? And ~)
38.9 Shell Variables
38.10 Shell Scripts
38.11 Control Structures
38.12 Automatically Executed C Shell Scripts (.Login.cshrc)
38.13 Exercises
APPENDIX A: Java Classes
APPENDIX B: ANSI-C Functions
APPENDIX C: Turbo Pascal Reference
APPENDIX D: Assembly Language Reference
APPENDIX E: ASCII Character Set
Index

Dedication
This book is dedicated to the memory of my Grandmother

Copyright
First published in Great Britain in 1997 by Arnold, a member of the Hodder
Headline Group, 338 Euston Road, London NW1 3BH
http://www.arnoldpublisher.com
Copublished in North, Central and South America by John Wiley & Sons Inc.,
605 Third Street,
New York, NY 10158-0012
© 1997 William Buchanan
All rights reserved. No part of this publication may be reproduced or transmitted
in any form or by any means, electronically or mechanically, including
photocopying, recording or any information storage or retrieval system, without
either prior permission in writing from the publisher or a licence permitting
restricted copying. In the United Kingdom such licences are issued by the
Copyright Licensing Agency: 90 Tottenham Court Road, London W1? 9HE.
Whilst the advice and information in this book is believed to be true and accurate
at the date of going to press, neither the author nor the publisher can accept any
legal responsibility or liability for any errors or omissions that may be made.
British Library Cataloguing in Publication Data
A catalogue record for this book is available from the British Library Library of
Congress Cataloging-in-Publication Data
A catalog record for this book is available from the Library of Congress ISBN 0
340 70014 9
ISBN 0 471 85266 2 (Wiley)
Publisher: David Ross
Production Editor: James Rabson Production Controller: Sarah Kett Cover
designer: Terry Griffiths Printed and bound in Great Britain by J W Arrowsmith,
Bristol

Preface
Specialization in software development is becoming a thing of the past.
Previously many software developers specialized on software languages such as
FORTRAN, C and Pascal. This was mainly because these languages allowed
access to all the required functionality. In modern times with the move towards
graphical user interface programming a developer must choose not only the
required software language(s) but also the required set of development tools for
a specific purpose. Typical decision might be to:
• Minimize development time;
• Create a usable interface (such as DOS, or Microsoft Windows or X-
Windows, and so on);
• Operate within critical timings (such as the use of fast code, or that DOS
programs generally operate faster than Microsoft Windows programs, or
that compiled programs generally work faster than interpreted programs);
• Integrate with other software or systems (such as the integration with
previous written software, different operating systems or with
precompiled libraries);
• Maintain the long-term development of the program (typical questions might
be: will there be updates to the development tools; will the development
company still be around in a few years?, and so on).
Typical modern development languages are C/C++, Visual Basic, Ada
(especially in military applications), Java and Delphi. This book introduces
C/C++ which can be used in C/C++ and Java development applications. Pascal
is useful in developing Delphi and Ada applications. Visual Basic is used to
write Microsoft Windows applications, and 80X86 Assembly Language
programming is useful in writing extremely fast sections of code and in
appreciating the operation of the PC.
The main objective of the text is to provide a single source of reference and
learning material for most of the main technical programming languages. It can
be used by undergraduates through a course of study from first year to final and

from introductory tutorial work to advanced user interfaces and project work. It
can also be used by professional developers with a knowledge of one or more of
the software development language who wish to learn some, or all, of the others,
or how these languages can be used in ‘real-life’ applications.
The text splits into nine main sections:
Part A: Pascal/C programming – gives an introduction to structured software
development using Pascal and C.
Part B: C++ programming – gives an introduction to object-oriented design
with C++.
Part C: 80x86 Assembly Language programs – gives an introduction to
Assembly Language programming and PC architecture.
Part D: Visual Basic programming – gives an introduction to the development
of graphical user interfaces for Microsoft Windows.
Part E: HTML and Java programs – show how to develop WWW-based pages
and gives an introduction to Java.
Part F: DOS.
Part G: Windows 3.
Part H: Windows 95.
Part I: UNIX.
The text uses C and Pascal to provide a basic grounding in software
development. These are used to show structured software development concepts,
such as repetition, decision making and modular development. The more
advanced concepts of object-oriented design is introduced with the C++
development. The Visual Basic section contains program examples which can be
used to develop graphical user interface programs.
Many software development job advertisements now specify the requirement
for a mixture of software languages on possibly several different operating
systems. Software development has thus evolved to the point where it is possible
to integrate different software tools to produce the required system. The user
interface of a program might be developed using a graphical programming
language such as Visual Basic and various specialized modules within the
program could be developed in C/C++. In summary, in a changing employment
market:
‘it is essential to become multi-skilled in different areas and applications’.


PART A
C/PASCAL

1
Introduction
1.1 Introduction
Software development has grown over the years from simple BASIC programs
written on small hobby computers to large software systems that control
factories. Many applications that at one time used dedicated hardware are now
implemented using software and programmable hardware. This shift in emphasis
has meant that, as a percentage, an increasing amount of time is spent on
software and less on hardware development.
Electrical, electronic and software engineers require a great deal of flexibility
in their approach to system development. They must have an understanding of
all levels of abstraction of the system, whether it be hardware, software or
firmware. The system itself could range from a small 4-bit central heating
controller to a large industrial control system. In the development of any system
the engineer must understand the system specification from its interface
requirements, its timing requirements, its electrical characteristics, and so on.
The software that runs on a system must be flexible in its structure as the
developer could require to interrogate memory addresses for their contents or to
model a part of the system as an algorithm. For this purpose the programming
languages C and Pascal are excellent in that they allow a high-level of
abstraction (such as algorithm specification) and allow low-level operations
(such as operations on binary digits). They have a wide range of applications,
from commerce and business to industry and research, which is a distinct
advantage as many software languages have facilities that make them useful
only in a particular environment. For example, in the past, business and
commercial applications used COBOL extensively, whereas engineering and
science used FORTRAN.
1.2 Hardware, software and firmware

A system consists of hardware, software and firmware, all of which interconnect.
Hardware is ‘the bits that can be touched’, that is, the components, the screws
and nuts, the case, the electrical wires, and so on. Software is the programs that
run on programmable hardware and change their operation depending on the
inputs to the system. These inputs could be taken from a keyboard, interface
hardware or from an external device. The program itself cannot exist without
some form of programmable hardware such as a microprocessor or controller.
Firmware is a hardware device that is programmed using software. Typical
firmware devices are EEPROMs (Electrically Erasable Read Only Memories),
and interface devices that are programmed using registers.
In most applications, dedicated hardware is faster than hardware that is
running software, although systems running software programs tend to be easier
to modify and require less development time.
1.3 Basic computer architecture
The main elements of a basic computer system are a central processing unit (or
microprocessor), memory, and input/output (I/O) interfacing circuitry. These are
interconnected by three main buses: the address bus; the control bus; and the
data bus, as illustrated in Figure 1.1. External devices such as a keyboard,
display, disk drives, and so on, can connect directly onto the data, address and
control buses, or connect through I/O interfacing circuitry.
FIGURE 1.1  Block diagram of a simple computer system
Memory normally consists of RAM (random access memory) and ROM (read
only memory). ROM stores permanent binary information, whereas RAM is a
non-permanent memory and loses its contents when the power is taken away.
RAM memory is used to run application programs and to store information

temporarily.
The microprocessor is the main controller of the computer. It fetches binary
instructions (known as machine code) from memory, it then decodes these into a
series of simple actions and carries out the actions in a sequence of steps. These
steps are synchronized by a system clock.
The microprocessor accesses a memory location by putting its address on the
address bus. The contents at this address are placed on the data bus and the
microprocessor reads the data from the data bus. To store data in memory the
microprocessor places the data on the data bus. The address of the location in
memory is then put on the address bus and the data is then read from the data
bus into the required memory address location.
1.4 Compiling, linking and producing an
executable program
A microprocessor only understands binary information and operates on a series
of binary commands known as machine code. It is extremely difficult to write
large programs in machine code, so that high-level languages are used instead. A
low-level language is one which is similar to machine code and normally
involves the usage of keyword macros to replace machine code instructions. A
high-level language has a syntax that is almost like written English and thus
makes a program easy to read and to modify. In most programs the actual
operation of the hardware is invisible to the programmer.
A compiler changes the high-level language into machine code. High-level
languages include C, BASIC, COBOL, FORTRAN and Pascal; an example of a
low-level language is 80386 Assembly Language.
Figure 1.2 shows the sequence of events that occur to generate an executable
program from a C or Pascal source code file (the filenames used in this example
relate to a PC-based system). An editor creates and modifies the source code file;
a compiler then converts this source code into a form which the microprocessor
can understand, that is, machine code. The file produced by the compiler is
named an object code file code (note that Turbo Pascal does not produce an
object code file). This file cannot be executed as it does not have all the required
information to run the program. The final stage of the process is linking, which
involves adding extra machine code into the program so that it can use devices
such as a keyboard, a monitor, and so on. A linker links the object code file with
other object code files and with libraries to produce an executable program.

These libraries contain other object code modules that are compiled source code.
FIGURE 1.2  Edit, compile and link processes
If compilation or linking steps generate errors or warnings then the source
code must be modified to eliminate them and the process of compilation/linking
begins again. Warnings in the compile/link process do not stop the compiler or
linker from producing an output, but errors will. All errors in the compilation or
linking stage must be eliminated, whereas it is only advisable to eliminate
warnings.
1.5 C compilation
Borland C++ Version 3.0 is an integrated development package available for
PC-based systems. It contains an editor, compiler, linker and debugger (used to
test programs). The editor creates and modifies source code files and is initiated
by running BC.EXE. Figure 1.3 shows a main screen with a source code file
PROG1_1.C.

FIGURE 1.3  Borland C++ Version 3.0 main screen
Figure 1.4 shows the compile menu options within this package. A source
code file is compiled by selecting Compile to OBJ. If there are no errors an
object code file is produced (in this case PROG_1.OBJ). This is linked using Link
EXE file (producing the file PROG_1.EXE). A compile and link process can also
be initiated using the Make EXE file option. Programs are run from the Run
menu option.
FIGURE 1.4  Borland C++ Version 3.0 compile menu options
1.6 Pascal compilation
Turbo Pascal Version 5.0 is an integrated development package available for
PC-based systems. It contains an editor, compiler, linker and debugger (used to

test programs). The editor creates and modifies source code files and is initiated
by running TURBO. EXE. Figure 1.5 shows a main screen with a source code file
PROG1_1.PAS.
FIGURE 1.5  Turbo Pascal Version 5.0 main screen
Figure 1.6 shows the compile menu options within this package. A source
code file is compiled by selecting Compile. If there are no errors then an
executable program is produced. If the destination is given as Memory then it
does not save the executable file to the disk but runs it from memory. If the
destination is to the Disk then an executable file will be produced (producing the
file PROG_1.EXE). The destination can be toggled by pressing the ENTER key
while the line cursor is on the Destination option. A program is run from the
Run menu option.

FIGURE 1.6  Turbo Pascal Version 5.0 compile menu options
1.7 Introduction to C
This section gives a brief introduction to ANSI-C.
1.7.1 Preprocessor
The preprocessor acts on programs before the compiler. It uses commands that
have a number-sign symbol (‘#’) as the first non-blank character on a line.
Figure 1.7 shows its main uses, which are: including special files (header files)
and defining various macros (or symbolic tokens). The #include directive
includes a header file and #define defines macros. By placing these directives
near the top of a source code file then all parts of the program have access to the
information contained in them.
FIGURE 1.7  Operations on the program to produce an executable file
For example, the preprocessor directive:
includes the header file main.h. The inverted commas inform the preprocessor
that this file will be found in the current working directory, while the directive

includes the file stdio.h found in the default include directory. This directory
is normally set-up automatically by the system. For example, Turbo C Version
2.0 stores its header files, by default, in the directory \TC\INCLUDE and Borland
C uses \BORLANDC\INCLUDE. Typically, header files on a Unix system are stored
in the usrinclude directory.
To summarize, inverted commas (” “) inform the preprocessor to search for
the specified header file in the current directory (or the directory specified in the
pathname). The chevron characters (< >) inform the preprocessor to search in the
default include directory. It is not advisable to include any other file apart from
header files. These have a ‘.h’ file extension (although this is not obligatory).
Standard header files are used in conjunction with functions contained in
libraries. They do not contain program code, but have information relating to
functions. A given set of functions, such as maths or I/O, has a header file
associated with it. Table 1.1 gives typical header files and their functionality.
Table 1.1
Typical header files
Header
file
Comment
ctype.h
character classification and conversion
Math.h
maths functions
stddef.h
defines several common data types and macros
stdio.h
Input/Output (I/O) routines, such as input from keyboard, output to display and file handling (stdio is
a contraction of standard input/output)
stdlib.h
miscellaneous routines
string.h
string manipulation functions
time.h
time functions
A macro replaces every occurrence of a certain token with another specified
token. The following examples show substitutions using the #define directive.
Typically, as a matter of programming style, the definitions of constants, such

as π, are given in uppercase characters.
1.7.2 Structure
Normally programs are split into a number of sub-tasks named functions. These
are clearly distinctive pieces of code that perform particular operations. The
main function (main ()) is the basic routine for controlling the flow of the
program and calls other sub-functions.
C Program 1.1 is a simple program which uses the puts() function to display
the text “Essence of Software”. The puts() function is a standard function
used to output text to the display; the header file associated with it is stdio.h.
This header file is included using the #include directive.
The statement terminator (;) is used to end a line of code (or statement) and
braces ({}) show the beginning ({) and end (}) of a block of code. Comments are
inserted in the program between a start comment identifier (/*) and an end
identifier (*/).
All C programs have a main() function which defines the entry point into the
program and, by means of calling functions, controls general program flow. It
can be located anywhere in the source code program, but is normally placed near
the top of the file it is located in (making it easier to find). The int keyword
preceding main() defines that the program returns a value to the operating
system (or calling program). In this case, the return value is 0 (return (0)).
Normally, a non-zero return value is used when the program has exited due to an
error; the actual value of this gives an indication of why the program has exited.
The void within the parenthesis of main() defines that there is no
communication between the program and the operating system (that is, no values
are passed into the program). Figure 1.8 shows the basic structure of a C
program.

FIGURE 1.8  C program structure
1.7.3 Data Types
Variables within a program can be stored as either numbers or characters. For
example, the resistance of a copper wire would be stored as a number (a real
value) and the name of a component (such as, “R1”) would be stored as
characters. Table 1.2 gives the four basic data types which define the format of
variables.
Table 1.2
Basic data types
Type
Usage
char
single character ‘a’, ‘1’, and so on
int
signed integer
float
single-precision floating point
double
double-precision floating point
There are three basic extensions for the four types; these are:
An integer is any value without a decimal point; its range depends on the
number of bytes used to store it. A floating point value is any number and can
include a decimal point; this value is always in a signed format. Again, the range
depends on the number of bytes used.

Integers normally take up 2 or 4 bytes in memory, depending on the compiler
implementation. This gives ranges of –32768 to 32767 (a 2-byte int) and –2
147483 648 to 2 147483 647 (a 4-byte int), respectively.
1.7.4 Declaration Of Variables
A program uses variables to store data. Before the program can use a variable, its
name and its data type must first be declared. A comma groups variables of the
same data type. For example, if a program requires integer variables num_steps
and bit_mask, floating point variables resistor1 and resistor2, and two
character variables char1 and char2, then the following declarations can be
made:
C Program 1.2 is a simple program that determines the equivalent resistance
of two resistors of 1000 Ω and 500 Ω connected in parallel. It contains three
floating point declarations for the variables resistor1, resistor2 and
equ_resistance.
It is also possible to assign an initial value to a variable at the point in the
program at which it is declared; this is known as variable initialization. C
Program 1.3 gives an example of this with the declared variables resistor1 and
resistor2 initialized to 1000.0 and 500.0, respectively.

1.7.5 Keywords
ANSI-C has very few reserved keywords (only 32); these cannot be used as
program identifiers. C is case-sensitive and thus they must be used in lowercase.
From these simple building blocks large programs can be built. The following
gives a list of the keywords.
Functions are sections of code that perform a specified operation. They
receive some input and produce an output in a way dictated by their
functionality. These can be standardized functions which are inserted into
libraries or are written by the programmer. ANSI-C defines some standard
functions which provide basic input/output to/from the keyboard and display,
mathematical functions, character handling, and so on. They are grouped
together into library files and are not an intrinsic part of the language. These
libraries link into a program to produce an executable program.
1.8 Introduction to Pascal
This section gives a brief introduction to Turbo Pascal.

1.8.1 Constant Declarations
Pascal uses the const keyword to defined constant numeric values. The
following examples show constant declarations for π and the speed of light
(which is 3×108).
In Pascal the case of the characters is ignored but, as a matter of programming
style, the definition of constants, such as π, is given in uppercase characters.
1.8.2 Structure
Normally programs are split into a number of sub-tasks named procedures or
functions. These are clearly distinctive pieces of code that perform particular
operations. The main program is the basic routine to control the flow of a
program and calls other sub-functions.
Pascal Program 1.1 is a simple program which uses the writeln procedure to
display the text ‘Essence of Software’. The writeln procedure is a standard
procedure which is used to output text to the display.
The statement terminator (;) is used to end a line of code (or statement) and
the keywords begin and end define the beginning and end of a block of code.
Comments are inserted into the program between a start comment identifier (/*)
and an end identifier (*/).
All Pascal programs have a main program which defines the entry point into
the program and, by means of calling functions and procedures, controls general
program flow. In most cases it is be located at the end of the source code file.
Figure 1.9 shows the basic structure of a Pascal program. Each program has a
program header which is defined with the program keyword. After this the

program variables are declared. In this case the variables declared are var1, var2
(which are integers) and var3, var4 (which are real values). The main program is
defined after the variable declaration and can be identified between the begin
and end keywords. The final end keyword has a full-stop after it.
FIGURE 1.9  Pascal program structure
1.8.3 Data Types
Variables within a program can be stored as either numbers or characters. For
example, the resistance of a copper wire would be stored as a number (a real
value) and the name of a component (such as, ‘R1’) would be stored as
characters. Table 1.3 gives the four basic data types which define the format of
variables.
Table 1.3
Basic Pascal data types
Type
Usage
Range
char
single character ‘a’, ‘1’, and so on
Character range
integer
signed integer
−32 768 to 32 767
real
single-precision floating point
2.9×19 39 to 1.7×1038
boolean
boolean type
true or false
Other data types used in Turbo Pascal include:

An integer is any value without a decimal point; its range depends on the
number of bytes used to store it. A floating point value is any number and can
include a decimal point; this value is always in a signed format. Again, the range
depends on the number of bytes used.
The integer type uses 2 bytes in memory. This gives ranges of –32768 to
32767 (a 2-byte int) and –2 147483 648 to 2 147483 647 (a 4-byte longint),
respectively.
1.8.4 Declaration Of Variables
A program uses variables to store data. Before the program can use a variable, its
name and its data type must first be declared. A comma groups variables of the
same data type. For example, if a program requires integer variables num_steps
and bit_mask, floating point variables resistor1 and resistor2, and two
character variables char1 and char2, then the following declarations can be
made:
Pascal Program 1.2 is a simple program that determines the equivalent
resistance of two resistors of 1000 Ω and 500 Ω connected in parallel. It contains
three floating point declarations for the variables resistor1, resistor2 and
eq_resistance.

1.8.5 Keywords
Turbo Pascal has 52 reserved keywords; these cannot be used as program
identifiers and can be in upper-or lowercase. Large programs can be built from
these simple building blocks. The following gives a list of the keywords.
Functions and procedures are sections of code that perform a specified
operation. They receive some input and produce an output in a way dictated by
their functionality. These can be standardized functions which are inserted into
libraries or are written by the programmer. Turbo Pascal defines some standard
functions which provide basic input/output to/from the keyboard and display,
mathematical functions, character handling, and so on. They are grouped
together into library files and are not an intrinsic part of the language. These
libraries link into a program to produce an executable program.
1.9 Exercises
1.9.1. Determine the errors in the C Programs 1.4 to 1.6 or the Pascal Programs
1.3 to 1.5. Each program has a single error. Enter them into the compiler
and after the error has been corrected, run them.

   

Worksheet 1:
W1.1. Which programming language is your choice for software development
(tick one):
c
[]
Turbo Pascal
[]
Mixture of C and Pascal
[]
W1.2. If you are running the compiler over the network then what is your login
name:
W1.3. Locate and run Pascal or C compiler:
W1.4. Enter either C Program 1.1 or Pascal Program 1.1 and save this to a file
on floppy disk as PROG1_1. PAS (for the Pascal file) or PROG1_1. C (for
the C file).

W1.5. Compile the program and note any messages that the compiler gives.
   
W1.6. If there are errors in the program then compare the entered file with the
program listing and try to identify how they differ. The compiler should
identify the location of the error (note look also at the line before). Then
recompile.
W1.7. After the program has been successfully compiled, run the program and
determine its output.
W1.8. Enter either C Program 1.2 or Pascal Program 1.2 and save file on floppy
disk as PROG1_2. PAS (for the Pascal file) or PROG1_2. C (for the C file).

W1.9. Using C Program 1.2 or Pascal Program 1.2 determine the equivalent
resistance for two parallel resistors. Use this program and by changing
the resistor values complete Table W1.1.
Table W1.1
Equivalent resistance
Resistor1 (Ω)
Resistor2 (Ω)
Equivalent resistance (Ω)
1000
1000
 
25
100
 
1e6 (1MΩ)
1e6
 
150
50
 

2
Input/Output
2.1 Introduction
Every program has some form of output and normally an input. Figure 2.1 shows
some examples of input and output devices. The input could be from a keyboard,
a file, input/output ports, a mouse, and so on. Output can be sent to devices such
as displays, printers, hard-disks, and so on. Typically, engineers also
communicate with devices such as ADC/DACs, LEDs, interface adapters, IC
programmers, and so on.

FIGURE 2.1  Input/output devices
The default input device is normal from a keyboard and the default output
from a display. Most programs prompt the user to enter data from the keyboard.
This data is then processed and the results displayed to the screen. The user can
then enter new data and so the cycle continues.
Most operating systems also allows a redirection of the input or output. For
example, a text file can act as an input to a program and the printer as the output.
2.2 Pascal input/output
Compared with C, Pascal has a very limited set of input/output statements (for
this reason this chapter contains many more pages on the C input/output
statements). Pascal uses the keyboard as the standard input and the display as the
standard output. The two statements which are used to control this input and
output are read and write.
2.2.1 Writeln
The statements used to output data from a program to the screen are writeln and
write. The write statement does not move the cursor to a newline once the data
has been printed, whereas the writeln will. The standard format is:
A text string is enclosed within quotes (’ ‘) and can be printed at any place in
the write statement. Values will be printed in a format defined by their type. For
example an integer will be displayed without a decimal point, a very large or
small real value will be displayed in exponent form. The actual format of the
value to be printed can be modified using the colon modifier, the standard format
is:

2.2.2 ReadIn
The statements used to input data into a program from the keyboard are read and
readln. The read statement does not move the cursor to a newline once the data
has been entered, whereas the readln will. The standard format is:
Pascal Program 2.1 shows a simple example of a program which uses
input/output statements
2.3 C input/output
The standard input/output (I/O) functions in C are not intrinsic (built-in) to the
language, but are stored in libraries that are linked into the program. The
#include preprocessor directive includes the header files associated with them.
Input/Output functions use stdio.h. In order to allow all parts of the source code
access to the functions defined in the header file the preprocessor directive is
located near the top of the file in which it is used. The compiler will then initiate
extra error checking whenever any of the standard I/O functions are used. C
Program 2.1 shows a program which includes the file stdio.h.

2.3.1 C Standard Output (Printf(), Puts() And
Putchar())
There are three basic output functions in C, these are:
The printf() function sends a formatted string to the standard output (the
display). This string can display formatted variables and special control
characters, such as new lines (‘\n’), backspaces (‘\b’) and tabspaces (‘\t’);
these are listed in Table 2.1.
Table 2.1
Special control (or escape sequence) characters
The puts() function writes a string of text to the standard output and no

formatted variables can be used. At the end of the text, a new line is
automatically appended.
The parameters passed into printf() are known as arguments; these are
separated commas. C Program 2.1 contains a printf() statement with only one
argument, that is, a text string. This string is referred to as the message string and
is always the first argument of printf(). It can contain special control
characters and/or parameter conversion control characters.
Conversion control characters describe the format of how the message string
uses the other arguments. If printf() contains more than one argument then the
format of the output is defined using a percent (%) character followed by a format
description character. A signed integer uses the %d conversion control characters,
an unsigned integer %u. A floating point value uses the %f conversion control
characters, while scientific notation uses %e. Table 2.2 lists the main conversion
control characters.
Table 2.2
Conversion control characters
Figure 2.2 shows an example of the printf() statement with four arguments.
The first argument is the message string followed by the parameters to be printed
in the message string. In this case the parameters are val1, val2 and ch; val1
is formatted in the message string as a floating point (%f), val2 as an integer (%d)
and ch as a character (%c). Finally, a new line character (‘\n’) is used to force a
new line on the output.

FIGURE 2.2  An example printf() statement
A numerical value is output to a given specification using a precision
specifier. This specifies the number of characters used to display the value and
the number of places after the decimal point. The general format of a floating
point value is:
where m is the width of the value (the number of digits including the decimal
point), n is the number of digits following the decimal point, and X is the format
type (f for float). The general format of a string or integer is:
where X is the format type (c for character, s for string or d for integer) and m
is the width of the output. Table 2.3 gives a few examples.
Table 2.3
Example of conversion control modifiers
Format
Function
%.3f
format floating point value with 3 decimal places and a default width
%8.3f
format floating point with 8 reserved spaces and 3 places after the decimal point such as 32.4 53
%10d
format integer for 10 reserved spaces such as 2 3
%3o
format octal integer number for 3 hexadecimal characters
%10.6e
format exponent format with 6 decimal places

2.3.2 C Standard Input (Scanf(), Gets() And
Getchar())
The keyboard is normally the standard input to a program. As with the output
functions, the input functions are not part of the standard language and are
contained in a standard C library. Definitions (or prototypes) of these functions
are found in the header file stdio.h. By including this header file a degree of
error checking is initiated at compilation. The compiler checks, among other
things, the data types of the parameters passed into the functions. It is thus less
likely that there will be any run-time errors.
There are three main input functions, these are:
If a numeric or a character variable is used with the scanf() function an
ampersand (&) precedes each parameter in the argument list (there are exceptions
and these will be discussed in Chapters 6 and 7). This prefix causes the memory
address of the variable to be used as a parameter and not the value. This allows
scanf() to change the value of the variable (this will also be explained in more
detail in Chapter 6). For now, it should be assumed that an ampersand precedes
all simple numerical and character data types when using scanf(). The general
format of the scanf() function is scanf (format,&arg1,&arg2 …).
The first argument format is a string that defines the format of all entered
values. For example, “% f %d” specifies that arg1 is entered as a float and arg2
as an integer. This string should only contain the conversion control characters
such as %d, %f, %c, %s, etc., separated by spaces. Figure 2.3 shows an
example of the scanf() function reading a float, an integer and a character into
the variables val1, val2 and ch.

FIGURE 2.3  An example of the scanf() statement
The gets (str) function reads a number of characters into a variable (in this
case str); these characters are read until the ENTER key is pressed. The
getchar() function reads a single character from the input. This character is
returned via the function header and not through the argument list.
2.4 Examples
This section contains some practical electronics-related examples of C and
Pascal programs. Each of the test runs relate to a run of the C program (although
most of the Pascal test runs are almost identical).
2.4.1 Fahrenheit To Centigrade Conversion
Temperature is typically measured in either centigrade or Fahrenheit. The
conversion from Fahrenheit to centigrade is: 
Program 2.2 converts from an entered value of Fahrenheit (faren) into
centigrade (cent), and Test run 2.1 shows a sample run for an entered value of
80°F. The resultant value is displayed with 8 places reserved for the answer and
2 decimal places. This is specified in C as % 8.2 f and in Pascal with :8:2 after
the variable.

2.4.2 Gradient Of A Straight Line
The equation of a straight line is:

where m is the gradient of the line and c is the point at which the line cuts the
y-axis. If two points on the line are known, (x1,y1) and (x2,y2) then m can be
calculated by: 
and the c value can be calculated from:
Program 2.3 determines the gradient of a straight line for entered value of
x1,y1 and x2,y2 (Note that the solution of the value for c will be left as an
exercise). Test run 2.2 is a sample test run.

2.4.3 Force Of Attraction
The gravitational force between two objects of mass m1 and m2 of a distance d
apart is given by: 
where G is a gravitation constant and is equal to 6.67×10−11 m3.kg_1sec−2.
Program 2.4 determines the gravitation force and Test run 2.3 shows a test run
for the gravitation force between an apple and the earth. The parameters used
are: 
The resultant gravitation force is 0.99 N, which is similar to the calculation
using:
The gravitation force constant (G) has been defined, in C, with the #define
statement and, in Pascal, with a const.


2.4.4 Capacitive Reactance
The reactance of a capacitor depends upon the applied frequency. At low
frequencies the reactance is extremely high and at high frequencies it is low. The
reactance (Xc) of a capacitor, of capacitance C (Farads), at an applied frequency f
(Hertz) is be given by: 
Figure 2.4 shows a schematic of this arrangement. There is one output
variable (Xc), two input variables (f and C) and a single constant (π). Program 2.5
shows a sample program and test run 2.4 is a sample run. In C a constant is
declared with the #define preprocessor option and Pascal uses the const
keyword.
FIGURE 2.4  Capacitor connected to sinusoidal voltage source

2.4.5 Impedance Of An RL Series Circuit
The magnitude of the impedance of an RL series circuit (modulus | Z |) is given
by the equation: 
and the angle of the impedance (argument Z ) is given by:

Figure 2.5 shows a schematic of an RL series circuit. Program 2.3 determines
the magnitude and the angle of the impedance using entered values of resistance
(R), inductance (L) and frequency (freq). In C the inverse tangent (tan−1)
function is defined (or prototyped) in math.h and is named atan(), whereas,
Pascal uses the arctan() function. Both these functions return the inverse
tangent in radians. The program converts the returned value into degrees by
scaling it by π/180.
FIGURE 2.5  RL series circuit
The program uses the square root function; in C this function is (sqrt())
which is prototyped in the math.h header file. This inclusion helps the compiler
check the format of the values sent to the function as it checks the general syntax
of the function call. It also informs the compiler that the value returned is a
floating point (this will be discussed in greater detail in a later chapter). In Pascal
it is also named sqrt().
Test run 2.5 is a sample output using entered values R = 100 Ω, L = 100mH
and frequency = 1 kHz. The impedance has a magnitude of 118.10 Ω and an
angle of 32.14°.

2.4.6 Resistors In Parallel

Program 2.7 determines the equivalent resistance of three resistors connected in
parallel. Figure 2.6 gives a schematic diagram of this set-up. The resistors
connected are R1, R2 and R3 and the equivalent input resistance is Requ. Test run
2.6 shows a run with values of 250, 500 and 1000 Ω.
FIGURE 2.6  Three resistors connected in parallel

2.4.7 Bit Operations
Program 2.8 relates to digital electronics and illustrates the power of C and
Pascal when dealing with low-level bit operators. The C program uses &, |, ⁁and ~
bitwise operators to create AND, OR, EX-OR, NAND and NOR Boolean
functions. Pascal uses the operators: and, or, xor and not. The NAND and NOR
functions are generated by inverting the AND and OR operations.
The C program allows the entry of hexadecimal values using the % x format
descriptor in scanf() statement. Test run 2.7 shows a run with test values.

The bit patterns used in the test run are 1110 0010 0001 0101 (E215h) and
1100 0100 0011 0001 (C431h). To verify the program the hexadecimal
equivalents of these values are operated on by the Boolean operators and the
results checked against the test run results.
The AND operation gives the following:
The OR operation gives the following:

The EX-OR function gives the following:
The inverse of AND (NAND) will be 0011 1111 1110 1110(3FEEh); the
inverse of the OR (NOR) is 0001 1001 1100 1010 (19CAh). These results are
identical to these in test run 2.16. Thus the test has been successful.
The Pascal Program 2.8 allows the input of the values as an integer. Test run
2.8 shows a sample test run.
Worksheet 2
W2.1. Enter two programs from the chapter and verify that their output conforms
with the sample test runs.

W2.2. Modify program 2.3 so that it also calculates the value of c. Use this
program to complete Table W2.1.
Table W2.1
Straight lines calculations
W2.3. Write a program which calculates the magnitude of a complex number of
x+jy (or in another form x+iy) and complete Table W2.2 (note that the
first row has been completed). The magnitude is given by:
Table W2.2
Magnitude
W2.4. Write a program which calculates the angle of a complex number of x+jy
(or in another form x+iy) and complete Table W2.3. The angle is given
by:
Table W2.3
Angle

   
Worksheet 3
W3.1. Modify the program written in W2.4 so that it converts the angle to
degree and complete Table W3.1. An angle converted from radians to
degree using:
Table W3.1
Angle
W3.2. Write a program which determines the equivalent resistance of three
parallel resistors. Use this program to complete Table W3.2.
Table W3.2
Equivalent parallel resistance

W3.3. Modify the program in Question W3.2 so that the user enters the applied
voltage to the parallel resistors and the program determines the current in
each of the resistor and the input current. Use this program to complete
Table W3.3. Note that the current in each of the resistors is simply the
applied voltage divided by each of the resistors. A sample test is given in
Test run 2.9.
Table W3.3
Current flow
W3.4. Modify the program in Question W3.3 so that is displays the current in
milliAmps (mA). Note to convert to mA then multiply the value by 1000.
A sample test is given in Test run 2.10.

3
Selection Statements
3.1 if … else statements
A decision is made with the i f statement. It logically determines whether a
conditional expression is TRUE or FALSE. For a TRUE, the program executes
one block of code; a FALSE causes the execution of another (if any). The
keyword else identifies the FALSE block. In C, braces ({}) are used to define
the start and end of the block. In Pascal, the begin and end keywords are used.
Relationship operators, include:
• Greater than (>).
• Less than (<).
• Greater than or equal to (>=).
• Less than or equal to (<=).
• Equal to (in C, it is == and, in Pascal, it is =).
• Not equal to (in C, it is ! = and, in Pascal it is <>).
These operations yield a TRUE or FALSE from their operation. Logical
statements (&&, | |, !) can then group these together to give the required
functionality. These are:
• AND (in C, it is & &, and, in Pascal it is and); • OR (in C, it is | |, and, in
Pascal it is or); • NOT (in C, it is !, and, in Pascal it is not).
If the operation is not a relationship, such as bitwise or an arithmetic
operation, then any non-zero value is TRUE and a zero is FALSE. The following
is an example syntax of the if statement. If the statement block has only one
statement then, in C, the braces ({}) can be excluded (in Pascal the begin and
end can be excluded).

The following is an example format with an else extension.
It is possible to nest if..else statements to give a required functionality. In
the next example, statement block1 is executed if expression1 is TRUE. If it is
FALSE then the program checks the next expression. If this is TRUE the
program executes statement block2, else it checks the next expression, and so on.
If all expressions are FALSE then the program executes the final else statement
block, in this case, statement block 4:
Figure 3.1 shows a diagrammatic represention of this example statement.

FIGURE 3.1  Structure of the compound if statement
3.1.1 Examples
This section contains some C and Pascal example programs.
Quadratic equations
Some electrical examples require the solution of a quadratic equation. The
standard form is:
The solution of x in this equation is given by:

This can yield three possible types of results:
1. if b2=4ac, there will be a single real root (x=–b/2a) 2. else, if b2>4ac,
there will be two real roots: 
3. else, the roots will be complex:
Program 3.1 determines the roots of a quadratic equation. In this program the
if..else statement is used to determine if the roots are real, complex or
singular. The value passed to the square-root function (sqrt()) should be tested
to determine if it is negative. If it is, it may cause the program to terminate as the
square root of a negative number cannot be calculated (it is numerically invalid).
The program may also terminate if a is zero as this causes a divide by zero error
(the trap for this error is left as a tutorial question). Note that, in C, the sqrt()
function is prototyped in the math.h, thus the math.h header is included in the
program.


Three test runs 3.1, 3.2 and 3.3 test each of the three types of roots that occur.
In Test run 3.1 the roots of the equation are real. In Test run 3.2 the roots are
complex, i.e. in the form x+jy. In Test run 3.3 the result is a singular root.
Electromagnetic (EM) waves
Program 3.2 uses the if statement to determine the classification of an EM wave
given its wavelength. Figure 3.2 illustrates the EM spectrum spanning different
wavelengths. The classification of the wave is determined either by the
frequency or the wavelength (normally radio and microwaves are defined by
their frequency, whereas other types by their wavelength). For example, an EM
wave with a wavelength of 10 m is classified as a radio wave, a wavelength of

500 nm as visible light and a wavelength of 50 cm is in the microwave region.
Test run 3.4 shows a sample run.
FIGURE 3.2  EM spectrum

EM waves can also be specified by their frequency. Program 3.3 allows the
user to enter the frequency of the wave, and the program then determines the
wavelength using the formula: 
where c is the speed of light and f the frequency of the wave.

Test run 3.5 shows a sample run.

Series/ parallel resistances
Program 3.4 determines the equivalent resistance of two resistors connected
either in series or parallel. The C program uses scanf() to get the two resistance
values and getchar() to select the circuit configuration. Problems can occur
when using getchar() after scanf() due to new-line characters being stored in
the keyboard buffer. The statement fflush(stdin) has been inserted into the
program in order to clear the buffer before getchar() is called (stdin represents
the standard input device, that is, the keyboard). The C program also uses to
lower() to convert the entered circuit selection character to lowercase (this is
protoyped in the ctype.h). In Turbo Pascal there is no lowercase conversion so
the uppercase equivalent is used (upcase).

3.2 switch statement
The case statement (and switch in C) is used when there are multiple decision
to be made. It is normally used to replace the if statement when there are many
routes of execution the program execution can take. The syntax of case/switch
is as follows.

In Pascal, the case statement simply selects which one of the constants
(const1, const2, and so on) matches the constant value. In C, the switch
statement checks the expression against each of the constants in sequence (the
constant must be an integer or character data type). When a match is found the
statement(s) associated with the constant is(are) executed. The execution carries
on to all other statements until a break is encountered or to the end of switch,
whichever is sooner. If the break is omitted, the execution continues until the
end of switch.
If none of the constants matches the switch expression a set of statements
associated with the default condition (default:) is executed.
3.2.1 Examples
Resistor colour code
Resistors are normally identified by means of a colour code system, as outlined
in Table 3.1. Program 3.5 uses a case/switch statement to determine the colour
of a resistor band for an entered value.
Table 3.1
Resistor colour coding system


Test run 3.6 shows a sample run.
Program 3.6 uses #define directives to define each of the resistor colour
bands. There may be a clash with these defines if other header files contain these
definitions. If this occurs change the defines to RES_BLACK, RES_BROWN, etc.
A default: has been added to catch any invalid input (such as less than 0 or
greater than 9).


Resistance of a conductor
The resistance of a cylindrical conductor is a function of its resistivity, cross-
sectional area and length. These parameters are illustrated in Figure 3.3. The
resistance is given by:

FIGURE 3.3  Cylindrical conductor
where
ρ = resistivity of the conductor (Ω.m); l = length of the conductor (m);
A = cross-sectional area of the conductor (m2).
Program 3.7 determines the resistance of a cylindrical conductor made from
either silver, manganese, aluminium or copper. The resistivities of these
materials have been defined using #define macros (in C) or const (in Pascal).
The user enters the conductor type as a character (‘c’, ‘a’, ‘s’ or ‘m’)
which can either be in upper or lowercase format as the tolower() function
converts the entered character to lowercase (this is protyped in ctype.h). When
an invalid character is entered the default condition of the case statement is
executed, and the text Invalid option is displayed. The program then calls the
exit() function; the argument passed to this function is the termination status. A
value of 0 describes a normal termination; any other value signals an abnormal
program termination.
In C, the printf() statement displays the resistance in scientific format (%e)
as values are typically much less than 1 Ω (such as mΩ or μΩ).


Test run 3.7 uses an aluminium conductor with a radius of 1 mm and length
1000 m. The resistance is found to be 8.08 Ω.
The Pascal Program 3.7 shows that several constants for a single case option
can be used (for example, ‘a’, ‘A’). In C, it is possible to have several case

options in the switch statement. For example, if the to lower() function is not
used in program 3.7 then the case option can be modified so that it includes the
upper and lowercase options, as shown in the following code:
3.3 Exercises
3.3.1. Modify Program 3.1 so that it cannot generate a divide by zero error, that
is, when a is 0 (zero). Note that if a is 0 then the root will be –c/b.
3.3.2. Modify Program 3.2 so that the user can enter the EM wave as a frequency
or a wavelength. A sample run is shown in test run 3.8.
3.3.3. Modify Program 3.2 so it uses the # define statement to define limits for
the wavelength, for example:
3.3.4. Capacitance is normally defined as a value and a specified unit, such as
pF, nF, μF, mF or F. Write a program in which a capacitance value and
the unit are entered and the program displays the actual numerical value
in Farads. The capacitance unit should be entered as a character. A
sample test run is given in Test run 3.9. Note that pF is 10−12 F, pF is 10−9
F, μF is 10−6 F and mF is 10−6 F.

3.3.5. Repeat Q3.10 for the value of the resistance. The units entered are either
mΩ (‘m’), Ω (‘1’), kΩ (‘k’) or MΩ (‘M’). Test run 3.11 shows a sample
run. Note that mΩ is 10−3 Ω, kΩ is 103 Ω and ?Ω is 106 Ω.
Worksheet 4:
W4.1. Enter Program 3.1 and use it to complete Table W4.1
Table W4.1
Roots of a quadratic equation
Equation
Root(s)
x2 +21x–72 = 0
 
5×2 +2x + 1= 0
 
25×2 – 30x + 9 = 0
 
6×2 + 9x–20 = 0
 
W4.2. Modify Program 3.1 so that it cannot generate a divide by zero error, that
is, when a is 0 (zero). Note that if a is 0 then the root will be -c/b.
Table W4.2
Root of a quadratic equation
Equation
Root
0×2 + 4x–2 = 0
 
0×2 + 6x + 6 = 0
 
W4.3. Write a program in which the user enters a value of resistance and the
program displays the resistance value in the best possible units. A

possible implementation could be: If the resistance is less than 1 000 Ω
(1e3) then it is printed as the value in ohms; else, if it is between 1 000
(le3) and 1 000000 Ω (1e6) then the value is printed as kΩ; else, if it is
greater than 1 000000 (1e6) then it is printed in MΩ.
   Test run W4.1 shows some sample runs.
Worksheet 5:
W5.1. OPTIONAL. Enter Program 3.5 and test the results.
W5.2. Write a program using the case (or switch) statement that allows the user
to select from a menu of options. These options allow the user to select
either the calculation of the equivalent resistance of two series or two
parallel resistors. The user should enter a 1 if the series equivalent is
required or a 2 if parallel required. Sample run W5.1 shows a sample test
run.
W5.3. The textbackground function allows the colour of the background to be
changed to BLACK, BROWN, RED, … and clrscr clears the screen.
Sample program 3.8 shows an example program of their use. Write a
program which allows the user to enter a colour and the then program
changes the background colour. Table W5.1 shows the colour definitions.
Table W5.1

   
OPTIONAL EXERCISE:
W5.4. Modify the program written in W5.2 so that the user enters an ‘s’ for
series resistance and a ‘p’ for parallel. Sample run W5.2 shows a sample

test run. Note that the program should accept the input characters in
uppercase or lowercase.

4
Repetitive Statements
4.1 Introduction
Iterative, or repetition, allows the looping of a set of statements. There are three
forms of iteration:
4.2 for
Many tasks within a program are repetitive, such as prompting for data, counting
values, and so on. The for loop allows the execution of a block of code for a
given control function or a given number of times. In Pascal the format is:

In this case, value starts at startval and ends at endval. Each time round the
loop, value will be incremented by 1. If there is only one statement in the block
then the begin and end reserved words can be omitted. In C the format is:
where:
4.3 Examples
4.3.1 ASCII Characters Program 4.1 Displays
ASCII Characters For Entered Start And End
Decimal Values. Test Run 4.1 Displays The
ASCII Characters From Decimal 40 (‘ (‘) To 50
(‘2’).


4.3.2 Transient Response Of An RC Circuit
Figure 4.1 illustrates an RC circuit with a voltage step applied at t=0. When a
voltage step, amplitude E volts, is applied to this circuit it produces an
exponential current.
FIGURE 4.1  RC circuit with step input applied at t = 0
The following defines the transient current in the circuit.
and the voltage across the resistor will be:
Program 4.3 determines the voltage across the resistor at given time intervals.
The user enters the end time and the number of time steps required; the program
determines the voltage at each of the time steps.


Test run 4.2 shows that the voltage across the resistor starts at a maximum at
t=0. This is because the voltage across the capacitor is initially zero. As the
capacitor charges, the voltage across it will increase until it almost equals the
applied voltage. The current in the circuit will also be at a maximum when the
step is applied. It will then decay to almost zero at a rate determined by the time
constant (which is a product of R and C).

4.3.3 Boolean Logic
Program 4.3 is an example of how a Boolean logic function can be analyzed and
a truth table generated. The for loop generates all the required binary
permutations for a truth table. The Boolean function used is: 
A schematic of this equation is given in Figure 4.2. Test run 4.3 shows a
sample run.
FIGURE 4.2  Digital circuit


4.4 Exercises
4.4.1. Write a program which prints all the characters from ‘0’ (zero) to ‘z’ in
sequence using a for loop.
4.4.2. Write a program which displays the squares, cubes and fourth powers of
the first 15 integers. A sample output is given next.
4.4.3. Write a program which displays the y values in the formulas given below
and with the given x steps.
   A sample run of the first equation is given next.
4.4.4. Write a program which displays the sine of a number from 0° degrees to
90° in steps of 10°.
4.4.5. Modify Program 4.3 so that it determines the truth table for the following
Boolean equation: 
Table 4.1

Truth table
4.4.6. Write a program which will determine the impedance of an RL series
circuit. The program must calculate the magnitude of the impedance.
Worksheet 6:
W6.1. Enter Program 4.1 and use it to complete Table W6.1.
Table W6.1
ASCII characters
Value
Character
34
 
35
 
36
 
37
 
38
 
64
 
65
 
66
 
67
 
68
 
69
 
70
 
W6.2. Write a program which lists the square of the values from 1 to 10. A
sample run in shown in Test run W6.1.

W6.3. Complete either Exercise 4.4.3(i), Exercise 4.4.4 or Exercise 4.4.5.
4.5 while()
The while statement allows a block of code to be executed while a specified
condition is TRUE. It checks the condition at the start of the block; if this is
TRUE the block is executed, else it will exit the loop. The syntax is
If the statement block contains a single statement then the braces may be
omitted (although it does no harm to keep them). A few examples are:

4.6 repeat..until() and do..while()
In C the do..while() statement is similar in its operation to while() except that
it tests the condition at the bottom of the loop. The repeat..until() in Pascal is
also similar to the while() statement but unlike while() the loop quits when the
associated condition is true. These loops thus allow statement block to be
executed at least once. The syntax is:
As with for and while loops the braces are optional. The do..while() and
repeat..until() loops require a semicolon at the end of the loop, whereas the
while() does not.
4.7 Examples
4.7.1 Repeating Program Often A User Is
Asked To Repeat The Program Once It Has
Finished Calculating Values. This Is
Sometimes Done By Asking The User If They
Want To Repeat (Or Continue) The Program.
If The User Enters A ‘Y’ Character Then The
Program Is Repeated, Else A ‘N’ Character
Will Exit The Program. Program 4.4
Implements This With A Repeat..Until()
/Do..While() Loop.

4.7.2 Limiting Ranges Of Inputs
Most of the values that are entered into a program have a certain range. For
example if a user is asked enter their age then the value will always be:
• An integer.
• A positive value.
• Less than 130.
If a user enters an invalid value then the program could either:
• Crash, which typically happens when a program tries to divide by zero or

determines the square root of a negative number.
• Gives invalid results.
Thus it is important that the user is stopped from entering values which are
invalid. Program 4.5 allows the user to determine the equivalent parallel
resistance for two resistors in parallel. The range of value values of entered
resistance is between 0Ω and 1MΩ. The repeat..until() /do while() loop is
placed around the user entry of each of the values. These loops continue until a
user enters a valid value. Test run 4.4 shows a sample run.

Program 4.6 gives an example of the determination of acceleration giving the
initial and end velocity, and the time difference. The range of velocity values is
between 0 and 1000 m/s, and the range of time difference values is between 0
and 60 s. Test run 4.5 shows a sample run.


4.8 Exercises
4.8.1. Correct the errors in the following programs:
(a) 

(b) 

4.8.2. What will the following sections of code output to the screen.
(i) 
(ii) 
(iii) 

(iv) 
(v) 
(vi) 
(vii) 
4.8.3. Determine the errors in the following programs
(i) 

(ii) 
(iii) 
(iv) 

(v) 
4.8.4. Determine the output from the following sections of code (beware of
infinite loops).
(i) 

(ii) 
(iii) 
(iv) 
(v) 
(vi) 
(vii) 

(viii) 
(ix) 
4.8.5. Write a Program to convert a decimal number to octal (base 8). A sample
run is given in Test run 4.6.
4.8.6. Replace the following for loop with a repeat..until and with a
while..do in the examples below.
(i) 
(ii) 

(iii) 
4.8.7. Write a program to convert hexadecimal to decimal. A sample run is
shown in Test run 4.7.
4.8.8. The drain current, in milliamps, of a sample depletion-type FET is given
by: 
   Write a program which determines the drain current (in mA) for gate-source
voltages (VGS) from –5 to 5 V in steps of 0.5 V. A sample run is given in
Test run 4.8.

Worksheet 7:
W7.1. Modify a program from a previous worksheet so that it prompts the user
to if they want to repeat the program.
W7.2. Write a program which will calculate the equivalent resistance of three
resistors in parallel. If the user enters an invalid value (such as a negative
value) the program will prompt the user to enter a valid input. A sample
run is shown in Test run W7.1.
W7.3. Write a program which will convert decimal value to hexadecimal (base
16). A sample run is shown in Test run W7.2.

W7.4. Write a Program in which you enter the number of bits in a binary
number, enter these bits and then calculate the decimal equivalent. A
sample run is given in test run W7.3. Note that the valid input for the bits
should be only a 0 or a 1.

5
Functions
5.1 Introduction
Functions are identifiable pieces of code with a defined interface. They are
called from any part of a program and allow large programs to be split into more
manageable tasks, each of which can be independently tested. Functions are also
useful in building libraries of routines that other programs use. Several standard
libraries exist, such as a maths and input/output libraries.
A function can be thought of as a ‘black box’ with a set of inputs and outputs.
It processes the inputs in a way dictated by its function and provides some
output. In most cases the actual operation of the ‘black box’ is invisible to the
rest of the program. A modular program consists of a number of ‘black box’
working independently of all others, of which each uses variables declared
within it (local variables) and any parameters sent to it. Figure 5.1 illustrates a
function represented by an ideal ‘black-box’ with inputs and outputs, and Figure
5.2 shows a main function calling several sub-functions (or modules).

FIGURE 5.1  An ideal ‘black-box’ representation of a function

FIGURE 5.2  Hierarchical decomposition of a program
5.2 Arguments and parameters
The data types and names of parameters passed into a function are declared in
the function header (its interface) and the actual values sent are referred to as
arguments. They can be passed either as values (known as ‘passing by value’) or
as pointers (known as ‘passing by reference’). Passing by value involves sending
a copy of it into the function. It is not possible to change the value of a variable
using this method. Variables can only be modified if they are passed by
reference (this will be covered in the next chapter). This chapter looks at how
parameters pass into a function and how a single value is returned.
An argument and a parameter are defined as follows:
An ‘argument’ is the actual value passed to a function.
A ‘parameter’ is the variable defined in the function header.

5.3 C functions
Figure 5.3 shows a program with two functions, main() and functionl().
Function main() calls functionl() and passes three parameters to it; these are
passed as values. A copy of the contents of d goes into g, e into h and f into i.
FIGURE 5.3  Local and global variables
Variables declared within a function are described as local variables. Figure
5.3 shows that d, e and f are local variables within main (); g, h, i, j and k are
local within function1(). These will have no links to variables of the same
name declared in other functions. Local variables only exist within a function in
which they are declared and do not exist once the program leaves the function.
Variables declared at the top of the source file (and not within a function) are
defined as global variables. These allow functions, within the source file, to
access them. Care must be taken when using global variables for many reasons,
one of which is that they tend to lead to programs that are unstructured and

difficult to maintain.
In Figure 5.3 the function function1() makes use of the variable a as this is
declared as a global variable. This function cannot be modelled as a ‘black box’
as it can modify a variable which is not passed to it. In a relatively small
program this may not create a problem but as the size of the program increases
the control of variables can become difficult.
Figure 5.4 shows an example of how things can go wrong with global
variables. In this example, a global variable i is used by two functions. Initially,
the value of i within the loop in main() will be 0. The function1() function is
called within this loop, which uses the variable i within another loop. Each time
it is incremented the global variable takes on the incremented value. When the
program leaves this function the value of i will have changed (that is, it will be
10). This causes the for() loop in main() to end. If the variable i had been
declared locally within both main() and function1() this problem would not
have occurred. As a rule, called modules should be self-contained and use only
the parameters sent to them.

FIGURE 5.4  An example of the use of global variables
Program 5.1 contains a function named print_values(). This is called from
main() and variables a and b are passed into the parameters c and d,
respectively; c and d are local parameters and only exist within print_values().
The values of c and d can be changed with no effect on the values of a and b.
5.3.1 Return Value
The return statement returns a single value from a function to the calling
routine. Programs in previous chapters have used functions that return values. If
there are no return statements in a function the execution returns automatically to
the calling routine upon execution of the closing brace (i.e. after the final
statement within the function). Program 5.2 contains functions which will add
and multiply two numbers. The function addition() uses return to send back
the addition of the two values to the main ().

Figure 5.5 shows a simple structure chart of this program. The function
addition() is called first; the variables sent are a and b and the return value is
put into the variable summation. Next, the multiply() is called; the variables
sent are also a and b and the value returned goes into multi. Finally, the function
print_values() is called; the values sent are a, b, multi and summation.

FIGURE 5.5  Basic structure chart for program 5.2
A function can have several return points, although it is normally better to
have only one return point. This is normally achieved by restructuring the code.
An example of a function with two returns is shown next. In this example a
decision is made as to whether the value passed into the function is positive or
negative. If it is greater than or equal to zero it returns the same value, else it
returns a negative value (return (-value)).
5.3.2 Function Type
Program 5.2 contains functions that return integer data types. It is possible to
return any other of C’s data types, including float, double and char, by
inserting the data type before the function name. If no data type is given then the
default return type is int. The following gives the general syntax of a function.

C is a flexible language in its structure. It allows the arrangement of functions
in any order and even within different files. If the compiler finds a function that
has not been defined (or prototyped) then it assumes the return type will be int.
It also assumes that at the linking stage the linker will be able to find the
required function either in the current compiled program, the libraries or other
object codes. It is thus important that the function return data type is defined
when the compiler is compiling the function; otherwise it will assume that the
return type is int.
Function declarations (or prototypes) are normally inserted either at the top of
each file, locally within a function, or in a header file (the .h files). These
declarations allow the compiler to determine the return type and the data types of
all parameters passed to the function. It thus allows the compiler to test for
illegal data types passed to a function in error. For example the following are
invalid uses of the function printf (), sqrt() and scanf(). The printf() has an
incorrect syntax as the first argument should be a format statement (i.e. a string),
the sqrt() function should be passed a floating point value and the scanf()
function requires a format string as the first argument.
If the stdio.h header is not included the compiler does not generate any errors
for the incorrect usage of printf() and scanf(). The same applies to the math.h
header file and the function sqrt().
When a function prototype is inserted at the top of the file it is a global
declaration of that function within the source code file. Otherwise, the
declaration can be inserted into the variable declaration lists within a function;
this will make the definition local only to the function in which it is defined.
If a function does not return a value then the data type definition for the return
value should be void. Also, if no parameters are sent to the function then the
argument list contains a void. The compiler would thus flag an error or warning

if any parameters are passed to a function with a void argument list or if a
returned value is used from a void return data type.
Figure 5.6 shows the operation of a function prototype. At the top of the file
the prototype declares the parameter types of the arguments passed (in this case,
two floats) and the return data type (in this case float). The compiler checks all
arguments sent to this function to see if they match up with these types. A
warning or error is generated if there is a mismatch. The return type is also
checked.
FIGURE 5.6  Checking conducted by the compiler on function prototypes
Program 5.3 contains a function power() which is prototyped at the top of the
program. The return value is double; the first argument is double and the second
is int. This function uses logarithms to determine the value of x raised to the
power of n. The formula used is derived next; the log () function is the natural

logarithm and the exp() the exponential function. Both of these require the
parameter sent as double and the return type is also double.
Some compilers give a warning if the return value data type is different from
the data type of the variable to which it is assigned. For example, if the data type
of the variable x in Program 5.3 is changed to a float then it is good practice to
recast the return value to a float, as shown next.

5.4 Pascal functions
In Pascal a function returns a single value. It is identified by the function header,
which is in the form:
where the parameters are passed through the formal_parameter_list and the
result type is defined by result_type.
Program 5.1 contains two functions named addition and multiply. In calling
the addition function and variables a and b are passed into the parameters c and
d, respectively; c and d are local parameters and only exist within addition(). The
values of c and d can be changed with no effect on the values of a and b. This
function returns a value back to the main program by setting a value which is the
same name as the function.
Program 5.1 also uses a procedure which, in this case, is similar to a function
but does not return any values back to the calling program.

Figure 5.5 shows a simple structure chart of this program, The function
addition() is called first; the variables sent are a and b and the return value is
put into the variable summation. Next, the multiply() is called; the variables
sent are also a and b and the value returned goes into multi. Finally, the function
print_values() is called; the values sent are a, b, multi and summation.
Program 5.2 contains functions that return integer data types. It is possible to
return any other of C’s data types, including real, double and character, by
inserting the data type after the function name.
A function can have several return points, although it is normally better to
have only one return point. This is normally achieved by restructuring the code.
An example of a function with two returns is shown next. In this example a
decision is made as to whether the value passed into the function is positive or
negative. If it is greater than or equal to zero it returns the same value, else it
returns a negative value (mag=-val).
Program 5.2 contains a function power() which has a return data type of
double; the first argument is double and the second is integer. This function
uses logarithms to determine the value of x raised to the power of n. The formula
used is derived next; the In() function is the natural logarithm and the exp() the
exponential function.

5.5 Examples
This section contains a few sample C and Pascal programs which use functions.
5.5.1 Tan Function
There is no tan function in Pascal; thus to overcome this Pascal Program 5.3
contains a tan function and Test run 5.1 shows a sample run.

C, unlike Pascal, has a tan function, thus to avoid redeclaring it C Program 5.4
has a function called tangent(). To improve accuracy the program uses double
data types. For this reason the scanf() and printf() functions use the data type
%If conversion characters.
5.5.2 Centigrade To Fahrenheit Conversion
Pascal Program 5.4 uses two functions to convert from Fahrenheit to centigrade,
and vice versa. Test run 5.2 shows a sample test run.


Pascal Program 5.5 and C Program 5.6 uses the two function developed in the
previous programs to display a table of values from 0°C to 100°C in steps of
10°C. Test run 5.3 shows a sample run.


5.5.3 Combinational Logic
In this example, the following Boolean equation is processed to determine its
truth table.
Figure 5.7 gives a schematic representation of this Boolean function.

FIGURE 5.7  Schematic representation of the function 
The four nodes numbered on this schematic are:
1. 
2. A.C
3. 
4. 
Table 5.1 gives a truth table showing the logical level at each point in the
schematic. This table is necessary to check the program results against expected
results. Table 5.2 gives the resulting truth table.
Table 5.1
Truth table

Table 5.2
Truth table
The permutations of the truth table input variables (i.e. 000, 001, 010, 011,
…, 111) are generated using 3 nested for loops. The inner loop toggles C from a
0 to a 1, the next loop toggles B and the outer loop toggles A. The Boolean
functions use the logical operators & & and | |. Recall that these operators treat a
value of 0 (zero) as FALSE and any other value as TRUE.

Test run 5.4 shows a sample run of the program. Notice that the results are
identical to the truth table generated by analyzing the schematic.

Pascal Program 5.6 shows the equivalent Pascal program. As Pascal has
reserved keywords for AND, OR and NOT the function names have been
changed to reflect the number of inputs they have, such as OR3 for a 3-input OR
gate and AND2 for a 2-input AND gate.

5.5.4 Impedance Of A Series RL Circuit
The magnitude of the impedance of an RL circuit is given by the equation:
and the phase angle of this impedance is given by:
Figure 5.8 gives a schematic of an RL series circuit.
FIGURE 5.8  RL series circuit
Figure 5.9 gives a structure chart which outlines a basic design for this
problem. Inputs are resistance (R), inductance (L) and frequency (f). The
program determines the magnitude and phase angle of the impedance. In order to
determine these values the reactance of the inductor must be determined using
XL = 2πfL.

FIGURE 5.9  Structure chart for a series RL circuit program


Test run 5.5 gives a sample run of this program. The input parameters used are
resistance 1 kΩ, inductance 1 mH and applied frequency 1 MHz.
Pascal Program 5.7 gives the equivalent Pascal program.


5.6 Exercises
5.6.1. Write a program which determines the magnitude of an entered value. The
program should use a function to determine this.
5.6.2. Write a program which determines the magnitude and angle of a complex
number (in the form x+iy, or x+jy). The program should use functions to
determine each of the values. Complete Table 5.3 using the program (the
first row has already been completed).
Table 5.3
Complex number calculation
5.6.3. Write a mathematical function for a factorial calcuation, where: 
5.6.4. Write mathematical functions for the following
   The sine and cosine functions should calculated from first principles with: 
   The error in the functions should be less than 1×10−6.
5.6.5. Using the functions developed in Exercise 5.6.2 and the standard sine and
cosine library functions, write a program which determines the error
between the standard library functions and the developed functions. From

this, complete Table 5.3.
Table 5.3
Sine and cosine results
5.6.6. Write a mathematical function which determines the exponential of a
value using the first principles formula: 
   Compare the result with the standard exp() library function.
5.6.7. Write Boolean logic functions for the following four digital gates:
Worksheet 8:
W8.1. Write a program with separate functions which determine the gradient of
a straight line (m) and the point at which a straight line cut the y-axis (c).
The entered parameters are two points on the line, that is, (x1, y1) and (x2,
y2). From this program complete Table W8.1 (the first row has already
been completed).
Table W8.1
Straight line calculations
W8.2. Write a program which has a function which will only return a real value

when the entered value is within a specified range. Examples of calls to
this function (which, in this case, is named get_real) are given next.
   which will only return a value from the function when the entered value is
between 0 and 100. A sample run is given next.
W8.3. Modify the program developed and use it to prompt the use to enter a
value of current (between 0A and 10A) and voltage (between 0V and
100V). The program will then determine the resistance by dividing the
entered voltage by the entered current. The program should contain two
functions: get_real() and cale_current().

6
Parameter Passing
6.1 Introduction
Parameter passing involves passing input parameters into a module (a function
in C and a function and procedure in Pascal) and receiving output parameters
back from the module. For example a quadratic equation module requires three
parameters to be passed to it, these would be a, b and c. These are defined as the
input parameters. The output parameters would be the two roots of the equation,
such as root1 and root2. Another parameter could also be passed back to
indicate the type of root (such as singular, real or complex). This indication is
normally known as a flag. Figure 6.1 illustrates the passing of parameters into
and out of a module.
FIGURE 6.1  Parameter passing
In Pascal the module would be defined as:
In C a flag is typically passed back through the function header, thus:

6.2 Pascal parameter passing
Procedures are used in Pascal when parameters need to be passed back to the
calling routine. Functions are normally used when there is only one value passed
back, whereas a procedure can return any number (or even none). The first part
of defining a procedure is to define the input parameters and the output
parameters. The input parameters are declared in the parameter list and output
parameters are defined with a preceding var keyword. For example, if the input
parameters are x and y, and the output parameters are w and z then the following
procedure would be defined:
In this case only values will be passed into the variables x and y, whereas the
values of w and z will be passed back to the calling module. If a procedure
requires local variables then these are declared after the procedure header. For
example, if the procedure in the last example has two local variables named
temp1 and temp2 then it will have the form:
Local variables only exist within the procedure and their contents are lost
when the procedure quits.
Program 6.1 shows an example program with a procedure which swaps the
values of two variables. In this case a temporary local value (temp) holds one of
the values (temp:=x) so that the contents of the other value can be placed in it
(x:=y). The temporary value is then put into the other variable (y:=temp). This
operation performs a swap.

Program 6.2 calculates the gradient of a straight line given two coordinates
(x1,y1) and (x2,y2).
6.3 C parameter passing

One of the most confusion areas of C programming is the usage of pointers.
They basically refer to addresses in memory but to the novice they are one of the
least liked elements of C programming. In many cases they are extremely useful
and allow the programmer to directly access areas of memory.
6.3.1 Introduction
If a company were to send a form to a person and they neglected to inform the
person of the correct return address then it would not be possible for the
recipient to send back the modified form (unless the person already knows the
address). Variables sent to functions operate in a similar manner. If the function
does not know where a variable lives (its address in memory) then the function
cannot change its contents.
A program uses data which is stored by variables. These are assigned to a
unique space in memory, the number of bytes they use depends on their data
type. For example, a char uses 1 byte, an int will typically take 2 or 4 bytes,
and a float, typically, 4 or 8 bytes. Each memory location contains one byte and
has a unique address associated with it (that is, its binary address). This address
is normally specified as a hexadecimal value as this can be easily converted to
the actual binary address. The memory map in Figure 6.2 shows how three
variables valuel, value2 and ch could be allocated in memory. This diagram
assumes that a float uses 4 bytes, and an int 2 bytes. The compiler, in this case,
has allocated valuel from addresses 100h to 103h, value2 at 104h and 105h, and
ch is allocated to 106h. The start of the variable’s address in memory can be
described as a memory pointer to the variable. A pointer variable is used to store
a memory address.

FIGURE 6.2  Example memory map
Variables sent to a function can have their contents changed by passing a
pointer in the argument list. This method involves sending a memory address
rather than a copy of the variable’s value. A preceding ampersand (&) specifies a
pointer. This can be thought of as representing the address of:
A pointer to a variable will store the address to the first byte of the area
allocated to the variable. An asterisk (*) preceding a pointer is used to access the
contents of the location pointed to. The number of bytes accessed will depend on
the data type of the pointer. The * operator can be thought of representing at
address:
Figure 6.3 shows an example memory map. A variable resistance_1 has the
value of 310.0 and is stored at a memory location starting at 107h. If the data
type is a short integer then it will take up 2 bytes in memory (i.e. 107h and
108h), if it is a float it may take up 4 bytes in memory (i.e. 107h to 110h). The
memory map also shows that a pointer ptr points to memory location 102h. The

value stored at this location is 15; *ptr accesses its contents. The declaration of
the pointer defines the data type of the pointer and thus the number of bytes used
to store the value at the address pointed to by the pointer.
FIGURE 6.3  Example memory map
6.3.2 Pointers With Functions
In the previous chapter it was shown that a single value is passed out of a
function through the function header. In order to pass values out through the
argument list the address of the variable is passed; that is referred to as ‘call by
reference’. To declare a pointer the data type is specified and the pointer name is
preceded by an asterisk. The following is the general format:
In this case ptr_name is the name of the pointer. The contents of the variable
at this address can be accessed using *ptr_name. When a function is to modify a
variable then a pointer to its address is sent. For example, if the variable to be
modified is value then the argument passed is & value.
Program 6.1 shows an example of a function that swaps the contents of two
variables (a and b). Figure 6.4 shows how the compiler checks the parameters
passed to the function and the return type. The function prototype, in this case,
specifies that the parameters sent are pointers to integer values and the return

type is void. The compiler checks that the parameters sent to the function are
integer pointers and that nothing is assigned to the return value from the
function.
FIGURE 6.4  Compiler checking for Program 6.1

Program 6.2 calculates the gradient of a straight line given two coordinates
(x1,y1) and (x2,y2). Within the get_coord() function the scanf() do not require
a preceding ampersand; the variable arguments are already pointers.

An example of a standard C function that uses call by reference is scanf()
where a pointer is passed for each variable. This allows the function to change
its contents.
6.4 Examples
6.4.1 Quadratic Equations
C Program 6.2 determines the roots of a quadratic equation. The function
get_values() gets variables a, b and c; these variables are passed as pointers.
The function to determine the root(s) of a quadratic equation is
quadratic_equ(). This returns the root type (such as, singular, real or complex)
through the function header and passes the equation root(s) through the
argument list using pointers. The root type returned can be referred to as a return
flag; this flag is set up using an enum declaration. There are three possible states
for this: SINGULAR (a value of 0), REAL_ROOTS (a value of 1) and COMPLEX_ROOTS
(a value of 2). The program then uses the flag to determine how the root(s) are to
be displayed. If the root is singular then print_results() prints a single value
of root1; else, if the roots are real, then two values root1 and root2 are printed;
and if the roots are complex the function will print the roots in the form root1

+/-j root2.
Figure 6.5 gives a basic structure chart of this program. The return flag from
the quadratic_equ() function is represented by an arrow with a circle on the
end.
FIGURE 6.5  Structure chart for Program 6.3


Pascal Program 6.3 is similar to the C Program 6.3 for the following:
• The flag for the quadratic equation is passed as one of the variables in the
parameter of quadratic_equ (rtype).
• The quadratic equation root types are defined as constants using const.

Test run 6.1 shows tests for each of the root types.

6.4.2 Equivalent Parallel Resistance
C Program 6.3 uses pointers to determine the equivalent parallel resistance of
two resistors. A basic structure chart, given in Figure 6.6, shows that
get_values() returns the variables R1 and R2; in order to change their values
they are sent as pointers. It also shows that the variables sent to
calc_parallel_res() are R1, R2 and R_equ is returned. Variables R1, R2 and
R_equ are then passed into print_results().
FIGURE 6.6  Structure chart for program 6.3
Pascal Program 6.4 gives the Pascal equivalent of this program.


Test run 6.2 shows a sample run.
6.5 Exercises
6.5.1. Write a program with a single module that returns both the value of m and
c for a straight line, given passed values of (x1, y1) and (x2, y2). The
equation of the straight line is given by: 
   Example calls for C and Pascal are:

   
   where x1, y1, x2, y2 are the coordinates, m is the return gradient and c is
the returned value for the point at which the line cuts the y-axis.
6.5.2. Write a program which contains a module which is passed two parameters.
The module should arrange the values of the parameters so that the first
parameter is the largest.
6.5.3. Resistors are normally identified by means of a colour coding system,
which is given in Table 6.1. Figure 6.7 shows a 4-band resistor, where the
first two bands give a digit, the third a multiplier and the fourth the
tolerance. Write a program, with parameter passing, in which the user
enters the first three values of the code and the program determines the
resistor value. The value range of inputs is between 0 and 9 and A sample
run is shown in Test run 6.3.
Table 6.1
Resistor colour coding

FIGURE 6.7  4-band resistor colour code
6.5.4. Write a module, with parameter passing, in which a minimum and
maximum value are passed to it and the module returns back an entered
value which is between the minimum and maximum value.
   Example calls for C and Pascal are:
   where min is the minimum value, max is the maximum value and val is the
return valued.
   Use this program with the previous exercise so that the entered values are
between 0 and 9.
Worksheet 9:
W9.1. Write a program which has a module which converts a complex number
in rectangular form into polar form (magnitude and angle). The module
should have two values passed to it (x and y) and return two values for
the magnitude and angle of the complex number (mag and angle). These
values are determined using: 
   then

   Example calls for C and Pascal are:
W9.2. Write a program which has a module which converts a complex number
in polar form into rectangular form (real and imaginary). The module
should have two values passed to it (mag and angle) and return two
values for the real and imaginary parts of the complex number (x and y).
These values are determined using: 
   then
   Example calls for C and Pascal are:

7
Arrays
7.1 Introduction
An array stores more than one value, of a common data type, under a collective
name. Each value has a unique slot and is referenced using an indexing
technique. Figure 7.1 shows a circuit with 5 resistors, which could be declared
with a program with 5 simple float (in C) or real (in Pascal) declarations. If these
resistor variables were required to be passed into a function all 5 would have to
be passed through the parameter list. A neater method uses arrays to store all of
the values under a common name (in this case R). Thus a single array variable
can then be passed into any function that uses it.

FIGURE 7.1  Simple variables against array indexing
7.2 C arrays
The declaration of an array specifies the data type, the array name and the
number of elements in the array in brackets ([]). The following gives the
standard format for an array declaration.
Figure 7.2 shows that the first element of the array is indexed 0 and the last
element as size–1. The compiler allocates memory for the first element
array_name [0] to the last array element array_name [size–1]. The number of
bytes allocated in memory will be the number of elements in the array multiplied
by the number of bytes used to store the data type of the array.

FIGURE 7.2  Array elements
The following gives some example array declarations:
7.2.1 Pointers And Arrays
In C, there is a strong relationship between pointers and arrays. A pointer
variable stores a memory address which can be modified, whereas an array name
stores a fixed address, set to the first element in the array. The address of the first
element of an array named arrname is thus &arrname [0]. Table 7.1 shows
examples of how arrays and pointers use different indexing notations and how it
is possible to interchange them.
Table 7.1
Relationship between arrays and pointers

Figure 7.3 shows two array declarations for arrname. Each has five elements;
the first is arrname [0] and the last arrname [4]. The number of bytes
allocated to each element depends on the data type declaration. A char array uses
one byte for each element, whereas an int array will typically take 2 or 4 bytes.
The array name arrname is set to the address of the first element of the array.
Each element within the array is referenced with respect to this address.
FIGURE 7.3  Array elements
Table 7.2 gives some examples of array and pointer statements.
Table 7.2
Examples of array and pointer statements
Statements
Description
int tmp[100];
declare an array named tmp with 100 elements
tmp[1]=5;
assign 5 to the second element of array tmp
*(tmp+1)=5/
equivalent to previous statement
ptr=&tmp[2];
get address of third element
7.2.2 Passing Arrays To C Functions
At compilation the compiler reserves enough space for all elements in an array

and initializes the array name to the start of it. In order for a function to modify
the array the base address is passed through the parameter list. The function
itself does not know the maximum number of elements in the array; unless a
parameter relating to the maximum number of elements in the array is also
passed. It is thus possible to run off the end of an array and access memory not
allocated to the array.
The notation used to signify that an array is being passed in a function is
square brackets (this signifies that it is a fixed address and not a pointer
variable). The following gives an example of array passing.
7.3 Pascal arrays
In Pascal, the declaration of an array specifies the data type, the array name and
the number of elements in the array in brackets ([]). The following gives the
standard format for an array declaration.
This declares an array of type datatype with the first element of array_name
[startval] to the last array element array_name [endval]. The following gives
some example array declarations and assignments.

7.3.1 Passing Arrays To Functions
In order to pass an array into a Pascal function or a procedure the array type
must first be defined. This is achieved with the type keyword and an array
definition is normally done before any of the procedures or functions. For
example to define an array type with 100 elements of real values:
and an example array is declared with:
When an array is passed into a function or a procedure, the type definition
must be used to define the array type. The following section of code gives an
example of array being passing into a function. In this case the array type has
been defined as arrtype and the name of the array in the main program is arr1.
In the function the array name is arrayin.
If an array is passed to a procedure, the only way that the procedure can
modify the contents of an array so that when its contents are changed when the
procedure has completed is to put the var keyword in front of its declaration in

the parameter list. The following shows an example of two procedures which
can modify the contents of an array. In the first, fill_arr, the function modifies
the array passed to it as there is a var in front of it in the parameter list. If there
was no var in front of the array name then the contents of the passed array could
be modified within this function but when the function was complete then the
array which is passed to the fill_arr function (array1) would not have been
modified. In the copy_arr procedure, the first array passed (arr1) does not have
its contents changed as there is no var keyword in front of it in the parameter list,
whereas the second array passed (arr2) has the var keyword in front of it. The
section of the code should fill an array with entered values (arr1) and then copy
this array into another (arr2).
7.4 Examples
7.4.1 Running Average Program Program 7.1
Is A 3-Point Running Average Program. This

Type Of Program Has A Low-Pass Filter
Response And Can Filter Data Samples.
Figure 7.4 Illustrates How The Output Is A
Function Of The Average Of Three Elements
In The Input Array; This Is Achieved By
Generating A Running Average.
FIGURE 7.4  Array elements
The first and last values of the processed array will take on the same values as
the input array as there are not three values over which to take an average. Test
run 7.1 shows a sample run with 10 entered values.



7.4.2 Sorting Program
Program 7.2 is an example of a sorting program where an array is passed to the
sort function, which then orders the values from smallest to largest. The
algorithm initially checks the first value in an array with all the other values. If
the value in the first position is greater than the sampled array value then the two
values are swapped.
Figure 7.5 shows an example of how a 6-element array can be sorted to
determine the smallest value. In the first iteration the value of 20 is compared
with 22. Since 20 is smaller than 22 the values are not swapped. Next, the value
of 20 is compared with 12 (the third element), as this is smaller the values are
swapped. This now makes 12 the first element. This continues until the last
value (15) is tested. At the end of these iterations the smallest value (3) will be
the first element in the array. As the first element now contains the smallest
value the operation can now continue onto the second element. This is tested
against the third, fourth, fifth and sixth elements and so on. The number of
iterations required to complete this process will therefore be 15 (5+4+3+2+1).

FIGURE 7.5  Array elements



Test run 7.2 shows a sample run with 10 entered values.

7.4.3 Preferred Values
In C, the initialization of an array with values (or characters) is defined between
a set of braces ({}). The following gives the standard format for initializing an
array:
Program 7.3 determines the nearest preferred resistor value in the range 10 to
100 Ω. An initialized array pref_values [] contains normalized preferred values
of 10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82 and 100 Ω.
In Pascal, it is not possible to initialize an array with values. Thus the
set_pref procedure is used to fill up the pref_values array.
The find_nearest_pref function determines the nearest preferred value. Its
operation uses the difference between the entered value and an index value in the
preferred value array. If the difference is less than the difference between the
previous nearest value and the entered value then the current preferred value will
take on the current indexed array value. Figure 7.6 shows a basic structure chart
for this program (note, the set_pref function has been included for the Pascal
equivalent program). Test run 7.3 shows a sample run.

FIGURE 7.6  Structure chart for Program 7.3


7.5 Exercises
7.5.1. Write a function that will arrange an array in descending values. Refer to
Program 7.2.

7.5.2. Modify Program 7.3 so that it determines the nearest preferred resistor
value between 10 and 100 Ω for the set of preferred values given in Table
7.3.
Table 7.3
Preferred resistor values
7.5.3. Write a function which scales an entered real value so that it scales it
between 10 and 100 and displays the number of zeros. A sample run is
given in Test run 7.4.
   Possible algorithm is:
   where, after these codes are complete, the value of val will be between 10 and
100 and the num_zeros will have the number of scaling zeros.
7.5.4. Modify the program in 7.2 so the user can enter any value of resistance
and the program will determine the nearest preferred resistor value. Test
run 7.5 gives a sample run. Hint: write a function which scales the
entered value between 10 and 100 Ω (as written in Exercise 7.5.3) then
pass the scaled value to the preferred value’s function.

   
7.5.5. Modify the program in 7.2 so the user can enter any value of resistance
and the program will determine the nearest preferred resistor value. Test
run 7.5 gives a sample run. Hint: write a function which scales the
entered value between 10 and 100 Ω (as written in Exercise 7.5.3) then
pass the scaled value to the preferred value’s function.
7.5.6. Figure 7.7 shows an alternative representation of the program developed
in Section 7.4.1 with the array values represented as time sampled values,
where the D represents a single time step delay. In this case the input
value value is delayed by a single time step (Input[i–1]) and two time
steps (Input[i–2]). The representation of the output can be written as:
FIGURE 7.7  Averaging system for time sampling
   For the input data of:

   Determine the output for the following functions:
(i) 
(ii) 
(iii) 
Assume that the previous samples to i=0 are zero. Test run 7.6 gives a sample
run of (i) and Program 7.4 shows a sample program which does not have any
functions or procedures.

Worksheet 10:
W10.1. Write a program, using arrays, with a function that will return the largest

value entered by the user.
W10.2. Repeat W10.1 with a minimum function.
W10.3. Write a program which will fill an array with values for the function: 
   for; x=1 to 10 (that is, 1,2,3,4,5, … 10).
W10.4. Modify the program in W10.3 for a range of –1 to 1, with a step of 0.1
in-between (that is, –1, –0.9, –0.8, … 0.8, 0.9, 1).

8
Strings
8.1 Introduction
Strings are one-dimensional arrays containing characters. In most cases the
number of characters a string has will vary, depending on the input. Thus they
must be declared with the maximum number of characters that is likely to occur.
In Pascal, strings are relatively easy to use; whereas strings in C are relatively
complex, but C has the advantage of having powerful string manipulation
routines.
8.2 Pascal strings
Pascal has a special data type reserved for character arrays, which is string. The
string size can be set as the standard form of an array declaration. For example:
If the string size parameter is excluded, such as:
then the string is assumed to have a size of 255 characters.
Table 8.1 lists the routines (functions and procedures) which are used to
manipulate strings and Table 8.2 shows the routines which are used to convert
from numeric value into strings, and vice-versa.
Table 8.1
Pascal array routines

Table 8.2
Pascal string conversion routines
Program 8.1 shows an example program which uses strings. The assignment
operator (: =) is used to assign one string to another (in this case, str1 to str2).
The length function is also used to determine the number of characters in the
entered string.
A major problem in software development is to guard against incorrect user
input. Typically a user may enter a string of characters instead of a numeric
value, or a real value instead of an integer. Program 8.2 contains a function
(get_int) which overcomes this problem. In this function the user enters an
input into a string (inp). This string is then converted into a numeric value using
the val function. One of the parameters of the val function is code. If, after it is

called, it is a zero then the string has been successfully converted, else either a
string or a real value was entered. The user will be told that the input is invalid
and will be reprompted for another value (as the repeat … until condition is
false). The equivalent function to get a real value is:

8.3 C character arrays
In C an array is setup with an array of characters, such as:
The end of a string in C is identified with the ASCII Null or termination
character (‘\0’). If double quotes are used to define a string, such as “Cap1”, then
a Null character is automatically appended onto it. If the string is loaded, as an
array, with single characters then the Null character must be inserted after the
last character. For example, if the string to be loaded is “Cap1” then the array
elements would be ‘C, ‘a’, ‘p’, ‘1’, ‘\0’. In Figure 8.1 the string “Res–1” is

terminated in a Null character (that is, 0000 0000b).
FIGURE 8.1  Example of string allocation
Strings are character arrays with maximum size. The string name is the
memory address for the first character in the string. For a declared string of char
name [SIZE], the array name name is a fixed address at the start of the string and
SIZE the number of characters reserved in memory for the string. Figure 8.1
shows a sample string allocation in memory; the declared string contains a
maximum of 11 characters. The maximum number of displayable characters in
the stored string will only be 10 as the Null character terminates the string.
As with arrays, the first character of a string declared as char str1[SIZE] is
indexed as str1 [0] and the last as str1 [SIZE–1]. As with arrays, it is
possible to overrun the end of a string (especially if the termination character is
not present). This can cause data to be read from or written to areas of memory
not assigned for this purpose. The dimensioned string should always contain at
least the maximum number of entered characters + 1. If a string is read from the
keyboard then the maximum number of characters that can be entered is limited
by the keyboard buffer. A macro BUFSIZ, defined in stdio.h, can be used to
determine its size.
8.3.1 Standard String Functions
There are several string handling functions in the standard library; most are
prototyped in string.h. Table 8.3 lists these. All the string functions return a
value; for example, Strlen() returns an integer value relating to the length of a
string and the functions strcat (), strupr (), strlwr() and strcpy() return
pointers to the resultant string. This pointer can be used, if required, but the
resultant string is also passed back as the first argument of these functions. The
strcmp() function returns a 0 (zero) only if both strings are identical.

Table 8.3
The main string handling functions
C Program 8.1 shows how s scanf() scans a string with different data types.
In this case, the user enters a string of text. The first word of the string is read
as a string (res_name) and the second as a float (res_values). The sscanf ()
returns the number of fields successfully scanned; if the number of fields
scanned is equal to 2 the variable okay is set to TRUE and the do {} while()
loop will thus end. If it is not equal to 2 the okay variable is set to FALSE and an
error message is displayed, the user will then be prompted to re-enter the values.

Test run 8.2 shows a sample run.
C Program 8.2 uses the string function strcmp(). The do{} while() loop
continues until the user enters the word “exit”. Test run 8.3 shows a sample run.

8.4 Examples
8.4.1 Counting The Number Of Characters
Program 8.3 Contains A Function (Nochars
()) Which Scans A String And Determines
The Number Of Occurrences Of A Given
Character. It Uses Gets() To Read The String
As It Accepts Spaces Between Words.
The function nochars() uses pointer arithmetic to read each of the characters
in the passed string until a Null character. The getchar() function is used to get
the search character. Test run 8.4 shows a sample run.


8.4.2 Setting Up An Array Of Strings
In C, the simplest way of setting up an array of strings is to define a new string
data type. In C program 8.4 a new data type named string is defined using the
statement typedef char string [BUFSIZ]. An array of strings is then set up
using the declaration string database [MAX_COMP_NAMES]. Each string in the
array can contain a maximum of BUFSIZ characters (note this can be changed to
any size if required) and can be accessed using normal array indexing.

A sample run is given in Test run 8.5. Note that the string “exit” quits the
program.

The equivalent Pascal program is given in Pascal Program 8.4. In this case a
new data type of declared (str_arr) which is an array of strings.

In C, an array of strings can also be initialized using braces. Program 8.5 and
Test run 8.6 show how this is set up.

8.4.3 Impedance Of A Parallel RC Circuit
The program in this section determines the impedance of a parallel RC circuit.
Figure 8.2 gives a schematic of this circuit. The impedance of this circuit can be
found using the product of the impedances over the sum. Thus:
FIGURE 8.2  Parallel RC circuit
The magnitude of the impedance is thus:
A structure chart for a program which determines this magnitude is given in
Figure 8.3 (note that for clarity the parameters passed to the two of the calls to
the get_float() function have not been included). The get_parameters()
function gets three variables (Res, Cap and freq); parallel_impedance()
determines the input impedance and returns it back into the variable Zin. Finally,
print_impedance() displays the input parameters and calculated impedance.

FIGURE 8.3  Structure chart for Program 8.7
The get_float() (or get_real() in Pascal) function gets a value by first
putting the entered information into a string and then converting it into a floating
point value. If the conversion fails then the user is asked to re-enter the value. It
also contains a check for the minimum and maximum value of the entered value.

Test run 8.7 shows that the user can enter a value in the incorrect format and
the program will reprompt for another. Notice that the user has entered the
strings “none” and “fred”; the program copes with these and reprompts for an
input.


8.5 Exercises
8.5.1. Explain why it is better to input numeric values as a string and then
converting it to a numeric value rather than entering it with scanf() (in
C) or readln() (in Pascal).

8.5.2. Write a program that declares the following seven strings.
   
   Store these strings as a single array of strings named menu by declaring an
array of strings. The program should display these strings as menu
options using a for loop. Test run 8.8 shows a sample run.
8.5.3. Modify the program in Exercise 8.5.2 so that the user can enter the menu
option. The program will display a message on the option selected. Test
run 8.9 shows a sample run.

8.5.4. Modify some programs in previous chapters so that program parameters
are entered using the get_float() (or get_real()) function.
8.5.5. Write a function that will capitalize all the characters in a string.
8.5.6. Repeat Exercise 8.5.5 but make the characters lowercase.
8.5.7. Write a function that will determine the number of words in a string.
Worksheet 11:
W11.1. Write a program in which the user enters a string of text and then presses
the RETURN key. The program will then display the number of
characters in the entered text. A sample run is shown in Test run 8.10.
W11.2. Write a program in which the user enters a string of either “sin”, “cos” or
“tan” and then a value. The program will then determine the
corresponding sine, cosine or tan of the value. A sample run is shown in
Test run 8.11.

W11.3. Modify the program in W11.2 so that the program reads in the entered
value as a string and converts it to a real value. The program should
reprompt if the value is invalid.
W11.4. Write a program in which the user enters a number of names, each
followed by the RETURN key. The end of the names is signified by
entering no characters. The program should store these in an array of
strings and then display them to the user. A sample run is shown in Test
run 8.12.
   

9
File I/O
9.1 Introduction
Information on computers is organized into directories and files. Typically files
have a filename followed by a filename extension which identifies the type of
file. This file extension is important in some operating systems, such as
Windows 95 and Windows NT, as it identifies the application program which is
associated with the file. Table 9.1 shows some typical file types.
Table 9.1
Typical file types
Files either contain text in the form of ASCII (a text file) or a binary file. A
text file uses ASCII characters and a binary file uses the binary digits which the
computer uses to store values. It is not normally possible to view a binary file
without a special program, but a text file can be viewed with a text editor.
Figure 9.1 shows an example of two files which contain four integer values.
The binary file stores integers using two bytes in 2s complement signed notation,
whereas the text file uses ASCII characters to represent the values. For example,

the value of –1 is represented as 11111111 11111111 in 2s complement. This
binary pattern is stored to the binary file. The text file uses ASCII characters to
represent –1 (these will be ‘-’ and ‘1’), and the bit pattern stored for the text file
will thus be 0010 1101 (ASCII ‘-’) and 0011 0001 (ASCII ‘1’). If a new line is
required after each number then a new-line character is inserted after it. Note,
there is no new-line character in ASCII and it is typical to represent a new-line
with two characters, a carriage return (CR) and a line feed (LF). In C, the new-
line character is denoted by ‘\n’.
FIGURE 9.1  File pointer
The file pointer moves as each element is read/written. Figure 9.2 shows a file
pointer pointing to the current position within the file.
FIGURE 9.2  Binary and text files

The number of bytes used to store each of the elements will depend on the
data type of the variable. For example, a long integer will be stored as four bytes,
whereas a floating point value can be stored as four bytes (on some systems).
The floating point format differs from an integer format; the standard floating
point format uses a sign-bit, a significand and an exponent. The end of the file is
signified by an EOF character.
9.2 Pascal file I/O
Pascal has a very basic set of file input/output. The functions used are defined in
Table 9.2.
Table 9.2
Pascal file I/O functions
Function
Description
assign (fptr,fname)
Assigns a file point (fbtr) to a file (fname).
rewrite (fptr)
Creates and opens a file which has been assigned with fbtr.
reset (fptr)
Opens an existing file which has been assigned with fbtr.
write (fptr, val)
Writes a value (val) to a file which has been assigned with fbtr.
read (fptr, val)
Reads a file which has been assigned with fbtr and puts the value into val.
In Pascal, a file pointer is defined either with the text keyword (for a text file)
or with:
Thus a file pointer for an integer file would use the following:
Pascal Program 9.1 reads in a number of integer values and writes each one in
turn to a file (‘out.dat’). The program initially assigns the filename to the file
pointer (fout) using the assign function. Next the file is created with the
rewrite function. Each value that is entered is then written to the file using the
write function. The program keeps prompting for values until the user enters a –

1 value. When this happens the program will exit the repeat … until loop. The
file pointer is then reset to the start of the file with the reset function. Next the
values are read back using the read function. Finally, after the –1 value is read-
in, the file is closed with the close routine.
9.3 C file I/O
There are 11 main functions used in file input/output (I/O), which are listed
below. The fprint() and fscanf() functions are similar to printf() and
scanf(), but their output goes to a file.

A file pointer stores the current position of a read or write within a file. All
operations within the file are made with reference to the pointer. The data type
of this pointer is defined in stdio.h and is named FILE.
9.3.1 Opening A File (Fopen ())
A file pointer is assigned using fopen(). The first argument is the file name and
the second a string which defines the attributes of the file; these are listed in
Table 9.3.
Table 9.3
File attributes
Attribute
Function
“r”
open for reading only
“w”
create for writing
“a”
append; open for writing at the end-of-file or create for writing if the file does not exist
“r”
open an existing file for update (read and write)
“w+”
create a new file for update
“a+”
open for append: open (or create if the file does not exist) for up-date at the end of the file)
The default mode for opening files is text, but a t attribute can be appended
onto the attribute string to specify a text file. For example, the attribute “wt”

opens a text file for writing. A binary file is specified by appending a b onto the
attribute string. For example, “rb” will open a binary file for reading.
The format of the fopen() function is:
If fopen() is completed successfully a file pointer will be returned, and this is
initialized to the start of the file. If was not able to open the file then a NULL will
be returned. There can be many reasons why a file cannot be opened, such as:
• The file does not exist.
• The file is protected from reading from and/or writing to.
• The file is a directory.
It is important that a program does not read from a file that cannot be opened
as it may cause the program to act unpredictably. A test for this condition is
given next.
9.3.2 Closing A File (Fclose())
Once a file has been used it must be closed before the program is terminated. A
file which is not closed properly can cause problems in the file system. The
standard format is given next; the return value (rtn) returns a 0 (a zero) on
success, otherwise EOF if any errors occur. The macro EOF is defined in stdio.h.
The feof() function detects the end-of-file character. It returns a non-zero
value (that is, a TRUE) if the file pointer is at the end of a file, else a 0 is
returned. The function shown next uses the feof() function to detect the end of

the file and also tests the return from the fscanf() so that an unsuccessful
reading from the file is disregarded.
9.3.3 Reading From Files
Table 9.4 lists the main functions and examples used in reading from files.
Table 9.4
Reading from files

9.3.4 Writing To Files
Table 9.5 lists the main functions used in writing to files.
Table 9.5
Writing to files

9.4 Examples
9.4.1 Averages Program
C Program 9.1 and Pascal Program 9.2 use text files to determine the average
value of a number of floating point values contained in a file. The get_values()
function is used to read the values from a file, in this case, IN.DAT. This file can
be created using a text editor.


An example of the contents of the IN.DAT file are given next.
A sample run using this file is given in Test run 9.1.


9.4.2 Binary Read/Write
C Program 9.2 and Pascal Program 9.3 is an example of how an array of floating
point values is written to a binary file. In the C program the floating point values
are writen using fwrite() and then read back using fread(). Note that the
NOFILE flags returned from dump_data() and read_data() are ignored by
main(). In the Pascal program the values are written to the file using write and
read using the read routine.


A sample test run is given in Test run 9.2.


9.5 Reading and writing one character at a time
In C a single character is read from a file with fgetc() and read back with the
fputc(). C Program 9.3 shows an example of reading a character, one at a time,

from a file and writing it to another file. Pascal Program 9.4 gives the equivalent
program. It uses the read and write routines.
9.6 Exercises
9.6.1. Write a program in which the user enters any character and the program
will determine the number of occurrences of that character in the
specified file. For example:

9.6.2. Write a program which will determine the number of words in a file.
(Hint: count the number of spaces in the file.) 9.6.3. Write a program
which will determine the number of lines in a file. A possible method is
to count the new-line characters.
9.6.4. Write a program which will get rid of blank lines in an input file and
writes the processed file to an output file. Example input and output files
are given next.
Worksheet 12:
W12.1. Write a program which will determine the average, the largest and the
smallest values of a text file containing floating point values in a text
form.
W12.2. Write a program which will count the number of characters in a file.
Hint: read the file one character at a time.
W12.3. Write a program which will count the occurrences of the letter ‘a’ in a
file. Hint: read the file one character at a time.
W12.4. Modify Program 9.1 so that the output is written to a file.

10
Structures and Records
10.1 Introduction
A structure (or, in Pascal, a record) is an identifiable object that contains items
which define it. These items are linked under a common grouping. For example,
an electrical circuit has certain properties that define it. These could be:
• A circuit title.
• Circuit components with identifiable names.
• Circuit components with known values.
For example, a circuit may have a title of “RC Filter Circuit”, the circuit
components are named “R1”, “R2” and “C1” and the values of these are 4320 Ω,
1200 Ω and 1 μF, respectively. The title and the component names are character
strings, whereas the component values are floating points. A structure (or record)
groups these properties into a single entity. These groupings are referred to as
fields and each field is made up of members.
10.2 Records in Pascal
A structure is a type that is a composite of elements that are distinctive and
perhaps of different data types. The following is an example of a structure which
will store a single electrical component. The record variable declared, in this
case, is Component. It has three fields of differing data types; cost (a float), code
(an integer) and name (a character string).

The dot notation (.) accesses each of the members within the record. For
example:
Pascal Program 10.1 is a simple database program. The database stores a
record of a single electrical component which includes its name
(Component.name), 
its 
cost 
(Component.cost) 
and 
its 
code 
number
(Component.code). The name is a string, the code a signed integer and the cost a
floating point value.
Test run 10.1 shows a sample run.
Pascal 
Program 
10.2 
contains 
a 
procedure 
to 
print 
the 
record
(print_component ()). To pass a structure into a function the data type of
parameter passed must be defined. For the purpose the type keyword is used to
define a new data type, in this case, it is named comp.

Test run 10.2 shows a sample run.
Pascal Program 10.3 uses a function to get data into the record
(get_component ()). The parameter passed into this function has a var in front
of the parameter so that it can be passed back to the calling routine.

Test run 10.3 shows that the results are identical to the previous run.
10.3 Structures in C
A structure is a type that is a composite of elements that are distinctive and
perhaps of different data types. The following gives an example of a structure
declaration (in this case the strings have been declared with a maximum of 100
characters).
The following is an example of a structure which will store a single electrical

component. The structure variable declared, in this case, is Component. It has
three fields of differing data types; cost (a float), code (an integer) and name (a
character string).
The dot notation (.) accesses each of the members within the structure. For
example:
C Program 10.1 is a simple database program. The database stores a record of
a single electrical component which includes its name (Component.name), its
cost (Component.cost) and its code number (Component.code). The name is a
string, the code a signed integer and the cost a floating point value.

Test run 10.4 shows a sample run.
Note that the structure could have been set up at initialization using the
following:
C Program 10.2 contains a function to print the structure (print_component
()). To pass a structure into a function the data type of parameter passed must be
defined. For the purpose the typedef keyword is used to define a new data type;
in this case, it is named CompType. The program also uses braces to initialize the
fields within the structure.

Test run 10.5 shows a sample run.
C Program 10.3 uses a function to get data into the structure (get_component
()). The parameter passed into this function will be a pointer to the base address
of the structure. For this purpose, an ampersand is inserted before the structure
name. The structure pointer operator (->) is used with the structure pointer to
access a member of a field.

Test run 10.6 shows that the results are identical to the previous run.
10.4 Array of structures
An array of structures can be set up in a way similar to normal array indexing.
When an array is declared the compiler assigns enough memory to hold all its
elements. Program 10.4 is similar to Program 10.3, but uses an array of
structures to store up to 5 electrical components. Figure 10.1 shows a structure
chart of this program. It uses get_float() and get_int() to filter any invalid
inputs for the cost and code of a component. These functions were developed in
Chapter 9 and have been reused as they have been well tested and are easily
ported into any program. The cost of the electrical components is now limited
between 0 and 1,000 and the component code from 0 to 32,767. A get_string()
function has also been added to get the name of the component. Test run 10.7
shows a sample run.
FIGURE 10.1  Structure chart for Program 10.4





10.4.1 Complex Arithmetic
Program 10.5 uses a structure (or record) to multiply to complex numbers. If
these complex numbers are a+jb and c+jd and the result is z then:

This operation is implemented in the function (procedure) multi_complex ().
Test run 10.8 gives a test run for the result of 3+j4 and 6+j2.

10.5 Exercises
10.5.1. Write a database program, based on Program 10.4, which gives a menu
choice as to whether the user wishes to enter input a new electric
component, to list all the components already in the database, or to exit
the program. A sample run is given in Test run 10.9.
10.5.2. Write a program which converts from rectangular notation to polar form.
In rectangular notation: 
   in polar form this is:

10.5.3. Write a program using structures (or records) with complex impedance
values that will determine the parallel impedance of two impedances Z1
and Z2. The formula for the impedances in parallel is given below:
10.5.4. Write a program which contains the following complex number
manipulation routines:
(i) complex number add.
(ii) complex number subtract.
(iii) complex number multiply.
(iv) complex number divide.
10.5.5. Modify the database program in the text so that the user can select an
option which will order the component names in alphabetic order.

PART B
C++

11
Introduction to C++
11.1 Introduction
C is an excellent software development language for many general purpose
applications. Its approach is that data and associated functions are distinct, data
is declared and the functions are then implemented. Object-oriented
programming languages allow the encapsulation of a set of data types and
associated functions into objects. These objects are integrated entities.
C++ is by far the most popular object-oriented language. It was developed by
Bjane Stoustrup at AT&T Bell Laboratories. A new programming language,
based on C++, called Java, has since been developed by Sun Microsystems. C++
is well supported and there are many different development systems. Figure 11.1
shows Microsoft Visual C++ Version 4.0. Microsoft Visual Version 5.0 is
similar but has enhanced support for WWW applications. The default file
extension for a C++ program is CPP.

FIGURE 11.1  Microsoft Visual C++
11.2 Enhancements to C++
C++ has many enhancements over C. These include:
I/O stream support. This facility allows data to be directed to an input and/or
an output stream. Section 11.3 outlines this.
Objects. An object incorporates data definitions and the declaration and
definitions of functions which operate on that data.
Classes. These are used to implement objects and can be initialized and
discarded with constructors and destructors, respectively. Section 11.6 outlines
this.
Complex numbers. C++ supports the usage of complex numbers and their
mathematical operations. Section 11.7 outlines these.
Data hiding. This allows certain data to be hidden from parts of a program
which are not allowed access to it. Section 11.6 outlines this.
Overloading. This allows more than one definition and implementation of a
function. Section 11.5 outlines this.
Virtual functions. This allows any one of a number of multiple defined
functions to be called at run-time.
Template classes. This allows the same class to be used by different data.

11.3 I/O stream
In C, output is sent to the standard output using the printf() function. In C++,
standard input and output are taken from streams. The standard output stream is
cout (normally to the monitor) and the standard input stream is taken from cin
(normally from the keyboard). To be able to use these streams, the iostream.h
header file must be included in the program. The redirection operator (<<) is
used to direct the data to the input or output. Program 11.1 shows an example
program and Test run 11.1 shows a sample run.
Program 11.2 shows another example and Test run 11.2 show a sample run.

11.4 Comments
C++ supports single line comment with a double slash (//) or multiline comment
which are defined between a (* and a *). The single line comment makes
everything on the line after the double slash a comment. A few examples are:
11.5 Function overloading
Often the programmer requires to call a function in a number of ways but still
wants the same name for the different implementations. C++ allows this with
function overloading. With this the programmer writes a number of functions
with the same number but which are called with a different argument list or
return type. The compiler then automatically decides which one should be
called. For example, in C++ Program 11.3 the programmer has defined three
square functions named sqr(). The data type of the argument passed is of a
different type for each of the functions, that is, either an int, a float or a
double. The return type is also different. In this program, three variables, of
different types, have been declared in the main() function. The compiler will
then call the correct format function for each of the calls. Test run 11.3 shows a
sample run. It can be seen that the implementation of the square function with a
float data type produces some rounding errors.

The argument list of the overloaded function does not have to have the same
number of arguments for each of the overloaded functions. C++ Program 11.4
shows an example of an overloaded function which has a different number of
arguments for each of the function calls. In this case, the show_results()
function can either be called with a message, followed by three values, or the
three values, or with a single value.

11.6 Classes
Classes are a general form of structures (struct). In C, a struct gathers together
data members and in C++ the struct may also have function members. The main
difference between a class and a struct is that in a struct all members of the

structure are public, while in a class the members are, by default private
(restricted). In a class, members are made public with the public keyword, and
private with the private keyword.
C++ Program 11.3 shows an example of a class. It can be seen that it is similar
to a structure, but that some parts of the class are private while others are public.
These are defined as follows:
• A public member of a class can be accessed by external code that is not part
of the class. Often the public member is a function.
• A private class member can only be used by code defined in a member
function of the same class.
It is obvious that all classes must have a public content so that they can be
accessed by external functions. In C++ Program 11.5 the circuit class has a
private part, in this case, the variable rtemp. The public parts are the functions
parallel() and serial(), which determine the parallel and series resistance of
two resistors. In the main function the class is declared to c1. The series
calculation is called with c1. series (r1,r2) and the parallel calculation is called
with c1.parallel (r1, r2).

The class would get cumbersome if the functions within it where to be defined
in it. C++ Program 11.6 shows how the functions can be defined in another part
of the program. In this case the class name is defined followed by a double colon
(::) and then the function name.
The private part of a class is typically used to store variables which are local

only to the class. An example is shown in C++ Program 11.7 where the variables
local to the circuit class are r1 and r2. The get_res() function is then used to
set these values and the other two functions then use them.

In many cases the use of passing parameters by pointers can be eliminated by
using classes. This is shown in C++ Program 11.8 where the get_res() function
is private to the circuit class. Then within the series() and parallel()
functions the get_res() function is called. Note that no other function can call
this function as it is private to circuit.

11.7 Complex numbers
C++ contains a range of functions which support complex numbers. These are
prototyped in complex.h and are outlined in Table 11.1.
Table 11.1
Complex functions prototyped in complex.h

The data type complex is used to declare a complex variable. In C++ Program
11.9 the variable z has been declared a complex variable. The complex()
function is used to convert the x and y variables into a complex number. The
functions real(), imag(), conj(), abs() and pow() are used and Test run 11.6
displays a sample run.

11.8 Exercises
11.8.1. Write an overloaded function which determines the gradient of a straight
line. The parameters passed are either two (x, y) coordinates (x1, y1 x2,
y2) or if the change in x and the change in y (dx, dy). The gradient will be
calculated as follows: 
11.8.2. Write an overloaded function which determines the angle of a straight
line. The parameters passed are either two coordinates (x1, y1, x2, y2) or
if the change in x and the change in y (dx, dy). The gradient will be
calculated as follows: 
11.8.3. The following C++ class definition contains date functions. The
get_date() function should fill the variables day, month and year. The
valid_data() function should then test if the entered date is valid.

   Write a C++ program which contains this class definition.
11.8.4. C++ Program 11.10 has a mathfunction class which contains multiply
and divide functions. Write a program which adds several other
mathematical functions, to give the following:
   

11.8.5. Modify Exercise 11.8.4 so that the values are entered from the keyboard.
11.8.6. The following C++ class definition contains an initialization, increment,
decrement and displaying functions. The initialization function should
initialize the samples variable to 0; the increment function should add one
onto the samples variable; the decrement should take one away from
samples and the show_samples display the samples value. Complete the
class declaration and write a C++ which calls it. The increment function
should be called when the ‘j’ key is pressed (followed by the RETURN
key) and the decrement function should be called when the ‘1’ key
(followed by the RETURN key) is pressed. The value of samples should
be displayed when the RETURN key is pressed without either the ‘j’ or
‘1’ keys.

   
11.8.7. Using the complex number functions determine the following, for the
complex number a=4 + i5 and b=6 + i10:
(a) a+b
(b) axb
(c) a-b
(d) a÷b
(e) a2
(f) b3
(g) |a|
(h) ea
(i) √a
Note that in electrical engineering a complex number is typically represented as
a+jb.

12
More C++
12.1 Constructors and destructors
A constructor allows for the initialization of a class and a destructor allows the
class function to be removed from memory. They are defined as follows:
• A constructor is a special initialization function that is automatically called
whenever a class is declared. The constructor always has the same name
as the class name, and no data types are defined for the argument list or
the return type. Normally a constructor is used to initialize a class.
• A destructor is a member of a function which is automatically called when the
class is destroyed. It has the same name as the class name but is preceded
by a tilde (~). Normally a destructor is used to clean-up when the class is
destroyed.
C++ Program 12.1 has a class which is named class_ex. The constructor for
this class is class_ex() and the destructor is ~class_ex(). Test run 12.1 shows
a sample run. It can be seen that initially when the program is run the message
Constructing is displayed. This is because the class is initially declared to c1.
Then when the function test() is called the Constructing message is again
displayed as a new class is defined (c2). When the program leaves this function
the destructor is called and thus the message Destructor is displayed. Finally,
when the program quits the destructor is again called.

12.2 Function templates
Function templates allow functions to be capable of operating on arguments of
any data type. To define a function template the following is done:
• Prefix the function with the template keyword.
• Define one or more identifiers that define parameterized types within angled
brackets.
In C++ Program 12.2 the template is created for a maximum() function. The
template definition:

defines that number can be of any data type. Thus:
could be matched to any one of the following:
The definition of the function is given as:

12.3 Class templates
The class template is a generalization of the function template. These allow
collections of objects of any type using the same class template. Program 12.3
shows an example of a class calc_current. In this case the template is defined
as:
which defines that number can be of any data type. When defining the class
variable the data type is defined. For example, to define the data type of number
as an int, then:
or as a float:
In the case of C++ Program 12.3 the class which uses an int will perform
integer operations and the float declaration will perform float operations.

12.4 I/O streams
The standard C++ library provides an expanded set of functions, templates,
string-handling classes and many other enhancements to C. One of the main
enhancements is the stream I/O library.
The stream I/O library gets rids of a particular problem in C where functions
such as printf() and scanf(), gives run-time errors when the data they are
handling is in the incorrect data form. For example:
would create an error if i was declared as a floating-point value. The stream
I/O function for input from the standard input is:

This allows for automatic data type conversion. To support the stream I/O the
stdio.h header file has been replaced by the header files iostream.h,
fstream.h and iomanip.h, and classes which are automatically defined are:
cout
for standard output.
cin
for standard input.
cerr
for standard error
The stream I/O class hierarchy is given in Figure 12.1. The ios (I/O state)
class is declared in iostream.h, and it contains information about the state of the
stream. It includes functions which are used to open and close streams, and it
also has stream format flags.
FIGURE 12.1  Block diagram of a simple computer system
The file I/O classes ifstream and ofstream are declared in the header file
fstream.h. and the class iostream inherits both istream and ostream, and is
declared in iostream.h.ifstream inherits all the standard input stream
operations defined by istream and adds a few more, such as constructors and
functions for opening files. of stream similarly related to ostream.
Finally, fstream, declared in the header file fstream.h, inherits iostream and
contains functions and constructors that allow files to be opened in input/output
mode.
The classes can be summarized by:
Abstract Stream Base
Class
 
ios
Stream base class.
Input Stream Classes
 
istream
General-purpose input stream class and base class for other input streams.
ifstream
Input file stream class.

Output Stream Classes
 
ostream
General-purpose output stream class and base class for other output streams.
ofstream
Output file stream class.
Input/Output Stream
Classes
 
iostream
General-purpose input/output stream class and base class for other input/output
streams.
fstream
Input/output file stream class.
12.4.1 Opening And Closing A File
The functions used to open and close a stream are open() and close (),
respectively.
open()
For a program to use a file stream (fstream) it must first be associated with a
specific disk file with the open function. This function is used with an associated
open_mode flag, which can be combined together with the bitwise OR (|)
operator. Table 12.1 defines these flags.
Table 12.1
File open flags
Flag
Function
ios::app
Opens an output file for appending.
ios::ate
Opens an existing file and sets the file pointer to the end of the file.
ios::binary
Opens file in binary mode (Note that the default mode is text mode).
ios::in
Opens an input file. Use ios::in as an open_mode for an ofstream file to prevent truncating
an existing file.
ios::nocreate
Open the file only if it already exists. Otherwise the operation fails.
ios::noreplace
Opens the file only if it does not exist. Otherwise the operation fails.
ios:: out
Opens an output file. When you use ios::out for an ofstream object without ios::app, ios::ate,
or ios::in, ios::trunc is implied.
ios::trunc
Opens a file and deletes the old file (if it already exists).
To declare a file pointer the class ofstream is used. For example, to declare a
stream of myfile which has the file name of out.dat and is an output file:

This type of declaration can be used when the stream has a fixed name and
file_open flag. It is also possible to use the open function to open the file. The
following achieves the same as the previous sample program.
The following gives an example of a binary file which is only for input:
while the following gives an example of a binary file which is only for input
and output:
close()
The close member function is used to close the file associated with an output
file stream. The fstream destructor automatically closes the file when the class
is destroyed. It is typically used when the stream needs to be associated with
another file.
C++ Program 12.4 opens a file for output and writes the character ‘H’ to it and
then closes the file.

12.4.2 Text I/O
The two main functions used for text I/O are put() and get().
put()
The put member function writes a single character to the output stream. C++
Program 12.4 shows an example of the put() function.
get()
The unformatted get member function works like the >> operator with two
exceptions:
• The get function includes white-space characters, whereas the extractor
excludes white space.
• The get function is less likely to cause a tied output stream (cout, for
example) to be flushed.
To extract a string:
Or to extract a single character:

where nCount is the maximum number of characters to store the line and
delim is the delimiter character (which by default is a new-line).
getline()
The getline member function is similar to the get function, but they differ as
the get function leaves the terminating character in the stream; whereas getline
removes the terminating character.
C++ Program 12.5 gives an example of the getline() function.
12.4.3 Error Processing Functions
The I/O stream libraries also contain a number of member functions which can
be used to test for errors while reading and writing to a stream. Table 12.2 lists
these flags.
Table 12.2
Error processing functions
Function
Return value
bad
Returns TRUE if there is an unrecoverable error.
fail
Returns TRUE if there is an unrecoverable error or an “expected” condition, such as a conversion
error, or if the file is not found.

good
Returns TRUE if there is no error condition (unrecoverable or other-wise) and the end-of-file flag is
not set.
eof
Returns TRUE on the end-of-file condition.
clear
Sets the internal error state. If called with the default arguments, it clears all error bits.
rdstate
Returns the current error state.
C++ Program 12.6 shows an example program which uses the fail() and
good() functions. The fail() function allows the program to test if the file has
been opened and the good() function allows the program to test if the end-of-file
has been reached (or if an error has occurred).
Note that:
can be replaced by:

as the ! operator is overloaded to perform the same function as the fail()
function.
12.4.4 File Pointers
The seekg() and tellg() are uses to set (seekg) or get (tellg) the current file
point for an input stream. On the output stream the seekp() and tellp() are
used. The seekg format is:
where pos specifies the new position value, off is the new offset value,
(streamoff and streampos are a typedef equivalent to a long int) and dir is the
seek direction which must be one of the following:
C++ Program 12.7 gives an example of a file pointer being set to the
beginning of a file with myfile.seekp(01, ios::beg)), where 01 represents a
zero offset and ios::beg the flag for the beginning of the file.
The tellg() format is:
where the streampos type is a long int.
12.4.5 Binary I/O
read
The read member function is similar to the read function in C. It reads a
specified number of bytes from a file into specified areas of memory. C++
Program 12.7 gives an example a single floating point value beginning written to
a file and then read back.

write
The write member function is similar to the write() function in C. It writes a
specified number of bytes from memory into a file. C++ Program 12.8 gives an
example of writing a 10 element array to a file and then reading it back.

12.5 Exercises
12.5.1. Modify C++ Program 12.2 so that it implements a minimum function.
12.5.2. Using a function template write a program which will calculate the
current in a circuit where the voltage and resistance can either be ints,
floats or doubles. The current is given by: 
12.5.3. Write a program which will read the text from a file in.dat and copy it,
one character at a time, to the file out.dat.
12.5.4. Write a program in which the user enters 10 floating-point values from
the keyboard. The program should then store these to a binary file (f
ile1.dat). Finally the file should be read-back to check its contents.

PART C
Assembly Language

13
Introduction
13.1 Introduction
High-level languages such as C, Pascal, Basic and FORTRAN are useful in
representing operations in an algorithm-like manner. These high-level languages
tend to hide much of the system operations away from the programmer. In most
cases, the operation of the program within the computer is invisible and the
location of the data or the program code in memory is also unimportant. This is
important in most applications as the programmer can forget about much of the
low-level operations and get on with high-level operations such as mathematical
calculations, graphics, and so on.
There are three main reasons for learning Assembly Language, these are:
• It increases the understanding of the operation of the computer.
• Assembly Language codes generally can be used to finely tune the operation
of the code. This fine tuning often speeds-up the operation of the
program. This is because high-level compilers do not always optimize the
generated code for speed.
• To gain access to certain hardware operations.
Many programs use a mixture of a high-level language and Assembly
Language for machine or time critical operations.
13.2 Basic computer architecture
The main elements of a basic computer system are a central processing unit (or
microprocessor), memory, and input/output (I/O) interfacing circuitry. These are
connected by means of three main buses: the address bus; the control bus; and
the data bus, as illustrated in Figure 13.1. External devices such as a keyboard,
display, disk drives, and so on, can connect directly onto the data, address and
control bus or can be connected via the I/O interfacing circuit. A bus is a
collection of common electrical connections grouped by a single name.

FIGURE 13.1  Block diagram of a simple computer system
Memory normally consists of RAM (random access memory) and ROM (read
only memory). ROM stores permanent binary information, whereas RAM is a
non-permanent memory and will lose its contents when the power is taken away.
Applications of this type of memory include running application programs and
storing temporary information.
The main controller for the computer is the microprocessor. It fetches binary
instructions from memory, decodes these instructions into a series of simple
actions and carries out the actions in a sequence of steps which are synchronized
by a system clock. To access a location in memory the microprocessor must put
the address of the location on the address bus. The contents at this address are
then placed on the data bus and the microprocessor reads the data on the data
bus. To store data in memory the microprocessor places the data on the data bus.
The address of the location in memory is put on the address bus and the data is
then read from the data bus into the required memory address location.
The classification of a microprocessor relates to the maximum number of bits
it can process at a time, that is their word length. The evolution has gone from 4-
bit, 8-bit, 16-bit, 32-bit and to 64-bit architectures.
13.3 Bits and bytes
A computer operates on binary digits named bits. These can either store a ‘1’ or
a ‘0’ (ON/ OFF). A group of 4 bits is a nibble and a group of 8 bits a byte. These
8-bits provide 256 different combinations of ON/OFF, from 00000000 to
11111111. A 16-bit field is known as a word and a 32-bit field as a long word.
Binary data is stored in memories which are either permanent or non-permanent.
This data is arranged as bytes and each byte has a different memory address, as

illustrated in Figure 13.2.
FIGURE 13.2  Memory storage (each address holds eight bits).
13.3.1 Binary Numbers
A computer operates on binary digits which use a base-2 numbering system. To
determine the decimal equivalent of a binary number each column is represented
by 2 raised to the power of 0, 1, 2, and so on. For example, the decimal
equivalents of 1000 0001 and 0101 0011 are:
Thus 01001111 gives:
The number of decimal values that a binary number can represent relates to
the number of bits. For example:
• 8 bits gives 0 to 28–1 (255) different representations; • 16 bits gives 0 to 216–1
(65 535) different representations; • 32 bits gives 0 to 232–1 (4 294 967
295) different representations.
The most significant bit (msb) is at the left-hand side of the binary number
and the least significant bit (lsb) on the right-hand side. To convert from decimal
(base-10) to binary the decimal value is divided by 2 recursively and remainder
noted. The first remainder gives the least significant digit (LSD) and the last the

most significant digit (MSD). For example:
Thus 110110 in binary is 54 decimal.
13.4 Binary arithmetic
The basic binary addition operation is given next.
This is used when adding two binary numbers together. For example:
13.5 Numbers and representations
Numbers are stored in several different ways. These can be:
• integers or floating point values.
• single precision or double precision numbers.
• signed or unsigned integers.
13.5.1 Negative Numbers
Signed integers use a notation called 2s complement to represent negative
values. In this representation the binary digits have a ‘1’ in the most significant

bit column if the number is negative, else it is a ‘0’. To convert a decimal value
into 2s complement notation, the magnitude of the negative number is
represented in binary form. Next, all the bits are inverted and a ‘1’ is added. For
example, to determine the 16-bit 2s complement of the value –65, the following
steps are taken:
Thus, –65 is 11111111 1011111 in 16-bit 2s complement notation. Table 13.1
shows that with 16 bits the range of values that can be represented in 2s
complement is from –32 767 to 32 768 (that is, 65 536 values).
Table 13.1
16-bit 2s complement notation
When subtracting one value from another the value to be taken away is first
converted into 2s complement format. This is then added to the other value and
the result is in 2s complement. For example, to subtract 42 from 65, first 42 is
converted into 2s complement (that is, –42) and added to the binary equivalent
of 65. The result gives a carry into the sign bit and a carry-out.
For a 16-bit signed integer can vary from –32768 (1000 0000 0000 0000) to

32767 (0111 1111 1111 1111). A simple C program to convert from a 16-bit
signed integer to 2s complement binary is given in Program 13.1.
A sample run is given in Test run 13.1.

13.5.2 Hexadecimal And Octal Numbers
In assembly language binary numbers are represented with a proceeding b, for
example 010101111010b and 101111101010b are binary numbers. Binary digits
are often commonly represented in hexadecimal (base 16) or octal (base 8)
representation. Table 13.2 shows the basic conversion between decimal, binary,
octal and hexadecimal numbers. In assembly language hexadecimal numbers
have a proceeding h and octal number an O. For example, 4 3 F1h is a
hexadecimal value whereas 4 310o is octal.
Table 13.2
Decimal, binary, octal and hexadecimal conversions 

To represent a binary digit as a hexadecimal value the binary digits are split
into groups of four bits (starting from the least significant bit). A hexadecimal
equivalent value then replaces each of the binary groups. For example, to
represent 0111010111000000b the bits are split into sections of 4 to give:
Thus, 75C0h represents the binary number 0111010111000000b. To convert
from decimal to hexadecimal the decimal value is divided by 16 recursively and
each remainder noted. The first remainder gives the least significant digit and the
final remainder the most significant digit. For example, the following shows the
hexadecimal equivalent of the decimal number 1103:
Thus the decimal value 110 3 is equivalent to 0 4 4 Fh.
In C, hexadecimal values are preceded by a 0 (zero) and the character ‘x’ (0x)
and an octal number a preceding zero 0 (zero). In Pascal, a dollar sign is used to
signify a hexadecimal value, for example $C4. Table 13.3 gives some example

formats.
Table 13.3
Decimal, binary, octal and hexadecimal conversions 
13.6 Memory addressing size
The size of the address bus indicates the maximum addressable number of bytes.
Table 13.4 shows the size of addressable memory for a given address bus size.
For example:
Table 13.4
Addressable memory (in bytes) related to address bus size
Address bus size
Addressable memory (bytes)
1
2
2
4
3
8
4
16
5
32
6
64
7
128
8
256
9
512
10
1K*
11
2K
12
4K
13
8K
14
16K
15
32K
16
64K
17
128K

17
128K
18
256K
19
512K
20
1M†
21
2M
22
4M
23
8M
24
16M
25
32M
26
64M
32
4G‡
64
16GG
*1K represents 1024
†1M represents 1 048 576 (1024 K) ‡1G represents 1 073 741 824 (1024 M)
• A 1-bit address bus can address up to two locations (that is 0 and 1).
• A 2-bit address bus can address 22 or 4 locations (that is 00, 01, 10 and 11).
• A 20-bit address bus can address up to 220 addresses (1 MB).
• A 24-bit address bus can address up to 16 MB.
• A 32-bit address bus can address up to 4 GB.
13.7 Exercises
13.7.1. Complete the table below (assume 8-bit unsigned binary values):
Decimal
Binary (8-bit)
12
 
235
 
128
 
255
 
 
1011 0110
 
0110 1001
13.7.2. Determine the binary or decimal equivalents for the following values
(assume 16-bit values and 2s complement notation):

13.7.3. Complete the table below (assume 16-bit signed integers and 2s
complement):
13.7.4. Determine the following subtractions using 2s complement notation
(assume 8-bit values and the answer should be in 2s complement):
(i) 43–21
(ii) 12–46
(iii) 127–126
(iv) 0–72
(v) 32+75

14
Computer Architecture
14.1 History of the PC
In 1959, IBM built the first commercial transistorized computer named the IBM
7090/7094 series. It was so successful that it dominated the computer market for
many years. Later, in 1965, they produced the famous IBM system 360 which
was built with integrated circuits. Then in 1970 IBM introduced the 370 system,
which included semiconductor memories. Unfortunately, these computers were
extremely expensive to purchase and maintain.
Around the same time the electronics industry was producing cheap pocket
calculators. The development of affordable computers happened when the
Japanese company, Busicon, commissioned a small, at the time, company named
Intel to produce a set of eight to twelve ICs for a calculator. Instead of designing
a complete set of ICs, Intel produced a set of ICs which could be programmed to
perform different tasks. These were the first ever microprocessors. Soon Intel
(short 
for 
Integrated 
Electronics) 
produced 
a 
general-purpose 
4-bit
microprocessor, named the 4004, and a more powerful 8-bit version, named the
8080. Other companies, such as Motorola, MOS Technologies and Zilog were
soon also making microprocessors.
IBM’s virtual monopoly on computer systems soon started to slip as many
companies developed computers based around the newly available 8-bit
microprocessors, namely MOS Technologies 6502 and Zilog’s Z–80. IBM’s
main contenders were Apple and Commodore who introduced a new type of
computer – the personal computer (PC). The leading systems were the Apple I
and the Commodore PET. These spawned many others, including the Sinclair
ZX80/ZX81, the Sinclair Spectrum, the Commodore Vic-20 and the classic
Apple II (all of which where based on or around the 6502 or Z–80).
IBM realized the potential of the microprocessor and used Intel’s 16-bit 8086
microprocessor in their version of the PC. It was named the IBM PC and has
since become the parent of all the PCs ever produced. IBM’s main aim was to

make a computer which could run business applications, such as word
processors, spreadsheets and databases. To increase the production of this
software they made information on the hardware freely available. This resulted
in many software packages being developed and helped clone manufacturers to
copy the original design. So the term ‘IBM-compatible’ was born and it quickly
became an industry standard by sheer market dominance.
14.2 Intel microprocessors
Intel marketed the first microprocessor, named the 4004, and it caused a
revolution in the electronics industry because previous electronic systems had a
fixed functionality. With this processor the functionality could be programmed
by software. It could handle just four bits of data at a time (a nibble), contained
2,000 transistors, operated with 46 instructions and allowed 4KB of program
code and 1 KB of data.
The second generation of Intel microprocessors began in 1974 with the 8-bit
processors; these were named the 8008, 8080 and the 8085. As they could
handle more bits at a time they were much more powerful than the previous 4-bit
devices. They were typically used in early microcomputers and applications such
as electronic instruments and printers. The 8008 had a 14-bit address bus and
could thus address up to 16KB of memory and the 8080 had a 16-bit address bus
thus giving it a 64 KB limit.
The third generation of microprocessors began with the launch of the 16-bit
processors. Intel released the 8086 microprocessor, which was mainly an
extension to the original 8080 processor, and thus retained a degree of software
compatibility. IBM’s designers realized the power of the 8086 and used it in the
original IBM PC and IBM XT (eXtended Technology). It had a 16-bit data bus
and a 20-bit address bus, giving a maximum addressable capacity of 1 MB. It
could also handle either 8 or 16 bits of data at a time (although in a messy way).
The PC has evolved since using Intel processors.
A stripped-down 8-bit external data bus version called the 8088 was also
available. This stripped down processor allowed designers to produce less
complex (and cheaper) computer systems. An improved architecture version of
the 8088/88, called the 80286, was launched in 1982, and was used in the IBM
AT (Advanced Technology).
In 1985, Intel introduced its first 32-bit microprocessor, the 80386DX. This
device was compatible with the previous 8088/8086/80286 (80×86) processors

and gave excellent performance. It could handle 8, 16 or 32 bits at a time and
had a full 32-bit data and address buses. This gave it a physical addressing
capability of 4 GB. A stripped-down 16-bit external data bus and 24-bit address
bus version called the 80386SX was released in 1988. Thus, because of its
limited address bus size, it could only access up to 16 MB of physical memory.
In 1989, Intel introduced the 80486DX which was basically an improved
80386DX with a memory cache and math co-processor integrated onto the chip.
It had an improved internal structure making it around 50% faster than a
comparable 80386. The 80486SX was also introduced, which was merely a
80486DX with the link to the math co-processor broken. A major limiting factor
on the speed of the processor became the speed of the system clock. For this
reason clock doublers and treblers where released allowed the processor to use a
higher clock speed than the system clock. Thus internal operations within the
processors were much faster but the processor had to slow down to the system
clock to communicate with external devices. Typically, systems with clock
doubler processors operated around 75% faster than the comparable non-doubled
processors (because much of the operation within the computer is done with the
processor). Typical clock doubler processors are DX2–66 and DX2–50 which
run from 33 MHz and 25 MHz clocks, respectively. Intel also produced a range
of microprocessors that run at three or four times the system clock speed and are
referred to as DX4 processors. These include the Intel DX4–100 (25 MHz clock)
and Intel DX4–75 (25 MHz clock).
The Pentium (or P–5) is a 64-bit ‘superscalar’ processor. It can execute more
than one instruction at a time and has a full 64-bit (8-byte) data bus and a 32-bit
address bus, and can operate at speeds from 75 MHz to over 200 MHz (which
runs from the 66 MHz system clock). In terms of performance, it operates almost
twice as fast as the equivalent 80486. It also has improved floating-point
operations (roughly three times faster) and is fully compatible with previous
80x86 processors. Figure 14.1 shows how Intel processors interface to external
equipment.

FIGURE 14.1  Intel microprocessors and their external interfacing
14.3 80386/ 80486 microprocessor
Figure 14.2 shows the main 80386/80486 processor connections. The Pentium
processor connections are similar but it has a 64-bit data bus. There are three
main interface connections: the memory/IO interface, interrupt interface and
DMA (direct memory access) interface.
FIGURE 14.2  Some of the 80386/80486 signal connections.
The write/read (w / ) line determines whether data is written to (w) or read
from ( ) memory. PCs can interface directly with memory or can interface to
isolated memory. Signal line M /  differentiates between the two types. If it is
high then the direct memory is addressed, else if it is low then the isolated

memory is accessed.
The 80386DX and 80486 have an external 32-bit data bus (D0-D31) and a 32-
bit address bus ranging from A2 to A31. The two lower address lines, A0 and A1,
are decoded to produce the byte enable signals 
, 
, 
 and 
. The 
 line
activates when A1A0 is 00, 
 activates when A1A0 is 01, 
 activates when
A1A0 and 
 activates when A1A0 is 11. Figure 14.3 illustrates this addressing.
FIGURE 14.3  Memory addressing
The byte enable lines are also used to access either 8, 16, 24 or 32 bits of data
at a time. When addressing a single byte, only the 
 line will be active (D0-D7);
if 16 bits of data are to be accessed then 
 and 
 will be active (D0-D15); if 32
bits are to be accessed then 
, 
, 
 and 
 are active (D0-D31).
The D/  line differentiates between data and control signals. When it is high
then data is read from or written to memory, else if it is low then a control
operation is indicated, such as a shutdown command.
The interrupt lines are interrupt request (INTR), non-maskable interrupt request
(NMI) and system reset (RESET), all of which are active high signals. The INTR line is
activated when an external device, such as a hard disk or a serial port, wishes to
communicate with the processor. This interrupt is maskable and the processor
can ignore the interrupt if it wants. The NMI is a non-maskable interrupt and is
always acted-on. When it becomes active the processor calls the non-maskable
interrupt service routine. The RESET signal causes a hardware reset and is normally
made active when the processor is powered-up.

14.4 Registers
All the PC-based Intel microprocessors are compatible with the original 8086
process and are normally backwardly compatible. Thus, for example, a Pentium
can run 8086 and 80386 code. Microprocessors use registers to perform their
operations. These registers are basically special memory locations in that they
are given names. The 8086 has 14 registers which are grouped into four
categories, as illustrated in Figure 14.4.
FIGURE 14.4  8086/88 registers
14.4.1 General Purpose Registers
There are four general purpose registers which are AX, BX, CX and DX. Each
can be used to manipulate a whole 16-bit word or with two separate 8-bit bytes.
These bytes are called the lower and upper order bytes. Each of these registers
can be used as two 8-bit registers; for example, AL represents an 8-bit register
which is the lower half of AX and AH represents the upper half of AX.
The AX register is the most general purpose of the four registers and is

usually used for all types of operations. Each of the other registers has one or
more implied extra functions. These are:
• AX, which is named the accumulator. It is used for all input/output operations
and some arithmetic operations. For example, multiply, divide and
translate instructions assume the use of AX.
• BX, which is named the base register. It can be used as an address register.
• CX, which is the count register. It is used by instructions which require to
count. Typically it is used for controlling the number of times a loop is
repeated and in bit shift operations.
• DX, which is the data register. It is used for some input/output and also when
multiplying and dividing.
14.4.2 Addressing Registers
The addressing registers are used in memory addressing operations, such as
holding the source address of the memory and the destination address. These
address registers are named BP, SP, SI and DI, which are:
• SI, which is the source index. This is used with extended addressing
commands.
• DI, which is the destination index. The destination is used in some addressing
modes.
• BP, which is the base pointer.
• SS, which is the stack pointer.
14.4.3 Status Registers
Status registers are used to test for various conditions in an operation, such as ‘is
the result negative’, ‘is the result zero’, and so on. The two status registers have
16 bits and are called the instruction pointer (IP) and the flag register (F):
• IP, which is the instruction pointer. The IP register contains the address of the
next instruction of the program.
• Flag register. The flag register holds a collection of 16 different conditions.
Table 14.1 outlines the most used flags.
Table 14.1
Processor flags

14.4.4 Segments Registers
There are four areas of memory called segments, each of which have 16 bits and
can thus address up to 64 KB (from 0000h to FFFFh). These segments are:
• Code segment (cs register). This defines the memory location where the
program code (or instructions) is stored.
• Data segment (ds register). This defines where data from the program will be
stored (ds stands for data segment register).
• Stack segment (ss register). This defines where the stack is stored.
• Extra segment (es).
All addresses are with reference to the segment registers.
The 8086 has a segmented memory, these registers are used to manipulate
these segments. Each segment provides 64 KB of memory, this area of memory
is known as the current segment. Segmented memory will be discussed in more
detail in the next section.

14.4.5 Memory Addressing
There are several methods of accessing memory locations, these are:
• Implied addressing which uses an instruction in which it is known which
registers are used.
• Immediate (or literal) addressing uses a simple constant number to define the
address location.
• Register addressing which uses the address registers for the addressing (such
as AX, BX, and so on).
• Memory addressing which is used to read or write to a specified memory
location.
14.5 Memory segmentation
The 80386, 80486 and Pentium processors run in one of two modes, either
virtual or real. When using the virtual mode they act as a pseudo-8086 16-bit
processor, known as the protected mode. In the real-mode they can use the full
capabilities of their address and data bus. The mode and their addressing
capabilities depend on the software and thus all DOS-based programs use the
virtual mode.
The 8086 has a 20-bit address bus so that when the PC is running 8086-
compatible code it can only address up to 1 MB of memory. It also has a
segmented memory architecture and can only directly address 64 KB of data at a
time. A chunk of memory is known as a segment and hence the phrase
‘segmented memory architecture’.
Memory addresses are normally defined by their hexadecimal address. A 4-bit
address bus can address 16 locations from 0000b to 1111b. This can be
represented in hexadecimal as 0h to Fh. An 8-bit bus can address up to 256
locations from 00h to FFh.
Two important addressing capabilities for the PC relate to a 16-and a 20-bit
address bus. A 16-bit address bus addresses up to 64KB of memory from 0000h
to FFFFh and a 20-bit address bus addresses a total of 1 MB from 00000h to
FFFFFh. The 80386/80486/Pentium processors have a 32-bit address bus and can
address from 00000000h to FFFFFFFFh.
A memory location is identified with a segment and an offset address and the
standard notation is segment:offset. A segment address is a 4-digit
hexadecimal address which points to the start of a 64 kB chunk of data. The

offset is also a 4-digit hexadecimal address which defines the address offset
from the segment base pointer. This is illustrated in Figure 14.5.
FIGURE 14.5  Memory addressing
The segment:offset address is defined as the logical address, the actual
physical address is calculated by shifting the segment address 4 bits to the left
and adding the offset. The example given next shows that the actual address of
2F8 4:0532 is 2FD72h.
14.5.1 Accessing Memory Using C And Pascal
In C the address 1234:9876h is specified as 0×12349876. Turbo Pascal accesses a
memory location using the predefined array mem[] (to access a byte), memw[] (a
word) or memw [] (a long integer). The general format is mem[segment:offset].
14.5.2 Near And Far Pointers
A near pointer is a 16-bit pointer which can only be used to address up to 64 KB
of data whereas a far pointer is a 20-bit pointer which can address up to 1 MB of
data. A far pointer can be declared using the far data type modifier, as shown

next.
In the program shown in Figure 14.6 a near pointer ptr1 and a far pointer
ptr2 have been declared. In the bottom part of the screen the actual addresses
stored in these pointers are displayed. In this case ptr1 is DS:12 34h and ptr2 is
0000:12 34h. Notice that the address notation of ptr1 is limited to a 4-digit
hexadecimal address, whereas ptr2 has a segment:offset address. The address
of ptr1 is in the form DS:XXXX where DS (the data segment) is a fixed address in
memory and XXXX is the offset.
FIGURE 14.6  Near and far pointers
There are several modes in which the compiler operates. In the small model
the compiler declares all memory addresses as near pointers and in the large
model they are declared as far pointers. Figure 14.7 shows how the large
memory model is selected in Borland C (Options→ Compiler→ Model→ Large).
The large model allows a program to store up to 1 MB of data and code.
Normally the small model is the default and only allows a maximum of 64 KB
for data and 64 KB for code.

FIGURE 14.7  Compiling a program in the large model
14.6 View inside the processor
To be able to view the processor the user must use a debugging program.
Figure 14.8 shows an example of Turbo Debugger which is available with
most of the Borland software development products and can be used to view the
operation of a program. It can be seen that the machine code and equivalent
assembly language macro appears in the top left hand window. A sample code
line is:
FIGURE 14.8  Example screen from Turbo Debugger

which specifies that the memory location is 01FA in the code segment
(cs:01FA). Machine code at this location is 55 (0101 0101) and the equivalent
Assembly Language instruction is push bp. Note that the cs segment address in
this case is 57 57h, thus the actual physical address will be with reference to the
address 57 570h (see Section 14.5 for a fuller explanation).
The contents of the flag register are shown on the right-hand side. In this case
the flags are:
The registers are shown to the left of the flag register. In this case the contents
are:
The data (in the data segment) is shown at the bottom left hand corner of the
screen. The first line:
shows the first 8 bytes in memory (from DS:0000 to DS:0007). The first byte
in memory is 00h (0000 0000) and the next is also 00h. After the 8 bytes are
defined the 8 equivalent ASCII characters are shown. In this case, these are:
The ASCII equivalent character for 5A (1001 1010) is ‘T’ and for 75 (0111
0101) it is ‘u’. Note that, in this case, the data segment register has 58A0h. Thus
the location of the data will be referenced to the address 58A00h.
The bottom right-hand window shows the contents of the stack.
14.7 Machine code and assembly language

An important differentiation is between machine code and assembly language.
The actual code which runs on the processor is machine code. These are made
up to unique bit sequences which identifies the command and other values which
these commands operate on. For example, for the debugger screen from Figure
14.8, the assembly language line to move a value into the AX register is:
the equivalent machine code is:
where the code B8h(1011 1000b) identifies the instruction to move a 16-bit
value into the AX register and the value to be loaded is 0194h (0000 0001 1001
0100b). Note that the reason the 94h value is stored before the 01h value is that
on the PC the least significant byte is stored in the first memory location and the
most significant byte in the highest memory location. Figure 14.9 gives an
example of storage within the code segment. In this case the two instructions are
mov and push. In machine code these are B8h and 50h, respectively.
FIGURE 14.9  Example memory storage for code segment
14.8 Exercises
14.8.1. For the debug screen given in Figure 14.10 determine the following:

FIGURE 14.10  Example screen from Turbo Debugger
(i) Contents of AX, BX, CX, DX, SI, DI.
(ii) Contents of AH, AL, BH and BL.
(iii) The first assembly language command.
(iv) The memory address of the first line of code (Hint: the cs:02C2 and
the value in the cs register need to be used).
(v) The memory address of the data (Hint: the ds:0000 and the value in
the ds register need to be used).

15
8086/88 Instructions
15.1 Introduction
This chapter discusses 8086/88 assembly language. As previously mentioned all
of the 80X86 and Pentium processors can run 8086 code. The 80386, 80486 and
Pentium processors run in one of two modes, either virtual or real. When using
the virtual mode they act as a pseudo-8086 16-bit processor, known as the
protected mode. All DOS-based programs use the virtual mode.
15.2 Characters and numbers
Integers can be represented as binary, octal, decimal, or hexadecimal numbers;
8086 Assembly Language represents these with a preceding B, O, D or H,
respectively. A decimal integer is assumed if there is no letter. Examples of
numeric constants are:
Character constants are enclosed with single quotes when they have a fixed
number of characters (such as ‘b’, ‘fired’, and so on), or if they have a variable
number of characters they are enclosed with double quotes (such as “a”, “fred”,
and so on).
For example:
15.3 Comments

Assembly Language programs probably need more comments than high-level
language as some of the operations give little information on their purpose. The
character used to signify a comment is the semi-colon (;) and all comments
within a program are ignored by the assembler. For example, the following lines
have comments:
15.4 Move (MOV)
The move instruction (mov) moves either a byte (8 bits) or a word (16 bits) from
one place to another. There are three possible methods:
• Moving data from a register to a memory location.
• Moving data from a memory location to a register.
• Moving data from one register to another.
Note that in 8086/88 it is not possible to move data directly from one memory
location to another using a single instruction. To move data from one memory
location to another then first the data is move from the memory location into a
register, next it is moved from the register to the destination address.
Examples of moving a constant value into registers are:
An address location is identified within square bracket ([]). Then to move
data into a specified address the address location must be loaded into a register.
For example, to load the value of 50h (0101 0000) into address location 200h the
following lines are used:
The general format of the mov instruction is:

Where r/m stands for register (such as AH, AL, BH, BL, CH, CL, DH, DL,
AX, BX, CX, DX, BP, SI, DI) or memory location. And r/m/d stands for a
register, memory or a constant value. The register sr stands for any of the
segment registers (CS, DS, ES, SS) and r16/m16 stand for any 16-bit register
(AX, BX, CX, SP, BP, SI, DI) and 16-bit memory address.
15.5 Addressing memory
An address location can be specified with either the BX, BP, SI or DI register.
Examples are:
Program 15.1 gives an Assembly Language; it loads 1234h into address
DS:0000h, 5678h into address DS:0002h and 22h into address DS:0005h.
Figure 15.1 shows a sample run of Program 15.1. It can be seen that the mov
[bx], 1234 operation loads the value 34h into address location DS:0000h and
12h into address DS:0001h. This is because the processor loads the least
significant byte into the lower address location.

FIGURE 15.1  Sample run of Program 15.1
It can be seen from Figure 15.1 that the associated machine code for the
instructions is:
Thus BBh is the machine code to load a value into the BX register, C7 07h loads
as value into the address pointed to and C747h loads an offseted value into an
address location.
15.6 Addition and subtraction (ADD and SUB)
As they imply, the ADD and SUB perform addition and subtraction of two words or
bytes. The ADD and SUB instruction operate on two operands and put the result
into the first operand. The source or destination can be a register or address.
Examples are:

The standard format of the add instruction is
where r is any register, m is memory location and d is any constant value.
15.7 Compare (CMP)
The CMP instruction acts like the SUB instruction, but the result is discarded. It
thus leaves both operands intact but sets the status flags, such as the O
(overflow), C (carry), Z (zero) and S (sign flag). It is typically used to determine
if two numbers are the same, or if one value is greater, or less than, another
value. Examples are:
15.8 Unary operations (INC, DEC and NEG)
The unary operations operate on a single operand. An INC instruction increments
the operand by 1, the DEC instruction decrements the operand by 1 and the NEG
instruction makes the operand negative. Examples are:
15.9 Boolean bitwise instructions (AND, OR,
XOR and NOT)
The Boolean bitwise instructions operate logically on individual bits. The XOR

function yields a 1 when the bits in a given bit position differ; the AND function
yields a 1 only when the given bit positions are both 1s. The OR operation gives
a 1 when any one of the given bit positions are a 1. These operations are
summarised in Table 15.1. For example:
Table 15.1
Bitwise operations
Examples of Assembly Language instructions which use bitwise operations
are:
15.10 Shift/rotate instructions (SHL, SAL, SHR,
SAR, ROL, ROR, RCL and RCR)
The shift/rotate instructions are:
SHL –shift bits left
SHR–shift bits right
SAL –shift arithmetic left
SAR–shift arithmetic right
RCL –rotate through carry left
RCR –rotate through carry right
ROL –rotate bits left
ROR –rotate bits right
The shift instructions move the bits, with or without the carry flag, and can

either be an arithmetic shift or logical shift, whereas the rotate instructions are
cyclic and may involve the carry flag. The SHL and SHR shift bits to the left and
right, respectively. They shift the bits to the left or right where the bit shifted out
is put into the carry flag and the bit shifted in is a 0. The rotate operations (ROL,
ROR, RCL, RCR) are cyclic. Rotate with carry instructions (RCL and RCR) rotate
the bits using the carry flag. Thus the bit shifted out is put into the carry flag and
the bit shift in is taken from the carry flag. The rotate bits (ROL and ROR) rotate
the bits without the carry flag. The SAL instruction is identical to SHL, but the
SAR instruction differs from SHR in that the most significant bit is shifted to the
right for each shift operation. This operation, and the others, are illustrated in
Figure 15.2.
FIGURE 15.2  Rotate operations
The number of shifts on the value is specified either as a unitary value (1) or
the number of shift is stored in the counter register (CL). The standard format is
where r/m is for register or memory and 1 stands for one shift. If any more

than one shift is required the CL register is used. These operations take a
destination and a counter value stored in CL. For example, with bit pattern: Initial
conditions:
01101011 and carry flag 1
Result after:
The following is an example of the SAR instruction:
After sar ax, 1 stores 005Bh (0000 0000 0101 1011b) then the sar ax, c1
instruction moves the contents of AX by 3 bit positions to the right. The contents
of AX after this operation will be 0005h (0000 0000 0000 0101b).
The following shows an example of the SHR instruction:
And an example of the ROR instruction:
15.11 Unconditional jump (JMP)
The JMP instruction transfers program execution to another part of the program.
It uses a label to identify the jump location; this is defined as a name followed by

a colon. The JMP instruction is not conditional – the program will always jump.
An example is given next:
15.12 Conditional jumps
With the JMP the program always goes to the label, but the unconditional jumps
will only branch if a certain condition is met, such as if the results is negative, or
the result is zero, and so on. Table 15.2 outlines the condition jump instructions.
Table 15.2
Conditional jump instructions
A few example are:

15.13 Subroutine calls (CALL and RET)
Subroutines allow a section of code to be called and for the program to return
back to where it was called. The instructions are CALL and RET. An example is
given next:
15.14 Push and pop
The PUSH and POP instructions are typically used with subroutines. A PUSH
instruction puts the operand onto a temporary storage called a stack (this will be
covered in more detail later). The stack is a LIFO (last in, first out) where the
last element to be loaded is the first to be taken off, and so on. The POP
instruction is used to extract the last value which was put on the stack.
Typically they are used to preserve the contents of various registers so that
their contents are recovered after a subroutine is called. For example, if a
subroutine modifies the AX, BX and CX registers, then the registers are put on the
stack with:
Next the subroutine can use these registers for its own use. Finally, within the
subroutine, the original registers are restored with:
The order of the POP instructions must be the reverse of the PUSH instructions
so that the contents are properly restored. For example:

15.15 Moving around data in memory
Program 15.2 loads the memory locations from DS:0000h to DS:00FFh with
values starting at 00h and ending at FFh. After the AL and BX registers have
been initialized to 00h then the code runs round a loop until all the memory
locations have been loaded. The BX register contains the address the value will
be loaded to. This increments each time round the loop. The AL register stores
the value to be loaded into the currently specified memory location. Figure 15.3
shows a sample run.

FIGURE 15.3  Sample debug screen
15.16 Assembler directives
There are various structure directives that allow the user to structure the
program. These are defined in Table 15.3.
Table 15.3
Assembler directives

15.17 Data definition
Variables are declared in the data segment. To define a variable the DB (define
byte) and DW (define word) macros are used. For example, to define (and
initialize) a variable temp, which has the value 15 assigned to it, is declared as
follows:
an uninitialized variable has a value which is a question mark, for example:
There are other definition types used, these are:

• dd (define doubleword –2 times 16 bits which is 4 bytes).
• dq (define quadword, which is 8 bytes).
• dt (define 10 bytes).
The data definition is defined within the data segment. In Turbo Assembler
(TASM) the data segment is defined after the .DATA directive (as shown in
TASM Program 15.4). Microsoft Assembler (MASM) defines the data segment
between the data segment and data ends, as shown in MASM Program 15.3.
Program 15.3 declares two variables named val1 and val2. The value val1 is
loaded with the value 1234h and val2 is loaded with 5678h. Figure 15.4 shows
an example screen after the three mov instructions have been executed. It can be
seen val1 has been stored at DS:0000 and val2 at DS:0002.
FIGURE 15.4  Sample debug screen

15.18 Equates (EQU)
To define a token to a certain value the EQU (equates) statement can be used.
For example:
The general format is:
The assembler simply replaces every occurrence of the token with the value
given.

15.19 Exercises Part 1
In this tutorial the sample code should be inserted, by replacing the highlighted
code, into Program 15.5.
15.19.1. Enter the following code and run the debugger to determine the values
given next.
15.19.2. Enter the following code and run the debugger to determine the values
given below.

15.19.3. Enter the following code and run the debugger to determine the values
given below.
   
15.19.4. Enter the following code and run the debugger to determine the values
given below.
15.19.5. Enter the following code and run the debugger to determine the values
given below.

15.19.6. Enter the following code and run the debugger to determine the values
given below.
15.19.7. Enter the following code and run the debugger to determine the values
given below.
15.19.8. Enter the following code and run the debugger to determine the values
given below.

15.19.9. Enter the following code and run the debugger to determine the values
given below.
15.19.10. Enter the following code and run the debugger to determine the values
given below.
   
15.19.11. Enter the following code and run the debugger to determine the values

given below.
15.19.12. Enter the following code and run the debugger to determine the values
given below.
15.19.13. Enter the following code and run the debugger to determine the values
given below.
15.19.14. Enter the following code and run the debugger to determine the values
given below.
   

15.19.15. Enter the following code and run the debugger to determine the values
given below.

15.20 Exercises Part 2
15.20.1. Write an Assembly Language program which contains a function which
adds the contents of the AX and BX registers and puts the result into the
CX register.
15.20.2. Write a program which loads the values 00h, 01h, 02h, … FEh, FFh
into the memory locations starting from address DS:0008h. A basic
layout is shown below.
15.20.3. Write a program which will load the values FFh, FEh, FDh, … 01h, 00h
into the memory locations starting from address DS:0000h.
15.20.4. Write a program which moves a block of memory from DS:0020h to
0100h to addresses which start at address 0200h.
15.20.5. Write a program which determines the largest byte in the memory
locations 0000h to 0050h.

16
8086 Interfacing and Timing
16.1 Introduction
There are two main methods of communicating external equipment, either they
are mapped into the physical memory and given a real address on the address
bus (memory mapped I/O) or they are mapped into a special area of input/output
memory (isolated I/O). Figure 16.1 shows the two methods. Devices mapped
into memory are accessed by reading or writing to the physical address. Isolated
I/O provides ports which are gateways between the interface device and the
processor. They are isolated from the system using a buffering system and are
accessed by four machine code instructions. The IN instruction inputs a byte, or
a word, and the OUT instruction outputs a byte, or a word. C and Pascal compilers
interpret the equivalent high-level functions and produce machine code which
uses these instructions.
FIGURE 16.1  Memory mapping or isolated interfacing

16.2 Interfacing with memory
The 80×86 processor interfaces with memory through a bus controller, as shown
in Figure 16.2. This device interprets the microprocessor signals and generates
the required memory signals. Two main output lines differentiate between a read
or a write operation (R/ ) and between direct and isolated memory access (M/ ).
The R/  line is low when data is being written to memory and high when data is
being read. When M/  is high, direct memory access is selected and when low,
the isolated memory is selected.
FIGURE 16.2  Access memory mapped and isolated I/O
16.3 Memory mapped I/O
Interface devices can map directly onto the system address and data bus. In a
PC-compatible system the address bus is 20 bits wide, from address 00000h to
FFFFFh (1 MB). If the PC is being used in an enhanced mode (such as with
Microsoft Windows) it can access the area of memory above the 1 MB. If it uses
16-bit software (such as Microsoft Windows 3.1) then it can address up to 16
MB of physical memory, from 000000h to FFFFFFh. If it uses 32-bit software

(such as Microsoft Windows 95) then the software can address up to 4 GB of
physical memory, from 00000000h to FFFFFFFFh. Table 16.1 and Figure 16.3
gives a typical memory allocation.
Table 16.1
Memory allocation for a PC
Address
Device
00000h–00FFFh
Interrupt vectors
00400h–0047Fh
ROM BIOS RAM
00600h–9FFFFh
Program memory
A0000h–AFFFFh
EGA/VGA graphics
B0000h–BFFFFh
EGA/VGA graphics
C0000h-C7FFFh
EGA/VGA graphics
FIGURE 16.3  Typical PC memory map
16.4 Isolated I/O

Devices are not normally connected directly onto the address and data bus of the
computer because they may use part of the memory that a program uses or they
could cause a hardware fault. On modern PCs only the graphics adaptor is
mapped directly into memory, the rest communicate through a specially reserved
area of memory, known as isolated I/O memory.
Isolated I/O uses 16-bit addressing from 0000h to FFFFh, thus up to 64 KB of
memory can be mapped. Microsoft Windows 95 can display the isolated I/O
memory map by selecting Control Panel → System → Device Manager, then
selecting Properties. From the computer properties window the Input/output
(I/O) option is selected. Figure 16.4 shows an example for a computer in the
range from 0000h to 0064h and Figure 16.5 shows from 0378h to 03FFh.
FIGURE 16.4  Example I/O memory map from 0000h to 0064h

FIGURE 16.5  Example I/O memory map from 0378h to 03FFh
It can be seen from Figure 16.5 that the keyboard maps into address 0060h and
0064h, the speaker maps to address 0061h and the system timer between 0040h
and 0043h. Table 16.2 shows the typical uses of the isolated memory area.
Table 16.2
Typical isolated I/O memory map
Address
Device
000h–01Fh
DMA controller
020h–021h
Programmable interrupt controller
040h–05Fh
Counter/Timer
060h–07Fh
Digital I/O
080h–09Fh
DMA controller
0A0h–0BFh
NMI reset
0C0h–0DFh
DMA controller
0E0h–0FFh
Math coprocessor
170h–178h
Hard-disk (Secondary IDE drive or CD-ROM drive)
lF0h-lF8h
Hard-disk (Primary IDE drive)
200h–20Fh
Game I/O adapter
210h–217h
Expansion unit
278h–27Fh
Second parallel port (LPT2:)
S
d
i l
t (COM2 )

2F8h–2FFh
Second serial port (COM2:)
300h–31Fh
Prototype card
378h–37Fh
Primary parallel port (LPT1:)
380h–38Ch
SDLC interface
3A0h–3AFh
Primary binary synchronous port
3B0h–3BFh
Graphics adapter
3C0h–3DFh
Graphics adapter
3F0h–3F7h
Floppy disk controller
3F8h–3FFh
Primary serial port (COM1:)
16.4.1 Inputting A Byte From An I/O Port
The assembly language command to input a byte is:
where DX is the Data Register which contains the address of the input port.
The 8-bit value loaded from this address is put into the register AL.
For Turbo/Borland C the equivalent function is inportb(). Its general syntax
is as follows:
where PORTADDRESS is the address of the input port and value is loaded with
the 8-bit value from this address. This function is prototyped in the header file
dos.h.
For Turbo Pascal the equivalent is accessed via the port [] array. Its general
svntax is as follows:
where PORTADDRESS is the address of the input port and value the 8-bit value
at this address. To gain access to this function the statement uses dos requires to
be placed near the top of the program.
Microsoft C++ uses the equivalent inp() function (which is prototyped in
conio.h).

16.4.2 Inputting A Word From A Port
The assembly language command to input a word is:
where DX is the Data Register which contains the address of the input port.
The 16-value loaded from this address is put into the register AX.
For Turbo/Borland C the equivalent function is inport(). Its general syntax is
as follows:
where PORTADDRESS is the address of the input port and value is loaded with
the 16-bit value at this address. This function is prototyped in the header file
dos.h.
For Turbo Pascal the equivalent is accessed via the portw [] array. Its general
syntax is as follows:
where PORTADDRESS is the address of the input port and value is the 16-bit
value at this address. To gain access to this function the statement uses dos
requires to be placed near the top of the program.
Microsoft C++ uses the equivalent inpw() function (which is prototyped in
conio.h).
16.4.3 Outputting A Byte To An I/O Port
The assembly language command to output a byte is:
where DX is the Data Register which contains the address of the output port.
The 8-bit value sent to this address is stored in register AL.
For Turbo/Borland C the equivalent function is outportb(). Its general syntax

is as follows:
where PORTADDRESS is the address of the output port and value is the 8-bit
value to be sent to this address. This function is prototyped in the header file
dos.h.
For Turbo Pascal the equivalent is accessed via the port [] array. Its general
syntax is as follows:
where PORTADDRESS is the address of the output port and value is the 8-bit
value to be sent to that address. To gain access to this function the statement
uses dos requires to be placed near the top of the program.
Microsoft C++ uses the equivalent outp() function (which is prototyped in
conio.h).
16.4.4 Outputting A Word
The assembly language command to input a byte is:
where DX is the Data Register which contains the address of the output port.
The 16-bit value sent to this address is stored in register AX.
For Turbo/Borland C the equivalent function is outport(). Its general syntax
is as follows:
where PORTADDRESS is the address of the output port and value is the 16-bit
value to be sent to that address. This function is prototyped in the header file
dos.h.
For Turbo Pascal the equivalent is accessed via the port [] array. Its general
syntax is as follows:

where PORTADDRESS is the address of the output port and value is the 16-bit
value to be sent to that address. To gain access to this function the statement
uses dos requires to be placed near the top of the program.
Microsoft C++ uses the equivalent outp() function (which is prototyped in
conio.h).
16.5 Digital I/O using the 8255
Each 8255 IC has 24 digital input/output lines. These are grouped into three
groups of 8 bits and are named Port A, Port ? and Port C. A single 8-bit register,
known as the control register, programs the functionality of these ports. Port C
can be split into two halves to give Port C (upper) and Port C (lower). The ports
and the control register map into the input/output memory with an assigned base
address. The arrangement of the port addresses with respect to the base address
is given in Table 16.3.
Table 16.3
PPI addresses
Port address
Function
BASE_ADDRESS
Port A
BASE_ADDRESS+1
Port B
BASE_ADDRESS+2
Port C
BASE_ADDRESS+3
Control register
Figure 16.6 shows the functional layout of the 8255. The control register
programs each of the ports to be an input or an output and also their mode of
operation. There are four main parts which are programmed: Port A, Port B, Port
C (lower) and Port C (upper).

FIGURE 16.6  Layout of PPI
Figure 16.7 shows the definition of the Control Register bits. The msb (most
significant bit) D7 either makes the device active or inactive. If it is set to a 0 it
is inactive, else it will be active. The input/output status of Port A is set by D4. If
it is a 0 then Port A is an output, else it will be an input. The status of Port ? is
set by D1, Port C (lower) by DO and Port C (upper) by D3.
FIGURE 16.7  PPI Control Register Bit Definitions
Port A can operate in one of three modes –0, 1 and 2. These are set by bits D5
and D6. If they are set to 00 then Mode 0 is selected, 01 to Mode 1 and 10 to
Mode 2. Port B can be used in two modes (Mode 0 and 1) and is set by bit D2.
Examples of bit definitions and the mode of operation are given in Table 16.4.

Table 16.4
Example bit patterns for control register
Bit pattern
Mode of operation
01101000
Device is inactive as D7 set to 0
10011000
Mode 0 Port A input, Port C (upper) input, Mode 0 Port B output, Port C (lower) output
10101000
Mode 1 Port A output, Port C (upper) input, Mode 0 Port B output, Port C (lower) output
16.5.1 Mode 0
Mode 0 is the simplest mode with no handshaking. In this mode the bits on Port
C can be programmed as inputs or outputs.
16.5.2 Mode 1
This mode gives handshaking for the synchronization of data. Handshaking is
normally required when one device is faster than another. In a typical
handshaking operation the originator of the data asks the recipient if it is ready to
receive data. If it is not then the recipient sends back a ‘not ready for data’
signal. When it is ready it sends a ‘ready for data’ signal and the originator then
sends the data.
If Ports A and B are inputs then the bits on Port C have the definitions given
in Table 16.5.
Table 16.5
Mode 1 handshaking lines for inputting data
When inputting data, the 
 going low (active) writes data into the port. After
this data is written into the port, the IBF line automatically goes high. This
automatically remains high until the data is read from the port.
If any of the ports are outputs, then the bit definitions of Port C are given in
Table 16.6.
T bl
16 6

Table 16.6
Mode 1 handshaking lines for outputting data
In this mode, when data is written to the port the 
 line goes low, which
indicates that data is ready to be read from the port. The 
 line will not go high
until the 
 is pulled low.
16.5.3 Mode 2
This mode allows bi-directional I/O. The signal lines are given in Table 16.7.
Table 16.7
Mode 2 operation for bi-directional I/O
16.6 Digital I/O programs
Program 16.1 outputs the binary code for 0 to 255 to Port B with a one-second
delay between changes. The program exits when the output reaches 255. A delay
routine has been added which uses the system timer. This will be discussed in
more detail in Section 17.10. Figure 16.8 shows a typical set-up to test the
program where Port ? has been connected to eight light-emitting diodes (LEDs).

FIGURE 16.8  Possible system set-up
In 8086 Assembly Language a macro is defined using the equ statement.
Program 16.1 uses these to define each of the port addresses. This helps to
document the program and makes it easier to make global changes. For example,
a different base address is relatively easy to set up, as a single change to
BASE_ADDRESS automatically updates all port defines in the program. In this case
the base address is 1F0h. This address should be changed to the required base
address of the DIO card.
The statements:
output the value 90h (1001 0000b) to the control register (CNTRLREG). The
statements:
initially set the AL register to 00h. The next two statements (mov dx, PORTB
and out dx, a1) output the value of AL to PORT B. Next the delay routine is
called (with call delay). This routine delays for a period of 1 second. Next the

AL register is incremented (inc a1). After this the AL register value is
compared with 100h (0001 0000 0000b). If the result of the compare statement
is not equal to zero then the program loops back to the loop1: label.
Program 16.2 reads the binary input from Port A and sends it to Port B. It will

stop only when all the input bits on port A are 1s. It shows how a byte can be
read from a port and then outputted to another port. Port A is used, in this
example, as the input and Port ? as the output. Figure 16.9 shows how Port A
could be connected to input switches and Port ? to the light-emitting diodes
(LEDs). Loading the bit pattern 90h into the control register initializes the
correct set-up for Ports A and B.
FIGURE 16.9  Typical system set-up

16.7 Timing
Each instruction takes a finite time to complete. The speed of operation is
determined by the processor clock speed. To find out how long a certain
instruction will take determine the number of clock cycles to execute it and
multiply this by the clock period. For example, if the clock rate is 8 MHz the
clock period is 0.125 μs. The following gives the number of clock cycles for
various instructions. Note that different processors take differing numbers of
clock cycles to execute a command. Notice also that the 80386 processor is
around twice as fast as the 8086 for many of the commands. This is due to
improved architecture.
Table 16.8
Instruction timings for different processors
where (b) – byte divide, (w) – word divide, (nj) – no jump.
For example, the mov ax, 1234 statement takes 0.5 μs assuming a 8 MHz
clock. The following program will output an increment value every two seconds.
Note the great improvement in the 80286/386 over the 8086 on dealing with
mathematics operations. In the 8086 it takes 144 clock cycles to perform a word
divide while the 80386 only takes 22 clock cycles (nearly seven times faster).

Within the second (inner) loop:
will be executed 64777 times. The number of cycles to do a dec and a jnz is
3+16 cycles. Thus it takes 19 cycles to complete this loop. The total time to
complete this inner loop is thus: Number of cycles × clock period = 19 × 0.125
μs = 2.375 μs.
Total time to complete this loop is 64 777 × 2.375 μs = 0.1538 s.
This inner loop is executed 7 times, thus the total delay time is 13 × 0.1538 =
2 s.
In general, for a general purpose loop with A and B as the variables in AX and
BX, then:
First the inner loop:

Then the number of cycles for inner loop will be B× 19:
Number of cycles = A × ((B × 19)+ 16 + 3)
If 19 × B is much greater than 19 then the following approximation can be
made:
Thus:
For example, in the last example (assuming a 4 MHz clock) the value of A is
13 and B is 64777, thus: 
Typical processor clocks are:
8086
4.77 MHz, 8 MHz.
386
16 MHz, 25 MHz, 33 MHz.
486
33 MHz, 50 MHz, 66 MHz, 100 MHz.
Pentium
60 MHz, 90 MHz, 120 MHz, 200 MHz.
16.8 Exercises
16.8.1. Write a program to input a byte from Port A.
16.8.2. Write a program which will send to Port B all 1’s.
16.8.3. Write a program which will read a byte from Port A. This byte is then
sent to Port B.
16.8.4. Write a program that sends a ‘walking-ones’ code to Port B. The delay

between changes should be one second. A ‘walking-ones’ code is as
follows:
   Hint: Use the shift left operator, that is << or sh1.
16.8.5. Write separate programs which output the patterns in (a) and (b). The
sequences are as follows:
   
16.8.6. Write separate programs which output the following sequences:

(e) The inverse of (d) above.
16.8.7. Write a program that reads a byte from Port A and sends the 1s
complement representation to Port B. Note that 1s complement is all bits
inverted.
16.8.8. Change the program in Exercise 16.8.9 so that it gives the 2s complement
value on Port B. Hint: Either complement all the bits of the value and add
1 or send the negated value.
16.8.9. Write a program which will count from 00h to ffh with 1s delay between
each count. The output should go to Port B.
16.8.10. Write a program which will sample Port A every 1s then sends it to Port
B.
16.8.11. Write a program which will simulate the following logic functions.
   
   where PA0 is bit 0 of Port A, PA1 is bit 1 of Port A and PB0 is bit 0 of Port B.
16.8.12. Write a program which will simulate a traffic light sequence. The delay
between changes should be approximately 1 second.

   and the sequence is:
16.8.13. Modify the program in 16.8.12 so that the sequence is:
16.8.14. Write a program which will input a value from Port A. This value is
sent to Port B and the bits are rotated with a delay of 1 second.
16.8.15. Write a program which will sample port A when bit 0 of Port C is
changed from a 0 to a 1. Values are then entered via Port A by switching
PC0 from a 0 to a 1. These values are put into memory starting from
address 100h. The end of the input session is given by PC1 being set (ie
PC1 is equal to a 1). When this is set all the input values are sent to Port
B with a 2 s interval.

17
8086 Interrupts
17.1 Interrupts (INT)
The interrupt function (INT) interrupts the processor. It can be used to gain
access to either DOS or BIOS functions. BIOS functions are typically used to
gain access to the hardware, whereas DOS functions are used to quit from
programs, read a character from the keyboard and write a character to the screen.
FIGURE 17.2  Bit definitions for serial port initialization
17.2 Interrupt 21h: DOS services
Programs access DOS functions using interrupt 21h. The functionality of the
call is set by the contents of the AH register. Other registers are used either to
pass extra information to the function or to return values back. For example, to
determine the system time the AH is loaded with the value 2AH. Next, the
processor is interrupted with interrupt 21H. Finally, when the program returns
from this interrupt the CX register will contain the year, DH the month, DL the day
and AL the day of the week.

Table 17.1 is only a small section of all the DOS related interrupts. For
example, function 2Fh contains many functions that control the printer. Note that
for the Get free disk space function the total free space on a drive is
AX×BX×CX and total space on disk, in bytes, is AX×CX×DX.
Table 17.1
DOS interrupts

In Program 17.1, function 02h (write character to the output) is used to display
the character ‘A’. In this case, the function number 02h is loaded into AH and the
character to be displayed is loaded into DL.

Program 17.2 uses the function 01h to get a character from the keyboard and
then the function 02h to display it.
Program 17.3 displays the default boot drive. In most cases the default boot
drive will be C.
17.3 Interrupt 10h: BIOS video mode
Interrupt 10h allows access to the video display. Table 17.2 outlines typical
interrupt calls. Program 17.4 uses the BIOS video interrupt to display a border
around the screen which changes colour each second from black to light blue.

These colours are set-up with an enum data type definition. In this case, BLACK is
defined as 0, BLUE as 1, and so on.
Table 17.2
BIOS video interrupt
To display a border the AH register is loaded with 0Bh, BH with 00h and BL
with the border colour. Next, the interrupt 10h is called with these parameters.
Figure 17.1 shows the bit definition for the colours.

FIGURE 17.1  Character attribute

17.4 Interrupt 11h: BIOS equipment check
Interrupt 11h returns a word which gives a basic indication of the types of
equipment connected. It is useful in determining if there is a math coprocessor
present and the number of parallel and serial ports connected. Table 17.3 shows
the format of the call.
Table 17.3
BIOS equipment check interrupt
Description
Input registers
Output registers
Get equipment list
 
AX = BIOS equipment list word
17.5 Interrupt 13h: BIOS disk access
Interrupt 13h allows access to many disk operations. Table 17.4 lists two typical
interrupt calls.
Table 17.4
BIOS disk access interrupt
17.6 Interrupt 14h: BIOS serial communications
BIOS interrupt 14h can be used to transmit and receive characters using RS-232
and also to determine the status of the serial port. Table 17.5 lists the main
interrupt calls. Program 17.5 initializes COM2: with 4800 baud, even parity, 1 stop
bit and 7 data bits.
Table 17 5

Table 17.5
BIOS serial communications interrupts
17.7 Interrupt 17h: BIOS printer
The BIOS printer interrupt allows a program either to get the status of the printer
or to write a character to it. Table 17.7 outlines the interrupt calls.
Table 17.7
BIOS printer interrupt

17.8 Interrupt 16h: BIOS keyboard
Interrupt 16h allows access to the keyboard. Program 17.6 uses the BIOS
keyboard interrupt to display characters, entered from the keyboard, to the
screen. Initially, the code:
tests to see if a key has been pressed. It repeats until the zero flag is unset (this
happens when a key has been pressed. The check for keystroke interrupt call sets
the zero flag (ZF) if there are no characters in the buffer, otherwise it will be a 0.

Next the code:
gets the key that has been pressed and puts the result into the DL register.
Finally, the DOS interrupt is used to display the character to the screen.
Table 17.6
BlOSkeyboard interrupt

17.9 Interrupt 19h: BIOS reboot
Interrupt 19h reboots the system without clearing memory or restoring interrupt
vectors. For a warm boot, equivalent to Ctrl-Alt-Del, then 1234h should be
stored at 0040h:0072h. For a cold boot, equivalent to a reset, then 0000h is
stored at 0040h:0072h. Care should be taken with this interrupt as it may cause
the PC to ‘hang’.
17.10 Interrupt 1Ah: BIOS system time
The BIOS system time interrupt allows a program to get access to the system
timer. Table 17.8 outlines the interrupt calls.
Table 17.8
BIOS system time interrupt
17.11 C and Pascal interrupts

See Section D.3.
17.12 Exercises
17.11.1. Using BIOS video interrupt 10h write programs which perform the
following:
(a) fill a complete screen with the character ‘A’ of a text colour of red
with a background of blue; (b) repeat (a), but the character
displayed should cycle from ‘A’ to ‘Z’ with a one-second delay
between outputs; (c) repeat (a), but the foreground colour should
cycle through all available colours with a one-second delay
between outputs; (d) repeat (a) so that the background colour
cycles through all available colours with a one-second delay
between outputs.
17.11.2. Using BIOS keyboard interrupt 16h write a program, in C or Pascal,
that displays the status of the Shift, Caps lock, Cntrl, Scroll and Num
keys.

PART D
Visual Basic

18
Introduction
18.1 Introduction
Microsoft Windows has become the de-facto PC operating system. All versions
up to, and including, Windows 3.11 used DOS as the core operating system.
New versions of Windows, such as Windows NT and Windows 95 do not use
DOS and can thus use the full capabilities of memory and of the processor. The
most popular programming languages for Windows programming are:
• Microsoft Visual Basic.
• Microsoft Visual C++ and Borland C++.
• Delphi (which is available from Borland).
Visual Basic has the advantage over the other language in that it is relatively
easy to use and to program with, although the development packages which are
used with C++ and Delphi make constructing the user interface relatively easy.
Visual Basic Version 4 is shown in Figure 18.1 and Version 5 is shown in Figure
18.2.

FIGURE 18.1  Visual Basic 4 user interface
FIGURE 18.2  Visual Basic 5 user interface

18.2 Event-driven programming
Traditional methods of programming involve writing a program which flows
from one part to the next in a linear manner. Most programs are designed using a
top-down structured design, where the task is split into a number of submodules,
these are then called when they are required. This means that it is relatively
difficult to interrupt the operation of a certain part of a program to do another
activity, such as updating the graphics display.
Visual Basic in general is:
• Object-oriented. Where the program is designed around a number of ready-
made objects.
• Event-driven. Where the execution of a program is not predefined and its
execution is triggered by events, such as a mouse click, a keyboard press,
and so on.
• Designed from the user interface outwards. The program is typically
designed by first developing the user interface and then coded to respond
to events within the interface.
18.3 Visual Basic files
A listing of a sample directory which contains Visual Basic files is:
The files are:
• Project files. Projects bind together the individual elements of a Visual Basic
program. Initially the user creates a project file for the program and this is
loaded whenever the program is being developed. The default extension
for a project is either .MAK or .VBP extension. Projects generally make it
easier to control the various elements of a program.
• Modules. Code that is attached to a form is accessible from anywhere on that
form, but a program may have more than one form. It will sometimes be
necessary to have program code that can be reached from any form, and
in this case the code would be written on a module. Modules disappear
from view when the program runs – only forms have an on-screen

existence. There may be several modules in one program, and each is
saved as a separate file. These are marked by a .BAS extension.
• Forms. A form forms the anchor for all parts of a Visual Basic program.
Initially it is a blank window and the user pastes controls onto it to create
the required user interface. Code is then associated with events on the
form, such as responding to a button press or a slider control, although
some control elements do not have associated code. A program can have
one or more forms, each of which displays and handles data in different
ways. To make forms shareable with other programs then each is saved
separately with a .FRM extension.
• Icons. These are, normally, small graphics images and have a .ICO extension.
• Graphics images. These are normally either BMP (bitmapped) files or WMF
(windows metafile) files with the .BMP and .WMF extensions, respectively.
• Others. Other files also exist, such as VBX which is Visual Basic eXtension.
18.4 Other terms
Visual Basic uses a number of other terms to describe design procedure, these
are:
• Controls. The VB interface contains a window with control objects which are
pasted onto a form. These controls can be simple text, menus, spreadsheet
grids, radio buttons, and so on. Each control has a set of properties that
defines their operation, such as their colour, the font size, whether it can
be resized, and so on. Some controls, such as command buttons, menus,
and so on, normally have code attached to them, but simple controls, such
as text and a graphics image can simply exist on a form with no
associated code.
• Procedures. As with C and Pascal, Visual Basic uses procedures, or
subroutines, to structure code. Most of these are associated with an event
that occurs from a control and some will be free-alone with no associated
event.
18.5 Main screen
Figure 18.3 shows the Visual Basic 4 desktop (Visual Basic 5 is similar, but the
windows do not float on the display). It contains a menu form, controls, main
form, project windows and properties window.

FIGURE 18.3  Visual Basic 4 desktop
18.5.1 Menu Bar And Toolbar
The menu bar and tool bar appear in a single, floating window, as shown in
Figure 18.4. The menu bar contains options for file manipulation (File), editing
(Edit), viewing (View), running (Run), testing the program (Debug),
manipulating windows (Window) and getting help (Help). These can either be
selected with the mouse, using the function key F10 and then selecting the
option with the arrow keys and pressing return or use the hot-key. The hot key is
Alt and the underlined character, thus Alt-F selects the File menu, Alt-E selects
the Edit menu, and so on.
FIGURE 18.4  Visual Basic 4 menu bar and toolbar
The toolbar contains shortcut buttons for commonly used menu items. To the

right of the toolbar there are two indicators; these display the position and size of
a selected form or control. This area of the window is also used in the
compilation phase to display the status of the compilation.
The toolbar buttons are:
 Creates a new form.
 Creates a new standard module.
 Opens an existing project.
 Saves the currently active project.
 Locks/unlocks the controls on the active form.
 Displays the Menu Editor.
 Displays the Properties window.
 Displays the Object Browser.
 Displays the Project window.
 Runs the application.
 Pauses program execution.
 Stops execution.
 Toggles a breakpoint (breakpoint on or off).
 Displays the value of the current selection in the Code window.
 Displays the structure of active calls.
 Traces through each line of code and steps into procedures.
 Executes code one procedure or statement at a time in the Code window.
18.5.2 Project Window
The Project window displays all the forms and modules used in the currently
active project; an example is shown in Figure 18.5. A new project is opened by
selecting New Project from the File menu, whereas to open an existing project
the Open Project option is selected from the File menu, else the open existing
project option is selected from the toolbar.

FIGURE 18.5  Visual Basic Project window
Only one project can be opened at a time, but that project can have any
number of forms. In the Project window the user can do the following:
• Open a Form window for an existing form by selecting the form name and
clicking the View Form button.
• Open the Code window for an existing form by selecting the module name
and clicking the View Code button.
• Remove a file from a project by selecting the file in the Project window, and
then from the File menu choose Remove File.
18.5.3 Form Window
The Form window, as shown in Figure 18.6, creates application windows and
dialog boxes. A new form is created by selecting the Form from the Insert menu
(or use the toolbar shortcut) and an existing form is opened by selecting the form
name and then clicking the View Form button. An existing form is added to a
project by selecting the Add File command from the File menu. Any associated
code on a form can be viewed by clicking on the View Code button.

FIGURE 18.6  Visual Basic Form window
Each form has a Control-menu box, Minimize and Maximize buttons, and a
title bar, and can be moved and resized. Table 18.1 shows the key combinations
in the Form window.
Table 18.1
Key combination in Form window
Key combination
Operation
alpha
Enter a value in the Properties window for the selected property.
CLICK–Drag
Select multiple controls.
CTRL+CLICK+ DRAG
Add or remove controls from the current selection.
CTRL–C
Copy the selected controls to the Clipboard.
CTRL-CLICK
Add or remove a control from the selection.
CTRL–E
Display the Menu Editor.
CTRL–J
Bring control to front (if controls are overlapping).
CTRL–K
Send control to back (if controls are overlapping).
CTRL–V
Paste from Clipboard onto the form.
CTRL–X
Cut the selected controls to the Clipboard.
CTRL–Z
Undo a deleted control.
DEL
Delete the selected controls.
F4
Display the Properties window
F7
Open the Code window for the selected object.
SHIFT–CTRL– alpha
Select a property in the Property list of the Properties window.
SHIFT-TAB
Cycle backward through controls in tab order.
TAB
Cycle forward through controls in tab order.
18.5.4 Toolbox
The Toolbox contains the icons for controls. These are standard Visual Basic
controls and any custom controls and insertable objects, as shown in Figure 18.7.
The Toolbox is displayed, if it is not already in view, with Toolbox from the
View menu and it is closed by double-clicking the Control-menu box.

FIGURE 18.7  Toolbox controls
Figure 18.6 shows some typical controls, these include:
• 
Pointer. The pointer does not draw any control objects and is used to
resize or move a control once it has been drawn on a form. When a
control is added to a form then the pointer is automatically selected.
• 
PictureBox. Displays graphical images (BMP, WMF, ICO or DIB).
• 
Label. Used to display text that cannot be changed by the user.
• 
TextBox. Allows the user to either enter or change text.
• 
Frame. Used to create a graphical or functional grouping for controls.
These are grouped by first drawing a Frame around them and then
drawing controls inside the frame.
• 
CommandButton. Used to carry out a command.

• 
CheckBox. Used to create a check box, where the user can indicate if
something is on or off (true or false), or, when there is more than one
option, a multiple of choices.
• 
OptionButton. Used to display a number of options but only one can be
chosen (this differs from the check box which only allows one option to
be chosen).
• 
ComboBox. Used to give a combination of a list box and test box, where
the user can either enter a value in a text box or choose an item from the
list.
• 
ListBox. Used to display a list of items and the user is allowed to choose
one of them. This list has a scroll button to allow the list to be scrolled.
• 
HScrollBar (horizontal scroll bar). Used to scroll up and down through a
list of text or graphical information. It can also be used to indicate the
current position on a scale or by the user to indicate a given strength of
value.
• 
VScrollBar (vertical scroll bar). Used to scroll across a list of text or
graphical information. It can also be used to indicate the current position
on a scale or by the user to indicate a given strength of value.
• 
Timer. Used to generate timed events at given intervals.
• 
DriveListBox. Used to display currently connected disk drives.
• 
DirListBox (directory list box). Used to display directories and paths.
• 
FileListBox. Used to display a list of files.
• 
Shape. Used to draw shapes, such as rectangles, rounded rectangles,
squares, rounded squares, ovals or circles.
• 
Line. Used to draw a variety of line styles on your form at design time
(transparent, solid, dash, dot, dash-dot and dash-dot-dot).
• 
Image. Used to display a graphical image, such as a bitmap (BMP), icon
(ICO), or metafile (WMF). These images can only be used to display and
image and do not have the same control functions as PictureBox.
• 
Data. Used to provide access to data in databases.

• 
OLE Controller. Used to link and embed objects from other applications
(such as Word Documents, Excell Spreadsheets, and so on). OLE stands
for Object Linking and Embedding.
• 
CommonDialog. Used to create customized dialog boxes for operations
such as printing files, opening and saving files, setting fonts and help
functions.
• 
DBList (data-bound list box). Used as an enhanced ListBox which can be
customized to display a list of items from which the user can choose one.
The list can be scrolled if it has more items than can be displayed at one
time.
• 
DBCombo (data-bound combo box). Used as an enhanced Combo which
can be customized to display a list of items from which the user can
choose one. Use to draw a combination list box and text box. The user
can either choose an item from the list or enter a value in the text box.
• 
DBGrid (data-bound grid). Use to display a series of rows and columns
and to manipulate the data in its cells. DBGrid is a custom control and
has increased data access capabilities that the standard Grid does not
have.
18.6 Properties window
The Properties window displays the properties of the currently selected form,
control or menu. They allow properties such as the colour, font type and size of
text, background colour of a form, type of graphic image, and so on.
First, the item to be changed is selected and then the Properties option is
chosen from the View menu, else the function key F4. The Property window is
closed with a double-click on the Control-menu box.
The Properties window contains two main parts, these are:
• The Object box. This is found below the title bar and identifies the currently
selected form or control on the form. In Figure 18.8 the command button
has an associated Properties window. The Object box in this case is:

FIGURE 18.8  Properties window
    Where CommandButton is the control item and is named Command1, other
control items are PictureBox, Label, TextBox, Frame, CheckBox,
OptionButton, ComboBox, ListBox, HScrollBar, VScrollBar, Timer,
DriveListBox, FileListBox, Shape, Line, Image, Data, and so on. Click
the arrow at the right side of the Object box (
) to get a list of the
controls on the current form. From the list, choose the current form or a
control on the form whose properties you want to change. An example is
given in Figure 18.9. In this case there are three command buttons
(named Command1, Command2 and Command3) on the form, a drive
list box (named Drive1), and so on. The list also contains the currently
active form (in this case it is named Form1). Names of controls are
assigned consecutively, so that the first command button is Command1,
the second is Command2, and so on.

FIGURE 18.9  Example list of controls
• The Properties list. This is a two-column list that shows all properties
associated with a form or control and their current settings. To change a
properties setting then the properties name is selected and the new setting
is either typed or selected from a menu. Properties that have predefined
settings (such as a range of colours or true/false) display the list of
settings by clicking the down arrow at the right of the settings box (
),
or they can be cycled through by double-clicking the property name in
the left column. In Figure 18.8 the Default property has either a True or
False setting. A 
 in the second column indicates either the selection of
colours from a palette or the selection of picture files through a dialog
box.
Figure 18.10 shows an example of colour settings. Note that the colour
appears as a 24-bit hexadecimal equivalent (with 8 other attribute bits), but when
the user selects the colour it appears as a colour in the palette. This 24-bit colour
is made up to red, green and blue (RGB). The standard format is:

FIGURE 18.10  Setting colour
The RR hexadecimal digits give the strength of the red from 00h to FFh (0 to
255), the GG hexadecimal digits give the strength of green and BB gives the
strength of blue. Thus for the colour strength parts: white is &HaaFFFFFF&,
black is &?aa000000&, red is &Haa0000FF&, yellow is &Haa00FFFF& and
cyan is &HaaFFFF00&.
18.7 Controls and Event
Controls have associated properties and also a number of events. These events
can be viewed by double clicking on a control or by selecting View Code from
Project window. Figure 18.11 shows an example of the Code windows. It can be
that the object can be selected by pulling down the menu of the left-hand side
and the associated events in the right-hand menu. The associated code with that
object and event is shown in the window below these menu options.

FIGURE 18.11  Selecting objects
Figure 18.12 shows an example of the events that occur when the control is a
command button (in this case the object is Command1). It can be seen that the
associated events are: Click, DragDrop, DragOver, GotFocus, KeyDown,
KeyPress and KeyUp. Each of these can have associated sections of code to
react to the event. For example, the Click event is initiated when the user clicks
the mouse button on the command button and KeyDown is initiated when a key
has been pressed down.
FIGURE 18.12  Events when the control is a command button
18.8 Exercises
18.8.1. Place a CommandButton on a form and display its properties. Note all of
the properties and, with the help of the help manual, identify of the
function of each of the properties. Note that help on a property can be

found by highlighting the property and pressing F1.
18.8.2. With a CommandButton identify the events that are associated with it.
18.8.3. Determine the actual colours of the following RGB colour values:
(i) &H0080FF80&
(ii) &H00FF8080&
(ii) &H00C000C0&
(iv) &H00E0E0E0&
18.8.4. Conduct the following:
(i) Add a command button to a form.
(ii) Change the text on the CommandButton to ‘EXIT’.
(iii) Change the font on the CommandButton to ‘Times Roman’ and the
font size to 16.
(iv) Resize the CommandButton so that the text fits comfortably into the
button.
(iv) Change the background colour of the form to yellow.
(v) Change the Caption name of the form to ‘My Application’.
18.8.5. Develop the form given in Figure 18.13.
FIGURE 18.13  Exercise
18.8.6. Explain why, in the previous exercise, that a radio button is used for the
age option and a check box is used to select the choices of Show
Graphics and Play Sounds. Which of the following would be radio
buttons or check boxes:
(i) Items on a shopping list.
(ii) Selection of a horse to win a race.

(iii) Selection of paint colour on a new car.
(iv) Selection of several modules on a course.

19
Visual Basic Language
19.1 Introduction
This chapter discusses the Visual Basic language and how a program is
developed.

FIGURE 19.4  Buttons for MsgBox

FIGURE 19.5  Icons for MsgBox
19.2 Programming language
Visual Basic has an excellent on-line manual in which the user can either search
for the occurrence of keywords (with Help → Search For Help On) or view the
contents of the manual (Help → Contents). The left-hand side of Figure 19.1
shows an example manual page after the user has selected Help → Contents →
Visual Basic Help, and then leads to other parts of the manual, such as the
Programming Language and Contents Topic. The left-hand side of Figure 19.1
shows an example of the Contents list.

FIGURE 19.1  Visual Basic 4 on-line help manual
19.3 Entering a program
To start the development of a program with no controls on a form then the user
selects the View Code from the Project window. Figure 19.2 shows the basic
steps. After the View Code is selected then the user selects the Form object from
within the form code window. Next the code is entered between the Private
Sub Load_From() and End Sub. This code is automatically run when the form is
run, as the procedure is Load. The code in Figure 19.2 simply displays the text
“Hello to you” to a window.

FIGURE 19.2  Steps taken to enter code
19.4 Language reference
This section contains a condensed reference to Visual Basic.
19.4.1 Data Types And Declaring Variables
A variable is declared with the Dim keyword. These variables must conform to

the following:
• Begin with an alphabet character.
• Cannot contain a dot, ‘$’, T, ‘@’, ‘#’ or ‘%’.
• Must be less than 256 characters long.
Examples are:
which declares a Boolean variable called val1, two single precision floating-
point variables: x and y, an integer named i, a date named newdate and a string
of 30 characters named name.
Variables are assigned values with the assignment operation (=), such as:
which sets the Boolean variable val1 to a True, the value of x to 2.134, y to
10.1, the date newdate is assigned the current date from the function Now and
the string name is assigned the string “Fred”. Note that strings of characters are
defined between inverted commas (“ ”).
19.4.2 Operators
The basic operators in Visual Basic are similar to the ones used in Pascal. Table
19.1 shows the main operators. The operator precedence is:
Table 19.1
Operator precedence
Arithmetic
Comparison
Logical
Exponentiation (^)
Equality (=)
Not
Negation (−)
Inequality (<>)

Negation ( )
Inequality (<>)
And
Multiplication and division (*,/)
Less than (<)
Or
Integer division (\)
Greater than (>)
Xor
Modulo arithmetic (Mod)
Less than or Equal to (<=)
 
Addition and subtraction (+,–)
Greater than or Equal to (>=)
 
String concatenation (&)
 
 
• Arithmetic operators have the highest precedence, followed by comparison
operators and finally logical operators.
• Arithmetic and logical operators are evaluated in the order given in Table
19.1.
• Comparison operators all have equal precedence.
• Multiplication and division have the same precedence, then the operation is
executed from left to right. The same occurs with addition and
subtraction.
19.4.3 Data Types
As with C and Pascal, Visual Basic has a whole range of data types. Their range
depends on their format (such as characters, integers and floating point values)
and the number of bytes used to store them. Table 19.2 outlines the main
predefined (intrinsic) data types. A user defined type can also be defined using
the Type statement.
Table 19.2
Data types
Data type
Storage size
Range
Byte
1 byte
0 to 255
Boolean
2 bytes
True or False
Integer
2 bytes
−32,768 to 32,767
Long (long integer)
4 bytes
−2,147,483,648 to 2,147,483,647
Single (single-precision floating-
point)
4 bytes
±3.402823×1038 to ± 1.401298×10−45
Double (double-precision floating-
point)
8 bytes
±4.94065645841247×10−324 to
±1.79769313486232×10308
Currency (scaled integer)
8 bytes
±922,337,203,685,477.5808
Date
8 bytes
January 1, 100 to December 31, 9999.
String (variable-length)
10 bytes +string
0 to approximately 2 billion

length
String (fixed-length)
Length of string
1 to approximately 65,400
The main data types are:

19.4.4 Convert Between Data Types
Visual Basic has strong data type checking where the compiler generates an
error when one data type is assigned directly to a variable with another data type.
Thus different data types may need to be converted into another type so that they
can be used. The basic conversion functions are:
Cbool(expr)
Which converts an expression into Boolean. The expression argument is any
valid numeric or string expression. If expression is zero then a False is
returned, else a True is returned.

Cbyte(expr)
Which converts an expression into Byte. The expression argument is any valid
numeric or string expression. If expression lies outside the acceptable range
for the Byte data type then an error occurs.
Ccur(expr)
Which converts an expression into Currency. The expression argument is any
valid numeric or string expression. If expression lies outside the acceptable
range for the Currency data type then an error occurs.
Cdate(expr)
Which converts an expression into Date. The date argument is any valid date
expression.
Cdbl(expr)
Which converts an expression into Double. The expression argument is any valid
numeric or string expression.
Cint(expr)
Converts an expression to an Integer. The expression argument is any valid
numeric or string expression. Cint differs from the Fix and Int functions, which
truncate, rather than round, the fractional part of a number. When the
fractional part is exactly 0.5, the Cint function always rounds it to the nearest
even number. For example, 0.5 rounds to 0, and 1.5 rounds to 2.
Clng(expr)
Which converts an expression into Long. The expression argument is any valid
numeric or string expression. As with Cint the value is rounded to the nearest
whole number.
Csng(expr)
Which converts an expression into Single. The expression argument is any valid
numeric or string expression. If expression lies outside the acceptable range
for the Single data type, an error occurs.
Cstr(expr)
Which converts an expression into string. The expression argument is any valid
numeric or string expression. If the expression is Boolean then a string is
returned with either True or False, else a numeric value returns a string
containing the number.
lnt(expr)
 
Fix(expr)
Returns the integer portion of a number. Int differs from Fix in that Int when the
number is negative then it returns the first negative integer which is less than
or equal to number, whereas Fix returns the first negative integer greater than
or equal to number. For example, if the value is –12.3 then Int converts this to
–13 while Fix converts it to –12.
A typical conversion is from a numeric or date variable into a string format.
Program 19.1 shows an example of a Visual Basic program which contains the
CStr function which is used to convert from two floating point values (x and y),
an integer (i) and date (newdate) into a string format. This is then used to
display the values to a window using the MsgBox function. The program also
uses the Fix function to round-up the value of x. Figure 19.3 shows a sample
run.

FIGURE 19.3  Sample run for Program 19.1
19.4.5 Input/Output
The functions that can be used to input and output information are InputBox and
MsgBox, respectively. Both these functions input and output information in the
form of a string of characters. Thus when outputing non-string variables, such as
integers and floating-point values, they must first be converted to a string using
one of the string conversion functions. The same must be done for input, where
the input string must be converted into the required data type, again using the
data type conversion functions.
Output

The MsgBox function displays a message in a dialog box with specified buttons
and then waits for the user to select a button. The value returned indicates the
chosen button. The basic format is:
where the parameters in brackets are optional. The parameters are:
prompt
string of be displayed in the dialog box.
buttons
Numeric value that is the sum of values that specifies the number, the type of buttons to display, the
icon style and the default button. Table 19.3 outlines these values and if it is omitted then the
default value for buttons is 0.
title
string which contains the title bar of the dialog box. If it is omitted then the application name is placed
in the title bar.
helpfile
string that identifies the Help file to use to provide context-sensitive Help for the dialog box. If helpfile
is provided then context must also be provided.
context
Numeric value that is the Help context number the Help author assigned to the appropriate Help
topic. If context is provided, helpfile must also be provided. When both helpfile and context are
provided, the user can press F1 to view the Help topic corresponding to the context.
Table 19.1 defines the button settings. The values from 0 to 5 define the type
of the button to be displayed. For example, a value of 5 will have two buttons,
which are Retry and Cancel. The values 16, 32, 48 and 64 identify the icon to be
displayed. For example, a value of 32 will display a question bubble. The 0, 256
and 512 define which button is the default. Each of these values can be added
together to create the requires set of buttons, icon and default button. For
example, to create a dialog box with the OK and Cancel buttons, a Critical icon
and the Cancel button to be the default, then the setting would be:
Table 19.3
Button settings
Constant
Value
Description
vbOKOnly
0
Display OK button only
vbOKCancel
1
Display OK and Cancel buttons. See example 1 in Figure 19.4.
vbAbortRetryIgnore
2
Display Abort, Retry, and Ignore buttons. See example 2 in Figure 19.4.
vbYesNoCancel
3
Display Yes, No, and Cancel buttons. See example 3 in Figure 19.4.
vbYesNo
4
Display Yes and No buttons. See example 4 in Figure 19.4.
vbRetryCancel
5
Display Retry and Cancel buttons. See example 5 in Figure 19.4.
16

vbCritical
16
Display Critical Message icon. See example 1 in Figure 19.5.
vbQuestion
32
Display Warning Query icon. See example 2 in Figure 19.5.
vbExclamation
48
Display Warning Message icon. See example 3 in Figure 19.5.
vbInformation
64
Display Information Message icon. See example 4 in Figure 19.5.
vbDefaultButton1
0
First button is default
vbDefaultButton2
256
Second button is default
vbDefaultButton3
512
Third button is default
which is 273. Note that to aid documentation in the program then the
predefined constant values can be used, so for the previous example:
The MsgBox function returns a value depending on the button pressed; these
return values are outlined in Table 19.4. For example, if the user presses the OK
button then the return value will be 1. If the dialog box has a Cancel button then
the user pressing ESC has the same effect as choosing Cancel. If the dialog box
contains a Help button, context-sensitive Help is provided for the dialog box.
However, no value is returned until one of the other buttons is chosen.
Table 19.4
MsgBox return values
Constant
Value
Button chosen
vbOK
1
OK
vbCancel
2
Cancel
vbAbort
3
Abort
vbRetry
4
Retry
vblgnore
5
Ignore
vbYes
6
Yes
vbNo
7
No
Program 19.2 gives an example of a program which displays a dialog box with
Yes and No buttons, and a question mark icon. The response will thus either be a
6 (if the Yes button is selected) or a 7 (if the No button is selected). Figure 19.6

shows a sample run.
FIGURE 19.6  Example run
Input
The InputBox function prompts the user to input text, or choose a button. It then
returns the contents of the text box. The basic format is:
where the parameters in brackets are optional. The parameters are:
prompt
string of be displayed in the dialog box.
title
string which contains the title bar of the dialog box. If it is omitted then the application name is placed

in the title bar.
default
string which is displayed in the text box and is the default response if no other input is provided. If
this field is omitted then the text box is initially empty.
xpos
Numeric value that specifies (in twips) the horizontal distance of the left edge of the dialog box from
the left edge of the screen. If xpos is omitted then the dialog box is horizontally centred.
ypos
Numeric value that specifies (in twips) the vertical distance of the upper edge of the dialog box from
the top of the screen. If ypos is omitted then the dialog box is vertically positioned approximately
one-third of the way down the screen.
helpfile
string that identifies the Help file to use to provide context-sensitive Help for the dialog box. If helpfile
is provided then context must also be provided.
context
Numeric value that is the Help context number the Help author assigned to the appropriate Help
topic. If context is provided, helpfile must also be provided. When both helpfile and context are
provided, the user can press F1 to view the Help topic corresponding to the context.
Program 19.3 shows an example usage of the InputBox function. In this case
the message for the title is ‘Input demonstration’, the default value is ‘10’ and
the value is return into the inval variable.
FIGURE 19.7  Example run

19.4.6 Decisions And Loops
The decisions and loops in Visual Basic are similar to the ones used in C and
Pascal.
If statement
The basic if statement format is:
or, in general:
Where the condition can be a numeric or string expression that evaluates to
True or False. The statement block contains one or more statements separated by
colons.
As with C and Pascal, if the first condition is True then the first statement
block is executed, else if the second condition is True then the second statement
block is executed, and so on. If none of the conditions are True then the final
else statement block is executed (if it exists).
Note that Else and ElseIf are both optional and there can be any number of
Elself clauses but none of them can occur after the Else clause Program 19.4
gives an example of a program in which the user enters a value from 0 to 2 and
the program displays the equivalent resistor colour code colour.

Case
The Case statement is similar to the case and switch statements used in Pascal
and C. Its general form is:
The expression can be any numeric or string expression. A match of the
expression to the expression value causes the corresponding statement block to
be executed. If none of the block match then the Case Else statement block is
executed. If testexpression matches any expressionlist expression associated
with a Case clause, the statements following that Case clause are executed up to
the next Case clause, or, for the last clause, up to the End Select. Control then
passes to the statement following End Select. If testexpression matches an
expressionlist expression in more than one Case clause, only the statements
following the first match are executed.
Multiple expressions or ranges can be added to the Case cause, such as:

It is also possible to specify ranges and multiple expressions for strings. For
example the following matches the string to ‘apple’ and everything,
alphabetically between, ‘banana’ and ‘carrot’:
Program 19.5 shows an example of a program which is similar to Program
19.4 but uses a case statement to select the resistor colour code colour.
For loop
The For loop is similar to the for loop in Pascal. It repeats a group of statements
a number of times. Its general form is:
or

Where counter is a numeric variable which as used a loop counter, start is the
Initial value of counter, end is the final value of counter and step is the amount
by which the count is changed for each loop. This value can either be positive or
negative. The default step size, if not specified is 1.
Program 19.6 uses a for loop to calculate the factorial value of an entered
value.
FIGURE 19.8  Example run
Do..while loop
The Do..while loop is similar to the while() statements used in Pascal and C. Its
general form is:

or
or
or
Program 19.7 uses a do..while loop to test to see if the user input is within a
valid range. In this case the valid input is between 0 and 10 for the voltage input
and greater than 0 and up to 10 for the current input. If the user enters a value
which is outside this range then a MsgBox is displayed with an error message
(INVALID: re-enter).

19.5 Exercises
19.5.1. Complete Program 19.5 so that it implements the complete resistor
colour code (see Table 6.1 on page 117).
19.5.2. Change the program in 19.5.1 so that it loops until the user enters a valid
value (between 0 and 9).
19.5.3. Change the program in 19.5.2 so that after the result has been displayed
the user is prompted as to whether to repeat the program (OK) or exit the
program (Cancel).
19.5.4. Write a program which will continually display the current date and time.
The sample code given below displays a single date and time.
19.5.5. Modify the program in Exercise 19.5.4 so that the OK and Cancel
buttons are shown. If the user selects the Cancel button then the program
should exit, else the program should display the new date. The sample

code given below displays a single date and time with the OK and Cancel
buttons.
19.5.6. Complete Worksheet 2 on page 37 using Visual Basic. Note that for
W2.2 the square root function in Visual Basic is sqr, and in W2.3 the
inverse tangent function is atn.

20
Forms
20.1 Introduction
This chapter discusses how forms are constructed and how code is associated
with the form.
20.2 Setting properties
Each control object has a set of properties associated with it. For example, the
TextBox control in Figure 20.1 has an object name of Text 1. This object has a
number of associated properties, such as Alignment, Appearance, BackColor,
and so on. These properties can be changed within the program by using the dot
notation. For example, to change the font to ‘Courier New’, the text displayed in
the object to ‘Hello’ and the height of the window to 1000 the following can be
used:
FIGURE 20.1  Object properties

20.3 Forms and code
Visual Basic programs are normally designed by first defining the user interface
(the form) and writing the code which is associated with events and controls.
The best way to illustrate the process is with an example.
20.3.1 Multiple Choice Example
In this example the user is to design a form with a simple question and three
optional examples. It should display if the answer is correct (TRUE) or wrong
(FALSE). The program should continue after each selection until the user selects
an exit button.
Step 1 : The label control is selected 
 Then the text ‘What is the capital of
France’ is entered the caption field, as shown in Figure 20.2.
FIGURE 20.2  Step 1
Step 2:
Next the user add a command button by selecting the command control 
.
The button is then added to the form and the Caption property is set to

‘Edinburgh’, as shown in Figure 20.3.
FIGURE 20.3  Step 2
Step 3:
Next the user adds another command button by selecting the command
control. The button is then added to the form and the Caption property is set to
‘Paris’, as shown in Figure 20.4.
FIGURE 20.4  Step 3
Step 4:
Next the user adds another command button by selecting the command

control. The button is then added to the form and the Caption property is set to
‘Munich’, as shown in Figure 20.5.
FIGURE 20.5  Step 4
Step 5:
Next the user adds a TextBox 
. This is then added to the right-hand side of
the form, as shown in Figure 20.6. The Text property is then changed to have an
empty field. The TextBox will be used to display text from the program.
FIGURE 20.6  Step 5

Step 6:
Next the user adds another command button by selecting the command
control. The button is then added to the form and the Caption property is set to
‘Exit’, as shown in Figure 20.7. A character in the name can be underlined by
putting an & before it. Thus ‘&Exit’ will be displayed as ‘Exit’.
FIGURE 20.7  Step 6
Step 7:
Next the code can be attached to each of the command buttons. This is done
by either double clicking on the command button or by selecting the button and
pressing the F7 key. To display to the TextBox (the object named Text1) then
the text property is set with:
which display the string “FALSE” to the text window. The associated code is
shown in Figure 20.8.

FIGURE 20.8  Visual Basic 4 on-line help manual
Step 8:
Next the code associated with the second command button is set, with:
as shown in Figure 20.9.
FIGURE 20.9  Visual Basic 4 on-line help manual
Step 9:
Next the code associated with the third command button is set, with:
as shown in Figure 20.10.

FIGURE 20.10  Visual Basic 4 on-line help manual
Step 10:
Finally the code associated with the exit command button is set by adding the
code:
which causes the program to end and the code is shown in Figure 20.11.
FIGURE 20.11  Visual Basic 4 on-line help manual
The program can then be executed with Run→Start. Figure 20.12 shows a
sample run.

FIGURE 20.12  Sample test run
Next the form and the project are saved using the File→Save option. If the file
has not been saved before then the user will be prompted to give the project and
the form a new file name. In this case save the project and the form as
VB03_01.VBP and VB03_01.FRM. These are listed in Program 20.1. It can be seen
that the form file (VB03_01.FRM) contains the Visual Basic code along with the
properties and definitions of the controls, whereas the project file (VB03_01.VBP)
defines the user’s environment, such as:
• The names of any forms.
• The control types.



20.4 Temperature conversion program
In this example the user will enter either a temperature in Centigrade or
Fahrenheit and the program will convert to an equivalent Fahrenheit or
Centigrade temperature. The steps taken, with reference to Figure 20.13, are:

FIGURE 20.13  Temperature conversion form
1. Add a Label control and change its Caption property to ‘Centigrade’.
2. Add a Label control and change its Caption property to ‘Fahrenheit’.
3. Add a TextBox control and put it beside the Centigrade Label. Next
change its Text property to ‘0’.
4. Add a TextBox control and put it beside the Fahrenheit Label. Next
change its Text property to ‘32’.
5. Add a CommandButton control and put it below the text boxes. Next
change its Caption property to ‘C to F’. This command button will
convert the value in the Centigrade to Fahrenheit and put the result in the
Fahrenheit text box.
6. Add a CommandButton control and put it beside the other command
button. Next change its Caption property to ‘F to C’. This command
button will convert the value in the Fahrenheit to Centigrade and put the
result in the Centigrade text box.
7. Select the form and change the Caption property to ‘Temperature
Conversion’.
Next the code associated with each control can be added, as follows:
1. First add code to the first command button (C to F) which will be used to
convert the text from the Centigrade text box (Text1) and display it to the
Fahrenheit text box (Text2). This is achieved with:
2. Next add code to the second command button (F to C) which will be used
to convert the text from the Fahrenheit text box (Text2) and display it to
the Centigrade text box (Text1). This is achieved with:

A test run of the program is given in Figure 20.14.
FIGURE 20.14  Sample run
The temperature conversion program up to this point has several weaknesses.
One of these is that it does not have an exit option (this will be left as an
exercise) and the other is that the user can enter a value which is not a valid
temperature value and the program will accept it. For example, if the user enters
a string of characters then the program stops and displays the message shown in
Figure 20.15.
FIGURE 20.15  Sample run with invalid input

To overcome this problem the value that is entered is tested to see if it is a
valid numeric value, using the IsNumeric() function. This returns a TRUE if the
value can be converted to a numeric value, else a FALSE. The modified code for
the two command buttons is given next and a sample run is shown in Figure
20.16.
FIGURE 20.16  Sample run with invalid input

20.5 Quadratic roots program
In this example the program calculates the roots of a quadratic equation with a
user entered values of a, b and c. The general form of a quadratic equation is:
the general solution is:
This leads to three types of roots, these are:
if (b2>4ac) then there are two real roots;
else if (b2=4ac) then there is a single root of –b/4a;
else if (b2<4ac) then these are two complex roots which are:
The steps taken, with reference to Figure 20.17, are:

FIGURE 20.17  Quadratic equation form
1. Add a Label control and change its Caption property to ‘a’.
2. Add a Label control and change its Caption property to ‘b’.
3. Add a Label control and change its Caption property to ‘c’.
4. Add a Label control and change its Caption property to ‘x1’.
5. Add a Label control and change its Caption property to ‘x2’.
6. Add a TextBox control and put it beside the a Label. Next change its Text
property to ‘0’ (this is the Text1 object).
7. Add a TextBox control and put it beside the b Label. Next change its Text
property to ‘0’ (this is the Text2 object).
8. Add a TextBox control and put it beside the c Label. Next change its Text
property to ‘0’ (this is the Text3 object).
9. Add a TextBox control and put it beside the x1 Label. Next change its
Text property to ‘0’ (this is the Text4 object).
10. Add a TextBox control and put it beside the x2 Label. Next change its
Text property to ‘0’ (this is the Text5 object).
11. Add a CommandButton control and put it below the text boxes. Next
change its Caption property to ‘Calculate’. This command button will be
used to determine the roots of the equation.
12. Add a CommandButton control and put it beside the other command
button. Next change its Caption property to ‘Exit’. This command button
will be used to exit the program.
13. Select the form and change the Caption property to ‘Quadratic Equation’.
Next the code associated with each control can be added, as follows:
1. First add code to the first command button (Calculate) which will be used
to calculate the roots and display to the roots text box (Text4 and Text5).
This is achieved with:

    
    Notice that the code includes the _ character which allows the
programmer to continue a statement onto another line.
2. Next add code to the second command button (Exit):
Figure 20.18 shows two sample runs.

FIGURE 20.18  Sample runs
20.6 Resistance calculation with slider controls
program
An excellent method of allowing the user to input a value within a fixed range is
to use a slider control. These slider controls can either be vertical (VScroll) or
horizontal (HScroll). The main properties, as shown in Figure 20.19, of a scroll
bar are:
FIGURE 20.19  Scroll bar properties
• Max. Which defines the maximum value of the scroll bar.
• Min. Which defines the minimum value of the scroll bar.
• Value. Which gives the current slider value.

As an example, a horizontal slider will be setup with a voltage range of 0 to
100. The value of the slider will be shown. The steps taken, with reference to
Figure 20.20, are:
FIGURE 20.20  Voltage form
1. Add a Label control and change its Caption property to ‘Voltage’.
2. Add a Label control and change its Caption property to ‘0’.
3. Add a HScrollBar control below the labels. Next change its Max property
to ‘100’ and its Min property to ‘0’.
Next the code associated with each control can be added, as follows:
1. Add code to the horizontal scroll bar which will be used to display its
value to the voltage value label (Label2). This is achieved with:
This will take the value from the scroll bar (HScroll1.Value) and display to
the second label box (Label2). When the program is run then the user can move
the scroll bar back and forward which causes a change in the displayed voltage
value (from 0 to 100). A sample run is shown in Figure 20.21.

FIGURE 20.21  Sample run
This project can now be enhanced by adding another slider for current and
displaying the equivalent resistance (which is voltage divided by current). The
steps taken, with reference to Figure 20.22, are:
FIGURE 20.22  New form
1. Add a Label control and change its Caption property to ‘Voltage’.
2. Add a Label control and change its Caption property to ‘0’.
3. Add a HScrollBar control below the labels (HScrolll). Next change its
Max property to ‘100’ and its Min property to ‘0’.
4. Add a Label control and change its Caption property to ‘Current’.
5. Add a Label control and change its Caption property to ‘0’.
6. Add a HScrollBar control below the labels (HScroll2). Next change its

Max property to ‘100’ and its Min property to ‘0’.
7. Add a Label control and change its Caption property to ‘Resistance’.
8. Add a Label control and change its Caption property to ‘0’.
Next the code associated with each control can be added, as follows:
1. Add code to the first horizontal scroll bar (HScrolll) which will be used to
display its value to the voltage value label (Label2). The resistance label
(Label6) is also updated with the result of the voltage divided by the
current. This is achieved with:
2. Add code to the second horizontal scroll bar (HScroll2) which will be
used to display its value to the current value label (Label4) with the value
of the scroll bar divided by 100. The resistance label (Label6) is also
updated with the result of the voltage divided by the current. This is
achieved with:
Figure 20.23 shows a sample run.

FIGURE 20.23  Sample run
One of the problems of the design is that the controls and form have names
which do not document their function. Visual Basic uses a naming convention
which uses the type of control and consecutively adds a number, as shown in the
design in Figure 20.24.
FIGURE 20.24  Object names
In this case an improved naming convention might be:

These are set by selecting the properties of each of the objects and then
changing the Name property to the required name. An example of changing the
name of the form to Resistance_Calc is given in Figure 20.25.
FIGURE 20.25  Changing the name of the form
Figure 20.26 shows the list of objects after each of their names has been
changed. Notice that it is now easier to locate the required object.

FIGURE 20.26  Changing the name of the form
Next the code must be modified so that the references are to the newly named
objects. The code for the voltage scroll bar (Voltage_Value) is now:
and the code for the current scroll bar (Current_Value) is now:
20.7 Exercises
20.7.1. Write a Visual Basic program in which the user enters either a value in
either radians or degrees and the program converts to either degrees or
radians, respectively. Figure 20.27 shows a sample run.

FIGURE 20.27  Radians to degrees conversion
20.7.2. Modify the program in Exercise 20.7.1 so that invalid entries are not
accepted.
20.7.3. Modify the program in Exercise 20.7.2 so that the conversion value is
automatically converted when the user enters a value (that is, there is no
need for the command buttons).
20.7.4. Write separate Visual Basic programs with slider controls for the
following formula:
(i) F = ma range: m=0.01 to 1000 g, a=0.01 to 100 m.s−2
(ii) V = IR range: 1=0.1 to 100 A, V=0.1 to 100 V
20.7.5. Write a Visual Basic program that calculates the values of m and c for a
straight line. The values of (x1, y1) and (x2, y2) should be generated with
slider controls (with a range of –100 to +100 for each of the values).
Figure 20.28 shows a sample design.

FIGURE 20.28  Straight line program design
20.7.6. Modify the program in Exercise 20.7.5 so that a divide by zero does not
occur when the difference in the x values is zero. If this is so then the
program should display ‘INFINITY’ for the gradient. If the two
coordinates are the same then the program should display the message
‘INVALID’ for the gradient.
20.7.7. Write a Visual Basic program which has a multiple choice option
question which is repeated. The program should keep a running tally of
the number of correct answers and the number of incorrect answers.
20.7.8. Complete Worksheet 3 on page 39 using Visual Basic.

21
Menus and Dialog Boxes
21.1 Introduction
This chapter discusses how menus and dialog boxes are used.
21.2 Menu editor
Most Windows programs have menus in which the user selects from a range of
defined pull-down menus with defined options. Visual Basic has an easy-to-use
function called the Menu Editor which is used to create custom menus. The
Menu Editor is started from the Tools Menu or from the toolbar shortcut 
.
An example screen from the Menu Editor is shown in Figure 21.1. It includes:
FIGURE 21.1  Menu editor

• Caption. Which is a text box in which the name of the menu bar or menu
option is entered. A hyphen (-) is entered as a caption if a menu separator
bar is required. This bar helps to separate menu options. Often in menus
the user can select a menu option by pressing the ALT key and an
assigned key (hot key). To specify the ALT-hot key then an & is inserted
before the letter of the menu option. When the program is run then this
letter is underlined. For example Fi&le would be displayed as File and
the assigned keys would be ALT-L. A double ampersand specifies the
ampersand character.
• Name. Which is a text box in which the control name for the menu option is
specified. This is used by the program code and is not displayed to the
user when the program is run.
• Index. Which is a numeric value that can be used to specify the menu option.
Typically it is used when calling a single function which services several
menu items. For example, a File menu may have the options: New, Open
and Save, then a single function could be created to service these requests
and the index value would be used which option has been selected.
• Shortcut. Which is a pull-down menu that can be used to specify a shortcut
key (Cntrl-A to Cntrl-Z, F1 to F12, Cntrl-F1 to Cntrl-F12, Shift-F1 to
Shift-F12, Shift-Cntrl-F1 to Shift-Cntrl-F12, Cntrl-Ins, Shift-Ins, Del,
Shift-Del, Alt-Bkspace).
• HelpContextlD. Which is a text box in which a unique numeric value is
specified for the context ID. This value can be used to find the
appropriate Help topic in the Help file identified by the HelpFile
property.
• NegotiatePosition. Which is a pull-down list box which allows the user to
specify the menu’s NegotiatePosition property and determine how the
menu appears in a form. Value options are 0 (None), 1 (Left) and 2
(Middle) and 3 (Right).
• Checked. Which is a check box which specifies if a check mark is to appear
initially at the left of a menu item. It is generally used to specify if a
toggled menu option is initially on or off.
• Enabled. Which is a check box which specifies if the menu item is to respond
to events. If it is not enabled then the menu item appears dimmed.
• Visible. Which is a check box which specifies if the menu item is to appear in
the menu.

21.2.1 Creating A Menu System
The user enters the caption and name and then uses the outlining buttons to
either promote or demote the item to a higher or lower level (with the left and
right arrow buttons) or up and down (with the up and down arrow buttons). With
this up to 4 levels of submenus can be created.
The list box displays a hierarchical list of menu items with indented submenu
items which indicate their hierarchical position. A menu option is inserted using
the Insert button and deleted with the Delete button. The OK button closes the
Menu Editor and saves the most recent changes.
The code associated with a menu item is defined by the menu item name. For
example if a menu item has the caption of File and a name of FileOption then
the associated code function will be FileOption_Click.
For example, to create a menu with:
1. Create a caption &File and add the name of MenuFile. Next press the
Next button.
2. Create a caption &Open and add the name of MenuFileItem. Add an index
value of 0. Then select the right arrow button to move the option to the
next level, as shown in Figure 21.2. Next press the Next button.

FIGURE 21.2  Adding a menu item
3. Create a caption &Save and add the name of MenuFileItem. Add an index
value of 1, as shown in Figure 21.3. Next press the Next button.
FIGURE 21.3  Adding a menu option

4. Create a caption &Close and add the name of MenuFileItem. Add an
index value of 2, as shown in Figure 21.4. Next press the Next button.
FIGURE 21.4  Adding a menu option
5. Create a caption &Exit and add the name of Exit. Then select the left
arrow button to move the option to the next level, as shown in Figure
21.5. Next press the OK button and the form shown in Figure 21.6 should
be displayed.

FIGURE 21.5  Adding a menu option
FIGURE 21.6  Menu editor
The associated code modules which are related to these menus items are
MenuFile_Click(), 
MenuFileItem_Click() 
and 
Exit_Click(). 
The
MenuFileItemClick() module has the Index parameter passed to it. This has a
value of 0 when Open is select, a 1 when Save is selected and a 2 when Close is
selected. The MenuFileItem is specified with:

thus the value of Index will either be 0, 1 or 2.
Next a text box is added to the form (Text1), as shown in Figure 21.7. The
resulting objects are shown in Figure 21.8.
FIGURE 21.7  Adding text box
FIGURE 21.8  Program objects
Next the code can be added. The MenuFileItem object services the Open,
Save and Close options and the Index parameter passed into it. In the code below
the Case statement is used to test the Index parameter and, in this case, display
some text to the text box.

This code appends either ‘Open’, ‘Save’ or ‘Close’ to the text box (Text1).
The & character concatenates two strings together, thus the code Text1.Text &
“Open” simply adds the text ‘Open’ to the text already in the text window. The
exit code is added as follows:
Figure 21.9 shows a sample run of the developed program. The Exit menu
option is used to quit the program and the File options (File, Save and Close)
simply display the required text to the text box.
FIGURE 21.9  Example run

21.3 Common dialog control 
The CommonDialog control allows for file operations such as opening, saving or
printing files. It is basically a control between Visual Basic and the Microsoft
Windows dynamic-link library COMMDLG. DLL. Thus this file must be in the
Microsoft Windows SYSTEM directory for the common dialog control to work.
A dialog box is added to an application by first adding the CommonDialog
control to a form and setting its properties. When developing the program the
common dialog box is displayed as an icon on the form. A program calls the
dialog with one of the following (assuming that the dialog box is named
CommonDialog1): CommonDialog1.Filter A string which displays the
filename filter. The | character is used to differentiate different For example the
following filter enables the user to select text files or graphic files that include
bitmaps and icons:
CommonDialog1.Filename Which returns or sets the path and filename of a
selected file.
CommonDialog1.Filterlndex Which defines the default filter (with reference
to the Filter).
CommonDialog1.ShowSave Which returns or sets the path and filename of a
selected file. Displays the CommonDialog control’s Save As dialog box. The
object placeholder represents an object expression that evaluates to an object in
the Applies To list.
CommonDialog1.ShowOpen Which displays the CommonDialog control’s
Open dialog box.
CommonDialog1.ShowPrinter Which displays the CommonDialog control’s
Printer dialog box.
CommonDialog1.ShowFont Which displays the CommonDialog control’s
Font dialog box.
CommonDialog1.ShowHelp Which runs WINHELP.EXE and displays the
specified help file.
A dialog box is added to a form in any position, as shown in Figure 21.10.
This box can be placed anywhere as it will not be seen on the form when the
program is run.

FIGURE 21.10  Example run
The common dialog box can be used to determine the filename of a file to be
opened or saved. It is used in Program 21.3 (which is a modification of Program
21.1) in the Open and Save file menu options. The filter is set to:
This displays, in the Type of File field, the three options “All Files
(*.*),*.*,Text Files (*.txt),*.txt and Temp Files (*.tmp) |*.tmp”.
The default file type is set to the second option with the filter index setting of:
Figure 21.11 shows a sample run and the dialog box. It can be seen that the
default Type of File is set to “Text Files (*.txt)” and Figure 21.12 shows an
example message box.

FIGURE 21.11  Example run
FIGURE 21.12  Example run

21.3.1 File Open/Save Dialog Box Flags
Various flags can be set before the file open/save dialog box. These are defined
in Table 21.1 are set with:
Table 21.1
CommonDialog control constants
Constant
Value
Description
cdlOFNReadOnly
&H1 (1)
Checks ReadOnly check box for Open and Save As dialog boxes,
see Figure 21.13.
cdlOFNOverwritePrompt
&H2(2)
Causes the Save As dialog box to generate a message box if the
selected file already exists.
cdlOFNHideReadOnly
&H4 (4)
Hides the ReadOnly check box, see Figure 21.14.
cdlOFNNoChangeDir
&H8 (8)
Sets the current directory to what it was when the dialog box was
invoked.
cdlOFNHelpButton
&H10 (16)
Causes the dialog box to display the Help button.
cdlOFNNoValidate
&H100
(256)
Allows invalid characters in the returned filename.
cdlOFNAllowMultiselect
&H200
(512)
Allows the File Name list box to have multiple selections, see
Figure 21.15.
cdlOFNExtensionDifferent
&H400
(1024)
The extension of the returned filename is different from the
extension set by the DefaultExt property.
cdlOFNPathMustExist
&H800
(2096)
User can enter only valid path names.
cdlOFNFileMustExist
&H1000
(4096)
User can enter only names of existing files.
The flags can either be defined with their constant name (such as
cdlOFNReadonly) or by the value (0x01). These values or names can be added
together to achieve the required functionality. For example, modifying the

previous example to checks the read-only check box for Open dialog box. A
sample dialog box is shown in Figure 21.13.
FIGURE 21.13  Example run
For example, modifying the previous example to hide the read-only check
box. A sample dialog box is shown in Figure 21.14.

FIGURE 21.14  Example run
For example, modifying the previous example to Allows the File Name list
box to have multiple selections. A sample dialog box is shown in Figure 21.15.
FIGURE 21.15  Example run

The flag settings for a dialog box with the read-only box checking and that the
user is not allowed to change the directory can either be set with:
which is 1 (cdlOFNReadonly) added to 8 (cdlOFNNochangeDir). The method
of using lable constants is preferable as it helps to document the program.
21.3.2 Showing Help Manuals
The common dialog box can also be used to run the help program WINHELP.EXE.
This is achieved by:
and the name of the help manual is specified by:
Various options flags can also be set with the help option, these are specified
in Table 21.2.
Table 21.2
CommonDialog control constants
Constant
Value
Description
cdlHelpCommand
&H102
Executes a help macro.
cdlHelpContents
&H3
Displays the help contents topic.
cdlHelpContext
&H1
Displays help for a particular context.

cdlHelpContextPopup
&H8
Displays in a pop-up window a particular Help topic.
cdlHelpForceFile
&H9
Ensures that WinHelp displays the correct Help file. If the correct Help file is
currently displayed, no action occurs. If the incorrect Help file is displayed,
WinHelp opens the correct file.
cdlHelpHelpOnHelp
&H4
Displays Help for using the help application itself.
cdlHelpIndex
&H3
Displays the index of the specified Help file.
cdlHelpKey
&H101
Displays Help for a particular keyword.
Typically a help menu option is added to a program. An example help event is
given in Program 21.4. The help command used is cdlHelpConents which
shows the index page of the help manual. Figure 21.16 shows an example of a
run and Figure 21.17 shows an example for the An example of Vbcbt help
manual.
FIGURE 21.16  Selecting help file

FIGURE 21.17  Example help manual
21.4 Running an application program
Visual Basic allows for the execution of applications with the Shell command.
Its format is:
where the windowstyle is as defined in Table 21.3. If this argument is missing
then the windowstyle is that the program is started with a minimized focus.
Table 21.3

Windowstyle named argument
Constant
Val
Description
vbHide
0
Window is hidden and focus is passed to the hidden window.
vbNormalFocus
1
Window has focus and is restored to its original size and position.
vbMinimizedFocus
2
Window is displayed as an icon with focus.
vbMaximizedFocus
3
Window is maximized with focus.
vbNormalNoFocus
4
Window is restored to its most recent size and position. The currently active
window remains active.
vbMinimizedNoFocus
6
Window is displayed as an icon. The currently active window remains active.
The following shows an example of executing the Calc.exe and Notepad.exe
programs:
21.5 Exercises
21.4.1. Write a Visual Basic program with the following menu system:

21.4.2. Modify the menu system in Exercise 21.4.1 so that the program displays
the function of the menu option.
21.4.3. Expand Program 21.5 and its menu system so that it runs other Windows
programs. An example could be:
21.4.4. Integrate some of the programs from previous chapters into a single
program with menu options. For example, the menu system could be:
   One possible method of implementing this program is to compile the
temperature conversion, quadratic equation and straight line programs to
an EXE (File→Make EXE file …). Then run the Shell function from the
object call.

22
Events
22.1 Introduction
Visual Basic differs from many other programming languages in that it is event-
driven where the execution of a program is defined by the events that happen.
This is a different approach to many programming languages which follow a
defined sequence of execution and the programmer must develop routines which
react to events. This chapter discusses the events that happen in Visual Basic.
22.2 Program events
Each object in Visual Basic has various events associated with it. For example,
the single click on an object may cause one event but a double click causes
another. The events are displayed at the right-hand side of the code window. An
example is shown in Figure 22.1 which in this case shows the events: KeyPress,
KeyUp, LinkClose, LinkError, LinkExecute, LinkOpen and Load. The name of
the routine which contains the code for the event and object is in the form:
FIGURE 22.1  Form events

The main events that occur in Visual Basic include:
• Click. Which occurs when a user performs a single click of the mouse button
on the object.
• DblClick. Which occurs when a user performs a double click of the mouse
button on the object.
• MouseUp. Which occurs when the user releases the mouse button.
• MouseDown. Which occurs when the user presses the mouse button down.
• MouseMove. Which occurs when the user moves the mouse.
• KeyUp. Which occurs when the user releases a key.
• KeyDown. Which occurs when the user presses a key.
• KeyPress. Which occurs when the user presses and releases a key (the
KeyDown and KeyUp events).
• Load. Which occurs when a form is loaded.
• DragDrop. Which occurs at the begin and end of a drag operation of any
control.
• LostFocus. Which occurs when an object loses the focus, either by user
action, such as tabbing to or clicking another object.
• Resize. Which occurs when a form is first displayed or if the object size is
changed.
• Unload. Which occurs when a form is about to be removed from the screen.
Not all controls and forms (objects) have all the events associated with them.
For example a form may have the following:

whereas a command button has a reduced set of routines:
The parameters passed into the routine depend on the actions associated with
the events. For example, the Keypress event on a command button causes the
routine:
to be called. The value of KeyAscii will contain the ASCII value of the
character press.
The mouse down event for a command button has the following routine
associated with it:

where the value of Button is the value of the button press (0 for none, 1 for the
left button and 2 for the right button). Shift specifies if the shift key has been
pressed, and X, Y specify the x,y coordinates of the mouse point. The following
sections discuss some events which occur.
22.2.1 Click
The Click event occurs when the user presses and then releases a mouse button
over an object. When the object is a form the event occurs when the user clicks
on a blank area or a disabled control. If the object is a control, then the event
occurs when the user:
• Clicks on a control with any of the mouse buttons. When the control is a
CheckBox, CommandButton, or OptionButton control then the Click
event occurs only when the user clicks the left mouse button.
• Presses the ALT-hotkey for a control, such as pressing Alt-X for the E&xit
control property name.
• Presses the Enter key when the form has a command button.
• Presses the Space key when command button, option button or check box
control has the focus.
22.2.2 Dbl Click
The Dbl Click event occurs when the user presses and releases the mouse button
twice over an object. In a form it occurs when the user double clicks either on a
disabled control or a blank area of a form. On a control the event happens when
the user:
• Double-clicks on a control with the left mouse button.
• Double-clicks an item within a ComboBox control whose Style property is set
to 1 (Simple).
An example form is shown in Figure 22.2. In this case a text box is added to
the form. Then the following code is added to the form:

FIGURE 22.2  Form events
which will display the text ‘MISS’ when the user click on any blank area on the
form. The following code is added to the text box:
which displays the text ‘HIT’ when the user double clicks on the text box.
22.2.3 Mouse Up, Mouse Down
The MouseUp event occurs when the user releases the mouse button and the
MouseDown event when the user presses a mouse button. The standard format
for the associated routines are:
where
• button identifies which button was pressed (MouseDown) or released

(MouseUp). The first bit of the value identifies the left button, the second
identifies the right button and the third bit identifies the middle button.
Thus a value of 1 identifies the left button, a value of 2 identifies the right
and a value of 4 identifies the middle button (if the mouse has one). A
combination of these values can be used to identify button press
combinations, such as a value of 6 identifies that the middle and right
buttons have been pressed. Table 22.1 shows the constant names for the
buttons.
Table 22.1
Button constants
Constant (Button)
Value
Description
vbLeftButton
1
Left button is pressed
vbRightButton
2
Right button is pressed
vbMiddleButton
4
Middle button is pressed
• shift identifies the state of the Shift, Cntrl, and Alt keys when the button was
pressed (or released). The first bit of the value identifies the Shift key, the
second bit identifies the Cntrl key and the third bit identifies the Alt key.
Thus a value of 1 identifies the Shift key, a value of 2 identifies the Cntrl
key and a value of 4 identifies the Alt key. A combination of these values
can be used to identify key combinations, such as a value of 6 identifies
that the Cntrl and Alt keys are pressed. Table 22.1 shows the constant
names for the keys.
• x, y identifies the current location of the mouse pointer. The x and y values
are relatively to the ScaleHeight, Scale Width, ScaleLeft, and ScaleTop
properties of the object.
An example of code for the mouse down event is given next and a sample run
is shown in Figure 22.3.

FIGURE 22.3  Form events
Table 22.2
Button constants
Constant
Value
Description
vbShiftMask
1
SHIFT key is pressed
vbCtrlMask
2
CTRL key is pressed
vbAltMask
4
ALT key is pressed
22.2.4 Mouse Move
The MouseMove event occurs when the user moves the mouse. Thus it is
continually being called as it moves across an object. The standard format for the
associated routines are:

where button, shift, x and y have the same settings as the ones defined in the
previous section.
An example of code for the MouseMove event is given next and a sample
code is shown in Figure 22.4. Figure 22.5 shows a sample run. In this case, the x
and y coordinate is the mouse pointer and the button pressed are displayed to the
text box.
FIGURE 22.4  Sample code
FIGURE 22.5  Sample run

22.2.5 Drag And Drop
The DragDrop event occurs at the end of a drag and drop operation of any
control. The standard format for the associated routines are:
where:
• source is the control being dragged.
• x, y specifies the current x and y coordinate of the mouse pointer within the
target form or control. The x and y values are relative to the ScaleHeight,
ScaleWidth, ScaleLeft, and ScaleTop properties of the object.
22.2.6 Keypress
The KeyPress event occurs when the user presses and releases a key (the
KeyDown and KeyUp events). The standard format for the associated routines
are:
where Keyascii specifies a standard ANSI keycode, this can be converted into
an ASCII character with the conversion function:
An example of code for the KeyPress event is given next and a sample run is
shown in Figure 22.6. For this program the user can type in the blank area on the
form (the grey area) and the text will be displayed in the text box.

FIGURE 22.6  Sample run
22.2.7 Lost Focus
The Lost focus occurs when an object loses the focus, either by user action, such
as tabbing to or clicking another object. The standard format for the associated
routines are:
22.2.8 Resize
The Resize event occurs when a form is first displayed or if the object size is
changed. The standard format for the associated routines are:
where:
• height is a value specifying the new height of the control.
• width is a value specifying the new width of the control.

22.2.9 Unload
The Unload event occurs when a form is about to be removed from the screen.
Then if the form is reloaded the contents of all its controls are reinitialized. The
standard format for the associated routines are:
where cancel determines whether the form is removed from the screen. If it is
0 then the form is removed else it will not be removed.
22.3 Exercises
22.3.1. Write a Visual Basic program which has a single form and a text box.
The text box should show all of the events that occur with the form, that
is:
   Investigate when these events occur. Notice that when an event has code
attached then the procedure name in the View Code pull-down menu
becomes highlighted.
22.3.2. Write a Visual Basic program which has a single command button and a
text box. The text box should show all of the events that occur with the
command button, that is:
   Investigate when these events occur.
22.3.3. Write a Visual Basic program in which the program displays the message
‘IN TEXT AREA’ when the mouse is within the textbox area and ‘OUT
OF TEXT AREA’ when it is out of the textbox area.
22.3.4. Write a Visual Basic program which has a command button. If the user
presses any lowercase letter then the program ends, else it should
continue. A sample event which quits when the letter ‘x’ is pressed is
given next:

22.3.5. Modify the program in Exercise 22.3.4 so that if the user clicks on the
form (and not on the command button) the program automatically
prompts the user for his/her name. This name should then appear in the
command button caption property (Command1.caption). An outline of
the event is given next:
22.3.6. Write a Visual Basic program which displays the message ‘So long and
thanks for the fish’ when the main form is Unloaded. The form should be
removed from the screen.
22.3.7. Write a Visual Basic program with a textbox which displays the current
keypress, including Alt-, Ctrl-and Shift-keystrokes.
22.3.8. Modify the program in Exercise 22.3.7 so that it also displays the mouse
button press and the coordinates of the mouse.

23
Graphics
23.1 Introduction
This chapter discusses how graphics files are loaded into the program and how
graphic objects can be drawn.
23.2 Loading graphics files
Visual Basic allows a graphic file to be loaded into a form, a picturebox or an
image control. The standard function is:
Where graphfile specifies the name of the graphics file, if no name is given
then the graphic in the form, picture box or image control is cleared. The
standard graphics files supported by Visual Basic are:
• BMP. Windows bitmap file.
• ICO. Icon file (maximum size of 32×32 pixels).
• RLE. Run-length encoded files.
• WMF. Windows metafile files.
Normally graphics files are displayed in a PictureBox 
 Thus to display the
graphic file “CLOUD.BMP” to Picture1 then:
A picture can be loaded put into the clipboard using:

The following example loads a graphics file into a PictureBox. Figure 23.1
shows a sample form which contains a PictureBox, a CommandButton and a
DialogBox.
FIGURE 23.1  Form
The code added to the command button is as follows:
This will display a dialog box with the default file setting of *.BMP. After the
user has selected a graphic then the LoadPicture function is used to display the
graphic file to the picture box (Picture 1). Figure 23.2 shows a sample dialog box
and Figure 23.3 shows a sample graphic.

FIGURE 23.2  Dialog box
FIGURE 23.3  Sample graphic
One problem with the previous example code is that a non-graphic file could
be loaded and the program would not give an error message. The following code
overcomes this by testing for an error. This is achieved by testing the Err
parameter after the picture has been loaded. If it is set to TRUE then an error
message is displayed and, after the user has accepted the error then the picture
will be cleared from the picture box.

23.3 Colours
The background and foreground colour of an object can be modified with the
BackColor or ForeColor property, respectively. The standard form is:
A colour is defined as its RGB (red/green/blue) strength, with a hexadecimal
strength from &H00 to &H77 for each colour. The valid ranges of colour are
thus from 0 to &HFFFFFF.
23.3.1 RGB Function
The RGBColor function returns the hexadecimal colour value given the three
strengths of red, green and blue. Its standard form is:
where red, green and blue are a value from 0 to 255. Table 23.1 gives some
example colours with their RGB colour. For example:
Table 23.1
Colour strengths

23.3.2 QBColor Function
The QBColor function has a limited range of 15, typically colours as specified in
Table 23.1. For example, the following sets the
Table 23.2
Colour values
23.4 Drawing
Visual Basic has a wide range of drawing functions (graphics methods); these
include:
• Line. Draws lines and rectangles on an object.

• Circle. Draws a circle, ellipse, or arc on an object.
• Cls. Clears graphics and text from a Form or PictureBox.
• Fill colour. Returns or sets the colour used to fill in shapes (drawn by Line
and Circle graphics methods).
• Fill style. Returns or sets the pattern used to fill Shapes (as created by Line or
Circle graphics methods).
23.4.1 Line
The Line graphic method draws lines and rectangles on an object. Its standard
form is:
where:
• Step. Keyword specifying the starting point co-ordinates. (Optional) • (x1,y1)
Define the starting point co-ordinates of a line or rectangle. If they are
omitted then the line starts at the current x,y position (CurrentX and
CurrentY). Optional • Step. Keyword specifying the end point co-
ordinates. (Optional) • (x2,y2) Define the end point co-ordinates of a line
or rectangle. (Required) • color. Defines the RGB colour used to draw the
line. If it is omitted then the ForeColor property setting is used.
(Optional) • B. If the B option is added then a box is drawn using the co-
ordinates for opposite corners. (Optional) • F. If the F option is added
then the box is filled with the same colour as the line colour. (Optional)
The CurrentX and CurrentY values are set to the end of the line after a line
has been drawn. The DrawWidth property sets the width of the line and
DrawMode and DrawStyle properties define the way that the line or box is
drawn.
The following code is added to a form and with the Click event. It displays 15
solid rectangles of a random size and random colour. The QBColor function is
used to display one of the 16 predefined colours. Note that the Rnd function
returns a random number from 0 to 1.

FIGURE 23.4  Sample graphic
23.4.2 Circle
The Circle graphic method draws a circle, ellipse or an arc on an object. Its
standard form is:
where:
• Step. Keyword specifying that the centre of the circle, ellipse, or arc is
relative to the current co-ordinates given by the CurrentX and CurrentY
properties of object. (Optional) • (x, y). Value which gives the co-
ordinates of the centre of the circle, ellipse or arc. (Required) • radius.

Value which specifies the radius of the circle, ellipse or arc. (Required)
• color. Value which specifies the colour of the circle’s outline. If
omitted, the value of the ForeColor property is used. (Optional) • start,
end. Values specifying the start and end angle (in radians) for an arc or a
partial circle or ellipse is drawn, start and end specify (in radians) the
beginning and end positions of the arc. (Optional) • aspect. Value
specifying the aspect ratio of the circle. The default value is 1.0, which
yields a perfect circle. (Optional)
The QBColor or RGB function are typically used to set the colour. A circle is
fill with a defined colour with the FillColor property and the fill style is set by
the FillStyle properties. The DrawWidth property defines the width of the line
used to draw the circle, ellipse, or arc.
The following example code draws 10 circles of increasing size of a random
colour. Figure 23.5 shows a sample run.
FIGURE 23.5  Sample graphic

23.4.3 DrawWidth
The DrawWidth property returns or sets the line width of a graphic method. To
set the width of line the following is used:
where the size is a value from 1 (the default) to 32,767 and is measured in
pixels.
23.4.4 DrawStyle
The DrawWidth property returns or sets the line style of a graphic method.
To set the line style the following is used:
where value is a number from 0 (the default) to 6 which corresponds to the
following line styles:
For example to set a line style on a Form to dashed:

DrawWidth=l
23.4.5 FillColor
The FillColor property returns or sets the colour used to fill in shapes, circles
and boxes. To set the fill colour the following is used:
where the size is a hexadecimal colour and by default it is Black.
23.4.6 FillStyle
The FillStyle property returns or sets the fill style of a graphic method. To set the
line style the following is used:
where value is a number from 0 (the default) to 6 which corresponds to the
following line styles:
The following example displays 15 randomly filled circles with a radius of
200 pixels. It is initiated with the user clicks on the form. Figure 23.6 shows a
sample run.

FIGURE 23.6  Sample graphic
23.4.7 CurrentX, CurrentY
The CurrentX and CurrentY property return or sets the horizontal and vertical
(CurrentY) co-ordinates, respectively. The standard format is:
The (0,0) co-ordinate is at the upper-left hand corner of an object.
23.4.8 CIs

The Cls method clears graphics and text generated at run time from a Form or
PictureBox. Its standard form is:
23.5 Exercises
23.5.1. Write a program which displays a coloured rectangle in the middle of a
form. Each time the user clicks on the form the rectangle should change
colour.
23.5.2. Write a Visual Basic program which automatically moves a rectangle
from the top left-hand side of the screen to the bottom right-hand side.
The program should quit once it reaches the bottom corner.
23.5.3. Write a Visual Basic program which randomly moves a small rectangle
around the screen. If the rectangle touches any of the edges it should
rebound off the edge.
23.5.4. Write a Visual Basic program in which the user controls the movement
of a small rectangle by the arrowkeys.
23.5.5. Write a Visual Basic program which displays a circle on the form which
follows the users mouse cursor (note use the cls function to get rid of the
existing circle).
23.5.6. Write separate Visual Basic programs which draw the following objects:
(i) A car.
(ii) A ship.
(iii) A house.
23.5.7. Write a Visual Basic program which displays the following images. Use
the sleep and cls functions to create a timing delay of 1 second between
each image display (the animation should look as if it is winking).

PART E
HTML/Java

24
HTML (Introduction)
24.1 Introduction
HTML is a standard hypertext language for the WWW and has several different
versions. Most WWW browsers support HTML 2 and most of the new versions
of the browsers support HTML 3. WWW pages are created and edited with a
text editor, a word processor or, as is becoming more common, within the
WWW browser.
HTML tags contain special formatting commands and are contained within a
less than (<) and a greater than (>) symbol (which are also known as angled
brackets). Most tags have an opening and closing version; for example, to
highlight bold text the bold opening tag is <B>and the closing tag is</B> .
Table 24.1 outlines a few examples.
Table 24.1
Example HTML tags
Open tag
Closing tag
Description
<HTML>
</HTML>
Start and end of HTML
<HEAD>
</HEAD>
Defines the HTML header
<BODY>
</BODY>
Defines the main body of the HTML
<TITLE>
</TITLE>
Defines the title of the WWW page
<I>
</I>
Italic text
<B>
</B>
Bold text
<U>
</U>
Underlined text
<BLINK>
</BLINK>
Make text blink
<EM>
</EM>
Emphasize text
<FONT SIZE=+1>
</FONT>
Increase font size by one increment
<FONT SIZE=–1>
</FONT>
Reduce font size by one increment
Center text

<CENTER>
</CENTER>
Center text
<H1>
</H1>
Section header, level 1
<H2>
</H2>
Section header, level 2
<H3>
</H3>
Section header, level 3
<P>
 
Create a new paragraph
<BR>
 
Create a line break
<excl – –>
––>
Comments
<SUPER>
</SUPER>
Superscript
<SUB>
</SUB>
Subscript
HTML script 1 gives an example script and Figure 24.1 shows the output from
the WWW browser. The first line is always <HTML> and the last line is </HTML>.
After this line the HTML header is defined between <HEAD> and </HEAD>. The
title of the window in this case is My first HTML page. The main HTML text is
then defined between <BODY> and </BODY>.
FIGURE 24.1  Example window from example HTML script

The WWW browser fits text into the window size and does not interpret line
breaks in the HTML source. To force a new line the <BR> (line break) or a new
paragraph (<p>) is used. The example also shows bold, italic and underlined
text.
24.2 Links
The topology of the WWW is set-up using links where pages link to other
related pages. A reference takes the form:
where url defines the URL for the file, Reference Name is the name of the
reference and </A> defines the end of the reference name. HTML script 24.2
shows an example of the uses of references and Figure 24.2 shows a sample
browser page. The background colour is set using the <BODY BGCOLOR= “#
FFFFFF”> which set the background colour to white. In this case the default text
colour is black and the link is coloured blue.

FIGURE 24.2  Example window from example HTML script 24.2
24.2.1 Other Links
Links can be set-up to send e-mail and newsgroups. For example:
to link to a tennis newsgroup and

to send a mail message to the e-mail address: f.bloggs@fredco.co.uk.
24.3 Lists
HTML allows ordered and unordered lists. Lists can be declared anywhere in the
body of the HTML.
24.3.1 Ordered Lists
The start of an ordered list is defined with <OL> and the end of the list by </OL>.
Each part of the list is defined after the <LI> tag. Unordered lists are defined
between the <UL> and </UL> tags. HTML script 24.3 gives examples of an
ordered and an unordered list. Figure 24.3 shows the output from the browser.
FIGURE 24.3  WWW browser with an ordered and unordered lists

Some browsers allow the type of numbered list to be defined with the <OL
TYPE=x>, where x can either be:
• A for capital letters (such as a, b, c, and so on).
• a for small letters (such as a, b, c, and so on).
• I for capital roman letters (such as I, II, III, and so on).
• i for small roman letters (such as i, ii, iii, and so on).
• I for numbers (which is the default).
would be displayed as:
I List 1
II List 2
III List 3
A List 1
B List 2
C List 3
The starting number of the list can be defined using the <LI VALUE=n> where
n defines the initial value of the defined item list.

24.3.2 Unordered Lists
Unordered lists are used to list a series of items in no particular order. They are
defined between the <UL> and </UL> tags. Some browsers allow the type of
bullet point to be defined with the <LI TYPE=shape>, where shape can either be:
• disc for round solid bullets (which is the default for first level lists).
• round for round hollow bullets (which is the default for second level lists).
• square for square bullets (which is the default for third).
HTML script 24.4 gives an example of an unnumbered list and Figure 24.4
shows the WWW page output for this script. It can be seen from this that the
default bullets for level 1 lists are discs, for level 2 they are round and for level 3
they are square.
FIGURE 24.4  WWW page with an unnumbered list

24.3.3 Definition Lists
HTML uses the <DL> and </DL> tags for definition lists. These are normally used
when building glossaries. Each entry in the definition is defined by the <DT> tag
and the text associated with the item is defined after the <DD> tag. The end of the
list is defined by </DL>.HTML script 24.5 shows an example with a definition
list and Figure 24.5 gives a sample output. Note that it uses the <EM> tag to
emphasize the definition subject.

FIGURE 24.5  WWW page with definition list
24.4 Colours
Colours in HTML are defined in the RGB (red/green/blue) strength. The format
is #rrggbb, where rr is the hexadecimal equivalent for the red component, gg
the hexadecimal equivalent for the green component and bb the hexadecimal
equivalent for the blue component. Table 24.2 lists some of the codes for certain
colours.

Table 24.2
Hexadecimal colours
Individual hexadecimal numbers use base 16 and range from 0 to F (in
decimal this ranges from 0 to 15). A two-digit hexadecimal number ranges from
00 to FF (in decimal this ranges from 0 to 255). Table 24.3 outlines hexadecimal
equivalents.
Table 24.3
Hexadecimal to decimal conversions
HTML uses percentage strengths for the colours. For example, FF represents
full strength (100%) and 00 represent no strength (0%). Thus, white is made
from FF (red), FF (green) and FF (blue) and black is made from 00 (red), 0 0
(green) and 00 (blue). Grey is made from equal weighting of each of the colours,
such as 4 3, 43, 4 3 for dark grey (#434343) and D4, D4 and D4 for light grey
(#D4D4D4). Thus, pure red with be #FF0000, pure green will be # 00 FF00 and
pure blue with be # 0000 FF.
Each colour is represented by 8 bits, thus the colour is defined by 24 bits. This
gives a total of 16777216 colours (224 different colours). Note that some video
displays will not have enough memory to display 16.777 million colours in the
certain mode so that colours may differ depending on the WWW browser and
the graphics adapter.
The colours of the background, text and the link can be defined with the

BODY tag. An example with a background colour of white, a text colour of
orange and a link colour of dark red is:
and for a background colour of red, a text colour of green and a link colour of
blue:
When a link has been visited its colour changes. This colour itself can be
changed with the VLINK. For example, to set-up a visited link colour of yellow:
Note that the default link colours are:
24.5 Background images
Image (such as GIF and JPEG) can be used as a background to a WWW page.
For this purpose the option BACKGROUND=‘src.gif’ is added to the <BODY>
tag. An HTML script with a background of CLOUDS.GIF is given in HTML
script 24.6. A sample output from a browser is shown in Figure 24.6.

FIGURE 24.6  WWW page with CLOUD.GIF as a background
24.6 Displaying images
WWW pages can support graphics images within a page. The most common
sources of images are either JPEG or GIF files, as these types of images
normally have a high degree of compression. GIF images, as was previously
mentioned, support only 256 colours from a pallet of 16.7 million colours,
whereas JPEG supports more than 256 colours.

24.6.1 Inserting An Image
Images can be displayed within a page with the <‘IMG SRC=‘src.gif’> which
inserts the graphic src.gif.HTML script 24.7 contains three images: myson.gif,
me.gif and myson2.gif. These are aligned either to the left or the right using the
ALIGN option within the <IMG SRC> tag. The first image (myson.gif) is aligned
to the right, while the second image (me.gif) is aligned to the left. Figure 24.7
shows a sample output from this script. Note that images are left aligned by
default.
FIGURE 24.7  WWW page with three images

24.6.2 Alternative Text
Often users choose not to view images in a page and select an option on the
viewer which stops the viewer from displaying any graphic images. If this is the
case then the HTML page can contain substitute text which is shown instead of
the image. For example:
24.6.3 Other Options
Other image options can be added, such as:
• HSPACE=x VSPACE=y defines the amount of space that should be left around
images. The x value defines the number of pixels in the x-direction and
the y value defines the number of pixels in the y-direction.
• WIDTH= x HEIGHT=y defines the scaling in the x-and y-direction, where x and y
are the desired pixel width and height, respectively, of the image.
• ALIGN=direction defines the alignment of the image. This can be used to align
an image with text. Valid options for aligning with text are texttop, top,
middle, absmiddle, bottom, baseline or absbottom. HTML script 24.8
shows an example of image alignment with the image a.gif (which is just

the letter ‘A’ as a graphic) and Figure 24.8 shows a sample output. It can
be seen that texttop aligns the image with highest part of the text on the
line, top alights the image with the highest element in the line, middle
aligns with the middle of the image with the baseline, absmiddle alights
the middle of the image with the middle of the largest item, bottom aligns
the bottom of the image with the bottom of the text and absbottom aligns
the bottom of the image with the bottom of the largest item.
FIGURE 24.8  WWW page showing image alignment

24.7 Horizontal lines
A horizontal line can be added with the <HR> tag. Most browsers allow extra
parameters, such as:
SIZE= n – which defines that the height of the rule is n pixels.
WIDTH=w – which defines that the width of the rule is w pixels or as a
percentage.
ALIGN=direction – where direction refers to the alignment of the rule Valid
options for direction are left, right or center.
NOSHADE – which defines that the line should be solid with no shading.
HTML script 24.9 gives some example horizontal lines and Figure 24.9 shows
an example output.
FIGURE 24.9  WWW page showing horizontal lines

24.8 Exercises
24.8.1. The home page for this book can be found at the URL:
   Access this page and follow any links it contains.
24.8.2. If possible, create a WWW page with the following blinking text:
24.8.3. The last part of the server name normally gives an indication of the
country where the server is located (for example www.fredco.co.uk is
located in the UK). Determine which countries use the following country
names:
(a) de
(b) nl
(c) it
(d) se
(e) dk
(f) sg
(g) ca
(h) ch
(i) tr
(j) jp
(k) au
Determine some other country identifier names.
24.8.4. Determine the HTML colour represent for the following:
(a) red
(b) green
(c) blue
(d) white
(e) black
24.8.5. Determine the HTML for the background, text and link colour:

24.8.6. Determine the error in the following HTML script:

25
Further HTML
25.1 Introduction
Chapter 24 introduced HTML; this chapter discusses some of HTML’s more
advanced features. HTML differs from compiled languages, such as C and
Pascal, in that the HTML text file is interpreted by an interpreter (the browser)
while languages such as C and Pascal must be precompiled before they can be
run. HTML thus has the advantage that it does not matter if it is the operating
system, the browser type or the computer type that reads the HTML file, as the
file does not contain any computer specific code. The main disadvantage of
interpreted files is that the interpreter does less error checking as it must produce
fast results.
The basic pages on the WWW are likely to evolve around HTML and while
HTML can be produced manually with a text editor, it is likely that, in the
coming years, there will be an increase in the amount of graphically-based tools
that will automatically produce HTML files. Although these tools are graphics-
based they still produce standard HTML text files. Thus a knowledge of HTML
is important as it defines the basic specification for the presentation of WWW
pages.
25.2 Anchors
An anchor allows users to jump from a reference in a WWW page to another
anchor point within the page. The standard format is:
where anchor name is the name of the section which is referenced. The </A>
tag defines the end of an anchor name. A link is specified by:

followed by the </A> tag. HTML script 25.1 shows a sample script with four
anchors and Figure 25.1 shows a sample output. When the user selects one of the
references, the browser automatically jumps to that anchor. Figure 25.2 shows
the output screen when the user selects the #Token reference. Anchors are
typically used when an HTML page is long or when a backwards or forwards
reference occurs (such as a reference within a published paper).
FIGURE 25.1  Example window with references

FIGURE 25.2  Example window with references
25.3 Tables
Tables are one of the best methods to display complex information in a simple
way. Unfortunately, in HTML they are relatively complicated to set up. The start
of a table is defined with the <TABLE> tag and the end of a table by </TABLE>. A
row is defined between the <TR> and </TR>, while a table header is defined
between <TH> and </TH>. A regular table entry is defined between <TD> and
</TD>.HTML script 25.2 shows an example of a table with links to other HTML
pages. The BORDER=n option has been added to the <TABLE> tag to define the
thickness of the table border (in pixels). In this case the border size has a
thickness of 10 pixels.

FIGURE 25.3  Example window from example Java script
Other options in the <TABLE> tag are:
• WIDTH=x, HEIGHT=y – defines the size of the table with respect to the full
window size. The parameters x and y are either absolute values in pixels
for the height and width of the table or are percentages of the full window
size.
• CELLSPACING=n – defines the number of pixels desired between each cell
where n is the number of pixels (note that the default cell spacing is 2

pixels).
An individual cell can be modified by adding options to the <TH> or <TD> tag.
These include:
• WIDTH=x, HEIGHT=y – defines the size of the table with respect to the table
size. The parameters x and y are either absolute values in pixels for the
height and width of the table or are percentages of the table size.
• COLSPAN=n – defines the number of columns the cell should span.
• ROWSPAN=n – defines the number of rows the cell should span.
• ALIGN=direction – defines how the cell’s contents are aligned horizontally.
Valid options are left, center or right.
• VALIGN=direction – defines how the cell’s contents are aligned vertically.
Valid options are top, middle or baseline.
• NOWRAP – informs the browser to keep the text on a single line (that is, with no
line breaks).
HTML script 25.3 shows an example use of some of the options in the
<TABLE> and <TD> options. In this case the text within each row is centre
aligned. On the second row the second and third cells are merged using the
COLSPAN=2 option. The first cell of the second and third rows have also been
merged using the ROWSPAN=2 option. Figure 25.4 shows an example output. The
table width has been increased to 90% of the full window, with a width of 50%.
FIGURE 25.4  Example window from example script

25.4 CGI scripts
CGI (Common Gateway Interface) scripts are normally written in either C or
Perl and are compiled to produce an executable program. They can also come
precompiled or in the form of a batch file. Perl has the advantage in that it is a
script that can be easily run on any computer, while a precompiled C program
requires to be precompiled for the server computer.
CGI scripts allow the user to interact with the server and store and request
data. They are often used in conjunction with forms and allow an HTML
document to analyze, parse and store information received from a form. On most
UNIX-type systems the default directory for CGI scripts is cgi-bin.
25.5 Forms
Forms are excellent methods of gathering data and can be used in conjunction
with CGI scripts to collect data for future use.
A form is identified between the <FORM> and </FORM> tags. The method used
to get the data from the form is defined with the METHOD= “POST”. The

ACTION option defines the URL script to be run when the form is submitted.
Data input is specified by the <INPUT TYPE> tag. HTML script 25.4 form has the
following parts:
• <form action="cgi-binAnyForm2” method="POST"> – which defines the
start of a form and when the “submit” option is selected the cgi script
cgi-binAnyForm2 will be automatically run.
• <input type="submit” value="Send Feedback">-which causes the
program defined in the action option in the <form> tag to be run. The
button on the form will contain the text “Send Feedback”, see Figure 25.5
for a sample output screen.
FIGURE 25.5  Example window showing an example form
• <input type=“reset” value=“Reset Form”> – which resets the data in the form.
The button on the form will contain the text “Reset Form”, see Figure
25.5 for a sample output screen.
• <input type="hidden” name="AnyFormTo” value= “f.bloggs
@toytown.ac.uk"> – which passes a value of f.bloggs@toytown.ac.uk
which has the parameter name of “AnyFormTo”. The program
AnyForm2 takes this parameter and automatically sends it to the email
address defined in the value (that is, f.bloggs@toytown.ac.uk).
• <input type="hidden” name="AnyFormSubject” value="Feedback form"> –

which passes a value of Feedback form which has the parameter name of
“AnyFormSubject”. The program AnyForm2 takes this parameter and
adds the text “Feedback form” in the text sent to the email recipient (in
this case, f.bloggs@toytown.ac.uk).
• Surname <input name="Surname"> – which defines a text input and assigns
this input to the parameter name Surname.
• <textarea name="Address” rows=2 cols=40> </textarea> – which
defines a text input area which has two rows and has a width of 40
characters. The thumb bars appear at the right-hand side of the form if the
text area exceeds more than 2 rows, see Figure 25.5.
In this case the recipient (f.bloggs@toytown.ac.uk) will receive an email with
the contents:

The extra options to the <input> tag are size=”n“, where n is the width of the
input box in characters, and maxlength=”m“, where m is the maximum number
of characters that can be entered, in characters. For example:
defines that the input type is text, the width of the box is 15 characters and the
maximum length of input is 10 characters.
25.5.1 Input Types
The type options to the <input> tag are defined in Table 25.1. HTML script
25.5 gives a few examples of input types and Figure 25.6 shows a sample output.
Table 25.1
Input type options


FIGURE 25.6  Example window with different input options
25.5.2 Menus
Menus are a convenient method of selecting from multiple options. The
<SELECT> tag is used to define start of a list of menu options and the
</SELECT> tag defines the end. Menu elements are then defined with the
<OPTION> tag. The options defined within the <SELECT> are:
• NAME=”name“ – which defines that name is the variable name of the menu.

This is used when the data is collected by the server.
• SIZE=“n” – which defines the number of options which are displayed in the
menu.
HTML script 25.6 shows an example of a menu. The additional options to the
<OPTION> tag are:
• SELECTED – which defines the default selected option.
• VALUE=”val“ – where val defines the name of the data when it is collected by
the server.
FIGURE 25.7  Example window showing an example form
25.6 Multimedia
If the browser cannot handle all the file types it may call on other application
helpers to process the file. This allows other ‘third-party’ programs to integrate
into the browser. Figure 25.8 shows an example of the configuration of the
helper programs. The options in this case are:

FIGURE 25.8  Example window showing an example form
• View in browser.
• Save to disk.
• Unknown: prompt user.
• Launch an application (such as an audio playback program or MPEG viewer).
For certain applications the user can select as to whether the browser
processes the file or another application program processes it. Helper programs
make upgrades in helper applications relatively simple and also allow new file
types to be added with an application helper. Typically when a program is
installed which can be used with a browser it will prompt the user to
automatically update the helper application list so that it can handle the given
file type(s).
Each file type is defined by the file extension, such as .ps for postscript files,
.exe for a binary executable file, and so on. These file extensions have been
standardized in MIME (Multipurpose Internet Mail Extensions) specification.
Table 25.2 shows some typical file extensions.
Table 25.2
Input type options
Mime type
Extension
Typical action
application/octet-stream
exe, bin
Save

application/postscript
ps, ai, eps
Ask user
application/x-compress
Z
Compress program
application/x-gzip
gz
GZIP compress program
application/x-javascript
js, mocha
Ask user
application/x-msvideo
avi
Audio player
application/x-perl
P1
Save
application/x-tar
tar
Save
application/x-zip-compressed
zip
ZIP program
audio/basic
au, snd
Audio player
image/gif
gif
Browser
image/jpeg
jpeg, jpg, jpe
Browser
image/tiff
tif, tiff
Graphics viewer
image/x-MS-bmp
bmp
Graphics viewer
text/html
htm, html
Browser
text/plain
text, txt
Browser
video/mpeg
mpeg, mpg, mpe, mpv, vbs, mpegv
Video player
video/quicktime
qt, mov, moov
Video player
25.7 Exercises
25.7.1. Construct a WWW page with anchor points for the following:
Select the network you wish to find out about:
Ethernet
Token ring
FDDI
Ethernet
Ethernet is the most widely used networking technology used in LAN (Local
Area Network). In itself it cannot make a network and needs some other protocol
such as TCP/IP or SPX/IPX to allow nodes to communicate. Unfortunately,
Ethernet in its standard form does not cope well with heavy traffic. Its has many
advantages, though, including:
• Networks are easy to plan and cheap to install.
• Network components are cheap and well supported.
• It is well-proven technology which is fairly robust and reliable.
• Simple to add and delete computers on the network.
• Supported by most software and hardware systems.

Token ring
Token ring networks were developed by several manufacturers, the most
prevalent being the IBM Token Ring. Token ring networks cope well with high
network traffic loadings. They were at one time extremely popular but their
popularity has since been overtaken by Ethernet. Token ring networks have, in
the past, suffered from network management problems and poor network fault
tolerance.
Token ring networks are well suited to situations which have large amounts of
traffic and also work well with most traffic loadings. They are not suited to large
networks or networks with physically remote stations. Their main advantage is
that they cope better with high traffic rates than Ethernet, but require a great deal
of maintenance especially when faults occur or when new equipment is added to
or removed from the network. Many of these problems have now been overcome
by MAUs (multi-station access units), which are similar to the hubs using in
Ethernet.
FDDI
A token-passing mechanism allows orderly access to a network. Apart from
token ring the most commonly used token-passing network is the Fiber
Distributed Data Interchange (FDDI) standard. This operates at 100 Mbps and,
to overcome the problems of line breaks, has two concentric token rings. Fibre
optic cables have a much high specification over copper cables and allow
extremely long interconnection lengths. The maximum circumference of the ring
is 100 km (62 miles), with a maximum 2 km between stations (in FDDI stations
are also known as stations). It is thus an excellent mechanism for connecting
interconnecting networks over a city or a campus. Up to 500 stations can connect
to each ring with a maximum of 1,000 stations for the complete network. Each
station connected to the FDDI highway can be a normal station or a bridge to a
conventional local area network, such as Ethernet or token ring.
25.7.2. Construct a WWW glossary page with the following terms:
Address
A unique label for the location of data or the identity of a communications device.
Address Resolution
Protocol (ARP)
A TCP/IP process which maps an IP address to an Ethernet address.
American National
Standards
Institute (ANSI)
ANSI is a non-profit organization which is made up of expert committees that publish
standards for national industries.
American Standard
An ANSI-defined character alphabet which has since been adopted as a standard
international alphabet for the interchange of characters

Code for
Information
Interchange
(ASCII)
international alphabet for the interchange of characters.
Amplitude
modulation (AM)
Information is contained in the amplitude of a carrier.
Amplitude-Shift
Keying (ASK)
Uses two, or more, amplitudes to represent binary digits. Typically used to transmit
binary data over speech-limited channels.
Application layer
The highest layer of the OSI model.
Asynchronous trans-
mission
Transmission where individual characters are sent one-by-one. Normally each
character is delimited by a start and stop bit. With asynchronous communication
the transmitter and receiver only have to be roughly synchronized.
25.7.3. Construct a WWW page which can be used to enter a person’s CV (note,
use a form). The basic fields should be:
Name:
Address:
Email address:
Telephone number:
Experience:
Interests:
Any other information:
25.7.4. Write an HTML script which displays the following timetable.
25.7.5. Design your own home page with a basic user home page (index.html)
which contains links to a basic CV page (for example, it could be named
cv.html) and a page which lists your main interests (myinter.html).
Design one of the home pages with a list of links and another with a table
of links. If possible incorporate graphics files into the pages.

26
JavaScript
26.1 Introduction
Computer systems contain a microprocessor which controls the operation of the
computer. The microprocessor only understands binary information and operates
on a series of binary commands known as machine code. It is extremely difficult
to write large programs in machine code, so that high-level languages are used
instead. A low-level language is one which is similar to machine code and
normally involves the usage of keyword macros to replace machine code
instructions. High-level languages have a syntax that is almost like written
English and thus make programs easy to read and to modify. In most programs
the actual operation of the hardware is invisible to the programmer. A compiler
changes the high-level language into machine code. Typical high-level
languages include C/C++, BASIC, COBOL, FORTRAN and Pascal; an example
of a low-level language is 80486 Assembly Language.
Java is a high-level language that has been developed specifically for the
WWW and is well suited to networked applications. It was originally developed
by Sun Microsystems and is based on C++ (but with less of the difficulties of
C++). Most new versions of Web browsers now support its usage. Java’s main
attributes are:
• It runs either as a stand-alone program or it can run within the Web browser.
When run within the browser the Java program is known as an applet.
• Java is a portable language and applets can run on any type of microprocessor
type (such as a PC based on Intel 80486 or Pentium, or a Motorola-based
computer).
• Java applets are hardware and operating system independent. For example,
the program itself does not have to interface directly to the hardware such
as a video adapter or mouse. Typical high-level languages, such as
C/C++ and Pascal, produce machine-dependent machine code, and can
thus only be executed on a specific computer or operating systems.

• Java allows for a client/server approach where the applet can run on the
remote computer which thus reduces the loading on the local computer
(typically the remote computer will be a powerful multitasking computer
with enhanced computer architecture).
• A Java compiler creates stand-alone programs or applets. Many new versions
of browsers have an integrated Java compiler.
Figure 26.1 shows the main functional differences between a high-level
language, a Java applet and JavaScript. JavaScript is interpret by the browser,
whereas a Java applet is compiled to a virtual machine code which can be run on
any computer system. The high-level language produces machine-specific code.
FIGURE 26.1  Differences between C++/Java and JavaScript
A normal C++ program allows access to hard-disk drives. This would be a
problem on the Web as unsolicited users (‘hackers’) or novice users could cause
damage on the Web server. To overcome this Java does not have any mechanism
for file input/output (I/O). It can read standard file types (such as GIF and JPG)
but cannot store changes to the Web server. A Java developers kit is available,
free of charge, from http://java.sun.com.
The following is an example HTML script and highlighted JavaScript. Figure
26.2 gives the browser output.

FIGURE 26.2  Example window from example JavaScript
26.2 JavaScript language
Programming languages can either be compiled to produce an executable
program or they can be interpreted while the user runs the program. Java is a
program language which needs to be compiled before it is used. It thus cannot be
used unless the user has the required Java compiler. JavaScript, on the other
hand, is a language which is interpreted by the browser. It is similar in many
ways to Java but allows the user to embed Java-like code into an HTML page.
JavaScript supports a small number of data types representing numeric, Boolean,
and string values and is supported by most modern WWW browsers, such as
Microsoft Internet Explorer and Netscape.
HTML is useful when pages are short and do not contain expressions, loops or

decisions. JavaScript allows most of the functionality of a high-level language
for developing client and server Internet applications. It can be used to respond
to user events such as mouse clicks, form input, and page navigation.
A major advantage that JavaScript has over HTML is that it supports the use
of functions without any special declarative requirements. It is also simpler to
use than Java because it has easier syntax, specialized built-in functionality, and
minimal requirements for object creation.
Important concepts in Java and JavaScript are objects. Objects are basically
containers for values. The main differences between JavaScript and Java are:
• JavaScript is interpreted by the client, while Java is compiled on the server
before it is executed.
• JavaScript is embedded into HTML pages, while Java applets are distinct
from HTML and accessed from HTML pages.
• JavaScript has loose typing for variables (that is, a variables data type does
not have to be declared), while Java has strong typing (that is, a variables
data type must always be declared before it is used).
• JavaScript has dynamic binding where object references are checked at run-
time. Java has static binding where object references must exist at
compile-time.
26.3 JavaScript values, variables and literals
JavaScript values, variables and literals are similar to the C programming
language. Their syntax is discussed in this section.
26.3.1 Values
The four different types of values in JavaScript are:
• Numeric value, such as 12 or 91.5432.
• Boolean values which are either TRUE or FALSE.
• String types, such as ‘Fred Bloggs’.
• A special keyword for a NULL value
Numeric values differ from those in most programming languages in that
there is no explicit distinction between a real value (such as 91.5432) and an
integer (such as 12).
26.3.2 Data Type Conversion

JavaScript differs from Java in that variables do not need to have their data types
defined when they are declared (loosely typed). Data types are then
automatically converted during the execution of the program. Thus a variable
could be declared with a numeric value as:
and then in the same script it could be assigned a string value, such as:
The conversion between numeric values and strings in JavaScript is easy, as
numeric values are automatically converted to an equivalent string. For example:
Sample run 26.1 gives the output from this script. It can be seen that x and y
have been converted to a string value (in this case, “13” and “10”) and that x+y
in the string conversion statement has been converted to “1310”. If a
mathematical operation is carried out (z=x+y) then z will contain 23 after the
statement is executed.

JavaScript provides several special functions for manipulating string and
numeric values:
• The eval (string) function which converts a string to a numerical value.
• The parseInt (string [,radix]) function which converts a string into an
integer of the specified radix (number base). The default radix is base–10.
• The parseFloat (string) function which converts a string into a floating-point
value.
26.3.3 Variables
Variables are symbolic names for values within the script. A JavaScript
identifier must either start with a letter or an underscore (‘_’), followed by
letters, an underscore or any digit (0–9). Like C, JavaScript is case sensitive so
that variables with the same character sequence but with different cases for one
or more characters are different. The following are different variable names:
26.3.4 Variable Scope
A variable can be declared by either simply assigning it a value or by using the
var keyword. For example, the following declares to variables Valuel and
Value2:
A variable declared within a function is taken as a local variable and can only
be used within that function. A variable declared outside a function is a global
variable and can be used anywhere in the script. A variable which is declared
locally which is already declared as global variable needs to be declared with the
var keyword, otherwise the use of the keyword is optional.
26.3.5 Literals
Literal values have fixed values within the script. Various reserved forms can be

used to identify special types, such as hexadecimal values, exponent format, and
so on. With an integer the following are used:
• If the value is preceded by a 0x then the value is a hexadecimal value (that is,
base 16). Examples of hexadecimal values are 0×1FFF, 0xCB.
• If the value is preceded by a 0 then the value is an octal value (that is, base 8).
Examples of octal values are 0777, 010.
• If it is not preceded by either a 0x or a 0 then it is a decimal integer.
Floating-point values
Floating-point values are typically represented as a real value (such as 1.342) or
in exponent format. Some exponent format values are:
Value
Exponent format
0.000001
le-6
1342000000
1.342e9
Boolean
The true and false literals are used with Boolean operations.
Strings
In C a string is represented with double quotes (“str”) whereas JavaScript
accepts a string within double (“) or single (‘) quotation marks. Examples of
strings are:
26.4 Expressions and operators
The expressions and operators used in Java and JavaScript are based on C and
C++. This section outlines the main expressions and operators used in
JavaScript.
26.4.1 Expressions
As with C, expressions are any valid set of literals, variables, operators and

expressions that evaluate to a single value. There are basically two types of
expression, one which assigns a value to a variable and the other which simply
gives a single value. A simple assignment is:
which assigns the value of 21 to value (note that the result of the expression is
21).
The result from a JavaScript expression can either be:
• A numeric value.
• A string.
• A logical value (true or false).
26.5 JavaScript operators
Both Java and JavaScript have a rich set of operators, of which there are four
main types:
• Arithmetic.
• Logical.
• Bitwise.
• Relational.
26.5.1 Arithmetic
Arithmetic operators operate on numerical values. The basic arithmetic
operations are add (+), subtract (–), multiply (*), divide (/) and modulus division
(%). Modulus division gives the remainder of an integer division. The following
gives the basic syntax of two operands with an arithmetic operator.
The assignment operator (=) is used when a variable ‘takes on the value’ of an
operation. Other short-handed operators are used with it, including add equals
(+=), minus equals (–=), multiplied equals (*=), divide equals (/=) and modulus
equals (%=). The following examples illustrate their uses.
Statement
Equivalent

x+=3.0
x=x+3.0
voltage/=sqrt(2)
voltage=voltage/sqrt(2)
bit mask *=2
bit mask=bit mask*2
In many applications it is necessary to increment or decrement a variable by 1.
For this purpose Java has two special operators; ++ for increment and –– for
decrement. These can either precede or follow the variable. If they precede, then
a pre-increment/decrement is conducted, whereas if they follow it, a post-
increment/decrement is conducted. The following examples show their usage.
Statement
Equivalent
no_values++
no values=no values+1
i – –
i=i-l
Table 26.1 summarizes the arithmetic operators.
Table 26.1
Arithmetic operators
Operator
Operation
Example
-
subtraction or minus
5–4→1
+
addition
4+2→6
*
multiplication
4*3→12
/
division
4/2→2
%
modulus
13%3→1
+=
add equals
χ += 2 is equivalent to x=x+2
-=
minus equals
x -= 2 is equivalent to x=x–2
/ =
divide equals
x /= y is equivalent to x=x/y
*=
multiplied equals
x *= 32 is equivalent to x=x* 32
=
assignment
x = 1
++
increment
Count++ is equivalent to Count=Count+1
decrement
Sec – - is equivalent to Sec=Sec-l
26.5.2 Relationship
The relationship operators determine whether the result of a comparison is
TRUE or FALSE. These operators are greater than (>), greater than or equal to

(<=), less than (<), less than or equal to (>=), equal to (==) and not equal to (!=).
Table 26.2 lists the relationship operators.
Table 26.2
Relationship operators
26.5.3 Logical (TRUE Or FALSE)
A logical operation is one in which a decision is made as to whether the
operation performed is TRUE or FALSE. If required, several relationship
operations can be grouped together to give the required functionality. C assumes
that a numerical value of 0 (zero) is FALSE and that any other value is TRUE.
Table 26.3 lists the logical operators.
Table 26.3
Logical operators
The logical AND operation will yield a TRUE only if all the operands are
TRUE. Table 26.4 gives the result of the AND (&&) operator for the operation
A&& B. The logical OR operation yields a TRUE if any one of the operands is TRUE.
Table 26.4 gives the logical results of the OR (| |) operator for the statement A | | B

and also gives the logical result of the NOT (!) operator for the statement ! A.
Table 26.4
Logical operations
26.5.4 Bitwise
The bitwise logical operators work conceptually as follows:
• The operands are converted to 32-bit integers, and expressed a series of bits
(zeros and ones).
• Each bit in the first operand is paired with the corresponding bit in the second
operand: first bit to first bit, second bit to second bit, and so on.
• The operator is applied to each pair of bits, and the result is constructed
bitwise.
The bitwise operators are similar to the logical operators but they should not
be confused as their operation differs. Bitwise operators operate directly on the
individual bits of an operand(s), whereas logical operators determine whether a
condition is TRUE or FALSE.
Numerical values are stored as bit patterns in either an unsigned integer
format, signed integer (2’s complement) or floating-point notation (an exponent
and mantissa). Characters are normally stored as ASCII characters.
The basic bitwise operations are AND (&), OR (|), 1s complement or bitwise
inversion (~), XOR (⁁), shift left (<<) and shift right (>>). Table 26.5 gives the
results of the AND bitwise operation on two bits Bit1 and Bit2.
Table 26.5
Bitwise operations

The Boolean bitwise instructions operate logically on individual bits. The
XOR function yields a 1 when the bits in a given bit position differ, the AND
function yields a 1 only when the given bit positions are both 1’s. The OR
operation gives a 1 when any one of the given bit positions are a 1. For example:
To perform bit shifts, the <<, >> and >>> operators are used. These operators
shift the bits in the operand by a given number defined by a value given on the
right-hand side of the operation. The left shift operator (<<) shifts the bits of the
operand to the left and zeros fill the result on the right. The sign-propagating
right shift operator (>>) shifts the bits of the operand to the right and zeros fill
the result if the integer is positive; otherwise it will fill with 1s. The zero-filled
right shift operator (>>>) shifts the bits of the operand to the right and fills the
result with zeros. The standard format is:
26.5.5 Precedence
There are several rules for dealing with operators:
• Two operators, apart from the assignment, should never be placed side by
side. For example, x * % 3 is invalid.
• Groupings are formed with parentheses; anything within parentheses will be
evaluated first. Nested parentheses can also be used to set priorities.
• A priority level or precedence exists for operators. Operators with a higher
precedence are evaluated first; if two operators have the same
precedence, then the operator on the left-hand side is evaluated first. The

priority levels for operators are as follows:
The assignment operator has the lowest precedence.
26.5.6 Conditional Expressions
Conditional expressions can result in one of two values based depending on a
condition. The syntax is:
If the expression is true then valuel is executed else value2 is executed. For
example:
This will assign the string ‘positive’ to sign if the value of val is greater than
or equal to 0, else it will assign ‘negative’.
26.5.7 String Operators
The normal comparison operators, such as <, >, >=, ==, and so on, can be used
with strings. In addition, the concatenation operator (+) can be used to
concatenate two string values together. For example:

will result in the string
26.6 JavaScript statements
JavaScript statements are similar to C and allow a great deal of control of the
execution of a script. The basic categories are:
• Conditional statements, such as if … else.
• Repetitive statements, such as for, while, break and continue.
• Comments, using either the C++ style for single-line comments (//) or
standard C multi-line comments (/*…*/).
• Object manipulation statements and operators, such as for … in, new,
this, and with.
26.7 Conditional statements
Conditional statements allow a program to make decisions on the route through a
program.
26.7.1 If … Else
A decision is made with the if statement. It logically determines whether a
conditional expression is TRUE or FALSE. For a TRUE, the program executes
one block of code; a FALSE causes the execution of another (if any). The
keyword else identifies the FALSE block. Braces are used to define the start
and end of the block.
Relationship operators (>,<,>=,<=,==, ! =) yield a TRUE or FALSE from
their operation. Logical statements (&&, | |, !) can then group these together
to give the required functionality. If the operation is not a relationship, such as
bitwise or an arithmetic operation, then any non-zero value is TRUE and a zero
is FALSE.
The following is an example syntax of the if statement. If the statement block
has only one statement the braces ({}) can be excluded.

The following is an example format with an else extension.
It is possible to nest if … else statements to give a required functionality. In
the next example, statement block1 is executed if expression1 is TRUE. If it is
FALSE then the program checks the next expression. If this is TRUE the
program executes statement block2, else it checks the next expression, and so on.
If all expressions are FALSE then the program executes the final else statement
block, in this case, statement block 4:
26.8 Loops
26.8.1 For()
Many tasks within a program are repetitive, such as prompting for data, counting
values, and so on. The for loop allows the execution of a block of code for a
given control function. The following is an example format; if there is only one
statement in the block then the braces can be omitted.

where:
starting condition
—
the starting value for the loop;
test condition
—
if test condition is TRUE the loop will continue execution;
operation
—
the operation conducted at the end of the loop.
26.8.2 While ()
The while() statement allows a block of code to be executed while a specified
condition is TRUE. It checks the condition at the start of the block; if this is
TRUE the block is executed, else it will exit the loop. The syntax is:
If the statement block contains a single statement then the braces may be
omitted (although it does no harm to keep them).
26.9 Comments
Comments are author notations that explain what a script does. Comments are
ignored by the interpreter. JavaScript supports Java-style comments:
• Comments on a single line are preceded by a double-slash (/ /).
• Multiline comments can be preceded by /* and followed by */.
The following example shows two comments:
26.10 Functions

JavaScript supports modular design using functions. A function is defined with a
JavaScript with the function reserved word and the code within the function is
defined within curly brackets. The standard format is:
where the parameters (param1, param2, and so on) are the values passed into
the function. Note that the return value (val) from the function is only required
when a value is returned from the function.
JavaScript 26.2 gives an example with two functions (add() and mult ()). In
this case the values value1 and value2 are passed into the variables a and b
within the add() function, the result is then sent back from the function into
value3.
Table 26.6
Example JavaScript

26.11 Objects and properties
JavaScript is based on a simple object-oriented paradigm, where objects are a
construct with properties that are JavaScript variables. Each object has properties
associated with it and can be accessed with the dot notation, such as:
26.12 Document objects
The document object contains information on the currently opened document.
HTML expressions can be displayed with the 
document.write() or
document.writeln() functions. The standard format is:

which displays one or more expressions to the specified window. To display
to the current window the document.write() is used. If a display to a specified
window then the window reference is defined, for example:
is used to output to the mywin window.
The document object can also be used to display HTML properties. The
standard HTML format is:
These and other properties can be accessed within a JavaScript with:
Table 26.7 shows an example.
Table 26.7
Example JavaScript

26.13 Event handling
JavaScript has event handlers which, on a certain event, causes other events to
occur. For example, if a user clicks the mouse button on a certain menu option
then the event handler can be made to carry-out a particular action, such as
adding to numbers together. Table 26.8 outlines some event handlers.
Table 26.8
Example event handers

26.14 Window objects
The window object is the top-level object for documents and can be used to open
and close windows.
26.14.1 Window Alert
The alert window shows an alert message to the users. Its format is:
Table 26.9
Example JavaScript

26.14.2 Opening And Closing Windows
Windows are opened with window.open() and closed with window.close().
Examples are:
or to open a window it is possible to simply use open() and to close the
current window the close() function is used. The standard format is:
where
winVar is the name of a new window which can be used to refer to a given
window.
winName is the window name given to the window;
features is a comma-separated list with any of the following:

26.14.3 Window Confirm
The window confirm is used to display a confirm dialogue box with a specified
message and the OK and Cancel buttons. If the user selects the OK button then
the function returns a TRUE, else it returns a FALSE. Table 26.10 gives an
example of the confirm window. In this case when the Exit button is selected
then the function ConfirmExit() is called. In this function the user is asked to
confirm the exit with the confirm window. If the user selects OK then the
window is closed (if it is the only window open then the browser quits).
Table 26.10
Example JavaScript with confirm window
26.14.4 Window Prompt
The window prompt displays a prompt dialog box which contains a message and
an input field. Its standard format is:
26.15 Object manipulation statements and
operators

JavaScript has several methods in which objects can be manipulated. These
include: the new operator, the this keyword, the for … in statement, and the
with statement.
26.15.1 This Keyword
The this keyword is used to refer to the current object. The general format is:
JavaScript 26.5 gives an example of the this keyword. In this case this is
used to pass the property values of the input form. This is then passed to the
function checkval() when the onBlur event occurs.
26.15.2 New Operator
The new operator is used to define a new user-defined object type or of one of
the pre-defined object types, such as array, Boolean, date, function and math.
JavaScript 26.6 gives an example which creates an array object with 6 elements
and then assigns strings to each of the array. Note that in Java the first element
of the array is indexed as 0.

Typically the new operator is used to create new data objects. For example:
26.15.3 For … In
The for … in statement is used to iterate a variable through all its properties. In
general its format is:

26.15.4 With
The with statement defines a specified object for a set of statements. A with
statement looks as follows:
For example JavaScript 26.7 contains calls to the Math object for the PI
property and cos and sin methods. JavaScript 26.8 then uses the with statement
to define the Match object is the default object.

26.16 Exercises
26.16.1. Explain how Java differs from JavaScript.
26.16.2. Explain the main advantages of using Java rather than a high-level
language, such as C++ or Pascal.
26.16.3. Implement the JavaScripts in the text and test their operation.
26.16.4. Write a JavaScript in which the user enters a value and the script
calculates the square of that value.
26.16.5. Write a JavaScript in which the user initially enters their name. The
script should then test the entered name and if it is not ‘FRED’, ‘BERT’
or ‘FREDDY’ then the browser exits.

27
Java (Introduction)
27.1 Introduction
Java has the great advantage over conventional software languages in that it
produces code which is computer hardware independent. This is because the
compiled code (called bytecodes) is interpreted by the WWW browser.
Unfortunately this leads to slower execution, but as much of the time is spent in
graphical user interface programs, to update the graphics, then the overhead is,
as far as the user is concerned, not a great one.
The other advantages that Java has over conventional software languages
include:
• It is a more dynamic language than C/C++ and Pascal, and was designed to
adapt to an evolving environment. It is extremely easy to add new
methods and extra libraries without affecting existing applets. It is also
useful in Internet applications as it supports most of the standard image
audio and video formats.
• It has networking facilities built into the language (support for TCP/IP
sockets, URLs, IP addresses and datagrams).
• While Java is based on C and C++ it avoids some of the difficult areas of
C/C++ code (such as pointers and parameter passing).
• It supports client/server applications where the Java applets run on the server
and the client receives the updated graphics information. In the most
extreme case the client can simply be a graphics terminal which runs Java
applets over a network. The small ‘black-box’ networked computer is one
of the founding principles of Java, and it is hoped in the future that small
Java-based computers could replace the complex PC/workstation for
general purpose applications, like accessing the Internet or playing
network games. This ‘black-box’ computer concept is illustrated in
Figure 27.1.

FIGURE 27.1  Internet accessing
Most existing Web browsers are enabled for Java applets (such as Internet
Explorer 3.0 and Netscape 2.0 and later versions). Figure 27.2 shows how Java
applets are created. First the source code is produced with an editor, next a Java
compiler compiles the Java source code into bytecode (normally appending the
file name with .class). An HTML page is then constructed which has the
reference to the applet. After this a Java-enabled browser or applet viewer can
then be used to run the applet.
FIGURE 27.2  Constructing Java applets
The Java Development Kit (JDK) is available, free, from Sun Microsystems
from the WWW site http://java.sun.com. This can be used to compile Java
applets and stand alone programs. There are versions for Windows NT/95, Mac
or UNIX-based systems with many sample applets.
Table 27.1 shows the main files used in the PC version. Figure 27.3 shows the
directory structure of the JDK tools. The Java compiler, Java interpreter and
applet viewer programs are stored in the bin directory. On the PC, this directory

is normally set up in the PATH directory, so that the Java compiler can be called
while the user is in another directory. The following is a typical setup (assuming
that the home directory is C:\JAVA):
Table 27.1
JDK programs
File
Description
Javac.exe
Java compiler
Java.exe
Java interpreter
Appletviewer.exe
Applet viewer for testing and running applets
classes.zip
It is needed by the compiler and interpreter
javap.exe
Java class disassembler
javadoc.exe
Java document generator
jbd.exe
Java debugger
FIGURE 27.3  Directory structure of JDK

The lib directory contains the classes.zip file which is a zipped-up version
of the Java class files. These class files are stored in the directories below the
src/java directory. For example, the io classes (such as File.java and
InputStream.java) are used for input/output in Java, the awt classes (such as
Panel.java and Dialog.java) are used to create and maintain windows. These
and other classes will be discussed later.
The include directory contains header files for integrating C/C++ programs
with Java applets and the demo directory contains some sample Java applets.
27.1.1 Applet Tag
An applet is called from within an HTML script with the APPLET tag, such as:
which loads an applet called Test.class and sets the applet size to 200 pixels
wide and 300 pixels high. Table 27.2 discusses some optional parameters.
Table 27.2
Other applet HTML parameters

27.1.2 Applet Viewer
A useful part of the JDK tools is an applet viewer which is used to test applets
before they are run within the browse. The applet viewer on the PC version is
AppletViewer.exe and the supplied argument is the HTML file that contains the
applet tag(s). It then runs all the associated applets in separate windows.
27.2 Creating an applet
Java applet 27.1 shows a simple Java applet which displays two lines of text and
HTML script 27.1 shows how the applet integrates into an HTML script.
First the Java applet (j1.java) is created. In this case the edit program is
used. The directory listing below shows that the files created are j1.java and
j1.html (Note that Windows NT/95 displays the 8.3 filename format on the left
hand side of the directory listing and the long filename on the right hand side).

Next the Java applet is compiled using the javac.exe program. It can be seen
from the listing that, if there are no errors, the compiled file is named j1.class.
This can then be used, with the HTML file, to run as an applet.

27.3 Applet basics
Java applet 27.1 recaps the previous Java applet. This section analyzes the main
parts of this Java applet.
27.3.1 Import Statements
The import statement allows previously written code to be included in the
applet. This code is stored in class libraries (or packages), which are compiled
Java code. For the JDK tools, the Java source code for these libraries is stored in
the src/java directory.
Each Java applet created begins with:
These include the awt and applet class libraries. The awt class provide code
that handles windows and graphics operations. The applet in Java script 27.1
uses awt code, for example, displays the ‘This is ..’ message within the applet
window. Likewise the applet uses the applet code to let the browser run the
applet.
The default Java class libraries are stored in the classes.zip file in the lib
directory. This file is in a compressed form and should not be unzip before it is
used. The following is an outline of the file.

Table 27.3 lists the main class libraries and some sample libraries.
Table 27.3
Class libraries

It can be seen that upgrading the Java compiler is simple, as all that is required
is to replace the class libraries with new ones. For example, if the basic language
is upgraded then java.lang.* files is simply replaced with a new version. The
user can also easily add new class libraries to the standard ones. A complete
listing of the classes is given in Appendix A.
27.3.2 Applet Class
The start of the applet code is defined in the form:
which informs the Java compiler to create an applet named j1 that extends the
existing Applet class. The public keyword at the start of the statement allows
the Java browser to run the applet, while if it is omitted the browser cannot
access your applet.
The class keyword is used to creating a class object named j1 that extends
the applet class. After this the applet is defined between the left and right braces
(grouping symbols).
27.3.3 Applet Functions

Functions allow Java applets to be split into smaller sub-tasks called functions.
These functions have the advantage that:
• They allow code to be reused.
• They allow for top-level design.
• They make applet debugging easier as each function can be tested in isolation
to the rest of the applet.
A function has the public keyword, followed by the return value (if any) and
the name of the function. After this the parameters passed to the function are
defined within rounded brackets. Recapping from the previous example:
This function has the public keyword which allows any user to execute the
function. The void type defines that there is nothing returned from this function
and the name of the function is paint(). The parameter passed into the function
is g which has the data type of Graphics. Within the paint() function the
drawstring() function is called. This function is defined in java.awt.Graphics
class library (this library has been included with the import java.awt. *
statement. The definition for this function is:
which draws a string of characters using the current font and colour. The x,y
position is the starting point of the baseline of the string (str).
It should be noted that Java is case sensitive and the names given must be
refered to in the case that they are defined as.
27.4 Stand-alone programs
A Java program can also be run as a stand-alone program. This allows the Java
program to be run without a browser and is normally used when testing a Java
applet. The method of output to the screen is:

which prints a message (message) to the display. This type of debugging is
messy as these statements need to be manually inserted in the program. It is
likely that later versions of the JDK toolkit will contain a run-time debugger
which will allow developers to view the execution of the program.
To run a stand-alone program the java. exe program is used and the user adds
output statements with the System.out.println () function. Note that there is
no output from applet with the System.out.println() function.
Java stand-alone program 27.1 gives a simple example of a stand-alone
program. The public static void main (Strings [] args) defines the main
function. Sample run 27.3 shows how the Java program is created (with edit)
and then compiler (with javac.exe), and then finally run (with java.exe).
27.5 Java reserved words
Like any programming language, Java has various reserved words which cannot
be used as a variable name. These are given next:

27.6 Applet variables
Variables are used to stored numeric values and characters. In Java all variables
must be declared with their data type before they can be used. The Java data
types are similar to C/C++ types, and are stated in Table 27.4.
Table 27.4
Java data types and their range
Type
Storage (bytes)
Range
boolean
 
True or False
byte
1
−128 to 127
char
2
Alphabetic characters
int
4
−2,147,483,648 to 2,147,483,647
short
2
−32,768 to 32,767
long
4
−2,147,483,648 to 2,147,483,647
float
4
±3.4×10(T−38 to ±3.4×1038
double
8
±1.7×10−308 to ±1.7×10308
27.6.1 Converting Numeric Data Types
Java is a strongly typed language and various operations follow standard
conversions for data types. If the developer wants to convert from one data type
to another (such as from an integer to a double) then the data type conversion is
used where the converted data type is defined within rounded brackets. For
example:

converts the addition of y and z to an integer.
27.6.2 The Paint() Object
The paint() object is the object that is called whenever the applet is redrawn. It
will thus be called whenever the applet is run and then it is called whenever the
applet is redisplayed.
27.7 Java operators
The table below recaps the Java operators from the previous chapter.
27.8 Mathematical operations
Java has a basic set of mathematics functions which are defined in the
java.lang.Math class library. Table 27.5 outlines these functions. An example
of the functions in this library is abs() which can be used to return the absolute
value of either a double, an int or a long value. Java automatically picks the
required format and the return data type will be of type of the value to be
operated on.
Table 27.5
Functions defined in java.lang.Math
Function
Description

double abs(double a)
Returns the absolute double value of a.
float abs(float a)
Returns the absolute float value of a.
int abs(int a)
Returns the absolute integer value of a.
long abs(long a)
Returns the absolute long value of a.
double acos(double a)
Returns the arc cosine of a, in the range of 0.0 through Pi.
double asin(double a)
Returns the arc sine of a, in the range of Pi/2 through Pi/2.
double atan(double a)
Returns the arc tangent of a, in the range of –Pi/2 through Pi/2.
double atan2(double a,
double b)
Converts rectangular coordinates (a, b) to polar (r, theta).
double ceil(double a)
Returns the ’ceiling’ or smallest whole number greater than or equal to a.
double cos(double a)
Returns the trigonometric cosine of an angle.
double exp(double a)
Returns the exponential number e(2.718…) raised to the power of a.
double floor(double a)
Returns the ’floor’ or largest whole number less than or equal to a.
double
IEEEremainder(double
f1, double f2)
Returns the remainder of f1 divided by f2 as defined by IEEE 754.
double log(double a)
Returns the natural logarithm (base e) of a.
double max(double a,
double b)
Takes two double values, a and b, and returns the greater number of the two.
double max(float a, float
b)
Takes two float values, a and b, and returns the greater number of the two.
int max (int a, int b)
Takes two int values, a and b, and returns the greater number of the two.
max(long a, long b)
Takes two long values, a and b, and returns the greater number of the two.
double min(double a,
double b)
Takes two double values, a and b, and returns the smallest number of the two.
float min (float a, float
b)
Takes two float values, a and b, and returns the smallest number of the two.
int min(int a, int b)
Takes two integer values, a and b, and returns the smallest number of the two.
long min(long a, long b)
Takes two long values, a and b, and returns the smallest number of the two.
double pow(double a,
double b)
Returns the number a raised to the power of b.
double random()
Generates a random number between 0.0 and 1.0.
double rint(double b)
Converts a double value into an integral value in double format.
long round(double a)
Rounds off a double value by first adding 0.5 to it and then returning the largest
integer that is less than or equal to this new value.
int round(float a)
Rounds off a float value by first adding 0.5 to it and then returning the largest
integer that is less than or equal to this new value.
double sin(double a)
Returns the trigonometric sine of an angle.
double sqrt(double a)
Returns the square root of a.
double tan(double a)
Returns the trigonometric tangent of an angle.
As the functions are part of the Math class they are preceded with the Math.

class method. For example:
Java stand-alone program 27.2 shows a few examples of mathematical
operations and Sample run 27.4 shows a sample compilation and run session.
Java has also two pre-defined mathematical constants. These are:
• Pi is equivalent to 3.14159265358979323846.
• E is equivalent to 2.7182818284590452354.
27.9 Loops

27.9.1 For ()
As with C/C++ and JavaScript the standard format for a for() loop is:
where:
Java applet 27.2 shows how a for() loop can be used to display the square
and cube of the values from 0 to 9. Notice that the final value of i within the
for() loop is 9 because the end condition is i<10 (while i is less than 10).

27.9.2 While ()
The while() statement allows a block of code to be executed while a specified
condition is TRUE. It checks the condition at the start of the block; if this is
TRUE the block is executed, else it will exit the loop. The syntax is:
If the statement block contains a single statement then the braces may be
omitted (although it does no harm to keep them).
27.10 Conditional statements
Conditional statements allow a program to make decisions on the route through a
program.
27.10.1 If … Else
As with C/C++ and JavaScript the standard format for a if() descision is:
The following is an example format with an else extension.
Java applet 27.3 uses a for() loop and the if() statement to test if a value is
less than, equal to or greater than 5. The loop is used to repeat the test 10 times.

The random() function is used to generate a value between 0 and 1, the
returned value is then multiplied by 10 so as to convert to into a value between 0
and 10. Then it is converted to an integer using the data type modifier (int). The
if() statement is then used to test the value.
27.11 Exercises
27.11.1. Write a Java applet which displays the following table of powers.

27.11.2. Write a Java applet which displays the following table of square root
values from 1 to 15.
Value
Square root
1
1
2
1.414214
3
1.732051
4
2
5
2.236068
6
2.44949
7
2.645751
8
2.828427
9
3
10
3.162278
11
3.316625
12
3.464102
13
3.605551
14
3.741657
15
3.872983
27.11.3. Write a Java applet which display 20 random numbers from between 0
and 20.
27.11.4. Write a Java applet that simulates the rolling of two dice. A sample
output is:
Dice 1:
3
Dice 2:
5
Total:
8

28
Java (Extended functions)
28.1 Introduction
Chapter 27 discussed the Java programming language. This chapter investigates
event-driven programs. The main events are:
• Initialization and exit functions (init (), start (), stop() and destroy
()).
• Repainting and resizing (paint ()).
• Mouse events (mouseUp (), mouseDown() and mouseDrag ()).
• Keyboard events (keyUp() and keyDown ()).
28.2 Initialization and exit functions
Java has various reserved functions which are called when various event occur.
Table 28.1 shows typical initialization functions and their events, and Figure
28.1 illustrates how they are called.
Table 28.1
Java initialization and exit functions
Function
Description
public void
init( )
This function is called each time the applet is started. It is typically used to add user-interface
components.
public void
start( )
This function is called after the init() function is called. It is also called whenever the user
returns to the page containing the applet and thus can be called many times as opposed to
the init() function which will only be called when the applet is first started. Thus, code
which is to be executed only once is normally put in the init()function, and code which
must be executed every time the applet is accessed should be inserted into the start()
function.
public void
stop()
This function is called when the user moves away from the page on which the applet resides. It
is thus typically used to stop processing while the user is not accessing the applet. Typically
it is used to stop animation or audio files, or mathematical processing. The start() function
normally restarts the processing.

public void
paint
(Graphics
g)
This function is called when the applet is first called and whenever the user resizes or moves
the windows.
public void
destroy()
This function is called when the applet is stopped and is normally used to release associated
resources, such as freeing memory, closing files, and so on.
FIGURE 28.1  Java initialization and exit functions
Java applet 28.1 gives an example using the init() and start() functions.
The variable i is declared within the applet and it is set to a value of 5 in the
init() function. The start() function then adds 6 onto this value. After this the
paint() function is called so that it displays the value of i (which should equal
11).

28.3 Mouse events
Most Java applets require some user interaction, normally with the mouse or
from the keyboard. A mouse operation causes mouse events. The three basic
events which are supported in Java are:
• mouseUp().
• mouseDown().
• mouseDrag().
Java applet 28.2 uses the three mouse events to display the current mouse
cursor. Each of the functions must return a true value to identify that the event
has been handled successfully (the return type is of data type Boolean thus the
return could only be a true or a false). In the example applet, on moving the
mouse cursor with the left mouse key pressed down the mouseDrag() function is
automatically called. The x and y coordinate of the cursor is stored in the x and y
variable when the event occurs. This is used in the functions to build a message
string (in the case of the drag event the string name is MouseDragMsg).

28.4 Mouse selection
In many applets the user is prompted to select an object using the mouse. To
achieve this the x and y position of the event is tested to determine if the cursor
is within the defined area. Java applet 28.3 is a program which allows the user to
press the mouse button on the applet screen. The applet then uses the mouse

events to determine if the cursor is within a given area of the screen (in this case
between 10,10 and 100,100). If the user is within this defined area then the
message displayed is HIT, else it is MISS. The graphics function
g.drawRect(x1,y1,x2,y2) draws a rectangle from (x1,y1) to (x2,y2).

28.5 Keyboard input
Java provides for two keyboard events, these are:
• keyUp() .Is called when a key has been released.
• keyDown(). Is called when a key has been pressed.
The parameters passed into these functions are event (which defines the
keyboard state) and an integer Keypressed which describes the key pressed.
The event contains an identification as to the type of event it is. When one of
the function keys is pressed then the variable event.id is set to the macro
Event.KEY_ACTION (as shown in Java applet 28.5). Other keys, such as the Ctrl,
Alt and Shift keys, set bits in the event.modifier variable. The test for the Ctrl
key is:
This tests the CTRL_MASK bit; if it is a 1 then the CTRL key has been pressed.
Java applet 28.5 shows its uses.

For function keys the KeyPress variable has the following values:
Thus, to test for the function keys the following routine can be used:

For control keys the KeyPress variable has the following values:
Thus, to test for the control keys the following routine can be used:
28.6 Graphics images
Java has excellent support images and sound. For graphics files it has support for
GIF and JPEG files, each of which is in a compressed form. The image object is
declared with:
Next the graphics image is associated with the image object with the get
Image() function:
where the getCodeBase() function returns the applets URL (such as
www.eece.napier.ac.uk) and the second argument is the name of the graphics file
(in this case, myson.gif). After this the image can be displayed with:

where mypic is the name of the image object, and the x and y values are the
coordinates of the upper-left hand corner of the image. The this keyword
associates the current object (in this case it is the graphics image) and the current
applet. Java applet 28.6 gives an applet which displays an image.
28.7 Graphics
The java.awt.Graphics class contains a great deal of graphics-based functions;
these are stated in Table 28.2.
Table 28.2
Java graphics functions
Graphics function
Description
public abstract void
translate(int x,
int y)
Translates the specified parameters into the origin of the graphics context. All
subsequent operations on this graphics context will be relative to this origin.
Parameters: x – the x coordinate y – the y coordinate

public abstract Color
get-Color ()
Gets the current colour.
public abstract void
setColor(Color c)
Set current drawing colour.
public abstract Font
getFont()
Gets the current font.
public abstract void
setFont(Font font)
Set the current font.
public FontMetrics
getFontMetrics()
Gets the current font metrics.
public abstract
FontMetrics
getFontMetrics(Font
f)
Gets the current font metrics for the specified font.
public abstract void
copyArea(int x, int
y, int width, int
height, int dx, int
dy)
Copies an area of the screen where (x,y) is the coordinate of the top left-hand
corner, width and height and the width and height, and dx is the horizontal
distance and dy the vertical distance.
public abstract void
drawLine(int x1,int
y1, int x2, int y2)
Draws a line between the (x1,y1) and (x2,y2).
public abstract void
fillRect(int x, int
y, int width, int
height)
Fills the specified rectangle with the current colour.
public
voiddrawRect(int
x,int y, int width,
int height)
Draws the outline of the specified rectangle using the current colour.
Public abstract void
clearRect(int x,
int y, int width,
int height)
Clears the specified rectangle by filling it with the current background colour of the
current drawing surface.
public void
draw3DRect(int x,
int y, int width,
int height, boolean
raised)
Draws a highlighted 3-D rectangle where raised is a boolean value that defines
whether the rectangle is raised or not.
public void
fill3DRect(int x,
int y,int width,
int height, boolean
raised)
Paints a highlighted 3-D rectangle using the current colour.
public abstract void
drawOval(int x,int
y, int width, int
height)
Draws an oval inside the specified rectangle using the current colour.
public abstract
voidfillOval(int
x,int y, int width,
int height)
Fills an oval inside the specified rectangle using the current colour.
public abstract void
drawArc(int x, int
Draws an arc bounded by the specified rectangle starting. Zero degrees for
startAngle is at the 3-o’clock position and arcAngle specifies the extent of the
A
iti
l
f
A
l
i di
t
t
l
k i
t ti
hil

y, int width, int
height, int
startAngle, int
arcAngle)
arc. A positive value for arcAngle indicates a counter-clockwise rotation while a
negative value indicates a clockwise rotation. The parameter (x,y) specifies the
centre point, and width and height specifies the width and height of a rectangle
public abstract void
fillArc(int x, int
y, int width, int
height, int
startAngle, int
arcAngle)
Fills a pie-shaped arc using the current colour.
public abstract void
drawPolygon(int
xPoints[], int
yPoints[],int
nPoints)
Draws a polygon using an array of x and y points (xPoints[] and yPoints[]). The
number of points within the array is specified by nPoints.
public abstract void
fillPolygon(int
xPoints[], int
yPoints[],int
nPoints)
Fills a polygon with the current colour.
public abstract void
drawstring (String
str, int χ, int y)
Draws the specified String using the current font and colour.
public abstract
boolean
drawImage(Image
img, int x, int y)
Draws the specified image at the specified coordinate (x, y).
public abstract void
dispose()
Disposes of this graphics context.
28.7.1 Setting The Colour
The current drawing colour is set using the setColor() function. It is used as
follows:
Colours are defined in the java.awt. Color class and valid colours are:
Any other 24-bit colour can be generated with the function Color which has
the format:

where r, g and b are values of strength from 0 to 255. For example:
28.7.2 Drawing Lines And Circles
Normally to draw a graphics object the user must plan its layout for the
dimension within the object. Figure 28.2 shows an example graphic with the
required dimensions. The drawOval() function uses the top level hand point for
the x and y parameters in the function and the width and height define the width
and height of the oval shape. Thus the drawOval() function can be used to draw
circles (if the width is equal to the height) or ovals (if the width is not equal to
the height). Java applet 28.7 shows the Java code to draw the object. This applet
uses the setColor() function to make the circle yellow and the other shapes
blue.
FIGURE 28.2  Dimensions of graphic

28.7.3 Drawing Polygons
The drawPolygon() function can be used to draw complex objects where the
object is defined as a group of (x,y) coordinates. Java applet 28.8 draws a basic
picture of a car and the xpoints array holds the x coordinates and ypoints hold
the y coordinates. Figure 28.3 illustrates the object.
FIGURE 28.3  Coordinates of graphic

28.8 Sound
The playing of sound files is similar to displaying graphics files. Java applet 28.9
shows a sample applet which plays an audio file (in this case, test.au).
Unfortunately the current version of the Java compiler only supports the AU
format, thus WAV files need to be converted into AU format.
The initialization process uses the getAudioClip() function and the audio file
is played with the loop() function. This function is contained in the
java.applet.AudioClip class, these functions are:

28.9 Dialog boxes
One of the features of Java is that it supports dialog boxes and checkboxes.
These are used with event handlers to produce event-driven options.
28.9.1 Buttons And Events
Java applet 28.10 creates three Button objects. These are created with the add()
function which displays the button in the applet window.

Applet 28.10 creates three buttons which do not have any action associated
with them. Java applet 28.11 uses the action function which is called when an
event occurs. Within this function the event variable is tested to see if one of the
buttons caused the event. This is achieved with:
If this tests to the true then the Msg string takes on the value of the Object,
which hold the name of the button that caused the event.

28.9.2 Checkboxes
Typically checkboxes are used to select from a number of options. Java applet
28.12 shows how an applet can use checkboxes. As before, the action function is
called when a checkbox changes its state and within the function event.target
parameter is tested for the checkbox with:
If this is true, then the function DetermineCheckState() is called which tests
event.target for the checkbox value and its state (true or false).

28.9.3 Radio Buttons
The standard checkboxes allow any number of options to be selected. A radio
button allows only one option to be selected at a time. The previous example can
be changed as follows:
This sets the checkbox type to RadioGroup and it can be seen that only one of
the checkboxes is initally set (that is, ‘Post’).
28.9.4 Pop-Up Menu Choices
To create a pop-up menu the Choice object is initally created with:
After this the menu options are defined using the addItem method. Java applet
28.13 shows an example usage of a pop-up menu.

28.9.5 Text Input
Text can be entered into a Java applet using the TextField action. In Java applet
28.14 the TextField (20) defines a 20-character input field.

28.10 Fonts
Java is well supported with different fonts. The class library java.awt.Font
defines the Font class and the general format for defining the font is:
The main font_types are:
This book is written in Times Roman. Helvetica looks good as a header, such
as Header 1. Courier produces a monospace font where all of the characters have
the same width. The Java applets in this chapter use the Courier font. Symbol is
normally used when special symbols are required. The font_attrib can either be
BOLD, ITALIC or NORMAL. and the font_size is an integer value which is supported
by the compiler. The font size of this text is 11 and most normal text varies

between 8 and 12.
Java applet 28.15 shows an example applet using different fonts.
28.11 Exercises
28.11.1. Explain how the three mouse events occur.
28.11.2. Write a Java applet that contains a target which has areas with different
point values. These point values are 50, 100 and 150. The program
should accumulate the score so far. A sample screen is given in Figure
28.4 (refer to Java applet 28.3 for the outline of the program).

FIGURE 28.4
28.11.3. Modify the program in 28.11.2 so that a RESET button is displayed.
When selected the points value should be reset to zero.
28.11.4. Write a Java applet which displays a square at a starting position
(50,50) with a width and length of 50 units. The user should then be able
to move the rectangle up, down, left or right using the u key (for up), d
key (for down), 1 key (for left) and r key (for right). The program should
continue until the x key is pressed.
28.11.5. Write a Java applet which displays which function key or control key
(Cntrl) has been pressed. The program should run continuously until the
Cntrl-Z keystroke is pressed.
28.11.6. Write separate Java applets, using simple rectangles and circles, to
display the following graphics:
(a) a television (a sample graphic is shown in Figure 28.5)
FIGURE 28.5
(b) a face
(c) a house
(d) a robot

28.11.7. Locate three GIF or JPEG files. Then write a Java applet which allows
the user to choose which one should be displayed. The function key F1
selects the first image, F2 the second, and F3 the third. The function key
F4 should exit the applet.
28.11.8. Using an applet which displays the text TEST TEXT, determine the
approximate colour of the following colour settings:
(a) color (100, 50, 10) (b) color (200,200, 0)
(c) color (10, 100, 100)
(d) color (200,200, 200)
(e) color (10, 10,100)
28.11.9. Write an applet using a polygon for the following shapes:
(a) a ship (a sample is shown in Figure 28.6)
FIGURE 28.6
(b) a tank
(c) a plane
28.11.10. Locate a sound file and write an application which uses it.
28.11.11. Write a Java applet which displays the following:
   Note that Sample Applet is bold Arial text with a size of 20 and the other text
is Courier of size of 14.
28.11.12. Write a Java applet in which the user enters some text. If the user
enters EXIT then the program will exit.

PART F
DOS

29
Introduction
29.1 Introduction
In 1947 the invention of the transistor caused a great revolution. In fact scientists
at the Bell Laboratories kept its invention secret for over seven months so that
they could fully understand its operation. On 30 June 1948 the transistor was
finally revealed to the world. Unfortunately, as with many other great inventions,
it received little public attention and even less press coverage (the New York
Times gave it 4½ inches on page 46).
Transistors had, initially, been made from germanium, which is not a robust
material and cannot withstand high temperatures. The first company to propose a
method of using silicon transistors was a geological research company named
Texas Instruments (which had diversified into transistors). Soon many
companies were producing silicon transistors and by 1955 the electronic valve
market had peaked, while the market for transistors was rocketing. The larger
electronic valve manufacturers, such as Western Electric, CBS, Raytheon and
Westinghouse failed to adapt to the changing market and quickly lost their
market share to the new transistor manufacturing companies, such as Texas
Instruments, Motorola, Hughes and RCA.
In 1959, IBM built the first commercial transistorized computer named the
IBM 7090/7094 series. It was so successful that it dominated the computer
market for many years. In 1965, they produced the famous IBM system 360
which was built with integrated circuits. Then in 1970 IBM introduced the 370
system, which included semiconductor memories. Unfortunately, these
computers were extremely expensive to purchase and maintain.
Around the same time the electronics industry was producing cheap pocket
calculators. The development of affordable computers happened when the
Japanese company Busicon commissioned a small, at the time, company named
Intel to produce a set of eight to twelve ICs for a calculator. Instead of designing
a complete set of ICs, Intel produced a set of ICs which could be programmed to

perform different tasks. These were the first ever microprocessors. Soon Intel
(short 
for 
Integrated 
Electronics) 
produced 
a 
general-purpose 
4-bit
microprocessor, named the 4004 and a more powerful 8-bit version, named the
8080. Other companies, such as Motorola, MOS Technologies and Zilog were
soon also making microprocessors.
IBM’s virtual monopoly on computer systems soon started to slip as many
companies developed computers based around the newly available 8-bit
microprocessors, namely MOS Technologies 6502 and Zilog’s Z–80. IBM’s
main contenders were Apple and Commodore who introduced a new type of
computer – the personal computer (PC). The leading systems were the Apple I
and the Commodore PET. These spawned many others, including the Sinclair
ZX80/ZX81, the BBC microcomputer, the Sinclair Spectrum, the Commodore
Vic–20 and the classic Apple II (all of which were based on or around the 6502
or Z-80).
IBM realized the potential of the microprocessor and used Intel’s 16-bit 8086
microprocessor in their version of the PC. It was named the IBM PC and has
since become the parent of all the PCs ever produced. IBM’s main aim was to
make a computer which could run business applications, such as word
processors, spread-sheets and databases. To increase the production of this
software they made information on the hardware freely available. This resulted
in many software packages being developed and helped clone manufacturers to
copy the original design. So the term ‘IBM-compatible’ was born and it quickly
became an industry standard by sheer market dominance.
On previous computers IBM had written most of their programs for their
systems. For the PC they had a strict time limit, so they went to a small computer
company called Microsoft to develop the operating system program. This
program was named the Disk Operating System (DOS) because of its original
purpose of controlling the disk drives. It accepted commands from the keyboard
and displayed them to the monitor. The language of DOS consisted of a set of
commands which were entered directly by the user and interpreted to perform
file management tasks, program execution and system configuration. The main
functions of DOS were to run programs, copy and remove files, create
directories, move within a directory structure and to list files.
Microsoft has since gone on develop industry-standard software such as
Microsoft Windows Version 3, Microsoft Office and Microsoft Windows 95.
Intel has also benefited greatly from the development of the PC and has
developed a large market share for their industry-standard microprocessors, such

as the 80286, 80386, 80486, Pentium and Pentium Pro processors.
29.2 Introduction to DOS
Most modern PCs either run DOS or allow access to an emulated version of it.
All version of Microsoft Windows up to, and including Microsoft Windows 3.1,
required DOS to be running before Windows could run. Windows 95 and
Windows NT are complete operating systems within themselves and display an
emulated version of DOS.
29.2.1 Checking The Version Of DOS (VER)
The first version of DOS was released in 1981 and each subsequent release has
been assigned a new version number. When there is a major change in DOS then
the first number is changed, such as, Versions 1.0, 2.0, 3.0, and so on. The
second number changes with a relatively minor change, such as version 1.1, 1.2,
1.3, and so on. Most versions of DOS are compatible with previous versions.
To determine the version of DOS that a computer is running then enter the VER
command, as shown in Test run 29.1. Many current systems use Version 6 or run
an emulated DOS from Windows 95 or Windows NT.
DOS versions later than Version 4 have an on-line help manual. To display
the help page on a command then HELP command_name is entered, as shown in
Test run 29.2.

29.2.2 Checking The Date And Time (Date And
Time)
Most PCs have an on-board clock which is powered by a rechargeable battery.
The DATE command displays the current date and allows the user to change the
system data, if required. Test run 29.3 shows an example. If the date is displayed
correctly then the <ENTER> key is pressed, as shown in Test run 29.3.
If this date is incorrect then the correct date is entered at the Enter new date
(dd-mm-yy) prompt. The example in Test run 29.4 shows that the current date
has been changed to Sunday 8/9/96. Care must be taken when entering the
current date as the system may be set up to display the date in USA format, that
is, MM-DD-YY (MONTH, DAY and YEAR).
The TIME command displays the current time. As with the date command the
user is prompted as to whether to change the current time, or not. Pressing the
ENTER key does not change the current time. Test run 29.6 shows an example of
changing the system time from 10:55 am to 11:15 pm.

29.2.3 Clearing The Screen (Cls)
The CLS command clears the screen and leaves only a prompt and the cursor.
29.2.4 Starting And Stopping DOS
When the PC is restarted, DOS is normally started automatically from the hard-
disk (unless the system has no hard-disks). Some PCs try to read the floppy disks
drives for the DOS system files. If this happens make sure there are no floppy
disks in the drives.
The method of starting DOS is described as the boot procedure. There are two
main methods of starting (or restarting DOS):
• A cold boot – occurs at power-up and causes the system to start a self-test
program; • A warm boot – is executed when the Ctrl, Alt and Del keys
are pressed down simultaneously (described as Ctrl-Alt-Del). This is
normally required when a program has crashed and the system has
hungup.
The Ctrl-Break keys (or Cntrl-C) are used to interrupt a DOS command.
Test run 29.7 shows how the TIME command is interrupted using the Ctrl and ‘C
keys.

29.3 Disks
Computers store data on floppy disks, hard-disks and optical disks. The disk
drives on a PC are identified by the labels from A : to Z :. It is convention that
the primary hard-disk drive is drive C :, the primary floppy drive is A :, and the
secondary floppy drive is B :., as given in Table 29.1.
Table 29.1
Disk drive allocation
Drive Allocation
Description
A:
Primary floppy disk drive
B:
Secondary floppy disk drive
C:
Primary hard-disk drive
D:
Secondary hard-disk drive or CD-ROM drive
Floppy and hard-disks store of information using magnetically fields on
separate concentric rings – known as tracks. These are subdivided into blocks of
512 bits – known as sectors. There are various different formats for these tracks
and sectors with varying capacities; these are given in Figure 29.2. Differing
capacities may lead to compatibility problems.
FIGURE 29.2  Sample file structure
Table 29.2
Floppy disk capacity

29.4 Formatting floppy disks (FORMAT)
The primary hard-disk is named C : and the primary disk drive is named A :. If
the PC has another floppy disk drive it is given the name B :. Other drives can
exist, such as for network drives, a secondary hard-disk, a CD-ROM drive, and
so on.
There are two main types of floppy disks. These are usually referred to by the
disks dimensions, as shown in Figure 29.2. Originally PCs used the 5.25” floppy
disks. They are extremely sensitive to physical damage, especially when they are
bent. Data on the disk can also be corrupted by external particles or finger prints.
The disk can be put into a dust cover – although it provides little protection to
being bent. A better floppy disk uses a sliding metal shutter to protect the
magnetic disk, this is the 3.5” disk. It also allows a greater amount of data
storage.
A 3.5” disk can be protected from over-writing stored data by sliding the write
protect button, as shown in Figure 29.2. There are two types 3.5” disk types,
these differ in the amount of data that can be safely stored on them. They are
named the double density (DD) and high density (HD) disk. The DD disk has a
maximum capacity of 720 KB and the HD has 1.4 MB. Normally, HD disks are
more reliable than DD disks, but they cost more to buy. An HD disk can be
identified either by the HD symbol or by the notch at the other side of the write
protect slider.
FIGURE 29.1  3.5” floppy disks.

29.4.1 Formatting A 3.5” Disk
The FORMAT command sets up the necessary format on the disk so that files can
be stored. A sample session is shown in Test run 29.8.
Notice that the message Saving UNFORMAT information is displayed. This
allows the user to unformat a disk that has been formatted accidentally (but only
if no new files have been written to the disk).
It is also possible to force the FORMAT command to format with a different
capacity. The /f switch extension is used for this purpose. Table 29.3 outlines
how it is modified for different capacities.
Table 29.3
Floppy disk capacity
Capacity
Command
Notes
720K
format a: /f:720
DD 3.5″ floppy disk
1.44M
format a: /f:1.44
HD 3.5″ floppy disk
360K
format a: /f:360
DD 5 1/4″ floppy disk
1.2M
format a: /f:1.2
HD 5 1/4″ floppy disk

29.5 File system structure
Files store data in the form of programs, documents, spread-sheets, and so on.
They are organized into a tree structure. The top of the structure is the root
directory and each branch is called a subdirectory. This structure makes finding
files easier than having all files stored in the one directory.
The route through the tree structure to a given file is known as the pathname
and reference to files external to the current directory is possible by using the
correct path. The pathname for a given file is traced through the tree structure
from the root directory to the location of the file.
Test run 29.9 shows an example list of a top-level directory. The prompt
should be set-up to display the current directory. In this case, the DOS prompt is
C:\>.
The top level directory in this case contains various subdirectories such as
DOCS, WINDOWS, PSP and TURBO. Each of these directories contains files and/or
subdirectories. The function of each directory is normally obvious from its
name. For example, the DOS directory contains DOS program, help manuals and
system files, the WINDOWS directory contains programs for Microsoft Windows.
The top-level directory is the root directory, and is given the name \. A small
section of the directory hierarchy is given in Figure 29.2. Notice that there are
four subdirectories below the root directory and that below the DOCS directory
there are three subdirectories NOTES, CLASSES and ADMIN. There is also one
subdirectory below WINDOWS. To identify the directories a pathname must be
given. The full pathname each directory is:

All these directories are stored on the hard disk which is labelled as C:, thus
the full pathname, with the disk drive, of the directories are:
These pathnames are the full pathnames and are absolute pathnames. It is also
possible to specify a relative pathname. With relative pathname the name given
does not have the preceding top-level directory (\). For example, if we are in the
GAMES directory the relative pathname for the DATA directory is CHESS\DATA and
if we are in the WINDOWS directory the relative pathname for the SYSTEM directory
is simply SYSTEM.
29.6 DOS Filenames
Files are stored on disks with a filename and an extension. The filename can be
up to eight characters long and the extension up to three characters. A period (‘.
’) separates the filename from the extension. Figure 29.3 shows the standard
format. The extension name gives an indication about what type of file it is.
FIGURE 29.3  DOS filenames
The valid characters that can be used for the filename are alphabetic
characters (‘A’ – ‘Z’), numbers (‘0’ – ‘9’), underscores (‘_’), braces (‘{‘,’}’),
parentheses (‘(7)’), tilde (‘~’), caret (’⁁‘), ampersand (‘&’), exclamation point
(‘!’), pound sign (‘£’), hyphen (‘-’), and dollar sign (‘$’). Other special
characters such as (‘*’), (‘?’), (‘:’), (‘;’), (’,’), (‘=’), and so on. are reserved for
special functions. Some valid and invalid filenames are given in Table 29.4.
Table 29.4

Examples of valid and invalid DOS filenames.
29.7 File types
Most files created have a certain purpose; for example documents from a word
processor, spread-sheets, text files. The filename extension adds extra
information about what type of file it is. Common filename extensions are given
in Table 29.5.
Table 29.5
Example file extensions
Test run 29.10 shows a sample DOS listing. Notice that this directory contains
System Files (.SYS), DOS Commands (.COM and .EXE), Text Files (.TXT) and
Help Files (.HLP). The other typical files include Basic Language Files (.BAS),
Initialization Files (.INI) and Listings (.LST). Programs with the .COM, .EXE or
.BAT extension can be executed.
29.8 Listing files (DIR)
The DIR command displays the contents of a directory. A help manual on DIR is
given in Test run 29.11.
Various switches modify the way the DIR command displays the directory
listing. Refer to the user manual shown in Test run 29.11 for a complete listing.
Test run 29.12 shows a sample listing without switches.

Table 29.6
Example switches for the DIR command
Command
Description
DIR /w
display directory in five columns
DIR /p
displays one screen of listing at a time
DIR /s
display all subdirectories and files
DIR /od
displaydirectory in order of date
DIR /1
displays directories in lower case
Test run 29.12 shows an example session using some of the formats. Notice
that the basic DIR command displays not only the filename and extension, but
also the following:
• The volume label of the disk (in this case, THINKPAD).

• The volume serial number, every disk drive has a unique volume serial
number (3A40–09E8).
• The current directory name (C:\).
• The directory name or filename.
• The date file or subdirectory was created, or was last modified (for example,
for the DOS directory it is 05/01/95).
• The time the file or directory was created, or was last modified (for example,
for the DOS directory it is 12:00).
• The number of files in the directory (in this case, 37).
• The disk space used up by the files in the current directory (in this case, 65,
786 bytes).
• The amount of available disk space (in this case, 41,353,216 bytes).
The DIR/p displays one screen of directory information and the user is
prompted to Press and key to continue …. This continues until all the directory
information is displayed. The DIR/s command is useful for finding files in
subdirectories. Several switches can be used at a single time, for example to

display all subdirectories with a pause between each screenful the command
used is DIR/p/s.
Worksheet 14: Note, if you are using Windows NT/95 then select either the
MSDOS Prompt or shutdown Windows and select Restart the computer in
MSDOS mode.
W14.1. Determine the DOS version of the PC you are using.
Version:
W14.2. Display the current date on the PC.
Date:
W14.3. Display the current time of the PC.
Time:
W14.4. Modify the date and time and redisplay.
New date:
New time:
W14.5. Change the date and time back so that they show the correct date and

time.
Completed successfully:
YES/NO
W14.6. Use the Ctrl-C (or Ctrl-Break) keystrokes to quit from the TIME
command.
Completed successfully:
YES/NO
W14.7. Clear the screen.
Completed successfully:
YES/NO
W14.8. Locate the following keys (tick, if found):
   
Keys
Functions keys F1-F10
Page Up/ Page Down
 
Alt key
Num Lock
 
Cntrl key
Home/End
 
Caps Lock
ESC
 
Horizontal TAB
Scroll Lock
 
Break
Delete
 

W14.9. Display the following characters to the screen (tick, if found):
Keys
√ Keys
√
£
\
 
<
:
 
>
(
 
?
)
 
#
 
/
|
 
W14.10. List all the files in the top level directory on the C: drive.
Note some of contents:
FILES:
DIRECTORIES:
W14.11. Which of the following are valid names for files (tick):
Filename
Valid(√)
Invalid(√)
MY_FILE.DAT
 
 
DOC1,DOC
 
 
TEMP.$$$
 
 
WORK∼1.BAT
 
 
WORK??.BAT
 
 
TAX:1.DOC
 
 
$1.WP
 
 
W14.12. For the file structure given in Figure W14.1 complete the table given
next (the first one has been completed):

FIGURE W14.1  File structure
Directory
Full pathname
ADMIN
C:\DOCS\ADMIN
MEMO
 
BERT
 
BATCH
 
WINDOWS
 
SYSTEM
 
W14.13. For the file structure given in Figure W14.2 determine the full
pathnames for the files given next (the first one has been completed):
FIGURE W14.2  File structure
FILE
Full pathname
T_SHEET.DOC
C-\DOCS\ADMIN\T_SHEET.DOC
P_SHEET.DOC
 
MEMOI.DOC
 

XCOPY.EXE
 
MESSAGE.BAT
 
MOUSE.SYS
 
W14.14. Using the DIR command list all the files on the hard disk (C:). Use the
CNTRL-C keystroke to exit.
Completed successfully:
YES/NO
W14.15. What is the probable function of the following files:
File
Probable Function
ADMIN.DOC
Document File
TAX91.WK1
 
DOSHELP.BAK
 
CONFIG.SYS
 
XCOPY.HLP
 
FIG1.PCX
 
GORILLA.BAS
 
HELP.TXT
 
W14.16. Determine from the DIR listing the size of the following files on the
hard disk:
FILE
Size of file (Bytes)
COMMAND.COM
 
CONFIG.SYS
 
AUTOEXEC.BAT
 
\DOS\XCOPY.EXE
 
\DOS\FC.EXE
 
W14.17. Determine from the DIR listing the date that the following files were

last modified:
FILE
Date last modified
COMMAND.COM
 
CONFIG.SYS
 
AUTOEXEC.BAT
 
\DOSkXCOPY.EXE
 
\DOS\FC.EXE
 
   
W14.18. Determine the amount of disk space that is remaining on the hard disk.
Disk space:
W14.19. Determine the amount of disk space used up by all the files in the \DOS
directory:
Disk space used by DOS directory:
W14.20. Determine the number of files in the \DOS directory (or the
\WINDOWS directory if there is no \DOS directory): Disk space used by
DOS directory:
Number of files:

W14.21. State what the following DIR commands do (try them out):
Command
Function
dir/b
Lists directories and displays only the name of the file/directory (bare
listing)
dir /1
 
dir/on
 
dir/os
 
dir/od
 
W14.22. Reboot the computer using a warm-boot.
Completed successfully:
YES/NO
W14.23. Reboot the computer using a cold-boot.
Completed successfully:
YES/NO

30
DOS File System/Editor
30.1 Changing directory (CD or CHDIR)
The change directory command, CD (or CHDIR) allows the user to move around
the file system. Table 30.1 shows a few sample commands and Sample session
30.1 shows a sample session. At the beginning of this session the user is in the
top level directory (C:\). The DIR/W command lists contents of the directory across
the screen in five columns. In this case the main directory contains a
subdirectory named \DOCS. To change the current directory to this directory the CD
DOCS command line is used. Next, contents of this directory are listed using DIR/W.
Table 30.1
Examples of the CD command
Example
Description
CD..
change directory to the one above the current directory
CD\
change directory to the top-level directory
CD \docs\notes\dos
change directory to the directory \DOCS\NOTES\DOS
CD notes
change directory to the subdirectory NOTES
In the \DOCS directory there are nine subdirectories. Each of these
subdirectories have their own function; for example, lecture notes are stored in
the NOTES directory and general administration documents are stored in the ADMIN
directory. Note that the full pathname for the NOTES directory is C:\DOCS\NOTES.
Next, the user changes the current working directory to the DOCS directory and
then to the DOS subdirectory. There are several files in this directory including the
files 
DOS.DOC and 
DOS_S1.DOC. The full pathname of the file 
DOS.DOC is
C:\DOS\DOCS\NOTES\DOS\DOS.DOC.


30.2 Making a directory (MKDIR or MD)
The MKDIR (or MD) command creates subdirectories. Sample session 30.2 shows a
sample session where the subdirectory TEMP is created in the top-level directory.

30.3 Viewing a file (TYPE)
The TYPE command views the contents of a file. A text file uses a standard
alphabet known as ASCII. Non-ASCII files contain data which cannot be viewed
by the user. Sample session 30.3 shows the listing of the file CONFIG.SYS which
is in the top-level directory. Note that this file contains information on the initial
startup environment of the PC.

30.4 Wild-cards (*or?)
Wild-cards are special characters which can be used to substitute various
characters in a filename. There are two wild-cards used in DOS, these are:
* replaces any number of characters ? replaces only one character
Sample session 30.4 shows a sample session. The user starts in the top-level
directory and lists all files or directories which start with the letter ‘d’ (using the
DIR d* command). Next the user changes the directory to \DOS. When in this
directory the user lists the files which have a SYS file extension (using DIR
*.SYS). Next, all files which begin with the letter ‘c’ are listed (using DIR C*).
Finally, all files which begin with the letter ‘m’ have any second letter followed
by the letters ‘av’ and with any file extension are listed (using DIRm?av.*).
30.5 Creating a text file
DOS Version 5.0/6.0 and Windows 96 have a text editor named EDIT. This
editor is useful to create text files but cannot be used with software programs.
For this reason an integrated development environment (IDE) editor will be
used..The example used in this section is Borland C++ Version 3.0, as shown in
Figure 30.1.
FIGURE 30.1  Borland C++ Version 4.0 main screen.
Many networks allows access to the compiler through a menu option. On
computers where the compiler is installed on the local hard disk, then typical set-

ups are given in Table 30.1.
For the Borland products (Turbo Pascal/Borland C/Turbo C) a file is entered
by simply entering text into the edit window. The main menu options are File,
Edit, Run, Compile, Options, Debug. Once the file text has been entered
then it is saved by using the File→Save option. As a default C files are give a C
extension, C++ are given a CPP extension, and Pascal files are automatically
assigned a PAS extension. To load a previously saved file the File→Open option
is used.
Table 30.2
IDE packages
IDE
Program to run
Typical home directory
Borland C++ Version 4
BC.EXE
C:\BORLAND\BIN
Turbo C Version 2
TC.EXE
C:\TC
Turbo Pascal
TURBO.EXE
C:\TURBO

30.8 Deleting Files (DEL or ERASE)
The DEL and ERASE commands delete files. Wild-cards can be used to replace
filenames, if required. Sample session 30.5 shows a sample session where the
file TEST3.TXT is deleted from the TEMP directory. Next, all the files with a TXT
extension are deleted.
As an extra safeguard against accidentally deleting, or selectively deleting
files the /P switch can be used. Notice in Sample session 30.6 the user is
prompted to delete each of the files individually.

30.9 Copying files (COPY)
The COPY command is used to copy files. The format of the COPY command is given
next:
where SOURCE is the name of the file to copy and DESTINATION is the name of the
file, or directory, to copy to.
In Sample session 30.7 the user creates a directory named TEMP. Next, the user
changes the directory to the TEMP subdirectory. Note that this directory is empty.
A file named TEST1.TXT is created using the DOS editor (EDIT). After this it is
listed using the TYPE TEST1.TXT command line.
Next the directory is listed using DIR and then the COPY command is used to
copy the new created file to TEST2.TXT. A directory listing (DIR) then shows
that there are now two files in this directory (TEST1.TXT and TEST2.TXT). Next,
the first file (TEST1.TXT) is deleted using ERASE command.


Worksheet 15:
W15.1. Go to the top-level directory, then move around the file system looking
in various directories. Try to determine the likely function of the
directories.
Directory
Likely function
C- \DOS
DOS directory containing some DOS commands, help functions, system files, and so on
 
 
 
 
 
 
 
 
 
 
W15.2. Find all the files which have the DOC extension on the hard disk (hint.
use the DIR/S command).
File(*.DOC)
Directory

DOS. Doe
C:\NOTES\DOeS\DOS
 
 
 
 
 
 
 
 
   Find all the files on the hard disk with the BAT extension.
File (*.BAT)
Directory
AUTOEXEC. BAT
C:\
 
 
 
 
 
 
 
 
W15.3. Create a directory named TEMP on the hard disk.
Command used:
W15.4. Go into the directory you have just created.
   
Command used:
W15.5. Create a file name PROG1.C (if you indent to use C) or PROG1 PAS (if you
indend to use Pascal) from the IDE editor, enter the following text and
save the file.

W15.6. Check that the file just created exists using the DIR command
Does it exist: YES/NO
W15.7. View the contents of this file using TYPE.
Are the contents correct: Yes/NO
W15.8. Copy this file into a file named PROG2.C (or PROG2.PAS if the file created
is PROG1.PAS) using the COPY command.
Command used:
W15.9. Verify that the COPY command has worked by listing the directory.
Has the file been copied correctly: YES/NO

W15.10. View the contents of the newly created file using TYPE.
Are the contents correct: YES/NO
W15.11. Insert a disk into one of the disk drives and format a floppy disk (if you
have one).
   
Command used: YES/NO
W15.12. Go to the floppy disk and copy the file PROG1.C (or PROG1.PAS) from
the C:\TEMP directory and confirm that it has copied correctly.
Command used:
W15.13. Determine the Volume label of the hard disk you are using.
Volume label:
W15.14. Determine the names that DOS will use for the following files/
directories:
Filename
DOS filename actually given

MY FILE 42 1.TEXT
MY FILE. TEX
DOC$1001. D
 
ACC 91 92.WK1
 
BACKUP.$$1 1
 
DOCS.FRED. 1
 
MEMO FRED.200
 
W15.15. Copy the following files that should be in the top-level directory on the
hard disk.
Copy from
Copy to
AUTOEXEC.BAT
AUTOEXEC. OLD
CONFIG.SYS
CONFIG. OLD
Files copied okay: YES/NO
W15.16. Make a directory named OLDBATS and copy the files CONFIG.OLD
and AUTOEXEC.OLD into this directory.
Files copied okay: YES/NO

PART G
Windows 3.x

31
Introduction
31.1 Introduction
A modern Personal Computer (PC) consists of a keyboard, a monitor, a mouse, a
floppy disk drive, a hard disk drive and a system unit. An operating system
allows the user to access these devices in an easy-to-use manner, as illustrated in
Figure 31.1. Microsoft DOS (Disk Operating System) is a text-based system in
which commands are entered via the keyboard to perform operations such as
copying files and running programs.
FIGURE 31.1  Using an operating system to access hardware
Microsoft Windows is a program which presents an easy-to-use graphical
interface to the PC hardware. It uses windows, icons, menus and pointers
(WIMPs) to access application programs, disk drives, file systems, and so on.
Most operations are conducted using a mouse instead of keyboard commands.
The user is presented with a series of icons which represent application
programs. It is far simpler to use than DOS as the information is presented
graphically. A major disadvantage of DOS is that the syntax and format of the
text command requires to be remembered.

Windows has gone through three major transformations, from the original
Version 1.0 to the most widely available version to Version 3.1 (and Version
3.11) and now to Windows 95/NT. It is installed on almost every new PC sold
and is becoming the de-facto standard for PC packages. This and the next
chapter discuss Windows 3.1/3.11.
31.2 Running Windows
Windows 3.x is a program which is run from DOS. It will either start
automatically when the PC is switched on, or can be run by typing WIN at the
DOS prompt and pressing <RETURN>.
31.3 Windows desktop
After Windows is started the screen displays the Microsoft start-up screen for a
short time. This displays the version number of the software. The main Windows
desktop is displayed after this. On top of the desk is the Program Manager
window. It contains a number of windows and icons within it. Programs and
applications are placed into groups. These groups contain icons which relate to
the program. The inactive windows are displayed as group icons. There are four
of these, as shown in Figure 31.2. A window is made active by double clicking
on the group icon. This expands the window to its normal form.

FIGURE 31.2  Main desktop screen
A program which has been running but is currently paused is shown as an icon
at the bottom of the screen. In the example screen in Figure 31.3 there are 4
active groups, these are: Accessories, Main, Msoffice and Applications. Within
the Accessories group there are 12 programs, these are: Write, Paintbrush,
Terminal, Notepad, Recorder, Cardfile, Calculator, Clock, Object
Packager, Character Mapper, Media Player and Sound Recorder.
FIGURE 31.3  A basic group window

The current active window has a blue title bars whilst an inactive window has
a grey title bar. Only icons within an active window can be selected.
31.4 Window items
Windows are made up to four main parts, these are:
• Main title bar. Every window has an identification title at the top of it, as
shown in Figure 31.3.
• Menu bar. Some windows have menu options to choose from, as shown in
Figure 31.4. Hot-keys are often underlined.
FIGURE 31.4  Menu bar on a window
• Scroll bar. When only part of a window is displayed a scroll bar (often called
a thumbnail) will appear. Holding down the mouse button on the small
square within the scroll bar moves the contents of the window.
• Control menu box. As shown in Figure 31.3.
31.5 Mouse controls
The mouse controls the pointer around the screen and the left mouse button is
used either to run an application, if it is an icon, or to single click to select a
window or file, as shown in Figure 31.5.

FIGURE 31.5  Main desktop screen
31.6 Program Manager menus
The Program Manager window has 4 menu options: File, Options, Windows and
Help. Table 31.1 shows the main options and the sub-options. For example, if
the File menu options is selected a sub-menu (a pull-down menu) shows the
options:, New, Open, Move, Copy, Delete, Properties, Run and Exit Windows.
Table 31.1
Menu options
31.6.1 Quitting Windows
To exit Windows, first the File option is selected from Program Manager. Next,
move the mouse pointer down to the Exit Windows option and select it with a
single click of the left mouse button, as shown in Figure 31.6.

FIGURE 31.6  Quitting Windows
31.6.2 Getting Help
The best method of getting help is to refer to the user manual. If that is not
available then there is on-line help. If the Help menu option is selected on the
Program Manager menu displays the options Contents, Search for Help on, How
to use Help, Windows Tutorial and About Program Manager.
31.7 Moving and resizing a window
The options used to change the windows size are:
• Maximizing a window. A window can be made to fill the complete screen by
selecting the 
 at the top right-hand corner of the screen.
• Minimizing a window. A window can be minimized to an icon using
• Making a window smaller. If a window is filling the complete screen it can
be made into a smaller window by selecting 
• Moving a window. A window can be moved by placing the mouse pointer on
the blue title bar. The left mouse button is pressed down while moving
the window to its required position, then the mouse button is released.
• Resizing a window. A window can be resized by placing the mouse pointer
either at one of the corners or the sides. The pointer shape should change
when it is placed over the border of the windows. To expand (or contract)
the window vertically the mouse pointer is placed either at the top or

bottom border. The mouse is then pressed while moving the border of the
windows. When the required position is found the mouse button is
released. A similar operation can be conducted to expand (or contact)
horizontally.
31.8 Closing a window with the Control menu
The Control menu is activated by selecting the top left-hand button on the
window. This menu contains the options: Restore, Move, Size, Minimize,
Maximize, Close, Switch to. The Restore, Move, Size, Minimize and Maximize
options mimic operations that are conducted by the mouse. A useful option is the
Close which exits from the window and closes it down, this is shown in Figure
31.7.
FIGURE 31.7  Control menu
31.9 Exercises
Conduct the following steps filling in the required information.
31.9.1. Switch PC on. Completed successfully []
31.9.2. Start Microsoft Windows and when it shows the initial start-up screen
observe the version number of the software.
31.9.3. Identify each of the active and inactive groups within the Program

Manager.
31.9.4. Identify all programs within three of the groups.
31.9.5. Resize the Program Manager window so that it fills the screen. Tick box
if completed successfully.
   Completed successfully []
31.9.6. Resize the Program Manager window so that it is shown at its normal
position on the screen.
   Completed successfully []

31.9.7. Iconize the Program Manager window and then restore it to its normal
position.
   Completed successfully []
31.9.8. Expand the Program Manager window horizontally, then restore it to its
normal position.
   Completed successfully []
31.9.9. Contract the Program Manager windows vertically, then restore it to its
normal position.
   Completed successfully []
31.9.10. Find the following application programs, run them and then exit. Tick
box if completed successfully.
31.9.11. Exit from Windows using the File menu option in the Program
Manager.
31.9.12. Start Windows again and this time exit using the Control menu.
Operations used:
31.9.13. There is an on-line help facility within Windows. To select this use the
Help menu option within the Program Manager. Use this facility to find
help on the following topics.

quitting windows: —————————
deleting groups: —————————
starting applications: —————————
deleting programs: —————————

32
File Management
32.1 Introduction
The Main group contains important application programs which allow the user
access to the file system, to setup a different environment, to setup different
computer hardware, gain access to DOS, etc. It contains Control Panel, Print
Manager, File Manager, ClipBook Viewer, MS-DOS Prompt, Windows
Setup, PIF Editor and Sysedit. The icons contained within Main are shown
in Figure 32.1.
FIGURE 32.1  Main group
Control Panel sets up the Windows environment and can be used to change
the colours of the windows, the fonts used, etc. The Print Manager program
checks the status of files which have been printed. File Manager allows access to
the file system and can be used to copy or move files from one directory to
another or from one disk drive to another. The MS-DOS Prompt program gives a
DOS window.
32.2 File manager
The file manager is identified by the filing cabinet icon. It is opened by double

clicking the cabinet icon. Files and directories are displayed with their file name
and an icon which indicates the file type. It employs a select, drag and put
technique where a file (or directory), once selected, can be dragged into another
directory or onto any disk drive. Note that the file manager in Windows 3.11
differs slightly from the file manager in Windows 3.1. Figure 32.2 shows the
Windows 3,11 file manager. The main difference is the icons to the right of the
current disk drive name.
FIGURE 32.2  File manager
A directory is identified with the 
 icon. Files have three main icons
associated with them. Application programs are identified with a 
 a document
file by 
 and any other file with a 
. Figure 32.3 shows a sample directory
listing.

FIGURE 32.3  File manager
A document file is a file which when double clicked will start an associated
application. Table 32.1 shows some typical file extensions and the application
which is run when the file is double clicked. For example, a file with a doc
extension will run a word processor, a bmp extension will start the paintbrush
package, and so on.
Table 32.1
File associated with application
File extension
Description
Application started
wav
Sound file
Sound package
txt
Text file
Notepad
doc
Document
Word processor
wk3
Lotus 123 worksheet
Lotus 123
wri
Write document
Write
hlp
Help file
Windows help
pcx
Graphics file
Paintbrush
xls
Microsoft Excell worksheet
Microsoft Excell
ppt
Microsoft Powerpoint presentation
Microsoft Powerpoint
bmp
Bit-mapped graphics file
Paintbrush

32.2.1 Selecting A Drive
A disk drive is selected with a single click on one of the disk icons above the
directory listing or by selecting Disk→Select drive… . In the example in Figure
32.4 there are three drives, a floppy disk on the A: drive, a hard-disk on the C:
drive and a CD-ROM on the D: drive. If there are any network drives these will
also be displayed.
FIGURE 32.4  Displaying directory
32.2.2 Selecting A Directory
A directory is selected by a single click on the directory icon (or on the directory
name). The open file icon (
) then shows which directory is currently open;
the directory display window displays the contents of this directory. An example
of changing the current directory is shown in Figure 32.5. In this example the
user has selected to list the contents of the top-level directory on the C: drive.
Next the mouse pointer is placed over the docs directory which is then opened
with a single click of the left mouse button. After this the admin directory is
opened. A directory can be closed by single mouse button click when it is open

(another click will open it again).
FIGURE 32.5  Selecting disk format option
32.2.3 Formatting A Disk
A floppy disk must be formatted before it can store files. Some disks are pre-
formatted when they are purchased, but others required to be formatted before
they are used. Care must be taken when formatting a disk as the current contents
of the disk will be erased.
To format a disk first insert it into the floppy disk drive. Next select
Disk→Format disk … from the menu, as shown in Figure 32.5. When this is
selected Windows will prompt the user for the drive which the disk has been
entered and the capacity of the disk. By default this is likely to be set to A: and
1.44 MB (for a 3.5 inch floppy disk drive on the A: drive), respectively. If the
drive differs from the default or its format differs then change the options by
pulling down the Disk In or the Capacity options.
Figure 32.6 shows the main steps that are taken to format the disk. First the
disk capacity and drive name are prompted for. When these are correct the OK
button is selected. Next a Format Disk window is displayed. Within this
window the current status of the disk formatting operation is displayed (from 0
to 100% complete). When complete, a window with a message Creating root
directory will be displayed. After this the formatted disks’ capacity is
displayed and the user is prompted as to whether another disk is to be formatted.
If no more disks are to be formatted then the No option is selected else Yes is
selected. Note that the Cancel option on any of the format status windows can be
selected to cancel the format process.

FIGURE 32.6  Formatting a floppy disk
32.2.4 Moving Files On The Same Disk Drive
Microsoft Windows uses a select, drag and drop procedure when copying or
moving files or directories. Moving files (copying them but deleting the original
file) can be achieved by moving the mouse pointer over the file and then
dragging the icon, while keeping the left mouse button held down, then placing
it in the desired directory. Figure 32.7 shows an example of the file acc2.wk1
being dragged into the directory C:\DOCS\BUSINESS.

FIGURE 32.7  Copying or moving a file on the same disk drive
32.2.5 Copying Files On The Same Disk Drive
Copying files to a new location is achieved by holding down the Ctrl key and
dragging the file to the desired directory, see Figure 32.8.
FIGURE 32.8  Delete confirmation
32.2.6 Copying Files To A Different Disk Drive
Copying files or directories to a disk drive is achieved by simply dragging the
file or directory icon to the drive icon. This is similar to moving files on the

same disk drive but in this case the file will not be deleted on the source
directory.
32.2.7 Moving Files To A Different Disk Drive
Moving files or directories to another disk drive is achieved by simply dragging
the file or directory icon, while pressing the Shift key, and dragged it to the
required drive icon.
32.2.8 Deleting Files
When a file is no longer required it can be deleted. This is achieved by clicking
on the file to be deleted and pressing the Del key on the keyboard. A message
asking for confirmation should appear, as shown in Figure 32.8. If the file is to
be deleted then the OK button is selected else Cancel. The confirmation window
for deleting a directory is different, an example is shown in Figure 32.9. After
the user selects the directory to delete a confirmation is displayed with either Yes
or Yes to All. If the user selects Yes then each file within the directory will be
prompted for deletion confirmation. If Yes to All is selected then all files within
the directory (and sub-directories) will be deleted without any confirmation.
FIGURE 32.9  Delete directory confirmation
32.2.9 Running Windows And DOS Applications
Running a file is achieved by placing the mouse pointer over the application file
and double clicking the left mouse button. If it is a Microsoft Windows
application it will be run as a normal Windows application, else if it has an
application attached to it then the associated application will be run and the
selected file loaded into it. For example, if it were a document file (.DOC) then a

word processor will be started with the selected document loading into it.
If a DOS-based application is selected then a DOS screen will appear which
will then load the program (if it can).
32.3 Exercises
Conduct the following steps filling in the required information.
32.3.1. Start Microsoft Windows. Completed successfully []
32.3.2. Identify some of the directories and sub-directories on the C: drive on the
PC and complete the table given in Figure 32.10.
FIGURE 32.10  Directory structure of C: drive
32.3.3. Identify some application programs within the \dos directory.
   Application programs: ____________________
   ____________________

32.3.4. Identify some application programs within the \windows directory.
   Application programs: ____________________
   ____________________
32.3.5. Identify some files which are in the \WINDOWS directory which will run
application programs
   Files: ____________________
   ____________________
32.3.6. On the C: drive find 5 graphics files (in any directory). Files:
   Files: ____________________
   ____________________
32.3.7. On the C: drive find 5 document files (in any directory). Files:
   Files: ____________________
   ____________________
32.3.8. Insert a floppy disk in the A: drive and format it.
   Total disk space: ____________________
   ____________________
32.3.9. Create a document file either by running Cardfile (within the Main
group) or running Write (within Accessories) or using a word processor
such as Word for Windows or Ami-Pro. Enter some text into the
document then save it in the C:\windows directory with the name
DOC1.DOC.
   Completed successfully []
32.3.10. Verify, with File Manager, that this file is in the \windows directory.
   Completed successfully []
32.3.11. Copy the file DOC1.DOC to the floppy disk in the A: drive.
   Completed successfully []
32.3.12. Verify, with File Manager, that the file has been copied to the A: drive.
If it is in the wrong place move it.
   Completed successfully []
32.3.13. Create a directory on the C: drive, named temp, below the top-level
directory using the File→Create Directory menu option.
   Completed successfully []
32.3.14. Verify, with File Manager, that this directory exists. If it is in the wrong
place move it.
   Completed successfully []
32.3.15. Copy the file DOC1.DOC to the temp directory.
   Completed successfully []

32.3.16. Verify, with File Manager, that the file is in the temp directory.
   Completed successfully []
32.3.17. There is an on-line help facility for the help manager within Windows.
To select this use the Help menu option within the File Manager. Use
this facility to find help on the following topics.
selecting files: ———————–
sorting files: ———————–
copying disks: ———————–
starting applications: ———————–

PART H
Windows 95/NT

33
Windows 95/NT
33.1 Introduction
Windows NT has provided an excellent network operating system. It
communicates directly with many different types of networks, protocols and
computer architectures. Windows NT and Windows 95 have the great advantage
of other operating systems in that they have integrated network support.
Operating systems now use networks to make peer-to-peer connections and also
connections to servers for access to file systems and print servers. The three
most widely used operating systems are MS-DOS, Microsoft Windows and
UNIX. Microsoft Windows comes in many flavours; the main versions are
outlined below and Table 33.1 lists some of their attributes.
Table 33.1
Windows comparisons
• Microsoft Windows 3.xx –16-bit PC-based operating system with limited
multitasking. It runs from MS-DOS and thus still uses MS-DOS
functionality and file system structure.
• Microsoft Windows 95 – robust 32-bit multitasking operating system

(although there are some 16-bit parts in it) which can run MS-DOS
applications, Microsoft Windows 3.xx applications and 32-bit
applications.
• Microsoft Windows NT – robust 32-bit multitasking operating system with
integrated networking. Networks are built with NT servers and clients. As
with Microsoft Windows 95 it can run MS-DOS, Microsoft Windows 3.x
applications and 32-bit applications.
33.2 Servers, workstations and clients
Microsoft Windows NT is a 32-bit, pre-emptive, multitasking operating system.
One of the major advantages it has over UNIX is that it can run PC-based
software. A Windows NT network normally consists of a server and a number of
clients. The server provides file and print servers as well as powerful networking
applications, such as electronic mail applications, access to local and remote
peripherals, and so on.
The Windows NT client can either:
• Operate as a stand-alone operating system.
• Connect with a peer-to-peer connection.
• Connect to a Windows NT server.
A peer-to-peer connection is when one computer logs into another computer.
Windows NT provides unlimited outbound peer-to-peer connections and
typically up to 10 simultaneous inbound connections.
33.3 Workgroups and domains
Windows NT assigns users to workgroups which are collections of users who are
grouped together with a common purpose. This purpose might be to share
resources such as file systems or printers, and each workgroup has its own
unique name. With workgroups each Windows NT workstation interacts with a
common group of computers on a peer-to-peer level. Each workstation then
manages its own resources and user accounts. Workgroups are useful for small
groups where a small number of users require to access resources on other
computers.
A domain in Windows NT is a logical collection of computers sharing a
common user accounts database and security policy. Thus each domain must
have at least one Windows NT server.

Windows NT is designed to operate with either workgroups or domains.
Figure 33.1 illustrates the difference between domains and workgroups.
FIGURE 33.1  Workgroups and domains
Domains have the advantages that:
• Each domain forms a single administrative unit with shared security and user
account information. This domain has one database containing user and
group information and security policy settings.
• They segment the resources of the network so that users, by default, can view
all networks for a particular domain.
User accounts are automatically validated by the domain controller. This stops
invalid users from gaining access to network resources.
33.4 Windows NT user and group accounts
Each user within a domain has a user account and is assigned to one or more
groups. Each group is granted permissions for the file system, accessing printers,
and so on. Group accounts are useful because they simplify an organization into
a single administrative unit. They also provide a convenient method of
controlling access for several users who will be using Windows NT to perform
similar tasks. By placing multiple users in a group, the administrator can assign
rights and/or permissions to the group.

Each user on a Windows NT system has the following:
• A user name (such as fred_bloggs).
• A password (assigned by the administrator then changed by the user).
• The groups in which the user account is a member (such as, staff).
• Any user rights for using the assigned computer.
Each time a user attempts to perform a particular action on a computer,
Windows NT checks the user account to determine whether the user has the
authority to perform that action (such as read the file, write to the file, delete the
file, and so on).
Normally there are three main default user accounts: Administrator, Guest and
an ‘Initial User’ account. The system manager uses the Administrator account to
perform such tasks as installing software, adding/deleting user accounts, setting
up network peripherals, installing hardware, and so on.
Guest accounts allow occasional users to log on and be granted limited rights
on the local computer. The system manager must be sure that the access rights
are limited so that hackers or inexperienced users cannot do damage to the local
system.
The ‘Initial User’ account is created during installation of the Windows NT
workstation. This account, assigned a name during installation, is a member of
the Administrator’s group and therefore has all the Administrator’s rights and
privileges.
After the system has been installed the Administrator can allocate new user
accounts, either by creating new user accounts, or by copying existing accounts.
33.5 File systems
Windows NT supports three different types of file system:
• FAT (file allocation table) – as used by MS-DOS, OS/2 and Windows NT/95.
A single volume can be up to 2 GB.
• HPFS (high performance file system) – a UNIX-style file system which is
used by OS/2 and Windows NT. A single volume can be up to 8 GB.
MS-DOS applications cannot access files.
• NTFS (NT file system) – as used by Windows NT. A single volume can be
up to 8 GB. MS-DOS applications, themselves, cannot access the file
system but they can when run with Windows NT.
The FAT file system is widely used and supported by a variety of operating
systems, such as MS-DOS, Windows NT and OS/2. If a system is to use MS-

DOS it must be installed with a FAT file system.
33.5.1 FAT
The standard MS-DOS FAT file and directory-naming structure allows an 8-
character file name and a 3-character file extension with a dot separator (.)
between them (the 8.3 file name). It is not case sensitive and the file name and
extension cannot contain spaces and other reserved characters, such as:
With Windows NT and Windows 95 the FAT file system supports long file
names which can be up to 255 characters. The name can also contain multiple
spaces and dot separators. File names are not case sensitive, but the case of file
names is preserved (a file named FredDocument.XYz will be displayed as
FredDocument.XYz but can be accessed with any of the characters in upper or
lower case).
Each file in the FAT table has four attributes (or properties): read-only,
archive, system and hidden (as shown in Figure 33.2). The FAT uses a linked list
where the file’s directory entry contains its beginning FAT entry number. This
FAT entry in turn contains the location of the next cluster if the file is larger than
one cluster, or a marker that designates this is included in the last cluster. A file
which occupies 12 clusters will have 11 FAT entries and 10 FAT links.

FIGURE 33.2  File attributes
The main disadvantage with FAT is that the disk is segmented into allocated
units (or clusters). On large-capacity disks these sectors can be relatively large
(typically 512 bytes/sector). Disks with a capacity of between 256 MB and 512
MB use 16 sectors per cluster (8KB) and disks from 512 MB to 1 GB use 32
sectors per cluster (16 KB). Drives up to 2 GB use 64 sectors per cluster (32
KB). Thus if the disk has a capacity of 512 MB then each cluster will be 8 KB.
A file which is only 1 KB will thus take up 8 KB of disk space (a wastage of 7
KB), and a 9 KB file will take up 16 KB (a wastage of 7 KB). Thus a file system
which has many small files will be inefficient on a cluster-based system. A
floppy disk normally use 1 cluster per sector (512 bytes).
Windows 95 and Windows NT support up to 255 characters in file names;
unfortunately, MS-DOS and Windows 3.xx applications cannot read them. To
accommodate this, every long file name has an autogenerated short file name (in
the form XXXXXXXX.YYY). Table 33.2 shows three examples. The
conversion takes the first six characters of the long name then adds a ~number to
the name to give it a unique name. File names with the same initial six characters
are identified with different numbers. For example, Program Files and Program
Directory would be stored as PROGRA~1 and PROGRA~2, respectively. Sample
listing 33.1 shows a listing from Windows NT. The left-hand column shows the
short file name and the far right-hand column shows the long file name.
Table 33.2

File name conversions
Long file name
Short file name
Program Files
PROGRA∼1
Triangular.bmp
TRAING∼1.BMP
Fredte∼1.1
FRED.TEXT.1
33.6 Running Windows 95 and NT
Windows 95 and NT are operating systems in their own right and thus do not
require DOS. The version of DOS which is run in Window 95/NT is an emulated
version.
Sometimes Windows NT/95 develops a problem when starting the computer.
If this occurs then it can be started in a safe mode, which does not load network
support and using the default settings (VGA monitor, no network, Microsoft
mouse driver, and the minimum device drivers required to start Windows). This
is achieved by pressing the F8 key when Windows is being booted. Normally the
user then selects Settings and then Control Panel to change the systems
settings.
Often the problem with the system start-up is to do with either AUTOEXEC.BAT
or CONFIG.SYS files. If this is the case the Command Prompt Only operation
setting can be selected when starting the computer. This option bypasses the two
system files. Otherwise, the Step-by-Step Confirmation can be selected, which
allows the user to load a specific system driver.
Another method of fixing the system is to boot the system with a bootable
DOS disk. The user can then try to fix the system. Note that this can only be
done if the disk has been formatted as FAT.

33.7 Basic Windows NT/95
There are many enhancements on Windows NT/95 as opposed to previous
versions. The main differences are:
• 
 Start button and taskbar. The task bar appears at the bottom of the
screen and it contains the Start button, which can be used to quickly start
a program. The taskbar also shows the programs which are currently
running and it can thus be used to switch between programs.
• 
 Folders. Documents and programs are stored in folders. In DOS and
previous versions of Windows these folders were called directories.
• The desktop. The desktop is the area of screen which appears when
Windows is started. Figure 33.3 shows an example. It can be customized
by adding program shortcuts, documents, printers, and the layout and
style of the background. To adjust settings such as desktop colour and
background, use your right mouse button to click anywhere on the
desktop, and then click Properties. Figure 33.4 shows an example of the
Properties window.
FIGURE 33.3  Example desktop screen

FIGURE 33.4  Example desktop screen
• 
 Network Neighborhood. Windows 95/NT has extensive support
for networking. If a network is present then the Network Neighborhood
icon appears on your desktop. The user can then browse the entire
network by double-clicking the icon.
• 
 My Computer. The My Computer icon allows quick and easy
access to the computer. The user can browse through the files and folders
by double-clicking the My Computer icon.
• 
 Windows Explorer. This is a program that allows the user to view
both the hierarchy of folders on your computer and all the files and
folders in each selected folder. It is typically used to copy and move files,
where files can be dragged into a specific folder.
• Properties. Each icon which appears in Windows 95/NT has associated
properties. It views the properties then the right mouse button clicks on
the item, and then clicks Properties from the pop-up menu.
• Shortcut menus. A shortcut menu is displayed when the user clicks the right

mouse button on an item. This menu allows the user to open, copy or
delete the item.
• Close, Minimize, and Maximize buttons. Each window has a close button 
 in the upper-right corner which, when clicked, will close the window
and quit the program. The windows can also minimize or maximize 
.
The current active window has a blue title bar whilst an inactive window has a
grey title bar. Only icons within an active window can be selected.
33.8 Mouse controls
The mouse controls the pointer around the screen. As with previous versions of
Windows, a double click of the left mouse button on an icon is used to either run
an application and a single click to select a window or file.
33.9 Quitting Windows
The user must shut Windows down before switching off the computer. To do
this the user selects the Shut Down … option from the Start bar. Then the user
will be given a number of options, as shown in Figure 33.5. If the user is to quit
and switch off then the Shut down the computer option is selected and Yes is
selected.
FIGURE 33.5  Quitting Windows

33.9.1 Getting Help
The best method of getting help is to refer to the user manual. If that is not
available then there is on-line help. The on-line manual is available by selecting
the help manual icon.
33.10 Moving and resizing a window
The option used to change the windows size are:
• Maximizing a window. A window can be made to fill the complete screen by
selecting the 
 at the top right-hand corner of the screen.
• Minimizing a window. A window can be minimized to an icon using
• Making a window smaller. If a window is filling the complete screen it can
be made into a smaller window by selecting 
• Moving a window. A window can be moved by placing the mouse pointer on
the blue title bar. The left mouse button down is pressed while moving
the window to its required position, then the mouse button is released.
• Resizing a window. A window can be resized by placing the mouse pointer
either at one of the corners or the sides. The pointer shape should change
when it is placed over the border of the windows. To expand (or contract)
the window vertically the mouse pointer is placed either at the top or
bottom border. The mouse is then pressed while moving the border of the
windows. When the required position is found the mouse button is
released. A similar operation can be conducted to expand (or contract)
horizontally.
33.11 Closing a window with the Control menu
The Control menu is activated by select the top left-hand button on the window.
This menu contains the options: Restore, Move, Size, Minimize, Maximize and
Close. The Restore, Move, Size, Minimize and Maximize options mimic
operations that are conducted by the mouse. A useful option is the Close which
exits from the window and closes it down; this is shown in Figure 33.6.

FIGURE 33.6  Control menu
33.12 Start
The Start button at the bottom left-hand side is used to quickly run application
programs. An example Start bar is shown in Figure 33.7.
FIGURE 33.7  Example start options

33.13 My Computer
The My Computer window allows access to local disks, such as the floppy disk
and hard disks, printers, CD-ROM, and so on. Figure 33.8 shows an example
window.
FIGURE 33.8  Example My Computer
33.14 Running DOS
Windows NT/95 runs an emulated version of DOS. This is typically used to run
DOS-based program and also to run DOS commands. Figure 33.9 shows how a
DOS window is initiated. It can either run in a window or full-screen. Figure
33.10 shows a sample DOS window.

FIGURE 33.9  Selecting MS-DOS Prompt
FIGURE 33.10  DOS window

33.15 Windows 95/NT network drives
Windows NT and 95 displays the currently mounted network drives within the
group My Computer. Figure 33.11 shows drives which are either local (C: D:
and E:) or mounted using NetWare (F: G: and so on). Windows NT and 95 also
automatically scan the neigbouring networks to find network servers. An
example is shown in Figures 1.12 and 1.13. Figure 33.13 shows the currently
mounted servers (such as, EECE_l) and by selecting the Global Network icon all
the other connected local servers can be shown.
FIGURE 33.11  Mounted network and local drives

FIGURE 33.13  Local neighbourhood servers
FIGURE 33.12  Network neighbourhood
33.16 Exercises
Conduct the following steps filling in the required information.
33.16.1. Windows version. Windows 95 [ ] Windows NT [ ] Other [ ]
33.16.2. Networked computer. Yes [ ] No [ ]
33.16.3. Identify each of the icons on the desktop:
33.16.4. Select My Computer and resize it so that it fills the screen. Tic box if
complete successfully.
   Completed successfully [ ]

33.16.5. Resize My Computer so that it is shown at its normal position on the
screen.
   Completed successfully [ ]
33.16.6. Iconize My Computer and then restore it to its normal position.
   Completed successfully [ ]
33.16.7. Expand My Computer horizontally, then restore it to its normal
position.
   Completed successfully [ ]
33.16.8. Contract My Computer window vertically, then restore it to its normal
position.
   Completed successfully [ ]
33.16.9. Find the following application programs, run them and then exit. Tic
box if complete successfully.
33.16.10. Open a DOS window and move around the file system. List some of
the directories on the system:
33.16.11. Exit from Windows.
   Completed successfully [ ]
33.16.12. Start Windows again.
   Completed successfully [ ]
33.16.13. There is an on-line help facility within Windows. To select this, use
the Help menu option within the Program Manager. Use this facility to
find help on the following topics.
Quitting windows: _____________________

Deleting folders: _____________________
Starting applications: ______________________
Deleting programs: ______________________

34
Extra Windows
34.1 Saving important set-up files
Windows 3.x and Windows 95/NT store important program configuration
information in INI file. These are normally either stored in the default windows
directory or in the home directory of the application. The important files for
Windows configuration are:
• SYSTEM.INI. This contains information on the configuration of various
programs and also programs which are initiated when Windows is
started.
• WIN.INI. This contains information of the desktop, such as the groups which
are displayed, their position on the desktop and their size.
It is important to backup the initialization files as these can be easily modified
by mistake. Initialization files have a INI extension and are stored in the
\WINDOWS directory. To make a backup of these files create a directory named
INI as a subdirectory of the \WINDOWS directory can copy these INI files into it.
If one of these files is modified by mistake it is a simple task to copy an older
version back into the \WINDOWS directory. This procedure is shown in Test run
34.1.

34.2 Running a program when Windows starts
up
Programs can be initiated when Windows is started. Typical programs which can
be loaded are the clock, a word processor, a spreadsheet or a calendar. This can
be achieved by selecting the following folder: Selecting Windows→Start
Menu→Programs→StartUp
Then the startup item is added by either dragging it into the StartUp folder or
by selecting File→New.
FIGURE 34.1  Adding to the StartUp folder
In Windows 3.1 it is selected by:
• The application icon can be inserted into the StartUp group so that it will
automatically start when windows is started. To create a new StartUp
group, select File>New from Program Manager, as illustrated in Figure
34.2. Next select a group and name it StartUp. Icons can then be dragged
from another group into this one.
FIGURE 34.2  Creating a StartUp group
    Once the startup group has been initiated an empty window should be
displayed. To move a program point to it with the cursor then hold the

first mouse key down and drag it into the StartUp group. If the program
is to be copied (and not moved) then hold down the Ctrl key as the icon is
dragged. Figure 34.2 shows a StartUp windows with the Calendar and
Clock.
A program can also be automatically started by editing the WIN.INI file so that
the program name is inserted after the run= directive. For example, to run the
clock and Word for Windows the following can be inserted:
To load a program which is minimized (that is, it will appear as an icon at the
bottom of the screen) the load= directive is used. For example, to start the
programs Word for Windows 6.0 and cardfile the following can be inserted
into the WIN.INI file
34.3 Capturing Windows screen
There are two hot keys set-up in Windows to capture screens:
• Print Screen key captures a complete screen.
• Alt-Print Screen captures only the current window.
These captured screens are put into the clipboard. Figure 34.3 shows the
Clipboard Viewer screen after a screen has been captured from Microsoft Word
for Windows 2.0. The contents of the clipboard can be imported into a document
or other application by pasting. This can either be done by selecting the Paste
from a menu or Ctrl-V.

FIGURE 34.3  Contents of Clipboard Viewer after a screen has been captured
34.4 Swapping between applications
The Alt-TAB hot key can be used to switch between one application and
another. For example:
1. Run an application.
2. Press Alt-TAB to cycle through the Windows applications on the desktop.
The name of the application appears at the top of the screen.
Figure 34.4 shows an example of swapping between a Windows screen and
another application.

FIGURE 34.4  Swapping between applications
34.5 Terminating programs which have crashed
If a program has crashed it can normally be terminated using the Ctrl-Alt-Del
keystrokes. If Windows is still running it will display a blue screen which asks
the user to either press <RETURN> if the program is to be terminated to use
Ctrl-Alt-Del to reboot the system. Normally it is only required to terminate the
crashed program so press <RETURN>.
34.6 Windows file extensions
Windows uses a large number of file types. Table 34.1 gives the basic file type
extensions.
Table 34.1
File extensions

34.7 Exercises
34.7.1. Start the calculator program and then press Ctrl-Alt-Del. Confirm that a
similar screen to the one shown in Figure 34.5. Next shut down the
program.
FIGURE 34.5  Closing an application
   Completed successfully [ ]
34.7.2. Identify some INI files and the application program that they are likely to
be linked to.
   Completed successfully [ ]
34.7.3. List some of the WIN.INI and SYSTEM.INI files. Identify some of the
lines in these files.
   Completed successfully [ ]
34.7.4. Run the Calculator and Notepad programs (from the Accessories group)
and use the Alt-TAB keystroke to swap between these applications.
   Completed successfully [ ]

34.7.5. With the Calculator program, determine the following:
(i) 54 × 32
(ii) 10432 54
(iii) √l63
    Completed successfully [ ]
34.7.6. With the Notepad program, create a file called MYFILE.TXT and add
the following text:
   Completed successfully [ ]
34.7.7. Quit the Calculator and Notepad programs.
   Completed successfully [ ]
34.7.8. Locate the MYFILE.TXT file and open it to see that it contains the
entered text.
   Completed successfully [ ]
34.7.9. Close the Notepad program.
   Completed successfully [ ]
34.7.10. From the operating system, change the name of MYFILE.TXT to
MYFILE2.TXT.
   Completed successfully [ ]
34.7.11. From the operating system, copy the MYFILE2.TXT file into
MYFILE3.TXT file.
   Completed successfully [ ]
34.7.12. Format a floppy disk and copy the MYFILE2.TXT file onto it.
   Completed successfully [ ]

PART I
UNIX

35
Introduction to UNIX
35.1 Introduction
UNIX is an extremely popular operating system and dominates in the high-
powered, multitasking workstation market. It is relatively simple to use and to
administer, and also has a high degree of security. UNIX computers use TCP/IP
communications to mount disk resources from one machine onto another. Its
main characteristics are:
• Multi-user.
• Pre-emptive multitasking.
• Multi-processing.
• Multi-threaded applications.
• Memory management with paging (organizing programs so that the program
is loaded into pages of memory) and swapping (which involves swapping
the contents of memory to disk storage).
The two main families of UNIX are UNIX System V and BSD (Berkeley
Software Distribution) Version 4.4. System V is the operating system most often
used and has descended from a system developed by the Bell Laboratories and
was recently sold to SCO (Santa Cruz Operation). Popular UNIX systems are:
• AIX (on IBM workstations and mainframes).
• HP-UX (on HP workstations).
• Linux (on PC-based systems).
• OSF/1 (on DEC workstations).
• Solaris (on Sun workstations).
An initiative by several software vendors has resulted in a common standard
for the user interface and the operation of UNIX. The user interface standard is
defined by the common desktop environment (CDE). This allows software
vendors to write calls to a standard CDE API (application specific interface).
The common UNIX standard has been defined as Spec 1170 APIs. Compliance
with the CDE and Spec 1170 API is certified by X/Open, which is a UNIX

standard organization.
35.2 Login into the system
In order to connect to the system a valid user ID and a password are required.
These are assigned initially by the system manager. In Sample session 35.1 the
user bill_b logs in with the correct password. If the user ID and password are
valid then system messages are then displayed in a start-up screen (such as
system shut-downs, holiday arrangements, and so on) and the command line
prompt 
is 
displayed 
(in 
this 
case
[51:miranda:/net/castor_win/local_user/bill_b]%). The computer is now
ready for a command.
35.3 Directory structure
Files are used to store permanent information which are used by programs. The
information could be schematics, text files, documents, and so on. In order to
facilitate the recovery of files they are arranged into directories in a structure that
is similar to an office filing system. The UNIX file directory structure takes the
form of a tree with the root directory at the highest level. This top level, or root
directory, is given the name /. An example of a directory system is shown in
Figure 35.1. In this case there are 5 sub-directories below the root level, these

are bin, usr, etc, dev and user. Below the usr directory there are 3 sub-
directories, these are lib, adm and bin. In this case, all the users of the system
have been assigned to a sub-directory below the users directory, that is,
bill_b,fred_a and alan_g.
FIGURE 35.1  Basic directory structure
The full pathname of the bill_b directory is /users/bill_b and the full
pathname of the adm directory is usradmin. Files can be stored within a
directory structure. Figure 35.2 shows an example structure.

FIGURE 35.2  Basic directory structure showing files within directories
In this case, the full pathname of the FORTRAN file prog.ftn is:
and the full pathname of the c directory is:
Files and sub-directories can also be referred to in a relative manner, where
the directory is not reference to the top-level (it thus does not have a preceding
/). For example, if the user was in the bill_b directory then the relative path for
the C program file1.c is:
35.4 On-line manual
Unix provides an on-line manual to give information on all the UNIX

commands. To get information man command-name is used, such as:
Examples are man 1s, man cd, and so on. Sample session 35.2 shows an
example of the help manual for the 1s command.
35.5 Changing directory
The pwd command can be used to determine the present working directory. and
the cd command can be used to change the current working directory. When
changing directory either the full pathname or the relative pathname is given. If a
/ precedes the directory name then it is a full pathname, else it is a relative path.
Some special character sequences are used to represent other directory, such as
the directory above the current directory is specified by a double dot (. .).
Thus to move to the directory above the command cd..can be used. If the cd
command is used without any preceding directory specifier then the directory
will be changed to the user’s home directory. Some example command sessions
are given next.

35.6 Listing directories
The ls command lists the contents of a directory. If no directory-name is given
then it lists the contents of the current directory. Sample session 35.3 shows a
typical session. In [5] the user moves to the directory above and in [11] the user
move back to the home directory.
The basic directory listing gives no information about the size of files, if it is a
directory, and so on. To list more information the –1 option is used. An example
session is shown in Sample session 35.5. In [15] the user requests extended
information on the files.

Other options can be used with ls; to get a full list use the on-line manual. In
Sample session 35.1 it was seen that other possible extensions are a b c d f g
i l m n o p q r s t u x A C F H L R 1.
Examples of usage are:
It is also possible to specify more than one extension, such as 1s –dr which
lists only directories in reverse order.
35.7 File attributes
UNIX provides system security by assigning each file and directory with a set of
attributes. These give the privileges on the file usage and their settings are
displayed with the 1s –1 command. In the case of [15] in Sample session 35.4,
the user uses 1s –1 to get extended information. The directory listing gives six
main fields; these are:
• File attributes.
• Owner of the files. Person (user ID) who owns the file.
• Group information. The group name defines the name of the group the group
the attributes concern.
• Size of file. The size of the file in bytes (8 bits).
• Date and time created or last modified. This gives the date and time the file

was last modified. If it was modified in a different year then the year and
date are given, but no time information is given.
• Filename.
Figure 35.3 defines the format of the extended file listing. The file attributes
contain the letters r, w, x which denote read, write and executable. If the
attribute exists then the associated letter is placed at a fixed position, else a –
appears. The definition of these attributes are as follows:
FIGURE 35.3  Extended file listing
• Read (r). This file can be copied, viewed, and so on, but it cannot be
modified.
• Write (w). This file can be copied, viewed and changed, if required.
Executable (x). It is possible to execute this program.
The file attributes split into four main sections. The first position identifies if
it is a directory or a file. A d character identifies a directory, else it is a file.
Positions 2–4 are the owner attributes, positions 5–7 are the groups attributes
and positions 8–10 are the rest of the world’s attributes. Table 35.1 lists some
examples.
Table 35.1
Example file attributes

Attributes
Description
-r-x–x—
This file can be executed by the owner and his group (e.g. staff, students, admin, research,
system, and so on). It can be viewed by the owner but no-one else. No other privileges
exist.
drwxr-xr-x
This directory can be cannot be written to by the members of group and others. All other
privileges exist
-rwxrwxrwx
This file can be read and written to by everyone and it can also be executed by everyone
(beware of this).
35.7.1 Changing Attributes Of A File
As we have seen, files have certain attributes such a read/write privileges, and so
on.
The chmod command can be used by the owner of the file to change any of the
file attributes. A general format is given next.
where settings define how the attributes are to be changed and which part of
the attribute to change. The characters which define which part to modify are u
(user), g (group), o (others), or a (all). The characters for the file attributes are a
sign (+, – or =) followed by the characters r, w, x. A ‘+’, specify that the
attribute is to be added, a specifies that the attribute is to be taken away. The ‘=’
defines the actual attributes. Some examples are given next:
In Sample session 35.5 [20] the owner of the file changes the execute attribute
for the user.

35.8 Special characters (*,? and [ ])
There are several special characters which aid access to files. These are stated in
Table 35.2.
Table 35.2
Special characters
Char
Description
?
matches any single character in a filename.
*
matches zero or more characters in a filename.
[ ]
matches one character at a time, these characters are contained in the squared brackets.
Sample session 35.6 shows a few sample uses of wildcards. In [24] the user
lists all the files which begin with the letter ‘m’. In [26] all two letter filenames
beginning with ‘c’ are listed. Then in [27] the files which begin with the letters
‘a’, ‘b’ or ‘c’ are listed.

Note that [a–c] represents [abc] and [1–9] represents [123456789].
35.9 Listing contents of a file
The command to list the contents of a file is cat, its form is:
Sample session 35.7 shows how it is used. If a file is larger than one screen
full it is possible to stop the text from scrolling by using Cntl-S (⁁S) to stop the
text and Cntl-Q (^Q) to start.
35.10 Making and removing directories
To make a directory the mkdir command is used, its form is:

to remove a directory the rmdir command is used, its form is:
In both cases the full pathname or relative pathname can be given.
35.11 Copying, renaming and removing
The command to copy files is the cp command. The standard format is:
and the command to rename (or move) is called mv. Its standard format is:
Files are erased, or deleted, using the rm command. Sample session 35.8
shows some uses of these commands.

35.12 Standard input and output
The standard input device for a program is via the keyboard and the standard
output is to the monitor. In UNIX all input output devices are communicated
with through a device file, which are stored in the /dev directory. For example,
each connected keyboard to the system (including remote computers) has a
different device name. To determine which is your terminal pathname use the
tty command as shown in Sample session 35.9.

35.12.1 Redirection
It is possible to direct the input and/or output from a program to another file or
device.
Redirecting output
The redirection symbol (>) redirects the output of a program to a given file (or
output device). This output will not appear on the monitor (unless it is redirected
to it). Sample session 35.10 shows how the output from a directory listing can be
send to a file named dirlist (see [57]). The contents of this file are then listed
in [58].
The redirection of output is particularly useful when a process is running and
an output to the screen is not required. Another advantage of redirection is that it
is possible to keep a permanent copy of a program’s execution.
To create a text file the cat command is used with the redirection, as shown
next. The file is closed when the user uses the CNTRL-D keystroke, as shown in
Sample run 35.11.
If the user does not want the output to appear on the screen then it can be
redirected to the file called devnull. This is the systems wastepaper basket and it
will automatically be deleted.
Redirecting input
The input can be redirected with the redirect symbol (<). The file given after the
symbol is taken as the input. For example:

In this case the program prog1 takes its input from the file inputfile, and not
from the keyboard.
35.12.2 Pipes
The pipe allows the output of one program to be sent to another as the input. The
symbol used is the vertical bar (|) and its standard form is:
This notation means that the output of program_a is used as the input to
program_b. The pipe helps in commands where a temporary file/s needs to be
created. For example, to find out who is logged into the system the who –a
command can be used. If names in a file need to be sorted alphabetically the
sort command can be used. Thus to sort the users on the system alphabetically
we can use:

It is possible to achieve this with one line using pipes.
35.13 Compiling C programs
The cc command is used to compile and link a program. If there are no errors in
the C source code then, by default, a file named a.out will be produced. This can
then be executed. If another executable filename is required then the -o
filename option can be used. Sample session 35.14 shows how the C file
file.c is compiled and linked to an executable file named file.

35.14 Displaying the time and date
The command to display the date is simply date. This is shown in Sample
session 35.15.
35.15 Where to find things
UNIX has various default directories which store standard command programs
and configuration files. Some of these are defined in the following sections.
35.15.1 /Bin
The /bin directory contains most of the standard commands, such as compilers,
UNIX commands, program development tools, and so on. Examples are:
• FORTRAN and C compilers, f 77 and cc.
• commands such as ar, cat, man utilities.
35.15.2 /Dev

The /dev directory contains special files for external devices, terminals,
consoles, line printers, disk drives, and so on.
35.15.3 /Etc
The /etc directory contains restricted system data and system utility programs
which are normally used by the system manager. These include password file,
login, and so on. Examples are:
35.15.4 /Lib
The /lib directory contains system utilities and FORTRAN and C runtime
support, system calls and input/output routines.
35.15.5 /Tmp
Temporary (scratch) files used by various utilities such as editors, compilers,
assemblers. These are normally stored in the / tmp directory.
35.15.6 Usradm
The usradm stores various administrators files, such as:

35.15.7 Usrbin
The usrbin contains less used utility programs, such as:
35.15.8 Usrinclude
The usrinclude directory contains C #include header files, such as:
35.15.9 Usrlib
The usrlib directory contains library routines and setup files, such as:
35.15.10 Usrman
The usrman contains the manual pages, such as
35.16 Exercises
35.17.1. Go to your home directory.

35.17.2. Display the current system date.
35.17.3. Display the on-line help manual for the following commands:
   Completed successfully: YES/NO
35.17.4. List all the users currently logged into the system.
35.17.5. Create a directory named src in your home directory.
35.17.6. Go into the directory src and create a sub-directory named cprogs.
35.17.7. Go into the cprogs directory and create a file named file1.c using cat
(or the system editor). Enter the following text and save the file.
35.17.8. List the file you have just created.
   Completed successfully: YES/NO
35.17.9. Change the name of this file to file2.c.
   Completed successfully: YES/NO

35.17.10. Make a copy of this file and name it file3.c.
   Completed successfully: YES/NO
35.17.11. Change the file attributes of this file so that the public cannot read
from or write to this file.
35.17.12. Create another named file2.c and enter the following source code.
35.17.13. Concatenate the two files together. Call the resultant file src.lis.
   Completed successfully: YES/NO
35.17.14. Compile and run the two C programs just created.
   Completed successfully: YES/NO
35.17.15. Remove the file src.lis
   Completed successfully: YES/NO
35.17.16. Investigate the following commands/ utilities:
35.17.17. Locate the following utility files and determine their usage.

35.17.18. Sketch a rough outline of the directory structure of the system.
35.17 Summary
Table 35.3 lists some standard UNIX commands.
Table 35.3
Commands summary
Command
Description
man subject
on-line manual on subject
ls
list of a directory (−1 long listing; –a all; –r reverse listing.
cd
change directory
mv
move file
cp
copy file
mkdir
make directory
pwd
present working directory
cat
concatenate a file/s
> file
redirect output to file
< file
redirect input from file

36
UNIX Commands
36.1 Process control
UNIX is a multitasking, multiuser operating system, where many tasks can be
running at a certain time. Typically there are several processes which are started
when the computer is rebooted; these are named daemon processes and they run
even when there is no user logged into the system.
36.1.1 Ps (Process Status)
The ps command prints information about the current process status. The basic
ps list gives a list of the current jobs of the user. An example is given in Sample
session 36.1.
The information provided gives the process identification number (PID), the
terminal at which the process was started (TTY), the amount of CPU time used
and the command line that was entered (CMD). A process can be stopped using
the kill command.
A long listing is achieved using the –1 option and for a complete listing of all
processes on the system the –a option is used, as shown in Sample session 36.2.

The column headed S gives the state of the process. An S identifies that the
process is sleeping (the system is doing something else), W specifies that the
system is waiting for another process to stop and R specifies that the process is
currently running. In summary:
• R process is running.
• T process has stooped.
• D process in disk wait.
• S process is sleeping (that is, less than 20 secs.).
• I process is idle (that is, longer than 20 secs.).
UID is the user identity number. PRI is the priority of the process. A high
number means a low priority.
36.1.2 Kill (Send A Signal To A Process, Or
Terminate A Process)
The kill command sends a signal to a process. The general format is:
The processid is the number given to the process by the computer. This can be
found by using the ps command. The sig value defines the amount of strength
that is given to the kill process and the strongest value is a –9. The owner of a
process can kill his own, but only the superuser can kill any process. Sample
session 36.3 gives an example session.

36.1.3 At (Execute Commands At Later Date)
The at command when used in conjunction with another command will execute
that command at some later time. The standard format is:
where time is given using from 1 to 4 digits, followed by either ‘a’, ‘p’, ‘n’ or
‘m’ for am, pm, noon or midnight, respectively. If no letters are given then a 24-
hour clock is assumed. A 1-or 2-digit time is assumed to be given in hours,
whereas a 3-or 4-digit time is assumed to be hours and minutes. A colon may
also be included to separate the hours from the minutes.
The Date can be specified by the month followed by the day-of-the-month
number, such as Mar 31. A Week can be given instead of the day and month.
For example, to compile a program at quarter past eight at night:
and to send fred a message at 14:00:

To remove all files with the .o extensions from the current directory on
September 9th at 1 noon.
To list all jobs that are waiting to executed at some later time use the –1
option.
To remove jobs from the schedule the –r option can be used and giving the
job number.
36.1.4 Nice (Run A Command At A Low Priority)
The nice command runs a command at a low priority. The standard format is as
follows:

The lowest priority is –20 and the default is –10. Sample session 36.9 gives a
sample session.
36.2 Compilers
The two main compilers on UNIX systems are C (cc) and FORTRAN (f77).
36.2.1 Cc (C Compiler)
The cc command is the C language compiler and is used to convert a C program
into binary code. It can also link several binary modules together to make an
executable file.
Files with the extension .c are taken as C programs and when a C program is
compiled the resulting binary module (the object code) is placed in the current
directory. If a –c option is not used the binary code will be called a.out. If the –c
option is used the binary code will take the name given, the modules produced
will have a .o extension. Options are:
–c. produce single binary module (object code) with the extension .o.
–o. outfit this option is used to give the name for the output file.
–g. produce debug information for use with a debugger (such as dbx).
In Sample session 36.11, the first example of the C program progl.c is
compiled; the resulting file produced is called a.out. This file can be executed
as required. The second type of compilation (cc –c *.c) compiles all the C
programs and produces an object module with a .o extension. These object
modules can be linked together using the compiler. The last example (cc –oprog
prog1.o prog2.o) links together the object modules for prog1.c and prog2.c.
The executable program, in this case, will be called prog.

36.2.2 F77 (FORTRAN Compiler)
The FORTRAN compiler f 77 is used to compile and/or link FORTRAN
programs. The source file is assumed to have the .f extension. If the –c option is
chosen the compiled module will have the .o extension; this is an object module.
Sample session 36.11 gives some examples.
36.2.3 Dbx (Debugger For C, FORTRAN And
Pascal)
The dbx utility is a source-level debugger for C, FORTRAN and Pascal. It
allows the user to trace a program’s execution and list variables. The general
format is:
Some commands for dbx are:
run
runs the current program.
step
step through the program execution one line at a time.
cont
continue program execution where it stopped.
print
print contents of a variable such as print input_value.
list
list next ten lines of code if no arguments are given; to list from linestart to lineend use list linestart,
li
d

lineend.
help
get help information.
trace
trace program execution.
quit
exit dbx.
36.2.4 Lint (C Program Verifier)
The lint utility is used to verify C programs. It attempts to detect bugs, non-
portable warnings and any wasteful use of C code. The basic C compiler, cc,
does little run time checking or inefficiency checking. To run the lint program:
Sample session 36.12 gives a sample session.
36.3 File manipulation commands
UNIX has a number of file manipulation commands, some of which were
defined in the previous chapter and many others are given in this section.
36.3.1 Cp (Copy Files)
The cp command will copy a given file or directory to a given file or directory.
There are several options that can be used:
–i uses interactive mode, the user is prompted whenever a file is to be
overwritten. The user answers ‘y’ or ‘n’.
–r uses recursive mode, the cp command all files including each subdirectory it
encounters.
The following example will copy a file called file1 into a file called file2.
Note that if file2 were a directory then file2 would be copied into that
directory.

If you want to copy a whole directory and all subdirectories the –r option is
used. In the next example the whole directory structure of usrstaff/bill is
copied into the directory usrstaff/fred:
To copy a file into a directory:
36.3.2 Is (List Directory)
The ls command lists the contents of a directory. A summary of the various
options are given below:
–a
lists all entries including files that begin with a. (dot)
–l
lists files in the long format. Information given includes size, ownership, group and time
last modified.
–r
lists in reverse alphabetic order.
–t
lists by time last modified (latest first) instead of name.
–l
lists one entry per line.
–F
marks directories with a trailing slash (/), executables with a trailing star (*).
–R
recursively lists subdirectories encountered.
Sample session 36.16 gives some examples.
36.3.3 File (Determine File Type)
The file command is used to test a file for its type such as a C program, text
file, binary file, and so on. Sample session 36.17 gives a typical session. Typical

file types include:
• mc68020 demand paged executable.
• C program text.
• ASCII text.
• Empty.
• Archive random library.
• Symbolic link.
• Executable shell script.
36.3.4 Du (Disk Usage)
The du command lists the size of a directory and its subdirectories. If no
directory name is given the current directory is assumed. Two options are given
next:

36.3.5 Cat (Concatenate And Display)
The cat command concatenates and displays the given files to the standard
output, which is normally the screen (although this output can be changed using
the redirection symbol). For example, to list a file to the screen:

To concatenate two files together (file1.txt and file2.txt) and put them into
a file called file3.txt:
If no filename is given then the input is taken from the standard input,
normally the keyboard. If a redirect symbol is used then this input will be sent to
the given file. The end of the input is given by a ⁁D (a control-D). For example:
36.3.6 Compress, Uncompress (Compress And
Expand Files)
The compress command uses the adaptive Lempel-Ziv coding to reduce the size
of a file. A.Z is added onto the filename so that it can be identified. Sample
session 36.21 shows an example.

The contents of the compressed files are in a coded form so that they cannot
be viewed by a text editor. The uncompress command can be used to
uncompress a compress file. Only files with the extension .Z can be
uncompressed.
36.3.7 Chmod (Change Mode)
Files in UNIX have various attributes; these attributes can be set or reset with the
chmod command. The attributes are:
Owner
Group
Public
r w x
r w x
r w x
The owner is the person who created the file and the group is a collection of
several users, such as research, development, production, admin groups, and so
on. The public is for everyone else on the system.
The r attribute stands for read privilege and if it is set then the file can be read
(that is, listed or copied) by that type of user. The w attribute stands for write
privilege and if it is set then the file can be written to (that is, listed, copied or
modified) by that type of user. The x attribute stands for execute privilege and if
it is set then the file can be executed (that is, it can be run) by that type of user.
For example -rw-r–r– is a file that the owner can read or write but the group
and the public can only read this file. Another example is -r-x–x–x; with these

attributes the owner can only read the file. No-one else can read the file. No-one
can change the contents of the file. Everyone can execute the file. The ls -al
listing gives the file attributes.
There are several ways to change the attributes. The general format is given
below:
The permission can be set by using the octal system. If an attribute exists a 1
is set, if not it is set to a 0. For example, rw-r–r– translates to 110 100 100,
which is 644 in octal. For example:
To make the file file.txt into rw-rw-r– :
To make the file Run_prog into –x–x—:

The other method used is symbolic notation, these are listed next:
u
user permission
o
others (public) permission
=
assign a permission
–
take away permission
w
write attribute
g
group permission
a
all of user, group and other permissions + add a permission
r
read attribute
x
execute attribute
For example, to change the file Run_list so that it can be executed by all use:
To take away read privilege for all files with the .c extension for the group
use:
36.3.8 Df (Disk Space)
The df command allows you to list the usage of the disk and all other mounted
disk drives. Sample session 36.28 gives some examples.

36.3.9 Diff (Differences Between Files)
The diff command shows the difference between two files or two directories.
There are various options used and these are summarized next:
–i ignores the case of letters (such as ‘b’ is same as ‘B’).
–w ignore all blanks (such as fred = 16.2 is same as fred=16.2).
Some examples are next. In the output listing the < character refers to the first
file given and the > character refers to the second file given. A c refers to a
change, a d to a line deleted and an a refers to text that has been appended. The
line numbers of the first file always appear first.
36.3.10 Mv (Move Files)
The mv command moves files or directories around the file system. The standard
formats are:

There are three different permutations. These are:
• Moving a file into another file (like renaming).
• Moving a directory into another directory (like renaming).
• Moving a file into another directory.
The options that can be used are:
–i
files are moved interactively. When a file is to be moved the system will prompt the user as to whether
he wants to move the file. If the answer is ’y’ the file will be moved, else it will not be moved.
–f
force mode; override any restrictions.
Sample session 36.30 shows examples.
36.3.11 More (Page A File)
The more command allows the user to print one page of text at a time to the
standard output. It pauses at the end of the page with the prompt ‘–More–’ at the
bottom of the page. Sample session 36.31 shows some examples.

36.3.12 Rm (Remove Files Or Directories)
The rm command removes files or directories. To remove a directory which is
empty the rmdir command can be used. There are various options, such as:
–f
force mode; remove files without asking questions
–r
recursive mode; delete content of a directory, its subdirectories and
 
the directory itself;
–i
interactive mode; asks question as to whether each file is to be deleted.
 
 
Sample session 36.32 gives some examples.
36.3.13 In (Make Links)
The In command makes a soft link to a file or directory. When the linkname is
used the system will go to the place indicated by the link. The general format is:

Sample session 36.33 shows some example.
36.3.14 Find (Find File)
The find command searches recursively through a directory structure to find
files that match certain criteria. It uses a pathname from where to start seaching;
this is the first argument given after find. The name of the file is specified after
the –name argument and if the userwants the files found printed to the standard
output the –print is specified at the end. Sample session 36.34 gives an example
of finding a file called fred. f, starting from the current directory.
Sample session 36.35 shows a search of the file passwd, starting from the top-
level directory.
The wild-card character can be used in the name but this must be inserted in

inverted commas (” “). Sample session 36.36 gives an example of search for all
C files starting with the/usr/staff/bill directory.
Other extensions can be used such as –a time which defines the time of last
access. The argument following –atime is the number of days since it has been
accessed. Sample session 36.37 gives an example of searching for all .o files that
have not been used within 10 days.
36.3.15 Grep (Search A File For A Pattern)
The grep command will search through given files looking for a given string
pattern. There are various options which can be used, a summary of these is
given below:
–v print lines that do not match; –x display only lines that match exactly;
–c display count of matching lines; –i ignore case.
Sample session 36.38 gives some examples and the standard format is:
36.3.16 Head (Displays First Few Lines Of A File)
The head command prints the top n lines of a file. The default number is 10 lines
and Sample 2.39 gives examples. The format is as follows:

36.3.17 Tail (Display Last Part Of File)
The tail command displays the last part of a file, where the first argument
defines the number of lines to be displayed. For example, to display the last 4
lines of the file file1.txt:

36.3.18 Wc (Word Count)
The wc utility counts the words, characters and lines in a file. If several files are
given then the sum total of the files will be given. There are three options that
can be used; these are c, w and 1, which stand for characters, words and lines.
If no filename is given then the keyboard is taken as the input and a control-D
ends the file input. Examples are:
36.4 Other commands
36.4.1 Ar (Archive And Library Maintainer)
The Ar Command Is Used To Create And
Maintain Libraries And Archives. A Library Is
A File Which Contains Compiled Programs.
These Files Are Called Object Modules And
Are Self-Contained Modules. The Object
Modules Have The Extension .O. The
Libraries Are Used In The Linking Process.

There Are Certain Standard Libraries On The
System; These Include The Standard Maths
Library And Standard Input/Output Library
(Normally Found In /Usr/Lib).
There are various options used with ar; these are given in Table 36.1. For
example, to create an archive
Table 36.1
ar options
Option
Description
d
delete the named files from the archive
r
replace the named files from archive
t
list the contents of an archive
x
extract a file from an archive
c
create an archive
v
extended listing of file
Then to list the archive:
and to extract a file from the archive:
Then adding all files with .c extension:

and listing the archive again:
To extract a file:
and to create a library with .o object modules:
Archives are useful for keeping many files together in the one file. This makes
them useful for printing, storing on tape, and so on. These are standard libraries
on the UNIX system, such as:
36.4.2 Banner (Make Posters)
The banner command prints the words given on the screen in large letters. A
sample session is shown in Sample session 36.42. The maximum letters on one
line is ten. Its standard form is:

36.4.3 Cal (Calendar)
The cal command displays a calendar for a given year and/or month. The year
may vary from 1 to 9999 and if no month or year is given the current month will
be printed. Sample session 36.43 shows an example of displaying the current
month and Sample session 36.44 displays a whole year.
36.4.4 Chpass (Change Password)
The chpass command is used to change the current login password. Sample
session 36.45 shows an example.

36.4.5 Date (Display Or Set Date)
The date command either gives the current date and time or can be used to set
the current date and time (although only the superuser can do this). If no
arguments are given then the current date and time is printed. If a valid argument
is given then the current time is changed. The general format is given below:
where yy is the year, mm is the month, dd is the day of month, hh is the hour
(24 hour clock), mm is the minute and ss is the seconds (optional).
It is possible to leave out various field such as the year and the seconds.
Sample session 36.46 gives some examples.
36.4.6 Echo (Echo Arguments)
The echo command writes its argument to the standard output. A C-like standard
is used for printing. Sample session 36.47 shows a few examples and the
characters used are given below:

36.4.7 Finger (Display Information On Users)
The finger command gives information on a given user. This information
includes:
• Login name.
• Full name.
• Terminal name.
• Idle time.
• Login time.
• Office location.
• Phone number, if known.
The files used are:
36.4.8 Ftp (File Transfer Program)
The ftp utility is the standard File Transfer Protocol. It is used to transfer files to
and from a remote network. The format is:

36.4.9 Ipr (Print File)
The lpr command spools a file to the printer.
36.4.10 Mail (Interactive Mail)
The mail utility is used to send and receive messages from/to other users. To
send mail the user’s name is simply specified after the program name. For
example, to send mail to a user fred:
Whenever the control-D (⁁D) keystroke is used then the message is sent to a
specified recipient. Other users can be sent the same mail by simply giving their
user name as one of the arguments, such as:
To send a file which has mail the redirect symbol (<) is used, such as:
When reading mail the system will typically tell the user when there is mail
waiting to be read, such as:

Then to read the mail the mail program is run, such as:
Then to read the mail the mail program is run, such as:
The mail response with a question mark (?) is used to indicate that the mail
program is waiting on the user to enter a command. Possible options are:
?
display help information
q
quit
x
exit without changing mail
p
print
s file
save to file
d
delete mail
+
next (no delete)
m user
mail user
36.4.11 Passwd (Change Login Password)
The passwd command is used to change the current password. Each user’s
password is stored in a coded form in etcpasswd. Each new password’s must be
at least 5 characters long if they include upper and lowercase, or 6 if they are
monocase. Sample session 36.53 shows an example.
36.4.12 Pwd (Present Working Directory)

The pwd command prints the pathname of the current working directory.
Examples are:
36.4.13 Rlogin (Remote Login)
The rlogin command allows the user to log into a remote machine. The format
is:
36.4.14 Sleep (Suspend Execution For An
Interval)
The sleep command is used to suspend to command for a given time. The
standard format is:
where the time is in seconds. Sample session 36.55 shows an example.

36.4.15 Spell (Find Spelling Errors)
The spell utility finds spelling errors. The UNIX dictionary resides in the file
/usr/diet/words. The format is given below.
There are various options used:
-b
British spelling (such as colour instead of color).
-v
verbose, full listing.
-X
lists every plausible stem for doubtful words.
Sample session 36.56 shows an example.
36.4.16 Stty (Set Terminal Options)
The stty command sets up the terminal characteristics. There are two main types
of options; these are toggles and settings. The standard format is given below.
Various settings are:
even
allow even parity
odd
allow odd parity
echo
echo every character to screen
icase
convert capital letters to lowercase
tabs
preserve tabs
ek
set erase and shell characters to # and @
erase c
set erase character to c (usually B/S)

kill c
,. set kill character to c (usually @)
300, 1200, and so on
set baud rate
Sample session 36.57 gives examples.
36.4.17 Tar (Tape Archiver)
The tar utility allows files to be saved, recovered or listed from a tape drive. Its
standard form is:
Options used are:
c
to create tape archive
t
to list tape archive
r
to recover tape archive
V
complete listing of file names
Sample session 36.58 shows examples.

36.4.18 Who (Users Logged In)
The who command lists all users on the system and which terminal they are
using. This information is found in the etcutmp file. If the arguments given are
am i (that is, who am i) then the system prints details about the user. For
example:
The information given is the user name, terminal logged in on and date that
the user logged in.
36.4.19 Write (Sends Messages To Users)
The write utility sends a message to a specified user. A control-D ends the
message input and sends it. Examples are:
36.5 Exercises
36.5.1. Login in the UNIX system and determine the current processes that the
user is currently running.
36.5.2. Determine all the current processes that are running and the user which
initiated the process. Identify the status of the processes.
36.5.3. Use the cat > newfile command and then the Ctrl-Z keystroke to
suspend the process. Show that the process has been suspended.

36.5.4. Kill the process which has just been suspended.
36.5.5. Using the at command, run an Is –1 at a time one minute from the
current time.
36.5.6. From the current directory, determine the file types of the files.
36.5.7. From the current directory, determine the size of all the directories.
36.5.8. Determine the present working directory.
36.5.9. Determine the present date.
36.5.10. List the current directory so that directories have a trailing slash.
36.5.11. Recursively list the current directory, showing all subdirectories.
36.5.12. Determine the users who are currently logged into the computer.
36.5.13. If there is a user logged into the computer then send an electronic
message to them.
36.5.14. Using stty, determine the terminal characteristics.
36.5.15. For the top-level directory, find all the C program files.

37
Editing and Text Processing
37.1 Introduction
UNIX has several command programs which can be used to edit and process
text. These are defined in Table 37.1.
Table 37.1
Editing and text processing programs
Text editors
Text processing
Text manipulation
vi, the visual editor
nroff, format document
grep, looks for a pattern
ex,line editor
troff, print formated document
sort, sorts lines of text
ed, line editor
tb1, formatting tables
spell, finds spelling errors
sed, stream text editor
pic, graphics language for
typesetting
tr, translates characters
awk, pattern scanning and
processing
eqn, typesetting mathematics
wc, counts characters, words and lines in
a file.
37.2 Visual editor
Most UNIX systems have their own text editor which is selected from the
Graphical User Interface. The vi editor (pronounced vee-eye) is a text-based
editor and is standard on all UNIX systems. It is not the easiest editor to use but
it is available on all UNIX-based system. The editor is called with:

37.2.1 Making Changes
The vi editor involves using special characters to identify editing commands.
The user enters text only when the editor is in insert mode. All characters
entered this mode are added to the file. When not in insert mode the characters
are interpreted as editor commands. For example, an ‘x’ keystroke tells the
editor to delete a single character and a ‘d’ followed by a ‘w’ deletes a word.
Insert mode
To insert text the user must be in the insert mode. A summary of the main
insertion and delete options is given below. To insert text, place the cursor on the
character you want to insert before then press ‘i’; this will put you into insert
mode. The text can then be entered with as many lines as required. To exit from
insert mode, the ESC key is pressed, as illustrated in Figure 37.1. This then puts
the editor back into normal mode. Other methods of insertion are similar, such as
an ‘a’ puts inserted text after the current cursor position. While ‘o’ starts a new
line above the line the user is currently on and ‘o’ puts it after the current line.
The insert mode characters are listed in Table 37.2.
Table 37.2
Editing and text processing programs
Option
Description
i
Enter insert text mode before cursor. The ESC key is used to exit from insert mode.
Enter insert mode and create a new text line above line you are on.
O
Enter insert mode below current line.
a
Enter insert mode after cursor (that is, append).
dd
Delete whole line.
X
Delete one character.
dw
Delete word.
db
Delete word before.
ns
Substitutes n characters and enters into insert mode.

FIGURE 37.1  Edit and insert mode
37.2.2 Deleting Text
Deleting text is performed in the edit mode. The various methods are:
• Delete lines. A single line is deleted with two ‘d’ characters, that is ‘d’ ‘d’.
To delete several lines the number of lines to be deleted is entered first
followed by two ‘d’ characters, such as 6 ‘d’ ‘d’ deletes 6 lines
• Delete words. A single word (a sequence of characters delimited by spaces)
is deleted with a ‘d’ followed by ‘w’. As with delete lines, several words
are deleted by entering the number of words to delete followed by the ‘d’
and ‘w’ characters.
• Delete characters. A single character is deleted with the ‘x’ character. Again,
if this character is preceded by a number then a number of characters are
deleted. For example, 5 followed by ‘x’ deletes 5 characters.
37.2.3 Substituting
The ‘s’ character identifies a substitution of characters. First the number of
characters to be substituted is entered and the editor marks the end of the text to
be substituted with a $. The editor is then put into insert mode and the new text
is entered followed by the ESC key. For example, to change fred to tom the
cursor is moved to the f of fred and then the user types 4stom <ESC>.

37.2.4 Cut And Paste (Yank And Put)
The ‘y’ ‘y’ keystroke is used to copy a line of text (yank) and the ‘p’ keystroke
(put) is then used to put this text to a defined part of a file. This is equivalent to
copy then paste operation. If the yank option is preceded by a number then that
number of lines are yanked. For example 7 ‘y’ ‘y’ stores 7 lines of text. Note that
the ‘p’ character puts lines after the present line and ‘P’ after the present line.
37.2.5 Undoing
The vi editor allows the last change to be undone. The keystroke for the last
operation to be undone is ‘u’ and to restore a whole line the ‘U’ keystroke is
used.
37.2.6 Moving Around
There are various methods of moving around these are outlined in Table 37.3;
and are defined as:
Table 37.3
Editing and text processing programs
Option
Description
l or →
move cursor forward one cursor position
h or ←
move cursor back one position
^b
backwards one page
^f
forward one page
^d
scroll down file
^u
scroll up file
k or ↓
next line
j or ↑
previous line
G n
go to line number n
W
forward one word
b
back one word
e
end of current word
w
word after this word

• Moving cursor. The cursor can be used with the arrow key (←,→, and so on)
if they are supported by the terminal being used. If the keyboard has no
arrow keys (or they are not supported) then the characters used are ‘h’
(left), ‘j’ (down), ‘k’ (up) and ‘1’ (right) keys
• Moving by page. The page can be moved back and forward using the PgUp
and PgDn keys, if they are supported. Else, to move backwards by one
page the ⁁b (press Cntrl and b at the same time) and to move one page
forward then ⁁f. A ⁁u and ⁁d allows the screen to be scrolled up or down,
respectively.
• Going to a line. In many situations the user requires to go to a specific line
number (especially when compiling a program). To do this the ‘G’
character is followed by the line number. For example, ‘G’ 1234 goes to
line number 1234.
37.2.7 Searching For Strings
The ‘’ and ‘?’ characters are used to find a string. A ‘’ searches forwards for the
next occurrence of a string, whereas, ‘?’ searches back for the occurrence of the
string. Thus:
37.2.8 Getting Out Of The Editor And Saving
There are various options that can be used (depending on what you require).
These are specified in Table 37.4. The user’s changes are not stored to the file
until the user uses either ‘Z’ ‘Z’, ‘:’ ‘w’ ‘q’ or’:’ ‘w’. These differ in that the ‘:’
‘w’ ‘q’ and ‘Z’ ‘Z’ sequence causes the changes to be saved to the file and quit
from the editor, whereas ‘:’ ‘w’ saves changes and the editor stays active.
Table 37.4
Methods of exiting
Option
Description

ZZ
Exits from editor and saves all changes.
:wq <CR>
Same as above (write and quit).
: w <CR>
Write changes but do not quit.
: w filename <CR>
Write changes to filename, no quit.
:qexcl <CR>
Quit from editor, no changes.
:eexcl <CR>
Re-edit, discarding changes.
A user can abandon the changes that have been made since the last save by
using either ‘:’ ‘q’ ‘!’ or ‘:’ ‘e’ ‘!’.
Note that <CR> stands for pressing the return key.
37.2.9 Reading-In And Writing-To Files
The command to read-in files is : r filename and the command to write the file to
a specified file is :w filename. For example, :r fred reads in a file called fred
and :w fred2 . txtwrites to a file called fred2 . txt.
37.2.10 Useful Advanced Editing Facilities
There are many powerful text editing facilities available, some useful examples
are:
this changes all occurrences of name1 to name2 for 10 lines:
writes lines 5 to 18 to file called fred.txt.
37.3 Example of text editing
This section contains a practical example of text editing. Start the editor with:

then when the editor has started enter ‘i’ to put the editor into insert mode.
Enter the text given below and make the changes required. If mistakes are made
as the text is being typed-in then the back-space key will delete the previous
character, else wait until all the text has been entered and then make the required
modifications. The text is:
Once the text has been entered then make the following changes/operations:
(a) Change loin in the title to lion. This can be done in a number of ways, such
as:
• Move cursor to the L of LOIN press 4× (or xxxx) and then press i to
enter insert mode and enter correct word LION. Press ESC button
to exit from insert mode.
• Move cursor to the L of LOIN press 4s (substitute 4 letters) the $ sign
shows the end of the word to be substituted. You will be in insert
mode automatically. Enter new text LION and press ESC to return
to normal mode;
• Move cursor to the L of LION press R (overwrite mode and replace)
this will automatically put you into insert mode. Next enter
correct LION and press ESC.
• For advanced editing go to start of text then type : :s/LOIN/LION/g
100 <CR>. This substitutes globally LOIN for LION for 100 lines.
(b) Copy the first 4 lines of the second paragraph and put these after the

third paragraph. To do this first yank (to get lines) and the put. First,
position the cursor at any position on the line which begins the second
paragraph. Next, get the lines by using 4yy (which gets 4 lines or use 4Y)
then move the cursor to the last line and press ρ to put the lines below last
line.
(c) Delete these new lines. This can be done by moving the cursor to the first
line of the new lines and then using 4dd (or dddd) to delete these 4 new
lines.
(d) Search for the word sheeps and change this to heaps. To find the word
sheeps use /sheeps <CR>, the editor will then find the first occurrence
after the current cursor position. If the word lies backwards from the
cursor then use ? sheeps <CR>. Once found replace it with heaps.
(e) Search for the word stumbled. How many occurrences are there?
(f) Write modified text to the file lion2.txt. This is done by using :w
lion2.txt <CR>.
(g) Read this file in at the end of the file. Move the cursor to the end of file
then use : r lion2.txt. This will read the file in.
(h) Delete these new lines. Position the cursor on the first new line then use dd
to delete a line. Repeat this deletion with the repeat option until all the
required lines are deleted.
(i) Find the word confusion and change it to unconfusion, then undo this
press u (the undo option).
(j) Save the text. Use: wq <CR>.
37.4 sed editor
The sed is a non-iterative stream editor. It is useful for editing large files and
performing global edits. The following text can be entered and operated on in the
examples given; call the file Walrus.

37.4.1 Global Changing
To globally change string1 to string2 the following is used:
For example, if we use the example given previously to change his to her, the
following can be used:
We can see that on the fifth line this has been replace by ther. To undo this
the following could be used:
37.5 grep
The grep command searches through given files for a given string pattern. Its
standard format is:
where the options which can be used are:
i t li
th t d
t
t h

–v
print lines that do not match
–X
display only lines that match exactly
–c
display count of matching lines
–i
ignore case
Examples are:
The grep is typically used with a pipe to search the output from a command.
For example, to find every occurrence of the word set in the manual on the C
shell:
which is equivalent to:
37.6 sort
The sort utility sorts lines in the given files and writes the output to the standard
output. It always uses the characters to sort the text and ignores the values of
numerical values. The standard format is:
As an example, create the following file and call it league. Its function is to

list a number of individuals, the number of games they have played and the
number of points scored. Each field is separated by spaces or tabs.
To sort the first field, that is the first name, then the sort is used with no
options.
Next, the surnames can be sorted by adding the +1 option, which causes the
sort to skip to the first field.
This is an incorrect sort as Simon Ripon comes before Bert Ripon. The reason
that it has not sorted these names properly is that it has tested only the surname.
To test the first field after the second the –2 option is added. Thus the sort +1 –
2 league command is interpreted as ‘skip the first field and then sort but stop
sorting after the second field and go back to the start of the line’.

To sort the third field (that is, the games played) then the +2n option is used.
Thus sort +2n +1 League is interpreted as ‘skip two fields then sort
numerically, then they are sorted by skipping the first field’.
To sort in reverse the r option is used.
To sort with the fourth field (that is, points):

37.7 Exercises
37.7.1. Write a command using 1s, | and the grep that will determine all files, in
the current working directory, which contain the letter r.
37.7.2. Using who, | and grep, determine all the users on teletype terminals (that
is, ttyxx).
37.7.3. Using the ls -al and grep, show any file which has the attributes rwx-r–
r–.
37.7.4. Determine any usage of the string “>>” in the manual on csh and sh.
37.7.5. The following are lists of teams and their games played, goals for, goals
against and points. Using the sort utility, determine:
(i) The list alphabetically of teams.
(ii) The teams sorted by decending goals for.
(iii) The teams sorted by ascending goals against.
(iv) The teams sorted by points then by goals for.
37.7.6. Using sort and ls –al, list the files in the current directory in order of
decreasing size.

38
Csh (C Shell)
38.1 Introduction
The C shell (csh) is one of the interfaces between the user and the UNIX
operating system; others include:
• Bourne shell (sh).
• Korne shell (ksh).
The C shell includes a command interpreter and a high-level programming
language. It has several advantages over the Bourne shell, these include:
• Variables are more versatile.
• It supports arrays of numbers and strings.
• Improved protection over accidental logout.
• Improved protection over accidental file overwrite.
• Alias mechanism.
• History mechanism to recall past events.
38.2 Entering the C Shell
The Bourne shell and the C shell can be used at any time but only one can be
used at a time. To call-up the C shell:
and the Bourne shell is called-up using sh. Normally, the shell at which a user
is put into initially is setup in the etcpasswd file. This file can only be change by
the system administrator. To list the passwd file:

this gives a paged list and the shells are given defined by either binsh or
bincsh. An excerpt from a passwd file is given next:
In this case, the passwd file has 3 users defined, these are root, fred and
fred2. The encrypted password is given in the second field (between the first
and second colon). The third field is a unique number that defines the user (in
this case fred is 2 and fred2 is 3). The fourth field, in this case defines the
group number. The fifth field is simply a comment field and, in this case,
contains the user’s names. In the next field the user’s home directory is defined
and the final field contains the initial UNIX shell (in this case it is the C shell).
When entering the C shell the .cshrc file is executed. This file sets up the C
shell to the needs of the user and is found in the user’s home directory. It can be
found by typing 1s –a1 in the user’s home directory. It can be listed as follows:
The .cshrc file will be discussed later.
38.3 Leaving the C shell
An annoying feature of the Bourne shell is that if the user presses the
CONTROL-D keystroke by mistake then they will be logged-out. In the C shell
if the ignoreeof variable is set then the CONTROL-D (^D) log out process is
inactive. A user can exit from the C shell by typing exit. To set the ignoreeof
variable just type:
This is usually done automatically when entering the shell. An example of
entering and leaving the C shell is given below.

Note: If the ignoreeof variable is not set then ^D will exit the C shell.
38.4 History
The history mechanism maintains a list of previous command lines, which are
also called events. To set the number of events the set history command is
used. For example, to set the number of stored events to 10:
and to recall the previous events the history command is typed:
38.5 Reexecuting events
It is possible to reexecute any event in the history list. The reference to an event
is made by starting the line with a!.
38.5.1 Event Numbers
An event can be reexecuted using the event number. This is achieved by a !
followed by the event number.

A negative number after the exclamation mark refers to an event prior to the
current event.
38.5.2 Reexecuting Previous Event
Two exclamation marks (! !) are used to reexecute the previous event. For
example:
38.5.3 Events Using Text
To execute a previous event with text then an exclamation mark followed by text
at the beginning of the event can be used. For example:

38.5.4 Changing Last Event
Typically a user makes a mistake in a command line and wants to replace a part
of the command line with another. To change a string of text in the last event
then the caret (^) symbol is used. For example ^fred^temp reexecutes the last
event but changes fred for temp. For example:
38.5.5 Changing Previous Events
To modify a previous event it is possible to use the :s/old/new to change a
given event. The event is specified by the methods given previously. For
example:
The first example changes event 13 but substitutes temp for fred. The second
example executes the last event beginning with cat and substitutes yyy for xxx.
38.6 Alias

The alias mechanism allows a user to substitute a given command for a single
word (or alias). The following are common aliases:
The first example executes the history command whenever h is entered at the
command line. The second executes an 1s –a1 when dir is entered.
The user can list the currently defined aliases by simply typing alias, such as:
The unalias command is used to remove an alias, such as:
38.7 Variables
The C shell only uses strings and does not use numbers. Thus, for example, 5 is
interpreted as the character 5 and not as the number 5. To operate on numbers
the @ is used.

38.7.1 Variable Substitution
The commands that are used to manipulate variables are:
• setenv which operates on global variables (that is, system variables).
• set and @ which operate on local variables to the current shell.
A variable is recognized by a preceding $ followed by the variable name.
Examples are $fruit, $numbers, and so on.
38.7.2 String Variables
The C shell treats variables as strings. To declare a variable the set command is
used. For example:
This will declare the variable myname which contains the string “Bill”. Note
that a space on either side of the = is necessary.
38.7.3 Arrays Of Strings
Before an array member is used it must be declared, that is, set. It is used to
declare every member of the array.

38.7.4 Numerical Variables
The @ command is used to assign a numeric variable. The format of the @
command is: @ variable-name operator expression
The operator can be any of the C operators. These are:
Shift operators:
Relationship:
Bitwise:
Logical:

An example is given next:
38.7.5 Files
Files can be tested for their status using the –n option, the standard form is:
where n can be:
d. file is a directory
e. file exists
f. file is a plain file
o. user owns the file
r. user has read access to file
w. user has write access to file
x. user has execute access to file
z. file is empty
For example
38.8 Special forms ($#, $? and ~)
The number of elements in an array is determined using the $# operator. The
general format is:

To determine if a variable has been declared the $? can be used. The general
format is:
The value returned will be zero if it has not been declared and 1 if it has been
declared.
The ~ (tilde) operator is used to substitute for the full pathname of a given
user. For example:
Thus –fred stands for user fred’s home directory, and so on.
38.9 Shell variables
These variables can be set by either the shell or the user. There are two basic
types: the first is given values, whereas the second is either set or unset.
38.9.1 System Variables That Take A Value
The standard variables that take on values are:
• $argv – The argv variable contains all the command line arguments. argv
[0] holds the name of the calling program, argv [1] contains the first
argument, and so on. For example, if the command line is:

    Then the argv variables will be:
• $#argv –contains the number of command line arguments. In the previous
example this will be 4.
• $cdpath – The variable is used by the cd command. When a cd command
with a simple filename is given, then the system will search the current
working directory. If the file is not in the current working directory then
the system will search in the directories given by the cdpath variable. If a
file is found in any of the search paths then the system changes to that
directory. It is usually set in the .login file, for example:
• $cwd – full pathname of current directory.
• $history – defines the size of the history list. This value is usually set in the
.cshrc file, such as:
• $home – defines the home directory of the user.
• $mail – files where the shell checks for mail.
• $path – gives the directories in which the system searches for executables.
Usually the search path is ‘. ’, ‘/bin’ and usr/bin’. For example:

• $prompt – A string that is printed before each command is read. If a ‘!’
appears in the string the current event number is substituted. The default
prompt is a %. An example prompt setting is:
    which will print as a prompt:
    if the current directory is usrstaff/bill_b/docs, the current event was 15
and the user’s name is bill_b.
• $savehist – contains the number of history events that are stored when the
user logs out. These events are stored in the ~/.history file. When the
user next logs in then the current history list will be as the saved event
history.
38.9.2 System Variables Are Set
The standard variables that are set are:
• $filec – enables file name completion. If it is set then the filename is
completed when the <ESC> key is pressed and the file is found.
    may become:
    The <Cntl-D> (^D) character is used to list any files which match the current
input. For example:

    In this example the files which match the first three characters FOR are
listed.
• $ignoreeof – if set the shell ignores the <Cntrl-D> logout command and
exit is used to leave the shell. It is set with:
• $noclobber – when set there are restrictions on the redirection to files. If a >
is given and the file exists it will not be destroyed.
38.10 Shell scripts
A shell script is a file that contains C shell commands. To execute a file the
mode must be changed so that it can be executed. For example:
Note that the first nonblank character in a C shell script must be a #. This tells
the shell that it is a C shell script.
38.11 Control Structures
The C shell control statements are if, foreach, while and switch.
38.11.1 If
The general format of the if control structure is given below.

An example of a C shell script using the if control structure is:
If the script’s filename were argtest then a typical run session may be:
38.11.2 If-Then Else
There are three different types of if-then else structures:
Type 1
Type 2
Type 3
if (expression) then commands
if (expression) then commands
if (expression) then commands
endif
else commands
else if (expression) then.
 
endif
.
 
 
endif
An example of a Shell script using if-then is:

If the file is called grade then a typical run session may be:
38.11.3 Foreach
The foreach structure reads each argument of an argument list in turn. The
standard format is as follows:
When the loop is first executed then loopindex will be assigned the first value
in the argument-list. The commands are then executed and the loop returns to the
start and the loopindex then takes on the second value in the argument-list, and
so on.
38.11.4 While
The general format of the while loop is:

The following shell script is an example which determines the factorial of a
number.
38.11.5 Switch
The switch statement can choose between several different strings. The general
format is:
An example of the switch structure which implements a basic calculator is
given next:

38.12 Automatically executed C shell scripts
(.login.cshrc)
When someone logs on to the system, or starts a C shell, three C shell scripts are
run at various times.
38.12.1 The .Login File
The .login file is executed when the user logs onto the system. Usually this file
contains terminal and keyboard commands. An example of a typical .login file is
shown below. In this case, the setenv command is used to set a variable for all
shells, that is csh and sh. The terminal type setup is a vt100.

38.12.2 The .Cshrc File
The .cshrc file is executed whenever a C shell is run. Again it is found in the
home directory of the user. It is typically used to set up parameters used by the C
shell, such as the path, prompt, and so on. A quick way of listing the .cshrc file
wherever you are is:
A typical .cshrc file is:
38.12.3 The .Logout File
The .logout file is automatically executed when the user logs out of the system.
It typically contains commands which tidy up the user’s work area and also to
write messages.
38.13 Exercises
38.13.1. Using an alias, define a command named rename which is equivalent to:

38.13.2. Using the date command, set user prompt to give the date.
38.13.3. Write a C shell script that calculates the sum of numbers up-to and
including the number given.
38.13.4. Write a C shell script named add_dot_C. which will add a .c to any
given file name. For example:
   would cause the file fred to become fred.c.
38.13.5. The command for finding a given file on the system is:
   which searches from the top-level directory for the file called filename. For
example, to find prog1.c the following can be used:
   Write a C shell script which is called findfile in which the argument passed
to it is the filename. For example,
38.13.6. The stream editor sed can be used to replace a given word with another
word. The format of this command is given below:
   This changes wordold for wordnew globally in file called filename. Write a
shell script called replace which gives three arguments. The first two are
for the words and the third for the filename. For example, to replace fred
for terry in the file name_file:

38.13.7. Write a C shell script which will give information about a given file.
The information should include access rights, whether it is of zero length,
file type, and so on. Name the shell script testfile.

A
Java Classes
java/
java/lang/
java/lang/Object.class
java/lang/Exception.class java/lang/Integer.class
java/lang/NumberFormatException.class 
java/lang/Throwable.class
java/lang/Class.class
java/lang/IllegalAccessException.class 
java/lang/StringBuffer.class
java/lang/ClassNotFoundException.class
java/lang/IllegalArgumentException.class java/lang/Number.class
java/lang/InterruptedException.class java/lang/String.class
java/lang/RuntimeException.class 
java/lang/InternalError.class
java/lang/Long.class
java/lang/Character.class 
java/lang/CloneNotSupportedException.class
java/lang/InstantiationException.class 
java/lang/VirtualMachineError.class
java/lang/Double.class
java/lang/Error.class
java/lang/NullPointerException.class 
java/lang/Cloneable.class
java/lang/System.class
java/lang/ClassLoader.class java/lang/Math.class
java/lang/Float.class
java/lang/Runtime.class
java/lang/
StringIndexOutOfBoundsException.class
java/lang/IndexOutOfBoundsException.class java/lang/SecurityException.class
java/lang/LinkageError.class java/lang/Runnable.class java/lang/Process.class
java/lang/SecurityManager.class java/lang/Thread.class
java/lang/UnsatisfiedLinkError.class
java/lang/IncompatibleClassChangeError.class
java/lang/NoSuchMethodError.class java/lang/IllegalThreadStateException.class
java/lang/ThreadGroup.class 
java/lang/ThreadDeath.class
java/lang/ArraylndexOutOfBoundsException.class java/lang/Boolean.class

java/lang/Compiler.class 
java/lang/NoSuchMethodException.class
java/lang/ArithmeticException.class 
java/lang/ArrayStoreException.class
java/lang/ClassCastException.class java/lang/NegativeArraySizeException.class
java/lang/IllegalMonitorStateException.class
java/lang/ClassCircularityError.class 
java/lang/ClassFormatError.class
java/lang/AbstractMethodError.class 
java/lang/IllegalAccessError.class
java/lang/InstantiationError.class 
java/lang/NoSuchFieldError.class
java/lang/NoClassDefFoundError.class 
java/lang/VerifyError.class
java/lang/OutOfMemoryError.class 
java/lang/StackOverflowError.class
java/lang/UnknownError.class java/lang/Win32Process.class java/io/
java/io/FilterOutputStream.class 
java/io/OutputStream.class
java/io/IOException.class java/io/PrintStream.class java/io/FileInputStream.class
java/ioAnterruptedIOException.class java/io/File.class
java/io/InputStream.class 
java/io/BufferedInputStream.class
java/io/FileOutputStream.class 
java/io/FileNotFoundException.class
java/io/BufferedOutputStream.class 
java/io/FileDescriptor.class
java/io/FilenameFilter.class 
java/io/FilterInputStream.class
java/io/PipedInputStream.class 
java/io/PipedOutputStream.class
java/io/EOFException.class 
java/io/UTFDataFormatException.class
java/io/DataInput.class
java/io/DataOutput.class 
java/io/DataInputStream.class
java/io/PushbackInputStream.class 
java/io/ByteArrayInputStream.class
java/io/SequenceInputStream.class 
java/io/StringBufferInputStream.class
java/io/LineNumberInputStream.class 
java/io/DataOutputStream.class
java/io/ByteArrayOutputStream.class 
java/io/RandomAccessFile.class
java/io/StreamTokenizer.class java/util/
java/util/Hashtable.class 
java/util/Enumeration.class
java/util/HashtableEnumerator.class 
java/util/Properties.class
java/util/HashtableEntry.class java/util/Dictionary.class java/util/Date.class
java/util/NoSuchElementException.class 
java/util/StringTokenizer.class
java/util/Random.class
java/util/VectorEnumerator.class java/util/Vector.class
java/util/BitSet.class
java/util/EmptyStackException.class 
java/util/Observable.class
java/util/Observer.class java/util/ObserverList.class java/util/Stack.class
java/awt/
java/awt/Toolkit.class

java/awt/peer/
java/awt/peer/WindowPeer.class 
java/awt/peer/TextFieldPeer.class
java/awt/peer/ContainerPeer.class 
java/awt/peer/PanelPeer.class
java/awt/peer/CanvasPeer.class 
java/awt/peer/FramePeer.class
java/awt/peer/ChoicePeer.class 
java/awt/peer/CheckboxMenuItemPeer.class
java/awt/peer/TextAreaPeer.class 
java/awt/peer/FileDialogPeer.class
java/awt/peer/TextComponentPeer.class 
java/awt/peer/ScrollbarPeer.class
java/awt/peer/ButtonPeer.class 
java/awt/peer/ComponentPeer.class
java/awt/peer/MenuComponentPeer.class 
java/awt/peer/MenuItemPeer.class
java/awt/peer/CheckboxPeer.class 
java/awt/peer/MenuPeer.class
java/awt/peer/ListPeer.class 
java/awt/peer/MenuBarPeer.class
java/awt/peer/LabelPeer.class 
java/awt/peer/DialogPeer.class
java/awt/Image.class
java/awt/MenuItem.class java/awt/MenuComponent.class java/awt/image/
java/awt/image/ImageProducer.class 
java/awt/image/ColorModel.class
java/awt/image/DirectColorModel.class 
java/awt/image/ImageConsumer.class
java/awt/image/ImageObserver.class 
java/awt/image/CropImageFilter.class
java/awt/image/ImageFilter.class 
java/awt/image/FilteredImageSource.class
java/awt/image/IndexColorModel.class
java/awt/image/MemoryImageSource.class 
java/awt/image/PixelGrabber.class
java/awt/image/RGBImageFilter.class 
java/awt/FontMetrics.class
java/awt/Checkbox.class 
java/awt/CheckboxGroup.class
java/awt/MenuContainer.class java/awt/Menu.class
java/awt/Insets.class
java/awt/MenuBar.class
java/awt/List.class
java/awt/Label.class
java/awt/Component.class 
java/awt/TextField.class
java/awt/TextComponent.class java/awt/Dialog.class
java/awt/Font.class
java/awt/Window.class
java/awt/FocusManager.class java/awt/Panel.class
java/awt/Container.class 
java/awt/Graphics.class
java/awt/CheckboxMenuItem.class java/awt/Canvas.class
java/awt/Frame.class
java/awt/Choice.class
java/awt/Event.class

java/awt/TextArea.class java/awt/AWTError.class java/awt/Polygon.class
java/awt/FlowLayout.class java/awt/Point.class
java/awt/FileDialog.class java/awt/Scrollbar.class java/awt/Dimension.class
java/awt/Color.class
java/awt/Button.class
java/awt/LayoutManager.class 
java/awt/Rectangle.class
java/awt/BorderLayout.class 
java/awt/GridLayout.class
java/awt/GridBagConstraints.class 
java/awt/GridBagLayout.class
java/awt/GridBagLayoutInfo.class 
java/awt/CardLayout.class
java/awt/MediaTracker.class 
java/awt/MediaEntry.class
java/awt/ImageMediaEntry.class java/awt/AWTException.class java/net/
java/net/URL.class
java/net/URLStreamHandlerFactory.class 
java/net/InetAddress.class
java/net/UnknownContentHandler.class java/net/UnknownHostException.class
java/net/URLStreamHandler.class 
java/net/URLConnection.class
java/net/MalformedURLException.class 
java/net/ContentHandlerFactory.class
java/net/ContentHandler.class 
java/net/UnknownServiceException.class
java/net/ServerSocket.class 
java/net/PlainSocketImpl.class
java/net/SocketImpl.class 
java/net/ProtocolException.class
java/net/SocketException.class 
java/net/SocketInputStream.class
java/net/Socket.class
java/net/SocketImplFactory.class 
java/net/SocketOutputStream.class
java/net/DatagramPacket.class 
java/net/DatagramSocket.class
java/net/URLEncoder.class java/applet/
java/applet/Applet.class 
java/applet/AppletContext.class
java/applet/AudioClip.class java/applet/AppletStub.class sun/
sun/tools/
sun/tools/debug/
sun/tools/debug/BreakpointQueue.class
sun/tools/debug/DebuggerCallback.class 
sun/tools/debug/RemoteThread.class
sun/tools/debug/StackFrame.class 
sun/tools/debug/RemoteAgent.class
sun/tools/debug/AgentConstants.class 
sun/tools/debug/AgentIn.class
sun/tools/debug/RemoteObject.class sun/tools/debug/RemoteStackVariable.class
sun/tools/debug/Remote 
Value.class 
sun/tools/debug/RemoteClass.class
sun/tools/debug/Agent.class 
sun/tools/debug/RemoteBoolean.class
sun/tools/debug/RemoteChar.class 
sun/tools/debug/RemoteString.class
sun/tools/debug/NoSessionException.class 
sun/tools/debug/Field.class

sun/tools/debug/NoSuchLineNumberException.class
sun/tools/debug/RemoteShort.class 
sun/tools/debug/RemoteThreadGroup.class
sun/tools/debug/RemoteInt.class 
sun/tools/debug/ResponseStream.class
sun/tools/debug/RemoteDouble.class 
sun/tools/debug/LocalVariable.class
sun/tools/debug/BreakpointSet.class 
sun/tools/debug/RemoteStackFrame.class
sun/tools/debug/MainThread.class 
sun/tools/debug/BreakpointHandler.class
sun/tools/debug/AgentOutputStream.class 
sun/tools/debug/RemoteLong.class
sun/tools/debug/RemoteFloat.class 
sun/tools/debug/RemoteArray.class
sun/tools/debug/InvalidPCException.class 
sun/tools/debug/LineNumber.class
sun/tools/debug/RemoteField.class sun/tools/debug/NoSuchFieldException.class
sun/tools/debug/RemoteByte.class 
sun/tools/debug/EmptyApp.class
sun/tools/debug/RemoteDebugger.class sun/tools/java/
sun/tools/java/RuntimeConstants.class 
sun/tools/java/Constants.class
sun/tools/java/Environment.class 
sun/tools/java/ClassPath.class
sun/tools/java/ClassDeclaration.class 
sun/tools/java/FieldDefinition.class
sun/tools/java/Type.class 
sun/tools/java/ClassNotFound.class
sun/tools/java/ClassType.class 
sun/tools/java/ClassDefinition.class
sun/tools/java/Parser.class 
sun/tools/java/ClassPathEntry.class
sun/tools/java/CompilerError.class 
sun/tools/java/Identifier.class
sun/tools/java/Package.class 
sun/tools/java/ClassFile.class
sun/tools/java/Imports.class 
sun/tools/java/ArrayType.class
sun/tools/java/AmbiguousField.class 
sun/tools/java/MethodType.class
sun/tools/java/Scanner.class 
sun/tools/java/SyntaxError.class
sun/tools/java/BinaryClass.class 
sun/tools/java/BinaryField.class
sun/tools/java/AmbiguousClass.class 
sun/tools/java/BinaryConstantPool.class
sun/tools/java/ScannerInputStream.class 
sun/tools/java/BinaryAttribute.class
sun/tools/java/BinaryCode.class 
sun/tools/java/BinaryExceptionHandler.class
sun/tools/javac/
sun/tools/javac/Main.class 
sun/tools/javac/SourceClass.class
sun/tools/javac/CompilerField.class 
sun/tools/javac/SourceField.class
sun/tools/javac/BatchEnvironment.class 
sun/tools/javac/ErrorConsumer.class
sun/tools/javac/ErrorMessage.class 
sun/tools/javac/BatchParser.class
sun/tools/zip/
sun/tools/zip/ZipFile.class 
sun/tools/zip/ZipEntry.class
sun/tools/zip/ZipFileInputStream.class 
sun/tools/zip/ZipConstants.class
sun/tools/zip/ZipFormatException.class
sun/tools/zip/ZipReaderInputStream.class 
sun/tools/zip/ZipReader.class

sun/tools/tree/
sun/tools/tree/ConstantExpression.class 
sun/tools/tree/LocalField.class
sun/tools/tree/Expression.class 
sun/tools/tree/IncDecExpression.class
sun/tools/tree/SuperExpression.class 
sun/tools/tree/NaryExpression.class
sun/tools/tree/StringExpression.class 
sun/tools/tree/UnaryExpression.class
sun/tools/tree/Context.class 
sun/tools/tree/ExpressionStatement.class
sun/tools/tree/ConditionVars.class 
sun/tools/tree/Node.class
sun/tools/tree/CharExpression.class 
sun/tools/tree/CaseStatement.class
sun/tools/tree/LessExpression.class 
sun/tools/tree/IntegerExpression.class
sun/tools/tree/SubtractExpression.class
sun/tools/tree/ArrayAccessExpression.class 
sun/tools/tree/TryStatement.class
sun/tools/tree/BinaryEqualityExpression.class 
sun/tools/tree/Statement.class
sun/tools/tree/AssignSubtractExpression.class
sun/tools/tree/FinallyStatement.class 
sun/tools/tree/ForStatement.class
sun/tools/tree/DivRemExpression.class 
sun/tools/tree/BinaryExpression.class
sun/tools/tree/ShiftRightExpression.class
sun/tools/tree/AssignMultiplyExpression.class
sun/tools/tree/BooleanExpression.class
sun/tools/tree/BinaiyAritnmeticExpression.class
sun/tools/tree/ThrowStatement.class
sun/tools/tree/AssignDivideExpression.class
sun/tools/tree/AssignShiftLeftExpression.class
sun/tools/tree/NewArrayExpression.class 
sun/tools/tree/AndExpression.class
sun/tools/tree/AssignBitOrExpression.class sun/tools/tree/BreakStatement.class
sun/tools/tree/SynchronizedStatement.class
sun/tools/tree/PreDecExpression.class sun/tools/tree/CompoundStatement.class
sun/tools/tree/DoubleExpression.class 
sun/tools/tree/ConvertExpression.class
sun/tools/tree/NullExpression.class sun/tools/tree/LessOrEqualExpression.class
sun/tools/tree/IdentifierExpression.class 
sun/tools/tree/ReturnStatement.class
sun/tools/tree/BitNotExpression.class 
sun/tools/tree/LongExpression.class
sun/tools/tree/VarDeclarationStatement.class
sun/tools/tree/MethodExpression.class 
sun/tools/tree/ThisExpression.class
sun/tools/tree/BitOrExpression.class 
sun/tools/tree/PositiveExpression.class
sun/tools/tree/IfStatement.class 
sun/tools/tree/FloatExpression.class
sun/tools/tree/NotEqualExpression.class
sun/tools/tree/InstanceOfExpression.class 
sun/tools/tree/NotExpression.class
sun/tools/tree/BitAndExpression.class 
sun/tools/tree/DivideExpression.class

sun/tools/tree/ShortExpression.class 
sun/tools/tree/RemainderExpression.class
sun/tools/tree/NewInstanceExpression.class sun/tools/tree/SwitchStatement.class
sun/tools/tree/AddExpression.class 
sun/tools/tree/AssignOpExpression.class
sun/tools/tree/EqualExpression.class 
sun/tools/tree/PostIncExpression.class
sun/tools/tree/GreaterExpression.class 
sun/tools/tree/PostDecExpression.class
sun/tools/tree/AssignExpression.class 
sun/tools/tree/WhileStatement.class
sun/tools/tree/ContinueStatement.class
sun/tools/tree/ConditionalExpression.class
sun/tools/tree/AssignAddExpression.class
sun/tools/tree/BinaryBitExpression.class 
sun/tools/tree/CastExpression.class
sun/tools/tree/AssignBitXorExpression.class
sun/tools/tree/ArrayExpression.class
sun/tools/tree/InlineMethodExpression.class
sun/tools/tree/InlineNewInstanceExpression.class
sun/tools/tree/CodeContext.class
sun/tools/tree/AssignShiftRightExpression.class
sun/tools/tree/UnsignedShiftRightExpression.class
sun/tools/tree/AssignBitAndExpression.class
sun/tools/tree/ShiftLeftExpression.class 
sun/tools/tree/CatchStatement.class
sun/tools/tree/IntExpression.class 
sun/tools/tree/TypeExpression.class
sun/tools/tree/CommaExpression.class
sun/tools/tree/AssignUnsignedShiftRightExpression.class
sun/tools/tree/ExprExpression.class
sun/tools/tree/AssignRemainderExpression.class
sun/tools/tree/ByteExpression.class sun/tools/tree/BinaryAssignExpression.class
sun/tools/tree/DoStatement.class 
sun/tools/tree/DeclarationStatement.class
sun/tools/tree/MultiplyExpression.class
sun/tools/tree/InlineReturnStatement.class sun/tools/tree/BitXorExpression.class
sun/tools/tree/BinaryCompareExpression.class
sun/tools/tree/BinaryShiftExpression.class 
sun/tools/tree/CheckContext.class
sun/tools/tree/PreIncExpression.class
sun/tools/tree/GreaterOrEqualExpression.class
sun/tools/tree/FieldExpression.class 
sun/tools/tree/OrExpression.class
sun/tools/tree/BinaryLogicalExpression.class
sun/tools/tree/NegativeExpression.class 
sun/tools/tree/LengthExpression.class
sun/tools/asm/
sun/tools/asm/Assembler.class 
sun/tools/asm/Instruction.class

sun/tools/asm/LocalVariable.class 
sun/tools/asm/ArrayData.class
sun/tools/asm/LocalVariableTable.class
sun/tools/asm/SwitchDataEnumeration.class 
sun/tools/asm/ConstantPool.class
sun/tools/asm/ConstantPoolData.class
sun/tools/asm/NameAndTypeConstantData.class
sun/tools/asm/NumberConstantData.class sun/tools/asm/FieldConstantData.class
sun/tools/asm/TryData.class 
sun/tools/asm/Label.class
sun/tools/asm/SwitchData.class 
sun/tools/asm/CatchData.class
sun/tools/asm/StringExpressionConstantData.class
sun/tools/asm/NameAndTypeData.class sun/tools/asm/StringConstantData.class
sun/tools/asm/ClassConstantData.class sun/tools/ttydebug/
sun/tools/ttydebug/TTY.class sun/tools/javadoc/
sun/tools/javadoc/Main.class sun/tools/javadoc/DocumentationGenerator.class
sun/tools/javadoc/HTMLDocumentationGenerator.class
sun/tools/javadoc/MIFDocumentationGenerator.class
sun/tools/javadoc/MIFPrintStream.class sun/net/
sun/net/MulticastSocket.class 
sun/net/URLCanonicalizer.class
sun/net/NetworkClient.class 
sun/net/NetworkServer.class
sun/net/ProgressData.class 
sun/net/ProgressEntry.class
sun/net/TelnetInputStream.class 
sun/net/TelnetProtocolException.class
sun/net/TelnetOutputStream.class 
sun/net/TransferProtocolClient.class
sun/net/ftp/
sun/net/ftp/FtpInputStream.class 
sun/net/ftp/FtpClient.class
sun/net/ftp/FtpLoginException.class 
sun/net/ftp/FtpProtocolException.class
sun/net/ftp/IftpClient.class sun/net/nntp/
sun/net/nntp/NewsgroupInfo.class 
sun/net/nntp/NntpClient.class
sun/net/nntp/UnknownNewsgroupException.class
sun/net/nntp/NntpProtocolException.class 
sun/net/nntp/NntpInputStream.class
sun/net/smtp/
sun/net/smtp/SmtpPrintStream.class 
sun/net/smtp/SmtpClient.class
sun/net/smtp/SmtpProtocolException.class sun/net/www/
sun/net/www/auth/
sun/net/www/auth/Authenticator.class 
sun/net/www/auth/basic.class
sun/net/www/content/
sun/net/www/content/text/
sun/net/www/content/text/Generic.class sun/net/www/content/text/plain.class
sun/net/www/content/image/

sun/net/www/content/image/gif.class 
sun/net/www/content/image/jpeg.class
sun/net/www/content/image/x_xbitmap.class
sun/net/www/content/image/x_xpixmap.class
sun/net/www/FormatException.class 
sun/net/www/MessageHeader.class
sun/net/www/MeteredStream.class 
sun/net/www/ProgressReport.class
sun/net/www/MimeEntry.class 
sun/net/www/MimeLauncher.class
sun/net/www/MimeTable.class 
sun/net/www/URLConnection.class
sun/net/www/UnknownContentException.class
sun/net/www/UnknownContentHandler.class sun/net/www/protocol/
sun/net/www/protocol/file/
sun/net/www/protocol/file/Handler.class
sun/net/www/protocol/file/FileURLConnection.class sun/net/www/protocol/http/
sun/net/www/protocol/http/Handler.class
sun/net/www/protocol/http/HttpURLConnection.class
sun/net/www/protocol/http/HttpPostBufferStream.class
sun/net/www/protocol/doc/
sun/net/www/protocol/doc/Handler.class sun/net/www/protocol/verbatim/
sun/net/www/protocol/verbatim/Handler.class
sun/net/www/protocol/verbatim/
VerbatimConnection.class sun/net/www/protocol/gopher/
sun/net/www/protocol/gopher/GopherClient.class
sun/net/www/protocol/gopher/GopherInputStream.class sun/net/www/http/
sun/net/www/http/UnauthorizedHttpRequestException.class
sun/net/www/http/HttpClient.class 
sun/net/www/http/AuthenticationInfo.class
sun/awt/
sun/awt/HorizBagLayout.class 
sun/awt/VerticalBagLayout.class
sun/awt/VariableGridLayout.class 
sun/awt/FocusingTextField.class
sun/awt/win32/
sun/awt/win32/MToolkit.class 
sun/awt/win32/MMenuBarPeer.class
sun/awt/win32/MButtonPeer.class 
sun/awt/win32/Win32Image.class
sun/awt/win32/MScrollbarPeer.class 
sun/awt/win32/MDialogPeer.class
sun/awt/win32/MCheckboxMenuItemPeer.class
sun/awt/win32/Win32Graphics.class 
sun/awt/win32/MListPeer.class
sun/awt/win32/MWindowPeer.class 
sun/awt/win32/MMenuItemPeer.class
sun/awt/win32/ModalThread.class 
sun/awt/win32/MCanvasPeer.class
sun/awt/win32/MFileDialogPeer.class 
sun/awt/win32/MTextAreaPeer.class
sun/awt/win32/MPanelPeer.class 
sun/awt/win32/MComponentPecr.class

sun/awt/win32/MCheckboxPeer.class 
sun/awt/win32/MLabelPeer.class
sun/awt/win32/Win32FontMetrics.class 
sun/awt/win32/MFramePeer.class
sun/awt/win32/MMenuPeer.class 
sun/awt/win32/MChoicePeer.class
sun/awt/win32/MTextFieldPeer.class 
sun/awt/win32/Win32PrintJob.class
sun/awt/image/
sun/awt/image/URLImageSource.class 
sun/awt/image/ImageWatched.class
sun/awt/image/InputStreamImageSource.class
sun/awt/image/ConsumerQueue.class 
sun/awt/image/ImageDecoder.class
sun/awt/image/ImageRepresentation.class
sun/awt/image/ImageInfoGrabber.class sun/awt/image/XbmImageDecoder.class
sun/awt/image/GifImageDecoder.class 
sun/awt/image/ImageFetcher.class
sun/awt/image/PixelStore.class 
sun/awt/image/JPEGImageDecoder.class
sun/awt/image/PixelStore8.class 
sun/awt/image/ImageFetchable.class
sun/awt/image/OffScreenImageSource.class 
sun/awt/image/PixelStore32.class
sun/awt/image/ImageFormatException.class
sun/awt/image/FileImageSource.class 
sun/awt/image/Image.class
sun/awt/UpdateClient.class 
sun/awt/ScreenUpdaterEntry.class
sun/awt/ScreenUpdater.class sun/misc/
sun/misc/Ref.class
sun/misc/MessageUtils.class sun/misc/Cache.class
sun/misc/CacheEntry.class 
sun/misc/CacheEnumerator.class
sun/misc/CEFormatException.class 
sun/misc/CEStreamExhausted.class
sun/misc/CRC 16.class
sun/misc/CharacterDecoder.class 
sun/misc/BASE64Decoder.class
sun/misc/UCDecoder.class 
sun/misc/UUDecoder.class
sun/misc/CharacterEncoder.class 
sun/misc/BASE64Encoder.class
sun/misc/HexDumpEncoder.class 
sun/misc/UCEncoder.class
sun/misc/UUEncoder.class 
sun/misc/Timeable.class
sun/misc/TimerTickThread.class sun/misc/Timer.class
sun/misc/TimerThread.class 
sun/misc/ConditionLock.class
sun/misc/Lock.class
sun/audio/
sun/audio/AudioDataStream.class 
sun/audio/AudioData.class
sun/audio/AudioDevice.class 
sun/audio/AudioPlayer.class
sun/audio/AudioStream.class 
sun/audio/NativeAudioStream.class
sun/audio/InvalidAudioFormatException.class
sun/audio/AudioTranslatorStream.class 
sun/audio/AudioStreamSequence.class

sun/audio/ContinuousAudioDataStream.class sun/applet/
sun/applet/StdAppletViewerFactory.class 
sun/applet/TextFrame.class
sun/applet/AppletViewerFactory.class 
sun/applet/AppletViewer.class
sun/applet/AppletCopyright.class 
sun/applet/AppletAudioClip.class
sun/applet/AppletSecurity.class 
sun/applet/AppletThreadGroup.class
sun/applet/AppletClassLoader.class 
sun/applet/AppletPanel.class
sun/applet/AppletViewerPanel.class 
sun/applet/AppletProps.class
sun/applet/AppletSecurityException.class
sun/applet/AppletZipClassLoader.class

B
ANSI-C Functions
Table B.1
Time functions
Table B.2

Classification functions

Table B.3
String functions

Table B.4
Conversion functions

Table B.5
Input/output functions



Table B.6
Other standard function

Table B.7
Math functions




C
Turbo Pascal Reference
The following is a list of Turbo Pascal procedures.

Turbo Pascal accesses some standard procedures and functions through units,
which are libraries of precompiled modules. For example, the Crt unit contains
routines which access the text display. To use a unit the uses keyword must be
included in a statement near the top of the program. For example, to use the
clrscr function:

The listing of modules in the crt unit is:
The listing of modules in the system unit is:

The listing of modules in the dos unit is:
The listing of modules in the graph unit is:

The following is a quick reference to commonly used functions.




The following is a quick reference to commonly used procedures.






D
Assembly Language Reference
D.1 Assembly language mnemonics
Table D.1 outlines the Assembly Language mnemonics (in column 1) and the
equivalent encoded bit values (in column 3). It also shows the number of cycles
for a 8086 processor and a 80386 processor (columns 4 and 5). The explanation
of the encoded bit values is given after the table.
Table D.1
Assembly Language reference 




Syntax:
reg
A general-purpose register of any size.
segreg
A segment registers, such as DS, ES, SS or CS.
accum
An accumulator of any size: AL or AX (or EAX on 386/486).
mem
A direct or indirect memory operand of any size.
label
A labeled memory location in the code segment.
src,dest
A source of destination memory operand used in a string operand.
immed
A constant operand.
and the bits are specified by:
d
direction bit. If set (1) then the transfer is from memory to register or register to register,
and the destination is a reg field. If not set then the source is a register field and the
transfer is from register to memory.
w
word/byte bit. If set the 16-bit operands are used, else 8-bit operands are used.
s
sign bit. If set then the operand has a sign-bit.
mod
mode. Identifies the register/memory mode. These are:
00
If r/m is 110 then direct memory is used, else the displacement is 0 and an indirect memory operand is
used.
01
An indirect memory operand is used with an 8-bit displacement.
10
An indirect memory operand is used with a 16-bit displacement.
11
A two-register instruction is used; the reg field specifies the destination and the r/m field specifies the
source.
reg register. Specifies one of the general-purpose registers. These are:
reg
16-bit, if w=1
8-bit, if w=0
000
AX
AL
001
CX
CL
010
DX
DL
011
BX
BL

100
SP
AH
101
BP
CH
110
SI
DH
111
DI
BH
r/m register/memory. Specifies a memory of register operand. If the mod file
is 11 then the register is specified with the reg field (as given above), else it has
the following settings:
reg
Operand address
000
DS:[BX+SI+disp]
001
DS:[BX+DI+disp]
010
SS:[BP+SI+disp]
011
SS:[BP+DI+disp]
100
DS:[SI+disp]
101
DS:[DI+disp]
110
DS:[BP+disp]
111
DS:[BX+disp]
The instruction encoding has the form:
where:
Disp
displacement. Specifies the offset for memory operands.
mmedi
register/memory. Specifies the actual values for constant values
D.2 Assembler directives
Table D.2 outlines some Assembly Language directives.
Table D.2
Assembly Language reference
Directive
Description
.386
Enables assembly of 386 code.

.8086
Enables assembly of 8086 code.
ASSUME segreg:name
Selects segreg to be the default segment register for all symbols in the
named segment.
.CODE
Defines the code segment.
COMMENT
Defines a comment.
.CONST
Defines a constant.
name DB init
Allocations and optionally initializes a byte of storage for each init.
name DW init
Allocations and optionally initializes a word of storage for each init.
name DD init
Allocations and optionally initializes a double word of storage for each init.
name DF init
Allocations and optionally initializes a far word (6 bytes) of storage for each
init.
name DQ init
Allocations and optionally initializes a quad word (8 bytes) of storage for
each init.
.DATA
Define the data segment.
ELSE
Defines an alternative block of the IF directive.
END
Defines the end of a module.
ENDIF
Defines the end of the IF directive.
EXTERN names
Defines one of more external variables, labels or systems which are called
names.
IF expression ifstatements
ENDIF
Defines the IF directive.
INCLUDE filename
Includes source code.
.MODEL mem_model
Defines memory model.
name module_name
Defines the module name.
org express
Organizes the program in memory.
. stack size
Defines the stack size.
title text
Defines title.
D.3 C and Pascal interrupts
In Turbo/Borland C there are four main functions to interrupt the processor:
int86x(), intdos(), intr() and int86(). These functions are prototyped in the
header file dos.h. This header file also contains a structure definition that
allows a C program to gain access to the processor’s registers. Parameters are
passed into and out of the interrupt sevice routines via these registers. The
format of the structure is:

Registers are accessed either as 8-bit registers (such as AL, AH) or 16-bit
registers (such as AX, BX). If a structure name regs is declared, then:
The syntax of the function int86() takes the form of
where the first argument of the parameter list is the interrupt number, the input
registers are passed as the second argument and the output registers the third.
Parameters are passed to the interrupt routine by setting certain input registers
and parameters are passed back from the interrupt in the output registers.
In a similiar way Turbo Pascal provides access throught the routine named
Intr(). To gain access to this procedure the uses dos; statement is placed near
the top of the program. A data type named Registers has also been predefined,
as shown below. Note that it is possible to use either the 16-bit registers (such as
AX, BX) or 8-bit (such as AL, AH):

In Program D.1, the DOS interrupt 21h and function 02h (write character to
the output) is used to display the character ‘A’. In this case, the function number
02h is loaded into AH and the character to be displayed is loaded into DL.
Program D.2 shows how a program can gain access to the system date. The
function used in this example is 2Ah. Test run D. 1 gives a sample run.


E
ASCII Character Set ANSI defined a
standard alphabet known as ASCII. This
has since been adopted by the CCITT as
a standard, known as IA5 (International
Alphabet No. 5). The following tables
define this alphabet in binary, as a
decimal, as a hexadecimal value and as
a character.

The standard ASCII character set is a 7-bit character and ranges from 0 to

127. This code is rather limited as it does not contain symbols such as Greek
letters, lines, and so on. For this purpose the extended ASCII code has been
defined. This fits into character number 128 to 255. The following 4 tables
define a typical extended ASCII character set.


Index
—Ω—
Ω, 24, 275
—1—
100Ω, 93
100Mbps, 402, 412
10Mbps, 402
155Mbps, 402
16Mbps, 402
—2—
24-bit colour, 462
256 colours, 394
2s complement, 159, 222, 223, 227, 277, 424
—8—
80286, 230, 274, 476
80386, 5, 231, 232, 233, 236, 243, 274, 276, 476, 485, 649, 653, 655
80386DX, 230, 232
80486, 231, 232, 236, 239, 241, 243, 245, 252, 254, 276, 415, 476, 653
8086, 229, 230, 233, 234, 236, 243, 244, 261, 271, 274, 276, 279, 476, 649, 655
8088, 230
8255, 268
A
AA, 245, 254
accumulator, 233, 649, 650, 651, 652, 653
accuracy, 91, 309
active, 232, 233, 268, 270, 286, 295, 300, 506, 507, 510, 532, 597

ADC, 21, 649
address bus, 4, 219, 220, 226, 230–232, 236, 261, 262
address bus size, 226, 230
addressable memory, 226
addressing
immediate, 236
memory, 226, 236, 237
register, 236
addressing memory, 244
AIX, 549
algorithm, 3, 129, 135, 219
alias, 557, 605, 609, 619
AM, 413
American, 391, 413
ampersand, 108, 111, 180, 345, 483
analogue, 553
AND, 35, 36, 41, 64, 96, 97, 247, 423, 424, 598, 611, 649
angle, 32, 33, 37, 39, 98–101, 118, 119, 200, 201, 376, 448
animation, 454
ANSI, 8, 12, 15, 96, 368, 391, 413, 484, 495, 627
apple, 29, 229, 319, 476
ARC, 492
archive, 529, 583, 584, 590
arctan, 32, 33, 101
arctan(), 32
argument, 81, 86, 87, 90, 108, 109, 111, 162, 193, 194, 205, 310, 311, 440, 460, 552, 580–582, 585, 586,
613, 615, 616, 620
arithmetic operator, 421, 422
ARP, 391, 413
array indexing, 181
array of strings, 148, 150, 155, 156
Array of structures, 181
arrays, 121
arrays of strings, 610
arrow keys, 294, 596

ASCII, 24, 60, 61, 67, 143, 159, 160, 240, 286, 363, 368, 391, 413, 424, 483, 493, 565, 573, 586, 628
BEL, 191, 475, 549
CR, 160, 597, 598, 599
FF, 245, 252, 254, 392, 393
LF, 160
SUB, 246, 652
ASCII characters, 60, 61, 67, 159, 240, 424, 565
ASK, 413
aspect ratio, 376
assembler directives, 252, 654
assembly, 224, 239, 240, 243, 265, 266, 267, 655
Assembly Language, 5, 219, 239, 243, 245, 247, 259, 271, 415, 649, 654, 655
asynchronous, 413
AT, 191, 230
attributes, 162, 163, 415, 484, 525, 529, 554–556, 565, 576, 603, 631
changing, 556
au, 464, 482, 485, 490–493, 499, 501, 530
audio, 410, 411, 437, 454, 464, 465
AUTOEXEC.BAT, 530
averages program, 166
averaging, 136
B
backspace, 24
base pointer, 234
BASIC, 3, 5, 219, 291–294, 296, 305, 307, 308, 310, 311, 317, 324, 327–329, 339, 345, 352, 361, 362,
371, 374, 415, 483, 530, 551
BCD, 287
bell, 549
Bell Laboratories, 191, 475, 549
best possible units, 56
binary, 3, 4, 5, 63, 79, 108, 159, 163, 168, 169, 170, 171, 210, 211, 215, 216, 220, 221, 222, 223, 224,
225, 243, 244, 265, 271, 272, 273, 411, 413, 415, 564, 570, 573, 631, 632
address, 108
commands, 5, 415
file, 159, 163, 168, 170, 171, 211, 216, 573, 631

I/O, 215
numbers, 221
read/write, 168
BIOS, 263, 279, 281–284, 285, 286, 287, 288
printer interrupt, 286, 287
bit shift, 233, 248, 424
bitmapped, 159, 545
bitwise, 35, 41, 210, 247, 424–426, 447
bitwise operator, 35, 424
black, 81, 82, 83, 281, 302, 387, 393, 399, 437, 462
blank lines, 173
blue, 281, 288, 302, 373, 374, 387, 392, 393, 398, 462, 463, 507, 509, 532, 534, 544
BMP, 293, 299, 371, 372, 545
bold, 385, 472
Boolean, 307, 308, 309, 310, 311, 417, 418, 420, 424, 434, 455
bitwise, 247, 424
logic, 63, 102
boot drive, 280, 281
Borland C, 238, 265–267, 291, 494, 495
Borland C++, 6, 291, 494, 495
Bourne shell, 605, 606
braces, 9, 41, 68, 132, 150, 179, 426, 427, 428, 444, 450, 483
brackets, 122, 124
bridge, 413
browser, 385–389, 393, 394, 401, 404, 410, 411, 415–417, 431, 433, 437, 438, 440, 442, 444, 445
buffer, 48, 69, 144, 285
Busicon, 229, 475
Button settings, 313
byte, 220
byte enable lines, 232
C
C
arrays, 121
file I/O, 162

functions, 82, 123
parameter passing, 107
program, 9–12, 16, 18, 19, 23, 24, 26, 35, 48, 91, 93, 107, 111, 113, 114, 145, 146, 148, 159, 166, 168,
172, 178–180, 223, 405, 418, 552, 561, 565, 570, 572–574, 592
C shell, 601, 605, 606, 609, 610, 615–620
C/C++, 415, 437, 439, 446, 449, 450
C++, 191–202, 205, 206, 208, 211–216, 241, 266, 267, 268, 291, 414–416, 421, 426, 436, 437, 439, 446,
449, 450, 494, 495
class template, 207
classes, 192, 195, 209
constructors, 205, 209
data hiding, 192
destructors, 205
function templates, 206
I/O stream support, 192
objects, 192, 417, 429
overloading, 192, 193
template classes, 192
virtual functions, 192
call by reference, 109, 111
capacitance, 55, 73
capacitive reactance, 30, 31
capacitor, 30, 63, 73, 149, 150, 183
caption, 345
caption property, 324, 326, 331, 334, 335, 337, 338
carriage return, 160, 586, 628, 632
carry flag, 247, 248, 649, 652
case options, 54
CBS, 475
CD, 265, 479, 491–493, 495, 515, 535
centigrade, 27, 92–94, 331, 332
CGI, 405
CGI script, 405
changing directory, 552
character alphabet, 391, 413
character arrays, 141, 143, 144

character handling, 12, 16
character strings, 175
characters and numbers, 243
click, 362, 363, 364, 372, 373, 375, 377, 378
clients, 525
clock cycles, 273–275
clock period, 273, 275
cls, 375, 379
cluster, 529
CMC, 649
COBOL, 3, 5, 415
code
machine, 4, 5, 239, 240, 415
object, 5, 6, 86
source, 5–8, 10, 13, 23, 87
colour, 49–52, 57, 58, 281, 282, 288, 293, 300–302, 318, 319, 373–378, 387, 392–394, 399, 461, 462,
471, 513, 531, 589
colour code, 49, 50, 51, 52, 318, 319
COM1:, 265
combinational logic, 94
combinations, 220, 296, 365
comments, 9, 13, 193, 243, 426, 428
Commodore, 229, 476
commondialog, 352, 355, 357
compilation, 5–7, 25, 123, 447, 570
compile, 6, 7, 494, 565
compiler, 5–8, 11, 13, 16, 18, 19, 23, 25, 32, 86, 87, 108–110, 122, 123, 181, 193, 238, 310, 415–417,
438, 439, 443–445, 464, 469, 494, 570, 571, 572
complex arithmetic, 184
complex functions, 200
complex impedance, 186
complex number, 37, 101, 118, 184, 188, 192, 199, 200, 203
complex numbers, 192, 199
compress, 411, 553, 554, 558, 559, 560, 575
compressed, 159
compression, 394

computing, 229
conditional jump, 249, 250
CONFIG.SYS, 530
constants, 9, 13, 49, 54, 113, 243, 355, 357, 365, 366, 447
control bus, 4
control Register, 268, 269
controls, 293, 302
conversion characters, 91
conversion control character, 24, 26
copper wire, 10, 14
copying, renaming and removing, 558
counting the number of characters, 147
CPU, 239, 241, 245, 252, 254, 567
creating a menu system, 346
csh
event numbers, 607
reexecuting events, 607
cube, 449
currency, 308, 309, 310
D
DAT, 163, 166, 167, 168, 488
data
bus, 4
definition, 253
Register, 265, 266, 267
segment, 235, 240, 253, 655
type, 9–11, 14, 25, 26, 49, 81, 86–91, 108, 109, 121, 122, 124, 141, 145, 148, 150, 160, 162, 175, 176,
178, 179, 191, 193, 199, 205–207, 209, 237, 281, 308–312, 417, 418, 444, 446, 447, 451, 455
types, 10, 14, 307, 308, 418
database program, 176, 178, 186
date, 201, 280, 307, 309, 310, 311, 434, 477, 478, 484, 485, 487, 490, 554, 561, 563, 568, 569, 585, 586,
591, 592, 619, 627
DD, 391, 477, 480, 481, 655
debugger, 6, 7, 240, 255–259, 439, 445, 570, 571
DEC, 246, 549, 650

decimal, 60, 77, 79, 221–225, 227, 243, 244, 309, 392, 393, 420, 561, 650
decimal point, 25
decisions and loops, 317
declaration, 11, 14
declaration of variables, 11, 14
degrees, 32, 33, 39, 65, 100, 101, 156, 462
del, 286, 346, 478, 519, 544, 545
Delphi, 291
destination address, 234, 244
dialog Box, 345, 354
Digital, 265, 268, 271
Directory structure, 550
disk drives, 4, 219, 299, 416, 476, 479, 500, 505, 562, 577
divide by zero, 44, 55, 56, 70, 73, 167, 168
division, 308, 421, 422, 649
do..while loop, 68–70, 320
DOC, 483, 488–492, 499, 501, 519, 521, 522, 530
domains, 526, 527
DOS, 236, 243, 254, 279, 280, 281, 283, 285, 286, 291, 476–479, 481–485, 487, 490–499, 501, 505, 506,
513, 519, 525, 528–531, 535, 536, 539, 541
cls, 478
copy, 496, 500
date, 477, 563
delete, 495, 628
dir, 484, 485, 490–493, 494–500, 563
erase, 495, 496
exit, 280, 281, 283, 285, 286
filenames, 483
format, 479–481
mkdir, 493
run, 535
services, 279
starting and stopping, 478
time, 477, 479, 487, 563, 567, 568
type, 493, 496, 500

unformat, 480
ver, 477
version, 280, 477, 487
DOS-based, 243, 519
drag and drop, 367
E
earth, 29
Edinburgh, 324
edit, 5, 294, 440, 441, 445, 494, 497, 593, 594, 597
editor, 5–7, 159, 166
eece.napier.ac.uk, 398, 460
EEPROM, 4
electronic mail, 525
EM spectrum, 45
EM wave, 45, 46, 47, 55
encapsulation, 191
EOF, 164
equates, 254
equivalent resistance, 12, 15, 20, 34, 39, 40, 57, 58, 79, 115, 116
error, 10, 16, 19, 23, 25, 44, 55, 56, 72, 86, 87, 142, 145, 164, 165, 168, 209, 213, 284, 287, 310, 311, 321,
373, 399, 401, 617, 631, 632, 633, 634, 635
error processing, 213
escape sequence, 24
Ethernet, 390, 391, 402, 408, 409, 411–413, 434, 435
event handling, 430
executable, 5, 7, 8, 12, 16, 159, 405, 411, 417, 555, 556, 561, 570, 573, 574
exp(), 88, 90
Explorer, 417, 531
exponent, 25, 160, 424
F
Fahrenheit, 27, 92, 331, 332
farads, 31, 55
FAT, 528, 529
fault tolerance, 412

FAX, 467, 468
FC, 490, 491
fclose(), 163
FDDI, 390, 402, 408, 411–413, 434, 435
DAS, 650
feof(), 164
FET, 78
fflush(), 48
fflush(stdin), 48, 69
fgetc(), 164
fgets(), 165
file
attributes, 163, 529, 554
binary read/write, 168
binary, 159, 163, 168
I/O, 159
pointer, 160, 162–164
pointers, 214
system structure, 481
system, 491, 499, 505, 513, 525–529, 539, 578
systems, 505, 525, 526, 528
text, 159, 160, 163, 165, 166, 174
transfer protocol, 587
find_nearest_pref(), 132
firmware, 3, 192
floating point, 11, 14, 15, 24, 25, 32, 152, 160, 166–168, 174, 175, 176, 178, 215, 222, 308, 311
floppy disk, 478, 479, 480, 481, 500, 501, 505, 515–517, 521, 529, 535, 546
fopen(), 162, 163
for loop, 59, 63, 77, 96, 155, 320, 427
force of attraction, 29
format descriptor, 35
forms, 293, 323, 324, 405
forms and code, 324
FORTRAN, 3, 5, 159, 219, 415, 492, 551, 562, 570, 571, 584, 614
fourth, 65, 129, 602, 606

fprintf(), 165
fputc(), 164, 165
fputs(), 165
frame, 298
France, 324, 330
fread(), 168
free disk space, 279, 280
frequencies, 30
frequency, 30, 31, 32, 33, 45–47, 55, 73, 98–100, 101, 153, 154
fscanf(), 162, 164, 165
ftp, 443, 565, 587
function
declarations, 86
header, 81, 105, 109, 111
prototype, 84, 85, 87, 88, 96, 111, 115
general, 12, 15, 81, 106, 428, 444, 448, 488, 627
fwrite(), 168
G
gateway, 405
gateways, 261
get_float(), 155, 181
get_int(), 181
get_values(), 111, 114, 166
getchar(), 25, 26, 48, 53, 69, 75, 76, 147, 164
gets(), 25, 147, 165
GIF, 159, 393, 394, 416, 459, 471
global variable, 82, 83, 84
gradient, 28, 29
graphical user interface, 593
ground, 598
H
hackers, 416, 528
handshaking, 269, 270

hardware, 3–5, 219, 229, 233, 263, 279, 412, 415, 437, 476, 505, 513, 528
HD, 480, 481
header, 8, 9, 13, 23, 25, 26, 32, 44, 51, 81, 86, 87, 105, 106, 109, 111, 192, 209, 265, 266, 267, 385, 386,
403, 439, 469, 563
header file, 8, 9, 23, 25, 32, 51, 86, 87, 201, 439, 563
help, 533
help files, 159
help manuals, 357, 481
hertz, 31
hexadecimal, 24, 25, 35, 77, 79, 108, 224, 225, 236, 237, 243, 302, 373, 374, 378, 392, 393, 420, 629
hierarchical decomposition, 82
high-level language, 5, 219, 243, 415–417, 436
history, 605, 606
hobby computers, 3
hosts, 562
HPFS, 528
HP-UX, 549, 550
HTML, 385–388, 390, 391–397, 399, 401–409, 413, 416–419, 429, 430, 432–436, 438, 440, 441, 450,
451, 455–460, 463–468, 470
anchors, 401
background images, 393
colours, 392
definition lists, 391
displaying images, 394
hexadecimal colours, 392
horizontal lines, 397
input types, 407
links, 387
lists, 388, 491
menus, 345, 409
ordered lists, 388
script, 386–388, 390, 391, 394–397, 399, 401–404, 406–409, 416, 440, 441, 450, 451, 455–460, 463–
468, 470
tables, 403
unordered lists, 388, 390
http, 387, 394, 398, 416, 431, 438, 443

hubs, 412
Hughes, 475
Hz, 153, 154
I
I/O
classes, 209
digital programs, 271
digital, 265, 268, 271
inputting a byte, 265
isolated, 261, 263
library, 208
memory mapped, 261, 262
outputting a word, 267
stream, 192, 208, 213
streams, 208
IBM, 229, 230, 412, 475, 476, 549
IC programmers, 21
icons, 371, 372, 373, 513, 514, 515, 532, 538
IDE, 265, 494, 500
IEEE, 309, 448
if(), 41–43, 45, 49, 426, 427
if … else statements, 41, 427
images, 293, 299, 393–396, 459
impedance, 32, 73, 98, 100, 101, 151, 173
implied addressing, 236
information, 4, 5, 8, 9, 152, 159, 209, 220, 229, 243, 279, 299, 312, 314, 387, 391, 394, 402, 403, 405,
413, 415, 429, 437, 476, 479, 480, 483–485, 493, 505, 510, 519, 526, 537, 541, 545, 550, 552–554, 562,
567, 570, 571, 573, 586, 588, 591, 620
initializing an array, 132
input/output, 4, 9, 12, 16, 21, 22, 23, 81, 161, 162, 209, 219, 233, 261, 268, 416, 439, 562, 583
insert mode, 594, 595, 597, 598
integrated development, 6, 7, 494
Intel, 229, 230, 231, 233, 415, 475, 476
Intel microprocessors, 230, 231, 233
interface, 81, 231, 232, 261, 265, 291–324, 437, 446, 453, 505, 549

interfacing with memory, 262
Internet, 411, 417, 437, 438
Internet Explorer, 417, 437
interrupt
1682h, 281
1684h, 283
1686h, 284
1688h, 284
1690h, 285, 1Ah, 287
1693h, 279
interrupts, 279
IP, 234, 391, 412, 413, 437, 526, 549
IP address, 391, 413, 437
IPX, 412
ISDN, 435
J
Java, 159, 191, 403, 404, 414–418, 421, 422, 428, 434, 436–472
applet, 415, 416, 418, 437–458, 460, 463–472
compiler, 416, 417, 438, 439, 443, 444, 464
script, 442
JPE, 651
JPEG, 159, 393, 394, 459, 471
JPG, 416
K
kΩ, 56
keyboard, 4, 5, 9, 12, 16, 21, 22, 25, 26, 48, 69, 144, 192, 202, 216, 219, 264, 279, 281, 285, 288, 431,
455, 457, 476, 505, 519, 559, 560, 575, 582, 596, 618, 632, 633
keyboard buffer, 144
keypress, 361–363, 368, 458, 459
keystroke, 285, 286, 471, 490, 546, 559, 587, 591, 594, 595, 606
keywords, 5, 10, 12, 15, 41, 176, 179, 415, 426
Korne shell, 605
L

LAN, 402, 411
length, 52–54, 141, 143, 144, 148, 220, 310, 371, 407, 428, 471, 620, 632
libraries, 5, 9, 12, 15, 23, 81, 86
library, 12, 16, 25, 144, 208, 352, 444, 447, 469, 545, 563, 573, 583, 584
LIFO, 250
light, 13, 45, 271, 273, 278, 281, 393
limiting ranges of inputs, 69
line break, 386, 404, 412
linker, 5, 6, 7, 86
Linux, 549
listing contents of a file, 557
listing directories, 553
ln(), 90
Local and global variables, 83
local area network, 412
local variables, 81, 82, 106, 610
log(), 88, 90
logarithms, 90
logical, 41, 308, 421, 423, 426, 611
logical operator, 96, 423, 424
login into the system, 550
long integer, 160, 237, 308, 309, 630
long word, 220
lost focus, 368
lowercase, 12, 48, 53, 58, 145, 590, 628, 629, 630
LZH, 492
M
MΩ, 56
MAC, 390
MAC addresses, 390
machine code, 4, 5, 239, 240, 245, 246, 261, 415, 416
machine code and assembly language, 240
macros, 5, 8, 9, 53, 253, 415
main(), 82–84, 85, 168, 193

making and removing directories, 557
manganese, 52
MASM, 253, 491, 492, 493
mathematical functions, 12, 16, 201
memory, 3, 4, 7, 11, 14, 26, 107–109, 122, 144, 181, 205, 215, 219, 220, 221, 226, 230, 232–241, 244,
246, 248, 251, 259, 261–265, 268, 278, 286, 291, 393, 454, 526, 549, 633, 651, 653–656
address, 3, 4, 26, 108, 122, 144
addressing, 226, 236, 237
cache, 230
map, 108, 109, 261–265
segmentation, 236
menu, 6, 7, 57, 155, 186, 294–296, 300, 301, 302, 345–349, 351, 353, 358, 409, 430, 467, 468, 494, 507–
510, 512, 516, 522, 534, 539, 543
menu editor, 345, 346, 347, 350
metafile, 293, 299, 371
mF, 55
microprocessor, 4, 5, 219, 220, 229, 230, 231, 262, 415, 476
Microsoft, 159, 191, 253, 262, 263, 266, 267, 268, 291, 310, 330, 352, 417, 476, 481, 505, 506, 510, 514,
517, 519, 525, 530, 543
Assembler, 253
Office, 476
Visual C++, 191, 291
Windows, 262, 263, 291, 310, 352, 476, 481, 505, 510, 517, 519, 525
microwaves, 45
MIME, 411
model
large, 238
small, 238
modular program, 81
module, 105, 106, 118, 252, 295, 296, 347, 570, 571, 655, 656
modules, 292
MOS, 229, 476
MOS Technologies, 229, 476
Motion video, 159
Motorola, 229, 415
mouse

control, 533
controls, 508, 533
down, 364
up, 364
MOV, 244, 651
move instruction, 244
moving around data in memory, 251
MPEG, 410
MS-DOS, 513, 525, 528, 529, 536, 541
multimedia, 408, 410
multiple choice example, 324
multiplication, 422
multitasking, 416, 525, 526, 549, 567
N
NAND, 35, 36, 96
Napier
EECE department, 398, 460
negative, 85, 90, 145, 222, 234, 235, 246, 249, 311, 320, 426, 462, 607, 629
negative numbers, 222
nested loop, 96
Netscape, 417
network, 18, 402, 408, 409, 411–413, 435, 437, 479, 497, 515, 525–528, 530, 531, 537, 587
network management, 412
network traffic, 412
networking, 525, 531
New York Times, 475
newline, 23, 24, 165
nF, 55
nibble, 220
NOR, 35, 36, 64, 96, 97
NTFS, 528
null, 143, 144, 147
numbers and representations, 222

O
object code, 159
object properties, 323
object-oriented, 291
objects, 191, 192, 207, 293, 297, 299, 303, 340, 341, 350, 362, 371, 417, 429, 432, 434, 435, 463, 465
octal, 24, 25, 77, 224, 225, 243, 420, 576, 586
OLE, 299, 330
opening a file, 162
operating system, 10, 21, 159, 291, 401, 415, 476, 505, 525, 526, 528, 530, 546, 549, 567, 605
operators, 307, 425
optical disks, 479
OR, 35, 36, 41, 96, 97, 210, 247, 278, 423, 424, 457, 611, 651
ordered, 388, 389
organization, 391, 413, 527
OS/2, 528
OSF/1, 549
OSI, 390, 413
P
paragraph, 386, 550, 598
parallel, 11, 12, 15, 19, 33, 34, 39, 47–49, 57, 58, 70, 79, 114–116, 151–155, 186, 194–199, 265, 283
parallel resistors, 19, 33, 39, 57
parallel_impedance(), 152
parameter conversion, 24
parameter list, 86, 106, 121, 123, 125
parameter passing, 81, 84, 105, 106, 107, 198, 437
parameters, 24, 25, 29, 52, 81, 82, 84, 86, 87, 89, 100, 104–106, 109, 142, 152–155, 198, 201, 284, 312,
316, 363, 397, 404, 428, 440, 444, 457, 461, 463
Pascal, 3, 5, 7, 13–16, 18, 19, 21, 22, 23, 26, 27, 31, 32, 35, 36, 41, 48, 49, 53, 54, 68, 88, 91, 92, 93, 97,
100, 104, 105, 106, 113, 114, 118, 119, 121, 124, 132, 141, 142, 150, 152, 154, 159, 161, 166, 168, 172,
175, 176, 177, 219, 225, 237, 261, 266, 267, 293, 307, 308, 318, 320, 401, 415, 436, 437, 483, 494, 500,
571
array routines, 142
arrays, 124
compilation, 7
file I/O, 161

functions, 88
parameter passing, 106
program, 13, 15, 16, 18, 19, 23, 36, 54, 91–93, 97, 100, 113, 114, 150, 161, 166, 168, 172, 176, 177
string, 141, 142
string conversion routines, 142
passing arrays to C functions, 123
passing arrays to functions, 124
passing by reference, 81
passing by value, 81
PC, 5, 6, 7, 159, 229, 230, 233, 236, 240, 262, 263, 272, 283, 291, 415, 437, 438, 440, 476, 478, 479, 487,
493, 505, 506, 510, 520, 525, 549
PCX, 483, 490
peer-to-peer, 525, 526
Pentium, 231, 233, 236, 243, 276, 415, 476
permutations, 63, 96, 578
pF, 55
pixels, 371, 377, 378, 396, 397, 403, 404, 433, 440
pointer variable, 122, 124
pointers, 81, 107–109, 110–115, 122–124, 144, 145, 147, 160, 162–164, 180, 198, 214, 237, 238, 437, 505
far, 237, 238
near, 238
near and far, 237, 238
with functions, 109
polygons, 463
ports
number, 284
Port A, 268–270, 273, 276–278
PortB, 268–273, 276–278
Port C, 268, 269, 270, 278
Postscript, 159
power(), 87, 90
precedence, 307, 308, 425, 447
precision specifier, 25
preemptive, 526, 549
preemptive multitasking, 526, 549

preferred resistor value, 135, 136
presentation, 309, 401
print servers, 525
print_results(), 112
printable, 628
printer port, 287
printf(), 23, 24, 25, 53, 86, 87, 91, 145, 162, 165, 192, 208, 629
priority, 425, 568, 570
private key, 195
procedures, 293
processor flags, 235
project files, 292
prototyped, 32, 44, 86, 87, 144, 199, 200, 265–267, 268
prototypes, 86, 93, 94
public member, 195
push and pop, 250
putchar(), 23, 164, 165
puts(), 9, 13, 23, 24, 165
Q
quadratic equation, 42–45, 56, 105, 111, 113, 114, 334, 335
quadratic equations, 111
quadratic roots, 334
R
RADAR, 492
radians, 32, 33, 38, 39, 100, 101, 376, 634
radio, 45, 293, 408, 431, 467
RAM, 4, 220, 263, 493
range, 3, 11, 14, 70, 71, 104, 132, 139, 199, 223, 231, 263, 301, 308, 309, 310, 311, 321, 336, 337, 345,
374, 392, 446, 448, 634, 635, 636
Raytheon, 475
RC circuit, 61–63, 151
RCA, 475
read_data(), 168
reading and writing one character at a time, 171

readln(), 154
recast, 88
records in Pascal, 175
rectangular, 186, 448
red, 288, 302, 373, 374, 392, 393, 398, 462
register, 233, 235, 239–241, 244, 246, 248, 251, 253, 259, 265–274, 279, 281, 285, 649–655
relationship operator, 422
repeat..until, 59, 68, 69, 70, 77, 142, 161
repeating program, 69
resistance, 10–15, 19, 20, 23, 32–34, 39, 40, 48, 49, 52–58, 69–73, 75, 76, 79, 98, 100, 104, 109, 114–116,
133–136, 153, 154, 196, 197, 198, 208, 216, 321, 338, 339
resistance calculation, 336
resistance of a conductor, 52
resistivities, 53
resistor colour code, 49
resize, 362, 368, 369, 511, 538
return, 84
flag, 111
statement, 84
value, 10, 84, 85, 87–89, 110, 164, 165, 213, 279, 315, 429, 444, 630–636
RGB, 302, 373, 374, 375, 376, 377, 392
ring network, 412
RL series, 32, 66, 98, 99, 154, 155
RL series circuit, 32, 66, 98, 99, 155
ROM, 4, 263, 265, 479, 515, 535
root, 32, 43, 44, 45, 55, 56, 70, 105, 111–114, 200, 334, 448, 449, 452, 481, 482, 517, 550, 560, 561, 574,
576, 577, 606, 635
root type, 111, 113, 114
RR, 302
RS–232, 284, 435
running average program, 126
S
sampling, 136
scanf(), 25, 26, 35, 48, 86, 87, 91, 111, 145, 154, 162, 165, 208, 629, 632
schematic, 31–33, 63, 95, 97, 98, 151

SCO, 549
scroll bar, 507
search, 8, 147, 172, 305, 508, 509, 581, 599, 601, 613
section header, 385
sectors, 280, 479, 529
segment, 235–237, 239–241, 244, 245, 251–255, 280, 281, 283, 286, 526, 651, 653, 655
serial, 480, 481, 484–498, 541
serial communications, 284
serial port, 283, 284, 285
series RL, 98–100
server name, 398
servers, 525, 537, 538
shell scripts, 615
shell variables, 612
shift instructions, 247
shift/rotate, 247
short integer, 109
signed integer, 11, 14, 24, 176, 178, 223, 224, 227, 424
silver, 52
Sinclair, 229, 476
SMTP, 443
software, 3, 4, 9, 10, 13, 18, 141, 191, 229, 230, 236, 239, 262, 412, 414, 437, 476, 494, 506, 510, 525,
549, 550, 650
software engineers, 3
Solaris, 549
sort(), 129
sorting program, 129
sound, 159, 459, 464, 472
sound file, 159, 514
source, 5, 6, 7, 8, 10, 13, 23, 31, 78, 82, 87, 142, 234, 246, 252, 367, 386, 442, 518, 558, 561, 565, 571,
653
source address, 234
special characters, 556
specification, 3, 25, 401
speech, 413
speed of light, 13, 46

SPX, 412
SPX/IPX, 412
sqrt(), 86, 87, 100
square root, 32, 43
squares, 65, 299
sscanf(), 145
stack pointer, 234
standard functions, 12, 16, 633
standard input, 559, 575, 583, 632, 633
standard input and output, 559
standard output, 559, 574, 580, 586, 601, 633
standard string functions, 144
standards, 391, 413
statement block, 41, 42, 59, 60, 68, 318, 319, 321, 427, 428, 449, 450, 451
statements, 422
repetitive, 59, 81, 105, 121, 159
static, 12, 418, 445, 446, 449
statements
logical, 41, 426
status registers, 234
stdin, 48
stop bit, 284, 413
straight line, 28, 29, 104, 107, 111, 201
strcat(), 144
strcmp(), 146
strcpy(), 144
string manipulation, 141
string variables, 610
strings, 141, 144, 147, 420, 445
strlen(), 144
strlwr(), 144
structure chart, 85, 86, 89, 98, 112, 114, 115, 132, 151, 181
structures, 181, 186
arrays, 181
dot notation, 176, 178

members, 175, 176, 178
pointer operator, 180
structures and Records, 175
SUB, 246, 652
subroutine calls, 250
Sun Microsystems, 191, 415, 438
swap, 106, 107, 110, 546
swapped, 129
switch statement, 49, 54, 617
switch(), 49, 54
synchronized, 4, 220, 413, 446
synchronous, 265
syntax, 86, 265, 266, 267, 415, 417, 418, 421, 425, 427, 428, 450, 505
system date, 280, 563
system time, 279, 280, 283, 287
SYSTEM.INI, 541, 545
T
TAB, 297, 488, 543, 546
tables, 403, 562, 593
tangent(), 91
TCP, 391, 412, 413, 437, 526, 549
TCP/IP, 391, 412, 413, 437, 526, 549
TD, 403, 404, 405
television, 471
telnet, 443
temperature conversion, 332
temperature conversion program, 331
terminal, 586, 618
terminate and stay, 280
test, 6, 7, 26, 28, 29, 31, 35–37, 39, 40, 45, 55, 57, 58, 60, 79, 86, 89, 90, 92, 97, 163, 167, 168, 170, 185,
201, 205, 206, 213, 234, 271, 285, 286, 321, 332, 351, 428, 436, 440, 449, 451, 458, 459, 464, 478, 569,
573, 574, 602, 611
Texas Instruments, 475
text, 159, 212, 282, 323, 326, 327, 330–336, 351–355, 364, 365, 366, 368, 372, 373, 468, 483, 514, 545,
593

blink, 385
editor, 166, 385, 401, 494, 575, 593
file, 159, 494, 514, 545
I/O, 212
keyword, 161
textbackground function, 57
time step delay, 136
timing, 261, 273
token, 9, 254, 255, 408, 412, 413
Token Ring, 390, 402, 408, 409, 412, 413, 434, 435
MAUs, 412
token rings, 412
tolower(), 48, 53, 54
topology, 387
TR, 403, 404, 405
tracks, 479
traffic, 278, 412
transient response, 61
transistor, 475
transistors, 475
truth table, 63–65, 94–97
Turbo Debugger, 239, 241
Turbo Pascal, 5, 7, 14, 15, 18, 48, 237, 266, 267, 494
TXT, 483, 490, 496, 497, 498, 545, 546
type keyword, 124, 176
types of roots, 45, 334
U
UK, 398
uncompress, 575
uncompressed, 575
unconditional jump, 249
UNIX, 8, 405, 438, 492, 525, 528, 549, 550, 552, 554, 559, 562, 566, 567, 570, 572, 576, 584, 589, 591,
593, 605, 606
banner, 584, 585
cal, 563, 565, 584, 585

cat, 557–566, 574–580, 583, 591, 600, 606–609, 615, 619
cc, 557, 561, 562, 569–572
chmod, 556–577, 615, 616
chpass, 585
compiling C programs, 561
cp, 557, 558, 564, 566, 572, 573, 612
date, 585
dbx, 570, 571
df, 577
diff, 578
du, 573
echo, 586
f77, 562, 570, 571
file, 573
find, 580
finger, 586
grep, 581, 582, 593, 600, 601, 603
head, 581, 582
kill, 567, 568, 590, 609, 618
lint, 572
In, 580
lpr, 568, 587, 608
Is, 552–560, 564, 566, 567, 570, 571, 573–577, 579, 580, 589, 603, 606–609, 619
mail, 587
more, 553–556, 565, 579, 598, 605, 608, 619, 655
mv, 557, 558, 566, 578, 579, 619
nice, 570
passwd, 562, 581, 588, 605, 606
pipes, 560
process control, 567
ps, 567, 568
redirection, 559
rlogin, 588, 589
rm, 558, 564, 569, 571, 579, 580
sed, 557, 593, 599, 600, 620

sleep, 589
sort, 601, 603
spell, 565, 589, 593
stty, 557, 589, 590, 592, 618
tail, 582
tar, 553, 590
wc, 582, 583, 593
who, 562, 590
write, 591
unload, 362, 369, 431
unordered lists, 388, 389
upcase, 48, 49
URL, 387, 398, 405, 430, 443, 460
URLs, 437
USA, 477
V
var keyword, 106, 125, 420
variables, 81–85, 89, 96, 106–109, 111, 113, 114, 121, 152, 193, 197, 199, 201, 253, 275, 307, 309, 312,
418, 419, 420, 421, 429, 446, 552, 571, 605, 609, 610, 612–614, 655
initialization, 12
substitution, 609
velocity, 71, 72
version, 229, 230, 280, 310, 385, 438, 439, 440, 443, 464, 475, 476, 477, 487, 505, 506, 510, 530, 537,
541
VGA, 263, 530
video, 159, 281, 282, 288, 393, 411, 437
visible, 45
Visual Basic, 291–294, 296, 305, 307, 308, 310, 311, 317, 324, 327–329, 339, 345, 352, 361, 362, 371,
374
controls and events, 302
files, 292
form window, 296, 297
language, 305
menu bar, 294, 507
object box, 300

project window, 295, 296, 302, 306
properties window, 295, 297, 300, 301, 531
toolbox, 296, 298
visual editor, 567, 593, 597, 607–609, 614–616
example, 597
insert mode, 594, 595, 597, 598
substituting, 595
volatile, 12, 446
voltage, 23, 31, 39, 40, 61–63, 72, 73, 75, 76, 104, 216, 321, 337, 338, 339, 341, 422
W
WAV, 464
wavelength, 45, 46, 55
web, 415, 416, 437
Western Electric, 475
UNIX, 562
while(), 68, 145, 146, 428, 450
white, 212, 302, 387, 393, 399, 462
WIMPs, 505
WIN.INI, 541–543, 545
Window objects, 432
Windows
capturing a screen, 543
closing a window, 510, 534
deleting files, 518
desktop, 506
file extensions, 545
File manager, 513, 514, 515
formatting a disk, 515
help, 509, 533
main group, 513, 521
moving and resizing a window, 509, 533
moving files, 517
quitting, 508, 509, 533
running, 506, 519, 530

selecting a directory, 515
selecting a drive, 515
startup, 542
swapping, 543, 544
terminating programs, 544
Windows 3.x, 506, 525, 529, 541
Windows 95/NT, 159, 262, 263, 291, 476, 477, 505, 525, 526, 528, 529, 530, 531, 537, 541
DOS window, 513, 536, 539
Explorer, 531
My Computer, 531, 535, 537, 538
network neighborhood, 531, 537
start button, 531, 534
Windows NT, 159, 291, 438, 440, 476, 477, 487, 505, 525, 526, 527, 528, 530, 531, 537, 541
network drives, 537
WK3, 484
WMF, 293, 299, 371
word, 220
word processor, 159, 514
words, 60, 147, 173, 246, 446, 582, 584, 589, 593, 594, 620
workgroups, 526, 527
worksheet, 18, 37, 39, 56, 57, 67, 79, 104, 118, 139, 156, 174, 188, 487, 499
workstation, 437, 526, 528, 549
workstations, 525, 549
WP, 488
Writing to files, 165
WWW, 191, 385, 386, 387, 389–398, 401, 411, 413, 415, 417, 437, 438
X
X
xterm, 557
X/Open, 549
XOR, 247, 424, 653
Z
Zilog, 229, 476

ZIP, 411, 442, 492

