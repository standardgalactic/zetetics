arXiv:1102.1889v2  [cs.LO]  7 Aug 2011
OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE
REPRESENTATION
DAVID I. SPIVAK AND ROBERT E. KENT
Abstract. In this paper we introduce the olog, or ontology log, a category-
theoretic model for knowledge representation (KR). Grounded in formal math-
ematics, ologs can be rigorously formulated and cross-compared in ways that
other KR models (such as semantic networks) cannot. An olog is similar to
a relational database schema; in fact an olog can serve as a data repository
if desired. Unlike database schemas, which are generally diÔ¨Écult to create or
modify, ologs are designed to be user-friendly enough that authoring or re-
conÔ¨Åguring an olog is a matter of course rather than a diÔ¨Écult chore. It is
hoped that learning to author ologs is much simpler than learning a database
deÔ¨Ånition language, despite their similarity. We describe ologs carefully and
illustrate with many examples. As an application we show that any primitive
recursive function can be described by an olog. We also show that ologs can
be aligned or connected together into a larger network using functors. The
various methods of information Ô¨Çow and institutions can then be used to in-
tegrate local and global world-views. We Ô¨Ånish by providing several diÔ¨Äerent
avenues for future research.
Contents
1.
Introduction
1
2.
Types, aspects, and facts
6
3.
Instances
14
4.
Communication between ologs
17
5.
More expressive ologs I
31
6.
More expressive ologs II
40
7.
Further directions
48
References
50
1. Introduction
Scientists have a pressing need to organize their experiments, their data, their
results, and their conclusions into a framework such that this work is reusable,
transferable, and comparable with the work of other scientists.
In this paper,
we will discuss the ‚Äúontology log‚Äù or olog as a possibility for such a framework.
Ontology is the study of what something is, i.e the nature of a given subject, and
ologs are designed to record the results of such a study. The structure of ologs is
This project was supported by OÔ¨Éce of Naval Research grant: N000141010841 and a gener-
ous contribution by Clark Barwick, Jacob Lurie, and the Massachusetts Institute of Technology
Department of Mathematics.
1

2
DAVID I. SPIVAK AND ROBERT E. KENT
based on a branch of mathematics called category theory. An olog is roughly a
category that models a given real-world situation.
The main advantages of authoring an olog rather than writing a prose description
of a subject are that
‚Ä¢ an olog gives a precise formulation of a conceptual world-view,
‚Ä¢ an olog can be formulaically converted into a database schema,
‚Ä¢ an olog can be extended as new information is obtained,
‚Ä¢ an olog written by one author can be easily and precisely referenced by
others,
‚Ä¢ an olog can be input into a computer and ‚Äúmeaningfully stored‚Äù, and
‚Ä¢ diÔ¨Äerent ologs can be compared by functors, which in turn generate auto-
matic terminology translation systems.
The main disadvantage to using ologs over prose, aside from taking more space on
the page, is that writing a good olog demands a clarity of thought that ordinary
writing or conversation can more easily elide. However, the contemplation required
to write a good olog about a subject may have unexpected beneÔ¨Åts as well.
A category is a mathematical structure that appears much like a directed graph:
it consists of objects (often drawn as nodes or dots, but here drawn as boxes) and
arrows between them. The feature of categories that distinguishes them from graphs
is the ability to declare an equivalence relation on the set of paths. A functor is a
mapping from one category to another that preserves the structure (i.e. the nodes,
the arrows, and the equivalences). If one views a category as a kind of language (as
we shall in this paper) then a functor would act as a kind of translating dictionary
between languages. There are many good references on category theory, including
[LS], [Sic], [Pie], [BW1], [Awo], and [Mac]; the Ô¨Årst and second are suited for general
audiences, the third and fourth are suited for computer scientists, and the Ô¨Åfth and
sixth are suited for mathematicians (in each class the Ô¨Årst reference is easier than
the second).
A basic olog, deÔ¨Åned in Section 2, is a category in which the objects and ar-
rows have been labeled by English-language phrases that indicate their intended
meaning. The objects represent types of things, the arrows represent functional
relationships (also known as aspects, attributes, or observables), and the commu-
tative diagrams represent facts. Here is a simple olog about an amino acid called
arginine ([W]):
D
an amino acid
found in dairy
is
&L
L
L
L
L
L
L
L
L
L
L
A
arginine
has
/
is
o
is

E
an electrically-
charged side
chain
is

X
an amino acid
has
wooooooooooo
has
'O
O
O
O
O
O
O
O
O
O
O
has
/
R
a side chain
N
an amine group
C
a carboxylic acid
(1)

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
3
The idea of representing information in a graph is not new. For example the
Resource Descriptive Framework (RDF) is a system for doing just that [CM]. The
key diÔ¨Äerence between a category and a graph is the consideration of paths, and
that two paths from A to B may be declared identical in a category (see [Spi3]).
For example, we can further declare that in Diagram (1), the diagram
A
/

E

X
/ R
(2)
commutes, i.e. that the two paths A
*4R are equivalent, which can be translated
as follows. Let A be a molecule of arginine. On the one hand A, being an amino
acid, has a side chain; on the other hand A has an electrically-charged side-chain,
which is of course a side chain. We seem to have associated two side-chains to A,
but in fact they both refer to the same physical thing, the same side-chain. Thus,
the two paths A ‚ÜíR are deemed equivalent. The fact that this equivalence may
seem trivial is not an indictment of the category idea but instead reinforces its
importance ‚Äî we must be able to indicate obvious facts within a given situation
because what is obvious is the most essential.
While many situations can be modeled using basic ologs (categories), we often
need to encode more structure. For this we will need so-called sketches. An olog
will be deÔ¨Åned as a Ô¨Ånite limit, Ô¨Ånite colimit sketch (see [BW2]), meaning we have
the ability to encode objects (‚Äútypes‚Äù), arrows (‚Äúaspects‚Äù), commutative diagrams
(‚Äúfacts‚Äù), as well as Ô¨Ånite limits (‚Äúlayouts‚Äù) and Ô¨Ånite colimits (‚Äúgroupings‚Äù).
Throughout this paper, whenever we refer to ‚Äúthe author‚Äù of an olog we am
referring to the Ô¨Åctitious person who created it. We will refer to ourselves, David
Spivak and Robert Kent, as ‚Äúwe‚Äù so as not to confuse things.
Warning 1.0.1. The author of an olog has a world-view, some fragment of which is
captured in the olog. When person A examines the olog of person B, person A may
or may not ‚Äúagree with it.‚Äù For example, person B may have the following olog
a marriage
includes
&N
N
N
N
N
N
N
N
N
N
N
includes
xrrrrrrrrrr
a man
a woman
which associates to each marriage a man and a woman. Person A may take the
position that some marriages involve two men or two women, and thus see B‚Äôs olog
as ‚Äúwrong.‚Äù Such disputes are not ‚Äúproblems‚Äù with either A‚Äôs olog or B‚Äôs olog, they
are discrepancies between world-views. Hence, throughout this paper, a reader R
may see a displayed olog and notice a discrepancy between R‚Äôs world-view and our
own, but R should not worry that this is a problem. This is not to say that ologs
need not follow rules, but instead that the rules are enforced to ensure that an olog
is structurally sound, rather than that it ‚Äúcorrectly reÔ¨Çects reality,‚Äù whatever that
may mean.
1.1. Plan of this paper. In this paper, we will deÔ¨Åne ologs and give several
examples. We will state some rules of ‚Äúgood practice‚Äù which help one to author ologs

4
DAVID I. SPIVAK AND ROBERT E. KENT
that are meaningful to others and easily extendable. We will begin in Section 2 by
laying out the basics: types as objects, aspects as arrows, and facts as commutative
diagrams. In Section 3, we will explain how to attach ‚Äúinstance‚Äù data to an olog and
hence realize ologs as database schemas. In Section 4, we will discuss meaningful
constraints betweeen ologs that allow us to develop a higher-dimensional web of
information called an information system, and we will discuss how the various
parts of such a system interact via information channels. In Sections 5 and 6, we
will extend the olog deÔ¨Ånition language to include ‚Äúlayouts‚Äù and ‚Äúgroupings‚Äù, which
make for more expressive ologs; we will also describe two applications, one which
explicates the computation of the factorial function, and the other which deÔ¨Ånes a
notion from pure mathematics (that of pseudo-metric spaces). Finally, in Section
7, we will discuss some possible directions for future research.
For the remainder of the present section, we will explain how ologs relate to
existing ideas in the Ô¨Åeld of knowledge representation.
1.2. The semantic advantage of ologs: modularity. The diÔ¨Äerence between
ologs and prose is modularity: small conceptual pieces can form large ideas, and
these pieces work best when they are reusable.
The same phenomenon is true
throughout computer science and mathematics. In programming languages, mod-
ularity brings not only vast eÔ¨Éciency to the writing of programs but enables an
‚Äúabstraction barrier‚Äù that keeps the ideas clean. In mathematics, the most powerful
results are often simple lemmas that are reusable in a wide variety of circumstances.
Web pages that consist of prose writing are often referred to as information silos.
The idea is that a silo is a ‚Äúbig tube of stuÔ¨Ä‚Äù which is not organized in any real
way. Links between web pages provide some structure, but such a link does not
carry with it a precise method to correlate the information within the two pages.
Similarly in science, one author may reference another paper, but such a reference
carries very little structure ‚Äî it just points to a silo.
Ologs can be connected with links which are much richer than the link between
two silos could possibly be. Individual concepts and connections within one olog
can be ‚Äúfunctorially aligned‚Äù with concepts and connections in another. A functor
creates a precise connection between the work of one author and the work of another
so that the precise nature of the comparison is not left to the reader‚Äôs imagination
but explicitly speciÔ¨Åed. The ability to incorporate mathematical precision into the
sharing of ideas is a central feature of ologs.
1.3. Relation to other models. There are many languages for knowledge repre-
sentation (KR). For example, there are database languages such as SQL, ontology
languages such as RDF and OWL, the language of Semantic Nets, and others (see
[Bor]).
One may ask what makes the olog concept diÔ¨Äerent or better than the
others.
The Ô¨Årst response is that ologs are closely related to the above ideas. Indeed, all
of these KR models can be ‚ÄúcategoriÔ¨Åed‚Äù (i.e. phrased in the language of category
theory) and related by functors, so that many of the ideas align and can be trans-
ferred between the diÔ¨Äerent systems. In fact, as we will make clear in Section 3,
ologs are almost identical to the categorical model of databases presented in [Spi2].
However, ologs have advantages over many existing KR models. The Ô¨Årst ad-
vantage arises from the notion of commutative diagrams (which allow us to equate
diÔ¨Äerent paths through the domain, see Section 2.3) and of limits and colimits

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
5
(which allow us to lay out and group things, see Sections 5 and 6). The additional
expressivity of ologs give them a certain semantic clarity and interoperability that
cannot be achieved with graphs and networks in the usual sense. The second ad-
vantage arises from the notion of olog morphisms, which allow the deÔ¨Ånition of
meaningful constraints between ologs. With this in hand, we can integrate a set
of similar ologs into a single information system, and go on to deÔ¨Åne information
fusion. This will be discussed further Section 4.
In the remainder of this section we will provide a few more details on the relation-
ship between ologs and each of the above KR models: databases, RDF/OWL, and
semantic nets. The reader who does not know or care much about other systems
of knowledge representation can skip to Section 1.4.
1.3.1. Ologs and Databases. A database is a system of tables, each table of which
consists of a header of columns and a set of rows. A table represents a type of thing
T , each column represents an attribute of T , and each row represents an example
of T . An attribute is itself a ‚Äútype of thing‚Äù, so each column of a table points to
another table.
The relationship between ologs and databases is that every box B in an olog
represents a type of thing and every arrow B ‚ÜíX emanating from B represents
an attribute of B (whose results are of type X). Thus the boxes and arrows in an
olog correspond to tables and their columns in a database. The rows of each table
in a database will correspond to ‚Äúinstances‚Äù of each type in an olog. Again, this
will be made more clear in Section 3 or one can see [Spi2] or [Ken5].
The point is that every olog can serve as a database schema, and the schemas
represented by ologs range from simple (just objects and arrows) to complex (in-
cluding commutative diagrams, products, sums, etc.). However, whereas database
schemas are often prescriptive (‚Äúyou must put your data into this format!‚Äù), ologs
are usually descriptive (‚Äúthis is how I see things‚Äù). One can think of an olog as
an interface between people and databases: an olog is human readable, but it is
also easily converted to a database schema upon which powerful applications can
be put to work. Of course, if one is to use an olog as a database schema, it will
become prescriptive. However, since the intention of each object and arrow is well-
documented (as its label), schema evolution would be straightforward. Moreover,
the categorical structure of ologs allows for functorial data migration by which one
can transfer the instance data from an older schema to the current one (see [Spi2]).
1.3.2. Ologs and RDF / OWL. In [Spi2], the Ô¨Årst author explained how a categor-
ical database can be converted into an RDF triple store using the Grothendieck
construction. The main diÔ¨Äerence between a categorical database schema (or an
olog) and an RDF schema is that one cannot specify commutativity in an RDF
schema. Thus one cannot express things like ‚Äúthe woman parent of a person x is
the mother of x.‚Äù Without this expressivity, it is hard to enforce much rigor, and
thus RDF data tends to be too loose for many applications.
OWL schemas, on the other hand, can express many more constraints on classes
and properties. We have not yet explored the connection, nor compared the expres-
sive power, of ologs and OWL. However, they are signiÔ¨Åcantly diÔ¨Äerent systems,
most obviously in that OWL relies on logic where ologs rely on category theory.
1.3.3. Semantic Nets. On the surface, ologs look the most like semantic networks,
or concept webs, but there are important diÔ¨Äerences between the two notions. First,

6
DAVID I. SPIVAK AND ROBERT E. KENT
arrows in a semantic network need not indicate functions; they can be relations. So
there could be an arrow ‚åúa father‚åù
has
‚àí‚àí‚Üí‚åúa child‚åùin a semantic network, but not in
an olog (see Section 2.2.3 for how the same idea is expressible in an olog). There is
a nice category of sets and relations, often denoted Rel, but this category is harder
to reason about than is the ordinary category of sets and functions (often denoted
Set). Thus, as mentioned above, semantic networks are categoriÔ¨Åable (using Rel),
but this underlying formalism does not appear to play a part in the study or use
of semantic networks. However, some attempt to integrate category theory and
neural nets has been made, see [HC].
Moreover, commutative diagrams and other expressive abilities held by ologs are
not generally part of the semantic network concept (see [Sow1]). For these reasons,
semantic networks tend to be brittle: minor changes can have devastating eÔ¨Äects.
For example, if two semantic networks are somehow synced up and then one is
changed, the linkage must be revised or may be altogether broken. Such a disaster
is often avoided if one uses categories: because diÔ¨Äerent paths can be equivalent,
one can simply add new ideas (types and aspects) without changing the semantic
meaning of what was already there. As section 4.4 demonstates with an extended
example, conceptual graphs, which are a popular formalism for semantics nets, can
be linearized to ologs, thereby gaining in precision and expressibility.
1.4. Acknowledgements.
1.4.1. David Spivak‚Äôs acknowledgments. I would like to thank Mathieu Anel and
Henrik Forssell for many pleasant and quite useful conversations.
I would also
like to thank Micha Breakstone for his help on understanding the relationship be-
tween ologs and linguistics. Finally I would like to thank Dave Balaban for helpful
suggestions on this document itself.
1.4.2. Robert Kent‚Äôs acknowledgments. I would like to thank the participants in the
Standard Upper Ontology working group for many interesting, spirited, rewarding
and enlightening discussions about knowledge representation in general and ontolo-
gies in particular; I especially want to thank Leo Obrst, Marco Schorlemmer and
John Sowa from that group. I want to thank Jon Barwise for leading the develop-
ment of the theory of information Ô¨Çow. I want to thank Joseph Goguen for leading
the development of the theory of institutions, and for pointing out the common ap-
proach to knowledge representation used by both the Information Flow Framework
and the theory of institutions.
2. Types, aspects, and facts
In this section we will explain basic ologs, which involve types, aspects, and facts.
A basic olog is a category in which each object and arrow has been labeled by text;
throughout this paper we will assume that text to be written in English.
The purpose of this section is to show how one can convert a real-world situation
into an olog. It is probably impossible to explain this process precisely in words.
Instead, we will explain mainly by example. We will give ‚Äúrules of good practice‚Äù
that lead to good ologs. While these rules are not strictly necessary, they help to
ensure that the olog is properly formulated. As the Dalai Lama says, ‚ÄúLearn the
rules so you know how to break them properly.‚Äù

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
7
2.1. Types. A type is an abstract concept, a distinction the author has made. We
represent each type as a box containing a singular indeÔ¨Ånite noun phrase. Each of
the following four boxes is a type:
a man
an automobile
a pair (a, w), where w is
a woman and a is an au-
tomobile
a pair (a, w) where w is
a woman and a is a blue
automobile owned by w
(3)
Each of the four boxes in (3) represents a type of thing, a whole class of things,
and the label on that box is what one should call each example of that class. Thus
‚åúa man‚åùdoes not represent a single man, but the set of men, each example of
which is called ‚Äúa man‚Äù1. Similarly, the bottom right-hand box in (3) represents
an abstract type of thing, which probably has more than a million examples, but
the label on the box indicates a common name for each such example.
Typographical problems emerge when writing a text-box in a line of text, e.g.
the text-box a man seems out of place here, and the more in-line text-boxes one
has in a given paragraph, the worse it gets. To remedy this, we will denote types
which occur in a line of text with corner-symbols, e.g. we will write ‚åúa man‚åùinstead
of a man .
2.1.1. Types with compound structures. Many types have compound structures; i.e.
they are composed of smaller units. Examples include
a man and
a woman
a food f and a child c
such that c ate all of f
a triple (p, a, j) where p is
a paper, a is an author of
p, and j is a journal in
which p was published
(4)
It is good practice to declare the variables in a ‚Äúcompound type‚Äù, as we did in the
last two cases of (4). In other words, it is preferable to replace the Ô¨Årst box above
with something like
a man m and
a woman w
or
a pair (m, w)
where m is a man
and w is a woman
so that the variables (m, w) are clear.
Rules of good practice 2.1.1. A type is presented as a text box. The text in that
box should
(i) begin with the word ‚Äúa‚Äù or ‚Äúan‚Äù;
(ii) refer to a distinction made and recognizable by the author;
(iii) refer to a distinction for which instances can be documented;
(iv) not end in a punctuation mark;
1In other words, types in ologs are intentional, rather than extensional ‚Äî the label on a type
describes its intention. The extension of a type will be captured by instance data; see Section 3 .

8
DAVID I. SPIVAK AND ROBERT E. KENT
(v) declare all variables in a compound structure.
The Ô¨Årst, second, and third rules ensure that the class of things represented
by each box appears to the author as a well-deÔ¨Åned set; see Section 3 for more
details. The fourth and Ô¨Åfth rules encourage good ‚Äúreadability‚Äù of arrows, as will
be discussed next in Section 2.2.
We will not always follow the rules of good practice throughout this document.
We think of these rules being followed ‚Äúin the background‚Äù but that we have ‚Äúnick-
named‚Äù various boxes. So ‚åúSteve‚åùmay stand as a nickname for ‚åúa thing classiÔ¨Åed
as Steve‚åùand ‚åúarginine‚åùas a nickname for ‚åúa molecule of arginine‚åù.
2.2. Aspects. An aspect of a thing x is a way of viewing it, a particular way in
which x can be regarded or measured. For example, a woman can be regarded as
a person; hence ‚Äúbeing a person‚Äù is an aspect of a woman. A man has a height
(say, taken in inches), so ‚Äúhaving a height (in inches)‚Äù is an aspect of a man. In
an olog, an aspect of A is represented by an arrow A ‚ÜíB, where B is the set of
possible ‚Äúanswers‚Äù or results of the measurement. For example when observing the
height of a man, the set of possible results is the set of integers, or perhaps the set
of integers between 20 and 120.
a woman
is
/ a person
(5)
a man
has as height (in inches)/ an integer between 20 and 120
(6)
We will formalize the notion of aspect by saying that aspects are functional
relationships.2 Suppose we wish to say that a thing classiÔ¨Åed as X has an aspect
f whose result set is Y .
This means there is a functional relationship called f
between X and Y , which can be denoted f : X ‚ÜíY . We call X the domain of
deÔ¨Ånition for the aspect f, and we call Y the set of result values for f. For example,
a man has a height in inches whose result is an integer, and we could denote this
by h: M ‚ÜíInt. Here, M is the domain of deÔ¨Ånition for height and Int is the set
of result values.
A set may always be drawn as a blob with dots in it. If X and Y are two sets,
then a a function from X to Y , denoted f : X ‚ÜíY can be presented by drawing
arrows from dots in blob X to dots in blob Y . There are two rules:
(i) each arrow must emanate from a dot in X and point to a dot in Y ;
(ii) each dot in X must have precisely one arrow emanating from it.
Given an element x ‚ààX, the arrow emanating from it points to some element
y ‚ààY , which we call the image of x under f and denote f(x) = y.
Again, in an olog, an aspect of a thing X is drawn as a labeled arrow point-
ing from X to a ‚Äúset of result values.‚Äù Let us concentrate brieÔ¨Çy on the arrow in
(5). The domain of deÔ¨Ånition is the set of women (a set with perhaps 3 billion
elements); the set of result values is the set of persons (a set with perhaps 6 billion
elements). We can imagine drawing an arrow from each dot in the ‚Äúwoman‚Äù set to
a unique dot in the ‚Äúperson‚Äù set. No woman points to two diÔ¨Äerent people, nor to
zero people ‚Äî each woman is exactly one person ‚Äî so the rules for a functional
relationship are satisÔ¨Åed. Let us now concentrate brieÔ¨Çy on the arrow in (6). The
2In type theory, what we here call aspects are called functions. Since our types are not Ô¨Åxed
sets (see Section 3), we preferred a term that was less formal.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
9
domain of deÔ¨Ånition is the set of men, the set of result values is the set of integers
{20, 21, 22, . . ., 119, 120}. We can imagine drawing an arrow from each dot in the
‚Äúman‚Äù set to a single dot in the ‚Äúinteger‚Äù set.
No man points to two diÔ¨Äerent
heights, nor can a man have no height: each man has exactly one height. Note
however that two diÔ¨Äerent men can point to the same height.
2.2.1. Invalid aspects. We tried above to clarify what it is that makes an aspect
‚Äúvalid‚Äù, namely that it must be a ‚Äúfunctional relationship.‚Äù In this subsection we
will present two arrows which on their face may appear to be aspects, but which
on closer inspection are not functional (and hence are not valid as aspects).
Consider the following two arrows:
a person
has / a child
(7*)
a mechanical pencil
uses / a piece of lead
(8*)
A person may have no children or may have more than one child, so the Ô¨Årst arrow
is invalid: it is not functional because it does not satisfy rule (2) above. Similarly,
if we drew an arrow from each mechanical pencil to each piece of lead it uses, it
would not satisfy rule (2) above. Thus neither of these is a valid aspect.
Of course, in keeping with Warning 1.0.1, the above arrows may not be wrong
but simply reÔ¨Çect that the author has a strange world-view or a strange vocabulary.
Maybe the author believes that every mechanical pencil uses exactly one piece of
lead. If this is so, then ‚åúa mechanical pencil‚åù
uses
‚àí‚àí‚Üí‚åúa piece of lead‚åùis indeed a
valid aspect! Similarly, suppose the author meant to say that each person was once
a child, or that a person has an inner child. Since every person has one and only one
inner child (according to the author), the map ‚åúa person‚åù
has as inner child
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí‚åúa child‚åù
is a valid aspect. We cannot fault the author for such a view, but note that we
have changed the name of the label to make its intention more explicit.
2.2.2. Reading aspects and paths as English phrases. Each arrow (aspect) X
f‚àí‚ÜíY
can be read by Ô¨Årst reading the label on its source box (domain of deÔ¨Ånition) X,
then the label on the arrow f, and Ô¨Ånally the label on its target box (set of result
values) Y . For example, the arrow
a book
has as Ô¨Årst author
/ a person
(9)
is read ‚Äúa book has as Ô¨Årst author a person‚Äù, a valid English sentence.
Sometimes the label on an arrow can be shortened or dropped altogether if it
is obvious from context. We will discuss this more in Section 2.3 but here is a

10
DAVID I. SPIVAK AND ROBERT E. KENT
common example from the way we write ologs.
A
a pair (x, y) where
x and y are integers
x
xqqqqqqqqqq
y
&M
M
M
M
M
M
M
M
M
M
B
an integer
B
an integer
(10)
Neither arrow is readable by the protocol given above (e.g. ‚Äúa pair (x, y) where x
and y are integers x an integer‚Äù is not an English sentence), and yet it is obvious
what each map means. For example, given the pair (8, 11) which belongs in box A,
application of arrow x would yield 8 in box B. The label x can be thought of as a
nickname for the full name ‚Äúyields, via the value of x,‚Äù and similarly for y. We do
not generally use the full name for fear that the olog would become cluttered with
text.
One can also read paths through an olog by inserting the word ‚Äúwhich‚Äù after
each intermediate box. For example the following olog has two paths of length 3
(counting arrows in a chain):
a child
is
/ a person
has as parents
/
has, as birthday
!D
D
D
D
D
D
D
D
D
D
D
D
a pair (w, m)
where w is a
woman and m
is a man
w
/ a woman
a date
includes / a year
(11)
The top path is read ‚Äúa child is a person, which has as parents a pair (w, m) where
w is a woman and m is a man, which yields, via the value of w, a woman.‚Äù The
reader should read and understand the content of the bottom path.
2.2.3. Converting non-functional relationships to aspects. There are many rela-
tionships that are not functional, and these cannot be considered aspects.
Of-
ten the word ‚Äúhas‚Äù indicates a relationship ‚Äî sometimes it is functional as in
‚åúa person‚åù
has
‚àí‚àí‚àí‚Üí‚åúa stomach‚åù, and sometimes it is not, as in ‚åúa father‚åù
has
‚àí‚àí‚Üí
‚åúa child‚åù. (Obviously, a father may have more than one child.) A quick Ô¨Åx would
be to replace the latter by ‚åúa father‚åù
has
‚àí‚àí‚Üí‚åúa set of children‚åù. This is ok, but the
relationship between ‚åúa child‚åùand ‚åúa set of children‚åùthen becomes an issue to deal
with later. There is another way to indicate such ‚Äúnon-functional‚Äù relationships.
In mathematics, a relation between sets A1, A2, and so on through An is deÔ¨Åned
to be a subset of the Cartesian product
R ‚äÜA1 √ó A2 √ó ¬∑ ¬∑ ¬∑ √ó An.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
11
The set R represents those sequences (a1, a2, . . . , an) that are so-related. In an olog,
we represent this as follows
R
{xxxxxxxxxxxxxxxxxxx

3333333333333
A1
A2
¬∑ ¬∑ ¬∑
An
For example,
R
a sequence (p, a, j) where p
is a paper, a is an author
of p, and j is a journal in
which p was published
p
}{{{{{{{{{{{{{{{{
a

j
!C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
A1
a paper
A2
an author
A3
a journal
Whereas A1 √ó A2 √ó A3 includes all possible triples (p, a, j) where a is a person, p
is a paper, and j is a journal, it is obvious that not all such triples are found in R.
Thus R represents a proper subset of A1 √ó A2 √ó A3.
Rules of good practice 2.2.1. An aspect is presented as a labeled arrow, pointing
from a source box to a target box. The arrow text should
(i) begin with a verb;
(ii) yield an English sentence, when the source-box text followed by the arrow
text followed by the target-box text is read;
(iii) refer to a functional dependence: each instance of the source type should give
rise to a speciÔ¨Åc instance of the target type;
2.3. Facts. In this section we will discuss facts and their relationship to ‚Äúpath
equivalences.‚Äù It is such path equivalences, which exist in categories but do not
exist in graphs, that make category theory so powerful. See [Spi3] for details.

12
DAVID I. SPIVAK AND ROBERT E. KENT
Given an olog, the author may want to declare that two paths are equivalent.
For example consider the two paths from A to C in the olog
A
a person
has as parents /
has as mother
&M
M
M
M
M
M
M
M
M
M
M
M
M
M
M
M
B
a pair (w, m)
where w is a
woman and
m is a man
‚úì
w

C
a woman
(12)
We know as English speakers that a woman parent is called a mother, so these two
paths A ‚ÜíC should be equivalent. A more mathematical way to say this is that
the triangle in Olog (12) commutes.
A commutative diagram is a graph with some declared path equivalences. In
the example above we concisely say ‚Äúa woman parent is equivalent to a mother.‚Äù
We declare this by deÔ¨Åning the diagonal map in (12) to be the composition of the
horizontal map and the vertical map.
We generally prefer to indicate a commutative diagram by drawing a check-mark,
‚úì, in the region bounded by the two paths, as in Olog (12). Sometimes, however,
one cannot do this unambiguously on the 2-dimensional page. In such a case we
will indicate the commutative diagrams (fact) by writing an equation. For example
to say that the diagram
A
f
/
h

B
g

C
i
/ D
commutes, we could either draw a checkmark inside the square or write the equation
f; g = h; i above it. Either way, it means that ‚Äúf then g‚Äù is equivalent to ‚Äúh then
i‚Äù.
2.3.1. More complex facts. Recording real-world facts in an olog can require some
creativity. Whereas a fact like ‚Äúthe brother of ones father is ones uncle‚Äù is recorded
as a simple commutative diagram, others are not so simple. We will try to show
the range of expressivity of commutative diagrams in the following two examples.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
13
Example 2.3.2. How would one record a fact like ‚Äúa truck weighs more than a car‚Äù?
We suggest something like this:
B1
a truck
is
/
‚úì
C
a physical
object
A
a truck t and a car c
t
:v
v
v
v
v
v
v
v
v
v
v
c
$H
H
H
H
H
H
H
H
H
H
H
t7‚Üíx, c7‚Üíy
/
D
a pair (x, y) where
x and y are phys-
ical objects and x
weighs more than y
x
dJJJ
yzttt
B2
a car
is
/
‚úì
C
a physical
object
where both top and bottom commute. This olog exempliÔ¨Åes the fact that simple
sentences sometimes contain large amounts of information. While the long map
may seem to suÔ¨Éce to convey the idea ‚Äúa truck weighs more than a car,‚Äù the path
equivalences (declared by check-marks) serve to ground the idea in more basic types.
These other types tend to be useful for other purposes, both within the olog and
when connecting it to others.
2.3.3. SpeciÔ¨Åc facts at the olog level. Another fact one might wish to record is that
‚ÄúJohn Doe‚Äôs weight is 150 lbs.‚Äù This is established by declaring that the following
diagram commutes:
John Doe
‚úì
has as weight (in pounds)
/
is

150
is

a person
has as weight (in pounds)/ a real number
(13)
If one only had the top line, it would be less obvious how to connect its information
with that of other ologs. (See Section 4 for more on connecting diÔ¨Äerent ologs).
Note that the top line in Diagram (13) might also be considered as existing at
the ‚Äúdata level‚Äù rather than at the ‚Äúolog level.‚Äù In other words, one could see John
Doe as an ‚Äúinstance‚Äù of ‚åúa person‚åù, rather than as a type in and of itself, and
similarly see 150 as an instance of ‚åúa real number‚åù. This idea of an olog having a
‚Äúdata level‚Äù is the subject of the Section 3.
Rules of good practice 2.3.4. A fact is the declaration that two paths (having the
same source and target) in an olog are equivalent. Such a fact is either presented
as a checkmark between the two paths (if such a check-mark is unambiguous) or
by an equation. Every such equivalence should be declared; i.e. no fact should be
considered too obvious to declare.

14
DAVID I. SPIVAK AND ROBERT E. KENT
3. Instances
The reader at this point hopefully sees an olog as a kind of ‚Äúconcept map,‚Äù and
it is one, albeit a concept map with a formal structure (implicitly coming from
category theory) and speciÔ¨Åc rules of good practice. In this section we will show
that one can also load an olog with data.
Each type can be assigned a set of
instances, each aspect will map the instances of one type to instances of the other,
and each fact will equate two such mappings. We give examples of these ideas in
Section 3.1.
In Section 3.2, we will show that in fact every olog can also serve as the layout for
a database. In other words, given an olog one can immediately generate a database
schema, i.e. a system of tables, in any reasonable data deÔ¨Ånition language such
as that of SQL. The tables in this database will be in one-to-one correspondence
with the types in the olog. The columns of a given table will be the aspects of
the corresponding type, i.e. the arrows whose source is that type. Commutative
diagrams in the olog will give constraints on the data.
In fact, this idea is the basic thesis in [Spi2], even though the word olog does
not appear in that paper. There it was explained that a category C naturally can
be viewed as a database schema and that a functor I : C ‚ÜíSet, where Set is the
category of sets, is a database state. Since an olog is a drawing of a category, it is
also a drawing of a database schema. The current section is about the ‚Äústates‚Äù of
an olog, i.e. the kinds of data that can be captured by it.
3.1. Instances of types, aspects, and facts. Recall from Section 2 that basic
ologs consist of types, displayed as boxes; aspects, displayed as arrows; and facts,
displayed as equations or check-marks. In this section we discuss the instances of
these three basic constructions. The rules of good practice (2.1.1, 2.2.1, and 2.3.4)
were speciÔ¨Åcally designed to simplify the process of Ô¨Ånding instances.
3.1.1. Instances of types. According to Rules 2.1.1, each box in an olog contains
text which should refer to a distinction made and recognizable by the author
for which instances can be documented. For example if my olog contains a
box
a pair (p, c) where p
is a person, c is a cat,
and p has petted c
(14)
then I must have some concept of when this situation occurs. Every time I witness
a new person-cat petting, I document it. Whether this is done in my mind, in
a ledger notebook, or on a computer does not matter; however using a computer
would probably be the most self-explanatory. Imagine a computer program in which
one can create ologs. Clicking a text box in an olog results in it ‚Äúopening up‚Äù to
show a list of documented instances of that type. If one is reading the CBS news
olog and clicks on the box ‚åúan episode of 60 Minutes‚åù, he or she should see a list of
all episodes of the TV show ‚Äú60 Minutes.‚Äù If we wish to document a new person-cat
petting incident we click on the box in (14) and add this new instance.
3.1.2. Instances of aspects. According to Rules 2.2.1, each arrow in an olog should
be labeled with text that refers to a functional relationship between the source box
and the target box. A functional relationship f : A ‚ÜíB between Ô¨Ånite sets A and
B can always be written as a 2-column table: the Ô¨Årst column is Ô¨Ålled with the

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
15
instances of type A and the second column is Ô¨Ålled with their f-values, which are
instances of type B.
For example, consider the aspect
a moon
orbits
‚àí‚àí‚àí‚Üía planet
(15)
We can document some instances of this relationship using the following table:
orbits
a moon
a planet
The Moon
Earth
Phobos
Mars
Deimos
Mars
Ganymede
Jupiter
Titan
Saturn
(16)
Clearly, this table of instances can be updated as more moons are discovered by
the author (be it by telescope, conversation, or research).
The correspondence between aspect (15) and Table (16) makes it clear that ologs
can serve to hold data which exempliÔ¨Åes the author‚Äôs world-view. In Section 3.2,
we will show that ologs (which have many aspects and facts) can serve as bona Ô¨Åde
database schemas.
3.1.3. Instances of facts. Recall the following olog:
A
a person
has as parents /
has as mother
&M
M
M
M
M
M
M
M
M
M
M
M
M
M
M
M
B
a pair (w, m)
where w is a
woman and
m is a man
‚úì
w

C
a woman
(12)
and consider the following instances of the three aspects in it:
has as parents
a person
a pair (w, m) ...
Cain
(Eve, Adam)
Abel
(Eve, Adam)
Chelsey
(Hillary, Bill)
w
a pair (w, m) ...
a woman
(Eve, Adam)
Eve
(Hillary, Bill)
Hillary
(Margaret, Samuel)
Margaret
(Emily, Kris)
Emily
(17)
has as mother
a person
a woman
Cain
Eve
Abel
Eve
Chelsey
Hillary
When we declare that the diagram in (12) commutes (using the check-mark),
we are saying that for every instance of ‚åúa person‚åù(of which we have three: Cain,

16
DAVID I. SPIVAK AND ROBERT E. KENT
Abel, and Chelsey), the two paths to ‚åúa woman‚åùgive the same answers. Indeed,
for Cain the two paths are:
(i) Cain 7‚Üí(Eve, Adam) 7‚ÜíEve;
(ii) Cain 7‚ÜíEve;
and these answers agree. If one changed any instance of the word ‚ÄúEve‚Äù to the word
‚ÄúSteve‚Äù in one of the tables in (17), some pair of paths would fail to agree. Thus
the ‚Äúfact‚Äù that the diagram in (12) commutes ensures that there is some internal
consistency between the meaning of parents and the meaning of mother, and this
consistency must be born out at the instance level.
All of this will be formalized in Section 3.2.2.
3.2. The relationship between ologs and databases. Recall from Section 3.1.1
that we can imagine creating an olog on a computer. The user creates boxes, arrows,
and compositions, hence creating a category C. Each text-box x in the olog can
be ‚Äúclicked‚Äù by the computer mouse, an action which allows the user to ‚Äúview the
contents‚Äù of x. The result will be a set of things, which we might call I(x) ‚ààSet,
whose elements are things of type x. So clicking on the box ‚åúa man‚åùone sees
I(‚åúa man‚åù), the set of everything the author has documented as being a man. For
each aspect f : x ‚Üíy of x, the user can see a function from the set I(x) to I(y),
perhaps as a 2-column table as in (17).
The type x may have many aspects, which we can put together into a single
multi-column table. Its columns are the aspects of x, and its rows are the elements
of I(x). Consider the following olog, taken from [Spi2] where it was presented as a
database schema.
employee
works in
/
manager

Ô¨Årst name

last name

department
secretary
o
name
u
string
(18)
The type ‚åúEmployee‚åùhas four aspects, namely manager (valued in ‚åúEmployee‚åù),
works in (valued in ‚åúdepartment‚åù), and first name and last name (valued in
‚åústring‚åù). As a database, each type together with its aspects form a multi-column
table, as in the following example.
Example 3.2.1. We can convert Olog (18) into a database schema. Each box rep-
resents a table, each arrow out of a box represents a column of that table. Here is
an example state of that database.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
17
employee
Id
Ô¨Årst name
last name
manager
works in
101
David
Hilbert
103
q10
102
Bertrand
Russell
102
x02
103
Alan
Turing
103
q10
department
Id
name
secretary
q10
Sales
101
x02
Production
102
string
Id
a
b
...
z
aa
ab
...
(19)
Note that every arrow f : x ‚Üíy of Olog (18) is represented in Database (19) as a
column of table x, and that every cell in that column can be found in the Id column
of table y. For example, every cell in the ‚Äúworks in‚Äù column of table employee
can be found in the Id column of table department.
The point is that ologs can be drawn to represent a world-view (as in Section
2), but they can also store data. Rules 1,2, and 3 in 2.1.1 align the construction of
an olog with the ability to document instances for each of its types.
3.2.2. Instance data as a set-valued functor. Let C be an olog. Section 3 so far has
described instances of types, aspects, and facts and how all of these come together
into a set of interconnected tables. The assignment of a set of instances to each
type and a function to each aspect in C, such that the declared facts hold, is called
an assignment of instance data for C. More precisely, instance data on C is a functor
C ‚ÜíSet, as in DeÔ¨Ånition 3.2.3.
DeÔ¨Ånition 3.2.3. Let C be a category (olog) with underlying graph |C|, and let
Set denote the category of sets. An instance of C (or an assignment of instance
data for C) is a functor I : C ‚ÜíSet. That is, it consists of
‚Ä¢ a set I(x) for each object (type) x in C,
‚Ä¢ a function I(f): I(x) ‚ÜíI(y) for each arrow (aspect) f : x ‚Üíy in C, and
‚Ä¢ for each fact (path-equivalence or equation) 3
f1 ; f2 ; ¬∑ ¬∑ ¬∑ ; fn = f ‚Ä≤
1 ; f ‚Ä≤
2 ; ¬∑ ¬∑ ¬∑ ; f ‚Ä≤
m
declared in C, an equality of functions
I(f1) ; I(f2) ; ¬∑ ¬∑ ¬∑ ; I(fn) = I(f ‚Ä≤
1) ; I(f ‚Ä≤
2) ; ¬∑ ¬∑ ¬∑ ; I(f ‚Ä≤
m).
For more on this viewpoint of categories and functors, the reader can consult
[Spi3].
4. Communication between ologs
The world is inherently heterogeneous. DiÔ¨Äerent individuals 4 in the world nat-
urally have diÔ¨Äerent world-views ‚Äî each individual has its own perspective on the
3If we let f = f1 ; f2 ; ¬∑ ¬∑ ¬∑ ; fn and f‚Ä≤ = f‚Ä≤
1 ; f‚Ä≤
2 ; ¬∑ ¬∑ ¬∑ ; f‚Ä≤
m, then we often write (f = f‚Ä≤): i ‚Üíj to
denote the fact that these paths are equivalent.
4By an individual we mean either an individual person acting on their own, a community
acting as a single entity, a software agent, etc. Later in this section we will use the notion of a
community acting as a distributed collection of linked, yet independent, individuals.

18
DAVID I. SPIVAK AND ROBERT E. KENT
world.
The conceptual knowledge (information resources) of an individual rep-
resents its world-view, and is encoded in an ontology log, or olog, containing the
concepts, relations, and observations that are important to that individual. An olog
is a formal speciÔ¨Åcation of an individual‚Äôs world-view in a language representing
the concepts and relationships used by that individual. In addition to the formula-
tion of an expressive language, a speciÔ¨Åcation needs to contain axioms (facts) that
constrain the possible interpretations of that language.
Since the ologs of diÔ¨Äerent individuals are encoded in diÔ¨Äerent languages, the
important need to merge disparate ologs into a more general representation is dif-
Ô¨Åcult, time-consuming and expensive. The solution is to develop appropriate com-
munication between individuals to allow interoperability of their ologs. Commu-
nication can occur between individuals when there is some commonality between
their world-views. It is this commonality that allows one individual to beneÔ¨Åt from
the knowledge and experience of another. In this section we will discuss how to
formulate these channels of communication, thereby describing a generalized and
practical technique for merging ologs.
The mathematical concept that makes it all work is that of a functor. A functor
is a mapping from one category to another that preserves all the declared structure.
Whereas in DeÔ¨Ånition 3.2.3 we deÔ¨Åned a functor from an olog to Set, here we will
be discussing functors from one olog to another.
Suppose we have two ologs, C and D, that represent the world-views of two
individuals. A functor F : C ‚ÜíD is basically a way of matching each type (box) of
C to a type of D, and each aspect (arrow) in C to an aspect (or path of aspects) in D.
Once ologs are aligned in this way, communication can occur: the two individuals
know what each other is talking about. In fact, mathematically we can show that
instance data held in C can be transformed (in coherent ways) to instance data held
in D, and vice versa (see [Spi2]). In simple terms, once individuals understand each
other in a certain domain (be it social, mathematical, etc.), they can communicate
their views about it.
While the basic idea is not hard, the details can be a bit technical. This section
is written in a more formal and logical style, and is decidedly more diÔ¨Écult than
the others. For this section only, we assume the reader is familiar with the notion
of Ô¨Åbered categories, colimits in the category Cat of categories, etc. We return
to our more informal style in Section 5, where we discuss how an individual can
author a more expressive olog.
4.1. Categories and their presentations. We never deÔ¨Åned categories in this
paper, but we deÔ¨Åned ologs and said that the two notions amounted to the same
thing. Thus, we implied that a category consists of the following: a set of objects,
a set of arrows (each pointing from one object to another), and a congruence rela-
tion on paths.5 This diÔ¨Äers from the standard deÔ¨Ånition of categories (see [Mac]),
which replaces our congruence relation with a composition rule and associativity
law (obtained by taking the categorical quotient). One could say that an olog is a
presentation of a category by generators (objects and arrows) and relations (path
congruences). Any category can be resolved and presented in such a way, which we
5A congruence relation on paths is an equivalence relation on paths that respects endpoints
and is closed under composition from left and right (see the axioms in 20).

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
19
will call a speciÔ¨Åcation. Likewise any functor can be resolved and presented as a
morphism between speciÔ¨Åcations. 6
In fact, this presentation form for categories (and the analogous one for functors)
is preferable for our work on communication between ologs, because it separates
the strictly graphical part of an olog (its types and aspects, regarded as the olog
language) from the propositional part (its facts, regarded as the olog formalism).
This presentation form is standard in the institutions [GB] and information Ô¨Çow
[BS] communities, since it separates the mechanism of Ô¨Çow from the content of Ô¨Çow;
in this case the formal content. Our work here applies the general theories of insti-
tutions and information Ô¨Çow to the speciÔ¨Åc logical system that underlies categories
and functors,7 demonstrating how this logical system can be used for knowledge
representation. Using the presentation forms for categories and functors, we show
how communication between individuals is eÔ¨Äected by the Ô¨Çow of information along
channels.
4.2. The architecture underlying information systems. We think of a com-
munity of people, businesses, etc. in terms of the ologs of each individual partici-
pant together with the information channels that connect them. These channels are
functors between ologs, which allow communication to occur. The heterogeneity of
multiple diÔ¨Äering world-views connected through such links can lead to a Ô¨Çexibil-
ity and robustness of interaction. For example, heterogeneity allows for multiple
schemas to be employed in the design of database systems in particular, and mul-
tiple languages to be employed in the design of knowledge representation systems
in general.
For any olog, consider the underlying graph of types and aspects. We regard this
graph as being the language of the olog, 8 with the facts of the olog being a subset
of all the possible assertions that one can make within this language. Any two
ologs with the same underlying graph of types and aspects have the same language,
and since the facts of each olog are expressed in the same language, they can be
‚Äúunderstood‚Äù by each other without translation. As such, we think of the collection
of all ologs with the same language (underlying graph) as forming a homogeneous
context, with the ologs ordered in a specialization-generalization hierarchy.
Whereas an olog represents (the world-view of) a single individual, an infor-
mation system (of ologs) represents a community of separate, independent and
distributed individuals. Here we consider an information system to be a diagram
of ologs of some shape I; that is, a collection of ologs and constraints indexed by a
base category I. The parts of the system represent either the ologs of the various
individuals in the system or common grounds needed for communication between
the individuals. Each part of the system speciÔ¨Åes its world-view as facts expressed
in terms of its language. The system is heterogeneous, since each part has a sep-
arate language for the expression of its world-view. The morphisms between the
parts are the alignment (constraint) links deÔ¨Åning the common grounds.
6We take an agnostic approach to foundations here.
With the presentation form, we show
how categories and functors are deÔ¨Ånable in terms of sets and functions, indicating how category
theoretic concepts could be deÔ¨Åned in terms of set theory. However, we fully understand that Set,
the category of sets and functions, is but one example of a topos, indicating how set theoretic
concepts could be deÔ¨Åned in terms of category theory.
7For the expert, this refers to the sketch logical system Sk, in its various manifestations.
8Section 4.4 indicates how natural languages can be encoded into ologs.

20
DAVID I. SPIVAK AND ROBERT E. KENT
As will be made clear in a moment, there is an underlying distributed system
consisting of the language (underlying graph) for each component part of the in-
formation system and a translation (graph morphism) for each alignment link. We
can think of this distributed system as an underlying system of languages linked by
translating dictionaries. This distributed system determines an information chan-
nel with core language (graph) and component translation links (graph morphisms)
along which the speciÔ¨Åcations of each component part can Ô¨Çow to the core. We
can think of this core as a universal language for the whole system and the channel
as a translation mechanism from parts to whole. At the core, the direct Ô¨Çow of
the component speciÔ¨Åcations are joined together (unioned) and allowed to interact
through entailment. The result of this interaction can then be distributed back to
the component parts, thereby allowing the separate parts of an information system
to interoperate.
In this section, we will make all this clear and rigorous. As mentioned above,
we will work with category presentations (here called speciÔ¨Åcations) rather than
categories. We will discuss the homogeneous contexts called Ô¨Åbers in detail and
give the axioms of satisfaction.
We will then discuss how morphisms between
graphs (the translating dictionaries between the ologs) allow for direct and inverse
information Ô¨Çow between these homogeneous Ô¨Åber contexts. Finally, we discuss
speciÔ¨Åcations (also known as theories) and the lattice of theories construction for
ontologies.
In Section 4.3 we will discuss how the information in ologs can be aligned by the
use of common grounds. This alignment will result in the creation of information
systems, which are systems of ologs connected together along functors. We will
discuss how to take the information contained in each olog of a heterogeneous system
and integrate it all into a single whole, called the fusion olog. Finally we will discuss
how the consequence of bringing all this information together, and allowing it to
interact, can be transferred back to each part of the system (individual olog) as a set
of local facts entailed by remote ologs, allowing for a kind of interoperability between
ologs. In Section 4.4 we will discuss conceptual graphs and their relationship to
ologs.
4.2.1. Fibers. A graph G contains types as nodes and aspects as edges. The graphs
underlying an olog is considered its language. Any category C has an underlying
graph |C|. In particular, |Set| is the graph underlying the category of sets and
functions. Olog (12) has an underlying graph containing the three types ‚åúperson‚åù,
‚åúperson-pair‚åùand ‚åúwoman‚åùand the three aspects ‚Äòhas a parent‚Äô, ‚Äòwoman‚Äô and
‚Äòhas as mother‚Äô.
Olog (17) has an underlying graph containing the three types
‚åúemployee‚åù, ‚åúdepartment‚åù, and ‚åústring‚åùand the six aspects ‚Äòmanager‚Äô, ‚Äòworks in‚Äô,
‚Äòsecretary‚Äô, ‚Äòname‚Äô, ‚ÄòÔ¨Årst name‚Äô and ‚Äòlast name‚Äô. Let eqn(G) denote the set of all
facts (equations) that are possible to express using the types and aspects of G. A
G-speciÔ¨Åcation is a set E ‚äÜeqn(G) consisting of some of the facts expressible in G.
The singleton set with the one fact that ‚Äúthe female parent of a person is his/her
mother‚Äù is a speciÔ¨Åcation for the graph of Olog (12). The set with the two facts
that ‚Äúthe manager has the same department as any employee‚Äù and ‚Äúthe secretary
of a department is an employee in that department‚Äù is a speciÔ¨Åcation for the graph
of Olog (17). Let spec(G) denote the collection of all G-speciÔ¨Åcations ordered by
inclusion E1 ‚äÜE2.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
21
4.2.2. Satisfaction. It will be useful here to deÔ¨Åne an instance of a graph G, instead
of an instance of a category C. An instance of a graph populates the graph by
assigning instance data to it.
An instance of a graph G is a graph morphism
D: G ‚Üí|Set| mapping each type x in G to a set D(x) of instances and mapping
each aspect e: x ‚Üíy in G to an instance function D(e): D(x) ‚ÜíD(y). Using
database terminology, we also call D a key diagram, since it gives the set of row
identiÔ¨Åers (primary keys) of tables and the cell contents deÔ¨Åned by key maps.
A key diagram D: G ‚Üí|Set| satisÔ¨Åes (is a model of) a G-fact «´ ‚ààeqn(G)
(see DeÔ¨Ånition 3.2.3), symbolized D |=G «´, when we have an equality of functions
D‚àó(«´0) = D‚àó(«´1). We also say that «´ (holds in) is true when interpreted in D.
An identity (f =G f): i ‚Üíj holds in all key diagrams (hence, is a tautology),
and vice-versa for any set A ‚àà|Set| a constant key diagram ‚àÜ(A): G ‚Üí|Set|
satisÔ¨Åes any fact «´ ‚ààeqn(G). A key diagram D: G ‚Üí|Set| satisÔ¨Åes (is a model
of) a G-speciÔ¨Åcation E, symbolized D |=G E, when it satisÔ¨Åes every fact in the
speciÔ¨Åcation. For any graph G, a G-speciÔ¨Åcation E entails a G-fact «´, denoted by
E ‚ä¢G «´, when any model of the speciÔ¨Åcation satisÔ¨Åes the fact. The consequence E‚Ä¢
of a G-speciÔ¨Åcation E is the set of all entailed equations. The consequence operator
(‚àí)‚Ä¢ is a closure operator, and the consequence of a speciÔ¨Åcation is a congruence.
For any G-speciÔ¨Åcation E, entailment satisÔ¨Åes the following axioms.
(basic)
If E contains the equation «´, then E entails «´.
(reÔ¨Çexive)
E entails the equations (f =G f): i ‚Üíj for any path f : i ‚Üíj.
(symmetric)
If E entails the equation (f1 =G f2): i ‚Üíj, then E entails the equation
(f2 =G f1): i ‚Üíj.
(transitive)
If E entails the two equations (f1 =G f2): i ‚Üíj and (f2 =G f3): i ‚Üíj,
then E entails the equation (f1 =G f3): i ‚Üíj.
(compositional)
If E entails the two equations (f1 =G f2): i ‚Üíj and (g1 =G g2): j ‚Üík,
then E entails the equation (f1 ; g1 =G f2 ; g2): i ‚Üík.
(bi-closed)
If E entails the equation (g1 =G g2): j ‚Üík, then E entails the equations
(f ; g1 =G f ; g2): i ‚Üík and (g1 ; h =G g2 ; h): j ‚Üíl for any left
composable path f : i ‚Üíj and any right composable path h: k ‚Üíl.
(20)
These are converted to inference rules in Table 1. To construct E‚Ä¢, we Ô¨Årst take the
reÔ¨Çexive, symmetric, and transitive closure E‚àóof E (so that E‚àóis a G-speciÔ¨Åcation
and also the smallest equivalence relation containing E), and then we get E‚Ä¢ by
closing up under composition on left and right. We extend speciÔ¨Åcation inclusion
with the entailment order, where E1 ‚â§G E2 when E1 entails each equation in E2;
that is, when E‚Ä¢
1 ‚äáE2 or equivalently when E‚Ä¢
1 ‚äáE‚Ä¢
2. The statement ‚ÄúE1 ‚â§G E2‚Äù
asserts that E1 is at least as specialized as E2. The entailment order ‚ü®spec(G), ‚â§G‚ü©,
which is a specialization-generalization order, represents a local version of the ‚Äúlat-
tice of theories‚Äù construction of Sowa [Sow2] (see Section 4.2.5).
The opposite
entailment order fbr(G) = ‚ü®spec(G), ‚â•G‚ü©is called the Ô¨Åber order.9 In the lattice10
spec(G), the meet is union ‚àß= ‚à™and the join is intersection ‚à®= ‚à©; whereas in
the lattice fbr(G), the join is union ‚à®= ‚à™and the meet is intersection ‚àß= ‚à©.
Any speciÔ¨Åcation E is entailment equivalent to its consequence E ‚àº= E‚Ä¢. A speciÔ¨Å-
cation E is closed when it is equal to its consequence E = E‚Ä¢. There is a one-one
correspondence between closed G-speciÔ¨Åcations and categories over graph G. The
9For consistency in discussion, we follow the terminology of formal concept analysis [GW],
information Ô¨Çow [BS] and the theory of institutions [GB]. This includes the polarity induced by
concept lattices and the directionality of infomorphisms.
10This is a complete preorder, loosely called a ‚Äúlattice‚Äù.

22
DAVID I. SPIVAK AND ROBERT E. KENT
conceptual intent of a key diagram D, implicit in satisfaction, is the closed speciÔ¨Å-
cation int(D) consisting of all facts satisÔ¨Åed by the key diagram. Hence, D |=G E
iÔ¨ÄE ‚äÜint(D) iÔ¨Äint(D) ‚â§G E.11
4.2.3. Elementary Ô¨Çow. A graph morphism H : G1 ‚ÜíG2 maps the types and as-
pects of G1 to the types and aspects of G2. Graph morphisms are the transla-
tions between ologs. A functor F : C1 ‚ÜíC2 has an underlying graph morphism
|F|: |C1| ‚Üí|C2|. For any graph morphism H : G1 ‚ÜíG2, there is a fact function
eqn(H): eqn(G1) ‚Üíeqn(G2) that maps a G1-equation (f1 =G1 f ‚Ä≤
1): i1 ‚Üíj1 to
the G2-equation (H‚àó(f1) =G2 H‚àó(f ‚Ä≤
1)): H(i1) ‚ÜíH(j1), and a key diagram functor
dgm(H): dgm(G2) ‚Üídgm(G1) that maps a key diagram D2 : G2 ‚Üí|Set| to the
key diagram H ‚ó¶D2 : G2 ‚Üí|Set|.12 The fact function is the fundamental unit of
information (formal) Ô¨Çow for ologs, and the key diagram functor is the fundamental
unit of semantic Ô¨Çow for ologs.13 Formal Ô¨Çow is adjoint to semantic Ô¨Çow ‚Äî satis-
faction is invariant under Ô¨Çow: dgm(H)(D2) |=G1 «´1 iÔ¨ÄD2 |=G2 eqn(H)(«´1) for
any graph morphism H : G1 ‚ÜíG2, source fact «´1 and target diagram D2. Spec-
iÔ¨Åcations can be moved along graph morphisms by extending the fact (equation)
function.
For any graph morphism H : G1 ‚ÜíG2, deÔ¨Åne the direct Ô¨Çow opera-
tor dir(H) = ‚Ñòeqn(H) : spec(G1) ‚Üíspec(G2)14 and the inverse Ô¨Çow operator
inv(H) = eqn(H)‚àí1((-)‚Ä¢) : spec(G2) ‚Üíspec(G1). Direct and inverse Ô¨Çow are
adjoint monotonic functions ‚ü®dir(H) ‚ä£inv(H)‚ü©: fbr(G1) ‚Üífbr(G2) w.r.t. Ô¨Åber
order: dir(H)(E1) ‚â•G2 E2 iÔ¨ÄE1 ‚â•G1 inv(H)(E2).
For any graph morphism
H : G1 ‚ÜíG2, any G1-speciÔ¨Åcation E1, and any G2-speciÔ¨Åcation E2, entailment
satisÔ¨Åes the following axioms.
(direct Ô¨Çow)
If E1 entails the equation (f =G1 f ‚Ä≤): i ‚Üíj, then dir(H)(E1) entails
the equation (H‚àó(f1) =G2 H‚àó(f ‚Ä≤
1)): H(i1) ‚ÜíH(j1).
(inverse Ô¨Çow)
If E2 entails the equation (H‚àó(f) =G2 H‚àó(f ‚Ä≤)): H(i) ‚ÜíH(j), then
inv(H)(E2) entails the equation (f =G1 f ‚Ä≤): i ‚Üíj.
These are converted to inference rules in Table 1. A graph morphism H : G1 ‚ÜíG2
deÔ¨Ånes a consequence operator (-)
‚ô¶H = dir(H) ‚ó¶inv(H) on the Ô¨Åber preorder
fbr(G1), where E1 ‚â•G1 E‚Ä¢
1 ‚â•G1 E
‚ô¶H
1
.
4.2.4. SpeciÔ¨Åcations. A speciÔ¨Åcation S = ‚ü®G, E‚ü©is an indexed notion consisting of
a graph G and a G-speciÔ¨Åcation E ‚ààspec(G). It is sometimes convenient to use
the symbol ‚ÄòS‚Äô in place of ‚ÄòE‚Äô; for example, to say that ‚ÄúS ‚ààspec(G)‚Äù. A category
C can be resolved and presented as a speciÔ¨Åcation spec(C) = ‚ü®G, E‚ü©consisting of
the underlying graph G = |C| containing the types and aspects of C and the col-
lection E of all facts that hold in C. In the other direction, any speciÔ¨Åcation S
induces a (quotient) category cat(S). Olog (12) and Olog (17) are described as
speciÔ¨Åcations in Section 4.2.1. A speciÔ¨Åcation morphism H : ‚ü®G1, E1‚ü©‚Üí‚ü®G2, E2‚ü©
is a graph morphism H : G1 ‚ÜíG2 that preserves entailment: E1 ‚ä¢G1 «´1 implies
E2 ‚ä¢G2 eqn(H)(«´1) for any «´1 ‚ààeqn(G1); or equivalently that satisÔ¨Åes the ad-
jointness conditions, dir(H)(E1) ‚â•G2 E2 iÔ¨ÄE1 ‚â•G1 inv(H)(E2). Being a graph
morphism, it maps types to types and aspects to aspects. Moreover, it also maps
facts in E1 to facts in E2; that is, it preserves all the declared structure.
A
functor F : C1 ‚ÜíC2 can be resolved and presented as a speciÔ¨Åcation morphism
11This is the Ô¨Årst step in the algebraization of Tarski‚Äôs ‚Äúsemantic deÔ¨Ånition of truth‚Äù [Ken4].
12The composition of graph morphisms is written in diagrammatic order.
13This is so, at the abstraction of institutions [Ken3].
14The symbol ‚Ñòdenotes the power-set operator.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
23
F : spec(C1) ‚Üíspec(C2). Hence, the presentation form for a functor does exactly
what the functor does. The Ô¨Åbered category of speciÔ¨Åcations Spec has speciÔ¨Åca-
tions as objects and speciÔ¨Åcation morphisms as morphisms. Thus, it is deÔ¨Åned in
terms of information Ô¨Çow. There is an underlying graph functor gph : Spec ‚ÜíGph
from speciÔ¨Åcations to graphs ‚ü®G, E‚ü©7‚ÜíG. The subcategory over any Ô¨Åxed graph
G is the Ô¨Åber fbr(G); because of the opposite orientation, we say that ‚Äúthe cat-
egory of speciÔ¨Åcations points downward in the concept lattice‚Äù. Throughout this
section we identify ologs with speciÔ¨Åcations and olog morphisms with speciÔ¨Åcation
morphisms.
4.2.5. The lattice of theories construction. Sowa‚Äôs ‚Äúlattice of theories‚Äù construction
(LOT) describes a modular framework for ontologies [Sow2]. The Olog formalism
follows the approach to LOT described in [IFF2].15 In the Olog formalism, LOT is
locally represented by the entailment preorders spec(G), and globally represented
by the category of speciÔ¨Åcations Spec.
We follow the discussion in section 6.5
‚ÄúTheories, Models and the World‚Äù of Sowa [Sow2]. From each olog (speciÔ¨Åcation)
in the ‚Äúlattice of theories‚Äù, the entailment ordering deÔ¨Ånes paths to the more gen-
eralized ologs above and the more specialized ologs below. Sowa deÔ¨Ånes four ways
for moving along paths from one olog to another: contraction, expansion, revision
and analogy.
Contraction: Any olog can be contracted or reduced to a smaller, simpler
olog, moving upward in the preorder spec(G), by deleting one or more
facts.
Expansion: Any olog can be expanded, moving downward in the preorder
spec(G), by adding one or more facts.
Revision: A revision step is composite, moving crosswise in the preorder
spec(G); it uses a contraction step to discard irrelevant details, followed by
an expansion step to added new facts.
Analogy: Unlike contraction and expansion, which move to nearby ologs in
an entailment preorder spec(G), analogy moves to an olog in a remote
entailment preorder in the category Spec via the Ô¨Çow along an underlying
graph morphism H : G1 ‚ÜíG2 by systematically renaming the types and
aspects that appear in the facts: any olog E1 in spec(G1) is moved (by
systematic renaming) to the olog dir(H)(E1) in spec(G2).
According to Sowa, the various methods used in nonmonotonic logic and the oper-
ators for belief revision correspond to movement through the lattice of theories.
4.3. Alignment and integration of information systems.
4.3.1. Common ground. Given the world-views of two individuals, as represented
by ologs S1 = ‚ü®G1, E1‚ü©and S2 = ‚ü®G2, E2‚ü©, there is little hope that one of them com-
pletely contains the other (even after allowing for renaming of types and aspects),
and there is correspondingly little chance of Ô¨Ånding a meaningful olog morphism be-
tween the two. Instead, in order to communicate the two individuals could attempt
to Ô¨Ånd a common ground, a third olog S = ‚ü®G, E‚ü©and meaningful morphisms16
15The IFF term ‚Äòtheory‚Äô is replaced by the Olog term ‚ÄôspeciÔ¨Åcation‚Äô or ‚Äôolog‚Äô.
16Roughly speaking, an olog morphism F : C ‚ÜíD is meaningful when for each type X in C,
every intended instance of X in C would be considered an instance of F (X) by the author of D
(in which case we say the intention for types is respected), and in a similar way the intention for
aspects is respected. Precisely speaking, if I : C ‚ÜíSet and J : D ‚ÜíSet are instance data for

24
DAVID I. SPIVAK AND ROBERT E. KENT
H1 : S ‚ÜíS1 and H2 : S ‚ÜíS2.17 This connection is a 1-dimensional knowledge
network S1
H1
‚Üê‚àí‚àíS
H2
‚àí‚àí‚ÜíS2 of shape ‚Ä¢ ‚Üê‚Ä¢ ‚Üí‚Ä¢ called a span (in Spec), where each
node is an olog and each edge is a morphism between ologs. The requirements of
this span are that dir(H1)(E) ‚â•G1 E1 and dir(H2)(E) ‚â•G2 E2, two requirements
involving local Ô¨Çow. Equivalently, that E ‚â•G inv(H1)(E1) ‚à®G inv(H2)(E2). The
latter precise expression can be rendered in natural language as ‚Äúthe world-view of
the common ground is contained in the combined world-views of the two individu-
als‚Äù. The various local direct/inverse Ô¨Çows allow world-views to be compared. Such
a common ground can be expanded and improved over time. The basic idea is that
one individual can attempt to explain a new idea (type, aspect or fact) to another
in terms of the common ground. Then the other individual can either interpret this
idea as they already have, learn from it (i.e. freely add it to their olog), or reject
it. We view an olog morphism H1 : S1 ‚ÜíS2 as an atomic constraint (alignment)
link between S1 and S2.18
We view a common ground span S1
H1
‚Üê‚àí‚àíS
H2
‚àí‚àí‚ÜíS2
as a molecular constraint between S1 and S2, which is weakest when S = ‚àÖand
strongest when S1 = S = S2.
4.3.2. Systems of ologs. In the general case, more than two individuals will share
a common ground. For example, companies that do business together may have a
common-ground olog as part of a legal contract; or, the various participants at a
conference will have some common understanding of the topic of that conference.
In fact, for any Ô¨Ånite set of ologs X = {S1, S2, . . . , Sn}, there should be a common
ground world-view (even if empty), say SX. If Y ‚äÜX is a subset, then there should
be a map SX ‚ÜíSY because any common understanding held by the individuals in
X is held by the individuals in Y. For example, the triangular-shaped diagram
S1
S12
C

S13
222222222
[88888888
S123

cGGGG
;w
w
w
w
S2
S23
o
/ S3
(21)
represents three individuals {1, 2, 3}, their ologs {S1, S2, S3}, their pair-wise com-
monality ologs {S12, S13, S23}, and their three-way commonality olog S123. This
diagram, which stands for the interaction between individuals {1, 2, 3}, does not
stand alone, but is part of an intricate web of other ologs and alignment constraints.
In particular, individuals 1 and 3 may be part of some diÔ¨Äerent interacting group,
say of individuals {1, 3, 6, 7}, and hence the right edge of the diagram would be
part of some tetrahedron-shaped diagram with vertices {1, 3, 6, 7}. If we take the
point-of-view that ‚Äúa collection of ologs representing the world-views of various in-
dividuals‚Äù is a system, then we can think of the ologs as being the types of that
C and D, then F is meaningful relative to I and J if one can exhibit a natural transformation
¬µ: I ‚áíF ‚ó¶J as in [Spi2].
17A common ground olog is also called a reference ontology in knowledge representation.
18This is so, at the abstraction of institutions [Ken3].

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
25
system, the morphisms connecting the ologs as being the aspects of that system,
with the shape of a system being its underlying graph. In essence, we can apply
ologs to themselves. In the system represented by diagram (21), there are seven
types {S1, S2, S3, S12, S13, S23, S123} and nine aspects {¬∑ ¬∑ ¬∑ , S123 ‚ÜíS13, . . . }, and
the shape looks like this
q
q
q
‚ú°‚ú°‚ú£
‚ú°
‚ú°‚ú¢
‚ùè
‚ùè‚ù™
‚ùè
‚ùè‚ù´
‚úõ
‚ú≤
q
q
q
q
‚úë
‚úë
‚ú∏
‚óó
‚óó
‚ù¶
‚ùÑ
In addition, we can introduce certain facts to represent the meaning of that system
and then enforce those facts.
A distributed system is a diagram (functor) G : I ‚ÜíGph of shape I within the
ambient category Gph. As such, it consists of an indexed family {Gn | n ‚ààI} of
graphs together with an indexed family {Ge : Gn ‚ÜíGm | (e: n ‚Üím) ‚ààI} of graph
morphisms. Let Dist(I) denote the collection of distributed systems of shape I.
An information system is a diagram S : I ‚ÜíSpec of shape I within the ambient
category Spec. As such, it consists of an indexed family {Sn = ‚ü®Gn, En‚ü©| n ‚ààI} of
ologs together with an indexed family {Se : Sn ‚ÜíSm | (e: n ‚Üím) ‚ààI} of olog mor-
phisms. Some of these ologs might represent the world-views of various individuals,
whereas others could be common grounds; also included might be portals between
individual ologs and common grounds, as in the CG example of Section 4.4. Let
Info(I) denote the collection of information systems of shape I. An information sys-
tem S with component ologs Sn = ‚ü®Gn, En‚ü©has an underlying distributed system G
of the same shape with component graphs Gn for n ‚ààI. For any distributed system
G, let infoI(G) denote the collection of information systems over G of shape I. There
is a pointwise entailment order S ‚â§I
G S‚Ä≤ on infoI(G) when component ologs satisfy
the same entailment ordering En ‚â§Gn E‚Ä≤
n for n ‚ààI, and by taking the coproduct
there is a pointwise entailment order on Info(I) = `
G‚ààDist(I) infoI(G). A constant
distributed system ‚àÜ(G) ‚ààDist(I) is a distributed system ‚àÜ(G): I ‚ÜíGph with
the same language G for any index n ‚ààI. Any constant distributed system deÔ¨Ånes
join and meet monotonic functions WI
G, VI
G : infoI(‚àÜ(G)) ‚Üífbr(G) mapping an
information system S ‚ààinfoI(‚àÜ(G)) to the join and meet ologs W S = S
n‚ààI En
and V S = T
n‚ààI En in fbr(G). The join monotonic function is adjoint to the con-
stant monotonic function ‚àÜI
G : fbr(G) ‚ÜíinfoI(‚àÜ(G)) that distributes an olog
S‚Ä≤ ‚ààfbr(G) to the various locations n ‚ààI forming a constant information sys-
tem ‚àÜ(S‚Ä≤) ‚ààinfoI(‚àÜ(G)), since W S ‚â•G S‚Ä≤ iÔ¨ÄS ‚â•I
‚àÜ(G) ‚àÜ(S‚Ä≤) for any system
S ‚ààinfoI(‚àÜ(G)) and any olog S‚Ä≤ ‚ààfbr(G).
4.3.3. System morphisms. Just as ologs are linked by morphisms, information sys-
tems are also linked by morphisms. For these there is the new complication of shape.
In this paper we deÔ¨Åne Ô¨Åxed-shape system moorphisms, but a more general deÔ¨Å-
nition would allow the shape to vary. A distributed system morphism Œ∏: G ‚áíG‚Ä≤
in Dist(I) consists of a collection {Œ∏n : Gn ‚ÜíG‚Ä≤
n | n ‚ààI} of component graph
morphisms, which are systematically coordinated in the sense that they satisfy the
naturality conditions Ge‚ó¶Œ∏m = Œ∏n‚ó¶G‚Ä≤
e for any indexing link e: n ‚Üím in I. A direct
Ô¨Çow operator dirI(Œ∏) : infoI(G) ‚ÜíinfoI(G‚Ä≤) along Œ∏ can be deÔ¨Åne, which maps an
information system S ‚ààinfoI(G) to an information system dir I(Œ∏)(S) ‚ààinfoI(G‚Ä≤)

26
DAVID I. SPIVAK AND ROBERT E. KENT
deÔ¨Åned by dirI(Œ∏)(S)n = dir(Œ∏n)(En) for n ‚ààI.19
An inverse Ô¨Çow operator
invI(Œ∏) : infoI(G‚Ä≤) ‚ÜíinfoI(G) can similarly be deÔ¨Åned.
Direct and inverse
Ô¨Çow are adjoint monotonic functions ‚ü®dir I(Œ∏) ‚ä£inv I(Œ∏)‚ü©: infoI(G) ‚ÜíinfoI(G‚Ä≤),
since dirI(Œ∏)(S) ‚â•I
G‚Ä≤ S‚Ä≤ iÔ¨ÄS ‚â•I
G inv I(Œ∏)(S‚Ä≤). An information system morphism
Œ∏: S ‚áíS‚Ä≤ in Info(I) consists of a collection {Œ∏n : Sn ‚ÜíS‚Ä≤
n | n ‚ààI} of component
olog morphisms, which are systematically coordinated and preserve alignment in
the sense that they satisfy the naturality conditions Se ‚ó¶Œ∏m = Œ∏n ‚ó¶S‚Ä≤
e for any in-
dexing link e: n ‚Üím in I; equivalently, Œ∏ is a morphism between the underlying
distributed systems Œ∏: G ‚áíG‚Ä≤ and the direct Ô¨Çow of S is at least as general as
S‚Ä≤: dir I(Œ∏)(S) ‚â•I
G‚Ä≤ S‚Ä≤. The ordering S ‚â•I
G S‚Ä≤ is an information system morphism
Œ∏: S ‚áíS‚Ä≤ with identity component translations Œ∏n = id Gn for each index n ‚ààI.
4.3.4. Channels. We continue with our systems point-of-view. Since we have rep-
resented the whole system as a diagram S of parts (ologs) Sn with part-part re-
lations (alignment constraints) Sn ‚ÜíSm, we also want to represent the whole
system as an olog C with part-whole relations Sn ‚ÜíC.20 An information chan-
nel ‚ü®Œ≥ : M ‚áí‚àÜ(C), C‚ü©consists of an indexed family {Œ≥n : Gn ‚ÜíC | n ‚ààI} of
graph morphisms called Ô¨Çow links with a common target graph C called the core
of the channel. A channel ‚ü®Œ≥, C‚ü©covers a distributed system G of shape I when the
part-whole relationships respect the alignment constraints (are consistent with the
part-part relationships): Œ≥n = Ge ‚ó¶Œ≥m for each indexing morphism e: n ‚Üím in
I. A covering channel is a distributed system morphism Œ≥ : G ‚áí‚àÜ(C) in Dist(I)
from distributed system G to constant distributed system ‚àÜ(C): I ‚ÜíGph. Such
a channel deÔ¨Ånes a direct Ô¨Çow operator dir I(Œ≥) : infoI(G) ‚ÜíinfoI(‚àÜ(C)) and
an inverse Ô¨Çow operator inv I(Œ≥) : infoI(‚àÜ(C)) ‚ÜíinfoI(G). For any two cover-
ing channels ‚ü®Œ≥‚Ä≤, C‚Ä≤‚ü©and ‚ü®Œ≥, C‚ü©over the same distributed system G, a reÔ¨Ånement
H : ‚ü®Œ≥‚Ä≤, C‚Ä≤‚ü©‚Üí‚ü®Œ≥, C‚ü©is a graph morphism between cores H : C‚Ä≤ ‚ÜíC that respects
the part-whole relationships of the two channels: Œ≥‚Ä≤
n ‚ó¶H = Œ≥n for n ‚ààI. In such
a situation, we say the channel ‚ü®Œ≥‚Ä≤, C‚Ä≤‚ü©is a reÔ¨Ånement of the channel ‚ü®Œ≥, C‚ü©. A
channel ‚ü®Œπ, ` G‚ü©is a minimal cover21 or optimal(ly reÔ¨Åned covering) channel of a
distributed system G when it covers G and for any other covering channel ‚ü®Œ≥, C‚ü©
there is a unique reÔ¨Ånement [Œ≥, C]: ` G ‚ÜíC from ‚ü®Œπ, ` G‚ü©to ‚ü®Œ≥, C‚ü©.
4.3.5. System Ô¨Çow. In order to represent an information system S = {Sn
Se
‚àí‚ÜíSm}
as a single olog ` S, called the fusion of S, with part-whole relations Sn ‚Üí` S, we
follow the colimit theorem of [TBG] by recognizing the following three properties.
‚Ä¢ Optimal channels exist for any distributed system G.
‚Ä¢ fbr(G) is a complete preorder for any graph G, loosely called a ‚Äúlattice‚Äù.
‚Ä¢ For any graph morphism H : G1 ‚ÜíG2, direct and inverse Ô¨Çow are adjoint
monotonic functions ‚ü®dir(H), inv(H)‚ü©: fbr(G1) ‚Üífbr(G2).
Let G ‚ààDist(I) be a distributed system of shape I with optimal channel ‚ü®Œπ, ` G‚ü©.
The optimal core bG = ` G is called the sum of the distributed system G, and
the optimal channel components (graph morphisms) {Œπn : Gn ‚Üí` G | n ‚ààI} are
called Ô¨Çow links. There is a direct system Ô¨Çow monotonic function (see Figure 1)
19Well-deÔ¨Åned, since dir(G‚Ä≤
e)(dir(Œ∏n)(En)) = dir(Œ∏m)(dir(Ge)(En)) ‚â•m dir(Œ∏m)(Em).
20The theory of part-whole relations is called mereology. It studies how parts are related to
wholes, and how parts are related to other parts within a whole.
21Information Ô¨Çow terminology [BS].

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
27
infoI(G)
infoI(‚àÜ( bG))
fbr( bG)
`
S
‚àã
S ‚àà
‚àà
S ‚ô¶
dir ‚ü®I,G‚ü©
inv‚ü®I,G‚ü©
dir I(Œπ)
inv I(Œπ)
‚à®I
ÀÜ
G
‚àÜI
ÀÜ
G
‚ú≤
‚ä£
‚úõ
‚ú≤
‚ä£
‚úõ
‚úé
‚òû
‚ùÑ
‚úç
‚úå
‚úª
Figure 1. System Flow
dir‚ü®I,G‚ü©= dirI(Œπ) ¬∑ ‚à®I
ÀÜG : infoI(G) ‚Üífbr( bG). Direct system Ô¨Çow has two steps: (i)
direct (Ô¨Åxed shape) system Ô¨Çow of an information system along the optimal channel
(Dist(I)-morphism) Œπ: G ‚áí‚àÜ( bG) and (ii) lattice join combining the contributions
of the parts into a whole. In the opposite direction, there is an inverse system Ô¨Çow
monotonic function (see Figure 1) inv ‚ü®I,G‚ü©= ‚àÜI
ÀÜG ¬∑ inv I(Œπ): fbr( bG) ‚ÜíinfoI(G).
Inverse system Ô¨Çow has two steps: (i) mapping an olog with core language bG to
a constant information system over ‚àÜ( bG) with shape I by distributing the olog
to the locations n ‚ààI, and (ii) inverse (Ô¨Åxed shape) system Ô¨Çow of this constant
information system back along the optimal channel Œπ: G ‚áí‚àÜ( bG). Direct system
Ô¨Çow is adjoint to inverse system Ô¨Çow ‚ü®dir ‚ü®I,G‚ü©‚ä£inv ‚ü®I,G‚ü©‚ü©: infoI(G) ‚Üífbr( bG),
since the composition components are adjoint. For any distributed system G ‚àà
Dist(I) with optimal core bG = ` G, any information system S ‚ààinfoI(G), and
any olog bS ‚ààfbr( bG), entailment satisÔ¨Åes the following axioms.
(direct Ô¨Çow)
If En entails the equation (f =Gn f ‚Ä≤): i ‚Üíj, then dir‚ü®I,G‚ü©(S) entails
the equation (Œπ‚àó
n(f) = ÀÜ
G Œπ‚àó
n(f ‚Ä≤)): Œπn(i) ‚ÜíŒπn(j) for any n ‚ààI.
(inverse Ô¨Çow)
If b
S entails the equation (Œπ‚àó
n(f)
= ÀÜ
G
Œπ‚àó
n(f ‚Ä≤)): Œπn(i)
‚Üí
Œπn(j), then
inv‚ü®I,G‚ü©(b
S)n entails the equation (f =Gn f ‚Ä≤): i ‚Üíj for any n ‚ààI.
These are converted to inference rules in Table 1. Information Ô¨Çow can be used to
compute the fusion olog for an information system and to deÔ¨Åne the consequence
of an information system. Fusion is direct system Ô¨Çow, and consequence is the
composition of direct and inverse system Ô¨Çow. Let S ‚ààinfoI(G) be any information
system. The fusion ` S = dir‚ü®I,G‚ü©(S) = ‚ü®` G, W
n‚ààI dir(Œπn)(En)‚ü©‚ààfbr( bG) is an
olog that represents the whole system in a centralized fashion [Ken2],[Ken3]. The
consequence S
‚ô¶
‚ü®I,G‚ü©= inv ‚ü®I,G‚ü©(dir ‚ü®I,G‚ü©(S)) = inv ‚ü®I,G‚ü©(` S) = {inv(Œπn)(` S) | n ‚àà
I} ‚ààinfoI(G) is an information system that represents the whole system in a
distributed fashion [Ken3]. It is inverse Ô¨Çow of the fusion olog along the optimal
channel, transfering the entailed facts of the whole system to the component parts.
The consequence operator (-)‚ô¶, which is deÔ¨Åned on information systems, is a
closure operator on the complete preorder infoI(G), and by taking the coproduct
it is a closure operator on the complete preorder Info(I) = `
G‚ààDist(I) infoI(G)
: (increasing) S ‚â•S‚ô¶, (monotonic) S ‚â•S‚Ä≤ implies S‚ô¶‚â•S‚Ä≤‚ô¶and (idempotent)
S‚ô¶‚ô¶= S‚ô¶. 22 Pointwise entailment order ‚â§on Info(I) is only a preliminary order,
since it does not incorporate interactions between system component parts. System
22By allowing system shape to vary, channels can be generalized to morphisms of distributed
systems. Then a notion of relative fusion (direct system Ô¨Çow) can be deÔ¨Åned in terms of left Kan

28
DAVID I. SPIVAK AND ROBERT E. KENT
equivalence:
(reÔ¨Çexive)
(f =G f): i ‚Üíj
(symmetric)
(f1 =G f2): i ‚Üíj
(f2 =G f1): i ‚Üíj
(transitive)
(f1 =G f2): i ‚Üíj, (f2 =G f3): i ‚Üíj
(f1 =G f3): i ‚Üíj
algebra:
(compositional)
(f1 =G f2): i ‚Üíj, (g1 =G g2): j ‚Üík
(f1 ; g1 =G f2 ; g2): i ‚Üík
(bi-closed)
(g1 =G g2): j ‚Üík
(f ; g1 =G f ; g2): i ‚Üík, (g1 ; h =G g2 ; h): j ‚Üíl
morphic Ô¨Çow:
(direct)
(f1 =G1 f ‚Ä≤
1): i1 ‚Üíj1
(H‚àó(f1) =G2 H‚àó(f ‚Ä≤
1)): H(i1) ‚ÜíH(j1)
(inverse)
(H‚àó(f1) =G2 H‚àó(f ‚Ä≤
1)): H(i1) ‚ÜíH(j1)
(f1 =G1 f ‚Ä≤
1): i1 ‚Üíj1
system Ô¨Çow:
(direct)
(f =Gn f ‚Ä≤): i ‚Üíj
(Œπ‚àó
n(f) = ÀÜ
G Œπ‚àó
n(f ‚Ä≤)): Œπn(i) ‚ÜíŒπn(j)
(inverse)
(Œπ‚àó
n(f) = ÀÜ
G Œπ‚àó
n(f ‚Ä≤)): Œπn(i) ‚ÜíŒπn(j)
(f =Gn f ‚Ä≤): i ‚Üíj
Table 1. Inference Rules
entailment order ‚™Øon Info(I) is deÔ¨Åned by S1 ‚™ØS2 when S
‚ô¶
1 ‚â§S
‚ô¶
2 ; equivalently,
S
‚ô¶
1 ‚â§S2. Pointwise order is stronger than system entailment order: S1 ‚â§S2 implies
S1 ‚™ØS2. This is a specialization-generalization order. Any information system S
is entailment equivalent to its consequence S ‚àº= S‚ô¶. An information system S is
closed when it is equal to its consequence S = S‚ô¶.
The whole eÔ¨Äect of taking the system consequence may be greater than the
sum of its parts, in the sense that Sn ‚â•n S
‚ô¶Œπn
n
‚â•n
W
m inv(Œπn)(dir(Œπm)(Sm)) ‚â•n
S‚ô¶
n for any n ‚ààI, since separate parts may have a productive interaction at the
channel core. A Ô¨Ånal part of an information system is a part with no non-trivial
constraint links from it.
(The graphical subsystem beneath) nonÔ¨Ånal parts are
necessary for the alignment of information systems, resulting in the equivalencing of
types and aspects through quotienting. However, because of the covering condition
Œπn = Ge ‚ó¶Œπm and the entailment order dir(Ge)(En) ‚â•m Em for constraint links
Se : Sn ‚ÜíSm, only the fact(ual) content of Ô¨Ånal parts of information systems are
necessary to compute the system fusion and consequence.
4.3.6. General examples. Here are some examples of system fusion/consequence.
extension, and a notion of relative system consequence can be deÔ¨Åned as the composition of direct
followed by inverse system Ô¨Çow.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
29
‚Ä¢ An information system S with a constant underlying distributed system,
Gi = G for all n ‚ààI, gathers together all the component parts of the infor-
mation system and forms their consequence. It has identity Ô¨Çow links {Œπn =
id G : G ‚ÜíG = ` G | n ‚ààI}, component join fusion ` S = W
n‚ààI Sn =
‚ü®G, S
n‚ààI En‚ü©, and constant system consequence S‚ô¶
n =
 W
n‚Ä≤‚ààI Sn‚Ä≤‚Ä¢ for all
n ‚ààI.
‚Ä¢ A discrete information system S = {Sn = ‚ü®Gn, En‚ü©| n ‚ààI} with no
constraint links Ge : Sn ‚ÜíSm for n Ã∏= m, has coproduct injection Ô¨Çow links
Œπn : Gn ‚Üí+n‚ààI Gn, non-restricting fusion, and inverse Ô¨Çow projecting back
to individual component consequence S‚ô¶
n = S‚Ä¢
n for all n ‚ààI. No alignment
(constraint) links means no interaction.
‚Ä¢ An information system S = {S1
H1
‚Üê‚àí‚àíS
H2
‚àí‚àí‚ÜíS2} consisting of a single com-
mon ground S = ‚ü®G, E‚ü©between two component ologs S1 = ‚ü®G1, E1‚ü©and
S2 = ‚ü®G2, E2‚ü©, with underlying distributed system (span) G = {G1
H1
‚Üê‚àí‚àí
G
H2
‚àí‚àí‚ÜíG2}, has pushout injection Ô¨Çow links G1
Œπ1
‚àí‚Üí` G
Œπ2
‚Üê‚àíG2, direct
image union fusion ` S = ‚ü®` G, dir(Œπ1)(E1) ‚à™dir(Œπ2)(E2)‚ü©, and system
consequence components S‚ô¶
n = ‚ü®Gn, inv(Œπn)(dir(Œπ1)(E1) ‚à™dir(Œπ2)(E2))‚ü©
for n = 1, 2. The Ô¨Çow links will quotient any types and aspects that are
connected through the common ground allowing for the approprate interac-
tion in the fusion consequence (dir(Œπ1)(E1)‚à™dir(Œπ2)(E2))‚Ä¢, then the inverse
Ô¨Çow will reconnect this with the component types and aspects.
4.4. Conceptual graphs. The conceptual graph formalism (CG) for knowledge
representation [Sow2], was initially formulated to represent database systems (DBS),
but is now used in natural language processing (NLP) and Ô¨Årst-order logic (FOL).
Verbs in NLP can often be represented relationally by star(-shaped conceptual)
graphs. For example, the sentence ‚ÄúJohn is going to Boston by bus‚Äù might be
represented by the conceptual graph
Person: John
'& %$
 ! "#
go
1
o
3

2
/ City: Boston
Bus
(22)
In a sentence of natural language, thematic roles are semantic descriptions of the
way (the entities described by) a noun phrase functions with respect to (the action
of) the verb. These entities are the participants in the occurrent expressed by the
verb. For the action of ‚Äògoing‚Äô in the above sentence there are three participants
and hence three thematic roles. ‚ÄòJohn‚Äô plays the role of the agent of the action,
a ‚ÄòBus‚Äô is the instrument used in the action and ‚ÄòBoston‚Äô is the destination of the
action. Translations using thematic roles can be used to align two ontologies with
respect to a common ground.
A CG-style translation of conceptual graph (22)
would replace the verb relation ‚Äògoing‚Äô with a concept ‚ÄòGo‚Äô and replace the edges
that form the signature of the ‚Äògoing‚Äô relation with binary relations for the three

30
DAVID I. SPIVAK AND ROBERT E. KENT
roles ‚Äòagent‚Äô, ‚Äòinstrument‚Äô and ‚Äòdestination‚Äô.
Person: John
'&
%$
 !
"#
agent
o
Go
o

/'&
%$
 !
"#
dest
/ City: Boston
'&
%$
 !
"#
inst

Bus
(23)
However, the case relations that semantically describe the thematic roles should be
viewed as functional in nature; that is, for any instance of the action of a sentence‚Äôs
verb there is a unique entity described by a noun phrase of the sentence. When
this semantics is respected, the translation to thematic roles becomes a process
of ‚Äúlinearization‚Äù, which is best described abstractly as: (1) the identiÔ¨Åcation of
relation types with entity types, (2) the translation of a sorted multiarity relation to
a span of functions, one function for each role, and (3) the functional interpretation
of thematic roles.
The Olog formalism, which also represents DBS and NLP, is a version of equa-
tional logic. Both the Olog and CG formalisms were designed as graphical rep-
resentations. However, the CG formalism is binary and relational, whereas the
Olog formalism is unary and functional. The CG formalism is binary since it has
two kinds of type, concepts and relations; it is relational in the way it interprets
edges. The Olog formalism is unary since it has only one kind of type, the abstract
concept; it is functional in the way it interprets aspects (edges). However, much
of the semantics of the CG formalism can be transformed to the Olog formalism
by the process of linearization23, thereby gaining in eÔ¨Éciency and conciseness. For
example, conceptual graph (22) can be linearized to the olog graph24
1
John / Person
Go
agent
o
inst

dest / City
1
Boston
o
Bus
(24)
Since olog aspects are interpreted functionally, the functional nature of thematic
roles is respected. In this manner, the olog formalism could be used to replace
the CG representation of ontologies.
For example, a community (acting as an
individual) could build its ontology C from ground up by aligning it with some top-
level reference ontology T (such as in the appendix of [Sow2]), thereby importing
some formal semantics from T .
The following fragment demonstrates how this
works.
Assume that ontology T contains the concept of ‚Äúspatial process‚Äù as represented
by the general concept type ‚åúSpatial-Process‚åùwith aspects ‚åúSpatial-Process‚åù
agent
‚àí‚àí‚àí‚Üí
‚åúAgent‚åù, ‚åúSpatial-Process‚åù
inst
‚àí‚àí‚Üí‚åúVehicle‚åùand ‚åúSpatial-Process‚åù
dest
‚àí‚àí‚Üí‚åúLocation‚åù.
At some stage assume that the community ontology C has speciÔ¨Åed the concept
type orderings ‚åúPerson‚åù‚â§‚åúAgent‚åù, ‚åúBus‚åù‚â§‚åúVehicle‚åùand ‚åúCity‚åù‚â§‚åúLocation‚åù
with corresponding injective aspects ‚åúPerson‚åù
is‚àí‚Üí‚åúAgent‚åù, ‚åúBus‚åù
is‚àí‚Üí‚åúVehicle‚åùand
23The linearization process works for any binary/relational knowledge representation, such as
CGs, entity-relationship data modelling [JRW], relational database systems [Ken5] or the Infor-
mation Flow Framework [IFF1]. In the entity-relationship data modelling, n-ary relationship links
are replaced by n-ary spans of aspects and attributes are included as types.
24‚åú1‚åùis the universal type to which all types have a unique aspect.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
31
‚åúCity‚åù
is‚àí‚Üí‚åúLocation‚åù. At the next stage it could deÔ¨Åne a concept type ‚åúC‚åùwith as-
pects ‚åúC‚åù
person
‚àí‚àí‚àí‚àí‚Üí‚åúPerson‚åù, ‚åúC‚åù
bus
‚àí‚àí‚Üí‚åúBus‚åùand ‚åúC‚åù
city
‚àí‚àí‚Üí‚åúCity‚åù, and link it with
the reference ontology concept ‚åúSpatial-Process‚åùby specifying a connecting aspect
‚åúC‚åù
process
‚àí‚àí‚àí‚àí‚Üí‚åúSpatial-Process‚åùand asserting the facts ‚Äòperson ; is = process ; agent‚Äô,
‚Äòbus ; is = process ; vehicle‚Äô and ‚Äòcity ; is = process ; location‚Äô.25 In the more ex-
pressive ologs with joins (Section 5), the process concept of ‚Äúgoing to city by bus‚Äù
can then be deÔ¨Åned as the pullback of the ‚Äúspatial process‚Äù concept: here, the
concept type ‚åúGo‚åùwith aspects ‚åúGo‚åù
person
‚àí‚àí‚àí‚àí‚Üí‚åúPerson‚åù, ‚åúGo‚åù
bus
‚àí‚àí‚Üí‚åúBus‚åùand
‚åúGo‚åù
city
‚àí‚àí‚Üí‚åúCity‚åùis pulled back along the above injective aspects, resulting in the
injective aspect ‚åúGo‚åù
is‚àí‚Üí‚åúSpatial-Process‚åùwith corresponding concept type order-
ing ‚åúGo‚åù‚â§‚åúSpatial-Process‚åù. As a result, the concept ‚åúC‚åùhas the new mediating
aspect C
going
‚àí‚àí‚àí‚ÜíGo, which satisÔ¨Åes the fact ‚Äògoing ; is = process‚Äô. In this manner
the community ontology C has been enlarged.
C
T
C
person
															
bus

city
33333333333333
going
/
process
(
Go
person
wooooooooooooooooooooooooooo
bus
|yyyyyyyyyyyyyyyyyyy
city

is
/
¬∑
Spatial-Process
agent
                 inst

dest
 @
@
@
@
@
@
@
@
@
@
@
@
@
@
@
@
@
¬∑
Person
is
6
Bus
is
6
City
is
5
¬∑
Agent
Vehicle
Location
|
{z
}
P
We assume that community ontology C and reference ontology T are combined into
a portal ontology P with portal link C
P‚àí‚ÜíP and alignment link T
A
‚àí‚ÜíP. If some
other ontology C‚Ä≤ is built up and aligned in the same fashion, then T is being used
as a common ground, and we have a ‚ÄòW‚Äô-shaped information system
C
P
>
>
>
>
>
>
>
T
A

A‚Ä≤
 @
@
@
@
@
@
@
@
C‚Ä≤
P ‚Ä≤
~}}}}}}}
P
P‚Ä≤
(25)
with portals P and P‚Ä≤ being the Ô¨Ånal parts. This ‚ÄòW‚Äô-shaped information system
uses the sketch institution Sk for ologs. It can be compared to the ‚ÄòW‚Äô-shaped
information system in [Ken1], which uses the information Ô¨Çow IF institution for
(local) logics.
5. More expressive ologs I
In this section and the next (5 and 6) we will introduce limits and colimits
within the context of ologs. These will allow authors to build ologs that are quite
25The symbol ‚Äò;‚Äô denotes concatenation or formal composition.

32
DAVID I. SPIVAK AND ROBERT E. KENT
expressive. For example we can declare one type to be the union or intersection
of other types. We do not assume mathematical knowledge beyond that of sets
and functions, which were loosely deÔ¨Åned in Section 2.2. However, the reader may
beneÔ¨Åt by consulting a reference on category theory, such as [Awo].
The basic ologs discussed in previous sections are based on the mathematical
notion of categories, whereas the olog presentation language we will discuss in this
section and the next are based on general sketches (see [Mak]). The diÔ¨Äerence is
in what can be expressed: in basic ologs we can declare types, aspects, and facts,
whereas in general ologs we can express ideas like products and sums, as we will
see below.
We will begin by discussing layouts, which will be represented categorically by
‚ÄúÔ¨Ånite limits‚Äù. As usual, the english terminology (layout) is not precise enough to
express the notion we mean it to express (limit). Intuitively, a limit can be thought
of as a system: it is a collection of units, each of a speciÔ¨Åc type, such that these
units have compatible aspects. These will include types like ‚åúa man and a woman
with the same last name‚åù. In Section 6 we will discuss groupings, which will be
represented by colimits. These will include types like ‚åúa thing that is either a pear
or a watermelon‚åù.
5.1. Layouts. A dictionary might deÔ¨Åne the word layout as something like ‚Äúa
structured arrangement of items within certain limits; a plan for such arrangement.‚Äù
In other words, we can lay out or specify the need for a set of parts, each of a
given type, such that the parts Ô¨Åt together well. This idea roughly corresponds
to the notion of limits in category theory, especially limits in the category of sets.
Given a diagram of sets and functions, its limit is the set of ways to accordingly
choose one element from each.
For example, we could have a type ‚åúa car and
a driver‚åù, which category-theoretically is a product, but which we are calling a
‚Äúlayout‚Äù ‚Äî a compound type whose parts are ‚Äúlaid out.‚Äù Of course, the term layout
is insuÔ¨Écient to express the precise meaning of limits, but it will have to do for
now. To understand limits, one really only need understand pullbacks and products.
These will be the subjects of Sections 5.2 and 5.3, or one can see [Awo] for more
details.
5.2. Pullbacks. Given three objects and two arrows arranged as to the left, the
pullback is the commutative square to the right:
Given:
C
g

B
f
/ D
the pullback is drawn:
A
f ‚Ä≤
/
g‚Ä≤

C
g

B
f
/ D.
We write A = B √óD C and say ‚ÄúA is the pullback of B and C over D.‚Äù The question
is, what does it signify? We will begin with some examples and then give a precise
deÔ¨Ånition.
Example 5.2.1. We will now give four examples to motivate the deÔ¨Ånition of pull-
back. In the Ô¨Årst example, (26), both B and C will be subtypes of D, and in such
cases the pullback will be their intersection. In the next two examples (27 and
28), only B will be a subtype of D, and in such cases the pullback will be the
‚Äúcorresponding subtype of C‚Äù (as should make sense upon inspection). In the last

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
33
example (29), neither B nor C will be a subtype of D. In each line below, the
pullback of the diagram to the left is the diagram to the right. The reader should
think of the left-hand olog as a kind of problem to which the new box A in the
right-hand olog is a solution.

34
DAVID I. SPIVAK AND ROBERT E. KENT
C
a loyal
customer
is

B
a wealthy
customer
is
/
D
a customer
A=B√óDC
a customer
that is wealthy
and loyal
is

is
/
C
a loyal
customer
is

B
a wealthy
customer
is
/
D
a customer
(26)
C
blue
is

B
a person
has as
favorite color /
D
a color
A=B√óDC
a person
whose favorite
color is blue
is

has as
favorite color
/
C
blue
is

B
a person
has as
favorite color
/
D
a color
(27)
C
a woman
is

B
a dog
has as owner
/
D
a person
A=B√óDC
a dog whose
owner is a
woman
is

has as owner /
C
a woman
is

B
a dog
has as owner
/
D
a person
(28)
C
a piece of
furniture
has

B
a space in
our house
has
/
D
a width
A=B√óDC
a pair (f, s)
where f is a piece
of furniture and s
is a space in our
house, and where
f and s have the
same width
s

f
/
C
a piece of
furniture
has

B
a space in
our house
has
/
D
a width
(29)

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
35
See Example 5.2.3 for a justiÔ¨Åcation of these, in light of DeÔ¨Ånition 5.2.2.
The following is the deÔ¨Ånition of pullbacks in the category of sets. For an olog,
the instance data are given by sets (at least in this paper, see Section 3), so this
deÔ¨Ånition suÔ¨Éces for now. See [Awo] for more details on pullbacks.
DeÔ¨Ånition 5.2.2. Let B, C, and D be sets, and let f : B ‚ÜíD and g: C ‚ÜíD be
functions. The pullback of B
f‚àí‚ÜíD
g‚Üê‚àíC, denoted B √óD C, is deÔ¨Åned to be the set
B √óD C := {(b, c) | b ‚ààB, c ‚ààC, and f(b) = g(c)}
together with the obvious maps B √óD C ‚ÜíB and B √óD C ‚ÜíC, which send an
element (b, c) to b and to c, respectively. In other words, the pullback of B
f‚àí‚ÜíD
g‚Üê‚àí
C is a commutative square
B √óD C
/

C
g

B
f
/ D.
Example 5.2.3. In Example 5.2.1 we gave four examples of pullbacks. For each,
we will consider B
f‚àí‚ÜíD
g‚Üê‚àíC to be sets and functions as in DeÔ¨Ånition 5.2.2 and
explain how the set A follows that deÔ¨Ånition, i.e. how its label Ô¨Åts with the set
B √óD C = {(b, c) | b ‚ààB, c ‚ààC, and f(b) = g(c)}.
In the case of (26), the set B √óD C should consist of pairs (w, l) where w is a
wealthy customer, l is a loyal customer, and w is equal to l (as customers). But if
w and l are the same customer then (w, l) is just a customer that is both wealthy
and loyal, not two diÔ¨Äerent customers. In other words, an instance of the pullback
is a customer that is both loyal and wealthy, so the label of A Ô¨Åts.
In the case of (27), the set B √óD C should consist of pairs (p, b) where p is a
person, b is the color blue, and the favorite color of p is equal to b (as colors). In
other words, it is a person whose favorite color is blue, so the label of A Ô¨Åts. If
desired, one could instead label A with ‚åúa pair (p, b) where p is a person, b is blue,
and the favorite color of p is b‚åù.
In the case of (28), the set B √óD C should consist of pairs (d, w) where d is a
dog, w is a woman, and the owner of d is equal to w (as people). In other words,
it is a dog whose owner is a woman, so the label of A Ô¨Åts. If desired, one could
instead label A with ‚åúa pair (d, w) where d is a dog, w is a woman, and the owner
of d is w‚åù.
In the case of (29), the set B √óD C should consist of pairs (f, s) where f is a
piece of furniture, s is a space in our house, and the width of f is equal to the width
of s. This is Ô¨Åts perfectly with the label of A.
5.2.4. Using pullbacks to classify. To distinguish between two things, one must
Ô¨Ånd a common aspect of the two things for which they have diÔ¨Äering results. For
example, a pen is diÔ¨Äerent from a pencil in that they both use some material to
write (a common aspect), but the two materials they use are diÔ¨Äerent. Thus the
material which a writing implement uses is an aspect of writing implements, and
this aspect serves to segregate or classify them. We can think of three such writing-
materials: graphite, ink, and pigment-wax. For each, we will make a layout in the

36
DAVID I. SPIVAK AND ROBERT E. KENT
olog below:
A1=B√óDC1
a writing imple-
ment that uses
graphite
uses
/
is

C1
graphite
is

A2=B√óDC2
a writing imple-
ment that uses
ink
uses
/
is

C2
ink
is

A3=B√óDC3
a writing imple-
ment that uses
pigment-wax
uses
/
is

C3
pigment-wax
is

B
a writing implement
uses
/
D
a writing material
One could also replace the label of box A1 with ‚Äúa pencil‚Äù, the label of box A2
with ‚Äúa pen‚Äù, and the label of box A3 with ‚Äúa crayon‚Äù; in so doing, the layouts at
the top would deÔ¨Åne a pencil, a pen, and a crayon to be a writing implement that
uses respectively graphite, ink, and pigment-wax.
5.2.5. Building pullbacks on pullbacks. There is a theorem in category theory which
states the following. Suppose given two commutative squares
1
/

3
/

‚åü
5

2
/ 4
/ 6
such that the right-hand square (3,4,5,6) is a pullback. It follows that if the left-
hand square (1,2,3,4) is a pullback then so is the big rectangle (1,2,5,6). It also
follows that if the big rectangle (1,2,5,6) is a pullback then so is the left-hand square
(1,2,3,4). This fact can be useful in authoring ologs.
For example, the type ‚åúa cellphone that has a bad battery‚åùis vague, but we can
lay out precisely what it means using pullbacks:
A=B√óDC
a cellphone that
has a bad battery
/

C=D√óF E
a bad battery
/

E=F √óHG
less than
1 hour
/

G
between
0 and 1

B
a cellphone
has
/
D
a battery
remains
charged
for
/
F
a duration
of time
in hours
yields /
H
a range of
numbers

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
37
The category-theoretic fact described above says that since A = B √óD C and
C = D √óF E, it follows that A = B √óF E. That is, we can decuce the deÔ¨Ånition ‚Äúa
cellphone that has a bad battery is deÔ¨Åned as a cellphone that has a battery which
remains charged for less than one hour.‚Äù In other words, A = B √óF E.
5.3. Products. Given a set of types (boxes) in an olog, one can select one in-
stance from each.
All the ways of doing just that comprise what is called the
product of these types. For example, if A = ‚åúa number between 1 and 10‚åùand
B = ‚åúa letter between x and z‚åù, the product includes a total of 30 elements, in-
cluding (4, z). We are ready for the deÔ¨Ånition.
DeÔ¨Ånition 5.3.1. Given sets A, B, their product, denoted A √ó B, is the set
A √ó B = {(a, b) | a ‚ààA and b ‚ààB}.
There are two obvious projection maps A √ó B ‚ÜíA and A √ó B ‚ÜíB, sending the
pair (a, b) to a and to b respectively.
Example 5.3.2. In Example 5.2.1, (29) we presented the idea of a piece of furniture
that was the same width as a space in the house. What if we say that ‚åúa nice
furniture placement‚åùis any space that is between 1 and 8 inches bigger than a
piece of furniture? We can use a combination of products and pullbacks to create
the appropriate type.
A=B√óDC
a nice furniture
placement

/
C
a pair of widths
(w1, w2) such that
1 ‚â§w2 ‚àíw1 ‚â§8

B1
a piece of
furniture
‚úì
has /
D1
a width
B=B1√óB2
a pair (f, s)
where f is a piece
of furniture and s
is a space in the
house
s
#H
H
H
H
H
H
f
;v
v
v
v
v
v
f7‚Üíw1, s7‚Üíw2
/
D=D1√óD2
a pair of widths
(w1, w2)
w1
bEEEEEEEEEEEE
w2
|yyyyyyyyyyyy
B2
a space in
the house
‚úì
has /
D2
a width
Here B and D are products and A is a pullback. This olog lays out what it means
to be ‚Äúa nice furniture placement‚Äù using products. The bottom horizontal aspect
B ‚ÜíD is an example of a map obtained by the ‚Äúuniversal property of products‚Äù;
see Section 5.6.

38
DAVID I. SPIVAK AND ROBERT E. KENT
5.3.3. Products of more (or fewer) types. The product of two sets A and B was
deÔ¨Åned in 5.3.1. One may also take the product of three sets A, B, C in a similar
way, so the elements are triples (a, b, c) where a ‚ààA, b ‚ààB, and c ‚ààC. In fact this
idea holds for any number of sets. It even makes sense to take the product of one
set (just A) or no sets! The product of one set is itself, and the product of no sets
is the singleton set {‚àó}. For more on this, see Section 5.5 or [Mac].
5.4. Declaring an injective aspect. A function is called injective if diÔ¨Äerent
inputs always yield diÔ¨Äerent outputs. For example the function that doubles every
integer (x 7‚Üí2x) is injective, whereas the function that squares every integer (x 7‚Üí
x2) is not because 32 = (‚àí3)2. An example of an injective aspect is ‚åúa woman‚åù
is‚àí‚Üí
‚åúa person‚åùbecause diÔ¨Äerent women are always diÔ¨Äerent as people. An example of a
non-injective aspect is ‚åúa person‚åù
has as father
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí‚åúa person‚åùbecause diÔ¨Äerent people
may have the same father.
The easiest way to indicate that an aspect is injective is to use a ‚Äúhook arrow‚Äù
as in f : A ÷í‚ÜíB, instead of a regular arrow f : A ‚ÜíB, to denote it. For example,
the Ô¨Årst map is injective (and speciÔ¨Åed as such with a hook-arrow), but the second
is not in the olog:
a person  
has / a personality
can be classiÔ¨Åed
as being of
/ a personality type
The author of this olog believes that no two people can have precisely the same
personality (though they may have the same personality type).
We include injective aspects in this section because it turns out that injectivity
can also be speciÔ¨Åed by pullbacks. See [nL1] for details.
5.5. Singletons types. A singleton set is a set with one element; it can be consid-
ered the ‚Äúempty product.‚Äù In other words if we denote An = A √ó A √ó ¬∑ ¬∑ ¬∑ A (where
A is written n times), then A0 is the empty product and is a singleton set. One can
specify that a certain type has only one instance by annotating it with A = {‚àó} in
the olog. For example the olog
A={‚àó}
God
is
/
B
a good thing
says that the author considers ‚åúGod‚åùto be single. As a more concrete example, the
intersection of {x ‚ààR | x ‚â•0} and {y ‚ààR | x ‚â§0} is a singleton set, as expressed
in the olog
A=B√óDC={‚àó}
a real number z
such that z ‚â•0
and z ‚â§0
x=z /
y=z

C
a real number x
such that x ‚â•0
is

B
a real number y
such that y ‚â§0
is
/
D
a real number

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
39
The fact that A = B √óD C and A = {‚àó} are declared indicates that there is only
one possible instance of a real number that is in both B and C.
5.6. The universal property of layouts. We cannot do the notion of universal
properties justice in this paper, but the basic idea is as follows. Suppose that D
is an olog, that D1, D2 are types in it, and that D = D1 √ó D2 (together with its
projection maps p1 : D ‚ÜíD1 and p2 : D ‚ÜíD2) is their product.
D1 √ó D2
p2
@
@
@
@
@
@
@
@
p1
~~~~~~~~
D1
D2
(30)
The so-called universal property of products should be thought of as ‚Äúan existence
and uniqueness‚Äù claim in D. Namely, for any type X with maps f : X ‚ÜíD1 and
g: X ‚ÜíD2, there is exactly one possible map m: X ‚ÜíD such that the facts
f = m; p1 and g = m; p2 hold.
X
g
%K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
f
2222222222
X
f
2222222222
g
(Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
Q
m
/ D1 √ó D2
p1

p2
:::::::::::
‚ùÄ
D1
D2
D1
D2
(31)
This may sound esoteric, but consider the following example.
The following olog is similar to the one in Example 5.3.2
B1
a piece of
furniture
has
/
C1
a width
‚úì
is, in
inches /
D1
a number
B=B1√óB2
a pair (f, s)
where f is a piece
of furniture and s
is a space in the
house
s 
f
O
/
D=D1√óD2
a pair of num-
bers (w1, w2)
w1
O
w2

B2
a space in
the house
has
/
C2
a width
‚úì
is, in
inches /
D2
a number
Here the only unlabeled map is the horizontal one B ‚ÜíD; how can we get away
with leaving it unlabeled? How does a piece of furniture and a space in the house
yield a pair of numbers? The answer is that B has a map to D1 (the path across
the top) and a map to D2 (the path across the bottom), and hence the universal
property of products gives a unique arrow B ‚ÜíD such that the two facts indicated
by checkmarks hold. (In terms of (30) and (31) we are using X = B.) In other
words, there is exactly one way to take a piece of furniture and a space in the house
and yield a pair of numbers if we enforce that the Ô¨Årst number is the width in inches

40
DAVID I. SPIVAK AND ROBERT E. KENT
of the piece of furniture and the second number is the width in inches of the space
in the house.
At this point we hope it is clear that the universal property of products is a
useful and constructive one. We will not describe the other universal properties
(either for pullbacks, singletons, or any colimits); as mentioned above they can be
found in [Awo].
6. More expressive ologs II
In this section we will describe various colimits, which are in some sense dual to
limits. Whereas limits allow one to ‚Äúlay out‚Äù a team consisting of many diÔ¨Äerent
interacting or non-interacting parts, colimits allow one to ‚Äúgroup‚Äù diÔ¨Äerent types
together. For example, whereas the product of ‚åúa number between 1 and 10‚åùand
‚åúa letter between x and z‚åùhas 30 elements (such as (3, y)), the coproduct of these
two types has 13 elements (including 4). Just as ‚Äúlayout‚Äù is a too weak a word to
capture the essence of limits, ‚Äúgrouping‚Äù is too weak a word to capture the essence
of colimits, but it will have to do.
We will start by describing coproducts or ‚Äúdisjoint unions‚Äù in Section 6.1. Then
we will describe pushouts in Section 6.2, wherein one can declare some elements in
a union to be equivalent to others. There is a category-theoretic duality between
coproducts and products and between pushouts and pullbacks.
It extends to a
duality between surjections and injections and a duality between empty types and
singleton types, the subject of Sections 6.3 and 6.4. The interested reader can see
[Awo] for details.
6.1. Coproducts. Coproducts are also called ‚Äúdisjoint unions.‚Äù If A and B are
sets with no members in common, then the coproduct of A and B is their union.
However, if they have elements in common, one must include both copies in A ‚àêB
and diÔ¨Äerentiate between them. Here is a deÔ¨Ånition.
DeÔ¨Ånition 6.1.1. Given sets A and B, their coproduct, denoted A ‚àêB, is the set
A ‚àêB = {(a, ‚ÄúA‚Äù) | a ‚ààA} ‚à™{(b, ‚ÄúB‚Äù) | b ‚ààB}.
There are two obvious inclusion maps A ‚ÜíA ‚àêB and B ‚ÜíA ‚àêB, sending a to
(a, ‚ÄúA‚Äù) and b to (b, ‚ÄúB‚Äù), respectively.
If A and B have no elements in common, then the one can drop the ‚ÄúA‚Äù and ‚ÄúB‚Äù
labels without changing the set A ‚àêB in a substantial way. Here are two examples
that should make the coproduct idea clear.
Example 6.1.2. In the following olog the types A and B are disjoint, so the coproduct
C = A ‚àêB is just the union.
A
a person
is
/
C=A‚àêB
a person or a cat
B
a cat
is
o

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
41
Example 6.1.3. In the following olog, A and B are not disjoint, so care must be
taken to diÔ¨Äerentiate common elements.
A
an animal
that can Ô¨Çy
labeled ‚ÄúA‚Äù is /
C=A‚àêB
an animal that can Ô¨Çy
(labeled ‚ÄúA‚Äù) or an
animal that can swim
(labeled ‚ÄúB‚Äù)
B
an animal that
can swim
labeled ‚ÄúB‚Äù is
o
Since ducks can both swim and Ô¨Çy, each duck is found twice in C, once labeled as
a Ô¨Çyer and once labeled as a swimmer. The types A and B are kept disjoint in C,
which justiÔ¨Åes the name ‚Äúdisjoint union.‚Äù
6.2. Pushouts. Pushouts can express unions in which an overlap is declared. They
can also express ‚Äúquotients,‚Äù where diÔ¨Äerent objects can be declared equivalent.
Given three objects and two arrows arranged as to the left, the pushout is drawn
as the commutative square to the right:
Given:
A
g
/
f

C
B
the pushout is drawn:
A
g
/
f

C
f ‚Ä≤

B
g‚Ä≤
/ D.
We write D = B‚àêAC and say ‚ÄúD is the pushout of B and C along A.‚Äù The question
is, what does it signify?
The idea is that an instance of the pushout B ‚àêA C is any instance of B or any
instance of C, but where some instances are considered equivalent to others. That
is, for any instance of A, its B-aspect is considered the same as its C-aspect. This
is formalized in DeÔ¨Ånition 6.2.2 after being exempliÔ¨Åed in Example 6.2.1.
Example 6.2.1. In each example below, the diagram to the right is the pushout of
the diagram to the left. The new object, D, is the union of B and C, but instances
of A are equated to their B and C aspects. This will be discussed after the two
diagrams.

42
DAVID I. SPIVAK AND ROBERT E. KENT
A
a cell in the
shoulder
is
/
is

C
a cell in
the arm
B
a cell in the
torso
A
a cell in the
shoulder
is
/
is

C
a cell in
the arm

B
a cell in the
torso
/
D=B‚àêAC
a cell in the
torso or arm
(32)
A
a college
mathematics
course
yields/
is 
C
an utterance
of the phrase
‚Äútoo hard‚Äù
B
a college
course
A
a college
mathematics
course
yields /
is

C
an utterance
of the phrase
‚Äútoo hard‚Äù

B
a college
course
/
D = B‚àêA C
a college course,
where every
mathematics
course is
replaced by an
utterance of the
phrase ‚Äútoo
hard‚Äù
(33)
In Olog (32), the shoulder is seen as part of the arm and part of the torso. When
taking the union of these two parts, we do not want to ‚Äúdouble-count‚Äù the shoulder
(as would be done in the coproduct B ‚àêC, see Example 6.1.3). Thus we create a
new type A for cells in the shoulder, which are considered the same whether viewed
as cells in the arm or cells in the body. In general, if one wishes to take two things
and glue them together, the glue serves as A and the two things serve as B and C,
and the union (or grouping) is the pushout B ‚àêA C.
In Olog (33), if every mathematics course is simply ‚Äútoo hard,‚Äù then when reading
oÔ¨Äa list of courses, each math course will not be read aloud but simply read as ‚Äútoo
hard.‚Äù To form D we begin by taking the union of B and C, and then we consider
everything in A to be the same whether one looks at it as a course or as the phrase
‚Äútoo hard.‚Äù The math courses are all blurred together as one thing. Thus we see
that the power to equate diÔ¨Äerent things can be exercised with pushouts.
DeÔ¨Ånition 6.2.2. Let A, B, and C be sets and let f : A ‚ÜíB and g: A ‚ÜíC be
functions. The pushout of B
f‚Üê‚àíA
g‚àí‚ÜíC, denoted B ‚àêA C, is the quotient of B ‚àêC
(see DeÔ¨Ånition 6.1.1) by the equivalence relation generated by declaring b ‚àºc (i.e.
b is equivalent to c) if: b ‚ààB, c ‚ààC, and there exists a ‚ààA with f(a) = b and
g(a) = c.
6.3. Declaring a surjective aspect. A function f : A ‚ÜíB is called surjective
if every value in B is the image of something in the domain A.
For example,

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
43
the function which subtracts 1 from every integer (x 7‚Üíx ‚àí1) is surjective, be-
cause every integer has a successor; whereas the function that doubles every integer
(x 7‚Üí2x) is not surjective because odd numbers are not mapped to. The aspect is
‚åúa published paper‚åù
was published in
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí‚åúan established journal‚åùis surjective because
every established journal has had at least one paper published in it. The aspect is
‚åúa published paper‚åù
has as Ô¨Årst author
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí‚åúa person‚åùis not surjective because not every
person is the Ô¨Årst author of a published paper.
The easiest way to indicate that an aspect is surjective is to denote it with a
‚Äútwo-headed arrow‚Äù as in f : A ÷â B. For example, the second map is surjective
(and indicated with a two-headed arrow) in the olog
a person
has / a personality
can be classiÔ¨Åed
as being of
/ / a documented
personality type
Here the Ô¨Årst aspect is not considered surjective, presumably because the author
imagines personalities had by no person.
We include surjective aspects in this section because it turns out that surjectivity
can also be speciÔ¨Åed by pushouts. See [nL2] for details.
6.4. Empty types. The empty set is a set with no elements; it can be considered
the ‚Äúempty coproduct.‚Äù In other words if we denote n ‚àóA = A ‚àêA ‚àê¬∑ ¬∑ ¬∑ ‚àêA (where
A is written n times), then 0 ‚àóA is the empty coproduct and is the empty set.
One can declare a type to be empty by annotating it with A = ‚àÖin the olog. For
example the olog
A=‚àÖ
a supernatural being
says that the set of supernatural beings is empty. As a more concrete example, the
intersection of positive numbers and negative numbers is empty, as expressed in the
olog
A=B√óDC=‚àÖ
a real number z
such that z < 0
and z > 0
/

C
a real number x
such that x > 0
is

B
a real number y
such that y < 0
is
/
D
a real number
6.5. Images. In what remains of Section 6, we will discuss how the ideas of this
section and the previous (Section 5) can be used together to create quite expressive
ologs. First we will discuss how each aspect f : A ‚ÜíB has an ‚Äúimage,‚Äù the subset of
B that are ‚Äúhit‚Äù by f. Then, in Sections 6.6 and 6.7, we will discuss how ologs can
express all primitive recursive functions and many other mathematical concepts.

44
DAVID I. SPIVAK AND ROBERT E. KENT
Consider the olog
X
a pair (p, c) where p is a
person, c is a computer,
and p owns c
p
xqqqqqqqqqqq
c
'N
N
N
N
N
N
N
N
N
N
N
Y
a person
Z
a computer
(34)
Some people own more than one computer, and some computers are owned by more
than one person. Some computers are not owned by a person, and some people do
not own a computer. The purpose of this section is to show how to use ologs to
capture ideas such as ‚Äúa person who owns a computer‚Äù and ‚Äúa computer that is
owned by a person‚Äù. These are called the images of p and c respectively.
Every aspect has an image, and these are quite important for human under-
standing. For example the image of the map ‚åúa person‚åù
has as father
‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚Üí‚åúa person‚åùis
the type ‚åúa father‚åù. In other words, a father is deÔ¨Åned to be a person x for which
there is some other person y such that x is the father of y.
The image of a function f : A ‚ÜíB is a commutative diagram (fact)
A
f
/
fs
" "E
E
E
E
E
E
E
E
‚úì
B
im(f)
-
fi
<y
y
y
y
y
y
y
y
where fs is surjective and fi is injective (see Sections 6.3 and 5.4). We indicate that
a type is the image of a map f by annotating it with Im(f), as in the following
olog:
A
a child
has as parents /

f
%K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
K
B
a pair (w, m) where w is
a woman and m is a man
‚úì
m

C=Im(f)
a father
 
is
/
‚úì
D
a man
Hopefully it is also clear that ‚åúa person who owns a computer‚åùand ‚åúa computer
that is owned by a person‚åùare the images of p: X ‚ÜíY and c: X ‚ÜíZ (respectively)
in Olog (34).
Using the label Im(f) is the easiest way to indicate an image, although one
can also do so categorically using limits and colimits. See [Mac, Chapter VIII] for
details.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
45
6.6. Application: Primitive recursion. We have already seen how ologs can be
used to express a conceptual understanding of a situation (all the ologs thus far ex-
emplify this idea). In this section we hope to convince the reader that ologs are also
able to express certain computations. In particular we will show by example that
primitive recursive functions (like factorial or Ô¨Åbonacci) can be expressed by ologs.
In this way, we can to put computation and knowledge representation together into
the same framework. It would be quite valuable to strengthen this connection by
showing that Ologs (or an extension thereof) can express any recursive function
(i.e. simulate Turing machines). This is an open research possibility.
Example 6.6.1. In this example we will present an olog that can represent the
‚ÄúFactorial function,‚Äù often denoted n 7‚Üín!, where for example the factorial of 4 is
24. Recall that a natural number is any nonnegative whole number: 0, 1, 2, 3, 4, . . ..
f(n) = n!
s; p = idA
s; q = d; f
i0; f = œâ
i1; f = s; m
A
a positive
natural number
s
1
d

i1

B=A√óD
a pair (p, q) where p
is a positive natural
number and q is a
natural number
p
o
q

m

C=A‚àêE
a natural number
f
/
D
a natural number
E
zero
i0
O
œâ
4h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
h
The idea of this olog is to convey the factorial function as follows. A natural
number is either zero or positive. Every positive natural number n has a decrement,
n ‚àí1. The factorial of zero is 1. The factorial of a positive number n is obtained
by multiplying n by the factorial of n ‚àí1.
To more explicitly describe the above olog, we must describe its intended in-
stances. Hopefully the instances of each type (A through E) are self-explanatory,
so we will describe the grouping, the layout, the aspects, and the facts. The set of
natural numbers is the disjoint union of zero and the set of positive natural numbers
and the maps i0 and i1 are the inclusions into the coproduct, which explains the
grouping C = A ‚àêE. The layout B = A √ó D is self-explanatory, and the maps
p and q are the projections from the product. The map d is the decrement map
n 7‚Üín ‚àí1, the map œâ sends 0 to 1, the map m is multiplication (n, n‚Ä≤) 7‚Üín ‚àón‚Ä≤.
Once m, d, and œâ are so-deÔ¨Åned, the Ô¨Årst two facts (s; p = idA and s; q = d; f)
specify that s sends n to the pair (n, f(d(n))), and the second two facts specify
that f sends 0 to 1 and sends a positive number n to m(s(n)) = m(n, f(d(n))), i.e.
n goes to the product n ‚àó(n ‚àí1)!.

46
DAVID I. SPIVAK AND ROBERT E. KENT
The above olog deÔ¨Ånes the factorial function (f) in terms of itself, which is the
hallmark of primitive recursion. Note, however, that this same olog can compute
many things besides the factorial function. That is, nothing about the olog says that
the instances of ‚åúZero‚åùis the set {0}, that œâ sends 0 to 1, that d is the decrement
function, or that m is multiplication ‚Äî changing any of these will change f as a
function. For example, the same olog can be used to compute ‚Äútriangle numbers‚Äù
(e.g.
f(4)=1+2+3+4=10) by simply changing the instances of œâ and m in the
obvious ways (use œâ = 0, m = + rather than œâ = 1, m = ‚àó)).
For a radical
departure, Ô¨Åx any forest (set of graphical trees) F, let E = ‚åúzero‚åùrepresent its set
of roots, A the other nodes, œâ the constant 0 function, d the parent function, and
m sending (p, d(p)) to f(d(p))+1. Then for each tree in F and each node n in that
tree, the function f will send n to its height on the tree.
Primitive recursion is a powerful technique for deriving new functions from the
repetition of others using a kind of ‚Äúwhile loop.‚Äù The general form of primitive
recursive functions can be found in [BBJ], and it is not hard to imitate Example
6.6.1 for the general case.
6.7. Application:
deÔ¨Åning mathematical concepts. In this subsection we
hope to convince the reader that many mathematical concepts can be deÔ¨Åned by
ologs. This should not seem like much of a stretch: ologs describe relationships
between sets, so we rely on the maxim that all of mathematics can be formulated
within set theory. To make the idea explicit, however, we will recall the deÔ¨Ånition
of pseudo-metric space (in 6.7.1) and then provide an olog with the same content
(in 35).
DeÔ¨Ånition 6.7.1. Let R‚â•0 denote the set of non-negative real numbers. A pseudo-
metric space is a pair (X, Œ¥) where X is a set and Œ¥: X √ó X ‚ÜíR‚â•0 is a function
with the following properties for all elements x, y, z ‚ààX:
(1) Œ¥(x, x) = 0;
(2) Œ¥(x, y) = Œ¥(y, x); and
(3) Œ¥(x, z) ‚â§Œ¥(x, y) + Œ¥(y, z).

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
47
d0; y = d1; y
d2; z = d0; z
d1; z = d0; z
œÜ; z = y
œÜ; y = z
s; y = id7
s; z = id7
s;Œ¥=g;0
Œ¥ ; œÜ=Œ¥
d2;Œ¥ =f; a
d0;Œ¥ =f; b
d1;Œ¥ = f; c
1=5√ó75√ó75
a triple (x0, x1, x2) of points in X
d0

d1

d2

f
/
2
a triple (a, b, c) of non-
negative real numbers such
that c ‚â§a + b
c

b

a

3=5√ó75
a pair (y, z) of points in X
GF
@A
œÜ
4i
i
i
i
Œ¥
/
z

y

4
a non-negative real number
5
a point in X
X

s
O
g
/
6={‚àó}
{0}
0
O
7
a pseudo-metric space
(35)
As long as the instances for the right-hand side of this olog are mathematically
correct (i.e. we assign 4 the set of non-negative real numbers), this olog has the
same content as DeÔ¨Ånition 6.7.1. One can use ologs to deÔ¨Åne usual metric spaces
(in which Property (1) in DeÔ¨Ånition 6.7.1 is strengthened), but it would have taken
too much space here.
It should be clear that ologs provide a more precise and explicit description of
any concept, relying less on the grammar of English and more on the mathematical
‚Äúgrammar‚Äù of sets and functions. Assumptions are exposed as all the working parts
of an object need to be explicitly documented. Thus an olog is likely to be instantly
readable by a theorem prover such as Coq ([Coq]), at least if one creates the olog
within an appropriate Olog-Coq interface API. Moreover, various parts of this olog
may be reusable in other contexts, and hence connect pseudo-metric spaces into a
web of neighboring deÔ¨Ånitions and theorems.
In fact, once a corpus of mathematics has been written in olog form, evidence of
conjectures not yet proven could be written down as instance data. For example,
one could record every known prime as instances of a type ‚åúprime‚åùand a machine
could automatically check that Goldbach‚Äôs conjecture (written as an olog containing
‚åúprime‚åùas a type) holds for all example ‚Äúso far.‚Äù With deÔ¨Ånitions, theorems, and
examples all written in the same computer-readable language of ologs, one may
hope for much more advanced searching and knowledge retrieval by humans. For
example, one could formulate very precise questions as database queries and use
SQL on the database corresponding to a given olog (see Section 3.2).

48
DAVID I. SPIVAK AND ROBERT E. KENT
7. Further directions
Ologs are basically categories which have text labels to explain their intended
semantic. As such there are many directions to explore ranging from quite theoret-
ical to quite practical. Here we consider three main classes: extending the theory
of ologs, studying communication with ologs, and implementing ologs in the real
world.
7.1. Extending the theory of ologs. In this paper we began by discussing basic
ologs, which are rich enough to capture the semantic of many situations. In Sections
5 and 6 we added more expressivity to ologs to allow one to encode ideas such as
intersections, unions, and images. However, ologs could be even more expressive.
One could add ‚Äúfunction types‚Äù (also known as exponentials); add a ‚Äúsubobject
classiÔ¨Åer type,‚Äù which could allow for negation and complements as well as power-
sets; or even add Ô¨Åxed sets (like the set of Strings) to the language of ologs. This
is not too hard (using sketches, see [Mak]); the reason we did not include them in
this paper was more because of space than any other reason.
Another generalization would be to allow the instances of an olog to take values
in a category other than Set.
For example, one could have an instance-space
rather than an instance-set, e.g. it is clear that the instances of the type ‚åúa point
on the unit circle‚åùconstitute a topological space. One could similarly argue that
the instances of the type ‚åúa human invention‚åùhave a topology or metric as well
(e.g. as an invention, the cellphone is closer to the telephone than it is to artiÔ¨Åcial
Ô¨Çavoring). Instance data on an olog C corresponds to a functor C ‚ÜíSet in this
paper, but it is quite easy to replace Set with a diÔ¨Äerent category such as Top
(the category of topological spaces), and this may have interesting uses in data
modeling.
In Section 6.7, we explicitly showed that pseudo-metric spaces (and we stated
further that metric spaces) can be presented by ologs. It would be interesting to
see if theorems could also be proven entirely within the context of ologs. If so, a
teacher could Ô¨Årst sketch a mathematical proof as a small or sparse olog C, and
then use a functor C ‚ÜíD to rigorously ‚Äúzoom in‚Äù on that proof so that the sketch
becomes a full-Ô¨Çedged proof (as the maps in C are factored into understandable
units in D).
If ologs are to be viable venues in which to discuss results in mathematics, then
they should be capable of describing all recursion, not just primitive recursion (as
in Section 6.6). We do not yet have an understanding for how this can be done. If
recursion can be fully deÔ¨Åned with the ologs described above, it would be interesting
to see it written out; if not, it would be interesting to understand what basic idea
could be gracefully added to ologs so that recursion becomes expressible.
In a diÔ¨Äerent direction, one could test the expressive power of ologs by deÔ¨Åning
simple games, like Tic Tac Toe or Chess, using ologs. It would be impressive to
deÔ¨Åne a vocabulary for writing games and a program which could automatically
convert an olog-deÔ¨Åned game into a playable computer game. This would show that
the same theory that we have seen express ideas about fatherhood and factorials
can also be used to invent games and program computers.
7.2. Studying communication with ologs. As discussed in Section 4, ologs can
be connected by functors into networks that are not just 2-way, but n-way. These
communication networks should be studied: what kinds of information can pass,

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
49
how reliable is it, how quickly can it spread, etc. This may be applicable in Ô¨Åelds
from economics to psychology to sociology. Such research may use results from
established mathematics such as Network Coding Theory (see [YLC]).
In [SA], we study how two or more entities (described as ologs) can communicate
new ideas (not just new instance data) to each other. It would be interesting to
see how well this ‚Äúcommunication protocol‚Äù works in practice, and whether it can
be theoretically automated. Furthermore, this communication protocol and any
theoretical automation of it should be implemented on a computer to see if diÔ¨Äerent
database schemas can be meaningfully integrated with minimal human assistance.
It may be possible to train children to create ologs about their interests or about
a given lesson. These ologs would show how the child actually perceives something,
which would probably be fascinating. By our experience and that of people we have
taught, the process of building an olog usually leads to a clariÔ¨Åcation of the concepts
involved. Moreover, a class project to connect the ologs of diÔ¨Äerent students and
between the students and the teacher, may have excellent pedagogical beneÔ¨Åts.
Finally, it may be interesting to study ‚Äúlocal truth‚Äù vs. ‚Äúglobal truth‚Äù in a
network of ologs. Functorial connections between ologs can allow for translation of
ideas between members of a group, but there may be ideas which do not extend
globally, just as a M¬®obius band does not admit a global orientation. That is, given
three parties on the M¬®obius band, any pair can agree on a compass orientation, but
there is no choice that the three can simultaneously agree on. Similarly, whether
or not it is possible to construct a global language which extends all the existing
local ones could be determined if these local languages and their connections were
entered into a computer olog system.
7.3. Implementing ologs in the real world. Once ologs are implemented on
computers, and once people learn how to author good ologs, much is possible. One
advantage comes in searching the information space. Currently when we search for
a concept (say in Google or on our hard drive), we can only describe the concept in
words and hope that those words are found in a document describing the concept.
That is, search is always text-based. Better would be if the concept is meaning-
fully interconnected in a web of concepts (an olog) that could be navigated in a
meaningful (as opposed to text-based) way.
Indeed, this is the semantic web vision: When internet data is machine-readable,
search becomes much more powerful. Currently, we rely on RDF scrapers that scour
web pages for ‚ü®subject, predicate, object‚ü©sentences and store them in RDF format,
as though each such sentence is a fact. Since people are inputting their data as
prose text, this may be the best available method for now; however, it is quite
inaccurate (e.g. often 15% of the facts are wrong, a number which can lead to
degeneration of deductive reasoning ‚Äì see [MBCH]). If ideas could be put on the
internet such that they compatibly made sense to both human and computer, it
would give a huge boost to the semantic web. We believe that ologs can serve as
such a human-computer interface.
While it is often assumed that because we all speak the same language we all
must mean the same things by it, this is simply not true. The age-old question
about whether ‚Äúblue for me‚Äù is the same as ‚Äúblue for you‚Äù is applicable to every
single word and idiom in our language. There is no easy way to sync up diÔ¨Äerent
people‚Äôs perceptions. If communication is to be eÔ¨Écient, agreements must be fairly

50
DAVID I. SPIVAK AND ROBERT E. KENT
explicit and precise, and this precision demands a rigor that is simply unavailable
in English prose. It is available in a network of ologs (as described in Section 4).
For example, the laws of the United States are hopelessly complex. Residents of
the US are required to obey the laws. However, unlike the rules of the Scholastic
Aptitude Test (SAT), which take 10 minutes for the proctor to read aloud, the
laws of the US are never really expressed ‚Äî the most important among them are
hopefully picked up by cultural osmosis. If an olog was created which had enough
detail that laws could be written in that format, then a woman could research for
herself whether her landlord was required to Ô¨Åx her refrigerator or whether this
was her responsibility. It may prove that the olog of laws is internally inconsistent,
i.e. that it is impossible for a person to satisfy all the laws ‚Äî such an analysis, if
performed, could fundamentally change our outlook on the legal system.
The same goes for science; information written up in articles is much less acces-
sible than information that is entered into an ontology. However, the dream of a
single universal ontology is untenable ([Min]). Instead we must allow each lab or
institute to create its own ontology, and then require citations to be functorial olog
connections, rather than mere silo-to-silo pointers. Thus, a network of ologs should
be created to represent the understanding of the modern scientiÔ¨Åc community as a
multi-faceted whole.
Another impetus for a scientist to write an olog about the study at hand is that,
once an olog is made, it can be instantly converted to a database schema which the
scientist can use to input all the data pertaining to this study. Indeed, if some data
did not Ô¨Åt within this schema, then the olog must have been insuÔ¨Écient to begin
with and should be modiÔ¨Åed to fully describe the experiment. If scientists work this
way, then the separation between them and database modelers can be reduced or
eliminated (the scientist assumes the database modeling role with little additional
burden). Moreover, if functorial connections are established between the ologs of
diÔ¨Äerent labs, then data can be meaningfully shared along those connections, and
ideas written in the language of one lab‚Äôs olog can be translated automatically into
the language of the other‚Äôs. The speed and accuracy of scientiÔ¨Åc research should
improve.
References
[Awo] S. Awodey. Category Theory. Second edition. Oxford Logic Guides, 52. Oxford University
Press, Oxford (2010).
[BBJ] G.S. Boolos, J.P. Burgess, R.C. JeÔ¨Ärey. Computability and Logic. Fifth edition.
Cambridge University Press, Cambridge (2007).
[BW1] M. Barr, C. Wells. Category Theory for Computing Science. Prentice Hall International
Series in Computer Science. Prentice Hall International, New York (1990).
[BW2] M. Barr, C. Wells. Toposes, Triples and Theories. Grundlehren der Mathematischen
Wissenschaften [Fundamental Principles of Mathematical Sciences], 278. Springer-Verlag,
New York (1985).
[BS]
J. Barwise and J. Seligman. Information Flow: The Logic of Distributed Systems.
Cambridge University Press, Cambridge (1997).
[Bor]
A. Borgida. ‚ÄúKnowledge representation meets databases ‚Äî a view of the symbiosis ‚Äî‚Äù.
20th International Workshop on Description Logics (2007).
[CM]
M. Chein, M-L Mugnier. Graph-based Knowledge Representation and Reasoning:
Computational Foundations of Conceptual Graphs. Advanced Information and
Knowledge Processing Series, Springer London, 427 pages (2008).
[Coq] The Coq proof assistant. (2011). Available online: http://coq.inria.fr/.

OLOGS: A CATEGORICAL FRAMEWORK FOR KNOWLEDGE REPRESENTATION
51
[GW] B. Ganter, R. Wille. Formal Concept Analysis: Mathematical Foundations. Springer,
New York (1999).
[Gog1] J. Goguen. ‚ÄúA categorical manifesto‚Äù. Math. Struc. Comp. Sci. 1: 49‚Äì67 (1991).
[Gog2] J. Goguen. ‚ÄúInformation integration in institutions‚Äù. Draft paper for the Jon Barwise
memorial volume edited by Larry Moss (2006).
[GB]
J. Goguen, R. Burstall. ‚ÄúInstitutions: Abstract model theory for speciÔ¨Åcation and
programming‚Äù. J. Assoc. Comp. Mach. vol. 39, pp. 95‚Äì146 (1992).
[HC]
M.J. Healy and T.P. Cavdell. ‚ÄúNeural networks, knowledge and cognition: A
mathematical semantic model based upon category theory,‚Äù UNM Technical Report
EECE-TR-04-020, DSpaceUNM, University of New Mexico (2004).
[IFF1] The Information Flow Framework (IFF). Available online: http://suo.ieee.org/IFF/.
[IFF2] ‚ÄúThe IFF approach to the lattice of theories‚Äù. Available online:
http://suo.ieee.org/IFF/work-in-progress/LOT/lattice-of-theories.pdf.
[JRW] M. Johnson, R. Rosebrugh, and R. Wood. ‚ÄúEntity Relationship Attribute Designs and
Sketches‚Äù. Theory and Application of Categories 10, 3, 94‚Äì112 (2002).
[Ken1] R.E. Kent. ‚ÄúThe IFF foundation for ontological knowledge organization‚Äù. Cataloging &
ClassiÔ¨Åcation Quarterly, special issue: Knowledge Organization and ClassiÔ¨Åcation in
International Information Retrieval (2003).
[Ken2] R.E. Kent. ‚ÄúSemantic integration in the Information Flow Framework‚Äù. In: Kalfoglou,
Y., Schorlemmer, M., Sheth, A., Staab, S., Uschold, M. (eds.) Semantic Interoperability
and Integration. Dagstuhl Seminar Proceedings, vol. 04391, Dagstuhl Research Online
Publication Server (2005).
[Ken3] R.E. Kent. ‚ÄúSystem consequence‚Äù. In: Rudolph, S., Dau, F., Kuznetsov, S. (eds.) The
Proceedings of the 17th International Conference on Conceptual Structures: Conceptual
Structures: Leveraging Semantic Technologies. LNCS 5662. Springer-Verlag Berlin,
Heidelberg (2009). Slides for ICCS2009 presentation located online:
http://www.hse.ru/data/708/792/1224/system-consequence_Robert_E_Kent.pdf.
[Ken4] R.E. Kent. ‚ÄúThe architecture of truth‚Äù. Unpublished manuscript (2010) to appear online
at: http://arxiv.org/.
[Ken5] R.E. Kent. ‚ÄúDatabase semantics‚Äù. Unpublished manuscript (2011) to appear online at:
http://arxiv.org/.
[LS]
F.W. Lawvere, S.H. Schanuel. Conceptual Mathematics. A First Introduction to
Categories. Second edition. Cambridge University Press, Cambridge (2009).
[Mac] S. Mac Lane. Categories for the Working Mathematician. Second edition. Graduate Texts
in Mathematics, 5. Springer-Verlag, New York (1998).
[Mak] M. Makkai. ‚ÄúGeneralized sketches as a framework for completeness theorems. I,II,III‚Äù. J.
Pure Appl. Algebra 115 (1997), no. 1.
[Min] G.W. Mineau. ‚ÄúSharing knowledge: Starting with the integration of vocabularies‚Äù.
Lecture Notes in Computer Science, Vol 754 (1993), pp. 34-45. Springer.
[MBCH] T.M. Mitchell, J. Betteridge, A. Carlson, E. Hruschka. ‚ÄúPopulating the semantic web
by macro-reading internet text‚Äù. Lecture Notes in Computer Science, Vol. 5823 (2009),
pp. 998-1002. Springer.
[nL1]
nLab contributors. ‚ÄúMonomorphism‚Äù. nLab. Available online:
http://ncatlab.org/nlab/show/monomorphism.
[nL2]
nLab contributors. ‚ÄúEpimorphism‚Äù. nLab. Available online:
http://ncatlab.org/nlab/show/epimorphism.
[Pie]
B.C. Pierce. Basic Category Theory for Computer Scientists. MIT Press (1991).
[Sic]
G. Sica. ‚ÄúWhat is category theory?‚Äù. Polimetrica S.a.s. Milan, Italy (2006).
[Sow1] J. Sowa. ‚ÄúSemantic Networks‚Äù. Available online:
http://www.jfsowa.com/pubs/semnet.htm.
[Sow2] J. Sowa. Knowledge Representation: Logical, Philosophical, and Computational
Foundations. Brooks/Cole (2000).
[Spi1] D.I. Spivak. ‚ÄúHigher dimensional models of networks‚Äù (2009). Available online:
http://arxiv.org/pdf/0909.4314.
[Spi2] D.I. Spivak. ‚ÄúFunctorial data migration‚Äù (2010). Available online:
http://arxiv.org/abs/1009.1166.
[Spi3] D.I. Spivak. ‚ÄúCategories via graphs and paths‚Äù (2011). To appear online:
http://math.mit.edu/Àúdspivak/cs/cats.pdf.

52
DAVID I. SPIVAK AND ROBERT E. KENT
[SA]
D.I. Spivak, M. Anel. ‚ÄúCommunication protocol‚Äù. In preparation.
[TBG] A. Tarlecki, R. Burstall, J. Goguen. ‚ÄúSome fundamental algebraic tools for the semantics
of computation, part 3: Indexed categories‚Äù. Th. Comp. Sci. vol. 91, pp. 239‚Äì264. Elsevier
(1991).
[W]
Wikipedia contributors. ‚ÄúAmino acid‚Äù Wikipedia, The Free Encyclopedia. 30 Sep. 2010.
Web. 30 Sep. 2010. Available online: http://en.wikipedia.org/wiki/Amino_acid.
[YLC] R. Yeung, S-Y Li, N. Cai. ‚ÄúNetwork coding theory‚Äù Foundations and trends in
communications and information theory. now Publishers Inc., Boston (2006).
Mathematics, MIT, Cambridge, MA 02139
E-mail address: dspivak@math.mit.edu
Ontologos
E-mail address: rekent@ontologos.org

