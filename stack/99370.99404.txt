Theorems 
for free! 
Philip 
Wadler 
University 
of Glasgow* 
Abstract 
From the type of a polymorphic 
function 
we can de- 
rive a theorem 
that it satisfies. 
Every 
function 
of the 
same type satisfies 
the same theorem. 
This 
provides 
a free source of useful theorems, 
courtesy 
of Reynolds’ 
abstraction 
theorem for the polymorphic 
lambda calcu- 
lus. 
1 
Introduction 
Write down the definition 
of a polymorphic 
function 
on 
a piece of paper. 
Tell me its type, but be careful 
not 
to let me see the function’s 
definition. 
I will tell you a 
theorem that the function 
satisfies. 
The purpose of this paper is to explain 
the trick. 
But 
first, let’s look at an example. 
Say that r is a function 
of type 
r : vx. x* 
+ X’. 
Here X is a type variable, 
and X’ 
is the type “list 
of 
X”. 
From this, as we shall see, it is possible to conclude 
that r satisfies the following 
theorem: 
for all types A 
and A’ and every total function 
tz : A -V A’ we have 
a*orA 
=rAtoa*. 
Here o is function 
composition, 
and a* : A* + A’* is 
the function 
“map a” that applies 
a elementwise 
to a 
list of A yielding 
a list of A’, and rA : A* ---t A’ is the 
instance of r at type A. 
The intuitive 
expIanation 
of this result is that r must 
work on lists of X for any type X. Since r is provided 
with no operations 
on values of type X, all it can do is 
*Author’s 
address: 
Department 
of Computing 
Science, Uni- 
veraity 
of Glasgow, 
G12 SQQ, ScotIand. 
Electronic 
mail: 
wadlsrOcr 
. glamgow. 
l c . uk. 
Permission to copy without fee all or part of this material is granted provided that 
the copies are not made or distributed for direct commercial advantage, the ACM 
copyright notice and the title of the publication and its date appear, and notice is 
given that copying is by permission of the Association for Computing Machinery. 
To copy otherwise, or to republish, requires a fee and/or 
specific permission. 
0 1989 ACM 
0-89791-328-0/89/0009/‘0347 
$1.50 
rearrange 
such lists, independent 
of the values contained 
in them. Thus applying 
a to each element of a list and 
then rearranging 
yields the same result 
as rearranging 
and then applying 
a to each element. 
For 
instance, 
r may 
be the 
function 
reverse 
: 
VX. X* + 
X* that 
reverses a list, and a may be the 
function 
code : Char + Int that converts a character 
to 
its ASCII 
code. Then we have 
code* (reuersech,, 
[‘a’, ‘b’, ‘c’)) 
= 
(99,98,97] 
= 
reversel,,t 
(code* [‘a’, ‘b’, ‘c’]) 
which 
satisfies the theorem. 
Or r may be the function 
tail : VX. X* + X* that returns 
all but the first element 
of a list, and a may be the function 
inc : Int + Int that 
adds one to an integer. 
Then we have 
inc’ 
( tailrat 
[ 1,2,3]) 
1 
y 
ht (inc* 
[LZ 
31) 
which also satisfies the theorem. 
On the other hand, say r is the function 
odds : Int* 
-+ 
Int’ 
that removes all odd elements from a list of inte- 
gers, and say a is inc as before. Now we have 
inc* 
(oddsI,,, [ 1,2,3]) 
z 
!:;“’ 
= 
odds~,~(inc* [l&3]) 
and the theorem is not satisfied. 
But this is not a coun- 
terexample, 
because odds has the wrong type: 
it is too 
specific, Int* 
-+ Int’ 
rather 
than t/X. X’ ----* X’. 
This theorem about functions 
of type VX. X’ -+ X* is 
pleasant 
but not earth-shaking. 
What 
is more exciting 
is that a similar 
theorem can be derived for every type. 
The result 
that 
allows theorems 
to be derived 
from 
types will be referred to as the parametricity 
result, be- 
cause it depends in an essential way on parametric 
poly- 
morphism 
(types of the form VX. 2’). Parametricity 
is 
just a reformulation 
of Reynolds’ 
abstraction 
theorem: 
terms evaluated 
in related 
environments 
yield 
related 
values [Rey33]. 
The key idea is that types may be read 
347 

as relations. 
This result 
will 
be explained 
in Section 2 
and stated more formally 
in Section 6. 
Some further 
applications 
of parametricity 
are shown 
in Figure 
1, which 
shows several types and the corre- 
sponding 
theorems. 
Each name was chosen, of course, 
to suggest a particular 
function 
of the named type, but 
the associated 
theorems 
hold for any function 
that has 
the same type (so long as it can be defined as a term in 
the pure polymorphic 
lambda 
calculus). 
For example, 
the theorem 
given for head also holds for last, and the 
theorem given for sort also holds for nub (see Section 3). 
The theorems 
are expressed using operations 
on func- 
tions that 
correspond 
to operations 
on types. 
Corre- 
sponding 
to the list type A* is the map operation 
a* 
that 
takes the function 
a : A -+ A’ into 
the func- 
tion 
a* : A* --) A’*. 
Similarly, 
corresponding 
to the 
product 
type A x B is the operation 
a x b that 
takes 
the functions 
a : A -+ A’ and b : B + 
B’ into the 
function 
a x b : A x B ---) A’ x B’; it is defined 
by 
(a x b) (2, Y) = ( a z, b y). 
As we shall see, it will be 
necessary to generalise 
to the case where a, b, a*, and 
a x b are relations. 
How useful are the theorems 
so generated? 
Only time 
and experience 
will tell, but some initial 
results are en- 
couraging: 
l 
In general, 
the laws derived 
from 
types are of a 
form useful for algebraic 
manipulation. 
For exam- 
ple, many of the laws in Figure 
1 allow one to Upush 
map through 
a function”. 
l 
Three 
years 
ago I co-authored 
a paper 
on the 
derivation 
of an algorithm 
for compiling 
pattern- 
matching 
in functional 
languages 
[BWSS]. 
The 
derivation 
used 
nine 
general 
theorems 
about 
higher-order 
functions 
such as map and sort. 
Of 
the nine theorems, 
five follow immediately 
from the 
types. 
l 
Sheeran 
has developed 
a formal 
approach 
to the 
design of VLSI 
circuits 
that 
makes heavy 
use of 
mathematical 
laws. 
She has found 
that 
many of 
the laws she needs can be generated 
from types 
using the methods 
described 
here, and has already 
written 
a paper describing 
how to do so [She89]. 
Not surprisingly, 
using a more specific 
type system al- 
lows even more theorems to be derived from the type of 
a function; 
this has already 
been explored 
to a certain 
extent by Sheeran [She89]. So there is reason to believe 
that further 
research will further 
extend the applicabil- 
ity of this method. 
Many 
functional 
languages, 
including 
Standard 
ML 
[Mil84,Mil87], 
Miranda’ 
[Tur85], 
and 
Haskell 
‘Miranda 
is a trademark 
of Research 
Software 
Limited. 
[HWSS], are based on the Hindley/Milner 
type system 
[Hin69,Mi178,DM82]. 
This 
system is popular 
because 
types need not, be given explicitly; 
instead, the principal 
(most general) 
type of a function 
can be inferred 
from 
its definition. 
However, 
for the purposes 
of this paper 
it is more convenient 
to use the Girard/Reynolds 
type 
system 
[Gir72,Gir86,Rey74,Rey83] 
(also known 
as the 
polymorphic 
lambda calculus, 
the second order lambda 
calculus, 
and System F). In the Girard/Reynolds 
sys- 
tem it is necessary 
to give the types 
of bound 
vari- 
ables explicitly. 
Further, 
if a function 
has a polymorphic 
type then type applications 
must be explicitly 
indicated. 
This is done via subscripting; 
for example, 
the instance 
of the function 
r : VX. X* + X‘ at the type A is written 
rA : A’ *A’. 
Every 
program 
in the Hindley/Milner 
system 
can 
automatically 
be 
translated 
into 
one 
in 
the 
Gi- 
rard/Reynolds 
system. 
All that is required 
is a straight- 
forward 
modification 
of the type inference 
algorithm 
to 
decorate 
programs 
with 
the appropriate 
type informa- 
tion. 
On the other hand, the inverse translation 
is not 
always possible, because the Girard/Reynolds 
system is 
more powerful 
than Hindley/Milner. 
Both 
the Hindley/Milner 
and the G&-d/Reynolds 
system satisfy the strong normalisation 
property: 
every 
term has a normal 
form, and every reduction 
sequence 
leads to this normal form. As a corollary, 
it follows that 
the fixpoint 
operator, 
cannot be defined as a term in these systems. 
For many 
purposes, 
we can get along 
fine without 
the fixpoint 
operator, 
because many useful functions 
(including 
all 
those shown 
in Figure 
1) may be defined 
in the Gi- 
rard/Reynolds 
system without 
its use. Indeed, every re- 
cursive function 
that can be proved total in second-order 
Peano arithmetic 
can be written 
as a term in the Gi- 
rard/Reynolds 
calculus 
(FLO83,Gir72,GLT89]. 
This in- 
cludes, for instance, 
Ackerman’s 
function 
(see [Rey85]), 
but it excludes interpreters 
for most languages 
(includ- 
ing the Girard/Reynolds 
calculus 
itself). 
If the power of unbounded 
recursion 
is truly 
required, 
then f; 
can be added as a primitive. 
However, 
adding 
fixpoints 
weakens the power of the parametricity 
the- 
orem. 
In particular, 
if fixpoints 
are allowed 
then the 
theorems 
in Figure 
1 hold in general 
only 
when the 
functions 
a and b are strict 
(that 
is, when 
a I 
= I 
and b I 
= 1)2. 
For this reason, the bulk of this pa- 
per assumes that 
fixpoints 
are not provided; 
but the 
necessary adjustment 
to allow fixpoints 
is described 
in 
Section 7. 
2This 
is similar 
to the restriction 
to strict 
coercion 
functions 
in [BCGS89], 
and is adopted 
for a similar 
reason. 
348 

Assume a : A + A’ and b : B -+ B’. 
head : VX. X’ + X 
a o headA = headAl o a* 
tail : vx. X” + X’ 
a* 0 tailA = tailA 0 a* 
(tt) 
: vx. x* ---t x* 4 x* 
4* (25 -H-A ys) = ( a* zs) +A’ (a* ys) 
concat : VX. X** - X” 
a* 0 concatA = concatA# 0 a*+ 
j.st:vx.wY.Xx 
Y-,X 
a 0 j8fAB = jStAl&V 
0 (a x b) 
md :VX.VY. 
XX 
Y ---, Y 
b 0 EndAB = SndAtp 0 (a X b) 
tip : VX. VY. (X’ x Y’) --, (X x Y)* 
(a x b)* 0 tip.4~ = tipA’B’ 0 (a* X b*) 
filter : VX. (X - Bool) + X’ ---, X’ 
a* 0 filterA (p’ 0 a) = f;rterAl p’ o a* 
sort : vx. (X --) x 4 Bool) - x* -+ x* 
if for all z,y f A, 
(z c y) = (a z C’ a y) then 
a* 0 sorfA (<) = sortA’ (<‘) 0 a* 
fold : VX. VY. (X - 
Y + Y) - 
Y - X’ - 
Y 
if for all 2 E A, y E 8, 
b (z $ y) = (a z) @ (b y) and b tc = u’ then 
b 0 jOidAB (@) U = jofdA’p 
(a) Cc’ 0 a* 
I:Vx.X+X 
a o IA = IAt o a 
K:VX*VY.X-+Y+X 
a (KAB 
z Y) = KAIB~ 
(a ~1 (b Y) 
Figure 
1: Examples 
of theorems from types 
349 

The fundamental 
idea of parametricity 
is not new. 
A restricted 
version 
of it appears 
in Reynolds’ 
origi- 
nal paper on the polymorphic 
lambda calculus 
[Rey74], 
where it is called 
the representation 
theorem, 
and a 
version 
similar 
to that 
used here appears in [Rey83], 
where 
it is called 
the abstraction 
theorem. 
Other 
versions 
include 
the logical 
relations 
of Mitchell 
and 
Meyer 
[MM85,Mit86]; 
and the dinatural 
transforma- 
tions of Bainbridge, 
Freyd, Girard, 
Scedrov, and Scott 
[BFSS87,FGSS88], 
from whom I have taken the name 
uparame tricity” 
. 
So far as I am aware, alI uses of parametricity 
to date 
have been ‘general”: 
they say something 
about possible 
implementations 
of the polymorphic 
lambda 
calculus 
(e.g. that the implementation 
is correct independent 
of 
the representation 
used) or about its models (e.g. that 
models should only be allowed 
that satisfy parametric- 
ity). 
The main contribution 
of this paper is to suggest 
that 
parametricity 
also has “specific” 
applications: 
it 
says interesting 
things 
about 
particular 
functions 
with 
particular 
types3. 
A second contribution 
of this 
paper 
is to present 
an updated 
proof 
of the abstraction 
theorem. 
The 
proof given here is based on that 
in [Rey83]. 
Unfor- 
tunately, 
that proof is expressed in terms of a %aive” 
set-theoretic 
model of the polymorphic 
lambda 
calcu- 
lus; Reynolds 
later 
proved 
that 
such models 
do not 
exist 
(Rey84]. 
Fortunately, 
the proof 
adapts 
easily 
to the frame 
models of Bruce, 
Meyer, 
and Mitchell 
[BM84,MM85], 
and that is the approach 
taken in this 
paper. 
(For other models of the polymorphic 
lambda 
calculus, 
see [BTC88,Mes89,Pit87].) 
The characterisation 
of parametricity 
given in this pa 
per can be formulated 
more concisely 
in terms of cat- 
egory theory, 
where it can be re-expressed 
in terms of 
lax natural 
transformations. 
This will be the subject of 
a further 
paper. 
The remainder 
of this paper is organised 
as follows. 
Sections 2 and 3 present the main new results: 
Section 2 
presents the parametricity 
theorem, 
and Section 3 gives 
further 
applications. 
Sections 
4-6 fill in the formali- 
ties: 
Section 
4 describes 
the syntax 
of the polymor- 
phic lambda 
calculus, 
Section 
5 shows how its syntax 
can be given using frame models, and Section 
6 gives 
the full statement 
of the parametricity 
theorem. 
Sec- 
tion 7 shows how the parametricity 
theorem 
should be 
adjusted 
to account 
for languages 
that use the fixpoint 
operator. 
Acknowledgements. 
I am grateful 
to Harold 
Sim- 
3Since this paper was written, 
I have learned that Peter de- 
Bruin 
has recently 
discovered similar 
applications 
[deB89], and 
that John Reynolds already knew of the application 
in Section 3.8. 
mons for helping 
to formulate 
and prove 
the result 
about 
map in Section 3.5, and to Samson Abramsky, 
Val Breazu-Tannen, 
Peter Freyd, 
John Hughes, 
John 
Launchbury, 
John Reynolds, 
Andre Scedrov, and Mary 
Sheeran for their comments 
on this work. 
2 
Parametricity 
explained 
The key to extracting 
theorems 
from types is to read 
types as relations. 
This 
section outlines 
the essential 
ideas, using a naive model of the polymorphic 
lambda 
calculus: 
types are sets, functions 
are set-theoretic 
func- 
tions, etc. The approach 
follows that in [Rey83]. 
Cognoscenti 
will 
recognise 
a small 
problem 
here- 
there are no naive set-theoretic 
models of polymorphic 
lambda 
calculus! 
(See [Rey84].) 
That’s 
ok; the essen- 
tial ideas adopt easily to frame models [BM84,MM85]. 
This section sticks to the simple but naive view; the i’s 
will be dotted and the t’s crossed in Sections 4-6, which 
explain 
the same notions in the context 
of frame models. 
The usual way to read a type is as a set. The type 
Boo1 corresponds 
to the set of booleans, 
and the type 
Int corresponds 
to the set of integers. 
If A and B are 
types, then the type A x B corresponds 
to a set of pairs 
drawn from A and B (the Cartesian product), 
the type 
A* corresponds 
to the set of lists with elements in A, and 
the type A -+ B corresponds 
to a set of functions 
from A 
to B. Further, 
if X is a type variable 
and A(X) is a type 
depending 
on X, then the type VX. A(X) 
corresponds 
to a set of functions 
that take a set B and return 
an 
element in A(B). 
An alternative 
is to read a type as a relation. 
If A 
and A’ are sets, we write 
A : A (r A’ to indicate 
that 
a is a relation 
between A and A’, that 
is, that 
A E 
A x A’. 
If z E A and 3;’ E A’, we write 
(2,~‘) 
E A 
to indicate 
that 
z and z’ are related 
by A. A special 
case of a relation 
is the identity 
relation 
IA : A + A, 
defined 
by 1~ = ((2, z) ] z E A}. 
In other words, if 
z, z’ E A, then (2,s’) 
E 1~ iff z = 2’. More generally, 
any function 
a : A ---, A’ may also be read as a relation 
((2, a z) ] z E A). In other words, if z E A and z’ E A’, 
then (z, 2’) E a iff a z = 2’. 
To read types as relations, 
we give a relational 
equiva- 
lent for constant 
types and for each of the type construc- 
tors Ax B, A*, A + B, and VX. A(X). 
Constant 
types, 
such as Boo1 and Int, may simply 
be read as identity 
relations, 
I~oOl : Boo1 # Boo1 and II~~ : Int f) Int. 
For any relations 
A : A + A’ and 3 : B N B’, the 
relation 
A x B : (A x B) * 
(A’ x B’) is defined by 
((2, Y), (z’s Y’)) E A x 3 
(2~~ 2’) E A a; 
(y, y’) E 8. 
350 

That 
is, pairs are related 
if their 
corresponding 
com- 
ponents 
are related. 
In the special case where a and 
b are function, 
then a x b is the function 
defined 
by 
(a x b) (5, Y) = (a z, b Y). 
For any relation 
A : A H A’, the relation 
A’ : A* H 
A’” is defined by 
(1 q, . . . , zn], [z;, . . ., XL]) E A’ 
iff 
(zr, 2:) E a and . ..and 
(z,,,zk) 
E A. 
That 
is, lists are related 
if they have the same length 
and corresponding 
elements are related. 
In the special 
case where a is a function, 
a* is the familiar 
‘map” 
function 
defined by a* [zr , . . . , zn] = [u zl, . . . , a zR], 
For any relations 
A : A H A’ and R : B * 
B’, the 
relation 
A - 
8 : (A -+ B) + (A’ -+ B’) is defined by 
(M’) 
E A-+8 
’ 
for all (2,~‘) 
E A:” (j 2,j’ 
2’) E 8. 
That is, functions 
are related if they take related argu- 
ments into related 
results. 
In the special case where a 
and b are functions, 
the relation 
a -+ b will not neces- 
sarily be a function, 
but in this case (j, j’) E a + 
b is 
equivalent 
to j’ 0 a = 6 0 j. 
Finally, 
we have to interpret 
V as an operation 
on re- 
lations. 
Let 3(X) 
b e a relation 
depending 
on X. Then 
3 corresponds 
to a function 
from relations 
to relations, 
such that for every relation 
A : A ++ A’ there is a cor- 
responding 
relation 
3(A) 
: F(A) 
w F’(A’). 
Then the 
relation 
VX. 3(X) 
: VX. F(X) 
e VX! F’(X’) 
is defined 
by 
(4% 8’) ‘;I- 
W) 
forallA:A+A’, 
(gA,gi’)E3(A). 
That 
is, polymorphic 
functions 
are related if they take 
related types into related results. 
(Note the similarities 
in the definitions 
of A + 8 and VX. 3(X).) 
Using the definitions 
above, any closed type T (one 
containing 
no free variables) 
can be read as a relation 
7 : T ++ T. The main result of this paper can now be 
described as follows: 
Proposition. 
(Parametricity.) 
If t is a 
closed term of type T, then (t, t) E T, where 
7 is the relation 
corresponding 
to the type T. 
A more formal 
statement 
of this result appears in Sec- 
tion 6, where it is extended 
to types and terms contain- 
ing free variables. 
3 
Parametricity 
applied 
This section first explains 
in detail 
how parametricity 
implies some of the theorems 
listed in the introduction 
and then presents some more general results. 
3.1 
Rearrangements 
The result in the introduction 
is a simple consequence 
of parametricity. 
Let r be a closed term of type 
r:vx.x*-+x*. 
Parametricity 
ensures that 
(r, f) E vx. 
X’ 4 x*. 
By the definition 
of V on relations, 
this is equivalent 
to 
forallA:A#A’, 
(TA, Q’) E A’ + A* 
By the definition 
of + on relations, 
this in turn is equiv- 
alent to 
for all A : A * 
A’, 
for all (zs, zs’) E A*, 
(fA 23, rA’ zs’) E A* 
This can be further 
expanded 
in terms of the definition 
of A*. 
A more convenient 
version 
can be derived 
by 
specialising 
to the case where the relation 
A is a function 
a : A --r A’. The above then becomes 
for all a : A -3 A’, 
for all zs, 
a* 2s = 2s’ 
implies 
u* (r&4 2s) = fA’ 2s’ 
or, equivalently, 
for all a : A 3 A’, 
u*or~=r~oa*. 
This is the version given in the introduction, 
3.2 
Fold 
The function 
fold has the type 
jo2d : VX. VY. (X + Y 4 Y) -+ Y + X‘ + Y. 
Parametricity 
implies that 
(fold, fold) E VX. Vy. (X -+ Jl + 9) + IJ -+ X* + Y. 
Let a : A + A’ and b : B -+ B’ be two functions. 
Ap- 
plying 
the definition 
of V on relations, 
twice, specialised 
to functions, 
gives 
(joldAB,joldAIp) 
E (a + b + 6) -+ b -+ a* -+ b 
351 

Applying 
the definition 
of -+ on relations, 
twice, gives 
for all (@, 63’) E (u ---) 6 3 b), 
for all (u, u’) E b, 
Here (CB) is just the name of a function 
of two argu- 
ments; by the usual convention, 
(@) z y may be written 
in the infix 
form z a y. Further 
expansion 
shows that 
the condition 
(@, @‘) E ( a -+ b + b) is equivalent 
to 
for all z E A, z’ E A’, y E B, y’ E B’, 
a z = z’ and b y = y’ implies 
6 (z @ y) = x’ GY y’. 
The result as a whole may then be rephrased, 
for all a : A -+ A’, b : B -+ B’, 
iffyb”,” 
2 ~‘-4, y E B, 
b (z ~3 y) = (a x) ~3’ (1 y), 
=U 
then b o foldAB (@) u = foldA*p (e’) u’ o a*. 
The theorems derived from types can often be given a 
reading with 
an algebraic 
flavour, 
and the result about 
fold provides 
an illustration 
of this. 
Let (A, B,@, u) 
and (A’, B’, CB’, u’) be two algebraic 
structures. 
The 
functions 
a and 
b form 
a homomorphism 
between 
these if b (z @ y) = (u z) @’ (b y) for all z and y, 
and if b u = u’. 
Similarly, 
let (A*, B, joldAB (a) u) 
and (A’*, B’ , foldAlp (@‘) u’) 
also be two 
algebraic 
structures. 
The 
functions 
u* and 
b form 
a home 
morphism 
between 
these if b (joidAB (CB} u ZJ) = 
fOidA'B' 
(@') 
U' 
(U* 
29). 
The 
result 
about 
fold 
states that if u and 6 form a homomorphism 
between 
(A, B, c, n) and (A’, B’, c’, A’), 
then 
a* and 
b form 
a homomorphism 
between 
(A*, B, foldAB 
(G3) u) and 
(A”,B’, 
fOidAlB# 
(CB') u'). 
3.3 
Sorting 
Let s be a closed term of the type 
s : VX.(X + X --t Bool) ---) (X’ ---) X’) 
Functions 
of this type include 
sort and nub: 
~0~ht(<m)[3,L 
4% 51 = 
[1,2,3,4,5] 
nuhnt (=znt)[L 
L&Z 
a11 
= 
[I, 2911 
The function 
sort takes an ordering 
function 
and a list 
and returns 
the list sorted in ascending 
order, and the 
function 
nub takes an equality 
predicate 
and a list and 
returns 
the list with 
adjacent 
duplicates 
removed. 
Applying 
parametricity 
to the type of s yields, for all 
a : A + A’, 
if for all 2, y E A, 
(z 4 y) = (u z 4’ a y) 
then 
a* o sA (4) = SA’ (+‘) 0 a* 
(Recall that Bool as a relation 
is just the identity 
rela- 
tion of booleans.) 
As a corollary, 
we have 
if for all z, y E A, 
(z < y) = (a z <’ a y) 
then 
SortAl (<) 0 a* = a* 0 SortA 
(<‘) 
so maps commute with sort, when the function 
mapped 
preserves ordering. 
(If < and <’ are linear orderings, 
then the hypothesis 
is equivalent 
to requiring 
that a is 
monotonic.) 
As a second corollary, 
we have 
if for all z, y E A, 
(z 3 y) = (u z E’ a y) 
then 
nubA’ (Z) 0 Q* = U* 0 nubA (E’) 
so maps commute with 
nub, when the function 
mapped 
preserves equivalence. 
(If = and s’ are equality 
on A 
and A’, then the hypothesis 
is equivalent 
to requiring 
that u is one-to-one.) 
3.4 
Polymorphic 
equality 
The programming 
language Miranda 
[Tur85] provides a 
polymorphic 
equality 
function, 
with type 
(=) : VX X ---t X - Book 
Applying 
parametricity 
to the type of (=) yields, for all 
a : A 4 A’, 
for 
au X,y 
E A, 
(2 =A y) = (a Z =A’ a y). 
This is obviously 
false; it does not hold for all a, but 
only for functions 
a that are one-to-one. 
This is not a contradiction 
to the parametricity 
theo- 
rem; rather, it provides a proof that polymorphic 
equal- 
ity cannot 
be defined in the pure polymorphic 
lambda 
calculus. 
Polymorphic 
equality 
can be added as a con- 
stant, 
but then parametricity 
will 
not hold (for terms 
containing 
the constant). 
This suggests that we need some way to Utamen the 
power of the polymorphic 
equality 
operator. 
Exactly 
such taming 
is provided 
by the “eqtype 
variables” 
of 
Standard 
ML [Mil87], 
or more generally 
by the “type 
classes” of Haskell 
[HW88,WB89]. 
In these languages, 
we can think of polymorphic 
equality 
as having the type 
(=) : V(=)X. 
X ---) X ----, Book 
Here V(=)X. 
F(X) 
is a new type former, where X ranges 
only over types for which 
equality 
is defined. 
Corre- 
sponding 
to the type constructor 
tl= is a new relation 
constructor: 
(g, g’) E v(=)x. 
?(X) 
for all ff : A 0 A’ respecA:g 
(=), 
(gA, gx,) E ?(A). 
352 

A relation 
A : A * 
A’ respects (=) if whenever 
z =A y 
and (2, CC’) E A and (y , y’) E 4 then 2’ =A’ y’, where 
(=A) 
is equality 
on A and (=A,) 
is equality 
on A’. 
In 
the case where A is a function 
a, this is equivalent 
to 
requiring 
that a be one-to-one. 
With this definition, 
we can prove that the polymor- 
phic equality 
operator, 
typed 
as above, 
satisfies 
the 
parametricity 
theorem. 
In our extended 
language 
we 
can define, for example, 
the function 
nub : v(=)x. 
x* 
-+ x* 
and the corresponding 
parametricity 
condition 
is the 
same as that for the previous 
version of nub. 
Thus, 
the more refined 
type structures 
of Standard 
ML and Haskell add exactly 
the information 
necessary 
to maintain 
parametricity. 
In Standard 
ML this trick 
works only 
for equality 
(which 
is built 
into 
the lan- 
guage), whereas in Haskell 
it works for any operators 
defined using the type class mechanism. r 
3.5 
A result 
about 
map 
Suppose that I tell you that I am thinking 
of a function 
m with 
the type 
m : VX.VY.(X 
+ 
Y) + (x* 
+ 
Y*) 
You will 
immediately 
guess that I am thinking 
of the 
map function, 
m(j) 
= j*. 
Of course, I could be thinking 
of a different 
function, 
for instance, 
one that reverses a 
lit 
and then applies f’ 
to it. But intuitively, 
you know 
that map is the only interesting 
function 
of this type: 
that all others must be rearranging 
functions 
composed 
with map. 
We can formalise 
this intuition 
as follows. 
Let m be 
a function 
with 
the type above. Then 
mAB(f) 
= f* o mAA 
= mBL? (&3) Of* 
where IA is the identity 
function 
on A. 
The function 
mAA 
ii3 a rearranging 
fUnCtiOn, 
as discussed in the 
preceding 
section. 
Thus, every function 
m of the above 
type can be expressed 
as a rearranging 
function 
com- 
posed with map, or equivalently, 
as map composed with 
a rearranging 
function. 
The proof is simple. 
As we have already 
seen, the 
parametricity 
condition 
for m is that 
iff’oa 
= b of then mA’B’(f’) 
o a* = b* o mAB(f) 
Taking 
A’ = B’ = B, b = f’ = IB, a = f satisfies the 
hypotheses, 
giving 
as the condusion 
W&?(b) 
Of’ 
= (b)* 
0 mAB(f) 
which gives us the second equality 
above, since (IB)* 
= 
IB’. 
The first equality 
may be derived 
by commuting 
the permuting 
function 
with 
map; or may be derived 
directly 
by a different 
substitution. 
3.6 
A result 
about 
fold 
Analogous 
to the previous result about 
map is a similar 
result about fold. 
Let j be a function 
with 
the type 
j: 
VX.VY.(X 
--+ Y “+ Y) --+ Y-X’ 
- 
Y 
Then 
fAB 
C n = foidAB 
C n 0 fAA* 
COnSA 
nil.4 
Note that jAR* ConsA nilA : A* -+ A* is a function 
that 
rearranges 
a list, so this says that every function 
with 
the type of fold can be expressed as fold composed with 
a rearranging 
function. 
The proof is similar 
to the previous 
one. The para- 
metricity 
condition 
for j is that 
if c’o (a x b) = b o c and n’ = b(n) then 
fA’B’ c’ n’ 0 a+ = b 0 fAB c n 
Taking 
A = A’, B = A*, a = IA, b = foldA(Bi 
c’ n’, 
c = consA, n = nilA satisfies the hypothesis, 
giving 
as 
the conclusion 
fABt c’ n’ 0 Ii 
= foldAB, 
C’ 
IL’0 
fAA. 
COnSA 
?dA 
The 12 term is just an identity, 
and so drops out, leaving 
us with 
the desired equality 
if we rename 
c’, n’, I?’ to 
c, n, B. 
3.? 
A result 
about 
filter 
Let j be a function 
with 
the type 
f: 
VX.(X+ 
Bool) +X* 
+ X* 
Three functions 
with 
this type are jilter, 
takewhile, 
and 
dropwhile. 
For example, 
filter 
odd [3,1,4,5,2] 
= 
[3,1,5] 
takewhile 
odd (3,1,4,5,2] 
= 
[3, l] 
dropwhile 
odd [3,1,4,5,2] 
= 
[4,5,2] 
See [BW88) for the definitions 
of these functions. 
For every such f we can define a corresponding 
func- 
tion of type 
g : VX.(X 
x Bool)’ 
---t X* 
such that j and g are related 
by the equation 
fA(P) 
= 
gA 
o 
(IA, 
P) 
(*) 
where (IA, p) z = (z, p z). That 
is, Jo is passed a pred- 
icate p of type A --t Boo1 and a list of A, whereas gA is 
passed a list of A x Boo1 pairs, the second component 
of the pair being 
the result 
of applying 
p to the first 
353 

component, 
Intuitively, 
this transformation 
is possible 
because the only values that p can be applied 
to are of 
type A, so it suffices to pair each value of type A with 
the result 
of applying 
p to it. 
A little 
thought 
show8 that a suitable 
definition 
of g 
is 
gA 
= 
f-St* 
O~AXBOOJ(J~L~ 
We can use parametricity 
to show that 
f and g sat- 
isfy (*), 
for all function8 
f of the given 
type. 
The 
parametricity 
conditions 
for f tell8 
us that 
for any 
U.: A 4 A’ and any p : A + Boo1 and p’ : A’ 4 Boo1 
we have 
if p’ 0 a = 
IBooJ 
0 p then f.# (p’) 0 a* = a* 0 f...t (p) 
Take A’ = A x Boo1 and o = &,p) 
and p’ = snd. 
Then the hypothesis 
becomes and o (IA, p) = p, which 
is satisfied, 
yielding 
the conclusion 
fAxBooJ(~~d)o(~A~P)* 
= v..,P)OfA(P)* 
Compose both sides with Ist*, 
giving 
fit* 
O~AXBOO.I(SA~) 
O (IA,P)* =fat* 
0 (IASP) O!A(P)- 
Then apply 
the definition 
of g, and observe that 
f.st o 
(IA, p) = IA, resulting 
in the equation 
gA o (h, 
P)’ = fA (P) 
as desired. 
3.8 
An isomorphism 
The preceding 
application8 
can all be expressed in the 
Hindley/Milner 
fragment 
of the polymorphic 
lambda 
calculus: 
all universal 
quantifier8 
appear at the outside 
of a type. 
This 
section 
presents 
an application 
that 
utilises the full power of the Girard/Reynolds 
system. 
Let A be an arbitrary 
type. 
Intuitively, 
this type 
is isomorphic 
to the type VX. (A ---) X) - 
X, which 
we will 
abbreviate 
a8 A. 
The apparent 
isomorphism 
between A and i is expressed by the functions: 
i 
: 
A-A 
i 
= 
Xz:AAX.Xg:A-+X.gz 
j 
: 
i--+A 
i 
= 
Ah : ;i. hA (XX : A Z) 
That 
is, a’ takes an element 
x of A to the element of i 
that maps a function 
g (of type A + 
X) to the value 
g z (of type X). 
The inverse function_ j recovers the 
original 
element by applying 
a value in A to the identity 
function. 
To prove that this truly 
is an isomorphism, 
we must 
verify 
that j o i and i o j are both identities. 
It is easy 
enough to verify 
the former: 
i (i xl 
= 
j (AX. Xg : A - 
X. g x) 
= 
(Xg : A + A g z) (Xz: A z) 
= 
&:A 
z) z 
= 
2 
However, 
the inverse identity 
is problematic. 
We can 
get a8 far as 
i (i h) 
= 
i (hA (AZ : A 2)) 
= 
Ax. xg : A - x. g (hA (kz : A 2)) 
and now we are stuck. 
Here is where 
parametricity 
helps. 
The parametricity 
condition 
for h : VX. (A + 
X)-+Xisthat,forallB:B-,B’andallf:A--+B, 
Taking 
B = A, B’ = X, 
b = g, and f = (Xz : A z) 
gives 
AX. Xg : A + x. g (hA (AZ : A s)) 
= 
AX.Xg:A--,X. 
hx (go(k:Az)) 
= 
AX.Xg:A-,X. 
hx g 
= 
h 
which completes the second identity. 
The second identity 
depends critically 
on parametric- 
ity, so the isomorphism 
holds only for model8 in which 
all element8 satisfy 
the parametricity 
constraint. 
Alas, 
the parametricity 
theorem 
guarantee8 
only 
that 
ele- 
ments of the model that 
correspond 
to lambda 
terms 
will be parametric; 
many models contain 
additional 
el- 
ements that are non-parametric. 
One model that con- 
tains only parametric 
elements is that in [BTC88]. 
4 
Polymorphic 
lambda 
calculus 
We now turn 
to a more formal 
development 
of the 
parametricity 
theorem. 
We begin with 
a quick review 
of the polymorphic 
lambda 
calculus. 
We will use X, Y, 2 to range over type variables, 
and 
T, U, V to range over types. 
Types 
are formed 
from 
type variables, 
function 
types, and type abstraction: 
T::=XI 
T--t 
Uj AX. T 
We will 
use z, y, z to range over individual 
variables, 
and t, u, u to range over terms. 
Terms are formed from 
individual 
variables, 
abstraction 
and application 
of in- 
dividuals, 
and abstraction 
and application 
of types: 
354 

VI 
X;zi- 
t: T 
X,X;zl-AX. 
t:QX. 
T 
Qp 
X;zi- 
t:QX. 
T 
X;z k tv : T(U/X] 
Figure 2: Typing 
rules 
We write 
TlUlXl 
to denote substitution 
of U for the 
free occurrences 
of X in T, and t[ u/r] 
and t[ U/X] sim- 
ilarly. 
A term is legal only if it is well typed. 
Typings 
are 
expressed as assertions 
of the form 
X;zt- 
t: T 
where X is a lit 
of distinct 
type variables 
Xl,. 
. . , X,,,, 
and z is a list of distinct 
individual 
variables, 
with types, 
x1 : TI,...,x,, 
: T,,. 
This 
assertion 
may be read as 
stating 
that 
t has type T in a context 
where each zi 
has type Ti. Each individual 
variable 
that appears free 
in t should 
appear 
in Z, and each type variable 
that 
appears free in T of z should 
appear in x. 
The type 
inference rules are shown in Figure 2. 
Two terms are equivalent 
if one can be derived from 
the other by renaming 
bound 
individual 
or type vari- 
ables (01 conversion). 
In addition, 
we have the familiar 
reduction 
rules: 
(p) 
(AZ : u. t) u 
=+ 
t[u/z] 
(AX. t)u 
=+ W/Xl 
(4 
Az:u.tx 
* 
t 
AX. tx 
=+ t 
where in the q rules z and X do not occur free in t. 
As is well known, 
familiar 
types such as booleans, 
pairs, lists, and natural 
numbers can be defined as types 
constructed 
from just + and V; see for example [Rey85] 
or [GLT89]. 
Alternatively, 
we could add suitable 
types 
and individual 
constants 
to the pure language described 
above. 
5 
Semantics 
of polymorphic 
lambda 
calculus 
We will 
give a semantics 
using a version 
of the frame 
semantics 
outlined 
in (BM&4] 
and (MM85]. 
We first 
discuss the semantics of types, and then discuss the se- 
mantics 
of terms. 
5.1 
Types 
A type model consists of a universe 
U of type values, 
and two operations, 
-) and Q that construct 
types from 
other types. 
There is a distinguished 
set [U + 
U] of 
functions 
from U to U. 
If A and B are in U, then 
A--,BmustbeinU,andifFisin\U+U),thenQF 
must be in U. 
Let T be a type with 
its free variables 
in X. We say 
that A is a type environment 
for X if it maps each type 
variable in X into a type value in U. The corresponding 
value of T in the environment 
A is written 
(ITl]?i and is 
defined as follows: 
Here ;ilXn 
is the value that a maps X into, and a[A/X] 
is the environment 
that maps X into A and otherwise 
behaves as ;i. 
(The 
reader may find that 
the above 
looks more familiar 
if d is replaced 
everywhere 
by a 
Greek letter such as q.) 
355 

5.2 
Terms 
Associated 
with 
each type A in U is a set DA of the 
values of that type. 
For each A and B in U, the elements in DA-B 
repre- 
sent functions 
from DA to Dg. 
We do not require that 
the elements 
are functions, 
merely that they represent 
functions. 
In particular, 
associated 
with each A and B 
in U there must be a set [DA --+ DB] of functions 
from 
DA to Dg, 
and functions 
$A,B 
: 
DA+B 
---, [DA 
---, DB] 
+A,B 
: 
[DA 
- 
DB] 
- 
DA-~B 
such that 
+A,B 0 $A,B is the identity 
on [DA 4 
DB]. 
We will usually 
omit the subscripts 
and just write 4 and 
6 
If F is a function 
in [U -+ U], the elements 
in Dvr 
represent 
functions 
that take a type A into an element 
of D=(A). 
In particular, 
associated 
with 
each F there 
must be a set [VA : U. Dp(A)] of functions 
that 
map 
each A in U into an element of Dr(A), 
and functions 
@F 
: 
DVF - 
[VA : u. DF(A)] 
QF 
: 
[VA : U. Dp(A)] 
-t DVF 
such that @F o q~ is the identity 
on [VA : U. DF(Al]. 
Again, we will usually 
omit the subscripts 
and just write 
(9 and Q’. 
Let t be a term such that X; z l- t : T. We say that 
A, B are environments 
respecting 
X, Z if A is a type 
environment 
for X and a is an environment 
mapping 
variables 
to values such that 
for each q r Ti in 2, we 
have that 
a[zil 
E DgTipa. The value of t in the envi- 
ronments 
A and zi is written 
[tna B and is defined 
as 
follows: 
Here a[zj 
is the value that 
a maps z into, and a[a/z] 
is the environment 
that 
maps z into a and otherwise 
behaves as a. 
A 
frame 
is 
a structure 
specifying 
U, +,V 
and 
D, 4, +, a, Q satisfying 
the constraints 
above. 
A frame 
is an environment 
model if for every x; z t t : T and ev- 
ery A, 7i respecting 
X, 2, the meaning 
of [tnA a as given 
above exists. 
(That 
is, a frame is a model if the sets 
[U 
- 
Ul, 
[PA 
-+ DB], 
and [VA : U. DF(.J)] 
are “big 
enough” .) 
We write 
X; Z b t : T if for all environments 
A, a 
respecting 
X, Z, we have [[tl)ii 2 E DI,la. 
Proposition. 
(Soundness 
of types.) 
For all 
X,%,t 
and T,ijX;Zt- 
t: 
T thenW;%bt: 
T. 
The type soundness result simply 
states that the mean- 
ing of a typed term corresponds 
to the meaning 
of the 
corresponding 
type. 
The proof is a straightforward 
in- 
duction 
over the structure 
of type inferences. 
Para- 
metricity 
is an analogue of this result, as we shall see in 
the next section. 
6 
The parametricity 
theorem 
In the previous 
section, 
we defined 
a semantics 
where 
a type environment 
A consists 
of a mapping 
of type 
variables 
onto types, 
and the semantics 
of a type 
T 
in the environment 
A is a set denoted DgT 1. In this 
section, we define an alternative 
semantics w 8, ere a type 
environment 
;R consists of a mapping 
of type variables 
onto relations, 
and the semantics 
of a type 
T in the 
environment 
A is a relation 
denoted 
[ Tna. 
We can then formally 
state the parametricity 
theo- 
rem: 
terms in related 
environments 
have related 
val- 
ues. We can think 
of environments 
?i and 2’ as specify- 
ing two different 
representations 
of types, related by A, 
which 
is why Reynolds’ 
called his version of this result 
“the abstraction 
theorem”. 
A key point 
of this paper 
is that this theorem 
has applications 
other than change 
of representation, 
hence the change in name from “ab- 
straction” 
to “parametricity” 
A function 
type may be regarded 
as a relation 
as fol- 
lows. If .4 : A e, A’ and B : B ($ B’ are two relations, 
then we define 
’ 
A - 
B : (A 4 B) # (A’ 4 B’) 
to be the relation 
A + B = ( (j, f’) ] (a, is’) E A implies 
w 
df’a’) 
E B ) 
In other words, functions 
are related if they map related 
arguments 
into related 
results. 
A type abstraction 
may be regarded 
as a relation 
as 
follows. 
Let F be a function 
from U to U, and F’ be a 
function 
from U’ to U’, and for each A in U and A’ in 
U’, let 3 be a function 
that takes a relation 
A : A G+ A’ 
and returns 
a relation 
3(A) : F(A) 
M F’(A’). 
Then we 
define 
V3:VF+VF’ 
356 

to be the relation 
V3 = ( (g, g’) 1 for all A, A’, and A : A H A’, 
MWWWW’N 
E 3(A) 
> 
In other words, type abstractions 
are related if they map 
related 
types into related results. 
A relation 
environment 
maps each type variable 
into 
a relation. 
Let A be a relation 
environment 
for X, and 
let ;I, A’ be two type environments 
for X. 
We write 
A : A o A’ if for each X in X we have &l[X] 
: zl[XI] 
+ 
A’pq. 
Given 
a relation 
environmenb 
A we can interpret 
a 
type T as a relation 
[ Z’]a as follows: 
Let ?i, ii respect 
X, z and A’, TL’ respect 
x, 2. 
We 
say that A, 2, a’, ii, a’ respect X, z if A : ?I * 
A’ and 
(a[[rijl, a’[qn) 
E I[Ti]a 
for each zi : Ti in z. It is easy to 
see that if A, ?i, A’, 7i, pi’ respect X, z then 2, B respect 
x, z and A’, it’ respect X, Z. 
We say that 
jk; z IF t : T iff for every 
2, A, ?i’, zi, ii’ 
that respect x, z we have (fit]&%, [t&&9) 
E [!f]A. 
Proposition. 
(Purametricity.) 
For all X, 
~,t,andT,i/~;~~t:TthenX;zI~tt: 
T. 
Proof. 
The proof is 3 straightforward 
induction 
over 
the structure 
of type inferences. 
For each of the infer- 
ence rules in Figure 2, we r ?place !- by IF and show that 
the resulting 
inference 
is valid. 
(End of proof.) 
As mentioned 
previously, 
data types such as booleans, 
pairs, lists, and natural 
numbers can be defined in terms 
of -+ and V. 
As an example, 
consider 
the construction 
for pairs. 
The type X x Y is defined as an abbreviation: 
xx 
Yd~fvz.x--+ 
Y--t2 
Every term of type X x Y is equivalent 
to a term of the 
form pairxv 
z y, where x : X and y : Y, and pair is 
defined by 
paw - 
. dsf AX. A Y. xx : x. xy : Y. 
AZ.Xp:X-+ 
Y-+Z.pzy 
The type of pair is, of course, 
pair:VX.VY.X--+ 
Y--+Xx 
Y 
where 
X x Y stands for the abbreviation 
above. 
It 
follows from the parametricity 
theorem 
that if A : A - 
A’ and B : B --+ B’, and (a, a’) E A and (b, b’) E 8, 
then 
( UP~~~XY x yll[AlX, 
B/ Yl [a/x, 
b/y], 
[W-XY 
x yll[A’lX, 
B’/ Yl Ia’lx, 
b’lyl 
) 
E [X x Y][A/X, 
B/Y]. 
That 
is, pairs are related if their corresponding 
compo- 
nents are related, 
as we would expect. 
It can be shown similarly, 
using the standard 
con- 
struction 
for lists, that lists are related 
if they have the 
same length 
and corresponding 
elements are related. 
Alternatively, 
suitable 
type constructors 
and individ- 
ual constants 
may be added to the pure polymorphic 
lambda 
calculus. 
In this case, for each new type con- 
structor 
an appropriate 
corresponding 
relation 
must be 
defined; suitable 
definitions 
of relations 
for pair and list 
types were given in Section 
2. Further, 
for each new 
constant 
the parametricity 
condition 
must be verified: 
if c is a constant 
of type T, we must check that I+ c : T 
holds. 
It then follows 
terms built 
from 
the 
stants. 
that parametricity 
holds for any 
new type constructors 
and con- 
7 
Fixpoints 
Every 
term in typed 
lambda 
calculus 
is strongly 
nor- 
malising, 
so if a fixpoint 
operator 
is desired it must be 
added as a primitive. 
This section mentions 
the addi- 
tional requirements 
necessary to ensure that the fixpoint 
primitive 
satisfies the abstraction 
theorem. 
Frame models associate with 
each type A a set DA. 
In order to discuss fixpoints, 
we require 
that 
each set 
have sufficient 
additional 
structure 
to be a domain: 
it 
must be provided 
with 
an ordering 
G such that 
each 
domain 
has a least element, 
I, 
and such that limits 
of 
directed 
sets exist. 
Obviously, 
we also require 
that all 
functions 
are continuous. 
What are the requirements 
on relations? 
The obvious 
requirement 
is that they, too, be continuous. 
That 
is, 
if A : A H A’, and xi is a chain 
in A, and 2: is a 
chain in A’, and (zi, xi’) E A for every i, then we require 
that (u xi, u xi) E A also. But in addition 
to this, we 
need a second requirement, 
namely 
that each relation 
A is strict, 
that is, that (IA, 
J-A,) E A. If we restrict 
relations 
in this way, then it is no longer true that every 
function 
a : A -+ A’ may be treated 
as a relation; 
only 
strict 
functions 
may be treated 
as such. 
With 
this restricted 
view of relations, 
it is easy to 
show that the fixpoint 
operator 
sati&es 
the parametric- 
ity theorem. 
As usual, for each type A define fixA as 
357 

he 
function 
sllch that 
fizz 
f = Uj’ 
1~. 
Parametricity 
holds if 
(fix, fix) 
E VA (A -+ A) ---) A. 
This 
will 
be true 
if fcr each A : A # 
A’ and each (j,f’) 
E A -+ A 
we have (fizA f,fiz..~f 
f’) 
E A. 
Recall 
that 
the con- 
clition 
on f 
and f’ 
means that 
if (2,~‘) 
E A then 
(f c, j’ 5’) E A. Now, since all relations 
are strict, 
it fol- 
lows that (IA, 
IA!) 
E A; hence (f IA, f’ 1~‘) 
E A; and, 
in general, (j’ IA, f” 
IA’) 
E 4. It follows, 
since all re- 
lations 
are continuous, 
that 
(Uji 
IA, 
u f” 
LA!) 
E 4, 
as required. 
Note that 
the restriction 
to strict 
relations 
here is 
similar 
to the restriction 
to strict 
coercion 
functions 
in 
[BCGS89], 
and is adopted for similar 
reasons. 
The requirement 
that 
relations 
are strict 
is essen- 
tial. 
For a counterexample, 
take A to be the domain 
{I, 
true, false}, 
and take A : A 4 
A to be the constant 
relation 
such that 
(z, true) E A for all 5. The relation 
A is continuous 
but not strict. 
Let j be the constant 
function 
f z = fake 
and let f’ 
the identity 
function 
f’ z = z. Then 
A --) A relates f to f’, but A does not 
relate fixA f = f&e to fizA f’ = 1. 
The restriction 
to strict 
arrows 
is not to be taken 
lightly. 
For instance, 
given a function 
r of type 
r : VA.A’ 
-) A* 
parametricity 
implies 
that 
TA’ 0 a* = a* 0 TA 
for all functions 
a : A - 
A’. If the fixpoint 
combinator 
appears in the definition 
of r, then we can only conclude 
that the above holds for strict 
a, which 
is a significant 
restriction. 
The desire to derive 
theorems 
from types therefore 
suggests that it would 
be valuable 
to explore 
program- 
ming languages 
that 
prohibit 
recursion, 
or allow only 
its restricted 
use. In theory, 
this is well understood; 
we 
have aheady noted that any computable 
function 
that is 
provably 
total in second-order 
Peano arithmetic 
can be 
defined in the pure polymorphic 
lambda calculus, 
with- 
out using the fixpoint 
as a primitive. 
However, 
practical 
languages based on this notion 
remain 
terra incognita. 
References 
[BCGS89] 
V. 
Breasu-Tannen, 
T. 
Coquand, 
C. 
A. 
Gunter, 
and A. Scedrov, Inheritance 
and ex- 
plicit 
coercion. 
In 4 ‘th Annual 
Symposium 
on 
Logic in Computer 
Science, Asilomar, 
Cali- 
fornia, 
June 1989. 
[BFSS87] 
E. S. B am rl ge, P. J. Freyd, 
A. Scedrov, 
- b ‘d 
and P. J. Scott, Functorial 
polymorphism. 
In 
G. Huet, editor, Logical Foundations 
of Func- 
tional 
Programming, 
Austin, 
Texas, 
1987. 
Addison-Wesley, 
to appear. 
[BM84] 
K. B. B ruce and A. R. Meyer, 
The seman- 
tics of second-order 
polymorphic 
lambda cal- 
culus. 
In 
Kahn, 
MacQueen, 
and 
Plotkin, 
editors, 
Semantics 
of Data 
Types, Sophia- 
Antipolis, 
France, 1984, pp. 131-144. LNCS 
173, Springer-Verlag. 
[BTC88] 
V. B reazu-Tannen 
and T. Coquand, 
Exten- 
sional models for polymorphism. 
Theoretical 
Computer 
Science, 59:85-114, 
1988. 
(BW86] 
G. Barrett 
and P. Wadler, 
Derivation 
of a 
pattern-matching 
compiler. 
Manuscript, 
Pro- 
gramming 
Research Group, 
Oxford, 
1986. 
[SW881 
R. Bird and P. Wadler, Introduction 
to Func- 
tional 
Programming. 
Prentice 
Hall, 1988. 
(DM82] 
L. Damas 
and 
R. Milner, 
Principal 
type 
schemes 
for functional 
programs. 
In 
Pro- 
ceedings of the 9’th Annual 
Symposium 
on 
Principles 
of Programming 
Languages, Albu- 
querque, 
N.M., 
January 
1982. 
IdeB 
P. J. d B 
e ruin, 
Naturalness 
of polymorphism. 
Submitted 
to Category Theory and Computer 
Science, Manchester, 
1989. 
[FGSS88] 
P. J. Freyd, J. Y. Girard, 
A. Scedrov, and P. 
J. Scott, Semantic 
parametricity 
in polymor- 
phic lambda 
calculus. 
In 8’rd Annual 
Sym- 
posium on Logic in Computer 
Science, Edin- 
burgh, Scotland, 
June 1988. 
(l?L083] 
[ Gir72] 
[~ir86] 
[GLT89] 
S. Fortune, 
D. Leivant, 
and M. O’Donnell, 
The 
expressiveness 
of simple 
and second- 
order type structures. 
Journal 
of the ACM, 
30(1):151-185, 
January 
1983. 
J.-Y. 
Girard, 
Interpre’tation 
junctionelle 
et 
dlimination 
des coupures dans l’arithmktique 
d’ordre 
auptrieure. 
Ph.D. 
thesis, 
UniversitC 
Paris VII, 
1972. 
J.-Y. Girard, 
The system F of variable 
types, 
fifteen years later. 
Theoretical 
Computer 
Sci- 
ence, 45, pp. 159-192. 
J.-Y. 
Girard, 
Y. 
Lafont, 
and 
P. Taylor, 
Proofs 
and 
Tyycs. 
Cambridge 
University 
Press, 1989. 
358 

[HinBQ] 
(HW88] 
(Mes89] 
[ Mi178] 
[Ma841 
(Mi187] 
[Mit86] 
[MM851 
[Pit871 
IRey741 
IJW83] 
iRey841 
R. Hindley, 
The 
principal 
type 
scheme of 
an object in combinatory 
logic. 
Trans. 
Am. 
Math. 
Sot. 146, pp. 29-60, December 
1969. 
P. Hudak 
and P. Wadler, 
editors, 
Report 
on the Functiona! 
Programming 
Language 
HuskelI. 
Technical 
Report 
YALEU/DCS/ 
RR656, Yale University, 
Department 
of Com- 
puter Science, December 1988; also Technical 
Report, 
Glasgow 
University, 
Department 
of 
Computer 
Science, December 
1988. 
J. Meseguer, 
Relating 
models 
of polymor- 
phism. 
In 16’th ACM 
Symposium 
on Prin- 
ciples 
of Programming 
Languages, 
Austin, 
Texas, January 
1989. 
R. Milner, 
A theory of type polymorphism 
in 
programming. 
J. Comput. 
Syst. Sei. 17, pp. 
348-375, 1978. 
R. Milner, 
A proposal 
for 
Standard 
ML. 
In ACMSymposium 
on Lisp and Functional 
Programming, 
Austin, 
Texas, August 
1984. 
R. Milner, 
Changes 
to the Standard 
ML 
core language. 
Report 
ECS-LFCS-87-33, 
Ed- 
inburgh 
University, 
Computer Science Dept., 
1987. 
J. C. Mitchell, 
Representation 
independence 
and data abstraction. 
In 13 ‘th ACM 
Sym- 
posium 
on Principles 
of Programming 
Lan- 
guages, pp. 263-276. 
J. C. Mitchell and A. R. Meyer, Second-order 
logical relations. 
In R. Parikh, 
editor, 
Log- 
its of Programs, 
Brooklyn, 
New York, 1985. 
LNCS 193, Springer-Verlag. 
A. M. Pitts, 
Polymorphism 
is set theoretic, 
constructively. 
In D. H. Pitt, 
et al., editors, 
Category Theory and Computer 
Science, Ed- 
inburgh, 
1987. LNCS 283, Springer-Verlag. 
J. C. Reynolds, Towards a theory of type 
structure. 
In B. Robinet, 
editor, 
Proc. 
Col- 
loque 
5ur 
la 
Programmation, 
LNCS 
19, 
Springer-Verlag. 
J. C. Reynolds, 
Types, abstraction, 
and para- 
metric polymorphism. 
In R. E. A. Mason, ed- 
itor, Information 
Processing 83, pp. 513-523. 
North-Holland, 
Amsterdam. 
J. C. Reynolds, 
Polymorphism 
is not set the- 
oretic. 
In Kahn, 
MacQueen, 
and Plotkin, 
[Re WI 
[She891 
[Tur85] 
1~~891 
editors, 
Semantics 
of Data 
Types, Sophia- 
Antipolis, 
France, 1984, pp. 145-156. LNCS 
173, Springer-Verlag. 
J. C. Reynolds, 
Three 
approaches 
to type 
structure. 
In 
Mathematical 
Foundations 
of 
Software 
Development, 
LNCS 
185, Springer- 
Verlag, 
1985. 
M. Sheeran, Categories 
for the working 
hard- 
ware 
designer. 
In 
Workshop 
on 
Hardware 
Specification, 
Verification, 
and 
Synthesis: 
Mathematical 
Aspects, Cornell, 
July 1989. 
D. A. Turner, 
Miranda: 
A non-strict 
func- 
tional 
language 
with 
polymorphic 
types. In 
Proceedings of the 2’nd International 
Confer- 
ence on Functional 
Programming 
Languages 
and Computer 
Architecture, 
Nancy, 
France, 
September 
1985. LNCS 201, Springer-Verlag, 
1985. 
P. Wadler 
and S. Blott, 
How to make ad- 
hoc polymorphism 
less ad hoc. In 16’th ACM 
Symposium 
on Principles 
of Programming 
Languages, Austin, Texas, January 1989. 
359 

