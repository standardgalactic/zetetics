 
 
 
 
 
A Predictive Autorotation Entry Analysis Using Bayesian 
Multi-Model Estimation Detection 
 
by 
 
Justin N. Martin 
 
 
 
 
A dissertation submitted to the Graduate Faculty of 
Auburn University 
in partial fulfillment of the 
requirements for the Degree of 
Doctor of Philosophy 
 
Auburn, Alabama 
December 16, 2017 
 
 
 
 
Keywords: Autorotation, Bayes’ Theorem, Multi-Model Estimation 
 
 
Copyright 2017 by Justin N. Martin 
 
 
Approved by 
 
Andrew J. Sinclair, Chair, Affiliates Associate Professor of Aerospace Engineering 
John E. Cochran, Jr., Professor of Aerospace Engineering, Emeritus 
Winfred A. Foster, Jr., Professor of Aerospace Engineering, Emeritus 
David A. Cicci, Professor of Aerospace Engineering 
George T. Flowers, Dean of Graduate School 
 

ii 
 
 
 
 
 
Abstract 
 
 
Improvements to achieving helicopter autorotation in an event of engine or 
driveshaft failure is an issue that has and always will be present in the engineering 
landscape.  Questions include, “how much of a performance hit can be taken for the 
proper autorotation tools?” and “how much control should the pilot initially have in the 
event of an engine failure?”  One certain aspect is that upon an engine failure in a 
rotorcraft, every second counts. 
A prediction of future behavior of a rotorcraft can be estimated by feeding 
observational flight data into comparable dynamic and engine analysis models.  The 
comparison of different hypothesis models is combined into a Bayes’ Multi-Model 
Estimation to evaluate the health of the rotorcraft.  Interesting concepts through this work 
are (a) the creation of a coupled dynamic and engine model that is iterated into failure 
models for detecting a risk, (b) the methodology for using multiple models for reducing 
false positives in engine failure detection, and (c) the magnitude of the change in pilot 
recognition time. 
The prediction of a failure in the rotorcraft model can lead to new contributions of 
methods into rotorcraft autorotation detection.  The use of live observation data to project 
the state and health of the rotorcraft at a future time has been shown to be valid.  The 
failure models were to be generated by reasonably changing states and controls in the 
normal functioning model.  As predicted, the aircraft altitude saved due to the significant 

iii 
 
reduction in pilot recognition time is essential for increasing the success of an 
autorotation landing. 
 
 
 

iv 
 
 
 
 
 
 
Acknowledgments 
 
 
The author would like to thank and appreciate his academic advisor, Dr. Andrew 
J. Sinclair.  His leadership and guidance early in the author’s graduate school career were 
beneficial in the completion of this dissertation.  The author would to also recognize Dr. 
Marvin Moulton of the U.S. Army, Aerospace Engineering Directorate.  Under his 
leadership within AED, Dr. Moulton provided the author with the guidance, base 
education of helicopter knowledge, and tools to investigate the topic of this dissertation. 
The author would like to personally thank his wife and son, Leigh Ann and 
Michael Martin, along with his sister, parents, and in-laws for supporting him in every 
step of the doctorate program.  Their love for him is the driving force he needed to 
complete this study. 
Finally, the author would like to thank all of those who have dedicated themselves 
to serving in the Armed Forces and pray for those who have lost their lives doing the 
same.  Whether this work ultimately affects Army helicopter safety or not, the author 
urges readers of this paper to assist the war fighter when possible. 
 
 

v 
 
 
 
 
 
 
Table of Contents 
 
 
Abstract ............................................................................................................................... ii 
Acknowledgments.............................................................................................................. iv 
Table of Contents .................................................................................................................v 
List of Figures ................................................................................................................... vii 
List of Tables .......................................................................................................................x 
List of Variables ................................................................................................................. xi 
1. 
Introduction ................................................................................................................1 
2. 
Evaluation Math Models ............................................................................................7 
2.1. The Dynamic Helicopter Model .................................................................................8 
2.1.1. Aircraft Modeling Configuration ...............................................................................9 
2.1.2. Aircraft Velocity Components .................................................................................11 
2.1.3. Aircraft Rotational Rates ..........................................................................................14 
2.1.4. Aircraft Euler Angles ...............................................................................................16 
2.2. The Dynamic Engine Model ....................................................................................17 
2.3. Coupling of Dynamic and Engine Models ...............................................................23 
2.4. Bayes’ and Multiple Model Estimation ...................................................................27 
2.5. FLIGHTLAB® and VirtualPilot ..............................................................................34 
3. 
Bayes’ Analysis of Rotorcraft Failure Models .........................................................39 
3.1. FLIGHTLAB® Reference Model ............................................................................39 

vi 
 
3.2. Model Configuration for Testing .............................................................................40 
3.3. Model Verification ...................................................................................................41 
3.3.1. Verification of Engine Model ..................................................................................42 
3.3.2. The Coupled Dynamic and Engine Model ...............................................................46 
3.4. Coupled Driveshaft Failure Model ...........................................................................63 
3.5. Coupled Fuel Flow Failure Model ...........................................................................65 
3.5.1. Bias and Turbulence in Coupled Dynamic Model ...................................................66 
3.6. Engine Failure with Non-Recovery ..........................................................................72 
3.6.1. Instantaneous Engine Disconnect .............................................................................72 
3.6.2. Engine Component Wind-Down ..............................................................................77 
3.7. Bayes’ Analysis and Results ....................................................................................82 
3.7.1. Bayes’ Model Selection and Threshold ...................................................................87 
3.7.2. Main Rotor Recovery Response ...............................................................................93 
3.7.3. Altitude Loss Improvement ......................................................................................98 
4. 
Conclusions ............................................................................................................104 
Bibliography ....................................................................................................................108 
Appendices .......................................................................................................................111 
Appendix A – State Representation Form .......................................................................112 
Appendix B – XAnalysis Code ........................................................................................125 
Appendix C – VirtualPilot Command Table ...................................................................142 
 
 
 

vii 
 
 
 
 
 
 
List of Figures 
 
 
Figure 1: Rotor Force Vectors in Autorotation ................................................................... 2 
Figure 2: T701 Turboshaft Engine .................................................................................... 18 
Figure 3: FLIGHTLAB® Model Components with FIQSEM Addition .......................... 21 
Figure 4: Bayes’ Hypothesis and Probability Flow Chart with permission from [14] ..... 31 
Figure 5: Failure Event Detection Scheme ....................................................................... 33 
Figure 6: VirtualPilot Prescribed Maneuver Structure ..................................................... 35 
Figure 7: VirtualPilot Flight Test Data Maneuver ............................................................ 36 
Figure 8: Engine Parameter Input and Output for 60kt Level Flight ................................ 43 
Figure 9: Engine Parameter Input and Output for 80kt Level Flight ................................ 44 
Figure 10: Engine Parameter Input and Output for 100kt Level Flight ............................ 45 
Figure 11: Body Velocities for 60kt Level Flight ............................................................. 48 
Figure 12: Body Angular Rates for 60kt Level Flight ...................................................... 49 
Figure 13: Orientation and Control Inputs for 60kt Level Flight ..................................... 50 
Figure 14: Body Velocities for 80kt Level Flight ............................................................. 51 
Figure 15: Body Angular Rates for 80kt Level Flight ...................................................... 52 
Figure 16: Orientation and Control Inputs for 80kt Level Flight ..................................... 53 
Figure 17: Body Velocities for 100kt Level Flight ........................................................... 54 
Figure 18: Body Angular Rates for 100kt Level Flight .................................................... 55 
Figure 19: Orientation and Control Inputs for 100kt Level Flight ................................... 56 

viii 
 
Figure 20: Body Velocities for 80kt Left Bank ................................................................ 57 
Figure 21: Body Angular Rates for 80kt Left Bank ......................................................... 58 
Figure 22: Orientation and Control Inputs for 80kt Left Bank ......................................... 59 
Figure 23: Body Velocities for 80kt Right Bank .............................................................. 60 
Figure 24: Body Angular Rates for 80kt Right Bank ....................................................... 61 
Figure 25: Orientation and Control Inputs for 80kt Right Bank ....................................... 62 
Figure 26: Sprag Clutch Components and Function ......................................................... 64 
Figure 27: Applied Numerical Bias to Body Axis Velocities ........................................... 67 
Figure 28: Bayesian Response to Body Velocity Biases .................................................. 68 
Figure 29: Model and Bayesian Response to a Longitudinal Disturbance ....................... 69 
Figure 30: Model and Bayesian Response to a Lateral Disturbance ................................ 70 
Figure 31: Model and Bayesian Response to a Collective Disturbance ........................... 71 
Figure 32: Main Rotor Fuel Flow for Instantaneous Failure ............................................ 73 
Figure 33: Model Control Inputs to Maintain Steady-State Flight ................................... 74 
Figure 34: Angular Response to Instantaneous Failure .................................................... 75 
Figure 35: Rotor Speed for Instantaneous Failure ............................................................ 76 
Figure 36: Generator and Turbine Speed for Instantaneous Failure ................................. 76 
Figure 37: Engine Parameters for a Wind-Down Failure ................................................. 78 
Figure 38: Engine Fuel Flow for Wind-Down Failure ..................................................... 79 
Figure 39: Angular Response for Wind-Down Failure..................................................... 80 
Figure 40: Main Rotor Speed for Wind-Down Failure ..................................................... 81 
Figure 41: Generator and Turbine speeds for Wind-Down Failure .................................. 81 
Figure 42: Kalman Filter Estimation ................................................................................ 82 

ix 
 
Figure 43: Swashplate Control Inputs............................................................................... 84 
Figure 44: Hypothesis Model Flow Chart for 3-Model System ....................................... 86 
Figure 45: Failure Recognition for 60 kts Instantaneous .................................................. 88 
Figure 46: Failure Recognition for 80 kts Instantaneous .................................................. 89 
Figure 47: Failure Recognition for 100 kts Instantaneous ................................................ 89 
Figure 48: Degradation of Normal Probability for Instantaneous Failure ........................ 90 
Figure 49: Failure Recognition for 60 kts Wind-Down .................................................... 91 
Figure 50: Failure Recognition for 80 kts Wind-Down .................................................... 91 
Figure 51: Failure Recognition for 100 kts Wind-Down .................................................. 92 
Figure 52: Degradation of Normal Probability for Wind-Down Failure .......................... 93 
Figure 53: Rotor Speed Recovery with Instantaneous Failure ......................................... 95 
Figure 54: Rotor Speed Recovery with Wind-Down Failure ........................................... 97 
Figure 55: Steady-State Descent Rate for Instantaneous Failure...................................... 99 
Figure 56: Steady-State Descent Rate for Wind-Down Failure ........................................ 99 
Figure 57: Landing Area Benefit for Quick Response ................................................... 102 
Figure 58: Rotor Speed Recovery Time Between Models ............................................. 103 
Figure 59: VirtualPilot Level Flight and Banked Turn Scheme ..................................... 142 
Figure 60: VirtualPilot Autorotation Scheme ................................................................. 143 
 
 
 

x 
 
 
 
 
 
 
List of Tables 
 
 
Table 1: Utility Helicopter Configuration........................................................................... 8 
Table 2: Equations of Motion Parameter Source .............................................................. 10 
Table 3: Engine Model Parameter Source ........................................................................ 22 
Table 4: Effects of Delayed Response for Instantaneous Failure ................................... 100 
Table 5: Effects of Delayed Response for Wind-Down Failure ..................................... 101 
 
 
 

xi 
 
 
 
 
 
 
List of Variables 
 
 
Variables by Letter 
a0  
 
Main Rotor Blade Lift-Curve Slope 
a0T  
Tail Rotor Blade Lift-Curve Slope 
b  
Number of Main Rotor Blades 
BLCG 
Buttline Center of Gravity Position 
CQ  
Main Rotor Torque Coefficient 
CTT  
Tail Rotor Thrust Coefficient 
Cx, Cy, Cz  
Main Rotor Force Coefficients in Shaft-Axis x-y-z 
CZTP  
Normalized Tailplane Force 
D, E, F, G, Z  
Simplified Engine Model Coefficient Matrices 
F0(1), F1s(1), F1c(1), 
Harmonic Comp. of Integrated Blade Aerodynamic Loads 
F2s(1),F2c(1), F1s(2), F1c(2)  
FSCG 
Fuselage Center of Gravity Position 
FT  
Tail Rotor Fin Blockage Factor 
g  
Gravity Constant (32.174 ft/s2) 
GW 
Rotorcraft Gross Weight 
hp 
Pressure Altitude 
hr  
Height of Main Rotor Hub Above Fuselage Ref. Point 
hT  
Height of Tail Rotor Hub Above Fuselage Ref. Point 
I  
Flap Moment of Inertia 
IR  
Main Rotor Moment of Inertia 
Ixx, Iyy, Izz  
Moments of Inertia 
Ixz  
Products of Inertia 
K  
Flapping Spring at Hinge 
L, M, N  
External Moments on Aircraft in Body x-y-z 

xii 
 
lT  
Tail Rotor Hub Distance Aft from Fuselage Ref. Point 
lTP  
Tail Center of Pressure Aft from Fuselage Ref. Point 
Ma  
Mass of the Aircraft (683.782 slugs) 
Ng  
Gas Generator Speed 
Np  
Power Turbine Speed 
p, q, r  
Aircraft Angular Rates in Body x-y-z 
PS3  
Static Pressure at Station 3 
QS  
Engine Shaft Torque 
R  
Main Rotor Radius 
RT  
Tail Rotor Radius 
s  
Main Rotor Solidity 
sT  
Tail Rotor Solidity 
STP  
Tail Rotor Plane Area 
T45  
Temperature at Station 4.5 (TGT) 
u, v, w  
Aircraft Velocity in Body x-y-z 
u(k)  
Engine Model Control Vector 
VT  
Tangential Velocity of Tail Rotor 
wf  
Engine Fuel Flow 
WLCG 
Waterline Center of Gravity Position 
X, Y, Z  
External Forces on Aircraft in Body x-y-z 
x(k)  
Engine Model State Vector 
x(k+1)  
Engine Model State Vector Advanced One Step 
xcg  
Center of Gravity Position Forward of Fuselage Ref. Point 
y(k)  
Engine Model Observation Vector 
 
Variables by Symbol 
TP  
Incidence for Tailplane 
0  
Main Rotor Coning Angle 
1cw  
1st Harmonic Cyclic Flapping Angle, Longitudinal 
1sw  
1st Harmonic Cyclic Flapping Angle, Lateral 

xiii 
 
  
Lock Number 
s  
Main Rotor Shaft Forward Tilt 
 
Non-uniform Flow and Tip Loss Factor 
0  
Total Inflow Across Rotor Disk 
1cw  
1st Harmonic Inflow Component of Cosine 
1sw  
1st Harmonic Inflow Component of Sine 
  
Main Rotor Speed 
T  
Tail Rotor Speed 
, ,   
Euler Angles 
  
Air Density (0.0023769 slugs/ft3) 
0  
Main Rotor Collective Pitch 
1cw  
Total Lateral Swashplate Angle 
1sw  
Total Longitudinal Swashplate Angle 
tw  
Tail Blade Twist 
  
Rotor Tip Speed Ratio, In-Plane
z  
Rotor Tip Speed Ratio, Normal to Plane 
 
 
 

1 
 
 
 
 
 
 
1. Introduction 
 
 
Rotorcraft function by driving the main rotor(s) to push air down, and when 
combined with rotor blade lift, the rotorcraft can fly.  In an autorotation, when either 
torque is no longer supplied to the main rotor or the angle of attack on the rotor blades is 
low, the aircraft descends and the air flow through the rotor changes direction to move 
upward through the rotor.  The air flowing through the rotor still drives the rotor blades to 
continue turning.  The potential energy (due to altitude) is transitioned to kinetic energy 
(rotor and translational speed).  The rotorcraft may still be maneuvered while the rotor 
speed is maintained near 100%.  When an engine fails, a pilot has approximately 2.0 
seconds to begin actions to enter an autorotation.  If the entry is delayed, the rotor speed 
may decay to a point that is unrecoverable given the altitude of the aircraft and time 
required to recover the rotor speed.  An automated process could avoid this decay in rotor 
speed and allow a pilot more time to locate and maneuver to a safe landing site. 
Autorotation can be broken into three basic phases; entry consisting of the first 3-
5 seconds, descent, and flare/landing.  The dangers in an engine failure are loss of aircraft 
control due to degradation of main rotor speed, acquisition of a safe landing site and 
maneuvering to the landing site with enough rotor energy to execute a proper autorotation 
landing.   
Therefore, the air flowing upward through the rotor mixed with the airflow from 
the aircraft’s forward speed is the only means of driving the rotor blades to continue their 

2 
 
motion.  As shown in Figure 1, the upward flow turning the main rotor allows the 
rotorcraft to maneuver into a landing position and complete a controlled landing. 
 
 
Figure 1: Rotor Force Vectors in Autorotation 
Reprinted with permission from Dynamic Flight, Inc., by M. J. Zeldes, 2017, Retrieved from 
www.dynamicflight.com/aerodynamics/autos/, Copyright 2010 by Dynamic Flight, Inc. 
 
The diagram is an example of aerodynamic forces present on a rotor blade in 
autorotation.  “Section A” shows the rotor tip with the resultant aerodynamic vector 
broken into the lift and drag vectors.  The drag vector component along the tip path plane 
is greater than the lift vector component along the tip path plane.  This results in a force 
working against the rotation of a torque-less rotor.  The increase in total drag within the 

3 
 
resultant vector is primarily due to the increase in speed (v =  x r), and possibly due to 
twist along the span of the rotor blade increasing the drag coefficient.  “Section C” is the 
focus of autorotation flight.  If the angle of attack is reduced due to a collective stick 
decrease, the resultant force tilts in front of the axis of rotation.  This creates a driving 
force causing the rotor to maintain rotational energy.  The reduction of angle of attack 
results in the lift force component in the tip path plane being greater than the drag force 
component in the tip path plane.  “Section E” is another area where the resultant force 
works against the motion of the rotor.  This is caused by the very low speeds in this 
region.  However, this region does not significantly contribute to the rotor lift or drag.  
The goal for a pilot is to set the collective input to a position where the total driving force 
is greater or equal to the total driven force.   
It is debatable what the most important aspect of an autorotation is the reaction 
time immediately following an engine failure or the descent to a safe landing zone.  Pilots 
are permitted approximately 2.0 seconds of reaction time immediately following an 
engine failure to begin recovery of the rotorcraft.  Pilot models to represent these actions 
are intended to account for sensorial perceptions, control behaviors and command 
actuations [1]. 
From a pilot’s point of view, an autorotation is as simple as recognizing the 
direction air is flowing through the main rotor.  However, from the early stages of pilot 
development in training scenarios containing known malfunctions to the later stages on 
battlefields and “routine” flight plan assignments, engine malfunctions followed by a 
poorly performed autorotation can cost the salvation of an aircraft and the lives of its 
crew members. 

4 
 
A primary failure for pilots occurs within the first 3-5 seconds of an engine 
failure.  Physically, the engine ceases to provide torque to the rotor shaft and rotor gear 
boxes.  With no torque being provided, drag on the main rotor blades begin to quickly 
decrease the rotor speed, otherwise known as rotor droop.   The more collective stick 
applied by the pilot, the greater the angle of attack of each rotor blade causing an increase 
in the airfoil drag, decelerating the main rotor at a faster rate.  The indicators provided to 
the pilot (besides cockpit bells and whistles), are in the dynamic and engine response to 
the reduction in power.  The rotorcraft will nose down because the utility helicopter’s 
center of gravity is aft of the main rotor position [2], yaw left due to the decrease in 
torque applied to the main rotor, an audible main rotor speed decrease and change in 
engine noise, and either loss or altitude or pilot addition of collective stick [3].  The U.S. 
Army has also indicated that a pilot is not to respond to the aircraft main rotor audio or 
multi-function/multi-purpose displays alone [3].  The U.S. Army has a mission goal for 
pilots to be able to decipher all the provided indicators, sort through the cockpit alerts, 
analyze their current flight state, and develop a plan of action, all within 2.0 seconds [4].  
In some cases, that time threshold is not met, pilots continue to make errors trying to 
protect their aircraft and crew, and in turn, the aircraft is lost. 
Previous work has been conducted to prevent the main rotor speed from decaying 
in the event of an engine failure.  The work has ranged from increasing the moment of 
inertia of the rotor blades by adding masses in various positions, to sliding masses along 
the rotor blade to increase and decrease inertia, to even applying small rockets at the end 
of the rotor blades to force the rotor blade to keep spinning [5].  However, improvements 
proposed for autorotation performance was too great of a cost to the aircraft functionality 

5 
 
and performance, effecting the feasibility and basic reasoning for having the aircraft in 
the first place [5].  An area that can still help maintaining control of a malfunctioning 
aircraft is by assisting the pilot to ensure the 2.0 second reaction time is upheld.  Research 
has gone as far as giving physical and haptic cues through stick force gradients to reduce 
this reaction time [6]. 
With the focus directed to the first 3-5 seconds following an engine failure, a 
means to reliably and more quickly detect a failure will be developed.  The areas of the 
aircraft to be analyzed are the dynamic responses to the rotorcraft airframe and the 
thermodynamic responses at sensor areas of the turboshaft engine driving the rotor 
system.  Each model will be treated separately and then combined using a Bayes’ 
Theorem Multiple Model Estimation (MME).  The conditional probabilities are 
calculated, which equates the dependency between random variables to decide on the 
state of a single variable [7].  The early detection of an engine failure reduces the “pilot” 
delay time from 2.0 seconds to a moment the math models indicate a failure. 
The probability analysis will require a Kalman filter for each model prior to 
calculating the MME.  Once combined, scenarios of various engine failures in various 
flight states will be evaluated and reported.  The groundwork will be in place to apply a 
software code to an aircraft in order detect a probable autorotation scenario at a pace 
faster than a pilot.  
Chapter 2 will introduce and couple an 8-state dynamic model with a 2-state 
engine model.  The dynamic model will consist of three body velocities, three body 
angular velocities, and two angular orientations using the swashplate positions as the 
control.  The engine model defines the engine generator speed and power turbine speed 

6 
 
with the fuel flow serving as the control.  The two models will be coupled together using 
the mechanical gear ratio between the power turbine speed and main rotor speed. 
Chapter 3 will proceed to evaluate the quality of the models used to evaluate the 
Bayesian estimation along with determining the estimation sensitivities due to external 
forces such as turbulence and internal phenomena such as instrument error.  The 
evaluation will be over the full (10x10) normal model.  Engine verification will also be 
completed to ensure the system is appropriate to couple with the dynamic model.  The 
second half of Chapter 3 will be used to record and analyze the results of the Bayesian 
estimation.  The estimation will lead to pilot reaction time analysis, and concluded with a 
calculation of the difference in altitude loss based upon the various pilot reaction times, 
Bayesian and delayed.  
 
 
 
 

7 
 
 
 
 
 
 
2. Evaluation Math Models 
 
 
As described in future sections, the Bayes’ Analysis will compare multiple 
weighted prediction models to determine the quickest means of verifying that an engine 
failure has occurred and the pilot should enter an autorotation to prepare for landing.  The 
two prediction models which are capable of being modeled are the dynamic model and 
the engine model.  The dynamic model uses the rate changes and orientation changes the 
helicopter undergoes to predict an engine failure.  The engine model examines key 
parameters that are capable of being measured to predict a failure.  This chapter discusses 
the development of the two models, the foundation of the Bayes’ analysis for predicting 
failure, and the integration into the FLIGHTLAB® and VirtualPilot environment.  
FLIGHTLAB® is the component-based modeling and simulation software developed by 
ART, Inc.  FLIGHTLAB® applies built-in solvers to progress a rotorcraft simulation 
model consisting of dynamic, aerodynamic, propulsion, and control systems through 
timesteps for model development and analysis.  The VirtualPilot is an Army AED 
developed product which applies either flight test data in the form of stick inputs or state 
responses or user prescribed maneuvers to calculate and apply stick control positions to 
drive the rotorcraft simulation. 
 
 

8 
 
2.1. The Dynamic Helicopter Model 
 
 
In the event of an engine failure, whether it be engine-related or aircraft damage 
related such as gear box or drive shaft failure, the aircraft will lose energy.  The energy 
can be in the form of potential energy as the helicopter begins a descent, or the form of 
kinetic energy as the rotor speed begins to droop.  Once the rotor speed begins to droop 
from its initial trimmed state, the aircraft position, speed, and orientation change.  Using a 
dynamic model of the helicopter, the future states of the aircraft can be estimated and 
provide breadcrumbs for determining an engine failure. 
The utility helicopter model is based from the UH-60 model described in work 
associated with the U.S. Army.  For this model, NACA 0012 airfoils were applied to the 
aircraft main rotor.  The tail rotor is modeled as a rotor disk and not with individual 
airfoils.  The physical configuration for the utility helicopter is described in Table 1. 
 
Variable 
Value 
Model Source 
Ma 
683.782 slugs 
Aircraft Config. 
IXX 
7344.17 slug-ft2 
Aircraft Config. 
IYY 
46372.17 slug-ft2 
Aircraft Config. 
IZZ 
43384.33 slug-ft2 
Aircraft Config. 
IXZ 
1661.08 slug-ft2 
Aircraft Config. 
R 
26.8 feet 
FLIGHTLAB 
RT 
5.5 feet 
FLIGHTLAB 
xcg 
360.0 inches 
FLIGHTLAB 
 
Table 1: Utility Helicopter Configuration 
 

9 
 
The described UH-60 configuration is to be used for every FLIGHTLAB® test.  
The mass characteristics will remain constant.  An assumption that is to also be made is 
no fuel weight is to be burned and expelled in a simulation.  Therefore, the UH-60 mass, 
inertias, and CG’s will remain constant throughout.  
 
 
2.1.1. Aircraft Modeling Configuration 
 
 
The configuration of the utility helicopter model will remain consistent 
throughout the simulation and analysis of the engine failure and detection.  Table 2 
defines the values assigned to the variables in each equation of motion along with a 
substantiation report as to where the values originated.  The last part is crucial for 
documentation, as values may have been assigned values from reference [8], the 
FLIGHTLAB® initial variables for a utility helicopter configuration, an updating 
variable linked to the simulation model at each time step, or simply calculated with an 
equation.  Table 2 will cover the variables for all three sections covering the aircraft 
dynamic equations of motion.    
 
 

10 
 
Variable 
Value 
Model Source 
a0 
5.73 
Thanapalan Ref. 
a0T 
5.73 
Thanapalan Ref. 
CQ 
rotor1_rotor_cpg_xaout_cq 
FLIGHTLAB 
CTT 
rotor2_rotor_cpg_xaout_ct 
FLIGHTLAB 
CZTP 
0 
Assumption 
FT 
-0.402 
Thanapalan Ref. 
hr 
5.5 
Aircraft Config. 
hT 
6.3150 
Aircraft Config. 
I 
rotor1_rotor_data_bsm 
FLIGHTLAB 
IR 
rotor1_rotor_data_bsm 
FLIGHTLAB 
K 
rotor1_rotor_data_flapkk 
FLIGHTLAB 
lT 
31.17 
Aircraft Config. 
lTP 
0 
Assumption 
S 
0.08210 
Thanapalan Ref. 
sT 
0.79 
Aircraft Config. 
STP 
0 
Assumption 
VT 
0 
Assumption 
TP 
0 
Assumption 
0 
rotor1_rotor_cpg_xaout_a0f 
FLIGHTLAB 
1cw 
rotor1_rotor_cpg_xaout_b1f 
FLIGHTLAB 
1sw 
rotor1_rotor_cpg_xaout_a1f 
FLIGHTLAB 
s 
0.0523 
Thanapalan Ref. 
0 
rotor1_rotor_cpg_xaout_lambdai 
FLIGHTLAB 
0 
rotor1_rotor_cpg_xaout_theta0 
FLIGHTLAB 
1cw 
rotor1_rotor_cpg_xaout_a1s 
FLIGHTLAB 
1sw 
rotor1_rotor_cpg_xaout_b1s 
FLIGHTLAB 
tw 
-0.314 
Thanapalan Ref. 

airframe_cpg_xaout_vxb / (R) 
FLIGHTLAB 
z 
airframe_cpg_xaout_vzb / (R) 
FLIGHTLAB 
 
Table 2: Equations of Motion Parameter Source 
 
For determining both the translational and rotational velocity components, a few 
assumptions were made in addition to those chosen by Thanapalan [8].  First, the aircraft 

11 
 
model is commanded to fly in coordinated flight, therefore the sideslip angle is zero 
degrees for straight and curved flight.  Second, the tail rotor is modeled as a disk rotor, 
making the blade lift curve slope zero.  Third, the angle of attack for the fuselage is 
assumed to be zero degrees. 
 
 
2.1.2. Aircraft Velocity Components 
 
 
The first set of equations of motion are for the aircraft velocity through the center 
of gravity.  Note that the speeds are all body-fixed variables, where u is out the nose of 
the aircraft, v is out the starboard side of the aircraft, and w is out the bottom of the 
aircraft. 
As defined in Aponso [9], the body-fixed velocity rate components have been 
described as: 
 
 
a
M
X
g
qw
rv
u
/
sin






 
 ( 1 ) 
a
M
Y
g
ru
pw
v
/
sin
cos







 
( 2 ) 
a
M
Z
g
pv
qu
w
/
cos
cos







 
( 3 ) 
 
The velocity components consist of a coupled relationship between translational 
and angular speeds, the contribution of gravity, and external forces due primarily to 
aerodynamic forces applied to the fuselage and rotor.  Those aerodynamic forces, as 
defined in Padfield [10] are: 

12 
 
 




s
a
C
s
a
R
R
s
a
C
s
a
R
R
X
Z
s
X
s
0
0
2
2
0
0
2
2
2
sin
2
1
2
cos
2
1










 
( 4 ) 










s
a
C
s
a
R
R
Y
Y
0
0
2
2
2
2
1


 
( 5 ) 






TP
ZTP
TP
T
Z
s
X
s
C
S
V
R
s
a
C
s
a
C
s
a
R
R
Z






2
2
0
0
0
2
2
2
1
2
cos
2
sin
2
1























 
( 6 ) 
 
CX, CY, and CZ are the main rotor force coefficients in the shaft axis.  Because of 
the assumption of coordinated flight, shaft axis is also representing the hub-wind axis.  
The rotor force coefficients are functions of the harmonics of blade aerodynamic loads 
and flapping.  The harmonic components are defined in Equations (7-9). 
 
2
4
2
4
2
2
)
2
(
1
1
)
1
(
2
0
)
1
(
1
1
)
1
(
2
)
1
(
0
0
s
sw
s
c
cw
c
X
F
F
F
F
F
s
a
C




















 
( 7 ) 
2
4
2
4
2
2
)
2
(
1
1
)
1
(
2
0
)
1
(
1
1
)
1
(
2
)
1
(
0
0
c
cw
s
s
sw
c
Y
F
F
F
F
F
s
a
C




















 
( 8 ) 
)
1
(
0
0
0
2
2
F
s
a
C
s
a
C
T
Z
















 
( 9 ) 
 
 
 
 

13 
 
where 
 

tw
Z
w
sw
p
F








2
0
1
2
0
)
1
(
0
1
4
1
2
2
2
2
3
1


























 
( 10 ) 














tw
Z
sw
cw
sw
s
p
F








3
2
3
0
0
1
1
1
)
1
(
1
 
( 11 ) 
2
3
0
1
1
1
)1
(
1









cw
sw
cw
c
q
F
 
( 12 ) 











0
1
1
1
)1
(
2
2
2





cw
w
sw
cw
s
q
F
 
( 13 ) 



















2
2
2
0
1
1
1
)
1
(
2
tw
sw
w
cw
sw
c
p
F







 
( 14 ) 








0
0
1
1
1
1
1
0
1
1
0
1
1
1
2
0
1
1
0
1
1
1
1
1
1
0
1
0
2
)
2
(
1
2
4
4
8
3
2
4
2
4
4
3
4
4
2
a
q
p
p
p
q
p
F
sw
cw
w
cw
cw
sw
w
Z
sw
tw
c
Z
cw
sw
cw
Z
cw
sw
sw
cw
sw
cw
sw
cw
Z
sw
s


















































































































 
( 15 ) 

14 
 

























































































0
1
1
1
1
1
0
1
1
0
1
1
1
0
1
1
0
1
1
1
1
1
1
0
1
0
0
)
2
(
1
2
4
2
4
2
8
3
4
2
2
3
4
3
4
3
4
2







































sw
cw
w
sw
cw
sw
w
Z
cw
sw
sw
cw
tw
sw
sw
cw
cw
sw
sw
sw
cw
cw
Z
cw
Z
c
q
p
q
q
p
q
F
 
( 16 ) 
 
If the aircraft model were to be simulated, the controls for longitudinal and lateral 
cyclic and collective stick inputs are input components to the flight control system to 
produce the resultant collective and cyclic pitch variables applied to the rotorcraft 
swashplate.  However, because the flight control system of the utility rotorcraft used is 
proprietary, only approximate swashplate angles are to be used.  The calculation of stick 
inputs into an approved flight control system to apply to the swashplate actuators is 
considered to be beyond the scope of work of this paper. Therefore, the output of the 
cyclic and collective swashplate angle components from FLIGHTLAB® will suffice. 
 
 
2.1.3. Aircraft Rotational Rates 
 
 
Like the translational velocities presented in the previous section, the aircraft 
rotational rate changes are defined about the center of gravity of the aircraft.  The roll, 
pitch, and yaw rates are defined as p, q, and r, respectively, and are about the body-fixed 
x, y, and z axis.  The body rotational rates are defined as: 

15 
 
 










xx
xx
xz
xz
zz
xx
xx
xz
xx
xz
xz
zz
xx
xx
xx
zz
yy
xz
xz
yy
xx
xx
xz
xx
zz
yy
I
L
pq
I
I
I
I
I
I
N
I
I
L
I
I
I
I
I
qr
I
I
I
I
pq
I
I
I
I
I
qr
I
I
I
p














2
2
2
2
2
2

 
( 17 ) 






M
I
r
p
I
pr
I
I
I
q
yy
xz
xx
zz
yy
1
1
2
2






 
( 18 ) 




2
2
2
2
xz
zz
xx
xx
xz
xz
zz
xx
xx
zz
yy
xz
xz
yy
xx
xx
I
I
I
N
I
L
I
I
I
I
qr
I
I
I
I
pq
I
I
I
I
r











 
( 19 ) 
 
The angular rate equations of motion consist of both the coupled translational and 
rotational effects along with the external moments applied to the aircraft by fuselage, 
main rotor, and tail rotor aerodynamic forces and moments.  Similar to the external 
forces, Padfield [10] defines the external moments (L, M, N) as: 
 






T
T
T
TT
T
T
T
T
T
T
Y
R
s
F
s
a
C
R
s
a
R
h
s
a
C
s
a
R
R
h
K
b
L
























0
2
0
2
0
0
2
2
1
2
2
1
2
2
1
2





 
( 20 ) 










TP
ZTP
TP
T
cg
TP
Z
s
X
s
cg
Z
s
X
s
R
s
C
S
V
R
x
l
s
a
C
s
a
C
s
a
R
R
x
s
a
C
s
a
C
s
a
R
R
h
K
b
M










2
2
0
0
0
2
2
0
0
0
2
2
1
2
1
2
cos
2
sin
2
1
2
sin
2
cos
2
1
2















































 
( 21 ) 

16 
 










T
T
TT
T
T
T
T
T
cg
T
Y
cg
R
Q
F
s
a
C
R
s
a
R
x
l
s
a
C
s
a
R
R
x
bI
I
s
a
C
sa
R
R
N









































0
2
0
2
0
0
2
2
0
0
3
2
2
2
1
2
2
1
'
2
2
2
1







 
( 22 ) 
 
The effects of the tail rotor when using a FLIGHTLAB® model are different than 
described.  The model uses a disk rotor rather than a blade model, leading the moments 
from the rotor as simply a thrust output across a moment arm.  Referencing Table 2, these 
are some of the assumptions used to zero out an aerodynamic force or moment.  Similar 
to the external forces, the external moments are broken into the rotor dynamic equations 
as functions of the control parameters. 
 
 
2.1.4. Aircraft Euler Angles 
 
 
The aircraft Euler angles are the roll, pitch, and yaw angles of the fuselage with 
respect to an earth-fixed coordinate system.  The equations of motion are based upon the 
angular rates and current measured positions. 
 





tan
cos
tan
sin
r
q
p




 
( 23 ) 



sin
cos
r
q



 
( 24 ) 





sec
cos
sec
sin
r
q



 
( 25 ) 
 
 

17 
 
For practical purposes, the yaw angle is not a parameter of concern since the 
aircraft may have a heading of any direction and will not change the motion of the 
aircraft.  However, the rate of change in yaw is of great importance when determining if 
an engine failure has occurred.  The yaw rate will change when power is no longer 
provided to the tail rotor. 
 
 
2.2. The Dynamic Engine Model 
 
 
As the airframe and rotor system states can provide indications of an engine 
failure in a rotorcraft, there is also the opportunity to measure engine parameters such as 
temperature, pressure, torque, etc. to hypothesize on such an engine failure.  For the 
utility helicopter in question, a basic T-701 turboshaft engine will be modeled to evaluate 
the engine criteria.   
The Army incorporated tandem T700-GE-700 series engines in the Apache attack 
and Blackhawk utility helicopters [11].  The 1600-hp class turboshaft engine consists of 4 
basic phases; the compressor, combustion chamber, gas generator turbine, and power 
turbine [12].  The compressor reduces the volume of the gas, thereby increasing the 
pressure.  The pressurized air is sent to the combustor, where the air/fuel mixture is 
combusted, significantly increasing the temperature and pressure of the combusted air 
mixture.  The high-pressurized air powers the axial spinning of the gas generator turbine, 
thereby powering the compressor to continue sending pressurized air to the combustor.  
The remainder of the energy from the combustor that is not used in the gas generator 

18 
 
turbine is used to power the free spinning power turbine.  As shown in Figure 2, the 
power turbine is mechanically linked to the rotor system [12].  
 
 
Figure 2: T701 Turboshaft Engine 
 
A feature of rotorcraft systems is that various degrees of freedom are highly 
coupled.  Therefore, when it comes to detecting an engine failure, multiple indicators are 
available for the pilot or any flight control system.  Within the engine, the T45 
temperature, Ng, Np, and the torque output can be monitored with sensors and will show 
signs of an engine failure.  The T45 temperature is the air and fuel mixture temperature 
leaving the combustor and entering the turbine of the engine.  An engine failure would 
result in a combustor failure and temperature drop.  The gas generator speed is the 
resultant of the compressors and combustor.  The torque from the gas generator drives the 
power generator turbines.  Like the combustor failing to heat the air, the Ng and Np will 
fail to maintain speed.  Finally, the torque output, related to the Np will not be significant 
enough to drive the rotor system.  Any and all of these components are capable of being 
used for model hypotheses if integrated into engine model equations of motion. 

19 
 
The handling response of the aircraft also degrades upon an engine failure.  
According to pilot manuals, upon an engine failure a rotorcraft will lose rotor speed, pitch 
down and yaw to the left.  The aircraft will pitch down due to the reduction in lift and the 
main rotor being slightly ahead of the aircraft CG.  The left yaw will occur due to the loss 
of counter torque in the tail being overpowered by the friction in the main rotor (rotates 
CCW from a top view) [3].  These are typically signs for a pilot, along with cockpit 
indicators, that an engine failure has occurred.  Waiting for attitude changes to detect 
engine failure introduces lag.  The pilot is constantly making adjustments to hold pitch 
attitude and heading before an engine failure.  Combined with a slower response due to 
the mass and size of a rotorcraft, valuable time is lost before a pilot reaction.  
The model simulation used for the following research representing the T700 
turboshaft engine is described by Ballin [12].  The author used the following assumptions 
for a model representing a turboshaft engine: 
• Each stage of engine model applies the conservation of mass. 
• Previously acquired empirical data was used to account for losses attributed to  
 
fluid dynamic or mechanical processes. 
• The power turbine efficiency represented as a function of power turbine speed 
 
was ignored. 
• Secondary effects such as bleed flows and variable vane geometries were 
 
represented by linear relationships and are always in the nominal position. 
Using the assumptions, the model uses the inlet values of pressure and 
temperature to march through the various components of the engine model, calculating 
enthalpy, mass flows, and gas and power turbine torques along the way.  The author 

20 
 
provides multiple case studies for varying state vectors to drive the simulation.  The state 
vector chosen consists of both the gas generator speed and power turbine speed [12].  The 
control input is the fuel flow introduced prior to combustion. 
Additional assumptions were made by the author per the suggestions in Duyar 
[11].  The assumptions were applied to the model beyond the scope of the engine model 
developed by Ballin [12]. 
• The power turbine is mechanically linked to the rotor system, and the main 
 
rotor speed is a constant ratio to that of the power turbine speed. 
• When operating with a healthy engine, model variables are to be adjusted to 
 
attempt to maintain a constant power turbine speed through the engine load 
 
sharing sub-function written by AED. 
Ballin [12] describes multiple configurations for variable state vector sizes.  The 
models examined use a combination of the gas generator speed (NG), the power turbine 
speed (NP), the total pressure at the compressor outlet (P3), the total pressure at the gas 
generator inlet (P41), the total pressure at the power turbine inlet (P45), and the total 
pressure at the gas generator input (T41).  Note that station 41 is also considered the 
combustor outlet. 
While increasing the number of parameters should lead to a more reliable engine 
model, Ballin presents the two degree-of-freedom model approximates the dynamics 
between the control volumes of the engine compressor, combustor, gas generator, and 
power turbine interact instantaneously, rather than implementing a time delay for fluid to 
pass through the engine components [12].  This paper uses the two degree-of-freedom 
model as opposed to those with more states because of the information available through 

21 
 
the Army FLIGHTLAB® Integrated Quasi-Steady Engine Module (FIQSEM) model 
along with the age of the development of the small turboshaft paper.  The Army FIQSEM 
model serves to bypass the modeling and dynamics for the propulsion system to better 
apply features such as malfunction notifications, current engine dynamics and 
performance, and cockpit outputs.  Figure 3 shows the FIQSEM implementation into a 
FLIGHTLAB® model for the Army.  However, the internal structure of the FIQSEM 
model is unknown to the author, preventing the use of engine temperatures and pressures 
at various stations.  The age of the Ballin model also led to the reduction of variables.  
The paper was published in 1988.  Significant advancement in engine performance, fuel 
performance, and material composition introduces enough discrepancy into the system 
that a lower number of states is preferred.  The reduction in fuel flow and the known 
gearing ratio between the power turbine and main rotor system are appropriate to 
represent failure models for this research.   
 
 
Figure 3: FLIGHTLAB® Model Components with FIQSEM Addition 
 

22 
 
Ballin [12] uses three different flight conditions in which to tune the engine 
models.  The conditions are a high-powered flight condition, power levels associated with 
the utility helicopter performing around the bucket speed, and power levels that occur in 
a controlled descent.  The second condition for operation around the bucket speed was 
chosen for the engine model.  The model was chosen to operate at normal flight 
conditions.  The model will only evaluate the initial moments of an engine failure and not 
the steady descent phase, therefore the descent condition is ignored.  Table 3 outlines the 
variables that are to be used for the engine model along with the original source as they 
enter model for substantiation purposes.  If the source is from the computer software, 
FLIGHTLAB®, the path to the variable is also provided to avoid confusion within the 
software package structure. 
 
Variable 
Value 
Model Source 
A, b 
Large Matrices 
Ballin Ref. 
Ng 
propulsion_data_FIQSEMOUTPUT_pcng1 
FLIGHTLAB 
Np 
propulsion_data_FIQSEMOUTPUT_pcnp1disp 
FLIGHTLAB 
wf 
propulsion_data_FIQSEMOUTPUT_wfpph1disp 
FLIGHTLAB 
 
Table 3: Engine Model Parameter Source 
 
With the exception of the matrices used to simplify the engine model for bucket 
speed operation [12], the components in use originate from the FLIGHTLAB® model.  
This is to ensure there is always a consistent and non-tampered input reading into the 

23 
 
engine model.  The input variables are calculated by FLIGHTLAB®, not the engine 
model.  The resultant engine model can be described as: 
 



f
w
b
k
Ax
k
x


1
 
( 26 ) 
 
The state vector in Equation (26) is: 
 


T
NP
NG
k
x

)
(
 
( 27 ) 
 
The control variable is fuel flow and the components of Equation (26) are defined as: 
 







4461
.0
3128
.0
0
233
.2
A
 
( 28 ) 


T
b
16630
149400

 
( 29 ) 
 
 
2.3. Coupling of Dynamic and Engine Models 
 
 
The dynamic model described in Section 2.1 and the engine model described in 
Section 2.2 are not coupled together in their current form.  It is known the engine model 
provides torque to the main rotor.  The main rotor speed is a part of the external forces 
and moments that contribute to the equations of motion.  The forces provide a resistance 
to the engine model which is accounted for with fuel flow as a control input.  For 

24 
 
coupling the dynamic model to the engine model, a mechanical linkage between the 
power turbine speed and main rotor speed is used. 
 













60
2
04
.
81
1

k
k
NP
 
( 30 ) 
 
The gearing ratio of the power turbine to the main rotor is 81.04:1.  Therefore, the 
dynamic model is partially a function of not only the main rotor speed, but also the power 
turbine speed, gas generator speed, and engine fuel flow. 
Another means of further coupling the dynamic helicopter model to the engine 
model is through the external moment in the z-direction, N, contained within the equation 
for roll rate and yaw rate.  The moment consists of two terms making up the torque 
provided to the rotor from the engine and two terms of the dynamic model acting against 
the motion of the main rotor.  Examining the terms of the engine providing torque to the 
main rotor, the first represents the aerodynamic torque applied to the rotor and contains a 
torque coefficient which can be used to couple the dynamic and engine models.  Kim [13] 
equates the torque coefficient (CQ) and pressure coefficient (CP) and defines them as: 
 
p
i
P
P
P
P
C
C
C
C



0
 
( 31 ) 
 
The pressure coefficient is the summation of the induced power coefficient, the profile 
power coefficient, and the parasite power coefficient.  All three coefficients are functions 
of the advance ratio which is a function of forward speed and main rotor speed.  The 

25 
 
induced power coefficient is also a function of the longitudinal shaft tilt in the wind axis.  
Therefore, the torque coefficient is a function of forward speed, main rotor speed, and 
pitch angle. 
 
The second term of the Z-moment is the pseudotorque the engine provides due to 
the changing speed of the main rotor.  The term contains a normalized rate of change of 
the main rotor speed.  The variable is a function of the rate of change of the main rotor 
speed which is mechanically linked to the rate of change of the power turbine speed.  
Therefore, the two terms of the external moment in the Z-direction are used to couple the 
rate of change of power turbine speed to both the roll rate and yaw rate of the aircraft. 
The parameter designation for the model matrices are matched with those in the 
Sioris paper [14]. 
 
w
u
x
x




B
A

 
( 32 ) 
 
where the state and control vectors are: 
 


T
NP
NG
r
q
p
w
v
u



x
 
( 33 ) 


T
f
sw
cw
w
1
1
0




u
 
( 34 ) 
 
 
 
 
 

26 
 
and the corresponding matrices are represented as: 
 




































































































































NP
P
N
NG
P
N
P
N
u
P
N
r
q
p
r
q
p
NP
r
NG
r
r
r
q
r
p
r
NP
q
r
q
q
q
p
q
NP
p
NG
p
r
p
q
p
p
p
NP
w
w
w
u
v
p
q
NP
v
v
v
u
w
p
r
NP
u
u
v
w
q
r
A
























































0
0
0
0
0
0
0
233
.2
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
 
( 35 ) 
 



























































































f
f
sw
cw
sw
cw
f
sw
cw
sw
cw
sw
cw
sw
cw
w
P
N
w
r
r
r
r
q
q
q
w
p
p
p
p
w
w
w
v
v
v
u
u
u
B





















0
0
0
149400
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
1
1
0
1
1
0
1
1
0
1
1
0
1
1
0


















 
( 36 ) 

27 
 
A derivation of the Jacobian terms described in the above equations is outlined in 
Appendix A.  As shown in the appendix, main rotor speed serves as a dependent variable 
for the external forces (X, Y, Z) and external moments (L, M, N).  Also note that 
following the coupling of the dynamic and engine model, the engine parameters act upon 
the translational and rotation velocity equations of motion.  The forward speed and pitch 
angle act upon the equation of motion for the power turbine speed. 
 
 
 
2.4. Bayes’ and Multiple Model Estimation 
 
 
The probability of an event in a simple system is usually straight forward.  The 
probability of rolling a 2 with a die, or the probability of a flipped coin landing on heads, 
or even the probability of guessing on a multiple-choice exam are examples with simple 
probabilities.  However, most systems in the real world do not depend on a single “flip of 
the coin” to function.  Whether it be a car backfiring due to a faulty spark plug, an 
incorrect fuel injection system, or an issue with fuel pumped at a gas station, or a bicycle 
chain malfunction due to incorrect tension, a faulty gear, or inadequate gear transfer 
system, multiple and independent parameters can cause the same malfunction.  A 
probability density represents the likeliness of an outcome to occur given certain input 
conditions.  Unlike a discrete random variable, the continuous random variables use the 
probability density function.  The objective of a Bayes’ estimation is to predict the 

28 
 
outcome of a continuous random variable given information of a separate random 
variable [14]. 
Two dependent variables can be evaluated against each other using a conditional 
mean.  The relationship between parameter xi and yj is represented as: 
 






j
j
i
j
i
y
y
x
y
x
Pr
,
Pr
Pr

 
( 37 ) 





i
j
i
i
j
x
y
x
x
y
Pr
,
Pr
Pr

 
( 38 ) 
 
Combining Equations (37) and (38), Bayes’ rule can be represented as: 
 







j
i
i
j
j
i
y
x
x
y
y
x
Pr
Pr
Pr
Pr

 
( 39 ) 
 
The probability of the system functioning in a specific state due to the 
observations of the system is a function of (a) the known observations during a desired 
state, (b) the probability of the system being in the desired state, and (c) the probability of 
observations.  The equation is effective for comparing two dependent variables.  
However, what if there are multiple variables that can affect the probability of the value 
of xi?  An example is the probability that a bicycle chain may break (xi) given the tension 
in the chain (y1).  The chain also has a probability to pop (xi) given a bent tooth on a gear 
(y2).  For this situation, Multiple-Model Estimation (MME) can be applied.  MME is a 

29 
 
generalized principle in which many values of system parameters could be run through 
their own linear optimal filters, and the state estimate with the highest probability would 
stand as the actual value of the parameter [15].  Each filter will be assigned a confidence 
value.  The sum of each result using a Bayes’ estimation weighed with the corresponding 
probability confidence results in an optimal estimate. 
The system also becomes a dynamic system that is continuously running for every 
simulation time step.  Therefore, the system parameters are based upon the density 
function containing measured data from instrumentation, referred to as the measurement 
vector, along with the system states which may also vary every time step.  The equation 
is represented as: 
 
















l
i
k
i
i
k
k
j
j
k
k
j
pr
pr
1
1
1
Pr
Pr
Pr
p
p
z
p
p
z
z
p
 
( 40 )  
 
The notation Pr( ) indicates a probability mass function while pr( ) is a probability 
density function.   
The issue is a case where there are a finite number of models to evaluate with 
only one model being correct.  Thus, the result is a discrete variable where Pr(pj) is the 
probability that pj is correct.  However, the measurement from the system can take on any 
value, making zk a continuous variable.  Therefore, pr(zk) is the probability density of the 
observation occurring. 

30 
 
In Equation (40), pj represents the event that the j-th model is correct while zk is 
the measurement vector of known parameters.  Therefore, knowing information about zk 
provides an estimate on model correctness variable pj.  In short, Equation (40) estimates 
the probability that the model is correct. 
The numerator of Equation (40), multiplies the probability that an observation 
vector would occur given a correct j-th model, 


j
k
pr
p
z
, and the probability of the 
accuracy of the model of the previous time step given the observation vector, 




1
1
Pr
Pr


k
j
k
j
z
p
p
. 
The denominator is simply the summation of all the numerators representing each 
model available in the system. The denominator is used as a normalizing function in 
order to represent each model probability, 


k
j z
p
Pr
, on a 0 to 1 scale.  However, the 
density function state is unknown at this instant, therefore, the state estimate must be 
generated by a Kalman filter represented below [15]. 
 


1
1
ˆ
ˆ








k
k
k
u
x
x
 
( 41 ) 


T
k
T
k
k










'
1
1
Q
P
P
 
( 42 ) 




1





k
T
k
T
k
k
R
H
HP
H
P
K
 
( 43 ) 











k
k
k
k
k
x
H
z
K
x
x
ˆ
ˆ
ˆ
 
( 44 ) 




1
1
1






H
R
H
P
P
k
T
k
k
 
( 45 ) 
 

31 
 
The Kalman filter is broken into 5 steps for each iteration; a state estimation 
extrapolation (propagation), a covariance estimate extrapolation (propagation), a filter 
gain calculation, a state estimate update and a covariance estimate update [15].  The (-) 
following a parameter is the estimate that results from the propagation while the (+) 
indicates the estimate following an update with measured data.  The state update, 


k
xˆ
, 
is the desired output for the MME while the covariance update, 


k
P
, tracks the 
uncertainty of the state estimation [16].  Equations (41-45) tracks the state estimate of the 
model in which it is associated. 
 
 
Figure 4: Bayes’ Hypothesis and Probability Flow Chart with permission from [15] 
 
The updated MME equations using Bayes’ Theorem can now be represented as: 
 

32 
 



















I
i
k
i
i
k
k
k
j
j
k
k
k
j
pr
pr
1
1
1
Pr
ˆ
Pr
ˆ
Pr
z
p
p
x
z
z
p
p
x
z
z
p
 
( 46 ) 
 
Where the state vector was represented as x, the optimal estimation for the state 
vector given the corresponding model is correct is represented as 


j
k p
xˆ
. The first term 
in the denominator may now pass through the Kalman filter to determine a propagated 
and updated estimate of the state.  Multiple Kalman filters may run simultaneously to 
evaluate multiple hypotheses against each other.  This scheme has been a proven method 
for determining the likelihood that the hypothesis is correct [17].  A Gaussian distribution 
is a function that indicates an observation to lie within a range of two real numbers.  The 
distribution contains of a residual function which is the difference between a measured 
observation and the state propagation.  A covariance matrix is also present which 
represents the error found in the updated state estimation [15].  The equation along with 
the residual and covariance matrices can be defined respectively. 
 
















i
k
i
k
i
T
k
e
pr
i
k
n
i
k
k
p
r
p
S
p
r
p
S
p
x
z
1
2
/
1
2
/
1
2
/
2
1
ˆ




 
( 47 ) 







i
k
k
i
k
p
x
H
z
p
r
ˆ
 
( 48 ) 


k
T
i
k
i
k
R
H
p
HP
p
S


 
( 49 ) 
 

33 
 
The optimal estimates for the state can now be found from the Kalman filters.  
Depending upon the system in which the MME Bayes’ Theorem is applied will 
determine the coefficients for the observation and state equations. 
Once the hypotheses are calculated and the probabilities from Equation (40) are 
determined, they can be plotted and evaluated to determine an appropriate moment that 
an engine failure has most likely occurred.  For situations with three or more hypothesis 
models, an appropriate means of detecting a failure is to pinpoint the moment the 
“normal function” hypothesis is no longer the more probable hypothesis to occur.  Figure 
5 shows the comparison of three hypotheses along with the recognition point of a model 
surpassing the “normal” hypothesis. 
 
 
Figure 5: Failure Event Detection Scheme 
 
Figure 5 shows and evaluation of three hypothesis models in a hypothetical 
situation.  The solid blue line represents a model functioning with no disturbance or error.  
The dashed red line and the dot-dashed black line represent a model with a built in 
discrepancy.  Therefore, in normal activity, the probability of these models being an 
appropriate representation of the system is near zero.  The orange vertical line is the 

34 
 
moment in time when the system goes from normal activity to broken.  The green and 
dashed vertical line pinpoints the moment the normal model is no longer the most 
probable model to represent the system.  This is the scheme that is to be associated with 
the work in future sections. 
 
 
2.5. FLIGHTLAB® and VirtualPilot 
 
 
The software used by the US Army to run simulations is FLIGHTLAB® 
produced by Advanced Rotorcraft Technology, Inc. out of Sunnyvale, CA.  
FLIGHTLAB® allows a user to input the physical properties of a particular rotorcraft 
system, design control and propulsion algorithms for parameter calculations for each 
simulation time step, set initial flight conditions along with aircraft configurations, trim a 
model and run a multi-step simulation while outputting variable values in each step.  The 
software allows a user to control how the model is to be run.  FLIGHTLAB® can be run 
at real-time through a helicopter simulator or non-real-time from a desktop. 
The US Army has developed a VirtualPilot (VP) program which can be used to 
simulate a pilot-in-the-loop when running FLIGHTLAB® scripts.  The virtual pilot has 
three basic functions; using pilot actions as a prescribed maneuver, a flight-test response, 
or a flight-test stick input.  The VP controller is shown schematically in Figure 6 and 
Figure 7.  The VP only controls the four stick inputs that a pilot can control, being 
longitudinal cyclic, lateral cyclic, collective and pedal inputs.  The aircraft performance 
capability cannot be better than the pilot’s ability to adjust with the aircraft reactions 

35 
 
through an autorotation [18].  That is, the pilot model must have some adaptability when 
autorotation conditions are not optimal. 
 
 
Figure 6: VirtualPilot Prescribed Maneuver Structure 
 
The prescribed maneuver method shown in the schematic above includes a user 
input to perform a maneuver.  The user tells the VP (a) which maneuver is to be 
performed whether it be forward speed control, a turn rate, heading control, etc., (b) the 
targets that a pilot would try to achieve such as a final forward speed or heading and (c) 
how aggressively to make the maneuver through gain adjustments within the VP.  The 
commands are then fed into the command model to determine the commanded responses 
such as pitch, roll and yaw angle.  Once the commanded responses are calculated, the 
stick positions to achieve the commanded responses are determined and fed into the flight 
dynamics model.  FLIGHTLAB® takes control of the flight dynamics with its own solver 
functions.  From that model, the aircraft state vector is determined. 
 

36 
 
 
Figure 7: VirtualPilot Flight Test Data Maneuver 
 
The final two uses for the VP as shown in the above schematic uses flight-test 
data as an input.  For the flight-test response, the VP takes in position such as pitch, roll 
or yaw angle.  Through the control system a stick position to achieve the state is 
calculated and commanded. The change in stick position is then fed into the flight 
dynamics model and a state vector is created.  The last use for the VP is to simply input 
the change in stick position and feed the result into the flight dynamics model.  
The VirtualPilot (VP) is broken into two user entries.  The first is the commands 
to be run.  For the longitudinal control in the cyclic, lateral control in the cyclic, 
collective control in the collective and directional control in the pedals, the user pre-
defines the command type to be implemented.  The second is the state targets which are 
used by the commands. 
The command for the longitudinal cyclic is the indicated airspeed (IAS) control 
mode.  The input is the forward indicated airspeed of the aircraft.  This was selected as 
the primary option to allow the pilot to maintain the initial forward speed to keep the 

37 
 
landing zone area as wide as possible.  VP modes not selected for the longitudinal cyclic 
were pitch attitude control and forward speed control.  The pitch attitude control was not 
used because a generic scout-class aircraft will vary forward pitch to command a forward 
speed with other generic utility-class vehicles, requiring the user to have extensive 
knowledge in the sensitivity and rigging of the aircraft in question.  The IAS control 
mode calculates the pitch angle to be commanded and runs it through the model.  The 
forward-speed control mode is designated for low-speed to hover applications and is 
therefore not used.  The forward-speed control mode gains are selected as such where 
axial speed of the aircraft may not be the dominant speed component. 
The command for the lateral cyclic has been selected down to two alternatives to 
be tested.  The first is a roll attitude control mode.  This angle can be adjusted as 
necessary to account for the generic model or simply remain in the trimmed roll angle to 
continue with straight and level flight.  The other command mode which can be applied is 
a high-speed heading control mode.  The mode essentially calculates a roll angle which 
can be dynamically achieved by the generic aircraft and turns until the heading is 
achieved.  A possible down fall with this command is the turn may be taken more 
aggressively which will vary due to different forward speeds.   
The commands in the collective and directional components will remain the same 
no matter the cyclic commands the user chooses.  For the collective command, an altitude 
hold mode is to be selected until the VP recognizes and responds to an engine failure.  At 
this point, the control mode will change to a main rotor speed control mode with an input 
target of 100% rotor speed.  The directional component will remain in the zero-sideslip 
control mode.  The input target will be a -angle of zero degrees.  Options not selected 

38 
 
are heading control modes and yaw rate control modes.  The modes were not selected 
because the optimal descent path should include zero sideslip. 
 
 
 

39 
 
 
 
 
 
 
3. Bayes’ Analysis of Rotorcraft Failure Models 
 
 
This chapter examines the UH-60 model hypothesis algorithms to test and analyze 
the theory from the previous chapter.  In the sections to come, there will be the 
description of a reference model which has been calibrated to respond similarly to a U.S. 
Army model correlated with flight test data, and the description and calibration of the 10-
State “normal” functioning model, the driveshaft failure model, and the engine failure 
model.  The calibration will include steady flight and steady flight with speed and data 
discrepancies.  The Bayes’ analysis equations from the previous chapter will be expanded 
to represent a full analysis.  Finally, the analysis will be run, data analyzed, and results 
discussed. 
 
 
3.1. FLIGHTLAB® Reference Model 
 
 
The Reference Model is a version of a UH-60M dynamic helicopter model 
created by the U.S. Army.  The role of the model is to demonstrate flight performance 
(how well the rotorcraft flies) and handling qualities (how well the rotorcraft responds to 
a pilot input).  The original model has gone through rigorous verification and validation 
testing against U.S. Army acquired flight test data. 

40 
 
The model used for this dissertation is an iteration of the U.S. Army model.  The 
gross weights, moments and products of inertia, center of gravity positions, main rotor 
airfoil shape, and tail rotor characteristics have been altered, making the model no longer 
verified and validated, but approved for public release.  Regression testing has been 
completed on the reference model by comparing it to the model used by the U.S. Army, 
and the author feels the results are satisfactory for continuing. 
The Reference model was created using ART, Inc. software FLIGHTLAB® v3.5 
within the XAnalysis tool.  The model has privately designed atmosphere, airframe, main 
rotor, tail rotor, propulsion, flight control, and VirtualPilot sub functions being executed 
with each simulated time step.  The engine model is external to the primary model.  The 
model is a form of a load sharing model, in that the power used from each engine may 
vary.  The engines are not mirrored to provide the correct power response.  Finally, the 
model will be used to create a database to run the Bayes’ Estimation as an external 
function.  The code for the external function is provided in Appendix B and C.  The 
model is not to be influenced by outside functions. 
 
 
3.2. Model Configuration for Testing 
 
 
For running all test cases, the same model configuration for the FIGHTLAB® 
reference model and external dynamic model will be applied.  The configuration 
parameters can be found in Table 1.  The parameters are similar to that of a real 
configuration of a UH-60 model, with changes applied to allow for the report to be 

41 
 
considered for public release.  The rotors applied to the model are NACA 0012 for the 
entire span of the rotor blade.  The reference for 100% main rotor speed is 27.0 rad/sec.  
The reference for 100% tail rotor speed is 124.5 rad/sec.  For steady flight, these values 
represent the rotor speed targets. 
The pressure altitude allows the model to maintain the pressure and density on the 
aircraft for any simulated altitude.  This negates the effect of changing pressure and 
density of the airflow across the body and through the rotor disk as the altitude changes 
during simulation.  The ambient temperature will also remain constant at all altitudes.  
The model will also negate fuel burn across the simulation duration.  Therefore, the 
weight, center of gravity, and moments/products of inertia will remain constant. 
 
 
3.3. Model Verification 
 
 
The sections to come will be used to compare the engine model, the 8-state 
dynamic model coupled with the engine model, the driveshaft failure model, and the fuel 
flow failure model.  The initial data compared is a U.S. Army reference model which has 
been modified to ensure there is no classified material presented.  The verification of 
these models will use the reference model data, propagate two seconds using the 
equations of motion, and compared to the model.  The verification will also include 
analysis of the model responses to biases presented in the data along with perturbations in 
the physical environment.  Bayesian plots will be provided to show the sensitivity of the 

42 
 
models to the added biases, however, the full Bayes’ evaluation will occur in the coming 
sections of this chapter. 
 
3.3.1. Verification of Engine Model 
 
 
Verification of the engine model is conducted to ensure the outputs of gas 
generator speed and power turbine speed respond appropriately with normal flight.  The 
engine model has never undergone an official verification and validation; therefore, no 
reference model is available.  However, inspection of the engine model parameters will 
determine the appropriateness of the current model for the work performed in this paper. 
The verification will compare the steady flight of the aircraft among the varying 
forward speeds of 60, 80, and 100 kts indicated airspeed.  The parameters evaluated are 
the engine fuel flow as the control variable, and the gas generator and power turbine 
speeds.   
 

43 
 
 
Figure 8: Engine Parameter Input and Output for 60kt Level Flight 
 
Generator Speed 
Turbine Speed 

44 
 
 
Figure 9: Engine Parameter Input and Output for 80kt Level Flight 
Generator Speed 
Turbine Speed 

45 
 
 
Figure 10: Engine Parameter Input and Output for 100kt Level Flight 
 
The plots show that the gas generator speed and power turbine speed remain at an 
approximate value of 90% and 100% respectively no matter the airspeed.  The fuel flow 
rate is specific for the airspeed as it is used drive the rotor and maintain a 100% rotor 
speed at any forward airspeed.  The fuel flow will be the control when engine failure is 
tested.  The plots indicate that the engine model used with FLIGHTLAB® input is a 
stable model. 
Generator Speed 
Turbine Speed 

46 
 
 
3.3.2. The Coupled Dynamic and Engine Model 
 
 
Comparison of the coupled dynamic and engine model to the FLIGHTLAB® 
reference model is used to ensure the dynamic model behaves similarly in steady flight 
prior to examining the model upon engine failure.  The coupled model is a 10-state model 
consisting of body velocities, body angular velocities, pitch and roll angles, gas generator 
speed, and power turbine speed.  The gearing ratio between the power turbine and main 
rotor couples the engine states to the dynamic model through the rotor speed. 
Note the reference model has not undergone an official verification and validation 
with flight test data due to the changes made for proprietary reasons.  However, the 
reference model has undergone regression testing with a verified and validated model.  
The regression testing demonstrated the expected changes in the reference model due to 
the changes referenced in Section 2.2.  The reference model is considered appropriate for 
the exercises performed in this paper. 
At each time step, the reference FLIGHTLAB® model data is used as the initial 
input into the 10-state dynamic and engine model.  Using the 10-state model, the dynamic 
model is projected 2 seconds forward to determine how the model views the states.  This 
should indicate stability in the system or instability.  The verification will compare the 
steady flight of the aircraft among the varying forward speeds of 60, 80, and 100 kts 
indicated airspeed.  The verification will also include left and right banked turns at 80 kts.  
The turns are to be completed with minimal sideslip.  The performance parameters 
evaluated are the vehicle velocities in the body x, y, and z-direction, the roll, pitch, and 

47 
 
yaw rates, and the roll and pitch angles.  The verified parameters are of interest upon an 
engine failure, therefore it is essential that they respond like the reference model.  
Because the model is verified, there is a greater chance that the introduction of error in 
the form of an engine failure will respond similarly.  Along with the aircraft performance, 
the swashplate longitudinal cyclic, lateral cyclic, and collective pitch angles are 
outputted.  There is not a verified and validated engine model to compare with the 
dynamic engine model.  Ballin [12] does provide comparison plots in the appendices to 
validate the simplified engine model. 

48 
 
 
Figure 11: Body Velocities for 60kt Level Flight 
Reference Model 
Dynamic Model 

49 
 
 
Figure 12: Body Angular Rates for 60kt Level Flight 
Reference Model 
Dynamic Model 

50 
 
 
Figure 13: Orientation and Control Inputs for 60kt Level Flight 
Reference Model 
Dynamic Model 
Collective Pitch 
Long. Pitch 
Lat. Pitch 

51 
 
 
Figure 14: Body Velocities for 80kt Level Flight 
Reference Model 
Dynamic Model 

52 
 
 
Figure 15: Body Angular Rates for 80kt Level Flight 
Reference Model 
Dynamic Model 

53 
 
 
Figure 16: Orientation and Control Inputs for 80kt Level Flight 
Reference Model 
Dynamic Model 
Collective Pitch 
Long. Pitch 
Lat. Pitch 

54 
 
 
Figure 17: Body Velocities for 100kt Level Flight 
Reference Model 
Dynamic Model 

55 
 
 
Figure 18: Body Angular Rates for 100kt Level Flight 
Reference Model 
Dynamic Model 

56 
 
 
Figure 19: Orientation and Control Inputs for 100kt Level Flight 
Reference Model 
Dynamic Model 
Collective Pitch 
Long. Pitch 
Lat. Pitch 

57 
 
 
Figure 20: Body Velocities for 80kt Left Bank 
Reference Model 
Dynamic Model 

58 
 
 
Figure 21: Body Angular Rates for 80kt Left Bank 
Reference Model 
Dynamic Model 

59 
 
 
Figure 22: Orientation and Control Inputs for 80kt Left Bank 
Reference Model 
Dynamic Model 
Collective Pitch 
Long. Pitch 
Lat. Pitch 

60 
 
 
Figure 23: Body Velocities for 80kt Right Bank 
Reference Model 
Dynamic Model 

61 
 
 
Figure 24: Body Angular Rates for 80kt Right Bank 
Reference Model 
Dynamic Model 

62 
 
 
Figure 25: Orientation and Control Inputs for 80kt Right Bank 
Reference Model 
Dynamic Model 
Collective Pitch 
Long. Pitch 
Lat. Pitch 

63 
 
The plots demonstrate a comparison between the reference model and the 
dynamic model.  The information from the reference model was used to project 2 seconds 
into the future and determine a value of the state examined.  The model does struggle 
with the roll component as there is typically a 2-3 degree margin of error left or right, 
creating a noisy result. 
The three indicated airspeeds examined all have a steady-state response for the 
10-state vector.  It should be noted for testing purposes, there is initial error in the 
reference model due to numerical discrepancies between the VirtualPilot and 
FLIGHTLAB® model.  Therefore, all cases should use a 50-second runoff period to 
settle the model and eliminate discrepancies.  Error may now be added to the system to 
evaluate the sensitivity of the model with biases and perturbations. 
 
 
3.4. Coupled Driveshaft Failure Model 
 
 
A driveshaft failure occurs when the output torque applied by the engine provides 
zero torque to the main rotor system.  The driveshaft pushes a sprag clutch as shown in 
Figure 26.  When the driveshaft is powered, the spokes in the clutch drive the main rotor 
systems.  When the main rotor is turning at a greater speed than the driveshaft at the point 
of the sprag clutch, the spokes simply slip, providing no torque to the rotor. 

64 
 
 
Figure 26: Sprag Clutch Components and Function 
Reprinted with permission from Bert Vogel Account on Teacher Webspace, 2017, Retrieved 
from http://hrsbstaff.ednet.ns.ca/bvogel/K100/download/Starter_clutch/ 
 
Modelling of the driveshaft failure uses the concept of the sprag clutch in order to 
disengage the driveshaft from the main rotor.  The engine model piece of the coupled 
dynamic model, described in Equation (26) through Equation (28), describes the forces of 
the rotorcraft on to the engine in the state matrix and the forces of the engine on to the 
rotorcraft in the control matrix.  To simulate the drivetrain failure, the diagonal of the state 
matrix (engine component) will be set to zero, causing the engine model to spin up with no 
anti-torque being applied from the rotor system to the engine.  This is shown below in 
Equation (50).  Only the engine components of the state matrix is set to zero since the other 
states will continue to be driven.  The control matrix in the engine component continues to 
add fuel to the system as if there is no error. 
 
 

65 
 



























0
0
0
0
0
0
NG
P
N
u
P
N
NP
u
A
Fail
Drivetrain

















 
( 50 ) 
 
 
3.5. Coupled Fuel Flow Failure Model 
 
 
A fuel flow failure occurs when the engine ceases to provide torque to the 
driveshaft and the main rotor.  When the engine does not provide the necessary torque to 
the main rotor, the sprag clutch becomes disengaged and the main rotor turns freely.  The 
drag on the rotor blade will impede the rotor at a slower rate than the reduction in engine 
speed. 
Modelling of the fuel flow failure calls upon removing the fuel flow from the 
engine component of the control.  This is shown below in Equation (51).  Every time step 
evaluated, the fuel flow to the engine component of the controller is set to zero, 
indicating that there is no assistance from the engine to the rotor system. 
 

























0
0
0
0
0
0
0
0
0
1
1
0











sw
cw
FuelFail
u
u
u
B



 
( 51 ) 

66 
 
3.5.1. Bias and Turbulence in Coupled Dynamic Model 
 
 
A necessary procedure to conduct prior to examining the test matrix outlined in 
the coming sections is to run a sensitivity analysis on the model along with the Bayesian 
output.  The procedure is run with the intention to prevent misleading results due to slight 
numerical biases within a simulation or the detection of false positives due to wind gusts 
or physical disturbances. 
The variables analyzed will be the translational rates of the aircraft (u, v, w) from 
steady level flight.  This will be applied in two separate manners.  The first will be an 
additional bias added towards a steady state system.  Once the system begins to calculate 
an approximation and multi-model estimate of a failure probability, a negative 5 knot bias 
to u, a positive 3 knot bias to v, and a positive 10 knot bias to w will be applied 
simultaneously.  This will cause a small system error between the speed and the control 
inputs to the swashplate model.  The second will be a simulated change within the 
FLIGHTLAB® environment.  This is to ensure the model does not sense an engine 
failure if the VirtualPilot opts to change its trimmed flight conditions to account for an 
impulse input from the steady state. 
Figure 27 and Figure 28 demonstrate the two methods used to test the model 
sensitivities and how they relate to a Bayes’ Theorem result.  The tests were all run at 80 
kts trimmed speed.  Sensitivity analysis at 60 kts and 100 kts demonstrate similar trends 
and results. 
 

67 
 
 
Figure 27: Applied Numerical Bias to Body Axis Velocities 
Reference Model 
Dynamic Model 

68 
 
 
Figure 28: Bayesian Response to Body Velocity Biases 
 
When a bias is added to either the forward, lateral, or vertical airspeed, indicating 
a reading error in a sensor, the Bayesian estimation did not show a noticeable change in 
probability of a normal, stable flight.  A numerical bias to the instrumentation as an 
observation into the three hypothesis models does not cause the system to register false 
positive readings of engine or drivetrain failure. 
The next set of plots represent a perturbation in the system.  This is to simulate 
hitting a wind pocket or some type of density change.  The perturbation is simulated 
through the VirtualPilot response in stick position to be used in the reference model.  
Figure 29 through Figure 31 apply a disturbance to the longitudinal, lateral, and collective 
axes, track the swashplate model positions, and follow the Bayesian estimation for each 
axes to examine the effects of the disturbance. 
 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 

69 
 
 
Figure 29: Model and Bayesian Response to a Longitudinal Disturbance 
 
Collective Pitch 
Long. Pitch 
Lat. Pitch 
Dynamic Model 
Coupled Model 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 

70 
 
 
Figure 30: Model and Bayesian Response to a Lateral Disturbance 
 
Collective Pitch 
Long. Pitch 
Lat. Pitch 
Dynamic Model 
Coupled Model 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 

71 
 
 
Figure 31: Model and Bayesian Response to a Collective Disturbance 
Collective Pitch 
Long. Pitch 
Lat. Pitch 
Dynamic Model 
Coupled Model 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 

72 
 
The figures demonstrate the sensitivity, yet quick recovery of the dynamic model 
in the Bayes’ analysis of the system health.  The longitudinal and lateral disturbances did 
not register a change in the status of the normal model probability.  The collective 
disturbance responded to the input, however, the change in the normal or failure models 
was not significant enough to detect a concern.  In all cases with a numerical bias or 
disturbance in all axes, there were no significant responses to detect a failure. 
 
 
3.6. Engine Failure with Non-Recovery 
 
 
The engine failure analysis has two primary inputs for failure; the dynamic model 
failure which is triggered by a disengagement of the sprag-clutch driving the main rotor 
and the engine model failure which is triggered by a quick reduction in fuel flow.  The 
section will evaluate the effects of an engine failure using both methods on the 
rotorcraft’s dynamic states, compressor and turbine speeds, and main rotor speed along 
with evaluating the effects on the Bayes’ analysis for detecting the failure.  No pilot 
recovery actions are taken.  The VirtualPilot model will maintain its forward speed, 
heading, and altitude as determined prior to the engine failure. 
 
 
3.6.1. Instantaneous Engine Disconnect 
 
 
In the case of a complete disconnect between the engine and main rotor, the fuel 
flow is instantaneously cut from the system.  This is to simulate a failure between the 

73 
 
power turbine and the main rotor, such as a sheared driveshaft.  Figure 32 represents the 
fuel flow effects as pertaining to the main rotor.  The sprag-clutch is disengaged, 
allowing the main rotor to act with no assistance from the engine. 
 
 
Figure 32: Main Rotor Fuel Flow for Instantaneous Failure 
 
The next set of figures show the pilot input in order to maintain airspeed, heading, 
and altitude following the engine failure.  Those inputs demonstrating a lack of response 
by a pilot to enter and autorotation are extrapolated into the dynamic response in body 
speeds, orientation, angular rates, and rotor speed, along with the gas generator and 
power turbine speeds.   
 

74 
 
 
Figure 33: Model Control Inputs to Maintain Steady-State Flight 
 
From the swashplate inputs above, the model will output other parameters for a 
flight with an engine failure and no pilot response.  The plots are an example of how 
quickly an aircraft can become unstable along with the importance of pilot intervention at 
its earliest time step. 
 
Collective Pitch 
Long. Pitch 
Lat. Pitch 

75 
 
 
Figure 34: Angular Response to Instantaneous Failure 
Body X Vel. 
Body Y Vel. 
Body Z Vel. 
Roll Angle 
Pitch Angle 
Roll Rate 
Pitch Rate 
Yaw Rate 

76 
 
 
 
Figure 35: Rotor Speed for Instantaneous Failure 
 
 
Figure 36: Generator and Turbine Speed for Instantaneous Failure 
 
Note from Figure 34 the Euler angle along with the angular rates.  A severe pitch 
angle followed by a tremendous roll angle have rendered the aircraft completely unstable.  
Generator Speed 
Turbine Speed 

77 
 
The next figure portrays the quick degradation of rotor speed.  Without the pilot’s 
recognition and reaction, the rotor speed drops below 70% within approximately 5 
seconds.  Once below the 70% threshold, the time and altitude loss to regain enough rotor 
speed to land the aircraft becomes critical. 
 
 
3.6.2. Engine Component Wind-Down 
 
 
For a basic model of a T701 turboshaft engine, the fuel cutoff shows a similar 
shape to Figure 37.  The two lines of interest in the figure are the “Turbine Speed Fuel Cut 
Off”, highlighted with an orange arrow, and the “Turbine Speed Fuel Ramp Down”, 
highlighted with a green arrow.  The fuel to the turbine ramps down over a 4 second 
period.  The dynamic model in FLIGHTLAB® will be programmed to do the same.  As a 
result, the turbine speed slows over a 15-second period. 
 

78 
 
 
Figure 37: Engine Parameters for a Wind-Down Failure 
 
Figure 38 shows the FLIGHTLAB® programmed fuel flow cut-off to simulate an 
engine failure.  Similar to the previous figure, the fuel flow tapers to zero over a 4 second 
span.  Figure 41 shows the gas generator and power turbine speed responses.  As 
previously projected, the turbine speed slows at a comparable rate over a 15-second 
period. 
 

79 
 
 
Figure 38: Engine Fuel Flow for Wind-Down Failure 
 
The figure demonstrates the fuel flow of the rotorcraft as the throttle is reduced 
over a 4-second period.  The model consists of two turboshaft engines using a 
loadsharing algorithm to ensure the proper torque is being sent to the driveshaft.  The 
small bounces in the fuel flow curve are due to the two models arguing with each other 
on load distribution.  However, over a 4-second time period, there is not a concern with 
the model performance.  Figure 41 portrays the resultant gas generator and power turbine 
speeds based from the fuel flow in Figure 38.  Similar to Figure 37, the power turbine 
speed powers down over a drawn-out 15-20 second duration.  The model parameters to 
be used for a simplified Bayes’ analysis for an engine appears to be appropriate. 
 

80 
 
 
Figure 39: Angular Response for Wind-Down Failure 
Body X Vel. 
Body Y Vel. 
Body Z Vel. 
Roll Rate 
Pitch Rate 
Yaw Rate 
Roll Angle 
Pitch Angle 

81 
 
 
Figure 40: Main Rotor Speed for Wind-Down Failure 
 
 
Figure 41: Generator and Turbine speeds for Wind-Down Failure 
 
The wind-down model response to an engine failure with zero pilot response is like 
that of the instantaneous engine failure.  There is about a second slower response, as seen 
in the main rotor speed in Figure 40.  However, the rate of rotor speed decay appears to be 
Gas Generator 
Power Turbine 

82 
 
similar.  Dynamically, the model speeds and orientation respond in similar fashion to that 
of the Instantaneous engine failure.  
 
 
3.7. Bayes’ Analysis and Results 
 
 
Figure 42 outlines the intention of the model to seek a predictive value of a 
performance or engine parameter.  In the figure, the blue line represents the simulation 
data, which is run to completion.  At each time step, a Kalman filter is applied to run the 
model a specified time forward.  That value is used in the calculation for determining if 
the model is degrading due to an engine failure.  Each time step is evaluated. 
 
 
Figure 42: Kalman Filter Estimation 
 

83 
 
The methodology used in Section 1.4, Bayes’ and multiple-model estimation, can 
be used to determine the probability of either a healthy flight or one involving an engine 
failure.  As described in the section, Kalman filter components may be used to determine 
the probability of the observation vector given an updated model state vector.  Equation 
(52) is the form the dynamic model must take to be applied in the Kalman filter [19]. 
 
w
u
x
x




B
A

 
( 52 ) 
 
The derivation of the state matrix and control matrix is shown in Appendix A.  
The control vector consists of four input variables; collective pitch angle, longitudinal 
cyclic swashplate angle, lateral cyclic swashplate angle, and fuel flow rate.  Figure 43, 
from [20], better demonstrates the location of the swashplate angle measurements.  In an 
ideal situation, the control would trace back to the collective and cyclic stick inputs by 
the pilot.  However, due to the non-consistent and proprietary flight control laws from 
varying helicopter platforms, along with the intense calculations between involving 
actuator position and dynamics and mixer dynamics, proceeding to the pilot stick inputs 
would distract from the scope of this paper. 
 

84 
 
 
Figure 43: Swashplate Control Inputs 
 
The following equation shows the observation matrix used in the normal model 
and two failure models.  The variables observed are the forward speed, descent rate, roll 
and pitch angles, gas generator speed, and power turbine speed. 
 


T
NP
NG
w
u



z
 
 

85 
 
  Once again, the Equations (53-54) are used to compare the health of the dynamic 
aircraft model and the T701D engine model. 
 



















l
i
k
i
i
k
k
k
j
j
k
k
k
j
pr
pr
1
1
1
Pr
ˆ
Pr
ˆ
Pr
z
p
p
x
z
z
p
p
x
z
z
p
 
( 53 ) 
















i
k
i
k
i
T
k
e
pr
i
k
n
i
k
k
p
r
p
S
p
r
p
S
p
x
z
1
2
/
1
2
/
1
2
/
2
1
ˆ




 
( 54 ) 
 
For the application of these equations, I is the number of hypothesis models.  For 
the cases in question, the normal flight hypothesis model and two failure models are 
evaluated.  The variable j is a single probability model and is defined as 
I
j 

1
.  The 
summation block upper limit, l, is the number of hypothesis models to be evaluated and 
compared to other models.  All of the hypothesis models are 10-state models; the (3x1) 
linear velocity vector, the (3x1) angular velocity vector, the (2x1) angular position vector, 
and the (2x1) engine model.  The above equation may be re-written as: 
 















C
B
A
e
k
j
j
k
k
j
j
k
j
k
j
T
k






1
2
1
2
1
2
1
Pr
2
1
|
Pr
1
p
p
S
z
p
p
r
p
S
p
r

 
( 55 ) 
 
 
 
 

86 
 
where 
 








































1
2
1
2
1
2
1
1
2
1
2
1
2
1
1
2
1
2
1
2
1
Pr
2
1
Pr
2
1
Pr
2
1
1
1
1












k
eng
eng
k
k
DriveShaft
DriveShaft
k
k
norm
norm
k
eng
k
eng
k
eng
T
k
DriveShaft
k
DriveShaft
k
DriveShaft
T
k
norm
k
norm
k
norm
T
k
e
C
e
B
e
A
p
p
S
p
p
S
p
p
S
p
r
p
S
p
r
p
r
p
S
p
r
p
r
p
S
p
r



 
( 56 ) 
 
The resultant value is the probability of one of the three hypothesis being most 
correct at the given time step of k.  The above equation may also be represented by Figure 
44, modified from the original version provided in Figure 4. 
 
 
Figure 44: Hypothesis Model Flow Chart for 3-Model System 
 
The figure shows the hypothesis models as either a normal model in which the 
system is healthy, or one of the two failure models where the driveshaft or engine has 
failed.  The probability of each hypothesis model calculated from Equation (55) is 
evaluated to determine the hypothesis model that is most likely to be correct. 

87 
 
The calculation from Equations (55-56) can present many obstacles for 
determining the probability of an engine failure.  The primary source of concern resides 
in the determinant of Sk, due to the size of Sk.  If the model is tuned improperly, the main 
diagonal of Sk is liable to have some barely non-zero numbers.  The first three fields in 
the state matrix are in knots.  The next five are either radians per second or radians.  The 
final two are in revolutions per minute. 
The development of the three hypothesis models allow a user to choose the 
hypotheses models that is most likely to be correct and determine the probability that an 
event occurred given very little live flight test data. 
 
 
3.7.1. Bayes’ Model Selection and Threshold 
 
 
As referenced in Chapter 2, three models are evaluated simultaneously using 
Bayes’ theorem.  The criteria for detecting a probable engine or driveshaft failure for a 
rotorcraft occurs when the normal function model no longer has the greatest probability 
of being the correct model.  This state occurs when the driveshaft failure model which 
indicates the engine is functioning but the main rotor is not being driven, or the engine 
failure model which indicates the engine is no longer providing torque to the rotorcraft 
system has a greater probability of being correct. 
The first case examined is the instantaneous model failure.  This failure indicates 
a driveshaft failure where the engine and main rotor system are immediately severed 
from each other.  The models were evaluated at 60 kts, 80 kts, and 100 kts of forward 

88 
 
speed.  Figure 45 through Figure 47 show the results of the three cases.  The vertical green 
line indicates the instant the failure occurs.  This is the instant from which the pilot 
reaction time is measured.  The vertical orange line is the moment normal model is less 
probable to be correct than either failure models.  This is the detection point.  The 
horizontal green line is the probability of the of the normal model at the detection point. 
 
 
Figure 45: Failure Recognition for 60 kts Instantaneous 
 
 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 

89 
 
 
Figure 46: Failure Recognition for 80 kts Instantaneous 
 
 
 
Figure 47: Failure Recognition for 100 kts Instantaneous 
 
The three models quickly show a detection point using Bayes’ theorem.  In all 
three models, the detection came in less than 1 second of a driveshaft failure and the 
probability of the normal model being correct degraded quickly.  Figure 48 shows the 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 

90 
 
degradation of the model compared to the time since failure occurred.  Note the 
probability is decreasing on the x-axis with time as the y-axis variable.  In all three 
speeds tested, the failure was detected when the normal model probability degraded to 
approximately 35-40%, as shown by the shaded area.  For all speeds, failures were 
detected in less than 0.6 seconds. 
 
 
Figure 48: Degradation of Normal Probability for Instantaneous Failure 
 
The second case examined is the engine wind-down model failure.  The failure 
incites an engine failure where the fuel flow to the engine is immediately removed from 
the system.  However, the engine does not separate from the main rotor system 
instantaneously.  The remaining fuel is burned and the inertia within the engine slows the 
reduction in torque to the main rotor.  Similarly, the models were evaluated at 60 kts, 80 
kts, and 100 kts of forward speed.  Figure 49 through Figure 51 show the results of the 
three cases. 
 
60 kts Fwd. Spd. 
80 kts Fwd. Spd. 
100 kts Fwd Spd. 

91 
 
 
Figure 49: Failure Recognition for 60 kts Wind-Down 
 
 
 
Figure 50: Failure Recognition for 80 kts Wind-Down 
 
 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 

92 
 
 
Figure 51: Failure Recognition for 100 kts Wind-Down 
 
Similar to the instantaneous failure, the three models show a detection point using 
Bayes’ theorem.  In all three models, the detection came in less than 1 second of an 
engine failure and the probability of the normal model being correct degraded quickly.  
Figure 52 shows the degradation of the model compared to the time since failure occurred.  
In all three speeds tested, the failure was detected when the normal model probability 
degraded to approximately 35-40%, as shown by the shaded area.  For all speeds, failures 
were detected in less than 0.8 seconds. 
 
 
Normal Flight 
Drivetrain Fail 
Fuel Flow Fail 

93 
 
 
Figure 52: Degradation of Normal Probability for Wind-Down Failure 
 
The detection of a system failure, whether it be a driveshaft or engine failure, has 
been found to be detected within 0.8 seconds of the event.  Using the Bayes’ estimation 
for the three hypothesis models, the normal model probability degrades to 35-40% of 
being the correct hypothesis.  It is this moment that other failure models are more likely 
to be correct.  The initial pilot response to an autorotation is two seconds if detected. 
 
 
3.7.2. Main Rotor Recovery Response 
 
 
The model response was evaluated at 60kts, 80kts, and 100kts.  Remembering the 
purpose is to maneuver the aircraft into a steady state autorotation as quickly as possible, 
the pilot is responsible for maintaining control of the roll, pitch, and yaw attitude along 
with recovering the rotor speed.  The rotor speed will be used to glide, maneuver to a 
landing spot, flare, and cushion to the ground.  Although the pilot will lower the 
60 kts Fwd. Spd. 
80 kts Fwd. Spd. 
100 kts Fwd Spd. 

94 
 
collective stick to zero, the position will not remain constant in order to avoid 
overspeeding the rotor and unnecessarily increasing the descent rate of the aircraft.  
Therefore, the speed that that pilot can achieve a desired and trimmed rotor speed is 
essential.  The pilot cannot be distracted fighting to find a constant rotor speed while 
autorotating. 
For the acquisition of a steady-state rotor speed, the threshold for error is 
appoximated to 3%.  At 3%, there is not a need for the pilot to focus on the energy stored 
in the rotor.  Figure 53 analyzes the rotor speeds for three different pilot delays for a 
driveshaft failure simulation.  The delays are classified as the time of first detection as 
estimated by the Bayes’ analysis, a standard 2-second delay for pilots in training, and a 3-
second delay found as the approximate time for the rotor speed to droop to 80%. 
The instant the rotor speed oscillation enters the 3% threshold and remains in a 
steady descent is marked for the Bayes’ estimation and the 3-second delay.  The time of 
entry is recorded and using the steady-state descent rate for each forward speed, the 
difference in lost altitude is calculated.  For the driveshaft failure, these values are found 
in Table 4. 
 

95 
 
 
Figure 53: Rotor Speed Recovery with Instantaneous Failure 
Bayes’ Response 
2-sec Response 
3-sec Response 

96 
 
In Figure 53, the blue lines represent the rotor speed using a pilot response found 
from the Bayesian recognition plots in the previous section.  The blue dots mark the 
moment the rotor speed enters and remains in a steady-state, 3% bandwidth.  The red line 
represents the 2-second pilot delay, which is the standard for Army pilot training.  The 
black line represents a 3-second delay which, although seemingly a short amount of time, 
is significant.  The faster the aircraft is traveling, the more time is required to reestablish 
a steady-state autorotation descent. 
Figure 54 examines the 10-state model with a fuel flow engine failure.  The lines 
continue to represent the rotor speed for a Bayes’ response (blue), a standard 2-second 
delay (red), and a 3-second delay (black).  The time of entry is recorded and using the 
steady-state descent rate for each forward speed, the difference in lost altitude is 
calculated.  For the engine failure, these values are found in Table 5. 
 

97 
 
 
Figure 54: Rotor Speed Recovery with Wind-Down Failure 
Bayes’ Response 
2-sec Response 
3-sec Response 

98 
 
 
By inspection, the trend holds true that if the indicated airspeed increases from 60 
knots up to 100 knots, the time of rotor speed recovery to enter and maintain a status in 
the 3% bandwidth increases.  A more thorough analysis is exercised in the coming 
sections.  The analysis will evaluate the recovery time, the descent rate, and translate into 
an altitude loss variable. 
 
 
3.7.3. Altitude Loss Improvement 
 
 
The VirtualPilot program is commanded to maintain 100% rotor speed following 
a predetermined pilot response time.  The response time is based upon the Bayesian 
analysis from Section 3.7.1.  Figure 55 is the analysis of the descent rate based upon the 
various response times of the VirtualPilot to reacquire the commanded rotor speed.  
Ultimately, no matter the pilot response, the descent rate behaves in a similar pattern for 
all cases.  Once in a steady-state autorotation, the descent rate is precise for the initial 
indicated airspeed.  For analyzing the effects of a Bayes’ response versus a 3-second 
delayed pilot response, the steady state descent rate will be combined with the results 
from Section 3.7.2 to determine the total altitude loss difference based solely upon the 
pilot response time. 
Figure 55 and Figure 56 demonstrate an aircraft going into a steady-state 
autorotation using two different engine failing procedures.  The study is a rather trivial 
task because the steady-state autorotation descent rate should asymptote to a single value 

99 
 
over an infinite amount of time no matter how the engine is failed.  However, the task 
does confirm that no matter the delay, the model does maintain some type of controlled 
response. 
 
 
Figure 55: Steady-State Descent Rate for Instantaneous Failure 
 
 
 
Figure 56: Steady-State Descent Rate for Wind-Down Failure 
Bayes’ Response 
2-sec Response 
3-sec Response 
Bayes’ Response 
2-sec Response 
3-sec Response 

100 
 
 
The figures confirm that over an extended period, the aircraft held at an indicated 
airspeed converges to a specific descent rate.  The descent rate is to be used in Table 4 and 
Table 5 to determine altitude loss an aircraft experiences when the pilot delays 3.0 
seconds versus the delay period calculated through the 10-state model Bayes’ analysis.  
The sensitivity of Bayes’ theorem with the three hypotheses lead to estimates less than a 
0.6-second pilot delay for the driveshaft failure simulation and estimates less than a 0.8-
second pilot delay for the engine failure when determining the main rotor speed response 
along with the altitude lost estimates. 
 
 
Fwd. 
Spd. 
Descent 
Rate 
Failure 
Response 
MR Response 
Time 
Add. Alt. 
Loss 
kts 
fpm 
  
sec 
ft 
60 
-2325 
3 sec. Delay 
7.24 
104.8 
Bayes' 
4.53 
80 
-2095 
3 sec. Delay 
15.69 
162.1 
Bayes' 
11.05 
100 
-2175 
3 sec. Delay 
20.57 
327.1 
Bayes' 
11.54 
 
Table 4: Effects of Delayed Response for Instantaneous Failure 
 
 
 
 
 

101 
 
Fwd. 
Spd. 
Descent 
Rate 
Failure 
Response 
MR Response 
Time 
Add. Alt. 
Loss 
kts 
fpm 
  
sec 
ft 
60 
-2325 
3 sec. Delay 
7.72 
117.6 
Bayes' 
4.69 
80 
-2095 
3 sec. Delay 
13.17 
65.7 
Bayes' 
11.29 
100 
-2175 
3 sec. Delay 
16.75 
185.9 
Bayes' 
11.62 
 
Table 5: Effects of Delayed Response for Wind-Down Failure 
 
Referencing Table 4 and Table 5 for the response, the altitude lost was determined 
by multiplying the rotor speed recovery time with the average descent rate.  The tables 
compare the difference between a 3-second delay and Bayes’ analysis delay rather than 
the entire altitude loss for each.  The reasoning is the period when the engine fails 
through the acquisition of steady rotor speed contains significant variations in the descent 
rate which also varies amongst the delay lengths.  Taking the difference between the two 
altitude losses assists in reducing the error from those periods of time. 
As forward speed increases, more time is required by the pilot to establish a 
steady rotor speed recovery.  With pilot work load being a possible hindrance for 
successfully completing an autorotation landing, the time saved in recovering rotor speed 
is essential.  In normal operating speeds, using the Bayes’ estimation for detecting an 
engine failure results in 100-350 feet of altitude preserved for the pilot to find an 
achievable safe landing zone.  Figure 57 portrays the reduction in achievable landing 
space for an engine failure at 1000 ft of altitude and 80 knots forward speed. 
 

102 
 
 
Figure 57: Landing Area Benefit for Quick Response 
 
In graphical form, the rotor speed recovery times between a 3-second pilot delay 
and the less than 1-second pilot delay from the Bayesian estimation are shown in Figure 
58.  In the plot, the blue bars represent the time needed for the rotor speed to recover with 
a fast pilot reaction time.  The red bars are the additional time required for the 3-second 
pilot delay model to recover and stabilize main rotor speed. 

103 
 
 
Figure 58: Rotor Speed Recovery Time Between Models 
 
 
The results in Figure 58 demonstrate the toll that more than 2 seconds of pilot 
reaction time cost places on rotor speed recovery.  The red portions of the plot represent 
time that a pilot can be searching for a landing area, maneuvering to a landing area, and 
preparing to save an aircraft with its crew, rather than deciphering the source of sirens, 
lights, and dynamic response and determining the correct course of action. 
 
 
Bayes’ Response 
3-second Delay 

104 
 
 
 
 
 
 
4. Conclusions 
 
 
The creation of a model using an aircraft’s current observable data to project its 
state vector, or vectors, to some future time and evaluate the health of the aircraft’s flight 
condition at each time step is presented.  While implementing a normal operating model, 
a driveshaft failure model, and an engine failure model to precisely project future states 
of the vehicle was difficult, probability hypotheses for each model and the failure 
detection criteria were developed.  The models began as an 8-state dynamic rotorcraft 
model and a 2-state engine model.  However, using the gearing ratio between the power 
turbine speed and the main rotor speed, the models could be coupled into a 10-state 
model representative of a generic utility helicopter. 
Making adjustments to the engine component of the state matrix and the control 
variables allowed iterations of failure models to be created.  By removing the state matrix 
components of the engine model, the torque normally generated and applied to the main 
rotor was no longer transferred, thereby simulating a driveshaft failure model.  An engine 
failure was modeled by removing the fuel flow as a control. 
Using the three 10-state models, the probability analysis could be calculated over 
a 2-second propagation of the model, using its current observable data to determine the 
probability of a healthy system.  The Bayesian analysis determined a time when the 
VirtualPilot was to detect an engine failure and respond to preserve main rotor speed and 
successfully enter an autorotation.  The response due to the Bayesian analysis was 

105 
 
compared to a real-world pilot’s response time of 2 seconds, along with a delayed pilot 
reaction time of 3 seconds.  The time used to recover and stabilize rotor speed was then 
converted to altitude lost to better compare the effectiveness of the probability analysis. 
The conclusions drawn from the effort presented in this paper allow for an 
alternative methodology to be applied to modern rotorcraft in terms of safety analysis.  
The three options to protect a crew and rotorcraft in the event of a power failure are to 
add more devices (which impacts performance), add a means to better inform the pilot of 
the failure, or have the control system take the rotorcraft handling from the pilot.  This 
work presents a baseline for combining the second and third options. 
The results proved beneficial as the full rotorcraft 10-parameter dynamic and 
engine state vector could be iterated into two separate failure hypothesis models for 
analysis.  From this achievement, a scheme was put in place to track the model that had 
the highest probability of being correct at every timestep.  The models were stable 
enough to differentiate between a numerical bias in instrumentation and a disturbance 
such as wind gusts versus an actual driveshaft or engine failure.  Bayes’ theorem allowed 
for multiple models to detect a failure as a team.  From this, the system could determine 
when a system had failed within a single second of the failure, whether an instantaneous 
failure or a wind-down failure type. 
Due to the success of the methods, the time to detect a failure was less than half 
the U.S. Army requirement.  As shown in the work, a simple 3-second delay in detecting 
a malfunction can cost a pilot more than 20% of rotor speed, or kinetic energy, dissipated 
from the system.  The presentation results showed the reduction time in pilot response, 

106 
 
translated it to a reduction in rotor speed recovery time, when then reflected in the 
reduction of lost altitude needed to stabilize an aircraft entering autorotation. 
Improvements to the process outlined in this presentation can made in the 
complexity of the normal model.  The idea is to remove the basic assumptions used for 
the fuselage characteristics along with the disc model for the tail rotor.  The assumptions 
for the fuselage were that the rotorcraft was flying maneuvers in coordinated turns and at 
an angle of attack of zero at all times.  Allowing discrepancies in the angle of attack and 
sideslip will affect the external forces and moments in the equations of motion, adding 
more discrepancy to the model.  Also, moving away from a disc rotor for the tail rotor 
allows for better handling and controls of the aircraft.  However, this also increases the 
calculation time for propagating the model forward. 
Finally, expansion of this work can take many directions as well.  Three topics to 
further evaluate to improve the model for a control system is a better weighting for the 
covariance matrices, a higher fidelity engine model with more parameter inputs such as 
shaft power, pressure changes following the combustor, T45 temperature readings, torque 
requirements, etc., and a completion of all three legs of an autorotation to create a full 
autorotation simulation from failure to touchdown.  The second and third expansion ideas 
are self-explanatory.  The first expansion idea requires some detail.  When calculating the 
probability of an engine failure using a determinant of the Sk matrix, gain sets were 
needed to prevent the determinant from being too close to singular.  This was the case in 
the 8-state model where knots on the 102 magnitude were being grouped with angular 
rates and positions in radians on the 10-4 magnitude.  Gain sets based upon airspeed 

107 
 
schedules were used, however, it would benefit the project to have a better weighting 
system in place using optimal controls. 
 
 
 
 

108 
 
 
 
 
 
 
 
Bibliography 
 
 
[1] 
Bottasso, C. L., Maisano, G., & Scorcelletti, F. (2009). Trajectory Optimization 
Procedures for Rotorcraft Vehicles Including Pilot Models, with Applications to 
ADS-33MTEs, Cat-A and Engin Off Landings. American Helicopter Society 65th 
Annual Forum and Technology Display. Grapevine, TX: AHS, Inc. 
[2]  
“UH-60A Expanded Gross Weight and Center of Gravity Evaluation”, 
USAAEFA No. 81-16, U.S. Army Aviation Engineering Flight Activity, Edwards 
Air Force Base, CA, August 1985. 
[3]  
“Operator’s Manual for Helicopters, Utility Tactical Transport”, TM 1-1520-280-
10, Department of the Army, Washington D.C., November 2007. 
[4]  
“Operator’s Manual for Army OH-58D Helicopter”, TM 1-1520-248-10, 
Department of the Army, Washington D.C., April 2013. 
[5] 
Graves, John D. (1983). Methods and Devices to Improve Helicopter 
Autorotational Characteristics (USAAVRADCOM-TR-82-D-38). Culver City, CA. 
[6] 
Keller, J. D., McKillip Jr, R. M., Horn, J. F., & Yomchinda, T. (2011). Active 
Flight Control and Applique Inceptor Concepts for Autorotation Performance 
Enhancement. American Helicopter Society 67th Annual Forum. Virginia Beach, 
VA: AHS, Inc. 

109 
 
[7] 
Bryson Jr., A. E., & Ho, Y.-C. (1975). Applied Optimal Control: Optimization, 
Estimation, and Control. Arlington, VA: Hemisphere Publishing Corporation. 
[8] 
Thanapalan, K.K.T. Modellingof a Helicopter System. University College 
London, U.K. 
[9] 
Aponso, B. L., Bachelder, E. N., & Lee, D. (2005). Automated Autorotation for 
Unmanned Rotorcraft Recovery. The AHS International Specialists' Meeting on 
Unmanned Rotorcraft. Chandler, AZ: American Helicopter Society International, 
Inc. 
[10] 
Padfield, Gareth D. (2007). Helicopter Flight Dynamics: The Theory and 
Application of Flying Qualities and Simulation Modeling. Reston, VA: American 
Institute of Aeronautics and Astronautics, Inc. 
[11] 
Duyar, A., Gu, Z., & Litt, J.S. (1992). A Simplified Dynamic Model of the T700 
Turboshaft Engine. 48th American Helicopter Society Annual Forum. Washington 
D.C.: AHS, Inc. 
[12] 
Ballin, Mark G. (1988). A High Fidelity Real-Time Simulation of a Small 
Turboshaft Engine (NASA-TM-100991). Moffett Field, CA: NASA. 
[13] 
Kim, Ki C. (1999). Analytical Cacluations of Helicopter Torque Coefficients (CQ) 
and Thrust Coefficient (CT) Values for the Helicopter Performance (HELPE) 
Model (ARL-TR-1986). Aberdeen Proving Ground, MD: Army Research 
Laboratory. 
[14] 
Siouris, G. M. (1996). An Engineering Approach to Optimal Control and 
Estimation Theory. New York, NY: John Wiley & Sons, Inc. 

110 
 
[15] 
Stengel, R. F. (1994). Optimal Control and Estimation. New York: Dover 
Publications, Inc., New York, NY. 
[16] 
Stevens, B. L., & Lewis, F. L. (1992). Aircraft Control and Simulation. New 
York: John Wiley & Sons, Inc. 
[17] 
Marschke, J. M., Crassidis, J. L., & Lam, Q. M. Multiple Model Adaptive 
Estimation for Inertial Navigation During Mars Entry. American Institute of 
Aeronautics and Astronautics. 
[18] 
Ferrell, K. R. (1974). Helicopter Performance Testing (AMCP 706-204). 
Alexandria, VA: US Army Materiel Command. 
[19] 
Tudosie, Alexandru-Nicolae. (2016). Turboshaft-Type APU for Aircraft as 
Controlled Object. Scientific Research and Education in the Air Force-AFASES, 
93-100. 
[20] 
Prouty, Raymond W. (2002). Helicopter Performance, Stability, and Control. 
Malabar, FL: Krieger Publishing Company. 

111 
 
 
 
 
 
 
Appendices 
 
 
 

112 
 
 
 
 
 
 
Appendix A – State Representation Form 
 
 
The following Appendix outlines the development of the Kalman Filter input 
matrices from the equations of motion provided in the Thanapalan paper [8].  The 
parameter designation for the Kalman filter matrices are matched with those in the Sioris 
paper [14]. 
  
x
x
x
-1
k
k
t



 
w
u
x
x




B
A

 
 
Continue to next page 

113 
 
The State Matrix component is broken into the initial values and those affected by a change in time. 
 












































1
1
1
1
1
1
1
1
1
1
1
k
k
k
k
k
k
k
k
k
k
k
NP
NG
r
q
p
w
v
u


x
 

114 
 










































































































































NP
NG
r
q
p
w
v
u
NP
P
N
NG
P
N
P
N
u
P
N
q
r
r
q
r
q
NP
r
NG
r
r
r
q
r
p
r
NP
q
r
q
q
q
p
q
NP
p
NG
p
r
p
q
p
p
p
NP
w
g
g
u
v
p
q
NP
v
g
g
u
w
p
r
NP
u
g
v
w
q
r
A















































0
0
0
0
0
0
0
233
.2
0
0
0
0
0
0
0
0
0
0
0
sin
cos
sin
cos
0
0
0
0
0
0
sec
cos
sin
tan
sin
cos
tan
cos
tan
sin
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
sin
cos
cos
sin
0
0
0
sin
sin
cos
cos
0
0
0
cos
0
0
0
2
x
 

115 
 
The Control Matrix component uses the swashplate angles and the fuel flow as 
inputs into the system. The fuel flow component is the primary control for the generator 
and power turbine speed states.  The power turbine speed, when engaged with the sprag 
gear, is mechanically linked to the main rotor speed with a gearing ratio of 81.04:1.  The 
torque coefficient and change in rotor speed found in the external moment about Z also 
are functions of various states.  These relationships allow the engine model to be coupled 
with the dynamic (8x8) model through the main rotor speed as a non-constant. 
 







































































































f
sw
cw
f
f
sw
cw
sw
cw
f
sw
cw
sw
cw
sw
cw
sw
cw
w
w
P
N
w
r
r
r
r
q
q
q
w
p
p
p
p
w
w
w
v
v
v
u
u
u
B
1
1
0
1
1
0
1
1
0
1
1
0
1
1
0
1
1
0
1
1
0
0
0
0
149400
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0










































u
 
where 





























60
2
04
.
81
1
60
2
04
.
81
1


NP
NPk
k
 
 

116 
 
From each the state and control matrix calculated above, each has partial derivatives derived from the Taylor Series to 
linearize the coupled equations.  Those partial derivatives are shown below. In some cases, the partial derivative is a function 
of more partial derivatives.  Those are presented as well. 
 
*** State Vector Partial Derivatives *** 


NP
C
C
s
a
R
NP
u
s
Z
s
X











sin
cos
0
4

 


NP
C
s
a
R
NP
v
Y 






0
4


 


NP
C
C
s
a
R
NP
w
s
Z
s
X











cos
sin
0
4

 




q
I
I
I
I
I
I
I
I
I
I
I
p
p
xx
xz
xz
zz
xx
xx
xz
yy
xx
xx
xz













2
2
2

 








2
2
2
2
xz
zz
xx
xx
xz
yy
xx
xx
xz
xx
zz
yy
xz
xx
xz
zz
yy
I
I
I
I
p
I
I
I
I
I
r
I
I
I
I
I
p
I
r
I
I
q
p












 

117 
 






q
I
I
I
I
I
I
I
I
I
I
I
r
p
xz
zz
xx
xx
xx
zz
yy
xz
xx
zz
yy














2
2

 


2
3128
.0
xz
zz
xx
xx
xz
xx
p
I
I
I
I
I
I
I
NG
p




 



NP
N
I
I
I
I
I
I
NP
L
I
I
I
I
I
I
NP
p
xz
zz
xx
xx
xz
xx
xz
zz
xx
xx
zz
xx










2
2

 
p
I
I
r
I
I
I
p
q
yy
xz
yy
xx
zz
2





 
0



q
q
 
r
I
I
p
I
I
I
r
q
yy
xz
yy
xx
zz
2





 







NP
C
R
x
l
C
C
s
a
R
h
C
C
s
a
R
x
I
NP
q
ZTP
cg
TP
s
Z
s
X
R
s
Z
s
X
cg
yy












2
0
4
0
4
sin
cos
cos
sin
1








 

118 
 

q
I
I
I
I
I
I
I
p
r
xz
zz
xx
xz
yy
xx
xx
2
2
2






 




2
2
2
xz
zz
xx
xz
yy
xx
xx
xx
zz
yy
xz
I
I
I
p
I
I
I
I
r
I
I
I
I
q
r









 

q
I
I
I
I
I
I
I
r
r
xz
zz
xx
xx
zz
yy
xz
2






 
2
3128
.0
xz
zz
xx
xx
p
I
I
I
I
I
NG
r




 
NP
N
I
I
I
I
NP
L
I
I
I
I
NP
r
xz
zz
xx
xx
xz
zz
xx
xz










2
2

 



























3
3
2
2
2
1
0
2
5.1
15
.1
tan
0
R
u
A
f
R
u
s
C
R
C
NP
s
a
I
b
I
u
P
N
D
s
T
R






 






















s
T
R
R
u
C
NP
s
a
I
b
I
P
N






2
1
0
2
sec

 
 

119 
 























s
a
R
R
I
NP
s
a
I
b
I
NG
P
N
p
R
0
3
2
1
0
2
6256
.0





 


s
a
R
I
b
I
I
R
u
A
f
s
C
R
u
C
s
a
I
b
I
NP
P
N
R
p
D
s
T
R
0
5
3
2
3
0
4461
.0
2
1
4
tan
2
0



































 
 
*** Control Vector Partial Derivatives *** 



































s
Z
s
X
a
s
a
C
s
a
C
s
a
R
R
M
u







sin
2
cos
2
2
1
1
0
0
0
0
0
2
2
0

 



































s
Z
cw
s
X
cw
a
cw
s
a
C
s
a
C
s
a
R
R
M
u







sin
2
cos
2
2
1
1
0
1
0
1
0
2
2
1

 



































s
Z
sw
s
X
sw
a
sw
s
a
C
s
a
C
s
a
R
R
M
u







sin
2
cos
2
2
1
1
0
1
0
1
0
2
2
1

 


























s
a
C
s
a
R
R
M
v
Y
a
0
0
0
2
2
0
2
2
1
1





 

120 
 


























s
a
C
s
a
R
R
M
v
Y
cw
a
cw
0
1
0
2
2
1
2
2
1
1





 


























s
a
C
s
a
R
R
M
v
Y
sw
a
sw
0
1
0
2
2
1
2
2
1
1





 



































s
Z
s
X
a
s
a
C
s
a
C
s
a
R
R
M
w







cos
2
sin
2
2
1
1
0
0
0
0
0
2
2
0

 



































s
Z
cw
s
X
cw
a
cw
s
a
C
s
a
C
s
a
R
R
M
w







cos
2
sin
2
2
1
1
0
1
0
1
0
2
2
1

 



































s
Z
sw
s
X
sw
a
sw
s
a
C
s
a
C
s
a
R
R
M
w







cos
2
sin
2
2
1
1
0
1
0
1
0
2
2
1

 






























s
a
C
x
I
h
I
s
a
R
R
I
I
I
p
Y
cg
xz
R
zz
xz
zz
xx
0
0
0
2
2
2
0
2
2
1
1





 






























s
a
C
x
I
h
I
s
a
R
R
I
I
I
p
Y
cw
cg
xz
R
zz
xz
zz
xx
cw
0
1
0
2
2
2
1
2
2
1
1





 

121 
 






























s
a
C
x
I
h
I
s
a
R
R
I
I
I
p
Y
sw
cg
xz
R
zz
xz
zz
xx
sw
0
1
0
2
2
2
1
2
2
1
1





 


2
16630
xz
zz
xx
xx
xz
xx
p
f
I
I
I
I
I
I
I
w
p




 



































































s
Z
s
X
R
s
Z
s
X
cg
yy
s
a
C
s
a
C
h
s
a
C
s
a
C
x
s
a
R
R
I
q











sin
2
cos
2
cos
2
sin
2
2
1
1
0
0
0
0
0
0
0
0
0
2
2
0

 



































































s
Z
cw
s
X
cw
R
s
Z
cw
s
X
cw
cg
yy
cw
s
a
C
s
a
C
h
s
a
C
s
a
C
x
s
a
R
R
I
q











sin
2
cos
2
cos
2
sin
2
2
1
1
0
1
0
1
0
1
0
1
0
2
2
1

 



































































s
Z
sw
s
X
sw
R
s
Z
sw
s
X
sw
cg
yy
sw
s
a
C
s
a
C
h
s
a
C
s
a
C
x
s
a
R
R
I
q











sin
2
cos
2
cos
2
sin
2
2
1
1
0
1
0
1
0
1
0
1
0
2
2
1

 






























s
a
C
x
I
h
I
s
a
R
R
I
I
I
r
Y
cg
xx
R
xz
xz
zz
xx
0
0
0
2
2
2
0
2
2
1
1





 






























s
a
C
x
I
h
I
s
a
R
R
I
I
I
r
Y
cw
cg
xx
R
xz
xz
zz
xx
cw
0
1
0
2
2
2
1
2
2
1
1





 

122 
 






























s
a
C
x
I
h
I
s
a
R
R
I
I
I
r
Y
sw
cg
xx
R
xz
xz
zz
xx
sw
0
1
0
2
2
2
1
2
2
1
1





 
2
16630
xz
zz
xx
xx
p
f
I
I
I
I
I
w
r




 























s
a
R
R
I
NP
s
a
I
b
I
w
P
N
p
R
f
0
3
2
1
0
2
33260





 
 
*** External Moments Partial Derivatives *** 
NP
C
R
h
NP
L
Y
R







4
2

 
NP
C
R
x
I
NP
N
Y
cg
p









4
2
4461
.0

 
 
 

123 
 
*** External Force Coefficient Partial Derivatives *** 


0
1
2
0
0
2
6
8
3
6
1
2


























z
sw
cw
X
s
a
C
 


cw
w
X
cw
q
s
a
C
1
0
2
0
1
16
8
6
1
2























 


sw
w
z
cw
X
sw
p
s
a
C
1
0
1
0
1
32
3
4
16
3
2




















 
6
4
3
8
3
6
1
2
0
1
2
0
0
cw
sw
Y
s
a
C
























 


sw
w
z
cw
Y
cw
p
s
a
C
1
0
1
0
1
16
4
4
2





















 


cw
w
Y
sw
q
s
a
C
1
0
2
0
1
16
8
6
1
2
























 
2
3
1
2
2
0
0













s
a
CZ
 

124 
 
0
2
0
1









s
a
CZ
cw

 
2
2
0
1












s
a
CZ
sw
 
 
 

125 
 
 
 
 
 
 
 
Appendix B – XAnalysis Code 
 
 
********** Bayesian Estimation for Dynamic Model ********** 
//***************** F*x(k-1) information ******************// 
 
if(counter == 1) 
 
wk0 = [0 0 0 0 0 0 0 0 0 0]'; 
 
vk = [0 0 0 0 0 0]';  // Htot is 6x10, vk is 6x1 
 
xkm1 = [ukm1 vkm1 wkm1 pkm1 qkm1 rkm1 phikm1 thetakm1 NGkm1 NPkm1]'; // NG and NP 
are rpm - input rpm 
 
xk = [u v w p q r phi theta NG NP]'; 
 
xk0 = xk; 
 
zk = [u w phi theta NG NP]'; 
 
zk0 = zk; 
 
ucontrolkm1 = [the0km1 the1cwkm1 the1swkm1 wfkm1]'; 
 
ucontrolk = [the0 the1cw the1sw wf]'; 
end 
ucontrolkm1(4,1) = wfkm1; 
ucontrolk(4,1) = wf; 
 
dpdp = (Ixz*(Ixx^2-Ixx*Iyy+Ixz^2)/(Ixx*(Ixx*Izz-Ixz^2))+Ixz/Ixx)*q; 
dpdq = ((Iyy-Izz)*r+Ixz*p)/Ixx + (Ixz^2*(Iyy-Izz-Ixx)*r+Ixz*(Ixx^2-
Ixx*Iyy+Ixz^2)*p)/(Ixx*(Ixx*Izz-Ixz^2)); 
dpdr = ((Iyy-Izz)/Ixx + Ixz^2*(Iyy-Izz-Ixx)/(Ixx*(Ixx*Izz-Ixz^2)))*q; 
dqdp = (Izz-Ixx)*r/Iyy - 2*Ixz*p/Iyy; 
dqdq = 0; 
dqdr = (Izz-Ixx)*p/Iyy + 2*Ixz*r/Iyy; 
drdp = (Ixx^2-Ixx*Iyy+Ixz^2)/(Ixx*Izz-Ixz^2)*q; 
drdq = (Ixz*(Iyy-Izz-Ixx)*r + (Ixx^2-Ixx*Iyy+Ixz^2)*p)/(Ixx*Izz-Ixz^2); 
drdr = Ixz*(Iyy-Izz-Ixx)/(Ixx*Izz-Ixz^2)*q; 
 
om = (xk(10,1)/81.04)*(2*3.14/60);  // NP is rpm, om is rad/sec 
domdNP = (2*3.14/60)/81.04; 
 
F01 = the0*(1/3 + mu^2/2) + mu/2*(the1sw + pw/2) + (muz/2 - lam0/2) + thetw*(1+mu^2)/4; 
F2c1 = -mu*(the1sw + beta1cw + (pw-lam1sw)/2 + mu*(the0 + thetw/2))/2; 
F1c1 = (alphacw + the1cw)/3 - mu*beta0/2; 
F1s1 = (alphasw + the1sw)/3 + mu*(the0 + muz -lam0 + 2*thetw/3); 
F2s1 = mu*(the1cw - beta1sw + (qw-lam1cw)/2 - mu*beta0)/2; 
F1c2 = -2*beta0*mu*(muz-lam0-4*mu*beta1cw/3) + (muz-lam0-4*mu*beta1cw/3)*alphacw - 
mu*beta1sw*alphasw/4 + the0*(alphacw/3-mu*(beta0+mu*beta1sw/2)/2) + thetw*(alphacw/4-
mu*(beta0/3+mu*beta1sw/8)) + the1cw*((muz-lam0)/2+mu*((alphasw-beta1cw)/2-beta1cw)/4) + 
mu*the1sw*((alphacw-beta1sw)/2-beta1sw-mu*beta0)/4; 
F1s2 = mu^2*beta0*beta1sw/2 + (muz-lam0-mu*beta1cw/4)*alphasw - mu*beta1sw*alphacw/4 + 
the0*(alphasw/3+mu*(muz-lam0)-mu^2*beta1cw/4) + thetw*(alphasw/4+mu*(muz-lam0-
beta1cw*mu/4)/2) + the1sw*((muz-lam0)/2+mu*(3*(alphasw-beta1cw)/8+beta1cw/4)) + 
mu*the1cw*((alphacw-beta1sw)/2-beta1sw-mu*beta0)/4; 
Cx = (F01/2 + F2c1/4)*beta1cw + F1c1*beta0/2 + F2s1*beta1sw/4 + F1s2/2;  // 2Cx/a0s 
Cy = (F01/2 + F2c1/4)*beta1sw - F1s1*beta0/2 - F2s1*beta1cw/4 + F1c2/2;  // 2Cy/a0s 
Cz = -F01;  // 2Cz/a0s 
dLdNP = 2*hR*rho*3.14*MRR^4*om*Cy*domdNP; 
dNdNP = -0.4461*Ip*-2*xcg*rho*3.14*MRR^4*om*Cy*domdNP; 
 
duddNP = (1/Ma)*((rho*3.14*MRR^4*a0*s)*(Cx*cos(gs)-Cz*sin(gs))*om*domdNP); 
dvddNP = (1/Ma)*((rho*3.14*MRR^4*a0*s)*Cy*om*domdNP); 
dwddNP = (1/Ma)*((rho*3.14*MRR^4*a0*s)*(Cx*sin(gs)+Cz*cos(gs))*om*domdNP); 

126 
 
dpddNG = 0.3128*Ip*Ixx*Izz/(Ixx*(Ixx*Izz-Ixz^2)); 
dpddNP = Ixx*Izz*dLdNP/(Ixx*(Ixx*Izz-Ixz^2)) + Ixx*Ixz*dNdNP/(Ixx*(Ixx*Izz-Ixz^2)); 
dqddNP = (1/Iyy)*(xcg*rho*3.14*MRR^4*a0*s*(Cx*sin(gs)+Cz*cos(gs)) - 
hR*rho*3.14*MRR^4*a0*s*(Cx*cos(gs)-Cz*sin(gs)) + lTPxCG*rho*MRR^2*CZTPval)*om*domdNP; 
drddNG = 0.3128*Ip*Ixx/(Ixx*Izz-Ixz^2); 
drddNP =Ixz*dLdNP/(Ixx*Izz-Ixz^2) + Ixx*dNdNP/(Ixx*Izz-Ixz^2); 
dNPddu = Ibeta*b*LockNum*om^2/(IR*a0*s*domdNP)*(-k*CT*tan(x(8)-
3*3.14/180)/(om*MRR)+1.15*CD0*s*u/(om*MRR)^2+1.5*fA*u^2/(om*MRR)^3; 
dNPddtheta = Ibeta*b*LockNum*om^2/(IR*a0*s*domdNP))*(-k*CT*u/(om*MRR*cos(x(8)-
3*3.14/180)^2); 
dNPddNG = Ibeta*b*LockNum*om^2*0.6256*Ip/(IR*a0*s*domdNP*rho*(om*Mrr)^2*3.14*MRR^3*a0*s); 
dNPddNP = (Ibeta*b*LockNum/(IR*a0*s))*(k*CT*(2*lam0*om-x(1)*tan(x(8)-
3*3.14/180)/MRR))+CD0*s*om/4-0.5*fA*u^3/(om^2*MRR^3))-
0.4461*Ip*Ibeta*LockNum*b/(IR*rho*MRR^5*3.14*a0*s); 
 
A11 = 0; 
A12 = r; 
A13 = -q; 
A14 = 0; 
A15 = -w; 
A16 = v; 
A17 = 0; 
A18 = -grav*cos(theta); 
A19 = 0; 
A110 = duddNP; 
A21 = -r; 
A22 = 0; 
A23 = p; 
A24 = w; 
A25 = 0; 
A26 = -u; 
A27 = grav*cos(phi)*cos(theta); 
A28 = -grav*sin(phi)*sin(theta); 
A29 = 0; 
A210 = dvddNP; 
A31 = q; 
A32 = -p; 
A33 = 0; 
A34 = -v; 
A35 = u; 
A36 = 0; 
A37 = -grav*sin(phi)*cos(theta); 
A38 = -grav*cos(phi)*sin(theta); 
A39 = 0; 
A310 = dwddNP; 
A41 = 0; 
A42 = 0; 
A43 = 0; 
A44 = dpdp; 
A45 = dpdq; 
A46 = dpdr; 
A47 = 0; 
A48 = 0; 
A49 = dpddNG; 
A410 = dpddNP; 
A51 = 0; 
A52 = 0; 
A53 = 0; 
A54 = dqdp; 
A55 = dqdq; 
A56 = dqdr; 
A57 = 0; 
A58 = 0; 
A59 = 0; 
A510 = dqddNP; 
A61 = 0; 
A62 = 0; 
A63 = 0; 
A64 = drdp; 

127 
 
A65 = drdq; 
A66 = drdr; 
A67 = 0; 
A68 = 0; 
A69 = drddNG; 
A610 = drddNP; 
A71 = 0; 
A72 = 0; 
A73 = 0; 
A74 = 1; 
A75 = sin(phi)*tan(theta); 
A76 = cos(phi)*tan(theta); 
A77 = (q*cos(phi)-r*sin(phi))*tan(theta); 
A78 = (q*sin(phi)+r*cos(phi))/(cos(theta)*cos(theta)); 
A79 = 0; 
A710 = 0; 
A81 = 0; 
A82 = 0; 
A83 = 0; 
A84 = 0; 
A85 = cos(phi); 
A86 = -sin(phi); 
A87 = -(q*sin(phi)-r*cos(phi)); 
A88 = 0; 
A89 = 0; 
A810 = 0; 
A91 = 0; 
A92 = 0; 
A93 = 0; 
A94 = 0; 
A95 = 0; 
A96 = 0; 
A97 = 0; 
A98 = 0; 
A99 = -2.233; 
A910 = 0; 
A101 = dNPddu; 
A102 = 0; 
A103 = 0; 
A104 = 0; 
A105 = 0; 
A106 = 0; 
A107 = 0; 
A108 = dNPddtheta; 
A109 = dNPddNG; 
A1010 = dNPddNP; 
 
Atot = [A11 A12 A13 A14 A15 A16 A17 A18 A19 A110; 
        A21 A22 A23 A24 A25 A26 A27 A28 A29 A210; 
        A31 A32 A33 A34 A35 A36 A37 A38 A39 A310; 
        A41 A42 A43 A44 A45 A46 A47 A48 A49 A410; 
        A51 A52 A53 A54 A55 A56 A57 A58 A59 A510; 
        A61 A62 A63 A64 A65 A66 A67 A68 A69 A610; 
        A71 A72 A73 A74 A75 A76 A77 A78 A79 A710; 
        A81 A82 A83 A84 A85 A86 A87 A88 A89 A810; 
        A91 A92 A93 A94 A95 A96 A97 A98 A99 A910; 
        A101 A102 A103 A104 A105 A106 A107 A108 A109 A1010]; 
 
I1010 = [1 0 0 0 0 0 0 0 0 0; 
         0 1 0 0 0 0 0 0 0 0; 
         0 0 1 0 0 0 0 0 0 0; 
         0 0 0 1 0 0 0 0 0 0; 
         0 0 0 0 1 0 0 0 0 0; 
         0 0 0 0 0 1 0 0 0 0; 
         0 0 0 0 0 0 1 0 0 0; 
         0 0 0 0 0 0 0 1 0 0; 
         0 0 0 0 0 0 0 0 1 0; 
         0 0 0 0 0 0 0 0 0 1]; 
 

128 
 
//***************** G*u(k) information *****************// 
 
dcxdt0 = beta1cw/3 + (pw-lam1sw)/6 + mu*(muz-lam0)/2; 
dcxdt1cw = (1/6-mu^2/8)*beta0 + mu*(qw-lam1cw)/16; 
dcxdt1sw = mu*beta1cw/4 + (muz-lam0)/4 + 3*mu*(pw-lam1sw)/16; 
dcydt0 = (qw-lam1cw)/6 - 3*mu*beta0/8; 
dcydt1cw = -mu*beta1cw/4 + (muz-lam0)/4 + mu*(pw-lam1sw)/16; 
dcydt1sw = -(1/6+mu^2/8)*beta0 + mu*(qw-lam1cw)/16; 
dczdt0 = -1/3 - mu^2/2; 
dczdt1cw = 0; 
dczdt1sw = -mu/2; 
 
common = 0.5*rho*(om*MRR)^2*3.14*MRR^2*a0*s; 
dudt0 = (1/Ma)*common*(dcxdt0*cos(gs)-dczdt0*sin(gs)); 
dudt1cw = (1/Ma)*common*(dcxdt1cw*cos(gs)-dczdt1cw*sin(gs)); 
dudt1sw = (1/Ma)*common*(dcxdt1sw*cos(gs)-dczdt1sw*sin(gs)); 
dvdt0 = (1/Ma)*common*dcydt0; 
dvdt1cw = (1/Ma)*common*dcydt1cw; 
dvdt1sw = (1/Ma)*common*dcydt1sw; 
dwdt0 = (1/Ma)*common*(dcxdt0*sin(gs)+dczdt0*cos(gs)); 
dwdt1cw = (1/Ma)*common*(dcxdt1cw*sin(gs)+dczdt1cw*cos(gs)); 
dwdt1sw = (1/Ma)*common*(dcxdt1sw*sin(gs)+dczdt1sw*cos(gs)); 
dpdt0 = (common/(Ixx*Izz-Ixz^2))*(Izz*hR-Ixz*xcg)*dcydt0; 
dpdt1cw = (common/(Ixx*Izz-Ixz^2))*(Izz*hR-Ixz*xcg)*dcydt1cw; 
dpdt1sw = (common/(Ixx*Izz-Ixz^2))*(Izz*hR-Ixz*xcg)*dcydt1sw; 
dpdwf = 16630*Ip*Ixx*Ixz/(Ixx*(Ixx*Izz-Ixz^2)); 
dqdt0 = (common/Iyy)*(xcg*(dcxdt0*sin(gs)+dczdt0*cos(gs))-hR*(dcxdt0*cos(gs)-
dczdt0*sin(gs))); 
dqdt1cw = (common/Iyy)*(xcg*(dcxdt1cw*sin(gs)+dczdt1cw*cos(gs))-hR*(dcxdt1cw*cos(gs)-
dczdt1cw*sin(gs))); 
dqdt1sw = (common/Iyy)*(xcg*(dcxdt1sw*sin(gs)+dczdt1sw*cos(gs))-hR*(dcxdt1sw*cos(gs)-
dczdt1sw*sin(gs))); 
drdt0 = common/(Ixx*Izz-Ixz^2)*(Ixz*hR-Ixx*xcg)*dcydt0; 
drdt1cw = common/(Ixx*Izz-Ixz^2)*(Ixz*hR-Ixx*xcg)*dcydt1cw; 
drdt1sw = common/(Ixx*Izz-Ixz^2)*(Ixz*hR-Ixx*xcg)*dcydt1sw; 
drdwf = 16630*Ip*Ixx/(Ixx*Izz-Ixz^2); 
dNPdwf = Ibeta*b*LockNum*om^2*33260*Ip/(IR*a0*s*rho*om^2*MRR^5*3.14*a0*s*domdNP); 
 
B11 = dudt0; 
B12 = dudt1cw; 
B13 = dudt1sw; 
B14 = 0; 
B21 = dvdt0; 
B22 = dvdt1cw; 
B23 = dvdt1sw; 
B24 = 0; 
B31 = dwdt0; 
B32 = dwdt1cw; 
B33 = dwdt1sw; 
B34 = 0; 
B41 = dpdt0; 
B42 = dpdt1cw; 
B43 = dpdt1sw; 
B44 = dpdwf; 
B51 = dqdt0; 
B52 = dqdt1cw; 
B53 = dqdt1sw; 
B54 = 0; 
B61 = drdt0; 
B62 = drdt1cw; 
B63 = drdt1sw; 
B64 = drdwf; 
B71 = 0; 
B72 = 0; 
B73 = 0; 
B74 = 0; 
B81 = 0; 
B82 = 0; 
B83 = 0; 

129 
 
B84 = 0; 
B91 = 0; 
B92 = 0; 
B93 = 0; 
B94 = 149400; 
B101 = 0; 
B102 = 0; 
B103 = 0; 
B104 = dNPdwf; 
 
Btot = [B11 B12 B13 B14; 
 
B21 B22 B23 B24; 
 
B31 B32 B33 B34; 
 
B41 B42 B43 B44; 
 
B51 B52 B53 B54; 
 
B61 B62 B63 B64; 
 
B71 B72 B73 B74; 
 
B81 B82 B83 B84; 
 
B91 B92 B93 B94; 
 
B101 B102 B103 B104]; 
 
//***************** xkp1 Calculation *****************// 
 
F = I1010 + dt*Atot; 
G = dt*Btot; 
 
wk = wk0 - dt*Atot*xkm1 - dt*Btot*ucontrolkm1; 
xkp1 = F*xk + G*ucontrolk + wk; 
wk = xkp1 - xk0; 
 
Qk = [wk(1,1)^2 0 0 0 0 0 0 0 0 0; 
      0 wk(2,1)^2 0 0 0 0 0 0 0 0; 
      0 0 wk(3,1)^2 0 0 0 0 0 0 0; 
      0 0 0 wk(4,1)^2 0 0 0 0 0 0; 
      0 0 0 0 wk(5,1)^2 0 0 0 0 0; 
      0 0 0 0 0 wk(6,1)^2 0 0 0 0; 
      0 0 0 0 0 0 wk(7,1)^2 0 0 0; 
      0 0 0 0 0 0 0 wk(8,1)^2 0 0; 
      0 0 0 0 0 0 0 0 wk(9,1)^2+0.00000000000000000001 0; 
      0 0 0 0 0 0 0 0 0 wk(10,1)^2+0.00000000000000000001]; 
 
if(counter==1) 
 
alpha = 10; 
 
Pk = alpha^2*Qk;  //Durrant-Whyte Reference states initial Q * alpha^2 with alpha 
     about 10 is a good first guess 
 
                  //The 100 can drop significantly lower if need be 
end 
Pkp1 = Atot*Pk*Atot' + Qk;  // Sioris paper Eq 4.7-43 
 
//***************** zkp1 Calculations *****************// 
 
Htot = [1 0 0 0 0 0 0 0 0 0; 
        0 0 1 0 0 0 0 0 0 0; 
        0 0 0 0 0 0 1 0 0 0; 
        0 0 0 0 0 0 0 1 0 0; 
 
0 0 0 0 0 0 0 0 1 0; 
 
0 0 0 0 0 0 0 0 0 1]; 
 
zkp1 = Htot*xkp1 + vk; // vk is previously defined 
vkp1 = zkp1 - zk0; 
 
Rk = [vkp1(1,1)^2 0 0 0 0 0; 
      0 vkp1(2,1)^2 0 0 0 0; 
      0 0 vkp1(3,1)^2 0 0 0; 
      0 0 0 vkp1(4,1)^2 0 0; 
      0 0 0 0 vkp1(5,1)^2+0.00000000000000000001 0; 
      0 0 0 0 0 vkp1(6,1)^2+0.00000000000000000001];  // weights found in other scripts 
    from rev0 
 

130 
 
Kk = Pkp1*Htot'*inv(Htot*Pkp1*Htot' + Rk); 
xkp1kp1 = xkp1 + Kk*(zkp1 - Htot*xkp1); 
Pkp1kp1 = inv(inv(Pkp1) + Htot'*inv(Rk)*Htot); 
Sk = Htot*Pkp1*Htot' + Rk; 
rkatp1 = zkp1 - Htot*xkp1; 
detSk = det(Sk); 
PROBzkxk1 = (1/((2*3.14)^(1/2)*detSk^0.5))*exp((-0.5)*rkatp1'*inv(Sk)*rkatp1); 
 
// Reset variables 
xkm1 = xk; 
xk = xkp1kp1; 
zk = zkp1; 
wk0 = wk; 
vk = vkp1; 
Pk = Pkp1kp1; 
 
u = xkp1kp1(1,1); 
v = xkp1kp1(2,1); 
w = xkp1kp1(3,1); 
p = xkp1kp1(4,1); 
q = xkp1kp1(5,1); 
r = xkp1kp1(6,1); 
phi = xkp1kp1(7,1); 
theta = xkp1kp1(8,1); 
NG = xkp1kp1(9,1); 
NP = xkp1kp1(10,1); 
 
//*********** End of Probability Calc ***********// 
 
 
********** Bayesian Estimation for Driveshaft Failure Model ********** 
 
//***************** F*x(k-1) information ******************// 
 
if(counterAdiagzero == 1) 
 
wk0AdiagzeroNEW = [0 0]'; 
 
wk0Adiagzero = [0 0 0 0 0 0 0 0 0 0]'; 
 
vkAdiagzeroNEW = [0 0]';  // Htot is 6x10, vk is 6x1 
 
vkAdiagzero = [0 0 0 0 0 0]'; 
 
xkm1Adiagzero = [ukm1Adiagzero vkm1Adiagzero wkm1Adiagzero pkm1Adiagzero 
qkm1Adiagzero rkm1Adiagzero phikm1Adiagzero thetakm1Adiagzero NGkm1Adiagzero 
NPkm1Adiagzero]'; // NG and NP are rpm - input rpm 
 
xkAdiagzero = [uAdiagzero vAdiagzero wAdiagzero pAdiagzero qAdiagzero rAdiagzero 
phiAdiagzero thetaAdiagzero NGAdiagzero NPAdiagzero]'; 
 
xkAdiagzero0 = xkAdiagzero; 
 
zkAdiagzero = [uAdiagzero wAdiagzero phiAdiagzero thetaAdiagzero NGAdiagzero 
NPAdiagzero]'; 
 
zkAdiagzero0 = zkAdiagzero; 
 
ucontrolkm1Adiagzero = [the0km1 the1cwkm1 the1swkm1 wfkm1]'; 
 
ucontrolkAdiagzero = [the0 the1cw the1sw wf]'; 
end 
ucontrolkm1Adiagzero(4,1) = wfkm1;   
ucontrolkAdiagzero(4,1) = wf; 
 
dpdp = (Ixz*(Ixx^2-Ixx*Iyy+Ixz^2)/(Ixx*(Ixx*Izz-Ixz^2))+Ixz/Ixx)*q; 
dpdq = ((Iyy-Izz)*r+Ixz*p)/Ixx + (Ixz^2*(Iyy-Izz-Ixx)*r+Ixz*(Ixx^2-
Ixx*Iyy+Ixz^2)*p)/(Ixx*(Ixx*Izz-Ixz^2)); 
dpdr = ((Iyy-Izz)/Ixx + Ixz^2*(Iyy-Izz-Ixx)/(Ixx*(Ixx*Izz-Ixz^2)))*q; 
dqdp = (Izz-Ixx)*r/Iyy - 2*Ixz*p/Iyy; 
dqdq = 0; 
dqdr = (Izz-Ixx)*p/Iyy + 2*Ixz*r/Iyy; 
drdp = (Ixx^2-Ixx*Iyy+Ixz^2)/(Ixx*Izz-Ixz^2)*q; 
drdq = (Ixz*(Iyy-Izz-Ixx)*r + (Ixx^2-Ixx*Iyy+Ixz^2)*p)/(Ixx*Izz-Ixz^2); 

131 
 
drdr = Ixz*(Iyy-Izz-Ixx)/(Ixx*Izz-Ixz^2)*q; 
 
om = (xkAdiagzero(10,1)/81.04)*(2*3.14/60);  // NP is rpm, om is rad/sec 
domdNP = (2*3.14/60)/81.04; 
 
F01 = the0*(1/3 + mu^2/2) + mu/2*(the1sw + pw/2) + (muz/2 - lam0/2) + thetw*(1+mu^2)/4; 
F2c1 = -mu*(the1sw + beta1cw + (pw-lam1sw)/2 + mu*(the0 + thetw/2))/2; 
F1c1 = (alphacw + the1cw)/3 - mu*beta0/2; 
F1s1 = (alphasw + the1sw)/3 + mu*(the0 + muz -lam0 + 2*thetw/3); 
F2s1 = mu*(the1cw - beta1sw + (qw-lam1cw)/2 - mu*beta0)/2; 
F1c2 = -2*beta0*mu*(muz-lam0-4*mu*beta1cw/3) + (muz-lam0-4*mu*beta1cw/3)*alphacw - 
mu*beta1sw*alphasw/4 + the0*(alphacw/3-mu*(beta0+mu*beta1sw/2)/2) + thetw*(alphacw/4-
mu*(beta0/3+mu*beta1sw/8)) + the1cw*((muz-lam0)/2+mu*((alphasw-beta1cw)/2-beta1cw)/4) + 
mu*the1sw*((alphacw-beta1sw)/2-beta1sw-mu*beta0)/4; 
F1s2 = mu^2*beta0*beta1sw/2 + (muz-lam0-mu*beta1cw/4)*alphasw - mu*beta1sw*alphacw/4 + 
the0*(alphasw/3+mu*(muz-lam0)-mu^2*beta1cw/4) + thetw*(alphasw/4+mu*(muz-lam0-
beta1cw*mu/4)/2) + the1sw*((muz-lam0)/2+mu*(3*(alphasw-beta1cw)/8+beta1cw/4)) + 
mu*the1cw*((alphacw-beta1sw)/2-beta1sw-mu*beta0)/4; 
Cx = (F01/2 + F2c1/4)*beta1cw + F1c1*beta0/2 + F2s1*beta1sw/4 + F1s2/2;  // 2Cx/a0s 
Cy = (F01/2 + F2c1/4)*beta1sw - F1s1*beta0/2 - F2s1*beta1cw/4 + F1c2/2;  // 2Cy/a0s 
Cz = -F01;  // 2Cz/a0s 
dLdNP = 2*hR*rho*3.14*MRR^4*om*Cy*domdNP; 
dNdNP = -0.4461*Ip*-2*xcg*rho*3.14*MRR^4*om*Cy*domdNP; 
 
duddNP = (1/Ma)*((rho*3.14*MRR^4*a0*s)*(Cx*cos(gs)-Cz*sin(gs))*om*domdNP); 
dvddNP = (1/Ma)*((rho*3.14*MRR^4*a0*s)*Cy*om*domdNP); 
dwddNP = (1/Ma)*((rho*3.14*MRR^4*a0*s)*(Cx*sin(gs)+Cz*cos(gs))*om*domdNP); 
dpddNG = 0.3128*Ip*Ixx*Izz/(Ixx*(Ixx*Izz-Ixz^2)); 
dpddNP = Ixx*Izz*dLdNP/(Ixx*(Ixx*Izz-Ixz^2)) + Ixx*Ixz*dNdNP/(Ixx*(Ixx*Izz-Ixz^2)); 
dqddNP = (1/Iyy)*(xcg*rho*3.14*MRR^4*a0*s*(Cx*sin(gs)+Cz*cos(gs)) - 
hR*rho*3.14*MRR^4*a0*s*(Cx*cos(gs)-Cz*sin(gs)) + lTPxCG*rho*MRR^2*CZTPval)*om*domdNP; 
drddNG = 0.3128*Ip*Ixx/(Ixx*Izz-Ixz^2); 
drddNP =Ixz*dLdNP/(Ixx*Izz-Ixz^2) + Ixx*dNdNP/(Ixx*Izz-Ixz^2); 
dNPddu = Ibeta*b*LockNum*om^2/(IR*a0*s*domdNP)*(-k*CT*tan(x(8)-
3*3.14/180)/(om*MRR)+1.15*CD0*s*u/(om*MRR)^2+1.5*fA*u^2/(om*MRR)^3; 
dNPddtheta = Ibeta*b*LockNum*om^2/(IR*a0*s*domdNP))*(-k*CT*u/(om*MRR*cos(x(8)-
3*3.14/180)^2); 
dNPddNG = Ibeta*b*LockNum*om^2*0.6256*Ip/(IR*a0*s*domdNP*rho*(om*Mrr)^2*3.14*MRR^3*a0*s); 
dNPddNP = (Ibeta*b*LockNum/(IR*a0*s))*(k*CT*(2*lam0*om-x(1)*tan(x(8)-
3*3.14/180)/MRR))+CD0*s*om/4-0.5*fA*u^3/(om^2*MRR^3))-
0.4461*Ip*Ibeta*LockNum*b/(IR*rho*MRR^5*3.14*a0*s); 
 
A11 = 0; 
A12 = r; 
A13 = -q; 
A14 = 0; 
A15 = -w; 
A16 = v; 
A17 = 0; 
A18 = -grav*cos(theta); 
A19 = 0; 
A110 = duddNP; 
A21 = -r; 
A22 = 0; 
A23 = p; 
A24 = w; 
A25 = 0; 
A26 = -u; 
A27 = grav*cos(phi)*cos(theta); 
A28 = -grav*sin(phi)*sin(theta); 
A29 = 0; 
A210 = dvddNP; 
A31 = q; 
A32 = -p; 
A33 = 0; 
A34 = -v; 
A35 = u; 
A36 = 0; 
A37 = -grav*sin(phi)*cos(theta); 

132 
 
A38 = -grav*cos(phi)*sin(theta); 
A39 = 0; 
A310 = dwddNP; 
A41 = 0; 
A42 = 0; 
A43 = 0; 
A44 = dpdp; 
A45 = dpdq; 
A46 = dpdr; 
A47 = 0; 
A48 = 0; 
A49 = dpddNG; 
A410 = dpddNP; 
A51 = 0; 
A52 = 0; 
A53 = 0; 
A54 = dqdp; 
A55 = dqdq; 
A56 = dqdr; 
A57 = 0; 
A58 = 0; 
A59 = 0; 
A510 = dqddNP; 
A61 = 0; 
A62 = 0; 
A63 = 0; 
A64 = drdp; 
A65 = drdq; 
A66 = drdr; 
A67 = 0; 
A68 = 0; 
A69 = drddNG; 
A610 = drddNP; 
A71 = 0; 
A72 = 0; 
A73 = 0; 
A74 = 1; 
A75 = sin(phi)*tan(theta); 
A76 = cos(phi)*tan(theta); 
A77 = (q*cos(phi)-r*sin(phi))*tan(theta); 
A78 = (q*sin(phi)+r*cos(phi))/(cos(theta)*cos(theta)); 
A79 = 0; 
A710 = 0; 
A81 = 0; 
A82 = 0; 
A83 = 0; 
A84 = 0; 
A85 = cos(phi); 
A86 = -sin(phi); 
A87 = -(q*sin(phi)-r*cos(phi)); 
A88 = 0; 
A89 = 0; 
A810 = 0; 
A91 = 0; 
A92 = 0; 
A93 = 0; 
A94 = 0; 
A95 = 0; 
A96 = 0; 
A97 = 0; 
A98 = 0; 
A99 = 0;  // set to zero to remove load from engine 
A910 = 0; 
A101 = dNPddu; 
A102 = 0; 
A103 = 0; 
A104 = 0; 
A105 = 0; 
A106 = 0; 

133 
 
A107 = 0; 
A108 = dNPddtheta; 
A109 = dNPddNG; 
A1010 = 0;  // set to zero to remove load from engine 
 
AtotAdiagzero = [A11 A12 A13 A14 A15 A16 A17 A18 A19 A110; 
        A21 A22 A23 A24 A25 A26 A27 A28 A29 A210; 
        A31 A32 A33 A34 A35 A36 A37 A38 A39 A310; 
        A41 A42 A43 A44 A45 A46 A47 A48 A49 A410; 
        A51 A52 A53 A54 A55 A56 A57 A58 A59 A510; 
        A61 A62 A63 A64 A65 A66 A67 A68 A69 A610; 
        A71 A72 A73 A74 A75 A76 A77 A78 A79 A710; 
        A81 A82 A83 A84 A85 A86 A87 A88 A89 A810; 
        A91 A92 A93 A94 A95 A96 A97 A98 A99 A910; 
        A101 A102 A103 A104 A105 A106 A107 A108 A109 A1010]; 
 
I1010 = [1 0 0 0 0 0 0 0 0 0; 
         0 1 0 0 0 0 0 0 0 0; 
         0 0 1 0 0 0 0 0 0 0; 
         0 0 0 1 0 0 0 0 0 0; 
         0 0 0 0 1 0 0 0 0 0; 
         0 0 0 0 0 1 0 0 0 0; 
         0 0 0 0 0 0 1 0 0 0; 
         0 0 0 0 0 0 0 1 0 0; 
         0 0 0 0 0 0 0 0 1 0; 
         0 0 0 0 0 0 0 0 0 1]; 
 
//***************** G*u(k) information *****************// 
 
dcxdt0 = beta1cw/3 + (pw-lam1sw)/6 + mu*(muz-lam0)/2; 
dcxdt1cw = (1/6-mu^2/8)*beta0 + mu*(qw-lam1cw)/16; 
dcxdt1sw = mu*beta1cw/4 + (muz-lam0)/4 + 3*mu*(pw-lam1sw)/16; 
dcydt0 = (qw-lam1cw)/6 - 3*mu*beta0/8; 
dcydt1cw = -mu*beta1cw/4 + (muz-lam0)/4 + mu*(pw-lam1sw)/16; 
dcydt1sw = -(1/6+mu^2/8)*beta0 + mu*(qw-lam1cw)/16; 
dczdt0 = -1/3 - mu^2/2; 
dczdt1cw = 0; 
dczdt1sw = -mu/2; 
 
common = 0.5*rho*(om*MRR)^2*3.14*MRR^2*a0*s; 
dudt0 = (1/Ma)*common*(dcxdt0*cos(gs)-dczdt0*sin(gs)); 
dudt1cw = (1/Ma)*common*(dcxdt1cw*cos(gs)-dczdt1cw*sin(gs)); 
dudt1sw = (1/Ma)*common*(dcxdt1sw*cos(gs)-dczdt1sw*sin(gs)); 
dvdt0 = (1/Ma)*common*dcydt0; 
dvdt1cw = (1/Ma)*common*dcydt1cw; 
dvdt1sw = (1/Ma)*common*dcydt1sw; 
dwdt0 = (1/Ma)*common*(dcxdt0*sin(gs)+dczdt0*cos(gs)); 
dwdt1cw = (1/Ma)*common*(dcxdt1cw*sin(gs)+dczdt1cw*cos(gs)); 
dwdt1sw = (1/Ma)*common*(dcxdt1sw*sin(gs)+dczdt1sw*cos(gs)); 
dpdt0 = (common/(Ixx*Izz-Ixz^2))*(Izz*hR-Ixz*xcg)*dcydt0; 
dpdt1cw = (common/(Ixx*Izz-Ixz^2))*(Izz*hR-Ixz*xcg)*dcydt1cw; 
dpdt1sw = (common/(Ixx*Izz-Ixz^2))*(Izz*hR-Ixz*xcg)*dcydt1sw; 
dpdwf = 16630*Ip*Ixx*Ixz/(Ixx*(Ixx*Izz-Ixz^2)); 
dqdt0 = (common/Iyy)*(xcg*(dcxdt0*sin(gs)+dczdt0*cos(gs))-hR*(dcxdt0*cos(gs)-
dczdt0*sin(gs))); 
dqdt1cw = (common/Iyy)*(xcg*(dcxdt1cw*sin(gs)+dczdt1cw*cos(gs))-hR*(dcxdt1cw*cos(gs)-
dczdt1cw*sin(gs))); 
dqdt1sw = (common/Iyy)*(xcg*(dcxdt1sw*sin(gs)+dczdt1sw*cos(gs))-hR*(dcxdt1sw*cos(gs)-
dczdt1sw*sin(gs))); 
drdt0 = common/(Ixx*Izz-Ixz^2)*(Ixz*hR-Ixx*xcg)*dcydt0; 
drdt1cw = common/(Ixx*Izz-Ixz^2)*(Ixz*hR-Ixx*xcg)*dcydt1cw; 
drdt1sw = common/(Ixx*Izz-Ixz^2)*(Ixz*hR-Ixx*xcg)*dcydt1sw; 
drdwf = 16630*Ip*Ixx/(Ixx*Izz-Ixz^2); 
dNPdwf = Ibeta*b*LockNum*om^2*33260*Ip/(IR*a0*s*rho*om^2*MRR^5*3.14*a0*s*domdNP); 
 
B11 = dudt0; 
B12 = dudt1cw; 
B13 = dudt1sw; 
B14 = 0; 

134 
 
B21 = dvdt0; 
B22 = dvdt1cw; 
B23 = dvdt1sw; 
B24 = 0; 
B31 = dwdt0; 
B32 = dwdt1cw; 
B33 = dwdt1sw; 
B34 = 0; 
B41 = dpdt0; 
B42 = dpdt1cw; 
B43 = dpdt1sw; 
B44 = dpdwf; 
B51 = dqdt0; 
B52 = dqdt1cw; 
B53 = dqdt1sw; 
B54 = 0; 
B61 = drdt0; 
B62 = drdt1cw; 
B63 = drdt1sw; 
B64 = drdwf; 
B71 = 0; 
B72 = 0; 
B73 = 0; 
B74 = 0; 
B81 = 0; 
B82 = 0; 
B83 = 0; 
B84 = 0; 
B91 = 0; 
B92 = 0; 
B93 = 0; 
B94 = 149400; 
B101 = 0; 
B102 = 0; 
B103 = 0; 
B104 = dNPdwf; 
 
BtotAdiagzero = [B11 B12 B13 B14; 
 
B21 B22 B23 B24; 
 
B31 B32 B33 B34; 
 
B41 B42 B43 B44; 
 
B51 B52 B53 B54; 
 
B61 B62 B63 B64; 
 
B71 B72 B73 B74; 
 
B81 B82 B83 B84; 
 
B91 B92 B93 B94; 
 
B101 B102 B103 B104]; 
 
//***************** xkp1 Calculation *****************// 
FAdiagzero = I1010 + dt*AtotAdiagzero; 
GAdiagzero = dt*BtotAdiagzero; 
 
wkAdiagzero = wk0Adiagzero - dt*FAdiagzero*xkm1Adiagzero – 
dt*BtotAdiagzero*ucontrolkm1Adiagzero; 
xkp1Adiagzero = FAdiagzero*xkAdiagzero + GAdiagzero*ucontrolkAdiagzero + wkAdiagzero; 
wkAdiagzero = xkp1Adiagzero - xkAdiagzero0; 
 
QkAdiagzero = [wk(1,1)^2 0 0 0 0 0 0 0 0 0; 
      0 wkAdiagzero(2,1)^2 0 0 0 0 0 0 0 0; 
      0 0 wkAdiagzero(3,1)^2 0 0 0 0 0 0 0; 
      0 0 0 wkAdiagzero(4,1)^2 0 0 0 0 0 0; 
      0 0 0 0 wkAdiagzero(5,1)^2 0 0 0 0 0; 
      0 0 0 0 0 wkAdiagzero(6,1)^2 0 0 0 0; 
      0 0 0 0 0 0 wkAdiagzero(7,1)^2 0 0 0; 
      0 0 0 0 0 0 0 wkAdiagzero(8,1)^2 0 0; 
      0 0 0 0 0 0 0 0 wkAdiagzero(9,1)^2 0; 
      0 0 0 0 0 0 0 0 0 wkAdiagzero(10,1)^2]; 
 
QkAdiagzeroNEW = [wkAdiagzero(9,1)^2 0;0 wkAdiagzero(10,1)^2]; 

135 
 
 
if(counterAdiagzero==1) 
 
alpha = 10; 
 
PkAdiagzero = alpha^2*QkAdiagzero;  //Durrant-Whyte Reference states initial Q * 
alpha^2 with alpha about 10 is a good first guess 
 
               //The 100 can drop significantly lower if need be 
 
PkAdiagzeroNEW = alpha^2*QkAdiagzeroNEW;  //Durrant-Whyte Reference states initial 
Q * alpha^2 with alpha about 10 is a good first guess 
 
               //The 100 can drop significantly lower if need be 
end 
 
Pkp1Adiagzero = AtotAdiagzero*PkAdiagzero*AtotAdiagzero' + QkAdiagzero;  // Sioris paper 
Eq 4.7-43 
AtotAdiagzeroNEW = [A99 A910;A109 A1010]; 
Pkp1AdiagzeroNEW = AtotAdiagzeroNEW*PkAdiagzeroNEW*AtotAdiagzeroNEW' + QkAdiagzeroNEW;  
// Sioris paper Eq 4.7-43 
 
//***************** zkp1 Calculations *****************// 
 
HtotAdiagzero = [1 0 0 0 0 0 0 0 0 0; 
        0 0 1 0 0 0 0 0 0 0; 
        0 0 0 0 0 0 1 0 0 0; 
        0 0 0 0 0 0 0 1 0 0; 
 
0 0 0 0 0 0 0 0 1 0; 
 
0 0 0 0 0 0 0 0 0 1]; 
HtotAdiagzeroNEW = [1 0;0 1]; 
 
zkp1Adiagzero = HtotAdiagzero*xkp1Adiagzero + vkAdiagzero; // vk is previously defined 
vkp1Adiagzero = zkp1Adiagzero - zkAdiagzero; 
NGAdiagzero NPAdiagzero]'; 
 
RkAdiagzero = [vkp1Adiagzero(1,1)^2 0 0 0 0 0; 
      0 vkp1Adiagzero(2,1)^2 0 0 0 0; 
      0 0 vkp1Adiagzero(3,1)^2 0 0 0; 
      0 0 0 vkp1Adiagzero(4,1)^2 0 0; 
      0 0 0 0 vkp1Adiagzero(5,1)^2+0.00000000000000000001 0; 
      0 0 0 0 0 vkp1Adiagzero(6,1)^2+0.00000000000000000001];  // weights found in other 
scripts from rev0 
 
RkAdiagzeroNEW = [vkp1Adiagzero(5,1)^2 0;0 vkp1Adiagzero(6,1)^2]; 
KkAdiagzero = Pkp1Adiagzero*HtotAdiagzero'*inv(HtotAdiagzero*Pkp1Adiagzero*HtotAdiagzero' 
+ RkAdiagzero); 
xkp1kp1Adiagzero = xkp1Adiagzero + KkAdiagzero*(zkp1Adiagzero - 
HtotAdiagzero*xkp1Adiagzero); 
Pkp1kp1Adiagzero = inv(inv(Pkp1Adiagzero) + 
HtotAdiagzero'*inv(RkAdiagzero)*HtotAdiagzero); 
 
SkAdiagzero = HtotAdiagzeroNEW*Pkp1AdiagzeroNEW*HtotAdiagzeroNEW' + RkAdiagzeroNEW; 
rkatp1Adiagzero = zkp1Adiagzero - HtotAdiagzero*xkp1Adiagzero; 
rkatp1AdiagzeroNEW = [rkatp1Adiagzero(5,1);rkatp1Adiagzero(6,1)]; 
rkatp1AdiagzeroNEW = 1e-10*rkatp1AdiagzeroNEW;  
detSkAdiagzero = det(SkAdiagzero); 
PROBzkxk1Adiagzero = (1/((2*3.14)^(1/2)*detSkAdiagzero^0.5))*exp((-
0.5)*rkatp1AdiagzeroNEW'*inv(SkAdiagzero)*rkatp1AdiagzeroNEW); 
 
// Reset variables 
xkm1Adiagzero = xkAdiagzero; 
xkAdiagzero = xkp1kp1Adiagzero; 
zkAdiagzero = zkp1Adiagzero; 
wk0Adiagzero = wkAdiagzero; 
vkAdiagzero = vkp1Adiagzero; 
PkAdiagzero = Pkp1kp1Adiagzero; 
 
uAdiagzero = xkp1kp1Adiagzero(1,1); 
vAdiagzero = xkp1kp1Adiagzero(2,1); 
wAdiagzero = xkp1kp1Adiagzero(3,1); 
pAdiagzero = xkp1kp1Adiagzero(4,1); 
qAdiagzero = xkp1kp1Adiagzero(5,1); 
rAdiagzero = xkp1kp1Adiagzero(6,1); 

136 
 
phiAdiagzero = xkp1kp1Adiagzero(7,1); 
thetaAdiagzero = xkp1kp1Adiagzero(8,1); 
NGAdiagzero = xkp1kp1Adiagzero(9,1); 
NPAdiagzero = xkp1kp1Adiagzero(10,1); 
 
//*********** End of Probability Calc ***********// 
 
 
 
 
********** Bayesian Estimation for Engine Failure Model ********** 
//***************** F*x(k-1) information ******************// 
 
if(counterwfzero == 1) 
 
wk0wfzeroNEW = [0 0]'; 
 
wk0wfzero = [0 0 0 0 0 0 0 0 0 0]'; 
 
vkwfzeroNEW = [0 0]';  // Htot is 6x10, vk is 6x1 
 
vkwfzero = [0 0 0 0 0 0]'; 
 
xkm1wfzero = [ukm1wfzero vkm1wfzero wkm1wfzero pkm1wfzero qkm1wfzero rkm1wfzero 
phikm1wfzero thetakm1wfzero NGkm1wfzero NPkm1wfzero]'; // NG and NP are rpm - input rpm 
 
xkwfzero = [uwfzero vwfzero wwfzero pwfzero qwfzero rwfzero phiwfzero thetawfzero 
NGwfzero NPwfzero]'; 
 
xkwfzero0 = xkwfzero; 
 
zkwfzero = [uwfzero wwfzero phiwfzero thetawfzero NGwfzero NPwfzero]'; 
 
zkwfzero0 = zkwfzero; 
 
ucontrolkm1wfzero = [the0km1 the1cwkm1 the1swkm1 wfkm1]'; 
 
ucontrolkwfzero = [the0 the1cw the1sw wf]'; 
end 
ucontrolkm1wfzero(4,1) = 0;   
ucontrolkwfzero(4,1) = 0; 
 
dpdp = (Ixz*(Ixx^2-Ixx*Iyy+Ixz^2)/(Ixx*(Ixx*Izz-Ixz^2))+Ixz/Ixx)*q; 
dpdq = ((Iyy-Izz)*r+Ixz*p)/Ixx + (Ixz^2*(Iyy-Izz-Ixx)*r+Ixz*(Ixx^2-
Ixx*Iyy+Ixz^2)*p)/(Ixx*(Ixx*Izz-Ixz^2)); 
dpdr = ((Iyy-Izz)/Ixx + Ixz^2*(Iyy-Izz-Ixx)/(Ixx*(Ixx*Izz-Ixz^2)))*q; 
dqdp = (Izz-Ixx)*r/Iyy - 2*Ixz*p/Iyy; 
dqdq = 0; 
dqdr = (Izz-Ixx)*p/Iyy + 2*Ixz*r/Iyy; 
drdp = (Ixx^2-Ixx*Iyy+Ixz^2)/(Ixx*Izz-Ixz^2)*q; 
drdq = (Ixz*(Iyy-Izz-Ixx)*r + (Ixx^2-Ixx*Iyy+Ixz^2)*p)/(Ixx*Izz-Ixz^2); 
drdr = Ixz*(Iyy-Izz-Ixx)/(Ixx*Izz-Ixz^2)*q; 
 
om = (xkwfzero(10,1)/81.04)*(2*3.14/60);  // NP is rpm, om is rad/sec 
domdNP = (2*3.14/60)/81.04; 
 
F01 = the0*(1/3 + mu^2/2) + mu/2*(the1sw + pw/2) + (muz/2 - lam0/2) + thetw*(1+mu^2)/4; 
F2c1 = -mu*(the1sw + beta1cw + (pw-lam1sw)/2 + mu*(the0 + thetw/2))/2; 
F1c1 = (alphacw + the1cw)/3 - mu*beta0/2; 
F1s1 = (alphasw + the1sw)/3 + mu*(the0 + muz -lam0 + 2*thetw/3); 
F2s1 = mu*(the1cw - beta1sw + (qw-lam1cw)/2 - mu*beta0)/2; 
F1c2 = -2*beta0*mu*(muz-lam0-4*mu*beta1cw/3) + (muz-lam0-4*mu*beta1cw/3)*alphacw - 
mu*beta1sw*alphasw/4 + the0*(alphacw/3-mu*(beta0+mu*beta1sw/2)/2) + thetw*(alphacw/4-
mu*(beta0/3+mu*beta1sw/8)) + the1cw*((muz-lam0)/2+mu*((alphasw-beta1cw)/2-beta1cw)/4) + 
mu*the1sw*((alphacw-beta1sw)/2-beta1sw-mu*beta0)/4; 
F1s2 = mu^2*beta0*beta1sw/2 + (muz-lam0-mu*beta1cw/4)*alphasw - mu*beta1sw*alphacw/4 + 
the0*(alphasw/3+mu*(muz-lam0)-mu^2*beta1cw/4) + thetw*(alphasw/4+mu*(muz-lam0-
beta1cw*mu/4)/2) + the1sw*((muz-lam0)/2+mu*(3*(alphasw-beta1cw)/8+beta1cw/4)) + 
mu*the1cw*((alphacw-beta1sw)/2-beta1sw-mu*beta0)/4; 
Cx = (F01/2 + F2c1/4)*beta1cw + F1c1*beta0/2 + F2s1*beta1sw/4 + F1s2/2;  // 2Cx/a0s 
Cy = (F01/2 + F2c1/4)*beta1sw - F1s1*beta0/2 - F2s1*beta1cw/4 + F1c2/2;  // 2Cy/a0s 
Cz = -F01;  // 2Cz/a0s 
dLdNP = 2*hR*rho*3.14*MRR^4*om*Cy*domdNP; 
dNdNP = -0.4461*Ip*-2*xcg*rho*3.14*MRR^4*om*Cy*domdNP; 
 
duddNP = (1/Ma)*((rho*3.14*MRR^4*a0*s)*(Cx*cos(gs)-Cz*sin(gs))*om*domdNP); 
dvddNP = (1/Ma)*((rho*3.14*MRR^4*a0*s)*Cy*om*domdNP); 
dwddNP = (1/Ma)*((rho*3.14*MRR^4*a0*s)*(Cx*sin(gs)+Cz*cos(gs))*om*domdNP); 

137 
 
dpddNG = 0.3128*Ip*Ixx*Izz/(Ixx*(Ixx*Izz-Ixz^2)); 
dpddNP = Ixx*Izz*dLdNP/(Ixx*(Ixx*Izz-Ixz^2)) + Ixx*Ixz*dNdNP/(Ixx*(Ixx*Izz-Ixz^2)); 
dpddNP = ((Ixz^2+(Ixx*Izz-Ixz^2))/(Ixx*(Ixx*Izz-Ixz^2))*hR*rho*3.14*MRR^4*a0*s*Cy + 
Ixz/(Ixx*Izz-Ixz^2)*rho*3.14*MRR^4*a0*s*(MRR*CQval-xcg*Cy))*om*domdNP; 
dqddNP = (1/Iyy)*(xcg*rho*3.14*MRR^4*a0*s*(Cx*sin(gs)+Cz*cos(gs)) - 
hR*rho*3.14*MRR^4*a0*s*(Cx*cos(gs)-Cz*sin(gs)) + lTPxCG*rho*MRR^2*CZTPval)*om*domdNP; 
drddNG = 0.3128*Ip*Ixx/(Ixx*Izz-Ixz^2); 
drddNP =Ixz*dLdNP/(Ixx*Izz-Ixz^2) + Ixx*dNdNP/(Ixx*Izz-Ixz^2); 
dNPddu = Ibeta*b*LockNum*om^2/(IR*a0*s*domdNP)*(-k*CT*tan(x(8)-
3*3.14/180)/(om*MRR)+1.15*CD0*s*u/(om*MRR)^2+1.5*fA*u^2/(om*MRR)^3; 
dNPddtheta = Ibeta*b*LockNum*om^2/(IR*a0*s*domdNP))*(-k*CT*u/(om*MRR*cos(x(8)-
3*3.14/180)^2); 
dNPddNG = Ibeta*b*LockNum*om^2*0.6256*Ip/(IR*a0*s*domdNP*rho*(om*Mrr)^2*3.14*MRR^3*a0*s); 
dNPddNP = (Ibeta*b*LockNum/(IR*a0*s))*(k*CT*(2*lam0*om-x(1)*tan(x(8)-
3*3.14/180)/MRR))+CD0*s*om/4-0.5*fA*u^3/(om^2*MRR^3))-
0.4461*Ip*Ibeta*LockNum*b/(IR*rho*MRR^5*3.14*a0*s); 
 
A11 = 0; 
A12 = r; 
A13 = -q; 
A14 = 0; 
A15 = -w; 
A16 = v; 
A17 = 0; 
A18 = -grav*cos(theta); 
A19 = 0; 
A110 = duddNP; 
A21 = -r; 
A22 = 0; 
A23 = p; 
A24 = w; 
A25 = 0; 
A26 = -u; 
A27 = grav*cos(phi)*cos(theta); 
A28 = -grav*sin(phi)*sin(theta); 
A29 = 0; 
A210 = dvddNP; 
A31 = q; 
A32 = -p; 
A33 = 0; 
A34 = -v; 
A35 = u; 
A36 = 0; 
A37 = -grav*sin(phi)*cos(theta); 
A38 = -grav*cos(phi)*sin(theta); 
A39 = 0; 
A310 = dwddNP; 
A41 = 0; 
A42 = 0; 
A43 = 0; 
A44 = dpdp; 
A45 = dpdq; 
A46 = dpdr; 
A47 = 0; 
A48 = 0; 
A49 = dpddNG; 
A410 = dpddNP; 
A51 = 0; 
A52 = 0; 
A53 = 0; 
A54 = dqdp; 
A55 = dqdq; 
A56 = dqdr; 
A57 = 0; 
A58 = 0; 
A59 = 0; 
A510 = dqddNP; 
A61 = 0; 
A62 = 0; 

138 
 
A63 = 0; 
A64 = drdp; 
A65 = drdq; 
A66 = drdr; 
A67 = 0; 
A68 = 0; 
A69 = drddNG; 
A610 = drddNP; 
A71 = 0; 
A72 = 0; 
A73 = 0; 
A74 = 1; 
A75 = sin(phi)*tan(theta); 
A76 = cos(phi)*tan(theta); 
A77 = (q*cos(phi)-r*sin(phi))*tan(theta); 
A78 = (q*sin(phi)+r*cos(phi))/(cos(theta)*cos(theta)); 
A79 = 0; 
A710 = 0; 
A81 = 0; 
A82 = 0; 
A83 = 0; 
A84 = 0; 
A85 = cos(phi); 
A86 = -sin(phi); 
A87 = -(q*sin(phi)-r*cos(phi)); 
A88 = 0; 
A89 = 0; 
A810 = 0; 
A91 = 0; 
A92 = 0; 
A93 = 0; 
A94 = 0; 
A95 = 0; 
A96 = 0; 
A97 = 0; 
A98 = 0; 
A99 = -2.233; 
A910 = 0; 
A101 = dNPddu; 
A102 = 0; 
A103 = 0; 
A104 = 0; 
A105 = 0; 
A106 = 0; 
A107 = 0; 
A108 = dNPddtheta; 
A109 = dNPddNG; 
A1010 = dNPddNP; 
 
Atotwfzero = [A11 A12 A13 A14 A15 A16 A17 A18 A19 A110; 
        A21 A22 A23 A24 A25 A26 A27 A28 A29 A210; 
        A31 A32 A33 A34 A35 A36 A37 A38 A39 A310; 
        A41 A42 A43 A44 A45 A46 A47 A48 A49 A410; 
        A51 A52 A53 A54 A55 A56 A57 A58 A59 A510; 
        A61 A62 A63 A64 A65 A66 A67 A68 A69 A610; 
        A71 A72 A73 A74 A75 A76 A77 A78 A79 A710; 
        A81 A82 A83 A84 A85 A86 A87 A88 A89 A810; 
        A91 A92 A93 A94 A95 A96 A97 A98 A99 A910; 
        A101 A102 A103 A104 A105 A106 A107 A108 A109 A1010]; 
 
I1010 = [1 0 0 0 0 0 0 0 0 0; 
         0 1 0 0 0 0 0 0 0 0; 
         0 0 1 0 0 0 0 0 0 0; 
         0 0 0 1 0 0 0 0 0 0; 
         0 0 0 0 1 0 0 0 0 0; 
         0 0 0 0 0 1 0 0 0 0; 
         0 0 0 0 0 0 1 0 0 0; 
         0 0 0 0 0 0 0 1 0 0; 
         0 0 0 0 0 0 0 0 1 0; 

139 
 
         0 0 0 0 0 0 0 0 0 1]; 
 
//***************** G*u(k) information *****************// 
 
dcxdt0 = beta1cw/3 + (pw-lam1sw)/6 + mu*(muz-lam0)/2; 
dcxdt1cw = (1/6-mu^2/8)*beta0 + mu*(qw-lam1cw)/16; 
dcxdt1sw = mu*beta1cw/4 + (muz-lam0)/4 + 3*mu*(pw-lam1sw)/16; 
dcydt0 = (qw-lam1cw)/6 - 3*mu*beta0/8; 
dcydt1cw = -mu*beta1cw/4 + (muz-lam0)/4 + mu*(pw-lam1sw)/16; 
dcydt1sw = -(1/6+mu^2/8)*beta0 + mu*(qw-lam1cw)/16; 
dczdt0 = -1/3 - mu^2/2; 
dczdt1cw = 0; 
dczdt1sw = -mu/2; 
 
common = 0.5*rho*(om*MRR)^2*3.14*MRR^2*a0*s; 
dudt0 = (1/Ma)*common*(dcxdt0*cos(gs)-dczdt0*sin(gs)); 
dudt1cw = (1/Ma)*common*(dcxdt1cw*cos(gs)-dczdt1cw*sin(gs)); 
dudt1sw = (1/Ma)*common*(dcxdt1sw*cos(gs)-dczdt1sw*sin(gs)); 
dvdt0 = (1/Ma)*common*dcydt0; 
dvdt1cw = (1/Ma)*common*dcydt1cw; 
dvdt1sw = (1/Ma)*common*dcydt1sw; 
dwdt0 = (1/Ma)*common*(dcxdt0*sin(gs)+dczdt0*cos(gs)); 
dwdt1cw = (1/Ma)*common*(dcxdt1cw*sin(gs)+dczdt1cw*cos(gs)); 
dwdt1sw = (1/Ma)*common*(dcxdt1sw*sin(gs)+dczdt1sw*cos(gs)); 
dpdt0 = (common/(Ixx*Izz-Ixz^2))*(Izz*hR-Ixz*xcg)*dcydt0; 
dpdt1cw = (common/(Ixx*Izz-Ixz^2))*(Izz*hR-Ixz*xcg)*dcydt1cw; 
dpdt1sw = (common/(Ixx*Izz-Ixz^2))*(Izz*hR-Ixz*xcg)*dcydt1sw; 
dpdwf = 16630*Ip*Ixx*Ixz/(Ixx*(Ixx*Izz-Ixz^2)); 
dqdt0 = (common/Iyy)*(xcg*(dcxdt0*sin(gs)+dczdt0*cos(gs))-hR*(dcxdt0*cos(gs)-
dczdt0*sin(gs))); 
dqdt1cw = (common/Iyy)*(xcg*(dcxdt1cw*sin(gs)+dczdt1cw*cos(gs))-hR*(dcxdt1cw*cos(gs)-
dczdt1cw*sin(gs))); 
dqdt1sw = (common/Iyy)*(xcg*(dcxdt1sw*sin(gs)+dczdt1sw*cos(gs))-hR*(dcxdt1sw*cos(gs)-
dczdt1sw*sin(gs))); 
drdt0 = common/(Ixx*Izz-Ixz^2)*(Ixz*hR-Ixx*xcg)*dcydt0; 
drdt1cw = common/(Ixx*Izz-Ixz^2)*(Ixz*hR-Ixx*xcg)*dcydt1cw; 
drdt1sw = common/(Ixx*Izz-Ixz^2)*(Ixz*hR-Ixx*xcg)*dcydt1sw; 
drdwf = 16630*Ip*Ixx/(Ixx*Izz-Ixz^2); 
dNPdwf = Ibeta*b*LockNum*om^2*33260*Ip/(IR*a0*s*rho*om^2*MRR^5*3.14*a0*s*domdNP); 
 
B11 = dudt0; 
B12 = dudt1cw; 
B13 = dudt1sw; 
B14 = 0; 
B21 = dvdt0; 
B22 = dvdt1cw; 
B23 = dvdt1sw; 
B24 = 0; 
B31 = dwdt0; 
B32 = dwdt1cw; 
B33 = dwdt1sw; 
B34 = 0; 
B41 = dpdt0; 
B42 = dpdt1cw; 
B43 = dpdt1sw; 
B44 = dpdwf; 
B51 = dqdt0; 
B52 = dqdt1cw; 
B53 = dqdt1sw; 
B54 = 0; 
B61 = drdt0; 
B62 = drdt1cw; 
B63 = drdt1sw; 
B64 = drdwf; 
B71 = 0; 
B72 = 0; 
B73 = 0; 
B74 = 0; 
B81 = 0; 

140 
 
B82 = 0; 
B83 = 0; 
B84 = 0; 
B91 = 0; 
B92 = 0; 
B93 = 0; 
B94 = 149400; 
B101 = 0; 
B102 = 0; 
B103 = 0; 
B104 = dNPdwf; 
 
Btotwfzero = [B11 B12 B13 B14; 
 
B21 B22 B23 B24; 
 
B31 B32 B33 B34; 
 
B41 B42 B43 B44; 
 
B51 B52 B53 B54; 
 
B61 B62 B63 B64; 
 
B71 B72 B73 B74; 
 
B81 B82 B83 B84; 
 
B91 B92 B93 B94; 
 
B101 B102 B103 B104]; 
 
//***************** xkp1 Calculation *****************// 
Fwfzero = I1010 + dt*Atotwfzero; 
Gwfzero = dt*Btotwfzero; 
 
wkwfzero = wk0wfzero - dt*Fwfzero*xkm1wfzero - dt*Btotwfzero*ucontrolkm1wfzero;  
xkp1wfzero = Fwfzero*xkwfzero + Gwfzero*ucontrolkwfzero + wkwfzero; 
wkwfzero = xkp1wfzero - xkwfzero0; 
 
Qkwfzero = [wk(1,1)^2 0 0 0 0 0 0 0 0 0; 
      0 wkwfzero(2,1)^2 0 0 0 0 0 0 0 0; 
      0 0 wkwfzero(3,1)^2 0 0 0 0 0 0 0; 
      0 0 0 wkwfzero(4,1)^2 0 0 0 0 0 0; 
      0 0 0 0 wkwfzero(5,1)^2 0 0 0 0 0; 
      0 0 0 0 0 wkwfzero(6,1)^2 0 0 0 0; 
      0 0 0 0 0 0 wkwfzero(7,1)^2 0 0 0; 
      0 0 0 0 0 0 0 wkwfzero(8,1)^2 0 0; 
      0 0 0 0 0 0 0 0 wkwfzero(9,1)^2 0; 
      0 0 0 0 0 0 0 0 0 wkwfzero(10,1)^2]; 
 
QkwfzeroNEW = [wkwfzero(9,1)^2 0;0 wkwfzero(10,1)^2]; 
 
if(counterwfzero==1) 
 
alpha = 10; 
 
Pkwfzero = alpha^2*Qkwfzero;  //Durrant-Whyte Reference states initial Q * alpha^2 
  with alpha about 10 is a good first guess 
 
               
       //The 100 can drop significantly lower if need be 
 
PkwfzeroNEW = alpha^2*QkwfzeroNEW;  //Durrant-Whyte Reference states initial Q * 
alpha^2 with alpha about 10 is a good first guess 
 
                
 
//The 100 can drop significantly lower if need be 
end 
 
Pkp1wfzero = Atotwfzero*Pkwfzero*Atotwfzero' + Qkwfzero;  // Sioris paper Eq 4.7-43 
AtotwfzeroNEW = [A99 A910;A109 A1010]; 
Pkp1wfzeroNEW = AtotwfzeroNEW*PkwfzeroNEW*AtotwfzeroNEW' + QkwfzeroNEW;  // Sioris paper 
Eq 4.7-43 
 
//***************** zkp1 Calculations *****************// 
 
Htotwfzero = [1 0 0 0 0 0 0 0 0 0; 
        0 0 1 0 0 0 0 0 0 0; 
        0 0 0 0 0 0 1 0 0 0; 
        0 0 0 0 0 0 0 1 0 0; 
 
0 0 0 0 0 0 0 0 1 0; 
 
0 0 0 0 0 0 0 0 0 1]; 
HtotwfzeroNEW = [1 0;0 1]; 
 

141 
 
zkp1wfzero = Htotwfzero*xkp1wfzero + vkwfzero; // vk is previously defined 
vkp1wfzero = zkp1wfzero - zkwfzero; 
 
Rkwfzero = [vkp1wfzero(1,1)^2 0 0 0 0 0; 
      0 vkp1wfzero(2,1)^2 0 0 0 0; 
      0 0 vkp1wfzero(3,1)^2 0 0 0; 
      0 0 0 vkp1wfzero(4,1)^2 0 0; 
      0 0 0 0 vkp1wfzero(5,1)^2+0.00000000000000000001 0; 
      0 0 0 0 0 vkp1wfzero(6,1)^2+0.00000000000000000001];  // weights found in other 
scripts from rev0 
 
RkwfzeroNEW = [vkp1wfzero(5,1)^2 0;0 vkp1wfzero(6,1)^2]; 
Kkwfzero = Pkp1wfzero*Htotwfzero'*inv(Htotwfzero*Pkp1wfzero*Htotwfzero' + Rkwfzero); 
xkp1kp1wfzero = xkp1wfzero + Kkwfzero*(zkp1wfzero - Htotwfzero*xkp1wfzero); 
Pkp1kp1wfzero = inv(inv(Pkp1wfzero) + Htotwfzero'*inv(Rkwfzero)*Htotwfzero); 
 
Skwfzero = HtotwfzeroNEW*Pkp1wfzeroNEW*HtotwfzeroNEW' + RkwfzeroNEW; 
rkatp1wfzero = zkp1wfzero - Htotwfzero*xkp1wfzero; 
rkatp1wfzeroNEW = [rkatp1wfzero(5,1);rkatp1wfzero(6,1)]; 
rkatp1wfzeroNEW = 1e-8*rkatp1wfzeroNEW;  
detSkwfzero = det(Skwfzero); 
PROBzkxk1wfzero = (1/((2*3.14)^(1/2)*detSkwfzero^0.5))*exp((0.5)*rkatp1wfzeroNEW'* 
inv(Skwfzero)*rkatp1wfzeroNEW); 
 
// Reset variables 
xkm1wfzero = xkwfzero; 
xkwfzero = xkp1kp1wfzero; 
zkwfzero = zkp1wfzero; 
wk0wfzero = wkwfzero; 
vkwfzero = vkp1wfzero; 
Pkwfzero = Pkp1kp1wfzero; 
 
uwfzero = xkp1kp1wfzero(1,1); 
vwfzero = xkp1kp1wfzero(2,1); 
wwfzero = xkp1kp1wfzero(3,1); 
pwfzero = xkp1kp1wfzero(4,1); 
qwfzero = xkp1kp1wfzero(5,1); 
rwfzero = xkp1kp1wfzero(6,1); 
phiwfzero = xkp1kp1wfzero(7,1); 
thetawfzero = xkp1kp1wfzero(8,1); 
NGwfzero = xkp1kp1wfzero(9,1); 
NPwfzero = xkp1kp1wfzero(10,1); 
 
//*********** End of Probability Calc ***********// 
 
 

142 
 
 
 
 
 
 
Appendix C – VirtualPilot Command Table 
 
 
The VirtualPilot uses commanded targets for each of the 4 axes of control; 
Longitudinal Cyclic, Lateral Cyclic, Collective, and Pedals.  One feature of the 
VirtualPilot is to set the modes and targets against the simulation time scale.  The first 
plot demonstrates the input mode and target value to put a helicopter into a steady-state 
level flight.  At some initiation point, the lateral cyclic command adjusts the roll angle to 
put the aircraft in a banked turn.  The other targets remain constant.  The “Hold Inputs” 
for the first 0.3 seconds is used to zero out any errors from a simulation fresh start. 
 
 
 
Figure 59: VirtualPilot Level Flight and Banked Turn Scheme 
 
The second plot evaluates the pilot maneuvers to transition from a steady state 
level flight to an autorotation.  The first vertical line at some time is the point of the 

143 
 
engine failure.  There are two method to “fail” the engine in the simulation model.  The 
first method is to disengage the sprag clutch.  This immediately disconnects the main 
rotor and tail rotor from the driveshaft.  The second method is to roll back the throttle 
from the cockpit to simulate a 4-second fuel flow decrease.  A throttle position of 120 is 
the normal operating value.  A throttle position of 50 is the point where the aircraft with 
the provided configuration is not capable of maintaining the fuel flow required for steady 
and level flight.  For each time step, the value of (simtime – COLPhaseTime) increases 
linearly.  This reduces the throttle position for each time step.  Once the engine begins its 
failure state, a specified time later, the pilot reacts to the engine failure.  In this scenario, 
the pilot correctly reduces the collective and drives the rotor speed back to 100%.  The 
aircraft at that point is in a steady autorotation. 
 
 
Figure 60: VirtualPilot Autorotation Scheme 
 

