Computational 
Epigenomics and 
Epitranscriptomics
Pedro H. Oliveira Editor
Methods in 
Molecular Biology   2624

M E T H O D S I N M O L E C U L A R B I O L O G Y
Series Editor
John M. Walker
School of Life and Medical Sciences
University of Hertfordshire
Hatfield, Hertfordshire, UK
For further volumes:
http://www.springer.com/series/7651

For over 35 years, biological scientists have come to rely on the research protocols and
methodologies in the critically acclaimed Methods in Molecular Biology series. The series was
the ﬁrst to introduce the step-by-step protocols approach that has become the standard in all
biomedical protocol publishing. Each protocol is provided in readily-reproducible step-by-
step fashion, opening with an introductory overview, a list of the materials and reagents
needed to complete the experiment, and followed by a detailed procedure that is supported
with a helpful notes section offering tips and tricks of the trade as well as troubleshooting
advice. These hallmark features were introduced by series editor Dr. John Walker and
constitute the key ingredient in each and every volume of the Methods in Molecular Biology
series. Tested and trusted, comprehensive and reliable, all protocols from the series are
indexed in PubMed.

Computational Epigenomics
and Epitranscriptomics
Edited by
Pedro H. Oliveira
Genoscope, Évry, France

Editor
Pedro H. Oliveira
Genoscope
E´ vry, France
ISSN 1064-3745
ISSN 1940-6029
(electronic)
Methods in Molecular Biology
ISBN 978-1-0716-2961-1
ISBN 978-1-0716-2962-8
(eBook)
https://doi.org/10.1007/978-1-0716-2962-8
© The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Science+Business Media, LLC, part
of Springer Nature 2023
This work is subject to copyright. All rights are solely and exclusively licensed by the Publisher, whether the whole or part
of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations, recitation,
broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or information storage and
retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter
developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication does not imply,
even in the absence of a speciﬁc statement, that such names are exempt from the relevant protective laws and regulations
and therefore free for general use.
The publisher, the authors, and the editors are safe to assume that the advice and information in this book are believed to
be true and accurate at the date of publication. Neither the publisher nor the authors or the editors give a warranty,
expressed or implied, with respect to the material contained herein or for any errors or omissions that may have been
made. The publisher remains neutral with regard to jurisdictional claims in published maps and institutional afﬁliations.
This Humana imprint is published by the registered company Springer Science+Business Media, LLC, part of Springer
Nature.
The registered company address is: 1 New York Plaza, New York, NY 10004, U.S.A.

Preface
Nucleic acids (DNA and RNA) are key repositories of genetic information, and their primary
sequence of four canonical nucleobases (A, C, G, T/U) in genomes and transcriptomes
deﬁnes the genetic blueprints and cellular identities across all branches of life. Moreover, it is
recognized that diversity within an organism is often governed by dynamic chemical mod-
iﬁcations of nucleobases, which can operate as a regulatory layer to ﬁne-tune key molecular
and cellular processes. Changes in epigenomic and epitranscriptomic landscapes can affect a
variety of such processes (e.g., transcription, translation, differentiation, and maintenance of
genome integrity) and are often linked to the onset and progression of disease. Our
understanding of the biochemistry and biological signiﬁcance of the more than 45 DNA
and 170 RNA chemical modiﬁcations reported to date [1, 2] has been largely propelled by
high-throughput sequencing technologies and mass-spectrometry-based approaches, cou-
pled with chemical, enzymatic, or antibody-dependent methodologies. In parallel, we have
witnessed the development of increasingly robust computational methods and statistical
tools tailored to make sense of a growing volume of often heterogeneous and noisy epi-ome
data. In this book, the reader is introduced to state-of-the-art computational methods
designed to manage, analyze, and generally leverage epigenomic and epitranscriptomic
data. Topics include ﬁne-mapping and quantiﬁcation of modiﬁcations, visual analytics,
imputation methods, supervised analysis, and integrative approaches for single-cell data.
Ultimately this compendium will be of interest to a broad audience including students,
biologists, bioinformaticians, and biomedical researchers.
´Evry, France
Pedro H. Oliveira
References
1. Sood et al (2019) DNAmod: the DNA modiﬁcation database. J Cheminfor 11(30):
1–10
2. Boccaletto et al (2018) MODOMICS: a database of RNA modiﬁcation pathways. 2017
update. Nucleic Acids Res 46(Database issue):D303–D307
v

Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
v
Contributors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ix
1
DNA Methylation Data Analysis Using Msuite . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
Xiaojian Liu, Pengxiang Yuan, and Kun Sun
2
Interactive DNA Methylation Array Analysis with ShinyE´ PICo . . . . . . . . . . . . . . .
7
Octavio Morante-Palacios
3
Predicting Chromatin Interactions from DNA Sequence
Using DeepC. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
Ron Schwessinger
4
Integrating Single-Cell Methylome and Transcriptome
Data with MAPLE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
Yasin Uzun, Hao Wu, and Kai Tan
5
Quantitative Comparison of Multiple Chromatin Immunoprecipitation-
Sequencing (ChIP-seq) Experiments with spikChIP. . . . . . . . . . . . . . . . . . . . . . . . .
55
Enrique Blanco, Cecilia Ballare´, Luciano Di Croce,
and Sergi Aranda
6
A Guide to MethylationToActivity: A Deep Learning Framework
That Reveals Promoter Activity Landscapes from DNA Methylomes
in Individual Tumors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
Karissa Dieseldorff Jones, Daniel Putnam, Justin Williams,
and Xiang Chen
7
DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot. . . . .
87
Alexis Hardy, Sandra Duharcourt, and Matthieu Defrance
8
Methylome Imputation by Methylation Patterns. . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
Ya-Ting Sabrina Chang, Ming-Ren Yen, and Pao-Yang Chen
9
Sequoia: A Framework for Visual Analysis of RNA Modiﬁcations
from Direct RNA Sequencing Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
Ratanond Koonchanok, Swapna Vidhur Daulatabad, Khairi Reda,
and Sarath Chandra Janga
10
Predicting Pseudouridine Sites with Porpoise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
139
Xudong Guo, Fuyi Li, and Jiangning Song
11
Pseudouridine Identiﬁcation and Functional Annotation with PIANO . . . . . . . .
153
Jiahui Yao, Cuiyueyue Hao, Kunqi Chen, Jia Meng, and Bowen Song
12
Analyzing mRNA Epigenetic Sequencing Data with TRESS . . . . . . . . . . . . . . . . .
163
Zhenxing Guo, Andrew M. Shaﬁk, Peng Jin, Zhijin Wu, and Hao Wu
13
Nanopore Direct RNA Sequencing Data Processing and Analysis
Using MasterOfPores . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
185
Luca Cozzuto, Anna Delgado-Tejedor, Toni Hermoso Pulido,
Eva Maria Novoa, and Julia Ponomarenko
vii

viii
Contents
14
Data Analysis Pipeline for Detection and Quantiﬁcation of
Pseudouridine (ψ) in RNA by HydraPsiSeq . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
207
Florian Pichot, Virginie Marchand, Mark Helm, and Yuri Motorin
15
Analysis of RNA Sequences and Modiﬁcations Using NASE . . . . . . . . . . . . . . . . .
225
Samuel Wein
16
Mapping of RNA Modiﬁcations by Direct Nanopore Sequencing
and JACUSA2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
241
Amina Lemsara, Christoph Dieterich, and Isabel S. Naarmann-de Vries
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
261

Contributors
SERGI ARANDA
• Centre for Genomic Regulation (CRG), Barcelona Institute of Science and
Technology, Barcelona, Spain
CECILIA BALLARE´
• Centre for Genomic Regulation (CRG), Barcelona Institute of Science
and Technology, Barcelona, Spain
ENRIQUE BLANCO
• Centre for Genomic Regulation (CRG), Barcelona Institute of Science
and Technology, Barcelona, Spain
YA-TING SABRINA CHANG
• Institute of Plant and Microbial Biology, Academia Sinica,
Taipei, Taiwan
KUNQI CHEN
• Key Laboratory of Ministry of Education for Gastrointestinal Cancer, School
of Basic Medical Sciences, Fujian Medical University, Fuzhou, Fujian, China
PAO-YANG CHEN
• Institute of Plant and Microbial Biology, Academia Sinica, Taipei,
Taiwan
XIANG CHEN
• Department of Computational Biology, St. Jude Children’s Research Hospital,
Memphis, TN, USA
LUCA COZZUTO
• Centre for Genomic Regulation (CRG), The Barcelona Institute of Science
and Technology, Barcelona, Spain
SWAPNA VIDHUR DAULATABAD
• Department of BioHealth Informatics, School of Informatics
and Computing, Indiana University Purdue University, Indianapolis, IN, USA
MATTHIEU DEFRANCE
• Universite´ Libre de Bruxelles, Interuniversity Institute of
Bioinformatics in Brussels (IB2), Brussels, Belgium
ANNA DELGADO-TEJEDOR
• Centre for Genomic Regulation (CRG), The Barcelona Institute
of Science and Technology, Barcelona, Spain; Universitat Pompeu Fabra (UPF), Barcelona,
Spain
LUCIANO DI CROCE
• Centre for Genomic Regulation (CRG), Barcelona Institute of Science
and Technology, Barcelona, Spain; Universitat Pompeu Fabra (UPF), Barcelona, Spain;
ICREA, Barcelona, Spain
KARISSA DIESELDORFF JONES
• Department of Computational Biology, St. Jude Children’s
Research Hospital, Memphis, TN, USA
CHRISTOPH DIETERICH
• Klaus Tschira Institute for Integrative Computational Cardiology,
University Heidelberg, Heidelberg, Germany; Department of Internal Medicine III
(Cardiology, Angiology, and Pneumology), University Hospital Heidelberg, Heidelberg,
Germany; German Centre for Cardiovascular Research (DZHK)-Partner Site HD/MA,
Heidelberg, Germany
SANDRA DUHARCOURT
• Universite´ Paris Cite´, CNRS, Institut Jacques Monod, 75013 ,
Paris, France
XUDONG GUO
• College of Information Engineering, Northwest A&F University, Yangling,
China
ZHENXING GUO
• Department of Biostatistics and Bioinformatics, Emory University Rollins
School of Public Health, Atlanta, GA, USA
CUIYUEYUE HAO
• Department of Mathematical Sciences, Xi’an Jiaotong-Liverpool
University, Suzhou, Jiangsu, China
ALEXIS HARDY
• Universite´ Libre de Bruxelles, Interuniversity Institute of Bioinformatics in
Brussels (IB2), Brussels, Belgium
ix

x
Contributors
MARK HELM
• Institute of Pharmacy of Pharmacy and Biochemistry, Johannes Gutenberg
University Mainz, Mainz, Germany
TONI HERMOSO PULIDO
• Centre for Genomic Regulation (CRG), The Barcelona Institute of
Science and Technology, Barcelona, Spain
SARATH CHANDRA JANGA
• Department of BioHealth Informatics, School of Informatics and
Computing, Indiana University Purdue University, Indianapolis, IN, USA; Department
of Medical and Molecular Genetics, Indiana University School of Medicine, Indianapolis,
IN, USA; Centre for Computational Biology and Bioinformatics, Indiana University
School of Medicine, 5021 Health Information and Translational Sciences (HITS),
Indianapolis, IN, USA
PENG JIN
• Department of Human Genetics, Emory University School of Medicine, Atlanta,
GA, USA
RATANOND KOONCHANOK
• Department of Human-Centered Computing, School of
Informatics and Computing, Indiana University Purdue University, Indianapolis, IN,
USA
AMINA LEMSARA
• Klaus Tschira Institute for Integrative Computational Cardiology,
University Heidelberg, Heidelberg, Germany; Department of Internal Medicine III
(Cardiology, Angiology, and Pneumology), University Hospital Heidelberg, Heidelberg,
Germany
FUYI LI
• College of Information Engineering, Northwest A&F University, Yangling,
China; Department of Microbiology and Immunology, The Peter Doherty Institute for
Infection and Immunity, The University of Melbourne, Melbourne, VIC, Australia
XIAOJIAN LIU
• Institute of Cancer Research, Shenzhen Bay Laboratory, Shenzhen, China
VIRGINIE MARCHAND
• Universite´ de Lorraine, CNRS, INSERM, UAR2008/US40 IBSLor,
EpiRNA-Seq Core facility, F-54000, Nancy, France
JIA MENG
• Department of Biological Sciences, Xi’an Jiaotong-Liverpool University, Suzhou,
Jiangsu, China; AI University Research Centre, Xi’an Jiaotong-Liverpool University,
Suzhou, Jiangsu, China; Institute of Systems, Molecular and Integrative Biology, University
of Liverpool, Liverpool, UK
OCTAVIO MORANTE-PALACIOS
• Epigenetics and Immune Disease Group, Josep Carreras
Research Institute (IJC), Barcelona, Spain; Germans Trias i Pujol Research Institute
(IGTP), Barcelona, Spain
YURI MOTORIN
• Universite´ de Lorraine, CNRS, INSERM, UAR2008/US40 IBSLor,
EpiRNA-Seq Core facility, F-54000, Nancy, France; Universite´ de Lorraine, CNRS,
UMR7365 IMoPA, F-54000, Nancy, France
ISABEL S. NAARMANN-DE VRIES
• Klaus Tschira Institute for Integrative Computational
Cardiology, University Heidelberg, Heidelberg, Germany; Department of Internal
Medicine III (Cardiology, Angiology, and Pneumology), University Hospital Heidelberg,
Heidelberg, Germany; German Centre for Cardiovascular Research (DZHK)-Partner Site
HD/MA, Heidelberg, Germany
EVA MARIA NOVOA
• Centre for Genomic Regulation (CRG), The Barcelona Institute of
Science and Technology, Barcelona, Spain; Universitat Pompeu Fabra (UPF), Barcelona,
Spain
FLORIAN PICHOT
• Institute of Pharmacy of Pharmacy and Biochemistry, Johannes Gutenberg
University Mainz, Mainz, Germany; Universite´ de Lorraine, CNRS, INSERM,
UAR2008/US40 IBSLor, EpiRNA-Seq Core facility, F-54000, Nancy, France

Contributors
xi
JULIA PONOMARENKO
• Centre for Genomic Regulation (CRG), The Barcelona Institute of
Science and Technology, Barcelona, Spain; Universitat Pompeu Fabra (UPF), Barcelona,
Spain
DANIEL PUTNAM
• Department of Computational Biology, St. Jude Children’s Research
Hospital, Memphis, TN, USA
KHAIRI REDA
• Department of Human-Centered Computing, School of Informatics and
Computing, Indiana University Purdue University, Indianapolis, IN, USA
RON SCHWESSINGER
• MRC WIMM Centre for Computational Biology, MRC Weatherall
Institute of Molecular Medicine, University of Oxford, Oxford, UK
ANDREW M. SHAFIK
• Department of Human Genetics, Emory University School of Medicine,
Atlanta, GA, USA
BOWEN SONG
• Department of Mathematical Sciences, Xi’an Jiaotong-Liverpool University,
Suzhou, Jiangsu, China; Institute of Systems, Molecular and Integrative Biology, University
of Liverpool, Liverpool, UK
JIANGNING SONG
• Biomedicine Discovery Institute, Monash University, Melbourne, VIC,
Australia; Monash Data Futures Institute, Monash University, Melbourne, VIC, Australia
KUN SUN
• Institute of Cancer Research, Shenzhen Bay Laboratory, Shenzhen, China
KAI TAN
• Center for Childhood Cancer Research, The Children’s Hospital of Philadelphia,
Philadelphia, PA, USA; Department of Biomedical and Health Informatics, The
Children’s Hospital of Philadelphia, Philadelphia, PA, USA; Department of Genetics,
University of Pennsylvania, Philadelphia, PA, USA; Penn Epigenetics Institute, University
of Pennsylvania, Philadelphia, PA, USA; Department of Pediatrics, University of
Pennsylvania, Philadelphia, PA, USA
YASIN UZUN
• Center for Childhood Cancer Research, The Children’s Hospital of
Philadelphia, Philadelphia, PA, USA; Department of Biomedical and Health Informatics,
The Children’s Hospital of Philadelphia, Philadelphia, PA, USA
SAMUEL WEIN
• Center for Bioinformatics Tu¨bingen, University of Tu¨bingen, Tu¨bingen,
Germany
JUSTIN WILLIAMS
• Department of Tumor Cell Biology, St. Jude Children’s Research Hospital,
Memphis, TN, USA
HAO WU
• Department of Genetics, University of Pennsylvania, Philadelphia, PA, USA;
Penn Epigenetics Institute, University of Pennsylvania, Philadelphia, PA, USA
HAO WU
• Department of Biostatistics and Bioinformatics, Emory University Rollins School
of Public Health, Atlanta, GA, USA
ZHIJIN WU
• Department of Biostatistics, Brown University, Providence, RI, USA
JIAHUI YAO
• Department of Biological Sciences, Xi’an Jiaotong-Liverpool University,
Suzhou, Jiangsu, China
MING-REN YEN
• Institute of Plant and Microbial Biology, Academia Sinica, Taipei,
Taiwan
PENGXIANG YUAN
• Institute of Cancer Research, Shenzhen Bay Laboratory, Shenzhen, China

Chapter 1
DNA Methylation Data Analysis Using Msuite
Xiaojian Liu, Pengxiang Yuan, and Kun Sun
Abstract
DNA methylation is a widespread epigenetic modiﬁcation responsible for many biological regulation
pathways. The development of various powerful biochemical assays, including conventional bisulﬁte
treatment-based and emerging bisulﬁte-free techniques, has promised high-resolution DNA methylome
proﬁling and signiﬁcantly propelled the DNA methylation research ﬁeld. However, the analysis of large-
scale data generated from such assays is still complex and challenging. In this paper, we present a step-by-
step protocol for using Msuite for whole-spectrum DNA methylation data analysis, from quality control,
read alignment, to methylation call and data visualization. The Msuite package and a testing dataset are
freely available at https://github.com/hellosunking/Msuite
Key words Bisulﬁte sequencing, Data visualization, CpG dinucleotides
1
Introduction
DNA methylation is a pervasive and important epigenetic regulator
in the mammalian genome, which affects diverse gene regulatory
processes and is intricately regulated to guide complex biological
processes, such as embryogenesis, aging, and tumorigenesis [1–
4]. In mammalian genomes, DNA methylation mostly takes place
at cytosines in CpG dinucleotides, and bisulﬁte sequencing has
traditionally been the most commonly used method to detect
such modiﬁcations [5–9]. Bisulﬁte treatment can modify the
unmethylated cytosines (converted to thymines in sequencing
data) while leaving the methylated ones unchanged, therefore
allowing their differentiation. However, in mammalian genomes,
methylated cytosines mostly appear in CpG dinucleotides, which
only accounts for a very limited proportion (e.g., ~5% in the human
genome) of all cytosines [10–12]. Hence, DNA libraries after
bisulﬁte treatment usually contain very few cytosines, which is
biased with low complexity. As a contrast, emerging bisulﬁte-free
techniques, such as TET-assisted pyridine borane sequencing
(TAPS) [13], employ an opposite strategy that only converts the
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_1,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
1

2
Xiaojian Liu et al.
methylated cytosines, resulting in a much balanced DNA library
with much higher complexity. In both types of approach, the
conversion makes the DNA library no longer the same compared
to the original DNA or reference genome, which makes data analy-
sis a complex and challenging task. Various data analysis softwares
have been developed, but most of them focus on sequence align-
ment and have not been optimized for bisulﬁte-free assays. To this
end, we developed Msuite [14], an all-in-one, multifunctional
package for DNA methylation data analysis. In this paper, we
provide a step-by-step protocol for using Msuite to perform DNA
methylation data analysis.
2
Materials
Msuite is freely available at https://github.com/hellosunking/
Msuite, implemented in C++ and Perl for Linux/Unix systems.
Users are recommended to downloaded the package releases, for
example, https://github.com/hellosunking/Msuite/archive/
refs/tags/v1.1.2.tar.gz for the latest version. After downloading,
uncompress the package using the following command:
$ tar zxf Msuite-1.1.2.tar.gz
A directory named “Msuite-1.1.2” will be created, and the
major program “msuite” will be found under this directory. Note
that we have included pre-compiled programs in the release pack-
age. In addition, the package also contains a testing dataset, which
is in silico generated using the SHERMAN program (https://www.
bioinformatics.babraham.ac.uk/projects/sherman/),
following
the TAPS protocol against the human reference genome (key para-
meters: C->T conversion rate: 20% for CpG sites, C->T conversion
rate at CpH sites: 0.5%, error rate: 0.1%).
3
Methods
3.1
Running
Environment and
Dependencies
Runing Msuite on Linux/Unix machine requires g++ (version 4.8
or higher), Perl (version 5.10 or higher), and R (version 3.0 or
higher). The Msuite package has already included all pre-compiled
executables needed (see Note 1). Msuite depends on bowtie2 and
samtools, and they must be installed on the system. Users can
download bowtie2 from https://sourceforge.net/projects/bowtie-
bio/ﬁles/bowtie2/ and samtools from http://www.htslib.org/
download/
and
follow
the
installation
instructions
in
the
corresponding packages.

DNA Methylation Data Analysis Using Msuite
3
3.2
Building Indices
Before running Msuite, genome indices must be built. To this end,
a utility named “build.index.sh” is available under the “build.index”
directory. The “build.index.sh” script requires three parameters:
a genome sequence ﬁle in fasta format (or directory containing
sequences for individual chromosomes), a RefSeq annotation, and
the identity of the genome index. Genome sequences can be down-
loaded from UCSC genome browser (http://genome.ucsc.edu).
For example, the hg38 reference genome can be downloaded via
the following command:
$ wget http://hgdownload.cse.ucsc.edu/goldenpath/hg38/
bigZips/hg38.fa.gz
The RefSeq annotations for hg38 (and mm10 (Mus Muscu-
lus)) are already included in the Msuite package. Users can down-
load newer versions via the following command if needed:
$ wget http://hgdownload.cse.ucsc.edu/goldenPath/hg38/data
base/refGene.txt.gz
Next, build the genome indices using the following command:
$ build.index/build.index.sh /path/to/hg38.fa.gz build.index/
hg38.refGene.txt.gz hg38
3.3
Run Msuite
Msuite provides two analysis modes: three-letter mode and four-
letter mode. The three-letter mode is generic and could be applied
to most DNA methylation assays (e.g., WGBS), while the four-
letter mode is speciﬁc for TAPS, 5hmC-CATCH [15], or similar
approaches (see Note 2).
Prepare scripts for analyzing the testing dataset using the three-
letter mode:
$ ./msuite -x hg38 -m TAPS -3 -1 ./testing_dataset/simu.read1.
fq.gz -2 ./testing_dataset/simu.read2.fq.gz -p 8 -o ./testing_-
dataset/Msuite.Mode3
Or using the four-letter mode:
$ ./msuite -x hg38 -m TAPS -4 -1 ./testing_dataset/simu.read1.
fq.gz -2 ./testing_dataset/simu.read2.fq.gz -p 8 -o ./testing_-
dataset/Msuite.Mode4
The “-x” option speciﬁes the identity of the genome index
(here hg38); the “-m” option speciﬁes the assay type (users can
set “-m BS” for WGBS data); the “-3”/ “-4” option denotes that a
three-letter or four-letter mode should be used, respectively (when
using the four-letter mode, “-m TAPS” must be set at the same
time as this mode only supports TAPS or similar assays; see Note 3);
the “-p” option speciﬁes the threads to be used (set “-p 0” to use

4
Xiaojian Liu et al.
all threads); the “-1” and “-2” options specify the input ﬁles (see
Note 4); and the “-o” option sets the output directory.
A makeﬁle should be generated in the output directory (“-o”
option). Change to that directory and run the actual analysis:
$ cd ./testing_dataset/Msuite.Mode3
$ make
Msuite will perform data preprocessing (including adapter-
trimming, low-quality cycle removal) [16], read alignment, meth-
ylation call, as well as data visualization (see Notes 5 and 6).
We have prepared a script, “run_testing_dataset.sh,” for build-
ing references and running the analysis on the testing dataset
automatically. Users can call it using the following command:
$ ./run_testing_dataset.sh
3.4
The Msuite
Output
Msuite writes all the results to the directory speciﬁed by the “-o”
option. The alignment output is recorded in the ﬁles “Msuite.ﬁnal.
bam” and “Msuite.rmdup.sam,” while the methylation calls are
recorded in the ﬁles “Msuite.CpG.meth.call,” “Msuite.CpH.meth.
call,” and “Msuite.CpG.meth.bedgraph.” In addition, Msuite sum-
marizes the most relevant quality control and analysis statistics, as
well as visualizations for methylation call and M-bias into an
HTML ﬁle named “Msuite.report/index.html.” Figure 1 shows
the HTML report of Msuite on the testing dataset.
4
Notes
1. This source package contains pre-compiled executable ﬁles
using g++ version 4.8.5 for Linux x86_64 system. If users
could not run the analysis normally, which is usually caused
by low version of libc++ library, the users can re-compile the
programs using the following command:
$ make clean && make
2. Msuite can directly analyze data generated by ATAC-me [17]
or similar protocols via setting “-k nextera”; Msuite also allows
the users to set the “-c cycle” option to control the cycles to be
analyzed if the users do not need all cycles;
3. If your data is generated using BS-seq protocol, you must use
the three-letter mode and set “-m BS.” The four-letter mode
only supports processing of TAPS / 5hmC-CATCH data
where the non-CpG methylationMethylation is very low;
4. Msuite supports multiple ﬁles as well as gzip-compressed ﬁles:
the users can use “,” to concatenate input ﬁles. Those with “.
gz” sufﬁx will be automatically interpreted as gzip-compressed
ﬁles;

DNA Methylation Data Analysis Using Msuite
5
Fig. 1 Example of the Msuite analysis summary on the testing dataset
5. The Msuite package contains a program called “Mviewer” [18]
for nucleotide-level, genotyping-aware DNA methylation data
visualization, which is speciﬁcally suitable for visualizing
imprinting events, or ending preferences in cell-free DNA
data [19].
6. This protocol also works for Msuite2 [20], which is the succes-
sor of Msuite and freely available at https://github.com/
hellosunking/Msuite2.

11.
6
Xiaojian Liu et al.
References
1. Yin Y, Morgunova E, Jolma A, Kaasinen E,
Sahu B, Khund-Sayeed S, Das PK, Kivioja T,
Dave K, Zhong F et al (2017) Impact of cyto-
sine methylation on DNA binding speciﬁcities
of human transcription factors. Science 356:
eaaj2239. https://doi.org/10.1126/science.
aaj2239
2. Baylin SB, Jones PA (2011) A decade of explor-
ing the cancer epigenome – biological and
translational implications. Nat Rev Cancer 11:
726–734. https://doi.org/10.1038/nrc3130
3. Zemach A, McDaniel IE, Silva P, Zilberman D
(2010) Genome-wide evolutionary analysis of
eukaryotic DNA methylation. Science 328:
916–919. https://doi.org/10.1126/science.
1186366
4. Feng S, Jacobsen SE, Reik W (2010) Epige-
netic reprogramming in plant and animal
development. Science 330:622–627. https://
doi.org/10.1126/science.1190614
5. Meissner A, Mikkelsen TS, Gu H, Wernig M,
Hanna J, Sivachenko A, Zhang X, Bernstein
BE, Nusbaum C, Jaffe DB (2008) Genome-
scale DNA methylation maps of pluripotent
and differentiated cells. Nature 454:766–770.
https://doi.org/10.1038/nature07107
6. Boyle P, Clement K, Gu H, Smith ZD,
Ziller M, Fostel JL, Holmes L, Meldrim J,
Kelley F, Gnirke A (2012) Gel-free multiplexed
reduced representation bisulﬁte sequencing for
large-scale
DNA
methylation
proﬁling.
Genome Biol 13:1–10. https://doi.org/10.
1186/gb-2012-13-10-r92
7. Meissner A, Gnirke A, Bell GW, Ramsahoye B,
Lander ES, Jaenisch R (2005) Reduced repre-
sentation bisulﬁte sequencing for comparative
high-resolution DNA methylation analysis.
Nucleic Acids Res 33:5868–5877. https://
doi.org/10.1093/nar/gki901
8. Sun K, Jiang P, Chan KCA, Wong J, Cheng YK,
Liang RH, Chan WK, Ma ES, Chan SL, Cheng
SH et al (2015) Plasma DNA tissue mapping
by genome-wide methylation sequencing for
noninvasive prenatal, cancer, and transplanta-
tion assessments. Proc Natl Acad Sci U S A
112:E5503–E5512. https://doi.org/10.
1073/pnas.1508736112
9. Gu H, Smith ZD, Bock C, Boyle P, Gnirke A,
Meissner A (2011) Preparation of reduced rep-
resentation bisulﬁte sequencing libraries for
genome-scale
DNA
methylation
proﬁling.
Nat Protoc 6:468–481. https://doi.org/10.
1038/nprot.2010.190
10. Luo C, Hajkova P, Ecker JR (2018) Dynamic
DNA methylation: in the right place at the
right time. Science 361:1336–1340. https://
doi.org/10.1126/science.aat6806
Greenberg MVC, Bourc’his D (2019) The
diverse
roles
of
DNA
methylation
in
mammalian development and disease. Nat Rev
Mol Cell Biol 20:590–607. https://doi.org/
10.1038/s41580-019-0159-6
12. Yoder JA, Walsh CP, Bestor TH (1997) Cyto-
sine methylation and the ecology of intrage-
nomic parasites. Trends Genet 13:335–340.
https://doi.org/10.1016/s0168-9525(97)
01181-5
13. Liu Y, Siejka-Zielinska P, Velikova G, Bi Y,
Yuan
F,
Tomkova
M,
Bai
C,
Chen
L,
Schuster-Bockler
B,
Song
CX
(2019)
Bisulﬁte-free
direct
detection
of
5-methylcytosine
and
5-hydroxymethylcytosine at base resolution.
Nat Biotechnol 37:424–429. https://doi.
org/10.1038/s41587-019-0041-2
14. Sun K, Li L, Ma L, Zhao Y, Deng L, Wang H,
Sun H (2020) Msuite: a high-performance and
versatile
DNA
methylation
data-analysis
toolkit. Patterns (NY) 1:100127. https://doi.
org/10.1016/j.patter.2020.100127
15. Zeng H, He B, Xia B, Bai D, Lu X, Cai J,
Chen L, Zhou A, Zhu C, Meng H et al
(2018) Bisulﬁte-free, nanoscale analysis of
5-hydroxymethylcytosine at single base resolu-
tion. J Am Chem Soc 140:13190–13194.
https://doi.org/10.1021/jacs.8b08297
16. Sun K (2020) Ktrim: an extra-fast and accurate
adapter- and quality-trimmer for sequencing
data. Bioinformatics 36:3561–3562. https://
doi.org/10.1093/bioinformatics/btaa171
17. Barnett KR, Decato BE, Scott TJ, Hansen TJ,
Chen B, Attalla J, Smith AD, Hodges E (2020)
ATAC-Me captures prolonged DNA methyla-
tion of dynamic chromatin accessibility loci
during cell fate transitions. Mol Cell 77:
1350–1364 e1356. https://doi.org/10.
1016/j.molcel.2020.01.004
18. Sun K, Lun FFM, Jiang P, Sun H (2017)
BSviewer: a genotype-preserving, nucleotide-
level visualizer for bisulﬁte sequencing data.
Bioinformatics 33:3495–3496. https://doi.
org/10.1093/bioinformatics/btx505
19. Sun K, Jiang P, Wong AIC, Cheng YKY, Cheng
SH, Zhang H, Chan KCA, Leung TY, Chiu
RWK, Lo YMD (2018) Size-tagged preferred
ends in maternal plasma DNA shed light on the
production mechanism and show utility in
noninvasive prenatal testing. Proc Natl Acad
Sci U S A 115:E5106–E5114. https://doi.
org/10.1073/pnas.1804134115
20. Li L, An Y, Ma L, Yang M, Yuan P, Liu X, Jin X,
Zhao Y, Zhang S, Hong X, Sun K (2022)
Msuite2: all-in-one DNA methylation data
analysis toolkit with enhanced usability and
performance. Comput Struct Biotechnol J 20:
1271–1276. https://doi.org/10.1016/j.csbj.
2022.03.005

Chapter 2
Interactive DNA Methylation Array Analysis with ShinyE´PICo
Octavio Morante-Palacios
Abstract
Arrays provide a cost-effective platform for the analysis of human DNA methylation. ShinyE´ PICo is an
interactive, web-based, and graphical tool that allows the user to analyze Illumina DNA methylation arrays
(450 k and EPIC), from the user’s own computer or from a server. This tool covers the analysis entirely,
from the raw data input to the ﬁnal list of differentially methylated positions or regions. Here, we describe
the steps of the analysis, the different parameters available, and useful information to understand and select
the best options in each step.
Key words DNA methylation, Epigenetics, Shiny, Web Interface, Differentially Methylated Positions,
Differentially Methylated Regions
1
Introduction
Cellular epigenomic landscapes are constituted by a plethora of
mechanisms, including posttranslational modiﬁcation of histones,
noncoding RNAs, chromatin accessibility, three-dimensional chro-
mosome organization, and DNA methylation [1, 2].
In particular, DNA methylation is the best-studied epigenetic
modiﬁcation, consisting, in humans, of the addition of a methyl
group to the carbon 5 (5meC) of cytosines [2]. DNA methylation
not only is found mostly in cytosine-followed-by-guanine dinu-
cleotides (CpG sites) but also at non-CpG sites (CpA, CpT, and
CpC).
Originally, DNA methylation was studied in CpG-rich regions
(CpG islands), which are found generally in gene promoters [3]. In
that context, DNA methylation is associated with gene repression,
and it is also relevant for X-chromosome inactivation, pre-mRNA
alternative splicing, and long-term gene silencing [1, 4, 5]. How-
ever, more recent works have elucidated a new role of DNA meth-
ylation in the regulation of dynamic biological processes, such as
cell differentiation, highlighting the role of DNA methylation in
enhancers, gene bodies, and partially methylated domains [6, 7].
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_2,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
7

8
Octavio Morante-Palacios
Despite the development of deep sequencing-based techniques
for the study of DNA methylation, with high resolution and cover-
age, such as the whole-genome bisulﬁte sequencing (WGBS), the
moderate cost and robust CpG coverage of DNA methylation
arrays make them still very useful for DNA methylation studies,
especially when a high number of samples is involved.
Illumina Inﬁnium microarrays are the most widely used plat-
form for the study of human DNA methylation. Inﬁnium Methy-
lationEPIC BeadChIP is the latest version of Illumina DNA
methylation array, covering more than 850,000 methylation sites
and 99% of RefSeq genes. The prior version was the Inﬁnium
Human Methylation 450 k BeadChip, which covers 450,000 meth-
ylation sites.
Several tools have been created for the analysis of Illumina
DNA methylation arrays. First, Genome Studio is the proprietary
tool designed by Illumina, which only works in Windows. In addi-
tion, multiplatform R packages such as illuminaio, minﬁ, lumi,
RnBeads, and limma [8–12] can be used to import array ﬁles,
perform the normalization, and calculate differentially methylated
positions, from R.
ShinyE´ PICo [13] is a graphical tool that relies on several well-
established R packages such as minﬁ, limma, and mCSEA to pro-
vide a web interface to follow all the steps of the DNA methylation
array analysis. First, this can be useful for users without a bioinfor-
matics background, since the application is very user-friendly and
guide the user through the analysis. Secondly, even for bioinforma-
ticians, the automatization and immediate graphical output of
shinyE´ PICo is very convenient for analysis involving iterative repe-
titions and trying several parameters in each step. Lastly, since
shinyE´ PICo can be installed on a server and can be used remotely
from other computers, it can help to optimize computer resources
and facilitate the use of servers for array analysis.
In this chapter, the main steps of the DNA methylation array
analysis with shinyE´ PICo will be discussed, explaining the different
options in each one and the interpretation of graphs and statistics.
2
Materials
ShinyE´ PICo is an R package, available in Bioconductor 3.14
(http://www.bioconductor.org/packages/release/bioc/html/
shinyepico.html). It requires the installation of R 4.1 in GNU/Li-
nux, macOS, or Windows. Moreover, for comfortable use of the
application, we recommend a computer with at least 16GB of
RAM, although depending on the number of arrays analyzed, the
requirements could be higher or lower.
After the installation, following the Bioconductor web instruc-
tions, shinyE´ PICO can be run executing the function shinyepico::

Interactive DNA Methylation Array Analysis with ShinyE´ PICo
9
run_shinyepico(), appearing directly in the web interface in the web
browser. To note, the run_shinyepico() function contains four
arguments that can be customized:
•
n_cores: This numeric parameter controls the number of cores,
and by default, it is half of the detected cores. If you have limited
RAM (8GB or less), we recommend setting this to 1, to avoid
the RAM overhead of multicore calculations.
•
max_upload_size: This parameter established the limitation
(in MB) of the ﬁles that can be uploaded to the application. By
default, this parameter is 2000 MB.
•
host: IP used to deploy the application. By default, this parameter
is your local IP (127.0.0.1), which means that only you, from
your computer, will have access to the application. However, it is
possible to make the app reachable to other computers in the
same LAN by changing the IP to 0.0.0.0.
•
port: Port used to deploy the application. By default, a random
free port.
Alternatively, shinyE´ PICo is also distributed as a Docker con-
tainer ready to use (https://hub.docker.com/repository/docker/
omorante/shinyepico). This option is especially useful to use shi-
nyE´ PICO remotely, conﬁguring a server, potentially with more
RAM and computational power, and using it from other compu-
ters. This kind of server can be conﬁgured with the ShinyProxy
project (https://www.shinyproxy.io).
3
Methods
The shinyE´ PICo workﬂow is divided into several parts. In the
following section, the full analysis will be explained, from the data
upload to the results export.
3.1
Data Upload
The ﬁrst step in the shinyE´ PICo workﬂow is to prepare the data in
the proper format. iDAT ﬁles should be compressed into a .zip ﬁle.
The name of the ﬁles should follow the standard convention:
XXXXXXXXXXXX_YYYYYY_ZZZ.idat being XXXXXXXXXXXX
the Sentrix_ID, YYYYYY the Sentrix_Position, and ZZZ Grn or
Red (corresponding, respectively, to the Red and Green signal ﬁle).
Moreover, a CSV (comma-separated) ﬁle with the annotation
of the experiment should be included. It is mandatory to include
the Sentrix_ID and Sentrix_Position columns that allow the soft-
ware to ﬁnd their respective iDAT ﬁles. Moreover, other columns
should be added to reﬂect the different variables (e.g., sample
name, health/disease, treatment/control, age, sex. . .). An example
of a sample sheet is included in Table 1. shinyE´ PICo autodetects
variable types (numerical or categorical). Then, it is recommended

10
Octavio Morante-Palacios
Table 1
Example of sample sheet
Sample_Name
Sample_Group
Donor
Sentrix_ID
Sentrix_Position
MAC A
MAC
A
202163550095
R02C01
MO B
MO
B
202163550095
R04C01
MAC C
MAC
C
202163550095
R06C01
MO A
MO
A
202163550095
R07C01
MO C
MO
C
202163550097
R05C01
MAC B
MAC
B
202163550097
R07C01
to not use numbers to deﬁne categorical variables. For example,
’Donor’, a categorical variable, should be ﬁlled in using letters or
words, but not only numbers.
After preparing the zip ﬁle, it can be easily uploaded with the
browse button on the Input tab. As indicated in the Materials
section, the size of the zip ﬁle to upload is limited by the max_-
upload_size parameter.
When a zip ﬁle with a proper sample sheet is uploaded, the
sample name, variable of interest, and donor columns should be
selected. The variable of interest is the one in which you want to
calculate the methylation differences. The donor variable is useful
when you have several samples from the same person. If it is not the
case, the sample name can be selected as the donor variable also.
Finally, it is possible to exclude samples from the analysis, deselect-
ing them in the “Select Samples to Process” bar.
When the “Continue” button is pressed, the information is
processed, and the tab focus is automatically switched to the
normalization tab.
3.2
Quality Control
After data uploading, two quality control plots are shown. First,
the QC signal plot shows the median methylated (mMed) and
unmethylated (uMed) signal from each sample (Fig. 1a). If a sample
is shown as “Suboptimal” or very distant from the other samples,
there is a great chance that some problem with the hybridization or
sample quality has occurred. Secondly, the bisulﬁte conversion plot,
calculated with speciﬁc control probes, allows the user to know if
the bisulﬁte conversion has been successful (Fig. 1b).
Moreover, the Sex Prediction and SNPs Heatmap tabs can also
be used to check if samples have been correctly annotated and
hybridized in the proper order. The sex prediction plot relies on
the X and Y chromosome intensities to identify XX or XY genotype
(Fig. 1c), whereas the SNP heatmap uses speciﬁc probes of the array

Interactive DNA Methylation Array Analysis with ShinyE´ PICo
11
Fig. 1 Quality control plots. (a) Scatter plot showing the overall methylation signal in the methylated channel
(mMed) in contrast with the unmethylated channel (uMed), for each sample. In this example, all the samples
are above the signal threshold. (b) Lollipop plot depicting the minimum ratio between the converted and
nonconverted control Illumina Inﬁnium II probes. (c) Scatter plot showing the median X chromosome intensity
in contrast with the median Y chromosome intensity, for each sample. The color indicates the sex prediction.
In this case, all the samples are predicted as “male” (M). (d) Heatmap of SNP probes. The dendrogram
clusterized together the samples from the same donors
to identify samples from the same donors (Fig. 1d). In the dendro-
gram, samples from the same donor should appear together in the
same cluster. Altogether, this information can be used to contrast
the data from the sample sheet and detect errors in the sample
processing.
3.3
Normalization
The ﬂuorescence signal of methylation arrays can be very sensitive
to technical variables, and the global proﬁles of methylation of
different samples can look very different. It is necessary to use a
normalization method to correct the data and make the samples
comparable.
ShinyE´ PICo includes all the normalization methods present in
the minﬁpackage. It is important to understand the use cases of
each normalization method in order to select one appropriate for
the dataset of interest:
•
Raw: This method does not perform any normalization, keeping
data as is. This is generally not recommended in order to calcu-
late DMPs or DMRs.

12
Octavio Morante-Palacios
•
Illumina: A reverse-engineered implementation of the Genome
Studio normalization. It relies on control probes of the array in
order to equalize methylation values.
•
Funnorm: A between-array normalization method that relies on
data from control probes of the arrays. It performs also Noob
normalization before Functional Normalization.
•
Noob: A within-array normalization method with dye-bias
normalization.
•
SWAN: A within-array normalization method that allows Inﬁ-
nium I and Inﬁnium II probes to be normalized together.
•
Quantile: A between-array normalization method that assumes
no global differences in methylation between the samples. When
global changes are expected, such as in cancer samples, other
methods, such as Funnorm, are recommended.
•
Additionally, it offers the option of performing Noob within
array
normalization
followed
by
Quantile
normalization
(Noob + Quantile), analogously to the Funnorm method. This
nonstandard approach has empirically shown good results in our
experience.
In our experience, for primary samples in which little methyla-
tion changes are expected, the Quantile or Noob+Quantile meth-
ods
perform
very
effectively.
However,
when
very
broad
methylation changes are expected, such as in cancer versus healthy
samples, other methods, such as Funnorm, should be used. More-
over, the Illumina method is ﬂexible for different types of datasets,
and it could be useful when we want similar behavior to the
Genome Studio software.
The result of normalization can be directly visualized by com-
paring the “Raw” and “Normalized” density plots (Fig. 2a, b) and
boxplots.
In addition to the normalization method, other options can be
selected. The Drop CpH and Drop SNP buttons remove probes of
cytosines outside the CpG context or annotated to known SNPs,
respectively.
Moreover, the X and Y chromosomes can be removed, which
can be useful if we have samples of different sex, to remove some
variability. However, there are other ways to manage this sex bias, as
we will explain in the next sections.
Finally, the normalization section contains two other tabs to
perform an exploratory data analysis prior to DMP or DMR calcu-
lation. In the correlations tab, the different parameters of the
sample sheet are correlated with the principal components (PCs)
of the principal component analysis (PCA) with the beta values
(Fig. 2c). This is very useful to detect variables that could be
inﬂuencing methylation. Moreover, this can be represented in the
PCA tab, where different PCs can be chosen for representation
(Fig. 2d).

Interactive DNA Methylation Array Analysis with ShinyE´ PICo
13
Fig. 2 Normalization and exploratory data analysis plots. (a) Density plot of raw beta values, depicting the
distribution of each sample. (b) Density plot of quantile-normalized beta values, depicting the distribution of
each sample. (c) Correlations between variables and principal components. Pearson correlation is applied to
correlate principal components with numerical variables. For categorical variables, linear models (principal
component ~ categorical variable) are generated, and R-squared statistics are shown in the representation.
(d) Principal component analysis representation, showing the principal component 1 (PC1) versus principal
component 2 (PC2)
3.4
Differentially
Methylated Position
Calculation
When normalization is ﬁnished, the next section is the DMP calcu-
lation. Analyzing differential methylation is probably the main aim
of most DNA methylation studies. ShinyE´ PICo uses the limma
package to generate a model and calculate contrasts. In order to
ﬁt the limma data assumptions, M-values are used instead of
B-values to generate the model.
First, the variable of interest should be selected. Pairwise differ-
ences will be calculated between all groups speciﬁed in this variable.
Moreover, covariables and interactions can also be included in the
model. This is useful to take into account differences in methylation
that can be driven by other biological variables such as donor, sex,
or age, or technical variables such as batch or array. The correlations
tab of the normalization section can help to determine what vari-
ables can be impacting DNA methylation. Usually, sex, if X/Y
chromosomes are preserved, and donor have a great impact on
DNA methylation and should be included. Including these covari-
ables in the model can increase the statistical power and reduce false

14
Octavio Morante-Palacios
Fig. 3 Differentially methylated positions and region calculation plots. (a) Density plot depicting the mean-
variance relation of each analyzed position. (b) DNA methylation heatmap of an example dataset including
three monocyte (MO) samples and three macrophage (MAC) samples (lower DNA methylation levels in blue
and higher methylation levels in red). (c) Genomic plot depicting CpGs assigned to the B2M gene promoter.
Consistent demethylation in MACs can be observed in several CpGs
positives. Furthermore, if a variable can affect DNA methylation
depending on another variable, an interaction term could be added
to the model.
Secondly, if the ArrayWeights option is enabled, estimated
relative quality weights for each array are calculated and used in
the limma model, using the function limma::arrayWeights. This
option ponderates the inﬂuence of the arrays in the model depend-
ing on the calculated qualities. It is especially useful with large
datasets of heterogeneous quality [14].
When the model is generated, a diagnosis plot is shown, depict-
ing the mean-variance relation of each position of the array
(Fig. 3a). Ideally, no relationship between mean and variance
should be detected: the distribution should be similar to a horizon-
tal straight line.
Finally, two other options are shown after clicking on the
“Generate Model” button. The eBayes Trend and eBayes Robust
options correspond to the homonymous options of the limma::
eBayes function. In brief, the eBayes Trend option can be useful

Interactive DNA Methylation Array Analysis with ShinyE´ PICo
15
when a mean/variance relationship is shown in the diagnosis plot
[15], and the Robust option can protect the statistical method
against hypo-variable or hyper-variable positions [16].
After contrast calculation, a heatmap depicting the differences
is shown (Fig. 3b). This heatmap is completely customizable. The
signiﬁcant DMPs can be ﬁltered by the differential of beta value,
FDR, or p-value. Moreover, the groups and contrasts shown in the
plot can be also selected. The “Remove Batch Effect” option per-
forms a correction of the represented beta values, subtracting the
effects of the covariables and interactions. This can be appropriate
when a high effect of these covariables is observed, and it only
applies to the representation, not the statistical analysis.
In addition, the heatmap can be divided into different clusters
according to the dendrogram with the “Row Colors options.” The
positions corresponding to each cluster can be downloaded as bed
ﬁles in the following sections.
Speciﬁc DMPs can also be explored in the DMP annotation
tab, which depicts the annotation of each DMP and allows the user
to represent boxplots of selected DMPs.
3.5
Differentially
Methylated Region
Calculation
When DMPs are calculated, the DMR calculation is enabled. shi-
nyE´ PICo relies on mCSEA [17] for this calculation. Since mCSEA
relies on the limma results as input, DMR calculation is only
available after the DMP calculation has been completed.
The concept of DMR can be explained as the calculation of
methylation differences in aggregate positions of the genome. This
aggregation can use different criteria, but generally, proximity is the
main criteria, because DNA methylation levels are often very spa-
tially correlated.
mCSEA uses predeﬁned regions of CpGs annotated to promo-
ters, gene bodies, or CpG islands outside genes. These regions can
be ﬁltered depending on the containing CpGs. Moreover, the
statistics of mCSEA are calculated with permutations, and shinyE´ -
PICo allows the user to select the number of permutations. More
permutations will generate more accurate statistics but will take
longer to ﬁnish the analysis.
After ﬁnishing this analysis, a heatmap can be also shown,
depicting the average beta values of each DMR. Moreover, individ-
ual DMRs can be plotted in the “Single DMR Plot” tab (Fig. 3c).
3.6
Results Export
After ﬁnishing the analysis, the results of the analysis can be
downloaded:
•
R Objects: The objects used by shinyE´ PICo during the analysis,
such as the RGChannelSet (minﬁraw object) and GenomicRa-
tioSet (minﬁnormalized object) can be downloaded in RDS
format, to import and use in R.

16
Octavio Morante-Palacios
•
Filtered Bed Files: DMP or DMR genomic positions can be
downloaded in BED format. Genomic coordinates can be
requested in hg38 or hg19 genomes. By default, beds are down-
loaded by contrasts, with two ﬁles for each contrast (with the
positions more methylated in one group, or another group).
Moreover, clusters of heatmap can be directly downloaded if
the Row Colors option is enabled.
•
Workﬂow Report: All the options selected during the analysis,
and the plots present in the application can be downloaded in an
HTML report. This report is intended as a reference that indi-
cates all the details of the analysis that can be consulted at any
time and reproduced in shinyE´ PICo if necessary.
•
Custom R Script: This option creates a custom R script, includ-
ing all the parameters selected in the analysis and all the func-
tions needed to reproduce exactly the results generated in
shinyE´ PICo outside the application.
•
Heatmap(s): DMP and DMR heatmaps can be downloaded in
PDF, ready to use in publication-quality ﬁgures.
Overall, these ﬁles can be used in a simple way to carry out
typical downstream analysis, such as gene ontology enrichment
analysis based on genomic regions or transcription factor motif
enrichment analysis.
4
Notes
ShinyE´ PICo enables interactive analysis of methylation arrays,
providing graphs to aid in analysis decision-making. However,
choosing the best options at each step is up to the user.
In this chapter, and in the ShinyE´ PICo and Minﬁvignettes in
Bioconductor, there is useful information for interpreting the
graphs and making these decisions. Additionally, in this section, I
will make some considerations and recommendations for frequent
situations.
First of all, in projects with a large number of samples, one of
the issues is quality control. Sometimes, the amount or integrity of
DNA in some of the samples could be low, especially if patient
samples are involved. The shinyE´ PICo signal plot allows to detect
potentially failed samples at a glance. Generally, samples hybridized
in the same batch should have a similar signal. For uncertain situa-
tions, it is advisable to continue the analysis with all samples and
check later by exploring the data with the PCA plot whether those
suboptimal samples differ signiﬁcantly from the rest.
Another key decision in the analysis is the method of normali-
zation. For this, the proportion of expected methylation changes
must be taken into account. For example, differentiation processes

Interactive DNA Methylation Array Analysis with ShinyE´ PICo
17
or primary cell samples from patients show relatively small changes
in proportion to the 450,000/850,000 positions of the Illumina
methylation arrays. In these cases, in our experience, the Noob
+Quantile method performs very well, equalizing very ﬁnely the
overall methylation proﬁles in the samples. In contrast, if global
methylation changes are expected, as occurs in cancer cells, it is
necessary to use alternative methods, such as Functional Normali-
zation or Illumina normalization.
Another key step in the analysis is the choice of the parameters
of the linear limma model. In particular, the choice of appropriate
covariates and interactions can make a big difference in the out-
come. A valuable resource for this choice is the correlations and
PCA plots in the Normalization tab. If we observe signiﬁcant
correlation of any covariate with the methylation data, we should
incorporate it into the linear model.
Finally, validation of the results after ﬁnishing the analysis
requires biological expertise related to the hybridized samples.
Tools such as GREAT [18], which allows calculation of enrichment
of CpGs lists with functional categories, and HOMER [19], which
calculates enrichment of transcription factor motifs, can be very
useful to determine whether the results are meaningful.
Funding
O.M.-P. holds an i-PFIS PhD Fellowship [IFI17/00034] from
Accio´n Estrate´gica en Salud 2013–2016 ISCIII, co-ﬁnanced by
Fondo Social Europeo.
References
1. Goldberg AD, Allis CD, Bernstein E (2007)
Epigenetics: a landscape takes shape. Cell 128:
635–638. https://doi.org/10.1016/j.cell.
2007.02.006
2. de la Calle-Fabregat C, Morante-Palacios O,
Ballestar E (2020) Understanding the rele-
vance of DNA methylation changes in immune
differentiation and disease. Genes (Basel) 11.
https://doi.org/10.3390/genes11010110
3. Jones PA (2012) Functions of DNA methyla-
tion: islands, start sites, gene bodies and
beyond. Nat Rev Genet 13:484–492. https://
doi.org/10.1038/nrg3230
4. Lev Maor G, Yearim A, Ast G (2015) The
alternative role of DNA methylation in splicing
regulation. Trends Genet 31:274–280
5. Chow JC, Yen Z, Ziesche SM, Brown CJ
(2005) Silencing of the mammalian X chromo-
some. Annu Rev Genomics Hum Genet 6:69–
92
6. Lister R, Pelizzola M, Dowen RH et al (2009)
Human DNA methylomes at base resolution
show
widespread
epigenomic
differences.
Nature 462:315–322. https://doi.org/10.
1038/nature08514
7. Neri F, Rapelli S, Krepelova A et al (2017)
Intragenic DNA methylation prevents spurious
transcription initiation. Nature 543:72–77.
https://doi.org/10.1038/nature21373
8. Smith ML, Baggerly KA, Bengtsson H et al
(2013) Illuminaio: an open source IDAT pars-
ing
tool
for
Illumina
microarrays.
F1000Research 2:264. https://doi.org/10.
12688/f1000research.2-264.v1
9. Aryee MJ, Jaffe AE, Corrada-Bravo H et al
(2014) Minﬁ: a ﬂexible and comprehensive
Bioconductor package for the analysis of Inﬁ-
nium DNA methylation microarrays. Bioinfor-
matics 30:1363–1369. https://doi.org/10.
1093/bioinformatics/btu049

18
Octavio Morante-Palacios
10. Mu¨ller F, Scherer M, Assenov Y et al (2019)
RnBeads 2.0: comprehensive analysis of DNA
methylation
data.
Genome
Biol
20:55.
https://doi.org/10.1186/s13059-019-
1664-9
11. Ritchie ME, Phipson B, Wu D et al (2015)
Limma powers differential expression analyses
for RNA-sequencing and microarray studies.
Nucleic Acids Res 43:e47. https://doi.org/
10.1093/nar/gkv007
12. Du P, Kibbe WA, Lin SM (2008) lumi: a pipe-
line for processing Illumina microarray. Bioin-
formatics 24:1547–1548. https://doi.org/10.
1093/bioinformatics/btn224
13. Morante-Palacios O, Ballestar E (2021) shi-
nyE´ PICo: a graphical pipeline to analyze Illu-
mina DNA methylation arrays. Bioinformatics.
https://doi.org/10.1093/bioinformatics/
btaa1095
14. Ritchie ME, Diyagama D, Neilson J et al
(2006) Empirical array quality weights in the
analysis of microarray data. BMC Bioinf 7:261.
https://doi.org/10.1186/1471-2105-7-261
15. Law
CW,
Chen
Y,
Shi
W,
Smyth
GK
(2014) Voom: precision weights unlock linear
model analysis tools for RNA-seq read counts.
Genome Biol 15:R29. https://doi.org/10.
1186/gb-2014-15-2-r29
16. Phipson B, Lee S, Majewski IJ et al (2016)
Robust hyperparameter estimation protects
against
hypervariable
genes
and
improves
power to detect differential expression. Ann
Appl Stat 10:946–963. https://doi.org/10.
1214/16-AOAS920
17. Martorell-Maruga´n J, Gonza´lez-Rumayor V,
Carmona-Sa´ez P (2019) MCSEA: detecting
subtle differentially methylated regions. Bioin-
formatics 35:3257–3262. https://doi.org/10.
1093/bioinformatics/btz096
18. McLean CY, Bristor D, Hiller M et al (2010)
GREAT improves functional interpretation of
cis-regulatory regions. Nat Biotechnol 28:
495–501. https://doi.org/10.1038/nbt.
1630
19. Heinz S, Benner C, Spann N et al (2010) Sim-
ple combinations of lineage-determining tran-
scription factors prime cis-regulatory elements
required for macrophage and B cell identities.
Mol Cell 38:576–589. https://doi.org/10.
1016/j.molcel.2010.05.004

Chapter 3
Predicting Chromatin Interactions from DNA Sequence
Using DeepC
Ron Schwessinger
Abstract
The genome 3D structure is central to understanding how disease-associated genetic variants in the
noncoding genome regulate their target genes. Genome architecture spans large-scale structures deter-
mined by ﬁne-grained regulatory elements, making it challenging to predict the effects of sequence and
structural variants. Experimental approaches for chromatin interaction mapping remain costly and time-
consuming, limiting their use for interrogating changes of chromatin architecture associated with genomic
variation at scale. Computational models to predict chromatin interactions have either interpreted chroma-
tin at coarse resolution or failed to capture the long-range dependencies of larger sequence contexts. To
bridge this gap, we previously developed deepC, a deep neural network approach to predict chromatin
interactions from DNA sequence at megabase scale. deepC employs dilated convolutional layers to achieve
simultaneously a large sequence context while interpreting the DNA sequence at single base pair resolution.
Using transfer learning of convolutional weights trained to predict a compendium of chromatin features
across cell types allows deepC to predict cell type-speciﬁc chromatin interactions from DNA sequence
alone. Here, we present a detailed workﬂow to predict chromatin interactions with deepC. We detail the
necessary data pre-processing steps, guide through deepC model training, and demonstrate how to employ
trained models to predict chromatin interactions and the effect of sequence variations on genome
architecture.
Key words Machine learning, Deep neural networks, Gene regulation, Chromatin interactions,
Genomic variation, DeepC
1
Introduction
Mammalian gene regulation is mediated through an intricate net-
work of regulatory DNA elements comprised of promoters and
distal element, such as insulators and enhancers, that may be
located mega bases away from the gene they regulate. Enhancers
physically interact with their target promoters as they regulate gene
expression [1, 2]. The genome is folded to minimize interactions
between enhancers and nontarget promoters, providing one key
driver of enhancer-promoter speciﬁcity [1]. Therefore, to identify
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_3,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
19

20
Ron Schwessinger
the target promoter of a regulatory element of interest, we must
either measure or predict the 3D organization of the surrounding
locus. Methods such as Hi-C [3] are powerful approaches for
sampling the physical interactions of the genome, and such studies
have provided convincing evidence for the role of CTCF in orga-
nizing the genome into self-interacting domains [4, 5]. However,
CTCF binding varies little between tissues, so it remains unclear
how chromatin interactions are regulated in a programmed and cell
type-speciﬁc manner. Understanding these aspects is critical not
only for understanding basic biology but also for the interpretation
of sequence variants in regulatory regions, which often underlie
common human diseases.
Computational models sophisticated enough to predict 3D
folding directly from DNA sequence can be used to predict the
consequences of sequence variation in silico at a scale that is unfea-
sible for experimental approaches. Generating chromatin interac-
tion maps is still expensive in terms of required cell numbers,
material, and time. Interaction maps, especially at high resolution,
are usually only affordable for a limited number of cell types and
individual genomes. In contrast, computational models can be
trained on genome-wide chromatin interactions over the reference
genome and, once generalization to unseen sequences has been
conﬁrmed, can be used to predict the effect of genomic variation at
a large scale. Moreover, such models enable systematic mutation of
DNA sequences in silico. For example, predicting the effects of
deleting all annotated enhancers, promoters and CTCF sites
genome-wide to assess which are critically important to predict
chromatin interactions from DNA sequence and so likely function-
ally important for 3D genome folding [6].
Proposed methods for predicting large scale but intricate chro-
matin architecture in silico are based on polymer models [7, 8] or
other coarse-grained encodings of chromatin features such as
CTCF
binding,
histone
modiﬁcations,
and
transcription
[9, 10]. Such models inherently lack the ability to predict the effect
of small genetic variations without the use of intermediate models.
In contrast, DNA sequence-based approaches focus on predicting
interactions using window-to-window-based encodings [11–13]
neglecting the interdependence of chromatin architecture. For
example, insulator elements located adjacent to or in between
enhancer and promoter elements are likely to inﬂuence their inter-
action frequency.
Overcoming the combined limitations of existing approaches
requires learning to predict the multiscale, convoluted nature of
chromatin architecture from DNA sequence patterns that are sen-
sitive to changes at base pair resolution. Machine learning
approaches using deep neural networks have emerged as promising
tools for such tasks. Speciﬁcally, convolutional neural networks
(CNNs) have proven powerful in genomics due to their ability to

Predicting Chromatin Interactions Using DeepC
21
learn local patterns and re-apply them over larger sequence contexts
[14–16]. Dilated convolutions [17, 18] have enabled the efﬁcient
aggregation of information over large spatial contexts while main-
taining resolution. Where prediction problems proved too chal-
lenging or training data too sparse for ab initio learning, transfer
learning [19] has enabled effective model training. Layers or entire
networks can be pre-trained on an auxiliary, more tractable, task.
The learned parameters can then be used to seed a model for
training on a more challenging task.
Previously, we reported deepC [6], a neural network that com-
bines dilated convolutions and transfer learning to predict chroma-
tin interactions from DNA sequence at megabase scale. The
combination of large-scale sequence context at base pair resolution
allows deepC models to predict alterations of chromatin architec-
ture caused by genomic variation ranging from large structural
variations to single base pair variants.
Users should note that the ﬁeld of chromatin architecture
prediction is continuing to develop. Back to back with deepC,
Fudenberg et al. proposed Akita [20], a neural network for pre-
dicting chromatin interactions of multiple cell types jointly from
DNA sequence without transfer learning. More recently, further
developments focus on developments increasing the prediction
accuracy [21, 22] home in focus speciﬁcally on enhancer-promoter
interactions [23, 24] or focus on increasing the utility for applica-
tion to new cell types using chromatin features as input rather than
DNA sequence [25].
In this chapter, we describe the core deepC workﬂow for
formatting Hi-C data, training models, and using them to predict
chromatin interactions and estimate the impact of sequence varia-
tion (Fig. 1.). In brief, Hi-C data in the form of sparse intrachro-
mosomal contact matrices are encoded as a vertical zigzag pole of
chromatin interactions associated with the center of a megabase
scale genomic window (Fig. 2). The chromatin interactions are
normalized with regard to their linear distance yielding a Hi-C
skeleton
that
highlights
domain
boundaries.
Using
this
pre-processed data as training set, deepC models are trained to
predict chromatin interactions using DNA sequence as input
while holding out chromosomes for testing and validation. The
network architecture of the base deepC model is detailed in
Table 1. To train a deepC model, the user will need to supply the
pre-trained convolutional ﬁlter weights used for transfer learning.
We provide pre-trained weights for human and mouse. After eval-
uating trained models on holdout chromosomes, the ﬁnal models
are used to predict chromatin interactions over regions of interest.
By comparing the predictions over
reference- and variant-
harboring DNA sequences, the impact of variants on chromatin
architecture can be estimated. The models may also be used to ﬁne
map chromatin interactions where the original Hi-C may not

6
7
Model Training
Hi-C Interactions
Hi-C Skeleton
Chromosome
Sparse Contact Matrices
Hi-C Skeleton Files
Variant
Reference
deepC Query Files
deepC
Training Set
Concatinate
Prediction
Quantification
Pre-Processing
deepC Model
Predictions
Validation
Reference
Variant
Pre-trained
Weights
Fig. 1 Overall workﬂow for deepC analysis. Sparse Hi-C contact matrices are pre-processed, including
distance normalization to Hi-C skeleton, and encoding for deepC training (see Fig. 2) on a chromosome
basis. Processed chromosomes are concatenated to form a deepC training set. Using the training set and
pre-trained convolutional weights from chromatin feature models, a cell type-speciﬁc deepC model is trained.
After model validation, chromatin interactions over reference and variant regions can be predicted and their
difference quantiﬁed. As shortcuts, pre-processed training data and pre-trained models are available
1
2
3
4
5
6
7
2
3
4
5
1:1
2:1
7:7
7:6
6:6
6:5
5:5
5:4
4:4
4:3
3:3
3:2
2:2
Target Output Vector
Fig. 2 Overview of the deepC encoding of Hi-C data. Genomic windows of megabase size are binned into equal
sized genomic windows matching the Hi-C data resolution. All pairwise interactions in a vertical zigzag pole
over the center of the window are used as target output vector, which a deepC model predicts using the
sequence underlying the whole window. By shifting the pole and the window by bin-sized increments, the
whole Hi-C map up to a window-sized linear distance is recovered

Predicting Chromatin Interactions Using DeepC
23
Table 1
Details of the default deepC model architecture. A module of 1D convolutional layers with max
pooling and ReLU activation is followed by a module of 1D dilated convolutions with residual
connections and gated activations used in Oord et al. 2016 [42], followed by flattening and a fully
connected layer. The seeded column indicates if the convolutional filters of this layer should be
seeded with pre-trained weights
Layer Type
Hidden units Filter width Max pool width Activation Residual Seeded
1
1D Conv
300
8
4
ReLU
No
Yes
2
1D Conv
600
8
5
ReLU
No
Yes
3
1D Conv
600
8
5
ReLU
No
Yes
4
1D Conv
900
4
5
ReLU
No
Yes
5
1D Conv
900
4
2
ReLU
No
Yes
6
1D Conv
100
1
1
ReLU
No
No
Dilation rate
7
1D Dilated Conv. 100
3
1
Gated
Yes
No
8
1D Dilated Conv. 100
3
2
Gated
Yes
No
9
1D Dilated Conv. 100
3
4
Gated
Yes
No
10
1D Dilated Conv. 100
3
8
Gated
Yes
No
11
1D Dilated Conv. 100
3
16
Gated
Yes
No
12
1D Dilated Conv. 100
3
32
Gated
Yes
No
13
1D Dilated Conv. 100
3
64
Gated
Yes
No
14
1D Dilated Conv. 100
3
128
Gated
Yes
No
15
1D Dilated Conv. 100
3
256
Gated
Yes
No
16
1D Dilated Conv. 100
3
1
Gated
Yes
No
17
Fully Connected
Output size
0
Gated
Yes
No
sufﬁciently recover chromatin domains. Pre-trained models allow
users to directly start with predictions.
Throughout the chapter, links to the relevant sections of the
deepC
repository
(https://github.com/rschwess/deepC)
are
listed. Sample data used to run the example commands and tutor-
ials in the repository are part of the repository or accessible via
download links. This includes example Hi-C data for human [4]
and mouse [26] as well as exemplary DNase-seq and CTCF ChIP-
seq data [27]. Moreover, all data necessary to run the outlined
examples as well as a snapshot of the deepC github repository are
available via Zenodo under https://doi.org/10.5281/zenodo.
5785805.

24
Ron Schwessinger
2
Materials
2.1
Data
For training deepC models, intrachromosomal contact frequency
matrices are required. The matrices need to be in the resolution that
is desired for the ﬁnal deepC model (also see Note 1). Contact
matrices can be obtained from standard Hi-C data analysis pipelines
such as Hi-C-Pro [28] and are often published alongside the raw
sequencing data. Contact frequencies may be provided as raw or
normalized interaction frequencies, for example, after iterative cor-
rection and eigenvector decomposition (ICE) normalization
[29]. The deepC workﬂow was designed to handle intrachromoso-
mal chromatin interactions. The deepC data processing functions
accept contact matrices in two sparse matrix formats:
2.1.1
Hi-C Data
(a)
Three-column tab-separated ﬁle per chromosome listing
[start_coord_of_window1
start_coord_of_window2
interaction_frequency]
(b)
Two ﬁles per chromosome in Hi-C-Pro output style. A three-
column tab-separated matrix ﬁle [index_of_window1 index_-
of_window2 contact_frequency] and a coordinate ﬁle with
tab-separated three columns [chromosome position index]
linking the indices used in the matrix ﬁle to genomic windows.
For data pre-processing, we recommend processing individual
contact matrices for each chromosome. Whole genome contact
matrices in style (a) can usually be split by a simple grep command:
grep -P “chr1\s+” whole_genome.matrix >chr1_contact.matrix
For splitting HiC-Pro style (b) contact matrices, the user may
want to use the perl helper script from the deepC repository
(https://github.com/rschwess/deepC/tree/master/formatted_
data_links). Example to extract a chr2 intrachromosomal contact
matrix:
perl ./deepC/helper_for_preprocessing_and_analysis/\
extract_hicpro_matrix.pl \
--bin insitu_k652_5000_abs.bed \
--matrix insitu_k652_5000_iced.matrix \
--outmatrix insitu_k652_5000_iced.chr20.matrix \
--outbed insitu_k652_5000_abs.chr20.bed \
-chr chr2
Great starting points for published Hi-C data are Rao et al. [4]
(GSE63525) for human and Bonev et al. [26] (GSE96107) for
mouse data. Note that Hi-C matrix formats usually list equally sized
genomic windows and the genomic coordinate indicating a win-
dow usually refers to the ﬁrst genomic position of that window (the
leftmost base).

Predicting Chromatin Interactions Using DeepC
25
2.1.2
Pre-trained
Convolutional Filter
Weights for Transfer
Learning
Pre-trained convolutional ﬁlter weights for human and mouse are
available from (https://github.com/rschwess/deepC/tree/mas
ter/formatted_data_links) in .npz format. If the user chooses to
pre-train their own CNN on chromatin features, we re-direct them
to the deepHaem github repository (https://github.com/
rschwess/deepHaem), which includes detailed tutorials on data
formatting and training of CNNs for chromatin features. Once
trained, CNN ﬁlter weights can be saved by modifying and running
the run_save_weights.py script.
2.1.3
Trained Models
To skip the data processing and training steps, the user may want to
download pre-trained deepC models. Pre-trained deepC models
for seven human and one mouse cell line are provided via the deepC
repository (https://github.com/rschwess/deepC/tree/master/
models). Every directory contains a hyperparameter ﬁle listing the
exact parameters the model has been trained with. It also contains
three model.* ﬁles that together comprise a saved tensorﬂow
model.
2.1.4
Additional Data
1. Chromosome sizes ﬁle: a two-column tab-separated ﬁle listing
[chromosome size_in_bp] indicating the chromosome size for
every chromosome named in the Hi-C matrices used. These
ﬁles can be downloaded from the UCSC Sequence and Anno-
tation Database [30] (https://hgdownload.soe.ucsc.edu/
downloads.html), for example, https://hgdownload.soe.ucsc.
edu/goldenPath/hg19/bigZips/hg19.chrom.sizes
2. Whole genome fasta ﬁle and a corresponding fasta index. For
the tutorials, a chr17-only fasta ﬁle as well as a whole genome
ﬁle are available from (https://github.com/rschwess/deepC/
tree/master/formatted_data_links). For other genomes, the
user should download the respective genome-wide fasta ﬁle
from the UCSC database (e.g., https://hgdownload.soe.ucsc.
edu/goldenPath/hg19/bigZips/) and index it, for example,
with samtools faidx [31]
3. (Optional) Bigwig ﬁles of chromatin features for adding cover-
age tracks to the chromatin interaction plots.
2.2
Software
The core deepC framework was written in python 3. To run model
training and predictions, the user will need python 3.5+ and the
following python packages:
1. tensorﬂow (tensorﬂow-gpu) [32]
tensorﬂow with GPU support is preferable for predictions and
essential for model training.
deepC was developed under tensorﬂow 1.8 but also supports
1.14+ and 2.1+.
2. numpy [33]

26
Ron Schwessinger
3. h5py (http://www.h5py.org)
4. pysam (https://github.com/pysam-developers/pysam)
5. pybedtools [34] and a compatible version of bedtools [35]
installed and accessible from the command line
The data pre-processing and visualization capabilities were
implemented in R. The user will need R version 3.4.4+ (not tested
for earlier versions) and the following packages installed:
1. tidyverse (https://www.tidyverse.org)
2. optparse
3. RColorbrewer
4. Cowplot (https://github.com/wilkelab/cowplot)
5. rtracklayer
In addition, a working version of perl is required to be accessi-
ble from the command line as perl helper scripts are called from
within R to speed up data processing.
2.3
Hardware
For training deepC models, a CUDA-capable GPU is required. We
trained models on a single NVIDIA Titan V card with 12 GB of
video memory but were restricted to a batch size of 1. Users with
more video memory available are encouraged to increase the
batch size.
3
Methods
3.1
Data Pre-
processing
Hi-C contact matrices can be pre-processed for deepC model train-
ing by using the provided wrapper script (./helper_for_preprocessin-
g_and_analysis/wrapper_preprocess_hic_data.R) or by following
the steps outlined in the pre-processing tutorial (./tutorials/tutor-
ial_format_HiC_data_for_deepC.html).
3.1.1
Pre-processing
Using the Wrapper Script
1. Run the wrapper script from the command line pointing to the
chromosome-wise Hi-C input, the chromosome sizes ﬁle, and
the directory of the deepC helper scripts.
2. Indicate the bin.size (resolution) in which the Hi-C data have
been analyzed, which will determine the deepC resolution (also
see Note 2).
3. Indicate the window.size, which limits the linear distance of the
deepC model to train, usually 1 Mb + 1x bin.size so
1,005,000 bp for a 5 kb resolution model.
4. Indicate the name of chromosome processed, matching the
names in the chromosome sizes ﬁle.

Predicting Chromatin Interactions Using DeepC
27
5. Indicate if example plots of the Hi-C data and/or the skeleton
transformed data should be saved using --plot.hic and--plot.
skeleton, respectively. Provide the start and end coordinate of
the region to plot and the size ratio of the plot to produce.
6. The wrapper script will:
(a)
Extract all Hi-C interactions at a linear distance relevant
within the speciﬁed window size.
(b)
Convert the sparse matrix to the vertical zigzag pole
encoding for deepC.
(c)
Remove genomic windows that have a median interaction
value of zero. To turn this behavior off, use the --keep.
median.zero option (also see Note 3).
(d)
Impute interaction windows with an observed frequency
of 0 with the median interaction value of a 5 × 5
neighborhood.
(e)
Transform the interaction frequencies to skeleton interac-
tions. To format the Hi-C data for deepC without skele-
ton transformation, use --no.transform (also see Note 4).
(f)
Format and output single chromosome data to a text ﬁle.
(g)
(Optional) If indicated, the wrapper will produce an
example plot of the Hi-C or skeleton-transformed data
over the speciﬁed genomic region.
7. Check if other pre-trained CNN ﬁlters may be desirable (also
see Note 5).
Example command:
Rscript ./deepC/helper_for_preprocessing_and_analysis/\
wrapper_preprocess_hic_data.R \
--hic.matrix=gm12878_primary_chr17_5kb.contacts.KRnorm.ma-
trix \
--chromosome.sizes=hg19_chrom_sizes.txt \
--sample=IMR90 \
--bin.size=5000 \
--window.size=1005000 \
--chrom=chr20 \
--helper=./deepC/helper_for_preprocessing_and_analysis \
--plot.hic \
--plot.skeleton \
--plot.start=2e+06 \
--plot.end=5000000 \
--plot.height=6 \
--plot.width=8

28
Ron Schwessinger
3.1.2
Pre-processing
Manually
To run the data pre-processing steps manually, the user may follow
the outlined workﬂow. The corresponding R code is detailed in
(https://github.com/rschwess/deepC/blob/master/tutorials/
tutorial_format_HiC_data_for_deepC.html)
1. Load libraries tidyverse, cowplot, and RColorBrewer.
2. Source the R functions for Hi-C and deepC analysis published
in
the
repository
(./helper_for_preprocessing_and_analysis/
functions_for_HiC.R and ./helper_for_preprocessing_and_ana-
lysis/functions_for_deepC.R).
3. Deﬁne the bin.size of the Hi-C data and window.size to be
used for formatting.
4. Deﬁne the number of percentiles used in the skeleton transfor-
mation. Default = 10.
5. Load the chromosome sizes ﬁle.
6. Read the Hi-C data using one of the two supported sparse
matrix formats.
7. Remove all interactions between genomic windows more distal
than the deﬁned window.size.
8. Create a windowed chromosome template using the deﬁned
window.size and bin.size.
9. Remove all incomplete genomic windows that are smaller than
the desired window.size.
10. Map the sparse contact map interactions to deepC vertical
zigzag pole format (see Fig. 2) where each window is assigned
to the pair-wise interaction frequencies at increased linear dis-
tance from the center (1:1, 2:1, 2:2, 3:2, 3:3, . . .).
11. Calculate the median interaction value of the vertical zigzag
pole per window.
12. Remove windows with a median interaction frequency of zero.
13. Impute pairwise interaction frequencies of zero with the
median frequency of a 5 x 5 neighborhood.
14. Apply the skeleton transformation. Convert the interaction
frequencies in unequal percentiles: 0–20%; 20–40%; 40–50%;
50–60%;
60–70%;
70–80%;
80–85%;
85–90%;
90–95%;
95–100%.
15. (Optional) Plot Hi-C data or the skeleton for a selected region.
16. Collapse the skeleton interaction values into a single comma-
separated string per window.
17. Store in a four-column tab-separated text ﬁle listing [chromo-
some start_coordinate end_coordinate interaction_frequen-
cies] with no header.

Predicting Chromatin Interactions Using DeepC
29
3.1.3
Collate Data for
Training
Both pre-processing workﬂows will produce a four-column tab-se-
parated ﬁle listing [chromosome start_coordinate end_coordinate
interaction_frequencies], in which the interaction frequencies list
the comma-separated skeleton-transformed frequencies of the ver-
tical zigzag pole over the center of indicated genomic window. It is
recommended to process intradomain interaction matrices per
chromosome. To construct a full training dataset, concatenate all
chromosome output ﬁles into a single ﬁle:
cat
coords_and_hic_skeleton_5kb_chr*_INR90.bed
>training_-
set_5kb_IMR90.txt
3.2
Training a Model
DeepC models are trained using the respective run_training_deep-
Cregr.py script (also see Note 6). The user may follow the tutorial in
the deepC repository (https://github.com/rschwess/deepC/
blob/master/tutorials/tutorial_train_a_model.md) and use the
example bash script provided as a guide (https://github.com/
rschwess/deepC/blob/master/tutorials/example_script_deepc_
train.sh). Default values for each parameter are outlined therein. A
minimal training set of IMR90 skeleton chromatin interactions at
5
kb
resolution
is
provided
(minimal_training_set_exam-
ple_IMR90.txt). It only contains 100 training instances per chro-
mosome and therefore will not produce meaningful models but is
intended to test the training procedure. For hyperparameters, see
Notes 7–13.
1. Deﬁne the path to the local deepC repository copy.
2. Link to the training set ﬁle, which is the combination of all
processed chromosomes.
3. Select test and validation chromosomes. Performance on test
chromosomes will be checked after each epoch. Validation
chromosomes will be held out from the training process
entirely.
4. Choose
how
often
the
training
script
should
report
training loss.
5. Deﬁne the number of output classes (entries in the output
vector). For example, a 5 kb resolution model with a window
size of 1,005,000 bp has 201 outputs.
6. Specify the window size of the processed data and hence the
model.
7. Deﬁne the keep probability for the dropout layers in the ﬁrst
module.
8. Limit the maximum number of epochs and maximum number
of chromosomes over which the training should be run. Note
that the training script will stop if one of the limits is reached
(also see Note 13).

30
Ron Schwessinger
9. Deﬁne the number of training chromosomes after which the
test chromosome performance should be evaluated, and check-
points saved.
10. Deﬁne training hyperparameters: learning rate, L2 norm
strength and ADAM [36] parameters (also see Note 8).
11. Deﬁne the batch size (also see Note 9).
12. Deﬁne the network architecture of the ﬁrst module of convo-
lutional layers with max pooling. Deﬁne the number of con-
volutional layers and the respective number of hidden units,
ﬁlter width, and max pooling width. Importantly, to employ
transfer learning, the dimensions of the ﬁrst convolutional
layers should match the dimensions of the convolutional layer
weights provided in terms of the number of hidden units and
the ﬁlter widths. Larger dimensions are supported, in which
case the excess ﬁlter weights are sampled from the existing
weights. Smaller dimensions are not supported. See Table 1
and the example training script for the dimensions of the
provided human and mouse transfer learning weights. In addi-
tion, the number of hidden units of the last convolutional layer
must match the number of hidden units in the dilated convo-
lutional layers (dilation_units) (also see Notes 7 and 11).
13. Deﬁne the network architecture of the second, dilated convo-
lutional module. Specify the successive dilation rates, the num-
ber of hidden units per layer, and the width of the
convolutional ﬁlters. Importantly, the ﬁrst dilated convolu-
tional layer with a dilation rate of 1 is automatically applied
and should not be speciﬁed explicitly. Specify if residual con-
nections between the dilated layers should be applied (also see
Note 7).
14. Deﬁne the transfer learning settings. Select if to apply transfer
learning, specify which convolutional ﬁlters of the ﬁrst module
should be seeded with pre-trained ﬁlter weights, and link to the
weights ﬁle.
15. Set additional training options. Specify if the order of training
examples per chromosome should be shufﬂed before each
training epoch. Select the data type in which to temporarily
store the DNA sequence and link to an indexed whole genome
fasta ﬁle from which the training script should extract the DNA
sequence.
16. Indicate if base pairs that are soft masked in the provided
reference genome (lower case letters) should be used during
training (also see Note 12).
17. Start the training and monitor training progress via tensor-
board (also see Note 10).

Predicting Chromatin Interactions Using DeepC
31
18. Inspect the ﬁnished run via tensorboard. Ensure the training
and test loss have converged and that the test loss is lower than
the training loss. Checkpoints are saved automatically if the
current test loss is smaller than the previously lowest test loss.
Thus, the checkpoint with the highest training iteration num-
ber is the best available model in the output directory.
19. Validate trained models by predicting regions or entire chro-
mosome maps over the holdout validation chromosomes using
run_deploy_shape_deepCregr.py.
See
“Predicting
chromatin
interactions” for more details.
20. (Optional) If further training of the saved model is required,
restart the training process. Link the training script with the
path to the previously best model and enable the reloading of
an existing model.
Example command:
python ./deepC/tensorflow2.1plus_compatibility_version/\
run_training_deepCregr.py \
--data_file ./minimal_training_set_example_IMR90.txt \
--train_dir ./minimal_imr90_training \
--test_chroms chr12,chr13 \
--validation_chroms chr16,chr17 \
--report_every 1 \
--num_classes 201 \
--bp_context 1005000 \
--learning_rate 0.0001 \
--l2_strength 0.001 \
--max_epoch 1 \
--max_chroms 18 \
--save_every_chrom 3 \
--keep_prob_inner 0.8 \
--batch_size 1 \
--conv_layers 6 \
--hidden_units_scheme 300,600,600,900,900,100 \
--kernel_width_scheme 8,8,8,4,4,1 \
--max_pool_scheme 4,5,5,5,2,1 \
--dilation_scheme 2,4,8,16,32,64,128,256,1 \
--dilation_units 100 \
--dilation_width 3 \
--dilation_residual=True \
--epsilon 0.1 \
--seed_weights=True \
--seed_scheme 1,1,1,1,1,0 \
--seed_file ./saved_conv_weights_human_deepc_arch.npy.npz \
--shuffle=True \
--store_dtype bool \

32
Ron Schwessinger
--whg_fasta ./hg19.fa \
--use_softmasked=False \
--gpu 0
3.3
Predicting
Chromatin Interactions
Using a trained model, chromatin interaction predictions are run
using the python scripts: run_deploy_shape_deepCregr.py and run_-
deploy_shape_combination_deepCregr.py.
Details
of
script
para-
meters and usage are listed in the prediction tutorial (https://
github.com/rschwess/deepC/blob/master/tutorials/tutorial_
predict_and_plot.html). The resulting deepC predictions can be
visualized using the wrapper script (https://github.com/
rschwess/deepC/blob/master/helper_for_preprocessing_and_
analysis/wrapper_plot_deepc_predictions.R) or by following the
manual steps in the tutorial; both are implemented in R. Trained
models are available to download from the deepC repository and
the Zenodo archive.
3.3.1
Run Predictions
1. Construct the query ﬁles for predictions (also see Notes 14–
17). The basic format is a four-column tab-separated ﬁle indi-
cating [chromosome start_position end_position variant_-
to_apply]. The ﬁrst three columns deﬁne the genomic
position of interest in bed-like, 0-based, half-open coordinates.
The fourth column indicates the sequence variation to apply to
the region. Here, reference indicates that the sequence should
be extracted from the provided reference genome. A single dot
(no quotations) “.” indicates that the outlined sequence should
be deleted. DNA bases in [A, C, G, T, N] alphabet indicate that
the outlined genomic window should be replaced with the
provided bases regardless of them matching the reference
genome or not. Flanking regions required for the predictions
will be extracted from the provided reference genome.
2. Select the appropriate run script to use:
(a)
run_deploy_shape_deepCregr.py—processes all regions and
variants indicated in the query ﬁle separately, producing
one output per line.
(b)
run_deploy_shape_combination_deepCregr.py—applies
all
variants indicated in the query ﬁle and produces one out-
put of predicted chromatin interactions over the resulting
DNA sequence, spanning all listed genomic windows.
3. Run the respective prediction script (also see Note 18).
(a)
Link to the input query ﬁle.
(b)
Deﬁne an output directory and a name_tag for the output
ﬁles.
(c)
Link to the trained deepC model to use.

Predicting Chromatin Interactions Using DeepC
33
(d)
Link to the indexed genome fasta that should be used to
extract the DNA sequence.
(e)
Specify if bases soft masked in the fasta ﬁle should be used
or ignored.
(f)
Indicate the base pair context, the window size of the
deepC model and for the predictions.
(g)
Specify over how many base pairs of the regions ﬂanking
the query window chromatin interactions should be
predicted.
(h)
Indicate the number of classes (output vector dimension)
and the bin.size of the deepC model.
(i)
Specify if to run the prediction on a GPU, if available, or
on a CPU only.
4. The output ﬁles are plain text ﬁles. The three-header lines,
marked by a leading #, indicate: (1) the query, the genomic
window, and the variants applied; (2) the relative coordinates of
the predicted interactions (position of the vertical zigzag pole)
as determined by the genomic window, the added ﬂanking base
pairs and the variants applied; (3) the number of base pairs all
genomic coordinates following the applied variants need to be
adjusted by. The remaining lines list (tab-separated) the geno-
mic windows of window.size and the predicted chromatin
interactions of the respective central zigzag pole.
Example command:
python ./deepC/tensorflow2.1plus_compatibility_version/\
run_deploy_shape_deepCregr.py \
--input example_region_short.bed \
--out_dir ./test_predict_out \
--name_tag predict \
--model ./model_deepCregr_5kb_GM12878/model \
--genome ./hg19.fa \
--use_softmasked=False \
--bp_context 1005000 \
--add_window 500000 \
--num_classes 201 \
--bin_size 5000 \
--run_on gpu
3.3.2
Visualize
Predictions Using the
Wrapper Script
The wrapper script can be used to plot Hi-C data with or without
skeleton transformation, predicted chromatin interactions for a
reference and a variant prediction, the corresponding differential
predicted interactions, and up to three 1D genomic signals from
bigwig tracks. All plots indicated will be stacked. An example
output of the wrapper plots is shown in Fig. 3. For exact parameter

34
Ron Schwessinger
Genomic Distance [kb]
1000
750
500
250
0
1000
750
500
250
0
1000
750
500
250
0
1000
750
500
250
0
0
20
40
40
60
80
20
0
71,100,000
71,400,000
71,700,000
72,300,000
72,000,000
1000
750
500
250
0
Hi-C
Skeleton
CTCF
DHS
Reference
Variant
Difference
0
10
20
Value
7.5
2.5
5.0
10.0
6
4
2
6
4
2
2
-2
-1
0
1
Diff
Coverage
Fig. 3 Example output of Hi-C data and deepC predictions using the plotting
wrapper script. From top to bottom, shown are Hi-C data, distance normalized
Hi-C skeleton, reference sequence prediction, prediction over a 350 bp deletion
of a CTCF site, differential plot reference – variant, and DNase-seq (DHS, DNase
hypersensitivity) and CTCF ChIP-seq coverage tracks. All data and predictions
are based on GM12878

Predicting Chromatin Interactions Using DeepC
35
names, see the --help message of the wrapper script and the detailed
readme ﬁle (https://github.com/rschwess/deepC/tree/master/
tutorials).
1. Deﬁne a name tag for the plot and name for the output
directory.
2. Link to the deepC repository helper script directory.
3. Specify the bin.size and the window.size of the deepC
model used.
4. Set the genomic region to plot by deﬁning chromosome start
and end position.
5. Set the width and height of the ﬁnal plot and indicate the
relative heights (0–1) of the individual plot parts.
6. Select which plots to produce and link to the relevant input ﬁles
if a plot type was selected:
(a)
To plot Hi-C data without skeleton transformation, sup-
ply a deepC pre-processed ﬁle of untransformed data, as
obtained by running the pre-processing wrapper with the
--no.transform ﬂag. Alternatively, the Hi-C data can be
processed from the same Hi-C input ﬁles that the
pre-processing wrapper supports (also see Note 19).
(b)
To plot skeleton data, provide the deepC formatted inter-
actions, for example, as output from the pre-processing
wrapper script. Alternatively, the skeleton transformation
can be applied on the ﬂy from Hi-C data input.
(c)
To plot deepC predictions, link to the output ﬁles of the
prediction python scripts. The user can supply and plot a
reference and a variant prediction.
(d)
Differential plots (reference–variant) can be plotted and
calculated using the supplied reference and variant
deﬁnition.
(e)
To plot 1D genomic signals, supply bigwig ﬁles.
7. (Optional) Indicate if to also calculate the mean absolute inter-
action difference per pairwise interaction within the window.
size.
8. (Optional) Provide colors for the 1D genomic tracks.
9. (Optional) Set individual titles for the plot components.
10. (Optional) Check for additional comments and workﬂows in
Notes 20–25.
Example command:
Rscript ./deepC/helper_for_preprocessing_and_analysis/\
wrapper_plot_deepc_predictions.R \
--sample=gm1278_test \

36
Ron Schwessinger
--out.dir=’.’ \
--helper=./deepC/helper_for_preprocessing_and_analysis/ \
--bin.size 5000 \
--window.size 1005000 \
--chrom=chr17 \
--plot.start=71150000\
--plot.end=72250000 \
--plot.width=12 \
--plot.height=16 \
--rel.heights=’0.75,0.75,0.75,0.75,0.75,1’ \
--plot.hic \
--plot.skeleton \
--plot.deepc.ref \
--plot.deepc.var \
--plot.deepc.diff \
--calc.deepc.diff \
--hic.preprocessed=hic_5kb_chr17_GM12878_no_transform.bed \
--skeleton.input=hic_skeleton_5kb_chr17_GM12878.bed \
--deepc.ref.input=test_predict_out/\
class_predictions_predict_1_chr17_71000000_71999999.txt \
--deepc.var.input=test_variant_out/\
class_predictions_predict_variant_1_chr17_71706322_71706671.
txt \
--plot.tracks \
--track.input.1=./dnase_gm12878_encode_uw_merged_w50.bw \
--track.input.2=./ctcf_gm12878_encode_broad_merged_w50.bw \
--track.colour.1=#756bb1 \
--track.colour.2=#e41a1c
3.3.3
Visualize
Predictions Manually
To visualize predictions manually, follow the R tutorial (https://
github.com/rschwess/deepC/blob/master/tutorials/tutorial_
train_a_model.md). The tutorial runs through the basic data
reading and plot functionalities that can be combined to produce
the user’s desired visualizations. The basic steps are outlined here:
1. Load libraries tidyverse, cowplot, and RColorBrewer. Load
rtracklayer if the plotting of 1D signals from bigwig tracks is
desired.
2. Source the R functions for Hi-C and deepC analysis published
in the repository (./functions_for_HiC.R and ./functions_for_-
deepC.R).
3. Deﬁne the bin.size of the Hi-C data and window.size to use for
formatting.
4. Deﬁne the number of percentiles used in the skeleton transfor-
mation. Default = 10.
5. Read deepC prediction ﬁles as output from the prediction
python scripts.

Predicting Chromatin Interactions Using DeepC
37
6. Read Hi-C data from pre-processed or supported Hi-C input
data types.
7. Read the skeleton-transformed Hi-C data from pre-processed
ﬁles or perform the skeleton transformation using the
Hi-C data.
8. Convert every chromatin interaction data frame to a ggplot2-
compatible
long
format
for
plotting
interactions
(triangularize).
9. Plot chromatin interactions, observed, normalized, or pre-
dicted, using ggplot2 [37] geom_polygon.
10. Import bigwig ﬁles by deﬁning a GRange object [38] over the
desired region and sub-setting the bigwig ﬁles over those
ranges.
11. Plot bigwig signals using ggplot2 geom_area.
12. Create differential plots (reference – variant).
13. Calculate the mean absolute interaction difference per pairwise
interaction within window.size.
14. Arrange multiple plots using cowplot.
4
Notes
1. DeepC can be used to ﬁne-map chromatin interactions at
resolutions at which the Hi-C contact frequencies start to
become sparse [39].
2. Due to the vertical zigzag pole interaction data encoding,
window.size / bin.size must be an odd number. When experi-
encing errors in the formatting script, the user should try
adding 1 × bin.size to the chosen window.size.
3. By default, deepC pre-processing removes genomic windows
where the median of the vertical zigzag pole interactions is 0 to
focus on genomic windows with more interaction structure.
The user may want to test the result of keeping these windows
in the training set.
4. The skeleton normalization was only tested using raw and
ICE-normalized contact frequencies. If the user chooses a
different normalization, they should ensure that the skeleton
transformation still produces an adequate representation of the
Hi-C data, for example, by visual inspection or by training a
deepC model without skeleton transformation.
5. The provided CNN ﬁlter weights were trained on a compen-
dium of chromatin feature data from ENCODE [27] and other
publicly available resources. The data composition largely fol-
lows deepSEA [14]. We observed good performance of these

38
Ron Schwessinger
pre-trained ﬁlters for a variety of other tasks. However, users
may choose to pre-train their own weights, including or focus-
ing on different cell types or chromatin feature data. We rec-
ommend designing this compendium as broad as possible.
Note that it is not essential for the chromatin feature compen-
dium to include matching chromatin features of the exact cell
type for which a deepC model should be trained. For related
deep learning tasks, pre-seeding with TF motifs, for example,
from the JASPAR motif database [40] has proven successful
[41] and users may want to experiment with this approach.
6. For training of a deepC model, GPU support is essential.
7. Hyperparameters for the original deepC model were optimized
using grid search. Resources permitting, users are encouraged
to further optimize hyperparameters for their given Hi-C data,
for example, using more advanced optimization strategies, such
as Bayesian optimization.
8. Although we observed good results with a learning rate of
0.0001, the user may need to adjust the learning rate when
working Hi-C data substantially different from the data ana-
lyzed in the original deepC paper [4, 26].
9. In the original deepC model/publication, hardware limitations
restricted us to a batch size of 1. This batch size leads to
substantial ﬂuctuations of training loss per iteration. Hardware
permitting, users are encouraged to trial larger batch numbers.
10. When inspecting deepC model training progression, the train-
ing loss is best smoothed over a considerable number of train-
ing steps, for example, by using the smoothing slider of
tensorboard. In contrast, the test loss is best inspected without
smoothing.
11. For the dilated module architecture, the dilation rates should
be increasing exponentially using a consistent base to ensure a
fast-growing receptive ﬁeld and equal coverage. This is usually
referred to as a dilated stack [42], and other works have used
multiple stacks in their architecture. When using a single stack
as in the default deepC architecture, using at least one ﬁnal
dilated layer with a dilation rate of 1 ensures a denser feature
representation per position.
12. By default, deepC training ignores soft-masked base pairs.
They are treated as N’s. We did not observe obvious differences
between models trained with or without soft masked base
pairs. Users particularly interested in repeat sequences should
train models including those base pairs.
13. Although deepC models usually converge fast after training on
three to six chromosomes, it is recommended to train for at
least one full epoch over all training chromosomes. We usually

Predicting Chromatin Interactions Using DeepC
39
did not see improvements when training for longer than one
full epoch.
14. The basic prediction query ﬁles allow for a wide range of
prediction tasks. Note that query ﬁles should use the 0-based
half-open coordinates as for bed ﬁles. For example:
(a)
To predict the interactions of a larger window of reference
sequence, supply a larger window for reference prediction
[chr17 71000000 72000000 reference].
(b)
To predict the impact of a single base pair change, run
predictions for the reference and the variant case [chr17
71000000
71000001
G]
and
[chr17
71000000
71000001 A]
(c)
To predict the effect of a deletion, use the dot notation
[chr17 71000000 71000011 .] and compare it to the
reference
prediction
[chr17
71000000
71000011
reference]
(d)
To predict the effect of an insertion, provide more DNA
bases in the fourth column than the size of the genomic
window indicates [chr17 71000000 71000001 GATAA].
(e)
Deletions and insertions lead to a relative shift of the
downstream chromatin interactions. Depending on the
size of the deletion, this shift effect may mask any ﬁner
detail of chromatin interactions that changes when plot-
ting differential plots and summarizing the difference.
One alternative is to replace the deleted DNA sequence
with a matching number of N’s [chr17 71000000
71000011 NNNNNNNNNN]. This removes the inter-
action shift effect. However, this encoding does not accu-
rately reﬂect the resulting DNA structure, and border
effects, such as the formation of novel binding sites at
the deletion junction, will not be captured, and sizes of
merged TADs may not be accurately reﬂected.
15. The size of insertions or replacement DNA sequence is only
limited by ﬁle size and memory restrictions. Large genomic
windows can be replaced by DNA sequences of kilo and even
mega bases using the basic format. For example, the user may
construct a long fasta sequence with multiple modiﬁcations
and supply the sequence in the fourth column of the query
format to replace a designated large genomic window.
16. Combinatorial mutations can be applied using the run_de-
ploy_shape_combination_deepCregr.py script. Every line of the
query ﬁle will be applied to the reference DNA sequence in
order of the genomic positions. The relative positions of the
variants to be applied will stay intact. For example, in the case
of two deletions being applied to a large DNA sequence, the

40
Ron Schwessinger
coordinates of the second deletion are not affected by the ﬁrst
deletion. Coordinates of the second deletion should be sup-
plied as matching to the reference genome coordinates.
17. Adding several hundred kilo bases of ﬂanking regions to the
predictions usually allows to visualize and place predicted inter-
actions in better context.
18. Running predictions using only a CPU support is possible but
GPU access speeds up the process signiﬁcantly. As a rough
guide, predicting chromatin interactions over several mega
bases may take about 5 min using a GPU and 2 h using a CPU.
19. While the wrapper script can pre-process and skeleton trans-
form the Hi-C data on the ﬂy, it is recommended to
pre-process
and
save
the
Hi-C
separately
using
the
pre-processing wrapper script. Using pre-processed ﬁles speeds
up the plotting wrapper script signiﬁcantly. Likely, users will
run the wrapper script several times to select plotting compo-
nents and optimize the visualization.
20. The provided reference prediction does not have to match the
reference genome, for example, the user may compare the
impact of two different genomic variants relative to each other.
21. It may prove useful to create a single long reference prediction
and subset it for plotting over various regions of interest.
22. If a reference prediction is available, interactions over variants
need only be computed over the regions within window.size of
the variant. To still visualize the variant chromatin interactions
in a wider context, use the --ﬁll.deepc.var ﬂag to complete the
region of interest with the supplied reference predictions.
23. It is often helpful to highlight the position of a genomic
variant, for example, with a vertical dashed line, and to high-
light the diagonal from the variant that indicates all pairwise
interactions with the variant genomic bin. The slope for this
diagonal is 2/bin.size.
24. To assess the potential impact of multiple variants, the user may
choose to only calculate the mean absolute interaction differ-
ence
of
all
predicted
variants
and
visualize
only
prioritized ones.
25. When estimating the impact of InDels or other variations that
introduce or remove a substantial number of DNA base pairs,
the shifting effect needs to be taken into consideration, and N
masking might prove more appropriate.

Predicting Chromatin Interactions Using DeepC
41
References
1. Hanssen LLP, Kassouf MT, Oudelaar AM et al
(2017)
Tissue-speciﬁc
CTCF-cohesin-
mediated
chromatin
architecture
delimits
enhancer interactions and function in vivo.
Nat Cell Biol 19:952–961. https://doi.org/
10.1038/ncb3573
2. Deng W, Lee J, Wang H et al (2012)
Controlling long-range genomic interactions
at a native Locus by targeted tethering of a
looping factor. Cell 149:1233–1244. https://
doi.org/10.1016/J.CELL.2012.03.051
3. Lieberman-Aiden E, van Berkum NL, Williams
L et al (2009) Comprehensive mapping of
long-range interactions reveals folding princi-
ples of the human genome. Science 326:289–
293.
https://doi.org/10.1126/science.
1181369
4. Rao SSP, Huntley MH, Durand NC et al
(2014) A 3D map of the human genome at
Kilobase resolution reveals principles of chro-
matin looping. Cell 159:1665–1680. https://
doi.org/10.1016/j.cell.2014.11.021
5. Nora EP, Goloborodko A, Valton AL et al
(2017) Targeted degradation of CTCF decou-
ples local insulation of chromosome domains
from
Genomic
compartmentalization.
Cell
169:930.e22–944.e22. https://doi.org/10.
1016/j.cell.2017.05.004
6. Schwessinger R, Gosden M, Downes D et al
(2020) DeepC: predicting 3D genome folding
using megabase-scale transfer learning. Nat
Methods 17:1118–1124. https://doi.org/10.
1038/s41592-020-0960-3
7. Bianco S, Lupia´n˜ez DG, Chiariello AM et al
(2018) Polymer physics predicts the effects of
structural variants on chromatin architecture.
Nat Genet 50:662–667. https://doi.org/10.
1038/s41588-018-0098-8
8. Buckle A, Brackley CA, Boyle S et al (2018)
Polymer simulations of heteromorphic chro-
matin predict the 3D folding of complex Geno-
mic Loci. Mol Cell 72:786.e11–797.e11.
https://doi.org/10.1016/j.molcel.2018.
09.016
9. Belokopytova PS, Nuriddinov MA, Mozheiko
EA et al (2020) Quantitative prediction of
enhancer–promoter interactions. Genome Res
30:72–84. https://doi.org/10.1101/gr.
249367.119
10. Zhang S, Chasman D, Knaack S, Roy S (2019)
In silico prediction of high-resolution Hi-C
interaction matrices. Nat Commun 10:5449.
https://doi.org/10.1038/s41467-019-
13423-8
11. Whalen S, Truty RM, Pollard KS (2016)
Enhancer–promoter interactions are encoded
by complex genomic signatures on looping
chromatin. Nat Genet 48:488–496. https://
doi.org/10.1038/ng.3539
12. Schreiber J, Libbrecht M, Bilmes J, Noble WS
(2017) Nucleotide sequence and DNaseI sen-
sitivity are predictive of 3D chromatin architec-
ture. bioRxiv 103614. https://doi.org/10.
1101/103614
13. Li W, Wong WH, Jiang R (2019) DeepTACT:
predicting 3D chromatin contacts via boot-
strapping deep learning. Nucleic Acids Res
47:e60–e60. https://doi.org/10.1093/nar/
gkz167
14. Zhou J, Troyanskaya OG (2015) Predicting
effects
of
noncoding
variants
with
deep
learning–based sequence model. Nat Methods
12:931–934. https://doi.org/10.1038/
nmeth.3547
15. Kelley DR, Snoek J, Rinn JL (2016) Basset:
learning the regulatory code of the accessible
genome with deep convolutional neural net-
works. Genome Res 26:990–999. https://doi.
org/10.1101/gr.200535.115
16. Alipanahi B, Delong A, Weirauch MT, Frey BJ
(2015) Predicting the sequence speciﬁcities of
DNA- and RNA-binding proteins by deep
learning.
Nat
Biotechnol
33:831–838.
https://doi.org/10.1038/nbt.3300
17. Kelley DR, Reshef YA, Bileschi M et al (2018)
Sequential regulatory activity prediction across
chromosomes with convolutional neural net-
works. Genome Res 28:739–750. https://doi.
org/10.1101/gr.227819.117
18. Yu F, Koltun V (2015) Multi-scale context
aggregation by dilated convolutions
19. Yosinski J, Clune J, Bengio Y, Lipson H (2014)
How transferable are features in deep neural
networks? Adv Neural Inf Proces Syst 4:
3320–3328
20. Fudenberg G, Kelley DR, Pollard KS (2020)
Predicting 3D genome folding from DNA
sequence with Akita. Nat Methods 17:1111–
1117. https://doi.org/10.1038/s41592-
020-0958-x
21. Zhou J (2021) Sequence-based modeling of
genome 3D architecture from kilobase to
chromosome-scale.
bioRxiv
2021.05.19.444847. https://doi.org/10.
1101/2021.05.19.444847
22. Zheng X, Wang J, Wang C (2021) HiCArch: a
deep
learning-based
Hi-C
data
predictor.
bioRxiv 2021.11.26.470146. https://doi.
org/10.1101/2021.11.26.470146
23. Cao F, Zhang Y, Cai Y et al (2021) Chromatin
interaction
neural
network
(ChINN):
a
machine learning-based method for predicting
chromatin interactions from DNA sequences.

33.
42
Ron Schwessinger
Genome Biol 22:1–25. https://doi.org/10.
1186/S13059-021-02453-5/FIGURES/8
24. Chen K, Zhao H, Yang Y (2021) Capturing
large genomic contexts for accurately predict-
ing enhancer-promoter interactions. bioRxiv
2021.09.04.458817. https://doi.org/10.
1101/2021.09.04.458817
25. Das A, Yang R, Gao V, et al Epiphany: predict-
ing
the
Hi-C
Contact
Map
from
1D
Epigenomic Data
26. Bonev B, Mendelson Cohen N, Szabo Q et al
(2017) Multiscale 3D genome rewiring during
mouse neural development. Cell 171:557.
e24–572.e24. https://doi.org/10.1016/j.
cell.2017.09.043
27. The ENCODE Project Consortium (2004)
The ENCODE (ENCyclopedia Of DNA Ele-
ments) Project. Science (New York, NY) 306:
636–640. https://doi.org/10.1126/science.
1105136
28. Servant N, Varoquaux N, Lajoie BR et al
(2015) HiC-Pro: an optimized and ﬂexible
pipeline for Hi-C data processing. Genome
Biol 16:259. https://doi.org/10.1186/
s13059-015-0831-x
29. Imakaev M, Fudenberg G, McCord RP et al
(2012) Iterative correction of Hi-C data reveals
hallmarks of chromosome organization. – Sup-
plement. Nat Methods 9:999–1003. https://
doi.org/10.1038/nmeth.2148
30. Karolchik D, Hinricks AS, Furey TS et al
(2004) The UCSC table browser data retrieval
tool. Nucleic Acids Res 32. https://doi.org/
10.1093/NAR/GKH103
31. Li H, Handsaker B, Wysoker A et al (2009)
The sequence alignment/map format and
SAMtools.
Bioinformatics
25:2078–2079.
https://doi.org/10.1093/bioinformatics/
btp352
32. Abadi M, Barham P, Chen J, et al (2016) Ten-
sorFlow: a system for large-scale machine
learning. In: 12th USENIX Symposium on
Operating Systems Design and Implementa-
tion (OSDI ’16), p 265–284
van der Walt S, Colbert SC, Varoquaux G
(2011) The NumPy array: a structure for
efﬁcient numerical computation. Comput Sci
Eng 13:22–30. https://doi.org/10.1109/
MCSE.2011.37
34. Dale RK, Pedersen BS, Quinlan AR (2011)
Pybedtools: a ﬂexible Python library for manip-
ulating genomic datasets and annotations. Bio-
informatics (Oxford, UK) 27:3423–3424.
https://doi.org/10.1093/BIOINFORMAT
ICS/BTR539
35. Quinlan AR, Hall IM (2010) BEDTools: a
ﬂexible suite of utilities for comparing genomic
features. Bioinformatics 26:841–842. https://
doi.org/10.1093/bioinformatics/btq033
36. Kingma DP, Ba J (2014) Adam: a method for
Stochastic Optimization. https://doi.org/
http://doi.acm.org.ezproxy.lib.ucf.
edu/10.1145/1830483.1830503
37. Wickham H (2009) ggplot2: elegant graphics
for data analysis. Springer, New York
38. Lawrence M, Huber W, Page`s H et al (2013)
Software for computing and annotating geno-
mic ranges. PLoS Comput Biol 9:e1003118.
https://doi.org/10.1371/JOURNAL.PCBI.
1003118
39. Schwessinger R, Gosden M, Downes D et al
(2020) DeepC: predicting 3D genome folding
using megabase-scale transfer learning. Nat
Methods. https://doi.org/10.1038/s41592-
020-0960-3
40. Sandelin A, Alkema W, Engstro¨m P et al
(2004) JASPAR: an open-access database for
eukaryotic transcription factor binding proﬁles.
Nucleic Acids Res 32:D91–D94. https://doi.
org/10.1093/nar/gkh012
41. Quang D, Xie X (2016) DanQ: a hybrid con-
volutional and recurrent deep neural network
for
quantifying
the
function
of
DNA
sequences.
Nucleic
Acids
Res
1:032821.
https://doi.org/10.1101/032821
42. Oord A van den, Dieleman S, Zen H, et al
(2016) WaveNet: a generative model for Raw
Audio. In: 2009 IEEE International Confer-
ence on Acoustics, Speech and Signal Proces-
sing, p 3437–3440

Chapter 4
Integrating Single-Cell Methylome and Transcriptome Data
with MAPLE
Yasin Uzun, Hao Wu, and Kai Tan
Abstract
As a mechanism of epigenetic gene regulation, DNA methylation has crucial roles in developmental and
differentiation programs. Thanks to the recently introduced bisulﬁte-sequencing-based methods, it is
possible to proﬁle the entire methylome at single-cell resolution. However, analysis of single-cell methy-
lome data is challenging due to data sparsity and moderate correlation with transcript level. Our recently
developed computational framework, MAPLE, addresses these challenges using supervised learning mod-
els. Using both genomic sequence and methylation information as the input, MAPLE predicts activity for
each gene, which can be used to integrate with transcriptome data from the same cell types. Here, we
provide an overview of our method and detailed guidance on how to use it for the integration of methylome
and transcriptome data.
Key words DNA methylation, Single-cell, Epigenomics, Multi-omics, Data integration
1
Introduction
DNA methylation is a major epigenetic mechanism of gene regula-
tion. Due to its vital role in development and disease, methylation
of DNA has long been studied using both microarray and next-
generation sequencing technologies. Because of its genome-wide
and quantitative nature, bisulﬁte sequencing is regarded as the
gold-standard technology for methylome proﬁling [1]. The advent
of single-cell sequencing methods has revolutionized biology,
revealing unprecedented molecular and cellular heterogeneities at
genetic, epigenetic, and microenvironmental levels. For DNA
methylation, many bisulﬁte conversion-based protocols have
recently been developed for proﬁling the DNA methylome at sin-
gle-cell resolution [2–13], leading to an exponential growth of
single-cell methylome data.
Despite the rapid accumulation of single-cell methylome data,
its interpretation presents formidable challenges, especially for
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_4,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
43

44
Yasin Uzun et al.
genome-wide datasets. First, unlike transcriptome or chromatin
accessibility data, single-cell bisulﬁte sequencing data is not just
concentrated at coding regions or regulatory regions. As a result,
such data is inherently sparse, and short genomic regions such as
gene promoters contain a limited number of cytosine sites, making
the estimation of methylation level across a genomic region difﬁ-
cult. The data sparsity makes imputation a necessity for performing
high-dimensional data analysis such as principal component
analysis.
Cell type annotation is another challenge for methylome data
for the following reasons. First, the correlation between transcrip-
tion and methylation is dependent on cell type. Although it is
generally observed that there is a positive correlation between
gene body methylation and transcription level, it is not the case in
mammalian neurons [3, 14]. Second, regarding the more general
negative correlation between gene promoter methylation and gene
transcription level, recent single-cell dual-omic assay proﬁling both
modalities have revealed that only a small number of genes follow
this trend. In contrast, promoter methylation of many genes is
positively correlated with transcription level or not correlated at
all [10, 11, 15, 16]. Hence, there is not a single universal relation-
ship between DNA methylation and gene activity level.
One approach to annotate cell types in methylome data is
integration of methylome data with transcriptome data if matched
datasets are available. Several methods have been developed for
integrating different single-cell data modalities generated using
the same tissue type [17–19]. Although those methods have been
demonstrated to have good performance, their performance
depends on the quality of the gene-by-cell activity matrices used
as the input. Unlike transcriptome data, for the reasons described
above, generating a reliable gene-by-cell activity matrix is challeng-
ing for methylome data. Thus, a reliable method is needed to
generate such a matrix for any downstream analysis. Our computa-
tion framework, termed MAPLE (Methylome Association by Pre-
dictive Linkage to Expression), addresses this problem using a
supervised learning approach and generates a reliable methylome-
based gene activity matrix [20].
2
Materials
MAPLE uses four types of inputs provided by the user as follows:
1. CpG methylation calls: This is a set of bed ﬁles describing the
genomic coordinates of CpG sites and the number of methy-
lated cytosines for each site, as described in Table 1. A separate
ﬁle is expected per individual cell. They can be generated using
the Bismark software [21].



Single-Cell Methylome-Transcriptome Integration with MAPLE
45
Table 1
Format of the input files containing the CpG methylation call information
Chr.
Start
End
Methylation Pct.
Methylated C Count
Unmethylated C count
chr1
3003226
3003227
100
2
0
chr1
3026310
3026311
0
0
1
chr1
3060607
3060608
100
1
0
...
...
...
...
...
...
Table 2
Format of the gene coordinate file containing the annotation information
Chr.
Start
End
Strand
Gene ID
Gene symbol
Gene biotype
chr10
100042193
100081877
ENSG00000120054
CPN1
protein_coding
chr10
100150094
100188334
ENSG00000107566
ERLIN1
protein_coding
chr10
100347124
100364834
+
ENSG00000099194
SCD
protein_coding
...
...
...
...
...
...
...
Gene coordinates: This is a seven-column bed ﬁle describ-
ing the genomic coordinates of the genes as described in
Table 2. This annotation is available for human and mouse
through the MAPLE project repository at https://github.
com/tanlabcode/MAPLE.1.0. The annotation ﬁles for other
organisms can be obtained from the Ensembl genome archive
(https://www.ensembl.org/index.html).
2. CpG contents: This is a gene-by-genomic bin matrix. Each
row is a gene, each column is a genomic bin, and the values are
the CpG content of the bin, ranging from 0 to 1. The ﬁle is an
R object ﬁle in RDS format. These inputs are also available for
human and mouse genes through the MAPLE project reposi-
tory at https://github.com/tanlabcode/MAPLE.1.0.
3. Trained classiﬁer models: These are the pre-trained models
for the three classiﬁers. The models were trained using single-
cell dual-omics datasets. The model ﬁle for CNN is in “hd5”
format compatible with the R keras package, whereas the mod-
els for RF and EN models are R objects of “randomForest”
and “cv.glmnet” classes, respectively, in the RDS format. The
pre-trained models using four different single-cell dual-omics
datasets are available through the MAPLE project repository at
https://github.com/tanlabcode/MAPLE.1.0 and can directly
be used for mammalian species.

46
Yasin Uzun et al.
3
Methods
3.1
Overview
of MAPLE
To train a predictive model, MAPLE takes advantage of data gen-
erated by single-cell dual-omics assays, which proﬁle the gene
expression and methylation levels in the same cells. Using such
data as inputs, we trained supervised-learning models to predict
the gene activities from bisulﬁte sequencing data. Using the trained
models, MAPLE infers gene activities using only single-cell methy-
lome data for each cell, which in turn can be used for downstream
analysis.
MAPLE uses the genomic and methylation information gath-
ered from the 5 kb region ﬂanking the transcription start site (TSS)
of each gene. Since the relative importance of methylated cytosines
for predicting gene activity depends on their distance to the TSS
[20], the promoter regions are divided into 500 bp bins, and two
features are computed for each bin. The ﬁrst feature is CpG con-
tent, which is deﬁned as the ratio of number of CpG dinucleotides
to total number of dinucleotides in the bin. This feature accounts
for the differences in genomic sequence content among different
genes. The second feature is CpG methylation rate, which is
deﬁned as the ratio of methylated CpG sites to total number of
CpG sites. By combining these two features for each bin, MAPLE
generates a feature set, which is used as the input for predicting
gene activity.
As mentioned above, a major challenge in single-cell methy-
lome data analysis is the inherent sparsity of the data. Even very
deep sequencing can only cover a small fraction of all CpG sites in
the genome, resulting in many bins with insufﬁcient numbers of
CpG calls to estimate the methylation rate of the bin and subse-
quently inference of gene activity. MAPLE addresses the sparsity
problem by utilizing the concept of meta cell [22] as follows. First,
methylation rates are computed for all gene-cell pairs, by using the
overall methylation rate of the 5 kb region ﬂanking the TSS. Miss-
ing values are imputed by using the column average of the gene-by-
cell methylation rate matrix, that is, for cells with insufﬁcient num-
ber of cytosine calls, the average methylation rate of all cells is used.
Next, principal component analysis (PCA) is performed on this
methylation rate matrix. Pairwise distances between cells are com-
puted using values based on top PCA components explaining the
greatest variance in the data. Then for each cell, a meta-cell is
generated, by combining the neighboring cells based on pairwise
distance. The methylation rate of the cell is calculated by using all
the cytosine calls in the meta-cell. By using this approach, the
number of bins with insufﬁcient cytosine calls is vastly reduced
and a robust inference can be achieved.
Using the CpG content and methylation rate features com-
puted based on meta-cells, MAPLE predicts the activity for each

Single-Cell Methylome-Transcriptome Integration with MAPLE
47
gene and cell pair. Three classes of statistical classiﬁers are used for
the prediction: random forest, convolutional neural network, and
elastic net regression. Gene activities are predicted by all three
classiﬁers, and the mean of the three predictions is used as the
ﬁnal predicted value. We pre-trained each classiﬁer using four sin-
gle-cell dual-omics datasets [10, 11, 15, 16] and made these mod-
els available through the project repository at https://github.com/
tanlabcode/MAPLE.1.0. MAPLE is an open-source software
implemented in R statistical programming language and is publicly
available under the MIT license.
MAPLE predicts gene activities using CpG methylation calls
provided by the user in bed ﬁle format. In addition to methylation
calls, MAPLE requires two annotation ﬁles. The ﬁrst annotation ﬁle
contains gene coordinates in bed format, which is used for extract-
ing transcription start sites (TSS) information. The second annota-
tion ﬁle contains the CpG contents of the genomic bins, which are
generated using the reference genome sequence of the organism
under study.
The ﬁrst task of MAPLE is generating promoter regions
(deﬁned as upstream and downstream 5 Kb of TSS) across the
genome. Each promoter region is divided into 500 bp bins. Next,
the CpG sites in the promoter region including both methylated
and unmethylated sites are identiﬁed.
Meta-cells are computed in the second step. Using the total
cytosine calls in a promoter region, the methylation rate of each
promoter-cell pair is calculated. PCA is computed for the gene
promoter-by-cell
methylation
matrix,
and
pairwise
distances
between the cells are calculated using the principal components
explaining the greatest variance. Finally, meta-cells are computed
based on the cell-cell pairwise distances.
After the meta-cells are computed, gene activity predictions are
made for each cell by each classiﬁer. The mean of three predictions
is used as the single output for each cell-gene pair, and the ensemble
predictions are converted into a gene-by-cell activity matrix. This
activity matrix can be analyzed directly or integrated with matching
transcriptome and/or epigenome data using existing data integra-
tion methods such as Seurat [17], Harmony [19], or LIGER [18].
3.2
Methylome
Matrix Construction
Cell-speciﬁc gene activities are computed using MAPLE in eight
steps as follows (Fig. 1):
1. Methylation calls for promoter bins are computed with the
compute_binned_met_counts function. The inputs to the
function are the gene coordinates ﬁle (annot_file) and the
directory path containing the CpG call ﬁles (cov_dir). The
CpG methylation rates of the promoter bins are calculated for
each gene and cell pair. The output is a list of two elements.
The ﬁrst element is a matrix of methylated cytosine counts for

48
Yasin Uzun et al.
Fig. 1 Flowchart showing methylome-based gene activity prediction using MAPLE. Green color represents
input, blue color represents intermediate results, and yellow color represents the output. CNN convolutional
neural network, RF random forest, EN elastic net regression
the promoter bins. Each row corresponds to a cell-gene pair,
and each column corresponds to a bin (numbered 1 to 20).
The second element is the same as the ﬁrst one but for
unmethylated cytosines.
2. Meta-cells are generated with the
compute_meta_cells
function. The inputs to the function are the matrices of methy-
lated
(df_met) and unmethylated (df_demet) CpG call
counts for the promoter bins, which are computed in the ﬁrst
step and saved in the list. The overall methylation rates of the
promoters are calculated and then used for PCA. Pairwise cell-
cell distances are computed using top principal components to
determine cell neighborhoods. Each cell and its nearest neigh-
bors are deﬁned as a meta-cell. Methylation levels of the meta-
cells are calculated using all cells in the neighborhood. The
number of nearest neighbors is set using the num_neighbors
parameter, which defaults to 20 (see Note 1).
3. Features for gene activity prediction are generated with the
get_fr_list function. The inputs are the meta-cell objects
(meta_object) computed in the previous step and the CpG
content ﬁle (cpg_content_file) for promoter bins. Missing
values in the methylation rate matrix are imputed by the pro-
moter average of all cells in the dataset. Cell-gene pairs with a
large number of bins with missing values, as determined by the
max_na_bins parameter (default is 5), can be excluded in this
step (see Note 2). The methylation rates and CpG contents are
combined into a single feature matrix for elastic net regression
and random forest and a three-dimensional array for convolu-
tional neural network (CNN). The output of this function is a
list containing the feature matrix and array.

Single-Cell Methylome-Transcriptome Integration with MAPLE
49
4. Methylome-based gene activities are computed using CNN
model with the cnn_predict function. The inputs are the
list of features computed in step 3 (fr_list) and the hd5
formatted pre-trained CNN model ﬁle (model_file). The
output is a vector of predicted activities for all cell-gene pairs.
5. Methylome-based gene activities are computed using Elastic-
Net regression model (EN) with the elastic_predict func-
tion. The inputs are the same as step 4, except that the
pre-trained model ﬁle is in the RDS ﬁle format (elastic_mo-
del_file) for the cv.glmnet object. The output is a vector of
predicted activities for all cell-gene pairs.
6. Methylome-based gene activities are computed using random
forest model (RF) with the rf_predict function. The inputs
are the same as step 4, except that the pre-trained model is in
the RDS ﬁle format (rf_model_file) for the randomForest
object. The output is a vector of predicted activities for all cell-
gene pairs.
7. The three predictions (CNN, EN, RF) are combined into one
output with the ensemble_predict function. The inputs are
the list of three vectors, corresponding to the three predictions
obtained in steps 4, 5, and 6 (prediction_list). The ﬁnal
gene activity scores for the cell-gene pairs are computed with this
function by using the mean of three predictions (see Note 3).
8. Cell-by-gene activity matrix is constructed using the con-
vert_preds_to_matrix function. The input is the vector
of ensemble gene activity predictions. The input vector is con-
verted to a two-dimensional gene-by-cell matrix as the output.
3.3
Downstream
Analysis
Once the gene activity matrix is generated from the methylome
data, any computational tools for single-cell genomic data can be
used to analyze this data. Here, we describe the data processing
steps for Seurat [17], as it is widely used in the biomedical research
community.
1. A Seurat object is constructed with the CreateSeuratOb-
ject function by providing the MAPLE predicted activity
matrix as the input count matrix and the assay name parameter
set to “MET.”
2. Predicted gene activity matrix is normalized using the
SCTransform function [23], providing the initialized object
as the input.
3. Highly variable features in the gene activity matrix are selected
and used for dimensionality reduction with the FindVaria-
bleFeatures function using the output generated in step 2.

50
Yasin Uzun et al.
4. The highly variable features are scaled with the ScaleData
function so that mean activity per gene is 0 and variance is
1, using the output of step 3 as the input.
5. Principal component analysis (PCA) is performed on the object
generated in step 4 to identify the principal components in the
activity matrix, using the RunPCA function on the output of
step 4. A UMAP (Uniform Manifold Approximation and Pro-
jection) [24, 25] dimensionality reduction is generated using
the RunUMAP function and the PCA result as the input.
6. A shared nearest neighbor (SNN) graph is constructed for the
cells in the population with the FindNeighbors function.
Next, ﬁnd cell clusters in the data using the FindClusters
function. Provide the Seurat object as the input for both
functions.
7. Gene activity pattern of the marker genes is investigated with the
FeaturePlot and VlnPlot functions for the individual clusters,
providing the object generated in step 6 and the list of marker
genes for the expected cell types as the input (see Note 4).
8. Differentially activated genes are identiﬁed based on the
MAPLE result, using the FindMarkers function, providing
the object with the clustering result as the input (see Note 5).
Visualize the results with the DoHeatmap function. The cell
type annotations can be assigned to the clusters identiﬁed in the
dataset based on the output of steps 7 and 8.
9. A column is added to the metadata of the Seurat object by
using the AddMetaData function with the Seurat object as the
input, metadata parameter set to “MET” and col.name set to
“tech” for the purpose of integration.
3.4
Integration
Methylome and matching transcriptome datasets can be integrated
by using MAPLE-predicted gene activity matrices as the input for
any single-cell integration tool. In here, we provide the integration
of MAPLE-predicted gene activities with transcriptome data using
Seurat [17] as follows (Fig. 2):
1. For the matching transcriptome dataset, execute steps 1–5
described in “Downstream Analysis.” Set the assay name
parameter to “RNA” and the “tech” metadata column to
“RNA.”
2. Select the integration features with the SelectIntegra-
tionFeatures function, providing transcriptome and methy-
lome objects as the input.
3. Prepare the two objects for integration with the PrepSCTIn-
tegration function, using the list of two objects and the
selected features as input.

Single-Cell Methylome-Transcriptome Integration with MAPLE
51
Fig. 2 Flowchart showing the steps for integration of single-cell methylome and transcriptome data. Yellow
color represents methylome data, pink color represents transcriptome data, orange color represents
integrated data
4. Find a set of anchors to be used for integrating the two mod-
alities using the FindIntegrationAnchors function and the
list generated in step 3 as the input. Set the normalization
method to “SCT.”
5. Perform data integration using the IntegrateData function,
providing the anchor set object generated in step 4 as the input
and normalization method set to “SCT” (see Note 6).
6. Compute the data representation in lower dimensions, by
executing the RunPCA and RunUMAP functions consecutively
on the integrated dataset object. Visualize the embedding of
two data modalities in reduced dimensions with the DimPlot
function and the “group.by” parameter set to “tech.”
7. Perform co-embedded clustering on the integrated object as
described in step 6 in the “Downstream Analysis” section.
8. As in step 7, in the “Downstream Analysis” section, determine
the activities of the marker genes in the integrated data. Set the
default assay for the integrated object to “SCT” and execute
the FeaturePlot and VlnPlot functions with the object and
the marker genes as the input. Group the data by clusters by
setting the “group.by” parameter to “seurat_clusters”
and split the data by modalities with the “split.by”

52
Yasin Uzun et al.
parameter set to “tech.” Check whether the marker activities
in the methylome data are consistent with the transcriptome
data for the corresponding clusters.
9. Assign the cell types for the cells in the DNA methylome data
by using the K-nearest neighbor transcriptome cells in the
co-embedded representation using the knn function R package
(see Note 7).
4
Notes
1. The choice of the number of nearest neighbors (num_neigh-
bors) for meta-cell computation depends on the sequencing
depth and the dataset size. For dataset with deep sequencing
and small number of cells, the number of nearest neighbors can
be smaller than the default value. If the sequencing depth is low
and the number of cells is high, the number of nearest neigh-
bors should be increased.
2. The choice of the maximum number of allowable bins for gene
activity prediction (max_na_bins) depends on the sequencing
depth. For deeply sequenced samples, this parameter can be
lowered for more robust inference and increased otherwise.
3. Although ensemble prediction of three classiﬁers provides con-
sistent and robust results, gene activity predictions of individual
classiﬁers can provide satisfactory output, depending on the
input. This can speed up processing when time and computing
resource are limited. Please refer to the results in our study for
details [20].
4. Since not all genes are strongly regulated by DNA methylation,
inspecting a limited number of canonical marker genes may not
be sufﬁcient for accurate cell cluster annotation. Hence, we
recommend the users to use a marker gene set that is as com-
prehensive as possible.
5. The differences in the methylome activity across the cell clus-
ters may be subtle compared to the transcriptome data. For this
reason, we recommend using a lower setting for the logfc.
threshold than the default value (0.25) for FindMarkers
function.
6. The typical number of cells in a methylome sample is consider-
ably low (in the order of hundreds) when compared to a typical
transcriptome sample (in the order of thousands). For this
reason, the default value of 100 neighbors for the smoothing
parameter k.weight in IntegrateData function may be too
high and can cause run time error. In that case, this parameter
setting should be gradually lowered.

Single-Cell Methylome-Transcriptome Integration with MAPLE
53
7. The number of nearest neighbors (k) in the knn function
should be set based on the expected sample heterogeneity. If
a high number of cell types with small numbers of cells are
expected in the data (which can be inferred partially using the
transcriptome data alone), k should be set low; otherwise, it
must be set to a higher value.
References
1. Li Y, Tollefsbol TO (2011) DNA methylation
detection:
bisulﬁte
genomic
sequencing
analysis. In: Tollefsbol TO (ed) Epigenetics
protocols, vol 791. Humana Press, Totowa,
pp 11–21
2. Ahn J, Heo S, Lee J, Bang D (2021) Introduc-
tion to single-cell DNA methylation proﬁling
methods. Biomolecules 11(7):1013. https://
doi.org/10.3390/biom11071013
3. Luo C, Keown CL, Kurihara L et al (2017)
Single-cell methylomes identify neuronal sub-
types and regulatory elements in mammalian
cortex. Science 357(6351):600–604. https://
doi.org/10.1126/science.aan3351
4. Luo C, Rivkin A, Zhou J et al (2018) Robust
single-cell DNA methylome proﬁling with
snmC-seq2. Nat Commun 9:3824. https://
doi.org/10.1038/s41467-018-06355-2
5. Clark SJ, Smallwood SA, Lee HJ et al (2017)
Genome-wide
base-resolution
mapping
of
DNA methylation in single cells using single-
cell bisulﬁte sequencing (scBS-seq). Nat Protoc
12(3):534–547. https://doi.org/10.1038/
nprot.2016.187
6. Kobayashi H, Koike T, Sakashita A et al (2016)
Repetitive DNA methylome analysis by small-
scale and single-cell shotgun bisulﬁte sequenc-
ing. Genes Cells 21(11):1209–1222. https://
doi.org/10.1111/gtc.12440
7. Farlik M, Shefﬁeld NC, Nuzzo A et al (2015)
Single-cell DNA methylome sequencing and
bioinformatic inference of epigenomic cell-
state dynamics. Cell Rep 10(8):1386–1397.
https://doi.org/10.1016/j.celrep.2015.
02.001
8. Mulqueen RM, Pokholok D, Norberg SJ et al
(2018) Highly scalable generation of DNA
methylation proﬁles in single cells. Nat Bio-
technol 36(5):428–431. https://doi.org/10.
1038/nbt.4112
9. Bian S, Hou Y, Zhou X et al (2018) Single-cell
multiomics sequencing and analyses of human
colorectal
cancer.
Science
362(6418):
1060–1063. https://doi.org/10.1126/sci
ence.aao3791
10. Angermueller C, Clark SJ, Lee HJ et al (2016)
Parallel single-cell sequencing links transcrip-
tional and epigenetic heterogeneity. Nat Meth-
ods 13(3):229–232. https://doi.org/10.
1038/nmeth.3728
11. Clark SJ, Argelaguet R, Kapourani C-A et al
(2018) scNMT-seq enables joint proﬁling of
chromatin accessibility DNA methylation and
transcription in single cells. Nat Commun 9:
781. https://doi.org/10.1038/s41467-018-
03149-4
12. Gu C, Liu S, Wu Q et al (2019) Integrative
single-cell analysis of transcriptome, DNA
methylome
and
chromatin
accessibility
in
mouse
oocytes.
Cell
Res
29(2):110–123.
https://doi.org/10.1038/s41422-018-
0125-4
13. Pott S (2017) Simultaneous measurement of
chromatin accessibility, DNA methylation, and
nucleosome
phasing
in
single
cells.
elife
6. https://doi.org/10.7554/eLife.23203
14. Mo A, Mukamel EA, Davis FP et al (2015)
Epigenomic signatures of neuronal diversity in
the
mammalian
brain.
Neuron
86(6):
1369–1384. https://doi.org/10.1016/j.neu
ron.2015.05.018
15. Hernando-Herraez I, Evano B, Stubbs T et al
(2019) Ageing affects DNA methylation drift
and transcriptional cell-to-cell variability in
mouse
muscle
stem
cells.
Nat
Commun
10(1):4361.
https://doi.org/10.1038/
s41467-019-12293-4
16. Argelaguet R, Clark SJ, Mohammed H et al
(2019) Multi-omics proﬁling of mouse gastru-
lation
at
single-cell
resolution.
Nature
576(7787):487–491
17. Stuart T, Butler A, Hoffman P et al (2019)
Comprehensive integration of single-cell data.
Cell 177(7):1888.e21–1902.e21. https://doi.
org/10.1016/j.cell.2019.05.031
18. Welch JD, Kozareva V, Ferreira A et al (2019)
Single-cell multi-omic integration compares
and contrasts features of brain cell identity.
Cell 177(7):1873.e17–1887.e17. https://doi.
org/10.1016/j.cell.2019.05.006

54
Yasin Uzun et al.
19. Korsunsky I, Millard N, Fan J et al (2019) Fast,
sensitive and accurate integration of single-cell
data with Harmony. Nat Methods 16(12):
1289–1296.
https://doi.org/10.1038/
s41592-019-0619-0
20. Uzun Y, Wu H, Tan K (2020) Predictive mod-
eling of single-cell DNA methylome data
enhances integration with transcriptome data.
Genome Res 31(1):101–109. https://doi.
org/10.1101/gr.267047.120
21. Krueger F, Andrews SR (2011) Bismark: a ﬂex-
ible aligner and methylation caller for Bisulﬁte-
Seq
applications.
Bioinformatics
27(11):
1571–1572. https://doi.org/10.1093/bioin
formatics/btr167
22. Zhu Q, Gao P, Tober J et al (2020) Develop-
mental trajectory of prehematopoietic stem cell
formation from endothelium. Blood 136(7):
845–856. https://doi.org/10.1182/blood.
2020004801
23. Hafemeister C, Satija R (2019) Normalization
and variance stabilization of single-cell RNA--
seq data using regularized negative binomial
regression. Genome Biol 20(1):296. https://
doi.org/10.1186/s13059-019-1874-1
24. McInnes L, Healy J, Melville J (2018) UMAP:
uniform manifold approximation and projec-
tion
for
dimension
reduction.
arXiv:1802.03426
25. Becht E, McInnes L, Healy J et al (2018)
Dimensionality
reduction
for
visualizing
single-cell data using UMAP. Nat Biotechnol
37:38–44. https://doi.org/10.1038/nbt.
4314

Chapter 5
Quantitative Comparison of Multiple Chromatin
Immunoprecipitation-Sequencing (ChIP-seq) Experiments
with spikChIP
Enrique Blanco, Cecilia Ballare´, Luciano Di Croce, and Sergi Aranda
Abstract
The chromatin immunoprecipitation coupled with the next-generation sequencing (ChIP-seq) is a power-
ful technique that enables to characterize the genomic distribution of chromatin-associated proteins,
histone posttranslational modiﬁcations, and histone variants. However, in the absence of a reference control
for monitoring experimental and biological variations, the standard ChIP-seq scheme is unable to accu-
rately assess changes in the abundance of chromatin targets across different experimental samples. To
overcome this limitation, the combination of external spike-in material with the experimental chromatin
is offered as an effective solution for quantitative comparison of ChIP-seq data across different conditions.
Here, we detail (i) the experimental protocol for preparing quality control spike-in chromatin from
Drosophila melanogaster cells and (ii) the computational protocol to compare ChIP-seq samples with
spike-in based on the use of the spikChIP software.
Key words ChIP-seq, Chromatin, Spike-in, Normalization, Genome bin, ChIP peak, Local
regression
1
Introduction
Chromatin is the macromolecular complex of DNA and histone
proteins that packs the genome into its basic structural units of
nucleosomes [1]. Within chromatin, a plethora of interacting pro-
teins organize the 3D distribution of the genome, regulate multiple
gene expression programs, and coordinate the appropriate trans-
mission of genetic and epigenetic information to cellular progeny
[1–5]. Alterations in the functionality of the proteins associated
with chromatin are intimately linked to severe developmental dis-
eases and cancer [6, 7]. Due to its biological and pathological
relevance, research on chromatin and epigenetics has been a rapidly
moving ﬁeld over the last decade, assisted by the development of
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_5,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
55

56
Enrique Blanco et al.
novel technologies for the high-throughput molecular analysis of
the genome.
Since its development in the 1980s [8–10], the chromatin
immunoprecipitation (ChIP) technique is a widely used method
in molecular biology [11]. The power of this technique increased
dramatically later with the advent of the massive parallel sequencing
approaches [12–15]. Indeed, ChIP-seq experiments are currently a
standard method to describe the genome-wide maps of distribution
of transcription factors, chromatin remodelers, and histone mod-
iﬁcations [16–20].
The striking impact of the ChIP-seq technology is based in its
relative technical simplicity (which allows it to be successfully
adopted by most experimental laboratories), its high sensitivity
and accuracy for mapping the genomic distribution of proteins,
and the solid standardization of the experimental and computa-
tional methods to efﬁciently analyze such a volume of information.
The original scheme of ChIP-seq has been maintained substantially
unmodiﬁed from chromatin isolation and fragmentation, immuno-
precipitation using speciﬁc antibodies, DNA puriﬁcation from pro-
tein complexes, library preparation, and parallel sequencing.
Remarkably, ChIP-seq is a semiquantitative method, which enables
to determine the relative occupancy of one factor on a given geno-
mic region, with respect to the rest of the genome. However, direct
comparison of ChIP-seq signal strength in the same loci between
different conditions (e.g., cell types, metabolic states, or pathologi-
cal situations) is inaccurate in the absence of an independent inter-
nal control to monitor technical variability when performing the
ChIP-seq scheme (i.e., variations in the efﬁciency of immunopre-
cipitation or library preparation [21]). Additionally, when an inter-
nal reference is missing, global changes in chromatin target
occupancy might result obscure as a consequence of equilibrating
the ChIP-seq libraries before sequencing or due to computational
normalization of the output sequencing by the total number of
reads [22].
To overcome all these limitations, distinct labs have proposed
alternative strategies based on the addition of exogenous spike-in
material as independent internal reference controls (spike-in), thus
providing a feasible solution to accurately normalize ChIP-seq
signal across samples [23–26]. Originally developed to correct
gene expression measurement in microarrays and RNA-seq experi-
ments [27, 28], the spike-in strategy is based in the mixture of the
experimental sample with an amount of exogenous material (either
from another species or synthetically produced) that is constant
between experiments. Both the experimental sample and the
spike-in are processed and analyzed in parallel. As long as the
amount of spike-in ChIP signal is the same in all samples, the
observable differences in the experimental samples across condi-
tions can be exclusively attributed to biological variation. Eventual

ChIP-seq Normalization Using spikChIP
57
differences in the spike-in signal can be computationally equili-
brated to eliminate technical variability, and this correction factor
is then used to normalize the experimental signal of each condition.
We have recently proposed a practical guideline for facilitating
the decision-making to researchers about when and how to apply
the spike-in strategy for normalizing ChIP-seq using mammalian
cells [26]. At the experimental level, we recommend using ﬂy
material as the spike-in because of: (1) the accuracy of the genome
assembly; (2) the extensive characterization of the ﬂy chromatin at
epigenetic level; 3) the evolutionary divergence between ﬂy and
mammalian genomes, which enables an unambiguous alignment of
the reads [24, 25]; and (4) the relative simplicity of preparing
chromatin from ﬂy cells. Moreover, we suggest the use of a second
antibody for a ﬂy-speciﬁc histone variant (H2Av) to capture the
spike-in material [25]. This strategy aims to avoid the cross-
reactivity constraint of the experimental antibody and to reduce
any potential variability due to competition between the spike-in
control and the experimental material, which usually exceeds the
amount of spike-in material by far. Moreover, the genomic occu-
pancy proﬁle of the ﬂy-speciﬁc H2Av is already characterized [25],
which can be extremely useful as an additional control point for
assessing ChIP-seq performance.
In this chapter, we detail an efﬁcient procedure for preparing a
stock of chromatin from D. melanogaster cells to use as internal
reference for ChIP-seq experiments. In addition, we provide a
roadmap for the computational analysis of ChIP-seq data using
spikChIP, a stand-alone pipeline designed in Perl and R to perform
the systematic normalization of multiple ChIP-seq experiments
with spike-in [26]. SpikChIP implements a local regression that
enables a gradual normalization from background to positive ChIP
signal regions (Fig. 1). This reduces the inﬂuence of sequencing
noise of spike-in material during ChIP-seq normalization while
minimizes the overcorrection of non-occupied genomic regions
in the experimental ChIP-seq.
2
Materials
2.1
Cell Culture
1. Drosophila Schneider’s Line 2 (SL2) cells (ATCC, Ref.
CRL-1963; Drosophila melanogaster).
2. Heat-inactivated FBS: Fetal bovine serum (Thermo Fisher)
inactivated 30 min at 56 °C.
3. SL2 culture medium: Schneider’s Drosophila media (Thermo
Fisher) supplemented with 10% heat-inativated FBS plus 1×
penicillin/streptomycin (Gibco).
4. 1× PBS buffer

58
Enrique Blanco et al.
Fig. 1 Scheme representing the normalization applied by SpikChIP. Sequencing data results in a number of
reads corresponding to non-occupied genomic regions (background, in gray) and enriched genomic regions
(peaks, in orange or red). The SpikChIP software runs by segmenting both the spike-in and experimental
genome into bins. Using the ChIP signal for each spike-in bin, SpikChIP calculates distinct correction
coefﬁcients (here depicted by the letters α, β, δ, γ). These coefﬁcients are then used to normalize the
experimental ChIP-seq values
5. Formaldehyde solution (Sigma).
6. Crosslinking Solution: 1% Formaldehyde in 1× PBS buffer.
7. Quenching Solution: 2 M glycine.
8. Complete
EDTA-free
Protease
Inhibitor
Cocktail
(PIC;
Roche).
9. QIAquick PCR puriﬁcation kit (Qiagen).
10. Proteinase K 20 mg/mL (Thermo Scientiﬁc).
11. Spike-in Antibody (Active Motif), against the Drosophila-spe-
ciﬁc histone variant, H2Av.
12. Lysis Buffer: 50 mM Tris-HCl pH 8.1; 10 mM EDTA;
1% SDS.

ChIP-seq Normalization Using spikChIP
59
2.2
Equipment
1. Cell culture hood (i.e., biosafety cabinet).
2. Inverted microscope with 4× and 10× objectives.
3. Incubator set at 26 °C.
4. Refrigerated centrifuges.
5. Micropipettes.
6. Pipettor.
7. Freezers: -20 and - 80 °C.
8. Bioruptor Pico Diagenode or equivalent.
9. Rotating shaker.
10. Thermo-block.
11. Nanodrop.
12. Complete electrophoresis apparatus.
13. Workstation with a minimum of 8 GB of RAM and 1 TB hard
drive.
2.3
Disposables
1. Sterile plastic pipettes.
2. 15 and 50 mL conical tubes
3. 75 cm2 tissue culture-treated ﬂasks
4. Filter pipette tips.
5. Sterilized Pasteur pipettes.
6. 1.5 mL Eppendorf tubes.
2.4
Software
Requirements
1. Operating system: UNIX command-line platform (Mac OS or
Linux) is required.
2. Bowtie: http://bowtie-bio.sourceforge.net/index.shtml
3. GAWK: https://www.gnu.org/software/gawk
4. MACS2: https://pypi.org/project/MACS2
5. Perl: https://www.perl.org
6. R: https://www.r-project.org (affy and MASS packages are
required).
7. SAMtools: http://www.htslib.org
8. SeqCode: https://github.com/eblancoga/seqcode
9. SpikChIP: https://github.com/eblancoga/spikChIP

60
Enrique Blanco et al.
3
Methods
3.1
Preparation of
Spike-in Chromatin for
ChIP-seq Experiments
Drosophila S2 cells are cultured in SL2 Culture Medium at 25 °C
without additional CO2. Cell cultures should be maintained
between 5 × 104 and 4 × 105 cells/cm2.
3.1.1
Preparation of
Drosophila SL2 Cells
3.1.2
Preparation of
Drosophila SL2 Chromatin
1. Collect 4 × 107 S2 cells by centrifugation at 300 g for 5 min at
room temperature (see Note 1).
2. Resuspend the cells with 10 mL of cross-linking solution by
pipetting up and down and incubate 10 min with gentle
rotation.
3. Add 0.67 mL of Quenching Solution and incubate 5 min at
room temperature with gentle rotation.
4. Collect the cells by centrifugation at 3250 g for 5 min at 4 °C.
5. Wash pellets by gently suspending in 10 mL ice-cold 1× PBS
and then collect them by centrifugation at 3250 g for 5 min at
4 °C.
6. Repeat step 5 twice. Keep the samples on ice during the
centrifugation steps (see Note 2).
7. Suspend cross-linked cells in 1 mL lysis buffer supplemented
with protease inhibitors (complete EDTA-free protease inhibitor
cocktail 1X) by gently pipetting up and down (avoid foam
formation), and then incubate for 10 min on ice.
8. Sonicate the suspension in 15 mL tubes in a refrigerated Bior-
uptor Pico at 4 °C during 24 cycles (30 s ON/30 s OFF, see
Notes 3 and 4).
9. Transfer the suspension to a 1.5 mL Eppendorf tube, clarify by
centrifugation at 15,000 g for 10 min at 4 °C in a tabletop
centrifuge and then, transfer supernatant to a new tube. Frag-
mented chromatin can be maintained at 4 °C for 16 h. For
longer periods, store at -80 °C, while performing Subheading
3.1, step 3.
3.1.3
Quality Control and
DNA Quantiﬁcation from
Fragmented Chromatin
1. Collect a 50 μL aliquot from fragmented chromatin from the
previous step 9.
2. Add 150 μL lysis buffer plus 2.5 μL proteinase K 20 mg/mL.
3. Incubate the mixture from 4 h to overnight at 65 °C with
vigorous shaking (800 rpm) in a Thermomixer.
4. Purify DNA using the PCR puriﬁcation kit and elute in 50 μL.
5. Quantify the puriﬁed DNA using a NanoDrop.

ChIP-seq Normalization Using spikChIP
61
6. Separate 800 ng of puriﬁed DNA by electrophoresis on a 1.2%
(w/v) agarose gel. Optimal DNA fragmentation should be
100–500 bp. If fragments are larger than 500 bp, include
additional sonication cycles until you reach the appropriate
fragmentation.
7. If the DNA fragmentation is optimal, store the fragmented
chromatin from the previous step 9 (Subheading 3.1.2) into
50 uL aliquots at -80 °C, to minimize freeze-thaw cycles.
3.1.4
Incorporation of
Drosophila SL2 Chromatin
with Experimental
Chromatin Samples
1. Prepare the experimental ChIP reaction mixes containing the
experimental chromatin and the antibody of interest, according
to the standard procedures.
2. Add the Spike-in chromatin (see Note 5).
3. Add Spike-in antibody. Usually, for a common ChIP reaction
[30 μg sample chromatin (DNA) and 5 μg speciﬁc antibody],
add 1.5 μg Spike-in antibody.
4. Remove 1% of the reaction mixes as input sample and keep at -
20 °C.
5. Perform the ChIP and the sequencing using Illumina sequenc-
ing platforms according to the standard procedures (see Note 6).
3.2
Computational
Analysis of ChIP-seq
Data Using Spike-in
Chromatin
To perform in our computer the analysis of ChIP-seq samples with
exogenous spike-in (see Note 7), it is necessary to previously gen-
erate a synthetic genome constructed from the chromosomes of
both species (Fig. 2; see Note 8). FASTA sequences will be down-
loaded from the UCSC genome browser [29]. For example, chro-
mosomes from human hg38 and fruit ﬂy dm3 assemblies are
retrieved, respectively, from:
3.2.1
Generation of the
Genome Index for ChIP-seq
Mapping
Fig. 2 Computational workﬂow for Subheading 3.2, steps 1–4

% samtools view -b -F 0x4 -o sample.bam sample.sam.
62
Enrique Blanco et al.
https://hgdownload.soe.ucsc.edu/goldenPath/hg38/
chromosomes/
https://hgdownload.soe.ucsc.edu/goldenPath/dm3/
chromosomes/.
We will tag the name of the spike-in chromosomes for easy
identiﬁcation (e.g., >chr2L in Drosophila melanogaster must be
replaced by >chr2L_FLY). The following GAWK command carries
this operation out on a FASTA ﬁle:
% gawk ’{if ($0~">") {print $0"_FLY"} else {print $0}}’ chrN.fa
> chrN_FLY.fa.
FASTA sequences of both genomes must be concatenated
together in a single multi-FASTA ﬁle with the UNIX cat com-
mand (see Note 9). Finally, genome indexes for read mapping will
be generated from this multi-FASTA ﬁle using a mapping tool such
as Bowtie [30] or BWA [31]. Let genome.fa be a multi-FASTA
ﬁle combining the chromosomes of two species, the following
command generates and stores the genome indexing ﬁles into the
output folder:
% bowtie-build genome.fa output/genome.
3.2.2
Genome Mapping
of each Individual ChIP-seq
Sample
The FASTQ raw data ﬁle of our ChIP-seq sample including spike-in
material must be aligned to the appropriate genome index contain-
ing the same species involved in the experiment (see Notes 10 and
11). We will run the following Bowtie command to map the ChIP-
seq experiment called sample.fastq over the genome indexing
ﬁles including spike-in using up to four processors, discarding
multi-locus reads, and saving the output in SAM format into the
sample.sam ﬁle:
% bowtie -p 4 -t -m 1 -S -q genome sample.fastq sample.sam.
We will remove unaligned reads and convert into BAM format
the resulting SAM ﬁle to save storage space with the following
SAMTools [32] command:
3.2.3
Extraction of
Aligned Reads into Distinct
Genome and Spike-in Files
To identify differences in the amount of spike-in reads across con-
ditions and introduce such corrections in the same proportions
over the reads corresponding to the true experiment, we will search
the tag described before in the BAM ﬁle and extract both classes of
reads into two separate SAM ﬁles (sample_experiment.sam and
sample_spike.sam):

% samtools view -h sample.bam | grep -v FLY > sample_experi-
ment.sam
% samtools view -h sample.bam | grep FLY > sample_spike.sam
Sample
BED experiment
BED spike-in
ChIP-seq Normalization Using spikChIP
63
Each SAM ﬁle will be converted into BAM format with this
SAMtools command (see Note 12):
% samtools view -S -b -o sample_experiment.bam sample_experi-
ment.sam
% samtools view -S -b -o sample_spike.bam sample_spike.sam
3.2.4
Identiﬁcation of
ChIP-Enriched Regions on
Each Experiment
MACS2 [33] will be used to identify the peaks of ChIP-seq signal
on each BAM ﬁle generated before for both genomes. For instance,
we perform the peak calling of one spike-in ﬁle of reads by running
this command (the –g option indicates the reference genome; dm
stands for Drosophila melanogaster, see Note 13 for additional ﬂag
options):
% macs2 callpeak -t sample_spike.bam -f BAM -g dm -n sample_-
spike --nomodel --extsize 150
We will select the columns informing about the location of the
peaks in the MACS2 output to generate ﬁnal BED ﬁles:
%
grep
-v
"#"
sample_spike/sample_spike_peaks.xls
|
grep
-v
start | gawk ’BEGIN{OFS="\t"}{if (NF>0) print $1,$2,$3,NR-1}’
> sample_spike_peaks.bed
3.2.5
Preparation of the
Conﬁguration File of
spikChIP
SpikChIP is a standalone pipeline designed in Perl and R to per-
form the normalization of multiple ChIP-seq spike-in experiments
by a local regression across samples that demonstrate to focus the
impact of the corrections over the ChIP signal-enriched regions,
diminishing secondary effects of the normalization over the back-
ground [26]. We will edit the following config.txt conﬁgura-
tion ﬁle to instruct spikChIP about where to ﬁnd our collection of
input data (ﬁles are considered to be in the current directory in this
example, Fig. 3; see Note 14):
BAM
experiment
BAM
spike-in
1
1_experiment.
Bam
1_spike.
Bam
1_experiment_peaks.
Bed
1_spike_peaks.
Bed
. . .
N
N_experiment.
Bam
N_spike.
Bam
N_experiment_peaks.
Bed
N_spike_peaks.
Bed

64
Enrique Blanco et al.
Fig. 3 Computational workﬂow for Subheading 3.2, steps 5–9
3.2.6
Preparation of the
Genome Deﬁnition File of
spikChIP
SpikChIP requires a second input a ﬁle with the list of chromo-
somes (and their sizes) that constitute the synthetic genome
employed in the previous mapping step. For instance, we will
download this ﬁle for human (hg38 assembly) from the UCSC
genome browser:
http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database/
chromInfo.txt.gz
Once we concatenate the same ﬁle for both species (e.g., hg38
and dm3), we will edit the ﬁnal ChromInfo.txt to tag the spike-in
genome chromosomes:
chr1
248,956,422
. . .
chrY
57,227,415
chr2L_FLY
23,011,544
. . .
chrX_FLY
22,422,827
3.2.7
Running spikChIP
to Normalize a Collection of
ChIP-seq Samples
We will execute the following command to analyze with spikChIP
the collection of ChIP-seq samples indicated in the conﬁguration
ﬁle (see Note 15):
% spikChIP.pl -v config.txt ChromInfo.txt
Throughout the running, spikChIP will inform about the stage
of the analysis that is currently ongoing. Basically, we will see the
following main informative messages:

ChIP-seq Normalization Using spikChIP
65
Stage 0. Conﬁguration of the pipeline.
Stage 1. Producing the segmentation of both genomes in bins
(1000 bps).
Stage 2. Processing each experiment with different normalization
methods.
Stage 3. Distinguishing bins of spike and sample genomes into
peaks or bg.
Stage 4. Generating the ﬁnal boxplots of values.
3.2.8
Interpretation and
Usage of spikChIP Output
Files
SpikChIP analysis generates a segmentation of both input genomes
into bins of the same size, calculates the amount of reads of each
ChIP-seq sample within each bin, and performs the local normali-
zation on such values using the corrections necessary to adjust
spike-in bins to normalize the bins of the genome employed in
the true experiment (see Note 16). Once the analysis is ﬁnished, we
can explore the ﬁnal ﬁles saved on the results/folder. We will see
the values normalized for each bin from both genomes in every
ChIP-seq experiment (rows are bins and columns are ChIP-seq
experiments normalized counts following the order declared in
the conﬁguration ﬁle, see Note 17):
% head FINAL_1. . .N_SPIKCHIP_1000_avg_normalized_sample.txt
chr1*1*1001 value1 . . . valueN
. . .
% head FINAL_1. . .N_SPIKCHIP_1000_avg_normalized_spike.txt
chr2L_FLY*1*1001 value1 . . . valueN
. . .
We can examine the output ﬁles used by spikChIP to generate
the boxplots segregating bins into peaks and background regions
according to the set of peaks declared in the conﬁguration ﬁle (only
average values shown here):
% head FINAL_1. . .N_SPIKCHIP_1000_sample_avg_peaks.txt
% head FINAL_1. . .N_SPIKCHIP_1000_sample_avg_bg.txt
% head FINAL_1. . .N_SPIKCHIP_1000_spike_avg_peaks.txt
% head FINAL_1. . .N_SPIKCHIP_1000_spike_avg_bg.txt
3.2.9
Generation of
Genome-Wide Proﬁles for
Graphical Browsers
To explore visually in the UCSC genome browser, we will generate
custom tracks in BedGraph format by extracting the appropriate
column of a particular spikChIP output ﬁle. The following UNIX
commands will produce the genome-wide proﬁle for the values
normalized in the experimental genome using the ﬁrst ChIP-seq
condition from a generic dataset as declared in the conﬁguration ﬁle
(see Note 18):

% zcat FINAL_1. . .N_SPIKCHIP_1000_avg_normalized_sample.txt.gz |
sed ’s/\*/ /g’ | gawk ’BEGIN{print "track type=bedGraph name=
AVG_SPIKCHIP_SAMPLE description=AVG_SPIKCHIP_SAMPLE visibili-
ty=full
maxHeightPixels=60
color=200,0,0";
OFS="\t"}{print
$1,$2,$3,$4}’ > SPIKCHIP_sample.bg
66
Enrique Blanco et al.
Before uploading into the browser, we will check the beginning
of the proﬁle:
% head SPIKCHIP_sample.bg
track
type=bedGraph
name=AVG_SPIKCHIP_SAMPLE
description=
AVG_SPIKCHIP_SAMPLE
visibility=full
maxHeightPixels=60
col-
or=200,0,0
chr1 1 1001 value_in_sample1
...
Finally, we will compress the custom track ﬁle to speed the
uploading up (see Note 19):
% gzip SPIKCHIP_sample1.bg
4
Notes
1. SL2 cells grow in suspension with some loosely adherent cells.
To collect the cells, gently resuspend them in pipetting
medium across the monolayer. Strongly adherent cells can be
mechanically dislodged with a cell scraper.
2. At this step, the cross-linked cell pellets could be stored at
-80 °C until 3 months.
3. The number of cycles should be optimized since the efﬁciency
in the chromatin fragmentation can differ greatly depending on
the equipment. The indicated values are suggested starting
parameters for the indicated equipment. Select the lowest
number of cycles that result in fragmented DNA ranging
from 100 to 500 bp.
4. Alternatively, another sonicator can be used, as long as the
samples are kept refrigerated throughout the process and the
appropriate chromatin fragmentation is achieved.
5. The optimal amount of spike-in reads for normalization must
be at least one million and, approximately, 2%–5% of the exper-
imental genome. The abundance of the target in the experi-
mental sample, as well as the efﬁciency of the antibody used for
capturing it, will inﬂuence the chromatin sample:chromatin
spike-in proportion in the ﬁnal mixture. As a guideline, when
using
robust
antibodies
against
abundant
histone

ChIP-seq Normalization Using spikChIP
67
modiﬁcations, the chromatin mixture should contain between
2.5% and 1% of spike-in material (% calculated according to the
amount of DNA corresponding to each chromatin material).
In contrast, when using antibodies against transcription fac-
tors, histone modiﬁers or low abundance histone modiﬁca-
tions, the mixture should contain between 0.1% and 0.05% of
spike-in material.
6. Alternatively to massive parallel sequencing, immunoprecipi-
tated and input material can be processed for qPCR by using
standard procedures. The qPCR signal from a speciﬁc spike-in
locus can be then used to normalize the qPCR signal for an
experimental locus. To select a speciﬁc locus to amplify from
spike-in material, the researchers can ﬁnd a source for H2Av,
H3K4me3, H3K27ac, and H3K27me3 ChIP-seq proﬁles in
the following link: https://genome.ucsc.edu/s/DiCroceLab/
spikChIP_MethodsMolBiol_2021.
Here below are two examples of ChIP-qPCR normaliza-
tion using spike-in: (i) the traditional “percentage of input”
normalization method and (ii) the use of the qPCR signal from
the spike-in as an internal reference.
(i) % input normalized by spike-in
Adjusted Input to 
100%
% input
Correction factor
Spike-in equilibrated 
%inp
Raw ct Average from 
triplicate
Raw Ct-6.64
100 x 2^ (Adjusted input-Ct ChIP)
% inp spike-in / % 
inp spike-in 
reference
% inp sample / 
correction factor
28,03
28,18
28,10
26,67
26,53
26,50
29,10
29,30
29,10
26,52
26,50
26,48
29,69
29,86
29,60
30,15
30,30
30,40
29,47
29,32
29,3
30,3
30,1
30,2
ChIP
Input (1%)
Input (1%)
ChIP
Input (1%)
ChIP
Input (1%)
ChIP
28,10
26,57
29,17
26,50
0,34
0,42
0,16
0,16
29,72
30,28
29,36
30,2
19,92
19,86
23,64
23,6
1,00
Spike-in #1
Spike-in #2
Sample #1
Sample #2
1,48
1,79
0,83

68
Enrique Blanco et al.
(ii) Normalization using spike-in signal as internal reference
Normalization by 
spike-in ChIP 
signal (ΔCT)
Normalization to a 
reference sample 
(ΔΔCT)
Relative 
quantification
Raw ct Average from 
triplicate
CT(ChIP sample)  −    
CT(reference 
spike-in ChIP)
ΔCT(ChIP sample)  
−  ΔCT(a reference 
sample)
2^-ΔΔCT
28,0
28,2
28,1
29,1
29,3
29,1
29,7
29,9
29,6
29,5
29,3
29,3
29,72
29,36
28,10
29,17
-1,6
-0,2
0,00
1,42
1,00
0,37
Sample #1
ChIP
Sample #2
ChIP
Spike-in #1
ChIP
Spike-in #2
ChIP
7. Virtual machines (e.g., Oracle Virtual Box™) allow users of
other operating systems to safely run Linux environments in
their computers with no modiﬁcation of the current setup.
8. We recommend to generate genome indexes from the basic list
of chromosomes (i.e., Homo sapiens assembly hg38: chr1 to
chr22, chrX, chrY, and chrM). Thus, FASTA ﬁles from alter-
nate sequences (e.g., chr1_GL383518v1_alt), ﬁx sequences
(e.g.,
chr1_KN196472v1_ﬁx),
unlocalized
contigs
(e.g.,
chr1_KI270706v1_random),
and
unplaced
contigs
(e.g.,
chrUn_GL000195v1) would be excluded from the analysis.
The same advice is applicable to spikChIP genome deﬁnition
ﬁles (chromInfo.txt).
9. Genome indexes for mapping reads on a particular pair of
genome assemblies are typically produced only once for being
reutilized later in all the mappings performed in the computer.
Original FASTA ﬁles are no longer used by the alignment tools
and can be deleted.
10. Genome mapping consists on univocally identifying the loca-
tion of each read in a particular position of one of the chromo-
somes in one of the two species that constitute the ChIP-seq
experiment. Unless focusing in the analysis of genomic repeats,
multi-reads (reads whose sequence is matching more than one
locus in one of the species) are usually discarded by introducing
the appropriate ﬂag option in the alignment tool.

ChIP-seq Normalization Using spikChIP
69
11. It is a good habit to centralize the storage of raw data FASTQ
ﬁles and BAM alignment ﬁles in two separate folders of a
particular location within our ﬁle tree.
12. The SAMTools flagstat command can be used over each
SAM/BAM ﬁle at any step of this protocol to obtain statistics
on the number and the class of the ChIP-seq aligned reads.
13. It is recommended to use the ﬂag option
--broad of
MACS2, when analyzing histone marks with a broad pattern
of occupancy. Furthermore, a second BAM ﬁle can be intro-
duced with the option –c to be used as a peak calling control
(e.g., Input or IgG).
14. We recommend to introduce the same set of ChIP-enriched
regions on each genome in all the lines of the spikChIP conﬁg-
uration ﬁle to ensure a fair comparison. These BED ﬁles could
be generated separately for each species (peaks.bed and
spike_peaks.bed) by gathering all peaks in every condition
or simply by selecting the condition in which a higher number
of peaks was identiﬁed.
15. SpikChIP can be customized to delete all intermediate ﬁles at
the end of the processing (-c ﬂag option). Depending on the
volume of the BAM ﬁles and the genomes analyzed on a run,
we strongly recommend to switch this option on.
16. In addition to its own normalization based in local regression,
spikChIP pipeline calculates in parallel up to four different
alternative normalization approaches: raw (absolute counts),
traditional (sequencing depth), ChIP-Rx [24] and Tag
removal [25]. Boxplots showing the performance of each
method on peaks and background regions of the input ChIP-
seq experiments are automatically generated. Further informa-
tion on [26].
17. SpikChIP calculates separately the maximum and the average
number of reads of each experiment to be assigned to each bin
of the genomes. Thus, output ﬁles using normalized values
calculated in both modes are generated by spikChIP. We sug-
gest to utilize maximum mode results when working with
transcription factors and histone marks (e.g., H3K4me3) asso-
ciated to sharp peaks, while average mode results are suitable to
study broad peaks of certain histone marks (e.g., H3K79me2).
18. To generate genome-wide proﬁles from normalized counts in
the spike-in genome, it is necessary to undo the tag edit
incorporated in the spikChIP input ﬁles (e.g., chr2L_FLY to
chr2L) by adding a sed instruction to the command previ-
ously described.
19. The UCSC genome browser offers Track hubs as an alternative
approach to directly upload genome-wide proﬁles. Faster
access to custom tracks visualized in this manner is achieved

70
Enrique Blanco et al.
by rendering only the fragment of the chromosome currently
viewed on the screen. However, track ﬁles must be perma-
nently hosted on a web space provider, and their internet
address should be supplied to the genome browser.
Acknowledgments
This work was supported by the Spanish of Economy, Industry and
Competitiveness (MEIC) (BFU2016-75008-P, and PID2019-
108322GB-100), “Fundacio´n Vencer El Ca´ncer” (VEC), the
European Regional Development Fund (FEDER), and from
AGAUR to L.D.C. The Ramon y Cajal program of the Ministerio
de Ciencia, Innovacio´n y Universidades and the European Social
Fund under the reference number RYC-2018-025002-I, and the
Instituto de Salud Carlos III-FEDER (PI19/01814), to S.A. We
acknowledge the funding support of the Spanish Ministry of Sci-
ence and Innovation to the EMBL partnership, the Centro de
Excelencia Severo Ochoa, and the CERCA Programme/General-
itat de Catalunya.
References
1. Cramer P (2014) A tale of chromatin and tran-
scription
in
100
structures.
Cell
159(5):
985–994. https://doi.org/10.1016/j.cell.
2014.10.047
2. Bonev B, Cavalli G (2016) Organization and
function of the 3D genome. Nat Rev Genet
17(11):661–678. https://doi.org/10.1038/
nrg.2016.112
3. Almouzni G, Cedar H (2016) Maintenance of
epigenetic information. Cold Spring Harb Per-
spect Biol 8(5). https://doi.org/10.1101/
cshperspect.a019372
4. Gilbert DM, Takebayashi SI, Ryba T, Lu J,
Pope BD, Wilson KA, Hiratani I (2010)
Space and time in the nucleus: developmental
control of replication timing and chromosome
architecture. Cold Spring Harb Symp Quant
Biol 75:143–153. https://doi.org/10.1101/
sqb.2010.75.011
5. Aranda S, Mas G, Di Croce L (2015) Regula-
tion of gene transcription by Polycomb pro-
teins. Sci Adv 1(11):e1500737. https://doi.
org/10.1126/sciadv.1500737
6. Mirabella AC, Foster BM, Bartke T (2016)
Chromatin deregulation in disease. Chromo-
soma 125(1):75–93. https://doi.org/10.
1007/s00412-015-0530-0
7. Espejo I, Di Croce L, Aranda S (2020) The
changing chromatome as a driver of disease: a
panoramic view from different methodologies.
BioEssays 42(12):e2000203. https://doi.org/
10.1002/bies.202000203
8. Solomon MJ, Larsen PL, Varshavsky A (1988)
Mapping protein-DNA interactions in vivo
with formaldehyde: evidence that histone H4
is retained on a highly transcribed gene. Cell
53(6):937–947
9. Gilmour DS, Lis JT (1984) Detecting protein-
DNA interactions in vivo: distribution of RNA
polymerase on speciﬁc bacterial genes. Proc
Natl Acad Sci U S A 81(14):4275–4279
10. Gilmour DS, Lis JT (1985) In vivo interactions
of RNA polymerase II with genes of Drosoph-
ila
melanogaster.
Mol
Cell
Biol
5(8):
2009–2018
11. Aranda S, Shi Y, Di Croce L (2016) Chromatin
and epigenetics at the forefront: ﬁnding clues
among
peaks.
Mol
Cell
Biol
36(19):
2432–2439. https://doi.org/10.1128/MCB.
00328-16
12. Johnson DS, Mortazavi A, Myers RM, Wold B
(2007) Genome-wide mapping of in vivo
protein-DNA
interactions.
Science
316(5830):1497–1502. https://doi.org/10.
1126/science.1141319

ChIP-seq Normalization Using spikChIP
71
13. Barski A, Cuddapah S, Cui K, Roh TY, Schones
DE, Wang Z, Wei G, Chepelev I, Zhao K
(2007) High-resolution proﬁling of histone
methylations in the human genome. Cell
129(4):823–837. https://doi.org/10.1016/j.
cell.2007.05.009
14. Mikkelsen TS, Ku M, Jaffe DB, Issac B,
Lieberman
E,
Giannoukos
G,
Alvarez
P,
Brockman W, Kim TK, Koche RP, Lee W,
Mendenhall E, O’Donovan A, Presser A,
Russ C, Xie X, Meissner A, Wernig M,
Jaenisch R, Nusbaum C, Lander ES, Bernstein
BE (2007) Genome-wide maps of chromatin
state in pluripotent and lineage-committed
cells. Nature 448(7153):553–560. https://
doi.org/10.1038/nature06008
15. Albert I, Mavrich TN, Tomsho LP, Qi J, Zan-
ton SJ, Schuster SC, Pugh BF (2007) Transla-
tional
and
rotational
settings
of
H2A.Z
nucleosomes across the Saccharomyces cerevi-
siae
genome.
Nature
446(7135):572–576.
https://doi.org/10.1038/nature05632
16. Consortium
EP
(2004)
The
ENCODE
(ENCyclopedia of DNA elements) project. Sci-
ence 306(5696):636–640. https://doi.org/
10.1126/science.1105136
17. Consortium EP (2012) An integrated encyclo-
pedia of DNA elements in the human genome.
Nature 489(7414):57–74. https://doi.org/
10.1038/nature11247
18. Consortium EP, Moore JE, Purcaro MJ, Pratt
HE, Epstein CB, Shoresh N, Adrian J, Kawli T,
Davis CA, Dobin A, Kaul R, Halow J, Van
Nostrand EL, Freese P, Gorkin DU, Shen Y,
He Y, Mackiewicz M, Pauli-Behn F, Williams
BA, Mortazavi A, Keller CA, Zhang XO, Elhaj-
jajy SI, Huey J, Dickel DE, Snetkova V, Wei X,
Wang
X,
Rivera-Mulia
JC,
Rozowsky
J,
Zhang J, Chhetri SB, Zhang J, Victorsen A,
White KP, Visel A, Yeo GW, Burge CB,
Lecuyer E, Gilbert DM, Dekker J, Rinn J,
Mendenhall EM, Ecker JR, Kellis M, Klein
RJ, Noble WS, Kundaje A, Guigo R, Farnham
PJ, Cherry JM, Myers RM, Ren B, Graveley
BR, Gerstein MB, Pennacchio LA, Snyder
MP, Bernstein BE, Wold B, Hardison RC, Gin-
geras TR, Stamatoyannopoulos JA, Weng Z
(2020) Expanded encyclopaedias of DNA ele-
ments in the human and mouse genomes.
Nature 583(7818):699–710. https://doi.
org/10.1038/s41586-020-2493-4
19. Stunnenberg
HG,
International
Human
Epigenome C, Hirst M (2016) The interna-
tional human Epigenome Consortium: a blue-
print for scientiﬁc collaboration and discovery.
Cell 167(5):1145–1149. https://doi.org/10.
1016/j.cell.2016.11.007
20. Skipper M, Eccleston A, Gray N, Heemels T,
Le Bot N, Marte B, Weiss U (2015) Presenting
the epigenome roadmap. Nature 518(7539):
313. https://doi.org/10.1038/518313a
21. Teng M, Du D, Chen D, Irizarry RA (2021)
Characterizing batch effects and binding site-
speciﬁc variability in ChIP-seq data. NAR
Genom Bioinform 3(4):lqab098. https://doi.
org/10.1093/nargab/lqab098
22. Chen K, Hu Z, Xia Z, Zhao D, Li W, Tyler JK
(2015) The overlooked fact: fundamental need
for spike-in control for virtually all genome-
wide analyses. Mol Cell Biol 36(5):662–667.
https://doi.org/10.1128/MCB.00970-14
23. Bonhoure N, Bounova G, Bernasconi D,
Praz V, Lammers F, Canella D, Willis IM,
Herr W, Hernandez N, Delorenzi M (2014)
Quantifying ChIP-seq data: a spiking method
providing an internal reference for sample-to-
sample normalization. Genome Res 24(7):
1157–1168. https://doi.org/10.1101/gr.
168260.113
24. Orlando DA, Chen MW, Brown VE, Solanki S,
Choi YJ, Olson ER, Fritz CC, Bradner JE,
Guenther MG (2014) Quantitative ChIP-Seq
normalization reveals global modulation of the
epigenome.
Cell
Rep
9(3):1163–1170.
https://doi.org/10.1016/j.celrep.2014.
10.018
25. Egan B, Yuan CC, Craske ML, Labhart P,
Guler GD, Arnott D, Maile TM, Busby J,
Henry
C,
Kelly
TK,
Tindell
CA,
Jhunjhunwala S, Zhao F, Hatton C, Bryant
BM, Classon M, Trojer P (2016) An alternative
approach to ChIP-Seq normalization enables
detection of genome-wide changes in histone
H3 lysine 27 Trimethylation upon EZH2 inhi-
bition. PLoS One 11(11):e0166438. https://
doi.org/10.1371/journal.pone.0166438
26. Blanco E, Di Croce L, Aranda S (2021) Spik-
ChIP: a novel computational methodology to
compare multiple ChIP-seq using spike-in
chromatin.
NAR
Genom
Bioinform
3(3):
lqab064. https://doi.org/10.1093/nargab/
lqab064
27. Loven J, Orlando DA, Sigova AA, Lin CY, Rahl
PB, Burge CB, Levens DL, Lee TI, Young RA
(2012) Revisiting global gene expression anal-
ysis. Cell 151(3):476–482. https://doi.org/
10.1016/j.cell.2012.10.012
28. Taruttis
F,
Feist
M,
Schwarzﬁscher
P,
Gronwald W, Kube D, Spang R, Engelmann
JC (2017) External calibration with drosophila
whole-cell spike-ins delivers absolute mRNA
fold
changes
from
human
RNA-Seq
and

72
Enrique Blanco et al.
qPCR
data.
BioTechniques
62(2):53–61.
https://doi.org/10.2144/000114514
29. Lee BT, Barber GP, Benet-Pages A, Casper J,
Clawson H, Diekhans M, Fischer C, Gonzalez
JN, Hinrichs AS, Lee CM, Muthuraman P,
Nassar LR, Nguy B, Pereira T, Perez G,
Raney BJ, Rosenbloom KR, Schmelter D,
Speir ML, Wick BD, Zweig AS, Haussler D,
Kuhn RM, Haeussler M, Kent WJ (2021) The
UCSC
genome
browser
database:
2022
update. Nucleic Acids Res. https://doi.org/
10.1093/nar/gkab959
30. Langmead B, Trapnell C, Pop M, Salzberg SL
(2009) Ultrafast and memory-efﬁcient align-
ment of short DNA sequences to the human
genome. Genome Biol 10(3):R25. https://
doi.org/10.1186/gb-2009-10-3-r25
31. Li H, Durbin R (2009) Fast and accurate short
read alignment with burrows-wheeler trans-
form.
Bioinformatics
25(14):1754–1760.
https://doi.org/10.1093/bioinformatics/
btp324
32. Danecek P, Bonﬁeld JK, Liddle J, Marshall J,
Ohan V, Pollard MO, Whitwham A, Keane T,
McCarthy SA, Davies RM, Li H (2021) Twelve
years of SAMtools and BCFtools. Gigascience
1 0 ( 2 ) .
h t t p s : // d o i . o r g / 1 0 . 1 0 9 3 /
gigascience/giab008
33. Zhang Y, Liu T, Meyer CA, Eeckhoute J, John-
son DS, Bernstein BE, Nusbaum C, Myers
RM, Brown M, Li W, Liu XS (2008) Model-
based analysis of ChIP-Seq (MACS). Genome
Biol 9(9):R137. https://doi.org/10.1186/
gb-2008-9-9-r137

Chapter 6
A Guide to MethylationToActivity: A Deep Learning
Framework That Reveals Promoter Activity Landscapes
from DNA Methylomes in Individual Tumors
Karissa Dieseldorff Jones, Daniel Putnam, Justin Williams,
and Xiang Chen
Abstract
Genome-wide DNA methylomes have contributed greatly to tumor detection and subclassiﬁcation. How-
ever, interpreting the biological impact of the DNA methylome at the individual gene level remains a
challenge. MethylationToActivity (M2A) is a pipeline that uses convolutional neural networks to infer
H3K4me3 and H3K27ac enrichment from DNA methylomes and thus infer promoter activity. It was
shown to be highly accurate and robust in revealing promoter activity landscapes in various pediatric and
adult cancers. The following will present a user-friendly guide through the model pipeline.
Key words H3K4me3, H3K27ac, Tumor, Promoter activity, Machine learning
1
Introduction
Cells orchestrate gene activity by controlling the frequency and
quantity of transcribed RNA. This spatial and temporal control
allows a given cell to respond to a plethora of intra- and extracellu-
lar signals and deﬁnes speciﬁc cell types with different cell functions.
To initiate transcription, promoter regions regulate these binding
events at the transcription start site (TSS) by integrating signals
from distal enhancers and local histone modiﬁcations (HMs).
Notably, tumors take advantage of alternative promoter usage to
activate repressed oncogenes [1–3], increase isoform diversity
[2, 3], and evade host immunity [3, 4].
Authors Karissa Dieseldorff Jones and Daniel Putnam have equally contributed to this chapter.
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_6,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
73

74
Karissa Dieseldorff Jones et al.
Pediatric tumors harbor fewer mutations than adult tumors
[5, 6], and, concomitantly, use epigenetic deregulation to promote
cancer initiation and progression [7]. Numerous groups have high-
lighted the potential of HMs and other epigenetic modiﬁcations to
predict gene expression [8–10]. Chromatin immunoprecipitation
sequencing (ChIP-seq) is the most common technique used to
quantify HM activities [11], and Cut&Run has surfaced as a great
alternative to meet the limitations of ChIP-seq [12]. Still, studies of
individual patient tumors in pediatric tumors are often limited by
the rarity of patient samples, limited amounts of fresh starting
material, and the extensive workload needed [13, 14].
Eukaryote DNA methylation (DNAm) is a regulatory mecha-
nism that occurs when a methyl group (-CH3) is covalently
attached to cytosine (C) to form 5-methylcytosine (5mC). It can
be accurately proﬁled in different tissue types through both array
[15, 16] and sequencing [17] methods. The DNAm pattern is
mechanistically linked to transcription factor binding and HMs
[18–25] and is integral in determining chromatin structure in
normal as well as disease conditions [26, 27]. However, the extent
to which DNAm contributes to the regulation of individual gene
expression is not well understood [13, 28, 29], with few exceptions
(e.g., hypermethylation of the promoters of RB1, CDKN2A, and
MGMT) [30].
To address these challenges, we developed MethylationToAc-
tivity (M2A), a deep convolutional neural network that captures the
complex relation between DNAm signatures and promoter activ-
ities [31]. M2A is highly accurate and robust in revealing promoter
activity landscapes. Here, we explain the steps of software installa-
tion and pipeline application.
The M2A workﬂow is summarized in Fig. 1, and each step is
further described in more detail in Table 1. M2A starts with raw
DNAm feature extraction near individual TSSs. This is followed by
high-level feature extraction through the CNN layers and mapping
between the generalized (high-order) features and the ﬁnal output
(i.e., the H3K4me3 and H3K27ac enrichment of the promoter) in
the fully connected (FC) layers.
2
Materials
2.1
Summary
M2A is available in four operating modes: (1) Github Clone,
(2) Github Docker Image, (3) Github Pipeline, and (4) St. Jude
Cloud. The main hub is located at https://github.com/chenlab-

A Guide to MethylationToActivity: A Deep Learning Framework That Reveals. . .
75
Fig. 1 Workﬂow illustrating both the MethyationToActivity vanilla version and optional transfer learning
pipeline
sj/M2A. The following chapter will elaborate on the Github
Pipeline.
2.1.1
Github Clone
1. Clone M2A from from Github
Git clone https://github.com/chenlab-sj/M2A.git
2. Ensure the following software packages are installed

Doc
Table 1
MethylationToActivity pipeline step descriptions
Process
Description
1_ResponseVariable
Generate histone enrichment for each unique promote region (transfer-
learning only)
2_MethylationFeatures
Process whole genome bisulﬁte sequencing (WGBS) features for model input
3_CombineInput
Scale and recombine features, and, for transfer learning, calculate HM values
(also stated as Step 3: Format)
4_RunModel
Using pre-generated input, get HM predictions for each unique promoter
region
5_TransferLearning
(Optional)
Train fully connected layers of a particular model for increased performance in
your domain of interest
76
Karissa Dieseldorff Jones et al.
Package
Version
pyBigWig
0.3.13
Numpy
1.17.1
Pandas
0.25.1
Pandarallel
1.4.2
Scikit-learn
0.20.2
H5py
2.9.0
Keras
2.2.4
Tensorflow
1.10.1
Scipy
1.3.1
Matplotlib
3.3.0
Cwltool
1.0
Psutil
5.6.1
3. Refer to M2A README.md to follow instructions using a cwl
workﬂow or use the Github Pipeline speciﬁed below.
2.1.2
Docker
M2A provides a Dockerﬁle that builds an image with all the
included dependencies.
1. To use this image, install Docker for your platform. In the
M2A project directory, build the following Docker image:
ker build –tag stjude/m2a:0.0.1.
2. Refer to M2A README.md to follow instructions using a cwl
workﬂow or use the Github Pipeline speciﬁed below.

A Guide to MethylationToActivity: A Deep Learning Framework That Reveals. . .
77
2.1.3
St. Jude Cloud
St. Jude Cloud provides the infrastructure to run a user-friendly
GPU accelerated pipeline.
1. Log in to St. Jude Cloud. Refer to the following URL:
https://university.stjude.cloud/docs/genomics-plat
form/workﬂow-guides/methylation-to-activity/
2. Select the MethylationToActivity (M2A) Project. Click Start.
This creates a new DNAnexus workspace and imports the
workﬂow. When the “Launch Tool” and “View Results” tabs
appear, the workﬂow has been successfully created.
3. Click “Launch Tool” with or without Transfer Learning. Select
the desired option. This will redirect to project analysis page
with conﬁgurable settings and inputs.
4. Under the “Analysis Inputs 1” tab, input the ﬁles requested.
The ﬁles will need to be uploaded to your project space on the
cloud before they become available for selection. Note: Only
input a “Promoter deﬁnitions” and/or “HDF5 format model”
ﬁle(s) if the default is not desired.
Refer to the following link for cloud ﬁle upload/
download:
https://university.stjude.cloud/docs/genomics-plat
form/analyzing-data/command-line
5. Choose desired “Genome” and “Model selection” from the
drop-down menus. Note: If an alternative “Promoter deﬁni-
tions” ﬁle is uploaded, the “Genome” must be set to “custom.”
6. Click the “Start Analysis” button located at the top right of the
screen to queue the project run. The run may take some time to
begin based on the DNAnexus queue.
7. Once the project has completed, download the result ﬁles.
Refer to the cloud ﬁle upload/download link above.
3
Methods
3.1
Step 1: Response
Variable (Only for
Transfer Learning)
The main objective of Step 1 is to summarize ChipSeq signal in
each promoter region. This is performed by summing the Chip-seq
signal, ChIPSum (H3K27ac or H3K4me3), on a 2 Kb window
centered at the transcription start site (+/- 1 Kb in both directions).
The same procedure is performed for the Chip-seq control termed
InputSum. The chip-seq enrichment is computed as the log2
((ChipSumSignal + Alpha) / InputSumSignal + Alpha)) where
Alpha is the ﬁrst quartile of the control signal. This is called log2_-
ChipDivInput and is the response variable for transfer learning. See
Fig. 2 for visual representation.

python
1_getResponseVariable.py
[Chip_Path]
[Input_Path]
2_Promoter_Definitions_hg19.txt
python
1_getResponseVariable.py
[Chip_Path]
[Input_Path]
2_Promoter_Definitions_hg19.txt
--outFileName
[OutFileName]
--outDirectory [OutFilePath]
78
Karissa Dieseldorff Jones et al.
Fig. 2 Response variable overview illustrating the calculation behind the newly added column
3.2
Input
(1) ChipSeq.bw and matching Input.bw
(2) The default promoter deﬁnitions ﬁle (6_InputFiles/2_Pro-
moter_Deﬁnitions_hg19.txt) contains the following columns:
•
EnsmblID_T = Ensemble transcript ID
•
EnsmblID_G = Ensemble gene ID
•
Gene = human readable gene name
•
Strand = + or -
•
Chr = “chr1, chr2, . . . chrX, chrY”
•
Start = Gene Start
•
End = Gene End
•
RStart = Transcription start site (TSS) - 1000bp
•
REnd = Transcription start site (TSS) + 1000bp
3.3
Example
Command
3.3.1
Optional
Arguments
--outFileName: Desired output ﬁle name (type: str)
--outDirectory: Desired output directory (type: str)
3.3.2
Optional Example
Command

A Guide to MethylationToActivity: A Deep Learning Framework That Reveals. . .
79
3.4
Output
•
Rows: promoter sites
•
Columns:
– EnsmblID_T: Ensemble Transcript ID
– EnsmblID_G: Ensemble Gene ID
– Gene: Gene Name
– Strand: + or -
– Chr: Chromosome
– Start: TSS Start Site
– End: TSS End Site
– RStart: Region Start Site
– REnd: Region End Site
– Log2_ChipDivInput: “Actual” signal (see more information
in the description and ﬁgure)
3.5
Step 2: Feature
Extraction
The main objective of Step 2 is to process the whole genome
bisulﬁte sequencing (WGBS) features for model input. A signature
is made from multiple methylation feature calculations per window
(n=20), per window size (250 bp, 2500 bp), per promoter (TSS
region). The three methylation (M-value) features calculated per
window include the average methylation, the variance of methyla-
tion, and the fraction of the sum of squared differences (SSD) for
the window methylation over the entire region. As mentioned
above, these three DNAm features are calculated for each of the
20 windows surrounding each TSS site, sized 250 bp and 2500
bp. This will result in 120 newly added columns of feature calcula-
tions. See Fig. 3 for a visual representation, including a calculation
of each feature.
3.6
Input
(1) Methylation ﬁle
•
Tab delimited
•
Required headers (order does not matter):
– chrom, (chromosome ID)
– pos, (position of the C in the CpG)
– mval, (calculated mvalue of a given CpG)
(2) By default, uses the promoter deﬁnitions ﬁle provided in
GitHub: 2_Promoter_Deﬁnitions_hg19.txt

python
2_getMethylationV2.py
[MethFileName]
2_Promoter_Defi-
nitions_hg19.txt
python
2_getMethylationV2.py
[MethFileName]
2_Promoter_Defi-
nitions_hg19.txt
--nbWorkers
[Cores]
--outFileName
[OutFile-
Name] --outDirectory [OutFilePath]
80
Karissa Dieseldorff Jones et al.
Fig. 3 Feature extraction overview illustrating the calculation behind the newly added columns
DNA methylation features, including the windowed M-value mean, variance, and the fraction of the SSD of
M-values (FSSD), were calculated and represented by the feature vectors Mavei, Mvari, and Mfssdi. Here,
i represents the promoter, j represents a speciﬁc window for a particular promoter, and Mvalk represents the
Mval for individual CpGs in a region where Mvalk(j) is the Mval for an individual CpG in a speciﬁc window
3.7
Example
Command
3.7.1
Optional
Arguments
--nbWorkers: Number of threads to use (type: int)*
*This will be constrained by the threads available. It will allow for
the work to be parallelized among a designated amount of
cores.
--outFileName: Desired output ﬁle name (type: str)
--outDirectory: Desired output directory (type: str)
3.7.2
Optional Example
Command

Run the model with Step 1 and Step 2 output for transfer learning.
A Guide to MethylationToActivity: A Deep Learning Framework That Reveals. . .
81
3.8
Output
•
Rows: promoter sites
•
Columns:
– EnsmblID_T: Ensemble Transcript ID
– EnsmblID_G: Ensemble Gene ID
– Gene: Gene Name
– Strand: + or -
– Chr: Chromosome
– Start: TSS Start Site
– End: TSS End Site
– Rstart: Region Start Site
– Rend: Region End Site
– 60 column succession of Window -10 to +10 for window size
250 kb for each feature (Example column title: 250_W-
10_M_Ave)
– 60 column succession of Window -10 to +10 for window size
2500 kb for each feature
3.9
Step 3: Format
The main objective of Step 3 is to combine all features into tensors
(-n dimensional matrix) for input to our machine learning model.
To accomplish this, the tensor is reshaped to (N, Resolutions,
Windows, Features) or (96757, 2, 20, 3) dimensions.
If transfer learning is needed, this will also combine the
response variable resulting from Step 1. See Fig. 1 for a visual
representation.
3.10
Input
Scenario 1:
Simply run the model with Step 2 output.
Scenario 2:
(1) Step 1 Output: Tab delimited ﬁle containing response
variable
•
Positional and gene data including log2ChipDivInput
(2) Step 2 Output: Tab delimited ﬁle containing methylation
features for 250 and 2,500 base pair window sizes
•
Features: Average, Variation, Fraction of Region SSD
•
Positional and Gene data: EnsmblID_T, EnsmblID_G,
Gene, Strand, Chr, Start, End, RStart, Rend

python 3_Combine.py [MethylationFilePath]
python 3_Combine.py [MethylationFilePath] --ResponseVariable-
Path [ReponseVariableFilePath]
python 3_Combine.py [MethylationFilePath] --ResponseVariable-
Path [ReponseVariableFilePath] --outFileName [OutFileName] --
outDirectory [OutFilePath]
82
Karissa Dieseldorff Jones et al.
3.11
Example
Command
Scenario 1:
Scenario 2:
3.11.1
Optional
Arguments
--outFileName: Desired output ﬁle name (type: str)
--outDirectory: Desired output directory (type: str)
3.11.2
Optional Example
Command
3.12
Output
One HDF5 ﬁle for prediction or transfer learning(extension=.h5)
The output dataset is termed “FeatureInput” in the HDF5.
It is an m by n array,
Where m = Windowsizes (resolutions)
Where n = Window position relative to the TSS (W-10, W- 9...W-
1, W1, W2, . . ., W10)
All meta data/positional values are stored in the hdf5 format as
bytes (binary format), with exception of “FeatureInput”
3.13
Step 4: Run
Model
The main objective of Step 4 is to generate all of the H3K27ac
and/or H3K4me3 enrichment signal predictions for each of the
promoter sites (TSS regions). See Figs. 1 and 4 for a visual
representation.
Fig. 4 Deep learning model overview

Python 4_getPredictions.py [FeatureFilePath] [ModelFilePath]
python
4_getPredictions.py
[FeatureFilePath]
[ModelFilePath]
--outFileName [OutFileName] --outDirectory [OutFilePath]
A Guide to MethylationToActivity: A Deep Learning Framework That Reveals. . .
83
3.14
Input
(1) Feature ﬁle
•
HDF5 ﬁle containing dataset termed “FeatureInput” and
meta data (for more information see Step 3 output section)
(2)
•
Model File
Model ﬁles provided in GitHub:
M2A_H3K27ac_Model_V2.h5
M2A_H3K4me3_Model_V2.h5
3.15
Example
Command
3.15.1
Optional
Arguments
--outFileName: Desired output ﬁle name (type: str)
--outDirectory: Desired output directory (type: str)
3.15.2
Optional Example
Command
3.16
Output
•
Rows: promoter sites
•
Columns (order of columns may differ):
– EnsmblID_T: Ensemble Transcript ID
– EnsmblID_G: Ensemble Gene ID
– Gene: Gene Name
– Strand: + or -
– Chr: Chromosome
– Start: TSS Start Site
– End: TSS End Site
– Rstart: Region Start Site
– Rend: Region End Site
– Regressor_Pred: Predicted Signal
3.17
Example Output
chr
End
EnsmblID_G
EnsmblID_T
Gene
REnd
RStart
Start
Strand
Regressor_PRed
chr7
127231759
ENSG00000004059.6
ENST00000000233.5
ARF5
127229399
127227399
127228399
+
3.0353603
chr12
9102551
ENSG00000003056.3
ENST00000000412.3
M6PR
9103551
9101551
9092961
-
3.6402566
chr12
2913124
ENSG00000004478.5
ENST000000001008.4
FKBP4
2905119
2903119
2904119
+
3.7427473

python
5_getTransferModel.py
[FeatureFilePath]
[ModelFile-
Path]
python
5_getTransferModel.py
[FeatureFilePath]
[ModelFile-
Path] --outFileName [OutFileName] --outDirectory [OutFilePath]
84
Karissa Dieseldorff Jones et al.
3.18
Step 5: Transfer
Learning (Optional)
Perform transfer learning on a single sample, updating the current
machine learning model. Extending our trained machine learning
model to learn features from a new data type. See Fig. 4 for visual
representation.
3.19
Input
(1) Feature File
•
HDF5 ﬁle containing dataset termed “FeatureInput” and
meta data (for more information see Step 3 output section)
(2)
•
Model File
Model ﬁles provided in GitHub:
M2A_H3K27ac_Model_V2.h5
M2A_H3K4me3_Model_V2.h5
3.20
Example
Command
3.20.1
Optional
Arguments
--outFileName: Desired output ﬁle name (type: str)
--outDirectory: Desired output directory (type: str)
3.20.2
Optional Example
Command
3.21
Output
Updated HDF5 model ﬁle. This will be the new model used for
testing new data rather than the previously trained model. View
Fig. 1 for more information on transfer learning main overview.
References
1. Davuluri RV, Suzuki Y, Sugano S, Plass C,
Huang TH (2008) The functional conse-
quences of alternative promoter use in mam-
malian genomes. Trends Genet 24:167–177.
https://doi.org/10.1016/j.tig.2008.01.008
2. Demircioglu D et al (2019) A pan-cancer tran-
scriptome analysis reveals pervasive regulation
through
alternative
promoters.
Cell
178:
1465–1477 e1417. https://doi.org/10.
1016/j.cell.2019.08.018
3. Qamra A et al (2017) Epigenomic Promoter
Alterations Amplify Gene Isoform and Immu-
nogenic Diversity in Gastric Adenocarcinoma.
Cancer Discov 7:630–651. https://doi.org/
10.1158/2159-8290.CD-16-1022
4. Sotillo E et al (2015) Convergence of acquired
mutations and alternative splicing of CD19
enables
resistance
to
CART-19
immunotherapy.
Cancer
Discov
5:1282–
1295. https://doi.org/10.1158/2159-8290.
CD-15-1020
5. Grobner SN et al (2018) The landscape of
genomic alterations across childhood cancers.
Nature 555:321–327. https://doi.org/10.
1038/nature25480
6. Ma X et al (2018) Pan-cancer genome and
transcriptome analyses of 1,699 paediatric leu-
kaemias and solid tumours. Nature 555:371–
376. https://doi.org/10.1038/nature25795
7. Huether R et al (2014) The landscape of
somatic mutations in epigenetic regulators
across 1,000 paediatric cancer genomes. Nat
Commun 5:3630. https://doi.org/10.1038/
ncomms4630
8. Dong X et al (2012) Modeling gene expression
using chromatin features in various cellular

A Guide to MethylationToActivity: A Deep Learning Framework That Reveals. . .
85
contexts. Genome Biol 13:R53. https://doi.
org/10.1186/gb-2012-13-9-r53
9. Karlic R, Chung HR, Lasserre J, Vlahovicek K,
Vingron M (2010) Histone modiﬁcation levels
are predictive for gene expression. Proc Natl
Acad Sci U S A 107:2926–2931. https://doi.
org/10.1073/pnas.0909344107
10. Singh R, Lanchantin J, Robins G, Qi Y (2016)
DeepChrome: deep-learning for predicting
gene expression from histone modiﬁcations.
Bioinformatics 32:i639–i648. https://doi.
org/10.1093/bioinformatics/btw427
11. Kelley DZ et al (2017) Integrated analysis of
whole-genome ChIP-Seq and RNA-Seq data
of primary head and neck tumor samples
associates HPV integration sites with open
chromatin marks. Cancer Res 77:6538–6550.
https://doi.org/10.1158/0008-5472.CAN-
17-0833
12. Skene PJ, Henikoff S (2017) An efﬁcient tar-
geted nuclease strategy for high-resolution
mapping
of
DNA
binding
sites.
Elife
6. https://doi.org/10.7554/eLife.21856
13. Kagohara LT et al (2018) Epigenetic regula-
tion of gene expression in cancer: techniques,
resources and analysis. Brief Funct Genomics
17:49–63. https://doi.org/10.1093/bfgp/
elx018
14. Zhang P, Lehmann BD, Shyr Y, Guo Y (2017)
The
utilization
of
formalin
ﬁxed-parafﬁn-
embedded
specimens
in
high
throughput
genomic
studies.
Int
J
Genomics
2017:
1926304. https://doi.org/10.1155/2017/
1926304
15. de Ruijter TC et al (2015) Formalin-ﬁxed, par-
afﬁn-embedded (FFPE) tissue epigenomics
using Inﬁnium HumanMethylation450 Bead-
Chip assays. Lab Invest 95:833–842. https://
doi.org/10.1038/labinvest.2015.53
16. Moran S et al (2014) Validation of DNA meth-
ylation proﬁling in formalin-ﬁxed parafﬁn-
embedded samples using the Inﬁnium Human-
Methylation450
Microarray.
Epigenetics
9:
829–833. https://doi.org/10.4161/epi.
28790
17. Gu H et al (2010) Genome-scale DNA meth-
ylation mapping of clinical samples at single-
nucleotide resolution. Nat Methods 7:133–
136. https://doi.org/10.1038/nmeth.1414
18. Charlet J et al (2016) Bivalent regions of cyto-
sine methylation and H3K27 acetylation sug-
gest an active role for DNA methylation at
enhancers. Mol Cell 62:422–431. https://doi.
org/10.1016/j.molcel.2016.03.033
19. Kondo Y (2009) Epigenetic cross-talk between
DNA methylation and histone modiﬁcations in
human cancers. Yonsei Med J 50:455–463.
https://doi.org/10.3349/ymj.2009.50.
4.455
20. Onuchic V et al (2018) Allele-speciﬁc epigen-
ome maps reveal sequence-dependent stochas-
tic switching at regulatory loci. Science 361.
https://doi.org/10.1126/science.aar3146
21. Rothbart SB, Strahl BD (1839) Interpreting
the language of histone and DNA modiﬁca-
tions. Biochim Biophys Acta 627-643:2014.
https://doi.org/10.1016/j.bbagrm.2014.
03.001
22. Shefﬁeld NC et al (2017) DNA methylation
heterogeneity deﬁnes a disease spectrum in
Ewing
sarcoma.
Nat
Med
23:386–395.
https://doi.org/10.1038/nm.4273
23. Stadler MB et al (2011) DNA-binding factors
shape the mouse methylome at distal regu-
latory regions. Nature 480:490–495. https://
doi.org/10.1038/nature10716
24. Zhu H, Wang G, Qian J (2016) Transcription
factors as readers and effectors of DNA meth-
ylation. Nat Rev Genet 17:551–565. https://
doi.org/10.1038/nrg.2016.83
25. Ziller MJ et al (2013) Charting a dynamic
DNA methylation landscape of the human
genome. Nature 500:477–481. https://doi.
org/10.1038/nature12433
26. Hashimshony T, Zhang J, Keshet I, Bustin M,
Cedar H (2003) The role of DNA methylation
in setting up chromatin structure during devel-
opment. Nat Genet 34:187–192. https://doi.
org/10.1038/ng1158
27. Moore LD, Le T, Fan G (2013) DNA methyl-
ation and its basic function. Neuropsychophar-
macology 38:23–38. https://doi.org/10.
1038/npp.2012.112
28. Jones PA (2012) Functions of DNA methyla-
tion: islands, start sites, gene bodies and
beyond. Nat Rev Genet 13:484–492. https://
doi.org/10.1038/nrg3230
29. Lay FD et al (2015) The role of DNA methyla-
tion in directing the functional organization of
the cancer epigenome. Genome Res 25:467–
477.
h ttps://doi.org/10.1101/gr.
183368.114
30. Baylin SB (2005) DNA methylation and gene
silencing in cancer. Nat Clin Pract Oncol 2
(Suppl 1):S4–S11. https://doi.org/10.1038/
ncponc0354
31. Williams J et al (2021) MethylationToActivity:
a deep-learning framework that reveals pro-
moter activity landscapes from DNA methy-
lomes in individual tumors. Genome Biol 22:
24. https://doi.org/10.1186/s13059-020-
02220-y

Chapter 7
DNA Modiﬁcation Patterns Filtering and Analysis Using
DNAModAnnot
Alexis Hardy, Sandra Duharcourt, and Matthieu Defrance
AbstractAbstract
Mapping DNA modiﬁcations at the base resolution is now possible at the genome level thanks to advances
in sequencing technologies. Long-read sequencing data can be used to identify modiﬁed base patterns.
However, the downstream analysis of Paciﬁc Biosciences (PacBio) or Oxford Nanopore Technologies
(ONT) data requires the integration of genomic annotation and comprehensive ﬁltering to prevent the
accumulation of artifact signals. We present in this chapter, a linear workﬂow to fully analyze modiﬁed base
patterns using the DNA Modiﬁcation Annotation (DNAModAnnot) package. This workﬂow includes a
thorough ﬁltering based on sequencing quality and false discovery rate estimation and provides tools for a
global analysis of DNA modiﬁcations. Here, we provide an application example of this workﬂow with
PacBio data and guide the user by explaining expected outputs via a fully integrated Rmarkdown script. This
protocol is presented with tips showing how to adapt the provided code for annotating epigenomes of any
organism according to the user needs.
Key words Epigenomics, Epigenome Annotation, DNA modiﬁcations, DNA Methylation, PacBio
Sequencing, Nanopore technology, DNAModAnnot
1
Introduction
Recent advances in sequencing technologies have greatly contrib-
uted to the epigenomics ﬁeld. Single-molecule real time (SMRT)
sequencing from Paciﬁc Biosciences (PacBio) and nanopore
sequencing from Oxford Nanopore Technologies (ONT) allow
the mapping of different DNA modiﬁcations at the base resolution
in the whole genome [1]. These long-read sequencing technologies
can even detect modiﬁcations in regions with a high amount of
repeats
that
were
previously
inaccessible
with
Illumina
sequencing [1].
Nanopore sequencing software such as Nanopolish or Deep-
Signal use differences in electric current intensity to detect modiﬁed
bases as they pass through the pores [2]. However, for many of
these software, the genome annotation (from the GC density to the
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_7,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
87

88
Alexis Hardy et al.
presence of repeated regions) is essential as it can impact the efﬁ-
ciency of DNA modiﬁcation detection in ONT data thus leading to
higher false-positive rates in some genomic regions [2].
For SMRT sequencing, the SMRT-Link software (SMRT-
Portal for older versions) uses slowing down events of the DNA
polymerase during sequencing to detect modiﬁed bases [1, 3]. Sev-
eral
modiﬁcations,
such
as
6-methyladenine
(6mA)
or
5-methylcytosine (5mC), can be detected as long as the coverage
requirement is fulﬁlled [4]. PacBio also suggests to deﬁne a thresh-
old based on the score parameter (also called « Modiﬁcation QV »)
by comparing the score of all bases sequenced [3]. However, this
method requires a strong signal that can be easily distinguished
from the noise in order to choose an adapted threshold based on
the score. Also, SMRT sequencing was found to overestimate the
modiﬁcation levels, especially when the amount of modiﬁed bases is
very low in the genome [5]. Thus, ill-adapted ﬁltering in such cases
can cause high amounts of artifacts.
To overcome this lack of stringency, we have previously released
DNAModAnnot (DNA Modiﬁcation Annotation) [6], an R pack-
age allowing comprehensive ﬁltering and analysis of modiﬁed
patterns for PacBio or ONT data using adapted visualization tools.
This package is divided into six modules, as illustrated in Fig. 1,
that can be combined to fully analyze pre-processed PacBio or
ONT data. DNAModAnnot provides tools to load pre-processed
data (« Data Loading ») and analyze the modiﬁcation distribution
Fig. 1 Overall workﬂow of the DNAModAnnot package used to ﬁlter and analyze DNA modiﬁcation patterns

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
89
at the genome level (« Global DNA Mod ») or using the genome
annotation provided (« DNA Mod annotation »). Furthermore
« Sequencing quality » assessment and False Discovery Rate esti-
mation (« FDR estimation ») can be directly used to perform a
thorough ﬁltering of PacBio or ONT data (« Filter ») (Fig. 1). This
modular toolbox uses object classes from the GenomicRanges [7]
and BioStrings [8] packages allowing a user-friendly coupling with
functions from other main Bioconductor packages.
In this chapter, we provide a roadmap for a systematic analysis
of DNA modiﬁcations and an example of DNAModAnnot applica-
tion on PacBio data. This workﬂow includes the loading of
pre-processed ﬁles, the ﬁltering steps based on sequencing quality
and false discovery rate estimations, and the DNA modiﬁcation
pattern analysis with genomic annotations or analysis at the
genome-wide level. It provides a summary of the functions
provided by DNAModAnnot and a linear processing that can be
easily extended with additional R packages for more advanced
analyses.
2
Materials
2.1
Data Sources
In this protocol, we use PacBio RSII data [9] (and additional
sequencing data listed in Table 1 [9, 10]) to analyze 6mA patterns
in Tetrahymena thermophila. The patterns of this DNA modiﬁca-
tion have already been described in this organism [9]. Using this
linear workﬂow, the user will learn to use DNAModAnnot by
retrieving and analyzing these patterns.
For SMRT sequencing data, DNAModAnnot need the modiﬁ-
cations.gff (data from modiﬁed bases only) and modiﬁcations.csv
(data from all sequenced bases) ﬁles. These pre-processed data can
be
sourced
from
https://github.com/AlexisHardy/
DNAModAnnot_AdditionalData,
also
listed
in
Table
1.
Pre-processed ﬁles were produced using the SMRT-link-tools
v7.0.1.66975-0 and 6mA was detected via the ipdSummary tool
[11]. Command lines to regenerate the modiﬁcations.csv and mod-
iﬁcations.gff ﬁles from the raw SMRT sequencing data (listed in
Table 1) are detailed in the Notes section (see Note 1).
DNAModAnnot [6] can also load ONT data pre-processed
with the DeepSignal software [12], but we will only focus on
PacBio data in this protocol (see Note 2).
This package also needs the genome assembly ( fasta) and its
annotation (e.g., gff) in order to analyze the DNA modiﬁcation
patterns (listed in Table 1).
All the ﬁles required to perform the analysis are listed in
Table 1. This table also contains additional sequencing data,
which can be analyzed together with DNA modiﬁcation patterns.

90
Alexis Hardy et al.
Table 1
List of input files used in this protocol
Description
Format Link
Required?
T. thermophila (June2014) genome
assembly sequence
fasta
http://ciliate.org/index.php/
home/downloads
Mandatory
T. thermophila (June2014) genome
annotation
gff3
http://ciliate.org/index.php/
home/downloads
Mandatory
T. thermophila pre-processed SMRT-seq
data (via SMRT-link tools
v7.0.1.66975-0) using
T_thermophila_June2014 genome
assembly.
SMRT-seq data was retrieved from
GSM2534782 [9] contig_list.txt
contains the listing of contigs selected
in this example.
gff, csv
and
txt
https://github.com/
AlexisHardy/
DNAModAnnot_
AdditionalData
Mandatory
T. thermophila SMRT-seq data (to be
retrieved via SRA Run Selector) [9]
bax.h5
https://www.ncbi.nlm.nih.
gov/geo/query/acc.cgi?
acc=GSM2534782
Not required if
pre-processed
ﬁles are available
T. thermophila MNase-seq [9]
bed
https://www.ncbi.nlm.nih.
gov/geo/query/acc.cgi?
acc=GSM2534785
Optional
T. thermophila H2A.Z ChIP-seq [9]
bed
https://www.ncbi.nlm.nih.
gov/geo/query/acc.cgi?
acc=GSM2534783
Optional
T. thermophila RNA-seq [10]
txt
https://www.ncbi.nlm.nih.
gov/geo/query/acc.cgi?
acc=GSM692081
Optional
2.2
Software and
Installation
The required packages are detailed in the description ﬁle of the
DNAModAnnot [6] package and can be installed via the install
command of the BiocManager [13] package:
BiocManager::install(c('Biostrings', 'BSgenome', 'Gviz', 
'seqLogo'))
DNAModAnnot [6] can be installed via GitHub using the
devtools [14] package:
devtools::install_github("AlexisHardy/DNAModAnnot")

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
91
3
Methods
For SMRT sequencing data, methylation detection via SMRT Link
[11] returns two ﬁles: the modiﬁcations.gff (containing data from
modiﬁed bases only) and modiﬁcations.csv (containing data from all
sequenced bases) ﬁles (see Note 2 for ONT data) (see Note 3).
For both sequencing data type, the data must ﬁrst be loaded
into R. Sequencing quality can be assessed to ﬁlter out contigs with
low coverage, which could bias the global statistics of modiﬁed base
distribution. DNA modiﬁcation distribution can also be analyzed at
the genome level. For PacBio data, false discovery rate can be
estimated to select an appropriate ﬁlter based on available detection
parameters (score or ipdRatio). By providing the genomic annota-
tion, it is also possible to identify the patterns of DNA modiﬁca-
tions associated with speciﬁc annotation features.
Here, we provide an example of analysis of 6mA patterns using
Tetrahymena thermophila PacBio RSII data [9] (and additional
sequencing data listed in Table 1 [9, 10]): from the input ﬁles
importation to the generation of graphs and reports. The results
are presented in Figs. 2 and 3 and Table 2. An Rmarkdown docu-
ment is also provided with all the commands and details of this
protocol (see Note 4).
3.1
Loading
Mandatory Files
Go to the webpages listed in Table 1 and collect the bed/csv/gff/
fasta/txt ﬁles. For PacBio data, you can either download SMRT
link [11] processed ﬁles called modiﬁcations.gff and modiﬁcations.
csv or download the bax.h5 ﬁles via the SRA Run Selector in the
GSM2534782 repository and use SMRT Link [11] to generate the
modiﬁcations.gff and modiﬁcations.csv ﬁles (see Note 1).
3.1.1
Import Genome
Sequence Information
readDNAStringSet
1. Import the genome sequence as a DNAstringSet object using
the
function from the Biostrings package
[8] then ﬁlter it using the contig_ﬁle.txt ﬁle to keep only the
sampled contigs (see Note 3).
organism_genome <-
Biostrings::readDNAStringSet("./genome.fasta")
names(organism_genome) <- gsub(x =
names(organism_genome), 
pattern = " .*", 
replacement = "")
#We only retrieve the 50 contigs and then we filter the 
organism_genome object
contigsToKeep <- read.table("./contig_list.txt")[,1]
organism_genome <- organism_genome[
names(organism_genome) %in% contigsToKeep]

Use the
function with the genome
DNAstringSet object to compute a sequencing report
about the genome assembly provided (similar to reports
from the QUAST software [15]) in a data.frame object.
92
Alexis Hardy et al.
Fig. 2 Example of graphs generated via DNAModAnnot using a subset of T. thermophila SMRT-seq data. (a)
Logo generated via the DrawModLogo function displaying an AT motif associated with 6mA. 5 bp were
selected upstream and downstream 6mA positions. “Negative” information content corresponds to informa-
tion content for depletion signal. (b) Barplot generated using the DrawModBasePropByFeature function using
gene and intergenic categories for comparison showing 6mAT enrichment in genes. (c) Barplot generated
using the DrawModBaseCountsWithinFeature function showing the enrichment of 6mAT downstream TSS. (d)
Boxplot generated using the DrawParamPerModBaseCategories function: a slight association between 6mAT
count (per kbp) and normalized RNA-seq read count can be observed. G-m (mid-log exponential growth)
sample was used here. Intervals are computed from quantiles to optimize the repartition of windows between
the categories
GetAssemblyReport
(a)
cOrgAssemblyName = "T.thermophila_June2014 (sampled)"
)
report_assembly <- GetAssemblyReport(
dnastringsetGenome = organism_genome,

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
93
Fig. 3 Example of graph generated using the DrawModBasePropDistFromFeature function with a subset of
T. thermophila SMRT-seq data then the AddToModBasePropDistFromFeaturePlot function with T. thermophila
MNase-seq data. Here, enrichment of 6mAT can be observed between peaks of MNase-seq reads down-
stream TSS
GetContigCumulLength
DrawContigCumulLength
(b)
Use the
function to retrieve a
data.frame with the contigs size and cumulated size.
This
data.frame
can
be
used
with
the
function to plot cumulated
length by contig.
contig_cumul_length <-
GetContigCumulLength(organism_genome)
DrawContigCumulLength(
nContigCumsumLength =
contig_cumul_length$cumsum_Mbp_length,
cOrgAssemblyName = "T.thermophila_June2014 (sampled)",
lGridInBackground = TRUE
)

94
Alexis Hardy et al.
Table 2
Global 6mA distribution report using a subset of T. thermophila SMRT-seq data and
T. thermophila_June2014 genome assembly (small version)
Parameters
T.thermophila_June2014
6mA count
19,354
Adenine count (sequenced)
15,488,227
Ratio 6mA/A
0.00125
Ratio 6mA/A corrected
0.00096
6mA mean fraction
0.76926
6mA mean coverage
31.38
6mA mean ipdRatio
43.26
6mA mean identiﬁcationQv
24.26
6mAA %
0.67%
6mAC %
0.19%
6mAG %
0.72%
6mAT %
98.42%
GetGenomeGRanges
2. Use the
function with the genome DNAs-
tringSet object to retrieve a GRanges object representing the
contigs (which will be required for some functions from this
package).
organism_genome_range <-
GetGenomeGRanges(organism_genome)
3.1.2
Import Modiﬁcation
Input Files
ImportPacBioCSV
1. Use the
function to import the modiﬁca-
tions.csv ﬁle as an Unstitched GPos object (ModCSV GPos) (see
Notes 3 and 5).
ModCSV_gpos <- ImportPacBioCSV(
cPacBioCSVPath = "./modifications.csv",
cSelectColumnsToExtract = c(
"refName", "tpl", "strand",
"base", "score",
"ipdRatio", "coverage"
),
lKeepExtraColumnsInGPos = TRUE,
lSortGPos = TRUE,
cContigToBeAnalyzed = names(organism_genome)
)

To
DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
95
ImportPacBioGFF
cNameModToExtract
2. Use the
function to import the modiﬁcations.
gff ﬁle as a GRanges object (ModGFF GRanges). Only one
modiﬁcation can be imported from this ﬁle, which should be
deﬁned with the
argument (see Note 3).
ModGFF_granges <- ImportPacBioGFF(
cPacBioGFFPath = "./modifications.gff",
cNameModToExtract = "m6A",
cModNameInOutput = "6mA",
cContigToBeAnalyzed = names(organism_genome)
)
3.2
Sequencing
Quality Assessment
and Filtering
GetSeqPctByContig
1. To retrieve the percentage of sequenced bases per contig and
per strand, use the
function with the
ModCSV GPos object. This function will return a list with the
percentage per contig and per strand according to the genome
assembly sequence provided.
contig_pct_seq <- GetSeqPctByContig(ModCSV_gpos,
grangesGenome = organism_genome_range
)
DrawBarplotBothStrands
(a)
plot this percentage using a per contig and per strand
barplot, use the
function and
provide the two sub-lists (generated on the previous step)
corresponding to the forward and the reverse strands (see
Note 6).
DrawBarplotBothStrands(
nParamByContigForward = contig_pct_seq$f_strand$seqPct,
nParamByContigReverse = contig_pct_seq$r_strand$seqPct,
cContigNames = contig_pct_seq$f_strand$refName,
cGraphName = "Percentage of sequencing per contig"
)
FiltPacBio f
GetSeqPctByContig
(b)
To remove data from contigs that are not sequenced enough
(e.g.,
less
than
95%
of
sequenced
bases),
use
the
unction with the sequencing percentage list
returned by the
function (see Note 7).
e DrawDistriHistBo
2. To look at the global distribution of a numeric parameter, use
th
x function to plot a histogram along a
boxplot showing the global range of this parameter.

96
Alexis Hardy et al.
DrawDistriHistBox(ModCSV_gpos$coverage,
cGraphName = "Coverage distribution of all bases 
sequenced",
cParamName = "Coverage",
lTrimOutliers = FALSE
)
GetMeanParamByContig
3. To compute the mean of the coverage (or any available numeric
parameter)
per
contig
and
per
strand,
use
the
function with the ModCSV GPos
and ModGFF GRanges objects depending on which parameter
you want to ﬁlter on. For coverage, we recommend using the
ModCSV GPos object.
contig_mean <- GetMeanParamByContig(
grangesData = ModCSV_gpos,
dnastringsetGenome = organism_genome,
cParamName = "coverage"
)
DrawBarplotBothStrands
(a)
Use the
function to plot the mean
of the chosen parameter per contig and per strand into a
barplot (see Note 6).
DrawBarplotBothStrands(
nParamByContigForward =
contig_mean$f_strand$mean_coverage,
nParamByContigReverse =
contig_mean$r_strand$mean_coverage,
cContigNames = contig_mean$f_strand$refName,
cGraphName = "Mean Coverage per contig"
)
FiltPacBio
GetMeanParamByContig
(b)
Use the
function with the mean parameter
list returned by the
function (see
Note 7).
3.3
Analysis of
Global Distribution and
Motif of DNA
Modiﬁcation Data
1.
GetModReportPacBio
Use the
function to obtain a data.frame
describing the global distribution of the DNA modiﬁcation
(e.g., modiﬁcation counts, ratio, motifs associated, mean of
parameters provided) (see Note 2). You will need to provide
both the ModCSV GPos and ModGFF GRanges objects.

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
97
report_modifications <- GetModReportPacBio(
grangesGenome = organism_genome_range,
grangesPacBioGFF = ModGFF_granges,
gposPacBioCSV = ModCSV_gpos,
cOrgAssemblyName = "T.thermophila_June2014 (sampled)",
dnastringsetGenome = organism_genome,
cBaseLetterForMod = "A",
cModNameInOutput = "6mA"
)
GetModRatioByContig
ModCSV_gpos[ModCSV_gpos$base == "A"]..
2. To compute the ratio of modiﬁed bases per contig and per
strand, use the
function with the
ModGFF GRanges. You will also need to provide all the bases
that can be targeted (modiﬁed or not) by extracting them from
the ModCSV GPos object (SubsetModCSV GPos). For exam-
ple, for 6mA you will need to keep only the « A » positions
using
the
following
command:
contig_mod_ratio <- GetModRatioByContig (ModGFF_granges,
ModCSV_gpos[ModCSV_gpos$base == "A"],
dnastringsetGenome = organism_genome,
cBaseLetterForMod = "A"
)
DrawBarplotBothStrands
(a)
Use the
function to plot the ratio
of modiﬁed bases into a barplot per contig and per strand
(see Note 6).
contig_mod_ratio$f_strand$Mod_ratio[
is.na(contig_mod_ratio$f_strand$Mod_ratio)] <- 0
contig_mod_ratio$r_strand$Mod_ratio[
is.na(contig_mod_ratio$r_strand$Mod_ratio)] <- 0
DrawBarplotBothStrands(
nParamByContigForward =
contig_mod_ratio$f_strand$Mod_ratio,
nParamByContigReverse =
contig_mod_ratio$r_strand$Mod_ratio,
cContigNames = contig_mod_ratio$f_strand$refName,
cGraphName = "Modif/Base ratio per contig (Sequenced 
sites only)"
)
FiltPacBio
GetModRatioByContig
(b)
Use the
function with the list of modiﬁcation
ratios returned by the
function if
you want to remove contigs with a low modiﬁcation ratio
(see Note 7).

98
Alexis Hardy et al.
DrawModLogo
3. To reveal a potential motif or sequence enrichment around the
modiﬁed bases, you can use the
function
(Fig. 2a).
GetGRangesWindowSeqandParam
(a)
You must ﬁrst retrieve all the trimmed sequences around
each
modiﬁed
base
using
the
function
with
the
ModGFF GRanges object. This will export a new
GRanges object with a new column named « sequence »
where the trimmed sequences will be stored (see Note 8).
ModGFF_granges_seq <-
GetGRangesWindowSeqandParam(ModGFF_granges,
organism_genome_range,
dnastringsetGenome = organism_genome,
nUpstreamBpToAdd = 5,
nDownstreamBpToAdd = 5
)
(b)
Then, retrieve the trimmed sequences in the « sequence »
column and convert them as a DNAStringSet object.
Seq_ForLogo <- as(ModGFF_granges_seq$sequence, 
"DNAStringSet")
DrawModLogo
nGenomicBgACGT
nPositionsToAnnotate
cAnnotationText
(c)
Use this DNAStringSet object with the
function to plot a logo (Fig. 2a). The genomic back-
ground can be provided with the
option
to correct the logo with the proportion of A, C, G, and T,
respectively, in the genome. You can also annotate a few
positions on this logo using the
and
options to indicate, respectively,
the positions to annotate and the text to be written (see
Note 9).
backgroundACGT = c(
(100-report_assembly["gc_pct",])/2,
report_assembly["gc_pct",]/2,
report_assembly["gc_pct",]/2,
(100-report_assembly["gc_pct",])/2
)/100
DrawModLogo(
dnastringsetSeqAroundMod = Seq_ForLogo,
nGenomicBgACGT = backgroundACGT, cYunit = "ic_hide_bg",
nPositionsToAnnotate = c(6), cAnnotationText =
c("6mA"), nTagTextFontSize = 12
)

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
99
ExtractListModPosByModMotif
4. Use the
function to retrieve a
list containing the following elements:
(a)
The names of the motifs overrepresented with the DNA
modiﬁcation.
(b)
The same motifs with the position of the modiﬁcation
inside these motifs.
(c)
A table containing the percentage of modiﬁcations in each
motif tested.
(d)
A listing of ModGFF GRanges: one GRanges object for
each
motif
overrepresented
with
the
modiﬁcation
(ModGFF GRangesList).
listMotif_ModGFF_grangeslist <-
ExtractListModPosByModMotif(
grangesModPos = ModGFF_granges,
grangesGenome = organism_genome_range,
dnastringsetGenome = organism_genome,
nUpstreamBpToAdd = 0, nDownstreamBpToAdd = 1,
nModMotifMinProp = 0.05,
cBaseLetterForMod = "A",
cModNameInOutput = "6mA"
)
nModMotifMinProp
The minimum proportion required to deﬁne motifs as
“overrepresented” with the modiﬁcation can be modiﬁed
using the
option (see Note 8).
5. Extract all the bases that can be targeted (modiﬁed or not) from
the ModCSV GPos object and convert it as a GRanges object
(SubsetModCSV GRanges). For example, for 6mA, you will
need to keep only the « A » positions using the following
command:
SubsetModCSV_granges <- as(ModCSV_gpos[ModCSV_gpos$base 
== "A"], "GRanges")
GetGRangesWindowSeqandParam
Then, retrieve all the trimmed sequences around each tar-
geted base using the
function
with the SubsetModCSV GRanges object (see Note 8).
SubsetModCSV_granges_seq <- GetGRangesWindowSeqandParam(
grangesData = SubsetModCSV_granges,
grangesGenome = organism_genome_range,
dnastringsetGenome = organism_genome,
nUpstreamBpToAdd = 0,
nDownstreamBpToAdd = 1
)

estimation.
100
Alexis Hardy et al.
3.4
False Discovery
Rate Estimations and
Filtering (PacBio Only)
DNAModAnnot [6] provides tools to estimate false discovery rate
(FDR) based on a threshold for parameters associated with modiﬁ-
cation detection [16] (see Note 10). These FDR estimations can
guide the choice of the ﬁlters to be used on the score or ipdRatio
parameters. FDR estimation is only available for PacBio data.
GetFdrEstListByThresh
cNameParamToTest
1. Use the SubsetModCSV GRanges object from the previous
part with the
function to estimate
the false discovery rate by threshold on a parameter to be
ﬁltered (deﬁned with the
option; usually
the score or the ipdRatio for PacBio data).
nRoundDigits = 1,
cModMotifsAsForeground =
listMotif_ModGFF_grangeslist$motifs_to_analyse
)
score_fdr_by_motif_list <- GetFdrEstListByThresh(
grangesDataWithSeq = SubsetModCSV_granges_seq,
grangesDataWithSeqControl = NULL,
cNameParamToTest = "score",
GetFdrEstListByThresh
The
function will return a list
(by motif over-represented) of data.frames. Each data.frame
contains the FDR estimated by threshold (for the provided
parameter) and the adjusted FDR (≈the cumulative minimum
FDR).
Two methods to estimate the FDR are provided with this
function [16]:
grangesDataWithSeqControl
(a)
If you have a control sample (i.e., a non-methylated sam-
ple, e.g., whole-genome ampliﬁed/PCR ampliﬁed), you
can provide it via the
option.
grangesDataWithSeqControl
In this case, FDR will be estimated using the data
provided via the
option as
the background signal (see Note 10).
grangesDataWithSeqControl
ImportPacBioCSV
The
data
provided
via
the
option
must have the
same format as the SubsetModCSV GRanges object with
the sequence of the modiﬁed sample. This means that,
after methylation detection, the control sample (initially as
a modiﬁcations.csv ﬁle) must be imported using the
function as a control ModCSV GPos.
Steps and ﬁlters applied to the sample ModCSV should
also be applied to the control data to ensure a correct FDR
grangesDataWithSeqControl
(b)
If you do not have a control sample, you must then leave
the
option empty.

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
101
In this case, you can estimate the FDR by comparing
motifs associated with modiﬁcations against other motifs
to be used as the background signal (see Note 10).
cModMotifsAsForeground
ExtractListModPosByModMotif
Here, motifs associated with the DNA modiﬁcation
(overrepresented motifs) must be provided via the
argument as a character vector.
FDR will be estimated for each overrepresented motif
separately. The user can choose to look at one motif in
particular. It is also possible to test all « over-represented »
motifs by retrieving the “motifs_to_analyse” vector from
the output list of the
function.
This function returns a list with one data.frame if a control
sample is provided. Else a list with one data.frame per motif
tested will be returned. Each data.frame contains the FDR
estimation per threshold on the parameter tested.
GetFdrBasedThreshLimit
2. To retrieve the threshold associated with a user-deﬁned FDR,
use the
function with the FDR esti-
mation list from the previous step (see Note 11).
score_fdr_by_motif_limit <-
GetFdrBasedThreshLimit(score_fdr_by_motif_list,
nFdrPropForFilt = 0.05,
lUseBestThrIfNoFdrThr = TRUE
)
DrawFdrEstList
3. Use the
function with the FDR estimation
list to plot FDR estimation distribution per threshold and per
motif, along with a user-deﬁned FDR limit/value to be repre-
sented on the graph.
DrawFdrEstList(
listFdrEstByThr = score_fdr_by_motif_list,
cNameParamToTest = "score",
nFdrPropForFilt = 0.05
)
FiltPacBio
GetFdrBasedThreshLimit
ExtractListModPosByModMotif
4. Use the
function with the output of the
function to ﬁlter the ModGFF
object according to the deﬁned FDR-associated threshold
(by motif or not). In this case, the ModGFF GRangesList
(returned by the
function)
must be used for ﬁltering (especially if no control sample was
provided during FDR estimation) (see Note 7). Only two

102
Alexis Hardy et al.
parameters
are
recognized
for
FDR
estimation
and
ﬁltering here: the ipdRatio and the score.
ModGFF_grangeslist <- FiltPacBio(
grangesPacBioGFF =
listMotif_ModGFF_grangeslist$GRangesbyMotif,
listFdrEstByThrIpdRatio = NULL,
listFdrEstByThrScore = score_fdr_by_motif_limit
)$gff
3.5
Analysis of DNA
Modiﬁcation Patterns
with Genomic
Annotations and Other
Sequencing Data
In this section, genomic annotations must be provided to analyze
the modiﬁed base distribution. Modiﬁed base counts or propor-
tions can be computed for any category of genomic features or
quantitative parameters and can be compared to other sequencing
data, such as MNase-seq data.
In this part, we deﬁne Mod as the modiﬁed bases and Base as all
target bases (modiﬁed or not) that use the same motifs as Mod. For
example, for Mod deﬁned as “6mAT” (“6mA” in AT motif), Base
would be “AT” (“A” in AT motif).
In this part, three objects will be required for most tools (along
with the genome sequence imported as a DNAStringSet object):
1. A ModGFF GRanges associated to a motif:
FiltPacBio
(a)
(PacBio only) Extract the GRanges for the motif to ana-
lyze from the GRangesList provided by the
function used on ModGFF GRanges after False Discovery
Rate estimation.
ModGFF_granges <- ModGFF_grangeslist[["AT"]]
ExtractListModPosByModMotif
(b)
Or extract the GRanges for the motif to analyze from the
GRangesList
within
the
list
provided
by
the
function
used
on
ModGFF GRanges.
ModGFF_granges <-
listMotif_ModGFF_grangeslist$ModGFF_grangeslist[["AT"]]
GetGRangesWindowSeqandParam
(c)
Or use the
function
with the ModGFF GRanges then subset on the column
« sequence » using the motif to analyze (see Note 8).

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
103
ModGFF_granges <-
ModGFF_granges_seq[ModGFF_granges_seq$sequence == "AT",]
2. A ModCSV GRanges associated to a motif.
GetGRangesWindowSeqandParam
Retrieve the ModCSV GRanges object with the sequence
(returned by the
function)
then subset on the column « sequence » using the motif to
analyze.
ModCSV_granges <-
ModCSV_granges_seq[ModCSV_granges_seq$sequence == "AT",]
3. A GRanges object ﬁlled with the genome annotation to be
compared to.
(a)
readGFFAsGRanges
For
annotation
ﬁles
using
gff
format,
use
the
function from the rtracklayer package
[17] to import the annotation into a GRanges object.
annotations_path <- "./T_thermophila_June2014.gff3"
annot_range <-
rtracklayer::readGFFAsGRanges(annotations_path)
PredictMissingAnnotation
(b)
PredictMissingAnnotation
Then, use the
function to
add « intergenic » features to the new GRanges object. For
some functions, the feature “intergenic” will be required
for comparison between genes and intergenic regions. If
your annotation ﬁle also provides mRNA positions and
exon
(or
intron)
positions,
the
function can add the miss-
ing annotation (introns or exons) to the new GRanges
object.
annot_range <- PredictMissingAnnotation(
grangesAnnotations = annot_range,
grangesGenome = organism_genome_range,
cFeaturesColName = "type",
cGeneCategories = c("gene"),
lAddIntronRangesUsingExon = TRUE
)

104
Alexis Hardy et al.
3.5.1
Computing Counts
by Genomic Feature
1.
GetModBaseCountsByFeature
Use the
function (with the
annotation GRanges and the ModGFF/ModCSV GRanges
associated with a motif) to count Base and Mod for each feature
provided in the annotation GRanges (annotation GRanges
with ModBase counts).
annot_range_MBcounts <- GetModBaseCountsByFeature(
grangesAnnotations = annot_range,
grangesModPos = ModGFF_granges,
gposModTargetBasePos = SubsetModCSV_granges,
lIgnoreStrand = FALSE
)
2.
DrawModBasePropByFeature
cFeaturesToCompare
Use the
function (with the anno-
tation GRanges and the ModGFF/ModCSV GRanges asso-
ciated with a motif) to compare the proportion of Base and
Mod between different annotation categories (Fig. 2b). Fea-
tures to be compared must be listed as a character vector in the
option.
DrawModBasePropByFeature(
grangesAnnotationsWithCounts = annot_range_MBcounts,
cFeaturesToCompare = c("gene", "intergenic"),
lUseCountsPerkbp = TRUE,
cBaseMotif = "AT",
cModMotif = "6mAT"
)
3.5.2
Quantitative
Parameter by Feature and
by Mod Count Categories
It is also possible to compare a quantitative parameter with Base
and Mod counts in genomic features.
GetModBaseCountsByFeature
1. Retrieve the annotation GRanges with ModBase counts
returned by the
function.
read.table
2. Import or compute the parameter that you want to compare to
the Mod or Base counts. For example, we imported RNA-seq
ﬁle containing read counts per gene in this protocol using the
function.
expression_file_path <- "./GSM692081_Growth.map.txt"
expression_dataframe <- read.table(
file = expression_file_path,
header = TRUE, sep = "\t"
)

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
105
merge
mcols()
mcols().
3. The quantitative parameter to be compared with the Mod or
Base must be loaded as a new column within the annotation
GRanges with ModBase counts. For example, we ﬁltered the
annotation GRanges with ModBase counts to keep only the
genes then we used the
function with the
of the
annotation GRanges with ModBase counts to replace its
In this example, we also normalize the counts of
mapped RNA-seq reads using the size of the genes.
genes_range_MBcounts_param <-
annot_range_MBcounts[annot_range_MBcounts$type == "gene"]
genes_range_MBcounts_param <- genes_range_MBcounts_param[
genes_range_MBcounts_param$Name %in%
expression_dataframe$Gene_ID
]
GenomicRanges::mcols(genes_range_MBcounts_param) <-
merge(
x = GenomicRanges::mcols(genes_range_MBcounts_param),
by.x = "Name",
y = expression_dataframe,
by.y = "Gene_ID"
)
genes_range_MBcounts_param$Number_of_mapped_reads_perkbp 
<-
1000*genes_range_MBcounts_param$Number_of_mapped_reads 
/
GenomicRanges::width(genes_range_MBcounts_param)
DrawParamPerModBaseCategories
4. Use the
function to plot
the distribution of the quantitative parameter provided by
category of Mod and Base counts (Fig. 2d).
DrawParamPerModBaseCategories(
grangesAnnotationsWithCounts =
genes_range_MBcounts_param,
cParamColname = "Number_of_mapped_reads",
cParamFullName = "Gene expression at G-m (mid-log 
exponential growth)",
cParamYLabel = "RNA-seq read counts (G-m)",
cSelectFeature = "gene",
lUseCountsPerkbp = FALSE,
cBaseMotif = "AT",
cModMotif = "6mAT",
lBoxPropToCount = FALSE, lUseSameYAxis = TRUE
)
3.5.3
Computing Count
Within Genomic Features
GetModBaseCountsWithinFeature
1. Use the
function (with the
annotation GRanges and the ModGFF/ModCSV GRanges
associated with a motif) to count Mod and Base within seg-
ments of each genomic feature provided. Each feature provided
is cut into a speciﬁc number of windows (deﬁned by the

106
Alexis Hardy et al.
nWindowsNb
GetModBaseCountsWithinFeature
argument), and counts are returned for each win-
dow of each feature. Here, we ﬁltered the annotation GRanges
to
keep
only
the
genes
before
using
the
function.
genes_range <- annot_range[annot_range$type == "gene", ]
genes_range <- GetModBaseCountsWithinFeature(
grangesAnnotations = genes_range,
grangesModPos = ModGFF_granges,
gposModTargetBasePos = SubsetModCSV_granges,
lIgnoreStrand = FALSE,
nWindowsNb = 20
)
DrawModBaseCountsWithinFeature
2. Then, use the
function to
represent the distribution within provided features through a
barplot (Fig. 2c).
DrawModBaseCountsWithinFeature(
grangesAnnotationsWithCountsByWindow = genes_range,
cFeatureName = "gene",
cBaseMotif = "AT",
cModMotif = "6mAT"
)
3.5.4
Computing
Distance from Genomic
Features
1.
GetDistFromFeaturePos
Use the
function with the annota-
tion GRanges and the ModGFF GRanges to retrieve, for each
feature provided, the distance, in bp, between this feature, and
a Mod (using a window of speciﬁc size around each feature) (see
Note 12).
Mod_distance_feature_countslist <- GetDistFromFeaturePos(
grangesAnnotations = annot_range,
cSelectFeature = "gene",
grangesData = ModGFF_granges,
lGetGRangesInsteadOfListCounts = FALSE,
lGetPropInsteadOfCounts = TRUE,
cWhichStrandVsFeaturePos = "both",
nWindowSizeAroundFeaturePos = 600,
lAddCorrectedDistFrom5pTo3p = TRUE,
cFeaturePosNames = c("TSS", "TTS")
)
2. Repeat the previous step with the annotation GRanges and the
ModCSV GRanges instead to retrieve, for each feature
provided, the distance, in bp, between this feature and a Base
(see Note 12).

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
107
cSelectFeature = "gene",
grangesData = SubsetModCSV_granges,
lGetGRangesInsteadOfListCounts = FALSE,
lGetPropInsteadOfCounts = TRUE,
cWhichStrandVsFeaturePos = "both", 
nWindowSizeAroundFeaturePos = 600,
lAddCorrectedDistFrom5pTo3p = TRUE,
cFeaturePosNames = c("TSS", "TTS")
)
Base_distance_feature_countslist <-
GetDistFromFeaturePos(
grangesAnnotations = annot_range,
DrawModBasePropDistFromFeature
3. Use the
function with the
output from the two previous steps to plot the proportion of
Mod or Base around genomic features provided (Fig. 3).
DrawModBasePropDistFromFeature(
listModCountsDistDataframe =
Mod_distance_feature_countslist,
listBaseCountsDistDataframe =
Base_distance_feature_countslist,
cFeaturePosNames = c("TSS", "TTS"),
cBaseMotif = "AT",
cModMotif = "6mAT"
)
AddToModBasePropDistFromFeaturePlot
GetGposCenterFromGRanges
(a)
It is also possible to add at least one additional axis
on
the
plot
to
compare
modiﬁcation
signal
with
another
parameter
by
using
the
function
(Fig. 3). However, distances can only be computed with
GPos objects or GRanges with a size of 1 bp per window.
For GRanges using windows with a size >1 bp, use the
function to retrieve the cen-
tral position of each window (see Note 13).
bedfile_path <-
"./GSM2534785_SB210_MNase.120_260.unique.bed"
bedfile_object <- rtracklayer::import.bed(bedfile_path)
bedfile_object <-
GetGposCenterFromGRanges(bedfile_object)
GetDistFromFeaturePos
AddToModBasePropDistFromFeaturePlot
(b)
Use the
function with the
annotation GRanges and the output from the previous
step then the
function to plot this parameter against Mod and Base
proportions (Fig. 3) (see Note 13). A new axis will thus
be
added
on
the
previous
plot
from
the

108
Alexis Hardy et al.
DrawModBasePropDistFromFeature function unless the
plot is no longer available (see Note 14).
bedfile_distance_feature_countslist <-
GetDistFromFeaturePos(
grangesAnnotations = annot_range,
cSelectFeature = "gene",
grangesData = bedfile_object,
lGetGRangesInsteadOfListCounts = FALSE,
lGetPropInsteadOfCounts = FALSE,
cWhichStrandVsFeaturePos = "both", 
nWindowSizeAroundFeaturePos = 600,
lAddCorrectedDistFrom5pTo3p = TRUE,
cFeaturePosNames = c("TSS", "TTS")
)
AddToModBasePropDistFromFeaturePlot(
dPosCountsDistFeatureStart =
bedfile_distance_feature_countslist[[1]],
dPosCountsDistFeatureEnd =
bedfile_distance_feature_countslist[[2]],
cSubtitleContent = "Along with MNase-seq read center 
distance",
cParamYLabel = "MNase-seq read center count",
cParamColor = "cyan3",
lAddAxisOnLeftSide = TRUE, cParamLty = 1, cParamLwd = 2
)
3.5.5
Local Visualization
with Gviz
DNAModAnnot [6] provides several functions that can be used
alongside the Gviz [18] package for local visualization (see Gviz
[18] documentation for main functions).
ExportFilesForGViz
plotTracks
1. The
function allows the user to export
ﬁles, which can be used for streaming (except for the gff3
format) with the
function from Gviz package
[18]. Here, using the bam format, it is possible to use Gviz
[18] streaming options also for genomic annotation.
ImportBamExtendedAnnotationTrack
stream
importFunction
2. To display the genomic annotations using streaming (using the
adapted
bam
ﬁle),
use
the
function as the import
function (via the
and
options while
making the annotation track). In this case, to allow the names
of the genomic features to be displayed, the “mapping” sub-list
of the generated annotation track must be manually completed
with the new “id” and “group” values deﬁned in the previous
step (see Note 4).

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
109
4
Notes
1. To generate the modiﬁcations.csv and modiﬁcations.gff ﬁles
using SMRT-Link-tools v7.0.1.66975–0:
(a)
Download the fasta genome and index the genome:
samtools faidx “genome.fasta”
(b)
For each SMRT cell to analyze, download the bax.h5 ﬁles
(ﬁle names must ﬁnish with the “h5”) then retrieve the
bam ﬁle:
bax2bam “SMRT_file_basename”.{1,2,3}.bax.h5 -o 
“SMRT_file_basename”
Then, align the reads from the bam ﬁle to the fasta
genome:
pbalign -vvv --nproc “Number of available processors” --
algorithm blasr --forQuiver --byread –metrics 
DeletionQV,IPD,InsertionQV,PulseWidth,QualityValue,MergeQ
V,SubstitutionQV,DeletionTag --tmpDir /tmp 
“SMRT_file_basename”.subreads.bam “genome.fasta” 
“SMRT_file_basename”_aligned.bam
(c)
Merge all SMRTcells:
samtools merge SMRT_merged.bam *_aligned.bam
(d)
Index the merged ﬁle:
pbindex SMRT_merged.bam
(e)
Then launch the DNA modiﬁcation detection tool:
ipdSummary --verbose --methylFraction --minCoverage 25 --
mapQvThreshold 30 --identify m6A --numWorkers “Number of 
available processors” --outfile tmp_dir/ SMRT_merged_6mA 
--reference “genome.fasta” SMRT_merged.bam 

110
Alexis Hardy et al.
--refCont  igs 
This command returns the modiﬁcations.csv and mod-
iﬁcations.gff ﬁles. With this command, they would be
called SMRT_merged_6mA.csv and SMRT_merged_6mA.
gff respectively. This command can easily take days if run
locally and/or with a low number of available CPUs. If
you want to analyze some contigs, use the
option with the name of the contigs that you want to
analyze. It is also possible to use a loop to launch methyl-
ation detection by a group of contigs.
2. To analyze DNA modiﬁcation patterns, ONT data must be
processed with the DeepSignal software [12]. Follow the
steps on the DeepSignal GitHub repository for the ONT data
processing:
https://github.com/bioinfomaticsCSU/
deepsignal [19].
After the full pre-processing of nanopore data via Deep-
Signal, you must retrieve the modiﬁcation-frequency ﬁle gen-
erated via the call_modiﬁcation_frequency.py script.
ImportDeepSignalModFrequency
Use the
function to
load the modiﬁcation-frequency ﬁle as an Unstitched GPos
object (ModCSV GPos).
e
the
FiltDeep
Then,
us
Signal
function
with
the
ModCSV GPos object to retrieve a ModGFF GPos by simply
ﬁltering target sites which have a fraction (“frac”) above 0.
ModGFF_gpos <- FiltDeepSignal(
gposDeepSignalModBase = ModCSV_gpos, 
cParamNameForFilter = "frac", 
nFiltParamLoBoundaries = 0, 
nFiltParamUpBoundaries = 1, 
cFiltParamBoundariesToInclude = "upperOnly"
)$Mod)
(a)
FiltDeepSignal
The
function returns a list with the ﬁl-
tered ModCSV as the ﬁrst element of the list, and the
ﬁltered ModGFF as the second element of the list.
(dnastringsetGenome
(b)
Some options of this function require ModCSV or the
ModGFF GPos objects or the sequence of the genome
option).
:cContigToBeRemoved,nContigMinSize,
listPctSeqByContig,nContigMinPctOfSeq,
listMeanCovByContig,nContigMinCoverage,
cParamNameForFilter,
listMeanParamByContig,
nContigFiltParamLoBound,
nContigFiltParamUpBound.
(c)
You can ﬁlter out contigs based on different conditions
using
a
combination
of
the
following
arguments
(ModCSV GPos object is required for most of these
options)
-
-
-

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
111
cParamNameForFilter,
nFiltParamLoBoundaries,
nFiltParamUpBoundaries,
cFiltParamBoundariesToInclude, nModMinCoverage.
(d)
You can ﬁlter out modiﬁcations from the ModGFF object
based on different conditions using a combination of the
following
arguments:
GetModReportPacBio
FiltPacBio
GetModReportDeepSignal
FiltDeepSignal,
The ModCSV GPos and the ModGFF GPos objects from
ONT-DeepSignal data can then be used in place of the
ModCSV GPos and the ModGFF GRanges/GPos objects
from PacBio data except for the False Discovery Rate estima-
tion
functions. For
some functions,
the
ModCSV and
ModGFF GPos objects will ﬁrst need to be converted as
GRanges objects. Also, when using ONT data, the functions
and
must be replaced by
the
functions
and
respectively.
3. For this example, only data from 50 random contigs will be
analyzed: the listing of selected contigs is available in the con-
tig_list.txt ﬁle listed in Table 1.
4. An Rmarkdown document is given in the supplementary data
and on the GitHub of the DNAModAnnot [6] with all the
commands
used:
https://github.com/AlexisHardy/
DNAModAnnot_AdditionalData.
SortGPos
5. If the
argument is TRUE, the importation will take a
longer time, but the size of the GPos object will be highly
reduced.
lIsOrderedLargestToSmallest
6. By default, the
argument is
TRUE and orders the contigs from the largest to the smallest
on the x-axis.
FiltPacBio
FiltDeepSignal
7. The
function is a wrapper function for ﬁltering
PacBio data contained in ModGFF and ModCSV objects. For
ONT data, check the
function (see Note 2).
(a)
This function returns a list with the ﬁltered ModCSV as
the ﬁrst element of the list, and the ﬁltered ModGFF as
the second element of the list. If the user provides a
ModGFF GRangesList instead of GRanges, the second
element of the list will also be returned as a GRangesList.
Mod_filtered_data <- FiltPacBio(
gposPacBioCSV = ModCSV_gpos,
grangesPacBioGFF = ModGFF_granges,
cContigToBeRemoved = NULL,
dnastringsetGenome = organism_genome,
nContigMinSize = 1000,
listPctSeqByContig = contig_percentage_sequencing,
nContigMinPctOfSeq = 95,
listMeanCovByContig = contig_mean_coverage,
nContigMinCoverage = 10
)
ModCSV_gpos <- Mod_filtered_data$csv
ModGFF_granges <- Mod_filtered_data$gff

112
Alexis Hardy et al.
(dnastringsetGenome
(b)
Providing the ModGFF is mandatory. Some options of
this function also require ModCSV GPos object or the
sequence of the genome
option).
cContigToBeRemoved,nContigMinSize,
listPctSeqByContig,nContigMinPctOfSeq,
listMeanCovByContig,nContigMinCoverage,
cParamNameForFilter,listMeanParamByContig,
nContigFiltParamLoBound,
nContigFiltParamUpBound.
(c)
It is possible to ﬁlter out contigs based on different con-
ditions using a combination of the following arguments
(ModCSV GPos object is required for most of these
options):
-
-
-
-
cParamNameForFilter,nFiltParamLoBoundaries,
nFiltParamUpBoundaries,
cFiltParamBoundariesToInclude,nModMinCoverage,
nModMinIpdRatio, nModMinScore.
(d)
It is also possible to ﬁlter out modiﬁcations from the
ModGFF object based on different conditions using a
combination
of
the
following
arguments:
-
-
-
GetFdrBasedThreshLimit
listFdrEstByThrIpdRatio
listFdrEstByThrScore
(e)
Finally, it is possible to ﬁlter out modiﬁcations from the
ModGFF GRangesList object based on false discovery rate
estimations
by
providing
the
output
list
of
the
function
to
the
or
arguments depending on which parameter has been used
for the estimation of the false discovery rate: ipdRatio or
score, respectively.
8.
nUpstreamBpToAdd
nDownstreamBpToAdd
Use the
and
argu-
ments to choose the size of the sequence motif (that includes
the target base) to look at or to ﬁlter.
cYunit
lPlotNegYAxis
9. The Y-axis can be changed to plot information content or
probabilities using the
option. You can also remove
the depletion signal by deactivating the
option. Sequences that do not have full width and sequences
that have some N or some gaps “-” are automatically removed
before drawing the sequence plot. If a base is enriched 100% at
one position, this base alone will be represented, and other
bases will not be represented into the « depletion » part unless
the “prob” value is used for the y-axis: here the complementary
base would then be represented.
GetFdrEstListByThresh
10. Formulas
can
be
found
in
the
documentation
of
the
function and are based on formulas
recently published [16].
nFdrPropForFilt
11. The chosen FDR is deﬁned by the
argument
(default to 5%). The threshold will be deﬁned as the closest

DNA Modiﬁcation Patterns Filtering and Analysis Using DNAModAnnot
113
lUseBestThrIfNoFdrThr
value below this level of FDR for each motif (or only for some
motifs if the
argument is used).
lGetGRangesInsteadOfListCounts
GetDistFromFeaturePos
12. If the genomic annotation feature provided is larger than 1 bp,
its two extremities will be used instead for computing the
distance. If the
argument
is deactivated, the
function will
return
instead
a list of
data.frames
giving the counts
(or proportion) of Mod (or Base) by distance toward the
feature.
import.bed
GetGposCenterFromGRanges
GetDistFromFeaturePos
import.bed
AddToModBasePropDistFromFeaturePlot
13. For example, we imported MNase-seq data from a bed ﬁle
using the
function from the rtracklayer package
[17], then we used the
function
before using its output with the
function with the output of the
function. Then
we used the
func-
tion to plot this parameter against Mod and Base proportions.
lAddAxisOnLeftSide
14. Up until two additional parameters can be added on this plot,
use the
argument to choose on which
side to put the axis of the new parameter to add.
References
1. Gouil Q, Keniry A (2019) Latest techniques to
study DNA methylation. Essays Biochem 63:
639–648.
https://doi.org/10.1042/
EBC20190027
2. Liu Y, Rosikiewicz W, Pan Z, Jillette N,
Wang P, Taghbalout A, Foox J, Mason C,
Carroll M, Cheng A, Li S (2021) DNA
methylation-calling tools for Oxford Nanopore
sequencing: a survey and human epigenome-
wide
evaluation.
Genome
Biol
22:295.
https://doi.org/10.1186/s13059-021-
02510-z
3. Methylome
analysis
technical
note
Paciﬁcbiosciences/bioinformatics-training
Wiki. In: GitHub. https://github.com/
PaciﬁcBiosciences/Bioinformatics-Training/
wiki/Methylome-Analysis-Technical-Note.
Accessed 28 Jan 2022
4. Detecting DNA base modiﬁcations using sin-
gle molecule, real-time sequencing. White Pap
Base Modif. 2015. https://www.pacb.com/
wp-content/uploads/2015/09/WP_
Detecting_DNA_Base_Modiﬁcations_Using_
SMRT_Sequencing.pdf. Accessed 27 Jan 2022
5. O’Brown ZK, Boulias K, Wang J, Wang SY,
O’Brown NM, Hao Z, Shibuya H, Fady P-E,
Shi Y, He C, Megason SG, Liu T, Greer EL
(2019) Sources of artifact in measurements of
6mA
and
4mC
abundance
in
eukaryotic
genomic
DNA.
BMC
Genomics
20:445.
https://doi.org/10.1186/s12864-019-
5754-6
6. Hardy A, Matelot M, Touzeau A, Klopp C,
Lopez-Roques C, Duharcourt S, Defrance M
(2021) DNAModAnnot: a R toolbox for DNA
modiﬁcation ﬁltering and annotation. Bioin-
formatics 37:2738–2740. https://doi.org/10.
1093/bioinformatics/btab032
7. Lawrence M, Huber W, Page`s H, Aboyoun P,
Carlson M, Gentleman R, Morgan MT, Carey
VJ (2013) Software for computing and anno-
tating genomic ranges. PLoS Comput Biol 9:
e1003118. https://doi.org/10.1371/journal.
pcbi.1003118
8. Page`s H, Aboyoun P, Gentleman R, DebRoy S
(2022) Biostrings: efﬁcient manipulation of
biological strings. https://bioconductor.org/
packages/Biostrings/. Accessed 26 Jan 2022
9. Wang Y, Chen X, Sheng Y, Liu Y, Gao S (2017)
N6-adenine DNA methylation is associated
with the linker DNA of H2A.Z-containing
well-positioned
nucleosomes
in
Pol
II-transcribed genes in Tetrahymena. Nucleic
Acids Res 45:11594–11606. https://doi.org/
10.1093/nar/gkx883
10. Xiong J, Lu X, Zhou Z, Chang Y, Yuan D,
Tian M, Zhou Z, Wang L, Fu C, Orias E,
Miao W (2012) Transcriptome analysis of the
model protozoan, tetrahymena thermophila,

114
Alexis Hardy et al.
using deep RNA sequencing. PLoS One 7:
e30630. https://doi.org/10.1371/journal.
pone.0030630
11. PacBio – software downloads. In: PacBio.
https://www.pacb.com/support/software-
downloads/. Accessed 26 Jan 2022
12. Ni P, Huang N, Zhang Z, Wang D-P, Liang F,
Miao Y, Xiao C-L, Luo F, Wang J (2019)
DeepSignal: detecting DNA methylation state
from Nanopore sequencing reads using deep-
learning.
Bioinformatics
35:4586–4595.
https://doi.org/10.1093/bioinformatics/
btz276
13. Morgan M, Ramos M (2021) BiocManager:
access the bioconductor project package repos-
itory. https://CRAN.R-project.org/package=
BiocManager. Accessed 26 Jan 2022
14. Wickham H, Hester J, Chang W, Bryan J
(2021) devtools: tools to make developing R
packages easier. https://CRAN.R-project.org/
package=devtools. Accessed 26 Jan 2022
15. Gurevich A, Saveliev V, Vyahhi N, Tesler G
(2013) QUAST: quality assessment tool for
genome assemblies. Bioinformatics 29:1072–
1075. https://doi.org/10.1093/bioinformat
ics/btt086
16. Zhu S, Beaulaurier J, Deikus G, Wu TP,
Strahl M, Hao Z, Luo G, Gregory JA,
Chess A, He C, Xiao A, Sebra R, Schadt EE,
Fang G (2018) Mapping and characterizing
N6-methyladenine
in
eukaryotic
genomes
using single-molecule real-time sequencing.
Genome Res 28:1067–1078. https://doi.
org/10.1101/gr.231068.117
17. Lawrence M, Gentleman R, Carey V (2009)
rtracklayer: an R package for interfacing with
genome browsers. Bioinformatics 25:1841–
1842. https://doi.org/10.1093/bioinformat
ics/btp328
18. Hahne F, Ivanek R (2016) Visualizing genomic
data
using
Gviz
and
bioconductor.
In:
Mathe´ E, Davis S (eds) Statistical genomics:
methods and protocols. Springer, New York,
pp 335–351. https://doi.org/10.1007/978-
1-4939-3578-9_16
19. Ni P, Huang N, bioinformaticsCSU (2021)
D e e p S i g n a l .
h t t p s : // g i t h u b . c o m /
bioinfomaticsCSU/deepsignal.
Accessed
26 Jan 2022

Chapter 8
Methylome Imputation by Methylation Patterns
Ya-Ting Sabrina Chang, Ming-Ren Yen, and Pao-Yang Chen
Abstract
DNA methylation is studied extensively for its relations with several biological processes such as transcrip-
tional regulation. While methylation levels are usually estimated per cytosine or genomic region, additional
information on methylation heterogeneity can be obtained when considering stretches of successive
cytosines on the same reads; however, the majority of methylomes suffer from low coverage of genomic
regions with sequencing depths enough for accurate estimation of methylation heterogeneity using existing
methods. Here we describe a probabilistic-based imputation method that makes use of methylation
information from neighboring sites to recover partially observed methylation patterns. Our method and
software are proven to be faster and more accurate among all evaluated. Ultimately, our method allows for a
more streamlined monitoring of epigenetic changes within cellular populations and their putative role in
disease.
Key words Bisulﬁte sequencing, Methylation heterogeneity, Methylation patterns, Probabilistic-
based imputation
1
Introduction
Methylation has been studied extensively [1] for its relationships
with key biological processes such as gene expression regulation,
development [2], aging, and disease [3]. Methylation was ﬁrst
studied through the estimation of methylation levels at DNA
regions such as CpG islands at promoters from microarray methyl-
ation datasets [4]. However, high-throughput sequencing methods
such as bisulﬁte sequencing (BS-seq) [5] and enzymatic methyl
sequencing (EM-seq) [6] allowed for a more accurate epigenome
analysis both at a genome-wide scale and at single nucleotide
resolution. For example, methylation levels of individual cytosine
sites can be aggregated in bins of hundreds of base pairs, compared
across different samples and conditions [2], and correlated with
gene expression [7]. Since the abovementioned sequencing meth-
ods usually cover the entire genome, the analyses are not limited to
genes and their promoters and allow for a more thorough study of
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_8,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
115

116
Ya-Ting Sabrina Chang et al.
methylation in other regions of interest (e.g., mobile genetic
elements).
Aligned sequencing reads provide the methylation statuses at
individual cytosines but can also provide methylation patterns or
permutations of methylation statutes if multiple cytosines in a row
are considered. As each read represents a cell within a population,
the collection of methylation patterns observed from different
reads can be used to study cellular heterogeneity and its putative
roles in disease and clinical outcomes. For example, the more
heterogeneous tumor cells are, the worse the clinical outcomes
[8, 9]. Single-cell bisulﬁte sequencing (scBS-seq) is a typical exper-
imental approach proposed to study cellular heterogeneity. How-
ever, it suffers from difﬁculties in isolating individual cells and DNA
samples being destroyed by bisulﬁte treatment. New methods were
also proposed to estimate cellular heterogeneity by quantifying the
variations in methylation patterns [10–12]. And despite the sub-
stantial amount of methylation sequencing data publicly available,
the average depth and coverage in most of these data are not
sufﬁcient for accurate estimation of methylation heterogeneity. To
illustrate such discrepancy, we summarize in Table 1 the average
depths and proportion of libraries with average depths above 2.5×
and 8× per strand by species. If we take the human genome as an
example, there are only 14% (8%) of published WGBS libraries that
have average depths exceeding 2.5× (8×) per strand, meaning that
less than 14% of 32,070 libraries were sequenced deep enough for a
proper estimation of methylation level. The number of libraries is
much smaller for analyses using methylation heterogeneity. We
should keep in mind that these are averages and that the depths at
individual cytosine sites do not reﬂect depths (reads) of methylation
patterns starting at that cytosine.
Imputation is commonly used to overcome this type of pro-
blems. However, most imputation methods developed for next-
generation methylation sequencing data analysis are aimed at high
coverage (i.e., for the entire genome) and for the estimation of
methylation levels only; they are not designed for imputing the
methylation patterns (haplotypes of methylation statuses) nor do
they use these patterns for estimation. Speciﬁcally, METHimpute
[13] was developed for imputing methylation levels of every cyto-
sine from whole-genome bisulﬁte sequencing data. Melissa [14]
and DeepCpG [15] were developed for imputing methylation
probabilities and methylation statuses of individual CpGs for
single-cell methylomes, respectively. While DeepCpG serves a simi-
lar purpose, it works by drawing information from large windows
(thousands of base pairs due to sparsity of single cell methylomes)
and multiple cells, which does not guarantee accurate prediction of
methylation patterns at every possible locus. These are not reliable
for recovering read-speciﬁc methylation patterns within bulk
sequencing data that are needed for the estimation of methylation

Species
(continued)
Methylome Imputation by Methylation Patterns
117
Table 1
Statistics of whole genome bisulfite sequence libraries from the NCBI SRA database (https://www.
ncbi.nlm.nih.gov/sra). *1x indicates sequencing depth of two times of a genome (accounting for both
strands). A minimum of 2.5x was recommended for differentially methylated region identification
[23]. Methylation heterogeneity estimation using methylation patterns within windows of four
cytosines (common approach) is recommended to have at least 16 reads. The libraries of BS-seq
were collected from the database using the keyword “Bisulfite-Seq.” Reduced representation
BS-seqs (RRBS) were removed from the analysis for better estimation of genome coverage. The
species with at least 40 libraries were selected. The genome sizes were taken from the NCBI genome
database (https://www.ncbi.nlm.nih.gov/genome/). For each library, the genome coverage was
calculated as the total number of sequenced bases divided by twice the genome size
Genome size
(Mb)
#WGBS
libraries
Average depth
(x*)
% Libraries
>2.5x*
% Libraries
>8x*
Animals
Apis mellifera
227
236
23.66
95%
89%
Daphnia magna
150
256
23.58
74%
73%
Crassostrea gigas
587
132
16.84
95%
94%
Nasonia vitripennis
297
63
15.52
98%
90%
Pan troglodytes
3050
81
14.69
43%
33%
Macaca mulatta
2832
121
14.32
59%
39%
Gallus gallus
1048
272
11.23
58%
47%
Ovis aries
2826
78
10.17
76%
53%
Sus scrofa
2437
484
7.83
53%
33%
Ctenopharyngodon
idella
893
129
7.78
59%
28%
Bos taurus
2687
382
7.77
69%
41%
Oryzias latipes
732
40
7.45
75%
38%
Salmo salar
2639
92
5.95
48%
46%
Anguilla anguilla
999
45
5.81
100%
4%
Schistosoma mansoni 365
80
5.21
35%
10%
Danio rerio
1357
790
4.27
29%
16%
Exaiptasia
diaphana
256
96
3.36
100%
0%
Rattus norvegicus
2883
682
3.09
21%
9%
Canis lupus
familiaris
2345
191
2.73
11%
6%
Homo sapiens
3102
32,070
2.30
14%
8%
Thymallus thymallus 1761
104
1.51
0%
0%

Table 1
Species
118
Ya-Ting Sabrina Chang et al.
(continued)
Genome size
(Mb)
#WGBS
libraries
Average depth
(x*)
% Libraries
>2.5x*
% Libraries
>8x*
Mus musculus
2604
41,233
1.29
8%
5%
Cavia porcellus
2723
48
1.20
0%
0%
Dicentrarchus
labrax
696
162
0.99
3%
0%
Zonotrichia albicollis 1053
159
0.34
1%
1%
Plants
Prunus persica
214
46
28.18
100%
100%
Arabidopsis
thaliana
120
4941
28.03
98%
92%
Fragaria vesca
214
69
25.43
99%
99%
Solanum tuberosum
810
59
23.26
100%
100%
Brassica napus
912
45
22.98
100%
100%
Fagus sylvatica
484
48
18.50
96%
96%
Solanum
lycopersicum
794
153
16.93
96%
69%
Oryza sativa
384
726
16.85
96%
79%
Medicago
truncatula
400
239
13.87
96%
62%
Glycine max
988
241
13.81
93%
63%
Populus nigra var.
italica
434
476
12.87
88%
86%
Malus domestica
648
46
11.55
100%
83%
Sorghum bicolor
685
223
10.63
86%
66%
Setaria italica
442
52
10.34
42%
38%
Phaseolus vulgaris
453
97
9.35
100%
56%
Phyllostachys edulis
1908
47
5.22
32%
32%
Zea mays
2181
747
4.49
38%
22%
Brachypodium
distachyon
271
977
4.33
27%
16%
Thlaspi arvense
526
76
2.59
21%
0%
Triticum aestivum
14,439
44
2.56
32%
5%
Picea abies
11,961
81
0.85
0%
0%

Methylome Imputation by Methylation Patterns
119
heterogeneity. The only program that was developed for recovering
partially observed methylation patterns is PReLIM [16]; however,
the method imputes only by attempting to complete binary matri-
ces that represent methylation status of reads within the bins and
requires training models using multiple bins that users have to
extract themselves and implement genome-wide. A more thorough
comparison of these methods can be found in Table 2.
DNA methylation is regulated by DNA methyltransferases
(DNMTs) [8]. Methylation occurring at CG, CHG, and CHH
contexts (where H is any of A, C, or T), is performed by different
groups of DNMTs via distinct mechanisms [17]. DNA methylation
in mammalian genomes primarily occur at CG [8], while methyla-
tion at other contexts such as CHG and CHH can be found in
species of plants [17] and fungi although their roles are not clear. In
a recent study, it was found that in Physcomitrella patens all contexts
act in silencing transposons and CHH methylation regulates the
expression of CG/CHG-depleted transposons. Also, the targeted
removal of non-CG methylation massively upregulated transposons
and genes. It was shown that CHG methylation acted as a greater
transcriptional regulator than CG methylation by comparing two
exclusively
but
equally
CG-
or
CHG-methylated
genomes
[18]. These ﬁndings were based on methylation levels.
Up until now, the majority of studies based on methylation
heterogeneity targeted human diseases such as cancer [19] and
therefore CG methylation. But the same principle can be useful
for other methylation contexts, for example, for studying DNMTs
and the pathways involved [20]. Therefore, it was our aim to
develop an accurate and fast imputation method that could produce
outputs widely applicable to different kingdoms such as animals,
plants, and fungi and with higher resolution (methylation pattern
information).
There is a strong correlation between methylation and dis-
tances between cytosines [21]. Such assumption is used in many
of the programs shown in Table 2. We used this property exten-
sively by extracting information from local cytosine sites and devel-
oped
a
probabilistic-based
imputation
method
to
impute
methylation status accurately and rapidly [22]. Our program is
able to take any methylation context (not limited to CG) that has
accuracy comparable with the only existing method that imputes
methylation status for bulk sequencing data. It also provides the
user the ﬂexibility to specify window size in number of cytosines for
imputation and genome-wide proﬁling. After all, it is straightfor-
ward to use, can be run with a single command, and outputs results
ready for downstream analyses using either methylation levels or
methylation heterogeneity.

Program
Target data
Input
Output
Method
(continued)
120
Ya-Ting Sabrina Chang et al.
Table 2
Comparison of existing imputation methods developed for methylome imputation
Methylation
contexts
Methylation status of single cell methylome
DeepCpG
scBS-seqa,
scRRBS-seq
Methylation
statuses of all
CG in .
bedGraph or
.tsv of all cells
to be used
for training
CG
Methylation
statuses
Neural network
trained using
local
methylation
levels of multiple
cells
Methylation levels/probabilities
Melissa
scBS-seqa
Processed
scBS-seq
CG
Methylation
probabilities
of all CG
within
speciﬁed
genomic
regions
Bayesian model
that uses
information of
neighbouring
CGs and of other
cells with similar
methylation
patterns
genome-wide
through
clustering
METHimpute WGBSa
CGmap
all
Methylation
level of all
cytosines
Hidden Markov
model with
transition matrix
estimated for
different
sequence
contexts; that is,
CG, CCG,
CWG, CAA...
etc.
Methylation patterns
PReLIM
WGBSa
Binary matrices
of
methylation
statuses
CGb
Binary matrices
of methylation
statuses
Matrix completion
trained using
other matrices of
the same sizes
(number of
CGs) on the
genome

Table 2
Program
Target data
Input
Output
Method
Methylome Imputation by Methylation Patterns
121
(continued)
Methylation
contexts
BSImp
WGBS, RRBS,
and EM-seq
.bam ﬁles and .
fa ﬁles
all
Tabulated
methylation
patterns and
methylation
levels of
cytosines of
speciﬁed
context
Recovering
methylation
patterns using
local patterns of
similar cells
within bulk
sequencing data
aEM-seq was developed very recently but has the same end product as BS-seqs so the programs that take BS-seqs should
all be applicable for EM-seq
bPReLIM was developed to support a program that can be used to identify cell type based on CpG methylation patterns
but since PReLIM only takes binary matrices as input, context does not matter; that is, it is up to the user to extract the
binary matrix from cytosine sites
2
Materials
Data source
Complete methylomes in .bam format; can be either
bisulﬁte sequencing data or enzymatic sequencing
data including scBS-seq, WGBS, RRBS. They can be
obtained from databases such as NCBI GEO.
Environment
We provide instructions using the Linux command line;
can be accessed via Command Prompt for Windows
users or Terminal for MacOS users.
Hardware
requirements
A computer running Ubuntu or some other version of
Linux, Windows, or MacOS.
Software
requirements
Other than Ubuntu, we require python 2.7+ with the
packages below installed for python: pandas 0.24+,
pysam 0.16.0.1+, and joblib. These requirements can
be fulﬁlled by running the following command under
Linux.
$ pip install MeHscr
3
Methods
Let us consider a window of n cytosines. If we collect all sequencing
reads covering at least one cytosine within the window, we would
have reads covering between 1 and n cytosines, which means there
will be missing values. If we assume that the methylation patterns
provided by these reads are similar for cells within the population
(given they are usually in close proximity originally), the behavior of

n




122
Ya-Ting Sabrina Chang et al.
cells or the methylation status of a cell at a given genomic position
can be predicted by those statuses nearby status and cells. There-
fore, using the law of total probability, let the methylation status of
a cytosine at a position j for read i be mij, then the probability of mij
being methylated, or 1, is
p mij = 1


≔p m - i,j = 1


=
X
s∈S
p m - i,j = 1jmi, - j = s


p mi, - j = s


ð1Þ
where S is the collection of subpatterns of complete patterns within
the same window, or methylation patterns at positions other than j,
and p(m-i,j = 1|mi,-j = s) is the observed probability of cytosines
being methylated at position j given subpattern mi,-j within the
window is s. mi,-j either equals to one of s or not; if mi,-j = x ∈
S, p(mij = 1) is taken as p(m-i,j = 1|mi,-j = x), the methylation level
at position j of those complete patterns with subpattern resemble
mi,-j. Alternatively, it is possible that mi,-j is not observed, or there
is no complete pattern with subpattern that resembles mi,-j, i
which case p(mij = 1) is taken as the methylation level at position
j, or p(m-i,j = 1). An illustration of the eligibility of reads for
imputation and a possible imputation result can be found in Fig. 1.
3.1
Implementation
The implementation of the program includes three major steps:
script download, input data preparation, and command execution.
The script can be downloaded using the following command.
$ wget https://raw.githubusercontent.com/britishcoffee/
BSImp/main/bsimp.py
Next, create a folder using the following command:
$ mkdir MeHdata
And move the necessary ﬁles (.bam, .bam.bai, .fa, and .fa.fai)
inside the folder.
$ scp [directory_to_bamﬁles_of_all_samples] .bam ./MeHdata
$ ln -s [directory_to_bamﬁles_of_all_samples] .bam ./
$ scp [directory_to_reference_genome] .fa . /MeHdata
$ ln -s [directory_to_reference_genome] .fa . /
Enter one of the following commands to run the program.
$ python bsimp.py -w 4 -c 8 --CG --CHG --CHH -mC
8 -f MeHdata
$ python bsimp.py -w 4 -c 8 --CG -mC 8 -f MeHdata -mML
0.05 --opt
$ python bsimp.py -w 4 -c 4 --CG

Methylome Imputation by Methylation Patterns
123
Fig. 1 Examples of imputation
Fig. 2 Representation of input, output, and procedure of BSImp
The program allows users the ﬂexibility for optimal and custo-
mised results. In the next subsection, we detail the parameters that
can be ﬁne-tuned.
3.2
Parameters
In our implementation, the imputations are done alongside
genome screening (Fig. 2) where windows of ﬁxed size of cytosines
of the same methylation contexts are extracted, imputed if valid,
and
proﬁled
for
their
copy
numbers
of
methylated
and

(continued)
124
Ya-Ting Sabrina Chang et al.
Fig. 3 Schematic representation of genome screening
unmethylated reads as well as every possible methylation pattern
(Fig. 3). It is done through sliding windows with w-1 cytosines
overlapping with the previous and next window. Only windows
consisting of at least two complete patterns will be considered for
imputation and proﬁled results outputted if the starting cytosine
position has enough reads and methylation levels above a user-
speciﬁed threshold within the window for CG and non-CG con-
texts, respectively.
Parameter
Symbol Explanation
Window size
w
Number of cytosines to consider at once;
default is 4.
w ≥4 is recommended for effective evaluation
of methylation heterogeneity, 3 is
recommended for methylomes with low depths
and w > 4 is recommended for non-CG
contexts. Since imputation is set to recover
methylation patterns with at most 1 missing
value, w will have an effect on imputation. This
value will be applied throughout the genome
and for all contexts speciﬁed independently.
Cores
c
Number of chromosomes that can be processed
in parallel at once; default is 4. The data
provided will be processed by chromosomes
so for 4 .bam ﬁles with 5 chromosomes each,
setting c ≥20 would be most efﬁcient.

Methylome Imputation by Methylation Patterns
125
Parameter
Symbol Explanation
CG methylation
CG
Consider methylation context CG; default is
FALSE.
CHG
methylation
CHG
Consider methylation context CHG; default is
FALSE.
CHH
methylation
CHH
Consider methylation context CHH; default is
FALSE.
minimum depth
for output
mC
BSImp will output result for the window if the
starting cytosine position has at least mC
reads; default is 4.
Name of folder
f
Name of folder where input data is kept.
Optional output opt
Outputs counts of methylation patterns and
methylated and unmethylated reads (prior to
imputation) for all methylation contexts.
Default is FALSE.
minimum
methylation
level
mML
Minimum methylation level required at starting
cytosine position to output results for the
window (for non-CG methylation contexts
only). Default is 0.05.
4
Notes
The only thing that might go wrong when attempting to run
BSImp [22] is failure to include all necessary ﬁles or failure to install
all required packages. The former can be avoided by checking that
there are a total of 2n + 2 ﬁles in the folder where n is the number of
libraries to analyze, each with a sequencing and an indexing data,
and a reference genome and its indexing ﬁle. The later can be
avoided by checking that all requirements are met when running
one of the commands for installation. If the program starts success-
fully, it regularly prints out messages to update on the progress.
This is done individually for each chromosome and for each library.
After the program is ﬁnished running, there will be n additional
ﬁles for each methylation context you speciﬁed. If opt is used to
output original counts, they will be included at the same rows as
imputed counts for side-by-side comparison. The time it will take
to run the program depends heavily on the number of libraries,
depth, number of cores allocated, and length of the genome. Only
libraries with the same reference genome can be run at once.

126
Ya-Ting Sabrina Chang et al.
References
1. Moore LD, Le T, Fan G (2013) DNA methyl-
ation and its basic function. Neuropsychophar-
macology 38(1):23–38
2. Hsieh J-WA, Yen M-R, Chen P-Y (2020) Epi-
genomic regulation of OTU5 in arabidopsis
thaliana. Genomics 112(5):3549–3559
3. Laird PW (2010) Principles and challenges of
genome-wide dna methylation analysis. Nat
Rev Genet 11(3):191–203
4. Luo X, Wang F, Wang G, Zhao Y (2020, Mar)
Identiﬁcation of methylation states of DNA
regions for illumina methylation beadchip.
BMC Genomics 21(Suppl 1):672
5. Barros-Silva D, Marques CJ, Henrique R, Jer-
o´nimo C (2018, Aug) Proﬁling dna methyla-
tion based on next-generation sequencing
approaches: new insights and clinical applica-
tions. Genes 9(9):429
6. Vaisvila R, Ponnaluri VKC, Sun Z, Langhorst
BW, Saleh L, Guan S, Dai N, Campbell MA,
Sexton BS, Marks K, Samaranayake M, Samuel-
son JC, Church HE, Tamanaha E, Correˆa IRJ,
Pradhan
S,
Dimalanta
ET,
Evans
TCJ,
Williams L, Davis TB (2021, Jun) Enzymatic
methyl sequencing detects dna methylation at
single-base resolution from picograms of dna.
Genome Res 31(7):1280–1289
7. Hanley MP, Hahn MA, Li AX, Wu X, Lin J,
Wang J, Choi AH, Ouyang Z, Fong Y, Pfeifer
GP, Devers TJ, Rosenberg DW (2017, Aug)
Genome-wide
DNA
methylation
proﬁling
reveals cancer-associated changes within early
colonic
neoplasia.
Oncogene
36(35):5035–5044
8. Jin B, Li Y, Robertson KD (2011) DNA meth-
ylation: superior or subordinate in the epige-
netic hierarchy? Genes Cancer 2(6):607–617
9. Landau DA, Clement K, Ziller MJ, Boyle P,
Fan J, Gu H, Stevenson K, Sougnez C,
Wang
L,
Li
S,
Kotliar
D,
Zhang
W,
Ghandi M, Garraway L, Fernandes SM, Livak
KJ, Gabriel S, Gnirke A, Lander ES, Brown JR,
Neuberg D, Kharchenko PV, Hacohen N,
Getz G, Meissner A, Wu CJ (2014) Locally
disordered methylation forms the basis of
intratumor methylome variation in chronic
lymphocytic
leukemia.
Cancer
Cell
26(6):813–825
10. Zhang Y, Liu H, Lv J, Xiao X, Zhu J, Liu X,
Su
J,
Li
X,
Wu
Q,
Wang
F,
Cui
Y
(2011) QDMR: a quantitative method for
identiﬁcation
of
differentially
methylated
regions by entropy. Nucleic Acids Res 39(9):
e58
11. Shannon CE (1948) A mathematical theory of
communication.
Bell
Syst
Tech
J
27(3):379–423
12. Hill MO (1973) Diversity and evenness: a uni-
fying notation and its consequences. Ecology
54(2):427–432
13. Taudt A, Roquis D, Vidalis A, Wardenaar R,
Johannes
F,
Colome´-Tatche´
M
(2018)
METHimpute: imputation-guided construc-
tion of complete methylomes from wgbs data.
BMC Genomics 19(1):444–444
14. Kapourani C-A, Sanguinetti G (2019) Melissa:
Bayesian clustering and imputation of single-
cell methylomes. Genome Biol 20(1):61
15. Angermueller C, Lee HJ, Reik W, Stegle O
(2017)
DeepCpG:
accurate
prediction
of
single-cell DNA methylation states using deep
learning. Genome Biol 18(1):67
16. Scott CA, Duryea JD, MacKay H, Baker MS,
Laritsky E, Gunasekara CJ, Coarfa C, Water-
land RA (2020) Identiﬁcation of cell type-
speciﬁc methylation signals in bulk whole
genome bisulﬁte sequencing data. Genome
Biol 21(1):156
17. Niederhuth CE, Bewick AJ, Ji L, Alabady MS,
Kim KD, Li Q, Rohr NA, Rambani A, Burke
JM,
Udall
JA,
Egesi
C,
Schmutz
J,
Grimwood
J,
Jackson
SA,
Springer
NM,
Schmitz RJ (2016) Widespread natural varia-
tion of DNA methylation within angiosperms.
Genome Biol 17(1):194
18. Domb K, Katz A, Harris KD, Yaari R, Kaisler E,
Nguyen VH, Hong UVT, Griess O, Heskiau
KG, Ohad N, Zemach A (2020) DNA methyl-
ation mutants in Physcomitrella patens elucidate
individual roles of CG and non-CG methyla-
tion in genome regulation. Proc Natl Acad Sci
117(52):33700–33710
19. Tian S, Bertelsmann K, Yu L, Sun S (2016)
DNA methylation heterogeneity patterns in
breast cancer cell lines. Cancer Informat 15
(Supple 4):1–9
20. Harris KD, Zemach A (2020) Contiguous and
stochastic CHH methylation patterns of plant
DRM2 and CMT2 revealed by single-read
methylome analysis. Genome Biol 21(1):194
21. Afﬁnito O, Palumbo D, Fierro A, Cuomo M,
De Riso G, Monticelli A, Miele G, Chiariotti L,
Cocozza S (2020) Nucleotide distance inﬂu-
ences co-methylation between nearby cpg
sites. Genomics 112(1):144–150
22. Chang Y-TS, Yen M-R, Chen P-Y (2022)
BSImp: imputing partially observed methyla-
tion patterns for evaluating methylation het-
erogeneity. Front Bioinfor 2
23. Ziller MJ, Hansen KD, Meissner A, Aryee MJ
(2015) Coverage recommendations for meth-
ylation analysis by whole-genome bisulﬁte
sequencing. Nat Methods 12(3):230–232

Chapter 9
Sequoia: A Framework for Visual Analysis of RNA
Modiﬁcations from Direct RNA Sequencing Data
Ratanond Koonchanok, Swapna Vidhur Daulatabad, Khairi Reda,
and Sarath Chandra Janga
Abstract
Oxford Nanopore-based long-read direct RNA sequencing protocols are being increasingly used to study the
dynamics of RNA metabolic processes due to improvements in read lengths, increased throughput, decreas-
ing cost, ease of library preparation, and convenience. Long-read sequencing enables single-molecule-based
detection of posttranscriptional changes, promising novel insights into the functional roles of RNA. However,
fulﬁlling this potential will necessitate the development of new tools for analyzing and exploring this type of
data. Although there are tools that allow users to analyze signal information, such as comparing raw signal
traces to a nucleotide sequence, they don’t facilitate studying each individual signal instance in each read or
perform analysis of signal clusters based on signal similarity. Therefore, we present Sequoia, a visual analytics
application that allows users to interactively analyze signals originating from nanopore sequencers and can
readily be extended to both RNA and DNA sequencing datasets. Sequoia combines a Python-based backend
with a multi-view graphical interface that allows users to ingest raw nanopore sequencing data in Fast5 format,
cluster sequences based on electric-current similarities, and drill-down onto signals to ﬁnd attributes of
interest. In this tutorial, we illustrate each individual step involved in running Sequoia and in the process
dissect input data characteristics. We show how to generate Nanopore sequencing-based visualizations by
leveraging dimensionality reduction and parameter tuning to separate modiﬁed RNA sequences from their
unmodiﬁed counterparts. Sequoia’s interactive features enhance nanopore-based computational methodol-
ogies. Sequoia enables users to construct rationales and hypotheses and develop insights about the dynamic
nature of RNA from the visual analysis. Sequoia is available at https://github.com/dnonatar/Sequoia.
Key words RNA modiﬁcations, Epitranscriptome, Single-molecule sequencing, Nanopore signal
analysis, Visual infrastructure
1
Introduction
Several studies in recent years have led to the identiﬁcation of
dynamic chemical alterations of nucleotide RNA bases, which are
increasingly being viewed as critical switches in RNA metabolism.
Authors Ratanond Koonchanok and Swapna Vidhur Daulatabad have equally contributed to this chapter.
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_9,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
127

128
Ratanond Koonchanok et al.
[1–3]. While mRNA modiﬁcations such as pseudouridine (ψ) and
internal N6-methyladenosine (m6A) have long been known [4],
their transcriptome-wide proﬁling was limited due to a lack of
adequate detection and analysis tools, which hampered the study
of epitranscriptomics at the single-molecule resolution.
Oxford Nanopore Technologies’ (ONT) single-molecule,
long-read sequencing technologies, on the other hand, are allowing
for low-cost RNA sequencing. As an RNA molecule travels through
a nanopore, the MinION from the ONT, for example, measures
variations in current across the nanopore. The current disruption is
sensitive to the moiety passing through the pore, allowing altera-
tions to be detected at a single-base level. Developing tools that can
automatically detect such alterations is difﬁcult since it requires an
understanding of the signal properties that distinguish modiﬁed
from non-modiﬁed bases. Visual evaluation of modiﬁed signal
characteristics can substantially aid such analysis.
Nanopore sequencing data may be analyzed and shown using a
variety of programs and frameworks (e.g., poRe [5], poretools [6],
HPG Pore [7], NanoPack [8], NanoPipe [9], and NanoR [10])—
all of these existing tools are largely intended to offer an overall
sequencing run summary visualizations or descriptive information.
These tools offer only rudimentary support for evaluating signal
aspects in depth. As a result, there is an unmet demand for innova-
tive visualization techniques that allow for thorough visual exami-
nation of ONT signal features while also allowing for large-scale
signal comparison. Although there are tools that allow users to
explore signal information, such as SquiggleKit [11], which allows
users to compare raw signal traces with a given nucleotide sequence
using the dynamic time-warping algorithm, they do not allow users
to look into each individual signal instance of each read, nor do they
provide options to observe signal clusters based on signal similarity.
Sequoia, a visualization tool for examining signals generated by
the ONT, is illustrated in this chapter. Sequoia was created with the
goal of assisting users in interactively exploring nanopore current
signals underlying RNA sequences in order to identify features that
distinguish chemically modiﬁed from unmodiﬁed nucleotides. The
tool allows users to import Fast5 ﬁles straight from the ONT and
uses dynamic time warping to cluster signals based on their electric
current or the sequences they represent as determined by base-
calling techniques. Sequoia offers a multi-view interface for nano-
pore signal analysis at both a high-level overview and a low-level of
detail. A command-line Python-based component for data proces-
sing and visualization that can be operated wholly within a web
browser is included in the package. We use the Sequoia framework
to show a comparison of modiﬁed and unmodiﬁed nanopore RNA
signal data. We demonstrate each step of the analysis to extract
signal from raw Nanopore data to ﬁnd qualitative signals that
distinguish modiﬁcations from unmodiﬁed RNA bases. Although

Sequoia: Visual Analysis of RNA Modiﬁcations from Long Read Sequencing
129
Sequoia was originally designed for Nanopore-based direct-RNA
sequencing data, users can run the pipeline over DNA sequencing
data as well. Algorithmic and implementation details behind the
Sequoia’s application, along with couple of case studies for RNA
modiﬁcations to compare signals of modiﬁed and unmodiﬁed
nucleotides, and is demonstrated in the original article [12]. In
this tutorial, we present a step-by-step overview on how to use the
Sequoia tool ab initio for analyzing raw nanopore datasets.
Sequoia’s qualitative observations can be used to identify features
for developing automated modiﬁcation-prediction algorithms,
paving the path for high-throughput epitranscriptomic event
proﬁling.
2
Materials
Sequoia is located at https://github.com/dnonatar/Sequoia. The
entire
repository
can
be
downloaded
using
the
following
command.
git clone https://github.com/dnonatar/Sequoia.git
Python 3 and the following libraries are required.
•
pandas (0.25 or newer)
•
numpy (1.17 or newer)
•
h5py (2.9 or newer)
•
dtaidistance (1.2.3 or newer)
•
Nanopolish [13]
•
Minimap [14]
3
Methods
3.1
Backend
Computation
To run the tool, navigate to the Sequoia folder then open the unix
command line and run the following command.
python backend_computation.py [--f1 F1] [--f2 F2] [--p P] [--k K]
[--s S] [--o O]
Parameters
•
F1: Fast5 ﬁle for modiﬁed signals (required)
•
F2: Fast5 ﬁle for unmodiﬁed signals (optional)
•
P: Dynamic time warping penalty (optional, default = 0)
•
K: CSV ﬁle with a list of 5-mer of interest (required)

130
Ratanond Koonchanok et al.
•
S: Sample size for each 5-mer (optional, default = 100)
•
O: Output directory (required)
Example:
python backend_computation.py --f1 test.fast5 --k kmer_list.csv --o
myoutput
The 5-mer list ﬁle is a CSV ﬁle containing the list of k-mer that
are of interest. The CSV ﬁle would contain a list of 5-mers in a
single column (no header). A symbol (*) is used for either A, C, T,
G. For example, if the list below is provided, the code would extract
all 5-mers with AAC as the ﬁrst three letters, and CCCCC.
AAC**
CCCCC
3.2
Visualization
Interface
To start the web interface for visualization, the user must navigate
to the output directory where the output folder is placed, open a
command line, and use the following command to start a local web
server.
python -m http.server
The user will then open the URL and select “index.html” to
access the visualization interface. The Sequoia interface is a multi-
view visualization containing multiple interactive visual representa-
tions. The fundamental steps to navigate through the interface are
as follows.
3.2.1
Data Selection
Once the interface is launched, the user must provide the directory
that contains the preprocessed Nanopore ﬁles, which is essentially
the output from running the backend_computation.py command
mentioned earlier, then click the “choose” button (Fig. 1a). If the
user does not specify a directory, Sequoia would search for a direc-
tory named “data” by default.
3.2.2
5-mer List
After the input data is provided, the user will see uniformity of
signals within each 5-mer through the distribution plots of dissim-
ilarities in the form of box or violin plots, as shown in Fig. 1b. The
distribution of distances gives the user an overview of signal consis-
tency within each 5-mer class. A dissimilarity score is computed
between every pair of signals within a 5-mer. The box and violin
plot will then display the distribution of those pairs, as illustrated in
Fig. 2a. The dropdown menu at the top of Fig. 1b enables the user
to select between box and violin plot. The user can rank the 5-mers
either alphabetically or based on the median distance among the
signal instances. In addition, the user can ﬁlter the list of 5-mers by

Sequoia: Visual Analysis of RNA Modiﬁcations from Long Read Sequencing
131
Fig. 1 Components for the visualization interface: (a) Textbox for specifying input data directory. (b) Panels for
the list of 5-mers. (c) t-SNE chart and its parameters. (d) Signal plot corresponding to the t-SNE analysis
typing the label of a 5-mer of interest, restricting the list to display
the 5-mers that match the label. Wild card regular expression can
also be utilized in the search box, while an asterisk act as a wildcard
for all four RNA nucleotides (A, C, G, and T). For example, typing
“AACA*” brings up AACAA, AACAC, AACAG, and AACAT.
The user can proceed to generate the t-SNE plot by clicking up
to four 5-mers from the list displayed. The selected 5-mer will be
highlighted in the original panel and show up in the bottom panel.
3.2.3
t-SNE Plot
When the user selects a 5-mer from the list, points representing
signals will appear in the t-SNE plot where a single point is basically
a single signal. The t-SNE plot allows a user to investigate each
5-mer in more detail through the comparison of signals from one
or more 5-mers. Points with similar signal patterns will be relatively
close to one another compared to points with signal patterns that
are different, which are positioned further apart.
The user can adjust a set of parameters on the right of the plot
to dictate how the t-SNE plot will be displayed, as shown in Fig. 1c.
If a low perplexity is selected, there will be more groups with each
group having a small number of members. As the perplexity is
increased, the number of groups will decrease with a larger group
size, as illustrated in Fig. 2b. The user can zoom in onto the t-SNE
scatterplot to inspect data points closely. Individual signals can be
selected and exported from this plot into a CSV by clicking at
points on the t-SNE plot and using the “Download CSV” button.

132
Ratanond Koonchanok et al.
Fig. 2 Visual representations of the interface components in Sequoia: (a) Distribution plot for a single 5-mer.
(b) Effect of perplexity on t-SNE plot
3.2.4
Signal Plot
The user can select a subset of points on the t-SNE chart and
visualize their underlying signal characteristics, as shown in
Fig. 1d. The signal plots display the raw signal as a line graph that
represents the raw Nanopore-generated electric current where the
time of passage through the Nanopore is on the X-axis and the
strength of the current measured is on the Y-axis. The user can
choose to average all the selected signals by clicking at the “Aver-
age” button on the right. By doing so, the signals within the same
5-mer will be averaged. The 25th and 75th percentile of electric

(
(i
Sequoia: Visual Analysis of RNA Modiﬁcations from Long Read Sequencing
133
current values recorded at each time step will also be displayed
through the shaded areas. The user can also choose to normalize
the signals by which the length of the signals in the time dimension
is homogenized as opposed to displaying them in the original
length.
4
Notes
Oxford Nanopore Technologies use a speciﬁc output ﬁle format
called FAST5 (ﬁle extension: “.fast5”), which is essentially the
output from the sequencing runs. Such resulting ﬁles are then fed
into base-calling algorithms like Guppy [15]. FAST5 data format is
built using the Hierarchical Data Format (HDF5) for optimized
data organization and recovery. FAST5 data is organized into a
speciﬁc schema containing groups, datasets, and attributes, which
are comparable to directory, data, and metadata. Pre-processing
steps pertaining to signal annotation and extraction might slightly
differ based on the version of the FAST5 generated. Sequoia
accommodates these variations and enables users to deploy the
tool on all available FAST5 formats from Oxford Nanopore Tech-
nologies. These features enable Sequoia to be relevant not only to
current versions of FAST5 but can also be easily executed with
older versions of FAST5 formatted ﬁles.
4.1
Input Files
Depending on the version of technology and tools used to generate
a set of FAST5 ﬁles, there are two major versions of it: event-based
FAST5 (earlier version) and concise FAST5 (current version). The
organization of FAST5 also differs from various tools currently
used, with two variations: single-read and multi-read FAST5,
where one single-read FAST5 ﬁle has data pertaining to one
sequencing read. On the other hand, multi-read has multiple read
data packed into one FAST5 ﬁle (Fig. 3).
i) To run an event-based FAST5 ﬁle, users can directly use the
commands in the above section to deploy Sequoia.
python backend_computation.py [--f1 F1] [--f2 F2] [--p P] [--k
K] [--s S] [--o O]
i) In the case of concise FAST5, the user will have to run the
Nanopolish [13] tool to extract signal and pre-process the data
prior to running Sequoia. The steps involved are as follows:
(a)
Running Nanopolish:
git clone --recursive https://github.com/jts/nanopolish.git
cd nanopolish
make
nanopolish index -d fast5_ﬁles/ reads.fasta

134
Ratanond Koonchanok et al.
Fig. 3 Illustration of FAST5 hierarchy variation and respective pipeline. Flowchart
illustrating Single FAST5 data from Nanopore sequencing can be directly
plugged into Sequoia, and multi FAST5 data can be converted into single
FAST5 using the ont_fast5_api from Oxford Nanopore Technology
nanopolish eventalign \
--reads reads.fasta \
--bam reads-ref.sorted.bam \
--genome ref.fa \
--scale-events > reads-ref.eventalign.txt
(b)
Pre-processing Nanopolish data:
Python event_extractor.py [--i output_ﬁle_from_Nanopol-
ish.txt] [--o Output_ﬁle.txt]
(c)
Deploying Sequoia:
python backend_computation.py [--f1 F1] [--f2 F2] [--p P]
[--k K] [--s S] [--o O]
4.2
Execution (Signal
Extraction)
Nanopore sequencers generate a single Fast5 ﬁle from each
sequenced read, where Fast5 is a hdf5-based hierarchy of direc-
tories, essentially containing events table, signal information, and
other metadata. The indexes of the corresponding values from the
signal list are annotated on successive 5-mers in the events table.
The signal list is an array of electric current values indexed in
tandem with the events table. Since 5-mers repeat across the
reads, cumulative signals extracted for each 5-mer have multiple

Sequoia: Visual Analysis of RNA Modiﬁcations from Long Read Sequencing
135
Fig. 4 Overview of Sequoia. Depicting the ﬂow of two variations of FAST5 data from Oxford Nanopore long-
read direct RNA sequencing into respective data extraction pipelines and into Sequoia. Event-based FAST5
showing the signal associated with the events pertaining to each 5-mer sequenced. Similarly, average signal
and respective 5-mers annotated using Nanopolish from FAST5. Both versions of data output can be plugged
into Sequoia for signal deconvolution to be further analyzed and visualized
instances. Each instance, hereby referred to as signal instance, is a
vector of electric current values extracted from a single read. To
enhance memory efﬁciency, different modules in Sequoia are exe-
cuted in a speciﬁc order. All the steps involved in Sequoia are
automated and sequentially executed in the background. The series
of steps involved in Sequoia are as highlighted in Fig. 4. As seen in
step 2 of Fig. 4, the data generated from Nanopore-based long read
RNA-seq, is converted into a table containing pairs of 5-mer and
their corresponding signal instance. The consequential signal table
is then utilized to compute the similarity matrix, which represents
comparability between every pair of signal instances. Furthermore,
the similarity matrix will then be used to generate: a t-SNE plot that
visually displays resemblance of the signal instances in selected
5-mers, a box or violin plot which depicts the uniformity across
the signal instance of a 5-mer, and the raw signal graph which
superimposes signal instances from various 5-mers for comparison.
Depending on the version of miniKNOW (https://github.
com/nanoporetech), FAST5 has two variations in hierarchy, as
discussed below:

136
Ratanond Koonchanok et al.
4.2.1. Single-Read FAST5 Files: In this scenario, each FAST5 ﬁle
contains signal and sequence information from one single
read. Users can plug in single-read FAST5 ﬁles directly into
the Sequoia pipeline using the commands:
python backend_computation.py [--f1 F1] [--f2 F2] [--p P]
[--k K] [--s S] [--o O]
4.2.2. Multi-read FAST5 Files: A ﬁle is called multi-read FAST5
ﬁle when each ﬁle contains signal and sequence informa-
tion from multiple reads. Users can convert multi-read ﬁles
to single FAST5 ﬁles using the following commands and
use the output single-read data with Sequoia.
(a)
Installation:
pip install ont-fast5-api
-or-
git clone https://github.com/nanoporetech/
ont_fast5_api
pip install ./ont_fast5_api
(b)
Converting to single_fast5: command and parameters
multi_to_single_fast5
[required]
-i, --input_path INPUT_PATH <(path) folder
containing multi_read_fast5 ﬁles>
-s, --save_path SAVE_PATH <(path) to folder
where single_read fast5 ﬁles will be output
[optional]
-t, --threads THREADS <(int) number of CPU
threads to use; default=1>
--recursive
<if
included,
recursively
search
sub-directories for multi_read ﬁles>
(c)
Sample usage:
multi_to_single_fast5
--input_path
/path/to/
multi_reads
--save_path
/output/path/to/
single_reads
Where /path/to/multi_reads contains multi_-
read .fast5 ﬁles. The output will be single_read .fast5
ﬁles in the folder /output/path/to/single_reads.
This output folder can used for further processing
and analysis. More information can be found at:
https://github.com/nanoporetech/ont_fast5_api
These steps are crucial in transforming the input data into a
uniform version of sequence and signal information. Once this is
achieved, users can execute Sequoia’s primary execution command
(shown below) to deploy the tool and perform analysis and
visualization.
python backend_computation.py [--f1 F1] [--f2 F2] [--p P] [--k K]
[--s S] [--o O]

Sequoia: Visual Analysis of RNA Modiﬁcations from Long Read Sequencing
137
Sequoia is a visual analytics platform that can facilitate the explora-
tion of nanopore sequencing datasets [12]. The platform enables
users to visualize and cluster signal instances and thereby aid in the
identiﬁcation of patterns across datasets, generate hypotheses, and
develop inferences. Using Sequoia, users can input the raw Fast5
ﬁle of their interest and analyze k-mer-speciﬁc signals, which can be
further processed to generate visualizations that effectively depict
the characteristics of datasets as well as k-mers. Sequoia integrates
and employs a robust set of algorithms like dynamic time warping
and t-SNE to highlight the underlying features of the dataset of
interest. As such, the framework generates a set of informative
visualizations that not only enable users to pinpoint variations
across cohorts and datasets but also in individual 5-mers them-
selves, starting from raw direct RNA-sequencing datasets enabling
users to discover and employ the promising features contributing to
the variability in the signals. In this tutorial, we present a step-by-
step approach to employing the framework on user generated
datasets to increase its usability and to enhance its versatility to
both RNA and DNA sequencing datasets resulting from Oxford
Nanopore sequencing platforms. Given the number of groups
working on RNA modiﬁcations—which are increasingly being
reported across all the four RNA bases in both bacterial and eukary-
otic systems—we believe frameworks such as sequoia will play a
critical role in developing computational models for not only enu-
merating the location of modiﬁed bases in single-molecule direct
RNA-sequencing datasets but also uncovering the cross talk
between RNA modiﬁcations and other RNA metabolic processes
in the cell.
5
Summary and Discussion
References
1. Roundtree IA et al (2017) Dynamic RNA
modiﬁcations in gene expression regulation.
Cell 169(7):1187–1200
2. Gokmen-Polar Y et al (2015) Prognostic
impact of HOTAIR expression is restricted to
ER-negative breast cancers. Sci Rep 5:8765
3. Neelamraju Y, Hashemikhabir S, Janga SC
(2015) The human RBPome: from genes and
proteins to human disease. J Proteomics 127
(Pt A):61–70
4. Grosjean H (2015) RNA modiﬁcation: the
Golden
Period
1995–2015.
RNA
21(4):
625–626
5. Watson M et al (2015) poRe: an R package for
the visualization and analysis of nanopore
sequencing
data.
Bioinformatics
31(1):
114–115
6. Loman NJ, Quinlan AR (2014) Poretools: a
toolkit for analyzing nanopore sequence data.
Bioinformatics 30(23):3399–3401
7. Tarraga J et al (2016) HPG pore: an efﬁcient
and scalable framework for nanopore sequenc-
ing data. BMC Bioinformatics 17:107
8. De Coster W et al (2018) NanoPack: visualiz-
ing and processing long-read sequencing data.
Bioinformatics 34(15):2666–2669
9. Shabardina V et al (2019) NanoPipe-a web
server for nanopore MinION sequencing data
analysis. Gigascience 8(2)
10. Bolognini D et al (2019) NanoR: A user-
friendly R package to analyze and compare
nanopore sequencing data. PLoS One 14(5):
e0216471

138
Ratanond Koonchanok et al.
11. Ferguson JM, Smith MA (2019) SquiggleKit: a
toolkit for manipulating nanopore signal data.
Bioinformatics 35:5372
12. Koonchanok R et al (2021) Sequoia: an inter-
active visual analytics platform for interpreta-
tion and feature extraction from nanopore
sequencing datasets. BMC Genomics 22(1):
513
13. Loman NJ, Quick J, Simpson JT (2015) A
complete bacterial genome assembled de novo
using only nanopore sequencing data. Nat
Methods 12(8):733–735
14. Li H (2018) Minimap2: pairwise alignment for
nucleotide sequences. Bioinformatics 34(18):
3094–3100
15. Xu F et al (2021) Evaluation of nanopore
sequencing technology to identify Salmonella
enterica Choleraesuis var. Kunzendorf and
Orion var. 15(+), 34(). Int J Food Microbiol
346:109167

Chapter 10
Predicting Pseudouridine Sites with Porpoise
Xudong Guo, Fuyi Li, and Jiangning Song
Abstract
Pseudouridine is a ubiquitous RNA modiﬁcation and plays a crucial role in many biological processes.
However, it remains a challenging task to identify pseudouridine sites using expensive and time-consuming
experimental research. To this end, we present Porpoise, a computational approach to identify pseudour-
idine sites from RNA sequence data. Porpoise builds on a stacking ensemble learning framework with
several informative features and achieves competitive performance compared with state-of-the-art
approaches. This protocol elaborates on step-by-step use and execution of the local stand-alone version
and the webserver of Porpoise. In addition, we also provide a general machine learning framework that can
help identify the optimal stacking ensemble learning model using different combinations of feature-based
features. This general machine learning framework can facilitate users to build their pseudouridine pre-
dictors using their in-house datasets.
Key words RNA pseudouridine site, Sequence analysis, Machine learning, Stacking ensemble
learning
1
Introduction
Pseudouridine (ψ) is a vital RNA modiﬁcation widely present
in eukaryotes and prokaryotes. Pseudouridine plays a crucial role
in many biological processes and is related to various diseases
[1–6]. For example, it is reported that the mutation of pseudour-
idine is associated with lung cancer and dyskeratosis congenita
[7]. Therefore, it is essential to identify the pseudouridine sites
and understand their mechanism and functional roles. However,
experimental detection of pseudouridine sites requires considerable
laboratory research and expense [2, 8]. In this regard, computa-
tional methods to identify pseudouridine sites based on RNA
sequence information are desirable.
Several computational methods have been developed to predict
pseudouridine sites from RNA sequences in recent years. For exam-
ple, a support vector machine (SVM)-based method, PPUS, was
previously built to predict the pseudouridine sites catalyzed by
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_10,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
139

140
Xudong Guo et al.
pseudouridine synthase (PUS) of Homo sapiens and Saccharomyces
cerevisiae [9]. In another study, an SVM-based predictor, iRNA-
PseU, was proposed to identify pseudouridine sites in H. sapiens,
S. cerevisiae, and Mus musculus, based on the chemical properties of
nucleotides and on a pseudo-nucleotide composition (PseKNC)
coding scheme [10]. Other predictors trained on the dataset
collected in [10] include PseUI, iPseU-CNN, XG-PseU, Ensem-
PseU, and RF-PseU [11–16]. In addition, PIANO [17] and
PSI-MOUSE [18] were developed for pseudouridine site predic-
tion and annotation by incorporating both sequence-based features
and genome-derived features. However, the performance of these
predictors is rather limited by factors such as good data engineering
conditions and called for further improvement. To this end, we
developed Porpoise [19] to enhance the prediction performance of
pseudouridine sites in H. sapiens, S. cerevisiae, and M. musculus.
Porpoise was developed based on a comprehensive assessment of
18 types of sequence-based features and accordingly, four types of
features, including binary features, pseudo k-tuple composition,
nucleotide chemical property, and position-speciﬁc trinucleotide
propensity based on single-strand (PSTNPss), which were selected
to build the stacked ensemble learning framework of Porpoise.
Extensive benchmarking tests demonstrate that Porpoise achieves
superior performance than the state-of-the-art approaches [19].
This methods chapter provides a detailed description of the
step-by-step use and execution of the local stand-alone version
and webserver of Porpoise. In addition, a general machine learning
framework based on the framework of Porpoise is also provided to
facilitate users’ efforts to quickly build and optimize their stacking
models based on their own in-house datasets.
2
Materials
2.1
Software
Porpoise (see Note 1).
2.2
Python
Environment and
Required Packages
To run Porpoise smoothly, users need to install the corresponding
version of Python (i.e., Python 3) and several Python packages.
A quick way to conﬁgure the operating environment of Porpoise
is to install Anaconda3. Anaconda3 is an open-source python
hairstyle version, which contains Python, Conda (a Python package
manager), and various packages for scientiﬁc computing. It can be
used entirely independently without the additional conﬁguration of
Python.
•
The environment for running Porpoise is speciﬁed below:
python 3.5 ~ 3.6,
•
mlxtend 0.13.0,

Predicting Pseudouridine Sites with Porpoise
141
•
Pandas 0.24.2.
•
NumPy 1.18.5.
•
scikit-learn 0.19.0,
•
xgboost 0.90.
2.3
Data Sources
We used previously collected training and testing datasets [10],
which were collected from the RMBase database [20]. In particular,
three training datasets, H_990 (H. sapiens), S_628 (S. cerevisiae),
and M_944 (M. musculus), were used for model training, and two
independent-test
datasets,
H_200
(H.
sapiens)
and
S_200
(S. cerevisiae), were used. The training and testing datasets are freely
available at the Download page of the Porpoise webserver (http://
web.unimelb-bioinfortools.cloud.edu.au/Porpoise/). A descrip-
tion of each of such datasets follows:
1. RNA_training.txt is the training dataset H_990 (H. sapiens),
which
contains
495
positive
samples
(Ψ-site-containing
sequences) and 495 negative samples (false ψ-site-containing
sequences). Each sample comprises a 21-bp RNA sequence
with uridine located at the center.
2. RNA_training1.txt is the training dataset S_628 (S. cerevisiae),
which
includes
314
positive
samples
(Ψ-site-containing
sequences) and 314 negative samples (false ψ-site-containing
sequences). Each sample comprises a 31-bp RNA sequence
with uridine located at the center.
3. RNA_training2.txt
is
the
training
dataset
M_944
(M. musculus), which contains 472 positive samples (Ψ-site-
containing sequences) and 472 negative samples (false ψ-site-
containing sequences). Each sample comprises a 21-bp RNA
sequence with uridine located at the center.
4. RNA_test.txt
is
the
independent
test
dataset
H_200
(H. sapiens), which encompasses 100 positive samples (ψ-site-
containing sequences) and 100 negative samples (false ψ-site-
containing sequences). Each sample comprises a 21-bp RNA
sequence with uridine located at the center.
5. RNA_test1.txt
is
the
independent
test
dataset
S_200
(S. cerevisiae), which includes 100 positive samples (ψ-site-
containing sequences) and 100 negative samples (false ψ-site-
containing sequences). Each sample comprises a 31-bp RNA
sequence with uridine located at the center.

142
Xudong Guo et al.
3
Methods
3.1
Local Stand-
Alone Version of
Porpoise
This section provides an introduction of the speciﬁc requirements,
step-by-step guide, and output results of the stand-alone version of
Porpoise. Porpoise was developed based on Python, and users need
to build a Python environment prior to its use. The following
describes how to set up an operating environment of Porpoise in
detail (Fig. 1). First, if the input sequence is a full-length sequence,
it will be pre-processed to meet the requirements of the three
models of Porpoise; otherwise, it can be directly input into Por-
poise. Next, if the pre-processed sequence meets the length
requirement, Porpoise will generate the prediction result and
allow the saving of the output ﬁle by the user.
3.1.1
Sequence Windows
For the full-length RNA sequence, the nucleotide sequence
corresponding to the length of each model needs to be taken
prior to feature encoding (see Note 2). As previously discussed,
the samples in the H_990 and M_944 datasets are 21-bp sequences,
while the samples in the S_628 datasets are 31-bp sequences.
3.1.2
Step-by-Step
Usage Guide
Step 1: Install Anaconda3 and create a virtual environment of
Porpoise.
Users can enable a virtual environment of Porpoise using
Anaconda3
(https://www.anaconda.com/products/individual)
through which multiple virtual environments in different Python
versions are created. Herein we provide an example to illustrate
how
to
install
Anaconda3
in
Linux.
Detailed
installation
Fig. 1 The overall workﬂow of Porpoise

Predicting Pseudouridine Sites with Porpoise
143
instructions are available at the ofﬁcial website (https://docs.
anaconda.com/anaconda/install/).
1. Download the Anaconda3 installer.
2. Verify the installer hash.
3. Execute the following command in the terminal to install
Anaconda3:
bash Anaconda‐latest‐Linux‐x86 64:sh
4. Follow the prompts on the installer screens.
5. Using conda to create a virtual environment (named porpoise)
with Python 3.5:
conda create‐n porpoise python = 3:5
6. Verify if the environment is successfully created:
conda info‐e
7. Using the pip or conda, command to install the required
packages of Porpoise (taking NumPy as an example):
source activate porpoise
pip install Numpy = = 1:18:5
Step 2: Install Porpoise.
After conﬁguring and installing Porpoise’s environment, the
second step is to install the local stand-alone version of Porpoise.
8. Download the Porpoise.zip ﬁle from the Porpoise webserver.
9. Unzip the Porpoise.zip ﬁle to the folder:
unzip‐o Porpoise:zip‐d < folder path >
Step 3: Predict pseudouridine sites using Porpoise.
Users can predict potential pseudouridine sites by Porpoise
using the following commands:
10. Activate the environment and run Porpoise (Refer to Note 3):
cd home=xxx=Porpoise
source activate porpoise
python Porpoise:py‐i < InputFilePath > ‐species
< species name > ‐o < OutputFilePath >

144
Xudong Guo et al.
3.1.3
Output Format
The prediction results can be saved to an output ﬁle in plain text
format. The prediction result ﬁle contains the sequence ID,
sequence, and prediction score. The prediction score is the proba-
bility that within a given sequence, a site gets predicted as a pseu-
douridine. If such a score is greater than a given cutoff threshold, it is
regarded as a pseudouridine site; otherwise, it is predicted as a
non-pseudouridine site. The closer the prediction score is to
1, the more likely the sample is to be a pseudouridine site. On the
contrary, the closer the prediction score is to 0, the more likely the
sample is to be a non-pseudouridine site.
Porpoise provides a result visualization function to display the
prediction results in SVG format. Such result visualization function
contains the following parameters:
– i: Input FASTA sequence ﬁle path
– m: Prediction result ﬁle path
– t: Threshold (three options: LOW, MEDIUM, HIGH).
– s: Species (three options: H. sapiens, S. cerevisiae, M. musculus)
– o: Output ﬁle path (default value: result.svg)
The visualization results can be generated by running the following
command (see Note 4):
python MYSVG:py‐i < Input file path > ‐m
< Model ′ s output file path > ‐t < threshold >
‐s < species name >
‐o result:svg
3.2
Webserver
To facilitate community-wide use including biologists with limited
bioinformatics expertise and allow the high-throughput analysis
and prediction of novel potential RNA pseudouridine sites, we
have also implemented an easy-to-use online webserver of Por-
poise, which is publicly available at http://web.unimelb-bio
infortools.cloud.edu.au/Porpoise/.
The
following
section
describes how to use the online webserver of Porpoise.
3.2.1
Online Webserver
Layout
There are six webpages on the webserver of Porpoise, including
Home, Server, Help, Job list, Download, and Contact pages. The
Home page is the default page and provides the description of
Porpoise. The Server webpage is the primary page that allows the
users to input or upload RNA sequences in FASTA format and
submit the job. The Help page provides several screenshots to
illustrate how to use the webserver of Porpoise. At the Job list
webpage, the users can query the processing status of their submit-
ted jobs according to the job ids. The Download webpage allows
the users to download the local stand-alone version and the training
and test datasets of Porpoise. Finally, users can contact us according

Predicting Pseudouridine Sites with Porpoise
145
Fig. 2 A screenshot showing the ﬁve major steps in using the Porpoise webserver
to the contact information provided on the Contact webpage in
cases where they ﬁnd any bugs or have any feedback.
3.2.2
Running
Predictions Through the
Online Webserver
Figure 2 illustrates the ﬁve major steps to run Porpoise via its online
webserver. This section discusses these ﬁve steps as follows:
1. Upload or copy/paste the input sequence data.
The webserver allows users to input one or more RNA
sequences in FASTA format in the input text box or upload a
sequence ﬁle in FASTA format.

Method assigns the feature encoding schemes for nucleo-
tide sequences (see Note 2). There are four different types of
feature encoding schemes that can be selected, including
binary features, pseudo k-tuple composition (PseKNC),
nucleotide chemical property (NCP), and PSTNPss. Multi-
ple encoding schemes should be separated by semicolons.
146
Xudong Guo et al.
2. Select the species type.
There are three species-speciﬁc models (H. sapiens, S. cerevisiae,
and M. musculus) provided in the webserver, and the users need to
select the corresponding species type.
3. Input an email address.
Users can provide their email addresses so that the webserver
can send the prediction results to their email once the prediction
task is completed.
4. Prediction results.
The prediction results are provided in a table format with ﬁve
columns, including sequence ID, sequence, probability, species
type, conﬁdence level, and position. Users can save the prediction
results in multiple formats including plain text, XLSX, PDF, and
CSV formats.
5. Query task.
The users can query their job status and retrieve the prediction
results using the job ID of their prediction task at the job list
webpage.
3.3
Auto-pipeline for
Model Training
To facilitate the users with limited machine learning expertise to
build their stacking ensemble learning models using in-house data-
sets, we also provide an Auto-pipeline (see Note 5) that allows users
to develop their stacking models based on the framework of Por-
poise. This Auto-pipeline can help users select the best base classiﬁer
combinations to build the stacking ensemble learning model based
on the features used in Porpoise. Users can ﬁrst specify their con-
ﬁguration requirements in a conﬁg.txt ﬁle and then use the Auto-
pipeline to generate the optimal stacking model.
3.3.1
Step-by-Step
Details
1. Prepare the conﬁguration ﬁle conﬁg.txt.
Five necessary parameters need to be set to run the Auto-
pipeline:
–
– ML assigns the base classiﬁers used for model stacking. The
user should select more than two base classiﬁers to build the
stacking model. Table 1 lists the base classiﬁers provided in
the Auto-pipeline. Users can use the abbreviations to assign

i, the input sequence ﬁle path.
Predicting Pseudouridine Sites with Porpoise
147
Table 1
Base classifiers and their abbreviations provided in Auto-pipeline
Abbreviation
Base classiﬁer
Abbreviation
Base classiﬁer
lr
Logistic Regression
rf
Random Forest Classiﬁer
knn
K Neighbors Classiﬁer
ada
AdaBoost Classiﬁer
nb
Naive Bayes
gbc
Gradient Boosting Classiﬁer
dt
Decision Tree Classiﬁer
lda
Linear Discriminant Analysis
svm
SVM – Linear Kernel
et
Extra Trees Classiﬁer
rbfsvm
SVM – Radial Kernel
xgboost
Extreme Gradient Boosting
gpc
Gaussian Process Classiﬁer
catboost
CatBoost Classiﬁer
mlp
MLP Classiﬁer
lightgbm
Light Gradient Boosting Machine
ridge
Ridge Classiﬁer
the
base
classiﬁers,
which
should
be
separated
by
semicolons.
– Kmer_Size assigns the k (k neighbouring nucleic acids)
value for the PseKNC encoding. This parameter should be
an integer larger than 0, with the default value of 3.
– normalize_method is the feature normalization algorithms
(two options: minmax and zscore).
– Validation assigns the k value for the k-fold cross-validation
(two options: 5, 10).
2. Run the Auto-pipeline.
The following parameters should be provided to run Auto-
pipeline:
–
– o, the output ﬁle folder.
– c: the ﬁle path for conﬁg.txt.
Users
can
view
the
parameters
with
the
following
command:
:=Auto - pipeline - h
Execute the following command to verify the user’s stacked
model:
:=Auto - pipeline - - i < dataset:fasta > - - c config:txt - - o result:txt

148
Xudong Guo et al.
Fig. 3 The overall workﬂow of the Auto-pipeline
3.3.2
Outputs
The output of the Auto-pipeline is the optimal stacking model
selected by the sample framework of Porpoise. As shown in
Fig. 3, it ﬁrst compares the performance of base classiﬁers, then
builds a series of stacked ensemble learning models through differ-
ent combinations of base classiﬁers, and ﬁnally selects the optimal
stacked model by comparing the performance of different combi-
nations models. The Auto-pipeline will generate six output ﬁles,
including the model ﬁle of the optimal stacked model (optimal-
Stacker.pkl), the performance comparison results of base classiﬁers
(resultsOfBaseClassiﬁers.csv), the performance evaluation results of
the stacked model (resultsOfStacker.csv), the training process
results (trainingProcess.txt), AUC curves (AUC.png), and confu-
sion matrix plot (Confusion Matrix.png). In the resultsOfBaseClas-
siﬁers.csv and resultsOfBaseClassiﬁers.csv ﬁles, six performance
metrics are calculated, including accuracy, AUC, recall, precision,
F1-score, and Matthew’s Correlation Coefﬁcient (MCC) [21–32],
among which MCC is used as the primary performance measure to
rank the classiﬁers (Table 2).
4
Notes
1. The source code and datasets of Porpoise are freely available at
the webserver: http://web.unimelb-bioinfortools.cloud.edu.
au/Porpoise/.
2. Porpoise uses four types of encoding schemes, including binary
features, pseudo k-tuple composition, nucleotide chemical
property, and PSTNPss. These features are fed into the stacked
ensemble learning framework to enable the construction of an
effective stacked model.

Predicting Pseudouridine Sites with Porpoise
149
Table 2
IDs and names of available basic classifiers
ID
Name
ID
Name
lr
Logistic Regression
rf
Random Forest Classiﬁer
knn
K Neighbors Classiﬁer
qda
Quadratic Discriminant Analysis
nb
Naive Bayes
ada
AdaBoost Classiﬁer
dt
Decision Tree Classiﬁer
gbc
Gradient Boosting Classiﬁer
svm
SVM – Linear Kernel
lda
Linear Discriminant Analysis
rbfsvm
SVM – Radial Kernel
et
Extra Trees Classiﬁer
gpc
Gaussian Process Classiﬁer
xgboost
Extreme Gradient Boosting
mlp
MLP Classiﬁer
catboost
CatBoost Classiﬁer
ridge
Ridge Classiﬁer
lightgbm
Light Gradient Boosting Machine
3. xxx denotes the username of the Linux system.
4. MYSVG.py needs two inputs: the prediction scores and the
input sequences in FASTA format.
5. We provide an Auto-pipeline that allows the users to train their
own stacking ensemble model based on the conﬁguration ﬁle
conﬁg.txt.
References
1. Basak A, Query CC (2014) A pseudouridine
residue in the spliceosome core is part of the
ﬁlamentous growth program in yeast. Cell Rep
8(4):966–973. https://doi.org/10.1016/j.cel
rep.2014.07.004
2. Carlile TM, Rojas-Duran MF, Zinshteyn B,
Shin H, Bartoli KM, Gilbert WV (2014) Pseu-
douridine proﬁling reveals regulated mRNA
pseudouridylation in yeast and human cells.
Nature 515(7525):143–146. https://doi.
org/10.1038/nature13802
3. Charette M, Gray MW (2000) Pseudouridine
in RNA: what, where, how, and why. IUBMB
Life 49(5):341–351. https://doi.org/10.
1080/152165400410182
4. Davis DR, Veltri CA, Nielsen L (1998) An
RNA model system for investigation of pseu-
douridine stabilization of the codon-anticodon
interaction in tRNALys, tRNAHis and tRNA-
Tyr. J Biomol Struct Dyn 15(6):1121–1132.
https://doi.org/10.1080/07391102.1998.
10509006
5. Jack K, Bellodi C, Landry DM, Niederer RO,
Meskauskas A, Musalgaonkar S, Kopmar N,
Krasnykh
O,
Dean
AM,
Thompson
SR
(2011) rRNA pseudouridylation defects affect
ribosomal ligand binding and translational
ﬁdelity from yeast to human cells. Mol Cell
44(4):660–666. https://doi.org/10.1016/j.
molcel.2011.09.017
6. Ma X, Zhao X, Yu YT (2003) Pseudouridyla-
tion (Ψ) of U2 snRNA in S. cerevisiae is cata-
lyzed by an RNA-independent mechanism.
EMBO J 22(8):1889–1897. https://doi.org/
10.1038/sj.emboj.7600718
7. Mei Y, Liao J, Shen J, Yu L, Liu B, Liu L, Li R,
Ji L, Dorsey S, Jiang Z (2012) Small nucleolar
RNA 42 acts as an oncogene in lung tumori-
genesis.
Oncogene
31(22):2794–2804.
https://doi.org/10.1038/onc.2011.449
8. Li X, Zhu P, Ma S, Song J, Bai J, Sun F, Yi C
(2015) Chemical pulldown reveals dynamic
pseudouridylation of the mammalian transcrip-
tome. Nat Chem Biol 11(8):592–597. https://
doi.org/10.1038/nchembio.1836

150
Xudong Guo et al.
9. Li Y-H, Zhang G, Cui Q (2015) PPUS: a web
server to predict PUS-speciﬁc pseudouridine
sites.
Bioinformatics
31(20):3362–3364.
https://doi.org/10.1093/bioinformatics/
btv366
10. Chen W, Tang H, Ye J, Lin H, Chou K-C
(2016) iRNA-PseU: identifying RNA pseu-
douridine sites. Mol Ther Nucleic Acids 5:
e332.
https://doi.org/10.1038/mtna.
2016.37
11. Bi Y, Jin D, Jia C (2020) EnsemPseU: identify-
ing pseudouridine sites with an ensemble
approach.
IEEE
Access
8:79376–79382.
https://doi.org/10.1109/ACCESS.2020.
2989469
12. He J, Fang T, Zhang Z, Huang B, Zhu X,
Xiong Y (2018) PseUI: Pseudouridine sites
identiﬁcation based on RNA sequence infor-
mation.
BMC
Bioinformatics
19(1):1–11.
https://doi.org/10.1186/s12859-018-
2321-0
13. Khan SM, He F, Wang D, Chen Y, Xu D
(2020)
MU-PseUDeep:
a
deep
learning
method for prediction of pseudouridine sites.
Comput Struct Biotechnol J 18:1877–1883.
https://doi.org/10.1016/j.csbj.2020.07.010
14. Liu K, Chen W, Lin H (2020) XG-PseU: an
eXtreme gradient boosting based method for
identifying
pseudouridine
sites.
Mol
Gen
Genomics 295(1):13–21. https://doi.org/10.
1007/s00438-019-01600-9
15. Lv Z, Zhang J, Ding H, Zou Q (2020)
RF-PseU: a random forest predictor for RNA
pseudouridine sites. Front Bioeng Biotechnol
8:134. https://doi.org/10.3389/fbioe.2020.
00134
16. Tahir M, Tayara H, Chong KT (2019) iPseU-
CNN: identifying RNA pseudouridine sites
using convolutional neural networks. Mol
Ther Nucleic Acids 16:463–470. https://doi.
org/10.1016/j.omtn.2019.03.010
17. Song B, Tang Y, Wei Z, Liu G, Su J, Meng J,
Chen K (2020) PIANO: a web server for
pseudouridine-site (Ψ) identiﬁcation and func-
tional annotation. Front Genet 11:88. https://
doi.org/10.3389/fgene.2020.00088
18. Song B, Chen K, Tang Y, Ma J, Meng J, Wei Z
(2020) PSI-MOUSE: predicting mouse pseu-
douridine sites from sequence and genome-
derived
features.
Evol
Bioinform
16:
1176934320925752. https://doi.org/10.
1177/1176934320925752
19. Li F, Guo X, Jin P, Chen J, Xiang D, Song J,
Coin LJM (2021) Porpoise: a new approach for
accurate prediction of RNA pseudouridine
sites. Brief Bioinform. https://doi.org/10.
1093/bib/bbab245
20. Sun W-J, Li J-H, Liu S, Wu J, Zhou H, Qu
L-H, Yang J-H (2016) RMBase: a resource for
decoding the landscape of RNA modiﬁcations
from
high-throughput
sequencing
data.
Nucleic
Acids
Res
44(D1):D259–D265.
https://doi.org/10.1093/nar/gkv1036
21. Chen Z, Zhao P, Li F, Marquez-Lago TT,
Leier
A,
Revote
J,
Zhu
Y, Powell
DR,
Akutsu T, Webb GI, Chou KC, Smith AI,
Daly RJ, Li J, Song J (2020) iLearn: an
integrated platform and meta-learner for fea-
ture engineering, machine-learning analysis
and modeling of DNA, RNA and protein
sequence
data.
Brief
Bioinform
21(3):
1047–1057. https://doi.org/10.1093/bib/
bbz041
22. Li F, Chen J, Leier A, Marquez-Lago T, Liu Q,
Wang Y, Revote J, Smith AI, Akutsu T, Webb
GI, Kurgan L, Song J (2020) DeepCleave: a
deep learning predictor for caspase and matrix
metalloprotease substrates and cleavage sites.
Bioinformatics 36(4):1057–1065. https://
doi.org/10.1093/bioinformatics/btz721
23. Li F, Leier A, Liu Q, Wang Y, Xiang D,
Akutsu T, Webb GI, Smith AI, Marquez-
Lago T, Li J, Song J (2020) Procleave: predict-
ing protease-speciﬁc substrate cleavage sites by
combining sequence and structural informa-
tion.
Genomics
Proteomics
Bioinformatics
18(1):52–64. https://doi.org/10.1016/j.
gpb.2019.08.002
24. Chen Z, Zhao P, Li C, Li F, Xiang D, Chen YZ,
Akutsu T, Daly RJ, Webb GI, Zhao Q,
Kurgan L, Song J (2021) iLearnPlus: a com-
prehensive and automated machine-learning
platform for nucleic acid and protein sequence
analysis, prediction and visualization. Nucleic
Acids Res 49(10):e60. https://doi.org/10.
1093/nar/gkab122
25. Li
F,
Chen
J,
Ge
Z,
Wen
Y,
Yue
Y,
Hayashida M, Baggag A, Bensmail H, Song J
(2021) Computational prediction and inter-
pretation of both general and speciﬁc types of
promoters in Escherichia coli by exploiting a
stacked ensemble-learning framework. Brief
Bioinform 22(2):2126–2140. https://doi.
org/10.1093/bib/bbaa049
26. Liu Q, Chen J, Wang Y, Li S, Jia C, Song J, Li F
(2021) DeepTorrent: a deep learning-based
approach
for
predicting
DNA
N4-methylcytosine
sites.
Brief
Bioinform
22(3):bbaa124. https://doi.org/10.1093/
bib/bbaa124

Predicting Pseudouridine Sites with Porpoise
151
27. Mei S, Li F, Xiang D, Ayala R, Faridi P, Webb
GI, Illing PT, Rossjohn J, Akutsu T, Croft NP,
Purcell AW, Song J (2021) Anthem: a user
customised tool for fast and accurate prediction
of binding between peptides and HLA class I
molecules. Brief Bioinform. https://doi.org/
10.1093/bib/bbaa415
28. Zhu Y, Li F, Xiang D, Akutsu T, Song J, Jia C
(2020)
Computational
identiﬁcation
of
eukaryotic promoters based on cascaded deep
capsule
neural
networks.
Brief
Bioinform.
https://doi.org/10.1093/bib/bbaa299
29. Chai D, Jia C, Zheng J, Zou Q, Li F (2021)
Staem5: a novel computational approachfor
accurate prediction of m5C site. Mol Ther
Nucleic Acids 26:1027–1034. https://doi.
org/10.1016/j.omtn.2021.10.012
30. Wang X, Li F, Xu J, Rong J, Webb GI, Ge Z,
Li J, Song J (2022) ASPIRER: a new computa-
tional approach for identifying non-classical
secreted proteins based on deep learning.
Brief Bioinform. https://doi.org/10.1093/
bib/bbac031
31. Li
F,
Guo
X,
Xiang
D,
Pitt
ME,
Bainomugisa A, Coin LJ (2022) Computa-
tional analysis and prediction of PE_PGRS pro-
teins using machine learning. Comput Struct
Biotechnol J. https://doi.org/10.1016/j.csbj.
2022.01.019
32. Li F, Dong S, Leier A, Han M, Guo X, Xu J,
Wang X, Pan S, Jia C, Zhang Y (2022) Positive-
unlabeled
learning
in
bioinformatics
and
computational biology: a brief review. Brief
Bioinform 23(1):bbab461. https://doi.org/
10.1093/bib/bbab461

Chapter 11
Pseudouridine Identiﬁcation and Functional Annotation
with PIANO
Jiahui Yao, Cuiyueyue Hao, Kunqi Chen, Jia Meng, and Bowen Song
Abstract
Pseudouridine (Ψ) is the ﬁrst-discovered RNA modiﬁcation abundantly present in many classes of RNAs,
which plays a pivotal role in a series of biological processes. Accurately identifying the location of Ψ sites is
helpful for relevant downstream researches. In this chapter, we introduce a website PIANO—for pseudour-
idine site (Ψ) identiﬁcation and functional annotation, which enables researchers to predict human putative
Ψ sites with a high-accuracy (average AUC of 0.955 under the full transcript model and 0.838 under the
mature mRNA model when testing on six independent datasets). The posttranscriptional regulatory
mechanisms of putative Ψ sites including miRNA-targets, RBP-binding regions, and splicing sites were
also annotated. A comprehensive query database was also provided to deposit over 4300 human Ψ
modiﬁcations, which is currently the most complete collection of experimental-derived Ψ sites. The
PIANO website is freely accessible at: http://piano.rnamd.com or http://180.208.58.19/Ψ-WHISTLE.
Key words Pseudouridine sites, Genome-derived feature, RNA modiﬁcation, Web-server, Functional
annotation
1
Introduction
As the ﬁrst-discovered RNA modiﬁcation occurring at the Uridine
site [1], pseudouridine (5-ribosyluracil, Ψ) occurs in many classes of
RNA, including mRNA, tRNA, snRNA, rRNA, and snoRNA [2],
which is the most prevalent modiﬁcation [3] with 7–9% of Ψ/U
ratio. It plays a pivotal role in various essential biological processes
[4, 5], and a deﬁciency of Ψ may be related to various diseases
[6, 7].
Wet-lab approaches were effective for proﬁling human Ψ sites,
such as Ψ-seq, PSI-seq, Pseudo-seq, CeU-seq, and RBS-seq [8–
12]. However, these experimental approaches are laborious, and
the coverage is limited to the transcripts, which expressed more
than others under a typical biological condition.
Computational approaches have been largely introduced to facil-
itate wet-lab experiments, including both machine learning models
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_11,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
153

154
Jiahui Yao et al.
[13–18] and collection of RNA modiﬁcation sites [19–22]. Inspired
by WHISTLE framework [23], here, a Ψ-site prediction framework,
PIANO (pseudouridine site identiﬁcation and functional annota-
tion), was developed based on a machine learning approach, which
extracts both sequence-derived and genomic-derived encodings to
support high-accuracy Ψ site prediction. In addition, the predicted Ψ
modiﬁcations are returned with various posttranscriptional genome
annotations. A PIANO website interface has been constructed to
provide an experiment-validated database and a Ψ site predictor for
convenience for future studies on Ψ site and its function mechanism
in various posttranscriptional regulations.
2
Materials
2.1
Software
The R programming language was used to develop the predictor. R
of different versions can be downloaded from https://www.r-
project.org. The IDE of RStudio can be installed from https://
www. rstudio.com. Several R packages are used in the construction:
TxDb, GenomicFeatures, ANNOVAR, Vienna RNA, and Caret.
2.2
Data Sources
Six known human Ψ site datasets were used in the construction
generated from four different base-resolution techniques, includ-
ing Ψ-Seq, RBS-Seq, CeU-Seq, and Pseudo-Seq. Predictor con-
struction and performance evaluation were conducted on these
datasets. The data were also deposited onto the database part of
the website.
3
Methods
Here, we describe the construction of the PIANO predictor frame-
work and how to use the PIANO web server to obtain the required
Ψ sites and corresponding function annotations.
3.1
A High-Accuracy
Predictor of Human Ψ
Sites Using a Machine
Learning Approach
Six experiment-validated datasets of human Ψ sites were down-
loaded for model construction. All data were accessible on gene
expression omnibus (GEO) (Table 1).
3.1.1
Dataset
Preparation for the
Machine Learning
Approach
3.1.2
Feature Encoding
Methods
In order to transform the biological information into the features
required by machine learning, three sequence-derived feature
methods (see note 1) and 42 genome-derived features were used
for encoding (see note 2). According to the importance rank

Pseudouridine Identiﬁcation and Functional Annotation with PIANO
155
Table 1
Base-resolution dataset used for Ψ-site prediction
Dataset
Cell line
Treatment
Technique
Site #
Source
H1
HEK293
Ψ-Seq
652
[8]
H2
Hela
RBS-Seq
322
[12]
H3
HEK293T
CeU-Seq
1555
[11]
H4
HEK293T
H2O2
460
H5
HEK293T
Heat Shock (HS)
421
H6
Hela
Pseudo-Seq
156
[10]
generated from the Perturb method [24] using R caret package, the
top n genomic features were selected for predictor construction to
avoid potential over-ﬁtting.
3.1.3
Model Training and
Evaluation
Support vector machine (SVM) with radial basis function was used
to build the classiﬁers, and a ﬁvefold cross-validation was con-
ducted. Dataset level leave-one-out cross-validation was con-
ducted, in which one of the ﬁve datasets was used as a testing
dataset, and the remaining dataset was used for training. Then,
the predictor was benchmarked by a dataset generated from an
independent Y proﬁling technique. The performance of the
PIANO framework was further evaluated by cell lines level cross-
validation, where datasets from HEK293T were used for training,
and datasets from Hela were used for testing. In addition, the
prediction of PSU-speciﬁc Ψ sites (pseudouridine synthase sub-
strates) was evaluated. In the performance, the area under ROC
curve (AUROC) was calculated as the main performance evaluation
metric.
3.1.4
Functional
Annotation of Putative Ψ
Sites and Probability
Estimation
The gene annotation including gene symbol, Ensembl gene ID,
gene type, and gene region were provided for each putative Ψ site
using R ANNOVAR package. In addition, the RBPs (RNA-binding
proteins) binding regions, miRNA-RNA targets, and splicing sites
were annotated. In addition, in order to accurately predict Ψ sites,
only the sites with a predictive value above 0.5 and a likelihood ratio
(RL) value greater than 1 (see note 3) were considered as the
putative Ψ site. Conﬁdence level was calculated based on RL value
to provide more reliable prediction results.
3.2
Using PIANO
Website to Obtain the
Desired Ψ site
A website PIANO (http://piano.rnamd.com) was built to support
a complete human Ψ site database containing 4303 experimental-
validated Ψ sites and a Ψ site predictor, which allows two types of
input ﬁle: FASTA format or genomic-information text format,

156
Jiahui Yao et al.
Fig. 1 Click Select ﬁle to input the ﬁles. Both FASTA format of simple txt format
were supported
serving as a helpful resource for researches in Ψ site and its role in
various posttranscriptional regulations.
3.2.1
Input File of PIANO
PIANO takes two kinds of formats as input ﬁles (Fig. 1): The ﬁrst is
the FASTA sequences and the second is a simple tab-delimited txt
format, which contains genomic position information (genome
assembly: hg19) with four columns: chromosome, start position,
end position, and strand.
3.2.2
Encoding Types
Used to Start the Prediction
Job
Choose the feature and annotation types to start the prediction
(Fig. 2a). After processing, users can view or download a list of
putative Ψ sites (Fig. 2b). When users leave the job page or lose the
page by accident, the job ID can be used to retrieve their job.
3.2.3
Result Explanation
for Genomic Feature-Based
Prediction
For users using both genomic and sequence-derived features, an
overall summary table is provided. Users can view the basic infor-
mation of putative Ψ sites with various gene annotations and a
number of related posttranscriptional annotations (Fig. 3).
3.2.4
Result Explanation
for Sequence-Based
Prediction
For users using quick sequence-derived features, a map of all puta-
tive Ψ sites in the given sequence is provided so that users can know
the position of each Ψ modiﬁcation (Fig. 4a). The detailed infor-
mation of each predicted Ψ site is then listed as a sequence of 41 bp,

Pseudouridine Identiﬁcation and Functional Annotation with PIANO
157
Fig. 2 (a) Choose a feature type and an annotation type to customize the prediction. (b) Click the Details to
view the whole predicted results or click Download to get a list of putative Ψ sites
as well as sample name, LR, and corresponding conﬁdence level
(Fig. 4b).
3.2.5
Ψ Site Collection in
PIANO Database
In the database of the website, PIANO provides a complete collec-
tion of experimental-validated human Ψ sites. Besides, a statistical
graph is provided to describe the distribution of these sites.

158
Jiahui Yao et al.
Fig. 3 A comprehensive list of putative Ψ sites with a number of functional annotations
4
Notes
1. The sequences of 41 bp ﬂanking the target sites were used for
sequence feature encoding. Three encoding methods were
used to extract features from sequences, including the chemical
properties of nucleotides, the position-speciﬁc nucleotide pro-
pensity, and cluster information. For the chemical properties of
nucleotides, each nucleotide was encoded to three dummy
variables, respectively, referring to whether the nucleotide has
ring structures, hydrogen bonds, and functional groups (amino
group as 1 and keto group as 0). Therefore, A, C, G, U is
respectively encoded as (1,1,1), (0,1,0), (1,0,0), and (0,0,1).
For the position-speciﬁc nucleotide propensity (PSNP), Zplus
and Zminus were calculated for the nucleotides on each position.
For the nucleotide on the ith position, Zplus is the frequency of
that nucleotide on the ith position in all positive data and
Zminue refers to the frequency of that nucleotide on the ith
position in all negative data. The PSNP value is then calculated
as Zplus - Zminue. For the cluster information, four variables are
calculated for every target site, respectively, referring to the
average relative position of each nucleic acid (A, C, G, U).
The value of each nucleic acid X (A, C, G, U) equals the sum
of the relative distance to the target site of the top k nearest X
divided by k (k can be 1, 2, 3). Using the target U site in
sequence “AGCCAUGCACG” as example, when k equals to
2, the value of A is (1 + 3) / 2 and the value of G is (1 + 4) / 2.

Pseudouridine Identiﬁcation and Functional Annotation with PIANO
159
Fig. 4 (a) A distribution of putative Ψ modiﬁcation is shown (b) Detailed information of each Ψ site is provided
2. Genomic-derived features. Forty-two genomic features were
used in the PIANO framework. The detailed descriptions are
summarized in Table 2.
3. The likelihood ratio (LR) of a Ψ site was calculated:
LR = P observationjΨ
ð
Þ
P observationjU
ð
Þ
ð1Þ
According to statistical signiﬁcance, the sites with the RL value
ranked in the top 0.5% of all transcriptome Us were reported to be
of high conﬁdence. The sites with the RL value ranked in the top
5% were labeled as medium conﬁdence, followed by low conﬁdence
of the remaining sites.

(continued)
160
Jiahui Yao et al.
Table 2
Genome-derived features used for human Ψ site prediction
ID Name
Description
Note
1
UTR5
5′ UTR
Dummy variables indicating whether the site is
overlapped to the topological region on the
major RNA transcript.
2
UTR3
3′ UTR
3
cds
Coding sequence
4
Stop_codons
Stop codons ﬂanked by
100 bp
5
Start_codons
Start codons ﬂanked by
100 bp
6
TSS
Downstream 100 bp of
TSS
7
TSS_A
Downstream 100 bp of
TSS on A
8
exon_stop
Exons containing stop
codons
9
alternative_exon
Alternative exons
10 constitutive_exon
Constitutive exons
11 internal_exon
Internal exons
12 long_exon
long exons (exon
length > = 400 bp)
13 last_exon
5′ last exon
14 last_exon_400bp
5′ 400 bp of the last
exons
15 last_exon_sc400
5′ 400 bp of the last
exons containing stop
codons
16 intron
Intron
17 pos_cds
Relative position on
coding sequence
Relative position on the region
18 pos_UTR5
Relative position on 5′
UTR
19 pos_UTR3
Relative position on 3′
UTR
20 pos_exons
Relative position on exon
21 length_UTR5
5′ UTR length
The region length in bp
22 length_UTR3
3′ UTR length
23 length_gene_ex
Mature transcript length
24 length_cds
Coding sequence length
25 length_gene_full
Full transcript length
26 dist_sj_5_p2000
Distance to the 5′ splicing
junction
Nucleotide distances toward the splicing
junctions or the nearest neighboring sites
27 dist_sj_3_p2000
Distance to the 3′ splicing
junction

Table 2
Pseudouridine Identiﬁcation and Functional Annotation with PIANO
161
(continued)
ID Name
Description
Note
28 PC_1bp
phastCons scores of the
nucleotide
Scores related to evolutionary conservation
29 PC_101bp
Average phastCons
scores within the
ﬂanking 50 bp
30 FC_1bp
ﬁtCons scores of the
nucleotide
31 FC_101bp
Average ﬁtCons scores
within the ﬂanking
50 bp region
32 struc_hybridize
Predicted RNA hybridized
region
RNA secondary structures
33 struc_loop
Predicted RNA loop
region
34 sncRNA
sncRNA
Genomic properties
35 lncRNA
lncRNA
36 HK_genes
Housekeeping genes
37 isoform_num
Number of isoforms
38 exon_num
Number of exons
39 HNRNPC_eCLIP
eCLIP data of HNRNPC
RNA binding sites
Attributes of the genes or transcripts
40 Veriﬁed_miRtargets
miRNA-targeted sites
veriﬁed by experiment
41 TargetScan
Predicted miRNA-
targeted sites by
TargetScan
42 miR_targeted_genes miRNA-targeted genes
References
1. Cohn WE, Volkin E (1951) Nucleoside-5′-
-phosphates from ribonucleic acid. Nature
167(4247):483–484
2. Ge J, Yu Y-T (2013) RNA pseudouridylation:
new insights into an old modiﬁcation. Trends
Biochem Sci 38(4):210–218
3. Meyer KD, Jaffrey SR (2017) Rethinking m6A
readers, writers, and erasers. Annu Rev Cell
Dev Biol 33:319–342
4. Jack K, Bellodi C, Landry DM, Niederer RO,
Meskauskas A, Musalgaonkar S, Kopmar N,
Krasnykh
O,
Dean
AM,
Thompson
SR
(2011) rRNA pseudouridylation defects affect
ribosomal ligand binding and translational
ﬁdelity from yeast to human cells. Mol Cell
44(4):660–666
5. Kierzek E, Malgowska M, Lisowiec J, Turner
DH, Gdaniec Z, Kierzek R (2014) The contri-
bution of pseudouridine to stabilities and
structure of RNAs. Nucleic Acids Res 42(5):
3492–3501
6. Bykhovskaya Y, Casas K, Mengesha E, Inbal A,
Fischel-Ghodsian N (2004) Missense mutation
in pseudouridine synthase 1 (PUS1) causes
mitochondrial myopathy and sideroblastic ane-
mia (MLASA). Am J Hum Genet 74(6):
1303–1308
7. Mei Y, Liao J, Shen J, Yu L, Liu B, Liu L, Li R,
Ji L, Dorsey S, Jiang Z (2012) Small nucleolar

17.
162
Jiahui Yao et al.
RNA 42 acts as an oncogene in lung tumori-
genesis. Oncogene 31(22):2794–2804
8. Schwartz S, Bernstein DA, Mumbach MR,
Jovanovic M, Herbst RH, Leo´n-Ricardo BX,
Engreitz JM, Guttman M, Satija R, Lander ES
(2014) Transcriptome-wide mapping reveals
widespread dynamic-regulated pseudouridyla-
tion of ncRNA and mRNA. Cell 159(1):
148–162
9. Lovejoy AF, Riordan DP, Brown PO (2014)
Transcriptome-wide mapping of pseudouri-
dines: pseudouridine synthases modify speciﬁc
mRNAs in S. cerevisiae. PLoS One 9(10):
e110799
10. Carlile TM, Rojas-Duran MF, Zinshteyn B,
Shin H, Bartoli KM, Gilbert WV (2014) Pseu-
douridine proﬁling reveals regulated mRNA
pseudouridylation in yeast and human cells.
Nature 515(7525):143–146
11. Li X, Zhu P, Ma S, Song J, Bai J, Sun F, Yi C
(2015) Chemical pulldown reveals dynamic
pseudouridylation of the mammalian transcrip-
tome. Nat Chem Biol 11(8):592–597
12. Khoddami V, Yerra A, Mosbruger TL, Fleming
AM,
Burrows
CJ,
Cairns
BR
(2019)
Transcriptome-wide
proﬁling
of
multiple
RNA modiﬁcations simultaneously at single-
base resolution. Proc Natl Acad Sci 116(14):
6784–6789
13. He J, Fang T, Zhang Z, Huang B, Zhu X,
Xiong Y (2018) PseUI: Pseudouridine sites
identiﬁcation based on RNA sequence infor-
mation.
BMC
Bioinformatics
19(1):306.
https://doi.org/10.1186/s12859-018-
2321-0
14. Liu K, Chen W, Lin H (2019) XG-PseU: an
eXtreme Gradient Boosting based method for
identifying
pseudouridine
sites.
Mol
Gen
Genomics.
https://doi.org/10.1007/
s00438-019-01600-9
15. Chen W, Tang H, Ye J, Lin H, Chou KC
(2016) iRNA-PseU: identifying RNA pseu-
douridine sites. Mol Ther Nucleic Acids 5:
e332.
https://doi.org/10.1038/mtna.
2016.37
16. Li YH, Zhang G, Cui Q (2015) PPUS: a web
server to predict PUS-speciﬁc pseudouridine
sites.
Bioinformatics
31(20):3362–3364.
https://doi.org/10.1093/bioinformatics/
btv366
Huang D, Song B, Wei J, Su J, Coenen F,
Meng J (2021) Weakly supervised learning of
RNA modiﬁcations from low-resolution epi-
transcriptome
data.
Bioinformatics
37
(Suppl_1):i222–i230. https://doi.org/10.
1093/bioinformatics/btab278
18. Liang Z, Zhang L, Chen H, Huang D, Song B
(2021) m6A-Maize: weakly supervised predic-
tion of m(6)A-carrying transcripts and m(6)A-
affecting mutations in maize (Zea mays).
Methods. https://doi.org/10.1016/j.ymeth.
2021.11.010
19. Song B, Chen K, Tang Y, Wei Z, Su J, Magal-
ha˜es
JPD,
Rigden
DJ,
Meng
J
(2021)
ConsRM: collection and large-scale prediction
of the evolutionarily conserved RNA methyla-
tion sites, with implications for the functional
epitranscriptome. Brief Bioinform. https://
doi.org/10.1093/bib/bbab088
20. Xuan JJ, Sun WJ, Lin PH, Zhou KR, Liu S,
Zheng LL, Qu LH, Yang JH (2018) RMBase
v2.0: deciphering the map of RNA modiﬁca-
tions from epitranscriptome sequencing data.
Nucleic
Acids
Res
46(D1):D327–D334.
https://doi.org/10.1093/nar/gkx934
21. Boccaletto
P,
Machnicka
MA,
Purta
E,
Piatkowski P, Baginski B, Wirecki TK, de
Crecy-Lagard
V,
Ross
R,
Limbach
PA,
Kotter A, Helm M, Bujnicki JM (2018)
MODOMICS: a database of RNA modiﬁca-
tion pathways. 2017 update. Nucleic Acids
Res 46(D1):D303–D307. https://doi.org/
10.1093/nar/gkx1030
22. Tang Y, Chen K, Song B, Ma J, Wu X, Xu Q,
Wei Z, Su J, Liu G, Rong R, Lu Z, de Magal-
haes JP, Rigden DJ, Meng J (2020) m6A-Atlas:
a comprehensive knowledgebase for unraveling
the N6-methyladenosine (m6A) epitranscrip-
tome. Nucleic Acids Res. https://doi.org/10.
1093/nar/gkaa692
23. Chen K, Wei Z, Zhang Q, Wu X, Rong R,
Lu Z, Su J, de Magalhaes JP, Rigden DJ,
Meng J (2019) WHISTLE: a high-accuracy
map
of
the
human
N6-methyladenosine
(m6A) epitranscriptome predicted using a
machine learning approach. Nucleic Acids Res
47(7):e41. https://doi.org/10.1093/nar/
gkz074
24. Gevrey M, Dimopoulos I, Lek S (2003) Review
and comparison of methods to study the con-
tribution of variables in artiﬁcial neural net-
work models. Ecol Model 160(3):249–264

Chapter 12
Analyzing mRNA Epigenetic Sequencing Data with TRESS
Zhenxing Guo, Andrew M. Shaﬁk, Peng Jin, Zhijin Wu, and Hao Wu
Abstract
RNA epigenetics has emerged as an active topic to study gene regulation mechanisms. In this regard, the
MeRIP-seq technology allows proﬁling transcriptome-wide mRNA modiﬁcations, in particular m6A. The
primary goals for the analysis of MeRIP-seq data are the identiﬁcation of m6A-methylated regions under
each condition and across different biological conditions. Here we describe detailed procedures to guide
researchers in MeRIP-seq data analyses by providing step-by-step instructions of the dedicated bioconduc-
tor package TRESS.
Key words RNA epigenetics, MeRIP-seq, Peak detection, Differential RNA methylation
1
Introduction
The study of posttranscriptional epigenetic modiﬁcations on
mRNA is part of an emerging ﬁeld to study genetic regulation
and its association with disease. Among all different types of RNA
modiﬁcations, m6A by far is the best known and most abundant
modiﬁcation on RNA molecules in eukaryotes (occurring at
roughly one in three adenosine residues in mammalian mRNA)
[1]. Studies report that m6A associates with multiple human dis-
eases such as cancers and neuronal disorders [2–4]. For example,
increased m6A methylation tends to enhance the translation of
oncogenes or degrade cancer suppressor genes. Study of m6A
helps to understand the development and progression of human
diseases, which contributes to the identiﬁcation of disease-
associated biomarkers and the discovery of therapeutic targets.
Recently developed high-throughput sequencing approach
named
methylated
RNA
immunoprecipitation
sequencing
(MeRIP-seq) enables transcriptome-wide proﬁling of m6A methyl-
ation [1]. In MeRIP-seq experiment, mRNA is ﬁrst fragmented
(approximately 100-nucleotide-long oligonucleotides) and then
immunoprecipitated (IP) by an anti-m6A afﬁnity puriﬁed antibody.
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_12,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
163

164
Zhenxing Guo et al.
Fig. 1 Peaks from MeRIP-seq in a mouse brain study, where m6A in cerebellums from 6-week-old mice are
proﬁled with two biological replicates
The antibody will enrich mRNA fragments with m6A methylation.
After immunoprecipitation, post-IP mRNA fragments are then
subject to high-throughput sequencing. In addition to the post-
IP samples, libraries are also prepared for input control fragments
to measure the background mRNA abundance, which essentially
quantiﬁes gene expression. After sequencing, the reads from both
IP and input samples are aligned to the reference genome. Due to
the enrichment from the IP process, transcriptomic regions with
m6A methylation will have more reads clustered than background
regions and form peak-like shapes when visualizing the read counts
along the genome. Therefore, people often refer to m6A regions as
“peaks,” a term usually used in ChIP-seq [5] to represent protein
binding sites. Figure 1 shows example m6A peaks on the Fat2 gene
from a study investigating the dynamics of m6A during mouse brain
development.
Studies have reported that cells may coordinately modulate
m6A modiﬁcation levels for regulatory purposes [6]. To explore
the dynamics of m6A in response to physiological conditions, one
ﬁrst needs to obtain the accurate genomic locations of m6A (“peak
calling”) and then identify regions where the m6A levels are altered
under such condition (“differential peak”). Both tasks require rig-
orous and efﬁcient tools for data analyses. Compared to the large
body of tools developed for RNA- and ChIP-seq data analysis,
those focusing on MeRIP-seq data are limited. Existing methods
suffer from serious limitations in either ignoring different sources
of variation, assuming inappropriate models, or low computational
efﬁciency [7–12]. The Bioconductor package TRESS (Toolbox for
mRNA Epigenetics Sequencing AnalysiS) is designed to overcome
the limitations in existing m6A tools [13]. In TRESS, both
transcriptome-wide m6A regions and differential m6A regions are
called in a two-step procedure. In the ﬁrst step, TRESS quickly
scans the whole transcriptome and loosely identiﬁes candidate
regions using an ad hoc algorithm. In the second step, TRESS

m6A Sequencing Data Analysis
165
models raw read counts from candidate regions using a hierarchical
negative binomial model that accounts for all sources of variation in
MeRIP-seq data. For peak calling, candidate regions whose meth-
ylation levels are signiﬁcantly greater than the background would
be inferred as m6A peaks. For differential peak calling, TRESS
connects the methylation level of each candidate region to covari-
ates by a generalized linear model framework. Candidate regions
whose methylation level is strongly associated with the covariate of
interest will be reported as differential m6A peaks. As the sample
size in MeRIP-seq experiment is usually small due to cost con-
straints (typically <3), TRESS induces a shrinkage procedure for
estimation of dispersion of methylation based on empirical Bayesian
methods. A Wald test is ﬁnally performed on each candidate to
detect either signiﬁcant m6A regions or differential m6A regions.
Thus, TRESS provides functions for candidate region identiﬁca-
tion, peak calling among candidates with/without replicates, and
differential peak calling analysis.
2
Materials
2.1
Data
The example dataset was obtained from the Gene Expression
Omnibus (GEO) under accession number GSE144032 [14]. This
data mainly contains samples from four mouse brain regions (cere-
bellum, cortex, hippocampus, and hypothalamus) at two time
points (2 and 6 week). Each sample has two pairs of IP and input
replicates. For peak calling analysis, we only use 6-week-old cere-
bellum samples. For differential m6A peaking, we use 2- and
6-week-old samples from mouse cerebellum and hypothalamus
regions. The detailed sample information used in this example is
provided in Table 1. With this dataset, we illustrate how to conduct
m6A peak calling analysis with and without replicates and differen-
tial m6A peak calling analysis.
2.2
Software
We will use the R language (https://cran.r-project.org/) for all data
preprocessing and downstream analysis. Bioconductor package
TRESS (https://bioconductor.org/packages/release/bioc/html/
TRESS.html) will be used for MeRIP-seq data analysis.
3
Methods
3.1
Download and
Preprocess Data
From the GEO website (https://www.ncbi.nlm.nih.gov/geo/),
search for GEO Accession number GSE144032. Under section
“Relations,” click the accession number to the right of “SRA”
will guide one to the NCBI’s Sequence Read Archive (SRA) web-
page, where all mouse brain datasets are listed. Each dataset con-
tains the raw sequencing data from that sample. Choose data for 2-

Table 1
Index
m6A antibody
Sample title
SRR_ ID
Bam ﬁle
1
GSM4278313
RNAseq_6wk_cerebellum_m6AIP_rep1 SRR10920696
2
GSM4278314
None
RNAseq_6wk_cerebellum_input_rep1
SRR10920697
3
GSM4278315
RNAseq_6wk_cerebellum_m6AIP_rep2 SRR10920698
4
GSM4278316
None
RNAseq_6wk_cerebellum_input_rep2
SRR10920699
5
GSM4278317
SRR10920700
6
GSM4278318
None
SRR10920701
7
GSM4278319
SRR10920702
8
GSM4278320
None
SRR10920703
9
GSM4493791
RNAseq_2wk_cerebellum_m6AIP_rep1 SRR11596813
10
GSM4493792
None
RNAseq_2wk_cerebellum_input_rep1
SRR11596814
11
GSM4493793
RNAseq_2wk_cerebellum_m6AIP_rep2 SRR11596815
166
Zhenxing Guo et al.
Detailed sample information of the four illustrative MeRIP-seq samples in this protocol
GEO
accession
number
Developmental
stage and source
Download
FASTQ ﬁle
6-week-old
cerebellum
Synaptic systems
m6A antibody
SRR10920696.
fastq
cb_6wk_ip
_rep1.bam
6-week-old
cerebellum
SRR10920697.
fastq
cb_6wk_input
_rep1.bam
6-week-old
cerebellum
Synaptic systems
m6A antibody
SRR10920698.
fastq
cb_6wk_ip
_rep2.bam
6-week-old
cerebellum
SRR10920699.
fastq
cb_6wk_input
_rep2.bam
6-week-old
hypothalamus
Synaptic systems
m6A antibody
RNAseq_6wk_ hypothalamus
_m6AIP_rep1
SRR10920700.
fastq
hth_6wk_ip
_rep1.bam
6-week-old
hypothalamus
RNAseq_6wk_ hypothalamus
input_rep1
SRR10920701.
fastq
hth_6wk_input
_rep1.bam
6-week-old
hypothalamus
Synaptic systems
m6A antibody
RNAseq_6wk_ hypothalamus
_m6AIP_rep2
SRR10920702.
fastq
hth_6wk_ip
_rep2.bam
6-week-old
hypothalamus
RNAseq_6wk_ hypothalamus
_input_rep2
SRR10920703.
fastq
hth_6wk_input
_rep2.bam
2-week-old
cerebellum
Synaptic systems
m6A antibody
SRR11596813.
fastq
cb_2wk_ip
_rep1.bam
2-week-old
cerebellum
SRR11596814.
fastq
cb_2wk_input
_rep1.bam
2-week-old
cerebellum
Synaptic systems
m6A antibody
SRR11596815.
fastq
cb_2wk_ip
_rep2.bam

15
GSM4493797 2-week-old
hypothalamus
Synaptic systems
m6A antibody
RNAseq_2wk_ hypothalamus
_m6AIP_rep2
SRR11596819 SRR11596819.
fastq
hth_2wk_ip
_rep2.bam
16
GSM4493798 2-week-old
hypothalamus
None
RNAseq_2wk_ hypothalamus
_input_rep2
SRR11596820 SRR11596820.
fastq
hth_2wk_input
_rep2.bam
Here in sample titles, “2wk_cerebellum,” “6wk_cerebellum,” “2wk_hypothalamus,” and “6wk_ hypothalamus” stands, respectively, for 2- and 6-week-old mouse brain
cerebellum and hypothalamus samples; “m6AIP,” “input” stands for IP and input control samples; “rep1” and “rep2” stands for ﬁrst and second replicate, respectively. Their
corresponding name of BAM ﬁles is shown in the last column
12
GSM4493794 2-week-old
cerebellum
None
RNAseq_2wk_cerebellum_input_rep2
SRR11596816 SRR11596816.
fastq
cb_2wk_input
_rep2.bam
13
GSM4493795 2-week-old
hypothalamus
Synaptic systems
m6A antibody
RNAseq_2wk_ hypothalamus
m6AIP_rep1
SRR11596817 SRR11596817.
fastq
hth_2wk_ip
_rep1.bam
14
GSM4493796 2-week-old
hypothalamus
None
RNAseq_2wk_ hypothalamus
_input_rep1
SRR11596818 SRR11596818.
fastq
hth_2wk_input
_rep1.bam
m6A Sequencing Data Analysis
167

168
Zhenxing Guo et al.
and 6-week-old samples from both mouse cerebellum and hypo-
thalamus regions. For example, the name of ﬁles for 6-week-old
cerebellum samples contain character “6wk_cerebellum,” with
additional characters “m6AIP,” “input” indicating IP, input con-
trol data, respectively (see Note 1). Pay attention to the sample
replicate number to make sure that the IP and input control data
are paired for each replicate. As the raw data ﬁles are usually very
big, we recommend to download them using the tool fasterq-dump
in command lines in terminal (see Note 2), which will save the
sequencing reads into “.fastq” ﬁles.
Because TRESS takes “.bam” ﬁles as input for each sample, one
should ﬁrst conduct sequencing alignment to generate bam ﬁles
from fastq ﬁles (see Note 3). In addition to bam ﬁles, TRESS also
requires the genome annotation ﬁle saved as “.sqlite” to provide
genomic positions of each m6A region. It can be created from the “.
gtf” ﬁle of that genome downloaded using Table Browser of UCSC
Genome Browser (see Note 4).
3.2
Prepare R
Environment
1. Install R language.
At the R language webpage (https://cran.r-project.org/),
choose your computing platform (Linux/Mac/Windows) and
follow the instructions on the webpage to install R.
2. Install TRESS and dependency packages.
Go to the Bioconductor software package page for TRESS
at https://bioconductor.org/packages/release/bioc/html/
TRESS.html
Follow the instructions from the “installation” section on
this page and install TRESS by entering the three lines of code
given (see Note 5).
3. Set working directory and load software.
First, set your R working directory to the absolute path of
the folder where you stored the “.bam” ﬁles and genome
annotation “.sqlite” ﬁle. For example, if the location is
“/path/to/my/data,” you can change the working directory
as (see Note 6):
setwd("/path/to/my/data")
Since TRESS is already installed, enter the following in R
to load the package to your current working environment.
library(TRESS)
3.3
Conduct Peak
Calling Analysis
Peak calling in TRESS is performed using one wrapper function
TRESS_peak, which mainly performs the following two steps to call
peaks:

m6A Sequencing Data Analysis
169
1. Divide the whole genome into equal-sized bins, and obtain
candidate m6A regions based on bin-level data (see Note 7)
2. Call m6A peaks among candidate regions (see Note 8).
Step 2 is designed for MeRIP-seq data with multiple replicates.
For data with only one replicate, candidate regions from step 1 will
be output as the ﬁnal list of peaks if they are signiﬁcant according to
binomial tests (see Note 9).
“mm9_UCSCknowngenes.sqlite”. .
Suppose we are interested in identifying transcriptome-wide
signiﬁcantly methylated m6A regions from two mouse brain cere-
bellum samples. Each sample consists of a pair of IP and input data.
One mouse genome annotation ﬁle we obtained through Subhead-
ing 3.1 is named as “
” Peak call-
ing in TRESS can be done through:
### organize data files
Input.file = c("cb_6wk_input_rep1.bam", "cb_6wk_input_rep2.bam")
IP.file = c("cb_6wk_ip_rep1.bam", "cb_6wk_ip_rep2.bam")
annoFile = "mm9_UCSCknowngenes.sqlite"
### Call peaks
TRESS_peak(IP.file = IP.file, Input.file = Input.file, 
Path_To_AnnoSqlite = annoFile, 
InputDir = getwd(),
OutputDir = "/path/to/output",
experiment_name = "cb_6wk")
Here,
(a)
“cb_6wk_input_rep1.bam” and “cb_6wk_input_rep2.bam”
are the data of two input replicates from 6-week-old mouse
cerebellum
samples.
“cb_6wk_ip_rep1.bam,”
“cb_6wk
_ip_rep2.bam” are the corresponding two replicates of IP
samples. They are paired in the speciﬁed order and are the
output of a particular sequencing alignment tool such as
Bowtie2.
InputDir = getwd()
(b)
“
” means that the required data are stored in
the current working directory. This is because you already
speciﬁed the working directory to where the data are stored
in Subheading 3.4.
OutputDir = "/path/to/output"
(c)
“
” speciﬁes an absolute path to
save the results. If OutputDir is not speciﬁed, no results will
be saved.
experiment_name = "cb_6wk"
(d)
“
” names the results from this
data as “cb_6wk.” You can change it depending on the
dataset.
By default, TRESS combines FDR and fold change as a crite-
rion to call peaks. Candidate regions with FDR < 0.05 and fold

170
Zhenxing Guo et al.
Fig. 2 An example output of the ﬁrst several lines of detected peaks
change greater than 2 are identiﬁed as signiﬁcant ones. Alternative
settings for deﬁning signiﬁcance can also be imposed (see Note 10).
Running the following code will show the ﬁrst few lines of m6A
peaks (about their locations and statistical inferences) as shown in
Fig. 2:
peaks = read.table(paste0("/path/to/output", "/",  "cb_6wk _peaks.xls"), 
sep = "\t", header = TRUE)
head(peaks[, c("chr", "start", "end", "strand", "mu", "stats", "pvals", "p.adj", "rScore")])
The peak results are sorted by the statistic rScore (see Note 11).
In addition to m6A peak saved in an “.xls” ﬁle (e.g., “cb_6wk
_peaks.xls”), information on bin-level read counts and their geno-
mic coordinates (see Note 7) are also saved as an R “.rda” object
(e.g., “cb_6wk_BinsAndCounts.rda”), which will be used for visu-
alization in Subheading 3.4.
3.4
Visualization of
Individual Peaks
With pre-called peaks, one can visualize them using function Sho-
wOnePeak in TRESS. The usage of this function is
ShowOnePeak(onePeak, allBins, binCounts)
In order to run this function, one needs to have:
1. “onePeak”: a pre-called peak saved as an R data.frame, which
contains genomic positions for that peak: “chr,” “start,”
“end,” “strand”;
2. “allBins”: genomic positions (“chr,” “start,” “end,” “strand”)
of all bins.
3. “binCounts”: the corresponding bin-level read counts in each
replicate of paired input and IP sample.
We show some example plots using the following codes, assum-
ing the peaks were called by TRESS for the 6-week-old mouse brain
cerebellum samples using two replicates.
load(paste0("/path/to/output", "/", "cb_6wk_BinsAndCounts.rda"))
allBins = as.data.frame(bins$bins)
colnames(allBins)[1] = "chr"
ShowOnePeak(onePeak = peaks[1,], allBins = allBins, binCounts = allCounts)
The resulting ﬁgure is shown in Fig. 3:

87
m6A Sequencing Data Analysis
171
Replicate 1
138109000
138109500
138110000
138110500
0.0
0.2
0.4
0.6
0.8
1.0
chr2
methyl%
0
47
94
141
Input read depth
Replicate 2
138109000
138109500
138110000
138110500
0.0
0.2
0.4
0.6
0.8
1.0
chr2
methyl%
0
47
94
141
187
Input read depth
1
Fig. 3 Visualization of one detected m6A peak
The ﬁgure displays the methylation levels (blue bars) as well as
sequencing coverage depth information (curves in grey). The pink-
shaded area is the detected m6A regions. Similarly, other peaks
can be visualized by specifying their row index from peaks in the
ShowOnePeak function (see Note 12).
TRESS_peak,
Unlike peak calling that implements all steps in one function
TRESS separates the model ﬁtting, which is the

Here,
172
Zhenxing Guo et al.
3.5
Conduct
Differential Peak
Calling Analysis
TRESS_DMRfit,
TRESS_DMRtest.
most computationally heavy part, from the hypothesis testing in the
differential m6A analysis. The model ﬁtting is implemented in
while the hypothesis testing is implemented in
Given an experimental design with multiple fac-
tors, the parameter estimation (model ﬁtting) only needs to be
performed once, and then the hypothesis testing for DMR calling
can be performed for different factors, which greater improved
computationally efﬁciency compared to other methods.
(A) m6A DM analysis in two-group comparison
Here, we demonstrate the procedure to ﬁnd m6A DMRs
in a two-group comparison. Suppose we are interested in
ﬁnding the m6A DMRs exhibiting differential methylation
between 2- and 6-week-old mouse brain cerebellum samples.
We have two IP and input replicates for samples at each time
point.
1. Prepare required ﬁles for TRESS_DMRﬁt use.
Input.file = c("cb_2wk_input_rep1.bam","cb_2wk_input_rep1.bam",
"cb_6wk_input_rep1.bam", "cb_6wk_input_rep2.bam")
IP.file = c("cb_2wk_ip_rep1.bam", "cb_2wk_ip_rep1.bam", 
"cb_6wk_ip_rep1.bam", "cb_6wk_ip_rep2.bam")
annoFile = "mm9_UCSCknowngenes.sqlite"
variable = data.frame(predictor = rep(c("Week2", "Week6"), c(2, 2)))
model = ~1+predictor
(a)
“cb_2wk_input_rep1.bam”
and
“cb_2wk_inpu-
t_rep2.bam” are the data of two input replicates
from
2-week-old
mouse
cerebellum
samples.
“cb_2wk_ip_rep1.bam,”
“cb_2wk
_ip_rep2.bam”
are the corresponding two replicates of IP samples.
variable 
Input.file
IP.file.
(b)
provides for each sample their condition
information deﬁned by all factors in the study. For
all factors, the listed order of each sample must be
exactly the same as that in
or
model
variable,
(c)
provides a linear formula of all factors, which,
together with
create a numerical design
matrix for model ﬁtting and hypothesis testing (see
Note 13).

m6A Sequencing Data Analysis
173
2. Conduct linear model ﬁtting using TRESS_DMRﬁt func-
tion
DMR.fit = TRESS_DMRfit(IP.file = IP.file,
Input.file = Input.file,
Path_To_AnnoSqlite = annoFile,
variable = variable,
model = model,
InputDir = getwd(),
OutputDir = "path/to/output",
experimentName = "cb6wkvs2wk")
3. Perform statistical test for DMR by using TRESS_DMRt-
est function.
DMR.test = TRESS_DMRtest(DMR = DMR.fit, contrast = c(0, 1))
contrast 
contrast = c(0, 1) 
Here,
requires a vector of contrast to test a
linear relationship among all studying factors. Because the
model design includes intercept as the ﬁrst column and
time is the only predicting factor, then
tests if the coefﬁcient of time equal to 0, or, if time signiﬁ-
cantly affects the methylation level of each candidate
region. By default, TRESS calls candidate regions with
FDR < 0.05 as signiﬁcant DMRs. Running the following
code will show the ﬁrst few lines of differential m6A peaks
(about their locations and statistical inferences) as shown
in Fig. 4:
load(paste0(OutputDir, "/", "cb6wkvs2wk_Candidates.rda"))
res = cbind(Candidates$Regions[, c("chr", "start", "end", "strand")],  DMR.test)
res = res[ order(abs(res$stat), decreasing = TRUE), ]
DMRS = res[which(res$padj < 0.05), ]
head(DMRS)
4. DMR visualization
Similar to peak visualization, the DMRs can also be
visualized using showOnePeak function, if needed.
With the inference result of each candidate region
available in the object DMR.test obtained in step (3) and
bin-level and candidate-level data generated in step (2),
one can visualize individual DMRs by running the follow-
ing codes.
Fig. 4 An example output of the ﬁrst several lines of detected differential m6A peaks

da"))
174
Zhenxing Guo et al.
(a)
Load in bin-level and candidate-level data
load(paste0(OutputDir, "/", "cb6wkvs2wk_BinsAndCounts.r
load(paste0(OutputDir, "/", "cb6wkvs2wk_Candidates.rda"))
Bins = as.data.frame(bins$bins); colnames(Bins)[1] = "chr"
(b)
Obtain DMRs
res
=
cbind(Candidates$Regions[,
c("chr",
"start", "end", "strand")], DMR.test)
res = res[ order(abs(res$stat), decreasing =
TRUE), ]
DMRS = res[which(res$padj < 0.05), ]
(c)
Visualize individual DMR with function ShowOne-
Peak
snames = c("cbwk2_rep1", "cbwk2_rep2", "cbwk6_rep1", "cbwk6_rep2")
ShowOnePeak(onePeak = DMRS[1, ],  
allBins = Bins,
binCounts = allCounts,
isDMR = TRUE,
Sname = snames)
The resulting ﬁgure is shown in Fig. 5:
snames
(isDMR = TRUE).
Here,
provides names for all samples if
the plot is to visualize a DMR
.
model
contrast
(B) m6A DM analysis in experiments with multifactor
As TRESS is designed for studies with complex designs,
DMRs testing in a multifactor design is similar to that in a
regular two-group comparison, with slightly modiﬁed
in function TRESS_DMRﬁt, and the
in function
TRESS_DMRtest.
1. Prepare required ﬁles for TRESS_DMRﬁt use.
Input.file = c( "cb_2wk_input_rep1.bam","cb_2wk_input_rep1.bam",
"cb_6wk_input_rep1.bam", "cb_6wk_input_rep2.bam",
"hth_2wk_input_rep1.bam","hth_2wk_input_rep1.bam",
"hth_6wk_input_rep1.bam", "hth_6wk_input_rep2.bam")
IP.file = c( "cb_2wk_ip_rep1.bam", "cb_2wk_ip_rep1.bam",
"cb_6wk_ip_rep1.bam", "cb_6wk_ip_rep2.bam",
"hth_2wk_ip_rep1.bam", "hth_2wk_ip_rep1.bam", 
"hth_6wk_ip_rep1.bam", "hth_6wk_ip_rep2.bam")

m6A Sequencing Data Analysis
175
cbwk2_rep1
164627200
164627400
164627600
164627800
164628000
164628200
164628400
164628600
0.0
0.2
0.4
0.6
0.8
1.0
chr1
methyl%
0
14
28
42
57
Input read depth
cbwk2_rep2
164627200
164627400
164627600
164627800
164628000
164628200
164628400
164628600
0.0
0.2
0.4
0.6
0.8
1.0
chr1
methyl%
0
14
28
42
57
Input read depth
cbwk6_rep1
164627200
164627400
164627600
164627800
164628000
164628200
164628400
164628600
0.0
0.2
0.4
0.6
0.8
1.0
chr1
methyl%
0
14
28
42
57
Input read depth
cbwk6_rep2
164627200
164627400
164627600
164627800
164628000
164628200
164628400
164628600
0.0
0.2
0.4
0.6
0.8
1.0
chr1
methyl%
0
14
28
42
57
Input read depth
Fig. 5 Visualization of one detected m6A DMR
annoFile = "mm9_UCSCknowngenes.sqlite"
variable = data.frame(time = rep(c("2wk", "6wk"), c(2, 2) ),
region = rep(c("CB", "HTH"), each = 4))
model = ~1+ time + region + time*region
variable
model = ~1+ time + region + time*region 
Here,
contains time and region information for
each sample.
will incorporate both time and region and their interaction
effect into the linear model (see Note 14).

176
Zhenxing Guo et al.
2. Conduct linear model ﬁtting using TRESS_DMRﬁt func-
tion.
DMR.fit = TRESS_DMRfit(IP.file = IP.file,
Input.file = Input.file,
Path_To_AnnoSqlite = annoFile,
variable = variable,
model = model,
InputDir = getwd(),
OutputDir = "path/to/output",
experimentName = "cbhth_6wkvs2wk")
3. Perform statistical test for DMR by using TRESS_DMRt-
est function.
DMR.test = TRESS_DMRtest(DMR = DMR.fit, contrast = c(0, 1, 0, 1))
contrast = c(0, 1, 0, 1) tests DMRs whose methyla-
tion level changes from 2 weeks to 6 weeks within hypo-
thalamus regions. Users can test the effect of factors in
different ways by specify corresponding contrasts accord-
ing to the model design (see Note 15).
4. DMR visualization.
Similarly, use showOnePeak function to visualize a spe-
ciﬁc DMR.
4
Notes
1. The naming convention for IP and input samples can vary
depending on the speciﬁc dataset. For GSE144032, IP samples
are indicated by “m6AIP,” and input control samples are
referred to as “input.” For other studies such as GSE113781
[2], IP and input samples are simply represented by “RIP-seq”
and “RNA-seq,” respectively. One should click one particular
sample to check its detailed experimental description.
2. fasterq-dump is a tool for downloading sequencing reads from
SRA, where the sequence reads will be downloaded as FASTQ
ﬁles. Prior to the run, make sure that the SRR ID of each
sample is correct. An example command is:
fasterq-dump SRR_ID -O /directory/to/save/fastq/files/
This should produce two FASTQ ﬁles (one for R1 and one
for R2) for paired-end sequencing and one FASTQ ﬁle for
single-end sequencing.

m6A Sequencing Data Analysis
177
3. Bowtie2 can be used to conduct sequence alignment given “.
fastq” ﬁles. Prior to performing alignment, one needs to pre-
pare genome index ﬁles ﬁrst. Taking “mm9” genome as an
example:
(I) Build Bowtie2 index ﬁle.
Download genome sequence of “mm9” from UCSC
(http://genome.ucsc.edu/cgi-bin/hgGateway ) and build
index ﬁles in command lines as follows:
wget https://hgdownload.soe.ucsc.edu/goldenPath/mm9/bigZips/chromFa.tar.gz
tar -xf chromFa.tar.gz 
cat *.fa > mm9.fa
bowtie2-build mm9.fa mm9
Then mm9 will be used as the index ﬁle for genome
“mm9.”
(II) Conduct alignment.
Example command lines to run Bowtie2 on single-end
sequencing are:
bowtie2 -p 8 -x /path/to/index/file/mm9
-U /path/to/xxx.fastq  -S 
/path/to/output/xxx.sam
For paired-end sequencing,
bowtie2 -p  8  -x  /path/to/index/file/mm9 -1  /path/to/xxx_R1.fastq  -2  
/path/to/xxx_R2.fastq  -S   /path/to/output/xxx.sam
After alignment, remove results on unknown chromo-
somes by
sed '/chrM/d;/random/d;/chrUn/d' /path/to/output/xxx.sam  >
/path/to/output/xxx_filtered.sam
Then transfer SAM ﬁles into BAM ﬁles to save space
with tool Samtools by
samtools  view  -bS  /path/to/output/xxx_filtered.sam   >  /path/to/output/xxx.bam
Finally, sort and then index “xxx.bam” ﬁles with
samtools sort -@ 8  /path/to/output/xxx.bam -o  /path/to/output/xxx.sorted.bam
samtools index -@ 8 /path/to/output/xxx.sorted.bam
xxx.sorted.bam
File “
” will be used for peak calling in
TRESS.

178
Zhenxing Guo et al.
4. To download a genome annotation ﬁle, go to UCSC
Table Browser https://genome.ucsc.edu/cgi-bin/hgTables
Let us now suppose that we need to download an annota-
tion ﬁle for the mouse genome. For this, we select “Mammal”
for clade, “Mouse” for genome, “mm9” for genome assembly
version, “Genes and Gene Predictions” for gene group,
“UCSC Genes” for gene track, “knownGene” for gene table,
and “genome” for the range of regions. Then select “GTF-
gene transfer format (limited)” for output format. Add a name
such as “mm9_UCSCknowngenes.gtf,” and by clicking “get
output,” an annotation ﬁle for the mouse genome will be
retrieved. For convenience, move ﬁle “mm9_UCSCknown-
genes.gtf” into the same directory where you store the “.
bam” data. With the “.gtf” ﬁle, one can use R function
makeTxDbFromUCSC from package GenomicFeatures to cre-
ate a TxDb object and save it as an “.sqlite” ﬁle as follows:
setwd("/path/to/my/data")
library(GenomicFeatures)
txdb = makeTxDbFromGFF("mm9_UCSCknowngenes.gft ", format = "gtf")
saveDb(txdb, file = “mm9_UCSCknowngenes.sqlite")
5. Install TRESS with the following codes:
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("TRESS")
setwd()
6. The example usage of
is provided for a Unix/Mac
environment. For Windows users, the command might
look like:
setwd("D:/path/to/my/data") 
or
setwd("D:\\path\\to\\my\\data") 
7. This is implemented by sub-functions DivideBins and Call-
Candidates. In particular,
(I) DivideBins function divides the genome into equal-sized
genomic bins and then obtain read counts in each bin from
all “.bam” ﬁles.
Bins = DivideBins(IP.file, Input.file, annoFile, InputDir = getwd(), OutputDir = 
"/path/to/output", experimentName = "Basal")

m6A Sequencing Data Analysis
179
Here “IP.ﬁle,” “Input.ﬁle,” and “annoFile” are the
same as those in Subheading 3.5.
An example of genomic coordinate for equal-sized
bins is:
chr   
start    
end 
width strand
chr1 6238343 6238392    50      +
chr1 6238393 6238442    50      +
chr1 6238443 6238492    50      +
chr1 6238493 6238542    50      +
chr1 6238543 6238592    50      +
chr1 6238593 6238642    50    +
chr1 6238643 6238692    50      +
chr1 6238693 6238742    50      +
chr1 6238743 6238792    50      +
chr1 6238793 6238842    50      + 
An example of bin-level read counts from 2 IP and
input
pairs
of
6-week-old
mouse
brain
cerebellum
samples is:
cb_6wk_input_rep1      cb_6wk_ip_rep1    cb_6wk_input_rep2    cb_6wk_ip_rep2
0                
0                     
0                  
6
7                  
6                     
1                 
13
8                 
10                     2                 
15
10                
23                    
3                 
21
6                 
36                     3                 
23
12                 
34                     3                 
22
17                 
25                     4                 
16
17                 
11                     3                  
7
13                 
27                     4                 
27
6                 
32                     2                 
28
(II) CallCandidates function performs three steps: (1) for each
paired input and IP replicate, conduct binomial test at
each bin; (2) then merge signiﬁcant bins-based binomial
test results to form bumps in each replicate; (3) obtain a
union of bumps from all input and IP pairs to construct a
list of candidate regions.
### Obtain candidate m6A regions given bin-level data
Candidates = CallCandidates(Counts = Bins$binCount, bins = Bins$bins)

180
Zhenxing Guo et al.
An example of genomic coordinates for candidate
regions:
chr    start     end 
strand   
chr1  6230193  6230492    
+  
chr1  6238343  6238642    
+  
chr1  6848562  6848911    
+  
chr1  7162551  7162700     
+  
chr1 17151204 17151353   
+ 
chr1 24822733 24822982   
+ 
chr1  9536339  9536938      
+  
An example of read counts in candidate regions from
2 IP and input pairs is:
cb_6wk_input_rep1 cb_6wk_ip_rep1 cb_6wk_input_rep2 cb_6wk_ip_rep2
28                
126                     
9                
89
43                
109                    
12 
100
87                
305                    
43                
249
37                 
52                     
6                 
70
77                 
83                    
22                
101
43                 
22                    
6                
90
192               
2126                   
114              
513
8. This is implemented by subfunction CallPeaks.multiRep. This
function conducts parameter estimation and hypothesis testing
for each candidate region, based on the assumed hierarchical
negative binomial distribution. Prior to running CallPeaks.
multiRep, one needs to ﬁrst estimate background methylation
levels using TRESS hidden function BgMethylevel in order to
construct Wald test statistics. An example is:
### Estimate background m6A level 
bg.mu = TRESS:::BgMethylevel(CandidCounts = Candidates$Counts, 
BinCounts=Bins$binCount)
### Call peaks 
Peaks = CallPeaks.multiRep(Candidates, mu.cutoff = bg.mu)
Here, mu.cutoff speciﬁes the estimated background meth-
ylation level.
9. For data with only one replicate, TRESS_peak calls the
sub-function
CallPeaks.oneRep
to
detect
peaks,
given
bin-level read count and genomic positions.
Peaks = CallPeaks.oneRep(Counts = Bins$binCount[, 1:2], bins = Bins$bins, sf = 
colSums(Bins$binCount[,1:2])/median(colSums(Bins$binCount[, 1:2])))
Here, only the ﬁrst paired Input and IP replicate is used. sf
is a vector of size factor for input control and IP samples, where

m6A Sequencing Data Analysis
181
the order of input and IP samples aligns with that in counts
matrix. sf is estimated based on the total bin-level read counts
in each sample and is used for sequencing depth normalization.
10. Different criteria for signiﬁcance are available in TRESS to ﬁlter
peaks based on results of Wald tests, including p-values, FDR,
and log fold change (logFC). One needs to ﬁrst specify a
criterion through argument WhichThreshold of TRESS_peak
and then provide a cutoff for that criterion through one or
two arguments with sufﬁx “*.cutoff.”
WhichThreshold = "fdr_lfc"
WhichThreshold = "fdr_lfc"
fdr.cutoff = 0.01
lfc.cutoff = 1.6
By default, TRESS combines FDR and logFC (with
) to select peaks. The default cut-
offs for FDR and logFC are 0.05 and 0.7 (for fold change of 2),
meaning that peaks with FDR < 0.05 and logFC > 0.7 will be
kept. With
, one can change the
cutoffs to more stringent values, for example, FDR < 0.01
and
logFC
>
1.6
by
setting
and
.
WhichThreshold = "fdr"
? TRESS_peak
One can also set
to select peaks
only based on FDR. Then by default, peaks with FDR < 0.05
will be kept. See man page of function TRESS_peak by
for more details.
11. Instead of Wald test statistics, TRESS ranks peaks using rScore,
which is calculated as follows
bμi - bμ
c
SE bμi
ð
Þ
Here, bμi is estimated methylation at region i; bμ
is the
average of all bμi. c
SE bμi
ð
Þ is the estimated standard error of bμi.
Compared to Wald test statistics, rScore prefers peaks whose
methylation level is signiﬁcantly higher than the average of all
candidate regions, which provides more biologically meaning-
ful peak ranks.
12. Instead of directly showing the ﬁgure in R terminal, one can
use the following to save the ﬁgure to a PDF ﬁle:
pdf("onePeak.pdf", width = 9, height = 12)
ShowOnePeak(onePeak = peaks[1,], allBins = allBins, binCounts = allCounts)
dev.off()
The width and height specify the graphics region in inches
for the output pdf.
model.matrix(model, variable) 
13. The numerical design matrix in the regression determined by
is
(Intercept) predictorWeek6
1            0
1            0
1            1
1            1

182
Zhenxing Guo et al.
14. Here the sample information for each variable is
time      region
2wk     CB
2wk     CB
2wk    HTH
2wk    HTH
6wk     CB
6wk     CB
6wk    HTH
6wk    HTH
model.matrix(model, variable)
The
numerical
design
in
regression
determined
by
is
(Intercept) time6wk regionHTH time6wk:regionHTH
1      
0         
0                 
0
1       
0         
0                 
0
1      
1
0
0
1      
1
0
0
1      
0
1
0
1      
0
1
0
1      
1         
1                 
1
1       
1         
1                 
1
contrast = c(0, 1, 0, 0),
c(0,1,0,1)
contrast = c(0, 0, 0, 1)
15. Based on the design matrix in Note 14,
tests, respectively, the time effect within the cerebel-
lum
and
hypothalamus
regions.
On
the
other
hand,
tests if the fourth coefﬁcient equal to
0, or, if time and region interaction signiﬁcantly affects the
methylation level of each candidate region.
References
1. Dominissini
D,
Moshitch-Moshkovitz
S,
Schwartz S, Salmon-Divon M, Ungar L,
Osenberg S, Cesarkas K, Jacob-Hirsch J,
Amariglio N, Kupiec M, Others (2012) Topol-
ogy of the human and mouse m 6 a rna methy-
lomes
revealed
by
m
6
a-seq.
Nature
485(7397):201–206. https://doi.org/10.
1038/nature11112
2. Engel M, Eggert C, Kaplick MP, Eder M,
Roh S, Tietze L, Namendorf C, Arloth J,
Weber P, Rex-Haffner M, Others (2018) The
role
of
m6a/m-rna
methylation
in
stress
response regulation. Neuron 99(2):389–403.
https://doi.org/10.1016/j.neuron.2018.
07.009
3. Lan Q, Liu P, Haase J, Bell JL, Hu¨ttelmaier S
and Liu T. (2019) The critical role of rna m6a
methylation in cancer. Cancer research 79(7):
1285–1292.
https://doi.org/10.1158/
0008-5472.CAN-18-2965
4. Lin X, Chai G, Wu Y, Li J, Chen F, Liu J,
Luo G, Tauler J, Du J, Lin S, others (2019)
RNA m6A methylation regulates the epithelial
mesenchymal transition of cancer cells and
translation of snail. Nature communications
10(1):1–13.
https://doi.org/10.1038/
s41467-019-09865-9
5. Johnson DS, Mortazavi A, Myers RM, Wold B
(2007) Genome-wide mapping of in vivo
protein-dna interactions. Science 316(5830):
1497–1502. https://doi.org/10.1126/sci
ence.1141319
6. Dai Q, Fong R, Saikia M, Stephenson D, Yu Y,
Pan T, Piccirilli JA (2007) Identiﬁcation of
recognition residues for ligation- based detec-
tion and quantitation of pseudouridine and n

m6A Sequencing Data Analysis
183
6-methyladenosine. Nucleic Acids Research
35(18):6322–6329. https://doi.org/10.
1093/nar/gkm657
7. Meng J, Cui X, Rao MK, Chen Y, Huang Y
(2013) Exome-based analysis for rna epigen-
ome sequencing data. Bioinformatics 29(12):
1565–1567. https://doi.org/10.1093/bioin
formatics/btt171
8. Cui X, Meng J, Zhang S, Chen Y, Huang Y
(2016) A novel algorithm for calling mrna m
6 a peaks by modeling biological variances in
merip-seq data. Bioinformatics 32(12):i378–
i385
9. Zhang M, Li Q, Xie Y (2018) A bayesian hier-
archical model for analyzing methylated rna
immunoprecipitation sequencing data. Quan-
titative Biology 6(3):275–286. https://doi.
org/10.1007/s40484-018-0149-2
10. Cui X, Zhang L, Meng J, Rao MK, Chen Y,
Huang Y (2015) Metdiff: a novel differential
rna methylation analysis for merip-seq data.
IEEE/ACM transactions on computational
biology and bioinformatics 15(2):526–534.
https://doi.org/10.1109/TCBB.2015.
2403355
11. Liu
L,
Zhang
S-W,
Huang
Y,
Meng
J
(2017) Qnb: differential rna methylation anal-
ysis for count-based small-sample sequencing
data with a quad-negative binomial model.
BMC bioinformatics 18:1–12
12. Zhang
Z,
Zhan
Q,
Eckert
M,
Zhu
A,
Chryplewicz A, De Jesus DF, Ren D, Kulkarni
RN, Lengyel E, He C et al (2019) Radar: dif-
ferential analysis of merip-seq data with a ran-
dom effect model. Genome biology 20:1–17
13. Guo Z, Shaﬁk AM, Jin P, Wu Z, Wu H (2021)
Detecting
m6a
methylation
regions
from
methylated rna immunoprecipitation sequenc-
ing.
Bioinformatics
37(18):2818–2824.
https://doi.org/10.1093/bioinformatics/
btab181
14. Shaﬁk AM, Zhang F, Guo Z, Dai Q, Pajdzik K,
Li Y, Kang Y, Yao B, Wu H, He C, others
(2021) N6-methyladenosine dynamics in neu-
rodevelopment and aging, and its potential role
in alzheimer’s disease. Genome Biology 22(1):
1–19. https://doi.org/10.1186/s13059-020-
02249-z

Chapter 13
Nanopore Direct RNA Sequencing Data Processing
and Analysis Using MasterOfPores
Luca Cozzuto, Anna Delgado-Tejedor, Toni Hermoso Pulido,
Eva Maria Novoa, and Julia Ponomarenko
Abstract
This chapter describes MasterOfPores v.2 (MoP2), an open-source suite of pipelines for processing and
analyzing direct RNA Oxford Nanopore sequencing data. The MoP2 relies on the Nextﬂow DSL2
framework and Linux containers, thus enabling reproducible data analysis in transcriptomic and epitran-
scriptomic studies. We introduce the key concepts of MoP2 and provide a step-by-step fully reproducible
and complete example of how to use the workﬂow for the analysis of S. cerevisiae total RNA samples
sequenced using MinION ﬂowcells. The workﬂow starts with the pre-processing of raw FAST5 ﬁles, which
includes basecalling, read quality control, demultiplexing, ﬁltering, mapping, estimation of per-gene/
transcript abundances, and transcriptome assembly, with support of the GPU computing for the basecalling
and read demultiplexing steps. The secondary analyses of the workﬂow focus on the estimation of RNA poly
(A) tail lengths and the identiﬁcation of RNA modiﬁcations. The MoP2 code is available at https://github.
com/biocorecrg/MOP2 and is distributed under the MIT license.
Key words Data analysis, Nanopore sequencing, Direct RNA sequencing, RNA modiﬁcations,
Reproducible science, Workﬂows, Open source, Nextﬂow
1
Introduction
Oxford Nanopore Technologies (ONT) have revolutionized the
ﬁeld of epigenomics and epitranscriptomics [1]. Nanopore cDNA
sequencing has been applied to obtain improved genome assem-
blies [2], accurate identiﬁcation of structural variants [3], and high-
resolution HLA typing [4], among others. On the other hand, the
direct RNA sequencing (dRNA-seq) on the ONT platform has
open unprecedented opportunities in epitranscriptomics studies
and has been applied to 3′ poly(A) tail length estimation [5–7],
accurate transcriptome proﬁling [8, 9], identiﬁcation of novel
Authors Luca Cozzuto and Anna Delgado-Tejedor have equally contributed to this chapter.
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_13,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
185

186
Luca Cozzuto et al.
isoforms [10–12], and direct identiﬁcation of a wide range of RNA
modiﬁcations [13–18].
RNA modiﬁcations, which are collectively referred to as the
“epitranscriptome,” are reversible changes to the chemical compo-
sition of RNA molecules post-synthesis. They have been observed
in mRNA, tRNA, rRNA, microRNA, snoRNA, and lncRNA and
have been shown to affect mRNA splicing [19], localization [20],
translational efﬁciency [21], regulation of gene expression [22],
and RNA structure and stability [23]. RNA modiﬁcations play
regulatory roles in determining cellular fate and differentiation
[24], sex determination [25], and immune responses [26] and
have been linked with many human diseases [27], including devel-
opmental [28] and neurological disorders, diabetes, and cancer
[29, 30].
The genomes of RNA viruses also carry RNA modiﬁcations
that play a role in virus-host interactions by mediating the viral and
host gene expression during virus infection [31, 32]. For example,
HIV-1 and the model animal retrovirus MLV are known to use the
RNA modiﬁcation machinery from the host cell to modify their
RNA [33], while some viruses, such as SARS-CoV-2, encode for
their own methyltransferase RNA-modifying enzyme that places an
RNA modiﬁcation near the cap structure of the viral RNA molecule
[32,
34].
As
a
consequence,
RNA
modiﬁcations
and
RNA-modifying enzymes could serve as targets for antiviral thera-
pies to decrease the rate of viral protein production. In this regard,
depletion of METTL3, which is responsible for placing m6A RNA
modiﬁcations in mRNAs [32, 35], is known to decrease the repro-
duction rate of some viral infections, such as Epstein-Barr [36],
HIV, or KHSV [37].
Hundreds of different RNA modiﬁcations have been identiﬁed
so far. However, their systematic studies have only started to
become possible recently with the advent of nanopore sequencing.
The accessibility and affordability of the Oxford Nanopore
sequencing platform make it a primary choice for studies
concerning epigenomics and epitranscriptomics. However, the
large amount of data that ONT instruments produce as output
puts a high demand on both computational resources and bioin-
formatics expertise in nanopore data management and analysis.
Workﬂow management systems, such as Snakemake [38],
Nextﬂow [39], Common Workﬂow Language [40], and Galaxy
[41], together with Linux containers, offer a solution to efﬁcient
and reproducible analysis of large datasets. The MoP software [42]
has been implemented using Nextﬂow [39]. The ability of Next-
ﬂow to support different batch schedulers (SGE, LSF, SLURM,
PBS, and HTCondor), cloud platforms (Kubernetes, Amazon
AWS, and Google Cloud), and GPU computing is critical for
processing nanopore sequencing big data. Nextﬂow has also tight

Nanopore dRNA-Seq Data Analysis Using MasterOfPores
187
Fig. 1 Overview of the MasterOfPores2 NextFlow workﬂow. (a) Modules of the MoP2 workﬂow for data
pre-processing and analysis of direct RNA sequencing datasets. (b) Steps performed in each of the MoP2
modules, including the software that are available to perform each of the steps in the modules
integration with the Linux containers, such as Docker and
Singularity.
Here, we present an upgraded version of the MasterOfPores
(MoP) software [42], MoP2, which has been implemented using
the Nextﬂow DSL2 [43] and has been expanded with new tools
and modules (Fig. 1). Speciﬁcally, we now provide the following
pipelines and improvements: (i) an upgraded module for RNA
modiﬁcation prediction that runs in parallel four different combi-
nations of tools to predict RNA modiﬁcations, (ii) a dedicated
module for predicting the consensus of the RNA modiﬁcation
calls based on the predictions of the four different approaches,
(iii) option for de novo transcriptome assembly within the
pre-processing
module,
(iv)
option
to
start
the
data
pre-processing not only from the raw FAST5 ﬁles but also from
FASTQ ﬁles, and (v) generation of output ﬁles that show the
association between read identiﬁer (readID) and transcript identi-
ﬁer (transcriptID). Moreover, in addition to dRNA-seq, our MoP2
workﬂow can now analyze demultiplexed FASTQ ﬁles from cDNA
nanopore sequencing experiments using the pre-processing mod-
ule, which includes read quality control, trimming, ﬁltering,
mapping, estimation of per-gene/transcript abundances, and tran-
scriptome assembly. The executables required by MoP2 are bun-
dled within the Docker images that are accessible in DockerHub
and can be converted on-the-ﬂy into a Singularity image, thus
allowing running MoP2 on both HPC and Cloud environments.

188
Luca Cozzuto et al.
2
Materials
2.1
Nanopore
Sequencing Test
Datasets: Total RNA
from Wild Type and
snoRNA-depleted S.
cerevisiae Strains
The MoP2 workﬂow below is demonstrated using the output of the
direct RNA sequencing experiments that include total RNA from
diverse yeast strains depleted in snoRNAs guiding either pseudour-
idine (Y) or 2-O-methylated (Nm) rRNA modiﬁcations [44]. The
samples were barcoded using the DeePlexiCon strategy [45] and
sequenced using MinION devices. In Flowcell 1, wild type
(WT) and the three different snoRNA-depleted strains lacking
pseudouridine (pU mutants) were sequenced, and in Flowcell
2, WT and three different snoRNA-depleted strains lacking 2-O-
methylations in three different sites (Nm mutants) were sequenced.
The FAST5 ﬁles are available in the European Nucleotide Archive
(pU samples ERR5296640 and Nm samples ERR5303454). Both
runs were analyzed and demultiplexed producing four samples
per run:
BC_1 BC_2 BC_3 BC_4
pU snR3 KO snR34 KO snR36 KO WT
Nm WT snR60 KO snR61 KO snR62 KO
After the demultiplexing, the following number of reads for
each sample was obtained (in thousands):
BC_1 BC_2 BC_3 BC_4 Unclassified
pU 144.6 67.0 112.2 91.0 11.3
Nm 113.8 247.3 320.7 310.0 19.1
1. Data can be downloaded using wget, curl, or other tools. For
example, to download the pU samples, use the command:
wget
ftp://ftp.sra.ebi.ac.uk/vol1/run/ERR529/ERR5296640/
RNA814001.fast5.tar.gz
and to download the Nm samples:
wget
ftp://ftp.sra.ebi.ac.uk/vol1/run/ERR530/ERR5303454/
RNA345944.fast5.tar.gz

Nanopore dRNA-Seq Data Analysis Using MasterOfPores
189
2. Data can be also downloaded manually from the ENA web-
page: https://www.ebi.ac.uk/ena/browser/home:
1. Go to Search tab.
2. Enter the accession number in the searcher (ERR5296640
for pU samples; ERR5303454 for Nm samples).
3. Enter the browser for the selected run.
4. Download the tar ﬁle containing raw data.
3. Uncompress ﬁles using the commands:
tar xvfz RNA814001.fast5.tar.gz .
tar xvfz RNA345944.fast5.tar.gz .
2.2
Required
Infrastructure to Run
MoP2 on the Yeast
Dataset
To run each yeast dataset, the minimal hardware requirement is
70 GB of RAM and at least 10 compute nodes (8 CPUs each). The
required software is either Docker v.20.10.8 (or later) or Singular-
ity v. 3.2.1 (or later).
The most computationally intensive parts of the software are
basecalling from FAST5 ﬁles and sample demultiplexing. There-
fore, the mop_preprocess pipeline’s steps of basecalling and demulti-
plexing beneﬁt enormously from using the GPU cards, with one
GPU being equivalent in computational time to 50–100 compute
nodes of 8 CPUs each. For example, using MoP1, the runtime of
the pre-processing pipeline per 1000 reads using 100 nodes
(8 CPUs each) took 133 min while using one GPU GIGABYTE
RTX 1660 Ti card, 404 min, and using one GPU INNO3D
GeForce RTX 2080 card, 68 min [42].
A small test set of two samples with a single FAST5 ﬁle with
500 reads each is provided along with the software; it can be used
for testing the workﬂow on a laptop with 16 GB RAM and Docker
installed.
2.3
Software
Installation
1. To install MoP2, use the following git command:
git clone --depth 1 --recurse-submodules https://github.com/
biocorecrg/MOP2.git
This will download the whole code and a library of the Next-
ﬂow sub-workﬂows from BioNextﬂow [46].
2. Because the Guppy software for basecalling of FAST5 ﬁle
cannot be bundled within a Docker image, we provide a helper
script, INSTALL.sh, that downloads the program from the
ONT website and places it in a binary folder, which will be
automatically mounted by Nextﬂow when the pipeline is
launched. To install Guppy version 3.4.5. (default) use the
command:

cd MoP2; sh INSTALL.sh
190
Luca Cozzuto et al.
To install a different Guppy version (see Note 1), for example,
4.0.15, provide it as a parameter:
cd MoP2; sh INSTALL.sh 4.0.15
3
Methods
3.1
Tuning the
Pipeline Parameters
The ﬁle params.conﬁg provides the Nextﬂow parameters, which
also include software and tools. Most of the tools used in the
pipelines can be turned on/off by specifying in params.conﬁg either
the name of the tool or selecting “NO.”
The command line parameters for each tool can be speciﬁed in
a separate tab-separated ﬁle. In particular, we provide four preset
combinations, for analyses of cDNA-seq, DNA-seq, and dRNA-seq
spliced and dRNA-seq unspliced, in the ﬁles cdna_tool_opt.tsv,
dna_tool_opt.tsv, drna_tool_splice_opt.tsv, and drna_tool_unspli-
ce_opt.tsv, respectively. For both test datasets described here, the
following should be speciﬁed in params.conﬁg:
pars_tools = "drna_tool_unsplice_opt.tsv"
If GPU is used, turn the parameter GPU on “ON.”
Specify also the transcriptome reference, email, and output
folder.
To run the pipelines on the small test set provided with the
MoP2 software, the only parameter that needs to be changed is the
email address.
To run the pipelines on the published yeast datasets, for the
demultiplexing step to be performed, in the ﬁle ./mop_preprocess/
params.conﬁg, the parameter “demulti_fast5” has to be set to
“YES.” The input FAST5 ﬁles should be placed in different folders
corresponding to each sample and speciﬁed in the params.conﬁg
ﬁle as:
fast5 = "PATH_TO_FAST5/**/*.fast5"
The folder matching the double asterisks should indicate the
name of the sample, and PATH_TO_FAST5 should be replaced
with the speciﬁc path where your samples are located. For example,
to reproduce the analyses described below on the yeast dataset,
place
the
downloaded
FAST5
ﬁles
in
two
folders,
each
corresponding to one MinION run (pU and Nm, respectively);
copy the params.conﬁg.test into params.conﬁg; and edit the fast5
parameter.

Nanopore dRNA-Seq Data Analysis Using MasterOfPores
191
3.2
Running MoP2
Pipelines
Different proﬁles to run the pipelines locally, on HPC or Cloud, are
speciﬁed in the folder MOP2/conf.
Below, as an example, we provide command lines for running
the mop_preprocess pipeline, provided in the ﬁle ./mop_preprocess/
mop_preprocess.nf, using the parameters speciﬁed in params.conﬁg.
•
If MoP2 is installed on a local machine with Docker installed,
run it typing the following command:
cd mop_preprocess
nextflow run mop_preprocess.nf -with-docker -bg -profile local
> log
•
To run the pipeline on the HPC (SGE) with singularity installed,
use the command:
cd mop_preprocess
nextflow run mop_preprocess.nf -with-singularity -bg -profile
sge > log
•
To run the pipeline on the AWS Batch cloud computing envi-
ronment, use the command:
cd mop_preprocess
nextflow run mop_preprocess.nf -with-docker -bg -profile aws-
batch > log
See Note 2 for a step-by-step guide on how to set up an AWS
infrastructure.
3.3
Mop_preprocess:
Pre-processing of
FAST5 or FASTQ Files
The ﬁrst pipeline of the workﬂow (Fig. 1) is called mop_preprocess
(Fig. 2). It takes as an input FAST5 or basecalled FASTQ. If the
secondary analyses of estimation of RNA poly(A) tail lengths and
the identiﬁcation of RNA modiﬁcations are not needed, FASTQ
ﬁles can be used as an input. The output of mop_preprocess is used as
input of the pipelines mop_tail and mop_mod (Fig. 2).
3.3.1
Mop_preprocess
Steps
The pipeline performs the following steps:
1. Read basecalling using Guppy, a basecaller provided by ONT.
This step can be run in parallel, and the user can decide the
number of ﬁles to be processed in a single job by using the
command –granularity in the ﬁle params.conﬁg. This step can
be run using GPU cards as well.
2. Demultiplexing of the reads using DeePlexiCon [45]. This step
is optional and can be used only if the libraries have been
barcoded with the oligonucleotides used to train the deep
neural classiﬁer [45]. This step can be run using GPU cards
as well.

192
Luca Cozzuto et al.
Fig. 2 Scheme of the individual steps performed, inputs and outputs of each module included in Master-
OfPores2. The inputs required by each module are depicted in green, whereas the ﬁnal outputs generated by
each module are shown in blue. (a) Input and outputs of mop_preprocess. (b) Input and outputs of mop_tail.
(c) Input and outputs of mop_mod. (d) Input and outputs of mop_consensus
3. Filtering of the resulting FASTQ ﬁles using either NanoFilt
[47] or nanoq [48]. This step is optional and can be run in
parallel.
4. Quality control of the basecalled data, using MinIONQC [49]
and FastQC [50].
5. Read mapping to a reference genome or transcriptome, using
minimap2 [51], graphmap, or graphmap2 [52].
6. Quality control on the alignment, using NanoPlot [47] and
bam2stats [53].
7. Conversion of BAM ﬁles into CRAM format, with or without
subsampling, with automatic calculation of corresponding
indexe(s) for each sample. These ﬁles can be used for exploring
alignments in a genome browser.
8. Gene or transcript quantiﬁcation, using HTSeq [54] or Nano-
Count [55]. The latter estimates transcript abundance using an
expectation-maximization algorithm. NanoCount can be run if

Nanopore dRNA-Seq Data Analysis Using MasterOfPores
193
reads have been mapped to the transcriptome, using the ﬂag –
reference_type transcriptome, whereas HTSeq can be employed
to quantify per-gene counts if the reads have been mapped to
the genome.
9. De novo transcriptome assembly, using bambu [56]. Optional.
10. Final report of the data processing using multiQC [57] that
combines the single quality controls done previously, as well as
global run statistics (Fig. 3).
3.3.2
Mop_preprocess
Conﬁguration and Running
Refer to Subheadings 3.1 and 3.2 above.
3.3.3
Mop_preprocess
Output
The pipeline outputs the following folders (for the embedded test
dataset, see the ﬁle ./mop_preprocess/output.example.tar.gz):
•
fast5_ﬁles: Contains one folder per sample, or for demulti-
plexed samples, basecalled FAST5 ﬁle(s) using Guppy.
•
fastq_ﬁles: FASTQ ﬁle(s) corresponding to each sample or
demultiplexed samples.
•
QC_ﬁles: Summary statistics for each sample produced during
the basecalling step, or a ﬁle containing information about the
correspondence of reads; that is, basecalled FAST5 ﬁle in the
demultiplexed FAST5 ﬁles.
•
alignment: BAM ﬁle(s) and corresponding indexe(s) for each
sample.
•
cram_ﬁles: Compressed CRAM ﬁle(s) and corresponding
indexe(s) for each sample.
•
counts: Read counts for each transcript or gene in each sample.
•
assigned: The assignment of each read to a gene/transcript if
the counting was performed. It is a simple tab-separated ﬁle with
two ﬁelds: read id and gene/transcript id.
•
assembly: The output of the bambu program, with a new GTF
annotation containing novel transcripts as well.
•
report: A ﬁnal comprehensive report produced by MultiQC.
3.3.4
Mop_preprocess
Runtime
Running the pipeline on the embedded test dataset of two samples
with a single small FAST5 took 25 min on a MacBook with 4 CPUs
and 16 GB RAM. The most demanding step was demultiplexing; it
required 3GB RAM and took 8 min. The copy of the output of this
pipeline is provided in the folder output_pre in the branch “test_re-
sults” of the GitHub repository.

194
Luca Cozzuto et al.
Fig. 3 MultiQC report generated as part of the mop_preprocess module. (a) Screenshot of the ﬁrst page of the
MultiQC report that is generated using the mop_preprocess module. On the left side of the report, all the
features generated using FastQC, MinIONQC, and AlignmentQC are shown. (b, c) MultiQC report allows export
of the generated ﬁgures as stand-alone plots, such as the analysis of per-sequence quality scores (b) or a
histogram depicting the unique and duplicated read counts, for each sample or barcode (c). (d) General
statistics of the runs generated by MinIONQC

Nanopore dRNA-Seq Data Analysis Using MasterOfPores
195
For the yeast dataset, the pre-processing of FAST5 ﬁles (run-
ning mop_preprocess, without assembly; see Subheading 3.2) took
5 h, using 100 compute nodes (8 CPUs each) of an HPC cluster
(SGE) and 10 GPU cards (NVIDIA GeForce RTX 2080 Ti). The
generated output was 137 GB, with intermediate ﬁles of 382 GB.
3.4
Mop_tail:
Estimation of poly(A)
Tail Lengths
The pipeline for the poly(A) tail lengths estimation (Fig. 1) is called
mop_tail (Fig. 2).
This pipeline takes as an input the output directly from mop_-
preprocess: basecalled FAST5 reads, their respective FASTQ ﬁles,
alignments, and assignment of read ID to gene/transcript ID. The
pipeline outputs the estimation of poly(A) tail length at the read
level using two independent workﬂows: one based on Tailﬁndr [5]
and another on Nanopolish [58].
1. In the ./mop_tail/params.conﬁg ﬁle, the following has to be
speciﬁed to execute mop_tail: the output folder produced by
mop_preprocess (parameter input_path), FASTA ﬁle for the ref-
erence transcriptome/genome (parameter reference), output
folder for mop_tail (parameter output), custom tool parameter
(parameter pars_tools), selected tools to run (parameters tail-
ﬁndr and nanopolish). For example:
input_path = "$baseDir/../mop_preprocess/output_book/"
reference = "$baseDir/../anno/yeast_rRNA_ref.fa.gz"
pars_tools = "$baseDir/tools_opt.tsv"
output = "$baseDir/output_book_polyA"
tailfindr = "YES"
nanopolish = "YES"
If both tailﬁndr and nanopolish are selected the pipeline out-
puts also the correlation between the two predictions as a plot of
log(polyA size+1, 2).
2. To execute the pipeline, for example, on a HPC cluster, use the
command:
cd mop_tail
nextflow run mop_tail.nf -with-singularity -bg > log.txt
3. The pipeline outputs the following folders (for a small test set,
in the branch “test_results,” see the folder output_tail) (see
Note 3).
•
nanopolish_ﬂow: Compressed tsv ﬁles, one per sample,
with the predictions made by nanopolish.
•
tailﬁndr_ﬂow: Compressed tsv ﬁles, one per sample, with
the predictions made by tailﬁndr.

196
Luca Cozzuto et al.
•
polya_common: If both tworkﬂows are selected, this folder
contains ﬁles, one per sample, with predictions made by
both tools and one image depicting the correlation between
the two tools. In brief, log2(polyA nt_length+1) values are
calculated for each transcript using both methods and the
linear correlation coefﬁcient is calculated.
For the yeast datasets, the mop_tail runtime was 2.5 h using
8 CPUs on an HPC cluster (SGE). The generated output was
76 MB, with intermediate ﬁles of 3 GB.
3.5
Mop_mod:
Prediction of RNA
Modiﬁcations Using
Four Different
Approaches
The pipeline for the prediction of RNA modiﬁcations (Fig. 1) is
called mop_mod (Fig. 2).
This pipeline takes as an input the output directly from mop_-
preprocess: basecalled FAST5 reads, their respective FASTQ ﬁles,
QC ﬁles, unspliced alignments (see Note 4), and assignment of read
ID to gene/transcript ID. Four different RNA detection workﬂows
can be run based on EpiNano (17), Nanopolish (59), Nanocompore
(14), and Tombo [59], using either level sample compare (current
intensity distribution comparison) or model sample compare (com-
parison to an unmodiﬁed current intensity proﬁle). Mop_mod out-
puts the predictions generated by each of the four tools in
individual folders. The pipeline also compares one sample against
another; for example, a wild type versus a knockout.
1. To run mop_mod, in the ﬁle ./mop_mod/params.conﬁg, specify
the path of the output from mop_preprocess (parameter input_-
path), reference (parameter reference), output folder (parame-
ter output), workﬂows to execute, whether or not to generate a
plot per transcript using EpiNano (parameter epinano_plots),
and the ﬁle for comparison (parameter comparison). The cus-
tom tools parameters (parameter pars_tools) can be speciﬁed in
the ﬁle tools_opt.tsv, and the ﬁle comparison.tsv should contain
the list of samples to be compared to in the format sampleA
<tab> sampleB. Here is an example of params.conﬁg to exe-
cute all four workﬂows on the yeast dataset:
input_path
= "$baseDir/../mop_preprocess/output/"
comparison
= "$baseDir/comparison.tsv"
reference
= "$baseDir/anno/yeast_rRNA_ref.fa.gz”
output
= "$baseDir/output_polya"
pars_tools
= "$baseDir/tools_opt.tsv"
// flows
epinano
= "YES"
nanocompore = "YES"
tombo_lsc
= "YES"
tombo_msc
= "YES"

// epinano plots
epinano_plots = "YES"
Nanopore dRNA-Seq Data Analysis Using MasterOfPores
197
2.
3.
To run the pipeline on an HPC, use the command:
cd mop_mod
nextflow run mop_mod.nf -with-singularity -bg > log.txt
The pipeline outputs the following folders (for the embedded
test dataset, in the branch “test_results,” see the folder
output_mod):
•
epinano_ﬂow: Compressed tsv ﬁles, one per sample, with
the predictions made by EpiNano for each comparison. If
the option epinano_plots is turned on, plots for each mapped
reference transcript are generated.
•
nanopolish-compore_ﬂow: Compressed tsv ﬁle with the
predictions made by Nanocompore for each comparison.
•
tombo_ﬂow: One or two ﬁles per comparison with the
predictions using the indicated modality of Tombo.
For the yeast datasets, the mop_mod execution time was 6 h
using 8CPUs on an HPC cluster (SGE). The generated output was
14 MB, with intermediate ﬁles of 300 GB.
3.6
Mop_consensus:
Identiﬁcation of
Robust Changes in
RNA Modiﬁcations
Across Two Conditions
The pipeline for the consensus prediction of RNA modiﬁcations
(Fig. 1) is called mop_consensus (Fig. 2).
This pipeline takes as an input the output from mop_mod,
which was run using the four workﬂows based on EpiNano (17),
Nanopolish (59), Nanocompore (14), and Tombo [59] using the
mode level sample compare. The pipeline outputs the consensus of
the different predictions running the tool NanoConsensus [60] in
parallel on each transcript and for each comparison (Fig. 4).
For the yeast datasets, the mop_consensus execution time was
3 min on an HPC cluster (SGE) using eight CPUs. The generated
output was 13 MB, with intermediate ﬁles of 25 MB.
3.7
MoP2 Execution
Monitoring and
Reporting
Nextﬂow allows obtaining a comprehensive report on computa-
tional resources that have been used during a Nextﬂow pipeline
execution; it also allows live monitoring of the pipeline run.
For example, executing the following commands for the yeast
dataset
cd mop_preprocess; nextflow run mop_preprocess.nf -with-singu-
larity -with-report -bg -profile sge > log
the report.html ﬁle is produced. It provides information about the
CPU and memory usage, memory peak usage, and timing for each

198
Luca Cozzuto et al.
Epinano
Nanopolish
Tombo
Nanocompore
NanoConsensus
0
1000
2000
3000
0
10
20
30
40
0
10
20
30
40
0
10
20
30
40
0
10
20
30
40
0
1000
2000
3000
0.00
0.25
0.50
0.75
1.00
Epinano
Nanopolish
Tombo
Nanocompore
NanoConsensus
0
1000
2000
3000
0
10
20
30
40
0
10
20
30
40
0
10
20
30
40
0
10
20
30
40
0
1000
2000
3000
0.00
0.25
0.50
0.75
1.00
WT vs snR61 KO
(expected sites: 25S:Am817 and 25S:Gm908) 
A
B
Position (bp)
NanoConsensus score
Z-Score((x-median)/sd)
WT vs snR34 KO
(expected sites: 25S:Y2826 and 25S:Y2820) 
NanoConsensus score
Z-Score((x-median)/sd)
Position (bp)
Fig. 4 Plots generated by the mop_consensus module, depicting the differential RNA-modiﬁed sites predicted
by each individual software and the consensus predictions (NanoConsensus). (a) Plot obtained by mop_con-
sensus when comparing S.cerevisiae WT versus snR61-deﬁcient strains, which is the snoRNA guiding Nm


Nanopore dRNA-Seq Data Analysis Using MasterOfPores
199
Fig. 5 Screenshot of the Nextﬂow report on CPU, memory usage, task execution time, and I/O during execution
of the mop_preprocess pipeline on the yeast dataset
step (Fig. 5). The reports on execution of all pipelines for the yeast
dataset are provided in the MoP2 Github repository.
It is also possible to monitor the pipeline execution using the
web app Tower (https://cloud.tower.nf/). For example, after reg-
istering at https://cloud.tower.nf/ the above command can be
executed with an additional parameter -with-tower, thus allowing
monitoring the pipeline;s execution in real time via the Tower
(Fig. 6).
4
Notes
1. Guppy versions higher than 4.4.1 are not yet supported in the
GPU mode. This is because the MoP workﬂow includes
CUDA version 10, while to be run in the GPU mode, Guppy
v. 4.4.1 or later requires CUDA 11. However, in the CPU
mode, MoP2 will still work with Guppy versions higher than
4.4.1.
Fig. 4 (continued) modiﬁcations at positions 25S:817 and 25S:908. (b) Plot obtained by mop_consensus
when comparing S.cerevisiae WT versus snR34-deﬁcient strains, which are responsible for placing Nm
modiﬁcations at positions 25S:2826 and 25S:2880. For each panel, the predicted differential RNA modiﬁca-
tions made by each individual software (EpiNano, Nanopolish, Tombo, and Nanocompore) are shown in the
four upper rows, whereas the consensus RNA modiﬁcation predictions are shown in the bottom row of each
panel (red)

200
Luca Cozzuto et al.
Fig. 6 Screenshot of the Tower app (https://cloud.tower.nf/) of the mop_preprocess execution
2.
2.1.
Setting up an AWS Infrastructure to run MoP2 on the
Cloud
To set up an AWS infrastructure, in the terraform folder of
the repository, we provide the Terraform scripts. The AWS
infrastructure consists of a machine entry point, an associated
S3 bucket storage, and an AWS Batch computing environment
with two queues, one for the CPU processes and another for
the GPU processes. To set up an AWS infrastructure, follow the
steps:
Modify conﬁg.sh to ﬁt the desired preferences (e.g., the
bucket name). An example of the contents of a conﬁg.sh
ﬁle is included below:
export TF_VAR_key_name=key-nf
# Modify instance type to fit more needs if desired: https://
aws.amazon.com/ec2/instance-types/t2/
export TF_VAR_instance_type=t2.small
# Image used for entrypoint
export TF_VAR_ami_entrypoint=ami-0cf1f74891140b374
# Image used for setting in the cluster
export TF_VAR_ami_batch=ami-06b8c6e4fe388181d
export TF_VAR_ami_batch_gpu=ami-06b8c6e4fe388181d
# Region

export TF_VAR_region=eu-central-1
export TF_VAR_profile=default
# If lower bid percentage, it will take longer to run in AWS
Batch, but it will be cheaper
export TF_VAR_bid_percentage=90
export TF_VAR_credentials=/home/myuser/.aws/credentials
export TF_VAR_ec2_password=sshpassword
export TF_VAR_instance_count=1
export TF_VAR_instance_volume_size=45
export TF_VAR_bucket_acl=public-read
export TF_VAR_bucket_prefix=mop2-bucket
export TF_VAR_compute_environment_name=nf-compute
export TF_VAR_compute_environment_name_gpu=nf-compute-gpu
export TF_VAR_queue_name=mop
export TF_VAR_queue_name_gpu=mop-gpu
export TF_VAR_compute_environment_type=SPOT
export TF_VAR_compute_environment_type_gpu=EC2
export TF_VAR_instance_batch=’["optimal"]’
export TF_VAR_instance_batch_gpu=’["p3"]’
export TF_VAR_subnets=’["subnet-8a280df7", "subnet-c54d6588",
"subnet-b85ab5d2"]’
export TF_VAR_repourl=https://github.com/biocorecrg/MOP2
export
AWS_ACCOUNT_ID=$(aws
sts
get-caller-identity|jq
.Ac-
count|tr -d \")
aws s3 cp mydata* s3://my-mop2-bucket-1/input --recursive
Nanopore dRNA-Seq Data Analysis Using MasterOfPores
201
2.2. Execute the Terraform scripts, using the environment vari-
ables deﬁned in conﬁg.sh:
source
config.sh
#This
file
can
be
modified
to
fit
user
preferences
terraform init #This needs to be done the first time
terraform plan #This checks the proposed infrastructure
terraform apply #If above proposal is OK, infrastructure is
deployed
2.3. Once the infrastructure is deployed, Terraform returns the
available machine EC2 entry point, the deﬁned S3 bucket,
and other components, including the two computation
queues. They can be retrieved again, using the command:
terraform output
2.4. Upload input data in the newly set-up bucket, using AWS
command-line S3 options (see https://docs.aws.amazon.
com/cli/latest/userguide/cli-services-s3-commands.html):

202
Luca Cozzuto et al.
where my-mop2-bucket-1, for example, is the ﬁnal bucket
name deﬁned by the TF_VAR_bucket_preﬁx variable in the
conﬁg.sh ﬁle.
2.5. Connect to the EC2 entry point using the ssh command with
the generated public DNS address of the entry point
returned by Terraform; for example:
ssh ec2-user@ec2-ww-xx-yy-zz.eu-reg.compute.amazonaws.com
2.6. Place the output results in the S3 bucket, so they can be
downloaded later on. This can be done by copying them to
the mounted bucket (under /mnt) in the entry point
machine once the analyses are ﬁnished or deﬁning the output
value in params.conﬁg to be a directory inside the actual
bucket instead of the default one (see https://www.
nextﬂow.io/docs/latest/amazons3.html).
2.7. Once the analyses are ﬁnished and the results retrieved, the
infrastructure can be removed using the command:
terraform destroy
3. The mop_tail module for poly(A) tail length estimations was
run on the same dataset used throughout this book chapter to
illustrate the usage of all MoP2 modules (yeast total RNA).
However, we should note that poly(A) tail length estimates in
this speciﬁc dataset will not have any biological meaning, as we
are using the total RNA that has been in vitro polyadenylated in
order to be sequenced using RMX oligonucleotides with poly
(dT) overhang. Therefore, the poly(A) tail length estimates in
this speciﬁc example will not be reﬂecting the biological
scenario.
4. The module mop_mod can only be run on unspliced alignments
(i.e., mapped to transcriptome) as several of the software tools
used in the mop_mod pipeline (e.g., Nanocompore and Tombo)
do not support the spliced mapping.
Acknowledgments
This work was partly supported by the Spanish Ministry of Econ-
omy,
Industry
and
Competitiveness
(MEIC)
(PID2021-
128193NB-100 to EMN) and the European Research Council
(ERC-StG-2021 No 101042103 to EMN). AD-T is supported
by a Severo Ochoa FPI PhD fellowship from the MEIC
(PRE2019-088498). We acknowledge the support of the MEIC
to the EMBL partnership, Centro de Excelencia Severo Ochoa and
CERCA Programme/Generalitat de Catalunya.

Nanopore dRNA-Seq Data Analysis Using MasterOfPores
203
References
1. Brown CG, Clarke J (2016) Nanopore devel-
opment at Oxford Nanopore. Nat Biotechnol
34(8):810–811. https://doi.org/10.1038/
nbt.3622
2. Midha MK, Wu M, Chiu KP (2019) Long-read
sequencing in deciphering human genetics to a
greater
depth.
Hum
Genet
138(11–12):
1201–1215.
https://doi.org/10.1007/
s00439-019-02064-y
3. Mahmoud M, Gobet N, Cruz-Da´valos DI,
Mounier N, Dessimoz C, Sedlazeck FJ (2019)
Structural variant calling: the long and the
short of it. Genome Biol 20(1):246. https://
doi.org/10.1186/s13059-019-1828-7
4. Liu C (2021) A long road/read to rapid high-
resolution HLA typing: The nanopore perspec-
tive. Hum Immunol 82(7):488–495. https://
doi.org/10.1016/j.humimm.2020.04.009
5. Krause M, Niazi AM, Labun K, Torres Cleuren
YN, Mu¨ller FS, Valen E (2019) tailﬁndr:
alignment-free poly(A) length measurement
for oxford nanopore RNA and DNA sequenc-
ing. RNA 25(10):1229–1241. https://doi.
org/10.1261/rna.071332.119
6. Workman RE, Tang AD, Tang PS et al (2019)
Nanopore native RNA sequencing of a human
poly(A) transcriptome. Nat Methods 16(12):
1297–1305.
https://doi.org/10.1038/
s41592-019-0617-2
7. Niazi AM, Krause M, Valen E (2021) Tran-
script
isoform-speciﬁc
estimation
of
Poly
(A) tail length by nanopore sequencing of
native RNA. Methods Mol Biol 2284:543–
567. https://doi.org/10.1007/978-1-0716-
1307-8_30
8. Bolisetty MT, Rajadinakaran G, Graveley BR
(2015) Determining exon connectivity in com-
plex
mRNAs
by
nanopore
sequencing.
Genome Biol 16:204. https://doi.org/10.
1186/s13059-015-0777-z
9. Sessegolo C, Cruaud C, Da Silva C et al (2019)
Transcriptome proﬁling of mouse samples
using nanopore sequencing of cDNA and
RNA molecules. Sci Rep 9(1):14908. https://
doi.org/10.1038/s41598-019-51470-9
10. Byrne A, Beaudin AE, Olsen HE et al (2017)
Nanopore long-read RNAseq reveals wide-
spread transcriptional variation among the sur-
face
receptors
of
individual
B
cells.
Nat
Commun 8:16027. https://doi.org/10.
1038/ncomms16027
11. Krizˇanovic K, Echchiki A, Roux J, Sˇikic M
(2018) Evaluation of tools for long read
RNA-seq
splice-aware
alignment.
Bioinformatics 34(5):748–754. https://doi.
org/10.1093/bioinformatics/btx668
12. Carlsen AT, Zahid OK, Ruzicka JA, Taylor EW,
Hall AR (2014) Selective detection and quan-
tiﬁcation of modiﬁed DNA with solid-state
nanopores.
Nano Lett
14(10):5488–5492.
https://doi.org/10.1021/nl501340d
13. Furlan M, Delgado-Tejedor A, Mulroney L,
Pelizzola M, Novoa EM, Leonardi T (2021)
Computational methods for RNA modiﬁcation
detection from nanopore direct RNA sequenc-
ing data. RNA Bio 18:1–10. https://doi.org/
10.1080/15476286.2021.1978215
14. Leger A, Amaral PP, Pandolﬁni L et al (2021)
RNA modiﬁcations detection by comparative
Nanopore direct RNA sequencing. Nat Com-
mun 12(1):7198. https://doi.org/10.1038/
s41467-021-27393-3
15. Simpson
JT,
Workman
RE,
Zuzarte
PC,
David M, Dursi LJ, Timp W (2017) Detecting
DNA cytosine methylation using nanopore
sequencing.
Nat
Methods
14(4):407–410.
https://doi.org/10.1038/nmeth.4184
16. Garalde DR, Snell EA, Jachimowicz D et al
(2018) Highly parallel direct RNA sequencing
on an array of nanopores. Nat Methods 15(3):
201–206. https://doi.org/10.1038/nmeth.
4577
17. Liu H, Begik O, Lucas MC et al (2019) Accu-
rate detection of m6A RNA modiﬁcations in
native RNA sequences. Nat Commun 10(1):
4079. https://doi.org/10.1038/s41467-
019-11713-9
18. Parker MT, Knop K, Sherwood A et al (2020)
Nanopore direct RNA sequencing maps the
complexity of Arabidopsis mRNA processing
and m. Elife 9:e49658. https://doi.org/10.
7554/eLife.49658
19. Haussmann IU, Bodi Z, Sanchez-Moran E et al
(2016)
m6A
potentiates
Sxl
alternative
pre-mRNA splicing for robust Drosophila sex
determination. Nature 540(7632):301–304.
https://doi.org/10.1038/nature20577
20. Madugalle SU, Meyer K, Wang DO, Bredy TW
(2020) RNA N6-Methyladenosine and the
regulation of RNA localization and function
in the brain. Trends Neurosci 12;43(12):
1011–1023. https://doi.org/10.1016/j.tins.
2020.09.005
21. Yu J, Chen M, Huang H et al (2018) Dynamic
m6A modiﬁcation regulates local translation of
mRNA in axons. Nucleic Acids Res 46(3):
1412–1423. https://doi.org/10.1093/nar/
gkx1182

22.
204
Luca Cozzuto et al.
Roundtree IA, Evans ME, Pan T, He C (2017)
Dynamic RNA modiﬁcations in gene expres-
sion
regulation.
Cell
169(7):1187–1200.
https://doi.org/10.1016/j.cell.2017.05.045
23. Lee Y, Choe J, Park OH, Kim YK (2020)
Molecular mechanisms driving mRNA degra-
dation by m6A modiﬁcation. Trends Genet
36(3):177–188. https://doi.org/10.1016/j.
tig.2019.12.007
24. Geula S, Moshitch-Moshkovitz S, Dominissini
D et al (2015) Stem cells. m6A mRNA meth-
ylation facilitates resolution of naı¨ve pluripo-
tency
toward
differentiation.
Science
347(6225):1002–1006. https://doi.org/10.
1126/science.1261417
25. Lence T, Akhtar J, Bayer M et al (2016) m6A
modulates neuronal functions and sex determi-
nation
in
Drosophila.
Nature
540(7632):
242–247.
https://doi.org/10.1038/
nature20568
26. Freund I, Eigenbrod T, Helm M, Dalpke AH
(2019) RNA modiﬁcations modulate activa-
tion
of
innate
toll-like
receptors.
Genes
(Basel) 10(2). https://doi.org/10.3390/
genes10020092
27. Jonkhout N, Tran J, Smith MA, Schonrock N,
Mattick JS, Novoa EM (2017) The RNA mod-
iﬁcation landscape in human disease. RNA
23(12):1754–1769. https://doi.org/10.
1261/rna.063503.117
28. Frye M, Harada BT, Behm M, He C (2018)
RNA modiﬁcations modulate gene expression
during
development.
Science
361(6409):
1346–1349. https://doi.org/10.1126/sci
ence.aau1646
29. Barbieri I, Kouzarides T (2020) Role of RNA
modiﬁcations in cancer. Nat Rev Cancer 20(6):
303–322. https://doi.org/10.1038/s41568-
020-0253-2
30. Yanas A, Liu KF (2019) RNA modiﬁcations
and the link to human disease. Methods Enzy-
mol 626:133–146. https://doi.org/10.1016/
bs.mie.2019.08.003
31. Courtney DG (2021) Post-transcriptional reg-
ulation of viral RNA through epitranscriptional
modiﬁcation. Cells 10(5). https://doi.org/10.
3390/cells10051129
32. Li N, Hui H, Bray B et al (2021) METTL3
regulates viral m6A RNA modiﬁcation and
host cell innate immune responses during
SARS-CoV-2
infection.
Cell
Rep
35(6):
109091. https://doi.org/10.1016/j.celrep.
2021.109091
33. Tsai K, Cullen BR (2020) Epigenetic and epi-
transcriptomic regulation of viral replication.
Nat Rev Microbiol 18(10):559–570. https://
doi.org/10.1038/s41579-020-0382-3
34. Horova V, Landova B, Hodek J et al (2021)
Localization of SARS-CoV-2 capping enzymes
revealed by an antibody against the nsp10 Sub-
unit. Viruses 13(8). https://doi.org/10.
3390/v13081487
35. Maldonado Lo´pez A, Capell BC (2021) The
METTL3-m6A
Epitranscriptome:
dynamic
regulator of epithelial development, differenti-
ation,
and
cancer.
Genes
(Basel)
12(7).
https://doi.org/10.3390/genes12071019
36. Zheng X, Wang J, Zhang X et al (2021) RNA
m6A methylation regulates virus-host interac-
tion and EBNA2 expression during Epstein-
Barr virus infection. Immun Inﬂamm Dis
9(2):351–362. https://doi.org/10.1002/
iid3.396
37. Kennedy EM, Courtney DG, Tsai K, Cullen
BR (2017) Viral epitranscriptomics. J Virol
91(9).
https://doi.org/10.1128/JVI.
02263-16
38. Ko¨ster J, Rahmann S (2012) Snakemake–a scal-
able bioinformatics workﬂow engine. Bioinfor-
matics 28(19):2520-2522. doi:https://doi.
org/10.1093/bioinformatics/bts480
39. Di Tommaso P, Chatzou M, Floden EW, Barja
PP, Palumbo E, Notredame C (2017) Next-
ﬂow enables reproducible computational work-
ﬂows.
Nat
Biotechnol
35(4):316–319.
https://doi.org/10.1038/nbt.3820
40. Crusoe MR, Abeln A, Alexandru I, Peter A,
Community TC (2021) Methods included:
standardizing computational reuse and porta-
bility with the common workﬂow language.
arXiv 2105.07028 [cs.DC]; 2021
41. Jalili V, Afgan E, Gu Q et al (2020) The Galaxy
platform for accessible, reproducible and col-
laborative biomedical analyses: 2020 update.
Nucleic
Acids
Res
48(W1):W395–W402.
https://doi.org/10.1093/nar/gkaa434
42. Cozzuto L, Liu H, Pryszcz LP et al (2020)
MasterOfPores: a workﬂow for the analysis of
oxford nanopore direct RNA sequencing data-
sets. Front Genet 11:211. https://doi.org/10.
3389/fgene.2020.00211
43. Nextﬂow DSL2. https://www.nextﬂow.io/
docs/latest/dsl2.html.
Accessed
23 December 2021.
44. Begik O, Lucas MC, Pryszcz LP et al (2021)
Quantitative proﬁling of pseudouridylation
dynamics
in
native
RNAs
with
nanopore
sequencing.
Nat
Biotechnol
39(10):
1278–1291.
https://doi.org/10.1038/
s41587-021-00915-6
45. Smith MA, Ersavas T, Ferguson JM et al
(2020) Molecular barcoding of native RNAs
using nanopore sequencing and deep learning.

53.
Nanopore dRNA-Seq Data Analysis Using MasterOfPores
205
Genome Res 30(9):1345–1353. https://doi.
org/10.1101/gr.260836.120
46. Cozzuto L, Di Tommaso P. BioNextﬂow – a
library of Groovy classes for Nextﬂow. https://
github.com/biocorecrg/BioNextﬂow/
tree/0.7.3. Accessed 23 Dec 2021
47. De Coster W, D’Hert S, Schultz DT, Cruts M,
Van Broeckhoven C (2018) NanoPack: visua-
lizing and processing long-read sequencing
data.
Bioinformatics
34(15):2666–2669.
https://doi.org/10.1093/bioinformatics/
bty149
48. Nanoq – ultra-fast quality control and sum-
mary reports for nanopore reads. https://
github.com/esteinig/nanoq.
Accessed
23 Dec 2021
49. Lanfear R, Schalamun M, Kainer D, Wang W,
Schwessinger B (2019) MinIONQC: fast and
simple quality control for MinION sequencing
data. Bioinformatics 35(3):523–525. https://
doi.org/10.1093/bioinformatics/bty654
50. FastQC – a quality control tool for high
throughput sequence data. Https://www.bio
informatics.babraham.ac.uk/projects/fastqc.
Accessed 23 Dec 2021
51. Li H (2018) Minimap2: pairwise alignment for
nucleotide sequences. Bioinformatics 34(18):
3094–3100. https://doi.org/10.1093/bioin
formatics/bty191
52. GraphMap2 – A highly sensitive and accurate
mapper for long, error-prone reads. https://
github.com/lbcb-sci/graphmap2.
Accessed
23 Dec 2021
Pryszcz L, Capella S. Bioinformatics binaries.
https://github.com/lpryszcz/bin.
Accessed
23 Dec 2021
54. Anders S, Pyl PT, Huber W (2015) HTSeq–a
Python
framework
to
work
with
high-
throughput sequencing data. Bioinformatics
31(2):166–169. https://doi.org/10.1093/
bioinformatics/btu638
55. Gleeson J, Leger A, Prawer YDJ et al (2021)
Accurate expression quantiﬁcation from nano-
pore direct RNA sequencing with NanoCount.
Nucleic Acids Res. https://doi.org/10.1093/
nar/gkab1129
56. bambu: reference-guided transcript discovery
and quantiﬁcation for long read RNA-Seq
data. https://github.com/GoekeLab/bambu.
https://doi.org/10.18129/B9.bioc.bambu.
Accessed 23 Dec 2021
57. Ewels P, Magnusson M, Lundin S, K€aller M
(2016) MultiQC: summarize analysis results
for multiple tools and samples in a single
report.
Bioinformatics
32(19):3047–3048.
https://doi.org/10.1093/bioinformatics/
btw354
58. Nanopolish – Software package for signal-level
analysis of Oxford Nanopore sequencing data.
https://github.com/jts/nanopolish. Accessed
23 Dec 2021
59. Tombo – a suite of tools primarily for the iden-
tiﬁcation of modiﬁed nucleotides from nano-
pore sequencing data. https://github.com/
nanoporetech/tombo. Accessed 23 Dec 2021
60. Delgdado-Tejedor A. NanoConsensus: con-
sensus prediction of RNA modiﬁcations from
direct
RNA
nanopore
sequencing
data.
Zenodo. https://doi.org/10.5281/zenodo.
5805806. Accessed 27 Dec 2021

Chapter 14
Data Analysis Pipeline for Detection and Quantiﬁcation
of Pseudouridine (ψ) in RNA by HydraPsiSeq
Florian Pichot
, Virginie Marchand
, Mark Helm
, and Yuri Motorin
Abstract
Pseudouridine, a modiﬁed RNA residue formed by the isomerization of its parental U nucleotide, is
prevalent in a majority of cellular RNAs; its presence was reported in tRNA, rRNA, and sn/snoRNA as
well as in mRNA/lncRNA. Multiple analytical deep sequencing-based approaches have been proposed for
pseudouridine detection and quantiﬁcation, among which the most popular relies on the use of soluble
carbodiimide (termed CMCT). Recently, we developed an alternative protocol for pseudouridine mapping
and quantiﬁcation. The principle is based on protection of pseudouridine against random RNA cleavage by
hydrazine/aniline treatment (HydraPsiSeq protocol). This “negative” detection mode requires higher
sequencing depth and provides a precise quantiﬁcation of the pseudouridine content. All “wet-lab”
technical details of the HydraPsiSeq protocol have been described in recent publications. Here, we describe
all bioinformatics analysis steps required for data processing from raw reads to the pseudouridylation proﬁle
of known or unknown RNA.
Key words High-throughput sequencing, Deep sequencing, Pseudouridine, Data analysis, RNA,
Computational biology
1
Introduction
Pseudouridine (ψ), formed by the enzymatic isomerization of its
parental uridine residue, is one of the most widespread RNA nucle-
otide modiﬁcation and is commonly observed in tRNAs, rRNAs,
snRNAs, snoRNAs, and mRNAs/lncRNAs [1–4]. The presence
of ψ alters both local RNA conformation, as well as H-bonding
capacity, providing additional functional features to the RNA chain
[5–7]. The prevalence and importance of ψ residues in various
cellular RNAs have promoted the development of speciﬁc detection
protocols [8, 9], since this nucleoside is “mass silent” for mass
spectrometry [10–12].
Chemical methods for ψ detection stem from fundamental
analysis of normal and modiﬁed nucleobases’ reactivity toward
various chemical reagents (reviewed in [13]). Two types of ψ
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_14,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
207

208
Florian Pichot et al.
reactivity were explored, the modiﬁcation of nitrogens in the
pyrimidine cycle [14] and Michael addition to the C5=C6 double
bond, leading to the ring opening. The ﬁrst approach led to a
“positive” detection mode allowing distinction between U and ψ
[15], while the reduced reactivity of the C=C double bond in ψ
distinguishes it from uridine in a “negative” mode, in this case, ψ is
protected from U-speciﬁc cleavage reagents (Fig. 1a).
The “positive” detection mode using ψ-speciﬁc N-cyclohexyl-
N′-β-(4-methylmorpholinium)
ethylcarbodiimide
p-tosylate
(CMCT) was ﬁrst established in low-throughput mode [14, 15]
and very extensively used in the early 1980s for ψ mapping in
rRNAs from different species. Further developments and optimiza-
tion of the protocol for deep sequencing analysis gave rise to
PseudoU-Seq and its variants (termed “CMCT-Seq” here) are
applied for ψ mapping in yeast and human mRNAs [16–18]. Due
to the “positive” detection mode, “CMCT-Seq” is relatively sensi-
tive and, in principle, requires lower sequencing depth for analysis,
but quantiﬁcation of the modiﬁcation content remains laborious
and requires internal calibration standards [19]. A version of
“CMCT-Seq” coupled to qRT-PCR was also proposed for quanti-
ﬁcation
of
the stoichiometry of
single
ψ
sites
in deﬁned
amplicons [20].
The “negative” detection mode relies on random cleavages of
all U residues in RNA by hydrazine, while ψ residues are resistant
under these conditions as they do not undergo ring’s opening
(Fig. 1a). This feature was also explored for ψ detection in
low-throughput mode [21, 22], but was not generalized as a widely
used protocol, since the absence of a signal in primer extension
analyses yields a less reliable interpretation than a distinct CMCT-
related RT stop corresponding to a modiﬁed residue.
However, a protection at ψ residues from hydrazine cleavage
allows a straightforward quantiﬁcation of the modiﬁcation rate, and
this advantage was explored in a high-throughput analytical
approach, termed HydraPsiSeq [23, 24]. In this method, RNA is
randomly cleaved at all unmodiﬁed U residues, yielding a 5′-P
residue at the N + 1 nucleotide. This feature of the resulting RNA
fragments is used for speciﬁc adapter ligation, leading to strongly
reduced background signal from non-U residues (Fig. 1b). In prac-
tice, the efﬁciency of random hydrazine cleavage varies somewhat,
depending on the RNA sequence context and structure. It, there-
fore, provides a rather irregular cleavage proﬁle even in relatively
denaturing conditions (50% hydrazine in water). Since ψ is not
sensitive to hydrazine, cleavages at pseudouridylation sites stay at
the background (or low) levels, depending on the modiﬁcation
stoichiometry. In the analysis of RNA with unknown modiﬁcation
pattern, these protected U residues in general represent potential ψ
but may also originate from other modiﬁed Us that are partially or
completely resistant to hydrazine, such as m5U, dihydrouridine (D),
or hypermodiﬁed 5-substituted Us in tRNA wobble position [24].

HydraPsiSeq Bioinformatics Pipeline
209
Fig. 1 Chemical basis for and experimental steps used in the HydraPsiSeq protocol. (a) Cleavage of U residues
in RNA by hydrazine treatment. This is followed by aniline scission of the phosphodiester bond. (b) Main “wet
lab” steps of the HydraPsiSeq protocol. As a key feature, only RNA fragments having adapters ligated to both
extremities are ampliﬁed and sequenced; thus, RT-arresting RNA modiﬁcations are not giving any sharp
signal. (c) Outline of proﬁles and scores used for detection and quantiﬁcation of the ψ residues

210
Florian Pichot et al.
Compared to “positive” mode detection protocols, Hydra-
PsiSeq requires a higher coverage depth, that is, at least >50–100
reads/RNA
position.
However,
such
sequencing
depth
is
readily achieved with the last generation of Illumina deep sequenc-
ing
machines
(NextSeq/NovaSeq
series)
typically
providing
~400–1000 million raw reads per ﬂow cell.
Practical applications of HydraPsiSeq to the analysis of rRNA
and tRNA pseudouridylation have been discussed in two recent
publications [23, 24]. In this method chapter, we will address the
computational aspects of data analysis and interpretation.
Our data analysis pipeline for HydraPsiSeq protocol includes
quality control of the raw reads, a trimming to remove adapter’s
contamination, an alignment to the reference RNA sequence, a
quantiﬁcation of the 5′- reads’ extremities, followed by calculation
of window-normalized cleavage at all U residues in RNA (Normal-
izedUcleavage) and speciﬁc HydraPsiSeq scores. The latter allows
detection of potentially modiﬁed positions in unknown RNAs and a
quantiﬁcation of the modiﬁcation stoichiometry for RNA species of
already established pseudouridylation proﬁles.
2
Materials
All calculations and data manipulation/storage are done using a
Unix (Linux) server (we are currently using Illumina Compute Dell
R815 server (2012) running Linux RedHat 6.0 and Illumina Dell
R740 (2021) under Ubuntu LTS20.4). Appropriate computer
conﬁgurations
(Linux
server
and
personal
workstation)
are
described in more detail in Notes 1 and 2. All software and
packages listed below should be installed and conﬁgured on a
Linux server (see Subheadings 2.2, 2.3, 2.4, and 2.5) and PC
under appropriate Windows version (Windows v.10 is currently
used, see Subheadings 2.2, 2.5, 2.6, and 2.7).
2.1
Library
Sequencing
1. Quantiﬁed and characterized HydraPsiSeq libraries.
2. Illumina sequencer (any type can be used since libraries are
compatible with a full range, but throughput or ﬂow cell
capacity (nominal number of clusters) should be adapted to
the required depth of sequencing). We successfully used
MiSeq,
HiSeq1000,
and
NextSeq2000
for
HydraPsiSeq
analysis.
2.2
Analysis of Raw
Reads’ Quality by
FastQC
FastQC software for Windows or Linux (current version 0.11.8,
https://www.bioinformatics.babraham.ac.uk/projects/fastqc/).

HydraPsiSeq Bioinformatics Pipeline
211
2.3
Trimming
Adapter trimming software Trimmomatic (current version 0.39,
http://www.usadellab.org/cms/?page=trimmomatic).
2.4
Alignment
Alignment software Bowtie 2.0 (current version 2.2.4, http://
bowtie-bio.sourceforge.net/bowtie2/index.shtml).
2.5
Data Processing
1. Samtools (current version 1.12, http://www.htslib.org/doc/
samtools.html).
2. Bedtools (current version 2.18, https://bedtools.readthedocs.
io/en/latest/).
3. (Optional) IGV (current version 2.6.2, https://software.
broadinstitute.org/software/igv/).
2.6
Data Treatment
R Studio server (current version “Juliet Rose” 1.4.1717, https://
www.rstudio.com/products/rstudio/download-server/) running
R environment (current version “Camp Pontanezen” 4.1.0,
https://cran.r-project.org/bin/windows/base/).
Alternatively,
standalone R Studio desktop version can be installed and be used
locally (current version 2021.09.0 + 351, https://www.rstudio.
com/products/rstudio/download/).
2.7
Data Analysis
Final data analysis including generating appropriate graphs and data
tables can be done either in the R environment (recommended)
with the ggplot2 package or in Microsoft Excel/Open/Libre
ofﬁce Calc.
3
Methods
“Wet-lab” library preparation steps for HydraPsiSeq (see Fig. 1b)
were described in detail elsewhere [23, 24]. Here, we present the
data analysis pipeline, outlined in Fig. 2.
3.1
Library
Sequencing
1. HydraPsiSeq libraries are sequenced at a moderate depth, and
the typical target number of raw sequencing reads for reliable
rRNA analysis is 20 million; thus, 10–12 HydraPsiSeq libraries
can be loaded to one lane of the HiSeq1000 ﬂow-cell (nominal
capacity of 250 million/lane, SBS v3 kits), or up to 48 libraries
to one NextSeq2000 ﬂow cell (capacity of 1100 million/lane,
P3 kits).
2. Sequencing mode is single read 50 nucleotides (SR50); this
sequencing mode is well suitable for downstream analysis of
HydraPsiSeq data.
3. Optimal loading of HydraPsiSeq libraries depends on the
sequencer and should be optimized empirically (generally
10–12 pM for HiSeq1000), considering that clustering is

212
Florian Pichot et al.
Fig. 2 Major bioinformatics steps for HydraPsiSeq data processing. Optional conversions are shown in gray.
File formats used in different steps, as well as computer environments are indicated
relatively efﬁcient for very short fragments obtained by hydra-
zine/aniline cleavage.
4. When the sequencing run is ﬁnished, raw reads are sorted by
sample using Illumina i7 indexes (and, optionally i5, not used
in the current library design), using bcl2fastq utility or onboard
Dragen demultiplex utility for NextSeq2000.
3.2
Analysis of Raw
Reads’ Quality by
FastQC
1. FastQC analysis of raw and trimmed reads (see below) can be
performed either in batch (for all FASTQ ﬁles present in the
folder) or only for selected ﬁles in the interactive mode. Inter-
active mode is described here:

HydraPsiSeq Bioinformatics Pipeline
213
2. Open a FASTQ ﬁle using the “File- > Open” option of the
FastQC menu, processing starts automatically and may take
time (10 s to 5 min), depending on the ﬁle size and computing
power available.
3. Check raw reads statistics. The sequence length of sequencing
reads should be the same for the majority of them. Base
sequence quality of reads should be higher than 20 (>30 is
strongly recommended) and N content should be as low as
possible (< 5% is recommended). Untrimmed reads might
have a high amount of adapter content and/or overrepresented
sequences due to the presence of adapters and complexity of
RNA samples used for analysis.
3.3
Trimming
1. For each folder containing FASTQ ﬁles with raw sequencing
reads, perform trimming of the adapter sequences using Trim-
momatic, using the following command java -jar ../trimmo-
matic-0.39.jar
SE
-phred33
<INPUT_FILE>
<OUPUT_FILE> ILLUMINACLIP:TruSeq3-SE.fa:2:30:N
LEADING:30
TRAILING:30
SLIDINGWINDOW:4:15
MINLEN:N AVGQUAL:30. Adapter sequences are deﬁned
in TruSeq3-SE.fa ﬁle. Recommended parameters (see Note 3)
ILLUMINACLIP: seed mismatches 2, palindrome clip thresh-
old 30, sample clip threshold 7; SLIDINGWINDOW: window
size 4, required quality 15; LEADING:30; TRAILING:30;
MINLENGTH:8; AVGQUAL:30. If performance issues are
encountered with Trimmomatic, reduce the number of fastq
ﬁles treated in parallel, issue found with RedHat 6.0 linux
server (see Note 4).
2. Assess the trimming quality with FastQC (as described above).
Check if adapter sequences were efﬁciently removed and not
present anymore in trimmed reads sequences.
3.4
Alignment
1. Select the *.bt2 ﬁle containing the reference sequence(s) for
bowtie2 alignment tool (see Note 5).
2. Align trimmed reads from Subheading 3.3 using bowtie2 in
“end-to-end” mode (default bowtie2 mode) to the appropriate
reference sequence.
3. Recommended parameters -p (number of computer proces-
sors/cores – 2);
--no-unal; --no-1mm-upfront; -D 15; -R 2; -N 0; -L 10; -i
S,1,1.15
4. (Optional) Save unaligned reads in *.fastq.gz for further analy-
sis and bowtie2 error message (STDERR) in a *.txt ﬁle for
subsequent quality control of the alignment statistics.

214
Florian Pichot et al.
3.5
Data Processing
1. Keep only uniquely aligned reads (for unambiguous mapping)
from the bowtie2 output SAM ﬁle. To do this, use the com-
mand grep -E “@|NM:” <SAM> | grep -v “XS:”.
2. Extract reads coverage information from a uniquely aligned
SAM ﬁle by samtools mpileup utility (samtools mpileup -f
<FASTA> -aBQ0 -d10000000 <SAM> | cut -f1-4 >
<CSV>) to generate a CSV ﬁle. Only the ﬁrst four columns
(the reference sequence name, the position, the reference
nucleotide base and the reads coverage) are required for the
downstream steps of the analysis pipeline.
3. Using samtools view utility convert the SAM ﬁle containing
uniquely aligned reads to BAM format (samtools view -Sb
<SAM> > <BAM>).
4. Using samtools index utility index the BAM ﬁle from Subhead-
ing 3.5, step 3 (samtools index < BAM>). This step is also
required for *.bam ﬁle visualization by IGV and subsequent
quality check for alignment to the reference.
5. Convert the BAM ﬁle to a BED format using bedtools bamtobed
utility (bedtools bamtobed -i <BAM> > <BED>). Counting of
only 5′-reads’ ends can be done directly from *.sam formatted
ﬁle, but this step ensures compatibility with other pipelines
using both 5′- and 3′-ends counting.
6. For each reference RNA sequence and BED ﬁle from Subhead-
ing 3.5, step 5, generate 5′-ends counting (information avail-
able in the second column of BED ﬁle) and 3′-ends counting
(information available in the third column of BED ﬁle)
awk ‘{print $2}’ < BED> | sort | uniq -c | awk ‘{print $3,
$2,$1,$4}’ | sort -n > <5primeCount.csv > (see Note 6). These
ﬁles by RNA species are used to generate raw cleavage proﬁles.
At the same time, generate coverage ﬁles from the mpileup.csv
ﬁle (from Subheading 3.5, step 2). Save the different output as
distinct .csv ﬁles.
7. (Optional) BED and SAM ﬁles can be removed to save storage
space.
3.6
Data Treatment
1. List all sample folders containing 5′-end counts and coverage
ﬁles.
2. For each folder and each reference sequence of interest, merge
the coverage and 5′-end count ﬁles. Notice that since the
original HydraPsiSeq cleavage signal appears at N + 1 nucleo-
tide, so -1 backshift is introduced during the merge step to
align the cleavage signal with the nucleotide at N position (see
Note 7).
3. Normalize the 5′-end counts (cleavage proﬁle) to the local
background in a sliding window for surrounding nucleotides

HydraPsiSeq Bioinformatics Pipeline
215
Fig. 3 Experimentally observed HydraPsiSeq proﬁle for S. cerevisiae 5S rRNA bearing a single ψ residue at
position 50 (ψ50). Since real HydraPsiSeq cleavage signals appear at N + 1 nucleotides, to align the signal
with the corresponding positions, the -1 backshift is already introduced in the graphs (see Note 7). Top panel
shows the intensity of 5′-count signals in log10 scale (pink) as well as normalization background (in grey) to
obtain NormUcounts. The bottom panel shows NormUcount proﬁle (in blue) in a linear scale, position of
protected ψ50 is highlighted and shown by a red arrow
(ten in total, ﬁve upstream and ﬁve downstream positions) to
obtain NormUcount. For this, the median for cleavage at the
non-U nucleotides is calculated and used as normalizing back-
ground value (see Fig. 3) (see Note 8).
4. From NormUcount generate NormUproﬁle by keeping only
uridine positions. NormUproﬁle shows protection of a given U
residue compared to other Us in the neighborhood and is
further used for calculation of HydraPsiScores (see Note 9).
Save NormUproﬁle in a *.csv ﬁle for further use.
5. In order to perform detection and quantiﬁcation of known and
potential ψ sites, different HydraPsiSeq scores are calculated.
These scores are somehow similar to RiboMethSeq scoring
strategy, but instead of using values for all nucleotides in the
sequence, only NormUcounts (NormUproﬁle) are used.
Scores A, B, and C (see formulas below) were proposed by
Nielsen’s lab [25] for +/- 6 nucleotide interval, but further
modiﬁed to reduce the neighboring region to +/-2 nucleo-
tides [26]. This was shown to improve detection selectivity.
Examples of proﬁles for scores obtained for yeast S. cerevisiae
5S rRNA containing a single ψ residue at position 50 are shown
in Fig. 4.
(a)
ScoreA2 is used for the detection of potential modiﬁed
sites (A2 means ScoreA calculated for +/-2 neighboring
nucleotides) and is calculated using the following formula:

216
Florian Pichot et al.
Fig. 4 NormUcount proﬁle and the corresponding HydraPsiSeq scores for U
(shown here as T in the sequence). Only U residues are taken for Uproﬁle (top
panel) and subsequent calculations of the HydraPsiSeq scores. ScoreMean,
ScoreA2, ScoreB2, and ScoreC2/PsiScore are shown. Depending on the score,
a different scale at the Y axis is used to exclude background values for
unmodiﬁed residues. Position of U to ψ conversion, T(U)50 is shown by an arrow

HydraPsiSeq Bioinformatics Pipeline
217
Score A2 = 1 -
2ni þ 1
1
2 jμl - σlj þ ni þ 1
2 jμr - σrj þ 1
(b)
where n is the read count at position i, μl and μr are the
mean values for left and right ﬂanking regions, and σl/σr
are standard deviations. In contrast to the initial formula
proposed by [25], the updated version may also take into
account negative values, those are not systematically
rounded to zero. ScoreA2 varies from negative values to
1.0 (maximal value).
(c)
ScoreB2 is also used for detection of unknown modiﬁed
sites (also for +/-2 neighboring nucleotides). This score
is highly sensitive and used for conﬁrmation of ScoreA2
detection. Values of ScoreB2 vary from negative values,
and the maximum value is not limited.
0
1
Pi - 1
i
2
ω
ω
n - 1 B
jn
þ
j
jnj
j = i - 2
P
i
2 B
i - 1
@
P
ωj
þ
j = iþ1
i -
P
2
C
ωj
C
j = iþ1
A
Score B2 =
j = i - 2
ni þ 1
where n is the read count at position i, and weight coefﬁcients ω are
0.9 for -2 and + 2 positions and 1.0 for -1 and + 1 nucleotides.
(d) ScoreC2 (also named PsiScore) is not used for the detection of
modiﬁcation candidates but rather for quantiﬁcation of the
modiﬁcation level, since this score shows a linear dependency
between score value and protection of a given nucleotide
against cleavage. Like ScoreA2, ScoreC2 is not rounded to
zero and takes negative values, maximal value is 1.0. Weight
coefﬁcients are the same for ScoreB2 and ScoreC2.
Score C2 =
ni
1
2
Pi - 1
j = i - 2ωjnj
P
i - 1
j = i - 2
ωj
þ
Piþ2
j = iþ1ωjnj
Pi - 2
j = iþ1ωj
0
B
B
@
1
C
C
A
(e) ScoreMean is an additional score that was proposed for the
detection of Nm candidates [27] and applied here for ψ detec-
tion. Calculation of the ScoreMean is illustrated in Fig. 5 for
simulated reads and real proﬁle for yeast 5S rRNA. First,
ratioLeft and ratioRight are calculated for neighboring
nucleotides. At a second step, variation of the ratio at nucleo-
tide n to neighboring positions is used. The ScoreMean is
calculated as the mean value for aroundLeft and aroundRight
(highlighted in more intense colors in Fig. 5).
6. Save the table containing the scores in a .csv ﬁle for later use.

218
Florian Pichot et al.
Fig. 5 Intermediate calculation to obtain ScoreMEAN used for mapping of ψ candidates. Behavior of the
different metrics is shown for ideal simulated U proﬁle (left) and for the S. cerevisiae 5S rRNA. RNAs have the
same length and the same positions for T(U) residues. Formulas used to obtain different proﬁles are shown on
the right. Values of aroundLeft and aroundRight used for calculation of ScoreMEAN (pink) are highlighted by
more intense color
3.7
Data Analysis
Final data analysis pipeline depends on the nature of analyzed RNA
and if the modiﬁcation sites are already identiﬁed and/or validated.
If so, the detection of candidates becomes optional, and analysis can
proceed directly to extraction of the HydraPsiSeq scores (almost
exclusively of PsiScore/ScoreC2) used for quantiﬁcation of the
modiﬁcation level. This extraction is done using the reference list
for RNA modiﬁcations in the species to be considered.
Major steps of this analysis are described below:
1. Extraction and analysis of known modiﬁcation sites.
(a)
Load the list (in *.csv format) containing the known
modiﬁed positions in the RNA of interest.
(b)
Select only type of modiﬁcations to be extracted and
further analyzed (here positions of known Psi residues).
(c)
Merge the scores table with the list by RNA type and
position.

HydraPsiSeq Bioinformatics Pipeline
219
(d)
Generate PsiScore heatmaps for raw and row-normalized
values, by the ggplot2 R package. Save graphs as EPS
or PDF.
2. Mapping of yet unknown modiﬁcation candidates.
(a)
When RNA modiﬁcation proﬁle for a given modiﬁcation
(here for ψ residues) is unknown and has to be estab-
lished, mapping of potential candidate sites is performed
on the basis of “detection” scores, mainly ScoreMean and
ScoreA2. Score B2 can also be used as an additional
parameter to decrease the number of potential false
positives.
(b)
Analysis of rRNA from different sources and construction
of the corresponding ROC curves pointed out that
threshold levels of ScoreMean >0.92 and ScoreA2 >0.5
generally provide a good compromise between selectivity
and speciﬁcity (see Note 10).
(c)
If necessary, threshold levels for ScoreB2 and PsiScore can
be introduced, empirical values to begin with are
ScoreB2 > 2.5 and PsiScore >0.75.
(d)
These recommended combinations of scores allow detec-
tion of highly modiﬁed positions; partial modiﬁcation at a
given site generally gives only low scores, which do not
exceed above-mentioned levels. Thus, partial RNA modi-
ﬁcation with PsiScore< ~ 0.7 escapes identiﬁcation (see
Note 11).
(e)
Detected candidates always require validation by orthog-
onal approaches; therefore, CMCT-based protocol for ψ
mapping can be recommended.
4
Notes
1. Recommended minimal conﬁguration for Linux server used
for data storage, trimming, alignment, and reads’ counting.
Computing power is not the most crucial limiting factor for
HydraPsiSeq data analysis pipeline. Raw read trimming and
alignment can be successfully performed on mid-range Intel-
based servers (e.g., Xeon E5-2630, 6 cores/12 threads,
2.6 GHz, 32 Gb RAM, ~15,000 CPU marks, see https://
www.cpubenchmark.net/ for CPU marks for different proces-
sors) or higher (e.g., 2x Xeon Gold 6226R, 16 cores/32
threads, 2.9 GHz, 128 Gb RAM, ~50,000 CPU marks),
depending on the number of sequencing projects to be treated.
Recommended HDD storage capacity is 10–20 Tb, if possible,
at least a part of the storage capacity should be in SSD format to
accelerate exchange of data. Depending on the computing

220
Florian Pichot et al.
power, trimming of typical raw reads fastq ﬁles takes 2–3 min
for each but may be done in parallel, depending on the number
of available cores. Alignment and counting are the most time-
consuming steps, about 10–15 min/sample, depending on the
length of the RNA reference. Estimations are given here for
rRNA analysis. Of note, the R Studio environment can also be
installed on the Linux server and used via Web interface
(R Studio Server); this greatly improves performance in data
processing at the second step. This can be used as an alternative
to Win10 PC running desktop R/R Studio for data processing.
2. Conﬁguration of a personal computer running R/R Studio is
relatively ﬂexible, almost ordinary mid-range ofﬁce PC can be
successfully used for data analysis. For optimal performance, we
recommend Intel i5/i7-based conﬁgurations with at least
16Gb (better 32 Gb) of RAM and SSD storage.
3. Depending on the RNA origin and the reads length, the sample
clip threshold and MINLENGTH may be adjusted. Here are
some recommended alternatives:
– Combination
of
simple
clip
threshold
10;
MIN-
LENGTH:17
may
be
used
for
very
complex
RNA
references.
– Combination of simple clip threshold 7; MINLENGTH:12
intermediate settings, allowing to reduce the number of
ambiguously mapped short reads.
4. (Optional) If performance issues are found for the Trimmo-
matic step, reduce the number of java threads running in
parallel. This can be done either by treating fastq ﬁles one by
one (with degraded performance) or by starting successive
Trimmomatic threads with delay. The time required is
computer-dependent but should be in a range of seconds
(10–15 s for example).
5. Reference sequence(s) for bowtie2 are stored in a FASTA ﬁle,
but only bowtie2 index ﬁles *.bt2 are used for alignment.
Original FASTA ﬁle containing the reference sequence needs
to be indexed by the bowtie2-build utility.
6. Only 5′-end counts will be used in the HydraPsiSeq data
analysis pipeline. 3′-end counting is conserved for eventual
quality control by manual inspection. Generation of these
3′-count ﬁles may be omitted, but gain in storage volume and
processing time is negligible.
7. A coverage ﬁle contains sequence information for all positions
in RNA, while certain locations may be missing in the 5′-end
counts ﬁle due to insufﬁcient coverage; thus, the coverage ﬁle is
used as a backbone for merge by default. Coverage ﬁle is
generated from a SAM ﬁle and thus has 1 to n coordinate

HydraPsiSeq Bioinformatics Pipeline
221
space, while 5′-end counts are created from a BED format and
positions are numbered from 0 to n-1. This backshift is taken
into account during the merge step and also allows alignment
of HydraPsiSeq signals to the cleaved nucleotides (and not to
N + 1 positions).
8. This normalization algorithm is appropriate for most rRNA
(or tRNA) species since they do not contain over 9 U residues
in a row. However, this may be not true for any randomly taken
RNA, like mRNA, sn/snoRNA or lncRNA. In such cases, the
window can either be extended to the 14–20 nucleotides, or
the last nonzero background value obtained before entering
the U-rich region is used for background normalization. Upon
our experience, these solutions seem to be relatively equivalent.
Similarly, values for the ﬁrst 5 and last 5 positions in RNA are
calculated using the adapted calculation window (1:5) and
(n-4:n), respectively.
9. From this point, protected sites, corresponding to potential
pseudouridylation positions, can be detected by manual inspec-
tion of the NormUcount values and global shape of the Nor-
mUproﬁle obtained from NormUcount by omission of non-U
nucleotides. Naturally occurring pseudouridylation sites in
RNA display a very low cleavage rate due to pseudouridine
protection against hydrazine/aniline cleavage and thus can be
distinguished from unmodiﬁed uridines by low NormUcount
value (< 2). Graphs for NormUproﬁle can be also generated
here for visual inspection of cleavage protection. However, for
more rigorous detection and quantiﬁcation of putative pseu-
douridylated sites, we recommend the use of HydraPsiSeq
scores described below.
10. Combination of scores’ threshold values ScoreMean >0.92
and ScoreA2 >0.5 is recommended for initial inspection and
rather stringent mapping of potential pseudouridylation sites
in unknown RNA. For more relaxed detection allowing to
capture partially modiﬁed candidates, the combination of Scor-
eMean>0.90 and ScoreA2>0.45 can be used. In the case of a
very important number of candidate sites in long RNA refer-
ences, the thresholds for ScoreMean and ScoreA2 can be com-
bined
with
ScoreB2>2.5
and
PsiScore
>0.9.
Such
a
combination gives the most highly conﬁdent candidate sites.
11. Validation of the modiﬁcation candidates in unknown RNA
can be done either by alternative orthogonal technologies
[28], or, better by using unmodiﬁed RNA obtained by
in vitro transcription or, if available, extracted from KO cells
having deleted or inactivated RNA modiﬁcation enzyme. We
found that the use of T7 transcripts may give only partial
validation, since the cleavage proﬁles of native and in vitro
transcribed RNA may be not identical and thus both false-
positives and false-negatives hits are still possible.

222
Florian Pichot et al.
Acknowledgments
This work was supported by ANR grants (MetRibo, D-erase) and
Re´gion Grand Est FRCR grants (EpiARN, ViroMOD) to the V.
M./Y.M., and Deutsche Forschungsgemeinschaft (DFG) grants to
M.H. [HE3397/17-1, SPP1784, and TRR319 RMaP, TP C01].
References
1. Adachi H, De Zoysa MD, Yu Y-T (2019) Post-
transcriptional pseudouridylation in mRNA as
well as in some major types of noncoding
RNAs. Biochim Biophys Acta Gene Regul
Mech 1862(3):230–239. https://doi.org/10.
1016/j.bbagrm.2018.11.002
2. McCown PJ, Ruszkowska A, Kunkler CN et al
(2020) Naturally occurring modiﬁed ribonu-
cleosides. Wiley Interdiscip Rev RNA 11(5):
e1595. https://doi.org/10.1002/wrna.1595
3. Borchardt EK, Martinez NM, Gilbert WV
(2020) Regulation and function of RNA pseu-
douridylation in human cells. Annu Rev Genet
54:309–336.
https://doi.org/10.1146/
annurev-genet-112618-043830
4. Morais P, Adachi H, Yu Y-T (2021) Spliceoso-
mal snRNA epitranscriptomics. Front Genet
12:652129. https://doi.org/10.3389/fgene.
2021.652129
5. Spenkuch F, Motorin Y, Helm M (2014) Pseu-
douridine: still mysterious, but never a fake
(uridine)!
RNA
Biol
11(12):1540–1554.
https://doi.org/10.4161/15476286.2014.
992278
6. Motorin Y, Marchand V (2021) Analysis of
RNA modiﬁcations by second- and third-
generation deep sequencing: 2020 update.
Genes 12(2):278. https://doi.org/10.3390/
genes12020278
7. Westhof E (2019) Pseudouridines or how to
draw on weak energy differences. Biochem
Biophys
Res
Commun
520(4):702–704.
https://doi.org/10.1016/j.bbrc.2019.
10.009
8. Adachi H, DeZoysa MD, Yu Y-T (2019)
Detection and quantiﬁcation of pseudouridine
in RNA. Methods Mol Biol Clifton NJ 1870:
219–235. https://doi.org/10.1007/978-1-
4939-8808-2_17
9. Zhou KI, Clark WC, Pan DW, Eckwahl MJ,
Dai Q, Pan T (2018) Pseudouridines have
context-dependent mutation and stop rates in
high-throughput sequencing. RNA Biol 15(7):
892–900.
https://doi.org/10.1080/
15476286.2018.1462654
10. Durairaj A, Limbach PA (2008) Mass spec-
trometry of the ﬁfth nucleoside: a review of
the identiﬁcation of pseudouridine in nucleic
acids.
Anal
Chim
Acta
623(2):117–125.
https://doi.org/10.1016/j.aca.2008.06.027
11. Addepalli
B,
Limbach
PA
(2011)
Mass
spectrometry-based
quantiﬁcation
of
pseu-
douridine in RNA. J Am Soc Mass Spectrom
22(8):1363–1372. https://doi.org/10.1007/
s13361-011-0137-5
12. Patteson KG, Rodicio LP, Limbach PA (2001)
Identiﬁcation of the mass-silent post-transcrip-
tionally modiﬁed nucleoside pseudouridine in
RNA by matrix-assisted laser desorption/ioni-
zation mass spectrometry. Nucleic Acids Res
29(10):E49–E49. https://doi.org/10.1093/
nar/29.10.e49
13. Helm M, Schmidt-Dengler MC, Weber M,
Motorin Y (2021) General principles for the
detection of modiﬁed nucleotides in RNA by
speciﬁc reagents. Adv Biol 5(10):e2100866.
https://doi.org/10.1002/adbi.202100866
14. Chang SE, Ish-Horowicz D (1974) Selective
modiﬁcation of cytidine, uridine, guanosine
and pseudouridine residues in Escherichia coli
leucine transfer ribonucleic acid. J Mol Biol
84(3):375–388. https://doi.org/10.1016/
0022-2836(74)90446-x
15. Ofengand J, Del Campo M, Kaya Y (2001)
Mapping pseudouridines in RNA molecules.
Methods (San Diego Calif) 25(3):365–373.
https://doi.org/10.1006/meth.2001.1249
16. Carlile TM, Rojas-Duran MF, Zinshteyn B,
Shin H, Bartoli KM, Gilbert WV (2014) Pseu-
douridine proﬁling reveals regulated mRNA
pseudouridylation in yeast and human cells.
Nature 515(7525):143–146. https://doi.
org/10.1038/nature13802
17. Lovejoy AF, Riordan DP, Brown PO (2014)
Transcriptome-wide mapping of pseudouri-
dines: pseudouridine synthases modify speciﬁc
mRNAs in S. cerevisiae. PLoS One 9(10):
e110799. https://doi.org/10.1371/journal.
pone.0110799
18. Schwartz S, Bernstein DA, Mumbach MR et al
(2014) Transcriptome-wide mapping reveals

HydraPsiSeq Bioinformatics Pipeline
223
widespread dynamic-regulated pseudouridyla-
tion of ncRNA and mRNA. Cell 159(1):
148–162. https://doi.org/10.1016/j.cell.
2014.08.028
19. Sas-Chen
A,
Nir
R,
Schwartz
S
(2021)
mito-Ψ-Seq: a high-throughput method for
systematic mapping of Pseudouridine within
mitochondrial RNA. Methods Mol Biol Clif-
ton NJ 2192:103–115. https://doi.org/10.
1007/978-1-0716-0834-0_9
20. Zhang W, Eckwahl MJ, Zhou KI, Pan T (2019)
Sensitive and quantitative probing of pseu-
douridine modiﬁcation in mRNA and long
noncoding
RNA.
RNA
25(9):1218–1225.
https://doi.org/10.1261/rna.072124.119
21. Bakin A, Ofengand J (1993) Four newly
located pseudouridylate residues in Escherichia
coli 23S ribosomal RNA are all at the peptidyl-
transferase center: analysis by the application of
a new sequencing technique. Biochemistry
32(37):9754–9762
22. Massenet S, Motorin Y, Lafontaine DL, Hurt
EC, Grosjean H, Branlant C (1999) Pseudour-
idine mapping in the Saccharomyces cerevisiae
spliceosomal U small nuclear RNAs (snRNAs)
reveals that pseudouridine synthase pus1p
exhibits a dual substrate speciﬁcity for U2
snRNA and tRNA. Mol Cell Biol 19(3):
2142–2154
23. Marchand V, Pichot F, Neybecker P et al
(2020) HydraPsiSeq: a method for systematic
and quantitative mapping of pseudouridines in
RNA. Nucleic Acids Res 48(19):e110. https://
doi.org/10.1093/nar/gkaa769
24. Marchand V, Bourguignon-Igel V, Helm M,
Motorin Y (2021) Analysis of pseudouridines
and other RNA modiﬁcations using HydraPsi-
Seq protocol. Methods (San Diego Calif) 203:
383–391. https://doi.org/10.1016/j.ymeth.
2021.08.008
25. Birkedal
U,
Christensen-Dalsgaard
M,
Krogh N, Sabarinathan R, Gorodkin J, Nielsen
H (2015) Proﬁling of ribose methylations in
RNA by high-throughput sequencing. Angew
Chem Int Ed Engl 54(2):451–455. https://
doi.org/10.1002/anie.201408362
26. Pichot F, Marchand V, Ayadi L, Bourguignon-
Igel V, Helm M, Motorin Y (2020) Holistic
optimization of Bioinformatic analysis pipeline
for detection and quantiﬁcation of 2′-O-
methylations in RNA by RiboMethSeq. Front
Genet 11:38. https://doi.org/10.3389/
fgene.2020.00038
27. Marchand V, Blanloeil-Oillo F, Helm M,
Motorin Y (2016) Illumina-based RiboMeth-
Seq approach for mapping of 2′-O-Me residues
in RNA. Nucleic Acids Res 44(16):e135.
https://doi.org/10.1093/nar/gkw547
28. Helm M, Motorin Y (2017) Detecting RNA
modiﬁcations in the epitranscriptome: predict
and validate. Nat Rev Genet 18(5):275–291.
https://doi.org/10.1038/nrg.2016.169

Chapter 15
Analysis of RNA Sequences and Modiﬁcations Using NASE
Samuel Wein
Abstract
Mass spectrometry is an ideal method for the discovery and characterization of modiﬁed RNAs. Unlike
other traditional sequencing methods, mass spectrometry can identify and localize multiple types of
modiﬁcations in tandem. One of the traditional hurdles to using this powerful technique has been a paucity
of software to interpret the complicated data produced by these experiments. Here I describe how to use
the NucleicAcidSearchEngine (NASE), a component of OpenMS as well as best practices for acquiring
RNA data, and potential pitfalls in the analysis process.
Key words RNA, Mass spectrometry, Transcriptomics, OpenMS
1
Introduction
“Traditional-RNA” sequencing requires the ampliﬁcation of the
input material by rtPCR. While the downstream sequencing pro-
cesses are high throughput, they ignore any chemical modiﬁcations
on the sample RNA that do not add or remove bases. Techniques
such as bisulﬁte sequencing have been developed to locate speciﬁc
modiﬁcations [1], but these are powerless to look at the
co-occurrence of multiple different types of modiﬁcations. Since
mass spectrometry is agnostic to modiﬁcation chemistry and analy-
sis does not require an ampliﬁcation step, mass spectrometry has
been identiﬁed as a helpful method for RNA modiﬁcation analysis
in micro RNAs [2], transfer RNAs [3], and ribosomal RNAs
[4]. There are two main classes of RNA mass spectrometry
[5]. The ﬁrst relies on hydrolyzing the RNA down to single nucleo-
tides and then treating the nucleotides with a phosphatase to
produce nucleosides; the result is a mix of the different nucleosides
(along with their modiﬁcations) that were present in the sample.
While this technique is very useful, it does not provide any infor-
mation about where the modiﬁcations occur; since this is very
important information for a variety of studies, a more complicated
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_15,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
225

226
Samuel Wein
but more informative method has arisen. The second method is to
ionize intact or minimally digested oligonucleotides. The mass of
these oligonucleotides is then measured, they are fragmented, and
the mass of the fragments is again measured. Since the patterns by
which they fragment are known, it is possible to then reconstruct
the fragment masses into a sequence, cognizant of any modiﬁcation
mass shifts. Unfortunately, the fragmentation patterns are complex,
and the results of any nontrivial experiment very quickly become
impossible to analyze by hand. Several software packages have been
developed over the years to address this complexity, including SOS
[6], Ariadne [7], Oma and Opa [8], RNAModMapper [9], and the
NucleicAcidSearchEngine (NASE) [10]. The latter is currently the
fastest and most feature-rich among the existing software, and in
this chapter, I will discuss how to fully explore its capabilities.
NASE works by taking the nucleic acid sequences from a
FASTA input ﬁle and either digesting them according to an enzyme
pattern or loading the full sequences into memory. It then calcu-
lates the theoretical mass of the resultant sequence. If dynamic
modiﬁcations are speciﬁed, it adds in all the potential options for
dynamic modiﬁcations. It then takes the resulting list of masses and
compares each entry to the precursor masses for each MS2 scan in
the experimental ﬁles. If theoretical masses of an oligonucleotide
match a precursor mass, NASE generates its theoretical spectrum.
The theoretical spectrum is composed of all possible fragment
peaks and compares these peaks to the peaks in the MS2 scan,
returning a score to represent how good of a ﬁt the match is.
NASE can be used for a variety of applications, from conﬁrming
that in vitro modiﬁcations to a therapeutic RNA occurred at the
intended location, to the discovery of novel modiﬁcation sites on
extracted cellular RNA. NASE was initially developed to search for
modiﬁcations on miRNA extracted from cells. Since it can identify
multiple types of modiﬁcation on the same molecule, it is useful for
this as well as other types of RNA analysis. We demonstrated
(20) the applicability of NASE to tRNA, rRNA, and mRNA with
prior digestion by site-speciﬁc ribonucleases and are currently in the
process of demonstrating that with the proper analytical settings,
we can sequence entire undigested tRNA. NASE has also found
demand in analyzing synthetic RNAs for therapeutic uses. Unlike
other tools, NASE can determine the rates of co-occurrence of
multiple modiﬁcations, something that is of increasing interest to
the medical ﬁeld. Given the ﬂexibility of NASE, we envision that
there are a multitude of other applications that we have not fore-
seen and hope to continue developing the software for the foresee-
able future.

Analysis of RNA Sequences and Modiﬁcations Using NASE
227
2
Materials
The analytical preparation of RNA for tandem mass spectrometry is
outside of the scope of this work for a comprehensive treatment on
this part of the process, please see [11].
Input ﬁles needed:
•
A FASTA formatted ﬁle containing the sequences that you are
searching for.
– A simple example ﬁle is included as a supplement to this
chapter.
– This ﬁle must contain one or more two-line entries. The ﬁrst
line of each entry is the identiﬁer and starts with a > followed
by a custom identiﬁer. Each of these must be unique and can
contain letters, numbers, and underscores but not white-
space. The second line is the expected sequence of the
RNA, as a string with no spaces.
– NASE recognizes the canonical ribonucleotides A C G U as
well as Modomics “Short Name” codes contained in brack-
ets, for example, 1,2′-O-dimethylinosine is represented as
[m1Im].
– A more complete description of the FASTA format can be
found on the NCBI’s website (https://www.ncbi.nlm.nih.
gov/BLAST/fasta.shtml).
•
One or more MzML (https://www.psidev.info/mzML) ﬁles
containing data from an experiment.
– MzML is the open standard for storing mass spectrometry
experiments; there are many ways to convert vendor raw ﬁles
into MzML, probably the easiest is with MSConvert, one of
the tools included in ProteoWizard (https://proteowizard.
sourceforge.io/download.html).
– Each MzML ﬁle must contain one or more MS2 scans repre-
senting fragmented RNAs. Each MS2 scan must include the
precursor mass that is the mass of the unfragmented ion
being analyzed. MS1 survey scans may be included but are
not used by NASE at this time.
•
A simple set of example data is available in PRIDE at https://
www.ebi.ac.uk/pride/archive/projects/PXD012094; this set
contains both an mzML experiment ﬁle and a FASTA ﬁle, as
well as an idXML ﬁle with the results of the authors’ analysis.

228
Samuel Wein
3
Methods
Output ﬁles produced (see Fig. 1):
•
NASE itself produces three main types of output ﬁles. One of
these,
MZTab,
is
mandatory,
with
identiﬁcation
output
(idXML) and label-free quantiﬁcation output (tsv) being
optional.
•
NASE’s outputs can be coupled with other tools within the
OpenMS ecosystem to ask more complicated questions. For
example, NASE outputs ﬁles that can be fed into our Feature-
FinderMetaboIdent
software
to
perform
label-free
quantiﬁcation.
•
NASE generates mzTab output based on the mzTab standard
(https://www.psidev.info/mztab#mzTab_1_0) but with cus-
tom Line preﬁxes (we are working with HUPO-PSI to get
support for nucleic acids added to their standard, but it’s not
there yet). The ﬁle consists of several tab-delineated tables; the
ﬁrst (MTD) is metadata, the second (NUH, NUC) is the whole
oligonucleotide (equivalent to a protein identiﬁcation), the third
(OLH, OLI) has the subsequences observed (equivalent to
peptide identiﬁcations), and the fourth (OSH, OSM) has the
actual spectral matches; for this table, the search_engine_score
[1] is the hyperscore from NASE, search_engine_score [2] is the
FDR level, and modiﬁcations show any dynamic mods that are
found in that spectra, opt_isotope_offset reports if an isotope
offset was used (NASE has a feature to correct precursor masses
based on the possibility of the non-mono-isotopic peak being
selected for fragmentation).
•
Secondly, NASE can produce idXML output ﬁles. This is an
identiﬁcation format that we use internally for OpenMS and
can be viewed with TOPPViewer. We do have an IDFileConver-
ter that can convert idXML ﬁles into standard mzident ﬁles.
•
Optionally, if generating label-free quantitation data, output is
in FeatureXML ﬁles (which can be read by TOPPView) and
NucleicAcid
SearchEngine
workflow
MzML
fasta
mzTab
IdXML
(optional)
Fig. 1 Schematic of basic ﬁle ﬂow through NucleicAcidSearchEngine

Analysis of RNA Sequences and Modiﬁcations Using NASE
229
tab-separated value ﬁles, which can be read by Excel, or loaded
into any standard data processing system.
Software required:
•
OpenMS.
– There are a couple of different ways to use OpenMS. An
installer for the software package itself can be found online
(https://github.com/OpenMS/OpenMS/releases)
for
Linux, MacOS, or Windows. This package provides the
libraries and software tools necessary to run either as
command-line programs, to build workﬂows with OpenMS’
built in workﬂow manager TOPPAS, and to view OpenMS
compatible ﬁles with TOPPView. OpenMS can also be
installed as an add-on to the analytics platform KNIME
(https://www.knime.com/downloads/download-knime),
OpenMS tools can also be used as part of the online service
Galaxy (https://usegalaxy.eu/), and selected pipelines can be
used inside NF-Core (https://www.openms.de/getting-
started/creating-workﬂows/). In this work, we will describe
the process of constructing an oligonucleotide MS workﬂow
using TOPPAS. A screenshot of the UI can be found in
Fig. 2.
3.1
Building a
Workﬂow
OpenMS contains a number of different tools for handling a wide
variety of workﬂows. Each tool takes one or more ﬁles as input has a
set of conﬁgurable parameters and produces one or more ﬁles as
output. In TOPPAS, the tools are listed at the left of the window in
the TOPP pane (if this pane is missing or has been closed it can be
re-enabled in the windows menu). Tools are divided into submenus
roughly by usage (though a large number of newer tools of all
categories are under the generic Utils label). There are also ﬁve
special tools with names in angled brackets (e.g., <input ﬁles>),
and these represent generic operations on ﬁles. Tools can be added
from the TOPP menu to the workﬂow either by double-clicking on
the tool name or by clicking and dragging into the center pane.
Connections between tools are represented by arrows, and they are
established by clicking and dragging from one tool node to another
(NB: clicking on a node without dragging highlights the node
allowing you to click again and drag to move the node. To clear
the highlighted node, click on the white background). An arrow is
created between the two nodes, and if there are multiple connec-
tions that could be made, a pop-up appears prompting the user to
select which output maps to which input (Fig. 3).

230
Samuel Wein
Fig. 2 TOPPAS interface
3.2
The Minimal
NASE Workﬂow
A minimal NASE search workﬂow (Fig. 4) can be created with just
two
<input file> nodes, the
NucleicAcidSearchEngine
node, and 1 <output file> node.
1. Place all of these nodes into the workspace (either by double-
clicking or clicking and dragging).
2. Connect the ﬁrst <input file> node to the NucleicAcid-
SearchEngine node by clicking and dragging from the input
node to the
NucleicAcidSearchEngine node. In the
input/output mapping pop-up select “File: Database [fasta]”
and click okay.
3. Double-click on the <input file> node and add your FASTA
ﬁle to search against.

Analysis of RNA Sequences and Modiﬁcations Using NASE
231
Fig. 3 TOPPAS dialog for connecting inputs and outputs
4. Repeat with the other input node (no pop-up should appear for
this one, since there is only one more possible input to
NucleicAcidSearchEngine.
5. Double-click on the second input ﬁle node and add all of the
MzML ﬁles from your experiment. If you have included more
than one MzML ﬁle, you must right-click on the FASTA input
ﬁle node and “Toggle Recycle Mode” so that the FASTA ﬁle is
reused over all your MzML ﬁles.
6. Connect the NucleicAcidSearchEngine to the <output
file> node. Select “File: Out [mzTab]” in the pop-up.
[Optional: add a second <output file> node and hook it
to “File: id_out [idXML]” to produce TOPPView viewable
output].
7. Double-click on the NucleicAcidSearchEngine node to
see all the conﬁguration options (see inset box for NASE
conﬁguration options). Make your conﬁguration decisions
and click “Okay.”
8. In the Pipeline menu, select run (or hit f5), select an output
directory, and select the number of processes to run in parallel.
Hit “Okay,” and wait for the software to run. Output ﬁles can
be found quickly by right-clicking on the output nodes and
clicking “Open containing folder” (Fig. 4).

232
Samuel Wein
Fig. 4 Visual representation of the core workﬂow
3.3
Adding Decoys
The minimal workﬂow above does not calculate what portion of
results are likely unreliable. Since NASE happily scores any identiﬁ-
cation that matches the precursor mass, users should establish a
cutoff score below which any identiﬁcation is discarded. To aid in
making these decisions, NASE includes support for target-decoy-
based false discovery rate calculation. To enable this decoy feature,
an additional tool, the DecoyDatabase, is added between the
FASTA input ﬁle node and the NucleicAcidSearchEngine
node (Fig. 5). The decoy_pattern in the NASE conﬁguration then
needs to be set.
1. Place all of these nodes into the workspace (either by double-
clicking of clicking and dragging).
2. Connect the ﬁrst input ﬁle node to the DecoyDatabase node
by clicking and dragging from the input node to the
DecoyDatabase node.
3. Connect the DecoyDatabase node to the NucleicAcid-
SearchEngine node, by clicking and dragging from the
DecoyDatabase node to the NucleicAcidSearchEngine

Analysis of RNA Sequences and Modiﬁcations Using NASE
233
Fig. 5 Visual representation of workﬂow with decoys. Note that the recycling (♻)
symbol appears in the DecoyDatabase node, to show that recycling mode is on
node. In the input/output mapping pop-up, select “File: Data-
base [fasta]” and click okay.
4. Double-click on the input-ﬁle node and add your FASTA ﬁle to
search against.
5. Double-click on the
DecoyDatabase node select “type”
“RNA” and “method” “shufﬂe.”
6. Connect the other input node to the NucleicAcidSearch-
Engine by clicking and dragging (no pop-up should appear for
this one, since there is only one more possible input to
NucleicAcidSearchEngine).
7. Double-click on the second input ﬁle node and add all of the
MzML ﬁles from your experiment. If you have included more
than one MzML ﬁle, you must right-click on the DecoyData-
base node and “Toggle Recycle Mode” so that the FASTA ﬁle
is reused over all your MzML ﬁles.

234
Samuel Wein
8. Connect the NucleicAcidSearchEngine to the output ﬁle
node. Select “File: Out [mzTab]” in the pop-up. [Optional:
add a second output ﬁle node and hook it to “File: id_out
[idXML]” to produce TOPPView viewable output].
9. Double-click on the NucleicAcidSearchEngine node to
see all the conﬁguration options (see inset box for NASE
conﬁguration options). Make your conﬁguration decisions
and click Okay. Be sure to set the decoy_pattern to the string
used in DecoyDatabase (by default “DECOY_”).
10. In the Pipeline menu select run (or hit f5), select an output
directory, and select the number of processes to run in parallel.
Hit “Okay” and wait for the software to run. Output ﬁles can
be found quickly by right-clicking on the output nodes and
clicking “Open containing folder.”
3.4
Adding Label-
Free Quantitation
NASE produces qualitative output on its own; however, it can be
coupled to other OpenMS tools to perform label-free quantiﬁca-
tion. To accomplish this, we add a FeatureFinderMetaboIdent
tool, which takes the lfq_out output from the NucleicAcid-
SearchEngine as well as the input mzML ﬁles, ﬁnds features
corresponding to the identiﬁcations from NASE, and produces
featureXML output. For ease of processing with downstream infor-
matics tools, the output from FeatureFinderMetaboIdent can
be further parsed into a tab-separated value format using TextEx-
porter. See a schematic version of the workﬂow in Fig. 6 below.
Fig. 6 Visual representation of workﬂow with label-free quantiﬁcation

Analysis of RNA Sequences and Modiﬁcations Using NASE
235
1. Follow instructions for either the minimal workﬂow, or the
adding decoys workﬂow up to the run step.
2. Add a FeatureFinderMetaboIdent node, a TextExpor-
ter node, and two output ﬁle nodes by clicking and dragging.
3. Connect NucleicAcidSearchEngine directly to Feature-
FinderMetaboIdent selecting the File: lfq_out [tsv] as the
source and File: id [tsv] as the target.
4. Connect the mzML input ﬁle to FeatureFinderMetaboI-
dent (no pop-up should appear for this one, since there is only
one more possible input to the tool).
5. Connect FeatureFinderMetaboIdent to TextExporter,
selecting File: out [featureXML] as the source and File: in [. . .]
as the target.
6. Connect FeatureFinderMetaboIdent to one of the output
ﬁle nodes, selecting File: out [featureXML] as the source.
7. Connect
TextExporter to the other output ﬁle node,
selecting File: out [. . .] as the source.
8. Double-click on TextExporter and set feature:add_metava-
lues to 0.
9. In the Pipeline menu select run (or hit f5), select an output
directory, and select the number of processes to run in parallel.
Hit “Okay” and wait for the software to run. Output ﬁles can
be found quickly by right-clicking on the output nodes and
clicking “Open containing folder.”
4
Notes
Conﬁguring NASE correctly for your data is the most impactful
thing that you can do during the analysis process to improve out-
comes. A ﬁgure of the parameter conﬁguration window can be seen
below in Fig. 7. NASE is by design very ﬂexible; the optimal
parameters for things like mass tolerance and charge depend on
the instrument that you are using, potential adducts are dependent
on sample preparation, and the number of processing threads is
determined by your computational hardware. Parameters are
divided into different categories. Precursor parameters concern
the tolerance and charge of the precursor as well as any chemical
adducts that may be present in your data. Fragment parameters
have to do with the tolerance of the MS2 products as well as which
ion types to look for. Modiﬁcation parameters consist of what
variable modiﬁcations to look for, as well as how many can occur
on each sequence. Oligo parameters deal with the digestion of

236
Samuel Wein
Fig. 7 The user interface window for NucleicAcidSearchEngine settings
sequences listed in the FASTA ﬁle and what size of sequences to
look for. FDR parameters are how to handle the target decoy search
(if desired) against your experimental data. All parameters are
described along with notes on how to best use them in detail in
Table 1.

(continued)
Analysis of RNA Sequences and Modiﬁcations Using NASE
237
Table 1
The full list of options for NASE
Threads
The number of threads to allocate for each NASE process.
The product of this value and the Max. Jobs run option
should be less than or equal to the number of threads in
your computer
no_progress
Whether to output progress during the search. Leave on true
when not debugging
Precursor
Mass_tolerance
The amount of tolerance to allow when matching precursor
masses to putative oligonucleotides (either in ppm or
Dalton, depending on mass_tolerance_unit). This should
be set no lower than the resolution of your instrument.
The higher you set it, the less selective the parent mass
selection step is, and the more nonspeciﬁc matches you
will get
Mass_tolerance_unit
Whether mass_tolerance should be interpreted as ppm or
daltons
Min_charge
The lowest (that is least charged) charge to look for. Set this
to negative for negative mode data. This should not be set
lower than the minimum charge that you expect in your
data (by inspection of experimental output, or calculation
what the lowest charge that would ﬁt in your M/Z scan
range for your smallest possible oligo)
Max_charge
The highest (that is most charged) charge to look for. Set this
to negative for negative mode data. This should not be set
higher than the maximum charge that you expect in your
data (by inspection of experimental output, or calculation
what the lowest charge that would ﬁt in your M/Z scan
range for your smallest possible oligo)
Include_unknown_charge Whether to search precursor masses for which there was no
charge recorded. This is dependent on the instrument you
are using, and how good its built-in charge detection is. In
the author’s experience, the higher the charge, the worse
instruments are at tagging it correctly. If set to true, NASE
calculates whether the precursor mass matches any
oligonucleotide for any charge between min_charge and
max_charge
Use_avg_mass
Whether to look for the average isotopic mass or
monoisotopic mass for each oligo. The use of this feature is
dependent on how your data was acquired. Depending on
the instrument, the precursor mass recorded in your MS2s
may be either the center of the acquisition window, and
the most abundant isotope, or a calculated monoisotopic
peak. Look at your data to ﬁnd out
Use_adducts
Whether to look for adducts from the potential_adducts list.
See notes on potential_adducts for guidance on whether
to use this
Potential_adducts
A list of adducts to search for in your data. These are each
formatted as “elemental composition”: “Charge.” the
choice of adducts (and whether to search for them at all)
should be dependent on whether you see characteristic
MS1 peaks in your experiment separated by X/z where X is
the putative mass of the adduct

Table 1
(continued)
238
Samuel Wein
(continued)
Isotopes
A list of monoisotopic peak misassignments to search for
(only if use_avg_mass is off). Certain manufacturer
instruments have a propensity to misassign the
monoisotopic peak for oligonucleotides, and this setting
expands the search to include the peaks of (m + x)/z where
x is numbers in the isotope list. This value can also be
negative to handle the case where the precursor mass is
incorrectly assigned to (m-1)/z. typical contents are
0 and 1
Fragment
Mass_tolerance
The tolerance to allow between theoretical masses for oligo
fragments and the experimental peaks in the MS2
spectrum. This should be set dependent on the resolution
of your MS2 scans. NB trial and error has shown that the
mass inaccuracies for low-intensity MS2 peaks can be
substantially above the nominal mass accuracy of the
instrument. Also note the oversetting this parameter can
lead to lots of false hits.
Mass_tolerance_units
Whether the fragment mass_tolerance value should be
interpreted in daltons or ppm
Ions
Fragmentation of oligonucleotides can produce nine
different fragment types. With HCD fragmentation of
RNA, we have found that all nine appear regularly;
however, this is not necessarily the case for other
fragmentation types. As a rule, don’t change these unless
you are using an alternative fragmentation type
Modiﬁcations Variable
A list of modiﬁcation that you believe may occur in your
sample. Names are taken from Modomics short names. See
https://genesilico.pl/modomics/modiﬁcations for a list
of mods. NB: These are only for modiﬁcations where the
location is not known ahead of time and included in the
FASTA input. Increasing the number of different possible
dynamic modiﬁcations greatly increases the search space
and the run-time of NASE
Variable_max_per_oligo
The maximum number of dynamic modiﬁcations to search
for in each product oligonucleotide. Increasing this greatly
increases run-time. Increasing this number above 4 is not
recommended for non-HPC use cases
Resolve_ambiguities
Whether to attempt to resolve ambiguous modiﬁcations
where possible (for example whether mA? Is actually mA
or am) based on whether the modiﬁcation mass is lost in
the a-B ions (requires a-B ions to be enabled). Typically,
should be left off unless you have speciﬁc modiﬁcations
that you want to sub-localize to either base or sugar
Oligo
Min_size
Minimum length of oligonucleotide to search for. Typically
left at 5 as shorter oligo’s have very few possible fragment
peaks
Max_size
Maximum length of oligonucleotide to look for. Leave at
0 to not use an upper length limit.

Table 1
Analysis of RNA Sequences and Modiﬁcations Using NASE
239
(continued)
Missed_cleavages
How many sites to allow enzyme to miss cleavage at?
Dependent on the enzyme and preparation of sample
Enzyme
Select which enzyme to use as a digestion enzyme for your
sequences in the FASTA ﬁle. See box about adding new
enzymes for more info
Fdr
Decoy_pattern
If your input FASTA ﬁle contains decoys (e.g., generated by
an upstream DecoyDatabase node), what substring should
be used to distinguish which entries are decoys?
Cutoff
What cutoff to use for FDR ﬁltering
Remove_decoys
Whether to remove decoys which fall below the FDR cutoff
from the ﬁnal output
References
1. Gilbert WV, Bell TA, Schaening C (2016) Mes-
senger RNA modiﬁcations – form, distribu-
tion, and function. Science 352:1408–1412.
https://doi.org/10.1126/science.aad8711
2. Kullolli M, Knouf E, Arampatzidou M et al
(2014) Intact MicroRNA analysis using high
resolution mass spectrometry. J Am Soc Mass
Spectrom 25:80–87. https://doi.org/10.
1007/s13361-013-0759-x
3. Hossain
M,
Limbach
PA
(2007)
Mass
spectrometry-based
detection
of
transfer
RNAs by their signature endonuclease diges-
tion products. RNA 13:295–303. https://doi.
org/10.1261/rna.272507
4. Taoka M, Nobe Y, Yamaki Y et al (2016) The
complete chemical structure of Saccharomyces
cerevisiae rRNA: partial pseudouridylation of
U2345 in 25S rRNA by snoRNA snR9.
Nucleic Acids Res 44:8951–8961. https://
doi.org/10.1093/nar/gkw564
5. Giessing AMB, Kirpekar F (2012) Mass spec-
trometry in the biology of RNA and its mod-
iﬁcations. J Proteome 75:3434–3449. https://
doi.org/10.1016/j.jprot.2012.01.032
6. Rozenski J, McCloskey JA (2002) SOS: a sim-
ple interactive program for ab initio oligonu-
cleotide sequencing by mass spectrometry. J
Am Soc Mass Spectrom 13:200–203. https://
doi.org/10.1016/S1044-0305(01)00354-3
7. Nakayama H, Akiyama M, Taoka M et al
(2009) Ariadne: a database search engine for
identiﬁcation and chemical analysis of RNA
using tandem mass spectrometry data. Nucl
Acids Res 37:e47–e47. https://doi.org/10.
1093/nar/gkp099
8. Nyakas A, Blum LC, Stucki SR et al (2012)
OMA and OPA—Software-supported mass
spectra analysis of native and modiﬁed nucleic
acids. J Am Soc Mass Spectrom 24:249–256.
https://doi.org/10.1007/s13361-012-
0529-1
9. Yu N, Lobue PA, Cao X, Limbach PA (2017)
RNAModMapper: RNA modiﬁcation mapping
software for analysis of liquid chromatography
tandem mass spectrometry data. Anal Chem
89:10744–10752. https://doi.org/10.1021/
acs.analchem.7b01780
10. Wein S, Andrews B, Sachsenberg T et al (2020)
A computational platform for high-throughput
analysis of RNA sequences and modiﬁcations
by mass spectrometry. Nat Commun 11:926.
https://doi.org/10.1038/s41467-020-
14665-7
11. Hagelskamp F, Kellner S (2021) Analysis of the
epitranscriptome with ion-pairing reagent free
oligonucleotide mass spectrometry. Methods
Enzymol 658:111–135. https://doi.org/10.
1016/bs.mie.2021.06.024

Chapter 16
Mapping of RNA Modiﬁcations by Direct Nanopore
Sequencing and JACUSA2
Amina Lemsara, Christoph Dieterich, and Isabel S. Naarmann-de Vries
Abstract
RNA modiﬁcations exist in all kingdom of life. Several different types of base or ribose modiﬁcations are
now summarized under the term “epitranscriptome.” With the advent of high-throughput sequencing
technologies, much progress has been made in understanding RNA modiﬁcation biology and how these
modiﬁcations can inﬂuence many aspects of RNA life. The most widespread internal modiﬁcation on
mRNA is m6A, which has been implicated in physiological processes as well as disease pathogenesis.
Here, we provide a workﬂow for the mapping of m6A sites using Nanopore direct RNA sequencing data.
Our strategy employs pairwise comparison of basecalling error proﬁles with JACUSA2. We outline a general
strategy for RNA modiﬁcation detection on mRNA and describe two speciﬁc use cases on m6A detection in
detail. Use case 1: a sample of interest with modiﬁcations (e.g., “wild-type” sample) is compared to a
sample lacking a speciﬁc modiﬁcation type (e.g., “knockout” sample, here METTL3-KO) or Use case 2: a
sample of interest with modiﬁcations is compared to a sample lacking all modiﬁcations (e.g., in vitro
transcribed cDNA). We provide a detailed protocol on experimental and computational aspects. Extensive
online material provides a snakemake pipeline to identify m6A positions in mRNA and to validate the results
against a miCLIP-derived m6A reference set. The general strategy is ﬂexible and can be easily adapted by
users in different application scenarios.
Key
words Epitranscriptome,
RNA
modiﬁcation,
Nanopore,
Direct
RNA-seq,
Prediction,
Snakemake
1
Introduction
Chemical modiﬁcations on DNA and histones, also known as epi-
genetics marks, strongly impact gene expression during cell differ-
entiation and in several other biological programs [1]. In the
1970s, it was recognized that RNA is also subjected to extensive
covalent modiﬁcation, and studies in the late 1980s revealed the
widespread deamination of bases (termed RNA editing), which can
lead to recoding if it occurs within coding sequences [2]. Impressive
development in the RNA modiﬁcation ﬁeld occurred during the
past eight years, with the discovery of an extensive layer of base
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8_16,
© The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer Nature 2023
241

242
Amina Lemsara et al.
modiﬁcations in mRNAs [3–5]. These can inﬂuence gene expres-
sion and have been already shown to be involved in primary cellular
programs such as stem cell differentiation, response to stress, and
the circadian clock. The study of RNA modiﬁcations and their
effects is now referred to as epitranscriptomics, and it reveals
striking similarities to what is known as epigenomics. To date,
13 distinct modiﬁcations have been identiﬁed on mRNA transcripts
[6]. These modiﬁcations are catalyzed by a variety of dedicated
enzymes and can be divided into two classes: modiﬁcations of
cap-adjacent nucleotides and internal modiﬁcations.
In contrast to the m7G cap, the impact of internal modiﬁca-
tions on gene regulation has been less studied apart from RNA
editing, which is mediated by RNA deaminases (e.g., the ADAR
family). The most widespread internal mRNA modiﬁcation is
N6-methyladenosine (m6A). By modulating the processing of
mRNA, m6A can regulate a wide range of physiological processes,
and its alteration has been linked to several diseases [7–9]. The
modiﬁcation is catalyzed co-transcriptionally by a megadalton
methyltransferase
complex,
which
includes
the
heterodimer
METTL3-METTL14 and other associated subunits [10]. This
modiﬁcation is reversible since two proteins of the AlkB-family of
demethylases can remove m6A from mRNA transcripts [11, 12]. In
mammals, m6A preferentially localizes within long internal exons
and at the beginning of terminal exons at so-called DRACH motif
(D = A/G/U, R = A/G, H = A/C/U) sites [13–15]. Once
deposited, m6A is recognized by several reader proteins that can
affect the fate of mRNA transcripts in nearly every step of the
mRNA life cycle, including alternative splicing [5, 16], mRNA
translation [17], and decay [5, 18, 19]. The best-described readers
are the YTH domain family of proteins that decode the signal and
mediate m6A functions. By affecting RNA structure, m6A can also
indirectly inﬂuence the association of additional RNA-binding pro-
teins (RBPs) and the assembly of larger messenger ribonucleopro-
tein particles (mRNPs) [20].
Several approaches have been presented to map RNA modiﬁca-
tions on RNA. Herein, we focus on mRNA modiﬁcation site detec-
tion in general and on m6A in particular where antibody-based
protocols (miCLIP), methylation-sensitive restriction enzyme
assays (MazF), or transgenic approaches (TRIBE, DART) have
been presented to map m6A sites. All of the aforementioned
approaches rely on high-throughput short-read sequencing on
the Illumina platform. This typically involves cDNA synthesis by
reverse transcription and PCR-based library ampliﬁcation. One
recent addition to the toolbox of RNA modiﬁcation mapping is
direct RNA single-molecule long-read sequencing on the Oxford
Nanopore Technologies (ONT) platform (dRNA-seq). While our
software is able to deal with Illumina and Nanopore-based
approaches, the latter is the principal topic of this method article.

JACUSA2 Detects RNA Modiﬁcations in Direct RNA-seq
243
2
Materials
2.1
ONT Direct RNA
Sequencing
This section summarizes all necessary consumables for direct RNA
sequencing of poly-adenylated RNA (i.e., mRNA) on the MinION
or similar device.
1. 500 ng polyA+ RNA isolated from total RNA, for example,
with Oligotex mRNA kit (#70022, Qiagen) or Dynabeads
oligo dT25 beads (#61002, Thermo Fisher Scientiﬁc) or
in vitro transcriptome sample. Store RNA at -80 ∘C and the
mRNA puriﬁcation kit as recommended by the manufacturer.
2. Nuclease-free water. Store at room temperature.
3. Direct RNA-sequencing kit (SQK-RNA002, Oxford Nano-
pore Technologies). Store at -20 ∘C.
4. NEBNext Quick Ligation Reaction Buffer (#B6058S, New
England Biolabs). Store at -20 ∘C.
5. T4 DNA Ligase (#M0202S, New England Biolabs). Store at -
20 ∘C.
6. dNTP Mix (10 mM each, #R0191, Thermo Fisher Scientiﬁc).
Store at -20 ∘C.
7. SuperScript IV Reverse Transcriptase (#18090010, Thermo
Fisher Scientiﬁc). Store at -20 ∘C.
8. Agencourt RNAClean XP beads (#A63987, Beckman Coul-
ter). Store at 4∘C.
9. 70% ethanol, freshly prepared.
10. Qubit dsDNA HS assay kit (#Q32854) and Qubit Fluorome-
ter (Thermo Fisher Scientiﬁc).
11. Flow cell priming kit (EXP-FLP002, Oxford Nanopore Tech-
nologies). Store at -20 ∘C.
12. Thermocycler.
13. Gentle rotator mixer.
14. Magnetic stand for 1.5 mL tubes.
15. 1.5 mL DNA LoBind tubes (Eppendorf), 0.2 mL PCR tubes.
16. MinION or GridION sequencing device and MinION R9.4.1
Flow cells (FLO-MIN106D, Oxford Nanopore Technolo-
gies). Store Flow cells at 4 ∘C.
2.2
Preparation of an
In Vitro Transcriptome
Sample
1. 100 ng polyA+ RNA isolated from total RNA, for example,
with Oligotex mRNA kit (#70022, Qiagen) or Dynabeads
oligo dT25 beads (#61002, Thermo Fisher Scientiﬁc). Store
RNA at -80 ∘C and the mRNA puriﬁcation kit as recom-
mended by the manufacturer.
2. 10 μM oligo(dT)-VN RT primer.

244
Amina Lemsara et al.
3. 5′-
TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTVN
-3′.
Store at -20 ∘C.
4. 20 μM template switching oligo (TSO). 5’- ACTCTAATAC
GACTCACTATAGGGAGAGGGC rGrG+G-3′. Store at -
20 ∘C.
5. 10 μM T7 extension primer. 5′-GCTCTAATACGACTCACTA
TAGG-3′. Store at -20 ∘C.
6. Nuclease-free water. Store at room temperature.
7. dNTP Mix (10 mM each, #R0191, Thermo Fisher Scientiﬁc).
Store at -20 ∘C.
8. Template Switching RT Enzyme Mix (#M0466S, New Eng-
land Biolabs). Store at -20 ∘C.
9. Q5 Hot Start High-Fidelity 2X Master Mix (#M0494S, New
England Biolabs). Store at -20 ∘C.
10. RNase H (5,000 U/mL) (#M0297S, New England Biolabs).
Store at -20 ∘C.
11. NucleoSpin Gel and PCR Clean-up, Mini kit for gel extraction
and PCR clean-up (#740609.50, Macherey-Nagel) or equiva-
lent. Store at room temperature.
12. MEGAscript T7 transcription kit (#AM1334, Thermo Fisher
Scientiﬁc). Store at -20 ∘C.
13. RNA
Clean
&
Concentrator-25
kit
(#R1017,
Zymo
Research). Store at room temperature.
14. Thermocycler.
15. Table top centrifuge for 1.5 mL tubes.
16. Nanodrop spectrophotometer or equivalent.
17. 0.2 mL PCR tubes, 1.5 mL DNA LoBind tubes (Eppendorf).
2.3
Hardware
Requirements
All analyses have been performed/tested on two alternative hard-
ware systems: a standard Linux desktop computer or an Apple iMac
(Retina 5 K, ultimo 2014). The workﬂow requires a multi-core
processor system with minimal main memory of 16GB RAM and
several GBs of free disk space (depending on data set size).
2.4
Software
Dependencies and
Installation
Our analysis workﬂow has few requirements, which are detailed in
Table 1. Speciﬁcally, to execute our workﬂow, the following pre-
requisites are necessary: a BASH shell, a JAVA runtime environ-
ment, a PERL, and R installation. Additional nonstandard software
to process and map Nanopore reads (bedtools, samtools, and Mini-
map2) is obligatory. Table 2 lists some additional R packages, which
are required to run the R code. Detailed installation instructions
and corresponding workﬂow code are deposited under https://
github.com/dieterich-lab/MiMB_JACUSA2_chapter.

JACUSA2 Detects RNA Modiﬁcations in Direct RNA-seq
245
Table 1
Software dependencies[tab:software]
Software
Version
Description
Minimap2
https://github.com/lh3/minimap2 v2.22 or
later
https://lh3.github.io/minimap2/
samtools
https://github.com/samtools/samtools v1.12
or later
http://samtools.github.io/
JAVA
https://openjdk.java.net/ 11.0.122021-07-
20 – JAVA 11 or later
OpenJDK Runtime Environment.
R
https://www.r-project.org/ version 3.5.1 or
later
The R Project for Statistical Computing.
PERL
https://www.perl.org/ version 5.28.1 or later
Perl is a highly capable, feature-rich
programming language.
bedtools
https://github.com/arq5x/bedtools2 version
2.29.2 or later
Perl is a highly capable, feature-rich
programming language.
snakemake https://snakemake.github.io/ version 6.8.1 or
later
The Snakemake workﬂow management
system.
Table 2
R Package dependencies[tab:software]
R Packages Version
Description
pROC
https://cran.r-project.org/web/packages/
pROC/index.htmlpROC_1.18.0
A set of tools to visualize, smooth and
compare receiver operating characteristics
(ROC curves).
stringr
https://cran.r-project.org/web/packages/
stringr/index.htmlstringr_1.4.0
Provides implementations of common
string manipulations
ggplot2
https://cran.r-project.org/web/packages/
ggplot2/index.html – ggplot2_3.3.0 or
later
ggplot2 is a system for declaratively creating
graphics, based on The Grammar of
Graphics.
NMF
https://cran.r-project.org/web/packages/
NMF/index.html – NMF_0.22.0 or later
Provides a framework to perform
Non-negative Matrix Factorization
(NMF).
3
Methods
Our workﬂow is based on the pairwise comparison of samples with
different modiﬁcation status (Fig. 1). The sample of interest (yel-
low) may be compared to different samples lacking certain mod-
iﬁcations. If available, the wild-type (WT) sample can be compared
to a knockout (KO) sample lacking speciﬁc enzymatic activities
(green), as outlined in Use Case 1. Alternatively, a sample lacking
all modiﬁcations may be used for comparison (blue). This may be
either a simulated sample (i.e., with NanoSim) or an in vitro

246
Amina Lemsara et al.
Fig. 1 General outline of RNA modiﬁcation detection by JACUSA2. A key feature of our approach is that
multiple replicates of the same condition can be considered simultaneously. Samples of interest where all
modiﬁcations are present could be compared with either KO samples where the modiﬁcation of interest is
missing or IVT/simulated samples where all modiﬁcations are absent (left panel). Read stacks (in blue) are
compared head to head, as shown on the right
transcribed sample derived from cDNA. Such an analysis is detailed
in Use Case 2. In any setting, JACUSA2 calculates scores for the
Mismatch, Insertion, and Deletion counts of the pairwise compar-
isons as outlined above (Fig. 1, right).
One feature of Nanopore sequencing is to read sequences as
5-mers (Fig. 2). Because of this, a m6A modiﬁcation may affect
basecalling not only if the modiﬁed nucleotide is in the central
position but also at neighboring positions (-2 to +2). To account
for this, JACUSA2 scores for Deletion, Mismatch, and Insertion
are calculated for the entire 5-mer context. Depending on the
modiﬁcation-speciﬁc signature, a Feature set can be selected to
calculate the ﬁnal JACUSA2 score (Fig. 2).
Our workﬂow can be divided into a wet-lab part (Fig. 3a) and a
computational part (Fig. 3b). Starting from total cellular RNA,
polyA+ RNA is isolated and subjected to Nanopore direct
RNA-sequencing. Guppy basecalling can be done as well as live
basecalling during sequencing on the respective FAST5 ﬁles,
which results in FASTQ output ﬁles (Fig. 3a). FASTQ ﬁles are
aligned to a reference sequence with Minimap2. SAMtools is used
to generate BAM ﬁles as input for JACUSA2 analysis, which yields
candidate m6A sites with the presented workﬂow in this chapter
(Fig. 3b). We will present all necessary experimental steps for
dRNA-seq in the next section.
3.1
Nanopore Direct
RNA Sequencing
1. Adjust 500 ng polyA+ RNA to a total volume of 9 μL with
nuclease-free water. Complete RT adapter ligation reaction
(in 0.2 mL PCR tube) with 3 μL NEBNext Quick Ligation
Reaction Buffer, 0.5 μl RNA CS (RCS, from SQK-RNA002),

1 μL RT-Adapter (RTA, from SQK-RNA002), and 1.5 μL T4
DNA Ligase. Incubate 10 min at room temperature.
JACUSA2 Detects RNA Modiﬁcations in Direct RNA-seq
247
Fig. 2 Motivation of 5-mer context for RNA modiﬁcation mapping. The nanopore covers ﬁve consecutive RNA
residues. That is why we consider a 5-mer context and derive three principal features for every position within
a given 5-mer (15 features in total, with a central A residue in this example). We evaluate each feature set by
previously learned patterns and compute a ﬁnal score for modiﬁcation site detection
Fig. 3 Experimental and computational workﬂow. (a) Starting from total cellular RNA, polyA+ RNA is isolated
and subjected to Nanopore direct RNA-sequencing. Guppy basecalling can be done as live basecalling during
sequencing or after the sequencing run from generated FAST5 ﬁles, resulting in FASTQ output ﬁles. (b) FASTQ
ﬁles are aligned to a reference sequence with Minimap2. SAMtools is used to generate BAM ﬁles as input for
JACUSA2 analysis, which yields candidate m6A sites as described in Fig. 4
2. Prepare the reverse transcription master mix on ice during
ligation: 9 μL nuclease-free water, 2 μL 10 mM dNTPs, 8 μL

5× SuperScript IV ﬁrst strand buffer, 4 μL 0.1 mM DTT (see
Note 1).
248
Amina Lemsara et al.
get_features
split_train_test
jacusa2_call2
sort_bam
sort_bam
sort_bam
sort_bam
get_pattern
visualize_pattern
Input: mapping_cond1_rep1.bam
Input: mapping_cond1_rep2.bam
Input: mapping_cond2_rep1.bam
Input: mapping_cond2_rep2.bam
filter_bam
filter_bam
filter_bam
filter_bam
predict_modification
Fig. 4 Computational workﬂow. Snakemake workﬂow for RNA modiﬁcation detection based on JACUSA2
variant calling
3. Add the reverse transcription master mix to the ligation reac-
tion and mix by pipetting. Add 2 μL SuperScript IV reverse
transcriptase and mix by pipetting. Incubate in a thermocycler
with the following protocol: 50 min at 50 ∘C, 10 min at 70 ∘C,
cool down to 4 ∘C.
4. Let the Agencourt RNAClean XP beads come to room tem-
perature during reverse transcription. Carefully resuspend
beads before use. Transfer reaction to a 1.5 mL DNA LoBind
tube and mix with 72 μL Agencourt RNAClean XP beads.
Incubate 5 min at room temperature on a gentle rotator mixer.
5. Collect beads on a magnetic stand and remove supernatant.
Wash pelleted beads two times (30 s) with 200 μL freshly
prepared 70% ethanol. Remove supernatant. Spin sample
down and place on magnet again. Remove any residual etha-
nol (see Note 2).
6. Resuspend beads in 20 μL nuclease-free water by gentle ﬂicking
and incubate 5 min at room temperature on a gentle rotator

JACUSA2 Detects RNA Modiﬁcations in Direct RNA-seq
249
mixer. Collect beads on a magnetic stand and transfer 20 μL
eluate in a fresh 1.5 mL DNA LoBind tube.
7. For ligation of the RMX adapter, add the following to 20 μL
eluate: 8 μL NEBNext Quick Ligation Reaction Buffer, 6 μl
RMX (from SQK-RNA002), 3 μL nuclease-free water, 3 μL T4
DNA Ligase. Mix by pipetting and incubate 10 min at room
temperature.
8. Add 40 μL carefully resuspended Agencourt RNAClean XP
beads to the reaction and mix by pipetting. Incubate 5 min at
room temperature on a gentle rotator mixer.
9. Collect beads on a magnetic stand and remove supernatant.
Wash pelleted beads two times with 150 μL wash buffer (WSB,
from SQK-RNA002). Resuspend beads by ﬂicking, spin down,
and return to magnetic stand. Remove supernatant from pel-
leted beads (see Note 2).
10. Resuspend
beads
in
21
μL
elution
buffer
(EB,
from
SQK-RNA002) by gentle ﬂicking and incubate 5 min at
room temperature on a gentle rotator mixer. Pellet beads on
a magnetic stand and transfer 21 μL eluate in a fresh 1.5 mL
DNA LoBind tube.
11. Quantify 1 μL of the library on a Qubit ﬂuorometer with the
Qubit dsDNA HS kit according to the manufacturer’s proto-
col. Concentration should be usually in the range of 5–10 ng/
μL
12. Insert MinION R9.4.1 Flow cell in the MinION or GridION
sequencing device and perform Flow cell check in the Min-
KNOW software. For successful sequencing of mammalian
polyA+ RNA, at least 1000 available pores are recommended.
13. Prepare Priming Mix by adding 30 μL ﬂush tether (FLT, from
EXP-FLP002) to a vial of ﬂush buffer (FB, from EXP-FLP002)
and mix by pipetting. Open priming port. Remove air bubble
from priming port by inserting the tip of a P1000 pipette into
the priming port and slowly dialing up, until a small volume of
storage buffer enters the pipette tip. Load 800 μL Priming Mix
via the priming port and carefully avoid introduction of air
bubbles. Close the priming port and wait for 5 min.
14. Mix 20 μL library with 17.5 μL nuclease-free water and 37.5
μL RNA running buffer (RRB, from SQK-RNA002) and mix
by pipetting. Open the priming port and the sample port. Load
200 μL Priming Mix via the priming port. Mix library by
pipetting just before loading and load dropwise via the sample
port. Carefully avoid introduction of air bubbles. Close the
sample port and the priming port.

250
Amina Lemsara et al.
15. Start sequencing for 48–72 h in the MinKNOW software.
Choose direct RNA-sequencing kit and high-accuracy base-
calling as parameters (see Note 3).
3.2
Preparation of an
In Vitro Transcriptome
Sample
The in vitro transcriptome sample is prepared based on a protocol
published by [21] with some modiﬁcations as detailed below (see
Note 4). An in vitro transcriptome lacks any RNA modiﬁcations
and is a perfect reference sample for RNA modiﬁcation mining.
1. Adjust 100 ng polyA+ RNA to a total volume of 6 μL with
nuclease-free water. Add 1 μL each of 10 μM oligo(dT)-VN RT
primer and 10 mM dNTPs. Mix by pipetting and incubate in a
thermocycler: 5 min at 75 ∘C, 2 min at 42 ∘C, cool to 4 ∘C.
2. Assemble 2.5 μL 4× template switching RT buffer, 0.5 μL
20 μM TSO, 1 μL 10× template switching RT enzyme mix
and mix by pipetting. Combine with 6 μL RNA and incubate in
a thermocycler: 90 min at 42 ∘C, 10 min at 68 ∘C, cool to 4 ∘C.
3. For second strand synthesis add to ﬁrst strand synthesis reac-
tion: 50 μL Q5 Hot Start High-Fidelity 2× Master Mix, 5 μL
RNase H, 2 μL 10 μM T7 extension primer, 33 μL nuclease-
free water. Mix by pipetting and incubate in a thermocycler:
15 min at 37 ∘C, 1 min at 95 ∘C, 10 min at 65 ∘C, cool to 4 ∘C.
4. Purify double-stranded cDNA with NucleoSpin Gel and PCR
Clean-up kit according to the manufacturer’s protocol and
elute in 20 μL elution buffer. Determine concentration on a
Nanodrop spectrophotometer. cDNA may be stored at -
20 ∘C.
5. Combine 8 μL cDNA for in vitro transcription with 2 μL each
of ATP, GTP, CTP, UTP, 10× reaction buffer, and enzyme mix
from the MEGAscript T7 transcription kit. Incubate 3 h at
37 ∘C.
6. Digest template DNA by addition of 1 μL Turbo DNase. Mix
by pipetting and incubate 15 min at 37 ∘C.
7. Adjust reaction volume to 100 μL with nuclease-free water and
clean up with RNA Clean & Concentrator-25 kit according to
the manufacturer’s protocol, using two volumes of adjusted
RNA binding buffer (1:1 RNA binding buffer: ethanol). Elute
RNA in 25 μL nuclease-free water. Determine RNA concentra-
tion on a Nanodrop spectrophotometer. Store at -80 ∘C.
3.3
Nanopore Read
Processing
1. Base call the ionic current signal stored in FAST5 ﬁles using
Guppy. For the IVT sample, we applied real-time basecalling
with the MinKNOW-embedded Guppy basecaller. Otherwise,
Guppy basecaller software can be used. In this case, the base-
caller requires the path to FAST5 ﬁles, the output folder, and
the conﬁg ﬁle or the ﬂowcell/kit combination. The output

consists in FASTQ ﬁles that can be compressed using the
JACUSA2 Detects RNA Modiﬁcations in Direct RNA-seq
251
option “–compress_fastq.”
$ guppy_basecaller --compress_fastq -i path_to_fast5 -s
path_to_output
-c
conﬁg_ﬁle.cfg
--cpu_threads_per_caller
14 --num_callers 1
Set the number of threads “cpu_threads_per_caller” and
the number of parallel basecallers “num_caller” according to
your resources. Additional details can be found at https://
nanoporetech.com/.
2. Align reads to the transcriptome using Minimap2 software.
The output is a SAM ﬁle that has to be converted to a com-
pressed form as BAM ﬁle using SAMtools command. The
alignment requires a reference sequence. Here, we used
GRCh38 Ensembl release 96 annotation and FASTA ﬁle.
Pre-indexing of the human genome saves time during read
alignment. Please save the index with the option “-d” before
read mapping and use the index instead of the reference ﬁle in
the minimap2 command line.
$ minimap2 -d reference.mmi reference.fa
For Direct RNA Sequencing, it is recommended to set a
small k-mer size “-k [=14]” to enhance sensitivity. We recom-
mend outputting only primary alignments “–secondary = no.”
Use the parameter “–MD” to add the reference sequence
information to the alignment; this is necessary for JACUSA2
downstream analysis. Adjust the number of threads “-t”
according to your resources. Check Minimap2 manual for
more details [22]. To enable spliced alignments, use the setting
“-ax splice” “–junc-bed annotation.bed –junc-bonus” where
“–junc-bonus” allows to tune the bonus score and the BED ﬁle
“–junc-bed annotation.bed” provides the splice junctions.
$ minimap2 -t 5 --MD -ax splice --junc-bonus 1 -k14 --
secondary=no --junc-bed ﬁnal_annotation_96.bed -ub refer-
ence.mmi Reads.fastq.gz | samtools view -bS >mapping.bam
The BED ﬁle can be generated from EnsEMBL GTF ﬁles
using the following command:
$paftools.js gff2bed annotation.gtf > annotation.bed
3. Mapping
RNA
modiﬁcations
using
JACUSA2
pipeline:
JACUSA2 [23] rapidly detects RNA modiﬁcations based on a
comparative strategy where read alignment features (mismatch,
insertion, and deletion) of samples of interest are compared to a
reference sequence (call-1) or against reference samples with-
out the corresponding RNA modiﬁcation of interest (call-2).
JACUSA2 processes replicate experiments. The analysis of read
alignment signatures is used for RNA modiﬁcation detection.
Particularly, we integrate JACUSA2 call-2 method with the
downstream analysis in one workﬂow using the Snakemake
workﬂow
manager
[24].
Our
Snakemake
workﬂow

252
Amina Lemsara et al.
encompasses several steps as shown in Fig. 4. The workﬂow
requires BAM ﬁles from two conditions as input. We suggest to
ﬁlter secondary and poor alignments beforehand. The output
of JACUSA2 call2 is preprocessed (get_features) and subjected
to a machine learning step to extract and visualize modiﬁcation
patterns (resp. get_pattern, visualize_pattern) and make pre-
dictions (predict_modiﬁcation). “split_train_test” snakemake
rule allows splitting input data into a training set and a test
set. To use our snakemake-based JACUSA2 pipeline, a set of
parameters should be deﬁned in the “conﬁg.yaml” ﬁle; mainly,
the label of the analysis “label,” the input bam ﬁles under
“data,” the reference sequence “reference,” a ﬁle containing
the size of chromosomes “chr_size,” JACUSA2 jar ﬁle “jar,”
plus the path to inputs and outputs under “path_inp” and
“path_out” ﬁelds, respectively. We typically execute the work-
ﬂow on a multi-core CPU system using the following com-
mand by specifying the number of cores to be used “–cores
[=all]” and the rule name:
$ snakemake --cores all rule_name
Please see Notes 5–8 and consult the Snakemake documen-
tation for further details (see https://snakemake.readthedocs.
io/en/stable/).
3.4
Use Case 1:
Comparison of Wild-
Type and Knockout
Samples
The JACUSA2 workﬂow detects RNA modiﬁcations using direct
RNA sequencing by comparing modiﬁed samples to unmodiﬁed
control samples. Here, we used a published dataset of HEK293 cell
lines to map m6A modiﬁcation [25]. Our example encompasses
two conditions: wild-type RNA (WT, modiﬁed RNAs) and RNA
from METTL3 knockout cells (KO, m6A modiﬁcation is absent).
We use two replicates per condition (see https://doi.org/10.
5281/zenodo.5913452). The FASTQ ﬁles are mapped using
Minimap2 as described in the previous section. The following
analysis is validated against m6A sites consistently reported in
three miCLIP-based studies [26–28] (Fig. 5).
Starting with the preprocessed mapped reads as inputs (BAM
ﬁles),
“HEK293T-WT-rep2.bam”
and
“HEK293T-WT-rep3.
bam” represent the wild-type replicates and “HEK293T-KO-
rep2.bam” and “HEK293T-KO-rep3.bam” the control replicates,
1. Compute read error proﬁle with the “jacusa2_call2 rule”:
$ snakemake --cores all jacusa2_call2
The method requires BAM ﬁles of the paired conditions
and the corresponding library information “-P1” and “-P2.”
In addition to the mismatch score, add “-D” and “-I” to
output the deletion and insertion scores. JACUSA2 allows
ﬁltering reads according to many parameters. Here, we con-
sider all sites with base calling quality “-q [>1],” mapping
quality “-m [>1],” and read coverage “-c [>4].” Plus, we

JACUSA2 Detects RNA Modiﬁcations in Direct RNA-seq
253
Fig. 5 m6A sites reported in the three miCLIP-based studies [26–28]
consider ﬁltering sites within homopolymer regions “-a [=Y].”
The output (named here, “Cond1vsCond2Call2.out”) con-
sists of a read error proﬁle where the format is a combination
of BED6 with JACUSA2 call-2 speciﬁc columns and common
info columns: info, ﬁlter, and ref. Check JACUSA2 manual for
more details on JACUSA2 ﬁlter and output options [29]. The
number of threads can be customized via the parameter “-p.”
All parameters related to the JACUSA2 method can be added
under the ﬁeld “jacusa_params” in the conﬁg ﬁle by setting the
name of the parameter
followed by the corresponding
value [key: value]. Be aware to set all parameters before running
the pipeline.
2. Process JACUSA2 output with the “get_features rule”:
$ snakemake --cores all get_features
Here, we select all sites within a 5-mer distance of a central
nucleotide
“A”
ﬂanked
by
two
random
nucleotides
(NNANN), and we ﬁlter out sites of the homopolymer regions.
Then, we rebuild the tabular features such that the observa-
tions are only sites with a reference base “A.” Each site is
characterized by 15 features corresponding to the mismatch,
insertion, and deletion scores for the observed site and its two
ﬂanking positions from both sides. The rule “get_features”
performs the preprocessing step. Use the parameter “region”
with a ﬁle containing target 5-mers to limit the analysis to
speciﬁc sites. The output is an R object “features/features.
rds,” representing the matrix of sites×15 features.
3. Extract characteristic m6A modiﬁcation patterns with the
“get_pattern” rule:
$ snakemake --cores all get_pattern
We train a model representing the m6A modiﬁcation pat-
terns given the matrix of Sites×Features. To this end, we
employ non-negative matrix factorization (NMF) [30]. Brieﬂy,

254
Amina Lemsara et al.
NMF factorizes a non-negative data matrix X (here: n sites and
m features) into two non-negative matrices as X ≈WH, such
that W is an n × k matrix containing basis vectors and H is an
k × m matrix containing coefﬁcient vectors. The coefﬁcient
vectors and their combination can be viewed as a pattern for
m6A modiﬁcation. The rank of factorization k is a critical
parameter that affects the performance substantially. We sug-
gest to select the rank k according to the method of [31] by
looking at silhouette [32] and cophenetic correlation [33]
indices. Accordingly, the performance indices are computed
for different choices of rank (k < n, m) and compared to the
performance of a random permutation of the original data.
Subsequently, the chosen rank corresponds to the value with
the largest difference between slopes of the original and the
randomized data. Here, the unsupervised pattern training is
based on the consensus set of 1905 m6A sites reported in the
three miCLIP-based studies mentioned earlier. Based on the
silhouette and cophenetic correlation indices, we identiﬁed an
optimal factorization rank of 6 (Fig. 6a). We then analyzed the
identiﬁed patterns. According to the membership indicator of
each site in matrix W, more than 80% of m6A modiﬁcation sites
can be represented by ﬁve patterns (Patterns 1,2,3,4,6)
(Fig. 6b). Interestingly, the linear combination of these ﬁve
patterns in Fig. 6c highlights the importance of position 3. Of
note, predeﬁned patterns can be used instead of learning new
patterns (see Note 9).
Multiple patterns and their combinations can be visualized
using “visualize_pattern” rule. The corresponding outputs are
under “pattern/viz” folder.
$ snakemake --cores all visualize_pattern
4. Predict
m6A
modiﬁcations
with
the
“predict_modiﬁcation” rule:
$ snakemake --cores all predict_modiﬁcation
This rule uses patterns of 15 features to predict m6A
modiﬁcation. We examine the ability of prediction on a subset
of data of more than 1.52 million sites including 17, 021
miCLIP m6A sites. We opt for the linear combination of the
ﬁve most relevant patterns described in step 3. The empirical
cumulative distribution function (eCDF) of the inferred scores
shows a signiﬁcant difference between the different miCLIP
m6A categories (miCLIP annotation) and the unmodiﬁed sites
(Fig. 6d). As the number of negative samples is much larger
than the number of positive samples, we consider the positive
predictive value (PPV, TP/(TP + FP)) of our predictions.
Here, Fig. 6e shows that PPV increases with the score cutoff.
The ﬁnal output is a BED ﬁle containing the estimated scores as
well as the corresponding eCDF and PPV plots. The
corresponding outputs are located under a new folder called
“prediction.”

JACUSA2 Detects RNA Modiﬁcations in Direct RNA-seq
255
Fig. 6 Case 1. WT versus KO. (a) NMF rank selection. Barplots represent differences in cophenetic correlation
and silhouette scores for NMF factorization of the original input and randomized data. Ranks with the largest
differences are determined for both measures, then the smallest rank is selected for the NMF decomposition.
(b) NMF result represented by the basis matrix W (“amplitude” matrix) and the coefﬁcient matrix H (“pattern”
matrix). The matrix H induces the RNA modiﬁcation pattern. (c) Barplot shows the sum of the top 5 patterns
(y-axis) across the speciﬁc 5-mer context (x-axis) and the score type: mismatch, deletion, and insertion (resp.
black, orange, and blue). The ﬁve patterns (coefﬁcient vectors: 1,2,3,4,6) are selected according to the
predominant columns in matrix W. (d) Score distribution inferred from the combined patterns, stratiﬁed by the
different categories of miCLIP-validated sites and non-miCLIP sites. (e) Number of predicted m6A sites (green)
and positive predictive value (PPV) of predicted m6A sites that overlap with miCLIP sites (orange)

256
Amina Lemsara et al.
3.5
Use Case 2:
Comparison of Wild-
Type and IVT Samples
An alternative way to detect RNA modiﬁcations is to compare a
modiﬁed sample to an IVT control sample. Therefore, we bench-
mark JACUSA2 on a sample set of two replicates from wild-type
HEK293 cell lines (see Use Case 1 modiﬁed sample) [25] and a
modiﬁcation-free IVT sample from HEK293 cDNA (control sam-
ple) (see “Preparation of an in vitro transcriptome sample”). All
analysis steps are identical to Use Case 1. We evaluate the analysis
against miCLIP m6A sites (Fig. 5).
1. Identify read error proﬁle: we use JACUSA2 call-2 with the
same parameters as the previously described case. The input
BAM ﬁles (HEK293T-WT-rep2.bam, HEK293T-WT-rep3.
bam) and (HEK293T-IVT-rep1.bam, HEK293T-IVT-rep2.
bam) are associated to the wild-type and IVT replicate samples,
respectively. All input ﬁles are available on https://doi.org/10.
5281/zenodo.5913452
$ snakemake --cores all jacusa2_call2
2. Process JACUSA2 output: we consider all sites corresponding
to a 5-mer (NNANN) with a central A residue. We employ the
Y ﬁlter to exclude sites within homopolymer regions.
$ snakemake --cores all get_features
3. Extract m6A modiﬁcation pattern: Based on the silhouette and
cophenetic correlation indices, we identiﬁed an optimal factor-
ization rank of 6 (Fig. 7a). We determined the predominant
factors from matrix W. Accordingly, more than 80% of m6A
modiﬁcation sites can be represented by four patterns (Pat-
terns: 1,2,3,6) (Fig. 7b). In agreement with Use Case 1, the
linear combination of the four patterns conﬁrms the impor-
tance of position 3 and the implication of all scores as shown in
Fig. 7c.
$ snakemake --cores all get_pattern
4. Predict m6A modiﬁcations: we evaluated the prediction ability
of the detected patterns on a test set of almost 1.52 million sites
where 17, 021 are miCLIP-m6A modiﬁed. We consider the
linear combination of the four most relevant patterns (1,2,3,6).
Figure 7d shows the eCDF of the inferred scores. The differ-
ence between the cumulative distribution of non-miCLIP sites
and miCLIP sites can be nicely observed, while the PPV plot
shows a lower performance as compared to Use Case
1 (Fig. 7e). The decrease in performance is likely explained by
the absence of all modiﬁcations in the IVT samples. Additional
adenosine modiﬁcations such as RNA editing may be counted
as false positives.
$ snakemake --cores all predict_modiﬁcation

JACUSA2 Detects RNA Modiﬁcations in Direct RNA-seq
257
Fig. 7 Case 2. WT versus IVT. (a) NMF rank selection. Barplots represent differences in cophenetic correlation
and silhouette scores for NMF factorization of the original input and randomized data. Ranks with the largest
value for both indices are determined, then the smallest rank is selected for the NMF decomposition. (b) NMF
result represented by the basis matrix W (“amplitude” matrix) and the coefﬁcient matrix H (“pattern” matrix).
The matrix H induces the RNA modiﬁcation pattern. (c) Barplots representing the linear combination of the top
4 patterns (y-axis) by the number of the position in the speciﬁc 5-mer context (x-axis) and the score type:
mismatch, deletion, and insertion (resp. black, orange, and blue). The four patterns (coefﬁcient vectors:
1,2,3,6) are selected according to the predominant columns in matrix W. (d) Score distribution inferred from
the combined patterns, stratiﬁed by the different categories of miCLIP validated sites and non-miCLIP sites. (e)
Number of predicted m6A sites (green) and positive predictive value (PPV) of predicted m6A sites that overlap
with miCLIP sites (orange)

258
Amina Lemsara et al.
4
Notes
1. The reverse transcription step during library preparation is
optional. However, we recommend to include this step to
ensure proper sequencing also of RNAs with secondary struc-
tures. Superscript IV reverse transcriptase may be replaced by
Superscript III reverse transcriptase, which is used in the pro-
tocol provided by Oxford Nanopore Technologies.
2. The library preparation protocol contains two bead cleanup
steps. It is important to remove ethanol and wash buffer
completely. However, beads should not be dried for several
minutes. Directly add water or elution buffer after washing to
prevent sticking of the RNA to the beads.
3. The default ﬁlter in current MinKNOW versions is a Q score of
9. For direct RNA sequencing, we recommend to adjust the
output ﬁlter to a minimum Q score of 7, as in previous Min-
KNOW versions.
4. During preparation of the in vitro transcriptome sample,
in vitro transcription and cleanup kits may be replaced by
equivalent products. The protocol however has been tested
only with the mentioned kits.
5. Conﬁguration of the pipeline should be handled via the
conﬁg ﬁle: conﬁg.yaml. All parameters should be set before
executing rules.
6. Once the pipeline has run successfully you should expect the
following folders with the corresponding outputs in the output
directory: bam, jacusa, features, patterns, and prediction.
7. JACUSA2 call2 could be run separately using the command
line as described in JACUSA2 manual [29], and then put the
output under a new folder with the name “jacusa” under the
output directory.
8. In the snakemake pipeline, rules are linked so that the work-
ﬂows are determined from top (e.g., predict_modiﬁcation) to
bottom (e.g., sort_bam) and executed accordingly from bot-
tom to top (Fig. 4). Therefore, running, for example, the
“predict_modiﬁcation” rule leads to executing all rules on its
pipeline.
9. This workﬂow uses a subset of the input data that correspond
to known modiﬁed sites to derive characteristic read alignment
proﬁles by NMF (patterns). Alternatively, predeﬁned patterns
could be used via a preloaded NMF R object into “patterns”
folder to compute scores for modiﬁcation site prediction.

JACUSA2 Detects RNA Modiﬁcations in Direct RNA-seq
259
Acknowledgments
The authors would like to thank Harald Wilhemi for testing the
snakemake pipeline. This work was supported by DFG SPP 1784
(DI1501/11-1) and DFG TRR 319 – RMaP.
References
1. Atlasi Y, Stunnenberg HG (2017) The inter-
play of epigenetic marks during stem cell dif-
ferentiation and development. Nat Rev Genet
18(11):643–658. https://doi.org/10.1038/
nrg.2017.57
2. Nishikura K (2010) Functions and regulation
of RNA editing by ADAR deaminases. Annu
Rev Biochem 79:321–349. https://doi.org/
10.1146/annurev-biochem-060208-105251
3. Frye M, Harada BT, Behm M, He C (2018)
RNA modiﬁcations modulate gene expression
during
development.
Science
361(6409):1346–1349. https://doi.org/10.
1126/science.aau1646
4. Worpenberg L, Paolantoni C, Roignant J-Y
(2022) Functional interplay within the epitran-
scriptome: reality or ﬁction? BioEssays News
Rev Mol Cell Dev Biol 44(2):e2100174.
https://doi.org/10.1002/bies.202100174
5. Roundtree IA, Evans ME, Pan T, He C (2017)
Dynamic RNA modiﬁcations in gene expres-
sion
regulation.
Cell
169(7):1187–1200.
https://doi.org/10.1016/j.cell.2017.05.045
6. Anreiter I, Mir Q, Simpson JT, Janga SC, Soller
M (2021) New twists in detecting mRNA
modiﬁcation
dynamics.
Trends
Biotechnol
39(1):72–89. https://doi.org/10.1016/j.
tibtech.2020.06.002
7. Roignant J-Y, Soller M (2017) m, javax.xml.
bind.JAXBElement@8cec19d, A in mRNA: an
ancient
mechanism
for
ﬁne-tuning
gene
expression.
Trends
Genet
TIG
33(6):380–390. https://doi.org/10.1016/j.
tig.2017.04.003
8. Zaccara S, Ries RJ, Jaffrey SR (2019) Reading,
writing and erasing mRNA methylation. Nat
Rev Mol Cell Biol 20(10):608–624. https://
doi.org/10.1038/s41580-019-0168-5
9. Shi H, Wei J, He C (2019) Where, when,
and
how:
context-dependent
functions
of
RNA methylation writers, readers, and erasers.
Mol Cell 74(4):640–650. https://doi.org/10.
1016/j.molcel.2019.04.025
10. Garcias Morales D, Reyes JL (2021) A birds’--
eye view of the activity and speciﬁcity of the
mRNA
m,
javax.xml.bind.JAXBEle-
ment@6d66739e,
A
methyltransferase
complex. Wiley Interdiscip Rev RNA 12(1):
e1618. https://doi.org/10.1002/wrna.1618
11. Jia G et al (2011) N6-methyladenosine in
nuclear RNA is a major substrate of the
obesity-associated
FTO.
Nat
Chem
Biol
7(12):885–887. https://doi.org/10.1038/
nchembio.687
12. Zheng G et al (2013) ALKBH5 is a mammalian
RNA demethylase that impacts RNA metabo-
lism and mouse fertility. Mol Cell 49(1):18–29.
https://doi.org/10.1016/j.molcel.2012.
10.015
13. Dominissini D et al (2012) Topology of the
human and mouse m6A RNA methylomes
revealed
by
m6A-seq.
Nature
485(7397):201–206. https://doi.org/10.
1038/nature11112
14. Meyer KD, Saletore Y, Zumbo P, Elemento O,
Mason CE, Jaffrey SR (2012) Comprehensive
analysis of mRNA methylation reveals enrich-
ment in 3’ UTRs and near stop codons. Cell
149(7):1635–1646. https://doi.org/10.
1016/j.cell.2012.05.003
15. Ke S et al (2015) A majority of m6A residues
are in the last exons, allowing the potential for
3’
UTR
regulation.
Genes
Dev
29(19):2037–2053. https://doi.org/10.
1101/gad.269415.115
16. Adhikari S, Xiao W, Zhao Y-L, Yang Y-G
(2016) m(6)A: Signaling for mRNA splicing.
RNA Biol 13(9):756–759. https://doi.org/
10.1080/15476286.2016.1201628
17. Wang X et al (2015) N6-methyladenosine
modulates messenger RNA translation efﬁ-
ciency. Cell 161(6):1388–1399
18. Wang X et al (2014) N 6-methyladenosine-
dependent regulation of messenger RNA sta-
bility. Nature 505(7481):117–120
19. Du H et al (2016) YTHDF2 destabilizes m
6 A-containing RNA through direct recruit-
ment of the CCR4–NOT deadenylase com-
plex. Nat Commun 7(1):1–11
20. Patil DP, Pickering BF, Jaffrey SR (2018)
Reading
m6A
in
the
transcriptome:
m6A-binding
proteins.
Trends
Cell
Biol
28(2):113–127

260
Amina Lemsara et al.
21. Zhang Z et al (2021) Systematic calibration of
epitranscriptomic
maps
using
a
synthetic
modiﬁcation-free RNA library. Nat Methods
18(10):1213–1222
22. Minimap2. [Online]. Available: https://
github.com/lh3/minimap2
23. Piechotta M, Wang Q, Altmu¨ller J, Dieterich C
(2021)
RNA
modiﬁcation
mapping
with
JACUSA2. bioRxiv
24. Ko¨ster J, Rahmann S (2012) Snakemake—a
scalable bioinformatics workﬂow engine. Bio-
informatics 28(19):2520–2522
25. Pratanwanich PN et al (2021) Identiﬁcation of
differential RNA modiﬁcations from nanopore
direct RNA sequencing with xPore. Nat Bio-
technol 39(11):1394–1402
26. Boulias K et al (2019) Identiﬁcation of the
m6Am methyltransferase PCIF1 reveals the
location and functions of m6Am in the tran-
scriptome. Mol Cell 75(3):631–643
27. Koh CW, Goh YT, Goh WS (2019) Atlas of
quantitative
single-base-resolution
N
6-methyl-adenine methylomes. Nat Commun
10(1):1–15
28. Ko¨rtel N et al (2021) Deep and accurate detec-
tion
of
m6A
RNA
modiﬁcations
using
miCLIP2 and m6Aboost machine learning.
bioRxiv:2020–2012
29. JACUSA2 manual. 2021. [Online]. Available:
https://github.com/dieterich-lab/JACUSA2
30. Lee DD, Seung HS (1999) Learning the parts
of objects by non-negative matrix factorization.
Nature 401(6755):788–791
31. Frigyesi A, Ho¨glund M (2008) Non-negative
matrix factorization for the analysis of complex
gene expression data: identiﬁcation of clinically
relevant tumor subtypes. Cancer Inform 6:
CIN-S606
32. Rousseeuw PJ (1987) Silhouettes: a graphical
aid to the interpretation and validation of clus-
ter analysis. J Comput Appl Math 20:53–65
33. Brunet J-P, Tamayo P, Golub TR, Mesirov JP
(2004) Metagenes and molecular pattern dis-
covery using matrix factorization. Proc Natl
Acad Sci 101(12):4164–4169

INDEX
B
Bioconductor.......................................8, 16, 89, 164–166
Bisulﬁte Sequencing........................................1, 8, 43, 44,
46, 76, 79, 115, 116, 121, 225
C
Chromatin
immunoprecipitation sequencing
(ChIP-seq).............................................. 55–70, 74
interaction............................................................19–40
spike-in..........................................................57, 61, 66
CpG
dinucleotides .........................................................1, 46
island................................................................. 14, 115
D
Data visualization..........................................................4, 5
Deep neural network ...................................................... 20
Differentially methylated region (DMR)............... 11, 12,
14, 16, 117, 172–176
E
Enzymatic methyl sequencing (EM-seq)............ 115, 121
Epigenome ............................................................. 47, 115
Epitranscriptome...........................................................186
G
Guppy ......................................................... 133, 189–192,
199, 246, 247, 251
H
Hi-C..........................................20–28, 33–35, 37, 38, 40
K
k-mer..................................................................... 130, 251
M
Machine learning...............................................20, 81, 84,
140, 146, 153, 154, 252
Pedro H. Oliveira (ed.), Computational Epigenomics and Epitranscriptomics,
Methods in Molecular Biology, vol. 2624, https://doi.org/10.1007/978-1-0716-2962-8,
© The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Science+Business Media, LLC, part of Springer
Nature 2023
261
Mass spectrometry ............................................... 225, 227
Methylated RNA immunoprecipitation sequencing
(MeRIP-seq).....................................163–166, 169
Methylation .......................................... 1–5, 7–17, 43–48,
51, 74, 79–81, 91, 100, 110, 115–125, 163–165,
171–173, 176, 180–182
Methyltransferase ........................................ 119, 186, 242
Microarray ................................................... 8, 43, 56, 115
Modiﬁcation
DNA ........................................................7, 87–89, 96,
101, 109, 110, 241
histone .................................................................7, 241
RNA.....................................139, 153, 154, 163, 186,
187, 208, 210, 218, 219, 221, 226, 241–258
N
Nanopore sequencing........................................... 87, 128,
134, 137, 186, 187, 246
Nextﬂow .............................................186, 187, 189–191,
194, 197, 199
Normalization .......................8, 9, 11–13, 16, 17, 22, 24,
37, 51, 56–58, 63, 65–67, 69, 147, 181, 215, 221
P
Paciﬁc Biosciences (PacBio) .............................87–89, 91,
100, 101, 111
Principal component analysis (PCA)................12, 16, 17,
44, 46–48, 50
Probabilistic-based imputation.....................................119
Pseudouridine............................................. 128, 139–149,
153–159, 188, 207–221
R
RNA sequencing (RNA-seq)............................56, 90, 92,
104, 105, 127–137, 176, 185–202, 243, 251, 258
S
Single-cell .............................................v, 43–53, 116, 120
Single-Molecule Real Time Sequencing
(SMRT-seq) ............................................ 90, 92–94

262 COMPUTATIONAL EPIGENOMICS AND EPITRANSCRIPTOMICS
Index
Snakemake .................................................. 186, 245, 248,
251–254, 256, 258
Support vector machine (SVM) .........................139, 147,
149, 155
T
Transcription Start Site (TSS) ................................ 46, 47,
73, 77–79, 81–83, 92, 93, 160
Transcriptomics .............................................................164
t-SNE...................................................131, 132, 135, 137
Tumor...............................................................73–84, 116
W
Web-server............................................................ 130, 154

