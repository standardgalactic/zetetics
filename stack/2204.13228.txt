Submitted to:
QPL 2022
© Alexander Cowtan
This work is licensed under the
Creative Commons Attribution License.
Qudit lattice surgery
Alexander Cowtan
Department of Computer Science, University of Oxford
Wolfson Building, Parks Road, Oxford, UK
Cambridge Quantum
Terrington House, 13-15 Hills Road, Cambridge, UK
akcowtan@gmail.com
We observe that lattice surgery, a model of fault-tolerant qubit computation, generalises straightfor-
wardly to arbitrary ﬁnite-dimensional qudits. The generalised model is based on the group algebras
CZd for d ≥2. It still requires magic state injection for universal quantum computation. We relate
the model to the ZX-calculus, a diagrammatic language based on Hopf-Frobenius algebras.
1
Introduction
Topological quantum computing is a theoretical paradigm of large-scale quantum error correction in
which important data is encoded in non-local features of a vast entangled state. So long as the physical
errors on the overall system stay below some threshold value, the data is protected. The archetypal
example is the CZ2 surface code [1, 2], a system which requires only nearest-neighbour connectivity
between qubits and has a high threshold against errors [5]. The key practical feature of the surface code,
as opposed to the earlier toric code [3], is that it may be embedded on the plane with boundaries, and
does not require exotic homology to encode data.
Lattice surgery was developed by Horsman et al. [4] as a method of computation using the surface
code. It is conceptually simple and ﬂexible, and believed to be efﬁcient in its consumption of resources
such as qubits and time [6, 7] compared to other methods such as defect braiding [8]. Lattice surgery
starts with patches of surface code, then employs ‘splits’ and ‘merges’ on these, which act non-unitarily
on logical states. In fact, merges are described by completely positive trace preserving (CPTP) maps, and
cannot be performed deterministically in general. Both features make the model cumbersome to describe
using the circuit model.
Interestingly, computation using lattice surgery closely mirrors the Hopf algebra structure of CZ2, the
group algebra of Z2 over the ﬁeld C. Coincidentally, this is one of the building blocks of the ZX-calculus,
a formal graphical language for reasoning about quantum computation [9]. It represents quantum pro-
cesses using ZX-diagrams, which may then be rewritten using the axioms of the calculus. The initial
presentation of the ZX-calculus applied only to qubits, and can be summarised algebraically as CZ2 and
C(Z2) sitting on the same vector space, plus the inherent Fourier transform and a so-called phase group.
De Beaudrap and Horsman [10] noticed this relationship between lattice surgery and qubit ZX-
calculus, and leveraged it to develop novel lattice surgery procedures. Other techniques using the same
idea have also been developed, e.g. for efﬁcient compilation of magic state distillation circuits [11] and
reasoning about implementing deterministic programs despite non-deterministic merges [12].
The ZX-calculus has since been generalised to qudits using CZd, for d ∈N [13]. We observe that
lattice surgery may similarly be generalised. The procedure is algebraically very simple, with the most
advanced technology required being the Fourier transform. We give a concrete description of the com-
putational model, although for brevity we elide some of the details such as the Pauli frame. We then
arXiv:2204.13228v3  [quant-ph]  30 Jun 2022

2
Qudit lattice surgery
leverage the qudit ZX-calculus to describe transformations on the logical data. We use this description
to give a series of qudit lattice surgery procedures, and show that the model still requires magic state
injection for universality.
2
The CZd surface code
In this section we introduce the surface code for qudits; readers familiar with Kitaev models may wish to
skip to Section 3. Throughout, we let Zd be the cyclic group with d elements labelled by integers 0,⋯,d−
1 with addition as group multiplication. We assume d ≥2, as the d = 1 case is trivial. In the interest of
brevity, proofs are brief or relegated to the appendices. For more explicit and thorough treatments at
a higher level of generality see e.g. [3, 15, 16]. Throughout, we occasionally ignore normalisation
(typically factors of d or 1
d) when convenient.
Deﬁnition 2.1. Let CZd be the group Hopf algebra with basis states ∣i⟩for i ∈Zd. CZd has multiplication
given by a linear extension of its native group multiplication, so ∣i⟩⊗∣j⟩↦∣i+ j⟩, and the unit ∣0⟩. It has
comultiplication given by ∣i⟩↦∣i⟩⊗∣i⟩, and the counit ∣i⟩↦1 ∈C. It has the normalised integral element
ΛCZd = 1
d ∑i∣i⟩and the antipode is the group inverse. CZd is commutative and cocommutative.
Deﬁnition 2.2. Let C(Zd) be the function Hopf algebra with basis states ∣δi⟩for i ∈Zd. C(Zd) is the dual
algebra to CZd. C(Zd) has multiplication ∣δi⟩⊗∣δj⟩↦δi,j∣δi⟩and the unit ∑i∣δi⟩. It has comultiplication
∣δi⟩↦∑h∈Zd ∣δh⟩⊗∣δi−h⟩and counit ∣δi⟩↦δi,0. It has the normalised integral element ΛC(Zd) = ∣δ0⟩and
the antipode is also the inverse. C(Zd) is commutative and cocommutative.
Lemma 2.3. The algebras are related by the Fourier isomorphism, so C(Zd) ≅CZd as Hopf algebras.
In particular this isomorphism has maps
∣j⟩↦∑
k
qjk∣δk⟩,
∣δ j⟩↦1
d ∑
k
q−jk∣k⟩,
(1)
where q = e
i2π
d is a primitive dth root of unity.
Deﬁnition 2.4. Now let Σ = Σ(V,E,P) be a square lattice viewed as a directed graph with its usual
(cartesian) orientation. The corresponding Hilbert space H will be a tensor product of vector spaces
with one copy of CZd at each arrow in E, with basis denoted by {∣i⟩}i∈Zd as before. Next, for each vertex
v ∈V and each face p ∈P we deﬁne an action of CZd and C(Zd), which acts on the vector spaces around
the vertex or around the face, and trivially elsewhere, according to
∣a⟩
∣b⟩
∣c⟩
∣d⟩
∣l⟩▷v
=
∣a−l⟩
∣b−l⟩
∣c+l⟩
∣d +l⟩
and
∣a⟩
∣b⟩
∣c⟩
∣d⟩
∣δj⟩▷p
= δj(a+b−c−d)∣a⟩
∣b⟩
∣c⟩
∣d⟩
for ∣l⟩∈CZd and ∣δj⟩∈C(Zd).

Alexander Cowtan
3
Here ∣l⟩▷v subtracts in the case of arrows pointing towards the vertex and ∣δ j⟩▷p has c,d entering
negatively in the δ-function because these are contra to a clockwise ﬂow around the face in our conven-
tions. The vertex actions are built from four-fold copies of the operator X and X†, where Xl∣i⟩= ∣i+l⟩.
Consider the face actions of elements ∑j qm j∣δ j⟩, i.e. the Fourier transformed basis of C(Zd); these face
actions are made up of Z and Z†, where Zm∣i⟩= qmi∣i⟩, and the Z, X obey ZX = qXZ.
Stabilisers on the lattice are given by measurements of the X ⊗X ⊗X† ⊗X† and Z ⊗Z ⊗Z† ⊗Z† op-
erators on vertices and faces respectively; that is, for the vertices we non-deterministically perform one
of the d projectors Pv( j) = ∑k qjk∣k⟩▷v for j ∈Zd, according to each of the d measurement outcomes.
Similarly for faces, we perform one of the d projectors Pp( j) = ∣δ j⟩▷p. In practice, this requires addi-
tional ‘syndrome’ qudits at each vertex and face; we give explicit circuits for these in Appendix A. At
each round of measurement, we measure all of the stabilisers on the whole lattice. Physically, we may
also say that the system is in a subspace of a certain Hamiltonian:
H = −(∑
v
A(v)+∑
p
B(p))+const.
where
A(v) = Pv(0) = Λ▷v = 1
d ∑
i
∣i⟩▷v,
B(p) = Pp(0) = Λ∗▷p = ∣δ0⟩▷p.
It is easy to see that
A(v)2 = A(v),
B(p)2 = B(p),
[A(v),A(v′)] = [B(p),B(p′)] = [A(v),B(p)] = 0
where v,v′ are different vertices, and p, p′ are different faces.
When the measurements at a vertex v and face p yield the projectors A(v) and B(p) we say that
no errors were detected at these locations, and we are locally in the vacuum. Then if we obtain the
projectors A(v) and B(p) everywhere we are in the global vacuum space Hvac. One can check that a
state ∣vac⟩∈Hvac obeys
∣l⟩▷v∣vac⟩= A(v)∣vac⟩= ∑
j
qm j∣δj⟩▷p∣vac⟩= B(p)∣vac⟩= ∣vac⟩
for all l,m ∈Zd,v ∈V, p ∈P.
Deﬁnition 2.5. We can always write down at least two vacuum states1, which we shall call:
∣0⟩L ∶= ∏
v
A(v)⊗
E
∣0⟩
and
∣δ0⟩L ∶= ∏
p
B(p)⊗
E
∑
i
∣i⟩.
Computationally, the vacuum space is also the logical space, the subspace in which we store data;
the subscript L refers to this logical space, and ∣0⟩L, ∣δ0⟩L are canonical logical states.
If measurements yield other projectors Pv( j) or Pp( j) then we have detected an error; in physics
jargon we have detected the presence of an electric or magnetic particle. One important feature of the
code is that if we receive the measurement outcome Pv( j), say, at a vertex then there will be another
vertex at which we detect Pv(−j) instead. This is because all operators on the lattice come in the form of
string operators. String operators come in two types: X and Z.
1In certain cases, such as when the lattice is embedded onto a sphere, these states coincide.

4
Qudit lattice surgery
Deﬁnition 2.6. An X-type string operator xFi
ξ acts on the lattice as
∣a⟩
∣b⟩
∣d⟩
∣c⟩
xFi
ξ
=
∣a−i⟩∣b−i⟩
∣d −i⟩
∣c−i⟩
∣e⟩
∣e+i⟩
where ξ is a string that passes between faces and for each crossed edge we apply either an Xi or Xi†
depending on the orientation, as shown.
The X-type string operators satisfy (xFi
ξ)† = xF−i
ξ . Additionally we have
xFi
ξ ○xF j
ξ = xFi+j
ξ
and, given concatenated strings ξ,ξ ′,
xFi
ξ ′○ξ = xFi
ξ ′ ○xFi
ξ
where one can see multiplication and comultiplication of CZd; more generally they obey the same Hopf
laws as CZd. The other axioms are easy to check.
The X-type string operators make magnetic quasiparticles ‘appear’ at the faces at which a string ends.
In particular, given an initial vacuum state ∣vac⟩, we can check that
Pp0(i)xFi
ξ∣vac⟩= Pp1(−i)xFi
ξ∣vac⟩= xFi
ξ∣vac⟩
where p0, p1 are the start and endpoints of the string, so we will detect errors at these locations upon
measurement. However, the string operators leave the system in the vacuum in the intermediate faces of
the string, as we have:
B(p)xFi
ξ = xFi
ξB(p)
for any p ≠p0 or p1. As a consequence, we may think of string operators as equivalent up to a sort of
discrete framed isotopy.
Deﬁnition 2.7. A Z-type string operator zFδ j
ξ acts on the lattice as
zFδj
ξ
∣a⟩
∣b⟩
∣c⟩
∣d⟩
∣e⟩
=
∣a⟩
∣b⟩
∣c⟩
∣d⟩
∣e⟩
δj(a−b+c−d −e)
by passing between vertices. For each crossed edge we include a term in the δ-function, as shown.
Observe that ∑j qmjzFδ j
ξ applies a Zm or Zm† at each edge, and that this is the Fourier transformed basis
of the Z-type string operators.
The Z-type string operators satisfy (zFδi
ξ )† = zFδi
ξ . Additionally we have
zFδi
ξ ○zFδ j
ξ = δi,j zFδ j
ξ

Alexander Cowtan
5
and
zFδi
ξ ′○ξ = ∑
h
zFδh
ξ ′ ○zFδi−h
ξ
,
so Z-type string operators obey the same Hopf laws as C(Zd).
The Z-type string operators generate electric quasiparticles at the vertices at which a string ends. We
have
Pv0(i)∑
j
qijzFδ j
ξ ∣vac⟩= Pv1(−i)∑
j
qi jzFδ j
ξ ∣vac⟩= ∑
j
qi jzFδ j
ξ ∣vac⟩.
As a result, we refer to this basis of the Z-type string operators as the ‘quasiparticle basis’. They leave
the system in the vacuum in the intermediate vertices of the string:
A(v)∑
j
qi jzFδ j
ξ = ∑
j
qi jzFδ j
ξ A(v)
for any v ≠v0 or v1.
In the quasiparticle basis we have
∑
j
qijzFδ j
ξ ○∑
j
qk jzFδ j
ξ = ∑
j
q(i+k) jzFδ j
ξ
and
∑
j
qijzFδ j
ξ ′○ξ = ∑
j
qi jzFδ j
ξ ′ ○∑
k
qikzFδk
ξ
i.e. the same algebraic rules as the X-type string operators, and as CZd.
Lemma 2.8. [3] String operators which form a closed loop on a lattice segment which is locally vacuum
either act as identity or are physically impossible, i.e. they take the system to 0.
Proof. First, assume the string passes between faces, so we have an X-type string operator. In this case,
we may tile the loop with squares on the dual lattice (that is, the dual in the graph-theoretic sense).
Then one can check the closed string operator acts as a product over the tiles of ∣l⟩▷v actions. As
∣l⟩▷v∣vac⟩= ∣vac⟩the state is left unchanged.
If the string passes between vertices, tile the loop with squares. Consider the Z-type string operators
in the quasiparticle basis. Then the closed string operator acts as a product of ∑j qm j∣δj⟩▷p actions. As
∑j qm j∣δ j⟩▷p∣vac⟩= ∣vac⟩the state is left unchanged. In the original basis, the product of ∣δh⟩▷p actions
acts as identity if h = 0; otherwise it takes the system to 0.
We are now ready to deﬁne a patch.
Deﬁnition 2.9. A patch is a rectangular segment of lattice bordered by two rough and two smooth
boundaries, like so:
where rough boundaries are at the top and bottom, while smooth boundaries are at the left and right.2
2One can of course deﬁne patches with other combinations of boundaries, which are useful for speciﬁc kinds of circuits [7],
but this is a convenient deﬁnition for our purposes.

6
Qudit lattice surgery
There are assumed to be no parts of the lattice beyond the patch; these are all of the edges in the
lattice. The stabilisers on the boundaries are the same as in the bulk, with the exceptions that (a) stabilis-
ers obviously exclude the edges which are not present, and (b) there are no stabilisers for single edges.
So, in particular, there are no vertex measurements which include only the single top and bottom edges;
likewise, there are no face measurements which include only the single left and right edges.3
Lemma 2.10. Let the system be in a vacuum state. All X-type string operators which extend between the
left to right boundaries, for example in the manner below
leave the system in vacuum, but do not generally act as identity.
Proof. There are no face stabilisers for the single edges at the end, and at all other faces B(p) commutes
with the string operators. However, while the string can be smoothly deformed up and down the sides
of the patch while leaving the operation on the vacuum invariant, it cannot be expressed as a product of
vertex or face operators, and explicit checks on small (but nontrivial) examples show that xFi
ξ does not
act as identity unless i = 0.
In fact, we have a stronger property: all operators which act as a product of X operations on edges
and leave the system in vacuum may be expressed as a linear combination of X-type string operators
extending between left and right, so the d different X-type string operators xFi
ξ form an orthonormal
basis for the algebra of such operators. We have a similar result for the Z-type string operators in the
quasiparticle basis, which extend between the top and bottom boundaries. These properties motivate the
following:
Lemma 2.11. A patch as deﬁned above with underlying group algebra CZd has dim(Hvac) = d and two
canonical bases, {∣i⟩L}i∈Zd and {∣δi⟩L}i∈Zd.
Proof. The states in Hvac, and hence the logical space of the code, are uniquely characterised by the
algebra of operators upon them. Given a reference state ∣ref⟩in the vacuum, if there is another vacuum
state ∣ψ⟩there must be some linear map which transforms ∣ref⟩into ∣ψ⟩. Thus {xFi
ξ}i∈Zd automatically
gives an orthonormal basis for Hvac.
Let us call ∣0⟩L the reference state from Def 2.5. Then ∣i⟩L ∶= xFi
ξ∣0⟩L, where ξ is any string extending
from the left boundary to the right. We may call xFi
ξ a logical Xi gate, i.e. Xi
L.
As with CZd itself, we have a Fourier basis for the patch’s logical space. To begin with, we have
∣δ0⟩L = ∑i xFi
ξ∣0⟩L. Then, we deﬁne further logical states in the Fourier basis by ∣δi⟩L = ∑j qi jzFδ j
ξ ′ ∣δ0⟩L,
where now the string ξ ′ extends from the top to bottom, and we claim that ∣δi⟩L = ∑k q−ik∣k⟩L. We
check on a small example that this is consistent with Lemma 2.3 in Appendix B, and assert that it holds
generally. As a result we call ∑j qijzFδ j
ξ ′ a logical Zi gate, Zi
L.
3More generally, boundary conditions are deﬁned by a subgroup K ⊆Zd. This leads to a rich algebraic theory [18]. In the
present case, the subgroups K associated to rough and smooth boundaries are K = {0} and K = Zd respectively.

Alexander Cowtan
7
Note that the logical space is independent of the size of lattice, and depends only on the topology.
The lattice size is relevant only for the probability of correcting errors.
3
Lattice surgery
If we have two patches with logical spaces (Hvac)1 and (Hvac)2 which are disjoint in space then we
evidently have a combined logical space Hvac = (Hvac)1⊗(Hvac)2.
We may start with one patch and ‘split’ it to convert it into two patches.
3.1
Splits
To perform a smooth split, take a patch and measure out a string of intermediate qudits from top to
bottom in the {∣δi⟩} basis, like so:
×
×
Regardless of the measurement results we get, we now have two disjoint patches next to each other. We
can see the effect on the logical state by considering an X-type string operator which had been extending
across a string ξ from left to right on the original patch. Previously it had been xFi
ξ, say. Now, let
ξ = ξ ′′ ○ξ ′, where ξ ′ extends across the left patch after the split and ξ ′′ extends across right one. Then
xFi
ξ = xFi
ξ ′ ○xFi
ξ ′′; our Xi
L gate on the original logical space is taken to Xi
L⊗Xi
L on (Hvac)1⊗(Hvac)2. It is
easy to see that this then gives the map:
∆s ∶∣i⟩L ↦∣i⟩L ⊗∣i⟩L
for i ∈Zd. This is the same regardless of the measurement outcomes on the intermediate qubits we
measured out.
To perform a rough split, take a patch and measure out a string of qudits from left to right in the {∣i⟩}
basis. A similar analysis to before, but for Zi
L gates, shows that we have
∆r ∶∣δi⟩L ↦∣δi⟩L ⊗∣δi⟩L.
Remark 3.1. We now note a subtlety: for both smooth and rough splits we induce a copy in the relevant
bases, that is the comultiplication of CZd, rather than the comultiplication of C(Zd) for the rough splits.
This is because we are placing both algebras on the same object, using the non-natural isomorphism
V ≅V ∗for vector spaces V. Thus if we take the rough split map in the other basis we get
∆r ∶∣i⟩L ↦∑
h
∣h⟩L ⊗∣i−h⟩L.
This follows directly from Lemma 2.3. The fact that both algebras are placed on the same object allows
us to relate the model to the ZX-calculus in Section 4.

8
Qudit lattice surgery
3.2
Merges
To perform a smooth merge, we do the reverse operation. Start with two disjoint patches:
and then initialise between them a string of intermediate qudits, each in the ∑i∣i⟩state, like so:
∣i⟩
∣j⟩
∑i,j
Then measure the stabilisers at all sites on the now merged lattice. Now, assuming no errors have oc-
curred all the stabilisers are automatically satisﬁed everywhere except the measurements which include
the new edges. These measurements realise a measurement of ZL⊗ZL on the logical space (Hvac)1⊗(Hvac)2.
We prove this in Appendix C. With merges, the resultant logical state after merging is also dependent on
the measurement outcomes.
Depending on which ‘frame’ we choose we can have two different sets of possible maps from the
smooth merge, see [10] for the easier qubit case. Here we choose to adopt the Pauli frame of the second
patch. In the Fourier basis we thus have the Kraus operators:
∇s ∶{∣δi⟩L⊗∣δ j⟩L ↦qin∣δi+j⟩L}n∈{0,⋯,d−1}
where qin is a factor introduced by the ZL⊗ZL measurement; we have n ∈{0,⋯,d −1} for the d different
possible measurement outcomes. If we only consider the n = 0 case for a moment, one can come to the
conclusion that this is the correct map using the ZL logical operators:
∑
j
qijzFδ j
ξ ○∑
j
qk jzFδ j
ξ = ∑
j
q(i+k) jzFδ j
ξ
from earlier, where ξ extends from bottom to top on both original patches. Then when we merge the
patches, we get the combined string operator. In the other basis of logical states, the smooth merge gives:
∇s ∶{∣i⟩L⊗∣j⟩L ↦δi+n,j∣i+n⟩L}n∈{0,⋯,d−1},
Remark 3.2. It is common in categorical quantum mechanics to consider the so-called multiplicative
fragment of quantum mechanics. In this fragment, we may post-select rather than just make measure-
ments according to the traditional postulates. As such, there is a choice of post-selection such that n = 0
and we acquire the multiplication of CZd or C(Zd) depending on basis. While physically we cannot
post-select, this is a useful toy model in which algebraic notions may be more conveniently related to
quantum mechanical processes.

Alexander Cowtan
9
Considering the same convention of frame, a rough merge gives:
∇r ∶{∣i⟩L⊗∣j⟩L ↦qin∣i+ j⟩}n∈{0,⋯,d−1}
by a similar argument, this time performing a measurement of XL⊗XL to merge patches at the top and
bottom.
3.3
Units and deletion
While we are on the subject of measurements, we can delete a patch by measuring out every qudit
associated to its lattice in the Z-basis. If we do so, we obtain the maps
εr ∶{∣i⟩L ↦δn,i}n∈{0,⋯,d−1}.
In the n = 0 outcome this is precisely the counit of C(Zd). We check this in Appendix D. If we instead
measure out each qudit in the X-basis we get
εs ∶{∣i⟩L ↦qin}n∈{0,⋯,d−1},
where we see the counit of CZd.
One can clearly also construct the units of C(Zd) and CZd, being ηs ∶∑i∣i⟩L and ηr ∶∣0⟩L respectively.
The last remaining pieces of the puzzle are the antipode and Fourier transform on the logical space.
3.4
Antipode
First we demonstrate how to map between the ∣0⟩L and ∣δi⟩L states. If we apply a Fourier transform
H = ∑j,k q−jk∣k⟩⟨j∣to a qudit in the state ∣0⟩we have H∣0⟩= ∑i∣i⟩.4 As HX = Z†H (and XH = HZ) all
A(v) projectors are translated to B(p) projectors by rotating the lattice to exchange vertices with faces
↦
such that the X,X† match up with Z†,Z appropriately when considering the clockwise conventions from
Def 2.4. This is just a conceptual rotation, and there does not need to be any physical rotation in space.
Thus we have
HL∣0⟩L = (⊗
E
H)∏
v
A(v)⊗
E
∣0⟩= ∏
p
B(p)⊗
E
∑
i
∣i⟩= ∣δi⟩L
where HL = ⊗E H is the logical Fourier transform, and the lattice has been mapped:
↦
4The H stands for Hadamard, which is what the qubit Fourier transform is commonly called. The qudit Fourier transform
is not a Hadamard matrix in general.

10
Qudit lattice surgery
HL also takes X-type string operators to Z-type string operators in the quasiparticle basis but with a
sign change, and thus we have
HL∣i⟩L = HLXi∣0⟩L = Z−iHL∣0⟩L = ∑
k
q−ik∣k⟩L = ∣δi⟩L
so it is genuinely a Fourier transform. Applying it twice gives
HLHL∣i⟩L = ∑
k,l
q−ikq−kl∣l⟩L = ∑
l
δl,−i∣l⟩L = ∣−i⟩L
where the lattice is now as though the whole patch has been rotated in space by π by the same argument
as before. This is evidently the logical antipode, SL = HLHL.
This completes the set of fault-tolerant operations we may perform with the CZd lattice surgery. One
can create other states in a non-error corrected manner and then perform state distillation to acquire the
correct state with a high probability, but this is beyond the scope of the paper and very similar to e.g.
[19].
4
The ZX-calculus
The ZX-calculus is based on Hopf-Frobenius algebras sitting on the same object. It imports ideas from
monoidal category theory to justify its graphical formalism [20]. See [24] for an introduction from the
categorical point of view. Calculations may be performed by transforming diagrams into one another,
and the calculus may be thought of as a tensor network theory equipped with rewriting rules.
Here we present the syntax and semantics of ZX-diagrams for CZd. We are unconcerned with either
universality or completeness [21], and give only the necessary generators for our purposes; moreover,
we adopt a slightly simpliﬁed convention. First, we have generators:
b
∑iq−ib∣i⟩
a
∣a⟩
;
;
for elements, where the small red and green nodes are called ‘spiders’, and diagrams ﬂow from bottom
to top.5 The labels associated to a spider are called phases. Then we have the multiplication maps,
∣i⟩⊗∣j⟩↦∣i+ j⟩
∣i⟩⊗∣j⟩↦δi,j∣i⟩
;
;
comultiplication,
;
∣i⟩↦∣i⟩⊗∣i⟩
∣i⟩↦∑h∣h⟩⊗∣i−h⟩
;
maps to C,
b
∣i⟩↦qib
a
∣i⟩↦δi,a
;
;
5Red and green are dark and light shades in greyscale.

Alexander Cowtan
11
and Fourier transform6 plus antipode:
∣j⟩↦∑iq−i j∣i⟩
∣i⟩↦∣−i⟩
S
;
;
Now, these generators obey all the normal Hopf rules: associativity of multiplication and comultiplica-
tion, unit and counit, bialgebra and antipode laws, but that it is not all. The ZX-calculus makes use of an
old result by Pareigis [22], which states that all ﬁnite-dimensional Hopf algebras on vector spaces auto-
matically give two Frobenius structures, which in the present case correspond to the red and green spiders
above. In this case, they are in fact so-called †-special commutative Frobenius algebras (†-SFCAs) [23].
Such algebras have a normal form, such that any connected set of green or red spiders may be combined
into a single green or red spider respectively, summing the phases [9]. This is called the spider theorem.
As an easy example, observe that we can deﬁne the Xa gate in the ZX-calculus as:
=
a
a ; ∣j⟩↦∣j+a⟩
and similarly for a Zb gate,
=
a
a ; ∣j⟩↦q−b j∣j⟩
b
b
.
The Fourier transform then ‘changes colour’ between green and red spiders. We show these axioms in
Appendix E. For a detailed exposition of the qudit ZX-calculus in greater generality see [13].
Now, one can immediately see that the generators are automatically (by virtue of the CZd and C(Zd)
structures) in bijection with the lattice surgery operations described previously. The bijection between
this fragment of the ZX-calculus and lattice surgery was spotted by de Beaudrap and Horsman in the qubit
case [10]; however, their presentation emphasises the Frobenius structures. The algebraic explanation for
the lattice surgery properties is all in the Hopf structure: in summary, it is because the string operators are
Hopf-like.7 The Frobenius structures are still useful diagrammatic reasoning tools because of the spider
theorem, and also because the two interacting Frobenius algebras correspond to the rough (red spider)
and smooth (green spider) operations. There is a convenient 3-dimensional visualisation for this using
‘logical blocks’, which we defer to Appendix F. There we also include Table 1, which is a dictionary
between lattice operations, ZX-diagrams and linear maps.
4.1
Gate synthesis
Using the ZX-calculus we can thus design logical protocols in a straightforward manner. We have already
implicitly shown a state injection protocol, being the spider merges for the Xa and Zb gates above, but
we can go further. A common gate in the circuit model is the controlled-X (CX) gate. In qudit quantum
computing this is deﬁned as the map
CX ∶∣i⟩⊗∣j⟩↦∣i⟩⊗∣i+ j⟩
6The Hadamard symbol here makes it look like it is vertically reversible, i.e. H† = H, but it is not; this is just a notational
ﬂaw.
7We formalise such operators as module maps in [16].

12
Qudit lattice surgery
which in the ZX-calculus we might represent as, say,
=
=
=
S
S
.
In the ﬁrst diagram we perform a smooth split followed by a rough merge; in the second we do the oppo-
site. In the third and fourth we ﬁrst generate a maximally entangled state and then perform a smooth and
rough merge on either side. The antipodes are necessary because of a minor complication with duals in
the qudit ZX-calculus. Rewrites using the calculus show that these are equal, and conversions into linear
maps do indeed yield the CX. We check this in Appendix G. Note that we implicitly assumed the n = 0
measurement outcomes for the merges, but we assert that in this case the protocol works deterministi-
cally by applying corrections. This is a generalisation of protocols speciﬁed in [10], and the correction
arguments are identical.
We can also easily see that the lattice surgery operations are not universal, even with the addition of
logical XL and ZL gates using string operators. All phases have integer values and so we cannot even
achieve all single-qudit gates in the 2nd level of the Clifford hierarchy fault-tolerantly. For example, we
cannot construct a
√
XL gate with the operations listed here.
With this limitation in mind, in Appendix H we discuss the prospects for expanding the scope of the
model to other group algebras and to Hopf algebras more generally.
5
Conclusion
We have shown that lattice surgery is straightforward to generalise to qudits, assuming an underlying
abelian group structure. The resultant diagrammatics which can be used to describe computation are
elegant, concise and powerful. We currently do not know how this generalises further, and what the
connections are to quantum ﬁeld theories. We aim to tackle these issues in future work.
6
Acknowledgements
We thank the Wolfson Harrison UK Research Council Quantum Foundation Scholarship for making this
work possible.
References
[1] E. Dennis, A. Kitaev, A. Landahl and J. Preskill, Topological quantum memory, J. Math. Phys. 43, 4452-4505
(2002)
[2] S. Bravyi and A. Kitaev, Quantum codes on a lattice with boundary, arXiv:quant-ph/9811052 [quant-ph]
[3] A. Kitaev, Fault-tolerant quantum computation by anyons, Annals Phys. 303 (2003) 2-30
[4] D. Horsman, A. G. Fowler, S. Devitt and R. Van Meter, New J. Phys. 14 (2012) 123011
[5] D. S. Wang, A. G. Fowler and L. C. L. Hollenberg, Quantum computing with nearest neighbor interactions
and error rates over 1%, Phys. Rev. A (2011) 83:020302(R)
[6] A. G. Fowler and C. Gidney, Low overhead quantum computation using lattice surgery, arXiv:1808.06709
[quant-ph]

Alexander Cowtan
13
[7] D. Litinski, A Game of Surface Codes: Large-Scale Quantum Computing with Lattice Surgery, Quantum 3,
128 (2019)
[8] A. G. Fowler, M. Mariantoni, J. M. Martinis, A. N. Cleland, Surface codes: Towards practical large-scale
quantum computation, Phys. Rev. A 86, 032324 (2012)
[9] B. Coecke and R. Duncan, Interacting Quantum Observables: Categorical Algebra and Diagrammatics, New
J. Phys. 13 (2011)
[10] N. de Beaudrap and D. Horsman, The ZX calculus is a language for surface code lattice surgery, Quantum 4,
218 (2020)
[11] C. Gidney and A. G. Fowler, Efﬁcient magic state factories with a catalyzed ∣CCZ⟩to 2∣T⟩transformation,
Quantum 3, 135 (2019)
[12] N. de Beaudrap, R. Duncan, D. Horsman and S. Perdrix, Pauli Fusion: a Computational Model to Realise
Quantum Transformations from ZX Terms, EPTCS 318 (2020) pp. 85-105
[13] Q. Wang, Quﬁnite ZX-calculus: a uniﬁed framework of qudit ZX-calculi, arXiv:2104.06429 [quant-ph]
[14] D. Reutter, Frobenius algebras, Hopf algebras and 3-categories, Hopf Algebras in Kitaev’s Quantum Double
Models: Mathematical Connections from Gauge Theory to Topological Quantum Computing and Categorical
Quantum Mechanics
[15] H. Bombin and M. A. Martin-Delgado, Family of non-Abelian Kitaev models on a lattice: Topological
condensation and conﬁnement, Phys. Rev. B 78 (2008) 115421
[16] A. Cowtan and S. Majid, Quantum double aspects of surface code models, J. Math. Phys. 63, 042202 (2022)
[17] D. Gottesman, Stabilizer Codes and Quantum Error Correction, Caltech Ph.D. Thesis (1997)
[18] S. Beigi, P. Shor and D. Whalen, The quantum double model with boundary: condensations and symmetries,
Comm. Math. Phys. 306 (2011) 663–694
[19] A. G. Fowler, A. M. Stephens and Peter Groszkowski, High-threshold universal quantum computation on the
surface code, Phys. Rev. A 80 (2009) 052312
[20] P. Selinger, A survey of graphical languages for monoidal categories, Springer Lecture Notes in Physics 813,
pp. 289-355, 2011
[21] M. Backens, Completeness and the ZX-calculus, arXiv:1602.08954 [quant-ph]
[22] B. Pareigis, When Hopf algebras are Frobenius algebras, J. Alg., Volume 18, Issue 4 (1971) 588-596
[23] B. Coecke, D. Pavlovic and J. Vicary, A new description of orthogonal bases, Mathematical Structures in
Computer Science (2012)
[24] C. Heunen and J. Vicary, Categories for Quantum Theory: An Introduction, Oxford University Press (2019)
DOI:10.1093/oso/9780198739623.001.0001
[25] H. Bombin, C. Dawson, R. V. Mishmash, N. Nickerson, F. Pastawski, S. Roberts, Logical blocks for fault-
tolerant topological quantum computation, arXiv:2112.12160 [quant-ph]
[26] P. Schauenburg, Computing Higher Frobenius-Schur Indicators in Fusion Categories Constructed from In-
clusions of Finite Groups, Paciﬁc J. Math. 280 (2016) 177–201
[27] P. Etingof, S. Gelaki, D. Nikshych and V. Ostrik, Tensor Categories, Mathematical Surveys and Monographs
205 (2010)
[28] A. Cowtan and S. Majid, On the algebraic structure of boundaries in Hopf double models, In preparation
[29] C. Meusburger, Kitaev lattice models as a Hopf algebra gauge theory, Commun. Math. Phys. 353 (2017)
413–468
[30] P. Chen, S. Cui and B. Yan, Ribbon operators in the generalized Kitaev quantum double model based on Hopf
algebras, arXiv:2105.08202 [cond-mat.str-el]
[31] V. Ostrik, Module categories, weak Hopf algebras and modular invariants, Transform. Groups 8 (2003) 177—
206

14
Qudit lattice surgery
[32] B. Balsam and A. Kirillov, Jr., Kitaev’s lattice model and Turaev-Viro TQFTs, arXiv:1206.2308 [math.QA]
[33] A. Kapustin and N. Saulina,
Topological boundary conditions in abelian Chern-Simons theory,
Nucl.Phys.B845:393-435 (2011)
[34] J. Fuchs and C. Schweigert, Category theory for conformal boundary conditions, Fields Institute Communi-
cations 39 (2003) 25–71
[35] A. D. Lauda, Frobenius algebras and planar open string topological ﬁeld theories, arXiv:math/0508349
[math.QA]
[36] J. Kock, Frobenius Algebras and 2-D Topological Quantum Field Theories (London Mathematical Society
Student Texts), Cambridge: Cambridge University Press (2003) doi:10.1017/CBO9780511615443
[37] S. Majid, Foundations of Quantum Group Theory, Cambridge University Press, (1995); paperback ed. (2000)
A
Circuits for measuring stabilisers
Given the face
w1
w2
w3
w4
we can perform a face measurement using the circuit
∣0⟩
⊕⊕⊕⊕
MZ
w1
w2
w3
w4
i.e. a measurement of the Z⊗Z⊗Z†⊗Z† operator. The CX gates act as ∣i⟩⊗∣j⟩↦∣i⟩⊗∣i+ j⟩, and the
yellow boxes are Fourier transforms H. Note that H2 ∶∣i⟩↦∣−i⟩. Hence one can calculate that this
circuit is the map
∣i⟩⊗∣j⟩⊗∣k⟩⊗∣l⟩↦δa(i+ j−k−l)∣i⟩⊗∣j⟩⊗∣k⟩⊗∣l⟩
for some a ∈Zd. For a vertex
u1
u2
u3
u4
we have
∣0⟩
MZ
⊕
⊕
⊕
⊕
†
u1
u2
u3
u4
measuring the X ⊗X ⊗X†⊗X† operator. The CX gates also act as ∣δi⟩⊗∣δj⟩↦∣δi−j⟩⊗∣δj⟩, motivating
the exchanged control and target and application of H2 to the other qudits. Then we see that this circuit
is the map
∣δi⟩⊗∣δ j⟩⊗∣δk⟩⊗∣δl⟩↦δb(i+ j−k−l)∣δi⟩⊗∣δj⟩⊗∣δk⟩⊗∣δl⟩

Alexander Cowtan
15
for some b ∈Zd.
B
Fourier basis for patches
Consider the small patch
Now, ∣i⟩L is the following state:
∏vA(v)
∣0⟩
∣0⟩
∣0⟩
∣i⟩
∣0⟩
∣i⟩
∣0⟩
∣0⟩
=
∑a,b,c,d
∣a⟩
∣c⟩
∣a−c⟩
∣i+b−a⟩∣b−d⟩∣i+d −c⟩
∣−b⟩
∣−d⟩
where we have taken ∣0⟩L and applied an X-type string from left to right. Now, consider ∣δ0⟩L:
∏pB(p)∑a,b,c,d,e,f,g,h
∣a⟩
∣c⟩
∣b⟩
∣d⟩
∣e⟩
∣f⟩
∣g⟩
∣h⟩
∣a⟩
∣c⟩
∣b⟩
∣d⟩
∣e⟩
∣f⟩
∣g⟩
∣h⟩
δ0(a−c−b)
= ∑a,b,c,d,e,f,g,h δ0(d +b−f −e)
δ0(g+e−h)
∣a⟩
∣c⟩
∣a−c⟩
∣d⟩∣g−h⟩∣f⟩
∣−g⟩
∣−h⟩
= ∑a,c,d,f,g,hδ0(d +a−c−f −g+h)
where we performed a change of variables g ↦−g, h ↦−h. Now, δ0(d + a −c −f −g + h) holds iff
d +a−g = i and −f −c+h = −i for some i ∈Zd. Thus we have ∣δ0⟩L = ∑i∣i⟩L. If we then apply a Z-type
string operator from top to bottom in the quasiparticle basis we see that ∣δj⟩L = ∑iq−i j∣i⟩L.
One could then show that the bases are consistent under Fourier transform for all sizes of patch by
induction, using the above as the base case.

16
Qudit lattice surgery
C
Proof of lattice merges
We demonstrate the smooth merge on a small patch but it is easy to see that the same method applies for
arbitrary large patches. We begin with two patches, in the ∣δg⟩L and ∣δh⟩L states respectively.
∑a,b,c,d,iqig
∣a⟩
∣c⟩
∣a−c⟩
∣i+b−a⟩∣b−d⟩∣i+d −c⟩
∣−b⟩
∣−d⟩
∑w,x,y,z,j qjh
∣w⟩
∣y⟩
∣w−y⟩
∣j+x−w⟩∣x−z⟩∣j+z−y⟩
∣−x⟩
∣−z⟩
Then initialise two new edges between, each in the ∣δ0⟩state.
∑a,b,c,d,i,j,k,l,w,x,y,zqig+jh
∣a⟩
∣c⟩
∣a−c⟩
∣i+b−a⟩∣b−d⟩∣i+d −c⟩
∣−b⟩
∣−d⟩
∣w⟩
∣y⟩
∣w−y⟩
∣j+x−w⟩∣x−z⟩∣j+z−y⟩
∣−x⟩
∣−z⟩
∣k⟩
∣l⟩
where we have exaggerated the length of the new edges for emphasis. Now if we apply stabiliser mea-
surements at all points we see that the only relevant ones are the face measurements including the new
edges (the vertex measurements will still yield A(v) unless a physical error has appeared there). The
relevant measurements give us
δs(c−w−k);
δr(k+i+d −c−j−x+w−l);
δt(−d +l +x)
for each new face, where r,s,t ∈Zd. By substitution this gives
δr(k+i+d −c−j−x+w−l) = δr(−t −s+i−j) = δr+t+s(i−j) = δn(i−j) = δi(n+ j)
where n is the group product of r,t,s in Zd. Computationally, n is the important measurement outcome
of the merge. Plugging back in to the patches we have
∑a,b,c,d,j,w,x,y,zqng+j(g+h)
∣a⟩
∣c⟩
∣a−c⟩
∣n+ j+b−a⟩∣b−d⟩∣n+ j+d −c⟩
∣−b⟩
∣−d⟩
∣w⟩
∣y⟩
∣w−y⟩
∣j+x−w⟩∣x−z⟩∣j+z−y⟩
∣−x⟩
∣−z⟩
∣c−w−s⟩
∣t +d −x⟩
In the positive outcome case, i.e. when s = r = t = 0, it is immediate that we have ∣δg+h⟩L on the combined
patch. Otherwise, we can ‘ﬁx’ the internal additions of s,t,n to the edges with string operators or alter-
natively accommodate them into the Pauli frame in the same manner as described in e.g. [10]. Then we
are left with qng∣δg+h⟩L, as stated.
The Fourier transformed version of the above explains the rough merges as well, so we do not de-
scribe it explicitly.

Alexander Cowtan
17
D
Proof of lattice counits
We now show a ‘smooth counit’ on a patch with state ∣δ j⟩L:
∑a,b,c,d,iqig
∣a⟩
∣c⟩
∣a−c⟩
∣i+b−a⟩∣b−d⟩∣i+d −c⟩
∣−b⟩
∣−d⟩
Measure out all edges in the Z basis, giving
∑
a,b,c,d,i
qijδr(a)δs(a−c)δt(c)δu(i+b−a)δv(b−d)δw(i+d −c)δx(−b)δy(−d)
for some r,⋯,y ∈Zd. Then we observe that δu(i+b−a) = δi(a−b−u) = δi(n) for n = a−b−u, and by
performing some other substitutions we arrive at
qnjδv(y−x)δw(n−y−t)δs(n−u−x−t)
Importantly, the only factor here which depends on the input state is qn j. All the δ-functions are merely
conditions regarding which measurement outcomes are possible due to the lattice geometry. These will
always be satisﬁed by our measurements, thus we have just
∣δ j⟩L ↦qn j
for n ∈Zd, which in the other basis is ∣i⟩L ↦δn,i as stated. The rough counit follows similarly.
E
Qudit ZX-calculus axioms
We show some relevant axioms for the fragment of qudit ZX-calculus which interests us. These simply
coincide with the rules from Hopf and Frobenius structures, along with the Fourier transform. We ignore
the more general phase group [13], and also leave out non-zero scalars. First, we deﬁne a spider
n
⋯
⋯
n
∶=
⋯
⋯
which is well-deﬁned due to associativity and specialty of the underlying Frobenius structure. The spider
is also invariant under exchange of input wires with each other and the same for outputs, as the Frobenius
algebra is (co)-commutative. A phaseless spider with 1 input and 1 output is identity:
=

18
Qudit lattice surgery
Now, we can deﬁne duality morphisms on the object CZd, which we call a ‘cup’ and similarly a ‘cap’:
;
∑i∈Zd ∣i⟩⊗∣i⟩
;
∣i⟩⊗∣j⟩↦δi,j
which correspond to:
=
=
S
=
S
for the cup, and the vertically ﬂipped version for the cap. The antipodes included here are responsible
for the antipodes in the CX gate in Section 4.1. Then we have the Fourier exchange rule:
n
†
†
=
⋯
⋯
n
⋯
⋯
n
which encodes Lemma 2.3 graphically.
Then we have the bialgebra rules
=
=
=
and rules pertaining to the antipode:
=
=
S
S
S
=
=
†
†
=
†
† =
This is far from an exhaustive set of rules.
F
The logical block depiction
The lattice at a given time is drawn with a red line for a smooth boundary and green for a rough boundary:

Alexander Cowtan
19
where the surface is shaded blue for clarity. A block extending upwards represents the transformation
over time. For example:
We call this the ‘logical block’ depiction, following similar work in [25].
Table 1 is an explicit dictionary between lattice surgery operations, qudit ZX-calculus and linear
maps in the multiplicative fragment, i.e. the n = 0 measurement outcomes. We choose to use the mul-
tiplicative fragment to highlight the visual connection between the columns. We see that red and green
spiders correspond to rough and smooth operations respectively.
We have no new results or proofs in this section, but we would like to discuss the diagrams of logical
blocks. These sorts of diagrams for lattice surgery have been used in an engineering setting to compile
quantum circuits to lattice surgery [11, 25]. To go from the cubes shown there to the tubes which we
show here we merely relax the discretisation of space and time somewhat to expose the relationship with
algebra. This relationship with algebra is relevant because such diagrams have appeared in a seemingly
quite different context.
It is well known that the category of ‘2-dimensional thick tangles’, 2Thick, is monoidally equivalent
to the category Frob freely generated by a noncommutative Frobenius algebra [35]. This should be
unsurprising to those familiar with the notion of a ‘pair of pants’ algebra. We say that 2Thick is a
presentation of Frob. Similarly, the symmetric monoidal category 2Cob of (diffeomorphism classes
of) 2-dimensional cobordisms between (disjoint unions of) circles is a presentation of ComFrob, the
category freely generated by a commutative Frobenius algebra [36].
This fact is important for topological quantum ﬁeld theories (TQFTs). One can deﬁne an n-dimensional
TQFT as a symmetric monoidal functor from nCob →Vect, the category of ﬁnite-dimensional vector
spaces. The key point is that the functor takes (diffeomorphism classes of) manifolds as inputs and out-
puts linear maps between vector spaces, which are by deﬁnition manifold invariants. One can see that
2D TQFTs are in bijection with commutative Frobenius algebras in Vect.
In [14], Reutter gives a slightly different monoidal category, which we will call 2Block. It has as
objects disjoint unions of squares, with the same shading of sides as those in the logical block diagrams
above. Then morphisms are classes of surfaces between the squares, such that the borders between the
surfaces match up with the edges of the squares at the source and target objects and the surface colours are
consistent with those of the squares’ sides. While the morphisms are obviously quotiented by equivalence
of surfaces up to border-preserving diffeomorphism, Reutter quotients by ‘saddle-invertibility’ as well,
which is not a rule one can acquire through topological moves alone, as it involves the closing and
opening of holes.
Reutter conjectures that 2Block ≃uHopf, where uHopf is the category freely generated by a unimod-
ular Hopf algebra.8 While we do not know enough about topology or geometry to prove (or disprove)
this conjecture, we suspect one route is to consider Morse functions and classify the diffeomorphism
classes near critical points. This is similar to one proof of 2Cob ≃ComFrob [36]. For the reader’s con-
venience, we now reproduce a handful of the equivalences under topological deformation which motivate
8In Vect, unimodularity is typically deﬁned using integrals [37]. In this more abstract setting it is deﬁned by some axioms
on dualities.

20
Qudit lattice surgery
Lattice operation
Logical block
ZX-diagram
Linear map
smooth unit
∑
i
∣i⟩
smooth split
∣i⟩↦∣i⟩⊗∣i⟩
smooth merge
∣i⟩⊗∣j⟩↦δi,j∣i⟩
smooth counit
∣i⟩↦1
rough unit
∣0⟩
rough split
∣i⟩↦∑
h
∣h⟩⊗∣i−h⟩
rough merge
∣i⟩⊗∣j⟩↦∣i+ j⟩
rough counit
∣i⟩↦δi,0
rotation
∣i⟩↦∑
j
q−i j∣j⟩
Table 1: Dictionary of lattice surgery operations in the multiplicative fragment.

Alexander Cowtan
21
this conjecture. We have the axioms of a Frobenius algebra,
and the same for red faces. These are just widened versions of the diagrams in 2Thick. Then one can
see the interpretation of a unimodular Hopf algebra as two interacting Frobenius algebras. We start with
two Frobenius algebras and glue them together in such a way that they give the bialgebra and antipode
axioms. The main bialgebra rule is
where we require saddle invertibility to close up a hole in the middle. This is also required for showing
that comultiplication is a unit map and so on. Given all of these deformations and those involving the
antipode, which is a twist by π, one can see that they deﬁne a functor uHopf →2Block; the hard part is
proving that this is an equivalence.
Now, Reutter also draws a comparison with representation theory and tensor category theory. It is
striking that, given the unimodular Hopf algebra CZd, we can create a logical space on a patch isomor-
phic to the vector space of CZd itself, and the logical operations precisely coincide with the linear maps
deﬁned by the algebra. We conjecture that lattice surgery is the ‘computational implementation’ of this
presentation of unimodular Hopf algebras, in the same way that the logical space of the Kitaev model on
a closed orientable manifold M is isomorphic to the vector space F(M) in the image of a Dijkgraaf-
Witten theory F ∶2Cob →Vect when given the same manifold M [16, Thm 3.2]. It remains to be seen
whether this extends further than just abelian group algebras.
G
Logical CX gate
Here we check the correctness of the CX gate implementations from Section 4.1.

22
Qudit lattice surgery
First, observe that the diagram:
yields the linear map:
∣i⟩⊗∣j⟩↦∣i⟩⊗∣i⟩⊗∣j⟩↦∣i⟩⊗∣i+ j⟩
where we have considered the diagram piecemeal from bottom to top, indicated by the dashed lines.
Then we can perform a sequence of rewrites between all four diagrams, labelled below:
=
S
=
=
S
S
=
=
where at each stage we have either used the spider rule, inserted duals, or swapped between duals and
spiders; see Appendix E.
H
Generalisations and Hopf algebras
While we have shown that lattice surgery works for arbitrary dimensional qudits, we emphasise that the
algebraic structures involved are very simple so far. The lattice model in the bulk can be generalised
signiﬁcantly: ﬁrst, one can replace CZd with another ﬁnite abelian group algebra. As all ﬁnite abelian
groups decompose into direct sums of cyclic groups this case follows immediately from the work herein
and is uninteresting.
At the second level up, we can replace it with an arbitrary ﬁnite group algebra CG. At this level
several assumptions break down:
• CG still has a dual function algebra C(G), but the Fourier transform no longer coincides with
Pontryagin duality, and the two algebras will no longer be isomorphic in general. One can still
deﬁne a Fourier transform in the sense that it translates between convolution and multiplication,
but in this case the Fourier transform is the Peter-Weyl isomorphism, i.e. a bimodule isomorphism
between CG and a direct sum of matrix algebras labelled by the irreps of G.
• The CG lattice model can no longer be described using string operators, and these must be pro-
moted to ribbon operators [3]. This is because the lattice model is based on the Drinfeld double
D(G) = C(G)>◁CG, where the associated action is conjugation. In the abelian case conjugation
acts trivially and so we have D(Zd) = C(Zd)⊗CZd: the double splits into independent algebras,
which give the X-type and Z-type string operators respectively.

Alexander Cowtan
23
• There are still canonical choices of rough and smooth boundary, labelled by subgroups K = {e}
and K = G for rough and smooth boundaries respectively. Similarly, we still have well-deﬁned
measurements, using representations of CG and C(G) for vertices and faces. However, the alge-
bra of ribbon operators which are undetectable at the boundary, and hence the logical operations
on a patch, becomes signiﬁcantly more complicated, see [26] for the underlying module theory.
Preliminary calculations indicate that they are labelled by conjugacy classes (i.e. irreps) of G, and
it is not even obvious that dim(Hvac) = ∣G∣as in the abelian case. This is quite an obstruction to
calculating the logical maps corresponding to lattice surgery operations.
Of course, the Kitaev model can be generalised much further still. The third level would be arbitrary
ﬁnite-dimensional Hopf C∗-algebras. At this level even the calculations in the bulk are tricky, and many
features were only recently resolved [16, 29, 30]. Understanding lattice surgery in these models seems a
formidable task. We aim to at least make some progress on this in upcoming work [28].
The fourth (and highest) level is the maximal generality, which are weak Hopf C∗-algebras, in bijec-
tion (up to an equivalence) with so-called unitary fusion categories [27]. Even at this extreme generality,
there are glimpses of hope. There are two canonical choices of boundaries given by the trivial (rough)
and regular (smooth) module categories [31], and we speculate that calculating some basic features like
dim(Hvac) of a patch could be done using techniques from topological quantum ﬁeld theory (TQFT).
At this level of generality, the connections with TQFT become more tantalising. The parallels between
topological quantum computing in the bulk and TQFTs are well-known, see e.g. [32], but lattice surgery
introduces discontinuous deformations in the manner of geometric surgery. While boundaries of TQFTs
are well-studied [33, 34], we do not know whether TQFT theorists study the relation between geometric
surgery on manifolds and linear algebra in the same manner as they do for, say, diffeomorphism classes
of cobordisms.

