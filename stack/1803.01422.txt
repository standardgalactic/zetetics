DAGs with NO TEARS: Continuous Optimization for Structure Learning
Xun Zheng, Bryon Aragam, Pradeep Ravikumar, and Eric P. Xing
Carnegie Mellon University
November 6, 2018
Abstract
Estimating the structure of directed acyclic graphs (DAGs, also known as Bayesian networks) is a
challenging problem since the search space of DAGs is combinatorial and scales superexponentially with the
number of nodes. Existing approaches rely on various local heuristics for enforcing the acyclicity constraint.
In this paper, we introduce a fundamentally diﬀerent strategy: We formulate the structure learning
problem as a purely continuous optimization problem over real matrices that avoids this combinatorial
constraint entirely. This is achieved by a novel characterization of acyclicity that is not only smooth but
also exact. The resulting problem can be eﬃciently solved by standard numerical algorithms, which also
makes implementation eﬀortless. The proposed method outperforms existing ones, without imposing any
structural assumptions on the graph such as bounded treewidth or in-degree. Code implementing the
proposed algorithm is open-source and publicly available at https://github.com/xunzheng/notears.
1
Introduction
Learning directed acyclic graphs (DAGs) from data is an NP-hard problem (Chickering, 1996; Chickering
et al., 2004), owing mainly to the combinatorial acyclicity constraint that is diﬃcult to enforce eﬃciently.
At the same time, DAGs are popular models in practice, with applications in biology (Sachs et al., 2005),
genetics (Zhang et al., 2013), machine learning (Koller and Friedman, 2009), and causal inference (Spirtes
et al., 2000). For this reason, the development of new methods for learning DAGs remains a central challenge
in machine learning and statistics.
In this paper, we propose a new approach for score-based learning of DAGs by converting the traditional
combinatorial optimization problem (left) into a continuous program (right):
min
W ∈Rd×d F(W)
subject to G(W) ∈DAGs
⇐⇒
min
W ∈Rd×d F(W)
subject to h(W) = 0,
(1)
where G(W) is the d-node graph induced by the weighted adjacency matrix W, F : Rd×d →R is a score
function (see Section 2.1 for details), and our key technical device h : Rd×d →R is a smooth function
over real matrices, whose level set at zero exactly characterizes acyclic graphs. Although the two problems
are equivalent, the continuous program on the right eliminates the need for specialized algorithms that
are tailored to search over the combinatorial space of DAGs. Instead, we are able to leverage standard
numerical algorithms for constrained problems, which makes implementation particularly easy, not requiring
any knowledge about graphical models. This is similar in spirit to the situation for undirected graphical
models, in which the formulation of a continuous log-det program (Banerjee et al., 2008) sparked a series of
remarkable advances in structure learning for undirected graphs (Section 2.2). Unlike undirected models,
which can be reduced to a convex program, however, the program (1) is nonconvex. Nonetheless, as we will
show, even na¨ıve solutions to this program yield state-of-the-art results for learning DAGs.
Contact: xzheng1@andrew.cmu.edu, naragam@cs.cmu.edu, pradeepr@cs.cmu.edu, epxing@cs.cmu.edu
1
arXiv:1803.01422v2  [stat.ML]  3 Nov 2018

0
5
10
15
0
5
10
15
W
(a) true graph
0
5
10
15
0
5
10
15
f
WECP(0)
0
5
10
15
f
WECP(0.1)
0
5
10
15
BFGS
-2
0
+2
(b) estimate with n = 1000
0
5
10
15
0
5
10
15
f
WECP(0)
0
5
10
15
f
WECP(0.1)
0
5
10
15
BFGS
-2
0
+2
(c) estimate with n = 20
Figure 1: Visual comparison of the learned weighted adjacency matrix on a 20-node graph with n = 1000
(large samples) and n = 20 (insuﬃcient samples): f
WECP(λ) is the proposed NOTEARS algorithm with
ℓ1-regularization λ, and BFGS is the binary estimate of the baseline (Ramsey et al., 2016). The proposed
algorithms perform well on large samples, and remains accurate on small n with ℓ1 regularization.
Contributions.
The main thrust of this work is to re-formulate score-based learning of DAGs so that
standard smooth optimization schemes such as L-BFGS (Nocedal and Wright, 2006) can be leveraged. To
accomplish this, we make the following speciﬁc contributions:
• We explicitly construct a smooth function over Rd×d with computable derivatives that encodes the
acyclicity constraint. This allows us to replace the combinatorial constraint G ∈D in (4) with a smooth
equality constraint.
• We develop an equality-constrained program for simultaneously estimating the structure and parameters
of a sparse DAG from possibly high-dimensional data, and show how standard numerical solvers can be
used to ﬁnd stationary points.
• We demonstrate the eﬀectiveness of the resulting method in empirical evaluations against existing
state-of-the-arts. See Figure 1 for a quick illustration and Section 5 for details.
• We compare our ouput to the exact global minimizer (Cussens, 2012), and show that our method
attains scores that are comparable to the globally optimal score in practice, although our methods are
only guaranteed to ﬁnd stationary points.
Most interestingly, our approach is very simple and can be implemented in about 50 lines of Python code.
As a result of its simplicity and eﬀortlessness in its implementation, we call the resulting method NOTEARS:
Non-combinatorial Optimization via Trace Exponential and Augmented lagRangian for Structure learning.
The implementation is publicly available at https://github.com/xunzheng/notears.
2
Background
The basic DAG learning problem is formulated as follows: Let X ∈Rn×d be a data matrix consisting of n
i.i.d. observations of the random vector X = (X1, . . . , Xd) and let D denote the (discrete) space of DAGs
G = (V, E) on d nodes. Given X, we seek to learn a DAG G ∈D (also called a Bayesian network) for the joint
distribution P(X) (Spirtes et al., 2000; Koller and Friedman, 2009). We model X via a structural equation
model (SEM) deﬁned by a weighted adjacency matrix W ∈Rd×d. Thus, instead of operating on the discrete
space D, we will operate on Rd×d, the continuous space of d × d real matrices.
2.1
Score functions and SEM
Any W ∈Rd×d deﬁnes a graph on d nodes in the following way: Let A(W) ∈{0, 1}d×d be the binary
matrix such that [A(W)]ij = 1 ⇐⇒wij ̸= 0 and zero otherwise; then A(W) deﬁnes the adjacency matrix
of a directed graph G(W). In a slight abuse of notation, we will thus treat W as if it were a (weighted)
graph. In addition to the graph G(W), W = [ w1 | · · · | wd ] deﬁnes a linear SEM by Xj = wT
j X + zj, where
2

X = (X1, . . . , Xd) is a random vector and z = (z1, . . . , zd) is a random noise vector. We do not assume that z is
Gaussian. More generally, we can model Xj via a generalized linear model (GLM) E(Xj | Xpa(Xj)) = f(wT
j X).
For example, if Xj ∈{0, 1}, we can model the conditional distribution of Xj given its parents via logistic
regression.
In this paper, we focus on linear SEM and the least-squares (LS) loss ℓ(W; X) =
1
2n∥X−XW∥2
F , although
everything in the sequel applies to any smooth loss function ℓdeﬁned over Rd×d. The statistical properties of
the LS loss in scoring DAGs have been extensively studied: The minimizer of the LS loss provably recovers a
true DAG with high probability on ﬁnite-samples and in high-dimensions (d ≫n), and hence is consistent for
both Gaussian SEM (van de Geer and B¨uhlmann, 2013; Aragam et al., 2016) and non-Gaussian SEM (Loh
and B¨uhlmann, 2014).2 Note also that these results imply that the faithfulness assumption is not required in
this set-up. Given this extensive previous work on statistical issues, our focus in this paper is entirely on the
computational problem of ﬁnding an SEM that minimizes the LS loss.
This translation between graphs and SEM is central to our approach. Since we are interested in learning
a sparse DAG, we add ℓ1-regularization ∥W∥1 = ∥vec(W)∥1 resulting in the regularized score function
F(W) = ℓ(W; X) + λ∥W∥1 = 1
2n∥X −XW∥2
F + λ∥W∥1.
(2)
Thus we seek to solve
min
W ∈Rd×d
F(W)
subject to
G(W) ∈D.
(3)
Unfortunately, although F(W) is continuous, the DAG constraint G(W) ∈D remains a challenge to enforce.
In Section 3, we show how this discrete constraint can be replaced by a smooth equality constraint.
2.2
Previous work
Traditionally, score-based learning seeks to optimize a discrete score Q : D →R over the set of DAGs D; note
that this is distinct from our score F(W) whose domain is Rd×d instead of D. This can be written as the
following combinatorial optimization problem:
min
G
Q(G)
subject to
G ∈D
(4)
Popular score functions include BDe(u) (Heckerman et al., 1995), BGe (Kuipers et al., 2014), BIC (Chickering
and Heckerman, 1997), and MDL (Bouckaert, 1993). Unfortunately, (4) is NP-hard to solve Chickering
(1996); Chickering et al. (2004) owing mainly to the nonconvex, combinatorial nature of the optimization
problem. This is the main drawback of existing approaches for solving (4): The acyclicity constraint is a
combinatorial constraint with the number of acyclic structures increasing superexponentially in d (Robinson,
1977). Notwithstanding, there are algorithms for solving (4) to global optimality for small problems (Ott
and Miyano, 2003; Singh and Moore, 2005; Silander and Myllymaki, 2006; Xiang and Kim, 2013; Cussens,
2012; Cussens et al., 2017). There is also a wide literature on approximate algorithms based on order search
(Teyssier and Koller, 2005; Schmidt et al., 2007; Scanagatta et al., 2015, 2016), greedy search (Heckerman
et al., 1995; Chickering, 2003; Ramsey et al., 2016), and coordinate descent (Fu and Zhou, 2013; Aragam and
Zhou, 2015; Gu et al., 2018). By searching over the space of topological orderings, the former order-based
methods trade-oﬀthe diﬃcult problem of enforcing acyclicity with a search over d! orderings, whereas the
latter methods enforce acyclicity one edge at a time, explicitly checking for acyclicity violations each time an
edge is added. Other approaches that avoid optimizing (4) directly include constraint-based methods (Spirtes
and Glymour, 1991; Spirtes et al., 2000), hybrid methods (Tsamardinos et al., 2006; G´amez et al., 2011), and
Bayesian methods (Ellis and Wong, 2008; Zhou, 2011; Niinim¨aki et al., 2016).
2Due to nonconvexity, there may be more than one minimizer: These and other technical issues such as parameter identiﬁability
are addressed in detail in the cited references.
3

The intractable form of the program (4) has led to a host of heuristic methods, often borrowing tools
from the optimization literature, but always resorting to clever heuristics to accelerate algorithms. Here we
brieﬂy discuss some of the pros and cons of existing methods. While not all methods suﬀer from all of the
problems highlighted below, we are not aware of any methods that simultaneously avoid all of them.
Exact vs. approximate.
Broadly speaking, there are two camps: Approximate algorithms and exact
algorithms, the latter of which are guaranteed to return a globally optimal solution. Exact algorithms form
an intriguing class of methods, but as they are based around an NP-hard combinatorial optimization problem,
these methods remain computationally intractable in general. For example, recent state-of-the-art work
(Cussens et al., 2017; Chen et al., 2016) only scale to problems with a few dozen nodes (Van Beek and
Hoﬀmann, 2015).3 Older methods based on dynamic programming methods (Ott and Miyano, 2003; Singh
and Moore, 2005; Silander and Myllymaki, 2006; Xiang and Kim, 2013; Loh and B¨uhlmann, 2014) also scale
to roughly a few dozen nodes. By contrast, state-of-the-art approximate methods can scale to thousands of
nodes (Ramsey et al., 2016; Aragam and Zhou, 2015; Scanagatta et al., 2015, 2016).
Local vs. global search.
Arguably the most popular approaches to optimizing (4) involve local search,
wherein edges and parent sets are added sequentially, one node at a time. This is eﬃcient as long as each
node has only a few parents, but as the number of possible parents grows, local search rapidly becomes
intractable. Furthermore, such strategies typically rely on severe structural assumptions such as bounded
in-degree, bounded treewidth, or edge constraints. Since real-world networks often exhibit scale-free and
small-world topologies (Watts and Strogatz, 1998; Barab´asi and Albert, 1999) with highly connected hub
nodes, these kinds of structural assumptions are not only diﬃcult to satisfy, but impossible to check. We
note here promising work towards relaxing this assumption for discrete data (Scanagatta et al., 2015). By
contrast, our method uses global search wherein the entire matrix W is updated in each step.
Model assumptions.
The literature on DAG learning tends to be split between methods that operate
on discrete data vs. methods that operate on continuous data. When viewed from the lens of (3), the
reasons for this are not clear since both discrete and continuous data can be considered as special cases of the
general score-based learning framework. Nonetheless, many (but not all) of the methods cited already only
work under very speciﬁc assumptions on the data, the most common of which are categorical (discrete) and
Gaussian (continuous). Since (3) is agnostic to the form of the data and loss function, there is signiﬁcant
interest in ﬁnding general methods that are not tied to speciﬁc model assumptions.
Conceptual clarity.
Finally, on a higher level, a signiﬁcant drawback of existing methods is their conceptual
complexity: They are not straightforward to implement, require deep knowledge of concepts from the graphical
modeling literature, and accelerating them involves many clever tricks. By contrast, the method we propose in
this paper is conceptually very simple, requires no background on graphical models, and can be implemented
in just a few lines of code using existing black-box solvers.
2.3
Comparison
It is instructive to compare existing methods for learning DAGs against other methods in the machine learning
literature. We focus here on two popular models: Undirected graphical models and deep neural networks.
Undirected graphical models, also known as Markov networks, is recognized as a convex problem (Yuan and
Lin, 2007; Banerjee et al., 2008) nowadays, and hence can be solved using black-box convex optimizers such as
CVX (Grant and Boyd, 2014). However, one should not forget score-based methods based on discrete scores
similar to (4) proliferated in the early days for learning undirected graphs (e.g. Koller and Friedman, 2009,
§20.7). More recently, extremely eﬃcient algorithms have been developed for this problem using coordinate
descent (Friedman et al., 2008) and Newton methods (Hsieh et al., 2014; Schmidt et al., 2009). As another
3Cussens (2012) reports experiments with d > 60 under a constraint on the maximum parent size.
4

example, deep neural networks are often learned using various descendants of stochastic gradient descent
(SGD) (Bousquet and Bottou, 2008; Kingma and Ba, 2014; Bottou et al., 2016), although recent work has
proposed other techniques such as ADMM (Taylor et al., 2016) and Gauss-Newton (Botev et al., 2017). One
of the keys to the success of both of these models—and many other models in machine learning—was having
a closed-form, tractable program for which existing techniques from the extensive optimization literature
could be applied. In both cases, the application of principled optimization techniques led to signiﬁcant
breakthroughs. For undirected graphical models the major technical tool was convex optimization, and for
deep networks the major technical tool was SGD.
Unfortunately, the general problem of DAG learning has not beneﬁted in this way, and one of our
main goals in the current work is to formulate score-based learning similarly as a closed-form, continuous
program. Arguably, the challenges with existing approaches stem from the intractable form of the program
(4). One of our main goals in the current work is to formulate score-based learning via a similar closed-form,
continuous program. The key device in accomplishing this is a smooth characterization of acyclicity that will
be introduced in the next section.
3
A new characterization of acyclicity
In order to make (3) amenable to black-box optimization, we propose to replace the combinatorial acyclicity
constraint G(W) ∈D in (3) with a single smooth equality constraint h(W) = 0. Ideally, we would like a
function h : Rd×d →R that satisﬁes the following desiderata:
(a) h(W) = 0 if and only if W is acyclic (i.e. G(W) ∈D);
(b) The values of h quantify the “DAG-ness” of the graph;
(c) h is smooth;
(d) h and its derivatives are easy to compute.
Property (b) is useful in practice for diagnostics. By “DAG-ness”, we mean some quantiﬁcation of how
severe violations from acyclicity become as W moves further from D. Although there are many ways to
satisfy (b) by measuring some notion of “distance” to D, typical approaches would violate (c) and (d). For
example, h might be the minimum ℓ2 distance to D or it might be the sum of edge weights along all cyclic
paths of W, however, these are either non-smooth (violating (c)) or hard to compute (violating (d)). If a
function that satisﬁes desiderata (a)-(d) exists, we can hope to apply existing machinery for constrained
optimization such as Lagrange multipliers. Consequently, the DAG learning problem becomes equivalent to
solving a numerical optimization problem, which is agnostic about the graph structure.
We proceed in two steps: First, we consider the simpler case of binary adjacency matrices B ∈{0, 1}d×d
(Section 3.1). Note that since {0, 1}d×d is a discrete space, we cannot take gradients or do continuous
optimization. For this we need the second step, in which we relax the function we originally deﬁne on binary
matrices to real matrices (Section 3.2).
3.1
Special case: Binary adjacency matrices
When does a matrix B ∈{0, 1}d×d correspond to an acyclic graph? Recall the spectral radius r(B) of a
matrix B is the largest absolute eigenvalue of B. One simple characterization of acyclicity is the following:
Proposition 1 (Inﬁnite series). Suppose B ∈{0, 1}d×d and r(B) < 1. Then B is a DAG if and only if
tr(I −B)−1 = d.
(5)
Proof. It essentially boils down to the fact that tr Bk counts the number of length-k closed walks in a directed
graph. Clearly an acyclic graph will have tr Bk = 0 for all k = 1, . . . , ∞. In other words, B has no cycles if
5

and only if f(B) = P∞
k=1
Pd
i=1(Bk)ii = 0, then
tr(I −B)−1 = tr
∞
X
k=0
Bk = tr I +
∞
X
k=1
tr Bk = d +
∞
X
k=1
d
X
i=1
(Bk)ii = d + f(B).
The desired result follows.
Unfortunately, the condition that r(B) < 1 is strong: although it is automatically satisﬁed when B is a
DAG, it is generally not true otherwise, and furthermore the projection is nontrivial. Alternatively, instead
of the inﬁnite series, one could consider the characterization based on ﬁnite series Pd
k=1 tr Bk = 0, which
does not require r(B) < 1. However, this is impractical for numerical reasons: The entries of Bk can easily
exceed machine precision for even small values of d, which makes both function and gradient evaluations
highly unstable. Therefore it remains to ﬁnd a characterization that not only holds for all possible B, but
also has numerical stability. Luckily, such function exists.
Proposition 2 (Matrix exponential). A binary matrix B ∈{0, 1}d×d is a DAG if and only if
tr eB = d.
(6)
Proof. Similar to Proposition 1 by noting that B has no cycles if and only if (Bk)ii = 0 for all k ≥1 and all
i, which is true if and only if P∞
k=1
Pd
i=1(Bk)ii/k! = tr eB −d = 0.
It is worth pointing out that matrix exponential is well-deﬁned for all square matrices. In addition to
everywhere convergence, this characterization has an added bonus: As the number of edges in B increases along
with the number of nodes d, the number of possible closed walks grows rapidly, so the trace characterization
tr(I −B)−1 rapidly becomes ill-conditioned and diﬃcult to manage. By re-weighting the number of length-k
closed walks by k!, this becomes much easier to manage. While this is a useful characterization, it does not
satisfy all of our desiderata since—being deﬁned over a discrete space—it is not a smooth function. The ﬁnal
step is to extend Proposition 2 to all of Rd×d.
3.2
The general case: Weighted adjacency matrices
Unfortunately, the characterization (6) fails if we replace B with an arbitrary weighted matrix W. However,
we can replace B with any nonnegative weighted matrix, and the same argument use to prove Proposition 2
shows that (6) will still characterize acyclicity. Thus, to extend this to matrices with both positive and
negative values, we can simply use the Hadamard product W ◦W, which leads to our main result.
Theorem 1. A matrix W ∈Rd×d is a DAG if and only if
h(W) = tr
 eW ◦W 
−d = 0,
(7)
where ◦is the Hadamard product and eA is the matrix exponential of A. Moreover, h(W) has a simple
gradient
∇h(W) =
 eW ◦W T ◦2W,
(8)
and satisﬁes all of the desiderata (a)-(d).
The proof of (7) is similar to (6), and desiderata (c)-(d) follow from (8). To see why desiderata (b) holds,
note that the proof of Proposition 1 shows that the power series tr(B + B2 + · · · ) simply counts the number
of closed walks in B, and the matrix exponential simply re-weights these counts. Replacing B with W ◦W
amounts to counting weighted closed walks, where the weight of each edge is w2
ij. Thus, larger h(W) > h(W ′)
means either (a) W has more cycles than W ′ or (b) The cycles in W are more heavily weighted than in W ′.
6

Algorithm 1 NOTEARS algorithm
1. Input: Initial guess (W0, α0), progress rate c ∈(0, 1), tolerance ϵ > 0, threshold ω > 0.
2. For t = 0, 1, 2, . . . :
(a) Solve primal Wt+1 ←arg minW Lρ(W, αt) with ρ such that h(Wt+1) < ch(Wt).
(b) Dual ascent αt+1 ←αt + ρh(Wt+1).
(c) If h(Wt+1) < ϵ, set f
WECP = Wt+1 and break.
3. Return the thresholded matrix c
W := f
WECP ◦1(|f
WECP| > ω).
Moreover, notice that h(W) ≥0 for all W since each term in the series is nonnegative. This gives another
interesting perspective of the space of DAGs as the set of global minima of h(W). However, due to the
nonconvexity, this is not equivalent to the ﬁrst order stationary condition ∇h(W) = 0.
A key conclusion from Theorem 1 is that h and its gradient only involve evaluating the matrix exponential,
which is a well-studied function in numerical analysis, and whose O(d3) algorithm (Al-Mohy and Higham,
2009) is readily available in many scientiﬁc computing libraries.
Although the connection between trace of
matrix power and number of cycles in the graph is well-known Harary and Manvel (1971), to the best of our
knowledge, this characterization of acyclicity has not appeared in the DAG learning literature previously.
We defer the discussion of other possible characterizations in the appendix. In the next section, we apply
Theorem 1 to solve the program (3) to stationarity by treating it as an equality constrained program.
4
Optimization
Theorem 1 establishes a smooth, algebraic characterization of acyclicity that is also computable. As a
consequence, the following equality-constrained program (ECP) is equivalent to (3):
(ECP)
min
W ∈Rd×d
F(W)
subject to
h(W) = 0.
(9)
The main advantage of (ECP) compared to both (3) and (4) is its amenability to classical techniques from
the mathematical optimization literature. Nonetheless, since {W : h(W) = 0} is a nonconvex constraint, (9)
is a nonconvex program, hence we still inherit the diﬃculties associated with nonconvex optimization. In
particular, we will be content to ﬁnd stationary points of (9); in Section 5.3 we compare our results to the
global minimizer and show that the stationary points found by our method are close to global minima in
practice.
In the follows, we outline the algorithm for solving (9).
It consists of three steps: (i) converting
the constrained problem into a sequence of unconstrained subproblems, (ii) optimizing the unconstrained
subproblems, and (iii) thresholding. The full algorithm is outlined in Algorithm 1.
4.1
Solving the ECP with augmented Lagrangian
We will use the augmented Lagrangian method (e.g. Nemirovski, 1999) to solve (ECP), which solves the
original problem augmented by a quadratic penalty:
min
W ∈Rd×d
F(W) + ρ
2|h(W)|2
subject to
h(W) = 0
(10)
7

with a penalty parameter ρ > 0. A nice property of the augmented Lagrangian method is that it approximates
well the solution of a constrained problem by the solution of unconstrained problems without increasing the
penalty parameter ρ to inﬁnity (Nemirovski, 1999). The algorithm is essentially a dual ascent method for
(10). To begin with, the dual function with Lagrange multiplier α is given by
D(α) =
min
W ∈Rd×d Lρ(W, α),
(11)
where
Lρ(W, α) = F(W) + ρ
2|h(W)|2 + αh(W)
(12)
is the augmented Lagrangian. The goal is to ﬁnd a local solution to the dual problem
max
α∈R
D(α).
(13)
Let W ⋆
α be the local minimizer of the Lagrangian (11) at α, i.e. D(α) = Lρ(W ⋆
α, α). Since the dual objective
D(α) is linear in α, the derivative is simply given by ∇D(α) = h(W ⋆
α). Therefore one can perform dual
gradient ascent to optimize (13):
α ←α + ρh(W ⋆
α),
(14)
where the choice of step size ρ comes with the following convergence rate:
Proposition 3 (Corollary 11.2.1, Nemirovski, 1999). For ρ large enough and the starting point α0 near the
solution α⋆, the update (14) converges to α⋆linearly.
In our experiments, typically fewer than 10 steps of the augmented Lagrangian scheme are required.
4.2
Solving the unconstrained subproblem
The augmented Lagrangian converts a constrained problem (10) into a sequence of unconstrained problems (11).
We now discuss how to solve these subproblems eﬃciently. Let w = vec(W) ∈Rp, with p = d2. The
unconstrained subproblem (11) can be considered as a typical minimization problem over real vectors:
min
w∈Rp f(w) + λ∥w∥1,
(15)
where
f(w) = ℓ(W; X) + ρ
2|h(W)|2 + αh(W)
(16)
is the smooth part of the objective. Our goal is to solve the above problem to high accuracy so that h(W)
can be suﬃciently suppressed.
In the special case of λ = 0, the nonsmooth term vanishes and the problem simply becomes an unconstrained
smooth minimization, for which a number of eﬃcient numerical algorithms are available, for instance the
L-BFGS (Byrd et al., 1995). To handle the nonconvexity, a slight modiﬁcation (Nocedal and Wright, 2006,
Procedure 18.2) needs to be applied.
When λ > 0, the problem becomes composite minimization, which can also be eﬃciently solved by the
proximal quasi-Newton (PQN) method (Zhong et al., 2014). At each step k, the key idea is to ﬁnd the
descent direction through a quadratic approximation of the smooth term:
dk = arg min
d∈Rp
gT
k d + 1
2dT Bkd + λ∥wk + d∥1,
(17)
where gk is the gradient of f(w) and Bk is the L-BFGS approximation of the Hessian. Note that for each
coordinate j, problem (17) has a closed form update d ←d + z⋆ej given by
z⋆= arg min
z
1
2 Bjj
|{z}
a
z2 + (gj + (Bd)j
|
{z
}
b
)z + λ| wj + dj
|
{z
}
c
+z| = −c + S

c −b
a, λ
a

.
(18)
8

Moreover, the low-rank structure of Bk enables fast computation for coordinate update. As we describe in
Appendix A, the precomputation time is only O(m2p + m3) where m ≪p is the memory size of L-BFGS, and
each coordinate update is O(m). Furthermore, since we are using sparsity regularization, we can further speed
up the algorithm by aggressively shrinking the active set of coordinates based on their subgradients (Zhong
et al., 2014), and exclude the remaining dimensions from being updated. With the updates restricted to
the active set S, all dependencies of the complexity on O(p) becomes O(|S|), which is substantially smaller.
Hence the overall complexity of L-BFGS update is O(m2|S| + m3 + m|S|T), where T is the number of inner
iterations, typically T = 10.
4.3
Thresholding
In regression problems, it is known that post-processing estimates of coeﬃcients via hard thresholding provably
reduces the number of false discoveries (Zhou, 2009; Wang et al., 2016). Motivated by these encouraging
results, we threshold the edge weights as follows: After obtaining a stationary point f
WECP of (10), given
a ﬁxed threshold ω > 0, set any weights smaller than ω in absolute value to zero. This strategy also has
the important eﬀect of “rounding” the numerical solution of the augmented Lagrangian (10), since due to
numerical precisions the solution satisﬁes h(f
WECP) ≤ϵ for some small tolerance ϵ near machine precision (e.g.
ϵ = 10−8), rather than h(f
WECP) = 0 strictly. However, since h(f
WECP) explicitly quantiﬁes the “DAG-ness” of
f
WECP (see desiderata (b), Section 3), a small threshold ω suﬃces to rule out cycle-inducing edges.
5
Experiments
We compared our method against greedy equivalent search (GES) (Chickering, 2003; Ramsey et al., 2016),
the PC algorithm (Spirtes et al., 2000), and LiNGAM (Shimizu et al., 2006). For GES, we used the fast
greedy search (FGS) implementation from Ramsey et al. (2016). Since the accuracy of PC and LiNGAM
was signiﬁcantly lower than either FGS or NOTEARS, we only report the results against FGS here. This is
consistent with previous work on score-based learning (Aragam and Zhou, 2015), which also indicates that
FGS outperforms other techniques such as hill-climbing and MMHC (Tsamardinos et al., 2006). FGS was
chosen since it is a state-of-the-art algorithm that scales to large problems.
For brevity, we outline the basic set-up of our experiments here; precise details of our experimental
set-up, including all parameter choices and more detailed evaluations, can be found in Appendix D. In each
experiment, a random graph G was generated from one of two random graph models, Erd¨os-R´enyi (ER) or
scale-free (SF). Given G, we assigned uniformly random edge weights to obtain a weight matrix W. Given W,
we sampled X = W T X + z ∈Rd from three diﬀerent noise models: Gaussian (Gauss), Exponential (Exp),
and Gumbel (Gumbel). Based on these models, we generated random datasets X ∈Rn×d by generating rows
i.i.d. according to one of these three models with d ∈{10, 20, 50, 100} and n ∈{20, 1000}. Since FGS outputs
a CPDAG instead of a DAG or weight matrix, some care needs to be taken in making comparisons; see
Appendix D.1 for details.
5.1
Parameter estimation
We ﬁrst performed a qualitative study of the solutions obtained by NOTEARS without thresholding by
visualizing the weight matrix f
WECP obtained by solving (ECP) (i.e. ω = 0). This is illustrated in Figures 1
(ER-2) and 2 (SF-4). The key takeaway is that our method provides (empirically) consistent parameter
estimates of the true weight matrix W. The ﬁnal thresholding step in Algorithm 1 is only needed to ensure
accuracy in structure learning. It also shows how eﬀective is ℓ1-regularization in small n regime.
5.2
Structure learning
We now examine our method for structure recovery, which is shown in Figure 3. For brevity, we only report
the numbers for the structural Hamming distance (SHD) here, but complete ﬁgures and tables for additional
9

0
5
10
15
0
5
10
15
W
(a) true graph
0
5
10
15
0
5
10
15
f
WECP(0)
0
5
10
15
f
WECP(0.1)
0
5
10
15
BFGS
-2
0
+2
(b) estimate with n = 1000
0
5
10
15
0
5
10
15
f
WECP(0)
0
5
10
15
f
WECP(0.1)
0
5
10
15
BFGS
-2
0
+2
(c) estimate with n = 20
Figure 2: Parameter estimates of f
WECP on a scale-free graph. Without the additional thresholding step
in Algorithm 1, NOTEARS still produces consistent estimates of the true graph. The proposed method
estimates the weights very well with large samples even without regularization, and remains accurate on
insuﬃcient samples when ℓ1-regularization is introduced. See also Figure 1.
Table 1: Comparison of NOTEARS vs. globally optimal solution. ∆(WG, c
W) = F(WG) −F(c
W).
n
λ Graph F(W) F(WG) F(c
W) F(f
WECP) ∆(WG, c
W) ∥c
W −WG∥∥W −WG∥
20
0
ER2
5.11
3.85
5.36
3.88
-1.52
0.07
3.38
20 0.5
ER2
16.04
12.81
13.49
12.90
-0.68
0.12
3.15
1000
0
ER2
4.99
4.97
5.02
4.95
-0.05
0.02
0.40
1000 0.5
ER2
15.93
13.32
14.03
13.46
-0.71
0.12
2.95
20
0
SF4
4.99
3.77
4.70
3.85
-0.93
0.08
3.31
20 0.5
SF4
23.33
16.19
17.31
16.69
-1.12
0.15
5.08
1000
0
SF4
4.96
4.94
5.05
4.99
-0.11
0.04
0.29
1000 0.5
SF4
23.29
17.56
19.70
18.43
-2.13
0.13
4.34
metrics can be found in the supplement. Consistent with previous work on greedy methods, FGS is very
competitive when the number of edges is small (ER-2), but rapidly deterioriates for even modest numbers of
edges (SF-4). In the latter regime, NOTEARS shows signiﬁcant improvements. This is consistent across each
metric we evaluated, and the diﬀerence grows as the number of nodes d gets larger. Also notice that our
algorithm performs uniformly better for each noise model (Exp, Gauss, and Gumbel), without leveraging any
speciﬁc knowledge about the noise type. Again, ℓ1-regularizer helps signiﬁcantly in the small n setting.
5.3
Comparison to exact global minimizer
In order to assess the ability of our method to solve the original program given by (3), we used the GOBNILP
program (Cussens, 2012; Cussens et al., 2017) to ﬁnd the exact minimizer of (3).
Since this involves
enumerating all possible parent sets for each node, these experiments are limited to small DAGs. Nonetheless,
these small-scale experiments yield valuable insight into how well NOTEARS performs in actually solving
the original problem. In our experiments we generated random graphs with d = 10, and then generated 10
simulated datasets containing n = 20 samples (for high-dimensions) and n = 1000 (for low-dimensions). We
then compared the scores returned by our method to the exact global minimizer computed by GOBNILP
along with the estimated parameters. The results are shown in Table 1. Surprisingly, although NOTEARS is
only guaranteed to return a local minimizer, in many cases the obtained solution is very close to the global
minimizer, as evidenced by deviations ∥c
W −WG∥. Since the general structure learning problem is NP-hard,
we suspect that although the models we have tested (i.e. ER and SF) appear amenable to fast solution, in
the worst-case there are graphs which will still take exponential time to run or get stuck in a local minimum.
Furthermore, the problem becomes more diﬃcult as d increases. Nonetheless, this is encouraging evidence
that the nonconvexity of (9) is a minor issue in practice. We leave it to future work to investigate these
problems further.
10

GG
G
G
G
G
G
G
G
G
G
G
GG
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
exp
gauss
gumbel
ER2
SF4
25
50
75 100
25
50
75 100
25
50
75 100
0
25
50
75
0
100
200
300
d (Number of nodes)
Structural Hamming distance (SHD)
G
G
G
G
GG
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
exp
gauss
gumbel
ER2
SF4
25
50
75 100
25
50
75 100
25
50
75 100
0.0
0.2
0.4
0.6
0.0
0.2
0.4
d (Number of nodes)
False discovery rate (FDR)
Method
G
G
G
FGS
NOTEARS
NOTEARS−L1
(a) SHD with n = 1000
GG
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
exp
gauss
gumbel
ER2
SF4
25
50
75 100
25
50
75 100
25
50
75 100
0
100
200
300
400
0
100
200
300
400
500
d (Number of nodes)
Structural Hamming distance (SHD)
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
exp
gauss
gumbel
ER2
SF4
25
50
75 100
25
50
75 100
25
50
75 100
0.3
0.5
0.7
0.9
0.2
0.4
0.6
d (Number of nodes)
False discovery rate (FDR)
Method
G
G
G
FGS
NOTEARS
NOTEARS−L1
(b) SHD with n = 20
Figure 3: Structure recovery in terms of SHD and FDR to the true graph (lower is better). Rows: random
graph types, {ER,SF}-k = {Erd¨os-R´enyi, scale-free} graphs with kd expected edges. Columns: noise types of
SEM. Error bars represent standard errors over 10 simulations.
5.4
Real-data
We also compared FGS and NOTEARS on a real dataset provided by Sachs et al. (2005). This dataset
consists of continuous measurements of expression levels of proteins and phospholipids in human immune
system cells (n = 7466 d = 11, 20 edges). This dataset is a common benchmark in graphical models since it
comes with a known consensus network, that is, a gold standard network based on experimental annotations
that is widely accepted by the biological community. In our experiments, FGS estimated 17 total edges with
an SHD of 22, compared to 16 for NOTEARS with an SHD of 22.
6
Discussion
We have proposed a new method for learning DAGs from data based on a continuous optimization program.
This represents a signiﬁcant departure from existing approaches that search over the discrete space of
DAGs, resulting in a diﬃcult optimization program. We also proposed two optimization schemes for solving
the resulting program to stationarity, and illustrated its advantages over existing methods such as greedy
equivalence search. Crucially, by performing global updates (e.g. all parameters at once) instead of local
updates (e.g. one edge at a time) in each iteration, our method is able to avoid relying on assumptions
about the local structure of the graph. To conclude, let us discuss some of the limitations of our method and
possible directions for future work.
11

First, it is worth emphasizing once more that the equality constrained program (9) is a nonconvex program.
Thus, although we overcome the diﬃculties of combinatorial optimization, our formulation still inherits the
diﬃculties associated with nonconvex optimization. In particular, black-box solvers can at best ﬁnd stationary
points of (9). With the exception of exact methods, however, existing methods suﬀer from this drawback as
well.4 The main advantage of NOTEARS then is smooth, global search, as opposed to combinatorial, local
search; and furthermore the search is delegated to standard numerical solvers.
Second, the current work relies on the smoothness of the score function, in order to make use of gradient-
based numerical solvers to guide the graph search. However it is also interesting to consider non-smooth,
even discrete scores such as BDe (Heckerman et al., 1995). Oﬀ-the-shelf techniques such as Nesterov’s
smoothing (Nesterov, 2005) could be useful, however more thorough investigation is left for future work.
Third, since the evaluation of the matrix exponential is O(d3), the computational complexity of our
method is cubic in the number of nodes, although the constant is small for sparse matrices. In fact, this is
one of the key motivations for our use of second-order methods (as opposed to ﬁrst-order), i.e. to reduce the
number of matrix exponential computations. By using second-order methods, each iteration make signiﬁcantly
more progress than ﬁrst-order methods. Furthermore, although in practice not many iterations (t ∼10)
are required, we have not established any worst-case iteration complexity results. In light of the results in
Section 5.3, we expect there are exceptional cases where convergence is slow. Notwithstanding, NOTEARS
already outperforms existing methods when the in-degree is large, which is known diﬃcult spot for existing
methods. We leave it to future work to study these cases in more depth.
Lastly, in our experiments, we chose a ﬁxed, suboptimal value of ω > 0 for thresholding (Section 4.3).
Clearly, it would be preferable to ﬁnd a data-driven choice of ω that adapts to diﬀerent noise-to-signal ratios
and graph types. It is an intersting direction for future to study such choices.
The code is publicly available at https://github.com/xunzheng/notears.
References
A. H. Al-Mohy and N. J. Higham. A New Scaling and Squaring Algorithm for the Matrix Exponential. SIAM
Journal on Matrix Analysis and Applications, 2009.
B. Aragam and Q. Zhou. Concave penalized estimation of sparse Gaussian Bayesian networks. Journal of
Machine Learning Research, 16:2273–2328, 2015.
B. Aragam, A. A. Amini, and Q. Zhou. Learning directed acyclic graphs with penalized neighbourhood
regression. Submitted, arXiv:1511.08963, 2016.
O. Banerjee, L. El Ghaoui, and A. d’Aspremont. Model selection through sparse maximum likelihood
estimation for multivariate Gaussian or binary data. Journal of Machine Learning Research, 9:485–516,
2008.
A.-L. Barab´asi and R. Albert. Emergence of scaling in random networks. Science, 286(5439):509–512, 1999.
A. Botev, H. Ritter, and D. Barber. Practical gauss-newton optimisation for deep learning. arXiv preprint
arXiv:1706.03662, 2017.
L. Bottou, F. E. Curtis, and J. Nocedal. Optimization methods for large-scale machine learning. arXiv
preprint arXiv:1606.04838, 2016.
R. R. Bouckaert. Probabilistic network construction using the minimum description length principle. In
European conference on symbolic and quantitative approaches to reasoning and uncertainty, pages 41–48.
Springer, 1993.
O. Bousquet and L. Bottou. The tradeoﬀs of large scale learning. In Advances in neural information processing
systems, pages 161–168, 2008.
4GES (Chickering, 2003) is known to ﬁnd the global minimizer in the limit n →∞under certain assumptions, but this is not
guaranteed for ﬁnite samples.
12

R. H. Byrd, P. Lu, J. Nocedal, and C. Zhu. A limited memory algorithm for bound constrained optimization.
SIAM Journal on Scientiﬁc Computing, 1995.
E. Y.-J. Chen, Y. Shen, A. Choi, and A. Darwiche. Learning bayesian networks with ancestral constraints.
In Advances in Neural Information Processing Systems, pages 2325–2333, 2016.
D. M. Chickering. Learning Bayesian networks is NP-complete. In Learning from data, pages 121–130.
Springer, 1996.
D. M. Chickering. Optimal structure identiﬁcation with greedy search. Journal of Machine Learning Research,
3:507–554, 2003.
D. M. Chickering and D. Heckerman. Eﬃcient approximations for the marginal likelihood of Bayesian
networks with hidden variables. Machine Learning, 29(2-3):181–212, 1997.
D. M. Chickering, D. Heckerman, and C. Meek. Large-sample learning of Bayesian networks is NP-hard.
Journal of Machine Learning Research, 5:1287–1330, 2004.
J. Cussens. Bayesian network learning with cutting planes. arXiv preprint arXiv:1202.3713, 2012.
J. Cussens, D. Haws, and M. Studen`y. Polyhedral aspects of score equivalence in bayesian network structure
learning. Mathematical Programming, 164(1-2):285–324, 2017.
B. Ellis and W. H. Wong. Learning causal Bayesian network structures from experimental data. Journal of
the American Statistical Association, 103(482), 2008.
J. Friedman, T. Hastie, and R. Tibshirani. Sparse inverse covariance estimation with the Graphical Lasso.
Biostatistics, 9(3):432–441, 2008.
F. Fu and Q. Zhou. Learning sparse causal Gaussian networks with experimental intervention: Regularization
and coordinate descent. Journal of the American Statistical Association, 108(501):288–300, 2013.
J. A. G´amez, J. L. Mateo, and J. M. Puerta. Learning Bayesian networks by hill climbing: Eﬃcient methods
based on progressive restriction of the neighborhood. Data Mining and Knowledge Discovery, 22(1-2):
106–148, 2011.
M. Grant and S. Boyd. CVX: Matlab software for disciplined convex programming, version 2.1. http:
//cvxr.com/cvx, Mar. 2014.
J. Gu, F. Fu, and Q. Zhou. Penalized estimation of directed acyclic graphs from discrete data. Statistics and
Computing, DOI: 10.1007/s11222-018-9801-y, 2018.
F. Harary and B. Manvel. On the number of cycles in a graph. Matematick`y ˇcasopis, 1971.
D. Heckerman, D. Geiger, and D. M. Chickering. Learning Bayesian networks: The combination of knowledge
and statistical data. Machine learning, 20(3):197–243, 1995.
C.-J. Hsieh, M. A. Sustik, I. S. Dhillon, and P. Ravikumar. Quic: quadratic approximation for sparse inverse
covariance estimation. Journal of Machine Learning Research, 15(1):2911–2947, 2014.
D. P. Kingma and J. Ba. Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980,
2014.
D. Koller and N. Friedman. Probabilistic graphical models: principles and techniques. MIT press, 2009.
J. Kuipers, G. Moﬀa, and D. Heckerman. Addendum on the scoring of gaussian directed acyclic graphical
models. The Annals of Statistics, pages 1689–1691, 2014.
P.-L. Loh and P. B¨uhlmann. High-dimensional learning of linear causal networks via inverse covariance
estimation. Journal of Machine Learning Research, 15:3065–3105, 2014.
A. Nemirovski. Optimization II: Standard Numerical Methods for Nonlinear Continuous Optimization. 1999.
Y. Nesterov. Smooth minimization of non-smooth functions. Mathematical Programming, 2005.
13

T. Niinim¨aki, P. Parviainen, and M. Koivisto. Structure discovery in bayesian networks by sampling partial
orders. Journal of Machine Learning Research, 17(1):2002–2048, 2016.
J. Nocedal and S. J. Wright. Numerical Optimization. 2006.
S. Ott and S. Miyano. Finding optimal gene networks using biological constraints. Genome Informatics, 14:
124–133, 2003.
J. Ramsey, M. Glymour, R. Sanchez-Romero, and C. Glymour. A million variables and more: the fast greedy
equivalence search algorithm for learning high-dimensional graphical causal models, with an application to
functional magnetic resonance images. International Journal of Data Science and Analytics, pages 1–9,
2016.
R. W. Robinson. Counting unlabeled acyclic digraphs. In Combinatorial mathematics V, pages 28–43.
Springer, 1977.
K. Sachs, O. Perez, D. Pe’er, D. A. Lauﬀenburger, and G. P. Nolan. Causal protein-signaling networks
derived from multiparameter single-cell data. Science, 308(5721):523–529, 2005.
M. Scanagatta, C. P. de Campos, G. Corani, and M. Zaﬀalon. Learning bayesian networks with thousands of
variables. In Advances in Neural Information Processing Systems, pages 1864–1872, 2015.
M. Scanagatta, G. Corani, C. P. de Campos, and M. Zaﬀalon. Learning treewidth-bounded bayesian networks
with thousands of variables. In Advances in Neural Information Processing Systems, pages 1462–1470,
2016.
M. Schmidt, A. Niculescu-Mizil, and K. Murphy. Learning graphical model structure using L1-regularization
paths. In AAAI, volume 7, pages 1278–1283, 2007.
M. Schmidt, E. Berg, M. Friedlander, and K. Murphy. Optimizing costly functions with simple constraints: A
limited-memory projected quasi-newton algorithm. In Artiﬁcial Intelligence and Statistics, pages 456–463,
2009.
S. Shimizu, P. O. Hoyer, A. Hyv¨arinen, and A. Kerminen. A linear non-Gaussian acyclic model for causal
discovery. Journal of Machine Learning Research, 7:2003–2030, 2006.
T. Silander and P. Myllymaki. A simple approach for ﬁnding the globally optimal bayesian network structure.
In Proceedings of the 22nd Conference on Uncertainty in Artiﬁcial Intelligence, 2006.
A. P. Singh and A. W. Moore. Finding optimal bayesian networks by dynamic programming. 2005.
P. Spirtes and C. Glymour. An algorithm for fast recovery of sparse causal graphs. Social Science Computer
Review, 9(1):62–72, 1991.
P. Spirtes, C. Glymour, and R. Scheines. Causation, prediction, and search, volume 81. The MIT Press, 2000.
G. Taylor, R. Burmeister, Z. Xu, B. Singh, A. Patel, and T. Goldstein. Training neural networks without
gradients: A scalable admm approach. In International Conference on Machine Learning, pages 2722–2731,
2016.
M. Teyssier and D. Koller. Ordering-based search: A simple and eﬀective algorithm for learning bayesian
networks. In Uncertainty in Artiﬁcal Intelligence (UAI), 2005.
I. Tsamardinos, L. E. Brown, and C. F. Aliferis. The max-min hill-climbing Bayesian network structure
learning algorithm. Machine Learning, 65(1):31–78, 2006.
P. Van Beek and H.-F. Hoﬀmann. Machine learning of bayesian networks using constraint programming. In
International Conference on Principles and Practice of Constraint Programming, pages 429–445. Springer,
2015.
S. van de Geer and P. B¨uhlmann. ℓ0-penalized maximum likelihood for sparse directed acyclic graphs. Annals
of Statistics, 41(2):536–567, 2013.
14

X. Wang, D. Dunson, and C. Leng. No penalty no tears: Least squares in high-dimensional linear models. In
International Conference on Machine Learning, pages 1814–1822, 2016.
D. J. Watts and S. H. Strogatz. Collective dynamics of small-world networks. nature, 393(6684):440, 1998.
J. Xiang and S. Kim. A* Lasso for learning a sparse Bayesian network structure for continuous variables. In
Advances in Neural Information Processing Systems, pages 2418–2426, 2013.
M. Yuan and Y. Lin. Model selection and estimation in the Gaussian graphical model. Biometrika, 94(1):
19–35, 2007.
B. Zhang, C. Gaiteri, L.-G. Bodea, Z. Wang, J. McElwee, A. A. Podtelezhnikov, C. Zhang, T. Xie, L. Tran,
R. Dobrin, et al. Integrated systems approach identiﬁes genetic nodes and networks in late-onset alzheimer’s
disease. Cell, 153(3):707–720, 2013.
K. Zhong, I. E.-H. Yen, I. S. Dhillon, and P. K. Ravikumar. Proximal quasi-newton for computationally
intensive l1-regularized m-estimators. In Advances in Neural Information Processing Systems, pages
2375–2383, 2014.
Q. Zhou. Multi-domain sampling with applications to structural inference of Bayesian networks. Journal of
the American Statistical Association, 106(496):1317–1330, 2011.
S. Zhou. Thresholding procedures for high dimensional variable selection and statistical estimation. In
Advances in Neural Information Processing Systems, pages 2304–2312, 2009.
15

Algorithm 2 Proximal Quasi-Newton for unconstrained problem (Zhong et al., 2014)
1. Input: w0, g0 = ∇f(w0), active set S = [p].
2. For k = 0, 1, 2, . . . :
(a) Shrink S to rule out j with wj = 0 or small subgradient |∂jL(w)|
(b) If shrinking stopping criteria is satisﬁed
i. Reset S = [p] and L-BFGS memory
ii. Update shrinking stopping criteria and continue
(c) Solve (17) for descent direction dk using coordinate update (18) on active set
(d) Line search for step size η ∈(0, 1] until Armijo rule is satisﬁed:
f(wk + ηdk) ≤f(wk) + ηc1(λ∥wk + dk∥1 −λ∥wk∥+ gT
k dk),
(20)
where c1 is some small constant, typically set to 10−3 or 10−4.
(e) Generate new iterate wk+1 ←wk + ηdk
(f) Update g, s, y, Q, R, bQ restricted to S
A
Details of Proximal Quasi-Newton
Recall Bk ∈Rp×p is the low-rank approximation of the Hessian matrix given by L-BFGS updates. Let the
memory size of L-BFGS be m, which is taken to be m ≪p. The compact form of L-BFGS update can be
written as
Bk = γkI −Q bQ,
(19)
where
Q =
γkSk
Yk

, R =
γkST
k Sk
Lk
LT
k
−Dk
−1
, bQ = RQT ,
Sk =
sk−m
· · ·
sk−1

, Yk =
yk−m
· · ·
yk−1

,
sk = wk+1 −wk, yk = gk+1 −gk, γk = yT
k−1yk−1/sT
k−1yk−1,
Dk = diag
sT
k−myk−m
· · ·
sT
k−1yk−1

, (Lk)ij =
(
sT
k−m+i−1yk−m+j−1
if i > j
0
otherwise .
The low rank structure of Bk enables fast computation of subsequent coordinate descent procedure.
Speciﬁcally, notice that all Q, R, bQ, and diag(B) can be precomputed in O(m2p + m3) time, which is
signiﬁcantly smaller than naive Hessian inversion O(p3). After precomputation, in each coordinate update,
both a and c in (18) can be computed and updated in O(1) time. Moreover, let bd = bQd ∈R2m, we have
(Bd)j = γdj −Qj,:bd, which suggests b in (18) only requires O(m) to compute and update. Therefore each
coordinate update is O(m).
The detailed procedure of PQN is outlined in Algorithm 2.
B
Sensitivity of threshold
We demonstrate the eﬀect of threshold in Figure 4. For each setting, we computed the “ROC” curve for FDR
and TPR with varying level of threshold, while ensuring the resulting graph is indeed a DAG. On the right,
16

(a) ER2, n = 1000
(b) ER2, n = 20
(c) SF4, n = 1000
(d) SF4, n = 20
Figure 4: Illustration of the eﬀect of the threshold with d = 20 and λ = 0.1. For each subﬁgure, ROC curve
(left) shows FDR and TPR with varying level of threshold, and sorted weights (right) plots the entries of
f
WECP in decreasing order.
we also present the estimated edge weights of f
WECP in decreasing order. One can ﬁrst observe that in all cases
most of the edge weights are equal or close to zero as expected. The remaining question is how to choose a
threshold that separates out these (near zero) from signals (away from zero) so that best performance can
be achieved. With enough samples, one can often notice a sudden change in the weight distribution as in
Figure 4(a)(c). With insuﬃcient samples, the breakpoint is less clear, and the optimal choice that balances
between TPR and FDR is depends on the speciﬁc settings. Nonetheless, the predictive performance is less
sensitive to threshold value as one can see from the slope of the decrease in the weights before getting close
to zero. Indeed, in our experiments, we found a ﬁxed threshold ω = 0.3 is a suboptimal yet reasonable choice
across many diﬀerent settings.
C
Sensitivity of weight scale
We investigate the eﬀect of weight scaling to the NOTEARS algorithm in Figure 5. In particular, we run
experiments with wij ∈α · [0.5, 2] ∪−α · [0.5, 2] with α ∈{1.0, 0.9, 0.8, . . . , 0.1}. On the left, we plot the
smallest threshold ω required to obtain a DAG (see Section 4.3) for diﬀerent scale α. Overall, across diﬀerent
values of α, the variation in the smallest ω required is minimal. We also hasten to point out that this also
decreases the signal to noise ratio (SNR), which more directly aﬀects the accuracy. Indeed, in the ﬁgure on
the right, we can observe (as expected) some performance drop when using smaller value of α.
D
Experiments
D.1
Experiment details
We used simulated graphs from two well-known ensembles of random graphs:
17

Figure 5: Varying weight scale α ∈{1.0, . . . , 0.1} with d = 20 and n = 1000 on an ER-2 graph. (Left)
Smallest threshold ω such that c
W is a DAG. (Right) SHD between ground truth and NOTEARS, lower the
better. The minimum ω remains stable, while the accuracy of NOTEARS drops as expected since the SNR
decreases with α.
• Erd¨os-R´enyi (ER). Random graphs whose edges are added independently with equal probability p. We
simulated models with d, 2d, and 4d edges (in expectation) each, denoted by ER-1, ER-2, and ER-4,
respectively.
• Scale-free networks (SF). Networks simulated according to the preferential attachment process described
in Barab´asi and Albert (1999). We simulated scale-free networks with 4d edges and β = 1, where β is
the exponent used in the preferential attachment process.
Scale-free graphs are popular since they exhibit topological properties similar to real-world networks such
as gene networks, social networks, and the internet. Given a random acyclic graph B ∈{0, 1}d×d from one
of these two ensembles, we assigned edge weights independently from Unif
 [−2, −0.5] ∪[0.5, 2]) to obtain
a weight matrix W = [w1 | · · · | wd] ∈Rd×d. Given W, we sampled X = W T X + z ∈Rd according to the
following three noise models:
• Gaussian noise (Gauss). z ∼N(0, Id×d).
• Exponential noise (Exp). zj ∼Exp(1), j = 1, . . . , d.
• Gumbel noise (Gumbel). zj ∼Gumbel(0, 1), j = 1, . . . , d.
Based on these models, we generated random datasets X ∈Rn×d by generating the rows i.i.d. according to
one of the models above. For each simulation, we generated n samples for graphs with d ∈{10, 20, 50, 100}
nodes. To study both high- and low-dimensional settings, we used n ∈{20, 1000}.
For each dataset, we ran FGS, PC, and LinGAM and NOTEARS to compare the performance in
reconstructing the DAG B. We used the following implementations:
• FGS and PC were implemented through the py-causal package, available at https://github.com/
bd2kccd/py-causal. Both of these methods are written in highly optimized Java code.
• LinGAM was implemented using the author’s Python code:
https://sites.google.com/site/
sshimizu06/lingam.
Since the accuracy of PC and LiNGAM was signiﬁcantly lower than either FGS or NOTEARS, we only
report the results against FGS. A few comments on FGS are in order: 1) FGS estimates a graph, so it does
not output any parameter estimates; 2) Instead of returning a DAG, FGS returns a CPDAG (Chickering,
2003), which contains undirected edges; 3) FGS has a single tuning parameter that controls the strength of
regularization. Thus, in our evaluations, we treated FGS favourably by treating undirected edges as true
18

positives as long as the true graph had a directed edge in place of the undirected edge. For tuning parameters,
we used the values suggested by the authors of the FGS code.
Denote the estimate returned by FGS by BFGS. As discussed in Appendix B, we ﬁx the threshold
at ω = 0.3. Having ﬁxed ω, when there is no regularization, NOTEARS requires no tuning. With ℓ1-
regularization, NOTEARS-ℓ1 requires a choice of λ which wes selected as follows: Based on the estimate
returned by FGS, we tuned λ so that the selected graph (after thresholding) had the same number of edges
as BFGS (or as close as possible). This ensures that the results are not inﬂuenced by hyperparameter tuning,
and fairly compares each method on graphs of roughly the same complexity. Denote this estimate by c
W and
the resulting adjacency matrix by bB = A(c
W).
D.2
Metrics
We evaluated the learned graphs on four common graph metrics: 1) False discovery rate (FDR), 2) True
positive rate (TPR), 3) False positive rate (FPR), and 4) Structural Hamming distance (SHD). Recall that
SHD is the total number of edge additions, deletions, and reversals needed to convert the estimated DAG into
the true DAG. Since we consider directed graphs, a distinction between True Positives (TP) and Reversed
edges (R) is needed: the former is estimated with correct direction whereas the latter is not. Likewise, a
False Positive (FP) is an edge that is not in the undirected skeleton of the true graph. In addition, Positive
(P) is the set of estimated edges, True (T) is the set of true edges, False (F) is the set of non-edges in the
ground truth graph. Finally, let (E) be the extra edges from the skeleton, (M) be the missing edges from the
skeleton. The four metrics are then given by:
1. FDR = (R + FP)/P
2. TPR = TP/T
3. FPR = (R + FP)/F
4. SHD = E + M + R.
D.3
Further evaluations
Figure 6 shows learned weighted adjacency matrices for ER1 and ER4. One can observe the same trend:
with large n, both regularized and unregularized NOTEARS works well compared to FGS, and with small n,
due to identiﬁability, the unregularized NOTEARS suﬀers signiﬁcantly, yet with the help of ℓ1-regularization
we can still accurately recover the true underlying graph.
Figure 7 and Figure 8 shows structure recovery results for n = 1000 and n = 20 for various random
graphs and SEM noise types. Other than ﬁxed ω as in the main paper, we also included the optimal choice
of thresholding, marked as “best”. The trend is consistent with the main text: our method in general
outperforms FGS, without tuning ω to the optimum for each setting.
Table 2 extends the global minimizer result for various random graph types. For each random graph and
samples, we computed exact local scores as inputs to GOBNILP program, which ﬁnds the globally optimal
structure for the given score. We can again observe that the diﬀerence between our estimate c
W and global
minimizer WG is small across all cases.
19

0
5
10
15
0
5
10
15
W
0
5
10
15
0
5
10
15
f
WECP(0)
0
5
10
15
f
WECP(0.1)
0
5
10
15
BFGS
-2
0
+2
0
5
10
15
0
5
10
15
f
WECP(0)
0
5
10
15
f
WECP(0.1)
0
5
10
15
BFGS
-2
0
+2
0
5
10
15
0
5
10
15
W
(a) true graph
0
5
10
15
0
5
10
15
f
WECP(0)
0
5
10
15
f
WECP(0.1)
0
5
10
15
BFGS
-2
0
+2
(b) estimate with n = 1000
0
5
10
15
0
5
10
15
f
WECP(0)
0
5
10
15
f
WECP(0.1)
0
5
10
15
BFGS
-2
0
+2
(c) estimate with n = 20
Figure 6: Visual comparison of the learned weighted adjacency matrix on a 20-node graph with n = 1000
(large samples) and n = 20 (insuﬃcient samples): f
WECP(λ) is the proposed NOTEARS algorithm with
ℓ1-regularization λ, and BFGS is the binary estimate of the baseline (Ramsey et al., 2016). Top row: ER1,
bottom row: ER4.
Table 2: Comparison of NOTEARS vs. globally optimal solution. ∆(WG, c
W) = F(WG) −F(c
W).
n
λ Graph F(W) F(WG) F(c
W) F(f
WECP) ∆(WG, c
W) ∥c
W −WG∥∥W −WG∥
20 0.00
ER1
5.01
3.69
5.19
3.73
-1.50
0.09
3.54
20 0.50
ER1
12.43
9.90
10.69
9.88
-0.78
0.11
2.76
1000 0.00
ER1
4.96
4.93
4.97
4.92
-0.04
0.03
0.35
1000 0.50
ER1
12.37
10.53
11.01
10.58
-0.48
0.11
2.47
20 0.00
ER2
5.11
3.85
5.36
3.88
-1.52
0.07
3.38
20 0.50
ER2
16.04
12.81
13.49
12.90
-0.68
0.12
3.15
1000 0.00
ER2
4.99
4.97
5.02
4.95
-0.05
0.02
0.40
1000 0.50
ER2
15.93
13.32
14.03
13.46
-0.71
0.12
2.95
20 0.00
ER4
4.76
3.66
5.23
3.88
-1.57
0.08
4.25
20 0.50
ER4
28.24
16.38
19.81
16.82
-3.44
0.15
6.66
1000 0.00
ER4
5.03
5.00
5.50
4.97
-0.50
0.00
0.46
1000 0.50
ER4
28.51
18.29
29.91
18.69
-11.61
0.13
5.76
20 0.00
SF4
4.99
3.77
4.70
3.85
-0.93
0.08
3.31
20 0.50
SF4
23.33
16.19
17.31
16.69
-1.12
0.15
5.08
1000 0.00
SF4
4.96
4.94
5.05
4.99
-0.11
0.04
0.29
1000 0.50
SF4
23.29
17.56
19.70
18.43
-2.13
0.13
4.34
20

GGG
GG
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
GG
GG
G
GG
G
G
G
GG
G
G
G
GG
G
G
G
GGGG
G
GGGG
G
GG
G
G
G
G
G
G
G
G
GGGG
G
GGGG
G
GG
GG
G
GG
G
G
G
G
G
GGG
GG
GG
G
G
GG
G
G
G
G
G
G
G
GGGG
G
GGGG
G
GG
G
G
G
GG
G
G
G
GGGG
G
GGGG
G
G
GG
G
G
GG
G
G
G
GGGG
G
GGGG
G
G
G
GG
G
GG
G
G
G
G
G
GGG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GGGG
G
GGGG
G
GG
GGG
GG
G
G
G
GGGG
G
GGGG
G
G
G
G
G
G
GG
G
G
G
GGGG
G
GG
GG
G
G
G
GG
G
GG
G
G
G
exp
gauss
gumbel
ER1
ER2
ER4
SF4
25
50
75
100
25
50
75
100
25
50
75
100
0
5
10
15
20
0
25
50
75
0
200
400
600
0
100
200
300
d (Number of nodes)
Structural Hamming distance (SHD)
GG
G
G
G
G
G
G
G
G
GGGG
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
GGG
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
GGG
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
GG
GGG
GG
G
G
G
G
G
G
GG
G
G
G
GG
GGGG
G
GGGG
G
G
G
G
GG
GG
G
G
G
GGGG
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
GG
GG
G
G
G
GG
G
G
G
GG
G
G
G
G
G
G
G
G
GGG
G
G
G
G
G
GG
G
G
G
G
G
G
GG
G
GGG
G
GG
G
G
G
G
G
G
GG
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
exp
gauss
gumbel
ER1
ER2
ER4
SF4
25
50
75
100
25
50
75
100
25
50
75
100
0.0
0.1
0.2
0.3
0.4
0.0
0.2
0.4
0.6
0.0
0.2
0.4
0.6
0.0
0.2
0.4
d (Number of nodes)
False discovery rate (FDR)
G
G
GGG
G
G
GG
G
G
G
GGG
GGG
G
G
G
G
G
G
G
GG
G
G
G
GGGG
G
GGG
G
G
G
G
GG
G
GG
GG
G
G
G
G
G
G
G
G
G
G
G
GG
GG
G
G
G
GG
G
G
G
GG
G
G
G
GG
G
G
G
GGG
G
GGG
G
G
G
GG
G
GG
G
G
G
G
G
G
G
G
GG
GG
G
GGGG
G
GGG
G
G
G
G
GG
G
GG
GG
G
G
G
G
G
G
G
G
G
G
G
G
GGG
G
G
G
GG
G
G
G
GG
G
G
G
GG
G
G
G
GGG
G
G
GG
G
GG
GGG
GGG
G
G
G
G
GG
G
GG
GG
G
GG
GG
G
GGG
G
G
G
G
GG
G
GG
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
GG
G
G
G
GG
G
G
G
GG
G
exp
gauss
gumbel
ER1
ER2
ER4
SF4
25
50
75
100
25
50
75
100
25
50
75
100
0.7
0.8
0.9
1.0
0.6
0.7
0.8
0.9
1.0
0.25
0.50
0.75
1.00
0.4
0.6
0.8
1.0
d (Number of nodes)
True positive rate (TPR)
GG
G
G
G
G
G
G
G
G
GGGGG
GGGGG
G
G
G
G
G
GG
G
GG
GGGGG
GGGGG
G
GGG
G
GGGG
G
GGGGG
GGGGG
GGG
G
G
G
G
G
G
G
GGGG
G
GGGGG
G
G
GGG
GG
G
G
G
GGGGG
GGGGG
GG
GG
G
GGGG
G
GGGGG
GGGGG
G
GGG
G
GGGG
G
GGGGG
GGGGG
GG
GG
G
G
G
GG
G
G
GGG
G
GGGGG
G
G
G
GG
G
G
G
G
G
GGGGG
GGGGG
GGGG
G
GG
GG
G
GGGGG
GGGGG
G
G
G
G
G
GGGG
G
GGGGG
GGGGG
GG
GG
G
G
GGG
G
G
GGG
G
GGGGG
exp
gauss
gumbel
ER1
ER2
ER4
SF4
25
50
75
100
25
50
75
100
25
50
75
100
0.00
0.03
0.06
0.09
0.0
0.2
0.4
0.6
0.8
0
1
2
3
0.0
0.2
0.4
0.6
0.8
d (Number of nodes)
False positive rate (FPR)
Method
G
G
G
G
G
FGS
NOTEARS (best)
NOTEARS (fixed)
NOTEARS−L1 (best)
NOTEARS−L1 (fixed)
Figure 7: Structure recovery results for n = 1000. Lower is better, except for TPR (lower left), for which
higher is better. Rows: random graph types, {ER,SF}-k = {Erd¨os-R´enyi, scale-free} graphs with kd expected
edges. Columns: noise types of SEM. Error bars represent standard errors over 10 simulations.
21

GGGGG
GG
G
GG
GG
G
GG
GG
G
GG
GGGGG
GG
G
GG
GG
G
GG
G
G
G
GG
GGGG
G
GGG
G
G
G
G
G
G
G
G
G
G
G
G
GGGGG
GG
G
GG
GG
G
GG
GG
G
G
G
GGGGG
GG
G
GG
GG
G
GG
GG
G
GG
GGGGG
GG
G
GG
GG
G
GG
G
G
G
GG
GGGG
G
GGG
G
G
G
G
G
G
G
G
G
G
G
G
GGGGG
GG
G
GG
GG
G
GG
GG
G
G
G
GGGGG
GG
G
GG
GG
G
GG
GG
G
GG
GGGGG
GG
G
GG
GG
G
GG
G
G
G
GG
GGGG
G
GGG
G
G
G
G
G
G
G
G
G
G
G
G
GGGGG
GG
G
GG
GG
G
GG
GG
G
G
G
exp
gauss
gumbel
ER1
ER2
ER4
SF4
25
50
75
100
25
50
75
100
25
50
75
100
0
200
400
0
100
200
300
400
0
100
200
300
400
0
100
200
300
400
500
d (Number of nodes)
Structural Hamming distance (SHD)
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
GG
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
GG
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GGG
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
GG
exp
gauss
gumbel
ER1
ER2
ER4
SF4
25
50
75
100
25
50
75
100
25
50
75
100
0.00
0.25
0.50
0.75
1.00
0.25
0.50
0.75
0.2
0.4
0.6
0.8
0.2
0.4
0.6
d (Number of nodes)
False discovery rate (FDR)
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
GG
G
G
G
GG
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
GG
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
GG
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
exp
gauss
gumbel
ER1
ER2
ER4
SF4
25
50
75
100
25
50
75
100
25
50
75
100
0.00
0.25
0.50
0.75
0.00
0.25
0.50
0.75
0.25
0.50
0.75
1.00
0.25
0.50
0.75
d (Number of nodes)
True positive rate (TPR)
G
G
G
G
G
GG
G
G
G
GG
G
GG
GG
G
GG
GG
G
G
G
G
G
G
G
G
GG
G
G
G
GG
G
GG
G
G
G
G
G
GG
G
GG
GG
G
GG
GGGGG
G
G
G
G
G
GG
G
G
G
GG
G
GG
GG
G
GG
GG
G
G
G
GG
G
G
G
GG
G
GG
GG
G
GG
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
GG
G
GG
G
G
G
G
G
G
G
G
GG
GG
G
GG
GGGGG
G
G
G
G
G
GG
G
GG
GG
G
GG
GG
G
GG
GG
G
G
G
GG
G
G
G
GG
G
GG
GG
G
GG
G
G
G
G
G
G
G
G
G
G
GG
G
G
G
GG
G
GG
G
G
G
G
G
GG
G
GG
GG
G
GG
GGGGG
G
G
G
G
G
GG
G
G
G
GG
G
GG
GG
G
GG
exp
gauss
gumbel
ER1
ER2
ER4
SF4
25
50
75
100
25
50
75
100
25
50
75
100
0.0
0.2
0.4
0.6
0.0
0.2
0.4
0.6
0.0
0.5
1.0
1.5
2.0
0.00
0.25
0.50
0.75
d (Number of nodes)
False positive rate (FPR)
Method
G
G
G
G
G
FGS
NOTEARS (best)
NOTEARS (fixed)
NOTEARS−L1 (best)
NOTEARS−L1 (fixed)
Figure 8: Structure recovery results for n = 20. Lower is better, except for TPR (lower left), for which higher
is better. Rows: random graph types, {ER,SF}-k = {Erd¨os-R´enyi, scale-free} graphs with kd expected edges.
Columns: noise types of SEM. Error bars represent standard errors over 10 simulations.
22

