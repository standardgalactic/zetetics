1
Determinacy in a synchronous π-calculus
Roberto M. Amadio
Universit´e Paris Diderot, PPS, UMR-7126
Mehdi Dogguy
Universit´e Paris Diderot, PPS, UMR-7126
Abstract
The Sπ-calculus is a synchronous π-calculus which is based on the SL
model. The latter is a relaxation of the Esterel model where the reac-
tion to the absence of a signal within an instant can only happen at
the next instant. In the present work, we present and characterize a
compositional semantics of the Sπ-calculus based on suitable notions
of labelled transition system and bisimulation. Based on this semantic
framework, we explore the notion of determinacy and the related one of
(local) conﬂuence.1
1.1 Introduction
Let P be a program that can repeatedly interact with its environment.
A derivative of P is a program to which P reduces after a ﬁnite number
of interactions with the environment. A program terminates if all its
internal computations terminate and it is reactive if all its derivatives
are guaranteed to terminate. A program is determinate if after any ﬁnite
number of interactions with the environment the resulting derivative is
unique up to semantic equivalence.
Most conditions found in the literature that entail determinacy are
rather intuitive, however the formal statement of these conditions and
the proof that they indeed guarantee determinacy can be rather intricate
in particular in the presence of name mobility, as available in a paradig-
matic form in the π-calculus.
Our purpose here is to provide a streamlined theory of determinacy
for the synchronous π-calculus introduced in [2]. It seems appropriate
1 Work partially supported by ANR-06-SETI-010-02.
From Semantics to Computer Science Essays in Honour of Gilles Kahn,
eds Yves
Bertot, G´erard Huet, Jean-Jacques L´evy and Gordon Plotkin. Published by Cambridge
University Press.
c
⃝Cambridge University Press 2009.
1
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

2
R. M. Amadio and M. Dogguy
to address these issues in a volume dedicated to the memory of Gilles
Kahn. First, Kahn networks [14] are a classic example of concurrent and
deterministic systems. Second, Kahn networks have largely inspired the
research on synchronous languages such as Lustre [9] and, to a lesser
extent, Esterel [6]. An intended side-eﬀect of this work is to illustrate
how ideas introduced in concurrency theory well after Kahn networks
can be exploited to enlighten the study of determinacy in concurrent
systems.
Our technical approach will follow a process calculus tradition, as
listed here.
(i) We describe the interactions of a program with its environment
through a labelled transition system to which we associate a compo-
sitional notion of labelled bisimulation.
(ii) We rely on this semantic framework, to introduce a notion of
determinacy and a related notion of conﬂuence.
(iii) We provide local conﬂuence conditions that are easier to check
and that combined with reactivity turn out to be equivalent to
determinacy.
We brieﬂy trace the path that has led to this approach. A system-
atic study of determinacy and conﬂuence for calculus of communicating
systems (CCS) is available in [17] where, roughly, the usual theory of
rewriting is generalized in two directions: ﬁrst rewriting is labelled and
second diagrams commute up to semantic equivalence. In this context,
a suitable formulation of Newman’s lemma [19], has been given in [11].
The theory has been gradually extended from CCS, to CCS with values,
and ﬁnally to the π-calculus [20].
Calculi such as CCS and the π-calculus are designed to represent
asynchronous systems. On the other hand, the Sπ-calculus is designed
to represent synchronous systems. In these systems, there is a notion of
instant (or phase, or pulse, or round) and at each instant each thread
performs some actions and synchronizes with all other threads. One may
say that all threads proceed at the same speed and it is in this speciﬁc
sense that we will refer to synchrony in this work.
In order to guarantee determinacy in the context of CCS rendez-vous
communication, it seems quite natural to restrict the calculus so that
interaction is point-to-point, i.e., it involves exactly one sender and one
receiver.2 In a synchronous framework, the introduction of signal-based
2 Incidentally, this is also the approach taken in Kahn networks but with an interac-
tion mechanism based on unbounded, ordered buﬀers. It is not diﬃcult to represent
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
3
communication oﬀers an opportunity to move from point-to-point to
a more general multi-way interaction mechanism with multiple senders
and/or receivers, while preserving determinacy. In particular, this is the
approach taken in the Esterel and SL [8] models. The SL model can be
regarded as a relaxation of the Esterel model where the reaction to the
absence of a signal within an instant can only happen at the next instant.
This design choice avoids some paradoxical situations and simpliﬁes the
implementation of the model. The SL model has gradually evolved into a
general purpose programming language for concurrent applications and
has been embedded in various programming environments such as C,
Java, Scheme, and Caml (see [7, 22, 16]). For instance, the Reactive
ML language [16] includes a large fragment of the Caml language plus
primitives to generate signals and synchronize on them. We should also
mention that related ideas have been developed by Saraswat et al. [21]
in the area of constraint programming.
The Sπ-calculus can be regarded as an extension of the SL model
where signals can carry values. In this extended framework, it is more
problematic to have both concurrency and determinacy. Nowadays,
this question is frequently considered when designing various kind of
synchronous programming languages (see, e.g. [16, 10]). As we have
already mentioned, our purpose here is to address the question with the
tool-box of process calculi following the work for CCS and the π-calculus
quoted above. In this respect, it is worth stressing a few interesting
variations that arise when moving from the ‘asynchronous’ π-calculus to
the ‘synchronous’ Sπ-calculus. First, we have already pointed-out that
there is an opportunity to move from a point-to-point to a multi-way
interaction mechanism while preserving determinacy. Second, the notion
of conﬂuence and determinacy happen to coincide while in the asyn-
chronous context conﬂuence is a strengthening of determinacy which
has better compositionality properties. Third, reactivity appears to be a
reasonable property to require of a synchronous system, the goal being
just to avoid instantaneous loops, i.e. loops that take no time.3
The rest of the paper is structured as follows. In Section 1.2, we intro-
duce the Sπ-calculus, in Section 1.3, we deﬁne its semantics based on
unbounded, ordered buﬀers in a CCS with value passing and show that, modulo
this encoding, the determinacy of Kahn networks can be obtained as a corollary
of the theory of conﬂuence developed in [17].
3 The situation is diﬀerent in asynchronous systems where reactivity is a more
demanding property. For instance, [11] notes: “As soon as a protocol internally
consists in some kind of correction mechanism (e.g., retransmission in a data link
protocol) the speciﬁcation of that protocol will contain a τ-loop”.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

4
R. M. Amadio and M. Dogguy
a standard notion of labelled bisimulation on a (non-standard) labelled
transition system and we show that the bisimulation is preserved by
static contexts, in Section 1.4 we provide alternative characterisations of
the notion of labelled bisimulation we have introduced, in Section 1.5, we
develop the concepts of determinacy and (local) conﬂuence. Familiarity
with the π-calculus [18, 23], the notions of determinacy and conﬂuence
presented in [17], and synchronous languages of the Esterel family
[6, 8] is assumed.
1.2 Introduction to the Sπ-calculus
We introduce the syntax of the Sπ-calculus along with an informal
comparison with the π-calculus and a programming example.
1.2.1 Programs
Programs P, Q, . . . in the Sπ-calculus are deﬁned as follows:
P
: : =
0 || A(e) || se || s(x).P, K || [s1 = s2]P1, P2 || [u  p]P1, P2
|| νs P || P1 | P2
K
: : =
A(r)
We use the notation m for a vector m1, . . . , mn, n ≥0. The informal
behaviour of programs follows. 0 is the terminated thread. A(e) is a
(tail) recursive call of a thread identiﬁer A with a vector e of expressions
as argument; as usual the thread identiﬁer A is deﬁned by a unique
equation A(x) = P such that the free variables of P occur in x. se
evaluates the expression e and emits its value on the signal s. s(x).P, K
is the present statement which is the fundamental operator of the SL
model. If the values v1, . . . , vn have been emitted on the signal s then
s(x).P, K evolves non-deterministically into [vi/x]P for some vi ([ / ] is
our notation for substitution). On the other hand, if no value is emitted
then the continuation K is evaluated at the end of the instant. [s1 =
s2]P1, P2 is the usual matching function of the π-calculus that runs P1 if
s1 equals s2 and P2, otherwise. Here both s1 and s2 are free. [up]P1, P2,
matches u against the pattern p. We assume u is either a variable x or
a value v and p has the shape c(x), where c is a constructor and x is a
vector of distinct variables. We also assume that if u is a variable x then
x does not occur free in P1. At run time, u is always a value and we run
θP1 if θ = match(u, p) is the substitution matching u against p, and P2
if such substitution does not exist (written match(u, p) ↑). Note that as
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
5
usual the variables occurring in the pattern p (including signal names)
are bound in P1. νs P creates a new signal name s and runs P. (P1 | P2)
runs in parallel P1 and P2. A continuation K is simply a recursive call
whose arguments are either expressions or values associated with signals
at the end of the instant in a sense that we explain below. We will also
write pause.K for νs s(x).0, K with s not free in K. This is the program
that waits till the end of the instant and then evaluates K.
1.2.2 Expressions
The deﬁnition of programs relies on the following syntactic categories:
Sig
: : =
s || t || · · ·
(signal names)
Var
: : =
Sig || x || y || z || · · ·
(variables)
Cnst
: : =
∗|| nil || cons || c || d || · · ·
(constructors)
Val
: : =
Sig || Cnst(Val, . . . , Val)
(values v, v′, . . .)
Pat
: : =
Cnst(Var, . . . , Var)
(patterns p, p′, . . .)
Fun
: : =
f || g || · · ·
(ﬁrst-order function symbols)
Exp
: : =
Var
|| Cnst(Exp, . . . , Exp)
|| Fun(Exp, . . . , Exp)
(expressions e, e′, . . .)
Rexp
: : =
!Sig
|| Var
|| Cnst(Rexp, . . . , Rexp)
|| Fun(Rexp, . . . , Rexp)
(exp. with deref. r, r′, . . .).
As in the π-calculus, signal names stand both for signal constants as
generated by the ν operator and signal variables as in the formal para-
meter of the present operator. Variables Var include signal names as
well as variables of other types. Constructors Cnst include ∗, nil, and
cons. Values Val are terms built out of constructors and signal names.
Patterns Pat are terms built out of constructors and variables (includ-
ing signal names). If P, p are a program and a pattern then we denote
with fn(P), fn(p) the set of free signal names occurring in them, respec-
tively. We also use FV (P), FV (p) to denote the set of free variables
(including signal names). We assume ﬁrst-order function symbols f, g, . . .
and an evaluation relation ⇓such that for every function symbol f and
values v1, . . . , vn of suitable type there is a unique value v such that
f(v1, . . . , vn) ⇓v and fn(v) ⊆
i=1,...,n fn(vi). Expressions Exp are
terms built out of variables, constructors, and function symbols. The
evaluation relation ⇓is extended in a standard way to expressions whose
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

6
R. M. Amadio and M. Dogguy
only free variables are signal names. Finally, Rexp are expressions that
may include the value associated with a signal s at the end of the instant
(which is written !s, following the ML notation for dereferenciation).
Intuitively, this value is a list of values representing the set of values
emitted on the signal during the instant.
1.2.3 Typing
Types include the basic type 1 inhabited by the constant ∗and, assum-
ing σ is a type, the type Sig(σ) of signals carrying values of type σ,
and the type List(σ) of lists of values of type σ with constructors
nil and cons. In the examples, it will be convenient to abbreviate
cons(v1, . . . , cons(vn, nil) . . .) with [v1; . . . ; vn]. 1 and List(σ) are exam-
ples of inductive types. More inductive types (booleans, numbers,
trees,. . .) can be added along with more constructors. We assume that
variables (including signals), constructor symbols, and thread identiﬁers
come with their (ﬁrst-order) types. For instance, a function symbols f
may have a type (σ1, σ2) →σ meaning that it waits two arguments
of type σ1 and σ2, respectively, and returns a value of type σ. It is
straightforward to deﬁne when a program is well-typed. We just point
out that if a signal name s has type Sig(σ) then its dereferenced value
!s has type List(σ). In the following, we will tacitly assume that we are
handling well typed programs, expressions, substitutions, . . . .
1.2.4 Comparison with the π-calculus
The syntax of the Sπ-calculus is similar to the one of the π-calculus,
however, there are some important semantic diﬀerences that we highlight
in the following simple example. Assume v1 ̸= v2 are two distinct values
and consider the following program in Sπ:
P = ν s1, s2

s1v1
|
s1v2
|
s1(x). (s1(y). (s2(z). A(x, y) , B(!s1)) , 0) , 0

If we forget about the underlined parts and we regard s1, s2 as channel
names then P could also be viewed as a π-calculus process. In this case,
P would reduce to
P1 = νs1, s2 (s2(z).A(θ(x), θ(y))
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
7
where θ is a substitution such that θ(x), θ(y) ∈{v1, v2} and θ(x) ̸= θ(y).
In Sπ, signals persist within the instant and P reduces to
P2 = νs1, s2 (s1v1 | s1v2 | (s2(z).A(θ(x), θ(y)), B(!s1)))
where θ(x), θ(y) ∈{v1, v2}. What happens next? In the π-calculus, P1 is
deadlocked and no further computation is possible. In the Sπ-calculus,
the fact that no further computation is possible in P2 is detected and
marks the end of the current instant. Then an additional computation
represented by the relation
N
−→moves P2 to the following instant:
P2
N
−→P ′
2 = νs1, s2 B(v)
where v
∈
{[v1; v2], [v2; v1]}. Thus at the end of the instant, a
dereferenced signal such as !s1 becomes a list of (distinct) values emitted
on s1 during the instant and then all signals are reset.
1.2.5 A programming example
We introduce a programming example to illustrate the kind of
synchronous programming that can be represented in the Sπ-calculus.
We describe ﬁrst a ‘server’ handling a list of requests emitted in the
previous instant on the signal s. For each request of the shape req(s′, x),
it provides an answer which is a function of x along the signal s′.
Server(s)
=
pause.Handle(s, !s)
Handle(s, ℓ)
=
[ℓ req(s′, x)::ℓ′](s′f(x) | Handle(s, ℓ′)), Server(s) .
The programming of a client that issues a request x on signal s and
returns the reply on signal t could be the following:
Client(x, s, t)
=
νs′ (sreq(s′, x) | pause.s′(x).tx, 0) .
1.3 Semantics of the Sπ-calculus
In this section, we deﬁne the semantics of the Sπ-calculus by a ‘standard’
notion of labelled bisimulation on a ‘non-standard’ labelled transition
system and we show that labelled bisimulation is preserved by ‘static’
contexts. A distinct notion of labelled bisimulation for the Sπ-calculus
has already been studied in [2] and the following Section 1.4 will show
that the two notions are (almost) the same. A signiﬁcant advantage of
the presentation of labelled bisimulation we discuss here is that in the
‘bisimulation game’ all actions are treated in the same way. This allows
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

8
R. M. Amadio and M. Dogguy
for a considerable simpliﬁcation of the diagram chasing arguments that
are needed in the study of determinacy and conﬂuence in Section 1.5.
1.3.1 Actions
The actions of the forthcoming labelled transition system are classiﬁed
in the following categories:
act
: : = α || aux
(actions)
α
: : = τ || νt sv || sv || N
(relevant actions)
aux
: : = s?v || (E, V )
(auxiliary actions)
µ
: : = τ || νt sv || s?v
(nested actions)
The category act is partitioned into relevant actions and auxiliary
actions.
The relevant actions are those that are actually considered in the
bisimulation game. They consist of: (i) an internal action τ; (ii) an emis-
sion action νt sv where it is assumed that the signal names t are distinct,
occur in v, and diﬀer from s; (iii) an input action sv; and (iv) an action
N (for Next) that marks the move from the current to the next instant.
The auxiliary actions consist of an input action s?v which is coupled
with an emission action in order to compute a τ action and an action
(E, V ) which is just needed to compute an action N. The latter is
an action that can occur exactly when the program cannot perform τ
actions and it amounts (i) to collect in lists the set of values emitted on
every signal, (ii) to reset all signals, and (iii) to initialize the continuation
K for each present statement of the shape s(x).P, K.
In order to formalize these three steps we need to introduce some
notation. Let E vary over functions from signal names to ﬁnite sets of
values. Denote with ∅the function that associates the empty set with
every signal name, with [M/s] the function that associates the set M
with the signal name s and the empty set with all the other signal names,
and with ∪the union of functions deﬁned point-wise.
We represent a set of values as a list of the values contained in the
set. More precisely, we write v ∥−M and say that v represents M if
M = {v1, . . . , vn} and v = [vπ(1); . . . ; vπ(n)] for some permutation π over
{1, . . . , n}. Suppose V is a function from signal names to lists of values.
We write V ∥−E if V (s) ∥−E(s) for every signal name s. We also write
dom(V ) for {s | V (s) ̸= []}. If K is a continuation, i.e. a recursive call
A(r), then V (K) is obtained from K by replacing each occurrence !s of
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
9
a dereferenced signal with the associated value V (s). We denote with
V [ℓ/s] the function that behaves as V except on s where V [ℓ/s](s) = ℓ.
With these conventions, a transition P
(E,V )
−−−−→P ′ intuitively means
that (1) P is suspended, (2) P emits exactly the values speciﬁed by E,
and (3) the behaviour of P in the following instant is P ′ and depends
on V . It is convenient to compute these transitions on programs where
all name generations are lifted at top level. We write P ⪰Q if we can
obtain Q from P by repeatedly transforming, for instance, a subprogram
νsP ′ | P ′′ into νs(P ′ | P ′′) where s /∈fn(P ′′).
Finally, the nested actions µ, µ′, . . . are certain actions (either relevant
or auxiliary) that can be produced by a sub-program and that we need
to propagate to the top level.
1.3.2 Labelled transition system
The labelled transition system is deﬁned in Table 1.1 where rules
apply to programs whose only free variables are signal names and with
standard conventions on the renaming of bound names. As usual, one
can rename bound variables, and the symmetric rules for (par) and
(synch) are omitted. The ﬁrst 12 rules from (out) to (νex) are quite close
to those of a polyadic π-calculus with asynchronous communication (see
[4, 12, 13]) with the following exception: rule (out) models the fact that
the emission of a value on a signal persists within the instant. The last
ﬁve rules from (0) to (next) are quite speciﬁc of the Sπ-calculus and
determine how the computation is carried on at the end of the instant
(cf. discussion in Section 1.3.1).
The relevant actions diﬀerent from τ, model the possible interactions
of a program with its environment. Then the notion of reactivity can be
formalized as follows.
Deﬁnition 1.1 (derivative) A derivative of a program P is a program
Q such that
P
α1
−→· · ·
αn
−−→Q,
where: n ≥0 .
Deﬁnition 1.2 (reactivity) We say that a program P is reactive, if
for every derivative Q every τ-reduction sequence terminates.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

10
R. M. Amadio and M. Dogguy
Table 1.1. Labelled transition system.
(out)
e ⇓v
se
sv
−→se
(inaux)
s(x).P, K
s?v
−−→[v/x]P
(in)
P
sv
−→(P | sv)
(rec)
A(x) = P,
e ⇓v
A(e)
τ−→[v/x]P
(=sig
1 )
[s = s]P1, P2
τ−→P1
(=sig
2 )
s1 ̸= s2
[s1 = s2]P1, P2
τ−→P2
(=ind
1 )
match(v, p) = θ
[v  p]P1, P2
τ−→θP1
(=ind
1 )
match(v, p) =↑
[v  p]P1, P2
τ−→P2
(comp)
P1
µ−→P ′
1
bn(µ) ∩fn(P2) = ∅
P1 | P2
µ−→P ′
1 | P2
(synch)
P1
νt sv
−−−→P ′
1
P2
s?v
−−→P ′
2
{t} ∩fn(P2) = ∅
P1 | P2
τ−→νt (P ′
1 | P ′
2)
(ν)
P
µ−→P ′
t /∈n(µ)
νt P
µ−→νt P ′
(νex)
P
νt sv
−−−→P ′
t′ ̸= s
t′ ∈n(v)\{t}
νt′ P
(νt′,t)sv
−−−−−→P ′
(0)
0
∅,V
−−→0
(reset)
e ⇓v
v occurs in V (s)
se
[{v}/s],V
−−−−−−→0
(cont)
s /∈dom(V )
s(x).P, K
∅,V
−−→V (K)
(par)
Pi
Ei,V
−−−→P ′
i
i = 1, 2
(P1 | P2)
E1∪E2,V
−−−−−−→(P ′
1 | P ′
2)
(next)
P ⪰νs P ′
P ′
E,V
−−→P ′′
V ∥−E
P
N
−→νs P ′′
1.3.3 A compositional labelled bisimulation
We introduce ﬁrst a rather standard notion of (weak) labelled
bisimulation. We deﬁne
α⇒as:
α⇒=





(
τ−→)∗
if α = τ
(
τ⇒) ◦(
N
−→)
if α = N
(
τ⇒) ◦(
α−→) ◦(
τ⇒)
otherwise
This is the standard deﬁnition except that we insist on not having
internal reductions after an N action. Intuitively, we assume that an
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
11
observer can control the execution of programs so as to be able to
test them at the very beginning of each instant.4 We write P
α−→· for
∃P ′ (P
α−→P ′).
Deﬁnition 1.3 (labelled bisimulation) A symmetric relation R on
programs is a labelled bisimulation if
P R Q,
P
α−→P ′,
bn(α) ∩fn(Q) = ∅
∃Q′ ( Q
α⇒Q′,
P ′ R Q′ )
We denote with ≈the largest labelled bisimulation.
The standard variation where one considers weak reduction in the
hypothesis (P
α⇒P ′ rather than P
α−→P ′) leads to the same rela-
tion. Furthermore, relying on this variation, one can show that the
concept of bisimulation up to bisimulation makes sense, i.e. a bisimula-
tion up to bisimulation is indeed contained in the largest bisimulation.
An important property of labelled bisimulation is that it is preserved by
static contexts. The proof of this fact follows [2] and it is presented in
Appendix A.2.
Deﬁnition 1.4 A static context C is deﬁned as follows:
C:: = [ ] || C | P || νs C
(1.1)
Theorem 1.5 (compositionality of labelled bisimulation) If P ≈
Q and C is a static context then C[P] ≈C[Q].
1.4 Characterizations of labelled bisimulation
The labelled transition system presented in Table 1.1 embodies a number
of technical choices which might not appear so natural at ﬁrst sight. To
justify these choices, it is therefore interesting to look for alternative
characterizations of the induced bisimulation equivalence. To this end
we recall the notion of contextual bisimulation introduced in [2].
4 This decision entails that, e.g., we distinguish the programs P and Q deﬁned
as follows: P = pause.(s1 ⊕s2), Q = νs (pause.A(!s) | s0 | s1), where A(x) =
[x  [0; 1]](s1 ⊕s2), s1, and ⊕, 0, and 1 are abbreviations for an internal choice
and for two distinct constants, respectively (these concepts can be easily coded in
the Sπ-calculus). On the other hand, P and Q would be equivalent if we deﬁned
N
⇒as
τ⇒◦N
−→◦τ⇒.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

12
R. M. Amadio and M. Dogguy
Deﬁnition 1.6 We write:
P ↓
if
¬( P
τ−→· )
(suspension)
P ⇓
if
∃P ′ ( P
τ⇒P ′ and P ′ ↓)
(weak suspension)
P ⇓L
if
∃P ′ ( P | P ′ ) ⇓
(L-suspension)
Obviously, P ↓implies P ⇓which in turn implies P ⇓L and none of
these implications can be reversed (see [2]). Furthermore, note that all
the derivatives of a reactive program enjoy the weak suspension property.
Deﬁnition 1.7 (commitment) We write P ↘s if P
νt sv
−−−→· and say
that P commits to emit on s.
Deﬁnition 1.8 (barbed bisimulation) A symmetric relation R on
programs is a barbed bisimulation if whenever P R Q the following holds:
(B1) If P
τ−→P ′ then ∃Q′ (Q
τ⇒Q′ and P ′ R Q′).
(B2) If P ↘s and P ⇓L then ∃Q′ (Q
τ⇒Q′, Q′ ↘s, and P R Q′).
(B3) If P ↓and P
N
−→P ′′ then ∃Q′, Q′′ (Q
τ⇒Q′, Q′ ↓, P R Q′, Q′
N
−→
Q′′, and P ′′ R Q′′).
We denote with ≈B the largest barbed bisimulation.
Deﬁnition 1.9 (contextual bisimulation) A symmetric relation R
on programs is a contextual bisimulation if it is a barbed bisimulation
(conditions (B1 −3)) and moreover whenever P R Q then
(C1) C[P] R C[Q], for any static context C.
We denote with ≈C the largest contextual barbed bisimulation.
We arrive at the announced characterization of the labelled bisimula-
tion.
Theorem 1.10 (characterization of labelled bisimulation) If P, Q
are reactive programs then P ≈Q if and only if P ≈C Q.
The proof of this result takes several steps summarized in Table 1.2
which provides three equivalent formulations of the labelled bisimula-
tion ≈.
In [2], the contextual bisimulation in Deﬁnition 1.9 is characterized as
a variant of the bisimulation ≈3 where the condition for the output is
formulated as follows:
P R Q,
P ⇓L,
P
νt sv
−−−→2 P ′,
{t} ∩fn(Q) = ∅
Q
νt sv
⇒2 Q′,
P ′ R Q′
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
13
Table 1.2. Equivalent formulations of labelled bisimulation.
Labelled transition systems
( α
−→1)
Rule (inaux ) replaced by
(in1
aux )
s(x).P, K
s?v
−−→[v/x]P | sv
( α
−→2)
Rule (in) removed and
action s?v replaced by sv
( α
→3)
Coincides with
α
−→2
Bisimulation games
(≈1)
As in Deﬁnition 1.3
(≈2)
As above if α ̸= sv. Require:
(Inp)
P R Q
(P | sv) R (Q | sv)
(≈3)
As above if α ̸= sv. Replace (Inp) with :
P R Q,
P
sv
−→2 P ′
∃Q′ ( Q
sv
⇒2 Q′ ∧P ′ R Q′)∨
(Q
τ
⇒2 Q′ ∧P ′ R (Q′ | sv) )
and for α = N require:
P R Q, (P | S) N
−→P ′,
S = s1v1 | · · · | snvn
∃Q′, Q′′ ( (Q | S)
τ
⇒2 Q′′,
(P | S) R Q′′,
Q′′
N
−→2 Q′,
P ′ R Q′ )
Clearly, if P is a reactive program then P ⇓L. Note also that the Deﬁni-
tion 1.2 of a reactive program refers to the labelled transition system 1.1
for which it holds that P
sv
−→(P | sv). Therefore, if P is reactive then
(P | sv) is reactive too and if we start comparing two reactive programs
then all programs that have to be considered in the bisimulation game
will be reactive too. This means that on reactive programs the condition
P ⇓L is always satisﬁed and therefore that the bisimulation ≈3 coincides
with the labelled bisimulation considered in [2].5
5 On non-reactive programs, labelled bisimulation makes more distinctions than
contextual bisimulation. For instance, the latter identiﬁes all the programs that
do not L-suspend.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

14
R. M. Amadio and M. Dogguy
Remark 1.11 (on determinacy and divergence) One may notice
that the notions of labelled bisimulation and contextual bisimulation we
have adopted are only partially sensitive to divergence. Let Ω= τ.Ωbe
a looping program. Then Ω̸≈C 0 since 0 may suspend while Ωmay
not. On the other hand, consider a program such as A = τ.A ⊕τ.0.
Then A ≈0 and therefore A ≈C 0 and we are led to conclude that
A is a determinate program. However, one may also argue that A is
not determinate since it may either suspend or loop. In other words,
determinacy depends on the notion of semantic equivalence we adopt. If
the latter is not sensitive enough to divergence then the resulting notion
of determinacy should be regarded as a partial property of programs, i.e.
it holds provided programs terminate. In practice, these distinctions do
not seem very important because, as we have already argued, reactivity
is a property one should always require of synchronous programs and
once reactivity is in place the distinctions disappear.
1.5 Determinacy and (local) conﬂuence
In this section, we develop the notions of determinacy and conﬂuence
for the Sπ-calculus which turn out to coincide. Moreover, we note that
for reactive programs a simple property of local conﬂuence suﬃces to
ensure determinacy.
We denote with ϵ the empty sequence and with s = α1 · · · αn a ﬁnite
sequence (possibly empty) of actions diﬀerent from τ. We deﬁne:
s⇒=

τ⇒
if s = ϵ
α1
⇒· · ·
αn
⇒
if s = α1 · · · αn
Thus s denotes a ﬁnite (possibly empty) sequence of interactions with the
environment. Following Milner [17], a program is considered determinate
if performing twice the same sequence of interactions leads to the same
program up to semantic equivalence.
Deﬁnition 1.12 (determinacy) We say that a program P is determi-
nate if for every sequence s, if P
s⇒Pi for i = 1, 2 then P1 ≈P2.
Determinacy implies τ-inertness which is deﬁned as follows.
Deﬁnition 1.13 (τ-inertness) A program is τ-inert if for all its
derivatives Q, Q
τ−→Q′ implies Q ≈Q′.
Next, we turn to the notion of conﬂuence. To this end, we introduce
ﬁrst the notions of action compatibility and action residual.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
15
Deﬁnition 1.14 (action compatibility) The compatibility predicate
↓is deﬁned as the least reﬂexive and symmetric binary relation on
actions such that α ↓β implies that either α, β ̸= N or α = β = N.
In other words, the action N is only compatible with itself while any
action diﬀerent from N is compatible with any other action diﬀerent
from N.6 Intuitively, conﬂuence is about the possibility of commuting
actions that happen in the same instant. To make this precise we also
need to introduce a notion of action residual α\β, which speciﬁes what
remains of the action α once the action β is performed.
Deﬁnition 1.15 (action residual) The residual operation α\β on
actions is only deﬁned if α ↓β and in this case it satisﬁes:
α\β =



τ
if α = β
νt\t′sv
if α = νt sv and β = νt′s′v′
α
otherwise
Conﬂuence is then about closing diagrams of compatible actions up
to residuals and semantic equivalence.
Deﬁnition 1.16 (conﬂuence) We say that a program P is conﬂuent,
if for all its derivatives Q:
Q
α⇒Q1,
Q
β⇒Q2,
α ↓β
∃Q3, Q4 ( Q1
β\α
⇒Q3,
Q2
α\β
⇒Q4,
Q3 ≈Q4 )
It often turns out that the following weaker notion of local conﬂuence
is much easier to establish.
Deﬁnition 1.17 (local conﬂuence) We say that a program is locally
conﬂuent, if for all its derivatives Q:
Q
α−→Q1
Q
β−→Q2
α ↓β
∃Q3, Q4 ( Q1
β\α
⇒Q3,
Q2
α\β
⇒Q4,
Q3 ≈Q4 )
6 The reader familiar with [20] will notice that, unlike in the π-calculus with
rendezvous communication, we do not restrict the compatibility relation on input
actions. This is because of the particular form of the input action in the labelled
transition system in Table 1.1 where the input action does not actually force a
program to perform an input. We expect that a similar situation would arise in
the π-calculus with asynchronous communication.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

16
R. M. Amadio and M. Dogguy
It is easy to produce programs which are locally conﬂuent but not
conﬂuent. For instance, A = s1⊕B where B = s2⊕A. However, one may
notice that this program is not reactive. Indeed, for reactive programs
local conﬂuence is equivalent to conﬂuence.
Theorem 1.18
(1) A program is determinate if and only if it is conﬂuent.
(2) A reactive program is determinate if and only if for all its derivatives
Q:
Q
α−→Q1,
Q
α−→Q2,
α ∈{τ, N}
∃Q3, Q4 (Q1
τ⇒Q3,
Q2
τ⇒Q4,
Q3 ≈Q4)
The fact that conﬂuent programs are determinate is standard and
it essentially follows from the observation that conﬂuent programs are
τ-inert. The observation that determinate programs are conﬂuent is
speciﬁc of the Sπ-calculus and it depends on the remark that input
and output actions automatically commute with the other compatible
actions.7
Part (2) of the theorem is proved as follows. First one notices that
the stated conditions are equivalent to local conﬂuence (again relying
on the fact that commutation of input and output actions is automatic)
and then following [11] one observes that local conﬂuence plus reactivity
entails conﬂuence.
We conclude this section by noticing a strong commutation property
of τ actions that suﬃces to entail τ-inertness and determinacy. Let
α;
be
α−→∪Id where Id is the identity relation.
Proposition 1.19 A program is determinate if for all its derivatives Q:
Q
τ−→Q1,
Q
τ−→Q2
∃Q′ (Q1
τ; Q′,
Q2
τ; Q′)
Q
N
−→Q1,
Q
N
−→Q2
Q1 ≈Q2
This is proven by showing that the strong commutation of the τ-
actions entails τ-inertness.
7 We note that the commutation of the inputs arises in the π-calculus with
asynchronous communication too, while the commutation of the outputs is due to
the fact that messages on signals unlike messages on channels persist within an
instant (for instance, in CCS, if P = a | a.b then P
a−→a.b, P
τ−→b, and there is
no way to close the diagram).
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
17
1.6 Conclusion
We have developed a framework to analyse the determinacy of programs
in a synchronous π-calculus. First, we have introduced a composi-
tional notion of labelled bisimulation. Second, we have characterized
a relevant contextual bisimulation as a standard bisimulation over a
modiﬁed labelled transition system. Third, we have studied the notion
of conﬂuence which turns out to be equivalent to determinacy, and we
have shown that under reactivity, conﬂuence reduces to a simple form
of local conﬂuence.
According to Theorem 1.18(2), there are basically two situations that
need to be analysed in order to guarantee the determinacy of (reactive)
programs. (1) At least two distinct values compete to be received within
an instant, for instance, consider: sv1 | sv2 | s(x).P, K. (2) At the end
of the instant, at least two distinct values are available on a signal. For
instance, consider: sv1 | sv2 | pause.A(!s). Based on this analysis, we
are currently studying an aﬃne type system in the style of [15] that
avoids completely the ﬁrst situation and allows the second provided the
behaviour of the continuation A does not depend on the order in which
the values are collected.
Bibliography
[1]
R. Amadio. The SL synchronous language, revisited. Journal of Logic and
Algebraic Programming, 70:121–150, 2007.
[2]
R. Amadio. A synchronous π-calculus. Information and Computation,
205(9):1470–1490, 2007.
[3]
R. Amadio, G. Boudol, F. Boussinot and I. Castellani. Reactive program-
ming, revisited. In Proc. Workshop on Algebraic Process Calculi: the ﬁrst
25 years and beyond, Electronic Notes in Theoretical Computer Science,
162:49–60, 2006.
[4]
R. Amadio, I. Castellani and D. Sangiorgi. On bisimulations for the asyn-
chronous π-calculus. Theoretical Computer Science, 195:291–324, 1998.
[5]
R. Amadio and F. Dabrowski. Feasible reactivity in a synchronous π-
calculus. In Proc. ACM SIGPLAN Symp. on Principles and Practice of
Declarative Programming, 2007.
[6]
G. Berry and G. Gonthier. The Esterel synchronous programming
language. Science of Computer Programming, 19(2):87–152, 1992.
[7]
F. Boussinot. Reactive C: An extension of C to program reactive systems.
Software Practice and Experience, 21(4):401–428, 1991.
[8]
F. Boussinot and R. De Simone. The SL synchronous language. IEEE
Trans. on Software Engineering, 22(4):256–266, 1996.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

18
R. M. Amadio and M. Dogguy
[9]
P. Caspi, D. Pilaud, N. Halbwachs and J. Plaice. Lustre: A declara-
tive language for programming synchronous systems. In Proc. ACM-POPL,
pp. 178–188, 1987.
[10]
S. Edwards and O. Tardieu. SHIM: A deterministic model for heteroge-
neous embedded systems. IEEE Transactions on Very Large Scale Integra-
tion Systems, 14(8), 2006.
[11]
J. Groote, M. Sellink. Conﬂuence for process veriﬁcation. Theoretical
Computer Science 170(1–2):47–81, 1996.
[12]
K. Honda and M. Tokoro. On asynchronous communication semantics.
In Object-based concurrent computing, SLNCS 612, 1992.
[13]
K. Honda and N. Yoshida. On reduction-based process semantics. Theo-
retical Computer Science, 151(2):437–486, 1995.
[14]
G. Kahn. The semantics of simple language for parallel programming.
IFIP Congress, 1974.
[15]
N. Kobayashi, B. Pierce and D. Turner. Linearity and the π-calculus.
ACM Transactions on Programming Languages and Systems (TOPLAS),
21(5), 1999.
[16]
L. Mandel and M. Pouzet. ReactiveML, a reactive extension to ML. In
Proc. ACM Principles and Practice of Declarative Programming, pp. 82–93,
2005.
[17]
R. Milner. Communication and Concurrency. Prentice-Hall, 1989.
[18]
R. Milner, J. Parrow and D. Walker. A calculus of mobile processes,
parts 1–2. Information and Computation, 100(1):1–77, 1992.
[19]
M. Newman. On theories with a combinatorial deﬁnition of equivalence.
Annals of Mathematics, 43(2):223–243, 1942.
[20]
A. Philippou and D. Walker. On conﬂuence in the π-calculus. In Proc.
ICALP, pp. 314–324, SLNCS 1256, 1997.
[21]
V. Saraswat, R. Jagadeesan and V. Gupta. Timed default concurrent
constraint programming. Journal of Symbolic Computation, 22(5,6) 475–
520, 1996.
[22]
M. Serrano, F. Boussinot and B. Serpette. Scheme fair threads. In Proc.
ACM Principles and Practice of Declarative Programming, pp. 203–214,
2004.
[23]
D. Sangiorgi and D. Walker. The π-calculus. Cambridge University
Press, 2001.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
19
A.1 Basic properties of labelled bisimulation
We collect some basic properties of the notion of labelled bisimulation.
First, we consider a standard variation of Deﬁnition 1.3 of bisimulation
where transitions are weak on both sides of the bisimulation game.
Deﬁnition
1.20
(w-bisimulation)
A symmetric relation R on
programs is a w-bisimulation if
P R Q,
P
α⇒P ′,
bn(α) ∩fn(Q) = ∅
∃Q′ ( Q
α⇒Q′,
P ′ R Q′ )
We denote with ≈w the largest w-bisimulation.
With respect to this modiﬁed deﬁnition we introduce the usual notion
of bisimulation up to bisimulation.8
Deﬁnition 1.21 (w-bisimulation up to w-bisimulation) A symmet-
ric relation R on programs is a w-bisimulation up to w-bisimulation if
P R Q,
P
α⇒P ′,
bn(α) ∩fn(Q) = ∅
∃Q′ ( Q
α⇒Q′,
P ′ ≈w ◦R ◦≈w Q′ )
We denote with ≈w the largest w-bisimulation.
Proposition 1.22
(1) The relation ≈is an equivalence relation.
(2) The relations ≈and ≈w coincide.
(3) If R is a w-bisimulation up to w-bisimulation then R ⊆≈w.
Proof (1) The identity relation is a labelled bisimulation and the union
of symmetric relations is symmetric. To check transitivity, we prove that
≈◦≈is a labelled bisimulation by standard diagram chasing.
(2) By deﬁnition a w-bisimulation is a labelled bisimulation, therefore
≈w⊆≈. To show the other inclusion, prove that ≈is a w-bisimulation
again by a standard diagram chasing.
(3)
First note that by (1) and (2), it follows that the relation ≈w
is transitive. Then one shows that if R is a w-bisimulation up to w-
bisimulation then the relation ≈w ◦R ◦≈w is a w-bisimulation.
8 We recall that it is important that this notion is deﬁned with respect to w-
bisimulation. Indeed, proposition 1.22(3) below fails if w-bisimulation is replaced
by bisimulation.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

20
R. M. Amadio and M. Dogguy
A.1.1 Structural equivalence
In the diagram chasing arguments, it will be convenient to consider
programs up to a notion of ‘structural equivalence’. This is the least
equivalence relation ≡such that (1) ≡is preserved by static contexts, (2)
parallel composition is associative and commutative, (3) νs (P | Q) ≡
νs P | Q if s /∈fn(Q), (4) sv | sv ≡sv, and (5) se ≡sv if e ⇓v. One
can check for the diﬀerent labelled transition systems we consider that
equivalent programs generate exactly the same transitions and that the
programs to which they reduce are again equivalent.
A.2 Proof of Theorem 1.5
The theorem follows directly from the following Lemma 1.23(4).
Lemma 1.23
(1) If P1 ≈P2 and σ is an injective renaming then σP1 ≈σP2.
(2) The relation ≈is reﬂexive and transitive.
(3) If P1 ≈P2 then (P1 | sv) ≈(P2 | sv).
(4) If P1 ≈P2 then νs P1 ≈νs P2 and (P1 | Q) ≈(P2 | Q).
Proof (1), (2) Standard arguments.
(3) Let R′ = {((P | sv), (Q | sv)) | P ≈Q} and R = R′∪≈. We show
that R is a bisimulation. Suppose (P | sv)
α−→· and P ≈Q. There are
two interesting cases to consider.
(α = τ) Suppose (P | sv)
τ−→(P ′ | sv) because P
s?v
−−→P ′. By deﬁnition
of the lts, we have that P
sv
−→(P | sv)
τ−→(P ′ | sv). By deﬁnition of
bisimulation, Q
sv
⇒(Q′′ | sv)
τ⇒(Q′ | sv) and (P ′ | sv) ≈(Q′ | sv). We
conclude, by noticing that then (Q | sv)
τ⇒(Q′ | sv).
(α = N) Suppose (P | sv)
N
−→P ′. Notice that P
sv
−→(P | sv). Hence:
Q
sv
⇒(Q′′ | sv)
τ⇒(Q′′′ | sv)
N
−→Q′,
(P | sv) ≈(Q′′ | sv) ≈(Q′′′ | sv),
and
P ′ ≈Q′ .
Then (Q | sv)
N⇒Q′.
(4) We show that R = {(νt (P1 | Q), νt (P2 | Q)) | P1 ≈P2}∪≈is a
labelled bisimulation up to the structural equivalence ≡.
(τ) Suppose νt (P1 | Q)
τ−→·. This may happen because either P1 or
Q perform a τ action or because P1 and Q synchronize. We analyse the
various situations.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
21
(τ)[1] Suppose Q
τ−→Q′. Then νt (P2 | Q)
τ−→νt (P2 | Q′) and we can
conclude.
(τ)[2] Suppose P1
τ−→P ′
1. Then P2
τ⇒P ′
2 and P ′
1 ≈P ′
2. So νt (P2 | Q)
τ⇒
νt (P ′
2 | Q) and we can conclude.
(τ)[3] Suppose P1
s?v
−−→P ′
1 and Q
νt′ sv
−−−−→Q′. This means Q ≡νt′ (sv |
Q′′) and Q′ ≡(sv | Q′′). By (3), (P1 | sv) ≈(P2 | sv). Moreover,
(P1 | sv)
τ−→(P ′
1 | sv). Therefore, (P2 | sv)
τ⇒(P ′
2 | sv) and (P ′
1 |
sv) ≈(P ′
2 | sv). Then we notice that the transition νt (P1 | Q)
τ−→· ≡
νt, t′ ((P ′
1 | sv) | Q′′) is matched by the transition νt (P2 | Q)
τ−→· ≡
νt, t′ ((P ′
2 | sv) | Q′′).
(τ)[4]
Suppose P1
νt′ sv
−−−−→P ′
1 and Q
s?v
−−→Q′. Then P2
νt′ sv
⇒
P ′
2 and
P ′
1 ≈P ′
2. And we conclude noticing that νt (P2 | Q)
τ⇒νt, t′ (P ′
2 | Q′).
(out) Suppose νt (P1 | Q)
νt′ sv
−−−−→·. Also assume t = t1, t2 and t′ =
t1, t3 up to reordering so that the emission extrudes exactly the names
t1 among the names in t. We have two subcases depending which compo-
nent performs the action.
(out)[1] Suppose Q
νt3 sv
−−−−→Q′. Then νt (P2 | Q)
νt′ sv
−−−−→νt2 (P2 | Q′)
and we can conclude.
(out)[2] Suppose P1
νt3 sv
−−−−→P ′
1. Then P2
νt3 sv
⇒
P ′
2 and P ′
1 ≈P ′
2. Hence
νt (P2 | Q)
νt′ sv
⇒
νt2 (P ′
2 | Q) and we can conclude.
(in) It is enough to notice that, modulo renaming, νt (Pi | Q) | sv ≡
νt ((Pi | sv) | Q) and recall that by (3), (P1 | sv) ≈(P2 | sv).
(N) Suppose νt (P1 | Q) ↓. Up to structural equivalence, we can express
Q as νtQ (SQ | IQ) where SQ is the parallel composition of emissions
and IQ is the parallel composition of receptions. Thus we have: νt (P1 |
Q) ≡νt, tQ (P1 | SQ | IQ), and νt (P2 | Q) ≡νt, tQ (P2 | SQ | IQ)
assuming {tQ} ∩fn(Pi) = ∅for i = 1, 2.
If νt (P1 | Q)
N
−→P then P ≡νt, tQ (P ′′
1 | Q′) where in particular,
we have that (P1 | SQ) ↓and (P1 | SQ)
N
−→(P ′
1 | 0).
By the hypothesis P1 ≈P2, and by deﬁnition of bisimulation we derive
that: (i) (P2 | SQ)
τ⇒(P ′′
2 | SQ), (ii) (P ′′
2 | SQ) ↓, (iii) (P ′′
2 | SQ)
N
−→
(P ′
2 | 0), (iv) (P1 | SQ) ≈(P ′′
2 | SQ), and (v) (P ′
1 | 0) ≈(P ′
2 | 0).
Because (P1 | SQ) and (P ′′
2 | SQ) are suspended and bisimilar, the two
programs must commit (cf. Deﬁnition 1.7) on the same signal names and
moreover on each signal name they must emit the same set of values up
to renaming of bound names. It follows that the program νt, tQ (P ′′
2 |
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

22
R. M. Amadio and M. Dogguy
SQ | IQ) is suspended. The only possibility for an internal transition is
that an emission in P ′′
2 enables a reception in IQ but this contradicts
the hypothesis that νt, tQ (P1 | SQ | IQ) is suspended. Moreover, (P ′′
2 |
SQ | IQ)
N
−→(P ′
2 | 0 | Q′).
Therefore, we have that
νt (P2 | Q) ≡νt, tQ (P2 | SQ | IQ)
τ⇒νt, tQ (P ′′
2 | SQ | IQ),
νt, tQ (P ′′
2 | SQ | IQ) ↓, and νt, tQ (P ′′
2 | SQ | IQ)
N
−→νt, tQ (P ′
2 |
0 | Q′). Now νt, tQ (P1 | SQ | IQ) R νt, tQ (P ′′
2 | SQ | IQ) because
(P1 | SQ) ≈(P ′′
2 | SQ) and νt, tQ (P ′
1 | Q′) R νt, tQ (P ′
2 | Q′) because
P ′
1 ≈P ′
2.
A.3 Proof of Theorem 1.10
We start with the labelled transition system deﬁned in Table 1.1 and the
notion of bisimulation in Deﬁnition 1.3. In Table 1.2, we incrementally
modify the labelled transition system and/or the conditions in the
bisimulation game. This leads to three equivalent characterizations of
the notion of bisimulation. We prove this fact step by step.
Lemma 1.24 The bisimulation ≈coincides with the bisimulation ≈1.
Proof The only diﬀerence here is in the rule (inaux), the bisimulation
conditions being the same. Now this rule produces an action s?v and the
latter is an auxiliary action that is used to produce the relevant action
τ thanks to the rule (synch). A simple instance of the diﬀerence follows.
Suppose P = se | s(x).Q, K and e ⇓v. Then:
P
τ−→se | [v/x]Q = P ′ and P
τ−→1 se | ([v/x]Q | sv) = P ′′ .
In the Sπ-calculus, we do not distinguish the situations where the
same value is emitted once or more times within the same instant. In
particular, P ′ and P ′′ are structurally equivalent (cf. Section A.1.1).
Next, we focus on the relationships between the labelled transitions
systems
act
−−→1 and
act
−−→2. In
act
−−→2, the rule (in) is removed and in the
rule (inaux), the label s?v is replaced by the label sv (hence the auxiliary
action s?v is not used in this labelled transition system).
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
23
Lemma 1.25 (1) If P
act
−−→1 P ′ and act ̸= sv then P
act′
−−→2 P ′ where
act′ = sv if act = s?v, and act′ = act otherwise.
(2) If P
act
−−→2 P ′ then P
act′
−−→1 P ′ where act′ = s?v if act = sv, and
act′ = act otherwise.
We also notice that 1-bisimulation is preserved by parallel composition
with an emission; the proof is similar to the one of Lemma 1.23(3).
Lemma 1.26 If P ≈1 Q then (P | sv) ≈1 (Q | sv).
Lemma 1.27 The bisimulation ≈1 coincides with the bisimulation ≈2.
Proof (≈1⊆≈2) We check that ≈1 is a 2-bisimulation. If α = sv then we
apply Lemma 1.26. Otherwise, suppose α ̸= sv, P ≈1 Q, and P
α−→2 P ′.
By Lemma 1.25(2), P
α−→1 P ′. By deﬁnition of 1-bisimulation, ∃Q′ Q
α
⇒1
Q′, P ′ ≈1 Q′. By Lemma 1.25(1), Q
α
⇒2 Q′.
(≈2⊆≈1) We check that ≈2 is a 1-bisimulation. If α = sv and P
sv
−→1
(P | sv) then by deﬁnition of the lts, Q
sv
−→1 (Q | sv). Moreover, by
deﬁnition of 2-bisimulation, (P | sv) ≈2 (Q | sv). Otherwise, suppose
α ̸= sv, P ≈2 Q, and P
α−→1 P ′. By Lemma 1.25(1), P
α−→2 P ′. By
deﬁnition of 2-bisimulation, ∃Q′ Q
α
⇒2 Q′, P ′ ≈2 Q′. By Lemma 1.25(2),
Q
α
⇒1 Q′.
Next we move to a comparison of 2 and 3 bisimulations. Note that
both deﬁnitions share the same lts denoted with
α−→2. First we remark
the following.
Lemma 1.28 (1)
If P ≈2 Q and P
N
−→P ′ then ∃Q′, Q′′
( Q
τ
⇒2
Q′′, Q′′
N
−→Q′, P ≈2 Q′′, P ′ ≈2 Q′ ).
(2) If P ≈3 Q then (P | sv) ≈3 (Q | sv).
Proof (1) If P
N
−→P ′ then P cannot perform τ moves. Thus if P ≈2 Q
and Q
τ
⇒2 Q′′ then necessarily P ≈2 Q′′.
(2)
Again we follow the proof of Lemma 1.23(3). Let R′ = {((P |
sv), (Q | sv)) | P ≈3 Q} and R = R′∪≈3. We show that R is a
3-bisimulation. Suppose (P | sv)
α−→1 · and P ≈3 Q. There are two
interesting cases to consider.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

24
R. M. Amadio and M. Dogguy
(α = τ) Suppose (P | sv)
τ−→2 (P ′ | sv) because P
sv
−→2 P ′. By deﬁnition
of 3-bisimulation, either (i) Q
sv
⇒2 Q′ and P ′ ≈3 Q′ or (ii) Q
τ
⇒2 Q′ and
P ′ ≈3 (Q′ | sv). In case (i), (Q | sv)
τ⇒(Q′ | sv) and we notice that
((P ′ | sv), (Q′ | sv)) ∈R. In case (ii), (Q | sv)
τ⇒(Q′ | sv) and we notice
that (P ′ | sv, (Q′ | sv) | sv) ∈R and (Q′ | sv) | sv ≡(Q′ | sv).
(α = N) Suppose ((P | sv) | S)
N
−→P ′. By deﬁnition of 3-bisimulation,
taking S′ = (sv | S) (Q | S′)
τ⇒Q′′
N
−→Q′, (P | S′) ≈3 Q′′, and
P ′ ≈3 Q′.
Lemma 1.29 The bisimulation ≈2 coincides with the bisimulation ≈3.
Proof
(≈2⊆≈3)
We show that ≈2 is a 3-bisimulation. We look ﬁrst
at the condition for the input. Suppose P ≈2 Q and P
sv
−→2 P ′. By
deﬁnition of 2-bisimulation, (P | sv) ≈2 (Q | sv). Also (P | sv)
τ−→2
(P ′ | sv) ≡P ′. By deﬁnition of 2-bisimulation, (Q | sv)
τ⇒(Q′ | sv) and
P ′ ≡(P ′ | sv) ≈2 (Q′ | sv). Two cases may arise.
(1)
If Q
sv
⇒Q′ then Q′ | sv ≡Q′ and we satisfy the ﬁrst case of the
input condition for 3-bisimulation.
(2) If Q
τ⇒Q′ then, up to structural equivalence, we satisfy the second
case of the input condition for 3-bisimulation.
Next we consider the condition for the end of the instant. Suppose P ≈2
Q, S = s1v1 | · · · | snvn, and (P | S)
N
−→2 P ′. By condition (Inp), (P |
S) ≈2 (Q | S). Then, by Lemma 1.28(1), the condition of 3-bisimulation
is entailed by the corresponding condition for 2-bisimulation applied to
(P | S) and (Q | S).
(≈3⊆≈2)
We show that ≈3 is a 2-bisimulation. The condition (Inp)
holds because of Lemma 1.28(2). The condition of 2-bisimulation for the
end of the instant is a special case of the condition for 3-bisimulation
where we take S empty.
A.4 Proof of Theorem 1.18 and Proposition 1.19
First, relying on proposition 1.22(3), one can repeat the proof in [17]
that conﬂuence implies τ-inertness and determinacy.
Proposition 1.30 If a program is conﬂuent then it is τ-inert and
determinate.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
25
Proof
Let S = {(P, P ′) | P conﬂuent and P
τ⇒P ′} and deﬁne R =
S ∪S−1. We show that R is a w-bisimulation up to w-bisimulation (cf.
Lemma 1.22(3)). Clearly R is symmetric. Then suppose P conﬂuent and
P
τ⇒Q (the case where Q reduces to P is symmetric). If Q
α⇒Q1 then
P
α⇒Q1 and Q1 R Q1. On the other hand, if P
α⇒P1 then by conﬂuence
there are P2, Q1 such that P1
τ⇒P2, Q
α⇒Q1, and P2 ≈Q1. Thus
P1 R ◦≈Q1.
Therefore if P is conﬂuent and P
τ⇒P ′ then P ≈P ′. Also recall that
if Q is a derivative of P then Q is conﬂuent. Thus we can conclude that
if P is conﬂuent then it is τ-inert.
Next, we show that:
P1 ≈P2,
P1
α⇒P3,
P2
α⇒P4
P3 ≈P4
.
By deﬁnition of bisimulation, ∃P5 ( P2
α⇒P5, P3 ≈P5 ). By conﬂuence,
∃P6, P7 ( P5
τ⇒P6, P4
τ⇒P7, P6 ≈P7 ). By τ-inertness and transitivity,
P3 ≈P4.
Finally, we can iterate this observation to conclude that if P
α1
⇒· · ·
αn
⇒
P1 and P
α1
⇒· · ·
αn
⇒P2 then P1 ≈P2.
We pause to point-out the particular properties of the input and
output actions in the labelled transition system in Table 1.1. It is easily
veriﬁed that if P
νtsv
−−−→P ′ then P ≡νt(sv | P ′′) and P ′ ≡(sv | P ′′).
This entails that in the following Table A.4.1 the cases that involve an
output action are actually general up to structural equivalence.
Note that, up to symmetry (and structural equivalence), the
Table A.4.1 covers all possible commutations of two compatible actions
α, β but the two remaining cases where α = β and α ∈{τ, N}.
Proposition 1.31 If a program is deterministic then it is conﬂuent.
Proof We recall that if P is deterministic then it is τ-inert. Suppose Q
is a derivative of P, α ↓β, Q
α⇒Q1 and Q
β⇒Q2.
If α = β then the deﬁnition of determinacy implies that Q1 ≈Q2. Also
note that α\β = β\α = τ and Qi
τ⇒Qi for i = 1, 2. So the conditions
for conﬂuence are fulﬁlled.
So we may assume α ̸= β and, up to symmetry, we are left with ﬁve
cases corresponding to the ﬁve situations considered in Table A.4.1.
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

26
R. M. Amadio and M. Dogguy
Table A.4.1. Input–output commutations.
(in −τ)
P
sv
−→(P | sv),
P
τ−→P ′
(P | sv)
τ−→(P ′ | sv),
P ′
sv
−→(P ′ | sv)
(in −in)
P
sv
−→(P | sv),
P
s′v′
−−→(P | s′v′)
(P | sv)
s′v′
−−→(P | sv) | s′v′,
(P | s′v′)
sv
−→(P | s′v′) | sv,
(P | sv) | s′v′ ≡(P | s′v′) | sv
(out −τ)
νt(sv | P)
νt sv
−−−→(sv | P),
νt(sv | P)
τ−→νt(sv | P ′)
(sv | P)
τ−→(sv | P ′),
νt(sv | P ′)
νt sv
−−−→(sv | P ′)
(out −in)
νt(sv | P)
νt sv
−−−→(sv | P),
νt(sv | P)
s′v′
−−→νt(sv | P) | s′v′
(sv | P)
s′v′
−−→(sv | P) | s′v′,
νt(sv | P) | s′v′
νt sv
−−−→(sv | P) | s′v′
(out −out)
νt(s1v1 | s2v2 | P)
νt1 s1v1
−−−−−−→νt\t1 (s1v1 | s2v2 | P),
νt(s1v1 | s2v2 | P)
νt2 s2v2
−−−−−−→νt\t2 (s1v1 | s2v2 | P)
νt\t1 (s1v1 | s2v2 | P)
νt2\t1 s2v2
−−−−−−−−→(s1v1 | s2v2 | P),
νt\t2 (s1v1 | s2v2 | P)
νt1\t2 s2v2
−−−−−−−−→(s1v1 | s2v2 | P)
In the two cases where β = τ we have that Q ≈Q2 by τ-inertness.
Thus, by bisimulation Q2
α⇒Q3 and Q1 ≈Q3. Now α\τ = α, τ\α = τ,
and Q1
τ⇒Q1. Hence the conditions for conﬂuence are fulﬁlled.
We are left with three cases where α and β are distinct input or output
actions. By using τ-inertness, we can focus on the case where Q
α⇒Q1
and Q
β−→Q′
2
τ⇒Q2. Now, by iterating the commutations in Table A.4.1,
we can prove that:
Q (
τ−→)n Q′
1,
n ≥1,
Q
β−→Q′
2
∃Q′′
2 ( Q′
1
β−→Q′′
2,
Q′
2 (
τ−→)n Q′′
2 )
.
So we are actually reduced to consider the situation where Q
α−→Q′
1
τ⇒
Q1 and Q
β−→Q′
2
τ⇒Q2. But then by Table A.4.1, we have: Q′
1
β\α
−−→Q3,
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

Determinacy in a synchronous π-calculus
27
Q′
2
α\β
−−→Q4, and Q3 ≡Q4. Then using τ-inertness and bisimulation, it
is easy to close the diagram.
This concludes the proof of the ﬁrst part of Theorem 1.18(1). To derive
the second part, we rely on the following fact due to [11].
Fact 1.32 ([11]) If a program is reactive and locally conﬂuent then it
is conﬂuent.
Thus to derive the second part of Theorem 1.18(2) is enough to prove
this fact.
Proposition 1.33 A program is locally conﬂuent if (and only if) for all
its derivatives Q:
Q
α−→Q1,
Q
α−→Q2,
α ∈{τ, N}
Q1
τ⇒Q3
Q2
τ⇒Q4
Q3 ≈Q4
Proof
The stated condition is a special case of local conﬂuence thus
it is a necessary condition. To show that it is suﬃcient to entail local
conﬂuence, it is enough to appeal again to Table A.4.1 (same argument
given at the end of the proof of Proposition 1.31).
Proof of Proposition 1.19
Proof
Say that P is strong conﬂuent if it satisﬁes the hypotheses of
Proposition 1.19.
Let S = {(P, Q) | P strong conﬂuent and (P ≡Q or P
τ−→Q)}.
Let R = S ∪S−1. We show that R is a bisimulation. Hence strong
conﬂuence entails τ-inertness. Note that if P
α−→Pi, for i = 1, 2, and α
is either an input or an output action then P1 ≡P2. By Table A.4.1 and
diagram chasing, we show that if P is strong conﬂuent and P
α⇒Pi, for
i = 1, 2, then P1 ≈P2. This suﬃces to show that P is determinate (and
conﬂuent).
https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

https://doi.org/10.1017/CBO9780511770524.002 Published online by Cambridge University Press

