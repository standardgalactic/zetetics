University of Alberta 
DESIGN AND IMPLEMENTATION 
OF DIGIT-SERIAL 
ONLINE MULTIPLY-ACCUMULATE 
ARITHMETIC 
OPERATIONS 
William Natter O 
A thesis submitted to the Faculty of Graduate Studies and Research in partial m e n t  
of the requirements for the degree of Master of Science. 
Department of Department of Electricd and Computer Engineering 
b o n t o n ,  Alberta 
spring 2001 

National Library 
Ml ,
,
,
d
a
 
Bibliothèque nationaie 
du Canada 
A uisitions and 
Acquisitions et 
B&qraphii Secvices 
saNices bibliographiques 
305 Wellington Street 
395, nie Wertington 
ûttawa ON K1A ON4 
ûiîaw8ON K 1 A W  
Canada 
CaMda 
The author has granted a non- 
exclusive licence allowing the 
National Li'brary of Canada to 
reproduce, loan, distnbute or seIl 
copies of this thesis in microform, 
paper or electronic formats. 
The author retains ownershrp of the 
copyright in this thesis. Neither the 
thesis nor substantial extracts fiom it 
may be printed or otherwise 
reproduced without the author's 
permission. 
L'auteur a accordé une licence non 
exclusive permettant à la 
Bibliothèque nationale du Canada de 
reproduire, prêter, distribuer ou 
vendre des copies de cette thèse sous 
la forme de microfiche/nlm, de 
reproduction sur papier ou sur format 
électronique. 
L'auteur conserve la propriété du 
droit d'auteur qui protège cette thèse. 
Ni la thèse ni des extraits substantiels 
de celle-ci ne doivent ê e  imprimés 
ou autrement reproduits sans son 
autorisation. 

To my wife, and both our families. 

Abstract 
This thesis is concemed with the combination of the online and digit-seriai arithmetic tech- 
niques for the design, development, and hardware implementation of algorithms for mui- 
tiplication and multiply-accumulate arithmetic operations. The online technique processes 
digital signah as generat ed and consumeci by curent practical analog-to-digi tai and digit al- 
to-analog converters. The digit-serial technique permits a trade-off between speed and 
area in a corresponding hardware implementation, and is extended to dynamically chang- 
ing wordlengths (with small hardware overhead). Multiplication and mdtiply-accumulate 
operations are perf'ormed as successive additions of partial operat ion updates, justifying 
the use of (redundant) ordinary signed-digit nuxnber systems where the addition archi- 
tecture delays can be made independent of the wordlengtl of the inputs. Emphasis is 
placed on the signed-binary number system, as it is closest to the m e n t  practicai number 
s yst ems (signed-magnit ude and two's complement ) . Relat ionships between number sys- 
tems are established to subsequently exploit their addition scheme similarities and d o w  
the determination of the corresponding fastest and smallest hardware implementations for 
the signed-binary and binary carry-save number systems. A generic online algorithm for 
multiply-sccumulate operation is developed so as to allow its modification into an dg* 
rithm for inner product by the mere change of the computation of a single variable (a 
partial operation update) , the other variables being operation-independent . Consequent ly, 
considerable design time savings are achieved by sharing the same core element for nu- 
mesous different arithmetic operations. The feasibility of a re-pipelined online digit-serial 
signed-binary multiplication algorithm is established by employing the IEEE 754 SB RNE 
rounding technique, and compares it to an exieting re-pipeiined least-signifiant-digit- (LSD- 
) fht digit-serial taro's complement multiplication algorithm employing the same rounding 
technique. A simulation of the corresponding FPGA hardware implementation confirms the 
correct funaionality of the algorithm. Parameterized gatelevel area and delay estimates of 
correspondhg ASIC hardware implementations are given. Moreover, an online bit-pardel 
signed-binary algorithm for multiply-accumulate operation employing a novel signed-binary 

to minimally redundant base4 recoding technique, the IEEE 754 SB RNE roundhg tech- 
nique, and a novel overflow detection and correction technique is developed. The resulting 
algorithm is subsequently compared to an existing LSD-first bit-pardel signecl-binary algo- 
rithm for multiply-accumulate operation employing an existing signed-binary to minimnlly 
redundant base4 recoding technique and the IEEE 754 SB RNE rounding technique. A 
simulation of FPG A hardware implementation again confirms the correct funct ionality of 
the algorithm. 

Acknowledgement s 
F h t ,  let me thank my wife, our families, and our close fnends for supporting me during 
the journey coming to an end with this thesis, in particula. for proof-reading part of it. 
Neil definitely deserves my humble gratitude for accepting to proof-read the thesis when 
he had so much to do. 
The writing of this thesis would not have been possible without NSERC and Micronet 
grants, obtained through the hard work of numerous students in the research group. In 
particular, Vihwas Rao has initiated the work on which this thesis is based. 
Last, but far fiom being least, 1 would iike to acknowledge the help, support, and 
guidance of my supervisor, Dr Nowrouzian. 

Contents 
Introduction 
1 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
1.1 Digital Signal Processing 
1 
. . . . . . . . . . . . . . . . . . . .  
1.2 Arithmetic for Digital Signal Processing 
3 
. . . . . . . . . . . . . . . . . . . . . . . . . . .  
1.3 Data Piocessing Techniques 
5 
. . . . . . . . . . . . . . . . .  
1.3.1 The Digit-Serial Arithrnetic Technique 
6 
. . . . . . . . . . . . . . . . . . . . . .  
1.3.2 
Oniine Arithmetic Technique 
7 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
1.4 Open Problems 
8 
. . . . . . . . . . . . . . . . . . . . . . . . . . . .  
1.4.1 Online Processing 
8 
. . . . . . . . . . . . . . . . . . . . . . . .  
1.4.2 Constant-Delay Addition 
9 
. . . . . . . . . . . . . . . . . . . . .  
1.4.3 Digit-Serial Online Operations 
9 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
1.5 Ovewiew of the Thesis 
10 
2 Theoretical Background for High-Speed Digit-Serial Online Arithmetic 
Operations 
12 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
2.1 Introduction 
12 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
2.2 Fixed-Point Arithmetic 
13 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
2.2.1 Introduction 
13 
. . . . . . . . . . . . .  
2.2.2 
Number Representation and Number Systems 
13 
2.2.3 
Similanties Between Addition Schemes in Generalized Signed-D igit 
............................. 
Number Systems 
16 
........................... 
2.3 Data Processbg Techniquee 
20 
................... 
2.3.1 Digit-Serial Arithmetic Technique 
20 
...................... 
2.3.2 
Oniine Arithmetic Technique 
30 

. . . . . . . . . . . . . . . . . . . . . .  
2.4 
High-Speed Signed-Binary Addition 
34 
2.4.1 Redundant Binary Addition Schemes . . . . . . . . . . . . . . . . . .  35 
2.4.2 
Characterization and Equidence of Redundant Binary Addit ion Schemes 38 
2.4.3 Bit-Serial and Digit-Serial Signed-Binary Limited-Carry Addition Ar- 
chitectures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  43 
2.5 ChapterSltmmary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  47 
3 Theoreticai Background for Online Signed-Digit Multiplication and Multiply- 
Accumulate Operations 
3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
3.2 Proposed Algorithm for Signed-Digit Online MAC Operation . . . . . . . .  
3.2.1 
Nomenclature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
3.2.2 
Signeci-Digit Online MAC Algorithm . . . . . . . . . . . . . . . . . .  
3.2.3 Determination of the Parameters of the Algorithm . . . . . . . . . .  
3.3 Algorithm and Building Blocks for High-Speed Signed-Binary Multiplication 
Architectures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
3.3.1 Single-Digit Multiplier and Digit Clearing Unit . . . . . . . . . . . .  
3.3.2 
Signed-Binary t O Minimally Redundant Base4 Recoding Technique 
3.4 Rounding and Overflow Handling in Online Arithmetic Operations . . . . .  
. . . . . . . . . . . . . . . . . . . .  
3.4.1 Rounding of Signed-Binary Words 
3.4.2 
Overfiow Handling in Online Anthmetic Operations . . . . . . . . .  
3.5 Chapter Summary ................................ 
4 Architecture for O nline Signed-Digit Digit-Serial Multiplication 
90 
.................................... 
4.1 Introduction 
90 
4.2 Algorithm for Bit-Serial Signed-Bhary Online Multiplication . . . . . . . .  91 
4.3 Extension to a Digit-Serial Signed-Binary Online Multiply-and-Round Alga- 
rithm . . . . . . . . . . . . . . . . . . * . . . . . . . . . . . . . . . . . . . .  95 
4.4 Architecture for Digit-Serial Signed-Binary Online Multiplication and Round- 
inp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  99 
. . . . . . . . . . . . . . . . . . . . . . .  
4.4.1 
Multiplicand Selection Unit 
101 

. . . . . . . . . . . . . . . . . . . . . . .  
4.4.2 
Online Multiplication Units 
101 
. . . . . . . . . . . . . . . . . . . . . . . . .  
4.4.3 
OnlineRounding Units 
103 
4.5 
Cornputer Simulation Results and Performance Cornparison . . . . . . . . .  104 
. . . . . . . . . . . . . . . . . . . . . . . . . . . .  
4.5.1 
Simulation Results 
104 
4.5.2 
Thmughput Parameterization and Improvement Via Re-Pipelining . 106 
. . . . . . . . . . . . . . . . . . . . . . . . . .  
4.5.3 
Area Parameterization 
109 
. . . . . . . . . . . . . . . . . . . . . . . .  
4.5.4 
Performance Cornparisons 
110 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
4.6 
Conclusion 
112 
5 Architecture for Online Signed-Binary Bit-Parallel Multiply-Accumulate 
Operation 
114 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
5.1 Introduction 
114 
5.2 Bit-Parallel Signed-Binary MAC Algorithm Employing SB to MRB4 Recoding 1 l5 
5.3 Architecture for MAC Operat ion Employing Signed-Blnary Multiplier Re 
coding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  122 
5.3.1 Signed-Binary to Minimally Redundant Base4 Recoders . . . . . . .  122 
. . . . . . . . . . . . . . . . . . . . . . .  
5.3.2 
Online Multiplication Units 
123 
. . . . . . . . . . . . . . . .  
5.3.3 
Rounding and Overflow Correction Unit 
124 
. . . . . . . . .  
5.4 
Cornputer Simulation Results and Performance Cornparison 
124 
. . . . . . . . . . . . . . . . . . . . . . . . . . . .  
5.4.1 
Simulation Results 
125 
. . . . . . . . . . . . . . . . . . . . . .  
5.4.2 
Throughput Parameterbation 
127 
. . . . . . . . . . . . . . . . . . . . . . . . . .  
5.4.3 
Area Parameterbation 
127 
................................ 
5.4.4 
Cornparison 
128 
.................................... 
5.5 Conclusion 
130 
6 Conclusion 
131 
. . . . . . . . . . . . . . . . . . . . . . . . . .  
6.1 Eteview of Material Presented 
131 
. . . . . . . . . . . . . . . . . . . . . . . . .  
6.2 Proposeci Areas of E'uture Work 
132 
............................... 
6.3 Concluding Remarks 
134 

A Systematic Enurneration of Redundant Bkiary Addition Schemes 
139 
. . . . . . . . . . . . . . . . . . . . . . .  
A.1 Determination of Set Cardinahies 
139 
A.2 Systematic Determination of the Sets S,. Sa. S,. and SB . . . . . . . . . .  141 
. . . . . . . . . . . . . . . . . . . . . .  
A.2.1 Case 1: 1s.. 1 = 3  and 1s. 1 = 2  
142 
. . . . . . . . . . . . . . . . . . . . . .  
A.2.2 Caae2: !Sc = 2  and IS, 1 = 3  
143 
A.3 Characterization of Redundant Binary Number Addition Schemes . . . . .  144 
A.4 Equivalence of Redundant Bi- 
Number Addition Schemes . . . . . . . .  145 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
A.5 Conclusion 
150 

List of Figures 
1.1 Typicai DSP System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2 
2.1 4Bit LSD-First Bit-Serial Binary Adder . . . . . . . . . . . . . . . . . . . .  
26 
2.2 
Bit Number in a 4Bit Bit-Serial Data Stream . . . . . . . . . . . . . . . . .  27 
2.3 
4Bit LSD-First Digit-SMal Binary Adder (D = 3) . . . . . . . . . . . . . .  28 
2.4 
Bit Number in a 4Bit Digit-Serid Data Stream (D = 3) . . . . . . . . . . .  28 
2.5 
Limited Carry Adder Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . .  38 
. . . . . . . . . .  
2.6 
Architecture for Bit-Serid Onhe Limited-Carry Addition 
44 
2.7 
Architecture for Digit-Serial Online Limited-Carry Addition . . . . . . . . .  47 
. . . . . .  
3.1 BoundonP,asafuneti0nofdandi,for/3=2~~=4and~~=1 
56 
. . . . . . . . .  
3.2 Three-Level Signed-Binary to Radix-4 Digit Set Conversion 
66 
Architecture for Digit-Seriai Online Multiply-and-Round Operation . . . . .  
Architecture of sn Online Multiplication Unit . . . . . . . . . . . . . . . . .  
Architecture of an Online Rounding Unit . . . . . . . . . . . . . . . . . . .  
Simulation Results for D = 2 and Wa = Wb = 8 . . . . . . . . . . . . . . . .  
Simulation Results for D = 3 and W 
a = Wb = 8 . . . . . . . . . . . . . . . .  
Re-Pipelineci Architecture for MAC Operation and IEEE 754 RNE Rounding. 
withWa=5andD=4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
Throughput Ve~us 
Digit-Size of Proposed and M i n g  Digit-Serial Multi- 
plication Architectures .............................. 
Log of Efficiency Versus Digit-Size of Proposeci and EiSeting Digit-Serial 
........................... 
Multiplication Architectures 

5.1 kchitecture for Bit-Paralle1 Orrline Mult iply- Accumulate Operation Em- 
. . . . . . . . . . . . . . . . . . . . . . . . .  
ploying SB to MRB4 Recoding 
123 
. . . . . . . . . . . . . . . . . . . . . .  
5.2 Simulation Results for W a = Wb = 8 
126 
5.3 Throughput Versus Wordlength of Proposed and Existhg Bit-Pardel MAC 
. . . . . . . . . . . . . . . . . . . . .  
. . . . . . . . . . . .  
Architectures 
.. 
129 
5.4 Efficiency V'us Wordlength of Proposed and Existing Bit-Pardel MAC 
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  
Architectures 
129 


List of Symbols 
AID 
ASIC 
BCS 
BS 
BSD 
Dl* 
DFG 
DS 
DSP 
FA 
FPGA 
GSD 
analog-tedigit al 
application-specific integrated circuit 
binary carry-save 
bit-serial 
balanced (ordinary) signed-digit 
digital- teanslog converter 
data-flow graph 
digit-serial 
digital signal processing/processor 
full adder 
field-programmable gatesrtay 
generalized signed-digit 
GSDNS generalized signed-digit number system 
IEEE 
Imtitute of Electrid and Electrodcs Engineers 
LSD 
least significant digit 
MAC 
multiply-accumulate (arithmetic operation) 
MRB4 
minimally redundant base4 
MSD 
most significant digit 
OSD 
oràinary (balancecl) signed-digit 

OSDNS ordinary signed-digit number system 
RNE 
round to nemest / even 
RNU 
round to nearest/upper 
SB 
signed- binary 
TC 
two's complement 
USD 
unbdanced signed-digit 
USDNS unbalanced signed-digit number system 
VHDL 
Very large scale integrated circuit Hardware Description Language 
A 
multiplicand word 
ai 
multiplicand digit of index i 
B 
multiplier word 
BP 
partially formed multiplier word at iteration p 
bi 
multiplier digit of index i 
C 
addend word 
CP 
partially formed addend word at iteration p 
ci 
addend digit of index i 
1% 
attainable upper limitl bound of a representation 
PP 
ofHine partial operation update word at iteration p 
5 
online partial operation result word at iteration p 
- 
r~ 
truncated (to its 7 MSDs) online partial operation result word at iteration p 
5p.i 
online partial operation result digit of index i at iteration p 
R~ 
off-Iine operation r d t  word at iteration p 
E~ 
online operation r d t  word at iteration p 
Fi 
online partial operation result digit of index i 

radix/base of a number representation/system 
weight of a digit of index i 
internai wordlength (of pp) 
offset parameter 
latency of an online operation 
onhe error at iteration p 
redundancy index (OSD number system) 
iteration number 
addition 
logic OR operation 
addition of sets 
multiplication of a set by a scalar 
XOR logic operation 
AND logic operation 
NOT logic operation 
set of positive integers 
set of rational 
set of reals 
equivalence rehtionship between addit ions 
set of signed integers 
set of negative integem 
set of positive integers 

Chapter 1 
Introduction 
1.1 Digital Signal Processing 
Most living creatures need to communicate in order to survive. Signals, which are sounds, 
gestures, or objects, convey the necessary pieces of information to perform communication. 
The first man-made devices using electrical signals to convey information are the tele- 
graph (invented by Morse in lm), and the telephone (invented by Bell in 1876). The 
fundamental dlnerence between telegraph and telephone is the type of signals they handle. 
To send a message by telegraph, one neeh to mite it on a sheet of paper. Then, a tele 
grapher translates ewry letter into Morse code. A letter is represented by a sequence of 
two symbols, which is called a binary representation of the Ietter. Then, the symbols are 
transmitteà in sequence over s wire as short and long impulses of electricity. The message 
is decoded on the other side by another telegrapher and handed over to the recipient of 
the message or forwasded to another place if necessary. By contrast, to send a message 
by telephone one spesks in a mouthpiece which translates the air vibrations into electrical 
signals. Of course, these si& 
are not a binary representation of the message. The elec- 
t n d  signals propagate through a wire, and are trmlated back to air vibrations through 
an ear-piece so that the receiver can hear what was said on the other end. 
In electrid engineering, a signal is represented as an amplitude that varies as a function 
of time. In 0th- words, the domain of a signal is an interval of time, and its range an 
i n t d  of amplitude. An i n t d  ia discrete if it contains only a h i t e  number of values 
(as opposed to a continuous interval). Therefore, tthere are four classes of signals, as Listed 
in Table 1.1. Discretetime discreteamplitude signals are fiequently refmed to as digital, 

Tàble 1.1: Classification of Signals 
I 
1 Continuous Amplitude 1 Disaete Amplitude 1 
Continuous Time 
whereas cont inuous-t ime continuous-amplitude signals are refend to as analog. 
In nature, signals are usually anslog, whereas man-made machines usually generate 
digital signals. Digital signals are handled by digital signal processors. A main impor- 
tant practical advantage of digital processors is their programmability, permitting various 
operations to be performed by using the same processor, and their cost-efEkt iveness. Fortu- 
nately, Nyquist determined that if certain conditions apply, analog signals can be digitized, 
i.e. represented using corresponding digital signals, and recovered pedectly. Several factors 
have contributed to the widespread use of the digital processing of analog and digital data, 
often called digital signal processhg (DSP) . First, the inventions of microprocessors and 
application-specific integrated circuits (ASICs) have permitted the custom design of digital 
signal processors. Second, the ever-decreasing size of silicon-based transistors has made 
possible the doubling of the speed of digital circuits every 18 months, and the reduction of 
their cost, the silicon ares of a digital circuit largely determinhg its cost. 
A typical DSP system is made of analog-t~digital (A/D) 
and digital-ta-analog (DIA) 
converters, and of a digital signsl procesor, as shown in Figure 1.1. The A/D and D/A 
Discret e Time 
Digital Signal 
4 
Figure 1.1: Typicd DSP System 
t emperat ure 
precipitations 
converters perforxn the same kind of operation as the translation of a message into their 
Morse code in the telegraph. The digital signal proceseor performs arithmetic operations, 
which most ofien comprise numerous additions and multiplications. The number of calcu- 
Mons to perform thereby determines the ma;lamum speed at which the DSP system can 
street light 
paycheque 

operate. Moreover, the area of the digital signal processor is a dominant component in the 
cost of the DSP system. Both these factors, speed and area, depend greatly on how the 
addition and multiplication operations are ixnplernented. 
Of particulaz interest is an arithmetic operation capable of multiplying two numben, 
and adding the resuit to a third number. Such an operation can be performed by a multiply- 
add or by a multiply-accumulate (MAC) 
arithmetic operat ion. The multiply-add arithmetic 
operation calculstes the reault and rounds it, whereaa the MAC arithmetic operation cal- 
d a t e s  the ml-precision result. 
Example 1 Let w multiply 0.01 by 0.02. The result às obtained as 0.0002 in a MAC 
arithmetic operation, w h e m  it M munded to 0.00 in c muttiply-add arithmetic opemtion. 
In this way, the use of MAC mithmetic operations is preferable in digital signal processors 
which are sensitive to calculation accmacy. 
Consider a digital signal processor employing only addition and multiplication opera- 
tions. A MAC modularization technique was developed in (Rao, 1996) to modify such a 
processor in order for it to use exclusively MAC arithmetic operations. Therefore, in a 
situation where area is the dominant factor, it is suiûcient to buiid a digital signal processor 
having a single MAC arithmetic operator, and to perform multiplex d the operations onto 
that operator (c.f. the Motorola DSP56002). 
A typical digital signal processor using addition, multiplication, and unit-delays is d e d  
a digital filter. Its primary objective is to selectively attenuste or boost certain fiequency 
componenta of a signal. This is usudy performed by adding weighted present and past 
input and past output samples, where the weights are constant. This corresponds to an 
inner product of a vector of constant weights by a vector of delayed input and output 
samples, which can be transiated to a number of MAC arithmetic operations. 
1.2 Arithmetic for Digital Signal Processing 
Digitd si@ 
are sampled and qwtized maiog si@, 
and are represented at each sample 
time instant by a number. Many different number systems cm be used, where the algebraic 
d u e  of s number is represented by a succession of digits refmed to as a word. The 

mapping fiom word to dgebraic value can be performed by assigning each digit a weight. 
In this way, the dgebraic value is obtained by summing the digit d u e s  dtipiied by their 
corresponding weights. In most number systems, the weights are expresseci as consecutive 
powers of a radix which will be denoted by 
(also retmed to as the base). Therefore, most 
number systems are characterized by their digit set and radix. 
Example 2 The mdiz of the decimal number system is lû, and the digit set U {O, 1,2,3,4,- 
5,6,7,8,9). Cocuider the decimai number 5, which can be represented by the decimal woni 
005io, where 005i0 = O x 102 + O x 10' + 5 x loO. Cowider now the binary number system: 
it hm a radàx 2, and a digit set {O, 1). The decimal number 5 can now be represented in the 
binary number system by 1012, where 1 x 22 + O x 2l+ 1 x 2O = 005io. 
Radix- and digit set-based number systems can be classified into two categories, namely, 
the ked-point and floating-point number systems. In a fixed-point number system, the 
weights have ked values, i.e. the largest weight cm always be made equal to, for example, 
@-l. The digit related to the srnalest weight is d e d  the lest signiscant digit (LSD), 
and 
the digit related to the largest weight is cded the most signifiuuit digit (MSD). 
Moreover, 
the number of digits constituting the word is called the wordlength. In a Boating-point 
number system, the word is split into two components, namely, the fkactiond and exponent 
parts f and e, respectively. The fractional part is a ked-point representation of a number 
N, and the algebraic d u e  of the desired number is obtained by multiplying N by pl which 
is referred to as scaling up by p. The increased range of a floating-point representation 
compared to that of a fixeci-point representation is obtained at the expense of additional 
preeiaion digits. Consequently, floating-point-based calculatione are more prone to accuracy- 
related mors than fixed-point-based caiculations. The fixed-point binary number system 
is the dominant number system in cornputers, mainly because its digit set has only two 
eiements, logic O and logic 1. 
This thesis is concerned with ordinary signed-digit (OSD) number systems, whieh are 
radk-B &cl-point number systems having a digit set {-q, . . . , O,. . . , 
r)) such that [tl 5 
I )  5 
(Avizienis, 1961; Parhami, 1990). These number systems are d e d  redundant, 
because a given dgebraic d u e  may have several different representations. 

Example 3 The signed-bhaty (SB) number system has a mdk 2, and a digit set (1, O, 11, 
where 
repnsents - 1. The decimal number 3 con then be npnzsented either by 0112, where 
O x 22 + 1 x 2' + 1 x 2' = 310, bg 1012, where 1 x 2* + O x 2l - 1 x 2' = 3i0, or even by 
lIlz, whenz 1 x 2' - 1 x 2l+ 1 x 2' = 310. 
In high-speed arithmetic operations, the time required to perform an operation, i.e. 
the delay, must be minimized. Consider the addition of the words A and B of equal 
wordlength, yielding a sum S. If A, B, and S are words expressed in a non-redundant 
number system, then the delay to obtain S is, at best, proportional to the logarithm of the 
common wordlenGb of A and B (Kornerup, 1994). This is rnainly due to the f& that the 
value of the MSD of S depends on the value of the LSDs of A and B, thereby requiring the 
propagation of a cany dong the N1 length of A and B. However, if the number system is 
redundant, then the delay can be made independent of the wordlength of A and B, because 
the value of the MSD is no longer dependent upon the values of all the digits of A and 
B (Avizienis, 1961; Parhami, 1990; Kornerup, 1994). Redundant number system hardware 
implementations exhibit Iarger are= relative to those of non-redundant number systems for 
equivalent operations, mainly because their digit sets contain more values. As a result, the 
absolute areaa of redundant number system hardware implementations have represented a 
hindrance in the past. This hindrance has been overcome with the advent of submicron 
techn010gies. 
In other number systems, such as in the logarithmic, residue, and rational number 
systems (Hw&llg3 1979), the mapping between the word and its dgebraic value takes on 
different forms, but these forms are beyond the scope of this thesis. 
1.3 Data Processing Techniques 
A digital signal must be transmitted as a word h m  
an A/D convarter to a digital signal 
processot, and kom the digital si@ processor to a DIA converter. At a given tirne instant, 
one3 several, or all digits of a word can be transmitted, i.e. in a bit-serial, digit-serial, or bit- 
parallel fashon, respectively. Of course, the bit-serid and bit-pardel fashions are subsumed 
by the digit-serial arithmetic technique. Hoarever, the digit-serial arithmetic technique can 

be derived fiom the bit-serid arithmetic technique. 
Moreover, a bit-serial data stream can be processed, (a) the LSD first, which is the 
conventional arithmetic technique, or (b) the MSD fht, which is the online arithmetic 
technique. The digit-serial and online arithmetic techniques are desdbed in the foliowing. 
1.3.1 The Digit-Serial Arithx.net ic Technique 
Let us consider an architecture having input data streams consisting of successions of words 
having a common wordlength W. By definition, the bit-serial arithmetic technique only 
requires to process one bit at a time (as opposed to W for the bit-parailel arithmetic 
technique). In addition, the number of wùes required for transmission inneases from 1 
to W. Consequently, the bit-serial technique results in smailer processing units (which is 
are8-&&ive), but the bit-parallel technique permits the design of faster xchitectures. The 
speed of an architecture is measured by its throughput, i.e. the number of samples it a n  
pmcess per tirne instant. 
The main principal trade-off in the design of electronic systems involves achieving the 
highest execution speed at the smdest area and the lowest power. The digit-serial arith- 
metic technique proposes that the given architecture rnay process D digits of each of the 
input data streams pet tirne instant, where the digit-size D rnay or rnay not be a divisor 
of W. In this way, a balance can be strudr between the area efficiency of bit-serial systems 
and the speed efEciency of bit-paralle1 systems. It is important to note that the bit-serial 
and bit-pardel arithmetic techniques are special cases of the digit-serial arithmetic for a 
digit-size of 1 and W, respectively. 
Any bit-serial architecture can be transformecl into its unique digit-serial counterpart 
of digit-size D (Parhi, 1991). Then, the bit-serial data stream is sectioned into sets of D 
consecutive digits. Of course, digits from two consecutive words may be present in that 
set. Therefore, an &thmetic operation on digits coming fiom two different words/numbers 
may occur at a given time instant in a digit-serial architecture, but, of course, must not 
inter fere. 

1.3.2 
Online Arithmetic Technique 
Cunent practical A/D and DIA converters generate and consume digits one by one, from 
the MSD fht to the LSD last. Howevei:, in the conventional arithmetic techniques, the 
carry propagates from the LSD first to the MSD last. Therefore, d e s s  operations can 
be performed the MSD Fust, delays due to changes in the flow of digits occur. The online 
arithmetic technique perfom arithmetic operations digit by digit, the MSD first . The result 
of such an operation must be expresseci in a redundant number system' (Owens, 1983). 
Therefore, online arithmetic operations have been seldom used because of the large area in 
the conesponding hardware implementations. 
The ordine arithmetic technique fin& its roots in 1961, when Avizienis introduced the 
notions of signed-digit arithmetic and constaat-delay addition ( Avizienis, 196 1). In 1977, 
Irwin introduced online algorit hms for several ari t hmetic operat ions (Irw in, 1977). In the 
past two decades, the increase in transistor density has permitted the very large scale 
integration of corresponding architectures to take place. As a result, online algorithms have 
gained plenty of interest. The most popular online algorithms perform arithmetic operations 
iteratiwly, the MSD k t .  
Let us consider an algorithm performing an arithmetic operation. The inputs are referred 
to as the operanch, and the output as the remit. Formally speaking, the online property 
can be defined in terms of the input to, or the output from, an arithmetic operation (Owens, 
1981). The algorithm is online with respect to its inputs when at a given iteration p, the 
first p+& 
MSDs of the operands are required for caldation, where & is a smail constant. 
Simila,rly, the algorithm is onliae with respect to its output when, at a given iteration p, 
the first p - kmt MSDs of the result have been generated by the algorithm (Owens, 1981), 
where kat is again a small constant. Finally, the aigorithm is onüne when it is both onüne 
with respect to its inputs and with respect to its output. The constant k, + kat is refened 
to as the lotencg of the online algorithm. The Iatency represents the number of iteratiom 
eiapshg between the anival thne for the input MSD and the departure tirne for the result 
digit having the same weight as the input MSD. It is important to note that, in general, the 
'1f one assames that the r e d t  word is expressed in a non-red~dant number system, then the MSD 
caruiot be output at the k t  
iteration, because it depends on the dues of the LSDs of the inputs. 

weight of the MSD of the resuit is larger than the weight of the MSD of the input, resulting 
in a non-zero latency. 
The flow of digits in online arithmetic operations corresponds to that in current prac- 
tical A/D and DIA converters (&e 
the conventional LSD-first arithmetic operations). 
The resulting advantages are that, (a) the delay due to a change in the flow of digits is 
eliminated, and (b) the LSDs can be discardeci when full-precision computation is not re- 
quired. Then, the result must be expressed in a redundant number system. If redundant 
representations are used both for the input words and the output words, then addition 
within online arithmetic processors can be performed in constant time. 
The hardware implementations of online arithmetic processors require large areas, be- 
cause redundant number systems require Iarger boolean functions which are more difncult 
to develop (Carter and Robertson, 1990; Ercegovac and Lang, 1990; Chow and Robert- 
son, 1978); given the rapid deaease in transistor size, the area becomes less important. 
In online arithmetic operations, the propagation of the carry toward the MSD must be 
stopped. This is accomplished by introducing a latency between the weight of the online 
input operand digit (s) and that of the output result digit. As a result, online algorithms 
resuit in slower paralld architectures than LSD-ht dgorithms for a given number system. 
1.4 Open Problems 
1.4.1 
Online Processing 
Numerous online algorithms performing arithmetic operations, including addition, sub- 
traction, multiplication, division, and multiply-accumulate arithmetic operation (MAC 
arithmetic operation), have been developed (kwin, 1977; Owens, 1981; Invin and Owens, 
1987; Guyot and Kusumaputri, 1991; Brackert et al., 1989; Sips and Lin, 1990; Lapointe 
et al., 1993; McQuillan and McCanny, 1995). The development of such algorithms ie com- 
monly basecl on the function approximation, the immediate eduation, or the recursion- 
based approaches. The function apprmcimation is employed for the approximation of 
complicated functions as polynomiais. T m  Emodd approaches have been d d b e d ,  in 
(Ercegovac, 1984) and in (Sips and Lin, 1990). In (Ercegovsc, 1984), a function d u e  is cal- 
nilated via an equivaent system of hear equations, for which efncient online architectures 

exist. In (Sips and Lin, 1990), an exact fiuiction value is fetched kom a table by using the 
partidy known inputs, and an output digit is estimateci by taking into account the previous 
output digits. These two approaches c m  be employed for any function. The recursion-based 
approach can be employed for any polynomial which includes addition, MAC operation, and 
inner product (Invin, 197% Ercegovac, 1984; Sips and Lin, 1990). 
So far, none of these techniques have separated the mechanism of the online process fiom 
the caiculation of the function under study. In particular, finding an internai mechanism 
common to al1 recursion-based online dgorithms remains an open problem for arithmetic 
operations. The main advantage of such a mechanism would be its applicability to the 
calculation of several diffkrent operations: in the industry, a corresponding hardware imple- 
mentation would be common to a number of arithmetic operations, and design re-use could 
be applied, saving substantial design time and capital. 
1.4.2 Constant-Delay Addition 
In a redundant number system with hrge rsdix value, arithmetic operations require large 
boolean functions which are di&ult tu optimize for hardware impkmentation. As a re- 
sult, the redundant binary system remains the most suitable for hardware implementation. 
Multiplications and MAC operations using redundant-binary number systems are imple- 
mented as nested additions of redundant-bhary numbers. Architectures for constant-delay 
hardware implementations of redundant-binary addition have been reported in (Chow and 
Robertson, 1978; Parhami, 1988; Thornton, 1997). A systematic enmeration of such ar- 
chitectures for redundant-binary addition has not been undertaken. Such an approach may 
result in novel, small, and high-speed hardware implementations. Moreover, interrelation- 
ships between the existing developments of architectures for redundant binary addition may 
be discovered, saving design time. 
1.4.3 
Digit-Sarial Online Operations 
The hardware Unplernentations of architectures for online arithmetic operations often resdt 
in large amast impIying high mst. Therefore, despite their outstanding features (includ- 
h g  MSD-first processing, and l m  latency), online arithmetic operations are seldom used 

in practical applications. However, the digit-serial arithmetic technique, which pennits a 
tradeoff between the speed and area of an architecture for arithmetic operation, has been 
applied to some onluie operations ody for the special case of the digit-size being a divisor 
of the wordlength (Irwin and Owens, 1988). The general digit-serial technique h a  not to 
been applied yet to the development of azchitectures for online MAC arithmetic operations. 
1.5 Overview of the Thesis 
The purpose of this thesis is twofold, namely, (a) to introduce the necessary background for 
the development of architectures for digit-serial online signed-digit arithmetic operations, 
and (b) to develop digit-serial and digit-pardel purely signed-digit multiply-accumulate 
operat ions. 
Chapter 2 is concerned with an introduction to the mathematical framework neces- 
sary for digit-serial online hed-point arithmetic operations, with a t horough description of 
limited-carry addition architectures. Discussions concerning number systems and the digit- 
serial and online arithmetic techniques are given. A simplification of the existing digit-serid 
unfolding algorithm is provided dong with an introduction of a new dynamicaily changing 
wordlength technique. A systematic enumeration of architectures permitting the constant- 
delay addition of redundant binary numbers is presented. This is required for the design of 
high-speed signed-binary MAC operations as nested additions. 
Chapter 3 introduces the necessary background for the development of industry-standard 
multiplication architectures. The development of bit-serid onIine MAC arit hmet ic opera- 
tions is first discussed in detd, leading to the description of the recursion-based online 
mechanism, which ean be used for the dadation of any aithe function. Then, description 
of singledigit signecl-binary multipliers is given, followed by the development of a nowl 
technique for signed-binery to minimally redundant base-4 cowersion. Such a conversion 
permits the design of fsster and s d e r  architectures for MAC arithmetic operations. Also, 
an online signed-binary algorithm is given for IEEE 754 round-to-neazeve, together 
with an onüae aigorithm for signed-digit d
o
w
 handling. 
Chapter 4 develops an algorithm for digit-serial online multiply-and-round arithmetic 
operation for general digit-size and input wordiength values. The aïgorithm employs the 

IEEE 754 RNE industry standard. An architecture for subsequent FPGA or ASIC hazdwaze 
implementation is given, which is re-pipelineci for throughput msximization and proven 
functionally correct through simulation. The throughput and efficiency (throughput per 
unit area) performances of this architecture are compared unfavorably to those of an acisting 
LSD-6rst digit-serial two's complement multiply-and-round operation employing signed- 
binary intermediate partial products. However, the architecture is shown to be viable for 
high-speed applications. 
In Chapter 4, an algorithm is developed for signed-binary pardel o n h e  MAC arith- 
metic operation employing signed-binary to minimally redundant base4 multiplier conver- 
sion, IEEE 754 RNE rounding, and ovedow detection and correction. A corresponding 
architecture for subsequent FPGA or ASIC hardware implementation is given, and proven 
functiondy correct through simulation. The throughput and efficiency figures are corn- 
pared davorably to those of an existing architecture for signed-binary paraiiel LSD-first 
MAC arithmetic operation employing signed-binary to minimaily redundant base4 multi- 
plier conversion and EEE 754 RNE rounding. 

Chapter 2 
Theoretical Background for 
High-Speed Digit-Serial Online 
Arit hmetic Operations 
2.1 Introduction 
Presently, digital signal processing h d s  numerous applications in many areas, such as 
virtual image synthesis, data transmission and reception, and database management. A 
digital signal is seen as thedependent data, and is represented as a sequence of numbers 
(fiequently refmed to as samples), where each sample is represented as a sequence of digits 
arrangeci in a given format. Consequently, digital signai proceseing requirea many arithmetic 
operations, predominAntly additions and multiplications. The performance of an arithmetic 
operation depends heaviiy on the choice of the digit sets, how many digits to process at a 
tirne, and in which order the digits are processeci. 
The present chapter provides the necessary background for the design and develop- 
ment of architectures for onüne arithmetic operationa in general, and for the multiplication 
operation in psrticular. In Section 2.2, the comsponding &ceci-point number represent a- 
tions are diacussed with an emphasis on generaiized signed-digit number representations 
and their properties. Then, the digieserial and online arithmetic techniques are introduced 
in Section 2.3. An imprwed digit-serial unfolding aigorithm and an example of an online 
algorithm are also provided in that section. In addition, a new digit-seriai unfolding tech- 
nique for architectures performing operations where the wordlength of the input changes 
dynamidy is proposed. Finally, in Section 2.4, limited-carry addition schemes that yield 

architectures whose delays are independent of the lengths of their inputs are explored. A 
chazacterization of these schemes permits one to link the design and development of several 
Ends of addition architectures, so as to reduce their design and development tirne. 
2.2 
Fixed-Point Arit hmet ic 
2.2.1 
Introduction 
Arithmetic operations are the building blocks of digital signal processors. This section is 
concenied with a discussion of the impact of generalized signed-digit number representa- 
tion, (a) on the range of permissible digital data, and (b) on the area and speed of the 
corresponding DSP hardware architecture. 
2.2.2 
Number Representation and Number Systems 
Definition 4 Number representation: consider a number N that belongs to a set S (e.g. 
N, Z, 
or W. 
A npresentation of N cowisb of 
1. o digit set D (e.g. {O, . . . ,9)), 
2. an integer length L, 
3. a sequence 
of digits that betong to D, where i, 
- imin + 1 = L, and 
%miosiaili>u 
4. a mapping M deftned in acwdance wàth 
Then, N ik r e p ~ e n t e d  bg the sequena 
thmugh the mapping M if 
nSidisisi- 
The digits 
are constrained to a certain digit set D. For example, the decimal repr* 
sentation of N requires that 
b e h g  to the set (0,1, . . . ,9}. The sequence of digits is 
comrnonly referred to as a word. 

A system in which number representations share the same mapping is called a num- 
ber system. Number systems can be ciassifiecl into two categories, namely complete and 
incomplete number systems. In a complete number system, any number fiom S can be 
represented by using the digit set D and the mapping M (Kornerup, 1994). This thesis is 
concerned with complete number systems only. 
Fixed- and Floating-Point Number Representations 
Usually, the digits of a number representation are assigned weights, denoted by the sequence 
W .  
, and the mapping is the obtained ss the imer product of the digit and the 
TiminSiSima 
weight sequences in accordance with 
Most ofken, such a representation is either referred to as Gted-point or as floating-point. Cer- 
tain representation mappings do not use weights in this way (e.g. the logsrithmic, residue, 
and rational nurnber systems (Hwang, 1979)). 
In a fuced-point representation, the weights are caiculated in accordance wit h 
whese represents the radix (or base). in this thesis, a digit with index i is dways associated 
with a weight /3-'. 
The digit of smallest weight is r e f d  to as the least-significant digit, 
or LSD, and the digit of large& weight is referred to as the most-significant digit, or MSD. 
In a floating-point representation, the number N is represented by a fixed-point mantissa 
m and a fixecl-point exponent e such that N = rnp. Part of the word is thedore r e s ~ t e d  
for m, and the other part is reserved for e. 
This thesis is ody concemeci with ked-point number representations. An important 
fature of euch a representation is that a fixed-point number ean always be mdtiplied by a 
power of the radix (scaled up) to yield an integer. A number system using weights in this 
way can thus be characterized by the r& 
/Y and the digit set D. The decimal number 
system (/3 = 10 and D = {O,. . . ,9)) is the one humans use to leam to count and add, and 
the binary numba system (/3 = 2 and D = {O, . . . ,1}) is ased by digital cornputers and 
other digital electronic devices. 

Example 5 The mdiz of the decimal number system is 14 and the digit set U {O, ... ,9). 
Consider the decimal number 25, which can represented by the decimal word 02S10, where 
= O x 102 + 2 x 10' + 5 x loO. Cowider now the binary number system: it has a mdZz 
2, and a digit set { O , .  . . ,1). The deeimal number 5 can now be represented in the bina y 
number syetem by 110012, whem 1 x 24 + 1 x Z3 + O  x Z2 + O  x 2' + 1 x 2' = 
Redundant Number Systems 
A number system is said to be redundant when a given aigebraic value can have several 
representations (Avizienis, 1961; Parhami, 1990; Komerup, 1994). 
Example 8 The signcd-binaq (SB) number system hm a mdix 2, and a digit set {&O, 11, 
where 1 representa -1. The decimal number 3 mn then be represented either by 0112, when 
O x 22 + 1 x 2l +1 x 2O= 3i0, or by 1012, when 1 x 22 + O  x 2'- 1 x 2' = 310. 
The key point with redundant number systems rests with the addition of two redundant 
words. In fact, when using redundant number systems it is possible to develop constant- 
delay architectures for addition In k t ,  if the result is expresseci in a redundant number 
system, it is possible to stop the carry propagation, leading to constant-delay architectures 
for addition (Avizienis, 1961; Chow and Robertson, 1978; Parhami, 1990; Kornerup, 1994; 
b, 
1996; Thornton, 1997). 
Let us d d b e  the conventionai addition. One ad& two digits at a given digit position, 
yielding a sum digit for that digit position and a carry. Then, one adds the cany to the digits 
of the next higher digit position, yielding a sum digit and a new carry, and so on. Let us 
now describe constant-deiay addition in redundant number systems. At any digit position, 
the two digits are combined to yield a carry for the next higher digit position, regardles of 
the value of the carry generated at the previous lower digit position. Then, the remairiing 
d u e  is combined with the incoming csny, yielding a sum digit. This process is alw referred 
to as weight-traa9k.r decomposition. As a consequence, the carry is absorbed immediately, 
and does not ripple dong the length of the input words, just*g 
the term wnstant-delay. 
Specific number representations have beai developed to stop the carry propagation at fixed 
digit position interoals (Phatak and Koren, 1994). 

For some number systems, two consecutive weight-trwfer decompositions are required 
for addition as thek digit set does not dow sufEcient redundancy in the sum word. In this 
way, the addition process can stiU be referred to as either constant-delay, or lirnited-carry? 
since the carry is absorbed &et two digit positions instead of one. This is the case for 
the signed-binary number system (Avizienis, 196 1; Parhami, 1990; Kornerup, 1994). The 
performances of the architectures and corresponding hardware implementations developed 
in this thesis rely greatly on this constant-delay property. 
2.2.3 
Similarities Between Addition Schemes in Generalized Signed-Digit 
Number Systems 
Generalized signed-digit (GSD) number systems were formally introduced in (Parhami, 
1990). They are radix-/3 number systems having a digit set of the form {-q-, . . . , v+), 
where q- 2 O, where q+ 2 0, and where q+ + 9, + 1 > p. These number systems 
are redundant, and were proven to a h w  constant-delay addition (Parhami, 1990). In 
the following, a relationship between GSD number systems is introduced to prove that 
 the^ addition mechaniSm8 are very similar. The exploitation of these similarities results in 
substantial design tirne savings by using architecture re-use. 
Relationships Between GSD Nuxnber Systems 
A subset of GSD number systems, ordinary signed-digit (OSD) number systems, was also 
A 
introduced in (Parhami, 1990). Their digit set is bdanced, i.e. >I+ = 9- = T, leading to 
the added admtage that if z belongs to the digit set (-9, -q + 1,. . . ,T - 1, q), then -x 
belongs to the same digit set. Unless otherwise stated, this thesis is concerneci with OSD 
number systems only. Often, r) is constrained as follows 
where the Iower bound is required in orda for the corresponding number system to be 
complete and redundant (Kornerup, 1994), whereas the upper bound is required for the 
representation of O in the corresponding number system to be unique. 
Let us introduce unbahced signed-digit (USD) number systems, where one can choose 
h 
q+ = 7- + 1 = q. One couid have equivslently chosen 7- = O+ + 1. Similarly, one can 

constrain q as followa 
As shown in the following, any GSD number system can be related to a unique OSD/USD 
number system, and thus inherits the same addition mechanisms. This property is at 
the hart of various techniques for iimiting the csny propagation in arithmetic operations 
(referred to as "tri& of the trade" in (Kornemp, 1994)). 
Let us dehe the addition of two sets in accordance with 
Si + S2 = {a such that a = al + oz, where ai E Si and a2 E S2), 
(2-6) 
and the multiplication of a set by a scdar in accordance with 
n kS= (y such that y = n x x ,  wherex ES). 
Let us give an example: 
The relationship 7Z between two GSD number systems can now be defined as foilows: 
Definition 7 Denote by Tc& a digit set tmnsfomation such that 
when C repmenfs { D  = (-r)-, . . . , q+}l(r)-, i)+) E IV2). Then, conaider c m d w  GSD 
number system NS of digit set D = (-7-, . . . , q+), and another m d w  GSD nurnber 
qstem NSf of digit set Df = (-$-, . . . ,a} 
such Uiat f+ + r/_ + 1 = q+ + q- + 1. NS 
b nluted fhmugh 78 fo N P  if und only if then ezàst É E (-1, l} and A E Z such that 
D' = TE,@). This relationship U equioalently denoted b y NSRNS'. 
It can be noted that the reverse t d o n n a t i o n  T;; exists, and that 

It can be proven that R is an equivalence relationship, Le. that R is rdexive, symmetric, 
and transitive. 
Let us denote the carnindiq of a set S by ISI. There are two types of GSD number 
systems: those for which ID1 is odd, and those for which ID1 is even (refmed to as odd and 
even GSD number systems, respectively) . 
Theorem 8 Any odd GSD numbe~ systern is related through 7Z to a unique OSD number 
system, and any even GSD number system ia rekated through R to a unique USD number 
system. 
Proof. The proof of the theorern consists of two parts, the first for odd GSD number 
systems, and the second for even GSD number systems. 
Let us consider an odd GSD number system GSDNS of digit set D = {-q-, . . . , q+}. 
A necessary condit ion for an OSD number system OSD NS of digit set D' = { -q, . . . , r)) 
to be related through 7Z to GSDNS is expressed by 
which Mplies that 
with q being a positive integer (because GSDNS is odd) . Therefore, only one unique 
OSD number system can be related to GSDNS. Let us prove t hat GSD NS is related 
through 7Z to OSDNS. If one chooses c = -1, then A = r]+ - r) leading to 

Therefore, GSDNS 7Z OSDNS. Shnkly, one can prove that c = 1 and A = q- - q 
implying that GSDNS 7Z OSDNS. Consequently, GSDNS 'R OSDNS, where 
OSD NS is unique. 
O Let us consider an even GSD number system GSDNS of digit set D = {-7-, . . . , q+). 
Similar to the previous discussion, a necessary condition for a USD number system 
USDNS of digit set DI = {-q + 1,. . . , r)) to be related by 'R to GSDNS is expregsed 
by 
with I) being a positive integer (because GSDNS is even). Therefore, only one unique 
USD nurnber system can be related to GSDNS. Let us prove that GSDNS is related 
through 7Z to USDNS. If one chooses r = -1, then A = q+ - 7 + 1 leading to 
%,&(Dl = -{-V-,* 
-*,V+} + {V+ - v +  1) 
(2.20) 
={-7+,***9q-}+{q+-q+l} 
(2.21) 
= {O, *.. ,q++q-)+{-q+ 
1) 
(2.22) 
={O9...,2q-l)+{-q+l} 
(2.23) 
= {-q+l,-.-,q} 
(2.24) 
= D'. 
(2.25) 
Therefore, GSDNS 7Z WSDNS. Similady, one can prove that e = 1 and A = 
7- - q + 1 implying that GSDNS 7Z USDNS. Consequently, GSDNS R USD NS, 
where USDNS ie unique. 
The above two bdeted points establish the proof. 
rn 
Theorem 8 implies that by assi- 
the same hardware code to an element of D and 
to its counterpart in D' via TE&, 
the addition of two numbers expressecl in these tato 
different number systems can be pedormed by using the same architecture. Moreover, 
ail the GSD number systems of a given class shares the addition mechanisms of a unique 
corresponding OSD or USD number system. Therefore, a lot of design tirne cm be saved by 
considering these sunilarities in the i n t d  addition medianisms in GSD number systems. 

An application of this theorem will be given in Section 2.4, where addition schemes will be 
characterized in the binary case leading to architectural similarities. Numerous studies of 
the properties of OSD number systems can now be applied to odd GSD nurnber systems 
(Chow and Robertson, 1978; Irwin and Owens, 1987; Irwin and Owens, 1988; Parhami, 
1988; Srhivas and Parhi, 1983; Thornton, 1997). 
2.3 Data Processing Techniques 
This section is concerned with the presentation of the digit-serial and the online arithmetic 
techniques as data processing methods. The former technique permits the processing of 
"severaln digits at a time, from one to the full wordlength. An extension of the digit-serial 
technique to a dynamically changing wordlength situation is also introduced. The latter 
technique permits the processing of data the MSD k t .  An introduction to the approaches 
to the development of resdting arithmetic operations is given, foIlowed by an example. 
2.3.1 
Digit-Serial Arithmetic Technique 
The bit-seriai arithmetic technique processes a digital signal one digit at a time, whereas 
the bit-paraliel arithmetic technique processes it one word of length W at a tirne. The 
bit-serial technique is ara-efficient because only one wire and one singledigit arithmetic 
unit are required to process the input data. Convemely, a bit-parailel transmission requires 
W wires and W singledigit arithmetic units, but aiiows the design of faster architectures 
by introducing as much concurrency between the internal operations as possible. 
The digit-serial arithmetic technique processes words D digits pet tirne instant, where 
the digit-size D may or may not be a divisor of W. The bit-serial and bit-parallel arithmetic 
are speciai cases of the digitserial arithmetic technique for digit-sizes of 1 and W, respec- 
tively. Therefore, this technique allows a trade-off between the area-efficiency of bit-serial 
systems and the tirne-efficiency of bit-parailel systems by adjuthg the parameter D. 
Digit-Serial Unfolding Algorithm 
Any bit-seriai architecture can be represented by combinatorid units, unit-delays, switches, 
and w h .  This representation c m  be translateci into a data-flm graph, which is a directed 

graph whose nodes represent combinatorial units, and whose ans represent either commu- 
nication involving a non-negative integer number of delays or zeredelay communication 
at specinc time instances. The digit-serial unfolding algorithm (Parhi, 1991) transforms a 
dats-80~ graph DFG of a bit-serid architecture into its correspondhg dolded data-%ow 
gmph UDFG of digit-size Dl processing D bits of the original bit-serial stream at a tirne, 
where D may or may not be a divisor of W. 
An arc is denoted by U + V, where node U represents its source, and where node V 
represents its destination. If the arc introduces i delays, then the result of node U obtained 
at time instant no is used at t h e  instant no + i in node V. If the arc provides zero-delay 
commUDication at a specific tirne instance, then the time instance is given by Ww + u, 
where W represents the wordlength of the bit-serial stream, where u belongs to the set 
{O, 1,. . . , W - 11, and where w represents the word number in the bit-serial stream. 
Let us denote L as the least cornmon multiple of W and D. The digit-serial unfolding 
algorithm below was presented in (Parhi, 1991). 
Algorithm 9 Digit-Serial Unfolding Algorithm 
Step 1. For -ch 
node U in DFG, dmw D nodes in UDFG, and label them 
Uo, 
..., UD-1. 
Step 2. For euch arc U -r V in DFG having O delay, dmtu the arcs IIq + V, with O 
delay for al2 q E {O,. . . , D - 1). 
Step 9. For each an: U + V in DFG hcving i delags, 
Step 30). If O < i < D, dmw the arcs UD-+~ + Vq With 1 delay for al1 q E 
{O, 1,. . . ,à - 11, and dmw the a m  
-+ 5 with O delay for q E 
{à,i+l, ..., D-1). 
Step 4. For each &ch 
U -t S hauing a awitching instance WI + u, calnilaie the bit- 
seriai auitching instance os Ll+u+wW, where w E {O,. . . , $ - 1), and when 
the componding digàt-serial suJit~hing iristance U , u ~ w l m o d D  
are caldated as 
=t+ 
vw E {O,-.-,& - 1). 
'LT 
Then, the fo11owing algorithm is a modification of Algorithm 9. 
Algorithm 10 Modi'ed Digit-SMal Unfolding Algorithm 
21 

Step 1'. For eoch node U in DFG, d
m
 D nodes in UDFG, and tabel them 
Uol..-,U&l. 
Step 2'. For cnch am U + V in DFG having i delays, dmw the arcs U(,i)modD + 
with [y1 delcy(s) for ail q E (O,. . . , D - 1). 
Step 8'. For mch suitch 
U + S having a switching instance Wl + u, calculate the 
bit-serial switching imtance as LI + u + wW, w h m  w E {O,. . . ,& - 11, 
and where the eomponding digit-senal dtching instance U(,+,w),odD 
am dmlated os 61 + 1-1, 
Vw E {O, ... , - 1). 
Theorem 11 Algorithm 9 and Algorithm 10 perfonn the same data-ftow gmph unfolding 
operution. 
Proof. 
One can remark that Steps 1' and 3' of Algorithm 10 correspond exactly to 
Steps 1 and 4 of Algorithm 9, respectively. Therefore, one has to prove that Step 2' in 
Algorithm 10 performa the operations of Steps 2, 3(a) and 3(b) in Algorithm 9. This is 
achieved by successively considezing the cases i = 0, O < i < D, 
and i 2 D. 
Let us assume that i = O, as in Step 2. One can readily observe that for q in 
{O, -,D - 1}, 
and 
hold. Therefore, for ali q in (O,. . . , D - l}, one arc Uq + Vp is drawn with O delays, 
which is the definition of Step 2: Step 2' and Step 2 are quivalent. 
Let us assume that O < i < Dl as in Step 3(a). Then, q belone either to {O,. . . , i - 1) 
or to {i,. .. , D - 1). 
- Let us consider q E (O, . . . , i - 1}, which implies that 
( q - i )  mod D = (D 
- i + q )  modD, 

where L) - i > O. Moreover, 
holds, which yields 
In this case, Step 2' draws the arcs UD++, + Vq with 1 delay for all q in 
[O,. . . , i - 11. Therefore, for O c i < D and q E [O, i - 11, Step 2' and Step 3(a) 
are equivalent. 
- Let us consider q E {i, . . . , D - 11, which implies that 
( q - i )  modD=q-i. 
Mor eover , 
holds, yielding 
- D + 1  
[i l=[q-l, 
(2.35) 
where 
= 1. In th& me, Step 2' draws the arcs Uq-i + V, with O delay for 
all q in {i, . . . , D - 1). Therefore, for O < i < D, Step 2' and Step 3(a) are also 
quivalent when q E {i, . . . , D - 1). 
Fkom these two points, O < i < D implies that Step 3(a) and Step 2' are equivalent. 
Let us now assume that i 9 D. Firstly, one has to prove that Step 2' and Step 3(b) 
create the same arcs. By recalling the definition of the modulo operation, 

one can write 
which becomes 
(q-i) modD=q-i-D LqJ - 
, 
Iy. 
(q-i) m o d D = q - i + D  - 
Therefore, Step 2' creates the arcs Uq-i+Dryl + & for q E {O,. . . , D - 11, which is 
the definition of the creation of the arcs in S tep 3(b). Secondly, each arc created by 
using Step 2' must be shown to have the same number of delays than if created by 
Step 3(b), which holds immediately. Therefore, for i ) D, Step 2' and Step 3(b) are 
equivdent. 
These above three bdeted cases establish the proof. 
As a result of Theorem 11, digit-serial unfolding can be performed by using Algorithm 10, 
thereby avoiding the multiple delay-based cases for the instantiation of arcs. 
Theorem 12 One con unite Step 2' equiudently as follows: for each arc U -+ V in DFG 
hathg i ddayb, d
m
 the arcs U# + Viq'+,)rncdD t d h  [%] delay (8) for al1 qf E {O, . . . , D - 
1). 
Proof. The proofis established by proving that, given i in N, and given q' in {O,. . . , D- 
l), any arc u# + F#+i)modD 
"th l*] 
delay(s) is the ssme UC as U(q-i)modD 
-t & with 
[$l 
= lq1 delay(s), nhere q = (q' + i) mod D. 
Given i in N, and given q' in {O,. . . , D - 11, defining 
implies that 
(q-i) modD= ((q'+i) modD-i) modD 
= (q'+i-i) 
modD 
=q'modD 
= d, 

because q' 
E (O, .. . , D  - 1). Of course, q E {O,... , D - 1) by dekition. Therefore, 
Uf + yb+i)modD 
is the same arc as U(q-qmdD -t Vq when q is defined in accordance with 
Eqn. 2.39. 
One has to prove that if i belongs to N, and if q' belongs to {O,. . . , D - l), then 
Firstly, by definition of the modulo operation, one can mite 
Fkom Eqn. 2.43 and by moduio 
By adding Eqns. 2.45 aad 2.46, 
which readily bads 
operat ion, 
and by recalling that - la] = [-al, one obtains 
In th* wây, it has been established t hat given i in N, drawing the arcs U# + vf+i) ,dD 
with 191 d&y(~) for BU q' in {O,. . . , D-1} i8 quivalent to drawing the arcs U(q-ilmodD + 
4 with 
delay(a) for dl q in {O,. . . , D - 1). 
a 
Theorem 12 allows the replacement in the modined algorithm of Step 2' by another 
equivaient step, which takes the source node number as the index of instantiation instead 
of the destination node nuiaiber. 
By varying the digit-size in the application of the digit-serial unfolding algorith, which 
translates bit-serial architectures into digit-mial architectures, one can strike a balance 
between the area and the speed of a given hardware architecture. A modifiecl digit-serial 
unfolding aigorithm allm one to perform the instantiation of the registers of an architecture 
in a single step without the need for t&ing the number of delays on the m e n t  arc. 
Moreover, the same step in the modifiai algorithm can be performed by considering either 
the source nodes or the destination nodes. 

Application of the Digit-Serial Architecture Unfolding 
Any bit-serial architecture ean be translated into its unique digit-serial conterpart of digit- 
size D by applying the digit-serial unfoiding algorithm presented in (Parhi, 1991). In the 
foilowing, this algorithm is applied to the example of bit-serial unsigned binary addition. 
Consider two digital signais a end b represented by binary words of wordlength 4, where 
a binary digit is referred to as a bit. The bits are transmitted bit-serially, the LSD k t ,  and 
the words are concatenated in the. The addition of the words in the two data streams can 
be performed by the full-adder (FA) architecture shown in Figure 2.1. There is only one 
Figure 2.1: CBit LSD-First Bit-Serial Binary Adder 
FA unit, which is numbered O. At each bit-serial time instant m, the incoming bits a, and 
b, are added together with the input carry 
and a sum bit s, 
and a corresponding 
output carry is generated in accordance with 
The output cany is then stored in a unit-delay register D for use in the next bit-serial time 
instant. 
Most of the time, i.e. for rn E {4n+I24n+2,4n+3), the switch equates the current input 
carry value ci,, with the output carry at the previous bit-serial time instant, ht,,-~. 
Otherwise, Le. for m = 4n, the switch resets the input carry to O. in other words, the 
addition of two words begins at every bit-serid t h e  instaat rn of the form m = 471 in the 
bit-serial architecture. The operation performed by the switch is illustratecl by the t h d i n e  

shown in Figure 2.2. The bit number in the A or B data strearn fed to the FA unit number O 
Unit 
Number , 
O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Instant rn 
Figure 2.2: Bit Number in a 4Bit Bit-Serial Data Stream 
is given at any bit-serial time instant m. The bit-senal thne instant corresponds exactly to 
the bit number in the bit stream as the words are transmitted one bit per bit-seriai time 
instant. A boxed nuniber indicates the bit number of the LSD of a word, and is equal to the 
bit-serial tirne instant at which the switch must teset the carry-in of the FA unit number 
O. In a correspondhg hardware implementation, the reset switch is controlled by a signal 
Ctrlo. 
The bit-serial architecture can be transfomed into its digit-serial counterpart with a 
digit-size of D = 3, by using the digit-serial unfolding algorithm by Parhi (Parhi, 199 l), 
as shown in Figure 2.3. One can observe that the unfolded architecture has been obtained 
as a cascade of FA units with mettable input carry, numbered fiom O to D - 1. In a 
corresponding hardware implementat ion, the reset swit ches are controlled by corresponding 
signals Ctrlo, CtrIl, . . . , CtdD-1- 
It is important to note that mf represents the digit-serial time instant (as opposed to 
m for the bit-serial tirne instant). This architecture fetches D = 3 consecutive bits in the 
bit-serial data stream to process them in parailel at a given digit-serial time instant rn', as 
illustrateci in the tirne-line s h m  in Figure 2.4. At a given digit-serial time instant mf, the 
FA unit =ber 
O is fed with the bit number 3mf +O, while the FA unit number 1 is fed with 
the bit number 3m' + 1, and the FA unit 2 (= D - 1) is fed with the bit number 3mf + 2. 
It can now be observed that the reset switches of the FA units O, 1, and 2 have to reset the 
input carries of the same FA units at digit-serial tirne instants of the form 4nf, 4n' + 1, and 
4n' + 2, respectively. Therefore, no input carry has to be reset when mf = 4n' + 3. 
One can observe that the bit-serial data stream is sectioned into sets of D consecutive 
digits. Of course, digits belonging to two consecutive samples may be present in those 

Figure 2.3: 4Bit LSD-Fht Digit-Serial Binary Adder (D = 3) 
Unit 
O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Instant m' 
Figure 2.4: Bit Number in a 4Bit Digit-Serial Data Stream (D = 3) 
sets, e.g. samples O and 1 at the digit-serial tirne instant m' = 1 (digits 3, 4, and 5) 
in Figure 2.4. Therefore, the main fundion of the reset mitches is to isolate these two 
consecutive additions being processed at the same digit-serial time instant in the same 
addition architecture. 
D y n a d d y  Changing Wordiength Technique 
Consider the digit-serial UIlfoIding example shown previouely in this section. Let us assume 
that the addend and augend words have a dynamidy chaaguig wordlengfih, i.e. that W is 

a function of the word number word 2 O. Then, it is possible to calculate the active-high 
control signals Ctdi at each digit-serial t h e  instant in such a manner as to permit addition, 
as shown in Algorithm 13. 
Algorithm 13 Calculution of Control Signals for Dynamically Changing Wortilength 
Step 1: Set word t- O; 
Step 2: Set c +- 0; 
Step 3: For i between O and D - 1, 
If i = C, then 
Set Ctdi t 
1; 
Set c 4- c + Wwo+d; 
Set word + wmd + 1; 
Else 
Set Ctdi + O; 
End 
End 
Step 4: Set c t 
c - D; 
Step 5: Go to Step 9 
A resulting hardware implementation thus dculates the addition of an addend to an augend 
of tirne-evolving wordlength while still using only D bit-serial ceils. 
It is important to note that the above algorithm is valid only if the minimum wordlength 
value is laqer than the digit-size D. Otherwise, more thaa two CHi si@ 
may be active 
at a given time instant. Moreover, the above algorithm can be used for any control signal 
that must be active at a t h e  instance Wn, where n E N. 
Let us consider a control signal that must be active cob,et bit-serial time instants after 
the start of the operation, i.e. at bit-serial time instances Wn + c0&t, 
where n E N, and 
where cOfiaer E 2. Then, one can generalize the above algorithm by replacing Step 2 by the 
step shown below. 

Step 2 new: If c , ~ ~ , t  < O, then 
Set c c Wo + c,flaet; 
Set word c 
1; 
Else 
Set c t 
coffaet; 
Set word + O; 
End 
The main bene& of a resulting digit-serial cell is that it accepts inputs of dynamically 
ehanging wordengths. As a result, coarser results using shorter wordlengths can be calcu- 
lated faster for a fixed hardware requirement. For example, if the wordlength drop by half, 
then the throughput is increased by a factor of 2. 
Let us describe the digit-serial dynamically changing wordlength unfolcihg technique for 
directed flow graphs representing arbitrary architectures. First, one executes steps 1 and 
2 of Algorithm 10. Then, for every switch, the control signal active at the bit-serial t h e  
instance Wn + cogiet It is imperative that the bit-serial cell accepts inputs of dynamically 
changing wordengths. The main disadvantage of this technique is that one must ensure 
that the wordlength truncation does not affect the functionality of the whole system. 
2.3.2 Online Arit hmetic Technique 
In conventional arithmetic operationa, the carries n a t u d y  ripple toward the MSDs of 
the result. The main practical disadvantages of conventional arithmetic operations are, 
(a) the required change in the flow of digits nom the MSD (imposed by A/D and DIA 
converters) to the LSD first, and (b) the large latency due to the calculation in LSD-kt 
arithmetic. In order to amid these problems, efforts have been made in the past two decades 
to develop online operations processing digits the MSD fi.&, 
which exhibit s m d  latencies. 
An introduction to the main approaches to the development of online arithmetic operations 
wiil be given, followed by the development of an example to iilustrate the technique. 
Approaches to the Development of Online Arithmetic Operations 
A number of online arithmetic architecutres have been developed in the pst, rsnging fiom 
the traditional addition, subtraction, multiplication, and division (Trivedi and Ercegovac, 

1977; kwin, 1977; Owens, 1980; Chow, 1980; Gorji-Sinalci and Ercegovac, 1981; h i n  and 
Owens, 1987; Irwin aad Owens, 1988; Guyot et al., 1989; Perlee and Casasent, 1989; Erce- 
govac and Lang, 1990; Privat, 1990; Balsara et al., 1991; Sips and Lin, 1990; Guyot and 
Kusumaputri, 1991; Srinivas and Parhi, 1983) to the more complex trigonometric, expo- 
nential, or filtering operations (Owens, 1981; McQuillan and McCanny, 1995; Fernando and 
Ercegovac, 1992; Lapointe et al., 1993; Lin and Sips, 1990; McNally et al., 1990; Bradc- 
ert et al., 1989). Online arithmetic operations have been developed by employing either a 
recursion-based method or an evaiuation-based method. 
The recursion-based method was developed first (Trivedi and Ercegom, 1977; Irwin, 
1977) and yields iterative and recursive algorithms. A review of such algorithms was pre- 
sented in (Ercegovsc, 1984). Many of the initial recursive online algorithms were ob- 
tained by successively transforming a conventional (LSD-first ) aigorithm to accep t in- 
put digits the MSD first, and then introducing additional steps in order for the alg* 
rithm to generate the output digits in an onîine fashion ('Iiivedi and Ercegovac, 1977; Ir- 
win, 1977; Owens, 1980; Chow, 1980; Gorji-Sinaki and Ercegoïac, 1981). In this way, 
conventional algorithms based on continued sum/products for the evaiuation of general 
funct ions (e.g. sine, logarit hm, or multiplicative inverse) have been transformed into on- 
line algorithms using the aforementioned procedure (Owens, 1981). However, most of the 
recent recursive online algorithms were obtained by directly considering the online flow of 
the input and output digits ('Itivedi and Ercegovac, 1977; Chow, 1980; Gorji-Sinaki and 
Ercegovac, 1981; Guyot et al., 1989; Privat, 1990; Guyot and Kusumaputri, 1991; Srinivas 
and Parhi, 1983; McQuülan and McCanny, 1995; Fernando and Ercegom, 1992; Lapointe 
et al., 1993; Lin and Sips, 1990; McNaiiy et al., 1990; Brackert et al., 1989). 
The renirsion-baseci method yidds algorithms which share a common iterative sequence. 
At a given iteration, a partial operation update is added to a scaied online error formed at 
the previous iteration, where the sealing factor is equai to the number system radix. Then, 
the resuit is rounded to an integer d e d  the onüae result digit. F W y ,  an oaüne error is 
dcuiated for use in the next iteration. 
Let us recall that the onüne result MSD is the k t  online resuit digit to be calculated. 
If no attention is paid to the magnitude of the scaied online error and that of the partial 

operation update, the radix-fl representation of the result of their addition may require 
MSDs of weights thst are lazger than that of the online result digit to be outputted. This 
problem is equivalent to stopping the carry propagation of the cumulative sum of the off- 
h e  partial updates, facüitated by scaling down the partial operation update by a constant 
Lîctor, and by using a redundant representation for the online result. Unfortunately, by 
scsling down the partial operation update, one increases the latency of the online arithmetic 
operation (c.f. Section 1.3.2). The determination of the minimum latency depends on the 
online arithmetic operation, as shown by many independent studies (Duprat et al., 1989; 
Sips and Lin, 1990). In fact, the iatency corresponds to the number of MSDs exceeding the 
input representation format (referred to as guard digits), and is thus determined both by 
the precision of oniine result digit estimation and by the range of the resdt of the operation 
itself. 
More recently, the evaiuation-based method was developed with the intention of finding 
the minimum latency of any arithmetic operation (Sips and Lin, 1990). Algorithma for fixed- 
point azithrnetic operation obtained by using thia method aJl share a common procedure and 
are aU iterative. At a given iteration, the ofHine iterative resuit is calcdated as accurately 
as the precision of the input words permits, and an online result digit is caldated by taking 
into account that result as weil as the previous online result digits. Of course, the hardware 
implementations of the exact remit calcuiation are impractical, i.e. they are too slow or 
too large (Sips and Lin, 1990). Therefore, in this thesis, eEorts are concentrated on the 
recursion-based approach. 
Application: O n b e  Algorithm for Signed-Binary Addition 
Let us consider the sddition of an addend A to an augend B resulting in a s u m  R in 
accordance with 
The inputs A and B, referred to as the operands, sre signed-binary number representations 
in accordance with 

and 
;=O 
where W represents the wordlength of A and B. The MSDs of A and B are a0 and bo, 
respectively. As the addition must be online with respect to the operanch, the inputs to the 
algorithm at iteration p (O 5 p 
W - 1) are a, and b,, thus leading to the formation of 
which represent the partially formed operands A, and B,. 
The sum digits 
are similarly generated in an online fashon, thus leading to the 
formation of the signed-binary representation 
where 6 represents the latency of the online addition algorithm to be discussed later. The 
signed-binary representation ip 
is an increasingly more accurate approximation of the sum 
R The ciifference R - $ has two ongins, namely, the absence of knowledge of d the digits 
of accuracy of the operands, and the onüne error which is due to the online digit selection 
process. 
The folIowing algorithm performs the addition of A and B in an onüne fashion: at a 
given iteration p, ap and b, are input, and the online s u m  digit FPs is generated. 
Algorithm 14 Online Otdinary Sàped-Digit Addition 
Step Ir Set p t 
O and c-1 t O, 
Step E Gaidate Pp t 
(ap + $) pd, 
Step 8: Calculate Fp t t E p - ~  
+ Pp, 
Step 4: Round Ep to TPs, 
LI 
Step 5: C~lculate 4 t Fp - +,J, 
Step 6: Cdculute p t 
p + 1, 
Step 7: If p < W ,  thm go to Step e, eise done. 

In the above algorithm, the online error and the iteration number are initialized to O. At a 
given iteration p, an off-iine partial addition update Pp is calculateci, by using the operand 
digits a, and b,. Then, Pp is combined to the onüne error ep-1 generated at the previous 
iteration, yieiding an online partial addition update F'. Next, Fp is rounded to the online 
sum digit Fp6, giving rise to an online error cp. This rounding operation can be perfomed 
on a s m d  number of the MSDs of Ep, inmeasing the speed of a eorreaponding hardware 
implementation. The iteration number is then inmementeci, and Steps 2 to 6 are performed 
until p = W - 1. It can be shown that at the end of iteration p = W - 1, the online iterative 
sum Rw-i represents the MSDs, and the online error sw-1 represents the LSDs of R. 
The enor between the exact sum and the oniine sum is caused by the absence of knowl- 
edge of A - A, and B - Bp, and by the online error ep. In the algorithm, the former error is 
reduced at each iteration by taking into account the off-line partial update P,. The latter 
error changes at each iteration, and must be kept s m d  enough so that the addition of Pp 
to the sded oniine error does not affect the o n h e  result digits outputted in previous itera- 
tions. This problem is hirther complicated by pezfonning the rounding operation for online 
result digit estimation on a small number of MSDs of F,, but can be circumvented by in- 
creasing the latency. As a result, the range of P, becomes smder, reducing the range of Fp 
(as desired). However, the latency should be kept s m d  in order to reduce the wordlength 
of the result. For a given arithmetic operation, one can calculate a minimum bound on 
the latency. Then, this bound can be used to determine the optimal tradeoff between the 
deiay of a corresponding implementation, which largely depends on the rounding operation 
(McQuillsn and McCanny, 1995) and the îatency of the operation. 
2.4 
High-Speed Signed-Binary Addition 
This section is concerned with an introduction to limiteci-carry sddition schemes in redun- 
dant binary number systems, and with the development of corresponding bit-serial and 
digit-serial online addition architectures. In part icular, the Iimited-carry redtmdant binary 
addition schemes wiii be o b s d  to share a common bit-pardel architecture. A systematic 
enmeration of ail the correspondhg addition schemes will extract and highlight the5 sim- 
ilar behaviors. As a d t ,  one wiii be able to employ an existing architecture for addition 

in a given number system as an addition architecture in a different nurnber system. 
2.4.1 
Redundant Binary Addit ion Schemes 
The addition of two signed-binary (SB) worde can be achieved in constant t h e ,  indepen- 
dently of the wordengths of the inputs (Avizienis, 1961). The implementation of such adders 
waa investigated in (Chow and Robertson, 1978) by analyzing ail possible digit encodings 
and by deriving the corresponding boolean equat ions, yielding efticient architectures. Then, 
a recoding approach was taken in (Parhami, 1988; Kornerup, 1994) for the development of 
SB adders. Recent ly, in (Thornton, 1 997), two weight-transfer digit decomposit ions were 
applied to perform the addition of SB numbers, where the binary code of the result always 
features an even number of l's, referred to as inherent parity. Such a property can be used 
for embedded correct huict ionality test hg. 
In the foilowing, it is shown that ali the above approaches are variations of the same 
approach, resulting in si& 
architectures. Therefore, one will characterize the redundant 
binary addit ion schemes that yield t hese constant-delay architectures by using two param- 
eters, one for the redundant binary digit-set, and one for the addition scheme itself. h this 
way, it is ehown that the similarity between redundaat binary addition schemes can indeed 
be exploited to map two different schemes to the same architecture through appropriate 
digit encoding. Due to the length of the prools, the theorems and lemmas are stated, but 
the prooh are presented in appendix. 
Carry-Wee and Limited-Carry Addition 
Addition can be performed in constant tirne when a redundant number representation is 
used (Avizienis, 1961; Puhami, IWO). The corresponding addition schemes can be qual- 
ified as either carry-fiee or limited-carry. In a carry-fiee addition scheme, the digits of 
equai weight of the addend and augend mràs are addad in parallel, and the result digit is 
decompoaed hto weight and t d e r  digits, where the h d e r  digit bears the next higher 
weight. Then, the weight and t r d e r  digits are added (recomposed), yielding the digits 
of the sum in the desired number representation. The t r d e r  digit, also called a carry, 
has thus been absorbed by the recumposition, resulting in an absence of carry propagation. 

Both the decomposition and recomposition can be performed in constant t h e  by one level 
of hardware ce&. This addition scheme is referred to as weight-transfer decomposition 
(Parhami, 1990; Rao and Nowrouzian, 1999), and as digit set conversion (Kornerup, 1994). 
It can be obaerved that the c a r w t y  of the digit set of the result representation is smaller 
than that of the input representation. In a lirnited-carry addition scheme, two such conver- 
sions are performed successively in order to perform the constant-delay addition, resulting 
in a t hrdevel architecture. 
It can be observed that in cany-free addition, a change in an input digit of weight 
B-' 
ody propagates to the output sum digit of weight Bdi, or to that of weight P-'+'. 
Consequently, in Iimited-carry addition, a change in an input digit of weight /3-' 
may 
propagate to the result digits of weights B - ~ ,  P-i+l , and 
Addition in Redundant Binary Number Syatems 
The redundant binary number aystems form three distinct radix-2 GSD number systems 
having a digit-set of catdinality 3. These digit-sets are {O, 1,2), {- 1,0, l), and {-2, - 1,O) 
for the binary cary-save (Parhami, 1990; Komerup, 1994), the SB (Avizienis, 1961) and 
the negative binary carty-save number systems. The redundant binary number systems 
require limited-carry addition schemes because they do not feature enough representation 
redundancy (Parhami, 1990). The binary carry-save number system is complete (Kornerup, 
1994) for IN+, the SB number system is complete for N, and the negative carry-save number 
system is complete for K. Of course, it can be observed that the negative binary carry-save 
number system does not find practical applications since it eaa only yield representations 
for negative numbers. 
The constant-delay property of addition in the redundant binary number systems has 
triggered their widespread use within binary multipliera. As an example, the multipliers 
introduced in (Wallace, 1964; Dadda, 1976; Larsson and Nicol-Chris, 1996) use the c a q -  
ssve number system. Similarly, the SB number system has been widely used for the design 
of non-redundant as well as redundant number multipiiers (Lapointe et al., 1993; Rao and 
Nowrouzian, 1997). The similarities of the addition schemes obtained here are valid for all 
redundant binary number systems, but are expected to be exploited only with the SB and 

binary carry-save number systems. 
Generic Architecture and Corresponding Scheme for Redundant Binary Addi- 
tion 
Let us consider the result S of the sum of sn addend A to an augend B in accordance with 
The operands A and B, and the result S are m
e
d
 to be represented in the same redun- 
dant binary number system having a contiguous digit set (7 - 1, 7 , ~  
+ 1), where 7 E {I,0,1) 
so that the corresponding number system is complete (Kornerup, 1994). Therefore, by re- 
calling the iimited-carry property of the addition schemes under consideration, one can 
and 
where W represents the wordlength of A and B. In the following, ail the limited-cany 
addition schemes which can calculate R are enumerated by determining ad the possible sets 
for the weight and t r d e r  digits for each conversion. 
Since any limited-carry addition scheme can be implemented by using three levels of 
hardwaxe cells, one aui always group them as shown in Figure 2.5. This three-level ar- 
chitecture will be employed for all addition schemes. The variables ci, t$, c?, and 4, are 
referred to as the weight digits, and a and fl as the trader digits of the addition scheme. 
The addition scheme corresponding to Figure 2.5 is expressed in accordance with 
a+4=4+4 
@+c$ =a+2c1, 
and 
4s = p+2c2, 

Figure 2.5: Limited Carry Adder Unit 
respectively, as shown in Figure 2.5. It is necessary that the carries cl and cz be given 
a weight 2. In this way, one integrates in the successive additions the fact that they are 
generated by a similar architecture processing digits of next higher power of two than a and 
b. 
For the sake of uniformity, any nyiable z is assumed to belong to a set denoted by S,. 
Of course, both ci and 4 belong to the same set Sc, to d o w  the above architecture to be 
cascaded to form a bit-pardel addition architecture. In such a bit-paralle1 architecture, the 
single-àigit architectures can be manipulated to use a and as carries (transfer digits) and 
cl and c2 as interna1 weight digits, changing the apparent carry propagation from MSD-first 
to LSD-M. Sirnilariy, 
and 4 belong to the same set Sm. It is important to note that 
the architecture in Figure 2.5 corresponds to a particular case of online addition, where the 
latency is equal to 2, and where the oniine error is obtained as a sum of two components, 4 
and 4. Therefore, by decomposing the onüne error, it is possible to obtain a constant-delay 
online addition. 
2.4.2 
Characterization and Equivaience of Redundant Binary Addition 
Schemes 
In the following, it is shown that the hardware imp1ementation of the architecture shown in 
Figure 2.5 c m  perfom several addition schemes employing diffierent number systems. This 
proof is obtained by fht characterizing the addition schemes by using two parameters, 
followed by defining an quivalence relationship between them, and by finally obsenring the 

resdting similanties and exploithg them for the d&d 
purpose. 
Characterization of Redundant Binary Addition Schemes 
If one denotes the cardinalïty of a set S by IS(, then one can readily observe that, by 
wumpt ion, 
1S.l = 3, lSbl = 3, and IS,I = 3. 
(2.62) 
Moreover, the calculation of the left-hand sides of Eqns. 2.59--2.61 
in terms of their 
conespondhg right-hand sides are only possible if the following constraints hold: 
It can be shown that only two sets of ardinality values are allowed by Eqns. 2.63-2.65, as 
shown in Table 2.1 (see Appendix A for a proof). In both cases, it is possible to determine 
Table 2.1: Set Cardinalities in Redundant-Binarv Addition Schemes 
the value of the elements of the sets as functions of 7 and of an o&et parameter A as given 
in Table 2.2 (again, see Appendix A for a proof). 
Theorem 15 Given any dundant binury additMn scheme, then 
7 E {-1,0,1) 
and 
A E R aich thut Sa = Sb = S, = (7 - l , ~ ,  
7+ l), and fhat the weight and tmnajer digit-sets 
of the addition scheme un us mmmurUed in m e  1, 9, or 3 of Tuble 2.2. 
Proof. The proof is given in Appendix A. 
The above theorem prwes that there is an M
t
e
 number ofredundant binary addition 
schemes, but that they are eharacterized by only two panuneters, one related to the digit 

Table 2.2: Parametrizai Digit Sets of Redundant Binary Addition Schemes 
1 Set / 
No. 1 
1 
No. 2 
1 
No. 3 
1 
set of the number system (r), and the other related to the addition scheme itself (A). It 
is important to note that the result does not depend on A, because it is introduced by the 
b t  conversion and is cancelled by the second. 
s 
, Sc1 
Sa 
Equivaience of Redundant Binary Addition Schemes 
Definition 16 Relationship between addition schemes: consider the redundant binary ad- 
dition schemw A with pammeters (7, A), and A' with pammeters (y, A'). Then, A and A' 
are d t e d  thmugh 7Z if and on29 if the= ezUts a in (1, l} such that 
{T- b7/Y+l} 
s + {A) 
{T-1,7+1}+{-A} 
This ir cpuiuafenfly denoted by 
In Appendix A, a lemma is &en which shows that 7Z is an equivalence relationship. It 
can be readily observed that a necessary condition for two addition schernes to be related 
(7 - 1,797 f II 
{7 - L71+ {Al 
{7-1,~+1,7+3}+{-A} 
SQ 
SB 
{ 7 - b 7 ~ 7 + ~ )  
(797 + 1) + {A) 
{7-3,7-1,~+1}+{-A} 
{~-1,7+1}+{-A} 
2{7-1,~+1}+2{A} 
{7-lt7+l}+{-A} 
2{7-197+l}+2{A} 
{7 - 197 + 1) + {-A} 
2{7 - 1 , ~  
+ 1) + 2{A} 

through 7Z is given by 
It can also be shown that the condition is also sdiicient, thus leading to the following 
t beorem. 
Theorem 17 There are two equivalence classes for 'R in the pmposed space of addition 
schemes: Ca2 for which IS,,I = 3 and IS,I = 2, and Cn for which IS,,I 
= 2 and IS,I = 3. 
In other words, any reàztndant binary addition scheme is either related to any member of 
class C32, 
or to any member of class &. 
Proof. The proof is established in Appendix A. 
rn 
Several implementations of schemes of class Ca2 have been implemented in the past 
(Chow and Robertson, 1978; Thornton, 1997). Two addition schemes of class Cu have 
been implemented in (Thornton, 1997). As a consequence of Theorem 17, one can state the 
following: 
Theorem 18 Let A and A' be two two-level reàundant binary addition schemes such that 
A 7z A'. 
I f  there eRcts a circuit b a t  implements A, fhen the some c i m i t  con be wed tu perform A'. 
Proof. The proof is estabüshed in Appendix A. 
Theorem 18 is very important as it states that a hardware implementation of a given 
addition scheme can be re-used for another equivaient addition scheme. It is crucial to 
note that this equivalence can be obtained kom one redundant binary representation to 
another, i.e. a binary carry-save adder and a signed-binary adder can be trandated to the 
same architecture. 
Let us naar give the example of a circuit for addition scheme A with parameters (7, A) = 
(O, 1) and addition scheme A' wîth parameters (7, A) = (0,O). By applying Theorem 17, 
one obtains th& ARA'. The numbers contained in the various sets are coded as shown in 
Table 2.3, 

Table 2.3: Coding the Set Values 
The codes for the elements of the sets of A are arbitrarily chosen. Every element of a 
set of A' is given the same code es its corresponding element of a set of A by using the 
appropriate transformation. Then, the conversion tables used for A are given below 
Addition 
A 
A' 
and the conversion tables used 
{& O, 1) 
i-boo 
O + (01,lO) 
1 + l l  
- 
1.11 
O-t(O1,lO) 
1 + 0 0  
1 
- 
or A' are given below 
codes, one obtains the same 
Sc, 
S+o 
- 
1 
O + l  
1 + 0  
the same Kaniaugh mapa, and the same circuit. 
Sc2 
o + o  
2 + 1  
- 
1
.
1
 
1 + 0  
O + O O  
2 + (01,lO) 
4 + 1 l  
3.11 - 
1 -* (01,lO) 
l + O O  
A Limiteci-Carry Adder: The 4:2 Cornpressor 
SB 
h
o
 
O + I  
h
l
 
2-0 
conversion tables, 
The 4:2 cornpressor, among many other counters, was introduced in (Dadda, 1976). Plenty 
of research hm been carried out to use 8nd optimize the 4:2 compressor (Law et al., 1999; 
Hagihara et al., 1998; Shim and Kim, 1997; Goto et al., 1997; Puai et al., 1996; Larsson 
and Nid-Chris, 
1996; Kanie et aL, 1994). Its primary application invohed the reduction of 

trees of binary numbers, arising in the multiplication of binary numbers. A 4:2 compressor 
adds four bits of weight 1 with a carry-in of weight 1 and generates one bit of weight 1 and 
one bit of weight 2 and a carry-out of weight 2. Its main feature is that the carry-in has no 
influence on the cargr-out, permitting a cascade of 4:2 cornpressors to perform addition in 
constant tirne (Dadda, 1976). Let us regroup the input bits into two sets of two, to form 
two binary carry-save digits. Moreover, let us transmit the output bit of weight 2 as a 
carrysut to the 4:2 compressor processing the bits of the next higher power of two. The 
second carry-in can thus be output directly, and combined with the existing output bit to 
form a binary carry-save sum digit. As a result, the 4:2 compressor has been transformed 
into a LSD-kt limited-cury binary carry-save adder. Therefore, the 4:2 compressor is also 
a SB adder. 
The systematic development of SB adders for any given SB digit encoding has been 
investigated (Chow and Rabertson, 1978). In that article, it was proven that a SB adder 
comsponding to the 4:2 compressor is one of the three best SB adders in te- 
of delay 
and a r a  Consequently, a 4:2 compressor hardware implementation proposed recently 
waa chosen for subsequent hardware irnplementation of the limited-carry SB adders (Kanie 
et al., 1994). 
2.4.3 
Bit-Serial and Digit-Serial Signed-Binary Limited-Carry Addition 
ArchÎtect ures 
Consider the online limitecl-camy addition of an addend word A to an augend word B given 
W 
W 
A=Coi2-' 
and B = x b i 2 - ' ;  
(a&) 
E {-l,O,l)*, 
(2.76) 
i=l 
'-1 
where the digits a and bi are inputted at time instant i. The resulting sum S ia of the form 
A corresponding bit-serial architecture is s h m  in Figure 2.6. This architecture implements 
Algorithm 14 (page 33) for bit-- 
online addition. The result digit F,-s corresponds 
to the sum digit s, the online error eP corresponds to 4 + 4, but the partial update P' 
m o t  be identifid directly. This architecture bas two modes of operation, ~ilmely, addition 

Ctrl 
Figure 2.6: Architecture for Bit-Serial Online Limited-Carry Addit ion 
initislization and continuing addition. During the addition initialbation mode, one assumes 
that the digits of A and B have been set to zero for all the past time instants. The Ctrl 
signal is set to 1 to select the resulting hardwired initialization carry values. The MSDs al 
of A and bl of B me added to the initialization carry values cl,init and cz,idtr yielding the 
MSD 9-1 of S, in addition to the carries that are stored for use in the next time instant. 
During the continuing addition mode, the digits Q and éi are added to the carries cl and 
c2 formed at the previous tirne instant, yielding the digit si-? and the mies d, and 4 
thst are stored for use in the next time instant. This implies a latency of 2 for the online 
addition (c.f. Section 1.3.2). 
It can be o b s d  that the initialization mode occurs every W time instants. Therefore, 
the Ctrl signal is equal to 1 for the (discrete) time instant n being divisible by W, i.e. when 
It is important to note that the carries formed at the previous tirne instant are discarded in 
the addition initialization mode. By padding both the addend and the augend wit h two zeros 
as theY LSDs, all the digits of accuracy of the sum will be made availsble, and the m i e s  
will be set to their initiahation values (Natter and Nmouzian, 1999). Consequently, the 
switches are not required. Therefore, the cost of padding two zems as the LSDs of both the 
addend and the augend hm to be eompared to the cost of using switches. 
The above adder originatea fiom a very efficient 4:2 cornpressor developed in (Kanie 
et al., l994), where the modifications introduced solely con& 
of wire re-routings. The SB 

input digit a  is represented by a bit pair ('a: a) so that 
The SB input digit b is similarly represented by a bit pair ('b: 
b) so that 
This SB digit encoding was presented in (Lapointe et al., 1993). As in Figure 2.5, a and 
b are combined to yield a E (-2, O), and the output c a q  dl E {O, 1,2} so that Eqn. 2.59 
(page 37) holds. One represents cr by a single bit 'a in accordance with 
a = 2('a - 1); 'a E {O, l}, 
(2.81) 
- 
and dl by a pair of bits ('4: 4) as pet Table 2.4. The 1 , $, - , and . symbols represent 
Table 2.4: Code for cl and dl 
ppp 
ppp 
1 Digit [ Code ('ci *cl) 1 
the Iogic OR., XOR, AND, and NOT operations, respectively. The above bits representing 
a and d, are caiculated in accordance with 
' o = ~ o ~ * a  
~ - ~ t z ~ ( ' a ~ ~ a )  
n'b, 
'4 = ('O e2 
O) $ ('6 $* 6), and 
?4. = e, 
respectiveiy. Then, a and ci are combined to yield /3 E {O, 4) and 4 E (-2, 
O), as given by 
Eqn. 2.60. The representation of 
by a bit pair ('ci: 
ci) is identical to that of 6. One 
represents 
by a siagle bit '/3 so that 
B = 4'8; 
' B  E {O, 1) 
(2.85) 

and 4 by a single bit '4 so that 
These bits are cdculated in accordance with 
- 
'p='cl 
-*ci llcl ^la 
and 
respectively. Finally, P and c2 are combined to yield the SB output s u m  digit s in accordance 
with Eqn. 2.61. One represents s by a bit pair ('9: 
s) so that 
and cz by a single bit 'c2 similarly to 4. Subsequently, the sum digit s is cdculated by 
using 
's =lc* and 2s =' 8. 
(2.90) 
Rom Eqns. 2.82-2.90 and Table 2.4, one can obtain the following bit representations of the 
initialization carry values 
By using Algorithm 10, one obtauis a generic digit-serial architecture of digit-size D for 
signed-binary limiteci-carry addition, as shown in Figure 2.7. At each time instant, D input 
digits are made available in both the addend A and augend B streams at esch time instant, 
resuiting in the generation of D mrresponding digits that are outputted by the sum S 
stream. The signal Ctdi is set when the (discrete) time instant n satisfies 
(n x D + i )  mod W =O, 
(2.92) 
where i corresponds to the singhdigit addition instance number . 

Figure 2.7: Architecture for Digit-Serial Online Limited-Carry Addition 
2.5 
Chapter Summary 
In this chapter, all redundant binary addition schemes have been found and characterized. 
Four of these schemes were previously reported in (Thornton, 1997). All schemes belong to 
two distinct cl-, 
and a t heorem has been given stating that the hardware implementation 
of one of these addition schemes can be used for any addition scheme belonging to the same 
class. The importance of this theorem lies in the facts that, (a) only two classes of three- 
level redundant binary addition schemes exist, and (b) all different implementations of one 
addition scheme can be used for al1 other members of the same class as they share the same 
internal mechanisms. This implies that an addition scheme with input and output digit 
sets {O, 1,2) can be implemented with the same circuit as an addition scheme with input 
and output digit sets {-1,0, l), or with input and output digit sets (-2, -1,O). 
This chapter has also introduced the necessary background for digit-serial online oper- 
ations. The digit-serial unfolding algorithm has been simplified by merging two steps into 
one. Moreover, the digit-serial technique has b e n  extended to the case of a dynamically 
dianging wordlengths. Similanties between number systems have been identifid, which can 
be exploited for design t h e  savings, in particth for redundant binary number systems, 
where the well-documented 4:2 cornpressor has been proven to be a limited-carry signed- 
binary adder. Finally, the proposed techniques have been applied to the development of a 
digit-serial online limited-earry addition architecture. 

Chapter 3 
Theoretical Background for Online 
Signed-Digit Multiplication and 
Mult iply- Accumulat e Operat ions 
Introduction 
With the advent of the commUILication era, digital signal processing is rapidly gaining 
popdarity, mainly because of the flexibility and cost-efficiency of conesponding hardware 
implementat ions. The multiplication and multiply-accumulat e operat ions are essent ial for 
digital signal processors. In such an operation, the resdt R is obtained in accordance with 
where A, B, and C represent the mdt iplicand, multiplier, and addend, respect ivelyl. 
This chapter is concernecl with an introduction to the theoretical background for the 
development of ~~chitectures 
for online signed-digit multiplication and multiply-accumulate 
operationa. The discussions begin with the development of a general algorithm for bit-serial 
online aigned-digit multiply-accumulate operation (Section 3.2). The salient feature of the 
proposeci algorithm is to have the operation depend on one single variable only, namely 
the partial update, while all the other variables are operation-independent. In this way, 
the resulting algorithm can perfonn any operation expressed as a sum of partial operation 
updates in a bit-serial online faShion. Then, in Section 3.3, an architecture unit for the 
mdtipbtion of a signed-binsry word by a binary and a signed-binary digit is presented 
together with a novel signed-biaary to minimnll 
. . 
y redundant base-4 recoding technique. The 
'A muitiplication corresponds to the speciai case of a MAC operation wïth C = 0. 

proposed recoding technique permits a speed-efficient reduction of the number of partial 
updates, substantially increasing the processing speed of a correspondkg architecture. As 
the format of the inputs to such arithmetic operations m o t  be naturally preserved for 
their outputs, the discussions continue in Section 3.3 with a description of the existing 
techniques for the rounding of signed-binary numbers and the ovdow handling in online 
operations. In particular, algorithms are given for pardel low-precision rounding of a 
signed-binary word and for oniine signed-binary rounding-compliant with the IEEE 754 
rounding to nearest /even standard. 
3.2 Proposed Algorithm for Signed-Digit Online MAC O p  
eration 
In this section, a generabed recursion-based algorithm for signed-digit online MAC o p  
eration is developed, where the multiplicand is assumed to be known at the outset, and 
where the multiplier and addend are made available in an online fashion. The resulting 
algorithm obtains an increasingly more accurate online MAC resdt as digits of decreasing 
weight of the multiplier and addend are made available. For the sake of generality, the 
reduadancy indices of the MAC operation operands (Le. the multiplicand, the mult ipiier, 
and the addend) are all assumed to be different. A strategy for the determination of the 
various algorithm parameters is presented. This strategy relies on a bound on the latency 
of the resdting algorithm together with a bound on the Merence between the indices of 
the most significant digits of the multiplier and addend. 
3.2. 1 Nomenclature 
It is assumeci that the MAC operation operands (A, B, C, aad the fmaI MAC result 
R) are represented in a fixeci-point radix-fl ordinary signed-digit (OSD) number system 

(Parhami, 1990) in accordance with 
W,+L-l 
and 
Here W., Wb, WC, 
and W, represent the wordlengths of A, B, C, and R, respectively, 
i., ib, ic, and i, represent the indices of their MSDs, and rfl 5 tla,a,vco 
rh. 5 8 - 1 
represent their redundancy indices. An estimation of a number X is denoted by 2, and 
its truncation by X. The MSDs of A and B can be assumed to have the same weight 8-l 
as made possible by proper scaling in Eqn. 3.1, implying that à, 
and ib are equd to 1. 
Consequently, the parameter i, indiates the relative position of the MSDs of AB and C 
(Natter and Nowrouzian, 2000a). 
For an OSD representation of A, 1. can be calcdated in wcordance with 
Since qa 5 p - 1, one has 
Therefore, the above representations restrict the ranges of the multiplicand A and multiplier 
B so as to permit one to represent AB in the saxne way as A (sfter rounding and overflow 
An online operation is typidy performed in an iterative manner, where the online 
input digits are available one by one, the MSD M. By taking into  coun nt the onüne 
mode of the d v a l  of the multiplier and addend, 
BP 
and cP = 
YS-' 

represent the partialiy formed B and C at iteration p. The correspondhg off-line iterative 
MAC result is dehed as 
The MAC resdt digits are assumed to be available online, fonning an online iterative 
MAC result $ at iteration p as given by 
where 6 represents the latency of the MAC operation. The off-lie iterative MAC result 
can be recursively defineci so that 
where P, represents an oE-Iine partial MAC update (as deterrnined in terms of the newly 
arriving bp and 
digits) at iteration p. By psdding B or C with zeros, one can set 
Wb = WC= 
W, withpe (1, ..., W). 
As formed by the accumulation of off-line partial MAC updates of large wordlength, Rp 
has more digits of accuracy than g,. In this way, $ approwüites Rp with some online 
error ep such that 
The iterative MAC result Rp can be expresseci as a fiinction of k-1 in accordance with 
Rp = RP1 + Fp@-' 
(3.13) 
where pp representts an online partial MAC update. In the following, recursion equations 
are developed, (a) to obtain fi in terms of the off-line partial MAC update Pp and the 
sded online error 
and (b) to determine Fp-s in terms of online partial MAC update 
4 and the online error +. 
3.2.2 
Signed-Digit Onüne MAC Algorithm 
The iterative MAC result Rp is given by 

Therefore, Pp = (Abp + Cie+pb-ie) 
p6 is an off-line partial MAC update value determinecl 
by the newly arriving bp and qe+p digits of the multiplier B and addend C, respectively. 
The bound on Pp is independent of p as it is scaled by the sarne weight ss FP-&, and can 
thus be used as a signal in a corresponding hardware implementation. 
If Eqn. 3.12 holds at iteration p - 1, then expanding R p i  in Eqn. 3.1 1 leads to 
The bound on ep is &O independent of p. By substituthg $ fiom Eqn. 3.10 into Eqn. 3.12, 
one obtains 
Finally, by invoking Eqns. 3.15, 3.16, and 3.13, one arrives at the recursion relationships 
and 
The online MAC result digit Fp-,j is an integer estimate of Pp to within an onüne error cp. 
Roundhg 4 can be restricted to roundhg ep-i& as in (McQuillan and McCanny, 1995). 
The recursion relationships in Eqns. 3.17 and 3.18 can be recast into the following algorithm 
for purely signed-digit online MAC operation. 
Algorithm 19 Online Onlinary Signed-Digit MAC Opemtion 
Step 1 Set p c 1 and €0 c 
O ,  
Step 2 R a d  bp and cie+,,, 
Step 8 Caldate Pp c (Abp + Cic+p~-k) 
B - ~ ,  
Step 4 Caidate 5 t 
e,,43 + Pp, 
Step 5 Round 5 to F',-J, 
Step 6 Calculate ep c fp - F',, 
Step 7 Wnte F,,-J, 
Step 8 Calculate pt p + 1, 
Step 9 I f p  < W + 1, then go to Step $, else donc end if. 

In the above algorithm, after the initiakation of the online error a, the multiplier B 
and addend C are consumed in an oniine fahion. At a given iteration p (1 5 p 5 W), an 
off-line partial MAC r d t  Pp is formed by using the most recent onüne digits of B and 
C. Then, one adds the s d e d  error +ip generated at the previous iteration to the off-line 
partial MAC update Pp, and obtains an online partial MAC update 8. 
Next, an integer 
odhe MAC result digit F',,-& 
is obtained by rounding Fp, giving rise to an online error cp 
(stored for use in the next iteration). 
In Step 5, one can use a truncation of Fp to its first 7 MSDs to perform the rounding 
operation, where 1 7 < Wp 
is d e d  the intemal wordlength, and where Wp 
represents 
the wordlength of the online partial result. In the following, the number system radix P, the 
redundancy indices r)6, qc, qr , r), the multiplicand bound ta, the wordlengths W., W, the 
interna1 wordlength 7, and the relative position of the MSDs of AB and C, 
à,, 
are taken into 
account as user-specified MAC arithmetic operation design parameters for the design of a 
cornespondhg architecture, where a represents the redundancy index of the OSD number 
Tg, 
and where 1. represents the bound on A such that IAl 5 1,. Moreover, Pp, ep, and Fp 
are taken into account as the variables of the MAC arithmetic operation. 
At the last iteration p = W, one has Bw = B and Cw = C. Therefore, 
In this way, & represents the MSDs, and cw represents the hast significant digits (LSDs) 
of R (as desired). 
The correct fuaetionality of the above algorithm has been verified by numerous Matlab 
simulations. It should be pointed out that the algorithm can be modified to perfonn other 
operations, such a0 inner products (Muller, 1994). 
The intemai wordength 7 should be kept srnail, because the deiay of the FPOA hard- 
ware implementation of the estimator in Step 5 is proportional to log&) 
(look-ah& 
operation), or to 7 (ripplecarry operation). Moreover, a low Iatency b allows for the con- 
sumption of the result digits by another MAC architecture after only a small hed delay 
(McQuillan and McCanny, 1995; Lapointe et al., 1993). Findy, negative values for i, have 
been shown to make possible a reduction in the delay of the hardware implementation of 

the singledigit MAC architecture (Natter and Nowrouzian, 20004. The same holds if ic is 
larger than or equal to W,: if i, = W., the addend digit can be padded as the LSD of the 
online error, instead of a zero; otherwise, Si, > W,, 
the addend digit a n  be padded as the 
LSD of Ab,. 
3.2.3 Determination of the Parameters of the Algorithm 
In this subsection, an interrelationship between 7, 6, and i, is derived, and lower bounds 
on 6 and i, are obtsined, (a) to place in evidence the trade-off between these user-specified 
parsmeters for an actual optimal hardware implementation, and (b) to obtain a procedure 
for the determination of the nurnerous design parameters (B, r)b, r),, q,=, v, 
Wo, 
la, 7,6, and 
i,). It is assumed that the number system radix 0 has been k e d  at the outset, implying 
that the redundancy indices are constrained to the range {If] , . . . , P - 1). 
By taking 
into account the f x t  that the redundancy indices can be chosen independently of each 
other, one can optimize the latency of nested MAC operations for subsequent hardware 
implementation. Therefore, it is hirther assumed that the redundancy indices have also 
been fixeci. 
At a given iteration p, the rounding of 8 
to a singledigit integer FPma 
in Step 5 restricts 
the weight of the MSDs of P, and cp-l to $. Let 1, and 1, represent the bounds on ep and 
P,, respectively, so that 
both hold, where equality can be obtained for some ep and P,. Then, for +la + Pp to 
be representable by FPp-& + ep, the bound on Fp before rounding (c.f. Eqn. 3.17) must be 
tighter than the bound on Fp a f k  roundhg (cf. Eqn. 3.18), i.e. 
if Eqn. 3.21 is not satisfied, one may h d  an off-he partial update P, and an online error 
ep-1 such that their eum, 4, cannot be represented as an online result digit and a new 
onhe error ep that can satisfy the desired upper bounds. 
Let us establish the values of the bounds 2, and 1, by introducing an estimation function 
whose main operation involves mmding the real OSD number Fp to the dosest single-digit 

integer Fpa. Consider the OSD number Fp dehed in accordance with 
where Wp 
represents the wordlength of Tg, and where 
represents the redundancy index 
of Fp. In order to reduce the delay of a corresponding hardware ùnplementation of the 
estimation hinction (which depends on the logarithm of the wordlength of Fp), one may 
consider a truncation of F, to its 7 MSDs as given by 
to estimate FP+ The admatage of th.& truncation is to permit a constant-delay estimation 
in a corresponding hardware architecture (Irwin, 1977), but it increases l,, and, conse 
quently, increases the latency 6. Then, the bound on the online error can be calculated by 
observing that the inequaiities 
hold (the corresponding equalities may be obtained for some d u e s  of the online partial 
result). Next, one can calculate the upper bound on the online error in accordance with 
where f is the usual rd-to-integer roundhg error, and where the other term is the bound 
on the tmcated part of Fp. The term -&31-wr 
becomes important when the wordlength 
of the online partial result becomes s m d  (e.g. in addition A = 1 and C = O), because it 
reduces 1, substantUy, permitting the increase of the bound on the off-line partial update. 
However, for practical multiply-accumulation operations, WF 
is large enough to warrant 
ignoring this term. Once @ and r), have been determined, one should minim;le lc so as to 
avoid over-constraining lp. When 7 decteases, 1, increaaes beyond a typical rd-teinteger 
romding error of f , leadhg to an inclteme in the latency of the MAC arit hmetic operation. 
Eqn. 3.21 implies an interrelationship befmen the bounds on ep and Pp which will be 
exploited in the proposed MAC aigorithm to derive a lower bound on the latency 6, with 

the lower bound being dependent on the characteristics of the input operands A, B, and C. 
The foiiowing bounds on 6 and à, 
can be derived only after lp has been detennined. 
Let lPPlmu represent the maximum value of IPpl From the definition of Pi,, one can 
show that 
For an OSD representation of A, la has been calculated in Subsection 3.2.1. For number 
systems other than OSD, one can replace la by the appropriate upper bound, e.g. la = 
2 - 2IwWa for SB numbers as represented in (McQuilIan and McCanny, 1995). Finding the 
maxiinun lp when the intenial wordlength, the upper bound on the multiplicand, and the 
redundancy indices are given yields the smdest latency 6. For purely signed-binary MAC 
operations, all redundancy indices are equal to 1, and 1. = 1 - 2-Wa. A plot of the valid 
bounds on Pp with respect to 6 and i, is obthed as shown in Figure 3.1 for 7 = 4. The two 
UOkmColai~ 
-8 
Figure 3.1: Bound on Pp as a function of d and i, for /3 = 2 , 7  = 4 and L = 1 
solutions for which 1, in Figure 3.1 is mmhurn are obtained as tuples (6, i,) = (3, -1) and 
(a,&) = (2,l). Similarly, for 7 = 3, the m8lcimum 1, is obtained by the tuple (6,i,) = (3,O). 
No improvement on lp is obtained when using 7 = 5 and 7 = 6. This is due to the facts 
that Ip is given by 

and that lp must always be smader than 1 - 1, (c.f. Eqn. 3.21), which in turn implies 
since 1, > f (unless 7 = Ws, 
which is impractical for a large WF). 
Therefme, it can be 
shown that the valid value of 1, nearest to 0.5 is 0.375, if the term -2-Wa-d 
is considered 
as smail. 
By substituting Eqns. 3.27 and 3.26 in Eqn. 3.21, one obtains 
Let us restrict i, to be smaller than W, 
2. In this way, the wordlength of the online partial 
result can be calculated as 
by identifying the weight of its LSD. By manipulating Eqn. 3.30, one obtains the following 
lower bound on the latency 
which is in agreement with that in (Brackert et al., 1989) for 
= r), = q, 
i, = O. Similarly, 
it is in agreement with that in (McQuillan and McCanny, 1995) for 
= 2 (implying l)s = 
r)s=qj=l)r=1)i~=4,ie=1,andla=1 (TC) o r ~ = 2 - 2 l - ~ a  (SB) 
It is important to note that the digit of weight 1 in the proposed representations 
(Eqns. 3.2 thmugh 3.5) must be quai to O, whereas it can be non-zero in the representations 
presented in (McQuillaa and McCanny, 1995). Therefore, the resu!ting latency values fiom 
the two representation types caunot be compared directly, because the representations of 
the inputs to and the outputs fimm the MAC operations are not the same. However9 if the 
addend C is equal to zero, then one can compare the latency values indhctly by scaling 
'Otherwise, the namber of iterations (= W )  
requid by the aigorithm to calahte the MAC result must 
be i
n
d
 
because of the umecessary padding of B and C with too many zeros. 

the proposed result by 2 to obtain the result presented in (McQuillan and McCanny, 1995). 
Subsequently, one can show t hat the two results match exactly, thus proving t hat the latency 
is definitely a relative measupement. It can be conduded that the latency value depends on 
the representations of the inputs to and the outputs fiom the MAC operation. 
When the bound on Abp + 
inmeases, the latency also inaeases to force 1, to 
satisfy Eqn. 3.21. Similarly, fiom Eqn. 3.30, one can obtain this lower bound on i, 
The complexity of choosing 6 and i, in Eqns. 3.32 and 3.34 can be reduced by using the 
C 
same number representation for A, B, C, and R, i.e. by setting q. = q b  = rl, = rl, I 
7, also 
permitting the consumption of k as a rnultiplicand, multiplier or addend in another online 
MAC architecture (Natter and Nowrouzian, 20008). The following strategy can be applied 
for choosing appropriate values for the parameters in Eqns. 3.32 and 3.34. 
(a) Choose the number system d i x  P, 
(b) Choose the redundancy indices, m, 
qc, qr, and r)p, 
(c) Choose the wordength W, of the multiplicand, and the bound fa on A, 
(d) Choose the intemal wordength 7, 
and calculate 6,, 
using Eqn. 3.32, 
(e) Choose the latency 6 2 6,., 
and calcdate ic,, 
using Eqn. 3.34, and 
(f) Choose the relative position of the MSDs of AB and C i, euch that W. 2 i. 2 ic,,,. 
As an example, for a SB online MAC arithmetic operation, @ = 2, la = 1, and a = O, = 
= 
= 1. Consequently, ail the parameters in (a), (b) , and (c) above are fixeci except 
for W, and 7. Let us find valid values for 6 and i, for various values of 7 for Wa = 5. For 
7 = 2, no 6- 
and ic,, 
can be found. For 7 = 3, 6- 
= 3 and the maximum vaüd lp 
bound of 0.25 (represented by IpmJ 
is obtained for ic, = O. Similarly for 7 = 4, one can 
find 6- = 2: if one chooses 6 = 2, then ic, = 1 and Ip- 
= 0.375, and if one chooses 
6 = 3, then ic, = -1 and lp,, = 0.375. No improvement on I p ,  
is obtained when using 
larger values for 7 for the same resson as mentioned previously. 
The parameter ic 
introduced in the proposed algorithm gives rise to additionid flexibility 
in a correspondhg hardware implementation, and may lead to the discovery of nuvei Eister 

MAC architectures. The MAC algorithm can be generalized for the detemination of di 
f i e  functions as such functions can be evaluated by a bounded online operator (Muller, 
1994). This generalization would be obtained by generatuig a different oE-1i.e partial 
update, implying a dinérent lower bound on the latency, but keeping the generd bounds 
on lp and 1, as fixed. 
3.3 Algorit hms and Building Blocks for High-Speed Signed- 
Binary Multiplication Architectures 
Multiplication is obtained as a successive addition of partial products, where a partial 
product is equd to the appropriately scaled result of the multiplication of the multiplicand 
word by a single multiplier digit. An important widespread technique to increaae the speed 
of multiplication involves the reduction of the number of partid products, usudy obtained 
by encoding the multiplier into a diffkrent representation. In addition, the doubleprecision 
representation of a multiplication result must be approximated by a single-precision result, 
thereby requiring rounding and overfiow correction operations. This section is concerned 
with the discussion of a conventional single-digit SB multiplier and a digit dearing unit, and 
with the development of an algorithm for recoding a signed-binary (SB) representation into 
a minimaUy redundant base4 (MRB4) representation having (-2, - 1,0,1,2) as its digit 
set in aa attempt to improve the a r a - t h e  efEciency of the resulting hardware multiplier 
architectures. 
3.3.1 
Single-Digit Multiplier and Digit Clearing Unit 
En an iterative online algorithm for SB multiplication or SB multiply-accumulate operation, 
the multiplication of a SB multiplicand by a SB multiplier digit is required to form the 
off-lùie partial update. However, it is suffident to consider the multiplication of a SB 
multiplicand digit by a SB multiplier digit, and to repeat the operation on every digit of 
the SB multiplicand. 
Consider two SB digits (a, b) E {-1,0,1)* represented by the bits (la: a) E {O, 1)* and 
(lb? b) E {O, 1)* in accordance with 
a='a+*a-1, 
and b='b+*b-1, 
(3.35) 

as in (Lapointe et al., 1993). Then, the product ab belongs to the set {+O, 11, and can 
be represented by a single result digit r as given by 
where the bits 'r and 2r are calculated in accordance with 
'r = ( G V )  
1 ('a A), 
and 
where - , 1 , and - represent the AND, OR, and NOT logic operations, respectively. 
The correct functionality of these equations ean be verified by exhaustive enmeration. 
Digit Clearing Unit 
In an iterative online algorithm, the online error has to be cleared at appropriate time 
instants. As the proposed architectures will employ SB words, the clearing operation is 
obtained by setting each SB digit a of a given sample to algebraic zero when s clearing 
control bit b is qua1 to logic O. Consider the SB digit a E {- 1,0,1), represented by the 
bits ('a: a) E {O, il2 in accordance with 
and consider the control bit Ctrl E {O, 1). Then, the SB clearing unit result digit r belongs 
to the set {-1,0,1), and can be represented in accordance with 
r =' r +2 r - 1, (Ir: r )  E {O, l}* 
(3 .40) 
where the bits Ir and 
are given by 
- 
Ir =' a A Ctrl and 
=* O 1 Ctrl. 
(3.41) 
As a resdt, if Ctrl = 1, then r = a. Otherwise, Ctrl = O implying ' r  = O and 2r = 1, 
which corresponds to t = O, as desired. 

3.3.2 
Signed-Binary to Minimdy Redundant Base4 Recoding Technique 
The well-known modifmd-Booth recoding technique was developed by MacSorley for the 
area-time efEcient multiplication of two's complement (TC) numbers. This rmding tech- 
nique recasts a TC multiplier into a corresponding minimaUy redundant base-4 (MRB4) 
representation having (-2, -1,0,1,2) as its digit set by 3-bit overlapped-scanning. A cor- 
responding &digit overlapped-scanning technique was developed for pardel signed-binary 
(SB) to MRB4 multiplier recoding (Rao and Nmouzisn, 1999). By using a base4 mul- 
tiplier representation, both techniques reduce the number of partial products by half. By 
avoiding the digit values 3 and -3 in the MRB4 representation, the modifiecl-Booth r e  
coding technique reduces the partial product cdculation delay to a constant, whereas the 
&digit overlapped technique mostly reduces the area end delay by a constant fxtor. A 
&digit overlapped-scanning technique is presented in the following, which performs a pax- 
allel SB to MRB4 number recoding by using two successive conversions which are similar 
to addition. The proposed scanning technique ie characterized by three important practicd 
features. Firstly, as for the two previous techniques, the base4 multiplier representation 
reduces the number of partial products by half, increasing the multiplication speed by 
a Eactor of 2. Secondly, as the &digit technique, the scanning technique is available to 
SB numbers. Thirdly, the conversions being similar to addition, a corresponding partial 
product formation architecture employing this multiplier recoding technique exhibits a re- 
duction by half in the asea obtained when employing the &digit recoding technique, at the 
expense of a small increase of the corresponding deiay. The proposed technique adapts the 
d t i n g  binary carry-save (BCS) to MRB4 representation recodhg technique proposed in 
(Kornerup, 1994) to SB representations by exploithg the similarities between the BCS and 
SB number representations. 
Development of an Algorithm for SB to MRB4 Recoding 
Let B represent a SB number of wordlength W given by 

Let us assume that W is even in accordance with 
which can be obtained by padding a zero as the most or least significant digit of B, as 
deemed appropriate. 
The Bdigit overlapped scaMing technique amounts to recoding Eqn. 3.42 into a MRB4 
representation BI'' having (-2, - 1,0,1,2) as its digit set in accordance with 
This recoding consists of three phases, namely, (a) recasting the representation B into a 
maximally redundant base4 representation B' having (-3, -2, - 1,0,1,2,3) as its digit-set , 
(b) recasting the representation B' into a base4 representation B" having {-1,0,1,2,3} 
as its digit-set, and (c) recasting the representation B" into the MRB4 representation B". 
Fhtly, let us recast B into a maximally redundant base4 representation B' given by 
B y  regrouping the odd and even terms of B in Eqn. 3.42, one obtains 
where bi = O for i < 1 and i > W. 
Let 5 be dehed in accordaace with 
for ail j in (1,. . . , W'). Then, 
b; E (-3, -2, -1,0,1,2,3), 
and 

Secondly, let us recast Eqn. 3.45 into a base4 representation B" given by 
W' 
where b) belongs to the set {-1,0,1,2,3}. 
This is achieved through a decornposition of the 
digits 6; into transfe digits sj-1 and weight digits vj in amordance with 
sub ject to 
and 
vj E {O, 1,2,3)* 
(3.53) 
Then, by taking into account the constraints in Eqns. 3.52 and 3.53, it uui be shown that 
Eqn. 3.51 possesaes a unique solution as given by 
and 
where 3 = O for j < 1 and j > W'. Consequently, one can observe that 
In addition, by making use of Eqns. 3.51 and 3.56, Eqn. 3.45 can be written as 
By letting the digits 
be d&ed 
in accordance with 
it follows that 

and that 
Thirdly, let us recast Eqn. 3.50 into a MRB4 representation BItf given by 
where by belongs to the set {-2, -1,0,1,2). This is achieved through a decomposition of 
the digits b$' into tramfer digits tj-i and weight digits wj in accordance with 
sub ject to 
and 
Then, by taking into account the constraints in Eqns. 3.63 and 3.64, it can be shown that 
Eqn. 3.62 passesses a unique solution as given by 
and 
where l$ = O for j < O and j > W'. Consequently, by making use of Eqn. 3.56, one cm 
observe that 
M o m ,  by making use of Eqns. 3.62 and 3.67, Eqn. 3.50 can be written as 

By defining the digits y in accordance with 
b r  = t j  + ~ j ,  
it folîows that 
and that 
as desireci. Therefore, by making use of Eqns. 3.49, 3.60, 3.71, and 3.70 it can be concluded 
that BI'' is a MRB4 representation correspondhg to the SB representation B. 
The above steps can be combined into a &digit overlapped-scanning technique as follows. 
Let a &digit overiapped sr;uining of the sets of digits 
be perfomed successively for j in {O, . . . , W'} to calculate 
where t$ represents a base-4 digit of B' and is defbed in accordance with 
and where the digits bi are assumed to be equal to O for i > W and i < 1. By defining 
the word B'" in accordance with Eqn. 3.44, one obtains a MRB4 representation of the SB 
representation B. 
The proposed recoding technique uui also be viewed as successive digit set conversion 
schemes, as shown in Figure 3.2. This digit set conversion scheme was developed by using 
the technique presented in (Kornemp, 1994), where it was also shown that the digit set 
conversion shown in Figure 3.2 cannot be pdormed by using fewer levels. 
The proposed recoding technique aui also be regardecl as recaating a maximally redun- 
dant base-4 representation, Bf, into a mnrimnlly redmdant one, BIff. The digits 3 and -3 

4tj-1 E {O, 4) 
W j  E (-2, -I,O, 1) tj E {O, 1) 
Figure 3.2: ThreeLevel Signed-Binary to Radix-4 Digit Set Conversion 
are thus awided in the recoded number representation. Multiplication by -2, -1,0, 1, and 2 
can be obtained in parallel by appropriate hardwired shift, zeroing, and negation. However, 
multiplication of A by 3 is the result of 2A + A, which necessitates the addition of two 
words. Therefore, the multiplication of a SB multiplieand word A of wordlength W. by a 
SB multiplier word B of wordlength W usually requires W additions to obtain the desired 
result, whereas recoding the multipiier B into a minimally redundant b a s 4  representation 
impiies the need for only [Tl + 1 additions. 
By recoding the SB multiplier into a corresponding MFtB4 representation, about Bty 
percent of the additions are saved in a LSD-first SB multiplication dgorithm, increasing 
the multiplication speed by a factor of 2. It is important to note that higher base recoding 
techniques exist, but that the additionai gains in speed over the proposed recoding technique 
are smaU (Kornerup, 1994). 
The following pseudo-code implements the propoged recoding technique. 
Algorithm 20 SB to MRB4 Recoding Algorithm 
input: B 
output: B' 
begin 
read B ; 

set & = O  for i < O  and i>w-1; 
set BJ = O; 
for j = O t o  W'; 
begin 
end 
This algorithm can be exemplified by the recoding of the 16-digit SB word 011 1 l0I0llI 1011 O 
into the %digit baae-4 word 00I2ïIi12, where denotes -1, and where 2 denotes -2. 
Implementation of a SB to MRB4 Recoder 
In a hardware implementation of a multiplication algorithm employing an SB to MRB4 
recoded multiplier, 191 + 1 recoders are required, and, since a digit value multiplies 
an entire word, WA (191 + 1) corresponding SB digit by MRB4 digit multipbers are 
required. Therefore, by carefully choosing the encoding used for the outputs of the MRB4 
recoder, one csn rninimize the area and delay of a corresponding SB digit by MRB4 digit 
multiplier. 
The SB encoding given in (Lapointe et al., 1993) is chasen for the input SB digits, as 
s h m  in Table 3.1. If a SB digit bi of weight 2-à is encoded in accordance with Table 3.1 
O 1 and 1 O 

by two bits, ' 
bi and 2bi respectively, then 
bi='&+*k-l 
holds. 
Let us determine the encoding of the digits si, Vj, tj, w,, and b y  . Given their respective 
digit sets, one can code these variables in accordance with 
where 'si, luj, luj, 'tj, 'wj, 2 ~ j ,  negatej, $hi f tj, and zetûj are bits, and t
h
~
~
 
belong to 
{O, 1)- 
The bit shi ftj indicates a multiplication by 1 or 2, the bit zwoj indicates a multipli- 
cation by O or 1, and the bit negate, indicatm a multiplication by 1 or -1, as listed in 
Table 3.2. It can be readily obserwd that the proposed encoding leads to the desired digit 
Table 3.2: Conventions for MRB4 Digit Encoding 
1 code action 1 
1- 
sets. 
The implementation of the fitst lewl is directed by Eqn. 3.51, which csn be translated 
into 
2 
4lSj-i + 2'Uj +2 V j  = 21@j-i + 2 azj-1 +' ~j f 2  ~j + 1, 
which is a binary sddition. 

The implementation of the second level is directed by Eqn. 3.62, which can be translated 
into 
which is a h  a binary addition. 
The implementation of the third level is directed by Eqn. 3.69 in accordance with 
(2negatej - 1) x (shi f tj + 1) x (zeroj) = 2('wj - 1) +2 wj +' tj, 
(3.83) 
which can be obtained by using 
and 
where - , 1 , and - represent the logid AND, OR, and NOT operations, respectively. 
The resulting MRB4 recoder requires a 15 gate-equivalent area, assuming the area of 
a mdtiplexer is the same as that of a gate, and assuming the area of NOT gates can be 
neglected. A subsequent ASIC hardware implementation is therefore more ara-efficient 
than that giwn in (Rao, 1996), for which 25 gate-equivalents are needed. Let us denote 
by t~ and t ~ u x  
the delay through a gate and a multiplexer, respectively. The delays 
requwd to obtain the shi f 9, XWOj, and negatej signais are 4tc + ~ ~ M U X ,  
4tc + 3 t ~ u x ,  
and 3 t ~  
+ 2tMuX, respectively. If t ~ u x  
is s s s d  to be equal to tc, then the delay of 
an ASIC hardware implementation is only larger than that proposed in (Rao, 1996) by one 
gate delay. 
Implementation of a mixed SB/MRB4 Digit Multiplier 
A mixed SBJMRB4 multiplier takes three digits as inputs: taro consecutive digits e-1 and 
Q of the SB mdtiplicand word A, having weights 2-*l 
and 2-$ respectively, and one digit 
of the recoded MRB4 multiplier word Br", represented by the signais shift,, rmoj, and 
negate j. 

The SB r d t  of the multiplication of A by t$' 
is denoted by R, where the bits represent- 
ing the digit Ti+*j of weight 2-i-2j 
can be expressed in tenao of the inputs in accordance 
with 
and 
A conesponding ASIC hardware implementation r e q h  a 6 gate-quivalent area, and its 
deiay is the maximum of t~ + 2 t ~ u x  
and 2 t ~  
+ t ~ u x  
This area is much smaller than the 
12 gate-equivalent area requked in (Rao, 1996). 
3.4 Rounding and Overflow Handling in Online Arithmetic 
Operat ions 
The result R of an arithmetic operation very often belongs to a range that is difTerent from 
that of the input(s). If R must be fed to the same unit s3 an input, then the problem 
of fitting the result into the desired input format cornes into play. In more down-teearth 
terms, the weights of some LSDs are too small, and those of some MSDs are too large, and 
R has to be re-represented in the desired format by taking ail these digits into account. 
The format fitting problem can be subdivided into two problems of different nature, 
referred to as rounding and d o w  handling. Rounding, de& with in Subsection 3.4.1, 
hds the closest number having no LSD of lower weight than desired. Subsection 3.4.2 
is concerneci with overflow handling, which determines whether the value of R belongs to 
the desired range, and corrects the representation accordingly. If the magnitude of R is 
too large (dm), 
then the new representation corresponds to the largest (positive or 
negative, as appropriate) valid value: this is referred to as saturating the representation of 
R.. 
3.4.1 
Roundhg of Signed-Binary Words 
The wordlength of the r d t  R of the multiplication of a multiplicafld of wordlength W by 
a multiplier of worlength W is at least kger than ZW, 
as can be observed when calculating 

0.1 x 0.1 = 0.01. If this r d t  is to be used as an input to another operation requiring 
the same format as the input multiplier and multiplicand, then R has to be rounded. 
The IEEE 754 standard indudes a d a t i o n  of the roundinggt~nearest/up (RNU) and 
the roundinggto-nearest/even (RNE) techniques (Santoro et d., 1989; Rao, 1996). In the 
following, a short description of the RNU and RNE rounding techniques WU be given. 
Then, an algorithm for online IEEE 754 SB RNE rounding will be presented. Finally, a 
specific low-precision rounding operation is dedoped, which is requird in online arit hmet ic 
operations for estimation of the online result digit. 
IEEE 754 RNU and RNE Raunding Techniques 
In both the RNU and the RNE rounding techniques, the exact result R of a multiplication 
must be rounded to a lower-precision word hd 
which minimbes the absolute distance 
d(R, &a) 
gi- 
by 
By scaling R and 
appropriateiy, one can assume that hnd 
& an integer, and thus that 
t 
holds. The RNU standard stipulates that Ld 
must be equal to the integer nearest to R, 
and in the case of a tie (e.g. -1.5, 
-0.5, 0.5, or 1.5), kd 
m u t  be equal to the lowest 
integer larger than R (Santoro et al., 1989; Rso, 1996). The RNE standard differs from the 
RNU standard only in case of a tie: &,,d 
must then be equal to the even integer neazest to 
R (Santoro et al., 1989; Rao, 1996). 
Algorithm for IEEE 754 RNU and RNE rounding of SB numbeni have been developed 
in (Rao, 1996) and will be explainecl briefly. The exact result R is decomposed into its most 
significant word R- 
and its least significant word Rb in sccordance with 
Then, one can observe that Rh is given by 

where Wh represents the wordlength of Rh. In this way, Rh consiats of a s u m  of a digit 
rl with a lead signifkant word &, in accordance with 
One can observe that R b  represents a &actional number that belonga to the set (-1,l). 
where W- represents the wordlength of &. 
Again, R,, 
consists of a sum of a digit 
ro with a most signifiant word R- 
in accordance with 
FinaLiy, by considering the sign and magnitude of both ri and 2h, it is possible to de- 
termine whether Rh belongs to one of the five sets [-1+2-W.w, 
-OS), { - O S ) ,  (-0.5,0.5), 
(0.51, and (0.5,l-2-fi.]. 
Therefore, an algorithm parsing the 9 cases (3 for ri, foiiowed by 
3 for Zhu) is suniuent to perform the RNU rounding technique for a SB number. Similarly, 
the RNE rounding technique can be perfomed by an algorithm that takes into account 
the sign and magnitude of both si and R b ,  
as well as the magnitude (and not the sign) 
of ro. These rounding algorith genenrte a round digit which uui be added to R,, 
for correction. 'Ihbles providing the round digit values for all the possible cases, and the 
corresponding algorit h m  have been presented in (Rao, 1996). 
In a corresponding hardware implementation, the sign and magnitude of a word are 
repreaented by sign and sticky bits, respectively, by using the following conventions 
and 

as in (Rao, 1996). Then, the round digit to add to & 
for correction is represented by 
two bits in accordance with 
round =' round +2 r a n d  - 1; ('round: round) E {O, 112. 
(3.100) 
Similady, ro and ri are both represented by two bits in accordance with 
ro =' ro +2 ro - 1; (lr0? ro) E {O, 112, 
and 
1
2
 
rl =' rl +2 rl - 1; ( 71, rl) € {O, II** 
(3.102) 
Next, round is caiculated by using the foIlowing booleaa equations - 
lround =' ri A 'r1.(sticky - Iro e2 ro 1 sticky A sign) 
(3.103) 
- 
= 'ri 1 2 t l  
(stickg - Iro $* r0 1 sticky A sign), 
(3.104) 
where - , 1 , $, and - denote the AND, OR, XOR, and NOT logic operations, respectively. 
Online Algorithm for IEEE 754 SB RNE Rounding 
Consider an iterative oniine algorithm for &thmetic operation with iatency 6, 
and effective 
wordlength Wg 
3. The symbols relating to the arithmetic and the rowiding operations are 
m k e d  by using "opn and "rndn subscripts, reepectively. Then, one must r
d
 
Eqn. 3.12 
(page 51), where the online operation remit &,, is combined with the online operation 
error c W ,  to yield the off-Une operation result %p, in accordance with 
In this way, there must Bast an iteration number po such that %p,po represents EIQP,M,,,, 
and c p o p b ~ - ~  
represents &,*, One cm calculate the desired round digit at any iteration, 
and dear it, unless p = po. Of course, the online =or of the online arithmetic operation 
has to be deared at iteration po + 1. Otherwise, oonline arithmetic operation resdt digits 
of l
m
 
signiIiance wiIl be generated, dthough they have been taken into account in the 
' ~ h e  effkdive wordlength is d&ed as the wordlength augmenteci by the nnmber of psdded zero digits 
noeded to match the wordlength of the online roopded operation d t .  
73 

round digit already. At any given iteration p, the online arithmetic operation result digit 
F&,,p-~op is added to a round digit round,i-sop. 
This digit is either equal to the round 
digit round obtained by performing the SB RNE algorithm on e V ,  at iteration pa, or to O 
otherwise. Consequently, it is sufncient to modify the online addition Algorithm 14 (page 
33) so that it incorporates the calculation of the round digit before its addition to the online 
result digit. The resulting algorithm performs the desired SB RNE rounding of & in an 
online fashion. 
Algorithm 21 OnZine IEEE 754 SB RNE Rounding 
Step 1: Set p t 
2 and r,d,l 
t 
O, 
Step 2: Set ro t 
Fp-,+ 
and Rb, t r , ,  
Step 3: Caictllute rnd,+ 
&y perfonning the SB RNE rounding algorithm on ro and 
Rh; 
Step 4: If p = po + 1, then d c d a t e  
t ~md,p-l-60p?-Sd, ebe ca~ctùote 
t 
(6nti,p-1-6~~ + mdp-1-6op) 2-6vnd, 
Step 9: Ston c d , ,  
Step 10: If p < Wfl+ 2, then go to Step 4, ebe done. 
In the above algorithm, the online error p starts at 2 to account for the unit-delay 
between the arrival of the bt input digit to the arithmetic operation and the departure 
of the corresponding output result digit. If the arithmetic operation is the addition (cl 
Subsection 2.4, page 34, then the SB input digits ai and bl are co~lsumed at iteration 1, the 
SB sum digit r-1 is generated at iteration 1, and d
e
 
avaüable to the rounding operation 
at iteration 2. This dehy results in latching the operation result digit in a corresponding 
hardware implementation. The oniine ermr (corresponding to the carries ci and c2 of a 
limited-carry addition, cf. Subsection 2.4.3) is initialized to O. Then, at a given iteration p, 
a round digit rdps, is determinecl in accordance with the SB RNE algorithm presented 
in @ao, 1996). Next, the oaline arithmetic operation resdt digit Fw,,l-a, 
is added to the 

round digit if the iteration is equd to po + 1, and O otherwise. The resulting off-üne partial 
update Pmdtp is combinecl with the scaled o&e 
error 2
~
~
,
~
-
~
 
caldated at the previ- 
ous iteration, yielding the online partial rounding r d t  FMp. F W y ,  the onLine partial 
rounding result is approximat ed t O the online rounded result digit Fmd,,,-i 
thus 
fonning an online error 
(the carries d, and 4 of a limited-cany addition). The round- 
ing operation is finished when the iteration number is larger than the dective wordlength 
of the input plus one digit. 
The latency of the proposed rounding operation is equal to that of addition, i.e. 
It is important to observe that 
This is due to the faet that 6rnd online result operation digits equal to zero have been 
introduced to flush the online rounded operation digits. As a result, the o d b e  rounding 
enor does not need clearing when operations are processeci one after another (Natter and 
Nowrouzian, 1999). 
Low-Precision Rounding for Cdcuiation of a SB Online Result Digit 
At any given iteration p of an online algorithm, one must round an online partial resuit pp 
to an online rasult digit Fe&. This rounding technique men, greatly fiom other rounding 
techniques such as the IEEE 754 standard RNU and RNE rounding techniques described in 
(Santoro et a., 1989; Rao, 1996). First, Pp is truncated to its firat 7 MSDs before rounding, 
where 7 is referred to as the i n t d  wordlength of the online operation. Second, the output 
of the rounding operation îs an integer that must belong to a restricted output remît digit 
set. if the result is represented in a SB format, then the digit set is {- 1,0,1). 
The ht clifference resuits in a degradation of the closeness of the rounded resdt to 
the exact r d t ,  which may, in tum, cause true d o w  in the oniine operation. In other 
words, the wordength of the online partial result may prove to be too large, yielding more 
than one online result digit, and thus requiring the change of an onlbe result digit that 
has &eady been generated at a previous iteration. However, a careful determination of 

the internal wordlength together with the latency of the operation, which are commonly 
refmed to as the online algorithm parameters, solves this problem. 
Mer careNly determining the online algorithm parameters, the second digerence can 
only cause unnecessary (but correctable) overfïow, which can solely occur with redundant 
repr-tations. 
Of course, F p 4  muet represent the nearest integer to Eg. h e v e r ,  in the 
case of a tie, it is mandatory to choose the digit value closest to O if the online result digit 
risks to be chosen out of the d
d
 
digit set. 
It is important to note that the above rounding principle for oniine algorithms is appli- 
cable to any radix-P OSD number system. An algorithm causing the unnecessary ovedow 
can be found in (Owens, 1980), where the online digit r,-8 is given by 
sign 
where 7 represents the redundmcy index of the OSD number representation of the online 
result, where sign(.) represents the sign of its argument, where min(.,.) represents the 
minimum d u e  of its arguments, where 1.1 represents the magnitude of its argument, and 
where r.1 represents the result of the RNU algorithm on its positive argument. 
In case of a SB number system, it is desired to obtsui an algorithm which rounds a 
SB number to the nearest integer, but in the case of a tie, chooses the integer closest to O. 
In this way, an online partiai result equal to 1.5 is rounded to 1, which is an allowed SB 
digit value. One can use the decomposition of Eqn. 3.91 to determine the desired rounding 
procedure. 
Let us distinguish between t h m  cases corresponding to the three possible d u e s  of ri: 
If ri = -1, then two sub-cases need consideration: 
- If Rh < O, then Rb < -0.5, and one must choose round = -1. 
- If 
2 O, then RI, 2 -0.5, and one must choose round = 0. 
If rl = O, then one must al- 
choose round = 0. 
If ri = 1, then two sub-cases need consideration: 
- If &,,,, > O, then RI, > 0.5, and one must choose ruund = 1. 

- If Er, 5 O, then Rt, 5 -0.5, and one rnust choose round = 0. 
These results are siimmai;Red in Table 3.3. 
Table 3.3: Low-Precision Rounding of SB Numbers 
The above table ean be implernented by generating a round digit round, represented 
algebraically in accordance with 
round =' round f2 round - 1, 
(3.109) 
where the two bits b u n d  and *round c m  be cakulated by the following boolean functions 
- 
'round =' ri - 'ri - sign, 
'round = sign - stidry - Irl 1 *ri, 
where sign and sticky are as described for the IEEE 754 RNE rounding technique, and 
where ri is represented algebraically in accordance with 
Then, the round digit is added to Rmw to yield &. In order to avoid the generation of 
a non-desired carry, this addition must be obtained by letting the carry propagate through 
the two digit positions of highest weight. 
Let us develop a SB carry-propagate adder combining only one input digit a with a 
cany-in q,,, and generating a sum digit s and a carry-out digit h t .  The SB digit a and 
the SB camy-in 
can be expressed 83 follows 
2 
a='a+ 
a - 1  and cin=1qn+2Gn-l, 
(3.113) 
where ('a? a) E {O, 11, and where ( l  eml 
ei,) E {O, 1). Then, addition occurs in accordance 
with 

where k
t
 E (-1, O, 1) and s E (-1,0,1) can be expressed as follows 
where ('s,%) 
E {O,l), and where 
E {0,1). The k
t
 digit must always be 
equd to O, unless both a and c, are different from O, thereby avoiding the possible writing 
of 1 as 2 - 1 or -1 as -2 + 1. The corresponding boolean equations are as follows 
and 
- 
2 s = ' a 1 2 ~ ~ ( l b $ 2 b ) 1 2 a - ( ~ - ' a ~ 1 b - % ) ~ 2 b ~ ( ~ ~ 1 b ~ 1 a  
,*a), 
(3.119) 
where - , 1, @ and - denote the AND, OR, XOR, and NOT logic operations, respectively. 
Finally, the proposed low-prdion rounding must al30 generate a least significant word 
RlaW,,, that, when added to hs, 
yields R again in accordance with 
where R is given by Eqn. 3.91. In other words, 
muet hold. In thh way, it is suEcient to h d  a digit ri,n, satisfying 
If round equals O, then no correction is necessary. Otherwiae, one csn observe that ri 
is always exactly opposite to raind. Therefore, the correction of the digit r' consists of 
multiplying it by -1 when round is Merent from zero. This is obt ained by set t ing 
2 
'ri,nm =' +I @ ('t=ound $* round) and 
rh,, =* ri @ ('round e2 round), 
(3.123) 
where 

holds. 
An extension of the proposeci rounding technique to larger radices and redundancy 
indices consiets of obtaining the onliae result digit in accordance with 
In this way, only a RNU aigorithm is requked for estimation of the online result digit, 
as opposed to a RNU algorithm and a operation calculating the minimum value of its 
arguments. The complexity of a correspondhg hardware implementation is thus lowered. 
Since the estimation function is the bottleneck of any architecture for onhe arithmetic 
operation, this reduction in complexity has important practical advantages. It c m  be 
observed that the "even" event in the RNE standard becomes irreievant in odd bases, 
because the decimal d u e  0.5 cannot be obtained exactly. 
3.4.2 
Overfiow Handling in Online Arithmetic Operations 
The result B of an online arithmetic operation with latency 6 is given by 
but is desired to be represented in accordance with 
such that Rd, = 
where W represents the wordlength of the desired format, where 
/3 represents the d i x ,  and where [g] 5 7 5 p- 1 represents the redundancy index. 
The fmt representation must thus be corrected in order to fit the desired format of the 
second representation. The extra MSDs of the first representation may induce too large 
a value for R to be corrected. This situation is d e d  a true o d o w  (Timrnermann and 
Hoetidsa, 1993; Rao, 1996). If these extra MSDs represent a non-zero -due, and if2 ean still 
be repzesented in the desired format, one reférs to the situation as a correctable overflow 
(Tirnm- 
and Hosticka, 1993; Rao, 1996). Finally, there is no d
m
 
when these 
extra MSDs represent 0. 

Rules to determine and handle overfiow situations have been developed in the signed- 
binary case in (Woods et al., 1993; Timmermann and Hosticka, 1993; Lapointe et al., 1993; 
Rao, 1996). They are extended to the case of an OSD number system in the following. 
Necessary Condition for OSD Number Correctability 
Let us decompose 
into its most significant word & 
and its l w t  sikaificant word Rb, 
in accordance with 
where 
and where 
In this way, E,, 
represente the o d o w  number, and &,, represents the truncation of fi 
to the desireci format. 
Theorem 22 If Emnu represenb c mmctablc ovetpow, then Rmw cun take on any of the 
foltowing thne Jorn: O . .  .OIl)o.. . r)o, 0 . .  .O, or O . .  .Oh&. . . %, where r)o = - 1, and 
where @ npmsenttz -70. 
Proof. The proof of this theorem can be established aRer proving the foilowing three 
lenimas. 
I 
ia ta nawsory and nficient andition for 2 to be representable as given in Eqn. 9.127. 
Proof. If 2 can be represented in the desired format of Eqn. 3.127, then Eqn. 3.131 
hoids, and is thus a necessary condition. 

Converseiy, if 2 is represented in the typicai format of Eqn. 3.126, and if Eqn. 3.131 
holQ, then &IW is an integer whose range belongs to the representabie range of the format 
given in Eqn. 3.127. Since an OSD number system is complete, 
can be represented in the 
desired format. 
Lemma 24 ~f &-, 
r e p ~ e n b  
a correctable oveflow, thcn the componding value belongs 
to the set {-1,0,1). 
Proof. Let us assume that the (integer) value of fi,, 
does not belong to the set 
{-1,0,1) and that 
represents a correctable o d o w .  Then, one can observe that 
Rh, by itself, satisfies Eqn. 3.131. Next, by caidating the extreme values of R, one 
obtains 
and 
Since 13 2 2 and q 5 /3 - 1, it f o h s  that 
Consequent ly, 
contradicting the Eact that fi represents a correctable ovdow, and complethg the proof. 
Lemma 24 is an extension of when 8- containe one or two SB digits and the operation 
is addition (Timrnermann and Hostida, 1993; Rao, 1996). 
Lemma 25 Let r]o = ,6 - 1 and 
= -m. An hteger npnsentation of O in any OSD 
number qptern is of the fonn 00 . . 
.O. If r) = m, fhen integer reprwmtations of - 1, und 1 
in an OSD number ~ $ t e m  
of ndundaney indez q are of the f o m  00.. . Oïmrlo.. . q~, 
and 
00 ... 
...%, 
mpectiuely. If q < m, then the corresponding USR integer number 
npnsentutions of -1 and 1 h m e  00.. .oI, and 00.. -01, mpdively. 

Proof. The representation of the value O in any OSD number system is of the form 
00.. .O. To prove this, consider the representation & of O given by 
where fi represents the radix of the number system, and where 
5 r) 5 B - 1 represents 
141 
the redundancy index of the number system. Let us assume that a,io is different from O, 
where io belongs to the set (1 - 6,. . . ,O). 
Of course, the integer part of &@O 
forms its 
most si@cant 
word, and must be a correctable ovdow. Otherwise, it can be readily 
observed that & cannot be equal to O. Then, by applying Lemma 24 to the integer part of 
&p, 
the corresponding value rnust belong to the set {-1,0,1). However, the magnitude 
of the hctional part of &/3Q 
is strictly smaller than 1 (c.f. Lemma 23 and t) 5 B - 1). 
Therefore, & m o t  be equal to zero, establishing the proot 
Let us consider a SB representation 
of 1 given by 
Then, consider the index 1 - 6 5 io 5 O of the non-zero digit of large& weight. By choosing 
il in {ào, io + 1,. . . , O) and by applying Lemma 24, one has 
By observing that 
= 1 and by taking il = io, it can be readily concluded that FI,, = 1. 
It is very important to observe that if q < @ - 1, then io 
= O. The proof is estabiished 
by aseuming that io c O and by obsenting that io 5 O must always hold. In this situation, 
the d e s t  value g-- 
that can be represented by 
is given by 
which can be recast into 
Since 9 < p- 1, &w+ > 1, and & 
cannot be equal to 1, leading to a contradiction. 

Next, let us prove by recurrence on il that when r) = B - 1, the following mat hematical 
proposition is tme for io + 1 5 il 5 O 
which cas be written as 
Since Filia = 1, one can obtain Fl,h+l, 
satisfying proposition Pi,. 
If Pi, is valid for io + 1 5 il 5 - 1, then let us prove that Pi, +i is algo valid. In this 
way, it is sufficient to prove that fi,i,+l 
= -(B - 1). One can replace il by il + 1 in 
Eqn. 3.142 to obtain 
which, since Pi, is valid, becomes 
and restricts the value of q,i,+l 
as necessary. 
This establishes the proof by recmence. 
The proof for the representation of -1 is obtained by observing that -1 = 1 x (-l), 
and that any OSD number system har a balanced digit set. 
The proof of Theorem 22 can now be estabiished. 
Proof. If &- represents a correctable d o w ,  then Lemma 24 implies that & 
represents -1, O, or 1, and Lemma 25 further determines the representation of g-, 
es- 
tabiishing the proof. 

Oniine Algorithm for Overfiow Handling in OSD Number Systems 
The algorithm developed in thie subsection extends the existing work on algorith and 
architectures for overfiow detection and correction in signed-binary representations (Woods 
et al., 1993; Fernando and Ercegovsc, 1992; T i e r m a n n  and Hosticka, 1993; Lapointe 
et ai., 1993; McQuillan and McCanny, 1995; RBO, 1996). Moreover, it is shom that the 
online detection and correction of aa d o w  in the most signifiant part of an OSD rep 
resentation is siinplifieci by the use of Theorem 22. 
One must recast the representation of 
as given by Fqn. 3.126 into the desired format of 
Eqn. 3.127. Then, at a given iteration 1 p < W + 6 of the algorithm for online arithmetic 
operation of latency 6, the oaline operation result $ is defined in accordance with 
Next, kp must be recast into an online corrected result Ls 
as @en 
by 
The online error between the onhe correcteci result and the oniine operation result is 
defineci in accordance with 
Fmm Theorem 22, q, can only take on the following five values: -OVF, -1, 0, 1, OVF, 
where OVF and -0VF denote positive and negative ovdow values, respectively. In the 
case of an o d o w ,  the digits of k - 6  must be saturateci to r) or -r), dependhg on the 
sign of the d m .  
A saturation function sat(x, y) can be defined in accordance with 
where min(., .) and =(., .) represent the minimum and maximum values of th& argu- 
ments, respectively. T b  funfunetion wili be uaed for the determination of the online corrected 
result digit. An absolute value of E, equsl to 1 indicates a potential o d o w ,  which may tnrn 
into a tnie d o w ,  or into no o d m  at di (Timmermann and Hosticka, 1993; Rao, 1996). 

Similar to the oniine MAC algorith, an online partial correction result 8 
is calcdated 
as foUows 
and mmt be translated into a corrected digit F,',,p-a such that 
holds, dess E,,- 
1 indicates an ovedow. If + equah OVF or -O VF, É, 
must be set to the 
same positive or negative ovedow, and Fh,p-a must be set to q or -q, in accordance with 
Lir 
the sign of the overfiow. It is important to observe that if 4 - 1  = O, then Fde;*,,p-& = +a, 
and no correction is necessary. The case 
1 = 1 must be explained in more detail. 
Let us observe that if eP-l = 1, then the situation is that of a potentid ovedow. If 
LI 
Pp = q + 1, then one can only choose cp = 1 and ?&p-6 
= I) in order for Eqn. 3.151 
to hold. However, if Fp > 7 + 1, then it is not possible to fmd any valid combination of 
online error and o n h e  corrected result digit for Eqn. 3.151 to hold. Therefore, one must 
set fdesP4 
= 7 and ep = OVF. F W y ,  if pp < r) + 1, it is aiways possible to find c, = O 
.c. 
and F&,6 
= Pp-6 so that Eqn. 3.151 holds. It is thus possible to combine the cases 
gp = q + 1 and Fp < q + 1 ttogether. Moreover, it cm be observed that if a potential 
overfiow becomes a true overfiow, then the previously generated MSDs have saturated to 
their correct values. It is very important to note that the calculation of the online corrected 
result digit corresponds to that of pp ssaturated to q. If cP-l = -1, then it is sutficient to 
invert the signs of the above calculations. 
Since F,8,p-s must be set to O for O 5 p 5 6, one can distinguish between two different 
ph- 
in the online overfiow handüng process. The b t  phase corresponds to O 5 p 
6, 
while the second phase corresponds to 6 + 1 5 p 5 W + 6. In the k t  phase, one constrains 
the desired o n h e  remit digit Fdu,p-s to be equal to 0, h t h e r  irnposing that 4 = Fp. As a 
consequeme, an overflow d u e  must be generated as soon as 5, reaches a value outside the 
digit set {-&O, 
1). If the first non-zem online operation result digit does not belong to the 
set {-1,0,1), 
then o d o w  occurs, (cf. Theorem 22). In the case of a potential ovdow, 
tme o d o w  ocnirs if Fps is Merent fkom 8 - I or 1 - fl (whichever is appropriate), (c.f. 

Theorem 22). In the second phase, the desired onüne result digit is not constrained to be 
e q d  to 0, but tme, potential, or no ovdow situations can be considered as rnentioned 
previously. 
Algorithm 26 Ontine Oveflow Handting for OSD Repmentatiow 
Step 1 Set p + 1, and €0 + O, 
Step 2 Read Ga, 
CI 
Step 4 If p 5 6, then set &d,p-& c O else set fdertP-,f 
c sat(Pp, q) end 
rr 
Step 5 If (Pp - ?&p-6) > 1 (true if ep-l = OVF), then set ep t OVF eise if (4 - 
k , p - d  
- 
< -1 (tme i f  ep-1 = -OVF), 
then set ep t -0VF elae aet ep e 
Pp - fdcs,p-6 end 
Step 6 Set p t 
p +  1, 
Step 7 If p < w + 1, then go to Step 2, else done end if. 
In the above dgorithm, each digit of the online operation result is read one by one, the 
MSD k t .  Its value is then combined with that of a scded online error in an online partial 
resdt Fp, where the scaed online error may indicate an o d o w .  A digit Fk,,p-a of equal 
weight to that of the input online operation result digit is either set to O for the h t  6 
MSDs, or obtained by saturating the online partial result value to -7 and 7, as required 
for the desired OSD format. Saturation occurs when overfiow is indicated by an overflowed 
online error, or in a potentid overflow situation. The resulting online error is determined 
as the subtraction of the odine partial result 8, 
but where an absolute d u e  of 6 
strictly 
larger than 1 yieds an overflowed online error. Finally, the iteration number is updated. 
As one cari observe, the online error takes on 5 different values, namely -OVF, -1, 0, 
1, and OVF. Of course, -1 and 1 correspond to a situation of potential overfiow. As a 
result, three bits are required to represent the online error: OVF indiates an overflow by a 
logic 1, POVF indicates a potential d o w  
by a logic 1, and S indicates a strictly negative 
potential or true o d o w  by a 1. Then, a table for the conversion of OVFp, POVFp, and 
Sp into tp is given in Thble 3.4. Next, ep is obtained recursively in accordance with 

Table 3.4: Conversion of OVFp, POVF,, and Sp into eP 
- 
where , - , and 1 represent the NOT, AND, and OR logic operations, respectively. 
Overflow Situations in Online Arithmetic Operations 
The type of overflow handled by the proposed dgorithm assumes that the online operation 
result is accurate. However, this may not be the case in an algorithm for MAC operation. 
If the result is fed back as the addend, then the value of the accumulation may overfiow 
its fixed-point representation. This results in a feedback of the accumulation value as an 
initialization value of the online =or that exceeds the upper bound on the online error. This 
situation ofien occurs in digital filters incorporating online arithmetic operat ions (Brackert 
et al., 1989; Ercegovac and Lang, 1989; Fernando and Ercegovac, 1992; Lapointe et al., 1993; 
McQuillan and McCanny, 1995). 
It is important to note that two different operations make use of the redundancy of the 
representation of their result, namely constant-delay addition and online processing, thus 
both may generate correctable overflow. As a result, the online partial result may itself 
require overflow correction. This is due to the fact that the addition of the online error with 
the off-line partial update is obtained by a constant-delay adder. 

It has been found that algorithms ean be developed to correct an ovedow if a result R 
represented in accordance with 
is known to belong to [-1,1] or [-1.5,1.5], where W represents the wordlength of the 
corrected result (Timmerm- 
and Hosticka, 1993). If one assumes that 8 will belong to 
the range [-1.5,1.5], being the result of the addition of a SB addend A of wordlength W 
represented in accordance with 
with a SB augend B represented in accordance with 
then it is possible to avoid generating the correctable overflow altogether by restoring the 
cany propagation during the addition of the two k t  MSDs of the result Fo md fi. This 
is due to the facts that, (a) during a cary propagation, a carry can only be created if the 
absolute value of the sum of the input digits (whose weight is assumed to be 1) exceeds 2, 
(b) true overflow ( 7 4  = 6 both equd to 1 or -1) cannot occur because of the restriction 
of the range of fi, and (c) potentid overflow ( L i  equal to -1 o r  1 and ro = O) cannot 
occur. It uui be readily shown that (a) and (b) are valid. To show the vaiidity of (c), one 
can consider six cases, three of which are negatives of the other three. Then, FI is either 
qua1 to 1 or to 0, and R cannot belong to the desired range, or 6 equals -1, which cannot 
occur by forcing the carry to propagate. 
3.5 
Chapter Summary 
Zn this chapter, a g e n d  algorithm has been developed for bit-serial online signed-digit 
multiply-accumulate operation. Its predominant salient feature consists of novel operation- 
independent variables, which permit the development of a bit-serial online algorithm for 
any operation as long as it can be expressed as a sum of partial operation updates. 

A novel signed-binary to minimally redundant base4 recodhg technique has been in- 
troduced, which permits a more speed-efncient reduction of the number of partial updates, 
substantially increaaing the processing speed of a co~esponding architecture. Digits ap- 
pear in excess in both the least and the most signifiant parts of the results of such o n h e  
operations. Therefore, algorithms have been presented for online signed-binary IEEE 754 
standard for rounding to nearestleven and online signed-digit ovedow handling. 
One MAC operation has been developed: the multiplicand A is known at the outset, 
the multiplier B and the addend C are made avaüable in an online fashion. By using a 
multiplicand known at the outset, one reserves the possibility to increase the wordlength 
of B without increasing the hardware requirements. Moreover, the wordlength of A can be 
inaessed as desired, since the delay of a conesponding architecture does not depend on it. 
If A were consumed in an online fashion, then an inmemental multiplication technique 
wouid be required (c.f. (Irwin, 1977)). In this situation, the partial MAC update is formed 
as the addition of two words of wordlengths linearly increasing with the iteration number. It 
is important to note that, although these wordlengths increase, the delay of a corresponding 
implementation is still a constant (Limited-carry addition). Therefore, since the hardware 
requhements cannot be infinite, a msximum wordlength for A and B must be set. 
One MAC operation has been developed: A is known at the outset, B and C oniine. 
By using a multipliamd known at the outset, one reserves the possibility to increase the 
wordlength of B without increasing the hardware requitements. Moreover, the wordlengt h 
of the multiplicand A can be increased as desired, since the delay of a conesponding archi- 
tecture does not depend on it. 
If A were input in an online fashion, then the incremented multiplication technique 
would be required, c.f. Irwin. In this situation, the partial MAC update is formed as the 
addition of two words of linearly inmeashg wordlengths. It important to note that, although 
these wordlengths inuease, the delay of a corresponding implementation is stiU a constant 
(limited-carry addition). Therefore, since the hardware requirements cannot be infinite, a 
maximum wordlength for A AND B must be set. 

Chapter 4 
Architecture for Online 
Signed-D igit Digit- Serial 
Multiplication 
4.1 Introduction 
Digital signal processing algorithm often require the accumulation of numerous multi- 
plication results. A multiply-accumulate (MAC) operation can efficiently perfonn such 
operations by returning a non-rounded intermediate result R in accordance with 
where A represents the multiplieand, B the multiplier, and C the addend. Then, the 
intermediate result R is fed back as the addend C for accumulation. 
In Chapter 2, the digit-seriai and online arithmetic techniques were described, and 
efficient sddition architectures were developed. Chapter 3 discussed the IEEE 754 SB ELNE 
rounding technique. This chapter is concerned with, (a) the development of an algorithm 
for digit-serial purely signed-binary online multiplication employing the IEEE 754 RNE 
rounding technique, (b) the development of a mrresponâing ~~chitecture 
for subsequent 
FPGA hardware implementation, and (c) the cornparison of the gatelevel speed and area 
performances of the proposeci architecture to d i n g  simüar architectures, illustrating a 
combination of the digit-serial and online arithmetic techniques. 
Section 4.2 introduces the bit-serial purely signeci-binary online multiplication and the 
bit-serial online IEEE 754 SB RNE rounding algorithms in a data strearn context. Sec- 
tion 4.3 combines the above bit-serial online algorithms into a single digit-serial algorithm 

for purely signed-binary digit-serial online multiply-and-round operat ion. Section 4.4 d e  
scribes a corresponding architecture for subsequent FPGA hardware implementation. Fi- 
nally, Section 4.5 presents simulation results to demonstrate t h t  the resulting architecture 
is bctionaily correct, discusses a throughput improvement via re-pipelinhg (Rao, l996), 
and compares the resulting architecture to existing simüar architectures by measuring their 
respective t hroughputs and &ciencies1 using speed aad area gate-level est imates. 
4.2 Algorithm for Bit-Serial Signed-Binary Online Multipli- 
cation 
This section is concerned with the development of an algorithm for bit-seriat signed-binary 
online multiplication. A data stream-based framework is used, which will permit the trans- 
formation of the bit-serial algorithm into a corresponding digit-serial algorit hm wit hout the 
need for an architecture or for a digit-serial unfolding algorithm. 
Consider a stream A of SB multiplicands of wordlength W. whose digits are made 
a d a b l e  in pardel, i.e. ail digits of a word are a d a b l e  at a given time instant. Similady, 
consider a stream B of SB multiplier words of wordlength Wb and effective wordlength 
Wb,=# (cf. Subsection 3.4.1) whose digits are made available in a bit-serial online fashion, 
i.e. digit-by-digit, the MSD bt. These two data streams will be combined to obtain 
the output stream Ld 
of EEE 754 SB RNErounded multiplication resuits of effective 
wordlength Wb,,p The onüne multiplication operation has a latency Jml, and the online 
roundhg operation has a latency Ld. 
The bit-pardel stream of SB multiplieand words A of wordlength W. is represented by 
Wa 
sequences e,nn20s 
where i belongs to the set {1,2,. . . , W.), 
and where n represents the 
time instant. At time instant n, the multiplicand word is given by 
where w represents the operation number and is given by 
'The efne*ncy is caicuiated as the quotient of the heughput and the area of a given architecture. 
91 

Given that Wbteff 
consecutive values of n yield the same operation number w, the mul- 
tiplicand digits of the w-th operation must be made available Wb,d time instants in a row. 
Therefore, for sqy w E N, for any i E (1,. . . , W,), 
and for any p E (2,. . . , Wb,& 
must hold, where p represents the iteration number of the w-th operation in accordance 
with 
One can observe that w and p - 1 represent the quotient and remainder of the division of 
n by Wb,eff, 
respectively, and thus satisfy 
The bit-serial stream of SB multiplier digits B is represented by a sequence (bn)n>o, 
where R belongs to the SB digit set {-1,0,1). 
The w-th SB multiplier word Bw can be 
defined in accordance with 
where w belongs to N, and where p not only represents the iteration number (as before), 
but also the index of the conespondhg multiplier digit in the w-th multiplier word. 
The non-rounded SB online multiplication resdt stream amd 
of effective wordlength 
Wb,cB is represented by the SB sequence (FmGn)n>or 
- where Fmdtn E {-1,0,1). 
By using 
Eqns. 4.3 and 4.5, the *th SB non-rounded online multiplication result word g m d , u  ca.n 
be d&ed in accordance with 
It is important to observe that at iteration p, the online multiplication result digit of weight 
Finally, the IEEE 754 SB RNErounded online multiplication result stream kd 
of 
e t i v e  wordlength Wbte# ki represented by the SB sequence (Fmd,n)not where Fmdtn E 
{-LO,l}* 

Let us recall that the d-th online rounding operation happens between iterations 2 
and Wb,eB of the wf-th online multiplication operation, and at iteration 1 of the w' + 1-th 
online multiplication operation (cf. Subsection 3.4.1). Therefore, the d-th SB IEEE 754 
SB RNErounded online multiplication result word 
is defined in accordance with 
where the word number w' is given by 
and where the index p' is given by 
p' = 2 + (n - 1) mod Wb,eg. 
(4.11) 
Together, wf and p' - 2 represent the quotient and remainder of the division of n - 1 by 
Wblef, and thus satisfy 
Again, it is important to note that at iteration p', the online rounded multiplication result 
digit has a weight 2 h ~ * ~ r d - d .  
Given the repetitive nature of the definition of the bit-seriai streams, the operations 
on the input data streams have to be repeated every WblQ time instants. Therefore, it is 
sufEcient to consider the multiplication of a single multiplicand A by a single multiplier B 
to yield a single oniine multiplication result R, conespondhg to a MAC operation where 
C = 0, but the notion of tirne mut be taken into account to schedule initializations as 
necessary. The algorithm devdoped in Subsection 3.2.2 can thus be used as a bit-serial 
online multiplication algorithm, but must be modifieci so as to be compatible with the dgo- 
rithm describeci in Subsection 3.4.1 for onüne IEEE 754 SB RNE rounding. Subsequently, 
the resulting online multiplication and rounding algonthms caa be applied successively to 
perform the desired online multiply-and-round algorithm. 
Let us perform the required modifications to the bit-serial o n h e  mdtiplication dg* 
rithm. The result digit of weight 2-Wb is generated at iteration po = Wb 
+ JmJ. Therefore, 

the scaled online error must be deared at iteration po + 1. Moreover, the effective wordlength 
of B is detezmined by taking into account the latencies Jmd of the multiplication opera- 
tion and ad 
of the rounding operation. In this way, the multiplier digits having indices 
wWb,cff + po + 1 thmugh wWbtce + Wb,g - 1 must be set to the algebraic d u e  O, where 
w E N, and where the effective wordlength 
is given by 
IR Subsection 3.4.1, the rounding operation latency Jmd was calculated to be equal to 2. 
The latency Jmd of the online multiplication operation will be determined shortly. 
Algorit hm 27 Bit-Serial Signed-Binary Online Multiplicution With Online Emr Cleanng 
Step 1 Set p t 1, 
Step 2 Set amdo + O, 
Step 3 Read bp, 
Step 4 Calculate PmdVp t 
&bp2-&m*, 
Step 5 If p = po + 1 then set ~k$>c~ 
t 
O ebe set e s $ l  t 2 ~ ~ d ~ p - i  
Step 6 Calculate fmdp t em%+-, 
+ Pp, 
4. 
Step 7 Round Pm4P to Fm4p-~,,,dl 
- 
Step 8 Cairnlate rmdVp 
J, Pmdtp - fm*p~,,,d, 
Step 9 write 
Step 10 Calculate p + p + 1, 
Step 11 Ston emap, 
Step 12 If p > Wb,efft 
then go to Step 9, else done. 
In the above algorith, the iteration number p is init ialized to 1, and the online multipli- 
cation error at the iteration previous to 1 (i.e. O), cm40, is initialized to O. Then, an off-line 
partial multiplication update 
is calculated, and the scaled online multiplication error 
at the previous iteration, em%fPl, ki eit her set to the value of the online multiplication error 
at the previous iteration ern4,+1 multiplied by 2 (i.e. scaled up by one digit position), or 
deareci if the iteration number is equal to po + 1. Next, Pm4p and emT,","l 
are combined 
to form an o n h e  partial multiplication r d t ,  FmdSt which is rounded to a singledigit 
integer fm4p-6,,,d referred to as the o d h e  mdtiplication r e d t  digit. This low-precision 

roundhg (c.f. Subsection 3.4.1) yields a new online multiplication enor 
Finally, the 
online multiplication error am4p is stored for use in the next iteration, the iteration number 
is updated, and the process is repeated. The multiplication operation is complete when the 
iteration number is strictly larger than the effective wordlength Wb,CB. 
Let us introduce the notion of time (as opposed to the notion of iteration) back into the 
proposed algorithm. At a time instant n corresponding to an iteration 1 of the proposed 
algorithm, the online error should be cleared. However, since 8m$,$ is set to zero in the 
previous multiplication operation, and since the digits of B at all the following iterations 
(po + 1, through Wb,u- 1) are equal to zero, the online multiplication error remains equal to 
zero during these iterations. Therefore, the new multiplication operation does not require 
a chring of the online error, except at the fkst time instant. 
The intemal wordlength y can be deterrnined leading to the latency Jrnd of the algorithm, 
and yielding the latency of the multiply-and-round operation. For SB numben, the radix P 
is equal to 2, implying r), = q~ = % = r), = 1, where r), = O for a multiplication operation. 
The bound lA on the absolute value of A, can be calculated to be equal to 1 - 2-Wa. As a 
result, the bound on the off-line partial multiplication update l p  is given by 
which leads to a lower bound on the latency Jmdtmin given by 
It am be seen that the minimum value that can be chosen for 7 is 3. If7 = 3, then 6md = 2. 
As the latency of the online rounding operation 6rnd is equal to 2, the effective wordlength 
of the 
4.3 
multiplier becornes 
Extension to a Digit-Serial Signed-Binary Online Multiply- 
and-Round Algorit hm 
Bit-serial (BS) operations process one digit of a data stream per BS time instant n E PI, 
whereas digit-serial (DS) operations process D consecutive digits of the sarne data stream 

per DS t h e  instant nt E N. Since D consecutive digits of a given data stream correspond 
ta D consecutive BS time instants, a DS algorithm consists of D paralle1 sub-algorithms 
(numbered d E {O, 1, . . . , D - 1)) invoking one iteration of the BS algorithm. Of course, all 
the D parallel sub-algorithms interact with each 0th- to yield the desired resuit. Conse- 
quently, DS t h e  instant/sub-dgorit hm number pair (n', d) corresponds exactly to the BS 
time instant n as given by 
Moreover, a word number/iteration number pair (w, p) or (w', p') &O corresponds exactly 
to one particular BS time instant (cl. Eqns. 4.6 and 4.12). These unique decompositions 
of the BS t h e  instant are at the root of the (sometimes complicated) equations underlying 
d DS sub-algorithms. 
The resulting algorithm for DS SB oniine multiplication and rounding is given below. 
Algo rit hm 2 8 Digit-Serial Signed-Binary Online Multiplication and Rounding 
Step 1 Set n' t O, 
Step 2 Read bDnt, bDnt+i, . . . , and bonl+D-i, 
Step 3 For d in (O, 1,. . . , D - 1) do, 
Step $.a Calculate UJ + Le] 
and p c 
1 + (Dn' + d) mod 
Step 9.6 Perfonn rteps Y thmugh 9 for itemtion p of the Oit-aerial online mul- 
tipliootion algorithm, moking use of the multiplicond word A, and the 
multiplier digit bDnt+d. 
Step 9.c Calculate w' t le] 
and d t 
2 + (Dn' + d - 1) mod 
Step 9.d Perform steps d thmugh 'Ifor itemtion d of the bit-se7ial online round- 
ing algorithm on the d-th online multiplication result, 
End 
Step 5 Calculate n' t n' + 1, and go to Step 2 
At a given DS t h e  instant n', D consecutive digits of the BS multiplier digit sequence 
are read, sepaxatecl, and consumeci by the D BS algorithm invocations (or sub-algorithrns). 
The word nambers w and w' and iteration numbers p and p' are calculateci as given by 

Eqns. 4.3, 4.5, 4.10, and 4.11, by calculating the BS time instant n from the DS time 
instant nt and sub-algorithm number d in accordance with Eqn. 4.17. These numbers are 
subsequently d 
to determine the set of elementary operations that must be performed 
at the given DS time instant to perform the invocation of the desired iteration of the BS 
algorithm. It caa be observed that the word number w may be different for two invocations 
of the BS algorithm at a given DS tirne instant nt, i.e. two or more operations may be 
computed in the DS algorithm at a given tirne instant. The number of operations being 
computed in the DS algorithm is s d e r  than two if one chooses D 5 Wb,* 
In the BS algorithm, the onluie enor generated at the BS time instant n is consumed as 
the online error at the previous iteration at the BS tirne instant n + 1. Fkom the uniqueness 
of the decomposition of the BS time instant n into a DS time instant n1 and a sub-algorithm 
number d, it follows that an online error generated by the d-th BS algorithm invocation 
at the nt-th DS time instant is used as an input by the (d + 1) mod D-t h BS algorithm 
invocation at the n'-th DS time instant if d belongs to the set {O, 1, . . . , D - 2). However, if 
d = D-1, then (Dna+d)+l = Dnt+D whichcan be re-written as Dnf+D = D(nl+l)+O. 
Therefore, the oniine error generated by the D - 1-th BS algorithm invocation at the n'-th 
DS time instant must be stored for use by the 09th BS dgorithm invocation at the nf+ 1-th 
DS time instant. Similady, the online result digit and online multiplication enor generated 
by the D - 1-th BS multiplication algorithm invocation must be delayed by one DS time 
instant, and be fed to the O-th invocation of the BS rounding algorithm. 
Let us denote by L the le& common multiple of D and Wb,,& Then, consider the BS 
time instants O to L - 1, and caldate the DS time instants and sub-algorithm numben at 
which a given iteration p* occurs. If one ansumes W b , , ~  
= 3, D = 2 -yielding L = ô-, 
and p* = 1, then iterstion p* occurs at BS time instants O and 3. The corresponding DS 
time instant and sub-algorithm number pairs are (0,O) and (1,l). Moreow, at DS tirne 
instant 2, iteration p* does not occur. Next, let us repeat this process for BS time instants 
L to 2L - 1. Iteration p8 o c m  at BS t h e  instants 6 and 9. The corresponding DS time 
instants and subalgorithm numbers are (3,O) and (4,l). Moreover, at DS t h e  instant 5, 
iteration p* does not occur. One can o b s m  a cyclic pattern, which emerges from three 
dineent decompositions of the BS time instant into a quotient and a remahder. The b t  

two decompositions use the dective wordlength W&,g 
as the divisor to obtain the word 
numbers (tu and w'). The third decomposition uses the digit-size D as the divisor to obtain 
the DS time instants (n') . 
One can make use of the above cyclic pattern by observing that some invocations do 
not require performing a particular iteration of the BS algorithm. In the above example, if 
p* = po + 1 and if p* = 1, then iteration po + 1 is never performed by the sub-algorithm 
number 2. As a result, the conditional clearing operation need not be performed for the 
subalgorithm number 2. More generally, if a conditional statement is tme only for a given it- 
eration, and if that iteration is not performed under a given sub-algorithm number, then the 
translation of that sub-algorithm to a corresponding architecture does not require translat- 
ing the conditional statement. Step 3 of the simplified DS unfolding aigorithm (c. f. Subsec- 
tion 2.3.1) calculates the DS time instants and sub-aigorithm numbers at which conditional 
statements must be performed, and uses the results to determine which conditional state- 
ments need to be irnplemented. This technique has been used in many occasions to reduce 
the hardware requirements (Parhi, 199 1; Satyanarayana and Nowrouzian, 1996; Rao, 1996). 
One can calculate the DS tirne instances and subalgorit hm numbers for iteration 1 in 
accordance with 
where i successively takes on d 
the values kom the set {O, 1, . . . , 'w 
- 1). Simiiarly, 
the DS tirne instants nt and subalgorithm numbers d corresponding to iteration po + 1 can 
be calculated in accordance with 
where i successiveiy takes on all the values fiom the set {O, 1,. . . , '"'D'Wb*eff) - 1). If Wb& 
Wb, rfl 
is not a constant, i.e. if it changes dynamidy, then Algorithm 13 (page 29) can be used 
for the on-thefly determination of the control bits indicating the desired iterations. In that 
situation, one must have D < Wb,eF 

4.4 Architecture for Digit-Serial Signed-Binary Online Md- 
tiplication and Rounding 
In this section, the proposed digit-serial algorithm is translatecl to a corresponding archi- 
tecture for a subsequent FPGA or ASIC hardware implementation. 
The resulting architecture consists of three main types of units, namely, multiplicand 
select ion units, online multiplication uuits, and online roundhg units as shown in Figure 4.1 
for generd values of the digit-size and wordiengths of the multiplicand and multiplier. 
1 
1 1 
MuIlipikation Unit O 
t- 
Multiplication Unit 1 
+-pz#'- 
1 
1 
1 
Multipiication Udt D - 2 
I
I
I
 
Multiplication Unit D - 1 
Figure 4.1: Architecture for Digit-Serial Online Multiply-and-Round Operation 
The architecture contains two types of control signals, nnmely RNDd and N Wd. First , 
the Unew wordn signal NWd indicates iteration 1 (i.e. a new operation) in the d-th online 
multiplication invocation when it is set to the logic value O. The DS time instants and sub- 
aigorithm numbers correspondhg to these iterations are given by Eqn. 4.18. Second, the 

"round" signal RNDd inàicates iteration po + 1 (i.e. the iteration for rounding) in the d-th 
onüne multiplication invocation when it is set to the logic value O. The DS t h e  instants 
and sub-algorithm numbers corresponding to these iterations are given by Eqn. 4.19. 
The d-th online multiplication unit and the d-th multiplicsnd selection unit implement 
S teps 3 through 9 of the BS algorithm for online multiplication (c.f. Algorithm 27, page 94). 
Similarly, the d-th oniine rounding unit implements Steps 2 through 7 of the BS algorithm for 
online IEEE 754 SB RNE rounding (c.f. Algorithm 21, page 74). The d-th multiplication 
selection unit coasists of a mdtiplexer controlled by a 
signal, and a logic gate 
performing an AND operation between s e l e ~ t ~ , ~ - ~  
and a signal NWd if d > O. The units 
wili be described individually in the following subsections. The critical path2 of the proposed 
architecture is shown in bold iines. One can observe that a signal xd carries the variable 
value x ~ a + d  at the DS time instant nt. 
Now, let us describe how signals flow in the above architecture. As a new multiplicand A 
is made available, the d-th selection unit (O 5 d 5 D-1) selects the appropriate multiplicand 
to be fed to the d-th multiplication unit. Then, the multiplicand A, the multiplier digit bd, 
and the online error cmd,d -whose value is controlled by RNDh 
are combined to yield 
a resdt digit Fd and a new oniine error c m d d + i .  Of course, emul,d+i is fed to the o n h e  
multiplication unit (d+ 1) mod D, 
and if d = D - 1, then the online error c m d , ~  
-generated 
by the multiplication unit D - 1- is delayed by one DS time instaat. A delay by one DS 
tirne instant is obtained by feeding a signed-binary si& 
to a register reg," where each 
digit of the online error is assigned a pair of D-type flipflops (DFFs). The input signals 
are latched on the positive edge of a dock signai, and the output s i p h  of every pair of 
DFFs in the register are initiaked to 01 (code for algebraic O) by a general active-low teset 
signai. 
At t h e  instant n', the online multiplication result digit 
and the o n h e  multipli- 
cation enor c*u(<~+I are fed to the onüne rounding unit (d + 1) mod D. Ag&, 
if d = D - 1, 
then the results are deiayed by one DS tirne instant. Afterwards, the d-th online rounding 
unit combines these values with that of the input online rounding error, and generates an 
2 ~ h e  
criticai path of an architecture corresponâs to the path of longest delay betl~een an input and an 
output of the architecture 

onüne rounded result digit Fdd and an online roundhg ermr e,qd+i. 
This online error is 
fed to the online rounding unit (d + 1) mod D. As before, the online error of the rounding 
unit number D - 1 must be delayed by one DS time instant so as to be fed to the rounding 
unit O appropriately. The signal Gqd 
at the DS t h e  instant n' carries the variable value 
F ~ n ' + d *  
4.4.1 Multipiicand Selection Unit 
If one assumes D < Wb,efl, 
the iterations perfomed by the D online multiplication units 
belong to two separate multiplication operations at most. As a result, it is sutlicient for one 
to make available in peralleI the new multiplicand value A, and to delay that value for use 
in the next DS tirne instant. Consequently, one reduces the multiplicand wire requirements 
from D x W. to Wa 
(by a factor D). The following gives a description of the corresponding 
architecture. 
Let us assume that at a given DS tirne instant nt, the control signal NWd, (O 5 do 5 
D - 1) is equal to logic O, indicating that the do-th online multiplication unit performs the 
f h t  iteration of an operation. Then, the online multipiication units 1 through do - 1 must 
use the stored value of the multiplicand, while the online multiplication units & through 
D - 1 must use the new multiplicand A. This selection is obtained by setting selection 
control bits s e l e d ~ , ~  
through ~ e l e c t ~ , ~ , , - ~  
to logic 1, and selectA,0 through sel edAVgqi to 
logic O. This is obtained by setting 
and by setting 
for aii d in {1,2,. . . , D - 11, where'represents the logic AND operation. These operations 
are expliutly s h m  in Figure 4.1. Findy, the routing of the appropriate multiplicand value 
to the conesponding online multiplication unit is obtained by multiplexers. 
4.4.2 
Online Multiplication Units 
An oonlie multiplication unit implements all the elementary operations required at any 
iteration of the proposeci aIgorithm for bit-serial online multiplication. The corresponding 

architecture is shown in Figure 4.2. This unit f a t u m  an addition/low-precision rounding 
A 
bd 
c r n u  
RNDd 
Limited-Carry Addition 
b 
Low-Precision 
Roundhg 
1 
y - 1 MSDs ' 
t 
h , d  
Cm4d+l 
Figure 4.2: Architecture of an Online Multiplication Unit 
core unit that can also be utilized for operations difkent from multiplication. The resulting 
added practicd advantage originates fkom the design of the o n h e  algorithms in terxns of 
operation-independent variables. 
The mdtiplication of the multiplicand word A by the multiplier digit bd is performed by 
an array of singledigit muhipliers (cf. Subsection 3.3.1). Then, the result is scaled down 
by Jrnd digit positions to yield the off-line partial multiplication update 
Next, the 
online error a,4d 
i9 deazed if RN& ie equd to logic O (c.f. Subsection 3.3.1), s d e d  up, 
and then a zero digit is padded as its LSD, r d t i n g  in ~d~$$~. Zero digits are padded as 
MSDs of 
to confom to the form&t of 8m$t. Subsequently, the em$$ is added by 
cascaded limited-carry adders to PmGd to generate an oniine partial multiplication result 
It is important to remember that the addition of the last two MSDs is obtained 
by carry-propagate adders (cf. Subsection 3.4.1), while the other digits are combïned by 
using hiteci-carry propagation adders (c.f. Subsection 2.4.2). 
Furth=, the 7 MSDs of 
are taken for low-preion rounding to the online multiplication resdt digit TmuIId 
(cf* 
Subsection 3.4.1 ) , generating the MSDs of the online multiplication error Em4d+l- The 

LSDs of the online partial multiplication result form the LSDs of the online multiplication 
error. 
The addition and low-preeision rounding uaits can be can be merged into a single core 
unit for the implementation of other recursive SB online operations as, for example, online 
rounding units (Natter and Nowrouzian, 2000b) (c.f. Subsection 3.2.2). Of course, the 
wordlength of the online partial update may dBer fiom operation to operation, subsequently 
necessitating the adaptation of the wordengths of the onüne error and the onfine partial 
result . 
4.4.3 
Online Rounding Units 
AR online rounding unit implements aJl the elementary operations required at any iteration 
of the algorithm for bitoserial online rounding. The proposed architecture is shown in 
Figure 4.3. 
FmuCd Cld,d+~ 
Round Digit 
Generator 
Figure 4.3: Architecture of an Online Roundhg Unit 
The oniine multiplication error and result digit are used to generate an IEEE 754 SB 
RNE round digit, as described in Subsection 3.4-1. The round digit is cleared (set to the 
algebraic value O) if RNDd is equal to logic 1, as opposed to O for the online multiplication 
error in the onüne multiplication unit. Therefore, it is always cleared, except at iteration 
po + 1, i-e. when the online multiplication error represents the LSDs of the final online 
multiplication result. Then, the round digit and the online multiplication remit digit are 

added to the input carries (representing the online roundhg error) by a iimited-carry adder, 
generating an o x h e  rounded digit and new mies. The carries of the D - 1-th adder are 
stored for use in the next DS time instant by the O-th adder. 
4.5 
Computer Simulation Results and Performance Cornpar- 
ison 
The correct functionality of the proposed architecture is c o b e d  by computer simulations. 
Then, its speed and area performances WU be rnessured, and subsequently compared to 
t hose of exis t h g  architectures. 
4.5.1 
Simulation Results 
In the following, simulation results are given to confirm the correct functionality of the 
proposed architecture. The wordlengths of the muitipiicand and multiplier have both been 
chosen to be equd to 8. The latencies of the online multiplication and rounding aigorithm 
are both equd to 2, as determined previously. Two values of the digit-size, 2 and 3, have 
been chosen for the demonstration of the correct functionality under varying digit-size 
values. In this way, the same test vectors will be applied to two different implementations 
to verify t heir correct functionality by comparing their outputs against the expected results. 
A VHDL code implementing the proposed architecture was developed by using MaxfPlus 
II, compiled by using the underlying Synopsys FPGA Design Compiler into a target FPGA 
referenced as EPF 10K20 RC24û-4, and simulated by using Max+Plus II. 
The multiplicand, multiplier, and remit values as expressed in decimal are iisted in 
Table 4.1. Both the full-prechion (A x B) and the expected IEEE 754 RNErounded (Rmd) 
results are given. The corresponding signed-binary values of the multiplicand, multiplier, 
and expected rounded result are listed in Table 4.2. The simulation results, as expressed 
in hexadecimal values, are shown in Figure 4.4, and correspond to a digit-size of 2. The 
correspondence between hdecimal and signed-binary values is listed in Table 4.3. 
In order to verify the results, it is important to remember that the signed-binary input 
and output representations flow in an online Eashion, Le. the MSD k t .  Moreover, the 
MSD of the result of the first operation appears at the BS time instant 1 (the h t  BS t h e  

Tabh 4.1: Test Vectors for Digit-Serial Multiply-Round Operation in Decimal 
Table 4.2: Test Vectors for D igit-Serial Muit iply-Round Operat ion in Signed-Binary 
A 
1 
B 
1 
A x B  
Figure 4.4: Simulation Results for D = 2 and W, = Wb = 8 
&mi 
instant is O), corresponding to the DS time instant O and the sub-algorithm number 1 in 
the above simulation results. 
The same vectors have been applied to a proposecl architecture with digit-size 3, as 
shoam in Figure 4.5. Rom both simulations, it aui be concluded that the results are as 

Table 4.3: Hexadecimal to Si ed-Binq Conversion Table 
I*I 
Figure 4.5: Simulation Results for D = 3 and W, = Wb = 8 
expected, and that the htnct ionality of the proposed architecture is thus correct. 
4.5 .2 Throughput Parameter kat ion and hnprovement Via Re-Pipelining 
The delay dong the aitical path, shown in bold lin= in Figure 4.1, will be calculated 
in terms of the multiplicand wordlength and the digit-size. The critical path originates 
fiom the LSD of the newly latched multiplicand. Then, a signal following the critical pat h 
goes through a selection unit and a singledigit signed-binary multiplier. Next, the signal 
propagates diagody (becsuse of the scaling of the online error) through D -2 ümited-carry 
adders and D - 3 oniine error dearing units (or O if D < 3). Further, the signal goes through 
an IEEE 754 SB RNE round digit generator, and one limited-carry adder in the D - 2-th 

online roundhg unit. Finally, the signal propagates through one limited-carry adder before 
reaching the o&e 
rounded remit digit Fm4D-i 
in the D - 1-th online rounding unit. 
Two components are dominant in the above critical path, namely, the Iunited-carry 
adciers in the multiplication units, and the IEEE 754 SB RNE round digit generator. The 
h t  component is due to the unfolding of the bit-serial architecture. In fact, consider the 
digit-serial unfolding of a mere bit-serial full-adder with a digit-size equal to the wordlength. 
The result is a bit-parallel carry-propagate adder, whose critical path is stretched across the 
digit-size (Rao, 1996). However, in the pmposed architecture, the required IEEE 754 round- 
ing of the result stretches the critical path across the horizontal direction for computation 
of the sign and sticky bits. 
Let us find ways to improve the throughput of the proposed architecture. One may 
reduce the delsy through the critical path by employing a look-ahead technique for the 
computation of the sign and sticky bits. Another solution, proposed in (Rao, lW6), is to 
re-pipeline the proposed architecture. Re-pipelining consists of cutting the critical path in a 
given architecture into sub-paths of approximately equal length and introducing latches in 
the nit locations. The signals are thus transmitted fiom one set of latches to the next, the 
delay on the critical path now corresponding to a fraction of the original critical path. As a 
resdt, the throughput of the architecture is increased considerably. However, one needs to 
wait for as many clock cycles as there are pipelinhg stages to obtain the output, and the 
area of a corresponding ASIC hardware implementation is considerably increased. 
Because of the non-homogeneity of the proposed architecture in the MSD part of the mul- 
tiplication unit, it is quite complicated to offer a parameterized solution to its re-pipelining. 
Therefore, only the pipeline cut delivering the minimum delay is described. The proposed 
architecture is shown in Figure 4.6, w here the re-pipelining cuts are shown in vertical dashed 
Lines, where Wa = 5, and where D = 4. It is important to point out that the selection units 
have not been represented to simplify the figure. The selection units are located just before 
the single-digit multipliers, between two pipe cuts. In this way, only A, its delayed version, 
and the aeledAç control bits have to be pipelined, instead of A. thmugh AD-l. 
Figure 4.6 is manged as Figure 4.1 in order to identify each component with its cor- 
responding unit. A square box with a &+" inside represents a LUnited-carry adder. An 

Figure 4.6: Re-Pipelined Architecture for MAC Operation and IEEE 754 RNE: Rounding, 
with W, = 5 and D = 4 

octagona3 box with a "+" inside represents a carry-propagate adder. A square box with a 
&Cn inside represents a single-digit clearing unit. A square box with a x" inside represents 
a singledigit multiplier. A rectanguiar box with a 'Sn inside represents a sign and sticky 
computation unit. Finally, a rectangular bax with "LP ROUNDn or "IEEE ROUND" rep 
resents a unit generating a low-precision or IEEE 754 SB RNE round digit, respectively. 
It c m  be observed that the LSD to MSD direction of limited-cany addition, implemented 
using 4:2 cornpressors (Kanie et al., 1994), has been used for the accumulation of partial 
multiplication updates, because re-pipelining can be applied intuitively. However, the MSD 
to LSD direction of ümited-cany addition has been used for the addition of the round digits 
with the result digits to suit the description of an algorithm for digit-serial online addition 
(Natter and Nowrouzian, 1999). 
A digit of weight 2-' of the online multiplication error c m d ~  
is fed as a digit of weight 
2-'+' 
of the online multiplication error cm&* two DS time instants aRer being generated. 
The longest delay T between two re-pipelining cuts is obtained in accordance with 
This longest delay results îkom the combination of one clearing unit, two carry-propagate 
adders, and an IEEE 754 SB RNE round digit generation unit. There are W. + Jmd + 2 
pipelinhg stages. A result of effective wordlength Wb,cff 
is thus obtained in W. + cfrnd + 
+ 1 DS time instants. 
4.5.3 
Area Parameterization 
The proposed architecture makes use of a number of elements desaibed in the previous 
chapters. The area requirement for gate-level implementation is given in Table 4.4. 
Some reductions in the hardware requirementci are possible. First, one need not calculate 
the cany-out digit of the esrry-propagate adder generating the MSD of FmJ,d. Second, 
one can use the sign and stidry bits generated for IEEE 754 roundhg as sign and sticky 
bits for low-precision rounding, thereby a h  allowing a reduction in the latency of online 
multiplication. As a r d t  of these reductions, the total ares of a corresponding ASIC 
hardwaze implement at ion of the proposed re-pipelined architecture can be caiculated in 

Tâble 4.4: Area Requirement for the Multiplication Architecture 
Unit 
1 
Area 
1 
Number of Units 
1 
accordance with 
A = (12~: + 72DWa + 12DJmd + 1680 + 12Jmd + 29)a, + (6DW. + 2LGrnd + 8 D ) h m .  
(4.23) 
where ag and h, represent the area of a gate and a multiplexer, respectively. 
4.5.4 
Performance Cornparisons 
Let us assume r, = lns, rmu2 = 1.5ns, a9 = 25pm2, and a,= = 37.sPm2. Moreover, let us 
assume that W. and Wb have the same value denoted by W (to simplify the comparisons) . 
Then, the throughput H of the proposed repipelined architecture is obtained by using 
Limiteci-Carry Adder 
Carry-Propagate Adder 
Low-Precision Rounding 
Multiplier 
Clearing 
Selection 
Next , the efnciency of an arehit mure 
D  
H=- 
WT' 
(4.24) 
is calculated as the quotient of its throughput and its 
4 
13 
b-7 
- 
2 
D - 1  
total ana. It is extremely important to note that neither the latency of the onüne operation 
nor an estimate of the power coneumption of a correspondhg hardware implementation is 
taken into account in the above aciency calculation. 
The proposed re-pipelined architecture is compared t O the repipelined architecture for 
LSD-kt digit-serial multiplication and IEEE 754 rounding of bots complement numbe~~ 
proposed in (Rao, 1996). The main differences between these architectures are, (a) the 
2 
2 
- 
2 
O 
2W,D 
(W. + h d ) D  
3 0  
D 
DWa 
(W, +6,,tUl+ 1)D 
1 

number representation of the inputs and output, (b) the mode of the arrivai of the multi- 
plicand (bit-paralle1 or digit-serial), and (c) the direction (LSD-first versus MSD-ht) of 
computation of the result. 
A plot of the throughput versus the digit-size is shown in Figure 4.7 for various values 
of W. A plot of the logarithm of the dciency versus the digit-size is shown in Figure 4.8 
Figure 4.7: Throughput Veftus Digit-Ske of Proposed and Existing Digit-Serial Multipli- 
cation Architectures 
for the same values of W. Ftom these plots, it can be concluded that the throughput of the 
proposed architecture is appraximately e q d  to that of the existing architecture. The non- 
linearities of the curves are due to modulo arithmetic effects. As in (Rao, 1996), the most 
&&nt architecture is the bit-parallei one. However, the relative efEciency is much lower 
than the d i n g  architecture, given that the vertical seale is logarithmic. This drarnatic 
ciifference in tenns of area performance a,rises fiom two fundamental clifferences between the 
architectures, namely, (a) the use of a redundant number representation (requiring large 
units for computing the resuit), and (b) the use of seleetors to choose the appropriate multi- 
plicand, a h  increasing latgely the area of a corresponding ASIC hardware implementation. 
It can also be observeci that the computation of the s i p  bit was not obtained by look- 

Figure 4.8: Log of Efficiency Versus Digit-Size of Proposed and Existing Digit-Seriai Mut- 
t iplication Architectures 
ahead techniques, making the critical path longer. However, this point does not have a 
large impact on the results for the wordlengths in Figs. 4.7 and 4.8. 
It is possible to make the multiplicand available in a bit-serial fashion in the bit-serial 
o d h e  algorithm for multiplication, as described in (hin, 1977) for signed-magnitude mul- 
tiplicand and multiplier inputs. As a result, it is possible to make the multiplicand available 
in a digitserial fashion in the digit-serial algorithm. However, in the resulting algorithm, 
the wordlength of the multiplier is constrained to be equal to that of the multiplicand. This 
becomes a drawback if the multiplicaad is read from a memory, because the computation al- 
ways requires W. iterations. By contrast, the proposed algorithm can be developed for any 
multiplier wordlength, which becomes a definite asset in a dynamically changing multiplier 
wordlength case. 
4.6 
Conclusion 
In this chapter, an algorithm has been devdoped for digit-serial online purely signed-blliary 
multiplication employing IEEE 754 SB RNE rounding, illutrathg the combination of the 

digit-serial and the online arit hmetic techniques. A correspondhg architecture for subse- 
quent FPGA hardware implementation has been proposed for general values of the digit-size 
and multiplicand and multiplier wordlengths, and con£ùmed functionaiiy correct through 
numerous simulations. The resulting architecture has been repipelined for throughput 
maximization. Gate-level speed and area estimates have been cdctdated. The efficiencies 
(ratio of throughput by area) of the proposed architecture were compared unfavorably to 
those of aisting architectures, mainly because of additional low-precision rounding units re- 
quired for MSD-first operation, and disuepancies between the operation themselves. Also, 
neither the power consumption nor the latency was taken into account in the dciency 
comparisons. Therefore, additiond work is required to determine suitability of digit-serial 
online operat ions for high-speed applications. 

Chapter 5 
Architecture for Online 
Signed-Binary Bit-Parallel 
Mult iply- Accumulate Operat ion 
5.1 Introduction 
This chapter is concemed with the design and subsequent FPGA hardware implementation 
issues of a purely signed-binary bit-parallel onhe multiply-accumulate operation employ- 
h g  the SB to MRB4 multiplier recoding, IEEE 754 RNE rounding, and overflow correction 
techniques. This includes, (a) the presentation of an algorit hm for bit-pardel online signed- 
binary MAC operation employing signed-binary to minimally redundant base4 recoding 
and IEEE 754 result rounding to nearest/even, (b) the translation of the algorithm to a cor- 
responding architecture for subsequent field-programmable gate anay or application-specinc 
integrated circuit implementation, and (c) the cornparison of the resulting architecture to 
existing similar architect uses. 
In Section 5.2 an algorithm is developed for purely signed-binary bit-parallel online 
multiply-accumulate operation employing the SB to MRB4 recoding technique. Moreover, 
the format of the result of the operation confom to that of the multiplieand and multi- 
p
k
 
by the IEEE 754 SB RNE rounding technique and the o d o w  correction technique 
discussed in Chaptu 3, dowing one to maintain a standard wordlength across a digital 
processor employing the proposed algorithm. Then, Section 5.3 describes a corresponding 
architecture for subsequent FPGA hardware implementation. FinaUy, Section 5.4 presents 
the simulation resdts demonstrating that the resuiting architecture is functionally correct, 

and compares the throughputs and &ciencies of the architecture and existing similar ar- 
chitectures (via speed and area gatelevel estimates). 
Simulation resdts wiii be presented for verification of correct hinctionality. In order to 
improve the throughput and allow a comparison of the proposed architecture to existing 
simhr architectures, Next, the proposed architecture is re-pipelined in order to both im- 
prove its throughput , and d o w  the comparison to exist ing similar architectures (Rao, 1996) 
by measwing their respective tkoughputs and &ciencies'. 
In Section 5.2, an algorithm is described for purely signed-binary bit-parallel online 
multipIy-accumulation operation employing the SB to MRB4 recoding technique. Moreover, 
the result of the operation wiU be expressed in the same format as the input multiplier and 
multiplicand by applying the IEEE 754 SB RNE rounding technique and the overfiow correc- 
tion technique discussed in Chapter 3, thus aliowing one to maintain a standard wordlength 
across a digital processor employing the proposed algorithm. Then, a corresponding archi- 
tecture for subsequent FPGA hardware implementation will be presented. Speed and area 
gatalevel estimates WU aUow a comparison wit h existing similar architectures. 
5.2 
Bit-Parallel Signed-Binary MAC Algorithm Employing 
SB to MRB4 Recoding 
The signed-binary (SB) to minimally redundant base-4 (MRB4) recoding technique pre- 
sented in Subsection 3.3.2 permits the reduction of the number of partial MAC updates by 
a factor of 2, increasing the speed of execution of a corresponding architecture by a factor 
of 2. In the following, an algorithm for bit-pardel oniine SB MAC operation employing SB 
to MRB4 multiplier recoding is developed. 
Consider the SB result R~~ of the MAC arithmetic operation given by 
where A~*, B
~
~
,
 
and cSB 
are refmed to as the SB MAC operation opefands, and represent 
the SB multiplieand, the SB multiplier, and the SB addend, respectively. 
' ~ h e  
efnaéncy rill be measnrrd as the ratio of the thmoghpnt by the ara of a given architecture. 

The SB multiplicand and multiplier can be defined in accordance with 
and 
where W. and Wb represent the wordlengths of A and B, respectively. By padding A and 
B with an appropnate number of zeros as LSDs, the values of W, and Wb can be assumed 
to be even in accordance with 
wa=2wo and wb=2wL, 
(5.4) 
where Wo and Wb' 
are integers. As a resuit, one can use the SB to MRB4 recoding technique 
presented in Subsection 3.3.2 to obtain a corresponding MRB4 representation .BMRB4 of B~~ 
Qven by 
In this way, ~~~~4 satisfies 
Since B M m  is expressed in a base4 represent at ion, the algorit hm foi online MAC operation 
m u t  process base4 numbers. The latency of the base4 oniine MAC operation is denoted 
by 6,,. 
Let us define the SB representation of the addend in accordance with 
Then, one hss to express AS* and cSB 
in quivalent base4 representations AB4 and CB4, 
respectively. One can obtain these representations by regrouping the odd and even digits, 
as seen in the i h t  step of the SB to MRB4 recoding technique in Subsection 3.3.2, resulting 

and 
where the values are preswed in accordance with 
Of course, this recoding is totally pardel. Finally, the result of the MAC arithmetic 
operation on ~
~
4
,
 
B M w  , and CB4 is defineci as 
By substituting the base-4 numbers by their SB equivalents in Eqns. 5.6 and 5.10, and by 
comparing the result to Eqn. 5.1, the base4 result ia proven to sat* 
The proposed algorithm for bit-paralle1 online SB MAC operation wiU be based on 
the recu~ive algorithm developed in Subsection 3.2.2. AU the iterations of the proposed 
algorithm wiil be performed at the same time instant. 
Let us decompose CBd into two components in accordance with 
where 
represents the most significant word of cB4, and where 
represents the lest sigdicant word of cB4. The k t  component, c&, wiil be made 
availab1e at the outset of the proposed algorith, whiie the second component, cZ, 
will 
be made available one digit per iteration. 

Since the operation is performed in a bit-pardel fàshion, ASB, B~*, 
and cSB 
axe a d -  
able at the outset, ia. at the first iteration. The digits of ~~~~d 
and CZ 
are made adable 
one pet iteration, the MSD k t .  In th* way, the wor& 
and 
are referred to as the partidy known multiplier and LSW addend at iteration p, respectively. 
Next, the otf-line iterative MAC result ~f~ is given by 
thus yielding the off-line partial MAC update 
where ic = WA (c.E Subsection3.2.1). The resulting MAC operation can be performed by 
using Algorithm 29. 
Algorithm 29 Bit-Pamllel Online Signed-Binary MAC Opemtion 
Step 1 Set p t O and eff c ~%4-~m=, 
Bd 
Step 2 R a d  bFRB4 and c ~ : + ~ ,  
Step 3 Cdmlate P? 
t (
A
B
I
~
~
~
~
 
+ cB4 
WO+P 4-W: 
4-6-e, 
Step 4 CaLcuiate FF4 c 
4ef, + P?, 
) 
Step 5 ~ound P,B1 to F:'~-, 
Step 6 Calculate CF 
t PF4 - ~
'
2
~
~
 
, 
Step 7 Wrüe F ' ~ _ _ ,  
Step 8 Calculate p t 
p + 1, 
Step 9 I f  p < WL + 1, then go to Step 2, else done end. 

In the above algorithm, the iteration p has to be initialized to O instead of 1 because 
the MSD of 
has a weight 4O. Moreover, (2% is scaled d o m  in the same m-er 
as ~
~
d
b
f
~
~
~
 
+ ~ $ + ~ 4 - ~ :  
and fed as the initiabation value of the scaled online ermr LI. 
In this way, it is imperative for C ~ - ~ , C  
to satisfy the same constraint as e-1, i.e. 
must hold true. O ther than these two points, the above algorithm corresponds to a bit-serial 
online algorithm for MAC operation as described in Subsection 3.2.2. At the last iteration, 
the onhe error É% is padded to the online result word R$ to fonn the final result ~
~
4
.
 
Let us calculate an upper bound on the addend. By applying Eqn. 5.20, one can obtain 
By observing that 1, = $ + (4l-7 - 4-w:-6ma9, 
Eqn. 5.21 becornes 
If Eqn. 5.22 is satisfied, then it is guaranteed that the above dgorithm generates the MAC 
resdt as expected. Moreover, by applying Eqn. 3.12 (page 51) at iteration WL of the above 
dgorithm, one obtains the base4 MAC operation resdt in accordance with 
Then, Eqn. 5.18 implies that 
holds. Next, by observing that BEY = ~~~4 
and that ~ 2 , ~ :  
= 
Eqn. 5.11 yields 
as desired. 
It is wy important to observe that Eqn. 5.23 implies that ~~4 is represented in accor- 
dsnce with 

which conforms to the representation of the sddend CBd. Therefore, ~~d can be fed back as 
the addend, permitting an accumulation of the MAC results, but requiring the addend, and 
the successive multipli~a~ld 
and multiplier values to be coIlStraùied ao as to yield a result 
~~d satisfying Eqn. 5.22. 
The MAC arithmetic operation online resdt that will be output must be expressed in 
the same format as the multiplier, so that one can use it as a multiplier in another online 
MAC arithmetic operation. The reformatting of the result requires two operations, (a) 
rounding in accordance with the IEEE 754 RNE standard, and (b) overflow correction. 
The MAC arithmetic operation resdt RSB can be rounded in accordance with the IEEE 
754 RNE standard as explained in Subsection 3.4.1. 
Therefore, R~~ is decomposed in 
accordance with 
w here 
represents its most signihnt word, and where 
represents its least signifiant word, md a signed-binasy 
(5.29) 
rounded r e d t  a 
is calculated, 
and is of the fonn 
Wb 
The extra digit of weight 22+26".c has been generated by the addition making part of the 
rounding openition. 
Then, the rounded r d t  eBd 
is fed to the d o w  detection and correction algorithm 
given in Subsection 3.4.2. Therefore, R$ is decomposed in accordance with 

where 
represents its most significant word, and where 
i= 
1 
represents its least signifiaint word, and a final output result R is generated. The final 
result R may be saturated (to the maximum or minimum representable value), but the 
corresponding internai result may not be saturateci. In this way, the extra MSDs of the 
R~~ required by the non-zero latency ci,,,, 
act as guard digits. 
It is important to observe that the online partial MAC result F:4 
is obtained as the 
addition of P? 
and 4efipBfl, 
but can also be viewed as the addition of ~
~
1
6
r
~
~
~
4
with 
4& 
+ cy wa+~ 
4 - & a ~ - ~ : .  
This observation implies that, instead of padding É? 
with a 
zero as its LSD in a corresponding architecture to obtain a multiplication by 4, one can 
pad c$+, 
a3 the LSD, to calculate 4efiPil + 
This is due to the fact that 
i, = Wo 
(c.t Subsection 3.2.2). 
Along with the development of the algorithm, one must determine the values of the 
internsl wordlength 7 and the latency dm,, of the base-4 online MAC arithmetic operation. 
The digits of FF4 are assumed to belong to the set (-3, -2,. . . ,3} such that the resulting 
addition architecture can be derived from limited-carry addition architectures (c.f. Subsec- 
tion 2.4.1). In order to yield a small Iatency value, the digits ~ , " j ~ ~ ~ ~  
are assumed to belong 
to (-3,. . . ,3). Consequently, the lower bound on the latency (c.f. Eqn. 3.32 page 57) is 
Of course, the choice y = 1 is not valid (1 - 1 is negative). One can observe that if 7 could 
be equal to 1, then no rounding of pp would be necessary. Then, the minimum valid 7 value 
is 2, and happerw to yield the srnallest latency d u e  6- 
= 1. As a resdt, one chooses 
7 = 2 and 6- 
= 1. It is interesting to note that the latency of the resulting signed-binary 
operation is twice that of the base4 operation. 

5.3 Architecture for MAC Operation Employing Signed-Binary 
Multiplier Recoding 
In this section, the proposed algorithm for bit-pardel online signed-binary multiply-accumulate 
operation will be translated to a corresponding architecture for a subsequent FPGA or ASIC 
hardware implementation. The resulting architecture is shown in Figure 5.1 for general val- 
ues of the wordlengths of the input multiplicand and multiplier. This architecture comprises 
three main parts, namely, a bit-pardel multiplier recoding unit, serial online multiplication 
units, and a bit-parallel rounding and overflow unit. Each of these units will be described 
individuaily in the following subsections. The critical path of the proposed architecture is 
shown in bold lines. 
At a given t h e  instant, the SB multiplier B~~ is fed to the bit-parallel recoder unit 
described in Subsection 3.3.2. The resulting digits of the MRB4 representation 
of 
the multiplier are fed individually to each of the Wi + 1 online multiplication units. The 
p t h  multiplication unit takes as other inputs the current SB multiplicand value A ~ *  and 
the online error c:!, 
generated in the (p- 1)-th multiplication unit. One can note that both 
the online multiplication unit number and the index of the corresponding MRB4 multiplier 
digit correspond to the iteration number in the algorithm. Then, the result digits coming 
out of the online multiplication units are gathered to form 22, and are combined to the 
digits of the online error (3 of the last online multiplication unit, yielding the full-precision 
b 
resuit ~
~
1
,
 
or, equivalently, R
~
~
.
 
Next, ~~4 branches off into two dXerent paths. In the first path, R ~ *  
is delayed by one 
sample tirne by registers, as described in Section 4.3, and the delayed signal is fed back as 
the accumulation value CBd. in the second path, ~~4 is rounded in accordance with the 
IEEE 754 RNE standard, as described in Subsection 3.4.1, and fed to an overflow correction 
unit, as d e d b e d  in Subsection 3.4.2. The last two operations are required to restrict the 
f o m t  of the output result to match that of the multiplier and multiplicand. 
5.3.1 Signed-Binary to Minimally Redundant Base4 Recoders 
The recoder is implemented as a cascade of signecl-binary to minimally redundant base4 
recoders. These recoders are as describecl in Subsection 3.3.2. 

I 
, 
teset el& 
1 
Rounding and O v e d m  Correction Unit 
1 '  
r2-~- 
@ 1 
1 1 
. 
1 
S 
D D 
rn 
S 
. 
1 
O S 
O D 
D 
1 
* 
s 
s 
O 
. 
s 
s 
L 
. . 
s 
O 
s 
D 
. . 
s 
s 
1 
O 
s 
s 
s 
w 
s 
O 
w 
s 
* 
* 
O 
b 
+ 
s 
O 
s 
s 
O 
* 
O 
s 
D 
s 
O 
O 
:
:
 
SB 
bMRB4 ->W{-'/ 
Figure 5.1: Architecture for Bit-Parallel Online Mdtiply-Accumulate Operation Employing 
SB to MRB4 Reeading 
B4 
w; 
, 
, 
=w:+w; 
5.3.2 Online Multiplication Units 
Recoder Wb 
The onüne multiplication units employed here are slightly dinerent fkom those described in 
Section 4 3  (page 95). Since the algorithm implemented by this architecture is based on 
radix-4 representations, the online error is scaled by 4 as opposed to 2. The first metence 
1 1  
SB 
MuItiply- Accumulation Unit WL 
- 
4w; 
O 
1 
I 

is that the online error is shifked up by two signed-binary digit positions instead of one. 
Then, the multiplier digits can take on values fiom the set (-2, -1,0,1,2). Therefore, 
the muitiplicand word by multiplier digit multiplication is perfomed by using dedicated 
multipiïers, which have been describecl in Subsection 3.3.2. 
The second merence cornes fkom the obsemation that no clearing of the oniine error is 
required for any of the intermediate oniine errors, because there is at most one operation 
happening at a given tirne instant within the architecture. Therefore, no online clearing 
unit is needed, and only a clearing of the accumulatecl result (
~
~
4
)
 
is necessary (achieved 
by setting the corresponding register to the appropriate value). 
Let us now consider the Iow-precision rounding unit. The interna1 wordlength 7 is equal 
to 2 for the bese-4 representations. Therefore, the truncated online partial MAC result 
comprises two base4 digits. The base-4 MSD corresponds to the digit of weight 1, and the 
base-4 LSD corresponds to the bsse4 MSD of the fraction. These two rnaximally redundant 
base-4 digits are represented by four signed-binary digits, two in the integer part, two in 
the fiaction part. Consequently, the circuit described in Subsection 3.4.1 can be used for 
the low-precision rounding of that word. 
5.3.3 Rounding and Ovedow Correction Unit 
In this unit, the resdt SB 
of the MAC operation is first rounded by employing the IEEE 
754 RNE rounding technique to eliminate the extra LSDs as described in Subsection 3.4.1 
(page 70). The addition of the IEEE 754 RNE round digit is obtained by an may of 
iimited-cany adders. The overflow correction unit has been desaibed in Subsection 3.4.2 
(pape 79). 
5.4 
Cornputer Simulation Results and Performance Compar- 
ison 
The correct f u n c t i o d e  of the proposed architecture WU 
be c o b e d  by cornputer simtda- 
tions. Then, its speed and area perfomances wül be rneasulced, and subsequently compared 
to t hose of existing architectures. 

5.4.1 
Simulation Results 
The wordlengt hs of both the mdtiplicand and the multiplier have been set equal to 8 for a 
subsequent simulation of FPGA hardware implementation by using Max+Plus II and the 
underlying Synopsys compiler. The refetence of the tsrget FPGA is EPF lOK2O RC240- 
4. The latency of the proposed algorithm is as chosen in the algorithm development (c.f. 
Section 4.3, page 95). 
The test vectors in decimal notation are listed in Table 5.1. It is important to observe 
Table 5.1: Test Vectors for ParaIlel MAC Operation in Decimal 
how some of the full-precision results exceed the absolute value 1 -2-8, which is the limit of 
the range of representable values in the chosen format. As s consequeme, the correspondhg 
expected result values are saturated to the maximum representable value, but the internd 
full-precision secumulateci result can stül hold these values without my true internal over- 
flow. The same vectors have been translatecl by a Matlab program into their equivalent 
signed-binary representations in Table 5.2 for use in a Matlab emulation of t h  proposed 
architecture. 
The simulation results are shown in hexadeckd values in Figure 5.2. The correspon- 
dence between hexadecimal and signeci-binary values is hted in Table 4.3 (page 106). In 
Figure 5.2, the signed-binary result values correspond exactly to the expected results, thus 
proving the correct functionali@ of the proposed architecture. Nurnerous other simulations 

I d I * J O l d Q 0 0 0 0 0  
o
o
d
l
d
 0 
O
d
 
0
0
0
0
0
l
r
c
l
r
c
M
 
0 0 ri i d  rc irc t r i  t 
Id 0 
l
I
r
c
r
c
O
~
0
0
0
0
0
 
0 0 0 l r c O t r c 0 0 1 r c ~  
I d I r ( d I d Q 0 0 0 0 d  
O t
4
 O
 lrl 0 O I d  Id I d  ri 
Q
ô
0
9
0
0
~
~
&
~
 

have been d e d  out to c o b  
the correct functionality. 
5.4.2 
Throughput Parameterization 
The various delays co~espondhg to the units are listed in Table 5.3. The delay of the 
Table 5.3: List of Delays of Architectural Units 
Unit 
1 
Delay 
1 Number of Units 1 
1 SB to MRB4 Recoder 
1 
6 
1 
I 
1 
I 
1 
IEEE 754 RNE round digit generation unit has been restricted to the delay concerning the 
critical path. Let us denote by rg and T,, 
the delay through a gate and a multiplexer, 
respectively. As a r d t ,  the delay T of the proposed architecture can be calculated in 
accordance with 
Limited-Carry Adder 
SB by -4 
Digit Multiplier 
RNE Ro~nding 
Overflow Correct ion 
5.4.3 
Area Parameterization 
The proposed architecture makes use of a number of elements described in the previous 
chapters. A summary of the ne& 
is Listed in Tàble 5.4. 
Some reductions of the hardware requirements are possible. For example, the addition 
of the round digit to obtain the IEEE 754 SB RNErounded result does not require limited- 
carry adders to their hlI &ent. 
As a result of these reductions, the total area A of a 
conesponding ASIC hardware implementation can be calculated in accordance with 
3 
2 
2Wa-2WL-2 
- 
- 
1 
1 
1 
Wi + 2  
1 
1 
1 

Table 5.4: List of Areas of Units Constituent in the MAC Architecture 
1 
Unit 
1 
Area 
1 Number of Units 1 
- - -  
- 
- 
SB to MRB4 Recoders 
5.4.4 
Cornparison 
Carry-Propagate Addes 
Low-Precision Rounding 
Multiplier 
D-fiip-flop 
RNE Digit Caledation 
Overfiow Correction 
Let us assume r9 = lm, rmuI = 1.5ns, cg = 2sPrn2, and hu 
= 37.5pn2. Moreover, one 
will assume that W. and Wb have the same value denoted by W, thereby sirnplifjhg the 
cornparison. Then, the throughputs H of the proposed architecture is obtained as 
Gates 
15 
Next, the efnciency of an architecture is caiculated as the ratio of its throughput by its total 
a r a  It is extremely important to note that neither the latency of the online operation nor 
an estimate of the power consumption of a correspondhg hardware irnplementat ion is taken 
into account in the above aciency caldation. 
The proposed architecture is compared to the architecture for LSD-kt bit-parallel MAC 
operation and IEEE 754 rounding of signed-binary nurnbers proposed in (Rao, 1996). The 
main dinerences between these architectures are the direction (LSD-first versus MSD-kt) 
of computation of the result, and the full-mrdlength o d o w  detection and correction of the 
result. A comparative plot of the throughput versus the wordlength is shown in Figure 5.3 
for some dues of W. A comparative plot of the efficiency versus the wordlength is shown 
in Figure 5.4 for the same values of W. The nirpos are not smooth due to slight clifferences 
between architectures when the wordength is odd or even. The speed and 6ciency are 
similar, dthough the proposed architecture performs worse than the &hg 
LSD-ht 
13 
11 
4 
6 
6 W. + 6 Wb' - 5 
36W; - 8Wb +36 
Mult iplexers 
1 
- 
Wb 
2 
- 
2 
- 
2 
2W,'+ 2Wb + 1 
5Wb 
% 
(W. + 1)wL 
2Wa+2W;+4 
1 
1 

Figure 5.3: Throughput Versus Wordlength of Proposed and Existing Bit-Parallel MAC 
Architectures 
Figure 5.4: Efficiency Versus Wordlength of P r o p d  and Existing Bit-Paralle1 MAC Ar- 
chitectures 
architecture, despite the numerous efforts to increase the speed of computation and reduce 
the axes of a rdting ASIC hardwase implementation. The worse delay calculation is 
related to the fact that the signed-binary digit encoding does not embed the sign of the digit 

directly. Therefore, additional caiculations are required to determine the sign of the least 
significant word to be rounded using the IEEE 754 SB RNE rounding technique. Moreover, 
the ana of the proposed architecture is Iarger because of two factors. The first factor 
is the low-precision rounding and cmy-propagate addition units required by the online 
processing of data. The second lactor is the large over£low correction unit performing an 
overflow detection and correction over the entire result word, instead of only on the MSD. 
B must be observed here that it has not been assumed that IR1 is smaller than 1 - 2-Wb. 
It must also be observed that the computation of the sign bit has not been obtained by 
look-ahead techniques, thereby making the critical path longer. However, this point does 
not have a large impact on the results for the wordlengths under consideration. 
As a conclusion, the proposed architecture may yield a slightly slower ASIC hardware 
implementation t han exist ing MD-first architectures. However, since current pract icd 
analog-t O-digital and digital- t o.analog convert ers generate and consume digits the MSD 
first, employing the proposed architecture might prove more attractive and efficient. 
5.5 
Conclusion 
In this chapter, an aigorithm has been developed for bit-parailel online purely signed-binary 
multiply-accumulate operation employing the proposed SB to MRB4 recoding, IEEE 754 
SB RNE result rounding, and overflow detection and correction techniques. Correspondhg 
architectures for the above dgorithms have been proposed, and the subsequent FPGA 
hardware implementations have been confirmed functionally correct. The efficiencies (ratio 
of throughput by area) of the proposed architectures were compared partially to those of 
existing architectures. The dinkrences observed were attributed ta additional low-precision 
rounding units required for MSD-first operation, and discrepsncies between the operations 
themselves. However, neither the latency of the online operation nor an estimate of the 
power consumption of a corresponding hardware implementation was taken into account in 
the efliciency calcuiations. Therefore, additioaal mrk is required to reach a conclusion on 
the suitability of online operations for high-speed applications. 

Chapter 6 
Conclusion 
6.1 Review of Material Presented 
This thesis has been concernai with the design, development, and implementation of digit- 
serial online signed-digit anthmetic operations for applications in digital signal processing. 
Chapter 1 has introduced arithmetic operations in the digital signal processing context, 
has briefly described the online and the digit-serial arithmetic techniques, and has described 
the existing advances and their respective extents. 
Then, in Chapter 2, fixed-point arit hrnetic in generalized signed-digit number systems 
hss been described. The digitserial and oniine mithmetic techniques have been discussed, 
the existing digit-serial unfolding algorithm hss been simplined, and the unfolding of bit- 
serial operations into operations featuring a dynamically changing wordlength have been 
introduced. Findy, redundant binary addition schemes have been duuacterized by a new 
o&t parameter, and subsequently separated into two equivalence classes. An addition 
scheme belonging to a given class of equivalence possesses the same addition mechanisms 
as the other addition schemes of that class, thus dowing the determination of the smdest 
and fsstest addition scheme under varying digit encoding. The 4:2 cornpressor has been 
pro- 
to be not only a redundant binary adder, but also one of the m& dcient. 
Next, Chapter 3 provided the foundation for onüne generalized signed-digit multiply- 
accumulate (MAC) 
operations by devehping a recursion-based algorithm featuring operation- 
independent variables. A different operation ean be performed by solely calculating a partial 
operation update dinerently. In this way, a generalizstion of bounds on these variables ha9 
been introduced, leading to a procedure for the determination of the various parameters of 

the MAC operation. These parsmeters include the number system radix, the redundancy 
indices, the internal wordlength, and the latency. Atso, multiplication and clearing units 
have been d d b e d ,  and techniques for IEEE 754 SB RNE rounding, low-precision round- 
*, 
and OVeffiow handling have been presented dong with corresponding architectures. 
Chapter 4 has applied the proposed algorithm to the development of an algorithm 
for digit-serial online purely signed-binary multiplication employing IEEE 754 SB RNE 
rounding, illustrat ing the combinat ion of the digit-serial and online arit hmet ic techniques. 
A corresponding architecture for subsequent FPGA hardware implementation has been 
proposed and verined functiondy correct. The resulting architecture has been re-pipelined 
for throughput maxhization. The &ciencies (ratio of throughput by area) of the proposed 
architecture were compared to t hose of exist hg architectures. 
Finally, in Chapter 5, an algorithm has been developed for bit-parallel online purely 
signed-binary multiply-accumulate operation employing the proposed SB to MRB4 recod- 
ing, IEEE 754 SB FOIE result rounding and overfiow detection and correction techniques. A 
corresponding architecture for subsequent FPGA hardware implementation has been pre 
posed and verified functiondy correct. The aciency of the proposed architecture has been 
compared to those of existing architectures. 
In Chapters 4 and 5, the efficiency compazisons have been unfavorable to online o p  
erations, mainly because of additional low-precision rounding units required for most- 
signifiant-digit-bt operation, but &O because of functional discrepancies. However, la- 
tency and power consumption have not been used as parameters in the aciency cdcula- 
tions. Therefore, more work WU be needed to reach a conclusion regârding the suitability 
of bit-serial, bit-parallel, and digit-serial online operations for high-speed applications. 
6.2 Proposed Areas of Future Work 
Addition and multiplication properties of ordinary signed-digit number systems have been 
presented and extendeci, but a determination of the speed and area of corresponding efkient 
hardware implementations has not been carrieci out. Such a determination would allow one 
to find which ordinsry signed-digit nurnber system is most efnûent in terms of area and 
speed. In particular, it is believed that OSD and USD numbes systems have another 

advantage in multiplication over other GSD number systems. Considering an odd (even) 
GSD number system of digit set D, 
the catdinali& of the set whose elements result &om 
the multiplication of two digits belonging to D should be smallest when the number system 
is OSD (USD). As a resdt, the smallest multiplication units would be obtained for OSD 
and USD number systems. 
The d y n d d y  changing wordlength technique has to be dehed more rigorously, in 
order to deterrnine its drawbacks and advantages exactly. In particular, the case of a dy- 
namically changing wordlength taking on values that are ali multiples of a s m d  wordlength 
value rnay lead to an algofith similar to that for digit-serial unf01ding of bit-serid architec- 
tures. It is possible to define such an unfolding algorithm at an algorithmic level instead of 
an architectural level, which would allow software engineers to benefit fiom this technique. 
la the context of digit-serial online operations, gate-level power estimates for cone- 
sponding hardware implementations and latency values should be taken into account in the 
caldation of the efficiency of these operations. The use of redundant number systems, 
which are known for their property of stopping the carry propagation, is expected to reduce 
the switching activity in a hardware implementation, and, consequently, its power consump 
tion. This work would d o w  one to reach a definitive conclusion regardhg the suitability 
of digit-serial online operations for high-speed low-power applications. 
The proposed online algorithm can be used for inner product operation. The author 
developed an example in Matlab code, but did not disdose it in this thesis. A direct 
application is the design of finite impulse response filters, since one can see the operation of 
mch a filter to be the inner product of a vector of coefficients with a vector of delayed input 
sample values. The small latency of such operations seems to be ais0 suitable for their use 
in infinite impulse response filtem. Similanties between the inner product co&cients may 
be exploited for low-area low-power design, especially if the coefkients are hard-wired. In 
the latter situation, multiplier-Iess architectures rnay be developed. 
Similarly, it is believed that the proposed online algorithm can be used for inaemental 
multiplication, whereby both the mdtiplicand and the multiplier are made a d a b l e  in an 
online £oshion (kwin, 1977). One should &O be able to &end the resdting algorithm to 
a MAC operation. Such an operation could be used for modulation. 

A significant reduction in the delay required for rowiding the lest significaat word 
(LSW) of a multiplication result can be obtained by first truncating the LSW to ody a few 
of its most significant digits. Then, romding m o n  wodd occur only if the truncated LSW 
is equal to O. 
6.3 Concluding Remarks 
It is most important to remark that the benefits of the online arithmetic technique are 
obtained when using a bit-serial transmission of the data. If the transmission is digit-seriai 
of bit-parallel, then a hardware implementation of the conesponding LSD-first arithmetic 
operation can achieve higher sampling frequencies and much lower areas, since no interme- 
diate estimation of the MSD is required. Moreover, since the result is obtained the LSD 
first, rounding techniques can be applied concurrently to the cornputation of the result of 
the arithmetic operation, thus avoiding additional delays. 

Bibliography 
Avizienis, A. (1961). Si ed-digit numbe[r] representat ions for fast pardel arit hrnetic, IRE 
r 
Thnsactions on E ectmnic Cornputers EC-lO(3): 389-400. 
Balsara, P., Owens, R and Irwin, M. (1991). Digit serial multipliers, Journal of Parallel 
and Distributed Computing 11: 156-162. 
Brackert, Jr, Roy Ercegovac, M. and Wilson, Jr, A. (1989). Design of an on-line mdtiply- 
add module for recursive digital filters, Proceedings of the gth Sylposium on Computer 
Arr'thmetic, IEEE, Santa Monica, CA, pp. 34-41. 
Carter, T. and Robertson, J. (1990). The set theory of arithmetic decomposition, IEEE 
Thnsactioru on Computers 39(8) : 993-1005. 
Chow, C. (1980). A variable pmhion processor module, Phd thesis, Departement of Corn- 
puter Science, University of Illinois, Charnpaign-Urbana, IL 61801. technicd report. 
Chow, C. and Robertson, J. (1978). Logical design of a redundant binary adder, Proceedings 
of the 4* Spposium on Cornputer Arithmetic, IEEE, Santa Monica, CA, pp. 109-115. 
Dadda, L. (1976). On parade1 digital multipliers, Alta Ekpuenza 45: 574-580. 
Duprat, J., Herreros, Y. and Muller, J. (1989). Some results about on-line computation 
of functions, Pmceetiings of the 
Symposium on Computer Arithmetic, IEEE, Santa 
Monica, CA, pp. 112-118. 
Ercegovac, M. (1984). On-line &thmetic: an o v e ~ e w ,  SPIE, Real- Time Signal Processing 
VII, Vol. 495, IEEE, San Diego, pp. 86-93. 
Ercegovac, M. and Lang, T. (1989). On-line azithmetic for DSP applications, Proceedings of 
the 92nd Midwest Symposium on Circuits and Systems, Urbana-Champaign, IL, USA, 
pp. 365368. 
Ercegovac, M. and Lang, T. 1990). Fast multiplication without carry-propagate addition, 
IEEE %wactions on 5 omputers 39(11): 1385-1390. 
Fernando, J. and Ercegovac, M. (1992). On-line arithmetic modules for recursive digital 
flters, Record of the 26" Asilomar Conference on Signab, Systems, and Computers, 
VOL 2, pp. 681-685. 
GO ji-Sinaki, A. and Erceg-, 
M. (1981). Design of a digit-slice on-line arithmetic unit, 
Pfoceedings of the 5* Symposium on Comput er ARthmetic, IEEE, University of Michi- 
gan, Ann Arbor, MI, pp. 72-80. 
Goto, G., houe, A., Ohe, R, Keshiwakura, S., Mitarai, S., Tsuru, T. and Izawa, T. (1997). 
4.1-ns compact 54 x 54-b multiplier utilizing sign-select booth encoders, IEEE Journal 
of Solid-State Circuits 32(ll): 1676-1681. 

Guyot, A., Herreros, Y. and Muller, J. (1989). JANUS, an on-line multiplier/divider for ma- 
nipulating large numbers, Pmceedàngs of the gth Symposium on Computer Arithmetic, 
IEEE, Santa Monica, CA, pp. 106-111. 
a prototype for hi& precision arithmetic, 
s of the International Confetence on 
TC ~ O ~ W G  
10.5, Elsevier Science Publishers 
B. V. 
Hagihars, Y., Inui, S., Yoshikawa, A., Nakazato, S., Iriki, S., Ikeda, R., Shibue, Y., Inaba, 
T., Kagamihara, M. and Yarnashina, M. (1998). 2.7119 0.25pm CMOS 54 x 54b multi- 
plier, Pmceedings of the 1998 IEEE 45th Internationat Solid-State Circuits Conference, 
pp. 296-297. 
Hwaag, K. (1979). Computer anthmetic - pnnciples, arcliitecture and design, John Wiey 
& Sons. 
h i n ,  M. (1977). An arithmetic unit for on-line oomputation, Ph.D. thesis, Department 
of Computer Science, University of &ois, 
Champaign-Urbana, IL 6 180 1. Technical 
Report UNCDCS-R-77-873. 
Irwin, M. and Owens, R (1987). Digit-pipelined arithmetic as illustrateci by the paste-up 
system: s tutorid, Computer 20(4): 61-73. 
h i n ,  M. and Owens, R. (1988). A cornparison of two digit serial VLSI adders, Proceedings 
of the IEEE Conference on Computer Design 1988, pp. 227-229. 
Kanie, Y., Kubota, Y., Toyoyama, S., Iwase, Y. and Tsuchimoto, S. (1994). 4 2  cornpressor 
wit h complementary pass-transistor logic, IEICE Thnsactions on Electronics E77- 
C(4): 647-649. 
Komerup, P. (1994). Digit-set conversions: generalizations and applications, IEEE %ns- 
action8 on Cornputer3 43(5): 622-629. 
Lapointe, M., Huynh, H. and Fortier, P. (1993). Systematic design of pipelined recursive 
filters, IEEE ~ w u c t i o n s  
on Computers 42(4): 413-426. 
Larsson, P. and Nicol-Chris, J. (1996). Transition reduction in carry-save adder trees, Pro- 
ceedings O f the 1996 International Symposium on Low Power Eleetronics and Design, 
pp. 85-88. 
Law, C., Rofail, S. and Yeo, K. (1999). Law-power circuit implementation for partial- 
product addition using pas-transistor logic, IEE Proc. - Circuits DeMces Syst., Vol. 
146, IEE, pp. 124-129. No. 3. 
Lin, H. and Sips, H. (1990). On-Iine CORDIC algorithms, IEEE IRowactions on Computers 
39 (8): 103û-1052. 
McNally, O., McCanny, J. and Woods, R. (1990). Optimiseci bit-level architectures for IlR 
filtering, Pmceedings of the IEEE Conference on Computer Design 1990, pp. 302-306. 
McQuillan, S. and McCanny, J. (1995). A systematic methodology for the design of high 
pedormance recursive digital fiitem, IEEE TkunsactiMu on Computers 44(8): 971-982. 
Muller, J. (1994). Some characteristics of functions cornputable in on-line arithmetic, IEEE 
It.crnsacfiow on Camputers 49(6): 752-755. 
Natta, W. and Nowrouzian, B. (1999). Digit-serial digit-online addition, Pmedings of 
the Canadian Confe~nce on Etectràcot and Computer Engineering 1999 (CCECE'gg), 
pp. 583-588. 

Natter, W. and Nowrouzian, B. (2000a . A novel algorithm for signed-digit online mdtiply- 
1 
accumulate operation and its pure y sieped-digit hardware implementation, Pmceedàngs 
of the International Symposium on Circuits and Systerns (ISCAS) 2000. 
Natter, W. and Nowrouzian, B. (2000b). Signed-Digit Online MAC Operation and its 
FPG A Hardware Implementation, ISIA C 2000. 
Owens, R. (1980). Digit-online algorithm /or pipeline architectuscs, P hd t hesis, Depart- 
ment of Computer Science, Pennsylvania State University, University Park, PA 16802. 
Technical Report CS-80-21. 
Owens, R (1981). Cornpouad algorithms for digit online arithmetic, Pmceedings of the 5'" 
Symposium on Computer Arithmetic, IEEE, University of Michigan, A m  Arbor, MI, 
pp. 64-71. 
Owens, R (1983). Techniques to reduce the inherent limitations of fdly digit online arith- 
metic, IEEE 2hnsactions on Computers C-32 (4): 406-41 1. 
Parhami, B. (1988). Carry-free addition of recoded binary signed-digit numbers, IEEE 
Thansactions on Cornputers W(l1): 1470-1476. 
Parhami, B. (1990). Generalized signed-digit number systems: a unifying framework for 
redundant number representations, IEEE Thnsactiow on Computers 39(1): 89-98. 
Parhi, K. (1991). A systematic approach for design of digit-serial signal processing archi- 
tectures, IEEE IPmnsactions on Circuits and System 38(4): 358-375. 
Perlee, C. and Casasent, D. (1989). Optical systems for digit-serial computation, Applied 
Optics 28(3): 611-626. 
Phatak, D. and Koren, 1. (1994). Hybrid signed-digit number systems: a unified fiamework 
for redundant number representations with bounded carry propagation chains, IEEE 
lRonsactions on Computers 43(8): 88b891. 
Pillai, R., Al-Khalili, D. and Al-Khalifi, A. (1996). Energy delay analysis of partial prod- 
uct reduction methods for parallel multiplier implementation, Pmceedings of the 1996 
International Symposium on Low Power Electmniu and Design, pp. 201-204. 
Privat, G. (1990). A novel class of serial-parallel redundant signed-digit mdtipliers, 1990 
IEEE International Symposium on Circuits and System, Vol. 3, IEEE, New Orleans, 
LA, pp. 2116-2119. 
Rao, V. (1996). Redundant num ber multiply-aoeumulate-modulan'zed digital filters, M.sc. 
thesis, The University of Calgary. 
Rao, V. and Nowrouaian, B. (1997). A 
multiply-accumulate 
arithmetic architecture employing mixed 
Canadian Journal 
of Electricol and Computer Engineering 
Rao, V. and Nowrouzian, B. (1999). 5-digit overlapped-scanning technique for the modiiied 
dix-4 recodin of signed-binary numbers, IEE Pm.-Cireuifs Deuices Syst., Vol. 146, 
IEE, pp. 1-4. Ef o. 6. 
Santoro, M., Bewick, G. and Horowitz, M. (1989). Rounding dgorithms for IEEE multipli- 
ers, P d i n g s  of the gth Symposium on Computer Arithmetic, IEEE, Santa Monica, 
CA, pp. 176-183. 
Satyamrayana, J. and NowroUnan, B. (1996). Design and FPGA implementation of 
digit-serial modified booth mdtipliers, Journal of Cirruits, Systems and Computers 
6 (5): 485501. 

Shim, D. and Kim, W. (1997). Design of 16 x 16 wave pipelineci multiplier using fan-in 
equaüzation technique, Pmceedings of the 1997 4ûth Midwest Symposium on Circuits 
and Systems, Vol. 1, Sacramento, CA, USA, pp. 336-339. 
Sips, H. and Lin, H. (1990). A new mode1 for on-line arithmetic with an application to the 
reciprocal dculation, Journal of Pamllel and Distduted Computing 8: 218-230. 
Srinim, H. and Parhi, K. (1983). Computer arithmetic architectures with redundant num- 
ber systems, IEEE Rznsactiow on Computers C-32(4): 40ô-411. 
Thornton, M. (1997). Signed binary addition eireuitry with inherent even parity outputs, 
IEEE ~ w a c t i o w  
on Computers 46(7): 811-816. 
Timmermann, D. and Hosticka, B. (1993). Ovedow eEects in redundant binary number 
systems, Electmnics Letters 29 (5) : 440-441. 
nivedi, K. and Ercegovac, M. (1977). On-line algorit hms for division and multiplication, 
IEEE lRowactiow on Cornputers C-26 (7): 68 1-687. 
Wallace, C. (1964). A suggestion for a fast multiplier, IEEE IRansactions on Cornputers 
EC-14: 14-17. 
Woods, R, McNaily, 0. and McQuillan, S. (1993). Saturation circuitry for redundant 
number baaed IIR Nt ers, Electronics Letters 29 (5) : M-M. 

Appendix A 
Systematic Enurneration of 
Redundant Binary Addit ion 
Schemes 
This appendix provides the proofs of the various t harems relating to redundant binary ad- 
dition schemes stated in this thesis. The goal of these theorems is to introduce a fiamework 
to study similar addition schemes which can be mapped to the same hardware implemen- 
tations. Section A.l determines the cardinalities of the sets of the variables involved in a 
redundant binary addition scheme. Then, Section A.2 determines the values of the elements 
of these sets in a systematic m m e r .  Next, Section A.3 provides the proofs of the theorem 
characterizing the proposed sddition schemes. Finally, Section A.4 provides the prooh of 
the theorem characterizing the proposed addition schemes. 
A.l Determination of Set Cardinalities 
This section is concerned with a determination of ail the possibilities for the cardinalities 
of the digit sets Sc,, Sa, S,, and SB. The cardinalities can be determined by using the 
following lemma. 
Lemma 30 Let Sa = {a1,.. . ,a,,,) und Sb = {bi,. . . ,b,,} representa sets such that 
Vi E [l,m - 11, ci < ~ + l ;  
und Vi E [l,n - 11, bi < bi+i. 
(A- 1) 
Pmof. The proof consists of two parts. 
Using the relationships between u& and bj'sl one obtains 
The number of different combinat ions is m + n - 1, t herefore Sa + Sb contains at least 
na + n - 1 elements. 
Each of the na elements of Sa can be added to at most n elements of Sb. Therefore, 
the xnaximum number of eîemaits in S. + Sb is nt x n. 

These two points establish the proof. 
In order for Eqn. 2.63 to be satsed, one must impose 
2 < ISa1, 2 ( 
I S C l I ,  and (ISaI, ISClI) # W ) .  
Otherwise, by using Lemmn 30, one can show that 
1sc1 + sa1 9 4 < Isa /sbI, 
contradicting Eqn. 2.63. Similarly, Eqn. 2.65 imposes that 
ISBI a 2, and IS,,I 
G 2. 
Otherwise, Lemma 30 imposes the constraint 
3 < Isg + 2 s 4  , 
contradicting of Eqn. 2.65, because IS,I = 3. 
Together, Eqn. A.4 and Lemma 30 impose the constraint 
3 < 1s. + 2sc* 1. 
If lS8I = 1, then 
Isg +sol = ISol 
IS,I 
5 2, 
contradicting Eqn. 2.64. Similarly, if IS, 1 = 1, then 
IsB +sel = Is/3l and lspl 5 2, 
&O contradicting Eqn. 2.64. Therefore, one can conclude that 
lSBl = 2 and IS,I = 2. 
Finnlly, let us prove that 
(ISQl 9 ISal) = @,3) or (3,2)' 
If Eqn. A.12 is not satisfied, then Eqn. A.4 and Lemma 30 impose the constraint 
4 < Isai2s"I' 
whereas Eqn. A.11 Gres 
1s.. 
+SPI < 4, 
(A. 10) 
(A.11) 
(A.12) 
(A.13) 
(A. 14) 
thus contradict' 
Eqn. 2.64. If Eqn. A.12 is satisfied, then Eqns. 2.63-2.65 are satisfied. 
Y 
A summary O the possible cases of set cardinalities is given in Table 2.1, Chapter 2. 

A.2 Systematic Determination of the Sets S,, , Sa, 
S,, and SB 
The values of the elements of Sg and S, are determined first , followed by the determinat ion 
of the values of the elements of Sa and Sc,. 
In accordance with Table 2.1, let us denote 
where one assumes 
< c22, and where Bi < &, which cm be obtained by swapping the 
elements. Let us further denote Ac2 = cn - c2l > O and AB = -& > 0. 
The foIlowing must hold for the migration fiom the right-hand side of Eqn. 2.61 to its 
left-hand side to be possible: 
and since 
one can identify ,& + 2
~
2
~
 
and & + 2cn ss the minimum and maximum element values in 
S + 2Sc2. The value & + 2cn must be equal to & + 2czi, otherwise Sg + 2S, $t 48,. 
d e r e k e ,  
By simple manipulations, one can fmd 
Therefore, one concludes that 
and 
The digit sets Sm and S are deterrnined as functions of the parameter czi. In the 
following, the cardîdities O ! the sets Sa and S, are taken into account. Two situations 
canoccur, n d y  /S,I 
= 3  and IS,I =2, or IScJ = 2  and IS,I =3. 

A.2.1 
Case 1: IS, 1 = 3 and IS,( = 2 
Similar to the determination of Sc2 and S,g , let us denote the eiements of Sc, and S, by 
where cil < cl2 < C ~ J  
and al < q. 
A h ,  let us deiine 
By combining these notations successively with Eqns. 2.64 and 2.63, one can exhaustively 
determine the values of the elements of Sc, and Sa. 
Eqn. 2.64 is satisfied when 
w here 
Sc2 + S~ = (47 - 4 - ~21,47 - 2 - C Z I , ~ ~  
- czi, 47 f 2 - ~21). 
(A.32) 
By identifkat ion, 
Moreover, one can observe that 
a2 + 2cl2 = 47 - c21 
(A.39) 
is the only set of equations allowing Eqn. A.35 to be satisfied. Therefore, one can calculate 
Aa = 2, Aciz = 1, and Acl3 = 2 
(A.40) 
The sets are now given by 
Sel = {CU, CU + 1, Cl1 + 2) 
(A.41) 
sa = (47 - C*l - 2ci1 - 4,47 - c21 - 2cll - 2). 
(A.42) 
Now, one can apply the constraint given by Eqn. 2.63 to obtain 

If cl1 and c21 are considered as taro dimensions of a threedimensional space, and if 7 is 
considered as a parameter, then this is the equation of a plane, and one can h d  a real A 
such that 
As a consequence, one can mite 
as shown in Case 1 of Table 2.2 (page 40). 
A.2.2 
Case 2: ISc,I = 2  and IS,I 
= 3  
Once again, let us define 
where cl1 < cl2 and al < a2 < ag. Moreover, let us define 
By exchanging the 101s 
of a and cl in the above proof, one can obtsin 
which ailows Eqn. 2.64 to be satisfied. By some manipulations, one obtains 
Aa2 = 2, Aa3 = 4, and Acl = 1. 
The sets can now be written as 
Similar to the previous demonstration, one can apply the constraint given by Eqn. 2.63 
to obtain 
S = + S ~  c S, +s,. 
(A.60) 

This problem has two solutions. Either 
C21 + Cl1 = 27 - 2, 
or 
C21 +Cl1 = 27- 1. 
Eqn. A.62 is equident to choosing A E R such that 
and Eqn. A.63 is equivalent to choosing A E 7Z such that 
In the case of Eqn. A.62, one c m  write 
as shown in Case 2 of Table 2.2 (page 40). In the case of Eqn. A.62, one can mite 
as shown in Case 3 of Table 2.2 (page 40). This completes the enurneration of redundant 
binary addition schemes, whose paxameters are 7 E { - 1,0,1) and A E L 
A.3 Characterization of Redundant Binary Number Addi- 
tion Schemes 
This section is concerned with a proof of Theorem 15, characterizing redundant binary 
addition schemes, and with the proof of for the equivaience of these schemes. 
Let us recall that Theorem 15 states that all redundaat binary addition schemes are 
characterized by 7, which determines the digit-set of the representation, and by A, which 
determines the sets of the weight aad tr8aSfer digits. 
Proof. Most of the proof has been given previously. The only sets SB and S,, that can 
be defined for a @en A are 

where czl= 7 - A - 1, i.e. 
because the number c21 was always given the same value in the previous demonstrations. 
If IS,I = 2 and IS,I 
= 3, then one can only find 
Sc, = {cil, cl1 f 1, cil + 2) 
(A.72) 
Sa = {e - - 2c11 - 4? 47 - ~ 2 1  - 2~11 - 2} 
(A.73) 
where c21 = 7 - A - 1, and where cil = 7 + A - 1. Hence, 
If 1 Sa 1 = 3 and 1 Sc, 1 = 2, t hen one cao only h d  
where c2l = 7 - A - 1, and where either cl1 = 7 + A - 1 or cl1 = 7 + A. Hence, one 
either has 
or has 
This completes the proof. 
u 
A.4 Equivalence of Redundant Binary Number Addition Schemes 
This section is concernai with a proof of Theorem 18, stating that certain addition schemes 
are quivalent, Le. two addition schemes may result in the same hardware implementation. 
First, one introduces functions that tranaform an addition scheme into another. Second, 
an equivalence relationship for addition schemes is d&ed. 
Finally, Theorem 18 is proven 
by demonstrating that there exist only two classes of equivalence for the above relationship. 
Let us introduce addition scheme transformations. 
Lemma 31 Cunsàder the dundant binaq number addition schemw A with pammeters 
(7, 
A) and A' with pammeters (y, A'). I f  thue addition achemw sot* 

then there ezist an E belonging to {&l) and tmwfonnatiow 
Tc, : x E S,*(E(X-(y+A)) +f+Af) ES& 
T, : z E S,ct(r(x - (y -A)) +y - A') E S& 
Ta: 
x~S,ct(r(x-(7-A))+f-A') ES, 
Tg : x E Sg *("x - 2(7 + A)) + 2(7' + A')) E Sb 
und 
such that T,,(Sc,) = S;,, TC2(Sca) = S&, T'(Sa) = So, TB($@) = Sfi, %(Sa) = SL, 
Tb(Sb) = Si, and T,(S,) = SL. Momver, one can define the inverse tmnsjomotions 
TG' : x E Sc, ct (e(x - (y' + A')) + 7 + A) E Si, 
TG' : x E S,ct(c(x - (y -At)) +r - A) E Si, 
TL' : x E S,H(E(X - (+-Af)) +y-A) E Si 
TB' : s E SB H ( ~ ( x  - 2(7' + A')) + 2(7 + A)) E Sb 
und 
such that T;~ (S&) = Sc,, T;'(S&) = S,, T;l(S;) = Sa, T;' (si) = SB, TC' (Sk) = S., 
T~'(S:) = Sb, and Tr1(S;) = S,. 
The proof of this lemma relies on the following two axioms. 
Axiom 32 If one defines S = S + (n), then S = S + {nt), where n' = -n. 
1 
Axiom 33 If one defines S = nS, then S = n'St, where n' = ;. 
Proof. The existence of the transformation from the digit set S = (7 - 1,7,7 + 1) to 
the digit set S = {y - 1, y, -/ + 1) is obtained immediately. In fact, if one subtracts 7 
fiom S, then one obtains So = (1, O, 1) (Axiom 32). Then, hom Axiom 33, 
Hence, e ( ~  
+ (-7 ) + (y) = S' (Axiom 32). By inverting the roles of S and Sr, one obtains 
the inverse tr d 
ormation. 
Let us now consider each digit-set cazdinsllity case separately to prove the existence of 
the minstormations for ci, a, 
c?, and and of their respective inverses. Axioms 32 and 33 
wiU be used throughout this demonstration, but wiil not be cited. 
Situation [Sc,I = 3, 1S9[ = 2. Since there is only one addition scheme with such 
parameters, one can m t e  

Hence, for ail c in (1, l}, 
€(SCi + (-7 - A)) = {i , O, 1) 
€(Sa+ (-7 +A}) = {I,l) 
4S,+ 
{-+A)) 
= {LI) 
€(Spi 2{-7 - A)) = 2{I, 1) 
By adding y + A' or 7' - A' appropriately, one can identifjr the results 
(Y + A') 4 
E(SC~ + {-7 - A)) = S& 
(Y - A') + €(Sa + (-7 + A)) = Sk 
(Y - A') 4 E(S- + {-7 + A}) = S& 
(Y + A') + C(S@ + 2{-7 - A)) = Sb 
The last equaüty was obtained by identification of the results. Thus, one found a 
transformation from A to A', and the reverse transformation exists and can be found 
by exchanging the roles of A and A'. 
Situation ISc, 1 = 2, ISaI = 3. There are two possible addition schemes A (and two A', 
respect iveiy) , namely, 
Sc, = (1, O) -i- 
{y + A} 
Sa ={1,1,3}+{7-~) 
Se= {I,l) +{T-A} 
sa = 2{I, 1) + 2{? + A}, 
SB = 2(1,1) + 2 { ~  + A). 
When A and A' are both in case 2 ofTsble 2.2, or both in case 3, one must choose 
c = 1. When A and A' are 
- in different cases (e.g. A is in case 2 and A' is in case 
3), one must choose r = 1. The trBPSfo~tions are obtained in the same way as 
in the previous situation, and the existence of the reverse transformation is obtained 
by exchanging the roIes of A and Ar. The existence of the transformations and their 
inverses is thus proven. 
Th* completes the proof. 
I 
Let us n m  introduce an equivalence relationship for addition schemes. Consider the re- 
dundant binaFy numbers addition schemes A and A , having parameters (7, 
A), and (y, A'), 
respectiveiy. If these addition schemes satjsfy Eqn. A.82, then A and A' are said to be re- 
hted through 'R In this way, Lemma 31 assures the existence of funaions assuring that 
the sets of A can be trdormed into the sets of Ar, and those of A' into those of A. 
In order to c h s  the space of addition schemes into taro groups, one needs to prove that 
'IS is an equivalence relationship. 

Proof. A relationship is an equivalence relationship when it is rdexive, symmetric, 
and transitive. 
The relationship 7Z is reflexive. Given 
= 7, Theorem 15 proves that there exist 
e =  1 and A1=A, such that A R A .  
The relationship 7Z is symmetnc, because the inverse tritIlSf0rmation.s exist. 
The relationship 7Z is transitive: if A R A', and if A' 7Z A", then there exists (c, d) in 
{i, 1)*, and there exists (A, A', A'') in z3 SU& that 
Tc1 ( 4  = 4% - (7 + A)) + y + A' 
and such that 
TL, (2) = C(X - (y + A')) + +y1' + A" 
TL ( x )  = d ( X  - (y - A')) + -/' - A" 
T,,(x)= 8 ( ~  
- (y -Ar)) +yt -A1' 
Tb(%) =g(z - 2(f + A')) + 2(7" + An) 
One can show that 
Indeed, there exists E" = e' x É in {f, lI2 and A" in 2 such that 
TC,(x)=dc(z-h+A))+ 
& ( + + A ~ - ( ~ + A ~ ) ) + ~ ~ + A ~ ~  
T:(~)=dc(s-(r-A)) + 
d(y-A'-(y-At))+f'-A'' 
T:(Z)=&C(Z-(y-A)) + 
$(y-A'-(y-At))+?-A" 
(A.92) 
T;(4 = M
x
 - 2(7 + A)) + 2€'((7' + A') - 2(7' + A')) + 2(f' + A") 
Tg(z) 
= dc(z - (7 + A)) + (y + A") 
T:(x) = dc(z - (7 -A)) + (y - A") 
(A.93) 
Tg(%) = de(% - (7 - A)) + (y - A") 
This completes the proof. 
Now that one has d&ed an quivalence relationship for addition schemes, one can 
find aJl the corresponding eqUvalence classes. Theorem 15 prwided the background to 
p r m  Lemma 31. The lemma established a relationship be- 
A and A' a9 soon as they 
were in the same situation listed in Table 2.1. 
Therefore, (1 Scl 1 , lSa 
1) = (3? 2) impiies 
ARA', and (1 Sc 1 ,1 Se 
1) = (2,3) &O impiies ARAt. Moreover , as 'R is an equivalence 
relationship on the set of addition schemes. Since every addition scheme in that set must 
mi& (1% 1 ,lSal) = (3,2) or (ISQ 
1 , ISo 1) = (2,3), then one can separate the set of addition 

schemes into two disjoint subsets C32 and C23, 
respectively, and C32 
U C23 
is equal to the 
whole set of addition schemes itself, thus establiahing that there are only two equivalence 
classes for R. 
In the following, a proof is given for Theorem 18. 
Proof. Assuming a hardware implementation of A's srchitecture were found, then 
three sub-circuits are dehed corresponding to the mappings Si, Sz, and S3. Using the 
trdormations between A and A' defined earlier, one can obtsin a circuit for the cells Si, 
Si, and Si, Le. derive a circuit for A'. Define the mapping Si as 
where (<,A, aA) = SI(~;l(aAt), TC' (bAt)). Then, defme the mapphg Si as 
such that 
where 4sa = s~(T&' ( c ~ , ~ / ) ,  
TF' (fi)). 
Given the above definitions, the mappings Si, Si, 
and Si are A% mappings, s3 proven below. 
The inputs and outputs of the defined architecture belon to the expected sets of A' 
by construction and by definition of the relationship R. 
oreover, the intermediate 
sets are of the expected size. 
h 
One has now to ptove that each mapping performs the expected function: 
Si. One cm write 
because r E {&l) 
(hence t? 
= i), proving that Si pedorms the expected opera- 
tion. 

Si. One can write 
because a E {i,l), proving that Si perfonns the expected operation. 
SJ. One can write 
because e E {I,1), proving that Si perforrns the expected operation. 
Therefore, simple transformations can be used to transform an architecture for A into an 
architecture for A'. If one chooses the same code for U A  and Ta(aA), and repeat the same 
procedure for all the variables and theh corresponding trdormatiom, then the circuit that 
performs Si is exactly the same as the one found for Si, 
because the same input codes m u t  
lead to the same output codes. This remark ean also be appiied to Si and Si. Therefore, the 
same circuit performs addition scheme A and addition scheme A', establishing the proof. i 
A.5 Conclusion 
The developments of the previous sections have established several t heorems. The resulting 
mathematical addition scheme hmework dlows one to furthes explore addition scheme 
similari t ies. 

