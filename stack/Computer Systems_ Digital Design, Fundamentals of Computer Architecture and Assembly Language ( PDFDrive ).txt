Ata Elahi
Computer 
Systems
Digital Design, Fundamentals of 
Computer Architecture and Assembly 
Language

Computer Systems

Ata Elahi
Computer Systems
Digital Design, Fundamentals of Computer
Architecture and Assembly Language

Ata Elahi
Southern Connecticut State University
New Haven, CT, USA
ISBN 978-3-319-66774-4
ISBN 978-3-319-66775-1
(eBook)
https://doi.org/10.1007/978-3-319-66775-1
Library of Congress Control Number: 2017952347
© Springer International Publishing AG 2018
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of
the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations,
recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and transmission
or information storage and retrieval, electronic adaptation, computer software, or by similar or
dissimilar methodology now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this
publication does not imply, even in the absence of a speciﬁc statement, that such names are exempt
from the relevant protective laws and regulations and therefore free for general use.
The publisher, the authors and the editors are safe to assume that the advice and information in this
book are believed to be true and accurate at the date of publication. Neither the publisher nor the
authors or the editors give a warranty, express or implied, with respect to the material contained
herein or for any errors or omissions that may have been made. The publisher remains neutral with
regard to jurisdictional claims in published maps and institutional afﬁliations.
Printed on acid-free paper
This Springer imprint is published by Springer Nature
The registered company is Springer International Publishing AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland

This book is dedicated to
Sara, Shabnam and Aria

Preface
This textbook is the result of my experiences teaching computer systems at the
Computer Science Department at Southern Connecticut State University since
1986. The book is divided into three sections: Digital Design, Introduction to
Computer Architecture and Memory, and ARM Architecture and Assembly Lan-
guage. The Digital Design section includes a laboratory manual with 12 experi-
ments using Logisim software to enforce important concepts. The ARM
Architecture and Assembly Language section includes several examples of assem-
bly langauge programs using Keil μVision 5 development tools.
Intended Audience
This book is written primarily for a one semester course as an introduction to
computer hardware and assembly language for students majoring in Computer
Science, Information Systems and Engineering Technology.
Organization
The material of this book is presented in such a way that no special background is
required to understand the topics.
Chapter 1 – Signals and Number Systems: Analog Signal, Digital Signal, Binary
Numbers, Addition and Subtraction of binary numbers, IEEE 754 Floating Point
representations, ASCII, Unicode, Serial Transmission, and Parallel Transmission.
Chapter 2 – Boolean Logics and Logic Gates: Boolean Logics, Boolean Algebra
Theorems, Logic Gates, Integrate Circuit (IC), Boolean Function, Truth Table of a
function and using Boolean Theorems to simplify Boolean Functions.
vii

Chapter 3 – Minterms, Maxterms, Karnaugh Map (K-Map) and Universal
Gates: Minterms, Maxterms, Karnaugh Map (K-Map) to simplify Boolean Func-
tions, Don’t Care Conditions and Universal Gates.
Chapter 4 – Combinational Logic: Analysis of Combination Logic, Design of
Combinational Logic, Decoder, Encoder, Multiplexer, Half Adder, Full Adder,
Binary Adder, Binary Subtractor, Designing Arithmetic Logic Unit (ALU) and
BCD to Seven Segment Decoder.
Chapter 5 – Synchronous Sequential Logic: Sequential Logic such as S-R Latch,
D-Flip Flop, J-K Flip Flop, T-Flip Flop, Register, Shift Register, Analysis of
Sequential Logic, State Diagram, State Table, Flip Flop Excitation Table and
Designing Counter.
Chapter 6 – Introduction to Computer Architecture: Components of a Micro-
computer, CPU Technology, CPU Architecture, Instruction Execution, Pipelining,
PCI, PCI Express, USB, and HDMI.
Chapter 7 – Memory: Memory including RAM, SRAM, DISK, SSD, Memory
Hierarchy, Cache Memory, Cache Memory Mapping Methods, Virtual Memory,
Page Table and the memory organization of a computer.
Chapter 8 – ARM Architecture and Instructions Part I: ARM Processor Archi-
tecture, and ARM Instruction Set such as Data Processing, Shift, Rotate, Uncondi-
tional Instructions and Conditional Instructions, Stack Operation, Branch, Multiply
Instructions and several examples of converting HLL to Assembly language.
Chapter 9 – ARM Instructions Part II: This chapter is the continuation of
Chapter 8 which covers Load and Store Instructions, Pseudo Instructions, ARM
Addressing Mode and data representation in memory.
Chapter 10 – ARM Assembly Language Programming Using Keil Development
Tools: Covers how to use Keil development software for writing assembly language
using ARM Instructions, Compiling Assembly Language and Debugging.
Instruction Resources: The instruction resources contains
•
Laboratory experiments using Logisim.
•
Solutions to the problems of each chapter.
New Haven, CT, USA
Ata Elahi
viii
Preface

Acknowledgments
I would like to express my special thanks to Professor Lancor Chairman of
Computer Science Department at Southern Connecticut State University for her
support as well as Professor Herv Podnar for his guidance.
I wish to acknowledge and thank Ms. Mary E. James, Senior Editor in Applied
Sciences and her assistant, Ms. Zoe Kennedy, for their support.
My special thanks to Marc Gajdosik, Nickolas Santini, Nicholas Bittar, Eric
Basini, Omar Abid and Alireza Ghods for their help in developing the manuscript.
Finally, I would like to thank the students of CSC 207 Computer Systems of
Spring 2017.
ix

Contents
1
Signals and Number Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
1.2
Analog Signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
1.2.1
Characteristics of an Analog Signal . . . . . . . . . . . . . .
3
1.3
Digital Signals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.4
Number System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.4.1
Converting from Binary to Decimal . . . . . . . . . . . . .
6
1.4.2
Converting from Decimal Integer to Binary . . . . . . . .
7
1.4.3
Converting Decimal Fraction to Binary . . . . . . . . . . .
8
1.4.4
Converting from Hex to Binary . . . . . . . . . . . . . . . . .
9
1.4.5
Binary Addition . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
1.5
Complement and Two’s Complement . . . . . . . . . . . . . . . . . .
11
1.5.1
Subtraction of Unsigned Number Using Two’s
Complement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.6
Unsigned, Signed Magnitude, and Signed Two’s
Complement Binary Number . . . . . . . . . . . . . . . . . . . . . . . . .
12
1.7
Binary Addition Using Signed Two’s Complement . . . . . . . . .
13
1.8
Floating Point Representation . . . . . . . . . . . . . . . . . . . . . . . .
14
1.8.1
Single Precision Representation . . . . . . . . . . . . . . . .
15
1.9
Binary-Coded Decimal (BCD) . . . . . . . . . . . . . . . . . . . . . . . .
16
1.10
Coding Schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
1.10.1
ASCII Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
1.10.2
Universal Code or Unicode . . . . . . . . . . . . . . . . . . . .
17
1.11
Parity Bit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
1.12
Clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
1.13
Transmission Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
1.13.1
Asynchronous Transmission . . . . . . . . . . . . . . . . . . .
22
1.13.2
Synchronous Transmission . . . . . . . . . . . . . . . . . . . .
23
xi

1.14
Transmission Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
1.14.1
Serial Transmission . . . . . . . . . . . . . . . . . . . . . . . . .
24
1.14.2
Parallel Transmission . . . . . . . . . . . . . . . . . . . . . . . .
24
1.15
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
2
Boolean Logics and Logic Gates . . . . . . . . . . . . . . . . . . . . . . . . . .
29
2.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
2.2
Boolean Logics and Logic Gates . . . . . . . . . . . . . . . . . . . . . .
30
2.3
Integrated Circuit (IC) Classiﬁcations . . . . . . . . . . . . . . . . . .
33
2.4
Boolean Algebra Theorems . . . . . . . . . . . . . . . . . . . . . . . . . .
36
2.5
Boolean Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
2.6
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
3
Minterms, Maxterms, Karnaugh Map (K-Map),
and Universal Gates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
3.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
3.2
Minterms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
3.3
Maxterms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
3.4
Karnaugh Map (K-Map) . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
3.4.1
Three-Variable Map . . . . . . . . . . . . . . . . . . . . . . . . .
53
3.4.2
Four-Variable K-Map . . . . . . . . . . . . . . . . . . . . . . . .
57
3.5
Sum of Products (SOP) and Product of Sums (POS) . . . . . . . .
58
3.6
Don’t Care Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
3.7
Universal Gates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
3.7.1
Using NAND Gates . . . . . . . . . . . . . . . . . . . . . . . . .
62
3.7.2
Using NOR Gates . . . . . . . . . . . . . . . . . . . . . . . . . .
63
3.7.3
Implementation of Logic Functions Using NAND
Gates or NOR Gates Only . . . . . . . . . . . . . . . . . . . .
64
3.7.4
Using NAND Gates . . . . . . . . . . . . . . . . . . . . . . . . .
64
3.7.5
Using NOR Gates . . . . . . . . . . . . . . . . . . . . . . . . . .
65
3.8
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
66
4
Combinational Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
4.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
4.2
Analysis of Combinational Logic . . . . . . . . . . . . . . . . . . . . . .
72
4.3
Design of Combinational Logic . . . . . . . . . . . . . . . . . . . . . . .
72
4.4
Decoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
75
4.4.1
Implementing a Function Using a Decoder . . . . . . . .
76
4.5
Encoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
4.6
Multiplexer (MUX) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
77
4.6.1
Designing Large Multiplexer Using Smaller
Multiplexers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
81
4.6.2
Implementing Functions Using Multiplexer . . . . . . . .
83
4.7
Half Adder, Full Adder, Binary Adder, and Subtractor . . . . . .
84
4.7.1
4-Bit Binary Adder . . . . . . . . . . . . . . . . . . . . . . . . .
87
4.7.2
Subtractor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
xii
Contents

4.8
ALU (Arithmetic Logic Unit) . . . . . . . . . . . . . . . . . . . . . . . .
88
4.9
Seven-Segment Display . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
4.10
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
92
5
Synchronous Sequential Logic . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
5.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
5.2
S-R Latch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
98
5.3
D Flip-Flop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
99
5.4
J-K Flip-Flop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
100
5.5
T Flip-Flop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
101
5.6
Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
101
5.7
Frequency Divider Using J-K Flip-Flop . . . . . . . . . . . . . . . . .
102
5.8
Analysis of Sequential Logic . . . . . . . . . . . . . . . . . . . . . . . . .
104
5.9
State Diagram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
106
5.10
Flip-Flop Excitation Table . . . . . . . . . . . . . . . . . . . . . . . . . . .
107
5.11
Counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
108
5.12
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
110
6
Introduction to Computer Architecture . . . . . . . . . . . . . . . . . . . .
115
6.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
6.2
Components of a Microcomputer . . . . . . . . . . . . . . . . . . . . . .
115
6.2.1
Central Processing Unit (CPU) . . . . . . . . . . . . . . . . .
116
6.2.2
CPU Buses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
116
6.2.3
32-Bit Versus 64-Bit CPU . . . . . . . . . . . . . . . . . . . .
118
6.3
CPU Technology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
118
6.4
CPU Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
120
6.5
Intel Microprocessor Family . . . . . . . . . . . . . . . . . . . . . . . . .
120
6.6
Multicore Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
122
6.7
CPU Instruction Execution . . . . . . . . . . . . . . . . . . . . . . . . . .
123
6.8
Disk Controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
125
6.9
Microcomputer Bus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
126
6.9.1
ISA Bus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
6.9.2
Microchannel Architecture Bus . . . . . . . . . . . . . . . . .
127
6.9.3
EISA Bus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
6.9.4
VESA Bus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
6.9.5
PCI Bus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
127
6.9.6
Universal Serial BUS (USB) . . . . . . . . . . . . . . . . . . .
128
6.9.7
USB Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . .
129
6.9.8
PCI Express Bus . . . . . . . . . . . . . . . . . . . . . . . . . . .
131
6.9.9
PCI Express Architecture . . . . . . . . . . . . . . . . . . . . .
131
6.9.10
PCI Express Protocol Architecture . . . . . . . . . . . . . .
132
6.10
FireWire . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
132
6.10.1
HDMI (High-Deﬁnition Multimedia Interface) . . . . . .
133
6.11
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
133
Contents
xiii

7
Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
7.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
7.2
Semiconductor Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . .
137
7.3
Hard Disk . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
142
7.4
Solid-State Drive (SSD) . . . . . . . . . . . . . . . . . . . . . . . . . . . .
144
7.5
Memory Hierarchy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
144
7.5.1
Virtual Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . .
153
7.5.2
Memory Organization of a Computer . . . . . . . . . . . .
155
8
Assembly Language and ARM Instructions Part I . . . . . . . . . . . .
161
8.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
161
8.2
Instruction Set Architecture (ISA) . . . . . . . . . . . . . . . . . . . . .
162
8.2.1
Classiﬁcation of Instruction Based on
Number of Operands . . . . . . . . . . . . . . . . . . . . . . . .
162
8.3
ARM Processor Architecture . . . . . . . . . . . . . . . . . . . . . . . . .
163
8.4
ARM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
165
8.5
ARM Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
166
8.5.1
Data Processing Instructions . . . . . . . . . . . . . . . . . . .
167
8.5.2
Compare and Test Instructions . . . . . . . . . . . . . . . . .
169
8.5.3
Register Swap Instructions (MOV and MVN) . . . . . .
170
8.5.4
Shift and Rotate Instructions . . . . . . . . . . . . . . . . . . .
171
8.5.5
ARM Unconditional Instructions and Conditional
Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
173
8.6
ARM Data Processing Instruction Format . . . . . . . . . . . . . . .
174
8.7
Stack Operation and Instructions . . . . . . . . . . . . . . . . . . . . . .
177
8.8
Branch (B) and Branch with Link Instruction (BL) . . . . . . . . .
178
8.8.1
B and BL Instruction Format . . . . . . . . . . . . . . . . . .
179
8.9
Multiply (MUL) and Multiply-Accumulate
(MLA) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
180
8.9.1
Multiply Instruction Format . . . . . . . . . . . . . . . . . . .
180
8.10
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
181
8.11
Problems and Questions . . . . . . . . . . . . . . . . . . . . . . . . . . . .
181
9
ARM Instructions Part II . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
185
9.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
185
9.2
ARM Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . .
185
9.2.1
ARM Pseudo Instructions . . . . . . . . . . . . . . . . . . . . .
186
9.2.2
Store Instructions (STR) . . . . . . . . . . . . . . . . . . . . . .
187
9.3
ARM Addressing Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . .
187
9.3.1
Immediate Addressing . . . . . . . . . . . . . . . . . . . . . . .
188
9.3.2
Pre-indexed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
188
9.3.3
Pre-indexed with Write Back . . . . . . . . . . . . . . . . . .
189
9.3.4
Post-index Addressing . . . . . . . . . . . . . . . . . . . . . . .
190
9.4
Swap Memory and Register (SWAP) . . . . . . . . . . . . . . . . . . .
191
xiv
Contents

9.5
Bits Field Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
191
9.5.1
BFC (Bit Field Clear Instruction) . . . . . . . . . . . . . . .
191
9.5.2
BFI (Bit Insertion Instruction) . . . . . . . . . . . . . . . . . .
192
9.6
Data Representation and Memory . . . . . . . . . . . . . . . . . . . . .
192
9.7
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
194
10
ARM Assembly Language Programming Using Keil
Development Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
197
10.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
197
10.2
Keil Development Tools for ARM Assembly . . . . . . . . . . . . . .
198
10.2.1
Assembling a Program . . . . . . . . . . . . . . . . . . . . . . . .
201
10.2.2
Running the Debugger/Simulator . . . . . . . . . . . . . . . .
204
10.2.3
Program Template . . . . . . . . . . . . . . . . . . . . . . . . . . .
208
10.3
Programming Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
208
10.4
Data Representation and Memory . . . . . . . . . . . . . . . . . . . . . .
209
10.5
Directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
209
10.5.1
Data Directive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
210
10.6
Memory in μVision v5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
211
10.7
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
212
Appendix: Digital Design Laboratory Experiments
Using LOGISIM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
217
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
255
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
257
Contents
xv

Chapter 1
Signals and Number Systems
Objectives: After completing this chapter, you should be able to:
•
Explain the basic components of a computer.
•
Distinguish between analog and digital signal.
•
Learn the characteristics of signal.
•
Convert decimal numbers to binary and vice versa.
•
Learn addition and subtraction of binary numbers.
•
Represent ﬂoating numbers in binary.
•
Convert from binary to hexadecimal and vice versa.
•
Distinguish between serial and parallel transmission.
1.1
Introduction
Numerical values have become an integral part of our daily lives. Numerical values
can be represented by analog or digital; examples include an analog watch, digital
watch, or thermometer. The following are advantages of digital representation of
numerical values compared to analog representation:
1. Digital representation is more accurate.
2. Digital information are easier to store
3. Digital systems are easier to design.
4. Noise has less effect.
5. Digital systems can easily be fabricated in an integrated circuit.
A digital signal is a discrete signal (step by step), and an analog signal is a
continuous signal. Digital systems are widely used and its applications can be seen
in computers, calculators, and cell phones. In a digital system, information is
transferred between components of the digital system in the form of digital signals.
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_1
1

A computer consists of two components: hardware and software. Hardware
refers to the physical components of a computer such as the keyboard, CPU, and
memory. Software refers to programs run by CPU including operating systems and
application programs. Computers can come in several different forms such as a
desktop, laptop, tablet, server, and iPhone. Regardless of the form, all computers
consist of the same basic structures. Figure 1.1 shows the basic components of a
computer.
Input Device The input device is used for entering information into memory.
Examples of input devices include the keyboard, mouse, touch pad screen, light
pen, barcode reader, and scanner. The input device converts information into bits,
and the bits are stored in memory.
Output Device A computer’s memory transfers information to the output device in
the form of bits. The output device converts bits to characters, images, and voices
which can be interpreted by humans.
Memory Memory is used to store information and programs. Memory comes in
the form of solid-state electronics such as RAM, ROM, ﬂash drive, or hard disk.
The Central Processing Unit (CPU) The CPU is used to perform computations
on information.
1.2
Analog Signals
An analog signal is a signal whose amplitude is a function of time and changes
gradually as time changes. Analog signals can be classiﬁed as nonperiodic and
periodic signals.
Nonperiodic Signal In a nonperiodic signal, there is no repeated pattern in the
signal as shown in Fig. 1.2.
Periodic Signal A signal that repeats a pattern within a measurable time period is
called a periodic signal, and completion of a full pattern is called a cycle. The
simplest periodic signal is a sine wave, which is shown in Fig. 1.3. In the time
domain, the sine wave amplitude a(t) can be represented mathematically as a(t) ¼
A Sin(ω t þ θ) where A is the maximum amplitude, ω is the angular frequency, and
θ is the phase angle.
Fig. 1.1 Basic components of a computer
2
1
Signals and Number Systems

A periodic signal can also be represented in the frequency domain where the
horizontal axis is the frequency and the vertical axis is the amplitude of the signal.
Figure 1.4 shows the frequency domain representation of a sine wave signal.
An electrical signal, usually representing voice, temperature, or a musical sound,
is made of multiple wave forms. These signals have one fundamental frequency and
multiple frequencies that are called harmonics.
1.2.1
Characteristics of an Analog Signal
The characteristics of a periodic analog signal are frequency, amplitude, and phase.
Frequency Frequency (F) is the number of cycles in 1 s, F ¼ 1
T, represented in Hz
(Hertz). If each cycle of an analog signal is repeated every 1 s, the frequency of the
signal is 1 Hz. If each cycle of an analog signal is repeated 1000 times every second
(once every millisecond), the frequency is
Time
Voltage
0
Fig. 1.2 Representation of
a nonperiodic analog signal
T
Volt
Time
Fig. 1.3 Time domain
representation of a sine
wave
Amplitude
ω
ω
A
Fig. 1.4 Frequency
representation of a sine
wave
1.2
Analog Signals
3

f ¼ 1
T ¼
1
103 ¼ 1000 Hz ¼ 1 kHz
Table 1.1 shows different values for frequency and their corresponding periods.
Amplitude The amplitude of an analog signal is a function of time as shown in
Fig. 1.5 and may be represented in volts (unit of voltage). In other words, the
amplitude is its voltage value at any given time. At the time t1, the amplitude of
the signal is V1.
Phase Two signals with the same frequency can differ in phase. This means that
one of the signals starts at a different time from the other one. This difference can be
represented in degrees (0 to 360) or by radians. A phase angle of 0 indicates
that the sine wave starts at time 0, and a phase angle of 90 indicates that the signal
starts at 90 as shown in Fig. 1.6.
Example 1.1 Find the equation for a sine wave signal with a frequency of 10 Hz,
maximum amplitude of 20 volts, and phase angle of 0:
Table 1.1 Typical units of frequency and period
Units of frequency
Numerical value
Units of period
Numerical value
Hertz (Hz)
1 Hz
Second (s)
1 s
Kilohertz (kHz)
103 Hz
Millisecond (ms)
103 s
Megahertz (MHz)
106 Hz
Microsecond (μs)
106 s
Gigahertz (GHz)
109 Hz
Nanosecond (ns)
109 s
Terahertz (THz)
1012 Hz
Picosecond ( ps)
1012 s
T/2
3T/4
T
t
-A
a(t)
t1= T/4
V1=+A
Fig. 1.5 A sine wave signal over one cycle
4
1
Signals and Number Systems

ω ¼ 2πf ¼ 2  3:1416  10 ¼ 62:83 rad
sec
a tð Þ ¼ 20 sin 62:83t
ð
Þ
1.3
Digital Signals
Modern computers communicate by using digital signals. Digital signals are
represented by two voltages: one voltage represents the number 0 in binary, and
the other voltage represents the number 1 in binary. An example of a digital signal
is shown in Fig. 1.7, where 0 volts represents 0 in binary and þ5 volts represents
1. 0 or 1 is called a bit and 8 bits is called a byte.
1.4
Number System
Numbers can be represented in different bases. A base of ten is called a decimal. In
the example, below consider 356 in decimal:
Fig. 1.6 Three sine waves with different phases
+5
1      
0        0
1        1
1
0
1
0
time
Fig. 1.7 Digital signal
1.4
Number System
5

356 ¼ 6 þ 50 þ 300 ¼ 6∗100 þ 5∗101 þ 3∗102
In general, a number can be represented in the form:
a5a4a3a2a1a0:a1a2a3
ð
Þr,
where r is the base of the number and ai must be less than r.
(10011)2 is a valid number but (211.01)2 is not.
Equation 1.1 can be used to convert a number in a given base to decimal:
ða5a4a3a2a1a0
|ﬄﬄﬄﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄﬄﬄﬄ}
Integer
:a1a2a3
|ﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄ}
Fraction
Þr ¼ a0  r0 þ a1  r1 þ a2  r2 þ a3  r3 þ . . .
þa1  r1 þ a2  r2 þ a2  r3 . . .
ð1:1Þ
Example 1.2 Convert (27.35)8 to the base of 10.
27:35
ð
Þ8 ¼ 7∗80 þ 2∗81 þ 3∗81 þ 5∗82 ¼ 7 þ 16 þ :375 þ :078125
¼ 23:45
ð
Þ10
Example 1.3 Convert 1101111 to decimal.
1101111
ð
Þ2 ¼ 1∗20 þ 1∗21 þ 1∗22 þ 1∗23 þ 0∗24 þ 1∗25 þ 1∗26
¼ 1 þ 2 þ 4 þ 8 þ 32 þ 64 ¼ 111
ð
Þ10
1.4.1
Converting from Binary to Decimal
Equation 1.2 represents the general form of a binary number:
a5a4a3a2a1a0:a1a2a3
ð
Þ2
ð1:2Þ
where ai is a binary digit or bit (either 0 or 1).
Equation 1.2 can be converted to decimal number by using Eq. 1.1:
ða5a4a3a2a1a0
|ﬄﬄﬄﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄﬄﬄﬄ}
Integer
:a1a2a3
|ﬄﬄﬄﬄﬄﬄ{zﬄﬄﬄﬄﬄﬄ}
Fraction
Þ2 ¼ a0  20 þ a1  21 þ a2  22 þ a3  23 þ . . .
þa1  21 þ a2  22 þ . . .
ð1:3Þ
6
1
Signals and Number Systems

a5a4a3a2a1a0:a1a2a3
ð
Þ2 ¼ a0 þ 2 a1 þ 4 a2 þ 8 a3 þ 16 a4 þ 32 a5 þ 64 a6
þ 1
2 ∗a1 þ 1
4 ∗a2 þ 1
8 ∗a3
Example 1.4 Convert (110111.101)2 to decimal.
110111:101
ð
Þ2 ¼ 1∗20 þ 1∗21 þ 1∗22 þ 0∗23 þ 1∗24 þ 1∗2∗5 þ 1∗21
þ 0∗22 þ 1∗23
¼ 55:625
Or
25
24
23
22
21
20
21
22
23
1
1
0
1
1
1
.
1
0
1
32 þ 16 þ 0 þ 4 þ 2 þ 1 þ 1=2 þ 0 þ 1=8
If a binary value is made of n bits of ones, then its decimal value is 2n  1.
Example 1.5
11 ¼ 22  1 ¼ 3
111 ¼ 23  1 ¼ 7
1111 ¼ 24  1 ¼ 15
11111 ¼ 25  1 ¼ 31
111111 ¼ 26  1 ¼ 63
Binary, or base of 2 numbers, is represented by 0s and 1s. A binary digit, 0 or 1, is
called a bit, 8 bits is called a byte, 16 bits is called a half word, and 4 bytes is called
a word.
1.4.2
Converting from Decimal Integer to Binary
To convert an integer number from decimal to binary, divide the decimal number
by the new base (2 for binary), which will result in a quotient and a remainder
(either 0 or 1). The ﬁrst remainder will be the least signiﬁcant bit of the binary
number. Continually divide the quotient by the new base, while taking the remain-
ders as each subsequent bit in the binary number, until the quotient becomes 0.
1.4
Number System
7

Example 1.6 Convert 34 in decimal to binary.
Quotient
Remainder
34/2 ¼
17
0 ¼ a0
17/2¼
8
1 ¼ a1
8/2
4
0 ¼ a2
4/2
2
0 ¼ a3
2/2
1
0 ¼ a4
1/2
0
1 ¼ a5
Therefore 34 ¼ (100010)2
If a binary number is made of all ones, then by using the equation 2n  1, it can
be converted to decimal.
Examples
Binary number
2n  1
Decimal number
11
22–1
3
111
23–1
7
1111
24–1
15
11111
25–1
32
A binary number is represented by a5 a4 a3 a2 a1 a0 where a0 is 20, a1 is 21, and
a5 is 25. Table 1.2 shows 2n.
1.4.3
Converting Decimal Fraction to Binary
A decimal number representation of (0.XY)10 can be converted into base of 2 and
represented by (0.a1, a2, a3, etc.)2.
The fraction number is multiplied by 2, the result of integer part is a1 and
fraction part multiply by 2, and then separate integer part from fraction, the integer
part represents a2; this process continues until the fraction becomes 0.
(0.35) 10 ¼ (
)2
0.35*2
¼
0.7
¼
0
þ
0.7
a1 ¼ 0
0.7*2
¼
1.4
¼
1
þ
0.4
a2 ¼ 1
0.4*2
¼
0.8
¼
0
þ
0.8
a3 ¼ 0
0.8*2
¼
1.6
¼
1
þ
0.6
a4 ¼ 1
0.6*2
¼
1.2
¼
1
þ
0.2
a5 ¼ 1
Sometimes, the fraction does not reach 0 and the number of bits use for the
fraction depends on the accuracy that the user deﬁnes, therefore the 0.35 ¼
0.010011 in binary
8
1
Signals and Number Systems

The hexadecimal number system has a base of 16 and therefore has 16 symbols
(0 through 9, and A through F). Table 1.3 shows the decimal numbers, their binary
values from 0 to 15, and their hexadecimal equivalents.
1.4.4
Converting from Hex to Binary
Table 1.3 can also be used to convert a number from hexadecimal to binary and
from binary to hexadecimal.
Example 1.7 Convert the binary number 001010011010 to hexadecimal. Each
4 bits are grouped from right to left. By using Table 2.2, each 4-bit group can be
converted to its hexadecimal equivalent.
Table 1.2 2n with different values of n
2n
Decimal value
2n
Decimal value
2n
Decimal value
20
1
28
256
216
65,536 ¼ 64 K
21
2
29
512
217
131,072 ¼ 128 K
22
4
210
1024 ¼ 1 K
218
262,144 ¼ 256 K
23
8
211
2048 ¼ 2 K
219
524,288 ¼ 512 K
24
16
212
4096 ¼ 4 K
220
1,048,576 ¼ 1 M
25
32
213
8192 ¼ 8 K
221
2 M
26
64
214
16,384 ¼ 16 K
222
4 M
27
128
215
32,768 ¼ 32 K
223
8 M
Table 1.3 Decimal numbers with binary and hexadecimal equivalents
Decimal
Binary (base of 2)
Hexadecimal (base of 16) or HEX
0
0000
0
1
0001
1
2
0010
2
3
0011
3
4
0100
4
5
0101
5
6
0110
6
7
0111
7
8
1000
8
9
1001
9
10
1010
A
11
1011
B
12
1100
C
13
1101
D
14
1110
E
15
1111
F
1.4
Number System
9

0010
1001
1010
2
9
A
Example 1.8 Convert (3D5)16 to binary. By using Table 2.2, the result in binary is:
3
D
5
0011
1101
0101
The resulting binary number is 001111010101.
Example 1.9 Convert 6DB from hexadecimal to binary. By using Table 1.3, the
result in binary is:
6
D
B
0110
1101
1011
The resulting binary number is 011011011011.
Example 1.10 Convert (110111.101)2 to decimal.
110111:101
ð
Þ2 ¼ 1∗20 þ 1∗21 þ 1∗22 þ 0∗23 þ 1∗24 þ 1∗2∗5 þ 1∗21
þ 0∗22 þ 1∗23
¼ 55:625
1.4.5
Binary Addition
1 þ 0 ¼ 1, 1 þ 1 ¼ 10,
Carry bits
11 1
10101
þ 01101
100010
In a binary number, the ﬁrst bit from the left of number is called the most
signiﬁcant bit (MSb), and the ﬁrst bit from the right of number is called least
signiﬁcant bit (LSb).
MSb ! 1 0 0 1 0  LSb
10
1
Signals and Number Systems

1.5
Complement and Two’s Complement
The complement of 1 is 0 and the complement of 0 is 1.
The complement of a binary number is calculated by complementing each bit of
the number.
Example 1.11 The complement of 101101 is 010010.
Two’s Complement of a number ¼ Complement of a number þ 1
Example 1.12 The two’s complement of 101011 is
010100 complement
ð
Þ þ 1 ¼ 010101
Example 1.13 Find the two’s complement of 10000:
01111 complement
ð
Þ þ 1 ¼ 10000
1.5.1
Subtraction of Unsigned Number Using Two’s
Complement
The following procedure is used to subtract B ¼ b5 b4 b3 b2 b1 b0 from A ¼ a5 a4 a3
a2 a1 a0:
1. Add two’s complement of B to the A.
2. Check to see if the result produces a carry:
(a) If the result produces a carry, discard the carry and the result is positive.
(b) If the result does not produce a carry, take two’s complement of the result,
and the result is negative.
Example 1.14 Subtract B ¼ 101010 from A ¼ 110101.
01010 1 ¼ Complement of B
Two’s complement of B ¼ 010101 þ 1 ¼ 010110
Add two’s complement of B to A.
1.5
Complement and Two’s Complement
11

110101 
+   010110
----------------
10 01011
Carry, discard the carry and the result is þ001011.
Example 1.15 Subtract B ¼ 110101 from A ¼ 101010.
Two’s complement of B is 001010 þ 1 ¼ 001011.
Add two’s complement of B to A.
001011
þ 101010
110101
As we can see, adding two 6-bit number results in a 6-bit answer. There is no
carry; we just take the two’s complement of the result.
Two’s Complement of 110101 ¼ 001010 þ 1 ¼ 001011
1.6
Unsigned, Signed Magnitude, and Signed Two’s
Complement Binary Number
A binary number can be represented in form unsigned number or signed number or
signed two’s complement, þ sign represented by 0 and – sign represented by 1.
Unsigned Number In an unsigned number, all bits of a number are used to
represent the number, but in a signed number, the most signiﬁcant bit of the number
represents the sign. A 1 in the most signiﬁcant position of number represents a
negative sign, and 0 in the most signiﬁcant position of number represents a
positive sign.
The 1101 unsigned value is 13.
Signed Magnitude Number In a signed number, the most signiﬁcant bit repre-
sents the sign, where 1101 ¼ 5 or 0101 ¼ þ5
In unsigned number, 1101 ¼ 13.
Signed Two’s Complement A signed two’s complement applies to a negative
number. If the sign of the number is one, then the number is represented by signed
two’s complement.
12
1
Signals and Number Systems

Example 1.16 Representing (5)10 with 4 bits in signed two’s complement.
(5)10 in signed number is 1101, then the two’s complement of 101 is 011, and
by adding sign bit results in 1011 which represents 5 in signed two’s complement.
Example 1.17 Represent (23)10 with an 8-bit signed two’s complement.
(23)10 ¼ (1 0 1 1 1)2 in unsigned base-2
(1 00 10111)2 – Extended to signed 8 bits (notice the MSb is 1)
the two’s complement of (0010111)2 is (1101001)2
(11101001)2 is (23)10 in signed two’s complement.
1.7
Binary Addition Using Signed Two’s Complement
The following examples show the results of the addition of two signed numbers:
(a) (þ3) þ (þ4)
Represent both numbers in binary, and the most signiﬁcant bit represents the
sign, and the result is positive.
0011 þ 0100 ¼ 0111 ¼ þ7
(b) (þ 3)10 þ (4)10
(4)10 in signed two’s complement is 1100, then
0011 þ 1100 ¼ 1111; result does not generate carry of then take two’s comple-
ment of result which is 1
3
ð
Þ þ þ5
ð
Þ ¼ 1101 þ 0101 ¼ 1 0010
discard carry and result is þ 2
ð
Þ
(c) (7)10 þ (5)10
By representing both numbers in 4-bit signed two’s complement,
7
ð
Þ10 ¼ 1001
5
ð
Þ10 ¼ 1011
1001 þ 1011 ¼ 10100
"
Signbit
The addition of two negative numbers results positive, and it is called overﬂow:
1.7
Binary Addition Using Signed Two’s Complement
13

þ7
ð
Þ þ þ6
ð
Þ ¼ 0111
ð
Þ þ 0110
ð
Þ ¼ 1101
The addition of two positive numbers results negative, and it is called overﬂow:
Example 1.18 A. Following addition using 8-bit signed two’s complement
(38)10 þ (44)10
38
ð
Þ10 in signed two’scomplement ¼ 11011010
þ44
ð
Þ10
þ
00101100
100000110 discard the carry and result is
00000110 ¼ 6
B. Add 38 to 44 using 8 bit signed two’s complement
38 ¼ 11011010
44 ¼ 11010100
------------
10101110 ¼ 82
C. Add þ100 to þ44
100 ¼ 01100100
44 ¼ 00101100
-------------
10010000
the sign of result is negative then results produce overﬂow
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
Addition Overﬂow The following cases result overﬂow for adding two signed
numbers if:
(a) Both numbers are negative, and results of addition become positive:
A
ð
Þ þ B
ð
Þ ¼ þC
(b) Both numbers are positive, and results of addition become negative:
þA
ð
Þ þ þB
ð
Þ ¼ C
1.8
Floating Point Representation
The central processing unit (CPU) typically consists of an arithmetic logic unit
(ALU), ﬂoating point unit (FLU/FPU), registers, control unit, and the cache
memory.
The arithmetic logic unit performs integer arithmetic operations such as addi-
tion, subtraction, and logic operations such as AND, OR, XOR, etc. Integers are
whole numbers without fractional components. 1, 2, and 3 are integers, while 0.1,
2.2, and 3.0001 all have fractional components are called ﬂoating point numbers.
14
1
Signals and Number Systems

The ﬂoating point unit performs ﬂoating point operations. Floating point num-
bers have a sign, a mantissa, and an exponent. The Institute of Electrical and
Electronics Engineers (IEEE) developed a standard to represent ﬂoating point
numbers, referred to as IEEE 754. This standard deﬁnes a format for both single
(32-bit) and double (64-bit) precision ﬂoating point numbers. Decimal ﬂoating
points are represented by M  10E, where M is the signed mantissa and E is the
exponent.
1.8.1
Single Precision Representation
Floating point numbers in single precision represented by 32 bits as shown in
Fig. 1.8
Biased Exponent The biased exponent is the exponent þ 127 (01111111)2;
therefore, the exponent is represented by a positive number.
Normalized Mantissa The mantissa is represented by 1. M, where M is called
normalized mantissa; if M ¼ 00101, then mantissa is 1.00101.
Example 1.19 Find normalized mantissa and biased exponent of (111.0000111)2.
111.0000111 can be written in the form of 1.110000111 * 210
Where
M ¼ 110000111
Biased exponent ¼ 10 þ 01111111 ¼ 10000001
The representation of 111.0000111 in single precision is
1bit
8 bits
23 bits
0
10000001
11000011100000000000000
Example 1.20 Convert the following single precision ﬂoating point to decimal
number.
101111101 11001000000000000000000
S ¼ 1 means mantissa is negative.
Biased exponent ¼ 01111101.
Exponent ¼ 01111101–01111111 ¼ 00000010.
Normalized mantissa ¼ 11001000000000000000000.
Mantissa ¼1. 11001000000000000000000.
Decimal number ¼ 1.11001000000000000000000 *210 ¼ 0.01110011.
Double Precision. In order to increase the accuracy of a ﬂoating point number,
IEEE 745 offers double precision represented by 64 bits as shown in Fig. 1.9.
Biased exponent ¼ exponent þ 1023
1.8
Floating Point Representation
15

Example 1.21 Represent 5.75 in IEEE 745 single precision.
15. 625 ¼ (1111.101)2
1111.101 ¼  1.11101101 * 211
S ¼ 1
Normalized mantissa ¼0.11101101.
Biased exponent ¼ 11 þ 01111111 ¼ 10000010.
IEEE745 single precision is
1 10000010 1110110100000000000000.
1.9
Binary-Coded Decimal (BCD)
In daily life, we use decimal numbers where the largest digit is 9, which is
represented by 1001 in binary. Table 1.4 shows decimal numbers and their
corresponding BCD code.
Fig. 1.8 IEEE 745 ﬂoating point single precision (S ¼ represent sign of mantissa. S ¼ 0 means
mantissa is positive, and S ¼ 1 means mantissa is negative)
Fig. 1.9 IEEE 745 double precision ﬂoating point format
Table 1.4 Binary-coded decimal (BCD)
Decimal
BCD
0
0000
1
0001
2
0010
3
0011
4
0100
5
0101
6
0110
7
0111
8
1000
9
1001
16
1
Signals and Number Systems

Example 1.21 Converting 345 to BCD
Using the table: 0011 0100 0101
Example 1.22 Convert (10100010010)BCD to decimal, separate each 4 bits from
right to left, and substitute the corresponding decimal number with BCD the results
in 512.
1.10
Coding Schemes
1.10.1
ASCII Code
Each character in ASCII code has a representation using 8 bits, where the most
signiﬁcant bit is used for a parity bit. Table 1.5 shows the ASCII code and its
hexadecimal equivalent.
Characters from hexadecimal 00 to 1F and 7F are control characters which are
nonprintable characters, such as NUL, SOH, STX, ETX, ESC, and DLE (data link
escape).
Example 1.23 Convert the word “network” to binary and show the result in
hexadecimal. By using Table 1.4, each character is represented by 7 bits and results
in:
1001110
1100101
1110100
1110111
1101111
1110010
1101011
N
e
t
w
o
r
k
Or in hexadecimal
4E
65
74
77
6F
72
6B
1.10.2
Universal Code or Unicode
Unicode is a new 16-bit character-encoding standard for representing characters
and numbers in most languages such as Greek, Arabic, Chinese, and Japanese. The
ASCII code uses 8 bits to represent each character in Latin, and it can represent
256 characters. The ASCII code does not support mathematical symbols and
scientiﬁc symbols. Since Unicode uses 16 bits, it can represent 65,536 characters
or symbols. A character in Unicode is represented by 16-bit binary, equivalent to
4 digits in hexadecimal. For example, the character B in Unicode is U0042H
(U represents Unicode). The ASCII code is represented between (00)16 and
(FF)16. For converting ASCII code to Unicode, two zeros are added to the left
side of ASCII code; therefore, the Unicode to represent ASCII characters is
1.10
Coding Schemes
17

Table 1.5 American Standard Code for Information Interchange (ASCII)
Binary
Hex
Char
Binary
Hex
Char
Binary
Hex
Char
Binary
Hex
Char
0000000
00
NUL
0100000
20
SP
1000000
40
@
1100000
60
,
0000001
01
SOH
0100001
21
!
1000001
41
A
1100001
61
a
0000010
02
STX
0100010
22
”
1000010
42
B
1100010
62
b
0000011
03
ETX
0100011
23
#
1000011
43
C
1100011
63
c
0000100
04
EOT
0100100
24
$
1000100
44
D
1100100
64
d
0000101
05
ENQ
0100101
25
%
1000101
45
E
1100101
65
e
0000110
06
ACK
0100110
26
&
1000110
46
F
1100110
66
f
0000111
07
BEL
0100111
27
’
1000111
47
G
1100111
67
g
0001000
08
BS
0101000
28
(
1001000
8
H
1101000
68
h
0001001
09
HT
0101001
29
)
1001001
49
I
1101001
69
i
0001010
0A
LF
0101010
2A
*
1001010
4A
J
1101010
6A
j
0001011
0B
VT
0101011
2B
þ
1001011
4B
K
1101011
6B
k
0001100
0C
FF
0101100
2C
,
1001100
4C
L
1101100
6C
l
0001101
0D
CR
0101101
2D
-
1001101
4D
M
1101101
6D
m
0001110
0E
SO
0101110
2E
.
1001110
4E
N
1101110
6E
n
0001111
0F
SI
0101111
2F
/
1001111
4F
O
1101111
6F
o
0010000
10
DLE
0110000
30
0
1010000
50
P
1110000
70
P
0010001
11
DC1
0110001
31
1
1010001
51
Q
1110001
71
q
0010010
12
DC2
0110010
32
2
1010010
52
R
1110010
72
r
0010011
13
DC3
0110011
33
3
1010011
53
S
1110011
73
s
0010100
14
DC4
0110100
34
4
1010100
54
T
1110100
74
t
0010101
15
NACK
0110101
35
5
1010101
55
U
1110101
75
u
0010110
16
SYN
0110110
36
6
1010110
56
V
1110110
76
v
0010111
17
ETB
0110111
37
7
1010111
57
W
1110111
77
w
0011000
18
CAN
0111000
38
8
1011000
58
X
1111000
78
x
0011001
19
EM
0111001
39
9
1011001
59
Y
1111001
79
y
18
1
Signals and Number Systems

0011010
1A
SUB
0111010
3A
:
1011010
5A
Z
1111010
7A
z
0011011
1B
ESC
0111011
3B
;
1011011
5B
[
1111011
7B
[
0011100
1C
FS
0111100
3C
<
1011100
5C
\
1111100
7C
\
0011101
1D
GS
0111101
3D
¼
1011101
5D
]
1111101
7D
}
0011110
1E
RS
0111110
3E
<
1011110
5E
^
1111110
7E
~
0011111
1F
US
0111111
3F
?
1011111
5F
-
1111111
7F
DEL
1.10
Coding Schemes
19

between (0000)16 and (00FF)16 . Table 1.6 shows some of the Unicode for Latin and
Greek characters. Unicode is divided into blocks of code, with each block assigned
to a speciﬁc language. Table 1.7 shows each block of Unicode for some different
languages (Fig. 1.10).
Table 1.6 Unicode values
for some Latin and Greek
characters
Latin
Greek
Character
Code (hex)
Character
Code (hex)
A
U0041
φ
U03C6
B
U0042
α
U03B1
C
U0043
γ
U03B3
0
U0030
μ
U03 BC
8
U0038
β
U03B2
Table 1.7 Unicode block
allocations
Start code (hex)
End code (hex)
Block name
U0000
U007F
Basic Latin
U0080
U00FF
Latin supplement
U0370
U03FF
Greek
U0530
U058F
Armenian
U0590
U05FF
Hebrew
U0600
U06FF
Arabic
U01A0
U10FF
Georgian
Fig. 1.10 Example of Unicode
20
1
Signals and Number Systems

Example of Unicode: open Microsoft Word and click on insert then symbol will
result Fig. 1.10. Click on any character to display the Unicode value of the
character, for example, Unicode for β is 03B2 in hex
1.11
Parity Bit
A parity bit is used for error detection of information, since a bit or bits may be
changed during the transmission of information from source to destination, a parity
bit is an extra bit appended to the information. It represents whether the number of
ones or zeroes is either even or odd in the original transmission and can alert the
destination to a loss of information.
Even Parity. The extra bit (0 or 1) is chosen such that the number of ones
becomes even.
Example 1.24 Our message is (00111)2. By appending a one to the left side of the
message, we create (100111)2. Our even parity bit has made the total number of
ones even (from 3 to 4 ones).
Our message is (10111)2. By appending a zero to the left side of the message, we
create (010111)2. Our even parity bit has left the total number of ones even (4 ones).
Odd Parity. The extra bit (0 or 1) is chosen such that the number of ones
becomes odd.
Our message is (10111)2. By appending a one to the left side of the message, we
create (110111)2. Our odd parity bit has made the total number of ones even (from
4 to 5 ones).
1.12
Clock
0 and 1 continuously repeated is called clock as shown in Fig. 1.11, when clock
change from 0 to 1 is called rising edge of clock and when clock change from 1 to
0 is called falling edge of clock.
Each cycle of the clock consists of 1 and 0 or 0 and 1; it is measured by time
(second). If one cycle represented by T and the unit of T is seconds, then
Fig. 1.11 Clock signals
1.12
Clock
21

F (frequency) ¼ 1/ T where the unit of frequency is hertz (Hz) and the unit of T is
seconds.
Example 1.25 What is the frequency of a clock if one cycle of the clock is equal to
0.5 ms?
F ¼ 1=T ¼ 1=0:5  103 ¼ 2000 Hz
1000 Hz
Kilohertz (KHz)
106 Hz
Megahertz (MHz)
109 Hz
Gigahertz (GHz)
1.13
Transmission Modes
When data is transferred from one computer to another by digital signals, the
receiving computer has to distinguish the size of each signal to determine when a
signal ends and when the next one begins. For example, when a computer sends a
signal as shown in Fig. 1.12, the receiving computer has to recognize how many
ones and zeros are in the signal. Synchronization methods between source and
destination devices are generally grouped into two categories: asynchronous and
synchronous.
1.13.1
Asynchronous Transmission
Asynchronous transmission occurs character by character and is used for serial
communication, such as by a modem or serial printer. In asynchronous transmis-
sion, each data character has a start bit which identiﬁes the start of the character and
1 or 2 bits which identiﬁes the end of the character, as shown in Fig. 1.13. The data
character is 7 bits. Following the data bits may be a parity bit, which is used by the
Start
 Bit                                                                                      Bit      Bit     Bit
D0     D1   D2  
  D3      D4    D5     D6     Parity  Stop  Stop
One Character
0
LSB
MSB
Fig. 1.13 Asynchronous transmission
Fig. 1.12 Digital signals
22
1
Signals and Number Systems

receiver for error detection. After the parity bit is sent, the signal must return to high
for at least 1 bit time to identify the end of the character. The new start bit serves as
an indicator to the receiving device that a data character is coming and allows the
receiving side to synchronize its clock. Since the receiver and transmitter clock are
not synchronized continuously, the transmitter uses the start bit to reset the receiver
clock so that it matches the transmitter clock. Also, the receiver is already
programmed for the number of bits in each character sent by the transmitter.
1.13.2
Synchronous Transmission
Some applications require transferring large blocks of data, such as a ﬁle from disk
or transferring information from a computer to a printer. Synchronous transmission
is an efﬁcient method of transferring large blocks of data by using time intervals for
synchronization.
One method of synchronizing transmitter and receiver is through the use of an
external connection that carries a clock pulse. The clock pulse represents the data
rate of the signal, as shown in Fig. 1.14, and is used to determine the speed of data
transmission. The receiver of Fig. 1.14 reads the data as 01101, each bit width
represented by one clock.
Figure 1.14 shows an extra connection is required to carry the clock pulse for
synchronous transmission. In networking, one medium is used for transmission of
both information and the clock pulse. The two signals are encoded in a way that the
synchronization signal is embedded into the data. This can be done with Manches-
ter encoding or Differential Manchester encoding.
1.14
Transmission Methods
There are two types of transmission methods used for sending digital signals from
one station to another across a communication channel: serial transmission and
parallel transmission.
Transmitter 
Receiver 
Clock
0        1       1          0        1
data
Fig. 1.14 Synchronous transmission
1.14
Transmission Methods
23

1.14.1
Serial Transmission
In serial transmission, information is transmitted 1 bit at a time over one wire as
shown in Fig. 1.15.
1.14.2
Parallel Transmission
In parallel transmission, multiple bits are sent simultaneously, 1 byte or more at a
time, instead of bit by bit as in serial transmission. Figure 1.16 shows how computer
A sends 8 bits of information to computer B at the same time by using eight
different wires. Parallel transmission is faster than serial transmission, at the same
clock speed.
1.15
Summary
Information exchanges between two electrical systems are in the form of digital or
analog signals.
Modern computers work with digital signals:
•
A digital signal is represented by two voltages.
1      0
  0
1
Ground Line
1     1        0          1
Fig. 1.15 Serial transmission
1         
0
1
0
1
1
0
1       
Clock
Computer
A
Computer
B
Fig. 1.16 Parallel transmission
24
1
Signals and Number Systems

•
Binary is the representation of a number in base of 2.
•
The frequency of a signal is the inverse of its cycle time.
•
One digit in binary is called a bit, 8 bits is called 1 byte, and 4 bytes is called
one word.
•
Information is represented inside the computer by binary or base of 2.
•
Negative numbers inside the computer is represented by the two’s complement.
•
The most signiﬁcant bit in signed numbers is represented by the sign of the
number.
•
Positive is represented by zero and negative is represented by one.
•
One’s complement of a binary number is the complement of each bit of the
number.
•
Two’s complement of a binary number is the complement of the number
plus one.
•
Binary-coded decimal (BCD) is used for representing decimal numbers from
0 to 9.
•
The hexadecimal number system is used in digital systems and computers as an
efﬁcient way of representing binary quantities.
•
Parity bit is used for error detection of one bit error.
•
IEEE 757 standard is used to represent ﬂoating point number.
•
Information is represented by ASCII code inside the computer; ASCII code is
made of 7 bits.
•
Information between components of a computer can be transmitted in serial or
parallel form.
•
In serial transmission, information is transmitted 1 bit at a time
•
In parallel transmission, information is transmitted in multiple bits at a time.
•
The next chapter will cover Boolean logic, Boolean algebra theorems, and logic
gates. Logic gate is the basic component of an integrated circuit (IC)
Problems and Questions
1. List three computer input devices.
2. List three computer output devices.
3. Show an analog signal.
4. Show a digital signal.
5. How many bits is:
(a) Byte
(b) Half word
(c) Word
6. Convert the following decimal numbers to binary:
(a) 35
(b) 85
(c) 23.25
7. Convert the following binary numbers to decimal:
1.15
Summary
25

(a) 1111101
(b) 1010111.1011
(c) 11111111
(d) 10000000
8. Convert the following binary numbers to hexadecimal:
(a) 1110011010
(b) 1000100111
(c) 101111.101
9. Find the frequency of digital signal with the following clock cycles:
(a) 1 s
(b) 0.1 s
(c) 0.02 s
(d) 0.02 ms
10. The following frequencies of a digital signal are given, ﬁnd the clock cycle of
digital signal:
(a) 10 Hz
(b) 200 Hz
(c) 10,000 Hz
(d) 4 MHz
11. Convert each of the following numbers to base of 10:
(a) (34A)16
(b) (FAC)16
12. Convert the following decimal numbers to base of 16:
(a) (234)10
(b) (75)10
13. Convert the following numbers to binary:
(a) (3FDA)16
(b) (FDA.5F)16
14. Perform the following additions:
1101010
1100101
1011011
þ1010111
15. Find two’s complements of the following numbers:
(a) 11111111
(b) 10110000
(c) 10000000
26
1
Signals and Number Systems

(d) 00000000
16. The word “LOGIC” is given.
(a) Represent in ASCII.
(b) Add even parity bit to each character and represent each character in hex.
17. Represent (465)10 in BCD.
18. Represent (100101100111)BCD in decimal.
19. Represent (110010000100)BCD in decimal.
20. Convert the following two’s complement numbers to decimal:
(a) 1011
(b) 11111001
(c) 10011111
21. Subtract the following unsigned numbers using two’s complement:
(a) 11110011–11000011
(b) 10001101–11111000
22. Perform addition of the following signed numbers; assume each number is
represented by 6 bits and state if the result of each addition produces overﬂow:
(a) (þ12) þ (þ7)
(b) (þ25) þ (þ30)
(c) (5) þ (þ 9)
(d) (6) þ (7)
(e) (36) þ (12)
23. What is the largest 16-bit binary value that can be represented by:
(a) Unsigned number
(b) Signed magnitude
(c) Signed two’s complement
24. Represent the following decimal numbers in IEEE 745 single precision:
(a) 34.375
(b) 0.045
25. Convert the following IEEE 745 single precision to decimal number:
(a) 1 10000100 01110000000000000000000
(b) 0 01111100 11100000000000000000000
26. List the types of transmission modes.
27. Convert each of the following signed magnitude numbers to decimal:
(a) 11000011
(b) 10001111
28. Represent each of the following numbers in 8-bit signed two’s complement:
1.15
Summary
27

(a) 15
(b) 24
(c) 8
29. Perform the following addition:
0F4A
þ420B
28
1
Signals and Number Systems

Chapter 2
Boolean Logics and Logic Gates
Objectives: After completing this chapter, you should be able to:
•
Understand the basic operation of Boolean theorems.
•
Explain the operation of different logic gates such as AND, OR, NOT, XOR, and
NAND gates.
•
Show the truth table of different logic gates.
•
Distinguish between the different types of integrated circuits (ICs).
•
Apply Boolean theorems to simplify Boolean function.
•
Draw logic circuit for Boolean function.
•
Show the truth table of Boolean function.
•
Find the output function of a digital logic circuit.
•
Distinguish between the SSI, MSI, LSI, and VLSI.
2.1
Introduction
Logic gates are made of transistors, and they are the basic components of integrated
circuit (IC). Logic gates are used for designing digital system; there are three basic
logic operations and they are called AND, OR, and NOT. The characteristic of a
digital system can be represented by a function or truth table. Boolean theorems are
used to simplify Boolean function in order to use fewer logic gates. Integrated
circuits are classiﬁed based on the number of gates that they contain, and they are
called SSI, MSI, LSI, and VLSI.
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_2
29

2.2
Boolean Logics and Logic Gates
AND Logic The AND logic is denoted by a period “.,” but most of the time, the
period is left out. X.Y or XY is pronounced as X AND Y.
X AND Y ¼ Z, Z ¼ 1 if and only if X ¼ 1 and Y ¼ 1 otherwise Z ¼ 0:
The AND logic operation can be represented by the electrical circuit of Fig. 2.1.
Assume X and Y are switches and Z is the light; X ¼ 0, Y ¼ 0 means the
switches are open and the light being off means zero and the light on means one.
Then we can make a table; Table 2.1 shows the operation of Fig. 2.1.
Figure 2.2 shows a 2-input AND gate and Table 2.2 shows the truth table for the
AND gate. The output of the AND gate is one when both inputs are one.
OR Logic. The OR operation is represented by a plus sign, “þ” or a V, where “þ”
is the most popular symbol used. X þ Y is pronounced X OR Y.
X þ Y ¼ Z, Z ¼ 1 if X ¼ 1 OR Y ¼ 1 or both X ¼ 1 and Y ¼ 1:
The OR operation can be represented by the electrical circuit in Fig. 2.3. In
Fig. 2.3, the light is off when both switches are off, and the light is on when at least
one switch is closed. Figure 2.4 shows a 2-input OR gate and Table 2.3 shows truth
table for the 2-input OR gate.
X
Y
Light
Fig. 2.1 Representation of
the AND operation
Table 2.1 Operation of
Fig. 2.1
X
Y
Light
Off
Off
Off
Off
On
Off
On
Off
Off
On
On
On
X
Y
Z=XY
Fig. 2.2 2-input AND gate
30
2
Boolean Logics and Logic Gates

NOT Logic The NOT logic performs a complement, meaning it converts a 1 to
0 and 0 to 1. Also called an inverter, the NOT X is represented by X0 or X. Figure 2.5
shows the NOT gate and Table 2.4 shows truth table for the NOT gate (inverter).
NAND Gate. Figure 2.6 shows 2-input NAND gate. The NAND gate can be made
from an AND gate and a NOT gate as shown in Fig. 2.7. Table 2.5 shows the truth
table of the 2-input NAND gate.
NOR Gate. Figure 2.8 shows a NOR logic gate. NOR gates are made of OR and
NOT gates. Table 2.6 shows the truth table of the 2-input NOR gate.
Table 2.3 Truth table of the
2-input OR gate
X
Y
Z
0
0
0
0
1
1
1
0
1
1
1
1
X
X
Fig. 2.5 NOT gate
Table 2.4 Truth table for the
NOT gate
X
X0
0
1
1
0
Table 2.2 AND gate truth
table
X
Y
Z
0
0
0
0
1
0
1
0
0
1
1
1
X                
Light
Battery 
Y
Fig. 2.3 Electrical circuit
representation of the OR
operation
X
Y
Z =X +Y
Fig. 2.4 2-input OR gate
2.2
Boolean Logics and Logic Gates
31

Exclusive OR Gate Figure 2.9 shows an exclusive OR gate. Exclusive OR is
represented by L and is labeled XOR. Table 2.7 shows the truth table for the XOR
gate.
X
M
Y ¼ X0Y þ XY0
X
Y
XY
Fig. 2.6 2-input NAND
gate
X
XY
XY
Y
Fig. 2.7 AND-NOT gates
used together to act as
NAND
Table 2.5 Truth table of the
2-input NAND
X
Y
XY
0
0
1
0
1
1
1
0
1
1
1
0
X
X + Y
Y
Fig. 2.8 NOR gate
Table 2.6 Truth table for the
2-input NOR gate
X
Y
X þ Y
0
0
1
0
1
0
1
0
0
1
1
0
X
XY’ + X’Y
Y
Fig. 2.9 2-input XOR
Table 2.7 Truth table for
XOR gate
X
Y
X L Y
0
0
0
0
1
1
1
0
1
1
1
0
32
2
Boolean Logics and Logic Gates

Exclusive NOR Gate Figure 2.10 shows an exclusive NOR gate. Exclusive NOR
is represented by ʘ and labeled XNOR. Table 2.8 shows the truth table for the
exclusive NOR gate.
Tri-State Device
Figure 2.11 shows the diagram of a tri-state device; the control line controls the
operation of tri-state devices.
In Fig. 2.11, if the control line is set to zero, then there is no connection between
input and output (the output is high impedance). If the control line is set to one, then
output value is equal to the input value.
Multiple Inputs Logic Gates
Figure 2.12 shows 3-input AND gate with its truth table, Fig. 2.13 shows 3-input
OR gate with its truth table, Fig. 2.14 shows 3-input NOR gates with its truth table,
and Fig. 2.15 shows 3-input NAD gate with its corresponding table.
2.3
Integrated Circuit (IC) Classiﬁcations
A transistor is a basic component of integrated circuits (IC). Figure 2.16 shows a
transistor with an IC. Transistors act like a switch in integrated circuits. An
integrated circuit is made from a hundred to millions of transistors.
Integrated circuits are classiﬁed based on the number of the gates inside the IC
such as SSI, MSI, LSI, and VLSI.
Fig. 2.10 Exclusive NOR
gate
Table 2.8 Truth table for
exclusive NOR gate
X
Y
X ʘ Y
0
0
1
0
1
0
1
0
0
1
1
1
Fig. 2.11 Tri-state device
2.3
Integrated Circuit (IC) Classiﬁcations
33

Small-Scale Integration (SSI) SSI refers to an IC that has less than 10 gates.
Figure 2.17 shows the inside of a 74HC08 (7408) IC, and Fig. 2.18 shows an image
of a 74HC08 IC.
X
F
Y
Z
X  Y  Z      F
0  0  0       0
0  0  1       0
0  1  0       0
0  1  1       0
1  0  0       0
1  0  1       0
1  1  0       0
1  1  1       1
Fig. 2.12 3-input AND
gate and its truth table
X
F
Y
Z
X  Y  Z      F
0  0  0       0
0  0  1       1
0  1  0       1
0  1  1       1
1  0  0       1
1  0  1       1
1  1  0       1
1  1  1       1
Fig. 2.13 3-input OR gate
and its truth table
X
F
Y
Z
X  Y  Z      F
0  0  0       1
0  0  1       1
0  1  0       1
0  1  1       1
1  0  0       1
1  0  1       1
1  1  0       1
1  1  1       0
Fig. 2.14 3-input NAND
gate and its truth table
X
Y
Z
F
X  Y  Z      F
0  0  0       1
0  0  1       0
0  1  0       0
0  1  1       0
1  0  0       0
1  0  1       0
1  1  0       0
1  1  1       0
Fig. 2.15 3-input NOR
gate and its truth table
34
2
Boolean Logics and Logic Gates

Integrated Circuit Pins Numbering Figure 2.18 shows a TTL 7408 IC; an IC
chip should be read with the notch on the left hand side. The labeling convention
starts with the left bottom pin under the notch and goes in a counterclockwise
direction.
The left bottom pin is pin #1.
The right bottom pin is pin #7.
The right upper pin is pin #8.
The left upper pin is pin #14.
As shown in Fig. 2.18, the IC number is 74LS08 where LS represents the
material IC was made with. Also on the IC, there is the letter M representing
Motorola which is the manufacturer of the IC, Intel uses the character “i,” and
Texas Instruments uses a map of Texas.
Fig. 2.18 74LS08 pins
Fig. 2.16 Transistor (left),
IC (right)
14
1
2
3
4
5
6
7
13
12
11
10
9
8
Fig. 2.17 TTL 7408
2 input AND gate
2.3
Integrated Circuit (IC) Classiﬁcations
35

Medium-Scale Integration (MSI). Refers to an IC that contains between 10 and
100 gates such as decoders and multiplexers.
Large-Scale Integration (LSI). Refers to an IC that contains between 100 and
1000 gates.
Very-Large-Scale Integration (VLSI). Refers to an IC that contains more than
1000 gates.
2.4
Boolean Algebra Theorems
Boolean theorems are used to simplify Boolean functions in order to use fewer
gates. Any variable such as X in binary can have a value of one or zero.
Theorem #1
X þ X ¼ X
Proof: Select X as 0 then 0 þ 0 ¼ 0; select X ¼ 1 then 1 þ 1 ¼ 1 results:
X þ X ¼ X.
Theorem #2
X þ 1 ¼ 1
Proof: Select X ¼ 0 then 0 þ 1 ¼ 1; select X ¼ 1 then 1 þ 1 ¼ 1; both cases
result in 1 then X þ 1 ¼ 1.
Theorem #3
X þ 0 ¼ X
Proof: Select x ¼ 0 then 0 þ 0 ¼ 0; select X ¼ 1 then 1 þ 0 ¼ 1; the result is
whatever value X is.
Theorem #4
X þ X0 ¼ 1
Proof: Select X ¼ 0 then 0 þ 1 ¼ 1; select X ¼ 1 then 1 þ 0 ¼ 1; in both cases
the result is 1.
Theorem #5
X:X ¼ X
Proof: Select X ¼ 1 then 1.1 ¼ 1; select X ¼ 0 then 0.0 ¼ 0; therefore XX ¼ X.
36
2
Boolean Logics and Logic Gates

Theorem #6
X:1 ¼ X
Proof: Select X ¼ 1 then 1.1 ¼ 1; select X ¼ 0 then 0.1 ¼ 0; therefore X.1 ¼ X.
Theorem #7
X:X0 ¼ 0
Proof: Select X ¼ 0 then 0.1 ¼ 0; select X ¼ 1 then 1.0 ¼ 0; both values of X
result in 0.
Theorem #8
X0
ð
Þ0 ¼ X
(00)0 ¼ (1)0 ¼ 0, (10)0 ¼ (0)0 ¼ 1 Whatever the value X has.
Distributive Theorem
X Y þ Z
ð
Þ ¼ XY þ XZ
In order to prove the above theorem, the truth table of both sides of the theorem
is generated as shown in Table 2.9 and shows both sides generate the same truth
table.
Table 2.9 The truth table for X(Y þ Z) ¼ XY þ XZ
2.4
Boolean Algebra Theorems
37

De Morgan’s Theorem I
X þ Y
ð
Þ0 ¼ X0 Y0
In this theorem the OR between X and Y is negated and changes the OR
operation to the AND operation.
Proof: By making a truth table for both sides of the theorem, it shows that both
sides of the theorem generate the same truth table (Table 2.10).
De Morgan’s Theorem II
XY
ð
Þ0 ¼ X0 þ Y0
In this theorem the XY is complemented and changes it from an AND operation
to an OR operation with each component complemented.
Example: (WXYZ)0 ¼ W0 þ X0 þ Y0 þ Z0
If the truth table of both sides were generated, then it would show that both sides
have the same truth table result.
Commutative Law
X þ Y ¼ Y þ X
XY ¼ YX
Associative Law
X YZ
ð
Þ ¼ XY
ð
ÞZ
X þ Y þ Z
ð
Þ ¼ X þ Y
ð
Þ þ Z
More Theorems
The following are useful theorems:
Table 2.10 The truth table showing De Morgan’s Law
38
2
Boolean Logics and Logic Gates

(a) X þ X0Y ¼ X þ Y
(b) X0 þ XY ¼ X0 þ Y
(c) X þ X0Y0 ¼ X þ Y0
(d) X0 þ XY0 ¼ X0 þ Y0
Example: Simplify the Following Functions
(a) F(X, Y, Z) ¼ XY0Z þ XY0Z0 þ XY
F(X, Y, Z) ¼ XY0(Z þ Z0) þ YZ where Z þ Z0 ¼ 1 then
F(X, Y, Z) ¼ XY0 þ XY ¼ X(Y þ Y0) ¼ X
(b) F(X, Y, Z) ¼ (X0 þ Y) (X þ Y0) ¼ X0X þ X0Y0 þ XY þ YY0 where X0X and
YY0 are zero then F(X, Y, Z) ¼ X0Y0 þ XY
2.5
Boolean Function
Boolean function is represented by algebraic expression which is made of binary
variables such as X, Y, and Z and logic operations between variables such as AND,
OR, and NOT.
F(X, Y, Z) ¼ X þ YZ is a Boolean function.
Figure 2.19 shows the logic circuit for function F where X, Y, and Z are the
inputs and F is the output; Table 2.11 shows the truth table of the function F.
The truth table shows the characteristics of function F; the function F ¼ 1 when
the inputs to the circuit are 100 or 101 or 110 or 111.
X
Y
Z
F(X,Y,Z)  = X + YZ
Fig. 2.19 Logic circuit for
a function F(X, Y,
Z) ¼ X þ YZ
Table 2.11 The truth table
for function F(X, Y,
Z) ¼ X þ YZ
X
Y
Z
YZ
X þ YZ
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
1
1
1
1
1
0
0
0
1
1
0
1
0
1
1
1
0
0
1
1
1
1
1
1
2.5
Boolean Function
39

Complement of a Function
In order to complement a function, both sides of the function must be
complemented.
Example: Complement the following function:
F X; Y; Z
ð
Þ ¼ XY þ Y0Z
Complementing both sides of the function F(X, Y, Z) results in the following:
F0 X; Y; Z
ð
Þ ¼ XY þ Y0Z
ð
Þ0 using De Morgan’s theorem:
F0 X; Y; Z
ð
Þ ¼ XY
ð
Þ0 Y0Z
ð
Þ0
F0 X; Y; Z
ð
Þ ¼ X0 þ Y0
ð
Þ Y þ Z0
ð
Þ
Example: Find the complement of the following function:
F X; Y; Z
ð
Þ ¼ X0 þ Y0
ð
Þ Y þ Z0
ð
Þ
Complement both sides of the function:
F0 X; Y; Z
ð
Þ ¼
X0 þ Y0
ð
Þ Y þ Z0
ð
Þ
½
0
Applying De Morgan’s theorem results
F0 X; Y; Z
ð
Þ ¼
X0 þ Y0
ð
Þ
½
0 þ
Y þ Z0
ð
Þ
½
0
F0 X; Y; Z
ð
Þ ¼
XY
ð
Þ
½
 þ
Y0Z
ð
Þ
½

F0 X; Y; Z
ð
Þ ¼ XY
ð
Þ þ Y0Z
ð
Þ
2.6
Summary
•
Boolean logic consists of the AND, OR, and NOT logics.
•
The output of the 2-input AND gate is one when both inputs are one; otherwise
the output is zero.
•
The output of the 2-input OR gate is one when at least one of the inputs is one;
otherwise the output is zero.
•
NOT gate performs one’s complement.
•
The integrated circuits (IC) are classiﬁed by SSI (small-scale integration), MSI
(medium-scale integration), LSI (large-scale integration), and very-large-scale
integration.
•
A NAND gate is equivalent of the AND-NOT.
•
A NOR gate is equivalent of the NOR-NOT.
•
The 2-input XOR has output one when the inputs are not equal; otherwise the
output is zero.
40
2
Boolean Logics and Logic Gates

•
The 2-input exclusive NOR (XNOR) is equivalent of the XOR-NOT.
•
Chapter 3 will cover minterms and maxterms, apply K-map to simplify a
function, and use universal gates to draw logic circuit.
Problems
1. Show truth table for 4-input AND, OR, NOR, and NAD gates.
2. If A ¼ 11001011 and B ¼ 10101110, then what is the value of the following
operations:
(a) A AND B
(b) A OR B
3. If A ¼ 11001011 and B ¼ 10101110, what is the value of the following
operations (F in hex ¼ 1111):
(a) A NOT
(b) A XOR B
(c) A AND 0F
(d) A AND F0
4. Draw a logic circuit for the following functions:
(a) F(X, Y, Z) ¼ XY0 þ XZ0 þ YZ
(b) F(X, Y, Z) ¼ (X þ Y0) (X0 þ Z0)(Y þ Z)
5. Use Boolean theorems to simplify the following expressions:
(a) X þ X þ X
(b) XY þ XY
(c) YYY
(d) X þ XY
(e) XY0 þ Y0
(f) (X þ Y)Y0
(g) (XY) þ (XY)0
(h) X0Y0 þ XY
6. Simplify the following functions:
(a) F(X, Y, Z) ¼ XY þ X0Y þ XZ
(b) F(X, Y, Z) ¼ (X þ Y) (X0 þ Y þ Z)
(c) F(X, Y, Z) ¼ XY0Z þ XYZ þ Y0Z
(d) F(X, Y, Z) ¼ XY þ X0YZ
(e) F(X, Y, Z) ¼ X0Y þ XYZ0
(f) F(X, Y, Z) ¼ (XY) þ (X þ Y þ Z)0X þ YZ
(g) F(X, Y, Z) ¼ (XY)0 þ (X þ Y þ Z)0
7. Find the truth table for the following functions:
(a) F(X, Y, Z) ¼ XY0 þ YZ þ XZ0
(b) F(X, Y, Z) ¼ (X þ Y0)(Y þ Z)(X0 þ Z0)
2.6
Summary
41

8. If A ¼ 10110110 and B ¼ 10110011, then ﬁnd
(a) A NAND B
(b) A NOR B
(c) A XOR B
9. Find the output of the following gates:
(a)
X
1
(b)
X
0
(c)
X
0
(d)
X
0
(e)
X
1
42
2
Boolean Logics and Logic Gates

10. Show the output of the following logic circuits:
(a)
A
A
C
B
(b)
B
C
A
B
(c)
B
C
A
B
2.6
Summary
43

11. Find the output function of the following logic circuits:
A
A
B
C
B
A
B
A
C
B
C
B
C
B
C
12. Find the output function of the following logic circuit:
X
Y
Z
13. Draw a logic circuit and show the truth table for the following functions:
(a) F(X, Y) ¼ (XY)0 þ X(X þ Y0)
(b) F(X, Y, Z) ¼ (X þ Y þ Z0)0 (X0 þ Y0)
(c) F(X, Y, Z) ¼ (X XOR Y) (X NOR Y0)
(d) F(X, Y, Z) ¼ (X0 þ Y0 þ Z) (X þ Y)
44
2
Boolean Logics and Logic Gates

14. Show truth table for each of the following functions:
(a) F(X, Y, Z) ¼ XY0 þ XZ0 þ YZ
(b) F(X, Y, Z) ¼ (X þ Y) (X þ Z0)
(c) F(X, Y, Z) ¼ XY (Y þ Z0)
15. Simplify the following functions:
(a) F(X, Y, Z) ¼ YZ þ (X þ Y)0 þ (XYZ)0
(b) F(X, Y, Z) ¼ (X þ Y þ Z)0 (X þ Y)
16. Draw Logic circuits for the following functions
(a) F(X, Y, Z) ¼ (X þ Y)0 þ YZ
(b) F(X, Y, Z) ¼ (XYZ)0 þ XZ þ YZ
2.6
Summary
45

Chapter 3
Minterms, Maxterms, Karnaugh Map
(K-Map), and Universal Gates
Objectives: After completing this chapter, you should be able to:
•
Represent a Boolean function in the form of sum of minters and product of
maxterm.
•
Generate a truth table from a function that is represented by the sum of
minterms.
•
Generate a truth table from a function that is represented by the product of
minterms.
•
Developed a function from the truth table.
•
Use K-map to simplify a function.
•
Apply don’t care condition in a K-map.
•
Draw logic circuit using only NAND or NOR gates.
3.1
Introduction
Digital circuit can be represented by a truth table or Boolean function. In a digital
circuit with multiple digital inputs and multiple digital outputs, the outputs depend
on the current value of inputs. A Boolean function can be represented in the form of
sum of minterms or the product of maxterms, which enable the designer to make a
truth table more easily. Also, Boolean functions can be simpliﬁed using Karnaugh
map (K-map) without using Boolean theorems, by transferring a function to
K-map and reading simpliﬁed function from K-map. Most digital systems are
designed by using universal gates (NAND or NOR).
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_3
47

3.2
Minterms
A minterm is associated with each combination of variables in a function. If a
function has n variables, then it has 2n minterms. Consider two Boolean variables,
X and Y. There are four different possible combinations that can be generated from
X AND Y, and they are X Y, X Y, X Y, and XY. These four combinations are called
the minterms for X AND Y. Table 3.1 shows the minterms and their designations
for F(X,Y) ¼ (X AND Y).
In Table 3.1, X Y ¼ 1, if X ¼ 0 and Y ¼ 0 then X Y is represented by m0 (decimal
number of 00); X Y ¼ 1 if X ¼ 0 and Y ¼ 1 then X Y is represented by m1; X Y ¼ 1
if X ¼ 1 and Y ¼ 0 and X Y is represented by m2; XY ¼ 1 if X ¼ 1 and Y ¼ 1 then
XY is represented by m3.
Application of Minterms. It is simple to generate a truth table from minterms and
vice versa. Consider the function F(X,Y) ¼ X Y +
X Y and its truth table
(Table 3.2); this function can be represented as F(X,Y) ¼ m1 + m2 or each minterm
that represents a one in the truth table. This may also be rewritten as F (X,
Y) ¼ ∑(1,2).
Three-Variable Minterms The three variables X, Y, and Z generate eight
minterms as shown in Table 3.3.
Example 3.1 Find the truth table for the following function:
F X; Y; Z
ð
Þ ¼ X0Y0Z þ X0YZ þ XYZ
The function F can be represented by a sum of the minterms (or where F ¼ 1):
F X; Y; Z
ð
Þ ¼ m1 þ m3 þ m7
or
F X; Y; Z
ð
Þ ¼
X
1; 3; 7
ð
Þ
Table 3.1 Minterms of
F(X,Y)
X Y
Minterm
Designation
0 0
X Y
m0
0 1
X Y
m1
1 0
X Y
m2
1 1
X Y
m3
Table 3.2 Truth table for
function F(X,Y) ¼ X Y
+ X Y with minterms
X
Y
F
0
0
0
m0
0
1
1
m1
1
0
1
m2
1
1
0
m3
48
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

The truth table for this function contains a one in row 1, row 3, and row 7. The
rest of the rows are zeros as shown in Table 3.4. The function for a truth table can
also be determined from the sum of the minterms.
Example 3.2 The following truth table is given; ﬁnd the function F.
In the following table, the output of function F is one when the input is 001 ¼ m1,
011 ¼ m3, 101 ¼ m5, and 111 ¼ m7; therefore F(X,Y,Z) ¼ m1 + m3 + m5 + m7 or
F X; Y; Z
ð
Þ ¼
X
1; 3; 5; 7
ð
Þ
X Y Z
F
0 0 0
0
0 0 1
1
0 1 0
0
0 1 1
1
1 0 0
0
1 0 1
1
1 1 0
0
1 1 1
1
Table 3.3 Three-variable
minterms
X Y Z
Minterms
Designation
0 0 0
X0Y0Z0
m0
0 0 1
X0Y0Z
m1
0 1 0
X0YZ0
m2
0 1 1
X0YZ
m3
1 0 0
XY0Z0
m4
1 0 1
XY0Z
m5
1 1 0
XYZ0
m6
1 1 1
XYZ
m7
Table 3.4 Truth table for
function F(X,Y,
Z) ¼ X0Y0Z + X0YZ + XYZ
X Y Z
F
0 0 0
0
0 0 1
1
0 1 0
0
0 1 1
1
1 0 0
0
1 0 1
0
1 1 0
0
1 1 1
1
3.2
Minterms
49

Substituting each designation of a minterm with its actual product term (e.g.,
m0 ¼ X0Y0Z0) results in the following function:
F X; Y; Z
ð
Þ ¼ X0Y0Z þ X0YZ þ XY0Z þ XYZ
Example 3.3 For the following truth table:
(a) Find the function F.
(b) Simplify the function.
(c) Draw the logic circuit for the simpliﬁed function.
X Y Z
F
0 0 0
1
0 0 1
0
0 1 0
1
0 1 1
1
1 0 0
0
1 0 1
0
1 1 0
0
1 1 1
1
From the truth table, where F ¼ 1, we select the minterms m0, m2, m3, and m7:
F X; Y; Z
ð
Þ ¼ m0 þ m2 þ m3 þ m7
Or
F X; Y; Z
ð
Þ ¼ X Y Z þ XY Z þ XYZ þ XYZ
XZ
Z
F X; Y; Z
ð
Þ ¼ X Z
Y þ Y

þ YZ
 X þ X

F X; Y; Z
ð
Þ ¼ X Z þ YZ
The logic circuit for the simpliﬁed function F is given in Fig. 3.1.
X
X’
X’Z’
Z’
Y
YZ
F
Z
Fig. 3.1 Logic circuit for F(X,Y,Z) ¼ X Z + YZ
50
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

3.3
Maxterms
Maxterm is complement of a minterm. If the minterm m0 is
 X Y Z

, then the maxterm
M0 is
 X Y Z

¼ X þ Y þ Z
Table 3.5 shows the maxterms for three variables.
In a truth table, an output of one represents minterms, and an output of zero
represent maxterms. Consider the truth Table 3.6, where the function F can be
expressed as the product of maxterms. (Please note: the product of maxterms, as
opposed to the sum of minterms.)
F(X,Y,Z) ¼ M0M2M4M5M6, or it can represented by
F X; Y; Z
ð
Þ ¼ π 0; 2; 4; 5; 6
ð
Þ
Substituting each designated maxterm with the corresponding maxterm results
in:
F X; Y; Z
ð
Þ ¼ X þ Y þ Z
ð
Þ X þ Y0 þ Z
ð
Þ X0 þ Y þ Z
ð
Þ X0 þ Y þ Z0
ð
Þ
Table 3.5 Maxterms of
function F(X,Y,Z)
X Y Z
Maxterm
Designation
0 0 0
X + Y + Z
M0
0 0 1
X + Y + Z0
M1
0 1 0
X + Y0 + Z
M2
0 1 1
X + Y0 + Z0
M3
1 0 0
X0 + Y + Z
M4
1 0 1
X0 + Y + Z0
M5
1 1 0
X0 + Y0 + Z
M6
1 1 1
X0 + Y0 + Z0
M7
Table 3.6 Truth Table for
F(X,Y,Z) ¼ M0M2M4M5M6
X Y Z
F
0 0 0
0
0 0 1
1
0 1 0
0
0 1 1
1
1 0 0
0
1 0 1
0
1 1 0
0
1 1 1
1
3.3
Maxterms
51

3.4
Karnaugh Map (K-Map)
Karnaugh maps are used to simplify a Boolean function without using Boolean
algebra theorems. A K-map is also another way to represent the truth table of a
function. K-maps are made of cells where each cell represents a minterm. Cells
marked with a one will be the minterms used for the sum of the minterms repre-
sentation of a function. Conversely, cells marked with a zero will be used for the
product of the maxterms representation.
Two variables X and Y can have four minterms as shown in Table 3.7. Each
minterm is represented by a cell in the K-map, so a two-variable K-map contains
four cells as shown in Fig. 3.2.
In Fig. 3.2 each cell represents a minterm. The cell located at row 0 and column
0 represents m0 (minterm zero) or X0Y0. The cell located at row 1 and column 1 is
represented by m3 or XY. As shown in Fig. 3.2, both cells in row zero contain X0, so
this row is labeled the X0 row. Both cells in row 1 contain X so that row is labeled as
the X row.
A K-map of a function is another way to represent the truth table of the function,
as seen in Fig. 3.3.
Consider the function F(X,Y) ¼ XY0 + X0Y0 ¼ m2 + m0. The truth table for the
function is given in Table 3.8, and the function is also mapped to a K-map as shown
in Fig. 3.3.
Adjacent Cell Two cells are adjacent if they differ on only one variable. The cells
X0Y0 and X0Y are adjacent because their only difference is Y0 and Y. Adjacent cells
can be combined in order to simplify a K-map’s function.
Table 3.7 Minterms for two
variables
X Y
Minterms
Designation
0 0
X0Y0
m0
0 1
X0Y
m1
1 0
XY0
m2
1 1
XY
m3
Fig. 3.2 Two-variable
K-map
52
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

As shown in the K-map, the cells m0 and m2 contain ones and the other cells
contain zeros. The cells m0 and m2 are adjacent to each other. Note that the adjacent
cells take up the entire column of Y0, and all other cells are zero. Our simpliﬁed
function is therefore F(X,Y) ¼ Y0.
Example 3.4 Simplify the following function:
F X; Y
ð
Þ ¼ X0Y þ XY0 þ XY
or
F X; Y
ð
Þ ¼ m1 þ m2 þ m3
Transferring minterms into a K-map results in Fig. 3.4.
As shown in Fig. 3.4, the cells m2 and m3 are adjacent, so they can be combined.
Likewise, the cells m1 and m3 can be combined. By reading the map, you will have
the simpliﬁed function.
Cells m2 and m3 are the entire row X, and cells m1 and m3 are the entire
column Y, with the other cell being zero. Therefore,
F X; Y
ð
Þ ¼ X þ Y
3.4.1
Three-Variable Map
A three-variable K-map contains eight cells, and each cell represents a minterm as
shown in Fig. 3.5.
X
X′ 0
X  1
Y
Y′
Y′
0
0
0
1
m1
m0
m2
m3
1
1
Fig. 3.3 The function
in a K-map
Table 3.8 The truth table for
the function F(X,
Y) ¼ XY0 + X0Y0
X Y
F
0 0
1
0 1
0
1 0
1
1 1
0
3.4
Karnaugh Map (K-Map)
53

Observe the following about the K-map in Fig. 3.5:
(a) At row 0, all four cells contain X0; therefore this row is labeled X0.
(b) At row 1, all four cells contain X; therefore this row is labeled X.
(c) At the columns 11 and 10, all four cells contain Y; therefore these columns are
labeled Y.
(d) At the columns 00 and 01, all four cells contain Y0; therefore these columns are
labeled Y0.
(e) At the columns 01 and 11, all four cells contain Z; therefore these columns are
labeled Z.
(f) At the columns 00 and 10, all four cells contain Z0; therefore these columns are
labeled Z0.
Adjacent cells can be grouped together in a K-map; in a K-map it can combine
2 cells, 4 cells, 8 cells, and 16 cells. Figure 3.6 shows how the ones could be
grouped in a K-map.
In Fig. 3.6, all four cells can be combined. Folding the K-map horizontally twice
will result in all of the ones overlapping, and row X0 covers all four ones.
For Fig. 3.7, consider folding a K-map once more. The four ones will overlap if
the map is folded once horizontally, then vertically. Also note that Z0 covers all four
ones.
Fig. 3.4 K-map for F(X,
Y) ¼ X0Y + XY0 + XY
Fig. 3.5 Three-variable
Map
54
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

Example 3.5 Simplify the following function:
F X; Y; Z
ð
Þ ¼ X0Y þ XZ þ XZ0
First, each term of the function must be transferred to the K-map.
(a) The ﬁrst term being X0Y, place a one on each cell located at the intersection of
the X0 row and the Y column as shown in Fig. 3.8. (m3 and m2)
Fig. 3.6 The grouping of
four cells in a K-map where
the simpliﬁed F(X,Y,
Z) ¼ X0
Fig. 3.7 Combing the four
Z0 cells together in the
K-map
Fig. 3.8 The combination
of the cells of the example
function in a K-map
3.4
Karnaugh Map (K-Map)
55

(b) The second term is XZ, so place a one on each cell located at the intersection of
the Y0 column and the X row. (m5 and m7)
(c) The third term being XZ0, place a one on each cell in the intersection of the X
row and the Z column. (m4 and m6)
Since our adjacent cells include the entire row X and every cell in the columns Y,
a simpliﬁed form of this function would be F(X,Y,Z) ¼ X + Y.
Example 3.6 Read the K-maps of Fig. 3.9a–d to determine the simpliﬁed function.
(a) All adjacent cells in columns Z0 and columns Y are one.
F X; Y; Z
ð
Þ ¼ Z0 þ Y
(b) The cells in row X0, columns Y0 are adjacent, as are the cells in row X,
columns Y.
F X; Y; Z
ð
Þ ¼ X0Y0 þ XY
Fig. 3.9 K-Maps for Example 3.6
56
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

(c) All cells are one, so the function is always equal to one.
F X; Y; Z
ð
Þ ¼ 1
(d) Without adjacent cells to simplify the terms, the function equals the ones:
F X; Y; Z
ð
Þ ¼ X0Y0Z þ X0YZ0 þ XY0Z0 þ XYZ
3.4.2
Four-Variable K-Map
Four-variable K-maps contain 16 cells as shown in Fig. 3.10. Please note the
speciﬁc layout of the map.
The following describes the coverage of each variable by K-map:
•
W covers rows 11 and 10.
•
W0 covers rows 00 and 01.
•
X covers rows 01 and 11.
•
X0 covers rows 00 and 10.
•
Y covers columns 11 and 10.
•
Y0 covers columns 00 and 01.
•
Z covers columns 01 and 11.
•
Z0 covers columns 00 and 10.
Example 3.7 Simplify the following function:
F W; X; Y; Z
ð
Þ ¼ m0 þ m2 þ m8 þ m10:
The function is transferred to the K-map as shown in Fig. 3.11. If the K-map is
folded once vertically and horizontally from the middle, then all four cells
Fig. 3.10 Four-variable
K-map
3.4
Karnaugh Map (K-Map)
57

containing one overlap each other. Note that each of these cells make up all
intersections of X0 and Z0.
The simpliﬁed function is F(W,X,Y,Z) ¼ X0Z0.
Example 3.8 Read the following K-map:
F W; X; Y; Z
ð
Þ ¼ X0Y0 þ X0Z þ XYZ0
3.5
Sum of Products (SOP) and Product of Sums (POS)
The sum of products of a function is its simpliﬁed sum of minterms.
Observe the function F(X,Y) ¼ XY0 + XY is in the form of SOP where the
addition sign is used for OR logic, and XY is called product. Consider function F1
(X,Y,Z) ¼ XY0 + YZ0 + XZ, and Fig. 3.12 shows logic circuit for function F1 which
is made of AND-OR.
Fig. 3.11 K-map for F(W,
X,Y,
Z) ¼ m0 + m2 + m8 + m10
58
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

Consider function F2(X,Y,Z) ¼ (X + Y0)(Y + Z0)(X + Z) which is represented by
the product of sums, and Fig. 3.13 shows logic circuit for function F2 which is in the
form OR-AND.
Example 3.9 Simplify the following function in the form of SOP and POS.
•
F(X,Y,Z) ¼ ∑(0,1,6,7)
Combining the ones (the minterms m0, m1, m6, and m7) in a K-map results in
Fig. 3.14.
The sum of products is therefore: F(X,Y,Z) ¼ X0Y0 + XY.
Combining the zeros in a K-map returns the signiﬁcant maxterms as in Fig. 3.15.
If F equals ∑(0,1,6,7), then F0 equals π(M2M3M4M5).
Since the product of maxterms is equal to the complement of F, in order to ﬁnd F,
both sides of the function will be complemented:
F X; Y; Z
ð
Þ ¼ XY0 þ X0Y
ð
Þ0
X
Y
Z
XY′
YZ′
F1
XZ
Fig. 3.12 Logic circuit for F1(X,Y,Z) ¼ XY0 + YZ0 + XZ made of AND-OR gates
Y
Z
Y′
Z′
X+Y′
X+Z
F2=(X+Y′)(Y+Z′)(X+Z)
Y+Z′
X
Fig. 3.13 Logic circuit for F2(X,Y,Z) ¼ (X + Y0)(Y + Z0)(X + Z)
3.5
Sum of Products (SOP) and Product of Sums (POS)
59

Using DeMorgan’s theorem
F X; Y; Z
ð
Þ ¼ XY0
ð
Þ0 X0Y
ð
Þ0
or
F(X,Y,Z) ¼ (X0 + Y)(X + Y0) in the ﬁnal, product of sums form.
3.6
Don’t Care Conditions
In a truth table, if certain combinations of the input variables are impossible, they
are considered don’t care conditions. These conditions are where the output of the
function does not matter. For example, binary-coded decimal (BCD) is 4 bits and
only 0000 to 1001 are used, so from 1010 to 1111 are not BCD; the truth table or
K-map values are don’t cares. A truth table or K-map cell marked with a “X” or “d”
is a don’t care term, and output will not be affected whether it is a one or zero. The
don’t care can be used to expand the adjacency of cells in a K-map to further
simplify a function, since their output does not matter.
Example 3.10 Figure 3.16 shows a K-map with don’t care minterms at m1, m10,
and m13. Since a don’t care can output either a zero or one, we can assume it is a one
in order to expand a grouping of adjacent cells.
Fig. 3.14 K-map for F(X,
Y,Z) ¼ ∑(0,1,6,7)
Fig. 3.15 K-map for F0(X,
Y,Z) ¼ π(M2M3M4M5)
60
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

From Fig. 3.16, the function would be F(W,X,Y,Z) ¼ XZ + X0Z0 + XW0.
When minterms for function F are don’t care terms, the don’t care function D is
equal to the sum of the don’t care minterm(s). If m7 is the only don’t care, then
don’t care function is represented by D(X,Y,Z) ¼ m7.
Example 3.11 Simplify the following function where D is a don’t care function:
F X; Y; Z
ð
Þ ¼ m0 þ m1 þ m2 þ m5
D X; Y; Z
ð
Þ ¼ m3 þ m7
Using these values results in the K-map in Fig. 3.17. By grouping adjacent cells
and using the don’t care terms, F(X,Y,Z) ¼ X0 + Z.
3.7
Universal Gates
The NAND and NOR gates are called universal gates. With NANDs or NORs,
designers are able to construct other logic gates such as OR, AND, and NOT gates.
Fig. 3.16 K-map with
don’t care minterms
Fig. 3.17 K-map for F(X,
Y,Z) ¼ m0 + m1 + m2 + m5
and D(X,Y,Z) ¼ m3 + m7
3.7
Universal Gates
61

3.7.1
Using NAND Gates
(a) NOT from NAND
A NOT gate is generated by connecting the inputs of a NAND gate together
as shown in the following ﬁgure.
X
X
X
(XX)'= X'
X
Or, it can be represented by: 
X’
(b) AND from NAND
An AND gate is constructed by connecting the inputs to a NAND gate and
putting another NAND on the output (to act as a NOT gate).
X
XY
(XY)’
Y
(c) OR from NAND
An OR gate is constructed by connecting each input to an individual NAND
gate and putting every output into a single NAND which acts as a NOT gate.
X
Y
Y′
X′
(X′Y′)′ = X+Y
62
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

3.7.2
Using NOR Gates
(a) NOT from NOR
A NOT gate is generated by connecting the inputs of a NOR gate together as
shown in the following ﬁgure.
X
X
X
( X + X)′ = X′
X
Or, it can be represented by: 
X′
(b) OR from NOR
An OR gate is constructed by connecting the inputs to a NOR gate and
putting another NOR on the output (to act as a NOT gate).
X
(X+Y)′
(X+Y)
Y
(c) AND from NOR
An AND gate is constructed by connecting each input to an individual NOR
gate and putting every output into a single NOR which acts as a NOT gate.
X
X′
(X′ + Y′)′ = XY
Y′
Y
3.7
Universal Gates
63

3.7.3
Implementation of Logic Functions Using NAND
Gates or NOR Gates Only
Many logic functions are implemented using only NAND or NOR gates, rather than
a combination of various gates. Most logic gate ICs contain multiple gates of a
single type, such as an IC containing eight AND gates. Using a single type of gate
can reduce the number of ICs needed.
Consider the function F(X,Y) ¼ X0Y0 + XY and its logic circuit diagram in
Fig. 3.18.
This diagram would require one IC for AND gates, another for NOT gates, and
one OR gate, or a total of three separate ICs.
By complementing the function twice, the right side of the equation may be
easier to use with NAND and NOR gates.
Example 3.12 Create a logic circuit using only NAND and only NOR for the
function F(X,Y) ¼ X0Y0 + XY.
3.7.4
Using NAND Gates
•
Complement the right side of the equation twice.
•
F(X,Y) ¼ X0Y0 + XY ! F(X, Y) ¼ [(X0Y0 + XY)0]0.
•
Use Boolean theorems to make it NAND friendly:
– F(X,Y) ¼ [(X0Y0)0(XY)0]0
Consider the ﬁnal function once more: F(X, Y) ¼ [(X0Y0)0(XY)0]0, and substitute
placeholders for the inner terms (Fig. 3.19).
•
F ¼ [(X0Y0)0(XY)0]0 ¼ [AB]0 (A NAND B)
– A ¼ (X0Y0)0 ¼ X0 NAND Y0
– B ¼ (XY)0 ¼ X NAND Y
– X0 ¼ X NAND X
– Y0 ¼ Y NAND Y
X
Y
X'
Y'
X' Y'
X Y
X Y + X' Y'
Fig. 3.18 Logic circuit for F(X,Y) ¼ XY + X0Z0
64
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

3.7.5
Using NOR Gates
•
Complement the right side of the equation twice:
– F(X,Y) ¼ X0Y0 + XY ! F(X, Y) ¼ [(X0Y0 + XY)0]0
•
Use Boolean theorems to make it NOR friendly:
– F(X,Y) ¼ [(X0Y0)0(XY)0]0
– F(X,Y) ¼ [(X+Y)(X0+Y0)]0
– F(X,Y) ¼ [(X+Y)0 + (X0+Y0)0]0
Consider the ﬁnal function once more: F(X, Y) ¼ [(X+Y)0 + (X0+Y0)0]0, and
substitute placeholders for the inner terms (Fig. 3.20).
•
F ¼ [(X0Y0)0(XY)0]0 ¼ [A+B]0 (A NOR B)
– A ¼ (X+Y)0 ¼ X NOR Y
– B ¼ (X0+Y0)0 ¼ X0 NOR Y0
– X0 ¼ X NOR X
– Y0 ¼ Y NOR Y
X
Y
F
(XY)
X’
(X’Y’)’
Y’
Fig. 3.19 Logic circuit of F(X,Y) ¼ X0Y0 + XY using only NAND gates
X
X’
(X+Y)’
(X’+Y)’
[(X+Y)’+(X’+Y’)]’
(X+Y)’+(X’+Y’)’
Y’
Y
Fig. 3.20 Logic circuit of F(X,Y) ¼ X0Y0 + XY using only NOR gates
3.7
Universal Gates
65

3.8
Summary
•
A digital circuit is made of the combination of the different gates with the
multiple digital inputs and the multiple digital outputs; the outputs depend
only to the current values of the inputs.
•
A combinational logic circuit can be represented by a Boolean function or truth
table.
•
Boolean theorems or K-map can be used to simplify a Boolean function.
•
Boolean function can be represented by the sum of the products (SOP) or the
product of sums (POS).
•
The NAND and NOR gates are called universal gates. It can generate other gates
by using NAND or NOR gates.
•
Don’t care condition is the input value that never applied to a combinational
circuit which results output with don’t care condition (0 or 1).
•
Chapters 1, 2, and 3 cover basic topics in order to be able to design digital
system; Chap. 4 presents how to design a digital system and covers digital
components that are used for designing digital system such as decoder, multi-
plexer, binary adder, binary subtractor, and arithmetic logic unit (ALU).
Problems
1. Find the output function of each truth table:
(a) As the sum of minterms
(b) As the product of maxterms
X Y Z
F
0 0 0
1
0 0 1
0
0 1 0
0
0 1 1
1
1 0 0
0
1 0 1
1
1 1 0
0
1 1 1
1
A B C D
F
0 0 0 0
1
0 0 0 1
0
0 0 1 0
1
0 0 1 1
1
0 1 0 0
0
0 1 0 1
1
0 1 1 0
1
0 1 1 1
1
1 0 0 0
1
(continued)
66
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

1 0 0 1
1
1 0 1 0
0
1 0 1 1
0
1 1 0 0
0
1 1 0 1
1
1 1 1 0
1
1 1 1 1
1
2. Generate truth table for the following functions:
(a) F(X,Y,Z) ¼ ∑(1,3,6,7)
(b) F(X,Y,Z) ¼ π(1,3,4)
(c) F(W,X,Y,Z) ¼ ∑(1,4,7,10,12,15)
(d) F(W,X,Y,Z) ¼ π(2,3,4,7,10,11,12,13)
3. Generate the function F for the following K-maps:
(a)
(b)
3.8
Summary
67

(c)
(d)
(e)
68
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

(f)
4. Find the simpliﬁed output function for the following truth table using a K-map:
(a)
X
Y
F
0
0
1
0
1
1
1
0
1
1
1
0
(b)
X
Y
Z
F
0
0
0
1
0
0
1
1
0
1
0
0
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
1
1
1
1
0
(c)
A B C D
F
0 0 0 0
1
0 0 0 1
0
0 0 1 0
1
0 0 1 1
1
0 1 0 0
0
0 1 0 1
1
(continued)
3.8
Summary
69

A B C D
F
0 1 1 0
1
0 1 1 1
1
1 0 0 0
1
1 0 0 1
1
1 0 1 0
0
1 0 1 1
0
1 1 0 0
0
1 1 0 1
1
1 1 1 0
1
1 1 1 1
1
5. Simplify the following functions using a K-map:
(a) F(X,Y) ¼ m2 + m3
(b) F(X,Y) ¼ X + X0Y
(c) F(X,Y) ¼ X0 + XY0
(d) F(X,Y,Z) ¼m0 + m2 + m5 + m7
(e) F(X,Y,Z) ¼ X0Y0Z0 + X0YZ + XY0Z + XYZ
(f) F(X,Y,Z) ¼ π(0, 2, 5, 7)
(g) F(X,Y,Z) ¼ XY0Z + X0 + Z + Y0Z0
(h) F(W,X,Y,Z) ¼ X0Y0Z0 + XYZ0 + WXY + W0X0Y0 + WZ
(i) F(W,X,Y,Z) ¼ X0 + XZ0 + WX0Y + W0Y0 + WZ
6. Simplify the following functions where D is a don’t care function:
(a) F(X,Y,Z) ¼ ∑(0,3,4)
D(X,Y,Z) ¼ ∑(2,6)
(b) F(W,X,Y,Z) ¼ ∑(0,1,3,5,9,11)
D(W,X,Y,Z) ¼ ∑(2,4,8,10)
7. Simplify the following functions in the form of SOP and POS, and draw a logic
circuit:
(a) F(X,Y,Z) ¼ ∑(0,2,5,7)
(b) F(W,X,Y,Z) ¼ ∑(0,1,4,6,9,11,13,15)
8. Draw logic circuits for the simpliﬁed functions from Problem 6:
(a) Using NAND gates
(b) Using NOR gates
9. Simplify the following function and draw a logic circuit using:
(a) NAND gates
(b) NOR gates
F W; X; Y; Z
ð
Þ ¼ W0X0Z0 þ XY0Z0 þ WX þ WY þ WX
00Y0Z0
70
3
Minterms, Maxterms, Karnaugh Map (K-Map), and Universal Gates

Chapter 4
Combinational Logic
Objectives: After completing this chapter, you should able to:
•
Find output function of a given digital circuit.
•
Design a combinational logic circuit using problem description.
•
Learn the operation of decoder and its application.
•
Learn application of encoder.
•
Design and learn the function of a multiplexer.
•
Develop half adder, full adder from logic gates.
•
Use full adder to design binary adder and subtractor.
•
Learn how to design ALU (arithmetic logic unit).
•
Use BCD to seven-segment decoder to display a number in decimal.
4.1
Introduction
Digital circuit is classiﬁed as combinational or sequential logic. Combinational
logic is a digital circuit with digital input or inputs and digital output or outputs, this
digital circuit performs a speciﬁc function, the output of combinational logic
depends on current value of inputs, and it is a memoryless circuit, but sequential
logic contains memory element. Figure 4.1 shows the block diagram of a combi-
national logic with inputs and outputs; in combinational logic, the outputs are a
function of the inputs.
Consider F(X,Y) ¼ XY0 þ X0Y which is given by Fig. 4.2; the logic circuit is
made of NOT, AND, and OR gates; the output of combinational logic will change
by changing the inputs. Table 4.1 shows truth table of Fig. 4.2.
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_4
71

4.2
Analysis of Combinational Logic
The objective of the analysis of combinational logic is to ﬁnd the output function
and truth table of a combinational logic circuit, Fig. 4.3 shows a combinational
logic, the output of the combinational logic is given by function F, and Table 4.2
shows the truth table of function F.
T1 ¼
X þ Z
ð
Þ0 þ XY

0 ¼ XY
ð
Þ0 X þ Z
ð
Þ XY
ð
Þ0 ¼ X þ Z
ð
Þ X0 þ Y0
ð
Þ
¼ XY0 þ X0Z þ Y0Z
F X; Y; Z
ð
Þ ¼ X þ Z
ð
Þ T1 ¼ X þ Z
ð
Þ XY0 þ X0Z þ Y0Z
ð
Þ
¼ XY0 þ XY0Z þ XY0Z þ X0Z þ Y0Z
F X; Y; Z
ð
Þ ¼
XY0 þ XY0Z þ X0Z þ Y0Z
¼ XY0 þ Y0Z X þ 1
ð
Þ þ X0Z
¼
XY0 þ Y0Z þ X0Z
4.3
Design of Combinational Logic
Figure 4.4 shows a block diagram of combinational logic; The following steps show
how to design a combinational logic:
1. Statement of the problem which describes the function of the combinational
logic.
Fig. 4.1 Block diagram
of a combinational logic
X
Y
Y’
X’
XY’
XY’+X’Y
X’Y
Fig. 4.2 Combinational logic circuit
Table 4.1 Truth table
of Fig. 4.2
X
Y
XY0
X0Y
F
0
0
0
0
0
0
1
0
1
1
1
0
1
0
1
1
1
0
0
0
72
4
Combinational Logic

2. Deﬁne the number of inputs and outputs or maybe they are given by the
statement of the problem.
3. Assign variables to the inputs and outputs.
4. Develop a truth table by writing all combinations for inputs. The outputs will be
determined by the statement of the problem.
5. Write the output functions using K-map.
6. Draw a logic circuit.
Example 4.1 Design a combinational logic circuit with three inputs and one
output; the output is one when the binary value of the inputs is greater than or
equal to three; otherwise the output will be zero.
Solution Figure 4.4 shows the block diagram of combinational logic with three
inputs and one output: the variables X, Y, and Z are assigned to the inputs, and
variable F is assigned to the output. Table 4.3 shows truth table for the problem
(Fig. 4.5).
In Table 4.3, all input combinations for X, Y, and Z are listed; then according to
the statement of the problem, the output F is one when the input is three or more;
X
XY
Y
F
Y
Z
(X + Z)’
X + Z
T1
[(X+Z)’ + XY]’
Fig. 4.3 Combinational logic
Table 4.2 Truth table
of Fig. 4.3
X Y Z
XY0
Y0Z
XZ0
F
0 0 0
0
0
0
0
0 0 1
0
1
0
1
0 1 0
0
0
0
0
0 1 1
0
0
0
0
1 0 0
1
0
1
1
1 0 1
1
1
0
1
1 1 0
0
0
1
1
1 1 1
0
0
0
0
Fig. 4.4 Block diagram
of a combinational logic
4.3
Design of Combinational Logic
73

otherwise the output is zero. The output function F can be represented by the sum of
minterms:
F X; Y; Z
ð
Þ ¼ m3 þ m4 þ m5 þ m6 þ m7
sum of minterms
ð
Þ
By transferring the minterms of F(X,Y,Z) into the K-map as shown in Fig. 4.6
and reading the simpliﬁed function from the K-map results F (X,Y,Z) ¼ X þ YZ.
Figure 4.7 shows the logic circuit for function F (Fig. 4.7).
Table 4.3 The truth table
for example 1
X Y Z
F
0 0 0
0
0 0 1
0
0 1 0
0
0 1 1
1
1 0 0
1
1 0 1
1
1 1 0
1
1 1 1
1
Fig. 4.5 Block diagram of combinational logic of example 4
Fig. 4.6 The K-map for
example 4
X
Y
Z
X + YZ
Fig. 4.7 The circuit
diagram for example 4
74
4
Combinational Logic

4.4
Decoder
A decoder is an MSI logic which generates the minterms of a set of inputs; the two
variables X and Y generate four minterms, and they are X0Y0 ¼ m0, X0Y ¼ m1,
XY0 ¼ m2, and XY ¼ m3. Figure 4.8 shows the block diagram of a 2*4 decoder
(2 inputs and 4 outputs), and Table 4.4 shows the truth table for a 2*4 decoder.
From the truth table of the decoder, the following functions are the outputs of a
decoder:
m0 ¼ X0Y0, m1 ¼ X0Y, m2 ¼ XY0, and m3 ¼ XY
Figure 4.9 shows logic circuit of 2*4 decoder. Most MSI ICs have an extra input
called enable/disable (E/D); the function of the E/D input is to enable or disable an
Fig. 4.8 The block diagram
of a 2*4 decoder
Table 4.4 The truth table for
a 2*4 decoder
X Y
m0
m1
m2
m3
0 0
1
0
0
0
0 1
0
1
0
0
1 0
0
0
1
0
1 1
0
0
0
1
X
Y
E/D
X’Y’=m0
X’Y=m1
XY’=m2
XY=m3
Fig. 4.9 Logic circuit of a
2*4 decoder with E/D
4.4
Decoder
75

IC as shown in Fig. 4.9. When E/D ¼ 0, all outputs of the decoder will be zeros
(meaning the decoder is disabled); the decoder only generates minterms when E/D
is set to one.
4.4.1
Implementing a Function Using a Decoder
Decoders
can
be
used
to
design
combinational
circuits.
Consider
F(X,
Y) ¼ XY þ X0Y0 which can be implemented using a decoder. The function can
be represented by F(X,Y) ¼ m3 þ m0. The function contains two variables which
are the inputs to the decoder; therefore, a 2*4 decoder is needed, and the output F is
the sum of minterms m3 and m0 which is shown in Fig. 4.10.
4.5
Encoder
An encoder is the opposite of a decoder; it has 2n inputs and n output, for n ¼ 2
means encoder has 22 ¼ 4 inputs and 2 outputs; the output is binary value of
selected input. Figure 4.11 shows block diagram of 4*2 encoder, and Table 4.5
shows the truth table for a 4*2 encoder. In Table 4.5, if A3 ¼ 1, then the output
XY ¼ 11, or if A2 ¼ 1, then the output XY ¼ 10.
Figure 4.12 shows the K-map for functions X and Y; the input combinations that
are not listed in the truth table of the 2*4 decoder are don’t care, designated by “X,”
in both K-maps. Figure 4.13 shows the logic circuit diagram of the 2*4 decoder.
Fig. 4.10 Implementing a function using decoder
Fig. 4.11 The block
diagram of a 4*2 encoder
76
4
Combinational Logic

4.6
Multiplexer (MUX)
A MUX is a combinational logic circuit with N inputs and one output; the function
of the MUX is to select one of the inputs from many and direct the input to the
output. Figure 4.14 shows the basic architecture of a multiplexer. A multiplexer that
has N inputs and one output is called an N-to-1 multiplexer. The internal switch
Table 4.5 The truth table
for a 4*2 encoder
A3
A2
A1
A0
X
Y
0
0
0
1
0
0
0
0
1
0
0
1
0
1
0
0
1
0
1
0
0
0
1
1
Fig. 4.12 The K-maps for
functions X and Y
4.6
Multiplexer (MUX)
77

selects one input line at a time and transfers that input to the output. When the
switch is in position A, it transfers input A to the output; when the switch moves to
position B, it transfers input B to the output. This method continues until the switch
moves to position D and transfers input D to the output.
The opposite of a multiplexer is a demultiplexer (DMUX), shown in Fig. 4.15.
The switch moves to send each input to the appropriate output. A DMUX has one
A0
A1
A2
A3
X
Y
Fig. 4.13 The logic circuit
diagram of the 4*2 encoder
MUX
  4*1
A
B
C
D
Inputs
Output DCBA
Select lines
Fig. 4.14 A 4-to-1 multiplexer
DMUX
  1*4
Input DCBA
A
B
C
D
Select Lines
0
1
2
3
Fig. 4.15 A 1-to-4 demultiplexer (DMUX)
78
4
Combinational Logic

input and N outputs – this is called a 1-to-N demultiplexer. When the switch is in
position 0, it transfers A to output port 0 and then moves to output port 1 and
transfers B to this port. This process continues until the switch moves to output port
3 and transfers D to port 3.
Figure 4.16 shows a 2*1 MUX where A and B are inputs and S is select line;
when S ¼ 0, the output of multiplexer is the value of A; when S ¼ 1, the output of
MUX is value of B.
Table 4.6 shows truth table of MUX for Fig. 4.16.
F S; A; B
ð
Þ ¼ m3 þ m5 þ m7
Fig. 4.16 Block diagram of
2*1 MX
Table 4.6 Truth table 2*1
MUX
S
A
B
F
0
0
0
0
0
0
1
0
0
1
0
1
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
0
1
1
1
1
4.6
Multiplexer (MUX)
79

Reading K-map results F(S,A,B) ¼ S0A þ SB.
Figure 4.17 shows logic circuit for 2*1 MUX.
Figure 4.18 shows a 4*1 MUX where I0, I1, I2, and I3 are the inputs, Y is the
output, and S0 and S1 are select lines. Table 4.11 shows the operation of the MUX.
The function Y can be generated from Table 4.7; when the inputs S0S1 ¼ 00,
then Y ¼ I0; when S0S1 ¼ 01, then Y ¼ I1; when S0S1 ¼ 10, then Y ¼ I2; when
S0S1 ¼ 11, then Y ¼ I3; therefore, the Y output is
Y ¼ S00 S10 I0 þ S00 S1I1 þ S0 S10 I2 þ S0 S1I0
Figure 4.19 shows the block diagram for a 4*1 MUX with E/D. Figure 4.20
shows logic circuit of 4*1 MUX; as shown in this ﬁgure, the E/D input is added to
the logic diagram of MUX; when E/D ¼ 0, the output Y ¼ 0, and the MUX is
disabled.
A
B
S
SB
S’A
S’A + SB
Fig. 4.17 Logic circuit for
2*1 MUX
Fig. 4.18 The block
diagram of 4*1 MUX
Table 4.7 The MUX
operation
S0
S1
Y
0
0
I0
0
1
I1
1
0
I2
1
1
I3
80
4
Combinational Logic

4.6.1
Designing Large Multiplexer Using Smaller
Multiplexers
By combining small MUXs, then it is able to generate a bigger MUX; an 8*1 MUX
can be constructed by two 4*1 multiplexers and one OR gate as shown in Fig. 4.21.
In this ﬁgure, A, B, and C are select lines. When A ¼ 0, the top MUX is enabled,
and when A ¼ 1, the lower MUX is enabled. Also, the 8*1 MUX can be
implemented using two 4*1 and one 2*1 MUX as shown in Fig. 4.22. In
Fig. 4.22, when A ¼ 0, the output F ¼ Y0, and when A ¼ 1, the output F ¼ Y1.
Fig. 4.19 Shows block
diagram of 4*1 MUX
with E/D
Fig. 4.20 The circuit logic diagram for a 4*1 MUX
4.6
Multiplexer (MUX)
81

Fig. 4.21 8*1 MUX using 4*1 MUX and OR gate
Fig. 4.22 8*1 MUX constructed with two 4*1 MUX and 2*1 MUX
82
4
Combinational Logic

4.6.2
Implementing Functions Using Multiplexer
(a) Implementing a three-variable truth table using a 8*1 MUX
MUX can be used to implement a digital function; consider truth Table 4.8; the
truth table is made of three variables, and it can use an 8*1 MUX to implant the
truth table (Table 4.8).
The truth table is made of three variables; therefore, an 8*1 MUX is needed;
the A, B, and C variables are connected to the select lines of MUX, and the inputs of
the MUX correspond to the output of truth table (Fig. 4.23).
(b) Implementing Table 4.8 using a 4*1 MUX
Number of variables – 1 ¼ number of select lines.
Three variables – 1 ¼ 2 number of select lines for MUX
If A and B are connected to select lines, when AB ¼ 00, there are two rows in
Table 4.9 with AB ¼ 00, then the output F depends on the value of C; in this case
C ¼ 0. Consider rows with AB ¼ 01, F ¼ 0 for C ¼ 0, and F ¼ 1 for C ¼ 1;
therefore, F ¼ C. Figure 4.24 shows implementation of Table 4.9 using 4*1 MUX.
Table 4.8 The truth table
for a MUX with three
variables
A
B
C
F
0
0
0
0
0
0
1
0
0
1
0
0
0
1
1
1
1
0
0
1
1
0
1
0
1
1
0
1
1
1
1
1
Fig. 4.23 The block
diagram of an 8*1 MUX
4.6
Multiplexer (MUX)
83

4.7
Half Adder, Full Adder, Binary Adder, and Subtractor
Half adder (HA) is a logic circuit that adds the bits X and Y; Fig. 4.25 shows block
diagram of a HA; the inputs to the HA are X and Y; the outputs of the HA are S
(sum) and C (carry). Table 4.10 shows the truth table for a HA. In this truth table,
when X ¼ Y ¼ 1, then X plus Y ¼ 10 results S ¼ 0 and C ¼ 1.
The functions S and C are
S ¼ m1 þ m2 ¼ X0Y þ XY0 ¼ X XOR Y
C ¼ XY ¼ X AND Y
Figure 4.26 shows logic circuit of half adder (HA).
Full Adder (FA) Figure 4.27 shows the block diagram of a full adder (FA). The
FA will add X þ Y þ Cin (each is only 1 bit), the outputs of the FA are called S and
Cout, and Table 4.11 shows the truth table of a FA; in this table, X, Y, and Cin are
added, and the results generate the sum (S) and carry (Cout).
The function of S can be represented by the sum of minterms as shown in
Eq. 4.1:
S X; Y; Cin
ð
Þ ¼ X0Y0Cin þ X0YCin0 þ X0YCin þ XY0Cin0 þ XYcin
ð4:1Þ
OR
Table 4.9 Truth tabe for
Fig 4.24
A
B
C
F
0
0
0
0
0
0
0
1
0
0
1
0
0
C
0
1
1
1
1
0
0
1
C0
1
0
1
0
1
1
0
1
1
1
1
1
1
Fig. 4.24 Multiplexer for
Table 4.9
84
4
Combinational Logic

S X; Y; Cin
ð
Þ ¼ Cin X0Y0 þ XY
ð
Þ þ Cin0 X0Y þ X0Y
ð
Þ
ð4:2Þ
X0Y þ X0Y ¼ X XOR Y ¼ A
X0Y0 þ XY ¼ X0Y þ X0Y
ð
Þ0 ¼ A0
Therefore, Eq. 4.2 can be written in the form of Eq. 4.3:
S X; Y; Cin
ð
Þ ¼ CinA0 þ Cin0A ¼ Cin XOR A
ð4:3Þ
Fig. 4.25 The block
diagram of a half adder
X
S
C
Y
Fig. 4.26 Logic circuit for
HA
Fig. 4.27 The block
diagram of a half adder
Table 4.10 The truth table
for a half adder
X Y
C
S
0 0
0
0
0 1
0
1
1 0
0
1
1 1
1
0
Table 4.11 The truth table
for a half adder
X Y Cin
Cout
s
0 0 0
0
0
0 0 1
0
1
0 1 0
0
1
0 1 1
1
0
1 0 0
0
1
1 0 1
1
0
1 1 0
1
0
1 1 1
1
1
4.7
Half Adder, Full Adder, Binary Adder, and Subtractor
85

Cout can be written in the form of the sum of minterms:
Cout X; Y; Cin
ð
Þ ¼ X0YCin, þ XY0Cin þ XYCin0 þ XYCin
OR
Cout X; Y; Cin
ð
Þ ¼ Cin X0Y; þXY0
ð
Þ þ XY Cin0 þ Cin
ð
Þ
OR
Cout X; Y; Cin
ð
Þ ¼ Cin X0Y; þXY0
ð
Þ þ XY
Figure 4.28 shows the logic circuit for a full adder.
Figure 4.29 shows block diagram of a full adder (FA), where X, Y, and Cin are
the inputs and S and Cout are the outputs.
X
Cout
S
Y
XY’ + X’Y
Cin
Fig. 4.28 Full adder logic circuit
Fig. 4.29 Block diagram
of FA
86
4
Combinational Logic

4.7.1
4-Bit Binary Adder
The function of a 4-bit binary adder is to add two 4-bit numbers such as:
X3X2X1X0 þ Y3Y2Y1Y0
When adding X0 by Y0, it results in a sum (S0) and a carry (C0); the C0 is then
added to X1 and Y1 which results in a S1 and a C1. Figure 4.30 shows 4-bit binary
adder; the Cin is connected to ground to represent zero.
The manufacturer diagram of the 4-bit binary adder is shown in Fig. 4.31 as one
IC, and the IC number is 7483.
B4
B1
A1
B4
B3
B2
A3
C4
C0
GND
C0
C4
B1
A1
A4
A3
A2
B3
B2
Vcc
Σ3
Σ4
Σ4
Σ3
Σ2
Σ1
Σ1
Σ2
A4
A2
16
1
2
3
4
5
6
7
8
15
14
13
12
11
10
9
Fig. 4.31 7483 4-bit binary
adder
Fig. 4.30 4-bit binary adder
4.7
Half Adder, Full Adder, Binary Adder, and Subtractor
87

4.7.2
Subtractor
A subtractor performs the subtraction of A  B or A þ B0 þ 1. Figure 4.32 shows a
diagram of a subtractor using a 4-bit binary adder. The CI is set to one, and inputs
B0, B1, B2, and B3 are complemented.
Figure 4.33 is a modiﬁcation of Fig. 4.32 which can perform both addition and
subtraction. CI is the carry in and CO is the carry out of the 4-bit binary adder. By
setting the Add/Sub switch to zero, it performs addition, and by setting Add/Sub
switch to one, it performs subtraction.
4.8
ALU (Arithmetic Logic Unit)
The function of the arithmetic logic unit (ALU) is to perform arithmetic opera-
tions such as addition and subtraction and bit-wise logic operations such as AND,
OR, and NOT. Figure 4.34 shows the block diagram of an ALU.
In Fig. 4.34, A and B buses are the inputs, and the C bus is the output of the ALU;
S1 and S0 are select lines that select the function of the ALU; Table 4.12 shows the
function of an ALU; assume A and B are 4 bits and represented by A3, A2, A1, and
A0 and B3, B2, B1, and B0.
The select lines of ALU deﬁnes the size of the multiplexer, since there are
2 select lines; therefore, the size of the MUX is 4*1 (4 inputs and 1 output); the
number of bits deﬁne the number of multiplexer. A and B are 4 bits; therefore, four
4*1 multiplexers are needed. Figure 4.35 shows a diagram of an ALU.
Fig. 4.32 4 bit subtractor
88
4
Combinational Logic

4.9
Seven-Segment Display
A seven-segment display is made of seven LEDs (light-emitting diode) as shown in
Fig. 4.36; a seven-segment display can display any one digit from zero to nine;
Fig. 4.37 shows the segments that should be on in order to display the digits from
0 through 9.
For displaying 0, all segments should be on except for g; for displaying 8, all
segments should be on. It requires a special decoder called a BCD to seven-segment
decoder to convert binary-coded decimal (BCD) to seven-segment display.
0
0
1
1
S0
B0
B1
B2
B3
A0
A0
B0
B1
B2
B3
A1
A2
A3
A1
A2
A3
Cl
– 0
– 1
– 0
– 0
– 0
– 1
1
1
1
0
0
– 0
– 0
– 0
1
Add=0
Sub=1
1
1
1
CO
S1
S2
S3
Fig. 4.33 Logic circuit for 4-bit adder and subtractor
Fig. 4.34 Block diagram of
an ALU
4.9
Seven-Segment Display
89

S1
DEV2
DEV2
DEV2
DEV2
S1
S0
D3
D2
D1
D0
0
0
0
0
S1
S0
D3
D2
D1
D0
S1
S0
D3
D2
D1
D0
S1
S0
D3
D2
D1
D0
C3
C2
C1
C0
C1
B3
B2
B1
B0
A3
A2
A1
A0
S3
S2
S1
S0
C0
S0
A0
A1
A2
A3
B0
B1
B2
B3
0
Fig. 4.35 A logic circuit diagram of an ALU
Table 4.12 The functions
of an ALU
S1
S0
ALU
0
0
A OR B
0
1
A þ B
1
0
A AND B
1
1
A0
a
b
g
f
e
d
c
Fig. 4.36 Seven-segment
display
Fig. 4.37 Seven-segment display from 0 to 9
90
4
Combinational Logic

Figure 4.38 shows a block diagram of the BCD to seven-segment decoder, and
Table 4.13 shows the truth table of the BCD to seven-segment decoder. The
decoder has 4 inputs and 7 outputs; the input to the decoder is BCD (binary-
coded decimal which is from 0000 through 1001), as shown in Table 4.13; if the
input value is greater than 1001, then the output is don’t care.
There are seven outputs, and each output requires a K-map in order to ﬁnd the
output functions. Figure 4.39 shows the K-map for output a.
By reading the K-map of Fig. 4.39, the result is function a:
a ¼ B0D0 þ A þ C þ BD
Using the above procedure, one can ﬁnd other output functions.
Fig. 4.38 A block diagram
of a BCD to seven-segment
decoder
Table 4.13 The truth table
for a BCD to seven-segment
decoder
A
B
C
D
a
b
c
d
e
f
g
0
0
0
0
1
1
1
1
1
1
0
0
0
0
1
0
1
1
0
1
0
0
0
0
1
0
1
1
0
1
1
0
1
0
0
1
1
1
1
1
1
0
0
1
0
1
0
0
0
1
1
0
0
1
1
0
1
0
1
1
0
1
1
0
1
1
0
1
1
0
1
0
1
1
1
1
1
0
1
1
1
1
1
1
0
0
0
0
1
0
0
0
1
1
1
1
1
1
1
1
0
0
1
1
1
1
0
0
1
1
1
0
1
0
d
d
d
d
d
d
d
1
0
1
1
d
d
d
d
d
d
d
1
1
0
0
d
d
d
d
d
d
d
1
1
0
1
d
d
d
d
d
d
d
1
1
1
0
d
d
d
d
d
d
d
1
1
1
1
d
d
d
d
d
d
d
4.9
Seven-Segment Display
91

4.10
Summary
•
Combinational circuit is a digital circuit with one or more digital inputs and
digital outputs.
•
The outputs of combinational circuit depend on current values of inputs.
•
A combinational logic circuit can be represented by a function or a truth table.
•
Decoder is a combinational logic with n inputs and 2n outputs; if n ¼ 2 then
decoder is 2*4.
•
Decoder generates minterms of inputs; a decoder with two inputs generates four
minterms.
•
Multiplexer is a combinational circuit with 2n inputs and one output, where n is
number of select lines. If n ¼ 2, then multiplexer will be 4*1.
•
The function of half adder (HA) is to add 2 bits and generate sum and carry.
•
The function of full adder (FA) is to add 3 bits.
•
The function of a 4-bit binary adder is to add two 4-bit numbers.
•
Arithmetic logic unit (ALU) is a combinational logic that performs arithmetic
operations and logic operations.
•
Seven-segment displays are used for displaying one digit of decimal number.
•
BCD to seven-segment decoder converts 4-bit BCD to 7 bits for interfacing to
7-segment displays.
•
Chapter 5 covers sequential logic circuit, and the topics presented in this chapter
are D, J-K, and T ﬂip-ﬂops, register, shift register, state diagram, state table, and
designing counter.
Problems
1. The following combinational circuit logic diagrams are given; ﬁnd the output
function and truth table for each function.
(a)
X
Y
F
Fig. 4.39 The K-map for
output a
92
4
Combinational Logic

(b)
X
Y
F
(c)
X
Y
F
(d)
X
Y
F
2. Find the output of following gates.
X
1
F =
F =
X
0
3. Find the output F for each set of inputs.
1
0
0
0
1
1
0
1
1
0
1
0
F
4.10
Summary
93

4. Design a logic circuit with three inputs and one output; the output generates even
parity bit of the inputs.
(a) Show the truth table.
(b) Find output function.
(c) Draw logic circuit.
5. Implement function F(X,Y,Z) ¼ XY0 þ XZ0 using:
(a) Decoder
(b) Multiplexer
6. Implement the following functions using only one decoder and external gates:
F1(X,Y,Z) ¼ ∑(0,3,4)
F2(X,Y,Z) ¼ ∑(2,3,5)
7. Implement a full adder using decoder.
8. The following multiplexer is given; complete its table.
A
B
C
F
0
0
0
0
1
1
0
1
0
1
1
1
1
0
0
1
0
1
1
1
0
0
0
1
9. Implement function F(W,X,Y,Z) ¼ ∑(0,1,3,4,7,8,9,11,12,15) using MUX.
10. Design an 8-bit binary adder using 4-bit binary adders.
94
4
Combinational Logic

11. Design a 16-bit binary adder using 4-bit binary adders.
12. Design a combinational logic with three inputs and three outputs; if input 0, 1,
2, or 3 then output 3 more than input, if input 4, 5, 6, or 7 then output 3 less than
the input.
13. A train with 7 wagons carry passenger and numbered from 1 to 7; each wagon
contains a binary switch for emergency, and when any of the switches become
on, then display wagon number in conductor cabin in decimal. Verify your
design using Logisim.
14. Design a combinational circuit with four inputs and one output; the input to the
combinational circuit is BCD, and output generates even parity for the input.
15. Design a 16*1 MUX using 4 *1 MUXs.
16. Design a 4-bit ALU to perform the following functions:
A þ B, A  B, A þ 1, A0, B0, A OR B, A XOR B, A AND B
17. Design a combinational logic that compares X and Y, where X ¼ X1X0 and
Y ¼ Y1Y0; the output of combinational logic is 1, when X < Y; otherwise the
output is 0.
(a) Show truth table.
(b) Find output function using K-map.
4.10
Summary
95

Chapter 5
Synchronous Sequential Logic
Objectives: After completing this chapter, you should be able to:
•
Analyze the sequential logic.
•
Learn operation of the S-R latch.
•
Design D ﬂip-ﬂop from S-R latch.
•
Learn the application of the D ﬂip-ﬂop.
•
Learn operation of the J-K and T ﬂip-ﬂops.
•
Design register and shift register using the D ﬂip-ﬂops.
•
Develop state table for a sequential circuit.
•
Develop state diagram from the state table.
•
Develop excitation table for each types of ﬂip-ﬂop.
•
Design digital counter.
5.1
Introduction
Sequential logic circuit contains memory elements, and the output depends on the
current value of input and prior input-level conditions. Figure 5.1 shows block
diagram of sequential logic as shown in this ﬁgure; the outputs depend on the inputs
and current state of memory elements; in this ﬁgure, the outputs of combinational
logic are the inputs to memory elements, and the outputs of memory elements are
the inputs to combinational logic; the basic elements of memory elements are ﬂip-
ﬂops that can hold binary values as long as the device is powered. The output of a
synchronous sequential logic depends on the outputs of memory elements and
inputs. The applications of synchronous sequential logic are designing register,
counter, and memory. Synchronous sequential logic operates with the clock pulse.
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_5
97

5.2
S-R Latch
S-R latch is a type of memory with two inputs S (set) and R (reset), two outputs Q,
and Q0, and the outputs are the complement of each other. Figure 5.2 shows block
diagram of a S-R latch.
A S-R latch can be constructed with NOR or NAND gates: Fig. 5.3 shows S-R
latch using NOR gates and Fig. 5.4 shows S-R latch using NAND gates.
Fig. 5.1 Block diagram of synchronous sequential logic
Fig. 5.2 Block diagram
of S-R latch
S
R
Q
Q'
Fig. 5.3 Logic circuit
of S-R latch using NOR
gates
S
R
Q
Q'
Fig. 5.4 Logic circuit
of S-R latch using NAND
gates
98
5
Synchronous Sequential Logic

S-R Latch Operation Consider S-R latch of Fig. 5.4 which is constructed with
NAND gates; the following steps describe the operation of S-R latch, and Table 5.1
shows its characteristic table:
1. By setting S ¼ 0 and R ¼ 0, results outputs Q ¼ Q0 ¼ 1 which are not permitted
because Q and Q0 must be a complement of each other; therefore, S ¼ R ¼ 0 is
prohibited.
2. By setting S ¼ 0 and R ¼ 1, results Q ¼ 1 and Q0 ¼ 0 as shown in Table 5.1, if S
changes from 0 to 1 then Q does not change.
3. By setting S ¼ 1 and R ¼ 0, results Q ¼ 0 and Q0 ¼ 1, if R changes from 0 to
1 then the Q does not change. It can conclude when S ¼ R ¼ 1 the output of Q
does not change (if Q ¼ 0 stays 0 or Q ¼ 1 stays 1). The S-R latch is a basic logic
circuit for D, J-K, and T ﬂip-ﬂops.
5.3
D Flip-Flop
D ﬂip-ﬂop is a 1-bit memory, and it is used for designing SRAM (Static RAM) and
register; Fig. 5.5 shows the logic diagram of D ﬂip-ﬂop. The inputs to ﬂip-ﬂop are D
and clock. When the clock is 0, then S ¼ R ¼ 1, and according to Table 5.2 the
output of ﬂip-ﬂop doesn’t change, by setting D to 0, and changing clock from 0 to
1 results S ¼ 0 and R ¼ 1 then Q ¼ 0 and Q0 ¼ 1; this means when input D ¼ 0 and
applying clock, the output Q changes to 0. Setting D to 1 and changing clock from
0 to 1 results S ¼ 0 and R ¼ 1, and then according to Table 5.2, the Q sets to one;
this means when input D ¼ 1 and applying clock, the output Q changes to
1. Figure 5.6 shows block diagram of D ﬂip-ﬂop, and rising edge of the clock is
represented by “ ” and Table 5.2 shows a characteristic table of D ﬂip-ﬂop.
Table 5.1 Characteristic
table of S-R latch
S
R
Q
Q0
0
0
1
1 Forbidden
0
1
1
0
1
1
1
0 No change
1
0
0
1
1
1
0
1 No change
D
Clock
010
S
R
Q
Q'
Fig. 5.5 Logic circuit of D ﬂip-ﬂop
5.3
D Flip-Flop
99

5.4
J-K Flip-Flop
Figure 5.7 shows block diagram of a J-K ﬂip-ﬂop where J, K, and clock are the
inputs to the J-K ﬂip-ﬂop. The application of J-K ﬂip-ﬂop is counter and frequency
divider. Table 5.3 shows characteristic table of J-K ﬂip-ﬂop, and the following steps
describe J-K ﬂip-ﬂop operations:
(a) By setting J ¼ K ¼ 0 and applying clock pulse to the ﬂip-ﬂop, the output Q does
not change, if Q ¼ 0 then stays 0, or if Q ¼ 1 then stays 1.
(b) By setting J ¼ 0, K ¼ 1 and applying clock pulse to the ﬂip-ﬂop, then output Q
changes to 0.
(c) By setting J ¼ 1, K ¼ 0 and applying clock to the ﬂip-ﬂop, the output Q changes
to 1.
(d) By setting J ¼ K ¼ 1 and applying a clock pulse, the output of the ﬂip-ﬂop is the
complement of present output; this means if Q ¼ 0 and applying clock, then
output changes to 1 and if Q ¼ 1 and applying clock pulse then the output will
change to 0.
Table 5.2 Characteristic
table of D ﬂip-ﬂop
Clock
D
Q
"
0
0
"
1
1
Fig. 5.6 Block diagram of
D ﬂip-ﬂop
Fig. 5.7 J-K ﬂip-ﬂop
Table 5.3 Characteristic
table of J-K ﬂip-ﬂop
Clock
J
K
Q
"
0
0
No change
"
0
1
0
"
1
0
1
"
1
1
Complement
100
5
Synchronous Sequential Logic

5.5
T Flip-Flop
T ﬂip-ﬂop is a special case of J-K ﬂip-ﬂop, and by connecting J and K inputs of J-K
ﬂip-ﬂop together results in a T ﬂip-ﬂop; Fig. 5.8 shows a block diagram of T ﬂip-
ﬂop, and Table 5.4 shows the characteristic table of T ﬂip-ﬂop; as shown in
Table 5.4 if T ¼ 0 and applying clock pulse, then the output of T ﬂip-ﬂop does
not change, and if T ¼ 1 and applying clock, then output of ﬂip-ﬂop becomes the
complement of the present output.
5.6
Register
D ﬂip-ﬂop is 1-bit memory or 1-bit register. If a group of D ﬂip-ﬂops share a
common clock, it is called register; the N-bit register is constructed with N D ﬂip-
ﬂops, and if 32 D ﬂip-ﬂops use a common clock, then it is called a 32-bit register.
Figure 5.9 shows a 4-bit register, and in this ﬁgure by placing 1101 at the inputs and
applying clock pulse, then the output will be 1101.
Shift Register
A shift register has one serial input, and one bit is loaded from serial input into the
register by every clock pulse, and then each bit of register is shifted to the next bit
position. Figure 5.10 shows 4-bit shift right register operation, and after shifting one
bit to the right, the contents of the register will be 0101. Figure 5.11 shows 4-bit
serial shift right register.
Example Figure 5.12 shows 4-bit shift right register; show the contents of register
after applying four clock pulses, and assume initial output of each D ﬂip-ﬂop is
zero.
Figure 5.13 shows shift left register with serial input of 1110100, and Table 5.5
shows contents of register after applying ﬁve clock pulses; assume the initial output
of each ﬂip-ﬂop is 0.
Fig. 5.8 Block diagram of T ﬂip-ﬂop
Table 5.4 Characteristic
table of T ﬂip-ﬂop
Clock
T
Q
"
0
No change
"
1
Complement
5.6
Register
101

Barrel Shifter
Barrel shifter is used for shifting data left and right; barrel shifter uses combina-
tional logic rather shift register; combinational logic does not require clock and it is
the fastest shifter; Fig. 5.14 shows 4-bit barrel shifter and Table 5.5 shows operation
table for barrel shifter.
5.7
Frequency Divider Using J-K Flip-Flop
Figure 5.15 shows a J-K ﬂip-ﬂop as frequency divider; the inputs J and K are set to
1 and assume the initial value of Q ¼ 0; as shown in this ﬁgure, for every two clock
pulses applied to the ﬂip-ﬂop, then Q generates one clock pulse as shown in
Fig. 5.15; this means the circuit divides the frequency by 2.
Fig. 5.10 4-bit shift right register operation
Fig. 5.9 4-bit register
Fig. 5.11 4-bit serial shift right register
102
5
Synchronous Sequential Logic

Fig. 5.12 4-bit shift right register
Fig. 5.13 4-bit shift left register
Table 5.5 Barrel shifter
operation
S1
S0
D3
D2
D1
D0
0
X
A3
A2
A1
A0
1
0
0
A3
A2
A1
1
1
A2
A1
A0
0
5.7
Frequency Divider Using J-K Flip-Flop
103

5.8
Analysis of Sequential Logic
In a combinational logic, the truth table represents the characteristic of a function,
but characteristic of sequential logic is represented by state table. State table is
represented by present state, next state, and output. The present state is the current
state of the ﬂip-ﬂop (current output), and the next state is the output of ﬂip-ﬂop after
applying clock to the sequential logic. Figure 5.16 shows a sequential circuit with
two J-K ﬂip-ﬂops with two states A and B; the state table consists of two columns
present state and next state; present state represents current outputs of the ﬂip-ﬂops
with all possible values for A and B (00, 01, 10, and 11) as shown in Table 5.6.
Consider the ﬁrst row; the present state is 00 (means A ¼ 0 and B ¼ 0); it is
interested to ﬁnd the outputs of ﬂip-ﬂops (next state) by applying clock pulse. If
Fig. 5.15 Frequency divider using J-K ﬂip-ﬂop
Fig. 5.14 4-bit barrel shifter
104
5
Synchronous Sequential Logic

A ¼ 0 and B ¼ 0 result in JA ¼ KA ¼ 0, JB ¼ KB ¼ 1, then applying clock pulse to
ﬂip-ﬂops results A ¼ 0 and B ¼ 1 (AB ¼ 01 next state).
Consider the second row, for present state A ¼ 0 and B ¼ 1; therefore,
JA ¼ KA ¼ 1, JB ¼ 0, and KB ¼ 1; applying a clock pulse to the ﬂip-ﬂops results
to next state with A ¼ 1 and B ¼ 0; the same procedure is used for row 10 and 11 to
ﬁnd the next states. Table 5.6 shows state table for sequential logic of Fig. 5.16.
Fig. 5.16 Sequential logic
Table 5.6 State table
for Fig. 5.16
Present state
Next state
A
B
A
B
0
0
0
1
0
1
1
0
1
0
1
1
1
1
0
0
5.8
Analysis of Sequential Logic
105

Example 5.1 Find the state table of Fig. 5.17.
Figure 5.17 contains external input X, and Table 5.7 shows stable with two
columns for next state: one for X ¼ 0 and another one for X ¼ 1.
5.9
State Diagram
Another way to represent the characteristic of sequential logic is by state diagram,
as shown in Fig. 5.18. The present state is the current value of ﬂip-ﬂop, and
applying clock the present state changes to next state.
D Flip-Flop State Diagram Figure 5.19 shows state diagram of D ﬂip-ﬂop, and
the following steps describe state diagram:
A
Clock
D
C
Q
DEV2
X
Fig. 5.17 Sequential
circuit
Table 5.7 State table for
Fig. 5.17
Present state
Next state for X ¼ 0
Next state for X ¼ 1
A
A
A
0
0
1
1
1
0
Fig. 5.18 State diagram
Fig. 5.19 State diagram for
D ﬂip-ﬂop
106
5
Synchronous Sequential Logic

1. If Q ¼ 0 (present state), by setting D ¼ 1 and applying clock, then Q changes
from 0 to 1 (next state).
2. If Q ¼ 1, by setting D ¼ 1 and applying clock, then output stays 1.
3. If Q ¼ 1, by setting D ¼ 0 and applying clock, then output changes to 0.
4. If Q ¼ 0, by setting D ¼ 0 and applying clock, then output stays 0.
Figure 5.20 shows state diagram of J-K and T ﬂip-ﬂops.
5.10
Flip-Flop Excitation Table
The application of excitation table is to determine input or inputs of a ﬂip-ﬂop in
order to get predeﬁned output.
D Flip-Flop Excitation Table
Table 5.8 shows excitation table for D ﬂip-ﬂop: Q(t) is present output (present state)
and Q(t + 1) is the next state.
Excitation Table Operation Consider the ﬁrst row of Table 5.8, if Q(t) ¼0 (pre-
sent state) and it is desired after applying a clock pulse, the output Q(t + 1) stays
0 and then D must be set to 0.
Consider the second row, the current output of D ﬂip-ﬂop (present state) is 0, and
it is desired to change the output Q (t + 1) to one; therefore, the input D must set to 1.
Fig. 5.20 J-K and T ﬂip-ﬂops state diagrams
Table 5.8 Excitation table
for D ﬂip-ﬂop
Q(t)
Q(t + 1)
D
0
0
0
0
1
1
1
0
0
1
1
1
5.10
Flip-Flop Excitation Table
107

Consider the third row, the present output is 1, and it is desired to change the
output (next state) to 0; therefore the input D must be set to 0.
Consider the fourth row, the present state is 1, and it is desired to stay 1;
therefore, D must set to one.
J-K Flip-Flop Excitation Table
Table 5.9 shows J-K ﬂip-ﬂop excitation table, and the following steps describe how
this table was generated:
1. Consider the ﬁrst row of excitation table, the present state of the ﬂip-ﬂop is zero,
and it desired to stay 0 by applying clock pulse; therefore, J must set to zero and
K is don’t care (0 or 1).
2. Consider the second row, the present state of the ﬂip-ﬂop is 0, and it is desired to
change the output to 1 by applying clock pulse; therefore, J must set to 1 and K
can don’t care.
3. Consider the third row, the present state Q(t) is 1, and it is desired to change it to
0; therefore, the J can don’t care and k ¼ 1.
4. Consider the fourth row, the present state is 1, and it is desired to stay 1;
therefore, J can don’t care and K ¼ 0.
T Flip-Flop Excitation Table. Table 5.10 shows excitation table of T ﬂip-ﬂop.
5.11
Counter
A counter is a sequential logic which is used to count the number of pulses applied
to it or divide a clock frequency if a system has a clock of 16 Hz, and it is possible to
use a counter to change 16 Hz clock to 4 Hz. The following steps describe how to
design a counter:
Table 5.9 J-K ﬂip-ﬂop
excitation table
Q(t)
Q(t + 1)
J
K
0
0
0
d
0
1
1
d
1
0
d
1
1
1
d
0
Table 5.10 T ﬂip-ﬂop
excitation table
Q(t)
Q(t + 1)
T
0
0
0
0
1
1
1
0
1
1
1
0
108
5
Synchronous Sequential Logic

(a) Deﬁne count sequence which is a sequence that the counter will count.
(b) Use count sequence to determine the number of ﬂip-ﬂops.
(c) Select the types of ﬂip-ﬂop.
(d) Use count sequence to develop state table.
(e) Use state table and ﬂip-ﬂop excitation table to develop excitation table for
counter.
(f) Use K-map to ﬁnd the input functions or function to each ﬂip-ﬂop.
(g) Draw the sequential logic for the counter.
Example: Design a counter to count 0—1—2—3 and repeat using J-K ﬂip-ﬂops.
The biggest number in count sequence is 3 which is represented in binary by 11;
therefore, two ﬂip-ﬂops are needed and it is called A and B as shown in Fig. 5.22,
and Table 5.11 shows state table for the counter.
The present state deﬁnes the current output of ﬂip-ﬂops, and the next state is the
output of ﬂip-ﬂops after applying a clock pulse.
Table 5.12 shows excitation table for the counter which was developed by using
excitation table of JK ﬂip-ﬂop.
Consider the ﬁrst row, the present output of J-K ﬂip-ﬂops is 00 (A ¼ 0, B ¼ 0),
and it is desired the outputs change to 01 (A ¼ 0 and B ¼ 1); therefore, it must set
JA ¼ 0, KA ¼ d (don’t care) in order for the A to stay 0 and set JB ¼ 1, KB ¼ d in
order for B to change from 0 to 1.
Consider the second row, the present state is 01 (A ¼ 0 and B ¼ 1), and it is
desired the output changes to 10 (A ¼ 1 and B ¼ 0); therefore, it must set JA ¼ 1,
KA ¼ d, and JB ¼ 0, KB ¼ d.
It is desired to ﬁnd the input functions to the ﬂip-ﬂops, the present state are the
inputs, and JA, KA, JB, and KB are the outputs of the Table 5.12, by transferring the
outputs to the K-maps, and reading the K-maps results the input functions to the
ﬂip-ﬂops; Fig. 5.21 shows K-maps for JA, KA, JB, and KB.
The input functions to the ﬂip-ﬂops are JA ¼ JB ¼ B, JB ¼ B0 and KB ¼ 1, and
Fig. 5.22 shows the circuit of 2-bit counter.
Table 5.11 State table of
counter
Present state
Next state
A
B
A
B
0
0
0
1
0
1
1
0
1
0
1
1
1
1
0
0
Table 5.12 Excitation table
for counter
Present state
Next state
A
B
A
B
JA
KA
JB
KB
0
0
0
1
0
d
1
d
0
1
1
0
1
d
d
1
1
0
1
1
d
0
1
d
1
1
0
0
d
1
d
1
5.11
Counter
109

5.12
Summary
•
Sequential logic circuit requires clock to operate.
•
A S-R latch is the basic component for ﬂip-ﬂop.
•
S-R latch can be constructed by the NAND or NOR gates.
•
The basic element of sequential logic is ﬂip-ﬂop.
•
Flip-ﬂop is a memory element with the two outputs Q and Q0.
•
By applying clock to the D ﬂip-ﬂop, the value of the D input copies at the Q
output.
•
D ﬂip-ﬂop use for designing register.
Fig. 5.21 K-maps for 2-bit counter
110
5
Synchronous Sequential Logic

•
Register is a group of the D ﬂip-ﬂop sharing the same clock.
•
J-K ﬂip-ﬂop is used for the designing counter.
•
Connecting inputs of a J-K ﬂip-ﬂop together results a T ﬂip-ﬂop.
•
State table and state diagram show operation of a sequential circuit.
•
Chapter 6 is an introduction to computer architecture which covers basic com-
ponents of a microcomputer as well as CPU technologies, CPU architectures,
multicore processor, instruction execution steps, pipelining, and microcomputer
buses.
Problems 1. Complete the following table for D ﬂip-ﬂop.
D
Q(t) present output
Q(t + 1) next output
0
0
0
1
1
0
1
1
Fig. 5.22 Sequential logic
of 2-bit counter
5.12
Summary
111

2. Complete the following table for J-K ﬂip-ﬂop.
J
K
Q(t) present output
Q(t + 1) next output
0
0
0
0
0
1
0
1
0
0
1
1
1
0
0
1
0
1
1
1
0
1
1
1
3. Complete the following table for T ﬂip-ﬂop.
T
Q(t) present output
Q(t + 1) next output
0
0
0
1
1
0
1
1
4. The following ﬁgure shows a sequential logic; complete the following table
assuming initial value of Q1 ¼ 0 and Q2 ¼ 0. Use logisim to verify your answer.
Clock
Q0
Q1
Initial value
0
0
Clock #1
Clock #2
Clock #3
5. Show an 8-bit register using D ﬂip-ﬂops.
6. The following shift register given, ﬁnd the output after ﬁve clock pulses.
112
5
Synchronous Sequential Logic

Q3
Q2
Q1
Q0
D3
D
Flip Flop
D2
D
Flip Flop
D1
D
Flip Flop
D0
D
Clock
11000111
Serial In
Flip Flop
7. With the following sequential logic given, assume initial value for Q0 ¼ 0 and
Q1 ¼ 0, and ﬂip-ﬂop changes state in rising edge of clock pulse; complete the
following table and then use logisim to verify your result.
Clock
Q0
Q1
Initial value
0
0
Clock #1
Clock #2
Clock #4
Clock #4
8. Complete the following excitation table for J-K ﬂip-ﬂop.
Q(t)
Q(t + 1)
J
K
0
0
0
1
1
0
1
1
9. Design a counter to count 0—1—2—3—4—5—6—7 and repeat.
(a) Use J-K ﬂip-ﬂops.
(b) Use T ﬂip-ﬂops.
(c) Verify your design using logisim.
5.12
Summary
113

10. Find the state diagram for the following state table.
AB
AB
AB
X ¼ 0
X ¼ 1
00
01
10
01
10
00
10
11
01
11
00
10
11. What is the content of the following register after shifting ﬁve times to the left?
12. Show state table and state diagram for following circuit.
X
A
B′
Clock
KB
JB
KB
JA
B
B
A
A
114
5
Synchronous Sequential Logic

Chapter 6
Introduction to Computer Architecture
Objectives: After completing this chapter, you should be able to:
•
List the components of a microcomputer.
•
List the components of CPU.
•
Distinguish CPU technologies.
•
Learn architecture of multicore processor.
•
Compare the RISC processor with the CISC processor.
•
Explain the difference between the von Neumann and the Harvard architecture.
•
Distinguish between the 32-bit processor and the 64-bit processor.
•
Explain the instruction execution steps.
•
Show advantage of the instruction pipelining.
•
Distinguish different types of the microcomputer buses.
•
Explain operation of the USB bus.
6.1
Introduction
Just as the architecture of a building deﬁnes its overall design and functions, so
computer architecture deﬁnes the design and functionality of a computer system.
The components of a microcomputer are designed to interact with one another, and
this interaction plays an important role in the overall system operation.
6.2
Components of a Microcomputer
A standard microcomputer consists of a microprocessor (CPU), buses, memory,
parallel input/output, serial input/output, programmable I/O interrupt, and direct
memory access DMA. Figure 6.1 shows components of microcomputer.
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_6
115

6.2.1
Central Processing Unit (CPU)
The central processing unit (CPU) is the “brain” of the computer and is responsible
for accepting data from input devices, processing the data into information, and
transferring the information to memory and output devices. The CPU is organized
into the following three major sections:
1. Arithmetic logic unit (ALU)
2. Control unit
3. Registers
The function of the arithmetic logic unit (ALU) is to perform arithmetic opera-
tions such as addition, subtraction, division, and multiplication and logic operations
such as AND, OR, and NOT.
The function of the control unit is to control input/output devices, generate
control signals to the other components of the computer such as read and write
signals, and perform instruction execution. Information is moved from memory to
the registers; the registers then pass the information to the ALU for logic and
arithmetic operations.
Register Register is the fastest memory in a computer which holds information.
6.2.2
CPU Buses
When more than one wire carries the same type of information, it is called a bus.
The most common buses inside a microcomputer are the address bus, the data bus,
and the control bus.
Programmable 
Interrupt
Direct memory Access
DMA
Memory
Parallel Input/Output 
Interface 
Serial Input/Output 
Interface
Arithmetic 
Logic Unit
Registers
Control Unit
CPU
Data Bus
Address BUS
Control Bus
Fig. 6.1 Components of a microcomputer
116
6
Introduction to Computer Architecture

Address Bus The address bus deﬁnes the number of addressable locations in a
memory IC by using the 2n formula, where n represents the number of address lines.
If the address bus is made up of three lines, then there are 23 ¼ 8 addressable
memory locations, as shown in Fig. 6.2. The size of the address bus directly
determines the maximum numbers of memory locations that can be accessed by
the CPU. For example, a CPU with 32 address bus can have 232 addressable
memory locations.
Data Bus The data bus is used to carry data to and from the memory. In Fig. 6.2,
each location can hold only four bits. The size of a memory IC is represented by
2n  m where n is the number of address lines and m is the size of each location. In
Fig. 6.2, where n ¼ 3 and m ¼ 4, the size of the memory is
23∗4 ¼ 32 bits:
The size of data bus plays important factor on CPU performance, current CPU’s
data bus is 32 bits or 64 bits, and a CPU with 32-bit data bus means it can read or
write 32 bits of data in and from memory.
Early generation of CPU contains 8-bit data bus, and each memory location
holds one byte, for reading word “book” as shown in Fig. 6.3. The CPU requires to
access memory four times.
000
001
010
011
100
101
110
111
Address Bus
Data Bus
Read/Write
Fig. 6.2 A memory with
three address lines and four
data lines
Fig. 6.3 CPU with 8 bit
Data Bus
6.2
Components of a Microcomputer
117

By increasing data bus from 8 bits to 32 bits, then CPU can access memory and
read entire word “book.” Most CPUs offer instruction to read 1 byte, 2 bytes, or
4 bytes from memory.
Control Bus The control bus carries control signals from the control unit to the
computer components in order to control the operation of each component. In
addition, the control unit receives control signals from computer components.
Some of the control signals are as follows:
Read signal:
The read line is set to high to read from memory location or
input/output (I/O) devices.
Write signal:
The write line is used to write data into the memory.
Interrupt:
Indicates an interrupt request.
Bus request:
The device is requesting to use the computer bus.
Bus Grant:
Gives
permission
to
the
requesting
device
to
use
the
computer bus.
I/O
Read
and
Write:
I/O read and write are used to read from or write to I/O devices.
6.2.3
32-Bit Versus 64-Bit CPU
The size of register plays an important role in the performance of CPU. A 32-bit
processor means it can perform operations on 32-bit data; therefore, the size of
registers is 32 bits and ALU also performs 32-bit operations. A 64-bit CPU
performs operation in 64-bit data; therefore, it contains 64-bit register and
64-bit ALU.
Most desktop and server computers are using AMD and Intel processors; they
might use 32 bits or 64 bits. Intel and AMD processor use the same architecture; this
means a program in computer with Intel processor can run on a computer with
AMD processor.
6.3
CPU Technology
There are two types of technology used for designing CPU and they are called CISC
and RIS.
CISC (Complex Instruction Set Computer) In 1978, Intel developed the 8086
microprocessor chip. The 8086 was designed to process a 16-bit data word; it had
no instruction for ﬂoating point operations. At the present time, the Pentium
processes 32-bit and 64-bit words, and it can process ﬂoating point instructions.
118
6
Introduction to Computer Architecture

Intel designed the Pentium processor in such a way that it can execute programs
written for earlier 80  86 processors.
The characteristics of 80  86 are called complex instruction set computers
(CISC), which include instructions for earlier Intel processors. Another CISC
processor is VAX 11/780, which can execute programs for the PDP-11 computer.
The CISC processor contains many instructions with different addressing modes,
for example, the VAX 11/780 has more than 300 instructions with 16 different
address modes.
The major characteristics of CISC processor are as follows:
1. A large number of instructions.
2. Many addressing modes.
3. Variable length of instructions.
4. Most instruction can manipulate operands in the memory.
5. Control unit is microprogrammed.
RISC Until the mid-1990s, computer manufacturers were designing complex
CPUs with large sets of instructions. At that time, a number of computer manufac-
turers decided to design CPUs capable of executing only a very limited set of
instructions.
One advantage of reduced-instruction set computer is that they can execute their
instructions very fast because the instructions are simple. In addition, the RISC chip
requires fewer transistors than the CISC chip. Some of the RISC processors are the
PowerPC, MIPS processor, IBM RISC System/6000, ARM, and SPARC.
The major characteristics of RISC processors are as follows:
1. Require few instructions.
2. All instructions are the same length (they can be easily decoded).
3. Most instructions are executed in one machine clock cycle.
4. Control unit is hardwired.
5. Few address modes.
6. A large number of registers.
RISC processor uses hardware and CISC processor microprogram for control
unit, and the control unit with hardware uses less space in a CPU; therefore, the
designer of CPU can add more registers to RISC processor compared with CISC.
The advantage of CISC processor is that designer can add new instruction
without changing the architecture of the processor. Table 6.1 shows the comparison
of CISC and RISC.
Table 6.1 Comparison of
RISC and CISC processor
CISC
RISC
Variable instruction length
Fixed instruction length
Variable opcode length
Fixed opcode length
Memory operands
Load/store instructions
Example: Pentium
ARM, MIPS
6.3
CPU Technology
119

6.4
CPU Architecture
There are two types of CPU architecture and they are von Neumann and Harvard
architecture.
Von Neumann Architecture It is a program consists of code (instructions) and
data. Figure 6.4 shows a block diagram of the von Neumann architecture. Von
Neumann uses the data bus to transfer data and instructions from the memory to the
CPU.
Harvard Architecture Harvard architecture uses separate buses for instructions
and data as shown in Fig. 6.5. The instruction address bus and instruction bus are
used for reading instructions from memory. The address bus and data bus are used
for writing and reading data to and from memory.
6.5
Intel Microprocessor Family
Intel designs and manufactures microprocessors for microcomputers. Each proces-
sor has a number or name, which is used by the computer designer to access the
information provided by the manufacturer of the processor.
Fig. 6.4 Von Neumann
architecture
Fig. 6.5 Harvard
architecture
120
6
Introduction to Computer Architecture

Intel microprocessor IC numbers and names are 8088, 80,286, 80,386, 80,486,
Pentium, Pentium II, Pentium III, and Pentium IV which they called IA-86 (Intel
architecture-86). Recently Intel and HP developed a new processor called Itanium
which is a 64-bit processor, which is described later in this chapter. The following is
a list of the characteristics of a microprocessor:
1. Register size: Registers are used to store information inside the processor.
Register sizes can vary from 8- to 16- to 32- to 64-bit.
2. Number of registers: A processor with several registers can store more infor-
mation in the CPU for processing.
3. Data bus size: The size of the data bus determines how many bits of data can be
transferred in parallel to or from memory or input/output ports.
4. Address bus size: The typical address sizes are 16, 32, and 64 bits. The size of
the address bus determines the number of memory locations that may be
accessed by the microprocessor.
5. Clock speed: The speed of the clock determines the speed at which the
processor executes instructions.
6. Math coprocessor: The math coprocessor is a special processor that performs
complex mathematical operations.
7. Real mode: Real mode allows for software compatibility with older software. It
enables the processor to emulate the lowest Intel 8088 processor and use only
the ﬁrst 1 MB of memory.
8. Protected mode: Protected mode is a type of memory usage that is available on
80,286 and later model microprocessors. In protected mode, each program can
be allocated a certain section of memory and other programs cannot use this
memory. Protected mode also enables a single program to access more than
1 MB of memory.
9. Cache size: Cache memory is a small amount of high-speed memory used for
temporary data storage based between the processor and main memory. The
size of cache can help to speed up the execution time of a program.
10. MMX technology: Intel’s MMX technology is designed to speed up multimedia
and communication applications, such as video, animation, and 3D graphics.
The technology includes single instruction multiple data (SIMD) technique
(meaning that with one instruction, the computer can perform multiple opera-
tions), 57 new instructions, eight 64-bit MMX register, and four new data types.
Table 6.2 Provide a quick reference to the preceding list of characteristics
Most workstations or laptops use CPU which is manufactured by Intel and AMD
Corporations. Intel processor is classiﬁed by the IA-16 (Intel architecture 16-bit
processor), IA-32, and IA-64.
Upward Compatibility Intel architecture is upward compatible meaning a pro-
gram written for IA-16 processor can run on IA-32.
Figure 6.6 shows general register IA-16, where AH, AL, BH, BL, CH, CL, DH,
and DL are 8-bit registers and AX, BX, CX, and DX are 16-bit register. The AX,
BX, CX, and DX are combinations of two registers.
6.5
Intel Microprocessor Family
121

Figure 6.7 shows IA-32 general registers where EAX, EBX, ECX, and EDX are
3-bit general registers, and also Figure 6.6 also contains IA-16-bit registers; there-
fore, a program was written for IA-16 can be executed by IA-32.
6.6
Multicore Processors
A multicore processor is an integrated circuit (IC) with two or more independent
CPU which is called core, and they are executing multiple instructions simulta-
neously in order to increase performance. A quad-core processor is a chip with four
independent units called cores that read and execute instructions such as add, move
data, and branch. Figure 6.8 shows a block diagram of quad-core processors which
are all sharing a memory. The following are some of the multicore processors:
Two cores (dual-core CPUs) such as AMD Phenom II X2 and Intel Core Duo
Table 6.2 Characteristics of Intel microprocessor
80486dx
Pentium
Pentium Pro
Pentium Pro II
Pentium II
Register size
32 bits
32 bits
32 bits
32/64 bits
32/64 bits
Data bus size
32 bits
64 bits
64 bits
64 bits
64 bits
Address size
32 bits
32 bits
32 bits
32 bits
32 bits
Max memory
4 GB
4 GB
4 GB
4 GB
4 GB
Clock speed
25,
33 MHz
60, 166 MHz
150, 200 MHz
233,
340, 400 MHz
450,
500 MHz
Math
processor
Built-in
Built-in
Built-in
Built-in
Built-in
L1 cache
8 KB,
16 KB
8 KB
instruction
8 KB data
8 KB instruc-
tion
8 KB data
16 KB instruc-
tion
16 KB data
16 KB
instruction
16 KB data
L2 cache
No
No
256 KB or
512 KB
512 KB
512 KB
MMX
technology
No
No
Yes
Yes
Yes
L1 cache is the cache memory built inside the microprocessor
L2 cache is not part of microprocessor; it is in a separate IC
Fig. 6.6 IA-16 registers
122
6
Introduction to Computer Architecture

Three cores (tri-core CPUs) such as AMD Phenom II X3
Four cores (quad-core CPUs) such as AMD Phenom II X4, Intel’s i5 and i7
processors
Six cores (hexa-core CPUs) such as AMD Phenom II X6 and Intel Core i7 Extreme
Edition 980X
Eight cores (octa-core CPUs) such as Intel Core i7 5960X Extreme Edition and
AMD FX-8350
Ten cores (deca-core CPUs) such as Intel Xeon E7-2850
6.7
CPU Instruction Execution
In general, CPU performs the following steps to execute one instruction:
1. Fetch instruction (F): Moving Instruction from memory to CPU.
2. Decode instruction (D): Determine types of instruction such as ADD, AND, OR,
and Store operands into registers if needed.
Fig. 6.7 Intel IA-32-bit registers
Fig. 6.8 Multicore processor architecture
6.7
CPU Instruction Execution
123

3. Execute instruction (E): Execute the instruction such as addition.
4. Write results (R): Store the result of execution into register or memory.
Pipelining. Pipelining will increase the performance of CPU meaning executing
more instructions in less time.
Figure 6.9 shows execution of four instructions without pipelining; in this ﬁgure,
CPU executes one instruction at a time, and each stage takes T second; then total
execution time is 16 T.
Figure 6.10 shows execution of four instructions using pipeline; CPU fetches I1
instruction and moves it to decode unit; CPU while decoding I1 will fetch I2
instruction and this process will continue.
As shown in Fig. 6.10, it takes 7 T to complete the execution of four instructions.
Figure 5.11 shows that at time T4 CPU writes the results of execution I1 into
memory and at the same time fetches instruction I4 from memory, but it is
impossible to read and write at the same time into or from memory; therefore,
having two separate caches (instruction cache and data cache) will overcome this
conﬂict, and this type of architecture is called Harvard architecture.
Direct memory access: Direct memory access (DMA) allows for the transfer of
blocks of data from memory to an I/O device or vice versa. Without DMA, the CPU
reads data from memory and writes it to an I/O device. Transferring blocks of data
from memory to an I/O device requires the CPU to do one read and one write for
each operation. This method of data transfer takes a lot of time. The function of
DMA is to transfer data from memory to an I/O device directly, without using the
CPU, so that the CPU is free to perform other functions.
The DMA performs the following functions in order to use of the computer bus:
•
The DMA sends a request signal to the CPU.
•
The CPU responds to the DMA with a grant request, permitting the DMA to use
the bus.
Fig. 6.9 Execution of instruction without pipeline
Fig. 6.10 Execution of instruction using pipeline
124
6
Introduction to Computer Architecture

•
The DMA controls the bus and the I/O device is able to read or write directly to
or from memory.
•
The DMA is able to load a ﬁle off an external disk into main memory when large
blocks of data need to be transferred to a sequential range of memory. DMA is
much faster and more efﬁcient than a CPU.
Programmable I/O Interrupt When multiple I/O devices such as external drives,
hard disks, printers, monitors, and modems are connected to a computer as shown in
Fig. 6.11; a mechanism is necessary to synchronize all device requests. The
function of a programmable interrupt is to check the status of each device and
inform the CPU of the status of each; for example, the printer is not ready, a disk is
write protected, this is an unformatted disk, and there is a missing connection to a
modem. Each device sends a signal to the programmable I/O interrupt controller in
order to update its status. Figure 6.11 shows the programmable I/O interrupt
controller.
6.8
Disk Controller
The disk controller moves the disk drive head, reads, and/or writes data. Today,
there are two types of disk controllers: IDE (integrated disk electronics) and SCSI
(small computer systems interface).
Integrated Disk Electronics (IDE). An IDE disk drive is connected to the ISA
bus with a ﬂat ribbon cable. The IDE disk controller supports two hard disks, each
with a 528-megabyte capacity. In 1994, hard disk drive vendors introduced EIDE
(extended IDE) which supports four devices, such as hard disks, tape drives,
CD-ROM devices, and larger hard disk drives. The EIDE has two connectors.
Each cable is connected to the EIDE controller and can support two hard disk
drives with a capacity of up to 250 GB. EIDE is used in IBM-compatible
computers.
Small Computer System Interface (SCSI) The small computer system interface
(SCSI) standard is deﬁned by the American National Standards Institute (ANSI) for
Programmable
Interrupt
Controller
Disk
Data Bus
Printer
Mouse
Keyboard
CPU
Address bus
Control Bus
Fig. 6.11 Programmable interrupt controller
6.8
Disk Controller
125

connecting daisy chaining multiple I/O devices, such as scanners, hard disks, and
CD-ROMs, to the microcomputer, as shown in Fig. 6.12.
SCSI is a standard interface for all types of microcomputers. It is used in
Macintosh, RISC workstations, and minicomputers, as well as in higher-end
IBM-compatible computers. The SCSI bus comes with different types of control-
lers. Table 6.3 shows the characteristics of several types of SCSI controllers, and
Fig. 6.13 shows SCSI-1, SCSI-2, and SCSI-3 connectors.
SATA (Serial Advanced Technology Attachment) SATA is a serial bus for
connecting mess storage such as hard disk, optical drive, and solid-state drive to
computer.
6.9
Microcomputer Bus
There are currently a number of different computer buses on the market that are
designed for microcomputers. Some of the computer BUS are ISA, MCA, EISA,
VESA PCI, FireWire, USB, and PCI Express. Universal serial bus (USB) and PC
Express are covered in more detail because they are more advanced than other
buses.
Hard Drive
Floppy
Scanner
CD-ROM
Fig. 6.12 SCSI bus
Table 6.3 Characteristics
of several types of SCSI
controllers
Bandwidth
Data rate MB/s
SCSI-1
8 bits
5
SCSI-2
16 bits
10–20
Ultra SCSI
8 bits
20
SCSI-3
16 bits
40
MB/s millions bytes per second
Fig. 6.13 SCSI-1, SCSI-2, and SCSI-3 connectors
126
6
Introduction to Computer Architecture

6.9.1
ISA Bus
The industry standard architecture (ISA) bus was introduced by IBM for the IBM
PC using an 8088 microprocessor. The ISA bus has an 8-bit data bus and 20 address
lines at a clock speed of 8 MHz. The PC AT type uses the 80,286 processor which
has a 16-bit data bus and 24-bit address lines and is compatible with the PC.
6.9.2
Microchannel Architecture Bus
The microchannel architecture (MCA) bus was introduced by IBM in 1987 for its
PS/2 microcomputer. The MCA bus is a 32-bit bus that can transfer four bytes of
data at a time and runs at a 10 MHz clock speed. It also supports 16-bit data transfer
and has 32-bit address lines. Microchannel architecture was so expensive the
non-IBM vendors developed a comparable but less expensive solution called the
EISA bus.
6.9.3
EISA Bus
The extended ISA (EISA) bus is a 32-bit bus that also supports 8- and 16-bit data
transfer bus architectures. EISA runs at 8-MHz clock speeds and has 32-bit address
lines.
6.9.4
VESA Bus
The video electronics standard association (VESA) bus, which is also called a video
local bus (VL-BUS), is a standard interface between the computer and its expan-
sion. As applications became more graphically intensive, the VESA bus was
introduced to maximize throughput of video graphics memory. The VESA bus
provides fast data ﬂow between stations and can transfer up to 132 Mbps.
6.9.5
PCI Bus
The peripheral component interconnect (PCI) bus was developed by Intel Corpo-
ration. PCI bus technology includes a 32-/64-bit bus that runs at a 33/66 MHz clock
speed. PCI offers many advantages for connections to hubs, routers, and network
6.9
Microcomputer Bus
127

interface cards (NIC). In particular, PCI provides more bandwidth: up to 1 gigabit
per second as needed by these hardware components.
The PCI bus was designed to improve the bandwidth and decrease latency in
computer systems. Current versions of the PCI bus support data rates of 1056 Mbps
and can be upgraded to 4224 Mbps. The PCI bus can support up to 16 slots or
devices in the motherboard. Most suppliers of ATM (asynchronous transfer mode)
and 100BaseT NICs offer a PCI interface for their products. The PCI bus can be
expanded to support a 64-bit data bus. Table 6.4 compares different bus architec-
tures showing characteristics of ISA, EISA, MCA, VESA, and PCI buses.
Figure 6.14 shows the PCI bus.
6.9.6
Universal Serial BUS (USB)
The universal serial bus (USB) is a computer serial bus which enables users to
connect peripherals such as the mouse, keyboard, modem, CD-ROM, scanner, and
printer, to the outside of a computer without any conﬁguration. Personal computers
equipped with USB will allow the user to connect peripherals to the computer, and
the computer will automatically be conﬁgured as the devices are attached to it. This
means that a USB has the capability to detect when a device has been added or
removed from a PC. USB is a true plug-and-play bus. Up to 127 peripherals can be
connected to a PC with a USB. USB version 1.1 was released in 1998 which
supports data rate of 12 Mbps (full speed) and 1.5 Mbps (low speed); the low
Table 6.4 Characteristics of various buses
Bus type
ISA
EISA
MCA
VESA
PCI
PCI-64
Speed (MHz)
8
8.3
10
33
33
64
Data bus bandwidth (bits)
16
32
32
32
32
66
Max. data rate (MB/s)a
8
32
40
132
132
508
Plug and play capable
No
No
Yes
Yes
Yes
Yes
aMB/s megabytes/second
Fig. 6.14 PCI card
128
6
Introduction to Computer Architecture

speed is used for devices such mouse, keyboards, and joysticks. The USB version
2 is a high speed (480 Mbps) that is compatible with USB 1.1 The USB 2.0
speciﬁcation was developed by seven leading computer manufacturers and it was
announced in 1999. The maximum cable length for USB is 5 meters.
6.9.7
USB Architecture
Figure 6.15 shows the USB architecture; the USB system is logically a tree
topology but physical is a star topology because each USB device communicates
directly with the Root Hub. There is only one host Controller in any USB system.
A USB system consists of USB host controller, USB root hub, USB hub, USB
cable, USB device, client software, and host controller software.
Host Controller The host controller initiates all data transfer, and root hub pro-
vides a connection between devices and host controller. The root hub receives
transaction generated by host controller and transmits to the USB devices. The host
controller uses polling to detect a new device and is connected to the bus or
disconnected from. Also, USB host controller performs the following functions:
(a) Host controller sets up the device for operation (device conﬁguration).
(b) Packet generation.
(c) Serializer/deserializer.
(d) Process request from device and host.
(e) Manage USB protocol.
Host Computer
USB  HUB
USB 
device
USB
Device
USB
Device
USB
Device
CPU
Memory
Computer BUS
Host Controller
Root Hub
Serial Port
V Bus
D+
D-
GND
USB
Serial
Port
Fig. 6.15 Architecture of USB
6.9
Microcomputer Bus
129

(f) Managing ﬂow between host and USB devices.
(g) Assign address to the devices.
(h) Execute client software.
(i) Collecting status bit from USB ports.
Root Hub The root hub performs power distribution to the devices, enables and
disables the ports, and reports status of each port to the host controller. The root hub
provides the connection between the host controller and USB ports.
Hub Hubs are used to expand the number of devices connected to the USB system.
Hubs are able to detect when a device is attached or removed from port. Figure 6.16
shows the architecture of hub. The upstream port is connected to the host, and USB
devices are connected to downstream port.
In downstream transmission, all devices that are connected to the hub will
receive the packet, but only the device accepts the packet that the device address
matches with address in the token. In upstream transmission, the device sends the
packet to the hub, and hub transmits the packet to its upstream port only. USB
improves its speed and every few years a new version was developed. Table 6.5
shows different versions of USB.
USB Cable. Figure 6.15 shows USB port with four pins, which consists of four
wires, with the V bus used to power the devices. Dþ and D are used for signal
transmission.
USB Device USB device is divided into the classes such as hub, printer, or mass
storage. The USB device has information about its conﬁguration such as class, type,
manufacture ID, and data rate. Host controller uses this information to load device
software from the hard disk. USB device might have multiple functions such as a
volume in a speaker. Each function in a USB device is speciﬁed by the endpoint
address.
Upstream Port
Down stream ports
Hub controller
Hub repeater
Transaction
Fig. 6.16 Architecture of
hub
Table 6.5 USB version and its data rate
USB version
Release data
Data rate
Data rate designation
USB 1.0
1996
1.5 Mbps
Low speed
USB 1.1
1998
12 Mbps
Full speed
USB 2.0
2000
480 Mbps
High speed
USB 3.0
2008
5 Gbps
Super speed
USB 3.1
2013
10 Gbps
Super speed þ
130
6
Introduction to Computer Architecture

6.9.8
PCI Express Bus
PCI express was introduced in mid-1990 with 33 MHz frequency, and during the
time the speed of BUS was increased to 66 MHz. Due to new development in
networking technology such as Gigabit Ethernet and I/O devices that demand more
bandwidth, there is a need for a new bus technology with higher bandwidth. The
PCI express was approved by Special Interest Group in 2002, and chipset starts
shipping in 2004. The PCI express has the following features:
•
PCI express is point-to-point connection between devices.
•
PCI express is a serial bus.
•
PCI express uses pocket and layer architecture.
•
Compatible with PCI bus through software.
•
End-to-end link data integrity (error detection).
•
Isochronous data transfer.
•
Selectable bandwidth.
6.9.9
PCI Express Architecture
Figure 6.17 shows PCI express architecture, and the function of host bridge is to
interface CPU bus with memory and PCI express switch. The switch is used to
increase the number of PCI’s express ports.
CPU
Host Bridge
Memory
PCI express
PCI-Express
Switch
PCI-Express
Device
PCI-Express
Device
PCI-Express
Device
Fig. 6.17 PCI express
architecture
6.9
Microcomputer Bus
131

6.9.10
PCI Express Protocol Architecture
Figure 6.18 shows PCI express protocol architecture. The protocol consists of PCI
software, transaction, data link, and physical layer.
Software Layer The software layer is used for compatibility with PCI, initializa-
tion, and enumeration of the devices connected to the PCI express.
PCI Express Physical Layer Figure 6.19 shows two devices are connected
through PCI express link (lane); each lane is made of four wires, and each PCI
express lane consists of two simplex connections, one for transmitting the packet
and another one for receiving the packet. The PCI express lane supports 2.5 giga
transfer/second each direction.
PCI express link may conﬁgure X1, X2, X4, X4, X16, and X32 lane, where X1
means 1 lane with 4 wires and X4 means 4 lanes with 16 wires and ﬁnally X32
means 32 lanes with 128 wires. PCI-32 means PCI express with 32 lanes. The clock
for PCI express serial link is embedded into the data by using 8B/10B encoding.
6.10
FireWire
FireWire or IEEE 1394 is a high-speed serial bus used for connecting digital
devices such as a digital video or camcorder. The bus is able to transfer data at
the rate of 100, 200, or 400 Mpbs. The IEEE 1394 cable consists of six copper
wires; two of the wires carry power and four of the wires carry signal as illustrated
in Table 6.6. Some FireWire connectors come with four pins, without having power
pins. Figure 6.20 shows FireWire male and female connectors.
Software
Transaction
Data Link
Physical Layer
Fig. 6.18 PCI express
protocol architecture
Device A
Device B
Packet
Fig. 6.19 PCI express
connections
132
6
Introduction to Computer Architecture

6.10.1
HDMI (High-Deﬁnition Multimedia Interface)
HDMI is an interface between two devices for transferring uncompressed video
data and compressed or uncompressed digital audio data. Some of the applications
of HDMI are computer monitor, digital TV, and video projector. Figure 6.21 shows
different types of HDMI connectors.
Motherboard The motherboard is a printed circuit board (PCB) that contains
most components of a computer such as CPU, RAM, ROM, expansion slots, and
USB. Figure 6.22 shows an image of motherboard.
6.11
Summary
•
The components of a microcomputer are the CPU, memory, parallel I/O, serial
I/O, programmable interrupt, and DMA.
•
The function of the CPU is executing instruction.
•
The components of the CPU are the arithmetic logic unit (ALU), control unit,
and registers.
•
Most computers use three types of memory: cache memory (SRAM), main
memory (DRAM or SDRAM), and secondary memory (hard disk, tape drive,
and ﬂoppy disk).
•
Semiconductor memory types are DRAM, SDRAM, EDORAM, DDR,
SDRAM, RDRAM, ROM, and EPROM.
•
SRAM is used in the cache memory; DRAM and SDRAM are used in the main
memory.
•
SATA, SCSI-1, SCSI-2, and SCSI-3 are the computer peripheral controllers.
Table 6.6 IEEE 1394 pins
Pin
Signal name
Description
1
Power
Unregulated DC; 17–24 V no load
2
Ground
Ground return for power and inner cable shield
3
TPB
Twisted-pair B, differential signals
4
TPBþ
Twisted-pair B, differential signals
5
TPA
Twisted-pair A, differential signals
6
TPAþ
Twisted-pair A, differential signals
Female
Male
12 mm
Fig. 6.20 FireWire male
and female connectors
6.11
Summary
133

•
ISA bus, EISA, MCA, and PCI are the microcomputer buses, and FireWire is a
high-speed serial bus with a data rate up to 400 Mbps.
•
USB is a serial bus.
•
PCI express is a serial bus.
•
Chapter 7 covers semiconductor memory, hard disk, solid-state drive, cache
memory mapping methods, and virtual memory.
Fig. 6.21 HDMI connectors
Expansion Slots
CNR
Riser
SiS Southbridge
Chipset
CMOS
Battery
USB 2.0
Riser
Front
Pannel
Connector
ATX Power
Connector
Bios
DDR SODIMM
Memory Slots
ASRock
Northbridge
Chipset
SERIAL ATA
HDD Connectors
FDD Header
ATA 133 HDD
CD Headers
CPU Zif
Socket
Fan
Connector
Secondary
Power
Connector
(Processor)
8x AGP Connector
CD Audio Connector
Back Pane Connectors
Fig. 6.22 Image of motherboard
134
6
Introduction to Computer Architecture

Review Questions
•
Multiple choice questions
1. The function of the _________ is to perform arithmetic operations.
(a) Bus
(b) Serial port
(c) ALU
(d) Control unit
2. When you compare the functions of a CPU and a microprocessor, __________.
(a) They are the same
(b) They are not the same
(c) The CPU is faster than microprocessor
(d) The microprocessor is faster than CPU
3. RISC processors use ___________.
(a) Complex instruction sets
(b) Reduced instruction sets
(c) a and b
(d) None of the above
4. The CISC processor control unit is ____________.
(a) Hardware
(b) Microcode
(c) a and b
(d) None of the above
5. Direct memory access allows for the transfer of blocks of data from memory to
an I/O device (or vice versa) without using the _______.
(a) CPU
(b) Data bus
(c) Control bus
(d) DMA controller
6. Which of the following buses are 32-bit?
(a) ISA
(b) PCI and EISA
(c) EISA and ISA
(d) MCA and ISA
7. Which of the following operating systems support plug and play?
(a) Window NT and Window 95
(b) Window 98 and Window NT
(c) Window XP and Window 2000
(d) DOS and Windows NT
6.11
Summary
135

1. List the components of a microcomputer.
2. Explain the functions of a CPU.
3. List the functions of an ALU.
4. What is the function of a control unit?
5. List components of a CPU?
6. How many bits a half word?
7. How many bits is a word?
8. Distinguish between a CPU and a microprocessor.
9. Explain the function of an address bus and a data bus.
10. Explain the function of DMA.
11. What is the application of a parallel port?
12. What is the application of a serial port?
13. What is an interrupt?
14. What is maximum memory for a CPU with 16 address lines and 8 data lines?
15. List characteristics of CISC processor.
16. List characteristics of RISC processor.
17. Distinguish between von Neumann architecture and Harvard architecture.
18. What is the advantage of multicore processor versus single core?
19. List CPU instruction execution steps.
20. Explain fetch instruction
21. How long does it take for a CPU to execute ﬁve instructions using pipelining if
each stage of pipeline takes 20 min.
22. Calculate execution time for problem 21 using non-pipeline processor.
23. What are characteristics of 64-bit processor?
24. List types of disk controller.
25. List computer buses.
26. List two serial buses.
27. What is maximum number USB ports a computer can have?
28. Show pin connection of USB port.
29. Show diagram of PCIe lane.
30. What is the application of FireWire?
31. What is application of HDMI?
136
6
Introduction to Computer Architecture

Chapter 7
Memory
Objectives: After completing this chapter, you should be able to:
•
Distinguish different types of semiconductor memory.
•
Explain sector, track on hard disk.
•
To calculate disk capacity.
•
Learn memory hierarchy.
•
Explain cache miss, cache hit, and cache hit ratio.
•
Describe types of memory use in a computer.
•
Explain different mapping methods use in cache memory.
•
Translate virtual address to physical address.
•
Explain function of page table.
•
Generate physical address from virtual address.
7.1
Introduction
In a computer, memory holds instructions (code) and data, memory plays an
important part of a computer performance, and register is a type of memory with
small capacity. There are two types of memory used in a computer, and they are
classiﬁed as semiconductor memory and hard disk. Semiconductor memory can be
volatile or nonvolatile memory. Volatile memory loses its contents when power is
removed from it, while nonvolatile memory will keep its contents without power.
7.2
Semiconductor Memory
There are two types of semiconductor memory: random-access memory (RAM) and
read-only memory (ROM).
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_7
137

RAM Data can be read from or written into random-access memory (RAM). The
RAM can hold the data as long as power is supplied to it and it is called volatile
memory. Figure 7.1 shows a general block diagram of RAM consisting of a data
bus, address bus, and read/write signals. The data bus carries data out from or into
the RAM. The address bus is used to select a memory location. The read signal
becomes active when reading data from RAM, and the write line becomes active
when writing to the RAM. Remember, RAM can only hold information when it has
power. Figure 7.2 shows a 16 * 8 bit RAM or 24 * 8 bit or 16 B RAM.
RAM
Data Bus
Address Bus
Read
Write
Chip Select
Fig. 7.1 RAM block diagram
Fig. 7.2 16 bytes of RAM
138
7
Memory

In Fig. 7.2, the address is 4 bits; therefore, there are 24 ¼ 16 memory locations,
and if each location holds 1 B, then there is 16 B of memory, a memory with m
address lines, then there is 2m memory locations. Table 7.1 shows the number of
address lines and equivalent decimal number of memory locations.
There are many types of RAM, such as dynamic RAM (DRAM), synchronous
DRAM (SDRAM), EDO RAM, DDR SDRAM, RDRAM, and static RAM (SRAM).
•
Dynamic RAM (DRAM) is used in main memory. DRAM uses fewer compo-
nents to make one bit; therefore, it can design DRAM integrated circuit (IC) with
large capacity as 4 GB per IC; Fig. 7.3 shows one bit DRAM.
The cell capacitor can be charged with logic one or zero, but it requires to be
refreshed (recharged) about every 1 ms. The CPU cannot read from or write to
memory while the DRAM is being refreshed; this makes DRAM the slowest
running memory.
•
Synchronous DRAM (SDRAM): SDRAM technology uses DRAM and adds a
special interface for synchronization. It can run at much higher clock speeds than
DRAM. SDRAM uses two independent memory banks. While one bank is
recharging, the CPU can read and write to the other bank. Figure 7.4 shows a
block diagram of SDRAM.
Table 7.1 Number of address and Memory locations
Number of addresses
Number of memory locations
Representation
10
210 ¼ 1024
1 K
11
211 ¼ 2048
2 K
12
212 ¼ 4096
4 K
13
213 ¼ 8192
8 K
14
214 ¼ 16,384
16 K
16
216 ¼ 65,536
64 K
20
220 ¼ 1,048,576
1 M
24
224 ¼ 16,777,261
16 M
32
232 ¼ 4,294,967,296
4 G
Fig. 7.3 1-bit DRAM
7.2
Semiconductor Memory
139

•
Extended Data Out RAM (EDORAM) transfers blocks of data to or from
memory.
•
Double Data Rate SDRAM (DDR SDRAM) is a type of SDRAM that transfers
data at both the rising edge and the falling edge of the clock. It can move data
twice faster than SDRM; therefore, memory can run at the ½ clock rate. DDR2
and DDR3 are an advancement on the DDR technology and further increase the
number of data transfers per clock cycle. DDR2 RAM provides 4 data transfers
per cycle, and DDR3 transfers 8 data per clock cycle. For 100 MHz clock rate
and 64 bits data bus, the transfer rates for DDR are
DDR ¼ 100*2*8 ¼ 1600 MB/s (MB/s)
DDR2 ¼ 100*4*8 ¼ 3200 MB/s
DDR3 ¼ 100*8*8 ¼ 6400 MB/s
•
Rambus DRAM (RDRAM) was developed by Rambus Corporation. It uses
multiple DRAM banks with a new interface that enables DRAM banks to
transfer multiple words and also transfer data at the rising edge and the falling
edge of clock. The RDRAM refreshing is done by the interface. The second
generation of RDAM is called DRDRAM (Direct RDRAM), and it can transfer
data at a rate of 1.6 Gbps. Figure 7.5 shows a RDRAM module.
DRAM Packaging
DRAM comes in different types of packaging such as SIMMs (single in-line
memory module) and DIMM (dual in-line memory module).
Figure 7.6 shows SIMM, which is a small circuit board that one side of the board
holds several chips. It has a 32 bit data bus.
Control Bus
Address Bus
Data Bus
Control
TOP
Bank
Bottom
Bank
Output buffer
Fig. 7.4 Block diagram of SDRAM
Fig. 7.5 Rambus memory module (Courtesy Samsung Corp.)
140
7
Memory

DIMM is a circuit board that both sides of the board hold several memory chips
but has a 64 bit data bus.
•
Static RAM (SRAM) is used in cache memory. SRAM is almost 20 times faster
than DRAM and is also much more expensive. D Flip Flop is one bit static RAM.
ROM (Read-Only Memory)
Like its name suggests, information can be ready only from read-only memory
(ROM). ROM holds information permanently, even while there is no power to the
ROM; this type of memory is called nonvolatile memory. Two types of ROM are
listed below:
•
Erasable Programmable Read-Only Memory (EPROM): EPROM can be erased
with ultraviolet light and reprogrammed with a device called an EPROM
programmer. Flash ROM is a type of EEPROM.
•
Electrically Erasable PROM (EEPROM): EEPROM can be erased by applying
speciﬁc voltage to one of its pin and can be reprogrammed with an EPROM
programmer.
•
Flash Memory: ﬂash memory is a nonvolatile memory that has wide range
applications such as ﬂash drive, solid-state drive, memory card, and embedded
system. Flash memory is a type of EEPROM that allows multiple memory
location to be written or erased on one operation. There are two types of
technology use for ﬂash memory, and they are NAND and NOR ﬂash memories;
NAND ﬂash memory has smaller access time than NOR ﬂash memory; most
ﬂash memory uses NAND technology.
Memory Access Time The time the CPU places address on address bus and data
appears on data bus or write the data into memory. Table 7.2 shows access time for
different types of memory.
Fig. 7.6 DRAM SIMM
Table 7.2 Memory access
time
Memory technology
Access time
SRAM
0.5–2.5 ns
DRAM
50–70 ns
Flash
5 * 103–5 * 105
7.2
Semiconductor Memory
141

7.3
Hard Disk
Figure 7.7 shows the internal architecture of hard disk made of several platters, and
platters hold the information; the functions of the heads are to read or write
information from disk surface. The surface of platter is made of several tracks,
and each track is divided into sectors as shown in Fig. 7.8.
track t
spindle
sector s
cylinder c
platter
rotation
arm
read-write
head
arm assembly
Fig. 7.7 Internal architecture of hard disk
Fig. 7.8 Surface of a platter
142
7
Memory

Disk Characteristics
Access Time: the time that takes to start transfer data, and it is the sum of seek time
and rotational delay.
Seek Time: the time that takes the head move to the proper track.
Rotational Delay: the time that it takes a sector to be positioned under read/write
head and depend on rotation speed. The rotation speed represented by revolutions
per minute (RPM) assumes the sector is away from head half of the track; therefore
the rotation delay is calculated by
Rotational Delay ¼ Time for half revolution ¼ 60s=RPM∗2
Disk Capacity: capacity of a disk calculated by
Disk Capacity ¼ Number of surfaces∗Number of track=Surface∗
Number of sectors=Track∗Number of bytes=Sector
Cluster
Each sector of a disk is 512 bytes (B), and cluster is made of one or more sectors, if
a cluster is 1 kB, then it is made of two sectors. The 2 kB cluster is made of
4 sectors. Table 7.3 shows default values of cluster size.
Example 7.1 A disk drive has 8 surfaces, each surface has 1024 tracks, each track
has 64 sectors, and each sector can hold 512 B and rotation speed of 6000RPM.
(a) What is the capacity of disk?
(b) What is the rotational delay?
Disk capacity ¼ 8 * 1024 * 64 * 512 ¼ 268,435,456 B
Rotation delay ¼ 60/6000 * 2 ¼ 0.005 s
Disk File System
A ﬁle system deﬁnes organization of information stored in hard disk; the windows
OS (operating system) offers FAT16 (ﬁle allocation table) and FAT32 which are
used for early windows OS; currently most windows OS uses NTFS (New Tech-
nology File System). NTFS offers better security such as permission to restrict
access and encryption.
Table 7.3 Default cluster size
DISK size
NTFS cluster size
512–1024 MB
1 kB
1024 MB–2 GB
2 kB
2 GB–2 TB
4 kB
7.3
Hard Disk
143

7.4
Solid-State Drive (SSD)
Hard drive is a slow device, and it can be replaced by SSD. SSD is made of
nonvolatile NAND ﬂash memory. Figure 7.9 shows architecture of SSD, and
Table 7.4 compares SSD with HDD.
7.5
Memory Hierarchy
Computers come with three types of memory, which are arranged in a hierarchical
fashion, as shown in Fig. 7.10:
Fig. 7.9 Architecture of SSD
Table 7.4 Comparing the SSD with HDD
Characteristics
SSD
HDD
Access time
100 times faster than HDD
5000–10,000 μs
Price
Expensive
Less expensive
Reliability
More reliable because it does not have any mechanical
part
Less reliable
Capacity
Gigabytes
Terabytes
Power
Less power than HDD
More power than
SSD
144
7
Memory

1. Cache memory: Cache memory is the fastest type of memory and is most often
used inside CPU called L1 cache, and it is faster than main memory and,
therefore, more expensive than main memory.
2. Main memory: Main memory uses DRAM and SDRAM. The program to be
executed moves from secondary memory (disk or tape) into main memory.
3. Secondary memory: Second memory refers to memory such as hard disk, SSD,
and CD-ROM (Table 7.5).
Cache Memory
Each cache memory location is called cache line which can hold a block of data
from main memory. For the most processors, the cache memory is located inside
CPU and called L1 cache; there are two types of cache in a CPU:
1. Data cache (D-cache): Data cache holds the data and it can be read or write
by CPU.
2. Instruction cache (I-Cache): Instruction cache holds instruction and CPU only
read from I-cache.
Fig. 7.10 Memory
hierarchy of a
microcomputer
Table 7.5 Show price of different type of memory
Memory type
SRAM
DRAM
SSD
HDD
Cost
$8.00/MB
$0.16/MB
$0.20/GB
0.05/GB
Access time
0.5–2.5 ns
50–70 ns
70–150 ns
5–20 ms
7.5
Memory Hierarchy
145

Cache Terminology
Miss: when CPU accesses the cache and data is not in cache, it is called cache miss
Hit: when CPU accesses the cache and data is in the cache, then it is called cache hit
Hit ratio: number of hits/number of miss þ number of hits (total number of reads)
Block: multiple of main memory locations is called block
Physical address: address generated by CPU to access main memory
Virtual address: address generated by CPU to access virtual memory or secondary
memory
Cache line or cache block: each can line or block holds multiple byes or words; the
size of cache line is the same block in main memory
Temporal locality: once a memory location referenced, then there is a high prob-
ability to be referenced again in near future
Spatial locality: when a memory location is accessed, then it is very likely the
nearby locations will be accessed soon.
Cache Memory Mapping Methods
Figure 7.11 shows a cache with 4 locations and main memory with 8 memory
locations, and the cache can hold only 4 memory locations of main memory; CPU
ﬁrst accesses the cache if data is not in cache and then accesses main memory and
moves a block data into the cache; the question is where the data will store in the
cache; this bring subject of mapping methods.
The mapping methods are used to map a block of main memory into the cache
line (cache block), and following are types of methods used for mapping:
1. Direct mapping
2. Associative mapping
3. Set associative
Direct Mapping
Figure 7.12 shows a cache memory with four cache lines, and each line holds 4 B;
the physical address seen by cache is divided into three ﬁelds and they are:
Fig. 7.11 Cache and main
memory
146
7
Memory

Offset: determines the size of cache line (number of bytes or words) since each
cache line can hold 4 memory locations and then the offset is 2 bits, and each
block is 4 memory locations; also offset determines which of the four data to be
transferred to CPU.
Index: index is the address to the cache; in this ﬁgure there are 4 cache lines and
then index is 2 bits.
V-bit (valid bit): V-bit set to one to represent that data in cache line is valid.
Tag: Size of Tag ¼ Size of Physical Address  (Size of Index þ Size of Offset).
If physical address is 7 bits, then tag ¼ 7(2 þ 2) ¼ 3 bits.
If valid bit is one and tag in address ﬁeld matches with the tag stored in cache,
then results are hit; otherwise is miss.
When CPU receives miss from cache, then access the main memory and transfer
a block of data from main memory to cache line using following equation for direct
mapping:
Cache line Address ¼ Main Memory Block Number
ð
ÞModulo N
where N is the number of cache lines.
Consider Fig. 7.13 cache and assume CPU generates address 010 10 11, the
Fig. 7.13 shows format of physical address seen by cache.
The CPU uses the index value to access cache line 10 and if the valid bit is zero
results in a miss, the CPU accesses the main memory and transfers block 01010 to
cache line 10 according to following equation:
Fig. 7.12 Cache memory with 4 cache lines
7.5
Memory Hierarchy
147

01010
ð
Þ2 ¼ 10
ð
Þ10
Cache line number ¼ 10modulo 4 ¼ 2 or
10
ð
Þ2
In this case each block is made up of 4 memory locations. Since the offset is two
bits, it can refer any of 4 (22) chunks of data within a block of memory. The block at
address 01010 in main memory with a 2 bit offset consists of memory locations
0101000 (M28), 0101001 (M29), 0101010 (M2A), and 0101011 (M2B).
In this case, M28, M29, M2A, and M2B are transferred to cache line 10, and the
V-bit is set to one. The tag is stored in the tag ﬁeld of cache as shown in Fig. 7.14.
Now, if the CPU generates address 0101010, where tag ¼ 010, index ¼ 10, and
offset ¼ 10, the CPU uses the index to access cache line 10. If on cache line 10 the
V-bit equals 1 and the tag of the address matches with the tag in the cache line, then
the result is a hit, and the CPU uses offset 10 to move data (M2A) in to the CPU.
(Where offset 00 ¼ M28, 01 ¼ M29, 10 ¼ M2A, 11 ¼ M2B.)
Example 7.2 Figure 7.15 shows the main memory and cache memory of a
computer. CPU generates (in hex) addresses 0  0, 0  2, 0  5, and 0  2.
Assuming the cache is empty at the beginning, show the contents of the cache.
In this example each block and cache line is 2 B and main memory consists of
8 blocks. Figure 7.16 shows the physical address as seen by the cache.
•
The byte offset is one bit. (2 B per block)
•
The index is two bits. (cache consist of 4 lines ¼ 22)
•
The tag is one bit. (Bits in block  bits in index ¼ 3  2 ¼ 1)
•
The CPU generates address 0  0 or 0000. Therefore, the tag is 0, the index is 00,
and the offset is 0. The CPU accesses cache line 00 and the V-bit is zero which
results in a miss. The CPU accesses main memory address 0000, transfers block
000 to the cache line 00, and sets the tag bit to zero and the V-bit to one.
Fig. 7.13 Format of
physical address for
0101011
Fig. 7.14 Cache memory
with four lines (four blocks)
148
7
Memory

Therefore, cache line 00 contains: V ¼ 1, Tag ¼ 0, Byte1 ¼ 0  5,
Byte0 ¼ 0  1.
•
Next the CPU generates address 0  2 or 0010. The index is 01 so the CPU
accesses cache line 01, where the valid bit is zero which results in a miss. Then
the CPU accesses main memory location 0010 and transfers block 001 into
cache line 01, changes the valid bit to one, and stores the tag part of the address
into the cache line’s tag. Therefore, cache line 01 is now: V ¼ 1, Tag ¼ 0,
Byte1 ¼ 0  7, Byte0 ¼ 0  6.
•
The CPU generates address 0  5 or 0101. The index is 10, so the CPU accesses
cache line 10 and the result is a miss. The CPU accesses main memory location
0101 and transfers block 010 to the cache, sets V to one, and stores the tag of the
address into the cache’s tag. Cache line 10 is now: V ¼ 1, Tag ¼ 0, Byte1 ¼ 0  7,
Byte0 ¼ 0  8.
•
The CPU generates address 0  2 or 0010, so it accesses cache line 01. The valid
bit is 1 and the cache line tag matches the address tag, which results in a hit. The
offset is 0, so the CPU reads byte 0 from cache line 01. This process will
continue for other addresses.
Fig. 7.15 Cache memory and main memory of Example 7.2
Fig. 7.16 Physical address
format for Example 7.1
7.5
Memory Hierarchy
149

Using the same size cache and main memory as above, blocks 000 and 100 will
both be mapped onto cache line 00. If the CPU generates addresses 0000, 1000,
0001, and 1001 consecutively, then results will be misses for all four addresses. In
order to reduce misses, then the cache can be divided into sets, and mapping method
is called set associative mapping.
Set Associative Mapping
In set associative mapping, the cache memory is divided into sets. The size of the
set can vary: examples include two-way set associative, four-way set associative,
and so on. Figure 7.17 shows a two-way set associative cache, and Fig. 7.18 shows
the physical address format seen by the cache. Using the previous examples as a
base, the byte offset will remain one bit since it refers to one of two bytes stored on
the cache line. The set identiﬁer will be one bit that deﬁnes the set address; the tag
size is calculated as follows:
Tag Size ¼ Physical address size  Set address  Offset
Assume the physical address is 4 bits, then Fig. 7.18 shows the physical address
seen by cache.
Example 7.3 Consider the main memory from Fig. 7.15, where the cache is empty
and it is divided into two sets as shown in Fig. 7.19. Show the contents of the cache
if the CPU generates addresses 0  0, 0  8, 0  0, and 0  8.
•
The CPU generates address 0  0 or 0000 and accesses cache set 0. Both cache
lines in the set 0 have valid bits of 0, so the result is a miss. The CPU then
accesses main memory, transfers contents of memory locations 0000 and 0001
into the cache, then changes the valid bit to one, and stores the tag part of the
address into the cache’s tag.
Next, the CPU generates address 0  8 or 1000 and accesses cache set 0. First
line of the cache has a valid bit of 1 but the tag does not match (10 vs. 00). The CPU
then accesses main memory, transfers contents of memory locations 1000 and 1001
into second line of the cache in the set 0, and changes the valid bit to one and stores
the tag part of the address into the cache’s tag. Now, when the CPU generates the
addresses 0  0 and 0  8 again result hits.
V
Tag
Byte1
Byte0
V
Tag
Byte1
Byte0
0
0
0
1
0
0
Fig. 7.17 Two-way set associate cache
Fig. 7.18 Physical address
seen by cache for set
associative mapping
150
7
Memory

Replacement Method
In set associative, when CPU brings a new block into cache, then one of the cache
lines must be replaced with new block; consider Fig. 7.20. If CPU generates address
0100 (4) (tag ¼ 01, set address ¼ 0, and offset is 0), it accesses set 0, and both cache
lines have valid bit one, but tags in cache lines do not match with address tag results
miss, and then CPU accesses main memory and must move the contents of memory
locations 0100 and 0101 into cache. CPU uses least recently used (LRU) method
which moves new block from main memory and replaces it with block that has been
longer in the cache. This method accomplishes by adding LRU bit to each cache
line of the cache as shown in Fig. 7.21.
In Fig. 7.21, assume both cache lines in set 0 are empty, a new block moves into
the ﬁrst cache line in set 0, and LRU changed from 0 to 1; the second block moves
to second cache line of set 0, and LRU changed from 0 to 1, but at the same time,
LRU of ﬁrst cache line will change from 1 to 0; therefore, the cache line with
LRU ¼ 0 contains block that has been longer in cache line.
Fig. 7.19 Content of cache for address 0000
Fig. 7.20 Contents of cache for addresses 0000 and 1000
7.5
Memory Hierarchy
151

Fully Associative Mapping
In fully associative mapping, the entire address is stored in the cache with its data.
Figure 7.22 shows a fully associative cache with four lines after the CPU has
accessed main memory locations 0  0 and 0  8. If the CPU next generates
address 0  0 or 0000, then it will compare the address with each address in the
cache, and if it matches, then it will read the data from the cache.
Cache Update Methods
1. Write Through: When new information is written to the cache, main memory is
also updated.
2. Buffered Write Through: There is a buffer between cache and main memory,
when new information is written to the cache, this information is written into
buffer, and the CPU can access this memory before the new information can be
written into main memory.
3. Write Back (Copy Back): In this method, only the cache is updated, and main
memory will be updated when the corresponding cache line is overwritten. In
this method each cache line has a dirty bit to indicate if cache line has been
modiﬁed or not.
Fig. 7.21 Two set associative with LUR
Valid
Address
Byte1
Byte0
1
000
5
1
1
100
9
2
0
0
Fig. 7.22 Associative
mapping
152
7
Memory

7.5.1
Virtual Memory
Virtual memory is a HDD or SSD; it is used to store application data and instruction
that is currently not needed to be process by the CPU. Virtual memory enables a
system to run application larger than main memory. Disk is seen by CPU as virtual
memory, if CPU has 16 address lines, then the size of virtual memory will be 216 B.
Application resides in disk and it is called process. When user runs a program, the
operating system moves the pages of process into main memory. Virtual memory is
divided into the pages as shown in Fig. 7.23; the process A occupied pages P0
through P4, and process B occupied pages P5–P9.
The CPU generates a virtual address (to access an address in the disk) of V-bits.
These bits are divided into two identiﬁers: a virtual page number of M bits and a
page offset of N bits as shown in Fig. 7.24. The total number of pages in the system
is equal to 2M, and the number of bytes (in a byte-addressable system) in a page is
equal to 2N. The total number of addresses in a system is equal to 2(NþM) or 2V.
Example 7.4 The capacity of a virtual disk is 2 MB (megabytes), and each page is
2 kB (kilobytes) in a byte-addressable system.
(a) What are values of N and M?
(b) How many pages are in the disk?
Since each page is 2 kB, 2N ¼ 2048 B, meaning N equals 11.
The capacity of the disk is 2 MB. 2V ¼ 2 M equals 221 so V ¼ 21 bits.
Fig. 7.23 Virtual memory
Fig. 7.24 Virtual address
format
7.5
Memory Hierarchy
153

The number of pages, then, is equal to 2(21–11). The disk contains 210 or 1024
pages, and the size of each page is 2 kB.
Page Table With main memory divided into blocks, the size of each block
(or frame) is equal to the page size. When the CPU transfers a page into main
memory, it records the page number and corresponding block in the page table. The
address line of the page table is the page number. Each line contains the frame or
block number of the matching location in main memory and a valid bit that
indicates whether the line is valid or not. Figure 7.25 shows a page table wherein
pages P0, P1, P3, and P4 are transferred to the blocks 2, 3, 0, and 1, respectively.
Fig. 7.25 Virtual memory, memory, and page table
154
7
Memory

Each process has its own page table stored in main memory. Since cache
memory is faster, part of the page table referred to as the translation lookaside
buffer (TLB) is stored in the cache. The TLB uses associative mapping.
7.5.2
Memory Organization of a Computer
Figure 7.26 shows memory organization of a computer which in this example
consists of:
A. Virtual memory (hard disk or solid-state drive)
B. Main memory (A type of DRAM)
C. Cache memory (SRAM)
D. A page table which keeps track of pages in main memory
E. The TLB which holds a part of the page table
Memory Operation
The following steps describe the operation of memory of a computer. First, the CPU
generates a virtual address and checks the TLB to see if the corresponding page is in
main memory already or not.
Fig. 7.26 Memory organization of a computer
7.5
Memory Hierarchy
155

A. If the TLB indicates that the corresponding page is in memory, then generate a
physical address and check if the data is in the cache.
(a) If it is in the cache, then this called a hit and it reads the data from the cache
(b) If it is not in the cache, then it is called a miss, and the CPU accesses
memory and moves a block of data into the cache then reads it.
B. If the corresponding page is not in the TLB, then the CPU checks the page table.
1. If the corresponding page is in main memory, then update the TLB and repeat
from step 1.
2. If corresponding page is not in main memory, then move the page from
virtual memory into main memory, update the page table, update the TLB,
and repeat from step 1.
C. If the corresponding page is not in the page table, then the CPU moves the page
from virtual memory into main memory, updates the page table, updates the
TLB, and repeats from step 1.
Questions and Problems
1. Distinguish between volatile and none-volatile memory.
2. What does RAM stand for?
3. List three different types of RAM.
4. Which of the following memory types are used for main memory?
(a) ROM and SDRAM
(b) SRAM and DRAM
(c) SDRAM and DRAM
(d) DRAM and EPROM
5. _________ holds information permanently, even when there is no power.
(a) ROM
(b) DRAM
(c) RAM
(d) SRAM
6. What does ROM stand for?
7. Is ﬂash memory a type of RAM or ROM?
8. What is the difference between EEPROM and EPROM?
9. What is capacity of a memory with 10 address lines and holds one byte per
memory location?
10. What is the primary application of SRAM?
11. What is the primary application of DRAM?
12. Deﬁne the following terms:
(a) Track
(b) Sector
(c) Cluster
156
7
Memory

13. A hard disk consists of 4 surfaces, each surface consists of 80 tracks, and each
track consists 32 sectors. Each sector holds 512 B. What is the capacity of this
disk?
14. What is the function of ﬁle allocation table (FAT)?
15. List types of memory in a computer from fastest to slowest.
16. What are the types of cache?
17. What type of memory is used for cache memory?
18. What is virtual memory?
19. Distinguish between a virtual address and physical address.
20. Physical address determines size of
(a) Virtual memory
(b) Physical memory
(c) Cache memory
21. Show the format of a virtual address.
22. What is hit ratio?
23. Explain temporal locality.
24. Explain spatial locality.
25. List cache mapping methods.
26. Show format of address seen by the cache for direct mapping.
27. List cache mapping methods.
28. Show format of address seen by the cache for set associative mapping.
29. What is the function of a page number in a virtual address?
30. How many bits is the page offset if each page holds 8 kB?
31. What is the function of the page table?
32. What information is stored in TLB? Where is the TLB stored?
33. List cache mapping methods.
34. What is the advantage of set associative versus direct mapping of caches?
35. What are the three write policies used for memory?
36. __________ is the fastest type of memory.
(a) Cache memory
(b) Main memory
(c) Secondary memory
(d) Hard disk
Problems
1. The following main and cache memory are given. The CPU generates addresses
0  0, 0  2, 0  3, 0  4, 0  5, 0  3, 0  6, 0  6, 0  7, 0  B, 0  D, and
0  F. Show the contents of the cache and ﬁnd the hit ratio.
7.5
Memory Hierarchy
157

ADDRESS
Contents
0000
5
0001
0
0010
1
0011
11
0100
15
0101
09
0110
16
0111
23
1000
65
1001
01
1010
8
1011
9
1100
15
1101
0
1110
2
1111
5
v    Tag
Data
2. The following memory and cache memory is given. CPU generates addresses
0  1, 0  2, 0  1, 0  8, 0  9, 0  1C, 0  1D, 0  3, and 0  4.
(a) Show the contents of the cache using two-way set associative mapping;
assume a LRU replacement policy.
(b) What is the hit rate?
158
7
Memory

3. A computer has 24 bit physical addresses and each memory location holds one
byte. This computer has 64 cache lines and each line holds 16 B. Show the
format of the address (tag, index, and byte offset) using
(a) Direct mapping
(b) 4-way set associative
(c) 8-way set associative
4. A computer has 32 kB of virtual memory and 8 kB of main memory with a page
size of 512 B.
(a) How many bits are in the virtual address?
(b) How many pages are in virtual memory?
(c) How many bits are required for the physical address?
(d) How many frames or blocks are in main memory?
5. A computer with 256 MB of virtual memory, 4 MB of main memory, and 8 kB
of cache memory. Assume a page size of 2 kB.
(a) What is the size of a virtual address?
(b) What is the size of a physical address?
(c) How many pages are in virtual memory?
(d) How many blocks are in main memory?
7.5
Memory Hierarchy
159

(e) What is the size of the page table? (Include the number of locations and the
total size of each location including all information.)
6. A computer has 20 bits of virtual memory and each page is 2 kB.
(a) What is the size of virtual memory?
(b) How many pages are in virtual memory?
7. A computer with 4 words per block has 4 K blocks of cache and 1 M blocks of
main memory.
(a) What is the size of a physical address?
(b) Determine the size of the tag, index, and word offset of physical address
using direct mapping.
(c) Determine the size of the tag, set, and word offset of physical address using
Two-way set associative mapping.
8. CPU of Fig. 7.26 generates addresses 000 and 00b; assume page 0 map into
block 1 and page 2 map in block 0, show the contents of page table.
160
7
Memory

Chapter 8
Assembly Language and ARM Instructions
Part I
Objectives: After completing this chapter, you should be able to:
•
Explain the function of compiler and the assembler.
•
Convert HLL to the machine language.
•
Show ARM processor architecture.
•
Describe the function of processor state register (PSR).
•
List instruction classiﬁcation based on number of the operands.
•
Learn different types of the ARM instructions.
•
Describe the operation of conditional instructions.
•
Convert HLL to the assembly language.
•
Explain the shift and the rotate instructions.
•
Explain the operation of stack instructions.
•
Explain application of the Branch instructions.
8.1
Introduction
Programmers use high-level language to develop application program; in order for
the program to become an executable form, it must be converted in machine code
(binary).
Figure 8.1 shows a high-level language (HLL) converted to machine code, the
compiler converts HLL into assembly language, and then assembler converts
assembly language to machine language (bits) by assembler.
Each CPU has a set of instructions which represents the type of operations the
CPU can perform, and these instructions are represented in mnemonic forms or
abbreviation, for example, the addition instruction is represented by “ADD,” and
subtraction instruction is represented by “SUB.”
ADD R1, R2, R3 means add contents of R2 with R3 register and store results in
R1 register. R1, R2, and R3 are called operands.
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_8
161

The following HLL are converted to assembly language:
HLL Assembly Language
R3=R1þR2 ADD R3, R1, R2
R3=R1-R2 SUB R3, R1, R2
The programmer uses instructions to write assembly language. The applications
of assembly language are:
•
Assembly language is used for writing fastest code.
•
It helps to better understand HLL.
•
Writing compiler for HLL requires knowledge of assembly language.
•
It is used in embedded system and driver.
•
HLL may not provide access to hardware then assembly language can be used.
8.2
Instruction Set Architecture (ISA)
Manufacturers of CPUs publish a document that contains information about the
processor such as list of registers, function of each register, size of data bus, size of
address bus, and list of instructions that can be executed by the CPU. Each CPU has
a known instruction set that a programmer can use to write assembly language
program. Instruction sets are speciﬁc to each type of processor. Pentium processors
use a different instruction set than ARM processor. The instructions classiﬁed are
based on number of operands or type of operation.
8.2.1
Classiﬁcation of Instruction Based on Number
of Operands
No Operand Instructions. The following are some of the instructions that do not
require any operands:
HLT
Halt the CPU
NOP
No operation
Fig. 8.1 Converting HLL to machine language
162
8
Assembly Language and ARM Instructions Part I

PUSH operand:
Push operand into top of the stack
POP operand
Remove the operand from top of the stack
One-Operand Instructions The following are some of the instructions that
require one operand.
INC
operand
Example: INC R1 – Increment register R1 by 1
DEC
operand
Example: DEC R1 – Decrement register R1 by 1
J
target
Jump to memory location labeled by target
ADD
operand
Add operand to the accumulator (ACC) ACC ! ACC þ operand
Two-Operand Instructions The following are some of the instructions that
require two operands.
ADD Rd, Rn Example: ADD R1, R2 – R1 R1þR2
Intel Instruction Set Architecture uses two operands.
MOV EAX, EBX ; EAX  EBX
Three-Operand Instructions Most modern processors use instructions with three
operands, such ARM, MIPS, and Itanium
ADD R1, R2, R3 ; R1 R2 þR3
8.3
ARM Processor Architecture
Advanced RISC Machine (ARM) was developed by the Acorn Company. ARM is a
leader supplier of microprocessors in the world, ARM develops the core CPU, and
thousands of suppliers add more functional units to the core. ARM uses two types
instruction called Thumb and Thumb-2. Thumb instructions are 16 bits and thumb-
2 instructions are 32 bits; currently most ARM processors use 32-bit instructions.
ARM contains 15 registers called R0 through R15, R0 through R12 called
general propose registers. ARM is able to execute Thumb instructions (16-bit
instructions) and Thumb-2 32 bits instruction. Thumb instructions use registers
R0 through R7.
ARM is intended for applications that require power efﬁcient processors, such as
telecommunications, data communication (protocol converter), portable instru-
ment, portable computer, and smart card. ARM is basically a 32-bit RISC processor
8.3
ARM Processor Architecture
163

(32-bit data bus and address bus) with fast interrupt response for the use in real-time
applications. A block diagram of ARM7 processor is shown in Fig. 8.2.
Instruction Decoder and Logic Control The function of instruction decoder and
logic control is to decode instructions and generate control signals to other parts of
processor for execution of instructions.
Address Register To hold a 32-bit address for address bus
Address Increment It is used to increment an address by four and place it in
address register.
Register Bank Register bank contains thirty-one 32-bit registers and 6 status
registers.
Fig. 8.2 Block diagram of ARM7 architecture
164
8
Assembly Language and ARM Instructions Part I

Barrel Shifter It is used for fast shift operation.
ALU 32-bit ALU is used for arithmetic and logic operation.
Write Data Register The processor put the data in Write Data Register for write
operation.
Read Data Register When processor reads from memory it places the result in this
register.
ARM Operation Mode
ARM can operate in one of the following modes:
1. User mode: Use for normal operation.
2. IRQ mode: This interrupt mode is designed for handling interrupt operations.
3. Supervisory mode: Used by operating system.
4. FIQ mode: Fast interrupt mode.
5. Undeﬁned mode: When an undeﬁned instruction executed.
6. Abort mode: This mode indicates that current memory access cannot be com-
pleted, such as when data is not in memory and the processor requires more time
to access disk and transfer block of data to memory.
8.4
ARM Registers
ARM7 has 31 general registers and 6 status registers. At user mode, only 16 regis-
ters and 1 Program Status Register (PSR) are available to programmers. The
registers are labeled R0 through R15. R15 is used for program counter (PC), R14
is used for link register, and R13 is used for stack pointer (SP). Figure 8.3 shows
user mode registers.
Current Program Status Register (CPSR). Figure 8.4 shows the format of PSR.
This register is used to store control bits and ﬂag bits. The ﬂag bits are N, Z, C,
and V, and the control bits are I, F, and M0 through M4. The ﬂag bits may be
changed during a logical, arithmetic, and compare operation.
Flag Bits
N (negative): N ¼ 1 means result of an operation is negative, and N ¼ 0 means
result of an operation is positive.
Z (zero): Z ¼ 1 means result of an operation is zero, and Z ¼ 0 result of an operation
is not zero.
C (carry): C ¼ 1 means result of an operation generated a carry, and C ¼ 0 means
result of an operation did not produce a carry.
V (overﬂow): V ¼ 1 means result of an operation generated an overﬂow, and V ¼ 0
means result of an operation did not generate an overﬂow.
8.4
ARM Registers
165

Control Bits
I (interrupt bit): When this bit sets to one, it will disable the interrupt, and this
means the processor does not accept any software interrupt.
F-bit is used to disable and enable fast interrupt request mode (FIQ) mode.
M4, M3, M2, M1, and M0 are mode bits, and they are equal to 10000 for user mode.
T (State bit): T ¼ 1 Processor executing Thumb instructions, T ¼ 0 processor
executing ARM instructions.
8.5
ARM Instructions
ARM architecture supports Thumb 16-bit and Thumb-2 32-bit instruction set. Most
of the ARM instructions use three operands. These instructions are classiﬁed based
on their instructions format and operations that are listed as follows:
(A) Data processing instructions
(B) Single data swap
(C) Shift and rotate instructions
(D) Unconditional instructions and conditional instructions
(E) Stack operations
31
30
29
28
27
7
6
5
4
3
2
1
0
N
Z
C
V
Unused
I
F
T
M4 M3 M2 M1 M0
Fig. 8.4 Storage format for CPSR
31                     0
R0
R1
R2
R3
R4
R5
R6
R7
R8
R9
R10      
R11
R12
R13
R14
R15   (PC)
CPSR
Fig. 8.3 User mode
registers
166
8
Assembly Language and ARM Instructions Part I

(F) Branch
(G) Multiply instructions
(H) Data transfer
8.5.1
Data Processing Instructions
The data processing instructions are as follows: AND, EOR, SUB, RSB, ADD,
ADC, SBC, RSB TST, TEQ, CMP, CMN, ORR, MOV, BIC, and MNW. Data
processing instructions use register operands and immediate operand. The general
format of data processing instructions is:
Mnemonic {S}{Condition} Rd, Rn, operand2
Mnemonic: Mnemonic is abbreviation of an operation such as ADD for
addition
{}: Commands inside the { } is optional such as S and condition
S: When an instruction contains S mean update the Processor Status
Register (PSR) ﬂag bits
Condition: Condition deﬁne the instruction will executed if meet
the condition
Rd: Rd is destination register
Rn: Rn is operand1
Operand2: Operand2 can be register or immediate value
A. Registers Operands The operands are in registers. First register is destination
register, second register is operand1 and third register is operand2.
Following are arithmetic and logic operations instructions with register
operands.
ADD R0, R1, R2 ;R0=R1þR2 Add contents of register R1 with register
R2 and place the result in register R0.
ADC R0, R1, R2; ;R0 = R1þR2 þC Add with carry C is carry bit.
SUB R0, R2, R3 ;R0=R2–R3 where R2 is ﬁrst operand and R3 is second
operand
8.5
ARM Instructions
167

SBC R0, R2, R3; ;R0=R2-R3þC-1 SUB with carry.
RSB R0, R2, R5 ;R0= R5-R2 Reverse SUB.
RSC R0, R2, R5 ;R0=R5-R2þC-1 Reverse sub with carry.
AND R0, R3, R5 ;R0= R3 AND R5.
ORR R7, R3, R5; ;R7=R3 OR R5.
EOR R0, R1, R2 ;R0 = R1 Exclusive OR with R2.
BIC
R0,
R1,
R2
;Bit
clear.
The
one
in
second
operand
clears
corresponding bit in ﬁrst operand and stores the results in des-
tination register.
Example 8.1 Assume contents of R1 is 1111111111011111, and R2 is 1000 0100
1110 0011 after execution of BIC R0,R1, R2 the R0 contains 0111 101100011100.
A. Immediate Operand In immediate operand, operand2 is an immediate value
and maximum can be 12 bits
ADD
R1,
R2,
#&25
;R1=R2þ&amp;amp;amp;amp;amp;amp;25,
#
means
immediate
and
&amp;amp;amp;amp;amp;amp;
means
the
immediate
value is in hexadecimal.
AND R2, R3, #&45 ;R2 = R3 AND &45.
EOR R2, R3, #&45 ;R2= R3 Exclusive OR &45.
Example 8.2 What are the contents of R1 after executing the following instruc-
tion? Assume R2 contains 0x12345678
ADD R1, R2, #0x345
The ADD instruction will add contains of R2 with 0x2345 and store the result in
R1, then R1 ¼ 0x123459BD.
Setting Flag Bits of PSR The above instructions do not affect the ﬂag bit of PSR
because the instructions do not have option S. By adding sufﬁx S to the instruction,
the instruction would affect the ﬂag bit.
ADDS R1, R2, R3 ;The sufﬁx S means set appropriate ﬂag bit.
SUBS R1, R2, R2; ;This will set zero ﬂag to 1.
168
8
Assembly Language and ARM Instructions Part I

8.5.2
Compare and Test Instructions
ARM processor uses the compare and test instructions to set ﬂag bits of PSR and
following are compare and test instructions.
CMP, CMN, TST, and TEQ, these instruction uses two operands for compare
and test, the result of their operations do not write to any register
CMP Instruction (Compare Instruction) The CMP instruction has following
format
CMP Operand1, Operand2
The CMP instruction compares Operand1 with Operand2; this instruction sub-
tracts Operand2 from Operand1 and sets the appropriate ﬂag. The ﬂag bit set based
on the result of the operation as follows
Z ﬂag set if Operand2 equal operand1
N ﬂag is set if operand1 less than operand2
C ﬂag is set if result of operation generate carry
Example 8.4 Assume R1 contains 0x00000024, and R2 contains 0x00000078; the
operation CMP R1, R2 will set N ﬂag to 1.
CMP Rd, immediate value , the immediate value can be 8 bits such as
CMP R1, #0xFF
CMN Compare Negate The CMN has following format
CMN Operand1, Operand2
The instruction will add operand1 with operand 2 and set appropriate ﬂag bit.
Example 8.5 Assume R1 contains 0x00000024 and R2 contains 0x13458978: the
operation CMN R1, R2 with result carry and set C ﬂag to 1.
TST (Test Instruction) The test instruction has following format
TST Oprand1, Operand2
The test instruction performs AND operation between operand1 and Operand2
and sets appropriate ﬂag bit. The operand can be immediate value or register such as
TST R1, R2 ;This instruction performs R1 AND R2 operation and sets
the appropriate ﬂag.
8.5
ARM Instructions
169

OR
TST R1, immediate, the immediate value can be 8 bits such as
TST R1, 0xFF
TEQ R1, R2 ;This instruction performs R1 Exclusive OR R2.
If R1 is equal to R2, then Z-ﬂag is set to 1.
8.5.3
Register Swap Instructions (MOV and MVN)
The register swap instructions have the following general formats.
A. MOV{S}{condition} Rd, Rm
Move the contents of Rm to Rd
Example 8.6 What is the content of R1 after execution of the following
instructions?
Assume R2 contains 0X0000FFFF.
a. MOV R1, R2 ;R1  R2
R2=0x0000FFFF
b. MVN R1, R2 ; R1  NOT R2
R2= 0xFFFF0000
A. MOV{S}{condition} Rd, immediate value
Immediate value is 16 bits, the range of immediate value if from 0x00000000 to
0x0000FFFF.
Example 8.7
MOV R2, # 0x45 , the contents of R2 will be 0x00000045
B. MOV Rn, Rm, lsl # n ; shift Rm n times to the left and store the
result Rn
C. Conditional MOV
MOVEQ R2, 0x56 ; if zero bit is set then executes MOVEQ
170
8
Assembly Language and ARM Instructions Part I

8.5.4
Shift and Rotate Instructions
ARM combined the rotate and shift operation with other instructions; the ARM
processor performs following shift operations.
LSL
Logical Shift Left
LSR
Logical Shift Right
ASR
Arithmetic Shift Right
ROR
Rotate Right
Logical Shift Left (LSL). In logical shift left operations, each bit of register
shifted to the left as shown in Fig. 8.5 and a zero will be placed in the least
signiﬁcant bit, the logical shift left multiplies the contents of register by two.
LSL R1, R1, n , shift to left R1 n times and store result in R1
Example 8.8 What is the content of R1 after executing the following instruction?
Assume R1 contain 0x00000500.
LSL R1, R1, 8
R1= 0x00050000
Logical Shift Right (LSR). In logical shift right operation, each bit of register
shifted to the right as shown in Fig. 8.6, and a zero will be placed in the most
signiﬁcant bit; the logical right divides the contents of register by two.
LSR R1, R1, n ,shift to right R1 n times and store result in R1
Fig. 8.5 Logical shift left
Fig. 8.6 Logical shift right
8.5
ARM Instructions
171

Example 8.9 What are the contents of R1 after executing the following instruc-
tion: assume R1 contains 0x00000500.
LSR R1, R1, 4
R1= 0x00000050
Arithmetic Shift Right (ASR). In arithmetic shift right, the most signiﬁcant bit
does not change and each bit shifted to the right as shown in Fig. 8.7.
Rotate Right Figure 8.8 shows an 8-bit register and Fig. 8.9 shows the register
after rotating one time.
Example 8.10 What is the content of R1 after rotating 16 times? Assume R1
contains 0X0000FFFF
ROR R1, R1 , #16
R1= 0xFFFF0000
ARM combines data processing instructions and shift operation; shift operation
is applied to the second operand of the instruction.
Example 8.11 Register R2 contains 0XEEEEFFFF, by executing.
MOV R1, R2, ROR # 16 ;the R2 rotate 16 times and store results in
R1
by rotating 16 times the contains of R1 will be xFFFFEEE
Fig. 8.7 Arithmetic shift
right
Fig. 8.8 Rotate right
operation
Fig. 8.9 One bit rotate right operation
172
8
Assembly Language and ARM Instructions Part I

ADD R1, R2, R3, LSL #4 ;R1= R2 þ R3 x 24, R3 is shifted 4 times to
the left and result is added to R3 and placed in R1.
Also a register can hold number of times the operand2 must be shifted.
ADD R1, R2, R3, LSL R4
;R1¼ R2 þ R3 X 2R4, Number of times R3 to be shifted is in R4.
MOV R0, R1, LSL #3
;Shift R1 to the left three times and move the result to R0.
8.5.5
ARM Unconditional Instructions and Conditional
Instructions
Figure 8.10 shows the general format of an ARM instruction. ARM instruction
deﬁnes two types of instructions, namely:
1. Unconditional instruction
2. Conditional instruction
Condition code deﬁnes the type of instruction. If this ﬁeld is set to 1110, then the
instruction is an unconditional instruction, otherwise the instruction is a conditional
instruction. To use an instruction as a conditional instruction, the condition will
sufﬁx to the instruction. The sufﬁxes are:
Condition Code Condition
0000 EQ equal
0001 NE not equal
0010 CS carry set
0111 CC carry is clear
0100 MI negative (N ﬂag is set)
0101 PL positive (N ﬂag is zero)
0110 VS overﬂow set
0111 VC overﬂow is clear
1000 HI higher for unsigned number
1001 LS less than for unsigned number
1010 GT greater for signed number
1011 LT signed less than
Condition
Code
Instruction
31                  28  27
1
Fig. 8.10 General format of an ARM instruction
8.5
ARM Instructions
173

1100 GT Greater Than
1101 LE less than or equal
1110 AL unconditional instructions
1111 Unused code
The processor checks the condition ﬂag before executing the conditional instruc-
tion. If it matches with the condition instruction, then the processor executes the
instruction, otherwise skips the instruction.
ADDEQ R1, R2, R3 ;If zero ﬂag is set and it will execute this
instruction.
Example 8.10 Convert the following HLL to ARM assembly language.
If R1=R2 then
ADD R3, R4, R5
Endif
ARM assembly language for the above program would be:
CMP R1, R2
ADDEQ R3, R4, R5
Example 8.11 Convert the following HLL to ARM assembly language.
If R1 = R2 Then R3= R4-R5
Else
If R1&amp;amp;amp;amp;amp;gt;R2 Then R3=R4þR5
ARM assembly language for the above program would be:
CMP R1, R2
SUBEQ R3, R4, R5
ADDGT R3, R4, R5
8.6
ARM Data Processing Instruction Format
The instruction format is used by assembler to convert instruction to machine code;
Fig. 8.11 shows data processing instruction format.
174
8
Assembly Language and ARM Instructions Part I

Condition Code To determine if the instruction is a conditional or a unconditional
instruction,
I bit I¼0 means the operand2 is a register, I¼1 means the operand 2 is an
immediate value.
Op Code The OP Code determines types of instruction and followiong are the op
codes for data processing instructions
Instruction
Op Code
AND
0000
EOR
0001
SUB
0010
RSB
0011
ADD
0100
ADC
0101
SBC
0110
RSC
0111
TST
1000
TEQ
1001
CMP
1010
set condition by Op1-Op2
CMN
1011
set condition for Op1+ Op2
ORR
1100
MOV
1101
Rd=operand2
BIC
1110
MVN
1111
Rd= NOT operand2
S bit S ¼ 0 do not change ﬂag bits of PSR register, S ¼ 1 set condition ﬂags of PSR
register.
Rn Rn is ﬁrst operand, and it can be any of the 16 registers, R0 through R15.
Rd Rd is destination register, and it can be any of the 16 registers, R0 through R15.
Operand2 When I ¼ 0 the operand2 is a register and Fig. 8.12 shows operand2’s
format.
31            28      27  26     25   24
21  20   19                 16 15
12 11 
0
Cond 
0 0
I
Op code
S
Rn
RD
Operand 2
Fig. 8.11 Data processing instruction format
11                   7   6     5
4     3       0
#  shift
SH
0
Rm
Fig. 8.12 Operand2’s format when bit 4 is equal to 0
8.6
ARM Data Processing Instruction Format
175

# Shift To determine immediate value for number of times Rm must be shifted
SH To determine types of shift operation
Rm second operand
Operation SH value
LSL 00 Logical Shift Left
LSR 01 Logical Shift Right
ASR 10 Arithmetic Shift Right
ROR 11 Rotate Right
Example 8.12 Convert the following instructions to machine code.
ADD R1, R2, R3, LSL #3
31            28      27  26     25   24
21  20     19    16 15      12 11 
7  6   5        4     3          0
Cond 
1110
0 0
I
0
Op code
0100
S
0
Rn
0010
RD
0001
#Shift
0011
SH
00
0
RM
0011
When bit 4 of operand2 is set to 1, the number of times Rm must be shifted is in a
register.
Figure 8.13 shows format of operand2 of Fig. 8.11.
I=1: The operand 2 would have following format.
11
0
Immediate Value
11
8 7
6
5
4
3
0
RS
0
SH
1
Rm
Fig. 8.13 Format of Operand2 when bit 4 is equal to 1
176
8
Assembly Language and ARM Instructions Part I

8.7
Stack Operation and Instructions
Part of the memory is used for temporary storage is called stack; the stack pointer
holds the address of top of the stack as shown in Fig. 8.14.
The register R13 is assigned as stack pointer (SP), and the stack uses the
following instruction.
a. Push {condition} Rn : transfer the contains of Rn into stack
and add 4 to the stack pointer
Example 8.12 Assume the content of R3 is 0x01234567; Fig. 8.15 shows the
contents of Stack after executing push R3.
Example 8.14 Show contents of stack and SP in Fig. 8.16 after execution of Push
R4; assume R4 contains 0X5645321F.
Fig. 8.15 Shows contains
of stack after execution of
push R3
Fig. 8.14 Stack
architecture
8.7
Stack Operation and Instructions
177

POP Instruction: the POP instruction has following format
POP{condition} Rn
POP Rn: the pop instruction remove the word from top the stack and
store
it
into
register
rn
and
automatically
decrement
stach
pointer by 4
Example 8.15 Show the contents of stack and SP of Fig. 8.16 after execution POP
R0; the contents of R0 will be 0x1FAD7856 and stack will look like as in Fig. 8.17.
8.8
Branch (B) and Branch with Link Instruction (BL)
The Branch instruction has following general format.
B{condition} label
B label ; branch to location label.
BEQ label ; if ﬂag bit Z=1 then execute this instruction
BL Subroutine ;it will branch to subroutine and save contents of
PC (R15) to R14 (link register) for return from subroutine.
Fig. 8.16 Show stack after
push operation
Fig. 8.17 Contents of stack
after POP operation
178
8
Assembly Language and ARM Instructions Part I

Example 8.16 Write a subroutine to ﬁnd the value of Y ¼ 16X þ 4; assume R1
holds the Y and R2 holds X.
BL Funct
Funct SUB R1, R1, R1
ADD R1, R1, R2, LSL4
ADD R1, R!, #04
MOV R15, R14 ; Move return address to PC
8.8.1
B and BL Instruction Format
31         28 27              25   24     23               0
Cond
101
L
offset
L=0 means Branch and condition for branch can be set by Cond ﬁeld.
L=1 Mean Branch and Link
Instruction
B Branch always
BAL Branch Always
BEQ Branch if Equal
BNE Branch if Not equal
BPL Branch on positive
BMI Branch on negative
BCC Branch if carry ﬂag is clear
BLO Branch below for unsigned number
BCS Branch carry ﬂag is set
BHS Branch if higher for unsigned number
BVC Branch if Over ﬂow ﬂag is clear
BVS Branch if Over ﬂow ﬂag is clear
BGT Branch greater for signed number
BGE Branch greater or equal for signed number
BLT Branch Less than for signed number
BLE Branch Less than for signed number
BLS Branch less than or equal for unsigned number
Example
8.17 Rewrite
following
assembly
language
using
conditional
instructions.
8.8
Branch (B) and Branch with Link Instruction (BL)
179

CMP R1,R2
BEQ Exit
ADD R1, R2, R3
Exit:
SUB R1, R5, R6
By using conditional instructions, the above assembly language can be
represented by
CMP R1,R2
SUBEQ R1,R5,R6
ADDNE R1,R2,R3
8.9
Multiply (MUL) and Multiply-Accumulate (MLA)
Instructions
MUL instruction
MUL Rd, Rm,Rs ;Rd= Rm*Rs
MLA Multiply and Accumulate
MLA Rd,Rm,Rs, Rn ; Rd= Rm*Rs þRn
8.9.1
Multiply Instruction Format
31          28 27          22  21   20    19                 16  15          12 11 8   7             4   3             
0
Cond
00000
A
S
Rd
Rn
RS
1001
Rm
A=0 MUL instruction
A=1 MLA instruction
S=0 Do not change ﬂag bit
S=1 Set the ﬂag bits
Rd is destination register
Rs, Rm and Rn are the operands
180
8
Assembly Language and ARM Instructions Part I

8.10
Summary
•
The function of compiler is to convert the HLL to the assembly language.
•
The function of assembler is to convert the assembly language to the machine
code (binary).
•
The computer instruction is represented by mnemonic form such as “ADD.”
•
Each instruction may have one or two or three operands, ADD R1, R2, and R3
where R1, R2, and R3 are called operands.
•
ARM stand for Advanced RISC Machine and ARMv7 uses 32-bit and 16-bit
instruction.
•
ARMv7 contain 31 registers and only 16 registers R0 through R15 used by
programmer.
•
The Register R15 is used for the program counter (PC), R14 is used for the link
register (LR), and R13 is used for the stack pointer (SP).
•
The PSR register is used to store control bits (I, F, M, and T) and ﬂag bits (N, Z,
C, and V).
•
The ARM processor offers two types of instructions, and they are unconditional
and conditional instruction.
•
The instructions CMP, CMN, TST, and TEQ will set processor status register.
•
Part of the memory is used for the stack, and the stack pointer holds the address
of the top of the stack.
•
Chapter 9 covers more ARM instructions such as load, store, pseudo instruc-
tions, bits ﬁeld instructions, ARM addressing mode, and data representation in
the memory.
8.11
Problems and Questions
1. Explain how HLL converted to Machine code.
2. List types of instructions based on number of operands.
3. Which register of ARM processor is used for the program counter (PC)?
4. Which register of ARM processor is used for stack pointer (SP)?
5. Which register of ARM processor is used for link register?
6. What is contents of R5 after execution of following instruction, assume R2
contains 0X34560701 and R3 contains 0X56745670
(a) ADD R5, R2, R3
(b) AND R5, R3, R2
(c) XOR R5, R2, R3
(d) ADD R5, R3, #0x45
7. What are the contents of R1? Assume R2 ¼ 0x00001234.
(a) MOV R1, R2, LSL #4
(b) MOV R1, R2, LSR #4
8.11
Problems and Questions
181

8. What is the difference between these two instructions?
(a) SUBS R1, R2, R2
(b) SUB R1,R2, R2
9. Convert the following HLL language to ARM instructions.
IF R1>R2 AND R3>R4 then
R1= R1 þ1
Else
R3=R3 þR3*8
Endif
10. Convert the following HLL language to ARM instructions.
IF R1>R2 OR R3>R4 then
R1= R1 þ1
Else
R3=R3 þR5*8
Endif
11. Convert the following ﬂowchart to ARM assembly language.
12. Write a program to add ten numbers from 0 to 10 or convert the following C
language to ARM assembly language.
int sum;
int i;
sum = 0;
182
8
Assembly Language and ARM Instructions Part I

for (i = 10 ; i > 0 ; i - - ){
sum = sum þ1
}
13. Write a program to convert the following HLL to ARM assembly.
a= 10;
b=45;
while ( a! =b ) {
if (a < b)
a = a þ5;
else
b= bþ5;
}
SOLUTION:
14. Convert the following HLL to ARM assembly.
IF R1>R2 AND R3>R4 then
R1= R1 þ1
Else
R3=R3 þR5*8
Endif
15. Convert the following ﬂowchart to ARM assembly.
R5=R3-R4
R12=R10-R11
F
T
T
F
R5=R3+R4
If R5>R6
IF R1=R2
8.11
Problems and Questions
183

Chapter 9
ARM Instructions Part II
Objectives: After completing this chapter, you should be able to:
•
Explain the different types of load instructions.
•
List the different types of store instructions.
•
Distinguish the different types of ARM addressing mode.
•
List the ARMv7 pseudo instructions.
•
Learn the application of ADR and LDR instructions.
•
Explain the bit ﬁeld instruction operation.
•
Learn how the data are represented in memory.
9.1
Introduction
The data transfer instructions are used to transfer data from memory to registers and
from registers to memory. ARM processor used LDR and STR instructions to
access memory. LDR and STR able to use register indirect, pre-index addressing,
and post-index addressing to access memory. ARM offers several pseudo instruc-
tions which used by programmer and assembler to convert them to ARM
instructions.
9.2
ARM Data Transfer Instructions
Load Instructions (LDR). The LDR instruction is used to read data from memory
and store it into a register, and it has the following general format.
LDR[type]{condition} Rd, Address
Where “type” deﬁnes the following load instructions
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_9
185

LDR
Load 32 bits (word)
LDRB
Load 1 byte
LDRH
Load 16 bits (half word)
LDRS
Load signed byte
LDRSB
Load sign extension
LDRSH
Load signed half word
LDM
Load multiple words
Condition is an optional such as LDREQ load data if Z ﬂag ¼1 and Rd is
destination register.
Example 9.1 Assume R0 holds address 0000 and the following memory is given,
show the contents of R1 and R3 after executing following instructions.
Address
Contents
0
0X85
1
0XF2
2
0X86
3
0XB6
LDRH R1, R0
½

R1 ¼ 0x0000F285
LDRSH R3, R0
½

R3 ¼ 0xFFFFF285
9.2.1
ARM Pseudo Instructions
ARM supports multiple pseudo instructions; the pseudo instruction is used by the
programmer, and assembler converts the pseudo instruction to ARM instruction.
ADR Pseudo Instruction ADR is used to load the address of memory location
into a register and has the following format.
ADR Rd, Address
Example 9.2 The following instructions will read the address of data and then load
the data into register R3:
ADR R0, table
Move address represented by table
LDR R3, [R0]
R3 ¼ 0x23456780
Address
Data
Table
0x23456780
LDR Pseudo Instruction LDR pseudo instruction is used for loading a constant
into a register. In order to move a 32 bits contestant into a register, the instruction
MOV Rd, #value only can move 12 bits to the register Rd because the operand2 in
186
9
ARM Instructions Part II

instruction format for MOV is 12 bits. The LDR pseudo instruction has following
format.
LDR Rd, ¼ Value
Example 9.3 The following instruction will load the R1 with 0x23456789:
LDR R1 , ¼ 0x23456789
9.2.2
Store Instructions (STR)
The STR instruction is used to transfer contents of a register into memory and has
following general format.
STR[type]{condition} Rd, [address]
Where “type” deﬁnes the following instruction types
STR
Store 32 bits (word)
STRB
Store 1 byte
STRH
Store 16 bits (half word)
STM
Store multiple words
Example 9.4
STR R5, [R3]
Store contents of R5 into the memory location that R3 holds the
address; R3 is the base register.
9.3
ARM Addressing Mode
•
The ARM processor support ARM offers several addressing modes and they are
pre-indexed, pre-indexed with immediate offset, pre-indexed with register off-
set, pre-index with scaled register, pre-index with register offset and write back,
post-index with immediate offset, post-index with register offset, and post-index
with scaled register offset; the following table shows a summary of ARM
addressing modes.
Addressing mode
Assembler syntax
Effective address (EA)
Immediate
MOV R1, #0X25
Data is part of
instruction
Pre-indexed
[Rn]
EA ¼ Rn
Pre-indexed with immediate offset
[Rn, # offset]
EA ¼ Rn þ offset
Pre-indexed with register offset
[Rn,  Rm]
EA ¼ Rn  Rm
Per-index with scaled register
[Rn, Rm, Shifted]
EA ¼ RN þ Rm
shifted
Pre-indexed with an immediate offset and write
back
[Rn, offset]!
EA ¼ Rn þ offset
Rn ¼ Rn þ offset
(continued)
9.3
ARM Addressing Mode
187

Addressing mode
Assembler syntax
Effective address (EA)
Pre-index with register offset and write back
[Rn,  Rm,]!
EA ¼ Rn  Rm
Rn ¼ Rn  Rm
Pre-index with scaled register offset and write
back
[Rn, Rm, Shifted]!
EA ¼ Rn  Rm shifted
Rn ¼ Rn  Rm shifted
Post-index with immediate offset
[Rn], offset
EA ¼ Rn
Rn ¼ Rn þ offset
Post-index with register offset
[Rn],  Rm
EA ¼ Rn
Rn ¼ Rn  Rm
Post-index with scaled register offset
[Rn],  Rm. SHL
#n
EA ¼ Rn
Rn ¼ Rn  Rm shifted
9.3.1
Immediate Addressing
In immediate addressing, the operand is part of instruction such as
MOV R0, # 0x34
or
ADD R1, R2, 0x12
9.3.2
Pre-indexed
In pre-index addressing mode represented by [Rn], the effective address (EA) is
contents of Rn such as
LDR R2, [R3]
Pre-indexed with Immediate Offset
Pre-indexed with immediate offset is represented by [Rn, #offset] such as
LDR R0, [Rn, #Offset]
The offset is an immediate value such as
LDR R1, Rn; #0x25
½

EA ¼ R2 þ 0x25
Pre-indexed with Register Offset
The offset can be register or register with shift operation:
LDR R0, R1; R2
½

EA ¼ R1 þ R2
188
9
ARM Instructions Part II

Example 9.5 What is the effective address of following address? Assume R5
contains 0X00002345
[R5, #0x25]
EA ¼ 0x000002345 þ 0X25 ¼ 0x0000236A
Example 9.6 What is effective address of following pre-index addressing, assume
R5 ¼ 0x00001542 and R2 ¼ 0X00001000
[R5, R2]
EA ¼ R5 þ R2 ¼ 0X00001542 þ oX00001000 ¼ 0X00002542
Pre-indexed with Scaled Register
The offset contains register with shift operation:
LDR R0, [Rn , R2 , LSL#2]
Example 9.7 What is EA of following instruction?
LDR R0, [Rn , R2 , LSL#2]
EA ¼ Rn þ R2 * 4
R2 shifted to the left twice (multiply by 4) and added to Rn.
9.3.3
Pre-indexed with Write Back
The general format for pre-index addressing with write back is
[Rn, Offset]!
The exclamation (!) character is used for write back; the offset can be immediate
value or register or shifted register:
EA ¼ Rn þ offset and Rn ¼ Rn þ offset
Pre-index with Immediate Offset and Write Back
LDR R0, [R1,# 4]!
EA ¼ R1 þ 4 and R1 updated by R1 ¼ R1 þ 4.
Example 9.8 What is the effective address and ﬁnal value of R5 for following
instruction? Assume the contents of R5 ¼ 0x 00002456:
LDR R0, R5; #0X4
½
!
EA ¼ R5 þ 0x4 ¼ 0x000245A
R5 ¼ R5 þ 0x4 ¼¼ 0x000245A
9.3
ARM Addressing Mode
189

Pre-index with Register Offset and Write Back
LDR R0, R1; R2
½
!
EA ¼ R1 þ R2
R1 ¼ R1 þ R2
Example 9.9 What is the effective address and ﬁnal value of R5 of following
instruction? Assume the contents of R5 ¼ 0x 00002456 and R2 0X00002222:
LDR R0, [R5, R2]!
EA ¼ R5 þ R2 ¼ 0x00004678
R5 ¼ R5 þ R2 ¼ 0x00004678
Pre-index with Scaled Register Offset and Write Back
LDR R1, [Rn, R2, LSL#2]!
EA ¼ Rn þ R2∗4
Rn ¼ Rn þ þR2∗4
9.3.4
Post-index Addressing
The general format of post-index addressing is
LDR R0, [Rn], offset
Offset can be immediate value or register or shifted register.
Post-index with an Immediate Value
LDR R0, [Rn], #4
Effective address ¼ Rn and Rn ¼ Rn þ 4
Post-index with Register Offset
LDR R0, Rn
½
, Rm
Effective address ¼ Rn and Rn ¼ Rn þ Rm
Post-index with Scaled Register Offset
LDR R0, Rn
½
, Rm, SHL#4
Effective address ¼ Rn and Rn ¼ Rn þ Rm∗16
190
9
ARM Instructions Part II

9.4
Swap Memory and Register (SWAP)
The swap instruction combines the load and stores instructions into one instruction,
and it has following format.
SWP Rd, Rm, [Rn]
The register Rd is destination register, Rm Swap memory and register (SWAP)
is the source register, and Rn is base register.
The swap instruction performs following functions.
Rd  memory [Rn] Load Rd from memory location [Rn]
[Rn]  Rm store the contents of Rm in memory location [Rd]
SWPB Rd, Rm, [Rn]
Swap one byte
9.5
Bits Field Instructions
ARM offers two bit ﬁeld instructions and they are bit ﬁeld clear (BFC) and bit ﬁeld
insertion (BFI).
9.5.1
BFC (Bit Field Clear Instruction)
BFC has following general format.
BFC {cond} Rd, # lsb, #width
Rd is destination register.
lsb determines start of bit position in the source register (Rd) to be clear.
Width determines number of bits to be clear from lsb to msb of the Rd register.
Example 9.10 Write an instruction to clear bits 7 through 15 of register R4;
assume R4 contains 0xFFFEFEFE.
BFC R4, #7, #8 clear bit 7 through bit 15 (8 bits) of register R4.
The initial value in R4 is.
After clearing bit 7 through 15 of R4 results.
9.5
Bits Field Instructions
191

9.5.2
BFI (Bit Insertion Instruction)
Bit insertion is used to copy a set of bit from one register Rn into register Rd starting
from lsb of Rd; BFI has following format.
BFI{cond} Rd, Rn, #lsb, #width
Rd is destination Reg.
Rn is source register.
#lsb starting bit from Rn.
#width number of bit starting from lsb of Rn.
Example 9.11 Copy 8 bits of R3 starting from bit 4 to R4; assume R3 contains 0x
FFFFEBCD and R4 contains 0xEE035007.
BFI R4, R3, #4, #8, and this instruction will copy 8 bits from B4 to B11 of R3
into B0 through B7 of R4, the initial value of R3 in binary.
11101110000000 11010100000000111
The initial value of R4 in binary is
1110 1110 0000 0011 0101 0000 0000 0111
The instruction will copy 8 bits from bit 4 of R3 into R4 starting from bit 0 of R4.
9.6
Data Representation and Memory
ARM processors deﬁne a word as 4 bytes and a half word as 2 bytes. Data can be
represented in the form of hexadecimal, decimal, and binary.
(a) Decimal numbers, such as 345
(b) Hexadecimal numbers, such as 0x2345, where “x” represents hexadecimal
192
9
ARM Instructions Part II

(c) Binary or base 2, such as 2_10111100
Memory holds data and code. Figure 9.1 shows a block diagram of memory. The
address of memory deﬁnes the location of the data, where each location of ARM
processor memory holds one byte. In assembly language, a label, as shown in
Fig. 9.2, represents the address of memory.
Figure 9.2 shows how each memory location holds one byte. Storing two bytes
(half word) of data, such as 0x4563, can be stored two different ways called Big
Endian and Little Endian.
Big Endian. In Big Endian the most signiﬁcant byte (MSB) of data is stored ﬁrst in
memory. In Fig. 9.3, 45 is the most signiﬁcant byte, and 63 is the least signiﬁcant
for the number 0x4563.
The ARM 7 operates in Big and Little Endian; each memory location of ARM7
holds one byte and a word (4 bytes) can be stored in memory in two different ways:
Big Endian and Little Endian.
Big Endian. In Big Endian the most signiﬁcant byte of a word is stored at the
lowest address.
Example 9.12 The 0x34569312 may be stored in Big Endian form as shown in
Fig. 9.3.
List
23
List+1
4A
List+2
56
List+3
F5
Fig. 9.2 Memory with the
labeling address
00
01
10
11
23
4A
56
F5
Fig. 9.1 Memory with the
binary address
Fig. 9.3 Big Endian
representation of hex
number 34569312
9.6
Data Representation and Memory
193

Little Endian. In Little Endian the least signiﬁcant byte of a word is stored at the
lowest address.
Example 9.13 Hex number 34569312 may be stored in Little Endian form as
shown in Fig. 9.4.
9.7
Summary
•
ARM instruction uses LDR and STR to read and write to memory.
•
The load instruction can be used to load one byte (LDRB), load 2 bytes (LDHB),
and load 4 bytes (LDR).
•
LDRSB (load signed extension) is used to load one byte and extended the sign of
the data.
•
LDRSH (load signed extension) is used to load two bytes and extended the sign
of the data.
•
The ARM pseudo instructions are ADR (load address of memory location) and
LDR (load a 32 bit value into a register).
•
ARM processor store instructions are STR (store one word), STRB (store one
byte), and STRH (store half word).
•
ARM offers several addressing modes and they are pre-indexed, pre-indexed
with immediate offset, pre-indexed with register offset, pre-index with scaled
register, pre-index with register offset and write back, post-index with immedi-
ate offset, post-index with register offset, and post-index with scaled register
offset.
•
Data can be represented in memory in the form of Big Endian and Little Endian.
•
In Big Endian the most signiﬁcant byte of a word is stored at the lowest address.
•
In Little Endian the least signiﬁcant byte of a word is stored at the lowest
address.
•
Chapter 10 covers how to use Keil development tools and run and debug a
program, programming rules, directives, and a sample program.
Problem
1. Trace following instructions; assume list starts at memory location 0x0000018
and using ARM Big Endian:
ADR R0, LIST
; Load R0 with address of memory location list
MOV R10, #0x2
(a) LDR R1, [R0]
(b) LDR R2, [R0, #4]!
Fig. 9.4 Little Endian
representation of hex
number 34569312
194
9
ARM Instructions Part II

(c) LDRB R3, [R0], #1
(d) LDRSB R5, [R0], #1
(e) LDRSH R6, [R0]
LIST DCB
0x34, 0xF5, 0x32, 0xE5, 0x01, 0x02, 0x8, 0xFE
2. Work problem #1 part A and B using Little Endian.
(a) R1 ¼ 0xE532F534
(b) R2 ¼ 0xFE080201
3. What is contents of register R7 after execution following program?
ADR R0, LIST
LDRSB R7, [R0]
LIST DC 0xF5
4. What are the contents of register Ri for the following load Instructions? Assume
R0 holds the address of list using Little Endian.
(a) LDR R1, [R0]
(b) LDRH R2, [R0]
(c) LDRB R3, [R0], #1
(d) LDRB R4, [R0]
(e) LDRSB R5, [R0], #1
(f) LDRSH R6, [R0]
List DCB
0x34, 0xF5, 0x32, 0xE5, 0x01, 0x02
5. The following memory is given, show the contents of each register, and assume
R1 ¼ 0x0001000 and R2 ¼ 0x00000004 (use Little Endian).
(a) LDR
R0, [ R1]
(b) LDR
R0, [R1, #4]
(c) LDR
R0, [R1, R2]
(d) LDR
R0, [R1, #4]!
1000
23
13
56
00
1004
45
11
21
88
1008
03
08
35
89
100C
44
93
9.7
Summary
195

6. What are the effective address and contents of R5 after executing following
instructions? Assume R5 contains 0x 18 and r6 contains 0X00000020.
(a) STR
R4, [R5]
(b) STR
R4, [R5, #4]
(c) STR
R4, [R5, #8]
(d) STR
R4, [R5, R6]
(e) STR
R4, [R5], #4
196
9
ARM Instructions Part II

Chapter 10
ARM Assembly Language Programming Using
Keil Development Tools
Objectives: After completing this chapter, you should be able to:
•
Explain the function development tool.
•
Explain the function of cross-assembler.
•
List several development tools for running assembly language program.
•
Install the Keil development tools.
•
Run and debug a program.
•
Use program template to write you own program.
•
Learn programming rules.
•
Represent data in memory for an assembly language program.
•
Learn the application of directives.
•
Distinguish the different types of data directives.
•
Run a step-by-step program and observe the contents of each register.
10.1
Introduction
Processor manufacturers publish documentation that contains information about
their processors, such as lists of registers, the function of each register, size of the
data bus, size of the address bus, and a list of the instructions that can be executed.
Each CPU has a known instruction set that a programmer can use to write assembly
language programs. Instruction sets are speciﬁc to each type of processor. For
example, Pentium processors implement a different instruction set than ARM
processors. Programs written using the instruction set of a processor are said to
be written in assembly language. The function of an assembler is to convert
assembly language to machine code (binary) that the CPU can execute.
When an assembler runs on one processor but can assemble instructions for a
different processor with a different instruction set it is called a cross-assembler.
Processor simulators are a key development tool, since they allow for a controllable
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1_10
197

test environment in a setting such as a Windows or Linux workstation. They may
also facilitate the transfer or download of the program to the target processor. The
following development tools are some which support ARM processors:
1. ARM Keil Microcontroller Tools (www.keil.com)
2. IAR Embedded Workbench (www.iar.com)
3. GNU ARM Assembler (www.gnu.org)
10.2
Keil Development Tools for ARM Assembly
For the examples in this book, Keil μVision® IDE (integrated development
environment) from Keil’s Microcontroller Development Kit (MDK) version 5
is used. A free version of this software can assemble and simulate the execution of
ARMv7 instructions provided the size is under 32 K. The download is available
from Keil’s website: http://www.keil.com.
When ﬁrst installed, a dialog titled Pack Installer may open after the installer
has ﬁnished. This utility assists the user in downloading and installing environ-
ments for μVision to enable the simulation of different boards and devices. By
default, however, several device templates come pre-installed with μVision
(Fig. 10.1).
•
To get started, open μVision and select Project ! New μVision Project. . ..
•
Name your project and choose a location to save it in.
After saving, a dialog will open and prompt you to Select Device for Target
“Target 1”. . .. Depending on whether or not you have installed any additional
packs from the Pack Installer, this screen may look different. Several ARM
processors are included with the default installation. For the examples in this
book, the ARM Cortex M3 (ARMCM3) was selected.
•
Select ARM Cortex M3 ! ARMCM3 and press OK. (Fig. 10.2)
For each processor, μVision has several libraries available. Some are essential,
such as start-up conﬁguration, while others are optional extensions to enable
Fig. 10.1 Creating a new project in Keil μVision® IDE v5.22
198
10
ARM Assembly Language Programming Using Keil Development Tools

broader functionality, such as Ethernet drivers and Graphics interfaces. To run
simple ARMv7 assembly programs, only the start-up component is needed.
•
Select CMSIS ! CORE and hit OK. (Fig. 10.3)
Now, you should have a blank project open in the Project pane, which by default
is on the left side of the window, under the Menu bar. Next, the project needs to be
conﬁgured to use the simulator to run the programs.
Fig. 10.2 Selecting the ARM Cortex M3 processor
Fig. 10.3 The CORE library to run the ARMCM3 processor
10.2
Keil Development Tools for ARM Assembly
199

•
Right click on the Target 1 folder and select Options for Target “Target 1”. . .
(Fig. 10.4)
•
Click on the Debug tab and select Use Simulator. (Fig. 10.5)
•
Click on Target and select Use MicroLIB as shown in Fig. 10.6
•
Add a new item to the project by right click the Source Group 1 folder in the
project pane as Fig. 10.7
•
Create a new assembler source ﬁle (Asm ﬁle or .s), name it, and then save it as
shown in Fig. 10.8
Assembly programs follow a certain structure and have what are called direc-
tives. These will be explained later on in the chapter, but they instruct the assembler
on how to structure much of the ﬁnal program. Much like many high-level language
programs run inside of a main “function” or “method,” the following example uses
the routines __Vectors and Reset_Handler (which are called by default by the
processor we selected).
Example 10.1 This program reads two numbers and stores the sum in R3 as shown
Fig. 10.9.
Fig. 10.4 Changing the project conﬁguration
200
10
ARM Assembly Language Programming Using Keil Development Tools

10.2.1
Assembling a Program
Once source code is ready to be assembled, you may have the assembler attempt to
translate and execute the program in the simulator. The ﬁrst step is to create the
assembly program by having the assembler translate your source code. There are
both keyboard shortcuts and menu buttons to do so. Both of the options listed below
are available on the menu bar as shown in Fig. 10.10.
•
F7 will build all target ﬁles (e.g., All source ﬁles in Target 1).
•
Ctrl þ F7 will build the currently active ﬁle (e.g., The ﬁle being modiﬁed).
The Build Output panel on the bottom of the window will show any errors,
warnings, or if the project was built successfully. A successful build should look
like Fig. 10.11, whereas a failure will give error descriptions to help the program-
mer ﬁnd where the code is incorrect.
Fig. 10.5 Setting the project to use the simulator
10.2
Keil Development Tools for ARM Assembly
201

Fig. 10.6 Options for Target1 (Use Micro LIB)
Fig. 10.7 Adding an item to the project
202
10
ARM Assembly Language Programming Using Keil Development Tools

Fig. 10.8 Create the assembly source ﬁle
Fig. 10.9 Source code for Example 10.1
10.2
Keil Development Tools for ARM Assembly
203

10.2.2
Running the Debugger/Simulator
Now that you have compiled a piece of code, you will want to debug the code for
testing. To start the debugger, click on Debug ! Start/Stop Debug Session from
the menu bar as shown in Fig. 10.12. (μVision may prompt a warning that it is
running in evaluation mode – if so, simply press OK.)
Fig. 10.10 Buttons used to assemble program
Fig. 10.11 Build Output for a successful assembly
204
10
ARM Assembly Language Programming Using Keil Development Tools

By default, the registers will be displayed in the Registers pane on the left side. If
you click the “þ” next to the xPSR line, you can view the current ﬂag bits – this is
the Program Status Register (PSR).
The Disassembly pane will display some of the current data, such as the machine
code instructions and notes of what line in the source code is being executed, and at
what memory address.
To run the program, you may use the following buttons/keypresses (Fig. 10.13):
•
Reset – Reset the CPU and restart the program.
•
Run (F5) – Run the entire program until the next breakpoint (if set).
•
Stop – Stop the currently executing code.
•
Step (F11) – Execute the current instruction line.
•
Step Over (F10) – Execute a single step over a function.
•
Step Out (Ctrl þ F11) – Finish the current function and stop.
•
Run to Cursor Line (Ctrl þ F10) – Execute the program until it reaches the
current cursor line.
Fig. 10.13 Location of Debug Menu buttons
Fig. 10.12 Starting/stopping the debugger
10.2
Keil Development Tools for ARM Assembly
205

Example 10.2 Running the code from Fig. 10.8.
•
First, retype the code exactly as shown in Fig. 10.8.
•
Assemble the code by saving the ﬁle (
or Ctrl þ S) then pressing F7 (or
)
to translate the assembly language ﬁle into machine code. The Build Output
panel should look like Fig. 10.11.
•
Run the simulator/debugger by pressing Ctrl þ F5 or
under the Debug
menu. Press OK if the EVALUATION MODE prompt appears.
•
Press F11 or
to “step” one line and execute an instruction, and watch the
changes in each panel. While debugging, the simulator will highlight the cur-
rently running or modiﬁed data. See Fig. 10.14 for an example which should
resemble your screen after the ﬁrst “step.” This will execute our ﬁrst bit of code,
MOV R1, #Q, and store the value of Q (6) into register R1.
– μVision’s debugger will highlight the next instruction in the source code
(MOV R2, #P), the modiﬁed registers (R1, R15), and show in the
Fig. 10.14 The debugger automatically highlights the most relevant information
206
10
ARM Assembly Language Programming Using Keil Development Tools

Disassembly pane the machine code and memory address of the instruction
with a label of the original assembly code.
•
Continue to “step” through the code, pressing F11 or the step button each time
until the program has executed. Watch the changes in each register at each step.
Another way to observe the functionality of your program is to view the current
memory. All of the instructions translated from source code and predeﬁned data are
stored in memory. The Disassembly pane will display an instruction 32-bit hexa-
decimal address in memory next to each instruction, for example.
To view the current values in memory while debugging, open the Memory
1 panel in the bottom right corner (Fig. 10.15). Up to four windows are available,
and by default Memory 1 should be enabled. If it is not, it may be enabled under the
Menu bar by clicking View ! Memory Windows ! Memory 1. (An enabled
window will have this icon next to it:
).
To search memory, enter the hexadecimal address of the portion of memory you
would like to view. Since it is a byte-addressable processor, each address holds one
byte of information, and is displayed as two hexadecimal digits.
Fig. 10.15 Location of the Memory window and panel tab
10.2
Keil Development Tools for ARM Assembly
207

10.2.3
Program Template
Figure 10.16 contains a sample template of code to write a program for the ARM
Cortex M3. The source code located between the Reset_Handler and STOP label is
executed when the program is run. (All labels must have no whitespace like spaces
or tabs on the left – they must be the ﬁrst text in the column, and the ﬁrst characters
on the line.)
10.3
Programming Rules
CASE Rules Instructions, symbols, and labels can be written in uppercase or
lowercase but cannot be combined (e.g., MOV or mov is correct, but MoV or moV
is not).
Comments The programmer can write comments after a semicolon (;)
MOV R1, R2; Moving contents of R2 to R1
Fig. 10.16 Program template for ARMCM3 processor in Keil μVision v5
208
10
ARM Assembly Language Programming Using Keil Development Tools

10.4
Data Representation and Memory
ARM processors deﬁne a word as 4 bytes and a half word as 2 bytes. Data can be
represented in the form of hexadecimal, decimal, and binary numbers (Fig. 10.17).
Data and code are held in memory. Figure 10.18 shows a block diagram of
memory. The address deﬁnes the location of the data in memory. Each location of
an ARM processor’s memory holds one byte. In assembly language, a label – as
shown in Fig. 10.14 – represents the address in memory for the data. When the code
is translated, the assembler automatically decides what address to use in place of the
label and substitutes it where appropriate in the program.
Since each memory location holds one byte, the programmer must be careful
when working with words and half words. Processors can function with either Big
Endian or Little Endian ordering. Figure 10.19 shows the number 0x2000000F
stored at 0x400 in both systems.
•
The ARM Cortex M3 used for these examples is a Little Endian processor.
10.5
Directives
A directive is an assembler command that is executed by the assembler. Directives
never produce any machine code. Directives are used to indicate the start of code or
data and the end of the program. A simple directive is END, which marks the end of
Base
Prefix
Example
Decimal (10)
-
17
Hexadecimal (16)
0x
0x11
Binary (2)
2_
2_00010001
Fig. 10.17 Numerical representation formats
Label
Data
Memory Address
Data
List
0x23
0x400
0x23
List+1
0x4A
0x401
0x4A
List+2
0x56
0x402
0x56
List+3
0xF5
0x403
0xF5
Fig. 10.18 Block diagram of memory if List is stored at address 0x400
Big Endian
Little Endian
0x400
0x20
0x0F
0x401
0x00
0x00
0x402
0x00
0x00
0x403
0x0F
0x20
Fig. 10.19 Big vs. Little
Endian
10.5
Directives
209

a program. Some of the most useful directives used by the ARM Assembler are as
follows:
•
AREA – deﬁnes a segment of memory
•
ENTRY – deﬁnes the start of the program
•
EQU – used to assign a constant to a label
– X EQU 6
– MOV R1, #X ; R1 ¼ #6
10.5.1
Data Directive
Data directives deﬁne the types and size of data.
•
DCB (Deﬁne Constant Byte)
•
DCW (Deﬁne Constant Half Word)
•
DCD (Deﬁne Constant Word)
•
SPACE (Reserve a zeroed block of memory)
DCB (Deﬁne Constant Byte). This directive is used for allocating one or more
bytes in memory.
•
list1 DCB 0xF,10,2_00010001
– list1 : 0x0F
– list1 þ 1: 0x0A
– list1 þ 2: 0x11
DCW (Deﬁne Constant Half Word). This directive deﬁnes constant half
words (16 bits, 2 bytes) and requires two memory locations per half word.
•
list1 DCW 0xFF00, 0x13
– list1 : 0x00
– list1 þ 1: 0xFF
– list1 þ 2: 0x13
– list1 þ 3: 0x00
DCD (Deﬁne Constant Word) DCD is used to deﬁne a word (32 bits, 4 bytes)
and requires four memory locations per word.
•
list1 DCD 0x12345678, 0xFF
– list1
: 0x78
– list1 þ 1: 0x56
– list1 þ 2: 0x34
– list1 þ 3: 0x12
– list1 þ 4: 0xFF
– list1 þ 5: 0x00
– list1 þ 6: 0x00
– list1 þ 7: 0x00
210
10
ARM Assembly Language Programming Using Keil Development Tools

Character Strings. A sequence of characters is called a character string. In
ARM assembly, strings must be null-terminated in that they must end with a
0 value when they are deﬁned.
•
List1 DCB “Assembly”,0
•
List2 DCB “I have $250”,0
The assembler breaks the string into bytes and stores them each in Little Endian
order.
Single Character. When storing a single character in a register or memory
location, the character must be inside single quotation marks. The assembler
converts the ASCII to hexadecimal.
•
List DCB ‘A’
SPACE. Reserves memory locations for later use.
•
List SPACE 20
– Reserves 20 bytes of memory starting at List.
10.6
Memory in μVision v5
Memory in μVision is simulated, and the program tries to replicate real-world
conditions. Many microprocessors use a combination of ROM (read-only memory)
and RAM and will have a program stored in ROM to respond to a power-up, reboot,
or other situation where RAM will not be propagated or reliable.
To do this, memory is marked as none, some, or all of the following permission
ﬂags:
•
Exec – Memory holds instructions and can be executed.
•
Read – Memory can be read.
•
Write – Memory can be written to.
By default, the area in memory that most directives will store their data in is
marked as both exec and read, but not write. This mimics ROM since the instruc-
tions stored there can be read and run, but attempts to write to those locations (with
STR or similar) will not work. The assembler is also unlikely to notify you of this
result.
Example 10.3 What are the contents of list1 after execution, if stored in ROM?
ADR R0, list1 ;store the address of list1 in R0
MOV R1, #2 ;store 2 in R1
LDRB R2, [R0] ;load the byte at list1 into R2
10.6
Memory in μVision v5
211

ADD R3, R1, R2 ; R3 R1þR2 (0þ2 = 2)
STRB R3, [R0] ;store R3 (#2) at list1
List1 = 0x00
While μVision and ARM source libraries allow for programs to more easily
utilize data stored in RAM rather than ROM, it goes beyond the scope of this
chapter. However, knowing what addresses are marked as read and write, you can
still use RAM to store data into memory.
By default, for the ARMCM3 processor, memory locations 0x20000000 –
0x20020000 are marked as read and write RAM in μVision.
Example 10.4 What are the contents of memory at 0x200000000 after the execu-
tion of these instructions?
list1 DCB 0x0
ADR R0, list1 ; store the address of list1 in R0
MOV R1, #2 ;store 2 in R1
LDRB R2, [R0] ;load the byte at list1 into R2
ADD R3, R1, R2 ; R3 R1þR2 (0þ2 = 2)
MOV R4, #0x20000000 ; store our initial RAM address in R4
STRB R3, [R4] ;store R3 (#2) at 0x20000000
List1 = 0x00
0x20000000 0x02
10.7
Summary
•
The simulation of a processor which run on different processor is called cross-
assembler.
•
There are several development tools for the ARM processor such Keil, IAR,
and GNU.
•
The ARM instructions and labels can be written in uppercase or lower case but
cannot combined.
•
The ARM processor deﬁnes word as 4 bytes, half word as two bytes, and they
can be represented in binary (2_1000011), hex (0x24), or decimal 45.
•
The data directives are DCB (Deﬁne Constant Byte), DCW (Deﬁne Constant
Half Word), DCD (Deﬁne Constant Word), and SPACE (reserved a zeroed block
of memory).
212
10
ARM Assembly Language Programming Using Keil Development Tools

•
The DCB is used to represent one byte in memory location such as
LIST DCB 0x32
•
The DCW is used to represent half word in memory location such as
LIST DCW 0x3245
•
The DCD is used to represent a word in memory location such as
LIST DCD 0x87673245
•
The SPACE directive is used to reserve memory location with zero values in all
of the locations such as
LIST SPACE 20
•
The character string must be terminated by null (0) such as
List DCB “WELCOME”, 0
•
The single catheter in a memory location must be inside of single quotations
such as
List DB ‘A’
Problems
1. Write a program to add elements of List1 and store in the List2.
List1
DCB 0x23, 0x45, 0X23, 0x11
List2
DCB 0x0
2. Write a program to ﬁnd the largest number and store it in memory location List3.
List1
DCD
0x23456754
List2
DCD
0X34555555
List3
DCD
0x0
3. Write a program, ﬁnd the sum of data in memory location LIST, and store the
SUM in memory location sum using loop.
List
DCB
0x23, 0x24, 0x67, 0x22, 0x99
SUM
DCD
0x0
4. Show the content of registers R1 through R5 after execution of the following
program:
AREA
NAME, CODE, READONLY
EXPORT SystemInit
EXPORT __main
10.7
Summary
213

ENTRY
SystemInit
__main
AREA Directives, CODE, READONLY
ENTRY
ADR R0, LIST1
LDRB R1, [R0]
LDRB R2, [R0, #1]!
LDRB R3, [R0,#1]!
LDRB R4, [R0,#1]!
LDRB R5, [R0,#1]
List
DCB
0x23, 0x24, 0x67, 0x22, 0x99
align
END
5. Write assembly language to clear bit position 0, 3, 5, and 6 of R12; the other bits
must be unchanged (using ARM instruction).
Solution:
LDR
R1, #0x00000069
BIC
R12, R12, R1
6. Write assembly language program for the following HLL:
IF R1 = R0
Then
ADD R3, R0, #5
Else
SUB R3, R0, #5
7. Write a program to read memory location LIST1 and LIST2 and store the sum in
LIST3.
LIST1
DCD 0x00002345
LIST2
DCD 0X00011111
LIST3
DCD 0x0
8. Write a program to multiplying two numbers using subroutine.
9. Write a program to add eight numbers using Indirect addressing.
214
10
ARM Assembly Language Programming Using Keil Development Tools

LIST DCB 0x5, 0x2,0x6,0x7 ,0x9,0x1,0x2,0x08
10. Write a program to add eight numbers using Post-index addressing.
LIST DCB 0x5, 0x2,0x6,0x7 ,0x9,0x1,0x2,0x08
11. Write a program to convert the following HLL language to ARM instructions.
IF R1=R2 AND R3>R4 then
R1= R1 +1
Else
R3=R3 +R3*8
Endif
12. What are the contents of R4 after execution of the following program.
__main
LDR R1, =0xFF00FF
ADR R0, LIST1
LDR R2, [R0]
AND R4, R2, R1
LIST1
DCD 0X45073487
13. Write a program to convert the following HLL to assembly language.
If R1=R2 then
R3= R3+1
IF R1<R2 Then
R3=R3-1
If R1>R2 Then
R3=R3-5
10.7
Summary
215

14. Write a subroutine to calculate value of Y where Y ¼ X*2 + x + 5, assume x is
represented by
LIST DCB 0x5
LIST1 DCB
0x5
15. Write a program to rotate R1 16 times; assume R1 contains 0x12345678.
16. Write a program to compare two numbers and store largest number in a
memory location LIST.
M1
EQU
5
N1
EQU
6
LIST2 DCB
0x0
17. Write a program to read a word memory location LIST and clear bit position B4
through B7 of register R5; assume R5 contains 0XFFFFFFF.
LDR R0, =0x000000F0
LDR R5, =0xFFFFFFFF
18. Write program to load Register R1, R2, R3, and R4 from memory location
LIST
LIST DCD
0x12345AAA, 0x0000BBBB, 0x0000CCCC, 0X00000DDD
216
10
ARM Assembly Language Programming Using Keil Development Tools

Appendix: Digital Design Laboratory
Experiments Using LOGISIM
Chapter 1: Problems and Questions
2. List three computer output devices.
Monitor, speaker, printer
4. Show a digital signal.
(a) Byte ¼ 8 bits
(b) Half word ¼ 16 bits
(c) Word ¼ 32 bits
6. Convert the following decimal numbers to binary:
(a) 35 ¼ 1000011
(b) 85 ¼ 1010101
(c) 23.25
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1
217

23 ¼ 10111
0.25 * 2 ¼ 0.5
a 1 ¼ 0
0.5 * 2 ¼ 1.0
a 2 ¼ 1
23.25 ¼ 10111.01
8. Convert the following binary numbers to hexadecimal:
(a) 1110011010 ¼ 39 A
(b) 1000100111 ¼ 227
(c) 101111.101 ¼ 101111.1010 ¼ 2F.A
10. The following frequencies of digital signals are given; ﬁnd the clock cycle of
digital signal:
(a) 10 Hz T ¼ 1/F ¼ 1/10 ¼ 0.1 second
(b) 200Hz T ¼ 1/F ¼ 1/200 ¼ 0.005 second
(c) 10000 Hz T¼1/10000 ¼ 0.1 milliseconds
(d) 4 MHz T ¼ 1/ 4 *106 ¼ 0.25 *106 ¼ 0.25 microseconds
12. Convert the following decimal number to base 16:
(a) (234)10 ¼
Quotient
Remainder
234/16 ¼
14 10 ¼ A in hex ¼ a0
14/16 ¼
0
14 ¼ E in hex ¼ a1
(a1 a0)16 ¼ (EA)16
(b) (75)10 ¼
Quotient
Remainder
75/16
4
11 ¼ (B)16
4/16 0
4¼ (4)16
(c) (75)10 ¼ (4B)16
14. Find two’s complements of the following numbers:
(a) 11111111
Two’s complement of a number ¼ complement of the number þ1
11111111 ¼ 00000000 þ1 ¼ 00000001
(b) 10110000 ¼ 01001111 þ1 ¼ 01010000
(c) 10000000 ¼ 01111111 þ1 ¼ 10000000
(d) 00000000 ¼ 1111111 1þ1 ¼ 0000000
16. Represent (465)10 in BCD.
(0100 0110 0101)BCD
18. Represent (110010000100) BCD in decimal.
Invalid number
218
Appendix: Digital Design Laboratory Experiments Using LOGISIM

20. Subtract the following unsigned numbers using two’s complement:
(a) 11110011 – 11000011
Add minuend to the two’s complement of subtrahend.
1. Two’s complement of 11000011 ¼ 00111100 þ1 ¼ 00111101
2. Add the result of step 1 to the minuend.
11110011
þ 00111101
----------------
100110000
Adding the two 8 bits results in 9 bits, the most signiﬁcant called carry;
discard the carry, and the result is positive þ 00110000.
(b) 10001101 – 11111000
Two’s complement of 11111000 ¼ 00000111 þ1 ¼ 00001000
10001101
þ00001000
-----------------
10010101 – adding two 8 bits results in 8 bits; take two’s complement of
sum, and the result is negative.
Two’s complement of 10010101 ¼ 01101010 þ1 ¼ 01101011
Result – 01101011
22. What is the largest 16-bit binary value that can be represented by
(a) Unsigned number
(b) Signed magnitude
(A) 216 – 1
(B) + 2151 or 2151
24. Convert the following IEEE 745 single precision to decimal number:
(a) 1
10000100
01110000000000000000000
(b) 0
01111100
11100000000000000000000
(A) S ¼ 1 mean number is negative
Exponent ¼ 10000100 – 01111111 ¼ 132127 ¼ 5
Mantissa ¼ 1.0111
Number ¼ 1.011 1* 25 ¼ 1011100 ¼ 92
(B)
S¼0 mean number is positive
Exponent ¼ 01111100 – 01111111 ¼ 124 – 127 ¼ 3 ¼ 11
Mantissa ¼ 1. 111
þ 1.111 * 23 ¼ 0.001111 ¼ 0.234375
Appendix: Digital Design Laboratory Experiments Using LOGISIM
219

26. Convert each of the following signed magnitude number to decimal:
(a) 11000011
(b) 10001111
(A)
The most signiﬁcant bit represents the sign
1000011 ¼ 35
(B)
–00001111 ¼ 15
28. Perform the following addition:
(0F4A)16 þ (420B)16 ¼ (5155)16
Chapter 2: Answers
2. If A ¼ 11001011 and B ¼ 10101110, the what are the results of following
operations value? of following operations?
(a) A AND B
(b) A OR B
(a) Performing bit by bit and operation
A ¼ 11001011
B ¼ 10101110
A AND B ¼ 10001010
(b) Performing bit by bit or operation
A ¼ 11001011
B ¼ 10101110
A OR B ¼ 11101111
4. Draw logic circuits for the following functions:
(a) F(X,Y,Z) ¼ XY0 þ YZ þ XZ0
(b) F(X,Y,Z) ¼ (X þ Y0) (Y þ Z) (X0 þ Z0)
220
Appendix: Digital Design Laboratory Experiments Using LOGISIM

(a)
z
Y'
Z'
X      Y
Z
XY'
YZ
XZ'
XY' + YZ + XZ'
(b)
Z'
X + Y'
Y + Z
X
X'
Y'
X' + Z'
Y                            Z
( X + Y' ) ( Y + Z ) ( X' + Z' )
6. Simplify following functions
(a) F(X, Y, Z) = XY + X0Y + XZ
Solution
F(X, Y, Z) = Y(X + X0) + XZ = Y + XZ
(b) F(X, Y, Z) = (X + Y) (X0 + Y + Z)
Appendix: Digital Design Laboratory Experiments Using LOGISIM
221

Solution
F(X, Y, Z) = (XX0 + XY + XZ + X0Y + YY + YZ) where XX0 = 0 and YY = Y
F(X, Y, Z) = (XY + XZ + X0Y + Y + YZ)
F(X, Y, Z) = Y(X + X0 + 1 + Z) + XZ
F(X, Y, Z) = Y + XZ
F(X, Y, Z) = XY0Z + XYZ + Y0ZF(X, Y, Z) = XZ(Y0 + Y) + Y0Z
F(X, Y, Z) = XZ + Y0Z
(c) F(X, Y, Z) = XY + YX0Z
F(X, Y, Z) = Y(X + X0Z) where X + X0Z = X + Z
F(X, Y, Z) = Y(X + Z)
(d) F(X, Y, Z) = X0Y + YXZ0
F(X, Y, Z) = Y(X0 + XZ0) = Y(X0 + Z0)
(e) F(X, Y, Z) = XY + (X + Y + Z)0X + YZ
F(X, Y, Z) = XY + (X0Y0Z0)X + YZ
F(X, Y, Z) = XY + YZ
(f) F(X, Y, Z) = (XY)0 + (X0 + Y + Z0)0
(g) F(X, Y, Z) = X0 + Y0 + XY0Z
F(X, Y, Z) = Y0(1 + XZ) + X0 = X0 + Y0
8. If A ¼ 10110110 and B ¼ 10110011, then ﬁnd
(a) A NAND B
(b) A NOR B
(c) A XOR B
(a) NAND each bit of A with corresponding bit of B
A ¼ 10110110
B ¼ 10110011
A NAND B ¼ 01001101
(b)
A ¼ 10110110
B ¼ 10110011
A NOR B ¼ 01001000
(c)
A ¼ 10110110
B ¼ 10110011
A XOR B ¼ 00000101
222
Appendix: Digital Design Laboratory Experiments Using LOGISIM

10. Show the output of the following logic circuits:
(a)
(b)
A
B
B
C
( A + B )'
( B + C)'
( A + B)' ( B + C)'
(c)
12. Find the output function of the following logic circuit:
Appendix: Digital Design Laboratory Experiments Using LOGISIM
223

14. Show the truth table for each of the following functions:
(a) F(X,Y,Z) ¼ XY0 þ XZ0 þ YZ
(b) F(X,Y,Z) ¼ (X þ Y) (X þ Z0)
(c) F(X,Y,Z) ¼ XY (Y þ Z0)
(a)
X
Y
Z
Y0
(XY)
(XY)0
(XþY0)
X
(XþY0)
(XY)0þX
(XþY0)
0
0
0
1
0
1
1
0
1
0
0
1
1
0
1
1
0
1
0
1
0
0
0
1
0
0
0
0
1
1
0
0
1
0
0
0
1
0
0
1
0
1
1
1
1
1
0
1
1
0
1
1
1
1
1
1
0
0
1
0
1
1
1
1
1
1
0
1
0
1
1
1
(b) F(X,Y,Z) ¼ (X þ Y þ Z0)0 (X0 þ Y0)
X
Y
Z
X0
Y0
Z0
(X0þY0)
(XþYþZ0)
(XþYþZ0)0
(XþYþZ0)0(X0þY0)
0
0
0
1
1
1
1
1
0
0
0
0
1
1
1
0
1
0
1
1
0
1
0
1
0
1
1
1
0
0
0
1
1
1
0
0
1
1
0
0
1
0
0
0
1
1
1
1
0
0
1
0
1
0
1
0
1
1
0
0
1
1
0
0
0
1
0
1
0
0
1
1
1
0
0
0
0
1
0
0
(c)
X
Y
Z
Y0
(X XOR Y)
(X NOR Y0)
(X XOR Y) (X NOR Y0)
0
0
0
1
0
0
0
0
0
1
1
0
0
0
0
1
0
0
1
1
1
0
1
1
0
1
1
1
1
0
0
1
1
0
0
1
0
1
1
1
0
0
1
1
0
0
0
0
0
1
1
1
0
0
0
0
224
Appendix: Digital Design Laboratory Experiments Using LOGISIM

(d)
X
Y
Z
X0
Y0
(X0þY0þZ)
(XþY)
(X0þ Y0þZ) (XþY)
0
0
0
1
1
1
0
0
0
0
1
1
1
1
0
0
0
1
0
1
0
1
1
1
0
1
1
1
0
1
1
1
1
0
0
0
1
1
1
1
1
0
1
0
1
1
1
1
1
1
0
0
0
0
1
0
1
1
1
0
0
1
1
1
16. Draw logic circuits for the following functions.
(a) F(X,Y,Z) ¼ (X þ Y)0 þ YZ
(b) F(X,Y,Z) ¼ (XYZ)0 þ XZ þ YZ
(a)
X      Y       Z
(X +Y)'
YZ
(X +Y)' + YZ
(b)
X        Y           Z
(XYZ)'
XZ
YZ
(XYZ)' +XZ +YZ
Appendix: Digital Design Laboratory Experiments Using LOGISIM
225

Chapter 3: Solution
Problems
2. Generate truth tables for the following functions:
(A) F(X,Y,Z) ¼ ∑(1,3,6,7)
X
Y
Z
F
0
0
0
0
0
0
1
1
0
1
0
0
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
0
1
1
1
1
(B) F(X,Y,Z) ¼ π(1,3,4)
Maxterms represent zeros in the truth table.
X
Y
Z
F
0
0
0
1
0
0
1
0
0
1
0
1
0
1
1
0
1
0
0
0
1
0
1
1
1
1
0
1
1
1
1
1
(C) F(W,X,Y,Z) ¼ ∑(1,4,7,10,12,15)
Minterms represent ones in the truth table.
(D) F(W,X,Y,Z) ¼ π(2,3,4,7,10,11,12,13)
Maxterms represent zeros in the truth table.
F(X,Y,Z) ¼ Y0Z0 þ YZ
226
Appendix: Digital Design Laboratory Experiments Using LOGISIM

4. Simplify following functions using K-map
(a)
X
Y
F
0
0
1
0
1
1
1
0
1
1
1
0
F(X,Y) ¼ X0 þ Y0
(b)
X
Y
Z
F
0
0
0
1
0
0
1
1
0
1
0
0
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
1
1
1
1
0
F(X,Y,Z) ¼ X0Y0 þ X0Z þ Y0Z þ XYZ0
Appendix: Digital Design Laboratory Experiments Using LOGISIM
227

(C)
A
B
C
D
F
0
0
0
0
1
0
0
0
1
0
0
0
1
0
1
0
0
1
1
1
0
1
0
0
0
0
1
0
1
1
0
1
1
0
1
0
1
1
1
1
1
0
0
0
1
1
0
0
1
1
1
0
1
0
0
1
0
1
1
0
1
1
0
0
0
1
1
0
1
1
1
1
1
0
1
1
1
1
1
1
F(W,X,Y,Z) ¼ WZ þ W0X0Y0 þ W0XZ0
SOP
6. Simplify the following functions where D is a don’t care function:
(A) F(X,Y,Z) ¼ ∑(0, 3, 4)
D(X,Y,Z) ¼ ∑(2, 6)
F(X,Y,Z) ¼ Z0 þ X0Y
(A) F(W,X,Y,Z) ¼ ∑(0, 1, 3, 5, 9, 11)
D(W,X,Y,Z) ¼ ∑(2, 4, 8, 10)
228
Appendix: Digital Design Laboratory Experiments Using LOGISIM

F(W,X,Y,Z) ¼ X0 þ W0Y0
8. Simplify the following function and draw logic circuit using
(A) NAND gates
(B) NOR gates
F(W,X,Y,Z) ¼ W0X0Z0 þ XY0Z0 þ WX þ WY þ WY0X0Z0
F(W,X,Y,Z) ¼ X0Z0 þ WX þ Y0Z0 þ WY
F(W,X,Y,Z) ¼ [(X0Z0 þ WX þ Y0Z0 þ WY)0]0
F(W,X,Y,Z) ¼ [(X0Z0)0 (WX)0 (Y0Z0)0 (WY)0]0
NAND form
Appendix: Digital Design Laboratory Experiments Using LOGISIM
229

F(W,X,Y,Z) ¼ [(X0Z0)0 (WX)0 (Y0Z0)0 (WY)0]0
F(W,X,Y,Z) ¼ [(X þ Z) (W0 þ X0) (Y þ Z) ( W0 þ Y0)]0
F(W,X,Y,Z) ¼ (X þ Z)0 þ (W0 þ X0)0 þ (Y þ Z)0 þ (W0 þ Y0)0
NOR form
W                          X                             Y                          Z
( W + Z )'
( W' + X' )'
( Y + Z )'
( W' + Y' )'
F
230
Appendix: Digital Design Laboratory Experiments Using LOGISIM

Chapter 4
2. Find the output of the following gates:
4. Design a logic circuit with three inputs and one output; the output generates
even parity bit of the inputs; assume zero is even.
(a) Show the truth table.
(b) Find output function.
(c) Draw logic circuit.
X
Y
Z
F
0
0
0
1
0
0
1
0
0
1
0
0
0
1
1
1
1
0
0
0
1
0
1
1
1
1
0
1
1
1
1
0
F(X,Y,Z) ¼ m0 þ m3 þ m5 þ m6
F(X,Y,Z) ¼ X0Y0Z0 þ X0YZ þ XY0Z þ XYZ0 ¼ X0 (Y0Z0 þ YZ) þ X
(Y0Z þ YZ0)
If
Y0Z þ YZ0 ¼ A then Y0Z0 þ YZ ¼ A0
Therefor function F can be written as
F(X,Y,Z) ¼ X0A0 þ XA ¼ X XNOR A
Appendix: Digital Design Laboratory Experiments Using LOGISIM
231

6. Implement the following functions using only one decoder and external gates:
F1(X,Y,Z) ¼ ∑(0, 3, 4)
F2(X,Y,Z) ¼ ∑( 2, 3, 5)
The function requires a 3*8 decoder.
8. The following multiplexer is given; complete its table.
10. Design an 8-bit binary adder using 4-bit binary adders.
B7
B4   A7       A4                                 B3       B0    A3        A0
  S7        S4
S3         S0
A0
A1
A2
A3
B0
B1
B2
B3
S0
S1
S2
S3
CO
CI
A0
A1
A2
A3
B0
B1
B2
B3
S0
S1
S2
S3
CO
CI
Cout
232
Appendix: Digital Design Laboratory Experiments Using LOGISIM

12. Design a combination logic with three inputs and three outputs, if input 0, 1, 2,
or 3 then output 3 more than input, if input 4, 5, 6, or 7 then output 3 less than
input.
X
Y
Z
A
B
C
0
0
0
0
1
1
0
0
1
1
0
0
0
1
0
1
0
1
0
1
1
1
1
0
1
0
0
0
0
1
1
0
1
0
1
0
1
1
0
0
1
1
1
1
1
1
0
0
Making K-map for A, B, and C
K-map for A
A (X,Y,Z) ¼ X0Z þ X0Y þ YZ
K-map for B
B (X,Y,Z) ¼ X0Y0Z0 þ X0YZ þ XY0Z þ XYZ0 ¼ X0(Y0Z0 þ YZ) þ X
(Y0Z þ YZ0)
If Y0Z þ YZ0 ¼ W then
B (X,Y,Z) ¼ X0W0 þ XW ¼ X XNOR W and W ¼ Y XOR Z
Appendix: Digital Design Laboratory Experiments Using LOGISIM
233

Function for C – by looking at the truth table, the column for C is complement
of Z, then
C ¼ Z0
X
Z
X'Z
Y
X'Y
YZ
A
W
B
C
14. Design a combinational circuit with four inputs and one output; the input to the
combination circuit is BCD, and the output generates even parity for the input.
W
X
Y
Z
F
0
0
0
0
0
0
0
0
1
1
0
0
1
0
1
0
0
1
1
0
0
1
0
0
1
0
1
0
1
0
0
1
1
0
0
0
1
1
1
1
1
0
0
0
1
1
0
0
1
0
1
0
1
0
d
1
0
1
1
d
1
1
0
0
d
1
1
0
1
d
1
1
1
0
d
1
1
1
1
d
234
Appendix: Digital Design Laboratory Experiments Using LOGISIM

F(W,X,Y,Z) ¼ W0X0Y0Z þ XY0Z0 þ WY0Z0þ XYZ þ X0YZ0
16. Design a 4-bit ALU to perform the following functions:
AþB, AB, Aþ1, A0, B0, A OR B, A XOR B, A AND B
Solution
This is 4-bit ALU; therefore, it requires four multiplexers. This ALU has eight
functions; therefore, each multiplexer is 8*1.
Chapter 5: Problems
2. Complete the following table for JK ﬂip-ﬂop:
J
K
Q(t) present output
Q(tþ1) next output
0
0
0
0
0
0
1
1
0
1
0
0
0
1
1
0
1
0
0
1
1
0
1
1
1
1
0
1
1
1
1
0
Appendix: Digital Design Laboratory Experiments Using LOGISIM
235

4. The following ﬁgure shows a sequential logic; complete the following table;
assume initial value of Q1 ¼ 0 and Q2 ¼ 0. Use logicism to verify your answer.
Clock
Q0
Q1
Initial value
0
0
Clock #1
1
0
Clock #2
0
1
Clock #3
1
1
6. The following shift register is given; ﬁnd the output after ﬁve clock pulses.
Q3
Q2
Q1
Q0
Clock
0
0
0
0
0
0
0
1
#1
0
0
1
1
#2
0
1
1
0
#3
1
1
0
0
#4
1
0
0
0
#5
8. Complete the following excitation table for JK ﬂip-ﬂop:
Q(t)
Q(tþ1)
J
K
0
0
0
d
0
1
1
d
1
0
d
1
1
1
d
0
236
Appendix: Digital Design Laboratory Experiments Using LOGISIM

10. Find the state table for the following state diagram:
Present state
Next state
X¼0
X¼l
A
B
A
B
AB
0
0
0
1
10
0
1
0
1
10
1
0
1
1
10
1
1
1
1
00
12. Show state table and state diagram for the following circuit:
Appendix: Digital Design Laboratory Experiments Using LOGISIM
237

Present state
Next state
X¼0
X¼l
A
B
A
B
A
B
0
0
1
1
1
0
0
1
0
1
1
1
1
0
0
0
0
1
1
1
1
1
0
0
Chapter 6
Review Questions
•
Multiple choice questions
The function of the _________ is to perform arithmetic operations.
(a) Bus
(b) Serial port
(c) ALU
(d) Control unit
Answer: C
2. When you compare the functions of a CPU and a microprocessor, __________
(a) They are the same.
(b) They are not the same.
(c) The CPU is faster than microprocessor.
(d) The microprocessor is faster than CPU.
Answer: A
4. The CISC processor control unit is ____________.
(a) Hardware
(b) Microcode
(c) a and b
(d) None of the above
Answer: A
6. Which of the following buses are 32-bit?
(a) ISA
(b) PCI and EISA
(c) EISA and ISA
(d) MCA and ISA
Answer: A
238
Appendix: Digital Design Laboratory Experiments Using LOGISIM

Short-Answer Questions
2. Explain the functions of a CPU.
Answer: The CPU is the “brain” of the computer and is responsible for accepting
data from input devices, processing the data into information, and transferring the
information to memory and output devices.
4. What is the function of a control unit?
Answer: The function of the control unit is to control input/output devices, generate
control signals to other components of the computer such as read and write signals,
and perform instruction execution.
6. How many bits in a half word? 16
8. Distinguish between a CPU and a microprocessor.
Answer: If the control unit registers and ALU are packaged into one integrated
circuit, it is a microprocessor; if they are not packaged in the same unit, it is a CPU.
10. Explain the function of DMA.
Answer: DMA (direct memory access) allows the transfer of blocks of data from
memory to an I/O device or vice versa. This is done directly without using the CPU.
12. What is the application of a serial port?
Answer: USB which has many applications is a type of serial port.
14. What is the maximum memory for a CPU with 16 address lines and 8 data lines?
Answer: A CPU with 16 address lines and 8 data lines can have a maximum
memory of 524,288 bits (2^16 * 8).
16. List characteristics of RISC processor.
Answer: The characteristics of a RISC processor are the following: it requires a new
instructions, all instructions are of the same length, most instructions are executed
in one machine clock cycle, control unit is hardwired, and it has few address modes
and a large number of registers.
18. What is the advantage of multicore processor versus single core?
Answer: A multicore processor can execute multiple instructions simultaneously
which increases performance over a single core processor.
20. Explain fetch instruction.
Answer: The fetch instruction moves an instruction from the memory into the CPU.
22. Calculate the execution time for problem 21 using non-pipeline processor.
Answer: 100 ms
Appendix: Digital Design Laboratory Experiments Using LOGISIM
239

24. List types of disk controller.
Answer: There are two types of disk controllers being integrated disk electronics
(IDE) and small computer system interface (SCSI).
26. List two serial buses.
Answer: USB and FireWire.
28. Show pin connection of a USB port.
Answer:
30. What is the application of FireWire?
Answer:
FireWire is a high-speed serial bus used for digital devices such as digital video
or camcorders.
Chapter 7: Questions and Problems
2. What does RAM stand for?
Answer: RAM stands for random-access memory.
4. Which of the following memory types are used for main memory?
(a) ROM and SDRAM
(b) SRAM and DRAM
(c) SDRAM and DRAM
(d) DRAM and EPROM
Answer: C
6. What does ROM stand for?
Answer: Read-only memory
240
Appendix: Digital Design Laboratory Experiments Using LOGISIM

8. What is the difference between EEPROM and EPROM?
Answer: EPROM requires the use of an ultraviolet light to be erased, while
EEPROM can be erased by applying a speciﬁc voltage to one of its pins.
10. What is the primary application of SRAM?
Answer: The primary application of SRAM is used as cache for the CPU.
12. Deﬁne the following terms:
(a) Track
(b) Sector
(c) Cluster
Answer:
(A) Tracks are the division of platters into circular paths.
(B) Sectors are each of the tracks further broken down into smaller pieces.
(C) A cluster is a grouping of sectors.
14. What is the function of File Allocation Table (FAT)?
Answer:
FAT deﬁnes organization of information stored on a hard disk, FAT16 and
FAT32 were used on earlier Windows applications.
16. What are the types of cache?
Answer: Data cache (D-cache) and Instruction cache (I-cache).
18. What is virtual memory?
Answer: Virtual memory is either a hard disk drive (HDD) or solid state drive
(SSD) that is used to store application data and instructions from the main memory
that are not currently needed by the CPU.
20. Physical address determines the size of
(a) Virtual memory
(b) Physical memory
(c) Cache memory
Answer: B
22. What is hit ratio?
Answer:
Hit ratio is the number of hits/number of misses number of hits.
24. Explain spatial locality.
Answer:
The idea that when a memory location is accessed, it is very likely that nearby
memory locations will also need to be accessed.
Appendix: Digital Design Laboratory Experiments Using LOGISIM
241

26. Show a format of address seen by the cache for direct mapping.
Answer:
28. What is the function of a page number in a virtual address?
Answer: The page number is used as part of a virtual address to identify pages.
30. What is the function of the page table?
Answer:
The page table is used to keep track of the page number of each page and the
corresponding block of data. The page table also keeps track of whether each page
is in the main memory or virtual memory.
32. What is the advantage of set associative versus direct mapping of caches?
Answer: Set associative mapping will have less misses than direct mapping.
34. __________ is the fastest type of memory.
(a) Cache memory
(b) Main memory
(c) Secondary memory
(d) Hard disk
Answer: A
242
Appendix: Digital Design Laboratory Experiments Using LOGISIM

Problems
2. The following memory and cache memory are given. CPU generates addresses
0x1, 0x2, 0x1, 0x8, 0x9, 0x1C, 0x1D, 0x3, and 0x4.
(a) A. Show the contents of the cache using two-way set associative mapping;
assume a LRU replacement policy.
(b) What is the hit rate?
Address
Content
Address
Content
00000
5
10000
5
00001
3
10001
0
00010
11
10010
1
00011
6
10011
11
00100
7
10100
15
00101
8
10101
09
00110
9
10110
12
00111
12
10111
23
01000
0
11000
65
01001
0
11001
21
01010
8
11010
8
01011
7
11011
7
01100
9
11100
9
01101
0
11101
0
O1110
2
11110
2
01111
5
11111
5
Initial value for V-bit and LUR
Set address
V
Tag
B1
B0
LRU
v
Tag
B1
B0
LRU
00
0
0
0
0
01
0
0
0
0
10
0
0
0
0
11
0
0
0
0
Format of address seen by cache
2 bits
2 bits
1 bit
Tag
Set address
Byte offset
Set address
V
Tag
B1
B0
LRU
V
Tag
B1
B0
LRU
00
0>l
00
0
5
0>l>0
0>1
01
0
5
0>1
01
0>1
00
11
3
0>1
0>1
0
10
0>1
11
0
9
0>1>0
0>1
00
7
6
0>1
11
0
0
0
0
Appendix: Digital Design Laboratory Experiments Using LOGISIM
243

4. A computer has 32 Kbytes of virtual memory and 8 Kbytes of main memory
with a page size of 512 bytes.
(a) How many bits are in the virtual address?
(b) How many pages are in the virtual memory?
(c) How many bits are required for the physical address?
(d) How many frames or blocks are in the main memory?
(a) 15 virtual address
(b) 215 / 29 ¼ 26 ¼ 64 pages
(c) 213 ¼ 8k physical address is 13 bits
6. A computer has 20 bits of virtual memory and each page is 2KB.
(a) What is the size of virtual memory?
(b) How many pages are in virtual memory?
Answer:
(a) 220 ¼ 1MB
(b) 220 / 211 ¼ 29 pages
8. CPU of Fig. 7.24 generates addresses 0x00 and 0x0b; assume Page0 map into
block1 and page 2 map in block 0; show the contents of page table
Address 0X00
Page#
Offset
000
00
Page number is the address to the page table
Address 0X0b
Page table
Valid bit
Frame number (2 bits)
000
0 1
01
001
0
010
0 1
00
011
0
100
0
101
0
110
0
111
0
0
Page #
offset
010
11
010 is the address to page table.
244
Appendix: Digital Design Laboratory Experiments Using LOGISIM

Chapter 8
2. List types of instructions based on number of operands:
Instructions with no operand such as HLT
Instruction with two operands such as MOV R1, R2
Instruction with the operands such as ADD R1, R2, R3
4. Which register of ARM processor is used for Stack Pointer (SP)?
R13
Problems
6. What are the contents of R1? Assume R2 ¼ 0x00001234.
(a) MOV R1, R2, LSL #4
R1 ¼ 0x00012340
(b) MOV R1, R2, LSR #4
R1 ¼ 0x00000123
8. Convert the following HLL language to ARM instructions.
IF R1>R2 AND R3>R4 then
R1= R1 þ1
Else
R3=R3 þR3*8
Endif
Solution
CMP R1, R2
CMPGT R3, R4
ADDGT R1,R1, #& 1
ADDLE R3, R3, R5 LSL #3
6. Convert the following ﬂowchart to ARM assembly language.
IF R1>R2
R3=R3+2
T
F
R4=R4 +4
IF R3=R7
R6=R6-R7
R6=R6+R7
T
F
Appendix: Digital Design Laboratory Experiments Using LOGISIM
245

Solution
CMP R1, R2
ADDGT F3, R3, #&2
ADDLE R4, R4, #&5
CMPLE R3, R7
SUBEQ R6,R6, R7
ADDNE R6,R6, R7
8. Write a program to convert the following HLL to ARM assembly:
a= 10;
b=45;
while (a! =b) {
if (a < b)
a = a þ5;
else
b= bþ5;
}
SOLUTION:
Solution
MOV R1, #10
MOV R2,45
Loop:
CMP R1, R2
BEQ Halt
ADDLT R1, R1,#5
ADDGT R2, R2, #5
B loop
Halt
10. Convert the following ﬂow chart to ARM assembly:
R5=R3-R4
R12=R10-R11
F
T
T
F
R5=R3+R4
If R5>R6
IF R1=R2
246
Appendix: Digital Design Laboratory Experiments Using LOGISIM

CMP R1, R2
SUBNE R5, R3,R4
BNE Halt
ADDEQ R5, R3 R4
CMPEQ R5, R6
SUBLTE R12, R10, R11
SUBGT R5, R3,R4
Halt
Chapter 9
Problem
Trace the following instructions; assume list start at memory location
0x0000018, and using ARM Big Endian.
ADR
R0, LIST
; Load R0 with address of memory location List
MOV R10, #0x2
(a) LDR R1, [R0]
(b) LDR R2, [R0, #4]!
(c) LDRB R3, [R0], #1
(d) LDRB R4, [R0 , R10]!
(e) LDRSB R5, [R0], #1
(f) LDRSH R6, [R0]
LIST
DCB
0x34, 0xF5, 0x32, 0xE5, 0x01, 0x02,0x8,0xFE
Solution
ADR
R0, LIST
; Load R0 with address of memory location List
MOV R10, #0x2
a.
LDR R1, [R0]
;R0¼0x18
R1¼0x34F532E5
b.
LDR R2, [R0, #4]!
;R0¼ 0x1C
R2 ¼0x010208FE
c.
LDRB R3, [R0] , #1
;R0¼ 0x19
R3¼0x34
d.
LDRB R4, [R0 , R10]!
;R0¼ 0x1A
R4¼0X32
e.
LDRSB R5, [R0], #1
;R0¼ 0x19
R5¼0x34
f.
LDRSH R6, [R0]
;R0¼ 0x18
R6¼0x34F5
LIST
DCB
0x34, 0xF5, 0x32, 0xE5, 0x01, 0x02,0x8,0xFE
2. Work problem #1 part A and B using Little Endian
(a) R1 ¼ 0xE532F534
(b) R2 ¼ 0xFE080201
Appendix: Digital Design Laboratory Experiments Using LOGISIM
247

4. What are the contents of register Ri for the following load instructions; assume
R0 holds the address of list using Little Endian.
(a) LDR R1, [R0]
(b) LDRH R2, [R0]
(c) LDRB R3, [R0] , #1
(d) LDRB R4, [R0]
(e) LDRSB R5, [R0], #1
(f) LDRSH R6, [R0]
List
DCB
0x34, 0xF5, 0x32, 0xE5, 0x01, 0x02
Solution
(a) LDR R1, [R0]
;R1¼0xE532F534
(b) LDRH R2, [R0]
; R2¼0x0000F534
(c) LDRB R3, [R0], #1
;R3¼0x00000034
(d) LDRB R4, [R0]
;R4¼ 0x000000F5
(e) LDRSB R5, [R0], #1
; R5¼0xFFFFFFF5
(f) LDRSH R6, [R0]
;R6¼0xFFFFE532
List
DCB
0x34, 0xF5, 0x32, 0xE5, 0x01, 0x02
6. What is the effective address and contains of R5 after executing the following
instructions? Assume R5 contains 0x 18 and r6 contains 0X00000020.
(A) STR
R4, [R5]
(B) STR
R4, [R5, #4]
(C) STR
R4, [R5, #8]
(D) STR
R4, [R5, R6]
(E) STR
R4, [R5], #4
Solutions
(A) STR R4, [R5]
EA¼ 0x18
(B) STR R4, [R5, #4]
EA¼ 0x18 þ 4¼ 0x1C
(C) STR R4, [R5, #8]
EA¼0x18 þ8¼0x20
(D) STR R4, [R5, R6]
EA¼ 0x18 þ0x20 ¼ 0x38
(E) STR R4, [R5], #4
EA¼ 0x18, R5¼0x18 þ4¼0x1C
248
Appendix: Digital Design Laboratory Experiments Using LOGISIM

Chapter 10
Solutions
For all program, the following templet were used:
AREA
RESET, DATA, READONLY
EXPORT __Vectors
__Vectors
DCD 0x20001000
; stack pointer value when stack is empty
DCD Reset_Handler ; reset vector
ALIGN
AREA
MYCODE, CODE, READONLY
ENTRY
EXPORT Reset_Handler
Reset_Handler
Location of Your Code
STOP
B STOP
END
;End of the program
2. Write a program to ﬁnd the largest number and store it in memory location
LIST3. Assume numbers are in location LIST1 and LIST2.
__main
ADR
R0,LIST1
LDR R1, [R0]
ADR R0, LIST2
LDR
R2, [R0]
CMP R1, R2
BHI
RESULT
; IF R1>R2
MOV R1, R2
RESULT
ADR R0, LIST3
STR R1, [R0]
LIST1
DCD
0x23456754
LIST2
DCD
0X34555555
LIST3
DCD
0x0
Appendix: Digital Design Laboratory Experiments Using LOGISIM
249

4. Write a program to add two numbers, the number represented by
N1
EQU
5
M1
EQU
7
Solution
MOV r6, #M1
;Load r6 with 7
MOV r8, #N1
__main
ADD R7, R6, R8
; ADD R6 with R8 and store in R7
N1
EQU
5
M1
EQU
7
6. Write a program, add LIST1 to LIST2, and store the sum in LIST3.
__main
ADR R1, LIST1
; ADR is Pseudo Instruction
LDR R2, [R1]
ADR R3, LIST2
LDR R4, [R3]
ADD R5, R2,R4
ADR R8, LIST3
STR R5 , [R8]
LIST1
DCD 0x00002345
LIST2
DCD 0X00011111
LIST3
DCD 0x00000000
8. Write a program for multiplying two numbers.
__main
LDR
R1, =0x22222222
LDR R2, =0x3
MUL R3, R1,R2
250
Appendix: Digital Design Laboratory Experiments Using LOGISIM

10. Write a program to add eight numbers using Post-index addressing
LIST DCB 0x5, 0x2,0x6,0x7 ,0x9,0x1,0x2,0x08
Solution
ADR R0, LIST
__main
SUB R5,R5,R5
MOV R1,#0x8
LOOP
LDRB R2, [R0], #1
ADD R5, R5, R2
SUB R1, R1, #01
CMP R1, #0x0
BNE
LOOP
ALIGN
LIST DCB 0x5, 0x2,0x6,0x7 ,0x9,0x1,0x2,0x08
10. Write a program to convert the following HLL language to ARM instructions:
IF R1=R2 AND R3>R4 then
R1= R1 +1
Else
R3=R3 +R3*8
Endif
ADR R6, LIST1
ADR R7, LIST2
ADR R8, LIST3
ADR R9, LIST4
LDR R1, [R6]
LDR R2, [R7]
LDR R3, [R6]
LDR R4, [R7]
CMP R1, R2
CMPEQ R3, R4
ADDGT R1,R1, # 1
ADDLE R3, R3, R3, LSL #3
ALIGN
LIST1 DCD 0x58
LIST2 DCD 0x95
Appendix: Digital Design Laboratory Experiments Using LOGISIM
251

LIST3 DCD 0x24
LIST4 DCD 0x234
STOP B
STOP
12. Write a program to convert the following HLL to assembly language:
If
R1=R2 then
R3= R3+1
IF R1<R2 Then
R3=R3-1
If R1>R2 Then
R3=R3-5
Solution
MOV R1, #0x9
MOV R2, #0x6
MOV R3, #0x5
__main
CMP R1, R2
ADDEQ R3, R3, #0x1
SUBLE R3, R3, #0x1
ADDGT R3, R3, #0x3
14. Write a program to rotate R1 16 times; assume R1 contains 0x12345678.
__main
ADR R0, LIST
LDR R1,[R0]
ROR R1, R1, #16
LIST
DCD 0x12345678
16. Write a program to read a word memory location LIST and clear bit position B4
through B7 of register R5; assume R5 contains 0XFFFFFFF.
LDR R0, =0x000000F0
LDR R5, =0xFFFFFFFF
252
Appendix: Digital Design Laboratory Experiments Using LOGISIM

Solution
LDR R0, =0x000000F0
LDR R5, =0xFFFFFFFF
__main
BIC R4, R5, R0
18. Write program to load Register R1, R2, R3, and R4 from memory
location LIST.
LIST DCD 0x12345AAA, 0x0000BBBB, 0x0000CCCC , 0X0000DDD
__main
ADR R0,LIST
LDM R0, {R1,R2,R3,R4}
LIST DCD
0x12345AAA, 0x0000BBBB, 0x0000CCCC , 0X00000DDD
Appendix: Digital Design Laboratory Experiments Using LOGISIM
253

References
1. M. Mano, Digital design, 5th edn. (Pearson, 2013) USA
2. E.O. Hwang, Digital design and microprocessor design with interfacing, 2nd edn. (Cengage
Learning, 2018) USA
3. D. Haris, S. Haris, Digital Design and Computer Architecture ARM Edition (Morgan
Kaufmann, 2016) USA
4. M. Wolf, Computers as Components (Morgan Kaufmann, 2017) USA
5. A. Elahi, T. Arjeski, ARM Assembly Language with Hardware Experiments (Springer, 2015)
USA
6. W. Stalling, Computer Organization and Design, 10th edn. (Pearson, 2016) USA
7. A. Clements, Computer Organization and Architecture Themes and Variations (Cengage
Learning, 2014) USA
8. NXP Corp, LPC16XX user manual
9. http://infocenter.arm.com, ARM V7 manual
10. Keil Corp, μvision development tool
11. ARM Cortex-M3 technical reference manual
12. S.B. Furber, ARM System-on-chip Architecture (Addison Wesley, 2000) USA
13. W. Holm, ARM Assembly Language (CRC Press, 2009) USA
14. K. Schindler, Introduction to Microprocessor Based System Using the ARM processor (Person,
2013) USA
15. J.W. Valvano, Embedded Systems Real-time Interfacing to the ARM Cortex-M3 (J.W. Valvano,
2011) USA
16. D. Lewis, Fundamentals of Embedded Software with ARMCotex-M3 (Pearson, 2013) USA
17. R. Gibson, ARM Assembly Language – An Introduction. (LuLu, 2007) USA
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1
255

Index
A
Addressing mode, ARM
addressing modes, 187
immediate addressing, 188
post-index addressing, 190
pre-index addressing mode, 188, 189
pre-index addressing with write back,
189, 190
processor support, 187
Advanced RISC Machine (ARM)
address register, 164
B and BL instruction format, 179
barrel shifter, 165
32-bit ALU, 165
branch with link instruction (BL), 178
description, 163
instruction decoder and logic control, 164
modes, 165
multiply (MUL), 180
multiply-accumulate (MLA)
instructions, 180
Read Data Register, 165
register bank, 164
registers, 163
stack operation and instructions, 177, 178
Write Data Register, 165
American Standard Code for Information
Interchange (ASCII), 18
Analog signals
amplitude, 4
frequency (F), 3
nonperiodic signal, 2
periodic Signal, 2
phase, 4
AND gate, 30, 31
AND logic, 30, 31
AND-NOT gates, 32
Arithmetic logic unit (ALU), 14, 88, 90
Arithmetic shift right (ASR), 172
ARM data processing instructions, 174, 175
ARM data transfer instructions
LDR pseudo instruction, 185, 186
pseudo instructions, 186
STR instruction, 187
ARM instructions
compare and test instructions, 169
data processing instructions, 167, 168
instructions format and operations, 166
register swap instructions (MOV and
MVN), 170
shift and rotate instructions, 171, 172
unconditional instructions and conditional
instructions, 173, 174
ARM pseudo instructions, 186
ARM registers, 165, 166
ASCII code, 17, 25
Assembler, 197
Asynchronous transmission, 22
B
Barrel shifter, 102
Biased exponent, 15, 16
Big Endian, 193
Binary to decimal conversion, 6–7
Binary-coded decimal (BCD), 16, 17
Bit, 5
4-Bit binary adder, 87
1-Bit DRAM, 139
Bit ﬁeld clear (BFC), 191
© Springer International Publishing AG 2018
A. Elahi, Computer Systems, https://doi.org/10.1007/978-3-319-66775-1
257

Bit Field Clear Instruction (BFC), 191
Bit ﬁeld insertion (BFI), 191
Bit ﬁeld instructions, 191, 192
Bit insertion instruction (BFI), 192
4-Bit shift left register, 103
Block, 146
Boolean algebra theorems
associative law, 38
commutative law, 38
De Morgan’s Theorem I, 38
De Morgan’s Theorem II, 38
description, 36
distributive theorem, 37
theorem, 36, 37
Boolean function, 39, 40
Boolean logics, 30
Boolean theorems, 29
Byte, 5
C
Cache line/cache block, 146
Cache memory, 145
Central processing unit (CPU), 2, 14, 15
architecture, 120
arithmetic logic unit (ALU), 116
32-bit processor, 118
64-bit CPU, 118
CISC, 118, 119
control unit, 116
harvard architecture, 120
instruction execution, 123
Intel microprocessor, 120–122
multicore processor, 122, 123
register, 116
Von Neumann architecture, 120
Clock, 21, 22
Coding schemes
ASCII code, 17
Combinational logic
ALU, 88, 90
analysis of, 72, 73
binary subtractor, 87
block diagram, 72
decoder, 75, 76
description, 71
design of, 72–74
full adder (FA), 84, 86
half adder (HA), 84, 85
multiplexer (MUX), 77–81, 83
sequential logic, 71
seven segment displays, 89, 91
Complement, 11, 12
Complex instruction set computer (CISC), 118
Computer
basic components of, 2
Condition code, 173
Counter, 108, 109
CPU buses, 116
address bus, 117
control bus, 118
data bus, 117, 118
Cross-assembler, 197
Current Program Status Register (CPSR),
165, 166
D
D ﬂip-ﬂop, 99–101
Data directives, 210, 211
character strings, 211
DCB, 210
DCD, 210
DCW, 210
single character, 211
SPACE, 211
Data representation
and memory, 192, 193, 209
DCB (Deﬁne Constant Byte), 210
DCD (Deﬁne Constant Word), 210
DCW (Deﬁne Constant Half Word), 210
Decimal to binary conversion, 7–9
Decoder, 75, 76
Digital signals, 1, 5
Direct memory access (DMA), 124
Directives, 209
Disk controller
IDE, 125
SATA, 126
SCSI, 125
Disk ﬁle system, 143
Don’t care conditions, 60, 61
Double Data Rate SDRAM (DDR
SDRAM), 140
Double precision, 15
E
Electrical signal, 3
Electrically Erasable PROM
(EEPROM), 141
Erasable Programmable Read-Only
Memory (EPROM), 141
Exclusive NOR gate, 33
Exclusive OR gate, 32
Exponent, 15
Extended Data Out RAM (EDORAM), 140
Extended ISA (EISA) bus, 127
258
Index

F
FireWire/IEEE 1394, 132
Flash memory, 141
Flip-ﬂop excitation table, 107
Floating point representation, 14, 15
Floating point unit (FLU/FPU), 14, 15
Frequency (F), 3, 4
Full adder (FA), 84, 86
Fully associative mapping, 152
H
Half adder (HA), 84, 85
Hard disk
access time, 143
disk ﬁle system, 143
internal architecture, 142
rotational cluster, 143
rotational delay, 143
seek time, 143
Harvard architecture, 120
Hexadecimal number, 9, 17, 25
High-deﬁnition multimedia interface (HDMI),
133, 134
High-level language (HLL), 161
Hit, 146
Hit ratio, 146
Hubs
architecture of, 130
I
I/O devices, 125
Industry standard architecture (ISA) bus, 127
Input device, 2
2-Input NAND gate, 31
Instruction set architecture (ISA)
description, 162
no operand instructions, 162
one operand instructions, 163
two operand instructions, 163
Integers, 14
Integrated circuits (IC)
integrated circuit pins numbering, 35
LSI, 36
MSI, 36
SSI, 34
transistors, 33
Integrated disk electronics (IDE), 125
Intel Processor Family, 120–122
J
J-K ﬂip-ﬂop, 100
J-K ﬂip-ﬂop excitation table, 108
K
Karnaugh map (K-map)
adjacent cells, 52, 54
combination of cells, 55
description, 52
four-variable, 57
function, 55
function F(X, Y), 52
minterms, 52
simpliﬁed function, 58
three-variable, 53, 54
transferring minterms, 53
Keil development tools
ARM Cortex M3 processor, 199
ARMv7 assembly programs, 199
assembling a program, 201
build output panel, 201
debugger/simulator, running the,
204–206
directives, 200
Keil μVision® IDE v5.22, 198
Keil’s website, 198
pack installer, 198
program template, 208
μVision, 198
L
Large-scale integration (LSI), 36
LDR pseudo instruction, 186
Little Endian, 194
Load instructions (LDR), 185
Logic gates, 29
Logical shift left (LSL), 171
Logical shift right (LSR), 171
M
Main memory, 145
Mantissa, 15, 16
Maxterm, 51
Medium-scale integration (MSI), 36
Memory, 2
in μVision, 211
Memory access time, 141
Index
259

Memory hierarchy
cache memory, 145, 146
direct mapping, 146–148
fully associative mapping, 152
main memory, 145
memory operation, 155
memory organization, of computer, 155
page table, 154
second memory, 145
set associative mapping, 150, 151
virtual memory, 153
Microchannel architecture (MCA) bus, 127
Microcomputer, 116
components of, 115, 116
CPU, 116 (see also Central processing
unit (CPU))
disk controller, 125, 126
microcomputer bus, 126
standard, 115
Minterms
application of, 48
description, 48
of F(X,Y), 48
logic circuit, 50
sum of the minterms, 48
three variables, 48
truth table, 48, 50
zeros, 49
Miss, 146
Motherboard, 133
Multicore processor, 122, 123
Multiple inputs logic gates, 33
Multiplexer (MUX), 77–81, 83
basic architecture of, 77
1-to-N demultiplexer, 78, 79
description, 77
function Y, 80
implementing, 83
large and smaller multiplexers, 81
logic circuit, 80
truth table, 79
N
NAND gate, 31
NOR gate, 31
NOR logic, 31
Normalized mantissa, 15
NOT gate, 31
NOT logic, 31
Number system, 5
binary addition, 10
from binary to decimal, 6–7
from decimal fraction to binary, 8–9
from decimal integer to binary, 7
from hex to binary, 9
O
OR gate, 31
OR logic, 30
OR operation, 30
Output device, 2
P
Page table, 154
Parallel transmission, 23, 24
Parity bit
description, 21
even parity, 21
odd parity, 21
PCI express, 131, 132
PCI express link (lane), 132
PCI express protocol architecture, 132
Periodic signal, 2, 3
Peripheral component interconnect (PCI)
bus, 127
Physical address, 146
Pipelining, 124
Product of sums (POS), 58–60
Programmable I/O interrupt
controller, 125
Programming rules, ARM assembly
language, 208
Pseudo instruction, 185, 186
R
Rambus DRAM (RDRAM), 140
Random-access memory (RAM)
16 bites, 138
block diagram, 138
EDORAM, 140
memory locations, 139
RDRAM, 140
SDRAM, 139, 140
types, 139
volatile memory, 138
Read-only memory (ROM)
EEPROM, 141
EPROM, 141
ﬂash memory, 141
Reduced instruction set computer
(RISC), 119
Register, 101, 116
260
Index

S
Second memory, 145
Semiconductor memory, 137
Serial advanced technology attachment
(SATA), 126
Serial transmission, 24
Set associative mapping, 150
Seven-segment display, 89
Shift register, 101
Signed magnitude number, 12
Signed two’s complement, 12
Single character, 211
Single precision, 15
Small computer system interface (SCSI), 125
Small-scale integration (SSI), 34
Software layer, 132
Solid-state drive (SSD), 144
SPACE, 211
Spatial locality, 146
S-R latch, 98, 99
Stack pointer (SP), 165, 177, 181
State diagram
of D ﬂip-ﬂop, 106
Store instructions (STR), 187
Subtractor, 88
Sum of products (SOP), 58
Swap memory and register (SWAP), 191
Synchronous DRAM (SDRAM), 139
Synchronous sequential logic
analysis of, sequential logic, 104–106
applications of, 97
block diagram, 97, 98
counter, 108, 109
D ﬂip-ﬂop, 99–101
J-K ﬂip-ﬂop, 100, 102
S-R latch, 98
state diagram, 106
T ﬂip-ﬂop, 101
Synchronous transmission, 23
T
T ﬂip-ﬂop, 101
T ﬂip-ﬂop excitation table, 108
Temporal locality, 146
Translation lookaside buffer (TLB), 155
Transmission methods
parallel transmission, 24
serial transmission, 24
Transmission modes
asynchronous transmission, 22
synchronous transmission, 23
Tri-state device, 33
Truth table, 29–34, 37–39
Two’s complement, 11, 12
U
Unicode, 17, 20
Universal code/unicode, 17, 20
Universal gates
description, 61
logic functions, implementation of, 64
using NAND gates, 62, 64
using NOR gates, 63, 65
Universal serial bus (USB), 128
Unsigned number, 12
USB architecture
host controller, 129
hubs, 130
root hub, 130
USB architecture, 129
USB cable, 130
USB device, 130
V
Very-large-scale integration (VLSI), 29, 33, 36
Video electronics standard association (VESA)
bus, 127
Virtual address, 146
Virtual memory, 153, 154
von Neumann and Harvard architecture, 120
X
XOR gate, 32
Index
261

