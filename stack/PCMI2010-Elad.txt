Five Lectures on Sparse and
Redundant Representations
Modelling of Images
Michael Elad


IAS/Park City Mathematics Series
Volume 19, 2010
Five Lectures on Sparse and Redundant
Representations Modelling of Images
Michael Elad
Preface
The ﬁeld of sparse and redundant representations has evolved tremendously over
the last decade or so. In this short series of lectures, we intend to cover this progress
through its various aspects: theoretical claims, numerical problems (and solutions),
and lastly, applications, focusing on tasks in image processing.
Our story begins with a search for a proper model, and of ways to use it. We
are surrounded by huge masses of data, coming from various sources, such as voice
signals, still images, radar images, CT images, traﬃc data and heart signals just
to name a few. Despite their diversity, these sources of data all have something in
common: each and everyone of these signals has some kind of internal structure,
which we wish to exploit for processing it better.
Consider the simplest problem of removing noise from data. Given a set of
noisy samples (e.g., value as a function of time), we wish to recover the true (noise-
free) samples with as high accuracy as possible. Suppose that we know the exact
statistical characteristics of the noise. Could we perform denoising of the given
data? The answer is negative: Without knowing anything about the properties
of the signal in mind, this is an impossible task. However, if we could assume,
for example, that the signal is piecewise-linear, the noise removal task becomes
feasible. The same can be said for almost any data processing problem, such as de-
blurring, super-resolution, inpainting, compression, anomaly detection, detection,
recognition, and more - relying on a good model is in the base of any useful solution.
When approaching a problem in image processing, there is a wide range of
models to choose from, such as Principal Component Analysis (PCA), Anisotropic
diﬀusions, Markov Random Fields, Total-Variation, Besov spaces and many more.
There are two important (and sometime somewhat contradictory) requirements for
a model to be useful. On one hand, it should be reliable, in the sense that it should
be able to represent the data well. On the other hand, it has to be simple enough
to be applied in practice to the various tasks at hand.
A simple example of a model used in a common task can be found in the JPEG
algorithm. At its core, this algorithm relies on the claim that when transforming
patches of 8×8 pixels in a typical image using the Discrete Cosine Transform (DCT),
only the top-left (low frequency) components are dominant, while the rest are close
The Computer Science Department, the Technion, Haifa 32000, Israel
E-mail address: elad@cs.technion.ac.il
The author wishes to thank Dr. Matan Protter for the extensive help in writing these lecture-notes.
c
⃝2013 American Mathematical Society
161

162
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
to zero. This model is used for compression by discarding the non-dominant com-
ponents, thus using much fewer numbers for representing the image. While simple
and relatively eﬀective, one immediately sees potential failures of this model, and
ways to further improve it.
We therefore turn our attention to the model of ”Sparse and Redundant Rep-
resentations” and example-based methods, which will be the focus of this booklet
(and corresponding course). This model has many “fathers”, drawing from various
areas of research, such as signal processing (Wavelet theory, multi-scale analysis,
signal transforms), machine learning, Mathematics (approximation theory, linear
algebra, optimization theory) and more.
We will see that it can be applied to
various applications, such as blind source separation, compression, denoising, in-
painting, demosaicing, super-resolution and more.
What is this model all about? Let us focus on the task of representing signals,
which are 8×8 patches of images, as done above. We shall assume that a dictionary
of such image patches is given to us, containing 256 atom-images, each of which is
also 8 × 8. The Sparseland model assumption is that every image patch from the
family of interest could be constructed as a linear combination of few atoms from
the dictionary.
To represent a signal of length 64, this model uses 256 numbers, and therefore
it is redundant. However, of these 256 all but few are zero, and therefore the model
is sparse. Eﬀectively, if there are 3 atoms involved in the found combination, only 6
numbers are needed to accurately represent the signal using this model – the three
locations of the non-zeros, and their values.
While this model sounds near-trivial, it raises several very diﬃcult questions.
Given an image patch, can we ﬁnd what atoms it was built from? Given a set
of patches, how should we get the dictionary for them? Is this model applicable
to various signals? The ﬁrst question is problematic, as crunching the numbers
indicates that a search through every possible combination is unlikely to ﬁnish any
time soon, even for low-dimensional problems.
However, several approximation
algorithms have been proposed, with surprising guarantees on their performance.
The ﬁrst two lectures will focus on such algorithms and their theoretical anal-
ysis. The third lecture will discuss how this model and theoretical foundations are
brought to the realm of image processing. The second question can be addressed by
learning the dictionary from a large collection of signals. Such algorithms have been
developed in the past several years, and will be discussed in the fourth lecture. The
last question is yet to be answered from a theoretical point of view, but empirically,
this model is extremely eﬀective in representing diﬀerent sources of signals and in
various problems, leading to state of the art results, which will be demonstrated in
the ﬁfth and ﬁnal lecture.
Having answered the above three important questions positively, we are now
ready to dive into the wonderful world of sparse and redundant representation
modelling of images, or Sparseland. For extensive coverage of this area, the reader
is encouraged to turn to my book:
M. Elad, Sparse and Redundant Representations:
From Theory to Applications in Signal and Image
Processing, Springer, New-York, 2010, ISBN: 978-
1-4419-7010-7
(http://www.springer.com/978-1-
4419-7010-7).

MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
163
I would like to take this opportunity and thank Springer for their permission to pub-
lish these lecture-notes with PCMI. It should be noted that the copyright of some of
the material here (e.g. the ﬁgures in Chapters 4 and 5) belongs to Springer. Finally,
the reader will ﬁnd it useful to read these lecture-notes while looking at the slides:
http://www.cs.technion.ac.il/˜elad/talks/2010/Summer-School-2010-PCMI.rar.


LECTURE 1
Introduction to sparse approximations -
algorithms
1. Motivation and the sparse-coding problem
We start our journey with a pure linear algebra point of view, and speciﬁcally by
considering a linear under-determined set of equations,
(1.1)
Dn×kα = x , k > n.
In order to simplify the following developments, we will assume that the columns
of D are (ℓ2) normalized.
Now, as for terminology used: We shall refer hereafter to x as a signal to be
processed, and α will stand for its representation. The matrix D will be referred to
as the dictionary, and its columns will be called atoms.
Assuming D is full rank, there is an inﬁnite number of solutions to this equation.
In engineering, such a situation is unacceptable, since we aim to get a single solution
to our problems.
In order to be able to choose the “best” single solution, we
require some quality measure J (α) that basically ranks the solutions based on
some measure, this way choosing the solution that solves the problem
(1.2)
ˆα = arg min
α J(α) s.t. Dα = x.
Of course, the natural question is how to select J properly. In engineering, the most
common answer is some quadratic term J(α) = ∥Bα∥2
2, as it is easy to minimize,
having a closed form solution. When chosen as a non-quadratic term, J is preferred
to be convex in order to ensure the existence of a unique global minimum to the
above problem. Of course, in many cases such choices are not aligned with our
needs, as we shall see next.
In these lectures we are interested in cases when α is sparse. In order to gain
a mathematical intuition, we consider the general ℓp-norm, J(α) = ∥α∥p
p. This
expression sums the absolute entries of the vector α after being raised to a power
p. Note that when p drops below 1 it is no longer a norm, but we shall disregard
this technicality.
When p goes below 1 and approaches zero, the function |αi|p resembles the
indicator function, being 1 for every αi ̸= 0, and 0 for αi = 0. Eﬀectively, we deﬁne
the ℓ0-norm, as a function counting the number of non-zeros in α and denote it by
∥α∥0
0. While ℓ0 is deﬁnitely not a norm, we will abuse this notation for simplicity.
We also deﬁne the term Support as the locations of non-zeros in α. We therefore
write the minimization problem (P0):
(1.3)
(P0) ˆα = arg min
α ∥α∥0
0 s.t. Dα = x.
165

166
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
In many cases our system might contain noise, and we cannot expect a perfect
solution to the linear system Dα = x. Instead, we require some proximity between
Dˆα and x, arriving at the following alternative problem:
(1.4)
(P ǫ
0) ˆα = arg min
α ∥α∥0
0 s.t. ||Dα −x||2 ≤ǫ,
where ǫ is closely related to the properties of the noise. We will be seeing this
minimization problem many times during the course.
In order to understand the complexity of the above deﬁned problem, let us
propose a method to perform this minimization in a direct way. Set L = 1, and
consider all supports {Si}I
i=1 of cardinality L (there are I =
 k
L

such supports).
For each support, we attempt to represent x using only columns from D in the
support. This can be done by solving a simple Least-Squares (LS) problem,
min
α ||Dα −x||2 s.t. Sup(α) = Sj.
If the result LS error is below the threshold ǫ, than we have found a solution and
can terminate. If none of the supports yields a solution with an error below the
threshold, L should be incremented and the process should be repeated.
Taking a nominal case where k = 2000, and a known support size L = 15 (so
searching the value of L is not needed), and requiring a mere 1 nano-second for each
LS operation, solving just one problem will take about 7.5 · 1020 years. This is due
to the exponential nature of the problem. Indeed, the problem posed in Equation
(1.4) is known to be NP-Hard [41]. This limitation leads us to seek approximation
algorithms for these two problems, (P0) and (P ǫ
0).
There are two main approaches to approximate the solution to the problem
posed in Equation (1.4), which we will explore in this lecture. The ﬁrst approach is
the greedy family of methods, where we attempt to build the solution one non-zero
at a time. The second approach is the relaxation methods, which attempt to solve
the problem by smoothing the ℓ0-norm and using continuous optimization tech-
niques. All these techniques that aim to approximate the solution of the problem
posed in Equation (1.4) are commonly referred to as pursuit algorithms.
While this lecture will be devoted to the various approximation algorithms, the
next lecture will discuss in depth the quality of the estimations they provide. The
second lecture will also discuss conditions that should be met in order to ensure
that (P0) has a unique solution, and (P ǫ
0) has a stable solution (as we shall see, we
will not be able to require uniqueness due to the noise).
2. Greedy algorithms
Our ﬁrst journey into approximation algorithms will deal with the family of greedy
algorithms.
These algorithms attempt to build the support of α one non-zero
element at a time. There is a variety of greedy techniques – see [22, 3, 9, 38, 40, 42]
for more details.
The most basic of algorithm is the Matching Pursuit (MP). This is an iterative
algorithm that starts by ﬁnding the one atom that best describes the input signal,
i.e., ﬁnding the index ˆi = arg mini minc ||x −c · di||2
2. Once found, we compute the
signal residual as x −c · di with the optimally found constant c and the atom di.
Then, at each iteration, the one atom that best describes the residual is added
to the support, with the appropriate coeﬃcient contributing to reducing the residual
the most. This process is repeated until the norm of the threshold drops below the

LECTURE 1. INTRODUCTION TO SPARSE APPROXIMATIONS - ALGORITHMS
167
given threshold. Note that the same atom may be added to the support several
times – in such cases, its corresponding coeﬃcient is aggregated.
The Orthogonal Matching Pursuit (OMP) is an improvement of the MP. The
OMP re-computes the set of coeﬃcients for the entire support each time an atom is
added to the support. This stage speeds up the convergence rate, as well as insures
that once an atom has been added to the support, it will not be selected again.
This is a result of the LS stage, making the residual orthogonal to all atoms in the
chosen support.
A further improvement to the OMP observes that the atom selection stage does
not completely correspond to the objective of reducing the residual (because of the
LS stage). Therefore, this version suggests to select the atom that will best reduce
the residual after the LS stage. This method is accordingly known as LS-OMP.
While LS-OMP seems to require more computations, there are some numerical
short-cuts to employ, which bring the eﬃciency of this method very close to that
of the OMP.
While improving the results of the MP, both the OMP and the LS-OMP require
more complex implementations and more calculations.
The other direction, of
simplifying the MP, has been attempted too, with the goal of reducing the amount
of computations needed at each stage. The Weak-MP is born from the observation
that in the MP, it is probably not necessary to ﬁnd the atom that most reduces the
residual, but an atom that can come close to this performance might do as well.
As a result, the atoms are scanned in order, and as soon as an atom is found to
reduce the residual by some threshold (or beyond), it is added to the support and
the iteration ends.
A further simpliﬁcation can be obtained by avoiding the search at each stage
completely, and instead determine the order in which atoms are to be added in
advance. Such an algorithm is called the Thresholding algorithm. In this method,
the inner product between the signal and all the atoms are computed, and then
sorted in descending order of magnitude. This order determines the order in which
atoms will be added to the support. At each iteration, the next atom is added to
the support, and LS over the support is carried out to best represent the signal (this
can be done using recursive least-squares, which avoids a direct matrix inversion).
As soon as the norm of the residual drops below the given threshold, the process
terminates.
3. Relaxation algorithms
In the previous section we reviewed the greedy algorithms, which attempt to con-
struct the support one atom at a time. Now it is time to turn to relaxation methods,
that smooth the ℓ0-norm and solve the alternative obtained problem using classical
methods from continuous optimization [22, 3].
One natural way to do this is to replace the ∥α∥0
0 penalty with the expression
PK
i=1

1 −exp
 −βα2
i

, and observe that as β →∞, this term better approximates
the ℓ0 norm. Therefore, it is possible to approximate the ℓ0 solution by optimizing
for a small value of β, and increase the value of β every few iterations.
An alternative is to “convexise” the ℓ0-norm, which brings us to the Basis
Pursuit (BP) algorithm [7]. In this algorithm, the ℓ0-norm is simply replaced by

168
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
the ℓ1-norm, leading to the optimization problem
(1.5)
min
α ∥α∥1 s.t. ∥Dα −x∥2 ≤ǫ,
with the hope that the solution of this optimization problem is close to the solution
of the original one. This problem can be formulated as linear programming for the
exact case (ǫ = 0), and quadratic programming for the general case. For this task,
several types of eﬃcient solvers can be employed, such as Interior Point methods
[33], Least-Angle-Regression (LARS) [20] and Iterative Shrinkage [8, 21, 24, 25,
26, 27].
Another interesting option for handling the problem formed above (either (1.4)
or (1.5)), is the Iterative Reweighted Least-Squares (IRLS). Before explaining this
algorithm, we slightly change the formulation of the problem. Instead of enforcing
the constraint ∥Dα −x∥2 ≤ǫ, we now insert it into the optimization problem:
(1.6)
min
α
λ · ∥α∥p
p + ∥Dα −x∥2
2,
with λ balancing the eﬀects of both terms. A proper choice of λ makes the two for-
mulations equivalent. Notice that our formulation uses the ℓp-norm, thus covering
both cases posed in Equations (1.4) or (1.5).
Now, let us re-write the ﬁrst term:
(1.7)
∥α∥p
p =
k
X
i=1
|αi|p =
k
X
i=1
|αi|p−2 · |αi| = αT A (α) α.
Based on this, we can suggest an iterative optimization scheme in which we freeze
A (α), and minimize for α:
(1.8)
ˆαj+1 = arg min
α λαT A (αj) α + 1
2∥Dα −x∥2
2.
This is a quadratic term, and as such, it is easy to minimize. In the following step,
we freeze αj+1 and compute A (αj+1), and so on, until the solution converges. More
on the IRLS (sometimes called FOCUSS) can be found in [28].
In the previously described algorithm, our only demand of the residual is that
its norm is bounded. However, in the general case, we expect the residual not only
to be bounded, but we also expect it to look like noise. In other words, we expect
the residual to show low correlation with any of the atoms in the dictionary. This
observation leads to the formulation of the Dantzig Selector (DS) [6]:
(1.9)
min
α ∥α∥1 s.t. ∥DT (Dα −x) ∥∞≤T.
Interestingly, this is a linear programming task even in the noisy case (unlike the BP,
which leads to a quadratic programming problem in the noisy case), and therefore
a wide range of tools can be used for solving it.
Simulations comparing the performance of the DS with those of the BP (see
[22]) show that these two algorithm perform (on average) at the same level. It is
well known that in the unitary case, the two are perfectly equivalent.
4. A closer look at the unitary case
What happens in the special case where the dictionary D is unitary, i.e., DT D = I
(the dictionary is of course not redundant in such a case)? Starting from the prob-
lems posed in Equations (1.4) and (1.5), let us write a more general optimization

LECTURE 1. INTRODUCTION TO SPARSE APPROXIMATIONS - ALGORITHMS
169
goal,
(1.10)
f (α) = 1
2∥Dα −x∥2
2 + λ · ρ (α)
where we use a general function ρ (α) = Pk
j=1 ρ(αj) measuring the “quality” of the
solution. This could be the ℓ0 pseudo-norm, the ℓ1-norm or any other separable
choice of penalty. Exploiting the fact that D is unitary, we get
f (α) = 1
2∥Dα −x∥2
2 + λ · ρ (α) = 1
2∥Dα −DDT x∥2
2 + λ · ρ (α)
= 1
2∥D (α −β) ∥2
2 + λ · ρ (α) = 1
2∥α −β∥2
2 + λ · ρ (α) .
(1.11)
The ﬁrst transition employed the unitary property, DDT = I.
The second is
done by denoting β = DT x. The last transition is due to the fact that the ℓ2-
norm is invariant to a unitary transformation. Since ρ() works on each entry of α
independently, we can ﬁnally write
(1.12)
f (α) =
k
X
j=1
1
2 (αj −βj) + λ · ρ (αj)

,
which indicates that this problem is separated into k easy to solve scalar optimiza-
tion problems.
As the problem becomes a set of independent 1-D problems, it is possible to
compute the output ˆα for any input value of β, eﬀectively forming a lookup table.
Plotting this graph generally looks like a shrinkage curve1 that nulls the small
entries and the large ones intact. Of course, such a graph can be created for any
penalty function ρ and value λ.
4.1. ℓ0 and greedy algorithms for unitary dictionaries
When working with the ℓ0, the function ρ is the indicator function, ρ(αj) = |αj|0.
Therefore, the independent optimization problem to solve is
(1.13)
αopt
j
= arg min
αj
1
2 (αj −βj)2 + λ · |αj|0

.
This is a very simple task - there are only two logical options for the value of αj.
Either αj = βi, paying λ for the second term, or αj = 0, and paying 1
2β2
j in the
ﬁrst term. Any other value will result in a necessarily larger penalty.
Therefore, the shrinkage curve for this case is very simple. For |β| <
√
2λ, we
choose α = 0, while for |β| ≥
√
2λ, we choose α = β. Therefore, this method is
known as Hard-Thresholding, as any coeﬃcient below the threshold
√
2 · λ is set to
zero, while every coeﬃcient above this threshold remains untouched. This solution
is the global minimizer of the problem we tackled.
It is possible to show that when the dictionary is unitary, all the greedy al-
gorithms we have seen (thresholding, OMP, LS-OMP, weak-OMP, MP) obtain the
exact solution, which is the one obtained by the hard-thresholding algorithm de-
scribed here. Just to illustrate this, the thresholding algorithm will compute DT x,
and work on the coeﬃcients in descending order of magnitude. The amount of
atoms it will choose is exactly those that the hard-thresholding will leave intact,
1The name comes from the fact that the resulting value of ˆα is always smaller or equal to the
input β.

170
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
i.e., the amount of atoms above the threshold. The OMP does the same, simply
choosing one atom at a time. Since the dictionary is unitary, adding another atom
to the support does not eﬀect the inner products of the residual with the remaining
atoms.
4.2. Relaxation algorithms for unitary dictionaries
The basis pursuit uses the ℓ1 -norm as a penalty on α. In the unitary case, this
leads to separate optimization problem of the form
(1.14)
αopt
j
= arg min
αj
1
2 (αj −βj)2 + λ · |αj|

.
Analyzing this problem, it turns out that the solution becomes
(1.15)
αopt
j
=



βj −λ
βj > λ
0
|βj| ≤λ
βj + λ
βj < −λ
The curve this solution implies is known as soft-thresholding, as when the coeﬃcient
is above the threshold it does not remain the same (as in the hard-thresholding),
but is made smaller instead.
The Dantzig Selector tries to solve an alternative problem (1.9). When we use
the unitary property, it becomes
ˆα = min
α ∥α∥1 s.t. ∥DT (Dα −x) ∥∞= min
α ∥α∥1 s.t. ∥α −DT x∥∞,
= min
α ∥α∥1 s.t. ∥α −β∥∞,
(1.16)
where in the ﬁrst transition we used DT D = I, which is the unitarity property,
and in the second transition simply re-introduced the notation of β. The last step
results in K independent optimization problems of the form:
(1.17)
arg min
αi |αj| s.t. |αj −βj| ≤T
It is not diﬃcult to see that the solution of this optimization problem is exactly
identical to the solution oﬀered for the BP algorithm in (1.15). The conclusion is
that BP and DS are exactly identical when the dictionary is unitary, and both of
them can be solved using a closed-form formula for each of the coeﬃcients (such
that they do not require a complex optimization procedure).
4.3. Unitary dictionaries - summary
We have seen that when the dictionary is unitary, both families of algorithms enjoy
a simple closed-form solution. Given the signal x, multiply it by the dictionary to
obtain a vector of coeﬃcients β = DT x. On each of the coeﬃcients, apply inde-
pendently a Look-Up Table operation with a shape that depends on ρ and λ, and
this results in the vector of coeﬃcients ˆα. This simple procedure yields the global
optimum of f(α), even if f itself is not convex. This leads to the obvious question
– can this be used to gain an insight to the general case, when the dictionary is
non-unitary? Can we use it to construct simpler, more eﬀective algorithms for such
cases? In the 4th lecture we will see a family of algorithms doing exactly that.

LECTURE 2
Introduction to sparse approximations - theory
This lecture deals with the theory of sparse approximations. We will start by
deﬁning several properties of dictionaries - the Spark, the Mutual-Coherence, and
the Restricted Isometry Property (RIP). We will then show theoretical guarantees
for the uniqueness of the solution for (P0), and show the equivalence of MP and
BP for the exact case. We will then continue with the discussion of (P ǫ
0), and show
theoretical guarantees on the stability of the solution. Finally, we will mention
brieﬂy results related to near-oracle performance of pursuit techniques in the noisy
case.
1. Dictionary properties
The purpose of this section is ﬁnding ways to characterize the dictionary D, in order
for us to be able to make claims about the conditions under which pursuit algorithms
are guaranteed to succeed. Ideally, we would like these bounds to be tight, and the
characterizations easy to compute. As we will see, this is not necessarily the case.
1.1. The matrix spark
The Spark was deﬁned by Donoho & Elad [14] (similar deﬁnitions have been made
in tensor decomposition by Kruskal [34, 35] as well as in coding theory):
Deﬁnition 2.1 (Spark). Given a matrix D, σ = Spark (D) is the smallest number
of atoms from D that are linearly dependent.
While this deﬁnition is likely to remind the reader of the deﬁnition of the rank
of a matrix, it is very diﬀerent. There are two diﬀerences between the deﬁnitions -
while the rank is the largest number of independent atoms, the Spark is the smallest
number of dependent atoms. For an example, consider the matrix
D =




1
0
0
0
1
0
1
0
0
1
0
0
1
0
0
0
0
0
1
0




The rank of this matrix is 4, the maximal number of independent columns (e.g.,
the ﬁrst four columns). The Spark of this matrix is 3: one column could only be
linearly dependent if it is the zero vector; Any two columns in this dictionary are
linearly independent; There is a group of three columns - the ﬁrst, second and last
- that are linearly dependent. Therefore, σ (D) = 3.
It is easy to observe that for a dictionary Dn×k, the Spark satisﬁes 1 ≤σ ≤
n+1. Also, if for some non-trivial vector v it exists that Dv = 0, than is is certain
that ∥v∥0
0 ≥σ, since the support of v constitutes a linearly dependent set of atoms.
Since the smallest possible such set is σ, the support of v also contains at least σ
atoms.
171

172
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
1.2. The mutual coherence
Deﬁnition 2.2 (Mutual Coherence). For a matrix D, the Mutual-Coherence M
is the largest (in magnitude) oﬀ-diagonal element of the Gram matrix of D, i.e.,
G = DT D.
For this deﬁnition, we assume that the columns of D are normalized. The
Mutual-Coherence measures the maximal similarity (or anti-similarity) between two
columns on the dictionary. Therefore, its value ranges between 0 (an orthonormal
basis) and 1 (when there are two identical atoms). As we will see later, a large
mutual coherence is bad news for our algorithms, as the algorithms are likely to
confuse between the two atoms.
1.3. The relationship between the spark and the mutual coherence
Our next task is to understand the relationship between the Spark and the Mutual
Coherence measures. In order to do that, we need the following well-known theorem:
Theorem 2.1 (Gershgorin’s Disk Theorem). Consider a general square matrix
A, and deﬁne the k′th disk as diskk =
n
x
|x −akk| ≤P
j̸=k |ajk|
o
. Then, the
eigenvalues of A all lie in the union of all disks, {λ1, λ2, .., λn} ⊂∪k=1..ndiskk.
Alternatively, we can write λmin ≥arg min1≤k≤n
n
akk −P
j̸=k |ajk|
o
and
λmax ≤arg max1≤k≤n
n
akk + P
j̸=k |ajk|
o
. One of the implications of the theorem
is that if A is diagonally dominant (assuming real entries), than A is necessarily
positive deﬁnite. This is because the origin is not in any of the disks, and therefore
all eigenvalues are positive. Using this theorem, we are now ready to make the
following claim:
Theorem 2.2 (Relation between Spark and Mutual Coherence). σ ≥1 + 1
M
Proof. Let us consider a group of columns S from D, and compute its sub-
Gram matrix.
We know that these columns are independent, if this matrix is
positive deﬁnite. From the Gershgorin’s disk theorem, we know that the matrix
will be positive deﬁnite if it is diagonally dominant.
The Mutual-Coherence bounds any oﬀ-diagonal element by M, while the diago-
nal elements are all 1. Therefore, the matrix is diagonally dominant if (S −1) M <
1. As long as S < 1 + 1/M, any group of S columns are independent. Therefore,
the minimal number of columns that could be dependent is S = 1 + 1/M, and this
is exactly the claimed result.
□
1.3.1. Grassmanian Frames. We now turn to deal with the following question: For
a general matrix Dn×k, with k > n, what is the best (smallest) Mutual-Coherence
we can hope for? Obviously, it can’t be zero, as that would mean that there are
k columns that are orthogonal, and that is not possible when their length is n. It
turns out that
(2.1)
Mmin =
s
k −n
n (k −1) = O
 1
√n

,
with the second step using the substitution k = ρn, and the approximation is true
for small values of ρ (e.g., 2,3). We will omit the proof, and only state that this
question is closely related to questions about packing vectors in the n-dimensional

LECTURE 2. INTRODUCTION TO SPARSE APPROXIMATIONS - THEORY
173
space in the most spacious ways. As an example, for a matrix with n = 50 rows
and k = 100 columns, the minimal possible coherence is roughly 0.1.
Can matrices achieving this bound be found in practice? The answer is yes,
and this family of matrices is known as Grassmanian Frames [49]. The prevailing
property of these frames is that the oﬀ-diagonal elements in their Gram-matrices
all have the same magnitude. They are diﬃcult to built, and a numerical algorithm
by Tropp has been developed for their construction [52]. It is important to note,
however, that for some pairs of n and k such frames do not exist.
1.4. The restricted isometry property
Deﬁnition 2.3 (Restricted Isometry Property). Given a matrix D, consider all
s-sparse vectors α, and ﬁnd the smallest value δs that satisﬁes
(1 −δs) ∥α∥2
2 ≤∥Dα∥2
2 ≤(1 + δs) ∥α∥2
2.
D is then said to have an s-RIP with a constant δs.
What is the meaning of this deﬁnition? Dα combines linearly atoms from D.
The RIP suggests that every such group of s atoms behaves like an isometry, i.e.,
does not considerably change the length of the vector it operates on.
As an example, when D is unitary, the length does not change for any s.
Therefore, δs(D) = 0, for every s. In this sense, the RIP asks how close is D to a
unitary matrix, when considering multiplications by s-sparse vectors.
1.5. The RIP and the mutual coherence
Let us denote DS as the sub-matrix of D containing only the columns in the support
S, and similarly, αS as containing only the non-zeros in α, so DSαS = Dα. Using
this terminology, the RIP property states that
(1 −δs) ∥αS∥2
2 ≤αT
SDT
SDSαS ≤(1 + δs) ∥αS∥2
2.
On the other hand, from an eigenvalue perspective, we know that
∥αS∥2
2 · λmin
 DT
SDS

≤αT
SDT
SDSαS ≤∥αS∥2
2 · λmax
 DT
SDS

.
From the Gershgorin’s theorem we already know that
λmin
 DT
SDS

≥1 −(s −1) M
λmax
 DT
SDS

≤1 + (s −1) M,
and ﬁnally, we see that
(2.2)
δs ≤(s −1) M.
1.6. The RIP and the spark
Suppose that the Spark of D is known to be σ. Then, for s = σ, there is at least
one vector α of cardinality s such that Dα = 0, therefore indicating that δσ = 1.
Furthermore, for any value of s < σ, it follows that δs < 1.
1.7. Computing the spark, the MC and the RIP
Summarizing the discussion so far, we consider the question of computing the above
described properties. The Spark requires going through each and every support and
checking for linear dependence. Thus, it is impossible to compute in general as it
is combinatorial. There is an exception, however, as a random iid matrix has a full
Spark of (n + 1).

174
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
The RIP similarly has to scan all supports, and is therefore also impossible
to compute in practice.
There is also an exception here as well, in the case of
a random Gaussian matrix, the RIP can be bounded (with high probability) by
δs ≤C ·
q
s
n · log
  k
s

. The C is a coeﬃcient controlling the probability – as the
required conﬁdence grows, so does the constant C, making the bound less tight.
Fortunately, the Mutual Coherence is very easy to compute, as we have seen
- it only requires computing the Gram matrix, and scanning all elements in it.
Unfortunately, as this measure only quantiﬁes pairs of atoms, it is also the weakest
of the three measures.
Lastly, it is important to note that all of the measures introduced are of worst-
case nature, and as such lead to worse-case performance analysis of algorithms.
For example, it is enough that the dictionary contains a duplicate atom to set the
Mutual Coherence to 1. The rest of the dictionary can behave perfectly, but that
will be unknown to the coherence. The Spark and the RIP will also suﬀer in such
a case in a similar fashion. Diﬀerent types of measures are needed for average-case
performance analysis, but such measures are still very much missing.
2. Theoretical guarantees - uniqueness for P0
After the introduction of some tools to be used, we now turn to the ﬁrst problem
of interest. Suppose Alice holds a dictionary D, and generates some sparse vector
of coeﬃcients α. Multiplying the two, Alice generates the signal x = Dα. Then,
Alice contacts her friend, Bob, and gives him the dictionary D and the vector x,
and asks him to ﬁnd the vector α she had used.
Bob knows that α is sparse, and so he sets out to seek the sparsest possible
solution of the system Dα = x, namely, solve the optimization problem
ˆα = arg min
α ∥α∥0
0 s.t. Dα = x.
For the time being, we shall assume that Bob can actually solve this problem exactly
(we have seen in the ﬁrst lecture that this is generally NP-hard, and therefore
impossible in practice). The question we want to ask is if (or when) can we expect
that ˆα = α. It might turn our that ˆα is even sparser than the original α. This is
essentially the question of uniqueness – what properties must α and the dictionary
D have so that α is the sparsest vector to create x? The answer turns out to be
quite simple [14]:
Theorem 2.3 (Uniqueness Requirements of P0). The following two claims deﬁne
the uniqueness condition and implication:
(1) Suppose we have found a sparse solution ˆα that satisﬁes Dˆα = x. If this
solution satisﬁes ∥ˆα∥0
0 < σ/2, then this this solution is unique (i.e., it is
the sparsest solution possible).
(2) If Alice generated a signal with ∥α∥0
0 < σ/2, than Bob is able to recover α
exactly: ˆα = α.
Proof. Suppose we have found two candidate solutions α1 and α2 to the linear
system of equations Dα = x, leading to Dα1 = Dα2 and D (α1 −α2) = 0. From
the Spark property, the cardinality of any vector v that satisﬁed Dv = 0 is at least
the Spark, indicating that
(2.3)
∥α1 −α2∥0
0 ≥σ.

LECTURE 2. INTRODUCTION TO SPARSE APPROXIMATIONS - THEORY
175
We can also observe that
(2.4)
∥α1∥0
0 + ∥α2∥0
0 ≥∥α1 −α2∥0
0.
This property can be understood by analyzing the supports of both vectors. If there
is no overlap in their supports, then the equality holds. If there is an overlap, and
two terms in the overlap happen to cancel each other exactly, then the resulting
support is smaller than the sum of sizes of the two supports. We can refer to this
property as some sort of triangle inequality of the ℓ0, even though it is not actually
a norm.
Combining the two inequalities, it turns out that the sum of cardinalities of
both vectors is at least the Spark,
(2.5)
∥α1∥0
0 + ∥α2∥0
0 ≥σ.
This can be viewed as an uncertainty principle – two solutions cannot be jointly
very sparse. If one solution is indeed sparse, the other must be non-sparse. The
uncertainty principle implies that if we have found a solution α1 with cardinality
less than half the Spark, i.e., α1 < σ/2, than every other solution α2 must have
a cardinality of more than half the Spark, in order to fulﬁll the requirement that
∥α1∥0
0 + ∥α2∥0
0 ≥σ. Therefore, α is sparser than any other solution, and indeed,
the sparsest solution.
It directly follows that if Alice chose α such that ∥α∥0
0 < σ/2, than it is the
sparsest solution to Dα = x, and therefore Bob will recover it exactly.
□
3. Equivalence of the MP and BP for the exact case
Now we turn to walk in Bob’s shoes. We have seen that Bob’s task is impossible
to solve directly, and therefore he has to turn to approximation algorithms, such
as Orthogonal Matching Pursuit (OMP)—, Basis Pursuit (BP), etc. The question
we ask now is: Is there any hope that any of these algorithms will actually recover
the exact solution?
Surprisingly, we will see that under some conditions, these
algorithms are guaranteed to succeed.
3.1. Analysis of the OMP
Recall the OMP algorithm, introduced in lecture 1. To make our life easier, we
assume that the s non-zero locations in α are in the ﬁrst s locations. Furthermore,
we assume that these coeﬃcients are sorted in decreasing order of magnitude, with
|α1| ≥|α2| ≥.. ≥|αs| > |αs+1| = 0. Thus, our signal can be written as x =
Ps
i=1 αidi. This assumption does not eﬀect the generality of our claims, as we
can achieve this structure by reordering the columns of D and the locations of the
non-zeros in α. The re-structured problem remains equivalent to the original one.
We now ask ourselves what conditions are needed for the ﬁrst OMP step to
succeed, i.e., that the ﬁrst atom added to the support is an atom in the true
support (one of the ﬁrst s atoms)?
Since the OMP selects the atom with the
largest magnitude inner-product, the ﬁrst step succeeds if
(2.6)
xT d1
 > max
j>s
xT dj
 .
This condition guarantees that the atom selection will prefer the ﬁrst atom to any
atom atom outside the support, and thus guarantees that an atom in the true
support is chosen. It may happen that another atom in the true support is chosen

176
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
instead of the ﬁrst, but this is also considered as a success. Therefore, the question
we want to answer is when does the condition (2.6) hold.
In order to ﬁnd out under what conditions this inequality is satisﬁed, we lower
bound the left-hand-side (LHS), and upper bound the right-hand-side(RHS). We
will then ﬁnd the conditions for the bound on the LHS still being greater than the
upper bound of the RHS, thus fulﬁlling the original inequality as well.
We start with an upper-bound of the Right-Hand-Side (RHS):
(2.7)
max
j>s
xT dj
 = max
j>s

s
X
i=1
αidT
i dj
 ≤max
j>s
s
X
i=1
|αi| ·
dT
i dj
 ≤|α1| · s · M.
The ﬁrst transition assigns the expression x = Ps
i=1 αidi, the second uses the prop-
erty |a + b| ≤|a| + |b|, and the third uses the deﬁnition of the Mutual-Coherence as
an upper bound on
dT
i dj
, as well as the monotonicity of the coeﬃcients, implying
that |αk| ≤|α1| for k = 2, .., s.
We now turn to lower-bound the Left-Hand-
Side(LHS) in inequality (2.6):
xT d1
 =

s
X
i=1
αidT
i d1
 =
α1 +
s
X
i=2
αidT
i d1
 ≥|α1| −

s
X
i=2
αidT
i d1

≥|α1| −
s
X
i=2
|αi| ·
dT
i d1
 ≥|α1| · [1 −(s −1) · M] .
(2.8)
The transitions in the ﬁrst line are made by ﬁrst substituting x = Ps
i=1 αidi and
then using the fact that the atoms are normalized, i.e., dT
1 d1 = 1.
Then, the
bounding starts by the reversed triangle inequality |a + b| ≥|a| −|b|, and then
repeating the steps performed in bounding the RHS (note that since the second
term is with a negative sign, increasing its magnitude reduces the magnitude of the
overall expression).
Using the bounds in (2.7) and (2.8) and plugging them into (2.6), we get that
a condition that guarantees that the ﬁrst OMP step succeeds is
xT d1
 ≥|α1| · [1 −(s −1) · M] > |α1| · s · M ≥max
j>s
xT dj
 ,
which leads to the following bound on the cardinality of the representation,
(2.9)
s < 1
2

1 + 1
M

.
Assuming this condition is met, the ﬁrst atom chosen is indeed an atom from
the true support, with index i∗. Then, a LS step is performed, and a coeﬃcient
value α∗
1 is assigned to this atom. Now, we look at the residual as our new signal,
being
r1 = x −α∗
1di∗=
s
X
i=1
αidi −α∗
1di∗.
This signal has the same structure we the one we started with – a linear combination
of the s ﬁrst atoms. This means that the exact same condition is needed for the
second step to succeed, and in fact, for all other steps to succeed as well.
This means, that if s < 1
2

1 + 1
M

the OMP is guaranteed to ﬁnd the correct
sparse representation. This is done in exactly s iterations, as in each iteration one
atom in the support is chosen, and due to the LS stage, the residual is always
orthogonal to the atoms already chosen.

LECTURE 2. INTRODUCTION TO SPARSE APPROXIMATIONS - THEORY
177
Using this result, and the bound we have found in the previous section regarding
the Spark, we come to the following conclusion:
Theorem 2.4 (OMP and MP Equivalence). Given a vector x with a representation
Dα = x, and assuming that ∥α∥0
0 < 0.5 (1 + 1/M), then (i) α is the sparsest possible
solution to the system Dα = x, and (ii) OMP (and MP) are guaranteed to ﬁnd it
exactly [50, 16].
3.2. Analysis of the BP
We now turn to perform the same analysis for the BP, checking under which
conditions are we guaranteed to succeed in recovering the sparsest solution. We
remind ourselves that the BP aims to approximate the solution of the problem
ˆα = arg minα ∥α∥0
0 s.t. Dα = x, by solving instead ˆα = arg minα ∥α∥1 s.t. Dα = x.
Therefore, our aim is now to show under which condition is the sparse vector α
used to generate the signal x also the shortest one with respect to the ℓ1 norm.
The strategy for this analysis starts by ﬁrst deﬁning the set of all solutions for
the linear set of equations Dβ = x (excluding the one we started with), such that
their ℓ1 length is shorter (or equal) to the length of the original vector α,
(2.10)
C = {β ̸= α |x = Dα = Dβ and ∥β∥1 ≤∥α∥1 } .
We will gradually inﬂate this set, while simplifying it, eventually showing that it
is still empty. When done, this will imply that the initial set is also empty, and
therefore α is the result of the ℓ1 minimization, leading to α being the vector with
the shortest ℓ1 norm, therefore recovered by the BP.
Our ﬁrst step starts with deﬁning the vector e = β −α, or in other words,
e + α = β. Our set remains unchanged, and is simply rewritten as
(2.11)
Ce = {e ̸= 0 |0 = De and ∥α + e∥1 −∥α∥1 ≤0} .
Next, we simplify the linear constraint 0 = De,
{e |0 = De} =

e
0 = DT De
	
=

e
−e =
 DT D −I

e
	
⊆

e
|e| =
 DT D −I

e
	
⊆

e
|e| ≤
DT D −I
 · |e|
	
⊆

e
|e| ≤M ·
 11T −I

· |e|
	
= {e |(1 + M) · |e| ≤M∥e∥1 }
The transition from the ﬁrst row to the second is done by taking absolute value of
both sides (an absolute value of a vector is done element-wise). Obviously, some new
e’s have been added to the set, as we are no longer forcing the sign equality, implying
that the set becomes larger. The next step stems from the triangle inequality. The
transition between the third and fourth lines is slightly more complex. Observe
that the matrix DT D is eﬀectively the Gram Matrix, and all oﬀ-diagonal elements
of it are bounded by M.
Furthermore, the matrix
 DT D −I

has zeros along
the main diagonal, and all remaining elements are still bounded by M. Observing
that 11T is a matrix of the proper size, all containing ones, than M
 11T −I

is
a matrix containing zeros on the diagonal, and M on the oﬀ-diagonal terms. Thus
DT D −I
 ≤M ·
 11T −I

element-wise. This way, we no longer need D directly,
instead characterizing it using only its Mutual-Coherence.

178
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
The last step re-orders the elements, and uses 1T |e| = ∥e∥1. Replacing the
linear constraint in (2.11) with the one derived above, we obtain an inﬂated set
(2.12)
Ce ⊆

e ̸= 0
|e| ≤
M
M + 1 · ∥e∥1 and ∥α + e∥1 −∥α∥1 ≤0

Now we turn to handle the second constraint, ∥α + e∥1 −∥α∥1 ≤0,
{e |∥α + e∥1 −∥α∥1 ≤0} =
(
e

K
X
i=1
(|αi + ei| −|αi|) ≤0
)
=
(
e

s
X
i=1
(|αi + ei| −|αi|) +
X
i>s
|ei| ≤0
)
⊆
(
e

X
i>s
|ei| −
s
X
i=1
|ei| ≤0
)
=

e
∥e∥1 −2 · 1T
s |e| ≤0
	
.
The ﬁrst step simply writes the ℓ1 norm as a sum of elements, and the second
step uses the knowledge that only the ﬁrst s coeﬃcients in α are non-zeros (as we
have assumed earlier). The third term uses a version of the triangle inequality,
|x + y|−|x| ≥−|y|. Using this replacement, each term in the sum is made smaller,
thus inserting more possible e’s into the set. The last step merely rewrites the
expression, since P
i>s |ei| −Ps
i=1 |ei| = PK
i=1 |ei| −2 · Ps
i=1 |ei| = ∥e∥1 −2 · 1T
s |e|,
with 1s denoting a vector of length k with the ﬁrst s elements being 1-es and the
remaining elements being 0-es.
Plugging this inﬂated group into our deﬁnition of the group Ce in (2.12), we
arrive at
(2.13)
Ce ⊆

e ̸= 0
|e| ≤
M
M + 1 · ∥e∥1 and ∥e∥1 −2 · 1T
s |e| ≤0

.
The attractive part about this set is that it no longer depends directly on D, but
only on its Mutual-Coherence, and furthermore, it does not depend on α any more,
allowing us to obtain a general bound applicable to all vectors.
Our next simpliﬁcation uses the observation that if we have found any vector
e ∈Ce, then for every real number z, z ·e is also in Ce. Since we are only interested
in the question weather Ce is empty or not, we choose to intersect this set with the
ℓ1-ball, i.e., all the vectors e that have an ℓ1-norm of 1,
(2.14)
Ce ⊆

e ̸= 0
|e| ≤
M
M + 1 and 1 −2 · 1T
s |e| ≤0 and ∥e∥1 = 1

.
Our purpose now is to derive conditions for this set to be empty. The ﬁrst constraint
is that every element of e is smaller than M/ (1 + M). In order to satisfy the second
constraint, the energy of the vector e should be concentrated in the elements in the
support. Using the bound on the size of each element, for the second constraint to
be satisﬁed (and the set being not empty) it is required that
1 −2 · s ·
M
1 + M ≤0 ⇒s ≥M + 1
2M
.
This means that as long as s < M+1
2M , the set is empty, and therefore Ce is also
empty. This implies that under this condition, a vector β diﬀerent from α, satisfying

LECTURE 2. INTRODUCTION TO SPARSE APPROXIMATIONS - THEORY
179
Dβ = x and with ∥β∥1 ≤∥α∥1 does not exist. This leads to the BP actually arriving
at α as the result of its minimization, which means that when s < M+1
2M , the basis
pursuit is guaranteed to recover α exactly.
Stating this formally, we obtain the equivalence theorem for the Basis Pursuit:
Theorem 2.5 (BP Equivalence). Given a vector x with a representation Dα = x,
and assuming that ∥α∥0
0 < 0.5 (1 + 1/M), then BP is guaranteed to ﬁnd the sparsest
solution [14, 29].
Obviously, this claim is exactly identical to the equivalence claim for the OMP,
meaning that the bound to guarantee success of the two algorithms is identical.
However, it does not mean that the two algorithms are perform the same, as they
are diﬀerent in general (speciﬁcally, when this bound is not met, or in the noisy
case). It is hard to tell which is better.
Furthermore, the bounds presented here are worst-case performance guaran-
tees.
When analyzing actual performance, these bounds are usually too pes-
simistic. Analysis of average performance has also been done. In a series of papers
[5, 12, 13, 18, 19, 53], bounds are developed from a probabilistic point of view,
showing that up to some bounds, the actual vector may be recovered with a prob-
ability close to 1. These bounds are proportional to O(1/M 2), instead of O(1/M).
4. Theoretical guarantees - stability for (P ǫ
0)
4.1. Stability versus uniqueness
Consider the following problem, which is very similar to the one we dealt with
above: Alice chooses a sparse vector α, multiplies it by D, and obtains x = Dα.
Alice wants to send the signal x to Bob, but unfortunately, unlike before, the
transmission line is imperfect. Therefore, noise is added to the signal, and Bob
receives the signal y = x + v, where we know that the norm of v is bounded,
∥v∥2 ≤ǫ.
Bob would like to recover α. Since y is noisy, there is no sense in solving the
exact equation y = Dα, and thus Bob would attempt to solve
ˆα = arg min
α ∥α∥0 s.t. ∥Dα −x∥2 ≤ǫ.
Due to the noise being added, there might be somewhere in the sphere around
x a vector with a sparser representation than α. If not, α itself will be chosen.
Therefore, we know that ∥ˆα∥0 ≤∥α∥0. Can we hope that ˆα = α? If not, can we at
least hope that they are similar or close-by?
It turns out (we will not show it hear, but the slides present it through a simple
and illustrative example) that exact equality in the recovery, ˆα = α, is impossible
to expect in general, and thus we will turn to discuss stability, which is a claim
about the proximity between Alice’s a, and Bob’s proposed solution ˆα.
Suppose we created the true signal with an s-sparse vector of coeﬃcients α1,
and the solution we got is an s-sparse (or sparser) vector α2. These vectors satisfy
∥Dα1 −y∥2 ≤ǫ and ∥Dα2 −y∥2 ≤ǫ, which means that both of these solutions are
inside a sphere around y with radius ǫ. As these two points are inside the sphere,
the maximal distance between the two is twice the radius, and therefore
(2.15)
∥D (α1 −α2) ∥2 ≤2ǫ.

180
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
On the other hand, we can use the RIP property. The vector α1 −α2 is 2s-sparse
at most (if the vectors have diﬀerent supports), and we have the RIP property
(2.16)
(1 −δ2s) ∥α1 −α2∥2
2 ≤∥D (α1 −α2) ∥2
2.
Combining (2.15) (by squaring both sides) with (2.16) leads to the relation
(2.17)
(1 −δ2s) ∥α1 −α2∥2
2 ≤4ǫ2
Rearranging the terms leads to the following bound on the distance between the
two solutions
(2.18)
∥α1 −α2∥2
2 ≤
4ǫ2
1 −δ2s
≤
4ǫ2
1 −(2s −1) M ,
where in the last step we have used the relationship between the RIP and the
Mutual-Coherence δs ≤(s −1) M.
We have obtained a bound on the distance
between the two representation vectors, and we can see that this bound is in the
order of the noise. It is slightly higher, since the denominator is smaller than 1,
but it is not far-oﬀ. This is what we strived to show – stability.
The above analysis assumes that the power of the noise is bounded, ∥v∥2 ≤ǫ.
However, there was no assumption made as to the shape of the noise, and the noise
might have taken any shape to work against our analysis and algorithm. For this
reason, the bounds we obtain is weak, showing no eﬀect of noise attenuation.
An alternative approach could be to model the noise as a random, i.i.d Gaussian
vector, the elements of which are randomly drawn as vi ∼N
 0, σ2
. When such a
model is assumed, we can expect to get much better stability bound: The norm of
the error is expected to be close to (but not exactly) s · σ2 instead of n · σ2, which
is a much better result. However, this claim will no longer be deterministic, but
only probabilistic, with a probability very close to 1.
5. Near-oracle performance in the noisy case
So far we discussed the theoretical solution of (P ǫ
0). However, we know that this
task is impossible, and approximation algorithms are used, such as the OMP and
the BP. Very similar analysis exists that shows stability of these algorithms – a
successful recovery of the representation vector. We will not show this here, and
we refer the readers to [15, 16, 51]
As above, there is a distinction between adversive noise, which leads to worst-
case performance bounds similar to the one given in Equation (2.18). When random
noise is assumed, these bounds improve dramatically. In that respect, it is custom-
ary to compare the performance of pursuit techniques to the one obtained by an
oracle - a pursuit technique that knows the exact support. The oracle’s error is
typically O(sσ2) (as described above), and practical pursuit methods show bounds
that are this expression multiplied by a constant (larger than 1) and a logk factor
[1, 6].

LECTURE 3
Sparse and redundant representation modelling
1. Modelling data with sparse and redundant representations
1.1. Inherent low-dimensionality of images
Let us think of the following virtual experiment: Consider images x of size √n×√n
(e.g., n = 400 for 20 × 20 images). Each such image can be thought of as a point
in the IRn space. Once we accumulate many such images, we will have many such
points in IRn. However, no matter how many images we accumulate, the space
IRn is not going to be completely ﬁlled, but rather many empty areas will remain.
Furthermore, the local density of the images from one place to another is expected
to vary considerably.
The bottom line from these two observations is that we believe that the true
dimension of the images is not n. Rather, we believe that the images form a low-
dimensional manifold in IRn, with spatially varying densities.
It is our task to
model this manifold reliably.
The tool with which we represent the manifold is the Probability Density Func-
tion (PDF) Pr(x). This function tell us for each x ∈IRn how probable it is to be
an image. Obviously, this function should be non-negative and when summed over
the entire space it should sum to 1. In order to fulﬁll our assumption of the images
forming a low-dimensional manifold, the PDF Pr(x) should be zero for most of the
cube [0, 255]n.
The function Pr(x) is called the Prior as it reﬂects our prior knowledge about
what images should look like. Unfortunately, characterizing this function explicitly
is probably an impossible task, which leads us to look for ways to simplify it.
1.2. Who needs a prior?
Let us consider one simple example in which we need a prior. Suppose we would
like to obtain an image x (lying on the low-dimensional manifold). Unfortunately,
we are only able to obtain its noisy version, z = x + v, where v is a random noise
vector with a limited magnitude ∥v∥2 ≤ǫ. Using the prior over the image x, we
can now use it to try and recover x, by solving the problem
ˆx = arg min
x Pr (x) s.t. ∥x −z∥2 ≤ǫ.
In eﬀect, we are looking for the most probable vector x (according to our prior),
which is also close enough to z to explain it. This approach is a very known one –
it is called the Maximum A’posteriori Probability (MAP) approach.
This simple example is just one of many that require a good model (prior).
All inverse problems, such as denoising, deblurring, super-resolution, inpainting,
demosaicing, tomographic reconstruction, single image scale-up and more, require a
good image prior, in order to be able to diﬀerentiate between the true image content
and the degradation eﬀects. Compression algorithms require a model in order to
181

182
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
be able to ﬁnd the most compact representation of the image. Anomaly detection
requires a model of the image, in order to pick up on anything not conforming to
the model. The number of problems requiring a good image model is ever growing,
which leads us to the natural question - what is this prior Pr(x)? Where can we
get it from?
1.3. Evolution of priors
The topic of a proper choice of Pr(x) for images has been at of the foundation of
the research in image processing since its early days, and many models have been
suggested. Since it is not possible to characterize Pr(x) explicitly, some form of
computing it is suggested. Usually, instead of suggesting Pr(x) directly, its minus
log is used, G (x) = −log (Pr(x)), thereby giving a penalty of 0 to the “perfect”
image, and some positive penalty to any other, a larger value as the probability of
the image decreases.
There has been an evolution of choices for G (x) through the years. It started
with the ℓ2-norm, and the very simple energy term, G (x) = λ∥x∥2
2. It then pro-
gressed to smoothness terms, demanding low energy of some derivatives, G (x) =
λ∥Lx∥2
2, with L being the Laplacian operator. A further step was made by adap-
tively demanding this low energy, while allowing pixels detected as edges to contain
high energy in the derivative, G (x) = λ∥Lx∥W, where W is a pre-computed diag-
onal matrix, assigning diﬀerent weights to diﬀerent pixels.
The next major step was the abandonment of the convenient ℓ2 norm and the
progression to robust statistics, G (x) = λρ {Lx}. One of the most known priors
from this family is the total variation, G (x) = λ∥|∇x| ∥1, suggested in the early
1990’s. [44].
Around the same time, the prior of Wavelet sparsity G (x) = λ∥Wx∥1 started
evolving in the approximation theory and the harmonic analysis communities [11,
17, 38]. The idea behind this prior is that looking at the wavelet coeﬃcients of an
image, they should be sparse - most of them should be zeros or very close to zero.
The prevailing model in the last decade, which is an evolution of all models
described so far, is the one involving sparse and redundant representations. Simi-
larly to the wavelets sparsity, this model assumes sparse coeﬃcients, however, it no
longer relies on ﬁxed transforms. In the reminder of these course, we will focus on
this model and show its applicability to image processing. Of course, this model is
not the last in the evolution, and in the coming years new models will be suggested,
and they will perform even better (hopefully).
2. The Sparseland prior
Our model (and any other model) represents a belief - how we believe an image
should look like, or what are the rules it obeys. The sparse and redundant repre-
sentation model believes that all images are generated by a “machine” that is able
to create √n×√n images. Inside this machine there exists a dictionary Dn×k, and
each of the columns of this dictionary is a prototype signal – an atom.
Each time this machine is required to generate a signal, a vector α is (randomly)
chosen. Not any vector can be selected, however, as this vector must be sparse -
it may only contain a small number L of non-zeros, at random locations and with
random values, which we will assume are Gaussian.
Then, the result signal is
created by multiplying the dictionary by the sparse vector of coeﬃcients: x = Dα.

LECTURE 3. SPARSE AND REDUNDANT REPRESENTATION MODELLING
183
We call this machine Sparseland and we assume that all our signals in the family
of interest are created this way.
The Sparseland model has some interesting properties. It is simple, as any
signal generated is a linear combination of only a small number of atoms. Instead
of describing the signal using n numbers to represent the signal, we only need 2L
values – the locations of the non-zeros and their values. These signals are thus very
compressible.
On the other hand, this source is also very rich. We have many (combinatorial)
ways to choose subsets of L atoms, and can therefore create a wealth of signals
using this model. As a matter of fact, the signals generated are a union of many
low-dimensional Gaussians.
The last reason, which is also the actual reason this model is indeed being used,
is that it is in fact familiar and has been used before, in other contexts and perhaps
in a simpliﬁed way, like wavelets and JPEG. This progress have been observed in
several trends recently. For example, the transition from JPEG to JPEG2000 is
essentially a move from the ℓ2-norm and taking the leading coeﬃcients, to the notion
of sparsity of wavelet coeﬃcients. The progress from Wiener ﬁltering (Fourier) to
robust estimation also promotes sparsity. Similar trend exists in the evolution of
wavelets, from unitary transforms to over-complete transforms with concepts and
tools such as frames, shift-invariance, steerable wavelets, contourlets, curvelets and
more, all point to the direction of redundancy in the representation [39, 10, 46, 45].
The ICA (independent component analysis) transform was also shown to be tied
to sparsity and independence between the coeﬃcients.
Another ﬁeld progressing towards an extensive usage of sparse and redundant
representation modeling is that of machine learning. Methods such as LDA, PCA,
SVM and feature-selection methods have all been extended or improved recently
by the introduction of sparse and redundant representations.
All of these directions clearly point to Sparseland. It is here, and we are going to
use it. In order to do that, however, we must deﬁne it clearly, analyze it, understand
it, and ﬁnd out how it should be applied to the various tasks at hand.
One more thing we must take into account in our model is the model noise.
While we expect our signals to look like they have been created as Dα with a sparse
α, we may want to allow for some perturbations from this exact model, with the
understanding that, just like any other model, this model is not perfect or exact.
For this purpose, we assume that signals are created as y = Dα + e, with e the
model noise with bounded energy ∥e∥2 ≤ǫ0.
3. Processing Sparseland signals
The model we will be considering in this section is the exact model, i.e. x = Dα.
We will assume from now on that there is no model noise, i.e., ǫ0 = 0. This does not
mean that we work only on clean signals; It only means that true signals can indeed
be created exactly by multiplying the dictionary by a sparse vector of coeﬃcients.
Now, we ask – How do we process such signals?
3.1. Transform
Suppose we have a Sparseland signal y, and we want to design a transform for it,
similarly to the wavelet transform or the Fourier transform. What would we like
such a transform to do?

184
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
First, we would like it to be invertible - we do not want to lose information by
applying the transformation. We would also like the transformation to be compact,
i.e., for its energy to be concentrated in a small number of coeﬃcients. Lastly, we
would also want the coeﬃcients to be independent of each other.
We can propose a very simple transformation that follows all these requirements
– let us transform y into the sparsest vector α such that Dα = y,
ˆα = arg min
α ∥α∥0
0 s.t. Dα = y.
We know that such an α indeed exists, making this transform possible, since it is
our model’s assumption that y was generated by a sparse vector multiplying the
dictionary.
As the dictionaries used are redundant, α is usually longer than y, making the
transform suggested also redundant. It is also invertible, as multiplying D by α
brings us back to our original signal. Lastly, we observe that the energy of the
transform is concentrated in only a few non-zero coeﬃcients, as α is sparse, and
those non-zeros are independent.
3.2. Compression
Suppose we now try to compress the Sparseland signal y. In order to allow com-
pression, we allow some error ǫ between the compressed signal and the original one.
Changing this value will create diﬀerent rates of compression, thus creating the
rate-distortion curve for the compression scheme. The compression can be done by
solving
ˆα = arg min
α ∥α∥0
0 s.t. ∥Dα −y∥2
2 ≤ǫ2,
which means searching for the smallest number of coeﬃcients that can explain the
signal y with an error of less than ǫ. Note that the ﬁnal rate-distortion curve is
obtained from taking into account the further error introduced by quantizing the
non-zero coeﬃcients in α.
3.3. Denoising
Given a noisy Sparseland signal z = y+v, created by the addition of additive noise
v (with known power ∥v∥2 = ǫ) to our original signal, we would like to recover y
as accurately as possible.
Since we know the signal y is sparse over the dictionary D and we expect the
noise to not be sparse over the same dictionary (since it is not a “real” image), the
following task can be proposed:
ˆα = arg min
α ∥α∥0
0 s.t. ∥Dα −z∥2
2 ≤ǫ2,
with the ﬁnal solution being ˆy = Dˆα. This denoising method works quite well in
practice, as we will see later on in the lectures.
There is a subtle point to address regarding denoising. Our model assumes
that the signals we operate on can be indeed represented exactly using a sparse
representation over the dictionary.
However, for real-world signals, this is not
exactly the case, and there are some model mismatches. The denoising algorithm
will remove these true details from the signal, along with the noise. This implies
that if the noise is very weak, such that its power is in the order of the model
mismatch, the denoising result might actually be worse than not denoising at all.
This is because the price of removing the model mismatch may be greater than the
price of not removing the noise. Usually, when the standard deviation of the noise

LECTURE 3. SPARSE AND REDUNDANT REPRESENTATION MODELLING
185
is 5 grey levels or more (when the image is in the range [0, 255]), it is considered to
be stronger than the model mismatches, and denoising the image indeed improves
its quality.
3.4. General inverse problems
As a generalization of the denoising problem, we now assume that the Sparseland
signal is given to us after a degradation operator H and an additive noise, z =
Hy + v.
The operator H can be any linear operator that can be written as a
matrix, representing blur, projection, down-scaling, masking and more.
We can try to recover y by looking for the sparsest α that when multiplied by
the dictionary and then by H is close enough to the input signal z. This vector is
found by solving the minimization problem:
ˆα = arg min
α ∥α∥0
0 s.t. ∥HDα −z∥2
2 ≤ǫ2,
and again, the ﬁnal solution is obtained by ˆy = Dˆα. The minimization is carried
out in practice by deﬁning the equivalent dictionary ˜D = HD, and solving the
same minimization problem we have already encountered:
ˆα = arg min
α ∥α∥0
0 s.t. ∥˜Dα −z∥2
2 ≤ǫ2,
There is a wide range of problems that can be solved using this mechanism: deblur-
ring, inpainting, demosaicing, super-resolution, tomographic reconstruction, image-
fusion and many more.
3.5. Compressed-sensing
Suppose that we want to sample the Sparseland signal y, such that we use much less
than n samples. There may be various reasons for this desire, such as the signal
being too long, having limited time to sample it, each sample being expensive,
and so on. Instead, we propose to sample noisy projections of it, using a known
projection matrix P, making our signal z = Py + v, with ∥v∥2 = ǫ representing
the sampling noise. Again, we suggest to recover the original signal by solving
ˆα = arg min
α ∥α∥0
0 s.t. ∥PDα −z∥2
2 ≤ǫ2,
and multiplying the found vector of coeﬃcients by the dictionary, ˆy = Dˆα. This
problem again is of the same form seen above, considering the eﬀective dictionary
as ˜D = PD. The Compressed Sensing ﬁeld deals with questions like the minimal
number of rows in P (the minimal number of projections) needed to recover the
original signal y with suﬃcient accuracy, and what kind of P should be chosen.
3.6. Morphological-component-analysis
The MCA task [47, 48] deals with the case where a given signal z = y1 + y2 + v
is a mixture of two Sparseland signals y1 and y2, each created from a diﬀerent
dictionary D1 and D2 respectively, with noise also being added. The goal is to
recover each of the original signals y1 and y2, assuming their dictionaries D1 and
D2 are known.
Since both signals should have a sparse representations, it is suggested to solve
the minimization problem
ˆ
α1, ˆα2 = arg min
α1,α1 ∥α1∥0
0 + ∥α2∥0
0 s.t. ∥D1α1 + D2α2 −z∥2
2 ≤ǫ2,
and recover the original signals using ˆy1 = D1 ˆα1 and ˆy2 = D2 ˆα2.

186
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
By concatenating the vectors α1 and α2 vertically into a single vector α, and
concatenating the two dictionaries by putting them side by side D = [D1D2], it
turns out that we have already seen this task:
ˆα = arg min
α ∥α∥0
0 s.t. ∥Dα −z∥2
2 ≤ǫ2.
3.7. Applications: Summary
We have gone over several applications that can be solved using the Sparseland
model. There are many more that we can envision using this model – encryption,
watermarking, scrambling, target detection, recognition, feature extraction and
more. What is common to all these problems is the need to solve a variant of
the problem (P ǫ
0),
ˆα = arg min
α ∥α∥0
0 s.t. ∥Dα −z∥2
2 ≤ǫ2.
This is a problem we have already seen and discussed - we know it is NP-hard, but
we have seen several algorithms to approximate its solution and some guarantees on
the quality of their solutions. The conclusion is that signal processing for Sparseland
signals is reasonable and practical.

LECTURE 4
First steps in image processing
In this lecture we will start working on image processing applications that rely
on the Sparseland model.
We will consider image deblurring, image denoising,
and image inpainting. Several other, more advanced applications, using the tools
shown in the lecture, will be given in the following (and last) lecture. More on
these applications can be found in [22].
1. Image deblurring via iterative-shrinkage algorithms
1.1. Deﬁning the problem
The deblurring problem is one of the most fundamental problems in image pro-
cessing: A high-quality image x undergoes blurring, be it due to atmospheric blur,
camera blur, or any other possible source. We assume this blur is known (could
be space variant). We measure a noisy (white iid Gaussian) version of the blurred
image. The noise v has a known standard deviation. Thus, the image we actually
obtain y is related to the ideal image x through
(4.1)
y = Hx + v,
and our task is to recover x given y. Since we are dealing with the Sparseland
model, we assume that the image x has a sparse representation over a carefully
chosen dictionary, and therefore we will try to solve
(4.2)
ˆα = arg min
α
1
2∥HDα −y∥2
2 + λ · ρ (α) .
Here, the function ρ is sparsity promoting penalty, such as the ℓ1-norm, or some-
thing similar (see the end of lecture 1). Since we are not interested in ˆα in itself
but in the recovered image, we ﬁnish the processing with ˆx = Dˆα.
Let us deﬁne the ingredients in Equation (4.2).
The vector y is the given
degraded image, and H is the known blur operator. The dictionary D should be
chosen by us. In the experiments we report here, we follow the work by Figueiredo
and Nowak [26, 27] and use the 2D un-decimated Haar wavelet transform with 2
resolution levels. This is a global dictionary with a redundancy factor of 7 : 1. As
for the function ρ, we use an approximation of the ℓ1 norm, with a slight smoothing,
(4.3)
ρ (α) = |α| −S · log

1 + α
S

.
The function ρ is a scalar function, operating on each entry of α individually, and
summing the result over all entries. The beneﬁt of using this function rather than
the ℓ1 norm directly is that it is smooth and derivable in the origin (and everywhere
else) and is therefore much more convenient to work with.
187

188
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
Lastly, the value of λ is set manually to get the best possible result. There are
algorithms that can ﬁnd its value for optimal performance automatically. However,
we will not discuss those here and proceed with the manually chosen value.
There is a wide knowledge in the area of continuous optimization, and it seems
like once we have written down our penalty function, we can use a wide variety
of methods or even general purpose optimization software packages (e.g., Matlab,
MOSEK) for its solution. However, such general purpose solvers typically perform
very poorly for this speciﬁc optimization task. One possible reason for this poor
performance is the fact that these solvers disregard the knowledge about the sparsity
of the desired solution. A second possible reason can be understood from look at
the gradient of our penalty function,
▽f (α) = DT (Dα −y) + λ · ρ′ (α)
and the Hessian
▽2f (α) = DT D + λ · ρ′′ (α) .
We must remember that α will contain many zero elements, and few non-zero
elements in unknown locations. In the locations of the zeros, the value of ρ′′ will
be very large, while for the non-zeros, these will be small numbers. Therefore, the
Hessian’s main diagonal will have a high contrast of values, causing this matrix
to be of very high condition-number, hurting the performance of general-purpose
solvers. Furthermore, as we do not know in advance the locations of these non-zeros
(this is actually the goal of the optimization - recovering the support), we cannot
even pre-condition the Hessian. This forces us to seek for tailored optimization
methods that will take advantage of the expected sparsity in the solution.
How should we do that? In lecture 1 we have seen that when the matrix D is
unitary, the solution is obtained by a simple scalar-wise shrinkage step Sρ,λ
 DT y

.
When D is not unitary, we would like to propose a similarly simple solution. This
idea leads to a family of algorithms known as “Iterative Shrinkage” [25]. There are
several such algorithms, and here we will present one of them.
1.2. The parallel coordinate descent (PCD) method
An interesting iterative shrinkage algorithm emerges from the classic coordinate
descent (CD) algorithm. Put generally, the CD operates as follows: Given a func-
tion to minimize with a vector as the unknown, all entries but one are ﬁxed, and
the remaining entry is optimized for. Then, this coordinate is ﬁxed, and a diﬀerent
entry is optimized. This is done serially over all entries, and in several iterations,
until convergence.
In our problem, solving for one entry at a time considers only the atom dj and
the coeﬃcient αj. Taking it out of the current support by setting αj = 0, we get
that the current error in representation is ej = y −Dα. We now attempt to best
reduce this error using only the atom dj, by choosing the optimal value for αj, i.e.,
minimizing
f (αj) = 1
2∥αj · dj −ej∥2
2 + λρ (αj) .
This is a scalar optimization problem that can be solved using shrinkage on the
scalar value dT
j ej. The shrinkage is applied by
αOP T
j
= Sρ,λ/∥dj∥2  dT
j ej

,

LECTURE 4. FIRST STEPS IN IMAGE PROCESSING
189
where S denotes the shrinkage operation – its shape is dictated by the choice of ρ
and λ/c. Notice that the shrinkage is done diﬀerently to each entry, based on the
norm of the j-th atom.
For low-dimensional problems (k ≈100) it makes sense to solve our problem
this way exactly. However, in the image deblurring problem, the unknown contains
many thousands entries, and it is impossible to use the above algorithm, as it
requires to extract one column at a time from the dictionary.
The solution to
this problem is the Parallel-Coordinate-Descent (PCD) algorithm.
The idea is
the following: Compute all the k descent trajectories {vj}k
j=1, each considering one
coordinate optimization. Since all are descent directions, their sum is also a descent
direction. The PCD takes this sum and uses this for the current iteration. The
problem with this direction is that it is not known how far to go along it. Therefore,
a 1D line-search is needed, and the overall iteration step is written as
(4.4)
αk+1 = αk + µ ·

Sρ,Qλ
 QDT (yDαk) −αk

,
with Q = diag−1  DT D

. µ is the found step-size in the line-search step.
1.3. Results
Figure 1 shows the deblurring result obtained by the PCD algorithm after 10 iter-
ations. More details on this experiment are given in the accompanying slides.
Figure 1. Debluring. Left: The original image, Middle: the mea-
sured (blurred and noisy) image, and Right: the PCD deblurring
result.
2. Image denoising
The image denoising problem can be viewed as a special case of the image deblurring
problem discussed above. For this to be evident, all we need to do is select H = I
(i.e., no blur at all). In this section we shall present two very diﬀerent ways to
handle this problem.
2.1. Global shrinkage
Embarking from the above-described deblurring algorithm, we can suggest the fol-
lowing simpliﬁed denoising method: Instead of the iterative mechanism, we can
apply the thresholding algorithm, as follows
(4.5)
ˆx = DST
 DT y

.

190
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
Of course, since we are using the redundant Haar dictionary, we should normalize
its columns (since they are not ℓ2 normalized) in order to have a single scalar
threshold for all atoms. Put diﬀerently, this leads to
(4.6)
ˆx = DWST
 W−1DT y

.
The only missing ingredient is determining the value of the threshold T . Experi-
menting with this algorithm, diﬀerent values of T will have a diﬀerent quality of
denoising. As an example, on the well known image “barbara” with noise with
standard deviation σ = 20, the optimal value of T is around 55. The denoised
image using this method is more than 5 dB better in PSNR than the noisy image.
This result is shown in Figure 2.
Figure 2. Global denoising. Left: The original image, Middle:
the measured (noisy) image, and Right: the global denoising result.
2.2. From global to local processing
While the above result is good, it is deﬁnitely not the best that can be achieved.
We will now turn to a much better method (and see an even better one in the next
lecture).
When discussing algorithms for the solution of the (P ǫ
0) problem, we saw that
very large signals could pose a computational problem. Therefore, when we work
on the image as a whole, we are forced to use only simple algorithms, such as
(iterative) shrinkage. Also, when using dictionaries for an entire image, the result
may be sparse when compared to the overall number of atoms, but we still require
a large number of coeﬃcients. These two observations lead us to attempt operating
on small image patches instead.
When processing a large image, we claim that every N × N patch (e.g., 8 × 8)
in it has a sparse representation over a dictionary. Furthermore, we use full over-
laps between the patches. By operating this way, we in fact force shift-invariance
sparsity. In order to write this formally, we deﬁne the operator Rij, which extracts
an N × N patch from the image around pixel (i, j). Now, the minimization task to
solve is [30, 31, 23]
(4.7)
ˆx = arg
min
x,{αij}ij

1
2∥x −y∥2
2 + µ
X
ij
∥Rijx −Dαij∥2
2

s.t. ∥αij∥0 ≤L.
The ﬁrst term requires a proximity between the recovered image and the input im-
age, a direct consequence of the log-likelihood. The second term requires that each

LECTURE 4. FIRST STEPS IN IMAGE PROCESSING
191
patch in the reconstructed image can be represented well as a linear combination of
atoms from the dictionary D. The constraint forces all of these linear combinations
to be sparse.
At this stage, the dictionary we will be using for this algorithm is the over-
complete DCT dictionary with 256 atoms, each representing an 8 × 8 patch. This
dictionary is separable, allowing it so be applied eﬃciently.
How can we perform the minimization in (4.7)?
We will take a coordinate
descent approach. First, we will ﬁx x = y, and solve for {αij}ij. The ﬁrst term
disappears, and we are left with M · N diﬀerent minimization tasks:
(4.8)
ˆαij = arg min
α ∥Rijx −Dα∥s.t. ∥α∥0 ≤L.
We have seen this problem before - this is the sparse coding problem, and can be
solved by any pursuit algorithm (e.g., OMP). Once we have found {αij}ij, we ﬁx
them, and recover x. This is a least-squares problem and a little bit of algebra
leads to a closed-form solution
(4.9)
ˆx =

I + µ
X
ij
RT
ijRij


−1 
y + µ
X
ij
RT
ijDˆαij

.
While this expression seems complicated, it is actually simple to implement. While
the operator Rij extracts a patch around the pixel (i, j), the operator RT
ij returns
a patch to the location (i, j). Therefore, the left matrix is in fact a diagonal one,
indicating for each pixel the amount of patches it belongs in, serving as normaliza-
tion.
Therefore, the entire denoising process is done by extracting each patch, per-
forming sparse coding, and getting a denoised patch instead. The denoised patch is
returned to its original position, with aggregation performed in the overlaps area.
Then, each pixel is normalized by the number of patches it belongs too (which is
generally N 2, apart from the borders of the image).
It turns out that this very simple method performs about 2.5dB better than
the global thresholding show previously. Furthermore, this algorithm can be im-
plemented very eﬃciently on parallel processors. We will see this local processing
approach in several more applications. The result obtained is shown in Figure 3.
Figure 3. Local denoising. Left: The original image, Middle: the
measured (noisy) image, and Right: the local denoising result.

192
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
3. Image inpainting
Assume that a signal has been created as x = Dα0 using a very sparse vector of
coeﬃcients α0. Unfortunately, we do not get x directly, but rather obtain ˜x, which
is the same signal x, but with some samples removed. We shall assume that we
know which samples are missing.
Each missing sample from x implies one lost
equation in the system x = Dα0. Therefore, we remove these corresponding rows
from the dictionary D, obtaining the dictionary ˜D. Now, we may try to solve
(4.10)
ˆα = arg min
α ∥α∥0 s.t. ˜x = ˜Dα.
If α0 was sparse enough, it will also be the solution of this modiﬁed problem. Then,
by computing Dˆα we will recover the original signal completely.
Using the above intuition, we now turn to extend the local denoising algorithm
into an inpainting one. The minimization task here is very similar to the one we
had for the denoising (4.7), with the needed modiﬁcation to take into account the
masking operator [30, 31, 36],
(4.11) ˆx = arg
min
x,{αij}ij

1
2∥Mx −y∥2
2 + µ
X
ij
∥Rijx −Dαij∥2
2

s.t. ∥αij∥0 ≤L,
where we now require that x is close to y only in the locations of un-masked pixels.
Again this minimization will be done using the coordinate descent approach.
First, we compute X = MT y (e.g., by zero ﬁlling), and do sparse coding for each
patch, using the matching pursuit
(4.12)
ˆαij = arg min
α ∥Mij (Rijx −Dα) ∥s.t. ∥α∥0 ≤L,
with Mij the appropriate masking for each patch. Once the sparse coding is ﬁn-
ished, the result image is again reconstructed by aggregating the patches in the
overlaps area, normalizing by the number of patches in each pixel,
(4.13)
ˆx =

MT M + µ
X
ij
RT
ijRij


−1 
MT y + µ
X
ij
RT
ijDˆαij

.
Figure 4 presents inpainting results obtained using this algorithm.
Figure 4. Local inpainting. Left: The original image, Middle:
the measured image with 50% missing pixels, and Right: the in-
painting result.

LECTURE 4. FIRST STEPS IN IMAGE PROCESSING
193
4. Dictionary learning
4.1. General dictionary learning
Our entire model and applications rely on having a suitable dictionary. A good
dictionary would be one that sparsiﬁes our data. The question we aim look at now
is how to construct such dictionaries. We have already seen one possible solution
– we can choose a dictionary from an existing family of transforms, such as DCT,
curvelets, contourlets, wavelets and so on. This approach has its beneﬁts, as usually
these transforms can be applied rather eﬃciently. However, a dictionary selected
this way is typically not the best ﬁt for the actual data.
A better approach is to train a dictionary from examples. The core idea is
to collect a set of representative examples of the images we work with, and train
a dictionary so that the examples can be sparsely represented over it.
Such a
dictionary will be better suited for our data, therefore leading to better performance
in various tasks.
Let us collect all the examples {xj} into a matrix X, where each column is one
example. Then, we can write the decomposition as X ≈DA, where each column
of A contains the coeﬃcients for the representation of the corresponding example.
A good dictionary is therefore one that is able to adequately represent each of the
examples, while the representation for each example in indeed sparse, i.e., each
column in A has only a small number of non-zeros. Formally, we would like to
solve
(4.14)
ˆD, ˆA = arg min
D,A
P
X
j=1
∥Dαj −xj∥s.t. ∀j, ∥αj∥0 ≤L.
This problem will be handled as follows: The ﬁrst stage is sparse-coding, assuming
D is ﬁxed, and only the representation vectors are sought. In this stage we should
solve for each example
(4.15)
min
α ∥Dα −xj∥2
2 s.t. ∥α∥0 ≤L.
We have seen in the ﬁrst lecture several ways to perform this minimization, via
pursuit algorithms. The second stage of dictionary training is the update of the
dictionary, once the representation vectors A have been recovered. There are two
main methods to do so: the Method of Optimal Directions (MOD) method [32]
and the K-SVD method [2].
4.2. MOD dictionary update
One option is to try and update the dictionary at once. The goal is minimizing
(4.16)
min
D ∥DA −X∥2
F ,
with X and A ﬁxed. Note the use of the Frobenius norm, as both DA and X are
matrices. Few simple linear algebra steps lead to
(4.17)
D = XAT  AAT −1 = XA†.
Once the dictionary is found this way, its columns need to be re-normalized.

194
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
4.3. K-SVD dictionary learning
Another option to train the dictionary is imitating the K-means algorithm in the
dictionary update stage.
This means that we process one atom at a time and
attempt to optimally replace it.
For processing the i-th atom, the ﬁrst stage is collecting only those examples
that use it into the matrix Xi. Then, the dictionary D and coeﬃcient matrix A
are all ﬁxed apart from the i-th column in D and the i-th row in A. Denoting
by Di and Ai these matrices with the i-th column/row removed respectively, the
following residual is computed
Ei = Xi −DiAi = Xi −DA + diαi.
This is the residual matrix for all the examples that use the i-th atom, without
taking into account the i-th atom itself. The new atom is the one that is best able
to reduce the mean residual, i.e., the result of the minimization problem
(4.18)
min
di,αi ∥αidT
i −Ei∥2
F .
The vector αi is the optimal set of coeﬃcients for this atom in each example. The
resulting atom ˆdi is inserted into the dictionary, and the new vector of coeﬃcients
αk replaces the i-th row in A (only in the columns relevant to the examples using
this atom).
The optimization task in (4.18) is in fact a rank-1 approximation, which can
be solved directly using the SVD decomposition. As every atom is updated using
an SVD operation, this algorithm is appropriately named K-SVD. Note, that in
the MOD training stage, the matrix of coeﬃcients A is held constant, and the
dictionary D is adapted to it. In the K-SVD algorithm, on the other hand, the
atom update stage also optimizes for the k’th row of A at the same time.

LECTURE 5
Image processing - more practice
In the previous lecture we saw how to denoise and inpaint an image based on
local, patch-processing. However, in both this cases, we used a ﬁxed dictionary – the
local DCT. In this lecture we shall revisit these two applications, and incorporate
into them the K-SVD, in an attempt to improve their performance. We shall also
demonstrate the capabilities of the Sparseland model in handling image processing
tasks by considering two new applications – an image scale-up process based on a
pair of trained dictionaries, and a facial image compression algorithm that performs
better than JPEG-2000. More details on the applications presented here can be
found in [22, 3].
1. Image denoising with a learned dictionary
When thinking about dictionary learning, both the MOD and the K-SVD are not
able to process signals with large dimensions. The reason is obvious – a high dimen-
sional signal implies a dictionary held as a very large explicit matrix, intolerable
amounts of computations, both for the training and for using this dictionary, and
a huge amount of examples to learn from, in order to avoid over-ﬁtting. Thus,
learned dictionaries are naturally used for low-dimensional signals.
We have already seen in the previous lecture that denoising (and inpainting)
can be done very eﬀectively by operating on small (e.g., 8 × 8) patches.
The
processing is then done on local blocks of images, using a dictionary that handles
low-dimensional signals. Formally, the denoising we have proposed is written as
(5.1)
ˆx = arg
min
x,{αij}ij

1
2∥x −y∥2
2 + µ
X
ij
∥Rijx −Dαij∥2
2

s.t. ∥αij∥0 ≤L.
The second term is the prior, expressing our belief that every patch in the image
should have a sparse representation over the dictionary D.
Our objective is to
introduce a learned dictionary into the above paradigm. One option is collecting a
set of high-quality images, extract patches from them, and use these examples to
train a dictionary. This dictionary will be a “universal dictionary”, as it is trained
on general content images. This option is useful, and brings reasonably good results
- about 0.5-1dB below the state of the art.
An interesting alternative is to use patches from the corrupted image itself for
the training process. Suppose an image of 1000 × 1000 is to be denoised. Such an
image contains nearly 106 patches, which are more than enough to allow training
the dictionary. Furthermore, since the dictionary training process contains some
sort of averaging, the resulting dictionary will actually be (almost) noise free, and
can thus be used for denoising.
195

196
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
This option works much better than using the “universal dictionary”, and leads
to state-of-the-art results [23]. In fact, going back to the penalty term in (5.1), we
can bring about this option by minimizing over D as well. Again, a coordinate
descent approach is used.
First, the image x = y is ﬁxed, and the dictionary
D is ﬁxed on some initialization (e.g., the redundant DCT). Each patch in the
image undergoes sparse coding.
Freezing the representations, the dictionary is
updated. All the patches then undergo sparse coding with the new dictionary, and
so. Iterating several times between sparse coding and dictionary update is exactly
the training procedure we have seen in the previous lecture, performed over the
patches in the image. After several such training iterations, the ﬁnal dictionary
is used for one last sparse-coding stage.
Then, the sparse representations and
the dictionary are ﬁxed, and the result image is recovered, using the same simple
aggregation method shown in the previous lecture,
(5.2)
ˆx =

I + µ
X
ij
RT
ijRij


−1 
y + µ
X
ij
RT
ijDˆαij

.
Figure 1 presents the result obtained using this algorithm, for the same test shown in
Lecture 4. The obtained image has PSNR = 31dB, which is 1dB higher compared
to the DCT-based outcome.
Figure 1. Local denoising with a trained dictionary. Left: The
original image, Middle: the noisy image (σ = 20), and Right: the
denoising result.
This denoising algorithm has been applied to many variation of the denoising
problem. One is of course the denoising of gray-scale images. When published, this
method led to state-of-the-art results. Later, it was extended by Mairal et. al. by
using joint sparsity (i.e., sparse coding similar patches together) [37]. This method
is currently the best performing denoising algorithm.
The denoising algorithm could also be applied to denoising of color images.
Usually, there is a sensitivity in how the relationships between the color channels
should be handled. In this algorithm, the solution is simple – the training is per-
formed on 8×8 ×3 patches, i.e., on colored patches extracted from the image. The
dictionary contains color atoms, and the rest of the algorithm remains the same.
This method is also the state-of-the-art in color image denoising [36].
Video sequences can also be handled by this method. When processing image
sequences, the redundancy between frames can and should be used in order to
achieve better denoising. While most video denoising algorithms require motion

LECTURE 5. IMAGE PROCESSING - MORE PRACTICE
197
estimation (which is error-prone), the suggested method can simply train on space-
time patches extracted from the video. Therefore, the dictionary is also constructed
of “movielets”, as each atom is a very short, very small (e.g., 8 × 8 × 5) space-time
patch. Furthermore, since consecutive images are very similar, it is not necessary
to retrain a dictionary for each image. Instead, it can be propagated from one
frame to the next, only requiring ﬁne tuning (1 K-SVD iteration) for each one.
This method’s performance is equivalent to the state-of-the-art [43].
2. Image inpainting with dictionary learning
Turning to image inpainting, we would like to apply dictionary learning here as
well, for handling the local patches. The process is very similar to the one done
in denoising. The algorithm starts with dictionary training using the K-SVD, by
performing alternating steps between sparse coding and dictionary update. During
the sparse coding stage, only the un-masked (i.e., known) pixels in each patch
are used. This is similar to the sparse coding undertaken in the ﬁxed dictionary
scenario. Once the sparse coding is done, each atom is updated using the SVD
operation, just like the K-SVD method.
This dictionary training is repeated for several (e.g., 10) iterations. Then, the
image is reconstructed from the ﬁnal sparse coding using the same formula we have
seen:
(5.3)
ˆx = arg
min
x,{αij}ij

1
2∥Mx −y∥2
2 + µ
X
ij
∥Rijx −Dαij∥2
2

s.t. ∥αij∥0 ≤L,
Of course, just like in the denoising case, this method can be easily generalized
to inpainting of color images and inpainting of video sequences using the same
extensions as in the denoising case. Figure 2 presents the results obtained with this
algorithm, showing the beneﬁt of using learned dictionary.
This approach to inpainting works well when the missing pixels are in (near-
random) locations, or organized in small groups. If the missing pixels form a large
area to reconstruct, the local approach will not work, and an alternative, global,
approach will be needed.
Another problem could arise if the missing pixels create a periodic mask, for
example, when every other pixel is missing. In this case, the dictionary will not
be able to learn the relationship between neighboring pixels, because it has no
information about such neighbors. Such is the case, for example, in image single-
image scale-up and demosaicing. The periodic nature of the mask pattern may cause
the learned dictionary to absorb this pattern into its atoms. In order to prevent
that, the dictionary should trained while allowing only a very small number of non-
zeros, and furthermore, only few training iterations in order to avoid over-ﬁtting.
Such a solution leads to state of the art results, which can be seen in [36].
3. Image scale-up with a pair of dictionaries
We turn to describe an image scale-up algorithm that uses trained dictionaries.
The method described here follows the work of Yang et. al. [54], with several
important modiﬁcations that lead to a simpler and more eﬃcient algorithm, with
better results [22].

198
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
Figure 2. Image inpainting with the K-SVD. Top-Left: The orig-
inal image, Top-Right: the measured image (masked with missing
pixels), Bottom Left: DCT-based inpainting, and Bottom Right:
the proposed K-SVD inpainting result.
3.1. Preliminaries
The image scale-up problem is deﬁned as follows. A high-quality (high-resolution)
image yh is blurred, decimated, and contaminated by additive noise, obtaining the
image zl,
(5.4)
zl = SHyl + v,
with H a blur operation, S the decimation operator, and v the noise. We assume
that the decimation S and blur H operators, and the statistical properties of the
noise v, are known.
We would like to reverse this process and recover the high quality image from
the given low quality one. This is a severely ill-posed inverse problem, and therefore
we shall need an image model for its regularization – we shall use the Sparseland
model.
In order to simplify notations, we will assume the the low resolution image
has undergone simple interpolation (such as bicubic) to the same size as the target
image
(5.5)
yl = Qzl,

LECTURE 5. IMAGE PROCESSING - MORE PRACTICE
199
with Q being the interpolation operator. This initialization step will save us the
technicalities of handling two scales in our formulation.
The algorithm we suggest relies on two core ideas. The ﬁrst is operating locally,
in the sense that each patch in the low-quality image will undergo resolution en-
hancement on its own. Then, the improved patches will be merged (using averaging
in the overlap areas, just as in the previously described denoising and inpainting)
in order to create the ﬁnal output image.
How each patch is enhanced? This enhancement requires two dictionaries, Al
and Ah for the low and high quality patches respectively. Each atom in Ah should
be the high-quality counterpart of the corresponding low quality atom in Al. In
order to enhance a low-quality patch, its sparse representation over the low-quality
dictionary Al is found. This sparse representation is then used to reconstruct a
patch from the high-quality dictionary, which is the enhancement result for the
low-quality patch. We will now go into further details of this algorithm, and focus
on learning these two dictionaries.
3.2. The core idea
As we have been practicing throughout this course, we assume that every √n×√n
patch extracted from location k in the high-quality image through pk
h = Rkyh,
can be represented sparsely over a high-quality dictionary Ah, i.e., for every patch
pk
h we assume that there exists a very sparse representation vector qk such that
pk
h ∼= Ahqk.
Next, we aim to ﬁnd a connection between a high-quality patch in yh and a
patch in the same location in yl. We can use our knowledge of the creation process
of zl from yh through blur, decimation and the addition of noise, with interpolation
used to create yl. Therefore,
(5.6)
yl = Q (DHyh + v) .
Combining all operators into one LALL = QDH, we come to the relationship for
each patch
(5.7)
∥Lpk
h −pk
l ∥2 ≤ǫ,
with L a local portion of LALL. This expression ties the low-quality patch and the
high-quality patch in the same location. Using our assumption that the high quality
patch can be sparsely represented over the high quality dictionary pk
h ∼= Ahqk, we
obtain the relationship ∥LAhqk −pk
l ∥2 ≤ǫ. Deﬁning a new dictionary, Al = LAh,
we obtain
(5.8)
∥Alqk −pk
l ∥2 ≤ǫ.
This observation leads to the conclusion that the sparse representation qk is also
the representation of the low quality patch pk
l over the low quality dictionary Al.
3.3. Dictionary training
Since we want to use trained dictionaries, the obvious question is what do we train
them on. One option is obtaining one (or more) high quality images. The high-
quality image is then blurred and down-sampled it using the known (expected)
operators. The low-resolution image is then interpolated back to the size of the
high-quality image.
Then, all the patches from each image are extracted, with
patches in the same location in the original and interpolated image being paired.

200
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
Finally, each patch undergoes some pre-processing steps (diﬀerent for the high-
quality and low-quality patches), to form our ﬁnal corpus for training. More on
this pre-processing can be found in [22].
An alternative to using a pre-determined image for training, we can attempt
training on the input image, as was done for denoising and inpainting and shown
to improve results.
However, we only have the low-quality image, so it seems
something is missing. To our aid will come to observation that images tend to have
a multi-resolution nature. If we consider an image pyramid, the characterizations
of the local relationship between two consecutive levels in the pyramid is relatively
the same in all levels.
From this observation comes the bootstrapping approach. The input image is
blurred, decimated and then interpolated to create an even lower quality image.
Now, we use the pair of low-quality and lowest-quality images as the basis for
the training of the high and low quality dictionaries respectively. Once these two
dictionaries are trained, the algorithm proceeds regardless of the training corpus.
Once the training patches have been collected and prepared, dictionary training
can begin. The ﬁrst step is training the low-quality dictionary from the set of low-
quality patches. This training is done using the K-SVD algorithm. The next step is
training the high-quality dictionary. We must remember that the two dictionaries
should align with each other, such that a high-quality patch and its low-quality
counterpart have the same representation over their dictionaries. This means that
given a low quality patch pk
l with a representation vector qk, it should also be the
representation vector of the high-quality patch pk
h. Therefore, it makes sense to use
the high-quality patches to train the high-quality dictionary such that this scale-up
process gets as close as possible to its objective. Formally, we should minimize
(5.9)
min
Ah
X
k
∥pk
h −Alqk∥2
2.
This is a simple least-squares problem to solve, and it results in a dictionary that
is coupled with the low-quality dictionary that was already trained.
Once both dictionaries have been trained, we are now armed with all that we
need to recover a high-resolution image given a low-resolution input. Note that this
training algorithm may be done oﬀ-line on a high-quality image (which we expect
to be similar to the image we would later enhance) or online, on the input image
itself.
Figure 3 presents an example for the results obtained by this algorithm. The
ﬁgure shows a high-resolution image and its scaled-down version. The scaling-up
process aims to return to the original image – we provide two possible results,
one obtained by the plain bicubic interpolation, and the second using the above-
described algorithm.
4. Image compression using sparse representation
Compressing images in one of the most researched ﬁelds in image processing, be-
cause of its importance to the ability to transfer/store images easily while retaining
as much of their quality as possible. Trained dictionaries that lead to the spars-
est representations seem ideal for compression. However, there is a diﬃculty with
training a global dictionary for all images, as it is expected to be less eﬀective. The
alternative, training a dictionary tailored for the speciﬁc given image, as practiced

LECTURE 5. IMAGE PROCESSING - MORE PRACTICE
201
Figure 3. Image Scale-Up. Top-Left: The original image, Top-
Right: the measured image (blurred, decimated, and noisy), Bot-
tom Left: Bicubic scaled-up image, and Bottom Right: the pro-
posed scale-up result.
in denoising and inpainting, is also diﬃcult, as it requires allocated bits for the
dictionary, which may compromise the success of the compression algorithm.
When turning to a speciﬁc family of images, the story changes, as it is now
possible to tailor speciﬁc dictionaries to the task, while not actually needing to
send them. One example for such a problem is the compression of high-quality
(e.g., 500 × 400) facial ID images, to put on biometric identity cards or credit
cards. It is possible to use general purpose compression algorithms, such as JPEG
and JPEG2000 for this purpose, but a speciﬁcally trained algorithm is expected to
do much better.
The proposed algorithm we describe here [4] has two stages – ﬁrst, training
appropriate dictionaries, and then, applying the trained dictionaries to compress
(and decompress) the facial images.
4.1. Facial image compression algorithm - training
For training, a set of high-quality facial images are collected. This set is then used
for training a dictionary for each portion of the image. The stages are as following:

202
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
(1) Key points in each image are detected (e.g., eyes, nose). These locations
are used to transform each image (using a piece-wise aﬃne transform) such
that these key points are in exactly the same coordinates in all images.
(2) Each image is divided into non-overlapping 15 × 15 patches. Overlaps are
avoided as redundancy will only worsen the compression rate.
(3) All patches in the same location are collected into a set.
(4) The mean of each set of patches is computed, stored, and removed from
each patch.
(5) For each set, a dictionary is trained, either using a linear approximation
(i.e., PCA) or non-linear approximation (i.e., K-SVD).
(6) Each patch location is assigned a constant number of atoms to use, and
quantization levels to use, both varying from location to location. This
assignment is done by minimizing the mean error on the training set while
achieving the desired compression rate.
Once the training procedure ends, for each patch location, its mean patch,
dictionary, number of allotted atoms and quantization levels are stored both in the
encoder and decoder.
4.2. Compressing and decompressing
When a new image is to be compressed, it undergoes the following stages (similar
to the training stage):
(1) The same key points in the image are detected and the image is warped.
(2) The (warped) image is divided into non-overlapping 15 × 15 patches.
(3) For each patch, the mean of this location is removed.
(4) Sparse coding over this location’s dictionary (or projection onto the PCA)
is carried out, using the number of atoms allotted to this location.
(5) The values of the coeﬃcients selected are quantized.
(6) Entropy coding is used to further compress the sent values.
Note that if K-SVD is used, when sending the atoms’ coeﬃcients their indices
are sent as well, while in PCA, only the coeﬃcients are sent. The recovery algorithm
is the exact opposite. Entropy de-coding is performed on the sent data, and each
patch is then reconstructed from the send coeﬃcients (and indices if K-SVD is
used). The inverse transform is applied to the image, returning to an image that is
as close as possible to the original. Figure 4 presents the obtained results for 550
Bytes per image.
5. Summary
The ﬁeld of sparse and redundant representation modeling oﬀers a new model, and
this can be brought to various problems in image processing, often leading to state-
of-the-art results. We have seen in these lecture-notes a partial list of these success
stories, and many more have been introduced to the scientiﬁc community in the
past few years. More applications, and more details in general about this ﬁeld and
its impact to image processing, can be found in my book:
M. Elad, Sparse and Redundant Representations:
From Theory to Applications in Signal and Image
Processing, Springer, New-York, 2010.

LECTURE 5. IMAGE PROCESSING - MORE PRACTICE
203
Figure 4. Facial image compression. From left to right: the orig-
inal image, JPEG results, JPEG-2000 results, local-PCA, and K-
SVD. The numbers represent the mean-squared-error per pixel af-
ter compression and decompression with 550 Bytes.


Bibliography
[1] Z. Ben-Haim, Y.C. Eldar, and M. Elad, Coherence-based performance guarantees
for estimating a sparse vector under random noise, to appear in IEEE Trans. on
Signal Processing.
[2] M. Aharon, M. Elad, and A.M. Bruckstein. K-SVD: An algorithm for designing of
overcomplete dictionaries for sparse representation, IEEE Trans. on Signal Pro-
cessing, 54(11):4311–4322, November 2006.
[3] A.M. Bruckstein, D. L. Donoho, and M. Elad, From sparse solutions of systems
of equations to sparse modeling of signals and images, SIAM Review, 51(1):34-81,
2009.
[4] O. Bryt and M. Elad, Compression of facial images using the K-SVD algorithm,
Journal of Visual Communication and Image Representation, 19(4):270–283, May
2008.
[5] E.J. Cand`es, J. Romberg, and T. Tao, Robust uncertainty principles: Exact signal
reconstruction from highly incomplete frequency information, IEEE Trans. Inform.
Theory, 52:489-509, 2006.
[6] E.J. Cand`es and T. Tao, The Dantzig selector: Statistical estimation when p is
much larger than n, Annals of Statistics, 35(6):2313–2351, June 2007.
[7] S.S. Chen, D.L. Donoho, and M.A. Saunders, Atomic decomposition by basis pur-
suit, SIAM Journal on Scientiﬁc Computing, 20(1):33–61 (1998).
[8] I. Daubechies, M. Defrise, and C. De-Mol, An iterative thresholding algorithm for
linear inverse problems with a sparsity constraint, Communications on Pure and
Applied Mathematics, LVII:1413–1457, 2004.
[9] G. Davis, S. Mallat, and M. Avellaneda, Adaptive greedy approximations, Journal
of Constructive Approximation, 13:57–98, 1997.
[10] M.N. Do and M. Vetterli, The contourlet transform:
an eﬃcient directional
multiresolution image representation, IEEE Trans. Image on Image Processing,
14(12):2091–2106, 2005.
[11] D.L. Donoho, De-noising by soft thresholding, IEEE Trans. on Information The-
ory, 41(3):613–627, 1995.
[12] D.L. Donoho, For most large underdetermined systems of linear equations, the
minimal ℓ1-norm solution is also the sparsest solution, Communications On Pure
And Applied Mathematics, 59(6):797–829, June 2006.
[13] D.L. Donoho, For most large underdetermined systems of linear equations, the
minimal ℓ1-norm near-solution approximates the sparsest near-solution, Commu-
nications On Pure And Applied Mathematics, 59(7):907–934, July 2006.
[14] D.L. Donoho and M. Elad, Optimally sparse representation in general (non-
orthogonal) dictionaries via l1 minimization, Proc. of the National Academy of
Sciences, 100(5):2197–2202, 2003.
[15] D.L. Donoho and M. Elad, On the stability of the basis pursuit in the presence of
noise, Signal Processing, 86(3):511–532, March 2006.
[16] D.L. Donoho, M. Elad, and V. Temlyakov, Stable recovery of sparse overcomplete
representations in the presence of noise, IEEE Trans. On Information Theory,
52(1):6–18, 2006.
[17] D.L. Donoho and I.M. Johnstone, Ideal denoising in an orthonormal basis chosen
from a library of bases, Comptes Rendus del’Academie des Sciences, Series A,
319:1317–1322, 1994.
205

206
MICHAEL ELAD, SPARSE REPRESENTATION MODELLING
[18] D.L. Donoho and J. Tanner, Neighborliness of randomly-projected Simplices in
high dimensions, Proceedings Of The National Academy Of Sciences, 102(27):9452–
9457, July 2005.
[19] D.L. Donoho and J. Tanner, Sparse nonnegative solutions of underdetermined lin-
ear equations by linear programming, Proc. Natl. Acad. Sci., 102:9446-9451 , 2005.
[20] B. Efron, T. Hastie, I.M. Johnstone, and R. Tibshirani, Least angle regression, The
Annals of Statistics, 32(2):407–499, 2004.
[21] M. Elad, Why simple shrinkage is still relevant for redundant representations?, to
appear in the IEEE Trans. On Information Theory.
[22] M. Elad, Sparse and Redundant Representations: From Theory to Applications in
Signal and Image Processing, Springer New-York, 2010.
[23] M. Elad and M. Aharon, Image denoising via sparse and redundant representations
over learned dictionaries, IEEE Trans. on Image Processing 15(12):3736–3745, De-
cember 2006.
[24] M. Elad, B. Matalon, and M. Zibulevsky, Coordinate and subspace optimization
methods for linear least squares with non-quadratic regularization, Applied and
Computational Harmonic Analysis, 23:346–367, November 2007.
[25] M. Elad and M. Zibulevsky, Iterative shrinkage algorithms and their acceleration for
l1-l2 signal and image processing applications”, IEEE Signal Processing Magazine,
27(3):78–88, May 2010.
[26] M.A. Figueiredo and R.D. Nowak, An EM algorithm for wavelet-based image
restoration, IEEE Trans. Image Processing, 12(8):906–916, 2003.
[27] M.A. Figueiredo, and R.D. Nowak, A bound optimization approach to wavelet-
based image deconvolution, IEEE International Conference on Image Processing -
ICIP 2005, Genoa, Italy, 2:782–785, September 2005.
[28] I.F. Gorodnitsky and B.D. Rao, Sparse signal reconstruction from limited data
using FOCUSS: A re-weighted norm minimization algorithm, IEEE Trans. On
Signal Processing, 45(3):600–616, 1997.
[29] R. Gribonval and M. Nielsen, Sparse decompositions in unions of bases, IEEE
Trans. on Information Theory, 49(12):3320–3325, 2003.
[30] O.G. Guleryuz, Nonlinear approximation based image recovery using adaptive
sparse reconstructions and iterated denoising - Part I: Theory, IEEE Trans. on
Image Processing, 15(3):539–554, 2006.
[31] O.G. Guleryuz, Nonlinear approximation based image recovery using adaptive
sparse reconstructions and iterated denoising - Part II: Adaptive algorithms, IEEE
Trans. on Image Processing, 15(3):555–571, 2006.
[32] K. Kreutz-Delgado, J.F. Murray, B.D. Rao, K. Engan, T-W, Lee, and T.J. Se-
jnowski, Dictionary learning algorithms for sparse representation, Neural Compu-
tation, 15(2)349–396, 2003.
[33] S.-J. Kim, K. Koh, M. Lustig, S. Boyd, and D. Gorinevsky, A method for large-
scale ,1-regularized least squares problems with applications in signal processing
and statistics, IEEE J. Selected Topics Signal Processing, 1(4):606-617, Dec. 2007.
[34] J.B. Kruskal, Three-way arrays: rank and uniqueness of trilinear decompositions,
with application to arithmetic complexity and statistics, Linear Algebra and its
Applications, 18(2):95–138, 1977.
[35] X. Liu and N.D. Sidiropoulos, Cramer-Rao lower bounds for low-rank decompo-
sition of multidimensional arrays, IEEE Trans. on Signal Processing, 49(9):2074–
2086, 2001.
[36] J. Mairal, M. Elad, and G. Sapiro, Sparse representation for color image restoration,
IEEE Trans. on Image Processing, 17(1):53–69, January 2008.
[37] J. Mairal, F. Bach, J. Ponce, G. Sapiro and A. Zisserman, Non-local sparse mod-
els for image restoration, International Conference on Computer Vision (ICCV),
Tokyo, Japan, 2009.
[38] S. Mallat, A Wavelet Tour of Signal Processing, Academic-Press, Second-Edition,
2009.
[39] S. Mallat and E. LePennec, Sparse geometric image representation with bandelets,
IEEE Trans. on Image Processing, 14(4):423–438, 2005.

207
BIBLIOGRAPHY
[40] S. Mallat and Z. Zhang, Matching pursuits with time-frequency dictionaries, IEEE
Trans. Signal Processing, 41(12):3397–3415, 1993.
[41] B.K. Natarajan, Sparse approximate solutions to linear systems, SIAM Journal on
Computing, 24:227–234, 1995.
[42] Y.C. Pati, R. Rezaiifar, and P.S. Krishnaprasad, Orthogonal matching pursuit:
recursive function approximation with applications to wavelet decomposition, the
twenty seventh Asilomar Conference on Signals, Systems and Computers, 1:40–44,
1993.
[43] M. Protter and Michael Elad, Image sequence denoising via sparse and redundant
representations, IEEE Trans. on Image Processing, 18(1):27–36, January 2009.
[44] L. Rudin, S. Osher, and E. Fatemi, Nonlinear total variation based noise removal
algorithms, Physica D, 60:259–268, 1992
[45] E.P. Simoncelli, W.T. Freeman, E.H. Adelsom, and D.J. Heeger, Shiftable multi-
scale transforms, IEEE Trans. on Information Theory, 38(2):587–607, 1992.
[46] J.-L. Starck, E.J. Cand`es, and D.L. Donoho, The curvelet transform for image
denoising, IEEE Trans. on Image Processing, 11:670–684, 2002.
[47] J.-L. Starck, M. Elad, and D.L. Donoho, Redundant multiscale transforms and
their application for morphological component separation, Advances in Imaging
And Electron Physics, 132:287–348, 2004.
[48] J.-L. Starck, M. Elad, and D.L. Donoho, Image decomposition via the combina-
tion of sparse representations and a variational approach. IEEE Trans. On Image
Processing, 14(10):1570–1582, 2005.
[49] T. Strohmer and R. W. Heath, Grassmannian frames with applications to coding
and communication, Applied and Computational Harmonic Analysis, 14:257–275,
2004.
[50] J.A. Tropp, Greed is good: Algorithmic results for sparse approximation, IEEE
Trans. On Information Theory, 50(10):2231–2242, October 2004.
[51] J.A. Tropp, Just relax: Convex programming methods for subset selection and
sparse approximation, IEEE Trans. On Information Theory, 52(3):1030–1051,
March 2006.
[52] J.A. Tropp, I.S. Dhillon, R.W. Heath Jr., and T. Strohmer, Designing struc-
tured tight frames via alternating projection, IEEE Trans. Information Theory,
51(1):188–209, January 2005.
[53] J.A. Tropp and A.A. Gilbert, Signal recovery from random measurements via or-
thogonal matching pursuit, Submitted for publication, April 2005.
[54] J. Yang, J. Wright, T. Huang, and Y. Ma, Image super-resolution via sparse rep-
resentation, to appear in PIEEE Trans. on Image Processing.


