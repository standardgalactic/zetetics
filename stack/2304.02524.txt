arXiv:2304.02524v1  [cs.CC]  5 Apr 2023
Submitted to:
QPL 2023
© T. Laakkonen, K. Meichanetzidis & J. van de Wetering
This work is licensed under the
Creative Commons Attribution License.
Picturing counting reductions with the ZH-calculus
Tuomas Laakkonen1,a, Konstantinos Meichanetzidis1,b, John van de Wetering 2,c
1 Quantinuum, 17 Beaumont Street, Oxford OX1 2NA, United Kingdom
2 Informatics Institute, University of Amsterdam, 1098 XH Amsterdam, The Netherlands
a,b {tuomas.laakkonen, k.mei}@quantinuum.com, c john@vdwetering.name
Counting the solutions to Boolean formulae deﬁnes the problem #SAT, which is complete for the
complexity class #P. We use the ZH-calculus, a universal and complete graphical language for linear
maps which naturally encodes counting problems in terms of diagrams, to give graphical reductions
from #SAT to several related counting problems. Some of these graphical reductions, like to #2SAT,
are substantially simpler than known reductions via the matrix permanent. Additionally, our approach
allows us to consider the case of counting solutions modulo an integer on equal footing. Finally,
since the ZH-calculus was originally introduced to reason about quantum computing, we show that
the problem of evaluating ZH-diagrams in the fragment corresponding to the Clifford+T gateset, is
in FP#P. Our results show that graphical calculi represent an intuitive and useful framework for
reasoning about counting problems.
Graphical calculi like the ZX-calculus [15,16] are seeing increased usage in reasoning about quantum
computations. While earlier work in this area has mostly focused on representing existing quantum
protocols and quantum algorithms in a graphical way in order to shed light on how these protocols
work [17, 18, 26, 27, 33, 38, 39, 55, 64], recent years have seen the development of entirely new results
that improve upon the existing state-of-the-art. For instance, there are now new results proved with
a graphical calculus in quantum circuit optimisation [5, 9, 20, 21, 25, 42], veriﬁcation [13, 42, 48] and
simulation [14, 43, 44, 47, 59], as well as new protocols in measurement-based quantum computing [4,
11,41], surface codes [6,30–32,37] and other fault-tolerant architectures [50,56].
These results in quantum computing show that diagrammatic reasoning can lead to new insights and
algorithms that go beyond what is known or what even can be derived using other methods. However,
these graphical languages are in actuality not restricted to just studying quantum computing. In fact,
diagrams, the objects of a graphical calculus, can represent arbitrary tensor networks, which can represent
arbitrary 2n-dimensional matrices and so they can be used for a wide variety of problems. Whereas one
would in general perform tensor contractions in order to compute with tensor networks, a graphical
calculus equips its diagrams with a formal rewrite system, which respects their tensor semantics, and
allows for reasoning in terms of two-dimensional algebra.
In this work, we focus on counting problems which are of both practical and theoretical importance
for a variety of domains, from computing partition functions in statistical mechanics [51], to proba-
bilistic reasoning [54] and planning [10]. The computational complexity of counting problems is of
fundamental interest to computer science [53]. Counting problems also have a natural tensor network
representation [29], and the complexity of computing with tensor networks has been thoroughly stud-
ied [23]. In practice, tensor contraction algorithms for counting problems have been developed, showing
competitive performance against the state of the art [34,45].
Graphical languages like the ZX-calculus, and its close relative, the ZH-calculus, have been used to
rederive complexity-theoretic results. Townsend-Teague et al. [57] showed that the partition function
of a family of Potts models, related to knot theory and quantum computation, is efﬁciently computable.
de Beaudrap et al. [24] proved graphically that the decision version of a hard counting problem can be

2
ZH-Calculus and Counting Complexity
solved in polynomial time. These proofs are constructive, in that they introduce algorithms in terms of
rewriting strategies. Even though this line of work recasts known results in a graphical language, such
an approach is arguably more unifying and intuitive, and thus has promising potential for generalisation.
Recent work by Laakkonen et al. [47] actually derived a novel complexity-theoretic result in the form
of an improved runtime upper bound for counting problems. To obtain this result, reductions to speciﬁc
counting problems were given a fully graphical treatment, to which then a known algorithm could be
applied, after this algorithm was also treated graphically and generalised.
In this work, we continue building on this programme of applying graphical methods to counting.
Speciﬁcally, we use the ZH-calculus to rederive various counting reductions that appear in the literature,
providing a uniﬁed, and arguably simpler, presentation. Among others, we give reductions from #SAT to
#2SAT, #Planar-SAT and #Monotone-SAT. See Table 1 for an overview. Our direct proof that #2SAT
is #P-complete also allows us to considerably simplify the proof that computing the permanent of an
integer matrix is #P-complete. Our results show that graphical languages can form a useful tool for the
study of counting complexity.
In Section 1 we introduce the basics of counting complexity, the ZH-calculus and how to represent
#SAT in ZH. Then in Section 2 we present our main reductions from #SAT by rewriting ZH-diagrams.
Section 3 considers the converse problem of reducing ZH-diagram evaluation to #SAT. We conclude in
Section 4, but note that we also present some additional reductions and proofs in the appendices.
1
Preliminaries
1.1
Counting reductions
Counting complexity is deﬁned in terms of the complexity classes #P and #MP, which are the ‘counting
analogues’ of NP. The class #P, ﬁrst deﬁned by Valiant in 1979 [60], is the class of problems which
can be deﬁned as counting the number of accepting paths to a non-deterministic Turing machine (NTM)
which halts in polynomial time, whereas #MP is the class of problems which can be deﬁned as counting,
modulo M, the number of accepting paths to an NTM (that also halts in polynomial time). Note that
the notation LP is also used to indicate #2P. These complexity classes are clearly related to NP, which
consists of problems that can be deﬁned as deciding whether an NTM has any accepting path.
Famously, the Boolean satisﬁability problem SAT is NP-complete [19]. Similarly, there are notions
of #P-completeness and #MP-completeness [60]. A problem A is #P-hard (#MP-hard) if any problem in
#P (#MP) can be solved in polynomial time given an oracle for A (that is, there exists a Cook reduction
from any problem in #P to A ). A problem A is #P-complete (#MP-complete) if it is both #P-hard
(#MP-hard) and is in #P (#MP).
Deﬁnition 1. Suppose φ : Bn →B is a Boolean formula in Conjunctive Normal Form (CNF),
φ(x1,...,xn) =
m
^
i=1
(ci1 ∨ci2 ∨···∨ciki)
(1)
where cij = xl or ¬xl for some l, and let #(φ) = |{⃗x | φ(⃗x) = 1}|. Each argument to f is called a variable
and each term ci1 ∧···∧ciki a clause. Then, we deﬁne the following problems:
1. SAT: Decide whether #(φ) > 0,
2. #SAT: Compute the value of #(φ),
3. #MSAT: Compute the value of #M(φ) := #(φ) mod M.

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
3
We additionally deﬁne variants, kSAT, #kSAT, #MkSAT, which represent the case where φ is re-
stricted to contain only clauses of size at most k (note that some sources take this to be size exactly k, but
we can recover this from our deﬁnition by adding dummy variables to each clause). We also take LSAT
as alternate notation for #2SAT.
To each formula φ we associate two graphs: the incidence graph is a bipartite graph with one vertex
for each variable and one for each clause, and where a variable vertex is connected to a clause vertex if
it occurs in that clause. The primal graph has one vertex for each variable, which are connected together
if the variables occur together in a clause.
The Cook-Levin theorem [19] shows that kSAT is NP-complete for k ≥3, but in fact also shows that
#kSAT is #P-complete and #MkSAT is #MP-complete for any M, as it maps any NTM into a Boolean
formula such that the number of satisfying assigments is exactly equal to the number of accepting paths.
We will consider variants on these problems, and speciﬁcally the case where the structure of the formula
φ is restricted in some way. For each of these variants, we will append a preﬁx to SAT to indicate the
restriction:
• PL: The incidence graph of the formula is planar.
• MON: The formula is monotone - it contains either no negated variables or no unnegated variables.
• BI: The primal graph is bipartite.
1.2
The ZH-calculus
The ZH-calculus is a rigorous graphical language for reasoning about ZH-diagrams in terms of rewrit-
ing [2]. We will give here a short introduction, referring the reader to [67, Section 8] for a more in-depth
explanation.
ZH-diagrams represent tensor networks composed of the two generators of the language, the Z-spider
and the H-box. The generators and their corresponding tensor interpretations are
...
σ1
σ2
σn
=
δσ1σ2...σn
=
(
1
σ1 = σ2 = ··· = σn
0
otherwise
a
...
σ1
σ2
σn
= 1+(a−1)δ1σ1σ2...σn
=
(
a
1 = σ1 = σ2 = ··· = σn
1
otherwise
(2)
where the H-box is labelled with a constant a ∈C, and we assume a = −1 if not given. The tensors
corresponding to the generators are composed according to the tensor product and each wire connecting
two tensors indicates a contraction, i.e. a summation over a common index [67]. We will also use two
derived generators - the Z-spider with a phase, and the X-spider. These are given in terms of the other
generators as:
α
...
α
=
...
1
2
α
...
...
=
eiα
(3)
Note that the tensors are symmetric under permutation of their wires, or indices. This implies that only
the connectivity, or the topology, of the tensor network matters.

4
ZH-Calculus and Counting Complexity
The rewriting rules of the ZH-calculus are shown in Appendix A. The rules are sound, i.e. they
respect the tensor semantics, and also complete for complex-valued linear maps, i.e. if two ZH-diagrams
represent the same tensor, then there exists a sequence of rewrites which transforms one diagram to the
other.
1.3
#SAT instances as ZH-diagrams
To embed #SAT instances into ZH-diagrams, we use the translation of de Beaudrap et al. [24] where each
variable becomes a Z-spider, each clause a zero-labelled H-box, and X-spiders are used for negation. In
particular the mapping is as follows
...
Variables ⇐⇒
0
...
Clauses ⇐⇒π
π
π
Negation ⇐⇒
(4)
and to form #SAT instances, we combine these as
#(φ) =
0
0
G
π
π
π
π
...
...
...
...
...
...
(5)
where G is a collection of wires and negations, connecting each variable to its corresponding clauses.
Due to cancellation of adjacent X-spiders, an instance has an X-spider between a variable and a clause
if the variable appears unnegated in that clause, and a wire if it appears negated. For example, for the
formula φ(x1,x2,x3) = (x1 ∨¬x2 ∨¬x3)∧(x2 ∨x3)∧(¬x1 ∨¬x2), we have:
0
0
0
π
π π
#(φ) =
x1
x2
x3
(6)
In this representation, a formula that is planar corresponds to a planar ZH-diagram and a monotone one
corresponds to a ZH-diagram where there are no X-spiders or where there is an X-spider between every
H-box and Z-spider. Instances with maximum clause size k correspond to ZH-diagrams where every
H-box has degree at most k.
2
Reductions from #SAT
We will show using the ZH-calculus that the restricted versions of #SAT deﬁned above—planar, mono-
tone or bipartite— are #P- and/or #MP-complete - Table 1 gives an overview of our reductions. All these
results are already known in the literature, as will be discussed in each section, but our main contribution
is to provide a simplifying and unifying viewpoint through the use of the ZH-calculus.
2.1
#SAT →#PL-SAT
The ﬁrst, and most commonly taught, proof that PL-SAT is NP-complete was published in 1982 by
Lichtenstein [49]. This reduction is parsimonious - every satisfying assignment of the original formula

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
5
Result
Reduction
#P
#kP
NP
PL-
#2SAT
MON-
BI-
3DEG-
Theorem 1
#SAT →#PL-SAT
✓
✓
✓
✓
Theorem 2
#SAT →#2SAT
✓
✓
✓
✓
✓
Theorem 3
#SAT →#MON-SAT
✓
†
✓
✓
✓
Theorem 6
#SAT →#3DEG-SAT
✓
✓
✓
✓
✓
✓
✓
Table 1:
An overview of the main reductions presented in this paper. The two leftmost columns give
each theorem and the corresponding reduction. The middle columns (marked #P, #kP, and NP) are given
a checkmark if the corresponding reduction is valid for that complexity class. A dagger is written for
#kP if there are some additional restrictions placed on k. The rightmost columns (marked PL-, etc) show
what structure each reduction preserves - a checkmark is given if the corresponding reduction preserves
the properties of the given #SAT variant (here #2SAT indicates that the maximum clause size is two),
i.e. the reduction presented in Theorem 2 sends planar instances to planar instances, but does not send
monotone instances to monotone instances.
corresponds to one satisfying assignment of the planar formula. Hence, this proves also that #PL-SAT
and #MPL-SAT are complete for #P and #MP. Lichtenstein’s construction uses a large gadget to elim-
inate non-planarity. In the following construction, we derive a similar gadget from ﬁrst principles, by
building on a famous identity from quantum computing.
Lemma 1. For any φ ∈#kSAT with n variables and m clauses and k ≥3, there is a planar φ′ ∈#kSAT
such that #(φ) = #(φ′). Furthermore, φ′ has O(n2m2) variables and clauses, and is computable in
O(poly(n,m)) time.
Proof. Any instance φ ∈#kSAT can be drawn in the plane as a ZH-diagram with some number of
crossing wires. By using the famous identity that a SWAP gate can be written as the composition of 3
CNOTs, we have that [52]:
0
0
=
...
...
...
...
0
...
...
0 ...
...
(7)
We now need to rewrite the X-spider, which represents a classical XOR function, into CNF for this to
be a valid #SAT instance. Unfortunately, the direct translation via the Tseytin transformation [58] does
not preserve planarity. However, we can instead use the following decomposition of an XOR as NAND
gates, which is planar:
=
...
...
...
...
...
...
(8)
Finally, NAND gates themselves have the following planar Tseytin transformation [58] into CNF:
...
...
... =
...
...
...
0
π
π
π
π
0
0
(9)

6
ZH-Calculus and Counting Complexity
Therefore, applying this to φ gives φ′ with n+12c variables and m+36c clauses where c is the number
of crossings. If the φ is drawn with straight-line wires only, then since there are at most nm wires in the
diagram and each pair can cross at most once, we have c ≤O(n2m2). As this rewrite introduces only
clauses of size three or less, φ′ is still a #kSAT instance.
Theorem 1. We have the following:
1. #PL-kSAT and #PL-SAT are #P-complete for any k ≥3.
2. #MPL-kSAT and #MPL-SAT are #MP-complete for any M ≥2 and k ≥3.
3. PL-kSAT and PL-SAT are NP-complete for any k ≥3.
Proof.
1. This follows immediately from Lemma 1 since the size of the rewriting does not depend on the
clause size.
2. This also follows from Lemma 1, since #(φ) = #(φ′) implies #M(φ) = #M(φ′) for any M.
3. This follows immediately from Lemma 1 since if #(φ) = #(φ′) implies that φ is satisﬁable if and
only if φ′ is satisﬁable.
2.2
#SAT to #2SAT
While it is known that #2SAT is #P-complete [62], the proof by Valiant relies on a chain of reductions
from #SAT to the permanent of an integer matrix, to the permanent of a binary matrix, to counting perfect
matchings in graphs, to counting all matchings in graphs, and then ﬁnally to #MON-BI-2SAT. Moreover,
this proof does not generalize to the case of #MP - in fact, proof that L2SAT is LP-complete was only
shown 27 years later in 2006 using a completely different method of holographic reductions [63], and
then a reduction for any ﬁxed M was given in 2008 by Faben [28]. In this section we give a simple direct
reduction from #SAT to #2SAT that applies both for #P and #MP.
Lemma 2 ( [47, Lemma 3.3]). The following equivalence holds:
0
=
0
0
π
π
π
...
...
(10)
Lemma 3. For any M = 2r +1 and φ ∈#MSAT with n variables and m clauses, there is a φ′ ∈#M2SAT
with O(n+mr) variables such that #M(φ) = #M(φ′), and φ′ can be computed in O(poly(n,m,r)) time.
Proof. By evaluating the matrices, we have
0 π
2
=
and therefore:
0
=
...
...
0
π
π
0
π = ...
0
π
π
0
−1
≡...
0
π
π
0
2r
mod 2r +1
...
0
π
π
0
M=
2
2
...
r copies
...
0
π
π
0
=
r copies
π
π
0
0
...
(11)
In this way we can rewrite all of the clauses in φ to form a suitable φ′.

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
7
Lemma 4. For any M > 2 and φ ∈#MSAT with n variables and m clauses, there is a φ′ ∈#M2SAT with
O(n+mM) variables such that #M(φ) = #M(φ′), and φ′ can be computed in O(poly(n,m,M)) time.
Proof. By evaluating the matrices, we have
0 π
r + 1
=
r
for all r. Therefore:
0
=
...
...
0
π
π
0
π = ...
0
π
π
0
−1
≡...
0
π
π
0
M −1
mod M
...
0
π
π
0
1
=
π
0 π
0
...
M −2 copies
...
0
π
π
0
I,U
=
π
0
π
0
...
M −2 copies
π
0
(12)
In this way we can rewrite all of the clauses in φ to form a suitable φ′.
Theorem 2. We have the following:
1. #M2SAT is #MP-complete for any M ≥2.
2. #2SAT is #P-complete.
Proof.
1. If M = 2, this follows from Lemma 3 with r = 0. If M > 2, then since M is ﬁxed, this follows from
Lemma 4.
2. For any φ ∈#SAT with n variables, note that 0 ≤#(φ) ≤2n. Hence #(φ) = #2n+1(φ), and so we can
apply Lemma 3 with r = n to generate φ′ ∈#2SAT such that #(φ) = #2n+1(φ′) = #(φ′) mod 2n+1
in polynomial time, giving a polynomial-time counting reduction from #SAT to #2SAT.
Corollary 1. #MPL-2SAT is #MP-complete for any M ≥2, and #PL-2SAT is #P-complete.
Proof. Note that the reductions given in Lemmas 3 and 4 preserve the planarity of the input instance.
Hence this follows by ﬁrst applying Lemma 1 and then Theorem 2.
Corollary 2. #MBI-2SAT is #MP-complete for any M ≥2, and #BI-2SAT is #P-complete.
Proof. When we apply Lemmas 3 and 4, the #2SAT instance obtained will always be bipartite, so this
follows from Theorem 2. We can see this as the primal graph has vertices in two groups: the set V of
vertices corresponding to variables of the original formula, and the sets Ci of the vertices introduced to
decompose clauses. The subgraph for each Ci is clearly bipartite, so let CA
i and CB
i be the corresponding
partition. Each vertex in V only connects to at most one vertex ci in each Ci, and assume without loss of
generality that ci ∈CA
i . Then the whole graph can be partitioned as V ∪CB
1 ∪···∪CB
m and CA
1 ∪···∪CA
m,
so it is bipartite.

8
ZH-Calculus and Counting Complexity
2.3
#SAT →#MON-SAT
While in the previous section we showed that #2SAT was #P-complete, other proofs [62] of this fact
actually consider the subset #MON-BI-2SAT. In this section we give a reduction from #SAT to #MON-
SAT, allowing us to remove negations from any CNF formula. This shows that our graphical method is
not any less powerful than the reduction via the permanent, and we argue that this chain of reductions
is more intuitive because it allows us to gradually restrict the formulae, rather than jumping straight to a
highly restrictive variant.
Lemma 5. For any r ≥0 and φ ∈#2rSAT with n variables, m clauses, and maximum clause size at
least two, there is a monotone φ′ ∈#2rSAT with O(n + nmr) variables and O(m + nmr) clauses such
that #2r(φ) = #2r(φ′). Additionally, φ′ preserves the maximum clause size of φ, and can be computed in
O(poly(n,m,r)) time.
Proof. By evaluating the matrices, we have
2
=
π
π
0
0
and therefore,
π
=
π
π
0
0
≡
mod 2r
M=
π
π
0
2
2
...
π=
π
π
0
0
π
π
π
π
0
2r
π
π
r copies
=
π
π
π
π
0
...
r copies
π
π
π
π
π
π
0
0
0
0
π=
0
...
r copies
0
0
0
0
(13)
where the ﬁrst equality follows from the Tseytin transformation of the NOT gate [58]. Thus we can
remove every negation in φ as follows:
π
0
SFZ
≡
0
...
r copies
0
0
0
0
0
...
...
...
...
mod 2r
(14)
There are at most nm negations in φ, and each can be rewritten with O(r) clauses and variables. Note
that this rewrite introduces only clauses of size two, so the maximum clause size is preserved.
Theorem 3. We have the following:
1. #2rMON-kSAT and #2rMON-SAT are #2rP-complete for any r ≥0 and k ≥2.
2. #MON-kSAT and #MON-SAT are #P-complete for any k ≥2.
Proof.
1. This follows immediately from Lemma 5. Since the transformation preserves maximum clause
size, this holds for either bounded or unbounded clause size.
2. For any φ ∈#kSAT with n variables and k ≥2, note that 0 ≤#(φ) ≤2n. Hence #(φ) = #2n+1(φ),
and so we can apply Lemma 5 with r = n + 1 to generate φ′ ∈#MON-kSAT such that #(φ) =
#2n+1(φ′) = #(φ′) mod 2n+1 in polynomial time, giving a polynomial-time counting reduction
from #kSAT to #MON-kSAT. The same argument also gives a reduction for #MON-SAT.

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
9
2.4
Other Reductions
Using similar methods we can also consider other restrictions of #SAT. For example, in Appendix B,
we combine Theorems 1, 2, and 3 with further reductions to show that #MON-BI-PL-3DEG-2SAT,
where 3DEG- indicates each variable participates in at most three clauses, is #P-complete. This case is
interesting because it is as small as possible - if we instead have each variable participate in only two
clauses then this is in P [22]. Indeed most upper bounds on runtime for #2SAT have better special case
for this type of formula [22,65].
As phase-free ZH-diagrams naturally encode #SAT instances, the ZH-calculus is mostly suited to
treat variations on the #SAT problem. To apply the technique of graphical reasoning to other (counting)
problems, we hence may need to use other graphical calculi. In particular, in Appendix C, we show
how the ZW-calculus [35] is naturally adapted to both the #XSAT problem (of which #1-in-3SAT is a
special case) and the #PERFECT-MATCHINGS problem, and use this shared structure to give graph-
ical reductions showing that both are #P-complete. This complements the recent result of Carette et
al. illustrating with the ZW-calculus that #PLANAR-PERFECT-MATCHINGS is in P [12].
While the reductions given above contribute to simplifying the literature in their own right, we can
also derive other simpliﬁcations from them. For example, the original proof by Valiant [60] (and the
simpliﬁcation by Ben-Dor and Halevi [7]) that computing the permanent of a boolean matrix is #P-
complete relies on a reduction from #3SAT. It would be simpler to reduce from #MON–2SAT, but the
original proof that #MON–2SAT is #P-complete relies on a reduction from the permanent, so this would
be circular.
However, by Theorems 2 and 3 we have #P-completeness for #MON–2SAT independent of the
permanent. This then allows us to give an alternate, simpler proof that computing the permanent of an
integer matrix is #P-complete, which we present in Appendix D. In the original proof of Ben-Dor and
Halevi [7], they construct for a given #3SAT instance a weighted directed graph with two cycles per
variable and a gadget of seven vertices for each clause such that the permanent of the adjacency matrix
of the graph equals the value of the #3SAT instance. As ﬁnding a suitable clause gadget was difﬁcult,
they found a suitable one using computer algebra. Our proof adapts theirs, but as we can start from a
#MON–2SAT instance, our graph can be made simpler, only requiring one cycle per variable, and a
symmetric clause gadget of just four vertices. This was found, and can easily be proven correct, by hand.
3
Evaluating ZH-Diagrams
While we have so far shown that variants of #SAT can be embedded into ZH-diagrams, and thus that the
problem of evaluating an arbitrary scalar ZH-diagram is #P-hard, we haven’t yet answered how much
harder it might be. I.e whether this problem is in #P. In this section we will show that evaluating ZH-
diagrams comprised of a certain fragment of generators is complete for FP#P. FP is the class of functions
that can be evaluated in polynomial time by a deterministic Turing machine (i.e the function analog of
P), and FP#P is thus the class of functions that can be evaluated in polynomial time by a deterministic
Turing maching with access to an oracle for a #P-complete problem (in our case we will use #SAT).
In order to consider the problem of evaluating ZH diagrams formally, we ﬁrst deﬁne the problem
Eval-F which is the task of ﬁnding the complex number corresponding to a scalar diagram that exists in
fragment F of a graphical calculus. A fragment is a set of diagrams built from arbitrary combinations of
a ﬁxed subset of generators.
Deﬁnition 2. For a given fragment F, the problem Eval-F is deﬁned as follows:

10
ZH-Calculus and Counting Complexity
Input A scalar diagram D ∈F consisting of n generators and wires in total, where any parameters of
the generators of D can be expressed in O(poly(n)) bits.
Output The value D ∈C.
The runtime of an algorithm for Eval-F is deﬁned in terms of the parameter n.
We will examine two fragments ZHπ/2k ⊇ZHπ and show that they can be reduced to #SAT. Far from
being purely academic, ZHπ is expressive enough to capture Toffoli-Hadamard quantum circuits, and
ZHπ/2k can additionally capture Clifford+T quantum circuits, both of which are approximately universal
for quantum computation.
Deﬁnition 3. ZHπ is the fragment of ZH-calculus given by the following generators:
...
...
π
...
...
...
...
π
...
...
...
...
(15)
Lemma 6. The following diagram equivalence holds:
0
0
0
0
π
π
π
π
π
π
=
(16)
This is derived from the Tseytin transformation of the XOR operation [58].
Theorem 4. There is a polynomial-time counting reduction from the problem Eval-ZHπ to #3SAT and
so Eval-ZHπ is in FP#P. Note that Eval-ZHπ is equivalent to the problem #SAT± as deﬁned in [47].
Proof. In order to rewrite a diagram D from ZHπ into #3SAT, we ﬁrst rewrite all of the non-scalar
H-boxes into zero H-boxes with two legs:
...
SFH
=
...
=
π
π
0
0
π
...
0 π
π
1
2
=
π
π
0
0
π
...
0
π
(17)
Where the second equality follows from Lemma A.4 in [47]. Now, we can remove all the X-spiders and
π-phase Z-spiders as follows, to rewrite into a valid #SAT diagram:
1. Any spiders or H-boxes with no legs should be removed from the diagram. Evaluate them by
concrete calculation and multiply their values together to get a scalar multiplier c for the diagram.
If there are no such spiders or H-boxes, set c = 1.
2. Extract the phases from all π-phase Z-spiders as follows:
π
π
...
...
...
π=
...
...
...
π
(18)
3. Unfuse the phase of every X-spider with at least two legs:
aπ
...
...
SF=
aπ
(19)

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
11
4. For any X-spiders with at least three legs, unfuse them and apply Lemma 6 to each X-spider:
...
=
...
=
...
(20)
5. Replace X-spiders with one leg as follows:
=
0
π
0 π
=
(21)
6. Excepting the single Z-spider with a π-phase, use the SFZ rule to fuse Z-spiders wherever possible.
If there are two two-legged zero H-boxes connected together directly, introduce a Z-spider between
them using the IZ rule.
At this point, this diagram follows the form of a #3SAT diagram except for a possible single π-phase
Z-spider. To remove the π-phase Z-spider, we can write the diagram as a sum of two diagrams which
don’t contain this phase:
π
=
π
−
=
0
π
−0
...
...
...
...
...
(22)
Since these two diagrams are #3SAT diagrams associated with some Boolean functions f1 and f2, the
value of D is then given by D = c(#( f1)−#( f2)).
Note that this method of splitting an instance into positive and negative components is similar to
Bernstein and Vazirani’s proof that BQP ⊆P#P [8, Theorem 8.2.5]. Now we can move on to considering
larger fragments fairly easily. We will show that by using gadgets to copy certain “magic states” - that
is, one-legged H-boxes with speciﬁc labels which we can split as sums - we can introduce phases which
are multiples of π
2k for any ﬁxed k.
Deﬁnition 4. ZHπ/2k for k ∈N is the fragment of ZH-calculus given by the following generators
nπ
2k
...
...
nπ
2k
...
...
...
...
(23)
where n ∈Z.
Lemma 7. The following diagram equivalence holds:
a
a2
a
a
=
(24)
Lemma 8. For all k > 0, there is a reduction from Eval-ZHπ/2k to Eval-ZHπ/2k−1.
Proof. Let D be a diagram in ZHπ/2k. In order to rewrite this into a diagram in ZHπ/2k−1, we need to
remove all Z-spiders with phases that are odd multiples n of π
2k , since even multiples of π
2k are already
valid for ZHπ/2k−1. Assume that n = 2m+1, then:
nπ
2k
...
...
SFZ
=
miπ
2k−1
...
...
π
2k
=
miπ
2k−1
...
...
exp iπ
2k
(25)

12
ZH-Calculus and Counting Complexity
Let a = e
iπ
2k , then by applying Lemma 7, fold up all of a-labelled H-boxes into one
a
a
...
=
a2
a
a2
a
...
a
...
SFH
=
a2
a2
1
2
1
2
(26)
and note that a2
=
π
2k−1
is in ZHπ/2k−1. Remove all scalar H-boxes from D and let their product be
c. Finally, we can split the remaining a-labelled H-box, giving D as the sum of two diagrams D1 and D2
in ZHπ/2k−1:
a
π
=
+ a
(27)
so then D = c(D1 +aD2).
Theorem 5. Eval-ZHπ/2k is FP#P-complete for all k ≥0.
Proof. By induction on Lemma 8 with the base case k = 0 given by Theorem 4, we have that Eval-ZHπ/2k
is in FP#P. It is clearly FP#P-hard, as ZHπ/2k contains the diagrams representing #SAT instances, and
hence is FP#P-complete.
The fragment ZHπ/22 captures precisely those diagrams that represent postselected Clifford+T quan-
tum circuits. Our results above hence also lead to a proof that PostBQP ⊆P#P, although note that this is
weaker than Aaronson’s result that PostBQP = PP [1].
4
Conclusion
In this paper we have used the ZH-calculus to simplify and unify the proofs of several known results
in counting complexity. In particular, we examined various variants of #SAT and show that they are
#P-complete, and similarly that the corresponding #MSAT variants are #MP-complete. We for instance
produced a simple direct reduction from #SAT to #2SAT, which considerably simpliﬁed existing proofs
that procede via a reduction to the matrix permanent. Our results show that graphical calculi like the ZH-
calculus, even though originally meant for the domain of quantum computing, can provide an intuitive
framework for working with counting problems, through their interpretation as tensor networks.
We also brieﬂy examined how other graphical calculi can be used to reason about other counting
problems, especially the ZW-calculus and its connection to counting perfect matchings in graphs. A
natural future direction is to explore which counting problems can be naturally formulated in a graphical
calculus. Finally, we also observed how the original domain of quantum computing can be related to
#SAT via the ZH-calculus, and show that the computational problem of evaluating ZH-diagrams that
represent postselected Clifford+T or Toffoli+Hadamard quantum circuits is in FP#P, and hence can be
efﬁciently evaluated with an #SAT oracle - evaluating whether this leads to a more efﬁcient method for
simulating quantum circuits is an interesting avenue for future research.
Acknowledgements
Some of this work was done while TL was a student at the University of Oxford, and the results in Section
3 are also presented in his Master’s thesis [46]. We thank Richie Yeung, Matty Hoban, and Julien Codsi
for helpful feedback.

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
13
References
[1] Scott Aaronson (2005): Quantum computing, postselection, and probabilistic polynomial-time. Proceed-
ings of the Royal Society A: Mathematical, Physical and Engineering Sciences 461(2063), pp. 3473–3482,
doi:10.1098/rspa.2005.1546.
[2] Miriam Backens & Aleks Kissinger (2019): ZH: A Complete Graphical Calculus for Quantum Computations
Involving Classical Non-linearity. Electronic Proceedings in Theoretical Computer Science 287, pp. 23–42,
doi:10.4204/EPTCS.287.2. arXiv:1805.02175.
[3] Miriam Backens, Aleks Kissinger, Hector Miller-Bakewell, John van de Wetering & Sal Wolffs (2021):
Completeness of the ZH-calculus, doi:10.48550/arXiv.2103.06610. arXiv:2103.06610.
[4] Miriam Backens, Hector Miller-Bakewell, Giovanni de Felice, Leo Lobski & John van de Wetering (2021):
There and back again: A circuit extraction tale. Quantum 5, p. 421, doi:10.22331/q-2021-03-25-421.
[5] Niel de Beaudrap, Xiaoning Bian & Quanlong Wang (2020): Fast and Effective Techniques for T-Count
Reduction via Spider Nest Identities.
In Steven T. Flammia, editor: 15th Conference on the Theory of
Quantum Computation, Communication and Cryptography (TQC 2020), Leibniz International Proceedings
in Informatics (LIPIcs) 158, Schloss Dagstuhl–Leibniz-Zentrum f¨ur Informatik, Dagstuhl, Germany, pp.
11:1–11:23, doi:10.4230/LIPIcs.TQC.2020.11.
[6] Niel de Beaudrap & Dominic Horsman (2020): The ZX calculus is a language for surface code lattice
surgery. Quantum 4, doi:10.22331/q-2020-01-09-218.
[7] A. Ben-Dor & S. Halevi (1993): Zero-One Permanent Is \#P-complete, a Simpler Proof. In: [1993] The 2nd
Israel Symposium on Theory and Computing Systems, pp. 108–117, doi:10.1109/ISTCS.1993.253457.
[8] Ethan Bernstein & Umesh Vazirani (1997):
Quantum Complexity Theory.
SIAM Journal on Com-
puting 26(5), pp. 1411–1473, doi:10.1137/S0097539796300921. arXiv:https://doi.org/10.1137/
S0097539796300921.
[9] Agust´ın Borgna, Simon Perdrix & Benoˆıt Valiron (2021): Hybrid quantum-classical circuit simpliﬁcation
with the ZX-calculus. In Hakjoo Oh, editor: Programming Languages and Systems, Springer International
Publishing, Cham, pp. 121–139, doi:10.1007/978-3-030-89051-3_8.
[10] Tom Bylander (1994): The computational complexity of propositional STRIPS planning.
Artiﬁcial In-
telligence 69(1), pp. 165–204, doi:https://doi.org/10.1016/0004-3702(94)90081-7. Available at
https://www.sciencedirect.com/science/article/pii/0004370294900817.
[11] Shuxiang Cao (2022): Multi-agent blind quantum computation without universal cluster state. arXiv preprint
arXiv:2206.13330.
[12] Titouan Carette, Etienne Moutot, Thomas Perez & Renaud Vilmart (2023): Compositionality of Planar Per-
fect Matchings, doi:10.48550/arXiv.2302.08767. arXiv:2302.08767.
[13] Kostia Chardonnet, Benoˆıt Valiron & Renaud Vilmart (2021): Geometry of Interaction for ZX-Diagrams.
In Filippo Bonchi & Simon J. Puglisi, editors: 46th International Symposium on Mathematical Foundations
of Computer Science (MFCS 2021), Leibniz International Proceedings in Informatics (LIPIcs) 202, Schloss
Dagstuhl – Leibniz-Zentrum f¨ur Informatik, Dagstuhl, Germany, pp. 30:1–30:16, doi:10.4230/LIPIcs.
MFCS.2021.30.
[14] Julien Codsi & John van de Wetering (2022): Classically Simulating Quantum Supremacy IQP Circuits
through a Random Graph Approach. arXiv preprint arXiv:2212.08609.
[15] Bob Coecke & Ross Duncan (2008): Interacting quantum observables. In: Proceedings of the 37th Interna-
tional Colloquium on Automata, Languages and Programming (ICALP), Lecture Notes in Computer Science,
doi:10.1007/978-3-540-70583-3_25.
[16] Bob Coecke & Ross Duncan (2011): Interacting Quantum Observables: Categorical Algebra and Diagram-
matics. New Journal of Physics 13(4), p. 043016, doi:10.1088/1367-2630/13/4/043016.

14
ZH-Calculus and Counting Complexity
[17] Bob Coecke, Bill Edwards & Rob Spekkens (2011): Phase groups and the origin of non-locality for qubits.
Electronic Notes in Theoretical Computer Science 270(2), pp. 15–36, doi:10.1016/j.entcs.2011.01.
021.
[18] Bob Coecke & Aleks Kissinger (2017): Picturing Quantum Processes: A First Course in Quantum Theory
and Diagrammatic Reasoning. Cambridge University Press, Cambridge, doi:10.1017/9781316219317.
[19] Stephen A. Cook (1971): The Complexity of Theorem-Proving Procedures. In: Proceedings of the Third
Annual ACM Symposium on Theory of Computing, STOC ’71, Association for Computing Machinery, New
York, NY, USA, pp. 151–158, doi:10.1145/800157.805047.
[20] Alexander Cowtan, Silas Dilkes, Ross Duncan, Will Simmons & Seyon Sivarajah (2020): Phase Gadget
Synthesis for Shallow Circuits. In Bob Coecke & Matthew Leifer, editors: Proceedings 16th International
Conference on Quantum Physics and Logic, Chapman University, Orange, CA, USA., 10-14 June 2019,
Electronic Proceedings in Theoretical Computer Science 318, Open Publishing Association, pp. 213–228,
doi:10.4204/EPTCS.318.13.
[21] Alexander Cowtan, Will Simmons & Ross Duncan (2020): A Generic Compilation Strategy for the Unitary
Coupled Cluster Ansatz. arXiv preprint arXiv:2007.10515.
[22] Vilhelm Dahll¨of, Peter Jonsson & Magnus Wahlstr¨om (2002): Counting Satisfying Assignments in 2-SAT
and 3-SAT. In Oscar H. Ibarra & Louxin Zhang, editors: Computing and Combinatorics, Lecture Notes in
Computer Science, Springer, Berlin, Heidelberg, pp. 535–543, doi:10.1007/3-540-45655-4_57.
[23] Carsten Damm, Markus Holzer & Pierre McKenzie (2002): The Complexity of Tensor Calculus. Computa-
tional Complexity 11(1/2), pp. 54–89, doi:10.1007/s00037-000-0170-4.
[24] Niel de Beaudrap, Aleks Kissinger & Konstantinos Meichanetzidis (2021): Tensor Network Rewriting Strate-
gies for Satisﬁability and Counting. Electronic Proceedings in Theoretical Computer Science 340, pp. 46–59,
doi:10.4204/EPTCS.340.3. arXiv:2004.06455.
[25] Ross Duncan, Aleks Kissinger, Simon Perdrix & John van de Wetering (2020): Graph-theoretic Simpliﬁca-
tion of Quantum Circuits with the ZX-calculus. Quantum 4, p. 279, doi:10.22331/q-2020-06-04-279.
[26] Ross Duncan & Maxime Lucas (2014): Verifying the Steane code with Quantomatic. In Bob Coecke &
Matty Hoban, editors: Proceedings of the 10th International Workshop on Quantum Physics and Logic,
Castelldefels (Barcelona), Spain, 17th to 19th July 2013, Electronic Proceedings in Theoretical Computer
Science 171, Open Publishing Association, pp. 33–49, doi:10.4204/EPTCS.171.4.
[27] Ross Duncan & Simon Perdrix (2010): Rewriting measurement-based quantum computations with gener-
alised ﬂow. In: International Colloquium on Automata, Languages, and Programming, Springer, pp. 285–
296, doi:10.1007/978-3-642-14162-1_24.
Available at http://personal.strath.ac.uk/ross.
duncan/papers/gflow.pdf.
[28] John Faben (2008): The Complexity of Counting Solutions to Generalised Satisﬁability Problems modulo k,
doi:10.48550/arXiv.0809.1836. arXiv:0809.1836.
[29] Artur Garc´ıa-S´aez & Jos´e I. Latorre (2012): An Exact Tensor Network for the 3SAT Problem. Quantum Info.
Comput. 12(3–4), p. 283–292.
[30] Craig Gidney (2022): A Pair Measurement Surface Code on Pentagons. arXiv preprint arXiv:2206.12780.
[31] Craig Gidney & Austin G. Fowler (2019): Efﬁcient magic state factories with a catalyzed |CCZ⟩to 2|T⟩
transformation. Quantum 3, p. 135, doi:10.22331/q-2019-04-30-135.
[32] Craig Gidney & Austin G. Fowler (2019): Flexible layout of surface code computations using AutoCCZ
states. arXiv preprint arXiv:1905.08916.
[33] Stefano Gogioso & Aleks Kissinger (2017): Fully graphical treatment of the quantum algorithm for the
Hidden Subgroup Problem. arXiv:1701.08669.
[34] Johnnie Gray & Stefanos Kourtis (2021): Hyper-Optimized Tensor Network Contraction. Quantum 5, p. 410,
doi:10.22331/q-2021-03-15-410.

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
15
[35] Amar Hadzihasanovic (2015): A Diagrammatic Axiomatisation for Qubit Entanglement, doi:10.48550/
arXiv.1501.07082. arXiv:1501.07082.
[36] John H. Halton (1966): On the Divisibility Properties of Fibonacci Numbers. The Fibonacci Quarterly 4(3),
pp. 217–240.
[37] Michael Hanks, Marta P. Estarellas, William J. Munro & Kae Nemoto (2020): Effective Compression
of Quantum Braided Circuits Aided by ZX-Calculus.
Physical Review X 10, p. 041030, doi:10.1103/
PhysRevX.10.041030.
[38] Anne Hillebrand (2012): Superdense Coding with GHZ and Quantum Key Distribution with W in the ZX-
calculus. Electronic Proceedings in Theoretical Computer Science 95, pp. 103–121, doi:10.4204/EPTCS.
95.10.
[39] Clare Horsman (2011): Quantum picturalism for topological cluster-state computing. New Journal of Physics
13(9), p. 095011, doi:10.1088/1367-2630/13/9/095011.
[40] Mark Jerrum, Alistair Sinclair & Eric Vigoda (2004): A Polynomial-Time Approximation Algorithm for the
Permanent of a Matrix with Nonnegative Entries. Journal of the ACM 51(4), pp. 671–697, doi:10.1145/
1008731.1008738.
[41] Aleks Kissinger & John van de Wetering (2019): Universal MBQC with generalised parity-phase interactions
and Pauli measurements. Quantum 3, doi:10.22331/q-2019-04-26-134.
[42] Aleks Kissinger & John van de Wetering (2020): Reducing the number of non-Clifford gates in quantum
circuits. Physical Review A 102, p. 022406, doi:10.1103/PhysRevA.102.022406.
[43] Aleks Kissinger & John van de Wetering (2022): Simulating quantum circuits with ZX-calculus reduced
stabiliser decompositions. Quantum Science and Technology 7(4), p. 044001, doi:10.1088/2058-9565/
ac5d20.
[44] Aleks Kissinger, John van de Wetering & Renaud Vilmart (2022): Classical Simulation of Quantum Cir-
cuits with Partial and Graphical Stabiliser Decompositions. In Franc¸ois Le Gall & Tomoyuki Morimae,
editors: 17th Conference on the Theory of Quantum Computation, Communication and Cryptography (TQC
2022), Leibniz International Proceedings in Informatics (LIPIcs) 232, Schloss Dagstuhl – Leibniz-Zentrum
f¨ur Informatik, Dagstuhl, Germany, pp. 5:1–5:13, doi:10.4230/LIPIcs.TQC.2022.5.
[45] Stefanos Kourtis, Claudio Chamon, Eduardo Mucciolo & Andrei Ruckenstein (2019): Fast Counting with
Tensor Networks. SciPost Physics 7(5), p. 060, doi:10.21468/SciPostPhys.7.5.060.
[46] Tuomas Laakkonen (2022): Graphical Stabilizer Decompositions For Counting Problems. Master’s thesis,
University of Oxford. Available at https://www.cs.ox.ac.uk/people/aleks.kissinger/theses/
laakkonen-thesis.pdf.
[47] Tuomas Laakkonen, Konstantinos Meichanetzidis & John van de Wetering (2022): A Graphical #SAT Algo-
rithm for Formulae with Small Clause Density. arXiv:2212.08048.
[48] Adrian Lehmann, Ben Caldwell & Robert Rand (2022): VyZX : A Vision for Verifying the ZX Calculus. arXiv
preprint arXiv:2205.05781.
[49] David Lichtenstein (1982): Planar Formulae and Their Uses. SIAM Journal on Computing 11(2), pp. 329–
343, doi:10.1137/0211025.
[50] Daniel Litinski & Naomi Nickerson (2022): Active volume: An architecture for efﬁcient fault-tolerant quan-
tum computers with limited non-local connections. arXiv preprint arXiv:2211.15465.
[51] Cristopher Moore & Stephan Mertens (2011): The Nature of Computation. Oxford University Press, Inc.,
USA.
[52] Michael A. Nielsen & Isaac L. Chuang (2010): Quantum Computation and Quantum Information. Cambridge
University Press, doi:10.1017/CBO9780511976667.
[53] C.H. Papadimitriou (1994): Computational Complexity. Theoretical computer science, Addison-Wesley.
Available at https://books.google.gr/books?id=JogZAQAAIAAJ.

16
ZH-Calculus and Counting Complexity
[54] Dan Roth (1996):
On the hardness of approximate reasoning.
Artiﬁcial Intelligence 82(1), pp.
273–302, doi:https://doi.org/10.1016/0004-3702(94)00092-1.
Available at https://www.
sciencedirect.com/science/article/pii/0004370294000921.
[55] Razin A. Shaikh, Quanlong Wang & Richie Yeung (2022): How to sum and exponentiate Hamiltonians in
ZXW calculus. arXiv:2212.04462.
[56] Alexis Shaw, Michael Bremner, Alexandru Paler, Daniel Herr & Simon J. Devitt (2022): Quantum computa-
tion on a 19-qubit wide 2d nearest neighbour qubit array. arXiv preprint arXiv:2212.01550.
[57] Alex Townsend-Teague & Konstantinos Meichanetzidis (2021):
Classifying Complexity with the ZX-
Calculus: Jones Polynomials and Potts Partition Functions. arXiv preprint arXiv:2103.06914.
[58] G. S. Tseitin (1983): On the Complexity of Derivation in Propositional Calculus.
In J¨org H. Siek-
mann & Graham Wrightson, editors: Automation of Reasoning: 2: Classical Papers on Computational
Logic 1967–1970, Symbolic Computation, Springer, Berlin, Heidelberg, pp. 466–483, doi:10.1007/
978-3-642-81955-1_28.
[59] Christian Ufrecht, Maniraman Periyasamy, Sebastian Rietsch, Daniel D. Scherer, Axel Plinge & Christopher
Mutschler (2023): Cutting multi-control quantum gates with ZX calculus. arXiv preprint arXiv:2302.00387.
[60] L. G. Valiant (1979): The Complexity of Computing the Permanent. Theoretical Computer Science 8(2), pp.
189–201, doi:10.1016/0304-3975(79)90044-6.
[61] L. G. Valiant & V. V. Vazirani (1986): NP Is as Easy as Detecting Unique Solutions. Theoretical Computer
Science 47, pp. 85–93, doi:10.1016/0304-3975(86)90135-0.
[62] Leslie G. Valiant (1979): The Complexity of Enumeration and Reliability Problems. SIAM Journal on Com-
puting 8(3), pp. 410–421, doi:10.1137/0208032.
[63] Leslie G. Valiant (2006): Accidental Algorithms. In: 2006 47th Annual IEEE Symposium on Foundations of
Computer Science (FOCS’06), pp. 509–517, doi:10.1109/FOCS.2006.7.
[64] Jamie Vicary (2013): Topological Structure of Quantum Algorithms. 2013 28th Annual ACM/IEEE Sym-
posium on Logic in Computer Science, doi:10.1109/lics.2013.14. Available at http://dx.doi.org/
10.1109/LICS.2013.14.
[65] Magnus Wahlstr¨om (2008): A Tighter Bound for Counting Max-Weight Solutions to 2SAT Instances. In Mar-
tin Grohe & Rolf Niedermeier, editors: Parameterized and Exact Computation, Lecture Notes in Computer
Science, Springer, Berlin, Heidelberg, pp. 202–213, doi:10.1007/978-3-540-79723-4_19.
[66] Dominic Welsh & Amy Gale (2011): The Complexity of Counting Problems. In: Aspects of Complexity:
Minicourses in Algorithmics, Complexity and Computational Algebra. Mathematics Workshop, Kaikoura,
January 7-15, 2000, De Gruyter, doi:10.1515/9783110889178.
[67] John van de Wetering (2020): ZX-calculus for the working quantum computer scientist.
arXiv preprint
arXiv:2012.13966.
[68] Mingji Xia & Wenbo Zhao (2006): #3-Regular Bipartite Planar Vertex Cover Is #P-Complete. In Jin-Yi Cai,
S. Barry Cooper & Angsheng Li, editors: Theory and Applications of Models of Computation, Lecture Notes
in Computer Science, Springer, Berlin, Heidelberg, pp. 356–364, doi:10.1007/11750321_34.

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
17
A
Rewriting Rules
The ZH-calculus is equipped with the following set of sound and complete rewriting rules [2]:
...
...
...
...
...
...
...
...
=
...
...
a
...
...
...
...
a
...
...
=
=
=
...
...
...
...
...
...
=
=
=
2
2
=
a
b
a+b
2
2
π
1
=
...
...
=
π
π
=
π
a
a
a
=
a
b
ab
(SFZ)
(BAZ)
(BAH)
(SFH)
(IZ)
(IH)
(U)
(M)
(A)
(O)
(I)
We will also use the following derived rewriting rules [3, Lemmas 2.10-2.24],
...
...
...
...
...
...
...
...
=
...
...
...
...
=
π
π
π
π
π
...
=
π
π
...
(π1)
(π2)
(SFX)
(28)
as well as the generalized (M) rule [2, Lemma 2.3]:
=
a
b
...
ab
...
(M)
(29)
B
#SAT →#MON-BI-PL-3DEG-SAT
The smallest subset of #2SAT that has been considered in the literature is #PL-MON-BI-CUBIC-2SAT,
where CUBIC- indicates that the primal graph of the instance is 3-regular [68]. In this section, we show
that #3DEG-SAT is #P-complete graphically, by relating the zero-labelled H-box with the Fibonacci
numbers. Here, 3DEG- indicates that every variable appears in at most three clauses. Then in Theorem
7 we combine all of our reductions to show #P-completeness for #PL-MON-BI-3DEG-2SAT. This is
slightly less restrictive than #PL-MON-BI-CUBIC-2SAT, but retains the interesting property that the

18
ZH-Calculus and Counting Complexity
maximum degree is the lowest possible (if the maximum degree was two, then the problem can be solved
in polynomial time [22]), while avoiding the complicated global construction of the original proof.
We will make use of the following identities concerning the Fibonacci numbers, deﬁned by:
Fn = Fn−1 +Fn−2
F1 = 1
F0 = 0
(30)
Lemma 9. gcd(Fn,Fn−1) = 1 for all n > 1.
Proof. gcd(Fn,Fn−1) = gcd(Fn−1 + Fn−2,Fn−1) = gcd(Fn−2,Fn−1) thus by induction gcd(Fn,Fn−1) =
gcd(F2,F1) = 1.
Lemma 10 ( [36]). For every M ≥1 there exists some 0 < n ≤M2 such that Fn ≡0 mod M.
Lemma 11 ( [36]). Fn =
j
φn
√
5 + 1
2
k
where φ = 1+
√
5
2
is the golden ratio.
Lemma 12. Suppose that Fn ≡0 mod M, then the following rewrite holds:
≡
0
F−1
n−1
0
0
...
n copies
mod M
(31)
Proof. Note that the Fibonacci numbers are deﬁned by
Fn+1
Fn

=
1
1
1
0
 Fn
Fn−1

=⇒
1
1
1
0
n
=
Fn+1
Fn
Fn
Fn−1

(32)
and so, supposing that Fn ≡0 mod M, we have
=
0
0
0
...
n copies
1
1
1
0
n
=
Fn +Fn−1
Fn
Fn
Fn−1

≡
Fn−1
0
0
Fn−1

=
Fn−1
mod M
(33)
but by Lemma 9, Fn−1 is coprime to Fn, so it must be coprime to M and thus invertible.
Lemma 13. Given M and k such that Fk ≡0 mod M, for any φ ∈#MSAT with n variables, m clauses,
and maximum clause size at least two, there is a φ′ ∈#MSAT with O(nmk) variables and O(nmk) clauses
such that every variable has degree at most three, and #M(φ) = c·#M(φ′) mod M where c is computable
in O(poly(n,m,k)) time. Additionally, φ′ can be computed in O(poly(n,m,k)) time and preserves the
maximum clause size of φ.
Proof. For every variable in φ with degree more than three, we can apply the following rewrite by
Lemma 12:
...
≡
d wires
0
0
0
...
...
...
2k copies
d −2 copies
SFZ
=
...
d −2 copies
mod M
IZ=
0
...
2k copies
d −2 copies
0
...
0
...
F6−2d
k−1
F6−2d
k−1
(34)

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
19
since d ≤m, this adds at most O(nmk) clauses and variables. Note that we took H-box sequences of
length 2k (i.e two applications of Lemma 12) in order to preserve any bipartite structure in φ. Thus
φ now has degree at most three. Since these rewrites only add clauses of size two, they preserve the
maximum clause size. The total scalar factor accumulated across all of these rewrites is
c =
n
∏
i=1
(
F6−2di
k−1
di > 3
1
di ≤3
(35)
where di is the degree of variable i, which is clearly computable in polynomial time.
Theorem 6. We have the following:
1. #M3DEG-kSAT and #M3DEG-SAT are #MP-complete for any M ≥1 and k ≥2.
2. #3DEG-kSAT and #3DEG-SAT are #P-complete for any k ≥2.
Proof.
1. By Lemma 10, there exists some k such that Fk ≡0 mod M and it is easy to compute. Therefore,
this follows from Lemma 13 since the maximum clause size is preserved.
2. Let ψ ∈#SAT have n variables, and φ be the golden ratio. Pick k =
l
logφ

(2n +1)
√
5−1
2
m
=
O(n), then Fk ≥2n+1 by Lemma 11 and #(φ) = #Fk(φ). Apply Lemma 13 with M = Fk to generate
φ′ ∈#3DEG-SAT such that #(φ) = c·#Fk(φ′) mod Fk = c·#(φ′) mod Fk for some polynomial-
time computable c. The same argument applies for bounded clause size.
Lemma 14. Given r ≥0, for any φ ∈#2r+12SAT with n variables and m clauses, there is a bipartite
φ′ ∈#2r+12SAT with O(nmr) variables and O(nmr) clauses such that #2r+1(φ) = #2r+1(φ′), which can
be computed in O(poly(n,m,r)) time, and that preserves monotonicity and planarity.
Proof. Note that we have the following rewriting rule
0
=
0
0
0
0
0
0
0
0
0
0
π
π
0
0
π
−1
π
π
0
0
π
π
π
π=
−1
π
=
0
0
π
0
0
π
π
π=
0
0
π
0
0
π
π
π
π
π
π
π
≡
0
0
0
0
π
π
π
π
π
π
π
π
π
π
π
π
0
0
0
0
0
0
...
...
...
π=
r copies each
mod 2r +1
r copies each
(36)
where the last line follows from the the proof of Lemma 3. After this is applied to every clause of size
two, every path between two vertices in the incidence graph will have even length (since every edge is
replaced by four edges), and hence the incidence graph is bipartite.
Theorem 7. We have the following:
1. #MON-BI-PL-3DEG-2SAT is #P-complete
2. LMON-BI-PL-3DEG-2SAT is LP-complete

20
ZH-Calculus and Counting Complexity
Proof. We can reduce from arbitrary #SAT instances to #MON-BI-PL-3DEG-2SAT by applying the
previously given reductions in the following order:
#SAT 1→#PL-SAT 2→#PL-2SAT 5→#MON-PL-2SAT
14
→#MON-BI-PL-2SAT 13
→#MON-BI-PL-3DEG-2SAT
In both cases, we ﬁrst reduce to #PL-SAT using Lemma 1. Then, we continue differently:
1. Apply Theorem 2 and Theorem 3 to reduce to #MON-PL-2SAT, as these preserve planarity. Then,
given φ with n variables, we apply Lemma 14 with r = n+1 to obtain φ′ ∈#MON-BI-PL-2SAT
such that #(φ) = #2r(φ′) = #(φ′) mod 2r. Then reduce φ′ to #MON-BI-PL-3DEG-2SAT using
Theorem 6, since it preserves planarity, monotonicity and bipartite structure.
2. Similarly, given φ ∈#SAT, apply Lemma 3 with r = 0, Lemma 5 with r = 1, Lemma 14 with
r = 0, and Lemma 13 with M = 2 and k = 3, to obtain φ′ ∈#MON-BI-PL-3DEG-2SAT such that
#2(φ) = #2(φ′).
C
#PERFECT-MATCHINGS and the ZW-Calculus
While so far we have worked exclusively with the ZH-calculus, which naturally represents #SAT, we can
use other calculi to attack other problems. In this section, we will use the ZW-calculus to examine the
connection between the problems #XSAT and #PERFECT-MATCHINGS, and sketch an argument that
they are both #P-complete. Like the connection between #SAT and #2SAT given using the ZH-calculus,
with this technique we can circumvent the usual reduction via the permanent.
Deﬁnition 5. Let f : Bn →B be a boolean function deﬁned by
f(x) =
m
^
i=0
φ(ci1,...,ciki)
(37)
where cij = xk or ¬xk for some k, and φ(⃗x) = 1 if and only if w(⃗x) = 1, where w(⃗x) is the Hamming
weight of ⃗x. Each φ term deﬁnes a clause, and so f(x) = 1 iff every clause has exactly one true literal.
The problem #XSAT is to compute #( f). When ki = 3 for all i, this is also known as #1-in-3SAT.
Deﬁnition 6. The problem #PERFECT-MATCHINGS is as follows: given an undirected simple graph
G, compute the number of perfect matchings of G. That is, the number of independent edge sets of G
that cover each vertex exactly once. We denote this quantity PerfMatch(G).
The ZW-calculus is a graphical calculus built from two generators, W-spiders and Z-spiders, which
are ﬂexsymmetric [35]. The Z-spider is a close analogue of the Z-spider in ZH-calculus (except with a π
phase), whereas the W-spider represents the W-state:
...
...
...
...
= |⃗0⟩⟨⃗0|−|⃗1⟩⟨⃗1|
= ∑
u,v
w(uv)=1
|u⟩⟨v|
(38)
These, along with wires, caps, and cups, are combined with tensor product and matrix multiplication
in the same way as in the ZH-calculus. Like the ZH-calculus, we will treat diagrams purely as tensor
networks rather than formal objects - hence equality of diagrams is just equality of tensors. This calculus

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
21
is also equipped with a set of sound and complete rewrite rules, including the following spider fusion
rules,
...
...
...
...
...
...
=
...
...
...
...
...
...
=
(39)
as well as others which we omit for brevity as we don’t use them explicitly here. In the same way that
ZH-calculus diagrams naturally represent #SAT instances with Z-spiders and clauses, the ZW-calculus
naturally represents #XSAT instances with the following mapping:
Variable ⇐⇒
...
Clause ⇐⇒
...
Negation ⇐⇒
(40)
Lemma 15. #XSAT is #P-complete
Proof. We can translate from #2SAT to #XSAT with the following correspondence:
=
0
=
...
...
π
=
(41)
In the other direction, we can translate #XSAT to #SAT by ﬁrst expanding every clause of size more then
three as follows:
...
=
...
...
...
...
=
(42)
Then, each clause
φ(x,y,z) = (x∧¬y∧¬z)∨(¬x∧y∧¬z)∨(¬x∧¬y∧z)
φ(x,y) = (x∧¬y)∨(¬x∧y)
φ(x) = x
(43)
can be rewritten as a bounded number of CNF clauses.
However, as Carette et al. [12] note, diagrams of the ZW-calculus can also naturally represent in-
stances of #PERFECT-MATCHINGS by taking each vertex of the graph to be a W-spider and edges
of the graph as wires. Therefore, any ZW-diagram containing only W-spiders represents an instance of
#PERFECT-MATCHINGS.
Theorem 8. #PERFECT-MATCHINGS is #P-complete.
Proof. Suppose we are given an instance f of #XSAT on n variables as a ZW-diagram, then to trans-
form it to an instance of #PERFECT-MATCHINGS we need to remove all Z-spiders, which represent
variables. First split all the variables so they have degree at most three:
=
...
...
...
(44)
Then we can use the following rewrites to remove all variables with degree two and three:
=
=
1
2
(45)

22
ZH-Calculus and Counting Complexity
We are left with only variables of degree one, some extraneous Z-spiders with degree two, and a constant
factor of 2−c. To complete the reduction to #PERFECT-MATCHINGS it then remains to show we can
get rid of these degree-one variables and the degree-two Z-spiders.
We can remove the Z-spiders by considering the whole diagram modulo 2n+c + 1: since we started
with a #XSAT instance with n variables, we have 0 ≤#( f) ≤2n, so the value of the remaining diagram is
at most 2n+c. It is hence sufﬁcient to calculate modulo 2n+c +1 for our resulting diagram. In this setting,
we have
=
1
0
0
−1

≡
1
0
0
2n+c

=
1
0
0
2
n+c
=
...
n+c copies
(mod 2n+c+1) (46)
since
=
1
0
0
2

(47)
and hence we are left with a diagram containing only variables of degree one, and no other Z-spiders. To
remove these variables of degree one, note that
=
(48)
and thus we can combine all the variables of degree one together:
...
=
...
...
(49)
Finally, we can remove the last variable by splitting the diagram as a sum of diagrams, neither of which
contain any Z-spiders:
=
+
(50)
Thus, these two diagrams each represent an instance of #PERFECT-MATCHINGS - let us denote the
graphs of the corresponding instances as G1 and G2. The construction above allows us to obtain G1 and
G2 in polynomial time, and we have
#( f) = 2−c(PerfMatch(G1)+PerfMatch(G2))
mod 2n+c +1
(51)
hence #PERFECT-MATCHINGS is #P-hard. We can also see that #PERFECT-MATCHINGS ∈
#P, since we can use Equation (45) to rewrite all wires into variables of degree two, and thus trans-
form an instance of #PERFECT-MATCHINGS into an instance of #XSAT. Therefore, #PERFECT-
MATCHINGS is #P-complete.
D
#P-Completeness for the Permanent
The proof by Valiant [60] that the permanent of an integer-valued matrix, Z-Permanent, is #P-complete,
and the simpliﬁed proof by Ben-Dor and Halevi [7], both rely on a reduction from #3SAT. This reduc-
tion could be simpliﬁed by using #2SAT instead, but this was unfortunately not possible, as the proof
that #2SAT is #P-complete relies itself on a reduction from the permanent. However, since we proved
in Theorem 2 that #2SAT is #P-complete independent of the permanent, we can make use of this to
simplify the reduction for Z-Permanent further. In this section, we detail this reduction, which shows
that Z-Permanent is #P-hard. Our construction and proof is essentially identical to that of Ben-Dor and
Halevi [7], with the exception that we start with an instance of #MON-2SAT, and can hence use simpler
gadgets.

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
23
Deﬁnition 7. Given a directed edge-weighted graph G with edges E, a cycle-cover of G is a set E′ ⊆E
of simple cycles that partition the vertices of G. Note that self-loops are permitted in G. The weight of a
cycle cover is the product of all the weights of the edges in E′.
Lemma 16. Let G be a directed graph with self-loops and edge weights wij, and let A be its adjacency
matrix, i.e. Aij = wij if i and j are connected or Aij = 0 otherwise. Then the permanent of A is the sum
of weights of all cycle-covers of G. We denote this number by #(G).
Given this, it is sufﬁcient to reduce #MON-2SAT to the problem of determining the sum of weights
of cycle-covers of a graph. We aim to construct a graph Gφ from a #MON-2SAT instance φ with n
variables and m clauses, in polynomial time, such that #(Gφ) = f(φ)·#(φ) for some easily computable
and suitably bounded f(φ). We construct Gφ as follows:
1. For each variable xi in φ, introduce a vertex vi to Gφ.
2. For each clause in φ, introduce a clause gadget of four vertices to Gφ, the structure of which we
will describe momentarily. Two of the vertices of this gadget are designated as the ﬁrst and second
input respectively.
3. For every variable vertex, add a self-loop si of weight one to Gφ.
4. For every variable vertex vi, add an edge of weight one from vi to an unused input c1 of the ﬁrst
clause in which v appears. Then add an edge of weight one from c1 to c2, an unused input of the
second clause in which v appears. Continue similarly until all di clauses in which v appears have
been processed, then add an edge of weight one from cdi to vi. Let these edges be labelled as cij.
An example of this construction is given below, the loop of edges proceeding from each variable high-
lighted in a different colour:
x
y
z
(x∨y)
(x∨z)
(y∨z)
∧
∧
C
C
C
(52)
The clause gadget is given by the following graph
2
2
−1
C
=
where the top-most vertex is the ﬁrst input, and the bottom-most vertex is the second. Bidirectional edges
represent a pair of edges, one in each direction, with the same weights. Now let Ec be the set of edges in
Gφ that are internal to clause gadgets, and let Er = E \Ec be the rest.
Deﬁnition 8. Let a partial cover of Gφ be a subset E′
r ⊆Er. A completion of E′
r is a cycle cover of Gφ
given by E′
r ∪E′
c where E′
c ⊆Ec. We call the weight of E′
r the sum of the weights of all completions of
E′
r.

24
ZH-Calculus and Counting Complexity
Let us say that a partial cover E′
r is induced by a satisfying assignment ⃗x of φ if, for every variable
xi assigned false in ⃗x, si ∈E′
r and cij /∈E′
r for all 1 ≤j ≤di, and for every variable xi assigned true in
⃗x, cij ∈E′
r for all 1 ≤j ≤di and si /∈E′
r. We wish to argue that the weight of a partial cover of Gφ is
non-zero if and only if it is induced by a satisfying assignment.
Lemma 17. Let E′
r be a partial cover of Gφ, then the weight of E′
r is 4m if E′
r is induced by a satisfying
assignment, and zero otherwise. Moreover, each such E′
r is induced by a unique satisfying assignment.
Proof. Suppose E′
r is induced by a satisfying assignment. Then for each clause gadget, the ingoing and
outgoing edges are included in E′
r for either one or both inputs (otherwise there is an unsatisﬁed clause).
The possible completions of E′
r are as follows for each clause gadget:
2
2
−1
2
2
−1
→
2
2
−1
+
=
4
2
2
−1
2
2
−1
→
=
4
(53)
The dotted edges represent edges not included in the cycle-cover. Then the total weight of each clause
gadget over the completions is four in either case, so the overall weight of E′
r is 4m. Now suppose that
E′
r is not induced by a satisfying assignment. Note that if the number of incoming and outgoing edges
of each clause gadge in E′
r is not equal, then the weight of E′
r is zero, as there is no valid completion
of E′
r (because there can be no such cycle-cover). Therefore, the only remaining case is that there is at
least one clause gadget which has no incoming and outgoing edges, or has one incoming edge and one
outgoing edge on the opposing input (otherwise E′
r would be induced by a satisfying assignment). In
either case, we can see the total weight of the gadget over the completions is zero:
2
2
−1
2
2
−1
→
2
2
−1
+
=
0
2
2
−1
2
2
−1
→
2
2
−1
+
=
0
2
2
−1
2
2
−1
+
+
(54)
Hence, the weight of E′
r must also be zero. Note that each E′
r that is induced by a satisfying assignment
must be induced by a unique assignment, since you can recover the assignment from E′
r.
Clearly, the sum of weights of all partial covers of Gφ is the same as the sum of weights of all
cycle-covers of Gφ. But by Lemma 17, this is 4m#(φ), so #(φ) = 4−m#(Gφ), and thus Z-Permanent is
#P-hard, as Gφ can be computed in polynomial time from φ.
It is interesting to note that the constructions of Ben-Dor and Halevi, and Valiant, both make use of
negative-weight edges and have f(φ) = km for some even integer k (12 for Ben-Dor and Halevi, and 45
for Valiant). In order to further simplify the next steps of the reduction to B-Permanent, it would be
desirable to have no negative weights, or k = 1. However, as Valiant points out [60], neither of these is
likely to be possible:

T. Laakkonen, K. Meichanetzidis & J. van de Wetering
25
• If k is odd, then #(φ) ≡#(Gφ) mod 2, but #(Gφ) mod 2 is easy to compute [7] (as the parity of
the permanent is equal to the parity of the determinant), so then P = LP and NP = RP by the
Valiant-Vazirani theorem [61].
• Suppose Gφ is constructed by reduction from 3SAT. If there are no negative-weighted edges, then
the existence of any cycle-cover of Gφ indicates the existence of a satisfying assignment to φ. But
determining if a cycle-cover exists is easy for general directed graphs, so then P = NP.
This last argument does not hold up for our construction, since we start from #MON-2SAT, for which it
is trivial to determine if a satisfying assignment exists (indeed, one always exists by setting every variable
true). However, we can still rule out the possibility of a reduction without negative-weighted edges: it is
known that Z-Permanent with non-negative weights has an FPRAS [40], whereas #MON-2SAT does
not, unless NP = RP [66, Theorem 57].

