CODE LISTINGS AND FIGURES

CHAPTER 1
THE INTERACTIVE RUBY CONSOLE PROGRAM (IRB), YOUR NEW
BEST FRIEND
The irb utility ships with Ruby and is the most widely used Ruby
command-line tool other than the interpreter itself. After starting irb,
you type Ruby code into it, and it executes the code and prints out the
resulting value.
Type irb  at the command line and enter sample code as you
encounter it in the text.
For example:
Having an open irb session means you can test Ruby snippets at any
time and in any quantity. Most Ruby developers nd irb indispensable,
and you’ll see a few examples of its use as we proceed through this
chapter.
The irb examples you’ll see in this book will use a command-line
option that makes irb output easier to read:
If you want to see the e|ect of the --simple-prompt  option, try
starting irb with and without it. As you’ll see, the simple prompt keeps
your screen a lot clearer. The default (nonsimple) prompt displays
more information, such as a line-number count for your interactive
1
2
>> 100 + 32 
=> 132
1 irb --simple-prompt

session; but for the examples we’ll look at, the simple prompt is
su}cient.
Because irb is one of the command-line tools that ship with Ruby, it’s
not discussed in detail until section 1.4.2. Feel free to jump to that
section and have a look; it’s pretty straightforward.
Table 1.1. Basic operations in Ruby
Operation
Example(s)
Comments
Arithmetic
2 + 3 (addition) 2 –
3 (subtraction) 2 *
3 (multiplication) 2
/ 3 (division) 10.3 +
20.25 103 - 202.5
32.9 * 10 100.0 /
0.23
All these operations work on integers or
oating-point numbers (floats). Mixing
integers and oats together, as some of
the examples do, produces a oating-
point result. Note that you need to write
0.23 rather than .23.
Assignment
x = 1 string =
"Hello"
This operation binds a local variable (on
the left) to an object (on the right). For
now, you can think of an object as a value
represented by the variable.
Compare two
values
x == y
Note the two equal signs (not just one, as
in assignment).
Convert a numeric
string to a number
x = "100".to_i 
s = "100" 
x = s.to_i
To perform arithmetic, you have to make
sure you have numbers rather than
strings of characters. to_i performs
string-to-integer conversion.
Table 1.2. Basic input/output methods and Øow control in Ruby
Operation
Example(s)
Comments
Print something to
the screen
print "Hello" 
puts "Hello" 
x = "Hello" 
puts x 
x = "Hello" 
print x 
x = "Hello" 
p x
puts adds a newline to the string it
outputs if there isn’t one at the end
already; print doesn’t. print prints
exactly what it’s told to and leaves the
cursor at the end. (Note: On some
platforms, an extra line is automatically
output at the end of a program.) p
outputs an inspect string, which may
contain extra information about what it’s
printing.

Operation
Example(s)
Comments
Get a line of
keyboard input
gets 
string = gets
You can assign the input line directly to a
variable (the variable string in the second
example).
Conditional
execution
if x == y 
puts "Yes!" 
else 
puts "No!" 
end
Conditional statements always end with
the word end. More on these in chapter 6.
Table 1.3. Ruby’s special objects and comment
Operation
Example(s)
Comments
Special value
objects
true 
false 
nil
The objects true and false often serve as
return values for conditional expressions.
The object nil is a kind of “nonobject”
indicating the absence of a value or
result. false and nil cause a conditional
expression to fail; all other objects
(including true, of course, but also
including 0 and empty strings) cause it to
succeed. More on these in chapter 7.
Default object
self
The keyword self refers to the default
object. Self is a role that di|erent objects
play, depending on the execution
context. Method calls that don’t specify a
calling object are called on self. More on
this in chapter 5.
Put comments in
code les
# A comment 
x = 1 # A comment
Comments are ignored by the
interpreter.
Table 1.4. Valid variable names in Ruby by variable type
Type
Ruby convention
Nonconventional
Local
rst_name
rstName, _rstName, __rstName, name1
Instance
@rst_name
@First_name, @rstName, @name1
Class
@@rst_name
@@First_name, @@rstName, @@name1
Global
$FIRST_NAME
$rst_name, $rstName, $name1

1 x = "100".to_i
1 x = "100".to_i(9)
1 puts "Hello."
Listing 1.1. Simple, limited-purpose Celsius-to-Fahrenheit converter (c2f.rb)
1
2
3
4
5
celsius = 100 
fahrenheit = (celsius * 9 / 5) + 32 
puts "The result is: " 
puts fahrenheit 
puts "."
1
2
$ ruby broken_c2f.rb 
broken_c2f.rb:5: syntax error, unexpected end-of-input, expecting ')'
1 $ ruby -cw c2f.rb
1 Syntax OK
1 $ ruby c2f.rb

1
2
3
The result is 
212 
.
1
2
3
print "The result is " 
print fahrenheit 
puts "."
1 The result is 212.
1 print fahrenheit, "\n"
Listing 1.2. Interactive temperature converter (c2×.rb)
1
2
3
4
5
6
7
print "Hello. Please enter a Celsius value: " 
celsius = gets 
fahrenheit = (celsius.to_i * 9 / 5) + 32 
 
print "The Fahrenheit equivalent is " 
print fahrenheit 
puts "."
1
2
3
4
5
6
$ ruby c2fi.rb 
Hello. Please enter a Celsius value: 100 
The Fahrenheit equivalent is 212. 
$ ruby c2fi.rb 
Hello. Please enter a Celsius value: 23 
The Fahrenheit equivalent is 73.

SHORTENING THE CODE
You can shorten the code in listing 1.2 considerably by consolidating
the operations of input, calculation, and output. A compressed rewrite
looks like this:
This version economizes on variables—there aren’t any—but requires
anyone reading it to follow a somewhat denser (but shorter!) set of
expressions. Any given program usually has several or many spots
where you have to decide between longer (but maybe clearer?) and
shorter (but perhaps a bit cryptic). And sometimes, shorter can be
clearer. It’s all part of developing a Ruby coding style.
1
2
print "Hello. Please enter a Celsius value: " 
print "The Fahrenheit equivalent is ", gets.to_i * 9 / 5 + 32, ".\
1 100
Listing 1.3. Temperature converter using ×le input (c2×n.rb)
1
2
3
4
5
6
7
puts "Reading Celsius temperature value from data file..." 
num = File.read("temp.dat") 
celsius = num.to_i 
fahrenheit = (celsius * 9 / 5) + 32 
puts "The number is " + num 
print "Result: " 
puts fahrenheit
1
2
3
4
$ ruby c2fin.rb 
Reading Celsius temperature value from data file... 
The number is 100 
Result: 212

Table 1.5. Key Ruby directories and their RbConfig  terms
Term
Directory contents
rubylibdir
Ruby standard library
bindir
Ruby command-line tools
archdir
Architecture-specic extensions and libraries (compiled,
binary les)
sitedir
Your own or third-party extensions and libraries (written in
Ruby)
vendordir
Third-party extensions and libraries (written in Ruby)
sitelibdir
Your own Ruby language extensions (written in Ruby)
sitearchdir
Your own Ruby language extensions (written in C)
Listing 1.4. Temperature converter with ×le output (c2fout.rb)
1
2
3
4
5
6
7
print "Hello. Please enter a Celsius value: " 
celsius = gets.to_i 
fahrenheit = (celsius * 9 / 5) + 32 
puts "Saving result to output file 'temp.out'" 
fh = File.new("temp.out", "w") 
fh.puts fahrenheit 
fh.close
1 $ irb --simple-prompt -rrbconfig
1 >> RbConfig::CONFIG["bindir"]
1
2
3
puts "This is the first (master) program file." 
load "loadee.rb" 
puts "And back again to the first file."

1 puts "> This is the second file."
1
2
3
This is the first (master) program file. 
> This is the second file. 
And back again to the first file.
1 load "loadee.rb"
1
2
3
4
5
6
7
8
9
$ ruby -e 'puts $:' 
/Users/dblack/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0 
/Users/dblack/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0/x86_64-darwin12.0 
/Users/dblack/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby 
/Users/dblack/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0 
/Users/dblack/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0/x86_64-darwin12.0 
/Users/dblack/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby 
/Users/dblack/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0 
/Users/dblack/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0/x86_64-darwin12.0
1
1 load "../extras.rb"
1 load "/home/users/dblack/book/code/loadee.rb"
1 load "loadee.rb"

SPECIFYING THE WORKING DIRECTORY
require  doesn’t know about the current working directory ( . ). You
can specify it explicitly
or you can append it to the load path using the array append operator,
so you don’t need to specify it in calls to require :
1 require "./loadee.rb"
1 require "./loadee.rb"
1 $: << "."
1 require "loadee.rb"
1 require "/home/users/dblack/book/code/loadee.rb"
1
2
3
4
5
6
>> "David Black".scanf("%s%s") 
NoMethodError: undefined method `scanf' for "David Black":String 
>> require "scanf" 
=> true 
>> "David Black".scanf("%s%s") 
=> ["David", "Black"]
1
2
3

Table 1.6. Summary of commonly used Ruby command-line switches
Switch
Description
Example of usage
-c
Check the syntax of a program le
without executing the program
ruby -c c2f.rb
-w
Give warning messages during
program execution
ruby -w c2f.rb
-e
Execute the code provided in
quotation marks on the command
line
ruby -e 'puts "Code demo!"'
-l
Line mode: print a newline after
every line of output
ruby -le 'print "+ newline!"'
-rname
Require the named feature
ruby –rprole
-v
Show Ruby version information
and execute the program in
verbose mode
ruby –v
--version
Show Ruby version information
ruby –-version
-h
Show information about all
command-line switches for the
interpreter
ruby –h
1 require_relative "loadee"
1 require_relative "lib/music/sonata"
1
2
$ ruby -e 'puts "David A. Black".reverse' 
kcalB .A divaD
1
2
3
4
5
$ ruby -e 'print "Enter a name: " 
puts gets.reverse' 
Enter a name: David A. Black 
 
kcalB .A divaD

SPECIFYING SWITCHES
You can feed Ruby the switches separately, like this
1 $ ruby -e 'print "Enter a name: "; print gets.reverse'
1
2
3
4
5
6
$ ruby c2f-2.rb 
The result is 212. 
$ ruby -l c2f-2.rb 
The result is 
212 
.
1
2
$ ruby -v 
ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-darwin12.0]
1 $ ruby -cw filename
1
2
3
4
5
6
$ ruby-1.8.6-p399 -ve "puts 'abc'.start_with?('a')" 
ruby 1.8.6 (2010-02-05 patchlevel 399) [x86_64-linux] 
-e:1: undefined method `start_with?' for "abc":String (NoMethodError) 
$ ruby-2.1.0p0 -ve "puts 'abc'.start_with?('a')"                 
ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-linux] 
true
1
2
1 $ ruby -c -w

or
But it’s common to type them together, as in the examples in the main
text.
1 $ ruby -v -e "puts 'abc'.start_with?('a')"
1
2
$ irb 
2.1.0 :001 >
1
2
$ irb --simple-prompt 
>>
1
2
>> 100 * 9 / 5 + 32 
=> 212
1
2
>> 365 * 24 * 60 
=> 525600
1
2
3
4
5
6
7
8
>> days = 365 
=> 365 
>> hours = 24 
=> 24 
>> minutes = 60 
=> 60 
>> days * hours * minutes 
=> 525600

1
2
3
4
$ irb --simple-prompt 
>> puts "Hello" 
Hello 
=> nil
1
2
3
4
$ irb --simple-prompt --noecho 
>> 2 + 2 
>> puts "Hi" 
Hi
1 $ ri String#upcase
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
= String#upcase 
 
(from ruby core) 
------------------------------------------------------------------------------ 
  str.upcase   -> new_str 
 
 
------------------------------------------------------------------------------ 
 
Returns a copy of str with all lowercase letters replaced with their 
uppercase counterparts. The operation is locale insensitive---only characters 
``a'' to ``z'' are affected. Note: case replacement is effective only in 
ASCII region. 
 
  "hEllO".upcase   #=> "HELLO"
1 $ rake admin:clean_tmp
Listing 1.5. Rake×le de×ning clean_tmp  tasks inside the admin  namespace
1
2
namespace :admin do 
  desc "Interactively delete all files in /tmp" 

3
4
5
6
7
8
9
10
11
12
13
14
15
16
  task :clean_tmp do 
    Dir["/tmp/*"].each do |f| 
      next unless File.file?(f) 
      print "Delete #{f}? " 
      answer = $stdin.gets 
      case answer 
      when /^y/ 
        File.unlink(f) 
      when /^q/ 
        break 
      end 
    end 
  end                                   
end
1
2
3
4
5
6
1 $ rake --tasks
1
2
3
$ rake --tasks 
(in /Users/ruby/hacking) 
rake admin:clean_tmp  # Interactively delete all files in /tmp
1
2
3
task :clean_tmp do 
  # etc. 
end
1 $ rake clean_tmp
1
2
3
4
5
6
7
namespace :admin do 
  namespace :clean do 
    task :tmp do 
      # etc. 
    end 
  end 
end

1 $ rake admin:clean:tmp
1 $ gem install prawn
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Fetching: Ascii85-1.0.2.gem (100%) 
Fetching: ruby-rc4-0.1.5.gem (100%) 
Fetching: hashery-2.1.0.gem (100%) 
Fetching: ttfunk-1.0.3.gem (100%) 
Fetching: afm-0.2.0.gem (100%) 
Fetching: pdf-reader-1.3.3.gem (100%) 
Fetching: prawn-0.12.0.gem (100%) 
Successfully installed Ascii85-1.0.2 
Successfully installed ruby-rc4-0.1.5 
Successfully installed hashery-2.1.0 
Successfully installed ttfunk-1.0.3 
Successfully installed afm-0.2.0 
Successfully installed pdf-reader-1.3.3 
Successfully installed prawn-0.12.0 
7 gems installed
1 $ gem install /home/me/mygems/ruport-1.4.0.gem
1
2
>> require "hoe" 
=> true
1
2
>> puts $:.grep(/hoe/) 
/Users/dblack/.rvm/gems/ruby-2.1.0/gems/hoe-3.8.1/lib
1
2
3
>> gem "hoe", "3.8.0" 
=> true 
1

4 >> puts $:.grep(/hoe/) 
/Users/dblack/.rvm/gems/ruby-2.1.0/gems/hoe-3.8.0/lib

CHAPTER 2
Figure 2.1. Anatomy of a method de×nition
1 obj = Object.new
1
2
3
4
def obj.talk 
  puts "I am an object." 
  puts "(Do you object?)" 
end
1 obj.talk
1
2
I am an object. 
(Do you object?)

Table 2.1. Examples of Ruby expressions and the values to which they evaluate
Expression
Value
Comments
2 + 2
4
Arithmetic expressions evaluate to their
results.
"Hello"
"Hello"
A simple, literal string (in quotation
marks) evaluates to itself.
"Hello" + " there"
"Hello there"
Strings can be “added” to each other
(concatenated) with the plus sign.
c = 100
100
When you assign to a variable, the whole
assignment evaluates to the value you’ve
assigned.
c * 9/5 + 32
212
The usual rules of precedence apply:
multiplication and division bind more
tightly than addition and are performed
rst.
1
2
3
def obj.c2f(c) 
  c * 9.0 / 5 + 32 
end
1 puts obj.c2f(100)
1 212.0
1 def obj.c2f c
1 obj.c2f 100

Expression
Value
Comments
obj.c2f(100)
212
A method call is an expression.
1 c * 9.0 / 5 + 32
1
2
3
def obj.c2f(c) 
  return c * 9.0 / 5 + 32 
end
1
2
3
4
5
6
01/02/03 
Town Hall 
Author's reading 
Mark Twain 
Second Balcony, row J, seat 12 
$5.50
1 ticket = Object.new
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
def ticket.date 
  "01/02/03" 
end 
def ticket.venue 
  "Town Hall" 
end 
def ticket.event 
  "Author's reading" 
end 
def ticket.performer 
  "Mark Twain" 
end 
def ticket.seat 
  "Second Balcony, row J, seat 12" 
end 
def ticket.price 
  5.50 
end
1

1
2
3
4
5
6
7
8
9
10
print "This ticket is for: " 
print ticket.event + ", at " 
print ticket.venue + ", on " 
puts ticket.date + "." 
print "The performer is " 
puts ticket.performer + "." 
print "The seat is " 
print ticket.seat + ", " 
print "and it costs $" 
puts "%.2f." % ticket.price
1
2
3
4
1
2
3
This ticket is for: Author's reading, at Town Hall, on 01/02/03. 
The performer is Mark Twain. 
The seat is Second Balcony, row J, seat 12, and it costs $5.50.
1
2
3
4
puts "This ticket is for: #{ticket.event}, at #{ticket.venue}." + 
  "The performer is #{ticket.performer}." + 
  "The seat is #{ticket.seat}, " + 
  "and it costs $#{"%.2f." % ticket.price}"
1
2
3
def ticket.availability_status 
  "sold" 
end
1
2
3
def ticket.available? 
  false 
end
1
2
3
4
if ticket.available? 
  puts "You're in luck!" 
else 

5   puts "Sorry--that seat has been sold." 
end
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
>> if "abc" 
>>   puts "Strings are 'true' in Ruby!" 
>> end 
Strings are 'true' in Ruby! 
=> nil 
>> if 123 
>>   puts "So are numbers!" 
>> end 
So are numbers! 
=> nil 
>> if 0 
>>   puts "Even 0 is true, which it isn't in some languages."    
>> end                                                           
Even 0 is true, which it isn't in some languages. 
=> nil 
>> if 1 == 2 
>>   puts "One doesn't equal two, so this won't appear." 
>> end 
=> nil
1
1
1
2
2
2
3
1
2
3
4
5
>> if puts "You'll see this" 
>>   puts "but not this" 
>> end 
You'll see this 
=> nil
1 p Object.new.methods.sort
1
2
3
4
5
6
7
8
9
[:!, :!=, :!~, :<=>, :==, :===, :=~, :__id__, :__send__, :class, :clone, 
:define_singleton_method, :display, :dup, :enum_for, :eql?, :equal?, :extend, 
:freeze, :frozen?, :hash, :inspect, :instance_eval, :instance_exec, 
:instance_of?, :instance_variable_defined?, :instance_variable_get, 
:instance_variable_set, :instance_variables, :is_a?, :kind_of?, :method, 
:methods, :nil?, :object_id, :private_methods, :protected_methods, 
:public_method, :public_methods, :public_send, :remove_instance_variable, 
:respond_to?, :send, :singleton_class, :singleton_methods, :taint, :tainted?, 
:tap, :to_enum, :to_s, :trust, :untaint, :untrust, :untrusted?]

1
2
3
4
5
obj = Object.new 
puts "The id of obj is #{obj.object_id}." 
str = "Strings are objects too, and this is a string!" 
puts "The id of the string object str is #{str.object_id}." 
puts "And the id of the integer 100 is #{100.object_id}."
1
2
3
a = Object.new 
b = a 
puts "a's id is #{a.object_id} and b's id is #{b.object_id}."
1
2
3
4
string_1 = "Hello" 
string_2 = "Hello" 
puts "string_1's id is #{string_1.object_id}." 
puts "string_2's id is #{string_2.object_id}."
1
2
1
2
obj = Object.new 
obj.talk
1 NoMethodError: undefined method `talk' for #<Object:0x00000102836550>
1
2
3
4
5
6
obj = Object.new 
if obj.respond_to?("talk") 
  obj.talk 
else 
  puts "Sorry, the object doesn't understand the 'talk' message." 
end

1
2
print "Information desired: " 
request = gets.chomp
1
2
3
4
5
if request == "venue" 
  puts ticket.venue 
elsif request == "performer" 
  puts ticket.performer 
...
1
2
3
4
5
if ticket.respond_to?(request) 
  puts ticket.send(request) 
else 
  puts "No such information available" 
end
1
1
2
3
4
5
6
7
obj = Object.new 
 
def obj.one_arg(x) 
  puts "I require one and only one argument!" 
end 
 
obj.one_arg(1,2,3)
1 ArgumentError: wrong number of arguments (3 for 1)
1
2
3
def obj.multi_args(*x) 
  puts "I can take zero or more arguments!" 
end

1
2
3
4
5
def two_or_more(a,b,*c) 
  puts "I require two or more arguments!" 
  puts "And sure enough, I got: " 
  p a, b, c 
end
1
2
3
4
5
I require two or more arguments! 
And sure enough, I got: 
1 
2 
[3, 4, 5]
1
2
3
def default_args(a,b,c=1) 
  puts "Values of variables: ",a,b,c 
end
1 default_args(3,2)
1
2
3
4
Values of variables: 
3 
2 
1
1 default_args(4,5,6)
1
2
3
4
Values of variables: 
4 
5 
6

1
2
3
4
5
6
def mixed_args(a,b,*c,d) 
  puts "Arguments:" 
  p a,b,c,d 
end 
 
mixed_args(1,2,3,4,5)
1
2
3
4
5
Arguments: 
1 
2 
[3, 4] 
5
1 mixed_args(1,2,3)
1
2
3
4
1 
2 
[] 
3
1
2
3
4
def args_unleashed(a,b=1,*c,d,e) 
  puts "Arguments:" 
  p a,b,c,d,e 
end
1
2
3
4
5
6
7
8
9
>> args_unleashed(1,2,3,4,5) 
1 
2 
[3]    
4 
5 
=> [1, 2, [3], 4, 5] 
>> args_unleashed(1,2,3,4) 
1 
1
2

Figure 2.2. Argument assignment logic in action
Table 2.2. Sample method signatures with required, optional, and default-valued
arguments
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
2 
[] 
3 
4 
=> [1, 2, [], 3, 4] 
>> args_unleashed(1,2,3) 
1 
1 
[] 
2 
3 
=> [1, 1, [], 2, 3] 
>> args_unleashed(1,2,3,4,5,6,7,8) 
1 
2 
[3, 4, 5, 6] 
7 
8 
=> [1, 2, [3, 4, 5, 6], 7, 8] 
>> args_unleashed(1,2) 
ArgumentError: wrong number of arguments (2 for 3+)
3
4
5
1 def all_optional(*args)
1
1
2
def broken_args(x,*y,z=1) 
end

Argument type(s)
Method signature
Sample call(s)
Variable assignments
Argument type(s)
Method signature
Sample call(s)
Variable assignments
Required (R)
def m(a,b,c)
m(1,2,3)
a = 1, b = 2, c = 3
Optional (O)
def m(*a)
m(1,2,3)
a = [1,2,3]
Default-valued (D)
def m(a=1)
m 
m(2)
a = 1 
a = 2
R/O
def m(a,*b)
m(1)
a = 1, b = [ ]
R/D
def m(a,b=1)
m(2) 
m(2,3)
a = 2, b = 1 
a = 2, b = 3
D/O
def m(a=1,*b)
m 
m(2)
a = 1, b = [] 
a = 2, b = [ ]
R/D/O
def m(a,b=2,*c)
m(1) 
m(1,3) 
m(1,3,5,7)
a = 1, b = 2, c = [] 
a = 1, b = 3, c = [ ] 
a = 1, b = 3, c = [5,7]
R/D/O/R
def m(a,b=2,*c,d
m(1,3) 
m(1,3,5) 
m(1,3,5,7) 
m(1,3,5,7,9)
a = 1, b = 2, c = [ ], d
= 3 
a = 1, b = 3, c = [ ], d
= 5 
a = 1, b = 3, c = [5],
d = 7 
a = 1, b = 3, c =
[5,7], d = 9
1
2
3
4
5
6
7
x 
_x 
name 
first_name 
plan9 
user_ID 
_
1
2
3
4
5
6
7
8
9
10
11
12
def say_goodbye  
  x = "Goodbye" 
  puts x 
end 
def start_here 
  x = "Hello" 
  puts x 
  say_goodbye 
  puts "Let's check whether x remained the same:" 
  puts x 
end 
start_here
1
2
3
4
5

1
2
3
4
Hello 
Goodbye 
Let's check whether x remained the same: 
Hello
1 str = "Hello"
1
2
3
str = "Hello" 
abc = str 
puts abc
1
2
3
4
5
6
7
8
9
10
11
12
13
14
str = "Hello" 
abc = str 
str.replace("Goodbye") 
puts str 
puts abc 
def say_goodbye 
  str = "Hello" 
  abc = str 
  str.replace("Goodbye") 
  puts str 
  puts abc 
end 
 
say_goodbye
1
2
Goodbye 
Goodbye
1 str.replace("Goodbye")

THE UN-REFERENCE: IMMEDIATE VALUES
Some objects in Ruby are stored in variables as immediate values.
These include integers, symbols (which look like :this ), and the
special objects true , false , and nil . When you assign one of
these values to a variable ( x = 1 ), the variable holds the value itself,
rather than a reference to it.
In practical terms, this doesn’t matter (and it will often be left as
implied, rather than spelled out repeatedly, in discussions of
references and related topics in this book). Ruby handles the
dereferencing of object references automatically; you don’t have to do
any extra work to send a message to an object that contains, say, a
reference to a string, as opposed to an object that contains an
immediate integer value.
But the immediate-value representation rule has a couple of
interesting ramications, especially when it comes to integers. For one
thing, any object that’s represented as an immediate value is always
exactly the same object, no matter how many variables it’s assigned
to. There’s only one object 100 , only one object false , and so on.
The immediate, unique nature of integer-bound variables is behind
Ruby’s lack of pre- and post-increment operators—which is to say,
you can’t do this in Ruby:
The reason is that due to the immediate presence of 1  in x , x++
would be like 1++ , which means you’d be changing the number 1 to
the number 2—and that makes no sense.
1
2
x = 1 
x++    # No such operator
1
2
3
4
5
str = "Hello" 
abc = str 
str = "Goodbye" 
puts str 
puts abc

1
2
Goodbye 
Hello
1
2
3
def change_string(str) 
  str.replace("New string content!") 
end
1
2
s = "Original string content!" 
change_string(s)
1 puts s
1 New string content!
1
2
3
s = "Original string content!" 
change_string(s.dup) 
puts s
1
1
2
3
s = "Original string content!" 
s.freeze 
change_string(s)
1

1
2
3
4
5
6
7
8
9
10
>> numbers = ["one", "two", "three"] 
=> ["one", "two", "three"] 
>> numbers.freeze 
=> ["one", "two", "three"] 
>> numbers[2] = "four" 
RuntimeError: can't modify frozen array 
>> numbers[2].replace("four") 
=> "four" 
>> numbers 
=> ["one", "two", "four"]
1
2
3
1
2
3
$ ruby -e "x" 
-e:1:in `<main>': undefined local variable or method 'x' for main:Object 
     (NameError)

CHAPTER 3
1 obj = Object.new
1
2
3
4
5
class Ticket 
  def event 
    "Can't really be specified yet..." 
  end 
end
1
1
2
ticket = Ticket.new 
puts ticket.event
1 Can't really be specified yet...
1 def ticket.event
1 def event
1
2
3
4
5
class C 
  def m 
    puts "First definition of method m" 
  end 
 

6
7
8
9
  def m 
    puts "Second definition of method m" 
  end 
end
1 C.new.m
1
2
3
class C 
  # class code here 
end
1
2
3
4
5
6
7
8
9
class C 
  def x 
  end 
end 
 
class C 
  def y 
  end 
end
1
2
3
4
5
6
7
class C 
  def x 
  end 
 
  def y 
  end 
end
1 puts Time.new.strftime("%m-%d-%y")
1 class Time

1
2
3
4
5
6
7
8
9
10
11
>> t = Time.new 
=> 2014-02-09 09:41:29 -0500 
>> t.xmlschema 
NoMethodError: undefined method 'xmlschema' for 2014-02-09 09:41:29 – 
     0500:Time 
     from (irb):2 
     from /Users/dblack/.rvm/rubies/ruby-2.1.0/bin/irb:11:in `<main>' 
>> require 'time' 
=> true 
>> t.xmlschema 
=> "2014-02-09T09:41:29-05:00"
1
2
1
2
3
4
ticket = Object.new 
def ticket.price 
  117.50 
end
Listing 3.1. An instance variable maintaining its value between method calls
1
2
3
4
5
6
7
8
9
10
11
12
13
class Person 
  def set_name(string) 
    puts "Setting person's name..." 
    @name = string 
  end 
  def get_name 
    puts "Returning the person's name..." 
    @name 
  end 
end 
joe = Person.new 
joe.set_name("Joe") 
puts joe.get_name
1
2
3
1
2
3
4
5
class Ticket 
  def initialize 
    puts "Creating a new ticket!" 
  end 
end

1
2
3
4
5
class Ticket 
  def initialize(venue,date) 
    @venue = venue 
    @date = date 
  end
1
2
3
4
5
6
7
8
def venue 
    @venue 
  end 
 
  def date 
    @date 
  end 
end
1
2
3
4
5
th = Ticket.new("Town Hall", "11/12/13") 
cc = Ticket.new("Convention Center", "12/13/14") 
puts "We've created two tickets." 
puts "The first is for a #{th.venue} event on #{th.date}." 
puts "The second is for an event on #{cc.date} at #{cc.venue}."
1
2
3
We've created two tickets. 
The first is for a Town Hall event on 11/12/13. 
The second is for an event on 12/13/14 at Convention Center.
1
2
3
def discount(percent) 
  @price = @price * (100 - percent) / 100.0 
end
1
2
class Ticket 
  def initialize(venue,date,price) 

3
4
5
6
7
8
9
10
11
12
13
14
15
    @venue = venue 
    @date = date 
    @price = price 
  end 
  # etc. 
 
  def price 
    @price 
  end 
  # etc. 
end 
 
th = Ticket.new("Town Hall", "11/12/13", 63.00)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class Ticket 
  def initialize(venue, date) 
    @venue = venue 
    @date = date 
  end 
 
  def set_price(amount) 
    @price = amount 
  end 
 
  def price 
    @price 
  end 
end
1
2
3
4
5
6
7
ticket = Ticket.new("Town Hall", "11/12/13") 
ticket.set_price(63.00) 
puts "The ticket costs $#{"%.2f" % ticket.price}." 
ticket.set_price(72.50) 
puts "Whoops -- it just went up. It now costs $#{"%.2f" % ticket.price}." 
 
1: Format price to two decimal places
1
1
2
The ticket costs $63.00. 
Whoops -- it just went up. It now costs $72.50.
1
2
3
def price=(amount) 
  @price = amount 
end

1 ticket.price=(63.00)
1 ticket.price=(63.00)
1 ticket.price = 63.00
1
2
3
4
5
6
7
8
class Silly 
  def price=(x) 
    puts "The current time is #{Time.now}" 
  end 
end 
 
s = Silly.new 
s.price = 111.22
1 The current time is 2014-02-09 09:53:31 -0500
1
2
3
4
5
6
7
8
9
10
11
12
13
class Ticket 
  def price=(amount) 
    if (amount * 100).to_i == amount * 100 
      @price = amount 
    else 
      puts "The price seems to be malformed" 
    end 
  end 
 
  def price 
    @price 
  end 
end

1
2
3
4
5
6
7
8
class TravelAgentSession 
  def year=(y) 
    @year = y.to_i 
    if @year < 100 
      @year = @year + 2000 
    end 
  end 
end
1
1
2
month, day, year = date.split('/') 
self.year = year
Listing 3.2. Ticket  class, with the attribute reader/writer methods spelled out
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
class Ticket 
  def initialize(venue, date) 
    @venue = venue 
    @date = date 
  end 
 
  def price=(price) 
    @price = price 
  end 
 
  def venue 
    @venue 
  end 
 
  def date 
    @date 
  end 
 
  def price 
    @price 
  end 
end
1
2
3
def something 
  @something 
end

Table 3.1. Summary of the attr_*  family of getter/setter creation methods
1
2
3
class Ticket 
  attr_reader :venue, :date, :price 
end
1
2
3
class Ticket 
  attr_writer :price 
end
Listing 3.3. Ticket  class, with getter and setter methods de×ned via attr_*  calls
1
2
3
4
5
6
7
8
class Ticket 
  attr_reader :venue, :date, :price 
  attr_writer :price 
  def initialize(venue, date) 
    @venue = venue 
    @date = date 
  end 
end
1
2
3
4
5
class Ticket 
  attr_reader :venue, :date 
  attr_accessor :price 
  # ... etc. 
end
1 attr :price, true

Method name
E|ect
Example
Equivalent code
Method name
E|ect
Example
Equivalent code
attr_reader
Creates a reader
method
attr_reader :venue
def venue 
@venue 
end
attr_writer
Creates a writer
method
attr_writer :price
def price=(price) 
@price = price 
end
attr_accessor
Creates reader and
writer methods
attr_accessor
:price
def price=(price) 
@price = price 
end 
 
def price 
@price 
end
attr
Creates a reader
and optionally a
writer method (if
the second
argument is true)
1. attr :venue
2. attr :price, true
1. See attr_reader
2. See
attr_accessor
1
2
3
4
5
6
7
class Publication 
  attr_accessor :publisher 
end 
 
class Magazine < Publication 
  attr_accessor :editor 
end
1
2
3
4
mag = Magazine.new 
mag.publisher = "David A. Black" 
mag.editor = "Joe Smith" 
puts "Mag is published by #{mag.publisher}, and edited by #{mag.editor}."
1
2
class Ezine < Magazine 
end

1
2
3
4
5
6
7
8
9
class Person 
  def species 
    "Homo sapiens" 
  end 
end 
class Rubyist < Person 
end 
david = Rubyist.new 
puts david.species
1
2
3
1 obj = Object.new
1
2
3
4
5
6
7
8
class C 
end 
 
class D < C 
end 
 
puts D.superclass 
puts D.superclass.superclass
1
2
C 
Object
1
2
obj = Object.new 
obj.some_method
1
2
>> BasicObject.new 
(Object doesn't support #inspect)

DEFINING INSTANCE METHODS IN CONNECTION WITH
CLASS.NEW
If you want to create an anonymous class using Class.new , and you
also want to add instance methods at the time you create it, you can
do so by appending a code block after the call to new . A code block is a
fragment of code that you supply as part of a method call, which can be
executed from the method. You’ll see much more about code blocks
when we look at iterators in chapter 6. Meanwhile, here’s a small
example of Class.new  with a block:
If you now create an instance of the class (with c.new ), you’ll be able
to call the method say_hello  on that instance.
1
2
3
class Ticket 
  # your code here 
end
1 my_class = Class.new
1 instance_of_my_class = my_class.new
1
2
3
4
5
c = Class.new do 
  def say_hello 
    puts "Hello!" 
  end 
end
1 Ticket.some_message

1
2
class Ticket 
  some_message
1
1 Ticket.new
1
2
3
class Ticket 
  attr_reader :venue, :date 
  attr_accessor :price
1
2
3
def Ticket.most_expensive(*tickets) 
  tickets.max_by(&:price) 
end
1
2
3
4
5
6
7
8
th = Ticket.new("Town Hall","11/12/13") 
cc = Ticket.new("Convention Center","12/13/14/") 
fg = Ticket.new("Fairgrounds", "13/14/15/") 
th.price = 12.55 
cc.price = 10.00 
fg.price = 18.00 
highest = Ticket.most_expensive(th,cc,fg) 
puts "The highest-priced ticket is the one for #{highest.venue}."
1 The highest-priced ticket is the one for Fairgrounds.
1
2
3
4
5
6
7
class Temperature 
  def Temperature.c2f(celsius) 
    celsius * 9.0 / 5 + 32 
  end 
 
  def Temperature.f2c(fahrenheit) 
    (fahrenheit - 32) * 5 / 9.0 

8
9
  end 
end
1 puts Temperature.c2f(100)
1
1
2
puts "Testing the response of a ticket instance...." 
wrong = fg.most_expensive
1
2
class Ticket 
  VENUES = ["Convention Center", "Fairgrounds", "Town Hall"]
1
2
3
4
5
6
7
8
def initialize(venue, date) 
  if VENUES.include?(venue) 
    @venue = venue 
  else 
    raise ArgumentError, "Unknown venue #{venue}" 
  end 
  @date = date 
end
1
2
1
2
3
4
5
6
7
class Ticket 
  VENUES = ["Convention Center", "Fairgrounds", "Town Hall"] 
end 
puts "We've closed the class definition." 
puts "So we have to use the path notation to reach the constant." 
puts "The venues are:" 
puts Ticket::VENUES
1
1 Math::PI

1
2
3
4
5
6
7
8
9
10
>> RUBY_VERSION 
=> "2.1.0" 
>> RUBY_PATCHLEVEL 
=> 0 
>> RUBY_RELEASE_DATE 
=> "2013-12-25" 
>> RUBY_REVISION 
=> 44422 
>> RUBY_COPYRIGHT 
=> "ruby - Copyright (C) 1993-2013 Yukihiro Matsumoto"
1
2
$ ruby -v 
ruby 2.1.0p0 (2013-12-25 revision 44422) [x86_64-darwin12.0]
1
2
A = 1 
A = 2
1
2
(irb):2: warning: already initialized constant A 
(irb):1: warning: previous definition of A was here
1
2
venues = Ticket::VENUES 
venues << "High School Gym"
1
1
2
3
4
5
6
>> mag = Magazine.new 
=> #<Magazine:0x36289c> 
>> mag.is_a?(Magazine) 
=> true 
>> mag.is_a?(Publication) 
=> true

1
2
3
4
5
mag = Magazine.new 
def mag.wings 
  puts "Look! I can fly!" 
end   
mag.wings
1

CHAPTER 4
1
2
3
4
5
6
module MyFirstModule 
  def say_hello 
    puts "Hello" 
  end 
 
end
1
2
3
4
5
6
class ModuleTester 
  include MyFirstModule 
end 
 
mt = ModuleTester.new 
mt.say_hello
Listing 4.1. Stacklike  module, encapsulating stacklike structure and behavior
1
2
3
4
5
6
7
8
9
10
11
module Stacklike 
  def stack 
    @stack ||= [] 
  end 
  def add_to_stack(obj) 
    stack.push(obj) 
  end 
  def take_from_stack 
    stack.pop 
  end 
end
1
2
3
1 s = Stacklike.new
1
Listing 4.2. Mixing the Stacklike  module into the Stack  class
1
2
require_relative "stacklike"        
class Stack 

3
4
  include Stacklike 
end
1
1
2
3
class Stack 
  include Stacklike 
end
Listing 4.3. Creating and using an instance of class Stack
1
2
3
4
5
6
7
8
9
10
11
s = Stack.new 
s.add_to_stack("item one") 
s.add_to_stack("item two") 
s.add_to_stack("item three") 
puts "Objects currently on the stack:" 
puts s.stack 
taken = s.take_from_stack 
puts "Removed this object:" 
puts taken 
puts "Now on stack:" 
puts s.stack
1
2
3
4
1
2
3
4
5
6
7
8
9
10
$ ruby stack.rb 
Objects currently on the stack: 
item one 
item two 
item three 
Removed this object: 
item three 
Now on stack: 
item one 
item two
Listing 4.4. Nonmodular rewrite of the Stack  class
1
2
3
4
5
6
7
8
9
10
class Stack 
  attr_reader :stack 
  def initialize 
    @stack = []       
  end 
  def add_to_stack(obj) 
    @stack.push(obj) 
  end 
  def take_from_stack 
    @stack.pop 
1

11
12
  end 
end
Listing 4.5. Using the Stacklike  module a second time, for a different class
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
require_relative "stacklike" 
class Suitcase 
end 
class CargoHold 
  include Stacklike 
  def load_and_report(obj) 
    print "Loading object " 
    puts obj.object_id 
    add_to_stack(obj) 
  end 
  def unload 
    take_from_stack 
  end 
end 
ch = CargoHold.new 
sc1 = Suitcase.new 
sc2 = Suitcase.new 
sc3 = Suitcase.new 
ch.load_and_report(sc1) 
ch.load_and_report(sc2) 
ch.load_and_report(sc3) 
first_unloaded = ch.unload 
print "The first suitcase off the plane is...." 
puts first_unloaded.object_id
1
2
3
4
5
1
2
3
4
Loading object 1001880 
Loading object 1001860 
Loading object 1001850 
The first suitcase off the plane is....1001850
Listing 4.6. Demonstration of module inclusion and inheritance
1
2
3
4
5
6
7
8
9
10
module M 
  def report 
    puts "'report' method in module M" 
  end 
end 
 
class C 
  include M 
end 
 

Figure 4.1. An instance of class D  looks for method x  in its method search path.
11
12
13
14
15
class D < C 
end 
 
obj = D.new 
obj.report
1
2
3
4
5
6
7
8
9
10
11
class BasicObject 
  # a scant seven method definitions go here 
end 
module Kernel 
  # over 100 method definitions go here! 
end 
class Object < BasicObject 
  # one or two private methods go here, 
  # but the main point is to mix in the Kernel module 
  include Kernel 
end

1
2
3
4
5
>> class C 
>> end 
=> nil 
>> C.superclass 
=> Object
Listing 4.7. Two same-named methods on a single search path
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
module InterestBearing 
  def calculate_interest 
    puts "Placeholder! We're in module InterestBearing." 
  end 
end 
 
class BankAccount 
  include InterestBearing 
 
  def calculate_interest 
    puts "Placeholder! We're in class BankAccount." 
    puts "And we're overriding the calculate_interest method..." 
    puts "which was defined in the InterestBearing module." 
  end 
end 
 
account = BankAccount.new 
account.calculate_interest
1
2
3
Placeholder! We're in class BankAccount. 
And we're overriding the calculate_interest method... 
which was defined in the InterestBearing module.
Listing 4.8. Mixing in two modules with a same-named method de×ned
1
2
3
4
5
6
7
8
9
10
module M 
  def report 
    puts "'report' method in module M" 
  end 
end 
 
module N 
  def report 
    puts "'report' method in module N" 
  end 

11
12
13
14
15
16
end 
 
class C 
  include M 
  include N 
end
1
2
c = C.new 
c.report
1
2
3
4
5
class C 
  include M 
  include N 
  include M 
end
1
2
c = C.new 
c.report
1
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
module MeFirst 
  def report 
    puts "Hello from module!" 
  end 
end 
 
class Person 
  prepend MeFirst 
  def report 
    puts "Hello from class!" 
  end 
end 
 
 
p = Person.new 
p.report

Figure 4.2. An instance of class D  looks for method x  in its method search path across
both included and prepended modules.
1
2
> Person.ancestors 
=> [MeFirst, Person, Object, Readline, Kernel, BasicObject]
1 Hello from class!
1
2
> Person.ancestors 
=> [Person, MeFirst, Object, Readline, Kernel, BasicObject]
Listing 4.9. Using the super  keyword to reach up one level in the lookup path

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
module M 
  def report 
    puts "'report' method in module M" 
  end 
end 
class C 
  include M 
  def report 
    puts "'report' method in class C" 
    puts "About to trigger the next higher-up report method..." 
    super 
    puts "Back from the 'super' call." 
  end 
end 
c = C.new 
c.report
1
2
3
4
1
2
3
4
'report' method in class C 
About to trigger the next higher-up report method... 
'report' method in module M 
Back from the 'super' call.
Listing 4.10. Using super  to wrap a method in a subclass
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class Bicycle 
  attr_reader :gears, :wheels, :seats 
  def initialize(gears = 1) 
    @wheels = 2 
    @seats = 1 
    @gears = gears 
  end 
end 
class Tandem < Bicycle 
  def initialize(gears) 
    super 
    @seats = 2 
  end 
end
1
2
1
2
3
4
>> o = Object.new 
=> #<Object:0x0000010141bbb0> 
>> o.blah 
NoMethodError: undefined method `blah' for #<Object:0x0000010141bbb0>

1
2
3
4
5
6
>> def o.method_missing(m, *args) 
>>   puts "You can't call #{m} on this object; please try again." 
>> end 
=> nil 
>> o.blah 
You can't call blah on this object; please try again.
1
1
2
3
4
5
6
7
8
9
class Student 
  def method_missing(m, *args) 
    if m.to_s.start_with?("grade_for_") 
      # return the appropriate grade, based on parsing the method name 
    else 
      super 
    end 
   end 
end
1
Listing 4.11. Sample usage of the Person  class
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
j = Person.new("John") 
p = Person.new("Paul") 
g = Person.new("George") 
r = Person.new("Ringo") 
j.has_friend(p) 
j.has_friend(g) 
 
g.has_friend(p) 
r.has_hobby("rings") 
Person.all_with_friends(p).each do |person| 
  puts "#{person.name} is friends with #{p.name}" 
end 
Person.all_with_hobbies("rings").each do |person| 
  puts "#{person.name} is into rings" 
end
1
2
3
John is friends with Paul 
George is friends with Paul 
Ringo is into rings
1
2
3
4
class Person 
  def self.method_missing(m, *args) 
  # code here 
1

5   end 
end
1
2
3
4
5
6
7
8
9
10
class Person 
  def self.method_missing(m, *args) 
    method = m.to_s 
    if method.start_with?("all_with_") 
      # Handle request here 
    else 
      super 
    end 
  end 
end
1
2
3
Listing 4.12. Implementation of the main logic of the Person  class
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
class Person 
  PEOPLE = [] 
  attr_reader :name, :hobbies, :friends 
  def initialize(name) 
    @name = name 
    @hobbies = [] 
    @friends = [] 
    PEOPLE << self 
  end 
  def has_hobby(hobby) 
    @hobbies << hobby 
  end 
  def has_friend(friend) 
    @friends << friend 
  end
1
2
3
4
5
Listing 4.13. Full implementation of Person.method_missing
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
def self.method_missing(m, *args) 
    method = m.to_s 
    if method.start_with?("all_with_") 
      attr = method[9..-1] 
      if self.public_method_defined?(attr) 
        PEOPLE.find_all do |person| 
          person.send(attr).include?(args[0]) 
        end 
      else 
        raise ArgumentError, "Can't find #{attr}" 
      end 
    else 
      super 
    end 
  end
1
2
3
4
5
6

Listing 4.14. CargoHold , inheriting from Stack  instead of mixing in Stacklike
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
class Stack 
  attr_reader :stack 
  def initialize 
    @stack = [] 
  end 
 
  def add_to_stack(obj) 
    @stack.push(obj) 
  end 
 
  def take_from_stack 
    @stack.pop 
  end 
end 
 
class Suitcase 
end 
 
class CargoHold < Stack 
  def load_and_report(obj) 
    print "Loading object " 
    puts obj.object_id 
    add_to_stack(obj) 
  end 
 
  def unload 
    take_from_stack 
  end 
end
1
2
3
4
5
6
7
module Vehicle 
... 
class SelfPropelling 
... 
class Truck < SelfPropelling 
  include Vehicle 
...
1
2
3
4
5
6
7
module SelfPropelling 
... 
class Vehicle 
  include SelfPropelling 
... 
class Truck < Vehicle 
...

1
2
3
4
module Tools 
  class Hammer 
  end 
end
1 h = Tools::Hammer.new

CHAPTER 5
Table 5.1. How the current object (self) is determined
Context
Example
Which object is self?
Top level of
program
Any code outside of other blocks
main (built-in top-level default
object)
Class
denition
class C 
self
The class object C
Module
denition
module M 
self
The module object M
Method
denitions
1. Top level (outside any
denition block): def
method_name self
Whatever object is self when the
method is called; top-level
methods are available as private
methods to all objects
 
1. Instance-method denition in
a class: class C def
method_name self
An instance of C, responding to
method_name
 
1. Instance-method denition in
a module: module M def
method_name self
Individual object extended by
M
Instance of class that mixes
in M
 
1. Singleton method on a specic
object: def obj.method_name
self
Obj
Figure 5.1. The determination of self in different contexts

1 x = 1
1
2
def m 
end
1 ruby -e 'puts self'
1 m = self
Listing 5.1. Examining self via calls to puts  in class and module de×nitions
1
2
3
class C 
  puts "Just started class C:" 
  puts self 
1

4
5
6
7
8
9
10
  module M 
    puts "Nested module C::M:" 
    puts self 
  end 
  puts "Back in the outer level of C:" 
  puts self 
end
2
3
1
2
3
4
5
6
7
8
9
10
class C 
  def x 
    puts "Class C, method x:" 
    puts self 
  end 
end 
 
c = C.new 
c.x 
puts "That was a call to x by: #{c}"
1
2
3
Class C, method x: 
#<C:0x00000101b381a0> 
That was a call to x by: #<C:0x00000101b381a0>
1
2
3
4
5
6
7
obj = Object.new 
def obj.show_me 
  puts "Inside singleton method show_me of #{self}" 
end 
 
obj.show_me 
puts "Back from call to show_me by #{obj}"
1
2
Inside singleton method show_me of #<Object:0x00000101b19840> 
Back from call to show_me by #<Object:0x00000101b19840>
1
2
3
4
class C 
  def C.x 
    puts "Class method of class C" 
    puts "self: #{self}" 

USING SELF INSTEAD OF HARD-CODED CLASS NAMES
By way of a little programming tip, here’s a variation on the last
example:
Note the use of self.x  
 rather than C.x . This way of writing a
class method takes advantage of the fact that in the class denition,
self is C . So def self.x  is the same as def C.x .
The self.x  version o|ers a slight advantage: if you ever decide to
rename the class, self.x  will adjust automatically to the new name.
If you hard-code C.x , you’ll have to change C  to your class’s new
name. But you do have to be careful. Remember that self inside a
method is always the object on which the method was called. You can
get into a situation where it feels like self should be one class object,
but is actually another:
5
6
7
  end 
end 
C.x
1
2
Class method of class C 
self: C
1
2
3
4
5
6
class C 
  def self.x 
    puts "Class method of class C" 
    puts "self: #{self}" 
  end 
end
1
1
2
3
class D < C 
end 
D.x

D  gets to call x , because subclasses get to call the class methods of
their superclasses. As you’ll see if you run the code, the method C.x
reports self—correctly—as being D , because it’s D  on which the
method is called.
1
2
3
obj.talk 
ticket.venue 
"abc".capitalize
1
2
3
talk 
venue 
capitalize
1
2
3
1
2
3
4
5
6
7
class C 
  def C.no_dot 
    puts "As long as self is C, you can call this method with no dot" 
  end 
  no_dot 
end 
C.no_dot
1
2
1 self.no_dot
1
2
3
4
5
6
7
8
9
10
11
12
13
class C 
  def x 
    puts "This is method 'x'" 
  end 
 
  def y 
    puts "This is method 'y', about to call x without a dot." 
    x 
  end 
end 
 
c = C.new 
c.y

1
2
This is method 'y', about to call x without a dot. 
This is method 'x'.
Listing 5.2. Composing whole name from values, using method calls on implicit self
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class Person 
  attr_accessor :first_name, :middle_name, :last_name 
  def whole_name 
    n = first_name + " " 
    n << "#{middle_name} " if middle_name 
    n << last_name 
  end 
end 
david = Person.new 
david.first_name = "David" 
david.last_name = "Black" 
puts "David's whole name: #{david.whole_name}" 
david.middle_name = "Alan" 
puts "David's new whole name: #{david.whole_name}"
1
1
2
David's whole name: David Black 
David's new whole name: David Alan Black
1
2
3
4
5
6
7
8
class C 
  def show_var 
    @v = "I am an instance variable initialized to a string." 
    puts @v 
  end 
  @v = "Instance variables can appear anywhere...." 
end 
C.new.show_var
1
2
1 I am an instance variable initialized to a string.

Listing 5.3. Demonstrating the relationship between instance variables and self
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
class C 
  puts "Just inside class definition block. Here's self:" 
  p self 
  @v = "I am an instance variable at the top level of a class body." 
  puts "And here's the instance variable @v, belonging to #{self}:" 
  p @v 
  def show_var 
    puts "Inside an instance method definition block. Here's self:" 
    p self 
    puts "And here's the instance variable @v, belonging to #{self}:" 
    p @v 
  end 
end 
 
c = C.new 
c.show_var
1
2
3
4
5
6
7
8
Just inside class definition block. Here's self: 
C 
And here's the instance variable @v, belonging to C: 
"I am an instance variable at the top level of a class body." 
Inside an instance method definition block. Here's self: 
#<C:0x00000101a77338> 
And here's the instance variable @v, belonging to #<C:0x00000101a77338>: 
nil
1
2
3
4
5
6
7
8
$gvar = "I'm a global!" 
class C 
  def examine_global 
    puts $gvar 
  end 
end 
c = C.new 
c.examine_global
1
1
2
3
4
5
6
7
class Person 
  def whole_name 
    n = $first_name + " " 
    n << "#{$middle_name} " if $middle_name 
    n << $last_name 
  end 
end

Figure 5.2. Schematic view of local scopes at the top level, the class-de×nition level,
and the methodde×nition level
1
2
3
4
5
david = Person.new 
$first_name = "David" 
$middle_name = "Alan" 
$last_name = "Black" 
puts david.whole_name
1
1
2
3
4
5
class C 
  a = 1 
  def local_a 
    a = 2 
    puts a 
1
2

6
7
8
9
10
  end 
  puts a 
end 
c = C.new 
c.local_a
3
4
1
2
1 
2
Listing 5.4. Reusing a variable name in nested local scopes
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
class C 
  a = 5 
  module M 
    a = 4 
    module N 
      a = 3 
      class D 
        a = 2 
        def show_a 
          a = 1 
          puts a 
        end 
        puts a 
      end 
      puts a 
    end 
    puts a 
  end 
  puts a 
end 
d = C::M::N::D.new 
d.show_a
1
2
3
4
5
Listing 5.5. Demonstrating the generation of a new local scope per method call
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class C 
  def x(value_for_a,recurse=false) 
    a = value_for_a 
    print "Here's the inspect-string for 'self':" 
    p self 
    puts "And here's a:" 
    puts a 
    if recurse 
      puts "Calling myself (recursion)..." 
      x("Second value for a") 
      puts "Back after recursion; here's a:" 
      puts a 
    end 
  end 
1
2
3
4
5
6

15
16
17
end 
c = C.new 
c.x("First value for a", true)
7
1
2
3
4
5
6
7
8
9
Here's the inspect-string for 'self': #<C:0x00000101b25be0> 
And here's a: 
First value for a 
Calling myself (recursion)... 
Here's the inspect-string for 'self': #<C:0x00000101b25be0> 
And here's a: 
Second value for a 
Back after recursion; here's a: 
First value for a
1
2
3
4
5
6
7
8
9
module M 
  class C 
    class D 
      module N 
        X = 1 
      end 
    end 
  end 
end
1
2
3
4
5
6
7
8
9
10
11
12
module M 
  class C 
    X = 2 
    class D 
      module N 
        X = 1 
      end 
    end 
  end 
end 
puts M::C::D::N::X 
puts M::C::X
1
2
1
2
3
4
5
6
7
8
module M 
  class C 
    class D 
      module N 
        X = 1 
      end 
    end 
    puts D::N::X 
1

9
10
  end 
end
1
2
3
4
5
6
7
8
9
10
11
class Violin 
  class String 
    attr_accessor :pitch 
    def initialize(pitch) 
      @pitch = pitch 
    end 
  end 
  def initialize 
    @e = String.new("E") 
    @a = String.new("A") 
    ...etc....
1
1
2
3
def history 
  ::String.new(maker + ", " + date) 
end
1
2
3
4
5
Car.add_make("Honda") 
Car.add_make("Ford") 
h = Car.new("Honda") 
f = Car.new("Ford") 
h2 = Car.new("Honda")
1
2
3
Creating a new Honda! 
Creating a new Ford! 
Creating a new Honda!
1
2
puts "Counting cars of same make as h2..." 
puts "There are #{h2.make_mates}."

1
2
puts "Counting total cars..." 
puts "There are #{Car.total_count}."
1
2
Counting total cars... 
There are 3.
1 x = Car.new("Brand X")
1 car.rb:21:in `initialize': No such make: Brand X. (RuntimeError)
Listing 5.6. Keeping track of car manufacturing statistics with class variables
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
class Car 
  @@makes = [] 
  @@cars = {} 
  @@total_count = 0 
  attr_reader :make 
  def self.total_count 
    @@total_count       
  end                   
  def self.add_make(make) 
    unless @@makes.include?(make) 
      @@makes << make 
      @@cars[make] = 0 
    end 
  end 
  def initialize(make) 
    if @@makes.include?(make) 
      puts "Creating a new #{make}!" 
      @make = make 
      @@cars[make] += 1 
      @@total_count += 1 
    else      raise "No such make: #{make}." 
    end 
  end 
  def make_mates 
    @@cars[self.make] 
  end 
end
1
2
3
4
5
6
7
8

1
2
3
4
5
6
7
8
9
class Parent 
  @@value = 100 
end 
class Child < Parent       
  @@value = 200 
end 
class Parent 
  puts @@value 
end
1
2
3
1
2
3
4
class Hybrid < Car 
end 
hy = Hybrid.new("Honda") 
puts "There are #{Hybrid.total_count} hybrids in existence!"
1
2
3
4
class Hybrid < Car 
  @@total_hybrid_count = 0 
  # etc. 
end
Listing 5.7. Car  with @@total_count  replaced by instance variable
@total_count
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
class Car 
  @@makes = [] 
  @@cars = {} 
  attr_reader :make 
  def self.total_count 
    @total_count ||= 0 
  end 
  def self.total_count=(n) 
    @total_count = n 
  end 
  def self.add_make(make) 
    unless @@makes.include?(make) 
      @@makes << make 
      @@cars[make] = 0 
    end 
  end 
  def initialize(make) 
    if @@makes.include?(make) 
      puts "Creating a new #{make}!" 
      @make = make 
      @@cars[make] += 1 
      self.class.total_count += 1 
    else 
      raise "No such make: #{make}." 
    end 
  end 
1
2
3

27
28
29
30
  def make_mates 
    @@cars[self.make] 
  end 
end
1
2
3
4
5
class Hybrid < Car 
end 
h3 = Hybrid.new("Honda") 
f2 = Hybrid.new("Ford") 
puts "There are #{Hybrid.total_count} hybrids on the road!"
1
1 self.class.total_count += 1
Listing 5.8. Baker  and other baking-domain classes
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
class Cake 
  def initialize(batter) 
    @batter = batter 
    @baked = true 
  end 
end 
class Egg 
end 
class Flour 
end 
class Baker 
  def bake_cake 
    @batter = [] 
    pour_flour 
    add_egg 
    stir_batter 
    return Cake.new(@batter) 
  end 
  def pour_flour 
    @batter.push(Flour.new) 
  end 
  def add_egg 
    @batter.push(Egg.new) 
  end 
  def stir_batter 
  end 
  private :pour_flour, :add_egg, :stir_batter 
end
1
2
3
4

1
2
b = Baker.new 
b.add_egg
1 `<main>': private method `add_egg' called for #<Baker:0x00000002aeae50> (NoMethodErro
1 add_egg
1 dog_years = age * 7
1 self.dog_years = age * 7
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class Dog 
  attr_reader :age, :dog_years 
 
  def dog_years=(years) 
    @dog_years = years 
  end 
 
  def age=(years) 
    @age = years 
    self.dog_years = years * 7 
  end 
 
  private :dog_years= 
end
1
2
3
rover = Dog.new 
rover.age = 10 
puts "Rover is #{rover.dog_years} in dog years."
1

1
2
3
4
5
def age=(years) 
  @age = years 
  dog = self 
  dog.dog_years = years * 7 
end
1
2
NoMethodError: private method 'dog_years=' called for 
#<Dog:0x00000101b0d1a8 @age=10>
Listing 5.9. Example of a protected method and its use
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
class C 
  def initialize(n) 
    @n = n 
  end 
  def n 
    @n 
  end 
  def compare(c) 
    if c.n > n 
      puts "The other object's n is bigger." 
    else 
      puts "The other object's n is the same or smaller." 
    end 
  end 
  protected :n 
end 
c1 = C.new(100) 
c2 = C.new(101) 
c1.compare(c2)
1
1
2
3
def talk 
  puts "Hello" 
end
1
2
3
4
5
class Object 
  private 
 
  def talk 
    puts "Hello" 

6
7
  end 
end
1
2
3
4
5
6
7
8
def talk 
  puts "Hello" 
end 
puts "Trying 'talk' with no receiver..." 
talk 
puts "Trying 'talk' with an explicit receiver..." 
obj = Object.new 
obj.talk
1
2
1 puts "Hello"
1 $ ruby -e 'p Kernel.private_instance_methods.sort'

CHAPTER 6
1
2
3
if condition 
  # code here, executed if condition is true 
end
1 if x > 10 then puts x end
1 if x > 10; puts x; end
1
2
3
4
5
if condition 
  # code executed if condition is true 
else 
  # code executed if condition is false 
end
1
2
3
4
5
6
7
8
9
if condition1 
# code executed if condition1 is true 
elsif condition2 
# code executed if condition1 is false 
# and condition2 is true 
elsif condition3 
# code executed if neither condition1 
# nor condition2 is true, but condition3 is 
end
1
2
3
4
5
print "Enter an integer: " 
n = gets.to_i 
if n > 0 
  puts "Your number is positive." 
elsif n < 0 

6
7
8
9
  puts "Your number is negative." 
else 
  puts "Your number is zero." 
end
1 if not (x == 1)
1 if !(x == 1)
1 if not x == 1
1 if !x == 1
1 if (!x) == 1
1 unless x == 1
1
2
3
4
5
unless x > 100 
  puts "Small number!" 
else 
  puts "Big number!" 
end

LIFE WITHOUT THE DANGLING ELSE AMBIGUITY
In some languages, you can’t tell which else  clause goes with which
if  clause without a special rule. In C, for example, an if  statement
might look like this:
But wait: Does the code behave the way the indentation indicates (the
else  belongs to the second if )? Or does it work like this?
All that’s changed is the indentation of the third line (which doesn’t
matter to the C compiler; the indentation just makes the ambiguity
visually obvious). Which if  does the else  belong to? And how do
you tell?
You tell by knowing the rule in C: a dangling else  goes with the last
unmatched if  (the rst of the two behaviors in this example). But in
Ruby, you have end  to help you out:
1
2
3
4
5
if x <= 100 
  puts "Small number!" 
else 
  puts "Big number!" 
end
1
2
3
if (x) 
    if (y) { execute this code } 
    else   { execute this code };
1
1
2
3
if (x) 
    if (y){ execute this code } 
else { execute this code };
1
1
2
3
4
5
if x > 50 
  if x > 100 
    puts "Big number" 
  else 
    puts "Medium number" 

The single else  in this statement has to belong to the second if ,
because that if  hasn’t yet hit its end . The rst if  and the last
end  always belong together, the second if  and the second-to-last
end  always belong together, and so forth. The if/end  pairs encircle
what belongs to them, including else . Of course, this means you
have to place your end  keywords correctly.
6
7
  end 
end
1 puts "Big number!" if x > 100
1
2
3
if x > 100 
  puts "Big number!" 
end
1 puts "Big number!" unless x <= 100
1 puts "done" && return (x > y && a < b) unless c == 0
1
1
2
3
4
5
6
7
8
x = 1 
if x < 0 
  "negative" 
elsif x > 0 
  "positive" 
else 
  "zero" 
end

1
2
3
4
5
6
7
8
>> x = 1 
=> 1 
>> if x == 2 
>>   "it's 2!" 
>> elsif x == 3 
>>   "it's 3!" 
>> end 
=> nil
1
1
2
3
if x = 1 
  y = 2 
end
1
2
1 x = 1
1
2
3
4
5
if false 
  x = 1 
end 
p x 
p y
1
2
1
2
3
if x = 1 
  puts "Hi!" 
end
1 warning: found = in conditional, should be ==
1 if x = y
1

1
2
3
x = y 
if x 
# etc.
1
2
3
4
5
6
7
8
9
10
name = "David A. Black" 
if m = /la/.match(name) 
  puts "Found a match!" 
  print "Here's the unmatched start of the string: " 
  puts m.pre_match 
  print "Here's the unmatched end of the string: " 
  puts m.post_match 
else 
  puts "No match" 
end
1
1
2
3
Found a match! 
Here's the unmatched start of the string: David A. B 
Here's the unmatched end of the string: ck
1
2
3
m = /la/.match(name) 
if m 
  # etc.
Listing 6.1. Interpreting user input with a case  statement
1
2
3
4
5
6
7
8
9
10
11
12
print "Exit the program? (yes or no): " 
answer = gets.chomp 
case answer 
when "yes" 
  puts "Good-bye!" 
  exit 
when "no" 
  puts "OK, we'll continue" 
else 
  puts "That's an unknown answer -- assuming you meant 'no'" 
end 
puts "Continuing with program...."
1
2
3
4
5

1
2
3
4
5
case answer 
when "y", "yes" 
  puts "Good-bye!" 
  exit 
   # etc.
1
2
3
4
5
6
7
8
if "yes" === answer 
  puts "Good-bye!" 
  exit 
elsif "no" === answer 
  puts "OK, we'll continue" 
else 
  puts "That's an unknown answer—assuming you meant 'no'" 
end
1 if "yes".===(answer)
1 "yes" === answer
Listing 6.2. Implementing case  statement behavior for the Ticket  class
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
class Ticket 
  attr_accessor :venue, :date 
  def initialize(venue, date) 
    self.venue = venue 
    self.date = date 
  end 
  def ===(other_ticket) 
    self.venue == other_ticket.venue 
  end 
end 
ticket1 = Ticket.new("Town Hall", "07/08/13") 
ticket2 = Ticket.new("Conference Center", "07/08/13") 
ticket3 = Ticket.new("Town Hall", "08/09/13") 
puts "ticket1 is for an event at: #{ticket1.venue}." 
case ticket1     
when ticket2 
  puts "Same location as ticket2!" 
when ticket3 
  puts "Same location as ticket3!" 
else 
1
2
3

21
22
  puts "No match" 
end
1
2
ticket1 is for an event at: Town Hall. 
Same location as ticket3!
1 if ticket2 === ticket1
1
2
3
4
5
6
7
8
case 
when user.first_name == "David", user.last_name == "Black" 
  puts "You might be David Black." 
when Time.now.wday == 5 
  puts "You're not David Black, but at least it's Friday!" 
else 
  puts "You're not David Black, and it's not Friday." 
end
1
1
2
3
4
5
6
7
if user.first_name == "David" or user.last_name == "Black" 
  puts "You might be David Black." 
elsif Time.now.wday == 5 
  puts "You're not David Black, but at least it's Friday!" 
else 
  puts "You're not David Black, and it's not Friday." 
end
1
2
3
4
5
6
7
8
puts case 
     when user.first_name == "David", user.last_name == "Black" 
       "You might be David Black." 
     when Time.now.wday == 5 
       "You're not David Black, but at least it's Friday!" 
     else 
       "You're not David Black, and it's not Friday." 
     end

1 loop codeblock
1
2
3
4
5
loop { puts "Looping forever!" } 
 
loop do 
  puts "Looping forever!" 
end
1
2
3
4
5
n = 1 
loop do 
  n = n + 1 
  break if n > 9 
end
1
2
3
4
5
6
n = 1 
loop do 
  n = n + 1 
  next unless n == 10 
  break 
end
1
2
3
4
5
6
n = 1 
while n < 11 
  puts n 
  n = n + 1 
end 
puts "Done!"
1
2
3
4
5
6
1 
2 
3 
4 
5 
6 

7
8
9
10
11
7 
8 
9 
10 
Done!
1
2
3
4
5
6
n = 1 
begin 
  puts n 
  n = n + 1 
end while n < 11 
puts "Done!"
1
2
3
4
n = 10 
while n < 10 
  puts n 
end
1
2
3
4
n = 10 
begin 
  puts n 
end while n < 10
1
2
3
4
5
n = 1 
until n > 10 
  puts n 
  n = n + 1 
end
1
2
3
n = 1 
n = n + 1 until n == 10 
puts "We've reached 10!"

1
2
a = 1 
a += 1 until true
1
2
3
4
a = 1 
begin 
  a += 1 
end until true
1
2
3
4
5
celsius = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100] 
puts "Celsius\tFahrenheit" 
for c in celsius 
  puts "#{c}\t#{Temperature.c2f(c)}" 
end
1
1 loop { puts "Looping forever!" }
1
2
3
4
5
def my_loop 
  while true 
    yield 
  end 
end
1
2
3
def my_loop 
  yield while true 
end
1 my_loop { puts "My-looping forever!" }

1
2
3
4
loop { puts "Hi" } 
loop() { puts "Hi" } 
string.scan(/[^,]+/) 
string.scan(/[^,]+/) {|word| puts word }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
>> array = [1,2,3] 
=> [1, 2, 3] 
>> array.map {|n| n * 10 } 
=> [10, 20, 30]                        
>> array.map do |n| n * 10 end 
=> [10, 20, 30]                                
>> puts array.map {|n| n * 10 } 
10 
20 
30 
=> nil 
>> puts array.map do |n| n * 10 end 
   #<Enumerator:0x00000101132048> 
=> nil
1
2
3
4
1 puts(array.map {|n| n * 10 })
1 puts(array.map) do |n| n * 10 end
1 puts array.map
1
2
3
4
5
>> 5.times { puts "Writing this 5 times!" } 
Writing this 5 times! 
Writing this 5 times! 
Writing this 5 times! 
Writing this 5 times! 
1

6
7
Writing this 5 times! 
=> 5
2
1
2
3
4
5
6
7
>> 5.times {|i| puts "I'm on iteration #{i}!" } 
I'm on iteration 0! 
I'm on iteration 1! 
I'm on iteration 2! 
I'm on iteration 3! 
I'm on iteration 4! 
=> 5
1
2
3
4
5
6
7
8
9
10
class Integer 
  def my_times 
    c = 0 
    until c == self 
      yield(c) 
      c += 1 
    end 
    self 
  end 
end
1
2
3
4
5
6
7
>> 5.my_times {|i| puts "I'm on iteration #{i}!" } 
I'm on iteration 0! 
I'm on iteration 1! 
I'm on iteration 2! 
I'm on iteration 3! 
I'm on iteration 4! 
=> 5
1
2
array = [1,2,3,4,5] 
array.each {|e| puts "The block just got handed #{e}." }
1
2
3
4
5
>> array.each {|e| puts "The block just got handed #{e}." } 
The block just got handed 1. 
The block just got handed 2. 
The block just got handed 3. 
The block just got handed 4. 

EXTRA CREDIT: DEFINE MY_EACH IN TERMS OF MY_TIMES
An interesting exercise is to dene my_each  using the existing
denition of my_times . You can use the size  method to determine
how many iterations you need and then perform them courtesy of
my_times , like so:
6
7
The block just got handed 5. 
=> [1, 2, 3, 4, 5]
1
2
3
4
5
6
7
8
9
10
class Array 
  def my_each 
    c = 0 
    until c == size 
      yield(self[c]) 
      c += 1 
    end 
    self 
  end 
end
1
1
2
3
4
5
6
7
8
>> array = [1,2,3,4,5] 
>> array.my_each {|e| puts "The block just got handed #{e}." } 
The block just got handed 1. 
The block just got handed 2. 
The block just got handed 3. 
The block just got handed 4. 
The block just got handed 5. 
=> [1, 2, 3, 4, 5]
1
2
3
4
5
6
7
8
class Array 
  def my_each 
    size.my_times do |i| 
      yield self[i] 
    end 
    self 
  end 
end

Using my_times  saves you the trouble of writing loop-counter code
in my_each . But it’s a bit backward: many of Ruby’s iterators are built
on top of each , not the other way around. Given the denition of
my_each  in the main text, how would you use it in an implementation
of my_times ?
Unlike the rst exercise, this one really will be left to you to try on your
own!
1
2
3
4
>> names = ["David", "Alan", "Black"] 
=> ["David", "Alan", "Black"] 
>> names.map {|name| name.upcase } 
=> ["DAVID", "ALAN", "BLACK"]
1
2
3
4
5
6
7
8
9
10
11
class Array 
  def my_map 
    c = 0 
    acc = [] 
    until c == size 
      acc << yield(self[c]) 
      c += 1 
    end 
    acc 
  end 
end
1
2
3
1
2
>> names.my_map {|name| name.upcase } 
=> ["DAVID", "ALAN", "BLACK"]
1
2
3
4
5
6
7
8
class Array 
  # Put the definition of my_each here 
  def my_map 
    acc = [] 
    my_each {|e| acc << yield(e) } 
    acc 
  end 
end

1
2
3
4
def args_unleashed(a,b=1,*c,d,e) 
  puts "Arguments:" 
  p a,b,c,d,e 
end
1
2
3
4
5
6
7
8
def block_args_unleashed 
  yield(1,2,3,4,5) 
end 
 
block_args_unleashed do |a,b=1,*c,d,e| 
  puts "Arguments:" 
  p a,b,c,d,e 
end
1
2
3
4
5
6
Arguments: 
1 
2 
[3] 
4 
5
1
2
3
4
5
6
def block_scope_demo 
  x = 100 
  1.times do 
    puts x 
  end 
end
1
1 block_scope_demo
1
1
2
3
4
5
6
7
def block_scope_demo_2 
  x = 100 
  1.times do 
    x = 200 
  end 
  puts x 

8 end 
block_scope_demo_2
1
1
2
3
4
5
6
7
8
9
def block_local_parameter 
  x = 100 
  [1,2,3].each do |x| 
    puts "Parameter x is #{x}" 
    x = x + 10 
    puts "Reassigned to x in block; it's now #{x}" 
  end 
  puts "Outer x is still #{x}" 
end
1
2
3
1
2
3
4
5
6
7
Parameter x is 1 
Reassigned to x in block; it's now 11 
Parameter x is 2 
Reassigned to x in block; it's now 12 
Parameter x is 3 
Reassigned to x in block; it's now 13 
Outer x is still 100
1
2
3
4
5
6
7
8
9
10
def block_local_variable 
  x = "Original x!" 
  3.times do |i;x| 
    x = i 
    puts "x in the block is now #{x}" 
  end 
  puts "x after the block ended is #{x}" 
end 
 
block_local_variable
1
2
3
4
x in the block is now 0 
x in the block is now 1 
x in the block is now 2 
x after the block ended is Original x!

Table 6.1. Common exceptions
Exception name
Common reason(s)
How to raise it
RuntimeError
The default exception raised
by the raise method.
Raise
NoMethodError
An object is sent a message it
can’t resolve to a method
name; the default
method_missing raises this
exception.
a = Object.new 
a.some_unknown_method_name
NameError
The interpreter hits an
identier it can’t resolve as a
variable or method name.
a = some_random_identier
IOError
Caused by reading a closed
stream, writing to a read-
only stream, and similar
operations.
STDIN.puts("Don't write to
STDIN!")
Errno::error
A family of errors relates to
le I/O.
File.open(-12)
TypeError
A method receives an
argument it can’t handle.
a = 3 + "can't add a string to a
number!"
ArgumentError
Caused by using the wrong
number of arguments.
def m(x); end; m(1,2,3,4,5)
1 $ ruby -cw filename.rb
1 $ ruby -e '1/0'
1
2
-e:1:in `/': divided by 0 (ZeroDivisionError) 
    from -e:1:in `<main>'
1
2
3
print "Enter a number: " 
n = gets.to_i 
begin 

4
5
6
7
8
9
10
  result = 100 / n 
rescue 
  puts "Your number didn't work. Was it zero???" 
  exit 
end 
 
puts "100/#{n} is #{result}."
1 rescue ZeroDivisionError
1
2
3
4
5
6
7
8
9
def open_user_file 
  print "File to open: " 
  filename = gets.chomp 
  fh = File.open(filename) 
  yield fh 
  fh.close 
  rescue 
    puts "Couldn't open your file!" 
end
1
2
1
2
3
4
5
6
7
8
9
10
11
12
def open_user_file 
  print "File to open: " 
  filename = gets.chomp 
  begin 
    fh = File.open(filename) 
  rescue 
    puts "Couldn't open your file!" 
    return 
  end 
  yield fh 
  fh.close 
end
1
2
3
1
2
3
4
def fussy_method(x) 
  raise ArgumentError, "I need a number under 10" unless x < 10 
end 
fussy_method(20)

WHAT GETS RAISED: AN EXCEPTION OR AN EXCEPTION CLASS?
The language of exception raising is class-based: raise
ZeroDivisionError  rather than raise ZeroDivisionError.new .
But really, instances of the exception classes are raised. The syntax lets
1
2
fussy.rb:2:in `fussy_method': I need a number under 10 (ArgumentError) 
    from fussy.rb:5:in `<main>'
1
2
3
4
5
begin 
  fussy_method(20) 
rescue ArgumentError 
  puts "That was not an acceptable number!" 
end
1
2
raise "Problem!" 
raise RuntimeError, "Problem!"
1
2
3
4
5
6
7
8
9
begin 
  fussy_method(20) 
rescue ArgumentError => e 
  puts "That was not an acceptable number!" 
  puts "Here's the backtrace for this exception:" 
  puts e.backtrace 
  puts "And here's the exception object's message:" 
  puts e.message 
end
1
2
3
1
2
3
4
5
6
That was not an acceptable number! 
Here's the backtrace for this exception: 
fussy.rb:2:in `fussy_method' 
fussy.rb:6:in `<main>' 
And here's the exception object's message: 
I need a number under 10

you raise a class because that looks better and abstracts away the fact
that instantiation is involved.
You can see the class/instance switch-o| if you examine the object
that you capture in the rescue  clause:
The object’s class is ArgumentError ; the object itself is an instance
of ArgumentError , not the class ArgumentError .
You get a reprieve from typing .new , and your code has a nice high-
level look to it, providing enough information to show you what’s
going on without unnecessary housekeeping details.
1
2
3
4
5
begin 
raise ArgumentError 
rescue => e 
p e.class 
end
1
1
2
3
4
5
6
7
8
begin 
  fh = File.open(filename) 
 
rescue => e 
  logfile.puts("User tried to open #{filename}, #{Time.now}") 
  logfile.puts("Exception: #{e.message}") 
  raise 
end
1
2
3
4
5
6
7
8
9
10
11
12
13
def line_from_file(filename, substring) 
  fh = File.open(filename) 
  begin 
    line = fh.gets 
    raise ArgumentError unless line.include?(substring) 
  rescue ArgumentError 
    puts "Invalid line!" 
    raise 
  ensure 
    fh.close 
  end 
  return line 
end

1
2
3
class MyNewException < Exception 
end 
raise MyNewException, "some new kind of error has occurred!"
1
2
3
4
5
6
7
8
class MyNewException < Exception 
end 
begin 
  puts "About to raise exception..." 
  raise MyNewException 
rescue MyNewException => e 
  puts "Just raised an exception: #{e}" 
end
1
2
About to raise exception... 
Just raised an exception: MyNewException
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class InvalidLineError < StandardError 
end 
def line_from_file(filename, substring) 
  fh = File.open(filename) 
  line = fh.gets 
  raise InvalidLineError unless line.include?(substring) 
  return line 
 
  rescue InvalidLineError 
    puts "Invalid line!" 
    raise 
  ensure 
    fh.close 
end
1
2
3
4
5
6
7
8
module TextHandler 
  class InvalidLineError < StandardError 
  end 
end 
def line_from_file(filename, substring) 
  fh = File.open(filename) 
  line = fh.gets 
  raise TextHandler::InvalidLineError unless line.include?(substring)
1


CHAPTER 7
Table 7.1. Built-in Ruby classes with literal constructors
Class
Literal constructor
Example(s)
String
Quotation marks
"new string" 
'new string'
Symbol
Leading colon
:symbol 
:"symbol with spaces"
Array
Square brackets
[1,2,3,4,5]
Hash
Curly braces
{"New York" => "NY", "Oregon"
=> "OR"}
Range
Two or three dots
0..9 or 0...10
Regexp
Forward slashes
/([a-z]+)/
Proc (lambda)
Dash, arrow, parentheses,
braces
->(x,y) { x * y }
1
2
str = String.new 
arr = Array.new
1 x = 1 + 2
1 x = 1.+(2)
1 my_object + my_other_object

Table 7.2. Methods with operator-style syntactic sugar–calling notation
Category
Name
Denition
example
Calling example
Sugared
notation
Arithmetic
method/operators
+
def +(x)
obj.+(x)
obj + x
 
-
def -(x)
obj.-(x)
obj - x
 
*
def *(x)
obj.*(x)
obj * x
 
/
def /(x)
obj./(x)
obj / x
 
% (modulo)
def %(x)
obj.%(x)
obj % x
 
** (exponent)
def **(x)
obj.**(x)
obj ** x
Get/set/append
data
[]
def [](x)
obj.[](x)
obj[x]
 
[]=
def []=(x,y)
obj.[]=(x,y)
obj[x] = y
 
<<
def <<(x)
obj.<<(x)
obj << x
Comparison
method/operators
<=>
def <=>(x)
obj.<=>(x)
obj <=> x
 
==
def ==(x)
obj.==(x)
obj == x
 
>
def >(x)
obj.>(x)
obj > x
 
<
def <(x)
obj.<(x)
obj < x
1
2
3
4
5
obj = Object.new 
def obj.+(other_obj) 
  "Trying to add something to me, eh?" 
end 
puts obj + 100
1
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
class Account 
  attr_accessor :balance 
  def initialize(amount=0) 
    self.balance = amount 
  end 
  def +(x) 
    self.balance += x 
  end 
  def -(x) 
    self.balance -= x 
  end 
  def to_s 
    balance.to_s 
  end 
end 
acc = Account.new(20) 
acc -= 5 
puts acc
1
2
3

Category
Name
Denition
example
Calling example
Sugared
notation
 
>=
def >=(x)
obj.>=(x)
obj >= x
 
<=
def <=(x)
obj.<=(x)
obj <= x
Case equality
operator
===
def ===(x)
obj.===(x)
obj === x
Bitwise operators
| (OR)
def |(x)
obj.|(x)
obj | x
 
& (AND)
def &(x)
obj.&(x)
obj & x
 
^ (XOR)
def ^(x)
obj.^(x)
obj ^ x
1
2
3
4
5
6
7
8
9
10
11
12
13
14
class Banner 
  def initialize(text) 
    @text = text 
  end 
  def to_s 
    @text 
  end 
  def +@ 
    @text.upcase 
  end 
  def -@ 
    @text.downcase 
  end 
end
1
1
2
3
4
banner = Banner.new("Eat at David's!") 
puts banner 
puts +banner 
puts -banner
1
2
3
1
2
3
4
5
class Banner 
  def ! 
    reverse 
  end 
end
1
2
puts !banner 
puts (not banner)
1
2

1
2
3
4
5
6
7
8
9
10
>> str = "Hello" 
=> "Hello" 
>> str.upcase 
=> "HELLO" 
>> str 
=> "Hello" 
>> str.upcase! 
=> "HELLO" 
>> str 
=> "HELLO"
1
2
1
2
3
4
names.each do |name| 
  capped = name.upcase 
  # ...code that does something with capped... 
end
1
2
>> "I am already a string!".to_s 
=> "I am already a string!"
1
2
>> ["one", "two", "three", 4, 5, 6].to_s 
=> "[\"one\", \"two\", \"three\", 4, 5, 6]"
1
2
>> Object.new.to_s 
=> "#<Object:0x000001030389b0>"
1
2
3
4
5
6
>> obj = Object.new 
=> #<Object:0x000001011c9ce0> 
>> puts obj 
#<Object:0x000001011c9ce0> 
=> nil 
>> def obj.to_s 
1
2
3

7
8
9
10
11
12
>>   "I'm an object!" 
>> end 
=> :to_s 
>> puts obj 
I'm an object! 
=> nil
4
5
1
2
>> "My object says: #{obj}" 
=> "My object says: I'm an object!"
1
2
>> Object.new.inspect 
=> "#<Object:0x007fe24a292b68>"
1
2
3
4
5
6
7
8
>> Object.new 
=> #<Object:0x007f91c2a8d1e8> 
>> "abc" 
=> "abc" 
>> [1,2,3] 
=> [1, 2, 3] 
>> /a regular expression/ 
=> /a regular expression/
1
2
3
4
5
6
7
8
9
10
11
12
13
class Person 
  def initialize(name) 
    @name = name 
  end 
 
 
  def inspect 
    @name 
  end 
end 
 
david = Person.new("David") 
puts david.inspect          # Output: David
1
2
>> "Hello".display 
Hello=> nil

1
2
3
4
5
6
7
8
>> fh = File.open("/tmp/display.out", "w") 
=> #<File:/tmp/display.out> 
>> "Hello".display(fh) 
=> nil 
>> fh.close 
=> nil 
>> puts(File.read("/tmp/display.out")) 
Hello
1
2
1 [1,2,3,4,5]
1
2
3
4
>> array = [1,2,3,4,5] 
=> [1, 2, 3, 4, 5] 
>> [*array] 
=> [1, 2, 3, 4, 5]
1
2
>> [array] 
=> [[1, 2, 3, 4, 5]]
1
2
3
4
5
def combine_names(first_name, last_name) 
  first_name + " " + last_name 
end 
names = ["David", "Black"] 
puts combine_names(*names)
1
1 >> 1 + "2"
1

1
2
3
print "Enter a number: " 
n = gets.chomp 
puts n * 100
1 n = gets.to_i
1
2
3
4
5
6
7
8
9
10
>> "123abc".to_i 
=> 123 
>> Integer("123abc") 
ArgumentError: invalid value for Integer(): "123abc" 
>> Float("3") 
=> 3.0 
>> Float("-3") 
=> -3.0 
>> Float("-3xyz") 
ArgumentError: invalid value for Float(): "-3xyz"
1
2
>> "Hello " + "there." 
=> "Hello there."
1
2
>> "Hello " + 10 
TypeError: no implicit conversion of Float into String
1
2
3
4
5
6
class Person 
  attr_accessor :name 
  def to_str 
    name 
  end 
end

1
2
3
david = Person.new 
david.name = "David" 
puts "david is named " + david + "."
1
1
2
3
4
5
6
class Person 
  attr_accessor :name, :age, :email 
  def to_ary 
    [name, age, email] 
  end 
end
1
2
3
4
5
6
7
david = Person.new 
david.name = "David" 
david.age = 55 
david.email = "david@wherever" 
array = [] 
array.concat(david) 
p array
1
1 100 > 80
1 if e
Listing 7.1. Testing the Boolean value of expressions using if  constructs
1
2
3
4
5
6
7
8
9
10
11
12
if (class MyClass; end) 
  puts "Empty class definition is true!" 
else 
  puts "Empty class definition is false!" 
end 
if (class MyClass; 1; end) 
  puts "Class definition with the number 1 in it is true!" 
else 
  puts "Class definition with the number 1 in it is false!" 
end 
if (def m; return false; end) 
  puts "Method definition is true!" 
1
2
3

13
14
15
16
17
18
19
20
21
22
23
24
25
else 
  puts "Method definition is false!" 
end 
if "string" 
  puts "Strings appear to be true!" 
else 
  puts "Strings appear to be false!" 
end 
if 100 > 50 
  puts "100 is greater than 50!"  
else 
  puts "100 is not greater than 50!" 
end
4
5
1
2
3
4
5
Empty class definition is false! 
Class definition with the number 1 in it is true! 
Method definition is true! 
Strings appear to be true! 
100 is greater than 50!
1
2
3
4
5
6
7
8
9
10
>> class MyClass; end 
=> nil 
>> class MyClass; 1; end 
=> 1 
>> def m; return false; end 
=> :m 
>> "string literal!" 
=> "string literal!" 
>> 100 > 50 
=> true
1
2
3
4
5
1
2
puts true.class 
puts false.class
1
2
1
2
3
4
5
6
7
8
>> a = true 
=> true 
>> a = 1 unless a 
=> nil 
>> a 
=> true 
>> b = a 
=> true

Table 7.3. Mapping sample expressions to their evaluation results and Boolean values
Expression
Object to which expression evaluates
Boolean value of expression
1
1
True
0
0
True
1+1
2
True
true
true
True
false
false
False
nil
nil
False
"string"
"string"
True
""
""
True
puts
"string"
nil
False
100 > 50
true
True
x = 10
10
True
def x; end
:x
True
class C; end
nil
False
class C; 1;
end
1
True
1 >> String.instance_methods(false)
1 puts @x
1
2
>> ["one","two","three"][9] 
=> nil
1
2
3
4
5
6
>> nil.to_s 
=> "" 
>> nil.to_i 
=> 0 
>> nil.object_id 
=> 8

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
>> a = Object.new 
=> #<Object:0x00000101258af8> 
>> b = Object.new 
=> #<Object:0x00000101251d70> 
>> a == a 
=> true 
>> a == b 
=> false 
>> a != b 
=> true 
>> a.eql?(a) 
=> true 
>> a.eql?(b) 
=> false 
>> a.equal?(a) 
=> true 
>> a.equal?(b) 
=> false
1
2
3
4
5
6
7
8
9
10
11
>> string1 = "text" 
=> "text" 
>> string2 = "text" 
=> "text" 
>> string1 == string2 
=> true 
>> string1.eql?(string2) 
 
=> true 
>> string1.equal?(string2) 
=> false
Listing 7.2. Example of a class that mixes in the Comparable  module
1
2
3
4
5
6
7
8
9
10
11
12
13
class Bid 
  include Comparable 
  attr_accessor :estimate 
  def <=>(other_bid) 
    if self.estimate < other_bid.estimate 
      -1 
    elsif self.estimate > other_bid.estimate 
      1 
    else 
      0 
    end 
  end 
end
1

1
2
3
def <=>(other_bid) 
  self.estimate <=> other_bid.estimate 
end
1
2
3
4
5
6
7
8
9
10
>> bid1 = Bid.new 
=> #<Bid:0x000001011d5d60> 
>> bid2 = Bid.new 
=> #<Bid:0x000001011d4320> 
>> bid1.estimate = 100 
=> 100 
>> bid2.estimate = 105 
=> 105 
>> bid1 < bid2 
=> true
1 >> "I am a String object".methods
1 >> "I am a String object".methods.sort
1 >> String.methods.sort
1
2
3
4
5
6
7
8
9
10
>> str = "A plain old string" 
=> "A plain old string" 
>> def str.shout 
>>   self.upcase + "!!!" 
>> end 
 
=> nil 
>> str.shout 
=> "A PLAIN OLD STRING!!!" 
>> str.methods.sort

1
2
>> str.singleton_methods 
=> [:shout]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
>> str = "Another plain old string." 
=> "Another plain old string." 
>> module StringExtras 
>>   def shout 
>>     self.upcase + "!!!" 
>>   end 
>> end 
=> :shout 
>> class String 
>>   include StringExtras 
>> end 
=> String 
>> str.methods.include?(:shout) 
=> true
1
1 >> String.instance_methods.sort
1 >> Enumerable.instance_methods.sort
1 String.instance_methods(false).sort

CHAPTER 8
1 "This is a string."
1 'This is also a string.'
1
2
puts "Two plus two is #{2 + 2}." 
puts 'Two plus two is #{2 + 2}.'
1
2
Two plus two is 4. 
Two plus two is #{2 + 2}.
1 puts "Escaped interpolation: \"\#{2 + 2}\"."
1
2
3
4
5
6
7
8
9
10
puts "Backslashes (\\) have to be escaped in double quotes." 
puts 'You can just type \ once in a single quoted string.' 
puts "But whichever type of quotation mark you use..." 
puts "...you have to escape its quotation symbol, such as \"." 
puts 'That applies to \' in single-quoted strings too.' 
puts 'Backslash-n just looks like \n between single quotes.' 
puts "But it means newline\nin a double-quoted string." 
puts 'Same with \t, which comes out as \t with single quotes...' 
puts "...but inserts a tab character:\tinside double quotes." 
puts "You can escape the backslash to get \\n and \\t with double quotes."

1
2
3
4
5
6
7
8
9
10
11
Backslashes (\) have to be escaped in double quotes. 
You can just type \ once in a single quoted string. 
But whichever type of quotation mark you use... 
...you have to escape its quotation symbol, such as ". 
That applies to ' in single-quoted strings too. 
Backslash-n just looks like \n between single quotes. 
But it means newline 
in a double-quoted string. 
Same with \t, which comes out as \t with single quotes... 
...but inserts a tab character:    inside double quotes. 
You can escape the backslash to get \n and \t with double quotes.
1 puts %q{You needn't escape apostrophes when using %q.}
1
2
3
%q-A string- 
%Q/Another string/ 
%[Yet another string]
1 [%q Hello! ]
1
2
[%q Hello\ there! ] 
%q-Better escape the \- inside this string!-
1
2
3
%Q[I can put [] in here unescaped.] 
%q(I have to escape \( if I use it alone in here.) 
%Q(And the same goes for \).)
1
2
3
4
5
>> text = <<EOM 
This is the first line of text. 
This is the second line. 
Now we're done. 
EOM 

6
7
=> "This is the first line of text.\nThis is the second line.\n 
 Now we're done.\n"
1
2
3
4
>> text = <<-EOM 
The EOM doesn't have to be flush left! 
       EOM 
=> "The EOM doesn't have to be flush left!\n"
1
2
3
4
5
6
7
8
9
10
>> text = <<-'EOM' 
Single-quoted! 
Note the literal \n. 
And the literal #{2+2}. 
EOM 
=> "Single-quoted!\nNote the literal \\n.\nAnd the literal \#{2+2}.\n" 
>> puts text 
Single-quoted! 
Note the literal \n. 
And the literal #{2+2}.
1
2
3
4
a = <<EOM.to_i * 10 
5 
EOM 
puts a
1
1
2
3
4
5
array = [1,2,3, <<EOM, 4] 
This is the here-doc! 
It becomes array[3]. 
EOM 
p array
1 [1, 2, 3, "This is the here-doc!\nIt becomes array[3].\n", 4]

1
2
3
do_something_with_args(a, b, <<EOM) 
http://some_very_long_url_or_other_text_best_put_on_its_own_line 
EOM
1
2
3
4
5
6
>> string = "Ruby is a cool language." 
=> "Ruby is a cool language." 
>> string[5] 
=> "i" 
>> string[-12] 
=> "o"
1
2
>> string[5,10] 
=> "is a cool "
1
2
3
4
5
6
7
8
>> string[7..14] 
=> " a cool " 
>> string[-12..-3] 
=> "ol languag" 
>> string[-12..20] 
=> "ol langua" 
>> string[15..-1] 
=> "language."
1
2
3
4
>> string["cool lang"] 
=> "cool lang" 
>> string["very cool lang"] 
=> nil
1
2
>> string[/c[ol ]+/] 
=> "cool l"

1
2
3
4
>> string.slice!("cool ") 
=> "cool " 
>> string 
=> "Ruby is a language."
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
>> string = "Ruby is a cool language." 
=> "Ruby is a cool language." 
>> string["cool"] = "great" 
=> "great" 
>> string 
=> "Ruby is a great language." 
>> string[-1] = "!" 
=> "!" 
>> string 
 
=> "Ruby is a great language!" 
>> string[-9..-1] = "thing to learn!" 
=> "thing to learn!" 
>> string 
=> "Ruby is a great thing to learn!"
1
2
3
4
>> "a" + "b" 
=> "ab" 
>> "a" + "b" + "c" 
=> "abc"
1
2
3
4
5
6
>> str = "Hi " 
=> "Hi " 
>> str + "there."  
=> "Hi there." 
>> str 
=> "Hi "
1
2
1
2
3
4
5
6
>> str = "Hi " 
=> "Hi " 
>> str << "there." 
=> "Hi there." 
>> str 
=> "Hi there."
1

1
2
3
4
>> str = "Hi " 
=> "Hi " 
>> "#{str} there." 
=> "Hi there."
1
2
>> "The sum is #{2 + 2}." 
=> "The sum is 4."
1
2
3
4
5
6
7
8
>> "My name is #{class Person 
                   attr_accessor :name 
                 end 
                 d = Person.new 
                 d.name = "David" 
                 d.name 
                 }." 
=> "My name is David."
1
2
3
4
5
6
7
8
9
10
11
12
13
14
>> class Person 
>>   attr_accessor :name 
>>   def to_s 
>>     name 
>>   end 
>> end 
=> :to_s 
>> david = Person.new 
=> #<Person:0x00000101a73cb0> 
>> david.name = "David" 
 
=> "David" 
>> "Hello, #{david}!" 
=> "Hello, David!"
1
2
3
4
>> string.include?("Ruby") 
=> true 
>> string.include?("English") 
=> false

1
2
3
4
>> string.start_with?("Ruby") 
=> true 
>> string.end_with?("!!!") 
=> false
1
2
3
4
>> string.empty? 
=> false 
>> "".empty? 
=> true
1
2
>> string.size 
=> 24
1
2
>> string.count("a") 
=> 3
1
2
>> string.count("g-m") 
=> 5
1
2
>> string.count("A-Z") 
=> 1
1
2
>> string.count("aey. ") 
=> 10
1

1
2
3
4
>> string.count("^aey. ") 
=> 14 
>> string.count("^g-m") 
=> 19
1
2
3
4
>> string.count("ag-m") 
=> 8 
>> string.count("ag-m", "^l") 
=> 6
1
1
2
3
4
5
6
>> string.index("cool") 
=> 10 
>> string.index("l") 
=> 13 
>> string.rindex("l") 
=> 15
1
2
>> "a".ord 
=> 97
1
2
>> "abc".ord 
=> 97
1
2
>> 97.chr 
=> "a"
1
2
3
4
5
>> "a" <=> "b" 
=> -1 
>> "b" > "a" 
=> true 
>> "a" > "A" 

6
7
8
=> true 
>> "." > "," 
=> true
1
2
3
4
>> "string" == "string" 
=> true 
>> "string" == "house" 
=> false
1
2
3
4
5
6
>> "a" == "a" 
=> true 
>> "a".equal?("a") 
=> false 
>> "a".equal?(100) 
=> false
1
2
3
4
5
6
7
8
>> string = "David A. Black" 
=> "David A. Black" 
>> string.upcase 
=> "DAVID A. BLACK" 
>> string.downcase 
=> "david a. black" 
>> string.swapcase 
=> "dAVID a. bLACK"
1
2
3
4
>> string = "david" 
=> "david" 
>> string.capitalize 
=> "David"
1
2
3
4
5
6
>> string = "David A. Black" 
=> "David A. Black" 
>> string.rjust(25) 
=> "           David A. Black" 
>> string.ljust(25) 
=> "David A. Black           "

1
2
3
4
>> string.rjust(25,'.') 
=> "...........David A. Black" 
>> string.rjust(25,'><') 
=> "><><><><><>David A. Black"
1
2
>> "The middle".center(20, "*") 
=> "*****The middle*****"
1
2
>> "The middle".center(21, "*") 
=> "*****The middle******"
1
2
3
4
5
6
7
8
>> string = "   David A. Black   " 
=> "   David A. Black   " 
>> string.strip 
=> "David A. Black" 
>> string.lstrip 
=> "David A. Black   " 
>> string.rstrip 
=> "   David A. Black"
1
2
3
4
5
6
>> "David A. Black".chop 
=> "David A. Blac" 
>> "David A. Black\n".chomp 
=> "David A. Black" 
>> "David A. Black".chomp('ck') 
=> "David A. Bla"
1
2
3
4
5
6
>> string = "David A. Black" 
=> "David A. Black" 
>> string.clear 
=> "" 
>> string 
=> ""

1
2
3
4
>> string = "(to be named later)" 
=> "(to be named later)" 
>> string.replace("David A. Black") 
=> "David A. Black"
1
2
3
4
5
6
>> "David A. Black".delete("abc") 
=> "Dvid A. Blk" 
>> "David A. Black".delete("^abc") 
=> "aac" 
>> "David A. Black".delete("a-e","^c") 
=> "Dvi A. Blck"
1
2
>> "David A. Black".crypt("34") 
=> "347OEY.7YRmio"
1
2
3
4
5
6
>> "a".succ 
=> "b" 
>> "abc".succ 
=> "abd" 
>> "azz".succ 
=> "baa"
1
2
>> "100".to_i(17) 
=> 289
1
2
3
4
>> "100".oct 
=> 64 
>> "100".hex 
=> 256

1
2
3
4
5
6
7
8
9
10
>> "1.2345".to_f 
=> 1.2345 
>> "Hello".to_s 
=> "Hello" 
>> "abcde".to_sym 
=> :abcde 
>> "1.2345and some words".to_f 
=> 1.2345 
>> "just some words".to_i 
=> 0
1 puts __ENCODING__
1
1 LANG=en_US.iso885915 ruby -e 'puts __ENCODING__'
1
1 # encoding: encoding
1 # encoding: ASCII
1
2
3
4
>> str = "Test string" 
=> "Test string" 
>> str.encoding 
=> #<Encoding:UTF-8>
1
2
>> str.encode("US-ASCII") 
=> "Test string"

1
2
3
4
>> str.encode!("US-ASCII") 
=> "Test string" 
>> str.encoding 
=> #<Encoding:US-ASCII>
1
2
3
4
5
6
7
>> str = "Test string" 
=> "Test string" 
>> str.encode!("US-ASCII") 
>> str << ". Euro symbol: \u20AC" 
=> "Test string. Euro symbol: €" 
>> str.encoding 
=> #<Encoding:UTF-8>
1
1
2
3
:a 
:book 
:"Here's how to make a symbol with spaces in it."
1
2
3
4
>> "a".to_sym 
=> :a 
>> "Converting string to symbol with intern....".intern 
=> :"Converting string to symbol with intern...."
1
2
>> :a.to_s 
=> "a"
1
2
3
>> "abc".object_id 
=> 2707250 
>> "abc".object_id 

TESTS FOR SYMBOL INCLUSION ARE ALWAYS TRUE
grep  is a regular expression–based way of looking for matching
elements in an array. Why not just say this?
Because it will always be true! The very act of writing :abc  in the
include?  test puts the symbol :abc  into the symbol table, so the
test passes even if there was no previous assignment to the identier
abc .
4
5
6
7
8
=> 2704780 
>> :abc.object_id 
=> 160488 
>> :abc.object_id 
=> 160488
1 s = :x
1
2
3
4
>> Symbol.all_symbols 
=> [:inspect, :intern, :object_id, :const_missing, :method_missing, 
:method_added, :singleton_method_added, :method_removed, 
:singleton_method_removed,
1
2
3
4
5
6
7
8
>> Symbol.all_symbols.size 
=> 3118 
>> abc = 1 
=> 1 
>> Symbol.all_symbols.size 
=> 3119 
>> Symbol.all_symbols.grep(/abc/) 
=> [:abc]
1
1 >> Symbol.all_symbols.include?(:abc)

1
2
3
4
>> def abc; end 
=> :abc 
>> Symbol.all_symbols.size 
=> 3119
1
2
3
1
2
3
4
5
6
>> abc = :my_symbol 
=> :my_symbol 
>> Symbol.all_symbols.size 
=> 3020 
>> Symbol.all_symbols.grep(/my_symbol/) 
=> [:my_symbol]
1
2
attr_accessor :name 
attr_reader :age
1 "abc".send(:upcase)
1 some_object.send(method_name.to_sym)
1
2
3
4
>> d_hash = { :name => "David", :age => 55 } 
=> {:name=>"David", :age=>55} 
>> d_hash[:age] 
=> 55
1
2
3
4
>> d_hash = { "name" => "David", "age" => 55 } 
=> {"name"=>"David", "age"=>55} 
>> d_hash["name"] 
=> "David"

1 hash = { :name => "David", :age => 55 }
1 hash = { name: "David", age: 55 }
1
2
>> Symbol.instance_methods(false).sort 
=> ["===", "id2name", "inspect", "to_i", "to_int", "to_s", "to_sym"]
1
2
3
4
>> Symbol.instance_methods(false).sort 
=> [:<=>, :==, :===, :=~, :[], :capitalize, :casecmp, :downcase, :empty?, 
:encoding, :id2name, :inspect, :intern, :length, :match, :next, :size, 
:slice, :succ, :swapcase, :to_proc, :to_s, :to_sym, :upcase]
1
2
3
4
5
6
7
8
9
10
>> sym = :david 
=> :david 
>> sym.upcase 
=> :DAVID 
>> sym.succ 
=> :davie 
>> sym[2] 
=> "v" 
>> sym.casecmp(:david) 
=> 0
1
1
2
3
4
5
n = 99.6 
m = n.round 
puts m 
x = 12 
if x.zero? 
1

Figure 8.1. Numerical class hierarchy
Table 8.1. Common arithmetic expressions and their evaluative results
Expression
Result
Comments
1 + 1
2
Addition
10/5
2
Integer division
16/5
3
Integer division (no automatic oating-
point conversion)
10/3.3
3.3333333333
Floating-point division
1.2 + 3.4
4.6
Floating-point addition
-12 - -7
–5
Subtraction
10 % 3
1
Modulo (remainder)
6
7
8
9
10
  puts "x is zero" 
else 
  puts "x is not zero" 
end 
puts "The ASCII character equivalent of 97 is #{97.chr}"
2
3
1
2
3
4
>> 0x12 
=> 18 
>> 0x12 + 12 
=> 30
1
1
2
3
4
5
6
>> 012 
=> 10 
>> 012 + 12 
=> 22 
>> 012 + 0x12 
=> 28

1
2
3
4
5
6
>> "10".to_i(17) 
=> 17 
>> "12345".to_i(13) 
=> 33519 
>> "ruby".to_i(35) 
=> 1194794
1
2
3
4
5
6
>> 1.+(1) 
=> 2 
>> 12./(3) 
=> 4 
>> -12.-(-7) 
=> -5
1
2
3
4
>> require 'date' 
=> true 
>> Date.parse("April 24 1705").england.strftime("%B %d %Y") 
=> "April 13 1705"
1
2
require 'date' 
require 'time'
1
2
>> Date.today 
=> #<Date: 2013-11-02 ((2456599j,0s,0n),+0s,2299161j)
1
2
>> puts Date.today 
2013-11-02

1
2
>> puts Date.new(1959,2,1) 
1959-02-01
>> puts Date.parse("2003/6/9") 
2003-06-09
1
2
3
4
5
6
>> puts Date.parse("03/6/9") 
2003-06-09 
>> puts Date.parse("33/6/9") 
2033-06-09 
>> puts Date.parse("77/6/9") 
1977-06-09
>> puts Date.parse("November 2 2013") 
2013-11-02 
>> puts Date.parse("Nov 2 2013") 
2013-11-02 
>> puts Date.parse("2 Nov 2013") 
2013-11-02 
>> puts Date.parse("2013/11/2") 
2013-11-02
>> Time.new                                            #1 
=> 2013-11-02 12:16:21 +0000                           #1 
>> Time at(100000000)
#2
>> puts DateTime.new(2009, 1, 2, 3, 4, 5) 
2009-01-02T03:04:05+00:00 
=> nil 
>> puts DateTime.now 
2013-11-03T04:44:52-08:00 

Table 8.2. Common time and date format speci×ers
Specier
Description
%Y
Year (four digits)
%y
Year (last two digits)
=> nil 
>> puts DateTime.parse("October 23, 1973, 10:34 AM") 
1973-10-23T10:34:00+00:00
>> dt = DateTime.now 
=> #<DateTime: 2014-02-21T06:33:38-05:00 
((2456710j,41618s,552942000n),-18000s,2299161j)> 
>> dt.year 
=> 2014 
>> dt.hour 
=> 6 
>> dt.minute 
=> 33 
>> dt.second 
=> 38 
>> t = Time.now 
=> 2014-02-21 06:33:50 -0500 
>> t.month 
=> 2 
>> t.sec 
=> 50 
>> d = Date.today 
=> #<Date: 2014-02-21 ((2456710j,0s,0n),+0s,2299161j)> 
>> d.day 
=> 21
>> d.monday? 
=> false 
>> dt.friday? 
=> true
>> t = Time.now 
=> 2014-02-21 06:37:59 -0500 
>> t.strftime("%m-%d-%y") 
=> "02-21-14"

Specier
Description
%b, %B
Short month, full month
%m
Month (number)
%d
Day of month (left-padded with zeros)
%e
Day of month (left-padded with blanks)
%a, %A
Short day name, full day name
%H, %I
Hour (24-hour clock), hour (12-hour clock)
%M
Minute
%S
Second
%c
Equivalent to "%a %b %d %H:%M:%S %Y"
%x
Equivalent to "%m/%d/%y"
>> t.strftime("Today is %x") 
=> "Today is 11/03/13" 
>> t.strftime("Otherwise known as %d-%b-%y") 
=> "Otherwise known as 03-Nov-13" 
>> t.strftime("Or even day %e of %B, %Y.") 
=> "Or even day  3 of November, 2013." 
>> t.strftime("The time is %H:%m.") 
=> "The time is 04:11."
>> Date.today.rfc2822 
=> "Sun, 3 Nov 2013 00:00:00 +0000" 
>> DateTime.now.httpdate 
=> "Sun, 03 Nov 2013 12:49:48 GMT"
>> t = Time.now 
=> 2013-11-03 04:50:49 -0800 
>> t - 20 
=> 2013-11-03 04:50:29 -0800 
>> t + 20 
=> 2013-11-03 04:51:09 -0800
>> dt = DateTime.now 
=> #<DateTime: 2013-11-03T04:51:05-08:00 ... > 
>> puts dt + 100 
2014-02-11T04:51:05-08:00 
>> puts dt >> 3 
2014-02-03T04:51:05-08:00 
>> puts dt << 10 
2013-01-03T04:51:05-08:00

>> d = Date.today 
=> #<Date: 2013-11-03 ((2456600j,0s,0n),+0s,2299161j)> 
>> puts d.next 
2013-11-04 
 
>> puts d.next_year 
2014-11-03 
>> puts d.next_month(3) 
2014-02-03 
>> puts d.prev_day(10) 
2013-10-24
>> d = Date.today 
=> #<Date: 2013-11-03 ((2456600j,0s,0n),+0s,2299161j)> 
>> next_week = d + 7 
=> #<Date: 2013-11-10 ((2456607j,0s,0n),+0s,2299161j)> 
>> d.upto(next_week) {|date| puts "#{date} is a #{date.strftime("%A")}" } 
2013-11-03 is a Sunday 
2013-11-04 is a Monday 
2013-11-05 is a Tuesday 
2013-11-06 is a Wednesday 
2013-11-07 is a Thursday 
2013-11-08 is a Friday 
2013-11-09 is a Saturday 
2013-11-10 is a Sunday

CHAPTER 9
1
2
3
4
array = ["ruby", "diamond", "emerald"] 
hash = { 0 => "ruby", 1 => "diamond", 2 => "emerald" } 
puts array[0]    # ruby 
puts hash[0]     # ruby
1
2
3
4
hash = { "red" => "ruby", "white" => "diamond", "green" => "emerald" } 
hash.each.with_index {|(key,value),i| 
  puts "Pair #{i} is: #{key}/#{value}" 
}
1
2
3
Pair 0 is: red/ruby 
Pair 1 is: white/diamond 
Pair 2 is: green/emerald
1 a = Array.new
1
2
3
4
>> Array.new(3) 
=> [nil, nil, nil] 
>> Array.new(3,"abc") 
=> ["abc", "abc", "abc"]
1
2
1
2
3
4
>> n = 0 
=> 0 
>> Array.new(3) { n += 1; n * 10 } 
=> [10, 20, 30]
1
2

1 a = []
1 a = [1,2,"three",4, []]
1 [1,2,3][1]
1
1
2
3
4
5
6
7
8
9
10
11
12
13
=> "A string" 
>> string.respond_to?(:to_ary) 
=> false 
>> string.respond_to?(:to_a) 
=> false 
>> Array(string) 
=> ["A string"] 
>> def string.to_a 
>>   split(//) 
>> end 
=> nil 
>> Array(string) 
=> ["A", " ", "s", "t", "r", "i", "n", "g"]
1
2
1
2
>> %w{ David A. Black } 
=> ["David", "A.", "Black"]
1
2
>> %w{ David\ A.\ Black is a Rubyist. } 
=> ["David A. Black", "is", "a", "Rubyist."]

THE TRY_CONVERT FAMILY OF METHODS
Each of several built-in classes in Ruby has a class method called
try_convert , which always takes one argument. try_convert
looks for a conversion method on the argument object. If the method
exists, it gets called; if not, try_convert  returns nil . If the
conversion method returns an object of a class other than the class to
which conversion is being attempted, it’s a fatal error ( TypeError ).
The classes implementing try_convert  (and the names of the
required conversion methods) are Array  ( to_ary ), Hash
( to_hash ), IO  ( to_io ), Regexp  ( to_regexp ), and String
( to_str ). Here’s an example of an object putting
Array.try_convert  through its paces. (The other try_convert
methods work similarly.)
1
2
>> %W{ David is #{2014 - 1959} years old. } 
=> ["David", "is", "55", "years", "old."]
1
2
3
4
5
6
>> %i{ a b c } 
=> [:a, :b, :c] 
>> d = "David" 
=> "David" 
>> %I{"#{d}"} 
=> [:"\"David\""]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
>> obj = Object.new 
=> #<Object:0x000001028033a8> 
>> Array.try_convert(obj) 
=> nil 
>> def obj.to_ary 
>>   [1,2,3] 
>> end 
 
=> :to_ary 
>> Array.try_convert(obj) 
=> [1, 2, 3] 
>> def obj.to_ary 
>>   "Not an array!" 
>> end 
=> :to_ary 
>> Array.try_convert(obj) 
TypeError: can't convert Object to Array (Object#to_ary gives Str

1
2
a = [] 
a[0] = "first"
1
2
a = [1,2,3,4,5] 
p a[2]
1
2
3
4
5
6
7
8
>> a = ["red","orange","yellow","purple","gray","indigo","violet"] 
=> ["red", "orange", "yellow", "purple", "gray", "indigo", "violet"] 
>> a[3,2] 
=> ["purple", "gray"] 
>> a[3,2] = "green", "blue"                                             #2 
=> ["green", "blue"] 
>> a 
=> ["red", "orange", "yellow", "green", "blue", "indigo", "violet"]
1
3
4
1
2
3
array = ["the", "dog", "ate", "the", "cat"] 
articles = array.values_at(0,3) 
p articles
1
1
2
a = [1,2,3,4] 
a.unshift(0)
1
2
a = [1,2,3,4] 
a.push(5)
1
2
a = [1,2,3,4] 
a << 5

1
2
a = [1,2,3,4,5] 
a.push(6,7,8)
1
2
3
4
5
6
7
8
9
10
11
12
13
a = [1,2,3,4,5] 
print "The original array: " 
p a 
popped = a.pop 
print "The popped item: " 
puts popped 
print "The new state of the array: " 
p a 
shifted = a.shift 
print "The shifted item: " 
puts shifted 
print "The new state of the array: " 
p a
1
2
3
4
5
The original array: [1, 2, 3, 4, 5] 
The popped item: 5 
The new state of the array: [1, 2, 3, 4] 
The shifted item: 1 
The new state of the array: [2, 3, 4]
1
2
3
4
5
6
7
8
9
10
>> a = %w{ one two three four five } 
=> ["one", "two", "three", "four", "five"] 
>> a.pop(2) 
=> ["four", "five"] 
>> a 
=> ["one", "two", "three"] 
>> a.shift(2) 
=> ["one", "two"] 
>> a 
=> ["three"]
1
2
>> [1,2,3].concat([4,5,6]) 
=> [1, 2, 3, 4, 5, 6]

1
2
3
4
5
6
>> a = [1,2,3] 
=> [1, 2, 3] 
>> b = a + [4,5,6] 
=> [1, 2, 3, 4, 5, 6] 
>> a 
=> [1, 2, 3]
1
1
2
3
4
5
6
>> a = [1,2,3] 
=> [1, 2, 3] 
>> a.replace([4,5,6]) 
=> [4, 5, 6] 
>> a 
=> [4, 5, 6]
1
1
2
a = [1,2,3] 
a = [4,5,6]
1
2
3
4
5
6
7
8
9
10
11
12
>> a = [1,2,3] 
=> [1, 2, 3] 
>> b = a 
=> [1, 2, 3] 
>> a.replace([4,5,6]) 
=> [4, 5, 6] 
>> b 
=> [4, 5, 6] 
>> a = [7,8,9] 
=> [7, 8, 9] 
>> b 
=> [4, 5, 6]
1
2
3
4
1
2
3
4
5
6
7
8
>> array = [1,2,[3,4,[5],[6,[7,8]]]] 
=> [1, 2, [3, 4, [5], [6, [7, 8]]]] 
>> array.flatten 
=> [1, 2, 3, 4, 5, 6, 7, 8] 
>> array.flatten(1) 
=> [1, 2, 3, 4, [5], [6, [7, 8]]] 
>> array.flatten(2) 
=> [1, 2, 3, 4, 5, 6, [7, 8]]
1
2
3

Table 9.1. Summary of common array query methods
1
2
>>[1,2,3,4].reverse 
=>  [4, 3, 2, 1]
1
2
>> ["abc", "def", 123].join 
=> "abcdef123"
1
2
>> ["abc", "def", 123].join(", ") 
=> "abc, def, 123"
1
2
3
4
>> a = %w{ one two three } 
=> ["one", "two", "three"] 
>> a * "-" 
=> "one-two-three"
1
2
>> [1,2,3,1,4,3,5,1].uniq 
=> [1, 2, 3, 4, 5]
1
2
3
4
5
>> zip_codes = ["06511", "08902", "08902", nil, "10027", 
"08902", nil, "06511"] 
=> ["06511", "08902", "08902", nil, "10027", "08902", nil, "06511"] 
>> zip_codes.compact 
=> ["06511", "08902", "08902", "10027", "08902", "06511"]

Method name/Sample call
Meaning
Method name/Sample call
Meaning
a.size (synonym: length)
Number of elements in the array
a.empty?
True if a is an empty array; false if it has
any elements
a.include?(item)
True if the array includes items; false
otherwise
a.count(item)
Number of occurrences of item in array
a.rst(n=1)
First n elements of array
a.last(n=1)
Last n elements of array
a.sample(n=1)
n random elements from array
1
2
3
4
5
6
7
8
state_hash = { "Connecticut" => "CT", 
               "Delaware"    => "DE", 
               "New Jersey"  => "NJ", 
               "Virginia"    => "VA" } 
print "Enter the name of a state: " 
state = gets.chomp 
abbr = state_hash[state] 
puts "The abbreviation is #{abbr}."
1 h = {}
1
2
>> Hash["Connecticut", "CT", "Delaware", "DE" ] 
=> {"Connecticut"=>"CT", "Delaware"=>"DE"}
1
2
>> Hash[ [[1,2], [3,4], [5,6]] ] 
=> {1=>2, 3=>4, 5=>6}
1 state_hash["New York"] = "NY"

1 state_hash.[]=("New York", "NY")
1 state_hash.store("New York", "NY")
1
2
3
4
h = Hash.new 
h["a"] = 1 
h["a"] = 2 
puts h["a"]
1
1 conn_abbrev = state_hash["Connecticut"]
1 conn_abbrev = state_hash.fetch("Connecticut")
1 state_hash.fetch("Nebraska", "Unknown state")
1 two_states = state_hash.values_at("New Jersey","Delaware")
1
2
3
4
>> h = Hash.new 
=> {} 
>> h["no such key!"] 
=> nil

1
2
3
4
>> h = Hash.new(0) 
=> {} 
>> h["no such key!"] 
=> 0
1
2
>> h 
=> {}
1 h = Hash.new {|hash,key| hash[key] = 0 }
1
2
3
4
>> h["new key!"] 
=> 0 
>> h 
=> {"new key!"=>0}
1
2
1
2
3
4
5
h1 = {"Smith" => "John", 
      "Jones" => "Jane" } 
h2 = {"Smith" => "Jim" } 
h1.update(h2) 
puts h1["Smith"]
1
1
2
3
4
5
h1 = {"Smith" => "John", 
      "Jones" => "Jane" } 
h2 = {"Smith" => "Jim" } 
h3 = h1.merge(h2) 
p h1["Smith"]
1
1 {"Smith"=>"Jim", "Jones"=>"Jane"}

Table 9.2. Common hash query methods and their meanings
1
2
3
4
>> h = Hash[1,2,3,4,5,6] 
=> {1=>2, 3=>4, 5=>6} 
>> h.select {|k,v| k > 1 } 
=> {3=>4, 5=>6}
1
2
>> h.reject {|k,v| k > 1 } 
=> {1=>2}
1
2
3
4
>> h = { 1 => "one", 2 => "two" } 
=> {1=>"one", 2=>"two"} 
>> h.invert 
=> {"two"=>2, "one"=>1}
1
2
3
4
>> h = { 1 => "one", 2 => "more than 1", 3 => "more than 1" } 
=> {1=>"one", 2=>"more than 1", 3=>"more than 1"} 
>> h.invert 
=> {"one"=>1, "more than 1"=>3}
1
2
>> {1 => "one", 2 => "two" }.clear 
=> {}
1
2
>> { 1 => "one", 2 => "two" }.replace({ 10 => "ten", 20 => "twenty"}) 
=> {10 => "ten", 20 => "twenty"}

HASHES AS FIRST ARGUMENTS
In addition to learning about the special syntax available to you for
using hashes as nal method arguments without curly braces, it’s
worth noting a pitfall of using a hash as the rst argument to a
method. The rule in this case is that you must not only put curly braces
around the hash but also put the entire argument list in parentheses. If
you don’t, Ruby will think your hash is a code block. In other words,
when you do this
Method name/Sample call
Meaning
Method name/Sample call
Meaning
h.has_key?(1)
True if h has the key 1
h.include?(1)
Synonym for has_key?
h.key?(1)
Synonym for has_key?
h.member?(1)
Synonym for has_key?
h.has_value?("three")
True if any value in h is "three"
h.value?("three")
Synonym for has_value?
h.empty?
True if h has no key/value pairs
h.size
Number of key/value pairs in h
1
2
3
4
add_to_city_database("New York City", 
  state: "New York", 
  population: 7000000, 
  nickname: "Big Apple")
1
2
3
4
5
6
def add_to_city_database(name, info) 
  c = City.new 
  c.name = name 
  c.state = info[:state] 
  c.population = info[:population] 
  # etc.
1 my_method { "NY" => "New York" }, 100, "another argument"

Ruby interprets the expression in braces as a block. If you want to send
a hash along as an argument in this position, you have to use
parentheses around the entire argument list to make it clear that the
curly braces are hash-related and not block-related.
1
2
3
4
5
6
7
8
>> def m(a:, b:) 
>>   p a,b 
>> end 
=> :m 
>> m(a: 1, b: 2) 
1 
2 
=> [1, 2]
1
2
3
4
>> m 
ArgumentError: missing keywords: a, b 
>> m(a: 1) 
ArgumentError: missing keyword: b
1
2
3
4
5
6
7
8
9
10
11
12
>> def m(a: 1, b: 2) 
>>   p a,b 
>> end 
=> :m 
>> m 
1 
2 
=> [1, 2] 
>> m(a:10) 
10 
2 
=> [10, 2]
1
2
1
2
3
4
5
6
7
8
9
10
>> def m(a: 1, b: 2, **c) 
>>   p a,b,c 
>> end 
 
=> :m 
>> m(x: 1, y: 2) 
1 
2 
{:x=>1, :y=>2} 
=> [1, 2, {:x=>1, :y=>2}]

1
2
3
4
5
6
7
8
9
10
11
12
>> def m(x, y, *z, a: 1, b:, **c, &block) 
>>   p x,y,z,a,b,c 
>> end 
=> :m 
>> m(1,2,3,4,5,b:10,p:20,q:30) 
1 
2 
[3, 4, 5] 
1 
10 
{:p=>20, :q=>30} 
=> [1, 2, [3, 4, 5], 1, 10, {:p=>20, :q=>30}]
1
2
>> r = Range.new(1,100) 
=> 1..100
1
2
>> r = 1..100 
=> 1..100
1
2
>> r = 1...100 
=> 1...100
1
2
3
4
>> Range.new(1,100) 
=> 1..100 
>> Range.new(1,100,true) 
=> 1...100
1 1..100

1 1...100
1
2
3
4
5
6
>> r = 1..10 
=> 1..10 
>> r.begin 
=> 1 
>> r.end 
=> 10
1
2
>> r.exclude_end? 
=> false
1
2
3
4
5
6
7
8
>> r = "a".."z" 
=> "a".."z" 
>> r.cover?("a") 
=> true 
>> r.cover?("abc") 
=> true 
>> r.cover?("A") 
=> false
1
2
3
1
2
>> r.cover?([]) 
=> false
1
2
3
4
>> r.include?("a") 
=> true 
>> r.include?("abc") 
=> false
1
2
>> r = 1.0..2.0 
=> 1.0..2.0 

ARE THERE BACKWARD RANGES?
The anticlimactic answer to the question of backward ranges is this:
yes and no. You can create a backward range, but it won’t do what you
probably want it to:
The range happily performs its usual inclusion test for you. The test
calculates whether the candidate for inclusion is greater than the start
point of the range and less than the end point. Because 50 is neither
greater than 100 nor less than 1, the test fails. And it fails silently; this
is a logic error, not a fatal syntax or runtime error.
Backward ranges do show up in one particular set of use cases: as index
arguments to strings and arrays. They typically take the form of a
positive start point and a negative end point, with the negative end
point counting in from the right:
You can even use an exclusive backward range:
3
4
>> r.include?(1.5) 
=> true
1
2
3
4
>> r = 100...1 
=> 100...1 
>> r.include?(50) 
=> false
1
2
3
4
>> "This is a sample string"[10..-5] 
=> "sample st" 
>> ['a','b','c','d'][0..-2] 
=> ["a", "b", "c"]
1
2
>> ['a','b','c','d'][0...-2] 
=> ["a", "b"]

In these cases, what doesn’t work (at least, in the way you might have
expected) in a range on its own does work when applied to a string or
an array.
1 require 'set'
1
2
3
4
5
6
7
>> new_england = ["Connecticut", "Maine", "Massachusetts", 
                  "New Hampshire", "Rhode Island", "Vermont"] 
=> ["Connecticut", "Maine", "Massachusetts", 
    "New Hampshire","Rhode Island", "Vermont"] 
>> state_set = Set.new(new_england) 
=> #<Set: {"Connecticut", "Maine", "Massachusetts", 
           "New Hampshire", "Rhode Island", "Vermont"}>
1
2
3
4
>> names = ["David", "Yukihiro", "Chad", "Amy"] 
=> ["David", "Yukihiro", "Chad", "Amy"] 
>> name_set = Set.new(names) {|name| name.upcase } 
=> #<Set: {"AMY", "YUKIHIRO", "CHAD", "DAVID"}>
1
2
3
4
>> tri_state = Set.new(["New Jersey", "New York"]) 
=> #<Set: {"New Jersey", "New York"}> 
>> tri_state << "Connecticut" 
=> #<Set: {"New Jersey", "New York", "Connecticut"}>
1
2
1
2
>> tri_state << "Connecticut" 
=> #<Set: {"New Jersey", "New York", "Connecticut"}>
1
1
2
3
4
>> tri_state << "Pennsylvania" 
=> #<Set: {"New Jersey", "New York", "Connecticut", "Pennsylvania"}> 
>> tri_state.delete("Connecticut") 
=> #<Set: {"New Jersey", "New York", "Pennsylvania"}>

1
2
>> tri_state.add?("Pennsylvania") 
=> nil
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
>> tri_state = Set.new(["Connecticut", "New Jersey", "New York"]) 
=> #<Set: {"Connecticut", "New Jersey", "New York"}> 
# Subtraction (difference/-) 
>> state_set - tri_state 
=> #<Set: {"Maine", "Massachusetts", "New Hampshire", "Rhode Island", 
"Vermont"}> 
# Addition (union/+/|) 
>> state_set + tri_state 
=> #<Set: {"Connecticut", "Maine", "Massachusetts", "New Hampshire", 
"Rhode Island", "Vermont", "New Jersey", "New York"}> 
# Intersection (&) 
>> state_set & tri_state 
=> #<Set: {"Connecticut"}> 
>> state_set | tri_state 
=> #<Set: {"Connecticut", "Maine", "Massachusetts", "New Hampshire", 
"Rhode Island", "Vermont", "New Jersey", "New York"}>
1
2
3
>> state_set ^ tri_state 
=> #<Set: {"New Jersey", "New York", "Maine", "Massachusetts", 
   "New Hampshire", "Rhode Island", "Vermont"}>
1
2
3
4
5
6
7
8
>> tri_state = Set.new(["Connecticut", "New Jersey"]) 
=> #<Set: {"Connecticut", "New Jersey"}> 
>> tri_state.object_id 
=> 2703420 
>> tri_state.merge(["New York"]) 
=> #<Set: {"Connecticut", "New Jersey", "New York"}> 
>> tri_state.object_id 
=> 2703420
1
2
3
4
>> s = Set.new([1,2,3]) 
=> #<Set: {1, 2, 3}> 
>> s.merge({ "New Jersey" => "NJ", "Maine" => "ME" }) 
=> #<Set: {1, 2, 3, ["New Jersey", "NJ"], ["Maine", "ME"]}>

1
2
3
4
5
6
>> state_set = Set.new(["New York", "New Jersey"]) 
=> #<Set: {"New York", "New Jersey"}> 
>> state_hash = { "Maine" => "ME", "Vermont" => "VT" } 
=> {"Maine"=>"ME", "Vermont"=>"VT"} 
>> state_set.merge(state_hash.keys) 
=> #<Set: {"New York", "New Jersey", "Maine", "Vermont"}>
1
2
3
4
5
6
7
8
>> small_states = Set.new(["Connecticut", "Delaware", "Rhode Island"]) 
=> #<Set: {"Connecticut", "Delaware", "Rhode Island"}> 
>> tiny_states = Set.new(["Delaware", "Rhode Island"]) 
=> #<Set: {"Delaware", "Rhode Island"}> 
>> tiny_states.subset?(small_states) 
=> true 
>> small_states.superset?(tiny_states) 
=> true

CHAPTER 10
1
2
3
class C 
  include Enumerable 
end
1
2
3
4
5
6
class C 
  include Enumerable 
  def each 
    # relevant code here 
  end 
end
Listing 10.1. An Enumerable  class and its deployment of the each  method
1
2
3
4
5
6
7
8
9
10
11
12
class Rainbow 
  include Enumerable 
  def each 
    yield "red" 
    yield "orange" 
    yield "yellow" 
    yield "green" 
    yield "blue" 
    yield "indigo" 
    yield "violet" 
  end 
end
1
2
3
4
r = Rainbow.new 
r.each do |color| 
  puts "Next color: #{color}" 
end
1
2
3
4
Next color: red 
Next color: orange 
Next color: yellow 
Next color: green 

5
6
7
Next color: blue 
Next color: indigo 
Next color: violet
1
2
3
r = Rainbow.new 
y_color = r.find {|color| color.start_with?('y') } 
puts "First color starting with 'y' is #{y_color}."
1
1
2
3
4
5
6
7
8
>> Enumerable.instance_methods(false).sort 
=> [:all?, :any?, :chunk, :collect, :collect_concat, :count, :cycle, :detect, 
:drop, :drop_while, :each_cons, :each_entry, :each_slice, :each_with_index, 
:each_with_object, :entries, :find, :find_all, :find_index, :first, 
:flat_map, :grep, :group_by, :include?, :inject, :lazy, :map, :max, :max_by, 
:member?, :min, :min_by, :minmax, :minmax_by, :none?, :one?, :partition, 
:reduce, :reject, :reverse_each, :select, :slice_before, :sort, :sort_by, 
:take, :take_while, :to_a, :to_h, :zip]
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
# Does the array include Louisiana? 
>> states.include?("Louisiana") 
=> true 
# Do all states include a space? 
>> states.all? {|state| state =~ / / } 
=> false 
 
# Does any state include a space? 
>> states.any? {|state| state =~ / / } 
=> true 
# Is there one, and only one, state with "West" in its name? 
>> states.one? {|state| state =~ /West/ } 
=> true 
# Are there no states with "East" in their names? 
>> states.none? {|state| state =~ /East/ } 
=> true
1
2
3
4
5
6
7
8
# Does the hash include Louisiana? 
>> states.include?("Louisiana") 
=> true 
# Do all states include a space? 
>> states.all? {|state, abbr| state =~ / / } 
=> false 
# Is there one, and only one, state with "West" in its name? 
1
2

HASHES ITERATE WITH TWO-ELEMENT ARRAYS
When you iterate through a hash with each  or any other built-in
iterator, the hash is yielded to your code block one key/value pair at a
time—and the pairs are two-element arrays. You can, if you wish,
provide just one block parameter and capture the whole little array:
In such a case, you’ll nd the key at pair[0]  and the value at
pair[1] . Normally, it makes more sense to grab the key and value in
separate block parameters. But all that’s happening is that the two are
wrapped up in a two-element array, and that array is yielded. If you
want to operate on the data in that form, you may.
9 >> states.one? {|state, abbr| state =~ /West/ } 
=> true
1
2
3
# Do all states include a space? 
>> states.keys.all? {|state, abbr| state =~ / / } 
=> false
1 hash.each {|pair| ... }
1
2
3
4
5
6
7
8
9
10
11
12
13
14
>> r = Range.new(1, 10) 
=> 1..10 
>> r.one? {|n| n == 5 } 
=> true 
>> r.none? {|n| n % 2 == 0 } 
=> false 
>> r = Range.new(1.0, 10.0) 
=> 1.0..10.0 
>> r.one? {|n| n == 5 } 
TypeError: can't iterate from Float 
>> r = Range.new(1, 10.3) 
=> 1..10.3 
>> r.any? {|n| n > 5 } 
=> true
1
2
3
4

THE DOMINANCE OF THE ARRAY
Arrays serve generically as the containers for most of the results that
come back from enumerable selecting and ltering operations,
whether or not the object being selected from or ltered is an array.
There are some exceptions to this quasi-rule, but it holds true widely.
The plainest way to see it is by creating an enumerable class of your
own and watching what you get back from your select queries. Look
again at the Rainbow  class in listing 10.1. Now look at what you get
back when you perform some queries:
In every case, the result set comes back in an array.
1
2
>> [1,2,3,4,5,6,7,8,9,10].find {|n| n > 5 } 
=> 6
1 [1,2,3,nil,4,5,6].find {|n| n.nil? }
1
2
3
4
>> failure = lambda { 11 } 
=> #<Proc:0x434810@(irb):6 (lambda)> 
>> over_ten = [1,2,3,4,5,6].find(failure) {|n| n > 10 } 
=> 11
1
1
2
3
4
5
6
7
8
>> r = Rainbow.new 
=> #<Rainbow:0x45b708> 
>> r.select {|color| color.size == 6 } 
=> ["orange", "yellow", "indigo", "violet"] 
>> r.map {|color| color[0,3] } 
=> ["red", "ora", "yel", "gre", "blu", "ind", "vio"] 
>> r.drop_while {|color| color.size < 5 } 
=> ["orange", "yellow", "green", "blue", "indigo", "violet"]

The array is the most generic container and therefore the logical
candidate for the role of universal result format. A few exceptions
arise. A hash returns a hash from a select  or reject  operation.
Sets return arrays from map , but you can call map!  on a set to
change the elements of the set in place. For the most part, though,
enumerable selection and ltering operations come back to you inside
arrays.
1
2
3
4
5
6
>> a = [1,2,3,4,5,6,7,8,9,10] 
=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
>> a.find_all {|item| item > 5 } 
=> [6, 7, 8, 9, 10] 
>> a.select {|item| item > 100 } 
=> []
1
2
1
2
>> a.reject {|item| item > 5 } 
=> [1, 2, 3, 4, 5]
1
2
3
4
>> colors = %w{ red orange yellow green blue indigo violet } 
=> ["red", "orange", "yellow", "green", "blue", "indigo", "violet"] 
>> colors.grep(/o/) 
=> ["orange", "yellow", "indigo", "violet"]
1
2
3
4
5
6
>> miscellany = [75, "hello", 10...20, "goodbye"] 
=> [75, "hello", 10...20, "goodbye"] 
>> miscellany.grep(String) 
=> ["hello", "goodbye"] 
>> miscellany.grep(50..100) 
=> [75]
1
2
1 enumerable.select {|element| expression === element }

1
2
3
4
>> colors = %w{ red orange yellow green blue indigo violet } 
=> ["red", "orange", "yellow", "green", "blue", "indigo", "violet"] 
>> colors.grep(/o/) {|color| color.capitalize } 
=> ["Orange", "Yellow", "Indigo", "Violet"]
1 enumerable.grep(expression) {|item| ... }
1 enumerable.select {|item| expression === item}.map {|item| ... }
1
2
3
4
5
>> colors = %w{ red orange yellow green blue indigo violet } 
=> ["red", "orange", "yellow", "green", "blue", "indigo", "violet"] 
>> colors.group_by {|color| color.size } 
=> {3=>["red"], 6=>["orange", "yellow", "indigo", "violet"], 
    5=>["green"], 4=>["blue"]}
1
2
3
4
5
6
7
8
9
class Person 
  attr_accessor :age 
  def initialize(options) 
    self.age = options[:age] 
  end 
  def teenager? 
    (13..19) === age 
  end 
end
1 people = 10.step(25,3).map {|i| Person.new(:age => i) }
1 teens =  people.partition {|person| person.teenager? }

1
2
3
[[#<Person:0x000001019d1a50 @age=13>, #<Person:0x000001019d19d8 @age=16>, 
#<Person:0x000001019d1988 @age=19>], [#<Person:0x000001019d1ac8 @age=10>, 
#<Person:0x000001019d1910 @age=22>, #<Person:0x000001019d1898 @age=25>]]
1 puts "#{teens[0].size} teens; #{teens[1].size} non-teens"
1 3 teens; 3 non-teens
1
2
3
4
5
6
>> [1,2,3,4].first 
=> 1 
>> (1..10).first 
=> 1 
>> {1 => 2, "one" => "two"}.first 
=> [1, 2]
1
2
3
4
5
6
7
8
9
10
>> hash = { 3 => "three", 1 => "one", 2 => "two" } 
=> {3=>"three", 1=>"one", 2=>"two"} 
>> hash.first 
=> [3, "three"] 
>> hash[3] = "trois" 
=> "trois" 
>> hash.first 
=> [3, "trois"] 
 
#1:- first means first inserted
1
2
1
2
3
4
5
6
7
8
class Die 
  include Enumerable 
  def each 
    loop do 
      yield rand(6) + 1 
    end 
  end 
end

1
2
3
4
5
6
7
8
9
puts "Welcome to 'You Win If You Roll a 6'!" 
d = Die.new 
d.each do |roll| 
  puts "You rolled a #{roll}." 
  if roll == 6 
    puts "You win!" 
    break 
  end 
end
1
2
3
4
5
6
7
Welcome to 'You Win If You Roll a 6' 
You rolled a 3. 
You rolled a 2. 
You rolled a 2. 
You rolled a 1. 
You rolled a 6. 
You win!
1
2
3
4
5
6
>> states = %w{ NJ NY CT MA VT FL } 
=> ["NJ", "NY", "CT", "MA", "VT", "FL"] 
>> states.take(2) 
=> ["NJ", "NY"] 
>> states.drop(2) 
=> ["CT", "MA", "VT", "FL"]
1
2
1
2
3
4
>> states.take_while {|s| /N/.match(s) } 
=> ["NJ", "NY"] 
>> states.drop_while {|s| /N/.match(s) } 
=> ["CT", "MA", "VT", "FL"]
1
2
3
4
>> [1,3,5,4,2].max 
=> 5 
>> %w{ Ruby C APL Perl Smalltalk }.min 
=> "APL"

1
2
>> %w{ Ruby C APL Perl Smalltalk }.min {|a,b| a.size <=> b.size } 
=> "C"
1
2
>> %w{ Ruby C APL Perl Smalltalk }.min_by {|lang| lang.size } 
=> "C"
1
1
2
3
4
>> %w{ Ruby C APL Perl Smalltalk }.minmax 
=> ["APL", "Smalltalk"] 
>> %w{ Ruby C APL Perl Smalltalk }.minmax_by {|lang| lang.size } 
=> ["C", "Smalltalk"]
1
2
die = Die.new 
puts die.max
1
2
3
4
5
6
7
8
9
>> state_hash = {"New York" => "NY", "Maine" => "ME",  
"Alaska" => "AK", "Alabama" => "AL" } 
=> {"New York"=>"NY", "Maine"=>"ME", "Alaska"=>"AK", "Alabama"=>"AL"} 
>> state_hash.min 
=> ["Alabama", "AL"] 
>> state_hash.min_by {|name, abbr| name } 
=> ["Alabama", "AL"] 
>> state_hash.min_by {|name, abbr| abbr } 
=> ["Alaska", "AK"]
1
2
3
1 [1,2,3].reverse_each {|e| puts e * 10 }
1
2
30 
20 

3 10
1
2
3
4
5
6
7
8
9
10
11
>> names = ["George Washington", "John Adams", "Thomas Jefferson",  
"James Madison"] 
=> ["George Washington", "John Adams", "Thomas Jefferson",  
"James Madison"] 
>> names.each_with_index do |pres, i| 
?>   puts "#{i+1}. #{pres}" 
>> end 
1. George Washington 
2. John Adams 
3. Thomas Jefferson 
4. James Madison
1
1
2
3
4
5
>> %w{a b c }.each_index {|i| puts i } 
0 
1 
2 
=> ["a", "b", "c"]
1
2
3
4
5
6
7
8
9
10
>> letters = {"a" => "ay", "b" => "bee", "c" => "see" } 
=> {"a"=>"ay", "b"=>"bee", "c"=>"see"} 
>> letters.each_with_index {|(key,value),i| puts i } 
0 
1 
2 
=> {"a"=>"ay", "b"=>"bee", "c"=>"see"} 
>> letters.each_index {|(key,value),i| puts i } 
NoMethodError: undefined method `each_index' for {"a"=>"ay", 
"b"=>"bee", "c"=>"see"}:Hash
1
2
3
4
5
6
>> array = %w{ red yellow blue } 
=> ["red", "yellow", "blue"] 
 
>> array.each.with_index do |color, i| 
?>   puts "Color number #{i} is #{color}." 
>> end

1
2
3
>> names.each.with_index(1) do |pres, i| 
?>   puts "#{i} #{pres}" 
>> end
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
>> array = [1,2,3,4,5,6,7,8,9,10] 
=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
>> array.each_slice(3) {|slice| p slice } 
[1, 2, 3] 
[4, 5, 6] 
[7, 8, 9] 
[10] 
=> nil 
>> array.each_cons(3) {|cons| p cons } 
[1, 2, 3] 
[2, 3, 4] 
[3, 4, 5] 
[4, 5, 6] 
[5, 6, 7] 
[6, 7, 8] 
[7, 8, 9] 
[8, 9, 10] 
=> nil
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
class PlayingCard 
  SUITS = %w{ clubs diamonds hearts spades } 
  RANKS = %w{ 2 3 4 5 6 7 8 9 10 J Q K A } 
  class Deck 
    attr_reader :cards 
    def initialize(n=1) 
      @cards = [] 
      SUITS.cycle(n) do |s| 
        RANKS.cycle(1) do |r| 
          @cards << "#{r} of #{s}" 
        End    
      end 
    end 
  end 
end
1
2
3
4
5
6
1 deck = PlayingCard::Deck.new(2)
1
2
>> [1,2,3,4].inject(0) {|acc,n| acc + n } 
=> 10

USING A SYMBOL ARGUMENT AS A BLOCK
You can use a symbol such as :upcase  with a &  in front of it in
method-argument position, and the result will be the same as if you
used a code block that called the method with the same name as the
symbol on each element. Thus you could rewrite the block in the last
example, which calls upcase  on each element, like this:
You’ll see an in-depth explanation of this idiom when you read about
callable objects in chapter 14.
1
2
3
4
5
6
7
8
>> [1,2,3,4].inject do |acc,n| 
     puts "adding #{acc} and #{n}...#{acc+n}" 
     acc + n 
   end 
adding 1 and 2...3 
adding 3 and 3...6 
adding 6 and 4...10 
=> 10
1
2
3
4
>> names = %w{ David Yukihiro Chad Amy } 
=> ["David", "Yukihiro", "Chad", "Amy"] 
>> names.map {|name| name.upcase } 
=> ["DAVID", "YUKIHIRO", "CHAD", "AMY"]
1 names.map(&:upcase)
1 result = array.each {|x| # code here... }

1
2
result = array 
array.each {|x| ... }
1 result = array.map {|x| # code here... }
1
2
array = [1,2,3,4,5] 
result = array.map {|n| puts n * 100 }
1 [nil, nil, nil, nil, nil]
1 names = %w{ David Yukihiro Chad Amy }
1 names.map!(&:upcase)
1
1
2
str = "abcde" 
str.each_byte {|b| p b }
1
2
3
4
5
97 
98 
99 
100 
101

1
2
str = "abcde" 
str.each_char {|c| p c }
1
2
3
4
5
"a" 
"b" 
"c" 
"d" 
"e"
1
2
3
4
5
6
7
>> str = "100\u20ac" 
=> "100€" 
>> str.each_codepoint {|cp| p cp } 
49 
48 
48 
8364
1
2
3
4
5
6
7
>> str.each_byte {|b| p b } 
49 
48 
48 
226 
130 
172
1
2
str = "This string\nhas three\nlines" 
str.each_line {|l| puts "Next line: #{l}" }
1
2
3
Next line: This string 
Next line: has three 
Next line: lines

1
2
3
str = "David!Alan!Black" 
$/ = "!" 
str.each_line {|l| puts "Next line: #{l}" }
1
2
3
Next line: David! 
Next line: Alan! 
Next line: Black
1
2
string = "Hello" 
p string.bytes
1 [72, 101, 108, 108, 111]
1
2
>> [3,2,5,4,1].sort 
=> [1, 2, 3, 4, 5]
1 >> [pa1, pa2, pa3, pa4, pa5].sort
1
2
3
def <=>(other_painting) 
  self.price <=> other_painting.price 
end

1 price_sorted = [pa1, pa2, pa3, pa4, pa5].sort
1
2
3
year_sort = [pa1, pa2, pa3, pa4, pa5].sort do |a,b| 
  a.year <=> b.year 
end
1
2
>> ["2",1,5,"3",4,"6"].sort {|a,b| a.to_i <=> b.to_i } 
=> [1, "2", "3", 4, 5, "6"]
1
2
>> ["2",1,5,"3",4,"6"].sort_by {|a| a.to_i } 
=> [1, "2", "3", 4, 5, "6"]
1
1
2
3
4
5
e = Enumerator.new do |y| 
  y << 1 
  y << 2 
  y << 3 
end
1
2
3
4
5
6
7
8
>> e.to_a 
=> [1, 2, 3] 
>> e.map {|x| x * 10 } 
=> [10, 20, 30] 
>> e.select {|x| x > 1 } 
=> [2, 3] 
>> e.take(2) 
   => [1, 2]
1
2
3
4
1
2
3
e = Enumerator.new do |y| 
  (1..3).each {|i| y << i } 
end

1
2
3
4
5
e = Enumerator.new do 
  yield 1 
  yield 2 
  yield 3 
end
1
2
1
2
3
4
5
6
7
e = Enumerator.new do |y| 
  puts "Starting up the block!" 
  (1..3).each {|i| y << i } 
  puts "Exiting the block!" 
end 
p e.to_a 
p e.select {|x| x > 2 }
1
2
3
4
5
6
Starting up the block! 
Exiting the block! 
[1, 2, 3] 
Starting up the block! 
Exiting the block! 
[3]
1
2
1
2
3
4
5
6
7
8
a = [1,2,3,4,5] 
e = Enumerator.new do |y| 
  total = 0 
  until a.empty? 
    total += a.pop 
    y << total 
  end 
end
1
2
3
4
5
6
7
8
>> e.take(2) 
=> [5, 9] 
>> a 
=> [1, 2, 3] 
>> e.to_a 
=> [3, 5, 6] 
>> a 
=> []

1
2
names = %w{ David Black Yukihiro Matsumoto } 
e = names.enum_for(:select)
1 e.each {|n| n.include?('a') }
1
1
2
3
4
>> e = names.enum_for(:inject, "Names: ") 
=> #<Enumerator: ["David", "Black", "Yukihiro", "Matsumoto"]:inject("Names: ")> 
>> e.each {|string, name| string << "#{name}..." } 
=> "Names: David...Black...Yukihiro...Matsumoto..."
1
2
3
>> e.each {|string, name| string << "#{name}..." } 
=> "Names: David...Black...Yukihiro...Matsumoto... 
David...Black...Yukihiro...Matsumoto..."
1
2
3
4
5
6
7
8
9
>> str = "Hello" 
=> "Hello" 
>> str.each_byte {|b| puts b } 
72 
101 
108 
108 
111 
=> "Hello"
1
2
>> str.each_byte 
=> #<Enumerator: "Hello":each_byte>

1 >> str.enum_for(:each_byte)
1
2
3
4
5
6
>> array = %w{ cat dog rabbit } 
=> ["cat", "dog", "rabbit"] 
>> e = array.map 
=> #<Enumerator: ["cat", "dog", "rabbit"]:map> 
>> e.each {|animal| animal.capitalize } 
=> ["Cat", "Dog", "Rabbit"]
1
1
2
3
4
>> h = { "cat" => "feline", "dog" => "canine", "cow" => "bovine" } 
=> {"cat"=>"feline", "dog"=>"canine", "cow"=>"bovine"} 
>> h.select {|key,value| key =~ /c/ } 
=> {"cat"=>"feline", "cow"=>"bovine"}
1
2
3
4
>> e = h.enum_for(:select) 
=> #<Enumerator: {"cat"=>"feline", "dog"=>"canine", "cow"=>"bovine"}:select> 
>> e.each {|key,value| key =~ /c/ } 
=> {"cat"=>"feline", "cow"=>"bovine"}
1
2
>> e = h.to_enum 
=> #<Enumerator: {"cat"=>"feline", "dog"=>"canine", "cow"=>"bovine"}:each>
1
2
3
4
>> h.each { } 
=> {"cat"=>"feline", "dog"=>"canine", "cow"=>"bovine"} 
>> e.each { } 
=> {"cat"=>"feline", "dog"=>"canine", "cow"=>"bovine"}
1
2
>> e.select {|key,value| key =~ /c/ } 
=> [["cat", "feline"], ["cow", "bovine"]]

1 def give_me_an_array(array)
1 array << "new element"
1 give_me_an_array(array.to_enum)
1
2
deck = PlayingCard::Deck.new 
deck.cards << "JOKER!!"
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
class PlayingCard 
  SUITS = %w{ clubs diamonds hearts spades } 
  RANKS = %w{ 2 3 4 5 6 7 8 9 10 J Q K A } 
  class Deck 
    def cards 
      @cards.to_enum 
    end 
    def initialize(n=1) 
      @cards = [] 
      SUITS.cycle(n) do |s| 
        RANKS.cycle(1) do |r| 
          @cards << "#{r} of #{s}" 
        end 
      end 
    end 
  end 
end
1
2
deck = PlayingCard::Deck.new 
deck.cards << "Joker!!"
1

1
2
3
4
5
6
names = %w{ David Yukihiro } 
e = names.to_enum 
puts e.next 
puts e.next 
e.rewind 
puts e.next
1
2
3
David 
Yukihiro 
David
1
2
3
4
5
6
7
8
9
module Music 
  class Scale 
    NOTES = %w{ c c# d d# e f f# g a a# b } 
 
    def play 
      NOTES.each {|note| yield note } 
    end 
  end 
end
1
2
scale = Music::Scale.new 
scale.play {|note| puts "Next note is #{note}" }
1
2
3
Next note is c 
Next note is c# 
Next note is d
1 scale.map {|note| note.upcase }
1 NoMethodError: unknown method `map' for #<Music::Scale:0x3b0aec>

ENUMERATOR LITERACY
1 enum = scale.enum_for(:play)
1
1
2
p enum.map {|note| note.upcase } 
p enum.select {|note| note.include?('f') }
1 ["C", "C#", "D", "D#", "E", "F", "F#", "G", "A", "A#", "B"]
1 ["f", "f#"]
1 puts names.select {|n| n[0] < 'M' }.map(&:upcase).join(", ")
1
1
2
3
4
5
6
7
>> names = %w{ David Black Yukihiro Matsumoto } 
=> ["David", "Black", "Yukihiro", "Matsumoto"] 
>> names.each_slice(2).map do |first, last| 
     "First name: #{first}, last name: #{last}\n" 
   end 
=> ["First name: David, last name: Black\n", 
    "First name: Yukihiro, last name: Matsumoto\n"]

One consequence of the way enumerators work, and of their being
returned automatically from blockless iterator calls, is that it takes a
little practice to read enumerator code correctly. Consider this snippet,
which returns an array of integers:
Probably not useful business logic...but the point is that it looks much
like string.each_byte  is returning an array. The presence of map
as the next operation, although not conclusive evidence of an array,
certainly evokes the presence of a collection on the left.
Let’s put it another way. Judging by its appearance, you might expect
that if you peel o| the whole map  call, you’ll be left with a collection.
In fact, string.each_byte  returns an enumerator. The key is that an
enumerator is a collection. It’s an enumerable object as much as an
array or a hash is. It just may take a little getting used to.
1
2
string = "An arbitrary string" 
string.each_byte.map {|b| b + 1 }
1 e = names.enum_for(:inject, "Names: ")
1 ('a'..'z').map.with_index {|letter,i| [letter, i] }
1
1
2
3
def play 
  NOTES.to_enum 
end
1 scale.play {|note| puts "Next note: #{note}" }

FORCING AN ENCODING
The String#^  as implemented in the previous snippet is vulnerable
to encoding issues: if you xor, say, a UTF-8 string against an ASCII
string twice, you’ll get back a string encoded in ASCII-8BIT. To guard
against this, add a call to force_encoding :
1 scale.play.with_index(1) {|note,i| puts "Note #{i}: #{note}" }
1
1
2
3
4
Note 1: c 
Note 2: c# 
Note 3: d 
# etc.
Listing 10.2. An exclusive-or method for strings
1
2
3
4
5
6
class String 
  def ^(key) 
    kenum = key.each_byte.cycle 
    each_byte.map {|byte| byte ^ kenum.next }.pack("C*") 
  end 
end
1
2
3
1
2
3
4
5
6
7
8
>> str = "Nice little string." 
=> "Nice little string." 
>> key = "secret!" 
=> "secret!" 
>> x = str ^ key 
   => "=\f\x00\x17E\x18H\a\x11\x0F\x17E\aU\x01\f\r\x15K" 
>> orig = x ^ key 
=> "Nice little string."
1
2
each_byte.map {|byte| byte ^ kenum.next }.pack("C*"). 
                         force_encoding(self.encoding)

This will ensure that the byte sequence generated by the mapping gets
encoded in the original string’s encoding.
1 (1..Float::INFINITY).select {|n| n % 3 == 0 }.first(10)
1
2
>> (1..Float::INFINITY).lazy 
=> #<Enumerator::Lazy: 1..Infinity>
1
2
>>(1..Float::INFINITY).lazy.select {|n| n % 3 == 0 } 
=> #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>
1
2
>> (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }.first(10) 
=> [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
1
2
3
4
5
6
>> my_enum = (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 } 
=> #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select> 
>> my_enum.take(5).force 
=> [3, 6, 9, 12, 15] 
>> my_enum.take(10).force 
=> [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
def fb_calc(i) 
 case 0 
 when i % 15 
   "FizzBuzz" 
 when i % 3 
   "Fizz" 
 when i % 5 

   "Buzz" 
 else 
   i.to_s 
 end 
end 
def fb(n) 
 (1..Float::INFINITY).lazy.map {|i| fb_calc(i) }.first(n) 
end
p fb(15)
["1", "2", "Fizz", "4", "Buzz", "Fizz", "7", "8", "Fizz", "Buzz", "11", 
    "Fizz", "13", "14", "FizzBuzz"]

CHAPTER 11
1 //
1
2
>> //.class 
=> Regexp
1
2
puts "Match!" if /abc/.match("The alphabet starts with abc.") 
puts "Match!" if "The alphabet starts with abc.".match(/abc/)
1
2
puts "Match!" if /abc/ =~ "The alphabet starts with abc." 
puts "Match!" if "The alphabet starts with abc." =~ /abc/
1
2
3
4
>> "The alphabet starts with abc" =~ /abc/ 
=> 25 
>> /abc/.match("The alphabet starts with abc.") 
=> #<MatchData "abc">
1 /a/
1 /\?/

1 /.ejected/
1 puts "Match!" if /.ejected/.match("%ejected")
1 /[dr]ejected/
1 /[a-z]/
1 /[A-Fa-f0-9]/
1 /[^A-Fa-f0-9]/
1
2
3
4
>> string = "ABC3934 is a hex number." 
=> "ABC3934 is a hex number." 
>> string =~ /[^A-Fa-f0-9]/ 
=> 7
1 /[0-9]/

1 /\d/
1 /\D/
1
2
regex.match(string) 
string.match(regex)
1 Peel,Emma,Mrs.,talented amateur
1 /[A-Za-z]+,[A-Za-z]+,Mrs?\./
1
2
>> /[A-Za-z]+,[A-Za-z]+,Mrs?\./.match("Peel,Emma,Mrs.,talented amateur") 
=> #<MatchData "Peel,Emma,Mrs.">
1 /([A-Za-z]+),[A-Za-z]+,(Mrs?\.)/

1 /([A-Za-z]+),[A-Za-z]+,(Mrs?\.)/.match("Peel,Emma,Mrs.,talented amateur")
1
2
3
line_from_file = "Peel,Emma,Mrs.,talented amateur" 
/([A-Za-z]+),[A-Za-z]+,(Mrs?\.)/.match(line_from_file) 
puts "Dear #{$2} #{$1},"
1
1
2
>> /a/.match("b") 
=> nil
Listing 11.1. Matching a phone number and querying the resulting MatchData  object
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
string = "My phone number is (123) 555-1234." 
phone_re = /\((\d{3})\)\s+(\d{3})-(\d{4})/ 
m = phone_re.match(string) 
unless m 
  puts "There was no match—sorry." 
  exit 
end 
print "The whole string we started with: " 
puts m.string 
print "The entire part of the string that matched: " 
puts m[0] 
puts "The three captures: " 
3.times do |index| 
  puts "Capture ##{index + 1}: #{m.captures[index]}" 
end 
puts "Here's another way to get at the first capture:" 
print "Capture #1: " 
puts m[1]
1
2
3
4
5
1
2
3
4
5
6
7
8
The whole string we started with: My phone number is (123) 555-1234. 
The entire part of the string that matched: (123) 555-1234 
The three captures: 
Capture #1: 123 
Capture #2: 555 
Capture #3: 1234 
Here's another way to get at the first capture: 
Capture #1: 123

1
2
3
m[1] 
m[2] 
#etc.
1
2
m[1] == m.captures[0] 
m[2] == m.captures[1]
1 /((a)((b)c))/.match("abc")
1
2
>> /((a)((b)c))/.match("abc") 
=> #<MatchData "abc" 1:"abc" 2:"a" 3:"bc" 4:"b">
1 >> re = /(?<first>\w+)\s+((?<middle>\w\.)\s+)?(?<last>\w+)/
1
2
>> m = re.match("David A. Black") 
=> #<MatchData "David A. Black" first:"David" middle:"A." last:"Black">
1
2
>> m[:first] 
=> "David"
Listing 11.2. Supplemental code for phone number–matching operations
1
2
3
print "The part of the string before the part that matched was: " 
puts m.pre_match 
print "The part of the string after the part that matched was: " 

4
5
6
7
8
puts m.post_match 
print "The second capture began at character " 
puts m.begin(2) 
print "The third capture ended at character " 
puts m.end(3)
1
2
3
4
The string up to the part that matched was: My phone number is 
The string after the part that matched was: . 
The second capture began at character 25 
The third capture ended at character 33
1
2
3
the character M, followed by the character r, followed by 
zero or one of the character s, followed by 
zero or one of the character '.'
1 /Mrs?\.?/
1 \d\d?
1
2
3
4
5
</poem> 
< /poem> 
</    poem> 
</poem 
>
1 /<\s*\/\s*poem\s*>/

1 /\d+/
1
2
3
/\d+/.match("There’s a digit here somewh3re...") 
/\d+/.match("No digits here. Move along.") 
/\d+/.match("Digits-R-Us 2345")
1
2
3
1
2
/(\d+)/.match("Digits-R-Us 2345") 
puts $1
1
2
3
string = "abc!def!ghi!" 
match = /.+!/.match(string) 
puts match[0]
1
1
2
3
string = "abc!def!ghi!" 
match = /.+?!/.match(string) 
puts match[0]
1
1
2
/(\d+?)/.match("Digits-R-Us 2345") 
puts $1
1 /\d+5/.match("Digits-R-Us 2345")

1
2
>> /(\d+)(5)/.match("Digits-R-Us 2345") 
=> #<MatchData "2345" 1:"234" 2:"5">
1 /\d{3}-\d{4}/
1 /\d{1,10}/
1 /\d{3,}/
1 /([A-Z]){5}/.match("David BLACK")
1
2
>> /([A-Z]){5}/.match("David BLACK") 
=> #<MatchData "BLACK" 1:"K">
1
2
>> /([A-Z]{5})/.match("David BLACK") 
=> #<MatchData "BLACK" 1:"BLACK">
1 /^\s*#/

NON-CAPTURING PARENTHESES
Table 11.1. Regular expression anchors
Notation
Description
Example
Sample matching string
^
Beginning of line
/^\s*#/
" # A Ruby comment line
with leading spaces"
$
End of line
/\.$/
"one\ntwo\nthree.\nfour"
\A
Beginning of
string
/\AFour score/
"Four score"
\z
End of string
/from the
earth.\z/
"from the earth."
\Z
End of string
(except for nal
newline)
/from the
earth.\Z/
"from the earth\n"
\b
Word boundary
/\b\w+\b/
"!!!word***" (matches
“word”)
1
2
3
4
5
6
7
>> comment_regexp = /^\s*#/ 
=> /^\s*#/ 
>> comment_regexp.match("  # Pure comment!") 
 
=> #<MatchData "  #"> 
>> comment_regexp.match("  x = 1  # Code plus comment!") 
=> nil
1
2
str = "123 456. 789" 
m = /\d+(?=\.)/.match(str)
1 re = /(?<=David )BLACK/
1 re = /(?<!David )BLACK/

If you want to match something—not just assert that it’s next, but
actually match it—using parentheses, but you don’t want it to count
as one of the numbered parenthetical captures resulting from the
match, use the (?:...)  construct. Anything inside a (?:)  grouping
will be matched based on the grouping, but not saved to a capture.
Note that the MatchData  object resulting from the following match
only has two captures; the def  grouping doesn’t count, because of
the ?:  notation:
Unlike a zero-width assertion, a (?:)  group does consume
characters. It just doesn’t save them as a capture.
1
2
3
4
>> str = "abc def ghi" 
=> "abc def ghi" 
>> m = /(abc) (?:def) (ghi)/.match(str) 
=> #<MatchData "abc def ghi" 1:"abc" 2:"ghi">
1
2
3
4
5
6
7
8
>> re = /(a)?(?(1)b|c)/ 
=> /(a)?(?(1)b|c)/ 
>> re.match("ab") 
=> #<MatchData "ab" 1:"a"> 
>> re.match("b") 
=> nil 
>> re.match("c") 
=> #<MatchData "c" 1:nil>
1
2
3
1 /(?<first>a)?(?(<first>)b|c)/
1 /abc/i
1
2
str = "This (including\nwhat's in parens\n) takes up three lines." 
m = /\(.*?\)/m.match(str)

1 (including\nwhat's in parens\n)
1
2
3
4
5
6
7
/ 
 \((\d{3})\)  # 3 digits inside literal parens (area code) 
   \s         # One space character 
 (\d{3})      # 3 digits (exchange) 
    -         # Hyphen 
 (\d{4})      # 4 digits (second part of number 
/x
1 /\((\d{3})\)\s(\d{3})-(\d{4})/
1 /  (?<=   David\ )    BLACK  /x
1 /[a-c]{3}/
1 /abc/
1
2
3
4
>> str = "def" 
=> "def" 
>> /abc#{str}/ 
=> /abcdef/

1
2
3
4
5
6
7
8
>> str = "a.c" 
=> "a.c" 
>> re = /#{str}/ 
=> /a.c/ 
>> re.match("a.c") 
=> #<MatchData "a.c"> 
>> re.match("abc") 
=> #<MatchData "abc">
1
2
3
4
>> Regexp.escape("a.c") 
=> "a\\.c" 
>> Regexp.escape("^abc") 
=> "\\^abc"
1
2
3
4
5
6
7
8
>> str = "a.c" 
=> "a.c" 
>> re = /#{Regexp.escape(str)}/ 
=> /a\.c/ 
>> re.match("a.c") 
=> #<MatchData "a.c"> 
>> re.match("abc") 
=> nil
1
2
>> Regexp.new('(.*)\s+Black') 
=> /(.*)\s+Black/
1
2
3
4
>> Regexp.new('Mr\. David Black') 
=> /Mr\. David Black/ 
>> Regexp.new(Regexp.escape("Mr. David Black")) 
=> /Mr\.\ David\ Black/
1
2
>> puts /abc/ 
(?-mix:abc)

1
2
>> /abc/.inspect 
=> "/abc/"
1 array.find_all {|e| e.size > 10 and /\d/.match(e) }
1
2
>> "testing 1 2 3 testing 4 5 6".scan(/\d/) 
=> ["1", "2", "3", "4", "5", "6"]
1
2
3
4
>> str = "Leopold Auer was the teacher of Jascha Heifetz." 
=> "Leopold Auer was the teacher of Jascha Heifetz." 
>> violinists = str.scan(/([A-Z]\w+)\s+([A-Z]\w+)/) 
=> [["Leopold", "Auer"], ["Jascha", "Heifetz"]]
1
2
3
violinists.each do |fname,lname| 
  puts "#{lname}'s first name was #{fname}." 
end
1
2
Auer's first name was Leopold. 
Heifetz's first name was Jascha.
1
2
str.scan(/([A-Z]\w+)\s+([A-Z]\w+)/) do |fname, lname| 
  puts "#{lname}'s first name was #{fname}." 

EVEN MORE STRING SCANNING WITH THE STRINGSCANNER
CLASS
The standard library includes an extension called strscan , which
provides the StringScanner  class. StringScanner  objects extend
the available toolkit for scanning and examining strings. A
StringScanner  object maintains a pointer into the string, allowing
for back-and-forth movement through the string using position and
pointer semantics.
Here are some examples of the methods in StringScanner :
3 end
1 "one two three".scan(/\w+/) {|n| puts "Next number: #{n}" }
1
2
3
Next number: one 
Next number: two 
Next number: three
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
>> require 'strscan' 
=> true 
>> ss = StringScanner.new("Testing string scanning") 
=> #<StringScanner 0/23 @ "Testi..."> 
>> ss.scan_until(/ing/) 
=> "Testing" 
>> ss.pos 
=> 7 
>> ss.peek(7) 
=> " string" 
>> ss.unscan 
=> #<StringScanner 0/23 @ "Testi..."> 
>> ss.pos 
=> 0 
>> ss.skip(/Test/) 
=> 4 
>> ss.rest 
=> "ing string scanning"
1
2
3
4
5
6
7
8

Using the notion of a pointer into the string, StringScanner  lets you
traverse across the string as well as examine what’s already been
matched and what remains. String-Scanner  is a useful complement
to the built-in string scanning facilities.
1
2
>> "Ruby".split(//) 
=> ["R", "u", "b", "y"]
1
2
line = "first_name=david;last_name=black;country=usa" 
record = line.split(/=|;/)
1 ["first_name", "david", "last_name", "black", "country", "usa"]
1
2
3
data = [] 
record = Hash[*line.split(/=|;/)] 
data.push(record)
1
1
2
>> "a,b,c,d,e".split(/,/,3) 
=> ["a", "b", "c,d,e"]
1
2
>> "typigraphical error".sub(/i/,"o") 
=> "typographical error"
1
2
>> "capitalize the first vowel".sub(/[aeiou]/) {|s| s.upcase } 
=> "cApitalize the first vowel"

A GLOBAL CAPTURE VARIABLE PITFALL
Beware: You can use the global capture variables ( $1 , etc.) in your
substitution string, but they may not do what you think they will.
Specically, you’ll be vulnerable to leftover values for those variables.
Consider this example:
Here, $1  from the previous match ( "abc" ) ended up inltrating the
substitution string in the second match. In general, sticking to the
\1 -style references to your captures is safer than using the global
capture variables in sub  and gsub  substitution strings.
1
2
>> "capitalize every word".gsub(/\b\w/) {|s| s.upcase } 
=> "Capitalize Every Word"
1
2
>> "aDvid".sub(/([a-z])([A-Z])/, '\2\1') 
=> "David"
1
2
>> "double every word".gsub(/\b(\w+)/, '\1 \1') 
=> "double double every every word word"
1
2
3
4
>> /(abc)/.match("abc") 
=> #<MatchData "abc" 1:"abc"> 
>> "aDvid".sub(/([a-z])([A-Z])/, "#{$2}#{$1}") 
=> "abcvid"
1
2
puts "Match!" if re.match(string) 
puts "Match!" if string =~ re 

3 puts "Match!" if re === string
1
2
3
4
5
6
7
8
9
10
11
print "Continue? (y/n) " 
answer = gets 
case answer 
when /^y/i 
  puts "Great!" 
when /^n/i 
  puts "Bye!" 
  exit 
else 
  puts "Huh?" 
end
1
2
>> ["USA", "UK", "France", "Germany"].grep(/[a-z]/) 
=> ["France", "Germany"]
1 ["USA", "UK", "France", "Germany"].select {|c| /[a-z]/ === c }
1
2
>> ["USA", "UK", "France", "Germany"].grep(/[a-z]/) {|c| c.upcase } 
=> ["FRANCE", "GERMANY"]
1 [1,2,3].grep(/1/)

CHAPTER 12
1
2
3
4
5
6
7
8
>> STDERR.class 
=> IO 
>> STDERR.puts("Problem!") 
Problem! 
=> nil 
>> STDERR.write("Problem!\n") 
Problem! 
=> 9
1
2
3
1
2
3
4
5
6
7
>> STDIN.each {|line| p line } 
This is line 1 
"This is line 1\n" 
This is line 2 
"This is line 2\n" 
All separated by $/, which is a newline character 
"All separated by $/, which is a newline character\n"
1
2
3
4
5
6
7
8
9
10
>> $/ = "NEXT" 
=> "NEXT" 
>> STDIN.each {|line| p line} 
First line 
NEXT 
"First line\nNEXT" 
Next line 
where "line" really means 
until we see... NEXT 
"\nNext line\nwhere \"line\" really means\nuntil we see... NEXT"
1
2
3
4
5
6
7
8
9
10
11
12
>> STDIN.select {|line| line =~ /\A[A-Z]/ } 
We're only interested in 
lines that begin with 
Uppercase letters 
^D 
=> ["We're only interested in\n", "Uppercase letters\n"] 
>> STDIN.map {|line| line.reverse } 
senil esehT 
terces a niatnoc 
.egassem 
^D 
=> ["\nThese lines", "\ncontain a secret", "\nmessage."]

1
2
3
if broken? 
  STDERR.puts "There's a problem!" 
end
1
2
3
4
5
6
record = File.open("/tmp/record", "w") 
old_stdout = $stdout 
$stdout = record 
$stderr = $stdout 
puts "This is a record" 
z = 10/0
1
2
3
This is a record 
outputs.rb:6:in `/': divided by 0 (ZeroDivisionError) 
    from outputs.rb:6:in `<main>'
1
2
line = gets 
char = STDIN.getc
1 line = STDIN.gets
1
2
>> f = File.new("code/ticket2.rb") 
=> #<File:code/ticket2.rb>

1
2
3
>> f.read 
=> "class Ticket\n  def initialize(venue, date)\n 
          @venue = venue\n    @date = date\n  end\n\n etc.
1
2
3
4
5
6
>> f.gets 
=> "class Ticket\n" 
>> f.gets 
=> "  def initialize(venue, date)\n" 
>> f.gets 
=> "    @venue = venue\n"
1
2
3
4
5
6
7
8
>> f.read 
=> "  def initialize(venue, date)\n    @venue = venue\n 
    @date = date\n  end\n\n 
    etc. 
>> f.gets 
=> nil 
>> f.readline 
EOFError: end of file reached
1
2
3
4
5
>> f.rewind 
=> 0 
>> f.readlines 
=> ["class Ticket\n", "  def initialize(venue, date)\n", 
    "    @venue = venue\n", "    @date = date\n"  etc.
1
2
3
4
5
>> f.each {|line| puts "Next line: #{line}" } 
Next line: class Ticket 
Next line:   def initialize(venue, date) 
Next line:     @venue = venue 
etc.
1
2
>> f.getc 
=> "c"

1
2
3
4
5
6
7
>> f.getc 
=> "c" 
 
>> f.ungetc("X") 
=> nil 
>> f.gets 
=> "Xlass Ticket\n"
>> f.getc 
=> nil 
>> f.readchar 
EOFError: end of file reached 
>> f.getbyte 
=> nil 
>> f.readbyte 
EOFError: end of file reached
>> f.rewind 
=> 0 
>> f.pos 
=> 0 
>> f.gets 
=> "class Ticket\n" 
>> f.pos 
=> 13
>> f.pos = 10 
=> 10 
>> f.gets 
=> "et\n"
f.seek(20, IO::SEEK_SET) 
f.seek(15, IO::SEEK_CUR) 
f.seek(-10, IO::SEEK_END)
full_text = File.read("myfile.txt") 
lines_of_text = File.readlines("myfile.txt")

LOW-LEVEL I/O METHODS
In addition to the various I/O and File  methods we’ll look at closely
here, the IO  class gives you a toolkit of system-level methods with
which you can do low-level I/O operations. These include sysseek ,
sysread , and syswrite . These methods correspond to the system
calls on which some of the higher-level methods are built.
The sys-  methods perform raw, unbu|ered data operations and
shouldn’t be mixed with higher-level methods. Here’s an example of
what not to do:
If you run this little program, here’s what you’ll see:
In addition to a warning, you get the second string (the one written
with syswrite ) stuck in the le before the rst string. That’s
because syswrite  and print  don’t operate according to the same
rules and don’t play nicely together. It’s best to stick with the higher-
level methods unless you have a particular reason to use the others.
File.open("output.txt", "w") do |f| 
  f.print("Hello") 
  f.syswrite(" there!") 
end 
puts File.read("output.txt")
syswrite.rb:3: warning: syswrite for buffered IO 
 there!Hello
>> f = File.new("data.out", "w") 
=> #<File:data.out> 
>> f.puts "David A. Black, Rubyist" 
=> nil 
>> f.close 
=> nil 
>> puts File.read("data.out") 

David A. Black, Rubyist 
=> nil 
>> f = File.new("data.out", "a") 
=> #<File:data.out> 
>> f.puts "Yukihiro Matsumoto, Ruby creator" 
=> nil 
>> f.close 
=> nil 
 
>> puts File.read("data.out") 
David A. Black, Rubyist 
Yukihiro Matsumoto, Ruby creator
Pablo Casals|Catalan|cello|1876-1973 
Jascha Heifetz|Russian-American|violin|1901-1988 
Emanuel Feuermann|Austrian-American|cello|1902-1942
File.open("records.txt") do |f| 
  while record = f.gets 
    name, nationality, instrument, dates = record.chomp.split('|') 
    puts "#{name} (#{dates}), who was #{nationality}, 
 played #{instrument}. " 
  end 
end
Pablo Casals (1876-1973), who was Catalan, played cello. 
Jascha Heifetz (1901-1988), who was Russian-American, played violin. 
Emanuel Feuermann (1902-1942), who was Austrian-American, played cello.
File.open("records.txt") do |f| 
  f.each do |record| 
    name, nationality, instrument, dates = record.chomp.split('|') 
    puts "#{name} (#{dates}), who was #{nationality}, 
  played #{instrument}. " 
  end 
end

# Sample record in members.txt: 
# David Black male 55 
count = 0 
total_ages = File.readlines("members.txt").inject(0) do |total,line| 
  count += 1 
  fields = line.split 
  age = fields[3].to_i 
  total + age 
end 
puts "Average age of group: #{total_ages / count}."
count = 0 
total_ages = File.open("members.txt") do |f| 
  f.inject(0) do |total,line| 
 
    count += 1 
    fields = line.split 
    age = fields[3].to_i 
    total + age 
  end 
end 
puts "Average age of group: #{total_ages / count}."
>> File.open("no_file_with_this_name") 
Errno::ENOENT: No such file or directory - no_file_with_this_name 
>> f = File.open("/tmp") 
=> #<File:/tmp> 
>> f.gets 
Errno::EISDIR: Is a directory - /tmp 
>> File.open("/var/root") 
Errno::EACCES: Permission denied - /var/root
>> Errno::ENOTDIR::Errno 
=> 20
>> File.size("code/ticket2.rb") 
=> 219 
>> FileTest.size("code/ticket2.rb") 
=> 219 
>> File::Stat.new("code/ticket2.rb").size 
=> 219
FileTest.exist?("/usr/local/src/ruby/README")

This family of query methods also includes , , , and .
This family of query methods includes and , which test for more
permissive permissions. It also includes variants of the basic
three methods with appended. These test the permissions of the
script’s actual runtime ID as opposed to its e|ective user ID.
GETTING FILE INFORMATION WITH KERNEL#TEST
Among the top-level methods at your disposal (that is, private
methods of the Kernel  module, which you can call anywhere without
a receiver, like puts ) is a method called test . You use test  by
passing it two arguments: the rst represents the test, and the second
is a le or directory. The choice of test is indicated by a character. You
can represent the value using the ?c  notation, where c  is the
character, or as a one-character string.
Here’s an example that nds out whether /tmp  exists:
Other common test characters include ?d  (the test is true if the
second argument is a directory), ?f  (true if the second argument is a
regular le), and ?z  (true if the second argument is a zero-length
le). For every test available through Kernel#test , there’s usually a
way to get the result by calling a method of one of the classes
FileTest.directory?("/home/users/dblack/info") 
FileTest.file?("/home/users/dblack/info") 
FileTest.symlink?("/home/users/dblack/info")
FileTest.readable?("/tmp") 
FileTest.writable?("/tmp") 
FileTest.executable?("/home/users/dblack/setup")
FileTest.size("/home/users/dblack/setup") 
FileTest.zero?("/tmp/tempfile")
test ?e, "/tmp"

discussed in this section. But the Kernel#test  notation is shorter
and can be handy for that reason.
>> File::Stat.new("code/ticket2.rb") 
=> #<File::Stat dev=0x1000002, ino=11531534, mode=0100644, 
nlink=1 uid=501 gid=20 rdev=0x0 size=219 blksize=4096
>> d = Dir.new("/usr/local/src/ruby/lib/minitest")                   #1 
=> #<Dir:/usr/local/src/ruby/lib/minitest>    
>> d.entries 
=> [".", "..", ".document", "autorun.rb", "benchmark.rb", "hell.rb", 
"mock.rb", "parallel_each.rb", "pride.rb", "README.txt", "spec.rb", 
"unit.rb"]
>> Dir.entries("/usr/local/src/ruby/lib/minitest") 
=> [".", "..", ".document", "autorun.rb", "benchmark.rb", "hell.rb", 
"mock.rb", "parallel_each.rb", "pride.rb", "README.txt", "spec.rb", 
"unit.rb"]
d = Dir.new("/usr/local/src/ruby/lib/minitest") 
entries = d.entries 
entries.delete_if {|entry| entry =~ /^\./ } 
entries.map! {|entry| File.join(d.path, entry) } 
entries.delete_if {|entry| !File.file?(entry) } 
print "Total bytes: " 
puts entries.inject(0) {|total, entry| total + File.size(entry) }
$ ls *.rb 
$ rm *.?xt 
$ for f in [A-Z]*   # etc.
>> Dir["/usr/local/src/ruby/include/ruby/r*.h"] 
=> ["/usr/local/src/ruby/include/ruby/re.h", "/usr/local/src/ruby/include/ 
     ruby/regex.h", "/usr/local/src/ruby/include/ruby/ruby.h"]

Dir.glob("info*")      # [] 
Dir.glob("info", File::FNM_CASEFOLD   # ["Info", "INFORMATION"]
>> Dir.glob("*info*") 
=> [] 
>> Dir.glob("*info*", File::FNM_DOTMATCH) 
=> [".information"] 
>> Dir.glob("*info*", File::FNM_DOTMATCH | File::FNM_CASEFOLD) 
=> [".information", ".INFO", "Info"]
Dir["*info*"]
Dir.glob("*info*", 0)
Dir.glob("*info*")
dir = "/usr/local/src/ruby/lib/minitest" 
entries = Dir["#{dir}/*"].select {|entry| File.file?(entry) } 
print "Total bytes: " 
puts entries.inject(0) {|total, entry| total + File.size(entry) }
newdir = "/tmp/newdir"                            #1 
newle = "newle" 
Dir mkdir(newdir)
>> require 'leutils' 
=> true 
>> FileUtils cp("baker rb" "baker rb bak")
>> FileUtils.mv("baker.rb.bak", "backup") 
=> 0 
>> Dir["backup/*"] 
=> ["backup/baker.rb.bak", "backup/ensure.rb", "backup/super.rb"]
>> File.exist?("backup/super.rb") 
=> true 
>> FileUtils.rm("./backup/super.rb") 
=> ["./backup/super.rb"] 

>> File.exist?("backup/super.rb") 
=> false
>> FileUtils.rm_rf("backup") 
=> ["backup"] 
>> File.exist?("backup") 
=> false
>> FileUtils::DryRun.rm_rf("backup") 
rm -rf backup 
=> nil 
>> FileUtils::DryRun.ln_s("backup", "backup_link") 
ln -s backup backup_link 
=> nil
>> FileUtils::NoWrite.rm("backup/super.rb") 
=> nil 
>> File.exist?("backup/super.rb") 
=> true
>> require 'pathname' 
=> true 
>> path = Pathname.new("/Users/dblack/hacking/test1.rb") 
=> #<Pathname:/Users/dblack/hacking/test1.rb>
>> path.basename 
=> #<Pathname:test1.rb> 
>> puts path.basename 
test1.rb
>> path.dirname 
=> #<Pathname:/Users/dblack/hacking>
>> path.extname 
=> ".rb"
>> path.ascend do |dir| 
?>   puts "Next level up: #{dir}" 
>> end
Next level up: /Users/dblack/hacking/test1.rb 
Next level up: /Users/dblack/hacking 

TESTING USING REAL FILES
If you want to run tests on le input and output using real les, Ruby’s
tempfile  class can help you. It’s a standard-library feature, so you
have to require 'tempfile' . Then, you create temporary les with
the constructor, passing in a name that Ruby munges into a unique
lename. For example:
You can then write to and read from the le using the File  object
tf .
Next level up: /Users/dblack 
Next level up: /Users 
Next level up: /
>> path = Pathname.new("/Users/dblack/hacking/test1.rb") 
=> #<Pathname:/Users/dblack/hacking/test1.rb> 
>> path.ascend do |dir| 
?>   puts "Ascended to #{dir.basename}" 
>> end
Ascended to test1.rb 
Ascended to hacking 
Ascended to dblack 
Ascended to Users 
Ascended to /
module DeCommenter 
  def self.decomment(infile, outfile, comment_re = /\A\s*#/) 
    infile.each do |inline| 
      outfile.print inline unless inline =~ comment_re 
    end 
  end 
end
File.open("myprogram.rb") do |inf| 
  File.open("myprogram.rb.out", "w") do |outf| 
    DeCommenter.decomment(inf, outf) 
  end 
end
tf = Tempfile.new("my_temp_file").

require 'stringio'                                          #1 
require_relative 'decommenter'                              #1 
string = <<EOM
#2
require 'open-uri' 
rubypage = open("http://rubycentral.org") 
puts rubypage.gets

CHAPTER 13
SOME OBJECTS ARE MORE INDIVIDUALIZABLE THAN OTHERS
Almost every object in Ruby can have methods added to it. The
exceptions are instances of certain Numeric  subclasses, including
integer classes and oats, and symbols. If you try this
1
2
3
4
5
class C 
  def talk 
    puts "Hi!" 
  end 
end
1
2
c = C.new 
c.talk
1
1
2
3
4
5
obj = Object.new 
def obj.talk 
  puts "Hi!" 
end 
obj.talk
1
1
2
3
4
5
class Car 
  def self.makes 
    %w{ Honda Ford Toyota Chevrolet Volvo } 
  end 
end
1 def 10.some_method; end

you’ll get a syntax error. If you try this
you’ll get a type error and a message saying “Can’t dene singleton.”
The same is true, in both cases, of oating-point numbers and
symbols.
1 class << 10; end
1
2
3
class C 
  # method and constant definitions here 
end
1
2
3
class << object 
  # method and constant definitions here 
end
1
2
3
4
5
6
7
str = "I am a string" 
class << str 
  def twice 
    self + " " + self 
  end 
end 
puts str.twice
1 I am a string I am a string
1
2
3
def str.twice 
  self + " " + self 
end

THE DIFFERENCE BETWEEN DEF OBJ.METH AND CLASS << OBJ;
DEF METH
This question often arises: Is there any di|erence between dening a
method directly on an object (using the def obj.some_method
notation) and adding a method to an object’s singleton class explicitly
(by doing class << obj; def some_method )? The answer is that
there’s one di|erence: constants are resolved di|erently.
If you have a top-level constant N , you can also dene an N  inside an
object’s singleton class:
Given this sequence of instructions, the two ways of adding a singleton
method to obj  di|er in which N  is visible from within the method
denition:
It’s relatively unusual for this di|erence in the visibility of constants
to a|ect your code; in most circumstances, you can regard the two
notations for singleton-method denition as interchangeable. But it’s
N = 1 
obj = Object.new 
class << obj 
  N = 2 
end
1
2
3
4
5
6
7
8
9
10
def obj.a_method 
  puts N 
end 
class << obj 
  def another_method 
    puts N 
  end 
end 
obj.a_method 
obj.another_method

worth knowing about the di|erence, because it may matter in some
situations and it may also explain unexpected results.
Figure 13.1. Method-search order, revised to include singleton classes
class Ticket 
 class << self 
   def most_expensive(*tickets) 
     tickets.max_by(&:price) 
   end 
 end 
end
def Ticket.most_expensive(*tickets)  # etc.
class << Ticket 
 def most_expensive(tickets) 
 # etc.

class Person 
 attr_accessor :name 
end 
david = Person.new 
david.name = "David" 
matz = Person.new 
matz.name = "Matz" 
ruby = Person.new 
ruby.name = "Ruby"
def david.name 
  "[not available]" 
end

puts "We've got one person named #{matz.name}, " 
puts "one named #{david.name}," 
puts "and one named #{ruby.name}."
We've got one person named Matz, 
one named [not available], 
and one named Ruby.
module Secretive 
  def name 
    "[not available]" 
  end 
end
class << ruby 
  include Secretive 
end
We've got one person named Matz, 
one named [not available], 
and one named [not available].
Listing 13.1. Including a module in a singleton class
class C 
  def talk 
puts "Hi from original class!"
Hi from original class! 
Hello from module!

c = C.new 
class << c 
  include M 
  p ancestors 
end
[#<Class:#<C:0x007fbc8b9129f0>>, M, C, Object, Kernel, BasicObject]
class C 
  include M 
end 
class << c 
  p ancestors 
end
[#<Class:#<C:0x007fbc8b9129f0>>, M, C, M, Object, Kernel, BasicObject]
string = "a string" 
p string.singleton_class.ancestors
class C 
end 
def C a
class
method

Figure 13.2. Relationships among classes in an inheritance relationship and their
singleton classes
class D < C 
end 
D.a_class_method
Singleton method defined on C
some_regexp.match(some_string)[1]
string = "A test string" 
re = /A (sample) string/ 
substring = re match(string)[1]
#1
class Regexp 
  alias __old_match__ match                   #1 
def match(string)
/abc/.match("X")[1]

THE TAP METHOD
The tap  method (callable on any object) performs the somewhat odd
but potentially useful task of executing a code block, yielding the
receiver to the block, and returning the receiver. It’s easier to show
this than to describe it:
Called on the receiver "Hello" , the tap  method yields that string
back to its code block, as conrmed by the printing out of the
uppercased version of the string. Then tap  returns the entire string
—so the reverse operation is performed on the string. If you call
gsub!  on a string inside a tap  block, it doesn’t matter whether it
returns nil , because tap  returns the string. Be careful, though.
Using tap  to circumvent the nil  return of gsub!  (or of other
similarly behaving bang methods) can introduce complexities of its
if regexp.match(string) 
  do something 
else 
  do something else 
end
>> string = "Hello there!" 
=> "Hello there!" 
>> string gsub!(/e/ "E")
>> string = "Hello there!" 
=> "Hello there!" 
>> string.gsub!(/zzz/, "xxx") 
=> nil 
>> string 
=> "Hello there!"
>> string = "Hello there!" 
=> "Hello there!" 
>> string gsub!(/e/ "E") reverse!
#1
>> "Hello".tap {|string| puts string.upcase }.reverse 
HELLO 
=> "olleH"

own, especially if you do multiple chaining where some methods
perform in-place operations and others return object copies.
>> string = "Hello there!" 
=> "Hello there!" 
>> string.gsub!(/zzz/, "xxx") 
=> nil 
>> string.reverse! 
=> "!ereht olleH"
class String 
  alias __old_gsub_bang__ gsub! 
  def gsub!(*args, &block) 
    __old_gsub_bang__(*args, &block) 
    self 
  end 
end
>> states = { "NY" => "New York", "NJ" => "New Jersey", 
➥ "ME" => "Maine" }                                              #1 
=> {"NY"=>"New York" "NJ"=>"New Jersey" "ME"=>"Maine"}
#1
>> string = "Eastern states include NY, NJ, and ME." 
=> "Eastern states include NY, NJ, and ME." 
>> while string.sub!(/\b([A-Z]{2})\b/) { states[$1] } 
>>   puts "Replacing #{$1} with #{states[$1]}..." 
>> end 
Replacing NY with New York... 
Replacing NJ with New Jersey... 
Replacing ME with Maine...
>> require 'active_support/core_ext' 
=> true 
>> "person".pluralize 
=> "people" 
>> "little_dorritt".titleize 
=> "Little Dorritt"
class String 
  alias __old_reverse__ reverse 
  def reverse 
    $stderr.puts "Reversing a string!" 
    __old_reverse__ 
  end 
end 
puts "David".reverse

ALIASING AND ITS ALIASES
In addition to the alias  keyword, Ruby has a method called
alias_method , which is a private instance method of Module . The
upshot is that you can create an alias for a method either like this
or like this:
Because it’s a method and not a keyword, alias_method  needs
objects rather than bare method names as its arguments. It can take
symbols or strings. Note also that the arguments to alias  don’t
have a comma between them. Keywords get to do things like that, but
methods don’t.
Reversing a string! 
divaD
class String 
  alias __old_reverse__ reverse 
end
class String 
  alias_method :__old_reverse__, :reverse 
end
>> Time.now.to_s 
=> "2013-12-31 08:37:32 -0500"
>> Time.now.to_s(:db) 
=> "2013-12-31 08:37:40"
>> Time.now.to_s(:number) 
=> " 20131231083748 "
>> Time.now.to_s(:rfc822) 
=> "Tue, 31 Dec 2013 08:38:00 -0500"

class << ruby 
  include Secretive 
end
module Secretive 
  def name 
"[not available]"
class Car 
  def self.makes 
    %w{ Honda Ford Toyota Chevrolet Volvo } 
  end 
end
class Car 
  class << self 
    def makes 
      %w{ Honda Ford Toyota Chevrolet Volvo } 
    end 
  end 
end
module Makers 
  def makes 
    %w{ Honda Ford Toyota Chevrolet Volvo } 
  end 
end 
 
class Car 
  extend Makers 
end
Car.extend(Makers)
p Car.singleton_class.ancestors
[#<Class:Car>, Makers, #<Class:Object>, #<Class:BasicObject>, Class, Module, 
     Object, Kernel, BasicObject]
module GsubBangModier 
  def gsub!(*args, &block) 
super || self
#1

module Shout 
  rene String do                           #1 
def shout
obj.class.ancestors.last == BasicObject
>> BasicObject.new.methods.sort 
NoMethodError: undefined method `methods' for #<BasicObject:0x007fafa308b0d8>
>> BasicObject.instance_methods(false).sort 
=> [:!, :!=, :==, :__id__, :__send__, :equal?, :instance_eval, :instance_exec]
require 'builder' 
xml = Builder::XmlMarkup.new(:target => STDOUT, :indent => 2)            #1 
xml instruct!
#2
<?xml version="1.0" encoding="UTF-8"?> 
<friends> 
  <friend source="college"> 
    <name>Joe Smith</name> 
    <address> 
      <street>123 Main Street</street> 
      <city>Anywhere, USA 00000</city> 
    </address> 
  </friend> 
</friends>
Listing 13.2. Lister  class: Generates indented lists from a BasicObject  subclass
class Lister < BasicObject 
  attr_reader :list 
def initialize
#1
lister = Lister.new 
lister.groceries do |item| 
  item.name { "Apples" } 
  item.quantity { 10 } 

  item.name { "Sugar" } 
  item.quantity { "1 lb" } 
end 
lister.freeze do |f| 
  f.name { "Ice cream" } 
end 
lister.inspect do |i| 
  i.item { "car" } 
end 
lister.sleep do |s| 
  s.hours { 8 } 
end 
lister.print do |document| 
  document.book { "Chapter 13" } 
  document.letter { "to editor" } 
end 
puts lister.list
groceries: 
  name: 
    Apples 
  quantity: 
    10 
  name: 
    Sugar 
 
  quantity: 
    1 lb 
freeze: 
  name: 
    Ice cream 
inspect: 
  item: 
    car 
sleep: 
  hours: 
    8 
print: 
  book: 
    Chapter 13 
  letter: 
    to editor

CHAPTER 14
1 pr = Proc.new { puts "Inside a Proc's block" }
1 pr.call
1 Inside a Proc's block
1 [1,2,3].each {|x| puts x * 10 }
1
2
3
4
def call_a_proc(&block) 
  block.call 
end 
call_a_proc { puts "I'm the block...or Proc...or something." }
1 I'm the block...or Proc...or something.
1
2
p = Proc.new {|x| puts x.upcase } 
%w{ David Black }.each(&p)

Figure 14.1. A phantom Proc  instantiation intervenes between a method call and a
method.
1
2
DAVID 
BLACK
1 [1,2,3].each {|x| puts x * 10 }
1 puts c2f(100)
1
2
3
4
def capture_block(&block) 
  block.call 
end 
capture_block { puts "Inside the block" }
1
2
p = Proc.new { puts "This proc argument will serve as a code block." } 
capture_block(&p)

1 This proc argument will serve as a code block.
capture_block(&p) { puts "This is the explicit block" }
1 capture_block(p)
capture_block(p.to_proc)
class Person 
 attr_accessor :name 
 def self.to_proc 
   Proc.new {|person| person.name } 
 end 
end 
d = Person.new 
d.name = "David" 
m = Person.new 
m.name = "Matz" 
puts [d,m].map(&Person)
%w{ david black }.map(&:capitalize)
["David", "Black"]

%w{ david black }.map {|str| str.capitalize }
%w{ david black }.map &:capitalize
%w{ david black }.map(&:capitalize)
%w{ david black }.map {|str| str.capitalize }
%w{ david black }.map {|str| str.send(:capitalize) }
class Symbol 
  def to_proc 
    Proc.new {|obj| obj.send(self) } 
  end 
end
class Symbol 
  def to_proc 
    puts "In the new Symbol#to_proc!" 
    Proc.new {|obj| obj.send(self) } 
  end 
end
irb --simple-prompt –I. -r sym2proc

>> %w{ david black }.map(&:capitalize) 
In the new Symbol#to_proc! 
=> ["David", "Black"]
  def talk 
    a = "Hello" 
puts a
m = 10 
[1,2,3].each {|x| puts x * m }
def multiply_by(m) 
  Proc.new {|x| puts x * m } 
end
Listing 14.1. Proc  object preserving local context
def call_some_proc(pr) 
  a = "irrelevant 'a' in method scope"          #1  
puts a
'a' to be used in Proc block 
irrelevant 'a' in method scope 
'a' to be used in Proc block
def make_counter 
  n = 0 
return Proc new { n += 1 }
#1

1 
2 
1 
3
pr = Proc.new {|x| puts "Called with argument #{x}" } 
pr.call(100)
Called with argument 100
>> pr = Proc.new {|x| p x } 
=> #<Proc:0x000001029a8960@(irb):1>
>> pr.call 
nil
>> pr.call(1,2,3) 
1
>> lam = lambda { puts "A lambda!" } 
=> #<Proc:0x0000010299a1d0@(irb):2 (lambda)> 
 
>> lam.call 
A lambda!
def m(&block)
def return_test 
  l = lambda { return } 
l call
#1
>> lam = lambda {|x| p x } 
=> #<Proc:0x000001029901f8@(irb):3 (lambda)> 
>> lam.call(1) 
1 
=> 1 

>> lam.call 
ArgumentError: wrong number of arguments (0 for 1) 
>> lam.call(1,2,3) 
ArgumentError: wrong number of arguments (3 for 1)
>> lam = -> { puts "hi" } 
=> #<Proc:0x0000010289f140@(irb):1 (lambda)> 
>> lam.call 
hi
>> mult = ->(x,y) { x * y } 
=> #<Proc:0x00000101023c38@(irb):7 (lambda)> 
>> mult.call(3,4) 
=> 12
lambda {|a,b=1| "Doesn't work in Ruby 1.8 -- syntax error!" }
->(a, b=1) { "Works in Ruby 1.8!" }
class C 
  def talk 
    puts "Method-grabbing test!  self is #{self}." 
  end 
end 
 
c = C.new 
meth = c.method(:talk)
meth.call
Method-grabbing test!  self is #<C:0x00000101201a00>.
class D < C 
end 
 
d = D.new 
unbound = meth.unbind 
unbound.bind(d).call

ALTERNATIVE TECHNIQUES FOR CALLING CALLABLE OBJECTS
Method-grabbing test!  self is #<D:0x000001011d0220>.
unbound = C.instance_method(:talk)
class A 
  def a_method 
    puts "Definition in class A" 
  end 
end 
 
class B < A 
  def a_method 
    puts "Definition in class B (subclass of A)" 
  end 
end 
 
class C < B 
end
c = C.new
c.a_method
Definition in class B (subclass of A)
A.instance_method(:a_method).bind(c).call
Definition in class A
class C 
  def call_original 
    A.instance_method(:a_method).bind(self).call 
  end 
end

So far we’ve exclusively used the call  method to call callable objects.
You do, however, have a couple of other options.
One is the square-brackets method/operator, which is a synonym for
call . You place any arguments inside the brackets:
If there are no arguments, leave the brackets empty.
You can also call callable objects using the ()  method:
Note the dot before the opening parenthesis. The ()  method has to
be called using a dot; you can’t just append the parentheses to a Proc
or Method  object the way you would with a method name. If there are
no arguments, leave the parentheses empty.
THE BINDING CLASS AND EVAL-ING CODE WITH A BINDING
Ruby has a class called Binding  whose instances encapsulate the
local variable bindings in e|ect at a given point in execution. And a
mult = lambda {|x,y| x * y } 
twelve = mult[3,4]
twelve = mult.(3,4)
>> eval("2+2") 
=> 4
print "Method name: " 
m = gets.chomp 
eval("def #{m}; puts 'Hi!'; end") 
eval(m)
Hi!
def abc; puts 'Hi!'; end

top-level method called binding  returns whatever the current
binding is.
The most common use of Binding  objects is in the position of second
argument to eval . If you provide a binding in that position, the string
being eval- ed is executed in the context of the given binding. Any
local variables used inside the eval  string are interpreted in the
context of that binding.
Here’s an example. The method use_a_binding  takes a Binding
object as an argument and uses it as the second argument to a call to
eval . The eval  operation, therefore, uses the local variable
bindings represented by the Binding  object:
The output of this snippet is "I'm a string in top-level
binding!" . That string is bound to the top-level variable str .
Although str  isn’t in scope inside the use_a_ binding  method, it’s
visible to eval  thanks to the fact that eval  gets a binding argument
of the top-level binding, in which str  is dened and bound.
Thus the string "puts str" , which otherwise would raise an error
(because str  isn’t dened), can be eval- ed successfully in the
context of the given binding.
def use_a_binding(b) 
  eval("puts str", b) 
end 
str = "I'm a string in top-level binding!" 
use_a_binding(binding)
p self 
a = [] 
a.instance_eval { p self }
main 
[]
class C 
  def initialize 
    @x = 1 
  end 
end 

THE INSTANCE_EXEC METHOD
instance_eval  has a close cousin called instance_exec . The
di|erence between the two is that instance_exec  can take
arguments. Any arguments you pass it will be passed, in turn, to the
code block.
This enables you to do things like this:
(Not that you’d need to, if you already know the delimiter; but that’s
the basic technique.)
Unfortunately, which method is which—which of the two takes
arguments and which doesn’t—just has to be memorized. There’s
nothing in the terms eval  or exec  to help you out. Still, it’s useful
to have both on hand.
 
c = C.new 
c.instance_eval { puts @x }
string = "A sample string" 
string.instance_exec("s") {|delim| self.split(delim) }            #1 
david = Person.new do 
  name "David" 
  age 55 
end
class Person 
  def initialize(&block) 
instance
eval(&block)
#1
c = Class.new 
c.class_eval do 
def some
method

>> var = "initialized variable" 
=> "initialized variable" 
>> class C 
>>   puts var 
>> end 
 
NameError: undefined local variable or method `var' for C:Class 
        from (irb):3 
>> C.class_eval { puts var } 
initialized variable
>> C.class_eval { def talk; puts var; end } 
=> nil 
>> C.new.talk 
NameError: undefined local variable or method `var' for #<C:0x350ba4>
>> C.class_eval { define_method("talk") { puts var }  } 
=> :talk
>> C.new.talk 
initialized variable
Thread.new do 
  puts "Starting the thread" 
  sleep 1 
  puts "At the end of the thread" 
end 
puts "Outside the thread"
Starting the thread 
Outside the thread
t = Thread.new do 
  puts "Starting the thread" 
  sleep 1 
  puts "At the end of the thread" 
end 
puts "Outside the thread" 
t.join
Starting the thread 
Outside the thread                      #1 
At the end of the thread

FIBERS: A TWIST ON THREADS
In addition to threads, Ruby has a Fiber  class. Fibers are like
reentrant code blocks: they can yield back and forth to their calling
context multiple times.
A ber is created with the Fiber.new  constructor, which takes a code
block. Nothing happens until you tell the ber to resume , at which
point the code block starts to run. From within the block, you can
suspend the ber, returning control to the calling context, with the
class method Fiber.yield .
Here’s a simple example involving a talking ber that alternates
control a couple of times with its calling context:
puts "Trying to read in some files..." 
t = Thread.new do 
  (0..2).each do |n| 
   begin 
    File.open("part0#{n}") do |f| 
      text << f.readlines 
    end 
    rescue Errno::ENOENT 
      puts "Message from thread: Failed on n=#{n}" 
      Thread.exit 
    end 
  end 
end 
t.join 
puts "Finished!"
Trying to read in some files... 
Message from thread: Failed on n=1 
Finished!
t = Thread.new do 
  puts "[Starting thread]"                                 #1 
Thread stop
f = Fiber.new do 
  puts "Hi." 
  Fiber.yield 
  puts "Nice day." 
  Fiber.yield 

Here’s the output from this snippet:
Among other things, bers are the technical basis of enumerators,
which use bers to implement their own stop and start operations.
  puts "Bye!" 
end 
f.resume 
puts "Back to the fiber:" 
f.resume 
puts "One last message from the fiber:" 
f.resume 
puts "That's all!"
Hi. 
Back to the fiber: 
Nice day. 
One last message from the fiber: 
Bye! 
That's all!
require 'socket' 
s = TCPServer.new(3939) 
conn = s accept
telnet localhost 3939
Trying 127.0.0.1... 
Connected to localhost. 
Escape character is '^]'. 
Hi. Here's the date. 
Sat Jan 18 07:29:11 EST 2014 
Connection closed by foreign host.
require 'socket' 
s = TCPServer.new(3939) 
while true 
  conn = s.accept 
  conn.puts "Hi. Here's the date." 
  conn.puts `date` 
  conn.close 
end
require 'socket' 
s = TCPServer.new(3939) 

while true
require 'socket' 
s = TCPServer.new(3939) 
while (conn = s accept)
#1
Listing 14.2. Chat server using TCPServer  and threads
require 'socket'                                          #1   
def welcome(chatter)                                      #2  
chatter print "Welcome! Please enter your name: "
>> a = 1 
=> 1 
>> Thread.new { a = 2 } 
=> #<Thread:0x390d8c run> 
>> a 
=> 2
>> t = Thread.new { Thread.stop; a = 3 } 
=> #<Thread:0x3e443c run> 
>> a 
=> 2 
>> t.run 
=> #<Thread:0x3e443c dead> 
>> a 
=> 3
>> $/ 
=> "\n" 
>> $var = 1 
=> 1 
>> Thread.new { $var = 2; $/ = "\n\n" } 
=> #<Thread:0x38dbb4 run> 
>> $/ 
=> "\n\n" 
>> $var 
=> 2
/(abc)/.match("abc")             
t = Thread.new do 
/(def)/ match("def")

t = Thread.new do 
  Thread.current[:message] = "Hello" 
end 
t.join 
p t.keys 
puts t[:message]
[:message] 
Hello
Listing 14.3. RPS game logic embodied in Games::RPS  class
module Games 
  class RPS 
include Comparable
#1
Listing 14.4. Threaded, networked RPS program using thread keys
require 'socket' 
require_relative 'rps' 
s = TCPServer new(3939)
#1
>> system("date") 
Sat Jan 18 07:32:11 EST 2014 
=> true 
>> system("cat") 
I'm typing on the screen for the cat command. 
I'm typing on the screen for the cat command. 
=> true 
>> system('grep "D"') 
one 
two 
David 
David
>> system("date") 
Sat Jan 18 07:32:11 EST 2014 
=> true 
>> $? 
=> #<Process::Status: pid 28025 exit 0> 
>> system("cat") 
^C=> false 
>> $? 
=> #<Process::Status: pid 28026 SIGINT (signal 2)>

SOME SYSTEM COMMAND BELLS AND WHISTLES
There’s yet another way to execute system commands from within
Ruby: the %x  operator. %x{date} , for example, will execute the date
command. Like the backticks, %x  returns the string output of the
command. Like its relatives %w  and %q  (among others), %x  allows
any delimiter, as long as bracket-style delimiters match: %x{date} ,
%x-date- , and %x(date)  are all synonymous.
Both the backticks and %x  allow string interpolation:
>> system("datee") 
=> nil 
>> $? 
=> #<Process::Status: pid 28037 exit 127>
>> system("date") 
Sat Jan 18 07:32:11 EST 2014 
=> true
>> d = `date` 
=> "Sat Jan 18 07:32:11 EST 2014\n" 
>> puts d 
Sat Jan 18 07:32:11 EST 2014 
=> nil 
 
>> output = `cat` 
I'm typing into cat. Since I'm using backticks, 
I won't see each line echoed back as I type it. 
Instead, cat's output is going into the 
variable output. 
=> "I'm typing into cat. Since I'm using backticks,\nI won't etc. 
>> puts output 
I'm typing into cat. Since I'm using backticks, 
I won't see each line echoed back as I type it. 
Instead, cat's output is going into the 
variable output.
>> `datee` 
Errno::ENOENT: No such file or directory - datee 
>> $? 
=> #<Process::Status: pid 28094 exit 127> 
>> `date` 
=> "Sat Jan 18 07:35:32 EST 2014\n" 
>> $? 
=> #<Process::Status: pid 28095 exit 0>

This can be convenient, although the occasions on which it’s a good
idea to call dynamically evaluated strings as system commands are,
arguably, few.
command = "date" 
%x(#{command})
>> d = open("|cat", "w+")             #1 
=> #<IO:fd 11> 
>> d puts "Hello to cat"
#2
>> open("|cat", "w+") {|p| p.puts("hi"); p.gets } 
=> "hi\n"
>> require 'open3'                                     #1 
=> true 
>> stdin stdout stderr = Open3 popen3("cat")
#2
Listing 14.5. Using Open.popen3  and threads to manipulate a cat  session
require 'open3' 
stdin, stdout, stderr = Open3.popen3("cat") 
t = Thread new do
#1
One 
Two 
Three 
-------- 
 
One 
Two 
Three 
-------- 
Four 
Five 
Six 
-------- 
Four 
Five 
Six 
--------


CHAPTER 15
1
2
3
4
5
6
7
8
9
10
class Cookbook 
  attr_accessor :title, :author 
  def initialize 
    @recipes = [] 
  end 
 
  def method_missing(m,*args,&block) 
    @recipes.send(m,*args,&block) 
  end 
end
1
2
3
4
cb = Cookbook.new 
cb << recipe_for_cake 
cb << recipe_for_chicken 
beef_dishes = cb.select {|recipes| recipe.main_ingredient == "beef" }
1
2
3
4
>> a 
NameError: undefined local variable or method `a' for main:Object 
>> a? 
NoMethodError: undefined method `a?' for main:Object
1
2
3
4
5
6
7
8
9
>> def method_missing(m,*args,&block) 
>>   raise NameError, "What on earth do you mean by #{m}?" 
>> end 
=> nil 
>> a 
NameError: What on earth do you mean by a? 
      from (irb):2:in `method_missing' 
>> BasicObject.new.a 
NoMethodError: undefined method `a' for #<BasicObject:0x4103ac>
1
2
>> a? 
NameError: What on earth do you mean by a??

1
2
3
4
5
6
7
8
9
10
11
12
13
14
class Person 
  attr_accessor :name, :age 
  def initialize(name, age) 
    @name, @age = name, age 
  end 
 
  def method_missing(m, *args, &block) 
    if /set_(.*)/.match(m) 
      self.send("#{$1}=", *args) 
    else 
      super 
    end 
  end 
end
1
2
3
4
person = Person.new("David", 54) 
person.set_age(55) 
p person.age                      
p person.respond_to?(:set_age)
1
2
1
2
3
def respond_to_missing?(m, include_private = false) 
  /set_/.match(m) || super 
end
1
2
55 
true
1
2
person = Person.new("David", 55) 
p person.method(:set_age)
1

1
2
3
4
5
6
7
8
module M 
  def self.included(c) 
    puts "I have just been mixed into #{c}." 
  end 
end 
class C 
  include M 
end
Listing 15.1. Using included  to add a class method as part of a mix-in operation
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
module M 
  def self.included(cl) 
    def cl.a_class_method 
      puts "Now the class has a new class method." 
    end 
  end 
 
  def an_inst_method 
    puts "This module supplies this instance method." 
  end 
end 
 
 
class C 
  include M 
end 
 
c = C.new 
c.an_inst_method 
C.a_class_method
1
2
This module supplies this instance method. 
Now the class has a new class method.
Listing 15.2. Triggering a callback from an extend  event
1
2
3
4
5
6
7
8
9
10
11
12
module M 
  def self.extended(obj) 
    puts "Module #{self} is being used by #{obj}." 
  end 
 
  def an_inst_method 
    puts "This module supplies this instance method." 
  end 
end 
 
my_object = Object.new 

13 my_object.extend(M) 
my_object.an_inst_method
Module M is being used by #<Object:0x007f8e2a95bae0>. 
This module supplies this instance method.
Listing 15.3. Extending an object and including it into its singleton class
module M 
 def self.included(c) 
   puts "#{self} included by #{c}." 
 end 
 def self.extended(obj) 
   puts "#{self} extended by #{obj}." 
 end 
end 
obj = Object.new 
puts "Including M in object's singleton class:" 
class << obj 
 include M 
end 
puts 
obj = Object.new 
puts "Extending object with M:" 
obj.extend(M)
Including M in object's singleton class: 
M included by #<Class:#<Object:0x0000010193c978>>. 
Extending object with M: 
M extended by #<Object:0x0000010193c310>.
class C 
 def self.inherited(subclass) 
   puts "#{self} just got subclassed by #{subclass}." 
 end 
end 
class D < C 
end

THE LIMITS OF THE INHERITED CALLBACK
Everything has its limits, including the inherited  callback. When D
inherits from C , C  is D ’s superclass; but in addition, C ’s singleton
class is the superclass of D ’s singleton class. That’s how D  manages
to be able to call C ’s class methods. But no callback is triggered. Even
if you dene inherited  in C ’s singleton class, it’s never called.
Here’s a testbed. Note how inherited  is dened inside the singleton
class of C . But even when D  inherits from C —and even after the
explicit creation of D ’s singleton class—the callback isn’t triggered:
The output from this program is
C just got subclassed by D.
class E < D 
end
class C 
  class << self 
    def self.inherited 
      puts "Singleton class of C just got inherited!" 
      puts "But you'll never see this message." 
    end 
  end 
end 
 
class D < C 
  class << self 
    puts "D's singleton class now exists, but no callback!" 
  end 
end
D's singleton class now exists, but no callback!

You’re extremely unlikely ever to come across a situation where this
behavior matters, but it gives you a nice X-ray of how Ruby’s class
model interoperates with its callback layer.
class C 
  def self.const_missing(const) 
    puts "#{const} is undefined—setting it to 1." 
    const_set(const,1) 
  end 
end 
 
puts C::A 
puts C::A
A is undefined—setting it to 1. 
1 
1
class C 
  def self.method_added(m)                  #1 
puts "Method #{m} was just dened "
Method a_new_method was just defined.
class C 
  def self.singleton_method_added(m) 
    puts "Method #{m} was just defined." 
  end 
end
Method singleton_method_added was just defined.
class C 
  def self.singleton_method_added(m) 
    puts "Method #{m} was just defined." 
  end 
  def self.new_class_method 
  end 
end
Method singleton_method_added was just defined. 
Method new_class_method was just defined.

obj = Object.new 
def obj.singleton_method_added(m) 
  puts "Singleton method #{m} was just defined." 
end 
 
def obj.a_new_singleton_method 
end
Singleton method singleton_method_added was just defined. 
Singleton method a_new_singleton_method was just defined.
obj = Object.new 
class << obj 
  def singleton_method_added(m) 
    puts "Singleton method #{m} was just defined." 
  end 
 
  def a_new_singleton_method 
  end 
end
class C 
  def singleton_method_added(m)                    #1       
puts "Singleton method #{m} was just dened "
Singleton method a_singleton_method was just defined.
>> string = "Test string" 
=> "Test string" 
>> string.methods.grep(/case/).sort 
=> [:casecmp, :downcase, :downcase!, :swapcase, :swapcase!, :upcase, 
:upcase!]
>>string.methods.grep(/.!/).sort 
=> [:capitalize!, :chomp!, :chop!, :delete!, :downcase!, :encode!, :gsub!, 
    :lstrip!, :next!, :reverse!, :rstrip!, :scrub!, :slice!, :squeeze!, 
    :strip!, :sub!, :succ!, :swapcase!, :tr!, :tr_s!, :upcase!]
string = "Test string" 
methods = string.methods                                     #1 
bangs = string methods grep(/ !/)
#1

def string.surprise!; end
Some bang methods have no non-bang partner: 
surprise!
>> class C; end 
=> nil 
>> C.methods.sort 
=> [:!, :!=, :!~, :<, :<=, :<=>, :==, :===, :=~, :>, :>=, :__id__, :__send__, 
     :allocate, :ancestors, :autoload, :autoload?, :class, :class_eval, 
     :class_exec, :class_variable_defined?, :class_variable_get, 
     :class_variable_set, :class_variables, etc.
$ ruby -e 'o = Object.new; p o.private_methods.size' 
72 
$ ruby -e 'o = Object.new; p o.protected_methods.size' 
0
$ ruby -e 'o = Object.new; p o.private_methods - 
     BasicObject.private_instance_methods(false) - 
     Kernel.private_instance_methods(false)' 
[]
class Person 
  attr_reader :name 
def name=(name)
#1
>> String.methods.grep(/methods/).sort 
=> [:instance_methods, :methods, :private_instance_methods, 
:private_methods,:protected_instance_methods, :protected_methods, 
:public_instance_methods,:public_methods, :singleton_methods]
>> Range.instance_methods(false).sort 
=> [:==, :===, :begin, :bsearch, :cover?, :each, :end, :eql?, :exclude_end?, 
     :first, :hash, :include?, :inspect, :last, :max, :member?, :min, :size, 
     :step, :to_s]]
>> Range.instance_methods(false) & Enumerable.instance_methods(false) 
=> [:first, :min, :max, :member?, :include?]

Listing 15.4. Enumerable  descendants’ overrides of Enumerable  instance
methods
overrides = {}                                               #1 
enum_classes = ObjectSpace.each_object(Class).select do |c|  #2 
c ancestors include?(Enumerable)
Class ARGF.class overrides: to_a 
Class Array overrides: to_a, to_h, first, reverse_each, find_index, sort, 
     collect, map, select, reject, zip, include?, count, cycle, take, 
     take_while, drop, drop_while 
Class Enumerator overrides: each_with_index, each_with_object 
Class Enumerator::Lazy overrides: map, collect, flat_map, collect_concat, 
     select, find_all, reject, grep, zip, take, take_while, drop, drop_while, 
     lazy, chunk, slice_before 
Class Hash overrides: to_h, to_a, select, reject, include?, member? 
Class ObjectSpace::WeakMap overrides: include?, member? 
Class Range overrides: first, min, max, member?, include? 
Class Struct overrides: to_a, to_h, select
class C 
end 
c = C new
#1
[:x, :y]
class << c 
  p private_instance_methods(false) 
end
[:z]
>> class C; end 
=> nil 
>> class D < C; end 
 
=> nil 
>> def C.a_class_method_on_C; end 
=> nil 
>> def D.a_class_method_on_D; end 
=> nil 
>> D.singleton_methods 
=> [:a_class_method_on_D, :a_class_method_on_C]

THE IRB UNDERSCORE VARIABLE
If you run local_variables  in a new irb session, you’ll see an
underscore:
The underscore is a special irb variable: it represents the value of the
last expression evaluated by irb. You can use it to grab values that
otherwise will have disappeared:
>> File.singleton_methods - File.singleton_methods(false) 
=> [:new, :open, :sysopen, :for_fd, :popen, :foreach, :readlines, 
:read, :select, :pipe, :try_convert, :copy_stream]
>> IO.singleton_methods(false) 
=> [:new, :open, :sysopen, :for_fd, :popen, :foreach, :readlines, 
:read, :select, :pipe, :try_convert, :copy_stream]
x = 1 
p local_variables 
[:x] 
p global_variables.sort 
[:$!, :$", :$$, :$&, :$', :$*, :$+, :$,, :$-0, :$-F, :$-I, :$-K, :$-W, :$-a, 
:$-d, :$-i, :$-l, :$-p, :$-v, :$-w, :$., :$/, :$0, :$1, :$2, :$3, :$4, :$5, 
:$6, :$7, :$8, :$9, :$:, :$;, :$<, :$=, :$>, :$?, :$@, :$DEBUG, :$FILENAME, 
:$KCODE, :$LOADED_FEATURES, :$LOAD_PATH, :$PROGRAM_NAME, :$SAFE, :$VERBOSE, 
:$\, :$_, :$`, :$stderr, :$stdin, :$stdout, :$~]
class Person 
  attr_accessor :name, :age 
  def initialize(name) 
    @name = name 
  end 
end 
 
david = Person.new("David") 
david.age = 55 
p david.instance_variables
[:@name, :@age]
>> local_variables 
=> [:_]

Now the Person  object is bound to the variable david .
>> Person.new("David") 
=> #<Person:0x000001018ba360 @name="David"> 
>> david = _ 
=> #<Person:0x000001018ba360 @name="David">
def x 
  y 
end 
 
def y 
  z 
end 
 
def z 
  puts "Stacktrace: " 
  p caller 
end 
 
x
Stacktrace: 
["tracedemo.rb:6:in `y'", "tracedemo.rb:2:in `x'", "tracedemo.rb:14:in 
`<main>'"]
def z 
  raise 
end
tracedemo.rb:10:in `z': unhandled exception 
     from tracedemo.rb:6:in `y' 
     from tracedemo.rb:2:in `x' 
     from tracedemo.rb:13:in `<main>'
Listing 15.5. Beginning of the CallerTools  module, including the Call  class
module CallerTools  
  class Call 
CALL
RE = /( *):(\d+):in `( *)'/
#1
myrubyfile.rb:234:in `a_method' 
   .*        :\d+:in '  .*    '

Listing 15.6. CallerTools::Stack  class
  class Stack 
    def initialize 
stack = caller
#1
require_relative 'callertools' 
def x 
  y 
end 
 
def y 
  z 
end 
def z 
  stack = CallerTools::Stack.new 
  puts stack.report 
end 
x
callertest.rb   12              z 
callertest.rb    8              y 
callertest.rb    4              x 
callertest.rb   16         <main>
Listing 15.7. Deck-of-cards implementation with card-dealing capabilities
module PlayingCards 
  RANKS = %w{ 2 3 4 5 6 7 8 9 10 J Q K A } 
SUITS = %w{ clubs diamonds hearts spades }
Listing 15.8. cardtest.rb: Testing the dealing accuracy of PlayingCards::Deck
require 'minitest/unit'                           #1    
require 'minitest/autorun' 
require
relative 'cards'
$ ruby cardtest.rb 
Run options: --seed 39562 
 
# Running tests: 
 
.. 
 
Finished tests in 0.000784s, 2551.0204 tests/s, 2551.0204 assertions/s. 
 
2 tests, 2 assertions, 0 failures, 0 errors, 0 skips

class MicroTest 
  def self.inherited(c) 
    c.class_eval do 
      def self.method_added(m) 
        # If m starts with "test" 
        #   Create an instance of c 
        #   If there's a setup method 
        #     Execute setup 
        #   Execute the method m 
      end 
    end 
  end 
end
Listing 15.9. MicroTest , a testing class that emulates some MiniTest functionality
require_relative 'callertools' 
class MicroTest 
def self inherited(c)
require_relative 'microtest' 
require_relative 'cards' 
 
class CardTest < MicroTest 
  def setup 
    @deck = PlayingCards::Deck.new 
  end 
 
  def test_deal_one 
    @deck.deal 
    assert_equal(51, @deck.size) 
  end 
 
  def test_deal_many 
    @deck.deal(5) 
    assert_equal(47, @deck.size) 
  end 
end
Assertion passed 
Assertion passed
Assertion failed: 
              microcardtest.rb   11  test_deal_one 
(51 is not 50) 
Assertion passed


