Proof-producing reﬂection for HOL
with an application to model polymorphism
Benja Fallenstein1 and Ramana Kumar2
1 Machine Intelligence Research Institute
2 Computer Laboratory, University of Cambridge
Abstract. We present a reﬂection principle of the form “If ⌜ϕ⌝is prov-
able, then ϕ” implemented in the HOL4 theorem prover, assuming the
existence of a large cardinal. We use the large-cardinal assumption to
construct a model of HOL within HOL, and show how to ensure ϕ has
the same meaning both inside and outside of this model. Soundness of
HOL implies that if ⌜ϕ⌝is provable, then it is true in this model, and
hence ϕ holds. We additionally show how this reﬂection principle can
be extended, assuming an inﬁnite hierarchy of large cardinals, to imple-
ment model polymorphism, a technique designed for verifying systems
with self-replacement functionality.
1
Introduction
Reﬂection principles of the form3 “if ⌜ϕ⌝is provable, then ϕ” have long been
of interest in logic and set theory (see, e.g., Franz´en [5] and Jech [13]). In this
paper, we show how to implement a reﬂection principle for HOL in the HOL4
theorem prover [21], using a novel approach for establishing a correspondence
between the logic and an internal model. Such a reﬂection principle does not
come for free, since by G¨odel’s second incompleteness theorem, HOL cannot
prove itself consistent [6]. We pay with an assumption about the existence of a
“large enough” HOL type. But we endeavour to ensure that this assumption has
the same content as the assumption, commonly studied in set theory [13], of the
existence of a strongly inaccessible cardinal.
Reﬂection is about trying to ﬁt a logic inside itself, so one has to keep two
instances of the logic in mind separately. We use the term inner HOL to refer
to the object logic (the HOL that is formalised) and outer HOL for the meta
logic (the HOL in which inner HOL is formalised). We build upon Harrison’s
formalisation of HOL in itself [11] that was extended in our previous work [15, 16]
to support deﬁned constants. The ﬁrst reﬂection principle we implement uses a
model of inner HOL provided by a large-cardinal assumption, together with the
previously-proved soundness theorem, to show that provability of a proposition
in inner HOL implies its truth in outer HOL.
3 ⌜ϕ⌝refers to ϕ as a syntactic object, represented e.g. by its G¨odel number or by an
abstract syntax tree.

This kind of reﬂection principle is asymmetric: the large-cardinal assumption
used in outer HOL to justify reﬂection cannot be used again in inner HOL to
justify further reﬂection. One setting in which it is useful to lessen this asymme-
try is in constructing and verifying a system that can replace itself (including
the replacement mechanism) by a new version while nevertheless always satisfy-
ing some safety property. We have extended the reﬂection principle above to an
implementation of model polymorphism [3], which enables the use of reﬂective
reasoning multiple times to verify such self-modifying systems.
Our speciﬁc contributions in this paper are as follows:
– A simple approach to deﬁning, in outer HOL, a partial embedding of outer
HOL in inner HOL (§3). We re-use a single polymorphic constant, to inner,
to embody the embedding at (almost) all outer HOL types.
– An algorithm for producing theorems that relate the semantics of inner HOL
terms to their outer HOL counterparts via the embedding (§4). The method
applies to terms that include user-deﬁned constants and types, and therefore
supports construction of a semantic interpretation of constants based on
replaying outer deﬁnitions in inner HOL (§5). Combined with the soundness
theorem for inner HOL, this gives us a reﬂection principle for HOL (§7).
– An extension of the reﬂection principle above to support model polymor-
phism [3] (§8).
– A reduction of the unavoidable assumption on the proof (in previous work)
of soundness and consistency of HOL within HOL to a traditionally-stated
large-cardinal assumption (§6).
All the work we present has been implemented in the HOL4 theorem prover,
and is available online at https://github.com/CakeML/hol-reflection.
Synopsis Our reﬂection principle has two legs: (1) a soundness theorem for HOL
(from previous work) asserting that a provable formula is true in all models, and
(2) a formal correspondence between objects in a particular, reﬂective model
(constructed assuming a large cardinal) and their counterparts outside. The
reﬂection principle works as follows: if a formula ⌜ϕ⌝is provable, the soundness
theorem asserts that ⌜ϕ⌝is true in the reﬂective model of HOL, and via the
correspondence we may conclude that ϕ is true outside the model. The bulk of
our work in this paper is in building the reﬂective model and establishing the
correspondence, particularly in supporting user-deﬁned constants.
2
Background: inner HOL
The starting point for studying reﬂection principles is a formalisation of a logic
inside itself. We use higher-order logic (HOL), the logic of the HOL Light theo-
rem prover [12]. Our formalisation of HOL within itself is described carefully in
previous work [15, 16], but we summarise it brieﬂy in this section.
2

HOL has the syntax of the simply-typed lambda calculus4 and a well-known
semantics in Zermelo set theory. The judgements of the logic are sequents,
(thy,hs) |- c, where c is a formula (a term of Boolean type), hs is a set of formu-
las, and thy speciﬁes the current set of axiom formulas and the current signature
of constants and type operators. The semantics of each type is a non-empty set;
the Boolean type is speciﬁed as a distinguished two-element set (Boolset, with
elements True and False) and function types are speciﬁed as function spaces (a
set of pairs forming a functional relation). The semantics of each term is an ele-
ment of the semantics of its type. The semantics of each sequent is true, written
(thy,hs) |= c, if the semantics of c is true whenever the semantics of all hs are
true, in any model (an interpretation of constants satisfying the axioms) of thy.
Since the semantic objects are sets, we need a model of set theory to deﬁne the
semantics of inner HOL. Our semantics does not pin down a particular model
of set theory. Instead, it is polymorphic: we use an outer HOL type variable,
usually µ, for the universe of sets, and encode the axioms of set theory as a
pair of assumptions, is set theory mem and ∃inf . is inﬁnite mem inf , about a
membership relation, (mem : µ
→
µ
→
bool), on sets. All our semantic
functions take the membership relation mem (and with it the universe µ) as a
parameter, and most theorems about the semantics assume the set-theory axioms
hold. However, for brevity we usually hide5 these parameters and assumptions
when they are obvious in context. We write x ⋖y for inﬁx application of the
mem relation (i.e., mem x y).
The important semantic function in this paper is the semantics of terms,
that is, the function that assigns an element of µ to each term of inner HOL.
We illustrate how it works with an example, considering the semantics of the
inner HOL version of the term λ x. foo y, where the constant (foo : α →β)
is instantiated at the types bool and ind list. The four parameters governing
the semantics are: the membership relation mem (hidden), the signature (s) of
constants and type operators in the theory, the interpretation (i) of constants
and type operators, and the valuation (v) of free term and type variables. We
denote the valuation of type variables by v ty whereas for term variables we use
v tm, and similar subscripts apply to the other semantic parameters. Our use of
interpretations and valuations is intended to be conventional and unsurprising;
we show the example here mainly to make our notation clear.6
termsem stm i v
(Abs (Var "x" Bool)
(Comb (Const "foo" (Fun Bool (Tyapp "list" [Tyapp "ind" [ ]])))
(Var "y" Bool))) =
Abstract Boolset sil (λ sx. sfoo ’ sy)
4 Including, as in Gordon [9], polymorphism (type variables and polymorphic con-
stants) and deﬁned constants and type operators.
5 This is akin to working within an Isabelle [23] locale which ﬁxes µ and mem and
assumes is set theory mem. (We assume inﬁnity only when necessary.)
6 The abstract syntax here is the inner HOL rendition of our example term. Bool and
Fun a b are abbreviations for Tyapp "bool" [ ] and Tyapp "fun" [a; b].
3

The semantics of the given lambda abstraction is a set-theoretic function (created
with Abstract) – in particular the set of two pairs, True 7→sfoo ’ sy and False 7→
sfoo ’ sy. The following equations show how we obtain the semantics of the
applied type operator, the instantiated constant, and the free variable:
sil = ity "list" [ity "ind" [ ]]
sfoo = itm "foo" [Boolset; sil]
sy = v tm ("y",Bool)
Inner HOL supports deﬁned constants and type operators via the current
theory, which is attached to each sequent. The inference system uses a concrete
implementation of each theory as a list of updates. Such a list is called a context
and every context can be viewed abstractly as a theory (written: thyof ctxt).
Contexts are made from ﬁve kinds of update: new type operator, new constant,
new axiom, new deﬁned type operator, and new deﬁned constant. The updates
for deﬁned type operators and constants have preconditions that require sequents
proved in the previous context. If an update upd satisﬁes all the preconditions
to be a valid update of the previous context ctxt, we say upd updates ctxt.
Both the within-theory inference rules and the theory-extending rules for
making updates (except new axiom) have been proved sound with respect to
the semantics. For the inference rules, the soundness theorem states7 that every
provable sequent is true:
⊢(thy,hs) |- c ⇒(thy,hs) |= c
For the extension rules, the soundness theorem states that there exists an ex-
tended interpretation of the new theory that continues to be a model of the
theory. Both theorems require the is set theory mem assumption.
3
An inner copy of outer HOL
Given an outer HOL term, it is straightforward to write a function in ML—
our function is called term_to_deep—that walks the structure of the term and
builds the corresponding inner HOL term. For example, term_to_deep
turns
Suc x
into
Comb (Const "Suc" (Fun Num Num)) (Var "x" Num).
This syntactic connection is straightforward. But what is the relationship be-
tween the semantics of an outer HOL term and its inner counterpart? Let ⌜tm⌝
stand for term to deep(tm). Ideally, we would like a connection between Suc x
and termsem stm i v ⌜Suc x⌝. Such a connection would mean that the structure
of outer HOL terms and types is replicated (indeed reﬂected) within the type
7 To understand the three turnstiles: ⊢denotes provability in outer HOL (and applies
to the whole formula), inﬁx |- denotes provability in inner HOL, and inﬁx |= states
that a sequent is valid according to the semantics of inner HOL.
4

denoted by µ. We cannot expect to reﬂect everything: in particular, we cannot
reﬂect µ within itself, nor anything depending on µ. But we can cover all other
outer HOL types and terms generically.
Our solution is to deﬁne a polymorphic constant, to inner, which sends an
outer HOL term to the element of µ to which it is supposed to correspond. We
show how to prove theorems of the form termsem stm i v ⌜tm⌝= to inner ty tm.
The type of to inner ty is α →µ.8 (We explain the ty argument shortly.)
We do not want to have to specify exactly how to inner creates its (partial)
copy of outer HOL. What is important is that the copy is faithful, which means
to inner is injective. We formalise this injectivity property precisely by saying
that to inner at type α should be a bijection between U(:α) (everything of type
α) and the set9 of elements of some set x in µ. Formally, we deﬁne a well-
formedness condition:
wf to inner f ⇐⇒∃x. BIJ f U(:α) { a | a ⋖x }
Then we deﬁne to inner as an arbitrary well-formed injection, using Hilbert
choice10 as follows:
to inner ty = tag ty ◦εf . wf to inner f
The tag ty part of the deﬁnition wraps the set produced by the well-formed
injection with a tag for the given inner HOL type, ty, thereby avoiding the
possibility of inadvertently sending outer HOL terms with diﬀerent types to the
same element in µ. The need for this tagging is explained in Section 5.
Since Hilbert choice only picks a well-formed injection if one exists, the use-
fulness of to inner at any particular outer HOL type depends on our assuming
(or being able to prove) wf to inner (to inner ty). The automation we describe in
Section 4 produces theorems that assume these well-formedness conditions, and
the automation in Section 5 proves almost all of them.
Of course, since the well-formedness condition on to inner says it is not just an
injection but a bijection, we can also go in the other direction, from inner HOL
terms to their outer counterparts. Given a well-formed injection ina, we denote
the set of terms of type µ that are in its range—that is, the inner representation
of the domain of ina—by range ina. The faithfulness of the representation is
summarised in the following two theorems exhibiting invertibility.
⊢wf to inner ina ⇒∀x. ina−1 (ina x) = x
⊢wf to inner ina ⇒∀x. x ⋖range ina ⇒ina (ina−1 x) = x
8 To be pedantic, to inner also depends on the pervasive mem relation of the set theory.
9 We follow the convention of treating predicates in outer HOL as sets. To be clear
U(:α) is a term of type α →bool, and { a | a ⋖x } is a term of type µ →bool.
These sets-as-predicates are distinct from the Zermelo sets, i.e., the terms of type µ.
10 Also known as indeﬁnite choice, the Hilbert choice principle in HOL pro-
vides a constant (ε), usually written as a binder, together with the axiom
(∃x. P x) ⇒P (εx. P x) which holds for any predicate P.
5

Usually, but not always, ina will be to inner ty for some ty. We use to inner
to reﬂect outer HOL at all types except for those that depend on µ and except
for the two primitive types of HOL: Booleans and function types. The primitive
types must be treated diﬀerently because the semantics of HOL requires them to
be interpreted by a distinguished two-element set and by set-theoretic function
spaces, respectively. We provide specialised constants that map these types to
their intended interpretations instead of an arbitrary set:
bool to inner b = if b then True else False
fun to inner ina inb f =
Abstract (range ina) (range inb) (λ x. inb (f (ina−1 x)))
We have now seen how we intend to reﬂect outer HOL terms into inner
HOL, using to inner ty injections. We next describe an algorithm that produces
a certiﬁcate theorem for (almost) any HOL term, asserting that the semantics
of the inner version of the term matches the reﬂection of the outer version. We
develop this algorithm in two stages: ﬁrst (next section), we ignore the interpre-
tation of constants and the valuation of variables in the semantics and simply
make assumptions about them; then (Section 5), we build an interpretation and
valuation that satisﬁes these assumptions.
4
Proof-producing reﬂection
Let us begin with an example of the kind of theorem produced by the ﬁrst stage
of our automation. Given as input the term Suc x, we produce the following
theorem that looks very long but whose components we will explain one by one.
We call each such theorem a certiﬁcate theorem for the input term.
⊢good context mem s i ∧wf to inner (to inner Num) ∧
lookup stm "Suc" = Some (Fun Num Num) ∧lookup sty "num" = Some 0 ∧
ity "num" [ ] = range (to inner Num) ∧
itm "Suc" [ ] = fun to inner (to inner Num) (to inner Num) Suc ∧
v tm ("x",Num) = to inner Num x ⇒
termsem stm i v ⌜Suc x⌝= to inner Num (Suc x)
First, look at the conclusion11 (the last line): we have produced an equality
between the semantics of the inner version of our input term and its reﬂection
created with to inner. Under what assumptions? The assumptions come in ﬁve
categories:
1. The assumption stated using good context, which represents the pervasive
is set theory mem assumption as well as some basic well-formedness condi-
tions on the signature and interpretation.
11 Num is an abbreviation for Tyapp "num" [ ].
6

2. wf to inner assumptions on all base types appearing in the input term (in
this case, just Num). A base type is any type variable or any application of
a non-primitive type operator. (For the primitives, Booleans and functions,
we prove wf to inner once and for all.)
3. Signature (s) assumptions stating that all non-primitive constants and type
operators in the input term (in this case Suc and num) have the same
type/arity in inner HOL as in outer HOL. (The only primitive constant,
equality, is assumed to have the correct type as part of good context.)
4. Interpretation (i) assumptions stating that the inner versions of all the base
types and constants of the input term are mapped to their reﬂections.
5. Valuation (v) assumptions stating that the inner versions of all type and
term variables in the input term are mapped to their reﬂections.
The algorithm for producing such a theorem works by recursively travers-
ing the structure of the input term. We build a theorem like the one above,
equating the semantics of an inner term to the reﬂection of its outer counter-
part, for each subterm in the input term starting at the leaves and progressing
bottom-up. When we encounter non-primitive type operators and constants we
add signature and interpretation assumptions as required, and similarly add val-
uation assumptions for free variables. The substitution of type variables used to
instantiate a polymorphic constant is easily reﬂected from outside to inside.
This algorithm works because the semantics itself is recursive. For example,
shown below is a theorem about the semantics that our algorithm uses when it
encounters a combination (function application) term. Notice that the theorem
makes two assumptions of the same form as its conclusion – these correspond to
recursive calls in the algorithm.
⊢termsem stm i v ftm = fun to inner ina inb f ∧termsem stm i v xtm = ina x ∧
wf to inner ina ∧wf to inner inb ⇒
termsem stm i v (Comb ftm xtm) = inb (f x)
The analogous theorem for lambda abstractions requires us to prove connec-
tions between inner HOL types and their reﬂections (via range). Therefore, we
have a similar recursive algorithm for types as the one described above for terms.
So far, our certiﬁcate theorems leave the semantic parameters (s, i, and v)
as free variables but make various assumptions about them. Our aim in the next
section is to show how we can instantiate these parameters in such a way that
most of the assumptions become provable. In other words, we show how to build
a reﬂective model that satisﬁes the assumptions in each of the categories above.
5
Building a reﬂective interpretation and valuation
Signature assumptions In outer HOL, types like num and constants like Suc are
all user-deﬁned. Logically speaking, there is a context (typically not represented
explicitly in the theorem prover) that lists the sequence of updates made to pro-
duce the current environment of deﬁned constants. An appropriate signature (s)
7

for a certiﬁcate theorem is one that corresponds to some context for the input
term, which will naturally satisfy all the signature assumptions. We require the
user of our automation to build an explicit representation of the desired context
(although we provide tools to help with this), and with that information proceed
to construct an interpretation and valuation to satisfy the assumptions of the
certiﬁcate theorem.
Algorithm for building the model The idea is to reﬂect the updates from the
outer context into the inner inference system, creating an inner context, and
then, update by update, build an interpretation of the inner context. The inter-
pretation we build must be reﬂective, which means it must satisfy the certiﬁcate
theorem’s assumptions, namely: all the deﬁned constants and types appearing
in the input term are mapped to the reﬂections of their outer versions. We build
the reﬂective interpretation by: (1) starting with the interpretation asserted to
exist by the soundness theorem, and (2) making a ﬁnite number of modiﬁcations
for each update in the context. We work recursively up the context applying the
relevant modiﬁcations for the last-added update at each stage.
Interpretation assumptions Each update introduces some number of type op-
erators, constants, and axioms12 to the theory. Each update thereby induces
some constraints on an interpretation for the interpretation to be reﬂective. For
example, the update that deﬁnes ⌜Suc⌝has an associated constraint that this
constant is interpreted as to inner (Fun Num Num) Suc.
For polymorphic constants and type operators with arguments, the con-
straints are more involved. In general, a constraint is induced by each instance
of the update and constrains the corresponding instance of the introduced con-
stants. Importantly, we only consider instances of the update that correspond
to the ﬁnitely many instances of the deﬁned constants in the input term. We re-
quire to inner to produce distinct reﬂections of distinct types, because otherwise
we cannot reliably distinguish diﬀerent instances of an update.
To show that an interpretation continues to be a model after being con-
strained, we require that at each constrained instance the axioms of the update
are satisﬁed. We can prove this for the constraints we build (which map things
to their reﬂections) because the axioms of the update being replayed are true
in outer HOL. For each constrained instance of an axiom, we use the algorithm
from the previous section to generate a certiﬁcate theorem with assumptions
that are all easy to discharge because the constraint is reﬂective.
wf to inner assumptions To prove the wf to inner assumptions (for deﬁned type
operators) on our certiﬁcate theorems, we use the fact that in outer HOL every
deﬁned type is represented by a predicate on a previously deﬁned (or primitive)
type. The same is true in inner HOL as we build up our interpretation, so the
12 When a new constant or type operator is deﬁned, theorems produced by the deﬁ-
nition are considered axioms of the resulting theory. The other source of axioms is
new-axiom updates, which we do not support since they are not sound in general.
8

wf to inner assumption on a deﬁned type reduces to the wf to inner assumption
on its representing type. These assumptions propagate back recursively to the
base case. The only wf to inner assumptions left after this process are for type
variables in the input term, and for the type of individuals (ind) – this last
assumption may be introduced if not present.
Base case of the algorithm To ﬁnish describing how we build a constrained model
that satisﬁes the assumptions of the certiﬁcate theorem, only the base case of
the recursive algorithm remains. What model do we start with before replaying
all the updates in the context? In our previous work [15, 16] on the soundness
and consistency of HOL, we showed that there is a model for the base context
of HOL (assuming the set-theory axioms, including inﬁnity). We use this model
in the base case of the algorithm for building a reﬂective interpretation, modulo
some subtleties concerning the Hilbert choice operator.
The base context, hol ctxt, includes the primitive types and constants (Booleans,
functions, equality) and the three axioms of HOL (extensionality, choice, and in-
ﬁnity). To state the axioms, the base context also includes some deﬁned constants
(conjunction, implication, etc.), and, importantly, the Hilbert choice constant,
and the type of individuals. Although most constraints are dealt with before
the base case, constraints on Hilbert choice remain. Therefore, we extend the
proof that hol ctxt has a model to show that in fact there is a model satisfying
any ﬁnite number of constraints on the intepretation of Hilbert choice. We also
modify the model to use range (to inner Ind) for the type of individuals.
Valuation assumptions So far we have described the algorithm for building an
interpretation (i) to satisfy the interpretation assumptions on certiﬁcate theo-
rems. To build a valuation (v) satisfying the valuation assumptions, we follow a
similar approach based on constraining an arbitrary valuation so that it maps
the free variables that occur in the input term to their reﬂections. We have not
covered all the gory details of these algorithms, but hope to have shared the
important insights. The ML code for our automation is around 1800 lines long,
supported by around 1000 lines of proof script about constrained interpretations.
6
Set theory from a large-cardinal assumption
Up until now, we have been working under the assumption is set theory mem,
as used in previous work [15, 16], which consists of the set-theoretic axioms of
extensionality, speciﬁcation, pairing, union, and power sets. To produce models
of hol ctxt and all its extensions, we also require the set-theoretic axiom of inﬁnity
(which is implied by wf to inner (to inner Ind)). One of our contributions is to
clarify that these assumptions are implied by a more traditionally-stated large-
cardinal assumption.
Our large-cardinal assumption is strictly stronger than what is necessary for a
model of HOL. We leave proving an equivalence between is set theory mem plus
inﬁnity and a large-cardinal assumption for future work, and here just prove
9

implication from a strongly inaccessible cardinal. The point is to build conﬁ-
dence in our speciﬁcation of set theory, by showing it is implied by a traditional
speciﬁcation (of a strong inaccessible).
We make use of Norrish and Huﬀman’s formalisation [20] of cardinals and
ordinals in HOL4. We write s ≺t to mean the predicate s has smaller cardinality
than the predicate t, i.e., there is an injection from s to t but not vice versa.
Remember that sets and predicates are usually identiﬁed in HOL; we use the
usual notation for sets like x ∈s (x is an element of s) and f ”s (the image of
s under f ) when s is a predicate.
The reduction theorem we have proved is that if some (outer HOL) type,
say µ, is a strongly inaccessible cardinal, then there is a membership relation mem
on that type that satisﬁes is set theory and is inﬁnite. Furthermore, according to
this mem, for every predicate s on the type µ which is strictly smaller than U(:µ),
there is a Zermelo set x whose elements are exactly the extension of s. In this
section, we are explicit with all uses of the type variable µ and the variable mem.
The formal statement of our reduction theorem is:
⊢strongly inaccessible U(:µ) ⇒
∃mem.
is set theory mem ∧
(∀s. s ≺U(:µ) ⇒∃x. s = { a | a ⋖x } ) ∧
∃inf . is inﬁnite mem inf
It is well known that the existence of a strongly inaccessible cardinal gives rise to
a model of set theory [13, Lemma 12.13], and the proof of our reduction theorem
contains no surprises. (The main lemma is that a strongly inaccessible cardinal
is in bijection with its smaller subsets.) Our focus here is on the deﬁnition of
strongly inaccessible, aiming to accurately capture traditional usage.
A cardinal is called “strongly inaccessible” if it is uncountable, a regular
cardinal, and a strong limit cardinal [13]. Assuming the axiom of choice (which
we do as we are working in HOL), a cardinal X is regular iﬀit cannot be
expressed as the union of a set smaller than X all of whose elements are also
smaller than X [13, Lemma 3.10]. Formally:
regular cardinal X ⇐⇒
∀x f .
x ⊆X ∧x ≺X ∧(∀a. a ∈x ⇒f a ⊆X ∧f a ≺X ) ⇒
S (f ”x) ≺X
A cardinal is a strong limit if it is larger than the power set of any smaller
cardinal. This is straightforward to formalise:
strong limit cardinal X ⇐⇒∀x. x ⊆X ∧x ≺X ⇒P(x) ≺X
A cardinal is countable if it can be injected into the natural numbers (this is
already deﬁned in HOL4’s standard library). With these three ideas formalised,
we deﬁne strongly inaccessible as follows:
strongly inaccessible X ⇐⇒
regular cardinal X ∧strong limit cardinal X ∧¬countable X
10

7
Proving reﬂection principles
We now have enough machinery in place to exhibit a reﬂection principle for HOL.
In the examples that follow, we use a two-place predicate Safe t v to construct
our input propositions, to match the example in Section 8. However, Safe can be
considered as a placeholder for any two-place predicate. As a concrete, simple
example, set Safe t v ⇐⇒v ̸= Suc t.
First, let us see how the reﬂection principle works on the input proposition
∀t. Safe t 0. Combining the automation from Sections 4 and 5, we can construct
a certiﬁcate theorem with almost all of the assumptions proved:
⊢is set theory mem ∧wf to inner (to inner Ind) ⇒
termsem (sigof inner ctxt)tm constrained model constrained valuation
⌜∀t. Safe t 0⌝=
bool to inner (∀t. Safe t 0)
Here constrained model and constrained valuation are built as described in Sec-
tion 5: they are a reﬂective model for the context (inner ctxt) that deﬁnes ⌜Safe⌝,
and a reﬂective valuation13 for the input proposition.
Next, consider the inner HOL sequent corresponding to provability of our
input proposition:
(thyof inner ctxt,[ ]) |- ⌜∀t. Safe t 0⌝
The soundness theorem for inner HOL states that if this sequent is provable, then
the semantics of its conclusion is true. Our certiﬁcate theorem above already
tells us that the semantics of the conclusion is equal to the reﬂection of the
input proposition. By deﬁnition of bool to inner, if the reﬂection of a proposition
is true then that proposition holds, hence we obtain:
⊢is set theory mem ∧wf to inner (to inner Ind) ⇒
(thyof inner ctxt,[ ]) |- ⌜∀t. Safe t 0⌝⇒∀t. Safe t 0
There would be additional wf to inner assumptions for each additional type vari-
able in the input term.
The ﬁnal step is to replace the is set theory mem assumption with the large-
cardinal assumption that provides us with a model of set theory. In this model, we
can replace the wf to inner assumption on ind by a lower bound on the cardinality
of µ. Similarly, any wf to inner assumption on a type variable, say α, could be
replaced by an assumption of the form U(:α) ≺U(:µ). Such assumptions can be
satisﬁed by large enough µ, except in the case α = µ; hence, it is important that
µ not occur in the input proposition. The resulting theorem no longer contains
any occurrences of mem, not even hidden ones.
⊢strongly inaccessible U(:µ) ∧U(:ind) ≺U(:µ) ⇒
(thyof inner ctxt,[ ]) |- ⌜∀t. Safe t 0⌝⇒∀t. Safe t 0
13 Any valuation would do for this input since it has no free type or term variables.
11

Thus we have shown that provability of our input proposition implies its truth,
assuming the existence of a large cardinal that is larger than the type of individ-
uals in outer HOL. We can prove a theorem like this for any input proposition
(that does not mention µ), including less obvious and even false propositions.
The reﬂection principle above can be generalised to a uniform reﬂection prin-
ciple [4], which, for an input proposition with a free natural-number variable,
requires an inner-HOL proof about only the relevant value of the variable. We
write ⌜v ⌝for the inner HOL numeral corresponding to the value of the outer
HOL variable v; for example, if v = 1 in outer HOL, then ⌜Safe t v ⌝denotes
the term ⌜Safe t (Suc 0) ⌝. The uniform reﬂection principle for the predicate
∀t. Safe t v is:
⊢strongly inaccessible U(:µ) ∧U(:ind) ≺U(:µ) ⇒
∀v. (thyof inner ctxt,[ ]) |- ⌜∀t. Safe t v⌝⇒∀t. Safe t v
Since v is quantiﬁed in outer HOL, this theorem encapsulates inﬁnitely many
reﬂection theorems of the previous kind. To implement uniform reﬂection, we
deﬁne an outer-HOL function quote : num →term which can be spliced into the
result of term_to_deep to provide terms of the form ⌜v⌝. It is straightforward to
show that the semantics of ⌜v⌝in a reﬂective valuation is equal to the reﬂection
of v, and uniform reﬂection follows.
8
An implementation of model polymorphism
One application of reﬂection principles is in designing and verifying systems that
include mechanisms for self-replacement. For concreteness, consider an operating
system intended to satisfy a certain safety property (e.g., a certain ﬁle is never
overwritten), but also with a mechanism for replacing itself by an arbitrary
updated version. For this system to be safe, the replacement mechanism must
be restricted to prevent replacement by an unsafe update. A simple restriction
would be to require a proof that the updated version is safe until replacement is
invoked, together with a syntactic check that the updated version’s replacement
mechanism (including the proof checker) is unchanged (or that the replacement
mechanism is removed altogether). To verify this system, we need to know that
the system’s proof checker is sound (only admits valid proofs) and we need a
reﬂection principle for its logic (the conclusions of valid proofs are true). But we
only need to establish these properties once.
Things get more interesting if we want to allow updates that might change the
replacement mechanism. A more general replacement mechanism simply requires
a proof that the updated version (including any new replacement mechanisms)
is safe. To verify this system, we need a reﬂection principle to conclude that
any updated version is safe assuming only that it was proved safe before the
update was made. Furthermore, if we want to leave open the possibility that later
updated versions retain a general replacement mechanism, we need a reﬂection
principle that can be iterated.
12

The reﬂection principles in the previous section do not iterate. Using the as-
sumption that a strongly inaccessible cardinal exists and is larger than the type
of individuals they let us prove results of the form “If ⌜ϕ⌝is provable, then ϕ”
for every ϕ not containing type variables. However, the proof of ⌜ϕ⌝may only
make use of the ordinary axioms of HOL: in particular, it cannot in turn assume
that there is a strongly inaccessible cardinal. It is tempting to choose ϕ to be the
formula strongly inaccessible U(:µ) =⇒ψ, for some formula ψ. But this contains
the type variable µ, leading our automation to produce the unsatisﬁable assump-
tion U(:µ) ≺U(:µ). We could instead try to use a diﬀerent type variable, as in
strongly inaccessible U(:ν) =⇒ψ; this would lead to a theorem showing ψ un-
der the assumptions that strongly inaccessible U(:µ), strongly inaccessible U(:ν),
U(:ν) ≺U(:µ), and the provability of ⌜strongly inaccessible U(:ν) =⇒ψ⌝. How-
ever, while the proof in inner HOL may now assume that there is one inaccessible
(ν), the theorem in outer HOL now assumes that there are two strongly inac-
cessible cardinals (ν and µ), one of which is larger than the other.
Indeed, there must always be a stronger assumption in outer HOL than
in inner HOL, since by G¨odel’s second incompleteness theorem, no consistent
proof system as strong as Peano Arithmetic can prove the reﬂection principle for
itself: Choosing ϕ ≡F, the identically false proposition, the assertion “If ⌜F⌝is
provable, then F” is equivalent to “⌜F⌝is not provable”, which asserts consistency
of the proof system. But by the second incompleteness theorem, a suﬃciently
strong proof system which can show its own consistency is inconsistent.
Nevertheless, the construction outlined above can be repeated any ﬁnite
number of times, showing that if there are (n + 1) nested strongly inaccessi-
ble cardinals, then a proposition ϕ holds if it is provable under the assump-
tion that there are n inaccessibles. Formally, we can deﬁne a term LCA of type
num →(µ →bool) →bool such that LCA 0 U(:µ) indicates that ind ﬁts
inside µ, and such that LCA (Suc t) U(:µ) indicates that µ is a strongly inac-
cessible cardinal and there is a strictly smaller subset Q of U(:µ) which satisﬁes
LCA t Q:
LCA 0 P ⇐⇒U(:ind) ≼P
LCA (Suc n) P ⇐⇒strongly inaccessible P ∧∃Q. Q ⊆P ∧Q ≺P ∧LCA n Q
Then, we can show a reﬂection principle of the form “If ⌜LCA t U(:µ) ⇒ϕ⌝
is provable, then LCA (Suc t) U(:µ) ⇒ϕ”. This approach systematises the
idea of allowing stronger systems to reﬂect the reasoning of weaker systems. As
described below, we can strengthen this principle so that it requires proofs not
about particular numerals ⌜t⌝but about a universally quantiﬁed variable t.
To see the relevance to problems like verifying the self-replacing operating
system, consider interpreting Safe t v as “candidate system v, and any up-
dated versions it permits, behave safely for t updates”, hence we want to show
∀t. Safe t v0 for the initial system v0. Suppose we have proved Safe 0 v0, that
is, we have veriﬁed the initial system except for its replacement mechanism, and
suppose the initial replacement mechanism requires a proof of the proposition
⌜∀t. LCA t U(:µ) ⇒Safe t v⌝before installing update v. We need, for all t, to
13

show Safe (Suc t) v0, but this is equivalent to showing Safe t v for all v that
satisfy the replacement mechanism’s proof requirement. The following reﬂection
principle enables us to do just that, provided we assume LCA (Suc t) U(:µ).
⊢∀v.
(thyof inner ctxt,[ ]) |- ⌜∀t. LCA t U(:µ) ⇒Safe t v⌝⇒
∀t. LCA (Suc t) U(:µ) ⇒Safe t v
Furthermore, the same reﬂection principle can be used within the proof required
by the replacement mechanism, because the increase in the value of t passed to
LCA is cancelled out by the decrease in the argument to Safe when considering
a new version.
To prove the theorem above (for any predicate Safe t v not containing type
variables), our automation shows that for every natural number t, LCA (Suc t) U(:µ)
implies the existence of a model of inner HOL in which ⌜LCA t U(:µ)⌝is true
(with the inner variable t being interpreted to equal its outer value). Thus, if the
implication in the assumption of the theorem is provable, then ⌜Safe t v⌝is true
in this model as well, and by our link between inner and outer HOL, it follows
that Safe t v.14
At the top level, we are still left with the assumption of LCA (Suc t) U(:µ)
for every t. A model of HOL in which this assumption is true can easily be
constructed, for example, in ZFC extended with the much stronger assumption
that there is a Mahlo cardinal [13, Chapter 8], a strongly inaccessible cardinal κ
such that there are exactly κ strongly inaccessibles ≼κ. The assumption that a
Mahlo cardinal exists is not uncommon in set-theoretical work, and has been used
in studies of dependent type theory to justify inductive-recursive deﬁnitions [2].
9
Related work
Reﬂection principles of the form “If ⌜ϕ⌝is provable, then ϕ”, as well as the uni-
form reﬂection principle “If ⌜ϕ(n)⌝is provable, then ϕ(n)”, have been studied
by Turing [22] and Feferman [4]. These authors consider sequences of theories
obtained by starting with a theory T0 (Peano Arithmetic, say), and repeat-
edly constructing theories Tα+1 by adding to Tα the reﬂection principle for all
theories Tβ, β ≤α. One can extend these sequences transﬁnitely by letting
Tλ := S
α<λ Tα at limit ordinals λ. Turing and Feferman showed that, in a
rather technical sense, sequences constructed in this way prove every true sen-
tence of arithmetic (see Franz´en [5] for an introduction, including an explanation
why this statement is not as strong as it may appear). Set theorists have been
interested in reﬂection principles, provable in ZF, which show that a sentence ϕ
is true if it is provable from a ﬁxed ﬁnite subset of ZF [13].
In the interactive theorem proving community, interest in reﬂection principles
has mainly come from the perspective of computational reﬂection [10], which
14 Our proof constructs a potentially slightly diﬀerent model of inner HOL for each
value of t; this is, roughly, the origin of the term model polymorphism.
14

justiﬁes the use of an eﬃcient decision procedure by proving that if the decision
procedure declares a sentence to be true, the sentence is in fact provable. For
example, Allen et al. [1] extend Nuprl with a reﬂection rule, an inference rule to
infer ϕ from “⌜ϕ⌝is provable”. To avoid inconsistency, they stratify their rule
in a manner similar to the transﬁnite progressions of Turing and Feferman: each
invocation of the reﬂection rule is annotated with a level, ℓ, and an invocation
at level ℓrequires a proof that ⌜ϕ⌝is provable using the reﬂection rule only
at levels < ℓ. Perhaps the most systematic use of reﬂection to justify more
complex inference rules from simpler ones is in Milawa [18], which allows its
entire proof checker to be replaced by a new version when given a proof that
all sentences which are provable according to the new proof checker were also
provable according to the old one.
Harrison [10], reviewing a large number of arguments and proposals for com-
putational reﬂection, ﬁnds no evidence that it ever makes an otherwise infeasible
proof technique feasible, though he concedes that in some cases, the speed-up
can be signiﬁcant. More recently, Coq’s ssreflect library [8] for computational
reﬂection has been instrumental in the formal veriﬁcation of the four-color the-
orem [7].
The algorithm in Section 4 bears a strong resemblance to the proof-producing
translation (or code generation) algorithm presented by Myreen and Owens [19].
The input term in their algorithm is also an outer HOL term, but the target,
instead of inner HOL, is the functional programming language CakeML. The
semantics of CakeML is very diﬀerent from the semantics of inner HOL, but the
overall approach of producing certiﬁcate theorems bottom-up works similarly.
10
Conclusion
We have described automation for proving reﬂection principles of the form “If
⌜ϕ⌝is provable, then ϕ” from assumptions about the existence of large cardi-
nals. Based on this work, we have discussed an implementation of model poly-
morphism [3], which allows reﬂective reasoning to be used in the veriﬁcation of
self-replacing systems.
In this paper, we have focused on the automation for proving reﬂection
principles. In future work, we plan to apply this to an implementation of a
self-modifying, self-verifying system. It would also be interesting to apply these
techniques to create an extensible version of HOL, similar to Milawa [18]; in par-
ticular, where Milawa requires a proof that a new version of the proof checker
is conservative (i.e., only accepts proofs of propositions that were also provable
according to the old proof checker), our semantic approach would allow us to
instead require a proof that the new version is sound (i.e., whenever it accepts a
proof of a proposition, that proposition is semantically true). It would be inter-
esting to explore how these syntactic and semantic extension principles compare
in practice.
Acknowledgements We thank Magnus Myreen for feedback on a draft of this
paper. We also thank the anonymous reviewers for their helpful criticism.
15

References
1. Allen, S.F., Constable, R.L., Howe, D.J., Aitken, W.E.: The semantics of reﬂected
proof. In: Proc. LICS. pp. 95–105. IEEE Computer Society (1990)
2. Dybjer, P., Setzer, A.: A ﬁnite axiomatization of inductive-recursive deﬁnitions.
In: Girard, J. (ed.) Proc. TCLA. LNCS, vol. 1581, pp. 129–146. Springer (1999)
3. Fallenstein, B., Soares, N.: Vingean reﬂection. Tech. rep., Machine Intelligence
Research Institute, Berkeley, CA (2015)
4. Feferman, S.: Transﬁnite recursive progressions of axiomatic theories. J. Symb.
Log. 27(3), 259–316 (1962)
5. Franz´en, T.: Transﬁnite progressions: a second look at completeness. B. Symb. Log.
10(3), 367–389 (2004), http://www.math.ucla.edu/~asl/bsl/1003/1003-003.ps
6. G¨odel, K.: ¨Uber formal unentscheidbare S¨atze der Principia Mathematica und ver-
wandter Systeme I. Monatshefte fr Mathematik und Physik 38(1), 173–198 (1931)
7. Gonthier, G.: The four colour theorem: Engineering of a formal proof. In: Kapur,
D. (ed.) ASCM. LNCS, vol. 5081, p. 333. Springer (2007)
8. Gonthier, G., Mahboubi, A.: An introduction to small scale reﬂection in Coq. J.
Form. Reasoning 3(2), 95–152 (2010)
9. Gordon, M.: From LCF to HOL: a short history. In: Plotkin, G.D., Stirling, C.,
Tofte, M. (eds.) Proof, Language, and Interaction, Essays in Honour of Robin
Milner. pp. 169–186. The MIT Press (2000)
10. Harrison, J.: Metatheory and reﬂection in theorem proving: A survey and critique.
Tech. Rep. CRC-053, SRI, Cambridge, UK (1995), http://www.cl.cam.ac.uk/
~jrh13/papers/reflect.dvi.gz
11. Harrison, J.: Towards self-veriﬁcation of HOL Light. In: Furbach, U., Shankar, N.
(eds.) Proc. IJCAR. LNCS, vol. 4130, pp. 177–191. Springer (2006)
12. Harrison, J.: HOL Light: An overview. In: Berghofer, S., Nipkow, T., Urban, C.,
Wenzel, M. (eds.) Proc. TPHOLs. LNCS, vol. 5674, pp. 60–66. Springer (2009)
13. Jech, T.: Set theory. The third millenium edition, revised and expanded. Springer
Monographs in Mathematics, Springer (2003)
14. Klein, G., Gamboa, R. (eds.): Proc. ITP, LNCS, vol. 8558. Springer (2014)
15. Kumar, R., Arthan, R., Myreen, M.O., Owens, S.: HOL with deﬁnitions: Semantics,
soundness, and a veriﬁed implementation. In: Klein and Gamboa [14], pp. 308–324
16. Kumar, R., Arthan, R., Myreen, M.O., Owens, S.: Self-formalisation of higher-order
logic. J. Autom. Reasoning (2015), submitted. Preprint at https://cakeml.org.
17. Mohamed, O.A., Mu˜noz, C.A., Tahar, S. (eds.): Proc. TPHOLs, LNCS, vol. 5170.
Springer (2008)
18. Myreen, M.O., Davis, J.: The reﬂective Milawa theorem prover is sound - (down
to the machine code that runs it). In: Klein and Gamboa [14], pp. 421–436
19. Myreen, M.O., Owens, S.: Proof-producing translation of higher-order logic into
pure and stateful ML. J. Funct. Program. 24(2-3), 284–315 (2014)
20. Norrish, M., Huﬀman, B.: Ordinals in HOL: transﬁnite arithmetic up to (and
beyond) ω1. In: Blazy, S., Paulin-Mohring, C., Pichardie, D. (eds.) Proc. ITP.
LNCS, vol. 7998, pp. 133–146. Springer (2013)
21. Slind, K., Norrish, M.: A brief overview of HOL4. In: Mohamed et al. [17], pp.
28–32
22. Turing, A.M.: Systems of logic based on ordinals. Proc. LMS 2(1), 161–228 (1939)
23. Wenzel, M., Paulson, L.C., Nipkow, T.: The Isabelle framework. In: Mohamed
et al. [17], pp. 33–38
16

