Python 3 Programming 
 
A  Beginner Crash Course Guide to 
Learn Python 3 in 1 Week 
 
 
 
 
 
 
 
 
 
 
 
 
Timothy C. Needham 
 

Copyright 2018 - All Rights Reserved – Timothy C. Needham 
 
ALL RIGHTS RESERVED. No part of this publication may be reproduced or 
transmitted in any form whatsoever, electronic, or mechanical, including 
photocopying, recording, or by any informational storage or retrieval system without 
express written, dated and signed permission from the author. 
 

Table of Contents 
 
Introduction 
Chapter One: An Introduction to Python 
Running Python 
Installing on Windows 
Installing on Other Systems 
Choosing the Right Version 
Learning while having fun 
Choosing to Code 
Using a Text Editor 
Using an Integrated Development Environment 
Getting Started 
Creating your own files 
 
Chapter Two: How to Design a Software 
Design your software 
Asking the right questions 
How to use Python to solve problems 
Identifying the problem 
What must the software do? 
Who will use the software? 
What systems will be used? 
Define the program 
Understanding the Audience 
Watching Users 
Compiling User Stories 
Identifying the Solution 

Understanding the Problem 
Understanding what the software needs to do 
Considering Limitations 
Defining the Results 
Refining the program 
Breaking the Solution Down 
Organizing Tasks into Steps 
Using Subgroups and Indentation 
Coding the Design 
Turning the Design into Executable Code 
Refining the Design 
Testing the Design 
Breaking down the Jargon 
 
Chapter Three: Data Types and Variables 
Choosing the right identifier 
Python Keywords 
Understanding the naming convention 
Creating and Assigning Values to Variables 
Recognizing different types of Variables 
Working with Dynamic Typing 
The None Variable 
Using Quotes 
Nesting Quotes 
How to use Whitespace Characters 
How to Create a Text Application 
Working with Numbers 
Computers only count to one 

Using Boolean 
Using Whole Numbers 
Performing Basic Mathematical Operations 
Working with Floats and Fractions 
Converting Data Types 
Breaking down Jargon 
 
Chapter Four: Conditional Statements 
How to Compare Variables 
Manipulating Boolean Variables 
Combine Conditional Expressions 
The Assignment Operator 
How to control the process 
How to deal with logical errors 
Using the conditional code 
Loops 
While Statement 
Nesting Loops 
Breaking Down Jargon 
 
Chapter Five: Data Structures 
Items in sequences 
Tuples 
Creating a Tuple 
Changing Values in a Tuple 
List 
Creating a List 
Modifying a List 

Stacks and Queues 
Dictionaries 
Breaking down Jargon 
 
Chapter Six: Working with Strings 
Splitting Strings 
Concatenation and Joining Strings 
Editing Strings 
How to Match Patterns 
Creating a Regular Expression Object 
 
Chapter Seven: How to Use Files 
How to Open Files 
Modes and Buffers 
Reading and Writing 
Closing Files 
 
Chapter Eight: Working with Functions 
Defining a Function 
Defining Parameters 
Documenting your Function 
Working with Scope 
Understanding Scope 
Manipulating Dictionaries and Lists 
Abstraction 
 
Chapter Nine: Solutions 
Concatenate two strings 

Sum of Two Numbers 
Even and Odd Numbers 
Fibonacci Series 
Palindrome 
Access Elements in a List 
Slice a List 
Delete Elements in a List 
Access Elements in a Tuple 
Change a Tuple 
Create a String 
 
Conclusion 
Other Books By Timothy C. Needham 
Did you enjoy this book? 
Sources 
 
 

Introduction 
 
Have you always wanted to learn how to program in Python? If the 
answer to that question is yes, you have begun one of the greatest 
adventures of this century. It is easy to learn to program since there is no 
specialized equipment that you need to purchase to run the programs. 
All you need is the right version of the software, a good computer and 
operating system. You can learn to program from the comfort of your 
own home.  
Python is one of the best languages with which one can learn how to 
program. There are multiple reasons why, but the simplest explanation is 
that Python is easy to read and write. It does not take too much time to 
write a working code since the language has a simple syntax, which 
makes it easy to write the code. This book acts as a guide for a beginner.  
This book provides information on how one should code when using 
Python and what attributes of Python can be used to make the program 
simple. You can never trust someone who says they know everything 
about programming. New versions of Python are built regularly to 
improve the user experience. This book provides information on 
different aspects of the language and will help you learn more about 
different structures and functions in Python.  
You have to keep in mind that the more you learn about programming 
the better you get at it. You will learn different ways to adapt your 
programming style to overcome some problems. There are a few 
exercises that have been given in the book to help you improve on 
writing code. I urge you to try to write the code before you look at the 
solutions that have been provided in the last chapter.  
I hope you enjoy the journey you are about to begin. Power up that 
computer and prepare yourself for a few solid hours of programming.  
Also, the only thing I ask is if you could please leave a review after 
listening this book on the Audible site. 
 

Chapter One: An Introduction to Python 
 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
 
Running Python 
Python is a software that can be installed and run on multiple operating 
systems including Mac OS X, or OS/2, Linux, Unix and Windows. If you 
are running Python on GNU/Linus or Mac OS X, you may already have 
the software installed in the system. It is recommended to use this type 
of system since it already has Python set up as an integral part. The 
programs in this book work on every operating system.  
 
Installing on Windows 
If you are using Windows, you will need to install Python and configure 
certain settings correctly before you start working on the examples given 
in this book. To do that, you must refer to specific instructions provided 
for your operating system on the following Python web pages:  
• http://wiki.Python.org/moin/BeginnersGuide/Download  
• http://www.Python.org/doc/faq/windows/  
• http://docs.Python.org/dev/3.0/using/windows.html  
 
You will first need to download the official installer. Alternative versions 
for 
AMD 
and 
Itanium 
machines 
are 
available 
at 
http://www.Python.org/download/. This file, which has an .msi 
extension, must be saved at a location that you can find easily. You can 
then double-click this file to start the Python installation wizard, which 
will take you through the installation. It is best to choose the default 
settings if you are unsure of the answers.  
 
Installing on Other Systems 
You may choose to install Python on other systems, if you want to take 
advantage of the latest versions of Python. The instructions for Unix-like 
and Linux systems can be found at the following links:  
• http://docs.Python.org/dev/3.0/using/unix.html  

If you’re using OS X, your instructions are here:  
• http://www.Python.org/download/mac/  
• http://docs.Python.org/dev/3.0/using/mac.html 
 
 
Choosing the Right Version 
Different installers include different numbers after the word Python that 
refers to the version number. If you look at the archives on multiple 
websites, the version numbers will range from 2.5.2 to 3.0 where the 
former is an old but usable version of Python while the latter is the latest 
version. The Python team released the version 2.6 at the same time that 
it released the version 3.0, since there are some people who may still 
want to stick to version 2 of Python since they want to continue to write 
code the old way but still want to benefit from general fixes and some of 
the new features introduced in version 3.0.  
The Python language is continuously evolving; version 3.0 has become 
the norm and has evolved into version 3.1.1. The newer versions of 3.0 
are refinements of version 3.0. Therefore, the newer versions will 
continue to be referred to as 3.0 in this book. Version 3.0 includes 
several changes to the programming language that are incompatible with 
version 2.0. You do not have to worry about programming using 
different versions of Python since there is only a subtle difference in the 
language or syntax.  
There may be some differences running Python on other operating 
systems, which will be pointed out in the book wherever necessary. 
Otherwise, the codes in the book will work in the same way across 
different operating systems. This is one of the many good points of 
Python. For the most part, this book will concentrate on the fun part—
learning how to write programs using Python. If you wish to learn more 
about Python, you should read the documentation prepared by the 
developers, which is free and well-written. It is available on at 
http://www.Python.org/doc/. 

 
 
Learning while having fun 
On most occasions, people do not want to have fun when they work on 
technical disciplines since fun is underestimated. Every human being 
only learns a subject well when he or she is having fun with it. 
Developing software using Python is often an engrossing and enjoyable 
experience, partly because you can test out your changes as soon as you 
have made them without having to perform any intermediary steps.  
Unlike many other languages, Python takes care of most background 
tasks making it easier for you to focus on the code and the design of your 
code. This makes it easy for the user to stay in the creative flow and 
continue to develop and refine the program.  
Python is easy to read and is one of many languages that use a syntax 
that is closer to English. Therefore, you spend less time trying to 
understand what you have written, which means that you have more 
time on hand to understand how the code can be improved and how you 
can expand the code to encompass different aspects.  
Another good thing about Python is that it can be used to complete any 
task, regardless of how big or small the task may be. You can develop 
simple text-driven or numerical based programs as well as major 
graphical applications. There are some limitations to the language, but 
before you identify them you will have already become adept at 
programming that will help you know how to work around that 
limitation.  
 
 
Choosing to Code 
 
Using a Text Editor 
People often choose to create or write Python scripts using plain text 
editors that have basic programming features. Programs like Kate, 
NEdit, gedit, BBedit and notepad (preferably notepas2/++) are the best 
ones to use for this task. Multiple editors are available that offer specific 
enhancements for programmers, such as syntax highlighting, which is 

useful for showing coding errors immediately as you type. Old-school 
programmers may choose to use Emacs or Vi. The language does not 
require specific software that needs to be used to create the code; that 
choice is up to you. Do not attempt to use word-processing software, 
such as Word or Open Office for this task; it will mess up badly.  
 
Using an Integrated Development Environment 
An integrated development environment (IDE) is a graphical interface 
with lots of useful features designed to make programming with Python 
even easier. You still have to type the code in the same way, but you can 
do all your coding using a single application, and these programming 
environments can provide some useful shortcuts and reminders. There 
are now several Python-specific IDEs. Popular applications include IDLE 
(which is bundled with Python itself), Eric (you may notice a theme here, 
nudge nudge, wink wink, say no more...), Geany, DrPython and SPE. 
More general programming environments like Bluefish and a whole host 
of others also support Python. This book doesn’t cover the use of IDEs or 
any of the alternative distributions of Python, because each of these 
approaches would require a chapter unto themselves, at the very least. 
However, the examples contained in this book will still work if you do 
choose to explore these options. This book will take the simplest 
approach, using tools that come as standard with most operating 
systems; that is, a text editor and the Python Interactive Shell. 
 
Getting Started 
When you sit down to write a new program, you must remember that it 
starts with a problem. Before you write code for anything, you have to 
develop an idea of what it is that you would like to create and the 
problem that you are looking to solve. This will help you develop a fair 
idea on how you would like to solve the problem. Over the course of the 
next chapter, we will look at the software development cycle, which will 
help you through the process of designing the software. This is a step 
that most people will need to learn separately since most programming 
guides usually switch to the intricacies of the language and focus on how 
to develop code which can make it difficult for a beginner to understand 
how to understand the code and what needs to be done to fix that code. 
Understanding the principles of software design can dramatically speed 
up the process of creating new software and help ensure that important 
details are not missed out.  

In the subsequent chapters, you will learn to build the designs and ideas 
in Python and learn to construct the basic units of the codes using words, 
data and numbers. You will also learn how to manipulate these inputs to 
refine the code. It is important to learn how to compare different sets of 
data to make informed decisions. Over the course of the book, you will 
learn to refine the designs you have created and break them down into 
portions that can be coded easily. These steps will help to expand your 
understanding of the language and help you turn your ideas into 
complete computer programs.  
 
Creating your own files 
Python is described as a self-documenting language; it does not mean 
that the user manual is written for you by Python. However, you can add 
documentation strings, which are defined as blocks of text, to your script 
or code. These documentation strings will show up when you open your 
code that can then be turned into web pages that provide useful 
references to those looking for similar code. An example of 
documentation strings has been provided in the subsequent chapters 
and it is important to learn to include documentation strings in your 
code at an early stage.  
 
 
If  you are enjoying the audiobook, I would love if you went to Audible and leave a short 
review. 
 
 

Chapter Two: How to Design a Software 
 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
 
If you were like most programmers, you would have jumped to the third 
chapter to learn more about how to build a program and may have 
bumped into an issue. However, this chapter will help you turn your 
problem into a working program.  
 
Design your software 
There are multiple reasons why one may want to write his or her own 
code to develop an application that does exactly what you want it to do. 
You may already have an idea of something you wish to achieve, which 
led you to pick up this book in the first place. You may need to develop a 
solution for work, you may have an amazing idea in mind that you want 
to develop or you may want to perform some analyses using Python; you 
can develop any type of program through Python. You may already have 
the program you need, if only it would do this one extra thing, or maybe 
you just enjoy the idea that writing your own software is possible. 
The first step that you should take is to ask questions. You must never 
refrain from asking the right questions. There are times when you may 
wonder why you should make the effort to ask people questions since 
there are some people who believe that they should dive into writing 
code without wasting any time. It is important to break the idea down 
into smaller fragments to develop a well-structured idea. This will help 
you develop a strong code. You have to remember that you are trying to 
make your life easier.  
 
 
 
Asking the right questions 
It is important to ask yourself why you are developing every module, 
function, project and line of code. You must ask yourself this right before 
you begin the process. There are is a possibility that someone out there 

has already written the code you want to develop or at least has written 
something very similar to it. You can use this code and convert it to suit 
your needs.  
You have to also ask yourself if there is a simpler way to work on the 
problem. Every programmer must learn to be lazy since that helps him 
or her identify a simpler way to work on the code. That way you will not 
have to work on the program from scratch and you do not need to learn 
everything from scratch. Most programmers tend to learn as they go 
along, but the art of programming does not have too much to do with 
memorizing code. Instead, you must identify the logical procedure and 
simplify the concept that you have in mind. The first task is extremely 
simple in the sense that you must only ask the right questions to break 
your idea down. However, you will encounter more complex problems as 
you progress and will also learn to develop ideas of your own.  
 
 
 
 
 
How to use Python to solve problems 
Programmers use a language called pseudocode to design software and 
Python is one of the only fee languages that are synonymous with 
pseudocode. The difference here is that you can run the code written in 
Python to obtain a result. This language is easy to read, does not require 
compiling and is fun to learn. Your scripts can be run immediately once 
you have saved it since you do not need to call upon the compiler or any 
other function to run the script. Unlike other languages, Python can be 
used to solve a wide range of problems easily since there are many 
preconstructed functions or modules that deal with the menial computer 
tasks. Experts have said that Python is similar to playing with building 
blocks since the elements of the language are easy to grasp and they can 
be combined in any way possible to create a graceful and complex 
structure.  
A great feature of Python is that it is a self-documenting language. You 
have to write the documentation yourself but blocks of text called 
documentation strings or docstrings can be including within the 
structure of the program. This feature is used by most programmers to 
keep the design ideas in one file that helps them think about the program 
and work on the code as they go along. You can also take a look at your 
old code and understand what it was that you were trying to achieve 
when you had written that code. These docstrings will help you and other 

programmers understand how your program functions and what the 
need for such a program is.  
 
 
 
Identifying the problem 
Before you start coding anything, you need to have an idea or a problem 
that you wish to solve. It is quite useful to start with a familiar repetitive 
task that you suspect could be performed more efficiently using a simple 
script. Your first problem is to find out how to communicate with your 
computer using Python and how to get your computer to communicate 
back. Using this as an example, I will briefly explain the stages of the 
software development cycle that most programs will go through in 
course of their development. You don’t have to slavishly follow all the 
suggestions in this chapter, but you may find that they provide a useful 
structure for developing more complex applications and to get you back 
on track if you find yourself getting lost. It is also useful to be able to 
design your program before having to think about the details of coding it 
in a formal computer language.  
The first stage of writing any new program is to grow a design out of the 
initial problem, a sequence of actions that will calculate the correct result 
and create the required output. Once the idea has passed the “Why 
bother?” test, it is necessary to create a simple framework on which to 
hang the various bits of code that you come up with. Without such a 
framework, it is virtually impossible and difficult to construct a simple 
script. We often tend to complicate the code and are left with a messy 
code in the end. The great news is that no specialized knowledge is 
required at this stage. The process can be started off by answering a few 
simple questions:  
• What do you want the software to do? 
• Who will be using it?  
• What system will users be running it on? 
 
 
 
 
 
What must the software do? 
You have to first write the problem you want to tackle down and why you 
want to solve that problem. This step will help you understand what it is 
that you want the software or code to do. You can use a simple text editor 
for this step. Start with some simple tasks that you know a computer can 
do, like adding a few numbers or updating strings or catalogues. It is 

difficult to identify the problem in the beginning. It is important to 
understand the problem better so you can identify the solution. Save the 
file as plain text (with the .txt extension) and give it the title of your 
program-to-be. In the next chapter, you will learn to write a code to get 
your computer to print a statement on your output window.  
 
 
 
Who will use the software? 
You must then specify your target audience, regardless of whether you 
are doing it for yourself. Write your target audience down and make a list 
of every person who will use this program.  
• Family 
• Relatives  
• Friends  
• Work mates  
• Clients or anonymous users 
• Registered users  
How do you want the audience to interact with the application you have 
built?  
• Use a text interface  
• Click a single button  
• Answer a complex form  
Do you need this audience to be adept at programming?  
• Should the application be self-explanatory? 
• Will they need to learn the ropes?  
 
 
 
What systems will be used?  
You have to know if the program you build will work on different 
operating systems. If you want it to run only on one operating system, 
you must let the users know. The program you build may also be 
accessed by clients through different types of systems through Internet 
applications and can use different hardware or software in the device. 
You have to also let the users know if they must download or install 
software for the computer to decode your script or program.  
These questions are important to answer at the initial stages of 
development since they may have a huge impact on the process in the 
future. Keep the answers simple ay this stage, but make sure you answer 
most of them since you will be prepared for any challenges or obstacles. 

If you can’t answer some of the questions yet, that’s fine too. This 
chapter will help you break your answers down into simpler steps, but 
before you move to that step, you must ask the right questions.  
 
Define the program 
It can be useful to create a list of the things you want the software to do 
and what it is you want to achieve by building this software. You may 
need to analyze the procedures you would be using and also understand 
the task you have taken up deeply. It is useful to examine a task that you 
have already performed before. This can be a task that you have not 
automated in the past. The following sections will help you generate the 
list of tasks you must complete to finish your design.  
 
 
 
Understanding the Audience 
Understand how your target audience performs the task that you have 
listed down. Sit with them and learn about the sections of the task they 
want to automate and understand the factors that they would like to 
control. You have to also make a list of factors that the audience finds 
confusing and understand how you can help them overcome those 
difficulties.  
There are some people who use a short questionnaire, even if it is them 
answering the questions, since the answers will help you gain an idea on 
the problem at hand. You can ask for some detailed answers in the 
questionnaire to understand what your target audience wants the 
application to look like and they may want it to behave. You must also 
understand what file formats they expect to use to read in information 
from and save it out to, particularly covering any unique or special 
considerations that you can imagine. File formats could include HTML, 
XML and plain text for text documents, or your users might have images 
saved as PNGs or JPEGs audio files (WAV) that they may want to 
convert to MP3s. A file’s extension (the letters after the last dot in the 
filename) usually provides a clue as to what format a file is in, though 
there are other ways of finding out this information.  
Through this exercise, you will understand how the task if often 
performed and the information you need to collect before you start the 
process. You do not need to develop an example or a prototype of the 

code at this stage since it is invaluable. It is better to have a code written 
down. You can tweak this code as you go along.  
 
Watching Users 
As a developer, you can take the liberty to watch the audience carry out 
the task and make notes while the tasks are being performed. You do not 
need a lot of detail at this stage since you only need to gather 
information that will help you develop your code or software. The 
alternative approach would be to put yourself in your audience’s position 
and walk through the task. Another technique is to collect up all the 
pieces of paper that go into or come out of the process and use them to 
create a storyboard. It is true that this step is more relevant in the future, 
but it is better to get into the habit of working on this step now.  
 
Compiling User Stories 
A user story consists of one or two lines in everyday language that 
specifies something that the user wants from the software. The idea is 
that stories should be brief enough to fit on an index card, on a sticky 
note, or into one cell of a spreadsheet. A user story should indicate the 
role of the user, what that user wants the software to do, and what 
benefit might be gained from it. User stories are prioritized by the user to 
indicate which features are most important and are then used to work 
out an estimate of the time it will take to develop those features by the 
developer. The developer may then create use cases out of these stories 
and tests to determine whether the requirements have been fulfilled. Use 
cases are longer, more detailed descriptions of features that are required 
by specific users in specific situations. You just need enough information 
to work out the basic functionality that will be required from the 
program you are about to write. Try to keep it concise. 
 
Identifying the Solution 
Armed with all this information, let’s return to the text file to complete 
the first stage of the software design. The design stage can often be the 
most time-consuming part of the programming process. It consists of 
several stages in which the output from one stage becomes the input to 
the next. Often, the output from one or more stages is fed back through 
the same process several times. This process that happens inside the 

program is termed as recursion. Every software design cycle has a 
similar recursive nature. So, let us go back to our initial problem now.  
 
Understanding the Problem 
This time around, you’re going to fill in a little more detail and turn your 
text file into a very simple user requirements document. In a 
professional situation, this would become the agreement between the 
programmer and the client who is paying for the software to be written. 
For now, you’re just going to use it as a means to keep a record of the 
original purpose of this software. Make sure that the problem is stated 
clearly and that you have identified the issue you wish to resolve 
correctly. Often, there can be hidden subtleties in the problem that look 
straightforward when written down in your natural language but require 
additional clarification when you come to turn them into programming 
language, or code. If the problem is not defined well enough to make a 
decision at that point, you will need to return to this stage and clear up 
the details before you can make any further progress. 
 
 
 
Understanding what the software needs to do 
The things you want the software to do are known as functional 
requirements in the trade. Simple examples include printing a message, 
adding up some numbers up, or sending an e-mail form. You might have 
additional details to add; for example, maybe the user must be able to 
input some text, numbers larger than 200 cannot be entered, or the 
update must be performed over the Internet. Functional requirements 
specify how a system should behave. For your first exercise, Hello World! 
You will be asking the software to print out a simple message, so your 
first functional requirement is that the computer should print out a 
message. 
 
 
 
Considering Limitations 
You may also want to include other needs or limitations of the software, 
which are called nonfunctional requirements. The remaining constraints 
are defined by the non-functional qualities and requirements of the 
software like cost-effectiveness, accessibility and compatibility with 
other operating systems, performance and usability. You do not have to 
worry about these aspects if you are developing a code for yourself.  

 
 
 
Defining the Results 
You need to give some thought as to how the software will be tested. 
Early on, it will be enough to simply run the program and see if it works, 
but as your scripts grow in complexity, you will find it useful to formalize 
the methods used for testing. It may be worth finding or creating some 
data to use as an example for testing purposes, and you may find it useful 
to create a table of values that you expect to find at various points in the 
process. In Chapter 11, I’ll be showing you how to create built-in test 
suites, which can make a large part of the process automatic. It’s 
generally considered good practice to write your tests before you do any 
coding, but it often happens that the tests and code actually get written 
at the same time. For now, a note of the expected output will do fine. 
 
 
 
Refining the program 
Any piece of software that is going to be used more than once will require 
some degree of maintenance. Issues that are worth thinking about early 
on are how the software might need to change in future and how to keep 
track of issues. You might also consider how the application is going to 
be kept in working condition while you’re integrating new possibilities 
and responding to new challenges. In many cases, the application will be 
maintained by the person who wrote it, but it is good practice to organize 
your project and write your code in a way that makes it easy for someone 
else to understand what you’ve done and contribute fixes and new 
features. One day, you might want to pass on the responsibility of 
keeping it up to date to someone else.  
To facilitate maintenance, the software should include some means of 
contact, such as the author’s e-mail address so that users can get in touch 
if there are any problems. For now, just note your e-mail address. Later 
on, I’ll show you how you can integrate this information into your code, 
so you don’t have to retype this information every time you want to use 
it. A principle of programming that you must keep in mind is ‘Don’t 
Repeat Yourself.’ This principle states that every piece of information 
must have an unambiguous, simple and authoritative representation in 
the system. No piece of information should ever have to be typed in 
twice—if you find yourself doing this, it’s a sure sign that some part of 
your script needs redesigning. 
Let us take a look at the hello_world txt program.  

Problem: Get the computer to output a message.  
Target Users: Me  
Target System: GNU/Linux  
Interface: Command-line  
Functional Requirements: Print out a message.  
User must be able to input some text.  
Testing: Simple run test - expecting a message to appear.   
Maintainer: maintainer@website.com 
 
 
 
Breaking the Solution Down 
Next, you start the process of turning your wish list into a program. In 
this stage, you will design a logical flow of actions, which will hopefully 
produce the desired outcome. First, you need to turn the text file into 
something the Python interpreter can understand by saving it as a 
Python (.py) file. Use the Save As function in your text editor to save the 
file with the same name, but this time with a .py extension. This example 
will become hello_world.py.  
Now, the interpreter needs to know what this text is; otherwise, it will 
attempt to interpret the first thing it finds as a command. There are a 
variety of ways of marking out blocks of text as comments or text strings 
so that the interpreter doesn’t attempt to execute them.  
 
Comments  
The hash symbol, #, is used to mark comments. Comments are 
completely ignored by the Python interpreter. All text between the # sign 
and the end of the line is ignored. This formatting is a convenience so 
you, the programmer, can write little notes to yourself to remind yourself 
what this part of the code is supposed to do or to flag parts of the code 
that need attention. These comments will only ever be seen by people 
who are actually reading the code. If you are writing software as part of a 
team, comments are a great way of communicating your thoughts and 
intentions to the other programmers. Good code can often contain more 
comments than actual lines of code—don’t be tempted to remove them 
once you’ve coded the design. In a month’s time, you are likely to have 

completely forgotten what this script was intended to do, and you will be 
thankful for these little reminders.  
Text strings  
Text strings are delimited by quotation marks. Delimited means the text 
is enclosed between a matching pair of the specified characters. Python 
uses a variety of forms of quotation marks, principally 'single' and 
"double" quotation marks. There is a subtle difference between the two 
forms, which I’ll cover in detail in the section on text strings in Chapter 
3. The main reason for the different forms is to allow nesting of quotes. 
Nesting means putting one inside the other like this: “What on earth 
does ‘nested delimiters’ mean?” she asked.  
Like comments, quotation marks only work if the text is all on one line. 
Fortunately, there are a variety of ways to get the interpreter to ignore 
line breaks. In this example, I shall use the technique of triple quoting, 
which is explained in later chapters.  
 
 
 
Organizing Tasks into Steps 
Now, you are prepared to start designing your program. The program 
design is initially sketched out in pseudocode, which is the design 
language that can be used as an intermediary step to turn the user 
requirements document into a piece of Python code. There is nothing 
special about the form of this language; your own natural way of 
expressing ideas is exactly what is needed in this situation. Pseudocode 
is simply a series of logical statements in your own words that describe 
the actions that the program needs to take in order to produce the 
desired result.  
If you are working as part of a team, your company may have a standard 
way of writing pseudocode, but you don’t need to worry about such 
considerations while you are learning. Over time, you are likely to find 
that your pseudocode naturally adopts a Python-like syntax. Initially, the 
important thing is that you can express your ideas clearly without having 
to worry about the rules of the language yet. 
 
 
 
Using Subgroups and Indentation 
Python is very strict about indentation. Python regards any space or tab 
at the start of a line as an indentation. Every indentation means 
something. Without going into too much detail at this stage, pay careful 

attention to how indentation is used in the examples. The most 
important thing to remember is not to mix tabs with spaces, as the 
interpreter thinks these are two different things (even if they look the 
same to you).  
In your text editor’s Preferences window, set it to insert four spaces 
instead of using tabs, and you’ll avoid so much future grief by doing this. 
It is always best to keep your designs clear and readable: use blank lines 
to separate the different sections of your pseudocode and use 
indentation to show how statements are grouped together. As long as 
each line is a comment preceded by a #, you are free to format it how you 
like. 
 
 
 
Coding the Design 
Now, you are ready to start turning your design into proper Python code. 
Great!  
The data your software will be manipulating will take various forms; 
these values are assigned to things called variables, which you can think 
of as a box or a bucket that contains a single piece of information, often a 
word or a number. Some people find it useful to think of them as slates 
that can be written on with chalk. The important thing is that the 
information in the container can be changed by putting a new value into 
it; this automatically wipes out the old value and replaces it with a new 
one. The fact that these values can be changed gives rise to the term 
variable.  
There are two stages to creating a variable, the first is to create the 
container and stick an identifying label on it: this is called initialization. 
The second is to put a value into it: this is called assignment. In Python, 
both these things happen in the same statement. Assignment (and 
therefore initialization) is performed using the = sign like this: variable = 
value. One of the specific features of Python is that, once a value has 
been assigned to a variable, the interpreter will then decide what sort of 
value it is (i.e., a number, some text, or some other relevant piece of 
information).  
Each variable is referred to by a name, known as an identifier, which is 
rather like a nametag that identifies the variable to the rest of the 
program. It’s a good idea to choose names that give an idea of what sort 
of values they represent. Python will regard any word that has not been 
commented out, delimited, or escaped in some other way as either a 

command or an identifier; for this reason, you need to be careful to avoid 
choosing words that are already being used as part of the Python 
language to identify your new variables. Details of which words you 
cannot use will be covered in the next chapter. 
 
 
 
Turning the Design into Executable Code 
Now, you have to come up with a strategy for solving the problems you 
have agreed to tackle.  
First, you want to print out a message, and you want the user to be able 
to input some text. OK, so you’re expecting your message and users’ text 
to be strings of text. It would be a very good idea to add this information 
to the Testing section of your docstrings at the start of the file. Text 
strings are represented by enclosing the text in quotes.  
Now, you just need to know the function that prints things out to the 
screen, which is called print () in Python. So, your first problem 
translates fairly easily into executable code as you can see in Listing 2-5. 
You can print any text you like; “Hello World!” is the default. 
Let us take a look at the first version of the Hello_World.py program. 
"""  
Problem: Get the computer to output a message.  
Target Users: Me  
Target System: GNU/Linux  
Interface: Command-line  
Functional Requirements: Print out a message.  
User must be able to input some text.  
Testing: Simple run test - expecting a message to appear.  
        - Expecting: message == input text  
Maintainer: maintainer@website.com  
""" 
# 1. Print out a friendly message  
Print ("Hello World!")  

# 2. Input some text  
# 3. Print out the text we just entered  
This script can be run by typing  
$ Python hello_world.py 
The only line in this script that is actually executed by the interpreter is 
print ("Hello World!"). Everything else is either ignored as a comment or 
assumed to be a docstring, in the case of the block of text at the 
beginning. If you change the text between the quotes in the call to the 
print () function, the Python interpreter will print out whatever you tell it 
to.  
Well done! You just wrote your first Python program. It’s about as basic 
as can be, but you can now bask in the satisfaction of having got Python 
to do something. 
 
 
 
Refining the Design 
Constantly editing the script to get it to say something different quickly 
becomes rather tedious. Wouldn’t it be great if the program were 
interactive? In that case, you would need to find a way to get some user 
input.  
The quick-and-dirty method for doing this is to use the built-in input () 
function. This function takes one argument, a text string that is printed 
to the screen to prompt the user for input. The function then returns the 
user’s input. All requests for input need a message to tell the user that 
input is required; this is known as a prompt. I assign this input to a 
variable called some_text. Then, I can use the print () function to print 
out the user’s input. Notice that this time some_text isn’t in quotes, 
because I want the value contained in the variable called some_text 
rather than the literal text string "some_text". Variable names aren’t 
allowed to contain spaces, so you’ll notice that I’ve replaced the space 
with an underscore. It’s worth remembering that variable names can’t 
contain dashes either, because Python will assume that the dash is a 
minus sign. Details of how to name your variables will be covered fully in 
Chapter 3. 

 
 
 
Testing the Design 
Now, it’s time to save the file again and test it by running the script with 
the Python interpreter as before. If you get any error messages at this 
stage, you probably made a mistake typing the script. Common errors 
include missing quotation marks or spaces in the wrong places. In this 
case, you will need to go back to the coding stage and correct these errors 
before you test the code again.  
The testing stage involves making sure that the design does what it is 
supposed to and that it matches the specification that you started with. 
Compare the actual output from running the program to the output you 
said you were expecting in your original specification. Are they the 
same? If not, why not? What could be done better?  
Apart from the initial design stage, you will probably spend most of your 
time cycling around this testing stage. Don’t be tempted to view error 
messages as annoyances or irritations: pay great attention to what they 
tell you, as they can be one of the most useful aids on the path of learning 
Python. On some occasions, you will want to deliberately produce error 
messages to prove that something is working. Try it now. Find out what 
you have to mess up to get an error message. Take note of what sort of 
message you get and fix your script so that it runs cleanly again. 
 
 
Breaking down the Jargon 
Some terms that were introduced in the chapter are:  
● Argument: This is a value you pass to a function or to a procedure, 
so it has some data to work with.  
● Assignment: This is the operation of setting a variable to a value.  
● Delimiter: This punctuation mark is typically used to separate a 
text string or other piece of data from surrounding characters.  
● Escape: This is a method of indicating that the next character in a 
text string should be processed in a different way.  
● Function: A function is a block of code that performs a calculation, 
accepts zero or more arguments and returns a value to the calling 
procedure when it is complete.  

● Indentation: This refers to the use of spaces and tabs at the start of 
a line of code or text, except you want to use spaces rather than 
tabs, remember?  
● Identifier: This is a user-defined name; both function names and 
variable names are identifiers. Identifiers must not conflict with 
keywords.  
● Initialization: This process sets the initial value of a variable. 
Initialization is done only once for each variable, when that 
variable is created.  
● Module: A module is a Python program that can be imported by 
another program. Modules are often used to define additional 
functions and classes.  
● Nesting: Put one piece of code inside another similar construct.  
● Nonfunctional requirements: These are needs or limitations of the 
software that are not specifically about what the software will do.  
● Program implementation: This is the actual realization of the 
program, as opposed to the design.  
● Prompt: This string of text or punctuation marks indicates that the 
user needs to input some information or commands. 
● Pseudocode: This program design language is intended to be read 
by humans, not performed by a computer.  
● Return: This refers to the process of transferring execution from a 
function back to the place from which that function was called in 
the main program. The return statement can also pass a value back 
to the main program for use in further calculation.  
● Statement: This instruction to do something in a programming 
language manipulates a piece of data, performs a calculation, or 
produces some output.  
● String: This refers to a line of text or other characters intended to 
be displayed or processed as a single item.  
● Top-level design: This is the first stage of a design, and it provides 
a summary or general description of the actions that the software is 
intended to perform.  
● User story: A user story consists of one or two lines in the everyday 
language of the user that specifies something desired from the 
software.  
● Validation: This process tests whether a value is what the 
programmer expects it to be.  
● Variables: Use variables as a means of referring to a specific item of 
data that you wish to keep track of in a program. It points to a 

memory location, which can contain numbers, text, or more 
complicated types of data. 
 
 
If  you are enjoying the audiobook, I would love if you went to Audible and leave a short 
review. 
 
 
 

Chapter Three: Data Types and Variables 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
 
In the last chapter, we learnt that an identifier is a part of a variable, 
which is a unit of data. These variables and identifiers are held in the 
computer’s memory and its value can be changed by making a 
modification to a value that is already present in the variable. This 
chapter will introduce you to the different types of variables that you can 
use when writing a program in Python. You will also learn how these 
variables can be used to convert your designs into working codes using 
Python. This is when you begin real programming. Over the course of 
this chapter, we will work on two programs – one where we will learn to 
format and manipulate text strings and another to perform a simple 
mathematical calculation.  
The programs mentioned above can be written easily using different 
variables. When you use variables, you can specify a function, method of 
calculation that must be used to obtain a solution without the knowledge 
of the type of value that the variable must refer to in advance. Every 
piece of information that must be put into a system needs to be 
converted into a variable before it can be used in a function. The output 
of the program is received only when the contents of these variables are 
put through all the functions written in the program.  
 
Choosing the right identifier 
Every section of your code is identified using an identifier. The compiler 
or editor in Python will consider any word that is delimited by quotation 
marks, has not been commented out, or has escaped in a way by which it 
cannot be considered or marked as an identifier. Since an identifier is 
only a name label, it could refer to just about anything, therefore, it 
makes sense to have names that can be understood by the language. You 
have to ensure that you do not choose a name that has already been used 
in the current code to identify any new variable.  

If you choose a name that is the same as the older name, the original 
variable becomes inaccessible. This can be a bad idea if the name chosen 
is an essential part of your program. Luckily, when you write a code in 
Python, it does not let you name a variable with a name used already. 
The next section of this chapter lists out the important words, also called 
keywords, in Python, which will help you avoid the problem. 
 
 
Python Keywords 
The following words, also called keywords, are the base of the Python 
language. You cannot use these words to name an identifier or a variable 
in your program since these words are considered the core words of the 
language. These words cannot be misspelt and must be written in the 
same way for the interpreter to understand what you want the system to 
do. Some of the words listed below have a different meaning, which will 
be covered in later chapters.  
● False  
● None  
● Assert  
● True  
● As  
● Break  
● Continue  
● Def  
● Import  
● In  
● Is  
● And  
● Class  
● Del  
● For  
● From  
● Global  
● Raise  
● Return  
● Else  
● Elif  

● Not  
● Or  
● Pass  
● Except  
● Try  
● While  
● With  
● Finally  
● If  
● Lambda  
● Nonlocal  
● Yield 
 
 
 
Understanding the naming convention 
Let us talk about the words that you can use and those you cannot use. 
Every variable name must always begin with an underscore or a letter. 
Some variables can contain numbers, but they cannot start with one. If 
the interpreter comes across a set of variables that begin with a number 
instead of quotation marks or a letter, it will only consider that variable 
as a number. You should never use anything other than an underscore, 
number or letter to identify a variable in your code. You must also 
remember that Python is a case-sensitive language, therefore false and 
False are two different entities. The same can be said for vvariable, 
Vvariable and VVariable. As a beginner, you must make a note of all the 
variables you use in your code. This will also help you find something 
easier in your code.  
 
Creating and Assigning Values to Variables 
Every variable is created in two stages – the first is to initialize the 
variable and the second is to assign a value to that variable. In the first 
step, you must create a variable and name it appropriately to stick a label 
on it and in the second step; you must put a value in the variable. These 
steps are performed using a single command in Python using the equal 
to sign. When you must assign a value, you should write the following 
code:  
Variable = value 

Every section of the code that performs some function, like an 
assignment, is called a statement. The part of the code that can be 
evaluated to obtain a value is called an expression. Let us take a look at 
the following example: 
Length = 14 
Breadth = 10 
Height = 10 
Area_Triangle = Length * Breadth * Height  
Any variable can be assigned a value or an expression, like the 
assignment made to Area_Triangle in the example above.  
Every statement must be written in a separate line. If you write the 
statements down the way you would write down a shopping list, you are 
going the right way. Every recipe begins in the same way with a list of 
ingredients and the proportions along with the equipment that you 
would need to use to complete your dish. The same happens when you 
write a Python code – you first define the variables you want to use and 
then create functions and methods to use on those variables.  
 
Recognizing different types of Variables 
The interpreter in Python recognizes different types of variables – 
sequences or lists, numbers, words or string literals, Booleans and 
mappings. These variables are often used in Python programs. A variable 
None has a type of its own called NoneType. Before we look at how 
words and numbers can be used in Python, we must first look at the 
dynamic typing features in Python.  
 
 
 
Working with Dynamic Typing 
When you assign a value to a variable, the interpreter will choose to 
decide the type of value the variable is, which is called dynamic typing. 
This type of typing does not have anything to do with how fast you can 
type on the keyboard. Unlike the other languages, Python does not 
require that the user declare the types of the variables being used in the 
program. This can be considered both a blessing and a curse. The 
advantage is that you do not have to worry about the variable type when 

you write the code, and you only need to worry about the way the 
variable behaves.  
Dynamic Typing in Python makes it easier for the interpreter to handle 
user input that is unpredictable. The interpreter for Python accepts 
different forms of user input to which it assigns a dynamic type which 
means that a single statement can be used to deal with numbers, words, 
or other data types, and the user does not have to always know what data 
type the variable must be. Not needing to declare variables before you 
use them makes it tempting to introduce variables at random places in 
your scripts. You must remember that Python won’t complain unless you 
try to use a variable before you have actually assigned it a value, but it’s 
really easy to lose track of what variables you are using and where you 
set up their values in the script.  
There are two really sensible practices that will help keep you sane when 
you start to create large numbers of different variables. One is to set up a 
bunch of default values at the start of each section where you will be 
needing them, keeping all the variables you are going to use together in 
one part of the text like an ingredients list. The other is to keep track of 
the expected types and values of your variables, keeping a data table in 
your design document for each program that you are writing.  
Python needs to keep track of the type of a variable for two main reasons. 
Chiefly, the machine needs to set aside enough memory to store the data, 
and different types of data take up different amounts of space, some 
more predictably than others. The second reason is that keeping track of 
types helps to avoid and troubleshoot errors. Once Python has decided 
what type a variable is, it will flag up a TypeError if you try to perform an 
inappropriate operation on that data. Although this might at first seem 
to be an unnecessary irritation, you will discover that this can be an 
incredibly useful feature of the language; as the following command-line 
example shows: 
>>> b = 3  
>>> c = 'word'  
>>> trace = False  
>>>  
b + c  
Traceback (most recent call last):  

File "", line 1, in <module> 
TypeError: unsupported operand type(s) for +: 'int' and 'str'  
>>> c - trace  
Traceback (most recent call last):  
File "", line 1, in <module> 
TypeError: unsupported operand type(s) for -: 'str' and 'bool'  
The program above tries to perform operation on data types that are 
incompatible. You’re not allowed to add a number to a word or take a 
yes/no answer away from it. It is necessary to convert the data to a 
compatible type before trying to process it. You can add words together 
or take numbers away from each other, just like you can in real life, but 
you can’t do arithmetic on a line of text. The tracebacks are Python’s way 
of alerting you to a potential error in your logic, in this case a TypeError. 
This tells me that I need to rewrite the code to make it clear what type of 
information I want to put in and get out of the equation.  
The purpose of data types is to allow us to represent information that 
exists in the real world, that is, the world that exists outside your 
computer, as opposed to the virtual world inside. We can have the 
existential conversation about what is real and what is not some other 
time. The previous example uses variables of type int (whole numbers) 
and type str (text). It will quickly become apparent that these basic data 
types can only represent the simplest units of information; you may need 
to use quite a complicated set of words, numbers, and relationships to 
describe even the simplest real-world entity in virtual-world terms. 
Python provides a variety of ways of combining these simple data types 
to create more complex data types, which I’ll come to later in this book. 
First, you need to know about the fundamental building blocks that are 
used to define your data and the basic set of actions you can use to 
manipulate the different types of values. 
 
The None Variable 
A predefined variable called None is a special value in Python. This 
variable has a type of its own and is useful when you need to create a 
variable but not define or specify a value to that variable. When you 

assign values such as “” and 0, the interpreter will define the variable as 
the str or int variable.  
Information = None 
A variable can be assigned the value None using the statement above. 
The next few examples will use real-world information that will be 
modeled into a virtual form using some fantasy characters. This example 
uses some statistics to represent some attributes of the characters to 
provide data for the combat system. You can use this example to 
automate your database and your accounts. So, let us take a look at some 
of the characters in the example.  
In the program, hello_world.py, you saw how you could get a basic 
output using the print () function. This function can be used to print out 
the value of the variable and a literal string of characters. Often, each 
print statement must start off on a new line, but several values can be 
printed on a single line by using a comma to separate them; print () can 
then be used to concatenate all the variables into a single line only 
separated by spaces.  
>>> Race = "Goblin"  
>>> Gender = "Female"  
>>> print (Gender, Race)  
Female Goblin  
Different segments of information can be combined into a single line 
using multiple methods. Some of these methods are more efficient when 
compared to others. Adjacent strings that are not separated will be 
concatenated automatically, but this is not a function that works for 
most variables.  
 
>>> print ("Male" "Elf")  
The expression above will give you the following output – “MaleElf” 
However, when you enter the following code,  
 
>>> print (“Male” Race) 
You will receive the following error:  
File "<stdin>", line 1  

print ("Male" Race)  
^  
SyntaxError: invalid syntax 
This approach cannot be used since you cannot write a string function as 
a variable and a string together since this is just a way of writing a single 
line string.  
 
Using Quotes 
In Python, a character is used to describe a single number, punctuation 
mark, or a single letter. A string of characters used to display some text 
are called strings or string literals. If you need to tell the interpreter that 
you want a block of text to be displayed as text, you must enclose those 
characters in quotation marks. This syntax can take multiple forms –  
‘A text string enclosed in single quotation marks.’ 
“A text string enclosed in double quotation marks.” 
“’A text sting enclosed in triple quotation marks.’’’ 
If text is enclosed in quotes, it is considered the type str (string). 
 
 
 
Nesting Quotes 
There are times when you may want to include literal quotation marks in 
your code. Python allows you to include a set of quotation marks inside 
another set of quotation marks, if you use a different type of quotation 
mark.  
>>>text= “You are learning ‘how to’ use nested quotes in Python” 
In the example above, the interpreter will assume that it has reached the 
end of the string when it reaches end of the text at second set of double 
quotes in the string above. Therefore, the substring ‘how to’ is considered 
a part of the main string, including the quotes. In this way, you can have 
at least one level of nested quotes. The easiest way to learn how to work 
with nested quotes is by experimenting with different types of strings.  
>>> boilerplate = """  
... #===(")===#===(*)===#===(")===#  

... Egregious Response Generator  
... Version '0.1'  
... "FiliBuster" technologies inc.  
... #===(")===#===(*)===#===(")===#  
... """  
>>> print(boilerplate) #=== (“) ===#=== (*) ===#=== (“) ===#  
Egregious Response Generator  
Version '0.1'  
"FiliBuster" technologies inc.  
#===(")===#===(*)===#===(")===# 
This is a useful trick to use if you want to format a whole block of text or 
a whole page.  
 
How to use Whitespace Characters 
Whitespace characters are can often be specified if the sequence of 
characters begin with a backslash. ‘\n’ produces a linefeed character that 
is different from the ‘\r’ character. In the output window, the former 
would shift the output to a new line, while the latter would shift the 
output to a new paragraph. You must understand the difference between 
how different operating systems use to translate the text.  
The usage and meaning of some of the sequences are lost on most 
occasions. You may often want to use \n to shift to a new line. Another 
sequence that is useful is \t, which can be used for the indentation of text 
by producing a tab character. Most of the other whitespace characters 
are used only in specialized situations.  
Sequence 
Meaning 
\n 
New line 
\r 
Carriage Return 
\t 
Tab 
\v 
Vertical Tab 

\e 
Escape Character 
\f 
Formfeed 
\b 
Backspace 
\a 
Bell 
 
You can use the example below to format the output for your screen:  
>>> 
print 
(“Characters\n\nDescription\nChoose 
your 
character\n \ 
…. \tDobby\n\tElf\n\tMale\nDon\’t forget to escape \’\\\’.” 
) 
Characters 
 
Description 
Choose your character 
 
Dobby 
 
Elf 
 
Male 
Don’t forget to escape ‘\’. 
You must remember that strings are immutable which means that they 
cannot be changed. It is possible to use simple functions to create new 
strings with different values.  
 
How to Create a Text Application 
All the information mentioned int his chapter can be used to write the 
code for our role-playing game. Strings are often simple to use since you 
must only ensure that you enclose the strings in matching quotes. The 
script to design the character-description is simple.  
# Prompt the user for some user-defined information  
# Output the character description 

You may want to include the following information for the character: 
● Name 
● Gender 
● Race 
● Description of the character 
For this information, you can create the following variables – Name, 
Gender, Race and Description. These values can be printed using the 
following code:  
"""  
chargen.py  
Problem: Generate a description for a fantasy role-playing 
character.  
Target Users: Me and my friends  
Target System: GNU/Linux  
Interface: Command-line  
Functional Requirements: Print out the character sheet  
User must be able to input the character's name, 
description, gender and race  
Testing: Simple run test  
Maintainer: maintainer@website.com  
""" __ 
version__ = 0.1  
Name = ""  
Desc = ""  
Gender = ""  
Race = ""  
# Prompt user for user-defined information  
Name = input ('What is your Name? ')  
Desc = input ('Describe yourself: ')  

Gender = input ('What Gender are you? (male / female / unsure): 
')  
Race = input ('What fantasy Race are you? - (Pixie / Vulcan / 
Gelfling / Troll/ Elf/ Goblin): ')  
# Output the character sheet  
character_line = “<~~==|#|!!++**\@/**++~~==|#|++~~>” 
print ("\n", character_line)  
print ("\t", Name)  
print ("\t", Race, Gender)  
print ("\t", Desc)  
print (fancy_line, "\n") 
The program above is a smarter version of the hello_world program 
written above. However, in this program, there is a new line added 
_version_ = 0.1 at the start of the program. This is a predefined variable 
that has a special meaning in Python’s documentation. This is the 
number we will continue to use to record the above example. As we go 
along, we will continue to increment this number when we make any 
changes or refine the program. Now, we will need to obtain some 
numerical information about the characters that will interact in the 
game.  
 
Working with Numbers 
It is straightforward to assign any number to variables.  
 
Muscle = 8 
 
Brains = 13 
As mentioned earlier, the interpreter assumes that a set of characters as 
a number if it starts with a numerical instead of a quotation mark or 
letter. Therefore, you cannot start any variable with a number. You must 
learn a few things before you begin to work on mathematics on your 
computer.  

 
Computers only count to one 
All the information in the computer can only be stored in zeros and ones. 
Every computer stores and processes any volume of data using tiny 
switches that can either be on (1) or off (0).  
 
Using Boolean 
As mentioned earlier, a computer can only register two values – True 
(value = 1) and False (value = 0). These values are known as Boolean 
operators and can be manipulated using operators like OR, NOT and 
AND. These operators are explained in further detail in the following 
chapter. Boolean values can be assigned as follows: 
 
Mirage = False 
 
Intelligence = True 
 
Using Whole Numbers 
Whole numbers, also called integers, do not have decimal points and can 
be zero, positive and negative. These numbers are used to refer to 
different things like the recipe example mentioned above.  
 
Performing Basic Mathematical Operations 
Now that you know how to store data in a variable, let us take a look at 
how to manipulate that data. Basic mathematical operations can be 
performed using operators like +, - and *. These operators create an 
expression that must be evaluated before you can obtain a value. The 
following statements can be used to perform these operations.  
>>>muscle = 2 + 3 
>>>brains = 7+4 
>>> speed = 5 * 6 
>>> weirdness = muscle * brains + speed 
>>> weirdness 
All these operations work using the BODMAS mathematical algorithm.  
 
 
 
Working with Floats and Fractions 
Most fractions are often expressed using the float type where decimal 
points can be used. These numbers, like integers, can be both positive 
and negative. You do not have to assign a variable to the data type float. 

Python automatically converts a variable into the float type if it is 
assigned a decimal number.  
Muscle = 2.8 
Brains = 4.6 
Speed = 6.8 
Even if the number before and after the decimal point is 0, it is still 
considered a fraction. This data type can be manipulated using the same 
mathematical operations mentioned above.  
 
 
 
Converting Data Types 
There are different built-in functions that are used in Python to convert a 
value from one data type to another. The data types often used are: 
● int (x) – used to convert any number into an integer 
● float (x) – used to convert a number to a float data type 
● str (object) – convert any type into a string that can be used to 
print 
>>> float (23)  
23.0  
>>> int (23.5)  
23  
>>> float (int (23.5))  
23  
 
Breaking down Jargon 
This section provides the definition of some new terms that were used in 
this chapter.  
● Binary: In arithmetic, binary relates to the digits 1 and 0. This term 
responds to the current in a wire.  
● Boolean: A Boolean variable can only take two values – True and 
False which correspond to 1 and 0 respectively. This type of 
variable is the most appropriate type that can be used to let the 
user know if a condition holds true or not.  

● Characters: A character is anything from a digit, letter, space and a 
punctuation mark. This data type is anything that can be type 
using a key on the keyboard, regardless of whether or not an 
output is printed on the screen.  
● Concatenate: When you create a string using different segments of 
strings or copy two text strings together.  
This chapter has helped you understand how to assign different types of 
variables and how you can manipulate strings and numbers. Let us take 
a look at the following exercises and see how well you do. The solutions 
are provided at the end of the book.  
1. Write a program to concatenate two strings 
2. Write a program to calculate the sum of two numbers 
 
 
 
 

Chapter Four: Conditional Statements 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
 
In the last few chapters, you have learnt how to use Python to 
manipulate strings and to make simple calculations. More importantly, 
you have learnt how to design your software. Now, it is time to learn how 
to refine your code. Therefore, pull out your old scripts and find an 
effective way to obtain your output.  
 
How to Compare Variables 
To generate more accurate answers, you must know how to compare the 
values and specify what the interpreter must do based on the obtained 
result. Python allows you to use conditional statements to allow you to 
make these decisions. A conditional statement can transform the code or 
script from just being a list of instructions to a code that can be used by 
the user to make their own decisions. It would be useful to tell the 
interpreter to perform a different action as per the decisions made by the 
user. You can write a pseudocode like: 
if a certain condition is true: 
 
then the following actions must be performed; 
if another condition is true: 
 
then these actions must be performed. 
Each pair in the example above is a conditional statement, but before we 
learn more about these statements, let us take a look at how to specify 
these conditions. Different values can be compared using the following 
operators: 
● <: Less than 
● >: Greater than 
● <=: Less than equal to 
● >=: Greater than equal to 
● ==: Equal to 

● !=: Not equal to 
These operators affect data types in different ways and give the user 
answers in the form of the Boolean operators. The data bits on either 
side of the operator are called operands and these are the variables that 
are compared. The comparative operator and the operands together 
form the conditional expression. It is important to check the conditional 
statements or expressions you are using since you may obtain an error if 
you compare incomparable data types. The results obtained by 
comparing these numbers are self-explanatory.  
>>> -2 < 5  
True  
>>> 49 > 37  
True  
>>> 7.65 != 6.0  
True  
>>> -5 <= -2  
True  
>>> 7 < -7  
False  
>>> 23.5 > 37.75  
False  
>>> -5 >= 5  
False  
>>> 3.2 != 3.2  
False 
Variables can also be used in conditional expressions.  
>>> variable = 3.0  
>>> variable == 3  
True 

 
 
 
Manipulating Boolean Variables 
Before you move onto the different conditional structures used in 
Python, you must learn how to manipulate the Boolean values True and 
False. You can use these values to understand the characteristics of any 
variable. These operators are often used with the terms AND, OR and 
NOT. The statements below represent some bits of information.  
>>> a = True 
>>> b = False 
>>> c = True 
>>> d = True 
>>> e = False 
Let us take a look at how AND, OR and NOT can be used.  
>>> a or b 
This operator returns the value True, since for the OR operator 
either one of the values needs to be true.  
>>> c and e 
This operator returns the value False, since for the AND operator 
both values must be the same.  
>>> not d 
This operator returns the value False, since the NOT operator 
provides the opposite of the value. 
 
 
 
Combine Conditional Expressions 
Conditional expressions can be combined to produce complex conditions 
that use the logical operators AND and OR. Let us take a look at the 
following conditions:  
(a < 6) AND (b > 7) 
This statement will only return True if the value of a is less than 6 
and the value of b is greater than 7.  

 
 
 
The Assignment Operator 
Since you are familiar with the assignment operator (=) which you use to 
put a value into a variable, let us take a look at how you can use this 
operator to assign values to variables. This assignment operator can be 
used to unpack sequences.  
>>> char1, char2, char3 = 'cat'  
>>> char1  
'c'  
>>> char2  
'a'  
>>> char3  
't' 
The assignment operator can also be used to assign different variables 
with the same value.  
a = b = c = 1 
The assignment operator can also be used along with mathematical 
operators. 
counter += 1 
The statement above is interpreted as counter = counter + 1. Other 
operators also can be used to either increment or decrement the value of 
the variable.  
 
 
How to control the process 
You have the liberty to decide what happens next in the program you 
have written using a control flow statement. The results of the 
comparison statements can be used to create conditional statements that 
allow the interpreter to provide the output that is based on whether the 
predefined conditions hold true. Conditional statements can be 
constructed using the keywords if, elif and else. Unlike other languages, 

Python does not use the keyword then. The syntax is very specific 
therefore you must pay close attention to the layout and punctuation.  
if condition:  
# Perform some actions  
print "Condition is True"  
elif condition != True:  
# Perform some other actions  
print "Condition is not True"  
else:  
# Perform default or fall-through actions  
print "Anomaly: Condition is neither True nor False" 
In the syntax above, the first line begins with the word if, which must be 
followed by a conditional statement that gives a True or False output 
followed by the colon. This colon means yes. The statements that follow 
must always start on a new line. The number of spaces doesn’t strictly 
matter so long as all the instructions after the colon are indented by the 
same amount, though it’s good practice to use the same number of 
spaces to indicate control flow throughout your code. The statements 
following after the colon are known as a suite.  
You can include further conditional sections using the elif keyword (an 
abbreviation of else-if, which is not a Python keyword); statements 
following elif will be evaluated only if the previous test fails (i.e., the 
conditional expression is False).  
You can also include a final else: statement, which will catch any value 
that did not satisfy any of the conditions; it doesn’t take any conditional 
expression at all. This can be used to specify a default set of actions to 
perform. In our previous example, things would have to go very wrong 
for us to ever see the final anomaly warning, as the preceding if and elif 
statements would have caught either of the two possible results. It is 
possible to nest if statements to allow for more possibilities, and you can 
leave out the elif or else statements if you don’t want anything to happen 
unless the condition is satisfied. In other words, sometimes you want to 
do something if a condition is satisfied but do nothing if it is not 
satisfied.  

After the final statement, the indentation must go back to its original 
level: this will indicate to the interpreter that the conditional block has 
come to an end. Python marks out blocks of code using indentation 
alone; it doesn’t use punctuation marks like the curly braces you may see 
in other languages. This unique feature of Python means you have to be 
extra careful about indentation. If you do get it wrong, you’ll find out 
soon enough, as the interpreter will complain loudly. 
>>> if c:  
... print(c)  
... c += 1  
... indent = "bad"  
File "<stdin>", line 4  
indent = "bad"  
^  
IndentationError: unindent does not match any outer indentation 
level 
A conditional statement always gives the user the ability to check or 
validate the data that was used as the input. Validation is often 
performed when the data is first fed into the computer and also when the 
information is written out on a database record or file.  
 
 
 
How to deal with logical errors 
As your applications become more complex, you will need more formal 
methods of testing your designs. One of the ways of doing this is to 
construct a trace table. You must trace the values of all the variables and 
the conditional expressions over the course of the execution of the 
program.  
A trace should be performed with as many different sets of data as is 
necessary to make sure that all the possible alternatives get tested. Most 
errors in programming don’t occur if the values lie within some expected 
range, but they often occur for unusual values (also called critical 
values). Critical values are values that lie outside the tolerances of the 
program, such a number that the application is not equipped to deal 
with.  

Critical values should be worked out early on in the design process, so 
that the program can be properly tested against them. In the calculation 
of the area of the triangle, the value that most needs taking into account 
is that of the breadth, which has been set at 14 cm. Allowing 8 cm means 
that the maximum breadth of the triangle can only be 8 cm.  
 
 
Using the conditional code 
Now you can apply your knowledge of conditional statements to allow 
for different ways of measuring up the material. If the breadth of the 
triangle were too much, it would become a different type of triangle. 
Therefore, you need to identify the right code which reflects the right 
conditions. The first step would be to translate your trace values into a 
pseudocode. The following example is about measuring the length of a 
curtain.  
if curtain width < roll width:  
total_length = curtain width  
else:  
total_length = curtain length  
if (curtain width > roll width) and (curtain length > roll width):  
if extra material < (roll width / 2):  
width +=1  
if extra material > (roll width / 2):  
width +=2 
 
 
Loops 
 
While Statement 
result = 1  
while result < 1000:  

result *= 2  
print result 
To control the number of times the loop is processed, it is necessary to 
specify a conditional expression; as long as this conditional expression is 
True at the beginning of an iteration, the loop continues. In the 
preceding example, our conditional expression is result < 1000. So, as 
long as the value of result is less than 1,000, the loop will continue 
processing. Once result reaches 1,024 (210), the program will stop 
processing the loop body.  
The variables used in the conditional expression are often expendable 
entities, which are only required for as long as the loop is active. Rather 
than keep thinking up different names, this kind of integer counter is 
usually named i or j by convention. 
Two things are important to remember in this sort of construction: Any 
variable used in the conditional expression must be initialized before the 
execution of the loop. Also, there must be some way of updating this 
variable within the loop; otherwise, the loop will just go around and 
round forever, which is called an infinite loop. 
It is possible to use different sorts of variables in the conditional 
expression. Let’s consider the problem of calculating the average of 
several numbers input by the user. The main problem here is that I don’t 
know how many numbers will be input. The solution is to use what is 
called a sentinel value to control the loop. Rather than using the counter 
in this instance, the script checks the value of the user input number. 
While it is positive (i.e., >= 0) the loop processes as normal, but as soon 
as a negative number is entered, the loop is broken, and the script goes 
on to calculate the average. Let us take a look at the following example: 
counter = 0  
total = 0  
number = 0  
while number >= 0:  
number = int (input ("Enter a positive number\nor a 
negative to exit: "))  
total += number  
counter += 1  

average = total / counter  
print(average) 
There are several methods of getting out of loops cleanly, the chief ones 
being the use of the break and continue keywords: If you want to get out 
of a loop without executing any more statements in the loop body, use 
break. If you just want to get out of this particular iteration of the loop, 
continue immediately takes you to the next iteration of the loop. 
At times, you will want the interpreter to recognize a condition but do 
nothing. In this case, the pass keyword can be useful; it creates a null 
statement, which simply tells the interpreter to move on to the next 
instruction. 
 
 
 
Nesting Loops 
You are allowed to nest loops and other conditional statements in 
Python, probably infinitely, but it is best to keep the number of levels of 
nesting to a minimum. For one thing, it’s very easy to get confused about 
which option the program is taking at any particular point. Also, having 
lots of indented blocks within other indented blocks makes your code 
difficult to read, can slow down the program’s execution, and is generally 
considered bad style. If you have come up with a design that involves two 
or three layers of looping, you should probably start thinking about 
redesigning it to avoid the excessive depth of nesting. 
 
For 
The other control flow statement I want to introduce is the for statement, 
which is constructed in a similar manner to the if and while statements. 
Its construction is for element in sequence: followed by an indented suite 
of instructions. During the first iteration of the loop, the variable element 
contains the first element in the sequence and is available to the 
indented suite. During the second iteration, it contains the second 
element in the sequence, and so on.  
To understand how this statement works, you need to know about 
sequences. The simplest sequence in Python is a string, which is a 
sequence of individual characters including spaces and punctuation. 
Other forms of sequence are tuples and lists. Tuples and lists are 
sequences of data items, the chief difference between them being that 

lists are editable in place, whereas tuples are not. It’s possible to use 
either in a for statement. They are constructed as follows: 
# tuple  
sequence1 = (1, 2, 3)  
# list  
sequence2 = [1, 2, 3] 
 
Breaking Down Jargon 
This section explains some of the terms used in this chapter.  
● Assignment operator: The single equals sign (=) is the assignment 
operator. It can be combined with other operators to perform more 
complex assignment operations.  
● Built-in: A built-in element is an innate part of the programming 
language, as opposed to something that has to be imported from a 
module. Built-in elements are part of Python’s standard library.  
● Comparison operators: These operators compare two values: 
● Conditional statement: This section of code is performed if a 
certain condition evaluates as True. A conditional statement is a 
form of control flow statement. • Critical values: These values exist 
at the edges of the permissible ranges set for an application. In 
particular, these are values that would cause changes or 
unexpected results from the normal running of the program.  
● Loop body: The body is the suite of instructions to be repeated in a 
loop.  
● Null statement: The pass keyword creates a null statement, which 
tells the interpreter to move on to the next statement.  
● Validation: This refers to the process of checking that your data is 
what you expect. 
Now that you have understood how to work with conditional statements 
and loops, try the following programs. The solutions to these programs 
have been provided at the end of the book.  
1. Write a program to print the Fibonacci series 
2. Write a program to print a palindrome 
3. Write a program to check if a number is even or odd 
 

Chapter Five: Data Structures 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
 
So far, you have learned to work with individual pieces of data to 
produce some simple results. Real world data is usually in lumps or 
groups, and it would be useful to work with such groups without having 
to make lots of repetitive statements in our code. Fortunately, Python 
provides a variety of data types that can make handling groups of data 
much simpler.  
The data types that are most used in Python are strings, tuples, lists and 
dictionaries, which are called data structures. Lists and tuples are a 
group or ordered data items while strings are pieces of characters or 
texts that are put together. Strings are just pieces of text. Tuples and lists 
are ordered groups of individual data items. Dictionaries are groups of 
pairs that only consist of key variables and values. Strings, tuples, and 
lists are also called sequences, which are a type of data model. The 
methods used for accessing the data in a sequence are same, which you 
will see later in this chapter.  
There is another way of looking at these data types—according to 
whether they can be modified or not, which is called mutability. An 
existing string and tuple cannot be modified, but new strings and tuples 
can be created using them which means that both strings and tuples are 
immutable. Lists are mutable, which means we can add or remove items 
from a list. 
 
Items in sequences 
We can fetch an individual item from a sequence using an index, which is 
the position of the element. The index is specified as an integer (a whole 
number) in square brackets immediately following the variable name. 
So, s[i] will retrieve the item at position i of sequence s. This allows you 
to access a single character in a string: 
>>> vegetable = ‘pumpkin’ 

>>> vegetable [0] 
‘p’ 
Or an item in a list: 
>>>vegetable = [‘pumpkins’, ‘potatoes’, ‘onions’, ‘eggplant’] 
>>>vegetable [1] 
‘pumpkins’ 
The first thing you will notice is that indexing is zero-based; that means 
you start counting at 0. An index of [2] accesses the third item in the list, 
the first item would be referenced with [0]. So, you can use integers 0 
through to the number of elements in the sequence minus one (0 to n – 
1) as indices. When you use a negative index, the interpreter counts from 
the end of the list.: 
>>>vegetable [-1] 
‘eggplant’ 
You can grab sections of a sequence using slices. Slicing is used to fetch 
multiple items from a sequence. Slices are the same as indices in the 
sense that the notation used for both is the same. However, slices are 
written with two or more integers separated by colons. The first value is 
the inclusive starting point and the second number is the exclusive end 
point of the slice. So, s [0:2] means that the slice will start from index 0 
and stop just before index 2, (i.e., fetch items at positions 0 and 1).  
The third value is optional and specifies an additional step value, which 
may be negative, so instead of picking out a sequential list, you can 
retrieve every other, or every nth item, and you can also retrieve them 
backward if you need to. So, s [i: j: step] will retrieve a slice of s starting 
from i and up to, but not including j, and taking the specified step. 
If you leave out the starting point, the slice will start at the beginning of 
the original sequence, and if you leave out the end point, the slice will 
run to the end of the original sequence.  
Indexing and slicing do not modify the original sequence; they make a 
new sequence from the original. However, the actual individual data 
items are the same. So, if you modify an individual item in a sequence, 
you will see the item change in a slice from the sequence as well. 

 
Tuples 
A tuple is an immutable ordered group of items or elements. Think of 
tuples as useful little sealed packets of information.  
A tuple is specified as a comma-separated list of values, which may be 
enclosed in parentheses. On certain occasions, the parentheses are 
required, so when in doubt, use parentheses. The values need not all be 
of the same type. A value can also be another tuple. 
 
 
 
Creating a Tuple 
Tuples can be created with no items in it using the round brackets ().  
>>>empty_tuple= () 
If you do not want more than one item in the tuple, you should enter the 
first item followed by a comma.  
>>>one_item = (‘blue’,) 
 
 
 
Changing Values in a Tuple 
You cannot change the values in a tuple. These tuples are sealed packets 
of information that are often used in situations where a set of values 
need to be passed on from one location to another. If you wish to change 
the sequence of the data, you should use a list.  
 
 
List 
A list is an ordered, comma-separated list of items enclosed in square 
brackets. Items need not all be of the same type. An item can also be 
another list.  
Lists can be sliced, concatenated, and indexed the same as any other type 
of sequence. It is possible to change individual items in a list, as opposed 
to immutable strings and tuples. Where a tuple is rather like a fixed 
menu, lists are more flexible. It is possible to assign data to slices, which 
can change the size of the list or clear it completely. 

 
Creating a List 
It is easy to create a list. 
>>> shopping_list = [‘detergent’, ‘deodorant’, ‘shampoo’, ‘body 
wash’] 
 
Modifying a List 
A new value can be added to a list using the assignment operator.  
>>> shopping_list [1] = ‘candles’ 
>>> shopping_list 
[‘detergent’, ‘candles’, ‘deodorant’, ‘shampoo’, ‘body wash’] 
 
 
Stacks and Queues 
Because lists are an ordered type of data, it is possible to use them to 
store and retrieve data items in a particular order. The two main models 
for doing this are described in traditional programming-speak as 
“stacks” and “queues.”  
A stack is a last in, first out (LIFO) structure, used rather like the discard 
pile in a card game. You put cards on the top of the pile and take them 
back off the top. You can push items onto the stack with list.append () 
and pop them back off with pop (). Note that there is no additional index 
argument, so it will be the last item of the list that is popped. 
>>> shopping_list.append (‘brush’) 
>>> shopping_list.pop() 
‘candles’ 
>>> shopping_list 
[‘detergent’, ‘deodorant’, ‘shampoo’, ‘body wash’] 
The other approach involves creating a first in, first out (FIFO) structure 
called a queue. This works more like a pipe, where you push items in at 
one end and the first thing you put in the pipe pops out of the other end. 
Again, we can push items into the pipe using append() and retrieve them 
using pop(0)— this time with an index of 0 to indicate that the data 
items should be popped from the start of the list 

>>> shopping_list.append (‘brush’) 
>>> shopping_list.pop(0) 
‘detergent’ 
>>> shopping_list 
[‘deodorant’, ‘shampoo’, ‘body wash’, ‘brush]’ 
 
 
Dictionaries 
Dictionaries are like address books: if you know the name of the person, 
you can get all of that person’s details. The name is technically referred 
to as a key, and any corresponding detail is referred to as the value.  
The key must be of an immutable type, that is, a string, number or tuple; 
the value can be more or less anything you like. The dictionary itself is a 
mutable data type, which means you can add, remove, and modify key-
value pairs. The keys are said to be mapped to objects, hence dictionaries 
are referred to as “mappings” to remind us that their behavior is 
somewhat different to sequences. 
Dictionaries are used anywhere we want to store attributes and values 
that describe some concept or entity. For example, we can use a 
dictionary to count instances of particular objects or states. Because each 
key has to have a unique identifier, there cannot be duplicate values for 
the same key. Therefore, we can use the key to store the items of input 
data, leaving the value part to store the results of our calculations. 
 
 
Breaking down Jargon 
Let us break down some of the new words you have come across in this 
chapter.  
● Arbitrary: In this instance, anything defined by the programmer is 
arbitrary.  
● Complex data types: These are structured or compound types 
constructed from a sequence of other types of data.  

● Constant: A constant value does not change during the execution of 
the program.  
● Constrain: Ensure that the results of a calculation fall between a 
specified range.  
● Hash: A hash is number calculated from a dictionary key to help 
with storage. This number is designed to be smaller than the key to 
aid efficiency.  
● Immutable: An immutable value that cannot be edited in place.  
● Index: An index is a token of an immutable type in square brackets 
immediately following the variable name, used to point to a 
specific item in the sequence.  
● Iterable: This refers to a code object that can be iterated.  
● Iterate: When you loop through items in a sequence one item at a 
time, you iterate it. 
● Iterator: This construct is designed to allow looping.  
● Mapping: This refers to a sequence that maps hashable values to 
arbitrary objects.  
● Matrix: A matrix is a multidimensional sequence.  
● Method: A method is a function specifically attached to an object 
or class of objects.  
● Mutable: A mutable value can be changed.  
● Operation: This action is performed on two variables (operands), 
usually of a mathematical or logical nature.  
● Queue: A queue is a first in, first out (FIFO) structure. You push 
things in at one end and pop values out of the other.  
● Resultant: This value is returned as the result of a process.  
● Separator: This text string is used to distinguish between items of 
data.  
● Sequence: A sequence is the simplest sort of complex data type in 
Python. Lists, strings, and tuples are the types of sequences.  
● Sequence packing: Sequence packing is the action of assigning a 
sequence of comma-separated values to a variable.  
● Slice: This refers to a smaller segment of a sequence. 
 
Here are a few exercises that will help you master data structures. 
1. Write a program to access the elements in a list 
2. Write a program to slice a list in Python.  
3. Write a program to delete elements in a List. 
4. Write a program to access elements in a tuple. 

5. Write a program to change a tuple.  
 
 
If  you are enjoying the audiobook, I would love if you went to Audible and leave a short 
review. 
 
 
 

Chapter Six: Working with Strings 
 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
 
Most commands in Python 3 will work in exactly the same way as in 
Python 2. There are, however, some important changes. Probably the 
most fundamental change is the rationalization of the string data type. In 
previous versions of Python, strings were coded as a sequence of single 
bytes, using the limited American Standard Code for Information 
Interchange (ASCII) character set to represent text, this 7-bit encoding 
allows for up to 128 characters including uppercase and lowercase 
letters, numbers, punctuation, and 33 invisible control characters. While 
ASCII is OK for representing languages that use Latin script, such as 
English and most European languages, it is completely useless when it 
comes to representing the 2,000 basic ideograms of the Chinese 
language. To deal with these sorts of problems, the Unicode standard 
was created to cover all written languages, so Python 3 has brought itself 
up-to-date by switching to Unicode as its default text encoding. The str 
type is what used to be the unicode type, and a new type, byte, has been 
introduced to represent raw text strings and binary data. Previous 
versions of Python went through all sorts of contortions in order to deal 
with text encoding; fortunately, all you really need to know is that the str 
type in Python 3 supports international characters by default, so you 
don’t have to do anything special if you want to write a string. 
To go along with the string type changes, the print statement in Python 
2.x has been replaced with the print() function which is a built-in 
function in version 3.0. this function replaces most of the earlier syntax 
with keyword arguments. To balance this, the old raw_input() is 
replaced by input(), and you have to use eval(input()) to get the old 
functionality of input(). 

 
Splitting Strings 
As strings are immutable, you will often want to split them up into lists 
in order to manipulate their contents. Quick reminder—a delimiter is a 
character or string of characters that are used to separate words or units 
of data. The list will be split up to maxsplit times, so you’ll end up with a 
list that’s maxsplit + 1 items long. If no separator is specified, the string 
will be split up by whitespace characters as if they are words. 
>>>sentence = ‘This is a long sentence’ 
>>> sentence.rstrip(‘sentence’).split() 
[‘This’, ‘is’, ‘a’, ‘long’] 
Python has an alternative string splitting method, string.partition(sep), 
which returns a tuple: (head, sep, tail). The method identifies the 
separator within the string and then returns the section before the 
separator the separator and the part of the string that is separated from 
the string. If the separator is not found, the method will return the 
original string and two empty strings. 
 
Concatenation and Joining Strings 
Using the + operator to join strings together is very inefficient; combined 
with lots of calls to the print() function (or statement in Python 2), using 
the + operator can potentially slow your program’s execution to a crawl. 
Python isn’t that slow. Often, it works out better to manipulate a list of 
words and then use string.join(sequence) to return a string that is a 
concatenation of the strings in the sequence. This method is the opposite 
of string.split(): the data you want to manipulate is in the sequence of 
the argument, and the string that you call the method on is just the string 
of characters you want to use to separate the items. This could be a space 
or an empty string. 
>>> s1=”example” 
>>> s2 = “text” 
>>> s3 = “ “  
>>> s3.join([s1,s2]) 

‘example text’ 
You must remember that the function string.join() always expects a 
sequence of strings as the argument.  
>>> s3 = “-“ 
>>> s3.join (‘castle’) 
‘c-a-s-t-l-e’ 
You also may have the need to convert different data types into strings by 
using a sublist.  
 
Editing Strings 
Strings, as you have probably gathered by now, can’t be edited in place, 
but they do have some useful methods that will return a new edited 
version of the string.  
You often need to clean up the beginning and end of the string to remove 
extraneous whitespace or punctuation, especially if you’re trying to 
compare some user input with a stored value. This is done with the 
string.strip([chars]) method. This returns a copy of the string with chars 
removed from the beginning and the end if the sequence is found. If no 
arguments are given, string.strip() will remove whitespace characters by 
default. 
>>> sentence = ‘This is a long sentence’ 
>>> sentence.strip(‘A’) 
‘ This is long sentence’ 
 
How to Match Patterns 
Sometimes, the basic string methods just aren’t enough. For example, 
you may need to retrieve values that appear within a regular pattern in a 
piece of text, but you don’t know what those values are going to be or just 
have a rough idea of what they should not be. This is where regular 
expressions come in. A regular expression (regex, for short) is a pattern 
that can match a piece of text. In its simplest form, a regular expression 
could just be a plain string of ordinary characters that matches itself. 
Regular expression syntax uses additional special characters to recognize 

a range of possibilities that can be matched. These expressions can be 
used in search and replace operations and to split up text in different 
way than string.split(). 
Regular expressions are complex, powerful, and difficult to read. Most of 
the time, you can manage without them, but they are particularly useful 
when dealing with complex, structured pieces of text. It’s best to take 
regular expressions slowly, learning a bit at a time. Trying to learn the 
whole regular expression syntax all in one go could be quite 
overwhelming.  
Regular expression matching operations are provided by the re module. 
As re is not built in by default, it is necessary to import the module first 
before it is possible to use it. 
>>> import rein 
The module supports both 8-bit and Unicode strings, so it should be 
possible to recognize any characters that you can type in from the 
keyboard or read from a file.  
Next, you need to construct a regular expression string to represent the 
pattern you want to catch. Let’s use the rather colorful string from earlier 
in the chapter again. 
 
 
 
Creating a Regular Expression Object 
You can compile a regular expression pattern into a regular expression 
object using re.compile(pattern[, flags]). This returns a pattern object on 
which you can call all the previous methods, but you no longer need to 
provide the pattern as an argument. You might want to do this if you 
need to use this pattern to perform lots of matches all at once; compiling 
the pattern into an object speeds up the pattern comparison process, 
because the pattern does not have to then be compiled each time it is 
used. You might also need to use this approach where a function 
specifically requires a regular expression object to be passed to it rather 
than just a pattern string. 
Exercises:  
1. Write a Program to create a string.  
 

If  you are enjoying the audiobook, I would love if you went to Audible and leave a short 
review. 
 
 
 
 

Chapter Seven: How to Use Files 
 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
 
So far, data has either been written into the program itself or received via 
the input() function and printed out using the print() function. Once the 
program has finished its execution, the data is lost. In order for an 
application to have any practical value, it is necessary to be able to store 
that information and retrieve it the next time the program is run. The 
vast majority of computer information is stored in files on a hard drive or 
similar storage medium or can be transmitted via some file-like object. 
File-like objects share some similar properties with files and can often be 
treated with the same methods; streams are an important kind of file-
like object. 
 
How to Open Files 
File objects can be created with the built-in open(filename[, mode[, 
buffering]]) function. Built-in functions and methods also return file 
objects. Let us open a plain text file in the same directory where we 
started the interpreter.  
>>> open(‘Python.txt’) 
<io.TextIOWrapper object at 0xb7ba990c> 
The example above uses another Python object which says it is an 
io.TextIOWrapper; in plain language, that’s a file object. If the file 
doesn’t exist, you’ll get an IOError. IO stands for input/output, in other 
words, reading and writing to files. The file object now holds the 
contents of story.txt, but in order to do anything with it, you need to 
learn some file methods. 
I hope you’re getting used to the concept that everything in Python is 
some type of object and that any type of object will usually have several 
methods that you can use to access its values or edit it. Before you can 

make use of the different file methods, it is important to understand the 
different ways that Python can open a file to create a file object. 
 
Modes and Buffers 
Opening the file by just passing the filename to open() creates a read-
only file object. If you want to be able to write to that file as well, it is 
necessary to set the optional mode argument. This argument can be a 
single character: r (read), w (write), or a (append), any of which may be 
followed by b (binary) or + (read/write). If you don’t provide a mode 
argument, Python will assume your file is a text file, and mode r will be 
assumed. 
>>> open(‘Python.txt’, ‘rb’) 
<io.BufferedReader object at 0xb7ba990c> 
The b mode returns a different kind of object to the default file object—
one that contains the same information in byte format. You might want 
to use this if you wanted to handle image or audio data. Write mode (w) 
lets you change the contents of the file completely. Append mode (a) only 
lets you add information to the end. This last option is useful for creating 
log files.  
The buffering argument, used with w or a, can either be 0 or 1. If it’s 0, 
your data is written straight to your hard-drive. If it’s 1, Python creates a 
temporary file to store the text in before it gets written out. The data is 
not written to disk unless you explicitly call file.flush() or file.close(). You 
probably won’t need this option immediately. 
 
Reading and Writing  
The most basic method you can use to access the file’s contents is 
file.read([size]). This reads up to size bytes from the file (less if the read 
hits the end of the file before it gets to size bytes). The complete file is 
read as one string if there is no size argument provided or if it is 
negative. Unless the file is opened as a binary object, the bytes are 
returned as string objects. In such cases, you will only have raw bytes as 
output. If you are reading a plain text file containing ordinary characters, 
you might not notice a great deal of difference. 
>>> text = open('Python.txt')  

>>> text.read()  
'Are you keen to learn the Python language 
[... pages more text here ...]  
Thank you for purchasing the book.\n' 
If you are dealing with a large body of text like the following example, 
you may wish to deal with it in smaller pieces. file.readline([size]) reads 
a single line from the file (up to the next newline character, \n). An 
incomplete line may be returned in an iteration. The size argument is 
defined as the number of bytes that the interpreter must read. The bytes 
also include the trailing newline. If the interpreter reaches the end of the 
file, an empty string is returned.  
>>> text = open(‘Python.txt’) 
>>> text.readline() 
“Are you keen to learn more about the Python language. Thank 
you for purchasing the book. I hope you gather all the 
information you were looking for.” 
Files are their own iterators, so you can also iterate through lines in a file 
using a for loop. The same result as the file.readline() method is returned 
at each iteration and the loop only ends when the method returns a null 
or empty string.  
Try the following code out:  
>>> for line in text: 
… print (line) 
 
Closing Files 
It is a good idea to use file.close() to close a file after you are finished 
with it. Python will probably notice that you’re not using the file anymore 
and free up the memory space eventually, but explicitly closing it is 
cleaner. Often, the data in a file.write() operation is stored in a buffer 
until the file is closed. You can make sure the data gets written out to the 
file without closing it by using file.flush(). A file once closed cannot be 
further read or written. You are allowed to call close() more than once.  

Chapter Eight: Working with Functions 
 
The first design considerations in making a new function are what kind 
of input it needs and what information the function will return. Of close 
importance are the type and structure of the data that will be fed in and 
retrieved. Data supplied to a function are called parameters, and the 
final information that is returned is known as results, or output. Our 
initial specification for the function design should also include a general 
description of the function’s specific purpose. 
 
Defining a Function 
A function is always defined using the def statement. The word def is 
followed by the function name, an optional list of parameters and the 
line ends with a colon which indicates that the subsequent lines should 
be indented as a suite or block of instructions. Let’s start with a function 
that takes no parameters: 
>>> def generate_rpc():  
... """Role-Playing Character generator  
"""  
... profile = {}  
... print "New Character"  
... return profile 
This block of instructions proceeds in exactly the same way as a complete 
script. So, in essence, we give a name to each piece of functionality, and 
they are called functions.  
If you want to provide some notes on what the function does, you can do 
so in the docstring, which must be the first thing in the function. The 
docstring is then followed by a series of statements that are the core 
functionality. The function can also return some data using a return 
statement.  
The function’s last line specifies which variables get returned to the main 
program. If there is nothing to return, you do not have to use a return 
statement, and Python will assume None as the default return value. 

Up to this point, the block of code in our function has not yet been run; it 
has simply been assigned to the function definition. To get the code to 
run, you need to call the function from the main body of the program. 
(This is called a function call.) Since we have given names to functions, 
we can call those functions any number of times: 
>>> generate_rpc()  
New Character  
{} 
We haven’t specified any parameters in this example, hence the empty 
parentheses after the function name. 
 
Defining Parameters 
Most functions work on some data that they have been given by the main 
program. In order for the function to receive data, it needs to set up 
some empty containers to hold the data. These become variables unique 
to the function and are known as formal parameters, and it’s best if they 
don’t use the same names as in the main program. These formal 
parameters have to be specified in the parentheses after the function 
name on the first line of the function definition. 
import random  
def roll(sides, dice):  
result = 0 for rolls in range(0,dice):  
result += random.randint(1,sides)  
return result 
This function might be called from the main program in the following 
way:  
muscle = roll(33,3)  
The values in parentheses in the function call are known as arguments; 
they correspond to the formal parameters in the function definition. In 
this case, the first argument, 33, is bound to the parameter sides, and the 
second argument, 3, is bound to the parameter dice. This effectively 
creates two variables, sides and dice, to be used inside the function. If 
you just send the function values like this, there must be the same 

number of arguments as parameters, and they have to be in the right 
order, so these are known as positional arguments. You could substitute 
the actual values in the function call with variables if you prefer. Just 
remember that the function is going to refer to that value by the name of 
the parameter that receives it, and the original variable will remain 
unaffected; only the value gets passed on. 
 
Documenting your Function 
Once a function is fully coded and passes the tests you have set for it, it is 
a good time to edit its docstring to fit with the expectations of Python’s 
documentation tools.  
Docstrings are expected to follow convention: The first line of a docstring 
should be a short description of the function that makes sense by itself 
and fits on only one line (usually a maximum of 79 characters, including 
any indentation). The next line should be left blank. After that, the body 
of the docstring should contain a description of the function’s 
parameters, a longer description of the function, notes about the 
algorithm used, and an example of how to use the function that includes 
details of optional arguments, keyword arguments, and its return values. 
You might also want to include information about possible side-effects, 
exceptions, and restrictions on when the function can be called (these 
matters will be covered later in this book). In short, all the information 
that another programmer would need to be able to use the function. It is 
very important to update your docstrings and comments every time the 
code changes. 
 
Working with Scope 
One way of conceptualizing functions is to think of them as black boxes 
that take in source data, process it and pass it back. The code in the main 
program that sends the source data and receives the result is known as 
the calling procedure. It doesn’t need to know what is inside the black 
box, so long as the source data and results are clearly identified. 
 
Understanding Scope 
When you write a function, you should not have to worry about using 
names that will clash with names used in the other parts of the program. 
This is why we have the concept of scopes.  

When any program is run, the interpreter keeps track of all the names 
that are created and used in the program. These names are tracked in a 
table referred to as a symbol table and can be viewed as a dictionary 
using the built-in vars() function. The variables created in the main 
program’s symbol table are known as global variables, because any part 
of the program can access these variables. These can be viewed with the 
built-in globals() function. You will notice that the result of running 
vars() with no arguments inside the main program is the same as 
running globals(). So far, the script examples in this book have only used 
global data. 
Any variable that is created in a function is stored in a symbol table 
unique to that function; this data is known as local data and can be 
accessed within that function using the locals() function. The main body 
of the program (global scope) cannot access the variables set inside the 
function (local scope). The function, however, is still able to access 
names in the main body, that is, globals. Hence, you have two ways to get 
at a function to process some data: The correct way is to take that data as 
a parameter for the function; the function will process it and then return 
the result, which will be collected by the main program. The other way is 
to let the function directly access and process the global data, but this 
second way is discouraged because the function works with only 
particular variable names and cannot be reused anywhere else. 
 
Manipulating Dictionaries and Lists 
Parameters to a function are passed by value. However, in the case of 
objects (unlike simple types such as integers and strings), if you modify 
the parts of an object, including items in a list or a dictionary, the 
changes are reflected outside the function as well. This means that a 
function can be used to modify a mutable data type such as a dictionary 
or list. Technically, such a modification procedure is not a pure function, 
as it neither needs a return value or indeed, any input parameters.  
In order to avoid strange side-effects, a good general policy is to send 
and return immutable values from functions and keep any modification 
procedures for your mutable types separate. If you send a list or 
dictionary to a function, all you are doing is sending it a pointer to the 
same global instance of that object, just as if you had written local_list = 
global_list. 

Abstraction 
This round of testing may bring new issues to light. In order to help you 
keep track of what’s going on with your code, do the minimum necessary 
to get the new code to pass its tests. If the new code fails, you should roll 
back the changes to the point where the code passes again. Also, if using 
the function doesn’t work, don’t sweat it: reverse the changes and move 
on. There is no rule that says you have to abstract everything into a 
function.  
The processes of placing code into functions (abstraction) and turning 
code that deals with specifics into general-purpose code (generalization) 
can also be applied to your testing procedures, and this is a good thing to 
do. All these test procedures will eventually get moved outside the 
program into a separate module, so abstraction and generalization are 
also good preparation. The rule to remember is to write your tests first 
and then make sure your existing code still passes before attempting to 
refactor it. Although this might seem like a laborious approach, in fact, it 
speeds up the development of new code and provides a mechanism for 
flagging up which part of the code needs fixing next, rather than having 
to keep all the details in your head. This has to be a good thing. 
 
If  you are enjoying the audiobook, I would love if you went to Audible and leave a short 
review. 
 
 
 

Chapter Nine: Solutions 
 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
 
Concatenate two strings 
# Python Program - Concatenate String 
 
print("Enter 'x' for exit."); 
string1 = input("Please enter the first string: "); 
if string1 == 'My name is Dobby': 
    exit(); 
else: 
    string2 = input("Please enter the second string: "); 
    string3 = string1 + string2; 
    print("\nString after concatenation =",string3); 
    print("String 1 =",string1); 
    print("String 2 =",string2); 
    print("String 3 =",string3); 
 
Sum of Two Numbers 
# Program to add two numbers 
  
number1 = input(" Please Enter the First Number: ") 
number2 = input(" Please Enter the second number: ") 
  

# Using the arithmetic operator to add two numbers 
sum = float(number1) + float(number2) 
print('The sum of {0} and {1} is {2}'.format(number1, number2, sum)) 
 
Even and Odd Numbers 
# Program to check whether a number is even or odd 
# When a number is divided by 2 and the remainder is 0, the number is 
even.  
# If remainder is 1, the number is odd. 
 
num = int(input("Enter a number: ")) 
if (num % 2) == 0: 
   print("{0} is Even".format(num)) 
else: 
   print("{0} is Odd".format(num)) 
 
Fibonacci Series 
# Program to display the Fibonacci sequence up to n-th term where n is 
provided by the user 
 
# change this value for a different result 
nterms = 10 
 
# uncomment to take input from the user 
#nterms = int(input("How many terms? ")) 
 
# first two terms 
n1 = 0 

n2 = 1 
count = 0 
 
# check if the number of terms is valid 
if nterms <= 0: 
   print("Please enter a positive integer") 
elif nterms == 1: 
   print("Fibonacci sequence upto",nterms,":") 
   print(n1) 
else: 
   print("Fibonacci sequence upto",nterms,":") 
   while count < nterms: 
       print(n1,end=' , ') 
       nth = n1 + n2 
       # update values 
       n1 = n2 
       n2 = nth 
       count += 1 
 
Palindrome 
# Program to check if a string is a palindrome or not 
# change this value for a different output 
 
my_str = 'I need to save Harry Potter' 
 
# make it suitable for caseless comparison 
my_str = my_str.casefold() 
 

# reverse the string 
rev_str = reversed(my_str) 
 
# check if the string is equal to its reverse 
if list(my_str) == list(rev_str): 
   print("It is palindrome") 
else: 
   print("It is not palindrome") 
 
Access Elements in a List 
my_list = ['p','r','o','b','e'] 
# Output: p 
print(my_list[0]) 
 
# Output: o 
print(my_list[2]) 
 
# Output: e 
print(my_list[4]) 
 
# Error! Only integer can be used for indexing 
# my_list[4.0] 
 
# Nested List 
n_list = ["Happy", [2,0,1,5]] 
 
# Nested indexing 
 

# Output: a 
print(n_list[0][1])     
 
# Output: 5 
print(n_list[1][3]) 
 
Slice a List 
my_list = ['p','r','o','g','r','a','m','i','z'] 
# elements 3rd to 5th 
print(my_list[2:5]) 
 
# elements beginning to 4th 
print(my_list[:-5]) 
 
# elements 6th to end 
print(my_list[5:]) 
 
# elements beginning to end 
print(my_list[:]) 
 
Delete Elements in a List 
>>> my_list = ['p','r','o','b','l','e','m'] 
>>> my_list[2:3] = [] 
>>> my_list 
['p', 'r', 'b', 'l', 'e', 'm'] 
>>> my_list[2:5] = [] 
>>> my_list 
['p', 'r', 'm'] 

 
Access Elements in a Tuple 
my_tuple = ('p','e','r','m','i','t') 
 
# Output: 'p' 
print(my_tuple[0]) 
 
# Output: 't' 
print(my_tuple[5]) 
 
# index must be in range 
# If you uncomment line 14, 
# you will get an error. 
# IndexError: list index out of range 
 
#print(my_tuple[6]) 
 
# index must be an integer 
# If you uncomment line 21, 
# you will get an error. 
# TypeError: list indices must be integers, not float 
 
#my_tuple[2.0] 
 
# nested tuple 
n_tuple = ("mouse", [8, 4, 6], (1, 2, 3)) 
 
# nested index 

# Output: 's' 
print(n_tuple[0][3]) 
 
# nested index 
# Output: 4 
print(n_tuple[1][1]) 
 
Change a Tuple 
my_tuple = (4, 2, 3, [6, 5]) 
 
# we cannot change an element 
# If you uncomment line 8 
# you will get an error: 
# TypeError: 'tuple' object does not support item assignment 
 
#my_tuple[1] = 9 
 
# but item of mutable element can be changed 
# Output: (4, 2, 3, [9, 5]) 
my_tuple[3][0] = 9 
print(my_tuple) 
 
# tuples can be reassigned 
# Output: ('p', 'r', 'o', 'g', 'r', 'a', 'm', 'i', 'z') 
my_tuple = ('p','r','o','g','r','a','m','i','z') 
print(my_tuple) 

 
Create a String 
# all of the following are equivalent 
my_string = 'Hello' 
print(my_string) 
 
my_string = "Hello" 
print(my_string) 
 
my_string = '''Hello''' 
print(my_string) 
 
# triple quotes string can extend multiple lines 
my_string = """Hello, welcome to 
           the world of Python""" 
print(my_string) 
 
 

Conclusion 
 
Thank you for purchasing the book.  
This book acts as a guide for those who are working with Python for the 
first time. Over the course of the book, you will gain information on what 
Python is and how to code in Python. Before you begin to program, there 
are some questions you must ask yourself to understand the right code 
you must write. This is called the software development stage and is one 
of the most important steps to complete when writing a code. Python is a 
simple language and is written as a pseudocode. As a programmer, you 
will find that it is easy for you to code in Python. 
You will gather information on different aspects of Python including – 
data types, structures, functions, how to work with files, how to work 
with strings including others. There are some exercises given at the end 
of the chapters which can be used to practice. The solutions to these 
exercises are provided in the last chapter of the book. The exercises 
provided in the book are simple but they will help you learn how to write 
simple code in Python. Once you understand the language better, you 
can go onto developing larger and more complex programs. Try to work 
on the exercises before you look at the solutions in the last chapter.  
You must remember that it is practice that will help you become the best 
programmer in any language. It is okay to make mistakes when you write 
code, but it is important that you learn from those mistakes. Keep a 
notepad close to you and make note of all the variables and functions you 
have declared in your code to ensure that you do not overwrite them with 
new code.  
I hope you gather all the information you are looking for. Good luck on 
your new adventure. 
Now head over to Audible and tell me what you think! 
Timothy C. Needham 
 

Other Books By Timothy C. Needham 
 
Python For Beginners: A Crash Course Guide To Learn Python in 
1 Week 
 
Excel 2016: A Comprehensive Beginner’s Guide to Microsoft Excel 2016 
 
Learn Java: A Crash Course Guide to Learn Java in 1 Week 
 
 
 
 


 
ALL RIGHTS RESERVED. No part of this publication may be reproduced or 
transmitted in any form whatsoever, electronic, or mechanical, including 
photocopying, recording, or by any informational storage or retrieval system without 
express written, dated and signed permission from the author. 

  
Sneak Preview of Python For Beginners. 
I would like to share with you a free sneak peek to another one of my audiobooks that I 
think you will really enjoy. The audiobook is called “Python For Beginners: A Crash Course 
Guide To Learn Python in 1 Week” and it’s about how you can easily learn Python language 
in 
less 
than 
a 
week. 
Enjoy!

Chapter 1: Python: A Comprehensive Background 
 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
Before we discuss Python programming, especially what python is, let me briefly say 
something about programming.   
Being a good programmer does not simply entail just knowing a vast array of 
programming languages or how to code fast programs. Instead, it is about: 
• Comprehending a problem abstractly and being able to change it into code. 
• Looking for new ways to tackle, for instance, a scientific problem and knowing the 
kind of tools to use. 
• Being able to fix a program when it is not working 
• Writing a program that is quick enough, not the quickest possible 
• Writing a program that other people can understand in a short period of time 
Take note of the last point: Reproducible research and open science is becoming the 
norm in some research fields. This means that other people will probably have to 
read your code, understand exactly what you are doing and be able to recreate the 
code so that they can run it themselves.  
By the end of this book therefore, we will not only be interested in the correctness of 
your solutions; we shall also look at whether we can understand how the program 
you create solves the problem.  
This is to mean that you should always write your codes assuming that someone else 
will read it.  
Let’s go back to understanding python, the programming language of the future.  
 
What Is Python? 
In its simplest terms, python is a general-purpose, multi-paradigm, and interpreted 
programming language that gives programmers the ability to use various styles of 
programming to create complex or simple programs, get results faster, and write 
code in a way that resembles human language (explanation below).  
Python is the programming language often used to create algorithms for sorting and 
analyzing chunks of data that businesses and organizations from all over the world 
collect.  
 

The explanation above brings about some very interesting points about python: 
1. It’s a high level language 
Python is a high-level language. This means the code you type to build a program is 
more like a human language than the typical code created to control machines. This, 
for one, makes things a lot simpler for you, the programmer, and means that 
someone else is better placed to understand the code if  he/she wants to use it 
him/herself. The human-like (high-level) code then goes through a software called an 
interpreter that converts it into machine code, a language that machines can 
understand. 
2. Its open source 
The software that lets us make programs in Python is open source. This means it is 
available in the public domain and anyone can freely use it. The greatest advantage of 
this software is the fact that you can modify it and create your own version to 
perform particular tasks. This is actually the main reason why many people have 
openly embraced the open source concept and the use of python is no exception.  
Let’s discuss this briefly: 
 
Associations that Use Python 
Many organizations currently use Python to complete major tasks. You will not 
always hear about their uses since organizations are somewhat reserved about 
sharing their systems’ information, or ‘trade secrets.’ Nonetheless, Python is still 
there making a great difference in the way organizations function and many common 
systems and applications have settled for Python for their development. Some of 
them include YouTube, Google Search, BitTorrent, NASA, Eve Online, iRobot 
machines, Yahoo, Facebook, Maya and many others.  
Look at the following commercial uses of Python:  
Corel: Over the years, people have used products such as PaintShop Pro to grab 
screenshots, modify pictures, draw fresh images, and perform many other graphic 
oriented tasks. What is amazing about this popular product is that it heavily relies on 
Python scripting. This means to automate tasks in PaintShop Pro, you will need a 
degree of Python knowledge.  
D-link: It can be quite problematic to upgrade firmware over a network connection, 
and this company (D-link) encountered a situation where every upgrade tended to tie 
up a machine, something they described as a weak utilization of resources. 
Additionally, a number of upgrades needed extra work since there were problems 
with the targeted device.  
The use of python to build a multi-threaded application that allows for the movement 
of updates to the devices enables one machine to service several devices, and a new 
methodology supported by python decreases all the reboots to one, after the 
installation of that fresh firmware is done. 

Moreover, this company opted for Python over other languages such as Java because 
Python offers an easy to use serial communication code. 
ForecastWatch.com: Have you ever wondered if someone somewhere reviews 
your weatherman’s performance? Well, if you have, look no further; this company 
does that. This company compares the thousands of weather forecasters produced 
every day against real climatological data in order to determine their accuracy. The 
produced report advances weather forecasts. 
In this particular case, the software used in the comparisons is a pure Python 
program since it contains standard libraries that are important in the collection, 
parsing, and storage of data from online sources. Additionally, the enhanced, 
multithreaded nature and capability of python gives it the ability to gather the 
forecasts from about 5,000 sources per day. The code is also a lot smaller than what 
other languages like PHP or Java would need. 
Many other companies, softwares, and programs use Python and to sum this up, I 
will say that scientists, business people, teachers, governments, and even religious 
organizations, just to mention the least use python programming in one form or the 
other.  
You too should also get started with learning python if you don’t want to be left 
behind. 
We’ll 
start 
from 
the 
beginning 
i.e. 
downloading 
the 
program.

Chapter 6: Variables 
Before continue, please refer to your audiobook companion PDF that comes free 
with your purchase of this audiobook to see and learn all the codes, explained with 
charts and images. 
 
I’m sure you have noted that experimenting with angles requires changing three 
different numbers or places in the code each time. Can you imagine trying out all the 
sizes of squares or with rectangles? Would that not be tedious? Luckily, we have 
easier ways to do that than changing many numbers each time.  
Using variables, we can achieve that sleekly. You will be able to tell python that 
whenever you refer to a variable, you actually mean something else. When you relate 
it to symbolic math, where you can write “let x be 5”, this concept may be a bit more 
familiar. In this case, then x*2 is obviously 10.  
In python syntax, this statement is explained as x = 5. 
After the statement, if you happen to ‘print (x)’, it outputs the value -5. We can also 
use that for turtle as well.  
turtle.forward(x) 
Variables store all sorts of stuff, not just numbers. Another thing you may want to 
store regularly is a ‘string’. A string just refers to a piece of text. These (Strings) 
usually have a starting as well as an ending double quote (“) - we will delve into that, 
the other data types you can store, and what you can use these for later in the book.  
Did you know that you can even refer to the turtle by name using a variable? Here is 
an explanation of this in play: 
john = turtle 
Now, each time you type ‘john’, python thinks you mean ‘turtle’. However, you can 
keep using turtle as well: 
 
The Angle Variable  
This is an exercise. If you create a variable known as tilt (you could assign it a 
number of degrees), how could you use that to make your experiment with the tilted 
squares program much faster? 
This is the solution: 

 
- ..and so on! 
NOTE: You could also apply this principle to the size of the squares 
Santa Claus’ House  
Now draw a house 
 
NOTE: You can calculate the diagonal line’s length using the Pythagorean Theorem. 
That is actually a good value to store in as a variable. To determine the square root of 
a given number in Python, you ought to first import the specific math module then 
proceed to use this function: ‘math.sqrt()’. We exponentiate a number with the ** 
operator (thus, squaring means **2). 

 
 
Next, we will be discussing loops.  
 
 
If  you are enjoying the audiobook, I would love if you went to Audible and leave a short 
review. 

If you enjoyed this preview of my audiobook “Python For Beginners: A Crash Course Guide 
To Learn Python in 1 Week” , be sure to check out the full audiobook on Audible.com 
 

