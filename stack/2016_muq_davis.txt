MIT Uncertainty QuantiÔ¨Åcation (MUQ) Library
Andrew Davis 1
Matthew Parno 2
Youssef Marzouk 1
1Massachusetts Institute of Technology
2Cold Regions Research and Engineering Lab (CRREL)
SIAM UQ 2016
Davis (MIT)
MUQ
SIAM UQ 2016
1 / 24

MUQ: philosophy
‚ÄúA small change in algorithm or application
should only require a small change in code‚Äù
Goals:
Provide a sandbox for playing with diÔ¨Äerent models and algorithms
Facilitate constructive modeling
Extensible and easily hybridized algorithms
Reduce distance and time between algorithms and applications
Davis (MIT)
MUQ
SIAM UQ 2016
2 / 24

MUQ: philosophy
‚ÄúA small change in algorithm or application
should only require a small change in code‚Äù
Goals:
Provide a sandbox for playing with diÔ¨Äerent models and algorithms
Facilitate constructive modeling
Extensible and easily hybridized algorithms
Reduce distance and time between algorithms and applications
Target audiences:
Algorithm developers
Application scientists and engineers
Davis (MIT)
MUQ
SIAM UQ 2016
2 / 24

MUQ: outline
1
Modeling framework
Constructing combined (physical + statistical) models with high-level
structure
Graphical modeling technique to easily combine sub models
2
Algorithm framework
Example: Markov chain Monte Carlo stack ‚Äî using mathematical
structure in software design
3
MUQ development update
Use of MUQ in our research
Davis (MIT)
MUQ
SIAM UQ 2016
3 / 24

MUQ: modeling
Unique modeling approach:
1
Graphically building physical and statistical models
Connect models and algorithms to expose underlying structure
Davis (MIT)
MUQ
SIAM UQ 2016
4 / 24

MUQ: modeling
Unique modeling approach:
1
Graphically building physical and statistical models
Connect models and algorithms to expose underlying structure
2
Easy to swap and extend models
Apply MCMC (and other algorithms) to a wide variety of applications
Davis (MIT)
MUQ
SIAM UQ 2016
4 / 24

MUQ: modeling
Unique modeling approach:
1
Graphically building physical and statistical models
Connect models and algorithms to expose underlying structure
2
Easy to swap and extend models
Apply MCMC (and other algorithms) to a wide variety of applications
3
‚ÄúGrey-box‚Äù approach: MUQ wraps around existing models, but
uses any new or available problem structure
Davis (MIT)
MUQ
SIAM UQ 2016
4 / 24

MUQ: modeling
Unique modeling approach:
1
Graphically building physical and statistical models
Connect models and algorithms to expose underlying structure
2
Easy to swap and extend models
Apply MCMC (and other algorithms) to a wide variety of applications
3
‚ÄúGrey-box‚Äù approach: MUQ wraps around existing models, but
uses any new or available problem structure
4
Built-in tools to implement physical models
Davis (MIT)
MUQ
SIAM UQ 2016
4 / 24

Graphical models in MUQ
Physical & statistical models are
implemented separately (ModPieces)
# create submodels
theta = VectorPassthroughModel()
prior = GaussianDensity(mu, sig)
f = ForwardModel()
like = GaussianDensity()
post = DensityProduct()
Davis (MIT)
MUQ
SIAM UQ 2016
5 / 24

Graphical models in MUQ
Physical & statistical models are
implemented separately (ModPieces)
Each component represents a piece of
the overall model
(e.g., prior, likelihood, forward model)
# create submodels
theta = VectorPassthroughModel()
prior = GaussianDensity(mu, sig)
f = ForwardModel()
like = GaussianDensity()
post = DensityProduct()
Davis (MIT)
MUQ
SIAM UQ 2016
5 / 24

Graphical models in MUQ
Physical & statistical models are
implemented separately (ModPieces)
Each component represents a piece of
the overall model
(e.g., prior, likelihood, forward model)
Separately implement submodels:
# create submodels
theta = VectorPassthroughModel()
prior = GaussianDensity(mu, sig)
f = ForwardModel()
like = GaussianDensity()
post = DensityProduct()
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
5 / 24

Graphical models in MUQ
Submodels are connected ‚Äî becoming
graphs (ModGraphs)
# Add graph nodes
G = ModGraph()
G.AddNode(theta, ‚ÄôParameter‚Äô)
G.AddNode(prior, ‚ÄôPrior‚Äô)
G.AddNode(f, ‚ÄôForward Model‚Äô)
G.AddNode(like, ‚ÄôLikelihood‚Äô)
G.AddNode(post, ‚ÄôPosterior‚Äô)
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
6 / 24

Graphical models in MUQ
Submodels are connected ‚Äî becoming
graphs (ModGraphs)
Node: A submodel (ModPiece)
# Add graph nodes
G = ModGraph()
G.AddNode(theta, ‚ÄôParameter‚Äô)
G.AddNode(prior, ‚ÄôPrior‚Äô)
G.AddNode(f, ‚ÄôForward Model‚Äô)
G.AddNode(like, ‚ÄôLikelihood‚Äô)
G.AddNode(post, ‚ÄôPosterior‚Äô)
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
6 / 24

Graphical models in MUQ
Submodels are connected ‚Äî becoming
graphs (ModGraphs)
Node: A submodel (ModPiece)
Directed edge: out/input of each submodel
# Add graph nodes
G = ModGraph()
G.AddNode(theta, ‚ÄôParameter‚Äô)
G.AddNode(prior, ‚ÄôPrior‚Äô)
G.AddNode(f, ‚ÄôForward Model‚Äô)
G.AddNode(like, ‚ÄôLikelihood‚Äô)
G.AddNode(post, ‚ÄôPosterior‚Äô)
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
6 / 24

Graphical models in MUQ
Submodels are connected ‚Äî becoming
graphs (ModGraphs)
Node: A submodel (ModPiece)
Directed edge: out/input of each submodel
Exposes underlying structure
# Add graph nodes
G = ModGraph()
G.AddNode(theta, ‚ÄôParameter‚Äô)
G.AddNode(prior, ‚ÄôPrior‚Äô)
G.AddNode(f, ‚ÄôForward Model‚Äô)
G.AddNode(like, ‚ÄôLikelihood‚Äô)
G.AddNode(post, ‚ÄôPosterior‚Äô)
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
6 / 24

Graphical models in MUQ
Submodels are connected ‚Äî becoming
graphs (ModGraphs)
Node: A submodel (ModPiece)
Directed edge: out/input of each submodel
Exposes underlying structure
Add submodels to the graph:
# Add graph nodes
G = ModGraph()
G.AddNode(theta, ‚ÄôParameter‚Äô)
G.AddNode(prior, ‚ÄôPrior‚Äô)
G.AddNode(f, ‚ÄôForward Model‚Äô)
G.AddNode(like, ‚ÄôLikelihood‚Äô)
G.AddNode(post, ‚ÄôPosterior‚Äô)
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
6 / 24

Graphical models in MUQ
Submodels are connected ‚Äî becoming
graphs (ModGraphs)
Node: A submodel (ModPiece)
Directed edge: out/input of each submodel
Exposes underlying structure
Connect nodes with edges:
# Add graph edges
G.AddEdge(‚ÄôParameters‚Äô, ‚ÄôForward Model‚Äô, 0)
G.AddEdge(‚ÄôForward Model‚Äô, ‚ÄôLikelihood‚Äô, 0)
G.AddEdge(‚ÄôLikelihood‚Äô, ‚ÄôPosterior‚Äô, 0)
G.AddEdge(‚ÄôParameters‚Äô, ‚ÄôPrior‚Äô, 0)
G.AddEdge(‚ÄôPrior‚Äô, ‚ÄôPosterior‚Äô, 1)
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
7 / 24

Advantages of graph-based modeling
1
Relates implementation structure to
intuitive interpretation
# use a different forward model
g = AnotherForwardModel()
G.SwapNode(‚ÄôForward Model‚Äô, g)
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
8 / 24

Advantages of graph-based modeling
1
Relates implementation structure to
intuitive interpretation
2
Easy to swap pieces of the problem
formulation
# use a different forward model
g = AnotherForwardModel()
G.SwapNode(‚ÄôForward Model‚Äô, g)
Parameters: Œ∏
Forward model:
g(Œ∏)
Likelihood:
œÄ(d|g(Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
8 / 24

Advantages of graph-based modeling
1
Relates implementation structure to
intuitive interpretation
2
Easy to swap pieces of the problem
formulation
# use a different forward model
g = AnotherForwardModel()
G.SwapNode(‚ÄôForward Model‚Äô, g)
3
‚ÄúGrey-box‚Äù wrapper around existing models
Parameters: Œ∏
Forward model:
g(Œ∏)
Likelihood:
œÄ(d|g(Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
8 / 24

Grey-box wrapper: Using existing models (C++)
Existing implementation becomes a submodel
The user only needs to write a MUQ/existing solver interface:
class ModelWrapper : public muq::Modeling::ModPiece ‚Äì
public:
// A way to create the submodel
ModelWrapper(inputSizes, outputSize) :
ModPiece(inputSizes, outputSize)
private:
// Grey-box implementation
Eigen::VectorXd EvaluateImpl(std::vector¬°Eigen::VectorXd¬ø
const& inputs) ‚Äì
Eigen::VectorXd output(outputSize);
/* ***** CALL EXISTING CODE HERE ***** */
return output;
Àù
Àù;
Davis (MIT)
MUQ
SIAM UQ 2016
9 / 24

Grey-box wrapper: Using existing models (Python)
Existing implementation becomes a submodel
The user only needs to write a MUQ/existing solver interface:
class ModelWrapper(libmuqModelling.ModPiece):
# a way to create the submodel
def ÀôÀôinitÀôÀô(self, inputSizes, outputSize):
libmuqModelling.ModPiece.ÀôÀôinitÀôÀô(inputSizes, outputSize)
# Grey-box implementation
def EvaluateImpl(self, inputs):
# #### CALL EXISTING CODE HERE #### #
# existing code returns output (list type)
return output
Davis (MIT)
MUQ
SIAM UQ 2016
10 / 24

Derivative implementation (C++)
User may optionally implement derivative information
Gradient, Jacobian, Jacobian‚Äôs action, and/or Hessian
The user only needs to write a MUQ/existing solver interface:
class ModelWrapper : public muq::Modeling::ModPiece ‚Äì
// Model implementation
Eigen::VectorXd EvaluateImpl(std::vector¬°Eigen::VectorXd¬ø
const& inputs) ‚Äì return output; Àù
// Derivative implementation
virtual Eigen::VectorXd
GradientImpl(std::vector¬°Eigen::VectorXd¬ø const& inputs,
Eigen::VectorXd const& sensitivity,
int const inputDimWrt) override ‚Äì
return gradient;
Àù
Àù;
Davis (MIT)
MUQ
SIAM UQ 2016
11 / 24

Model derivatives
1
Option to include user implemented
derivatives
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
12 / 24

Model derivatives
1
Option to include user implemented
derivatives
2
Defaults to Ô¨Ånite diÔ¨Äerence if analytic
derivatives are not implemented
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
12 / 24

Model derivatives
1
Option to include user implemented
derivatives
2
Defaults to Ô¨Ånite diÔ¨Äerence if analytic
derivatives are not implemented
3
Computes derivative of the graph‚Äôs output
via the chain rule
Parameters: Œ∏
Forward model:
f (Œ∏)
Likelihood:
œÄ(d|f (Œ∏))
Prior:
œÄ(Œ∏)
Posterior:
œÄ(Œ∏|d) ‚àùœÄ(d|f (Œ∏))œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
12 / 24

Built-in modeling tools
1
Extensible submodel class (ModPiece)
Davis (MIT)
MUQ
SIAM UQ 2016
13 / 24

Built-in modeling tools
1
Extensible submodel class (ModPiece)
2
Implemented common models:
Component-wise functions (exp, sin, . . .)
Component-wise sum
Linear solver Ax = b (using Eigen)
and many more . . .
Davis (MIT)
MUQ
SIAM UQ 2016
13 / 24

Built-in modeling tools
1
Extensible submodel class (ModPiece)
2
Implemented common models:
Component-wise functions (exp, sin, . . .)
Component-wise sum
Linear solver Ax = b (using Eigen)
and many more . . .
3
Sundials interface
Numerical integration of ODEs, state-discretized PDEs
Root-Ô¨Ånding algorithms
Davis (MIT)
MUQ
SIAM UQ 2016
13 / 24

Built-in modeling tools
1
Extensible submodel class (ModPiece)
2
Implemented common models:
Component-wise functions (exp, sin, . . .)
Component-wise sum
Linear solver Ax = b (using Eigen)
and many more . . .
3
Sundials interface
Numerical integration of ODEs, state-discretized PDEs
Root-Ô¨Ånding algorithms
4
Transient and steady PDE solver
User must implement the weak form
Derivative information computed via automatic diÔ¨Äerentiation
(Sacado)
Finite element method spatial discretization (LibMesh)
Davis (MIT)
MUQ
SIAM UQ 2016
13 / 24

MUQ: outline
1
Modeling framework
Constructing combined (physical + statistical) models with high-level
structure
Graphical modeling technique to easily combine sub models
2
Algorithm framework
Example: Markov chain Monte Carlo stack ‚Äî using mathematical
structure in software design
3
MUQ development update
Use of MUQ in our research
Davis (MIT)
MUQ
SIAM UQ 2016
14 / 24

MUQ: MCMC
Question
What are the fundamental components of an MCMC algorithm?
Metropolis-Hastings MCMC:
1
Save current state
Œ∏(k) = Œ∏
2
Propose new state
Œ∏‚Ä≤ ‚àºq(Œ∏‚Ä≤|Œ∏)
3
Accept or reject
Œ± = min

1, œÄ(Œ∏‚Ä≤)
œÄ(Œ∏)
q(Œ∏|Œ∏‚Ä≤)
q(Œ∏‚Ä≤|Œ∏)

Davis (MIT)
MUQ
SIAM UQ 2016
15 / 24

MUQ: MCMC
Question
What are the fundamental components of an MCMC algorithm?
Metropolis-Hastings MCMC:
1
Save current state
Œ∏(k) = Œ∏
2
Propose new state
Œ∏‚Ä≤ ‚àºq(Œ∏‚Ä≤|Œ∏)
3
Accept or reject
Œ± = min

1, œÄ(Œ∏‚Ä≤)
œÄ(Œ∏)
q(Œ∏|Œ∏‚Ä≤)
q(Œ∏‚Ä≤|Œ∏)

Chain
Kernel
Proposal
Davis (MIT)
MUQ
SIAM UQ 2016
15 / 24

MUQ: MCMC
Question
What are the fundamental components of an MCMC algorithm?
Metropolis-Hastings MCMC:
1
Save current state
Œ∏(k) = Œ∏
2
Propose new state
Œ∏‚Ä≤ ‚àºq(Œ∏‚Ä≤|Œ∏)
3
Accept or reject
Œ± = min

1, œÄ(Œ∏‚Ä≤)
œÄ(Œ∏)
q(Œ∏|Œ∏‚Ä≤)
q(Œ∏‚Ä≤|Œ∏)

Chain
Kernel
Proposal
We copy this structure with
C++ classes
Easily extendable
Many possible conÔ¨Ågurations
(> 30)
Davis (MIT)
MUQ
SIAM UQ 2016
15 / 24

MUQ: full MCMC framework
Chain Kernel
Proposal
AMALA
AM
RW
smMALA
HMC
MH
DR
TM
IA
Single
Multi
Advantages:
New proposals used with any kernel
Focus eÔ¨Äorts on new features
Changing components is trivial
Extensive performance comparisons
are straightforward
// MH + AMALA:
ps.put(‚ÄùMCMC.Kernel‚Äù,‚ÄùMH‚Äù);
ps.put(‚ÄùMCMC.Proposal‚Äù,‚ÄùAMALA‚Äù);
// TM + RW:
ps.put(‚ÄùMCMC.Kernel‚Äù,‚ÄùTransportMap‚Äù);
ps.put(‚ÄùMCMC.Proposal‚Äù,‚ÄùMHProposal‚Äù);
Davis (MIT)
MUQ
SIAM UQ 2016
16 / 24

MCMC and models
Observation:
Many MCMC algorithms rely on speciÔ¨Åc problem structure.
Solution:
Use problem classes that can exploit graphical representations.
MCMC
Algorithm
Sampling
Problem
Graphical
Model
Davis (MIT)
MUQ
SIAM UQ 2016
17 / 24

MCMC and models
Observation:
Many MCMC algorithms rely on speciÔ¨Åc problem structure.
Solution:
Use problem classes that can exploit graphical representations.
MCMC
Algorithm
Sampling
Problem
Graphical
Model
Problem iterates through graph and extracts important structure:
Gaussian prior and error model
Linear models
Gauss-Newton Hessians
etc. . .
Davis (MIT)
MUQ
SIAM UQ 2016
17 / 24

MCMC and models
Observation:
Many MCMC algorithms rely on speciÔ¨Åc problem structure.
Solution:
Use problem classes that can exploit graphical representations.
MCMC
Algorithm
Sampling
Problem
Graphical
Model
Problem iterates through graph and extracts important structure:
Gaussian prior and error model
Linear models
Gauss-Newton Hessians
etc. . .
No extra eÔ¨Äort: Structure automatically deÔ¨Åned in ‚Äúgrey-box‚Äù model.
Davis (MIT)
MUQ
SIAM UQ 2016
17 / 24

Beyond MCMC
Lessons learned:
Design code to mimic the mathematics
Allows us easily add new components without duplicate code
Makes algorithms more conÔ¨Ågurable and intuitive
Davis (MIT)
MUQ
SIAM UQ 2016
18 / 24

Beyond MCMC
Lessons learned:
Design code to mimic the mathematics
Allows us easily add new components without duplicate code
Makes algorithms more conÔ¨Ågurable and intuitive
Use gray-box for automated structure extraction
Enables algorithms to exploit high-level structure
Still allows arbitrary model implementations (e.g., legacy code)
Davis (MIT)
MUQ
SIAM UQ 2016
18 / 24

Beyond MCMC
Lessons learned:
Design code to mimic the mathematics
Allows us easily add new components without duplicate code
Makes algorithms more conÔ¨Ågurable and intuitive
Use gray-box for automated structure extraction
Enables algorithms to exploit high-level structure
Still allows arbitrary model implementations (e.g., legacy code)
Notes:
Similar structure exists in our optimization algorithms
More complicated chains being tested (DILI, DILI+maps, etc.)
Davis (MIT)
MUQ
SIAM UQ 2016
18 / 24

MUQ: outline
1
Modeling framework
Constructing combined (physical + statistical) models with high-level
structure
Graphical modeling technique to easily combine sub models
2
Algorithm framework
Example: Markov chain Monte Carlo stack ‚Äî using mathematical
structure in software design
3
MUQ development update
Use of MUQ in our research
Davis (MIT)
MUQ
SIAM UQ 2016
19 / 24

MUQ usage: ice sheet modeling
Solve conservation equations with uncertain input parameters . . .
Uncertain basal topography
Uncertain basal friction
Uncertain width
Longitudinal
stress
‚àí
Frictional
stress
‚àí
Lateral
stress
=
Driving
stress
Momentum balance equation
Change in
thickness
+
Advection
=
Accumulation
and ablation
Stochastic
calving
Mass balance equation
. . . computed Ô¨Åeld are used within UQ algorithms (e.g., Monte Carlo,
optimization, MCMC, importance sampling ect. . . .)
Davis (MIT)
MUQ
SIAM UQ 2016
20 / 24

MUQ usage: map-accelerated MCMC
Use nonlinear variable transformation to ‚Äúprecondition‚Äù target density.
reference proposal
qr(r ‚Ä≤|r) = N(r, œÉ2I)
mapped proposal
qŒ∏(Œ∏‚Ä≤|Œ∏) = qr
  ÀúT(Œ∏‚Ä≤)| ÀúT(Œ∏)
 detD ÀúT(Œ∏‚Ä≤)

The exchangeability of MCMC components makes testing many
reference proposals easy
Davis (MIT)
MUQ
SIAM UQ 2016
21 / 24

MUQ usage: characterizing marginal distributions
Build a surrogate model of the marginal using stochastic evaluations
‚àí2
‚àí1
0
1
2
3
4
5
Œ∏
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
22 / 24

MUQ usage: characterizing marginal distributions
Build a surrogate model of the marginal using stochastic evaluations
Using the surrogate to evaluate the acceptance ratio does not aÔ¨Äect
the proposal
‚àí2
‚àí1
0
1
2
3
4
5
Œ∏
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
22 / 24

MUQ usage: characterizing marginal distributions
Build a surrogate model of the marginal using stochastic evaluations
Using the surrogate to evaluate the acceptance ratio does not aÔ¨Äect
the proposal
We can easily combine many proposal methods (e.g., MH, AM,
DRAM, . . .) with surrogate modeling
‚àí2
‚àí1
0
1
2
3
4
5
Œ∏
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
œÄ(Œ∏)
Davis (MIT)
MUQ
SIAM UQ 2016
22 / 24

MUQ: development notes
Development improvements:
Google analytics:
0
2
4
6
8
10
12
14
16
18
0
50
100
Workshop
SIAM CSE
Weeks since 1 Dec 2014
Sessions/week
BitBucket
Doxygen
Davis (MIT)
MUQ
SIAM UQ 2016
23 / 24

MUQ: development notes
Development improvements:
Improved build system
cmake automatically downloads and installs dependencies
Google analytics:
0
2
4
6
8
10
12
14
16
18
0
50
100
Workshop
SIAM CSE
Weeks since 1 Dec 2014
Sessions/week
BitBucket
Doxygen
Davis (MIT)
MUQ
SIAM UQ 2016
23 / 24

MUQ: development notes
Development improvements:
Improved build system
cmake automatically downloads and installs dependencies
Extensive testing for corrent and/or consistent perfermance
Automated code testing for veriÔ¨Åcation with Jenkins
Google analytics:
0
2
4
6
8
10
12
14
16
18
0
50
100
Workshop
SIAM CSE
Weeks since 1 Dec 2014
Sessions/week
BitBucket
Doxygen
Davis (MIT)
MUQ
SIAM UQ 2016
23 / 24

muq.mit.edu
Davis (MIT)
MUQ
SIAM UQ 2016
24 / 24

