SACJ, No 42., 2008 
 
 
87 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
a
g th  T e
 
 
r
 L
g a es n  
Teaching the Theory of Formal Languages and 
 
 
 
 
 
 
 
 
 
 
o
 n 
 
p te  
ce 
Automata in the Computer Science 
g
r i
u
UndergraduateCurriculum    
Nelishia Pillay1 
School of Computer Science, University of KwaZulu Natal, Pietermaritzburg Campus 
ABSTRACT 
The theory of formal languages and automata form an essential component of the undergraduate Computer Science curriculum both 
nationally and internationally.  This paper reports on the experiences of teaching the theory of formal languages and automata at 
universities worldwide.  The paper discusses how this area is incorporated into the Computer Science undergraduate curriculum, 
teaching and learning difficulties generally encountered, different teaching methodologies employed and teaching and learning aids.  
The paper also identifies further areas of research into improving the teaching and learning of the theory of formal languages and 
automata. 
  
G
 
CATEGORIES 
 
 
 
 
D 
B E
 D S
T
AND SUBJECT DESCRIPT
R
ORS    
K.3.2 [Computers and Education]: Computer and Information Science Education – computer science education, curriculum.  
  
E
R
 
R
GENERAL TERMS    
Computer Science Education. 
KEYWORDS    
Theory of formal languages, automata theory.  
 
                                                                 
 
1 Email: pillayn32@ukzn.ac.za 
1. INTRODUCTION 
This paper aims to bring together different experiences in 
teaching and learning theory of formal languages and automata 
at universities worldwide.  As such it provides a reference for 
academics teaching this material for the first time and for those 
who wish to further develop and improve their courses on 
formal language and automata theory (FLAT). 
Research into the teaching and learning of FLAT is a well 
established area of Computer Science Education research and a 
session is often dedicated to this topic at the annual ACM 
SIGCSE (Special Interest Group on Computer Science 
Education) conferences with the SIGCSE ‘06 including a panel 
discussion on the teaching of automata [1].  As mentioned 
above this paper provides a survey of experiences in teaching 
and learning FLAT and also highlights future areas of research 
for improving the teaching and learning of this topic.  As such 
the paper will also serve as a reference for new and current 
researchers in this field. 
The following section provides an overview of how FLAT 
topics are incorporated into an undergraduate Computer 
Science curriculum.  This is followed by a discussion on the 
learning and teaching difficulties generally experienced at 
universities with FLAT courses.  Teaching methodologies and 
aids employed to overcome these problems are then presented.  
Finally, the paper identifies areas for further improvement of 
the teaching and learning of FLAT. 
2.  FLAT IN THE COMPUTER SCIENCE 
UNDERGRADUATE CURRICULUM 
The Computing Curricula report for Computer Science 
composed by the ACM and IEEE [43] outlines which FLAT 
topics are core topics and must form part of the Computer 
Science undergraduate curriculum and which areas are 
electives. Table1 lists the core topics and Table 2 the electives.   
 
Table 1: Core FLAT topics described in the 
Computing Curricula report 
Basic Computability 
 
• 
Finite-state machines 
• 
Context-free grammars 
• 
Tractable and intractable problems 
• 
Uncomputable functions 
• 
The halting problem 
• 
Implications of uncomputability 
 
 
 

88 
 
 
 
 
 
SACJ, No 42., 2008 
 
A survey of the undergraduate Computer Science curricula 
taught at universities nationally and internationally was 
conducted via the Internet. Approximately fifteen curricula 
were reviewed. The survey revealed that a majority of both the 
core and elective topics are taught to undergraduate students.  
In most institutions a course on FLAT is taught in the third year 
of a three year undergraduate degree. At some universities these 
topics are taught over the second and third year and at a few 
institutions basic FLAT concepts are included in first year 
courses.  Some FLAT courses include additional topics such as 
parsing or cellular automata.  Table 3 tabulates the topics, in 
order of complexity, that were found to be common to most 
FLAT modules and some of the additional topics taught.  FLAT 
courses usually have a Discrete Mathematics prerequisite due to 
the mathematical nature of the course.  In a number of 
universities the FLAT course is a prerequisite for a fourth year 
course on Compilers and Programming Languages. 
 
Table 2: Elective FLAT topics described in the Computing 
Curricula report 
The Complexity Classes P 
and NP 
Automata Theory 
• 
Definition 
of 
the 
classes P and NP 
• 
NP-Completeness 
(Cook’s  
theorem) 
• 
Standard 
NP-
complete  
problems 
• 
Reduction techniques 
 
• 
Deterministic 
finite 
automata  
(DFAs) 
• 
Nondeterministic finite  
automata (NFAs) 
• 
Equivalence of DFAs 
and  
NFAs 
• 
Regular expressions 
• 
The pumping lemma for  
regular languages 
• 
Pushdown 
automata 
(PDAs) 
• 
Relationship of PDAs 
and  
context-free grammars 
• 
Turing machine  
• 
Nondeterministic 
machines 
• 
Sets and languages 
• 
Chomsky hierarchy 
• 
The 
Church-Turing 
Thesis 
 
 
 
Table 3: FLAT topics that form part of undergraduate 
Computer Science curricula 
Common Topics 
Additional Topics 
 
• 
Deterministic 
finite 
automata (DFAs) 
• 
Nondeterministic finite  
automata (NFAs) 
• 
Finite 
transducers 
(Mealy  
and Moore machines) 
• 
Converting 
NFAs 
to 
DFAs 
• 
Pumping lemma for  
context-free languages 
• 
Parsing – top-down  
parsing, 
bottom-up 
parsing, 
LR, 
SLR, 
LALR parsers 
• 
Set theory 
• 
Cellular automata 
• 
Cryptography 
• 
L-systems 
• 
Regular expressions 
• 
DFAs, NFAs and regular 
expressions  
• 
Properties of regular  
languages 
• 
Context-free grammars  
(CFGS) 
• 
CFG simplification and  
normal forms 
• 
Pushdown 
automata 
(PDAs) 
• 
Turing machines 
• 
Recursively enumerable  
languages 
• 
Church’s Thesis 
• 
The Universal Turing  
machine 
• 
Decidability, the halting  
problem and reducibility 
• 
NP completeness  
 
• 
Kleene’s 
characterisation 
of 
computability 
• 
Quantum computing 
 
 
The instruction of FLAT courses takes the form of a 
combination of lectures and weekly tutorials.  Traditional chalk-
and-board methods are used to teach students the different 
concepts during lectures.  Lectures are based on a prescribed 
textbook. Table 4 lists the textbooks generally prescribed in 
FLAT courses in order of popularity.  These courses are taught 
without the use of computers and usually do no include any 
programming [27].  Tutorials require students to work through 
exercises which are submitted for assessment and the marks 
obtained for the tutorials usually contribute to the class mark for 
the course.  Other forms of assessment commonly used in 
FLAT courses include tests during the semester and an end-of-
semester examination.  A few FLAT courses include a practical 
project such as the construction of a scanner for a compiler. 
However, this is rare and is usually included in courses that 
present additional topics such as parsing.   
 
Table 4:  Textbooks commonly prescribed in FLAT 
courses 
Book Title 
Reference 
Introduction to the Theory of 
Computation 
(Sipser, 2005) 
[35] 
Introduction to Automata Theory, 
Languages and Computation 
(Hopcroft,  
2006) [21] 
An Introduction to Formal Languages 
and Automata 
(Linz, 2006) 
[25] 
Introduction to Computer 
Theory 
(Cohen, 1997) 
[11] 
 
The following section describes difficulties experienced by 
both lecturers and students involved in FLAT courses. 
3. TEACHING AND LEARNING 
DIFFICULTIES 
FLAT topics have been found to be difficult to teach and learn 
([6], [7], [26], [42]).  Students generally find FLAT courses to 
be outdated and cannot relate them to other courses in the 

SACJ, No 42., 2008 
 
 
89 
Computer Science curriculum or current computer applications 
([23], [39]).  Thus, students taking a FLAT course tend to be 
disinterested and are not motivated.   
Due to the mathematical nature of the course students find 
the topics covered abstract and difficult ([14], [39], [40], [41]).  
The 
traditional 
chalk-and-board 
teaching 
methodology 
employed to teach FLAT courses makes it difficult for students 
to conceptualise the different structures and proofs ([9], [26]).  
The paper tutorials do not facilitate immediate feedback and are 
not interactive which also makes learning difficult ([5], [14], 
[31], [39], [40]).  Verma [39] states that this often leads to 
student frustration and a higher drop-out rate for FLAT courses 
than other Computer Science courses.  Furthermore, these 
difficulties often result in students obtaining a “superficial” 
understanding of FLAT concepts [7].  This point was further 
emphasised by student evaluations conducted by the author in a 
third year undergraduate course on FLAT, in which some 
students commented that they had not obtained a deep enough 
understanding of proofs. 
On the one hand lecturers have to deal with de-motivated 
and often frustrated students.  In addition to this marking of 
written tutorials submitted by students is difficult and time-
consuming to mark by hand and the process is error prone. The 
following section discusses methods employed to overcome 
these difficulties. 
4. TEACHING STRATEGIES 
Given the problems outlined in the previous section, a lot of 
research has been conducted into improving the teaching and 
learning of FLAT courses.  Constructivist teaching methods 
which require students to learn by doing and using and building 
on existing knowledge of concepts are replacing the traditional 
chalk-and-board methods which facilitate passive learning.  
Such constructivist methods promote active learning which is 
important in Computer Science [42]. 
A number of visual tools that can be used for both teaching 
and learning have been developed to motivate students and help 
them obtain a deeper understanding of FLAT constructs and 
proofs.   
Learning tools that provide individualised student tuition, 
namely, intelligent tutoring systems, are also being investigated 
as a means of assisting students to overcome learning 
difficulties with FLAT. 
Attempts have also been made to increase students’ interest 
by using current Computer Science applications to discuss the 
different concepts.  The inclusion of historical information on 
FLAT in courses has also proven to simulate student interest.   
Chesnevar et al. ([7], [8]) have found that a combination of 
using visual tools, relating FLAT concepts to other Computer 
Science topics and current applications and providing an 
overview of the role played by FLAT in Computer Science 
history, is effective in motivating students and helping them 
conceptualise the different FLAT concepts. 
These different approaches are discussed in the sections that 
follow. 
4.1 Pen-and-Paper Approach 
The author has conducted a study to test a pencil-and-paper 
based constructivist approach to teaching FLAT topics.  In 
traditional teaching methods students are lectured on the FLAT 
concepts and complete exercises during a tutorial on these 
concepts.  In this case the teaching of the concepts and the 
testing of the students’ understanding and knowledge (by means 
of tutorials) obtained during teaching are done in different 
sessions at different times.  The problem with this scenario is 
that students are not able to immediately test their perception of 
the concepts taught and obtain immediate feedback to rectify 
any misconceptions.   
In the approach taken by the author the structure of lectures 
was changed to facilitate students testing their comprehension 
of the topics taught immediately and receiving immediate 
feedback to allow them to correct errors in their knowledge and 
understanding.  During a lecture a new topic is firstly 
introduced.  The students are then required to work on exercises 
which help test their comprehension of the concept.  The 
student can ask for assistance while working through the 
exercises.  The students and lecturer then go through the 
solutions together.  For example, in teaching the construction of 
automata or grammars the lecturer obtains a complete or partial 
solution from a student.  The lecturer then works through how 
the students can assess the solution and how to improve the 
solution if it is incorrect.   
The tutorial for the week further tests the students’ skill and 
knowledge gained during the lectures for the week by 
presenting students with more challenging problems than those 
worked through in lectures.  It is anticipated that this approach 
will progressively develop the students’ knowledge of FLAP 
concepts and skill at solving problems.  The tutorials are 
marked by the lecturer and a tutorial feedback session is held to 
discuss problems generally experienced by students with the 
tutorial.  These tutorials also give the lecturer an idea of which 
concepts the students’ have not grasped and which skills need 
to be further developed.   
An evaluation of this approach was conducted.  Students 
were asked to anonymously write down what they liked about 
the course, what they did not like about the course and any 
suggestions they may have.  The evaluation revealed that 
students found this approach helpful in learning the different 
FLAT concepts.  The students felt that the approach was 
interactive and that the exercises during lectures helped them to 
understand the concepts taught.  Some of the comments made 
by students include: “Interactive, lots of examples”; “The 
technique of working examples in class for a few minutes and 
thereafter going through it together, I personally thought was 
very helpful and effective since it allowed us to grasp the 
concept quickly and thus making learning easier”; “What is 
done in lectures is reinforced in tutorials”; “The tutorials were 
done almost in conjunction with the lesson, so we could extend 
what we had learnt”. 
However, these methods could not be used to help students 
conceptualise proofs and some students felt that while they had 
grasped the “mechanics” of proofs they had not developed a 
deeper understanding.  The use of visualization tools, which is 
discussed below, is a possible solution to this problem. 
4.2 Pen-Based Computing Approach 
Berque et al. [3] have tested the use of pen-based computing as 
a means of ensuring that students are “actively engaged” 
throughout a FLAT lecture.  Often students are absorbed in note 
taking rather than concentrating on explanations being provided 
by the lecturer.  The approach taken by Berque et al. is similar 
to the pencil-and-paper-based approach described above.  The 
lecturer basically presents new material to the students using the 
electronic whiteboard.  Students do not need to take notes since 
whatever is written to the whiteboard is automatically 
transferred to the student video tablets.  The students, using 
pen-based computing tools, can add their own personal 
explanations and notes to the material and store it.  Students are 
then required to work on a problem on the material, e.g. 
constructing a DFA, and can obtain assistance from the lecturer 

90 
 
 
 
 
 
SACJ, No 42., 2008 
 
if needed.  The lecturer then randomly selects a student’s 
solution, which is transmitted to the lecturers video tablet and 
discussed with the class.   This process is repeated for each new 
concept introduced.  To encourage students to play an active 
role in this process students are allocated an “engagement 
grade” which contributes to their class mark. 
An empirical evaluation of this approach revealed that 
students found this method effective in helping them grasp the 
different concepts.  A majority of the students indicated that 
they preferred this form of lecturing instead of the traditional 
chalk-and-board methods.  Students also indicated that this 
form of instruction forced them to be more attentive during 
lectures. 
4.3 Visualization Tools 
Numerous visualization tools have been developed to motivate 
students and assist them in understanding FLAT constructs and 
proofs.  These tools facilitate experimentation that would be 
difficult and boring to do on paper [33].  Some of these tools 
basically provide animations of the different concepts and 
proofs.  Others allow students to create different FLAT 
structures like automata and grammars and simulate the created 
construct and so debug it. These tools can be used in the 
classroom by lecturers and by students in tutorials and for 
revision and studying purposes.  This section provides an 
overview of these tools.  A majority of these tools are freely 
available over the Internet. 
Chesnevar et al. [6] divide the visualization tools into two 
categories, namely, those that focus on a single concept or type 
of language, e.g. finite automata, or the Pumping Lemma, or 
regular languages, and those that cover more than one FLAT 
topic, e.g. finite automata and pushdown automata and Turing 
machines.  In this paper these categories will be referred to as 
single-function and multi-function tools respectively.  In some 
instances the tool has been developed over time and hence a 
number of different versions of the tool exist. In these cases the 
latest version of the tool is described. 
Single-function tools have been developed for regular 
expressions, finite automata, pushdown automata and Turing 
machines.    A number of tools exist for visualizing regular 
language structures. RegeXeX is a tool developed by Brown et 
al. [4] to help students construct regular expressions.  RegeXeX 
presents the student with an exercise, from the repository of 
exercises maintained by the system, and provides feedback on 
the correctness of the solution.  RegeXeX can also be used in 
the classroom to illustrate how regular expressions are created. 
CAVE (Constructive Algorithm Visualization Environment) is 
a teaching aid to assist lecturers in illustrating the construction 
of DFAs and combining DFAs using operators such as union 
and concatenation [6].  FSME (Finite State Machine Explorer) 
provides an environment in which the user can construct finite 
state machines and test them on different inputs [6]. It also 
caters for the conversion between equivalent classes of 
machines.  TAGS (Transducer Automata Graphical Simulator) 
allows the user to define and run finite state transducers, 
namely, Moore and Mealy machines [13]. FSA Simulator 
simulates deterministic and nondeterministic automata by 
highlighting transitions between states ([15], [16], [17]).  The 
user is able to create DFAs in the form of transition diagrams.  
FSA Simulator checks the solution entered by the student by 
determining the equivalence of the student’s DFA and a stored 
solution and guides the student on how to correct his/her 
attempt.  ProofChecker is used to create, in the form of a 
transition graph, and visualize deterministic finite automata 
[36].  ProofChecker provides feedback on solutions entered by 
students highlighting both the syntactical and semantic errors 
made. ProofChecker also assists students in determining the 
language a DFA accepts.  Two versions of ProofChecker have 
been developed, one for sighted students and another for 
visually impaired students.  The authors have also developed 
ProofGrader for marking student submissions.    
Language emulator Vieira et al. [40] and FAdo (Finite 
Automata devoted oracle) developed by Moreira et al. [27] 
enable the user to create and simulate regular expressions, 
regular grammars, deterministic and nondeterministic finite 
acceptors. The user can also perform operations such as union, 
interaction, difference and complement on DFAs.  These 
systems also perform conversions of NFAs to DFAs, 
conversions between finite acceptors and regular expressions, 
conversions between finite acceptors and regular grammars.  
Both systems find errors in student solutions and provide 
feedback on the errors. In the language emulator input is in the 
form of a transition table while input to FAdo is in text form.  
The language emulator also allows for the creation, simulation 
and conversions of Mealy and Moore machines. 
IPAA (Interaction Pushdown Automata Animation) is a 
system developed by McDonald [26] and is dedicated to the 
creation and simulation of pushdown automata.  PDAs are 
entered as transition graphs and the user is given the option of 
stepping through simulations. Visual tools for Turing machines 
include Turing’s World [40], Turing Machine Simulator and 
VisualTuring [6]. Turing’s World provides an environment in 
which the user can construct and simulate Turing machines 
while Turing Machine Simulator and VisualTuring basically 
simulate existing machines and allow the user to edit the 
existing machines. 
Multi-function visual tools include Minerva, JCT (Java 
Computability Tool), DEM (Deus ex Machina), AtoCC, jFAST 
and JFLAP. Minerva can be used to construct and debug finite 
state acceptors, PDAs, Turing machines and grammars [6]. It 
also helps students to construct solutions to problems on the 
Pumping Lemma for regular languages.  Unfortunately, 
Minerva is only available in Spanish.  JCT also caters for the 
creation and simulation of finite automata and Turing machines 
[6].   DEM is a supplement to a textbook on FLAT [37] and 
covers finite state machines, pushdown automata, Turing 
machines, register machines, vector machines, linear-bounded 
automata and Markov algorithms [6].  Taylor [38] uses DEM to 
demonstrate the Church-Turing thesis.  Taylor states that tools 
such as DEM allow for different models of computability to be 
constructed 
and 
analysed, 
thus 
facilitating 
such 
a 
demonstration. 
AtoCC assists students in understanding the phases from 
creating a finite automaton through to compiler construction 
[20]. 
JFLAP (Java Formal Languages and Automata Package) has 
been developed over a number of years ([5], [14], [30], [31],  
[32], [33], [39]). It facilitates the construction and simulation of 
regular expressions, finite acceptors (DFAs and NFAs), finite 
transducers (Mealy and Moore machines), regular grammars, 
PDAs, context-free grammars, unrestricted grammars, single 
and multi-tape Turing machines, L-systems, LL(1) and SLR(1) 
parsers.  JFLAP can perform conversions between automata and 
grammars for regular and context-free languages, conversions 
between regular expressions and automata and conversions 
between Mealy and Moore machines. It also allows for the 
simplification of context-free grammars and the conversion of 
CFGs to normal forms. JFLAP can also test the equivalence of 
machines, minimise DFAs and combine automata.  Later 
versions of JFLAP facilitate the creation of complex Turing 
machines by combining simpler machines which are treated as 

SACJ, No 42., 2008 
 
 
91 
building blocks.  JFLAP also caters for the creation and 
simulation of Universal Turing machines.  The latest version of 
JFLAP provides games for assisting students in learning the 
Pumping Lemma for regular and context-free languages.   
JFLAP has been used by both students and lecturers.  For 
example, JFLAP can be used in lectures to illustrate the 
properties of regular languages when proving that regular 
languages are closed under certain operations or illustrating the 
advantage of a two-tape Turing machine over a one-tape Turing 
machine.  JFLAP has also been used in a classroom setting 
where students are firstly required to use JFLAP to either solve 
a problem or rectify an incorrect solution.  The students and 
lecturer then discuss the different approaches to finding a 
solution [14].  JFLAP also provides lecturers with a facility for 
batch marking.   
According to White et al. [42] most visual tools for FLAT 
require students to have some knowledge of concepts and 
mathematical notation used and are thus not suitable for 
introductory level FLAT topics such as those typically taught at 
first year level.  White et al. have developed jFAST as a 
supplement to existing visual tools.  This tool can be used as an 
aid in basic FLAT courses with other tools such as JFLAP 
being used later on in the curriculum.  In the development of 
jFAST emphasis was placed on ease-of-use and is aimed at 
providing assistance in both the teaching and learning of FLAT.  
Users can construct and simulate finite automata and jFAST 
performs error checking on solutions entered and provides 
feedback accordingly.  The error-checking component can also 
be used by lecturers to mark student tutorials.  jFAST also 
facilitates the simulation of PDAs and Turing machines. 
Hannay [19] has created a package consisting of web-based 
simulators for regular expressions, finite state machines, 
pushdown automata, context-free grammars and Turing 
machines.  This package enables students to trace through built-
in examples of the different structures and so assists them in 
conceptualising these constructs. 
Wermelinger et al. [41] use a Prolog toolkit rather than a 
simulator to assist students in learning FLAT concepts. The 
toolkit contains structures and proofs that can be used and/or 
extended by students to test and develop their understanding of 
regular language structures and pushdown automata. The toolkit 
“reinforces learning by doing”.  The authors feel that while 
simulators provide a visualisation of the different structures, the 
toolkit facilitates a deeper level of understanding of concepts as 
the student is required to understand and change existing 
programs.  Thus, the authors suggest that the toolkit be used in 
conjunction with a simulator. 
Student feedback on the use of visual tools was generally 
positive.  According to Vieira et al. [40] students found the 
tools helpful in testing the solutions they firstly created on 
paper. Studies with JFLAP revealed that a majority of the 
students preferred either using JFLAP to create solutions or 
firstly constructing solutions on paper and then testing it with 
JFLAP. 
It is evident from the discussion presented in this section that 
there are a variety of tools available to help learners 
conceptualise the different FLAT concepts.  These tools differ 
with respect to interfaces, input formats and simulation 
processes.  JFLAP has proven to be quite popular and the 
authors report that it is currently being used in over 160 
countries by both students for learning purposes and lecturers 
for more effective teaching [33].   Empirical evaluations of the 
different tools have indicated that there is no one best tool [18].  
Students’ learning styles have a direct impact on which tool/s 
they prefer.  Furthermore, a number of students preferred to use 
more than one simulator to give them different views of FLAP 
concepts ([6], [7], [8]).  Table 5 below lists the websites for the 
tools discussed in this section that are accessible via the 
Internet.  
4.4 Intelligent Tutoring Systems 
Intelligent tutoring systems (ITSs) are learning tools that  
provide the learner with individualised tuition. The ITS 
maintains a model of the student’s knowledge and skills on the 
concepts being taught and tailors the instruction accordingly.  
There is not much research into the use of ITSs for FLAT and 
most of the work is still in the early stages of development.  For 
example, Pillay et al. [29] describe how genetic programming 
can be used in the expert module of an ITS for finite automata 
to automatically generate solutions to problems presented to the 
student.  The generated solutions can then be compared to the 
student solutions and feedback can be provided accordingly.  
Devedzic et al. [12] propose an intelligent tutoring system, 
namely 
FLUTE 
(Formal 
Languages 
and 
Automata 
Environment), to teach FLAT.  The architecture of FLUTE 
consists of an expert module, an explanation module, a student 
model, a pedagogical module and a user interface.   
The expert module consists of domain knowledge obtained 
from text books and experts in the field and includes 
information on applications of FLAT, lesson plans for the 
different topics and a set of examples and exercises. The 
explanation module generates answers to student questions.  
The student model keeps track of the student’s knowledge and 
how the student learns.  This model is constantly updated.  
Based on the student model, the pedagogical module decides on 
what to teach next, which problems to use to test the student, 
how much help to give the student and when the student needs 
this assistance.  This module is also responsible for responding 
to student questions.   
The system provides for four learning levels, namely 
preliminaries, basic, senior level and advanced level.  The 
preliminary level covers mathematic basics needed and the 
Table 5: Visual tools that can be accessed via the 
Internet 
Simulator 
Web Site 
RegeXeX 
http://www.cs.umd.edu/~hardisty/resea
rch/index.html 
CAVE 
http://www.cs.virginia.edu/~mst2f/cav
e.html 
FSME 
http://www.belgarath.org/java/fsme.ht
ml 
TAGS 
http://www.cs.uns.edu.ar/~cic/fcc.htm 
FSA Simulator 
http://www.cs.montana.edu/webworks/
webworks-home/projects/fsa/fsa.html 
ProofChecker 
http://research.csc.ncsu.edu/accessibili
ty/ProofChecker/ 
FAdo 
http://www.ncc.up.pt/fado 
Turing Machine 
Simulator 
http://archives.math.utk.edu/software/
msdos/miscellaneous/jkturing/.html 
 
VisualTuring 
http://www.cheransoft.com/vturing/do
wnload.html 
JCT 
http://humboldt.sunyit.edu/JCT/ 
JFLAP 
http://www.jflap.org/ 
jFAST 
http://www46.homepage.villanova.edu
/timothy.m.white/ 

92 
 
 
 
 
 
SACJ, No 42., 2008 
 
definition of a language.  Finite automata, pushdown automata, 
regular grammars, context-free grammars, and the relationship 
between grammars and automata are taught at the basic level.  
The senior level focuses on Turing machines and decidability 
and the advanced level examines closure properties of 
languages, complexity theory, syntax analysis, grammatical 
transformations and other language classes.  Only the 
preliminary and basic levels have been implemented at this 
stage of the development of FLUTE.   
Mechanisms are built into FLUTE to motivate students and 
keep them actively engaged in the learning process, e.g. the 
system will compliment the student every now again when he or 
she has created a solution to a problem; when presenting a 
particular concept the system may give examples of current 
applications. 
Given the success that intelligent tutoring systems have had 
in other domains, they definitely have potential in assisting 
learners overcome learning difficulties with FLAT.  However, 
research in this area is still in its infancy and much more work 
needs to be done on the development and evaluation of these 
systems before they make their way into Computer Science 
laboratories.  
4.5 Stimulating Student Interest 
Students taking FLAT courses tend to feel that these courses are 
outdated and irrelevant to the rest of the Computer Science 
curriculum and are thus generally disinterested.  Consequently, 
a fair amount of work has been conducted into methods for 
stimulating student interest in FLAT topics.  The following 
methods have proven to be effective at rousing student interest 
in FLAT: 
 
• 
Using examples to link FLAT to other topics in the 
Computer Science curriculum – Chesnevar et al. ([7], [8]) 
suggest that the different FLAT concepts can be illustrated 
in the context of a particular programming language.  
Students taking the course would already have knowledge 
of a first programming language such as Java and would 
thus be able to relate to the illustrations.  Chesnevar et al. 
show how the properties and limitations of the different 
types of languages and grammars can be depicted using a 
programming 
language. 
 
Using 
current 
computer 
applications of FLAT to introduce different FLAT topics - 
According to Devedzic et al. [12] students’ interest can be 
increased by showing them where they can apply the 
knowledge they have obtained, for example in compiler 
construction 
or 
designing 
adaptive 
screen 
forms. 
Applications cited in the literature as being useful for this 
purpose include logic programming and formal verification 
[39]; programming languages, query languages, data 
description languages such as XML, text searches based on 
regular expressions and communication protocols [41]; 
anti-virus problems to illustrate the halting problem, using 
a finite automaton to model word recognition in a text-
entry interface, and hypercomputers [7].  Schreyer et al. 
[34] illustrate the functioning of a nondeterministic finite 
automaton by using an NFA to model a critical process 
with a binary semaphore. A recent article entitled “Things 
I learned in School” published in “ACM Queue”, explains 
the crucial role played by finite state machines in user 
interface design [10]. 
• 
Examining the role that FLAT has played in the history of 
Computer Science – Both Verma [39] and Chesnevar et al. 
([7], [8]) have found that placing FLAT in context of 
Computer Science history makes the course more 
interesting.  For example, when teaching Turing machines 
Chesnevar et al. link this to the history of Alan Turing’s 
life.  When introducing the Church-Turing thesis 
Chesnevar et al. comment on the fact that both Alan 
Turing and Stephen Kleene were PhD students of Alonzo 
Church and thus had similar research goals. Verma has 
included links to historical information on the course 
webpage. 
• 
Using games to illustrate different FLAT concepts – 
Olagunju et al. [28] use the click game to introduce the 
concept of a finite state machine.  A finite automaton is 
used to model the wins and losses in the game.  A different 
approach is taken by Korte et al. [23] in which students 
use different automata to build their own game.  These 
games are generally of a social nature and can differ for 
different countries and cultures.  For example, one of the 
games built in the study conducted by Korte et al. is 
“Becoming the Leader of the Conservative Party” and was 
developed during elections for a new British conservative 
party leader.  Korte et al. show how game-building can be 
used to help students obtain an understanding of finite 
automata and Turing machines.  An empirical evaluation 
of this approach revealed that while game-building most 
definitely motivated weaker students it had a negative 
effect on stronger students.  This once again emphasises 
that in teaching FLAT topics more than one strategy 
should be used to cater for the different learning styles of 
students. 
5. DIRECTIONS FOR FUTURE 
RESEARCH 
From the above discussion it is evident that there has been 
much research conducted into improving the teaching and 
learning of FLAT courses.  This section proposes future 
directions for this research.   
By taking a similar approach to that used by Wermelinger 
[41] in developing the Prolog toolkit, the fact that “computer 
science students generally enjoy writing computer programs” 
[42] can be used to help students better conceptualise and 
understand FLAT topics.  In writing a program for a particular 
application, one usually obtains a better understanding of this 
domain. Students enrolled for FLAT courses in their third year 
of study would have already been exposed to one or more 
programming languages and data structures.  An area for further 
investigation would be to test the effect of getting students to 
write programs that construct and simulate particular automata 
and grammars.  Interface libraries can be provided to ensure 
that students focus on FLAT concepts only.  Students can also 
write programs that perform conversions from one structure to 
another, e.g. grammars to automata and vice versa.  In learning 
the Pumping Lemma for regular languages students can write a 
program that determines the necessary partitions for words into 
x, y, and z [25]. 
Chesnevar et al. [7] state that students often develop 
incorrect mental models of FLAT topics.  Research shows that 
intelligent tutoring systems provide the necessary individualised 
tuition necessary to help students develop the correct mental 
models of different concepts.  However, not much work has 
been done on the use of intelligent tutoring systems for teaching 
FLAT courses and the development of such systems are still in 
their initial stages.  More research into the building of such 
systems needs to be conducted so as to speed up the process of 
getting these systems into laboratories for student use. 
The effectiveness of using collaborative learning by means of 
group work as a teaching tool for Computer Science is 

SACJ, No 42., 2008 
 
 
93 
highlighted by Beck et al. [2] and Joseph et al. [22].  Beck et al. 
state that in addition to aiding the learning process, 
collaborative learning also improves students’ attitudes towards 
the course.  There has not been any research into the use of 
collaborative learning in FLAT courses to stimulate interest and 
assist students in overcoming learning difficulties. This needs to 
be investigated further. 
It is clear from the discussions presented in this paper that 
there has been a large amount of research into strategies, such 
as the use of visual tools, for improving both the learning and 
teaching of FLAT topics.  However, evaluations of these 
methodologies have generally been of an empirical nature.  
Instruments for evaluating these strategies need to be identified 
and a more concrete assessment of the benefits of these methods 
for teaching and learning needs to be conducted. 
6. CONCLUSION 
This paper reports on teaching formal languages and automata 
theory (FLAT) as part of the undergraduate Computer Science 
curriculum.  It provides an overview of how formal languages 
and automata theory can be integrated into a CS undergraduate 
curriculum.  It also highlights the teaching and learning 
difficulties associated with FLAT courses and suggests 
strategies for overcoming these problems.  It is evident that 
traditional chalk-and-board methods are not effective in the 
teaching of FLAT and constructivist teaching strategies that 
promote active learning are essential for students to obtain a 
deeper understanding of FLAT topics.   This study has revealed 
that a combination of teaching strategies is needed in teaching 
FLAT courses in order to cater for the different student learning 
styles.  The paper has also identified areas that need to be 
investigated to further improve the teaching and learning of 
FLAT. 
REFERENCES 
[1] Armoni, M., Rodger, S., Vardi, M. and Verma, R. 2006.  
Automata Theory: It's Relevance to Computer Science 
Students and Course Content.  ACM SIGCSE Bulletin 
inroads 38, 3,197-198. 
[2] Beck, L.L., Chizhik, A. W., and McElroy, A.C. 2005.  
Cooperative Learning Techniques in CS1: Design and 
Experimental Evaluation.  ACM SIGSE Bulletin inroads 
37, 1, 470-474.  
[3] Berque, D., Johnson, D.K., and Jovanovic, L. 2001.  
Teaching Theory of Computation Using Pen-Based 
Computers and an Electronic Whiteboard.  ACM SIGCSE 
Bulletin inroads 33, 3, 169-172.  
[4] Brown, C.W., and Hardisty, E. A. 2007.  RegeXeX: An 
Interactive System Providing Regular Expression 
Exercises.  ACM SIGCSE Bulletin inroads 39, 1, 445-449. 
[5] Cavalcante, R., Finley, T., and Rodger, S. H. 2004.  A 
Visual and Interactive Automata Theory Course with 
JFLAP 4.0. ACM SIGCSE Bulletin inroads 36, 1, 140-
144. 
[6] Chesnevar, C.I., Cobo, M. L., and Yurcik, W.  2003.  
Using Theoretical Computer Simulators for Formal 
Languages and Automata Theory.  ACM SIGCSE Bulletin 
inroads 35, 2, 33-37. 
[7] Chesnevar, C.I., Gonzalez, M. P., and Maguitman, A. G., 
2004.  Didactic Strategies for Promoting Significant 
Learning in Formal Languages and Automata Theory.  
ACM SIGCSE Bulletin inroads 36, 3, 7-11. 
[8] Chesnevar, C. I., Maguitman, A.G., Gonzalez, M. P., and 
Cobo, M. L. 2004.  Teaching Fundamentals of Computing 
Theory: A Constructivist Approach.  Journal of Computer 
Science and Technology 4, 2, 91-97. 
[9] Chuda, D. 2007.  Visualization in Education of Theoretical 
Computer Science.  Proceedings of the 2007 International 
Conference on Computer Systems, 285, 15-1-15-6.  
[10] Coatta, T. 2007.  Things I Learned in School.  ACM 
Queue 5.7 
[11] Cohen, D.I.A. 1997  Introduction to Computer Theory.  
2nd Edition.  John Wiley & Sons, Inc.  
[12] Devedzic, V., Debenham , J., and Popvic D. 2000.  
Teaching Formal Languages by an Intelligent Tutoring 
System.  Educational Technology and Society 3, 2,  ISSN 
1436-4522. 
[13] Esmoris, A., Chesnevar, C. I., and Gonzalez M. P.  2005.  
TAGS: A Software Tool for Simulating Transducer 
Automata.  International Journal of Electrical Engineering 
Education 42, 4, 338-349. 
[14] Gramond, E. and Rodger, S. H. 1999.  Using JFLAP to 
Interact with Theorems in Automata Theory.  ACM 
SIGCSE Bulletin inroads 31, 1, 336-340. 
[15] Grinder, M.T. 2002. Animating Automata: A Cross-
Platform Program for Teaching Finite Automata.   ACM 
SIGCSE Bulletin inroads 34, 1, 63-67.  
[16] Grinder, M.T., Kim, S. B., Lutey, T. L., Ross, R. J., and 
Walsh, K. F. 2002.  Loving to Learn Theory: Active 
Learning Modules for the Theory of Computing.  ACM 
SIGCSE Bulletin inroads 34, 1, 371-375. 
[17] Grinder, M.T. 2003.  A Preliminary Empirical Evaluation 
of the Effectiveness of a Finite State Automaton Animator 
2003.  ACM SIGCSE Bulletin inroads 35, 1, 157-161. 
[18] Hamada, M. and Shiina, K. 2004.  A Classroom 
Experiment for Teaching Automata.  ACM SIGCSE 
inroads 36, 3, 261. 
[19] Hannay, D.G. 2002.  Interactive Tools for Computation 
Theory. ACM SIGCSE Bulletin inroads 34, 4, 68-70. 
[20] Hielscher, M. and Wagenknecht, C. 2006.  AtoCC-
Learning Environment for Teaching Theory of Automata 
and Formal Languages.  ACM SIGCSE Bulletin inroads 
38, 3, 306. 
[21] Hopcroft J.E., Motwani, R. and Ullman, J. D. 2006  
Introduction to Automata, Theory, Languages and 
Computation. 3rd Edition.  Addison-Wesley. 
[22] Joseph, A. and Payne, M. 2003.  Group Dynamics and 
Collaborative Group Performance.  ACM SIGCSE 
Bulletin inroads 35, 1, 368-371. 
[23] Korte, L. and Anderson, S. 2007.  Learning by Game-
Building. ACM SIGCSE Bulletin inroads 39, 3, 53-57. 
[24] Lewis, H. R., and Papadamitriou, H. 1997 Elements of the 
Theory of Computation.  2nd Edition.  Prentice Hall. 
[25] Linz, P. 2006 An Introduction to Formal Languages and 
Automata.  4th Edition.  Jones and Bartlett Publishers, Inc. 
[26] McDonald, J. 2002.  Interactive Pushdown Automata 
Animation. ACM SIGCSE Bulletin inroads 34, 1, 376-
380. 
[27] Moreira, N., and Reis, R. 2005.  Interactive Manipulation 
of Regular Objects with FAdo.  ACM SIGCSE Bulletin 
inroads 38, 3, 335-339. 

94 
 
 
 
 
 
SACJ, No 42., 2008 
 
[28] Olagunju, A.O., and Geiger, K. 2001.  Just Clicking Some 
Theoretical Aspects of Computing.  ACM SIGCSE 
Bulletin inroads 33, 2, 37-42. 
[29] Pillay, N. and Naidoo, A. 2006.  An Investigation into the 
Automatic Generation of Solutions to Problems in an 
Intelligent Tutoring System for Finite Automata.  
Proceedings of the 36th SACLA Conference - 2006, 84-
93. 
[30] Rodger, S.H. 1998.  JFLAP: An Aid to Studying Theorems 
in Automata Theory.  ACM SIGCSE Bulletin inroads 30, 
3, 302. 
[31] Rodger, S.H. 2006.  Learning Automata and Formal 
Languages Interactively with JFLAP.  ACM SIGCSE 
Bulletin inroads 38, 3, 360. 
[32] Rodger, S.H., Bressier, B., Finley, T., and Reading, S. 
2006.  Turning Automata Theory into a Hands-on Course.  
ACM SIGCSE Bulletin inroads 38, 1, 379-383. 
[33] Rodger, S.H., Lim, J., Reading, S. 2007. Increasing 
Interaction and Support in the Formal Languages and 
Automata Theory Course.  ACM SIGCSE Bulletin inroads 
39, 3, 58-62. 
[34] Schreyer, B., and Wawrzynski, W. 2006.  Finite Automata 
Models for CS Problem with Binary Semaphore.  ACM 
SIGCSE Bulletin inroads 38, 3, 330. 
[35] Sipser, M. 2005.  Introduction to the Theory of 
Computation.  2nd Edition.  PWS Publishing Company. 
[36] Stallmann, M., Balik, S., Rodman, R., Bahram, S., Grace, 
M., and High, S. 2007.  ProofChecker: An Accessible 
Environment for Automata Theory Correctness Proofs.  
ACM SIGCSE Bulletin inroads 39, 3, 48-53. 
[37] Taylor, G. 1998  Models of Computation and Formal 
Languages.  Oxford University Press. 
[38] Taylor, R.G. 1998.  Motivating the Church-Turing Thesis 
in the Twenty-First Century.  ACM SIGCSE Bulletin 
inroads 30, 3, 228-231. 
[39] Verma, R.M. 2005.  A Visual and Interactive Automata 
Theory Course Emphasizing the Breadth of Automata.  
ACM SIGCSE Bulletin inroads 37, 3, 325-329 
[40] Vieira, L. F. M., Vieira, M. A. M., and Vieira, N. J. 2004.  
Language Emulator, A Helpful Toolkit in the Learning 
Process of Computer Theory.  ACM SIGCSE Bulletin 
inroads 36, 1, 135-139. 
[41] Wermelinger, M., and Dias, A. M. 2005.  A Prolog Toolkit 
for Formal Languages and Automata.  ACM SIGCSE 
Bulletin inroads 38, 3, 330-334. 
[42] White, T.M., and Way, T. P. 2006.  jFAST: A Java Finite 
Automata Simulator.  ACM SIGCSE Bulletin inroads 38, 
1, 384-388. 
[43] Computing Curricula 2001 Computer Science 2001.  ACM 
Press.  http://www.acm.org/education/curricula-
recommentations. 
 
    

