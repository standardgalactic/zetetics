
This page intentionally left blank

CAMBRIDGE STUDIES IN
ADVANCED MATHEMATICS
EDITORIAL BOARD
B. BOLLOBAS, W. FULTON, A. KATOK, F. KIRWAN,
P. SARNAK
Lectures in Logic and Set Theory Volume 1
This two-volume work bridges the gap between introductory expositions of
logic or set theory on one hand, and the research literature on the other. It can
be used as a text in an advanced undergraduate or beginning graduate course
in mathematics, computer science, or philosophy. The volumes are written in
a user-friendly conversational lecture style that makes them equally effective
for self-study or class use.
Volume 1 includes formal proof techniques, a section on applications of
compactness (including non-standard analysis), a generous dose of computa-
bility and its relation to the incompleteness phenomenon, and the Ô¨Årst presen-
tation of a complete proof of G¬®odel‚Äôs second incompleteness theorem since
Hilbert and Bernay‚Äôs Grundlagen.

Already published
2
K. Petersen Ergodic theory
3
P.T. Johnstone Stone spaces
5
J.-P. Kahane Some random series of functions, 2nd edition
7
J. Lambek & P.J. Scott Introduction to higher-order categorical logic
8
H. Matsumura Commutative ring theory
10
M. Aschbacher Finite group theory, 2nd edition
11
J.L. Alperin Local representation theory
12
P. Koosis The logarithmic integral I
14
S.J. Patterson An introduction to the theory of the Riemann zeta-function
15
H.J. Baues Algebraic homotopy
16
V.S. Varadarajan Introduction to harmonic analysis on semisimple Lie groups
17
W. Dicks & M. Dunwoody Groups acting on graphs
19
R. Fritsch & R. Piccinini Cellular structures in topology
20
H. Klingen Introductory lectures on Siegel modular forms
21
P. Koosis The logarithmic integral II
22
M.J. Collins Representations and characters of Ô¨Ånite groups
24
H. Kunita Stochastic Ô¨Çows and stochastic differential equations
25
P. Wojtaszczyk Banach spaces for analysts
26
J.E. Gilbert & M.A.M. Murray Clifford algebras and Dirac operators in harmonic analysis
27
A. Frohlich & M.J. Taylor Algebraic number theory
28
K. Goebel & W.A. Kirk Topics in metric Ô¨Åxed point theory
29
J.F. Humphreys ReÔ¨Çection groups and Coxeter groups
30
D.J. Benson Representations and cohomology I
31
D.J. Benson Representations and cohomology II
32
C. Allday & V. Puppe Cohomological methods in transformation groups
33
C. Soule et al. Lectures on Arakelov geometry
34
A. Ambrosetti & G. Prodi A primer of nonlinear analysis
35
J. Palis & F. Takens Hyperbolicity, stability and chaos at homoclinic bifurcations
37
Y. Meyer Wavelets and operators 1
38
C. Weibel, An introduction to homological algebra
39
W. Bruns & J. Herzog Cohen-Macaulay rings
40
V. Snaith Explicit Brauer induction
41
G. Laumon Cohomology of Drinfeld modular varieties I
42
E.B. Davies Spectral theory and differential operators
43
J. Diestel, H. Jarchow, & A. Tonge Absolutely summing operators
44
P. Mattila Geometry of sets and measures in Euclidean spaces
45
R. Pinsky Positive harmonic functions and diffusion
46
G. Tenenbaum Introduction to analytic and probabilistic number theory
47
C. Peskine An algebraic introduction to complex projective geometry
48
Y. Meyer & R. Coifman Wavelets
49
R. Stanley Enumerative combinatorics I
50
I. Porteous Clifford algebras and the classical groups
51
M. Audin Spinning tops
52
V. Jurdjevic Geometric control theory
53
H. Volklein Groups as Galois groups
54
J. Le Potier Lectures on vector bundles
55
D. Bump Automorphic forms and representations
56
G. Laumon Cohomology of Drinfeld modular varieties II
57
D.M. Clark & B.A. Davey Natural dualities for the working algebraist
58
J. McCleary A user‚Äôs guide to spectral sequences II
59
P. Taylor Practical foundations of mathematics
60
M.P. Brodmann & R.Y. Sharp Local cohomology
61
J.D. Dixon et al. Analytic pro-P groups
62
R. Stanley Enumerative combinatorics II
63
R.M. Dudley Uniform central limit theorems
64
J. Jost & X. Li-Jost Calculus of variations
65
A.J. Berrick & M.E. Keating An introduction to rings and modules
66
S. Morosawa Holomorphic dynamics
67
A.J. Berrick & M.E. Keating Categories and modules with K-theory in view
68
K. Sato Levy processes and inÔ¨Ånitely divisible distributions
69
H. Hida Modular forms and Galois cohomology
70
R. Iorio & V. Iorio Fourier analysis and partial differential equations
71
R. Blei Analysis in integer and fractional dimensions
72
F. Borceaux & G. Janelidze Galois theories
73
B. Bollobas Random graphs

LECTURES IN LOGIC
AND SET THEORY
Volume 1: Mathematical Logic
GEORGE TOURLAKIS
York University

Ôù£Ôù°Ôù≠Ôù¢Ôù≤Ôù©Ôù§ÔùßÔù• ÔùµÔùÆÔù©Ôù∂Ôù•Ôù≤Ôù≥Ôù©Ôù¥Ôùπ Ôù∞Ôù≤Ôù•Ôù≥Ôù≥
Cambridge, New York, Melbourne, Madrid, Cape Town, Singapore, S√£o Paulo
Cambridge University Press
The Edinburgh Building, Cambridge Ôù£Ôù¢Ôú≤ Ôú≤Ôù≤Ôùµ, United Kingdom
First published in print format 
ISBN-13   978-0-521-75373-9 hardback
ISBN-13   978-0-511-06871-3 eBook (EBL)
¬© George Tourlakis 2003
2003
Information on this title: www.cambridge.org/9780521753739
This book is in copyright. Subject to statutory exception and to the provision of
relevant collective licensing agreements, no reproduction of any part may take place
without the written permission of Cambridge University Press.
ISBN-10   0-511-06871-9 eBook (EBL)
ISBN-10   0-521-75373-2 hardback
Cambridge University Press has no responsibility for the persistence or accuracy of
ÔùµÔù≤Ôù¨s for external or third-party internet websites referred to in this book, and does not
guarantee that any content on such websites is, or will remain, accurate or appropriate.
Published in the United States by Cambridge University Press, New York
www.cambridge.org

Œ≥ŒπŒ± œÑŒ∑ŒΩ Œ¥ŒµœÉœÄoŒπŒΩŒ±, œÑŒ∑ŒΩ ¬µŒ±œÅŒπŒΩŒ± Œ∫Œ±Œπ œÑoŒΩ Œ≥ŒπŒ±ŒΩŒΩŒ∑


Contents
Preface
page ix
I
Basic Logic
1
I.1
First Order Languages
5
I.2
A Digression into the Metatheory:
Informal Induction and Recursion
19
I.3
Axioms and Rules of Inference
28
I.4
Basic Metatheorems
42
I.5
Semantics; Soundness, Completeness, Compactness
52
I.6
Substructures, Diagrams, and Applications
75
I.7
DeÔ¨Åned Symbols
112
I.8
Computability and Uncomputability
123
I.9
Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability,
and Incompletableness
155
I.10
Exercises
191
II
The Second Incompleteness Theorem
205
II.1
Peano Arithmetic
206
II.2
A Formal Œ≤-Function
232
II.3
Formal Primitive Recursion
248
II.4
The Boldface  and 
256
II.5
Arithmetization
265
II.6
Derivability Conditions; Fixed Points
272
II.7
Exercises
316
Bibliography
319
List of Symbols
321
Index
323
vii


Preface
Both volumes in this series are about what mathematicians, especially logicians,
call the ‚Äúfoundations‚Äù (of mathematics) ‚Äì that is, the tools of the axiomatic
method, an assessment of their effectiveness, and two major examples of ap-
plication of these tools, namely, in the development of number theory and set
theory.
There have been, in hindsight, two main reasons for writing this volume.
One was the existence of notes I wrote for my lectures in mathematical logic
and computability that had been accumulating over the span of several years
and badly needed sorting out. The other was the need to write a small section
on logic, ‚ÄúA Bit of Logic‚Äù as I originally called it, that would bootstrap my
volume on set theory‚Ä† on which I had been labouring for a while. Well, one
thing led to another, and a 30 or so page section that I initially wrote for the
latter purpose grew to become a self-standing volume of some 300 pages. You
see, this material on logic is a good story and, as with all good stories, one does
get carried away wanting to tell more.
I decided to include what many people will consider, I should hope, as
being the absolutely essential topics in proof, model, and recursion theory ‚Äì
‚Äúabsolutely essential‚Äù in the context of courses taught near the upper end of
undergraduate, and at the lower end of graduate curricula in mathematics, com-
puter science, or philosophy. But no more.‚Ä° This is the substance of Chapter I;
hence its title ‚ÄúBasic Logic‚Äù.
‚Ä† A chapter by that name now carries out these bootstrapping duties ‚Äì the proverbial ‚ÄúChapter 0‚Äù
(actually Chapter I) of volume 2.
‚Ä° These topics include the foundation and development of non-standard analysis up to the ex-
treme value theorem, elementary equivalence, diagrams, and L¬®owenheim-Skolem theorems, and
G¬®odel‚Äôs Ô¨Årst incompleteness theorem (along with Rosser‚Äôs sharpening).
ix

x
Preface
But then it occurred to me to also say something about one of the most
remarkable theorems of logic ‚Äì arguably the most remarkable ‚Äì about the lim-
itations of formalized theories: G¬®odel‚Äôs second incompleteness theorem. Now,
like most reasonable people, I never doubted that this theorem is true, but, as the
devil is in the details, I decided to learn its proof ‚Äì right from Peano‚Äôs axioms.
What better way to do this than writing down the proof, gory details and all?
This is what Chapter II is about.‚Ä†
As a side effect, the chapter includes many theorems and techniques of one
of the two most important ‚Äì from the point of view of foundations ‚Äì ‚Äúapplied‚Äù
logics (formalized theories), namely, Peano arithmetic (the other one, set theory,
taking all of volume 2).
I have hinted above that this (and the second) volume are aimed at a fairly
advanced reader: The level of exposition is designed to Ô¨Åt a spectrum of math-
ematical sophistication from third year undergraduate to junior graduate level
(each group will Ô¨Ånd here its favourite sections that serve its interests and level
of preparation ‚Äì and should not hesitate to judiciously omit topics).
There are no speciÔ¨Åc prerequisites beyond some immersion in the ‚Äúproof
culture‚Äù, as this is attainable through junior level courses in calculus, linear al-
gebra, or discrete mathematics. However, some familiarity with concepts from
elementary na¬®ƒ±ve set theory such as Ô¨Åniteness, inÔ¨Ånity, countability, and un-
countability will be an asset.‚Ä°
A word on approach. I have tried to make these lectures user-friendly, and thus
accessible to readers who do not have the beneÔ¨Åt of an instructor‚Äôs guidance.
Devices to that end include anticipation of questions, frequent promptings for
the reader to rethink an issue that might be misunderstood if glossed over
(‚ÄúPauses‚Äù), and the marking of important passages, by
, as well as those that
can be skipped at Ô¨Årst reading, by
.
Moreover, I give (mostly) very detailed proofs, as I know from experience
that omitting details normally annoys students.
‚Ä† It is strongly conjectured here that this is the only complete proof in print other than the one
that was given in Hilbert and Bernays (1968). It is fair to clarify that I use the term ‚Äúcomplete
proof‚Äù with a strong assumption in mind: That the axiom system we start with is just Peano
arithmetic. Proofs based on a stronger ‚Äì thus technically more convenient ‚Äì system, namely,
primitive recursive arithmetic, have already appeared in print (Diller (1976), Smory¬¥nski (1985)).
The difÔ¨Åculty with using Peano arithmetic as the starting point is that the only primitive recursive
functions initially available are the successor, identity, plus, and times. An awful amount of work
is needed ‚Äì a preliminary ‚Äúcoding trick‚Äù ‚Äì to prove that all the rest of the primitive recursive
functions ‚Äúexist‚Äù. By then are we already midway in Chapter II, and only then are we ready to
build G¬®odel numbers of terms, formulas, and proofs and to prove the theorem.
‚Ä° I have included a short paragraph nicknamed ‚Äúa crash course on countable sets‚Äù (Section I.5,
p. 62), which certainly helps. But having seen these topics before helps even more.

Preface
xi
The Ô¨Årst chapter has a lot of exercises (the second having proportionally
fewer). Many of these have hints, but none are marked as ‚Äúhard‚Äù vs. ‚Äújust about
right‚Äù, a subjective distinction I prefer to avoid. In this connection here is some
good advice I received when I was a graduate student at the University of
Toronto: ‚ÄúAttempt all the problems. Those you can do, don‚Äôt do. Do the ones
you cannot‚Äù.
What to read. Consistently with the advice above, I suggest that you read this
volume from cover to cover ‚Äì including footnotes! ‚Äì skipping only what you
already know. Now, in a class environment this advice may be impossible to
take, due to scope and time constraints. An undergraduate (one semester) course
in logic at the third year level will probably cover Sections I.1‚ÄìI.5, making light
of Section I.2, and will introduce the student to the elements of computability
along with a hand-waving ‚Äúproof‚Äù of G¬®odel‚Äôs Ô¨Årst incompleteness theorem (the
‚Äúsemantic version‚Äù ought to sufÔ¨Åce). A fourth year class will probably attempt
to cover the entire Chapter I. A Ô¨Årst year graduate class has no more time than
the others at its disposal, but it usually goes much faster, skipping over familiar
ground, thus it will probably additionally cover Peano arithmetic and will get
to see how G¬®odel‚Äôs second theorem follows from L¬®ob‚Äôs derivability conditions.
Acknowledgments. I wish to offer my gratitude to all those who taught me,
a group led by my parents and too large to enumerate. I certainly include my
students here. I also include Raymond Wilder‚Äôs book on the foundations of
mathematics, which introduced me, long long ago, to this very exciting Ô¨Åeld
and whetted my appetite for more (Wilder (1963)).
I should like to thank the staff at Cambridge University Press for their pro-
fessionalism, support, and cooperation, with special appreciation due to Lauren
Cowles and Caitlin Doggart, who made all the steps of this process, from ref-
ereeing to production, totally painless.
This volume is the last installment of a long project that would have not been
successful without the support and warmth of an understanding family (thank
you).
I Ô¨Ånally wish to record my appreciation to Donald Knuth and Leslie Lamport
for the typesetting tools TEX and LATEX that they have made available to the tech-
nical writing community, making the writing of books such as this one almost
easy.
George Tourlakis
Toronto, March 2002


I
Basic Logic
Logic is the science of reasoning. Mathematical logic applies to mathematical
reasoning ‚Äì the art and science of writing down deductions. This volume is
about the form, meaning, use, and limitations of logical deductions, also called
proofs. While the user of mathematical logic will practise the various proof
techniques with a view of applying them in everyday mathematical practice,
the student of the subject will also want to know about the power and limitations
of the deductive apparatus. We will Ô¨Ånd that there are some inherent limitations
in the quest to discover truth by purely formal ‚Äì that is, syntactic ‚Äì techniques.
In the process we will also discover a close afÔ¨Ånity between formal proofs and
computations that persists all the way up to and including issues of limitations:
Not only is there a remarkable similarity between the types of respective limi-
tations (computations vs. uncomputable functions, and proofs vs. unprovable,
but ‚Äútrue‚Äù, sentences), but, in a way, you cannot have one type of limitation
without having the other.
The modern use of the term mathematical logic encompasses (at least) the
areas of proof theory (it studies the structure, properties, and limitations of
proofs), model theory (it studies the interplay between syntax and meaning ‚Äì or
semantics ‚Äì by looking at the algebraic structures where formal languages are
interpreted), recursion theory (or computability, which studies the properties
and limitations of algorithmic processes), and set theory. The fact that the last-
mentioned will totally occupy our attention in volume 2 is reÔ¨Çected in the
prominence of the term in the title of these lectures. It also reÔ¨Çects a tendency,
even today, to think of set theory as a branch in its own right, rather than as an
‚Äúarea‚Äù under a wider umbrella.
1

2
I. Basic Logic
Volume 1 is a brief study of the other three areas of logic‚Ä† mentioned above.
This is the point where an author usually apologizes for what has been omitted,
blaming space or scope (or competence) limitations. Let me start by outlin-
ing what is included: ‚ÄúStandard‚Äù phenomena such as completeness, compact-
ness and its startling application to analysis, incompleteness or unprovabil-
ity (including a complete proof of the second incompleteness theorem), and a
fair amount of recursion theory are thoroughly discussed. Recursion theory,
or computability, is of interest to a wide range of audiences, including stu-
dents with main areas of study such as computer science, philosophy, and, of
course, mathematical logic. It studies among other things the phenomenon of
uncomputability, which is closely related to that of unprovability, as we see in
Section I.9.
Among the topics that I have deliberately left out are certain algebraic tech-
niques in model theory (such as the method of ultrapowers), formal interpre-
tations of one theory into another,‚Ä° the introduction of ‚Äúother‚Äù logics (modal,
higher order, intuitionistic, etc.), and several topics in recursion theory (oracle
computability, Turing reducibility, recursive operators, degrees, Post‚Äôs theorem
in the arithmetic hierarchy, the analytic hierarchy, etc.) ‚Äì but then, the decision
to stop writing within 300 or so pages was Ô¨Årm. On the other hand, the topics
included here form a synergistic whole in that I have (largely) included at every
stage material that is prerequisite to what follows. The absence of a section on
propositional calculus is deliberate, as it does not in my opinion further the
understanding of logic in any substantial way, while it delays one‚Äôs plunging
into what really matters. To compensate, I include all tautologies as ‚Äúproposi-
tional‚Äù (or Boolean) logical axioms and present a mini-course on propositional
calculus in the exercises of this chapter (I.26‚ÄìI.41, pp. 193‚Äì195), including the
completeness and compactness of the calculus.
It is inevitable that the language of sets intrudes in this chapter (as it indeed
does in all mathematics) and, more importantly, some of the results of (informal)
set theory are needed here (especially in our proofs of the completeness and
compactness metatheorems). Conversely, formal set theory of volume 2 needs
some of the results developed here. This ‚Äúchicken or egg‚Äù phenomenon is often
called ‚Äúbootstrapping‚Äù (not to be confused with ‚Äúcircularity‚Äù ‚Äì which it is not¬ß),
the term suggesting one pulling oneself up by one‚Äôs bootstraps.¬∂
‚Ä† I trust that the reader will not object to my dropping the qualiÔ¨Åer ‚Äúmathematical‚Äù from now on.
‚Ä° Although this topic is included in volume 2 (Chapter I), since it is employed in the relative
consistency techniques applied there.
¬ß Only informal, or na¬®ƒ±ve, set theory notation and results are needed in Chapter I at the meta-level,
i.e, outside the formal system that logic is.
¬∂ I am told that Baron M¬®unchhausen was the Ô¨Årst one to apply this technique, with success.

I. Basic Logic
3
This is a good place to outline how our story will unfold: First, our objective is to
formalize the rules of reasoning in general ‚Äì as these apply to all mathematics ‚Äì
and develop their properties. In particular, we will study the interaction between
formalized rules and their ‚Äúintended meaning‚Äù (semantics), as well as the limi-
tations of these formalized rules: That is, how good (= potent) are they for
capturing the informal notions of truth?
Secondly,oncewehaveacquiredthesetoolsofformalizedreasoning,westart
behaving (mostly‚Ä†) as users of formal logic so that we can discover important
theorems of two important mathematical theories: Peano arithmetic (Chapter II)
and set theory (volume 2).
By formalization (of logic) we understand the faithful representation or
simulation of the ‚Äúreasoning processes‚Äù of mathematics in general (pure logic),
or of a particular mathematical theory (applied logic: e.g., Peano arithmetic),
within an activity that ‚Äì in principle ‚Äì is driven exclusively by the form or syntax
of mathematical statements, totally ignoring their meaning.
We build, describe, and study the properties of this artiÔ¨Åcial replica of the
reasoning processes ‚Äì the formal theory ‚Äì within ‚Äúeveryday mathematics‚Äù (also
called ‚Äúinformal‚Äù or ‚Äúreal‚Äù mathematics), using the usual abundance of mathe-
matical symbolism, notions, and techniques available to us, augmented by the
descriptive power of English (or Greek, or French, or German, or Russian,
or . . . , as particular circumstances or geography might dictate). This milieu
within which we build, pursue, and study our theories is often called the meta-
theory, or more generally, metamathematics. The language we speak while at
it, this m¬¥elange of mathematics and ‚Äúnatural language‚Äù, is the metalanguage.
Formalization turns mathematical theories into mathematical objects that
we can study. For example, such study may include interesting questions such
as ‚Äúis the continuum hypothesis provable from the axioms of set theory?‚Äù or
‚Äúcan we prove the consistency of (axiomatic) Peano arithmetic within Peano
arithmetic?‚Äù‚Ä° This is analogous to building a ‚Äúmodel airplane‚Äù, a replica of the
real thing, with a view of studying through the replica the properties, power,
and limitations of the real thing.
But one can also use the formal theory to generate theorems, i.e., discover
‚Äútruths‚Äù in the real domain by simply ‚Äúrunning‚Äù the simulation that this theory-
replica is.¬ß Running the simulation ‚Äúby hand‚Äù (rather than using the program
‚Ä† Some tasks in Chapter II of this volume, and some others in volume 2, will be to treat the ‚Äútheory‚Äù
at hand as an object of study rather than using it, as a machine, to crank out theorems.
‚Ä° By the way, the answer to both these questions is ‚Äúno‚Äù (Cohen (1963) for the Ô¨Årst, G¬®odel (1938)
for the second).
¬ß The analogy implied in the terminology ‚Äúrunning the simulation‚Äù is apt. For formal theories such
as set theory and Peano arithmetic we can build within real mathematics a so-called ‚Äúprovability

4
I. Basic Logic
of the previous footnote) means that you are acting as a ‚Äúuser‚Äù of the formal
system, a formalist, proving theorems through it. It turns out that once you get
the hang of it, it is easier and safer to reason formally than to do so informally.
The latter mode often mixes syntax and semantics (meaning), and there is
always the danger that the ‚Äúuser‚Äù may assign incorrect (i.e., convenient, but not
general ) meanings to the symbols that he‚Ä† manipulates, a phenomenon that has
distressed many a mathematics or computer science instructor.
‚ÄúFormalism for the user‚Äù is hardly a revolutionary slogan. It was advocated
by Hilbert, the founder of formalism, partly as a means of ‚Äì as he believed‚Ä° ‚Äì
formulating mathematical theories in a manner that allows one to check them
(i.e., run ‚Äúdiagnostic tests‚Äù on them) for freedom from contradiction,¬ß but also
as the right way to ‚Äúdo‚Äù mathematics. By this proposal he hoped to salvage
mathematicsitself,which,Hilbertfelt,wasabouttobedestroyedbytheBrouwer
school of intuitionist thought. In a way, his program could bridge the gap
between the classical and the intuitionist camps, and there is some evidence
that Heyting (an inÔ¨Çuential intuitionist and contemporary of Hilbert) thought
that such a rapprochement was possible. After all, since meaning is irrelevant to
a formalist, then all that he is doing (in a proof) is shufÔ¨Çing Ô¨Ånite sequences of
symbols, never having to handle or argue about inÔ¨Ånite objects ‚Äì a good thing,
as far as an intuitionist is concerned.¬∂
predicate‚Äù, that is, a relationP(y, x) which is true of two natural numbers y and x just in case y
codes a proof of the formula coded by x. It turns out that P(y, x) has so simple a structure that it
is programmable, say in the C programming language. But then we can write a program (also in
C) as follows: ‚ÄúSystematically generate all the pairs of numbers (y, x). For each pair generated,
if P(y, x) holds, then print the formula coded by x‚Äù. Letting this process run for ever, we obtain
a listing of all the theorems of Peano arithmetic or set theory! This fact does not induce any
insomnia in mathematicians, since this is an extremely impractical way to obtain theorems. By
the way, we will see in Chapter II that either set theory or Peano arithmetic is sufÔ¨Åciently strong
to formally express a provability predicate, and this leads to the incompletableness phenomenon.
‚Ä† In this volume, the terms ‚Äúhe‚Äù, ‚Äúhis‚Äù, ‚Äúhim‚Äù, and their derivatives are by deÔ¨Ånition gender-neutral.
‚Ä° This belief was unfounded, as G¬®odel‚Äôs incompleteness theorems showed.
¬ß Hilbert‚Äôs metatheory ‚Äì that is, the ‚Äúworld‚Äù or ‚Äúlab‚Äù outside the theory, where the replica is
actually manufactured ‚Äì was Ô¨Ånitary. Thus ‚Äì Hilbert advocated ‚Äì all this theory building and
theory checking ought to be effected by Ô¨Ånitary means. This ingredient of his ‚Äúprogram‚Äù was
consistent with peaceful coexistence with the intuitionists. And, alas, this ingredient was the one
that ‚Äì as some writers put it ‚Äì destroyed Hilbert‚Äôs program to found mathematics on his version
of formalism. G¬®odel‚Äôs incompleteness theorems showed that a Ô¨Ånitary metatheory is not up to
the task.
¬∂ True, a formalist applies classical logic, while an intuitionist applies a different logic where, for
example, double negation is not removable. Yet, unlike a Platonist, a Hilbert-style formalist does
not believe ‚Äì or he does not have to disclose to his intuitionist friends that he might believe ‚Äì that
inÔ¨Ånite sets exist in the metatheory, as his tools are just Ô¨Ånite symbol sequences. To appreciate the
tension here, consider this anecdote: It is said that when Kronecker ‚Äì the father of intuitionism ‚Äì
was informed of Lindemann‚Äôs proof (1882) that œÄ is transcendental, while he granted that this was
an interesting result, he also dismissed it, suggesting that ‚ÄúœÄ‚Äù ‚Äì whose decimal expansion is, of

I.1. First Order Languages
5
In support of the ‚Äúformalism for the user‚Äù position we must deÔ¨Ånitely men-
tion the premier paradigm, Bourbaki‚Äôs monumental work (1966a), which is a
formalization of a huge chunk of mathematics, including set theory, algebra,
topology, and theory of integration. This work is strictly for the user of mathe-
matics, not for the metamathematician who studies formal theories. Yet, it is
fully formalized, true to the spirit of Hilbert, and it comes in a self-contained
package, including a ‚ÄúChapter 0‚Äù on formal logic.
More recently, the proposal to employ formal reasoning as a tool has been
gainingsupportinanumberofcomputerscienceundergraduatecurricula,where
logic and discrete mathematics are taught in a formalized setting, starting with
a rigorous course in the two logical calculi (propositional and predicate), em-
phasizing the point of view of the user of logic (and mathematics) ‚Äì hence with
an attendant emphasis on ‚Äúcalculating‚Äù (i.e., writing and annotating formal)
proofs. Pioneering works in this domain are the undergraduate text (1994) and
the paper (1995) of Gries and Schneider.
I.1. First Order Languages
In the most abstract (therefore simplest) manner of describing it, a formalized
mathematical theory consists of the following sets of things: A set of basic
or primitive symbols, V , used to build symbol sequences (also called strings,
or expressions, or words) ‚Äúover V ‚Äù. A set of strings, Wff, over V , called the
formulas of the theory. Finally, a subset of Wff, called Thm, the set of theorems
of the theory.‚Ä†
Well, this is the extension of a theory, that is, the explicit set of objects in it.
How is a theory ‚Äúgiven‚Äù?
In most cases of interest to the mathematician it is given by V and two
sets of simple rules: formula-building rules and theorem-building rules. Rules
from the Ô¨Årst set allow us to build, or generate, Wff from V . The rules of the
second set generate Thm from Wff. In short (e.g., Bourbaki (1966b)), a theory
consists of an alphabet of primitive symbols, some rules used to generate the
‚Äúlanguage of the theory‚Äù (meaning, essentially, Wff) from these symbols, and
some additional rules used to generate the theorems. We expand on this below:
course, inÔ¨Ånite but not periodic ‚Äì ‚Äúdoes not exist‚Äù (see Wilder (1963, p. 193)). We are not to pro-
pound the tenets of intuitionism here, but it is fair to state that inÔ¨Ånite sets are possible in intuition-
istic mathematics as this has later evolved in the hands of Brouwer and his Amsterdam ‚Äúschool‚Äù.
However, such sets must be (like all sets of intuitionistic mathematics) Ô¨Ånitely generated ‚Äì just
as our formal languages and the set of theorems are (the latter provided our axioms are too) ‚Äì in
a sense that may be familiar to some readers who have had a course in ‚Äúautomata and language
theory‚Äù. See Wilder (1963, p. 234)
‚Ä† For a less abstract, but more detailed view of theories see p. 38.

6
I. Basic Logic
I.1.1 Remark . What is a ‚Äúrule‚Äù? We run the danger of becoming circular or too
pedantic if we overdeÔ¨Åne this notion. Intuitively, the rules we have in mind are
string manipulation rules, that is, ‚Äúblack boxes‚Äù (or functions) that receive string
inputs and respond with string outputs. For example, a well-known theorem-
building rule receives as input a formula and a variable, and returns (essentially)
the string composed of the symbol ‚àÄ, immediately followed by the variable and,
in turn, immediately followed by the formula.‚Ä†
‚ñ°
(1) First off, the ( Ô¨Årst order) formal language, L, where the theory is ‚Äúspoken‚Äù,‚Ä°
is a triple (V , Term, Wff), that is, it has three important components, each
of them a set.
V is the alphabet or vocabulary of the language. It is the collection of the
basic syntactic ‚Äúbricks‚Äù (symbols) that we use to form expressions that
are terms (members of Term) or formulas (members of Wff). We will
ensure that the processes that build terms or formulas, using the basic
building blocks in V , are intuitively algorithmic or ‚Äúmechanical‚Äù.
Terms will formally codify ‚Äúobjects‚Äù, while formulas will formally
codify ‚Äústatements‚Äù about objects.
(2) Reasoning in the theory will be the process of discovering true statements
about objects ‚Äì that is, theorems. This discovery journey begins with certain
formulas which codify statements that we take for granted (i.e., we accept
without ‚Äúproof‚Äù as ‚Äúbasic truths‚Äù). Such formulas are the axioms. There are
two types of axioms:
Special or nonlogical axioms are to describe speciÔ¨Åc aspects of any
speciÔ¨Åc theory that we might be building. For example, ‚Äúx + 1 Ã∏= 0‚Äù
is a special axiom that contributes towards the characterization of
number theory over the natural numbers, N.
The other kind of axiom will be found in all theories. It is the kind that is
‚Äúuniversally valid‚Äù, that is, not theory-speciÔ¨Åc (for example, ‚Äúx = x‚Äù
is such a ‚Äúuniversal truth‚Äù). For that reason this type of axiom will be
called logical.
(3) Finally, we will need rules for reasoning, actually called rules of inference.
These are rules that allow us to deduce, or derive, a true statement from
other statements that we have already established as being true.¬ß These
rules will be chosen to be oblivious to meaning, being only concerned with
‚Ä† This rule is usually called ‚Äúgeneralization‚Äù.
‚Ä° We will soon say what makes a language ‚ÄúÔ¨Årst order‚Äù.
¬ß The generous use of the term ‚Äútrue‚Äù here is only meant for motivation. ‚ÄúProvable‚Äù or ‚Äúdeducible‚Äù
(formula), or ‚Äútheorem‚Äù, will be the technically precise terminology that we will soon deÔ¨Åne to
replace the term ‚Äútrue statement‚Äù.

I.1. First Order Languages
7
form. They will apply to statement ‚ÄúconÔ¨Ågurations‚Äù of certain recognizable
forms and will produce (derive) new statements of some corresponding
recognizable forms (See Remark I.1.1).
I.1.2 Remark. We may think of axioms of either logical or nonlogical type as
special cases of rules, that is, rules that receive no input in order to produce an
output. In this manner item (2) above is subsumed by item (3), and thus we are
faithful to our abstract deÔ¨Ånition of theory where axioms were not mentioned.
An example, outside mathematics, of an inputless rule is the rule invoked
when you type date on your computer keyboard. This rule receives no input,
and outputs on your screen the current date.
‚ñ°
We next look carefully into (Ô¨Årst order) formal languages.
There are two parts in each Ô¨Årst order alphabet. The Ô¨Årst, the collection of
the logical symbols, is common to all Ô¨Årst order languages regardless of which
theory is ‚Äúspoken‚Äù in them. We describe this part immediately below.
Logical Symbols
LS.1. Object or individual variables. An object variable is any one symbol
out of the non-ending sequence v0, v1, v2, . . . . In practice ‚Äì whether
we are using logic as a tool or as an object of study ‚Äì we agree to be
sloppy with notation and use, generically, x, y, z, u, v, w with or without
subscripts or primes as names of object variables.‚Ä† This is just a matter
of notational convenience. We allow ourselves to write, say, z instead of,
say, v1200000000560000009. Object variables (intuitively) ‚Äúvary over‚Äù (i.e.,
are allowed to take values that are) the objects that the theory studies
(numbers, sets, atoms, lines, points, etc., as the case may be).
LS.2. The Boolean or propositional connectives. These are the symbols ‚Äú¬¨‚Äù
and ‚Äú‚à®‚Äù.‚Ä° They are pronounced not and or respectively.
LS.3. The existential quantiÔ¨Åer, that is, the symbol ‚Äú‚àÉ‚Äù, pronounced exists or
for some.
LS.4. Brackets, that is, ‚Äú(‚Äù and ‚Äú)‚Äù.
LS.5. The equality predicate. This is the symbol ‚Äú=‚Äù, which we use to indicate
that objects are ‚Äúequal‚Äù. It is pronounced equals.
‚Ä† Conventions such as this one are essentially agreements ‚Äì effected in the metatheory ‚Äì on how
to be sloppy and get away with it. They are offered in the interest of user-friendliness.
‚Ä° The quotes are not part of the symbol. They serve to indicate clearly here, in particular in the
case of ‚Äú‚à®‚Äù, what is part of the symbol and what is not (the following period).

8
I. Basic Logic
The logical symbols will have a Ô¨Åxed interpretation. In particular, ‚Äú=‚Äù will
always be expected to mean equals.
The theory-speciÔ¨Åc part of the alphabet is not Ô¨Åxed, but varies from theory
to theory. For example, in set theory we just add the nonlogical (or special)
symbols, ‚ààand U. The Ô¨Årst is a special predicate symbol (or just predicate) of
arity 2, the second is a predicate symbol of arity 1.‚Ä†
In number theory we adopt instead the special symbols S (intended meaning:
successor, or ‚Äú + 1‚Äù function), +, √ó, 0, <, and (sometimes) a symbol for the
exponentiation operation (function) ab. The Ô¨Årst three are function symbols of
arities 1, 2, and 2 respectively. 0 is a constant symbol, < a predicate of arity 2,
and whatever symbol we might introduce to denote ab would have arity 2.
The following list gives the general picture.
Nonlogical Symbols
NLS.1. A (possibly empty) set of symbols for constants. We normally use
the metasymbols‚Ä° a, b, c, d, e, with or without subscripts or primes, to
stand for constants unless we have in mind some alternative ‚Äústandard‚Äù
formal notation in speciÔ¨Åc theories (e.g., ‚àÖ, 0, œâ).
NLS.2. A (possibly empty) set of symbols for predicate symbols or relation
symbols for each possible ‚Äúarity‚Äù n > 0. We normally use P, Q, R
generically, with or without primes or subscripts, to stand for predicate
symbols. Note that = is in the logical camp. Also note that theory-
speciÔ¨Åc formal symbols are possible for predicates, e.g., <, ‚àà.
NLS.3. Finally, a (possibly empty) set of symbols for functions for each possi-
ble ‚Äúarity‚Äù n > 0. We normally use f, g, h, generically, with or without
primes or subscripts, to stand for function symbols. Note that theory-
speciÔ¨Åc formal symbols are possible for functions, e.g., +, √ó.
I.1.3 Remark. (1) We have the option of assuming that each of the logical
symbols that we named in LS.1‚ÄìLS.5 have no further ‚Äústructure‚Äù and that the
symbols are, ontologically, identical to their names, that is, they are just these
exact signs drawn on paper (or on any equivalent display medium).
In this case, changing the symbols, say, ¬¨ and ‚àÉto ‚àºand E respectively
results in a ‚Äúdifferent‚Äù logic, but one that is, trivially, ‚Äúisomorphic‚Äù to the one
‚Ä† ‚ÄúArity‚Äù is a term mathematicians have made up. It is derived from ‚Äúary‚Äù of ‚Äúunary‚Äù, ‚Äúbinary‚Äù,
etc. It denotes the number of arguments needed by a symbol according to the dictates of correct
syntax. Function and predicate symbols need arguments.
‚Ä° Metasymbols are informal (i.e., outside the formal language) symbols that we use within
‚Äúeveryday‚Äù or ‚Äúreal‚Äù mathematics ‚Äì the metatheory ‚Äì in order to describe, as we are doing here,
the formal language.

I.1. First Order Languages
9
we are describing: Anything that we may do in, or say about, one logic trivially
translates to an equivalent activity in, or utterance about, the other as long as
we systematically carry out the translations of all occurrences of ¬¨ and ‚àÉto ‚àº
and E respectively (or vice versa).
An alternative point of view is that the symbol names are not the same as
(identical with) the symbols they are naming. Thus, for example, ‚Äú¬¨‚Äù names
the connective we pronounce not, but we do not know (or care) exactly what
the nature of this connective is (we only care about how it behaves). Thus, the
name ‚Äú¬¨‚Äù becomes just a typographical expedient and may be replaced by other
names that name the same object, not.
This point of view gives one Ô¨Çexibility in, for example, deciding how the
variable symbols are ‚Äúimplemented‚Äù. It often is convenient to think that the
entire sequence of variable symbols was built from just two symbols, say, ‚Äúv‚Äù
and ‚Äú|‚Äù.‚Ä† One way to do this is by saying that vi is a name for the symbol
sequence‚Ä°
‚Äúv | . . . |

i|‚Äôs
‚Äù
Or, preferably ‚Äì see (2) below ‚Äì vi might be a name for the symbol sequence
‚Äúv | . . . |

i|‚Äôs
v‚Äù
Regardless of option, vi and vj will name distinct objects if i Ã∏= j.
This is not the case for the metavariables (‚Äúabbreviated informal names‚Äù)
x, y, z, u, v, w. Unless we say so explicitly otherwise, x and y may name the
same formal variable, say, v131.
We will mostly abuse language and deliberately confuse names with the
symbols they name. For example, we will say, e.g., ‚Äúlet v1007 be an object
variable . . . ‚Äù rather than ‚Äúlet v1007 name an object variable . . . ‚Äù, thus appearing
to favour option one.
(2) Any two symbols included in the alphabet are distinct. Moreover, if any of
them are built from simpler ‚Äúsub-symbols‚Äù ‚Äì e.g., v0, v1, v2, . . . might really
name the strings vv, v|v, v||v, . . . ‚Äì then none of them is a substring (or subex-
pression) of any other.¬ß
‚Ä† We intend these two symbols to be identical to their names. No philosophical or other purpose
will be served by allowing ‚Äúmore indirection‚Äù here (such as ‚Äúv names u, which actually names
w, which actually is . . . ‚Äù).
‚Ä° Not including the quotes.
¬ß What we have stated under (2) are requirements, not metatheorems! That is, they are nothing of
the sort that we can prove about our formal language within everyday mathematics.

10
I. Basic Logic
(3) A formal language, just like a ‚Äúnatural‚Äù language (such as English or
Greek), is ‚Äúalive‚Äù and evolving. The particular type of evolution we have in
mind is the one effected by formal deÔ¨Ånitions. Such deÔ¨Ånitions continually add
nonlogical symbols to the language.‚Ä†
Thus, when we say that, e.g., ‚Äú‚ààand U are the only nonlogical symbols of
set theory‚Äù, we are telling a small white lie. More accurately, we ought to have
said that ‚Äú‚ààand U are the only ‚Äòprimitive‚Äô nonlogical symbols of set theory‚Äù,
for we will add loads of other symbols such as ‚à™, œâ, ‚àÖ, ‚äÇ, ‚äÜ.
This evolution affects the (formal) language of any theory, not just set
theory.
‚ñ°
Wait a minute! If formal set theory is ‚Äúthe foundation of all mathematics‚Äù, and
if, ostensibly, this chapter on logic assists us to found set theory itself, then
how come we are employing natural numbers like 1200000000560000009 as
subscripts in the names of object variables? How is it permissible to already talk
about ‚Äúsets of symbols‚Äù when we are about to found a theory of sets formally?
Surely we do not ‚Äúhave‚Äù‚Ä° any of these ‚Äúitems‚Äù yet, do we?
First off, the presence of subscripts such as 1200000000560000009 in
v1200000000560000009
is a non-issue. One way to interpret what has been said in the deÔ¨Ånition is
to view the various vi as abbreviated names of the real thing, the latter being
strings that employ the symbols v and | as in Remark I.1.3. In this connection
saying that vi is ‚Äúimplemented‚Äù as
v | . . . |

i|‚Äôs
v
(1)
especially the use of ‚Äúi‚Äù above, is only illustrative, thus totally superÔ¨Çuous. We
can say instead that strings of type (1) are the variables which we deÔ¨Åne as
follows without the help of the ‚Äúnatural number i‚Äù (this is a variation of how
this is done in Bourbaki (1966b) and Hermes (1973)):
An ‚Äú|-calculation‚Äù forms a string like this: Write a ‚Äú|‚Äù.¬ß This is the ‚Äúcurrent
string‚Äù. Repeat a Ô¨Ånite number of times: Add (i.e., concatenate) one | imme-
diately to the right of the current string. Write this new string (it is now the
current string).
‚Ä† This phenomenon will be studied in some detail in what follows. By the way, any additions are
made to the nonlogical side of the alphabet. All the logical symbols have been given, once and
for all.
‚Ä° ‚ÄúDo not have‚Äù in the sense of having not formally deÔ¨Åned ‚Äì or proved to exist ‚Äì or both.
¬ß Without the quotes. These were placed to exclude the punctuation following.

I.1. First Order Languages
11
Let us call any string that Ô¨Ågures in some |-calculation a ‚Äú|-string‚Äù. A variable
either is the string vv, or is obtained as the concatenation from left to right of
v followed by an |-string, followed by v.
All we now need is the ability to generate as many as necessary distinct
variables (this is the ‚Äúnon-ending sequence‚Äù part of the deÔ¨Ånition, p. 7): For
any two variables we get a new one that is different from either one by forming
the string ‚Äúv, followed by the concatenation of the two |-parts, followed by v‚Äù.
Similarly if we had three, four, . . . variables. By the way, two strings of | are
distinct iff‚Ä† both occur in the same |-calculation, one, but not both, as the last
string.
Another, more direct way to interpret what was said about object variables
on p. 7 is to take the deÔ¨Ånition literally, i.e., to suppose that it speaks about the
ontology of the variables.‚Ä° Namely, the subscript is just a a string of meaningless
symbols taken from the list below:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
Again we can pretend that we know nothing about natural numbers, and when-
ever, e.g., we want a variable other than either of v123 or v321, we may offer
either of v123321 or v321123 as such a new variable.
O.K., so we have not used natural numbers in the deÔ¨Ånition. But we did say
‚Äúsets‚Äù and also ‚Äúnon-ending sequence‚Äù, implying the presence of inÔ¨Ånite sets!
As we have already noted, on one hand we have ‚Äúreal mathematics‚Äù, and on
the other hand we have syntactic replicas of theories ‚Äì the formal theories ‚Äì
that we built within real mathematics. Having built a formal theory, we can then
choose to use it (acting like formalists) to generate theorems, the latter being
codiÔ¨Åed as symbol sequences (formulas). Thus, the assertion ‚Äúaxiomatic set
theory is the foundation of all mathematics‚Äù is just a colloquialism proffered
in the metatheory that means that ‚Äúwithin axiomatic set theory we can construct
the known sets of mathematics, such as the reals R and the complex numbers
C, and moreover we can simulate what we informally do whenever we are
working in real or complex analysis, algebra, topology, theory of measure and
integration, functional analysis, etc., etc.‚Äù
There is no circularity here, but simply an empirical boastful observation in
the metatheory of what our simulator can do. Moreover, our metatheory does
‚Ä† If and only if.
‚Ä° Why not just say exactly what a deÔ¨Ånition is meant to say rather than leave it up to interpretation?
One certainly could, as in Bourbaki (1966b), make the ontology of variables crystal-clear right in
the deÔ¨Ånition. Instead, we have followed the custom of more recent writings and given the deÔ¨Å-
nition in a quasi-sloppy manner that leaves the ontology of variables as a matter for speculation.
This gives one the excuse to write footnotes like this one and remarks like I.1.3.

12
I. Basic Logic
have sets and all sorts of other mathematical objects. In principle we can use any
among those towards building or discussing the simulator, the formal theory.
Thus, the question is not whether we can use sets, or natural numbers, in
our deÔ¨Ånitions, but whether restrictions apply. For example, can we use inÔ¨Ånite
sets?
If we are Platonists, then we have available in the metatheory all sorts of sets,
including inÔ¨Ånite sets, in particular the set of all natural numbers. We can use
any of these items, speak about them, etc., as we please, when we are describing
or building the formal theory within our metatheory.
Now, if we are not Platonists, then our ‚Äúreal‚Äù mathematical world is much
more restricted. In one extreme, we have no inÔ¨Ånite sets.‚Ä†
We can still manage to deÔ¨Åne our formal language! After all, the ‚Äúnon-
ending‚Äù sequence of object variables v0, v1, v2, . . . can be Ô¨Ånitely generated in
at least two different ways, as we have already seen. Thus we can explain (to
a true formalist or Ô¨Ånitist) that ‚Äúnon-ending sequence‚Äù was an unfortunate slip
of the tongue, and that we really meant to give a procedure of how to generate
on demand a new object variable, different from whatever ones we may already
have.
Two parting comments are in order: One, we have been somewhat selective
in the use of the term ‚Äúmetavariable‚Äù. We have called x, x‚Ä≤, y metavariables,
but have implied that the vi are formal variables, even if they are just names
of formal objects such that we do not know or do not care what they look like.
Well, strictly speaking the abbreviations vi are also metavariables, but they are
endowed with a property that the ‚Äúgeneric‚Äù metavariables like x, y, z‚Ä≤ do not
have: Distinct vi names denote distinct object variables (cf. I.1.3).
Two, we should clarify that a formal theory, when used (i.e., the simulator
is being ‚Äúrun‚Äù) is a generator of strings, not a decider or ‚Äúparser‚Äù. Thus, it
can generate any of the following: variables (if these are given by procedures),
formulas and terms (to be deÔ¨Åned), or theorems (to be deÔ¨Åned). Decision issues,
no matter how trivial, the system is not built to handle. These belong to the
metatheory. In particular, the theory does not see whatever numbers or strings
(like 12005) may be hidden in a variable name (such as v12005).
Examples of decision questions: Is this string a term or a formula or a variable
(Ô¨Ånitely generated as above)? All these questions are ‚Äúeasy‚Äù. They are algo-
rithmically decidable in the metatheory. Or, is this formula a theorem? This is
‚Ä† A Ô¨Ånitist ‚Äì and don‚Äôt forget that Hilbert-style metatheory was Ô¨Ånitary, ostensibly for political
reasons ‚Äì will let you have as many integers as you like in one serving, as long as the serving
is Ô¨Ånite. If you ask for more, you can have more, but never the set of all integers or an inÔ¨Ånite
subset thereof.

I.1. First Order Languages
13
algorithmically undecidable in the metatheory if it is a question about Peano
arithmetic or set theory.
I.1.4 DeÔ¨Ånition (Terminology about Strings). A symbol sequence or expres-
sion (or string) that is formed by using symbols exclusively out of a given set‚Ä†
M is called a string over the set, or alphabet, M.
If A and B denote strings (say, over M), then the symbol A ‚àóB, or more
simply AB, denotes the symbol sequence obtained by listing Ô¨Årst the symbols
of A in the given left to right sequence, immediately followed by the symbols of
B in the given left to right sequence. We say that AB is (more properly, denotes
or names) the concatenation of the strings A and B in that order.
We denote the fact that the strings (named) C and D are identical sequences
(but we just say that they are equal) by writing C ‚â°D. The symbol Ã∏‚â°denotes
the negation of the string equality symbol ‚â°. Thus, if # and ? are (we do mean
‚Äúare‚Äù) symbols from an alphabet, then
#?? ‚â°#??
but
#? Ã∏‚â°#??
We can also employ ‚â°in contexts such as ‚Äúlet A ‚â°##?‚Äù, where we give the
name A to the string ##?.‚Ä°
In this book the symbol ‚â°will be exclusively used in the metatheory for equality
of strings over some set M.
The symbol Œª normally denotes the empty string, and we postulate for it the
following behaviour:
A ‚â°AŒª ‚â°ŒªA
for all strings A
We say that A occurs in B, or is a substring of B, iff there are strings C and D
such that B ‚â°CAD.
For example, ‚Äú(‚Äù occurs four times in the (explicit) string ‚Äú¬¨(()‚à®)((‚Äù, at
positions 2, 3, 7, 8. Each time this happens we have an occurrence of ‚Äú(‚Äù in
‚Äú¬¨(()‚à®)((‚Äù.
If C ‚â°Œª, we say that A is a preÔ¨Åx of B. If moreover D Ã∏‚â°Œª, then we say
that A is a proper preÔ¨Åx of B.
‚ñ°
‚Ä† A set that supplies symbols to be used in building strings is not special. It is just a set. However,
it often has a special name: ‚Äúalphabet‚Äù.
‚Ä° Punctuation such as ‚Äú.‚Äù is not part of the string. One often avoids such footnotes by enclosing
strings that are explicitly written as symbol sequences inside quotes. For example, if A stands
for the string #, one writes A ‚â°‚Äú#‚Äù. Note that we must not write ‚ÄúA‚Äù, unless we mean a string
whose only symbol is A.

14
I. Basic Logic
I.1.5 DeÔ¨Ånition (Terms). The set of terms, Term, is the smallest set of strings
over the alphabet V with the following two properties:
(1) All of the items in LS.1 or NLS.1 (x, y, z, a, b, c, etc.) are included.
(2) If f is a function‚Ä† of arity n and t1, t2,. . . , tn are included, then so is the
string ‚Äú f t1t2 . . . tn‚Äù.
The symbols t, s, and u, with or without subscripts or primes, will denote
arbitrary terms. Since we are using them in the metalanguage to ‚Äúvary over‚Äù
terms, we naturally call them metavariables. They also serve ‚Äì as variables ‚Äì
towards the deÔ¨Ånition (this one) of the syntax of terms. For this reason they are
also called syntactic variables.
‚ñ°
I.1.6 Remark. (1) We often abuse notation and write f (t1,. . . , tn) instead of
f t1 . . . tn.
(2) DeÔ¨Ånition I.1.5 is an inductive deÔ¨Ånition.‚Ä° It deÔ¨Ånes a more or less
‚Äúcomplicated‚Äù term by assuming that we already know what ‚Äúsimpler‚Äù terms
look like. This is a standard technique employed in real mathematics. We will
have the opportunity to say more about such inductive deÔ¨Ånitions ‚Äì and their
appropriateness ‚Äì in a
-comment later on.
(3) We relate this particular manner of deÔ¨Åning terms to our working def-
inition of a theory (given on p. 6 immediately before Remark I.1.1 in terms
of ‚Äúrules‚Äù of formation). Item (2) in I.1.5 essentially says that we build new
terms (from old ones) by applying the following general rule: Pick an arbitrary
function symbol, say f . This has a speciÔ¨Åc formation rule associated with it
that, for the appropriate number, n, of an already existing ordered list of terms,
t1,. . . , tn, will build the new term consisting of f , immediately followed by
the ordered list of the given terms.
To be speciÔ¨Åc, suppose we are working in the language of number theory.
There is a function symbol + available there. The rule associated with + builds
the new term +ts for any prior obtained terms t and s. For example, +v1v13
and +v121 + v1v13 are well-formed terms. We normally write terms of number
theory in ‚ÄúinÔ¨Åx‚Äù notation,¬ß i.e., t + s, v1 + v13 and v121 + (v1 + v13) (note the
intrusion of brackets, to indicate sequencing in the application of +).
‚Ä† We will omit from now on the qualiÔ¨Åcation ‚Äúsymbol‚Äù from terminology such as ‚Äúfunction sym-
bol‚Äù, ‚Äúconstant symbol‚Äù, ‚Äúpredicate symbol‚Äù.
‚Ä° Some mathematicians will absolutely insist that we call this a recursive deÔ¨Ånition and reserve
the term ‚Äúinduction‚Äù for ‚Äúinduction proofs‚Äù. This is seen to be unwarranted hair splitting if we
consider that Bourbaki (1966b) calls induction proofs ‚Äúd¬¥emonstrations par r¬¥ecurrence‚Äù. We will
be less dogmatic: Either name is all right.
¬ß Function symbol placed between the arguments.

I.1. First Order Languages
15
A by-product of what we have just described is that the arity of a function
symbol f is whatever number of terms the associated rule will require as input.
(4) A crucial word used in I.1.5 (which recurs in all inductive deÔ¨Ånitions) is
‚Äúsmallest‚Äù. It means ‚Äúleast inclusive‚Äù (set). For example, we may easily think of
a set of strings that satisÔ¨Åes both conditions of the above deÔ¨Ånition, but which is
not ‚Äúsmallest‚Äù by virtue of having additional elements, such as the string ‚Äú¬¨¬¨(‚Äù.
Pause. Why is ‚Äú¬¨¬¨(‚Äù not in the smallest set as deÔ¨Åned above, and therefore
not a term?
The reader may wish to ponder further on the import of the qualiÔ¨Åcation
‚Äúsmallest‚Äù by considering the familiar (similar) example of N, the set of natural
numbers. The principle of induction in N ensures that this set is the smallest
with the properties:
(i) 0 is included, and
(ii) if n is included, then so is n + 1.
Bycontrast,allofZ(setofintegers),Q(setofrationalnumbers),R(setofreal
numbers) satisfy (i) and (ii), but they are clearly not the ‚Äúsmallest‚Äù such.
‚ñ°
I.1.7 DeÔ¨Ånition (Atomic Formulas). The set of atomic formulas, Af, contains
precisely:
(1) The strings t = s for every possible choice of terms t, s.
(2) The strings Pt1t2 . . . tn for every possible choice of n-ary predicates P (for
all choices of n > 0) and all possible choices of terms t1, t2,. . . , tn.
‚ñ°
We often abuse notation and write P(t1,. . . , tn) instead of Pt1 . . . tn.
I.1.8 DeÔ¨Ånition (Well-Formed Formulas). The set of well-formed formulas,
Wff, is the smallest set of strings or expressions over the alphabet V with the
following properties:
(a) All the members of Af are included.
(b) If A and B denote strings (over V ) that are included, then (A ‚à®B ) and
(¬¨A) are also included.
(c) If A is‚Ä† a string that is included and x is any object variable (which may or
may not occur (as a substring) in the string A), then the string ((‚àÉx)A) is
also included. We say that A is the scope of (‚àÉx).
‚ñ°
‚Ä† Denotes!

16
I. Basic Logic
I.1.9 Remark.
(1) The above is yet another inductive deÔ¨Ånition. Its statement (in the metalan-
guage) is facilitated by the use of so-called syntactic, or meta, variables ‚Äì
A and B ‚Äì used as names for arbitrary (indeterminate) formulas. In gen-
eral, we will let calligraphic capital letters A, B , C , D , E , F , G (with or
without primes or subscripts) be names for well-formed formulas, or just
formulas, as we often say. The deÔ¨Ånition of Wff given above is standard.
In particular, it permits well-formed formulas such as ((‚àÉx)((‚àÉx)x = 0)) in
the interest of making the formation rules ‚Äúcontext-free‚Äù.‚Ä†
(2) The rules of syntax just given do not allow us to write things such as ‚àÉf or
‚àÉP where f and P are function and predicate symbols respectively. That
quantiÔ¨Åcation is deliberately restricted to act solely on object variables
makes the language Ô¨Årst order.
(3) We have already indicated in Remark I.1.6 where the arities (of function and
predicate symbols) come from (DeÔ¨Ånitions I.1.5 and I.1.7 referred to them).
These are numbers that are implicit (‚Äúhardwired‚Äù) with the formation rules
for terms and atomic formulas. Each function and each predicate symbol
(e.g., +, √ó, ‚àà, <) has its own unique formation rule. This rule ‚Äúknows‚Äù how
many terms are needed (on the input side) in order to form a term or atomic
formula. Therefore, since the theory, in use, applies rather than studies its
formation rules, it is, in particular, ignorant of arities of symbols.
Now that this jurisdictional point has been made (cf. the concluding
remarks about decision questions, on p. 12), we can consider an alternative
way of making arities of symbols known (in the metatheory): Rather than
embedding arities in the formation rules, we can hide them in the ontology
of the symbols, not making them explicit in the name.
For example, a new symbol, say ‚àó, can be used to record arity. That
is, we can think of a predicate (or function) symbol as consisting of two
parts: an arity part and an ‚Äúall the rest‚Äù part, the latter needed to render the
symbol unique.‚Ä° For example, ‚ààmay be actually the name for the symbol
‚Äú‚àà‚àó‚àó‚Äù, where this latter name is identical to the symbol it denotes, or ‚Äúwhat
you see is what you get‚Äù ‚Äì see Remark I.1.3(1) and (2), p. 8. The presence
of the two asterisks declares the arity. Some people say this differently:
They make available to the metatheory a ‚Äúfunction‚Äù, ar, from ‚Äúthe set of
‚Ä† In some presentations, the formation rule in I.1.8(c) is ‚Äúcontext-sensitive‚Äù: It requires that x be
not already quantiÔ¨Åed in A.
‚Ä° The reader may want to glimpse ahead, on p. 166, to see a possible implementation in the case
of number theory.

I.1. First Order Languages
17
all predicate symbols and functions‚Äù (of a given language) to the natural
numbers, so that for any function symbol f or predicate symbol P, ar( f )
and ar(P) yield the arities of f and P respectively.‚Ä†
(4) Abbreviations
Abr1. The string ((‚àÄx)A) abbreviates the string ‚Äú(¬¨((‚àÉx)(¬¨A)))‚Äù. Thus,
for any explicitly written formula A, the former notation is infor-
mal(metamathematical),whilethelatterisformal(withintheformal
language).Inparticular,‚àÄisametalinguisticsymbol.‚Äú‚àÄx‚Äùistheuni-
versal quantiÔ¨Åer. A is its scope. The symbol ‚àÄis pronounced for all.
We also introduce ‚Äì in the metalanguage ‚Äì a number of additional Boolean
connectives in order to abbreviate certain strings:
Abr2. (Conjunction, ‚àß) (A ‚àßB ) stands for (¬¨((¬¨A) ‚à®(¬¨B ))). The
symbol ‚àßis pronounced and.
Abr3. (Classical or material implication, ‚Üí) (A ‚ÜíB ) stands for
((¬¨A) ‚à®B ). (A ‚ÜíB ) is pronounced if A, then B .
Abr4. (Equivalence, ‚Üî) (A ‚ÜîB ) stands for ((A ‚ÜíB ) ‚àß(B ‚ÜíA)).
Abr5. To minimize the use of brackets in the metanotation we adopt stan-
dard priorities of connectives: ‚àÄ, ‚àÉ, and ¬¨ have the highest, and then
we have (in decreasing order of priority) ‚àß, ‚à®, ‚Üí, ‚Üî, and we agree
not to use outermost brackets. All associativities are right ‚Äì that is,
if we write A ‚ÜíB ‚ÜíC , then this is a (sloppy) counterpart for
(A ‚Üí(B ‚ÜíC )).
(5) The language just deÔ¨Åned, L, is one-sorted, that is, it has a single sort or
type of object variable. Is this not inconvenient? After all, our set theory
(volume 2 of these lectures) will have both atoms and sets. In other theories,
e.g., geometry, one has points, lines, and planes. One would have hoped to
have different ‚Äútypes‚Äù of variables, one for each.
Actually, to do this would amount to a totally unnecessary complication
of syntax. We can (and will) get away with just one sort of object variable.
For example, in set theory we will also introduce a 1-ary‚Ä° predicate, U,
whose job is to ‚Äútest‚Äù an object for ‚Äúsethood‚Äù.¬ß Similar remedies are avail-
able to other theories. For example, geometry will manage with one sort of
variable and unary predicates ‚ÄúPoint‚Äù, ‚ÄúLine‚Äù, and ‚ÄúPlane‚Äù.
‚Ä† In mathematics we understand a function as a set of input‚Äìoutput pairs. One can ‚Äúglue‚Äù the two
parts of such pairs together, as in ‚Äú‚àà‚àó‚àó‚Äù ‚Äì where ‚Äú‚àà‚Äù is the input part and ‚Äú‚àó‚àó‚Äù is the output part,
the latter denoting ‚Äú2‚Äù ‚Äì etc. Thus, the two approaches are equivalent.
‚Ä° More commonly called unary.
¬ß People writing about, or teaching, set theory have made this word up. Of course, one means by
it the property of being a set.

18
I. Basic Logic
Apropos language, some authors emphasize the importance of the
nonlogical symbols, taking at the same time the formation rules for
granted; thus they say that we have a language, say, ‚ÄúL = {‚àà, U}‚Äù rather
than ‚ÄúL = (V , Term, Wff) where V
has ‚ààand U as its only nonlogi-
cal symbols‚Äù. That is, they use ‚Äúlanguage‚Äù for the nonlogical part of the
alphabet.
‚ñ°
A variable that is quantiÔ¨Åed is bound in the scope of the quantiÔ¨Åer. Non-
quantiÔ¨Åed variables are free. We also give below, by induction on formulas,
precise (metamathematical) deÔ¨Ånitions of ‚Äúfree‚Äù and ‚Äúbound‚Äù.
I.1.10 DeÔ¨Ånition (Free and Bound Variables). An object variable x occurs
free in a term t or atomic formula A iff it occurs in t or A as a substring
(see I.1.4).
x occurs free in (¬¨A) iff it occurs free in A.
x occurs free in (A ‚à®B ) iff it occurs free in at least one of A or B .
x occurs free in ((‚àÉy)A) iff x occurs free in A, and y is not the same
variable as x.‚Ä†
The y in ((‚àÉy)A) is, of course, not free ‚Äì even if it might be so in A ‚Äì as
we have just concluded in this inductive deÔ¨Ånition. We say that it is bound in
((‚àÉy)A). Trivially, terms and atomic formulas have no bound variables.
‚ñ°
I.1.11 Remark. (1) Of course, DeÔ¨Ånition I.1.10 takes care of the deÔ¨Åned con-
nectives as well, via the obvious translation procedure.
(2) Notation. If A is a formula, then we often write A[y1,. . . , yk] to indicate
our interest in the variables y1,. . . , yk, which may or may not be free in A.
Indeed, there may be other free variables in A that we may have chosen not to
include in the list.
On the other hand, if we use round brackets, as in A(y1,. . . , yk), then we
are implicitly asserting that y1,. . . , yk is the complete list of free variables that
occur in A.
‚ñ°
I.1.12 DeÔ¨Ånition. A term or formula is closed iff no free variables occur in it.
A closed formula is called a sentence.
A formula is open iff it contains no quantiÔ¨Åers (thus, an open formula may
also be closed).
‚ñ°
‚Ä† Recall that x and y are abbreviations of names such as v1200098 and v11009 (which name distinct
variables). However, it could be that both x and y name v101. Therefore it is not redundant to say
‚Äúand y is not the same variable as x‚Äù. By the way, x Ã∏‚â°y says the same thing, by I.1.4.

I.2. A Digression into the Metatheory
19
I.2. A Digression into the Metatheory:
Informal Induction and Recursion
We have already seen a number of inductive or recursive deÔ¨Ånitions in Sec-
tion I.1. The reader, most probably, has already seen or used such deÔ¨Ånitions
elsewhere.
We will organize the common important features of inductive deÔ¨Ånitions
in this section, for easy reference. We just want to ensure that our grasp of
these notions and techniques, at the metamathematical level, is sufÔ¨Åcient for
the needs of this volume.
One builds a set S by recursion, or inductively (or by induction), out of two
ingredients: a set of initial objects, I , and a set of rules or operations, R. A
member of R ‚Äì a rule ‚Äì is a (possibly inÔ¨Ånite) table, or relation, like
y1
. . .
yn
z
a1
. . .
an
an+1
b1
. . .
bn
bn+1
...
...
...
If the above rule (table) is called Q, then we use the notations‚Ä†
Q(a1,. . . , an, an+1)
and
‚ü®a1,. . . , an, an+1‚ü©‚ààQ
interchangeably to indicate that the ordered sequence or ‚Äúrow‚Äù a1,. . . , an, an+1
is present in the table.
We say that ‚ÄúQ(a1,. . . , an, an+1) holds‚Äù or ‚ÄúQ(a1,. . . , an, an+1) is true‚Äù,
but we often also say that ‚ÄúQ applied to a1,. . . , an yields an+1‚Äù, or that ‚Äúan+1
is a result or output of Q, when the latter receives input a1,. . . , an‚Äù. We often
abbreviate such inputs using vector notation, namely, ‚Éóan (or just ‚Éóa, if n is
understood). Thus, we may write Q(‚Éóan+1) for Q(a1,. . . , an, an+1).
A rule Q that has n + 1 columns is called (n + 1)-ary.
I.2.1 DeÔ¨Ånition. We say ‚Äúa set T is closed under an (n + 1)-ary rule Q‚Äù to
mean that whenever c1,. . . , cn are all in T , then d ‚ààT for all d satisfying
Q(c1,. . . , cn, d).
‚ñ°
With these preliminary understandings out of the way, we now state
‚Ä† ‚Äúx ‚ààA‚Äù means that ‚Äúx is a member of ‚Äì or is in ‚Äì A‚Äù in the informal set-theoretic sense.

20
I. Basic Logic
I.2.2 DeÔ¨Ånition. S is deÔ¨Åned by recursion, or by induction, from initial objects
I and set of rules R, provided it is the smallest (least inclusive) set with the
properties
(1) I ‚äÜS,‚Ä†
(2) S is closed under every Q in R. In this case we say that S is R-closed.
We write S = Cl(I , R), and say that ‚ÄúS is the closure of I under R ‚Äù. ‚ñ°
We have at once:
I.2.3 Metatheorem (Induction on S). If S = Cl(I , R) and if some set T
satisÔ¨Åes
(1) I ‚äÜT , and
(2) T is closed under every Q in R,
then S ‚äÜT .
Pause. Why is the above a metatheorem?
The above principle of induction on S is often rephrased as follows: To prove
that a property P(x) holds for all members of Cl(I , R), just prove that
(a) every member of I has the property, and
(b) the property propagates with every rule in R, i.e., if P(ci) holds (is true)
for i = 1,. . . , n, and if Q(c1,. . . , cn, d) holds, then d too has the property
P(x) ‚Äì that is, P(d) holds.
Of course, this rephrased principle is valid, for if we let T be the set of all
objects that have property P(x) ‚Äì for which set one employs the well-established
symbol {x : P(x)} ‚Äì then this T satisÔ¨Åes (1) and (2) of the metatheorem.‚Ä°
I.2.4 DeÔ¨Ånition (Derivationsand Parses). A(I , R)-derivation, or simply de-
rivation ‚Äì if I and R are understood ‚Äì is a Ô¨Ånite sequence of objects d1,. . . , dn
‚Ä† From our knowledge of elementary informal set theory, we recall that A ‚äÜB means that every
member of A is also a member of B.
‚Ä° We are sailing too close to the wind here! It turns out that not all properties P(x) lead to sets
{x : P(x)}. Our explanation was na¬®ƒ±ve. However, formal set theory, which is meant to save us from
our na¬®ƒ±vet¬¥e, upholds the ‚Äúprinciple‚Äù (a)‚Äì(b) using just a slightly more complicated explanation.
The reader can see this explanation in our volume 2 in the chapter on cardinality.

I.2. A Digression into the Metatheory
21
(n ‚â•1) such that each di is
(1) a member of I , or‚Ä†
(2) for some (r + 1)-ary Q ‚ààR, Q(d j1,. . . , d jr , di) holds, and jl < i for
l = 1,. . . ,r.
We say that di is derivable within i steps.
A derivation of an object A is also called a parse of a.
‚ñ°
Trivially, if d1,. . . , dn is a derivation, then so is d1,. . . , dm for any 1 ‚â§m < n.
If d is derivable within n steps, it is also derivable in k steps or less, for all
k > n, since we can lengthen a derivation arbitrarily by adding I -elements
to it.
I.2.5 Remark. The following metatheorem shows that there is a way to ‚Äúcon-
struct‚Äù Cl(I , R) iteratively, i.e., one element at a time by repeated application
of the rules.
This result shows deÔ¨Ånitively that our inductive deÔ¨Ånitions of terms (I.1.5)
and well-formed formulas (I.1.8) fully conform with our working deÔ¨Ånition of
theory, as an alphabet and a set of rules that are used to build formulas and
theorems (p. 5).
‚ñ°
I.2.6 Metatheorem.
Cl(I , R) = {x : x is (I , R)-derivable within some number of steps, n}
Proof. For notational convenience let us write
T = {x : x is (I , R)-derivable within some number of steps, n}.
As we know from elementary na¬®ƒ±ve set theory, we need to show here both
Cl(I , R) ‚äÜT and Cl(I , R) ‚äáT to settle the claim.
(‚äÜ) We do induction on Cl(I , R) (using I.2.3). Now I ‚äÜT , since every
member of I is derivable in n = 1 step. (Why?)
Also, T is closed under every Q in R. Indeed, let such an (r + 1)-ary Q be
chosen, and assume
Q(a1,. . . , ar, b)
(i)
‚Ä† This ‚Äúor‚Äù is inclusive: (1), or (2), or both.

22
I. Basic Logic
and {a1,. . . , ar} ‚äÜT . Thus, each ai has a (I , R)-derivation. Concatenate all
these derivations:
. . . , a1,. . . , a2,. . . , . . . , ar
The above is a derivation (why?). But then, so is
. . . , a1,. . . , a2,. . . , . . . , ar, b
by (i). Thus, b ‚ààT .
(‚äá) We argue this ‚Äì that is, ‚Äúif d ‚ààT , then d ‚ààCl(I , R)‚Äù ‚Äì by induction
on the number of steps, n, in which d is derivable.
For n = 1 we have d ‚ààI and we are done, since I ‚äÜCl(I , R).
Let us make the induction hypothesis (I.H.) that for derivations of ‚â§n steps
the claim is true. Let then d be derivable within n + 1 steps. Thus, there is a
derivation a1,. . . , an, d.
Now, if d ‚ààI , we are done as above (is this a ‚Äúreal case‚Äù?) If on the other
hand Q(a j1,. . . , a jr, d), then for i = 1,. . . ,r we have a ji ‚ààCl(I , R) by the
I.H.; hence d ‚ààCl(I , R), since the closure is closed under all Q ‚ààR.
‚ñ°
I.2.7 Example. One can see now that N = Cl(I , R), where I = {0} and R
contains just the relation y = x + 1 (input x, output y). Similarly, Z, the set
of all integers, is Cl(I , R), where I = {0} and R contains just the relations
y = x + 1 and y = x ‚àí1 (input x, output y).
For the latter, the inclusion Cl(I , R) ‚äÜZ is trivial (by I.2.3). For ‚äáwe
easily see that any n ‚ààZ has a (I , R)-derivation (and then we are done by I.2.6).
For example, if n > 0, then 0, 1, 2,. . . , n is a derivation, while if n < 0, then
0, ‚àí1, ‚àí2,. . . , n is one. If n = 0, then the one-term sequence 0 is a derivation.
Another interesting closure is obtained by I = {3} and the two relations
z = x + y and z = x ‚àíy. This is the set {3k : k ‚ààZ} (see Exercise I.1).
‚ñ°
Pause. So, taking the Ô¨Årst sentence of I.2.7 one step further, we note that we
have just proved the induction principle for N, for that is exactly what the
‚Äúequation‚Äù N = Cl(I , R) says (by I.2.3). Do you agree?
There is another way to view the iterative construction of Cl(I , R): The
set is constructed in stages. Below we are using some more notation borrowed
from informal set theory. For any sets A and B we write A ‚à™B to indicate the
set union, which consists of all the members found in A or B or in both. More
generally, if we have a lot of sets, X0, X1, X2,. . . , that is, one Xi for every
integer i ‚â•0 ‚Äì which we denote by the compact notation (Xi)i ‚â•0 ‚Äì then we
may wish to form a set that includes all the objects found as members all over
the Xi, that is (using inclusive, or logical, ‚Äúor‚Äùs below), form
{x : x ‚ààX0 or x ‚ààX1 or . . . }

I.2. A Digression into the Metatheory
23
or, more elegantly and precisely,
{x : for some i ‚â•0, x ‚ààXi}
The latter is called the union of the sequence (Xi)i‚â•0 and is often denoted by

i‚â•0 Xi
or

i‚â•0
Xi
Correspondingly, we write

i‚â§n Xi
or

i‚â§n
Xi
if we only want to take a Ô¨Ånite union, also indicated clumsily as X0 ‚à™. . . ‚à™Xn.
I.2.8 DeÔ¨Ånition (Stages). In connection with Cl(I , R) we deÔ¨Åne the sequence
of sets (Xi)i ‚â•0 by induction on n, as follows:
X0 = I
Xn+1 =

i‚â§n
Xi

‚à™

b : for some Q ‚ààR and some ‚Éóan in

i ‚â§n
Xi, Q(‚Éóan, b)
	
That is, to form Xn+1 we append to 
i ‚â§n Xi all the outputs of all the relations
in R acting on all possible inputs, the latter taken from 
i‚â§n Xi.
We say that Xi is built at stage i, from initial objects I and rule-set R.
‚ñ°
In words, at stage 0 we are given the initial objects (X0 = I ). At stage 1 we
apply all possible relations to all possible objects that we have so far ‚Äì they
form the set X0 ‚Äì and build the 1st stage set, X1, by appending the outputs to
what we have so far. At stage 2 we apply all possible relations to all possible
objects that we have so far ‚Äì they form the set X0 ‚à™X1 ‚Äì and build the 2nd
stage set, X2, by appending the outputs to what we have so far. And so on.
When we work in the metatheory, we take for granted that we can have
simple inductive deÔ¨Ånitions on the natural numbers. The reader is familiar with
several such deÔ¨Ånitions, e.g.,
a0 = 1
(for a Ã∏= 0 throughout)
an+1 = a ¬∑ an

24
I. Basic Logic
We will (meta)prove a general theorem on the feasibility of recursive deÔ¨Ånitions
later on (I.2.13).
The following theorem connects stages and closures.
I.2.9 Metatheorem. With the Xi as in I.2.8,
Cl(I , R) =

i‚â•0
Xi
Proof. (‚äÜ) We do induction on Cl(I , R). For the basis, I = X0 ‚äÜ
i‚â•0 Xi.
We show that 
i‚â•0 Xi is R-closed. Let Q ‚ààR and Q(‚Éóan, b) hold, for some
‚Éóan in 
i‚â•0 Xi. Thus, by deÔ¨Ånition of union, there are integers j1, j2,. . . , jn
such that ai ‚ààX ji, i = 1,. . . , n. If k = max{ j1,. . . , jn}, then ‚Éóan is in 
i‚â§k Xi;
hence b ‚ààXk + 1 ‚äÜ
i‚â•0 Xi.
(‚äá) It sufÔ¨Åces to prove that Xn ‚äÜCl(I , R), a fact we can prove by induction
on n. For n = 0 it holds by I.2.2. As an I.H. we assume the claim for all n ‚â§k.
The case for k + 1: Xk + 1 is the union of two sets. One is 
i‚â§k Xi. This is a
subset of Cl(I , R) by the I.H. The other is

b : for some Q ‚ààR and some ‚Éóa in 
i‚â§k
Xi, Q(‚Éóa, b)

This too is a subset of Cl(I , R), by the preceding observation and the fact that
Cl(I , R) is R-closed.
‚ñ°
Worth Saying. An inductively deÔ¨Åned set can be built by stages.
I.2.10 DeÔ¨Ånition (Immediate Predecessors, Ambiguity). If d ‚ààCl(I , R)
and for some Q and a1,. . . , ar it is the case that Q(a1,. . . , ar, d), then the
a1,. . . , ar are immediate Q-predecessors of d, or just immediate predecessors
if Q is understood; for short, i.p.
A pair (I , R) is called ambiguous if some d ‚ààCl(I , R) satisÔ¨Åes any (or
all) of the following conditions:
(i) It has two (or more) distinct sets of immediate P-predecessors for some
rule P.
(ii) It has both immediate P-predecessors and immediate Q-predecessors, for
P Ã∏= Q.
(iii) It is a member of I , yet it has immediate predecessors.
If (I , R) is not ambiguous, then it is unambiguous.
‚ñ°

I.2. A Digression into the Metatheory
25
I.2.11 Example. The pair ({00,0}, {Q}), where Q(x, y, z) holds iff z = xy
(where ‚Äúxy‚Äù denotes the concatenation of the strings x and y, in that order), is
ambiguous. For example, 0000 has the two immediate predecessor sets {00,00}
and {0,000}. Moreover, while 00 is an initial object, it does have immedi-
ate predecessors, namely, the set {0,0} (or, what amounts to the same thing,
{0}).
‚ñ°
I.2.12 Example. The pair (I , R), where I = {3} and R consists of z = x + y
and z = x ‚àíy, is ambiguous. Even 3 has (inÔ¨Ånitely many) distinct sets of i.p.
(e.g., any {a, b} such that a + b = 3, or a ‚àíb = 3).
The pairs that effect the deÔ¨Ånition of Term (I.1.5) and Wff (I.1.8) are un-
ambiguous (see Exercises I.2 and I.3).
‚ñ°
I.2.13 Metatheorem (DeÔ¨Ånition by Recursion). Let (I , R) be unambiguous
and Cl(I , R) ‚äÜA, where A is some set. Let also Y be a set, and‚Ä† h : I ‚ÜíY
and gQ, for each Q ‚ààR, be given functions. For any (r +1)-ary Q, an input for
the function gQ is a sequence ‚ü®a, b1,. . . , br‚ü©where a is in A and the b1,. . . , br
are all in Y. All the gQ yield outputs in Y.
Under these assumptions, there is a unique function f : Cl(I , R) ‚ÜíY
such that
y = f (x) iff
Ô£±
Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£≥
y = h(x) and x ‚ààI
or, for some Q ‚ààR,
y = gQ(x, o1,. . . , or) and Q(a1,. . . , ar, x) holds,
where oi = f (ai), for i = 1,. . . ,r
(1)
The reader may wish to skip the proof on Ô¨Årst reading.
Proof. Existence part. For each (r + 1)-ary Q ‚ààR, deÔ¨Åne 
Q by‚Ä°

Q(‚ü®a1, o1‚ü©,. . . , ‚ü®ar, or‚ü©, ‚ü®b, gQ(b, o1,. . . , or)‚ü©)
iff
Q(a1,. . . , ar, b)
(2)
For any a1,. . . , ar, b, the above deÔ¨Ånition of 
Q is effected for all possible
choices of o1,. . . , or such that gQ(b, o1,. . . , or) is deÔ¨Åned.
Collect now all the 
Q to form a set of rules 
R.
Let also 
I = {‚ü®x, h(x)‚ü©: x ‚ààI }.
‚Ä† The notation f : A ‚ÜíB is common in informal (and formal) mathematics. It denotes a function
f that receives ‚Äúinputs‚Äù from the set A and yields ‚Äúoutputs‚Äù in the set B.
‚Ä° Forarelation Q,writingjust‚ÄúQ(a1,. . . , ar, b)‚Äùisequivalenttowriting‚ÄúQ(a1,. . . , ar, b)holds‚Äù.

26
I. Basic Logic
We will verify that the set F = Cl( 
I , 
R ) is a 2-ary relation that for every
input yields at most one output, and therefore is a function. For such a relation
it is customary to write, letting the context fend off the obvious ambiguity in
the use of the letter F,
y = F(x)
iff
F(x, y)
(‚àó)
We will further verify that replacing f in (1) above by F results in a valid
equivalence (the ‚Äúiff‚Äù holds). That is, F satisÔ¨Åes (1).
(a) We establish that F is a relation composed of pairs ‚ü®x, y‚ü©(x is input, y is
output), where x ‚ààCl(I , R) and y ‚ààY. This follows easily by induction
on F (I.2.3), since 
I ‚äÜF, and the property (of ‚Äúcontaining such pairs‚Äù)
propagates with each 
Q (recall that the gQ yield outputs in Y).
(b) We next show that ‚Äúif ‚ü®x, y‚ü©‚ààF and ‚ü®x, z‚ü©‚ààF, then y = z‚Äù, that is, F is
‚Äúsingle-valued‚Äù or ‚Äúwell-deÔ¨Åned‚Äù, in short, it is a function.
We again employ induction on F, thinking of the quoted statement as a
‚Äúproperty‚Äù of the pair ‚ü®x, y‚ü©:
Suppose that ‚ü®x, y‚ü©‚àà
I , and let also ‚ü®x, z‚ü©‚ààF.
By
I.2.6,
‚ü®x, z‚ü©‚àà
I ,
or

Q(‚ü®a1, o1‚ü©,. . . , ‚ü®ar, or‚ü©, ‚ü®x, z‚ü©),
where
Q(a1,. . . , ar, x) and z = gQ(x, o1,. . . , or), for some (r + 1)-ary 
Q and
‚ü®a1, o1‚ü©,. . . , ‚ü®ar, or‚ü©in F.
The right hand side of the italicized ‚Äúor‚Äù cannot hold for an unambiguous
(I , R), since x cannot have i.p. Thus ‚ü®x, z‚ü©‚àà
I ; hence y = h(x) = z.
To prove that the property propagates with each 
Q, let

Q(‚ü®a1, o1‚ü©,. . . , ‚ü®ar, or‚ü©, ‚ü®x, y‚ü©)
but also
P

b1, o‚Ä≤
1

,. . . ,

bl, o‚Ä≤
l

,

x, z

where Q(a1,. . . , ar, x), P(b1,. . . , bl, x), and
y = gQ(x, o1,. . . , or)
and
z = gP

x, o‚Ä≤
1,. . . , o‚Ä≤
l

(3)
Since (I , R) is unambiguous, we have Q = P (hence also 
Q = P), r = l,
and ai = bi for i = 1,. . . ,r.
By I.H., oi = o‚Ä≤
i for i = 1,. . . ,r; hence y = z by (3).
(c) Finally, we show that F satisÔ¨Åes (1). We do induction on Cl( 
I , 
R) to prove:
(‚Üê)
If x ‚ààI and y = h(x), then F(x, y) (i.e., y = F(x) in the
alternative notation (‚àó)), since 
I ‚äÜF. Let next y = gQ(x, o1,. . . , or)
and Q(a1,. . . , ar, x), where also F(ai, oi), for i = 1,. . . ,r. By (2),

Q(‚ü®a1, o1‚ü©,. . . , ‚ü®ar, or‚ü©, ‚ü®x, gQ(x, o1,. . . , or)‚ü©); thus ‚Äì F being closed

I.2. A Digression into the Metatheory
27
under all the rules in 
R ‚Äì F(x, gQ(b, o1,. . . , or)) holds; in short, F(x, y)
or y = F(x).
(‚Üí)
Now we assume that F(x, y) holds and we want to infer the right
hand side (of iff ) in (1). We employ Metatheorem I.2.6.
Case 1. Let ‚ü®x, y‚ü©be F-derivable‚Ä† in n = 1 step. Then ‚ü®x, y‚ü©‚àà
I . Thus
y = h(x).
Case 2. Suppose next that ‚ü®x, y‚ü©is F-derivable within n + 1 steps,
namely, we have a derivation
‚ü®x1, y1‚ü©, ‚ü®x2, y2‚ü©, . . . , ‚ü®xn, yn‚ü©, ‚ü®x, y‚ü©
(4)
where 
Q(‚ü®a1, o1‚ü©,. . . , ‚ü®ar, or‚ü©, ‚ü®x, y‚ü©) and Q(a1,. . . , ar, x) (see (2)),
and each of ‚ü®a1, o1‚ü©,. . . , ‚ü®ar, or‚ü©appears in the above derivation, to
the left of ‚ü®x, y‚ü©. This entails (by (2)) that y = gQ(x, o1,. . . , or). Since
the ‚ü®ai, oi‚ü©appear in (4), F(ai, oi) holds, for i = 1,. . . ,r. Thus, ‚ü®x, y‚ü©
satisÔ¨Åes the right hand side of iff in (1), once more.
Uniqueness part. Let the function K also satisfy (1). We show, by induction
on Cl(I , R), that
For all x ‚ààCl(I , R) and all y ‚ààY,
y = F(x) iff y = K(x)
(5)
(‚Üí)
Let x ‚ààI , and y = F(x). By lack of ambiguity, the case conditions
of(1)aremutuallyexclusive.Thus,itmustbethat y = h(x).Butthen, y = K(x)
as well, since K satisÔ¨Åes (1) too.
Let now Q(a1,. . . , ar, x) and y = F(x). By (1), there are (unique, as we now
know) o1,. . . , or such that oi = F(ai) for i = 1,. . . ,r, and y = gQ(x, o1,. . . ,
or). By the I.H., oi = K(ai). But then (1) yields y = K(x) as well (since K
satisÔ¨Åes (1)).
(‚Üê)
Just interchange the letters F and K in the above argument.
‚ñ°
The above clearly is valid for functions h and gQ that may fail to be deÔ¨Åned
everywhere in their ‚Äúnatural‚Äù input sets. To be able to have this degree of
generality without having to state additional deÔ¨Ånitions (such as left Ô¨Åelds,
right Ô¨Åelds, partial functions, total functions, nontotal functions, Kleene ‚Äúweak
equality‚Äù), we have stated the recurrence (1) the way we did (to keep an eye on
both the input and output side of things) rather than the ‚Äúusual‚Äù
f (x) =
h(x)
if x ‚ààI
gQ(x, f (a1),. . . , f (ar))
if Q(a1,. . . , ar, x) holds
‚Ä† Cl(
I , 
R )-derivable.

28
I. Basic Logic
Of course, if all the gQ and h are deÔ¨Åned everywhere on their input sets (i.e.,
they are ‚Äútotal‚Äù), then f is deÔ¨Åned everywhere on Cl(I , R) (see Exercise I.4).
I.3. Axioms and Rules of Inference
Now that we have our language, L, we will embark on using it to formally
effect deductions. These deductions start at the axioms. Deductions employ
‚Äúacceptable‚Äù purely syntactic ‚Äì i.e., based on form, not on meaning ‚Äì rules that
allow us to write a formula down (to deduce it) solely because certain other
formulas that are syntactically related to it were already deduced (i.e., already
written down). These string-manipulation rules are called rules of inference.
We describe in this section the axioms and the rules of inference that we will
accept into our logical calculus and that are common to all theories.
We start with a precise deÔ¨Ånition of tautologies in our Ô¨Årst order language L.
I.3.1 DeÔ¨Ånition (Prime Formulas in Wff. Propositional Variables). A for-
mula A ‚ààWff is a prime formula or a propositional variable iff it is either of
Pri1. atomic,
Pri2. a formula of the form ((‚àÉx)A).
We use the lowercase letters p, q,r (with or without subscripts or primes) to
denote arbitrary prime formulas (propositional variables) of our language.
‚ñ°
That is, a prime formula has either no propositional connectives, or if it does,
it hides them inside the scope of (‚àÉx).
We may think of a propositional variable as a ‚Äúblob‚Äù that a myopic being
makes out of a formula described in I.3.1. The same being will see an arbitrary
well-formed formula as a bunch of blobs, brackets, and Boolean connectives
(¬¨, ‚à®), ‚Äúcorrectly connected‚Äù as stipulated below.‚Ä†
I.3.2 DeÔ¨Ånition (Propositional Formulas). The set of propositional formulas
over V , denoted here by Prop, is the smallest set such that:
(1) Every propositional variable (over V ) is in Prop.
(2) If A and B are in Prop, then so are (¬¨A) and (A ‚à®B ).
We use the lowercase letters p, q,r (with or without subscripts or primes) to
denote arbitrary prime formulas (propositional variables) of our language.
‚ñ°
‚Ä† Interestingly, our myope can see the brackets and the Boolean connectives.

I.3. Axioms and Rules of Inference
29
I.3.3 Metatheorem. Prop = Wff.
Proof. (‚äÜ) We do induction on Prop. Every item in I.3.2(1) is in Wff. Wff
satisÔ¨Åes I.3.2(2) (see I.1.8(b)). Done.
(‚äá) We do induction on Wff. Every item in I.1.8(a) is a propositional variable
(over V ), and hence is in Prop.
Prop trivially satisÔ¨Åes I.1.8(b). It also satisÔ¨Åes I.1.8(c), for if A is in Prop,
then it is in Wff by the ‚äÜ-direction, above. Then, by I.3.1, ((‚àÉx)A) is a propo-
sitional variable and hence in Prop. We are done once more.
‚ñ°
I.3.4 DeÔ¨Ånition (Propositional Valuations). We can arbitrarily assign a value
of 0 or 1 to every A in Wff (or Prop) as follows:
(1) We Ô¨Åx an assignment of 0 or 1 to every prime formula. We can think of this
as an arbitrary but Ô¨Åxed function v : {all prime formulas over L} ‚Üí{0, 1}
in the metatheory.
(2) We deÔ¨Åne by recursion an extension of v, denoted by ¬Øv:
¬Øv((¬¨A)) = 1 ‚àí¬Øv(A)
¬Øv((A ‚à®B )) = ¬Øv(A) ¬∑ ¬Øv(B )
where ‚Äú¬∑‚Äù above denotes number multiplication.
We call, traditionally, the values 0 and 1 by the names ‚Äútrue‚Äù and ‚Äúfalse‚Äù
respectively, and write t and f respectively.
We also call a valuation v a truth (value) assignment.
Weusethejargon‚ÄúAtakesthetruthvaluet(respectively,f)underavaluation
v‚Äù to mean ‚Äú¬Øv(A) = 0 (respectively, ¬Øv(A) = 1)‚Äù.
‚ñ°
The above inductive deÔ¨Ånition of ¬Øv relies on the fact that DeÔ¨Ånition I.3.2 of
Prop is unambiguous (I.2.10, p. 24), or that a propositional formula is uniquely
readable (or parsable) (see Exercises I.6 and I.7). It employs the metatheorem
on recursive deÔ¨Ånitions (I.2.13).
The reader may think that all this about unique readability is just an annoying
quibble. Actually it can be a matter of life and death. The ancient Oracle of
Delphi had the nasty habit of issuing ambiguous ‚Äì not uniquely readable, that
is ‚Äì pronouncements. One famous such pronouncement, rendered in English,
went like this: ‚ÄúYou will go you will return not dying in the war‚Äù.‚Ä† Given that
ancientGreeksdidnotusepunctuation,theabovehastwodiametricallyopposite
meanings depending on whether you put a comma before or after ‚Äúnot‚Äù.
‚Ä† The original was ‚ÄúIŒæŒµŒπœÇ Œ±œïŒπŒæŒµŒπœÇ oœÖ Œ∏ŒΩŒ∑ŒæŒµŒπœÇ ŒµŒΩ œÄoŒªŒµ¬µ œâ
Œπ ‚Äù.

30
I. Basic Logic
The situation with formulas in Prop would have been as disastrous in the
absence of brackets ‚Äì which serve as punctuation ‚Äì because unique readability
would not be guaranteed: For example, for three distinct prime formulas p, q,r
we could Ô¨Ånd a v such that ¬Øv(p ‚Üíq ‚Üír) is different depending on whether
we meant to insert brackets around ‚Äúp ‚Üíq‚Äù or around ‚Äúq ‚Üír‚Äù (can you Ô¨Ånd
such a v?).
I.3.5 Remark (Truth Tables). DeÔ¨Ånition I.3.4 is often given in terms of truth-
functions. For example, we could have deÔ¨Åned (in the metatheory, of course)
the function F¬¨ : {t, f} ‚Üí{t, f} by
F¬¨(x) =
t
if x = f
f
if x = t
We could then say that ¬Øv((¬¨A)) = F¬¨(¬Øv(A)). One can similarly take care of
all the connectives (‚à®and all the abbreviations) with the help of truth functions
F‚à®, F‚àß, F‚Üí, F‚Üî. These functions are conveniently given via so-called truth-
tables as indicated below:
x
y
F¬¨(x)
F‚à®(x, y)
F‚àß(x, y)
F‚Üí(x, y)
F‚Üî(x, y)
f
f
t
f
f
t
t
f
t
t
t
f
t
f
t
f
f
t
f
f
f
t
t
f
t
t
t
t
‚ñ°
I.3.6 DeÔ¨Ånition (Tautologies, SatisÔ¨Åable Formulas, UnsatisÔ¨Åable Formulas
in Wff). A formula A ‚ààWff (equivalently, in Prop) is a tautology iff for all
valuations v one has ¬Øv(A) = t.
We call the set of all tautologies, as deÔ¨Åned here, Taut. The symbol |=Taut A
says ‚ÄúA is in Taut‚Äù.
A formula A ‚ààWff (equivalently, in Prop) is satisÔ¨Åable iff for some valu-
ation v one has ¬Øv(A) = t. We say that v satisÔ¨Åes A.
A set of formulas  is satisÔ¨Åable iff for some valuation v, one has ¬Øv(A) = t
for every A in . We say that v satisÔ¨Åes .
A formula A ‚ààWff (equivalently, in Prop) is unsatisÔ¨Åable iff for all val-
uations v one has ¬Øv(A) = f. A set of formulas  is unsatisÔ¨Åable iff for all
valuations v one has ¬Øv(A) = f for some A in .
‚ñ°

I.3. Axioms and Rules of Inference
31
I.3.7 DeÔ¨Ånition (Tautologically Implies, for Formulas in Wff). Let A and
 be respectively any formula and any set of formulas (over L).
The symbol |=Taut A, pronounced ‚Äú tautologically implies A‚Äù, means
that every truth assignment v that satisÔ¨Åes  also satisÔ¨Åes A.
‚ñ°
‚ÄúSatisÔ¨Åable‚Äù and ‚ÄúunsatisÔ¨Åable‚Äù are terms introduced here in the propositional
or Boolean sense. These terms have a more complicated meaning when we
decide to ‚Äúsee‚Äù the object variables and quantiÔ¨Åers that occur in formulas.
We have at once
I.3.8 Lemma.‚Ä† |=Taut A iff ‚à™{¬¨A} is unsatisÔ¨Åable (in the propositional
sense).
If = ‚àÖthen |=Taut A says just |=Taut A, since the hypothesis ‚Äúevery truth
assignment v that satisÔ¨Åes ‚Äù, in the deÔ¨Ånition above, is vacuously satisÔ¨Åed.
For that reason we almost never write ‚àÖ|=Taut A and write instead |=Taut A.
I.3.9 Exercise. For any formula A and any two valuations v and v‚Ä≤, ¬Øv(A) =
¬Øv‚Ä≤(A) if v and v‚Ä≤ agree on all the propositional variables that occur in A.
In the same manner, |=Taut A is oblivious to v-variations that do not affect
the variables that occur in  and A (see Exercise I.8).
‚ñ°
Before presenting the axioms, we need to introduce the concept of substitu-
tion.
I.3.10 Tentative DeÔ¨Ånition (Substitutions of Terms). Let A be a formula, x
an (object) variable, and t a term. A[x ‚Üêt] denotes the result of ‚Äúreplacing‚Äù
all free occurrences of x in A by the term t, provided no variable of t was
‚Äúcaptured‚Äù (by a quantiÔ¨Åer) during substitution.
‚Ä† The word ‚Äúlemma‚Äù has Greek origin, ‚ÄúŒª¬¥Œ∑¬µ¬µŒ±‚Äù, plural ‚Äúlemmata‚Äù (some people say ‚Äúlemmas‚Äù)
from ‚ÄúŒª¬¥Œ∑¬µ¬µŒ±œÑŒ±‚Äù. It derives from the verb ‚ÄúŒªŒ±¬µŒ≤ ¬¥Œ±ŒΩœâ‚Äù (to take) and thus means ‚Äútaken thing‚Äù.
In mathematical reasoning a lemma is a provable auxiliary statement that is taken and used as
a stepping stone in lengthy mathematical arguments ‚Äì invoked therein by name, as in ‚Äú . . . by
Lemma such and such . . . ‚Äù ‚Äì much as ‚Äúsubroutines‚Äù (or ‚Äúprocedures‚Äù) are taken and used as
auxiliary stepping stones to elucidate lengthy computer programs. Thus our purpose in having
lemmata is to shorten proofs by breaking them up into modules.

32
I. Basic Logic
If the proviso is valid, then we say that ‚Äút is substitutable for x (in A)‚Äù, or
that ‚Äút is free for x (in A)‚Äù. If the proviso is not valid, then the substitution is
undeÔ¨Åned.
‚ñ°
I.3.11 Remark. There are a number of issues about DeÔ¨Ånition I.3.10 that need
discussion or clariÔ¨Åcation.
Reasonable people will be satisÔ¨Åed with the above deÔ¨Ånition ‚Äúas is‚Äù. How-
ever, there are some obscure points (enclosd in quotation marks above).
(1) What is this about ‚Äúcapture‚Äù? Well, suppose that A ‚â°(‚àÉx)¬¨x = y. Let
t ‚â°x.‚Ä† Then A[y ‚Üêt] ‚â°(‚àÉx)¬¨x = x, which says something altogether
different than the original. Intuitively, this is unexpected (and undesirable):
A codes a statement about the free variable y, i.e., a statement about all
objects which could be ‚Äúvalues‚Äù (or meanings) of y. One would have ex-
pected that, in particular, A[y ‚Üêx] ‚Äì if the substitution were allowed ‚Äì
would make this very same statement about the values of x. It does not.‚Ä°
What happened is that x was captured by the quantiÔ¨Åer upon substitution,
thus distorting A‚Äôs original meaning.
(2) Are we sure that the term ‚Äúreplace‚Äù is mathematically precise?
(3) Is A[x ‚Üêt] always a formula, if A is?
A re-visitation of I.3.10 via an inductive deÔ¨Ånition (by induction on terms
and formulas) settles (1)‚Äì(3) at once (in particular, the informal terms ‚Äúreplace‚Äù
and ‚Äúcapture‚Äù do not appear in the inductive deÔ¨Ånition). We deÔ¨Åne (again) the
symbol A[x ‚Üêt], for any formula A, variable x, and term t, this time by
induction on terms and formulas:
First off, let us deÔ¨Åne s[x ‚Üêt], where s is also a term, by cases:
s[x ‚Üêt] ‚â°
Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
t
if s ‚â°x
a
if s ‚â°a, a constant
(symbol)
y
if s ‚â°y, a variable Ã∏‚â°x
f r1[x ‚Üêt]r2[x ‚Üêt] . . .rn[x ‚Üêt]
if s ‚â°f r1 . . .rn
Pause. Is s[x ‚Üêt] always a term? That this is so follows directly by induction
on terms, using the deÔ¨Ånition by cases above and the I.H. that each of ri[x ‚Üêt],
i = 1, . . . , n, is a term.
‚Ä† Recall that in I.1.4 (p. 13) we deÔ¨Åned the symbol ‚Äú‚â°‚Äù to be equality on strings.
‚Ä° The original says that for any object y there is an object that is different from it; A[y ‚Üêx] says
that there is an object that is different from itself.

I.3. Axioms and Rules of Inference
33
We turn now to formulas. The symbols P,r, s (with or without subscripts)
below denote a predicate of arity n, a term, and a term (respectively):
A[x ‚Üêt] ‚â°
Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
s[x ‚Üêt] = r[x ‚Üêt]
if A ‚â°s = r
Pr1[x ‚Üêt]r2[x ‚Üêt] . . .
if A ‚â°Pr1 . . .rn
rn[x ‚Üêt]
(B [x ‚Üêt] ‚à®C [x ‚Üêt])
if A ‚â°(B ‚à®C )
(¬¨(B [x ‚Üêt]))
if A ‚â°(¬¨B )
A
if A ‚â°((‚àÉy)B ) and y ‚â°x
((‚àÉy)(B [x ‚Üêt]))
if A ‚â°((‚àÉy)B ) and y Ã∏‚â°x
and y does not occur in t
In all cases above, the left hand side is deÔ¨Åned iff the right hand side is.
Pause. We have eliminated ‚Äúreplaces‚Äù and ‚Äúcaptured‚Äù. But is A[x‚Üêt] a for-
mula (whenever it is deÔ¨Åned)? (See Exercise I.9)
‚ñ°
I.3.12 DeÔ¨Ånition (Simultaneous Substitution). The symbol
A[y1,. . . , yr ‚Üêt1,. . . , tr]
or, equivalently, A[‚Éóyr ‚Üê‚Éótr] ‚Äì where ‚Éóyr is an abbreviation of y1,. . . , yr ‚Äì
denotes simultaneous substitution of the terms t1,. . . , tr into the variables
y1,. . . , yr in the following sense: Let ‚Éózr be variables that do not occur at all
(either as free or bound) in any of A, ‚Éótr. Then A[‚Éóyr ‚Üê‚Éótr] is short for
A[y1 ‚Üêz1] . . . [yr ‚Üêzr][z1 ‚Üêt1] . . . [zr ‚Üêtr]
(1)
‚ñ°
Exercise I.10 shows that we obtain the same string in (1) above, regardless of
our choice of new variables ‚Éózr.
More Conventions. The symbol [x ‚Üêt] lies in the metalanguage. This
metasymbol has the highest priority, so that, e.g., A ‚à®B [x ‚Üêt] means
A ‚à®(B [x ‚Üêt]), (‚àÉx)B [x ‚Üêt] means (‚àÉx)(B [x ‚Üêt]), etc.
The reader is reminded about the conventions regarding the metanotations
A[‚Éóxr] and A(‚Éóxr) (see I.1.11). In the context of those notations, if t1,. . . , tr are
terms, the symbol A[t1,. . . , tr] abbreviates A[‚Éóyr ‚Üê‚Éótr].
We are ready to introduce the (logical) axioms and rules of inference.

34
I. Basic Logic
Schemata.‚Ä† Some of the axioms below will actually be schemata. A formula
schema, or formula form, is a string G of the metalanguage that contains syn-
tactic variables, such as A, P, f, a, t, x.
Whenever we replace all these syntactic variables that occur in G by speciÔ¨Åc
formulas, predicates, functions, constants, terms, or variables respectively, we
obtain a speciÔ¨Åc well-formed formula, a so-called instance of the schema. For
example, an instance of (‚àÉx)x = a is (‚àÉv12)v12 = 0 (in the language of Peano
arithmetic). An instance of A ‚ÜíA is v101 = v114 ‚Üív101 = v114.
I.3.13 DeÔ¨Ånition (Axioms and Axiom Schemata). The logical axioms are all
the formulas in the group Ax1 and all the possible instances of the schemata in
the remaining groups:
Ax1. All formulas in Taut.
Ax2. (Schema)
A[x ‚Üêt] ‚Üí(‚àÉx)A
for any term t
By I.3.10‚ÄìI.3.11, the notation already imposes a condition on t, that it is
substitutable for x.
N.B. We often see the above written as
A[t] ‚Üí(‚àÉx)A[x]
or even
A[t] ‚Üí(‚àÉx)A
Ax3. (Schema) For each object variable x, the formula x = x.
Ax4. (Leibniz‚Äôs characterization of equality ‚Äì Ô¨Årst order version. Schema) For
any formula A, object variable x, and terms t and s, the formula
t = s ‚Üí(A[x ‚Üêt] ‚ÜîA[x ‚Üês])
N.B. The above is written usually as
t = s ‚Üí(A[t] ‚ÜîA[s])
We must remember that the notation already requires that t and s be free
for x.
We will denote the above set of logical axioms by .
‚ñ°
‚Ä† Plural of schema. This is of Greek origin, œÉœá ¬¥Œ∑¬µŒ±, meaning ‚Äì e.g., in geometry ‚Äì Ô¨Ågure or
conÔ¨Åguration or even formation.

I.3. Axioms and Rules of Inference
35
The logical axioms for equality are not the strongest possible, but they are
adequate for the job. What Leibniz really proposed was the schema t = s ‚Üî
(‚àÄP)(P[t] ‚ÜîP[s]), which says, intuitively, that ‚Äútwo objects t and s are equal
iff, for every ‚Äòproperty P‚Äô, both have P or neither has P‚Äù.
Unfortunately, our system of notation (Ô¨Årst-order language) does not allow
quantiÔ¨Åcation over predicate symbols (which can have as ‚Äúvalues‚Äù arbitrary
‚Äúproperties‚Äù). But is not Ax4 read ‚Äúfor all formulas A‚Äù anyway? Yes, but with
one qualiÔ¨Åcation: ‚ÄúFor all formulas A that we can write down in our system of
notation‚Äù, and, alas, we cannot write all possible formulas of real mathematics
down, because they are too many.‚Ä†
While the symbol ‚Äú=‚Äù is suggestive of equality, it is not its shape that
qualiÔ¨Åes it as equality. It is the two axioms, Ax3 and Ax4, that make the symbol
behave as we expect equality to behave, and any other symbol of any other
shape (e.g., Enderton (1972) uses ‚Äú‚âà‚Äù) satisfying these two axioms qualiÔ¨Åes as
formal equality that is intended to codify the metamathematical standard ‚Äú=‚Äù.
I.3.14 Remark. In Ax2 and Ax4 we imposed the condition that t (and s) must
be substitutable in x. Here is why:
Take A to stand for (‚àÄy)x = y and B to stand for (‚àÉy)¬¨x = y. Then, tem-
porarily suspending the restriction on substitutability, A[x ‚Üêy] ‚Üí(‚àÉx)A is
(‚àÄy)y = y ‚Üí(‚àÉx)(‚àÄy)x = y
and x = y ‚Üí(B ‚ÜîB [x ‚Üêy]) is
x = y ‚Üí((‚àÉy)¬¨x = y ‚Üî(‚àÉy)¬¨y = y)
neither of which, obviously, is ‚Äúvalid‚Äù.‚Ä°
There is a remedy in the metamathematics: Move the quantiÔ¨Åed variable(s)
out of harm‚Äôs way, by renaming them so that no quantiÔ¨Åed variable in A has
the same name as any (free, of course) variable in t (or s).
This renaming is formally correct (i.e., it does not change the meaning of
the formula), as we will see in the variant (meta)theorem (I.4.13). Of course,
‚Ä† ‚ÄúUncountably many‚Äù, in a precise technical sense developed in the chapter on cardinality in
volume 2 (see p. 62, of this volume for a brief informal ‚Äúcourse‚Äù in cardinality). This is due to
Cantor‚Äôs theorem, which implies that there are uncountably many subsets of N. Each such subset
A gives rise to the formula x ‚ààA in the metalanguage.
On the other hand, set theory‚Äôs formal system of notation, using just ‚ààand U as start-up
(nonlogical) symbols, is only rich enough to write down a countably inÔ¨Ånite set of formulas
(cf. p. 62). Thus, our notation will fail to denote uncountably many ‚Äúreal formulas‚Äù x ‚ààA.
‚Ä° Speaking intuitively is enough for now. Validity will be deÔ¨Åned carefully pretty soon.

36
I. Basic Logic
it is always possible to effect this renaming, since we have countably many
variables, and only Ô¨Ånitely many appear free in t (and s) and A. This trivial
remedy allows us to render the conditions in Ax2 and Ax4 harmless. Essentially,
a t (or s) is always substitutable after renaming.
‚ñ°
It is customary to assume a Platonist metatheory, and we do so. We can then
say ‚Äúcountably many‚Äù variables without raising any eyebrows. Alternatively,
we know how to get a new variable that is different from all those in a given
Ô¨Ånite set of variables without invoking an inÔ¨Ånite supply.
I.3.15 DeÔ¨Ånition (Rules of Inference). The following are the two rules of
inference. These rules are relations in the sense of Section I.2, with inputs from
the set Wff and outputs also in Wff. They are written traditionally as ‚Äúfractions‚Äù.
We call the ‚Äúnumerator‚Äù the premise(s) and the ‚Äúdenominator‚Äù the conclusion.
We say that a rule of inference is applied to the formula(s) in the numerator,
and that it yields (or results in) the formula in the denominator.
Inf1. Modus ponens, or MP. For any formulas A and B ,
A, A ‚ÜíB
B
Inf2. ‚àÉ-introduction ‚Äì pronounced E-introduction. For any formulas A and B
such that x is not free in B ,
A ‚ÜíB
(‚àÉx)A ‚ÜíB
N.B. Recall the conventions on eliminating brackets!
‚ñ°
It is immediately clear that the deÔ¨Ånition above meets our requirement that the
rules of inference be ‚Äúalgorithmic‚Äù, in the sense that whether they are applicable
or how they are applicable can be decided and carried out in a Ô¨Ånite number
of steps by just looking at the form of (potential input) formulas (not at the
‚Äúmeaning‚Äù of such formulas).
We next deÔ¨Åne -theorems, that is, formulas we can prove from the set of
formulas  (this  may be empty).
I.3.16 DeÔ¨Ånition (-Theorems). The set of -theorems, Thm, is the least
inclusive subset of Wff that satisÔ¨Åes:
Th1.  ‚äÜThm (cf. I.3.13).
Th2.  ‚äÜThm. We call every member of  a nonlogical axiom.
Th3. Thm is closed under each rule Inf1‚ÄìInf2.

I.3. Axioms and Rules of Inference
37
The metalinguistic statement A ‚ààThm is traditionally written as  ‚ä¢A,
and we say that A is proved from  or that it is a -theorem.
We also say that A is deduced by , or that  deduces A.
If  = ‚àÖ, then rather than ‚àÖ‚ä¢A we write ‚ä¢A. We often say in this case
that A is absolutely provable (or provable with no nonlogical axioms).
We often write A, B , . . . , D ‚ä¢E for {A, B , . . . , D } ‚ä¢E .
‚ñ°
I.3.17 DeÔ¨Ånition (-Proofs). We just saw that Thm is Cl(I , R), where I is
the set of all logical and nonlogical axioms, and R contains just the two rules
of inference. An (I , R)-derivation is also called a -proof (or just proof, if 
is understood).
‚ñ°
I.3.18 Remark. (1) It is clear that if each of A1, . . . , An has a -proof and
B has an {A1, . . . , An}-proof, then B has a -proof. Indeed, simply con-
catenate all of the given -proofs (in any sequence). Append to the right of that
sequence the given {A1, . . . , An}-proof (that ends with B ). Then the entire
sequence is a -proof, and ends with B .
We refer to this phenomenon as the transitivity of ‚ä¢.
N.B. Transitivity of ‚ä¢allows one to invoke previously proved (by him or
others) theorems in the course of a proof. Thus, practically, a -proof is a
sequence of formulas in which each formula is an axiom, is a known -theorem,
or is obtained by applying a rule of inference on previous formulas of the
sequence.
(2) If  ‚äÜ and  ‚ä¢A, then also  ‚ä¢A, as follows from I.3.16 or I.3.17.
In particular, ‚ä¢A implies  ‚ä¢A for any .
(3) It is immediate from the deÔ¨Ånitions that for any formulas A and B ,
A, A ‚ÜíB ‚ä¢B
(i)
and if, moreover, x is not free in B ,
A ‚ÜíB ‚ä¢(‚àÉx)A ‚ÜíB
(ii)
Some texts (e.g., Sch¬®utte (1977)) give the rules in the format of (i)‚Äì(ii) above.
‚ñ°
The axioms and rules provide us with a calculus, that is, a means to ‚Äúcal-
culate‚Äù proofs and theorems. In the interest of making the calculus more user-
friendly ‚Äì and thus more easily applicable to mathematical theories of interest,
such as Peano arithmetic or set theory ‚Äì we are going to develop in the next
section a number of derived principles. These principles are largely of the form

38
I. Basic Logic
A1,. . . , An ‚ä¢B . We call such a (provable in the metatheory) principle a de-
rived rule of inference, since, by transitivity of ‚ä¢, it can be used as a proof-step
in a -proof. By contrast, the rules Inf1‚ÄìInf2 are ‚Äúbasic‚Äù or ‚Äúprimary‚Äù; they
are given outright.
We can now Ô¨Åx our understanding of the concept of a formal or mathematical
theory.
A (Ô¨Årst order) formal (mathematical) theory over a language L, or just theory
over L, or just theory, is a tuple (of ‚Äúingredients‚Äù) T = (L, , I, T ), where
L is a Ô¨Årst order language,  is a set of logical axioms, I is a set of rules of
inference, and T a non-empty subset of Wff that is required to contain  (i.e.,
 ‚äÜT ) and be closed under the rules I.
Equivalently, one may simply require that T is closed under ‚ä¢, that is, for
any  ‚äÜT and any formula A, if  ‚ä¢A, then A ‚ààT . This is, furthermore,
equivalent to requiring that
A ‚ààT
iff
T ‚ä¢A
(1)
Indeed, the if direction follows from closure under ‚ä¢, while the only if direction
is a consequence of DeÔ¨Ånition I.3.16.
T is the set of the formulas of the theory,‚Ä† and we often say ‚Äúa theory T ‚Äù,
taking everything else for granted.
If T = Wff, then the theory T is called inconsistent or contradictory. Oth-
erwise it is called consistent.
Throughout our exposition we Ô¨Åx  and I as in DeÔ¨Ånitions I.3.13 and I.3.15.
By (1), T = ThmT . This observation suggests that we call theories such as
the ones we have just deÔ¨Åned axiomatic theories, in that a set  always exists
so that T = Thm (if at a loss, we can just take  = T ).
We are mostly interested in theories T for which there is a ‚Äúsmall‚Äù set 
(‚Äúsmall‚Äù by comparison with T ) such that T = Thm. We say that T is
axiomatized by . Naturally, we call T
the set of theorems, and  the set of
nonlogical axioms of T.
If, moreover,  is recognizable (i.e., we can tell ‚Äúalgorithmically‚Äù whether
or not a formula A is in ), then we say that T is recursively axiomatized.
Examples of recursively axiomatized theories are ZFC set theory and Peano
arithmetic. On the other hand, if we take T to be all the formulas of arithmetic
that are true when interpreted ‚Äúin the intended way‚Äù‚Ä° over N ‚Äì the so-called
‚Ä† As opposed to ‚Äúof the language‚Äù, which is all of Wff.
‚Ä° That is, the symbol ‚Äú0‚Äù of the language is interpreted as the 0 ‚ààN, ‚ÄúSx‚Äù as x + 1, ‚Äú(‚àÉx)‚Äù as
‚Äúthere is an x ‚ààN‚Äù, etc.

I.3. Axioms and Rules of Inference
39
complete arithmetic ‚Äì then there is no recognizable  such that T
= Thm.
We say that complete arithmetic is not recursively axiomatizable.‚Ä†
Pause. Why does complete arithmetic form a theory? Because work of Sec-
tion I.5 ‚Äì in particular, the soundness theorem ‚Äì entails that it is closed under ‚ä¢.
We tend to further abuse language and call axiomatic theories by the name
of their (set of) nonlogical axioms . Thus if T = (L, , I, T ) is a Ô¨Årst order
theory and T
= Thm, then we may say interchangeably ‚Äútheory T ‚Äù, ‚Äútheory
T ‚Äù or ‚Äútheory ‚Äù.
If  = ‚àÖ, then we have a pure or absolute theory (i.e., we are ‚Äújust doing
logic, not math‚Äù). If  Ã∏= ‚àÖ, then we have an applied theory.
Argot. A Ô¨Ånal note on language versus metalanguage, and theory versus
metatheory. When are we speaking the metalanguage and when are we speaking
the formal language?
The answer is, respectively, ‚Äúalmost always‚Äù and ‚Äúalmost never‚Äù. As it
has been remarked before, in principle, we are speaking the formal language
exactly when we are pronouncing or writing down a string from Term or Wff.
Otherwise we are (speaking or writing) in the metalanguage. It appears that we
(and everybody else who has written a book in logic or set theory) is speaking
and writing within the metalanguage with a frequency approaching 100%.
The formalist is clever enough to simplify notation at all times. We will
seldom be caught writing down a member of Wff in this book, and, on the rare
occasions we may do so, it will only be to serve as an illustration of why one
should avoid writing down such formulas: because they are too long and hard
to read and understand.
We will be speaking the formal language with a heavy ‚Äúaccent‚Äù and using
many ‚Äúidioms‚Äù borrowed from ‚Äúreal‚Äù (meta)mathematics and English. We will
call our dialect argot, following Manin (1977).
The important thing to remember is when we are working in the theory,‚Ä° and
this is precisely when we generate theorems. That is, it does not matter if a theo-
rem (and much of the what we write down during the proof) is written in argot.
Two examples:
(1) One is working in formal number theory (or formal arithmetic) if one states
and proves (say, from the Peano axioms) that ‚Äúevery natural number n > 1
‚Ä† The trivial solution ‚Äì that is, taking  = T ‚Äì will not do, for it turns out that T is not
recognizable.
‚Ä° Important, because arguing in the theory restricts us to use only its axioms (and earlier proved
theorems; cf. I.3.18) and its rules of inference ‚Äì nothing extraneous to these syntactic tools is
allowed.

40
I. Basic Logic
has a prime factor‚Äù. Note how this theorem is stated in argot. Below we
give its translation into the formal language of arithmetic:‚Ä†
(‚àÄn)(S0 < n ‚Üí(‚àÉx)(‚àÉy)(n = x √ó y ‚àß
S0 < x ‚àß(‚àÄm)(‚àÄr)(x = m √ó r ‚Üím = S0 ‚à®m = x)))
(1)
(2) One is working in formal logic if one is writing a proof of (‚àÉv13)v13 = v13.
Suppose though that our activity consists of effecting deÔ¨Ånitions, introducing
axioms,oranalyzingthebehaviourorcapabilityofT,e.g.,provingsomederived
rule A1,. . . , An ‚ä¢B ‚Äì that is, a theorem schema ‚Äì or investigating consis-
tency‚Ä° or ‚Äúrelative consistency‚Äù.¬ß Then we are operating in the metatheory,
that is, in ‚Äúreal‚Äù mathematics.
One of the most important problems posed in the metatheory is
‚ÄúGiven a theory T and a formula A. Is A a theorem of T?‚Äù
This is Hilbert‚Äôs Entscheidungsproblem, or decision problem. Hilbert be-
lieved that every recursively axiomatized theory ought to admit a ‚Äúgeneral‚Äù
solution, by more or less mechanical means, to its decision problem. The tech-
niques of G¬®odel and the insight of Church showed that this problem is, in
general, algorithmically unsolvable.
As we have already stated (p. 36), metamathematics exists outside and in-
dependently of our effort to build this or that formal system. All its methods
are ‚Äì in principle ‚Äì available to us for use in the analysis of the behaviour of a
formal system.
Pause. But how much of real mathematics are we allowed to use, reliably, to
study or speak about the ‚Äúsimulator‚Äù that the formal system is?¬∂ For example,
have we not overstepped our license by using induction (and, implicitly, the
entire inÔ¨Ånite set N) in our Platonist metatheory, speciÔ¨Åcally in the recursive or
inductive deÔ¨Ånitions of terms, well-formed formulas, theorems, etc.?
The quibble here is largely ‚Äúpolitical‚Äù. Some people argue (a major propo-
nent of this was Hilbert) as follows: Formal mathematics was meant to crank
out ‚Äútrue‚Äù statements of mathematics, but no ‚Äúfalse‚Äù ones, and this freedom
‚Ä† Well, almost. In the interest of brevity, all the variable names used in the displayed formula (1)
are metasymbols.
‚Ä° That is, whether or not T = Wff.
¬ß That is, ‚Äúif  is consistent‚Äù ‚Äì where we are naming the theory by its nonlogical axioms ‚Äì ‚Äúdoes
it stay so after we have added some formula A as a nonlogical axiom?‚Äù
¬∂ The methods or scope of the metamathematics that a logician uses ‚Äì in the investigation of some
formal system ‚Äì are often restricted for technical or philosophical reasons.

I.3. Axioms and Rules of Inference
41
from contradiction ought to be veriÔ¨Åable. Now, as we are so verifying in the
metatheory (i.e., outside the formal system) shouldn‚Äôt the metatheory itself be
‚Äúabove suspicion‚Äù (of contradiction, that is)? Naturally.
Hilbert‚Äôs suggestion for achieving this ‚Äúabove suspicion‚Äù status was, essen-
tially, to utilize in the metatheory only a small fragment of ‚Äúreality‚Äù that is
so simple and close to intuition that it does not need itself a ‚ÄúcertiÔ¨Åcate‚Äù (via
formalization) for its freedom from contradiction. In other words, restrict the
metamathematics.‚Ä† Such a fragment of the metatheory, he said, should have
nothing to do with the inÔ¨Ånite, in particular with the entire set N and all that it
entails (e.g., inductive deÔ¨Ånitions and proofs).‚Ä°
If it were not for G¬®odel‚Äôs incompleteness results, this position ‚Äì that meta-
mathematical techniques must be Ô¨Ånitary ‚Äì might have prevailed. However,
G¬®odel proved it to be futile, and most mathematicians have learnt to feel com-
fortable with inÔ¨Ånitary metamathematical techniques, or at least with N and
induction.¬ß Of course, it would be reckless to use as metamathematical tools
‚Äúmathematics‚Äù of suspect consistency (e.g., the full na¬®ƒ±ve theory of sets).
It is worth pointing out that one could Ô¨Åt (with some effort) our inductive
deÔ¨Ånitions within Hilbert‚Äôs style. But we will not do so. First, one would have
to abandon the elegant (and now widely used) approach with closures, and use
instead the concept of derivations of Section I.2. Then one would somehow
have to effect and study derivations without the beneÔ¨Åt of the entire set N.
Bourbaki (1966b, p. 15) does so with his constructions formatives. Hermes
(1973) is another author who does so, with his ‚Äúterm-‚Äù and ‚Äúformula-calculi‚Äù
(such calculi being, essentially, Ô¨Ånite descriptions of derivations).
Bourbaki (but not Hermes) avoids induction over all of N. In his metamath-
ematical discussions of terms and formulas¬∂ that are derived by a derivation
‚Ä† Otherwise we would need to formalize the metamathematics ‚Äì in order to ‚Äúcertify‚Äù it ‚Äì and
next the metametamathematics, and so on. For if ‚ÄúmetaM‚Äù is to authoritatively check ‚ÄúM‚Äù for
consistency, then it too must be consistent; so let us formalize ‚ÄúmetaM‚Äù and let ‚ÄúmetametaM‚Äù
check it; . . . a never ending story.
‚Ä° See Hilbert and Bernays (1968, pp. 21‚Äì29) for an elaborate scheme that constructs ‚Äúconcrete
number objects‚Äù ‚Äì Ziffern or ‚Äúnumerals‚Äù ‚Äì ‚Äú|‚Äù, ‚Äú||‚Äù, ‚Äú|||‚Äù, etc., that stand for ‚Äú1‚Äù, ‚Äú2‚Äù, ‚Äú3‚Äù, etc.,
complete with a ‚Äúconcrete mathematical induction‚Äù proof technique on these objects, and even
the beginnings of their recursion theory. Of course, at any point, only Ô¨Ånite sets of such objects
were considered.
¬ß Some proponents of inÔ¨Ånitary techniques in metamathematics have used very strong words
in describing the failure of ‚ÄúHilbert‚Äôs program‚Äù. Rasiowa and Sikorski (1963) write in their
introduction: ‚ÄúHowever G¬®odel‚Äôs results exposed the Ô¨Åasco of Hilbert‚Äôs Ô¨Ånitistic methods as far
as consistency is concerned.‚Äù
¬∂ For example, in loc. cit., p. 18, where he proves that, in our notation, A[x ‚Üêy] and t[x ‚Üêy]
are a formula and term respectively.

42
I. Basic Logic
d1,. . . , dn, he restricts his induction arguments on the segment {0, 1,. . . , n},
that is, he takes an I.H. on k < n and proceeds to k + 1.
I.4. Basic Metatheorems
We are dealing with an arbitrary theory T = (L, , I, T ), such that  is the
set of logical axioms (I.3.13) and I are the inference rules (I.3.15). We also let
 be an appropriate set of nonlogical axioms, i.e., T = Thm.
I.4.1 Metatheorem (Post‚Äôs ‚ÄúExtended‚Äù Tautology Theorem). If A1,. . . ,
An |=Taut B then A1,. . . , An ‚ä¢B .
‚ñ°
Proof. The assumption yields that
|=Taut A1 ‚Üí¬∑ ¬∑ ¬∑ ‚ÜíAn ‚ÜíB
(1)
Thus, since the formula in (1) is in , using DeÔ¨Ånition I.3.16, we have
A1,¬∑ ¬∑ ¬∑ , An ‚ä¢A1 ‚Üí¬∑ ¬∑ ¬∑ ‚ÜíAn ‚ÜíB
(2)
Applying modus ponens to (2) n times, we deduce B .
‚ñ°
I.4.1 is an omnipresent derived rule.
I.4.2 DeÔ¨Ånition. A and B provably equivalent in T means that  ‚ä¢A ‚ÜîB .
I.4.3 Metatheorem. Any two theorems A and B of T are provably equivalent
in T.
Proof. By I.4.1,  ‚ä¢A yields  ‚ä¢B ‚ÜíA. Similarly,  ‚ä¢B yields
 ‚ä¢A ‚ÜíB . One more application of I.4.1 yields  ‚ä¢A ‚ÜîB .
‚ñ°
Worth noting: ‚ä¢¬¨x = x ‚Üî¬¨y = y (why?), but neither ¬¨x = x nor ¬¨y = y
is a ‚àÖ-theorem.
I.4.4 Remark (Hilbert Style Proofs). In practice we write proofs ‚Äúvertically‚Äù,
that is, as numbered vertical sequences (or lists) of formulas. The numbering
helps the annotational comments that we insert to the right of each formula that
we list, as the following proof demonstrates.

I.4. Basic Metatheorems
43
A metatheorem admits a metaproof, strictly speaking. The following is a
derived rule (or theorem schema) and thus belongs to the metatheory (and so
does its proof).
Another point of view is possible, however: The syntactic symbols x, A,
and B below stand for a speciÔ¨Åc variable and speciÔ¨Åc formulas that we just
forgot to write down explicitly. Then one can think of the proof as a (formal)
Hilbert style proof.
‚ñ°
I.4.5 Metatheorem (‚àÄ-Introduction ‚Äì Pronounced ‚ÄúA-Introduction‚Äù). If x
does not occur free in A, then A ‚ÜíB ‚ä¢A ‚Üí(‚àÄx)B .
Proof.
(1)
A ‚ÜíB
given
(2)
¬¨B ‚Üí¬¨A
(1) and I.4.1
(3)
(‚àÉx)¬¨B ‚Üí¬¨A
(2) and ‚àÉ-introduction
(4)
A ‚Üí¬¨(‚àÉx)¬¨B
(3) and I.4.1
(5)
A ‚Üí(‚àÄx)B
(4), introducing the ‚àÄ-abbreviation
‚ñ°
I.4.6 Metatheorem (Specialization). For any formula A and term t,
‚ä¢(‚àÄx)A ‚ÜíA [t].
At this point, the reader may want to review our abbreviation conventions, in
particular, see Ax2 (I.3.13).
Proof.
(1)
¬¨A[t] ‚Üí(‚àÉx)¬¨A
in 
(2)
¬¨(‚àÉx)¬¨A ‚ÜíA[t]
(1) and I.4.1
(3)
(‚àÄx)A ‚ÜíA [t]
(2), introducing the ‚àÄ-abbreviation
‚ñ°
I.4.7 Corollary. For any formula A, ‚ä¢(‚àÄx)A ‚ÜíA .
Proof. A[x ‚Üêx] ‚â°A.
‚ñ°
Pause. Why is A[x ‚Üêx] the same string as A?
I.4.8 Metatheorem (Generalization). For any  and any A, if  ‚ä¢A, then
 ‚ä¢(‚àÄx)A .

44
I. Basic Logic
Proof. Choose y Ã∏‚â°x. Then we continue any given proof of A (from ) as
follows:
(1)
A
proved from 
(2)
y = y ‚ÜíA
(1) and I.4.1
(3)
y = y ‚Üí(‚àÄx)A
(2) and ‚àÄ-introduction
(4)
y = y
in 
(5)
(‚àÄx)A
(3), (4), and MP
‚ñ°
I.4.9 Corollary. For any  and any A,  ‚ä¢A iff  ‚ä¢(‚àÄx)A.
Proof. By I.4.7, I.4.8, and modus ponens.
‚ñ°
I.4.10 Corollary. For any A, A ‚ä¢(‚àÄx)A and (‚àÄx)A ‚ä¢A.
‚ñ°
The above corollary motivates the following deÔ¨Ånition. It also justiÔ¨Åes the
common mathematical practice of the ‚Äúimplied universal quantiÔ¨Åer‚Äù. That is,
we often state ‚Äú. . . x . . . ‚Äù when we mean ‚Äú(‚àÄx) . . . x . . . ‚Äù.
I.4.11 DeÔ¨Ånition (Universal Closure). Let y1,. . . , yn be the list of all free vari-
ables of A. The universal closure of A is the formula (‚àÄy1)(‚àÄy2) ¬∑ ¬∑ ¬∑ (‚àÄyn)A ‚Äì
often written more simply as (‚àÄy1y2 . . . yn)A or even (‚àÄ‚Éóyn)A.
‚ñ°
By I.4.10, a formula deduces and is deduced by its universal closure.
Pause. We said the universal closure. Hopefully, the remark immediately above
is undisturbed by permutation of (‚àÄy1)(‚àÄy2) ¬∑ ¬∑ ¬∑ (‚àÄyn). Is it? (Exercise I.11).
I.4.12 Corollary (Substitution of Terms). A[x1,. . . , xn] ‚ä¢A[t1,. . . , tn] for
any terms t1,. . . , tn.
The reader may wish to review I.3.12 and the remark following it.
Proof. We illustrate the proof for n = 2. What makes it interesting is the re-
quirement to have ‚Äúsimultaneous substitution‚Äù. To that end we Ô¨Årst substitute
into x1 and x2 new variables z, w ‚Äì i.e., not occurring in either A or in the ti.
The proof is the following sequence. Comments justify, in each case, the pres-
ence of the formula immediately to the left by virtue of the presence of the

I.4. Basic Metatheorems
45
immediately preceding formula.
A[x1, x2]
starting point
(‚àÄx1)A[x1, x2]
generalization
A[z, x2]
specialization; x1 ‚Üêz
(‚àÄx2)A[z, x2]
generalization
A[z, w]
specialization; x2 ‚Üêw
Now z ‚Üêt1, w ‚Üêt2, in any order, is the same as ‚Äúsimultaneous substitu-
tion I.3.12‚Äù:
(‚àÄz)A[z, w]
generalization
A[t1, w]
specialization; z ‚Üêt1
(‚àÄw)A[t1, w]
generalization
A[t1, t2]
specialization; w ‚Üêt2
‚ñ°
I.4.13 Metatheorem (The Variant, or Dummy-Renaming, Metatheorem).
For any formula (‚àÉx)A, if z does not occur in it (i.e., is neither free nor bound),
then ‚ä¢(‚àÉx)A ‚Üî(‚àÉz)A[x ‚Üêz].
We often write this (under the stated conditions) as ‚ä¢(‚àÉx)A[x] ‚Üî(‚àÉz)A[z].
By the way, another way to state the conditions is ‚Äúif z does not occur in A
(i.e., is neither free nor bound in A), and is different from x‚Äù. Of course, if
z ‚â°x, then there is nothing to prove.
Proof. Since z is substitutable in x under the stated conditions, A[x ‚Üêz] is
deÔ¨Åned. Thus, by Ax2,
‚ä¢A[x ‚Üêz] ‚Üí(‚àÉx)A
By ‚àÉ-introduction ‚Äì since z is not free in (‚àÉx)A ‚Äì we also have
‚ä¢(‚àÉz)A[x ‚Üêz] ‚Üí(‚àÉx)A
(1)
We note that x is not free in (‚àÉz)A[x‚Üêz] and is free for z in A[x‚Üêz]. Indeed,
A[x ‚Üêz][z ‚Üêx] ‚â°A. Thus, by Ax2,
‚ä¢A ‚Üí(‚àÉz)A[x ‚Üêz]
Hence, by ‚àÉ-introduction,
‚ä¢(‚àÉx)A ‚Üí(‚àÉz)A[x ‚Üêz]
(2)
Tautological implication from (1) and (2) concludes the argument.
‚ñ°

46
I. Basic Logic
Why is A[x ‚Üêz][z ‚Üêx] ‚â°A? We can see this by induction on A (recall
that z occurs as neither free nor bound in A).
If A is atomic, then the claim is trivial. The claim also clearly ‚Äúpropagates‚Äù
with the propositional formation rules, that is, I.1.8(b).
Consider then the case that A ‚â°(‚àÉw)B . Note that w ‚â°x is possible
under our assumptions, but w ‚â°z is not. If w ‚â°x, then A[x ‚Üêz] ‚â°A; in
particular, z is not free in A; hence A[x ‚Üêz][z ‚Üêx] ‚â°A as well.
So let us work with w Ã∏‚â°x. By I.H., B [x ‚Üêz][z ‚Üêx] ‚â°B . Now
A[x ‚Üêz][z ‚Üêx] ‚â°((‚àÉw)B )[x ‚Üêz][z ‚Üêx]
‚â°((‚àÉw)B [x ‚Üêz])[z ‚Üêx]
see I.3.11; w Ã∏‚â°z
‚â°((‚àÉw)B [x ‚Üêz][z ‚Üêx])
see I.3.11; w Ã∏‚â°x
‚â°((‚àÉw)B )
I.H.
‚â°A
By I.4.13, the issue of substitutability becomes moot. Since we have an inÔ¨Ånite
supply of variables (to use, for example, as bound variables), we can always
change the names of all the bound variables in A so that the new names are
different from all the free variables in A or t. In so doing we obtain a formula
B that is (absolutely) provably equivalent to the original.
Then B [x ‚Üêt] will be deÔ¨Åned (t will be substitutable in x). Thus, the
moral is: any term t is free for x in A after an appropriate ‚Äòdummy‚Äô renaming.
By the way, this is one of the reasons we want an inÔ¨Ånite supply (or an
extendible Ô¨Ånite set, for the Ô¨Ånitist) of formal variables.
I.4.14 DeÔ¨Ånition. In the following we will often discuss two (or more) theories
at once. Let T = (L, , I, T ) and T‚Ä≤ = (L‚Ä≤, , I, T ‚Ä≤) be two theories, such
that V
‚äÜV ‚Ä≤. This enables T‚Ä≤ to be ‚Äúaware‚Äù of all the formulas of T (but not
vice versa, since L‚Ä≤ contains additional nonlogical symbols).
We say that T‚Ä≤ is an extension of T (in symbols, T ‚â§T‚Ä≤ ) iff T ‚äÜT ‚Ä≤.
Let A be a formula over L (so that both theories are aware of it). The symbols
‚ä¢T A and ‚ä¢T‚Ä≤ A are synonymous with A ‚ààT and A ‚ààT ‚Ä≤ respectively.
Note that we did not explicitly mention the nonlogical axioms  or ‚Ä≤ to the
left of ‚ä¢, since the subscript of ‚ä¢takes care of that information.
We say that the extension is conservative iff for any A over L, whenever
‚ä¢T‚Ä≤ A it is also the case that ‚ä¢T A. That is, when it comes to formulas over
the language (L) that both theories understand, then the new theory does not
do any better than the old in producing theorems.
‚ñ°
I.4.15 Metatheorem (Metatheorem on Constants). Let us extend a language
L of a theory T by adding new constant symbols e1,. . . , en to the alphabet V ,
resulting in the alphabet V ‚Ä≤, language L‚Ä≤, and theory T‚Ä≤.

I.4. Basic Metatheorems
47
Furthermore, assume that ‚Ä≤ = , that is, we did not add any new nonlogical
axioms.
Then‚ä¢T‚Ä≤ A[e1,. . . , en]implies‚ä¢T A[x1,. . . , xn]foranyvariables x1,. . . ,
xn that occur nowhere in A[e1,. . . , en], as either free or bound variables.
Proof. Fix a set of variables x1,. . . , xn as described above. We do induction on
T‚Ä≤-theorems.
Basis. A[e1,. . . , en] is a logical axiom (over L‚Ä≤); hence so is A[x1,. . . , xn],
over L ‚Äì because of the restriction on the xi ‚Äì thus ‚ä¢T A[x1,. . . , xn]. Note
that A[e1,. . . , en] cannot be nonlogical under our assumptions.
Pause. What does the restriction on the xi have to do with the claim above?
Modus ponens. Here ‚ä¢T‚Ä≤
B [e1,. . . , en] ‚ÜíA[e1,. . . , en] and ‚ä¢T‚Ä≤
B [e1,. . . , en]. By I.H., ‚ä¢T
B [y1,. . . , yn] ‚ÜíA[y1,. . . , yn] and ‚ä¢T
B [y1,. . . , yn], where y1,. . . , yn occur nowhere in B [e1,. . . , en]
‚Üí
A[e1,. . . , en] as either free or bound variables. By modus ponens, ‚ä¢T
A[y1,. . . , yn]; hence ‚ä¢T A[x1,. . . , xn] by I.4.12 (and I.4.13).
‚àÉ-introduction. We have ‚ä¢T‚Ä≤ B [e1,. . . , en] ‚ÜíC [e1,. . . , en], z is not free
in C [e1,. . . , en], and A[e1,. . . , en] ‚â°(‚àÉz)B [e1,. . . , en] ‚ÜíC [e1,. . . , en].
By I.H., if w1,. . . , wn ‚Äì distinct from z ‚Äì occur nowhere in B [e1,. . . , en] ‚Üí
C [e1,. . . , en] as either free or bound, then we get ‚ä¢T B [w1,. . . , wn] ‚Üí
C [w1,. . . , wn]. By ‚àÉ-introduction we get ‚ä¢T
(‚àÉz)B [w1,. . . , wn]
‚Üí
C [w1,. . . , wn]. By I.4.12 and I.4.13 we get ‚ä¢T (‚àÉz)B [x1,. . . , xn] ‚Üí
C [x1,. . . , xn], i.e., ‚ä¢T A[x1,. . . , xn].
‚ñ°
I.4.16 Corollary. Let us extend a language L of a theory T by adding new
constant symbols e1,. . . , en to the alphabet V , resulting to the alphabet V ‚Ä≤,
language L‚Ä≤, and theory T‚Ä≤.
Furthermore, assume that ‚Ä≤ = , that is, we did not add any new nonlogical
axioms.
Then ‚ä¢T‚Ä≤ A[e1,. . . , en] iff ‚ä¢T A[x1,. . . , xn], for any choice of variables
x1,. . . , xn.
‚ñ°
Proof. If part: Trivially, ‚ä¢T A[x1,. . . , xn] implies ‚ä¢T‚Ä≤ A[x1,. . . , xn], hence
‚ä¢T‚Ä≤ A[e1,. . . , en] by I.4.12.
Only-if
part:
Choose
variables
y1,. . . , yn
that
occur
nowhere
in
A[e1,. . . , en] as either free or bound. By I.4.15, ‚ä¢T A[y1,. . . , yn]; hence,
by I.4.12 and I.4.13, ‚ä¢T A[x1,. . . , xn].
‚ñ°
I.4.17 Remark. Thus, the extension T‚Ä≤ of T is conservative, for, if A is over
L, then A[e1,. . . , en] ‚â°A. Therefore, if ‚ä¢T‚Ä≤ A, then ‚ä¢T‚Ä≤ A[e1,. . . , en];
hence ‚ä¢T A[x1,. . . , xn], that is, ‚ä¢T A.

48
I. Basic Logic
A more emphatic way to put the above is this: T‚Ä≤ is not aware of any new
nonlogical facts that T did not already ‚Äúknow‚Äù although by a different name. If
T‚Ä≤ can prove A[e1,. . . , en], then T can prove the same ‚Äústatement‚Äù, however,
using (any) names (other than the ei) that are meaningful in its own language;
namely, it can prove A[x1,. . . , xn].
‚ñ°
The following corollary stems from the proof (rather than the statement)
of I.4.15 and I.4.16, and is important.
I.4.18 Corollary. Let e1,. . . , en be constants that do not appear in the nonlog-
ical axioms . Then, if x1,. . . , xn are any variables, and if  ‚ä¢A[e1,. . . , en],
it is also the case that  ‚ä¢A[x1,. . . , xn].
I.4.19 Metatheorem (The Deduction Theorem). For any closed formula A,
arbitrary formula B , and set of formulas , if +A ‚ä¢B , then  ‚ä¢A ‚ÜíB .
N.B.  + A denotes the augmentation of  by adding the formula A. In the
present metatheorem A is a single (but unspeciÔ¨Åed) formula. However, the no-
tation extends to the case where A is a schema, in which case it means the
augmentation of  by adding all the instances of the schema.
A converse of the metatheorem is also true trivially: That is,  ‚ä¢A ‚ÜíB
implies  + A ‚ä¢B . This direction immediately follows by modus ponens
and does not require the restriction on A.
Proof. The proof is by induction on  + A theorems.
Basis. Let B be logical or nonlogical (but, in the latter case, assume
B Ã∏‚â°A). Then  ‚ä¢B .
Since B |=Taut A ‚ÜíB , it follows by I.4.1 that  ‚ä¢A ‚ÜíB .
Now, if B ‚â°A, then A ‚ÜíB is a logical axiom (group Ax1); hence
 ‚ä¢A ‚ÜíB once more.
Modus ponens. Let  + A ‚ä¢C , and  + A ‚ä¢C ‚ÜíB .
By I.H.,  ‚ä¢A ‚ÜíC and  ‚ä¢A ‚ÜíC ‚ÜíB .
Since A ‚ÜíC , A ‚ÜíC ‚ÜíB |=Taut A ‚ÜíB , we have  ‚ä¢A ‚ÜíB .
‚àÉ-introduction. Let  + A ‚ä¢C ‚ÜíD , and B ‚â°(‚àÉx)C ‚ÜíD , where x is
not free in D . By I.H.,  ‚ä¢A ‚ÜíC ‚ÜíD . By I.4.1,  ‚ä¢C ‚ÜíA ‚ÜíD ;
hence  ‚ä¢(‚àÉx)C ‚ÜíA ‚ÜíD by ‚àÉ-introduction (A is closed). One more
application of I.4.1 yields  ‚ä¢A ‚Üí(‚àÉx)C ‚ÜíD .
‚ñ°
I.4.20 Remark. (1) Is the restriction that, A must be closed important? Yes.
Let A ‚â°x = a, where ‚Äúa‚Äù is some constant. Then, even though A ‚ä¢(‚àÄx)A

I.4. Basic Metatheorems
49
by generalization, it is not always true that ‚ä¢A ‚Üí(‚àÄx)A. This follows from
soundness considerations (next section). Intuitively, assuming that our logic
‚Äúdoesn‚Äôt lie‚Äù (that is, it proves no ‚Äúinvalid‚Äù formulas), we immediately infer
that x = a ‚Üí(‚àÄx)x = a cannot be absolutely provable, for it is a ‚Äúlie‚Äù. It fails
at least over N, if a is interpreted to be ‚Äú0‚Äù.
(2) I.4.16 adds Ô¨Çexibility to applications of the deduction theorem:
‚ä¢T (A ‚ÜíB )[x1,. . . , xn]
(‚àó)
where [x1,. . . , xn] is the list of all free variables just in A, is equivalent
(by I.4.16) to
‚ä¢T‚Ä≤ (A ‚ÜíB )[e1,. . . , en]
(‚àó‚àó)
where e1,. . . , en are new constants added to V (with no effect on nonlogical
axioms:  = ‚Ä≤).
Now, since A[e1,. . . , en] is closed, proving
‚Ä≤ + A[e1,. . . , en] ‚ä¢B [e1,. . . , en]
establishes (‚àó‚àó), and hence also (‚àó).
In practice, one does not perform this step explicitly, but ensures that,
throughout the  + A proof, whatever free variables were present in A ‚Äúbe-
haved like constants‚Äù, or, as we also say, were frozen.
(3) In some expositions the deduction theorem is not constrained by requiring
that A be closed (e.g., Bourbaki (1966b) and more recently Enderton (1972)).
Which version is right? Both are in their respective contexts. If all the rules
of inference are ‚Äúpropositional‚Äù (e.g., as in Bourbaki (1966b) and Enderton
(1972), who only employ modus ponens) ‚Äì that is, they do not meddle with
quantiÔ¨Åers ‚Äì then the deduction theorem is unconstrained. If, on the other hand,
the rules of inference manipulate object variables via quantiÔ¨Åcation, then one
cannot avoid constraining the application of the deduction theorem, lest one
want to derive (the invalid) ‚ä¢A ‚Üí(‚àÄx)A from the valid A ‚ä¢(‚àÄx)A.
This also entails that approaches such as in Bourbaki (1966b) and Enderton
(1972) do not allow ‚Äúfull‚Äù generalization ‚ÄúA ‚ä¢(‚àÄx)A‚Äù. They only allow a
‚Äúweaker‚Äù rule, ‚Äúif ‚ä¢A, then ‚ä¢(‚àÄx)A‚Äù.‚Ä†
(4) This divergence of approach in choosing rules of inference has some addi-
tional repercussions: One has to be careful in deÔ¨Åning the semantic counterpart
‚Ä† Indeed, they allow a bit more generally, namely, the rule ‚Äúif  ‚ä¢A with a side condition, then
 ‚ä¢(‚àÄx)A. The side condition is that the formulas of  do not have free occurrences of x.‚Äù Of
course,  can be always taken to be Ô¨Ånite (why?), so that this condition is not unrealistic.

50
I. Basic Logic
of ‚ä¢, namely, |= (see next section). One wants the two symbols to ‚Äútrack each
other‚Äù faithfully (G¬®odel‚Äôs completeness theorem).‚Ä†
I.4.21 Corollary (Proof by Contradiction). Let A be closed. Then  ‚ä¢A
iff  + ¬¨A is inconsistent.
Proof. If part: Given that T = Wff, where T
is the theory  + ¬¨A. In par-
ticular,  + ¬¨A ‚ä¢A. By the deduction theorem,  ‚ä¢¬¨A ‚ÜíA. But ¬¨A ‚Üí
A |=Taut A.
Only-if part: Given that  ‚ä¢A. Hence  + ¬¨A ‚ä¢A as well (re-
call I.3.18(2)). Of course,  + ¬¨A ‚ä¢¬¨A. Since A, ¬¨A |=Taut B for an
arbitrary B , we are done.
‚ñ°
Pause. Is it necessary to assume that A is closed in I.4.21? Why?
The following is important enough to merit stating. It follows from the type
of argument we employed in the only-if part above.
I.4.22 Metatheorem. T is inconsistent iff for some A, both ‚ä¢T A and ‚ä¢T ¬¨A
hold.
We also list below a number of ‚Äúquotable‚Äù proof techniques. These tech-
niques are routinely used by mathematicians, and will be routinely used by us.
The proofs of all the following metatheorems are delegated to the reader.
I.4.23Metatheorem(DistributivityorMonotonicityof‚àÉ). Forany x, A, B ,
A ‚ÜíB ‚ä¢(‚àÉx)A ‚Üí(‚àÉx)B
Proof. See Exercise I.12.
‚ñ°
I.4.24Metatheorem(DistributivityorMonotonicityof‚àÄ). Forany x, A, B ,
A ‚ÜíB ‚ä¢(‚àÄx)A ‚Üí(‚àÄx)B
Proof. See Exercise I.13.
‚ñ°
The term ‚Äúmonotonicity‚Äù is inspired by thinking of ‚Äú‚Üí‚Äù as ‚Äú‚â§‚Äù. How? Well,
we have the tautology
(A ‚ÜíB ) ‚Üî(A ‚à®B ‚ÜîB)
(i)
‚Ä† In Mendelson (1987), |= is deÔ¨Åned inconsistently with ‚ä¢.

I.4. Basic Metatheorems
51
If we think of ‚ÄúA‚à®B ‚Äù as ‚Äúmax(A, B )‚Äù, then the right hand side in (i) above
says that B is the maximum of A and B , or that A is ‚Äúless than or equal to‚Äù
B . The above metatheorems say that both ‚àÉand ‚àÄpreserve this ‚Äúinequality‚Äù.
I.4.25 Metatheorem (Equivalence Theorem, or Leibniz Rule). Let  ‚ä¢
A ‚ÜîB , and let C ‚Ä≤ be obtained from C by replacing some ‚Äì possibly, but not
necessarily, all ‚Äì occurrences of a subformula A of C by B .
Then  ‚ä¢C ‚ÜîC ‚Ä≤, i.e.,
A ‚ÜîB
C ‚ÜîC ‚Ä≤
is a derived rule.
Proof. The proof is by induction on formulas C . See Exercise I.15.
‚ñ°
Equational or calculational predicate logic is a particular foundation of Ô¨Årst
order logic that uses the above Leibniz rule as the primary rule of inference. In
‚Äúpractising‚Äù such logic one prefers to write proofs as chains of equivalences.
Most equivalences in such a chain stem from an application of the rule. See
Dijkstra and Scholten (1990), Gries and Schneider (1994), Tourlakis (2000a,
2000b, 2001b).
I.4.26 Metatheorem (Proof by Cases). Suppose that  ‚ä¢A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®An,
and  ‚ä¢Ai ‚ÜíB for i = 1, . . . . Then  ‚ä¢B .
Proof. Immediate, by I.4.1.
‚ñ°
Proof by cases usually beneÔ¨Åts from the application of the deduction theorem.
That is, having established  ‚ä¢A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®An, one then proceeds to adopt,
in turn, each Ai (i = 1,. . . , n) as a new nonlogical axiom (with its variables
‚Äúfrozen‚Äù). In each ‚Äúcase‚Äù (Ai) one proceeds to prove B .
At the end of all this one has established  ‚ä¢B .
In practice we normally use the following argot:
‚ÄúWe will consider cases Ai, for i = 1,. . . , n.‚Ä†
Case A1.
. . . therefore, B .‚Ä°
¬∑ ¬∑ ¬∑
Case An.
. . . therefore, B .‚Äù
‚Ä† To legitimize this splitting into cases, we must, of course, show  ‚ä¢A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®An.
‚Ä° That is, we add the axiom A1 to , freezing its variables, and we then prove B .

52
I. Basic Logic
I.4.27 Metatheorem (Proof by Auxiliary Constant). Suppose that for arbi-
trary A and B over the language L we know
(1)  ‚ä¢(‚àÉx)A[x]
(2)  + A[a] ‚ä¢B , where a is a new constant not in the language L of .
Furthermore assume that in the proof of B all the free variables of A[a]
were frozen. Then  ‚ä¢B .
Proof. Exercise I.21.
‚ñ°
The technique that Ô¨Çows from this metatheorem is used often in practice. For
example, in projective geometry axiomatized as in Veblen and Young (1916),
in order to prove Desargues‚Äôs theorem on perspective triangles on the plane, we
use some arbitrary point (this is the auxiliary constant!) off the plane, having
veriÔ¨Åed that the axioms guarantee that such a point exists. It is important to
note that Desargues‚Äôs theorem does not refer to this point at all ‚Äì hence the term
‚Äúauxiliary‚Äù.
In this example, from projective geometry, ‚ÄúB ‚Äù is Desargues‚Äôs theorem,
‚Äú(‚àÉx)A[x]‚Äù asserts that there are points outside the plane, a is an arbitrary such
point, and the proof (2) starts with words like ‚ÄúLet a be a point off the plane‚Äù ‚Äì
which is argot for ‚Äúadd the axiom A[a]‚Äù.
I.5. Semantics; Soundness, Completeness, Compactness
So what do all these symbols mean? We show in this section how to ‚Äúdecode‚Äù the
formal statements (formulas) into informal statements of ‚Äúreal‚Äù mathematics.
Conversely, this will entail an understanding of how to code statements of real
mathematics in our formal language.
The rigorous‚Ä† deÔ¨Ånition of semantics for Ô¨Årst order languages is due to Tarski
and is often referred to as ‚ÄúTarski semantics‚Äù. The Ô¨Çavour of the particular
deÔ¨Ånition given below is that of ShoenÔ¨Åeld (1967), and it accurately reÔ¨Çects
our syntactic choices ‚Äì most importantly, the choice to allow full generalization
A ‚ä¢(‚àÄx)A.Inparticular,wewilldeÔ¨Ånethesemanticcounterpartof‚ä¢,namely,
|=, pronounced ‚Äúlogically implies‚Äù, to ensure that  ‚ä¢A iff  |= A. This is
the content of G¬®odel‚Äôs completeness theorem, which we prove in this section.
This section will place some additional demands on the reader‚Äôs recollection
of notation and facts from informal set theory. We will, among other things,
‚Ä† One often says ‚ÄúThe formal deÔ¨Ånition of semantics . . . ‚Äù, but the word ‚Äúformal‚Äù is misleading
here, for we are actually deÔ¨Åning semantics in the metatheory, not in the formal theory.

I.5. Semantics; Soundness, Completeness, Compactness
53
make use of notation from na¬®ƒ±ve set theory, such as
An
(or A √ó ¬∑ ¬∑ ¬∑ √ó A



n times
)
for the set of ordered n-tuples of members of A.
We will also use the symbols ‚äÜ, ‚à™, 
a‚ààI.‚Ä†
In some passages ‚Äì delimited by
warning signs ‚Äì these demands will
border on the unreasonable.
For example, in the proof of the G¬®odel-Mal‚Ä≤cev completeness-compactness
result we will need some elementary understanding of ordinals ‚Äì used as index-
ing tools ‚Äì and cardinality. Some readers may not have such background. This
prerequisite material can be attained by consulting a set theory book (e.g., the
second volume of these lectures).
I.5.1 DeÔ¨Ånition. Given a language L = (V , Term, Wff), a structure M =
(M, I ) appropriate for L is such that M Ã∏= ‚àÖis a set (the domain or underlying
set or universe‚Ä°) and I (‚ÄúI ‚Äù for interpretation) is a mapping that assigns
(1) to each constant a of V
a unique member aI ‚ààM,
(2) to each function f of V
‚Äì of arity n ‚Äì a unique (total)¬ß function f I :
Mn ‚ÜíM,
(3) to each predicate P of V ‚Äì of arity n ‚Äì a unique set PI ‚äÜMn.¬∂
‚ñ°
I.5.2 Remark. The structure M is often given more verbosely, in conformity
with practice in algebra. Namely, one ‚Äúunpacks‚Äù the I into a list aI , bI ,. . . ;
f I , gI ,. . . ; PI , QI , . . . and
writes
instead
M = (M; aI , bI ,. . . ; f I ,
gI ,. . . ; PI , QI , . . . ). Under this understanding, a structure is an underly-
ing set (universe), M, along with a list of ‚Äúconcrete‚Äù constants, functions, and
relations that ‚Äúinterpret‚Äù corresponding ‚Äúabstract‚Äù items of the language.
Under the latter notational circumstances we often use the symbols aM, f M,
PM ‚Äì rather than aI , f I , PI ‚Äì to indicate the interpretations in M of the
constant a, function f , and predicate P respectively.
‚Ä† If we have a set of sets {Sa, Sb, Sc, . . . }, where the indices a, b, c, . . . all come out of an ‚Äúindex
set‚Äù I, then the symbol 
i‚ààI Si stands for the collection of all those objects x that are found in
at least one of the sets Si. It is a common habit to write 
‚àû
i=0 Si instead of 
i‚ààN Si. A ‚à™B is
the same as 
i‚àà{1,2} Si, where we have let S1 = A and S2 = B.
‚Ä° Often the qualiÔ¨Åcation ‚Äúof discourse‚Äù is added to the terms ‚Äúdomain‚Äù and ‚Äúuniverse‚Äù.
¬ß Requiring f I to be total is a traditional convention. By the way, total means that f I is deÔ¨Åned
everywhere on Mn.
¬∂ Thus PI is an n-ary relation with inputs and outputs in M.

54
I. Basic Logic
We have said above ‚Äústructure appropriate for L‚Äù, thus emphasizing the gen-
erality of the language and therefore our ability to interpret what we say in it in
many different ways. Often though, e.g., as in formal arithmetic or set theory,
we have a structure in mind to begin with, and then build a formal language to
formally codify statements about the objects in the structure. Under these cir-
cumstances, in effect, we deÔ¨Åne a language appropriate for the structure. We use
the symbol LM to indicate that the language was built to Ô¨Åt the structure M. ‚ñ°
I.5.3 DeÔ¨Ånition. We routinely add new nonlogical symbols to a language L
to obtain a language L‚Ä≤. We say that L‚Ä≤ is an extension of L and that L is
a restriction of L‚Ä≤. Suppose that M = (M, I ) is a structure for L, and let
M‚Ä≤ = (M, I ‚Ä≤) be a structure with the same underlying set M, but with I
extended to I ‚Ä≤ so that the latter gives meaning to all new symbols while it gives
the same meaning, as I does, to the symbols of L.
We call M‚Ä≤ an expansion (rather than ‚Äúextension‚Äù) of M, and M a reduct
(rather than ‚Äúrestriction‚Äù) of M‚Ä≤. We may (often) write I = I ‚Ä≤ ‚ÜæL to indicate
that the ‚Äúmapping‚Äù I ‚Ä≤ ‚Äì restricted to L (symbol ‚Äú ‚Üæ‚Äù) ‚Äì equals I . We may also
write M = M‚Ä≤ ‚ÜæL instead.
‚ñ°
I.5.4 DeÔ¨Ånition. Given L and a structure M = (M, I ) appropriate for L.
L(M) denotes the language obtained from L by adding to V
a unique new
name i for each object i ‚ààM.
This amends both sets Term, Wff into Term(M), Wff(M). Members of the
latter sets are called M-terms and M-formulas respectively.
We extend the mapping I to the new constants by: i
I = i for all i ‚ààM
(where the ‚Äú=‚Äù here is metamathematical: equality on M).
‚ñ°
All we have done here is to allow ourselves to do substitutions like [x ‚Üêi]
formally. We do, instead, [x ‚Üêi]. One next gives ‚Äúmeaning‚Äù to all closed
terms in L(M). The following uses deÔ¨Ånition by recursion (I.2.13) and relies
on the fact that the rules that deÔ¨Åne terms are unambiguous.
I.5.5 DeÔ¨Ånition. For closed terms t in Term(M) we deÔ¨Åne the symbol tI ‚ààM
inductively:
(1) If t is any of a (original constant) or i (imported constant), then tI has
already been deÔ¨Åned.
(2) If t is the string f t1 . . . tn, where f is n-ary, and t1,. . . , tn are closed M-
terms, we deÔ¨Åne tI to be the object (of M) f I (tI
1 ,. . . , tI
n ).
‚ñ°
Finally, we give meaning to all closed M-formulas, again by recursion (over
Wff).

I.5. Semantics; Soundness, Completeness, Compactness
55
I.5.6 DeÔ¨Ånition. For any closed formula A in Wff(M) we deÔ¨Åne the symbol
AI inductively. In all cases, AI ‚àà{t, f}.
(1) If A ‚â°t = s, where t and s are closed M-terms, then AI = t iff tI = sI .
(The last two occurrences of ‚Äú=‚Äù are metamathematical.)
(2) If A ‚â°Pt1 . . . tn, where P is an n-ary predicate and the ti are closed
M-terms, then AI = t iff ‚ü®tI
1 ,. . . , tI
n ‚ü©‚ààPI or PI (tI
1 ,. . . , tI
n ) ‚Äúholds‚Äù.
(Or ‚Äúis true‚Äù; see p. 19. Of course, the last occurrence of ‚Äú=‚Äù is metamathe-
matical.)
(3) If A is any of the sentences ¬¨B , B ‚à®C , then AI is determined by
the usual truth tables (see p. 30) using the values B I and C I . That is,
(¬¨B )I = F¬¨(B I ) and (B ‚à®C )I = F‚à®(B I , C I ). (The last two oc-
currences of ‚Äú=‚Äù are metamathematical.)
(4) If A ‚â°(‚àÉx)B , then AI = t iff (B [x ‚Üêi])I = t for some i ‚ààM. (The
last two occurrences of ‚Äú=‚Äù are metamathematical.)
‚ñ°
We have ‚Äúimported‚Äù constants from M into L in order to be able to state
the semantics of (‚àÉx)B above in the simple manner we just did (following
ShoenÔ¨Åeld (1967)).
We often state the semantics of (‚àÉx)B by writing
((‚àÉx)B [x])I is true
iff
(‚àÉi ‚ààM)(B [i])I is true
I.5.7 DeÔ¨Ånition. Let A ‚ààWff, and M be a structure as above.
An M-instance of A is an M-sentence A(i1,. . . , ik) (that is, all the free
variables of A have been replaced by imported constants).
We say that A is valid in M, or that M is a model of A, iff for all M-instances
A‚Ä≤ of A it is the case that A‚Ä≤I = t.‚Ä† Under these circumstances we write
|=M A.
For any set of formulas  from Wff, the expression |=M , pronounced ‚ÄúM
is a model of ‚Äù, means that for all A ‚àà, |=M A.
A formula A is universally valid or logically valid (we often say just valid)
iff every structure appropriate for the language is a model of A.
Under these circumstances we simply write |= A.
If  is a set of formulas, then we say it is satisÔ¨Åable iff it has a model. It is
Ô¨Ånitely satisÔ¨Åable iff every Ô¨Ånite subset of  has a model.‚Ä°
‚ñ°
The deÔ¨Ånition of validity of A in a structure M corresponds with the normal
mathematical practice. It says that a formula is true (in a given ‚Äúcontext‚Äù M)
just in case it is so for all possible values of the free variables.
‚Ä† We henceforth discontinue our pedantic ‚Äú(The last occurrence of ‚Äú=‚Äù is metamathematical.)‚Äù.
‚Ä° These two concepts are often deÔ¨Åned just for sentences.

56
I. Basic Logic
I.5.8 DeÔ¨Ånition. We say that  logically implies A, in symbols  |= A,
meaning that every model of  is also a model of A.
‚ñ°
I.5.9 DeÔ¨Ånition (Soundness). A theory (identiÔ¨Åed by its nonlogical axioms)
 is sound iff, for all A ‚ààWff,  ‚ä¢A implies  |= A, that is, iff all the
theorems of the theory are logically implied by the nonlogical axioms.
‚ñ°
Clearly then, a pure theory T is sound iff ‚ä¢T A implies |= A for all A ‚ààWff.
That is, all its theorems are universally valid.
Towards the soundness result‚Ä† below we look at two tedious (but easy)
lemmata.
I.5.10 Lemma. Given a term t, variables x Ã∏‚â°y, where y does not occur in t,
and a constant a. Then, for any term s and formula A, s[x ‚Üêt][y ‚Üêa] ‚â°
s[y ‚Üêa][x ‚Üêt] and A[x ‚Üêt][y ‚Üêa] ‚â°A[y ‚Üêa][x ‚Üêt].
Proof. Induction on s:
Basis:
s[x ‚Üêt][y ‚Üêa] ‚â°
Ô£±
Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£≥
if s ‚â°x
then t
if s ‚â°y
then a
if s ‚â°z
where x Ã∏‚â°z Ã∏‚â°y, then z
if s ‚â°b
then b
‚â°s[y ‚Üêa][x ‚Üêt]
For the induction step let s ‚â°f r1 . . .rn, where f has arity n. Then
s[x ‚Üêt][y ‚Üêa] ‚â°f r1[x ‚Üêt][y ‚Üêa] . . .rn[x ‚Üêt][y ‚Üêa]
‚â°f r1[y ‚Üêa][x ‚Üêt] . . .rn[y ‚Üêa][x ‚Üêt]
by I.H.
‚â°s[y ‚Üêa][x ‚Üêt]
Induction on A:
Basis:
A[x ‚Üêt][y ‚Üêa]
‚â°
Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
if A
‚â°Pr1 . . .rn then
Pr1[x ‚Üêt][y ‚Üêa] . . .rn[x ‚Üêt][y ‚Üêa]
‚â°Pr1[y ‚Üêa][x ‚Üêt] . . .rn[y ‚Üêa][x ‚Üêt]
if A
‚â°r = s then
r[x ‚Üêt][y ‚Üêa] = s[x ‚Üêt][y ‚Üêa]
‚â°r[y ‚Üêa][x ‚Üêt] = s[y ‚Üêa][x ‚Üêt]
‚â°A[y ‚Üêa][x ‚Üêt]
‚Ä† Also nicknamed ‚Äúthe easy half of G¬®odel‚Äôs completeness theorem‚Äù.

I.5. Semantics; Soundness, Completeness, Compactness
57
The property we are proving, trivially, propagates with Boolean connectives.
Let us do the induction step just in the case where A ‚â°(‚àÉw)B . If w ‚â°x or
w ‚â°y, then the result is trivial. Otherwise,
A[x ‚Üêt][y ‚Üêa] ‚â°((‚àÉw)B )[x ‚Üêt][y ‚Üêa]
‚â°((‚àÉw)B [x ‚Üêt][y ‚Üêa])
‚â°((‚àÉw)B [y ‚Üêa][x ‚Üêt])
by I.H.
‚â°((‚àÉw)B )[y ‚Üêa][x ‚Üêt]
‚â°A[y ‚Üêa][x ‚Üêt]
‚ñ°
I.5.11 Lemma. Given a structure M = (M, I ), a term s, and a formula A,
both over L(M). Suppose each of s and A have at most one free variable, x.
Let t be a closed term over L(M) such that tI = i ‚ààM. Then (s[x ‚Üê
t])I = (s[x ‚Üêi])I and (A[x ‚Üêt])I = (A[x ‚Üêi])I . Of course, since t is
closed, A[x ‚Üêt] is deÔ¨Åned.
Proof. Induction on s:
Basis. s[x ‚Üêt] ‚â°s if s ‚àà{y, a, j} (y Ã∏‚â°x). Hence (s[x ‚Üêt])I = sI =
(s[x ‚Üêi])I in this case. If s ‚â°x, then s[x ‚Üêt] ‚â°t and s[x ‚Üêi] ‚â°i, and
the claim follows once more.
For the induction step let s ‚â°f r1 . . .rn, where f has arity n. Then
(s[x ‚Üêt])I = f I ((r1[x ‚Üêt])I ,. . . , (rn[x ‚Üêt])I )
= f I ((r1[x ‚Üêi])I ,. . . , (rn[x ‚Üêi])I )
by I.H.
= (s[x ‚Üêi])I
Induction on A:
Basis. If A ‚â°Pr1 . . .rn, then‚Ä†
(A[x ‚Üêt])I = PI ((r1[x ‚Üêt])I ,. . . , (rn[x ‚Üêt])I )
= PI ((r1[x ‚Üêi])I ,. . . , (rn[x ‚Üêi])I )
= (A[x ‚Üêi])I
Similarly if A ‚â°r = s.
The property we are proving, clearly, propagates with Boolean connectives.
Let us do the induction step just in the case where A = (‚àÉw)B . If w ‚â°x, the
result is trivial. Otherwise, we note that ‚Äì since t is closed ‚Äì w does not occur
‚Ä† For a metamathematical relation Q, as is usual (p. 19), Q(a, b, . . . ) = t, or just Q(a, b, . . . ),
stands for ‚ü®a, b, . . . ‚ü©‚ààQ.

58
I. Basic Logic
in t, and proceed as follows:
(A[x ‚Üêt])I = t iff (((‚àÉw)B )[x ‚Üêt])I = t
iff (((‚àÉw)B [x ‚Üêt]))I = t
iff (B [x ‚Üêt][w ‚Üêj])I = t for some j ‚ààM, by I.5.6(4)
iff (B [w ‚Üêj][x ‚Üêt])I = t for some j ‚ààM, by I.5.10
iff ((B [w ‚Üêj])[x ‚Üêt])I = t for some j ‚ààM
iff ((B [w ‚Üêj])[x ‚Üêi])I = t for some j ‚ààM, by I.H.
iff (B [w ‚Üêj][x ‚Üêi])I = t for some j ‚ààM
iff (B [x ‚Üêi][w ‚Üêj])I = t for some j ‚ààM, by I.5.10
iff (((‚àÉw)B [x ‚Üêi]))I = t by I.5.6(4)
iff (((‚àÉw)B )[x ‚Üêi])I = t
iff (A[x ‚Üêi])I = t
‚ñ°
I.5.12 Metatheorem (Soundness). Any Ô¨Årst order theory (identiÔ¨Åed by its non-
logical axioms) , over some language L, is sound.
Proof. By induction on -theorems, A, we prove that  |= A. That is, we Ô¨Åx
a structure for L, say M, and assume that |=M . We then proceed to show that
|=M A.
Basis. A is a nonlogical axiom. Then our conclusion is part of the assump-
tion, by I.5.7.
Or A is a logical axiom. There are a number of cases:
Case 1. |=Taut A. We Ô¨Åx an M-instance of A, say A‚Ä≤, and show that
A‚Ä≤I = t. Let p1,. . . , pn be all the propositional variables (alias prime
formulas) occurring in A‚Ä≤. DeÔ¨Åne a valuation v by setting v(pi) = pI
i
for i = 1,. . . , n. Clearly, t = ¬Øv(A‚Ä≤) = A‚Ä≤I (the Ô¨Årst ‚Äú=‚Äù because
|=Taut A‚Ä≤, the second because after prime formulas were taken care of,
all that remains to be done for the evaluation of A‚Ä≤I is to apply Boolean
connectives ‚Äì see I.5.6(3)).
Pause. Why is |=Taut A‚Ä≤?
Case 2. A ‚â°B [t] ‚Üí(‚àÉx)B . Again, we look at an M-instance B ‚Ä≤[t‚Ä≤] ‚Üí
(‚àÉx)B ‚Ä≤. We want (B ‚Ä≤[t‚Ä≤] ‚Üí(‚àÉx)B ‚Ä≤)I = t, but suppose instead that
(B ‚Ä≤[t‚Ä≤])I = t
(1)
and
((‚àÉx)B ‚Ä≤)I = f
(2)
Let t‚Ä≤I = i (i ‚ààM). By I.5.11 and (1), (B ‚Ä≤[i])I = t. By I.5.6(4),
((‚àÉx)B ‚Ä≤)I = t, contradicting (2).

I.5. Semantics; Soundness, Completeness, Compactness
59
Case 3. A ‚â°x = x. Then an arbitrary M-instance is i = i for some i ‚ààM.
By I.5.6(1), (i = i)I = t.
Case 4. A ‚â°t = s ‚Üí(B [t] ‚ÜîB [s]). Once more, we take an arbitrary
M-instance, t‚Ä≤ = s‚Ä≤ ‚Üí(B ‚Ä≤[t‚Ä≤] ‚ÜîB ‚Ä≤[s‚Ä≤]). Suppose that (t‚Ä≤ = s‚Ä≤)I = t.
That is, t‚Ä≤I = s‚Ä≤I = (let us say) i (in M). But then
(B ‚Ä≤[t‚Ä≤])I = (B ‚Ä≤[i])I
by I.5.11
= (B ‚Ä≤[s‚Ä≤])I
by I.5.11
Hence (B [t] ‚ÜîB [s])I = t.
For the induction step we have two cases:
Modus ponens. Let B and B ‚ÜíA be -theorems. Fix an M-instance
B ‚Ä≤ ‚ÜíA‚Ä≤. Since B ‚Ä≤, B ‚Ä≤ ‚ÜíA‚Ä≤ |=Taut A‚Ä≤, the argument here is entirely
analogous to the case A ‚àà (hence we omit it).
‚àÉ-introduction. Let A ‚â°(‚àÉx)B ‚ÜíC and  ‚ä¢B ‚ÜíC , where x is not
free in C . By the I.H.
|=M B ‚ÜíC
(3)
Let (‚àÉx)B ‚Ä≤ ‚ÜíC ‚Ä≤ be an M-instance such that (despite expectations)
((‚àÉx)B ‚Ä≤)I = t but
C ‚Ä≤I = f
(4)
Thus
B ‚Ä≤[i]
I = t
(5)
for some i ‚ààM. Since x is not free in C , B ‚Ä≤[i] ‚ÜíC ‚Ä≤ is a false (by (4) and (5))
M-instance of B ‚ÜíC , contradicting (3).
‚ñ°
We used the condition of ‚àÉ-introduction above, by saying ‚ÄúSince x is not free
in C , B ‚Ä≤[i] ‚ÜíC ‚Ä≤ is a(n) . . . M-instance of B ‚ÜíC ‚Äù.
So the condition was useful. But is it essential? Yes, since, for example, if
x Ã∏‚â°y, then x = y ‚Üíx = y Ã∏|= (‚àÉx)x = y ‚Üíx = y.
As a corollary of soundness we have the consistency of pure theories:
I.5.13 Corollary. Any Ô¨Årst order pure theory is consistent.
Proof. Let T be a pure theory over some language L. Since Ã∏|= ¬¨x = x, it
follows that Ã∏‚ä¢T ¬¨x = x, thus T Ã∏= Wff.
‚ñ°

60
I. Basic Logic
I.5.14 Corollary. Any Ô¨Årst order theory that has a model is consistent.
Proof. Let T be a Ô¨Årst theory over some language L, and M a model of T.
Since Ã∏|=M ¬¨x = x, it follows that Ã∏‚ä¢T ¬¨x = x, thus T Ã∏= Wff.
‚ñ°
First order deÔ¨Ånability in a structure: We are now in a position to make the
process of translation to and from informal mathematics rigorous.
I.5.15 DeÔ¨Ånition. Let L be a Ô¨Årst order language, and M a structure for L. A
set (synonymously, relation) S ‚äÜMn is (Ô¨Årst order) deÔ¨Ånable in M over L
iff for some formula S (y1,. . . , yn) (see p. 18 for a reminder on round-bracket
notation) and for all i j, j = 1,. . . , n, in M,
‚ü®i1,. . . , in‚ü©‚ààS
iff
|=M S (i1,. . . , in)
We often just say ‚ÄúdeÔ¨Ånable in M‚Äù.
A function f : Mn ‚ÜíM is deÔ¨Ånable in M over L iff the relation y =
f (x1,. . . , xn) is so deÔ¨Ånable.
‚ñ°
N.B. Some authors say ‚Äú(Ô¨Årst order) expressible‚Äù (Smullyan (1992)) rather
than ‚Äú(Ô¨Årst order) deÔ¨Ånable‚Äù in a structure.
In the context of (M), the above deÔ¨Ånition gives precision to statements such
as ‚Äúwe code (or translate) an informal statement into the formal language‚Äù or
‚Äúthe (formal language) formula A informally ‚Äòsays‚Äô . . . ‚Äù, since any (informal)
‚Äústatement‚Äù (or relation) that depends on the informal variables x1,. . . , xn has
the form ‚Äú‚ü®x1,. . . , xn‚ü©‚ààS‚Äù for some (informal) set S. It also captures the
essence of the statement.
‚ÄúThe (informal) statement ‚ü®x1,. . . , xn‚ü©‚ààS can be written (or made) in the
formal language.‚Äù
What ‚Äúmakes‚Äù the statement, in the formal language, is the formula S
that Ô¨Årst order deÔ¨Ånes it.
I.5.16 Example. The informal statement ‚Äúz is a prime‚Äù has a formal translation
S0 < z ‚àß(‚àÄx)(‚àÄy)(z = x √ó y ‚Üíx = z ‚à®x = S0)
over the language of elementary number theory, where the nonlogical symbols
are 0, S, +, √ó, < and the deÔ¨Ånition (translation) is effected in the standard
structure N = (N; 0; S, +, √ó; <), where ‚ÄúS‚Äù satisÔ¨Åes, for all n ‚ààN, S(n) =
n + 1 and interprets ‚ÄúS‚Äù (see I.5.2, p. 53, for the ‚Äúunpacked‚Äù notation we have
just used to denote the structure N). We have used the variable name ‚Äúz‚Äù both
formally and informally.
‚ñ°

I.5. Semantics; Soundness, Completeness, Compactness
61
It must be said that translation is not just an art or skill. There are theoretical
limitations to translation. The trivial limitation is that if M is an inÔ¨Ånite set and,
say, L has a Ô¨Ånite set of nonlogical symbols (as is the case in number theory
and set theory), then we cannot deÔ¨Åne all S ‚äÜM, simply because we do not
have enough Ô¨Årst order formulas to do so.
There are non-trivial limitations too. Some sets are not Ô¨Årst order deÔ¨Ånable
because they are ‚Äúfar too complex‚Äù. See Section I.9.
This is a good place to introduce a common notational argot that allows us to
write ‚Äúmixed-mode‚Äù formulas that have a formal part (over some language L)
but may contain ‚Äúinformal‚Äù constants (names of, to be sure, but names that have
not formally been imported into L) from some structure M appropriate for L.
I.5.17 Informal DeÔ¨Ånition. Let L be a Ô¨Årst order language and M = (M, I ) a
structure for L. Let A be a formula with at most x1,. . . , xn free, and i1,. . . , in
members of M. The notation A [[i1,. . . , in]] is an abbreviation of (A[i1,. . . ,
in])I .
‚ñ°
This argot allows one to substitute informal objects into variables outright,
by-passing the procedure of importing formal names for such objects into the
language. It is noteworthy that mixed mode formulas can be deÔ¨Åned directly by
induction on formulas ‚Äì that is, without forming L(M) Ô¨Årst ‚Äì as follows:
Let L and M be as above. Let x1,. . . , xn contain all the free variables that
appear in a term t or formula A over L (not over L(M)!). Let i1,. . . , in be
arbitrary in M.
For terms we deÔ¨Åne
t[[i1, . . . in]] =
Ô£±
Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£≥
i j
if t ‚â°xj (1 ‚â§j ‚â§n)
aI
if t ‚â°a
f I (t1[[i1,. . . , in]],. . . ,
tr[[i1,. . . , in]])
if t ‚â°f t1 . . . tr
For formulas we let
A[[i1, . . . in]] =
Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
t[[i1, . . . in]] = s[[i1, . . . in]]
if A ‚â°t = s
PI (t1[[i1,. . . , in]],. . . ,
tr[[i1,. . . , in]])
if A ‚â°Pt1 . . . tr
¬¨(B [[i1, . . . in]])
if A ‚â°¬¨B
(B [[i1, . . . in]] ‚à®C [[i1, . . . in]])
if A ‚â°B ‚à®C
(‚àÉa ‚ààM)B [[a, i1, . . . in]]
if A ‚â°(‚àÉz)B [z, ‚Éóxn]

62
I. Basic Logic
where ‚Äò(‚àÉa ‚ààM) . . . ‚Äù is short for ‚Äú(‚àÉa)(a ‚ààM ‚àß. . . )‚Äù. The right hand side
has no free (informal) variables; thus it evaluates to one of t or f.
We now turn to the ‚Äúhard half‚Äù of G¬®odel‚Äôs completeness theorem, that our
syntactic proof apparatus can faithfully mimic ‚Äúproofs by logical implication‚Äù.
That is, the syntactic apparatus is ‚Äúcomplete‚Äù.
I.5.18 DeÔ¨Ånition. A theory over L (designated by its nonlogical axioms)  is
semantically complete iff  |= A implies  ‚ä¢A for any formula A.
‚ñ°
The term ‚Äúsemantically complete‚Äù is not being used much. There is a competing
syntactic notion of completeness, that of simple completeness, also called just
completeness. The latter is the notion one has normally in mind when saying
‚Äú. . . a complete theory . . . ‚Äù. More on this shortly.
We show the semantic completeness of every Ô¨Årst order theory by proving,
using the technique of Henkin (1952), the consistency theorem below. The
completeness theorem will then be derived as a corollary.
I.5.19 Metatheorem (Consistency Theorem). If a (Ô¨Årst order) theory T is
consistent, then it has a model.
We will Ô¨Årst give a proof (via a sequence of lemmata) for the case of ‚Äúcount-
able languages‚Äù L, that is, languages that have a countable alphabet. We will
then amend the proof to include the uncountable case.
A crash course on countable sets: A set A is countable‚Ä† if it is empty or (in
the opposite case) if there is a way to arrange all its members in an inÔ¨Ånite
sequence, in a ‚Äúrow of locations‚Äù, utilizing one location for each member of N.
It is allowed to repeatedly list any element of A, so that Ô¨Ånite sets are countable.
Technically, this enumeration is a (total) function f : N ‚ÜíA whose range
(set of outputs) equals A (that is, f is onto). We say that f (n) is the nth element
of A in the enumeration f . We often write fn instead of f (n) and then call n a
‚Äúsubscript‚Äù or ‚Äúindex‚Äù.
We can convert a multi-row enumeration
( fi, j)i, j in N
‚Ä† Na¬®ƒ±vely speaking. The deÔ¨Ånition is similar to the formal one that is given in volume 2. Here we
are just offering a quick-review service ‚Äì in the metamathematical domain, just in case the reader
needs it ‚Äì in preparation for the proof of the consistency theorem.

I.5. Semantics; Soundness, Completeness, Compactness
63
into a single row enumeration quite easily. Technically, we say that the set N √ó
N ‚Äì the set of ‚Äúdouble subscripts‚Äù (i, j) ‚Äì is countable. This is shown diagram-
matically below. The ‚Äúlinearization‚Äù or ‚Äúunfolding‚Äù of the inÔ¨Ånite matrix of
rows is effected by walking along the arrows:
(0, 0)
(0, 1)
(0, 2)
(0, 3)
. . .
‚Üó
‚Üó
‚Üó
(1, 0)
(1, 1)
(1, 2)
‚Üó
‚Üó
(2, 0)
(2, 1)
‚Üó
(3, 0)
...
This observation yields a very useful fact regarding strings over countable sets
(alphabets): If V
is countable, then the set of all strings of length 2 over V
is also countable. Why? Because the arbitrary string of length 2 is of the form
did j where di and d j represent the ith and j elements of the enumeration of V
respectively. Unfolding the inÔ¨Ånite matrix exactly as above, we get a single-row
enumeration of these strings.
By induction on the length n ‚â•2 of strings we see that the set of strings
of any length n ‚â•2 is also countable. Indeed, a string of length n + 1 is a
string ab, where a has length n and b ‚ààV . By the I.H. the set of all a‚Äôs can be
arranged in a single row (countable), and we are done exactly as in the case of
the did j above.
Finally, let us collect all the strings over V
into a set S. Is S countable? Yes.
We can arrange S, at Ô¨Årst, into an inÔ¨Ånite matrix of strings mi, j, that is, the jth
string of length i. Then we employ our matrix-unfolding trick above.
Suppose now that we start with a countable set A. Is every subset of A
countable? Yes. If B ‚äÜA, then the elements of B form a subsequence of the
elements of A (in any given enumeration). Therefore, just drop the members of
A that are not in B, and compact the subscripts.‚Ä†
To prove the consistency theorem let us Ô¨Åx a countable language L and a
Ô¨Årst order theory T over L with nonlogical axioms . In the search for a model,
‚Ä† By ‚Äúcompact the subscripts‚Äù we mean this: After dropping members of A that do not be-
long to B, the enumeration has gaps in general. For example, B might be the subsequence
a13, a95, a96, a97, a1001, . . . . We just shift the members of B to the left, eliminating gaps, so
that the above few listed members take the locations (subscripts), 0, 1, 2, 3, 4, . . . , respectively.
Admittedly, this explanation is not precise, but it will have to do for now.

64
I. Basic Logic
we start with a simple countable set, here we will take N itself, and endow it
with enough structure (the I -part) to obtain a model, M = (M, I ) of T.
Since, in particular, this will entail that a subset of N (called M in what
follows) will be the domain of the structure, we start by importing all the
constants n ‚ààN into L. That is, we add to V
a new constant symbol n for
each n ‚ààN. The new alphabet is denoted by V (N), and the resulting language
L(N).
I.5.20 DeÔ¨Ånition. In general, let L = (V , Term, Wff) be a Ô¨Årst order lan-
guage and M some set. We add to V
a new constant symbol i for each
i ‚ààM. The new alphabet is denoted by V (M), and the new language by
L(M) = (V (M), Term(M), Wff(M)).
This concept originated with Henkin and Abraham Robinson. The aug-
mented language L(M) is called the diagram language of M.
‚ñ°
The above deÔ¨Ånition generalizes DeÔ¨Ånition I.5.4 and is useful when (as
happens in our current context) we have a language L and a set (here N), but
not, as yet, a structure for L with domain N (or some subset thereof).
Of course, if M = (M, I ), then L(M) = L(M).
Two observations are immediate: One,  has not been affected by the addi-
tion of the new constants, and, two, L(N) is still countable.‚Ä† Thus, there are
enumerations
F 0, F 1, F 2, . . . of all sentences in Wff(N)
(1)
and
G 1, G 2, G 3, . . . of all sentences in Wff(N) of the form (‚àÉx)A
(2)
where, in (2), every sentence (‚àÉx)A of Wff(N) is listed inÔ¨Ånitely often.
Pause. How can we do this? Form an inÔ¨Ånite matrix, each row of which is the
same Ô¨Åxed enumeration of the (‚àÉx)A sentences. Then unfold the matrix into a
single row.
With the preliminaries out of the way, we next deÔ¨Åne by induction (or re-
cursion) over N an inÔ¨Ånite sequence of theories, successively adding sentences
over L(N) as new nonlogical axioms: We set 0 = . For any n ‚â•0, we deÔ¨Åne
‚Ä† If A and B are countable, then so is A ‚à™B, since we can arrange the union as an inÔ¨Ånite matrix,
the 0th row being occupied by A-members while all the other rows being identical to some Ô¨Åxed
enumeration of B.

I.5. Semantics; Soundness, Completeness, Compactness
65
n+1 in two stages: We Ô¨Årst let
n =
n ‚à™{F n}
if n Ã∏‚ä¢¬¨F n
n
otherwise
(3)
Then, we set
n+1 =
n ‚à™{A[x‚Üêi]}
if n ‚ä¢G n+1, where G n+1 ‚â°(‚àÉx)A
n
otherwise
The choice of i is important: It is the smallest i such that the constant i does
not occur (as a substring) in any of the sentences
F 0,. . . , F n, G 1,. . . , G n+1
(4)
The sentence A[x‚Üêi] added to n+1 is called a special Henkin axiom.‚Ä† The
constant i is the associated Henkin (also called witnessing) constant.
We now set
‚àû=

n‚ààN
n
(5)
This is a set of formulas over Wff(N) that deÔ¨Ånes a theory T‚àûover Wff(N) (as
the set of nonlogical axioms of T‚àû).
I.5.21 Lemma. The theory T‚àûis consistent.
Proof. It sufÔ¨Åces to show that each of the theories n is consistent.
(Indeed, if ‚ä¢T‚àû¬¨x = x,‚Ä° then A1,. . . , Am ‚ä¢¬¨x = x, for some Ai(i =
1,. . . , m) in ‚àû, since proofs have Ô¨Ånite length. Let n include all of
A1,. . . , Am.
Pause. Is there such a n?
Then n will be inconsistent.)
On to the main task. We know (assumption) that 0 is consistent. We take
the I.H. that n is consistent, and consider n+1 next.
First, we argue that n is consistent. If n = n, then we are done by the
I.H. If n = n ‚à™{F n}, then inconsistency would entail (by I.4.21)  ‚ä¢¬¨F n,
contradicting the hypothesis of the case we are at (top case of (3) above).
‚Ä† Another possible choice for Henkin axiom is (‚àÉx)A ‚ÜíA[x‚Üêi].
‚Ä° ¬¨x = x is our favourite ‚Äúcontradiction builder‚Äù. See also I.4.22.

66
I. Basic Logic
Next, we show that n ‚à™{A[x‚Üêi]} is consistent, where A[x‚Üêi] is the
added Henkin axiom ‚Äì if indeed such an axiom was added.
Suppose instead that n ‚à™{A[x‚Üêi]} ‚ä¢¬¨z = z, for some variable z. Now
i does not occur in any formulas in the set n ‚à™{(‚àÉx)A, ¬¨z = z}.
Since (‚àÉx)A ‚â°G n+1 and n ‚ä¢G n+1, we get n ‚ä¢¬¨z = z by I.4.27
(auxiliary constant metatheorem). This is no good, since n is supposed to be
consistent.
‚ñ°
I.5.22 DeÔ¨Ånition. A theory T over L decides a sentence A iff one of ‚ä¢T A
or ‚ä¢T ¬¨A holds. We say that A is decidable by T. In the case that ‚ä¢T ¬¨A
holds, we say that T refutes A. T is simply complete, or just complete, iff every
sentence is decidable by T.
‚ñ°
The deÔ¨Ånition is often offered in terms of consistent theories, since an incon-
sistent theory decides every formula anyway.
I.5.23 Lemma. T‚àûis simply complete.
Proof. LetAbeasentence.ThenA ‚â°F n forsomen.Ifn ‚ä¢¬¨F n, then we are
done. If however n does not refute F n, then we are done by (3) (p. 65).
‚ñ°
I.5.24 Lemma. T‚àûhas the witness property,‚Ä† namely, whenever ‚ä¢T‚àû(‚àÉx)A,
where (‚àÉx)A is a sentence over L(N), then for some m ‚ààN we have ‚ä¢T‚àû
A[x ‚Üêm].
Proof. Since the proof ‚ä¢T‚àû(‚àÉx)A involves Ô¨Ånitely many formulas from ‚àû,
there is an n ‚â•0 such that n ‚ä¢(‚àÉx)A. Now, (‚àÉx)A ‚â°G k+1 for some
k ‚â•n, since (‚àÉx)A occurs in the sequence (2) (p. 64) inÔ¨Ånitely often. But then
k ‚ä¢(‚àÉx)A as well.
Pause. Why?
Hence, A[x ‚Üêm] is added to k+1 as a Henkin axiom, for an appropriate
Henkin constant m, and we are done.
‚ñ°
I.5.25 DeÔ¨Ånition. We next deÔ¨Åne a relation, ‚àº, on N by
n ‚àºm
iff
‚ä¢T‚àûn = m
(6)
‚ñ°
‚Ä† We also say that it is a Henkin theory.

I.5. Semantics; Soundness, Completeness, Compactness
67
‚àºhas the following properties:
(a) ReÔ¨Çexivity. n ‚àºn (all n): By ‚ä¢x = x and I.4.12.
(b) Symmetry. If n ‚àºm, then m ‚àºn (all m, n): It follows from ‚ä¢x = y ‚Üí
y = x (Exercise I.16) and I.4.12.
(c) Transitivity. If n ‚àºm and m ‚àºk, then n ‚àºk (all m, n, k): It follows from
‚ä¢x = y ‚Üíy = z ‚Üíx = z (Exercise I.17) and I.4.12.
Let us deÔ¨Åne a function f : N ‚ÜíN by
f (n) = smallest m such that m ‚àºn
(7)
By (a) above, f is totally deÔ¨Åned. We also deÔ¨Åne a subset M of N, by
M = { f (n) : n ‚ààN}
(8)
This M will be the domain of a structure that we will build, and show that it is
a model of the original T.
First, we modify ‚àû‚Äúdownwards‚Äù.
I.5.26 DeÔ¨Ånition. The M-restriction of a formula A is the formula AM ob-
tained from A by replacing by f (n) every occurrence of an n in A.
‚ñ°
We now let
M
‚àû= {AM : A ‚àà‚àû}
(9)
We have the following results regarding M
‚àû(or the associated theory TM
‚àû):
I.5.27 Remark. Before proceeding, we note that the language of TM
‚àûis L(M),
and that A ‚â°AM if A is over L(M), since f (m) = m for m ‚ààM (why?). ‚ñ°
I.5.28 Lemma. Let A be over L(N). If ‚ä¢T‚àûA, then ‚ä¢TM
‚àûAM.
Proof. Induction on T‚àû-theorems.
Basis. If A ‚àà‚àû, then AM ‚ààM
‚àûby (9). If A ‚àà, then AM ‚àà (why?)
Modus ponens. Let ‚àû‚ä¢B and ‚àû‚ä¢B ‚ÜíA. By the I.H., M
‚àû‚ä¢B M
and M
‚àû‚ä¢B M ‚ÜíAM, and we are done.
‚àÉ-introduction. Let ‚àû‚ä¢B ‚ÜíC , where x is not free in C
and
A ‚â°(‚àÉx)B ‚ÜíC . By the I.H., M
‚àû‚ä¢B M ‚ÜíC M, and we are done by
‚àÉ-introduction.
‚ñ°

68
I. Basic Logic
I.5.29 Lemma. TM
‚àû‚â§T‚àû, conservatively.
Proof. Leaving the ‚Äúconservatively‚Äù part aside for a moment, let us verify that
for any A over L(N)
‚àû‚ä¢AM ‚ÜîA
(‚àó)
This follows from ‚àû‚ä¢n = f (n) (recall that n ‚àºf (n) by deÔ¨Ånition of f ) for
all n ‚ààN, and Exercise I.18.
Because of (‚àó), ‚àûcan prove any B ‚ààM
‚àû. Indeed, let B ‚â°AM for some
A ‚àà‚àû(by (9)). By (‚àó) and ‚àû‚ä¢A, we obtain ‚àû‚ä¢B .
Thus, TM
‚àû‚â§T‚àû.
Pause. Do you believe this conclusion?
Turning to the ‚Äúconservatively‚Äù part, this follows from Lemma I.5.28 and
Remark I.5.27.
‚ñ°
I.5.30 Corollary. TM
‚àûis consistent.
Proof. If it can prove ¬¨x = x, then so can T‚àû.
‚ñ°
I.5.31 Lemma. TM
‚àûis simply complete.
Proof. Let the sentence A be over L(M). It is decidable by T‚àû(I.5.23).
By I.5.28, TM
‚àûdecides AM. But that‚Äôs A.
‚ñ°
I.5.32 Lemma. TM
‚àûis a Henkin theory over L(M).
Proof. Let M
‚àû‚ä¢(‚àÉx)A, where (‚àÉx)A is a sentence. Then ‚àû‚ä¢(‚àÉx)A as
well, hence ‚àû‚ä¢A[x‚Üên], for some n ‚ààN (by I.5.24).
It follows that M
‚àû‚ä¢AM[x‚Üêf (n)], and we are done, since A ‚â°AM and
f (n) ‚ààM.
‚ñ°
I.5.33 Lemma. TM
‚àûdistinguishes the constants of M, that is, if n Ã∏= m (both
in M), then ‚ä¢TM
‚àû¬¨n = m.
Proof. By I.5.31, if ‚ä¢TM
‚àû¬¨n = m fails, then ‚ä¢TM
‚àûn = m; hence n ‚àºm. By
the deÔ¨Ånition of f (n) and M (p. 67), it follows that n = m (since each set
{m ‚ààN : m ‚àºn} determined by n can have exactly one smallest element, and
any two distinct such sets ‚Äì determined by n and k ‚Äì have no common elements
(why?)). This contradicts the assumption that n Ã∏= m.
‚ñ°

I.5. Semantics; Soundness, Completeness, Compactness
69
We have started with a consistent theory T over L. We now have a consistent,
complete, Henkin extension TM
‚àûof T, over the language L(M) (M ‚äÜN), which
distinguishes the constants of M.
We are now ready to deÔ¨Åne our model M = (M, I ). We are pleased to note
that the constants of M are already imported into the language, as required by
DeÔ¨Ånitions I.5.5 and I.5.6.
For any predicate‚Ä† P of L of arity k, we deÔ¨Åne for arbitrary n1,. . . , nk in M
PI (n1,. . . , nk) = t
iff
M
‚àû‚ä¢Pn1,. . . , nk
(A)
that is, we are deÔ¨Åning the set of k-tuples (relation) PI by
PI =

‚ü®n1,. . . , nk‚ü©: M
‚àû‚ä¢Pn1,. . . , nk

(A‚Ä≤)
Let next f be a function letter of arity k, and let n1,. . . , nk be an input for f I .
What is the appropriate output?‚Ä°
Well, Ô¨Årst observe that M
‚àû‚ä¢(‚àÉx) f n1,. . . , nk = x (why?). By I.5.32, there
is an m ‚ààM such that
M
‚àû‚ä¢f n1,. . . , nk = m
(B)
We need this m to be unique. It is so, for if also M
‚àû‚ä¢f n1,. . . , nk = j, then
(Exercise I.17) M
‚àû‚ä¢m = j, and thus m = j (if m Ã∏= j, then also M
‚àû‚ä¢¬¨m =
j, by I.5.33 ‚Äì impossible, since M
‚àûis consistent).
For the input n1,. . . , nk we set
f I (n1,. . . , nk) = m
(B.1)
where m is uniquely determined by (B). This deÔ¨Ånes f I .
The case of constants is an interesting special case.¬ß As above, we let aI be
the unique m ‚ààM such that
M
‚àû‚ä¢a = m
(C)
The interesting, indeed crucial, observation (required by I.5.5) is that, for any
imported constant m, we have mI ‚â°m. Indeed, this follows from uniqueness
and the trivial fact M
‚àû‚ä¢m = m.
‚Ä† Recall that we have added no new predicates and no new functions in going from L to L(M).
We have just added constants.
‚Ä° We have yet to determine f I . Here we are just ‚Äúthinking out loud‚Äù towards suggesting a
good f I .
¬ß Actually, it is not a special case for us, since we did not allow 0-ary functions. But some au-
thors do.

70
I. Basic Logic
The following will be handy in the proof of the Main Lemma below:
M
‚àû‚ä¢t = tI
(D)
for any closed term t over L(M). We prove (D) by induction on terms t.
Basis. If t ‚â°a (a original or imported), then (C) reads M
‚àû‚ä¢a = aI .
Lett ‚â°f t1 . . . tk.ByI.5.5,tI = f I (tI
1 ,. . . , tI
k ).Setni = tI
i fori = 1,. . . , k.
Then tI = f I (n1,. . . , nk). By (B) and (B.1),
M
‚àû‚ä¢f n1,. . . , nk = f I (n1,. . . , nk)
By the I.H., M
‚àû‚ä¢ti = tI
i , in other words M
‚àû‚ä¢ti = ni, for i = 1,. . . , k. By
Ax4, we obtain (via Exercise I.19)
M
‚àû‚ä¢f t1,. . . , tk = f n1,. . . , nk
Thus (Exercise I.17),
M
‚àû‚ä¢f t1,. . . , tk = f I 
tI
1 ,. . . , tI
k

This concludes the proof of (D).
I.5.34 Main Lemma. For every sentence A over L(M), AI = t iff M
‚àû‚ä¢A.
Proof. This is proved by induction on formulas.
Basis. Case where A ‚â°Pt1 . . . tk: Let ni = tI
i
(i = 1,. . . , k). By (A)
above (p. 69), PI (n1,. . . , nk) = t iff M
‚àû‚ä¢Pn1 . . . nk iff M
‚àû‚ä¢Pt1 . . . tk ‚Äì
the second ‚Äúiff‚Äù by Ax4 (via Exercise I.19) and (D). We are done in this case,
since AI = PI (tI
1 . . . tI
k ).
Case where A ‚â°t = s: Let also n = tI and m = sI . Then AI = t iff
tI = sI iff n = m iff M
‚àû‚ä¢n = m (for the last ‚Äúiff‚Äù the if part follows by
consistency and I.5.33; the only-if part by Ax3 and I.4.12).
The induction steps. Let A ‚â°¬¨B . Then AI = t iff B I = f iff (I.H.)
M
‚àûÃ∏‚ä¢B iff (completeness I.5.31 (‚Üí) and consistency I.5.30 (‚Üê)) M
‚àû‚ä¢A.
Let A ‚â°B ‚à®C . Consider Ô¨Årst B I ‚à®C I = t. Say B I = t. By I.H.,
M
‚àû‚ä¢B ;henceM
‚àû‚ä¢B ‚à®C bytautologicalimplication.SimilarlyifC I = t.
Conversely, let M
‚àû‚ä¢B ‚à®C . Then one of M
‚àû‚ä¢B or M
‚àû‚ä¢C must be the
case: If neither holds, then M
‚àû‚ä¢¬¨B and M
‚àû‚ä¢¬¨C by completeness, hence
M
‚àûis inconsistent (why?).
The Ô¨Ånal case: A ‚â°(‚àÉx)B . Let ((‚àÉx)B )I = t. Then (B [x‚Üên])I = t
for some n ‚ààM. By I.H., M
‚àû‚ä¢B [x‚Üên]; hence M
‚àû‚ä¢(‚àÉx)B by Ax2 and
MP. Conversely, let M
‚àû‚ä¢(‚àÉx)B . By I.5.32, M
‚àû‚ä¢B [x‚Üên], where n is the
appropriate Henkin constant. By I.H., (B [x‚Üên])I = t; hence AI = t.
‚ñ°
Finally,

I.5. Semantics; Soundness, Completeness, Compactness
71
Proof (of the Consistency Theorem). Let A‚Ä≤ be an M-instance of a formula
A in .
Note that A is over L.
From  ‚äÜM
‚àûit follows that M
‚àû‚ä¢A, and hence M
‚àû‚ä¢A‚Ä≤, by I.4.12. By
the Main Lemma, A‚Ä≤I = t.
Thus, the reduct M‚Ä≤ = (M, I ‚ÜæL) is a model of .
‚ñ°
We had to move to the reduct M‚Ä≤ to be technically correct. While M ‚ÄúsatisÔ¨Åes‚Äù
, its I also acts on symbols not in L. The I of a structure appropriate for L
is only supposed to assign meaning to the symbols of L.
I.5.35 Corollary. A consistent theory over a countable language has a count-
able model.
I.5.36 Corollary (L¬®owenheim-Skolem Theorem). If a set of formulas  over
a countable language has a model, then it has a countable model.
Proof. If a model exists, then the theory  is consistent.
‚ñ°
I.5.37 Corollary (G¬®odel‚Äôs Completeness Theorem). In any countable Ô¨Årst
order language L,  |= A implies  ‚ä¢A.
Proof. Let B denote the universal closure of A. By Exercise I.43,  |= B .
Thus, +¬¨B has no models (why?). Therefore it is inconsistent. Thus,  ‚ä¢B
(by I.4.21), and hence (specialization),  ‚ä¢A.
‚ñ°
A way to rephrase completeness is that if  |= A, then also  |= A, where
 ‚äÜ is Ô¨Ånite. This follows by soundness, since  |= A entails  ‚ä¢A and
hence  ‚ä¢A, where  consists of just those formulas of  used in the proof
of A.
I.5.38 Corollary (Compactness Theorem). In any countable Ô¨Årst order lang-
uage L, a set of formulas  is satisÔ¨Åable iff it is Ô¨Ånitely satisÔ¨Åable.
Proof. Only-if part. This is trivial, for a model of  is a model of any Ô¨Ånite
subset.
If part. Suppose that  is unsatisÔ¨Åable (it has no models). Then it is in-
consistent by the consistency theorem. In particular,  ‚ä¢¬¨x = x. Since the
pure theory over L is consistent, a -proof of ¬¨x = x involves a nonempty
Ô¨Ånite sequence of nonlogical axioms (formulas of ), A1,. . . , An. That is,
A1,. . . , An ‚ä¢¬¨x = x; hence {A1,. . . , An} has no model (by soundness).
This contradicts the hypothesis.
‚ñ°

72
I. Basic Logic
Alternatively, we can prove the above by invoking ‚Äúsyntactic compactness‚Äù: A
set of formulas is consistent iff every Ô¨Ånite subset is consistent, since proofs
have Ô¨Ånite length. Now invoke the consistency theorem and I.5.14.
We conclude this section by outlining the amendments to our proof that will
remove the restriction that L is countable. This plan of amendments presupposes
some knowledge‚Ä† of ordinals and cardinality (cf. volume 2) beyond what our
‚Äúcrash course‚Äù has covered. The reader may accept the statements proved here
and skip the proofs with no loss of continuity. These statements, in particular
the G¬®odel-Mal‚Ä≤cev compactness theorem, are applied later on to founding non-
standard analysis (following A. Robinson).
Let L be (possibly) uncountable, in the sense that the cardinality k of V
is ‚â•œâ. The cardinality of the set of all strings over V
is also k (for a proof see
volume 2, Chapter VII). We now pick and Ô¨Åx for our discussion an arbitrary set
N of cardinality k.
I.5.39 Remark. An example of such a set is k itself, and can be taken as N.
However, we can proÔ¨Åt from greater generality: N can be any set of any type
of (real) objects that we choose with some purpose in mind, as long as its
cardinality is k.
‚ñ°
Therefore the elements of N can be arranged in a transÔ¨Ånite sequence (indexed
by all the ordinals Œ± < k)
n0, n1,. . . , nŒ±, . . .
We then form L(N) (to parallel L(N) of our previous construction) by adding
to V a distinct name nŒ± for each nŒ± ‚ààN. Thus, we have enumerations
F 0, F 1, F 2,. . . , F Œ±, . . . of all sentences in Wff(N)
(1‚Ä≤)
and
G 1, G 2, G 3,. . . , G Œ±, . . . of all sentences in Wff(N) of the form (‚àÉx)A (2‚Ä≤)
where, in (2‚Ä≤), every sentence (‚àÉx)A of Wff(N) is listed inÔ¨Ånitely often, and
the indices (subscripts) in both (1‚Ä≤) and (2‚Ä≤) run through all the ordinals Œ± < k
(omitting index 0 in the second listing).
We next proceed as expected: We deÔ¨Åne by induction (or recursion) over
the ordinals Œ± < k a transÔ¨Ånite sequence of theories (determined by  and
additional sentences over L(N) as nonlogical axioms‚Ä°):
‚Ä† On an informal level, of course. All this is going on in the metatheory, just like the countable
case.
‚Ä° Note that the formulas in  need not be closed.

I.5. Semantics; Soundness, Completeness, Compactness
73
We set 0 = . For any Œ± < k, we deÔ¨Åne Œ± to be 
Œ≤<Œ± Œ≤ just in case Œ±
is a limit ordinal. If Œ± = Œ≤ + 1 (a successor) then the deÔ¨Ånition is effected in
two stages: We Ô¨Årst let
Œ≤ =
Œ≤ ‚à™{F Œ≤}
if Œ≤ Ã∏‚ä¢¬¨F Œ≤
Œ≤
otherwise
(3‚Ä≤)
Then, we set Œ± = Œ≤ ‚à™{A[x ‚Üêi]} just in case Œ≤ ‚ä¢G Œ±, where G Œ± ‚â°
(‚àÉx)A.
The choice of i is important: i = nŒ± ‚ààN, where Œ± < k is the smallest index
such that the constant nŒ± does not occur (as a substring) in any of the sentences
F 0,. . . , F Œ≤, G 1,. . . , G Œ±
(4‚Ä≤)
The sentence A[x ‚Üêi] added to Œ± is called a special Henkin axiom. The
constant i is the associated Henkin or witnessing constant.
We now set
k =

Œ±<k
Œ±
(5‚Ä≤)
This is a set of formulas over Wff(N) that deÔ¨Ånes a theory Tk over Wff(N) (as
the set of nonlogical axioms of Tk). We next deÔ¨Åne ‚àº, on N this time, as before
((6) on p. 66):
n ‚àºm
iff
‚ä¢Tk n = m
We note its properties, and proceed to deÔ¨Åne a subset M of N as in (7) and (8)
(p. 67).
Since M ‚äÜN, its cardinality is ‚â§k. After deÔ¨Åning the M-restriction of
a formula A as before, all the rest proceeds as in Lemmata I.5.28‚ÄìI.5.33,
replacing throughout T‚àû, TM
‚àû, and members i ‚ààN by Tk, TM
k , and members
i ‚ààN respectively. We are then able to state:
I.5.40 Metatheorem (Consistency Theorem). If a (Ô¨Årst order) theory T over
a language L of cardinality k is consistent, then it has a model of cardinal-
ity ‚â§k.
Terminology: The cardinality of a model is that of its domain.
I.5.41 Corollary (Completeness Theorem). In any Ô¨Årst order language L,
 |= A implies  ‚ä¢A.

74
I. Basic Logic
I.5.42 Corollary (G¬®odel-Mal‚Ä≤cev Compactness Theorem). In any Ô¨Årst order
language L, a set of formulas  is satisÔ¨Åable iff it is Ô¨Ånitely satisÔ¨Åable.
The L¬®owenheim-Skolem theorem takes the following form:
I.5.43 Corollary (Upward L¬®owenheim-Skolem Theorem). If a set of for-
mulas  over a language L of cardinality k has an inÔ¨Ånite model, then it has a
model of any cardinality n such that k ‚â§n.
Proof. Let K = (K, I ) be an inÔ¨Ånite model of . Pick a set N of cardinality n,
and import its individuals c as new formal constants c into the language of .
The set  =  ‚à™{¬¨c = d : c Ã∏= d on N} is Ô¨Ånitely satisÔ¨Åable. This is because
every Ô¨Ånite subset of  involves only Ô¨Ånitely many of the sentences ¬¨c = d;
thus there is capacity in K (as it is inÔ¨Ånite) to extend I into I ‚Ä≤ (keeping K
the same, but deÔ¨Åning distinct cI ‚Ä≤, d
I ‚Ä≤
, etc.) to satisfy these sentences in an
expanded structure K‚Ä≤ = (K, I ‚Ä≤).
Hence  is consistent.
Following the construction given earlier, we take this N (and ) as our
starting point to build a simply complete, consistent extension Tn of , and a
model M for , with domain some subset M of N. The choice of M follows the
deÔ¨Ånition of ‚Äú‚àº‚Äù (see pp. 66 and 73). Under the present circumstances, ‚Äú‚àº‚Äù is
‚Äú=‚Äù on N, for ‚ä¢Tn c = d implies c = d on N (otherwise ¬¨c = d is an axiom ‚Äì
impossible, since Tn is consistent). Thus M = N; hence the cardinality of M
is n.
The reduct of M on L is what we want. Of course, its cardinality is still right
(M did not change).
‚ñ°
Good as the above proof may be, it relies on the particular proof of the
consistency theorem, and this is a drawback. Hence we offer another proof that
does not have this defect.
Proof. (Once more) We develop a different argument, starting from the point
where we concluded that  is consistent. Since the language of this theory has
cardinality ‚â§n,
Pause. Why?
we know by I.5.40 that
we have a model M = (M, I ) for  of cardinality ‚â§n
(‚àó‚àó)

I.6. Substructures, Diagrams, and Applications
75
DeÔ¨Åne now a function f : N ‚ÜíM by f (n) = nI . Since all n ‚ààN have
been imported into the language of , f is total. f is also 1-1: Indeed, if c Ã∏= d
on N, then ¬¨c = d is an axiom. Hence, (¬¨c = d)I = t. That is, f (c) Ã∏= f (d)
on M. But then (by results on cardinality in volume 2) the cardinality n of N
is ‚â§the cardinality of M. By yet another result about cardinality,‚Ä† (‚àó‚àó) and
what we have just concluded imply that N and M have the same cardinality.
At this point we take the reduct of M on L, exactly as in the previous
proof.
‚ñ°
The above proof required more set theory. But it was independent of any
knowledge of the proof of the consistency theorem.
I.5.44 Remark (about Truth). The completeness theorem shows that the syn-
tactic apparatus of a Ô¨Årst order (formal) logic totally captures the semantic
notion of truth, modulo the acceptance as true of any given assumptions .
This justiÔ¨Åes the habit of the mathematician (even the formalist: see Bourbaki
(1966b, p. 21)) of saying ‚Äì in the context of any given theory  ‚Äì ‚Äúit is true‚Äù
(meaning ‚Äúit is a -theorem‚Äù, or ‚Äúit is -proved‚Äù), ‚Äúit is false‚Äù (meaning ‚Äúthe
negation is a -theorem‚Äù), ‚Äúassume that A is true‚Äù (meaning ‚Äúadd the formula
A ‚Äì to  ‚Äì as a nonlogical axiom‚Äù), and ‚Äúassume that A is false‚Äù (meaning
‚Äúadd the formula ¬¨A ‚Äì to  ‚Äì as a nonlogical axiom‚Äù).
Thus, ‚Äúit is true‚Äù (in the context of a theory) means ‚Äúit is true in all its
models‚Äù, hence provable: a theorem. We will not use this particular argot.
There is yet another argot use of ‚Äúis true‚Äù (often said emphatically, ‚Äúis really
true‚Äù), meaning truth in some speciÔ¨Åc structure, the ‚Äúintended model‚Äù. Due to
G¬®odel‚Äôs Ô¨Årst incompleteness theorem (Section I.9) this truth does not coincide
with provability.
I.6. Substructures, Diagrams, and Applications
On p. 38 we saw one way of generating theories, as the sets of theorems, Thm,
proved from some set of (nonlogical) axioms, . Another way of generating
theories is by taking all the formulas that are valid in some class of structures.‚Ä°
‚Ä† That k ‚â§l ‚àßl ‚â§k ‚Üík = l for any cardinals k and l.
‚Ä° In axiomatic set theory (e.g., as this is developed in volume 2 of these lectures) the term ‚Äúclass‚Äù
means a ‚Äúcollection‚Äù that is not necessarily a set, by virtue of its enormous size. Examples of
such collections are that of all ordinal numbers, that of all cardinal numbers, that of all the objects
that set theory talks about, and many others. In the present case we allow for a huge collection of
structures ‚Äì for example, all structures ‚Äì hence we have used the term ‚Äúclass‚Äù, rather than ‚Äúset‚Äù,
deliberately.

76
I. Basic Logic
I.6.1 DeÔ¨Ånition. Let L be a Ô¨Årst order language and C a class of structures
appropriate for L. We deÔ¨Åne two symbols
T (C )
def
= {A : for all M ‚ààC , |=M A}
and
Th(C )
def
= {A : A is closed and, for all M ‚ààC , |=M A}
If C = {M} then we write T (M) and Th(M) rather than T ({M}) and Th({M}).
‚ñ°
For any class of structures, C , T (C ) is a theory in the sense of p. 38. This
follows from an easy veriÔ¨Åcation of
A ‚ààT (C )
iff
T (C ) ‚ä¢A
(1)
We verify the if direction of (1), the opposite one being trivial. To prove A ‚àà
T (C ) we let M ‚ààC and prove
|=M A
(2)
By soundness, it sufÔ¨Åces to prove |=M T (C ), i.e.,
|=M B
for all
B ‚ààT (C )
which holds by DeÔ¨Ånition I.6.1.
I.6.2 Example. For any structure M for a language L, T (M) is a complete
theory: We want, for any sentence A, T (M) ‚ä¢A or T (M) ‚ä¢¬¨A. By the
previous observation, this translates to A ‚ààT (M) or (¬¨A) ‚ààT (M). This
holds, by I.6.1.
‚ñ°
I.6.3 Example. Let K be the (enormous) class of all structures for some
language L. Then T (K ) is the set of all universally valid formulas over L. ‚ñ°
I.6.4 DeÔ¨Ånition. Suppose that M and K are two structures for a language L.
If it happens that T (M) = T (K), then we say that M and K are elementarily
equivalent and write M ‚â°K.
The context will fend off any mistaking of the symbol for elementary equi-
valence, ‚â°, for that for string equality (cf. I.1.4).
‚ñ°
I.6.5 Proposition.‚Ä† Let M and K be two structures for L. Then, M ‚â°K iff
Th(M) = Th(K).
‚Ä† Normally we use the word ‚ÄúProposition‚Äù for a theorem that we do not want to make a big fuss
about.

I.6. Substructures, Diagrams, and Applications
77
Proof. The only-if part is immediate from I.6.4. For the if part, let A be an
arbitrary formula of L. Let A‚Ä≤ be its universal closure (cf. I.4.11). Then |=M A
iff |=M A‚Ä≤ and |=K A iff |=K A‚Ä≤; thus |=M A iff |=K A (since |=M A‚Ä≤ iff
|=K A‚Ä≤).
‚ñ°
One way to obtain a structure K that is elementarily equivalent to a stru-
cture M is by a systematic renaming of all the members of the domain
of M.
In what follows, if M = (M, I ) is a structure, |M| is alternative notation for
its domain M. Moreover, the interpretation of a language item a, f , or P will
be denoted by an M superscript, e.g., aM, rather than with an I superscript,
as in aI . This alternative notation saves us from juggling far too many letters
if we are discussing several structures at once (M, N, M, N, I M, I N, etc.; see
also I.5.2, p. 53).
I.6.6 DeÔ¨Ånition (Embeddings, Isomorphisms, and Substructures). Let M
and K be structures for a language L, and œÜ : |M| ‚Üí|K| be a total (that is,
everywhere deÔ¨Åned on |M|) and 1-1‚Ä† function. œÜ is a structure embedding ‚Äì in
which case we write œÜ : M ‚ÜíK ‚Äì just in case œÜ preserves all the nonlogical
interpretations. This means the following:
(1) aK = œÜ(aM) for all constants a of L
(2) f K(œÜ(i1),. . . , œÜ(in)) = œÜ( f M(i1,. . . , in)) for all n-ary functions f of L
and all i j ‚àà|M|
(3) PK(œÜ(i1),. . . , œÜ(in)) = PM(i1,. . . , in) for all n-ary predicates P of L and
all i j ‚àà|M|
In the last two cases ‚Äú=‚Äù is metamathematical, comparing members of |K| in
the former and members of the truth set, {t, f}, in the latter.
An important special case occurs when œÜ : |M| ‚Üí|K| is the inclusion map,
that is, œÜ(i) = i for all i ‚àà|M| ‚Äì which entails |M| ‚äÜ|K|. We then say
that M is a substructure of K and write M ‚äÜK (note the absence of | . . . |).
Symmetrically, we say that K is an extension of M.
If œÜ is onto as well ‚Äì that is, (‚àÄb ‚àà|K|)(‚àÉa ‚àà|M|)œÜ(a) = b ‚Äì then we say
that it is a structure isomorphism, in symbols M ‚àº=
œÜ K, or just M ‚àº= K.
It will be convenient to use the following abbreviation (ShoenÔ¨Åeld (1967)):
iœÜ is short for œÜ(i) for all i ‚àà|M|.
‚ñ°
‚Ä† That is, œÜ(a) = œÜ(b) implies a = b for all a and b in |M|.

78
I. Basic Logic
There is no special signiÔ¨Åcance in using the letter œÜ for the embedding or
isomorphism, other than its being a symbol other than what we normally use
(generically) for formal function symbols ( f, g, h).
One way to visualize what is going on in DeÔ¨Ånition I.6.6 is to employ a so-called
commutative diagram (for simplicity, for a unary f )
|M| ‚àãi
f M
‚àí‚Üíf M(i) ‚àà|M|
|
|
œÜ‚Üì
‚ÜìœÜ
|K| ‚àãiœÜ
f K
‚àí‚Üíf K(iœÜ) ‚àà|K|
That the diagram commutes means that all possible compositions give the same
result. Here œÜ( f M(i)) = f K(œÜ(i)).
When M ‚äÜK and œÜ is the inclusion map, then the diagram above simply
says that f M is the restriction of f K on |M|, in symbols, f M = f K ‚Üæ|M|.
Condition (3) in DeÔ¨Ånition I.6.6 simply says that PM is the restriction of PK
on |M|n, i.e., PM = PK ‚à©|M|n. One often indicates this last equality by
PM = PK | |M|.
I.6.7 Remark. Sometimes we have a structure M = (M, I ) for L and a
1-1 correspondence (total, 1-1, and onto) œÜ : M ‚ÜíK for some set K. We
can turn K into a structure for L, isomorphic to M, by deÔ¨Åning its ‚ÄúI ‚Äù-part
mimicking DeÔ¨Ånition I.6.6. We say that œÜ induces an isomorphism M ‚àº=
œÜ K.
We do this as follows:
(i) We set aK = œÜ(aM) for all constants a of L
(ii) We set f K(‚Éóin) = œÜ( f M(œÜ‚àí1(i1),. . . , œÜ‚àí1(in))) for all n-ary function sym-
bols f of L and all i j in K.‚Ä†
(iii) We set PK(‚Éóin) = PM(œÜ‚àí1(i1),. . . , œÜ‚àí1(in)) for all n-ary predicate sym-
bols P of L and all i j in K.
It is now trivial to check via I.6.6 that for the K so deÔ¨Åned above, M ‚àº=
œÜ K
(Exercise I.47).
‚ñ°
The following shows that an embedding (and a fortiori an isomorphism)
preserves meaning beyond that of the nonlogical symbols.
‚Ä† By œÜ‚àí1(a), for a ‚ààK, we mean the unique b ‚ààM such that œÜ(b) = a.

I.6. Substructures, Diagrams, and Applications
79
I.6.8 Theorem. Let œÜ : M ‚ÜíK be an embedding of structures of a language
L. Then:
(1) For every term t of L whose variables are among ‚Éóxn, and for all ‚Éóin in |M|,
one has t[[iœÜ
1 ,. . . , iœÜ
n ]] = œÜ(t[[‚Éóin]]).‚Ä†
(2) For every atomic formula A of L whose variables are among ‚Éóxn, and for
all ‚Éóin in |M|, one has |=M A[[‚Éóin]] iff |=K A[[iœÜ
1 ,. . . , iœÜ
n ]].
(3) If œÜ is an isomorphism, then we can remove the restriction atomic from (2)
above.
Strictly speaking, we are supposed to apply ‚Äú|=‚Äù to a (formal) formula (cf. I.5.7).
‚ÄúA[[‚Éóin]]‚Äù is an abbreviated notation for a ‚Äúconcrete‚Äù (already interpreted) sen-
tence. However, it is useful to extend our argot to allow the notation ‚Äú|=M
A[[‚Éóin]]‚Äù ‚Äì which says ‚Äúthe concrete sentence A[[‚Éóin]] is true in M‚Äù, in short,
(A[i1,. . . , in])M = t (cf. I.5.17) ‚Äì as this notation readily discloses where A
was interpreted and therefore where it is claimed to be true.
Proof. (1): We do induction on terms t (cf. I.5.17). If t ‚â°a, a constant of L,
then the left hand side is aK while the right hand side is œÜ(aM). These (both in
|K|) are equal by I.6.6.
If t ‚â°x j (for some x j among the ‚Éóxn), then t[[iœÜ
1 ,. . . , iœÜ
n ]] = iœÜ
j ‚àà|K| while
t[[i1,. . . , in]] = i j ‚àà|M|. Thus (1) of the theorem statement is proved in this
case.
Finally, let t ‚â°f t1 . . . tr. Then
œÜ

( f t1 . . . tr)[[‚Éóin]]

= œÜ( f M(t1[[‚Éóin]],. . . , tr[[‚Éóin]])) (cf. I.5.17)
= f K(œÜ(t1[[‚Éóin]]),. . . , œÜ(tr[[‚Éóin]])) (by I.6.6)
= f K
t1

iœÜ
1 ,. . . , iœÜ
n

,. . . , tr

iœÜ
1 ,. . . , iœÜ
n

(by I.H.)
= ( f t1 . . . tr)

iœÜ
1 ,. . . , iœÜ
n

(by I.5.17)
(2): We have two cases:
Case where A ‚â°Pt1 . . . tr.
Then
|=M (Pt1 . . . tr)[[‚Éóin]]
iff |=M PM(t1[[‚Éóin]],. . . , tr[[‚Éóin]])
(by I.5.17)
iff |=K PK(œÜ(t1[[‚Éóin]]),. . . , œÜ(tr[[‚Éóin]]))
(by I.6.6)
iff |=K PK
t1

iœÜ
1 ,. . . , iœÜ
n

,. . . , tr

iœÜ
1 ,. . . , iœÜ
n

(by (1))
iff |=K (Pt1 . . . tr)

iœÜ
1 ,. . . , iœÜ
n

(by I.5.17)
‚Ä† Recall I.5.17. Of course, t[[‚Éóin]] ‚àà|M|, while t

iœÜ
1 ,. . . , iœÜ
n

‚àà|K|.

80
I. Basic Logic
Case where A ‚â°t = s.
Then
|=M (t = s)[[‚Éóin]] iff |=M t[[‚Éóin]] = s[[‚Éóin]]
(I.5.17)
iff |=K œÜ(t[[‚Éóin]]) = œÜ(s[[‚Éóin]])
(if by 1-1-ness)
iff |=K t

iœÜ
1 ,. . . , iœÜ
n

= s

iœÜ
1 ,. . . , iœÜ
n

(by (1))
iff |=K (t = s)

iœÜ
1 ,. . . , iœÜ
n

(by I.5.17)
(3): It is an easy exercise to see that if A and B have the property claimed,
then so do ¬¨A and A ‚à®B without the additional assumption of ontoness.
Ontoness helps (‚àÉx)A:
|=M ((‚àÉx)A)[[‚Éóin]]
iff (‚àÉa ‚àà|M|) |=M A[[a, ‚Éóin]]
(by I.5.17)
iff (‚àÉa ‚àà|M|) |=K A

aœÜ, iœÜ
1 ,. . . , iœÜ
n

(by I.H. on formulas)
iff (‚àÉb ‚àà|K|) |=K A

b, iœÜ
1 ,. . . , iœÜ
n

(if by ontoness)
iff |=K ((‚àÉx)A)

iœÜ
1 ,. . . , iœÜ
n

(by I.5.17)
‚ñ°
I.6.9 Corollary. If M and K are structures for L and M ‚äÜK, then for all
quantiÔ¨Åer-free formulas A whose variables are among ‚Éóxn, and for all ‚Éóin in
|M|, one has |=M A[[‚Éóin]] iff |=K A[[‚Éóin]].
I.6.10 Corollary. If M and K are structures for L and M ‚àº=
œÜ K, then M ‚â°K.
Proof. Let A(‚Éóxn) be a formula. The sought
|=M A(‚Éóxn)
iff
|=K A(‚Éóxn)
translates to
(‚àÄi1 ‚àà|M|) . . . (‚àÄin ‚àà|M|) |=M A[[‚Éóin]]
iff
(‚àÄj1 ‚àà|K|) . . . (‚àÄjn ‚àà|K|) |=K A[[‚Éójn]]
which is true,‚Ä† by (3) of I.6.8, since every j ‚àà|K| is an iœÜ (for some i ‚àà|M|).
‚ñ°
I.6.11 Corollary. Let M and K be structures for L, M ‚àº=
œÜ K, and T a theory
over L. Then |=M T iff |=K T.
Condition (2) in I.6.8 is quite strong, as the following shows.
‚Ä† Since we are arguing in the metatheory, we can say ‚Äútrue‚Äù rather than ‚Äúprovable‚Äù.

I.6. Substructures, Diagrams, and Applications
81
I.6.12 Theorem. Let M and K be structures for L, and œÜ : |M| ‚Üí|K| be a
total function. If for every atomic A that contains at most the variables ‚Éóxn and
for all ‚Éóin in |M| one has
|=M A[[‚Éóin]]
iff
|=K A

iœÜ
1 ,. . . , iœÜ
n

(1)
then œÜ : M ‚ÜíK is an embedding.
Proof. First off, œÜ is 1-1. Indeed, since x = y is atomic, then, by (1) above, for
all i and j in |M|, |=M i = j iff |=K iœÜ = jœÜ.‚Ä† The if direction gives 1-1-ness.
We now check the three conditions of DeÔ¨Ånition I.6.6.
Let next aM = i. Using the atomic formula a = x, we get (by (1))
|=M (a = x)[[i]]
iff
|=K (a = x)[[iœÜ]]
that is,
|=M aM = i
iff
|=K aK = iœÜ
Since aM = i is true, so is aK = iœÜ. That is, aK = œÜ(aM). (This part only
needed the only-if direction of (1).)
Let now f be n-ary. Consider the atomic formula f (‚Éóxn) = xn+1. By (1),
|=M ( f (‚Éóxn) = xn+1)[[‚Éóin+1]]
iff
|=K ( f (‚Éóxn) = xn+1)

iœÜ
1 ,. . . , iœÜ
n+1

That is,
|=M f M(‚Éóin) = in+1
iff
|=K f K
iœÜ
1 ,. . . , iœÜ
n

= iœÜ
n+1
Thus f K(iœÜ
1 ,. . . , iœÜ
n ) = œÜ( f M(‚Éóin)). (This part too only needed the only-if
direction of (1).)
Finally, let P be n-ary. By (1)
|=M P(‚Éóxn)[[‚Éóin]]
iff
|=K P(‚Éóxn)

iœÜ
1 ,. . . , iœÜ
n

That is,
|=M PM(‚Éóin)
iff
|=K PK
iœÜ
1 ,. . . , iœÜ
n

‚ñ°
I.6.13 Corollary. Let M and K be structures for L, and œÜ : |M| ‚Üí|K| be a
total function. If, for every atomic and negated atomic A that contains at most
the variables ‚Éóxn and for all ‚Éóin in |M| one has
|=M A[[‚Éóin]]
implies
|=K A

iœÜ
1 ,. . . , iœÜ
n

then œÜ : M ‚ÜíK is an embedding.
‚Ä† (x = y) [[i, j]] ‚â°i = j.

82
I. Basic Logic
Proof. Let |=K A[[iœÜ
1 ,. . . , iœÜ
n ]], A atomic. If Ã∏|=M A[[‚Éóin]], then |=M ¬¨A[[‚Éóin]].
¬¨A is negated atomic. Thus, |=K ¬¨A[[iœÜ
1 ,. . . , iœÜ
n ]], i.e., Ã∏|=K A[[iœÜ
1 ,. . . , iœÜ
n ]],
contradicting the assumption. The ‚Äúimplies‚Äù has now been promoted to ‚Äúiff‚Äù.
‚ñ°
I.6.14 Corollary. Let M and K be structures for L, and |M| ‚äÜ|K|. If, for
every atomic and negated atomic A that contains at most the variables ‚Éóxn and
for all ‚Éóin in |M| one has
|=M A[[‚Éóin]]
implies
|=K A[[‚Éóin]]
then M ‚äÜK.
Proof. |M| ‚äÜ|K| means that we may take here œÜ : |M| ‚Üí|K| to be the inclu-
sion map.
‚ñ°
The converses of the above two corollaries hold (these, essentially, are I.6.8
and I.6.9).
Moreover, these corollaries lead to
I.6.15 DeÔ¨Ånition (Elementary Embeddings and Substructures). Let M and
K be structures for L, and œÜ : |M| ‚Üí|K| a total function. If, for every formula
A that contains at most the variables ‚Éóxn and for all ‚Éóin in |M|, one has
|=M A[[‚Éóin]]
implies
|=K A

iœÜ
1 ,. . . , iœÜ
n

(1)
then œÜ : M ‚ÜíK is called an elementary embedding. We write œÜ : M ‚Üí‚â∫K
in this case.
If œÜ is the inclusion map |M| ‚äÜ|K|, then (1) becomes
|=M A[[‚Éóin]]
implies
|=K A[[‚Éóin]]
(2)
In this case we say that M is an elementary substructure of K, or that the latter
is an elementary extension of the former. In symbols, M ‚â∫K.
‚ñ°
I.6.16 Remark. The ‚Äúimplies‚Äù in (1) and (2) in the deÔ¨Ånition above is promoted
to ‚Äúiff‚Äù as in the proof of I.6.13.
By I.6.13 and I.6.14, an elementary embedding œÜ : M ‚Üí‚â∫K is also an
embedding œÜ : M ‚ÜíK, and an elementary substructure M ‚â∫K is also a
substructure M ‚äÜK.

I.6. Substructures, Diagrams, and Applications
83
If œÜ : M ‚Üí‚â∫K, then condition (1) in DeÔ¨Ånition I.6.15 (which, as we have
already noted, is an equivalence) yields, for all sentences A over L,
|=M A
iff
|=K A
By I.6.5, M ‚â°K. In particular, M ‚â∫K implies M ‚â°K.
‚ñ°
I.6.17Remark. Inmanyargumentsinmodeltheory,startingwithastructureM
for some language L, one constructs another structure K for L and an embedding
œÜ : M ‚ÜíK or an elementary embedding œÜ : M ‚Üí‚â∫K. More often than not
one would rather have a structure extension or an elementary extension of M
(i.e., preferring that œÜ be the inclusion map) respectively. This can be easily
obtained as follows:
Let M = (M, . . . ) and K = (K, . . . ). Let N be a set disjoint from M,‚Ä† of
cardinality equal to that of K ‚àíœÜ[M].‚Ä° Thus there is a 1-1 correspondence
œà : K ‚àíœÜ[M] ‚ÜíN, from which we can build a 1-1 correspondence œá : K ‚Üí
M ‚à™N by deÔ¨Åning
œá(x) =
œà(x)
if x ‚ààK ‚àíœÜ[M]
œÜ‚àí1(x)
if x ‚ààœÜ[M]
Using Remark I.6.7, we get a structure K‚Ä≤ = (M ‚à™N, . . . ) such that
K ‚àº=
œá K‚Ä≤
(1)
We verify that if we had œÜ : M ‚Üí‚â∫K initially, then we now have¬ß
œá ‚ó¶œÜ : M ‚Üí‚â∫K‚Ä≤
(2)
Well, let A be arbitrary over L with free variables among ‚Éóxn. Pick any ‚Éóin in M,
and assume |=M A[[‚Éóin]]. By hypothesis on œÜ and I.6.15, |=K A[[œÜ(i1),. . . ,
œÜ(in)]]. By I.6.8(3) and (1) above, |=K ‚Ä≤ A[[œá(œÜ(i1)),. . . , œá(œÜ(in))]]. This set-
tles (2), by I.6.15. By deÔ¨Ånition of œá above, if x ‚ààM, then, since œÜ(x) ‚ààœÜ[M],
we have œá(œÜ(x)) = œÜ‚àí1(œÜ(x)) = x. That is, (2) is an elementary extension
(œá ‚ó¶œÜ is the identity on M).
The alternative initial result, an embedding œÜ : M ‚ÜíK, yields a struc-
ture extension œá ‚ó¶œÜ : M ‚äÜK‚Ä≤, since the composition of embeddings is an
embedding (Exercise I.48).
‚ñ°
‚Ä† N ‚à©M = ‚àÖ.
‚Ä° œÜ[X] = {œÜ(x) : x ‚ààX}. X ‚àíY = {x ‚ààX : x /‚ààY}.
¬ß œá ‚ó¶œÜ denotes function composition. That is, (œá ‚ó¶œÜ) (x) = œá(œÜ(x)) for all x ‚ààM.

84
I. Basic Logic
The following criterion for elementary extensions evaluates truth in the big-
ger of the two structures. It is useful, among other places, in the proof of the
downward L¬®owenheim-Skolem theorem (I.6.20 below).
I.6.18 Proposition. Let M and K be structures for L. If M ‚äÜK, and moreover,
for every formula A whose free variables are among y and ‚Éóxn, and for all ‚Éóbn
in |M|,
(‚àÉa ‚àà|K|) |=K A[[a, ‚Éóbn]]
implies
(‚àÉa ‚àà|M|) |=K A[[a, ‚Éóbn]]
(3)
then M ‚â∫K.
Proof. We need to prove (2) of I.6.15 using (3) above.
We do induction on formulas. We have already remarked in I.6.16 that the
deÔ¨Ånition is an ‚Äúiff‚Äù, and it is more convenient to carry the induction through
with an ‚Äúiff‚Äù rather than an ‚Äúimplies‚Äù.
First off, by M ‚äÜK and Corollary I.6.9, we are done for all quantiÔ¨Åer-free
formulas. This takes care of atomic formulas.
For the induction step, from B and C to ¬¨B and B ‚à®C , we note (with ‚Éói
arbitrary, in |M|)
|=M ¬¨B [[‚Éói]] iff Ã∏|=M B [[‚Éói]]
iff Ã∏|=K B [[‚Éói]]
by I.H.
iff |=K ¬¨B [[‚Éói]]
Similarly,
|=M (B ‚à®C )[[‚Éói]] iff |=M B [[‚Éói]] or |=M C [[‚Éói]]
iff |=K B [[‚Éói]] or |=K C [[‚Éói]]
by I.H.
iff |=K (B ‚à®C )[[‚Éói]]
It only remains to check existential formulas. The implication
|=M ((‚àÉx)B )[[‚Éói]]
implies
|=K ((‚àÉx)B )[[‚Éói]]
that is,
(‚àÉa ‚àà|M|) |=M B [[a, ‚Éói]]
implies
(‚àÉa ‚àà|K|) |=K B [[a, ‚Éói]]
being trivial by |M| ‚äÜ|K|, we check the opposite direction. Let ‚Éói still be in
|M|, and (‚àÉa ‚àà|K|) |=K B [[a, ‚Éói]]. By (3), (‚àÉa ‚àà|M|) |=K B [[a, ‚Éói]]. By I.H.,
(‚àÉa ‚àà|M|) |=M B [[a, ‚Éói]].
‚ñ°

I.6. Substructures, Diagrams, and Applications
85
I.6.19 Example. The structure N‚Ä≤ = (N, <, 0) is a reduct of the standard model
of arithmetic. It is essentially a linearly ordered set, where we have also focused
on a ‚Äúdistinguished element‚Äù, 0, that also happens to be the minimum element of
the order. Any nonempty B ‚äÜN that contains 0 leads to a B = (B, <, 0) ‚äÜN‚Ä≤,
trivially.
If we ask for more, that B ‚â∫N‚Ä≤, then we reduce our choices (of B that
work) drastically. Indeed, let A(x, y) say that x and y are consecutive, x < y.
That is, A(x, y) is
x < y ‚àß¬¨(‚àÉz)(x < z ‚àßz < y)
Then
(‚àÄa ‚ààN) |=N‚Ä≤ ((‚àÉy)A(x, y))[[a]]
(1)
Thus, if B ‚â∫N‚Ä≤, then we require B ‚äÜN‚Ä≤ ‚Äì in particular, 0 ‚ààB ‚Äì and
(from (1), I.6.15 and I.6.16)
(‚àÄa ‚ààB)(‚àÉb ‚ààB) |=B A[[a, b]]
(2)
0 ‚ààB and (2) yield (by metamathematical induction) that B = N.
‚ñ°
The following is a useful tool in model theory.
I.6.20 Theorem (Downward L¬®owenheim-Skolem Theorem). Assume that L
has cardinality at most m (that is, the set of nonlogical symbols does‚Ä†), while
the structure M = (M, I ) (for L) has cardinality at least m. Let X ‚äÜM, and
the cardinality of X be ‚â§m. Then there is a structure K for L, of cardinality
exactly m, that satisÔ¨Åes X ‚äÜ|K| and K ‚â∫M.
This proof requires some facility with cardinal manipulation. In particular, we
use facts such as that, if m is an inÔ¨Ånite cardinal and n ‚ààN while ‚Ñµ0 is the
cardinality of N, then (n + 1) ¬∑ m = ‚Ñµ0 ¬∑ m = mn+1 = m, where ‚Äú¬∑‚Äù denotes
cardinal multiplication.
Proof. (Thinking out loud.) If K = (K, . . . ) ‚Äì still to be deÔ¨Åned ‚Äì is to satisfy
K ‚â∫M, then we have to ensure (I.6.18), among other things, that for every
A(y, ‚Éóxn) over L and for all ‚Éóan in K, if A[[b, ‚Éóan]] is true in M (where b ‚ààM),
then some b‚Ä≤ ‚ààK exists such that A[[b‚Ä≤, ‚Éóan]] is also true in M.
‚Ä† It is a set-theoretical fact that the union of a countable set and an inÔ¨Ånite set has cardinality equal
to that of the inÔ¨Ånite set, or ‚Ñµ0 + m = m. Recall that the set of logical symbols is countable.

86
I. Basic Logic
In short, we need to obtain K as a subset of M that includes X and is closed
under all the relations
QA = {‚ü®‚Éóan, b‚ü©: |=M (A(y, ‚Éóxn))[[b, ‚Éóan]]}
(1)
where b is the output part in QA above.
It is prudent to take two precautions:
First, in order to get the smallest cardinal possible for K, we build the ‚äÜ-
smallest set described in italics above, that is, we take K = Cl(X, R),‚Ä† where
R is the set of all the relations QA as A varies over all the formulas over L.
Second, in order to place a lower bound of m to the cardinality of K, we start,
rather than with X, with a set Y of cardinality exactly m such that X ‚äÜY ‚äÜM.
Such a Y exists by the size estimates for X and M. In other words, we have just
changed our mind, and now let K = Cl(Y, R).
Actually, a bit more prudence is in order. Let us rename the Cl(Y, R) above
K ‚Ä≤. We are still looking for a K that we will keep.
We will ‚Äúcut down‚Äù each QA in (1) ‚Äì with the help of the axiom of choice
(AC) ‚Äì making the relation single-valued‚Ä° in its output, b. (End of thinking out
loud.)
We deÔ¨Åne

QA = {‚ü®‚Éóan, b‚ü©: b picked by AC in {x : QA (‚Éóan, x)} if (‚àÉx ‚ààM)QA (‚Éóan, x)}
(2)
Let now 
R be the set of all 
QA , and set K = Cl(Y, 
R). This one we keep!
First off, trivially, K ‚äÜM. To turn K into a substructure of M, we have to
interpret every f, a, P ‚Äì function, constant and predicate, respectively ‚Äì of L
as f M ‚ÜæK n (n-ary case), leave as aM, and PM|K (n-ary case), respectively.
For functions and constants we have more work: For the former we need to
show that K is closed under all f M |`K n. Let then f be n-ary in L and ‚Éóan be in
K. Then f M(‚Éóan) = b and b ‚ààM. We want b ‚ààK.
Well, if we set A ‚â°f (‚Éóxn) = y, then |=M ( f (‚Éóxn) = y)[[‚Éóan, b]]; hence
QA (‚Éóan, b) is true (cf. (1)), and therefore 
QA (‚Éóan, b) is true, for b is unique,
given the ‚Éóan, so that it must be what AC picks in (2). Thus, since K is

QA-closed, b ‚ààK. Similarly one proves the case for constants a of L, us-
ing the formula a = y.
Thus we do have a substructure, K = (K, . . . ), of M.
It remains to settle the property of Proposition I.6.18 and the cardinality
claims.
‚Ä† You may want to review Section I.2 at this point.
‚Ä° A fancy term for ‚Äúfunction‚Äù. This function need not be deÔ¨Åned everywhere on M.

I.6. Substructures, Diagrams, and Applications
87
First off, let |=M A[[b, ‚Éóan]], where b ‚ààM, and the ‚Éóan are in K. For some
b‚Ä≤ picked by AC in (2), 
QA (‚Éóan, b‚Ä≤) is true, that is, |=M A[[b‚Ä≤, ‚Éóan]]. Since K is

QA-closed, b‚Ä≤ ‚ààK. Thus, the ‚â∫-criterion for K ‚â∫M is met.
Finally, we compute the cardinality of K. This inductively deÔ¨Åned set is
being built by stages (see I.2.9),
K =

i‚â•0
Ki
(3)
Atstage0wehave K0 = Y.Havingbuilt Ki, i ‚â§n,webuild Kn+1 byappending
to 
i‚â§n Ki all b such that 
QA (‚Éóar, b) holds. We do so for all 
QA (‚Éóxr, y) and
all possible ‚Éóar in 
i‚â§n Ki.
We show that the cardinality of each Kn is ‚â§m. This is true for K0. We take
an I.H. for all n ‚â§k and consider Kk+1 next.
Now, the set of formulas over L has cardinality ‚â§m; hence
the set 
R as well has cardinality ‚â§m
(4)
We let S = 
i‚â§k Ki for convenience. By I.H.,
(cardinality of S) ‚â§(k + 1) ¬∑ m = m
(5)
For each 
QA (‚Éóxr+1) ‚àà
R , the cardinality of the set of contributed outputs,
taking inputs in S, is at most equal to the cardinality of Sr, i.e., ‚â§mr = m. The
total contribution of all the 
QA is then, by (4), of cardinality ‚â§m ¬∑ m = m.
Thus, using (5), the cardinality of Kk+1 is ‚â§m + m = m. By (3), the cardinal
of K is ‚â§‚Ñµ0 ¬∑ m = m. Since it is also ‚â•m (by Y ‚äÜK), we are done.
‚ñ°
N.B. The set K ‚Ä≤ that we have discarded earlier also satisÔ¨Åes K‚Ä≤ = (K ‚Ä≤, . . . ) ‚â∫
M, and has cardinality at most that of M. We cannot expect though that it has
cardinality ‚â§m.
I.6.21 Corollary. Assume that L has cardinality at most m, while the structure
M = (M, I ) (for L) has cardinality at least m. Let X ‚â∫M, and the cardinality
of |X| be ‚â§m. Then there is a structure K for L, of cardinality exactly m that
satisÔ¨Åes X ‚â∫K ‚â∫M.
Proof. Working with X = |X| exactly as in I.6.20, we getK. It is straightforward
to check that X ‚äÜK.‚Ä† The ‚â∫-criterion (I.6.18) for X ‚â∫K is: Given A with free
‚Ä† For n-ary f in L, f X = f M‚ÜæXn by assumption. On the other hand, f K = f M‚ÜæK n by
construction of K. But X ‚äÜK.

88
I. Basic Logic
variables among the y and ‚Éóxn, and ‚Éóan in X. Verify that if
for some b ‚ààK,
|=K A[[b, ‚Éóan]]
(1)
then
|=K A[[b‚Ä≤, ‚Éóan]]
for some b‚Ä≤ ‚ààX
(2)
Well, K ‚äÜM and (1) yield |=M A[[b, ‚Éóan]]. (2) follows from X ‚â∫M.
‚ñ°
The following deÔ¨Ånition builds on I.5.4 and I.5.20.
I.6.22 DeÔ¨Ånition (Diagrams). Given a language L and a structure A for L. Let
‚àÖÃ∏= M ‚äÜ|A|. We call L(M), constructed as in I.5.20, the diagram language of
M. We denote by AM the expansion of A that has all else the same as A, except
that it gives the ‚Äúnatural meaning‚Äù to the new constants, i, of L(M). Namely,
i
AM= i for all i ‚ààM. AM is called the diagram expansion of A (over L(M)).
We often write AM = {|A|,. . . , (i)i‚ààM} to indicate that constants i with
interpretations i where added. The part ‚Äú{|A|, . . . }‚Äù is just A.
If M = |A|, then we write L(A) for L(M), as in I.5.4.
The basic diagram of A, denoted by D(A), is the set of all atomic and
negated atomic sentences of L(A) that are true in A|A|.
The elementary diagram of A is just Th(A|A|).
Suppose now that A and M are as above, B is a structure for L as well ‚Äì
possibly A = B ‚Äì and œÜ : M ‚Üí|B| is a total function. We may now wish to
import the constants i of M into L, as i, and expand B so that, for each i ‚ààM,
i is interpreted as œÜ(i). This expansion of B is denoted by BœÜ[M].‚Ä†
Thus, all else in BœÜ[M] is the same as in B, except that i
BœÜ[M] = œÜ(i).
We often write BœÜ[M] = {|B|,. . . , (œÜ(i))i‚ààM} to indicate that constants i
with interpretations œÜ(i) were added.
Therefore, if M ‚äÜ|B| and œÜ is the inclusion map, then BœÜ[M] is the expan-
sion of B, BM.
‚ñ°
The particular way that we have approached the assignment of semantics is not
the ‚Äúusual‚Äù one.‚Ä° One often sees a manner of handling substitution of informal
constants into formal variables that differs from that of I.5.4. Namely, other
authors often do this by assigning (or ‚Äúcorresponding‚Äù) values to variables,
rather than substituting (formal names of) values into variables. This is achieved
by a so-called assignment function, s, from the set of all variables {v0, v1, . . . }
‚Ä† In the choice of our notation we are following Keisler (1978).
‚Ä° It is the same as the one in ShoenÔ¨Åeld (1967).

I.6. Substructures, Diagrams, and Applications
89
to the domain, |A|, of the structure into which we want to interpret a language
L. Intuitively, s(v j) = a says that we have plugged the value a into v j.
While we have not favoured this approach, we will grant it one thing: It does
not compel us to extend the language L into the diagram language L(A) to
effect the interpretation. Such extensions may be slightly confusing when we
deal with diagrams.
For example, let L and A be as above, with ‚àÖÃ∏= M ‚äÜ|A|. We next form
L(M). Now, this language has new constants, i, for each i ‚ààM. Thus, when
we proceed to interpret it into AM, we already have formal counterparts of all
i ‚ààM in L(M), and we need only import the constants (as per I.5.4) of |A|‚àíM.
But is there any harm done if we re-import all i ‚àà|A|, asi, to form L(M)(A)?
Not really. Let us focus on an i ‚ààM which has been imported as i when forming
L(M) and then again asi to do what I.5.4 prescribes towards interpreting L(M)
in AM. Thus, i is a closed term t of L(M)(A) for which tAM = i. Sincei is the
imported name for i, Lemma I.5.11 yields that, for any term s and formula A
over L(M)(A) of at most one free variable x,
(s[x ‚Üêi])AM = (s[x ‚Üêi])AM
and
(A[x ‚Üêi])AM = (A[x ‚Üêi])AM
In short, meaning does not depend on which formal alias of i ‚ààM we use. We
will be free to assume then that thei were not new (for i ‚ààM); they were just
the i.
In particular, the statement ‚Äúthe sentence A over L(A) is true in A|A|‚Äù is
equivalent to the statement ‚Äúthe A-instance‚Ä† A of a formula over L is true
in A‚Äù, since a closed formula of L(A) is an A-instance of one over L and
conversely (i ‚â°i).
Diagrams offer more than one would expect from just nomenclature, as a
number of applications in the balance of this section will readily demonstrate.
First, we translate I.6.13, I.6.14, and I.6.15 into the diagram terminology.
I.6.23 Lemma (Main Diagram Lemma). Let M and K be two structures for
L, and œÜ : |M| ‚Üí|K| be a total function. Then
(1) œÜ : M ‚ÜíK (embedding) iff |=KœÜ[|M|] D(M);
(2) œÜ : M ‚Üí‚â∫K (elementary embedding) iff |=KœÜ[|M|] Th(M|M|).
Moreover, if |M| ‚äÜ|K|, then
‚Ä† Cf. I.5.7, p. 55.

90
I. Basic Logic
(3) M ‚äÜK (substructure) iff |=K|M| D(M);
(4) M ‚â∫K (elementary substructure) iff |=K|M| Th(M|M|).
Proof. Direct translation of the facts quoted prior to the lemma statement. For
example, the hypothesis of the if part in item (1) above is the same as the
displayed formula in the statement of I.6.13 if we recall that, e.g., an atomic
sentence over L(M) is an M-instance A(i1,. . . , in) of an atomic formula A
over L and that |=M A[[‚Éóin]] is argot for

A(i1,. . . , in)
M = t (cf. I.5.17).
The only-if part in (1)‚Äì(4) is due to the remark following I.6.14, p. 82.
‚ñ°
We present a number of applications of diagrams. First, we revisit the upward
L¬®owenheim-Skolem theorem (I.5.43).
I.6.24 Theorem (Upward L¬®owenheim-Skolem Theorem, Version 2). Let A
be an inÔ¨Ånite structure for L. For every cardinal n that is not smaller than
the cardinal of A (that is, of |A|) and of L, there is a structure B for L, of
cardinality exactly n, such that A ‚â∫B.
Proof. As in the proof of I.5.43, pick a set N of cardinality n. The set of
sentences over L(A)(N)
Q = Th(A|A|) ‚à™{¬¨c = d : c Ã∏= d on N}
where c are distinct new constants, one for each c ‚ààN, is Ô¨Ånitely satisÔ¨Åable.
This is because every Ô¨Ånite subset of Q involves only Ô¨Ånitely many of the
sentences ¬¨c = d, and thus there is capacity in A = (A, I ) (as A is inÔ¨Ånite)
to extend I into I ‚Ä≤ (keeping A the same, but deÔ¨Åning distinct cI ‚Ä≤, d
I ‚Ä≤
, etc.)
to satisfy these sentences in an expanded structure A‚Ä≤ = (A, I ‚Ä≤).
By compactness, there is a model D = (D, I D) for Q
(1)
We will look at Ô¨Årst into its reduct on L(A), C = (D, I C) ‚Äì that is, I C =
I D ‚ÜæL(A). C is a model of Th(A|A|).
We deÔ¨Åne next a function f : A ‚ÜíD by f (nI ) = nI C. The function f
is total because all n ‚ààA have been imported, as n, in the language L(A) of
Th(A|A|).
Thus, if C‚Ä≤ = (D, I C‚Ä≤) is the reduct of C on L ‚Äì that is, I C‚Ä≤ = I C ‚ÜæL ‚Äì then
the expansion C‚Ä≤
f [A] of C‚Ä≤ is just C, hence, |=C‚Ä≤
f [A] Th(AA). By the main diagram
lemma above,
f : A ‚Üí‚â∫C‚Ä≤
(2)

I.6. Substructures, Diagrams, and Applications
91
Without loss of generality, we may assume in (2) that A ‚äÜD (see Remark I.6.17)
and that f is the inclusion map (nI = nI C). That is,
A ‚â∫C‚Ä≤
Thus, it remains to settle the cardinality claims. First off, since c Ã∏= d in N
implies that ¬¨c = d is true in D by (1), it follows that the cardinality of D
is ‚â•n.‚Ä† That is, the cardinality of C‚Ä≤ (that is, of its domain D) is ‚â•n.
By the downward L¬®owenheim-Skolem theorem (in the form I.6.21) there is
a structure B of cardinality exactly n such that A ‚â∫B ‚â∫C‚Ä≤.
‚ñ°
Theorem I.6.24 provides different information than its counterpart, I.5.43. The
former ignores axioms and works with a language and its structures. In the pro-
cess it gives a strong type of extension between the given structure and the
constructed structure. The latter downplays structures and is about a language,
a set of axioms, and the size of the models that we can build for those axioms.
Version I.5.43 has the important consequence that theories over countable
languages that have any inÔ¨Ånite model at all ‚Äì such as ZFC ‚Äì must also have
modelsofanyinÔ¨Ånitecardinality.Inparticulartheymusthavecountablemodels.
We conclude the section with a further sampling of applications.
I.6.25 DeÔ¨Ånition. We call a theory T open iff it is the set of theorems of a set of
axioms  that consists entirely of open formulas, i.e., quantiÔ¨Åer-free formulas.
Such is, for example, group theory and ROB arithmetic (I.9.32). Such theories
are also called universal, since one can generate them with a different ‚Ä≤. The
latter‚Äôs formulas are all the universal closures of open formulas, those in .
‚ñ°
Thus, by the completeness theorem, a theory T is open iff there is a set of open
formulas, , such that T and  have the same models.
We have the following model-theoretic result for open theories:
I.6.26 Theorem (¬¥Lo¬¥s-Tarski). A theory T (in the sense of p. 38) is open iff
every substructure of every model of T is also a model.
Proof. Only-if part: Exercise I.53.
If part: All this is over some language L. Let  be the set of all open theorems
of T (over L).‚Ä° We need to show that T = Thm, or, for every structure M
‚Ä† The function N ‚àãn #‚Üí¬ØnI D ‚ààD is total and 1-1.
‚Ä° According to the deÔ¨Ånition of a theory on p. 38, in particular the displayed formula (1) there,
‚Äúopen theorems of T ‚Äù is synonymous with ‚Äúopen formulas in T ‚Äù.

92
I. Basic Logic
for L,
|=M 
implies
|=M T
(1)
To this end, we assume the hypothesis in (1) and consider D(M) ‚à™T . We
claim that this is a consistent set of formulas over L(M). Otherwise T ‚à™
{A1,. . . , An} ‚ä¢¬¨x = x, where A1,. . . , An is a Ô¨Ånite set of sentences of
D(M). By the deduction theorem
T ‚ä¢¬¨x = x ‚à®¬¨A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨An
Hence (tautological implication and logical axiom x = x)
T ‚ä¢¬¨A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨An
(2)
By the theorem on constants, (I.4.15) ‚Äì since T is over L ‚Äì (2) yields
T ‚ä¢¬¨A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨An
where ¬¨A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨An is obtained from ¬¨A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨An by replacing all
the imported constants i, j, . . . which appear in the latter formula by distinct
new variables. Thus, ¬¨A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨An is in  hence is valid in M. That is,
assuming the formula‚Äôs variables are among ‚Éóyr, for all ‚Éóar in |M|,
|=M (¬¨A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨An)[[‚Éóar]]
(3)
We can thus choose the ‚Éóar so that A j ‚â°(A j)[[‚Éóar]] for j = 1,. . . , n. Since
(3) entails that (A j)[[‚Éóar]] is false‚Ä† in M|M| for at least one j, this contradicts
that all the A j are in D(M).
Thus, by the consistency theorem, there is a model K for D(M) ‚à™T .
Without loss of generality (cf. Remark I.6.17), the mapping i
M #‚Üíi
K is the
identity. If we now call A the reduct of K on L, then the expansion A|M| of A
is K; therefore |=A|M| D(M). The diagram lemma implies that M ‚äÜA. Since
A is a model of T , then so is M by hypothesis. This settles (1).
‚ñ°
I.6.27 Example. Group theory is usually formulated in a language that employs
the nonlogical symbols ‚Äú‚ó¶‚Äù (binary function), ‚Äú‚àí1‚Äù (unary function) and ‚Äú1‚Äù
(constant). Its axioms are open, the following:
(1) x ‚ó¶(y ‚ó¶z) = (x ‚ó¶y) ‚ó¶z‚Ä°;
(2) x ‚ó¶1 = 1 ‚ó¶x = x (using ‚Äú=‚Äù conjunctionally);
(3) x ‚ó¶x‚àí1 = x‚àí1 ‚ó¶x = 1.
‚Ä† Cf. discussion on p. 89.
‚Ä° Where we are using the habitual inÔ¨Åx notation, ‚Äúx ‚ó¶y‚Äù, rather than ‚ó¶xy or ‚ó¶(x, y).

I.6. Substructures, Diagrams, and Applications
93
The models of the above axioms are called groups. Over this language, every
substructure of a group, that is, every subset that includes (the interpretation
of) 1 and is closed under ‚ó¶and ‚àí1, is itself a group, as the only-if direction of
the above theorem guarantees.
It is possible to formulate group theory in a language that has only ‚Äú‚ó¶‚Äù and
‚Äú1‚Äù as nonlogical symbols. Its axioms are not open:
(i) x ‚ó¶(y ‚ó¶z) = (x ‚ó¶y) ‚ó¶z;
(ii) x ‚ó¶1 = 1 ‚ó¶x = x;
(iii) (‚àÉy)x ‚ó¶y = 1;
(iv) (‚àÉy)y ‚ó¶x = 1.
Since the ¬¥Lo¬¥s-Tarski theorem is an ‚Äúiff‚Äù theorem, it must be that group theory
so formulated has models (still called groups) that have substructures that are
not groups (they are semigroups with unit, however).
‚ñ°
I.6.28 DeÔ¨Ånition. Constructions in model theory often result in increasing
sequences of structures, either of the type
M0 ‚äÜM1 ‚äÜM2 ‚äÜ¬∑ ¬∑ ¬∑
(1)
or of the type
M0 ‚â∫M1 ‚â∫M2 ‚â∫¬∑ ¬∑ ¬∑
(2)
Sequences of type (1) are called increasing chains or ascending chains of
structures. Those of type (2) are called elementary chains.
‚ñ°
Chains are related to theories that can be axiomatized using exclusively exis-
tential axioms, that is, axioms of the form (‚àÉx1) . . . (‚àÉxn)A, for n ‚â•0,‚Ä† where
A is open. Such theories are called inductive. By taking the universal closures
of existential axioms we obtain formulas of the form (‚àÄy1) . . . (‚àÄym)(‚àÉx1) . . .
(‚àÉxn)A. For this reason, inductive theories are also called ‚àÄ‚àÉ-theories.
The following result is easy to prove, and is left as an exercise.
I.6.29 Theorem (Tarski‚Äôs Lemma). The union M of an elementary chain (2)
above is an elementary extension of every Mi.
‚Ä† n = 0 means that the preÔ¨Åx (‚àÉx1) . . . (‚àÉxn) is missing. Thus an open formula is a special case
of an existential one. As a matter of fact, we can force a nonempty existential preÔ¨Åx on an open
formula: If z does not occur in A, then we can be prove A ‚Üî(‚àÉz)A without nonlogical axioms.

94
I. Basic Logic
Proof. First off, a chain of type (2) is also of type (1); thus, Mi ‚äÜMi+1 for all
i ‚â•0. Let M and Mi denote the universes of M and Mi respectively. Then by
‚Äúunion of the Mi‚Äù we understand that we have taken M = 
i‚â•0 Mi and
(i) PM = 
i‚â•0 PMi, for each predicate P,
(ii) f M = 
i‚â•0 f Mi for each function f (note that f Mi ‚äÜf Mi+1 for all
i ‚â•0), and
(iii) aM = aM0, for each constant.
The real work is delegated to Exercise I.54.
‚ñ°
I.6.30 Theorem (Chang-¬¥Lo¬¥s-Suszko). The union of every type-(1) chain
(I.6.28) of models of a theory T (the latter in the sense of p. 38) is a model of
T iff the theory is inductive.
Proof. The proof is standard (e.g., Chang and Keisler (1973), Keisler (1978),
ShoenÔ¨Åed (1967)).
If part: Delegated to Exercise I.55.
Only-if part: Assume the hypothesis for a theory T over L. We will prove
that it is inductive. To this end, let  by the set of all existential consequences
of T ‚Äì i.e., formulas (‚àÉx1) . . . (‚àÉxn)A ‚Äì n ‚â•0 ‚Äì with A open. As in the proof
of I.6.26, we endeavour to prove
|=M 
implies
|=M T
(1)
Assume the hypothesis in (1), and let D‚àÄ(M) denote the set of all universal
sentences‚Ä† over L(M) that are true in MM, where we have written M for |M|.
We argue that D‚àÄ(M) ‚à™T
is consistent. If not, T
‚ä¢¬¨x = x ‚à®¬¨
A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨An, for some Ai ‚ààD‚àÄ(M); hence (notation as in the proof
of I.6.26)
T ‚ä¢¬¨(A1 ‚àß¬∑ ¬∑ ¬∑ ‚àßAn)
Since ‚ä¢A ‚Üî(‚àÄz)A if z is not free in A, and ‚àÄdistributes over ‚àß(see
Exercise I.23), we can rewrite the above as
T ‚ä¢¬¨(‚àÄ‚Éóxr)(B 1 ‚àß¬∑ ¬∑ ¬∑ ‚àßB n)
(2)
where the B i are open over L, and (‚àÄ‚Éóxr) is short for (‚àÄx1) . . . (‚àÄxr). The formula
in (2) is (logically equivalent to one that is) existential. Thus, it is in , and
hence is true in M, an impossibility, since no Ai ‚ààD‚àÄ(M) can be false in MM.
‚Ä† A universal formula has the form (‚àÄx1) . . . (‚àÄxn)A, n ‚â•0, where A is open. Thus (n = 0) every
open formula is also universal, as well as existential.

I.6. Substructures, Diagrams, and Applications
95
We can now have a model, K‚Ä≤ = (K,. . . , (a)a‚ààM), of D‚àÄ(M) ‚à™T , where
‚Äú(a)a‚ààM‚Äù indicates the special status of the constants a ‚ààM ‚äÜK: These have
been added to L, as a, to form L(M). If K = (K, . . . ) is the reduct of K‚Ä≤ to L,
then K‚Ä≤ = KM; hence
|=KM D‚àÄ(M)
(3)
Since D(M) ‚äÜD‚àÄ(M), we obtain
M ‚äÜK
(I.6.23),
and
|=K T
(T is over L)
(4)
Remark I.6.17 was invoked without notice in assuming that the a of L(M) are
interpreted in K‚Ä≤ exactly as in MM: as a.
We next argue that the theory S = D(K) ‚à™Th(MM) over‚Ä† L(K) is consis-
tent, where D(K) is as in I.6.22, i.e.,the set of all atomic and negated atomic
sentences over L(K) that are true in KK = (K,. . . , (a)a‚ààM, (a)a‚ààK‚àíM). Note
that L(K) is obtained by adding to L(M) the constants (a)a‚ààK‚àíM, each a in-
terpreted as a in KK. That is, a ‚ààM were not re-imported as something other
than the original a of L(M).
Now, if S is not consistent, then some Ai ‚ààD(K) (i = 1,. . . , n) jointly
with Th(MM) prove ¬¨x = x. Since the Ai are sentences (over L(K)), the
usual technique yields
Th(MM) ‚ä¢¬¨A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨An
Let ¬¨A‚Ä≤
1 ‚à®¬∑ ¬∑ ¬∑‚à®¬¨A‚Ä≤
n be obtained from ¬¨A1 ‚à®¬∑ ¬∑ ¬∑‚à®¬¨An by replacing all its
constants a, b, . . . ‚Äì where a, b, . . . are in K ‚àíM ‚Äì by distinct new variables
‚Éóxr. Thus (I.4.15)
Th(MM) ‚ä¢(‚àÄ‚Éóxr)(¬¨A‚Ä≤
1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨A‚Ä≤
n)
(5)
Since (‚àÄ‚Éóxr)(¬¨A‚Ä≤
1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨A‚Ä≤
n) is a sentence over L(M), (5) implies that it is
in Th(MM), i.e., true in MM. Thus, being universal, it is in D‚àÄ(M). By (3) it is
true in KM. In particular, its KM-instance (cf. I.5.7) ¬¨A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®¬¨ An ‚Äì a
sentence of L(K) ‚Äì is true in KM in the sense of I.5.7, and hence also in KK.
This is impossible, since Ai ‚ààD(K) implies that no sentence Ai can be false
in KK.
Thus, there is a model A = (A, . . . ) of S over L(K). Now, on one hand we
have
|=A D(K)
(6)
‚Ä† The part Th(MM) is over L(M), of course.

96
I. Basic Logic
and we may assume, without loss of generality (cf. I.6.17), that
for a ‚ààK,
aK #‚ÜíaA is the inclusion map
(7)
Therefore, K ‚äÜA, and we may write A a bit more explicitly as
A = (A,. . . , (a)a‚ààM, (a)a‚ààK‚àíM)
(8)
Let us call M‚Ä≤ = (A, . . . ) the reduct of A on L. By (8), A = M‚Ä≤K, so that
(6) reads |=M‚Ä≤ K D(K); hence (by I.6.23)
K ‚äÜM‚Ä≤
(9)
On the other hand, every sentence of Th(MM) ‚Äì a subtheory of S ‚Äì is true in
A. The relevant part of A is its reduct on L(M), namely, M‚Ä≤M. Thus, |=M ‚Ä≤
M
Th(MM), and therefore
M ‚â∫M‚Ä≤
(10)
After all this work we concentrate on the core of what we have obtained: (4),
(9), and (10). By (10) and remarks in I.6.16 we have that |=M ‚Ä≤ . Thus we can
repeat our construction all over again, using M‚Ä≤ in the place of M, to obtain
K‚Ä≤ ‚äáM‚Ä≤ with |=K‚Ä≤ T , and also a M‚Ä≤‚Ä≤ that is an elementary extension of M‚Ä≤.
In short, we can build, by induction on n, an alternating chain
M0 ‚äÜK0 ‚äÜM1 ‚äÜK1 ‚äÜ¬∑ ¬∑ ¬∑
(11)
such that
M0 ‚â∫M1 ‚â∫¬∑ ¬∑ ¬∑
(12)
and
|=Kn T
for
n ‚â•0
(13)
where M0 = M, and, for n ‚â•0, Kn and Mn+1 are obtained as ‚ÄúK‚Äù and ‚ÄúM‚Ä≤‚Äù
respectively from Mn, the latter posing as the ‚ÄúM‚Äù in the above construction.
By assumption and (13), the union of the alternating chain (11) is a model, B,
of T . Since B also equals the union of the chain (12), Tarski‚Äôs lemma (I.6.29)
yields M ‚â∫B. Hence |=M T , proving (1).
‚ñ°
Some issues on the cardinality of models are addressed by the upward and
downward L¬®owenheim-Skolem theorems. Here we sample the connection be-
tween possible uniqueness of models of a given cardinality and completeness.

I.6. Substructures, Diagrams, and Applications
97
As before, a theory T over some language L is (simply) complete iff for all
sentences A, one of T ‚ä¢A or T ‚ä¢¬¨A holds. If T is in the sense of p. 38,
then it is complete iff for all sentences A, one of A ‚ààT or (¬¨A) ‚ààT
holds.
I.6.31 DeÔ¨Ånition. A theory T over a language L is Œ∫-categorical (where Œ∫ ‚â•
cardinality of L) iff any two models of T of cardinality Œ∫ are isomorphic. In
essence, there is only one model of cardinality Œ∫.
‚ñ°
I.6.32 Theorem (¬¥Lo¬¥s-Vaught Test). If T over L has no Ô¨Ånite models and is
Œ∫-categorical for some Œ∫, then it is complete.
Proof. The hypothesis is vacuously satisÔ¨Åed by an inconsistent theory. If T
is inconsistent, then it is complete. Let it be consistent then, and assume that
there is some sentence A that is neither provable nor refutable. Then both
T ‚à™{A} and T ‚à™{¬¨A} are consistent. Let A and B be respective models.
By the upward L¬®owenheim-Skolem theorem there are structures A‚Ä≤ and B‚Ä≤ of
cardinality Œ∫ each such that A ‚â∫A‚Ä≤ and B ‚â∫B‚Ä≤; hence (by assumption and
remarks in I.6.16)
A ‚â°A‚Ä≤ ‚àº= B‚Ä≤ ‚â°B
Thus A is true in B (since it is so in A), which is absurd.
‚ñ°
Our last application is perhaps the most startling. It is the rigorous intro-
duction of Leibniz‚Äôs inÔ¨Ånitesimals, that is, ‚Äúquantities‚Äù that are non-zero,‚Ä† yet
their absolute values are less than every positive real number. InÔ¨Ånitesimals
form the core of a user-friendly (sans Œµ-Œ¥, that is) introduction to limits and
the differential and integral calculus ‚Äì in the manner that Leibniz conceived
calculus (but he was never able to prove that inÔ¨Ånitesimals ‚Äúexisted‚Äù). Such
approaches to learning calculus (sometimes under the title non-standard analy-
sis) have been accessible to the undergraduate student for quite some time now
(e.g., Henle and Kleinberg (1980); see also Keisler (1976)). The legitimization
of inÔ¨Ånitesimals was Ô¨Årst announced in 1961 by Abraham Robinson (1961,
1966). Besides making calculus more ‚Äúnatural‚Äù, non-standard analysis has also
been responsible for the discovery of new results.
All that we need to do now is to extend the standard structure for the reals,
R = (R, . . . ) ‚Äì where ‚Äò‚Äò . . . ‚Äù includes ‚Äú+‚Äù, ‚Äú√ó‚Äù, ‚Äú<‚Äù, ‚Äú0‚Äù, ‚Äú1‚Äù, etc. ‚Äì so that
it is enriched with ‚Äúnew‚Äù numbers, including inÔ¨Ånitesimals. Given the tools at
our disposal, this will be surprisingly easy:
‚Ä† Actually, 0 is an inÔ¨Ånitesimal, as it will turn out. But there are uncountably many that are non-zero.

98
I. Basic Logic
Thus, we start by extending the Ô¨Årst order language for the reals, by importing
all constants, all functions, and all relations over R into the language as formal
constants, functions, and predicates respectively.
There are two issues we want to be clear about.
(1) In the exposition that follows we will almost exclusively use (an argot
of) the formal notation for the extended language of the reals ‚Äì and, in-
frequently, informal notations for concrete objects (e.g., reals). We are
thus best advised to keep the formal language notation uncomplicated, and
complicate ‚Äì if we must ‚Äì only the notation for the concrete objects. Thus,
e.g., we will denote by ‚Äú<‚Äù the formal, and by ‚Äú‚ó¶<‚Äù the concrete, predicate
on the reals; by ‚Äú
‚àö
2‚Äù the formal, and by ‚Äú‚ó¶‚àö
2‚Äù the concrete constant.‚Ä† In
short, we import a, f, P for all informal ‚ó¶a ‚ààR, for all functions ‚ó¶f with
inputs and outputs in R, and for all relations ‚ó¶P on R. Having done that,
we interpret as follows: aR = ‚ó¶a, f R = ‚ó¶f , and PR = ‚ó¶P. We will call
the language so obtained, simply, L. Due to lack of imagination, we will
call the expansion of the original R still R.‚Ä° Thus
R = (R,. . . , (‚ó¶a : ‚ó¶a ‚ààR), (‚ó¶f : ‚ó¶f on R), (‚ó¶P : ‚ó¶P on R))
(i)
(2) Not all functions on R are total (i.e., everywhere deÔ¨Åned). For example, the
function x #‚Üí‚àöx is undeÔ¨Åned for x < 0. This creates a minor annoyance
because functions of a Ô¨Årst order language are supposed to be interpreted as
(i.e., are supposed to name) total functions. We get around this by simply
not importing (names for) nontotal functions. However, we do import their
graphs,¬ß for these are just relations. All we have to do is to invent appropriate
notation for the formal name of such graphs. For example, suppose we want
toformallyname‚Äúy = ‚ó¶‚àöx‚Äù.Wejustuse y = ‚àöx.Thus,theformal(binary)
predicate name is the compound symbol ‚Äú= ‚àö‚Äù, which we employ in inÔ¨Åx
notation when building an atomic formula from it. See also I.6.37 later in
this section (p. 101).
With the above out of the way, we Ô¨Åx a cardinal m that is bigger than the
maximum of the cardinal of L and R. By the upward L¬®owenheim-Skolem
‚Ä† There is nothing odd about this. Both ‚Äú
‚àö
2‚Äù and ‚Äú‚ó¶‚àö
2‚Äù are names. Unlike what we do in normal
use, we pretend here that the former is the formal name, but the latter is the informal name for
the object called the ‚Äúsquare root of two‚Äù.
‚Ä° No confusion should arise from this, for neither the original bare bones R nor its language ‚Äì
which we haven‚Äôt named ‚Äì will be of any future use.
¬ß The graph of an n-ary function ‚ó¶f is the relation {‚ü®y, ‚Éóxn‚ü©: y = ‚ó¶f (‚Éóxn) is true in R}, or simply,
y = ‚ó¶f (‚Éóxn).

I.6. Substructures, Diagrams, and Applications
99
theorem there is a structure
‚àóR = (‚àóR, . . . , (‚àóa : ‚ó¶a ‚ààR), (‚àóf : ‚ó¶f on R), (‚àóP : ‚ó¶P on R))
(ii)
for L such that
R ‚â∫‚àóR
(1)
and
(cardinality of ‚àóR) = m
(2)
In particular (from (1) and (2)),
R ‚äÇ‚àóR
(3)
I.6.33 DeÔ¨Ånition. The members of ‚àóR are called the hyperreals or hyperreal
numbers. By (3), all reals are also hyperreals. The members of ‚àóR ‚àíR ‚Äì a non-
empty set by (3) ‚Äì are the non-standard numbers or non-standard hyperreals.
The members of R are the standard numbers or standard hyperreals.
‚ñ°
(1) says that a Ô¨Årst order sentence is true in R iff it is true in ‚àóR. This is neat. It
gives us a practical transfer principle (as it is called in Keisler (1982), although
in a different formulation): To verify a Ô¨Årst order sentence in ‚àóR (respectively,
in R) one only needs to verify it in R (respectively, in ‚àóR).
By (1) (which implies R ‚äÜ‚àóR) we also have
‚ó¶a = ‚àóa
for all
‚ó¶a ‚ààR
(4)
‚ó¶f ‚äÜ‚àóf
for all
‚ó¶f on R
(5)
and
‚ó¶P ‚äÜ‚àóP
for all
‚ó¶P on R
(6)
I.6.34 Example. Here is an example of how (4) and (6) apply:
(‚àÄx)(x < 0 ‚Üí¬¨(‚àÉy)(y = ‚àöx))
(7)
is true in R. Hence it is true in ‚àóR. Moreover, (‚àí6) < 0 is true in ‚àóR, since it
is true in R.
Pause. We have used formal notation in writing the two previous formulas.
By (7) and specialization, (‚àí6) < 0 ‚Üí¬¨(‚àÉy)(y = ‚àö(‚àí6)). Thus,
¬¨(‚àÉy)(y =

(‚àí6))

100
I. Basic Logic
is true in ‚àóR. Concretely this says that if we are working in the set ‚àóR, then
(using x #‚Üí‚àó‚àöx for the concrete function on ‚àóR, and also using (4))
‚àó
‚ó¶(‚àí6) is undeÔ¨Åned
So, nontotal functions continue (i.e., their extensions on ‚àóR do) being undeÔ¨Åned
on the same reals on which they failed to be deÔ¨Åned on R.
The reader can similarly verify that ‚àóR will not forgive division by zero,
using, for example, the formal sentence ¬¨(‚àÉy)(y ¬∑ 0 = 1).
‚ñ°
I.6.35 Example. Now start with the sentence (written formally!) sin(œÄ) = 0.
This is true in R, and hence in ‚àóR. A more messy way to say this is to say that by
(5) (note that ‚ó¶sin is total; hence the name sin was imported), ‚ó¶sin ‚äÜ‚àósin, and
hence (cf. (4)) ‚àósin(‚àóœÄ) = ‚àósin(‚ó¶œÄ) = ‚ó¶sin(‚ó¶œÄ) = ‚ó¶0 = ‚àó0. Thus, sin(œÄ) = 0,
the formal counterpart of ‚àósin(‚àóœÄ) = ‚àó0, is true in ‚àóR.
‚ñ°
Elementary arithmetic on R carries over on ‚àóR without change. Below is a
representative sample.
I.6.36 Example. First off, ‚àó< is a total order on ‚àóR. That is, the following
three sentences are true in ‚àóR (because they are so in R):
(‚àÄx)(¬¨x < x)
(‚àÄx)(‚àÄy)(x < y ‚à®y < x ‚à®x = y)
and
(‚àÄx)(‚àÄy)(‚àÄz)(x < y ‚àßy < z ‚Üíx < z)
The formal symbol ‚â§, as usual, is introduced by a deÔ¨Ånition
x ‚â§y ‚Üîx = y ‚à®x < y
Can we add inequalities, term by term, in ‚àóR? Of course, since
(‚àÄx)(‚àÄy)(‚àÄz)(‚àÄw)(x < y ‚àßz < w ‚Üíx + z < y + w)
is true in R therefore in ‚àóR as well.
The above has all sorts of obvious variations using, selectively, ‚â§instead of
<. Multiplication, term by term, goes through in ‚àóR under the usual caveat:
(‚àÄx)(‚àÄy)(‚àÄz)(‚àÄw)(0 ‚â§x < y ‚àß0 ‚â§z < w ‚Üíxz < yw)

I.6. Substructures, Diagrams, and Applications
101
Two more useful inequalities are
(‚àÄx)(‚àÄy)(‚àÄz)(z < 0 ‚àßx < y ‚Üízx > zy)
and
(‚àÄx)(‚àÄy)((0 < x ‚àßx < 1/y) ‚Üî(0 < y ‚àßy < 1/x))
The formal function | . . . | (absolute value) enjoys the usual properties in ‚àóR
because it does so in R. Here is a useful sample:
(‚àÄx)(‚àÄy)(|x + y| ‚â§|x| + |y|)
(‚àÄx)(‚àÄy)(|x ‚àíy| ‚â§|x| + |y|)
(‚àÄx)(‚àÄy)(|x| ‚â§y ‚Üî‚àíy ‚â§x ‚â§y)
Back to equalities: + and √ó are, of course, commutative on ‚àóR, for (‚àÄx)(‚àÄy)(x+
y = y + x) is true in R. Moreover,
(‚àÄx)(‚àÄy)(|xy| = |x||y|)
where we have used ‚Äúimplied √ó‚Äù above. Finally, the following are true in ‚àóR:
(‚àÄx)(0x = 0), (‚àÄx)(1x = x), and (‚àÄx)((‚àí1)x = ‚àíx).
‚ñ°
I.6.37 Remark (ImportingFunctions: theLast Word). We can now conclude
our discussion, on p. 98, about importing nontotal functions. Let then ‚ó¶f be an
n-ary nontotal function on R. The graph, y = ‚ó¶f (‚Éóxn) is imported as the formal
predicate ‚Äú(= f )‚Äù ‚Äì we write, formally, ‚Äúy(= f )‚Éóxn‚Äù rather than ‚Äúy = f ‚Éóxn‚Äù or
‚Äúy = f (‚Éóxn)‚Äù.‚Ä† Let y = ‚àóf (‚Éóxn) be the extension of y = ‚ó¶f (‚Éóxn) on ‚àóR (cf. (6),
p. 99). We note two things:
One, for any b, ‚Éóan in R, if b = ‚ó¶f (‚Éóan), then b = ‚àóf (‚Éóan) by (6) and (4)
(p. 99).
Two, since
(‚àÄx1) . . . (‚àÄxn)(‚àÄy)(‚àÄz)(y(= f )‚Éóxn ‚àßz(= f )‚Éóxn ‚Üíy = z)
is true in R by the assumption that ‚ó¶f is a function ‚Äì i.e., that the relation
y = ‚ó¶f (‚Éóxn) is single-valued in y ‚Äì it is true in ‚àóR as well, so that the concrete
relation y = ‚àóf (‚Éóxn) is single-valued in y. That is, ‚àóf is a function. Along with
remark one, above, this yields ‚ó¶f ‚äÜ‚àóf . This is the counterpart of (5) (p. 99)
‚Ä† This avoids a possible misunderstanding that, in something like y = f ‚Éóxn, f is an n-ary function
letter and hence f ‚Éóxn is a term. f is part of a language symbol, namely, of the predicate ‚Äú(= f )‚Äù.
It is not a symbol itself.

102
I. Basic Logic
for nontotal functions, and we are pleased to note that it has exactly the form
of (5), without any caveats.
Pause. Is ‚àóf total on ‚àóR?
We can now pretend, in practice (i.e., in argot) that all functions of R, total
or not, have been imported and thus have extensions in ‚àóR.
‚ñ°
We next explore ‚àóR looking for strange numbers, such as inÔ¨Ånitesimals and
inÔ¨Ånite numbers. To ensure that we know what we are looking for, we deÔ¨Åne:
I.6.38 DeÔ¨Ånition (InÔ¨Ånitesimals). An inÔ¨Ånitesimal h is a member of ‚àóR such
that |h| < x is true in ‚àóR for all positive x ‚ààR. A member h of ‚àóR is a Ô¨Ånite
hyperreal iff |h| ‚â§x is true in ‚àóR for some positive x ‚ààR. A member h of ‚àóR
is an inÔ¨Ånite hyperreal iff it is not Ô¨Ånite. That is, |h| > x is true in ‚àóR for all
positive x ‚ààR.
‚ñ°
I.6.39 Remark. Thus, 0 is an inÔ¨Ånitesimal, and every inÔ¨Ånitesimal is Ô¨Ånite.
The reader has surely noticed that we have dropped the annoying left-
superscripting of members of ‚àóR (or of R). This is partly because of (4) (p. 99).
Since ‚ó¶a = ‚àóa for all ‚ó¶a ‚ààR, it is smart to name both by the simpler formal
name, a. Moreover, since the left-superscript notation originates in the structure
R, it is not applicable to objects of ‚àóR unless these are extensions (functions
or predicates) of objects of R. It is thus pointless to write ‚Äú‚àóh‚Äù.
Even in the cases of functions and predicates, we can usually get away
without superscripts, letting the context indicate whether we are in R, in ‚àóR, or
in the formal language. For example we have used ‚Äú|h|‚Äù rather than ‚Äú‚àó|h|‚Äù, but
then we are clear that it is the latter that we are talking about, as the absolute
value here is applicable to non-standard inputs.
‚ñ°
I.6.40 Proposition. h ‚àà‚àóR is a nonzero inÔ¨Ånitesimal iff 1/|h| is inÔ¨Ånite.
Proof. If part: Suppose that 1/|h| is inÔ¨Ånite, and let 0 < r ‚ààR be arbitrary.
Then 1/r < 1/|h|. Specialization of the appropriate inequality in I.6.36 (a true
fact in ‚àóR) yields |h| < r.
Only-if part: Let 0 < r ‚ààR be arbitrary. By hypothesis, |h| < 1/r. By the
fact invoked above, r < 1/|h|.
‚ñ°
I.6.41 Proposition. Let h and h‚Ä≤ be inÔ¨Ånitesimals. Then so are
(1) h + h‚Ä≤,
(2) hh‚Ä≤,
(3) hr for any r ‚ààR.

I.6. Substructures, Diagrams, and Applications
103
Proof. (1): Let 0 < r ‚ààR be arbitrary. Then |h + h‚Ä≤| ‚â§|h| + |h‚Ä≤| < r/2 +
r/2 < r is true in ‚àóR.
(2): Let 0 < r ‚ààR be arbitrary. Then |hh‚Ä≤| = |h||h‚Ä≤| < r1 = r is true in
‚àóR.
(3): If r = 0, then h0 = 0 (cf. I.6.36), an inÔ¨Ånitesimal. Otherwise, let 0 < s ‚àà
R be arbitrary. |h| < s/|r| by hypothesis; hence |hr| = |h||r| < s (the reader
can easily verify that we have used legitimate ‚àóR-arithmetic).
‚ñ°
I.6.42 Proposition. Let h and h‚Ä≤ be inÔ¨Ånite hyperreals. Then so are
(1) hh‚Ä≤,
(2) hr for any 0 Ã∏= r ‚ààR,
(3) h + r for any r ‚ààR.
The prudence to ask that 0 Ã∏= r in (2) stems from the concluding remarks
in I.6.36.
Proof. (1): Let 0 < r ‚ààR be arbitrary. Then |hh‚Ä≤| = |h||h‚Ä≤| > r1 = r is true
in ‚àóR.
(2): Let 0 < s ‚ààR be arbitrary. |h| > s/|r| by hypothesis; hence |hr| =
|h||r| > s.
(3): Let 0 < s ‚ààR. Now, |h + r| ‚â•|h| ‚àí|r|.
Pause. Do you believe this?
Hence, s < |h + r|, since s + |r| < |h|.
‚ñ°
I.6.43 Example. We observe the phenomenon of indeterminate forms familiar
from elementary calculus. There we use the following symbols:
(i) Form ‚àû‚àí‚àû. This translates into ‚Äúthere is no Ô¨Åxed rule for what h‚àíh‚Ä≤ will
yield‚Äù (both positive inÔ¨Ånite). For example, if h = 2h‚Ä≤ (certainly inÔ¨Ånite,
by (2)), then h ‚àíh‚Ä≤ is inÔ¨Ånite. If a is an inÔ¨Ånitesimal, then h‚Ä≤ +a is inÔ¨Ånite.
Pause. Is that true?
Hence, if h = h‚Ä≤ + a, then h ‚àíh‚Ä≤ = a is an inÔ¨Ånitesimal. In particular, it
is Ô¨Ånite.
(ii) Form ‚àû/‚àû. There are three different outcomes for h/h‚Ä≤, according as
h = h‚Ä≤, h = (h‚Ä≤)2 (see (1) above), or h‚Ä≤ = h2.
(iii) Form 0/0. This translates to the question ‚Äúwhat is the result of h/h‚Ä≤, if
both are inÔ¨Ånitesimal?‚Äù It depends: Typical cases are h = h‚Ä≤, h = (h‚Ä≤)2,
and h‚Ä≤ = h2.
‚ñ°

104
I. Basic Logic
The following terminology and notation are useful. They are at the heart of
the limiting processes.
I.6.44 DeÔ¨Ånition. We say that two hyperreals a and b are inÔ¨Ånitely close, in
symbols a ‚âàb, iff a ‚àíb is an inÔ¨Ånitesimal.
Thus, in particular (since a ‚àí0 = a is true), a ‚âà0 says that a is an inÔ¨Ånites-
imal.
‚ñ°
I.6.45 Proposition. ‚âàis an equivalence relation on ‚àóR. That is, for all x, y, z,
it satisÔ¨Åes
(1) x ‚âàx,
(2) x ‚âày ‚Üíy ‚âàx,
(3) x ‚âày ‚âàz ‚Üíx ‚âàz.
Proof. Exercise I.59.
‚ñ°
I.6.46 Proposition. If r ‚âàs and r and s are real, then r = s.
Proof. r ‚àís ‚âà0 and r ‚àís ‚ààR. But, trivially, 0 is the only real inÔ¨Ånitesimal.
‚ñ°
I.6.47 Theorem (Main Theorem). For any Ô¨Ånite non-standard number h there
is a unique real r such that h ‚âàr.
Throughout the following proof we use superscriptless notation. In each case
it is clear where we are: In L, in R, or in ‚àóR.
Proof. Uniqueness is by I.6.45 and I.6.46. For the existence part let |h| ‚â§b,
0 < b ‚ààR, and deÔ¨Åne
H = {x ‚ààR : x < h}
(1)
H, a subset of R, is bounded above by b: Indeed, in ‚àóR, and for any Ô¨Åxed x ‚ààH,
x < h ‚â§b holds. Hence (cf. I.6.36), still in ‚àóR, x < b holds. Then it is true
in R as well (cf. p. 99, (4) and (6)). Let r ‚ààR be the least upper bound of H
(over the reals, least upper bounds of sets bounded above exist). We now argue
that
h ‚âàr
(2)

I.6. Substructures, Diagrams, and Applications
105
Suppose that (2) is false. Then there is a s > 0, in R, such that‚Ä†
s ‚â§|h ‚àír| is true in ‚àóR
(3)
There are two cases:
Case |h ‚àír| = h ‚àír. Then (3) implies s + r ‚â§h. Since s + r is standard,
but h is not, we have s +r < h hence s +r ‚ààH, and thus s +r ‚â§r from
the choice of r (upper bound), that is, s ‚â§0, contrary to the choice of s.
Case |h ‚àír| = r ‚àíh. Then (3) implies h ‚â§r ‚àís. Thus r ‚àís is an upper
bound of H (in R), contrary to choice of r (least upper bound, yet r ‚àí
s < r).
‚ñ°
It is unreasonable to expect that an inÔ¨Ånite number h is inÔ¨Ånitely close to a real
r, for if that were possible, then h ‚àír = a ‚âà0. But r + a is Ô¨Ånite (right?).
I.6.48 DeÔ¨Ånition (Standard Parts). Let h be a Ô¨Ånite hyperreal. The unique
real r such that h ‚âàr is called the standard part of h. We write st(h) = r.
‚ñ°
I.6.49 Example. For any real r, st(r) = r. This is by r ‚âàr and uniqueness
of standard parts. Also, since h is an inÔ¨Ånitesimal iff h ‚âà0, then h is an
inÔ¨Ånitesimal iff st(h) = 0.
‚ñ°
We can now prove that inÔ¨Ånitesimals and inÔ¨Ånite numbers exist in great
abundance.
I.6.50 Theorem. There is at least one, and hence there are uncountably many,
non-standard inÔ¨Ånitesimals.
Proof. Pick an h ‚àà‚àóR ‚àíR (cf. (3) preceding DeÔ¨Ånition I.6.33). If it is inÔ¨Ånite,
then 1/|h| is an inÔ¨Ånitesimal (by I.6.40). It is also nonzero, and hence non-
standard (0 is the only standard inÔ¨Ånitesimal).
Pause. ¬¨(‚àÉx)(1 = x0) is true in R.
If |h| is Ô¨Ånite, then st(h) exists and a = h‚àíst(h) ‚âà0. If a ‚ààR, so is h =
st(h) + a.
Why uncountably many? Well, Ô¨Åx a non-standard inÔ¨Ånitesimal h. The func-
tion r #‚Üírh is a 1-1, total function on the reals.‚Ä° Thus, its range, {rh : r ‚ààR}
is in 1-1 correspondence with R, and hence is uncountable.
‚ñ°
‚Ä† Letussettleaninconsistencyinterminology:Weuse‚ÄútrueinR‚Äù(withorwithoutthe‚àósuperscript)
synonymously with ‚Äútrue in R‚Äù
‚Ä° 1-1 because rh = r‚Ä≤h ‚Üír = r‚Ä≤, since h Ã∏= 0 ‚Äì being non-standard ‚Äì and the sentence
(‚àÄx)(‚àÄy)(‚àÄz)(z Ã∏= 0 ‚Üíxz = yz ‚Üíx = y) is true in R.

106
I. Basic Logic
I.6.51 Corollary. There is at least one, and hence there are uncountably many,
inÔ¨Ånite numbers.
I.6.52 Remark. By the preceding results, every Ô¨Ånite hyperreal h has the form
st(h) + a, where a ‚âà0. a = 0 iff h ‚ààR. For such hyperreals, h ‚âàst(h).
Conversely, any pair r (real) and a ‚âà0 leads to a hyperreal h = r + a such
that st(h) = r (since r + a ‚âàr).
Thus, if we were to depict the set ‚àóR on a line, in analogy with the R-line,
we could start with the latter, then stretch it and insert nonstandard numbers
(respecting order, ‚àó<) so that each real r lies in a ‚Äúcloud‚Äù of nonstandard
numbers that are inÔ¨Ånitely close to r. Then each such cloud‚Ä† contains only one
real; for r ‚âàh ‚âàr‚Ä≤ with r,r‚Ä≤ real implies r ‚âàr‚Ä≤ and hence r = r‚Ä≤. The cloud
in which 0 lies is the set of all inÔ¨Ånitesimals.
We then add all the positive inÔ¨Ånite numbers to the right end of the line
(again, respecting order, ‚àó<) and all the negative inÔ¨Ånite numbers to the left
end of the line.
‚ñ°
The deÔ¨Ånition that a function f is continuous that we will eventually give
essentially requires that the standard part function st, commute with f . As a
prelude towards that we present a proposition below that deals with the special
cases of addition, multiplication, and a few other elementary functions.
But Ô¨Årst, the non-standard counterpart to the pinching lemma of calculus.‚Ä°
I.6.53 Lemma (Pinching Lemma). If 0 < h < h‚Ä≤ and h‚Ä≤ ‚âà0, then h ‚âà0.
Either or both of ‚Äú<‚Äù can be replaced by ‚Äú‚â§‚Äù.
Proof. Exercise I.60.
‚ñ°
I.6.54 Corollary. If a < b < c and a ‚âàc, then a ‚âàb and b ‚âàc. Moreover,
this remains true if we replace one or both of ‚Äú<‚Äù by ‚Äú‚â§‚Äù.
Proof. 0 < b ‚àía < c ‚àía.
‚ñ°
I.6.55 Proposition (Elementary Algebra of st). Throughout, a and b are Ô¨Åxed
Ô¨Ånite hyperreals.
(1) a ‚â•0 implies st(a) ‚â•0.
(2) st(a + b) = st(a) + st(b).
(3) st(a ‚àíb) = st(a) ‚àíst(b).
‚Ä† The cloud for r ‚ààR is {r + a : a ‚âà0}. Of course, if a < 0, then r + a < r, while if a > 0, then
r + a > r.
‚Ä° If 0 < g(x) < f (x) for all x in an open interval (a, b), c ‚àà(a, b), and limx‚Üíc f (x) = 0, then
also limx‚Üíc g(x) = 0.

I.6. Substructures, Diagrams, and Applications
107
(4) st(a ¬∑ b) = st(a) ¬∑ st(b).
(5) If st(b) Ã∏= 0, then st(a/b) = st(a)/st(b).
(6) st(an) = st(a)n for all n ‚ààN.
(7) If st(a) Ã∏= 0, then st(a‚àín) = st(a)‚àín for all 0 < n ‚ààN.
(8) st(a1/n) = st(a)1/n for all 0 < n ‚ààN (a ‚â•0 assumed for n even).
Proof. We sample a few cases and leave the rest as an exercise (Exercise I.61).
(1): Assume the hypothesis, yet st(a) < 0. By I.6.54, st(a) ‚âà0; hence st(a) =
0, a contradiction.
(5): st(b) Ã∏= 0 implies that b Ã∏‚âà0,‚Ä† in particular, b Ã∏= 0. The formula to
prove thus makes sense. Now, a = a(a/b); hence, by (4), st(a) = st(a(a/b)) =
st(a) st(a/b).
(7): Having proved (6) by induction on n, we note that st(an) = st(a)n Ã∏= 0.
Moreover, a‚àín = 1/an. Hence st(a‚àín) = st(1/an) = st(1)/st(an) = 1/st(a)n,
since st(1) = 1.
(8): For odd n, it is true in R that
(‚àÄx)(‚àÉy)x = yn
or, more colloquially,
(‚àÄx)(‚àÉy)y = x1/n
(i)
(i) is also true in ‚àóR, so it makes sense, for any a ‚àà‚àóR and odd n, to form a1/n.
Similarly, if n is even, then
(‚àÄx)(x ‚â•0 ‚Üí(‚àÉy)y = x1/n)
(ii)
is true in ‚àóR, so it makes sense, for any 0 ‚â§a ‚àà‚àóR and even n, to form a1/n.
For any such a1/n that makes sense, so does st(a)1/n, by (1).
Thus, noting that a = (a1/n)n we get st(a) = st((a1/n)n) = st(a1/n)n, the
second ‚Äú=‚Äù by (6). Hence st(a1/n) = st(a)1/n.
‚ñ°
A corollary to (1) above, insigniÔ¨Åcant (and easy) as it may sound, is the
non-standard counterpart to the statement that a real closed interval [a, b] is
compact, that is, every sequence of members of [a, b] that converges, converges
to a number in [a, b].
I.6.56 Corollary. h ‚â§h‚Ä≤ implies st(h) ‚â§st(h‚Ä≤). In particular, if a and b are
real and the closed interval in ‚àóR is
[a, b]
def
= {x ‚àà‚àóR : a ‚â§x ‚â§b}
then whenever h ‚àà[a, b], it also follows that st(h) ‚àà[a, b].
‚Ä† b Ã∏‚âà0 means, of course, ¬¨(b ‚âà0).

108
I. Basic Logic
The notion of the limit of a real function‚Ä† of one variable f at a point a
depends on what the function does when its inputs are in a neighbourhood of
a ‚Äì that is, an open interval (c, b) that contains a ‚Äì but not on what it does on a
itself. For this reason the limit is deÔ¨Åned in terms of a punctured neighbourhood
of a, which means a set like (c, a) ‚à™(a, b), where c < a < b. We are interested
in calculating better and better approximations to the values f (x) as x gets very
close to a (but never becomes equal to a ‚Äì for all we care, f might not even be
deÔ¨Åned on a).
We can deÔ¨Åne limits `a la Leibniz now, replacing ‚Äúvery close‚Äù by ‚ÄúinÔ¨Ånitely
close‚Äù:
I.6.57 DeÔ¨Ånition (Limits). Let ‚ó¶f be a real function of one variable deÔ¨Åned
in some punctured real neighbourhood of the real a. Let b be also real.‚Ä° The
notation limx‚Üía ‚ó¶f (x) = b abbreviates (i.e., is deÔ¨Åned to mean)
for all non-standard h ‚âà0,
‚àóf (a + h) ‚âàb
(1)
In practice (argot) we will let the context fend for itself and simply write (1) as
‚Äúfor all non-standard h ‚âà0, f (a + h) ‚âàb‚Äù and, similarly, limx‚Üía f (x) = b
for its abbreviation, that is, dropping the ‚àóand ‚ó¶left superscripts. We have just
deÔ¨Åned the so-called two-sided Ô¨Ånite limit.
Similarly one deÔ¨Ånes a whole variety of other limits. We give two examples
of such deÔ¨Ånitions (in simpliÔ¨Åed notation):
Suppose f is deÔ¨Åned in the open interval (a, c) and let b be real. Then the
symbol limx‚Üía+ f (x) = b abbreviates
for all positive h ‚âà0,
f (a + h) ‚âàb
(2)
We have just deÔ¨Åned the so-called right Ô¨Ånite limit.
Finally, let f be deÔ¨Åned in the open interval (a, c). Then limx‚Üía+ f (x) =
+‚àûabbreviates
for all positive h ‚âà0,
f (a + h) is positive inÔ¨Ånite
(3)
We have just deÔ¨Åned the so-called right positive inÔ¨Ånite limit.
‚ñ°
I.6.58 Remark.
(A) In (1) in the above deÔ¨Ånition, h ‚àà‚àóR ‚àíR guarantees that h Ã∏= 0. This in
turn guarantees that we are unconcerned with what f wants to be on a ‚Äì as
‚Ä† That is, a function f : R ‚ÜíR ‚Äì not necessarily a total one.
‚Ä° Recall that, because ‚ó¶a =‚àóa by (4) on p. 99, we have already decided to use the formal name
‚Äúa‚Äù for either ‚ó¶a or ‚àóa.

I.6. Substructures, Diagrams, and Applications
109
we should be ‚Äì since a + h Ã∏= a. Furthermore, ‚àóf (a + h) is deÔ¨Åned
for all such h, so that (1) makes sense. This is easy: To Ô¨Åx ideas, let
‚ó¶f be deÔ¨Åned in the punctured neighbourhood (d, a) ‚à™(a, c). First off,
0 < |h| < min(a ‚àíd, c ‚àía), since 0 Ã∏= h ‚âà0. Hence h > 0 ‚Üía <
a + h < c, while h < 0 ‚Üíd < a + h < a. Secondly, the sentence
(‚àÄx)(d < x < a ‚à®a < x < c ‚Üí(‚àÉy)y = f (x)) is true in R by
the assumption on ‚ó¶f , hence also in ‚àóR. Thus, ‚àóf is deÔ¨Åned in the non-
standard (punctured) neighbourhood {x ‚àà‚àóR : d < x < a ‚à®a < x < c}.
This neighbourhood we are going to denote by (d, a) ‚à™(a, c) as well, and
let the context indicate whether or not this symbol denotes a standard or a
non-standard neighbourhood.
(B) Another way to state (1) above is
for all nonzero h ‚âà0,
st( f (a + h)) = b
(4)
That is, the standard part above is independent of the choice of h.
‚ñ°
I.6.59Example. Wecomputelimx‚Üí2(3x3‚àíx2+1):Let0 Ã∏= h ‚âà0bearbitrary.
Then
st(3(2 + h)3 ‚àí(2 + h)2 + 1) = st(3(23 + 12h + 6h2 + h3)
‚àí(4 + 4h + h2) + 1)
= st(21 + 32h + 17h2 + 3h3)
= 21,
by I.6.55
We compute limx‚Üí0(x/|x|). We want st(h/|h|) for 0 Ã∏= h ‚âà0. In order to
remove the absolute value sign we consider cases:
st
 h
|h|

=
1
if h > 0
‚àí1
if h < 0
According to the deÔ¨Ånition (cf. (B), previous remark), the limit limx‚Üí0
(x/|x|) does not exist. The calculation above shows however that limx‚Üí0+(x/
|x|) = 1 and limx‚Üí0‚àí(x/|x|) = ‚àí1.
We see that calculating limits within non-standard calculus is easy be-
cause we calculate with equalities, rather than with inequalities as in standard
calculus.
‚ñ°
We show next that the non-standard deÔ¨Ånition of limit is equivalent to
Weierstrass‚Äôs Œµ-Œ¥ deÔ¨Ånition:

110
I. Basic Logic
I.6.60 Theorem. Let ‚ó¶f be a real function, deÔ¨Åned in some punctured neigh-
bourhood of (the real) a. Let b be also real. The following statements are
equivalent:
(i) (1) in DeÔ¨Ånition I.6.57
(ii) (‚àÄ0 < Œµ ‚ààR)(‚àÉ0 < Œ¥ ‚ààR)(‚àÄx ‚ààR)(0 < |x ‚àía| < Œ¥ ‚Üí|‚ó¶f (x) ‚àíb| < Œµ).‚Ä†
Proof. (i) ‚Üí(ii): Let then (1) in I.6.57 hold. To prove (ii), Ô¨Åx an 0 < Œµ ‚ààR.‚Ä°
It now sufÔ¨Åces to show the truth of the formal sentence (iii) below:
(‚àÉŒ¥ > 0)(‚àÄx)(0 < |x ‚àía| < Œ¥ ‚Üí| f (x) ‚àíb| < Œµ)
(iii)
One way to prove an existential sentence such as (iii) is to exhibit a Œ¥ that
works. Since it is a sentence over L, it sufÔ¨Åces to verify it in ‚àóR. It will then be
true in R ‚Äì which is what we want.
Thus, we take Œ¥ = h where 0 Ã∏= h ‚âà0 and show that it works. Let now
x ‚àà‚àóR be arbitrary such that 0 < |x ‚àía| < h. Thus (I.6.53), |x ‚àía| ‚âà0;
hence x ‚àía ‚âà0 from ‚àí|x ‚àía| ‚â§x ‚àía ‚â§|x ‚àía| and I.6.54 (via I.6.55). We
can now write x = a + h‚Ä≤, with h‚Ä≤ ‚âà0 and h‚Ä≤ Ã∏= 0. By hypothesis ‚Äì i.e., (i) ‚Äì
‚àóf (a + h‚Ä≤) ‚âàb is true in ‚àóR, i.e., ‚àóf (x) ‚âàb is true. Hence ‚àóf (x) ‚àíb ‚âà0,
and therefore |‚àóf (x) ‚àíb| is less than any positive real. In particular, it is less
than Œµ.
(ii) ‚Üí(i): We assume (ii), pick an arbitrary h such that 0 Ã∏= h ‚âà0, and
prove ‚àóf (a + h) ‚âàb. This requires
for all real Œµ > 0,
|‚àóf (a + h) ‚àíb| < Œµ
(iv)
So Ô¨Åx an arbitrary real Œµ > 0. Assumption (ii) translates into the assumption
that the sentence (iii) is true in R. Let then Œ¥ > 0 be real, so that the L-sentence
below is true in R (Œ¥ and Œµ below are formal constants):
(‚àÄx)(0 < |x ‚àía| < Œ¥ ‚Üí| f (x) ‚àíb| < Œµ)
(v)
(v) is also true in ‚àóR. By specialization in the metalanguage, take x = a + h.
Now, 0 < |x ‚àía| = |h| by choice of h. Also, |x ‚àía| = |h| < Œ¥ is also true,
since Œ¥ > 0 and real, and h ‚âà0. Thus, by (v), translated into ‚àóR, we have
|‚àóf (x) ‚àíb| < Œµ. This proves (iv).
‚ñ°
‚Ä† This argot is a bit awkward, but not unusual. ‚Äú(‚àÄ0 < Œµ ‚ààR) . . . ‚Äù stands for ‚Äú(‚àÄŒµ)(0 < Œµ ‚àßŒµ ‚àà
R ‚Üí. . . ‚Äù.
‚Ä° We have Ô¨Åxed a real Œµ. Recall that the name ‚ÄúŒµ‚Äù is also used for the formal constant that denotes
this real Œµ.

I.6. Substructures, Diagrams, and Applications
111
Worth repeating: The part (i) ‚Üí(ii) of the above proof was an instance where
we were able to prove a Ô¨Årst order fact in ‚àóR and then transfer it back to R.
This is the essential use we get from the elementary extension R ‚â∫‚àóR, for if
all the facts we needed could easily be proved in R, the whole fuss of obtaining
an extension that contains weird numbers would be pointless.
We conclude with the deÔ¨Ånition of continuity and with one more elementary
application of transferring facts from ‚àóR back to R. Some more techniques and
facts will be discovered by the reader in the Exercises section.
I.6.61 DeÔ¨Ånition. Let f be a real function of one real variable, deÔ¨Åned at least
on an open real interval (a, b). We say that f is continuous at c ‚àà(a, b) (a real
point) iff limx‚Üíc f (x) = f (c).
If f is also deÔ¨Åned at a, then we say that it is continuous at the left endpoint
a of [a, b), meaning that limx‚Üía+ f (x) = f (a). In a similar situation at the
right endpoint b, we require that limx‚Üíb‚àíf (x) = f (b).
We say that f is continuous on [a, b] iff it is so at every real x ‚àà[a, b].
‚ñ°
I.6.62 Remark. The above is the standard deÔ¨Ånition. Since it involves the
concept of limit, we may translate it to a corresponding non-standard deÔ¨Ånition.
Let then f be deÔ¨Åned on the real closed interval [a, b]. Then for any (real)
c ‚àà(a, b) continuity requires (using h as a free variable over ‚àóR)
0 Ã∏= h ‚âà0 ‚Üíst(‚àóf (c + h)) = f (c)
(1)
Continuity at the endpoints reads
0 < h ‚âà0 ‚Üíst(‚àóf (a + h)) = f (a)
(2)
and
0 > h ‚âà0 ‚Üíst(‚àóf (b + h)) = f (b)
(3)
Does it matter if we take the 0 Ã∏= part away? No, since the limit is equal to the
function value.
Suppose now that f is continuous on the real interval [a, b]. We now extend
[a, b] to include non-standard numbers as in I.6.56. Then, whenever x ‚àà[a, b],
where x is a hyperreal, we also have st(x) ‚àà[a, b] by I.6.56. Thus, x ‚àà[a, b]
implies that x = r + h where r is real ‚Äì a ‚â§r ‚â§b ‚Äì and h ‚âà0. We can now
capture (1)‚Äì(3) by the single statement
x ‚àà[a, b] ‚Üíst(‚àóf (x)) = ‚àóf (st(x))
(4)

112
I. Basic Logic
Thus, continuity is the state of affairs where st commutes with the function
letter. By the way, since st(x) is real, so is ‚àóf (st(x)); indeed, it is the same as
‚ó¶f (st(x)) (cf. (5), p. 99), which we write, more simply, f (st(x)). In practice one
writes (4) above as
x ‚àà[a, b] ‚Üíst( f (x)) = f (st(x))
‚ñ°
I.6.63 Example. The function x #‚Üí‚àöx is continuous on any [a, b] where
0 ‚â§a. Indeed, by I.6.55, 0 ‚â§x implies st(‚àöx) = ‚àöst(x). Now invoke (4)
in I.6.62.
‚ñ°
I.6.64 Theorem. Suppose that f is continuous on the real interval [a, b]. Then
f is bounded on [a, b], that is, there is a real B > 0 such that
x ‚àà[a, b] ‚à©R ‚Üí| f (x)| < B
(1)
Proof. We translate the theorem conclusion into a sentence over L. ‚Äú f ‚Äù, as
usual, plays a dual role: name of the real and name of the formal object. The
translation is
(‚àÉy)(‚àÄx)(a ‚â§x ‚â§b ‚Üí| f (x)| < y)
(1‚Ä≤)
Now (1‚Ä≤) is true in ‚àóR under the assumption that ‚ó¶f , which we still call f , is
continuous.
Here is why: Take y = H, where H ‚àà‚àóR is some positive inÔ¨Ånite hyperreal.
Pick any hyperreal x in [a, b] (extended interval). Now, the assumption on
continuity, in the form (4) of I.6.62, has the side effect that
st( f (x)) is deÔ¨Åned
Hence f (x) is Ô¨Ånite. Let then 0 < rx ‚ààR such that | f (x)| < rx. Thisrx depends
on the picked x. But rx < H; thus | f (x)| < H for the arbitrary hyperreal x in
[a, b], establishing the truth of (1‚Ä≤) in ‚àóR. So it is true in R too.
‚ñ°
I.7. DeÔ¨Åned Symbols
We have already mentioned that the language lives, and it is being constantly
enriched by new nonlogical symbols through deÔ¨Ånitions. The reason we do this
is to abbreviate undecipherably long formal texts, thus making them humanly
understandable.
There are three possible kinds of formal abbreviations, namely, abbreviations
of formulas, abbreviations of variable terms (i.e., ‚Äúobjects‚Äù that depend on free

I.7. DeÔ¨Åned Symbols
113
variables),andabbreviationsofconstantterms(i.e.,‚Äúobjects‚Äùthatdonotdepend
on free variables). Correspondingly, we introduce a new nonlogical symbol for
a predicate, a function, or a constant in order to accomplish such abbreviations.
Here are three simple examples, representative of each case.
We introduce a new predicate (symbol), ‚Äú‚äÜ‚Äù, in set theory by a deÔ¨Ånition‚Ä†
A ‚äÜB ‚Üî(‚àÄx)(x ‚ààA ‚Üíx ‚ààB)
An introduction of a function symbol by deÔ¨Ånition is familiar from elemen-
tary mathematics. There is a theorem that says
‚Äúfor every non-negative real number x there is a unique
non-negative real number y such that x = y ¬∑ y‚Äù
(1)
This justiÔ¨Åes the introduction of a 1-ary function symbol f that, for each such x,
produces the corresponding y. Instead of using the generic ‚Äú f (x)‚Äù, we normally
adopt one of the notations ‚Äú‚àöx‚Äù or ‚Äúx1/2‚Äù. Thus, we enrich the language (of,
say, algebra or real analysis) by the function symbol ‚àö
and add as an axiom
the deÔ¨Ånition of its behaviour. This would be
x = ‚àöx‚àöx
or
y = ‚àöx ‚Üîx = y ¬∑ y
where the restriction x ‚â•0 is implied by the context.
The ‚Äúenabling formula‚Äù (1) ‚Äì stated in argot above ‚Äì is crucial in order
that we be allowed to introduce ‚àö
and its deÔ¨Åning axiom. That is, before we
introduce an abbreviation of a (variable or constant) term ‚Äì i.e., an object ‚Äì we
must have a proof in our theory of an existential formula, i.e., one of the type
(‚àÉ!y)A, that asserts that (if applicable, for each value of the free variables) a
unique such object exists.
The symbol ‚Äú(‚àÉ!y)‚Äù is read ‚Äúthere is a unique y‚Äù. It is a ‚Äúlogical‚Äù abbreviation
(deÔ¨Åned logical symbol, just like ‚àÄ) given (in least-parenthesized form) by
(‚àÉx)(A ‚àß¬¨(‚àÉz)(A ‚àß¬¨x = z))
Finally, an example of introducing a new constant symbol, from set theory,
is the introduction of the symbol ‚àÖinto the language, as the name of the unique
‚Ä† In practice we state the above deÔ¨Ånition in argot, probably as ‚ÄúA ‚äÜB means that, for all x,
x ‚ààA ‚Üíx ‚ààB‚Äù.

114
I. Basic Logic
object‚Ä† y that satisÔ¨Åes ¬¨U(y) ‚àß(‚àÄx)x /‚àày, read ‚Äúy is a set,‚Ä° and it has no
members‚Äù. Thus, ‚àÖis deÔ¨Åned by
¬¨U(‚àÖ) ‚àß(‚àÄx)x /‚àà‚àÖ
or, equivalently, by
y = ‚àÖ‚Üî¬¨U(y) ‚àß(‚àÄx)x /‚àày
The general situation is this: We start with a theory , spoken in some
basic¬ß formal language L. As the development of  proceeds, gradually and
continuously we extend L into languages Ln, for n ‚â•0 (we have set L0 = L).
Thus the symbol Ln+1 stands for some arbitrary extension of Ln effected at
stage n + 1. The theory itself is being extended by stages, as a sequence n,
n ‚â•0.
A stage is marked by the event of introducing a single new symbol into the
language via a deÔ¨Ånition of a new predicate, function or constant symbol. At
that same stage we also add to n the deÔ¨Åning nonlogical axiom of the new
symbol in question, thus extending the theory n into n+1. We set 0 = .
SpeciÔ¨Åcally, if ¬∂ Q (‚Éóxn) is some formula, we then can introduce a new pred-
icate symbol ‚ÄúP‚Äù# that stands for Q .
In the present description, Q is a syntactic (meta-)variable, while P is a new
formal predicate symbol.
This entails adding P to Lk (i.e., to its alphabet V k) as a new n-ary predicate
symbol, and adding
P‚Éóxn ‚ÜîQ (‚Éóxn)
(i)
to k as the deÔ¨Åning axiom for P. ‚Äú‚äÜ‚Äù is such a deÔ¨Åned (2-ary) predicate in set
theory.
Similarly, a new n-ary function symbol f is added into Lk (to form Lk+1) by
a deÔ¨Ånition of its behaviour. That is, we add f to Lk and also add the following
‚Ä† Uniqueness follows from extensionality, while existence follows from separation. These facts ‚Äì
and the italicized terminology ‚Äì are found in volume 2, Chapter III.
‚Ä° U is 1-ary (unary) predicate. It is one of the two primitive nonlogical symbols of formal set
theory. With the help of this predicate we can ‚Äútest‚Äù an object for set or atom status. ‚Äú U(y)‚Äù
asserts that y is an atom, thus ‚Äú¬¨U(y)‚Äù asserts that y is a set ‚Äì since we accept that sets or atoms
are the only types of objects that the formal system axiomatically characterizes.
¬ß ‚ÄúBasic‚Äù means here the language given originally, before any new symbols were added.
¬∂ Recall that (see Remark I.1.11, p. 18) the notation Q (‚Éóxn) asserts that ‚Éóxn, i.e., x1,. . . , xn, is the
complete list of the free variables of Q .
# Recallthatpredicatelettersaredenotedbynon-calligraphiccapitalletters P, Q, R withorwithout
subscripts or primes.

I.7. DeÔ¨Åned Symbols
115
formula (ii) to k as a new nonlogical axiom:
y = f y1 . . . yn ‚ÜîQ (y, y1,. . . , yn)
(ii)
provided we have a proof in k of the formula
(‚àÉ!y)Q (y, y1,. . . , yn)
(iii)
Of course, the variables y, ‚Éóyn are distinct.
Depending on the theory, and the number of free variables (n ‚â•0), ‚Äú f ‚Äù may
take theory-speciÔ¨Åc names such as ‚àÖ, œâ, ‚àö, etc. (in this illustration, for the
sake of economy of effort, we have thought of deÔ¨Åned constants, e.g., ‚àÖand œâ,
as 0-ary functions ‚Äì something that we do not normally do).
In effecting these deÔ¨Ånitions, we want to be assured of two things:
1. Whatever we can state in the richer language Lk (for any k > 0) we can also
state in the original (‚Äúbasic‚Äù) language L = L0 (although awkwardly, which
justiÔ¨Åes our doing all this). ‚ÄúCan state‚Äù means that we can ‚Äútranslate‚Äù any
formula F over Lk (hopefully in a natural way) into a formula F ‚àóover L
so that the extended theory k can prove that F and F ‚àóare equivalent.‚Ä†
2. We also want to be assured that the new symbols offer no more than con-
venience, in the sense that any formula F , over the basic language L, that
k (k > 0) is able to prove, one way or another (perhaps with the help of
deÔ¨Åned symbols),  can also prove.‚Ä°
Theseassuranceswillbecomeavailableshortly,asMetatheoremsI.7.1andI.7.3.
Here are the ‚Äúnatural‚Äù translation rules, that take us from a language stage Lk+1
back to the previous, Lk (so that, iterating the process, we are back to L):
Rule (1). Suppose that F is a formula over Lk+1, and that the predicate P
(whose deÔ¨Ånition took us from Lk to Lk+1, and hence is a symbol of Lk+1 but
not of Lk) occurs in F zero or more times. Assume that P has been deÔ¨Åned by
the axiom (i) above (included in k+1), where Q is a formula over Lk.
We eliminate P from F by replacing all its occurrences by Q . By this we
mean that whenever P‚Éótn is a subformula of F , all its occurrences are replaced
by Q (‚Éótn). We can always arrange by I.4.13 that the simultaneous substitution
Q [‚Éóxn ‚Üê‚Éótn] is deÔ¨Åned.
This results to a formula F ‚àóover Lk.
‚Ä† , spoken over L, can have no opinion, of course, since it cannot see the new symbols, nor does
it have their ‚ÄúdeÔ¨Ånitions‚Äù among its ‚Äúknowledge‚Äù.
‚Ä° Trivially, any F
over L that  can prove, any k (k > 0) can prove as well, since the latter
understands the language (L) and contains all the axioms of . Thus k extends the theory .
That it cannot have more theorems over L than  makes this extension conservative.

116
I. Basic Logic
Rule (2). If f is a deÔ¨Åned n-ary function symbol as in (ii) above, introduced
into Lk+1, and if it occurs in F as F [ f t1 . . . tn],‚Ä† then this formula is logically
equivalent to‚Ä°
(‚àÉy)(y = f t1 . . . tn ‚àßF [y])
(iv)
provided that y is not free in F [ f t1 . . . tn].
Using the deÔ¨Ånition of f given by (ii) and I.4.13 to ensure that Q (y,‚Éótn) is
deÔ¨Åned, we eliminate this occurrence of f , writing (iv) as
(‚àÉy)(Q (y, t1,. . . , tn) ‚àßF [y])
(v)
which says the same thing as (iv) in any theory that thinks that (ii) is true (this
observation is made precise in the proof of Metatheorem I.7.1). Of course, f
may occur many times in F , even ‚Äúwithin itself‚Äù, as in f f z1 . . . zny2 . . . yn,¬ß
or even in more complicated conÔ¨Ågurations. Indeed, it may occur within the
scope of a quantiÔ¨Åer. So the rule becomes: Apply the transformation taking
every atomic subformula A[ f ‚Éótn] of F into form (v) by stages, eliminating at
each stage the leftmost innermost¬∂ occurrence of f (in the atomic formula we
are transforming at this stage), until all occurrences of f are eliminated.
We now have a formula F ‚àóover Lk.
I.7.1 Metatheorem (Elimination of DeÔ¨Åned Symbols: I). Let  be any theory
over some formal language L.
(a) Let the formula Q be over L, and P be a new predicate symbol that extends
L into L‚Ä≤ and  into ‚Ä≤ via the axiom P‚Éóxn ‚ÜîQ (‚Éóxn). Then, for any formula
F over L‚Ä≤, the P-elimination as in Rule (1) above yields a F ‚àóover L such
that
‚Ä≤ ‚ä¢F ‚ÜîF ‚àó
(b) Let F [x] be over L, and let t stand for f t1,. . . , tn, where f is introduced
by (ii) above as an axiom that extends  into ‚Ä≤. Assume that no ti contains
the letter f and that y is not free in F [t]. Then#
‚Ä≤ ‚ä¢F [t] ‚Üî(‚àÉy)(Q (y,‚Éótn) ‚àßF [y])
‚Ä† This notation allows for the possibility that f t1,. . . , tn does not occur at all in F
(see the
convention on brackets, p. 18).
‚Ä° See (C) in the proof of Metatheorem I.7.1 below.
¬ß Or f ( f (z1,. . . , zn), y2,. . . , yn)), using brackets and commas to facilitate reading.
¬∂ A term f t1,. . . , tn is ‚Äúinnermost‚Äù iff none of the ti contains ‚Äú f ‚Äù.
# As we already have remarked, in view of I.4.13, it is unnecessary pedantry to make assumptions
on substitutability explicit.

I.7. DeÔ¨Åned Symbols
117
Here ‚ÄúL‚Ä≤‚Äù is ‚ÄúLk+1‚Äù (for some k) and ‚ÄúL‚Äù is ‚ÄúLk‚Äù.
Proof. First observe that this metatheorem indeed gives the assurance that, after
applying the transformations (1) and (2) to obtain F ‚àófrom F , ‚Ä≤ thinks that
the two are equivalent.
(a): This follows immediately from the Leibniz rule (I.4.25).
(b): Start with
‚ä¢F [t] ‚Üít = t ‚àßF [t] (By ‚ä¢t = t and |=Taut-implication)
(A)
Now, by Ax2, substitutability, and non-freedom of y in F [t],
‚ä¢t = t ‚àßF [t] ‚Üí(‚àÉy)(y = t ‚àßF [y])
Hence
‚ä¢F [t] ‚Üí(‚àÉy)(y = t ‚àßF [y])
(B)
by (A) and |=Taut-implication.‚Ä†
Conversely,
‚ä¢y = t ‚Üí(F [y] ‚ÜîF [t])
(Ax4; substitutability was used here)
Hence (by |=Taut)
‚ä¢y = t ‚àßF [y] ‚ÜíF [t]
Therefore, by ‚àÉ-introduction (allowed, by our assumption on y),
‚ä¢(‚àÉy)(y = t ‚àßF [y]) ‚ÜíF [t]
which, along with (B), establishes
‚ä¢F [t] ‚Üî(‚àÉy)(y = t ‚àßF [y])
(C)
Finally, by (ii) (which introduces ‚Ä≤ to the left of ‚ä¢), (C), and the Leibniz rule,
‚Ä≤ ‚ä¢F [t] ‚Üî(‚àÉy)(Q (y,‚Éótn) ‚àßF [y])
(D)
‚ñ°
The import of Metatheorem I.7.1 is that if we transform a formula F ‚Äì written
over some arbitrary extension by deÔ¨Ånitions, Lk+1, of the basic language L ‚Äì
into a formula F ‚àóover L, then k+1 (the theory over Lk+1 that has the beneÔ¨Åt
of all the added axioms) thinks that F ‚ÜîF ‚àó. The reason for this is that we can
‚Ä† We will often write just ‚Äúby |=Taut‚Äù meaning to say ‚Äúby |=Taut-implication‚Äù.

118
I. Basic Logic
imagine that we eliminate one new symbol at a time, repeatedly applying the
metatheorem above ‚Äì part (b) to atomic subformulas ‚Äì forming a sequence of
increasingly more ‚Äúbasic‚Äù formulas F k+1, F k, F k‚àí1,. . . , F 0, where F 0 is the
same string as F ‚àóand F k+1 is the same string as F .
Now, i+1 ‚ä¢F i+1 ‚ÜîF i for i = k,. . . , 0, where, if a deÔ¨Åned function letter
was eliminated at step i + 1 ‚Üíi, we invoke (D) above and the Leibniz rule.
Hence, since 0 ‚äÜ1 ‚äÜ¬∑ ¬∑ ¬∑ ‚äÜk+1, k+1 ‚ä¢F i+1 ‚ÜîF i for i = k,. . . , 0,
therefore k+1 ‚ä¢F k+1 ‚ÜîF 0.
I.7.2Remark(OnePointRule). Theabsolutelyprovableformulain(C)above
is sometimes called the one point rule (Gries and Schneider (1994), Tourlakis
(2000a, 2001b)). Its dual
F [t] ‚Üî(‚àÄy)(y = t ‚ÜíF [y])
is also given the same nickname and is easily (absolutely) provable using (C)
by eliminating ‚àÉ.
‚ñ°
I.7.3 Metatheorem (Elimination of DeÔ¨Åned Symbols: II). Let  be a theory
over a language L.
(a) If L‚Ä≤ denotes the extension of L by the new predicate symbol P, and ‚Ä≤
denotes the extension of  by the addition of the axiom P‚Éóxn ‚ÜîQ (‚Éóxn),
where Q is a formula over L, then  ‚ä¢F for any formula F over L such
that ‚Ä≤ ‚ä¢F .
(b) Assume that
 ‚ä¢(‚àÉ!y)R(y, x1,. . . , xn)
(‚àó)
pursuant to which we have deÔ¨Åned the new function symbol f by the axiom
y = f x1. . . xn ‚ÜîR(y, x1,. . . , xn)
(‚àó‚àó)
and thus extended L to L‚Ä≤ and  to ‚Ä≤. Then  ‚ä¢F for any formula F
over L such that ‚Ä≤ ‚ä¢F .
Proof. This metatheorem assures that extensions of theories by deÔ¨Ånitions are
conservative in that they produce convenience but no additional power (the
same old theorems over the original language are the only ones provable).
(a): By the completeness theorem, we show instead that
 |= F
(1)

I.7. DeÔ¨Åned Symbols
119
So let M = (M, I ) be an arbitrary model of , i.e., let
|=M 
(2)
We now expand the structure M into M‚Ä≤ = (M, I ‚Ä≤) ‚Äì without adding any
new individuals to its domain M ‚Äì by adding an interpretation PI ‚Ä≤ for the new
symbol P. We deÔ¨Åne for every a1,. . . , an in M
PI ‚Ä≤(a1,. . . , an) = t iff |=M‚Ä≤ Q (a1,. . . , an)
[i.e., iff
|=M Q (a1,. . . , an)]
Clearly then, M‚Ä≤ is a model of the new axiom, since, for all M‚Ä≤-instances of
the axiom ‚Äì such as P(a1,. . . , an) ‚ÜîQ (a1,. . . , an) ‚Äì we have
(P(a1,. . . , an) ‚ÜîQ (a1,. . . , an))I ‚Ä≤ = t
It follows that |=M‚Ä≤ ‚Ä≤, since we have |=M‚Ä≤ , the latter by (2), due to having
made no changes to M that affect the symbols of L. Thus, ‚Ä≤ ‚ä¢F yields
|=M‚Ä≤ F ; hence, since F is over L, we obtain |=M F . Along with (2), this
proves (1).
(b): As in (a), assume (2) in an attempt to prove (1). By (‚àó),
|=M (‚àÉ!y)R(y, x1,. . . , xn)
Thus, there is a concrete (i.e., in the metatheory) function f of n arguments that
takes its inputs from M and gives its outputs to M, the input-output relation
being given by (3) below (‚Éóbn in, a out). To be speciÔ¨Åc, the semantics of ‚Äú‚àÉ!‚Äù
implies that for all b1,. . . , bn in M there is a unique a ‚ààM such that
(R(a, b1,. . . , bn))I = t
(3)
We now expand the structure M into M‚Ä≤ = (M, I ‚Ä≤),‚Ä† so that all we add to it
is an interpretation for the new function symbol f . We let f I ‚Ä≤ = f . From (2)
it follows that
|=M‚Ä≤ 
(2‚Ä≤)
since we made no changes to M other than adding an interpretation of f , and
since no formula in  contains f . By (3), if a, b1,. . . , bn are any members of
M, then we have
|=M‚Ä≤ a = f b1. . . bn iff a = f (b1,. . . , bn)
iff |=M R(a, b1,. . . , bn)
by the deÔ¨Ånition of f
iff |=M‚Ä≤ R(a, b1,. . . , bn)
‚Ä† This part is independent of part (a); hence this is a different I ‚Ä≤ in general.

120
I. Basic Logic
the last ‚Äúiff‚Äù being because R (over L) means the same thing in M and M‚Ä≤.
Thus,
|=M‚Ä≤ y = f x1. . . xn ‚ÜîR(y, x1,. . . , xn)
(4)
Now (‚àó‚àó), (2‚Ä≤), and (4) yield |=M‚Ä≤ ‚Ä≤ which implies |=M‚Ä≤ F (from ‚Ä≤ ‚ä¢F ).
Finally, since F contains no f , we have |=M F . This last fact, and (2) give (1).
‚ñ°
I.7.4 Remark.
(a) We note that translation rules (1) and (2) ‚Äì the latter applied to atomic
subformulas ‚Äì preserve the syntactic structure of quantiÔ¨Åer preÔ¨Åxes. For
example, suppose that we have introduced f by
y = f x1. . . xn ‚ÜîQ (y, x1,. . . , xn)
(5)
in set theory. Now, an application of the collection axiom of set theory has
a hypothesis of the form
‚Äú(‚àÄx ‚ààZ)(‚àÉw)(. . . A[ f t1 . . . tn] . . . )‚Äù
(6)
where, say, A is atomic and the displayed f is innermost. Eliminating this
f , we have the translation
‚Äú(‚àÄx ‚ààZ)(‚àÉw)(. . . (‚àÉy)(A[y] ‚àßQ (y, t1,. . . , tn)) . . . )‚Äù
(7)
which still has the ‚àÄ‚àÉ-preÔ¨Åx and still looks exactly like a collection axiom
hypothesis.
(b) Rather than worrying about the ‚Äúontology‚Äù of the function symbol formally
introduced by (5) above ‚Äì i.e., the question of the exact nature of the symbol
thatwenamed ‚Äú f ‚Äù‚Äìinpracticeweshrugthisoffandresorttometalinguistic
devices to name the function symbol, or the term that naturally arises from
it. For example, one can use the notation ‚Äú fQ ‚Äù for the function ‚Äì where the
subscript ‚ÄúQ ‚Äù is the exact string over the language that ‚ÄúQ ‚Äù denotes ‚Äì or,
for the corresponding term, the notation of Whitehead and Russell (1912),
(Œπz)Q (z, x1,. . . , xn)
(8)
The ‚Äúz‚Äù in (8) above is a bound variable.‚Ä† This new type of term is read
‚Äúthe unique z such that . . . ‚Äù. This ‚ÄúŒπ‚Äù is not one of our primitive symbols.‚Ä°
‚Ä† That it must be distinct from the xi is obvious.
‚Ä° It is however possible to enlarge our alphabet to include ‚ÄúŒπ‚Äù, and then add deÔ¨Ånitions of the
syntax of ‚ÄúŒπ-terms‚Äù and axioms for the behaviour of ‚ÄúŒπ-terms‚Äù. At the end of all this one gets a

I.7. DeÔ¨Åned Symbols
121
It is just meant to lead to the friendly shorthand (8) above that avoids the
‚Äúontology‚Äù issue. Thus, once one proves
(‚àÉ!z)Q (z, x1,. . . , xn)
(9)
one can then introduce (8) by the axiom
y = (Œπz)Q (z, x1,. . . , xn) ‚ÜîQ (y, x1,. . . , xn)
(5‚Ä≤)
which, of course, is an alias for the axiom (5), using more suggestive nota-
tion for the term f x1,. . . , xn. By (9), the axioms (5) or (5‚Ä≤) can be replaced
by
Q ( f x1,. . . , xn, x1,. . . , xn)
and
Q ((Œπz)Q (z, x1,. . . , xn), x1,. . . , xn)
(10)
respectively. For example, from (5‚Ä≤) we get (10) by substitution. Now, Ax4
(with some help from |=Taut) yields
Q ((Œπz)Q (z, x1,. . . , xn), x1,. . . , xn) ‚Üí
y = (Œπz)Q (z, x1,. . . , xn) ‚ÜíQ (y, x1,. . . , xn)
Hence, assuming (10),
y = (Œπz)Q (z, x1,. . . , xn) ‚ÜíQ (y, x1,. . . , xn)
(11)
Finally, deploying (9), we get
Q ((Œπz)Q (z, x1,. . . , xn), x1,. . . , xn) ‚Üí
Q (y, x1,. . . , xn) ‚Üíy = (Œπz)Q (z, x1,. . . , xn)
Hence
Q (y, x1,. . . , xn) ‚Üíy = (Œπz)Q (z, x1,. . . , xn)
by (10). This, along with (11), yields (5‚Ä≤).
‚ñ°
The IndeÔ¨Ånite Article. We often have the following situation: We have proved
a statement like
(‚àÉx)A[x]
(1)
conservative extension of the original theory, i.e., any Œπ-free formula provable in the new theory
can be also proved in the old (Hilbert and Bernays (1968)).

122
I. Basic Logic
and we want next to derive a statement B . To this end, we start by picking a
symbol c not in B and say ‚Äúlet c be such that A[c] is true‚Äù.‚Ä† That is, we add
A[c] as a nonlogical axiom, treating c as a new constant.
From all these assumptions we then manage to prove B, hopefully treat-
ing all the free variables of A[c] as constants during the argument. We then
conclude that B has been derived without the help of A[c] or c (see I.4.27).
Two things are noteworthy in this technique: One, c does not occur in the
conclusion, and, two, c is not uniquely determined by (1). So we have a (rather
than the) c that makes A[c] true.
Now the suggestion that the free variables of the latter be frozen during the
derivation of B is unnecessarily restrictive, and we have a more general result:
Suppose that
 ‚ä¢(‚àÉx)A(x, y1,. . . , yn)
(2)
Add a new function symbol f to the language L of  (thus obtaining L‚Ä≤) via
the axiom
A( f y1,. . . , yn, y1,. . . , yn)
(3)
This says, intuitively, ‚Äúfor any y1,. . . , yn, let x = f ‚Éóyn make A(x, ‚Éóyn) true‚Äù.
Again, this x is not uniquely determined by (2).
Finally, suppose that we have a proof
 + A( f ‚Éóyn, ‚Éóyn) ‚ä¢B
(4)
such that f , the new function symbol, occurs nowhere in B, i.e., the latter
formula is over L. We can conclude then that
 ‚ä¢B
(5)
that is, the extension  + A( f ‚Éóyn, ‚Éóyn) of  is conservative.
A proof of the legitimacy of this technique, based on the completeness
theorem, is easy. Let
|=M 
(6)
and show
|=M B
(7)
Expand the model M = (M, I ) to M‚Ä≤ = (M, I ‚Ä≤), so that I ‚Ä≤ interprets
the new symbol f . The interpretation is chosen as follows: (2) guarantees
‚Ä† Cf. I.5.44.

I.8. Computability and Uncomputability
123
that, for all choices of i1,. . . , in in M, the set S(i1,. . . , in) = {a ‚ààM :
|= M A(a, i1,. . . , in)} is not empty.
By the axiom of choice (of informal set theory), we can pick an a(i1,. . . , in)‚Ä†
in each S(i1,. . . , in). Thus, we deÔ¨Åne a function f : Mn ‚ÜíM by letting, for
each i1,. . . , in in M, f (i1,. . . , in) = a(i1,. . . , in).
The next step is to set
f I ‚Ä≤ = f
Therefore, for all i1,. . . , in in M,
( f i1 . . . in)I ‚Ä≤ = f (i1,. . . , in) = a(i1,. . . , in)
It is now clear that |=M‚Ä≤ A( f y1 . . . yn, y1,. . . , yn), for, by I.5.11,
(A( f i1. . . in, i1,. . . , in))I ‚Ä≤ = t ‚Üî(A(a(i1,. . . , in), i1,. . . , in))I ‚Ä≤ = t
and the right hand side of the above is true by the choice of a(i1,. . . , in).
Thus, |=M‚Ä≤  + A( f y1 . . . yn, y1,. . . , yn); hence |=M‚Ä≤ B , by (4). Since B
contains no f , we also have |=M B ; thus we have established (7) from (6). We
now have (5).
One can give a number of names to a function like f : a Skolem function,
an Œµ-term (Hilbert (1968)), or a œÑ-term (Bourbaki (1966b)). In the Ô¨Årst case
one may ornament the symbol f , e.g., f‚àÉA, to show where it is coming from,
although such mnemonic naming is not, of course, mandatory.
The last two terminologies actually apply to the term f y1 . . . yn, rather than
to the function symbol f . Hilbert would have written
(Œµx)A(x, y1 . . . , yn)
(8)
and Bourbaki
(œÑx)A(x, y1 . . . , yn)
(9)
‚Äì each denoting f y1 . . . yn. The ‚Äúx‚Äù in each of (8) and (9) is a bound variable
(different from each yi).
I.8. Computability and Uncomputability
Computability (or ‚Äúrecursion theory‚Äù) is nowadays classiÔ¨Åed as an area of logic
(e.g., it is one of the areas represented in the Handbook of Mathematical Logic,
Barwise (1978)). It has its origins in the work of several logicians in the 1930s
‚Ä† The ‚Äú(i1,. . . , in)‚Äù part indicates that ‚Äúa‚Äù depends on i1,. . . , in.

124
I. Basic Logic
(G¬®odel, Turing, Kleene, Church, Post, et al.). Motivation for this research was
partly provided by Hilbert‚Äôs program to found all mathematics on formalism.
This was a formalism that one ought to be able to certify by Ô¨Ånitary means
(for each particular formalized theory) to be free of contradiction. Moreover,
it was a formalism, for which ‚Äì Hilbert expected ‚Äì a ‚Äúmethod‚Äù ought to exist
to solve the Entscheidungsproblem (decision problem), that is, the question ‚Äúis
this arbitrary formula a theorem, or not?‚Äù
What was a ‚Äúmethod‚Äù supposed to be, exactly, mathematically speaking?
Was the expectation that the Entscheidungsproblem of any theory is amenable
to algorithmic solution realistic? Work of Church (lack of a decision algorithm
for certain theories (1936)) showed that it was not, nor for that matter was
the expectation of certifying freedom of contradiction of all formal theories by
Ô¨Ånitary means (G¬®odel‚Äôs second incompleteness theorem).
One of these two negative answers (Church‚Äôs) built on an emerging theory
of computable (or algorithmic) functions and the mathematical formulation of
the concepts of algorithm or method. The other one, G¬®odel‚Äôs, while it used
existing (pre-Turing and pre-Kleene) rudiments of computability (primitive
recursive functions of Dedekind), can be recast, in hindsight, in the framework
of modern computability. This recasting shows the intimate connection between
the phenomena of incompletableness of certain theories and uncomputability,
and thus it enhances our understanding of both phenomena.
With the advent of computers and the development of computer science,
computability gained a new set of practitioners and researchers: theoretical
computer scientists. This group approaches the area from two (main) stand-
points: to study the power and limitations of mathematical models of computing
devices (after all, computer programs are algorithms), and also to understand
why some problems have ‚Äúeasy‚Äù while others have ‚Äúhard‚Äù algorithmic solutions
(complexity theory) ‚Äì in the process devising several ‚Äúpractical‚Äù (or efÔ¨Åcient)
solutions, and techniques, for a plethora of practical problems.
We develop the basics of computability here informally, that is, within ‚Äúreal
mathematics‚Äù (in the metatheory of pure and applied Ô¨Årst order logic).
Computability, generally speaking, formalizes the concept of a ‚Äúcomputable
function‚Äù f : Nk ‚ÜíN. That is, it concerns itself with the issue of separating the
set of all so-called number-theoretic functions ‚Äì that is,‚Ä† functions with inputs
in N and outputs in N ‚Äì into computable and uncomputable.
Because we want the theory to be as inclusive as possible, we allow it to
study both total and nontotal functions f : Nk ‚ÜíN.
‚Ä† More precisely, this is what ordinary computability or ordinary recursion theory studies. Higher
recursion theory, invented by Kleene, also looks into functions that have higher order inputs such
as number-theoretic functions.

I.8. Computability and Uncomputability
125
The trivial reason is that in everyday computing we do encounter both total
and nontotal functions. There are computer programs which (whether or not
according to the programmer‚Äôs intent) do not stop to yield an answer for all
possible inputs. We do want to have formal counterparts of those in our theory,
if we are hoping to have a theory that is inclusive.
Alesstrivialreasonisthatunlessweallownontotalfunctionsinthetheory,an
obvious diagonalization can show the existence of total (intuitively) computable
functions that are not in the theory.
I.8.1 DeÔ¨Ånition. Any number-theoretic function f : Nk ‚ÜíN is a partial
function. If its domain, dom( f ), equals Nk ‚Äì the set of all potential inputs, or
left Ô¨Åeld ‚Äì then we say that f is total. If it does not, then f is nontotal.
That a ‚ààdom( f ) is also denoted by f (a) ‚Üì, and we say that f is deÔ¨Åned at
a or that f (a) converges.‚Ä† In the opposite case we write f (a) ‚Üëand say that f
is undeÔ¨Åned at a or that f (a) diverges.
A number-theoretic relation is a subset of Nk. We usually write such relations
in relational notation. That is, we write R(a1,. . . , an) for ‚ü®a1,. . . , an‚ü©‚ààR.
Thus our notation of relations parallels that of formulas of a Ô¨Årst order language,
and we use the logical connectives (‚àÉ, ‚àÄ, ¬¨, ‚à®, etc.) informally to combine
relations. We carry that parallel to the next natural step, and use the phrases
‚Äú. . . a relation R . . . ‚Äù and ‚Äú. . . a relation R(y1,. . . , yn) . . . ‚Äù interchangeably,
thelattertoconveythatthefulllistoftherelation‚Äôsvariablesisexactly y1,. . . , yn
(cf. p. 18).
We occasionally use Œª-notation to modify a given relation R(y1,. . . , yn).
This notation is employed as in Œªz1. . . zr.R, or even Œªz1. . . zr.R(y1,. . . , yn).
The part ‚ÄúŒªz1 . . . zr.‚Äù denotes that ‚Äúz1,. . . , zr‚Äù is the active variables list and
supersedes the list ‚Äúy1,. . . , yn‚Äù. Any yi that is not in the list z1,. . . , zr is
treated as a constant (or ‚Äúparameter‚Äù ‚Äì i.e., it is ‚Äúfrozen‚Äù). The list z1,. . . , zr
may contain additional variables not in the list y1, . . . , yn.
Thus, e.g., Œªxy.x < 2 = {0, 1} √ó N, while Œªyx.x < 2 = N √ó {0, 1}. On
the other hand, Œªx.x < y = {x : x < y}, which denotes a different relation for
different values of the parameter y.
Finally, as before, ‚Éózr or just ‚Éóz (if r is understood) denotes z1,. . . , zr, so that
we may write Œª‚Éózr.R(y1,. . . , yn).
‚ñ°
I.8.2 DeÔ¨Ånition (Bounded QuantiÔ¨Åcation). For any relation R, the symbols
(‚àÉx)<z R, (‚àÄx)<z R, (‚àÉx)‚â§z R, (‚àÄx)‚â§z R stand for (‚àÉx)(x < z ‚àßR), (‚àÄx)(x <
z ‚ÜíR), (‚àÉx)(x ‚â§z ‚àßR), (‚àÄx)(x ‚â§z ‚ÜíR), respectively. We say that they
denote bounded quantiÔ¨Åcation.
‚ñ°
‚Ä† This nomenclature parallels that of ‚Äúconvergent‚Äù or ‚Äúhalting‚Äù computations.

126
I. Basic Logic
I.8.3 DeÔ¨Ånition. If R ‚äÜNn is a relation and f : Nk ‚ÜíN a function, then
R(w1,. . . , wm, f (‚Éóxk), wm+1,. . . , wn) means‚Ä†
(‚àÉz)(R(w1,. . . , wm, z, wm+1,. . . , wn) ‚àßz = f (‚Éóxk))
We have just one important exception to this rule: If Q is g(‚Éóy) = w, then
g(‚Éóy) = f (‚Éóxk) means
g(‚Éóy) ‚Üë‚àßf (‚Éóxk) ‚Üë‚à®(‚àÉz)(z = g(‚Éóy) ‚àßz = f (‚Éóxk))
One often writes g(‚Éóy) ‚âÉf (‚Éóxk) for the above to alert the reader that ‚Äúweak
equality‚Äù (a notion due to Kleene) applies, but we will rather use ‚Äú=‚Äù throughout
and let the context determine the meaning.
‚ñ°
Clearly, weak equality restores reÔ¨Çexivity of ‚Äú=‚Äù (which fails if the general
understanding of substitution above applied to ‚Äú=‚Äù as well).
Œª-notation comes in handy in denoting number-theoretic functions. Instead
of saying ‚Äúconsider the function g obtained from f : Nk ‚ÜíN, by setting, for
all ‚Éówm,
g( ‚Éówm) = f (‚Éóxk)
where if an xi is not among the w j it is understood to be an (unspeciÔ¨Åed)
constant‚Äù, we simply say ‚Äúconsider g = Œª ‚Éówm. f (‚Éóxk)‚Äù.
I.8.4 Example. Turning to inequalities, f (x) > 0 means (is equivalent to)
(‚àÉy)(y = f (x) ‚àßy > 0). In particular, it implies that f (x) ‚Üì.
‚ñ°
I.8.5 Example. In the presence of partial functions, ¬¨A = B and A Ã∏= B are
not interchangeable. For example, f (a) Ã∏= b says (by I.8.3) that (‚àÉy)( f (a) =
y‚àßy Ã∏= b). In particular, this entails that f (a) ‚Üì. On the other hand, ¬¨ f (a) = b
holds iff f (a) ‚Üë‚à®(‚àÉy)( f (a) = y ‚àßy Ã∏= b).
We are not changing the rules of logic here, but are just amending our
understanding of the semantics of the metanotation ‚ÄúÃ∏=‚Äù, to make it correct in
the presence of partial functions.
‚ñ°
There are many approaches to deÔ¨Åning computable functions, and they are
all equivalent, that is, they deÔ¨Åne exactly the same set of functions. All except
two of them begin by deÔ¨Åning a notion of ‚Äúcomputation model‚Äù, that is, a set
‚Ä† Cf. I.7.2.

I.8. Computability and Uncomputability
127
of string-manipulation algorithms (e.g., Turing machines, Markov algorithms,
Kleene‚Äôs equation manipulation processes), and then they deÔ¨Åne a computable
functionasonewhoseinput-outputrelationship‚Äìcodedasarelationonstrings‚Äì
can be veriÔ¨Åed by an algorithm belonging to the computation model.
There are two number-theoretic approaches, both due to Kleene, one using
so-called Kleene schemata‚Ä† and one that inductively deÔ¨Ånes the set of com-
putable functions, bypassing the concepts of ‚Äúalgorithm‚Äù or ‚Äúcomputation‚Äù.‚Ä°
We follow the latter approach in this section. According to this, the set
of computable functions is the smallest set of functions that includes some
‚Äúindisputably computable‚Äù functions, and is closed under some ‚Äúindisputably
algorithmic‚Äù operations.¬ß
The following are operations (on number-theoretic functions) that are cen-
trally important:
I.8.6 DeÔ¨Ånition (Composition). Let Œª‚Éóx.gi(‚Éóx) (i = 1,. . . , n) and Œª‚Éóyn. f (‚Éóyn)
be given functions.¬∂ Then h = Œª‚Éóx. f (g1(‚Éóx),. . . , gn(‚Éóx)) is the result of their
composition.
‚ñ°
Note the requirement that all the variables of the ‚Äúoutermost‚Äù function, f , be
substituted, and that each substitution (a function application, gi(‚Éóx)) apply to
the same variable list ‚Éóx. With additional tools, we can eventually relax this very
rigid requirement.
I.8.7 DeÔ¨Ånition (Primitive Recursion). Let Œªx‚Éóynz.g(x, ‚Éóyn, z) and Œª‚Éóyn.h(‚Éóyn)
be given. We say that Œªx‚Éóyn. f (x, ‚Éóyn) is obtained by primitive recursion from
h and g just in case it satisÔ¨Åes, for all x and ‚Éóyn, the following equations (the
so-called primitive recursive schema):
f (0, ‚Éóyn) = h(‚Éóyn)
f (x + 1, ‚Éóyn) = g(x, ‚Éóyn, f (x, ‚Éóyn))
‚ñ°
I.8.8 DeÔ¨Ånition (Unbounded Search). Given Œª‚Éóx yn.g(x, ‚Éóyn). f is deÔ¨Åned from
g by unbounded search on the variable x just in case, for all ‚Éóyn, the following
‚Ä† These characterize inductively the set of all number-tuples ‚ü®z, ‚Éóx, y‚ü©which are intuitively under-
stood to ‚Äúcode‚Äù the statement that the machine, or algorithm, z, when presented with input ‚Éóx,
will eventually output y.
‚Ä° Work on this originated with Dedekind, who characterized in this manner a proper subset of
computable functions, that of primitive recursive functions.
¬ß The reader will agree, once all the details are in hand, that the qualiÔ¨Åcation ‚Äúindisputably‚Äù is apt.
¬∂ Afunctioninthissection,unlessotherwiseexplicitlystated,isanumber-theoreticpartialfunction.

128
I. Basic Logic
holds:
f (‚Éóyn) =
min{x : g(x, ‚Éóyn) = 0 ‚àß(‚àÄz)<xg(z, ‚Éóyn) ‚Üì}
‚Üëif the minimum above does not exist
(1)
In (1) above, the case ‚Äú‚Üë‚Äù is short for ‚Äú f (‚Éóyn) is undeÔ¨Åned‚Äù. We write f (‚Éóyn) =
(¬µx)g(x, ‚Éóyn) as a short form of (1).
‚ñ°
I.8.9 Example. The condition ‚Äúg(x, ‚Éóyn) = 0‚àß(‚àÄz)<xg(z, ‚Éóyn) ‚Üì‚Äù is rather com-
plicated. It says that (see also I.8.4)
g(0, ‚Éóyn) > 0,
g(1, ‚Éóyn) > 0,. . . ,
g(x ‚àí1, ‚Éóyn) > 0
but g(x, ‚Éóyn) = 0. For example, suppose that
g(x, y) =
0
if x = y = 1
‚Üë
otherwise
Then, while the smallest x such that g(x, 1) = 0 holds is x = 1, this is not what
(1) ‚Äúcomputes‚Äù. The deÔ¨Ånition (1) yields undeÔ¨Åned in this case, since g(0, 1) ‚Üë.
Of course, the part ‚Äú(‚àÄz)<xg(z, ‚Éóyn) ‚Üì‚Äù in (1) is superÔ¨Çuous if g is total.
‚ñ°
The following functions are intuitively computable. They form the basis of
an inductive deÔ¨Ånition of all computable functions.
I.8.10 DeÔ¨Ånition (Initial Functions).
Zero: z
(Œªx.0)
Successor: s
(Œªx.x + 1)
Identities or projections: un
i , for n ‚â•1 and 1 ‚â§i ‚â§n
(Œª‚Éóxn.xi).
‚ñ°
I.8.11 DeÔ¨Ånition. The set of partial computable or partial recursive functions,
P,istheclosureoftheinitialfunctionsabove,undertheoperationscomposition,
primitive recursion, and unbounded search.
Thesetofcomputableorrecursivefunctions,R,isthesetofalltotalfunctions
of P.
‚ñ°
One occasionally sees terminology such as ‚Äúcomputable partial functions‚Äù or
‚Äúrecursive partial functions‚Äù. Of course, ‚Äúpartial‚Äù qualiÔ¨Åes ‚Äúfunctions‚Äù (not ‚Äúre-
cursive‚Äù or ‚Äúcomputable‚Äù): therefore one hopes never to see ‚Äúpartially recursive
functions‚Äù or ‚Äúpartially computable functions‚Äù.

I.8. Computability and Uncomputability
129
I.8.12 DeÔ¨Ånition. The set of primitive recursive functions, PR, is the closure
of the initial functions above under the operations composition and primitive
recursion.
‚ñ°
The primitive recursive functions were deÔ¨Åned by Dedekind and were called
‚Äúrecursive‚Äù until the recursive functions of I.8.11 were deÔ¨Åned. Then the name
of the functions of Dedekind was qualiÔ¨Åed to be ‚Äúprimitive‚Äù.
Why are the functions in P ‚Äúcomputable‚Äù?‚Ä† Well, an (informal) induction
on the deÔ¨Ånition (I.8.11) shows why this is ‚Äúcorrect‚Äù.
The initial functions are clearly intuitively computable (e.g., by pencil and
paper, by anyone who knows how to add 1 to an arbitrary natural number).
Suppose that each of Œª‚Éóx.gi(‚Éóx) (i = 1,. . . , n) and Œª‚Éóyn. f (‚Éóyn) are intuitively
computable (i.e., we know how to compute the output, given the input). To
compute f (g1(‚Éóa),. . . , gn(‚Éóa)), given ‚Éóa, we compute each of the gi(‚Éóa), and then
use the results as inputs to f .
To see why f (deÔ¨Åned by a primitive recursive schema from h and g) is
computable if h and g are, let us Ô¨Årst introduce the notation z := x, which we
understand to say ‚Äúcopy the value of x into z‚Äù.
Then we can write an ‚Äúalgorithm‚Äù for the computation of f (a, ‚Éóbn):
(1)
z := h(‚Éóbn)
Repeat (2) below for i = 0, 1, 2,. . . , a ‚àí1:
(2)
z := g(i, ‚Éóbn, z)
Since(I.H.)thecomputationsh(‚Éóbn)and g(i, ‚Éóbn, z)canbecarriedout‚Äìregardless
of the input values ‚Éóbn, i, and z ‚Äì at the end of the ‚Äúcomputation‚Äù indicated above,
z holds the value f (a, ‚Éóbn).
Finally, let Œªx‚Éóyn.g(x, ‚Éóyn) be intuitively computable. We show how to com-
pute Œª‚Éóyn.(¬µx)g(x, ‚Éóyn):
(1) x := 0.
(2) if g(x, ‚Éóbn) = 0, go to step (5).
(3) x := x + 1.
(4) go back to step (2).
(5) Done! x holds the result.
The above algorithm justiÔ¨Åes the term ‚Äúunbounded search‚Äù. We are searching
by letting x = 0, 1, 2, . . . in turn. It is ‚Äúunbounded‚Äù since we have no a priori
‚Ä† We have ‚Äúcomputable‚Äù and computable. The former connotes our intuitive understanding of the
term. It means ‚Äúintuitively computable‚Äù. The latter has an exact deÔ¨Ånition (I.8.11).

130
I. Basic Logic
knowledge of how far the search will have to go. It is also clear that the algorithm
satisÔ¨Åes the deÔ¨Ånition of (¬µx):‚Ä† We will hit step (5) iff progress was never
blocked at step (2) (i.e., iff all along g(i, ‚Éóbn) > 0 (see I.8.4) until the Ô¨Årst
(smallest) i came along for which g(i, ‚Éóbn) = 0).
We have our Ô¨Årst few simple results:
I.8.13 Proposition. R ‚äÇP.
Proof. The ‚äÜ-part is by deÔ¨Ånition. The Ã∏= -part follows from the fact that e ‚àà
P but e Ã∏‚ààR, where we have denoted by ‚Äúe‚Äù the totally undeÔ¨Åned (empty)
function Œªy.(¬µx)s(u2
1(x, y)) (in short, e(y), for any y, is the smallest x such
that x + 1 = 0; but such an x does not exist).
‚ñ°
I.8.14 Proposition. R is closed under composition and primitive recursion.
Proof. These two operations preserve total functions (why?).
‚ñ°
I.8.15 Corollary. PR ‚äÜR.
Proof. By induction on PR, since the initial functions (common to PR and
P) are total and hence are in R.
‚ñ°
Thus all primitive recursive functions are total.
It can be shown that the inclusion PR ‚äÜR is proper, but we will not need
this result (see, e.g., Tourlakis (1984)).
I.8.16 DeÔ¨Ånition. A relation R(‚Éóx) is (primitive) recursive iff its characteristic
function,
œáR = Œª‚Éóx.
0
if R(‚Éóx)
1
if ¬¨R(‚Éóx)
is (primitive) recursive.
The set of all primitive recursive (recursive) relations, or predicates,‚Ä° is
denoted by PR‚àó(R‚àó).
‚ñ°
‚Ä† By the way, in modern Greek, one pronounces ‚Äú¬µ‚Äù exactly like the English word ‚Äúme‚Äù.
‚Ä° Relations are often called ‚Äúpredicates‚Äù by computability practitioners.

I.8. Computability and Uncomputability
131
Since we are to stay within N, we need a special kind of subtraction, proper
subtraction:‚Ä†
x
.‚àíy
def
=
x ‚àíy
if x ‚â•y
0
otherwise
I.8.17 Example. This example illustrates some important techniques used to
circumvent the rigidity of our deÔ¨Ånitions.
We prove that Œªxy.x
.‚àíy ‚ààPR. First, we look at a special case. Let p =
Œªx.x
.‚àí1 and p = Œªxy.p(x). Now p is primitive recursive, since
p(0, y) = z(y)
(1)
p(x + 1, y) = u3
1(x, y,p(x, y))
Thus, so is
p = Œªx.p

u1
1(x), z(x)

(2)
Finally, let d = Œªxy.y
.‚àíx. This is in PR, since
d(0, y) = u1
1(y)
(3)
d(x + 1, y) = p

u3
3(x, y, d(x, y))

Thus, Œªxy.x
.‚àíy is primitive recursive, since
Œªxy.x
.‚àíy = Œªxy.d

u2
2(x, y), u2
1(x, y)

(4)
Our acrobatics here have worked around the following formal difÔ¨Åculties:
(i) Our number-theoretic functions have at least one argument. Thus, any
instance of the primitive recursive schema must deÔ¨Åne a function of at
least two arguments. This explains the introduction of p in the schema (1).
(ii) A more user-friendly way to write (1) (in the argot of recursion theory) is
p(0) = 0
p(x + 1) = x
Indeed, ‚Äúu3
1(x, y,p(x, y))‚Äù is a fancy way (respecting the form of the
primitive recursive schema) to just say ‚Äúx‚Äù. Moreover, one simply writes
p = Œªx.p(x, 0) instead of (2) above.
(iii) Finally, (3) and (4) get around the fact that the primitive recursion schema
iterates via the Ô¨Årst variable. As this example shows, this is not cast in
stone, for we can swap variables (with the help of the un
i ).
‚Ä† Some authors pronounce proper subtraction monus.

132
I. Basic Logic
One must be careful not to gloss over this last hurdle by shrugging it off:
‚ÄúWhat‚Äôs in a name?‚Äù. It is not a matter of changing names everywhere to go from
Œªxy.x
.‚àíy to Œªyx.y
.‚àíx. We actually needed to work with the Ô¨Årst variable in
the Œª-list, but (because of the nature of ‚Äú
.‚àí‚Äù) this variable should be after ‚Äú
.‚àí‚Äù.
That is, we did need d = Œªxy.y
.‚àíx.
In argot, (3) takes the simple form
x
.‚àí0 = x
x
.‚àí(y + 1) = (x
.‚àíy)
.‚àí1
The reader must have concluded (correctly) that the argot operations of per-
muting variables, identifying variables, augmenting the variable list with new
variables (also, replacing a single variable with a function application or a con-
stant) are not argot at all, but are derived ‚Äúlegal‚Äù operations of substitution (due
to Grzegorczyk (1953) ‚Äì see Exercise I.68).
Therefore, from now on we will relax our notational rigidity and beneÔ¨Åt
from the presence of these operations of substitution.
‚ñ°
I.8.18 Example. Œªxy.x + y, Œªxy.x √ó y (or, in implied multiplication notation,
Œªxy.xy), and Œªxy.x y are in PR. Let us leave the Ô¨Årst two as an easy exercise,
and deal with the third one, since it entails an important point:
x0 = 1
x y+1 = x √ó x y
The ‚Äúimportant point‚Äù is regarding the basis case, x0 = 1. We learn in ‚Äúordinary
math‚Äù that 00 is undeÔ¨Åned. If we sustain this point of view, then Œªxy.x y cannot
possibly be in PR (why?). So we re-deÔ¨Åne 00 to be 1.
One does this kind of re-deÔ¨Ånition a lot in recursion theory (it is akin to
removing removable discontinuities in calculus) when a function threatens not
to be, say, primitive recursive for trivial reasons.
A trivial corollary is that Œªx.0x ‚ààPR (why?). This is a useful function,
normally denoted by sg. Clearly,
sg(x) =
1
if x = 0
0
otherwise
We also see that sg(x) = 1
.‚àíx, which provides an alternative proof that Œªx.0x ‚àà
PR.
‚ñ°

I.8. Computability and Uncomputability
133
I.8.19 Example.
Œªxyz.
y
if x = 0
z
if x Ã∏= 0
is in PR. This function is often called the ‚Äúswitch‚Äù or ‚Äúif-then-else‚Äù, and is
sometimes denoted by the name ‚Äúsw‚Äù.
We rest our case, since
sw(0, y, z) = y
sw(x + 1, y, z) = z
We see immediately that sw(x, 1, 0) = 0x = 1
.‚àíx. The function Œªx.sw(x,
0, 1) = Œªx.1
.‚àí(1
.‚àíx) has a special symbol: ‚Äúsg‚Äù. It is often called the signum,
since it gives the sign of its argument.
‚ñ°
I.8.20 Lemma. R(‚Éóx) is in PR‚àó(respectively, R‚àó) iff, for some f ‚ààPR (res-
pectively, f ‚ààR), R(‚Éóx) ‚Üîf (‚Éóx) = 0.
Proof. Only-if part: Take f = œáR. If part: œáR = Œª‚Éóx.sg( f (‚Éóx)).
‚ñ°
I.8.21 Theorem. PR‚àó(respectively, R‚àó) is closed under replacement of vari-
ables by primitive recursive (respectively, recursive) functions.
Proof. If œáR is the characteristic function of R(‚Éóx, y, ‚Éóz) and f is a total function,
then Œª‚Éóx ‚Éów‚Éóz.œáR(‚Éóx, f ( ‚Éów), ‚Éóz) is the characteristic function of R(‚Éóx, f ( ‚Éów), ‚Éóz). (See
also Exercise I.68.)
‚ñ°
I.8.22 Theorem. PR‚àóand R‚àóare closed under Boolean connectives (‚ÄúBo-
olean operations‚Äù) and bounded quantiÔ¨Åcation.
Proof. It sufÔ¨Åces to cover ¬¨, ‚à®, (‚àÉy)<z. We are given R(‚Éóx), Q(‚Éóy), and P(y, ‚Éóx),
all in PR‚àó(or R‚àó; the argument is the same for both cases).
Case for ¬¨:
œá¬¨R = Œª‚Éóx.sg(œáR(‚Éóx)).
Case for ‚à®:
œáR‚à®Q = Œª‚Éóx‚Éóy.œáR(‚Éóx)œáQ(‚Éóy) (where we have used implied mul-
tiplication notation).
Case for (‚àÉy)<z:
To unclutter the notation, let us denote by œá‚àÉP the char-
acteristic function of (‚àÉy)<z P(y, ‚Éóx). Then
œá‚àÉP(0, ‚Éóx) = 1
œá‚àÉP(z + 1, ‚Éóx) = œáP(z, ‚Éóx)œá‚àÉP(z, ‚Éóx)
‚ñ°

134
I. Basic Logic
I.8.23 Remark. (1) The reader can convince himself that quantifying over the
Ô¨Årst variable was only for the sake of notational convenience.
(2) The case for (‚àÉy)‚â§z (and therefore for (‚àÄy)‚â§z) can be easily made:
(‚àÉy)‚â§z Q(y, ‚Éóx) ‚Üî(‚àÉy)<z+1Q(y, ‚Éóx)
(here we have used I.8.21).
‚ñ°
I.8.24 Example (Bounded Summation and Multiplication). We are collect-
ing tools that will be useful in our arithmetization of P. Two such tools are the
operations  
y<z f (y, ‚Éóx) and !
y<z f (y, ‚Éóx). Both PR and R are closed under
these operations. For example, here is the reason for !:
"
y<0
f (y, ‚Éóx) = 1
"
y<z+1
f (y, ‚Éóx) = f (z, ‚Éóx)
"
y<z
f (y, ‚Éóx)
‚ñ°
I.8.25 DeÔ¨Ånition (Bounded Search). For a total function Œªy‚Éóx.g(y, ‚Éóx) we
deÔ¨Åne for all ‚Éóx
(¬µy)<zg(y, ‚Éóx)
def
=
min{y : y < z ‚àßg(y, ‚Éóx) = 0}
z if the minimum does not exist
The symbol (¬µy)‚â§zg(y, ‚Éóx) is deÔ¨Åned to mean (¬µy)<z+1g(y, ‚Éóx).
‚ñ°
Bounded search, (¬µy)<z, searches a predetermined domain, 0, 1,. . . , z ‚àí1. If
unsuccessful, it returns the Ô¨Årst number to the right of the domain.
We extend the use of search on predicates:
I.8.26 DeÔ¨Ånition. For a predicate R(y, ‚Éóx), the symbols (¬µy)R(y, ‚Éóx), (¬µy)<z
R(y, ‚Éóx),
and
(¬µy)‚â§z R(y, ‚Éóx)
mean
(¬µy)œáR(y, ‚Éóx),
(¬µy)<zœáR(y, ‚Éóx),
and
(¬µy)‚â§zœáR(y, ‚Éóx) respectively.
‚ñ°
I.8.27 Theorem (DeÔ¨Ånition by Cases). R and PR are closed under the sche-
ma of deÔ¨Ånition by cases (below), where it is understood that the relations Ri
are mutually exclusive:
f (‚Éóx) =
Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
g1(‚Éóx)
if R1(‚Éóx)
g2(‚Éóx)
if R2(‚Éóx)
...
gk(‚Éóx)
if Rk(‚Éóx)
gk+1(‚Éóx)
otherwise

I.8. Computability and Uncomputability
135
Proof. Perhaps the simplest proof is to observe that
f (‚Éóx) = g1(‚Éóx)sg(œáR1(‚Éóx)) + ¬∑ ¬∑ ¬∑ + gk(‚Éóx)sg(œáRk(‚Éóx)) + gk+1(‚Éóx)sg(œáQ(‚Éóx))
a Ô¨Åxed-length sum, where Q ‚Üî¬¨(R1 ‚à®¬∑ ¬∑ ¬∑ ‚à®Rk).
‚ñ°
I.8.28 Theorem. R and PR are closed under bounded search.
Proof. Let g(z, ‚Éóx) = (¬µy)<z f (y, ‚Éóx). Then
g(0, ‚Éóx) = 0
g(z + 1, ‚Éóx) = if g(z, ‚Éóx) Ã∏= z then g(z, ‚Éóx)
else if f (z, ‚Éóx) = 0 then z
else z + 1
The second equation above is g(z + 1, ‚Éóx) = k(z, ‚Éóx, g(z, ‚Éóx)), where
k(z, ‚Éóx, w) = if w Ã∏= z then w
else if f (z, ‚Éóx) = 0 then z
else z + 1
Clearly k is wherever f is (in R or PR), since (see I.8.19) sw ‚ààPR.
‚ñ°
I.8.29 Proposition. The following are all primitive recursive:
(i) Œªxy.
#x
y
$ %
the quotient of the division x
y
&
(ii) Œªxy.rem(x, y)
%
the remainder of the division x
y
&
(iii) Œªxy.x|y (‚Äúx divides y‚Äù)
(iv) Pr(x) (x is a prime)
(v) Œªn.pn (the n th prime)
(vi) Œªnx. exp(n, x) (the exponent of pn in the prime factorization of x)
(vii) Seq(x) (‚Äúx‚Äôs prime number factorization contains at least one prime, but
no gaps‚Äù)
Proof. (i):
#x
y
$
= (¬µz)‚â§x((z + 1)y > x)
(1)
(1) is correct for all y Ã∏= 0. Since we do not want the quotient function to
fail primitive recursiveness for a trivial reason (we have a ‚Äúremovable
nontotalness‚Äù ‚Äì see also I.8.18), we deÔ¨Åne ‚åäx/y‚åãto equal the right hand side
of (1) at all times (of course, the right hand side is total).

136
I. Basic Logic
(ii): rem(x, y) = x
.‚àí‚åäx/y‚åãy.
(iii): x|y ‚Üîrem(y, x) = 0.
(iv): Pr(x) ‚Üîx > 1 ‚àß(‚àÄy)‚â§x(y|x ‚Üíy = 1 ‚à®y = x).
(v):
p0 = 2
pn+1 = (¬µy)‚â§22n+1 (Pr(y) ‚àßy > pn)
The above is based on Euclid‚Äôs proof that there are inÔ¨Ånitely many primes
(p0 p1 ¬∑ ¬∑ ¬∑ pn +1 is either a prime, q ‚â•pn+1, or it has a prime divisor q ‚â•pn+1)
and an induction on n that shows pn ‚â§22n.
(vi): exp(n, x) = (¬µy)‚â§x

¬¨(py+1
n
|x)

.
(vii): Seq(x) ‚Üîx > 1‚àß(‚àÄy)‚â§x(‚àÄz)‚â§x(y|x‚àßPr(y)‚àßPr(z)‚àßz < y ‚Üíz|x).
‚ñ°
I.8.30 DeÔ¨Ånition (Coding and Decoding Number Sequences). An arbitrary
(Ô¨Ånite) sequence of natural numbers a0, a1,. . . , an‚àí1 will be coded as
pa0+1
0
pa1+1
1
¬∑ ¬∑ ¬∑ pan‚àí1+1
n‚àí1
We use the notation
‚ü®a0, a1,. . . , an‚àí1‚ü©
def
=
"
y<n
p
ay+1
y
(1)
‚ñ°
In set theory one likes to denote tuples by ‚ü®a0,. . . , an‚àí1‚ü©as well, a practice
that we have been following (cf. Section I.2). To avoid notational confusion, in
those rare cases where we want to write down both a code ‚ü®a0,. . . , an‚àí1‚ü©of a
sequence a0,. . . , an‚àí1 and an n-tuple in set theory‚Äôs sense, we write the latter
in the ‚Äúold‚Äù notation, with round brackets, that is, (a0,. . . , an‚àí1).
Why ‚Äú + 1‚Äù in the exponent? Without that, all three sequences ‚Äú2‚Äù, ‚Äú2, 0‚Äù,
and ‚Äú2, 0, 0‚Äù get the same code, namely 22. This is a drawback, for if we are
given the code 22 but do not know the length of the coded sequence, then we
cannot decode 22 back into the original sequence correctly. Contrast this with
the schema (1) above, where these three examples are coded as 23, 23 ¬∑ 3 and
23 ¬∑ 3 ¬∑ 5 respectively. We see that the coding (1) above codes the length n of
the sequence a0, a1,. . . , an‚àí1 into the code z = ‚ü®a0, a1,. . . , an‚àí1‚ü©. This length
is the number of primes in the decomposition of z (of course, Seq(z) is true),
and it is useful to have a function for it, called ‚Äúlh‚Äù. There are many ways to
deÔ¨Åne a primitive recursive length function, lh, that does the job. The simplest
deÔ¨Ånition allows lh to give nonsensical answers for all inputs that do not code

I.8. Computability and Uncomputability
137
sequences. Examples of such inputs are 0, 1, 10;‚Ä† in short, any number z such
that ¬¨Seq(z). We let
lh(z) = (¬µy)‚â§z(¬¨py|z)
Clearly, lh ‚ààPR.
From all the above, we get that Seq(z) iff, for some a0, a1,. . . , an‚àí1, z =
‚ü®a0, a1,. . . , an‚àí1‚ü©(this justiÔ¨Åes the mnemonic ‚ÄúSeq‚Äù for ‚Äúsequence‚Äù).
Clearly,lh(z) = n inthiscase,and‚Ä° exp(i, z)
.‚àí1 = ai fori = 0, 1,. . . , n‚àí1
(exp(i, z)
.‚àí1 = 0 if i ‚â•n).
It is customary to use the more compact symbol
(z)i
def
= exp(i, z)
.‚àí1
Thus, if Seq(z), then the sequence (z)i, for i = 0,. . . ,lh(z)
.‚àí1, decodes z.
We will also need to express sequence concatenation primitive recursively.
We deÔ¨Åne concatenation, ‚Äú‚àó‚Äù, by
‚ü®a0,. . . , an‚àí1‚ü©‚àó‚ü®b0,. . . , bm‚àí1‚ü©
def
= ‚ü®a0,. . . , an‚àí1, b0,. . . , bm‚àí1‚ü©
(2)
Of course, for Œªxy.x ‚àóy to be in PR we must have a total function to begin
with, so that ‚Äú‚àó‚Äù must be deÔ¨Åned on all natural numbers, not on just those
satisfying Seq.
The following deÔ¨Ånition is at once seen to satisfy all our requirements:
x ‚àóy
def
= x ¬∑
"
i<lh(y)
pexp(i,y)
i+lh(x)
(3)
I.8.31 Theorem (Course-of-Values (Primitive) Recursion). Let H(x, ‚Éóyn), the
history function of f , stand for ‚ü®f (0, ‚Éóyn),. . . , f (x, ‚Éóyn)‚ü©for x ‚â•0.
Then PR and R are closed under the following schema of course-of-values
recursion:
f (0, ‚Éóyn) = h(‚Éóyn)
f (x + 1, ‚Éóyn) = g(x, ‚Éóyn, H(x, ‚Éóyn))
Proof. It follows from the (ordinary) primitive recursion
H(0, ‚Éóyn) = ‚ü®h(‚Éóyn)‚ü©
H(x + 1, ‚Éóyn) = H(x, ‚Éóyn) ‚àó‚ü®f (x + 1, ‚Éóyn)‚ü©
= H(x, ‚Éóyn) ‚àó‚ü®g(x, ‚Éóyn, H(x, ‚Éóyn))‚ü©
and f (x, ‚Éóyn) = (H(x, ‚Éóyn))x.
‚ñ°
‚Ä† Our deÔ¨Ånition gives lh(0) = 1, lh(1) = 0, lh(10) = 1.
‚Ä° Since Seq(z), we have exp(i, z)
.‚àí1 = exp(i, z) ‚àí1 for i = 0, 1,. . . , n ‚àí1.

138
I. Basic Logic
We next arithmetize P-functions and their computations. We will assign
‚Äúprogram codes‚Äù to each function. A program code ‚Äì called in the literature a
G¬®odel number, or a œÜ-index, or just an index ‚Äì is, intuitively, a number in N that
codes the ‚Äúinstructions‚Äù necessary to compute a P-function.
If i ‚ààN is a‚Ä† code for f ‚ààP, then we write
f = {i}
(Kleene‚Äôs notation)
or‚Ä°
f = œÜi
(Rogers‚Äôs (1967) notation)
Thus, either {i} or œÜi denotes the function with code i.
The following table indicates how to assign G¬®odel numbers (middle column)
to all partial recursive functions by following the deÔ¨Ånition of P. In the table,
f indicates a code of f :
Function
Code
Comment
Œªx.0
‚ü®0, 1, 0‚ü©
Œªx.x + 1
‚ü®0, 1, 1‚ü©
Œª‚Éóxn.xi
‚ü®0, n, i, 2‚ü©
1 ‚â§i ‚â§n
Composition:
‚ü®1, m, f ,g1,. . . ,gn‚ü©
f must be n-ary
f (g1(‚Éóym), . . . , gn(‚Éóym))
gi must be m-ary
Primitive recursion from
basis h and iterated part g
‚ü®2, n + 1,h,g ‚ü©
h must be n-ary
g must be (n + 2)-ary
Unbounded search:
‚ü®3, n, f ‚ü©
f must be (n + 1)-ary
(¬µy) f (y, ‚Éóxn)
and n > 0
We have been somewhat loose in our description above. ‚ÄúThe following table
indicates how to assign G¬®odel numbers (middle column) to all partial recursive
functions by following the deÔ¨Ånition of P‚Äù, we have said, perhaps leading the
reader to think that we are deÔ¨Åning the codes by recursion on P. Not so. After
all, each function has inÔ¨Ånitely many codes.
What was really involved in the table ‚Äì see also below ‚Äì was arguing back-
wards: a speciÔ¨Åcation of how we would like our œÜ-indices behave once we
‚Ä† The indeÔ¨Ånite article is appropriate here. Just as in real life a computable function has inÔ¨Ånitely
many different programs that compute it, a partial recursive function f has inÔ¨Ånitely many
different codes (see I.8.34 later on).
‚Ä° That is where the name ‚ÄúœÜ-index‚Äù comes from.

I.8. Computability and Uncomputability
139
obtained them. We now turn to showing how to actually obtain them by di-
rectly deÔ¨Åning the set of all œÜ-indices, , as an inductively deÔ¨Åned subset of
{z : Seq(z)}:
 = Cl(I , R)
where I = {‚ü®0, 1, 0‚ü©, ‚ü®0, 1, 1‚ü©} ‚à™{‚ü®0, n, i, 2‚ü©: n > 0 ‚àß1 ‚â§i ‚â§n}, and the
rule set R consists of the following three operations:
(i) Coding composition: Input a and bi (i = 1,. . . , n) causes output
‚ü®1, m, a, b1,. . . , bn‚ü©
provided (a)1 = n and (bi)1 = m, for i = 1,. . . , n.
(ii) Coding primitive recursion: Input a and b causes output
‚ü®2, n + 1, a, b‚ü©
provided (a)1 = n and (b)1 = n + 2.
(iii) Coding unbounded search: Input a causes output
‚ü®3, n, a‚ü©
provided (a)1 = n + 1 and n > 0.‚Ä†
By the uniqueness of prime number decomposition, the pair (I , R) is un-
ambiguous (see I.2.10, p. 24). Therefore we deÔ¨Åne by recursion on  (cf. I.2.13)
a total function Œªa.{a} (or Œªa.œÜa)‚Ä° for each a ‚àà:
{‚ü®0, 1, 0‚ü©} = Œªx.0
{‚ü®0, 1, 1‚ü©} = Œªx.x + 1
{‚ü®0, n, i, 2‚ü©} = Œª‚Éóxn.xi
{‚ü®1, m, a, b1,. . . , bn‚ü©} = Œª‚Éóym.{a}({b1}(‚Éóym),. . . , {bn}(‚Éóym))
{‚ü®2, n + 1, a, b‚ü©} = Œªx‚Éóyn.Prec({a}, {b})
{‚ü®3, n, a‚ü©} = Œª‚Éóxn.(¬µy){a}(y, ‚Éóxn)
In the above recursive deÔ¨Ånition we have used the abbreviation Prec({a}, {b})
for the function given (for all x, ‚Éóyn) by the primitive recursive schema (I.8.7)
with h-part {a} and g-part {b}.
We can now make the intentions implied in the above table ofÔ¨Åcial:
‚Ä† By an obvious I.H. the other cases can fend for themselves, but, here, reducing the number of
arguments must not result in 0 arguments, as we have decided not to allow 0-ary functions.
‚Ä° The input, a, is a code; the output, {a} or œÜa, is a function.

140
I. Basic Logic
I.8.32 Theorem. P = {{a} : a ‚àà}.
Proof. ‚äÜ-part: Induction on P. The table encapsulates the argument diagram-
matically.
‚äá-part: Induction on . It follows trivially from the recursive deÔ¨Ånition
of {a} and the fact that P contains the initial functions and is closed under
composition, primitive recursion, and unbounded search.
‚ñ°
I.8.33 Remark. (Important.) Thus, f ‚ààP iff for some a ‚àà, f = {a}.
‚ñ°
I.8.34 Example. Every function f ‚ààP has inÔ¨Ånitely many œÜ-indices. Indeed,
let f = { f }. Since f = Œª‚Éóxn.u1
1( f (‚Éóxn)), we obtain f = {‚ü®1, n, ‚ü®0, 1, 1, 2‚ü©, f ‚ü©}
as well. Since ‚ü®1, n, ‚ü®0, 1, 1, 2‚ü©, f ‚ü©> f , the claim follows.
‚ñ°
I.8.35 Theorem. The relation x ‚àà is primitive recursive.
Proof. Let œá denote the characteristic function of the relation ‚Äúx ‚àà‚Äù. Then
œá(0) = 1
œá(x + 1) = 0 if
x + 1 = ‚ü®0, 1, 0‚ü©‚à®x + 1 = ‚ü®0, 1, 1‚ü©‚à®
(‚àÉn, i)‚â§x(n > 0 ‚àß0 < i ‚â§n ‚àßx + 1 = ‚ü®0, n, i, 2‚ü©) ‚à®
(‚àÉa, b, m, n)‚â§x(œá(a) = 0 ‚àß(a)1 = n ‚àßSeq(b) ‚àß
lh(b) = n ‚àß(‚àÄi)<n(œá((b)i) = 0 ‚àß
((b)i)1 = m) ‚àßx + 1 = ‚ü®1, m, a‚ü©‚àób) ‚à®
(‚àÉa, b, n)‚â§x(œá(a) = 0 ‚àß(a)1 = n ‚àßœá(b) = 0 ‚àß
(b)1 = n + 2 ‚àßx + 1 = ‚ü®2, n + 1, a, b‚ü©) ‚à®
(‚àÉa, n)‚â§x(œá(a) = 0 ‚àß(a)1 = n + 1 ‚àßn > 0 ‚àß
x + 1 = ‚ü®3, n, a‚ü©)
= 1 otherwise
The above can easily be seen to be a course-of-values recursion. For example,
if H(x) = ‚ü®œá(0),. . . , œá(x)‚ü©, then an occurrence of ‚Äúœá(a) = 0‚Äù above can be
replaced by ‚Äú(H(x))a = 0‚Äù, since a ‚â§x.
‚ñ°
We think of‚Ä† a computation as a sequence of equations like {e}(‚Éóa) = b. Such an
equation is intuitively read as ‚Äúthe program e, when it runs on input ‚Éóa, produces
‚Ä† ‚ÄúWe think of‚Äù indicates our determination to avoid a rigorous deÔ¨Ånition. The integrity of our
exposition will not suffer from this.

I.8. Computability and Uncomputability
141
output b‚Äù. An equation will be legitimate iff
(i) it states an input-output relation of some initial function (i.e., (e)0 = 0), or
(ii) it states an input-output relation according to œÜ-indices e such that (e)0 ‚àà
{1, 2, 3}, using results (i.e., equations) that have already appeared in the
sequence.
For example, in order to state (¬µy){e}(y, ‚Éóan) = b ‚Äì that is, {‚ü®3, n, e‚ü©}(‚Éóan) =
b ‚Äì one must ensure that all the equations,
{e}(b, ‚Éóan) = 0, {e}(0, ‚Éóan) = r0,. . . , {e}(b ‚àí1, ‚Éóan) = rb‚àí1
where the ri‚Äôs are all non-zero, have already appeared in the sequence. In our
coding, every equation {a}(‚Éóan) = b will be denoted by a triple ‚ü®e, ‚Éóan, b‚ü©that
codes, in that order, the œÜ-index, the input, and the output. We will collect (code)
all these triples into a single code, u = ‚ü®. . . , ‚ü®e, ‚Éóan, b‚ü©, . . . ‚ü©.
Before proceeding, let us deÔ¨Åne the primitive recursive predicates
(1) Œªuv.u ‚ààv (‚Äúv is a term in the (coded) sequence u‚Äù),
(2) Œªuvw.v < uw (‚Äúv occurs before w in the (coded) sequence u‚Äù).
Primitive recursiveness follows from the equivalences
v ‚ààu ‚ÜîSeq(u) ‚àß(‚àÉi)<lh(u)(u)i = v
v < uw ‚Üîv ‚ààu ‚àßw ‚ààu ‚àß(‚àÉi, j)<lh(u)((u)i = v ‚àß(u) j = w ‚àßi < j)
We are now ready to deÔ¨Åne the relation ‚ÄúComputation(u)‚Äù which holds iff
u codes a computation according to the previous understanding. This involves a
lengthyformula.Intheinterestofreadability,commentsenclosedin{ }-brackets
are included in the left margin, to indicate the case under consideration.
Computation(u)‚ÜîSeq(u) ‚àß(‚àÄv)‚â§u[v ‚ààu ‚Üí
{Œªx.0}
(‚àÉx)‚â§uv = ‚ü®‚ü®0, 1, 0‚ü©, x, 0‚ü©‚à®
{Œªx.x + 1}
(‚àÉx)‚â§uv = ‚ü®‚ü®0, 1, 1‚ü©, x, x + 1‚ü©‚à®
{Œª‚Éóxn.xi}
(‚àÉx, n, i)‚â§u{Seq(x) ‚àßn = lh(x) ‚àßi < n‚àß
v = ‚ü®‚ü®0, n, i + 1, 2‚ü©‚ü©‚àóx ‚àó‚ü®(x)i‚ü©}‚à®
{composition}
(‚àÉx, y, f ,g, m, n, z)‚â§u{Seq(x) ‚àßSeq(y) ‚àßSeq( f )‚àß
Seq(g) ‚àßn = lh(x) ‚àßn = lh(g) ‚àßm = lh(y)‚àß
( f )1 = n ‚àß(‚àÄi)<n(Seq((g)i) ‚àß((g)i)1 = m)‚àß
v = ‚ü®‚ü®1, m, f ‚ü©‚àóg‚ü©‚àóy ‚àó‚ü®z‚ü©‚àß
‚ü®f ‚ü©‚àóx ‚àó‚ü®z‚ü©< uv‚àß
(‚àÄi)<n‚ü®(g)i‚ü©‚àóy ‚àó‚ü®(x)i‚ü©< uv}‚à®

142
I. Basic Logic
{prim. recursion}
(‚àÉx, y,h,g, n, c)‚â§u{Seq(h) ‚àß(h)1 = n ‚àßSeq(g)‚àß
(g)1 = n + 2 ‚àßSeq(y) ‚àßlh(y) = n ‚àßSeq(c)‚àß
lh(c) = x + 1 ‚àßv = ‚ü®‚ü®2, n + 1,h,g‚ü©, x‚ü©‚àóy ‚àó‚ü®(c)x‚ü©‚àß
‚ü®h‚ü©‚àóy ‚àó‚ü®(c)0‚ü©<u v ‚àß(‚àÄi)<x‚ü®g, i‚ü©‚àóy ‚àó‚ü®(c)i,
(c)i+1‚ü©< uv}‚à®
{(¬µy) f (y, ‚Éóxn)}
(‚àÉf , y, x, n,r)‚â§u{Seq( f ) ‚àß( f )1 = n + 1 ‚àßn > 0‚àß
Seq(x) ‚àßlh(x) = n ‚àßSeq(r) ‚àßlh(r) = y‚àß
v = ‚ü®‚ü®3, n, f ‚ü©‚ü©‚àóx ‚àó‚ü®y‚ü©‚àß
‚ü®f , y‚ü©‚àóx ‚àó‚ü®0‚ü©< uv‚àß
(‚àÄi)<y(‚ü®f , i‚ü©‚àóx ‚àó‚ü®(r)i‚ü©< uv ‚àß(r)i > 0)}]
Clearly, the formula to the right of ‚Äú‚Üî‚Äù above we see that Computation(u) is
primitive recursive.
I.8.36 DeÔ¨Ånition (The Kleene T -Predicate). For each n ‚ààN, T (n)(a, ‚Éóxn, z)
stands for Computation((z)1) ‚àß‚ü®a, ‚Éóxn, (z)0‚ü©‚àà(z)1.
‚ñ°
The above discussion yields immediately:
I.8.37 Theorem (Kleene Normal Form Theorem).
(1) y = {a}(‚Éóxn) ‚â°(‚àÉz)(T (n)(a, ‚Éóxn, z) ‚àß(z)0 = y).
(2) {a}(‚Éóxn) = ((¬µz)T (n)(a, ‚Éóxn, z))0.
(3) {a}(‚Éóxn) ‚Üì‚â°(‚àÉz)T (n)(a, ‚Éóxn, z).
I.8.38 Remark. (Very important.) The right hand side of I.8.37(2) above is
meaningful for all a ‚ààN, while the left hand side is only meaningful for a ‚àà.
We now extend the symbols {a} and œÜa to be meaningful for all a ‚ààN. In
all cases, the meaning is given by the right hand side of (2).
Of course, if a Ã∏‚àà, then (¬µz)T (n)(a, ‚Éóxn, z) ‚Üëfor all ‚Éóxn, since T (n)(a, ‚Éóxn, z)
will be false under the circumstances. Hence also {a}(‚Éóxn) ‚Üë, as it should be
intuitively: In computer programmer‚Äôs jargon, ‚Äúif the program a is syntactically
incorrect, then it will not run, for it will not even compile. Thus, it will deÔ¨Åne
the everywhere undeÔ¨Åned function‚Äù.
By the above, I.8.33 now is strengthened to read ‚Äúthus, f ‚ààP iff for some
a ‚ààN, f = {a}‚Äù.
‚ñ°
We can now deÔ¨Åne a P-counterpart to R‚àóand PR‚àóand consider its closure
properties.

I.8. Computability and Uncomputability
143
I.8.39 DeÔ¨Ånition (Semi-recursive Relations or Predicates). A relation P(‚Éóx)
is semi-recursive iff for some f ‚ààP, the equivalence
P(‚Éóx) ‚Üîf (‚Éóx) ‚Üì
(1)
holds (for all ‚Éóx, of course). Equivalently, we can state that P = dom( f ).
The set of all semi-recursive relations is denoted by P‚àó.‚Ä†
If f = {a} in (1) above, then we say that a is a semi-recursive index of P.
If P has one argument (i.e., P ‚äÜN) and a is one of its semi-recursive
indices, then we write P = Wa (Rogers (1967)).
We have at once
I.8.40 Corollary (Normal Form Theorem for Semi-recursive Relations).
P(‚Éóxn) ‚ààP‚àóiff, for some a ‚ààN,
P(‚Éóxn) ‚Üî(‚àÉz)T (n)(a, ‚Éóxn, z)
Proof. By deÔ¨Ånition (and Theorem I.8.32 along with Remark I.8.38), P(‚Éóxn) ‚àà
P‚àóiff, for some a ‚ààN, P(‚Éóxn) ‚Üî{a}(‚Éóxn) ‚Üì. Now invoke I.8.37(3).
‚ñ°
Rephrasing the above (hiding the ‚Äúa‚Äù, and remembering that PR‚àó‚äÜR‚àó)
we have
I.8.41 Corollary (Strong Projection Theorem). P(‚Éóxn) ‚ààP‚àóiff, for some
Q(‚Éóxn, z) ‚ààR‚àó,
P(‚Éóxn) ‚Üî(‚àÉz)Q(‚Éóxn, z)
Proof. Fortheonly-ifparttake Q(‚Éóxn, z)tobeŒª‚Éóxnz.T (n)(a, ‚Éóxn, z)forappropriate
a ‚ààN. For the if part take f = Œª‚Éóxn.(¬µz)Q(‚Éóxn, z). Then f ‚ààP and P(‚Éóxn) ‚Üî
f (‚Éóxn) ‚Üì.
‚ñ°
Here is a characterization of P‚àóthat is identical in form to the characteriza-
tions of PR‚àóand R‚àó(Lemma I.8.20).
I.8.42 Corollary. P(‚Éóxn) ‚ààP‚àóiff, for some f ‚ààP,
P(‚Éóxn) ‚Üîf (‚Éóxn) = 0
‚Ä† We are making this symbol up (it is not standard in the literature). We are motivated by comparing
the contents of I.8.20 and of I.8.42 below.

144
I. Basic Logic
Proof. Only-if part: Say P(‚Éóxn) ‚Üîg(‚Éóxn) ‚Üì. Take f = Œª‚Éóxn.0 ¬∑ g(‚Éóxn).
If part: Let f = {a}. By I.8.37(1), f (‚Éóxn) = 0 ‚Üî(‚àÉz)(T (n)(a, ‚Éóxn, z)‚àß(z)0 =
0). We are done by strong projection.
‚ñ°
The usual call-by-value semantics of f (g(‚Éóx), ‚Éóy) require divergence if g(‚Éóx) ‚Üë.
That is, before we embark on calculating the value of f (g(‚Éóx), ‚Éóy),we require the
values of all the inputs. In particular, 0 ¬∑ g(‚Éóxn) ‚Üëiff g(‚Éóxn) ‚Üë.
Of course, ‚Äú0¬∑ g(‚Éóxn)‚Äù is convenient notation. If we set {b} = g, we can write
instead
((¬µz)(T (n)(b, ‚Éóxn, (z)1) ‚àß(z)0 = 0))0
We immediately obtain
I.8.43 Corollary. R‚àó‚äÜP‚àó.
Intuitively, for a predicate R ‚ààR‚àówe have an algorithm (that computes œáR)
that for any input ‚Éóx will halt and answer ‚Äúyes‚Äù ( = 0) or ‚Äúno‚Äù ( = 1) to the
question ‚Äú‚Éóx ‚ààR?‚Äù
For a predicate Q ‚ààP‚àówe are only guaranteed the existence of a weaker
algorithm (for f ‚ààP such that dom( f ) = Q). It will halt iff the answer to the
question ‚Äú‚Éóx ‚ààQ?‚Äù is ‚Äúyes‚Äù (and halting will amount to ‚Äúyes‚Äù). If the answer
is ‚Äúno‚Äù, it will never tell, because it will (as we say for non-halting) ‚Äúloop for
ever‚Äù (or diverge). Hence the name ‚Äúsemi-recursive‚Äù for such predicates.
I.8.44 Theorem. R ‚ààR‚àóiff both R and ¬¨R are in P‚àó.
Proof. Only-if part. By I.8.43 and closure of R‚àóunder ¬¨.
If part. Let i and j be semi-recursive indices of R and ¬¨R respectively, that
is,
R(‚Éóxn) ‚Üî(‚àÉz)T (n)(i, ‚Éóxn, z)
¬¨R(‚Éóxn) ‚Üî(‚àÉz)T (n)( j, ‚Éóxn, z)
DeÔ¨Åne
g = Œª‚Éóxn.(¬µz)(T (n)(i, ‚Éóxn, z) ‚à®T (n)( j, ‚Éóxn, z))
Trivially, g ‚ààP. Hence, g ‚ààR, since it is total (why?). We are done by noticing
that R(‚Éóxn) ‚ÜîT (n)(i, ‚Éóxn, g(‚Éóxn)).
‚ñ°
I.8.45 DeÔ¨Ånition (Unsolvable Problems; Halting Problem). A problem is a
question ‚Äú‚Éóx ‚ààR?‚Äù for any predicate R. ‚ÄúThe problem ‚Éóx ‚ààR is recursively

I.8. Computability and Uncomputability
145
unsolvable‚Äù, or just ‚Äúunsolvable‚Äù, means that R Ã∏‚ààR‚àó, that is, intuitively, there
is no algorithmic solution to the problem.
The halting problem has central signiÔ¨Åcance in recursion theory. It is the
question whether program x will ever halt if it starts computing on input x.
That is, setting K = {x : {x}(x) ‚Üì} we can then ask ‚Äúx ‚ààK?‚Äù. This question is
the halting problem.‚Ä† We denote the complement of K by K. We will refer to
K as the halting set.
I.8.46 Theorem (Unsolvability of the Halting Problem). The halting prob-
lem is unsolvable.
Proof. It sufÔ¨Åces to show that K is not semi-recursive. Suppose instead that i
is a semi-recursive index of the set. Thus,
x ‚ààK ‚Üî(‚àÉz)T (1)(i, x, z)
or, making the part x ‚ààK ‚Äì that is, {x}(x) ‚Üë‚Äì explicit,
¬¨(‚àÉz)T (1)(x, x, z) ‚Üî(‚àÉz)T (1)(i, x, z)
(1)
Substituting i into x in (1), we get a contradiction.
‚ñ°
I.8.47 Remark. Let us look at the above in the light of Wa-notation (p. 143).
Now, {x}(x) ‚Üëiff x /‚ààWx; thus we want to show
¬¨(‚àÉi)(Wi = {x : x /‚ààWx})
(2)
(2) says ‚Äú{x : x /‚ààWx} is not a Wi‚Äù. Well, if (2) is false, then, for some i,
x ‚ààWi ‚Üîx /‚ààWx
and hence
i ‚ààWi ‚Üîi /‚ààWi
‚Äì a contradiction. This is a classic application of Cantor diagonalization‚Ä° and
is formally the same argument as in Russell‚Äôs paradox, according to which
{x : x /‚ààx} is not a set ‚Äì just omit the symbol ‚ÄúW‚Äù throughout.
The analogy is more than morphological: Our argument shows that {x : x /‚àà
Wx} is not an object of the same type as the rightmost object in the { } brackets.
‚Ä† ‚ÄúK‚Äù is a reasonably well-reserved symbol for the set {x : {x}(x) ‚Üì}. Unfortunately, K is also
used for the Ô¨Årst projection of a pairing function, but the context easily decides which is which.
‚Ä° Cantor‚Äôs theorem showed that if (Xa)a‚ààI is a family of sets, then {a : a /‚ààXa} is not an ‚ÄúXi‚Äù ‚Äì
it is not in the family ‚Äì for otherwise i ‚ààXi iff i /‚ààXi.

146
I. Basic Logic
Russell‚Äôs argument too shows that {x : x /‚ààx} is not an object of the same
type as the rightmost object in the { } brackets. That is, unlike x, it is not
a set.
‚ñ°
K ‚ààP‚àó, of course, since {x}(x) ‚Üì‚Üî(‚àÉz)T (1)(x, x, z). We conclude that the
inclusion R‚àó‚äÜP‚àóis proper, i.e., R‚àó‚äÇP‚àó.
I.8.48 Theorem (Closure Properties of P‚àó). P‚àóis closed under ‚à®, ‚àß, (‚àÉy)<z,
(‚àÉy), (‚àÄy)<z. It is not closed under either ¬¨ or (‚àÄy).
Proof. We will rely on the normal form theorem for semi-recursive relations
and the strong projection theorem.
Given semi-recursive relations P(‚Éóxn), Q(‚Éóym), and R(y, ‚Éóuk) of semi-recursive
indices p, q,r respectively.
‚à®:
P(‚Éóxn) ‚à®Q(‚Éóym) ‚Üî(‚àÉz)T (n)(p, ‚Éóxn, z) ‚à®(‚àÉz)T (m)(q, ‚Éóym, z)
‚Üî(‚àÉz)

T (n)(p, ‚Éóxn, z) ‚à®T (m)(q, ‚Éóym, z)

‚àß:
P(‚Éóxn) ‚àßQ(‚Éóym) ‚Üî(‚àÉz)T (n)(p, ‚Éóxn, z) ‚àß(‚àÉz)T (m)(q, ‚Éóym, z)
‚Üî(‚àÉw)

(‚àÉz)<wT (n)(p, ‚Éóxn, z) ‚àß(‚àÉz)<wT (m)(q, ‚Éóym, z)

Breaking the pattern established by the proof for ‚à®, we may suggest a simpler
proof for ‚àß: P(‚Éóxn) ‚àßQ(‚Éóym) ‚Üî((¬µz)T (n)(p, ‚Éóxn, z) + (¬µz)T (m)(q, ‚Éóym, z)) ‚Üì.
Yet another proof, involving the decoding function Œªiz.(z)i is
P(‚Éóxn) ‚àßQ(‚Éóym) ‚Üî(‚àÉz)T (n)(p, ‚Éóxn, z) ‚àß(‚àÉz)T (m)(q, ‚Éóym, z)
‚Üî(‚àÉz)

T (n)(p, ‚Éóxn, (z)0) ‚àßT (m)(q, ‚Éóym, (z)1)

There is a technical reason (to manifest itself in II.4.6) that we want to avoid
‚Äúcomplicated‚Äù functions like Œªiz.(z)i in the proof.
(‚àÉy)<z:
(‚àÉy)<z R(y, ‚Éóuk) ‚Üî(‚àÉy)<z(‚àÉw)T (k+1)(r, y, ‚Éóuk, w)
‚Üî(‚àÉw)(‚àÉy)<zT (k+1)(r, y, ‚Éóuk, w)
(‚àÉy):
(‚àÉy)R(y, ‚Éóuk) ‚Üî(‚àÉy)(‚àÉw)T (k+1)(r, y, ‚Éóuk, w)
‚Üî(‚àÉz)(‚àÉy)<z(‚àÉw)<zT (k+1)(r, y, ‚Éóuk, w)

I.8. Computability and Uncomputability
147
Both of the ‚àÉ-cases can be handled by the decoding function Œªiz.(z)i. For
example,
(‚àÉy)R(y, ‚Éóuk) ‚Üî(‚àÉy)(‚àÉw)T (k+1)(r, y, ‚Éóuk, w)
‚Üî(‚àÉz)T (k+1)(r, (z)0, ‚Éóuk, (z)1)
(‚àÄy)<z:
(‚àÄy)<z R(y, ‚Éóuk) ‚Üî(‚àÄy)<z(‚àÉw)T (k+1)(r, y, ‚Éóuk, w)
‚Üî(‚àÉv)(‚àÄy)<z(‚àÉw)<vT (k+1)(r, y, ‚Éóuk, w)
Think of v above as the successor (+1) of the maximum of some set of w-
values, w0,. . . , wz‚àí1, that ‚Äúwork‚Äù for y = 0,. . . , z ‚àí1 respectively. The usual
overkill proof of the above involves (z)i (or some such decoding scheme) as
follows:
(‚àÄy)<z R(y, ‚Éóuk) ‚Üî(‚àÄy)<z(‚àÉw)T (k+1)(r, y, ‚Éóuk, w)
‚Üî(‚àÉw)(‚àÄy)<zT (k+1)(r, y, ‚Éóuk, (w)y)
Regarding closure under ¬¨ and ‚àÄy, K provides a counterexample to ¬¨, and
¬¨T (1)(x, x, y) provides a counterexample to ‚àÄy.
‚ñ°
I.8.49 Remark (Projection Theorem). That P‚àóis closed under (‚àÉy) is the
content of the (weak) projection theorem.
‚ñ°
I.8.50 DeÔ¨Ånition (Recursively Enumerable Predicates). A predicate R(‚Éóxn)
is recursively enumerable (r.e.) iff R = ‚àÖor, for some f ‚ààR of one variable,
R = {(‚Éóxn) : (‚àÉm) f (m) = ‚ü®‚Éóxn‚ü©},‚Ä† or, equivalently,
R(‚Éóxn) ‚Üî(‚àÉm) f (m) = ‚ü®‚Éóxn‚ü©
(1)
‚ñ°
By (1) and strong projection (I.8.41), every r.e. relation is semi-recursive.
The converse is also true.
I.8.51 Theorem. Every semi-recursive R is r.e.
Proof. Let a be a semi-recursive index of R. If R = ‚àÖ, then we are done.
Suppose then R(‚Éóan) for some ‚Éóan. We deÔ¨Åne a function f by cases:
f (m) =
‚ü®(m)0,. . . , (m)n‚àí1‚ü©
if T (n)(a, (m)0,. . . , (m)n‚àí1, (m)n)
‚ü®‚Éóan‚ü©
otherwise
It is trivial that f is recursive and satisÔ¨Åes (1) above. Indeed, our f is
in PR.
‚ñ°
‚Ä† Cf. comment regarding rare use of round brackets for n-tuples, p. 136.

148
I. Basic Logic
Suppose that i codes a program that acts on input variables x and y to
compute a function Œªxy. f (x, y). It is certainly trivial to modify the program
to compute Œªx. f (x, a) instead: In computer programming terms, we simply
replace an instruction such as ‚Äúread y‚Äù by one that says ‚Äúy := a‚Äù (copy the
value of a into y). From the original code, a new code (depending on i and a)
ought to be trivially calculable.
This is the essence of Kleene‚Äôs iteration or S-m-n theorem below.
I.8.52 Theorem (Kleene‚Äôs Iteration or S-m-n Theorem). There is a primitive
recursive function Œªxy.œÉ(x, y) such that for all i, x, y,
{i}(‚ü®x, y‚ü©) = {œÉ(i, y)}(x)
Proof. Let a be a œÜ-index of Œªx.‚ü®x, 0‚ü©, and b a œÜ-index of Œªx.3x. Next we Ô¨Ånd
a primitive recursive Œªy.h(y) such that for all x and y
{h(y)}(x) = ‚ü®x, y‚ü©
(‚àó)
To achieve this observe that
‚ü®x, 0‚ü©= {a}(x)
and
‚ü®x, y + 1‚ü©= 3‚ü®x, y‚ü©= {b}(‚ü®x, y‚ü©)
Thus, it sufÔ¨Åces to take
h(0) = a
h(y + 1) = ‚ü®1, 1, b, h(y)‚ü©
Now that we have an h satisfying (‚àó), we note that
œÉ(i, y)
def
= ‚ü®1, 1, i, h(y)‚ü©
will do.
‚ñ°
I.8.53 Corollary. There is a primitive recursive function Œªiy.k(i, y) such that,
for all i, x, y,
{i}(x, y) = {k(i, y)}(x)
Proof. Let a0 and a1 be œÜ-indices of Œªz.(z)0 and Œªz.(z)1 respectively. Then
{i}((z)0, (z)1) = {‚ü®1, 1, i, a0, a1‚ü©}(z) for all z, i. Take k(i, y) = œÉ(‚ü®1, 1, i, a0,
a1‚ü©, y).
‚ñ°

I.8. Computability and Uncomputability
149
I.8.54 Corollary. There is for each m > 0 and n > 0 a primitive recursive
function Œªi ‚Éóyn.Sm
n (i, ‚Éóyn) such that, for all i, ‚Éóxm, ‚Éóyn,
{i}(‚Éóxm, ‚Éóyn) = {Sm
n (i, ‚Éóyn)}(‚Éóxm)
Proof. Let ar (r = 0,. . . , m ‚àí1) and br (r = 0,. . . , n ‚àí1) be œÜ-indices so that
{ar} = Œªxy.(x)r (r = 0,. . . , m ‚àí1) and {br} = Œªxy.(y)r (r = 0,. . . , n ‚àí1).
Set c(i) = ‚ü®1, 2, i, a0,. . . , am‚àí1, b0,. . . , bn‚àí1‚ü©, for all i ‚ààN, and let d be a
œÜ-index of Œª‚Éóxm.‚ü®‚Éóxm‚ü©. Then,
{i}(‚Éóxm, ‚Éóyn) = {c(i)}(‚ü®‚Éóxm‚ü©, ‚ü®‚Éóyn‚ü©)
= {k(c(i), ‚ü®‚Éóyn‚ü©)}(‚ü®‚Éóxm‚ü©)
by I.8.53
= {‚ü®1, m, k(c(i), ‚ü®‚Éóyn‚ü©), d‚ü©}(‚Éóxm)
Take Œªi ‚Éóyn.Sm
n = ‚ü®1, m, k(c(i), ‚ü®‚Éóyn‚ü©), d‚ü©.
‚ñ°
Since P-functions are closed under permutation of variables, there is no signi-
Ô¨Åcance (other than notational convenience, and a random left vs. right choice)
in presenting the S-m-n theorem in terms of a ‚Äúneat‚Äù left-right partition of the
variable list. Any variable sub-list can be parametrized.
I.8.55 Corollary (Kleene‚Äôs Recursion Theorem). If Œªz‚Éóx. f (z, ‚Éóxn) ‚ààP, then
for some e,
{e}(‚Éóxn) = f (e, ‚Éóxn)
for all ‚Éóxn
Proof. Let {a} = Œªz‚Éóxn. f

Sn
1(z, z), ‚Éóxn

. Then
f

Sn
1(a, a), ‚Éóxn

= {a}(a, ‚Éóxn)
=

Sn
1(a, a)

(‚Éóxn)
by I.8.54
Take e = Sn
1(a, a).
‚ñ°
I.8.56 DeÔ¨Ånition. A complete index set is a set A = {x : {x} ‚ààQ} for some
Q ‚äÜP.
A is trivial iff A = ‚àÖor A = N (correspondingly, Q = ‚àÖor Q = P).
Otherwise it is non-trivial.
‚ñ°
I.8.57 Theorem (Rice). A complete index set is recursive iff it is trivial.
Thus, algorithmically we can only decide trivial properties of programs.

150
I. Basic Logic
Proof. (The idea of this proof is attributed in Rogers (1967) to G. C. Wolpin.)
If part: Immediate, since œá‚àÖ= Œªx.1 and œáN = Œªx.0.
Only-if part: By contradiction, suppose that A = {x : {x} ‚ààQ} is non-
trivial, yet A ‚ààR‚àó. So let a ‚ààA and b /‚ààA. DeÔ¨Åne f by
f (x) =
b
if x ‚ààA
a
if x /‚ààA
Clearly,
x ‚ààA iff f (x) /‚ààA,
for all x
(1)
By the recursion theorem, there is an e such that { f (e)} = {e} (apply I.8.55 to
Œªxy.{ f (x)}(y)).
Thus, e ‚ààA iff f (e) ‚ààA, contradicting (1).
‚ñ°
A few more applications of the recursion theorem will be found in the
Exercises.
I.8.58 Example. Every function of P has inÔ¨Ånitely many indices (revisited).
For suppose not, and let A = {x : {x} ‚ààQ} be Ô¨Ånite, where Q = { f }. Then A
is recursive (why?), contradicting Rice‚Äôs theorem.
‚ñ°
We have seen that progressing along PR‚àó, R‚àó, P‚àówe obtain strictly more
inclusive sets of relations, or, intuitively, progressively more ‚Äúcomplex‚Äù predi-
cates. For example, we can easily ‚Äúsolve‚Äù Œªxy.x < y, we can only ‚Äúhalf‚Äù solve
x ‚ààK, and we cannot even do that for x /‚ààK. The latter is beyond P‚àó. Still,
all three are ‚Äúarithmetic‚Äù‚Ä† or ‚Äúarithmetical‚Äù predicates in a sense that we make
precise below. The interest immediately arises to classify arithmetic predicates
according to increasing ‚Äúcomplexity‚Äù. This leads to the arithmetic(al) hierarchy
of Kleene and Mostowski.
I.8.59 DeÔ¨Ånition. The set of all arithmetic(al)‚Ä° predicates is the least set
that includes R‚àóand is closed under (‚àÉx) and (‚àÄx). We will denote this set
by .
‚ñ°
‚Ä† Accent on ‚Äúmet‚Äù.
‚Ä° We will adhere to the term ‚Äúarithmetic‚Äù, as in Smullyan (1992). The reader will note that these
predicates are introduced in two different ways in Smullyan (1992), each different from the
above. One is indicated by a capital ‚ÄúA‚Äù and the other by a lowercase ‚Äúa‚Äù. All three deÔ¨Ånitions are
equivalent. We follow the standard deÔ¨Ånition given in works in recursion theory (Rogers (1967),
Hinman (1978), Tourlakis (1984)).

I.8. Computability and Uncomputability
151
We sort arithmetic relations into a hierarchy as follows (Kleene (1943),
Mostowski (1947)).
I.8.60 DeÔ¨Ånition (The Arithmetic Hierarchy). We deÔ¨Åne by induction on
n ‚ààN:
0 = 0 = R‚àó
n+1 = {(‚àÉx)P : P ‚ààn}
n+1 = {(‚àÄx)P : P ‚ààn}
The variable ‚Äúx‚Äù above is generic.
We also deÔ¨Åne, for all n, n = n ‚à©n and also set ‚àû= 
n‚â•0(n ‚à™n).
‚ñ°
I.8.61Remark. Intuitively,thearithmetichierarchyiscomposedofallrelations
of the form (Q1x1)(Q2x2) . . . (Qnxn)R, where R ‚ààR‚àóand Qi ‚àà{‚àÉ, ‚àÄ} for
i = 1, . . . , n. If n = 0 there is no quantiÔ¨Åer preÔ¨Åx. Since ‚àÉx‚àÉy and ‚àÄx‚àÄy can
be ‚Äúcollapsed‚Äù into a single ‚àÉand single ‚àÄrespectively,
Pause. Do you believe this?
one can think of the preÔ¨Åx as a sequence of alternating quantiÔ¨Åers. The relation
is placed in a -set (respectively, -set) iff the leftmost quantiÔ¨Åer is a ‚Äú‚àÄ‚Äù
(respectively, ‚Äú‚àÉ‚Äù).
‚ñ°
I.8.62 Lemma. R ‚ààn iff (¬¨R) ‚ààn. R ‚ààn iff (¬¨R) ‚ààn.
Proof. We handle both equivalences simultaneously. For n = 0 this is so by
closure properties of R‚àó.
Assuming the claim for n, we have
R ‚ààn+1 iff R ‚Üî(‚àÉy)Q and Q ‚ààn
iff (I.H.)R ‚Üî¬¨(‚àÄy)¬¨Q and (¬¨Q) ‚ààn
iff ¬¨R ‚Üî(‚àÄy)¬¨Q and (¬¨Q) ‚ààn
iff ¬¨R ‚ààn+1
and
R ‚ààn+1 iff R ‚Üî(‚àÄy)Q and Q ‚ààn
iff (I.H.) R ‚Üî¬¨(‚àÉy)¬¨Q and (¬¨Q) ‚ààn
iff ¬¨R ‚Üî(‚àÉy)¬¨Q and (¬¨Q) ‚ààn
iff ¬¨R ‚ààn+1
‚ñ°

152
I. Basic Logic
It is trivial that ‚àû‚äÜ. The following easy lemma yields the converse
inclusion as a corollary.
I.8.63 Lemma. We have the following closure properties:
‚àû
is closed under (1)‚Äì(6) from the following list.
n (n ‚â•0)
is closed under (1)‚Äì(4).
n (n ‚â•0)
is closed under (1)‚Äì(3), and, if n > 0, also (5).
n (n ‚â•0)
is closed under (1)‚Äì(3), and, if n > 0, also (6).
(1) Replacement of a variable by a recursive function‚Ä†
(2) ‚à®, ‚àß
(3) (‚àÉy)<z, (‚àÄy)<z
(4) ¬¨
(5) (‚àÉy)
(6) (‚àÄy)
Proof. (1) follows from the corresponding closure of R‚àó. The rest follow at
once from I.8.60 and the techniques of I.8.48 ((4) also uses I.8.62).
‚ñ°
I.8.64 Corollary.  = ‚àû. Hence, DeÔ¨Ånition I.8.60 classiÔ¨Åes all arithmetic
predicates according to deÔ¨Ånitional complexity.
We next see that the complexity of arithmetic predicates increases in more
than just ‚Äúform‚Äù as n increases (i.e., as the form ‚Äú(Q1x1)(Q2x2) . . . (Qnxn)R‚Äù
gets more complex with a longer alternating quantiÔ¨Åer preÔ¨Åx, we do get new
predicates deÔ¨Åned).
I.8.65 Proposition. n ‚à™n ‚äÜn+1 for n ‚â•0.
Proof. Induction on n.
Basis. For n = 0, n ‚à™n = R‚àó. On the other hand, 1 = P‚àó(why?), while
(by I.8.62) 1 = {Q : (¬¨Q) ‚ààP‚àó}. Thus 1 = 1 ‚à©1 = R‚àóby I.8.44.
We consider now the n +1 case (under the obvious I.H.). Let R(‚Éóxr) ‚ààn+1.
Then, by I.8.63(1), so is Œªz‚Éóxr.R(‚Éóxr), where z is not among the ‚Éóxr. Now, R ‚Üî
(‚àÄz)R, but (‚àÄz)R ‚ààn+2.
‚Ä† Since un
i , Œªx.0, and Œªx.x + 1 are recursive, this allows the full range of the Grzegorczyk substi-
tutions (Exercise I.68), i.e., additionally to function substitution, also expansion of the variable
list, permutation of the variable list, identiÔ¨Åcation of variables, and substitution of constants into
variables.

I.8. Computability and Uncomputability
153
Next, let R(‚Éóxr) ‚Üî(‚àÉz)Q(z, ‚Éóxr), where Q ‚ààn. By the I.H., Q ‚ààn+1;
hence Q ‚ààn+1. Thus, R ‚ààn+2.
The argument is similar if we start the previous sentence with ‚ÄúLet R(‚Éóxr) ‚àà
n+1‚Äù.
‚ñ°
I.8.66 Corollary. n ‚äÜn+1 and n ‚äÜn+1, for n ‚â•0.
I.8.67 Corollary. n ‚äÜn+1 for n ‚â•0.
We next sharpen the inclusions above to proper inclusions.
I.8.68 DeÔ¨Ånition (Kleene). For n ‚â•1 we deÔ¨Åne Œªxy.En(x, y) by induction:
E1(x, y) ‚Üî(‚àÉz)T (1)(x, y, z)
En+1(x, y) ‚Üî(‚àÉz)¬¨En(x, ‚ü®z‚ü©‚àóy)
where ‚Äú‚ü®‚ü©‚Äù is our standard coding of p. 136.
‚ñ°
Of course, ‚ü®z‚ü©= 2z+1.
I.8.69 Lemma. En ‚ààn and ¬¨En ‚ààn, for n ‚â•1.
Proof. A trivial induction (via I.8.62 and I.8.63).
‚ñ°
I.8.70 Theorem (Enumeration or Indexing Theorem (Kleene)).
(1) R(‚Éóxr) ‚ààn+1 iff R(‚Éóxr) ‚ÜîEn+1(i, ‚ü®‚Éóxr‚ü©) for some i.
(2) R(‚Éóxr) ‚ààn+1 iff R(‚Éóxr) ‚Üî¬¨En+1(i, ‚ü®‚Éóxr‚ü©) for some i.
Proof. The if part is Lemma I.8.69 (with the help of I.8.63(1)). We prove the
only-if part ((1) and (2) simultaneously) by induction on n.
Basis. n = 0. If R(‚Éóxr) ‚àà1 = P‚àó, then so is R((u)0, . . . , (u)r‚àí1). Thus, for
some i (semi-recursive index), R((u)0, . . . , (u)r‚àí1) ‚Üî(‚àÉz)T (1)(i, u, z); hence
R(‚Éóxr) ‚Üî(‚àÉz)T (1)(i, ‚ü®‚Éóxr‚ü©, z) ‚ÜîE1(i, ‚ü®‚Éóxr‚ü©).
If R(‚Éóxr) ‚àà1, then (¬¨R(‚Éóxr)) ‚àà1 = P‚àó. Thus, for some e, ¬¨R(‚Éóxr) ‚Üî
E1(e, ‚ü®‚Éóxr‚ü©); hence R(‚Éóxr) ‚Üî¬¨E1(e, ‚ü®‚Éóxr‚ü©).
The induction step. (Based on the obvious I.H.) Let R(‚Éóxr) ‚ààn+2. Then
R(‚Éóxr) ‚Üî(‚àÉz)Q(z, ‚Éóxr), where Q ‚ààn+1, hence (I.H.)
Q(z, ‚Éóxr) ‚Üî¬¨En+1(e, ‚ü®z, ‚Éóxr‚ü©)
for some e
(i)

154
I. Basic Logic
Since ‚ü®z, ‚Éóxr‚ü©= ‚ü®z‚ü©‚àó‚ü®‚Éóxr‚ü©, (i) yields
R(‚Éóxr) ‚Üî(‚àÉz)¬¨En+1(e, ‚ü®z‚ü©‚àó‚ü®‚Éóxr‚ü©)
‚ÜîEn+2(e, ‚ü®‚Éóxr‚ü©)
(by the deÔ¨Ånition of En+2)
An entirely analogous argument takes care of ‚ÄúLet R(‚Éóxr) ‚ààn+2‚Äù.
‚ñ°
I.8.71 Corollary. The same set of arithmetic relations, , can be deÔ¨Åned by
setting 0 = 0 = PR‚àó. Indeed, no sets in the hierarchy are affected by this
change, except 0 = 0.
I.8.72 Theorem (Hierarchy Theorem (Kleene, Mostowski)).
(1) n+1 ‚àín+1 Ã∏= ‚àÖ,
(2) n+1 ‚àín+1 Ã∏= ‚àÖ.
Moreover, all the inclusions in I.8.65 (n > 0), I.8.66 (n ‚â•0), and I.8.67 (n > 0)
are proper.
Proof. (1): En+1 ‚ààn+1 ‚àín+1. Indeed (see also I.8.69), if En+1 ‚ààn+1,
then
En+1(x, ‚ü®x‚ü©) ‚Üî¬¨En+1(i, ‚ü®x‚ü©)
(1‚Ä≤)
for some i (I.8.63(1) and, I.8.70). Letting x = i in (1‚Ä≤), we get a contradiction.
(2): As in (1), but use ¬¨En+1 as the counterexample.
For I.8.65: Let R(x, y) ‚ÜîEn(x, ‚ü®x‚ü©) ‚à®¬¨En(y, ‚ü®y‚ü©). Since En ‚ààn and
(¬¨En) ‚ààn, I.8.63(1), I.8.65, and closure of n+1 under ‚à®yield R ‚ààn+1.
Let x0 and y0 be such that En(x0, ‚ü®x0‚ü©) is false and En(y0, ‚ü®y0‚ü©) is true (if no
such x0, y0 exist, then En is recursive (why?); not so for n > 0 (why?)).
Now, R /‚ààn ‚à™n, for, otherwise, say it is in n. Then so is R(x0, y) (that
is, ¬¨En(y, ‚ü®y‚ü©)), which is absurd. Similarly, if R ‚ààn, we are led to the absurd
conclusion that R(x, y0) ‚ààn.
For I.8.66: K ‚àà1 ‚àí0. For n > 0, n = n+1 implies n = n+1
(why?); hence n ‚à™n = n+1 ‚à™n+1 ‚äán+1 ‚à©n+1 = n+1; thus
n ‚à™n = n+1 by I.8.65, contrary to what we have just established above.
Similarly for the dual n vs. n+1.
For I.8.67: If n+1 = n, then n+1 = n ‚à©n ‚äÜn ‚à™n, which has
been established as an absurdity for n > 0.
‚ñ°

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 155
I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness
In this section we apply recursion-theoretic techniques to the proof theory
of a certain axiomatic arithmetic in order to derive a major result (G¬®odel‚Äôs
Ô¨Årst incompleteness theorem) regarding the inadequacy of the syntactic proof
apparatus.
We have to overcome a small obstacle outright: Our recursion theory is
a theory of number-theoretic functions and relations. We need some way to
translate its results in the realm of strings (over some alphabet) so that our theory
can handle recursive, r.e., primitive recursive, etc., functions and predicates
that have inputs and outputs that are such strings. For example, a recursively
axiomatized theory, we say, is one with a recursive set of axioms. But what do
we mean by a recursive set of strings?
Well, we can code strings by numbers, and then use the numbers as proxies
for the strings. This is the essence of G¬®odel numbering, invented by G¬®odel
(1931) towards that end.
Given a Ô¨Ånite alphabet V . We denote by V ‚àóthe set of all strings over V .
We use the term ‚ÄúG¬®odel-numbering‚Äù for any 1-1 (not necessarily onto) function
f : V ‚àó‚ÜíN that is intuitively computable. More precisely, we want to have
two algorithms: one to compute f (w) for each w ‚ààV ‚àó, and one to check if a
given n ‚ààN codes some string over V (i.e., is in the range of f ), and if so, to
compute w = f ‚àí1(n).
We use special notation in the context of G¬®odel numberings. Rather than
‚Äú f (w)‚Äù ‚Äì the G¬®odel number of w ‚Äì we write ‚åúw‚åù, allowing the context to tell
which speciÔ¨Åc f we have in mind.
The above, of course, is not a precise deÔ¨Ånition, since the term ‚Äúcomputable‚Äù
(function) was never deÔ¨Åned between ‚Äúmixed‚Äù Ô¨Åelds (V ‚àóon the left and N on
the right). This does not present a problem however, for in practice any speciÔ¨Åc
G¬®odel numbering will be trivially seen (at the intuitive level) to satisfy the
algorithmic coding-decoding requirement.
The heart of the matter in effecting a G¬®odel numbering of a given V ‚àóis
simple: We start with a ‚Äúprimitive‚Äù numbering by assigning distinct numbers
from N to each symbol of V . Then, in principle, we can extend this primitive
numbering to the entire V ‚àóby recursion on strings.
However, in the cases of interest to us, that is, terms, formulas, and sequences
of such over some language L, we will prefer to do our recursion on terms,
formulas, and sequences (rather than on generic strings).

156
I. Basic Logic
For example, if the numbers n0, n1, . . . , nm were already assigned to the
formal function symbol g (m-ary) and to the terms t1, . . . , tm respectively, one
would just need a way to obtain a number for gt1 . . . tm from the numbers
we have just listed. This simply requires the presence of some number-coding
scheme, ‚Äú‚ü®‚ü©‚Äù, to compute ‚ü®n0, n1, . . . , nm‚ü©. G¬®odel used, essentially, the prime
power coding scheme ‚Äú‚ü®‚ü©,lh, Seq, (z)i‚Äù of p. 136.
We will not adopt prime power coding here, but instead we will use a different
coding based on G¬®odel‚Äôs Œ≤-function. Our approach is based on the exposition in
ShoenÔ¨Åeld (1967), the motivation being to do the number coding with as little
number theory as possible,‚Ä† so that when we have to revisit all this in the next
chapter ‚Äì formally this time ‚Äì our task will be reasonably easy, and short.
We Ô¨Åx, for the balance of the chapter, a simple pairing function, that is,
a total and 1-1 function J : N2 ‚ÜíN that can be obtained via addition and
multiplication. For example, let us set
J(x, y) = (x + y)2 + x
for all x, y
(‚àó)
J is trivially primitive recursive. Its 1-1-ness follows from the observation
that x +y < u+v implies x +y+1 ‚â§u+v and hence J(x, y) < (x +y+1)2 ‚â§
(u + v)2 ‚â§J(u, v).
Thus, if J(x, y) = J(u, v), then it must be x + y = u + v, and therefore
x = u. But then y = v.
The symbols K and L are reserved for the projection functions of a pairing
function J.‚Ä°
We see at once that K, L are in PR; indeed,
K(z) = (¬µx)‚â§z(‚àÉy)‚â§z(J(x, y) = z)
L(z) = (¬µy)‚â§z(‚àÉx)‚â§z(J(x, y) = z)
Let us then address the task of Ô¨Ånding a way to ‚Äúalgorithmically‚Äù code a number
sequence a0, . . . , an by a single number, so that each of the ai can be algorith-
mically recovered from the code as long as we know its position i.
We start by setting
c = max{1 + J(i, ai) : i ‚â§n}
(‚àó‚àó)
‚Ä† G¬®odel‚Äôs original approach needed enough number theory to include the prime factorization
theorem. An alternative approach due to Quine, utilized in Smullyan (1961, 1992), requires the
theorem that every number can be uniquely written as a string of base-b digits out of some Ô¨Åxed
alphabet {0, 1, . . . , b‚àí1}. On the other hand, employing the variant of G¬®odel‚Äôs Œ≤-function found
in ShoenÔ¨Åeld (1967), one does not even need the Chinese remainder theorem.
‚Ä° It is unfortunate, but a standard convention, that this ‚ÄúK‚Äù clashes with the usage of ‚ÄúK‚Äù as the
name of the halting set (I.8.45). Fortunately, it is very unlikely that the context will allow the
confusion of the two notations.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 157
Next, let p be the least common multiple of the numbers 1, 2, . . . , c + 1, for
short, lcm{1, 2, . . . , c + 1}, that is,
p = (¬µz)
%
z > 0 ‚àß(‚àÄi)‚â§c(i + 1)|z
&
(‚àó‚àó‚àó)
We recall the following deÔ¨Ånition from elementary number theory:
I.9.1 DeÔ¨Ånition. The greatest common divisor, or gcd, of two natural numbers
a and b such that a + b Ã∏= 0 is the largest d such that d|a and d|b.‚Ä† We write
d = gcd(a, b) = gcd(b, a).
‚ñ°
I.9.2 Lemma. For each a and b in N (a + b Ã∏= 0) there are integers u and v
such that gcd(a, b) = au + bv.
Proof. The set A = {ax +by > 0 : x ‚ààZ‚àßy ‚ààZ} is nonempty. For example,
if a Ã∏= 0, then a1+b0 > 0 is in A. Let g be the least member of A. So, for some
u and v in Z,
g = au + bv > 0
(1)
We argue that g|a (and similarly, g|b). If not, let
0 < r < g
(2)
such that a = gq +r (q = ‚åäa/g‚åã). Thus, using (1), r = a ‚àígq = a(1‚àíuq)‚àí
bvq, a member of A. (2) contradicts the minimality of g.
Thus, g is a common divisor of a and b. On the other hand, by (1), every
common divisor d of a and b divides g; hence d ‚â§g. Thus, g = gcd(a, b).
‚ñ°
I.9.3 DeÔ¨Ånition. Two natural numbers a and b (a + b Ã∏= 0) are relatively prime
iff gcd(a, b) = 1.
‚ñ°
The above is the standard deÔ¨Ånition of relative primality. However, an equi-
valent deÔ¨Ånition can save us from a lot of grief when we redo all this formally
in the next chapter. This alternate deÔ¨Ånition is furnished by the statement of
the following lemma, which we prove here (informally) only as a preview for
things to come in the next chapter.
I.9.4 Lemma. The natural numbers a and b (a + b Ã∏= 0) are relatively prime
iff for all x > 0, a|bx implies a|x.
‚Ä† If a = b = 0, then such a largest d does not exist, since (‚àÄx)(x > 0 ‚Üíx|0). Hence the restriction
to a + b Ã∏= 0.

158
I. Basic Logic
Proof. Only-if part.
By I.9.2, 1 = au + bv for some integers u and v. Thus,
x = axu + bxv; hence a|x.
If part.
We prove the contrapositive.‚Ä† Let 1 < d = gcd(a, b). Write a = dk
and b = dm. Now, a|bk, but a > k; hence a Ã∏ | k.
‚ñ°
We can now prove:
I.9.5 Lemma. With c > 0 arbitrary, and p chosen as in (‚àó‚àó‚àó) on p. 156 above,
gcd

1 + ( j + 1)p, 1 + (i + 1)p

= 1
for all
0 ‚â§i < j ‚â§c + 1
Proof. We will proceed by contradiction. Let d > 1 divide both 1 + ( j + 1)p
and 1 + (i + 1)p. Then d > c + 1 (otherwise d|p and hence d Ã∏ | 1 + ( j + 1)p).
Now d divides any linear combination of 1 + ( j + 1)p and 1 + (i + 1)p, in
particular j ‚àíi (which is equal to (1+(i +1)p)( j +1)‚àí(1+( j +1)p)(i +1)).
Since 0 < j ‚àíi ‚â§c + 1, this is impossible.
‚ñ°
I.9.6 Lemma. If d0, . . . , dr, b, with b greater than 1, are such that gcd(b, di) =
1 for all 0 ‚â§i ‚â§r, then b Ã∏ | lcm{di : i = 0, . . . ,r}.
Proof. Set z = lcm{di : i = 0, . . . ,r}, and suppose that b|z; thus z = bk for
some k. By I.9.4 (since di|z), we have di|k for all 0 ‚â§i ‚â§r. From b > 1
follows k < z, contradicting the minimality of z.
‚ñ°
Armed with Lemmata I.9.5 and I.9.6, we can now code any nonempty subset
(the emphasis indicating disrespect for order) of numbers i j, 0 ‚â§i j ‚â§c (c > 0
being an arbitrary integer), by the least common multiple q of the numbers
1 + (i j + 1)p, p being the lcm of {1, 2, . . . , c + 1}. Indeed, a number of the
form 1 + (z + 1)p, for 0 ‚â§z ‚â§c, divides q precisely when z is one of the i j.
Thus, we can code the sequence a0, a1, . . . , an by coding the set of numbers
J(i, ai) (position information i is packed along with value ai), as suggested
immediately above: We let
q = lcm
'
1 +

1 + J(i, ai)

p : i = 0, . . . , n
(
With n, c, p, q as above (see (‚àó‚àó) and (‚àó‚àó‚àó)), we recover ai as
(¬µy)
%
1 +

1 + J(i, y)

p | q
&
(1)
‚Ä† The contrapositive of A ‚ÜíB is the tautologically equivalent ¬¨B ‚Üí¬¨A.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 159
or, setting, a = J(c, q) and forcing the search to exit gracefully even when q
is nonsense (that is, not a code),
(¬µy)
%
y = a ‚à®1 +

1 + J(i, y)

p | L(a)
&
(2)
Of course, p in (2) above is given in terms of c by (‚àó‚àó‚àó), that is, it equals the
least common multiple of the numbers {1, 2, . . . , K(a) + 1}.
In what follows we will use the notation Œ≤(a, i) for the expression (2) above.
Thus,
Œªai.Œ≤(a, i) ‚ààPR
Œ≤(a, i) ‚â§a
for all a, i
(3)
The ‚Äú‚â§‚Äù in (3) is ‚Äú=‚Äù iff the search in (1) above fails. Otherwise y ‚â§J(i, y) <
1 + J(i, y) < L(a) ‚â§a + 1; hence y ‚â§J(i, y) < a.
For any sequence a0, . . . , an there is an a such that Œ≤(a, i) = ai for i ‚â§n.
This is the version of G¬®odel‚Äôs Œ≤-function in ShoenÔ¨Åeld (1967). Since we will
carefully prove all the properties of this Œ≤-function ‚Äì and of its associated
sequence coding scheme ‚Äì later on, in the context of axiomatic arithmetic
(Section II.2), we will avoid ‚Äúobvious‚Äù details here.
I.9.7 Remark. (1) Why lcm? Both in (‚àó‚àó‚àó) and in the deÔ¨Ånition of q above, we
could have used product instead. Thus, p could have been given as c-factorial
(c!), and q as the product‚Ä†
" '
1 +

1 + J(i, ai)

p : i = 0, . . . , n
(
The seemingly more complex approach via lcm is actually formally simpler.
The lcm is explicitly deÔ¨Ånable, while the product of a variable number of factors
necessitates a (primitive) recursive deÔ¨Ånition. Alas, Œ≤ will be employed in the
next chapter precisely in order to show that recursive deÔ¨Ånitions are allowed in
Peano arithmetic.
(2) G¬®odel‚Äôs original Œ≤ was less ‚Äúelementary‚Äù than the above: Starting with
a modiÔ¨Åed ‚Äúc‚Äù,
c‚Ä≤ = max{1 + ai : i ‚â§n}
(‚àó‚àó‚Ä≤)
one then deÔ¨Ånes
p‚Ä≤ = n!c‚Ä≤
(‚àó‚àó‚àó‚Ä≤)
As in Lemma I.9.5, gcd(1+(1+ j)p‚Ä≤, 1+(1+i)p‚Ä≤) = 1 for all 0 ‚â§j < i ‚â§n.
‚Ä† As a matter of fact, for a set of relatively prime numbers, their lcm is the same as their product.

160
I. Basic Logic
By the Chinese remainder theorem (see, e.g., LeVeque (1956)), there is a
q‚Ä≤ ‚ààN such that q‚Ä≤ ‚â°ai mod 1 + (1 + i)p‚Ä≤ for i = 0, . . . , n. Thus, q‚Ä≤ codes
the sequence a0, . . . , an. Since each ai satisÔ¨Åes ai < 1 + (1 + i)p‚Ä≤ by the
choice of p‚Ä≤, ai is recovered from q‚Ä≤ by rem(q‚Ä≤, 1 + (1 + i)p‚Ä≤). One then sets
Œ≤‚Ä≤(q‚Ä≤, p‚Ä≤, i) = rem(q‚Ä≤, 1 + (1 + i)p‚Ä≤). This ‚ÄúŒ≤‚Ä≤‚Äù is G¬®odel‚Äôs original ‚ÄúŒ≤‚Äù.
‚ñ°
This ability to code sequences without using (primitive) recursion can be used
to sharpen Corollary I.8.71, so that we can start the arithmetic hierarchy with
even simpler relations 0 = 0 than primitive recursive.
We will proÔ¨Åt by a brief digression here from our discussion of G¬®odel num-
berings to show that any R ‚ààPR‚àóis a (‚àÉx)-projection of a very ‚Äúsimple‚Äù
relation, one out of the set deÔ¨Åned below. This result will be utilized in our
study of (that is, in the metatheory of) formal arithmetic.
I.9.8 DeÔ¨Ånition (Constructive Arithmetic Predicates). (Smullyan (1961,
1992), Bennett (1962)). The constructive arithmetic predicates are the smallest
set of predicates that includes Œªxyz.z = x + y, Œªxyz.z = x ¬∑ y, and is closed
under ¬¨, ‚à®, (‚àÉy)<z, and explicit transformations.
Explicit transformations (Smullyan (1961), Bennett (1962)) are exactly the
following: Substitution of any constant into a variable, expansion of the vari-
ables list, permutation of variables, identiÔ¨Åcation of variables.
We will denote the set of constructive arithmetic predicates by CA.‚Ä†
‚ñ°
Trivially,
I.9.9 Lemma. CA ‚äÜPR‚àó.
and
I.9.10 Lemma. CA is closed under (‚àÉy)‚â§z. Conversely, the deÔ¨Ånition above
could have been given in terms of (‚àÉy)‚â§z.
Proof. (‚àÉy)‚â§z R(y, ‚Éów) ‚ÜîR(z, ‚Éów) ‚à®(‚àÉy)<z R(y, ‚Éów). Conversely, (‚àÉy)<z R(y,
‚Éów) ‚Üî(‚àÉy)‚â§z(¬¨y = z ‚àßR(y, ‚Éów)). Of course, y = z is an explicit transform of
x ¬∑ y = z.
‚ñ°
‚Ä† Smullyan (1992) uses ‚Äú0‚Äù, but as we already have been shifting the meaning of that symbol, this
name would not be reliable here. Some use ‚Äú0‚Äù (due to the presence of bounded quantiÔ¨Åcation),
but this symbol also suffers from the same ambiguities.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 161
I.9.11 Lemma. CA is closed under substitution of the term x +1 into variables.
Proof. We do induction on the deÔ¨Ånition of CA.
Basis.
(1) z = x + y + 1:
z = x + y + 1 ‚Üî(‚àÉw)‚â§z(z = x + w ‚àßw = y + 1). Of
course, w = y + 1 is an explicit transform of w = y + u.
(2) z + 1 = x + y:
z + 1 = x + y ‚Üî(‚àÉw)‚â§x(x = w + 1 ‚àßz = w + y) ‚à®
(‚àÉw)‚â§y(y = w + 1 ‚àßz = x + w).
(3) z = x(y + 1):
z = x(y + 1) ‚Üî(‚àÉw)‚â§z(z = xw ‚àßw = y + 1).
(4) z + 1 = xy:
z + 1 = xy ‚Üî(‚àÉu)‚â§x(‚àÉw)‚â§y(x = u + 1 ‚àßy = w + 1 ‚àßz =
uw+u+w). Of course, z = uw+u+w ‚Üî(‚àÉx)‚â§z(‚àÉy)‚â§z(z = x + y‚àßx =
uw ‚àßy = u + w).
The property of CA that we are proving trivially propagates with the Boolean
operations. Moreover (‚àÉy)<z+1R(y, ‚Éóx) ‚Üî(‚àÉy)‚â§z R(y, ‚Éóx).
‚ñ°
(‚àÉy)‚â§z is a ‚Äúderived operation‚Äù (I.9.10); thus it is not checked in the proof
above. Needless to say, were it the principal (primary) bounded quantiÔ¨Åcation
deÔ¨Ånitionally, then we would have employed the argument (‚àÉy)‚â§z+1R(y, ‚Éóx) ‚Üî
R(z + 1, ‚Éóx) ‚à®(‚àÉy)‚â§z R(y, ‚Éóx) instead, and the I.H., to conclude the above
proof.
I.9.12 Corollary. CA is closed under substitution into variables by functions
f satisfying
(i) Œªy‚Éóxn.y = f (‚Éóxn) is in CA, and
(ii) for some i, f (‚Éóxn) ‚â§xi + 1 for all ‚Éóxn.
Proof. Let R(y, ‚Éóz) be in CA, and f be as described above; in particular let
f (‚Éóxn) ‚â§xi + 1 for all ‚Éóxn. Then
R( f (‚Éóxn), ‚Éóz) ‚Üî(‚àÉy)‚â§xi+1(y = f (‚Éóxn) ‚àßR(y, ‚Éóz))
‚ñ°
I.9.13 Lemma. The graphs of J, K, and L (p. 156) are in CA.
By the ‚Äúgraph‚Äù of a function Œª‚Éóx. f (‚Éóx) we understand the relation Œªy‚Éóx.y = f (‚Éóx).
Proof. The case for J is trivial. K and L present some mild interest. For
example,
y = K(x) ‚Üî
%
y = x + 1 ‚àß¬¨(‚àÉz)‚â§x J(y, z) = x
&
‚à®(‚àÉz)‚â§x J(y, z) = x
‚ñ°

162
I. Basic Logic
I.9.14 Remark. We can substitute K(x) and L(x) for variables in CA relations,
by I.9.12, since K(x) ‚â§x + 1 for all x and L(x) ‚â§x + 1 for all x. J(x, y)
is ‚Äútoo big‚Äù for I.9.12 to apply to it, but that too can be substituted, as results
of Bennett show (1962, retold in Tourlakis (1984)). However, we will not need
this fact in this volume.
‚ñ°
I.9.15 Proposition. Œªaiy.Œ≤(a, i) = y is in CA.
Proof. Recall that Œ≤(a, i) = (¬µy)(y = a ‚à®1+(1+ J(i, y))p(a) | L(a)), where
p(a) = (¬µz)(z > 0 ‚àß(‚àÄi)‚â§K(a)(i + 1) | z)
We set for convenience P(a, i, y) ‚Üî1 + (1 + J(i, y))p(a) | L(a), and show
that P is in CA. Now P(a, i, y) ‚Üî(‚àÉu)‚â§a(L(a) = u(1 + (1 + J(i, y))p(a))),
and in view of I.9.12 (cf. I.9.14) and closure under (‚àÉy)‚â§w, we need only show
that
z = u

1 + (1 + J(i, y))p(a)

is in CA. The above is equivalent to
(‚àÉv, x)‚â§z
%
v = p(a) ‚àßz = ux ‚àßx = 1 + (1 + J(i, y))v
&
where we have used the shorthand ‚Äú(‚àÉv, x)‚â§z‚Äù for ‚Äú(‚àÉv)‚â§z(‚àÉx)‚â§z‚Äù.
That x = 1 + (1 + J(i, y))v is in CA follows from
x = 1 + (1 + J(i, y))v ‚Üî(‚àÉu, w,r, s)‚â§x(w = J(i, y) ‚àßu
= w + 1 ‚àßr = uv ‚àßx = r + 1)
We concentrate now on v = p(a). We start with the predicate
H(z, w) ‚Üîz > 0 ‚àß(‚àÄi)‚â§w(i + 1) | z
This is in CA since (i + 1) | z ‚Üî(‚àÉu)‚â§zz = u(i + 1). Now
v = p(a) ‚ÜîH(v, K(a)) ‚àß(‚àÄz)<v¬¨H(z, K(a))
and the case for v = p(a) rests by I.9.14. This concludes the proof that P(a, i, y)
is in CA. Finally, setting
Q(a, i, y) ‚Üîy = a ‚à®P(a, i, y)

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 163
we have Q(a, i, y) in CA. We are done by observing that
Œ≤(a, i) = y ‚ÜîQ(a, i, y) ‚àß(‚àÄz)<y¬¨Q(a, i, y)
‚ñ°
The crucial step in order to achieve the earlier suggested projection represent-
ation of arbitrary primitive recursion relations (p. 160) is to express the arbitrary
primitive recursive ‚Äúcomputation‚Äù
(‚àÉc0, . . . , cx)
%
z = cx ‚àßc0 = h(‚Éóy) ‚àß(‚àÄi)<xci+1 = g(i, ‚Éóy, ci)
&
(1)
in the form (‚àÉu)R, where R ‚ààCA. (1), of course, ‚Äúcomputes‚Äù (or veriÔ¨Åes) that
z = f (x, ‚Éóy), where, for all x, ‚Éóy,
f (0, ‚Éóy) = h(‚Éóy)
f (x + 1, ‚Éóy) = g(x, ‚Éóy, f (x, ‚Éóy))
I.9.16 Theorem. If R(‚Éóx) ‚ààPR‚àó, then, for some Q(y, ‚Éóx) ‚ààCA,
R(‚Éóx) ‚Üî(‚àÉy)Q(y, ‚Éóx)
Proof. Since R(‚Éóx) ‚ààPR‚àóiff for some f ‚ààPR one has R(‚Éóx) ‚Üîf (‚Éóx) = 0,
it sufÔ¨Åces to show that for all f ‚ààPR there is a Q(z, y, ‚Éóx) ‚ààCA such that
y = f (‚Éóx) ‚Üî(‚àÉz)Q(z, y, ‚Éóx).
We do induction on PR. The graphs of the initial functions are in CA without
the help of any (‚àÉy)-projection.
Let f (‚Éóx) = g(h1(‚Éóx), . . . , hm(‚Éóx)), and assume that (I.H.) z = g(‚Éóym)
‚Üî
(‚àÉu)G(u, z, ‚Éóym) and y = hi(‚Éóx) ‚Üî(‚àÉz)Hi(z, y, ‚Éóx) for i = 1, . . . , m, where G
and the Hi are in CA.
Let us write ‚Äú(‚àÉ‚Éózr)‚Äù and ‚Äú(‚àÉ‚Éózr)‚â§w‚Äù as short for ‚Äú(‚àÉz1)(‚àÉz2) . . . (‚àÉzr)‚Äù and
‚Äú(‚àÉz1)‚â§w(‚àÉz2)‚â§w . . . (‚àÉzr)‚â§w‚Äù respectively. Then
y = f (‚Éóx) ‚Üî(‚àÉ‚Éóum)
%
y = g(‚Éóum) ‚àßu1 = h1(‚Éóx) ‚àß¬∑ ¬∑ ¬∑ ‚àßum = hm(‚Éóx)
&
‚Üî(‚àÉ‚Éóum)
%
(‚àÉz)G(z, y, ‚Éóum) ‚àß(‚àÉz1)H1(z1, u1, ‚Éóx) ‚àß
¬∑ ¬∑ ¬∑ ‚àß(‚àÉzm)Hm(zm, um, ‚Éóx)
&
‚Üî(‚àÉw)(‚àÉ‚Éóum)‚â§w
%
(‚àÉz)‚â§wG(z, y, ‚Éóum) ‚àß(‚àÉz1)‚â§wH1(z1, u1, ‚Éóx) ‚àß
¬∑ ¬∑ ¬∑ ‚àß(‚àÉzm)‚â§wHm(zm, um, ‚Éóx)
&
We Ô¨Ånally turn to the graph z = f (x, ‚Éóy), where f is deÔ¨Åned by primitive recur-
sion from h and g above. This graph is veriÔ¨Åed by the computation (1).

164
I. Basic Logic
Assume that (this is the I.H.) z = h(‚Éóy) ‚Üî(‚àÉw)H(w, z, ‚Éóy) and u =
g(x, ‚Éóy, z) ‚Üî(‚àÉw)G(w, u, x, ‚Éóy, z), where H and G are in CA. Then
z = f (x, ‚Éóy) ‚Üî(‚àÉc)
%
Œ≤(c, 0) = h(‚Éóy) ‚àßŒ≤(c, x) = z ‚àß
(‚àÄi)<xŒ≤(c, i + 1) = g(i, ‚Éóy, Œ≤(c, i))
&
‚Üî
(using the I.H.)
(‚àÉc)
%
(‚àÉw)H(w, Œ≤(c, 0), ‚Éóy) ‚àßŒ≤(c, x) = z ‚àß
(‚àÄi)<x(‚àÉw)G(w, Œ≤(c, i + 1), i, ‚Éóy, Œ≤(c, i))
&
‚Üî
(see the proof of I.8.48)
(‚àÉu)(‚àÉc)<u
%
(‚àÉw)<u H(w, Œ≤(c, 0), ‚Éóy) ‚àßŒ≤(c, x) = z ‚àß
(‚àÄi)<x(‚àÉw)<uG(w, Œ≤(c, i + 1), i, ‚Éóy, Œ≤(c, i))
&
Of course things like G(w, Œ≤(c, i + 1), i, ‚Éóy, Œ≤(c, i)) can be easily seen to be in
CA, since y = Œ≤(c, i) is by I.9.15, and Œ≤(c, i) ‚â§c < u.
‚ñ°
I.9.17 Corollary.  is the closure of z = x+y and z = xy under ‚à®, ¬¨, (‚àÉy)<z,
(‚àÉy), and explicit transformations.
Indeed, since (‚àÉy) subsumes (‚àÉy)<z,
I.9.18 Corollary.  is the closure of z = x + y and z = xy under ‚à®, ¬¨, (‚àÉy),
and explicit transformations.
The name ‚Äúarithmetic‚Äù relations is now completely justiÔ¨Åed.
The following corollary is sufÔ¨Åciently important (even useful) to merit theo-
rem status.
I.9.19 Theorem (A Constructive Arithmetic Kleene Predicate). There is,
for each n > 0, a constructive arithmetic predicate T (n)
C A(i, ‚Éóxn, z) such that
{i}(‚Éóxn) ‚Üì‚Üî(‚àÉz)T (n)
C A(i, ‚Éóxn, z)
Moreover, there is a primitive recursive function U of one argument, such that
{i}(‚Éóxn) = U
%
(¬µz)T (n)
C A(i, ‚Éóxn, z)
&
Proof. By I.9.16, let, for every n > 0, C(n) ‚ààCA be such that
T (n)(i, ‚Éóxn, z) ‚Üî(‚àÉu)C(n)(u, i, ‚Éóxn, z)
Set T (n)
C A(i, ‚Éóxn, z) ‚Üî(‚àÉu)‚â§z(‚àÉw)‚â§z(z = J(u, w) ‚àßC(n)(u, i, ‚Éóxn, w)), in other
words, T (n)
C A(i, ‚Éóxn, z) ‚ÜîC(n)(K(z), i, ‚Éóxn, L(z)).
For U, set, for all z, U(z) = (L(z))0.
‚ñ°

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 165
After our brief digression to obtain I.9.16 and its corollaries, we now return
to codings and G¬®odel numberings.
We have seen that any (Ô¨Åxed length) sequence a0, . . . , an can be coded by a
primitive recursive function of the ai, namely, q of p. 158. Indeed, we can code
variable length sequences b0, . . . , bn‚àí1 by appending the length information,
n, at the beginning of the sequence.
I.9.20 DeÔ¨Ånition. (Following ShoenÔ¨Åeld (1967).‚Ä†) We now revise the symbol
‚ü®a0, . . . , an‚àí1‚ü©to mean, for the balance of this chapter, the smallest a such that
Œ≤(a, 0) = n
and
Œ≤(a, i + 1) = ai + 1
for i < n
‚ñ°
We re-introduce also Seq(z), (z)i, ‚àó, and lh, but to mean something other than
their homonyms on p. 136 (this time basing the deÔ¨Ånitions on the Œ≤-coding).
We let lh(z) = Œ≤(z, 0) and (z)i = Œ≤(z, i + 1)
.‚àí1. Thus Œ≤(z, i + 1) > 0
implies Œ≤(z, i + 1) = (z)i + 1.
Seq(z) will say that z is some ‚Äúbeta-coded‚Äù sequence. We have analogous
expectations on the ‚Äústructure‚Äù of the number z (as in the case of the ‚ÄúSeq‚Äù of
p. 136) as dictated by I.9.20. Thus a z is a ‚ÄúSeq‚Äù iff
(1) the sequence terms have been incremented by 1 before ‚Äúpacking‚Äù them
into z, and
(2) any smaller x (x < z, that is) codes a different sequence.‚Ä°
That is,
Seq(z) ‚Üî(‚àÄi)<lh(z)Œ≤(z, i + 1) > 0 ‚àß(‚àÄx)<z
(lh(x) Ã∏= lh(z) ‚à®(‚àÉi)<lh(z)(z)i Ã∏= (x)i)
We also (re)deÔ¨Åne (see also II.2.16 and II.2.21)
a ‚àób = (¬µz)(Seq(z) ‚àßlh(z) = lh(a) + lh(b) ‚àß
(‚àÄi)<lh(a)(i > 0 ‚Üí(z)i = (a)i) ‚àß
(‚àÄi)<lh(b)(i > 0 ‚Üí(z)i+lh(a) = (b)i)
It is clear that ‚ü®a0, . . . , an‚àí1‚ü©‚àó‚ü®b0, . . . , bm‚àí1‚ü©= ‚ü®a0, . . . , an‚àí1, b0, . . . , bm‚àí1‚ü©.
Note also that Seq(z) implies (z)i < z for i <lh(z).
‚Ä† See however II.2.14, p. 242.
‚Ä° z is the smallest number that codes whatever it codes.

166
I. Basic Logic
As was already suggested on p. 155, if ‚åú‚åù: V ‚ÜíN is any reasonable 1-1
total mapping from a Ô¨Ånite symbol alphabet V to the natural numbers then we
can use ‚ü®. . . ‚ü©to extend it to a G¬®odel numbering ‚åú‚åù: V + ‚ÜíN.‚Ä†
Rather than attempting to implement that suggestion in the most general
setting, we will shortly show exactly what we have in mind in the case of
languages appropriate for formal arithmetic.
We now Ô¨Åx an alphabet over which we can deÔ¨Åne a hierarchy of languages
where formal arithmetic can be spoken. For the balance of the chapter, the
absolutely essential nonlogical symbols‚Ä° will be indicated in boldface type:
0, S, +, √ó, <
(NL)
The entire alphabet, in the following Ô¨Åxed order, is
0,
, ‚Éù, ‚ñ≥, =, ¬¨, ‚à®, ‚àÉ, (, ), #
(1)
The commas are just metalogical separators in (1) above. All the rest are formal
symbols. The symbol ‚Äú#‚Äù is ‚Äúglue‚Äù, and its purpose is to facilitate building an
unlimited (enumerable) supply of predicate and function symbols, as we will
shortly describe.
The brackets have their normal use, but will be also assisting the symbols
‚Äú
‚Äù, ‚Äú‚ñ≥‚Äù, and ‚Äú‚Éù‚Äù
to build the object variables, function symbols, and
predicate symbols of any language in the hierarchy.
The details are as follows:
Variables.
The argot symbol ‚Äúv0‚Äù is short for ‚Äú(
)‚Äù, ‚Äúv1‚Äù is short for
‚Äú(
)‚Äù, and, in general,
‚Äúvj‚Äù is short for ‚Äú(
j+1
  
. . .
)‚Äù
Function symbols.
The argot symbol ‚Äú f n
j ‚Äù ‚Äì the jth function symbol
( j ‚â•0) with arity n > 0 ‚Äì is a short name for the string
‚Äú(
j+1



‚ñ≥. . . ‚ñ≥#
n



‚ñ≥. . . ‚ñ≥)‚Äù
‚Ä† V + denotes the set of all nonempty strings of V .
‚Ä° That is, all languages where arithmetic is spoken and practised formally will include these
symbols.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 167
Predicate symbols.
The argot symbol ‚ÄúPn
j‚Äù ‚Äì the jth predicate symbol
( j ‚â•0) with arity n > 0 ‚Äì is a short name for the string
‚Äú(
j+1



‚Éù. . . ‚Éù#
n



‚Éù. . . ‚Éù)‚Äù
Some symbols in the list (NL) are abbreviations (argot) that will be used
throughout, in conformity with standard mathematical practice:
S
names
(‚ñ≥#‚ñ≥),
that is, f 1
0
+
names
(‚ñ≥#‚ñ≥‚ñ≥),
that is, f 2
0
√ó
names
(‚ñ≥‚ñ≥#‚ñ≥‚ñ≥),
that is, f 2
1
<
names
(‚Éù# ‚Éù‚Éù),
that is, P2
0
I.9.21 DeÔ¨Ånition. A language LA of arithmetic is a Ô¨Årst order language over
the alphabet (1), with the stated understanding of the ontology of vi‚Äôs, f n
i ‚Äôs,
and Pn
i ‚Äôs.
LA must contain the nonlogical symbols (NL).
We will normally write (argot) t < s, t + s and t √ó s (t, s are terms) rather
than <ts, + ts, and √óts respectively.
‚ñ°
The subscript A (for ‚ÄúArithmetic‚Äù) in LA reÔ¨Çects the particular standard
structure (appropriate for the language) ‚ÄúA‚Äù that we have in mind. In what
follows we will study extensively the language for the standard structure‚Ä† N =
(N; 0; S, +, √ó; <).
Our notation for the language under discussion will normally indicate the
structure we have in mind, e.g., by writing LN.
LN has no nonlogical symbols beyond the ones listed under (NL).
Still, occasionally we will just write LA regardless, and let the context reveal
what we are thinking.
The ‚Äúnatural‚Äù structures for extensions of LN will be expansions of N (see
DeÔ¨Ånition I.5.3, p. 54). Such expansions will normally be denoted by N‚Ä≤ =
(N; 0; S, +, √ó, . . . ; <, . . .), or just N‚Ä≤. We will never need to specify the ‚Äú. . . ‚Äù
part in N‚Ä≤.
The extended language, correspondingly, may be denoted by LN‚Ä≤, if the
correspondence needs to be emphasized, else we will fall back on the generic
LA.
‚Ä† Also sometimes called the ‚Äústandard model‚Äù, although this latter term implies the presence of
some nonlogical axioms for N to be a model of.

168
I. Basic Logic
Note that all languages LA will have just one constant symbol, 0.
Each bold nonlogical symbol of the language is interpreted as its lightface
‚Äúreal‚Äù counterpart (as usual, S = Œªx.x + 1), that is, 0N = 0, <N =<, SN = S,
+N = +, etc.
Of course, in any expansion N‚Ä≤, all we do is give meaning to new nonlogical
symbols leaving everything else alone. In particular, in any expansion it is still
the case that 0N‚Ä≤ = 0, <N‚Ä≤ =<, SN‚Ä≤ = S, +N‚Ä≤ = +, etc.
G¬®odel numbering of LA: At this point we Ô¨Åx our G¬®odel numbering for all
possible languages LA. Referring to (1) of p. 166, we assign
‚åú0‚åù= ‚ü®0, 1‚ü©
‚åú
‚åù= ‚ü®0, 2‚ü©
‚åú‚ñ≥‚åù= ‚ü®0, 3‚ü©
‚åú‚Éù‚åù= ‚ü®0, 4‚ü©
‚åú=‚åù= ‚ü®0, 5‚ü©
‚åú¬¨‚åù= ‚ü®0, 6‚ü©
‚åú‚à®‚åù= ‚ü®0, 7‚ü©
‚åú‚àÉ‚åù= ‚ü®0, 8‚ü©
‚åú(‚åù
= ‚ü®0, 9‚ü©
‚åú)‚åù
= ‚ü®0, 10‚ü©
‚åú#‚åù= ‚ü®0, 11‚ü©
We then set, for all j, n in N,
‚åú(
j+1
  
. . .
)‚åù= ‚ü®1, ‚åú(‚åù,
j+1



‚åú
‚åù, . . . , ‚åú
‚åù, ‚åú)‚åù‚ü©
‚åú(
j+1
  
‚ñ≥. . . ‚ñ≥#
n+1
  
‚ñ≥. . . ‚ñ≥)‚åù= ‚ü®2, ‚åú(‚åù,
j+1



‚åú‚ñ≥‚åù, . . . , ‚åú‚ñ≥‚åù, ‚åú#‚åù,
n+1



‚åú‚ñ≥‚åù, . . . , ‚åú‚ñ≥‚åù, ‚åú)‚åù‚ü©
and
‚åú(
j+1



‚Éù. . . ‚Éù#
n+1



‚Éù. . . ‚Éù)‚åù
= ‚ü®3, ‚åú(‚åù,
j+1



‚åú‚Éù‚åù, . . . , ‚åú‚Éù‚åù, ‚åú#‚åù,
n+1



‚åú‚Éù‚åù, . . . , ‚åú‚Éù‚åù, ‚åú)‚åù‚ü©
and by recursion on terms and formulas
1. If g and Q are function and predicate symbols respectively of arity n, and
t1, . . . , tn are terms, then
‚åúgt1. . . tn‚åù= ‚ü®‚åúg‚åù, ‚åút1‚åù, . . . , ‚åútn‚åù‚ü©

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 169
and
‚åúQt1 . . . tn‚åù= ‚ü®‚åúQ‚åù, ‚åút1‚åù, . . . , ‚åútn‚åù‚ü©
Moreover, for terms t and s, ‚åút = s‚åù= ‚ü®‚åú= ‚åù, ‚åút‚åù, ‚åús‚åù‚ü©.
2. If A and B are formulas, then
‚åú(¬¨A)‚åù= ‚ü®‚åú¬¨‚åù, ‚åúA‚åù‚ü©
‚åú((‚àÉx)A)‚åù= ‚ü®‚åú‚àÉ‚åù, ‚åúx‚åù, ‚åúA‚åù‚ü©
and
‚åú(A ‚à®B )‚åù= ‚ü®‚åú‚à®‚åù, ‚åúA‚åù, ‚åúB ‚åù‚ü©
Pause. What happened to the brackets in case 2 above?
It is clear that, intuitively, this numbering is algorithmic both ways. Given a
basic symbol ((1) of p. 166), term or formula, we can apply the above rules to
come up with its G¬®odel number.
Conversely, given a number n we can test Ô¨Årst of all if it satisÔ¨Åes Seq (for all
numbers ‚Äú‚åú‚åù‚Äù necessarily satisfy Seq). If so, and if it also satisÔ¨Åes lh(n) = 2,
(n)0 = 0 and 1 ‚â§(n)1 ‚â§11, then n is the G¬®odel number of a basic symbol (1)
of the alphabet, and we can tell which one it is.
If now (n)0 = 1, we further check to see if we got a code for a variable, and,
if so, of which ‚Äúvi‚Äù. This will entail ascertaining that lh(n) ‚â•4, that (n)1 ‚Äúis‚Äù ‚Ä†
a ‚Äú(‚Äù, (n)lh(n)‚àí1 is a ‚Äú)‚Äù, and all the other (n)i are
‚Äôs. If all this testing passes,
then we have a code for vi with i =lh(n) ‚àí4.
We can similarly check if n codes a function or predicate symbol, and if so,
which one.
As one more example,‚Ä° let Seq(n), lh(n) = 3 and (n)0 = ‚åú‚àÉ‚åù. Then we
need to ascertain that (n)1 is some vi and ‚Äì beneÔ¨Åting from an I.H. that we can
decode numbers <n ‚Äì that (n)2 is some formula A.
Pause. This I.H. hinges on the crucial ‚Äúif Seq(n), then (n)i < n‚Äù.
We have thus decoded n into ((‚àÉvi)A).
We note the following table, which shows that codes of distinct constructs
do not clash.
‚Ä† More accurately, ‚Äúcodes‚Äù.
‚Ä° We will formalize this discussion in the next chapter, so there is little point to pursue it in detail
here.

170
I. Basic Logic
Code (n) attribute
Potential expression
(n)0 = 0
Basic symbol
(n)0 = 1
Variable
(n)0 = 2
Function symbol
(n)0 = 3
Predicate symbol
(n)0 > 3 ‚àß((n)0)0 = 2
Term
(n)0 > 3 ‚àß((n)0)0 = 3
Atomic formula
(n)0 > 3 ‚àß((n)0)0 = 0
((n)0)1 = 5
Atomic formula (=)
((n)0)1 = 6
Negation
((n)0)1 = 7
Disjunction
((n)0)1 = 8
Existential quantiÔ¨Åcation
Note that (n)0 > 3 for those items claimed above stems from (z)i < z for
codes z, and the presence of, say, ‚Äú(‚Äù ‚Äì ‚åú(‚åù> 9 ‚Äì in the syntax of func-
tions and predicates, while the symbols =, ¬¨, ‚à®, ‚àÉhave each a code greater
than 5.
Having arithmetized LA, we can now apply the tools of analysis of number
sets to sets of expressions (strings) over LA. Thus,
I.9.22 DeÔ¨Ånition. We call a set A of expressions over LA constructive arith-
metic, primitive recursive, recursive, semi-recursive, or deÔ¨Ånable over LA (in
some structure) iff {‚åúx‚åù: x ‚ààA} is constructive arithmetic, primitive recursive,
recursive, semi-recursive, or deÔ¨Ånable over LA, respectively.
‚ñ°
We have seen that one way to generate theories is to start with some set
of nonlogical axioms  and then build Thm. Another way is to start with a
structure M and build T (M) = {A : |=M A}.‚Ä†
We will be interested here, among other theories, in the complete arithmetic,
that is, T (N). One of our results will be Tarski‚Äôs undeÔ¨Ånability of arithmetical
truth, that is, intuitively, that the set T (N) is not deÔ¨Ånable in the structure N.
Recall that (refer to DeÔ¨Ånition I.5.15, p. 60) R ‚äÜMn is deÔ¨Ånable over L in
M = (M, I ) iff, for some formula R(x1, . . . , xn) of L,
R(i1, . . . , in)
iff
|=M R(i1, . . . , in)
for all i j ‚ààM
where i j are imported constants (see I.5.4).
‚Ä† Cf. I.6.1.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 171
We say that R(x1, . . . , xn) is a regular formula for R iff the variables
x1, . . . , xn are the formal variables v0, . . . , vn‚àí1. Applying ‚Äúdummy renaming‚Äù
(I.4.13) judiciously, followed by the substitution metatheorem (I.4.12), we can
convert every formula to a logically equivalent regular formula. For example,
v13 = v99 is not regular, but it says the same thing as the regular formula
v0 = v1, i.e, v13 = v99 |= v0 = v1 and v0 = v1 |= v13 = v99.
Henceforth we will tacitly assume that formulas representing relations are
always chosen to be regular.
Turning our attention to N‚Ä≤, we have an interesting variant to the notion of
deÔ¨Ånability over (any) LN‚Ä≤, due to the richness of LN‚Ä≤ in certain types of terms.
I.9.23 DeÔ¨Ånition (Numerals). A term such as ‚Äú
n
  
S . . . S 0‚Äù for n ‚â•1 is called
a numeral. We use the shorthand notationn for this term. We also let (the case
of n = 0)0 be an alias for the formal 0.
‚ñ°
n must not be confused with the imported constants n of LA(N) (or LA(N‚Ä≤)).
The former are (argot names of) terms over LA; the latter are (argot names of)
new constants, not present in the original LA (which only has the constant 0).
The usefulness of numerals stems from the following trivial lemma.
I.9.24 Lemma. For all n ‚ààN, n N = n.
Proof. Induction on n. For n = 0,0 N = 0N = 0.
Now,

n + 1 N =

S
n
  
S . . . S 0
N
= SNnN
= S(n)
since SN = S, using the I.H.
= n + 1
‚ñ°
I.9.25 Corollary. For all n ‚ààN, |=N n = n.
Thus, for any formula A over LA and any n, |=A A[n] ‚ÜîA[n], since
|= n = n ‚Üí(A[n] ‚ÜîA[n]).
Therefore, a relation R ‚äÜNn is deÔ¨Ånable over LA in an appropriate expan-
sion of N, say N‚Ä≤, iff there is a regular formula R in LA such that, for all mj
in N,
R(m1, . . . , mn)
iff
|=A R(
m1, . . . , 
mn)
(D)

172
I. Basic Logic
The above expresses deÔ¨Ånability over LA without using any ‚Äúsyntactic materi-
als‚Äù (such as imported constants n) that are outside the language LA.
Lemmata I.9.24‚ÄìI.9.25 and (D) above go through, of course, for any expan-
sion N‚Ä≤ of N.
The following lemma will be used shortly:
I.9.26 Lemma. The function Œªn.‚åún‚åùis primitive recursive.
Proof.
‚åú0‚åù
= ‚ü®0, 1‚ü©
‚åú
n + 1‚åù= ‚ü®‚åúS‚åù, ‚åún‚åù‚ü©
where, of course, ‚åúS‚åù= ‚ü®2, ‚åú(‚åù, ‚åú‚ñ≥‚åù, ‚åú#‚åù, ‚åú‚ñ≥‚åù, ‚åú)‚åù‚ü©.
‚ñ°
Next, through the concept of deÔ¨Ånability over the minimum language LN,
we assign (Ô¨Ånite) string representations to each arithmetic formula. Through
this device, and G¬®odel numbering of the string representations, we assign (in-
directly) G¬®odel numbers to those formulas. Thus, we can speak of recursive,
semi-recursive, arithmetic, etc., subsets of (arithmetic) relations.
I.9.27 DeÔ¨Ånition. The set ‚àÜ0(LA) of formulas over LA is the smallest set of
formulas over the language that includes the atomic formulas and satisÔ¨Åes the
closure conditions: If A and B are in ‚àÜ0(LA), then so are ¬¨A, A ‚à®B , and
(‚àÉx)<tA, where ‚Äú(‚àÉx)<tA‚Äù is short for (‚àÉx)(x < t ‚àßA).
In (‚àÉx)<tA we require that the variable x does not occur in the term t. In
the case that LA = LN we often simply write ‚àÜ0 rather than ‚àÜ0(LN).
‚ñ°
We do hope (by virtue of choosing boldface type for ‚àÜ0) that we will not
confuse this set of formulas over LN with the 0 relations of the arithmetic
hierarchy.
I.9.28 Lemma. Every relation in CA is deÔ¨Ånable in N over LN (in the sense
of (D) above) by some formula in ‚àÜ0.
Proof. We do induction on CA. The basis contains two cases, z = x + y and
z = xy.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 173
v0 = v1 + v2 deÔ¨Ånes z = x + y, since for any a, b, c in N,
(a = b +c)N = t ‚Üî(a = b + c)N = t
‚ÜîaN = b
N + N cN
‚Üîa = b + c
An analogous case can be made for z = xy.
We leave it to the reader to verify that if R and Q are deÔ¨Åned by R and Q
respectively, then ¬¨R and R ‚à®Q are deÔ¨Åned by ¬¨R and R ‚à®Q respectively.
Finally, we show that (‚àÉx)<y R(‚Éózr, x) is deÔ¨Åned by (‚àÉx)<yR, that is,
(‚àÉvr+1)(vr+1 < v0 ‚àßR(v1, . . . , vr, vr+1))
Fix b0, . . . , br in N. Trivially, x < y deÔ¨Ånes x < y; thus (using the I.H. for R)
for any Ô¨Åxed a in N,
a < b0 ‚àßR(‚Éóbr, a)
iff
|=N a < 
b0 ‚àßR(
b1, . . . , 
br,a)
(i)
Let (‚àÉx)<b0 R(‚Éóbr, x). Then the left side of ‚Äúiff‚Äù in (i) holds for some a; hence
so does the right side. Therefore,
|=N a < 
b0 ‚àßR(
b1, . . . , 
br, a)
(ii)
Hence
|=N (‚àÉvr+1)(vr+1 < 
b0 ‚àßR(
b1, . . . , 
br, vr+1))
(iii)
Conversely, if (iii) holds, then so does (ii) for some a, and hence also the right
hand side of ‚Äúiff‚Äù in (i). This yields the left hand side; thus (‚àÉx)<b0 R(‚Éóbr, x). ‚ñ°
I.9.29 Lemma. Every relation that is deÔ¨Ånable in N by some formula in ‚àÜ0
over LN is in PR‚àó.
Proof. Induction on ‚àÜ0.
Basis.
An atomic formula is t = s or t < s. It is a trivial matter to verify
that a relation deÔ¨Åned by such formulas is obtained by Œªxy.x = y and Œªxy.x < y
by a Ô¨Ånite number of explicit transformations and substitutions of the functions
Œªxy.x + y and Œªxy.xy for variables. We know that this does not lead beyond
PR‚àó.
Induction step.
Relations deÔ¨Åned by combining their deÔ¨Åning formulas
from ‚àÜ0, using (the formal) ¬¨, ‚à®,(‚àÉx)<y also stay in PR‚àóby the closure of
the latter set under (the informal) ¬¨, ‚à®, (‚àÉx)<y.
‚ñ°

174
I. Basic Logic
The above lemma can be sharpened to replace PR‚àóby CA. This follows
from results of Bennett (1962) (retold in Tourlakis (1984)), that CA predicates
are closed under replacement of variables by so-called rudimentary functions
(Smullyan (1961), Bennett (1962), Tourlakis (1984)).
I.9.30 Theorem. A relation is arithmetic iff it is deÔ¨Ånable in N over LN.
Proof. If part.
We do induction on the complexity of the deÔ¨Åning formula.
Atomic formulas deÔ¨Åne relations in PR‚àó, as was seen in the basis step above
(indeed, relations in CA by the previous remarks), and hence in 0 (DeÔ¨Åni-
tion I.8.60). Since arithmetic relations are closed under ¬¨, ‚à®, (‚àÉx), the property
(that relations which are Ô¨Årst order deÔ¨Ånable in N are arithmetic) propagates
with (the formal) ¬¨, ‚à®,(‚àÉx).
Only-if part.
This follows because z = x + y and z = xy are deÔ¨Ånable
(I.9.28), and deÔ¨Ånability is preserved by Boolean operations and (‚àÉx).
‚ñ°
We now turn to Tarski‚Äôs theorem.
I.9.31 Theorem (Tarski). The set T = {‚åúA‚åù: A ‚ààT (N)} is not arithmetic;
therefore it is not deÔ¨Ånable in N (over LN).
Proof. Suppose that T is arithmetic, say,
(Œªx.x ‚ààT) ‚ààm ‚à™m
Pick R(x) ‚ààm+1 ‚àím ‚à™m (cf. I.8.72), and let the regular formula R(v0) ‚Äì
or, simply, R ‚Äì deÔ¨Åne R over LN.
Clearly, the formula
(‚àÉv0)

v0 = v1 ‚àßR(v0)

also deÔ¨Ånes R(x), since
|= R(v1) ‚Üî(‚àÉv0)

v0 = v1 ‚àßR(v0)

Thus,
R(n) ‚Üî|=N (‚àÉv0)

v0 =n ‚àßR

‚Üî
)
‚åú‚àÉ‚åù, ‚åúv0‚åù,

‚åú‚àß‚åù, ‚ü®‚åú= ‚åù, ‚åúv0‚åù, ‚åún‚åù‚ü©, ‚åúR‚åù
*
‚ààT

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 175
By I.9.26, g = Œªn.‚ü®‚åú‚àÉ‚åù, ‚åúv0‚åù, ‚ü®‚åú‚àß‚åù, ‚ü®‚åú= ‚åù, ‚åúv0‚åù, ‚åún‚åù‚ü©, ‚åúR‚åù‚ü©‚ü©is in R.‚Ä†
Thus, R(x) iff g(x) ‚ààT; hence R(x) ‚ààm ‚à™m, which is absurd.
‚ñ°
The trick of considering (‚àÉv0)(v0 = v1 ‚àßR(v0)) is due to Tarski. It simpliÔ¨Åes
the task of computing the G¬®odel number of (a formula equivalent to) R(n)
from n and the G¬®odel number of R(v0).
G¬®odel‚Äôs original approach to computing such numbers was more complica-
ted, utilizing a substitution function ‚Äì sub‚Ä° (see next chapter) ‚Äì that was analo-
gous to Kleene‚Äôs later invention, the ‚ÄúS-m-n‚Äù functions of recursion theory.
We have cheated a bit in the above proof, in pretending that ‚Äú‚àß‚Äù was a basic
symbol of the alphabet. The reader can easily Ô¨Åx this by invoking De Morgan‚Äôs
laws.
We have just seen that the set of all formulas of arithmetic that are true in
the standard structure N is really ‚Äúhard‚Äù.¬ß Certainly it is recursively unsolvable
(not even semi-recursive, not even arithmetic, . . . ).
Whatcanwesayaboutprovableformulasofarithmetic?Butthen,‚Äúprovable‚Äù
under what (nonlogical) axioms?
I.9.32 DeÔ¨Ånition (Formal Arithmetic(s)). We will use the ambiguous phrase
‚Äúa Formal Arithmetic‚Äù for any Ô¨Årst order theory over a language LA for arith-
metic (DeÔ¨Ånition I.9.21), that contains at least the following nonlogical axioms
(due to R. M. Robinson (1950)).
The speciÔ¨Åc Formal Arithmetic over LN that has precisely the following
nonlogical axioms we will call ROB. The name ‚ÄúROB‚Äù will also apply to the
list of the axioms below:
ROB-1. (Regarding S)
S1.
¬¨Sx = 0 (for any variable x)
S2.
Sx = Sy ‚Üíx = y (for any variables x, y)
ROB-2. (Regarding +)
+1.
x + 0 = x (for any variable x)
+2.
x + Sy = S(x + y) (for any variables x, y)¬∂
‚Ä† It is trivial to see that the Œª‚Éóx.‚ü®‚Éóx‚ü©that was introduced on p.165 is in R. With slightly more effort
(Exercise I.106) one can see that it is even in PR, and therefore so is g.
‚Ä° The function sub is primitive recursive, of two arguments, such that‚åúR(n)‚åù= sub(g, n), where
g = ‚åúR(v0)‚åù.
¬ß These are the formulas we often call ‚Äúreally true‚Äù.
¬∂ If we had stayed with the formal notation of p. 167, we would not have needed brackets here.
We would have simply written +xSy = S + xy.

176
I. Basic Logic
ROB-3. (Regarding √ó)
√ó1.
x √ó 0 = 0 (for any variable x)
√ó2.
x √ó Sy = (x √ó y) + x (for any variables x, y)
ROB-4. (Regarding <)
<1.
¬¨x < 0 (for any variable x)
<2.
x < Sy ‚Üîx < y ‚à®x = y (for any variables x, y)
<3.
x < y ‚à®x = y ‚à®y < z (for any variables x, y).
Let us abstract (i.e., generalize) the situation, for a while, and assume that
we have the following:
(1) An arbitrary Ô¨Årst order language L over some Ô¨Ånite alphabet V (not nec-
essarily the one for formal arithmetic).
(2) A G¬®odel numbering ‚åú‚åùof V + that we extend to terms and formulas, exactly
as we described starting on p. 168, where we extended the speciÔ¨Åc G¬®odel
numbering on the alphabet of arithmetic (p. 166). We are continuing to base
our coding on the ‚ü®‚ü©of p. 165.
(3) A theory  over L with a recursive set of axioms, , that is, one for which
the set A = {‚åúF ‚åù: F ‚àà} is recursive.
(4) The theory  has just two rules of inference,
I1 : A
B
I2 : A, B
C
(5) There are recursive relations I1(x, y), I2(x, y, z), corresponding to I1 and
I2, that mean
I1(‚åúX ‚åù, ‚åúY ‚åù)
iff
X ‚ä¢Y via I1
and
I2(‚åúX ‚åù, ‚åúY ‚åù, ‚åúZ‚åù)
iff
X , Y ‚ä¢Z via I2
That is, intuitively, we require the rules of inference to be ‚Äúcomputable‚Äù (or
algorithmic).
We call such a theory recursively axiomatized.
A proof over  is a sequence of formulas A1, A2, . . . , Ar, and it is assigned
the G¬®odel number ‚ü®‚åúA1‚åù, ‚åúA2‚åù, . . . , ‚åúAr‚åù‚ü©.
The following is at the root of G¬®odel‚Äôs incompletableness result.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 177
I.9.33 Theorem. If  is a recursively axiomatized theory over L, then Thm
is semi-recursive.
Of course, this means that the set of G¬®odel numbers of theorems,  = {‚åúA‚åù:
A ‚ààThmŒì}, is semi-recursive.
Proof. We set A = {‚åúA‚åù: A ‚àà} and B = {‚åúA‚åù: A ‚àà}, where  is
our ‚Äústandard‚Äù set of logical axioms. We defer to the reader the proof that B is
recursive.
Actually, we suggest the following easier approach. Show that the set of G¬®odel
numbers of an equivalent set of logical axioms, 2 (Exercises I.26‚ÄìI.41) is
recursive (indeed, primitive recursive).
Let Proof(u) mean that u is the G¬®odel number of a -proof. Then
Proof (u) ‚ÜîSeq(u) ‚àß(‚àÄi)<lh(u)
%
(u)i ‚ààA ‚à®(u)i ‚ààB ‚à®
(‚àÉj)<i I1((u) j, (u)i) ‚à®
(‚àÉj)<i(‚àÉk)<i I2((u) j, (u)k, (u)i)
&
Thus, Proof (u) is in R‚àó.
Finally, if  = {‚åúA‚åù:  ‚ä¢A} (the set of G¬®odel numbers of -theorems),
then  is semi-recursive, since
x ‚àà ‚Üî(‚àÉu)

Proof (u) ‚àß(‚àÉi)<lh(u)x = (u)i

‚ñ°
I.9.34 Corollary. The set of theorems of any recursively axiomatized formal
arithmetic is semi-recursive. In particular, the set of theorems of ROB is semi-
recursive.
I.9.35 DeÔ¨Ånition. Smullyan (1992). Let us call a formal arithmetic  over LN
correct iff  ‚äÜT (N).
‚ñ°
Many people call such an arithmetic ‚Äúsound‚Äù. We opted for the nomenclature
‚Äúcorrect‚Äù, proposed in Smullyan (1992), because we have deÔ¨Åned ‚Äúsound‚Äù in
such a manner that all Ô¨Årst order theories (recursively axiomatizable or not) are
sound (that is due to the ‚Äúeasy half‚Äù of G¬®odel‚Äôs completeness theorem).
Correctness along with soundness implies Thm ‚äÜT (N).
Thus, we can rephrase the above corollary as
I.9.36 Corollary (G¬®odel‚Äôs First Incompleteness Theorem). [Semantic ver-
sion]. ROB is incompletable as long as we extend it correctly and recursively

178
I. Basic Logic
over the language LN. That is, every correct recursively axiomatized formal
arithmetic  over LN is simply incomplete: There are inÔ¨Ånitely many sentences
F over LN that are undecidable by .
Proof. Since  is correct, Thm ‚äÜT (N). This is an inequality because Thm
is semi-recursive, while T (N) is not even arithmetic.
Every one of the inÔ¨Ånitely many sentences F ‚ààT (N) ‚àíThm,
Pause. Why ‚ÄúinÔ¨Ånitely many‚Äù?
is unprovable. By correctness, ¬¨F is not provable either, since it is false.
‚ñ°
I.9.37 Remark. (1) ROB has N as a model. Thus it is correct and, of course,
consistent.
(2) There are some ‚Äúreally true‚Äù sentences that we cannot prove in ROB (and,
by correctness of ROB, we cannot prove their negations either). For example,
(‚àÄx)¬¨x < x is not provable (see Exercise I.108).
Similarly, (‚àÄx)(‚àÄy)x + y = y + x is not provable (see Exercise I.109).
Thus, it may not have come as a surprise that this formal arithmetic is
incomplete. G¬®odel‚Äôs genius came in showing that it is impossible to complete
ROB by throwing axioms at it (a recursive set thereof). It is incompletable.
(3)Itturnsoutthatthereisan‚Äúalgorithm‚ÄùtogeneratesentencesF ‚ààT (N)‚àí
Thm for any recursive  that has been ‚Äúgiven‚Äù, say as a Wm (that is, Wm =
{‚åúF ‚åù: F ‚àà}).
First of all (cf. proof of I.9.33), we revise Proof (u) to Œªum. Proof (u, m),
given by
Proof (u, m) ‚ÜîSeq(u) ‚àß(‚àÄi)<lh(u)
%
(‚àÉz)T (1)(m, (u)i, z) ‚à®(u)i ‚ààB ‚à®
(‚àÉj)<i I1((u) j, (u)i) ‚à®
(‚àÉj)<i(‚àÉk)<i I2((u) j, (u)k, (u)i)
&
We set m = {‚åúA‚åù: (m) ‚ä¢A}, where the subscript (m) of  simply reminds
us how the axioms are ‚Äúgiven‚Äù, namely: Wm = A = {‚åúF ‚åù: F ‚àà(m)}.
Then x ‚ààm ‚Üî(‚àÉu)(Proof (u, m) ‚àßx = (u)lh(u)
.‚àí1), a semi-recursive
relation of x and m, is equivalent to ‚Äú{a}(u, m) ‚Üì‚Äù for some a, and therefore to
‚Äú{S1
1(a, m)}(u) ‚Üì‚Äù. Setting f (m) = S1
1(a, m) for all m, we have
There is a primitive recursive function f such that m = W f (m)
(‚àó)
Pause. A by-product worth verbalizing is that if the set of axioms is semi-
recursive, then so is the set of theorems, and from a semi-recursive index of the
former, a semi-recursive index of the latter is primitive recursively computable.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 179
Let now H (v0) deÔ¨Åne Œªx.¬¨(‚àÉz)T (1)(x, x, z). Clearly, it is also the case that
¬¨(‚àÉz)T (1)(x, x, z)
iff
|=N (‚àÉv0)

v0 =x ‚àßH (v0)

We next consider the set K = {‚åú(‚àÉv0)(v0 =x ‚àßH (v0))‚åù: x ‚ààK}.
Set, for all x,
g(x) = ‚åú(‚àÉv0)

v0 =x ‚àßH (v0)

‚åù
Then g ‚ààPR, for the reason we saw in the proof of I.9.31, and
x ‚ààK
iff
g(x) ‚ààK
We also consider the set Q = {‚åú(‚àÉv0)(v0 =x ‚àßH (v0))‚åù: x ‚ààN}. Since
x ‚ààN iff g(x) ‚ààQ, and g is strictly increasing, Q is recursive (Exercise I.95).
Actually, all we will need here is that Q is semi-recursive, and this it readily
is, since it is r.e. (DeÔ¨Ånition I.8.50) via g (strictly increasing or not). Trivially,
K = Q ‚à©T
(‚àó‚àó)
where, as in I.9.31, we have set T = {‚åúA‚åù: A ‚ààT (N)}.
We make a few observations:
(i) If Wi ‚äÜK, then i ‚ààK ‚àíWi (else, i ‚ààK ‚à©K). Sets such as K that come
equipped with an algorithm for producing counterexamples to a claim
K = Wi are called productive (Dekker 1995). That is, a set S is productive
with productive function h ‚ààR iff for all i, Wi ‚äÜS implies h(i) ‚ààS‚àíWi.
In particular, h = Œªx.x works in the case of K.
(ii) We saw that K = g‚àí1[K], where g‚àí1[. . . ] denotes inverse image. We show
that K is productive as well. We just need to Ô¨Ånd a productive function for
K. Let Wi ‚äÜK. Then g‚àí1[Wi] ‚äÜg‚àí1[K] = K. By the S-m-n theorem,
there is an h ‚ààPR such that g‚àí1[Wi] = Wh(i). Indeed,
x ‚ààg‚àí1[Wi] ‚Üîg(x) ‚ààWi
‚Üî{i}(g(x)) ‚Üì
‚Üî{e}(x, i) ‚Üì
for some e (why?)
‚Üî{S1
1(e, i)}(x) ‚Üì
Take h = Œªx.S1
1(e, x). Thus, h(i) ‚ààK ‚àíWh(i) = g‚àí1[K ‚àíWi] (g is 1-1).
Therefore Œªx.g(h(x)) is the sought productive function.
(iii) We Ô¨Ånally show that T is productive, using (‚àó‚àó) above. First, we ask the
reader (Exercise I.98) to show that there is a k ‚ààPR such that
Wk(i) = Wi ‚à©Q
(1)

180
I. Basic Logic
(recall that Q is semi-recursive). We can now Ô¨Ånd a productive function
for T. Let Wi ‚äÜT. Thus, Wk(i) ‚äÜT ‚à©Q = K, from which
g(h(k(i))) ‚ààT ‚à©Q ‚àíWi ‚à©Q = T ‚à©Q ‚àíWi ‚äÜT ‚àíWi
We return now to what this was all about: Suppose we have started with a
correct recursively axiomatized extension of ROB,  (over LN), where Wi is
the set of G¬®odel numbers of the nonlogical axioms. By (‚àó), the set of G¬®odel
numbers of the -theorems is W f (i). By correctness, W f (i) ‚äÜT.
Then g(h(k( f (i)))) is the G¬®odel number of a true unprovable sentence. A
œÜ-index of Œªi.g(h(k( f (i)))) is an algorithm that produces this sentence for any
set of axioms (coded by) i.
‚ñ°
We saw in I.9.37(2) above that ROB cannot prove some startlingly simple
(and useful) formulas. On the other hand, it turns out that it has sufÔ¨Åcient power
to ‚ÄúdeÔ¨Åne syntactically‚Äù all recursive relations. We now turn to study this phe-
nomenon, which will lead to a syntactic version of G¬®odel‚Äôs Ô¨Årst incompleteness
theorem.
I.9.38 DeÔ¨Ånition. Let  be a formal arithmetic over some language LA(‚äáLN).
We say that a relation R ‚äÜNr is formally deÔ¨Ånable in , or -deÔ¨Ånable, iff
there is a formula R(v0, . . . , vr‚àí1) over LA such that, for all ‚Éóar in N,
if
R(‚Éóar),
then
 ‚ä¢R(
a1, . . . , 
ar)
and
if
¬¨R(‚Éóar),
then
 ‚ä¢¬¨R(
a1, . . . , 
ar)
Of course, the left ‚Äú¬¨‚Äù is informal (metamathematical); the right one is formal.
We say that R formally deÔ¨Ånes R, but often, just that it deÔ¨Ånes R. The
context will determine if we mean formally or in the semantic sense.
‚ñ°
The terminology that names the above concept varies quite a bit in the literature.
Instead of ‚Äúformally deÔ¨Ånable‚Äù some say just ‚ÄúdeÔ¨Ånable‚Äù and let the context
Ô¨Åx the meaning. Out of a fear that the context might not always successfully
do so, we added the obvious qualiÔ¨Åer ‚Äúformally‚Äù, since this type of deÔ¨Ånability
is about provability, while the other one (I.5.15) is about truth. Terms such
as ‚Äúrepresentable‚Äù (or ‚Äú-representable‚Äù) are also used elsewhere instead of
‚Äúformally deÔ¨Ånable‚Äù.
It is clear that if R is ROB-deÔ¨Ånable and  extends ROB (over the same or
over an extended language), then R is also -deÔ¨Ånable.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 181
I.9.39 Lemma. x = y is ROB-deÔ¨Ånable.
Proof. We show that v0 = v1 deÔ¨Ånes x = y.
Let a = b (be true). Thus a and b are identical strings over LA. Therefore
‚ä¢a =b by substitution in the logical axiom x = x.
In the present sequence of lemmata regarding the power of ROB we abuse
notation and simply write ‚Äú‚ä¢. . . ‚Äù rather than ‚ÄúROB ‚ä¢. . . ‚Äù or ‚Äú‚ä¢ROB . . . ‚Äù.
Let next a Ã∏= b. We use (metamathematical) induction on b to show ‚ä¢
¬¨a =b.
Basis.
If b = 0, then a = c+1 for some c, under the assumption. We want
‚ä¢¬¨
c + 1 =0, i.e., ‚ä¢¬¨Sc =0, which we have, by axiom S1 (I.9.32) and
substitution.
Induction step.
We now go to the case a Ã∏= b + 1. If a = 0, then we are back
to what we have already argued (using ‚ä¢x = y ‚Üíy = x). Let then a = c + 1.
Thus, c Ã∏= b, and hence (I.H.), ‚ä¢¬¨c =b. By S2 (and |=Taut) ‚ä¢¬¨Sc = Sb, i.e.,
‚ä¢¬¨
c + 1 = 
b + 1.
‚ñ°
I.9.40 Corollary. Let t be a term with the free variables v0, . . . ,vn‚àí1 and f a
total function of n arguments such that, for all ‚Éóan, b, if f (‚Éóan) = b, then
‚ä¢t(
a1, . . . , 
an) =b
Then the formula t(v0, . . . , vn‚àí1) = vn deÔ¨Ånes the graph of f .
Proof. It sufÔ¨Åces to show that if f (‚Éóan) Ã∏= b, then
‚ä¢¬¨t(
a1, . . . , 
an) =b
(1)
Well, the assumption means that for some c Ã∏= b, f (‚Éóan) = c ( f is total), and
hence ‚ä¢t(
a1, . . . , 
an) =c.
If we add t(
a1, . . . , 
an) =b to our assumptions, then ‚ä¢c =b (by ‚ä¢x =
y ‚Üíy = z ‚Üíx = z and substitution), which contradicts ‚ä¢¬¨c =b, yielded
by c Ã∏= b. Via proof by contradiction we have established (1).
‚ñ°
A function such as f above is term-deÔ¨Åned by t (in ROB). Suppressing mention
of t, we just say ‚Äú f is term-deÔ¨Ånable‚Äù (in ROB).
I.9.41 Lemma. x + y = z is ROB-deÔ¨Ånable.
Proof. The formula v0 + v1 = v2 Ô¨Ålls the bill. Indeed, by Corollary I.9.40 we
only need to prove that
a + b = c
implies
‚ä¢a +b =c
(2)

182
I. Basic Logic
We do induction on b.
Basis.
Let b = 0. Then, a = c; thus
‚ä¢a =c
(3)
By axiom +1 (I.9.32) and substitution, ‚ä¢a +0 =a. Transitivity of formal
equality and (3) yield ‚ä¢a +0 =c.
Induction step.
Let a + (b + 1) = c. Then c = d + 1 for some d; hence
a + b = d. By I.H.,
‚ä¢a +b = d
Hence
‚ä¢S(a +b) = Sd
(4)
by the Leibniz axiom (substitution and modus ponens).
By axiom +2, we also have (via substitution)
‚ä¢a + Sb = S(a +b)
so that transitivity of equality and (4) result in
‚ä¢a + Sb = Sd
that is, ‚ä¢a + 
b + 1 = 
d + 1.
‚ñ°
I.9.42 Lemma. x √ó y = z is ROB-deÔ¨Ånable.
Proof. Exercise I.110.
‚ñ°
I.9.43 Lemma. x < y is ROB-deÔ¨Ånable.
Proof. By induction on b we prove simultaneously
a < b
implies
‚ä¢a <b
(i)
and
a Ã∏< b
implies
‚ä¢¬¨a <b
(ii)
Basis.
For b = 0, (i) is vacuously satisÔ¨Åed, while (ii) follows from axiom <1
and substitution.
Induction step.
Let a < b + 1. Thus, a < b or a = b. One case yields (I.H.)
‚ä¢a <b, and the other ‚ä¢a =b (I.9.39).

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 183
By tautological implication, ‚ä¢a <b ‚à®a =b in either case. Hence ‚ä¢a <
Sb, by substitution, |=Taut, and axiom < 2. That is, ‚ä¢a < 
b + 1.
Let next a Ã∏< b + 1. Thus, a Ã∏< b and a Ã∏= b. Thus we have both ‚ä¢¬¨a <b
(by I.H.) and ‚ä¢¬¨a =b (by I.9.39); hence (|=Taut)
‚ä¢¬¨(a <b ‚à®a =b)
(iii)
Via the equivalence theorem (I.4.25), |=Taut, and axiom <2, (iii) yields ‚ä¢
¬¨a < Sb, that is, ‚ä¢¬¨a < 
b + 1.
‚ñ°
I.9.44 Lemma. For any formula A and number n, ROB can prove
A[0], . . . , A[ 
n ‚àí1] ‚ä¢x <n ‚ÜíA
where n = 0 means that we have nothing nonlogical to the left of ‚Äú ‚ä¢‚Äù (beyond
the axioms of ROB).
Proof. Induction on n.
Basis.
If n = 0, then we need ‚ä¢x <0 ‚ÜíA, which is a tautological impli-
cation of axiom <1.
Induction step.
We want
A[0], . . . , A[n] ‚ä¢x < Sn ‚ÜíA
By axiom <2 and the equivalence theorem (I.4.25) we need to just prove
A[0], . . . , A[n] ‚ä¢(x <n ‚à®x =n) ‚ÜíA
This follows at once by proof by cases (I.4.26) since A[0], . . . , A[ 
n ‚àí1] ‚ä¢
x <n ‚ÜíA (by I.H.) and A[n] ‚ä¢x =n ‚ÜíA by tautological implication from
the Leibniz axiom and modus ponens.
‚ñ°
By the deduction theorem we also get
ROB ‚ä¢A[0] ‚Üí¬∑ ¬∑ ¬∑ ‚ÜíA[ 
n ‚àí1] ‚Üíx <n ‚ÜíA
I.9.45 Lemma. ROB-deÔ¨Ånable relations are closed under Boolean operations.
Proof. If R and Q are deÔ¨Åned by R and Q respectively, then it is a trivial
exercise (Exercise I.111) to show that ¬¨R and R ‚à®Q are deÔ¨Åned by ¬¨R and
R ‚à®Q respectively.
‚ñ°
I.9.46 Lemma. ROB-deÔ¨Ånable relations are closed under explicit transforma-
tions.

184
I. Basic Logic
Proof. (Mostly a task for the reader, Exercise I.112).
Substitution by a constant.
Let R(z, ‚Éóxm) be deÔ¨Åned by R(z,‚Éóxm) (where
we have used syntactic variables z,‚Éóxm for v0, . . . , vm).
Then, for any a ‚ààN, R(a, ‚Éóxm) is deÔ¨Åned by R(a,‚Éóxm). Indeed, for any
‚Éóbm, if R(a, ‚Éóbm), then ‚ä¢R(a, 
b1, . . . , 
bm), and if ¬¨R(a, ‚Éóbm), then ‚ä¢¬¨R(a,

b1,. . . , 
bm).
Introduction of a new variable.
Let Q(‚Éóxn) be deÔ¨Åned by Q (‚Éóxn) and let
S(z, ‚Éóxn) ‚ÜîQ(‚Éóxn) for all z, ‚Éóxn, where z is a new variable. That is, S(z, ‚Éóxn) ‚Üî
Q(‚Éóxn) ‚àßz = z; hence it is deÔ¨Ånable (by Q (‚Éóxn) ‚àßz = z, incidentally) due
to I.9.39, and I.9.45.
‚ñ°
I.9.47 Lemma. ROB-deÔ¨Ånable relations are closed under (‚àÉx)<y.
Proof. Let Q(x, ‚Éózn) be deÔ¨Åned by Q (x,‚Éózn). We show that (‚àÉx)<yQ (x,‚Éózn) ‚Äì
that is,
(‚àÉx)

x < y ‚àßQ (x,‚Éózn)

‚Äì deÔ¨Ånes (‚àÉx)<y Q(x, ‚Éózn).
Let (‚àÉx)<a Q(x, ‚Éóbn). Then, for some c < a, we have Q(c, ‚Éóbn). By I.9.43,
I.9.45, the assumption, and |=Taut,
‚ä¢c <a ‚àßQ (c, 
b1 . . . , 
bn)
Hence (by the substitution axiom and modus ponens)
‚ä¢(‚àÉx)

x <a ‚àßQ (x, 
b1 . . . , 
bn)

Next, let ¬¨(‚àÉx)<a Q(x, ‚Éóbn), that is,
Q(0, ‚Éóbn), . . . , Q(a ‚àí1, ‚Éóbn) are all false
By assumption on Q,
‚ä¢¬¨Q (i, 
b1, . . . , 
bn),
for i = 0, 1, . . . , a ‚àí1
Hence (I.9.44 followed by generalization)
‚ä¢(‚àÄx)

x <a ‚Üí¬¨Q (x, 
b1 . . . , 
bn)

In short, removing the abbreviation ‚Äú‚àÄ‚Äù, and using the logical axiom (tautology)

x <a ‚Üí¬¨Q (x, 
b1 . . . , 
bn)

‚Üî¬¨

x <a ‚àßQ (x, 
b1 . . . , 
bn)

and the equivalence theorem, we have
‚ä¢¬¨(‚àÉx)

x <a ‚àßQ (x, 
b1 . . . , 
bn)

‚ñ°
We have established

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 185
I.9.48 Proposition. Every relation in CA is ROB-deÔ¨Ånable.
I.9.49 Lemma (Separation Lemma). Let R and Q be any two disjoint semi-
recursive sets. Then there is formula F (x) such that, for all m ‚ààN,
m ‚ààR
implies
ROB ‚ä¢F (m)
and
m ‚ààQ
implies
ROB ‚ä¢¬¨F (m)
Proof. By I.9.19, there are relations A(x, y) and B(x, y) in CA such that
m ‚ààR ‚Üî(‚àÉx)A(x, m)
(1)
and
m ‚ààQ ‚Üî(‚àÉx)B(x, m)
(2)
for all m. By I.9.48, let A and B deÔ¨Åne A and B respectively.
We deÔ¨Åne F (y) to stand for
(‚àÉx)
%
A(x, y) ‚àß(‚àÄz)

z < x ‚Üí¬¨B (z, y)
&
(3)
and proceed to show that it satisÔ¨Åes the conclusion of the lemma.
Let m ‚ààR. Then m /‚ààQ; hence (by (1) and (2)), A(n, m) holds for some n,
while B(i, m), for all i ‚â•0, are false. Thus,
‚ä¢A(n, m)
(4)
and ‚ä¢¬¨B(i, m), for i ‚â•0.‚Ä† By I.9.44, ‚ä¢z <n ‚Üí¬¨B(z, m); hence by gene-
ralization followed by |=Taut (using (4)),
‚ä¢A(n, m) ‚àß(‚àÄz)
%
z <n ‚Üí¬¨B(z, m)
&
The substitution axiom and |=Taut yield
‚ä¢(‚àÉx)
%
A(x, m) ‚àß(‚àÄz)

z < x ‚Üí¬¨B(z, m)
&
i.e., ‚ä¢F (m).
Let next m ‚ààQ. We want to show that ‚ä¢¬¨F (m), which ‚Äì referring to
(3) and using |=Taut, using the Leibniz rule, and inserting/removing the deÔ¨Åned
symbol ‚Äú‚àÄ‚Äù ‚Äì translates to‚Ä°
(‚àÄx)
%
¬¨A(x, y) ‚à®(‚àÉz)

z < x ‚àßB (z, y)
&
(5)
‚Ä† Throughout, ‚Äú ‚ä¢‚Äù is short for ‚Äú ‚ä¢ROB‚Äù, of course.
‚Ä° ‚ÄúTranslates to‚Äù means ‚Äúis provably equivalent to, without the assistance of any nonlogical
axioms‚Äù.

186
I. Basic Logic
The assumption yields m /‚ààR; hence (by (1) and (2)), B(n, m) holds for some
n, while A(i, m), for all i ‚â•0, are false. Thus,
‚ä¢B(n, m)
(6)
and‚ä¢¬¨A(i, m)fori ‚â•0.Thelatteryields(byI.9.44)‚ä¢x < Sn ‚Üí¬¨A(x, m),
or, using the Leibniz rule and axiom <2,
‚ä¢(x <n ‚à®x = n) ‚Üí¬¨A(x, m)
(7)
(6) and |=Taut yield ‚ä¢n < x ‚Üín < x ‚àßB(n, m); therefore
‚ä¢n < x ‚Üí(‚àÉz)

z < x ‚àßB(z, m)

(8)
by the substitution axiom and |=Taut.
Proof by cases (I.4.26) and (7) and (8) yield
‚ä¢(x <n ‚à®x = n ‚à®n < x) ‚Üí¬¨A(x, m) ‚à®(‚àÉz)

z < x ‚àßB(z, m)

Hence (axiom <3)
‚ä¢¬¨A(x, m) ‚à®(‚àÉz)

z < x ‚àßB(z, m)

The generalization of the above is (5).
‚ñ°
The above lemma trivially holds for predicates of any number of arguments.
That is, we may state and prove, with only notational changes (‚Éóy for y, ‚Éóm for
m, ‚Éóm for m), the same result for disjoint semi-recursive subsets of Nn, for any
n > 0.
I.9.50 Corollary. Every recursive predicate is deÔ¨Ånable in ROB.
Proof. If R ‚äÜNn is recursive, then it and Nn ‚àíA are semi-recursive.
‚ñ°
We can say a bit more. First, a deÔ¨Ånition:
I.9.51 DeÔ¨Ånition. A predicate R(‚Éóxn) is strongly formally deÔ¨Ånable in , or
just strongly deÔ¨Ånable in , iff, for some formula R(‚Éóxn), both of the following
equivalences hold (for all ‚Éóbn ‚ààN):
R(‚Éóbn)
iff
 ‚ä¢R(
b1, . . . , 
bn)
and
¬¨R(‚Éóbn)
iff
 ‚ä¢¬¨R(
b1, . . . , 
bn)
We say that R strongly deÔ¨Ånes R (in ).
‚ñ°

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 187
Correspondingly, a total function f (‚Éóxn) is strongly term-deÔ¨Ånable by t just in
case, for all c, ‚Éóbn ‚ààN,
f (‚Éóbn) = c
iff
 ‚ä¢t(
b1, . . . , 
bn) =c
I.9.52 Corollary. Every recursive predicate is strongly deÔ¨Ånable in ROB.
Proof. Let the recursive R ‚äÜNn be deÔ¨Åned (in ROB) by R(‚Éóxn). We already
have the ‚Üí-directions for the positive and negative cases (by ‚Äúweak‚Äù deÔ¨Ånabil-
ity). We need the ‚Üê-directions.
Let then ‚ä¢R(
m1, . . . , 
mn). If ¬¨R( ‚Éómn), then also ‚ä¢¬¨R(
m1, . . . , 
mn),
contradicting the consistency of ROB.‚Ä† Thus, R( ‚Éómn). A similar argument works
for the negative case.
‚ñ°
We have at once
I.9.53 Corollary. Every recursive predicate is strongly deÔ¨Ånable in any con-
sistent extension of ROB.
‚ñ°
I.9.54 DeÔ¨Ånition. Two disjoint semi-recursive subsets R and Q of N are re-
cursively inseparable iff there is no recursive set S such that R ‚äÜS and S ‚äÜQ
(where Q = N ‚àíQ).
‚ñ°
I.9.55 Lemma. R = {x : {x}(x) = 0} and Q = {x : {x}(x) = 1} are recursively
inseparable.
Proof. Clearly R and Q are disjoint semi-recursive sets (why?).
Let S be recursive, and suppose that it separates R and Q, i.e.,
R ‚äÜS ‚äÜQ
(1)
Let {i} = œáS.
Assume that i ‚ààS. Then {i}(i) = 1, hence i ‚ààQ (deÔ¨Ånition of Q). But also
i ‚ààQ, by (1).
Thus, i ‚ààS, after all. Well, if so, then {i}(i) = 0, hence i ‚ààR (deÔ¨Ånition
of R). By (1), i ‚ààS as well.
Thus i /‚ààS ‚à™S = N, which is absurd.
‚ñ°
‚Ä† Having adopted a Platonist‚Äôs metatheory, the fact that N is a model of ROB establishes consis-
tency. A constructive proof of the consistency of ROB is beyond our scope. For an outline see
ShoenÔ¨Åeld (1967).

188
I. Basic Logic
I.9.56 Theorem (Church‚Äôs Theorem). (Church (1936)). For any consistent
extension of ROB, the set Thm is not recursive.
‚ñ°
Proof. Let  = {‚åúA‚åù: A ‚ààThm}, where  consistently extends ROB.
Applying I.9.49 to the R and Q of I.9.55, we obtain a formula F of a single
free variable v0 such that
m ‚ààR
implies
 ‚ä¢F (m)
(1)
and
m ‚ààQ
implies
 ‚ä¢¬¨F (m)
(2)
Let S = {m :  ‚ä¢F (m)}. By (1), R ‚äÜS. By (2) and consistency, Q ‚à©S = ‚àÖ,
i.e., S ‚äÜQ.
By I.9.55,
S /‚ààR‚àó
(3)
By deÔ¨Ånition of S,
m ‚ààS
iff
 ‚ä¢F (m)
iff
 ‚ä¢(‚àÉv0)(v0 = m ‚àßF )
(4)
using the Tarski trick once more (p. 175).
We already know that there is a primitive recursive g such that g(m) =
‚åú(‚àÉv0)(v0 = m ‚àßF )‚åùfor all m.
Suppose now that  ‚ààR‚àó. Then so is S, since (by (4))
m ‚ààS
iff
g(m) ‚àà
(5)
This contradicts (3).
‚ñ°
The above theorem, published some three years after G¬®odel published his
incompleteness results, shows that the decision problem for any consistent
theory ‚Äì not just for one that is recursively axiomatized ‚Äì that contains arith-
metic (ROB) is recursively unsolvable. In particular, we rediscover that T (N),
which extends ROB consistently, is not recursive. Of course, we already know
much more than this about T (N).
Church‚Äôs result shattered Hilbert‚Äôs belief that the Entscheidungsproblem (de-
cision problem) of any axiomatic theory ought to be solvable by ‚Äúmechanical
means‚Äù.
On the other hand, G¬®odel‚Äôs incompleteness theorems had already shown the
untenability of Hilbert‚Äôs hope to address the consistency of axiomatic theories
by Ô¨Ånitary means.‚Ä†
‚Ä† Finitary means can be formalized within Peano arithmetic using, if necessary, arithmetization.
However, the consistency of Peano arithmetic is not provable from within.

I.9. Arithmetic, DeÔ¨Ånability, UndeÔ¨Ånability, and Incompletableness 189
The following is a strengthened (by Rosser (1936)) syntactic version of
G¬®odel‚Äôs Ô¨Årst incompleteness theorem. It makes no reference to correctness;
instead it relies on the concept of consistency.
G¬®odel‚Äôs original syntactic version was proved under stronger consistency
assumptions, that the formal arithmetic under consideration was œâ-consistent.‚Ä†
I.9.57 Theorem (G¬®odel-Rosser First Incompleteness Theorem) [Syntactic
Version]. Any consistent recursive formal arithmetic  is simply incomplete.
Proof. We work with the same R, Q, S as in I.9.55‚ÄìI.9.56. By I.9.34,  is
semi-recursive, and hence, so is S by (5) in the previous proof.
How about S?
At this point we add the assumption (that we expect to contradict) that  is
simply complete. Then (referring to the proof of I.9.56),
m ‚ààS
iff
 Ã∏‚ä¢F (m)
completeness
‚àí‚Üí
‚Üê‚àí
consistency
 ‚ä¢¬¨F (m)
As in the proof of I.9.56, setting, for all m, f (m) = ‚åú(‚àÉv0)(v0 = m ‚àß¬¨F )‚åù,
we get
m ‚ààS
iff
f (m) ‚àà
Since f is in PR, S is semi-recursive; hence S is recursive, contradict-
ing I.9.55.
‚ñ°
I.9.58 Remark. (1) The assumption that  is recursive is not just motivated by
convenience (towards showing that  is r.e.). After all, T (N) is a consistent
and simply complete extension of ROB (but it is not recursively axiomatizable,
as we know).
(2) We can retell the above proof slightly differently:
Let S‚Ä≤ = {m :  ‚ä¢¬¨F (m)}. Then S‚Ä≤ is semi-recursive. S ‚à©S‚Ä≤ = ‚àÖby consis-
tency. Thus, S ‚à™S‚Ä≤ Ã∏= N (otherwise S‚Ä≤ = S, making S recursive).
Let n ‚ààN ‚àíS ‚à™S‚Ä≤. Then Ã∏‚ä¢F (n) and Ã∏‚ä¢¬¨F (n).
It is clear that the set N ‚àíS ‚à™S‚Ä≤ is inÔ¨Ånite (why?); hence we have inÔ¨Ånitely
many undecidable sentences.
(3) For each n ‚ààN ‚àíS ‚à™S‚Ä≤, exactly one of F (n) and ¬¨F (n) is true (in N).
Which one?
‚Ä† A formal arithmetic is œâ-inconsistent iff for some formula F of a single free variable x, (‚àÉx) F
and all of ¬¨ F (m) ‚Äì for all m ‚â•0 ‚Äì are provable. Otherwise, it is œâ-consistent. Of course, an
œâ-consistent theory, as it fails to prove something, is consistent. For G¬®odel‚Äôs original formulation
of the Ô¨Årst theorem see Exercise I.116.

190
I. Basic Logic
We have deÔ¨Åned F (y) ((3) on p. 185 originally; see also the proof of I.9.56)
to stand for
(‚àÉx)

A(x, y) ‚àß(‚àÄz)(z < x ‚Üí¬¨B(z, y))

where, with R and Q as in I.9.55‚ÄìI.9.56,
k ‚ààR
iff
|=N (‚àÉx)A(x,k)
and‚Ä†
k ‚ààQ
iff
|=N (‚àÉx)B(x,k)
We also note that
|= ¬¨F (y) ‚Üî(‚àÄx)

¬¨A(x, y) ‚à®(‚àÉz)(z < x ‚àßB(z, y))

(i)
Now, if n ‚ààN ‚àíS ‚à™S‚Ä≤, then n /‚ààR; hence |=N ¬¨(‚àÉx)A(x,n), that is,
|=N (‚àÄx)¬¨A(x,n)
(ii)
Noting that (I.4.24, p. 50)
|= (‚àÄx) C ‚Üí(‚àÄx)(C ‚à®D )
for any C and D , (ii) yields
|=N ¬¨F (n)
(iii)
(4) œâ-Incompleteness of arithmetic. Now, (iii) implies
|=N G (k,n)
for all k ‚â•0
by (i) and substitution, where G (x, y) abbreviates
¬¨A(x, y) ‚à®(‚àÉz)

z < x ‚àßB(z, y)

Thus,
 ‚ä¢G (k,n)
for all k ‚â•0
since A(x, y) and B(x, y) (p. 185) are in CA.
Thus we have the phenomenon of œâ-incompleteness in any consistent (and
recursive) extension  of ROB. That is, there is a formula H (x) such that while
 ‚ä¢H (k) for all k ‚â•0, yet  Ã∏‚ä¢(‚àÄx)H (x). An example of such an H is
G (x,n). Therefore, Thm for such is not closed under the ‚Äúœâ-rule‚Äù
H (0), H (1), H (2), . . . ‚ä¢(‚àÄx)H (x)
‚Ä† This and the previous equivalence are just restatements of (1) and (2) on p. 185.

I.10. Exercises
191
(5) A consistent but œâ-inconsistent arithmetic. Next, consider the theory
 + F (n), for some Ô¨Åxed n ‚ààN ‚àíS ‚à™S‚Ä≤. Since  Ã∏‚ä¢¬¨F (n), this theory is
consistent. However, it is œâ-inconsistent:
Indeed, by (ii),
|=N ¬¨A(k,n)
for all k ‚â•0
Hence, for reasons already articulated,
 ‚ä¢¬¨A(k,n)
for all k ‚â•0
and, trivially,
 + F (n) ‚ä¢¬¨A(k,n)
for all k ‚â•0
(iv)
But also  + F (n) ‚ä¢F (n), so that, along with (iv), we have derived the
œâ-inconsistency of  + F (n); for
 + F (n) ‚ä¢(‚àÉx)A(x,n)
‚Äì the latter due to ‚ä¢(‚àÉx)(C ‚àßD ) ‚Üí(‚àÉx)C and the deÔ¨Ånition of F .
(6) A consistent but incorrect arithmetic. The consistent formal arithmetic
 + F (n) is not correct, since Ã∏|=N F (n).
(7) From what we have seen here (cf. also Exercise I.113) we can obtain
an alternative foundation of computability via ROB: We can deÔ¨Åne a recursive
predicate to be one that is strongly deÔ¨Ånable in ROB (I.9.52).
We can also deÔ¨Åne a semi-recursive predicate P(‚Éóxn) to be one that is posi-
tively strongly deÔ¨Ånable in ROB, i.e., for some P and all ‚Éóan,
P(‚Éóan)
iff
ROB ‚ä¢P (
a1, . . . , 
an)
We can then say that a partial recursive function is one whose graph is positively
strongly deÔ¨Ånable, while a recursive function is a total partial recursive function.
With this understanding, uncomputability coincides with undecidability (of
ROB) and hence with its incomplete(able)ness (unprovability): There are sets
that are positively strongly deÔ¨Ånable but not strongly deÔ¨Ånable (e.g., the set
K; see also Exercise I.116). Thus, our claim at the beginning of this volume, ‚Äì
that not only is there an intimate connection between uncomputability and
unprovability, but also you cannot have one without having the other ‚Äì is now
justiÔ¨Åed.
‚ñ°
I.10. Exercises
I.1. Prove that the closure obtained by I = {3} and the two relations z =
x + y and z = x ‚àíy is the set {3k : k ‚ààZ}.
I.2. The pair that effects the deÔ¨Ånition of Term (I.1.5, p. 14) is unambiguous.

192
I. Basic Logic
I.3. The pair that effects the deÔ¨Ånition of Wff (I.1.8, p. 15) is unambi-
guous.
I.4. With reference to I.2.13 (p. 25), prove that if all the gQ and h are deÔ¨Åned
everywhere on their input sets (i.e., they are total) ‚Äì these are I for h
and A √ó Y r for gQ and (r + 1)-ary Q ‚Äì then f is deÔ¨Åned everywhere on
Cl(I , R).
I.5. Let us deÔ¨Åne inductively the set of formulas Ar by:
(1) 1, 2, and 3 are in Ar.
(2) If a and b stand for formulas of Ar, then so do a + b and a √ó b.
(N.B. It is the intention here not to utilize brackets.)
(3) DeÔ¨Åne a function (intuitively speaking), Eval(x) by Eval(x) = x if x
is 1, 2, or 3, and (inductive step) Eval(a + b) = Eval(a) + Eval(b),
Eval(a √ó b) = Eval(a) √ó Eval(b) for all a, b in Ar, deÔ¨Åned via (1)
and (2).
Show that the deÔ¨Ånition (1)‚Äì(2) above allows more than one possible
parse, which makes (3) ill-deÔ¨Åned; indeed, show that for some a ‚ààAr,
Eval(a) has more than one possible value, so it is not a function after all.
I.6. Prove that for every formula A in Prop (I.3.2, p. 28) the following is
true: Every nonempty proper preÔ¨Åx (I.1.4, p. 13) of the string A has an
excess of left brackets.
I.7. Provethatanynon-primeA inProphasuniquelydeterminedimmediate
predecessors.
I.8. For any formula A and any two valuations v and v‚Ä≤, ¬Øv(A) = ¬Øv‚Ä≤(A) if
v and v‚Ä≤ agree on all the propositional variables that occur in A.
I.9. Prove that A[x ‚Üêt] is a formula (whenever it is deÔ¨Åned) if t is a term.
I.10. Prove that DeÔ¨Ånition I.3.12 does not depend on our choice of new vari-
ables ‚Éózr.
I.11. Prove that ‚ä¢(‚àÄx)(‚àÄy)A ‚Üî(‚àÄy)(‚àÄx)A.
I.12. Prove I.4.23.
I.13. Prove I.4.24.
I.14. (1) Show that x < y ‚ä¢y < x (< is some binary predicate symbol; the
choice of symbol here is meant to provoke).
(2) Show informally that Ã∏‚ä¢x < y ‚Üíy < x (Hint: Use the assumption
that our logic ‚Äúdoes not lie‚Äù (soundness theorem).)
(3) Does this invalidate the deduction theorem? Explain.
I.15. Prove I.4.25
I.16. Prove that ‚ä¢x = y ‚Üíy = x.
I.17. Prove that ‚ä¢x = y ‚àßy = z ‚Üíx = z.
I.18. Suppose that  ‚ä¢ti = si for i = 1, . . . , m, where the ti, si are arbitrary
terms. Let F be a formula, and F ‚Ä≤ be obtained from it by replacing any

I.10. Exercises
193
number of occurrences of ti in F (not necessarily all) by si. Prove that
 ‚ä¢F ‚ÜîF ‚Ä≤.
I.19. Suppose that  ‚ä¢ti = si for i = 1, . . . , m, where the ti, si are arbitrary
terms. Letr be a term, andr‚Ä≤ be obtained from it by replacing any number
of occurrences of ti in r (not necessarily all) by si.
Prove that  ‚ä¢r = r‚Ä≤.
I.20. Settle the Pause following I.4.21.
I.21. Prove I.4.27.
I.22. Suppose that x is not free in A. Prove that ‚ä¢A ‚Üí(‚àÄx)A and ‚ä¢
(‚àÉx)A ‚ÜíA.
I.23. Prove the distributive laws :
‚ä¢(‚àÄx)(A ‚àßB ) ‚Üî(‚àÄx)A ‚àß(‚àÄx)B
and
‚ä¢(‚àÉx)(A ‚à®B ) ‚Üî
(‚àÉx)A ‚à®(‚àÉx)B .
I.24. Prove ‚ä¢(‚àÉx)(‚àÄy)A ‚Üí(‚àÄy)(‚àÉx)A with two methods: Ô¨Årst using the
auxiliary constant method, next exploiting monotonicity.
I.25. Prove ‚ä¢(‚àÉx)(A ‚Üí(‚àÄx)A).
In what follows let us denote by 1 the pure logic of Section I.3 (I.3.13
and I.3.15).
Let us now introduce a new pure logic, which we will call 2. This is exactly
the same as our 1 (which we have called just  until now), except that we
have a different axiom group Ax1. Instead of adopting all tautologies, we only
adopt the following four logical axiom schemata of group Ax1 in 2:‚Ä†
(1) A ‚à®A ‚ÜíA
(2) A ‚ÜíA ‚à®B
(3) A ‚à®B ‚ÜíB ‚à®A
(4) (A ‚ÜíB ) ‚Üí(C ‚à®A ‚ÜíC ‚à®B )
2 is due to Hilbert (actually, he also included associativity in the axioms,
but, as Gentzen has proved, this was deducible from the system as here given;
therefore it was not an independent axiom ‚Äì see Exercise I.35). In the exercises
below we write ‚ä¢i for ‚ä¢i, i = 1, 2.
I.26. Show that for all F and every set of formulas , if  ‚ä¢2 F holds, then
so does  ‚ä¢1 F .
Our aim is to see that the logics 1 and 2 are equivalent, i.e., have exactly the
same theorems. In view of the trivial Exercise I.26 above, what remains to be
shown is that every tautology is a theorem of 2. One particular way to prove
this is through the following sequence of 2-facts.
‚Ä† ¬¨ and ‚à®are the primary symbols; ‚Üí, ‚àß, ‚Üîare deÔ¨Åned in the usual manner.

194
I. Basic Logic
I.27. Show the transitivity of ‚Üíin 2:
A ‚ÜíB , B ‚ÜíC ‚ä¢2 A ‚ÜíC
for all A, B , and C .
I.28. Show that ‚ä¢2 A ‚ÜíA (i.e., ‚ä¢2 ¬¨A ‚à®A), for any A.
I.29. For all A, B show that ‚ä¢2 A ‚ÜíB ‚à®A.
I.30. Show that for all A and B , A ‚ä¢2 B ‚ÜíA.
I.31. Show that for all A, ‚ä¢2 ¬¨¬¨A ‚ÜíA and ‚ä¢2 A ‚Üí¬¨¬¨A.
I.32. ForallAandB ,showthat‚ä¢2 (A ‚ÜíB ) ‚Üí(¬¨B ‚Üí¬¨A).Conclude
that A ‚ÜíB ‚ä¢2 ¬¨B ‚Üí¬¨A.
(Hint. ‚ä¢2 A ‚Üí¬¨¬¨A.)
I.33. Show that A ‚ÜíB ‚ä¢2 (B ‚ÜíC ) ‚Üí(A ‚ÜíC ) for all A, B , C .
I.34. (Proof by cases in 2.) Show for all A, B , C , D ,
A ‚ÜíB , C ‚ÜíD ‚ä¢2 A ‚à®C ‚ÜíB ‚à®D
I.35. Show for all A, B , C that
(1) ‚ä¢2 A ‚à®(B ‚à®C ) ‚Üí(A ‚à®B ) ‚à®C and
(2) ‚ä¢2 (A ‚à®B ) ‚à®C ‚ÜíA ‚à®(B ‚à®C ).
I.36. Deduction theorem in ‚Äúpropositional‚Äù 2. Prove that if , A ‚ä¢2 B
using only modus ponens, then also  ‚ä¢2 A ‚ÜíB using only modus
ponens, for any formulas A, B and set of formulas .
(Hint. Induction on the length of proof of B from  ‚à™{A}, using the
results above.)
I.37. Proof by contradiction in ‚Äúpropositional‚Äù 2. Prove that if , ¬¨A de-
rives a contradiction in 2 using only modus ponens,‚Ä† then  ‚ä¢2 A
using only modus ponens, for any formulas A and set of formulas .
Also prove the converse.
We can now prove the completeness theorem (Post‚Äôs theorem) for the ‚Äúpropo-
sitional segment‚Äù of 2, that is, the logic 3 ‚Äì so-called propositional logic (or
propositional calculus) ‚Äì obtained from 2 by keeping only the ‚Äúpropositional
axioms‚Äù (1)‚Äì(4) and modus ponens, dropping the remaining axioms and the
‚àÉ-introduction rule. (Note. It is trivial that if  ‚ä¢3 A, then  ‚ä¢2 A.) Namely,
we will prove that, for any A and , if  |=Taut A, then  ‚ä¢3 A.
First, a deÔ¨Ånition:
I.10.1 DeÔ¨Ånition (Complete Sets of Formulas). A set  is complete iff for
every A, at least one of A or ¬¨A is a member of .
‚ñ°
‚Ä† That is, it proves some B but also proves ¬¨B .

I.10. Exercises
195
I.38. Let  Ã∏‚ä¢3 A. Prove that there is a complete  ‚äá such that also
 Ã∏‚ä¢3 A. This is a completion of .
(Hint. Let F 0, F 1, F 3, . . . be an enumeration of all formulas. (There is
such an enumeration. DeÔ¨Åne n by induction on n:
0 = 
n+1 =
Ô£±
Ô£≤
Ô£≥
n ‚à™{F n}
if n ‚à™{F n} Ã∏‚ä¢3 A
otherwise
n ‚à™{¬¨F n}
if n ‚à™{¬¨F n} Ã∏‚ä¢3 A
To make sense of the above deÔ¨Ånition, show the impossibility of having
both n ‚à™{F n} ‚ä¢3 A and n

{¬¨F n} ‚ä¢3 A. Then show that  =

n‚â•0 n is as needed.)
I.39. (Post.) If  |= A, then  ‚ä¢3 A.
(Hint. Prove the contrapositive. If  Ã∏‚ä¢3 A, let  be a completion
(Exercise I.38) of  such that  Ã∏‚ä¢3 A. Now, for every prime formula
(cf. I.3.1, p. 28) P , exactly one of P or ¬¨P (why exactly one?) is in .
DeÔ¨Åne a valuation (cf. I.3.4, p. 29) v on all prime formulas by
v(P ) =
0
if P ‚àà
1
otherwise
Of course, ‚Äú0‚Äù codes, intuitively, ‚Äútrue‚Äù, while ‚Äú1‚Äù codes ‚Äúfalse‚Äù. To
conclude, prove by induction on the formulas of Prop (cf. I.3.2, p. 28)
that the extension v of v satisÔ¨Åes, for all formulas B , v(B ) = 0 iff
B ‚àà. Argue that A /‚àà.)
I.40. If  |=Taut A, then  ‚ä¢2 A.
I.41. For any formula F and set of formulas, one has  ‚ä¢1 F iff  ‚ä¢2 F .
I.42. (Compactness of propositional logic.) We say that  is Ô¨Ånitely satisÔ¨Åable
(in the propositional sense) iff every Ô¨Ånite subset of  is satisÔ¨Åable
(cf. I.3.6, p. 30). Prove that  is satisÔ¨Åable iff it is Ô¨Ånitely satisÔ¨Åable.
(Hint. Only the if part is nontrivial. It uses Exercise I.39. Further hint: If
 is unsatisÔ¨Åable, then  |=Taut A ‚àß¬¨A for some formula A.)
I.43. Prove semantically, without using soundness, that A |= (‚àÄx)A.
I.44. Give a semantic proof of the deduction theorem.
I.45. Show semantically that for all A and B , A ‚ÜíB |= (‚àÄx)A ‚Üí(‚àÄx)B .
I.46. Show semantically that for all A and B , A ‚ÜíB |= (‚àÉx)A ‚Üí(‚àÉx)B .
I.47. Prove the claim in Remark I.6.7.
I.48. Prove that the composition of two embeddings œÜ : M ‚ÜíK and œà : K ‚Üí
L is an embedding.
I.49. Find two structures that are elementarily equivalent, but not isomorphic.

196
I. Basic Logic
I.50. Let œÜ : M ‚ÜíM be an isomorphism. We say also (since we have the
same structure on both sides of ‚Äú‚Üí‚Äù) that œÜ is an automorphism. Prove
that if S ‚äÜ|M|n is Ô¨Årst order deÔ¨Ånable (cf. I.5.15) in M, then,for all ‚Éóin
in |M|,
‚ü®‚Éóin‚ü©‚ààS
iff
‚ü®œÜ(i1), . . . , œÜ(in)‚ü©‚ààS
I.51. Prove that N is not Ô¨Årst order deÔ¨Ånable in the structure R = (R, <)
(R is the set of reals).
(Hint. Use Exercise I.50 above.)
I.52. Prove that addition is not deÔ¨Ånable in (N, √ó). More precisely, show that
the set {‚ü®x, y, z‚ü©‚ààN3 : z = x + y} is not deÔ¨Ånable.
(Hint. DeÔ¨Åne a function œÜ : N ‚ÜíN by œÜ(x) = x if x is not divisible
by 2 or 3. Otherwise œÜ(x) = y, where y has the same prime number
decomposition as x, except that the primes 2 and 3 are interchanged.
For example, œÜ(6) = 6, œÜ(9) = 4, œÜ(12) = 18. Prove that œÜ is an
automorphism on (N, √ó), and then invoke Exercise I.50 above.)
I.53. Prove the only-if part of the Lo¬¥s-Tarski theorem (I.6.26).
I.54. Prove Theorem I.6.29.
I.55. Prove the if part of Theorem I.6.30.
I.56. Prove by a direct construction, without using the upward L¬®owenheim-
Skolem theorem, that there are nonstandard models for arithmetic.
(Hint. Work with the theory Th(N) ‚à™{n < C : n ‚ààN} where C is a new
constant added to the language of arithmetic LN = {0, S, +, √ó, <}.
Use compactness and the consistency theorem.)
I.57. Prove that if  has arbitrarily large Ô¨Ånite models, then it has an inÔ¨Ånite
model.
I.58. Prove by a direct construction, without using the upward L¬®owenheim-
Skolem theorem, that there is a nonstandard model for all true Ô¨Årst order
sentences about the reals.
I.59. Prove Proposition I.6.45.
I.60. Prove the pinching lemma (I.6.53).
I.61. Conclude the proof of I.6.55.
I.62. Let N, a unary predicate of the extended language L of the reals, have
as its interpretation N R = N, the set on natural numbers. Use it to prove
that there are inÔ¨Ånite natural numbers in ‚àóR.
(Hint. Use the true (in R) sentence (‚àÄx)(‚àÉy)(N(y) ‚àßx < y).)
I.63. Prove that if h is an inÔ¨Ånite natural number, then so is h ‚àí1. A side effect
of this is an inÔ¨Ånite descending chain of (inÔ¨Ånite) natural numbers in ‚àóR.
Hence there are nonempty sets of natural numbers in ‚àóR with no mini-
mum element. Does this contradict the transfer principle (p. 99)? Why?

I.10. Exercises
197
I.64. Prove the extreme value theorem: Every real function of one real variable
that is continuous on the real interval [a, b] attains its maximum. That
is, (‚àÉx ‚àà[a, b])(‚àÄy ‚àà[a, b]) f (y) ‚â§f (x).
(Hint. Subdivide [a, b] into n > 0 subintervals of equal length, [ai, ai+1],
where ai = a + (b ‚àía)i/n for i = 0, . . . , n. Formulate as a Ô¨Årst order
sentence over L the true (why true?) statement that ‚Äúfor all choices of
n > 0 (in N) there is an i ‚ààN such that f (a + (b ‚àía)i/n) is maximum
among the values f (a+(b‚àía)k/n), k = 0, . . . , n‚Äù. Transfer to ‚àóR. This
is still true. Now take n to be an inÔ¨Ånite natural number K. Let I be a (hy-
perreal) natural number that makes f (a + (b ‚àía)I/K) maximum among
the f (a+(b‚àía)i/K), 0 ‚â§i ‚â§K. See if f (st(a+(b‚àía)I/K)) is what you
want.)
I.65. Use the technique of the previous problem to prove the intermediate
value theorem: Every real function of one real variable that is continu-
ous on the real interval [a, b] attains every value between its minimum
and its maximum.
I.66. Prove the existence of inÔ¨Ånite primes in ‚àóR.
I.67. Let T be a pure theory over some language L. Form the theory T‚Ä≤ over
L ‚à™{œÑ} by adding the schemata
(‚àÄx)(A ‚ÜîB ) ‚Üí(œÑx)A = (œÑx)B
and
(‚àÉx)A[x] ‚ÜíA[(œÑx)A]
where œÑ is a new symbol used to build terms: If A is a wff, then (œÑx)A
is a term. Prove that T‚Ä≤ extends T conservatively (œÑ may be interpreted
as that of p. 123).
I.68. Prove that in the presence of the initial functions of PR (I.8.10, p. 128)
the following Grzegorczyk (1953) substitution operations can be simu-
lated by composition (I.8.6):
(a) Substitution of a function into a variable
(b) Substitution of a constant into a variable
(c) IdentiÔ¨Åcation of any two variables
(d) Permutation of any two variables
(e) Introduction of new (‚Äúdummy‚Äù) variables (i.e., forming Œª‚Éóx‚Éóy.g(‚Éóy)).
I.69. Prove that if f is total and Œª‚Éóx y.y = f (‚Éóx) is in R‚àó, then f ‚ààR. Is the
assumption that f is total necessary?
I.70. Show that both PR and R are closed under bounded summation,
 
y<z f (y, ‚Éóx) and bounded product, !
y<z f (y, ‚Éóx).

198
I. Basic Logic
I.71. Prove that if f is total and Œª‚Éóx y.y = f (‚Éóx) is in P‚àó(semi-recursive), then
f ‚ààR.
I.72. Prove I.8.27 using the if-then-else function rather than addition and
multiplication.
I.73. Prove that pn ‚â§22n for n ‚â•0.
(Hint. Course-of-values induction on n. Work with p0 p1 . . . pn + 1.)
I.74. Prove, without using the fact that Œªn.pn ‚ààPR, that œÄ ‚ààPR, where the
œÄ-function is given by œÄ(n) = (the number of primes ‚â§n).
I.75. Prove, using Exercise I.74 above, but without using the fact that Œªn.pn ‚àà
PR, that the predicate Œªyn.y = pn is in PR‚àó. Conclude, using Exer-
cise I.73, that Œªn.pn ‚ààPR.
I.76. The Ackermann function‚Ä† is given by double recursion by
A(0, x) = x + 2
A(n + 1, 0) = 2
A(n + 1, x + 1) = A(n, A(n + 1, x))
Prove that Œªnx.A(n, x) ‚ààR.
(Hint. DeÔ¨Åne
F(z, n, x) =
Ô£±
Ô£≤
Ô£≥
x + 2
if n = 0
2
if n > 0 ‚àßx = 0
{z}(n
.‚àí1, {z}(n, x
.‚àí1))
if n > 0 ‚àßx > 0
Now apply the recursion theorem.)
I.77. Prove that there exists a partial recursive h that satisÔ¨Åes
h(y, x) =
y
if x = y + 1
h(y + 1, x)
otherwise
Which function is Œªx.h(0, x)?
(Hint. Use the recursion theorem, imitating your solution to Exercise I.76
above.)
I.78. Prove that there exists a partial recursive k that satisÔ¨Åes
k(y, x) =
0
if x = y + 1
k(y, x) + 1
otherwise
Which function is Œªx.k(0, x)?
‚Ä† There are many versions, their origin part of computability folklore. The one here is not the
original one.

I.10. Exercises
199
I.79. Given Œªy‚Éóx. f (y, ‚Éóx) ‚ààP. Prove that there exists a partial recursive g that
satisÔ¨Åes
g(y, ‚Éóx) =
y
if f (y, ‚Éóx) = 0
g(y + 1, x)
otherwise
How can you express Œªx.g(0, x) in terms of f ?
I.80. Prove that K = {x : {x}(x) ‚Üì} is not a complete index set, that is, there
is no D ‚äÜP such that K = {x : {x} ‚ààD}.
(Hint. Show that there is an e ‚ààN such that {e}(e) = 0, while {e}(x) ‚Üë
if x Ã∏= e.)
I.81. Is {x : {x}(x) = 0} a complete index set? Recursive? Semi-recursive?
(Your answer should not leave any dangling ‚Äúwhy‚Äùs.)
I.82. Let f ‚ààR. Is {x : { f (x)}(x) ‚Üì} a complete index set? Why?
I.83. Consider a complete index set A = {x : {x} ‚ààD} such that there are two
functions {a} and {b}, the Ô¨Årst in D, the second not in D, and {a} ‚äÜ{b}.
Prove that there is a 1-1 recursive function f such that
x ‚ààK ‚Üîf (x) ‚ààA
Conclude that A is not semi-recursive.
(Hint. To Ô¨Ånd f use the S-m-n theorem to show that you can have
{ f (x)}(y) =
{a}(y)
if computation {a}(y) takes ‚â§steps than {x}(x)
{b}(y)
otherwise
The wordy condition above can be made rigorous by taking ‚Äústeps‚Äù to
be intuitively measured by the size of z in T (i, x, z). ‚Äú‚â§‚Äù is understood
to be fulÔ¨Ålled if both {a}(y) and {x}(x) are undeÔ¨Åned.)
I.84. An A as the above is productive.
I.85. Prove that there is an f ‚ààP such that Wx Ã∏= ‚àÖiff f (x) ‚Üì, and Wx Ã∏= ‚àÖ
iff f (x) ‚ààWx.
I.86. Selection theorem. Prove that for every n > 0, there is a function Œªa‚Éóyn.
Sel(n)(a, ‚Éóyn) such that
(‚àÉx)({a}(x, ‚Éóyn) ‚Üì) ‚ÜîSel(n)(a, ‚Éóyn) ‚Üì
and
(‚àÉx)({a}(x, ‚Éóyn) ‚Üì) ‚Üî{a}(Sel(n)(a, ‚Éóyn), ‚Éóyn) ‚Üì
(Hint. Expand on the proof idea of Exercise I.85.)
I.87. Prove that f ‚ààP iff its graph Œªy‚Éóx.y = f (‚Éóx) is in P‚àó.
(Hint. For the if part, one, but not the only, way is to apply the selection
theorem.)

200
I. Basic Logic
I.88. DeÔ¨Ånition by positive cases. Let Ri(‚Éóxn), i = 1, . . . , k, be mutually exclu-
sive relations in P‚àó, and Œª‚Éóxn. fi(‚Éóxn), i = 1, . . . , k, functions in P. Then
f deÔ¨Åned below is in P:
f (‚Éóxn) =
Ô£±
Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£≥
f1(‚Éóxn)
if R1(‚Éóxn)
...
...
fk(‚Éóxn)
if Rk(‚Éóxn)
‚Üë
otherwise
(Hint. The if-then-else function will not work here. (Why? I thought P
was closed under if-then-else.) Either use the selection theorem directly,
or use Exercise I.87.)
I.89. Prove that every r.e. relation R(‚Éóx) can be enumerated by a partial recur-
sive function.
(Hint. Modify the ‚Äúotherwise‚Äù part in the proof of I.8.51.)
I.90. Prove that there is an h ‚ààPR such thatWx = ran({h(x)}).
(Hint. Use Exercise I.89, but include x in the active arguments. Then use
the S-m-n theorem.)
I.91. Sharpen Exercise I.90 above as follows: Ensure that h is such that
Wx Ã∏= ‚àÖimplies {h(x)} ‚ààR.
(Hint. Use Exercise I.85 for the ‚Äúotherwise‚Äù.)
I.92. Prove that for some œÉ ‚ààPR, ran({x}) = dom({œÉ(x)}).
(Hint. Show that y ‚ààran({x}) is semi-recursive, and then use S-m-n.)
I.93. Prove that there is a œÑ ‚ààPR such that ran({x}) = ran({œÑ(x)}) and,
moreover, ran({x}) Ã∏= ‚àÖimplies that {œÑ(x)} ‚ààR.
I.94. Prove that a set is recursive and nonempty iff it is the range of a non-
decreasing recursive function.
(Hint. To check for a ‚ààran( f ), f non-decreasing, Ô¨Ånd the smallest i
such that a ‚â§f (i), etc.)
I.95. Prove that a set is recursive and inÔ¨Ånite iff it is the range of a strictly
increasing recursive function.
I.96. Prove that every inÔ¨Ånite semi-recursive set has an inÔ¨Ånite recursive sub-
set.
(Hint. Effectively deÔ¨Åne a strictly increasing subsequence.)
I.97. Prove that there is an m ‚ààPR such that Wx inÔ¨Ånite implies that Wm(x) ‚äÜ
Wx andWm(x) is an inÔ¨Ånite recursive set.
(Hint. Use Exercise I.91 and I.96.)
I.98. Prove that there is an h in PR such that Wx ‚à©Wy = Wh(x,y) (all x, y).
I.99. Prove that there is an k ‚ààPR such that Wx ‚à™Wy = Wk(x,y) (all x, y).
I.100. Prove that there is an g ‚ààPR such that Wx √ó Wy = Wg(x,y) (all x, y).

I.10. Exercises
201
I.101. Prove that P is not closed under min by Ô¨Ånding a function f ‚ààP such
that
Œªx.
min{y : f (x, y) = 0}
if min exists
‚Üë
otherwise
is total and 0-1-valued, but not recursive.
(Hint. Try f (x, y) that yields 0 if (y = 0 ‚àß{x}(x) ‚Üì) ‚à®y = 1 and is
undeÔ¨Åned for all other inputs.)
I.102. Prove that Œªx.{x}(x) has no (total) recursive extension.
I.103. Express the projections K and L of J(x, y) = (x + y)2 + x in closed
form ‚Äì that is, without using (¬µy)<z or bounded quantiÔ¨Åcation.
(Hint. Solve for x and y the Diophantine equation z = (x + y)2 + x.
The term ‚åä‚àöz‚åãis involved in the solution.)
I.104. Prove that the pairing function J(x, y) = (x + y)(x + y + 1)/2 + x is
onto (of course, the division by 2 is exact), and Ô¨Ånd its projections K
and L in closed form.
(Hint. For the onto part you may convince yourself that J enumerate-
spairs as follows (starting from the 0th pair, (0, 0): It enumerates by
ascending group number, where the group number of the pair (a, b) is
a + b. In each group it enumerates by ascending Ô¨Årst component; thus
(a, b) is ath in the group of number a + b.)
I.105. Find a polynomial onto pairing function via the following enumera-
tion: Enumerate by group number. Here the group number of (a, b) is
max(a, b), that is, a
.‚àíb + b. In group i the enumeration is
(0, i), (1, i), (2, i), . . . , (i ‚àí1, i), (i, i), (i, i ‚àí1), (i, i ‚àí2),
(i, i ‚àí3), . . . , (i, 1), (i, 0)
Find also the projections K and L in closed form.
By the way, what makes this J ‚Äúpolynomial‚Äù is that (like the one in Exer-
cise I.103 above) it does not involve division. It only involves +, √ó,
.‚àí,
and substitutions.
I.106. Prove that Œª‚Éóxn.‚ü®‚Éóxn‚ü©, where ‚ü®. . . ‚ü©is that deÔ¨Åned on p. 165, is in PR.
I.107. Prove that if t is a closed term of LN, then
ROB ‚ä¢t = 
tN
(Hint. Induction on terms.)
I.108. Prove, by constructing an appropriate model, that (‚àÉx)x < x is consis-
tent with ROB, and therefore ROBÃ∏‚ä¢¬¨x < x.
(Hint. For example, you can build a model on the set N ‚à™{‚àû}, where
‚Äú‚àû‚Äù is a new symbol (not in N).)

202
I. Basic Logic
I.109. Prove, by constructing an appropriate model, that (‚àÉx)(‚àÉy)x + y Ã∏=
y + x is consistent with ROB, and therefore ROB Ã∏‚ä¢x + y = y + x.
I.110. Prove that x √ó y = z is ROB-deÔ¨Ånable.
I.111. Prove I.9.45.
I.112. Complete the proof of I.9.46.
I.113. Prove that if A ‚äÜN is positively strongly formally deÔ¨Ånable in ROB ‚Äì
that is, for some A and all n, n ‚ààA iff ROB ‚ä¢A(n) ‚Äì then it is semi-
recursive. What can you say if we drop ‚Äúpositively‚Äù? Is the converse true?
I.114. Is either of the two sets in I.9.55 recursive? Why?
I.115. Prove that if  is a complete extension of ROB and {‚åúA‚åù: A ‚àà} is
recursive, then  has a decidable decision problem, i.e., {‚åúA‚åù:  ‚ä¢A}
is recursive.
I.116. G¬®odel‚Äôs Ô¨Årst incompleteness theorem ‚Äì original version. Prove that if 
is a œâ-consistent extension of ROB and {‚åúA‚åù: A ‚àà} is recursive,
then  is incomplete.
(Hint. This is a suggestion for ‚Äúproof by hindsight‚Äù, using recursion-
theoretic techniques (not G¬®odel‚Äôs original proof). So, prove, under the
statedassumptions,thateverysemi-recursive A ‚äÜNispositivelystrongly
deÔ¨Ånable (cf. Exercise I.113) in  (œâ-consistency helps one direction).
Thus, the halting set K is so deÔ¨Ånable. What does this do to Thm? Etc.)
We explore here some related formal deÔ¨Ånability concepts for functions.
We say that a total Œª‚Éóxn. f (‚Éóxn) is formally functionally deÔ¨Ånable (in some exten-
sion of ROB, ) iff for some F (y,‚Éóxn) the following holds for all b, ‚Éóan in N:
b = f (‚Éóan)
implies
 ‚ä¢F (y,
a1, . . . , 
an) ‚Üîy = b
(1)
I.117. Prove that if  is a consistent extension of ROB (for example, ROB itself
or a conservative extension), then, in the deÔ¨Ånition above, the informal
‚Äúimplies‚Äù can be strengthened to ‚Äúiff‚Äù.
I.118. Prove that a total Œª‚Éóxn. f (‚Éóxn) is formally functionally deÔ¨Ånable (in some-
extension of ROB, ) iff for some F (y,‚Éóxn) the following hold for all
b, ‚Éóan in N:
(i) The graph of f ‚Äì Œªy‚Éóxn.y = f (‚Éóxn) ‚Äì is formally deÔ¨Åned in  by F
in the sense of I.9.38, and
(ii) b = f (‚Éóan) implies  ‚ä¢F (y, 
a1, . . . , 
an) ‚Üíy = b.
I.119. Actually, the above was just a warm-up and a lemma. Prove that a total
f is formally functionally deÔ¨Ånable in ROB (or extension thereof) iff
its graph is just deÔ¨Ånable (I.9.38).
(Hint. For the hard direction, let (using a single argument for notational
convenience) F (x, y) deÔ¨Åne y = f (x) in the sense of I.9.38. Prove that

I.10. Exercises
203
G (x, y), a short name for
F (x, y) ‚àß(‚àÄz < y)¬¨F (x, z)
also deÔ¨Ånes y = f (x) and moreover satisÔ¨Åes
if
f (a) = b
then
‚ä¢G (a, y) ‚Üíy = b
To this end assume f (a) = b and prove, Ô¨Årst, that ‚ä¢G (a, y) ‚Üíy < Sb,
and second (using I.9.44) that ‚ä¢y < Sb ‚ÜíG (a, y) ‚Üíy = b.)
I.120. Let the total f of one variable be weakly deÔ¨Ånable in ROB (or extension
thereof), that is, its graph is formally deÔ¨Ånable in the sense of I.9.38. Let
A(x) be any formula. Then prove that, for some well-chosen formula
B(x),
(‚àÄa ‚ààN) ‚ä¢B(a) ‚ÜîA( +
f (a))
(Hint. By Exercise I.119, there is a F (y, x) that functionally deÔ¨Ånes f
((1) above). Take for B the obvious: (‚àÉy)(F (y, x) ‚àßA(y)).)
I.121. Let A ‚äÜNbepositivelystronglydeÔ¨ÅnableinROB,andthetotalŒªx. f (x)
be functionally deÔ¨Ånable in ROB. Prove that f ‚àí1[A], the inverse image
of A under f , is also positively strongly deÔ¨Ånable. Give two proofs: one
using the connection between ROB and recursion theoretic concepts,
the second ignorant of recursion theory.
(Hint. Use Exercise I.120.)
We have used the formula (‚àÉv0)(v0 = n ‚àßF (v0)) ‚Äì which is logically equiv-
alent to F (n) by the one point rule (I.7.2) ‚Äì on a number of occasions (e,g.,
p. 175), notably to ‚Äúeasily‚Äù obtain a G¬®odel number of (a formula equivalent to)
F (n) from a G¬®odel number of F (v0) andn. This G¬®odel number is (pretending
that ‚àßis a primitive symbol so that we do not obscure the notation)

‚åú‚àÉ‚åù, ‚åúv0‚åù, ‚ü®‚åú‚àß‚åù, ‚ü®‚åú= ‚åù, ‚åúv0‚åù, ‚åún‚åù‚ü©, ‚åúF (v0)‚åù‚ü©

The above, with n as the only variable, is recursive (indeed, primitive recursive).
So trivially, is, the function s of two (informal) variables n and x over N:
s = Œªnx

‚åú‚àÉ‚åù, ‚åúv0‚åù, ‚ü®‚åú‚àß‚åù, ‚ü®‚åú= ‚åù, ‚åúv0‚åù, ‚åún‚åù‚ü©, x‚ü©

Clearly,
s(n, ‚åúF (v0)‚åù) = ‚åú(‚àÉv0)(v0 = n ‚àßF (v0))‚åù
A Ô¨Åxed point, or Ô¨Åxpoint, of a formula A(v0) in an extension of ROB, , is a
sentence F such that
 ‚ä¢F ‚ÜîA( 
‚åúF ‚åù)

204
I. Basic Logic
I.122. Let ROB ‚â§ and A(v0) be any formula in the language of . Prove
that A has a Ô¨Åxpoint F in .
(Hint. The function s above is recursive; thus so is D = Œªx.s(x, x).
Therefore, D is functionally deÔ¨Ånable in . Now use Exercise I.120
with f = D. See if you can use a ‚Äúgood‚Äù a ‚ààN.)
I.123. Tarski‚Äôs ‚ÄúundeÔ¨Ånability of truth‚Äù again (cf. I.9.31). Prove that T =
{‚åúA‚åù: A ‚ààT (N)} is not (semantically) deÔ¨Ånable in N, basing the
argument on the existence of Ô¨Åxpoints in ROB and on the latter‚Äôs cor-
rectness.
(Hint. Suppose that some LN formula, say A(v0), deÔ¨Ånes T. Use the
previous exercise to Ô¨Ånd a sentence that says ‚ÄúI am false‚Äù.)
I.124. Let us use the term strongly ¬µ-recursive functions for the smallest set of
functions, R‚Ä≤, that includes the initial functions of PR and the functions
Œªxy.x + y, Œªxy.xy, and Œªxy.x
.‚àíy, and is closed under composition
and (¬µy) applied on total, regular functions Œª‚Éóx y.g(‚Éóx, y), that is, total
functions satisfying
(‚àÄ‚Éóx)(‚àÉy)g(‚Éóx, y) = 0
Prove that R‚Ä≤ = R.
(Hint. Use coding and decoding, e.g., via the Œ≤-function, to implement
primitive recursion.)
I.125. Prove (again) that all recursive functions are functionally deÔ¨Ånable in
ROB. Do so via Exercise I.124, by induction on R‚Ä≤, without using the
separation lemma (I.9.49).
I.126. (Craig.) Prove that a recursively enumerable set of sentences T over a
Ô¨Ånitely generated language (e.g., like that of arithmetic) admits a recur-
sive set of axioms, i.e., for some recursive , T = Thm.
(Hint. Note that for any A ‚ààT , any two sentences in the sequence
A, A ‚àßA, A ‚àßA ‚àßA, . . .
are logically equivalent. Now see if Exercises I.94 and I.95 can be of
any help.)
I.127. Let T be the pure theory over the language that contains precisely the
following nonlogical symbols: One constant, one unary function, two
binary functions, and one binary predicate. Prove that T has an undecid-
able decision problem, that is, {‚åúA‚åù: A ‚ààT} is not recursive.

II
The Second Incompleteness Theorem
Our aim in the previous section was to present G¬®odel‚Äôs Ô¨Årst incompleteness
theorem in the context of recursion theory. Much as this ‚Äúmodern‚Äù approach is
valuable for showing the links between unprovability and uncomputability, it
has obscured the simplicity of G¬®odel‚Äôs ingenious idea (as it was carried out in
his original paper (1931)).
What he had accomplished in that paper, through arithmetization of for-
mulas and proofs, was to build a sentence of arithmetic, F , that said ‚ÄúI am
not a theorem‚Äù. One can easily prove, metamathematically, that such an F is
undecidable, if arithmetic is œâ-consistent.
To see this at the intuitive level, let us replace œâ-consistency by correctness.
Then surely F is not provable, for if it is, then it is a theorem, and hence false
(contradicting correctness).
On the other hand, we have just concluded that F is true! Hence, ¬¨F is
false, and therefore not provable either (by correctness).
This simple application of the ‚Äúliar‚Äôs paradox‚Äù‚Ä† is at the heart of the Ô¨Årst
incompleteness theorem.
Imagine now that the arithmetization is actually carried out within (some)
formal arithmetic, and that with some effort we have managed to embed into
formal arithmetic the metamathematical argument that leads to the assertion ‚Äúif
arithmetic is consistent, then Ã∏‚ä¢F ‚Äù‚Ä°. The quoted statement is formalized by
‚ÄúCon ‚ÜíF ‚Äù, where ‚ÄúCon‚Äù is some (formal) sentence that says that arithmetic
is consistent. This is so, intuitively, since F ‚Äúsays‚Äù: ‚ÄúF is not a theorem‚Äù.
‚Ä† Attributed in its original form to Epimenides of Crete, who proclaimed: ‚ÄúAll Cretans are liars‚Äù. Is
this true? G¬®odel‚Äôs version is based on the variation: ‚ÄúI am lying‚Äù. Where does such a proclamation
lead?
‚Ä° Where, of course, ‚Äú ‚ä¢‚Äù is using the nonlogical axioms of our formal arithmetic.
205

206
II. The Second Incompleteness Theorem
It follows that Ã∏‚ä¢Con (why?).
This is G¬®odel‚Äôs second incompleteness theorem, that if a recursively axioma-
tized theory is a consistent extension of (Peano) arithmetic, then it cannot prove
the sentence that asserts its own consistency.
In order to prove this theorem we will need to develop enough formal arith-
metic to be able to carry out elementary arguments in it. We will also need to
complete the details of our earlier arithmetization, within formal arithmetic this
time.
II.1. Peano Arithmetic
We start by extending ROB with the addition of the induction axiom schema, to
obtain Peano arithmetic. Within this arithmetic we will perform all our formal
reasoning and constructions (arithmetization).
As a by-product of the required extra care that we will exercise in this
section, regarding arithmetization details, we will be able to see through some
technicalities that we have suppressed in I.9.33‚ÄìI.9.34 and I.9.37. For example,
we had accepted there, without explicitly stating so, that our standard rules of
inference, modus ponens and (‚àÉ)-introduction, are recursive, and therefore Ô¨Åt
the general description of the unspeciÔ¨Åed rules I1 and I2 on p. 176.
We will soon see below why this is so. Similarly, we have said that  is
recursive. At the intuitive level this is trivial, since some logical axioms are
recognized by their form (e.g., the axiom x = x), while the tautologies can be
recognized by constructing a truth table. While this ability to recognize tau-
tologies can be demonstrated rigorously, that is far too tedious an undertaking.
Instead, we opt for a more direct avenue. In the exercises (Exercises I.26‚ÄìI.41)
we led the reader to adopt a Ô¨Ånite set of axiom schemata in lieu of the inÔ¨Ånitely
many schemata whose instances are tautologies. This makes it much easier to
see that this amended  is recursive (even primitive recursive).
II.1.1 DeÔ¨Ånition (Peano Arithmetic). We extend ROB over the same lan-
guage, LN, by adding the induction axiom (in reality, an induction schema),
Ind, below:
A[x ‚Üê0] ‚àß(‚àÄx)(A ‚ÜíA[x ‚ÜêSx]) ‚ÜíA
(Ind)
We often write more simply‚Ä†
A[0] ‚àß(‚àÄx)(A[x] ‚ÜíA[Sx]) ‚ÜíA[x]
‚Ä† Cf. p. 33.

II.1. Peano Arithmetic
207
or just
A[0] ‚àß(‚àÄx)(A ‚ÜíA[Sx]) ‚ÜíA
The theory ROB + Ind is called Peano arithmetic, for short PA.
‚ñ°
II.1.2 Remark (A Note on Nonlogical Schemata and DeÔ¨Åned Symbols).
Metatheorems I.7.1 and I.7.3 ensure that the addition of deÔ¨Åned predicates,
functions, and constants to any language and theory results in a conservative
extension of the theory, that is, any theorem of the new theory over the old
(original) language is also provable in the old theory. Moreover, we saw how
any formula A of the new language can be naturally transformed to a formula
A ‚àóof the old language (eliminating deÔ¨Åned symbols), so that
A ‚ÜîA ‚àó
(1)
is provable in the extended theory.
There is one potential worry about the presence of nonlogical schemata ‚Äì
such as the induction axiom schema of PA ‚Äì that we want to address:
First off, while logical axioms are ‚Äúgood‚Äù over any Ô¨Årst order language ‚Äì they
are ‚Äúuniversal‚Äù ‚Äì nonlogical axioms and schemata on the other hand are speciÔ¨Åc
to a theory and its basic language, i.e., the language that existed prior to any
extensions by deÔ¨Ånitions. Thus, the induction schema is an ‚Äúagent‚Äù that yields a
speciÔ¨Åc nonlogical axiom (an instance of the schema) for each speciÔ¨Åc formula,
over the basic language LN, that we care to substitute into the metavariable A.
There is no a priori promise that the schema ‚Äúworks‚Äù whenever we replace
the syntactic variable A by a formula, say ‚ÄúB ‚Äù, over a language extension
obtained by deÔ¨Ånitions. By ‚Äúworks‚Äù, of course, we mean that the produced
schema instance is a theorem in the extended theory.
Well, does it ‚Äúwork‚Äù? Indeed it does; for let us look at the formula
B [x ‚Üê0] ‚àß(‚àÄx)(B ‚ÜíB [x ‚ÜêSx]) ‚ÜíB
(2)
where the particular formula B may contain deÔ¨Åned symbols. Following the
technique of symbol elimination (cf. Remark I.7.4(a), p. 120) ‚Äì eliminating at
the atomic formula level ‚Äì we obtain the following version of (2), in the basic
language of PA. This translated version has exactly the same form as (2) (i.e.,
Ind), namely
B ‚àó[x ‚Üê0] ‚àß(‚àÄx)(B ‚àó‚ÜíB ‚àó[x ‚ÜêSx]) ‚ÜíB ‚àó
Thus ‚Äì being a schema instance over the basic language ‚Äì it is an axiom of PA,
and hence also of its extension (by deÔ¨Ånitions). Now, by (1), the equivalence

208
II. The Second Incompleteness Theorem
theorem (Leibniz rule I.4.25) yields the following theorem of the extended
theory:
(B [x ‚Üê0] ‚àß(‚àÄx)(B ‚ÜíB [x ‚ÜêSx]) ‚ÜíB )
‚Üî
(B ‚àó[x ‚Üê0] ‚àß(‚àÄx)(B ‚àó‚ÜíB ‚àó[x ‚ÜêSx]) ‚ÜíB ‚àó)
Hence (2) is a theorem of the extended theory.
‚ñ°
II.1.3 Remark (The Induction ‚ÄúRule‚Äù). In practice, instead of Ind, we usually
employ the (derived) rule of inference Ind‚Ä≤ that we obtain from Ind by invok-
ing modus ponens and the duo I.4.7‚ÄìI.4.8:‚Ä†
A[x ‚Üê0], A ‚ÜíA[x ‚ÜêSx] ‚ä¢A
(Ind‚Ä≤)
The rule is normally applied as follows: We ascertain that the premises apply
by
(1) proving A[0] (this part is called the basis of the induction, just as in the
informal case over N), and
(2) adding the induction hypothesis (I.H.) A to the axioms, treating the free
variables of A as new constants‚Ä° until we can prove A[Sx].
We then have a proof of A ‚ÜíA[Sx] by the deduction theorem.
Ind‚Ä≤ now allows us to conclude that A has been proved by induction on x.
What is interesting is that Ind‚Ä≤ implies Ind; thus the two are equivalent.
What makes this interesting is that while the deduction theorem readily yields
Ind from Ind‚Ä≤, it does so under the restriction that the free variables in A[0]
and (‚àÄx)(A ‚ÜíA[Sx]) must be treated as new constants (be ‚Äúfrozen‚Äù). We
can do without the deduction theorem and without the restriction.
Let us then Ô¨Åx a formula A and prove Ind assuming Ind‚Ä≤ (see, e.g.,
ShoenÔ¨Åeld (1967)).
We let¬ß
B ‚â°A[0] ‚àß(‚àÄx)(A ‚ÜíA[Sx]) ‚ÜíA
To prove B , using Ind‚Ä≤, we need to prove
B [0]
(1)
‚Ä† Throughout this chapter, the symbol ‚ä¢implies a subscript, PA, or some extension thereof, unless
something else is clear from the context.
‚Ä° That is, disallowing universal quantiÔ¨Åcation over, or substitution in the variables. Of course,
existential quantiÔ¨Åcation is always possible by Ax2.
¬ß Here ‚Äú‚â°‚Äù means equality of strings; cf. I.1.4.

II.1. Peano Arithmetic
209
and
B ‚ÜíB [Sx]
(2)
Now, (1) is a tautology, while (2) is tautologically equivalent to
(A[0] ‚àß(‚àÄx)(A ‚ÜíA[Sx]) ‚àß¬¨A) ‚à®
¬¨A[0] ‚à®¬¨(‚àÄx)(A ‚ÜíA[Sx]) ‚à®A[Sx]
(3)
In turn, (3) ‚Äì after distributing ‚à®over ‚àß‚Äì is seen to be tautologically equivalent
to
A[0] ‚Üí(‚àÄx)(A ‚ÜíA[Sx]) ‚ÜíA ‚ÜíA[Sx]
which is provable by tautological implication and specialization (I.4.7).
‚ñ°
For the next little while we will be rediscovering arithmetic in the formal
setting of PA. In the process, new predicate and function symbols will be
introduced to the language (with their attendant axioms ‚Äì as in Section I.7).
II.1.4 DeÔ¨Ånition. We introduce the predicate ‚â§by x ‚â§y ‚Üîx < y ‚à®x = y.
‚ñ°
For the balance of the section ‚ä¢means ‚ä¢PA unless noted otherwise.
Of course, in the those instances where we add axioms (in order to argue by
the deduction theorem, or by auxiliary constant, or by cases, etc.) by a sentence
such as ‚ÄúLet A . . . ‚Äù or ‚ÄúAdd A . . . ‚Äù, ‚Äú‚ä¢‚Äù will mean provability in the aug-
mented theory PA + A.
II.1.5 Lemma. ‚ä¢0 ‚â§x.
Proof. We use induction on x.‚Ä† For convenience, we let A ‚â°0 ‚â§x.
Basis.
‚ä¢A[0], since 0 = 0 |=Taut A[0] by II.1.4.
I.H.
Add A.‚Ä°
Now, A[Sx] ‚â°0 < Sx ‚à®0 = Sx; thus, by < 2 (p. 175) and the Leibniz
rule (I.4.25, p. 51), ‚ä¢A[Sx] ‚ÜîA ‚à®0 = Sx. We are done by |=Taut and I.H. ‚ñ°
II.1.6 Lemma (Transitivity of <). ‚ä¢x < y ‚àßy < z ‚Üíx < z.
‚Ä† This, usually, means that we are using the induction rule, Ind‚Ä≤, rather than the induction schema
itself.
‚Ä° Instead of ‚Äúadd‚Äù, we often say ‚Äúlet‚Äù. Either means that we are about to invoke the deduction
theorem, and we are adding a new nonlogical axiom, with all its free variables ‚Äúfrozen‚Äù.

210
II. The Second Incompleteness Theorem
Proof. Induction on z. Let‚Ä† A[z] ‚â°x < y ‚àßy < z ‚Üíx < z.
Basis.
‚ä¢A[0] from < 1 and |=Taut.
I.H.
Add A.
Add x < y ‚àßy < Sz (to prove x < Sz). This yields (by < 2, the Leibniz
rule, and |=Taut)
x < y ‚àßy < z ‚à®x < y ‚àßy = z
(1)
We also have (the I.H.) A:
x < y ‚àßy < z ‚Üíx < z
and (Leibniz equality axiom)
x < y ‚àßy = z ‚Üíx < z
Thus, using |=Taut, x < z follows from (1). This last conclusion, by |=Taut and
< 2, yields x < Sz.
‚ñ°
II.1.7 Corollary (IrreÔ¨Çexivity of <). ‚ä¢¬¨x < x.
Proof. Induction on x.
Basis.
By < 1.
I.H.
Add ¬¨x < x.
We want to deduce ¬¨Sx < Sx. Arguing by contradiction, we add Sx < Sx,
that is, via < 2,
‚ä¢Sx < x ‚à®Sx = x
(1)
Now, ‚ä¢x < Sx by < 2, the axiom ‚ä¢x = x, and |=Taut. Thus, using (1),
‚ä¢x < Sx ‚àß(Sx < x ‚à®Sx = x)
which yields x < x by II.1.6 and the Leibniz equality axiom (Ax4 of ),
contradicting the I.H.
‚ñ°
Intuitively, ‚Äú<‚Äù is a (strict) order (irreÔ¨Çexive and transitive). Thus the induction
axiom has a net contribution to ROB (cf. Exercise I.108).
II.1.8 Lemma (Antisymmetry of ‚â§). ‚ä¢x ‚â§y ‚àßy ‚â§x ‚Üíx = y.
Proof. Assume the hypothesis
x ‚â§y ‚àßy ‚â§x
‚Ä† That is, ‚Äúz‚Äù is our favourite free variable in the formula ‚Äì see I.1.11, p. 18.

II.1. Peano Arithmetic
211
By II.1.4 this is tautologically equivalent to
¬¨(x < y ‚àßy < x) ‚Üí¬¨(x < y ‚àßx = y)
‚Üí¬¨(y < x ‚àßx = y) ‚Üíx = y
Since ‚ä¢¬¨(x < y ‚àßy < x) by transitivity and irreÔ¨Çexivity (e.g., use proof by
contradiction for this sub-claim) while each of
¬¨(x < y ‚àßx = y)
and
¬¨(y < x ‚àßx = y)
are theorems by the Leibniz axiom and irreÔ¨Çexivity, x = y follows by modus
ponens.
‚ñ°
II.1.9 Lemma. ‚ä¢x < y ‚ÜíSx < Sy.
Proof. Induction on y.
Basis.
‚ä¢x < 0 ‚ÜíSx < S0, by < 1 and |=Taut.
I.H.
Add x < y ‚ÜíSx < Sy.
Add x < Sy towards proving Sx < SSy.
Hence ‚ä¢x < y ‚à®x = y, by < 2. By I.H. and the Leibniz equality axiom,
‚ä¢Sx < Sy ‚à®Sx = Sy
Therefore ‚ä¢Sx < SSy by < 2.
‚ñ°
II.1.10 Corollary. ‚ä¢x < y ‚ÜîSx ‚â§y.
Proof. ‚Üí: ‚ä¢Sx ‚â§y ‚ÜîSx < Sy, by < 2.
‚Üê: By ‚ä¢x < Sx and transitivity.
‚ñ°
II.1.11 Proposition. Axiom < 3 is redundant in the presence of the induction
axiom.
Proof. Exercise II.1.
‚ñ°
We give notice that in what follows we will often use x > y to mean y < x.
We now state without proof some ‚Äústandard‚Äù properties of + and √ó. The
usual proof tool here will be induction. The lemma below will need a double
induction, that is, on both x and y.‚Ä†
‚Ä† Actually, if you prove associativity Ô¨Årst and also the theorem S0 + x = Sx, then you can prove
commutativity with a single induction, after you have proved 0 + x = x.

212
II. The Second Incompleteness Theorem
II.1.12 Lemma. ‚ä¢x + y = y + x.
Proof. Exercise II.3.
‚ñ°
II.1.13 Lemma. ‚ä¢x + (y + z) = (x + y) + z.
Proof. Exercise II.4.
‚ñ°
II.1.14 Lemma. ‚ä¢x √ó y = y √ó x.
Proof. Exercise II.5.
‚ñ°
II.1.15 Lemma. ‚ä¢x √ó (y √ó z) = (x √ó y) √ó z.
Proof. Exercise II.6.
‚ñ°
II.1.16 Lemma. ‚ä¢x √ó (y + z) = (x √ó y) + (x √ó z).
Proof. Exercise II.7.
‚ñ°
We adopt the usual priorities of arithmetic operations; thus, instead of
x √ó (y + z) = (x √ó y) + (x √ó z)
we will normally use the argot
x √ó (y + z) = x √ó y + x √ó z
We will adopt one more useful abbreviation (argot): From now on we will
write xy for x √ó y (implied multiplication notation). Moreover we will often
take advantage of properties such as commutativity without notice, for example,
writing x + y for y + x.
II.1.17 Lemma. ‚ä¢x < y ‚Üíx + z < y + z.
Proof. Induction on z.
Basis.
From +1.
I.H.
Add x < y ‚Üíx + z < y + z.
Let x < y. By I.H., ‚ä¢x + z < y + z. By II.1.9, ‚ä¢S(x + z) < S(y + z).
By +2, ‚ä¢x + Sz < y + Sz.
‚ñ°

II.1. Peano Arithmetic
213
II.1.18 Corollary. ‚ä¢x + z < y + z ‚Üíx < y.
Proof. Let x + z < y + z. Add ¬¨x < y, which, by < 3, tautologically im-
plies
y < x ‚à®y = x
(1)
Since ‚ä¢y < x ‚Üíy + z < x + z (II.1.17) and ‚ä¢y = x ‚Üíy + z = x + z
(Leibniz axiom), |=Taut and (1) yield
‚ä¢y + z ‚â§x + z
Along with the original assumption and transitivity, we have just contradicted
irreÔ¨Çexivity.
‚ñ°
II.1.19 Corollary. ‚ä¢z > 0 ‚ÜíSx ‚â§x + z.
Proof. We have ‚ä¢0 < z ‚Üí0 + x < z + x. Commutativity of +, and +1,
lead to the claim.
‚ñ°
II.1.20 Lemma. ‚ä¢z > 0 ‚àßx < y ‚Üíxz < yz.
Proof. Induction on z.
Basis.
By < 1.
I.H.
Add z > 0 ‚àßx < y ‚Üíxz < yz.
Let now
x < y
(1)
As ‚ä¢0 < Sz anyhow (< 2 and II.1.5), we embark on proving
xSz < ySz
By √ó2 (and the Leibniz axiom, twice) the above is provably equivalent to
x + xz < y + yz
(2)
so we will just prove (2).
By II.1.5 there are two cases for z.‚Ä†
Case z = 0.
Thus, by the Leibniz axiom and √ó1,
‚ä¢xz = 0
and
‚ä¢yz = 0
‚Ä† Cf. p. 51.

214
II. The Second Incompleteness Theorem
By (1), II.1.17, and the Leibniz axiom,‚Ä†
‚ä¢x + xz < y + yz
Case z > 0.
First off, by I.H. and II.1.17,
‚ä¢y + xz < y + yz
Also, by II.1.17,
‚ä¢x + xz < y + xz
These last two and transitivity (II.1.6) yield
‚ä¢x + xz < y + yz
‚ñ°
II.1.21 Corollary (Cancellation Laws).
‚ä¢x + z = y + z ‚Üíx = y
‚ä¢z > 0 ‚àßxz = yz ‚Üíx = y
Proof. By < 3, II.1.7, II.1.17, and II.1.20.
‚ñ°
II.1.22 Corollary.
‚ä¢x < y ‚àßz < w ‚Üíx + z < y + w
‚ä¢x < y ‚àßz < w ‚Üíxz < yw
Proof. By II.1.6, II.1.17, and II.1.20.
‚ñ°
II.1.23 Theorem (Course-of-Values Induction). For any formula A, the fol-
lowing is provable in PA:
(‚àÄx)((‚àÄz < x)A[z] ‚ÜíA) ‚Üí(‚àÄx)A
(1)
It goes without saying that z is a new variable. Such annoying (for being ob-
vious) qualiÔ¨Åcations we omit as a matter of policy.
In practice, the schema (1) is employed in conjunction with the deduction
theorem, as follows: One proves A with frozen free variables, on the I.H. that
‚Ä† This ‚Äú ‚ä¢‚Äù is effected in the extension of PA that contains the I.H. and also x < y and z = 0.

II.1. Peano Arithmetic
215
‚Äú(‚àÄz < x)A[z] is true‚Äù (i.e., with the help of the new axiom (‚àÄz < x)A[z]).
This is all one has to do, since then (‚àÄz < x)A[z] ‚ÜíA (deduction theorem)
and hence (generalization) (‚àÄx)((‚àÄz < x)A[z] ‚ÜíA).
By (1), (‚àÄx)A now follows.
Proof. To prove (1), we let the name B (or B [x], since we are interested in
x) stand for (‚àÄz < x)A[z], that is,
B ‚â°(‚àÄz)(z < x ‚ÜíA[z])
Proving (1) via the deduction theorem dictates that we next assume (1)‚Äôs
hypothesis, that is, we add the axiom
(‚àÄx)(B ‚ÜíA)[‚Éóc ]
where ‚Éóc are new distinct constants, substituted into all the free variables of
(‚àÄx)(B ‚ÜíA). The above yields
‚ä¢B [x,‚Éóc ] ‚ÜíA[x,‚Éóc ]
(2)
Our next (subsidiary) task is to establish
‚ä¢(‚àÄx)B [x,‚Éóc ]
(3)
by induction on x.
Basis.
‚ä¢B [0,‚Éóc ] by |=Taut and < 1.
I.H.
Add B [x,‚Éóc ], with frozen x, of course.‚Ä† By (2),‚Ä°
‚ä¢A[x,‚Éóc ]
(4)
Now, B [Sx,‚Éóc ] ‚â°(‚àÄz < Sx)A[z,‚Éóc ]; thus
B [Sx,‚Éóc ]
‚Üî
)
by the Leibniz rule, |=Taut and < 2 ‚Äì ‚àÄdistributes over ‚àß(Exercise I.23)
*
(‚àÄz)(z < x ‚ÜíA[z,‚Éóc ]) ‚àß(‚àÄz)(z = x ‚ÜíA[z,‚Éóc ])
‚Üî
)
I.7.2,
*
B [x,‚Éóc ] ‚àßA[x,‚Éóc ]
‚Ä† A constant. But we will not bother to name it anything like ‚Äúc‚Ä≤‚Äù.
‚Ä° x is still frozen.

216
II. The Second Incompleteness Theorem
Pause. We applied the style of ‚Äúequational proofs‚Äù or ‚Äúcalculational proofs‚Äù ‚Ä†
immediately above (chain of equivalences). The ‚Äú‚Üî‚Äù is used conjunctionally,
that is, ‚Äú‚ä¢D 1 ‚ÜîD2 ‚Üî. . . ‚ÜîDn‚Äù means ‚Äú‚ä¢(D1 ‚ÜîD2) ‚àß¬∑ ¬∑ ¬∑ ‚àß(Dn‚àí1 ‚Üî
Dn)‚Äù; hence, by tautological implication, ‚ä¢D1 ‚ÜîDn.
By (4) and the I.H. we have proved B [Sx,‚Éóc ]. Hence our induction has
concluded: We now have (3).
By(2),(3),‚àÄ-monotonicity(I.4.24),andmodusponensweinfer(‚àÄx)A[x,‚Éóc ];
hence, by the deduction theorem,
(‚àÄx)(B ‚ÜíA)[‚Éóc ] ‚Üí(‚àÄx)A[x,‚Éóc ]
Applying the theorem on constants, we get (1).
‚ñ°
We have applied quite a bit of pedantry above during the application of the
deduction theorem, invoking the theorem on constants explicitly. This made it
easier to keep track of which variables were frozen, and when.
II.1.24 Corollary (The Least Principle). The following is provable in PA for
any A:
(‚àÉx)A ‚Üí(‚àÉx)(A ‚àß(‚àÄz < x) ¬¨ A[z])
(LP)
Proof. The course-of-values induction schema applied to ¬¨A is provably
equivalent to (LP) above.
‚ñ°
We now have enough tools to formalize unbounded search, (¬µy), in PA (cf.
I.8.8, p. 127).
Suppose that we have‚Ä°
‚ä¢(‚àÉx)A
(E)
Informally this says that for all values of the free variables there is a (corre-
sponding value) x that makes A true. In view of the least principle, we must
then be able to deÔ¨Åne a ‚Äútotal function on the natural numbers‚Äù which, for each
input, returns the smallest x that ‚Äúworks‚Äù. Formally this ‚Äúfunction‚Äù will be a
function letter ‚Äì introduced into the theory (PA) by an appropriate deÔ¨Ånition
‚Ä† Cf. Dijkstra and Scholten (1990), Gries and Scheider (1994), Tourlakis (2000a, 2000b. 2001b).
‚Ä° Reminder: We continue using ‚Äú‚ä¢‚Äù for ‚Äú‚ä¢T ‚Äù, where T is PA, possibly extended by deÔ¨Ånitions.

II.1. Peano Arithmetic
217
(Section I.7) ‚Äì whose natural interpretation in N will be the total function we
have just described. The formal details are as follows:
Let B stand for
A ‚àß(‚àÄz < x) ¬¨ A[z]
(B)
By the least principle and (E) (existence condition),
‚ä¢(‚àÉx) B
(1)
Pause. By ‚àÉ-monotonicity (I.4.23), (1) implies (E), since ‚ä¢B ‚ÜíA. Thus
(1) and (E) are provably equivalent in PA, by II.1.24.
We next show that the ‚Äú‚àÉ‚Äù in (1) is really ‚Äú‚àÉ!‚Äù. To this end, we prove
B [x] ‚àßB [y] ‚Üíx = y
(2)
Add B [x] and B [y] (with frozen free variables), that is, add
A[x] ‚àß(‚àÄz < x) ¬¨ A[z]
and
A[y] ‚àß(‚àÄz < y) ¬¨ A[z]
These entail
A[x]
(3)
z < x ‚Üí¬¨A[z]
(4)
A[y]
(5)
z < y ‚Üí¬¨A[z]
(6)
We will now show that adding
x < y ‚à®y < x
(7)
will lead to a contradiction, therefore establishing (by < 3)
x = y
Having added (7) as an axiom, we now have two cases to consider:
Case x < y.
Then (6) yields ¬¨A[x] contradicting (3).
Case y < x.
Then (4) yields ¬¨A[y], contradicting (5).
We have established (2).
We can now introduce a new function symbol, f , in LA by the axiom
f‚Éóy = x ‚ÜîB
( f)
where the list ‚Éóy, x contains all the free variables of B ‚Äì and perhaps others.

218
II. The Second Incompleteness Theorem
Pause. Is ‚Äúand perhaps others‚Äù right? Should it not be ‚Äúexactly the free vari-
ables of B ‚Äù?
The ‚Äúenabling necessary condition‚Äù for ( f ) is, of course, (1) ‚Äì or, equiv-
alently, (E) ‚Äì above. We will always speak of (E) as the enabling existence
condition.
The following alternative notation to ( f ) above is due to Hilbert and Bernays
(1968) and better captures the intuitive meaning of the whole process we have
just described:
f‚Éóy = (¬µx)A
( f ‚Ä≤)
or, using the Whitehead-Russell ‚ÄúŒπ‚Äù,
(¬µx)A
def= (Œπx)B
( f ‚Ä≤‚Ä≤)
Thus, we can always introduce a new function symbol f in PA by the explicit
deÔ¨Ånition ( f ‚Ä≤) as long as we can prove (E) above.
Note that, by I.7.1 and I.7.3, such extensions of PA are conservative.
We can also say that we have introduced a ¬µ-term, (¬µx)A, if we want to
suppress the details of introducing a new function letter, etc.
Axiom ( f ) yields at once‚Ä†
‚ä¢B [ f‚Éóy]
( f (3))
therefore, by (B), < 3, and |=Taut,
‚ä¢A[ f‚Éóy]
( f (4))
and
‚ä¢A[z] ‚Üíf‚Éóy ‚â§z
( f (5))
Here ‚Äú¬µ‚Äù is the formal counterpart of the ‚Äú¬µ‚Äù (unbounded search) of non-
formalized recursion theory (I.8.8). We have restricted its application in the
formal theory so that functions deÔ¨Åned as in ( f ‚Ä≤) are total (due to (E)).
We will also need to formalize primitive recursion, that is, to show that given
any function symbols g and h of LA, of arities n + 2 and n respectively, we
can introduce a new function symbol f of arity n + 1 satisfying the (deÔ¨Åning)
axioms
f 0‚Éóyn = h‚Éóyn
f Sx‚Éóyn = gx‚Éóyn f x‚Éóyn
‚Ä† Where the machinery for ‚Äú‚ä¢‚Äù includes the deÔ¨Åning axiom ( f ).

II.1. Peano Arithmetic
219
Needless to stress that x,‚Éóyn are free variables. Note that the pair of equations
above generalizes the manner in which + and √ó were introduced as primeval
symbols in ROB and PA.
More ‚Äúuser-friendly‚Äù (argot) notation for the above recurrence equations is
f (0,‚Éóyn) = h(‚Éóyn)
f (Sx,‚Éóyn) = g(x,‚Éóyn, f (x,‚Éóyn))
To be able to handle primitive recursion we need to strengthen our grasp of
‚Äúarithmetic‚Äù in PA, by developing a few more tools.
First off, for any term t we may introduce a new function symbol f by a
‚ÄúdeÔ¨Ånition‚Äù (axiom)
f‚Éóy = t
(8)
where ‚Éóy contains all the free variables of t (but may contain additional free
variables).
(8) is our preferred short notation for introducing f . The long notation is by
quoting
‚ä¢(‚àÉx)x = t
(8‚Ä≤)
and‚Ä†
f‚Éóy = (¬µx)x = t
(8‚Ä≤‚Ä≤)
Of course, the enabling condition (8‚Ä≤) is satisÔ¨Åed, by logical axiom Ax2.
We next introduce the (formal) characteristic function of a formula, a formal
counterpart of the characteristic function of a relation (I.8.16).
Let A be any formula, and ‚Éóyn the list of its free variables. We introduce a
new n-ary function symbol œáA by the explicit deÔ¨Ånition
œáA ‚Éóyn = (¬µx)(A ‚àßx = 0 ‚à®¬¨A ‚àßx =1)
(C)
As always, we must be satisÔ¨Åed that the enabling condition
‚ä¢(‚àÉx)(A ‚àßx = 0 ‚à®¬¨A ‚àßx =1)
(C‚Ä≤)
holds. Well, since ‚ä¢A ‚à®¬¨A, we may use proof by cases.
Case A.‚Ä°
Now, ‚ä¢A ‚àß0 = 0 ‚à®¬¨A ‚àß0 =1, thus (C‚Ä≤) follows.
Case ¬¨A.
This time ‚ä¢A ‚àß1 = 0 ‚à®¬¨A ‚àß1 =1, thus (C‚Ä≤) follows once
more.
‚Ä† I shall eventually stop issuing annoyingly obvious reminders such as: ‚Äúx is not, of course, chosen
among the variables of t‚Äù.
‚Ä° Cf. p. 51.

220
II. The Second Incompleteness Theorem
II.1.25 Remark (Disclaimer). ‚Äú[T]he (formal) characteristic function of a for-
mula‚Äù (emphasis added) above are strong words indeed. Once a œáA has been
introduced as above, one may subsequently introduce a new function symbol
f by the explicit deÔ¨Ånition f‚Éóyn = œáA ‚Éóyn, and this too satisÔ¨Åes (C) and its
corollaries (9) and (10) below. For example, ‚ä¢A ‚Üîf‚Éóyn = 0.
Thus, ‚Äúthe‚Äù characteristic function symbol is in fact not unique.‚Ä† Never-
theless, we may occasionally allow the tongue to slip. The reader is hereby
forewarned.
‚ñ°
II.1.26 Remark (About ‚Äú ‚ä¢‚Äù, Again: Recursive Extensions of PA). From
now on, proofs take place in an (unspeciÔ¨Åed) extension of PA effected by a
Ô¨Ånite sequence of ¬µ-deÔ¨Ånitions or‚Ä° deÔ¨Ånitions of new predicate symbols. To
be exact, we work in a theory PA‚Ä≤ deÔ¨Åned as follows: There is a sequence of
theories Ti, for i = 0, . . . , n each over a language LAi, such that
(i) LA0 = LN, T0 = PA, Tn = PA‚Ä≤, and
(ii) for each i = 0, . . . , n ‚àí1, Ti+1 is obtained from Ti by
(a) adding a single new function symbol f to LAi, to obtain LAi+1, and
adding the axiom
f (‚Éóy) = (¬µx)A
(F)
to Ti, having shown Ô¨Årst that ‚ä¢Ti (‚àÉx)A, or
(b) adding a single new n-ary predicate symbol P to LAi, to obtain LAi+1,
and adding the axiom¬ß
P‚Éóxn ‚ÜîA(‚Éóxn)
(P)
to Ti.
We will restrict from now on the form of function and predicate deÔ¨Åni-
tions (F) and (P) above, so that in each case the formula A is in ‚àÜ0(LA)
(see I.9.27), where LA is the language to which the new symbol is being
added.
Under the above restriction on A, we call any extension PA‚Ä≤ of PA, as
described in (i)‚Äì(ii) above, a recursive extension (ShoenÔ¨Åeld (1967),
Schwichtenberg (1978)).¬∂
‚ñ°
‚Ä† Its interpretation, or ‚Äúextension‚Äù, in the standard structure is unique, of course.
‚Ä° Inclusively speaking.
¬ß Such a deÔ¨Ånition effected the introduction of ‚Äú‚â§‚Äù in II.1.4.
¬∂ Actually, those authors require A to be an open formula. For the purposes of Theorem II.4.12
later on, the two formulations make no difference.

II.1. Peano Arithmetic
221
One can now show that
‚ä¢A ‚ÜîœáA ‚Éóyn = 0
(9)
and
‚ä¢¬¨A ‚ÜîœáA ‚Éóyn =1
(10)
For (9), add A,‚Ä† and prove
œáA ‚Éóyn = 0
(11)
We have (cf. ( f (4)), p. 218)
‚ä¢A ‚àßœáA ‚Éóyn = 0 ‚à®¬¨A ‚àßœáA ‚Éóyn =1
Since
A, A ‚àßœáA ‚Éóyn = 0 ‚à®¬¨A ‚àßœáA ‚Éóyn =1 |=Taut œáA ‚Éóyn = 0
(11) follows. In short, we have the ‚Üí-direction of (9). Similarly, one obtains
the ‚Üí-direction of (10).
A by-product of all this, in view of tautological implication and ‚ä¢A ‚à®¬¨A,
is
‚ä¢œáA ‚Éóyn = 0 ‚à®œáA ‚Éóyn =1
The latter yields the ‚Üê-directions of (9) and (10) via proof by cases: Say,
we work under the case œáA ‚Éóyn = 0, with frozen ‚Éóyn. Add ¬¨A. By the ‚Üí-half
of (10),
‚ä¢œáA ‚Éóyn =1
hence, using the assumption, we obtain ‚ä¢0 =1 which contradicts axiom S1.
Thus ‚ä¢A, and hence the ‚Üê-half of (9) is proved. One handles (10) similarly.
DeÔ¨Ånition by cases. We want to legitimize deÔ¨Ånitions of new function symbols
f such as
f‚Éóxn =
Ô£±
Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£≥
t1
if A1
...
...
tk
if Ak
(12)
where
‚ä¢A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®Ak
(13)
‚ä¢¬¨(Ai ‚àßA j)
for all i Ã∏= j
(14)
‚Ä† With frozen ‚Éóyn, of course.

222
II. The Second Incompleteness Theorem
and ‚Éóxn is the list of all free variables in the right hand side of (12). Our under-
standing of the informal notation (12) is that
‚ä¢Ai ‚Üíf‚Éóxn = ti
(15)
holds for i = 1, . . . , k. We (formally) achieve this as follows:
Let œái‚Éóxn be the‚Ä† characteristic term of A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®
Ai ‚à®¬∑ ¬∑ ¬∑ ‚à®Ak, where

Ai means that Ai is missing from the disjunction. Then the deÔ¨Ånition below,
in the style of (8) (p. 219), is what we want (cf. I.8.27):
f‚Éóxn = t1œá1‚Éóxn + ¬∑ ¬∑ ¬∑ + tkœák‚Éóxn
(16)
Indeed, ‚ä¢Ai ‚Üí¬¨(A1 ‚à®¬∑ ¬∑ ¬∑ ‚à®
Ai ‚à®¬∑ ¬∑ ¬∑ ‚à®Ak), by (14) and |=Taut; hence
‚ä¢Ai ‚Üíœái‚Éóxn =1
(17)
On the other hand,‚Ä°
‚ä¢Ai ‚Üíœá j‚Éóxn = 0
for j Ã∏= i
(18)
Elementary properties¬ß of + and √ó now yield (15).
We next deÔ¨Åne the formal proper subtraction function(-symbol), Œ¥. Infor-
mally,¬∂ Œ¥(x, y) stands for x
.‚àíy. In fact, its natural interpretation ‚Äì as it is sug-
gested by the right hand side of (19) below ‚Äì in N‚Ä≤ = (N; 0; S, +, √ó; <; . . . ) is
x
.‚àíy.
We set, exactly as in informal recursion theory
Œ¥(x, y) = (¬µz)(x = y + z ‚à®x < y)
(19)
To allow (19) stand, one must show that
‚ä¢(‚àÉz)(x = y + z ‚à®x < y)
(20)
By < 3, one applies proof by cases. If x < y is the hypothesis, then, by Ax2
and modus ponens, (20) holds.
‚Ä† For the use of the deÔ¨Ånite article here ‚Äì and in similar contexts in the future ‚Äì see the dis-
claimer II.1.25, p. 220
‚Ä° Since ‚ä¢Ai ‚ÜíA1 ‚à®¬∑ ¬∑ ¬∑ ‚à®
A j ‚à®¬∑ ¬∑ ¬∑ ‚à®Ak for j Ã∏= i.
¬ß +1, √ó1 and √ó2, associativity, commutativity.
¬∂ When it comes to formal counterparts of known number-theoretic functions we will abuse the
formal notation a bit, opting for argot in the interest of readability. Here we wrote ‚ÄúŒ¥(x, y)‚Äù rather
than the nondescript ‚Äú f 2
i xy‚Äù, where f 2
i is the Ô¨Årst unused (so far) function symbol of arity 2.
See also p. 166.

II.1. Peano Arithmetic
223
For the remaining case we do induction on x to prove
‚ä¢x ‚â•y ‚Üí(‚àÉz)x = y + z
(21)
Pause. What happened to ‚Äú ‚à®x < y‚Äù?
Basis.
For x = 0, if y = 0 (cases!), then z = 0 works (via Ax2) by +1.
Otherwise (y Ã∏= 0), and we are done by < 1.
For the induction step we want
‚ä¢Sx ‚â•y ‚Üí(‚àÉz)Sx = y + z
(21‚Ä≤)
Let Sx ‚â•y. This entails two cases:
If Sx = y, then z = 0 works.
Finally, say Sx > y. By < 2, we have x ‚â•y. By I.H.,
‚ä¢(‚àÉz)x = y + z
(21‚Ä≤‚Ä≤)
Add x = y + a to the hypotheses, where a is a new constant.‚Ä† By +2, we have
‚ä¢Sx = y + Sa; hence ‚ä¢(‚àÉz)Sx = y + z, and we are done proving (20).
We have at once
II.1.27 Lemma. ‚ä¢x < y ‚ÜíŒ¥(x, y) = 0, and ‚ä¢x ‚â•y ‚Üíx = y + Œ¥(x, y).
Also,
II.1.28 Lemma. For any z, ‚ä¢zŒ¥(x, y) = Œ¥(zx, zy).
Proof. If x < y, then zx < zy, and hence ‚ä¢Œ¥(x, y) = 0 and ‚ä¢Œ¥(zx, zy) = 0.
If x ‚â•y, then zx ‚â•zy using II.1.20; hence (II.1.27)
‚ä¢x = y + Œ¥(x, y)
(i)
and
‚ä¢zx = zy + Œ¥(zx, zy)
(ii)
(i) yields
‚ä¢zx = zy + zŒ¥(x, y)
using distribution of √ó over + (II.1.16), and therefore we are done by (ii)
and II.1.21.
‚ñ°
‚Ä† Or, more colloquially, ‚Äúlet z = a work in (21‚Ä≤‚Ä≤)‚Äù. We are using proof by auxiliary constant.

224
II. The Second Incompleteness Theorem
Now that we have mastered addition, subtraction, and multiplication, we
turn our attention to division. First we formalize remainders and quotients.
We start from the trivial observation
‚ä¢(‚àÉz)(‚àÉw)x = yw + z
(1)
(1) follows from ‚ä¢x = y0 + x (+1 and √ó1).
Thus we may introduce a new function (of arity 2), the remainder function
‚Äúr‚Äù, by the following ¬µ-deÔ¨Ånition:‚Ä†
r(x, y) = (¬µz)(‚àÉw)x = yw + z
(rem)
We have at once (( f (4)), p. 218)
‚ä¢(‚àÉw)x = yw+r(x, y)
(EQ)
Therefore we can introduce quotients, q(x, y), via the deÔ¨Ånition of the 2-ary
function symbol ‚Äúq‚Äù below:
q(x, y) = (¬µw)x = yw+r(x, y)
(Q)
To improve readability we will usually denote the term q(x, y) by ‚åäx/y‚åãor
#x
y
$
(note the boldface variables x and y, which distinguish the formal case from
the informal one), and we will hardly need to refer to the symbol ‚Äúq‚Äù again.
One more application of ( f (4)) ‚Äì to (Q) ‚Äì yields
‚ä¢x = y
#x
y
$
+r(x, y)
(Euc)
The enabling condition (EQ) for (Q) yields
‚ä¢(‚àÉw)x = 0 ¬∑ w+r(x, 0)
Hence the interesting
‚ä¢x = r(x, 0)
Since ‚ä¢x = 0 ¬∑ 0 + r(x, 0), (Q) and ( f (5)) (p. 218) yield ‚åäx/0‚åã‚â§0. Hence,
by II.1.5,
‚ä¢
,x
0
-
= 0
‚Ä† We write ‚Äúr(x, y)‚Äù rather than ‚Äúrxy‚Äù in the interest of user-friendliness of notation.

II.1. Peano Arithmetic
225
Adding the usual assumption y > 0, we can guarantee the ‚Äústandard‚Äù prop-
erties of quotient and remainder, namely the inequality‚Ä† r(x, y) < y and the
uniqueness of quotient and remainder.
To see this, add y ‚â§r(x, y). Thus (II.1.27)
‚ä¢r(x, y) = y + t
(2)
where we have set t = Œ¥(r(x, y), y) for convenience. By (Euc) and √ó2 (invok-
ing associativity tacitly, as is usual)
‚ä¢x = yS
#x
y
$
+ t
Hence,
‚ä¢(‚àÉw)x = yw+ t
from which, along with (rem) and ( f (5)) (p. 218),
‚ä¢r(x, y) ‚â§t
Since also ‚ä¢r(x, y) ‚â•t by (2) and II.1.17, we get ‚ä¢r(x, y) = t (II.1.8); hence
‚ä¢y = 0 from (2) and cancellation (II.1.21). By the deduction theorem we have
derived
‚ä¢y ‚â§r(x, y) ‚Üíy = 0
or, better still (via < 3, irreÔ¨Çexivity, and II.1.5), the contrapositive
‚ä¢y > 0 ‚Üír(x, y) < y
We next turn to uniqueness. Let‚Ä° then
z < y ‚àß(‚àÉw)x = yw + z
(3)
(3) derives y > 0 by II.1.5 and II.1.6.
By ( f (5)) and (rem), ‚ä¢r(x, y) ‚â§z. Since we want ‚Äú=‚Äù here, we add
r(x, y) < z
(4)
to obtain a contradiction. Reasoning by auxiliary constant, we also add
x = yq + z
(5)
‚Ä† The ‚Äú0 ‚â§r(x, y)‚Äù part is trivial from ‚ä¢0 ‚â§x (II.1.5) and substitution.
‚Ä° Cf. p. 209 for our frequent use of the argot ‚Äúlet‚Äù.

226
II. The Second Incompleteness Theorem
for some new constant q. Let now s = Œ¥(z,r(x, y)). By (4) and II.1.27,
‚ä¢z = r(x, y) + s ‚àßs > 0
(6)
Thus (5) and (Euc) yield (via II.1.21) ‚ä¢y ‚åäx/y‚åã= yq + s; hence (deÔ¨Ånition
of Œ¥ and II.1.28)
‚ä¢yŒ¥
#x
y
$
, q

= s
We conclude that ‚ä¢y ‚â§s (why?), which, along with ‚ä¢z < y, from (3),
and ‚ä¢s ‚â§z, from (6) and II.1.17, yields (transitivity of <) the contradiction
‚ä¢y < y. Thus,
‚ä¢z < y ‚àß(‚àÉw)x = yw + z ‚Üíz = r(x, y)
It is a trivial matter (not pursued here) now to obtain
‚ä¢z < y ‚àßx = yw + z ‚Üíw =
#x
y
$
‚àßz = r(x, y)
(UN)
In (rem) (p. 224) the formula to the right of (¬µz) is provably equivalent to the
‚àÜ0-formula (‚àÉw)‚â§xx = yw+ z (why?). Thus the latter could have been used
in lieu of the original.
Therefore the addition of r and its deÔ¨Åning axiom to the theory results to a
recursive extension (such as we promised all our extensions by deÔ¨Ånitions to
be [p. 220]).
We next introduce the divisibility predicate ‚Äú|‚Äù by the axiom (D) below:
x|y ‚Üîr(y, x) = 0
(D)
Once again, the use of boldface variables will signify that we are in the formal
domain.
II.1.29 Lemma. ‚ä¢y|x ‚Üî(‚àÉz)yz = x.
Proof. By tautological implication, we have two directions to deal with:
‚Üí:
It follows by (Euc) above, +1, and Ax2.
‚Üê:
By the deduction theorem; assume (‚àÉz)yz = x towards proving y|x.
Thus ‚ä¢(‚àÉz)yz + 0 = x by +1. By (rem) and ( f (5)), we have ‚ä¢r(x, y) ‚â§0.
Done, by antisymmetry and II.1.5.
‚ñ°
We now deÔ¨Åne relative primality: We say that x and y are relatively prime iff
‚ä¢(‚àÄz)(x|yz ‚Üíx|z)
(7)

II.1. Peano Arithmetic
227
We introduce the metanotation RP(x, y) to stand for (‚àÄz)(x|yz ‚Üíx|z). Thus,
we may write (7) as ‚ä¢RP(x, y).
We emphasize that ‚ÄúRP‚Äù is not introduced as a predicate into the language,‚Ä†
rather it is introduced as a metamathematical abbreviation ‚Äì that is, we write
‚ÄúRP(x, y)‚Äù simply to avoid writing the formula in (7).
The technical reason is that we only introduce predicates if we are prepared
to give a ‚àÜ0-formula to the right of ‚Äú‚Üî‚Äù in their deÔ¨Ånition (since we want to
only consider recursive extensions‚Ä° of PA).
II.1.30 Remark. Strictly speaking, RP as (informally) deÔ¨Åned gives relative
primality correctly, as we understand it intuitively, only when both numbers are
nonzero. It has some pathologies: e.g, the counterintuitive
‚ä¢RP(0,2)
Indeed, to prove (‚àÄz)(0 |2z ‚Üí0 | z), strip it of the quantiÔ¨Åer and assume
r(2z, 0) = 0
Hence (p. 224)
‚ä¢2z = 0
Thus (‚ä¢2 > 0, ‚ä¢0z = 0, and II.1.21) ‚ä¢z = 0; hence
‚ä¢0 | z
Similarly, one can prove ‚ä¢x > 0 ‚ÜíRP(0, x).
Of course, in ‚Äúreality‚Äù (i.e., informally), 0 and 2 are not relatively prime,
since their greatest common divisor is 2.
‚ñ°
II.1.31 Exercise. Show that ‚ä¢RP(x, y) ‚Üíx > 0 ‚à®y > 0.
‚ñ°
II.1.32 Lemma. ‚ä¢(‚àÉz)(‚àÉw)Œ¥(xz, yw) =1 ‚ÜíRP(x, y).
Proof. Assume the hypothesis
(‚àÉz)(‚àÉw)Œ¥(xz, yw) =1
‚Ä† That would have been through a deÔ¨Ånition like RP(x, y) ‚Üî(‚àÄz)(x|yz ‚Üíx|z).
‚Ä° Cf. p. 220.

228
II. The Second Incompleteness Theorem
Let Œ¥(xa, yb) =1, where a and b are new constants. Add also
x|yz
(8)
towards proving x|z.
Now ‚ä¢zŒ¥(xa, yb) = z;‚Ä† hence
‚ä¢Œ¥(zxa, zyb) = z
(9)
by II.1.28. Setting c = ‚åäzy/x‚åãfor convenience,‚Ä° we get ‚ä¢xc = zy from (8).
Thus, by (9), ‚ä¢Œ¥(zxa, xcb) = z; hence (again via II.1.28)
‚ä¢xŒ¥(za, cb) = z
That is, ‚ä¢x|z, and an application of the deduction theorem followed by gener-
alization yields (‚àÄz)(x|yz ‚Üíx|z), i.e., RP(x, y).
‚ñ°
We have already remarked that we will be using associativity and commutativity
of ‚Äú+‚Äù and ‚Äú√ó‚Äù without notice.
II.1.33 Lemma. ‚ä¢x > 0 ‚ÜíRP(x, y) ‚ÜíRP(y, x).
Proof. The case y = 0 is trivial by Remark II.1.30. Thus, take now the case
y > 0.
We add the assumptions
x > 0
RP(x, y)
and
y|xz
(10)
towards proving y|z. By (10),
‚ä¢xz = ya
(11)
where a = ‚åäxz/y‚åã. Thus x|ya; hence x|a by RP(x, y).
Write then a = xq (q = ‚åäa/x‚åã), from which and (11) ‚ä¢xz = yxq. Thus,
‚ä¢z = yq, by II.1.21 and our Ô¨Årst hypothesis, which proves y|z.
‚ñ°
‚Ä† Assuming you believe that ‚ä¢x = x1.
‚Ä° Another aspect of convenience is to invoke commutativity or associativity of either + or √ó tacitly.

II.1. Peano Arithmetic
229
Thus, what we have explicitly derived under the second case above (via the
deduction theorem) was
y > 0 ‚ä¢x > 0 ‚ÜíRP(x, y) ‚Üíy|xz ‚Üíy|z
Hence we also derived (by ‚àÄ-introduction) what we really wanted,
y > 0 ‚ä¢x > 0 ‚ÜíRP(x, y) ‚Üí(‚àÄz)(y|xz ‚Üíy|z)
The moral is that even ‚Äúformal‚Äù, but ‚Äúpractical‚Äù, proofs often omit the obvious.
While we could just as easily have incorporated these couple of lines in the
proof above, we are going to practise this shortening of proofs again and again.
Hence the need for this comment.
II.1.34 Lemma. ‚ä¢k | p ‚ÜíRP(S(ip), S((i + k)p)).
Proof. The case p = 0 being trivial ‚Äì ‚ä¢RP(S0, S0) ‚Äì we argue the case p > 0.
Add k | p towards proving
RP(S(ip), S((i + k)p))
(i)
Thus,
p = ka
(ii)
where a = ‚åäp/k‚åã. By II.1.32
‚ä¢RP(S(ip), p)
(iii)
and
‚ä¢RP(S(ip), k)
(iv)
each because ‚ä¢Œ¥(S(ip), ip) =1. Add S(ip) | zS((i + k)p) towards proving
‚ä¢S(ip) | z.
By hypothesis, ‚ä¢S(ip) | zkp (Ô¨Åll in the missing steps); hence ‚ä¢S(ip) | zp
by (iv). Then ‚ä¢S(ip) | z by (iii).
‚ñ°
We now embark on introducing coding of sequences formally.‚Ä†
The formal counterpart of a sequence a0, a1, . . . , an of (variable) length = n+1
is a term t(n,‚Éóx),‚Ä° where the parenthesis notation lists all free variables of t. We
may also simply write t[n] (see p. 18).
‚Ä† This will be a ‚Äúcareful‚Äù repetition of the deÔ¨Ånition of G¬®odel‚Äôs Œ≤-function ((2) of p. 159).
‚Ä° ‚Äún‚Äù is here a variable, not a numeral. That is why we wrote ‚Äún‚Äù rather than ‚Äún‚Äù.

230
II. The Second Incompleteness Theorem
We introduce the maximum of the Ô¨Årst n + 1 members of a sequence
max
i‚â§n (t(i,‚Éóx)) = (¬µz)((‚àÄi)‚â§nz ‚â•t(i,‚Éóx ))
(M)
To legitimize (M) we need to establish
‚ä¢(‚àÉz)(‚àÄi)(i ‚â§n ‚Üíz ‚â•t(i,‚Éóx))
(M‚Ä≤)
We prove (M‚Ä≤) by induction on n.
For n = 0 (M‚Ä≤) follows immediately (do [z ‚Üêt(0,‚Éóx)] and apply Ax2).
Add now (M‚Ä≤) for frozen n and ‚Éóx, and show that
‚ä¢(‚àÉz)(‚àÄi)(i ‚â§Sn ‚Üíz ‚â•t(i,‚Éóx))
(M‚Ä≤‚Ä≤)
Let a satisfy (M‚Ä≤) (where in the latter n and ‚Éóx are still frozen).
That is, formally, add a new constant symbol a, and the new axiom
(‚àÄi)(i ‚â§n ‚Üía ‚â•t(i,‚Éóx))
(M(3))
It follows (specialization) that
‚ä¢i ‚â§n ‚Üía ‚â•t(i,‚Éóx)
(1)
Since ‚ä¢a + t(Sn,‚Éóx) ‚â•a and ‚ä¢a + t(Sn,‚Éóx) ‚â•t(Sn,‚Éóx), proof by cases, (1),
and ‚ä¢i ‚â§Sn ‚Üîi ‚â§n ‚à®i = Sn yield‚Ä†
‚ä¢i ‚â§Sn ‚Üía + t(Sn,‚Éóx) ‚â•t(i,‚Éóx)
(2)
Hence (generalization)
‚ä¢(‚àÄi)(i ‚â§Sn ‚Üía + t(Sn,‚Éóx) ‚â•t(i,‚Éóx))
and via Ax2
‚ä¢(‚àÉz)(‚àÄi)(i ‚â§Sn ‚Üíz ‚â•t(i,‚Éóx))
This is (M‚Ä≤‚Ä≤). Now the deduction theorem conÔ¨Årms the induction step.
‚ñ°
We next introduce the least common multiple of the Ô¨Årst n + 1 members of
a ‚Äúpositive sequence‚Äù:
lcm
i‚â§n(St(i,‚Éóx)) = (¬µz)(z > 0 ‚àß(‚àÄi)‚â§nSt(i,‚Éóx) | z)
(LCM)
To legitimize (LCM) we need to establish
‚ä¢(‚àÉz)(z > 0 ‚àß(‚àÄi)(i ‚â§n ‚ÜíSt(i,‚Éóx) | z))
(LCM‚Ä≤)
‚Ä† With help from the logical i = Sn ‚Üít(i,‚Éóx ) = t(Sn,‚Éóx ).

II.1. Peano Arithmetic
231
One can easily prove (LCM‚Ä≤) by induction on n. In outline, a z that works for
n = 0 is St(0,‚Éóx). If now a (auxiliary constant!) works for n (the latter frozen
along with ‚Éóx), then aSt(Sn,‚Éóx) works for Sn. The details are left to the reader.
The positive sequence above has members St(i,‚Éóx), ‚Äúindexed‚Äù by i, where t is
some term.
This representation stems from the fact that ‚ä¢t > 0 ‚Üít = SŒ¥(t,1).
Alternatively, we could have opted to ¬µ-deÔ¨Åne lcm with a condition: that
(‚àÄi ‚â§n) t (i,‚Éóx) > 0. This approach complicates the deÔ¨Åning formula as we try
to make the ¬µ-deÔ¨Åned object total (when interpreted in the standard structure).
Axiom (LCM) implies at once ( f (4) and f (5) of p. 218)
‚ä¢(z > 0 ‚àß(‚àÄi)‚â§nSt(i,‚Éóx) | z) ‚Üílcm
i‚â§n(St(i,‚Éóx)) ‚â§z
(1)
‚ä¢lcm
i‚â§n(St(i,‚Éóx)) > 0
(2)
and‚Ä†
‚ä¢(‚àÄi)‚â§n
%
St(i,‚Éóx) | lcm
i‚â§n(St(i,‚Éóx))
&
(3)
(1) can be sharpened to
‚ä¢(z > 0 ‚àß(‚àÄi)‚â§nSt(i,‚Éóx) | z) ‚Üílcm
i‚â§n(St(i,‚Éóx)) | z
(1‚Ä≤)
Indeed, assume the left hand side of ‚Äú‚Üí‚Äù in (1‚Ä≤) and also let
r > 0 ‚àßz = lcm
i‚â§n(St(i,‚Éóx))q + r
(4)
where the terms r and q are the unique (by (2)) remainder and quotient of the
division z/lcmi‚â§n(St(i,‚Éóx)) respectively. That is, we adopt the negation of the
right hand side of ‚Äú‚Üí‚Äù in (1‚Ä≤) and hope for a contradiction.
Well, by (3), (4) and our additional assumptions immediately above,
‚ä¢r > 0 ‚àß(‚àÄi)‚â§nSt(i,‚Éóx) |r
hence
‚ä¢lcm
i‚â§n(St(i,‚Éóx)) ‚â§r
by (1), contradicting the remainder inequality (by (2) the divisor in (4) is posi-
tive). This establishes that r > 0 is untenable and proves (1‚Ä≤).
We now revisit Lemma I.9.6 (actually proving a bit more).
‚Ä† The big brackets are superÔ¨Çuous but they improve readability.

232
II. The Second Incompleteness Theorem
II.1.35 Lemma. Let t and s be terms. Then
‚ä¢s > S0 ‚àß(‚àÄi)‚â§nRP(s, St[i]) ‚ÜíRP(s,lcm
i‚â§n(St[i]))
Proof. Let
s > S0 ‚àß(‚àÄi)‚â§nRP(s, St[i])
(5)
Let also (we are implicitly using II.1.33) lcmi‚â§n(St[i]) | sz. By (3) and (5)
‚ä¢(‚àÄi)‚â§nSt[i] | z
Taking cases, if z = 0 then
‚ä¢lcm
i‚â§n(St[i]) | z
(6)
anyway. If z > 0 then (6) is again obtained, this time by (1‚Ä≤).
‚ñ°
The following is the formalized Lemma I.9.6.
II.1.36 Corollary. Let t and s be terms. Then
‚ä¢s > S0 ‚àß(‚àÄi)‚â§nRP(s, St[i]) ‚Üí¬¨s | lcm
i‚â§n(St[i])
Proof. Exercise II.11.
‚ñ°
II.2. A Formal Œ≤-Function
The following steps formalize those taken starting with p. 156. Note that c,
p, and q below are just convenient (metamathematical) abbreviations of the
respective right hand sides.
Let t(n,‚Éóx) be a term, and set
c = max
i‚â§n (St[i])
(C)
We next let p be the lcm of the sequence S0, . . . , Sc (informally, 1, . . . , c+1).
Thus we set‚Ä†
p = lcm
i‚â§c (Si)
(P)
Finally, deÔ¨Åne the term q by the explicit deÔ¨Ånition‚Ä°
q = lcm
i‚â§n(S(pSt[i]))
(Q)
‚Ä† That is, p stands for s[c], where s[n] abbreviates lcmi‚â§n(Si), n being a variable.
‚Ä° Of course, a more user-friendly way to write ‚ÄúS(pSt[i])‚Äù is ‚Äú1 + p(1 + t[i])‚Äù.

II.2. A Formal Œ≤-Function
233
By (P) and (2) and (3) (p. 231) above,
‚ä¢p > 0 ‚àß(‚àÄi)‚â§cSi | p
(P‚Ä≤)
We can now derive
‚ä¢y ‚â§c ‚Üí(‚àÄi)(i ‚â§n ‚Üí¬¨ y = t[i])
‚Üí(‚àÄi)(i ‚â§n ‚ÜíRP(S(pSy), S(pSt[i])))
(6)
To see why (6) holds, add the assumptions y ‚â§c and i ‚â§n ‚Üí¬¨ y = t[i]. We
now try to prove
i ‚â§n ‚ÜíRP(S(pSy), S(pSt[i]))
So add i ‚â§n. This yields ¬¨ y = t[i], which splits into two cases by < 3,
namely, y > t[i] and y < t[i].
We will consider Ô¨Årst the case y > t[i]. Set k = Œ¥(y, t[i]) for convenience.
Now ‚ä¢0 < k ‚àßk ‚â§y hence also ‚ä¢k ‚â§c by assumption and transitivity.
Thus ‚ä¢k | p by (P‚Ä≤) and Exercise II.10.
Moreover (by II.1.27) ‚ä¢y = t[i] + k, hence (via +2) ‚ä¢Sy = St[i] + k.
Thus II.1.34 yields
‚ä¢RP(S(pSy), S(pSt[i]))
The other case, y < t[i], is handled entirely similarly with slightly different
start-up details: This time we set k = Œ¥(t[i], y).
Now ‚ä¢0 < k ‚àßk ‚â§t[i]; hence also ‚ä¢k < c.
Why? Well, ‚ä¢i ‚â§n ‚ÜíSt[i] ‚â§c by (C) and (M) (p. 230) via ( f (4))
(p. 218). Now the assumption i ‚â§n yields ‚ä¢St[i] ‚â§c, and transitivity does
the rest.
Thus ‚ä¢k | p by (P‚Ä≤), and one continues the proof as in the previous case:
By II.1.27 ‚ä¢t[i] = y + k; hence (via +2) ‚ä¢St[i] = Sy + k. Thus II.1.34
yields
‚ä¢RP(S(pSy), S(pSt[i]))
once more.
At this point we have derived (by the deduction theorem)
y ‚â§c ‚ä¢
(i ‚â§n ‚Üí¬¨ y = t[i]) ‚Üí(i ‚â§n ‚ÜíRP(S(pSy), S(pSt[i])))
(7)
Hence, by ‚àÄ-monotonicity (I.4.24),
y ‚â§c ‚ä¢
(‚àÄi ‚â§n)(¬¨ y = t[i]) ‚Üí(‚àÄi ‚â§n)RP(S(pSy), S(pSt[i]))
(7‚Ä≤)

234
II. The Second Incompleteness Theorem
(6) now follows by the deduction theorem.
We immediately derive from (6), (Q), and II.1.36 that
‚ä¢y ‚â§c ‚Üí(‚àÄi ‚â§n)(¬¨ y = t[i]) ‚Üí¬¨S(pSy) | q
(8)
Hence, by tautological implication,
‚ä¢y ‚â§c ‚ÜíS(pSy) | q ‚Üí(‚àÉi ‚â§n)y = t[i]
(8‚Ä≤)
Thus, informally speaking, q ‚Äúcodes‚Äù the unordered set of all ‚Äúobjects‚Äù
T = {S(pSt[i]) : i ‚â§n}
in the sense that if x is in T, then x | q, and, conversely, if S(pSy) | q ‚Äì where
y ‚â§c ‚Äì then S(pSy) is in T. By coding ‚Äúposition information‚Äù, i, along with
the term t[i], we can retrieve from q the ith sequence member t[i].
To this end, we deÔ¨Åne three new function symbols, J, K, L, of arities 2, 1,
and 1 respectively:
J(x, y) = (x + y)2 + x
(J)
where ‚Äú(x + y)2‚Äù is an abbreviation for ‚Äú(x + y) √ó (x + y)‚Äù,
K z = (¬µx)(x = Sz ‚à®(‚àÉy)‚â§z J(x, y) = z)
(K)
Lz = (¬µy)(y = Sz ‚à®(‚àÉx)‚â§z J(x, y) = z)
(L)
J, K, L are the formal counterparts of J, K, L of p. 156.
To legitimize (K) and (L) one needs to show
‚ä¢(‚àÉx)(x = Sz ‚à®(‚àÉy)‚â§z J(x, y) = z)
(K ‚Ä≤)
and
‚ä¢(‚àÉy)(y = Sz ‚à®(‚àÉx)‚â§z J(x, y) = z)
(L‚Ä≤)
They are both trivial, since ‚ä¢Sz = Sz.
II.2.1 Lemma. ‚ä¢J(x, y) = J(a, b) ‚Üíx = a ‚àßy = b.
Proof. A straightforward adaptation of the argument following (‚àó) on p. 156.
‚ñ°
II.2.2 Lemma. ‚ä¢K J(a, b) = a and ‚ä¢LJ(a, b) = b.
Proof. We just prove the Ô¨Årst contention, the proof of the second being entirely
analogous.

II.2. A Formal Œ≤-Function
235
First, it is a trivial matter to prove ‚ä¢x ‚â§J(x, y) and ‚ä¢y ‚â§J(x, y) (Exer-
cise II.12). Now ‚ä¢b ‚â§J(a, b) ‚àßJ(a, b) = J(a, b); hence
‚ä¢a = SJ(a, b) ‚à®(‚àÉy)(y ‚â§J(a, b) ‚àßJ(a, y) = J(a, b))
(1)
By (K), (1) above, and ( f (5)) (p. 218) we have
‚ä¢K J(a, b) ‚â§a
(2)
while (K) and ( f (4)) (p. 218) yield
‚ä¢K J(a, b) = SJ(a, b)
‚à®(‚àÉy)(y ‚â§J(a, b) ‚àßJ(K J(a, b), y) = J(a, b))
(3)
Since K J(a, b) = SJ(a, b) is untenable by (2), we get
‚ä¢(‚àÉy)(y ‚â§J(a, b) ‚àßJ(K J(a, b), y) = J(a, b))
(4)
Let c ‚â§J(a, b) ‚àßJ(K J(a, b), c) = J(a, b), where c is a new constant. By
II.2.1, ‚ä¢K J(a, b) = a.
‚ñ°
To conclude our coding, whose description we launched with the
-sign on
p. 232, let Ô¨Ånally a[n] be a term.
We code the sequence a(n,‚Éóx), for i ‚â§n, by following the above steps, letting
Ô¨Årst t of the previous discussion be an abbreviation of the speciÔ¨Åc term below:
t(i,‚Éóx)
def
= J(i, a(i,‚Éóx)),
where i and ‚Éóx are distinct variables
(T)
Thus, by (8‚Ä≤) (p. 234) and substitution, we have
‚ä¢J(i, m) ‚â§c ‚àßS(pSJ(i, m)) | q ‚Üí
(‚àÉj ‚â§n)J(i, m) = J( j, a[ j])
which (by II.2.1‚Ä†) yields
‚ä¢J(i, m) ‚â§c ‚àßS(pSJ(i, m)) | q ‚Üím = a[i] ‚àßi ‚â§n
(5)
This motivates the deÔ¨Ånition (where d is intended to receive the ‚Äúvalue‚Äù‚Ä°
J(c, q))
II.2.3 DeÔ¨Ånition (The Formal Œ≤).
Œ≤(d, i) = (¬µm)(m = d ‚à®S(pSJ(i, m)) | Ld)
(B)
‚Ä† ‚ä¢(‚àÉj)( j ‚â§n ‚àßJ(i, m) = J( j, a[ j])) ‚Üím = a[i] ‚àßi ‚â§n. To see this, assume hypothesis
and use a new constant b to eliminate (‚àÉj).
‚Ä° Of course, regardless of intentions, the letter d in the deÔ¨Ånition (B) is just a variable, like i, m.

236
II. The Second Incompleteness Theorem
The letter p in (B) is an abbreviation for the term lcm j‚â§Kd(Sj) (see (P),
p. 232).
‚ñ°
That (B) is a legitimate deÔ¨Ånition, that is,
‚ä¢(‚àÉm)(m = d ‚à®S(pSJ(i, m)) | Ld)
(B‚Ä≤)
follows from ‚ä¢x = x.
II.2.4 Proposition.
(i) ‚ä¢Œ≤(x, i) ‚â§x. Moreover,
(ii) ‚ä¢Œ≤(x, i) < x ‚Üî(‚àÉm)(S(pSJ(i, m)) | Lx), where p = lcmi‚â§K x(Si).
Proof. (i) is immediate from (B), ‚ä¢x = x and ( f (5)) (p. 218).
(ii): The ‚Üí-part is immediate from (B) and ( f (4)) (p. 218).
As for ‚Üê, assume (‚àÉm)(S(pSJ(i, m)) | Lx).
Let S(pSJ(i,r)) | Lx, where r is a new constant. Hence ‚ä¢S(pSJ(i,r))
‚â§Lx. We also have ‚ä¢Lx ‚â§Sx by (L) (p. 234) and ( f (5)) (p. 218); thus
‚ä¢pSJ(i,r) ‚â§x bytransitivityandII.1.9(contrapositive).But‚ä¢r < pSJ(i,r)
by ‚ä¢y ‚â§J(x, y) (Exercise II.12); hence ‚ä¢r < x. Since ‚ä¢Œ≤(x, i) ‚â§r by (B)
and ( f (5)) (p. 218), we are done.
‚ñ°
All this work yields the ‚Äúobvious‚Äù:
II.2.5 Theorem. For any term a(i,‚Éóx),
‚ä¢(‚àÄx1) . . . (‚àÄxm)(‚àÄn)(‚àÉz)(‚àÄi)(i ‚â§n ‚ÜíŒ≤(z, i) = a(i,‚Éóx))
(6)
where m is the length of ‚Éóx.
Proof. We prove instead
‚ä¢(‚àÉz)(‚àÄi)(i ‚â§n ‚ÜíŒ≤(z, i) = a(i,‚Éóx))
The proof constructs a ‚Äúz that works‚Äù (and then invokes Ax2). To this end,
we let t be that in (T ), and in turn, let c, p, q stand for the terms in the right
hand sides of (C), (P), and (Q) respectively (p. 232). Setting for convenience
d = J(c, q), we are reduced to proving
i ‚â§n ‚ÜíŒ≤(d, i) = a(i,‚Éóx)
(7)

II.2. A Formal Œ≤-Function
237
Thus we add the assumption i ‚â§n. We know
‚ä¢J(i, a(i,‚Éóx)) ‚â§c,
by (C), (M) on p. 230, and ( f (4)) (p. 218)
‚ä¢S(pSJ(i, a(i,‚Éóx))) | q,
by (Q) and (3) on p. 231
Or, using the abbreviation ‚Äúd‚Äù and II.2.2
‚ä¢J(i, a(i,‚Éóx)) ‚â§Kd
(8)
‚ä¢S(pSJ(i, a(i,‚Éóx))) | Ld
(9)
Thus,
‚ä¢(‚àÉm)(S(pSJ(i, m)) | Ld)
The above existential theorem and II.2.4(ii) imply
‚ä¢Œ≤(d, i) < d
(10)
so that (B) (p. 235) and ( f (4)) ‚Äì through ‚ä¢¬¨Œ≤(d, i) = d, by (10) ‚Äì yield
‚ä¢S(pSJ(i, Œ≤(d, i))) | Ld
(11)
By (9), (B), and ( f (5)) (p. 218), ‚ä¢Œ≤(d, i) ‚â§a(i,‚Éóx); hence, since J is increasing
in each argument (do you believe this?), (8) implies
‚ä¢J(i, Œ≤(d, i)) ‚â§Kd
Combining the immediately above with (11), we obtain
‚ä¢J(i, Œ≤(d, i)) ‚â§Kd ‚àßS(pSJ(i, Œ≤(d, i))) | Ld
Now (5) on p. 235 yields
‚ä¢Œ≤(d, i) = a(i,‚Éóx)
By the deduction theorem, we now have (7).
‚ñ°
II.2.6 Corollary. For any term a(i,‚Éóx),
‚ä¢(‚àÄx1) . . . (‚àÄxm)(‚àÄn)(‚àÉz)(‚àÄi)i‚â§n(Œ≤(z, i) < z ‚àßŒ≤(z, i) = a(i,‚Éóx))
where m is the length of ‚Éóx.
Proof. By (10) of the previous proof.
‚ñ°

238
II. The Second Incompleteness Theorem
II.2.7 Example (Some Pathologies). (1) By II.2.4 (i) we get ‚ä¢Œ≤(0, i) = 0
(using II.1.5 and II.1.8). Thus, if we introduce an 1-ary function letter f by the
explicit deÔ¨Ånition f n = 0, then ‚ä¢i ‚â§n ‚ÜíŒ≤(0, i) = fi. It follows, accord-
ing to (6) of II.2.5, that 0 ‚Äúcodes‚Äù the sequence of the Ô¨Årst n members of the
term fi ‚Äì for any n ‚Äúvalue‚Äù.
(2) Next, ‚Äúcompute‚Äù Œ≤(3, i). Now, ‚ä¢K3 =4 and ‚ä¢L3 =4 (why?). Since
‚ä¢p = 
60 (why?), we get
‚ä¢¬¨S(pSJ(i, m)) | L3
since ‚ä¢S(pSJ(i, m)) ‚â•
61 (why?). By II.2.4(ii), ‚ä¢Œ≤(3, i) =3.‚Ä†
Thus,ifwehaveafunctionsymbol g withadeÔ¨Ånition gn =3,thenapossible
proof of
‚ä¢(‚àÉz)(‚àÄi)(i ‚â§w ‚ÜíŒ≤(z, i) = gi)
starts with ‚Äútake z to be3‚Äù. An alternative ‚Äúvalue‚Äù for z is the ‚Äúd‚Äù constructed
in the proof of II.2.5, adapted to the term gn. We may call the latter z-‚Äúvalue‚Äù
the ‚Äúintended one‚Äù or the ‚Äúnatural one‚Äù.
Clearly, ‚Äúintended‚Äù or not, any z that works in (6) of II.2.5 is an in principle
acceptable coding of the Ô¨Årst ‚Äún members‚Äù of a term a.
(3) Finally, let us compute Œ≤(2, i). Now, ‚ä¢K2 =1 and ‚ä¢L2 = 0. Also
‚ä¢p =2. It follows that
‚ä¢Œ≤(2, i) = 0
since
‚ä¢S(pSJ(i, 0)) | 0
Thus, if f is introduced as in part (1) of this example by f n = 0, then
‚ä¢(‚àÉz)(‚àÄi)(i ‚â§w ‚ÜíŒ≤(z, i) = fi)
can be proved by letting z be 2, or 0, or by invoking the construction carried
out in the proof of II.2.5.‚Ä° In particular, Œ≤ is not 1-1 in its Ô¨Årst argument.
Part (3) of this example shows that an x that passes the test ‚ÄúŒ≤(x, i) < x‚Äù
is not necessarily the d computed in the standard manner as in the proof of
II.2.5 ‚Äì i.e., we cannot expect ‚ä¢x = d. After all, ‚ä¢Œ≤(2, i) <2.
‚ñ°
‚Ä† This is related to the example Œ≤(4, i) =4 of II.2.14.
‚Ä° If the latter construction is followed, then ‚ä¢Lz > 0, of course.

II.2. A Formal Œ≤-Function
239
We are all set to introduce the formal counterparts of ‚ü®. . . ‚ü©, Seq,lh, ‚àó, (z)i
of p. 165.
II.2.8 DeÔ¨Ånition (Bold ‚ü®. . . ‚ü©). For any term t and any variable w not free in
t, we denote by ‚ü®t[i] : i < w‚ü©(or, sloppily, ‚ü®t[0], . . . , t[w ‚àí1]‚ü©) the ¬µ-term
(¬µz)(Œ≤(z, 0) = w ‚àß(‚àÄi)<w(Œ≤(z, Si) = St[i]))
(FC)
‚ñ°
II.2.9 Proposition. The ¬µ-term in (FC) can be formally introduced.
Proof. We want
‚ä¢(‚àÉz)(Œ≤(z, 0) = w ‚àß(‚àÄi)<w(Œ≤(z, Si) = St[i]))
(FC‚Ä≤)
Let a[w, n] abbreviate the term deÔ¨Åned by cases below (see p. 221):
a[w, n] =
w
if n = 0
St[Œ¥(n, S0)]
if n > 0
(‚àó)
(‚àó) yields ((15) on p. 221)
‚ä¢n = 0 ‚Üía[w, n] = w
and hence (Ax4)
‚ä¢a[w, 0] = w
(1)
but also
‚ä¢n > 0 ‚Üía[w, n] = St[Œ¥(n, S0)]
Hence (by ‚ä¢Sn > 0 and modus ponens)
‚ä¢a[w, Sn] = St[Œ¥(Sn, S0)]
or, using ‚ä¢Œ¥(Sn, S0) = n (do you believe this?)
‚ä¢a[w, Sn] = St[n]
(2)
Now, by Theorem II.2.5,
‚ä¢(‚àÉz)(‚àÄi)(i ‚â§w ‚ÜíŒ≤(z, i) = a[w, i])

240
II. The Second Incompleteness Theorem
In view of the above existential statement, we introduce a new constant c and
the assumption
(‚àÄi)(i ‚â§w ‚ÜíŒ≤(c, i) = a[w, i])
By specialization we obtain from the above
‚ä¢0 ‚â§w ‚ÜíŒ≤(c, 0) = a[w, 0]
that is,
‚ä¢Œ≤(c, 0) = a[w, 0]
(3)
by II.1.5, and
‚ä¢Si ‚â§w ‚ÜíŒ≤(c, Si) = a[w, Si]
that is,
‚ä¢i < w ‚ÜíŒ≤(c, Si) = a[w, Si]
(4)
in view of II.1.10. Putting the generalization of (4) together (conjunction)
with (3), via (1) and (2), yields
‚ä¢Œ≤(c, 0) = w ‚àß(‚àÄi)<w(Œ≤(c, Si) = St[i])
from which Ax2 yields (FC‚Ä≤).
‚ñ°
II.2.10 DeÔ¨Ånition. We introduce the functions ‚Äúlh‚Äù and ‚Äú( . . . )...‚Äù by
lh(z) = Œ≤(z, 0)
(z)i
= Œ¥(Œ≤(z, Si), S0)
(‚àó‚àó)
‚ñ°
In the second deÔ¨Ånition in the group (‚àó‚àó) above we have introduced a new
2-ary function symbol called, let us say, f , by f zi = Œ¥(Œ≤(z, Si), S0) ‚Äì in
informal lightface notation, Œ≤(z, i + 1)
.‚àí1 ‚Äì and then agreed to denote the
term ‚Äú f zi‚Äù by (z)i.‚Ä†
II.2.11 Proposition. If we let b = ‚ü®t[i] : i < x‚ü©, then we can obtain
(1) ‚ä¢lh(b) = x,
(2) ‚ä¢(‚àÄi)<x(b)i = t[i], or, equivalently, ‚ä¢(‚àÄi)<lh(b)(b)i = t[i], and
(3) ‚ä¢z < b ‚Üí(¬¨lh(z) = x ‚à®(‚àÉi)<x¬¨(z)i = t[i]).
‚Ä† Note how this closely parallels the ‚Äú(z)i‚Äù of the prime-power coding. We had set there (p. 137)
(z)i = exp(i, z)
.‚àí1.

II.2. A Formal Œ≤-Function
241
Proof. (1): By ( f (4)) and (FC) (p. 239),
‚ä¢Œ≤(b, 0) = x
We conclude using II.2.10.
(2): By ( f (4)) and (FC),
‚ä¢i < x ‚ÜíŒ≤(b, Si) = St[i]
We conclude using ‚ä¢Œ¥(St[i], S0) = t[i] and II.2.10.
(3): To prove the last contention we invoke ( f (3)), p. 218, in connection
with (FC). It yields
‚ä¢(‚àÄz)<b¬¨(Œ≤(z, 0) = x ‚àß(‚àÄi)(i < x ‚ÜíŒ≤(z, Si) = St[i]))
Hence, using II.2.10, the Leibniz rule, and specialization,
‚ä¢z < b ‚Üí(¬¨lh(z) = x ‚à®(‚àÉi)<x¬¨(z)i = t[i])
‚ñ°
Item (3) above suggests how to test a number for being a sequence code or
not. We deÔ¨Åne (exactly as on p. 165, but in boldface)
II.2.12 DeÔ¨Ånition. We introduce the unary predicate Seq by
Seq(z) ‚Üî(‚àÄi)<lh(z) Œ≤ (z, Si) > 0 ‚àß
(‚àÄx)<z(lh(x) Ã∏= lh(z) ‚à®(‚àÉi)<lh(z)(z)i Ã∏= (x)i)
‚ñ°
The Ô¨Årst conjunct above tests that we did not forget to add 1 to the sequence
members before coding. The second conjunct says that our code z is minimum,
because, for any smaller ‚Äúnumber‚Äù x, whatever sequence the latter may code
(‚Äúminimally‚Äù or not) cannot be the same sequence as the one that z (minimally)
codes.
II.2.13 Proposition. ‚ä¢Seq(z) ‚Üí(‚àÄi)<lh(z)z > (z)i.
Proof. Assume the hypothesis. Specialization and II.2.12 yield
‚ä¢i < lh(z) ‚ÜíŒ≤(z, Si) > 0
(1)
By II.1.10, ‚ä¢Œ≤(z, Si) > 0 ‚ÜíŒ≤(z, Si) ‚â•S0; thus, by II.1.27 and II.2.10, (1)
yields
‚ä¢i < lh(z) ‚ÜíŒ≤(z, Si) = (z)i + S0

242
II. The Second Incompleteness Theorem
By +2 and +1 we now get
‚ä¢i < lh(z) ‚ÜíŒ≤(z, Si) = S((z)i)
which, by II.2.4(i), rests our case.
‚ñ°
II.2.14 Remark. The inequality
(z)i < z
(i)
is very important when it comes to doing induction on sequence codes and
(soon) on G¬®odel numbers.
By Example II.2.7 we see that unless we do something about it, we are not
justiÔ¨Åed in expecting ‚ä¢Œ≤(z, i) < z, in general. What we did to ensure that in-
duction on codes is possible was to add 1 to each sequence member t[i], a
simple trick that was already employed in the prime-power coding (p. 136),
although for different reasons there.‚Ä† This device ensures (i) by II.2.13.
Another way to ensure (i) is to invoke Corollary II.2.6 and modify (FC) to
read instead
(¬µz)(Œ≤(z, 0) = w ‚àßw < z ‚àß(‚àÄi)<w(Œ≤(z, Si) < z ‚àßŒ≤(z, Si) = t[i]))
Note that we did not need to ‚Äúadd 1‚Äù to t above.
We prefer our Ô¨Årst solution (DeÔ¨Ånition II.2.8), if nothing else, because it al-
lows 0 to code the ‚Äúempty sequence‚Äù (see II.2.15 below), a fact that is intuitively
pleasing.
This is a good place to mention that while our ‚ÄúŒ≤‚Äù (in either the bold or
the lightface version) is, essentially, that in ShoenÔ¨Åeld (1967), we had to tweak
the latter somewhat (especially the derived ‚Äú‚ü®. . . ‚ü©‚Äù) to get it to be induction-
friendly (in particular, to have (i) above).
The version in ShoenÔ¨Åeld (1967, (5), p. 116) is
Œ≤(a, i) = (¬µx)(x = a ‚à®
(‚àÉy)<a(‚àÉz)<a(a = J‚Ä≤(y, z) ‚àßS(zSJ‚Ä≤(x, i)) | y))
(Sh)
where‚Ä°
J‚Ä≤(y, z) = (y + z)2 + y +1
Since, intuitively speaking, 4 is not in the range of J‚Ä≤, i.e., formally,
‚ä¢¬¨(‚àÉy)(‚àÉz)J‚Ä≤(y, z) = 4
‚Ä† Namely, to enable us to implicitly store in the code the length of the coded sequence.
‚Ä° The two ‚ÄúJ‚Äùs, the one employed here and ShoenÔ¨Åeld‚Äôs J‚Ä≤, trivially satisfy ‚ä¢J‚Ä≤(y, z) = SJ(y, z).

II.2. A Formal Œ≤-Function
243
we have
‚ä¢Œ≤(4, i) =4
because the search (‚àÉy)<a(‚àÉz)<a( . . . ) in the deÔ¨Åning axiom (Sh) fails. This in-
validates (7), p. 116 of ShoenÔ¨Åeld (1967),‚Ä† on which (i) hinges in that book.‚Ä° ‚ñ°
II.2.15 Example. Since ‚ä¢0 = Œ≤(0, 0) by II.2.7, we have ‚ä¢lh(0) = 0, but
also, by < 1, that 0 is a minimum code of a sequence. Indeed, ‚ä¢Seq(0) by < 1.
Since the sequence in question has 0 length, it is called the empty sequence.
We often write the minimum code, (FC), of the empty sequence as ‚Äú‚ü®‚ü©‚Äù, that is,
‚ä¢‚ü®‚ü©= 0
‚ñ°
To conclude with the introduction of our formal coding tools we will also
need a formal concatenation function.
II.2.16 DeÔ¨Ånition (Concatenation). ‚Äú‚àó‚Äù ‚Äì a 2-ary function symbol ‚Äì is intro-
duced via the ¬µ-term below (denoted by ‚Äúx ‚àóy‚Äù):
x ‚àóy = (¬µz)(Œ≤(z, 0) = lh(x) + lh(y) ‚àß
(‚àÄi)<lh(x)Œ≤(z, Si) = S((x)i) ‚àß
(‚àó‚àó‚àó)
(‚àÄi)<lh(y)Œ≤(z, Si + lh(x)) = S((y)i))
‚ñ°
The legitimacy of (‚àó‚àó‚àó) relies on
II.2.17 Proposition.
‚ä¢(‚àÉw)(Œ≤(w, 0) = lh(x) + lh(y) ‚àß
(‚àÄi)<lh(x)Œ≤(w, Si) = S((x)i) ‚àß
(1)
(‚àÄi)<lh(y)Œ≤(w, Si + lh(x)) = S((y)i))
Since the x and y are free variables, (1) says, informally, that for all ‚Äúvalues‚Äù of
x and y a wthat ‚Äúworks‚Äù exists. That is, the natural interpretation of ‚àóover N is
total. In other words, just like the ‚Äú‚àó‚Äù that we saw earlier on, which was based
on prime power coding (see I.8.30, p. 136), this new ‚Äú‚àó‚Äù makes sense regardless
of whether or not its arguments are minimum codes according to (FC).
‚Ä† That ‚ä¢¬¨a = 0 ‚ÜíŒ≤(a, i) < a.
‚Ä° (8) in loc. cit., p. 117 [deduced from (7) in loc. cit.]: ‚ä¢a Ã∏= 0 ‚Üílh(a) < a ‚àß(a)i < a.

244
II. The Second Incompleteness Theorem
Proof. To see why (1) holds, we introduce the 3-ary function symbol a by
a(n, x, y) =
Ô£±
Ô£≤
Ô£≥
lh(x) + lh(y)
if n = 0
S((x)Œ¥(n,S0))
if 0 < n ‚àßn ‚â§lh(x)
S((y)Œ¥(n,S(lh(x))))
if lh(x) < n
(A)
By II.2.5,
‚ä¢(‚àÉw)(‚àÄi)(i ‚â§lh(x) + lh(y) ‚ÜíŒ≤(w, i) = a(i, x, y))
Let us add a new constant, z, and the assumption
(‚àÄi)(i ‚â§lh(x) + lh(y) ‚ÜíŒ≤(z, i) = a(i, x, y))
(2)
We now show that we can prove (1) from (2).
It may be that it is not the case that ‚ä¢Seq(z). This is just Ô¨Åne, as the proof
needs no such assumption.
We verify each conjunct of (1) separately:
r Since (A) yields (p. 221) ‚ä¢n = 0 ‚Üía(n, x, y) = lh(x) + lh(y) and hence
‚ä¢a(0, x, y) = lh(x) + lh(y)
(2), specialization, and II.1.5 yield
‚ä¢Œ≤(z, 0) = lh(x) + lh(y)
(3)
r Next we prove
‚ä¢i < lh(x) ‚ÜíŒ≤(z, Si) = S((x)i)
(4)
By II.1.10 this amounts to proving
‚ä¢Si ‚â§lh(x) ‚ÜíŒ≤(z, Si) = S((x)i)
(4‚Ä≤)
Now, since ‚ä¢lh(x) ‚â§lh(x) + lh(y), (2) yields
‚ä¢Si ‚â§lh(x) ‚ÜíŒ≤(z, Si) = a(Si, x, y)
Moreover, (A) and ‚ä¢0 < Si yield (p. 221)
‚ä¢Si ‚â§lh(x) ‚Üía(Si, x, y) = S((x)Œ¥(Si,S0))
and since ‚ä¢Œ¥(Si, S0) = i, we get (4‚Ä≤) above.
r Finally, we want to verify
‚ä¢i < lh(y) ‚ÜíŒ≤(z, Si + lh(x)) = S((y)i)
(5)

II.2. A Formal Œ≤-Function
245
which amounts to
‚ä¢Si ‚â§lh(y) ‚ÜíŒ≤(z, Si + lh(x)) = S((y)i)
(5‚Ä≤)
using II.1.10. Add Si ‚â§lh(y). Hence ‚ä¢Si + lh(x) ‚â§lh(x) +lh(y) by
II.1.17. Thus, by (2),
‚ä¢Œ≤(z, Si + lh(x)) = a(Si + lh(x), x, y)
(6)
By (A),
‚ä¢lh(x) < Si + lh(x)
‚Üía(Si + lh(x), x, y) = S((y)Œ¥(Si+lh(x),S(lh(x))))
(7)
Hence, noting that
‚ä¢lh(x) < Si + lh(x)
(by II.1.17)
‚ä¢Si + lh(x) = i + S(lh(x))
and
‚ä¢Œ¥(i + S(lh(x)), S(lh(x))) = i
(by II.1.27)
(6) and (7) yield
‚ä¢Œ≤(z, Si + lh(x)) = S((y)i)
which by the deduction theorem yields (5‚Ä≤) and hence (5).
Putting now the conjuncts (3)‚Äì(5) together and applying Ax2 yields (1).
‚ñ°
II.2.18 Example. We verify that for any terms t and s
‚ä¢‚ü®t[i] : i < n‚ü©‚àó‚ü®s[i] : i < m‚ü©= ‚ü®a[i] : i < n + m‚ü©
where
a[i] =
Ô£±
Ô£≤
Ô£≥
t[i]
if i < n
s[Œ¥(i, n)]
if n ‚â§i ‚àßi < n + m
0
otherwise
Setting x = ‚ü®t[i] : i < n‚ü©and y = ‚ü®s[i] : i < m‚ü©for convenience, we get
from II.2.11
‚ä¢lh(x) = n
‚ä¢lh(y) = m
‚ä¢i < n ‚Üí(x)i = t[i]

246
II. The Second Incompleteness Theorem
and
‚ä¢i < m ‚Üí(y)i = s[i]
Pause. (Important.) None of the above four facts need the assertion that x and
y are minimum ‚Äú‚ü®. . . ‚ü©-codes‚Äù. We have invoked above only the part of II.2.11
that does not rely on minimality. Only the last claim in II.2.11 does.
Thus, by II.2.16,
‚ä¢x ‚àóy = (¬µz)(lh(z) = n + m ‚àß
(‚àÄi)<nŒ≤(z, Si) = St[i] ‚àß
(8)
(‚àÄi)<mŒ≤(z, Si + n) = Ss[i])
On the other hand,
‚ä¢‚ü®a[i] : i < n + m‚ü©= (¬µw)(lh(w) = n + m ‚àß
(‚àÄi)<nŒ≤(w, Si) = St[i] ‚àß
(9)
(‚àÄi)<mŒ≤(w, Si + n) = Ss[i])
by the way a was deÔ¨Åned (noting that ‚ä¢n ‚â§i + n and ‚ä¢Œ¥(i + n, n) = i).
By (8) and (9), we are done.
Pause. Parting comment: From our earlier Pause, we see that even in the case
when x and y are not the minimum ‚ü®. . . ‚ü©-codes for the sequences t[i] : i < n
and s[i] : i < m respectively, but nevertheless happen to satisfy the following,
‚ä¢lh(x) = n
‚ä¢lh(y) = m
‚ä¢i < n ‚Üí(x)i = t[i]
and
‚ä¢i < m ‚Üí(y)i = s[i]
Then the work immediately above still establishes
‚ä¢x ‚àóy = ‚ü®a[i] : i < n + m‚ü©
‚ñ°
II.2.19 Proposition. If we let b abbreviate ‚ü®t[i] : i < x‚ü©, then we have
‚ä¢Seq(b)
Proof. Immediate from II.2.8, II.2.11, and II.2.12.
‚ñ°
II.2.20 Exercise. ‚ä¢Seq(x ‚àóy).
‚ñ°

II.2. A Formal Œ≤-Function
247
II.2.21 Example. We introduce the abbreviation t below:
t = (¬µz)(Seq(z)‚àß
lh(z) = lh(x) + lh(y)‚àß
(‚àÄi)<lh(x)(z)i = (x)i ‚àß
(‚àÄi)<lh(y)(z)i+lh(x) = (y)i)
(1)
and prove
‚ä¢t = x ‚àóy
By the deÔ¨Ånition of ‚Äú‚àó‚Äù (II.2.16) and ( f (4)) (p. 218) ‚Äì using
‚ä¢x = Sy ‚ÜíŒ¥(x, S0) = y
(by II.1.27) and II.2.10 to remove instances of Œ≤ ‚Äì we obtain
‚ä¢lh(x ‚àóy) = lh(x) +lh(y)‚àß
(‚àÄi)<lh(x)(x ‚àóy)i = (x)i ‚àß
(‚àÄi)<lh(y)(x ‚àóy)i+lh(x) = (y)i
(2)
Since also ‚ä¢Seq(x ‚àóy), by II.2.20 we get
‚ä¢t ‚â§x ‚àóy
(3)
by (2), (1), and ( f (5)) (p. 218).
To get the converse inequality, we use (1) and ( f (4)) to get
‚ä¢Seq(t)‚àß
lh(t) = lh(x) + lh(y)‚àß
(‚àÄi)<lh(x)(t)i = (x)i ‚àß
(‚àÄi)<lh(y)(t)i+lh(x) = (y)i
(4)
The Ô¨Årst conjunct of (4) and II.2.12 (via II.1.27) yield,‚Ä† from the remaining
conjuncts of (4),
‚ä¢Œ≤(t, 0) = lh(x) + lh(y)‚àß
(‚àÄi)<lh(x)Œ≤(t, Si) = S((x)i)‚àß
(‚àÄi)<lh(y)Œ≤(t, Si + lh(x)) = S((y)i)
By the deÔ¨Ånition of ‚Äú‚àó‚Äù (II.2.16) and ( f (5)),
‚ä¢x ‚àóy ‚â§t
which along with (3) and II.1.8 rests the case.
‚ñ°
‚Ä† More expansively, ‚ä¢(‚àÄi)<lh(t)Œ≤(t, Si) ‚â•S(0) by II.2.12, which implies (by II.1.27 and II.2.10)
‚ä¢(‚àÄi)<lh(t)Œ≤(t, Si) = (t)i + S0, but ‚ä¢z + S0 = Sz.

248
II. The Second Incompleteness Theorem
II.2.22 Example. By II.2.18,
‚ä¢0 ‚àó‚ü®t[i] : i < x‚ü©= ‚ü®t[i] : i < x‚ü©
and
‚ä¢‚ü®t[i] : i < x‚ü©‚àó0 = ‚ü®t[i] : i < x‚ü©
In particular, ‚ä¢0 ‚àó‚ü®‚ü©= ‚ü®‚ü©(cf. II.2.15), i.e., ‚ä¢0 ‚àó0 = 0. Note however that
if a is the term that denotes the natural coding of the empty sequence, that is,
‚ä¢Œ≤(a, 0) = 0 and ‚ä¢0 < a (note that ‚ä¢¬¨Seq(a)), then
‚ä¢0 ‚àóa = 0
since ‚ä¢Seq(0 ‚àóa), and therefore
‚ä¢¬¨0 ‚àóa = a
‚ñ°
Thus we have two ways to ‚ÄúŒ≤-code‚Äù sequences t[i], for i < x. One is to pick
any c that satisÔ¨Åes ‚ä¢Œ≤(c, 0) = x and ‚ä¢(‚àÄi)<xŒ≤(c, i) = t[i]. The other is to
employ the minimum ‚Äú‚ü®. . . ‚ü©-code‚Äù, b = ‚ü®t[i] : i < x‚ü©. By II.2.19, b (but not
necessarily c) ‚ÄúsatisÔ¨Åes‚Äù Seq.
II.3. Formal Primitive Recursion
II.3.1 Theorem (Primitive Recursive DeÔ¨Ånitions). Let h and g be n-ary and
(n + 2)-ary function symbols. Then we may introduce a new (n + 1)-ary func-
tion symbol, f , such that
‚ä¢f (0,‚Éóy ) = h(‚Éóy )
and
‚ä¢f (Sx,‚Éóy ) = g(x,‚Éóy, f (x,‚Éóy ))
Proof. We prove
‚ä¢(‚àÉz)
%
Seq(z) ‚àßlh(z) = Sx ‚àß(z)0 = h(‚Éóy )
‚àß(‚àÄi)<x((z)Si = g(i,‚Éóy, (z)i))
&
(1)
This is done by formal induction on x.
For x = 0, taking z = ‚ü®h(‚Éóy )‚ü©works (this invokes < 1 and Ax2).

II.3. Formal Primitive Recursion
249
Assume now (1) for frozen variables (the I.H.). For the induction step we
want to show
‚ä¢(‚àÉz)
%
Seq(z) ‚àßlh(z) = SSx ‚àß(z)0 = h(‚Éóy )
‚àß(‚àÄi)<Sx((z)Si = g(i,‚Éóy, (z)i))
&
(2)
To this end, let a be a new constant, and add the assumption (invoking I.4.27
and (1))
‚ä¢Seq(a) ‚àßlh(a) = Sx ‚àß(a)0 = h(‚Éóy )
‚àß(‚àÄi)<x((a)Si = g(i,‚Éóy, (a)i))
(3)
Set now
b = a ‚àó‚ü®g(x,‚Éóy, (a)x)‚ü©
By II.2.21 and ( f (4)) (p. 218)
‚ä¢Seq(b)‚àß
lh(b) = SSx‚àß
(‚àÄi)<Sx(b)i = (a)i ‚àß
(b)Sx = g(x,‚Éóy, (a)x)
(4)
the last conjunct being distilled from
‚ä¢i < S0 ‚Üí(b)i+Sx = g(x,‚Éóy, (a)x)
and ‚ä¢i < S0 ‚Üîi = 0.
Thus, using (3) and the Leibniz axiom (Ax4),
‚ä¢Seq(b)‚àß
lh(b) = SSx‚àß
(b)0 = h(‚Éóy )‚àß
(‚àÄi)<x(b)Si = g(i,‚Éóy, (b)i)‚àß
(b)Sx = g(x,‚Éóy, (b)x)
(since ‚ä¢(b)x = (a)x by (4))
In short, using (I.7.2) ‚ä¢(b)Sx = g(x,‚Éóy, (b)x) ‚Üî(‚àÄi)i=x(b)Si = g(i,‚Éóy, (b)i),
‚àÄ-distribution over ‚àß, and < 2, we have
‚ä¢Seq(b) ‚àßlh(b) = SSx ‚àß(b)0 = h(‚Éóy ) ‚àß(‚àÄi)<Sx(b)Si = g(i,‚Éóy, (b)i)
This proves (2) by Ax2 and concludes the inductive proof of (1). We can now let
F(x,‚Éóy ) = (¬µz)
%
Seq(z) ‚àßlh(z) = Sx‚àß
(z)0 = h(‚Éóy ) ‚àß(‚àÄi)<x((z)Si = g(i,‚Éóy, (z)i))
&
where F is a new function symbol.

250
II. The Second Incompleteness Theorem
By ( f (4)) (p. 218),
‚ä¢(F(x,‚Éóy ))0 = h(‚Éóy )
‚ä¢i < x ‚Üí(F(x,‚Éóy ))Si = g(i,‚Éóy, (F(x,‚Éóy ))i)
(5)
The Ô¨Årst part of (5) yields (by substitution)
‚ä¢(F(0,‚Éóy ))0 = h(‚Éóy )
(6)
The second yields (by substitution [x ‚ÜêSi])
‚ä¢(F(Si,‚Éóy ))Si = g(i,‚Éóy, (F(Si,‚Éóy ))i)
(7)
We now claim that
‚ä¢(F(Si,‚Éóy ))i = (F(i,‚Éóy ))i
(8)
It is convenient to prove a bit more, by induction on i, namely, that
‚ä¢(‚àÄx)(i < x ‚Üí(F(i,‚Éóy ))i = (F(x,‚Éóy ))i)
(9)
The case for i = 0 follows from (6) and the Ô¨Årst of (5).
We now assume (9) as our I.H., freezing the free variables (i and ‚Éóy ).
For our induction step we need to prove
(‚àÄx)(Si < x ‚Üí(F(Si,‚Éóy ))Si = (F(x,‚Éóy ))Si)
but we prove instead
Si < x ‚Üí(F(Si,‚Éóy ))Si = (F(x,‚Éóy ))Si
To this end, we assume Si < x ‚Äì freezing x ‚Äì and proceed to verify
‚ä¢(F(Si,‚Éóy ))Si = (F(x,‚Éóy ))Si
(10)
Well, since also ‚ä¢i < x and ‚ä¢i < Si, the I.H. (9) yields by specialization
‚ä¢(F(i,‚Éóy ))i = (F(x,‚Éóy ))i
and
‚ä¢(F(i,‚Éóy ))i = (F(Si,‚Éóy ))i
Therefore,
‚ä¢g(i,‚Éóy, (F(Si,‚Éóy ))i) = g(i,‚Éóy, (F(x,‚Éóy ))i)
which, by the second part of (5) and (7), veriÔ¨Åes (10).
Having thus established (9) and therefore (8), (7) becomes
‚ä¢(F(Si,‚Éóy ))Si = g(i,‚Éóy, (F(i,‚Éóy ))i)

II.3. Formal Primitive Recursion
251
All this proves that if f is a new function symbol introduced by
f (x,‚Éóy ) = (F(x,‚Éóy ))x
then the two formulas stated in the theorem are proved.
‚ñ°
II.3.2 Exercise. Verify that if h and g are ¬µ-deÔ¨Åned from ‚àÜ0(LA) formulas,
then so is f .
‚ñ°
II.3.3 Theorem (Course-of-Values Recursion). Let h and g be function sym-
bols of arities n and n + 2 respectively. Then we may introduce a new function
symbol H of arity n + 1 such that
‚ä¢(H(0,‚Éóy ))0 = h(‚Éóy )
‚ä¢(H(Sx,‚Éóy ))Sx = g(x,‚Éóy, H(x,‚Éóy ))
‚ä¢Seq(H(x,‚Éóy )) ‚àßlh(H(x,‚Éóy )) = Sx
(1)
Proof. Invoking II.3.1, we introduce a new function symbol H by the primitive
recursion below, and show that it works:
H(0,‚Éóy ) = ‚ü®h(‚Éóy )‚ü©
H(Sx,‚Éóy ) = H(x,‚Éóy ) ‚àó‚ü®g(x,‚Éóy, H(x,‚Éóy ))‚ü©
(2)
The third formula in the group (1) is proved by induction on x. The basis is
immediate from the basis of the recursion (2) (note that a ‚Äú‚ü®. . . ‚ü©‚Äù term satisÔ¨Åes
Seq by II.2.19).
Assume now the contention for frozen x. By II.2.21 and the second formula
in group (2),
‚ä¢lh(H(Sx,‚Éóy )) = SSx
and
‚ä¢Seq(H(Sx,‚Éóy ))
This concludes the induction. The other two contentions in the theorem are
direct consequences of the two recurrence equations (2).
‚ñ°
II.3.4 Remark. Introducing yet another function symbol, f , by
f (x,‚Éóy ) = (H(x,‚Éóy ))x

252
II. The Second Incompleteness Theorem
yields at once
‚ä¢f (0,‚Éóy ) = h(‚Éóy )
‚ä¢f (Sx,‚Éóy ) = g(x,‚Éóy, H(x,‚Éóy ))
This is the standard way that course-of-values recursion is presented, i.e.,
deÔ¨Åning a function f from known functions h and g and from the ‚Äúhistory‚Äù,
H(x,‚Éóy ) = ‚ü®f (i,‚Éóy ) : i ‚â§x‚ü©, of f .
‚ñ°
We recall the concept of a term-deÔ¨Ånable (total) function (p. 181). We can now
prove
II.3.5 Theorem. Every primitive recursive function is term-deÔ¨Ånable in (some
recursive extension of ) PA.
Proof. The proof is by (informal) induction on PR. For the basis, we already
know that the initial functions are term-deÔ¨Ånable in ROB, a subtheory of PA.
Let now f, g1, . . . , gn be deÔ¨Åned by the terms f, g1, . . . , gn. We will argue
that the term f (g1(‚Éóym), . . . , gn(‚Éóym)) deÔ¨Ånes Œª‚Éóym. f (g1(‚Éóym), . . . , gn(‚Éóym)).
So let f (g1(‚Éóam), . . . , gn(‚Éóam)) = b be true. Then, for appropriate ‚Éócn,
f (c1, . . . , cn) = b
g1(‚Éóam) = c1
...
gn(‚Éóam) = cn
By the induction hypothesis,
‚ä¢f (c1, . . . , 
cn) = b
‚ä¢g1(
a1, . . . , 
am) = c1
...
‚ä¢gn(
a1, . . . , 
am) = 
cn
Hence (via Ax4)
‚ä¢f (g1(
a1, . . . , 
am), . . . , gn(
a1, . . . , 
am)) = b
Let Ô¨Ånally h and g be term-deÔ¨Åned by h and g respectively, and let f be given
by the schema below (for all x, ‚Éóy):
f (0, ‚Éóy ) = h(‚Éóy )
f (x + 1, ‚Éóy ) = g(x, ‚Éóy, f (x, ‚Éóy ))

II.3. Formal Primitive Recursion
253
We verify that the term f (x,‚Éóy ), where f is introduced by formal primitive
recursion below, deÔ¨Ånes f :
f (0,‚Éóy ) = h(‚Éóy )
(1)
f (x + 1,‚Éóy ) = g(x,‚Éóy, f (x,‚Éóy ))
To this end, we prove by (informal) induction on a that‚Ä†
f (a, ‚Éób) = c
implies
‚ä¢f (a,‚Éób) =c
(2)
Let a = 0. Then f (0, ‚Éób) = c entails h(‚Éób) = c; hence ‚ä¢h(‚Éób) =c by the I.H. (of
the PR-induction).
By the Ô¨Årst equation of group (1), ‚ä¢f (0,‚Éób) =c, which settles the basis of
the a-induction. Now Ô¨Åx a, and take (2) as the I.H. of the a-induction. We will
argue the case of (2) when a is replaced by a + 1.
Let f (a + 1, ‚Éób) = c. Then g(a, ‚Éób, d) = c, where f (a, ‚Éób) = d. By the I.H. of
the PR-induction and a-induction, i.e., (2),
‚ä¢f (a,‚Éób) =d
and
‚ä¢g(a,‚Éób,d) =c
Thus, by Ax4 and the second equation of group (1),
‚ä¢f (Sa,‚Éób) =c
‚ñ°
The above suggests the following deÔ¨Ånition.
II.3.6 DeÔ¨Ånition (Formal Primitive Recursive Functions). A deÔ¨Åned func-
tion symbol f is primitive recursive iff there is a sequence of function symbols
g1, . . . , gp such that gp ‚â°f and, for all i = 1, . . . , p, gi has been introduced
by a primitive recursive deÔ¨Ånition
gi(0, v1, . . . , vn‚àí1) = g j(v1, . . . , vn‚àí1)
gi(Sv0, v1, . . . , vn‚àí1) = gk(v0, v1, . . . , vn‚àí1, gi(v0, . . . , vn‚àí1))
where j < i and k < i and the g j and gk have arities n ‚àí1 and n + 1 respec-
tively, or by composition, that is, an explicit deÔ¨Ånition such as
gi(v0, . . . , vn‚àí1) = g j0(g j1(v0, . . . , vn‚àí1), . . . , g jr (v0, . . . , vn‚àí1))
‚Ä† ‚Éób means 
b1, 
b2, . . . .

254
II. The Second Incompleteness Theorem
using, again, previous function symbols (of the correct arities) in the sequence
(i.e., jm < i, m = 0, . . . ,r). Otherwise, gi is one of S, Z (zero function symbol),
or U n
i (n > 0, 1 ‚â§i ‚â§n) (projection function symbols), where the latter two
symbols are introduced by the deÔ¨Åning axioms
Z(v0) = 0
and
U n
i (v0, . . . , vn‚àí1) = vi‚àí1
for each positive n and 1 ‚â§i ‚â§n in N.
A sequence such as g1, . . . , gp is a formal (primitive recursive) derivation of
gp.
A term is primitive recursive iff it is deÔ¨Åned from 0, variables, and primitive
recursive function symbols according to the standard deÔ¨Ånition of ‚Äúterm‚Äù.
A predicate P is primitive recursive iff there is a primitive recursive function
symbol f of the same arity as P such that P(‚Éóx) ‚Üîf (‚Éóx) = 0 is provable.
By a slip of the tongue, we may say that P is primitive recursive iff its formal
characteristic function, œáP, is. (See however II.1.25, p. 220.)
‚ñ°
II.3.7 Remark. In order that the primitive recursive derivations do not mo-
nopolize our supply of function symbols, we can easily arrange that primitive
recursive function symbols are chosen from an appropriate subsequence of the
‚Äústandard function symbol sequence f n
i ‚Äù of p. 166. We Ô¨Åx the following very
convenient scheme that is informed by the table on p. 138.
Let a be the largest f -index used to allocate all the Ô¨Ånitely many function
symbols required by LN (three) and the Ô¨Ånitely many required for the introduc-
tion of Œ≤ and the ‚ü®. . .‚ü©coding.
We let, for convenience, b = a + 1, and we allocate the formal primi-
tive recursive function symbols from among the members of the subsequence
( f n
bk)k‚â•0, being very particular about the k-value (k-code) chosen (p. 138):
(1) k = ‚ü®0, 1, 0‚ü©is used for Z (n = 1, of course).
(2) k = ‚ü®0, 1, 1‚ü©is used for S.‚Ä†
(3) k = ‚ü®0, n, i, 2‚ü©is used for U n
i . That is, U n
i is allocated as
f n
b‚ü®0,n,i,2‚ü©
‚Ä† It does no harm that S is already allocated as f 1
0 . After all, every ‚Äúreal‚Äù primitive recursive
function ‚Äì i.e., function viewed extensionally as a set of input-output pairs ‚Äì has inÔ¨Ånitely many
different derivations, and hence inÔ¨Ånitely many function symbols allocated to it.

II.3. Formal Primitive Recursion
255
(4) k = ‚ü®1, m, f, g1, . . . , gn‚ü©is used if f m
bk is allocated to denote the result of
composition from function symbols (already allocated) with k-codes equal
to f, g1, . . . , gn. Of these, the symbol with code f must have arity n; all
the others, arity m.
(5) k = ‚ü®2, n + 1, h, g‚ü©is used if f n+1
bk
is allocated to denote the result of
primitive recursion from function symbols (already allocated) with k-codes
h, g. Of these the Ô¨Årst must have arity n, the second n + 2.
This allocation scheme still leaves an inÔ¨Ånite supply of unused (so far)
symbols to be used for future extensions of the language.
As a parting comment we note that the seemingly contrived allocation
scheme above forces the set of k-codes to be primitive recursive. (See Ex-
ercise II.13).
‚ñ°
By the proof of II.3.5, having the formal and informal derivations of the
boldface f and the lightface f ‚Äútrack each other‚Äù in the obvious way ‚Äì i.e.,
assemblingtheboldfaceversionexactlyasthelightfaceversionwasassembled‚Äì
we obtain f N‚Ä≤ = f , and
II.3.8 Theorem. If f is a formal primitive recursive function of arity n (in
LN‚Ä≤), then, for all ‚Éóan in Nn,
|=N‚Ä≤ f (‚Éóan) =b
implies
‚ä¢f (‚Éóan) =b
II.3.9 Corollary. The ‚Äúimplies‚Äù in II.3.8 can be strengthened to ‚Äúiff‚Äù. That is,
every informal primitive recursive function is strongly term-deÔ¨Ånable (p. 187),
indeed by a primitive recursive term.
Proof. Assume ‚ä¢f (‚Éóan) =b. Writing f for f N‚Ä≤, assume f (‚Éóan) = c Ã∏= b. Then
also ‚ä¢f (‚Éóan) =c; hence ‚ä¢b =c. Now, b Ã∏= c yields (already in ROB)
‚ä¢¬¨b =c, contradicting consistency of PA‚Ä≤.
‚ñ°
We are reminded that ROB and PA are consistent (since they each have a
model), a fact that we often use implicitly.‚Ä†
It is trivial then that each recursive extension PA‚Ä≤ is also consistent, for such
an extension is conservative.
‚Ä† We base this assertion, of course, on the existence of a standard model N, a fact that provides
a non-constructive proof of consistency. Constructive proofs of the consistency of ROB and PA
are also known. See for example ShoenÔ¨Åeld (1967), Sch¬®utte (1977).

256
II. The Second Incompleteness Theorem
II.3.10 Corollary. For every closed primitive recursive term t there is a unique
n ‚ààN such that ‚ä¢t = n.
Proof. Existence is by II.3.8 (use n = tN‚Ä≤). Uniqueness follows from deÔ¨Ån-
ability of x = y in ROB (I.9.39, p. 181) and hence in any extension PA‚Ä≤.
‚ñ°
Pause. Is it true that every closed term in a recursive extension of PA is provably
equal to a numeral?
II.3.11 Corollary. Every primitive recursive relation is strongly deÔ¨Ånable by
some formal primitive recursive predicate.
II.4. The Boldface ‚àÜand Œ£
II.4.1 DeÔ¨Ånition. Let LA be a language of arithmetic. The symbol Œ£1(LA)
denotes the set of formulas {(‚àÉx)A : A ‚àà‚àÜ0(LA)}.
If the language is LN, then we simply write Œ£1.
‚ñ°
Usage of boldface type in Œ£1 should distinguish this set of formulas over LN
from the set of 1-relations of the arithmetic hierarchy.
We also deÔ¨Åne variants of ‚àÜ0 and Œ£1 above.
II.4.2 DeÔ¨Ånition. Let LA be a language of arithmetic. The symbol ‚àÜ+
0 (LA) de-
notes the smallest set of formulas over LA that includes the atomic formulas, but
also the negations of atomic formulas, and moreover satisÔ¨Åes the closure con-
ditions: If A and B are in ‚àÜ+
0 (LA), then so are A ‚à®B , A ‚àßB , (‚àÉx)<tA,
and (‚àÄx)<tA (where we require that the variable x not occur in the term t).
If the language is LN, then we simply write ‚àÜ+
0 .
‚ñ°
II.4.3 DeÔ¨Ånition. Let LA be a language of arithmetic. The symbol ‚àÜ‚Ä≤
0(LA)
denotes the smallest set of formulas over LA that includes the restricted atomic
formulas (deÔ¨Åned below) ‚Äì and their negations ‚Äì and moreover satisÔ¨Åes the
closure conditions: If A and B are in ‚àÜ‚Ä≤
0(LA), then so are A ‚à®B , A ‚àßB ,
(‚àÉx)<yA and (‚àÄx)<yA (where x Ã∏‚â°y).
Correspondingly, the symbol Œ£‚Ä≤
1(LA) denotes the set of formulas {(‚àÉx)A :
A ‚àà‚àÜ‚Ä≤
0(LA)}.
If the language is LN, then we simply write ‚àÜ‚Ä≤
0 and Œ£‚Ä≤
1.
Now, the restricted atomic formulas over LA are x = y, 0 = y, f‚Éóxn = y,
and P‚Éóxn for all n-ary function ( f ) and predicate (P) symbols.
‚ñ°

II.4. The Boldface  and 
257
The restriction on the atomic formulas above was to have function and predicate
letters act on variables (rather than arbitrary terms). Similarly, we have used
(‚àÉx)<y and (‚àÄx)<y rather than (‚àÉx)<t and (‚àÄx)<t in II.4.3.
The superscript ‚Äú+‚Äù in II.4.2 is indicative of the (explicit) presence of only
positive closure operations (¬¨ does not participate in the deÔ¨Ånition). The same
is true of the ‚àÜ‚Ä≤
0(LA) formulas.
It turns out that both ‚àÜ+
0 (LA) and ‚àÜ‚Ä≤
0(LA) formulas are closed under nega-
tion (in the deÔ¨Ånition of these sets of formulas the application of ‚Äú¬¨‚Äù has been
pushed as far to the right as possible). We prove this contention below. The
introduction of ‚àÜ+
0 (LA) and ‚àÜ‚Ä≤
0(LA) is only offered for convenience (proof
of II.4.12 below). Neither symbol is standard in the literature.
II.4.4 Lemma. For any A ‚àà‚àÜ+
0 (LA) (respectively, A ‚àà‚àÜ‚Ä≤
0(LA)) there is a
B ‚àà‚àÜ+
0 (LA) (respectively, B ‚àà‚àÜ‚Ä≤
0(LA)) such that ‚ä¢¬¨A ‚ÜîB , where ‚Äú‚ä¢‚Äù
denotes logical (pure) provability.
Proof. We do induction on ‚àÜ+
0 (LA) (respectively, ‚àÜ‚Ä≤
0(LA); the induction vari-
able is A).
Basis.
If A is atomic (or restricted atomic), then we are done at once. If
it is a negated atomic (or negated restricted atomic) formula, then we are done
by |=Taut B ‚Üî¬¨¬¨B .
Now A can have the following forms (if not atomic or negated atomic) by
II.4.2‚ÄìII.4.3:
(i) A ‚â°B ‚à®C .
Then ‚ä¢¬¨A ‚Üî¬¨B ‚àß¬¨C , and we are done by the I.H.
via the Leibniz rule.
(ii) A ‚â°B ‚àßC .
Then ‚ä¢¬¨A ‚Üî¬¨B ‚à®¬¨C , and we are done by the I.H.
via the Leibniz rule.
(iii) A ‚â°(‚àÉx)<tB .
Then ‚ä¢¬¨A ‚Üî(‚àÄx)<t¬¨B , and we are done by the
I.H. via the Leibniz rule.
(iv) A ‚â°(‚àÄx)<tB .
Then ‚ä¢¬¨A ‚Üî(‚àÉx)<t¬¨B , and we are done by the
I.H. via the Leibniz rule.
‚ñ°
II.4.5 Corollary. For any A ‚àà‚àÜ0(LA) there is a B ‚àà‚àÜ+
0 (LA) such that we
can prove A ‚ÜîB without nonlogical axioms.
Conversely, every B ‚àà‚àÜ+
0 (LA) is a formula of ‚àÜ0(LA).
II.4.6 Lemma. Let A and B be in Œ£1(LA) (respectively, Œ£‚Ä≤
1(LA)). Then
each of the following is provably equivalent in PA‚Ä≤ to a formula in Œ£1(LA)

258
II. The Second Incompleteness Theorem
(respectively, Œ£‚Ä≤
1(LA)):
(i) A ‚à®B
(ii) A ‚àßB
(iii) (‚àÉx)A
(iv) (‚àÉx)<zA
(v) (‚àÄx)<zA.
By PA‚Ä≤ over LA, above, we understand an extension by deÔ¨Ånitions of PA over
LN. (In this connection cf. II.1.2, p. 207).
Proof. The proof is a straightforward formalization of the techniques employed
in the proof of I.8.48. The only case that presents some interest is (v), and we
give a proof here. The proof hinges on the fact‚Ä†
‚ä¢(‚àÄx)<z(‚àÉy)B ‚Üî(‚àÉw)(‚àÄx)<z(‚àÉy)<wB
where w is a new variable.
The ‚Üê-direction of the above being trivial, we just prove
‚ä¢(‚àÄx)<z(‚àÉy)B ‚Üí(‚àÉw)(‚àÄx)<z(‚àÉy)<wB
(1)
by induction on z.‚Ä°
The basis, z = 0 is settled by < 1. Take now (1), with frozen variables, as
the I.H. Add the assumption
(‚àÄx)<Sz(‚àÉy)B
(2)
We want
‚ä¢(‚àÉw)(‚àÄx)<Sz(‚àÉy)<wB
(3)
By (2) and specialization,
‚ä¢x < z ‚à®x = z ‚Üí(‚àÉy)B
(4)
Since ‚ä¢x < z ‚Üíx < z ‚à®x = z and ‚ä¢x = z ‚Üíx < z ‚à®x = z, (4) yields
‚ä¢x < z ‚Üí(‚àÉy)B
(5)
‚Ä† If we set A ‚â°(‚àÉy)B , where B ‚àà‚àÜ0(LA), then (‚àÉw)(‚àÄx)<z(‚àÉy)<wB is the Œ£1(LA) formula
we want in order to establish (v).
‚Ä° The reader who has had some axiomatic set theory will notice the remarkable similarity of (1)
with the axiom of collection (cf. volume 2, Chapter III). Indeed, (1) interprets collection, if we
interpret the basic predicate ‚Äú‚àà‚Äù of set theory as the predicate ‚Äú<‚Äù of arithmetic.

II.4. The Boldface  and 
259
and
‚ä¢x = z ‚Üí(‚àÉy)B
(6)
By (5) and the I.H. we obtain
‚ä¢(‚àÉw)(‚àÄx)<z(‚àÉy)<wB
(7)
By (6) we obtain ‚ä¢(‚àÉy)B [x ‚Üêz]; hence
‚ä¢(‚àÉw)(‚àÉy)<wB [x ‚Üêz]
(8)
Pause. Why is (8) true? Well, it follows immediately provided we believe
‚ä¢(‚àÉy)B ‚Üí(‚àÉw)(‚àÉy)<wB
To establish the above let (‚àÉy)B [y]. Add now B [c], where c is a new constant.
Then ‚ä¢c < Sc ‚àßB [c]; hence ‚ä¢(‚àÉy)(y < Sc ‚àßB ) (by Ax2) and thus ‚ä¢
(‚àÉw)(‚àÉy)(y < w ‚àßB ) (by Ax2 again).
Now, arguing by auxiliary constant once more, relying on (7) and (8), we
add new constants a and b and the assumptions
(‚àÄx)<z(‚àÉy)<aB
(7‚Ä≤)
and
(‚àÉy)<bB [x ‚Üêz]
(8‚Ä≤)
By the Leibniz axiom (Ax4) and tautological implication, (8‚Ä≤) yields
‚ä¢x = z ‚Üí(‚àÉy)<bB
(9)
On the other hand, we obtain from (7‚Ä≤)
‚ä¢x < z ‚Üí(‚àÉy)<aB
(10)
Now set c = S(a + b). Proof by cases from (9) and (10) yields‚Ä†
‚ä¢x < z ‚à®x = z ‚Üí(‚àÉy)<cB
Hence
‚ä¢(‚àÄx)x<Sz(‚àÉy)<cB
By Ax2, (3) follows.
‚ñ°
‚Ä† Via the obvious ‚ä¢(‚àÉy)<aB ‚Üí(‚àÉy)<cB and ‚ä¢(‚àÉy)<bB ‚Üí(‚àÉy)<cB , obtained from
II.1.17, tautological implication, and ‚àÉ-monotonicity (I.4.23).

260
II. The Second Incompleteness Theorem
II.4.7 Lemma. For any A ‚àà‚àÜ0(LA) (respectively, A ‚àà‚àÜ‚Ä≤
0(LA)) there
is a provably equivalent ‚Äì in pure logic ‚Äì B ‚ààŒ£1(LA) (respectively,
B ‚ààŒ£‚Ä≤
1(LA)).
Proof. Let x be a variable that is not free in A. Then
(a) (‚àÉx)A ‚ààŒ£1(LA) (respectively, (‚àÉx)A ‚ààŒ£‚Ä≤
1(LA)), and
(b) ‚ä¢(‚àÉx)A ‚ÜîA.
‚ñ°
II.4.8 Lemma. For any A ‚àà‚àÜ0(LA) there is a B ‚ààŒ£‚Ä≤
1(LA) such that
‚ä¢PA‚Ä≤ A ‚ÜîB
The absence of a prime from ‚àÜ0(LA) is intentional. PA‚Ä≤ is as in II.4.6
Proof. InviewofII.4.5,wedoinductiononthedeÔ¨Ånitionof‚àÜ+
0 (LA)(induction
variable is A).
Basis.
Atomic formulas of type t = s: We Ô¨Årst look at the subcase t = y.
We embark on an informal induction on the formation of t.
For the basis we have two cases: t ‚â°x and t ‚â°0. Both lead to restricted
atomic formulas (II.4.3), and we are done by II.4.7. If now t ‚â°f t1 . . . tn, then
(one point rule, I.7.2)
‚ä¢f t1 . . . tn = y ‚Üî
(‚àÉx1) . . . (‚àÉxn)( t1 = x1
  
I.H.
‚àß. . . ‚àßtn = xn
  
I.H.
‚àßf x1 . . . xn = y



‚àÜ‚Ä≤
0(LA)
)
where the xi are new variables. By the I.H. on terms, the Leibniz rule, and II.4.6‚Äì
II.4.7 we are done.
We can now conclude the t = s case:
‚ä¢t = s ‚Üî(‚àÉy)(t = y ‚àßs = y),
where y is a new variable.
Basis.
Atomic formulas of type Pt1 . . . tn: Done by
‚ä¢Pt1 . . . tn ‚Üî
(‚àÉx1) . . . (‚àÉxn)(t1 = x1 ‚àß. . . ‚àßtn = xn ‚àßPx1 . . . xn



‚àÜ‚Ä≤
0(LA)
)
Basis.
Negated atomic formulas of type ¬¨t = s:
‚ä¢¬¨ t = s ‚Üî(‚àÉx)(‚àÉy)(t = x ‚àßs = y ‚àß¬¨x = y
  
‚àÜ‚Ä≤
0(LA)
)

II.4. The Boldface  and 
261
Basis.
Negated atomic formulas of type ¬¨Pt1 . . . tn:
‚ä¢¬¨Pt1 . . . tn ‚Üî
(‚àÉx1) . . . (‚àÉxn)(t1 = x1 ‚àß. . . ‚àßtn = xn ‚àß¬¨Px1 . . . xn



‚àÜ‚Ä≤
0(LA)
)
The induction steps are for ‚à®, ‚àß, (‚àÉx)<t, (‚àÄx)<t and follow at once from
II.4.6 (i), (ii), (iii), (iv), and (v), and (‚àÉx)<tA ‚Üî(‚àÉz)(z = t ‚àß(‚àÉx)<zA).
‚ñ°
II.4.9 Corollary. For any A ‚ààŒ£1(LA) there is a provably (in PA‚Ä≤) equivalent
B ‚ààŒ£‚Ä≤
1(LA).
Proof. II.4.8 and II.4.6(iii).
‚ñ°
II.4.10 Lemma. Let PA‚Ä≤ over LA‚Ä≤ be a recursive extension of PA. Then for
each A ‚ààŒ£1(LA‚Ä≤) there is a formula B ‚ààŒ£1(LN) such that ‚ä¢PA‚Ä≤ A ‚ÜîB .
Proof. It sufÔ¨Åces to prove that if LA‚Ä≤ is obtained from LA by the addition of
either a single function or a single predicate symbol, and the deÔ¨Åning axiom
was added to a recursive extension T (over LA) of PA yielding PA‚Ä≤, then for
each A ‚ààŒ£1(LA‚Ä≤) there is a formula B ‚ààŒ£1(LA) such that ‚ä¢PA‚Ä≤ A ‚ÜîB .
In view of II.4.9 and II.4.6(iii) it sufÔ¨Åces to prove this latter claim just for
all A ‚àà‚àÜ‚Ä≤
0(LA‚Ä≤). We do induction on the deÔ¨Ånition of ‚àÜ‚Ä≤
0(LA‚Ä≤) (induction
variable: A).
Basis.
Restricted atomic cases and their negations. All cases are trivial
(II.4.7), except f‚Éóxn = y, ¬¨ f‚Éóxn = y, P‚Éóxn, and ¬¨P‚Éóxn, when f , or P, is the
new symbol.
Say we have the case ¬¨ f‚Éóxn = y, where
f‚Éóxn = (¬µz)B
and B ‚àà‚àÜ0(LA).
Note the absence of a prime from A in ‚àÜ0(LA). ‚Äú‚ä¢‚Äù below is ‚Äú‚ä¢PA‚Ä≤‚Äù.
Thus,
‚ä¢f‚Éóxn = y ‚ÜîB [y] ‚àß(‚àÄz)<y¬¨B [z]
and therefore
‚ä¢¬¨ f‚Éóxn = y ‚Üî(‚àÉw)(¬¨y = w‚àßB [w] ‚àß(‚àÄz)<w¬¨B [z])
The right hand side of ‚Äú‚Üî‚Äù above is in Œ£1(LA).

262
II. The Second Incompleteness Theorem
If on the other hand P is the new symbol, then we have
P‚Éóxn ‚ÜîB
and B ‚àà‚àÜ0(LA), and this rests the case via II.4.7.
The induction steps are (II.4.3) for ‚à®, ‚àß, (‚àÉx)<z, (‚àÄx)<z and follow at once
from II.4.6 (i), (ii), (iv), and (v) and the standard technique of eliminating
deÔ¨Åned symbols (at the atomic formula level).
‚ñ°
II.4.11 Corollary. Let PA‚Ä≤ over LA‚Ä≤ be a recursive extension of PA. Then for
each A ‚ààŒ£1(LA‚Ä≤) there is a formula B ‚ààŒ£‚Ä≤
1(LN) such that ‚ä¢PA‚Ä≤ A ‚ÜîB .
Proof. II.4.10 guarantees a C ‚ààŒ£1(LN) such that ‚ä¢PA‚Ä≤ A ‚ÜîC . Now II.4.9
provides the B ‚ààŒ£‚Ä≤
1(LN) we want (recall that PA‚Ä≤ extends PA).
‚ñ°
II.4.12 Theorem. Let PA‚Ä≤ over LN‚Ä≤ be a recursive extension of PA, and A a
sentence in Œ£1(LN‚Ä≤). Then |=N‚Ä≤ A implies that ‚ä¢PA‚Ä≤ A.
Or, ‚Äúany really true sentence of Œ£1(LN‚Ä≤) is provable‚Äù.
Proof. By II.4.11 there is a sentence C ‚ààŒ£‚Ä≤
1(LN) (note the absence of a prime
from N) such that
‚ä¢PA‚Ä≤ A ‚ÜîC
(1)
Thus (do you believe this?)
|=N‚Ä≤ A ‚ÜîC
Hence
|=N‚Ä≤ C
Now, there is a formula B (x) ‚àà‚àÜ‚Ä≤
0(LN) such that‚Ä†
C ‚â°(‚àÉx)B (x)
Hence
|=N‚Ä≤ (‚àÉx)B (x)
Therefore, taking reducts,
|=N (‚àÉx)B (x)
(2)
‚Ä† ‚â°means string equality.

II.4. The Boldface  and 
263
By (2), (B (n))N = t for some n ‚ààN; hence (p. 171)
(B (n))N = t
(3)
By (3), and an easy induction on the structure of B (n) (DeÔ¨Ånition II.4.3),
following the steps of the proof of I.9.48 (p. 185),
‚ä¢ROB B (n)
Hence ‚ä¢PA‚Ä≤ (‚àÉx)B (x) by Ax2. By (1), ‚ä¢PA‚Ä≤ A.
‚ñ°
II.4.13 Example. Equipped with II.4.12, one can now readily answer the
‚Äúwhy‚Äùs that were embedded in Example II.2.7.
‚ñ°
II.4.14 Remark. What II.4.12 above ‚Äì and, earlier on, II.3.8 ‚Äì do for us, prac-
tically, is to eliminate the need for formal proofs of ‚Äútrue‚Äù Œ£1-sentences A,
proofs that would be normally carried out in tedious detail within some recur-
sive extension of PA. This is achieved by a two-pass process:
(1) We somehow convince ourselves that A is ‚Äútrue‚Äù, i.e., true in N or in some
expansion thereof that accommodates whatever deÔ¨Åned symbols are used
inside the sentence.
(2) We then invoke (Meta)theorem II.4.12, which guarantees ‚ä¢A, without our
having to write down a single line of a formal proof!
The reader may object: Obviously all the work was shifted to item (1). But
how does one ‚Äúprove‚Äù informally the ‚Äútruth‚Äù of a sentence? Does it not neces-
sitate as much work ‚Äì in an informal deduction‚Ä† ‚Äì as a formal proof does? For
example, that lcm{2, 3, 4, 5} = 60 is deÔ¨Ånitely obvious, but just proclaiming
so does not prove this fact. How do we know that it is true?
The explanation is not mathematical, but it rather hinges on the sociology of
informal proofs. An informal proof, viewed as a social activity, ends as soon as
a reasonably convincing case has been made. Informal proofs are often sketchy
(hence shorter than formal proofs), and the participants (prover and reader)
usually agree that a certain level of detail can be left untold,‚Ä° and are also
prepared to accept ‚Äúthe obvious‚Äù ‚Äì the latter being informed by a vast database
of ‚Äúreal‚Äù mathematical knowledge that goes all the way back to one‚Äôs primary
school years.
‚Ä† Ofcourse, onewould neverthinkofestablishingtruthinmathematicalpracticepurelybysemantic
means, for this would involve messy inÔ¨Ånitary arguments, while deductions, even informal ones,
have the advantage of being Ô¨Ånitary.
‚Ä° We are guilty of often leaving details for the reader to work out in our formal proofs. This dilutes
the formal proof by an informality that we exercise for pedagogical reasons.

264
II. The Second Incompleteness Theorem
Surely sometime in the past we have learnt how to compute the lcm, or the
gcd, of a set of numbers, or that 13 + 7 = 20 is ‚Äútrue‚Äù. We retrieve all this
from the ‚Äúdatabase‚Äù. Of course, a formal proof in ROB of, say, 
13 +7 = 
20 is
another matter, and is certainly not totally painless, as the reader who has read
the lemma on the deÔ¨Ånability of x + y = z (I.9.41, p. 181) will agree.‚Ä†
Thus, deductions in ‚Äúreal‚Äù mathematics need only be as long (i.e., as de-
tailed) as necessary for their acceptability. Indeed, one often Ô¨Ånds that the level
of detail included in various informal proofs of the same result is inversely pro-
portional to the mathematical sophistication of the targeted audiences in each
presentation.‚Ä° By contrast, formal proofs are, by deÔ¨Ånition (cf. I.3.17, p. 37),
audience-independent.
Back to practice: Having performed step (1) above, we can now do one of
two things: We can decide not to cheat by using step (2), but write down instead
a formal argument that translates the informal one of step (1), treating the latter
merely as a set of ‚Äúorganizational notes‚Äù.¬ß
Or, we can take the easy way out and invoke step (2). This avenue establishes
the formal result entirely metamathematically. We have shown that a formal
proof exists, without constructing the proof.
The approach is analogous to that of employing Church‚Äôs thesis to informally
‚Äúprove‚Äù results in recursion theory. This thesis says: ‚ÄúIf we have shown by an
informal argument that a partial function f is computable in the intuitive sense ‚Äì
for example, we have written informal instructions for its computation ‚Äì then
this f is partial recursive, that is, a formal algorithm for its computation exists
(e.g., an algorithm formalized as a Turing machine, or as a Kleene schemata
description)‚Äù. We do not need to exhibit this formal algorithm.
Compare with ‚ÄúIf we have shown by an informal argument that a sentence
A among the types allowed in II.4.12 and II.3.8 is true in the standard struc-
ture, then there exists a proof for this A in (some conservative extension of)
PA‚Äù.
However, even though Church‚Äôs thesis and II.4.12 and II.3.8 are applied
in a similar manner, there is a major difference between them: The former
‚Ä† It is normal (sloppy) practice to invoke ‚Äúgeneral‚Äù results where it would have been more appro-
priate, in order to avoid circularity, not to do so. For example, we may claim that (for any Ô¨Åxed a
and b in N) the ‚Äútrue‚Äù sentence a +b = 
a + b is provable, by invoking II.4.12 or II.3.8. Correct
practice would have been to say that the provability of the sentence is due to I.9.41, since the
latter was used towards the establishment of II.4.12 and II.3.8. But this puts a heavier burden on
memory.
‚Ä° For example, it is held that part of the reason that G¬®odel never published a complete proof of his
second incompleteness theorem was that the result was readily believed by his targeted audience.
¬ß This is entirely analogous to what a computer programmer might do. He would Ô¨Årst develop
pseudocode (an informal program) towards the solution of a problem. He would then translate
the pseudocode to a formal computer program written in the appropriate programming language.

II.5. Arithmetization
265
is only a belief based on empirical evidence,‚Ä† while the latter two are meta-
theorems.
Unlike ‚Äútrue‚Äù existential sentences, ‚Äútrue‚Äù universal, or Œ†1, sentences (of
arithmetic) are not necessarily provable, as G¬®odel‚Äôs Ô¨Årst incompleteness theo-
rem tells us. The Œ†1-formulas are those of the form ¬¨A where A is Œ£1.
For example, if T is the formal Kleene predicate, then there are inÔ¨Ånitely
many ‚Äútrue‚Äù Œ†1-sentences of the form ¬¨(‚àÉy)T(a,a, y) that are not provable
(cf. (3) in I.9.37).
‚ñ°
II.5. Arithmetization
We now resume and conclude the discussion on the arithmetization of formal
arithmetic(s) that we have started in Section I.9 (p. 168). The arithmetization is
really a package that includes the G¬®odel numbers of terms and formulas on one
hand, and, on the other hand, a Ô¨Ånite suite of formal predicates and functions
introduced to test for properties of G¬®odel numbers (e.g., testing whether x is a
number for a formula, term, variable, etc.).
This package will be totally contained inside an appropriate recursive exten-
sion of PA over the appropriate LN‚Ä≤ that contains all the tools (such as ‚Äú‚ü®. . . ‚ü©‚Äù,
etc.) needed to form G¬®odel numbers as on p. 168 and all the additional test
predicates and functions (and their deÔ¨Åning axioms).
G¬®odel numbers, ‚Äú‚åú. . . ‚åù‚Äù, will be certain closed terms over LN‚Ä≤ rather
than ‚Äúreal‚Äù natural numbers from N. We will rely on the numbering given on
p. 168; however, we shall now employ the formal minimum coding ‚ü®. . . ‚ü©given
by (FC) on p. 239 and also make the following trivial amendment to notation:
Every occurrence of a speciÔ¨Åc natural number n inside ‚ü®. . . ‚ü©brackets is now
changed to the term denoted by n (numeral).
We next introduce the testing tools, that is, a Ô¨Ånite sequence of atomic
formulas and terms (introducing appropriate predicate and function symbols in
a manner that respects the rules for recursive extensions) that enable the theory
to ‚Äúreason about‚Äù formulas (using G¬®odel numbers as aliases of such formulas).
‚Ä† In some contexts ‚Äì such as when partial function oracles are allowed ‚Äì there is evidence to
the contrary: If L(x, Œ±, y) is the relation that says ‚Äúprogram x with input the oracle Œ± has a
computation of length less than y‚Äù, then this is intuitively computable: Just let program x crank
with input Œ± and keep track of the number of steps. If the program halts in fewer than y steps,
then stop everything and return ‚Äúyes‚Äù; otherwise, if x has already performed the yth step, stop
everything and return ‚Äúno‚Äù. Now, if Œ± and Œ≤ are partial functions, Œ± ‚äÜŒ≤ does not guarantee that
L(x, Œ±, y) and L(x, Œ≤, y) yield the same answer, that is, L is non-monotone, or inconsistent. In
most foundations of computability inconsistent relations such as L are not allowed, i.e., L is not
formally computable in such theories; hence Church‚Äôs thesis fails with respect to such theories.
This particular ‚Äúnegative evidence‚Äù is eliminated if we use a different foundation of computability
that was introduced in Tourlakis (1986, 1996, 2001a). Now L is formally computable. See also
Kalm¬¥ar‚Äôs (1957) objections.

266
II. The Second Incompleteness Theorem
In each case we precede the deÔ¨Ånition with a comment stating the intended
meaning.
Var(x, i) holds if ‚Äúx = ‚åúvi‚åù‚Äù.
Var(x, i) ‚ÜîSeq(x) ‚àßlh(x) = i +4 ‚àß(x)0 = S0
‚àß(x)S0 = ‚åú(‚åù‚àß(x)i + SSS0 = ‚åú)‚åù
‚àß(‚àÄz)<lh(x)(S0 < z ‚àßz < i +3 ‚Üí(x)z = ‚åú‚ñ°‚åù)
(Var)
We prefer to write, say, ‚Äú. . . = ‚åú(‚åù‚Äù rather than ‚Äú. . . = ‚ü®0,9‚ü©‚Äù.
Func(x, i, j) holds if ‚Äúx = ‚åúf j
i ‚åù‚Äù.
Func(x, i, j) ‚ÜîSeq(x) ‚àßlh(x) = i + j +6 ‚àß(x)0 = 2
‚àß(x)S0 = ‚åú(‚åù‚àß(x)i+ j+5 = ‚åú)‚åù
‚àß(x)i+3 = ‚åú#‚åù
(Func)
‚àß(‚àÄz)<lh(x)(S0 < z ‚àßz < i + j +5
‚àß¬¨z = i +3
‚Üí(x)z = ‚åú‚ñ≥‚åù)
Pred(x, i, j) means ‚Äúx = ‚åúP j
i ‚åù‚Äù.
Pred(x, i, j) ‚ÜîSeq(x) ‚àßlh(x) = i + j +6 ‚àß(x)0 = 3
‚àß(x)S0 = ‚åú(‚åù‚àß(x)i+ j+5 = ‚åú)‚åù
‚àß(x)i+3 = ‚åú#‚åù
(Pred)
‚àß(‚àÄz)<lh(x)(S0 < z ‚àßz < i + j +5
‚àß¬¨z = i +3
‚Üí(x)z = ‚åú‚Éù‚åù)
Before we proceed with terms and other constructs we introduce the lower-
case versions of the above predicates:
var(x)
‚Üî(‚àÉi)‚â§xVar(x, i)
holds if ‚Äúx = ‚åúvi‚åù, for some i‚Äù
f unc(x, n) ‚Üî(‚àÉi)‚â§xFunc(x, i, n)
holds if ‚Äúx = ‚åúf n
i ‚åù, for some i‚Äù
pred(x, n) ‚Üî(‚àÉi)‚â§x Pred(x, i, n)
holds if ‚Äúx = ‚åúPn
i ‚åù, for some i‚Äù
Term is a new function symbol introduced by course-of-values recursion
(Theorem II.3.3, p. 251) below. Term(‚åút‚åù) = 0 means ‚Äút is a term‚Äù.
On the other hand, the statement ‚ÄúTerm(x) = 0 implies that ‚Äòx = ‚åút‚åùfor some
term t‚Äô ‚Äù is not a fair description of what ‚ÄúTerm‚Äù does. That is, after establishing
that Term(x) = 0, we can only infer that x ‚Äúbehaves like‚Äù the G¬®odel number
of some term, not that it is the G¬®odel number of some term. See Lemma II.6.24

II.5. Arithmetization
267
(p. 297) later on, and the comment following it. If ‚Äúimplies‚Äù is not apt, then we
cannot say ‚Äúmeans‚Äù either, for the latter is argot for equivalence. We can say
‚Äúholds if‚Äù, though.
Similar caution must be exercised when interpreting the remaining functions
and predicates introduced in this section.
Term(x) =
Ô£±
Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£≥
0
if var(x) ‚à®x = ‚ü®0, S0‚ü©
‚à®Seq(x) ‚àß(‚àÉy)<x(lh(x) = Sy ‚àßf unc((x)0, y)
‚àß(‚àÄz)<yTerm((x)Sz) = 0)
S0
otherwise
(Trm)
AF(‚åúA‚åù) says ‚ÄúA is atomic‚Äù.
AF(x) ‚Üî(‚àÉy)<x(‚àÉz)<x(Term(y) = 0 ‚àßTerm(z) = 0
‚àßx = ‚ü®‚åú= ‚åù, y, z‚ü©)
‚à®Seq(x)‚àß(‚àÉy)<x(lh(x) = Sy ‚àßpred((x)0, y)
‚àß(‚àÄz)<yTerm((x)Sz) = 0)
(Af)
WFF is a new function symbol introduced by course-of-values recursion
below. WFF(‚åúA‚åù) = 0 means ‚ÄúA ‚ààWff ‚Äù:
WFF(x) =
Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
0
if AF(x) ‚à®Seq(x) ‚àß(lh(x) =3 ‚àß[(x)0 = ‚åú‚à®‚åù
‚àßWFF((x)S0) = 0 ‚àßWFF((x)SS0) = 0
‚à®(x)0 = ‚åú‚àÉ‚åù‚àßvar((x)S0) ‚àßWFF((x)SS0) = 0]
‚à®lh(x) =2 ‚àß(x)0 = ‚åú¬¨‚åù‚àßWFF((x)S0) = 0)
S0
otherwise
(Wff)
We now introduce a new function symbol, Free, such that Free(i, x) = 0
intuitively says ‚Äúif x is the G¬®odel number of a term or formula E, then vi occurs
free in E‚Äù (see I.1.10, p. 18).
Free(i, x) =
Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
0
if Var(x, i) ‚à®
%
AF(x) ‚à®(Term(x) = 0 ‚àß(‚àÉy)<x f unc((x)0, y))
&
‚àß
(‚àÉy)<lh(x)(0 < y ‚àßFree(i, (x)y) = 0) ‚à®
WFF(x) = 0 ‚àß(x)0 = ‚åú¬¨‚åù‚àßFree(i, (x)S0) = 0 ‚à®
WFF(x) = 0 ‚àß(x)0 = ‚åú‚à®‚åù‚àß
(Free(i, (x)S0) = 0 ‚à®Free(i, (x)SS0) = 0) ‚à®
WFF(x) = 0 ‚àß(x)0 = ‚åú‚àÉ‚åù‚àß
¬¨Var((x)S0, i) ‚àßFree(i, (x)SS0) = 0
S0
otherwise
(Fr)

268
II. The Second Incompleteness Theorem
We next introduce G¬®odel‚Äôs substitution function, a precursor of Kleene‚Äôs S-m-n
functions. We introduce a new function symbol by course-of-values recursion.
Sub(x, y, z) will have the following intended effect:
Sub(‚åút[vi]‚åù,i, ‚åús‚åù) = ‚åút[s]‚åù
and
Sub(‚åúA[vi]‚åù,i, ‚åús‚åù) = ‚åúA[s]‚åù
However, in the latter case, the result will be as described iff s is substitutable in
vi. Otherwise the result 0 will be returned (a good choice for ‚Äúnot applicable‚Äù,
since no G¬®odel number equals 0).
This will make the deÔ¨Ånition a bit more complicated than usual.‚Ä† Our deÔ¨Å-
nition of Sub below tracks I.3.11, p. 32.
Sub(x, i, z) =
Ô£±
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≤
Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£¥Ô£≥
z
if Var(x, i)
x
if x = ‚ü®0, S0‚ü©
x
if var(x) ‚àß¬¨Var(x, i)
(¬µw)
%
Seq(w) ‚àßlh(w) = lh(x) ‚àß(w)0 = (x)0 ‚àß
(‚àÄy)<lh(x)(y > 0 ‚Üí(w)y = Sub((x)y, i, z))
&
if (Term(x) = 0 ‚àß(‚àÉy)<x f unc((x)0, y)) ‚à®AF(x)
‚ü®(x)0, Sub((x)S0, i, z)‚ü©
if WFF(x) = 0 ‚àß(x)0 = ‚åú¬¨‚åù‚àß
Sub((x)S0, i, z) > 0
‚ü®(x)0, Sub((x)S0, i, z), Sub((x)SS0, i, z)‚ü©
if WFF(x) = 0 ‚àß(x)0 = ‚åú‚à®‚åù‚àß
Sub((x)S0, i, z) > 0 ‚àßSub((x)SS0, i, z) > 0
x
if WFF(x) = 0 ‚àß(x)0 = ‚åú‚àÉ‚åù‚àßVar((x)S0, i)
‚ü®(x)0, (x)S0, Sub((x)SS0, i, z)‚ü©
if WFF(x) = 0 ‚àß(x)0 = ‚åú‚àÉ‚åù‚àß¬¨Var((x)S0, i)
‚àßSub((x)SS0, i, z) > 0 ‚àß
(‚àÉj)‚â§(x)S0(Var((x)S0, j) ‚àßFree( j, z) > 0)
0
otherwise
(Sub)
A two variable version, the family of the ‚Äúlowercase subi‚Äù, for i ‚ààN, is also
useful:
subi(x, z) = Sub(x,i, z)
(subi)
For any terms t[vm], s and formula A[vm], we will (eventually) verify that
‚ä¢subm(‚åút[vm]‚åù, ‚åús‚åù) = ‚åút[s]‚åùand ‚ä¢subm(‚åúA[vm]‚åù, ‚åús‚åù) = ‚åúA[s]‚åù, as-
suming that s is substitutable for vm in A.
‚Ä† In the literature ‚Äì e.g., ShoenÔ¨Åeld (1967), Smory¬¥nski (1978, 1985) ‚Äì one tends to deÔ¨Åne Sub with
no regard for substitutability, i.e., pretending that all is O.K. One then tests for substitutability
via other predicates or functions that are subsequently introduced.

II.5. Arithmetization
269
In the next section we introduce (informally) yet another special case of sub
that has special signiÔ¨Åcance towards proving the second incompleteness theo-
rem. For now, we continue with the introduction of predicates that ‚Äúrecognize‚Äù
G¬®odel numbers of logical axioms.
The introductory remarks to Section II.1 announced that we will be making
an amendment to what the set  of logical axioms is, in order to make the
arithmetization more manageable.
Indeed, while keeping the schemata Ax2‚ÄìAx4 the same, we change group
Ax1 ‚Äì the ‚Äúpropositional axioms‚Äù ‚Äì to consist of the four schemata below:
(1) A ‚à®A ‚ÜíA
(2) A ‚ÜíA ‚à®B
(3) A ‚à®B ‚ÜíB ‚à®A
(4) (A ‚ÜíB ) ‚Üí(C ‚à®A ‚ÜíC ‚à®B ).
Of course, the new axiom group Ax1 is equivalent with the old one on p. 34,
as Exercises I.26‚ÄìI.41 (pp. 193‚Äì195) in Chapter I show.
Thus we introduce predicates Propi (i = 1, 2, 3, 4) such that Propi(x) is
intended to hold if x is a G¬®odel number of a formula belonging to the schema (i),
i = 1, 2, 3, 4. Here is one case (case (4)); cases (1)‚Äì(3) are less work.
Prop4(x) ‚Üî(‚àÉy)<x(‚àÉz)<x(‚àÉw)<x

WFF(y) = 0 ‚àßWFF(z) = 0 ‚àß
WFF(w) = 0 ‚àß
x =
.
‚åú‚Üí‚åù,
)
‚åú‚Üí‚åù, y, z
*
,
)
‚åú‚Üí‚åù, ‚ü®‚åú‚à®‚åù, w, y‚ü©, ‚ü®‚åú‚à®‚åù, w, z‚ü©
*/
To simplify notation we have used the abbreviation ‚Äú‚ü®‚åú‚Üí‚åù, a, b‚ü©‚Äù for the
fully explicit ‚Äú‚ü®‚åú‚à®‚åù, ‚ü®‚åú¬¨ ‚åù, a‚ü©, b‚ü©‚Äù. This will recur in our descriptions of the
remaining axiom schemata.
We Ô¨Ånally introduce
Prop(x) ‚ÜîProp1(x) ‚à®Prop2(x) ‚à®Prop3(x) ‚à®Prop4(x)
(Prop)
which is intended to hold if x is a G¬®odel number of an axiom of type Ax1 (as
the Ax1 group was amended above).
For Ax2 we introduce SubAx.
SubAx(x) holds if x = ‚åúA[z ‚Üêt] ‚Üí(‚àÉz)A‚åùfor some formula A, vari-
able z, and term t that is substitutable for z in A. Thus,
SubAx(x) ‚Üî(‚àÉy)<x(‚àÉz)<x(‚àÉw)<x(‚àÉi)<x
%
WFF(y) = 0 ‚àß
Term(w) = 0 ‚àßVar(z, i) ‚àßSub(y, i, w) > 0 ‚àß
x = ‚ü®‚åú‚Üí‚åù, Sub(y, i, w), ‚ü®‚åú‚àÉ‚åù, z, y‚ü©‚ü©
&
(SubAx)

270
II. The Second Incompleteness Theorem
Note that Sub(y, i, w) > 0 ‚Äúsays‚Äù that the term with G¬®odel number w is sub-
stitutable for vi in the formula with G¬®odel number y. We will verify this in the
next section, however the reader can already intuitively see that this is so from
the deÔ¨Ånition of Sub.
For the axioms Ax3 we introduce Id Ax:
Id Ax(x) holds if x = ‚åúy = y‚åùfor some variable y. Thus,
Id Ax(x) ‚ÜîSeq(x) ‚àßlh(x) = SSS0 ‚àß
(x)0 = ‚åú= ‚åù‚àß(x)S0 = (x)SS0 ‚àßvar((x)S0)
(IdAx)
Finally, for Ax4 we introduce Eq Ax. Eq Ax(x) holds if x = ‚åút = s ‚Üí
(A[t] ‚ÜîA[s])‚åùfor some formula A and substitutable terms t and s. Thus,
Eq Ax(x) ‚Üî(‚àÉy)<x(‚àÉz)<x(‚àÉw)<x(‚àÉv)<x(‚àÉi)<x
%
WFF(y) = 0 ‚àß
Term(w) = 0 ‚àßTerm(v) = 0 ‚àßVar(z, i) ‚àß
Sub(y, i, w) > 0 ‚àßSub(y, i, v) > 0 ‚àß
x = ‚ü®‚åú‚Üí‚åù, ‚ü®‚åú= ‚åù, w, v‚ü©, ‚ü®‚åú‚Üî‚åù, Sub(y, i, w), Sub(y, i, v)‚ü©‚ü©
&
(EqAx)
Thus, we introduce LA by
LA(x) ‚ÜîProp(x) ‚à®SubAx(x) ‚à®Id Ax(x) ‚à®Eq Ax(x)
(LA)
LA(‚åúA‚åù) means ‚ÄúA ‚àà‚Äù.
We have two rules of inference. Thus, we introduce MP by
MP(x, y, z) ‚ÜîWFF(x) = 0 ‚àßWFF(z) = 0 ‚àßy = ‚ü®‚åú‚Üí‚åù, x, z‚ü©
(MP)
We also introduce ‚àÉ-introduction, EI, by
EI(x, y) ‚Üî(‚àÉu)<x(‚àÉv)<x(‚àÉz)<x(‚àÉi)<x

x = ‚ü®‚åú‚Üí‚åù, u, v‚ü©
‚àßWFF(u) = 0 ‚àßWFF(v) = 0
‚àßVar(z, i) ‚àßFree(i, v) > 0
‚àßy = ‚ü®‚åú‚Üí‚åù, ‚ü®‚åú‚àÉ‚åù, z, u‚ü©, v‚ü©

(EI)
We will use one more rule of inference in the deÔ¨Ånition of Proof below.
This rule, substitution of terms, is, of course a derived rule (I.4.12, p. 44),
but we acknowledge it explicitly for our future convenience (Lemma II.6.27 ‚Äì
via II.6.18 and II.6.20). Thus, we introduce SR. SR(x, y) holds if x = ‚åúA‚åù
and y = ‚åúA[vi ‚Üêt]‚åùfor some term t substitutable in vi:
SR(x, y)‚ÜîWFF(x) = 0 ‚àßWFF(y) = 0 ‚àß
(‚àÉi)‚â§x(‚àÉz)‚â§y(Term(z) = 0 ‚àßy = Sub(x, i, z))
(SR)

II.5. Arithmetization
271
II.5.1 Remark. In introducing MP, EI, and SRabove we have been consistent
with our deÔ¨Ånition of inference rules (I.3.15, p. 36) in that the rules act on
formulas.
It is technically feasible to have the rules act on any strings over our alphabet
instead‚Äìe.g.,viewmodusponensasactingonarbitrarystringsAand(A ‚ÜíB )
to produce the string B . Indeed the literature, by and large, takes this point of
view for the arithmetized versions above, deÔ¨Åning, for example MP‚Ä≤ just as
MP‚Ä≤(x, y, z) ‚Üîy = ‚ü®‚åú‚Üí‚åù, x, z‚ü©
(M P‚Ä≤)
Still, informally speaking, a proof built upon the primed versions of the rules of
inference is composed entirely of formulas‚Ä† ‚Äì as it should be ‚Äì for these rules
produce formulas if their inputs are all formulas, and, of course, a proof starts
with formulas (the axioms).
‚ñ°
We are ready to test for proofs. Fix a set of nonlogical axioms .
Suppose that we already have a formula Œì such that Œì(‚åúA‚åù) means ‚ÄúA ‚àà‚Äù.
Then, we may introduce the informal abbreviation Proof such that
Proof (x) holds if x = ‚ü®‚åúA1 ‚åù, ‚åúA2 ‚åù, . . . ‚ü©where A1, A2, . . . is some -
proof.
Proof (x) stands for Seq(x) ‚àßlh(x) > 0 ‚àß
(‚àÄi)<lh(x)(LA((x)i) ‚à®Œì((x)i) ‚à®
(‚àÉj)<i(‚àÉk)<i MP((x) j, (x)k, (x)i) ‚à®
(‚àÉj)<i EI((x) j, (x)i) ‚à®
(‚àÉj)<i SR((x) j, (x)i))
(Proof)
Note that this introduction of Proof is modulo , but most of the time we will
not indicate that dependence explicitly (e.g., as Proof ), since whatever  we
have in mind will be usually clear from the context.
G¬®odel‚Äôs theorem is about theories with a ‚Äúrecognizable‚Äù set of axioms, i.e.,
recursively axiomatized theories. However, it is also applicable if we take the
somewhat more general assumption that  is a semi-recursive set, which for-
mally means that we want the formula Œì to be Œ£1 over the language where
we effect our coding. Informally, this means that even if we cannot recognize
the axioms, nevertheless we can form an effective (algorithmic) listing of all of
them; G¬®odel‚Äôs results still hold for such theories.‚Ä°
‚Ä† As an easy informal induction on the length of proofs shows.
‚Ä° It is easy to see that the the set of theorems of a theory with a semi-recursive set of axioms is
also semi-recursive by closure of semi-recursive relations under (‚àÉy). This immediately opens
any such theory for arithmetic to the incompletableness phenomenon, since the set of all true
sentences is not semi-recursive.

272
II. The Second Incompleteness Theorem
The reader will note that PA is much ‚Äúsimpler‚Äù than semi-recursive. Indeed,
it is not hard to show that if  = PA, then the formula Œì is primitive recursive.‚Ä†
In this case, Œì(x) will be equivalent to a lengthy disjunction of cases. For
example, the case corresponding to axiom +1, z + 0 = z, is given by the (‚àÜ0)
formula
(‚àÉz)<x

var(z) ‚àßx = ‚ü®‚åú= ‚åù, ‚ü®‚åú+ ‚åù, z, 0‚ü©, z‚ü©

We leave the details to the reader (Exercise II.15).
II.6. Derivability Conditions; Fixed Points
In this section we will Ô¨Ånd a sentence in LN that says ‚ÄúI am not a theorem‚Äù.
We will also show that certain derivability conditions (the Ableitbarkeits-
forderungen,‚Ä° of Hilbert and Bernays (1968)) hold in some appropriate ex-
tension, C, of PA. These conditions talk about deducibility (derivability) in
appropriate consistent extensions  of PA. At the end of all this, to prove the
second incompleteness theorem becomes a comparatively easy matter.
We begin by assessing the success of our arithmetization. We have made
claims throughout Section II.5 about what each introduced predicate or function
meant intuitively. We want to make precise and substantiate such claims now,
although we will not exhaustively check every predicate and function that we
have introduced. Just a few spot checks of the most interesting cases will sufÔ¨Åce.
First off, we Ô¨Åx our attention on an arbitrary consistent extension,  of PA, over
some language LA, where Œì is Œ£1 over the language of C below.
We also Ô¨Åx an extension by deÔ¨Ånitions¬ß of PA, where all the predicates
and functions that we have introduced in our arithmetization along with their
deÔ¨Åning axioms, reside. We will use the symbol C (‚ÄúC‚Äù for Coding) for this
speciÔ¨Åc extension. The language of C will be denoted by LN C.
As a matter of fact, in the interest of avoiding circumlocutions ‚Äì in particular
when proving the Hilbert-Bernays DC 3 later on (II.6.34) ‚Äì we allow all the
primitive recursive function symbols (II.3.6, p. 253) to be in LN C and, corre-
spondingly, all the deÔ¨Åning axioms of those symbols (i.e., through composition,
primitive recursion, or, explicitly, as deÔ¨Ånitions of Z and U n
i ) to be included
in C.
‚Ä† Cf. II.3.6, p. 253.
‚Ä° The Ableitbarkeitsforderungen that we employ are close, but not identical, to the originals in
Hilbert and Bernays (1968). We have allowed some inÔ¨Çuence from L¬®ob‚Äôs modern derivability
conditions, which we also state and prove, essentially using the old Ableitbarkeitsforderungen
as stepping stones in the proof. Once we have L¬®ob‚Äôs conditions, we employ them to prove the
second incompleteness theorem.
¬ß Recall that extensions by deÔ¨Ånitions are conservative.

II.6. Derivability Conditions; Fixed Points
273
We note that C is a recursive extension of PA in the sense of p. 220, since
Proof (introduced in the previous section), and Deriv and Œò (p. 281 and
p. 280 below) are not introduced as predicates, but rather are introduced as
informal abbreviations.
Note that the languages LA and LN C may, a priori, extend the language
of PA, LN, in unrelated directions, since the former extension accommodates
whatever new nonlogical axioms are peculiar to , while the latter simply
accommodates symbols (beyond the basic symbols (N L) of p. 166) that are
introduced by deÔ¨Ånitions (see, however, II.6.32, p. 303). Thus,  may fail to be
a conservative extension of PA, unlike C.
When we write ‚Äú ‚ä¢‚Äù in this section, we mean ‚Äú ‚ä¢C‚Äù (or ‚Äú ‚ä¢C plus some
‚Äòtemporary‚Äô assumptions‚Äù, if a proof by deduction theorem, auxiliary constant,
etc., has been embarked upon). Exceptions will be noted.
The informal symbols ‚ÄúProof ‚Äù, ‚ÄúDeriv‚Äù, and ‚ÄúŒò‚Äù (the latter two to be in-
troduced shortly) will abbreviate ‚ÄúProof ‚Äù, ‚ÄúDeriv‚Äù, and ‚ÄúŒò‚Äù respectively.
Now (equipped with the tools of Sections I.8‚ÄìI.9 and II.3.6‚ÄìII.3.11) it is
easy to verify that all the atomic formulas and terms that we have introduced
in Section II.5, to ‚Äúrecognize speciÔ¨Åed sets of G¬®odel numbers‚Äù ‚Äì except for the
formula Proof , because of our assumptions on  ‚Äì are primitive recursive. For
atomic formulas this means that the corresponding characteristic terms‚Ä† are.
Pause. Is that so? How about the deÔ¨Ånition of Sub (p. 268)? It contains un-
bounded search.
In particular, the lightface versions of each such formula or term (e.g.,
Var(x, i), T erm(x), W F F(x)) ‚Äì i.e., the informal versions obtained by repli-
cating the formal deÔ¨Ånitions in the metatheory ‚Äì are in PR‚àóor PR. Applying
Theorem II.3.8 and its Corollary II.3.9, we have that the boldface version in
each case both deÔ¨Ånes semantically (in LNC) and strongly deÔ¨Ånes (in C) the
corresponding lightface version.
Since every G¬®odel number t is a closed primitive recursive term, II.3.10
implies that for any such t there is a unique n ‚ààN such that ‚ä¢t = n.
We can actually obtain a bit more: If we let, for the balance of this section, gn(E)
denote the informal (lightface) G¬®odel number of a term or formula E,‚Ä° ‚Äì that is,
a ‚Äúreal‚Äù number in N ‚Äì while ‚åúE‚åùcontinues to denote the formal version ‚Äì i.e.,
‚Ä† Cf. II.1.25 (p. 220) and p. 222.
‚Ä° An arbitrary term is generically denoted by t or s in the metalanguage; a formula, by a calli-
graphic uppercase letter such as A . The ‚ÄúE‚Äù here is a compromise notation that captures (in the
metalanguage) an arbitrary term or formula, that is, an arbitrary well-formed expression (string).

274
II. The Second Incompleteness Theorem
a closed term in LN C ‚Äì then (by II.3.8‚ÄìII.3.9)
‚ä¢‚åúE‚åù= 
gn(E)
(1)
To see why (1) is true, consider the G¬®odel numbering that we have developed
starting on p. 168. In the interest of clarity of argument, let us introduce the
functions fi (i = 1, . . . , 11) below ‚Äì as well as their lightface versions,
the latter (not shown) by the same (although lightface) deÔ¨Åning equations.
Note the deliberate choice of distinct variables vi (i = 1, . . . , 11):
f1(v1)
= ‚ü®0, v1‚ü©
f2(v2)
= ‚ü®0, v2‚ü©
f3(v3)
= ‚ü®0, v3‚ü©
f4(v4)
= ‚ü®0, v4‚ü©
f5(v5)
= ‚ü®0, v5‚ü©
f6(v6)
= ‚ü®0, v6‚ü©
f7(v7)
= ‚ü®0, v7‚ü©
f8(v8)
= ‚ü®0, v8‚ü©
f9(v9)
= ‚ü®0, v9‚ü©
f10(v10) = ‚ü®0, v10‚ü©
f11(v11) = ‚ü®0, v11‚ü©
Then any formal (respectively, informal) G¬®odel number ‚åúE‚åù(respectively,
gn(E)) is a closed instance of h[v1, . . . , v11] (respectively, of h[v1, . . . , v11])
for some appropriate formal (respectively, informal) primitive recursive h (re-
spectively, h). The closed instance is obtained in a speciÔ¨Åc way: Each vi (re-
spectively, each vi) is being replaced byi (respectively, i).
As we assume that the formal and informal deÔ¨Ånitions ‚Äútrack each other‚Äù ‚Äì
i.e., have identical primitive recursive derivations except for typeface ‚Äì then
h = hN C
(1‚Ä≤)
Now (1) translates to
‚ä¢h[1, . . . , 
11] = (h[1, . . . , 11])‚àº
where ‚Äò(h[1, . . . , 11])‚àº‚Äô denotes that ‚Äò‚àº‚Äô applies to all of ‚Äòh[1, . . . , 11]‚Äô; which
holds by (1‚Ä≤) and II.3.8.
II.6.1 A Very Long Example. It is trivial that, for any i ‚ààN, Var(gn(vi), i)
is true.‚Ä† Thus, both
|=N C Var( 
gn(vi),i)
‚Ä† Do you believe this? See II.4.14 for a discussion of such outrageous claims.

II.6. Derivability Conditions; Fixed Points
275
and
‚ä¢Var( 
gn(vi),i)
hold, for all i ‚ààN.‚Ä† By (1), p. 274, and Ax4,
|=N C Var(‚åúvi‚åù,i)
and
‚ä¢Var(‚åúvi‚åù,i)
hold for all i ‚ààN. From the last two and Ax2 follow, for all i ‚ààN,
|=N C var(‚åúvi‚åù)
and
‚ä¢var(‚åúvi‚åù)
Conversely, if ‚ä¢Var(n,i), then Var(n, i) is true by II.3.9, and therefore, tri-
vially, gn(vi) = n through examination of the lightface deÔ¨Ånition (Var) (iden-
tical to the boldface version given on p. 266). Hence
‚ä¢
gn(vi) = n
Thus (by (1), p. 274)
‚ä¢‚åúvi‚åù= n
(2)
In other words, ‚ä¢Var(n,i) implies that n is provably‚Ä° equal to the (formal)
G¬®odel number of the variable vi.
Similarly, ‚ä¢var(n) implies that n is provably equal to the formal G¬®odel
number of some variable.
We next verify that Term behaves as intended. Indeed, by induction on
terms, t, we can show in the metatheory that T erm(gn(t)) = 0 is true. For ex-
ample, if t = f t1 . . . tn, then the I.H. implies that T erm(gn(ti)) = 0 is true,
for i = 1, . . . , n. Given that gn(t) = ‚ü®gn( f ), gn(t1), . . . , gn(tn)‚ü©, and consult-
ing (Trm),¬ß we see that indeed, T erm(gn(t)) = 0 is true. The basis cases are
covered as easily. Thus (II.3.8),
‚ä¢Term(
gn(t)) = 0
‚Ä† We recall that the metasymboli denotes a (formal) term. On the other hand, i in vi is part of the
name.
‚Ä° In C.
¬ß This is the formal deÔ¨Ånition on p. 267. The informal deÔ¨Ånition is the lightface version of (Trm).

276
II. The Second Incompleteness Theorem
hence, by (1) and Ax4
‚ä¢Term(‚åút‚åù) = 0
Conversely, ‚ä¢Term(n) = 0 implies that T erm(n) = 0 is true. Now an infor-
mal (i.e., metamathematical) course-of-values induction on n easily shows that
n = gn(t) for some term t, and thus we obtain ‚ä¢‚åút‚åù= n, exactly as we have
obtained (2). For example, say that T erm(n) = 0 because the third disjunct‚Ä† in
the top case of the deÔ¨Ånition (Trm) (p. 267) is true, namely,
Seq(n) ‚àß(‚àÉy)<n(lh(n) = y + 1 ‚àßf unc((n)0, y)
‚àß(‚àÄz)<yT erm((n)z+1) = 0)
Let y = k < n be a value that works above, i.e., such that the following is true:
Seq(n) ‚àß(lh(n) = k + 1 ‚àßf unc((n)0, k) ‚àß(‚àÄz)<kT erm((n)z+1) = 0)
By the I.H.‚Ä° there are terms t1, . . . , tk such that gn(tz) = (n)z for z = 1, . . . , k.
Moreover, the truth of f unc((n)0, k) implies, analogously to the case of Var,
that there is a function symbol f , of arity k, such that gn( f ) = (n)0. Therefore,
n = ‚ü®(n)0, (n)1, . . . , (n)k‚ü©
= ‚ü®gn( f ), gn(t1), . . . , gn(tk)‚ü©
= gn( f t1 . . . tk)
We have veriÔ¨Åed that ‚ä¢Term(n) = 0 implies that n is provably equal to the
(formal) G¬®odel number of some term t.
One similarly veriÔ¨Åes that WFF behaves as intended. We next verify that
Free and Sub behave as intended.
Suppose that vi appears free in A. Referring to the lightface deÔ¨Ånition of
Free (which is structurally identical to (Fr), p. 267) and using induction on
A or t ‚Äì as the case may be ‚Äì it is easy to show that Free(i, gn(A)) = 0 or
(correspondingly) Free(i, gn(t)) = 0. Thus, one can prove (by (1) and II.3.8‚Äì
II.3.10)
‚ä¢Free(i, ‚åúA‚åù) = 0
or (correspondingly)
‚ä¢Free(i, ‚åút‚åù) = 0
Conversely, assume that ‚ä¢Free(i,n) = 0 for some i, n in N. Thus, Free(i, n) =
0 is true. A course-of-values induction on n (over N) shows that n = gn(E)
‚Ä† A disjunct is a member of a disjunction.
‚Ä° ‚ÄúIf Seq(n), then i < lh(n) ‚Üí(n)i < n‚Äù is crucial here.

II.6. Derivability Conditions; Fixed Points
277
(where E is some term or formula) and vi is free in E. For example, if
Free(i, n) = 0 is true because the last disjunct in (Fr) (p. 267) obtains, namely,
W F F(n) = 0 ‚àß(n)0 = gn(‚àÉ) ‚àß¬¨Var((n)1, i) ‚àßFree(i, (n)2) = 0
then the behaviour of W F F ensures that, for some formula A,
n = gn(A)
(i)
Moreover (by (i) and properties of W F F), n = ‚ü®(n)0, (n)1, (n)2‚ü©; hence for
some j ‚ààN and formula B ,
(n)2 = gn(B ), (n)1 = gn(vj)
and
A ‚â°((‚àÉvj)B )
By ¬¨Var((n)1, i), we have i Ã∏= j. By I.1.10 and the I.H. (by which the conjunct‚Ä†
Free(i, (n)2) = 0 ensures that vi is free in B ) it follows that vi is free in A.
Thus, by (1) (p. 274) and (i), ‚ä¢‚åúA‚åù= n in this case, and hence (by assumption
and Ax4)
‚ä¢Free(i, ‚åúA‚åù) = 0
All in all, using (1) for the if part,
vi is free in t
iff
‚ä¢Free(i, ‚åút‚åù) = 0
vi is free in A
iff
‚ä¢Free(i, ‚åúA‚åù) = 0
Turning now to Sub, we validate the claims made on p. 268.
Let at Ô¨Årst t and s be terms. It is easy (metamathematical induction on t) to
see that
Sub(gn(t), i, gn(s)) = gn(t[vi ‚Üês])
(3)
is true. Indeed (sampling the proof), let t ‚â°f t1 . . . tn. Referring to the deÔ¨Åni-
tion of Sub (mirrored on p. 268 for the boldface case), we obtain
Sub(gn(t), i, gn(s)) = ‚ü®gn( f ), Sub(gn(t1), i, gn(s)), . . . ,
Sub(gn(tn), i, gn(s))‚ü©
Using the I.H. on t, the above translates to
Sub(gn(t), i, gn(s)) = ‚ü®gn( f ), gn(t1[vi ‚Üês]), . . . , gn(tn[vi ‚Üês])‚ü©
Since gn(t[vi ‚Üês]) = ‚ü®gn( f ), gn(t1[vi ‚Üês]), . . . , gn(tn[vi ‚Üês])‚ü©, (3)
follows.
‚Ä† A conjunct is a member of a conjunction.

278
II. The Second Incompleteness Theorem
Let next A be a formula, and s be a term substitutable for vi in A. By
induction on A we can show in the metatheory that
Sub(gn(A), i, gn(s)) = gn(A [vi ‚Üês])
(4)
is true. Sampling the proof of (4), let us consider an interesting case, namely,
A ‚â°(‚àÉvj)B , where i Ã∏= j. By the I.H. on formulas,
Sub(gn(B ), i, gn(s)) = gn(B [vi ‚Üês])
(5)
By I.3.10‚ÄìI.3.11, A[vi ‚Üês] ‚â°(‚àÉvj)(B [vi ‚Üês]). Thus,
gn(A [vi ‚Üês]) = ‚ü®gn(‚àÉ), gn(vj), gn(B [vi ‚Üês])‚ü©
(6)
By the deÔ¨Ånition of Sub,
Sub(gn(A), i, gn(s)) = ‚ü®gn(‚àÉ), gn(vj), Sub(gn(B ), i, gn(s))‚ü©
Thus, (5) and (6), yield (4).
Here is the other interesting case, where A is a formula, and s is a term that
is not substitutable for vi in A. By induction on A we can show this time that
Sub(gn(A), i, gn(s)) = 0
(7)
We just sample the same case as above. First off, for any term or formula E,
gn(E) > 0.
Pause. Do you believe this?
Consider Ô¨Årst the subcase where A ‚â°(‚àÉvj)B , and s is substitutable for vi in
B . By (4), Sub(gn(B ), i, gn(s)) = gn(B [vi ‚Üês]) > 0.
Now, by assumption of non-substitutability for vi in A, it must be that vj
is free in s. Thus, the relevant condition for the deÔ¨Ånition of Sub (this is the
second from last condition, p. 268) fails, since Free( j, gn(s)) = 0. Therefore
the deÔ¨Ånition (of Sub) returns 0 (the ‚Äúotherwise‚Äù), and (7) is correct in this
subcase.
The remaining subcase is that substitutability of s failed earlier, that is
(I.H.), Sub(gn(B ), i, gn(s)) = 0. Still, the relevant condition in the deÔ¨Åni-
tion of Sub is the second from last. It fails once more, since the conjunct
‚ÄúSub(gn(B ), i, gn(s)) > 0‚Äù is false. Therefore,
Sub(gn(A), i, gn(s)) > 0
iff
the term s is substitutable for vi in A

II.6. Derivability Conditions; Fixed Points
279
We translate the above, as well as (3) and (4), to the formal domain us-
ing (1) (p. 274) and II.3.8‚ÄìII.3.9:
‚ä¢Sub(‚åúA ‚åù,i, ‚åús‚åù) > 0
iff
the term s is substitutable for vi in A
‚ä¢Sub(‚åút[vi]‚åù,i, ‚åús‚åù) = ‚åút[s]‚åù
‚ä¢Sub(‚åúA[vi]‚åù,i, ‚åús‚åù) = ‚åúA[s]‚åù
if the term s is substitutable for vi in A
The claims regarding subi (p. 268) are trivial consequences of the above.
We Ô¨Ånally check Proof .
Turning to the lightface version (see p. 271 for the boldface version), let
n = ‚ü®gn(A0), . . . , gn(Ak‚àí1)‚ü©, where k > 0 and A0, . . . , Ak‚àí1 is a -proof.
Assume that Œì(x) (and hence (x)) is primitive recursive, an assumption that
is correct in the case of PA (Exercise II.15)
That Seq(n), and lh(n) = k > 0, is true outright. To see that Proof (n) is
true we now only need to investigate (n)i for i < k and verify that it satisÔ¨Åes
L A((n)i) ‚à®((n)i) ‚à®(‚àÉj)<i(‚àÉm)<i M P((n) j, (n)m, (n)i) ‚à®
(‚àÉj)<i E I((n) j, (n)i) ‚à®(‚àÉj)<i SR((n) j, (n)i)
(8)
Now, (n)i = gn(Ai), for i < k. The following exhaust all cases:‚Ä†
Case 1. Ai ‚àà ‚à™. Then the Ô¨Årst or second disjunct of (8) is true.
Case 2. Forsome j < i andm < i,onehasAm ‚â°A j ‚ÜíAi.Then M P((n) j,
(n)m, (n)i) is true.
Case 3. For some j < i, one has A j ‚â°B ‚ÜíC , x is not free in C , and
Ai ‚â°(‚àÉx)B ‚ÜíC . Then E I((n) j, (n)i) is true.
Case 4. For some j < i, and some variable x and term t substitutable for x in
A j, one has Ai ‚â°A j[x ‚Üêt]. Then SR((n) j, (n)i) is true.
Thus, (8) is true under all possible cases.
Conversely, one can show by (metamathematical) course-of-values induc-
tion on lh(n) that if Proof (n) is true, then there is a -proof A0, . . . , Ak‚àí1,
wherek =lh(n) > 0,suchthatn = ‚ü®gn(A0), . . . , gn(Ak‚àí1)‚ü©.Notethattruthof
Proof (n) guarantees the truth of Seq(n) and lh(n) > 0 (deÔ¨Ånition of Proof ).
Suppose that k = 1 (basis). Then the only disjuncts that can be true in (8) are
the Ô¨Årst two (why?). If the Ô¨Årst one holds, then this implies that (n)0 = gn(B )
for some formula B ‚àà (see (L A), p. 270); if the second one holds, then
(n)0 = gn(B ) for some formula B ‚àà (hence, in either case, the one-member
sequence ‚ÄúB ‚Äù ‚Äì which we may want to rename ‚ÄúA0‚Äù ‚Äì is a -proof). The reader
‚Ä† Recall that we have agreed to allow the redundant substitution rule (p. 270).

280
II. The Second Incompleteness Theorem
will have no difÔ¨Åculty completing the induction. By the primitive recursiveness
of Proof ‚Ä† and II.3.9,
Proof (n) is true
iff
‚ä¢Proof (n)
(9)
In particular, if A0, . . . , Ak‚àí1 is some -proof and we set
n = ‚ü®gn(A0), . . . , gn(Ak‚àí1)‚ü©
and also set
t = ‚ü®‚åúA0‚åù, . . . , ‚åúAk‚àí1‚åù‚ü©
‚Äì the (formal) G¬®odel number of the proof ‚Äì then ‚ä¢t = n. Since Proof (n) is
true, (9) yields ‚ä¢Proof (n); hence
‚ä¢Proof (t)
Now, noting that Proof N C = Proof , the only-if direction of (9) also holds
for our Œ£1 Œì (by II.4.12). Thus, the claim we made above, ‚ÄúIn particular, if
A0, . . . , Ak‚àí1 is, etc.‚Äù, still holds without the restriction to a primitive recursive
Œì. Is the if direction still true?
‚ñ°
II.6.2 DeÔ¨Ånition (The Provability Predicate). The informal abbreviation Œò
introduced below is called the provability predicate:
Œò(x) stands for (‚àÉy)(Proof (y) ‚àß(‚àÉi)<lh(y)x = (y)i)
‚ñ°
II.6.3 Remark. (1) The deÔ¨Ånition of Œò and the use of the term ‚Äúprovability
formula‚Äù is modulo a Ô¨Åxed set of nonlogical axioms . We have already Ô¨Åxed
attention on such a set, but our attention may shift to other sets, ‚Ä≤, ‚Ä≤‚Ä≤, etc., on
occasion. All that is required is to observe that:
r Any such primed  is a consistent extension of PA.
r The corresponding predicate, Œì, is Œ£1 over the language of C, LN C,
where all the symbols (and more) that we use for G¬®odel coding belong.
(2) Note that we did not require x to be the last formula in the ‚Äúproof‚Äù y.
‚Ä† We have cheated here and allowed ‚Äì for the purpose of this informal veriÔ¨Åcation ‚Äì the ‚Äúlocal‚Äù
assumption that Œì is primitive recursive. Recall that our ‚Äúglobal‚Äù assumption on Œì ‚Äì the one
operative throughout this section, outside this example ‚Äì is that it is a Œ£1 formula. In this
connection the reader should note the concluding sentence of this example.

II.6. Derivability Conditions; Fixed Points
281
(3) Œò(x) is in Œ£1(LNC).
(4) From the work in the previous example we see that Œò(x) intuitively says
that x is the G¬®odel number of some theorem. More precisely, if  ‚ä¢A (A is
over ‚Äôs language) and we set t = ‚åúA‚åù(and also n = gn(A)), then Œò(n) is
a true Œ£1(LNC) sentence. By II.4.12,
‚ä¢Œò(n)
Hence (by ‚ä¢t = n)
‚ä¢Œò(t)
The reader is reminded that ‚Äú‚ä¢‚Äù means ‚Äú‚ä¢C‚Äù unless noted otherwise.
(5) The preceding discussion completes the (sketch of) proof of I.9.33 given
on p. 177. That is, that the lightface version of Œò(x), (x), is semi-recursive.
A number of issues that were then left open (e.g., the recursiveness of  and
of the rules I1 and I2) have now been settled.
(6) It is useful to introduce an informal abbreviation for
Proof (y) ‚àß(‚àÉi)<lh(y)x = (y)i
We will use the name Deriv introduced by
Deriv(y, x) stands for Proof (y) ‚àß(‚àÉi)<lh(y)x = (y)i
That is, Deriv(y, x) intuitively says that the proof (coded by) y derives the
theorem (coded by) x.
‚ñ°
In the following lemmata we ‚Äúdo‚Äù some of the metatheory of arithmetic
within formal arithmetic, having arithmetized the language. For example, the
Ô¨Årst lemma says that if we substitute a term into some variable of another term,
then we obtain a term. The chapter concludes with a proof (second incomplete-
ness theorem) that we cannot ‚Äúdo‚Äù all the metatheory within the theory.
II.6.4 Lemma.
‚ä¢Term(x) = 0 ‚àßTerm(z) = 0 ‚ÜíTerm(Sub(x, i, z)) = 0
Proof. We do this proof in some detail, since in most others in the following
sequence of lemmata, we delegate much of the burden of proof to the reader.
(Warning: This proof will be rather pedantic.)

282
II. The Second Incompleteness Theorem
We do (formal) course-of-values induction (II.1.23, p. 214) on x, proceeding
according to the deÔ¨Ånition of Term (p. 267). The latter yields (cf. (9), p. 221)
‚ä¢Term(x) = 0 ‚Üîvar(x) ‚à®x = ‚ü®0, S0‚ü©
‚à®Seq(x) ‚àß(‚àÉy)<x(lh(x) = Sy
‚àßf unc((x)0, y) ‚àß(‚àÄz)<yTerm((x)Sz) = 0)
(1)
Now assume
Term(x) = 0
and
Term(z) = 0
(2)
and prove
Term(Sub(x, i, z)) = 0
(3)
We have cases according to (1):
Case of var(x):
Thus (p. 266) ‚ä¢(‚àÉj)‚â§xVar(x, j). We may now add a
new constant a and the assumption
a ‚â§x ‚àßVar(x, a)
The subcase a = i and the deÔ¨Ånition of Sub, (Ô¨Årst case; cf. also the deÔ¨Ånition
by cases in (15), p. 221) yield
‚ä¢Sub(x, i, z) = z
(4)
Similarly, the (only other) subcase, ¬¨ a = i, and the deÔ¨Ånition of Sub (third
case) yield
‚ä¢Sub(x, i, z) = x
(5)
Either of (4) or (5) yields (3) because of (2), and we are done in this case.
Pause. In the last subcase I used (tacitly) the ‚Äúfact‚Äù that
‚ä¢Var(x, a) ‚Üí¬¨ a = i ‚Üí¬¨Var(x, i)
Is this indeed a fact? (Hint. lh.)
Case of x = ‚ü®0, S0‚ü©:
The deÔ¨Ånition of Sub (second case) yields (5), and
once again we have derived (3) from (2).
Finally the hard case, that is, that of the third disjunct in (1) above:
Seq(x)‚àß(‚àÉy)<x(lh(x) = Sy
‚àßf unc((x)0, y) ‚àß(‚àÄz)<yTerm((x)Sz) = 0)
(hc)

II.6. Derivability Conditions; Fixed Points
283
By (hc) we have
‚ä¢Seq(x)
(6)
and we may also introduce a new constant b and the assumption
b < x ‚àßlh(x) = Sb
‚àßf unc((x)0, b) ‚àß(‚àÄz)<bTerm((x)Sz) = 0
(7)
On the other hand, the deÔ¨Ånition of Sub (fourth case) and (2) (cf. (15), p. 221)
yields
‚ä¢Sub(x, i, z) = (¬µw)(Seq(w) ‚àßlh(w) = lh(x) ‚àß(w)0 = (x)0 ‚àß
(‚àÄy)<lh(x)(y > 0 ‚Üí(w)y = Sub((x)y, i, z)))
(8)
Using the abbreviation t = Sub(x, i, z) for convenience, we get from (8) via
( f (4)) (p. 218)
‚ä¢Seq(t)
(9)
‚ä¢lh(t) = lh(x)
(10)
‚ä¢(t)0 = (x)0
(11)
and
‚ä¢(‚àÄy)<lh(x)(y > 0 ‚Üí(t)y = Sub((x)y, i, z))
(12)
By (6) and II.2.13
‚ä¢y < lh(x) ‚Üí(x)y < x
(13)
Now (7) yields
‚ä¢(‚àÄz)<lh(x)(z > 0 ‚ÜíTerm((x)z) = 0)
Thus (12) and (13) ‚Äì via the I.H. ‚Äì yield
‚ä¢(‚àÄy)<lh(x)(y > 0 ‚ÜíTerm((t)y) = 0)
(14)
that is, reintroducing b (see (7)),
‚ä¢(‚àÄy)<bTerm((t)Sy) = 0
(14‚Ä≤)
By (7), (14‚Ä≤), (10), and (11) we now have
‚ä¢lh(t) = Sb
‚àßf unc((t)0, b) ‚àß(‚àÄy)<bTerm((t)Sy) = 0

284
II. The Second Incompleteness Theorem
Since ‚ä¢lh(t) ‚â§t by II.2.4(i), and therefore ‚ä¢b < t by the Ô¨Årst conjunct of
the above, we obtain
‚ä¢b < t ‚àßlh(t) = Sb
‚àßf unc((t)0, b) ‚àß(‚àÄy)<bTerm((t)Sy) = 0
Hence, using a new variable z, Ax2, and (9),
‚ä¢Seq(t) ‚àß(‚àÉz)<t(lh(t) = Sz
‚àßf unc((t)0, z

‚àß(‚àÄy)<zTerm((t)Sy) = 0)
(15)
By the deÔ¨Ånition of Term, ‚ä¢Term(t) = 0 follows immediately from (15). ‚ñ°
The above result (and the following suite of similar results) is much easier to
prove if instead of free variables we have numerals. We just invoke II.3.8‚ÄìII.3.9.
However, we do need the versions with free variables.
The following says that a term is substitutable into any variable of another
term.‚Ä†
II.6.5 Corollary.
‚ä¢Term(x) = 0 ‚àßTerm(z) = 0 ‚ÜíSub(x, i, z) > 0
Proof. Assume the hypothesis (to the left of ‚Äú‚Üí‚Äù). Then (lemma above)
‚ä¢Term(Sub(x, i, z)) = 0
(1)
Now
‚ä¢Term(x) = 0 ‚ÜíSeq(x) ‚àßlh(x) > 0
by inspection of the cases involved in the deÔ¨Ånition of Term (see (1) in the
previous proof). By II.2.13,
‚ä¢Seq(x) ‚àßlh(x) > 0 ‚Üíx > (x)0
Thus, by II.1.5 and II.1.6,
‚ä¢Term(x) = 0 ‚Üíx > 0
(2)
By substitution from (1), and (2), we have ‚ä¢Sub(x, i, z) > 0.
‚ñ°
‚Ä† By a variable of a term we understand any variable ‚Äì hence the free i in the corollary statement ‚Äì
not only one that actually occurs in the term. That is, we mean a variable x of t in the sense t[x].

II.6. Derivability Conditions; Fixed Points
285
II.6.6 Lemma. ‚ä¢Term(x) = 0 ‚àßFree(i, x) = 0 ‚ÜíSub(x, i, z) ‚â•z.
Proof. Assume the hypothesis, i.e.,
Term(x) = 0
and
Free(i, x) = 0
We do (formal) course-of-values induction on x. By the deÔ¨Ånition of Free
(p. 267), we have just two cases to consider. Here is why, and what:
In principle, we have the three cases as in the proof of II.6.4. However, the
Ô¨Årst case considered in II.6.4 has here only its Ô¨Årst subcase tenable, namely,
where a = i. This is because the other subcase ‚Äì ¬¨a = i ‚Äì implies as before
‚ä¢var(x) ‚àß¬¨Var(x, i). Now this forces ‚ä¢Free(i, x) = S0, for if we have
‚ä¢var(x), then ‚ä¢(x)0 = 1; hence we cannot have any of ‚ä¢(‚àÉy)<x f unc((x)0,
y),‚Ä† ‚ä¢AF(x), or ‚ä¢WFF(x) = 0.
Thus, (4) of the proof of II.6.4 holds.
The second case in the proof of II.6.4, namely, x = ‚ü®0, S0‚ü©is also untenable
as before (see (Fr), p. 267), since here ‚ä¢(x)0 = 0.
This leaves the hard case (hc), which yields (8) of the proof of II.6.4, namely,
‚ä¢Sub(x, i, z) = (¬µw)
%
Seq(w) ‚àßlh(w) = lh(x) ‚àß(w)0 = (x)0
‚àß(‚àÄy)<lh(x)(y > 0 ‚Üí(w)y = Sub((x)y, i, z))
&
Thus, by ( f (4)) (p. 218), tautological implication, and eliminating ‚àÄ,
‚ä¢0 < y ‚àßy < lh(x) ‚Üí(Sub(x, i, z))y = Sub((x)y, i, z)
(1)
The deÔ¨Ånition of Free (p. 267) yields
‚ä¢(‚àÉy)<lh(x)(0 < y ‚àßFree(i, (x)y) = 0)
Invoking proof by auxiliary constant, we now add
0 < a ‚àßa < lh(x) ‚àßFree(i, (x)a) = 0
(2)
where a is a new constant. By (2) (Ô¨Årst two conjuncts) and (1),
‚ä¢(Sub(x, i, z))a = Sub((x)a, i, z)
(3)
Now, since (cf. (Trm), p. 267)
‚ä¢Term(x) = 0 ‚Üí(‚àÄz)<lh(x)(0 < z ‚ÜíTerm((x)z) = 0)
‚Ä† Since ‚ä¢lh((x)0) ‚â§(x)0 and (see (Func), p. 266) ‚ä¢lh((x)0) ‚â•6.

286
II. The Second Incompleteness Theorem
we obtain by hypothesis and specialization
‚ä¢0 < a ‚àßa < lh(x) ‚ÜíTerm((x)a) = 0
Thus
‚ä¢Term((x)a) = 0
(4)
via the Ô¨Årst two conjuncts of (2). Using now (2) (last conjunct), (4), and the
I.H. ‚Äì this uses II.2.13 ‚Äì we get
‚ä¢Sub((x)a, i, z) ‚â•z
(5)
Since ‚ä¢Seq(Sub(x, i, z)), II.2.13 yields
‚ä¢Sub(x, i, z) > (Sub(x, i, z))a
By (3) and (5) we now have ‚ä¢Sub(x, i, z) > z.
‚ñ°
The next three claims (stated without proof, since their proofs are trivial
variations of the preceding three) take care of atomic formulas.
II.6.7 Lemma.
‚ä¢AF(x) ‚àßTerm(z) = 0 ‚ÜíAF(Sub(x, i, z)) = 0
II.6.8 Corollary.
‚ä¢AF(x) ‚àßTerm(z) = 0 ‚ÜíSub(x, i, z) > 0
II.6.9 Lemma. ‚ä¢AF(x) ‚àßFree(i, x) = 0 ‚ÜíSub(x, i, z)‚â•z.
For the next result we want to ensure that a substitution actually took place
(hence the condition on substitutability, ‚ÄúSub(x, i, z) > 0‚Äù, which was unnec-
essary in the cases of term or atomic formula targets).
II.6.10 Proposition.
‚ä¢Term(x) = 0 ‚à®WFF(x) = 0 ‚Üí
Sub(x, i, z) > 0 ‚àßFree(i, x) = 0 ‚ÜíSub(x, i, z) ‚â•z
Proof. The case for Term(x) = 0 is II.6.6 above. The subcase AF(x) for
WFF(x) = 0 is II.6.9 (for either of these the assumption Sub(x, i, z) > 0
is redundant).

II.6. Derivability Conditions; Fixed Points
287
We consider here one among the other subcases of WFF(x) = 0. Once
again, we employ course-of-values induction on x, legitimized by II.2.13.‚Ä† Add
then the assumptions WFF(x) = 0, Sub(x, i, z) > 0 and Free(i, x) = 0.
Subcase.
x = ‚ü®‚åú‚à®‚åù, (x)S0, (x)SS0‚ü©. Thus (deÔ¨Ånition of WFF, p. 267)
‚ä¢WFF((x)S0) = 0
and
‚ä¢WFF((x)SS0) = 0
By the deÔ¨Ånition of Free (p. 267) we now have
‚ä¢Free(i, (x)S0) = 0 ‚à®Free(i, (x)SS0) = 0
(1)
By deÔ¨Ånition of Sub we obtain
‚ä¢Sub(x, i, z) = ‚ü®‚åú‚à®‚åù, Sub((x)S0, i, z), Sub((x)SS0, i, z)‚ü©
(2)
Pause. Wait a minute! The above is so provided that
‚ä¢Sub((x)S0, i, z) > 0 ‚àßSub((x)SS0, i, z) > 0
Is this satisÔ¨Åed? Why?
By (1), we consider cases. So add Free(i, (x)S0) = 0. The I.H. and
‚ä¢Sub((x)S0, i, z) > 0 yield
‚ä¢Sub((x)S0, i, z) ‚â•z
and hence
‚ä¢Sub(x, i, z) ‚â•z
exactly as in II.6.6, invoking ‚ä¢‚ü®. . . , u, . . . ‚ü©> u. The other case works out
as well.
‚ñ°
II.6.10 justiÔ¨Åes the bound of the existential quantiÔ¨Åers in the deÔ¨Ånition of SR
(p. 270).
II.6.11 Lemma.
‚ä¢WFF(x) = 0 ‚àßTerm(z) = 0 ‚àßSub(x, i, z) > 0 ‚Üí
WFF(Sub(x, i, z)) = 0
‚Ä† This is the last time we are reminded of the role of II.2.13 in our inductions on G¬®odel numbers.

288
II. The Second Incompleteness Theorem
Proof. We add the assumptions
WFF(x) = 0
Term(z) = 0
and
Sub(x, i, z) > 0
(1)
and do (formal) course-of-values induction on x, proceeding according to the
deÔ¨Ånition of WFF (p. 267), towards proving
‚ä¢WFF(Sub(x, i, z)) = 0
We illustrate what is involved by considering one case, leaving the rest to the
reader.
Case ‚Äú¬¨‚Äù.
x = ‚ü®‚åú¬¨‚åù, y‚ü©and ‚ä¢WFF(y) = 0, where we have used the
abbreviation y = (x)S0 for convenience.
We also add the assumption (which we hope to contradict)
Sub(y, i, z) = 0
Thus,
‚ä¢¬¨Sub(y, i, z) > 0
and therefore, via tautological implication and Ax4 (since ‚ä¢(x)S0 = y),
‚ä¢¬¨(WFF(x) = 0 ‚àß(x)0 = ‚åú¬¨‚åù‚àßSub((x)S0, i, z) > 0)
Thus, the ‚Äúotherwise‚Äù‚Ä† in the deÔ¨Ånition of Sub (p. 268) is provable, since
(x)0 = ‚åú¬¨‚åùis refutable in all the other cases. Therefore, ‚ä¢Sub(x, i, z) = 0,
contradicting the assumption (1).
We have just established
‚ä¢Sub(y, i, z) > 0
Hence also (deÔ¨Ånition of Sub)
‚ä¢Sub(x, i, z) = ‚ü®‚åú¬¨‚åù, Sub(y, i, z)‚ü©
(2)
By I.H.,
‚ä¢WFF(Sub(y, i, z)) = 0
‚Ä† That is, the conjunction of the negations of all the explicit cases.

II.6. Derivability Conditions; Fixed Points
289
Hence, by the deÔ¨Ånition of WFF,
‚ä¢WFF(‚ü®‚åú¬¨‚åù, Sub(y, i, z)‚ü©) = 0
Thus
‚ä¢WFF(Sub(x, i, z)) = 0
by (2) and Ax4.
‚ñ°
Pause. Where was the assumption Term(z) = 0 used?
II.6.12 Lemma.
‚ä¢(‚àÄj) Free( j, z) > 0 ‚àßTerm(z) = 0 ‚àß
WFF(x) = 0 ‚ÜíSub(x, i, z) > 0
This says that closed terms are always substitutable.
Proof. We assume
(‚àÄj)Free( j, z) > 0
Term(z) = 0
and
WFF(x) = 0
and do (formal) course-of-values induction on x proceeding according to the
deÔ¨Ånition of WFF to show
‚ä¢Sub(x, i, z) > 0
We illustrate what is involved by considering one case, leaving the remaining
cases to the reader.
Case ‚Äú‚àÉ‚Äù.
Add x = ‚ü®‚åú‚àÉ‚åù, y, w‚ü©, WFF(w) = 0, and var(y), where we
have used the abbreviations y = (x)S0 and w = (x)SS0 for convenience. The
latter expands to (see (var), p. 266)
‚ä¢(‚àÉj)‚â§yVar(y, j)
(3)
Assume Ô¨Årst the interesting subcase.
Subcase.
Add ¬¨Var(y, i). By (3) we may add a new constant a and the
assumption
a ‚â§y ‚àßVar(y, a)
(4)

290
II. The Second Incompleteness Theorem
By ‚ä¢(‚àÄj)Free( j, z) > 0
‚ä¢Free(a, z) > 0
Hence by (4) and Ax2
‚ä¢(‚àÉj)‚â§y(Var(y, j) ‚àßFree( j, z) > 0)
By the I.H. ‚ä¢Sub(w, i, z) > 0; hence (deÔ¨Ånition of Sub)
‚ä¢Sub(x, i, z) = ‚ü®‚åú‚àÉ‚åù, y, Sub(w, i, z)‚ü©
Thus, ‚ä¢Sub(x, i, z) > 0 (e.g., ‚ä¢Sub(x, i, z) > ‚åú‚àÉ‚åù).
Subcase.
Add Var(y, i). Now
‚ä¢Sub(x, i, z) = x
Therefore, once more, ‚ä¢Sub(x, i, z) > 0. (Why is ‚ä¢x > 0?)
‚ñ°
II.6.13 Lemma. ‚ä¢Proof (x) ‚àßProof (y) ‚ÜíProof (x ‚àóy).
Proof. Assume Proof (x) and Proof (y). Thus,
‚ä¢Seq(x) ‚àßlh(x) > 0 ‚àß
(‚àÄi)<lh(x)(LA((x)i) ‚à®Œì((x)i) ‚à®
(‚àÉj)<i(‚àÉk)<i MP((x) j, (x)k, (x)i) ‚à®
(‚àÉj)<i EI((x) j, (x)i) ‚à®
(‚àÉj)<i SR((x) j, (x)i))
(1)
and
‚ä¢Seq(y) ‚àßlh(y) > 0 ‚àß
(‚àÄi)<lh(y)(LA((y)i) ‚à®Œì((y)i) ‚à®
(‚àÉj)<i(‚àÉk)<i MP((y) j, (y)k, (y)i) ‚à®
(‚àÉj)<i EI((y) j, (y)i) ‚à®
(‚àÉj)<i SR((y) j, (y)i))
(2)
By II.2.21 (p. 247) we have
‚ä¢Seq(x ‚àóy)
‚ä¢lh(x ‚àóy) = lh(x) + lh(y)
(3)
Hence
‚ä¢Seq(x ‚àóy) ‚àßlh(x ‚àóy) > 0
(4)

II.6. Derivability Conditions; Fixed Points
291
(4) settles the Ô¨Årst two conjuncts of Proof (x ‚àóy). We now address the last
conjunct, (‚àÄi)<lh(x‚àóy)(LA((x ‚àóy)i) ‚à®. . . ). It sufÔ¨Åces to drop the quantiÔ¨Åer
and show
‚ä¢i < lh(x ‚àóy) ‚Üí
LA((x ‚àóy)i) ‚à®Œì((x ‚àóy)i)‚à®
(‚àÉj)<i(‚àÉk)<i MP((x ‚àóy) j, (x ‚àóy)k, (x ‚àóy)i) ‚à®
(‚àÉj)<i EI((x ‚àóy) j, (x ‚àóy)i) ‚à®
(‚àÉj)<i SR((x ‚àóy) j, (x ‚àóy)i)
(5)
We note, again by II.2.21,
‚ä¢(‚àÄi)<lh(x)(x ‚àóy)i = (x)i ‚àß
(‚àÄi)<lh(y)(x ‚àóy)i+lh(x) = (y)i
(6)
To prove (5), add i < lh(x ‚àóy). By (3) and (6) we have two cases.
Case 1.
i < lh(x). By (1) and (6) (Ô¨Årst conjunct) we obtain (using Ax4)
‚ä¢LA((x ‚àóy)i) ‚à®Œì((x ‚àóy)i) ‚à®
(‚àÉj)<i(‚àÉk)<i MP((x ‚àóy) j, (x ‚àóy)k, (x ‚àóy)i) ‚à®
(‚àÉj)<i EI((x ‚àóy) j, (x ‚àóy)i) ‚à®
(‚àÉj)<i SR((x ‚àóy) j, (x ‚àóy)i)
(7)
Case 2.
i ‚â•lh(x). Setting m = Œ¥(i,lh(x)), we get ‚ä¢m + lh(x) = i
(cf. II.1.27) and ‚ä¢m < lh(y) (using (3)). By (2),
‚ä¢LA((y)m) ‚à®Œì((y)m) ‚à®
(‚àÉj)<m(‚àÉk)<mMP((y) j, (y)k, (y)m) ‚à®
(‚àÉj)<mEI((y) j, (y)m) ‚à®
(‚àÉj)<mSR((y) j, (y)m)
Hence, bringing in (6) (second conjunct) via Ax4 and noting that ‚ä¢j < m ‚Üí
j < lh(y), we get
‚ä¢LA((x ‚àóy)m+lh(x)) ‚à®Œì((x ‚àóy)m+lh(x)) ‚à®
(‚àÉj)<m(‚àÉk)<mMP((x ‚àóy) j+lh(x), (x ‚àóy)k+lh(x), (x ‚àóy)m+lh(x)) ‚à®
(‚àÉj)<mEI((x ‚àóy) j+lh(x), (x ‚àóy)m+lh(x)) ‚à®
(‚àÉj)<mSR((x ‚àóy) j+lh(x), (x ‚àóy)m+lh(x))
Translating the above (via proof by cases) in terms of i, we obtain (7) once
more.

292
II. The Second Incompleteness Theorem
To sample one case, we translate the last disjunct. We claim that
‚ä¢(‚àÉj)<mSR((x ‚àóy) j+lh(x), (x ‚àóy)m+lh(x)) ‚Üí
(‚àÉj)<i SR((x ‚àóy) j, (x ‚àóy)i)
Assume the hypothesis, and add a new constant a and the assumption
a < m ‚àßSR((x ‚àóy)a+lh(x), (x ‚àóy)m+lh(x))
By II.1.17, ‚ä¢a + lh(x) < m + lh(x), that is, a + lh(x) < i. The above now
yields
a + lh(x) < i ‚àßSR((x ‚àóy)a+lh(x), (x ‚àóy)i)
Hence (Ax2)
‚ä¢(‚àÉj)( j < i ‚àßSR((x ‚àóy) j, (x ‚àóy)i))
After all this, the deduction theorem establishes (5).
‚ñ°
II.6.14 Lemma.
‚ä¢Proof (w) ‚àß(‚àÉj)<lh(w)(‚àÉk)<lh(w)MP((w) j, (w)k, x)
‚ÜíProof

w ‚àó‚ü®x‚ü©

Proof. Assume
Proof (w)
(8)
and
(‚àÉj)<lh(w)(‚àÉk)<lh(w)MP((w) j, (w)k, x)
(9)
and set t = w ‚àó‚ü®x‚ü©. Since ‚ä¢Seq(t) ‚àßlh(t) = S(lh(w)), the Ô¨Årst two required
conjuncts for Proof (w ‚àó‚ü®x‚ü©) are settled. To conclude, we add i < lh(t), that
is (< 2) i < lh(w) ‚à®i = lh(w), and prove
‚ä¢LA((t)i) ‚à®Œì((t)i) ‚à®
(‚àÉj)<i(‚àÉk)<i MP((t) j, (t)k, (t)i) ‚à®
(‚àÉj)<i EI((t) j, (t)i) ‚à®
(‚àÉj)<i SR((t) j, (t)i)
(10)
There are two cases:
Case 1.
i < lh(w). Thus (cf. (6) (Ô¨Årst conjunct) of the previous proof)
‚ä¢(t)i = (w)i
(11)

II.6. Derivability Conditions; Fixed Points
293
By (8),
‚ä¢LA((w)i) ‚à®Œì((w)i) ‚à®
(‚àÉj)<i(‚àÉk)<i MP((w) j, (w)k, (w)i) ‚à®
(‚àÉj)<i EI((w) j, (w)i) ‚à®
(‚àÉj)<i SR((w) j, (w)i)
Now (10) follows from the above and (11) via Ax4.
Case 2.
i = lh(w). Thus, ‚ä¢(t)i = x. By (9),
‚ä¢(‚àÉj)<lh(w)(‚àÉk)<lh(w)MP((w) j, (w)k, (t)i)
or, using (11),
‚ä¢(‚àÉj)<i(‚àÉk)<i MP((t) j, (t)k, (t)i)
(10) now follows by tautological implication.
‚ñ°
II.6.15 Lemma.
‚ä¢Proof (w) ‚àß(‚àÉj)<lh(w)SR((w) j, x) ‚ÜíProof (w ‚àó‚ü®x‚ü©)
Proof. A trivial rephrasing of the previous proof.
‚ñ°
II.6.16 Exercise. Show by a formal course-of-values induction on i that
‚ä¢i < lh(x) ‚àßProof (x) ‚ÜíWFF((x)i) = 0
Moreover, show that this is so regardless of whether one adopts MP, EI, and
SR as we did on p. 270 or, instead, one adopts their primed versions (cf. II.5.1,
p. 271).
‚ñ°
II.6.17 Corollary.
‚ä¢Deriv(y, u) ‚àßDeriv(z, ‚ü®‚åú‚Üí‚åù, u, x‚ü©) ‚ÜíDeriv(y ‚àóz ‚àó‚ü®x‚ü©, x)
Note. We have used the abbreviation ‚Äú‚ü®‚åú‚Üí‚åù, u, x‚ü©‚Äù for ‚Äú‚ü®‚åú‚à®‚åù, ‚ü®‚åú¬¨‚åù, u‚ü©,
x‚ü©‚Äù.
Proof. By Lemma II.6.13, ‚ä¢Proof (y ‚àóz). The result follows at once from
II.6.14 since ‚ä¢MP(u, ‚ü®‚åú‚Üí‚åù, u, x‚ü©, x).
This last claim also uses II.6.16, since the hypothesis (to the left of ‚Äú‚Üí‚Äù)
yields ‚ä¢WFF(u) = 0 and ‚ä¢WFF(‚ü®‚åú‚Üí‚åù, u, x‚ü©) = 0.
‚ñ°

294
II. The Second Incompleteness Theorem
A special case of the above is: For any formulas A and B ,
‚ä¢Deriv(y, ‚åúA‚åù) ‚àßDeriv(z, ‚åúA ‚ÜíB ‚åù)
‚ÜíDeriv(y ‚àóz ‚àó‚ü®‚åúB ‚åù‚ü©, ‚åúB ‚åù)
II.6.18 Corollary.
‚ä¢Term(z) = 0 ‚àßSub(x, i, z) > 0 ‚Üí
Deriv(y, x) ‚ÜíDeriv(y ‚àó‚ü®Sub(x, i, z)‚ü©, Sub(x, i, z))
Proof. We add Term(z) = 0, Sub(x, i, z) > 0, and Deriv(y, x). That
‚ä¢Deriv(y ‚àó‚ü®Sub(x, i, z)‚ü©, Sub(x, i, z))
(12)
will then follow at once from II.6.15 once we prove
‚ä¢SR(x, Sub(x, i, z))
(13)
We look Ô¨Årst at the interesting case: That is, we add Free(i, x) = 0.
To prove (13) we need (see deÔ¨Ånition of SR, p. 270) to prove
‚ä¢WFF(x) = 0 ‚àßWFF(Sub(x, i, z)) = 0 ‚àß
(‚àÉi)‚â§x(‚àÉw)‚â§Sub(x, i, z)(Term(w) = 0 ‚àß
Sub(x, i, z) = Sub(x, i, w))
(14)
or, simply,
‚ä¢WFF(x) = 0 ‚àßWFF(Sub(x, i, z)) = 0 ‚àß
i ‚â§x ‚àßz ‚â§Sub(x, i, z)
because then the third conjunct of (14) follows by MP and Ax2 from
‚ä¢i ‚â§x ‚àßz ‚â§Sub(x, i, z) ‚àßTerm(z) = 0 ‚àß
Sub(x, i, z) = Sub(x, i, z)
That is, we need
‚ä¢WFF(x) = 0
(i)
‚ä¢WFF(Sub(x, i, z)) = 0
(ii)
‚ä¢i ‚â§x
(iii)
‚ä¢z ‚â§Sub(x, i, z)
(iv)

II.6. Derivability Conditions; Fixed Points
295
We get (i) by ‚ä¢Deriv(y, x) (II.6.16), while (ii) follows from II.6.11, (i),
and the assumptions. We get (iii) from the deÔ¨Ånition of Free. Finally, (iv) is
by II.6.10.
The other case is to add Free(i, x) > 0. Then ‚ä¢Sub(x, i, z) = x (see Ex-
ercise II.19); hence we need only show that
‚ä¢Deriv(y, x) ‚ÜíDeriv(y ‚àó‚ü®x‚ü©, x)
We leave this as an easy exercise (Exercise II.20).
‚ñ°
We can also state a special case: For any formula A, variable vi and term t
substitutable for vi in A,
‚ä¢Deriv(y, ‚åúA‚åù) ‚ÜíDeriv(y ‚àó‚ü®subi(‚åúA‚åù, ‚åút‚åù)‚ü©, subi(‚åúA‚åù, ‚åút‚åù))
Translating the last two corollaries in terms of Œò we obtain
II.6.19 Corollary.
‚ä¢Œò(u) ‚àßŒò(‚ü®‚åú‚Üí‚åù, u, x‚ü©) ‚ÜíŒò(x)
II.6.20 Corollary.
‚ä¢Term(z) = 0 ‚àßSub(x, i, z) > 0 ‚ÜíŒò(x) ‚ÜíŒò(Sub(x, i, z))
II.6.21 Remark. (1) A special case of Corollary II.6.19 is worth stating: For
any formulas A and B over LA,
‚ä¢Œò(‚åúA‚åù) ‚àßŒò(‚åúA ‚ÜíB ‚åù) ‚ÜíŒò(‚åúB ‚åù)
(2) We omit the rather trivial (‚Äútrivial‚Äù given the tools we already have devel-
oped, that is) proofs of II.6.19‚ÄìII.6.20. SufÔ¨Åce it to observe that, for example,
using Ax2 and |=Taut, we get from II.6.17
‚ä¢Deriv(y, u) ‚àßDeriv(z, ‚ü®‚åú‚Üí‚åù, u, x‚ü©) ‚ÜíŒò(x)
Using ‚àÉ-introduction, we can now get rid of y and z.
‚ñ°
In order to focus the mind, we now state the derivability conditions that hold
for Œò (Ableitbarkeitsforderungen of Hilbert and Bernays (1968)). We will need
to establish that they indeed do hold in order to meet our goal of this section.

296
II. The Second Incompleteness Theorem
II.6.22 DeÔ¨Ånition (Derivability Conditions). The following statements are
the derivability conditions for the derivability predicate Œò appropriate for .
For any formulas A and B over LA,‚Ä†
DC 1. If ‚ä¢ A, then ‚ä¢C Œò(‚åúA‚åù).
DC 2. ‚ä¢C Œò(‚åúA‚åù) ‚àßŒò(‚åúA ‚ÜíB ‚åù) ‚ÜíŒò(‚åúB ‚åù).
DC 3. For any primitive recursive term t over LN C and any numbers a1, . . . , an
in N, ‚ä¢C t(
a1, . . . , 
an) = 0 ‚ÜíŒò(‚åút(
a1, . . . , 
an) = 0‚åù).
‚ñ°
II.6.23 Remark. DC 3 above is pretty much the Hilbert-Bernays (1968) third
derivability condition. DC1‚ÄìDC2 are actually L¬®ob‚Äôs versions. L¬®ob also has a
different third derivability condition ‚Äì a formalized version of DC 1 ‚Äì that we
prove later (see II.6.38).
‚ñ°
Now, DC 1 was settled in II.6.3(4), while DC 2 is II.6.21(1). Thus we focus
our effort on proving DC 3. To this end, we will Ô¨Ånd it convenient to prove a
bit more: namely, that DC 3 is true even if instead of the 
a1, . . . , 
an we use free
variables x1, . . . , xn. To formulate such a version we will employ, for any term
or formula E(x1, . . . , xn),‚Ä° a primitive recursive term gE(x1, . . . , xn) such that,
for all a1, . . . , an in N,
‚ä¢C ‚åúE(
a1, . . . , 
an)‚åù= gE(
a1, . . . , 
an)
(1)
Assume for a moment that we have obtained such a family of g-terms, and let
gt=0(x1, . . . , xn) be appropriate for the formula t(x1, . . . , xn) = 0. If now we
manage to prove
‚ä¢t(x1, . . . , xn) = 0 ‚ÜíŒò(gt=0(x1, . . . , xn))
then DC 3 follows by substitution and Ax4 from (1) above.
To this end, we Ô¨Årst address an important special case: We introduce a
function symbol Num such that
‚ä¢Num(n) = ‚åún‚åù
for all n ‚ààN
(2)
Thus, we are saying that Num = gx, that is, a g-term appropriate for the term x.
The symbol Num ‚Äì and its deÔ¨Åning axioms below ‚Äì are in LN C and C re-
spectively, since the introducing axioms make it clear that Num is primitive
recursive.
‚Ä† In the interest of clarity ‚Äì and emphasis ‚Äì we have retained the subscript C of ‚ä¢, wherever it was
applicable throughout the deÔ¨Ånition.
‚Ä° Recall the convention on round brackets, p. 18.

II.6. Derivability Conditions; Fixed Points
297
We deÔ¨Åne
Num(0) = ‚åú0‚åù
Num(Sx) = ‚ü®‚åúS‚åù, Num(x)‚ü©
(Num)
To see that the above deÔ¨Ånition behaves as required by (2), we do meta-
mathematical induction on n ‚ààN: For n = 0, the claim is settled by the Ô¨Årst
equation in the group (Num) and by ‚ä¢0 = 0 (deÔ¨Ånition of ‚Äún‚Äù, p. 171).
Assume the claim for a Ô¨Åxed n. Now (deÔ¨Ånition), ‚ä¢
n + 1 = Sn; thus (Ax4
and second equation in (Num))
‚ä¢Num( 
n + 1) = ‚ü®‚åúS‚åù, Num(n)‚ü©
‚ä¢‚ü®‚åúS‚åù, Num(n)‚ü©= ‚ü®‚åúS‚åù, ‚åún‚åù‚ü©
by I.H. and Ax4
‚ä¢‚ü®‚åúS‚åù, ‚åún‚åù‚ü©= ‚åúSn‚åù
by deÔ¨Ånition of ‚Äú‚åúSt‚åù‚Äù
‚ä¢‚åúSn‚åù= ‚åú
n + 1‚åù
by deÔ¨Ånition of n
Intuitively, Num(x) is the G¬®odel number of
S . . . S
  
x copies
0
(3)
where x is a formal variable (not just a closed term n). If we are right in this
assessment, then it must be case that ‚ä¢Term(Num(x)) = 0. Moreover, even
though the expression in (3),‚Ä† intuitively, ‚Äúdepends‚Äù on x, it still contains no
variables (it is a sequence of copies of the symbol ‚ÄúS‚Äù followed by ‚Äú0‚Äù), so that
we expect ‚ä¢Free(y, Num(x)) > 0.
Both expectations are well founded.
II.6.24 Lemma. ‚ä¢Term(Num(x)) = 0.
Proof. Formal induction on x. For x = 0, we want ‚ä¢Term(‚åú0‚åù) = 0. This is
the case, by II.3.8, since T erm(gn(0)) = 0 is true.
We now prove
‚ä¢Term(Num(Sx)) = 0
(4)
based on the obvious I.H. It sufÔ¨Åces (by (Num) above) to prove
‚ä¢Term

‚ü®‚åúS‚åù, Num(x)‚ü©

= 0
‚Ä† Of course, such an expression is not well formed in our formalism, because it is a variable length
term. This is why we emphasized the word ‚Äúintuitively‚Äù twice in this comment.

298
II. The Second Incompleteness Theorem
Turning to the deÔ¨Ånition of Term (p. 267), we Ô¨Ånd that the third disjunct is
provable, since
‚ä¢Seq
%
‚ü®‚åúS‚åù, Num(x)‚ü©) ‚àßlh(‚ü®‚åúS‚åù, Num(x)‚ü©) = SS0
‚àßf unc

(‚ü®‚åúS‚åù, Num(x)‚ü©)0, S0

‚àßTerm

(‚ü®‚åúS‚åù, Num(x)‚ü©)S0

= 0
&
,
the last conjunct by I.H.
We are done, by deÔ¨Ånition by cases ((15), p. 221).
‚ñ°
II.6.24 says that Num(x) ‚Äúbehaves‚Äù like the G¬®odel number of a term. It does
not say that there is a term t such that Num(x) = ‚åút‚åù. (See also the previous
footnote, and also recall that G¬®odel numbers of speciÔ¨Åc expressions are closed
terms.)
II.6.25 Lemma. ‚ä¢Free(y, Num(x)) > 0.
Proof. Wedo(formal)inductionon x. For x = 0wewant‚ä¢Free(y, ‚åú0‚åù) > 0,
which is correct (if we examine the cases in the deÔ¨Ånition of Free, p. 267, only
the ‚Äúotherwise‚Äù applies).
To conclude, we examine Free(y, Num(Sx)) (with frozen free variables x
and y). By II.6.24,
‚ä¢Term(Num(Sx)) = 0
so we need only examine (see (Fr), p. 267)
(‚àÉz)<SS0(0 < z ‚àßFree(y, (‚ü®‚åúS‚åù, Num(x)‚ü©)z) = 0)
(5)
We want to refute (5), so we add it as an assumption (with frozen free variables
x and y ‚Äì proof by contradiction, I.4.21).
We take a new constant, a, and assume
a < SS0 ‚àß0 < a ‚àßFree

y, (‚ü®‚åúS‚åù, Num(x)‚ü©)a

= 0
One now gets ‚ä¢a = S0 from the Ô¨Årst two conjuncts;‚Ä† hence
‚ä¢Free(y, Num(x)) = 0
from the last conjunct.
We have just contradicted the I.H. Free(y, Num(x)) > 0. Thus, the nega-
tion of (5) is provable. It now follows that the ‚Äúotherwise‚Äù case (conjunc-
tion of the negations of the explicit cases) is provable in the deÔ¨Ånition of
‚Ä† The Ô¨Årst yields a ‚â§S0, and the second yields S0 ‚â§a.

II.6. Derivability Conditions; Fixed Points
299
Free(y, Num(Sx)). Therefore, ‚ä¢Free(y, Num(Sx)) = S0 (see also (15),
p. 221).
‚ñ°
It is now clear what the gE-terms must be:
Let E(vi1, . . . , vin) be a term or formula where the vi j are (names for) the
formal object variables, as these were constructed on p. 166 from the symbols
of a Ô¨Ånite alphabet. Let us introduce the informal abbreviation
si(x, y) = subi(x, Num(y))
(s)
Informal, because we do not need to introduce a formal symbol. All we need
is convenience. Were we to introduce si formally, it would then be a primi-
tive recursive function symbol of LN C and (s) would be the deÔ¨Åning axiom
(essentially, composition). As it stands now, it is just a metatheoretical symbol.
Then gE(x1, . . . , xn) ‚Äì where the xi are arbitrary metavariables, possibly
overlapping with the vi j ‚Äì is an informal abbreviation for the term‚Ä†
sin( . . . si2(si1(‚åúE‚åù, x1), x2), . . . , xn)
(6)
Indeed Ax4, (2) (p. 296), and (s) above imply, for any n ‚ààN,
‚ä¢C si j(x,n) = subi j(x, ‚åún‚åù)
Thus (p. 279)
‚ä¢C si j(‚åúE[vi j]‚åù,n) = ‚åúE[n]‚åù
Repeating the above for each free variable of E, we obtain
‚ä¢C gE(
m1, . . . , 
mn) = ‚åúE(
m1, . . . , 
mn)‚åù
It is clear that gE is a primitive recursive term (each subi(x, y) is).
We abbreviate (6) ‚Äì i.e., gE(x1, . . . , xn) ‚Äì by yet another informal notation as
in Hilbert and Bernays (1968):
{E(x1, . . . , xn)}
(7)
The reader will exercise care not to confuse the syntactic (meta)variables xj
introduced in (6) and (7) with the formal variables that occur free in the ex-
pression E. The latter are the vi j, as already noted when introducing (6). In
particular, the ‚Äúi‚Äù in subi is that of the formal vi, not that of the ‚Äúsyntactic‚Äù xi.‚Ä°
‚Ä† By II.6.25, the order of substitutions is irrelevant. ‚ÄúE‚Äù and ‚ÄúE(vi1, . . . , vin)‚Äù are, of course,
interchangeable. The latter simply indicates explicitly the list of all free variables of E.
‚Ä° Unless, totally coincidentally, xi denotes vi in some context. See the informal deÔ¨Ånition (s)
above, and also the deÔ¨Ånition (subi), p. 268.

300
II. The Second Incompleteness Theorem
We may write simply {E} if the variables x1, . . . , xn are implied by the
context.
We note that while ‚åúE(x1, . . . , xn)‚åùis a closed term, {E(x1, . . . , xn)} is a
term with precisely x1, . . . , xn as its list of free variables.
II.6.26 Example. ‚ä¢{x} = Num(x). Indeed,
‚ä¢{x} = subm(‚åúvm‚åù, Num(x))
But ‚ä¢subm(‚åúvm‚åù, Num(x)) = Num(x) (by the deÔ¨Ånition of Sub, Ô¨Årst case,
p. 268). For any terms
t(vj1, . . . , vjhvm1, . . . , vmn)
and
s(vj1, . . . , vjh, vk1, . . . , vkr )
and any choice of (meta)variables
x1, . . . , xh, y1, . . . , yn, z1, . . . , zr
(1)
We have
‚ä¢{(t = s)(x1, . . . , xh, y1, . . . , yn, z1, . . . , zr)} =
‚ü®‚åú= ‚åù, {t(x1, . . . , xh, z1, . . . , zr)}, {s(x1, . . . , xh, y1, . . . , yn)}‚ü©
(2)
Now that the list (1) has been recorded, we will feel free to abbreviate (2) as
‚ä¢{t = s} = ‚ü®‚åú= ‚åù, {t}, {s}‚ü©
(3)
We proceed to establish (2) (or (3)) recalling that the order of substitution
is irrelevant, and using ‚Äú=‚Äù conjunctionally below (i.e., ‚ä¢t = s = r means
‚ä¢t = s and ‚ä¢s = r):
‚ä¢{(t = s)(x1, . . . , xh, y1, . . . , yn, z1, . . . , zr)} =
skr (. . . smn(. . . s jh(. . . s j1(‚åút = s‚åù, x1), . . . , xh), . . . , yn), . . . , zr) =
‚ü®‚åú= ‚åù, skr (. . . smn(. . . s jh(. . . s j1(‚åút‚åù, x1), . . . , xh), . . . , yn), . . . , zr),
skr (. . . smn(. . . s jh(. . . s j1(‚åús‚åù, x1), . . . , xh), . . . , yn), . . . , zr)‚ü©=
‚ü®‚åú= ‚åù, {t(x1, . . . , xh, z1, . . . , zr)}, {s(x1, . . . , xh, y1, . . . , yn)}‚ü©
The computations above iterate case 4 of the deÔ¨Ånition of Sub (subcase for
AF, p. 268), keeping in mind informal deÔ¨Ånition (s) (p. 299). This iterative
calculation relies on II.6.4 and II.6.24 to ensure that
‚ä¢Term(Sub(‚åúE‚åù,i, Num(w))) = 0
at every step (E is t or s).

II.6. Derivability Conditions; Fixed Points
301
We have abbreviated
‚åú(t = s)(vj1, . . . , vjhvm1, . . . , vmn, vk1, . . . , vkr )‚åù
by
‚åút = s‚åù
‚åút(vj1, . . . , vjh, vm1, . . . , vmn)‚åù
by
‚åút‚åù
and
‚åús(vj1, . . . , vjh, vk1, . . . , vkr)‚åù
by
‚åús‚åù
We have also freely used during our computation the fact that
‚ä¢Free(i, x) > 0 ‚àßTerm(x) = 0 ‚ÜíSub(x, i, z) = x
(see Exercise II.19).
The same type of computation ‚Äì employing II.6.11, II.6.12, II.6.24, and
II.6.25 ‚Äì establishes that
‚ä¢{A ‚ÜíB } = ‚ü®‚åú‚Üí‚åù, {A}, {B }‚ü©
We have used the short { }-notation above.
The behaviour of the symbol { } is not very stable with respect to substitution.
For example, we have found that ‚ä¢{x} = Num(x) above. However, it is not
true that for arbitrary unary f
‚ä¢{ f x} = Num( f x)
(4)
(see Exercise II.21). On the other hand, (4) does hold if f ‚â°S. Indeed (using,
once again, ‚Äú=‚Äù conjunctionally), we Ô¨Ånd that
‚ä¢{Sx} = sub1(‚åúSv1‚åù, Num(x))
= ‚ü®‚åúS‚åù, sub1(‚åúv1‚åù, Num(x))‚ü©
= ‚ü®‚åúS‚åù, Num(x)‚ü©
= Num(Sx)
‚ñ°
II.6.27 Lemma. ‚ä¢C Œò(x) ‚ÜíŒò(Sub(x, i, Num(y))).
Proof. By modus ponens from II.6.20, since
‚ä¢Term(Num(y)) = 0
by II.6.24, and
‚ä¢Œò(x) ‚ÜíSub(x, i, Num(y)) > 0
‚Äì the latter from ‚ä¢Œò(x) ‚ÜíWFF(x) = 0 (cf. II.6.16), II.6.12, and II.6.25. ‚ñ°

302
II. The Second Incompleteness Theorem
II.6.28 Corollary. For any formula A over LA and variable vi,
‚ä¢C Œò(‚åúA[vi]‚åù) ‚ÜíŒò
%
Sub

‚åúA[vi]‚åù,i, Num(x)
&
Iterating application of the above for all the free variables in A, we obtain
at once:
II.6.29 Corollary. For any formula A over LA,
‚ä¢C Œò(‚åúA(vi1, . . . , vin)‚åù) ‚ÜíŒò

{A(x1, . . . , xn)}

Of course, we also obtain a useful special case ‚Äì where xj denotes vi j ‚Äì as
follows: For any formula A over LA,
‚ä¢C Œò(‚åúA(x1, . . . , xn)‚åù) ‚ÜíŒò

{A(x1, . . . , xn)}

The next corollary follows at once from the above remark and DC 1.
II.6.30 Corollary (The Free Variables Version of DC 1). For any formula A
over LA, if ‚ä¢ A(x1, . . . , xn), then ‚ä¢C Œò

{A(x1, . . . , xn)}

.
II.6.31 Lemma (The Free Variables Version of DC 2). For any formulas A
and B over LA,
‚ä¢C Œò

{A ‚ÜíB }

‚ÜíŒò

{A}

‚ÜíŒò

{B }

Proof. {A ‚ÜíB } abbreviates
‚ü®‚åú‚Üí‚åù, subin(. . . subi1(‚åúA‚åù, Num(x1)), . . . , Num(xn)),
subin(. . . subi1(‚åúB ‚åù, Num(x1)), . . . , Num(xn))‚ü©
while {A} and {B } abbreviate
subin(. . . subi1(‚åúA‚åù, Num(x1)), . . . , Num(xn))
and
subin(. . . subi1(‚åúB ‚åù, Num(x1)), . . . , Num(xn))
respectively. We are done, by II.6.19.
Pause. Why is
‚ä¢WFF

subin(. . . subi1(‚åúB ‚åù, Num(x1)), . . . , Num(xn))

= 0?
‚ñ°

II.6. Derivability Conditions; Fixed Points
303
II.6.32 Remark. In what follows, all the way to the end of the section, we as-
sume ‚Äì without loss of generality ‚Äì that our unspeciÔ¨Åed consistent Œ£1 extension,
, of PA also extends C, the theory of G¬®odel coding.
Here is why generality is not lost in the case where we were unfortunate
enough to start with a  that did not satisfy the assumption:
(1) We start with PA ‚â§,‚Ä† where Œì is Œ£1(LNC).
(2) We extend  ‚Äì to ‚Ä≤ ‚Äì by adding the axioms for all the deÔ¨Åned symbols
that were added to PA in order to form C and LN C. This results to the
language LN‚Ä≤. So, not only do we have PA ‚â§C conservatively, but also
 ‚â§‚Ä≤ conservatively.
(3) Since  is consistent, the ‚Äúconservatively‚Äù part above ensures that so is ‚Ä≤.
Trivially, PA ‚â§‚Ä≤and C ‚â§‚Ä≤.
(4) If Q is a formula that semantically deÔ¨Ånes the nonlogical axioms of C,
that is, Q(‚åúA‚åù) means that A is a C-axiom, then Œì‚Ä≤(x) can be taken to
abbreviate
Œì(x) ‚à®Q(x)
(‚àó)
Given that Q(x) is primitive recursive (Exercise II.23‚Ä°), the formula (‚àó) is
Œ£1(LNC) (Exercise II.24).
‚ñ°
II.6.33 Lemma. For any terms t, s and variable z, if ‚ä¢C t = s and
‚ä¢C t = z ‚ÜíŒò

{t = z}

then also
‚ä¢C s = z ‚ÜíŒò

{s = z}

where we have written ‚ÄúŒò‚Äù for ‚ÄúŒòŒì‚Äù.
Proof. ‚Äú‚ä¢‚Äù means ‚Äú‚ä¢C‚Äù. By Ax4
‚ä¢t = z ‚Üís = z
(1)
and
‚ä¢s = z ‚Üít = z
(2)
‚Ä† The relation ‚Äú‚â§‚Äù that compares two theories was introduced on p. 46.
‚Ä° C contains the Ô¨Ånitely many deÔ¨Åning axioms we have introduced towards the G¬®odel coding.
Moreover it contains the inÔ¨Ånitely many axioms introducing the primitive recursive symbols. A
deÔ¨Åning predicate for this part can be introduced by a course-of-values recursion, as can be easily
deduced from the speciÔ¨Åc allocation scheme chosen for primitive recursive function symbols.
See Remark II.3.7, p. 254.

304
II. The Second Incompleteness Theorem
By DC 1 and DC 2 (free variables versions, II.6.30 and II.6.31) in that order,
(1) yields
‚ä¢Œò

{t = z}

‚ÜíŒò

{s = z}

(3)
where we have used the blanket assumption ‚ÄúC ‚â§‚Äù (II.6.32) in the application
of DC 1 (DC 1 assumes ‚Äú‚ä¢ . . . ‚Äù). Our unused assumption, along with (2)
and (3), yields what we want by tautological implication.
‚ñ°
We now have all the tools we need towards proving DC 3.
II.6.34 Main Lemma. For any primitive recursive term t over LN C and any
variable z not free in t,
‚ä¢C t = z ‚ÜíŒò

{t = z}

(1)
where we have written ‚ÄúŒò‚Äù for ‚ÄúŒòŒì‚Äù.
We continue the practice of omitting the subscript C from ‚ä¢(a subscript will
be used if other than C, or as a periodic reminder (or emphasis) if it is C). The
implicit assumption ‚ÄúC ‚â§‚Äù (II.6.32) enables II.6.30 (DC 1, free variables
version) exactly as in the case of II.6.33.
Here is how not to prove the lemma: ‚ÄúBy Ax4 it sufÔ¨Åces to prove
‚ä¢Œò

{t = t}

This follows from ‚ä¢t = t and II.6.30.‚Äù
Such an attempt does not heed the warning in Example II.6.26. Recall that
‚ä¢{t = z} = ‚ü®‚åú= ‚åù, {t}, Num(z)‚ü©. However, we have already noted that it
is not true in general that ‚ä¢Num(t) = {t}. Thus, in general,
Ã∏‚ä¢{t = z}[z ‚Üêt] = {t = t}
Proof. The proof is by (metamathematical) induction on the formation of t and
follows the one given by Hilbert and Bernays (1968) (however, unlike them,
we do not restrict primitive recursive terms to ‚Äúnormalized‚Äù forms).
We have three basis cases:
Case 1.
t ‚â°Zv0. Since ‚ä¢Zv0 = 0, it sufÔ¨Åces, by II.6.33, to prove the
following version of (1):
‚ä¢0 = z ‚ÜíŒò

{0 = z}


II.6. Derivability Conditions; Fixed Points
305
By Ax4 it sufÔ¨Åces to prove
‚ä¢Œò

{0 = 0}

This follows from ‚ä¢0 = 0 and II.6.30.
Pause. Wait a minute! How does this differ from what I said above that we
should not do?
Case 2.
t ‚â°U n
i (v0, . . . , vn‚àí1).
Again, by II.6.33 and ‚ä¢U n
i (v0, . . . , vn‚àí1) = vi‚àí1, (1) now becomes (where
we have simpliÔ¨Åed the metanotation: x rather than the ‚Äúactual‚Äù vi‚àí1)
‚ä¢x = z ‚ÜíŒò

{x = z}

By Ax4 it sufÔ¨Åces to prove
‚ä¢Œò

{x = x}

This follows from ‚ä¢x = x and II.6.30.
Pause. Was this O.K.?
Case 3.
t ‚â°Sx. (1) now is
‚ä¢Sx = z ‚ÜíŒò

‚ü®‚åú= ‚åù, {Sx}, Num(z)‚ü©

By Ax4 it sufÔ¨Åces to prove
‚ä¢Œò

‚ü®‚åú= ‚åù, {Sx}, Num(Sx)‚ü©

‚Äì that is (II.6.26), ‚ä¢Œò

‚ü®‚åú= ‚åù, {Sx}, {Sx}‚ü©

, or (II.6.26 again)
‚ä¢Œò

{Sx = Sx}

This follows from ‚ä¢Sx = Sx and II.6.30.
We now embark on the two induction steps:
Composition.
Suppose that t ‚â°f s1 . . . sn, where the function f and the
terms si are primitive recursive.
Let (I.H.)
‚ä¢f x1 . . . xn = z ‚ÜíŒò

{ f x1 . . . xn = z}

(2)
and
‚ä¢si = xi ‚ÜíŒò

{si = xi}

for i = 1, . . . , n
(3)

306
II. The Second Incompleteness Theorem
where none of the xi are free in any of the s j, and, moreover, z is not one of the
xi. By Ax4
‚ä¢s1 = x1 ‚Üís2 = x2 ‚Üí¬∑ ¬∑ ¬∑ ‚Üísn = xn ‚Üí
f s1 . . . sn = z ‚Üíf x1 . . . xn = z
(4)
and
‚ä¢s1 = x1 ‚Üís2 = x2 ‚Üí¬∑ ¬∑ ¬∑ ‚Üísn = xn ‚Üí
f x1 . . . xn = z ‚Üíf s1 . . . sn = z
(5)
By (2) and (4) (and tautological implication),
‚ä¢s1 = x1 ‚Üís2 = x2 ‚Üí¬∑ ¬∑ ¬∑ ‚Üísn = xn ‚Üí
f s1 . . . sn = z ‚ÜíŒò

{ f x1 . . . xn = z}

(6)
By II.6.30 and (5),
‚ä¢Œò

{s1 = x1 ‚Üís2 = x2 ‚Üí¬∑ ¬∑ ¬∑ ‚Üísn = xn ‚Üí
f x1 . . . xn = z ‚Üíf s1 . . . sn = z}

Hence, by II.6.31,
‚ä¢Œò

{s1 = x1}

‚ÜíŒò

{s2 = x2}

‚Üí¬∑ ¬∑ ¬∑ ‚ÜíŒò

{sn = xn}

‚Üí
Œò

{ f x1 . . . xn = z}

‚ÜíŒò

{ f s1 . . . sn = z}

The above and (3) tautologically imply
‚ä¢s1 = x1 ‚Üís2 = x2 ‚Üí¬∑ ¬∑ ¬∑ ‚Üísn = xn ‚Üí
Œò

{ f x1 . . . xn = z}

‚ÜíŒò

{ f s1 . . . sn = z}

The above and (6) tautologically imply
‚ä¢s1 = x1 ‚Üís2 = x2 ‚Üí¬∑ ¬∑ ¬∑ ‚Üísn = xn ‚Üí
f s1 . . . sn = z ‚ÜíŒò

{ f s1 . . . sn = z}

(7)
Finally, since the xi are not free in any of the s j and are distinct from z, the
substitutions [xi ‚Üêsi] into (7), and tautological implication, imply
‚ä¢f s1 . . . sn = z ‚ÜíŒò

{ f s1 . . . sn = z}

Primitive recursion.
We are given that h(‚Éóy ) and g(x,‚Éóy, w) are primitive
recursive terms, and that f has been introduced to satisfy
‚ä¢f (0,‚Éóy ) = h(‚Éóy )
‚ä¢f (Sx,‚Éóy ) = g(x,‚Éóy, f (x,‚Éóy ))
(8)
Supposing that z is distinct from x,‚Éóy, we want to show
‚ä¢f (x,‚Éóy ) = z ‚ÜíŒò

{ f (x,‚Éóy ) = z}


II.6. Derivability Conditions; Fixed Points
307
To allow the Ô¨Çexibility of splitting the induction step into an I.H. and a con-
clusion (as usual practice dictates, using the deduction theorem), we prove the
following (provably) equivalent form instead:
‚ä¢(‚àÄz)
%
f (x,‚Éóy ) = z ‚ÜíŒò

{ f (x,‚Éóy ) = z}
&
(9)
under the same restriction, that the bound variable z is not among x,‚Éóy.
Now, our metamathematical I.H. (on the formation of primitive recursive
terms t) ‚Äì under the assumption that z is not among x,‚Éóy, w ‚Äì is
‚ä¢h(‚Éóy ) = z ‚ÜíŒò

{h(‚Éóy ) = z}

‚ä¢g(x,‚Éóy, w) = z ‚ÜíŒò

{g(x,‚Éóy, w) = z}

(10)
(9) is proved by formal induction on x.
For the formal basis of (9), let us set x ‚Üê0. By the Ô¨Årst of (8), the Ô¨Årst
of (10), and II.6.33 (followed by generalization) we deduce the basis, namely,
‚ä¢(‚àÄz)
%
f (0,‚Éóy ) = z ‚ÜíŒò

{ f (0,‚Éóy ) = z}
&
Now assume (9) (formal I.H.) for frozen x,‚Éóy, and prove
‚ä¢(‚àÄz)
%
f (Sx,‚Éóy ) = z ‚ÜíŒò

{ f (Sx,‚Éóy ) = z}
&
(11)
By generalization, it sufÔ¨Åces to prove
‚ä¢f (Sx,‚Éóy ) = z ‚ÜíŒò

{ f (Sx,‚Éóy ) = z}

(11‚Ä≤)
(where z is not among x,‚Éóy). We choose w, not among x,‚Éóy, z. By Ax4,
‚ä¢f (x,‚Éóy ) = w ‚Üíg(x,‚Éóy, f (x,‚Éóy )) = z ‚Üíg(x,‚Éóy, w) = z
‚ä¢f (x,‚Éóy ) = w ‚Üíg(x,‚Éóy, w) = z ‚Üíg(x,‚Éóy, f (x,‚Éóy )) = z
which by the second part of (8) and Ax4 translate into
‚ä¢f (x,‚Éóy ) = w ‚Üíf (Sx,‚Éóy ) = z ‚Üíg(x,‚Éóy, w) = z
‚ä¢f (x,‚Éóy ) = w ‚Üíg(x,‚Éóy, w) = z ‚Üíf (Sx,‚Éóy ) = z
(12)
Tautological implication using the second part of (10) and the Ô¨Årst of (12)
yields
‚ä¢f (x,‚Éóy ) = w ‚Üíf (Sx,‚Éóy ) = z ‚ÜíŒò

{g(x,‚Éóy, w) = z}

(13)
II.6.30‚ÄìII.6.31 and the second part of (12) yield
‚ä¢Œò

{ f (x,‚Éóy ) = w}

‚ÜíŒò

{g(x,‚Éóy, w) = z}

‚ÜíŒò

{ f (Sx,‚Éóy ) = z}


308
II. The Second Incompleteness Theorem
Using the I.H. (9), followed by specialization (and with the help of |=Taut), this
yields
‚ä¢f (x,‚Éóy ) = w ‚ÜíŒò

{g(x,‚Éóy, w) = z}

‚ÜíŒò

{ f (Sx,‚Éóy ) = z}

Here is where the (universally quantiÔ¨Åed) form of (9) helped formally. We have
been manipulating the z-variable by substituting w. This would be enough
to unfreeze variables frozen between I.H. and conclusion, thus invalidating the
deduction theorem step. However, that is not the case here, because this variable
manipulation is hidden from the deduction theorem. z is a bound variable in the
assumption (9).
Tautological implication, using the above and (13), furnishes
‚ä¢f (x,‚Éóy ) = w ‚Üíf (Sx,‚Éóy ) = z ‚ÜíŒò

{ f (Sx,‚Éóy ) = z}

Finally, since x, w, z,‚Éóy are all distinct, the substitution [w ‚Üêf (x,‚Éóy )] in the
above yields (11‚Ä≤) by tautological implication, and we thus have (11) by gener-
alization.
‚ñ°
At this point the reader may take a well-deserved break.
Next, we prove
II.6.35 Corollary. For any primitive recursive predicate P over LN C,
‚ä¢C P(x1, . . . , xn) ‚ÜíŒò

{P(x1, . . . , xn)}

Proof. Indeed,
‚ä¢P(x1, . . . , xn) ‚ÜíœáP(x1, . . . , xn) = 0
(1)
and
‚ä¢œáP(x1, . . . , xn) = 0 ‚ÜíP(x1, . . . , xn)
(2)
where œáP is ‚Äúthe‚Äù (primitive recursive) characteristic function (see II.3.6,
p. 253, and II.1.25, p. 220) for P(x1, . . . , xn). By the main lemma (II.6.34),
‚ä¢œáP(x1, . . . , xn) = 0 ‚ÜíŒò

{œáP(x1, . . . , xn) = 0}

Hence (by (1))
‚ä¢P(x1, . . . , xn) ‚ÜíŒò

{œáP(x1, . . . , xn) = 0}

(3)

II.6. Derivability Conditions; Fixed Points
309
By (2) and II.6.30‚ÄìII.6.31,
‚ä¢Œò

{œáP(x1, . . . , xn) = 0}

‚ÜíŒò

{P(x1, . . . , xn)}

This and (3) yield what we want, by tautological implication.
‚ñ°
We can prove a bit more:
II.6.36 Corollary. For any Œ£1(LNC) formula A,
‚ä¢C A (x1, . . . , xn) ‚ÜíŒò

{A (x1, . . . , xn)}

Proof. Let A (x1, . . . , xn) be Œ£1(LNC).
Then, for some ‚àÜ0(LNC) formula Q (y, x1, . . . , xn), where y is distinct
from x1, . . . , xn,
‚ä¢A (x1, . . . , xn) ‚Üî(‚àÉy)Q (y, x1, . . . , xn)
We introduce a predicate R by the deÔ¨Ånition
R(y,‚Éóxn) ‚ÜîQ (y,‚Éóxn)
(4)
Then R is primitive recursive (Exercise II.22).
By II.6.35,
‚ä¢R(y, x1, . . . , xn) ‚ÜíŒò

{R(y, x1, . . . , xn)}

Hence, by (4) and tautological implication,
‚ä¢Q (y, x1, . . . , xn) ‚ÜíŒò

{R(y, x1, . . . , xn)}

(5)
By II.6.30‚ÄìII.6.31 and the ‚Üí-part of (4),
‚ä¢Œò

{R(y, x1, . . . , xn)}

‚ÜíŒò

{Q (y, x1, . . . , xn)}

Hence (by (5))
‚ä¢Q (y, x1, . . . , xn) ‚ÜíŒò

{Q (y, x1, . . . , xn)}

(6)
Now,
‚ä¢Q (y, x1, . . . , xn) ‚Üí(‚àÉy)Q (y, x1, . . . , xn)
Hence, by II.6.30‚ÄìII.6.31,
‚ä¢Œò

{Q (y, x1, . . . , xn)}

‚ÜíŒò

{(‚àÉy)Q (y, x1, . . . , xn)}


310
II. The Second Incompleteness Theorem
Combining the above with (6) via |=Taut, we get
‚ä¢Q (y, x1, . . . , xn) ‚ÜíŒò

{(‚àÉy)Q (y, x1, . . . , xn)}

which yields what we want via ‚àÉ-introduction.
‚ñ°
The following corollary is a step backward in terms of degree of generality,
but it is all we really need. It is a formalized DC 1, for it says ‚Äúif it is true that
A is provable, then it is also true that Œò(‚åúA‚åù) is provable‚Äù.
II.6.37 Corollary (L¬®ob). For any formula A over LN C,
‚ä¢C Œò

‚åúA‚åù

‚ÜíŒò
%
‚åúŒò

‚åúA‚åù

‚åù
&
Proof. For any Ô¨Åxed A, Œò(‚åúA‚åù) is a Œ£1(LNC) sentence.
‚ñ°
II.6.38 Remark.
The above corollary is L¬®ob‚Äôs third derivability condition,
DC 3.
‚ñ°
II.6.39 Theorem (The Fixpoint Theorem, or Diagonalization Lemma). For
any formula A(x) over LN C, there is a sentence B over the basic language of
PA, LN, such that
‚ä¢C B ‚ÜîA(‚åúB ‚åù)
B is called a Ô¨Åxed point or Ô¨Åxpoint of A in C.
The assumption C ‚â§ of II.6.32 is not used here.
Proof. Let C (x) be the formula obtained from A(s1(x, x)) after removing all
deÔ¨Åned symbols (following I.7.1 and I.7.3). Then C is over LN, and
‚ä¢C C (x) ‚ÜîA(s1(x, x))
(1)
Let next n ‚ààN be such that (cf. (1), p. 274)
‚ä¢C n = ‚åúC (x)‚åù
Hence (p. 279, 297, and 299)
‚ä¢C s1(n,n) = ‚åúC (n)‚åù
(2)
By (1) and substitution,
‚ä¢C C (n) ‚ÜîA(s1(n,n))

II.6. Derivability Conditions; Fixed Points
311
By Ax4 and (2), the above yields
‚ä¢C C (n) ‚ÜîA

‚åúC (n)‚åù

Thus ‚ÄúC (n)‚Äù is the sentence ‚ÄúB ‚Äù we want.
‚ñ°
Applying the above to ¬¨Œò, we obtain a sentence that semantically says ‚ÄúI
am not a theorem of ‚Äù.
II.6.40 Corollary (G¬®odel). There is a sentence G over the basic language LN
such that
‚ä¢C G ‚Üî¬¨ŒòŒì(‚åúG ‚åù)
(1)
We now need to revisit (half of) G¬®odel‚Äôs Ô¨Årst incompleteness theorem. We
will show that the sentence G above is not provable in .‚Ä† For the balance of
the section we will be careful to subscript Œò with the name, say , of the theory
for which it is a provability predicate.
II.6.41 Lemma (G¬®odel). Let  over LA be a consistent extension of PA such
that Œì(x) is Œ£1(LNC). Let the sentence G over LN be a Ô¨Åxed point of ¬¨Œò Œì in
C. Then Ã∏‚ä¢ G .
The assumption C ‚â§ of II.6.32 is not used here.
Proof. Assume that
‚ä¢ G
(2)
By the assumption on Œì(x), DC 1 is applicable; hence
‚ä¢C ŒòŒì(‚åúG ‚åù)
(1) of II.6.40 now yields
‚ä¢C ¬¨G
Since PA ‚â§C conservatively, and G is over LN, we have ‚ä¢PA ¬¨G , and hence,
by PA ‚â§,
‚ä¢ ¬¨G
The above and (2) contradict the consistency of .
‚ñ°
‚Ä† The other half, which we do not need towards the proof of the second incompleteness theorem,
uses a stronger consistency assumption ‚Äì œâ-consistency (p. 189) ‚Äì and states that G is not refut-
able either.

312
II. The Second Incompleteness Theorem
We continue honouring the assumption of II.6.32; however, we make it explicit
here. That is, we have the following situation:
(1) PA ‚â§ consistently (Œì in Œ£1(LNC)).
(2)  ‚â§‚Ä≤ conservatively, by adding the symbols (and their deÔ¨Ånitions) of C.
Œì‚Ä≤ is in Œ£1(LNC)
We let the metasymbol ‚ÄúCon‚Äù stand for ‚Äú is consistent‚Äù. With the help of the
arithmetization tools this can be implemented as a sentence whose semantics
is that some convenient refutable formula is not a -theorem.
‚Äú0 = S0‚Äù is our choice of a refutable formula (cf. S1). We may now deÔ¨Åne
Con
abbreviates
¬¨ŒòŒì‚Ä≤(‚åú0 = S0‚åù)
since 0 = S0 is unprovable in  iff it is so in ‚Ä≤; therefore ¬¨ŒòŒì‚Ä≤(‚åú0 = S0‚åù) ‚Äì
that is, Con ‚Äì says both ‚Äú‚Ä≤ is consistent‚Äù and ‚Äú is consistent‚Äù.
We will next want to show that, under some reasonable assumptions, 
cannot prove Con, that is, it cannot prove its own consistency.
For this task to be meaningful (and ‚Äúfair‚Äù to  ), Con (that is, the actual
formula it stands for) must be in the language of , LA. We can guarantee
this if we deÔ¨Åne Con to instead abbreviate the sentence S obtained from
¬¨ŒòŒì‚Ä≤(‚åú0 = S0‚åù) by elimination of deÔ¨Åned symbols. Thus, we Ô¨Ånalize the def-
inition as
Con
abbreviates
S
(‚àó)
where S is over the basic language LN of PA and satisÔ¨Åes
‚ä¢C S ‚Üî¬¨ŒòŒì‚Ä≤(‚åú0 = S0‚åù)
(‚àó‚àó)
II.6.42 Theorem (G¬®odel‚Äôs Second Incompleteness Theorem). Let  be a
consistent extension of PA such that Œì(x) is Œ£1(LNC). Then Ã∏‚ä¢ Con.
Proof. Let  ‚â§‚Ä≤ as in the discussion above (we continue being explicit here
about our blanket assumption II.6.32; thus C ‚â§‚Ä≤, while C ‚â§ might fail).
The proof utilizes the Ô¨Åxed point G of ¬¨ŒòŒì‚Ä≤ that is obtained in the manner
of II.6.40‚ÄìII.6.41 above (note however the prime). Our aim is to show that‚Ä†
‚ä¢‚Ä≤ Con ‚ÜíG
(3)
We start with the observation
|=Taut ¬¨G ‚Üí(G ‚Üí0 = S0)
‚Ä† Cf. the informal discussion at the beginning of this chapter, p. 205.

II.6. Derivability Conditions; Fixed Points
313
Hence (absolutely)
‚ä¢¬¨G ‚Üí(G ‚Üí0 = S0)
which by (1) of II.6.40 (but using the theory ‚Ä≤ rather than ) and the Leibniz
rule implies
‚ä¢C ŒòŒì‚Ä≤(‚åúG ‚åù) ‚Üí(G ‚Üí0 = S0)
DC 1 now yields (this uses C ‚â§‚Ä≤)
‚ä¢C ŒòŒì‚Ä≤
%
‚åúŒòŒì‚Ä≤
‚åúG ‚åù

‚Üí(G ‚Üí0 = S0)‚åù
&
which further yields, via DC 2,
‚ä¢C ŒòŒì‚Ä≤
%
‚åúŒòŒì‚Ä≤
‚åúG ‚åù

‚åù
&
‚ÜíŒòŒì‚Ä≤
‚åúG ‚åù

‚ÜíŒòŒì‚Ä≤
‚åú0 = S0‚åù

L¬®ob‚Äôs DC 3 (II.6.37, which also uses C ‚â§‚Ä≤) and the above yield, by tauto-
logical implication,
‚ä¢C ŒòŒì‚Ä≤(‚åúG ‚åù) ‚ÜíŒòŒì‚Ä≤(‚åú0 = S0‚åù)
By contraposition, and using (1) of II.6.40 (for ‚Ä≤) and (‚àó‚àó),
‚ä¢C S ‚ÜíG
(4)
Since C ‚â§‚Ä≤, (4) implies (3) (via (‚àó)).
Now if ‚ä¢ Con, then also ‚ä¢‚Ä≤ Con by  ‚â§‚Ä≤. Thus (3) would yield
‚ä¢‚Ä≤ G , contradicting II.6.41 (for ‚Ä≤).
‚ñ°
(1) The above proof is clearly also valid for the trivial extension  = PA. In
this case, ‚Ä≤ = C. Moreover, we note that, since PA ‚â§C conservatively
and S ‚ÜíG is over LN, (4) implies
‚ä¢PA S ‚ÜíG
as well, from which (via PA ‚â§ ‚Äì no prime) ‚ä¢ S ‚ÜíG .
(2) It is also true that ‚ä¢ G ‚ÜíCon; thus ‚ä¢ G ‚ÜîCon (Exercise II.25).
II.6.41 and II.6.42 provide two examples of sentences unprovable by , a
consistent extension of PA with a 1 set of axioms. As remarked above, the
two sentences are provably equivalent (in ). The former says ‚ÄúI am not a
theorem‚Äù,‚Ä† and thus its unprovability shows that it is true in A, the natural
structure appropriate for LA.
‚Ä† Of ‚Ä≤ ‚Äì being a Ô¨Åxed point of ¬¨ŒòŒì‚Ä≤ ‚Äì and hence not of  either.

314
II. The Second Incompleteness Theorem
Let us put II.6.32 back into (implicit) force to avoid verbosity in the discussion
and results that follow. So we have C ‚â§.
What about a sentence that says ‚ÄúI am a theorem of ‚Äù?‚Ä† Such a sentence,
H , is a Ô¨Åxed point of ŒòŒì, since ŒòŒì(‚åúH ‚åù) ‚Äúsays‚Äù that (i.e., is true in NC iff)
 ‚ä¢H . A theorem of L¬®ob (1955) shows that such sentences are provable,
and hence true as well, since then ŒòŒì(‚åúH ‚åù) is true, and we also know that
‚ä¢ H ‚ÜîŒòŒì(‚åúH ‚åù).
II.6.43 Theorem (L¬®ob‚Äôs Theorem (1955)). Let PA ‚â§ consistently, and
assume that the formula Œì is Œ£1(LNC). Then, for any sentence A,
‚ä¢ ŒòŒì(‚åúA‚åù) ‚ÜíA
implies that
‚ä¢ A.
Proof. Equivalently, let us prove that
Ã∏‚ä¢ A
implies that
Ã∏‚ä¢ ŒòŒì(‚åúA‚åù) ‚ÜíA
So assume that Ã∏‚ä¢ A. By I.4.21,  + ¬¨A is a consistent Œ£1(LNC) extension
of C (hence of PA), that is, it is semantically deÔ¨Åned by a Œ£1(LNC) formula.
Pause. Why is  + ¬¨A Œ£1(LNC)?
By II.6.42,
Ã∏‚ä¢+¬¨A Con+¬¨A
(1)
Now, we choose as an ‚Äúimplementation‚Äù of the sentence ‚ÄúCon+¬¨A‚Äù the sen-
tence ‚Äú¬¨ŒòŒì(‚åúA‚åù)‚Äù, because of I.4.21. Thus, (1) can be written as
Ã∏‚ä¢+¬¨A ¬¨ŒòŒì(‚åúA‚åù)
Hence, by modus ponens,
Ã∏‚ä¢ ¬¨A ‚Üí¬¨ŒòŒì(‚åúA‚åù)
The contrapositive is what we want: Ã∏‚ä¢ ŒòŒì(‚åúA‚åù) ‚ÜíA.
‚ñ°
The statement in II.6.43 is actually an equivalence. The other direction is triv-
ially true by tautological implication.
‚Ä† This question was posed by Henkin (1952).

II.6. Derivability Conditions; Fixed Points
315
L¬®ob‚Äôs theorem can be proved from Ô¨Årst principles, i.e., without reliance on
G¬®odel‚Äôs second incompleteness theorem. One starts by getting a Ô¨Åxed point B
of ŒòŒì(x) ‚ÜíA in C and then judiciously applying the derivability conditions
(Exercise II.26).
Conversely, L¬®ob‚Äôs theorem implies G¬®odel‚Äôs (second) theorem: Indeed, the
tautology
¬¨ŒòŒì(‚åú0 = S0‚åù) ‚ÜíŒòŒì(‚åú0 = S0‚åù) ‚Üí0 = S0
yields‚Ä†
‚ä¢ ¬¨ŒòŒì(‚åú0 = S0‚åù) ‚ÜíŒòŒì(‚åú0 = S0‚åù) ‚Üí0 = S0
Thus
‚ä¢ Con ‚ÜíŒòŒì(‚åú0 = S0‚åù) ‚Üí0 = S0
Suppose now that ‚ä¢ Con. Then, by the above,
‚ä¢ ŒòŒì(‚åú0 = S0‚åù) ‚Üí0 = S0
Hence, by L¬®ob‚Äôs theorem, ‚ä¢ 0 = S0, contradicting the consistency of .
We have simpliÔ¨Åed the hypotheses in G¬®odel‚Äôs two theorems in allowing  to
extend PA (or, essentially equivalently, extend C in the proof of the second). The
theorems actually hold under a more general hypothesis that  contains PA (or
C). This containment can be understood intuitively, at least in the case of formal
set theory (formalized as ZFC for example):‚Ä° There is enough machinery inside
ZFC to construct the set of natural numbers (œâ) and show that this set satisÔ¨Åes
the axioms PA.¬ß One can then carry out the arithmetization of Section II.5 for
terms, formulas, proofs, and theorems, of ZFC this time, in ZFC exactly as we
did for Peano arithmetic, and prove that both incompleteness theorems hold for
ZFC.¬∂
‚Ä† Under the assumption of II.6.32 ‚Äì C ‚â§ ‚Äì ŒòŒì is in the language of .
‚Ä° The formal treatment requires the concept of interpreting one theory inside another. This is one
of many interesting topics that we must leave out in this brief course in logic. See however our
volume 2 for a complete discussion of this topic and its bearing on this comment here.
¬ß Thus, one constructs a model of PA inside ZFC. We show how this is done in volume 2.
¬∂ In other words, the elements of the set œâ will furnish us with G¬®odel numbers for the formulas and
terms of ZFC, while certain terms and formulas over œâ will allow ZFC to ‚Äúargue‚Äù about these
G¬®odel numbers.

316
II. The Second Incompleteness Theorem
II.7. Exercises
II.1. Prove that PA can actually prove axiom <3, and therefore this axiom is
dependent (redundant).
II.2. Prove in PA: ‚ä¢x ‚â§y ‚Üí¬¨y < x.
II.3. Prove in PA: ‚ä¢x + y = y + x.
II.4. Prove in PA: ‚ä¢x + (y + z) = (x + y) + z.
II.5. Prove in PA: ‚ä¢x √ó y = y √ó x.
II.6. Prove in PA: ‚ä¢x √ó (y √ó z) = (x √ó y) √ó z.
II.7. Prove in PA: ‚ä¢x √ó (y + z) = (x √ó y) + (x √ó z).
II.8. Settle the Pause regarding the displayed formula ( f ) on p. 218.
II.9. Prove the formula (LCM‚Äô) on p. 230.
II.10. Prove in PA: ‚ä¢x > 0 ‚Üíx = SŒ¥(x, S0).
II.11. Prove Lemma II.1.36.
II.12. Prove in PA: ‚ä¢x ‚â§J(x, y), and ‚ä¢y ‚â§J(x, y), where J is that of p. 234.
II.13. Prove the concluding claim in II.3.7.
II.14. Conclude the proof of Lemma II.4.6.
II.15. Prove that there is a unary formal primitive recursive predicate Œì such
that, for any formula A, Œì(‚åúA‚åù) means that A is (an instance of) a
Peano axiom.
II.16. Prove that if the formula Œì that semantically deÔ¨Ånes the nonlogical ax-
ioms of an extension of PA is Œ£1(LN‚Ä≤) then so are Proof , Deriv,
and Œò.
II.17. Settle the Pause on p. 273.
II.18. Settle the Pause on p. 289.
II.19. Prove that
‚ä¢Free(i, x) > 0 ‚àß(Term(x) = 0 ‚à®WFF(x) = 0)
‚ÜíSub(x, i, z) = x
II.20. Prove that
‚ä¢Deriv(y, x) ‚ÜíDeriv(y ‚àó‚ü®x‚ü©, x)
II.21. Show that it is not true that for arbitrary unary f
‚ä¢{ f x} = Num( f x)
II.22. Prove that if Q is ‚àÜ0(LNC) and P is introduced by P‚Éóx ‚ÜîQ (‚Éóx), then
P is primitive recursive.
II.23. Prove that the characterizing formula for the nonlogical axioms of the
theory C ‚Äì that is, Œì such that, for any formula A, Œì(‚åúA‚åù) means that
A is a nonlogical axiom ‚Äì is primitive recursive.

II.7. Exercises
317
II.24. Prove that if the one-variable formulas Q and Œì are primitive recursive
and Œ£1(LA) respectively, then the formula Q(x) ‚à®Œì(x) is Œ£1(LA).
II.25. Refer to II.6.42. Prove that it is also true that ‚ä¢ G ‚ÜíCon, and thus
‚ä¢ G ‚ÜîCon
II.26. Prove L¬®ob‚Äôs theorem without the help of G¬®odel‚Äôs second incompleteness
theorem.
II.27. Prove Tarski‚Äôs theorem (see I.9.31, p. 174) on the (semantic) undeÔ¨Ån-
ability of truth using the Ô¨Åxpoint theorem (II.6.39) to Ô¨Ånd a sentence that
says ‚ÄúI am false‚Äù.
II.28. Refer to II.6.41. Let  over LA be an œâ-consistent extension of PA such
that Œì(x) is Œ£1(LNC). Let the sentence G over LN be a Ô¨Åxed point of
¬¨ŒòŒì in C. Then Ã∏‚ä¢ ¬¨G .
II.29. Let A be any sentence in the language of a  ‚Äì where Œì(x) is Œ£1(LNC) ‚Äì
that extends PA consistently. Establish that ‚ä¢C ¬¨Œò(‚åúA‚åù) ‚ÜíCon.
II.30. With the usual assumptions on  and C (II.6.32), prove that
‚ä¢C Con ‚ÜíCon+¬¨Con


Bibliography
Barwise, Jon, editor (1978). Handbook of Mathematical Logic. North-Holland,
Amsterdam.
Bennett, J. (1962). On Spectra. PhD thesis, Princeton University.
Bourbaki, N. (1966a). ¬¥El¬¥ements de math¬¥ematique. Hermann, Paris.
(1966b). ¬¥El¬¥ements de math¬¥ematique; th¬¥eorie des ensembles. Hermann, Paris.
Chang, C.C., and H. Jerome, Keisler (1973). Model Theory. North-Holland, Amsterdam.
Church, Alonzo (1936). A note on the Entscheidungsproblem, J. Symbolic Logic, 1:40‚Äì
41, 101‚Äì102.
Cohen, P. J. (1963). The independence of the continuum hypothesis, part I, Proc. Nat.
Acad. Sci. U.S.A., 50: 1143‚Äì1148; part II 51:105‚Äì110 (1964).
Davis, M. (1965). The Undecidable. Raven Press, Hewlett, N. Y.
Dekker, James C. E. (1955). Productive sets, Trans. Amer. Math. Soc., 78:129‚Äì149.
Dijkstra, Edsger W., and Carel S. Scholten (1990). Predicate Calculus and Program
Semantics. Springer-Verlag, New York.
Enderton, Herbert B. (1972). A Mathematical Introduction to Logic. Academic Press,
New York.
G¬®odel, K. (1931). ¬®Uber formale unentscheidbare S¬®atze der Principia Mathematica und
verwandter Systeme I, Monatsh. Math. u. Phys. 38:173‚Äì198. (English transl. in Davis
(1965, pp. 5‚Äì38).
(1938). The consistency of the axiom of choice and of the generalized continuum
hypothesis, Proc. Nat. Acad. Sci. U.S.A., 24:556‚Äì557.
Grzegorczyk, A. (1953). Some classes of recursive functions, Rozprawy Mat., 4:1‚Äì45.
Gries, David, and Fred B. Schneider (1994). A Logical Approach to Discrete Math.
Springer-Verlag, New York.
(1995). Equational propositional logic, Inf. Process. Lett., 53:145‚Äì152.
Henkin, Leon (1952). A problem concerning provability, J. Symbolic Logic, 17:160.
Henle, James M., and Eugene M. Kleinberg (1980). InÔ¨Ånitesimal Calculus. The MIT
Press, Cambridge, Mass.
Hermes, H. (1973). Introduction to Mathematical Logic. Springer-Verlag, New York.
Hilbert, D., and P. Bernays (1968). Grundlagen der Mathematik I, II. Springer-Verlag,
New York.
Hinman, P. G. (1978). Recursion-Theoretic Hierarchies. Springer-Verlag, New York.
Kalm¬¥ar, L. (1957). An argument against the plausibility of Church‚Äôs thesis. In Construc-
tivity in Mathematics, Proc. of the Colloquium held at Amsterdam, pp. 72‚Äì80.
319

320
Bibliography
Keisler, H. Jerome (1976). Foundations of InÔ¨Ånitesimal Calculus. PWS Publishers,
Boston.
Fundamentals of model theory. In Barwise (1978), Chapter A.2, pp. 47‚Äì104.
(1982). Elementary Calculus; an InÔ¨Ånitesimal Approach. PWS Publishers,
Boston.
Kleene, S. C. (1943). Recursive predicates and quantiÔ¨Åers, Trans. Amer. Math. Soc.,
53:41‚Äì73, 1943. In Davis (1965, pp. 255‚Äì287).
LeVeque, William J. (1956). Topics in Number Theory, volume I. Addison-Wesley,
Reading, Mass.
L¬®ob, Martin H. (1955). Solution to a problem of Leon Henkin, J. Symbolic Logic,
20:115‚Äì118.
Manin, Yu. I. (1977). A Course in Mathematical Logic. Springer-Verlag, New York.
Mendelson, Elliott (1987). Introduction to Mathematical Logic, 3rd edition. Wadsworth
& Brooks, Monterey, Calif.
Mostowski, A. (1947). On deÔ¨Ånable sets of positive integers, Fund. Math. 34:81‚Äì112.
Rasiowa, H., and R. Sikorski (1963). The Mathematics of Metamathematics. Pa¬¥nstwowe
Wydawnictwo Naukowe, Warszawa.
Robinson, A. (1961) Non-standard analysis, Proc. Roy. Acad. Amsterdam Ser. A,
64:432‚Äì440.
(1966). Non-standard Analysis. North-Holland, Amsterdam. Revised ed., 1974.
Robinson, Raphael M. (1950). An essentially undecidable axiom system (Abstract). In
Proc. International Congress of Mathematicians, volume 1, pp. 729‚Äì730.
Rogers, H. (1967). Theory of Recursive Functions and Effective Computability.
McGraw-Hill, New York.
Rosser, J. Barkley (1936). Extensions of some theorems of G¬®odel and Church, J. Sym-
bolic Logic, 1:87‚Äì91.
Sch¬®utte, K. (1977). Proof Theory. Springer-Verlag, New York.
Schwichtenberg, Helmut (1978). Proof theory: some applications of cut-elimination. In
Barwise (1978), Chapter D.2, pp. 867‚Äì895.
ShoenÔ¨Åeld, Joseph R. (1967). Mathematical Logic. Addison-Wesley, Reading, Mass.
Smory¬¥nski, C. (1978). The incompleteness theorems. In Barwise (1978), Chapter D.1,
pp. 821‚Äì865.
(1985). Self-Reference and Modal Logic. Springer-Verlag, New York.
Smullyan, Raymond M. (1961). Theory of Formal Systems. Ann. Math. Stud. 47.
Princeton University Press, Princeton.
(1992). G¬®odel‚Äôs Incompleteness Theorems. Oxford University Press, Oxford.
Tourlakis, G. (1984). Computability. Reston Publishing Company, Reston, Virginia.
(1986). Some reÔ¨Çections on the foundations of ordinary recursion theory, and a
new proposal, Z. math. Logik, 32(6):503‚Äì515.
(1996). Recursion in partial type-1 objects with well-behaved oracles, Math.
Logic Quart. (MLQ), 42:449‚Äì460.
(2000a). A basic formal equational predicate logic ‚Äì part I, BSL, 29(1‚Äì2):43‚Äì56.
(2000b). A basic formal equational predicate logic‚Äìpart II, BSL, 29(3):75‚Äì88.
(2001a). Computability in type-2 objects with well-behaved type-1 oracles is
p-normal, Fund. Inform., 48(1):83‚Äì91.
(2001b). On the soundness and completeness of equational predicate logics,
J. Comput. and Logic, 11(4):623‚Äì653.
Veblen, Oswald, and John Wesley Young (1916). Projective Geometry, volume I. Ginn,
Boston.
Wilder, R. L. (1963). Introduction to the Foundations of Mathematics. Wiley, New York.
Whitehead, A. N., and B. Russell (1912). Principia Mathematica, volume 2. Cambridge
University Press, Cambridge.

List of Symbols
 + A, 48
z := x, 129
D(A), 88
Œ†1, 265
(‚àÉa ‚ààM) . . . , 62
{E(x1, . . . , xn)}, 299
A(y1,. . . , yk), 18
A[y1,. . . , yk], 18
‚ñ≥, 166
‚Éù, 166
, 166
Cl(I , R ), 20
‚ü®a0, . . . , an‚àí1‚ü©, 165
‚ü®t[i] : i < w‚ü©, 239
‚ü®. . . ‚ü©, 19
x ‚àóy, 243, 245
, 150
‚àû, 151
n, 151
‚àÜ0, 172
‚àÜ+
0 , 256
‚àÜ‚Ä≤
0, 256
œÜ : M ‚Üí‚â∫K, 82
M ‚â∫K, 82
Œµ-Œ¥, 109
f : A ‚ÜíB, 25
‚åúw‚åù, 155
iœÜ, 77
(a)a‚ààM, 95
L(M), 54
a ‚âàb, 104
Z, 15
(Œπz)Q , 120
K, 145
K, 145
LM, 54
Œª, 125
lcm, 157
lh(z), 137, 165
lh(x), 240
limx‚Üía ‚ó¶f (x) = b, 108
, 34, 38
aM, f M, PM, 53
(¬µx), 128
N, 15
a Ã∏‚âà0, 107
Num, 296
P, 128
n, 151
PR, 129
PR‚àó, 130
(z)i, 240
.‚àí, 131
‚àÉ!, 113
Q, 15
R, 15
R, 128
R‚àó, 130
I = I ‚Ä≤ ‚ÜæL, 54
M = M‚Ä≤ ‚ÜæL, 54
¬Øi, 54
limx‚Üía+ f (x) = b, 108
Seq(z), 137, 165
Seq, 241
n, 151
1, 256
st(h), 105
x ‚àóy, 137, 165
string
Œª, 13
‚â°, 13
M ‚äÜK, 77
T (C ), 76
Th(C ), 76
‚ü®. . . ‚ü©, 19
Wa, 143
‚Éóan, 19
‚Éóa, 19
‚Éóxn, 33
‚âÉ, 126
‚äÜ, 20
321


Index
‚àÄ-introduction, 43
absolutely provable, 37
AC, 86
Ackermann function, 198
‚àÄ‚àÉ-theory, 93
alphabet, 6, 13
alternating chain, 96
ambiguity, 24
ambiguous, 24
antisymmetry, 210
argot, 39
arithmetic, 150
arithmetic hierarchy, 151
arithmetic relations, 150
arithmetical relations, 150
arithmetization, 134, 265
arity, 8
ascending chains, 93
assignment function, 88
associativities, 17
automorphism, 196
axiom, 6
Henkin, 65
logical, 6
nonlogical, 6, 36
special, 6
axiomatic theories, 38
axiomatized, 38
axioms, logical, 34
basic diagram, 88
Bennett, J., 162
Bernays, P., 41
beta function, 159, 235
Boolean, 7
Boolean operations, 133
bound variable, 18
bounded, 112
bounded multiplication, 134
bounded product, 197
bounded quantiÔ¨Åcation, 125
bounded search, 134
bounded summation, 134, 197
Bourbaki, 5, 14, 41
Brouwer, L. E. J., 4
call by value, 144
cancellation laws, 214
categorical, 97
characteristic function, 130, 219
characteristic term, 222
Chinese remainder theorem, 160
Church, Alonzo, 124, 188
Church‚Äôs thesis, 264
class, 75
closed form, 201
closed formula, 18
closed interval, 111
closed under, 19
closure, 20
coding, 136
collection, 258
commutative diagram, 78
compact, 107
compactness theorem, 71, 74
complete, 97, 194
simply complete, 66
complete arithmetic, 39, 170
complete index set, 149, 199
completeness theorem, 52, 71, 73, 194
completion, 195
composition, 127
computability, 123
computable, 128
computable function, 124
computation, 140
323

324
Index
computation model, 126
computer program, 264
concatenate, 10
concatenation, 13, 137, 243
formal, 243, 245
conjunct, 277
conjunction, 17
conjunctionally, 216
connectives, 7
conservative, 115, 121, 218
conservative extension, 46, 118
consistency theorem, 71, 73
constant, 8
Henkin, Leon, 65
witnessing, 65
construction formative, 41
constructive arithmetic, 164, 170
constructive arithmetic predicates, 160
continuous, 111
contrapositive, 158
converges, 125
correct, 177
countable, 62
course-of-values induction, 214
course-of-values recursion, 137,
251
Craig, W., 204
C-theory, 272
decision problem, 40, 188
decoding, 136, 240
Dedekind, R., 124, 129
deduced, 37
deduction theorem, 48
deÔ¨Ånability, 60
in a structure, 60
deÔ¨Ånable, 170, 171
deÔ¨Ånable in arithmetic, 171
deÔ¨Ånition by cases, 134, 221
deÔ¨Ånition by positive cases, 200
deÔ¨Ånition by recursion, 25
‚àÜ0 formulas, 172
derivability conditions, 272, 296
derivation, 20, 254
derived rule, 38, 40
diagonalization, 125, 145
diagonalization lemma, 310
diagram, 64, 88
diagram expansion, 88
diagram language, 64, 88
Diophantine equation, 201
disjunct, 276
distributive laws, 193
diverges, 125
domain, 53
dummy renaming, 45
‚àÉ-introduction, 36
elementarily equivalent structures, 76
elementary chains, 93
elementary diagram, 88
elementary embedding, 82
elementary extension, 82
elementary substructure, 82
elimination of deÔ¨Åned symbols, 116, 118
empty sequence, 243
Entscheidungsproblem, 40, 124
enumeration theorem, 153
Œµ-term, 123
equivalence theorem, 51, 183
existential axioms, 93
existential formula, 113
expansion, 88
explicit deÔ¨Ånition, 218
explicit transformations, 160
expressions, 6
extension, 77
extensionality, 114
extreme value theorem, 197
Ô¨Ånitary, 4
Ô¨Ånite hyperreal, 102
Ô¨Ånitely satisÔ¨Åable, 195
Ô¨Årst incompleteness theorem, 155
Ô¨Åxed point, 203, 310
Ô¨Åxpoint, 203, 310
Ô¨Åxpoint theorem, 310, 317
formal, 1
beta function, 235
Formal Arithmetic, 166, 175
formal language
Ô¨Årst order, 6
formalize, 3
formally deÔ¨Ånable, 180
formally functionally deÔ¨Ånable, 202
formula
decidable by a theory, 66
mixed-mode, 61
prime, 28
propositional, 28
satisÔ¨Åable, 30
tautology, 30
unsatisÔ¨Åable, 30
formula form, 34
formula schema, 34
free for, 32
free variable, 18
function
computable, 128
partial computable, 128
partial recursive, 128
primitive recursive, 129
recursive, 128

Index
325
G¬®odel number, 155
generalization, 43
Gentzen, Gerhard, 193
G¬®odel, Kurt, 124
G¬®odel-Mal‚Ä≤cev compactness theorem, 74
G¬®odel-numbering, 155
G¬®odel-Rosser Ô¨Årst incompleteness
theorem, 189
G¬®odel‚Äôs Ô¨Årst incompleteness theorem, 177,
202, 317
G¬®odel‚Äôs second incompleteness theorem, 312
graph, 98, 161, 163, 199, 202
greatest common divisor, 157
gcd, 157
Gries, David, 5
group theory, 92
groups, 93
Grzegorczyk, A., 132
g-term, 296
halting problem, 145
halting set, 145
Henkin, Leon, 62, 112, 314
Henkin theory, 66
Hermes, H., 41
Heyting, A., 4
hierarchy theorem, 154
Hilbert, D., 4, 41
history function, 137
hyperreal numbers, 99
hyperreals, 99
I.H., 22
i.p., 24
Identities, 128
iff, 11
immediate predecessors, 24
implied multiplication notation, 212
inclusion map, 77
incompletable, 177
incompletableness, 124
inconsistent, 265
increasing chains, 93
indeÔ¨Ånite article, 121
indexing theorem, 153
individual variables, 7
induced isomorphism, 78
induction axiom, 206
induction axiom schema, 206
induction hypothesis, 22
induction rule, 208
induction schema, 206
inductive deÔ¨Ånitions, 20
inductive theories, 93
inÔ¨Ånite hyperreal, 102
inÔ¨Ånite natural numbers, 196
inÔ¨Ånite prime, 197
inÔ¨Ånitely close, 104
inÔ¨Ånitesimal 97, 102
inÔ¨Åx, 14, 98
informal, 8
initial functions, 128
input, 19
intermediate value theorem, 197
interpretation, 53
iota notation, 120
irreÔ¨Çexive, 210
irreÔ¨Çexivity, 210
iteration theorem, 148
iteratively, 21
Œ∫-categorical, 97
Keisler, H. Jerome, 88
Kleene, S. C., 124, 150
Kleene normal form theorem, 142
Kleene predicate, 164
Kleene schemata, 127, 264
Kleene T -predicate, 142
Kleene‚Äôs recursion theorem, 149
Kronecker, L., 4
Œª-notation, 125
language
extension, 54
Ô¨Årst order, 16
restriction, 54
least common multiple, 157, 230
least principle, 216
left endpoint, 111
left Ô¨Åeld, 125
Leibniz, G. W., 34
Leibniz rule, 51
limit ordinal, 73
Lindemann, F., 4
L¬®ob, Martin H., 310, 314
L¬®ob‚Äôs derivability condition, 310
L¬®ob‚Äôs theorem, 314
logical symbols, 7
logically implies, 52
L¬®owenheim-Skolem theorem, 71
Manin, Yu. I., 39
Markov, A. A., 127
material implication, 17
mathematical theory, see theory
maximum, 230
metalanguage, 3
metamathematics, 3
metatheory, 3
metavariable, 207
modus ponens, 36
monotonicity, 50

326
Index
monus, 131
Mostowski, A., 150
MP, 36
¬µ-deÔ¨Ånitions, 218
¬µ-term, 218
neighbourhood, 108
non-monotone, 265
non-standard hyperreals, 99
non-standard numbers, 99
nontotal, 125
Num function, 296
number-theoretic functions, 124
numeral, 41, 171
object variables, 7
occurrence, 13
occurs in, 13
œâ-consistent, 189
œâ-incompleteness, 190
œâ-inconsistent, 191
œâ-rule, 190
one point rule, 118
onto, 62
open, 92
open formulas, 91
open theory, 91
operations of substitution, 132
ordered sequence, 19
ordinary computability, 124
ordinary recursion theory, 124
output, 19
pairing function, 156
parsable, 29
parse, 21
partial computable, 128
partial function, 125
partial recursive, 128
Peano arithmetic, 206
œÜ-index, 138
œÄ-function, 198
pinching lemma, 106
polynomial, 201
positively strongly deÔ¨Ånable, 191, 202
Post, E. L., 124, 194
Post‚Äôs theorem, 194
predicate, 8, 130
preÔ¨Åx, 13
prime power coding, 136
primitive recursion, 127
primitive recursive, 129, 170, 253
primitive recursive deÔ¨Ånitions, 248
primitive recursive functions, 124, 127
primitive recursive schema, 127
priorities, 17
problem, 144
productive function, 179
productive sets, 179
programming language, 264
projection, 128
projection function symbols, 254
projection functions, 156
projection theorem, 147
proof, 37
-, 37
proof by auxiliary constant, 52
proof by cases, 183
proof by contradiction, 50
proper preÔ¨Åx, 13
proper subtraction, 131, 222
propositional connectives, 7
propositional axioms, 194, 269
propositional calculus, 194
propositional logic, 194
propositional segment, 194
propositional valuations, 29
propositional variable, 28
provability predicate, 280, 311
provably equivalent, 42
proved from, 37
punctured neighbourhood, 108
Quine, W. V. O., 156
R-closed, 20
r.e. predicate, 147
Rasiowa, H., 41
real function, 108
recursion, 19
recursion theorem, 149
recursion theory, 123
recursive, 128, 130, 170
recursive deÔ¨Ånition, 20
recursive extension, 220, 262, 265,
273
recursively axiomatizable, 39
recursively axiomatized, 38, 271
recursively enumerable predicate, 147
recursively inseparable, 187
recursively unsolvable, 144
regular, 171
regular formula, 171
regular functions, 204
relation, see predicate, 8, 19
primitive recursive, 130
recursive, 130
relational notation, 125
relatively prime, 157, 226
remainder function, 224
restricted atomic formulas, 256
restriction, 78

Index
327
Rice, H. G., 149
right endpoint, 111
right Ô¨Ånite limit, 108
right positive inÔ¨Ånite limit, 108
Robinson, Abraham, 64
Robinson, R. M., 175
Rosser, J. Barkley, 189
rudimentary functions, 174
rules of inference, 6
Russell‚Äôs paradox, 145
S-m-n theorem, 148
satisÔ¨Åable, 55
Ô¨Ånitely, 55
schema instance, 34
Schneider, Fred B., 5
scope, 15
selection theorem, 199
semi-recursive, 170
semi-recursive index, 143
semi-recursive relations, 143
semigroups, 93
sentence, 18
separation, 114
sequence, 229
sethood, 17
signum, 133
Sikorski, R., 41
simple completeness, 62
simultaneous substitution, 33
single-valued, 86
Skolem function, 123
sort, 17
soundness, 58
special Henkin axiom, 73
specialization, 43
stage, 23
standard hyperreals, 99
standard numbers, 99
standard part, 105
string
empty, 13
equality, 13
preÔ¨Åx, 13
proper, 13
strong projection theorem, 143
strongly deÔ¨Ånable, 186
strongly formally deÔ¨Ånable, 186
strongly term-deÔ¨Ånable, 187
strongly ¬µ-recursive, 204
structure, 53
domain of, 53
embedding, 77
expansion of, 54, 119
extension of, 77
reduct of, 54
underlying set of, 53
universe of, 53
structure embedding, 77
structure isomorphism, 77
structures, elementarily equivalent, 76
substitutable for, 32
substitution, 31
simultaneous, 33
substitution function, 175, 268
substring, 9, 13
substructure, 77
successor, 73, 128
syntactic variable, 14, 207
T-Predicate, 142
table, 19
Tarski, Alfred, 170, 175
Tarski‚Äôs theorem, 174, 317
œÑ-term, 123
tautology theorem, 194
term, primitive recursive, 254
term-deÔ¨Ånable, 181, 252
term-deÔ¨Åned, 181
theorem, 36
-, 36
theorem schema, 40
theory, 38
absolute, 39
‚àÄ‚àÉ, 93
applied, 39
C, 272
conservative extension of, 46
consistent, 38
contradictory, 38
decides, 66
extension of, 46
Ô¨Årst order, 38
Henkin, 66
inconsistent, 38
inductive, 93
open, 91
pure, 39
recursively axiomatized, 176
refutes, 66
semantically complete, 62
simply complete, 66
sound, 56
universal, 91
total, 98, 125
transfer principle, 99
transÔ¨Ånite sequence, 72
transitive, 209
transitivity of ‚ä¢, 37
truth (value) assignment, 29
truth functions, 30
Turing, Alan, 124

328
Index
Turing machines, 127, 264
two-sided Ô¨Ånite limit, 108
type, 17
unambiguous, 24
unary, 17
unbounded search, 127, 216
uncomputability, 124
undeÔ¨Ånability of truth, 204
underlying set, 53
union, 22
uniquely readable, 29
universal, 265
universal closure, 44
universal quantiÔ¨Åer, 17
universal sentences, 94
universal theory, 91
unsolvable, 145
vacuously satisÔ¨Åed, 31
valid, 55
logically, 55
universally, 55
valuation, 29, 195
variable
bound, 18
free, 18
frozen, 49
variant, 35, 45
Veblen, Oswald, 52
vector notation, 19
weak equality, 126
weak projection theorem, 147
weakly deÔ¨Ånable, 203
Weierstrass, Karl, 109
witness property, 66
witnessing constant, 73
Young, John Wesley, 52
zero, 128
zero function symbol, 254
Ziffern, 41

