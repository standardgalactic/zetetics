Dyadic versus triadic sign models in
functional and object-oriented computer
programming paradigms*
KUMIKO TANAKA-ISHII
Abstract
The correspondence between the triadic sign model proposed by Peirce and
the dyadic sign model proposed by Saussure is examined. Traditionally, it
has been thought that Peirce’s interpretant corresponds to Saussure’s signi-
ﬁed and Saussure’s model lacks Peirce’s object. However, our analysis of
the two most widely used computer programming paradigms suggests that
Peirce’s object formally corresponds to Saussure’s signiﬁed, and that Saus-
sure’s sign model is obtained when Peirce’s interpretant is located outside of
his model in the language system.
Keywords:
dyadic and triadic sign models; object-oriented programming;
functional programming; identiﬁers; semiosis; system.
1.
The question
Semiotics has long had two sign models, the dyadic model proposed by
Saussure and the triadic model proposed by Peirce. In fact, the inherent
di¤erence separating these two models has been recognized since the be-
ginning of the philosophy of language (Noth 1990). Figure 1 summarizes
the dyadic model and the triadic model.
The earliest expression of a dyadic model is found in the philosophy of
Augustine in the fourth century. Following this tradition, among the
scholastics, signs were regarded as ‘aliquid stat pro aliquo’; that is, some-
thing stands for something else. At that time, signs functioned as labels
(aliquid, sign vehicle), naming preexisting objects (aliquo, meaning). At
the beginning of the twentieth century, Saussure advocated that it is actu-
ally the sign vehicle that deﬁnes the meaning, thus changing the function
of signs. To escape from the notion of ‘labeling’ connoted by preexisting
Semiotica 158–1/4 (2006), 213–231
0037–1998/06/0158–0213
6 Walter de Gruyter

terms, he named two sides of signs as signiﬁer (corresponding to a sign
vehicle) and signiﬁed (corresponding to meaning) and asserted that they
are two inseparable aspects of a sign.
The earliest expression of a triadic model appears in the philosophy of
Plato, where an object calls its idea in the human’s mind and thus leads to
the label. Traditionally, triadic models had a sign vehicle that pointed to
a referent and these two were connected by a sense. In parallel to what
happened with the dyadic model in the nineteenth century, Peirce said
that the order of three elements appearing in the mind is not as Plato
said: it is the representamen (sign vehicle) that evokes an interpretant
(sense) deﬁning the object (referent). This is founded on Peirce’s pan-
semiotic philosophy. The existence of signs prior to sense and referent is
now shared by most philosophers who have adopted the triadic model,
such as Ogden and Richards (1989 [1923]).
Thus, there have been two models of signs for many years. However,
the relationship between these two models has been controversial, ex-
cept for the notion of sign vehicle. Both dyadic and triadic models in-
clude the notion of a sign vehicle that functions by evoking a cognitive
image inside the human mind. The authors of the existing literature
generally agree that Peirce’s representamen, Ogden’s symbol, Saussure’s
signiﬁer, and Hjemslev’s expression all correspond to one another. How-
ever, as for the other relata, Noth (1990: 93) states that the ‘history of
the sense-reference dichotomy before and after Frege is a Babylonian
confusion.’
In Noth, two models are summarized as follows:
Figure 1.
Dyadic and triadic sign models and previously proposed correspondences of the
relata
214
K. Tanaka-Ishii

Triadic models distinguish between sign vehicle, sense, and reference as the three
relata of the sign. Dyadic models ignore either the dimension of reference or that
of sense. (Noth 1990: 93)
In the chapter on Saussure, Saussure’s model is characterized as follows:
‘The distinctive feature of its bilaterality is the exclusion of the referential
object’ (Noth 1990: 59). Moreover, in the chapter on ‘Meaning, Sense,
and Reference,’ Noth shows the contrast between reference and sense in
a table: sense corresponds to Saussure’s signiﬁed and reference corre-
sponds to Saussure’s thing, whereas sense corresponds to Peirce’s inter-
pretant and reference corresponds to Peirce’s object (Noth 1990: 94,
ﬁg. M 3). From these correspondences, we can infer that Noth regards
Peirce’s interpretant as corresponding to Saussure’s signiﬁed and Peirce’s
object as corresponding to Saussure’s thing.
Eco also discusses the correspondence between the dyadic and triadic
models (Eco 1979; 1988), and provides a ﬁgure (Eco 1988: ﬁg. 1.2.3)
showing the correspondence between Saussure’s ‘concept’ and Peirce’s
‘interpretant.’ Saussure repeatedly uses the term ‘concept’ to explain and
deﬁne his signiﬁed (Saussure 1993), again indicating that Peirce’s interpre-
tant corresponds to Saussure’s signiﬁed. This is justiﬁed in his other liter-
ature on semiotics where Eco states ‘Objects are not considered within
Saussure’s linguistics’ (Eco 1979: 60). Through the correspondence with
the sign model presented by Frege, Eco situates the Peirce object as a
‘real and actual object.’
Consequently, according to Noth and Eco, two eminent writers on se-
miotics, the correspondence of sign models in Saussure and Peirce can be
stated as follows:
—
Saussure’s signiﬁer and Peirce’s representamen correspond, and
—
Saussure’s sign model does not include a referential object, therefore,
—
Saussure’s signiﬁed and Peirce’s interpretant correspond.
To verify this correspondence, we next examine the deﬁnitions of relata in
the sign models of Peirce and Saussure.
2.
Another hypothesis based on Peirce and Saussure’s deﬁnitions
Peirce explains his object as:
The Sign stands for something, its object. It stands for that object, not in all
respects but in reference to a sort of idea. (CP 2.228)
Dyadic versus triadic sign models
215

In the latter sentence, ‘not in all respects’ is explained mainly by his dis-
tinction between two types of object: the immediate and the mediate ob-
ject. The immediate object is ‘as the Sign itself represents it, and whose
Being is thus dependent upon the Representation of it in the Sign’ (CP
4.536). As expressed by Peirce as ‘a sort of idea,’ the immediate object is
interpreted as ‘the mental representation of an object’ by Noth (1990). In
contrast, the mediate object is the ‘Object outside of the sign,’ or ‘the Re-
ality which by some means contrives to determine the Sign to its Repre-
sentation’ (CP 4.536). Therefore, Peirce’s object included in his sign
model is the immediate object, which is actually the mental representation
of an object.
These two distinctions regarding Peirce’s object raises the question of
whether the object actually corresponds to Saussure’s thing, because
Saussure’s thing is a real world object. More precisely, Peirce’s mediate
object corresponds to Saussure’s thing, both referring to a real world ob-
ject. However, Peirce’s immediate object does not correspond, as it is
mental in nature. It is more likely to correspond to Saussure’s signiﬁed,
which is explained as follows:
Le signiﬁant 3(est auditif )4 et le signiﬁe´ 3(est conceptuel)4 sont les deux e´le´ments
composant le signe. (Saussure 1993: 93)1
Consequently, there is the possibility that Saussure’s signiﬁed corresponds
to Peirce’s immediate object.
The other relatum of Peirce, the interpretant, he deﬁnes as:
A sign addresses somebody, that is, creates in the mind of that person an equiva-
lent sign, or perhaps a more developed sign. That sign which it creates I call the
interpretant of the ﬁrst sign. (CP 2.228)
Peirce’s objective of semiotic study concerned the formulation of hu-
man semiosis and this interpretant plays a crucial role in semiosis pro-
duction. The interpretant of a representamen calls other representamens
which evoke other interpretants leading to an inﬁnite semiosis. To have
this function evoke semiosis, Peirce explains interpretant with respect to
the term ‘interpretation’ (CP 8.184). Peirce’s sign model thus encapsulates
not only the mental representation of an object, but also interpretations
of the object.
Now, clariﬁcation is needed as to where this ‘interpretation’ of the ob-
ject is situated in Saussure’s model. If Saussure encapsulates this in his
sign model, then, it should be inside the signiﬁed (because there is no
other relatum), but how much Saussure’s ‘signiﬁed,’ ‘concept’ comprise
is not clariﬁed in his students’ notes (Saussure 1966; 1968; 1993).
216
K. Tanaka-Ishii

Another aspect of Saussure’s model is that the value of signs not only
exists in the signiﬁed, but also outside of his model. Saussure uses the
notion of ‘di¤erence,’ which is explained as:
On peut exprimer autrement encore ce que nous avons dit en groupant autour du
terme valeur, en posant ce principe: il n’y a dans la langue (c’est-a`-dire dans un
e´tat de langue) que des di¤e´rences. Di¤e´rence implique pour notre esprit deux
termes positifs entre lesquels s’e´tablit la di¤e´rence. (Saussure 1993: 141)2
This thought can also be seen in his emphasis on the sign world as a ho-
listic ‘syste`me,’ where the values of signs exist within the total language
system. This di¤erence among signs appears only in the presence of other
signs: their use. Then, it is likely that in Saussure’s model, the use of a
sign is not incorporated in the sign model, and exists as a holistic value
in the system.
Overall, another hypothesis is raised here that Saussure’s signiﬁed cor-
responds to Peirce’s immediate object and Peirce’s interpretant is located
outside of the sign model, in Saussure’s language system. Note that the
dimension of reference or sense is not ignored as is stated in Noth (1990);
rather, the interpretant is just situated outside the sign model, appearing
as di¤erence in use. This hypothesis is also consistent with two di¤erent
views by Peirce and Saussure as to how a chain of signs as language use
is generated. Peirce thought that a semiosis is generated successively
by evoking an interpretant incorporated in each sign, whereas Saussure
thought that a sign is used by some other sign, which is used by some
other sign, and so on, where the relationship between signs does not exist
in the sign model itself, but exists in the language system.
One way to justify this hypothesis is to show a signiﬁcant example to
which this hypothesis applies. In this paper, we show that this hypoth-
esis applies to computer programming languages. Current computer pro-
grams are based on two types of paradigm: the object-oriented paradigm,
which is based on triadic modeling of signs, and the functional paradigm,
which is based on dyadic modeling.
In the next section, we discuss programming languages from a semiot-
ics viewpoint.
3.
Programming language and semiotics
A programming language is an artiﬁcial language that describes data and
operation to control computers (Sethi 1996). A program is a text created
by a human programmer according to a software speciﬁcation. As all
Dyadic versus triadic sign models
217

information handled by computers ultimately consists of ones and zeros
which are represented by electric signals passing through circuits, the
world of programming languages is formed only of signs.
Though programming languages have been one of the most successful
artiﬁcial sign systems, semiotic analysis of programming languages has
attracted attention only recently. The earliest mention of this topic was a
brief four-page article in ACM magazine (Zemanek 1966) that empha-
sized the importance of semiotic analysis of programming languages.
For an actual study that analyzed the computing domain, we had to
wait until the work done by (Andersen 1997; Andersen et al. 1993). Their
major work was in modeling software in terms of programmers and users
based on the sign theory of Hjemslev. Their work is important in that it
opened the domain of proper semiotic analysis of software, and moreover
opened the domain of computational semiotics. Computational semiotics
can potentially provide the semiotics domain with ideas generated with
regard to software, and alternatively the programming language domain
can obtain ideas generated in semiotics.
A characteristic of programming languages makes them a promising
target for semiotic analysis: a programming language has to be a rigid
language as it must ultimately be interpreted and executed on machines.
Rigidness can be restated as being e‰cient and minimal, with the least
possible ambiguity. Yet compared with other languages, apart from natu-
ral languages, programming languages are fairly complex as they are
designed for humans to manipulate. They are complex enough for there
to be similarities between programming and natural languages. For ex-
ample, Connolly and Cooke (2004) recently analyzed the pragmatics of
computer programs, and showed that much of linguistic pragmatics ap-
plies to programming. Therefore, programming languages help to sim-
plify and highlight some controversies regarding natural language.
Our analysis has this view in common with previous work, and focuses
on solving the question of how the correspondences between the dyadic
and triadic models of signs should be revised. We conduct our analysis
through identiﬁers, the user-deﬁned signs inside programs. We next ex-
plain identiﬁers by using a program example.
4.
Identiﬁers
Programs are written using signs of which there are brieﬂy four kinds:
reserved words, identiﬁers, literals, and operators. Literals consist of
constant values such as numbers, whereas operators consist of special
signs such as ‘¼’ (assignment), ‘|’ (indicating ‘or’), ‘þ’ (addition), ‘*’
218
K. Tanaka-Ishii

multiplication, parentheses, numbers, quotation marks, and so on. All
signs that begin with alphabetic characters are either reserved words or
identiﬁers. Reserved words are signs that are predeﬁned in the language
system. Identiﬁers are signs that are deﬁned and utilized by programmers
inside programs. An identiﬁer represents a data structure and/or a func-
tion, the essential existence inside computers. The choice of signs is left up
to programmers, so the identiﬁers in programs are arbitrary.
An identiﬁer always involves (1) a deﬁnition and (2) a use. This con-
trasts with natural language, where signs do not have a deﬁnition phase
and terms are predeﬁned by social convention (Saussure 1993). An identi-
ﬁer is deﬁned by means of other signs, standing for what it is going to
represent. This resembles the case in natural languages, where words are
sometimes explained by using other signs. The largest di¤erence is that a
recursive data structure or function deﬁnition is commonly used in com-
puter programs, but the calculation should be carefully designed to avoid
creating inﬁnite loops. In programming language, this is realized by pro-
viding basic data types such as integers, booleans, or basic functions such
as addition and multiplication, and users then deﬁne their own data and
functions through their combination. Once deﬁned, identiﬁers are used by
other calculation processes.
4.1.
An example
An example program is shown in Figure 2. The program is written in the
Haskell programming language (Thompson 1999). Signs formed of with
alphabetic characters in this program, other than the following, are iden-
tiﬁers: data (declaration of new data deﬁnitions) and do (executes subse-
quent expressions successively). Among the identiﬁers, the following are
predeﬁned in libraries; i.e., a set of programs prepared by a professional
programmer for general use: pi (gives the ratio of the circumference of a
circle to its radius), putStr (prints out a string on the display), and show
(converts data into a string).
Lines 1, 2, and 3 represent the deﬁnition of new data structures of
Coordinate, Shape, Rectangle, and Circle; lines 5 and 6 deﬁne a function
area; lines 8 and 9 use the data structures Rectangle and Circle to allocate
an actual rectangle and a circle and deﬁne them by the names a_rectangle
and a_circle; and lines 11, 12, and 13 use the thus deﬁned functions and
data.
The identiﬁer Rectangle is deﬁned in line 2 by a Coordinate and two
decimals (denoted as Double). The data Coordinate is deﬁned in line 1
as a pair of decimals. The use of Rectangle is seen in line 8, where a
Dyadic versus triadic sign models
219

rectangle with coordinates (10,10), width 30, and height 20 is allocated,
and then assigned to another identiﬁer a_rectangle. A similar deﬁnition
and use can be seen for Circle and a_circle. A function area is deﬁned in
lines 5 and 6 for calculating the area sizes of rectangles and circles. In the
deﬁnition, other identiﬁers ( p, w, h, and r) are deﬁned on the left side and
used on the right side.
The function area is used in lines 11 and 13 to calculate the area for
a_rectangle and a_circle, then the result is printed using the putStr func-
tion. The output of this program looks like:
600.0 2827.4333882308138
where the ﬁrst and second outputs respectively correspond to the area
sizes of a_rectangle and a_circle.
4.2.
Semantics layers of identiﬁers
Once written, programs are interpreted and executed on computers. First,
a program text is syntactically analyzed, optimized if necessary, and com-
piled. The program is then executed on machines. In this phase, each
identiﬁer corresponds to an address inside the machine’s main memory.
Some identiﬁers can be removed if inline or macro expansion is used,
where identiﬁers are automatically replaced by the codes that they
1
data Coordinate ¼ Coordinate Double Double
2
data Shape ¼ Rectangle Coordinate Double
Double
3
Circle Coordinate Double
4
5
area (Rectangle p w h) ¼ w * h
6
area (Circle p r) ¼ pi * r * r
7
8
a_rectangle ¼ Rectangle (Coordinate 10 10) 30 20
9
a_circle ¼ Circle (Coordinate 10 10) 30
10
11
main ¼ do putStr (show (area a_rectangle))
12
putStr " "
13
putStr (show (area a_circle))
Figure 2.
A Haskell program example
220
K. Tanaka-Ishii

represent. Whether to expand is controlled by the programmer through
use of a reserved word provided in the language. However, any program
can be executed without such expansion. Therefore, each identiﬁer can be
regarded as corresponding to a memory address. At the location of the
assigned address is the content that the identiﬁer represents.
Historically speaking, identiﬁers were memory addresses in early pro-
gramming languages. In many early assembly languages, the programmer
had to calculate free locations in the memory and had to indicate the spe-
ciﬁc address of the temporal data storage. This put a considerable burden
on programmers with regard to the administration of free memory space,
as well as making program reusability questionable as each address had
no particular meaning for programmers. Therefore, the whole process of
memory administration is now automated. In addition, addresses now ac-
quire signs — the identiﬁers.
Such generation and execution of programs indicate that there are dif-
ferent phases of identiﬁer interpretation. In each process, identiﬁers are
processed using di¤erent semantics.
—
Semantics in Natural Language
Programs are interpreted by humans as well as by machines. They
are read not only by the programmers who wrote the programs, but
also by other programmers who will modify and reuse them. For all
programmers, the identiﬁers give clues to the intent of the programs.
For example an identiﬁer named Rectangle suggests that the cor-
responding data is supposed to represent a rectangle. As explained,
any identiﬁer can be deﬁned and introduced by the programmer and
identiﬁers are arbitrary: for example, a term like ‘oo7rto8rsdlkfjlau-
wet’ can be used instead of Rectangle. However, if a programmer
wants his program to be readable, Rectangle is a better identiﬁer, be-
cause the terms used as identiﬁers transmit meanings just like terms
in natural language. Therefore, programmers are trained to choose
meaningful identiﬁers from a natural language viewpoint. In this
sense, identiﬁers can be analyzed just like signs in natural language.
—
Semantics in Programming Language
All identiﬁers are deﬁned and used in a program. This deﬁnition and
use provide identiﬁer semantics to be interpreted by compilers and
interpreters. Much work deﬁning the formal semantics of programs
using mathematics and logic has been reported (Gunter 1992; Ten-
nent 1991).
—
Semantics in Machine Language
A memory address assigned to every identiﬁer is what an identiﬁer
actually is, giving a meaning to the identiﬁer. The memory address
Dyadic versus triadic sign models
221

represents the direct being of the identiﬁer. An identiﬁer is a conno-
tation of the actual memory address on computers. A programmer
who is knowledgeable regarding compilers will think topologically
about which identiﬁers are located close together to make programs
work more e‰ciently. However, many programmers now have little
need to think about the actual address given to an identiﬁer, because
the address assignment to an identiﬁer is done automatically by
compilers. Therefore, the semantics at the machine language level is
now used mainly by machines, and programmers tend to handle pro-
grams only at higher levels.
The ﬁrst layer can be similarly analyzed as in natural language, and the
last layer of memory exactly reﬂects the second layer, as programs are
compiled automatically. In this paper, we are interested in the second
layer. Unlike the other semantic analyses of programming languages
mentioned above, our methodology is based on semiotics, especially the
application of the Saussure and Peirce sign models and determination of
the correspondence among relata.
5.
Two programming paradigms
5.1.
Another program example
Another program, this time in Java language (Arnold et al. 2000), is
shown in Figure 3. This program gives exactly the same output as the
Figure 2 program. As in the previous program, identiﬁers such as Rectan-
gle, Circle, area, and a_rectangle are used. The program includes several
reserved words such as abstract, class, and new, but we only explain the
overall meaning of this program and highlight just what is needed in the
discussion below.
A class Rectangle is deﬁned in line 12 as being a data composite of lines
12 to 23. It is a data structure having lower_left coordinates (line 13), and
width and height (line 14). An instance of class Rectangle is allocated in
memory by a constructor function Rectangle in line 16. Note that the
Rectangle of line 16 and that of line 12 di¤er: Rectangle of line 12 is a
class name, whereas Rectangle of line 16 is the name of a function used
for initializing and allocating new data belonging to that class. This is
due to a Java language requirement that constructor functions have the
same name as the class. The class also contains a member function, in
this case the area function which calculates the area size of a rectangle
(height multiplied by width). Similarly, the identiﬁer of the class Circle is
deﬁned in lines 25 to 36.
222
K. Tanaka-Ishii

1
class Coordinate{
2
double x,y;
3
Coordinate(double a, double b){
4
x ¼ a; y ¼ b;
5
}
6
}
7
8
abstract class Shape{
9
abstract double area();
10
}
11
12
class Rectangle extends Shape{
13
Coordinate lower_left;
14
double width, height;
15
16
Rectangle(double x, double y, double w, double h){
17
lower_left ¼ new Coordinate(x,y);
18
width ¼ w; height ¼ h;
19
}
20
double area(){
21
return width * height;
22
}
23
}
24
25
class Circle extends Shape{
26
Coordinate center;
27
double radius;
28
29
Circle(double x, double y, double rr){
30
center ¼ new Coordinate(x,y);
31
radius ¼ rr;
32
}
33
double area(){
34
return Math.PI * radius * radius;
35
}
36
}
37
38
public class RectangleMain{
39
public static void main(String[] args){
40
Rectangle a_rectangle ¼ new Rectangle(10,10,20,30);
41
Circle a_circle ¼ new Circle(10,10,30);
42
System.out.print(a_rectangle.area()þ" "þa_circle.area());
43
}
44
}
Figure 3.
A Java program example
Dyadic versus triadic sign models
223

These two classes are used in lines 40 and 41 by allocating a rectangle
with lower left coordinates of (10,10), width 30, and height 20 and a circle
with lower left coordinates of (10,10) and diameter 30, each represented
by identiﬁers a_rectangle and a_circle. Their area sizes are calculated in
line 42.
5.2.
Functional vs. object-oriented paradigms
There is a large di¤erence between the ﬁrst program example and the sec-
ond. In the ﬁrst, the function area is located outside of the deﬁnition of
data Rectangle and Circle, whereas in the second it is encapsulated inside.
The question addressed here is how to express the fact that the calculation
of area di¤ers according to each type of shape.
In the ﬁrst program, the question is solved on the function side by
changing the calculation method according to what shape it receives as
an argument. The area function that is deﬁned in lines 5 and 6 and called
in lines 11 and 13 is unique, being located at the same place inside mem-
ory after compilation.
In contrast, in the second program, the question is solved by making
the function area belong to Rectangle and Circle. They are two separate
functions, each containing a speciﬁc deﬁnition to calculate the area size of
either Rectangle or Circle only. After compilation, they are located at dif-
ferent places in the memory. Here, the function area is regarded as a func-
tionality belonging to the data class of Rectangle and Circle.
This a¤ects the use of a function to calculate the area of shapes. This
can be seen by comparing lines 11 and 13 of Figure 2 with line 42 of Fig-
ure 3. The function area in Figure 2 takes either a_rectangle or a_circle as
arguments: from a data viewpoint, they are referred to from elsewhere in
the system. In contrast, in Figure 3 the notation a_rectangle.area( ) signi-
ﬁes that the data a_rectangle is calling the function area which belongs to
Rectangle.
The ﬁrst program was written using a paradigm called functional pro-
gramming (Bird 1998). In this paradigm, programs are executed through
the evaluation of functional expressions. A function is a mapping of a
set to another output set, and in programs a function is applied to input
data to obtain the output. In this paradigm, functions are treated as
ﬁrst-order objects, so functions that apply to data or functions are de-
ﬁned outside of the data deﬁnition. Thus, the deﬁnition of an identiﬁer
becomes minimal. The actual execution then proceeds through a func-
tion or by data being called by another function existing outside of its
deﬁnition.
224
K. Tanaka-Ishii

On the other hand, the second program was written using another
paradigm, object-oriented programming. In these languages, programs
are written based on objects, each of which models a concept or an object
consisting of functions and features that constitute the object. The em-
phasis on objects makes it easier to package data and functionality to-
gether into units within a program; objects are the basis of modularity
and structure in an object-oriented computer program. Therefore, the def-
inition of an object contains maximally what is related to it. The execu-
tion proceeds by calling what is already incorporated inside the deﬁnition.
These two kinds of identiﬁer are the main di¤erence between the two
most widely used paradigms in the programming language domain. In the
next section, we apply the Saussure and Peirce sign models to these two
paradigms.
6.
Functional/object-oriented paradigms, Saussure/Peirce models
There are two types of identiﬁer in the two programs of Figure 2 and
Figure 3: one is dyadic and stands for either a function or data, while
the other represents both functions and data. In functional programs, all
identiﬁers are dyadic, whereas in object-oriented programs, dyadic and
triadic identiﬁers are both seen. For example, the identiﬁer area in line
20 is dyadic in that it stands for only a procedure, whereas identiﬁers
such as Rectangle or Circle in either line 12 or 25 are triadic in that they
represent both data and its functionalities. This mixture in object-oriented
language is a historical consequence of all identiﬁers originally being dy-
adic and the object-oriented paradigm was gradually incorporated into
the language.
The philosophy of the object-oriented paradigm is expressed by triadic
identiﬁers, because the key point of the object-oriented paradigm is the
encapsulation of data and functionality together. From here, we distin-
guish between dyadic and triadic identiﬁers as representing functional
and object-oriented paradigms, respectively. Next, we explain how Saus-
sure’s model applies to dyadic identiﬁers and Peirce’s model applies to
triadic identiﬁers.
6.1.
Functional paradigm and Saussure
We start with the functional paradigm and Saussure. First, a signiﬁer
corresponds to the identiﬁer that represent its deﬁned content. For exam-
ple, the name Rectangle is a signiﬁer, standing for the data constituents
Coordinate and two Doubles, as signiﬁed. More precisely, Rectangle is
Dyadic versus triadic sign models
225

inseparably deﬁned as the set of Coordinate and two Doubles: with the
name Rectangle, the set of constituents are put together. This is done by
conceptualizing, or modeling, a rectangle as a combination of these three
data. Such correspondence of signiﬁer and signiﬁed also holds for identi-
ﬁers that stand for functions: the function name is a signiﬁer representing
a procedure as signiﬁed.
These identiﬁers are used by being called from some other signs inside
the program. For example, a_rectangle is called by function area. Note
that the deﬁnition of Rectangle does not show any relationship with the
function area. It is only area that knows it can have Rectangle as an argu-
ment. This fact that area can take Rectangle as an argument adds value
to the sign Rectangle. Therefore, in the functional paradigm, dyadic iden-
tiﬁers acquire meaning by how they are used.
Then, as in Saussure’s theory, di¤erence plays an important role. This
can be seen from two identical deﬁnitions with di¤erent identiﬁers not be-
ing redundant or meaningless in the functional paradigm. For example, in
the left program of Figure 4, data structures X and Y are identical but
named di¤erently. This does not make X and Y redundant, because they
are used by functions in di¤erent ways and this di¤erence in use means
that di¤erent values are given to X and Y; that is, X is used by funX (incre-
ment X) but not by funY, whereas Y is used by funY (decrement Y ) but not
by funX. Thus, X and Y can be distinguished through their use di¤erence.
6.2.
Object-oriented paradigm and Peirce
In the object-oriented paradigm, the identiﬁer corresponds to Peirce’s
representamen and Peirce’s objects are data constituents. For example, a
data X ¼ X Int
data Y ¼ Y Int
funX (X i) ¼ i þ1
funY (Y i) ¼ i 1
class X {
int i;
X(int ii) {
i ¼ ii;
}
int fun() {
return i þ1;
}
}
class Y {
int i;
Y(int ii) {
i ¼ ii;
}
int fun() {
return i 1;
}
}
Figure 4.
Additional values are put on two identical data structures through use in functional
paradigm (left), which appears as di¤erent data structure in object-oriented paradigm (right)
226
K. Tanaka-Ishii

Coordinate and two Doubles (decimals) representing height and width are
objects of Rectangle, as representamen. These constituents make up an
idea, a concept, of what a rectangle is, thus constituting an immediate ob-
ject of Peirce. This cannot be an interpretant, because it does not evoke a
semiotic chain.
A semiotic chain is evoked by functions that belong to Rectangle. The
function area utilizes multiplication in calculation, therefore generating
semiosis. Also, function application is analogous to interpretation, as the
area of a rectangle can be regarded as one interpretation of the rectangle.
Thus member functions are interpretants.
When a programmer needs to design an entity that is essentially func-
tional, such as for sorting a list or calculating an area, this can also be
done in a triadic way. Taking sorting as an example, the minimum and
maximum values can be obtained from the results of sorting. Then, mini-
mum, maximum can be encapsulated among the sorting functionality be-
cause it uses the sort function. In such a case, a representamen corre-
sponds to the identiﬁer ‘sort,’ the procedure of sorting corresponds to the
object, and minimum and maximum constitute an interpretant of sort.
Returning to the Rectangle example, it is Rectangle that has the infor-
mation that area is part of its deﬁnition, which di¤ers from the dyadic
case. This ﬁts in with the model of Peirce’s semiosis generation, which
requires only local information incorporated inside the sign model, and
does not require the whole language system. Related to this, in the
object-oriented paradigm the condition that all related functions be in-
cluded in the deﬁnition means the di¤erence by use will not become an
issue. This is because everything that adds value to a sign is incorporated
in its deﬁnition, so if two data are to be di¤erently used, they appear as
two di¤erent structures from the beginning. For example, the previous
example of X and Y in Figure 4, if expressed according to the object-
oriented paradigm, will give us the program on the right side of Figure 4.
Here, the increment function is included in the class of X and the decre-
ment function in Y. Then, X and Y are di¤erent data structures anyway
therefore Saussure’s di¤erence will not become an issue.
Note that this condition of putting all class-related functions into the
class is actually not fulﬁlled in many current object-oriented program-
ming languages. For example, we can think of a functional program as
k ðX iÞðY jÞ ¼ i þ j
and this function should belong to both X or Y under the object-oriented
paradigm because k uses both X and Y. However, this limitation is not
met in many actual languages because of the technical di‰culty.
Dyadic versus triadic sign models
227

Some object-oriented languages overcome this problem, such as CLOS
(Keene 1988), or more radically with an actor model as originally pro-
posed by Hewitt in the 1970s (Hewitt and Agha 1992). However, actor
model languages are fairly rare and there is no actual and popular lan-
guage system of this type. Therefore, we focus on the more commonly
used Java language as a sample program in this paper.
6.3.
Correspondence among Saussure and Peirce
We now examine the correspondence between dyadic and triadic identi-
ﬁers through our application of the Saussure and Peirce’s sign models to
identiﬁers, as illustrated in Figure 5. This correspondence can be summa-
rized as follows.
—
Saussure’s signiﬁer corresponds to Peirce’s representamen.
—
Saussure’s signiﬁed corresponds to Peirce’s immediate object.
—
Saussure’s di¤erence appears when the ‘use’ of each sign is located
outside of the sign model.
In Peirce’s model, the ‘use’ of signs is represented as an interpretant
and semiosis is generated by calling an interpretant preattached to the
Figure 5.
Dyadic and triadic sign models and correspondence when applied to identiﬁers of
functional/object-oriented programming paradigms
228
K. Tanaka-Ishii

sign itself. On the other hand, in Saussure’s model, a semiosis is generated
by a sign being used by another sign which is used by another sign and
so on, where all signs are located inside the language system. This corre-
spondence follows the hypothesis described in Section 2. Consequently, in
the triadic model, meaning as use is embedded inside the sign’s deﬁnition,
so semiosis is generated by applying signs already belonging to the sign;
in the dyadic model, meaning as use is distributed inside the language sys-
tem as a holistic value, so a sign sequence appears by a sign being called
from some other sign located in the system.
In the programming domain, as in the semiotic domain, there is no an-
swer to the question of which model is best. The triadic model provides
a rich and complete concept of the object, which enables modularity and
encapsulation. As a consequence, though, modeling and describing ob-
jects maximally become technically di‰cult. On the other hand, func-
tional programming minimizes the target concept by excluding the use
from its deﬁnition and distributing it inside the system. In this paradigm,
programmers can easily deﬁne functions and data, but this raises the
question of modularity as much of the value of identiﬁers becomes ho-
listic. Therefore, many recent languages combine the two di¤erent para-
digms; for example, purely functional programs have type classes where
types are constituted in an object-oriented manner, while object-oriented
languages still have many functional aspects as shown in our Figure 3
sample.
One important concept that can be transferred from the programming
domain to the domain of semiotics is the compatibility of the dyadic
model and the triadic model. Although some software speciﬁcations are
best written in one of the two types of programming language, most pro-
grams can be written according to either paradigm for a given speciﬁca-
tion. In practice, as was shown by the short program examples given in
this paper, functional language and object-oriented language programs
both give exactly the same output. This is natural because the di¤erence
between the two models lies in where to situate the ‘use’ of signs — inside
or outside the sign model. Then, as far as our hypothesis is correct,
Peirce’s model is compatible with Saussure’s model, and Saussure’s model
can be obtained when Peirce’s interpretant is located outside of the sign
model in the language system.
7.
Conclusion
Even in a newly developed artiﬁcial sign system we can ﬁnd contrast be-
tween the dyadic and triadic sign models, a contrast that has been known
Dyadic versus triadic sign models
229

in language philosophy since the eras of Plato and Augustine. Not only
does this contrast exist, but it deﬁnes the di¤erence between the two most
widely used programming paradigms.
One beneﬁt of viewing programming paradigms from a semiotic view-
point is that this allows us to discuss a target system in a more objective
and simpler manner compared with having natural language as analysis
target. Such discussion regarding this sort of simpliﬁed language could
lead to new understandings regarding the correspondence in natural lan-
guages as well.
Notes
*
This study was initiated by a proposal made by Professor Toru Nishigaki of University
of Tokyo to formally relate object-oriented programming paradigm with Peirce’s theory.
The author expresses her appreciation to Professor Nishigaki for his suggestion. The
author expresses her great gratitude to Kyo Kageura of the University of Tokyo and
Yuichiro Ishii for their valuable comments and suggestions regarding this paper.
1.
‘The signifying 3(auditory)4 and the signiﬁed 3(conceptual)4 elements are the two ele-
ments that make up the sign.’
2.
‘What I have said by focussing on the term value can be alternatively expressed by lay-
ing down the following principle: in the language (that is, a language state) there are
only di¤erences. Di¤erence implies to our mind two positive terms between which the
di¤erence is established.’
References
Andersen, P. (1997). A Theory of Computer Semiotics. Cambridge University Press.
Andersen, P., Holmqvist, B., and Jensen, J. (1993). Computers as Media. Cambridge: Cam-
bridge University Press.
Arnold, K., Gosling, J., and Holmes, D. (2000). The Java Programming Language. Boston:
Pearson Education.
Bird, R. (1998). Introduction to Functional Programming Using Haskell. New York: Prentice
Hall.
Connolly, J. and Cooke, D. (2004). The pragmatics of programming languages. Semiotica
151 (1/4), 149–161.
Eco, U. (1979). The Theory of Semiotics. Bloomington: Indiana University Press.
—(1988). Le Signe. Histoire et analyse d’un concept, J. M. Klinkenberg (trans.). Brussels:
Editions Labor.
Gunter, C. (1992). Semantics of Programming Language. London: MIT Press.
Hewitt, C. and Agha, G. (1992). Concurrent Systems for Knowledge Processing: An Actor
Perspective. Cambridge: MIT Press.
Keene, S. (1988). Object-Oriented Programming in Common Lisp: A Programmer’s Guide to
Common Lisp Object System. Boston: Addison-Wesley.
Noth, W. (1990). Handbook of Semiotics. Bloomington: Indiana University Press.
230
K. Tanaka-Ishii

Ogden, C. and Richards, I. (1989 [1923]). The Meaning of Meaning: A Study of the Inﬂuence
of Language upon Thought and of the Science of Symbolism. New York: Harcourt.
Peirce, Charles, S. (1931–1966). The Collected Papers of Charles S. Peirce, 8 vols., C.
Hartshorne, P. Weiss, and A. W. Burks (eds.). Cambridge: Harvard University Press.
[Reference to Peirce’s papers will be designated CP followed by volume and paragraph
number.]
Saussure, Ferdinand de (1966). Cours de Linguistique Ge´ne´rale, C. Bally, A. Sechehaye, and
A. Riedlinger (eds.), W. Baskin (trans.). New York/Toronto/London : McGraw-Hill.
—(1968). Cours de Linguistique Ge´ne´rale, R. Engler (ed.). Wiesbaden: Otto Harrassowitz
Wiesbaden.
—(1993). Troisie`me cours de linguistique ge´ne´rale (1910–1911) d’apre`s les cahiers d’E´mile
Constantin, E. Komatsu (ed.), R. Harris (trans.). Oxford/New York: Pergamon Press.
Sethi, R. (1996). Programming Languages: Concepts and Constructs. Boston: Addison-
Wesley.
Tennent, R. (1991). Semantics of Programming Languages. New York: Prentice Hall.
Thompson, S. (1999). Haskell — The Craft of Functional Programming. Boston: Addison-
Wesley.
Zemanek, H. (1966). Semiotics and programming languages. Communications of the Associ-
ation for Computing Machinery 9 (3), 139–143.
Kumiko Tanaka-Ishii (b. 1969) is an Associate Professor in the Department of Creative
Informatics, Graduate School of Information Science and Technology at the University of
Tokyo 3kumiko@i.u-tokyo.ac.jp4. Her research interests are computational semiotics, com-
putational linguistics, and natural language processing. Her major publications include
‘Three RoboCup simulation league commentator systems’ (with E. Andre, K. Binstead
et al., 2000); ‘Progress through performance competitions? A large-scale comparative study
of multi-agent teams’ (with G. Kaminka, I. Frank, and K. Arai, 2001); and ‘Predictive text
entry techniques using adaptive language models’ (in press).
Dyadic versus triadic sign models
231


