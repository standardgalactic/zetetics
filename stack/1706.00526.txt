Knowledge Representation in
Bicategories of Relations
Evan Patterson
Department of Statistics, Stanford University
Abstract
We introduce the relational ontology log, or relational olog, a knowledge representation
system based on the category of sets and relations. It is inspired by Spivak and Kent’s
olog, a recent categorical framework for knowledge representation. Relational ologs
interpolate between ologs and description logic, the dominant formalism for knowledge
representation today.
In this paper, we investigate relational ologs both for their
own sake and to gain insight into the relationship between the algebraic and logical
approaches to knowledge representation. On a practical level, we show by example
that relational ologs have a friendly and intuitive—yet fully precise—graphical syntax,
derived from the string diagrams of monoidal categories. We explain several other
useful features of relational ologs not possessed by most description logics, such as a
type system and a rich, ﬂexible notion of instance data. In a more theoretical vein, we
draw on categorical logic to show how relational ologs can be translated to and from
logical theories in a fragment of ﬁrst-order logic. Although we make extensive use of
categorical language, this paper is designed to be self-contained and has considerable
expository content. The only prerequisites are knowledge of ﬁrst-order logic and the
rudiments of category theory.
1. Introduction
The representation of human knowledge in computable form is among the oldest and most
fundamental problems of artiﬁcial intelligence. Several recent trends are stimulating continued
research in the ﬁeld of knowledge representation (KR). The birth of the Semantic Web
[BHL01] in the early 2000s has led to new technical standards and motivated new machine
learning techniques to automatically extract knowledge from unstructured text [Nic+16].
In the scientiﬁc community, successful knowledge bases like the Gene Ontology [Ash+00]
have inspired a proliferation of ontologies across biology and biomedicine [Noy+09]. This
development belongs to a general trend towards greater openness and interconnectivity in
science. Optimists dream of a future science in which all scientiﬁc knowledge is open, online,
and interpretable by machines [Nie12].
1
arXiv:1706.00526v2  [cs.AI]  1 Nov 2017

Description logic is the dominant formalism for knowledge representation today. In particular,
the language OWL (Web Ontology Language), a W3C standard underlying the Semantic
Web, is a description logic [Gra+08]. Description logics are logical calculi designed speciﬁcally
for knowledge representation. They lie somewhere between propositional logic and ﬁrst-order
predicate logic, striking a trade-oﬀbetween computational tractability and expressivity.
In parallel with the invention of description logic and the Semantic Web, a mostly disjoint
community of mathematicians, physicists, and computer scientists have discovered that
category theory, popularly known for its abstruseness, is useful not just for describing abstract
mathematical structures, but for modeling such diverse real-world phenomena as databases,
programming languages, electrical circuits, and quantum mechanics [Spi12; LS88; BF15;
AC04]. The ethos of this research program is that category theory can serve as a general-
purpose modeling language for science and engineering. Having internalized this perspective,
it is but a short step to contemplate a general-purpose knowledge representation system based
on category theory. In this spirit, Spivak and Kent have recently introduced the ontology log
(or olog), a simple and elegant categorical framework for knowledge representation [SK12].
An objective of this paper is to understand the relationship between the logical and algebraic
approaches to knowledge representation. To that end, we introduce a third knowledge
representation formalism that interpolates between description logic and ontology logs. We
call it the relational ontology log, or relational olog. Spivak and Kent’s ologs, which we
sometimes call functional ologs to avoid confusion, are based on Set, the archetypal category
of sets and functions. Relational ologs are based on Rel, the category of sets and relations.
That may sound a small diﬀerence, since functions and relations are often interchangeable,
but it leads to very diﬀerent modes of expression. Functional ologs achieve their expressivity
through categorical limits and colimits (products, pullbacks, pushforwards, etc.), while
relational ologs rely mainly on relational algebra (intersections, unions, etc.). In this sense,
relational ologs are actually closer to description logic than to functional ologs.
Practitioners of description logic will ﬁnd in relational ologs several useful features not
possessed by most existing KR systems, including OWL. Some of these features are awkward
to handle in a purely logical system; all emerge automatically from the categorical framework.
First, functors allow instance data to be associated with an ontology in a mathematically
precise way. Instance data can be interpreted as a relational or graph database or can take
more exotic forms. Second, relational ologs are by default typed. We argue that types,
if used judiciously, can mitigate the maintainability challenges posed by the open world
semantics of description logic. Finally, relational ologs have a friendly and intuitive—yet
fully precise—graphical syntax, derived from the string diagrams of monoidal categories. We
expect that this graphical language will appeal to technical and non-technical users alike.
How to read this paper
We have tried to write a paper that is accessible to a diverse
audience. All Remarks and Appendices are technical and can be skipped on a ﬁrst reading.
The mathematical prerequisites are limited as follows. We assume the reader is familiar
with the syntax and semantics of ﬁrst-order logic. No prior knowledge of description logic is
required. We expect the reader to know the “big three” concepts of category theory—category,
2

functor, and natural transformation—but we do not assume knowledge of categorical logic
or monoidal categories and their graphical languages. References for further reading are
provided where appropriate.
Readers who prefer to begin with an extended example may proceed immediately to Section 5.1,
referring to Section 3 as needed to understand the graphical notation. The core of the paper,
explaining the categorical-relational approach to knowledge representation, is Sections 3 to 7.
The other sections develop extensions of our methodology and make connections to other
branches of mathematics and knowledge representation.
Organization of paper
In the next section, we review description logic as a computationally
tractable subset of ﬁrst-order logic and describe several widely used description logics. In
Section 3, we introduce Rel, the category of sets and relations, and use it to illustrate the
general concepts of monoidal categories and their graphical languages. We also make initial
contact with the basic notions of description logic. Motivated by Rel, in Section 4 we present
the bicategory of relations, a categorical abstraction of relational algebra invented by Carboni
and Walters. Section 5 deﬁnes a relational olog to be a ﬁnitely presented bicategory of
relations and illustrates with an extended example. Sections 6 and 7 discuss the implications
of instance data and types for knowledge representation. In Section 8, we take a sojourn into
categorical logic, proving that regular logic is the internal language of bicategories of relations.
This result establishes a formal connection between relational ologs and a fragment of typed
ﬁrst-order logic. In Section 9, we introduce the distributive relational olog, an extension of the
relational olog with high expressivity. In the ﬁnal Section 10, we comment on the philosophy
of categorical knowledge representation and suggest directions for future research. The two
Appendices bring mathematical rigor to the informal discussion of categorical logic in the
main text.
2. Description logic
Early knowledge representation systems, based on semantic networks or frames, often lacked
a formal semantics. The intended meanings of the elements of such systems were deﬁned only
implicitly or operationally by the inference algorithms that manipulated them. As a result,
researchers found it diﬃcult to reason generally about these systems, independent of any
speciﬁc implementation. Arguments were advanced that knowledge representation should be
grounded in formal logic [Woo75]. First-order logic, ever the “default” logical system, seems
like a natural place to start.
Description logic (DL) is motivated by the deﬁciencies of ﬁrst-order logic as a foundation for
knowledge representation. Chief among these is computational intractability: ﬁrst-order logic,
while quite expressive, is undecidable. The basic description logics are subsets of ﬁrst-order
logic designed to be decidable (although not always in polynomial time). The tradeoﬀ
between expressivity and tractability was emphasized by the earliest papers on description
logic [BL84]. Another point, less frequently mentioned, is that description logic is simpler
3

and more user friendly than ﬁrst-order logic. As we will see, its syntax suppresses variables,
both bound and free, and imposes strict limits on the logical sentences that can be formed.
Given that most users of knowledge representation systems are domain experts in scientiﬁc
or business ﬁelds, not professional mathematicians, it is important that KR formalisms be
easily interpretable and maintainable. A knowledge base consisting of a collection of arbitrary
ﬁrst-order sentences will probably not meet this requirement.
2.1. Review of description logic
In this section, we briskly review description logic. General introductions to description
logic include the survey [KSH12] and the textbook chapter [BL04, Ch. 9] by Brachman and
Levesque. A comprehensive reference is the Description Logic Handbook [Baa+07]. For the
perspectives of the bioinformatics and Semantic Web communities, see [RB11] and [HKR09],
respectively.
Description logic uses a special nomenclature to specify the features possessed by a given
system. The base system, from which most others are derived, is called AL (for Attributive
Concept Language). Given a collection of atomic concepts, denoted A, and atomic roles,
denoted R or S, the concept descriptions of AL are well-formed terms of the grammar:
C, D
::=
A |
(atomic concept)
⊤|
(universal concept)
⊥|
(bottom concept)
¬A
(atomic negation)
C ⊓D |
(intersection)
∀R.C |
(value restriction)
∃R.⊤
(limited existential quantiﬁcation).
Note that negating arbitrary concepts is not allowed in AL. Concepts and roles are interpreted
as unary and binary predicates in ﬁrst-order logic:
(¬A)(x)
iﬀ
¬A(x)
(C ⊓D)(x)
iﬀ
C(x) ∧D(x)
(∀R.C)(x)
iﬀ
∀y.(R(x, y) →C(y))
(∃R.⊤)(x)
iﬀ
∃y.R(x, y)
A terminological box or TBox is a collection of terminological axioms of form
C ⊑D
or
C ≡D,
interpreted as the ﬁrst-order sentences
∀x.(C(x) →D(x))
or
∀x.(C(x) ↔D(y)).
4

ID
Name
DL Syntax
FOL Interpretation
C
Concept negation
¬C
¬C(x)
U
Concept union
C ⊔D
C(x) ∨D(x)
E
Full existential quantiﬁcation
∃R.C
∃y.(R(x, y) ∧C(y))
H
Role axioms
R ⊑S
∀x, y.(R(x, y) →S(x, y))
R ≡S
∀x, y.(R(x, y) ↔S(x, y))
O
Nominals (concept literals)
{a1, . . . , an}
{a1, . . . , an}
I
Inverse roles
R−
R−(x, y) ↔R(y, x)
F
Functional role
≤1R
see below
N
Number restriction
≥nR
see below
= nR
≤nR
Q
Qualiﬁed number restriction
≥nR.C
see below
= nR.C
≤nR.C
N/A
Role intersection
R ⊓S
R(x, y) ∧S(x, y)
N/A
Role union
R ⊔S
R(x, y) ∨S(x, y)
N/A
Role composition
R ◦S
∃y.R(x, y) ∧S(y, z)
R
Regular role inclusion
R1 ◦· · · ◦Rn ⊑S
see below
(D)
Concrete domains (data types)
varies
varies
Table 1: Summary of AL language extensions
An assertional box or ABox is a collection of assertional axioms of form
C(a)
or
R(a, b),
where a, b are names of individuals. A knowledge base or ontology in description logic consists
of a TBox and an ABox. Given the above translations into ﬁrst-order logic, there is an
obvious notion of an interpretation or model of a knowledge base. Thus description logic
inherits a model-theoretic semantics from ﬁrst-order logic.
More expressive description logics are obtained by adjoining to AL additional concept and
role constructors, identiﬁed by script letters like C and U. The literature describes countless
such extensions; Table 1 lists the most important ones. As a warning, a few identiﬁers (like
F and R) are not used consistently across the literature.
Several DL constructs in Table 1 deserve elaboration. The qualiﬁed number restriction (Q)
term ≥nR.C (respectively ≤nR.C) denotes the class of elements related by R to at least n
(respectively at most n) elements of class C. In ﬁrst-order logic,
(≥nR.C)(x)
iﬀ
∃y1, . . . , yn.

^
1≤i≤n
(R(x, yi) ∧C(yi)) ∧
^
1≤i<j≤n
yi ̸= y′
j


(≤nR.C)(x)
iﬀ
∀y1, . . . , yn+1.

^
1≤i≤n
(R(x, yi) ∧C(yi)) →
_
1≤i<j≤n+1
yi = y′
j

.
5

Number restriction (N) and functional roles (F) are special cases of qualiﬁed number
restriction. Concrete domains ((D)) refer to data types, such as natural numbers or real
numbers, and operations on them, such as addition and multiplication. We return to the
topic of data types in Section 7.
Most descriptions logics do not allow arbitrary intersection, union, or composition of roles.
However, composition-based regular role inclusion (R) is widely used. System R allows
axioms of form R1 ◦· · · ◦Rn ⊑S, where R1, . . . , Rn are atomic roles, provided there are no
cycles between axioms. This acyclicity requirement, which we will not make precise, leads to
favorable computational properties. Note that R is sometimes taken to include additional,
ad hoc features like reﬂexivity, “local” reﬂexivity, irreﬂexivity, and disjoint roles [HKS05;
HKS06].
A few description logics are privileged in theory or practice. The minimal language AL is too
inexpressive for most applications. The central language in the theory of description logic is
ALC. It is logically equivalent to ALUE, although the shorter name ALC is preferred. In
a break with the standard nomenclature, the language S is ALC plus transitive roles. The
Web Ontology Languages are derived from system S. For example, OWL 1 Lite corresponds
to SHIF(D), OWL 1 DL to SHION(D), and OWL 2 DL to SROIQ(D).
2.2. Structure of description logic
To put the subsequent developments in context, we make a few observations about the
structure of description logic. Since description logic is not a single logical system, but rather
a large federation of systems, it is diﬃcult to make broad generalizations. Nevertheless, some
general themes can be discerned.
An obvious syntactic diﬀerence between description logic and ﬁrst-order logic is that the
former is point-free while the latter is not. By “point-free” we mean that the concept and
role constructors of description logic suppress all variables, free and bound. First-order logics
without variables do exist—Tarksi, for example, studied such systems in his last major work
[TG87]—but, outside of description logic, they are rare in research and in practice. In this
respect, relational ologs are like description logic: both the textual and graphical syntaxes of
relational ologs are point-free.
Description logics characteristically impose strict limitations on how concepts and roles may
be combined. Thus, not all ﬁrst-order sentences are expressible in description logic. The
same is true of relational ologs: we shall see that when relational ologs are interpreted as
ﬁrst-order theories (Section 8), not all ﬁrst-order sentences are expressible.
Moreover, there are structural similarities between the ﬁrst-order sentences that are expressible
in the two formalisms. In description logic, terminological axioms C ⊑D and R ⊑S typically
translate into ﬁrst-order sentences of form
∀x1 · · · ∀xn(ϕ →ψ),
6

where ϕ and ψ are formulas containing only the connectives and quantiﬁers ∧, ∨, ⊤, ⊥, ∃.
(Depending on the language, exceptions can arise from value restrictions ∀R.C and number
restrictions like ≤nR.C. However, these constructors are acceptable in axioms of form
∀R.C ⊑⊤or ∀R.C ⊑⊥. Concept negations ¬C also present exceptions.) The logical system
just described is called coherent logic. The weaker system of regular logic is obtained when
ϕ and ψ are further restricted to the connectives and quantiﬁers ∧, ⊤, ∃. We shall see that
regular logic and coherent logic are closely connected to relational ologs (Sections 8 and 9).
3. The category of relations
In this section we introduce Rel, the category of sets and relations. Although the reader is
doubtless familiar with sets and relations, we think it helpful to start the development in this
very concrete setting. We will introduce monoidal categories and their graphical languages
by equipping Rel with various categorical structures, such as a monoidal product, diagonals
and codiagonals, and a dagger operator. These structures on Rel motivate the more abstract
“categories of relations” needed for knowledge representation (Section 4). We will also make
initial contact with description logic.
Our presentation draws on the physics-oriented survey by Coecke and Paquette [CP10], where
Rel is viewed as a “quantum-like” category, in contrast to the “classical-like” category Set.
The excellent surveys [BS10] and [Sel10] also provide more detail about monoidal categories
and their applications and graphical languages. General introductions to category theory, in
order of increasing sophistication, are [LS09; Spi14; Awo10; Lei14; Rie16; Mac98].
Deﬁnition. The category of sets and relations, denoted by Rel, is the category whose objects
are sets and whose morphisms R : X →Y are subsets R ⊆X × Y . The composition of
R : X →Y and S : Y →Z, written R · S : X →Z or RS : X →Z, is given by
xRSz
iﬀ
∃y ∈Y : xRy ∧yRz,
where xRy means that (x, y) ∈R. For any set X, the identity morphism 1X is the diagonal
relation:
x(1X)x′
iﬀ
x = x′.
The notion of composition of relations is natural and important. Notice that when R and
S are (graphs of) functions, RS is the usual composition of functions. Also, the identity
morphism is the usual identity function. As a result, Set, the category of sets and functions,
is a subcategory of Rel.
Remark. As illustrated by the deﬁnition, we compose morphisms in left-to-right or “diagram-
matic” order. We make this choice for consistency with the graphical syntax, which is read
from left to right. It is also consistent with the notation xRy for (x, y) ∈R.
Unlike Set, the category Rel is a special kind of a 2-category.
7

Deﬁnition. A category C is a locally posetal 2-category if between any two morphisms
f, g : A →B with common domain and codomain, there exists at most one 2-morphism,
written
A
B
f
g
or more succintly f ⇒g, together with operations of vertical composition,
A
B
f
g
h
⇝
A
B
f
h
,
and horizontal composition,
A
B
C
f
g
h
k
⇝
A
C
f·h
g·k
,
such that each hom-set C(A, B) is a poset (partially ordered set) under the relation ⇒.
In Rel, we stipulate that R ⇒S if there is a set containment R ⊆S. Vertical composition
simply says that set containment is transitive. More interestingly, horizontal composition
says that containment is preserved by composition of relations: if R ⊆S and T ⊆U, then
R ·T ⊆S ·U. Furthermore, the hom-sets are posets because R ⊆R and also R = S whenever
R ⊆S and S ⊆R. Thus Rel is a locally posetal 2-category. In this context, the symbol ⇒
has a happy double meaning: we can read ⇒as a generic 2-morphism or as logical implication.
In the terminology of description logic, 2-morphisms are subsumptions.
3.1. Monoidal category
We will make Rel into a monoidal category by equipping it with the Cartesian product. We
ﬁrst state the general deﬁnition of a monoidal category.
Deﬁnition. A (strict) monoidal category (C, , I) is a category C together with a functor
 : C × C →C, called the monoidal product, and an object I, called the monoidal unit, such
that (, I) behaves like a monoid on the objects and morphisms of C, in the following sense.
For objects A, B, C, we have
A  (B  C) = (A  B)  C,
A  I = I  A = I,
and for morphisms f, g, h, we have
f  (g  h) = (f  g)  h,
f  1I = 1I  f = f.
8

More explicitly, functorality of the monoidal product  means that for any objects A, B,
1A  1B = 1AB
and for any morphisms f : A →B, g : B →C, h : D →E, k : E →F,
(f · g)  (h · k) = (f  h) · (g  k).
Let us immediately introduce the graphical language of string diagrams that is associated
with any monoidal category. In this language, objects are represented by wires and morphisms
are represented by boxes with incoming and outgoing wires. A generic morphism f : A →B
is represented as
f
A
B
.
The composite fg : A →C of f : A →B and g : B →C is
f
A
g
B
C
and the monoidal product f  g : A  B →C  D of f : A →B and g : C →D is
f
g
A
C
B
D
.
Identity morphisms are represented specially as a bare wire:
1A
=
A
.
Each time we introduce a new monoidal structure, we will augment the graphical language
accordingly.
String diagrams are among the most beautiful aspects of the theory of monoidal categories.
Unlike the diagrams and ﬂowcharts found throughout the engineering literature, which have
no formal meaning, string diagrams provide a formal calculus for reasoning in monoidal
categories. More precisely, coherence theorems guarantee that string diagrams constitute
a sound and complete calculus for equational reasoning with morphisms in a monoidal
category. Coherence theorems are emphasized by Selinger’s comprehensive survey [Sel10].
All string diagrams in this paper are drawn by the author’s (highly experimental) library for
computational category theory [Pat17].
9

The Cartesian product makes Rel into a monoidal category in the most straightforward way.
(Later we will see that it is not the only interesting monoidal product on Rel.) On objects,
deﬁne
X  Y := X × Y = {(x, y) : x ∈X, y ∈Y }
and given morphisms R : X →Y and S : Z →W, deﬁne R  S : X  Z →Y  W by
(x, z)(R  S)(y, w)
iﬀ
xRy ∧zSw.
The monoidal unit is any singleton set, which we write as I = {∗}.
Remark. Technically, Rel is not a strict monoidal category, as deﬁned above, because the
Cartesian product is not strictly associative: X × (Y × Z) ̸= (X × Y ) × Z. Of course, there
is a natural isomorphism X × (Y × Z) ∼= (X × Y ) × Z, mapping (x, (y, z)) to ((x, y), z),
that allows us to identify these two sets. Similarly, X × I ̸= X but there is a natural
isomorphism X × I ∼= X that identiﬁes (x, ∗) with x. Such considerations lead to the general
deﬁnition of a monoidal category, where strict associativity and units are replaced with
associator and unitor natural isomorphisms, subject to some coherence conditions. However,
the coherence theorem for monoidal categories [Mac63] ensures that a general monoidal
category is monoidally equivalent to some strict monoidal category, called its strictiﬁcation.
As a result, we adopt the common practice of suppressing associators and unitors, eﬀectively
replacing every monoidal category by its strictiﬁcation. Note that the graphical language
implicitly performs this strictiﬁcation. Incidentally, the abstract categories of relations we
construct in Section 8 will actually be strict monoidal categories.
As in most monoidal categories in encountered in practice, in Rel the order of inputs and
outputs can be freely exchanged.
Deﬁnition. A monoidal category (C, , I) is a symmetric monoidal category if there is a
natural family of isomorphisms
σA,B : A  B →B  A,
A, B ∈C,
called braidings, satisfying σ−1
A,B = σB,A.
In the graphical language, braidings are represented by crossed wires:
σA,B
=
A
B
B
A
.
The braidings in Rel are deﬁned by
(x, y) σX,Y (y′, x′)
iﬀ
x = x′ ∧y = y′.
In Rel, unlike in Set, there is a fundamental duality between inputs and outputs under which
any input can be turned into an output and vice versa. This duality is captured abstractly
by the following deﬁnition.
10

Deﬁnition. A symmetric monoidal category (C, , I) is a compact closed category if for every
object A ∈C, there is an object A∗, the dual of A, and a pair of morphisms ηA : I →A∗ A
and ϵA : A  A∗→I, the unit and counit respectively, which satisfy the triangle or zig-zag
identities:
A
A  A∗ A
A
1AηA
1A
ϵA1A
A∗
A∗ A  A∗
A∗
ηA1A∗
1A∗
1A∗ϵA .
The prototypical example of a compact closed category is (Vectk, ), the category of ﬁnite-
dimensional vector spaces (over a ﬁxed ﬁeld k) and linear maps, equipped with the tensor
product. The monoidal unit is I = C, the one-dimensional vector space. As expected, the
dual A∗of a vector space A is the space of linear maps A →C. The unit ηA : I →A∗ A
maps c to c1A and the counit ϵA : A  A∗→I is the trace operator.
Rel is a self-dual compact closed category. That is, every object is its own dual (X∗= X).
The unit ηX : I →X  X and counit ϵX : X  X →I are deﬁned by
(∗) ηX (x, x′)
iﬀ
x = x′
iﬀ
(x, x′) ϵX (∗).
In the graphical language, these morphisms are represented as “bent wires”:
ηX
=
X
X
ϵX
=
X
X
.
The zig-zag identities assert that “zig-zags can be straightened out”:
=
=
.
Remark. String diagrams for compact closed categories typically include arrowheads on the
wires to distinguish objects
A
−−→from their duals
A∗
−−→, which are drawn as reversed arrows
A
←−−. Because we work in self-dual categories, we can safely omit the arrowheads.
We have amassed enough structure to specify relations of arbitrary arity. Relations B : I →I
whose domain and codomain are the monoidal unit constitute the degenerate case of arity
zero. Since I = {∗} is the singleton set, the hom-set Rel(I, I) has only two members: the
11

identity relation 1I = {(∗, ∗)} and the empty relation ∅. Deﬁning ⊤:= 1I and ⊥:= ∅, we
interpret relations B : I →I as booleans.
Next, we have unary and binary relations. A unary relation C : X →I is called a class or
concept in the description logic literature. Its elements have the form (x, ∗), where x ∈X.
In the graphical calculus, wires of type I are not drawn at all, so a concept C : X →I is
represented as
C
X
.
A binary relation R : X →Y , or role in description logic jargon, is depicted as
R
X
Y
,
as we have seen.
Finally, we can easily express higher-order relations. A relation of arity n is a morphism of
form R : X1  · · ·  Xn →I. For instance, here is a ternary relation R : X  Y  Z →I:
R
X
Y
Z
Apparently, there are two conventions for representing a binary relation: as a morphism
R : X →Y or a morphism R : X  Y →I. By bending wires, we can pass freely between
the two representations, via the transformations
R
X
Y
⇝
R
X
Y
and
R
X
Y
⇝
R
,
which, by the zig-zag identities, are mutually inverse. Most description logics do not support
relations of arity greater than two, in part because the point-free textual syntax becomes quite
awkward [Baa+07, §5.7]. The graphical language of monoidal categories enables graceful and
intuitive composition even when relations have multiple inputs and outputs.
12

3.2. Dagger category
Every relation R : X →Y in Rel has an opposite relation R† : Y →X, also known as the
converse or inverse relation, deﬁned by
yR†x
iﬀ
xRy.
This structure is axiomatized by the following deﬁnition.
Deﬁnition. A dagger category is a category C equipped with a contravariant functor (−)† :
Cop →C that is the identity on objects and is involutive, i.e., ((−)†)† = 1C.
More explicitly, a dagger category is a category C such that to every morphism f : A →B
there corresponds a morphism f † : B →A, and the correspondence satisﬁes
1A
† = 1A,
(fg)† = g†f †,
and
(f †)† = f.
When C is a monoidal category, one typically asks that the dagger respect the monoidal
structure.
Deﬁnition. A symmetric monoidal category C is a dagger symmetric monoidal category if C
is a dagger category and (−)† is a symmetric monoidal functor, i.e.,
(f  g)† = f †  g†
and
σ†
A,B = σB,A = σ−1
A,B.
A compact closed category C is a dagger compact category if C is a dagger symmetric monoidal
category and for each object A ∈C, there is a commutative diagram
I
A  A∗
A∗ A
ϵ†
A
ηA
σA,A∗.
Remark. Dagger compact categories have been introduced and studied in the context of
quantum computing [Sel07].
The prototypical example is Hilb, the category of ﬁnite-
dimensional Hilbert spaces and linear maps, equipped with the tensor product. Here f † is
the usual adjoint (or Hermitian conjugate) of the linear map f. For this reason, in a general
dagger category C, the morphism f † is often called the adjoint of f. To avoid confusion with
the 2-categorical notion of adjoint, invoked in Section 4, we do not use this terminology.
In the graphical language, f † is represented by taking the “mirror image” of f:
f †
B
A
:=
f
B
A
.
Equivalently, given any morphism f drawn as a string diagram—which we read from left to
right, as usual—we get f † by reading the same diagram from right to left.
13

With the dagger operation deﬁned above, Rel is a dagger compact category. However, unlike
most dagger compact categories, Rel is self-dual. Thus there is potentially a second way to
transform a morphism X →Y into a morphism Y →X: bend both the input and the output
wires. These two operations are actually the same, which we can express graphically as:
R
=
R
.
This equation is a generalization of the zig-zag identity: if we imagine “straightening out” the
right-hand side by pulling on the ends of the input and output wires, we obtain the left-hand
side. Mathematically speaking, the dagger structure on Rel is superﬂuous since it can be
reduced to the compact closed structure. We choose to make the dagger structure explicit
because inverse relations occur frequently in practice and the associated graphical language
is succinct and intuitive.
3.3. Diagonals and codiagonals
In our ﬁnal topic of this section, we show that the category of relations has operations
for “copying” and “deleting” data and, dually, for “merging” and “creating” data. Using
these operations, we can express intersections of classes and relations and, more generally,
logical operations involving conjunction. We also obtain an important characterization of the
“functional relations”, or maps, in Rel.
The “copying” and “merging” operations are deﬁned by internal comonoids and monoids,
respectively, in Rel. We recall the general deﬁnition of a (co)monoid in a monoidal category.
Deﬁnition. Let (C, , I) be a monoidal category. An internal monoid in C is an object
M ∈C together with a multiplication morphism µ : M  M →M and a unit morphism
η : I →M such that
M  M  M
M  M
M  M
M
1Mµ
µ1M
µ
µ
I  M
M  M
M  I
M
η1M
µ
1Mη
.
Dually, an internal comonoid in C is an internal monoid in Cop. In concrete terms, an internal
comonoid is an object C together with a comultiplication morphism δ : C →C  C and a
counit morphism ϵ : C →I such that
C
C  C
C  C
C  C  C
δ
δ
δ1C
1Cδ
C
I  C
C  C
C  I
δ
ϵ1C
1Cϵ
.
14

If C is a symmetric monoidal category, we say that an internal monoid (M, µ, η) is commutative
if
M  M
M  M
M
σM,M
µ
µ
.
Dually, an internal comonoid (C, δ, ϵ) is cocommutative if
C
C  C
C  C
δ
δ
σC,C .
Note that an internal monoid in Set is just a monoid in the usual sense, i.e., a set M
equipped an associative binary operation µ and an identity element η. Likewise, an internal
commutative monoid in Set is just a commutative monoid.
We deﬁne a family of internal (co)monoids in Rel as follows.
For each set X, deﬁne
∆X : X →X  X by
x ∆X (x′, x′′)
iﬀ
x = x′ ∧x = x′′,
and deﬁne ♦X : X →I by ♦X = {(x, ∗) : x ∈X} (so that x(♦X)∗holds for every x ∈X).
It is easily veriﬁed that (X, ∆X, ♦X) is a cocommutative comonoid in Rel. By taking the
opposite relations
∇X := ∆†
X : X  X →X
and
□X := ♦†
X : I →X,
we also obtain for each set X a commutative monoid (X, ∇X, □X) in Rel. We think of ∆X
as “copying” or “duplicating,” ∇X as “merging,” ♦X as “deleting” or “erasing,” and □X
as “creating.” These interpretations will be manifest from the graphical language, to be
demonstrated shortly. However, for the graphical language to be consistent, the family of
(co)monoids must satisfy certain coherence axioms, which ensure that they interact properly
with the monoidal product. These axioms are captured by the following deﬁnition.
Deﬁnition ([Sel99]). A monoidal category with diagonals is a symmetric monoidal category
C together with a family of morphisms ∆A : A →A  A and ♦A : A →I, not necessarily
natural in objects A, such that each triple (A, ∆A, ♦A) is a cocommutative comonoid in C
and obeys the coherence axioms
♦I = 1I,
♦AB = ♦A  ♦B,
∆AB = (∆A  ∆B)(1A  σA,B  1B).
Dually, a monoidal category with codiagonals is a symmetric monoidal category C together
with a family of morphisms ∇A : A  A →A and □A : I →A such that each triple
(A, ∇A, □A) is commutative monoid in C and obeys the coherence axioms
□I = 1I,
□AB = □A  □B,
∇AB = (1A  σB,A  1B)(∇A  ∇B).
15

Remark. When the monoidal category C is, like Rel, not strict, we also need coherence axioms
asserting that ∆I and ∇I are the unitors realizing the isomorphism I ∼= I  I.
The graphical language of a monoidal category with diagonals is
∆A
=
A
,
♦A
=
A
.
Similarly, the graphical language of a monoidal category with codiagonals is
∇A
=
A
,
□A
=
A
.
By the coherence axioms, we can express the diagonal morphisms for a product A  B in the
graphical language as
∆AB
=
A
B
A
B
A
B
,
♦AB
=
A
B
.
Of course, there is a dual picture for the codiagonal morphisms.
Under the above deﬁnitions, Rel is a monoidal category with diagonals and codiagonals.
A quick calculation shows that the intersection R ∩S of two relations R, S : X →Y with
common domain X and codomain Y is ∆X(R  S)∇Y or, in graphical language,
R ∩S
=
X
R
S
Y
.
As a special case, the intersection of two classes C, D : X →I is
C ∩D
=
X
C
D
.
16

We can also express many of the basic concept constructors in description logic. For any
relation R : X →Y and class C : Y →I, the “limited” existential quantiﬁcation ∃R.⊤is the
class
R
X
Y
and the “full” existential quantiﬁcation ∃R.C is the class
R
X
C
Y
.
In contrast to description logic, we can retain access to the domain or codomain of the
relation R while restricting its values. For instance, given classes C : X →I and D : Y →I,
the relation
X
R
C
D
Y
consists of all pairs (x, y) ∈X ×Y satisfying xRy ∧xC∗∧yD∗. The value restriction concept
constructor ∀R.C cannot be expressed as a single morphism, but we can achieve the same
eﬀect by declaring a subsumption of two diﬀerent morphisms:
R
X
Y
=⇒
C
Y
.
This 2-morphism asserts that ∀x ∈X.∀y ∈Y.(xRy →yC∗).
Finally, we can express a typed variant of the “universal role” in description logic. The local
maximum
⊤X,Y
:=
X
Y
is the (unique) maximum element of the poset Rel(X, Y ), namely X × Y . It generalizes the
top element ⊤= ⊤I,I = 1I of the booleans Rel(I, I).
Maps
The diagonal structure on Rel leads to an abstract characterization of the relations
that are functions, i.e., the relations R : X →Y with the property that for every x ∈X,
there exists a unique y ∈Y such that xRy. This matter is closely connected to the naturality,
or lack thereof, of the diagonal in Rel. In general, a diagonal in a symmetric monoidal
category C is natural if for every morphism f : A →B, we have f∆B = ∆A(f  f) and
f♦B = ♦A, or graphically
f
A
B
=
A
f
f
B
B
17

and
f
A
B
=
A
.
The ﬁrst equation has the interpretation that applying f, then copying the output is the
same as copying the input, then applying f to both copies; the second that applying f,
then deleting the output is the same as deleting the input. When both equations hold for a
morphism f, we say that f is a comonoid homomorphism. In a general category, we expect
the equations to hold for morphisms that “behave like functions.”
The diagonal in Rel is not natural because not all relations are functions. However, for any
relation R : X →Y , there are 2-morphisms
R
X
Y
=⇒
X
R
R
Y
Y
R
X
Y
=⇒
X
.
We say that every morphism in Rel is a lax comonoid homomorphism. Explicitly, the
2-morphisms are the inclusions
{(x, y, y) : xRy} ⊆{(x, y, y′) : xRy ∧xRy′}
{(x, ∗) : ∃y ∈Y.xRy} ⊆{(x, ∗) : x ∈X}.
When the ﬁrst inclusion is an equality, R is a partial function; when the second is an equality,
R is total; when both are equalities, R is a function or a map. In other words, the comonoid
homomorphisms in Rel are exactly the relations that are functions.
Of course, for every concept about the diagonal, there is a dual concept about the codiagonal,
whose details we omit. In Rel, we obtain abstract characterizations of the injective, surjective,
and bijective relations.
By combining the diagonal and codiagonal structures, we can
characterize the injective functions, surjective functions, etc.
Interactions between structures
To conclude this section, we consider how the diagonals
and codiagonals of Rel interact with each other and with the previous structures. In fact,
the self-dual compact closed structure is reducible to the (co)diagonals. The unit and counit
morphisms are given by
X
X
=
X
,
X
X
=
X
.
18

We have seen that the dagger is, in turn, reducible to the compact closed structure. Like the
dagger operation, bending arrows is useful enough to merit its own textual and graphical
syntax.
The internal monoids and comonoids in Rel combine to form internal Frobenius algebras
(sometimes called Frobenius monoids) [Koc04]. That is, for each object X, there is a monoid
(X, ∇X, □X) and a comonoid (X, ∆X, ♦X) satisfying the Frobenius equations
(1X  ∆X)(∇X  1X) = ∇X∆X = (∆X  1X)(1X  ∇X)
or, graphically,
=
=
.
The monoid and comonoids are also special, meaning that ∆X∇X = 1X or
=
.
Finally, by deﬁnition, we have ∇X = ∆†
X and □x = ♦†
X. These properties can be summarized
by saying that (X, ∆X, ♦X, ∇X, □X) is a special †-Frobenius monoid [BE15].
4. Abstract categories of relations
The category Rel of sets and relations cannot stand alone as a formalism for knowledge
representation. A knowledge representation system must be implementable on a computer,
which requires that each knowledge base admit a ﬁnite description. Yet Rel, far from being
a ﬁnitary object, has as objects every possible set and as morphisms every possible relation!
Moreover, there is no formal system for specifying equations or subsumptions that should
hold between relations. To enable a ﬁnite description of categories that “behave like” the
category of sets and relations, we must axiomatize the salient structures of Rel. The previous
section provides some clues about how to achieve this axiomatization.
In fact, there are two diﬀerent notions of an “abstract” category of relations in the category
theory literature. The best known is Freyd’s allegory, popularized by Freyd and Scedrov
[FS90] and utilized in Johnstone’s treatise on topos theory [Joh02]. There have been a few
eﬀorts to apply allegories to real-world phenomena, e.g., in circuit design [BH94; BJ94], logic
19

programming [AL12], and database modeling [ZMS13]. Allegories take intersections and
the dagger (called “reciprocation”) as primitive, characterizing the former by axioms like
reﬂexivity, commutativity, and, most distinctively, the modular law
RS ∩T ⊆(R ∩TS†)S,
where R ⊆S is, by deﬁnition, equivalent to R∩S = R. (The reader can check that this rather
strange law does hold in Rel.) The second notion is the bicategory of relations, introduced by
Carboni and Walters [CW87; Car+08]. In bicategories of relations, the monoidal structures
are primitive, while intersections and the dagger are derived concepts. The two notions
are ostensibly quite diﬀerent, but it can be shown that the categories of unitary pretabular
allegories and of bicategories of relations are equivalent, in fact isomorphic [KN94; Law15].
Thus, the choice of axiomatization is mostly a matter of preference.
In this paper, we shall take bicategories of relations as our preferred notion of an “abstract”
category of relations. An advantage of this choice is that the graphical language of monoidal
categories is immediately available.
Deﬁnition ([CW87]). A bicategory of relations is a locally posetal 2-category B that is also
a symmetric monoidal category (B, , I) with diagonals (X, ∆X, ♦X)X∈B, such that
• every morphism R : X →Y is a lax comonoid homomorphism,
R · ∆Y =⇒∆X(R  R),
R · ♦Y =⇒♦X;
• the duplication morphisms ∆X and deletion morphisms ♦X have right adjoints ∇X :=
∆∗
X and □X := ♦∗
X;
• the pairs of morphisms (∆X, ∇X) obey the Frobenius equations.
We denote by BiRel the category of (small) bicategories of relations and structure-preserving
functors.
Remark. Our deﬁnition diﬀers from Carboni and Walter’s deﬁnition in one respect. They ask
not for diagonals but only for internal cocommutative comonoids, subject to the requirement
that they are the unique cocommutative comonoids with right adjoints. However, it appears
that the only use of this uniqueness axiom is to derive the coherence axioms [CW87, Remark
1.3 (ii)]. We think it simpler to just assert the coherence axioms to begin with. By omitting
the uniqueness axiom, we ensure that the theory of bicategories of relations is essentially
algebraic (see below).
Every structure invoked in the deﬁnition has been introduced in Section 3, with the exception
of adjoints. In this paper we use “adjoint” in the sense of 2-categories [Lac10]. Thus, in a
locally posetal 2-category C, a morphism f : A →B is left adjoint to g : B →A (and g is
right adjoint to f), written f ⊣g, if
1A =⇒fg
and
gf =⇒1B.
If a morphism f has a right adjoint g, then it is unique, for if g′ is another right adjoint, then
g′ ⇒g′fg ⇒g and, by symmetry, g ⇒g′, so that g = g′. Similarly, left adjoints are unique
20

Structure
Name
Notation and deﬁnition
category
composition
R · S
monoidal category
product
R  S
braiding
σX,Y
diagonal
copy
∆X
delete
♦X
codiagonal
merge
∇X := ∆∗
X = ∆†
X
create
□X := ♦∗
X = ♦†
X
compact closed
unit
ηX := □X · ∆X
counit
ϵX := ∇X · ♦X
dagger
dagger
R† := (ηX  1Y )(1X  R  1Y )(1X  ϵY )
logical
intersection
R ∩S := ∆X(R  S)∇Y
true
⊤:= ♦I · □I = 1I
local maximum
⊤X,Y := ♦X · □Y
Table 2: Summary of morphisms in a bicategory of relations
when they exist. In Rel, a relation R : X →Y has a right adjoint R∗: Y →X if and only
if R is a function, in which case R∗= R†. Together with the discussion in Section 3, this
proves that Rel is a bicategory of relations. We shall meet other interesting bicategories of
relations in Sections 6 and 8.
Carboni and Walters derive from the axioms of a bicategory of relations all the categorical
structures discussed in Section 3. The situation is perfectly analogous to that of Rel. For
the reader’s convenience, we summarize the results in Table 2, using the textual syntax for
brevity.
The characterization of maps in Rel also generalizes to an arbitrary bicategory of relations.
A morphism R : X →Y in a bicategory of relations B is a map if it has a right adjoint
R∗: Y →X. Equivalent conditions are that R is a comonoid homomorphism or that R is left
adjoint to R† [CW87, Lemma 2.5]. The collection of maps in B is closed under composition
and monoidal products and hence forms a symmetric monoidal category, which we denote
by Map(B). In the motivating example, Map(Rel) = Set. The diagonal on B is natural
when restricted to Map(B), making Map(B) into a cartesian category. In fact, Map(B) is
the largest subcategory of B that is cartesian. Thus, in the terminology of [Sel99], Map(B)
is the focus of B.
5. Relational ologs
A categorical framework for knowledge representation, generalizing the category of sets and
relations, emerges almost automatically from the abstractions developed in the previous
section. An ontology in this framework is called a “relational olog,” after Spivak and Kent
[SK12]. We will deﬁne a relational olog to be any bicategory of relations that admits a ﬁnite
21

description; more precisely, a relational olog is a ﬁnitely presented bicategory of relations.
Intuitively, a ﬁnitely presented bicategory of relations is the “generic” or “free” bicategory
of relations that contains a speciﬁed ﬁnite collection of basic objects, morphisms, and 2-
morphisms. It is analogous to other free constructions in algebra, such as a free vector space
or a ﬁnitely presented group. Another, more relevant example is a functional olog that does
not involve limits or colimits, which is just a ﬁnitely presented category.
Deﬁnition. A relational ontology log (or relational olog) is a ﬁnitely presented bicategory of
relations.
In more detail, a relational olog is a bicategory of relations B presented by
• a ﬁnite set of basic types or object generators;
• a ﬁnite set of basic relations or morphism generators of form R : X →Y , where X, Y
are object expressions;
• a ﬁnite set of subsumption axioms or 2-morphism generators of form R ⇒S, where
R, S are well-formed morphism expressions with the same domain and codomain.
Note that while our deﬁnition does not explicitly include equality axioms, equality of mor-
phisms can be reduced to subsumption. In the sequel, axioms of form R = S are understood
to be shorthand for the two axioms R ⇒S and S ⇒R.
We hope that the meaning of the deﬁnition is intuitively clear but let us be somewhat more
precise about our terminology. By “well-formed morphism expressions” we mean expressions
constructed from the morphism generators and the syntax of bicategories of relations (see
Table 2) such that domains and codomains are respected in all compositions. Similarly,
“object expressions” are expressions constructed from the object generators and the syntax
of monoidal categories ( and I). A bicategory of relations B is “presented by” a given
collection of generators B0 if B contains (an isomorphic copy of) B0 and if for every other
bicategory of relations B′ containing B0, there exists a unique functor F : B →B′ preserving
the structure of BiRel and the generators B0. As usual, this universal property guarantees
the uniqueness of B up to isomorphism. For readers concerned about the existence of B we
make the following technical remark.
Remark. The preceding deﬁnition can be made fully rigorous by formulating the axioms of a
bicategory of relations as an essentially algebraic theory. Roughly speaking, an essentially
algebraic theory is an algebraic theory that allows some operations to be partially deﬁned,
provided the domain of deﬁnition is characterized by equations between total operations [Fre72;
PS97]. A motivating example is the theory of categories, where composition of morphisms is
partially deﬁned. It is well known that deﬁnition by ﬁnite presentation, also known as the
“method of generators and relations,” works in any essentially algebraic theory. There are
several methods for constructing a free model from the syntax of the theory. Generalized
algebraic theories, a reformulation of essentially algebraic theories using dependent type
theory, provide a particularly elegant solution [Car86; Pit95].
Alternatively, our foray into categorical logic (Section 8) yields an entirely diﬀerent and fully
explicit construction of relational ologs. This construction is based not on universal algebra
or dependent type theory but on the proof theory of a subset of ﬁrst-order logic.
22

5.1. Example: Friend of a friend
While the formal deﬁnition of a relational olog is somewhat abstract, the speciﬁcation of
a particular relational olog is, as a practical matter, simple and intuitive, thanks to the
graphical language of monoidal categories. To illustrate, we specify a relational olog in a toy
domain aﬀectionately called “friend of a friend” (or “FOAF”) [BM14; DV10]. This domain,
involving people, organizations, and their presences online, is often used to showcase the
Semantic Web technologies (RDF and OWL). We take the formal speciﬁcation of FOAF as
an inspiration only, making no attempt to replicate its interface or general philosophy.
The basic types of the olog are “Person”, “Organization”, “Number”, and “String”. We shall
introduce the basic relations as we need them. Here are some essential relations for our
ontology:
knows
Person
Person
,
member of
Person
Organization ,
friend of
Person
Person
,
works at
Person
Organization .
The obligatory “friend of a friend” relation is just the composite
friend of
friend of
.
(All relations are typed but when the types are clear from context we shall suppress the type
labels.) Some of the basic relations are subsumed by others. For instance, if Alice is a friend
of Bob, then Alice knows Bob; thus, the “friend of” relation is subsumed by the “knows”
relation:
friend of
=⇒
knows
.
Likewise, the “works at” relation is subsumed by the “member of” relation (diagram omitted).
Presumably, if Alice knows Bob, then Bob also knows Alice, so we should declare that the
“knows” relation is symmetric:
knows
=
knows
.
Most people would also say that the “friend of” relation is symmetric.
We can attach some basic data to each person, such as their name and age:
age
Person
Number ,
family name
Person
String ,
given name
Person
String .
We declare that these relations are (total) functions; for instance,
age
=
age
age
,
age
=
.
23

In RDF and OWL, functional relations whose codomains are primitive data types are called
“properties” and are treated specially.
For extra ﬂavor, we complement the “friend of” relation with an “enemy of” relation. We can
then deﬁne the notorious relation of “frenemy” as the intersection of friend and enemy:
frenemy of
:=
friend of
enemy of
.
Next, we model some basic family relationships. Having introduced a “child of” relation, the
“parent of” relation is just its inverse:
parent of
:=
child of
.
An “ancestor of” relation should possess several properties. First, it should subsume “parent
of”:
parent of
=⇒
ancestor of
.
It should be transitive,
ancestor of
ancestor of
=⇒
ancestor of
,
(an ancestor of an ancestor is an ancestor) and reﬂexive,
Person
=⇒
ancestor of
,
(by convention, we regard every person as their own ancestor). Finally, the ancestor relation
should be antisymmetric,
ancestor of
ancestor of
=⇒
Person
,
(if two people are both ancestors and descendants of each other, then they are the same
person). We can now deduce, rather an declare as an axiom, that the relation “grandparent
of” is subsumed by “ancestor of”:
grandparent of
:=
parent of
parent of
=⇒
ancestor of
ancestor of
=⇒
ancestor of
.
24

In summary, “ancestor of” is a partial order that subsumes “parent of.” It would be more
precise to declare that “ancestor of” is the partial order generated by “parent of,” but that
cannot be expressed in a relational olog.
So far we have seen only relatively simple, binary relations. Let us now consider more complex
compound relations and relations of arity diﬀerent than two. The class (unary relation) of
employed people can be deﬁned as the class of people who work at some organization:
is employed
Person
:=
works at
Person
Organization
.
We declare a ternary relation “salary” with signature
salary
Person
Organization
Number
.
We assert that “salary” is a partial function (diagram omitted). Its domain of deﬁnition is
characterized by
salary
=
works at
.
Alternatively, we can take this equation as the deﬁnition of the “works at” relation: a person
works at an organization if and only if they draw a salary from that organization. As another
example, a “colleague” is a person whom you know and with whom you share a membership
at some organization:
colleague of
:=
knows
member of
member of
.
A simple calculation, using the symmetry of “knows,” proves that “colleague of” is a symmetric
relation. More fancifully, a romantic “love triangle” is the ternary relation
loves
enemy of
loves
.
Thus, a love triangle consists of two people, mutually enemies, who both love a third person.
Assuming “enemy of” is symmetric, this relation is symmetric in its ﬁrst two arguments. As
25

long as we’re indulging in Shakespearean themes, we can also deﬁne the quaternary relation
of “intergenerational family feud”:
enemy of
parent of
parent of
enemy of
.
Such a feud consists of two parent-child pairs, where the parents are enemies and the children
are also enemies.
Although it might be entertaining to continue along these lines, we shall stop here. We hope
we have convinced the reader that relational ologs are both expressive and intuitive. With a
little practice, it becomes easy to write down complex relations and read them at a glance.
However, there are certain natural constraints that cannot be expressed in a relational olog,
as developed so far. For instance, if we took our ontology more seriously, we might prefer to
dismiss the possibility of “frenemies” and declare that “friend of” and “enemy of” are disjoint
relations. At present we cannot express this constraint because we cannot express the empty
relation. Nor can we express unions, so we cannot declare that, for example, the “parent of”
relation is the union of the “mother of” and “father of” relations. In Section 9 we explain
how to overcome these limitations.
6. Instance data
A distinguishing feature of categorical knowledge representation, compared to the logical
paradigm, is a rich and ﬂexible notion of instance data. The idea of instance data is simply
that of functorality. To be precise, instance data for a relational olog B in an arbitrary
bicategory of relations D is a structure-preserving functor D : B →D. We call D the data
category for the instance data D. Unsurprisingly, the “standard” data category is Rel, the
category of sets and relations. We study this important case and several others below.
In knowledge representation systems based on description logic, instances are represented by
named constants within the logical system, usually called “individuals.” There are several
advantages to the categorical notion of instance data. First, there is a clean separation between
universal concepts, stored in the olog B, and instantiations of these concepts, stored in the
functor D : B →D. In description logic, this separation is only partly achieved by partitioning
the axioms of the knowledge base into a “TBox” and an “ABox” (see Section 2). Besides its
aesthetic appeal, the separation of universal and particular knowledge has important practical
beneﬁts. In modern “big data” applications involving a large number of individuals, storing
instance data in a suitable database, rather than as logical sentences, becomes a practical
26

necessity. Of course, one can deﬁne ad hoc schemes for translating between the logical system
and the database system. The point is that functors provide a simple, mathematically precise
notion of “translation” between systems.
Another advantage, less easily achieved by ad hoc devices, is that we can deﬁne “non-standard”
instance data by using data categories besides Rel. This possibility arises because ologs,
unlike logical theories, are algebraic structures and hence come equipped with a general
notion of structure-preserving maps, namely functors. From this point of view, instance data
for relational ologs is closely connected to functorial semantics in categorical logic. We shall
return to categorical logic in Section 8.
Let us add, parenthetically, that it is possible to represent individuals inside a relational
olog. An individual of type X is a map c : I →X, since a function from the singleton set
I = {∗} to X picks out an element of X. In our view, individuals should be used sparingly
to represent concepts that are inherently singletons. For example, there is at any given time
only one Dalai Lama, so it would be reasonable to represent the Dalai Lama as an individual
of type “Person.” It should suﬃce to include most “ordinary” people only as instance data. In
general, the olog should contain only universal concepts, even if they are singletons, while the
instance data contains all particular knowledge. (We grant that when building an ontology it
is not always easy to distinguish between universal and particular, but often the diﬀerence is
clear enough.)
In this section, we consider four diﬀerent kinds of instance data for relational ologs. The ﬁrst
and second are interpreted as relational databases and graph databases, respectively. With
minor modiﬁcation, these two concepts apply equally well to functional ologs and are treated
by Spivak and Kent [SK12]. The other two kinds of instance data are speciﬁc to relational
ologs. From the matrix calculus of relations, an extension of the familiar boolean algebra, we
derive instance data in the category of boolean matrices. Finally, we consider “non-standard”
instance data in the category of linear relations. This data category can be used to model
linear dynamical systems.
6.1. Relational databases
The default category for instance data, suitable for most applications, is the category of sets
and relations. Thus, without further qualiﬁcation, instance data for a relational olog B is a
structure-preserving functor D : B →Rel.
A structure-preserving functor D : B →Rel is deﬁned by the following data. Each basic
type X of B is mapped to a set D(X) and each basic relation R : X →Y of B is mapped to
a subset D(R) of D(X) × D(Y ). The set D(X) contains the instances of type X and the
subset D(R) tabulates the instances of type X that are in relation R with instances of type
Y . By functorality, this data determines the action of D on every object and every morphism
of B, since B is generated by the basic types and relations. Moreover, in order for D to be
well-deﬁned, it must preserve all the subsumption axioms of B. Thus, for every subsumption
axiom R ⇒S, we require that D(R) ⊆D(S). If the mapping D satisﬁes these properties, it
deﬁnes valid instance data for the olog.
27

Instance data is straightforwardly interpreted as a relational (SQL) database [Cod70]. In
the idealized database interpretation, there is a single-column table D(X) for each basic
type X, which deﬁnes the primary key of each instance of type X, and a multi-column table
D(R) for each basic relation R, whose columns are foreign keys associated with the domain
and codomain types of R. The tables D(R) are called “association tables” or “junction
tables” in SQL jargon. Association tables are the standard way of representing many-to-many
relationships in a relational database. The primary key of the association table is the product
of the foreign keys of the columns.
An example should make this clear. Instance data for a fragment of the “friend of a friend”
ontology (Section 5.1) is shown below.
Person
ID
P1
P2
P3
P4
Organization
ID
O1
O2
salary
Person
Organization
Number
P1
O1
30,000
P3
O2
40,000
friend of
Person 1
Person 2
P1
P2
P2
P1
knows
Person 1
Person 2
P1
P2
P2
P1
P3
P4
P4
P3
As required by functorality, the “friend of” and “knows” tables are symmetric and the “friend
of” table is a subset of the “knows” table. In practice we expect to deviate slightly from
the idealized database interpretation to obtain a more compact database schema. Most
importantly, instead of representing maps as individual tables, e.g.,
Person
ID
P1
P2
P3
P4
age
Person
Number
P1
21
P2
37
P3
22
P4
54
family name
Person
String
P1
Doe
P2
Smith
P3
Williams
P4
Jones
given name
Person
String
P1
Alice
P2
Bob
P3
Carol
P4
David
,
it would be more conventional to combine the maps with common domain into a single table,
e.g.,
Person
ID
age
family name
given name
P1
21
Doe
Alice
P2
37
Smith
Bob
P3
22
Williams
Carol
P4
54
Jones
David
.
28

We could represent partial maps similarly, using NULL to indicate undeﬁned values.
By formalizing the association of instance data with an olog, it becomes possible to migrate
data in a precise, principled way. Suppose that, in light of new information or a changing
world, we decide to update the concepts in our ontology B, yielding a new ontology B′. Ideally
we can translate the concepts of B into concepts of B′ by means of a functor F : B →B′.
The functor F can then be used to migrate the original data D : B →Rel to updated data
D′ : B′ →Rel. This paradigm is called functorial data migration and is investigated by
Spivak and collaborators in a series of papers [Spi12; SK12; SW15; Sch+16]. Functorial data
migration has been developed for functional ologs. At least one data migration functor, the
pullback functor, has an obvious analogue for relational ologs. It is an open question whether
the other data migration functors, the left and right pushforward functors, admit analogues.
This question, while important, is not pursued further here.
6.2. Graph databases
Graph databases [AG08; RN10] provide a natural storage model for the instance data of an
ontology. In fact, the development of graph databases can be traced back to the semantic
networks and frame systems of the early era of knowledge representation [AG08, Fig. 1].
Even today it is sometimes suggested that graph databases are knowledge representation
systems. That is not so: graph databases oﬀer a generic data storage model that need not
impose any logical constraints on the data. Still, the confusion exists precisely because graph
databases are so well-aligned with the practice of knowledge representation. In this section,
we explain how instance data D : B →Rel can be interpreted as a graph database.
Unlike relational databases, which are practically synonymous with the Structured Query
Language (SQL), graph databases are an emerging technology with no universally accepted
data model or query language. Our construction maps easily onto Apache TinkerPop3
[Apa15], an open standard for graph databases with moderate vendor adoption.
The
Resource Description Framework (RDF), a core component of the Semantic Web, can also be
regarded as a graph database [AG05], especially when coupled with a graph query language
like SPARQL [PS08].
The interpretation of instance data as a graph database involves a construction called the
“category of elements.”
Deﬁnition. Let B be a bicategory of relations. The category of elements of a structure-
preserving functor F : B →Rel, denoted
R
B F or
R F, has as objects, the pairs
(X, x)
where
X ∈B,
x ∈F(X),
and as morphisms (X, x) →(Y, y), the morphisms in B
R : X →Y
such that
x F(R) y.
Composition and identity morphisms are inherited from B.
29

Remark. Technically, this deﬁnition is not included in the usual notion of a category of
elements [Rie16, §2.4], which applies to functors F : C →Set, nor in the more general
Grothendieck construction [Jac99, §1.10], which applies to functors F : C →Cat. However, it
is evidently the same idea, so we will use the same terminology.
A category of elements
R
B F is itself a bicategory of relations, with its structure inherited
from both B and Rel. The monoidal product is deﬁned by
(X, x)  (Y, y) := (X  Y, (x, y)),
IR
F := (IB, ∗).
The diagonal maps are ∆(X,x) := ∆X and ♦(X,x) := ♦X.
These morphisms behave as
expected because F is structure-preserving. For example, there is a copying morphism
∆X : (X, x) →(X  X, (x′, x′′)) in
R F if and only if x = x′ and x = x′′. Finally, the
2-morphisms of
R F are just the 2-morphisms of B. (It is tempting to declare that R ⇒S in
R F whenever F(R) ⇒F(S) in Rel, but under that deﬁnition
R F is not necessarily locally
posetal.)
Given instance data D : B →Rel, we think of
R D as a graph database as follows. The
vertices of the graph are the objects (X, x) of
R D. The vertex labels (or vertex types) are
the objects X of B, given by the canonical projection functor
R
B D →B. The directed edges
of the graph are morphisms (X, x)
R−→(Y, y) of
R D. The edge labels (or edge types) are the
morphisms R of B, again given by the projection functor
R
B D →B. As an example, the
instance data for the FOAF ontology yields the graph database:
P1
Person
P2
Person
P3
Person
P4
Person
knows
knows
friend of
friend of
knows
knows
As with relational databases, the idealized graph database interpretation may require modiﬁca-
tion to accommodate real-world database systems. The size of the graph can be considerably
reduced by representing maps with “primitive type” codomains (e.g., “Number” or “String”)
as “vertex properties,” a feature supported by most graph databases. Symmetric relations,
such as “knows” and “friend of,” can be represented by one undirected edge instead of two
directed edges. Another issue, not arising with relational databases, is the representation of
relations whose domain or codomain is a product of basic types, such as the “salary” relation.
If the database included vertices only for basic types, we would need directed hyperedges
[Gal+93], a feature not supported by most graph databases. The solution is to include
vertices for product types and edges for the projection morphisms. In fact, this encoding is
accomplished automatically by the monoidal product in the category of elements.
30

6.3. Boolean matrices
We now consider instance data derived from the matrix calculus of relations. Unlike relational
and graph databases, the matrix calculus has no analogue for functional ologs. It is a special
case of categorical matrix calculus, which can be performed in any biproduct category [CP10,
§3.5.5], [Har09].
Let B = {0, 1} be the commutative “rig” (commutative ring without negatives) of booleans,
whose operations are deﬁned by
0 + 0 = 0,
0 + 1 = 1 + 0 = 1,
1 + 1 = 1
0 · 0 = 0,
0 · 1 = 1 · 0 = 0,
1 · 1 = 1.
That is, addition in B is logical disjunction and multiplication in B is logical conjunction.
Deﬁnition. The category Mat(B) of boolean matrices has as objects the natural numbers
and as morphisms m →n the m × n matrices over B. Composition is deﬁned by matrix
multiplication and the identity morphisms are the identity matrices.
We interpret a matrix R ∈Bm×n as a relation with domain [m] = {1, . . . , m} and codomain
[n] = {1, . . . , n}, where individual i ∈[m] is in relation R with individual j ∈[n] if and only
if Ri,j = 1. As expected, composition in Mat(B) is given by existential quantiﬁcation:
(R · S)i,k = 1
iﬀ
∃j : Ri,j = 1 ∧Sj,k = 1.
The category of boolean matrices is a bicategory of relations. There is a 2-morphism R ⇒S if
and only if R ≤S (elementwise). The monoidal product is the tensor product of matrices:
R  S :=




R1,1S
· · ·
R1,nS
...
...
...
Rm,1S
· · ·
Rm,nS



.
The diagonals are deﬁned by
∆n :=

e1e⊤
1
· · ·
ene⊤
n

∈Bn×n2
and
♦n :=




1
...
1



∈Bn×1,
where ei is the ith standard basis vector. With these deﬁnitions, the dagger is simply the
matrix transpose, R† = R⊤. Given matrices R, S ∈Bm,n, a quick calculation shows that local
intersections are given by the elementwise (Hadamard) product:
R ∩S := ∆m(R  S)∇n =




R1,1S1,1
· · ·
R1,nS1,n
...
...
...
Rm,1Sm,1
· · ·
Rm,nSm,n



=: R  S.
Thus we recover the usual intersection of relations.
31

Anticipating Section 9, we equip Mat(B) with a second monoidal product, the direct sum of
matrices:
R  S :=
 
R
0
0
S
!
.
Deﬁne a codiagonal with respect to the direct sum by
▼n :=
 
In
In
!
∈B2n×n
and
■n := () = 0 × n matrix,
where In is the n × n identity matrix. We recover unions of relations from the formula
R ∪S := ▲m(R  S)▼n = R + S.
This construction will be revisited and generalized in Section 9.
Matrix data—instance data in the category of boolean matrices—for a relational olog B is
a structure-preserving functor D : B →Mat(B). Each basic type X of B is mapped to a
natural number D(X) and each basic relation R : X →Y is mapped to a D(X) × D(Y )
matrix D(R) over B, such that all the subsumption axioms of B are satisﬁed. For example,
the instance data for the FOAF ontology becomes
D(friend of) =





0
1
0
0
1
0
0
0
0
0
0
0
0
0
0
0




,
D(knows) =





0
1
0
0
1
0
0
0
0
0
0
1
0
0
1
0




.
The two matrices are symmetric because the corresponding relations in B are. Note that
relations with (theoretically) inﬁnite domain or codomain, such as “family name,” “given
name,” and “salary,” cannot be represented as matrices.
The matrix representation of relations plays an important role in data analysis applications.
A symmetric relation R with the same domain and codomain, such as the “friend of” relation,
is often regarded as an undirected graph, with D(R) its adjacency matrix. This simple
observation is the starting point of the spectral analysis of network data, a rich and active
area of statistical research [Mah16]. Matrix data oﬀers yet another example of how instance
data can be used to connect an ontology to another computational system in a mathematically
precise way.
6.4. Linear relations
Relational and graph databases are both realized by functors D : B →Rel, and matrix data
can be regarded as a repackaged functor D : B →FinRel, where FinRel is the category
of ﬁnite sets and relations. On the basis of these examples one might suppose that, in
general, instance data amounts to a functor into Rel. That would be mistaken. In this
section, we describe a counterexample of practical signiﬁcance, the category of linear relations.
This category has been studied by Baez and Erbele [BE15], and independently by Bonchi,
32

Sobociński, and Zanasi [BSZ14], as a model of signal ﬂow diagrams in control theory. Note
that the material in this section is peripheral to the main development of the paper and can
be skipped without loss of continuity.
Deﬁnition. The category of linear relations, denoted VectRelk, is the category whose
objects are ﬁnite-dimensional vector spaces (over a ﬁxed ﬁeld k) and whose morphisms
L : U →V are linear relations, which are vector subspaces
L ⊆U  V.
Composition and identity morphisms are deﬁned as in Rel; thus, given linear relations
L : U →V and M : V →W, the composite LM : U →W is
LM = {(u, w) | ∃v ∈V : (u, v) ∈L ∧(v, w) ∈M} .
The category of linear relations is a bicategory of relations. The 2-morphisms are subspace
inclusions. The monoidal product is the direct sum (which we always write as , not ) and
the monoidal unit is the zero vector space. The diagonal is deﬁned by
∆V :
( V →V  V
v 7→(v, v)
and
♦V :
( V →{0}
v 7→0.
Given these deﬁnitions, the maps in VectRelk are just linear maps, in the usual sense. Be
warned that the dagger is not the matrix transpose, in contrast to Mat(B); indeed, the
transpose of a linear map is always another linear map, but f † is not a linear map unless f is
invertible. As in Rel, the dagger simply eﬀects a formal exchange of inputs and outputs.
However, the linear transpose leads to interesting structure not present in Rel. The transpose
of the duplication map ∆V is the addition map
▼V := ∆⊤
V :
( V  V →V
(v1, v2) 7→v1 + v2
and the transpose of the deletion map ♦V is the zero map
■V := ♦⊤
V :
( {0} →V
0 7→0.
The linear relations ▲V := ▼†
V : V →V  V and ♦V := ■†
V : V →{0} are called coaddition
and cozero, respectively.
The family of maps (▼V , ■V ) form a codiagonal structure on VectRelk. Moreover, every
linear relation L : U →V is a lax monoid homomorphism with respect to this structure,
meaning that
(L  L)▼V =⇒▼UL
and
■V =⇒■UL.
The duality exhibited here motivates the following deﬁnition.
33

Deﬁnition ([CW87, §5]). An abelian bicategory of relations is locally posetal 2-category
B that is also a symmetric monoidal category (B, , I) with diagonals (X, ∆X, ♦X) and
codiagonals (X, ▼X, ▲X) such that
• every morphism R : X →Y is a lax comonoid homomorphism and a lax monoid
homomorphism;
• the morphisms ∆X, ♦X, ▼X, ■X have right adjoints, denoted ∇X, □X, ▲X, ♦X;
• both pairs (∆X, ∇X) and (▲X, ▼X) obey the Frobenius equations.
Remark. An equivalent, more succinct deﬁnition is that an abelian bicategory of relations is
a locally posetal 2-category B such that both B and Bco are bicategories of relations with
respect to the same monoidal product. Here Bco is the 2-category B with all 2-morphisms
reversed. See Section 9 for further discussion.
The category of linear relations, VectRelk is an abelian bicategory of relations. The usual
category of relations, Rel, is not an abelian bicategory of relations.
The category of linear relations would obviously be an inappropriate data category for
the FOAF ontology. Linear relations are useful for representing systems of linear ordinary
diﬀerential equations (ODEs), as argued by Baez and Erbele [BE15]. The graphical language of
monoidal categories then formalizes the signal ﬂow diagrams that appear in control theory and
other engineering ﬁelds. In this setting, one takes the ﬁeld k = R(s), the real numbers R with
a formally adjoined indeterminate s. Upon taking Laplace transforms, diﬀerentiation becomes
the linear operation of scalar multiplication by s and integration becomes multiplication by
1/s. A linear relation L : km →kn is a system of linear, constant-coeﬃcient ODEs with m
input signals and n output signals.
The damped, driven harmonic oscillator provides a simple, one-dimensional example. The
equation of motion is
md2x
dt2 + β dx
dt + κx(t) = F(t),
where x is a position or angle and F is a driving force. Provided the oscillations are not too
large, this equation accurately describes a mass on a spring or a pendulum under gravity,
subject to an additional driving force. The system can be represented by a linear relation
k →k with input F and output x:
m
R
β
R
κ
The dark nodes are coaddition and the light nodes are coduplication. It is perhaps easier to
read the diagram from right to left, noting that the formal inverse of the integration map
34

R is the diﬀerentiation map
d
dx. The same diagram is drawn in conventional engineering
notation in [Fri12, Fig. 2.1]. A string diagram for a more complicated system, the “inverted
pendulum,” is presented in [BE15, §5].
Like the previous data categories, the category of linear relations deserves a more compre-
hensive treatment than space here permits. We include it mainly as a concrete example
of the “non-standard” instance data enabled by functorial semantics. The possibility of
instance data with extra algebraic or topological structure is a distinctive—and sometimes
useful—feature of categorical knowledge representation that is not easily replicated in a
purely logical system.
7. Types and the open-world assumption
The use of types is another distinctive feature of categorical knowledge representation. Unlike
instance data, types can be added to existing logical systems without too much diﬃculty; we
shall do so in Section 8. Nonetheless, we regard types as distinctive because category theory
is typed “by default,” while logic is not, and because, as a practical matter, the knowledge
representation systems in common use are untyped. In this section, we discuss the signiﬁcance
of types for knowledge representation.
The reader may be puzzled by the claim that knowledge representation frameworks based
on description logic are untyped. Isn’t the assignment of individuals to concepts a form of
typing? Indeed, isn’t a primary purpose of description logic to taxonomize the types of things
existing in a given domain via a hierarchy of interrelated concepts? If so, what could be the
purpose of adding a second, explicit form of typing to the system? These questions have
merit and we shall try to answer them in this section.
First, we explain why description logic is untyped. Consider the relation “friend of” from
the FOAF ontology (Section 5.1). We want to express that only people can be friends. In
description logic, we would use a value restriction (see Sections 2 and 3) to ensure that any
two individuals in the “friend of” relation belong to the concept “Person.” Then, given any
two individuals belonging to the disjoint concept “Organization,” the answer to the question
“Are the two entities friends?” would be “No.” On one view that is a perfectly reasonable
answer. But on another it is confused. We might argue that the answer to the question is
neither “yes” nor “no” because the question does not make sense. Organizations are simply
not the kind of things that can be friends with each other. Merely by asking whether two
organizations are friends, we commit a category mistake—using “category” in the sense of
Gilbert Ryle, not Eilenberg and Mac Lane. A programmer would call it a type error. These
two possible responses illustrate the philosophical diﬀerence between classes and types.
More prosaically, in description logic any concepts are comparable, while in relational ologs
only relations with the same domain and codomain are comparable. Thus, in description
logic, there is a universal concept, to which all individuals belong, and it is possible to take
the intersection of any two concepts. By contrast, a relational olog has only local maxima
and local intersections within each collection of typed relations X →Y .
35

These distinctions have practical implications for knowledge representation. To bring this
out, we consider two diﬀerent methods of constructing a taxonomy of entities in a relational
olog. This task, although probably overrepresented in KR research, is important in many
applications. The ﬁrst method, eﬀectively untyped, is based on subsumption of concepts with
a single domain type. The second method creates a hierarchy of diﬀerent types connected by
inclusion maps.
We shall see that the diﬀerence between the two methods is related to the open and closed
world assumptions in database theory and knowledge representation [Rei78]. Under the open
world assumption, any statements that are not deducible from a knowledge base are not
assumed to be either true or false. Under the closed world assumption, certain statements that
are not deducible are assumed to be false. The open world assumption is the standard mode
of reasoning in logical systems, including ﬁrst-order logic and description logic. The closed
world assumption is commonly used in databases and ruled-based knowledge representation.
For example, in the database for the FOAF ontology (Section 6.1), the absence of a row in
the “friend of” table for Alice and Carol is interpreted as the absence of friendship between
Alice and Carol—not the absence of knowledge of whether Alice and Carol are friends. More
generally, closed world reasoning makes assumptions about what is true based on what is not
explicitly stated.
To create a taxonomy in the style of description logic, we work with concepts C : X →I
over a ﬁxed domain type X. The subsumption axiom C ⇒D asserts that every instance of
concept C : X →I is also an instance of concept D : X →I. A collection of such axioms
implicitly deﬁnes a hierarchy of concepts and sub-concepts. Inferences about concepts are
made under the open world assumption. In particular, no two concepts C, D are provably
disjoint unless there is a disjointness axiom C ∩D ⇒⊥(or disjointness can be inferred
from other axioms). Relational ologs support disjointness axioms through the extensions of
Section 9.
In a relational olog, it is also possible to represent a taxonomy as a hierarchy of types. For
each kind in the taxonomy we deﬁne a type X. To declare that type X is a subtype of type
Y , we add an inclusion map ι : X →Y . An inclusion of X into Y is simply a morphism
ι : X →Y that is an injective map. Injectivity is asserted by the axiom
ι
ι
X
X
Y
=
ι
X
Y
.
Given instance data F : B →Rel, the function F(ι) associates each element of F(X) with a
unique element of F(Y ), thereby identifying F(X) with a subset of F(Y ). In this way we
interpret X as a subtype of Y . Inferences about types in the hierarchy are made under what
amounts to a closed world assumption: unless explicitly stated, distinct types are unrelated.
Two types unconnected by any morphism are not merely “disjoint,” they occupy diﬀerent
universes. It is not permitted to contemplate their intersection.
36

These design patterns are not mutually exclusive, and we expect that they can be proﬁtably
combined. On one hand, the open world assumption enables inference about concepts that
are not recorded by, or even anticipated by, the creator of the ontology. It embodies the
ethos of the Semantic Web, which, like the World Wide Web, allows “anyone to say anything
about anything.” On the other hand, it can be inconvenient in scientiﬁc domains with a large
and tightly controlled vocabulary, such as biology and biomedicine. The Gene Ontology, for
example, contains tens of thousands of concepts related to genes and their biological functions
[Ash+00]. Many of them are disjoint, and all these constraints must be recorded. Graphical
ontology editors like Protégé simplify these tasks [Mus15], but omissions are still easy to
make. We suggest that a judicious use of typing could eliminate the most embarrassing errors
of this kind.
Some authors have tried to augment description logics like OWL with closed world reasoning
[KAH11; SKH11]. This work is partly motivated by the need for closed world reasoning when
an ontology is used “like a database” to make inferences about particular individuals. In
this context, it is instance data, not typing, that oﬀers a simple solution. Given a relational
olog B and instance data D : B →Rel, inference in B is open world (modulo constraints
imposed by the type system). By contrast, inference in the bicategory of relations D(B),
a subcategory of Rel, is closed world. For any two relations R, S : X →Y , there is a
subsumption D(R) ⇒D(S) in the database if and only if the table D(R) is a subset of
the table D(S). Assuming the database has complete information with respect to a given
population, if a subsumption D(R) ⇒D(S) holds at the instance level, then we can regard
the subsumption R ⇒S as valid for that population, even if R ⇒S cannot be deduced at
the knowledge level (in B). This is a form of closed world reasoning. Again, we see the utility
of a clean separation between universal and particular knowledge.
Another important use of types is to represent “concrete data types” like integers, real
numbers, and strings within an ontology. All practical description logic systems, including
OWL, support data types, but only though ad hoc extensions of the logical language [Baa+07,
§6.2]. We grant that software implementations may need to handle primitive data types
specially, but think it inelegant to distinguish in the mathematical formalism between
“abstract” types like “Person” and “Organization” and “concrete” types like numbers and
strings.
As others have observed, category theory builds a bridge between traditional mathematical
logic and programming language theory. In this setting, it connects description logic with
type theory. Relational ologs are based on simple type theory. Of the two basic algebraic
data types, we already have product types, and we shall introduce sum types in Section 9. We
could conceivably use a more sophisticated type system. For example, instead representing
subtypes by inclusions, we could add ﬁrst-class subtypes and polymorphism. Polymorphic
and other type theories have been extensively investigated in the context of categorical logic
[Cro93; Jac99].
In the programming language community, it is generally accepted that some amount of typing
increases the robustness and maintainability of software systems (although opinions diﬀer
greatly as to how much typing is desirable). Apart from low-level assembly languages, there
are virtually no programming languages in common use that are completely untyped. In
37

the same spirit, we argue that at least some typing is desirable in knowledge representation
systems. The extent and sophistication of the typing will depend on the application and on
personal preferences.
8. Categorical logic
There is a fundamental connection between relational ologs and logical formalisms for
knowledge representation. We foreshadowed this connection in Section 3 by deﬁning the
structures that make Rel into a bicategory of relations using logical, rather than set-theoretic,
notation. In fact, it is possible to reason about any bicategory of relations using ﬁrst-order
logic, in eﬀect pretending that it is Rel. This conclusion is perhaps surprising, since some
bicategories of relations, such as the category VectRel of linear relations (Section 6.4), look
“from the outside” quite diﬀerent than Rel.
The purpose of this section, and the attendant Appendix A, is to make precise the connection
between relational ologs and ﬁrst-order logic. Our results belong to categorical logic, which
represents both syntax and semantics as categories and interpretations of logical theories as
functors. The ﬁeld was initiated by Lawvere’s seminal thesis on the functorial semantics of
algebraic theories [Law63]. An important result of categorical logic, perhaps the best known
application of category theory to computer science, is that the simply-typed lambda calculus
is the internal language of cartesian closed categories [LS88; Cro93; Jac99]. In a similar spirit,
we prove that a certain fragment of ﬁrst-order logic, called “regular logic,” is the internal
language of bicategories of relations.
We now explain semiformally the correspondence between regular logic and bicategories of
relations. For details and proofs, we refer to Appendix A.
Regular logic is the fragment of ﬁrst-order logic with connectives ∃, ∧, ⊤, =. Unlike traditional
ﬁrst-order logic, regular logic is typed (cf. Section 7). Every variable x, free or bound, is
assigned a type A, expressed by writing x : A. To indicate the types of free variables, every
formula of regular logic is associated with a list of type assignments, called a context. Here
are some examples of formulas in context:
x : A, y : B | R(x, y) ∧S(x, y)
x : A, z : C | ∃y : B.(R(x, y) ∧S(y, z))
x : A, x′ : A, x′′ : A | (x = x′) ∧(x = x′′)
x : A | ⊤
In general, a formula in context has form Γ | ϕ, where ϕ is a formula and Γ is a context
containing all the free variables of ϕ.
A theory in regular logic, or regular theory, is deﬁned by the following data. There is a set of
basic types A, B, . . . and a set of relation symbols R, S, . . . . Each relation symbol R has a
ﬁxed signature (A1, . . . , An) that determines its arity and argument types. A regular theory
also has a set of axioms of form Γ | ϕ ⊢ψ, which we interpret as: “by assumption, ϕ implies
38

ψ in the context Γ.” Given a regular theory T, we say that Γ | ϕ entails Γ | ψ under the theory
T, or that Γ | ϕ ⊢ψ is a theorem of T, if Γ | ψ can be deduced from Γ | ϕ using the axioms of
T and the inference rules of the proof system for regular logic.
As an example, we deﬁne a regular theory capturing a fragment of the “friend of a friend”
ontology (Section 5.1). The types of the theory are “Person,” “Organization,” “Number,”
and “String.” Its relation symbols include
knows : (Person, Person),
friend of : (Person, Person),
works at : (Person, Organization),
salary : (Person, Organization, Number).
The symmetry of the “knows” relation is expressed by the axiom
x : Person, y : Person | knows(x, y) ⊢knows(y, x).
The “works at” relation is determined by
x : Person, y : Organization | ∃z : Number.(salary(x, y, z)) ⊣⊢works at(x, y),
where, as usual, ⊣⊢is shorthand for ⊢and ⊣(two axioms).
We establish a correspondence between regular theories and bicategories of relations. First,
to every regular theory T, we associate a bicategory of relations Cl(T), called the classifying
category of T. The classifying category is constructed directly from the syntax of regular logic.
Its objects are ﬁnite lists of types A = (A1, . . . , An), which can be regarded as α-equivalence
classes [Γ] of contexts Γ = x : A. Its morphisms are equivalence classes of formulas in context
[Γ; ∆|ϕ] : [Γ] →[∆], where equality of formulas is up to α-equivalence (renaming of variables)
and deducible logical equivalence under the axioms of T. For instance, in the “friend of a
friend” theory, we have
[x : Person; y : Org | ∃z : Number.(salary(x, y, z))] = [a : Person; b : Org | works at(a, b)].
The semicolon in the context partitions the free variables into domain and codomain; it serves
no logical purpose. To make Cl(T) into a bicategory of relations, we deﬁne composition,
products, and diagonals analogously to Rel (Section 3).
Conversely, to every small bicategory of relations B, we associate a regular theory Lang(B),
called the internal language of B. Its types are the objects of B and its relation symbols are
the morphisms of B. Note that Lang(B) necessarily has inﬁnitely many types and relation
symbols! The axioms of Lang(B) are chosen to guarantee that formulas corresponding to equal
morphisms are provably equivalent. To make sense of this statement, we must explain how
an arbitrary formula in context Γ | ϕ of Lang(B) can be interpreted as a morphism JΓ | ϕK of
B. The mapping J·K is essentially inverse to the constructions making the classifying category
into a bicategory of relations. We prove a soundness theorem for general interpretations of a
regular theory T in a bicategory of relations B, yielding a categorical semantics for regular
logic.
The main result of this section, proved in Appendix A, is that Cl is inverse to Lang in an
appropriate sense.
39

Theorem. With respect to typed regular logic, for every small bicategory of relations B, there
is an equivalence of categories
Cl(Lang(B)) ≃B
in
BiRel.
Consequently, we can regard regular theories and small bicategories of relations as “the same.”
Besides enriching our understanding of relational ologs, this result is potentially practically
useful, as it enables the transfer of tools and techniques between category theory and logic.
What should it mean to give “instance data” for a description logic knowledge base, assuming
it can be expressed as a regular theory T? We simply ask what data is required to give a
structure-preserving functor D : Cl(T) →Rel. What should be meant by a “translation”
T →T′ between knowledge bases T and T′? Again, we need only ask what data is needed
to give a functor F : Cl(T) →Cl(T′). We will not carry out these exercises here but it is
instructive to do so.
In the other direction, we can reason about a relational olog B by performing logical inference
in Lang(B). This observation is signiﬁcant because the computational aspects of category
theory are highly underdeveloped in comparison with logic. Much research on description
logic is directed towards its computability and complexity theory, and there is a long tradition
of computational ﬁrst-order logic. Many mature inference engines and theorem provers exist.
By contrast, the theory and practice of computational category theory, especially higher
category theory, is only now emerging [Mim14; KZ15; BKV16].
Bibliographic remarks
Regular logic has been thoroughly studied by categorical logicians
as the simplest fragment of ﬁrst-order logic with a quantiﬁer [Awo09; But98; Oos95]. Our
categorical semantics of regular logic is quite diﬀerent from the usual one. Conventionally,
a formula Γ | ϕ is interpreted as a subobject JΓ | ϕK of the object JΓK: an equivalence class
of monomorphisms into JΓK. A category suitable for such interpretations, called a regular
category, has all ﬁnite limits and “well-behaved” subobjects. The classifying category of
a regular theory is a regular category whose objects are (equivalence classes of) formulas
in context and whose morphisms are (equivalence classes of) formulas in context that are
provably functional. In our framework, the classifying bicategory of relations has as objects
(equivalence classes of) contexts and as morphisms (equivalence classes of) formulas in context.
The latter perspective seems more natural to us.
The germ of the above theorem is present already in the original paper of Carboni and
Walters [CW87, Remark 2.9 (iii)], but to our knowledge has never been carefully developed.
There are also strong connections between bicategories of relations and regular categories.
Given a regular category C, there is a bicategory of relations Rel(C) with the same objects
as C and with morphisms A →B equal to the subobjects of A × B—a construction that
predates and motivates Carboni and Walters’ paper. Yet not every bicategory of relations
arises in this way. Conversely, if a bicategory of relations B is functionally complete, then
Map(B) is a regular category [CW87, Theorem 3.5]. Yet in general Map(B) need not be a
regular category. Thus, to a limited extent, it is possible to pass between bicategories of
relations and regular categories.
40

9. More expressive relational ologs
Relational ologs, as developed so far, can express local intersections and maxima. As proved in
Section 8, their internal language is the regular (∃, ∧, ⊤, =) fragment of ﬁrst-order logic. It is
natural to ask for more expressive relational ologs allowing local unions and minima. In logical
terms, they should correspond to the coherent (∃, ∧, ∨, ⊤, ⊥, =) fragment of ﬁrst-order logic.
In this section, we develop such highly expressive relational ologs, called distributive relational
ologs. We follow the pattern established by Sections 3 to 5: ﬁrst, we present the relevant
monoidal structures on Rel; next, we abstract from Rel to formulate a general categorical
structure, called a distributive bicategory of relations; ﬁnally, we deﬁne a distributive relational
olog to be a ﬁnitely presented distributive bicategory of relations.
9.1. The category of relations, revisited
The category of relations has another interesting monoidal product, besides the Cartesian
product: the disjoint union. In this section, we explain disjoint unions from a categorical
perspective. As in Section 3, our presentation draws on the survey [CP10], especially §3.5 on
“classical-like” monoidal products.
The disjoint union (or tagged union) is deﬁned on objects of Rel by
X  Y := {(x, 1) : x ∈X} ∪{(y, 2) : y ∈Y }.
An element of X  Y is either an element of X or an element of Y , plus a special tag to
avoid ambiguity when X and Y intersect. Given morphisms R : X →Y and S : Z →W of
Rel, the disjoint union R  S : X  Z →Y  W is deﬁned by
(t, i)(R  S)(s, j)
iﬀ







R(t, s)
if i = j = 1
S(t, s)
if i = j = 2
⊥
otherwise
The monoidal unit is O := ∅, the empty set. Finally, the braiding morphism σX,Y : X  Y →
Y  X exchanges the tags. With these deﬁnitions, (Rel, , O) is a symmetric monoidal
category.
The category of relations is now equipped with two monoidal products. In general, when
working with two monoidal products  and , we call the ﬁrst product  the tensor and
the second product  the cotensor. To avoid confusion, we will always use “light” notation
for structures associated with the tensor and “dark” notation for structures associated with
the cotensor. What that means should become clear shortly.
We would like to reason about both monoidal products using a single graphical language.
Unfortunately, that is not entirely straightforward. The basic problem is that we now have
an eﬀectively three-dimensional language, with dimensions corresponding to composition,
the tensor, and the cotensor, but drawing pictures in dimensions greater than two is highly
41

impractical. We discuss (two-dimensional!) graphical languages for multiple products below.
For the moment, we work exclusively with the cotensor and can therefore employ, without
ambiguity, the usual graphical language of monoidal categories.
We now consider structures derived from the disjoint union. Deﬁne the codiagonals ▼X :
X  X →X and ■X : O →X on Rel by
(x, i)▼Xx′
iﬀ
x = x′.
Note that the initial morphism ■X must be the (typed) empty relation O →X. Deﬁne the
diagonals ▲X := ▼†
X : X →X  X and ♦X := ■†
X : X →O by duality. As in (Rel, , I),
these morphisms form special †-Frobenius monoids; in particular, they satisfy the Frobenius
equations.
The disjoint union is logically dual to the Cartesian product. The union R∪S of two relations
R, S : X →Y is ▲X(R  S)▼Y or, in graphical language,
R ∪S
=
X
R
S
Y
.
Similarly, the typed empty relation ⊥X,Y : X →Y , or local minimum, is ♦X · ■Y :
⊥X,Y
=
X
Y
.
In particular, the boolean ⊥: I →I is ⊥I,I = ♦I · ■I.
There is a categorical interpretation of logical duality. The familiar principle of 1-categorical
duality establishes a correspondence between a category C and its opposite Cop. In a bicategory
of relations, this form of duality is captured by the dagger functor. By analogy, in a 2-category
B, we can consider the 2-category Bco obtained from B by reversing all 2-morphisms. The
correspondence between B and Bco is duality at the level of 2-morphisms. If B is a bicategory
of relations, then 2-categorical duality is logical duality. Consider the situation in Rel. The
diagonals ∆X and ♦X are maps, and the codiagonals ▼X and ■X are also maps. Equivalently,
the diagonals ∆X and ♦X are maps in Rel, while the diagonals ▲X and ♦X are maps in
Relco. Thus (Relco, , O) is also a bicategory of relations, provided we verify the axiom on
lax monoid homomorphisms.
In fact, a stronger statement holds, breaking the symmetry between products and sums.
Unlike the diagonals ∆X and ♦X in (Rel, , I), the codiagonals ▼X and ■X in (Rel, , O)
are natural. That is, for every relation R : X →Y , we have (R  R)▼Y = ▼XR and
■XR = ■Y , or graphically
R
R
X
X
Y
=
R
X
Y
42

and
R
X
Y
=
Y
.
Likewise, we have ▲X(R  R) = R▲Y and R♦Y = ♦X. This situation motivates the following
deﬁnition.
Deﬁnition. Let (C, , O) be a symmetric monoidal category. The monoidal product  on C
is a
• a (categorical) product if there exists a diagonal (▲A, ♦A), natural in A;
• a (categorical) coproduct if there exists a codiagonal (▼A, ■A), natural in A;
• a biproduct if it both a product and coproduct, such that for any objects A1, A2, the
projection maps π1 = 1A1  ♦A2 and π2 = ♦A1  1A2, the inclusion maps ι1 = 1A1  ■A2
and ι2 = ■A1  1A2, and zero maps 0i,j = ♦Ai■Aj satisfy the equations
ιi · πj = δi,j :=



1Ai
if i = j
0i,j
if i ̸= j ,
i, j = 1, 2.
Remark. Although it is not immediately obvious, these deﬁnitions of “product” and “coproduct”
agree with the standard deﬁnitions via universal properties [HV12].
The category of relations is a biproduct category with respect to the disjoint union. Another
prime example of a biproduct category is (Vectk, ), the category of ﬁnite-dimensional vector
spaces and linear maps, equipped with the direct sum. The category of linear relations,
VectRelk, is not a biproduct category.
Interactions between monoidal products
We have hitherto studied the disjoint union only
in isolation. We now consider how the Cartesian product and disjoint union interact in Rel.
On the objects of Rel, there is a natural isomorphism
X  (Y  Z) ∼= (X  Y )  (X  Z),
given by (x, (w, i)) 7→((x, w), i), that expresses the distributivity of products over sums. In
words: having an element of X and an element of Y or Z is the same as having elements of
X and Y or elements of X and Z. Here is one possible general deﬁnition of distributivity in
a monoidal category.
Deﬁnition ([Jay93]). A distributive monoidal category is a symmetric monoidal category
(C, , I) with coproduct  that satisﬁes the distributive law: for any objects A, B, C, the
canonical distributivity morphism
(A  B)  (A  C) →A  (B  C),
determined by the universal property of the coproduct, is an isomorphism.
Remark. A rig category, or bimonoidal category, retains the distributive law but relaxes
the requirements that the tensor be symmetric and that the cotensor be the coproduct. It
categoriﬁes the classical algebraic structure known as a “rig” (ring without negatives) [BD98].
For the purposes of this paper, the extra generality of rig categories is unnecessary.
43

Besides Set and Rel, examples of distributive monoidal categories include Ab, the category
of abelian groups, and Vectk, the category of ﬁnite-dimensional vector spaces, both equipped
the tensor product  and the direct sum .
The distributive law extends to morphisms of Rel in a familiar way. For any three relations
R, S, T : X →Y , we have
R ∩(S ∪T) = (R ∩S) ∪(R ∩T).
It is tempting to display this equation diagrammatically:
R
S
T
=
R
S
R
T
.
As noted at the beginning of this section, diagrams involving two monoidal products take
us beyond the ﬁrmly established graphical language of monoidal categories. The picture
above relies on context derived from the copy and merge nodes to determine which monoidal
product is “active” at a given point. In this case the notation is unambiguous, but in general
one must take care to avoid coherence problems, especially when working with the monoidal
units. We conjecture that soundness is maintained if the cotensor is restricted to forming
unions (via the morphisms ▲X and ▼X) and local minima (via ♦X and ■X). This restricted
language is already suﬃcient for applications that do not directly utilize sum types, a special
case of some practical interest.
In the literature, proof nets are established as a graphical calculus for categories with
two monoidal products. Girad introduced proof nets in his seminal paper on linear logic
[Gir87]. Blute et al generalized the formalism to weakly distributive and ∗-autonomous
categories (models of linear logic), adopting a graphical style reminiscent of string diagrams
[Blu+96]. Unfortunately, proof nets are considerably more complicated than string diagrams,
accommodating monoidal units through special “thinning links.” In our view it remains an
open problem to deﬁne a graphical language for categories with multiple monoidal products
that is provably coherent—sound and complete—but still simple enough for practical use by
nonspecialists.
9.2. Distributive bicategories of relations
Motivated by distributivity in the category of relations, we deﬁne a categorical abstraction
called a “distributive bicategory of relations.” We begin with the following more general
deﬁnition.
44

Deﬁnition. A union bicategory of relations is a locally posetal 2-category B, a symmetric
monoidal category (B, , I) with diagonals (X, ∆X, ♦X), and a symmetric monoidal category
(B, , O) with codiagonals (X, ▼X, ▲X), such that
• every morphism R : X →Y is a lax comonoid homomorphism and a lax monoid
homomorphism;
• the morphisms ∆X, ♦X, ▼X, ■X have right adjoints, denoted ∇X, □X, ▲X, ♦X;
• both pairs (∆X, ∇X) and (▲X, ▼X) obey the Frobenius equations.
Equivalently, a union bicategory of relations is a locally posetal 2-category B such that both
B and Bco are bicategories of relations (not necessarily with respect to the same monoidal
product).
Remark. To our knowledge, this deﬁnition does not appear in the literature. Note that
Johnstone’s “union allegory” insists that unions are preserved by composition [Joh02, §A3.2];
under our deﬁnition of “union bicategory of relations,” the strongest statement that can
be made about the interaction between unions and composition is the logical dual of the
modular law, (R ∪TS†)S ⊆RS ∪T.
The deﬁnition postulates no relationship whatsoever between the two monoidal products. An
abelian bicategory of relations (Section 6.4) is a union bicategory of relations where the two
products coincide. In our main example VectRelk, the union L ∪M of two linear relations
L, M ⊆U  V is the vector space sum L + M. The other important special case of a union
bicategory of relations is the distributive bicategory of relations.
Deﬁnition. A distributive bicategory of relations is a union bicategory of relations where
the cotensor is the categorical coproduct.
We denote by DistBiRel the category of (small) distributive bicategories of relations and
structure-preserving functors.
Remark. Carboni and Walters mention “distributive” bicategories of relations in passing, but
do not clearly state a deﬁnition [CW87, Remark 3.7]. It seems likely that our deﬁnition is
what they had in mind. Freyd and Scedrov utilize an analogous concept of “distributive
allegory” [FS90].
Of course, Rel is a distributive bicategory of relations. Another example is the category of
boolean matrices, Mat(B), introduced in Section 6.3.
Several important properties are implicit in the deﬁnition.
As the name suggests, the
distributive law holds automatically in a distributive bicategry of relations. In fact, if (C, , I)
is any compact closed category and  is the coproduct, then C is a distributive monoidal
category [Jay93]. Moreover, it can be shown that intersections distribute over unions in
a distributive bicategory of relations. Also, the coproduct in a distributive bicategry of
relations is automatically a biproduct, by the symmetry of a dagger category. (Alternatively,
products or coproducts in a compact closed category are always biproducts [Hou08].) Table 3
summarizes the extra notation associated with a distributive bicategory of relations, extending
Table 2 in Section 4.
45

Structure
Name
Notation and deﬁnition
biproduct category
biproduct
R  S
braiding
σX,Y
merge
▼X
create
■X
copy
▲X := ▼∗
X = ▼†
X
delete
♦X := ■∗
X = ■†
X
logical
union
R ∪S := ▲X(R  S)▼Y
false
⊥:= ♦I · ■I
local minimum
⊥X,Y := ♦X · ■Y
Table 3: Summary of extra morphisms in a distributive bicategory of relations
Lastly, following the established pattern, we deﬁne a corresponding notion of olog. All
remarks made in Section 5 about the meaning of “ﬁnitely presented” remain in force.
Deﬁnition. A distributive relational olog is a ﬁnitely presented distributive bicategory of
relations.
Distributive relational ologs are very expressive. The only connectives of ﬁrst-order logic
not directly expressible are negation and universal quantiﬁcation. However, the negation,
or complement, of a relation R : X →Y can be implicitly deﬁned by introducing another
relation S : X →Y together with the two axioms R ∩S ⇒⊥X,Y and ⊤X,Y ⇒R ∪S. In
graphical language, the axioms are beautifully symmetric:
X
R
S
Y
=⇒
X
Y
X
Y
=⇒
X
R
S
Y
.
This deﬁnition of negation makes sense in any union bicategory of relations. In Rel, negation
is the usual set-theoretic complement; in VectRelk, it is the subspace complement (internal
direct sum).
9.3. Categorical logic with product and sum types
By now it should be evident that distributive relational ologs correspond, in some sense, to
the fragment of ﬁrst-order logic with connectives ∃, ∧, ∨, ⊤, ⊥, =. This fragment is called
coherent logic or, in older literature, geometric logic. Coherent logic, or variants thereof,
has been used in axiomatic geometry [ADM09] and in automated theorem proving [Sto+14;
46

GG16], in part because it is more readily interpretable by humans than richer logics. Coherent
logic is nonetheless as expressive as ﬁrst-order logic, in the sense that any ﬁrst-order theory
can be translated into an equivalent coherent theory called its Morleyization [Joh02, Lemma
D1.5.13]. In the Morleyized theory, negations are encoded by the two axioms shown above.
Despite the suggestive analogy, a direct translation of Section 8 founders, due to the presence
of sum types. In a bicategory of a relations, any two objects X and Y have a product X  Y ,
but our system of typed regular logic does not include product types. That is, the syntax
does not permit the construction of a type A × B from two basic types A and B. This
mismatch is, however, not fatal because products are smuggled into the logical system as
contexts: a context (x : A, y : B) amounts to a single variable of type A×B. Adding a second
monoidal product puts this device under considerable strain. One could conceivably extend
the syntax of a context to represent a fully “destructured” element of arbitrary compound
type. A better solution is to augment the logical language with product types A × B and
sum types A + B, as well as a unit (singleton) type 1 and zero (empty) type 0. The role of
contexts is downplayed accordingly.
Product and sum types are ubiquitous in programming language theory. The simply typed
lambda calculus is often treated with product and sum types, in both classical and categorical
settings [Sel13; LS88]. By contrast, ﬁrst-order logics with non-trivial type systems are rare.
A proof system for ﬁrst-order logic with product and sum types does not, to our knowledge,
appear in the literature. We now present such a system, straightforwardly adapted from the
lambda calculus. As in Section 8, the treatment here is informal. Details and proofs are
deferred to Appendix B.
Remark. A clariﬁcation may be helpful to readers acquainted with the Curry-Howard cor-
respondence [How80; Wad15]. The interpretation of types as propositions, and programs
as proofs, is the subject of a large body of research. However, we are interested in types
with logic, not types as logic. The former is sometimes called “two-level type theory.” An
example is Gambino and Aczel’s “logic-enriched type theory,” a system of ﬁrst-order logic
with dependent types [GA06].
By using a non-trivial type system, we commit ourselves to a proper treatment of terms. In
Section 8, we did not bother to distinguish the “terms” of regular logic, which are just typed
variables x : A. We now formally distinguish two kinds of expressions in context: formulas
(also called propositions) and terms. As before, the formulas are generated by the equality
relation, relation symbols, and logical connectives. The terms are generated by variables,
function symbols, and term constructors for the product and sum types.
The term constructors are familiar from typed lambda calculus. Given a term t : A × B,
there are projection terms π1(t) : A and π2(t) : B, and given two terms t : A and s : B, there
is a pair term ⟨t, s⟩: A × B. Dually, given terms t : A and s : B, there are inclusion terms
ι1(t) : A + B and ι2(s) : A + B, and given terms t : A + B, r : C, s : C, there is a copair term
δ (t, x : A.r, y : B.s) : C. The copair term, or “case statement,” is interpreted as follows. If
t : A + B is a value of type A, return the term r with variable x replaced by t. If t : A + B is
a value of type B, return the term s with variable y replaced by t. In either case, the result
is a value of type C.
47

We now sketch the correspondence between coherent logic with product and sum types and
distributive bicategories of relations. To every coherent theory T we associate the classifying
category Cl(T), a distributive bicategory of relations. Its objects are the types of T. Note the
diﬀerence from Section 8, where the objects of Cl(T) are ﬁnite lists of types. The morphisms
of Cl(T) are equivalence classes of formulas in context with exactly two free variables. The
types of these variables are the domain and codomain of the morphism. We make the
classifying category into a distributive bicategory of relations analogously to Rel (Sections 3
and 9.1).
Conversely, every small distributive bicategory of relations B has its internal language
Lang(B), a coherent theory. As before, we interpret an arbitrary formula in context Γ | ϕ of
Lang(B) as a morphism JΓ | ϕK of B. The construction proceeds analogously to Section 8,
with one important addition: terms are interpreted as maps. More precisely, a term in
context Γ | t : A is interpreted as a morphism JΓ | t : AK : JΓK →JAK of Map(B). Although
the connection between terms and maps is interesting its own right, in the present proof,
the interpretation of terms as maps serves only to establish the base case in the inductive
interpretation of formulas as morphisms.
Our main result, proved in Appendix B, is stated below.
Theorem. With respect to coherent logic with product and sum types, for every small
distributive bicategory of relations B, there is an equivlance of categories
Cl(Lang(B)) ≃B
in
DistBiRel.
It is also possible to realize the correspondence between regular logic and bicategories of
relations using a richer type system than in Section 8. The appropriate logic is regular logic
with product types and a singleton type (but not sum types or an empty type).
Theorem. With respect to regular logic with product types, for every small bicategory of
relations B, there is an equivalence of categories
Cl(Lang(B)) ≃B
in
BiRel.
10. Conclusion and outlook
In this paper, we have propounded a categorical framework for knowledge representation
centered around bicategories of relations. We emphasized three important features that
emerge automatically from category theory: instance data, types, and graphical syntax.
We compared our framework informally to description logic and formally to the regular
and coherent fragments of typed ﬁrst-order logic. In this ﬁnal section, we oﬀer a general
perspective on categorical knowledge representation. We also suggest directions for future
research.
We have extensively discussed the relationship between the algebraic and logical approaches
to knowledge representation, but have said comparatively little about how the two categorical
48

frameworks—functional and relational ologs—are related. Although a complete answer
is beyond the scope of this work, we will suggest a “pattern” or “template” for deﬁning
categorical ontologies that is general enough to encompass these and other frameworks. This
template can perhaps serve as a ﬁrst step towards a uniﬁed methodology of categorical
knowledge representation.
Doctrines are a useful organizing principle for category theory [KR77]. Informally, a doctrine
is a family of categories or higher categories with extra structure. The most basic doctrine is
the doctrine of categories (with no extra structure). There are also doctrines of categories with
ﬁnite products, of symmetric monoidal categories, of compact closed categories, of 2-categories,
of bicategories of relations, etc. Besides the categories themselves, a doctrine speciﬁes the
relevant kind of “structure-preserving” functors, and the natural transformations between
these. The concept of doctrine can be formalized, but for us this informal understanding is
perfectly adequate.
Here is a general recipe for constructing a categorical knowledge base. First, choose a doctrine.
This choice should be informed by the phenomena being modeled; we expand on this idea
below. Next, deﬁne a ﬁnitary speciﬁcation language for the doctrine. As above, the basic
strategy is ﬁnite presentation, a.k.a. the method of generators and relations, which works
in considerable generality. If the doctrine supports arbitrary limits or colimits, the method
of sketches can be used instead [Wel93; Mak97]. Alternatively, if the doctrine has as its
internal language some well-known logical system, that system could serve as a speciﬁcation
language. Finally, use the speciﬁcation language to deﬁne an ontology. As a mathematical
object, the ontology is simply a ﬁnitely generated category of the doctrine. Instance data for
the ontology is derived from the “prototype” category of the doctrine, such as Set or Rel, or
possibly from a more exotic category.
Some doctrines relevant to knowledge representation are listed in Table 4. Functional ologs
arise from the doctrine of categories with ﬁnite limits and colimits; relational ologs from the
doctrine of bicategories of relations. The typed lambda calculus is the internal language of
the doctrine of cartesian closed categories. Besides its central role in programming language
theory, the lambda calculus has been used to model natural languages [HK98]. This list by
no means exhausts the doctrines that are potentially useful for knowledge representation.
Diﬀerent doctrines are appropriate for diﬀerent applications. Bicategories of relations are
designed to model classes of entities (concepts) and the relationships between them (roles).
Description logic shares this orientation. However, creating taxonomies of concepts is hardly
the only worthwhile application of knowledge representation. As an example, the original
impetus for this work was our need to model knowledge about computer programs used
in data analysis. Description logics (and relational ologs) are ill-suited to this project; a
doctrine related to the lambda calculus is much more appropriate. In general, we worry that
the mainstream of KR research has unjustiﬁably privileged taxonomies over other kinds of
knowledge. Our philosophy is that category theory is a universal modeling language enabling
a more expansive understanding of knowledge representation. In the future, we hope to
see practical, ﬂexible knowledge representation systems that allow doctrines to be rapidly
assembled from the categorical toolbox to meet the needs of particular applications.
49

Doctrine
Prototype(s) Internal language
category
Set
category with ﬁnite (co)limits
Set
bicategory of relations
Rel
regular logic with product
types
distributive bicategory of relations
Rel
coherent logic with product
and sum types
cartesian closed category
Set, CPO
typed lambda calculus with
product types
bicartesian closed category
Set
typed lambda calculus with
product and sum types
Table 4: Selected doctrines relevant to knowledge representation
There are myriad directions for future research on categorical knowledge representation. We
mention a few that are directly relevant to relational ologs.
A glaring omission in this work is any discussion of automated inference. By contrast,
computationally tractable inference has been the prime directive of the description logic
community. The ﬁrst step for our project is to acknowledge that inference in a relational
olog is undecidable. This is true even without the extensions of Section 9. (One can see this
algebraically, by reduction from the word problems for monoids or groups, or logically, by
reduction from the decision problem for regular theories.)
There are two possible responses to the problem of undecidability. We could follow the DL
community in imposing language restrictions to achieve provable computational tractability.
The extensive DL literature would doubtless be very helpful in carrying out this program.
However, we worry that imposing ad hoc restrictions would do irredeemable violence to
the formalism’s elegance and expressivity. A second approach is to allow an unrestricted
language and settle for approximate inference. We share with Doyle and Patil the opinion
that this approach is undervalued by the description logic community [DP91]. In the statistics
and machine learning communities, the need for approximate inference in complex models
is an accepted fact of life. The contrast is especially stark because inference in ﬁrst-order
theories is harder than inference in probabilistic models. In any event, developing inference
algorithms for relational ologs, exact or approximate, is an important prerequisite for practical
applications.
Another problem, already raised in Section 9, is to deﬁne a graphical language for distributive
bicategories of relations that is coherent, yet intuitive. (We think that proof nets fall short
on the second count.) The graphical language of string diagrams is a very appealing feature
of relational ologs. We hope that a satisfactory extension of string diagrams to categories
with multiple monoidal products will be discovered.
50

Acknowledgments
I thank John Baez, David Spivak, and Ryan Wisnesky for helpful comments on the manuscript.
I am grateful to Thomas Icard for his encouragement of this project. Finally, I thank the
many contributors to the nLab for creating an invaluable online resource for aspiring and
professional category theorists.
References
[AC04]
Samson Abramsky and Bob Coecke. “A categorical semantics of quantum proto-
cols”. Logic in Computer Science, 2004. IEEE. 2004, pp. 415–425.
[ADM09]
Jeremy Avigad, Edward Dead, and John Mumma. “A formal system for Euclid’s
Elements”. The Review of Symbolic Logic 2.4 (2009), pp. 700–768.
[AG05]
Renzo Angles and Claudio Gutierrez. “Querying RDF data from a graph database
perspective”. European Semantic Web Conference. 2005, pp. 346–360.
[AG08]
Renzo Angles and Claudio Gutierrez. “Survey of graph database models”. ACM
Computing Surveys 40.1 (2008), p. 1.
[AL12]
Emilio Jesús Gallego Arias and James B. Lipton. “Logic programming in tabular
allegories”. Technical Communications of the 28th International Conference on
Logic Programming (ICLP’12). Vol. 17. Schloss Dagstuhl–Leibniz-Zentrum fuer
Informatik, 2012, pp. 334–347.
[Apa15]
Apache Software Foundation. TinkerPop3 Documentation. 2015. url: http:
//tinkerpop.apache.org/docs/current/reference/ (visited on 03/23/2017).
[Ash+00]
Michael Ashburner et al. “Gene Ontology: tool for the uniﬁcation of biology”.
Nature Genetics 25.1 (2000), pp. 25–29.
[Awo09]
Steve Awodey. “Introduction to Categorical Logic”. Lecture notes. 2009. url:
http://www.andrew.cmu.edu/user/awodey/catlog/notes/.
[Awo10]
Steve Awodey. Category Theory. 2nd ed. Oxford University Press, 2010.
[Baa+07]
Franz Baader, Diego Calvanese, Deborah L McGuinness, Daniele Nardi, and Peter
F Patel-Schneider, eds. The Description Logic Handbook: Theory, Implementation
and Applications. 2nd ed. Cambridge University Press, 2007.
[BD98]
John Baez and James Dolan. “Categoriﬁcation”. arXiv:math/9802029 (1998).
[BE15]
John Baez and Jason Erbele. “Categories in control”. Theory and Applications of
Categories 30.24 (2015), pp. 836–881.
[BF15]
John Baez and Brendan Fong. “A compositional framework for passive linear
networks”. arXiv:1504.05625 (2015).
[BH94]
Carolyn Brown and Graham Hutton. “Categories, allegories and circuit design”.
Logic in Computer Science, 1994. LICS’94. IEEE. 1994, pp. 372–381.
51

[BHL01]
Tim Berners-Lee, James Hendler, and Ora Lassila. “The Semantic Web”. Scientiﬁc
American 284.5 (2001), pp. 28–37.
[BJ94]
Carolyn Brown and Alan Jeﬀrey. “Allegories of circuits”. International Symposium
on Logical Foundations of Computer Science. Springer. 1994, pp. 56–68.
[BKV16]
Krzysztof Bar, Aleks Kissinger, and Jamie Vicary. “Globular: an online proof
assistant for higher-dimensional rewriting”. arXiv:1612.01093 (2016).
[BL04]
Ronald Brachman and Hector Levesque. Knowledge Representation and Reasoning.
Elsevier, 2004.
[BL84]
Ronald Brachman and Hector Levesque. “The tractability of subsumption in
frame-based description languages”. AAAI-84 Proceedings. AAAI. 1984, pp. 34–
37.
[Blu+96]
Richard F Blute, J Robin B Cockett, Robert A G Seely, and Todd H Trimble.
“Natural deduction and coherence for weakly distributive categories”. Journal of
Pure and Applied Algebra 113.3 (1996), pp. 229–296.
[BM14]
Dan Brickley and Libby Miller. FOAF Vocabulary Speciﬁcation 0.99. 2014. url:
http://xmlns.com/foaf/spec/20140114.html.
[BS10]
John Baez and Mike Stay. “Physics, topology, logic and computation: a Rosetta
Stone”. New Structures for Physics. Springer, 2010, pp. 95–172.
[BSZ14]
Filippo Bonchi, Paweł Sobociński, and Fabio Zanasi. “A categorical semantics of
signal ﬂow graphs”. International Conference on Concurrency Theory (CONCUR
2014). 2014, pp. 435–450.
[But98]
Carsten Butz. “Regular categories and regular logic”. BRICS Lecture Series
LS-98-2 (1998).
[Car+08]
Aurelio Carboni, G Max Kelly, Robert FC Walters, and Richard J Wood. “Carte-
sian bicategories II”. Theory and Applications of Categories 19.6 (2008), pp. 93–
124.
[Car86]
John Cartmell. “Generalised algebraic theories and contextual categories”. Annals
of Pure and Applied Logic 32 (1986), pp. 209–243.
[CLW93]
Aurelio Carboni, Stephen Lack, and Robert FC Walters. “Introduction to extensive
and distributive categories”. Journal of Pure and Applied Algebra 84.2 (1993),
pp. 145–158.
[Cod70]
Edgar F Codd. “A relational model of data for large shared data banks”. Com-
munications of the ACM 13.6 (1970), pp. 377–387.
[CP10]
Bob Coecke and Eric Oliver Paquette. “Categories for the practising physicist”.
New Structures for Physics. Springer, 2010, pp. 173–286.
[Cro93]
Roy L Crole. Categories for Types. Cambridge University Press, 1993.
[CW87]
Aurelio Carboni and Robert FC Walters. “Cartesian bicategories I”. Journal of
Pure and Applied Algebra 49.1-2 (1987), pp. 11–32.
52

[DP91]
Jon Doyle and Ramesh S Patil. “Two theses of knowledge representation: Language
restrictions, taxonomic classiﬁcation, and the utility of representation services”.
Artiﬁcial intelligence 48.3 (1991), pp. 261–297.
[DV10]
Ian Davis and Eric Vitiello Jr. RELATIONSHIP: A vocabulary for describing
relationships between people. 2010. url: http://vocab.org/relationship/.
[FDB06]
Marcelo Fiore, Roberto Di Cosmo, and Vincent Balat. “Remarks on isomorphisms
in typed lambda calculi with empty and sum types”. Annals of Pure and Applied
Logic 141.1-2 (2006), pp. 35–50.
[Fre72]
Peter Freyd. “Aspects of topoi”. Bulletin of the Australian Mathematical Society
7.1 (1972), pp. 1–76.
[Fri12]
Bernard Friedland. Control system design: an introduction to state-space methods.
Courier Dover Publications, 2012.
[FS90]
Peter J Freyd and Andre Scedrov. Categories, Allegories. Elsevier, 1990.
[GA06]
Nicola Gambino and Peter Aczel. “The generalised type-theoretic interpretation
of constructive set theory”. Journal of Symbolic Logic (2006), pp. 67–103.
[Gal+93]
Giorgio Gallo, Giustino Longo, Stefano Pallottino, and Sang Nguyen. “Directed
hypergraphs and applications”. Discrete Applied Mathematics 42.2 (1993), pp. 177–
201.
[GG16]
M Ganesalingam and W T Gowers. “A fully automatic theorem prover with
human-style output”. Journal of Automated Reasoning (2016), pp. 1–39.
[Gir87]
Jean-Yves Girard. “Linear logic”. Theoretical Computer Science 50.1 (1987),
pp. 1–101.
[Gra+08]
Bernardo Cuenca Grau, Ian Horrocks, Boris Motik, Bijan Parsia, Peter Patel-
Schneider, and Ulrike Sattler. “OWL 2: The next step for OWL”. Web Semantics:
Science, Services and Agents on the World Wide Web 6.4 (2008), pp. 309–322.
[Har09]
John Harding. “A link between quantum logic and categorical quantum mechan-
ics”. International Journal of Theoretical Physics 48.3 (2009), pp. 769–802.
[HK98]
Irene Heim and Angelika Kratzer. Semantics in generative grammar. Blackwell,
1998.
[HKR09]
Pascal Hitzler, Markus Krotzsch, and Sebastian Rudolph. Foundations of Semantic
Web Technologies. CRC Press, 2009.
[HKS05]
Ian Horrocks, Oliver Kutz, and Ulrike Sattler. “The irresistible SHIQ”. Proc. of
OWL: Experiences and Directions. 2005.
[HKS06]
Ian Horrocks, Oliver Kutz, and Ulrike Sattler. “The even more irresistible
SROIQ”. Proc. 10th Int. Conf. on Principles of Knowledge Representation
and Reasoning (KR’06). AAAI, 2006, pp. 57–67.
[Hou08]
Robin Houston. “Finite products are biproducts in a compact closed category”.
Journal of Pure and Applied Algebra 212.2 (2008), pp. 394–400.
53

[How80]
William A Howard. “The formulae-as-types notion of construction”. To H.B.
Curry: Essays on combinatory logic, lambda calculus and formalism 44 (1980),
pp. 479–490.
[HV12]
Chris Heunen and Jamie Vicary. Lectures on categorical quantum mechanics.
Computer Science Department, Oxford University. 2012.
[Jac95]
Bart Jacobs. “Parameters and parametrization in speciﬁcation, using distributive
categories”. Fundamenta informaticae 24.3 (1995), pp. 209–250.
[Jac99]
Bart Jacobs. Categorical logic and type theory. Vol. 141. Studies in Logic and the
Foundations of Mathematics. Elsevier, 1999.
[Jay93]
C Barry Jay. “Tail recursion through universal invariants”. Theoretical Computer
Science 115.1 (1993), pp. 151–189.
[Joh02]
Peter T Johnstone. Sketches of an elephant: A topos theory compendium. 2 vols.
Oxford University Press, 2002.
[KAH11]
Matthias Knorr, José Júlio Alferes, and Pascal Hitzler. “Local closed world
reasoning with description logics under the well-founded semantics”. Artiﬁcial
Intelligence 175.9-10 (2011), pp. 1528–1554.
[KN94]
Petrus Knijnenburg and Frank Nordemann. Two Categories of Relations. Tech.
rep. 94-32. Leiden University, Department of Computer Science, 1994.
[Koc04]
Joachim Kock. Frobenius algebras and 2-d topological quantum ﬁeld theories.
Cambridge University Press, 2004.
[KR77]
Anders Kock and Gonzalo Reyes. “Doctrines in categorical logic”. Handbook of
Mathematical Logic. Ed. by Jon Barwise. North Holland, 1977.
[KSH12]
Markus Krötzsch, Frantisek Simancik, and Ian Horrocks. “A description logic
primer”. arXiv:1201.4089 (2012).
[KZ15]
Aleks Kissinger and Vladimir Zamdzhiev. “Quantomatic: A proof assistant for
diagrammatic reasoning”. International Conference on Automated Deduction.
Springer. 2015, pp. 326–336.
[Lac10]
Stephen Lack. “A 2-categories companion”. Towards higher categories. 2010,
pp. 105–191.
[Law15]
Finn Lawler. “Fibrations of predicates and bicategories of relations”. arXiv:1502.08017
(2015).
[Law63]
F. William Lawvere. “Functorial Semantics of Algebraic Theories”. PhD thesis.
Columbia University, 1963.
[Lei14]
Tom Leinster. Basic category theory. Vol. 143. Cambridge University Press, 2014.
[LS09]
F William Lawvere and Stephen H Schanuel. Conceptual mathematics: a ﬁrst
introduction to categories. 2nd ed. Cambridge University Press, 2009.
[LS88]
Joachim Lambek and Philip J Scott. Introduction to higher-order categorical logic.
Cambridge University Press, 1988.
54

[Mac63]
Saunders Mac Lane. “Natural associativity and commutativity”. Rice University
Studies 49.4 (1963), pp. 28–46.
[Mac98]
Saunders Mac Lane. Categories for the working mathematician. 2nd ed. Vol. 5.
Graduate Texts in Mathematics. Springer-Verlag, 1998.
[Mah16]
Michael Mahoney. “Lecture notes on spectral graph methods”. arXiv:1608.04845
(2016).
[Mak97]
Michael Makkai. “Generalized sketches as a framework for completeness theorems.
Part I”. Journal of Pure and Applied Algebra 115.1 (1997), pp. 49–79.
[Mim14]
Samuel Mimram. “Towards 3-dimensional rewriting theory”. arXiv:1403.4094
(2014).
[Mus15]
Mark A Musen. “The Protégé project: A look back and a look forward”. AI
Matters 1.4 (2015), pp. 4–12.
[Nic+16]
Maximilian Nickel, Kevin Murphy, Volker Tresp, and Evgeniy Gabrilovich. “A
review of relational machine learning for knowledge graphs”. Proceedings of the
IEEE 104.1 (2016), pp. 11–33.
[Nie12]
Michael Nielsen. Reinventing Discovery: The New Era of Networked Science.
Princeton University Press, 2012.
[Noy+09]
Natalya F Noy et al. “BioPortal: ontologies and integrated data resources at the
click of a mouse”. Nucleic Acids Research (2009).
[Oos95]
Jaap van Oosten. “Basic Category Theory”. BRICS Lecture Series LS-95-1 (1995).
[Pat17]
Evan Patterson. epatters/Catlab: An experimental library for computational cate-
gory theory. Apr. 2017. doi: 10.5281/zenodo.569966.
[Pit95]
Andrew Pitts. Categorical logic. Tech. rep. University of Cambridge, Computer
Laboratory, 1995.
[PS08]
Eric Prud’hommeaux and Andy Seaborne, eds. SPARQL Query Language for RDF.
World Wide Web Consortium (W3C). 2008. url: https://www.w3.org/TR/rdf-
sparql-query/.
[PS97]
Frank Piessens and Eric Steegmans. “Proving semantical equivalence of data
speciﬁcations”. Journal of Pure and Applied Algebra 116.1-3 (1997), pp. 291–322.
[RB11]
Peter N Robinson and Sebastian Bauer. Introduction to bio-ontologies. CRC Press,
2011.
[Rei78]
Raymond Reiter. “On closed world data bases”. Logic and data bases. Springer,
1978, pp. 55–76.
[Rie16]
Emily Riehl. Category theory in context. Dover, 2016.
[RN10]
Marko A Rodriguez and Peter Neubauer. “Constructions from dots and lines”.
Bulletin of the American Society for Information Science and Technology 36.6
(2010), pp. 35–41.
[Sch+16]
Patrick Schultz, David I Spivak, Christina Vasilakopoulou, and Ryan Wisnesky.
“Algebraic databases”. arXiv:1602.03501 (2016).
55

[Sel07]
Peter Selinger. “Dagger compact closed categories and completely positive maps”.
Electronic Notes in Theoretical Computer Science 170 (2007), pp. 139–163.
[Sel10]
Peter Selinger. “A survey of graphical languages for monoidal categories”. New
Structures for Physics. Springer, 2010, pp. 289–355.
[Sel13]
Peter Selinger. “Lecture notes on the lambda calculus”. arXiv:0804.3434 (2013).
[Sel99]
Peter Selinger. “Categorical structure of asynchrony”. Electronic Notes in Theo-
retical Computer Science 20 (1999), pp. 158–181.
[SK12]
David I Spivak and Robert E Kent. “Ologs: a categorical framework for knowledge
representation”. PLoS One 7.1 (2012).
[SKH11]
Kunal Sengupta, Adila Alfa Krisnadhi, and Pascal Hitzler. “Local closed world
semantics: Grounded circumscription for OWL”. International Semantic Web
Conference. Springer. 2011, pp. 617–632.
[Spi12]
David I Spivak. “Functorial data migration”. Information and Computation 217
(2012), pp. 31–51.
[Spi14]
David I Spivak. Category theory for the sciences. MIT Press, 2014.
[Sto+14]
Sana Stojanović, Julien Narboux, Marc Bezem, and Predrag Janičić. “A vernacular
for coherent logic”. International Conference on Intelligent Computer Mathematics.
Springer. 2014, pp. 388–403.
[SW15]
David I Spivak and Ryan Wisnesky. “Relational foundations for functorial data mi-
gration”. Proceedings of the 15th Symposium on Database Programming Languages.
ACM. 2015, pp. 21–28.
[TG87]
Alfred Tarski and Steven Givant. A formalization of set theory without variables.
Vol. 41. American Mathematical Society, 1987.
[Wad15]
Philip Wadler. “Propositions as types”. Communications of the ACM 58.12 (2015),
pp. 75–84.
[Wel93]
Charles Wells. “Sketches: Outline with References”. With 2009 addendum. 1993.
url: http://www.cwru.edu/artsci/math/wells/pub/pdf/Sketch.pdf.
[Woo75]
William A Woods. “What’s in a link: Foundations for semantic networks”. Repre-
sentation and Understanding: Studies in Cognitive Science (1975), pp. 35–82.
[ZMS13]
Bartosz Zieliński, Paweł Maślanka, and Ścibor Sobieski. “Allegories for database
modeling”. International Conference on Model and Data Engineering. Springer.
2013, pp. 278–289.
A. Regular logic and bicategories of relations
The objective of this appendix to state carefully and prove the theorem of Section 8, estab-
lishing a correspondence between regular logic and bicategories of relations. The development
will be detailed yet terse, as we have already explained the main ideas behind the theorem in
Section 8.
56

Γ | x1 : A1
· · ·
Γ | xn : An
Γ | R(x1, . . . , xn)
(relation symbol R : A)
Γ | x : A
Γ | y : A
Γ | x = y
(equality)
Γ | ϕ
Γ, x : A | ϕ
(weakening)
Γ | ⊤
(truth)
Γ | ϕ
Γ | ψ
Γ | ϕ ∧ψ
(conjunction)
Γ, x : A | ϕ
Γ | ∃x : A.ϕ
(existential quantiﬁer)
Figure 1: Formation rules for regular logic
We ﬁrst deﬁne a formal system for regular logic. The syntax is borrowed from [Awo09] and
the proof system from [Joh02]. We depart from the standard formulation of regular logic only
by dispensing with function symbols. This convention is merely a convenience; Appendix B
shows how to incorporate function symbols.
Deﬁnition. A (multisorted) signature consists of
• a set of sorts or basic types, which we write generically as A, B, A1, B1, . . . , and
• a set of relation symbols, which we write as R, S, . . . , where each relation symbol R is
associated with a (possibly empty) ordered list of types (A1, . . . , An).
For brevity, we often use the vector notation A := (A1, . . . , An). To express that relation
symbol R has types A, we write R : A or R : (A1, . . . , An).
There is a countably inﬁnite set of variables x, y, z, . . . . Unlike in some typed logical calculi,
the variable symbols do not have ﬁxed types. Instead, we write x : A to express that x is a
variable of type A. A context is a (possibly empty) ﬁnite, ordered list of form
Γ = x : A = (x1 : A1, . . . , xn : An),
where the xi’s are distinct variables and the Ai’s are basic types.
With respect to a ﬁxed signature, the formulas in context of the regular language are
expressions of form Γ | ϕ, where Γ is a context and ϕ is a formula, as deﬁned inductively
by the formation rules in Figure 1. Formulas outside of a context have no deﬁnite meaning.
Note that the only terms in context of the regular language are variables, for which there is a
single formation rule:
Γ, x : A, Γ′ | x : A.
57

ϕ ⊢ϕ
(identity)
ϕ ⊢χ
χ ⊢ψ
ϕ ⊢ψ
(cut)
x : A | ϕ ⊢ψ
Γ | t : A
Γ | ϕ[t/x] ⊢ψ[t/x]
(substitution)
ϕ ⊢x = x
(x = y) ∧ϕ ⊢ϕ[y/x]
(equality)
ϕ ⊢⊤
(truth)
ϕ ⊢ψ
ϕ ⊢χ
ϕ ⊢ψ ∧χ
ϕ ∧ψ ⊢ϕ
ϕ ∧ψ ⊢ψ
(conjunction)
Γ, x : A | ϕ ⊢ψ
Γ | (∃x : A.ϕ) ⊢ψ
(existential quantiﬁer)
Γ | ϕ ∧(∃x : A.ψ) ⊢∃x : A.(ϕ ∧ψ)
[x /∈Γ]
(Frobenius)
Figure 2: Inference rules for regular logic
A sequent is an expression of form Γ | ϕ ⊢ψ, where Γ | ϕ and Γ | ψ are both formulas in
context. The inference rules for sequents are listed in Figure 2.
The statement of the inference rules assumes the following notational conventions. Contexts
that are constant across the premises and conclusion of a rule are omitted. The formulas in
context appearing in the rules are implicitly assumed to be well-formed. For example, the
existential quantiﬁer rule assumes that x does not appear freely in ψ because Γ | ψ must be
well-formed. The vector notation x = y is shorthand for x1 = y1 ∧· · · ∧xn = yn; likewise,
∃x : A is shorthand for ∃x1 : A1 · · · ∃xn : An. The expression ϕ[y/x] denotes the simultaneous
substitution of yi for xi, for 1 ≤i ≤n, in the formula ϕ.
Remark. Several inference rules deserve further comment.
• Substitution: Useful special cases of the substitution rule include the weakening and
strengthening rules
Γ | ϕ ⊢ψ
Γ, x : A | ϕ ⊢ψ
Γ, x : A | ϕ ⊢ψ
Γ | t : A
Γ | ϕ ⊢ψ
.
• Existential quantiﬁer: Given the other rules, the bidirectional existential quantiﬁer rule
is equivalent to the ∃-introduction and ∃-elimination rules [Jac99, Lemma 4.1.8]
Γ | t : A
Γ | ϕ ⊢ψ[t/x]
Γ | ϕ ⊢∃x : A.ψ
Γ | ϕ ⊢∃x : A.ψ
Γ, x : A | ψ ⊢χ
Γ | ϕ ⊢χ
.
58

• Frobenius: The so-called “Frobenius axiom,” linking conjunction and existential quan-
tiﬁcation, is superﬂuous in full ﬁrst-order logic with implication but is not deducible
from the other rules of regular logic [Joh02, p. 831]. The converse rule is deducible
[Joh02, p. 832]. The omission of the Frobenius rule in some standard texts on regular
logic, such as [Oos95] and [But98], is apparently an error.
Deﬁnition. A regular theory (with respect to a ﬁxed signature) is deﬁned by a set of sequents
in the signature, not necessarily ﬁnite, called the axioms of theory. Under a regular theory
T, a formula ϕ entails ψ, written Γ | ϕ ⊢T ψ, if the sequent Γ | ϕ ⊢ψ is deducible from the
axioms of T using the inference rules of regular logic (Figure 2). In this case we say that the
sequent Γ | ϕ ⊢ψ is an entailment or theorem of T.
We now begin to establish the correspondence between bicategories of relations and regular
logic by constructing the classifying category of a regular theory.
Deﬁnition. The classifying category of a regular theory T, denoted Cl(T), is the bicategory
of relations deﬁned as follows. Its objects are ﬁnite lists of basic types A : (A1, . . . , An).
Given a context Γ = x : A, we also write [Γ] := A. Its morphisms A →B are equivalence
classes of formulas in context,
[x : A; y : B | ϕ],
where the equivalence relation ∼is deﬁned by
(x : A, y : B | ϕ) ∼(x′ : A, y′ : B | ϕ′)
iﬀ
x : A, y : B | ϕ ⊣⊢T ϕ′[x/x′, y/y′].
In other words, the morphisms of Cl(T) are formulas in context up to α-equivalence and
logical equivalence under T. Here ⊣⊢T is shorthand for ⊣T and ⊢T, and the semicolon in a
context (Γ; Γ′) is an extralogical marker that partitions the context into the domain [Γ] and
codomain [Γ′] of the morphism [Γ; Γ′ | φ]. The 2-morphisms of Cl(T) are the entailments of T:
[Γ; Γ′ | ϕ] =⇒[Γ; Γ′ | ψ]
iﬀ
Γ, Γ′ | ϕ ⊢T ψ.
We now deﬁne the requisite structures to make the classifying category into a bicategory of
relations. Composition of morphisms is given by
[x : A; y : B | ϕ] · [y : B; z : C | ψ] := [x : A; z : C | ∃y : B.ϕ ∧ψ],
and the identity morphisms are
1A := [x : A; x′ : A | x = x′].
The monoidal product is deﬁned on objects by A  B := (A, B) and on morphisms by
[Γ; ∆| ϕ]  [Γ′; ∆′ | ψ] := [Γ, Γ′; ∆, ∆′ | ϕ ∧ψ].
The monoidal unit is the empty list I := (). The braidings are
σA,B := [x : A, y : B; y′ : B, x′ : A | (x = x′) ∧(y = y′)].
Finally, the diagonals are
∆A := [x : A; x′ : A, x′′ : A | (x = x′) ∧(x = x′′)]
♦A := [x : A | ⊤].
59

Lemma. The classifying category Cl(T) of a regular theory T is a bicategory of relations.
Proof. We must check that every axiom of a bicategory of relations can be deduced from the
inference rules of regular logic. The proofs are tedious but mechanical; we sketch a few to
illustrate what is involved and leave the rest to the reader.
First, we show that Cl(T) is a category. To prove that composition is associative, we must
show that the two formulas
x : A; w : D | ∃y : B.(ϕ ∧∃z : C.(ψ ∧χ))
x : A; w : D | ∃z : C.(∃y : B.(ϕ ∧ψ) ∧χ)
are equivalent in regular logic. In fact, both formulas are equivalent to
x : A; w : D | ∃y : B.∃z : C.(ϕ ∧ψ ∧χ).
The derivation relies crucially on the Frobenius rule. We omit the details and the proof of
the identity axiom of a category.
Next, we prove that Cl(T) is a locally posetal 2-category. It is obvious that Cl(T) is locally
posetal. The vertical composition axiom is immediate from the cut rule. To prove the
horizontal composition axiom, suppose we have two entailments
x : A, y : B | ϕ ⊢θ
and
y : B, z : C | ψ ⊢χ.
By the conjunction and weakening rules,
x : A, y : B, z : C | ϕ ∧ψ ⊢θ ∧χ.
Using the ∃-introduction rule and then the bidirectional ∃-rule, we obtain
x : A, z : C | ∃y : B.(ϕ ∧ψ) ⊢∃y : B.(θ ∧χ),
proving the validity of horizontal composition.
The axiom on lax comonoid homomorphisms amounts to two easily proved entailments,
namely
x : A; y′ : B, y′′ : B | ∃y : B.(ϕ ∧(y = y′) ∧(y = y′′)) ⊢ϕ[y′/y] ∧ϕ[y′′/y]
and
x : A | ∃y : B.ϕ ⊢⊤.
Finally, we mention that the adjoints of ∆A and ♦A exist and are equal to
∇A := [x′ : A, x′′ : A; x : A | (x′ = x) ∧(x′′ = x)]
and
□A := [; x : A | ⊤].
Next, we construct the internal language of a bicategory of relations. A preliminary deﬁnition
is:
60

Deﬁnition. An interpretation or model of a signature in a bicategory of relations B is
speciﬁed by
• for every basic type A, an object JAK of B;
• for every relation symbol R : A, a morphism JRK : JAK →I of B, where we deﬁne
JAK := JA1K  · · ·  JAnK.
If Γ = x : A is a context, we also write JΓK := JAK.
An interpretation of a signature extends to the full regular language in that signature. By
induction on the formation rules of regular logic (Figure 1), we assign to each formula in
context Γ, Γ′ | ϕ a morphism JΓ; Γ′ | ϕK : JΓK →JΓ′K of B. In interpreting a rule, we allow
ourselves to order the context variables and place the context semicolon however is most
convenient, with the understanding that any other arrangement can be achieved by a suitable
braiding and bending of wires. This ﬂexibility greatly simpliﬁes the notation.
• Relation symbol: Given a relation symbol R : A,
Jx : A, Γ | R(x)K := JRK  ♦JΓK.
• Equality: There are two cases: when the variables are distinct, set
JΓ, x : A; y : A | x = yK := ♦JΓK  1JAK;
when the variables are equal, set
JΓ | x = xK := ♦JΓK.
• Weakening: Given a morphism JΓ | ϕK : JΓK →I,
JΓ, x : A | ϕK := JΓ | ϕK  ♦JAK.
• Truth: JΓ; Γ′ | ⊤K := ⊤JΓK,JΓ′K = ♦JΓK□JΓ′K.
• Conjunction: Given morphisms JΓ; Γ′ | ϕK : JΓK →JΓ′K and JΓ; Γ′ | ψK : JΓK →JΓ′K,
JΓ; Γ′ | ϕ ∧ψK := ∆JΓK · (JΓ; Γ′ | ϕK  JΓ; Γ′ | ψK) · ∇JΓ′K.
• Existential quantiﬁer: Given a morphism JΓ; x : A | ϕK : JΓK →JAK,
JΓ | ∃x : A.ϕK := JΓ; x : A | ϕK · ♦JAK.
Deﬁnition. An interpretation J·K of the signature of a regular theory T in a bicategory of
relations B is an interpretation or model of T in B if it satisﬁes all the axioms of T, i.e, for
every axiom
Γ | ϕ ⊢ψ
of
T,
there is a 2-morphism
JΓ | ϕK =⇒JΓ | ψK
in
B.
The previous lemma can be interpreted as a completeness theorem, stating that the inference
rules of regular logic are suﬃcient to prove every axiom of a bicategory of relations. The next
lemma is a soundness theorem: it says that every inference rule of regular logic is valid in an
arbitrary bicategory of relations.
61

Lemma. Let J·K be an interpretation of a regular theory T in a bicategory of relations B.
For every theorem
Γ | ϕ ⊢T ψ
of
T,
there is a 2-morphism
JΓ | ϕK =⇒JΓ | ψK
in
B.
Proof. The proof is by induction on the derivation of a theorem of T. By the deﬁnition of
an interpretation, every axiom of T holds in B. Therefore, it suﬃces to show that every
inference rule of regular logic (Figure 2) is valid in B. We sketch these proofs below.
• Identity: Existence of identity 2-morphism.
• Cut: Vertical composition of 2-morphisms.
• Substitution: Omitted.
• Equality: Omitted.
• Truth: By the lax comonoid homomorphism axiom,
JΓ | ϕK = JΓ | ϕK · ♦I =⇒♦JΓK = JΓ | ⊤K .
• Conjunction: If JΓ; Γ′ | ϕK ⇒JΓ; Γ′ | ψK and JΓ; Γ′ | ϕK ⇒JΓ; Γ′ | χK, then
JΓ; Γ′ | ϕK = ∆JΓK(JΓ; Γ′ | ϕK  JΓ; Γ′ | ϕK)∇JΓ′K
⇒∆JΓK(JΓ; Γ′ | ψK  JΓ; Γ′ | χK)∇JΓ′K
= JΓ; Γ′ | ψ ∧χK .
That proves the ﬁrst conjunction rule. For the second, calculate
JΓ; Γ′ | ϕ ∧ψK = ∆JΓK(JΓ; Γ′ | ϕK  JΓ; Γ′ | ψK)∇JΓ′K
⇒∆JΓK(JΓ; Γ′ | ϕK  ♦JΓK□JΓ′K)∇JΓ′K
= JΓ; Γ′ | ϕK .
The proof of the third rule is similar.
• Existential quantiﬁer: Fix formulas JΓ; x : A | ϕK : JΓK →JAK and JΓ | ψK : JΓK →I.
By the weakening formation rule, JΓ; x : A | ψK = JΓ | ψK·□JAK. If there is an entailment
JΓ; x : A | ϕK ⇒JΓ; x : A | ψK, then
JΓ | ∃x : A.ϕK = JΓ; x : A | ϕK ♦JAK
⇒JΓ; x : A | ψK ♦JAK
= JΓ | ψK □JAK♦JAK
= JΓ | ψK .
The proof of the converse rule is similar.
62

• Frobenius: Given formulas JΓ | ϕK : JΓK →I and JΓ, x : A | ψK : JΓK →JAK, compute
JΓ | ϕ ∧(∃x : A.ψ)K = ∆JΓK(JΓ | ϕK  JΓ | ∃x : A.ψK)
= ∆JΓK(JΓ | ϕK  JΓ, x : A | ψK ♦JAK)
= ∆JΓK(JΓ | ϕK □JAK  JΓ, x : A | ψK)∇JAK♦JAK
= ∆JΓK(JΓ, x : A | ϕK  JΓ, x : A | ψK)∇JAK♦JAK
= JΓ; x : A | ϕ ∧ψK ♦JAK
= JΓ | ∃x : A.(ϕ ∧ψ)K .
Deﬁnition. The internal language of a small bicategory of relations B is the regular theory
Lang(B) deﬁned as follows. Its signature consists of
• a basic type A for every object A of B, and
• a relation symbol R : (A1, . . . , An) for every morphism R : A1  · · ·  An →I of B.
A sequent Γ | ϕ ⊢ψ is an axiom of Lang(B) if and only if JΓ | ϕK ⇒JΓ | ψK in B, where J·K is
the obvious interpretation of the signature of Lang(B) in B.
By the lemma, Lang(B) is interpretable in B and the theorems of Lang(B) are exactly the
2-morphism of B.
Remark. In general, a single morphism of B gives rise to many relation symbols of Lang(B),
e.g., if R : A →I is morphism and A = A1  A2, then there are relation symbols R : (A) and
R : (A1, A2).
We have now developed the machinery to state and prove the main theorem of Section 8.
Theorem. For every small bicategory of relations B, there is an equivalence of categories
Cl(Lang(B)) ≃B
in
BiRel.
Proof. To prove the equivalence, it suﬃces to construct a structure-preserving functor F :
Cl(Lang(B)) →B that is full, faithful, and essentially surjective on objects [Rie16, Theorem
1.5.9]. Deﬁne the functor F on objects by
F(A) := JAK = JA1K  · · ·  JAnK ,
where A = (A1, . . . , An) and each Ai is a basic type of Lang(B). If Γ = x : A is a context,
we also write F(Γ) := JΓK. Deﬁne F on morphisms [Γ; Γ′ | ϕ] : [Γ] →[Γ′] by
F([Γ; Γ′ | ϕ]) := JΓ; Γ′ | ϕK : F(Γ) →F(Γ′).
By the construction of the classifying category and the internal language, we have the
fundamental equivalence
[Γ; Γ′ | ϕ] ⇒[Γ; Γ′ | ψ] in Cl(Lang(B))
iﬀ
Γ, Γ′ | ϕ ⊢Lang(B) ψ
iﬀ
JΓ; Γ′ | ϕK ⇒JΓ; Γ′ | ψK in B.
63

In particular, the functor F is well-deﬁned and faithful. It is full because if R : A →B
is a morphism of B, then there exists a relation symbol R : (A, B) of Lang(B) such that
F(Jx : A; y : B | R(x, y)K) = R. Clearly, F is (essentially) surjective on objects.
It remains to prove that F is a structure-preserving functor. The fundamental equivalence says
that F preserves 2-morphisms. We must show that F also preserves composition, identities,
monoidal products, and all the other structures of a bicategory of relations. We prove that
F preserves composition and products of morphisms and omit the other straightforward
veriﬁcations. First, given morphisms [x : A; y : B | ϕ] and [y : B; z : C | ψ] of Cl(Lang(B)),
calculate
F([x : A; y : B | ϕ] · [y : B; z : C | ψ])
= F([x : A; z : C | ∃y : B.(ϕ ∧ψ)])
=
q
x : A; z : C | ∃y : B.(ϕ ∧ψ)
y
= (1JAK  ηJCK)
q
x : A, z : C; y : B | ϕ ∧ψ
y
♦JBK
= (1JAK  ηJCK)(
q
x : A; y : B | ϕ
y

q
z : C; y : B | ψ
y
)∇JBK♦JBK
= (1JAK  ηJCK)(
q
x : A; y : B | ϕ
y

q
y : B; z : C | ψ
y†)ϵJBK
=
q
x : A; y : B | ϕ
y
·
q
y : B; z : C | ψ
y
= F([x : A; y : B | ϕ]) · F([y : B; z : C | ψ]).
Given morphisms [x : A; y : B | ϕ] and [z : C; w : D | ψ], calculate
F([x : A; y : B | ϕ]  [z : C; w : D | ψ])
= F([x : A, z : C; y : B, w : D | ϕ ∧ψ])
=
q
x : A, z : C; y : B, w : D | ϕ ∧ψ]
y
= ∆(A,C)(
q
x : A, z : C; y : B, w : D | ϕ
y

q
x : A, z : C; y : B, w : D | ψ
y
)∇(B,D)
= (∆A  ∆C)(1A  σA,C  1C)
(
q
x : A; y : B | ϕ
y
 ♦C□D  ♦A□B  Jz : C; w : D | ψK)
(1B  σD,B  1D)(∇B  ∇D)
= (∆A  ∆C)(
q
x : A; y : B | ϕ
y
 ♦A□B  ♦C□D  Jz : C; w : D | ψK)(∇B  ∇D)
=
q
x : A; y : B | ϕ
y
 Jz : C; w : D | ψK
= F([x : A; y : B | ϕ])  F([z : C; w : D | ψ]).
The ﬁrst calculation is obscured by the wire bending needed to unpack the deﬁnitions, but
becomes transparent when rendered as a string diagram.
Remark. The inverse functor G : B →Cl(Lang(B)) in the equivalence is deﬁned on objects by
G(A) := A and on morphisms R : A →B by G(R) := [x : A; y : B | R(x, y)]. As an alternate
proof, it is possible to explicitly construct the natural isomorphisms F · G ∼= 1Cl(Lang(B)) and
G · F ∼= 1B.
64

B. Coherent logic and distributive bicategories of relations
In this appendix we prove the main theorem of Section 9.3, establishing a correspondence
between coherent logic with product and sum types and distributive bicategories of relations.
We present the logical system carefully because we cannot ﬁnd a comparable logic in the
literature. However, where the proof overlaps with Appendix A, we provide less detail.
We ﬁrst deﬁne a formal system for coherent logic with product and sum types. For the sake
of brevity, we refer to this system simply as “coherent logic.” We maintain the syntactic
conventions of Appendix A, including the vector notation. Our proof system is an amalgama-
tion of the usual proof systems for typed lambda calculus [Jac99; FDB06] and coherent logic
[Joh02] but with several important diﬀerences that we shall point out.
Deﬁnition (cf. [Jac95; Jac99]). A distributive signature consists of
• a set of basic types, which generates a set of types according to the BNF grammar
A, B ::= C | A × B | 1 | A + B | 0,
where C ranges over basic types;
• a set of function symbols f, g, h, . . . , each with ﬁxed domain type A and codomain type
B, written f : A →B;
• a set of relation symbols R, S, . . . , each with ﬁxed domain types A and B, written
R : (A, B).
Variables and contexts are deﬁned as in Appendix A. With respect to a ﬁxed distributive
signature, a term in context is an expression of form Γ | t : A, as deﬁned inductively by the
formation rules in Figure 3. Likewise, a formula in context is an expression Γ | ϕ deﬁned by
the formation rules in Figure 4.
A sequent is an expression Γ | ϕ ⊢ψ, where Γ | ϕ and Γ | ψ are both formulas in context.
The sequent Γ ⊢ϕ is shorthand for Γ | ⊤⊢ϕ. The inference rules for sequents are listed in
Figure 5. As before, we omit the context when it is the same in the premises and conclusion
of a rule.
Remark. We comment on the inference rules that diﬀer from both ﬁrst-order logic and
equational type theory. Most importantly, product types are treated exactly as in type theory
but sum types have a stronger axiomatization.
• Distributivity: Like the Frobenius rule, the distributivity axiom linking conjunction
and disjunction is superﬂuous in full ﬁrst-order logic but is not deducible from the
other rules of coherent logic [Joh02, p. 831]. The converse of the distributivity axiom is
deducible.
• Case: Our case rules cannot be expressed in simple type theory. Instead, type theory
postulates
⊢δ (t, x : A.s[ι1(x)/z], y : B.s[ι2(y)/z]) = s[t/z].
Given the other axioms, this rule can be deduced from our ﬁrst case rule but not
conversely.
65

Γ, x : A, Γ′ | x : A
(variable)
Γ | t : A
Γ | f(t) : B
(function symbol f : A →B)
Γ | t : A
Γ | s : B
Γ | ⟨t, s⟩: A × B
(pair)
Γ | t : A × B
Γ | π1(t) : A
Γ | t : A × B
Γ | π2(t) : B
(projection)
Γ | ∗: 1
(singleton)
Γ | t : A + B
Γ, x : A | r : C
Γ, y : B | s : C
Γ | δ (t, x : A.r, y : B.s) : C
(case)
Γ | t : A
Γ | ι1(t) : A + B
Γ | t : B
Γ | ι2(t) : A + B
(inclusion)
Figure 3: Formation rules for terms of coherent logic
Γ | t : A
Γ | s : B
Γ | R(t, s)
(relation symbol R : (A, B))
Γ | t : A
Γ | s : A
Γ | t = s
(equality)
Γ | ϕ
Γ, x : A | ϕ
(weakening)
Γ | ⊤
(truth)
Γ | ⊥
(falsity)
Γ | ϕ
Γ | ψ
Γ | ϕ ∧ψ
(conjunction)
Γ | ϕ
Γ | ψ
Γ | ϕ ∨ψ
(disjunction)
Γ, x : A | ϕ
Γ | ∃x : A.ϕ
(existential quantiﬁer)
Figure 4: Formation rules for formulas of coherent logic
66

• Empty: In simple type theory, the empty type is axiomatized by an empty function
⊥A : A obeying the formation and inference rules
t : 0
⊥A(t) : A
t : 0
s : A
⊢⊥A(t) = s
.
In particular, one can derive Γ, x : 0 | r = s for any terms r, s. We strengthen that result
to Γ, x : 0 | ⊥and discard the empty function ⊥A.
A coherent theory is deﬁned analogously to a regular theory.
Deﬁnition. The classifying category of a coherent theory T, denoted Cl(T), is the distributive
bicategory of relations whose objects are the types of T (basic or compound); whose morphisms
A →B are equivalence classes of formulas in context [x : A, y : B | ϕ], where equivalence is
up to α-equivalence and provable logical equivalence under T; and whose 2-morphisms are
the theorems of T.
The structures of a distributive bicategory of relations are deﬁned as follows.
• Category: Composition is deﬁned by
[x : A, y : B | ϕ] · [y : B, z : C | ψ] := [x : A, z : C | ∃y : B.(ϕ ∧ψ)]
and the identity morphisms are 1A := [x : A, x′ : A | x = x′].
• Tensor: On objects, A  B := A × B and I := 1; on morphisms,
[x1 : A1,y1 : B1 | ϕ]  [x2 : A2, y2 : B2 | ψ]
:= [x : A1 × A2, y : B1 × B2 |
∃x1 : A1.∃y1 : B1.(ϕ ∧π1x = x1 ∧π1y = y1)∧
∃x2 : A2.∃y2 : B2.(ψ ∧π2x = x2 ∧π2y = y2)]
= [x : A1 × A2, y : B1 × B2 | ϕ[π1x/x1, π1y/y1] ∧ψ[π2x/x2, π2y/y2]].
The braidings are
σA,B := [x : A × B, y : B × A | (π1x = π2y) ∧(π2x = π1y)].
• Cotensor: On objects, A  B := A + B and O := 0; on morphisms,
[x1 : A1,y1 : B1 | ϕ]  [x2 : A2, y2 : B2 | ψ]
:= [x : A1 + A2, y : B1 + B2 |
∃x1 : A1.∃y1 : B1.(ϕ ∧ι1x1 = x ∧ι1y1 = y)∨
∃x2 : A2.∃y2 : B2.(ψ ∧ι2x2 = x ∧ι2y2 = y)].
The braidings are
σA,B := [x : A + B, y : B + A |
∃x′ : A.∃y′ : B.((ι1x′ = x ∧ι2x′ = y) ∨(ι2y′ = x ∧ι1y′ = y))].
67

ϕ ⊢ϕ
(identity)
ϕ ⊢χ
χ ⊢ψ
ϕ ⊢ψ
(cut)
x : A | ϕ ⊢ψ
Γ | t : A
Γ | ϕ[t/x] ⊢ψ[t/x]
(substitution)
⊢x = x
(x = y) ∧ϕ ⊢ϕ[y/x]
x = y ⊢t = t[y/x]
(equality)
⊢π1(⟨t, s⟩) = t
⊢π2(⟨t, s⟩) = s
(projection)
⊢⟨π1(t), π2(t)⟩= t
(pair)
⊢δ (ι1(t), x : A.r, y : B.s) = r[t/x]
⊢δ (ι2(t), x : A.r, y : B.s) = s[t/y]
(inclusion)
Γ | ⊢(∃x : A.ι1(x) = t) ∨(∃x : B.ι2(x) = t)
Γ | (∃x : A.ι1(x) = t) ∧(∃x : B.ι2(x) = t) ⊢⊥
[x /∈Γ]
(case)
Γ | t : 1
Γ | ⊢t = ∗
Γ, x : 0 | ⊢⊥
(singleton & empty)
ϕ ⊢⊤
⊥⊢ϕ
(truth & falsity)
ϕ ⊢ψ
ϕ ⊢χ
ϕ ⊢ψ ∧χ
ϕ ∧ψ ⊢ϕ
ϕ ∧ψ ⊢ψ
(conjunction)
ϕ ⊢χ
ψ ⊢χ
ϕ ∨ψ ⊢χ
ϕ ⊢ϕ ∨ψ
ψ ⊢ϕ ∨ψ
(disjunction)
ϕ ∧(ψ ∨χ) ⊢(ϕ ∧ψ) ∨(ϕ ∧χ)
(distributivity)
Γ, x : A | ϕ ⊢ψ
Γ | (∃x : A.ϕ) ⊢ψ
(existential quantiﬁer)
Γ | ϕ ∧(∃x : A.ψ) ⊢∃x : A.(ϕ ∧ψ)
[x /∈Γ]
(Frobenius)
Figure 5: Inference rules for coherent logic
68

• Diagonals and codiagonals:
∆A := [x : A, y : A × A | ⟨x, x⟩= y]
♦A := [x : A, y : 1 | ⊤]
▼A := [x : A + A, y : A | δ (x, x1 : A.x1, x2 : A.x2) = y]
■A := [x : 0, y : A | ⊥].
Lemma. The classifying category Cl(T) of a coherent theory T is a distributive bicategory of
relations.
The proof of the lemma is monstrously long but similar in many respects to the completeness
proof in Appendix A. To exemplify the new considerations posed by product and sum types,
we prove a diﬀerent, “obvious” fact about local unions in the classifying category. We expect
this will exhaust the reader’s appetite for such calculations. We then proceed directly to the
construction of the internal language of a distributive bicategory of relations.
Proposition. Local unions in the classifying category of a coherent theory are given by logical
disjunction:
[x : A, y : B | ϕ] ∪[x : A, y : B | ψ] = [x : A, y : B | ϕ ∨ψ].
Proof. In an abuse of notation, we write [ϕ] := [x : A, y : B | ϕ] and [ψ] := [x : A, y : B | ψ].
By deﬁnition,
[ϕ] ∪[ψ] = ▲A([ϕ]  [ψ])▼B.
First, use the inclusion rules and the ﬁrst case rule to show that
▲A = [x : A, y : A + A | (ι1x = y) ∨(ι2x = y)]
▼B = [x : B + B, y : B | (x = ι1y) ∨(x = ι2y)].
Therefore,
([ϕ]  [ψ])▼B = [x′ : A + A, y : B | ∃y′ : B + B.(
((∃x : A.∃˜y : B.(ϕ[˜y/y] ∧ι1x = x′ ∧ι1˜y = y′))∨
(∃x : A.∃˜y : B.(ψ[˜y/y] ∧ι2x = x′ ∧ι2˜y = y′)))
∧(y′ = ι1y ∨y′ = ι2y))].
Use the Frobenius rule and the distributivity of existential quantiﬁers over disjunctions to put
the formula into prenex normal form, then distribute the conjunction over the disjunctions
to put the body into disjunctive normal form:
([ϕ]  [ψ])▼B = [x′ : A + A, y : B | ∃x : A.∃˜y : B.∃y′ : B + B.(
(ϕ[˜y/y] ∧ι1x = x′ ∧ι1˜y = y′ ∧ι1y = y′)∨
(ϕ[˜y/y] ∧ι1x = x′ ∧ι1˜y = y′ ∧ι2y = y′)∨
(ψ[˜y/y] ∧ι2x = x′ ∧ι2˜y = y′ ∧ι1y = y′)∨
(ψ[˜y/y] ∧ι2x = x′ ∧ι2˜y = y′ ∧ι2y = y′))].
69

The ﬁrst and last disjuncts are handled by the injectivity of the inclusions (deducible from
the inclusion rules), e.g.,
ι1˜y = y′ ∧ι1y = y′ ⊢ι1˜y = ι1y ⊢˜y = y.
Eliminate the two cross terms using the second case rule, e.g.,
ι1˜y = y′ ∧ι2y = y′ ⊢ι1˜y = ι2y ⊢⊥.
Upon simpliﬁcation the result is
([ϕ]  [ψ])▼B = [x′ : A + A, y : B | ∃x : A.((ϕ ∧ι1x = x′) ∨(ψ ∧ι2x = x′))].
The second half of the calculation is very similar and yields
[ϕ] ∪[ψ] = ▲A([ϕ]  [ψ])▼B = [x : A, y : B | ϕ ∨ψ].
Deﬁnition. An interpretation or model of a distributive signature in a distributive bicategory
of relations B is speciﬁed by
• for every basic type C, an object JCK of B;
• for every function symbol f : A →B, a morphism JfK : JAK →JBK of Map(B);
• for every relation symbol R : (A, B), a morphism JRK : JAK →JBK of B.
The extension of the interpretation to any type of the signature is implicit in the deﬁnition:
JA × BK = JAK  JBK ,
J1K = I,
JA + BK = JAK  JBK ,
J0K = O.
We also maintain the convention that Jx : AK := JAK := JA1K  · · ·  JAnK.
An interpretation of a distributive signature extends to the full coherent language in that
signature by induction on the term and formula formation rules. Each term in context Γ|t : A
is interpreted as a morphism JΓ | tK : JΓK →JAK of Map(B) as follows.
• Variable: JΓ, x : A, Γ′ | x : AK := ♦JΓK  1JAK  ♦JΓ′K.
• Function symbol: Given a function symbol f : A →B and a map JΓ | t : AK,
JΓ | f(t) : BK := JΓ | t : AK · JfK .
• Pair: Given maps JΓ | t : AK and JΓ | s : BK,
JΓ | ⟨t, s⟩: A × BK := ∆JΓK(JΓ | t : AK  JΓ | s : BK).
• Projection: Given a map JΓ | t : A × BK,
JΓ | π1(t) : AK := JΓ | t : A × BK (1JAK  ♦JBK)
JΓ | π2(t) : BK := JΓ | t : A × BK (♦JAK  1JBK).
• Singleton: JΓ | ∗: IK := ♦JΓK.
70

• Case: Given maps JΓ | t : A + BK, JΓ, x : A | r : CK, and JΓ, y : B | s : CK, deﬁne JΓ | δ (t, x : A.r, y : B.
to be
∆JΓK · (1JΓK  JΓ | t : A + BK) · dJΓK,JAK,JBK · (JΓ, x : A | rK  JΓ, y : B | sK) · ▼JCK,
where dX,Y,Z : X  (Y  Z) →(X  Y )  (X  Z) is the family of distributivity
isomorphisms in B.
• Inclusion: Given maps JΓ | t : AK and JΓ | s : BK,
JΓ | ι1(t) : A + BK := JΓ | t : AK  ■B
JΓ | ι2(s) : A + BK := ■A  JΓ | s : BK .
Each formula in context Γ; Γ′ | ϕ is interpreted as a morphism JΓ; Γ′ | ϕK : JΓK →JΓ′K of B as
follows.
• Relation symbol: Given a relation symbol R : (A, B) and two maps JΓ | t : AK and
JΓ | s : BK, deﬁne
JΓ | R(t, s)K := ∆JΓK(JΓ | t : AK JRK  JΓ | s : BK)ϵJBK.
where, as usual, ϵJBK = ∇JBK♦JBK.
• Equality: Given maps JΓ | t : AK and JΓ | s : AK,
JΓ | t = sK := ∆JΓK(JΓ | t : AK  JΓ | s : AK)ϵJAK
• Falsity: JΓ; Γ′ | ⊥K := ⊥JΓK,JΓ′K = ♦JΓK■JΓ′K.
• Disjunction: Given morphisms JΓ; Γ′ | ϕK : JΓK →JΓ′K and JΓ; Γ′ | ψK : JΓK →JΓ′K,
JΓ; Γ′ | ϕ ∨ψK := ▲JΓK · (JΓ; Γ′ | ϕK  JΓ; Γ′ | ψK) · ▼JΓ′K.
The other formation rules—weakening, truth, conjunction, and existential quantiﬁer—are
interpreted exactly as in Appendix A.
An interpretation or model of a coherent theory in a distributive bicategory of relations is
deﬁned analogously to an interpretation of a regular theory in a bicategory of relations. There
is also a corresponding soundness theorem.
Lemma. Let J·K be an interpretation of a coherent theory T in a distributive bicategory of
relations B. For every theorem
Γ | ϕ ⊢T ψ
of
T,
there is a 2-morphism
JΓ | ϕK =⇒JΓ | ψK
in
B.
Proof. As before, we must show that every inference rule of coherent logic (Figure 5) is valid
in B. We sketch the proofs for the rules that have not already been treated in Appendix A.
71

• Projection: The ﬁrst projection axiom ⊢π1⟨t, s⟩= t holds because
∆X(f  g)πY,Z = ∆X(f  g)(1Y  ♦Z) = ∆X(f  g♦Z) = ∆X(f  ♦X) = f
whenever f : X →Y and g : X →Z are maps.
The second projection axiom
⊢π2⟨t, s⟩= s is proved similarly.
• Pair: The pair axiom ⊢⟨π1(t), π2(t)⟩= t amounts to the equality
∆XY (πX,Y  π′
X,Y ) = (∆X  ∆Y )(1X  σX,Y  1Y )(1X  ♦Y  ♦X  1Y )
= (∆X  ∆Y )(1X  σX,Y ♦Y X  1Y )
= (∆X  ∆Y )(1X  ♦X  ♦Y  1Y )
= 1X  1Y = 1XY .
• Inclusion: The two inclusion axioms are dual to the two projection axioms, e.g.,
ιX,Y (f  g)▼Z = f for any two morphisms f : X →Z and g : Y →Z (which need not
be maps).
• Case: The ﬁrst case axiom ⊢(∃x : A.ι1x = t) ∨(∃x : B.ι2x = t) amounts to
□XY = ▲I(□XιX,Y  □Y ι′
X,Y )▼XY .
By the dual of the pair axiom, (ιX,Y  ι′
X,Y )▼XY = 1XY , it suﬃces to show that
□XY = ▲I(□X  □Y ), or equivalently
♦XY = (♦X  ♦Y )▼I =: [♦X, ♦Y ]
Because the inclusions are maps, we have ιX,Y ♦XY = ♦X and ι′
X,Y ♦XY = ♦Y , and
hence the last equation holds by the universal property of the coproduct. We omit the
proof of the second case axiom.
• Singleton: The unit I of the tensor is terminal in Map(B).
• Empty: For any objects X, Y of B, there is at most one morphism X  O →Y , which
must therefore be ⊥XO,Y . A similar result holds, with essentially the same proof, in a
distributive category; we refer to [CLW93, Proposition 3.2].
• Falsity: Dual to truth.
• Disjunction: Dual to conjunction.
• Distributivity: As mentioned in Section 9.2, the distributive law
R ∩(S ∪T) = (R ∩S) ∪(R ∩T)
holds in any distributive bicategory of relations.
The proof, which we omit, is a
calculation involving the canonical distributivity isomorphism.
Deﬁnition. The internal language of a small distributive bicategory of relations B is the
coherent theory Lang(B) deﬁned as follows. Its signature consists of
• for every object A of B, a basic type A;
• for every pair of types (A, B) and every morphism f : JAK →JBK of Map(B), a function
symbol f : A →B; and
72

• for every pair of types (A, B) and every morphism R : JAK →JBK of B, a relation
symbol R : (A, B).
A sequent Γ | ϕ ⊢ψ is an axiom of Lang(B) if and only if JΓ | ϕK ⇒JΓ | ψK in B. Throughout
the deﬁnition, J·K is the obvious interpretation of the signature of Lang(B) in the category B.
Remark. The expressivity of the internal language is not aﬀected by including function
symbols for the maps because every map is also associated with a relation symbol.
As in Appendix A, a single morphism of B can give rise to many function and relation
symbols of Lang(B). Moreover, despite replacing lists of types by compound types, it remains
the case that Lang(B) has “too many” types. For example, if A = A1  A2 is a product in B,
then both A and A1 × A2 are types in Lang(B). Although the types are isomorphic, they are
formally distinct. This discrepancy explains why the equivalence of categories in the theorem
below is not an isomorphism of categories.
Theorem. For every small distributive bicategory of relations B, there is an equivalence of
categories
Cl(Lang(B)) ≃B
in
DistBiRel.
Proof. It suﬃces to construct a structure-preserving functor F : Cl(Lang(B)) →B that
is full, faithful, and essentially surjective on objects. Deﬁne the functor F on objects by
F(A) := JAK and on morphisms by
F([x : A; y : B | ϕ]) := Jx : A; y : B | ϕK : F(A) →F(B).
The proof that F is well-deﬁned and has the requisite properties proceeds as in Appendix A.
We leave the details to the reader.
73

